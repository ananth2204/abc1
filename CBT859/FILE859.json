{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220013107000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 9288188, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 19, "INMDSNAM": "CBT.V500.FILE859.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 9288188, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 9288188, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE859.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x90\\x08'", "DS1TRBAL": "b'S\\xce'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x07\\x12\\x00\\x00\\x07\\x1b\\x00\\t\\x00\\x91'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04S\\x00A\\x01\\x110_\\x01\\x110_\\x022\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf8\\xf3@@@'", "ispf": {"version": "04.83", "flags": 0, "createdate": "2011-11-01T00:00:00", "modifydate": "2011-11-01T02:32:41", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-483"}, "text": "REGULAR CBT TAPE - VERSION 483    FILE:  859\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT483.FILE859\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 80 MEMBERS COUNTED; CUMULATIVE SIZE IS 87,612 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   11/01/11    02:32:41    GMT-4:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$ASMONE": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x02\\x00\\x00V\\x01\\x11)\\x9f\\x01\\x11)\\x9f\\t'\\x00/\\x00/\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@\"", "ispf": {"version": "02.00", "flags": 0, "createdate": "2011-10-26T00:00:00", "modifydate": "2011-10-26T09:27:56", "lines": 47, "newlines": 47, "modlines": 0, "user": "CLEMSON"}, "text": "//$ASMONE JOB ...installation jobcard...\n//*\n//* This model job will precompile, assemble and link a service\n//* processor module.  Adjust the JOB card above and SET statements\n//* below to be suitable for your site.\n//*\n//* This job assumes that you have installed the Clemson University\n//* Structured Macro package, and that the Structured Macro pre-\n//* compiler resides in your linklist (if not, add a STEPLIB to the\n//* //P step below.\n//*\n//*\n//  SET MEMBER=REQUIRED\n//  SET SRVLIB=prefix.SRV.SOURCE\n//  SET SRVLOAD=prefix.SRV.LOAD\n//  SET COPT='RENT'\n//  SET LOPT='RENT,REUS,REFR'\n//  SET SYSOUT='*'\n//*\n//P       EXEC PGM=MSC0150$\n//* STEPLIB  DD  DISP=SHR,DSN=&SRVLOAD\n//SYSPRINT DD  SYSOUT=A,DCB=BLKSIZE=141\n//SYSPUNCH DD  SPACE=(CYL,(1,1)),UNIT=SYSDA,DCB=BLKSIZE=3120,\n//             DSN=&&SRC,DISP=(,PASS)\n//SYSIN    DD  DISP=SHR,DSN=&SRVLIB.(&MEMBER.)\n//*\n//C       EXEC PGM=ASMA90,\n//             PARM='DECK,OBJECT,XREF(SHORT),TERM,&COPT',\n//             COND=(5,LT)\n//SYSLIB   DD  DISP=SHR,DSN=SYS1.MACLIB\n//         DD  DISP=SHR,DSN=&STRUCMAC.\n//         DD  DISP=SHR,DSN=&SRVLIB.\n//SYSPRINT DD  SYSOUT=&SYSOUT.,LRECL=121\n//SYSTERM  DD  SYSOUT=&SYSOUT.\n//SYSUT1   DD  DSN=&&SYSUT1,SPACE=(4096,(120,120),,,ROUND),UNIT=VIO\n//SYSLIN   DD  DSN=&&OBJ,SPACE=(3040,(40,40),,,ROUND),UNIT=VIO,\n//             DISP=(MOD,PASS),\n//             DCB=(BLKSIZE=3040,LRECL=80,RECFM=FBS,BUFNO=1)\n//SYSIN    DD  DSN=&&SRC,DISP=(OLD,DELETE)\n//SYSPUNCH DD  &OBJECT,DCB=BLKSIZE=80\n//*\n//L       EXEC PGM=IEWL,COND=(5,LT),PARM='LIST,MAP,&LOPT.'\n//SYSPRINT DD  SYSOUT=&SYSOUT\n//SYSUT1   DD  UNIT=VIO,SPACE=(CYL,(1,1)),DSN=&&UT1\n//SYSLIN   DD  DSN=&&OBJ,DISP=(OLD,DELETE),UNIT=SYSDA\n//         DD  DDNAME=SYSIN\n//SYSLMOD  DD  DSN=&SRVLOAD.(&MEMBER),DISP=SHR\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$BOILER": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x02\\x00\\x00V\\x01\\x11)\\x9f\\x01\\x11)\\x9f\\t'\\x00\\x10\\x00\\x10\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@\"", "ispf": {"version": "02.00", "flags": 0, "createdate": "2011-10-26T00:00:00", "modifydate": "2011-10-26T09:27:56", "lines": 16, "newlines": 16, "modlines": 0, "user": "CLEMSON"}, "text": "*---------------------------------------------------------------------*\n*  Copyright 2011 by Clemson University Research Foundation           *\n*                                                                     *\n*  Licensed under the Apache License, Version 2.0 (the \"License\");    *\n*  you may not use this file except in compliance with the License.   *\n*  You may obtain a copy of the License in this library as member     *\n*  $LICENSE, or from                                                  *\n*                                                                     *\n*      http://www.apache.org/licenses/LICENSE-2.0                     *\n*                                                                     *\n*  Unless required by applicable law or agreed to in writing,         *\n*  software distributed under the License is distributed on an \"AS    *\n*  IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either    *\n*  express or implied.  See the License for the specific language     *\n*  governing permissions and limitations under the License.           *\n*---------------------------------------------------------------------*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$LICENSE": {"ttr": 522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x02\\x00\\x00V\\x01\\x11)\\x9f\\x01\\x11)\\x9f\\t'\\x00\\xc9\\x00\\xc9\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@\"", "ispf": {"version": "02.00", "flags": 0, "createdate": "2011-10-26T00:00:00", "modifydate": "2011-10-26T09:27:56", "lines": 201, "newlines": 201, "modlines": 0, "user": "CLEMSON"}, "text": "                                 Apache License\n                           Version 2.0, January 2004\n                        http://www.apache.org/licenses/\n\n   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n   1. Definitions.\n\n      \"License\" shall mean the terms and conditions for use, reproduction,\n      and distribution as defined by Sections 1 through 9 of this document.\n\n      \"Licensor\" shall mean the copyright owner or entity authorized by\n      the copyright owner that is granting the License.\n\n      \"Legal Entity\" shall mean the union of the acting entity and all\n      other entities that control, are controlled by, or are under common\n      control with that entity. For the purposes of this definition,\n      \"control\" means (i) the power, direct or indirect, to cause the\n      direction or management of such entity, whether by contract or\n      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n      outstanding shares, or (iii) beneficial ownership of such entity.\n\n      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n      exercising permissions granted by this License.\n\n      \"Source\" form shall mean the preferred form for making modifications,\n      including but not limited to software source code, documentation\n      source, and configuration files.\n\n      \"Object\" form shall mean any form resulting from mechanical\n      transformation or translation of a Source form, including but\n      not limited to compiled object code, generated documentation,\n      and conversions to other media types.\n\n      \"Work\" shall mean the work of authorship, whether in Source or\n      Object form, made available under the License, as indicated by a\n      copyright notice that is included in or attached to the work\n      (an example is provided in the Appendix below).\n\n      \"Derivative Works\" shall mean any work, whether in Source or Object\n      form, that is based on (or derived from) the Work and for which the\n      editorial revisions, annotations, elaborations, or other modifications\n      represent, as a whole, an original work of authorship. For the purposes\n      of this License, Derivative Works shall not include works that remain\n      separable from, or merely link (or bind by name) to the interfaces of,\n      the Work and Derivative Works thereof.\n\n      \"Contribution\" shall mean any work of authorship, including\n      the original version of the Work and any modifications or additions\n      to that Work or Derivative Works thereof, that is intentionally\n      submitted to Licensor for inclusion in the Work by the copyright owner\n      or by an individual or Legal Entity authorized to submit on behalf of\n      the copyright owner. For the purposes of this definition, \"submitted\"\n      means any form of electronic, verbal, or written communication sent\n      to the Licensor or its representatives, including but not limited to\n      communication on electronic mailing lists, source code control systems,\n      and issue tracking systems that are managed by, or on behalf of, the\n      Licensor for the purpose of discussing and improving the Work, but\n      excluding communication that is conspicuously marked or otherwise\n      designated in writing by the copyright owner as \"Not a Contribution.\"\n\n      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n      on behalf of whom a Contribution has been received by Licensor and\n      subsequently incorporated within the Work.\n\n   2. Grant of Copyright License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      copyright license to reproduce, prepare Derivative Works of,\n      publicly display, publicly perform, sublicense, and distribute the\n      Work and such Derivative Works in Source or Object form.\n\n   3. Grant of Patent License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      (except as stated in this section) patent license to make, have made,\n      use, offer to sell, sell, import, and otherwise transfer the Work,\n      where such license applies only to those patent claims licensable\n      by such Contributor that are necessarily infringed by their\n      Contribution(s) alone or by combination of their Contribution(s)\n      with the Work to which such Contribution(s) was submitted. If You\n      institute patent litigation against any entity (including a\n      cross-claim or counterclaim in a lawsuit) alleging that the Work\n      or a Contribution incorporated within the Work constitutes direct\n      or contributory patent infringement, then any patent licenses\n      granted to You under this License for that Work shall terminate\n      as of the date such litigation is filed.\n\n   4. Redistribution. You may reproduce and distribute copies of the\n      Work or Derivative Works thereof in any medium, with or without\n      modifications, and in Source or Object form, provided that You\n      meet the following conditions:\n\n      (a) You must give any other recipients of the Work or\n          Derivative Works a copy of this License; and\n\n      (b) You must cause any modified files to carry prominent notices\n          stating that You changed the files; and\n\n      (c) You must retain, in the Source form of any Derivative Works\n          that You distribute, all copyright, patent, trademark, and\n          attribution notices from the Source form of the Work,\n          excluding those notices that do not pertain to any part of\n          the Derivative Works; and\n\n      (d) If the Work includes a \"NOTICE\" text file as part of its\n          distribution, then any Derivative Works that You distribute must\n          include a readable copy of the attribution notices contained\n          within such NOTICE file, excluding those notices that do not\n          pertain to any part of the Derivative Works, in at least one\n          of the following places: within a NOTICE text file distributed\n          as part of the Derivative Works; within the Source form or\n          documentation, if provided along with the Derivative Works; or,\n          within a display generated by the Derivative Works, if and\n          wherever such third-party notices normally appear. The contents\n          of the NOTICE file are for informational purposes only and\n          do not modify the License. You may add Your own attribution\n          notices within Derivative Works that You distribute, alongside\n          or as an addendum to the NOTICE text from the Work, provided\n          that such additional attribution notices cannot be construed\n          as modifying the License.\n\n      You may add Your own copyright statement to Your modifications and\n      may provide additional or different license terms and conditions\n      for use, reproduction, or distribution of Your modifications, or\n      for any such Derivative Works as a whole, provided Your use,\n      reproduction, and distribution of the Work otherwise complies with\n      the conditions stated in this License.\n\n   5. Submission of Contributions. Unless You explicitly state otherwise,\n      any Contribution intentionally submitted for inclusion in the Work\n      by You to the Licensor shall be under the terms and conditions of\n      this License, without any additional terms or conditions.\n      Notwithstanding the above, nothing herein shall supersede or modify\n      the terms of any separate license agreement you may have executed\n      with Licensor regarding such Contributions.\n\n   6. Trademarks. This License does not grant permission to use the trade\n      names, trademarks, service marks, or product names of the Licensor,\n      except as required for reasonable and customary use in describing the\n      origin of the Work and reproducing the content of the NOTICE file.\n\n   7. Disclaimer of Warranty. Unless required by applicable law or\n      agreed to in writing, Licensor provides the Work (and each\n      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n      implied, including, without limitation, any warranties or conditions\n      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n      PARTICULAR PURPOSE. You are solely responsible for determining the\n      appropriateness of using or redistributing the Work and assume any\n      risks associated with Your exercise of permissions under this License.\n\n   8. Limitation of Liability. In no event and under no legal theory,\n      whether in tort (including negligence), contract, or otherwise,\n      unless required by applicable law (such as deliberate and grossly\n      negligent acts) or agreed to in writing, shall any Contributor be\n      liable to You for damages, including any direct, indirect, special,\n      incidental, or consequential damages of any character arising as a\n      result of this License or out of the use or inability to use the\n      Work (including but not limited to damages for loss of goodwill,\n      work stoppage, computer failure or malfunction, or any and all\n      other commercial damages or losses), even if such Contributor\n      has been advised of the possibility of such damages.\n\n   9. Accepting Warranty or Additional Liability. While redistributing\n      the Work or Derivative Works thereof, You may choose to offer,\n      and charge a fee for, acceptance of support, warranty, indemnity,\n      or other liability obligations and/or rights consistent with this\n      License. However, in accepting such obligations, You may act only\n      on Your own behalf and on Your sole responsibility, not on behalf\n      of any other Contributor, and only if You agree to indemnify,\n      defend, and hold each Contributor harmless for any liability\n      incurred by, or claims asserted against, such Contributor by reason\n      of your accepting any such warranty or additional liability.\n\n   END OF TERMS AND CONDITIONS\n\n   APPENDIX: How to apply the Apache License to your work.\n\n      To apply the Apache License to your work, attach the following\n      boilerplate notice, with the fields enclosed by brackets \"\u00dd\u00a8\"\n      replaced with your own identifying information. (Don't include\n      the brackets!)  The text should be enclosed in the appropriate\n      comment syntax for the file format. We also recommend that a\n      file or class name and description of purpose be included on the\n      same \"printed page\" as the copyright notice for easier\n      identification within third-party archives.\n\n   Copyright \u00ddyyyy\u00a8 \u00ddname of copyright owner\u00a8\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$MEMBERS": {"ttr": 526, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x02\\x00\\x00V\\x01\\x11)\\x9f\\x01\\x11)\\x9f\\t'\\x00P\\x00P\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@\"", "ispf": {"version": "02.00", "flags": 0, "createdate": "2011-10-26T00:00:00", "modifydate": "2011-10-26T09:27:56", "lines": 80, "newlines": 80, "modlines": 0, "user": "CLEMSON"}, "text": "\n                Clemson University Service Processors\n\nThis library contains the source modules and macros for the Clemson\nUniversity Service Processors.\n\nThese materials are being made available to cbttape.org under the Apache\n2.0 license.  See member $LICENSE or refer to Apache's web site at\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nNaming Conventions\n------------------\n  o The member describing what is in this library (this member), is\n    named $MEMBERS.\n  o The \"Service Processors User's Guide and Reference\" manual is\n    contained in members beginning with the prefix SRVDOC.  These\n    members are the original BookMaster source and are here for\n    reference.  The documentation intended for use is included in the\n    CBT package as a single html file, srvdoc.html.\n  o The names of all members containing service processor code\n    (source, copy, macro, and load) should begin with SRVsp, where\n    'sp' is one of the two-letter codes in the table below:\n\n    sp                              Description\n    --   ----------------------------------------------------------\n    ##   Internal-use Service Processor Macros.\n    CM   Composite Environment Support & Standard Module Name Table.\n    DT   Date/Time Service Processor.\n    DV   Data In Virtual Service Processor.\n    ES   Environment Support Service Processor(s).\n    FI   File Handler Service Processors.\n    IM   Item Manager Service Processor.\n    MM   Memory Manager Service Processor.\n    MN   Module Name Tables.\n    MS   Message Server Service Processor.\n    PL   Printline Service Processor.\n    ST   String Handler Service Processor.\n    SY   Symbol Manager Service Processor.\n\n    New service processors should be assigned a new two-letter code and\n    the table above should be updated.  The remaining characters (after\n    SRVsp) should be chosen as follows:\n\n    SRVESenv  - Source code for an Environment Support service\n                processor, such as SRVESMVS.\n    SRVESXnn  - Source code for Environment Support exit routines.\n    SRV$$env  - Source and Link-edit JCL for an Environment Support's\n                Standard Module Name Table; 'env' will always be equal\n                to the 'env' of the Environment Support for which the\n                table exists.\n    SRVsp     - Source code for an environment-independent service\n                processor.\n    SRVspenv  - Source code for an environment-dependent service\n                processor; 'env' should be the same as that of the\n                Environment Support service processor on which it\n                depends, unless there is good reason for another choice.\n                For example, the File Handlers use 'env' to refer to the\n                type of files they can handle, although all of them are\n                dependent on SRVESMVS (they can't all be called\n                SRVFIMVS, so another choice for 'env' was mandated).\n    SRVspMAC  - Copy code containing symbol definitions and macros\n                defining a service processor's protocol.\n    SRVspIMC  - Copy code containing internal-use symbols and macros for\n                a specific service processor.\n    SRVspXRZ  - Source code for an excersizer program that tests as many\n                features of the associated service processor as\n                possible.\n                *hint* These routines can be used as working examples.\n\nOther useful members:\n\n    LNKCMMVS  - Will link Service Processor modules with SRVESMVS, so that\n                fewer LOADs will occur when applications start Service\n                Processors.  Useful for placing a production version of\n                Service Processors in the linklist.  Does not include\n                SRVFIOS or SRVPLMVS, since those modules are RMODE(24).\n\n    SRVLEVEL and SRVMOD - These modules include level and copyright info\n                in module headers at assembly time.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$OBJECT": {"ttr": 529, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x00\\x00\\x00\\x01\\x110_\\x01\\x110_\\x02$\\x0e\\xe5\\x0e\\xe5\\x00\\x00\\xd6\\xc2\\xc4\\xc5\\xc3\\xd2\\xe2@@@'", "ispf": {"version": "02.00", "flags": 0, "createdate": "2011-11-01T00:00:00", "modifydate": "2011-11-01T02:24:00", "lines": 3813, "newlines": 3813, "modlines": 0, "user": "OBDECKS"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "$SRVDOC1": {"ttr": 2058, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x01\\x00!\\x01\\x110_\\x01\\x110_\\x02\\x19A3A3\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@'", "ispf": {"version": "02.01", "flags": 0, "createdate": "2011-11-01T00:00:00", "modifydate": "2011-11-01T02:19:21", "lines": 16691, "newlines": 16691, "modlines": 0, "user": "CLEMSON"}, "text": "\n  Service Processors User's Guide And Reference\n\nClemson University Research Foundation\nService Processors\nUser's Guide And Reference\n\nLast revision: July 14, 1997\n\nClemson University Research Foundation\n\n26 Sep 2011\n\nThis document contains information that is proprietary and confidential\ninformation of the Clemson University Research Foundation. This document\nmay not be reproduced in part or in whole without the written permission\nof the Clemson University Research Foundation.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may\nnot use this file except in compliance with the License. You may obtain\na copy of the License in this library as member $LICENSE, or from the\nApache.Org web site. <http://www.apache.org/licenses/LICENSE-2.0>\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n\u20acClemson University Research Foundation 1989,1990,1992.\n\n------------------------------------------------------------------------\n\n\n  Preface <#ToC_1>\n\nService processors were created at Clemson University to assist in the\ndevelopment and maintenance of assembly language programs. They provide\nan efficient, flexible environment that can be used as a foundation for\nconstructing large and complex programs. Service processors provide a\nvariety of functions, including many of those directly available to\nprograms written in high-level programming languages, and are designed\nso that new functions can be added as needed.\n\nIn conjunction with the /*Clemson University Structured Macros*/,\nservice processors bring assembler language programming to a level\napproaching that of high-level programming languages. However, their use\nis not restricted to assembly language programs: any program written in\na language that supports standard System/370 calling conventions can\nbenefit from service processors.\n\nThe Clemson University Service Processors are packaged in a load library\nand accompanying macro library. The load library is accessed through the\nsystem linklist or link pack area, so no STEPLIB is required for its\nuse. The macro library should be concatenated to the assembler's SYSLIB\nfile, and requires the IBM High-Level Assembler.\n\n------------------------------------------------------------------------\n\n\n  Table of Contents\n\n  *\n\n    *Preface* <#Header_1>\n\n  *\n\n    *Figures* <#HDRFIGLIST_START>\n\n------------------------------------------------------------------------\n\n/*Part 1. Service Processors User's Guide*/ <#HDRPART1>\n\n  *\n\n    *Chapter 1. Introduction to Service Processors* <#Header_4>\n\n      o\n\n        What Are Service Processors? <#Header_5>\n\n      o\n\n        How Programs use Service Processors <#Header_6>\n\n      o\n\n        The Service Processor Execution Environment <#Header_7>\n\n  *\n\n    *Chapter 2. Using Service Processors* <#Header_8>\n\n      o\n\n        Copy Members <#Header_9>\n\n      o\n\n        Loading Service Processors <#Header_10>\n\n      o\n\n        Invoking Services <#Header_11>\n\n          +\n\n            Symbol Definitions <#Header_12>\n\n          +\n\n            Function Macros and Service Processor Identifiers <#Header_13>\n\n      o\n\n        Checking Return Codes <#Header_14>\n\n      o\n\n        Multiple Sessions With the Same Processor <#Header_15>\n\n      o\n\n        Cascading Service Processors of the Same Type <#Header_16>\n\n      o\n\n        Putting it Together <#Header_17>\n\n  *\n\n    *Chapter 3. Service Processors And The Structured Macros* <#Header_18>\n\n      o\n\n        Useful Structured Macro Constructs <#Header_19>\n\n      o\n\n        Service Processor Support <#Header_20>\n\n          +\n\n            BLOCK Macro <#Header_21>\n\n          +\n\n            ERREXIT Macro <#Header_22>\n\n          +\n\n            User-Defined Conditions <#Header_23>\n\n------------------------------------------------------------------------\n\n/*Part 2. Service Processors Reference*/ <#HDRSPREF>\n\n  *\n\n    *Chapter 4. Description Of Service Processors* <#Header_25>\n\n      o\n\n        Service Processors <#Header_26>\n\n      o\n\n        Naming Conventions <#Header_27>\n\n      o\n\n        Linkage Conventions <#HDRLINKAGE>\n\n  *\n\n    *Chapter 5. Date/Time Services* <#Header_29>\n\n          +\n\n            Obtaining Date/Time Services' Symbols & Macros <#Header_30>\n\n          +\n\n            Establishing Date/Time Services Defaults <#Header_31>\n\n          +\n\n            Identifying Date/Time Services <#Header_32>\n\n          +\n\n            Loading Date/Time Services <#Header_33>\n\n          +\n\n            Specifying Date, Time And Interval Formats <#Header_34>\n\n          +\n\n            The General Input Format <#Header_35>\n\n          +\n\n            Common Parameters <#Header_36>\n\n          +\n\n            Description of Parameters. <#Header_37>\n\n          +\n\n            Return Codes <#Header_38>\n\n          +\n\n            Return Codes <#Header_39>\n\n      o\n\n        Date/Time Services Functions <#Header_40>\n\n  *\n\n    *Chapter 6. Environment Support* <#HDRSRVES>\n\n      o\n\n        Symbols & Macros <#Header_42>\n\n      o\n\n        Establishing Service Processor Identifiers <#Header_43>\n\n      o\n\n        Choosing an Environment Support Load Module <#Header_44>\n\n      o\n\n        Loading Environment Support <#Header_45>\n\n      o\n\n        Data Areas <#Header_46>\n\n          +\n\n            The Environment Support Vector <#Header_47>\n\n          +\n\n            Module Name Tables <#HDRMNTS>\n\n          +\n\n            The Debugging Information Area <#Header_49>\n\n      o\n\n        Common Parameters <#Header_50>\n\n      o\n\n        Complete List of Environment Support Return Codes <#Header_51>\n\n      o\n\n        Environment Support Service Processor Functions and Macros\n        <#Header_52>\n\n  *\n\n    *Chapter 7. File Handlers* <#HDRSRVFI>\n\n      o\n\n        The Standard File Handler <#Header_54>\n\n      o\n\n        The Source Management System File Handler <#Header_55>\n\n      o\n\n        The ISPF/PDF File Handler <#Header_56>\n\n      o\n\n        The XsubID File Handler <#Header_57>\n\n      o\n\n        Preparing to use a File Handler <#Header_58>\n\n          +\n\n            Obtaining File Handler Symbols & Macros <#Header_59>\n\n          +\n\n            Establishing File Handler Defaults <#Header_60>\n\n          +\n\n            Identifying the File Handler <#Header_61>\n\n          +\n\n            Loading the File Handler <#Header_62>\n\n      o\n\n        Common Parameters <#Header_63>\n\n      o\n\n        Return Codes <#Header_64>\n\n      o\n\n        File Handler Service Processor Functions <#Header_65>\n\n  *\n\n    *Chapter 8. Item Manager* <#Header_66>\n\n          +\n\n            Obtaining Item Manager Symbols & Macros <#Header_67>\n\n          +\n\n            Establishing Item Manager Defaults <#Header_68>\n\n          +\n\n            Identifying the Item Manager <#Header_69>\n\n          +\n\n            Loading the Item Manager <#Header_70>\n\n          +\n\n            Common Parameters <#Header_71>\n\n          +\n\n            Complete List of Item Manager Return Codes <#Header_72>\n\n      o\n\n        Item Manager Service Processor Functions <#Header_73>\n\n  *\n\n    *Chapter 9. Memory Manager* <#HDRSRVMEM>\n\n      o\n\n        Preparing to Use the Memory Manager <#Header_75>\n\n          +\n\n            Common Parameters <#Header_76>\n\n          +\n\n            Complete List of Memory Manager Return Codes <#Header_77>\n\n      o\n\n        Memory Manager Service Processor Functions <#Header_78>\n\n  *\n\n    *Chapter 10. Message Services* <#Header_79>\n\n          +\n\n            Defining Messages <#Header_80>\n\n          +\n\n            Obtaining Message Services' Symbols & Macros <#Header_81>\n\n          +\n\n            Establishing Message Services Defaults <#Header_82>\n\n          +\n\n            Identifying Message Services <#Header_83>\n\n          +\n\n            Loading Message Services <#Header_84>\n\n          +\n\n            Common Parameters <#Header_85>\n\n          +\n\n            Return Codes <#Header_86>\n\n      o\n\n        Message Services Functions <#Header_87>\n\n  *\n\n    *Chapter 11. Printline* <#Header_88>\n\n          +\n\n            Basic Operation Of Printline <#Header_89>\n\n          +\n\n            The Format Of A Page <#Header_90>\n\n          +\n\n            Obtaining Printline Symbols & Macros <#Header_95>\n\n          +\n\n            Establishing Printline Defaults <#Header_96>\n\n          +\n\n            Identifying Printline <#Header_97>\n\n          +\n\n            Loading Printline <#Header_98>\n\n          +\n\n            Common Parameters <#Header_99>\n\n          +\n\n            Return Codes <#Header_100>\n\n      o\n\n        Printline Service Processor Functions <#Header_101>\n\n  *\n\n    *Chapter 12. String Handler* <#HDRSRVST>\n\n      o\n\n        Preparing to Use the String Handler <#Header_103>\n\n      o\n\n        Common Parameters <#Header_104>\n\n      o\n\n        Complete List of String Handler Return Codes <#Header_105>\n\n      o\n\n        String Handler Service Processor Functions <#Header_106>\n\n  *\n\n    *Chapter 13. Symbol Manager* <#HDRSRVSY>\n\n          +\n\n            Obtaining Symbol Manager Symbols & Macros <#Header_110>\n\n          +\n\n            Common Symbol Manager Parameters <#Header_111>\n\n          +\n\n            Identifying the Symbol Manager <#Header_112>\n\n          +\n\n            Loading the Symbol Manager <#Header_113>\n\n          +\n\n            Complete List of Symbol Manager Return Codes <#Header_114>\n\n      o\n\n        Symbol Manager Service Processor Functions <#Header_115>\n\n  *\n\n    *Appendix A. Writing A Service Processor* <#Header_116>\n\n      o\n\n        Service Processor Conventions <#Header_117>\n\n      o\n\n        The \"Cheap Calculator\" Service Processor <#HDRSPCC>\n\n      o\n\n        Components Of A Service Processor <#Header_119>\n\n          +\n\n            The Service Processor Load Module <#Header_120>\n\n          +\n\n            The Service Processor Copy Member <#Header_121>\n\n          +\n\n            The User's Guide And Reference <#Header_134>\n\n      o\n\n        Writing The Code <#Header_135>\n\n          +\n\n            Structured Macro Support <#Header_136>\n\n          +\n\n            The Parameter List <#Header_140>\n\n          +\n\n            Entry Logic <#Header_149>\n\n          +\n\n            The Main CASE Block <#Header_150>\n\n          +\n\n            The START And TERMINATE Functions <#Header_151>\n\n          +\n\n            Other Functions <#Header_152>\n\n          +\n\n            The Main Error Exit <#Header_153>\n\n  *\n\n    *Index* <#HDRINDEX_START>\n\n------------------------------------------------------------------------\n\n\n  Figures <#ToC_2>\n\n 1.\n\n    Obtaining Service Processor Symbols and Macros <#Figure_1>\n\n 2.\n\n    Loading service processors <#FIGLOSPS>\n\n 3.\n\n    Code that uses service processor symbols <#FIGCTUSPS>\n\n 4.\n\n    Code that does not use service processor symbols <#FIGCTNSPS>\n\n 5.\n\n    Establishing service processor defaults <#FIGESPD>\n\n 6.\n\n    Code that uses service processor interface macros <#FIGCTUSPIM>\n\n 7.\n\n    Generated Program Work Area (PWA) fields <#FIGGPWAFS>\n\n 8.\n\n    Checking service processor return codes <#FIGCSPRCS>\n\n 9.\n\n    TSO command buffer layout <#Figure_9>\n\n10.\n\n    Example command buffer contents <#Figure_10>\n\n11.\n\n    The DISPLAY program <#FIGDISPLAY>\n\n12.\n\n    Parameter list conventions <#FIGPLIST>\n\n13.\n\n    Environment Support's Symbols and Macros <#Figure_13>\n\n14.\n\n    Module Name Table Layout <#FIGMNTSTR>\n\n15.\n\n    Sample Message Module Definition <#Figure_15>\n\n16.\n\n    Printline Header Definition Example <#FIGPLHDREX>\n\n17.\n\n    Sample Header Definition With Page Counter <#FIGPLFMTHD>\n\n18.\n\n    User-Defined Condition Example <#FIGMACDEFX>\n\n19.\n\n    DEFUCOND Macros For SRVCC <#FIGMACDEFU>\n\n20.\n\n    CC_ID Macro For SRVCC <#FIGMACID>\n\n21.\n\n    Symbol Definitions For SRVCC <#FIGMACSYMS>\n\n22.\n\n    Building A Variable-Length Parameter List Using ##PLIST <#FIGMAC##PL>\n\n23.\n\n    CC_ADD Macro For SRVCC <#FIGMACADDM>\n\n24.\n\n    SRVCC's Parameter List DSECT (Partial) <#FIGCCPARMD>\n\n25.\n\n    Entry Logic For SRVCC <#FIGMACENT>\n\n26.\n\n    The CC_Start And CC_Terminate Functions <#FIGMACSTRT>\n\n27.\n\n    The CC_Add Function <#FIGMACADD>\n\n28.\n\n    SRVCC's ERREXIT Routine <#FIGMACERRX>\n\n------------------------------------------------------------------------\n\n\n  Part 1. Service Processors User's Guide <#ToC_3>\n\n------------------------------------------------------------------------\n\n\n  Chapter 1. Introduction to Service Processors <#ToC_4>\n\nYou are driving home from work when suddenly your car's engine, knowing\nthat your warranty expired just yesterday, starts sputtering and spews\nout lots of black smoke. Then it dies completely and you have to call\nfor a wrecker to take it to the shop for repairs. When you finally make\nit home, its too late to cook anything so you order a pizza and have it\ndelivered. After eating, you load up the dishwasher and turn it on only\nto find out that a pipe has burst. Water floods your kitchen. You turn\nthe dishwasher off and, grumbling to yourself while cleaning up the\nmess, resolve to call a plumber in the morning. What a lousy day!\n\nWhat does all of this have to do with service processors? Well, in real\nlife you call on various companies or service industries to do things\nfor you. Towing service was provided by the wrecker, car repairs by the\nshop, cooking and delivery by the pizza restaurant, water and\nelectricity to operate your dishwasher were provided by utility\ncompanies, and plumbing repairs by the plumber. Many of the services you\ncall on are things you might be able to do for yourself, but its easier\nand often more efficient to have it done by someone else.\n\nService processors perform analagous services for programs. Services are\navailable for extracting information about a program's execution\nenvironment, efficiently managing storage, manipulating textual data,\nreading from arbitrary files, and managing symbols. A service processor\ngroups related services together into a single \"company\" that programs\ncan call upon without having to worry about the implementation details.\nThis can dramatically reduce the amount of code that must be written to\ndevelop a new program.\n\n------------------------------------------------------------------------\n\n\n    What Are Service Processors? <#ToC_5>\n\nService processors are an integrated system of subroutines that serve as\nbuilding-blocks for program construction. Each service processor is a\nsubroutine that provides one or more related services, usually for\nmanaging a specific type of software resource such as a file or a symbol\ntable. Service processors take advantage of the building-blocks offered\nby other service processors, building on their services wherever\npossible. The services within a processor share internal code and\nworking storage, as well as data and other resources. They are able to\nretain information and resources across invocations, providing them with\nthe ability to keep track of things on a program's behalf. Additional\nfeatures of service processors include a built-in mechanism for tracking\ndebugging information and a method of supporting multiple execution\nenvironments. Some of the service processors available include:\n\n  *\n\n    Date/Time: provides services for obtaining the current date and time\n    and for manipulating date/time values. The Date/Time service\n    processor supports numerous formats and may be used to convert\n    values from one format to another. Services are also available for\n    subtracting or adding a duration to a given date/time value, and for\n    calculating the duration between two date/time values.\n\n  *\n\n    Environment Support: acts as an interface between the calling\n    program and its execution environment (an operating system, online\n    system, high-level language, etc), and provides services for\n    extracting information such as the time and date, userid and group\n    name, and whether a program is executing in the forground or\n    background.\n\n  *\n\n    Memory Manager: provides an efficient storage management scheme for\n    programs that need to frequently allocate small items of storage and\n    then free them all at once. Storage can be set up in separate\n    /heaps/ and entire storage heaps can be released with a single call.\n    Items of storage can, of course, be individually released as well.\n\n  *\n\n    String Handler: provides services for manipulating and formatting\n    string data, and services for converting various types of data to\n    and from character format.\n\n  *\n\n    Symbol Manager: provides services for storing symbols with attached\n    information and retrieving them by name at a later time. The\n    information attached to a symbol is controlled entirely by the\n    calling program.\n\n  *\n\n    File Handlers: provide services for reading from various types of\n    files without concern for the actual record layout or access method\n    required.\n\n  *\n\n    PrintLine: this service processor provides an application program\n    with a good set of basic report-writing services. It can be used to\n    set up headers and footers on the printed page, keep track of the\n    current page number and perform automatic ejects.\n\nFor a more detailed look at the services available, see Part 2, \"Service\nProcessors Reference\" <#HDRSPREF>: there is a separate chapter for each\nservice processor that describes its purpose and details the services it\nprovides. Also, scanning the table of contents is a quick way to get a\nfeel for what services are available.\n\n------------------------------------------------------------------------\n\n\n    How Programs use Service Processors <#ToC_6>\n\nPrograms use service processors by calling them with a function code\nindicating the service to be performed (the terms function and service\nare used interchangeably in this manual). For example, a program might\ncall the Environment Support service processor with the ES_GET_TIME\nfunction code to obtain the current time and date. The program would, of\ncourse, provide parameters in which Environment Support would return the\nrequested information. Each function of a service processor has its own\nset of function-specific parameters.\n\nBefore a program can use any of a processor's services, it must\nestablish a session with the service processor by calling it with the\nSTART function code. The *start* function establishes a session between\nthe calling program and the service processor, and returns a unique\nsession identifier to the caller. This session identifier, or /token/,\nusually represents a software resource being managed by the newly\nestablished session, such as an open file or a new symbol table.\n\nThe token returned by *start* is used on future calls to the service\nprocessor, along with a function code, to identify the session (or\nresource) for which a service is being requested. A program can start as\nmany sessions as desired, and most service processors provide optional\nparameters that tailor the new session to the caller's needs. A\ncomplimentary function code, TERMINATE, ends a service processor session\nand resets the session identifier token to a null value.\n\n------------------------------------------------------------------------\n\n\n    The Service Processor Execution Environment <#ToC_7>\n\nAlthough service processors reside in separate subroutines, they are\ninterdependent to varying degrees. For example, the Symbol Manager uses\nthe Memory Manager to deal with the storage in which symbols are kept\nand the File Handler uses the String Handler to format its messages. One\nservice processor, Environment Support, is used by all service\nprocessors for such basic services as allocating working storage,\nmanaging debugging information, and gaining access to other service\nprocessors.\n\nWhen Environment Support is started (invoked with the START function\ncode), it creates a data area called the Environment Support Vector that\nrepresents an execution environment for service processors. Environment\nSupport returns the address of the ESV to the calling program, which is\nthen responsible for passing it to other service processors as they are\nstarted. Thus, Environment Support must be the first service processor\nstarted. Once the address of the ESV has been passed to a service\nprocessor it will be retained, so there is no need to provide it with\nsubsequent function calls.\n\n------------------------------------------------------------------------\n\n\n  Chapter 2. Using Service Processors <#ToC_8>\n\nThis chapter describes the general concepts and procedures needed to\nmake use of service processors. The focus in this chapter (as well as in\nthe rest of the manual) is on assembly language programming with the\n/*Clemson University Structured Macros*/, and all examples are shown in\nassembler. However, service processors can be used from any language\nthat supports standard System/370 linkage conventions and they have the\npotential of running within the execution environment of high-level\nlanguages such as PL/I.\n\nWhile service processors are easy to use, some setting up is required\nbefore a program can begin invoking their functions. As mentioned in the\nintroduction, each service processor is a subroutine. The subroutine,\nwhich must be invoked in 31-bit addressing mode, must be loaded into\nstorage somehow and invoked with the START function code before any\nother functions can be used. Also, all service processors depend on the\nexecution environment established by Environment Support, which must be\nloaded and started before any other service processors.\n\n------------------------------------------------------------------------\n\n\n    Copy Members <#ToC_9>\n\nEach service processor has a /copy member/ containing macros for\ninvoking its services and symbols that name its load module, function\ncodes, and return codes. Assembler programs should have a COPY statement\nfor each service processor they use, and it should appear as close to\nthe beginning of the program as possible. For example, the following\nstatements would be used to obtain the symbolic definitions and macros\nfor the Environment Support and String Handler service processors:\n\n*Figure 1. Obtaining Service Processor Symbols and Macros* <#FT_Figure_1>\n\n  COPY  SRVESMAC    | Copy Environment Support's symbols & macros.\n  COPY  SRVSTMAC    | Copy the String Handler's symbols & macros.\n\n\nAfter a service processor's copy member has been processed, all of its\nsymbols and macros are available for use. Look in the appropriate\nchapters of Part 2, \"Service Processors Reference\" <#HDRSPREF> for\ncomplete descriptions of service processor copy members and how to use\nthem. Programs written in a language other than assembler should contain\nequivalent symbols or named constants for the function codes and return\ncodes they use.\n\n------------------------------------------------------------------------\n\n\n    Loading Service Processors <#ToC_10>\n\nAs a general rule, each service processor resides in its own load\nmodule, although there are exceptions that will be described later. The\nonly service processor that must be loaded directly by the application\nprogram is Environment Support. How this is done is dependent on the\nprogramming language used and the environment in which it is running.\nOnce Environment Support has been loaded and started, other service\nprocessors may be loaded through the ES_LOAD_MODULE function. For\nexample, an assembler program running under MVS/XA might issue the\nfollowing sequence of instructions to load Environment Support and two\nother service processors.\n\n*Figure 2. Loading service processors* <#FT_FIGLOSPS>\n\n\n\n  LOAD  EPLOC==&MVS_ENVIRONMENT_SUPPORT   | Load Environment Support.\n  ST    R0,ES_EPA                         | Save its EPA.\n  CALLX ES_EPA,(ES_TKN,&ES_START,ES_ESVA) | Start Environment Support.\n  CALLX ES_EPA,(ES_TKN,&ES_LOAD_MODULE,&STRING_HANDLER,ST_EPA)\n  CALLX ES_EPA,(ES_TKN,&ES_LOAD_MODULE,&MEMORY_MANAGER,MM_EPA)\n\n------------------------------------------------------------------------\n\n\n    Invoking Services <#ToC_11>\n\nService processors are called using standard linkage conventions for\nprograms running in 31-bit addressing mode (see \"Linkage Conventions\"\n<#HDRLINKAGE>). The first two parameters of the subroutine call are\nalways the same: a *token* followed by a *function code*. The minimum\ncall to invoke one of a service processor's functions looks like the\nfollowing for an assembler program written with the Structured Macros:\n\nCALLX SERVICE_PROCESSOR,(TOKEN,FUNCTION_CODE)\n\nThe *function code* parameter is a four byte signed binary integer that\nselects the desired function. Two function codes, START and TERMINATE,\nare supported by all service processors. Other function codes are\ndependent on the particular service processor. The *token* parameter is\na four byte value whose contents are set by the service processor itself\nwhen the START function is invoked. Additional parameters may be\nrequired or optional, depending on the service being requested.\n\n\n      Symbol Definitions <#ToC_12>\n\nThe function code symbols provided by a service processor's copy member\nshould always be used in place of the actual integer values they\nrepresent. For example, the instructions in Figure 3 <#FIGCTUSPS> load\nand start three service processors and invoke several of their functions.\n\n*Figure 3. Code that uses service processor symbols* <#FT_FIGCTUSPS>\n\n\n\n     LOAD  EPLOC==C&MVS_ENVIRONMENT_SUPPORT\n     ST    R0,ES_EPA\n     CALLX ES_EPA,(ES_TKN,&ES_START,ES_ESVA)\n     CALLX ES_EPA,(ES_TKN,&ES_LOAD_MODULE,&STRING_HANDLER,ST_EPA)\n     CALLX ST_EPA,(ST_TKN,&ST_START,ES_ESVA)\n     CALLX ES_EPA,(ES_TKN,&ES_LOAD_MODULE,&MEMORY_MANAGER,MM_EPA)\n     CALLX MM_EPA,(MM_TKN,&MM_START,ES_ESVA)\n     CALLX MM_EPA,(MM_TKN,&MM_OBTAIN_STORAGE,80,MSG_BUFFER)\n     CALLX ES_EPA,(ES_TKN,&ES_GET_FORMATTED_TIME,TIME,,DATE)\n     L     R2,MSG_BUFFER\n     CALLX ST_EPA,(ST_TKN,&ST_FORMAT,(R2),80,MSG_LENGTH,               +\n                'Execution beginning at %CL5 on %CL8.',36,TIME,DATE)\n     CALLX ES_EPA,(ES_TKN,&ES_DISPLAY_MESSAGE,(R2),MSG_LENGTH)\n\n\n\nBecause symbols are used for specifying function codes, it is easy to\ndetermine what functions are being invoked. After the instructions in\nFigure 3 <#FIGCTUSPS> have been executed, a message like the one below\nwill be written to the user's terminal or to the job message log:\n\nExecution beginning at 14:10 on 06/01/89.\n\nUse of service processor symbols makes for code that is much easier to\nunderstand than the following instruction sequence, which produces\nidentical code to that in Figure 3 <#FIGCTUSPS> but uses the actual\ninteger values instead of their symbolic names:\n\n*Figure 4. Code that does not use service processor symbols* <#FT_FIGCTNSPS>\n\n\n\n     LOAD  EPLOC==C'SRVESMVS'\n     ST    R0,ES_EPA\n     CALLX ES_EPA,(ES_TKN,1,ES_ESVA)\n     CALLX ES_EPA,(ES_TKN,5,'SRVSTR',ST_EPA)\n     CALLX ST_EPA,(ST_TKN,1,ES_ESVA)\n     CALLX ES_EPA,(ES_TKN,5,'SRVMEM',MM_EPA)\n     CALLX MM_EPA,(MM_TKN,1,ES_ESVA)\n     CALLX MM_EPA,(MM_TKN,3,80,MSG_BUFFER)\n     CALLX ES_EPA,(ES_TKN,24,TIME,JULIAN,,DATE)\n     L     R2,MSG_BUFFER\n     CALLX ST_EPA,(ST_TKN,3,(R2),80,MSG_LENGTH,                        +\n              'Execution beginning at %CL5 on %CL8.',36,TIME,DATE)\n     CALLX ES_EPA,(ES_TKN,7,(R2),MSG_LENGTH)\n\n\n      Function Macros and Service Processor Identifiers <#ToC_13>\n\nIn programs that make heavy use of service processor functions, coding\nsubroutine calls can be a chore. After all, the first few items in the\nsubroutine call are always the same: an entry point address, a token\nvalue, and a function code. Furthermore, if a large number of service\nprocessors or service processor sessions are needed, creating labels and\nstorage for the entry point addresses and token values can become\ntedious (e.g. ES_EPA, ES_TKN, etc).\n\nThe macros defined within each service processor's copy member can do\nmost of this automatically. There is a separate macro for invoking each\nservice processor function. The name of each function invocation macro\nis the same as that of the function it invokes, and all values are\nspecified using keyword parameters instead of the positional parameters\nused in CALLX statements.\n\nIn addition to the function invocation macros, each service processor\nhas a macro for establishing /service processor identifiers/. A service\nprocessor identifier is a collection of parameters that will be\nautomatically used whenever the identifier is referenced. For example,\nthe ES_ID instruction in Figure 5 <#FIGESPD> creates an Environment\nSupport service processor identifier, ENV_SUP, and associates it with\nfour different values. Once it has been created, specifying ID=ENV_SUP\non any Environment Support macro is equivalent to specifying all of\nthose values.\n\n*Figure 5. Establishing service processor defaults* <#FT_FIGESPD>\n\n\n\n     ES_ID ID=ENV_SUP,SPEPNAME=&MVS_ENVIRONMENT_SUPPORT,               +\n                  SPEPA=ES_EPA,SPTOKEN=ES_TKN,ESVA=ES_ESVA\n\n\n\nAny number of service processor identifiers can be created: they are\nsimply used for grouping several different parameters under a single\nname. Each service processor has its own macro for creating identifiers,\nbut they are all similar and have at least the following keywords:\nSPEPNAME, SPEPA, SPTOKEN, and ESVA. Additional keywords may be specified\nfor some service processor identifiers.\n\nAll keywords other than ID= are optional when creating any service\nprocessor identifier and most will be set to default values if they are\nomitted. In particular, if the entry point address and token value\nkeywords are omitted, storage will be reserved for them in the\nStructured Macros Program Work Area (PWA). The same is true for the ESV\naddress, except that the ES_ID macro will generate the storage, and all\nother service processor identifiers will default to the existing value.\n\nAny storage field generated in the PWA by a service processor macro will\nbe named using Structured Macros global variable &PWA. followed by the\nservice processor identifier, an underscore, and the keyword to which\nthe value applies. For example, if SPTOKEN had not been specified in\nFigure 5 <#FIGESPD>, the instruction\n\n&PWA.ENV_SUP_SPTOKEN  DS  F\n\nwould have been generated for it in the PWA.\n\nThe code in Figure 6 <#FIGCTUSPIM> performs the same function as that in\nFigure 3 <#FIGCTUSPS>, but uses service processor macro instructions in\nplace of the LOAD and CALLX instructions.\n\n*Figure 6. Code that uses service processor interface macros*\n<#FT_FIGCTUSPIM>\n\n\n\n     ES_ID                 ID=ES,SPEPNAME=&MVS_ENVIRONMENT_SUPPORT\n     ST_ID                 ID=ST,SPEPNAME=&STRING_HANDLER\n     MM_ID                 ID=MM,SPEPNAME=&MEMORY_MANAGER\n     ES_MVS_LOAD           ID=ES              | Load Env. Support.\n     ES_START              ID=ES              | Start Env. Support.\n     ES_LOAD_MODULE        ID=ES,SPID=ST      | Load String Handler.\n     ES_LOAD_MODULE        ID=ES,SPID=MM      | Load Memory Manager.\n     ST_START              ID=ST              | Start String Handler.\n     MM_START              ID=MM              | Start Memory Manager.\n     MM_OBTAIN_STORAGE     ID=MM,SIZE=80,ADDRESS=MSG_BUFFER\n     ES_GET_FORMATTED_TIME ID=ES,TIME=TIME,GREGORIAN=DATE\n     ST_FORMAT ID=ST,CONTROL='Execution beginning at %CL5 on %CL8.',   +\n               SOURCE=(TIME,DATE),TARGET=(*MSG_BUFFER,80),             +\n               RESULTLEN=MSG_LENGTH\n     ES_DISPLAY_MESSAGE    ID=ES,MESSAGE=(*MSG_BUFFER,MSG_LENGTH)\n\n\n\nThe first instruction in Figure 6 <#FIGCTUSPIM> establishes default\nvalues for Environment Support and associates them with service\nprocessor identifier ES. While Environment Support's entry point name\nwas explicitly specified, its entry point address, token value, and ESV\naddress were not: ES_ID automatically reserves storage for them in the\nPWA. The next two instructions do the same thing for the String Handler\nand the Memory Manager, but use the previouly established value for ESVA\ninstead of generating new fields. After these three instructions have\nbeen seen by the assembler, the following fields will have been created\nin the PWA and named as shown:\n\n*Figure 7. Generated Program Work Area (PWA) fields* <#FT_FIGGPWAFS>\n\n\n\n  &PWA.ES_SPEPA   DS A    | ID=ES: Environment Support's Entry Point Address.\n  &PWA.ES_SPTOKEN DS F    | ID=ES: Environment Support's Token.\n  &PWA.ES_ESVA    DS F    | ID=ES: Environment Support's ESV Address.\n  &PWA.ST_SPEPA   DS A    | ID=ST: String Handler's Entry Point Address.\n  &PWA.ST_SPTOKEN DS F    | ID=ST: String Handler's Token.\n  &PWA.MM_SPEPA   DS A    | ID=MM: Memory Manager's Entry Point Address.\n  &PWA.MM_SPTOKEN DS F    | ID=MM: Memory Manager's Token.\n\n\nThe remaining instructions in Figure 6 <#FIGCTUSPIM> produce the same\ncode as their counterparts in Figure 3 <#FIGCTUSPS>, automatically\nobtaining the correct parameters and values through service processor\nidentifiers.\n\n------------------------------------------------------------------------\n\n\n    Checking Return Codes <#ToC_14>\n\nOn return from any service processor function, register 15 will contain\nan integer value indicating the results of the function's operation.\nThis value is the function's return code. Each service processor has its\nown set of return codes, but a value of zero (*0*) always means a\nfunction call has completed successfully.\n\nWhen most service processor functions cannot complete successfully, they\nsave information in Environment Support's debugging information area,\nset the return code, and return to the calling program. The return code\nfrom these functions should always be checked to insure successful\noperation. However, some functions are designed to succeed or abend the\nprogram, so there is no need to examine their return codes. Refer to the\ndescription of a particular function for details on how it handles\nabnormal conditions.\n\nChecking the return code after a service processor function call is\neasy. Each service processor COPY member defines symbols for all of its\nreturn codes. These symbols may be used in open code while checking\nreturn codes, as in the following IF statement:\n\n  IF (CH,R15,EQ,=H'&MM_STORAGE_NOT_AVAILABLE')   | If out of storage.\n\nIn addition to the return code symbols, user-conditions are defined (via\nthe Structured Macros DEFUCOND macro) for checking them. To use one of\nthese conditions, simply prefix the condition code's name with a percent\nsign. This statement is identical to the one above and happens to\ngenerate the same assembler code:\n\n  IF (%MM_STORAGE_NOT_AVAILABLE)                 | If out of storage.\n\nFigure 8 <#FIGCSPRCS> shows a typical sequence of instructions for\nchecking a function's return code. In this case, the Memory Manager's\nMM_OBTAIN_STORAGE function is being invoked. While no attempt is made to\nrecover from errors, the out-of-storage return code is handled as a\nspecial case. All other non-successful return codes from this function\nindicate more serious problems and are handled by displaying Environment\nSupport's debugging information area and then abending the program with\na dump. The return codes from Environment Support's display services are\nnot checked because they will either succeed or abend the program.\n\n*Figure 8. Checking service processor return codes* <#FT_FIGCSPRCS>\n\n\n\n  MM_OBTAIN_STORAGE ID=MM,SIZE=133,ADDRESS=LINE  | Obtain 133 bytes stg.\n  IF (%MM_STORAGE_NOT_AVAILABLE)                 | If out of storage.\n    ES_DISPLAY_MESSAGE ID=ES,MESSAGE='Not enough storage to operate.'\n    ERREXIT  CODE=8                              |   Exit with RC=8.\n  ELSEIF (NOT,(%MM_SUCCESS))                     | ElseIf other   failure.\n    ES_DISPLAY_DEBUG_INFO_AND_ABEND ID=ES        |   Abend with a   dump.\n  ENDIF                                          | EndIf.\n\n------------------------------------------------------------------------\n\n\n    Multiple Sessions With the Same Processor <#ToC_15>\n\n------------------------------------------------------------------------\n\n\n    Cascading Service Processors of the Same Type <#ToC_16>\n\n------------------------------------------------------------------------\n\n\n    Putting it Together <#ToC_17>\n\nNow that the basic features and requirements of service processors have\nbeen covered, a complete program can be written. This program is a TSO\ncommand processor written in assembler using the Structured Macros and\nthe service processor macros. It uses Environment Support and the File\nHandler to read in and display every line in a sequential data set or\nmember of a partitioned data set, and is invoked with the following\nsyntax:\n\n\nDISPLAY /file-specification/\n\nOn entry to the program, register 1 must point to the TSO Command\nProcessor Parameter List, or CPPL. The first word in the CPPL is a\npointer to the command buffer containing the command entered by the\nuser. The command buffer looks like the following:\n\n*Figure 9. TSO command buffer layout* <#FT_Figure_9>\n\n\nLength of buffer\n\n\n\nOffset to 1^st operand\n\n\n\nCommand Text\n\nBuffer+0\n\n\n\nbuffer+2\n\n\n\nbuffer+4\n\n\n\nThe first field, length, is a signed halfword equal to the length of the\nentire command buffer, including the four-byte prefix. The second field,\noffset, is a signed halfword equal to the offset from the beginning of\ncommand-text to the current position (thus, an offset of 0000 would\nindicate the first character in command-text). The last field,\ncommand-text, is the text of the command as entered by the user.\n\nBefore invoking DISPLAY, TSO will set the value of offset to indicate\nthe first non-blank character after the command name itself (i.e.\n*DISPLAY*). For example, if a user entered the command *display\nsource(notes)*, the command buffer would contain the following values,\nwith length and offset shown in decimal:\n\n*Figure 10. Example command buffer contents* <#FT_Figure_10>\n\n\nLength\n\n\n\nOffset\n\n\n\nCommand Text\n\n25\n\n\n\n8\n\n\n\ndisplay source(notes)\n\n\nThe listing below was taken directly from a working copy of the DISPLAY\nprogram, and is well commented. To understand the code of this program\nin detail, refer to the reference chapters for the Environment Support\nand File Handler service processors.\n\n*Figure 11. The DISPLAY program* <#FT_FIGDISPLAY>\n\n\n\n*---------------------------------------------------------------------*\n*\n*  DISPLAY FileSpecification\n*\n*  A TSO command to display the contents of the specified sequential\n*  data set or PDS member on the user's terminal.  If the file cannot\n*  be opened for some reason, or if an error occurs while it is reading\n*  a line, the program will issue an error message and terminate\n*  normally.\n*\n*  Inputs:  On entry to this program, Register 1 (R1) must point to the\n*           TSO Command Processor Parameter List (CPPL), which is\n*           mapped by macro IKJCPPL in SYS1.MACLIB.\n*\n*  Outputs: Normally, each line in the file named by FileSpecification\n*           will be written to the user's terminal. If an error occurs,\n*           a message will be written to the terminal.  Some messages\n*           are created by this program, but most are obtained from the\n*           File Handler.\n*\n*  Return Codes:\n*    0    - The specified file was successfully displayed.\n*    4    - The file was displayed, but warning(s) were issued.\n*    8    - The file was not displayed.  An error message was issued.\n*   12    - A severe error occurred.  A message and dump were issued.\n*   Abend - A critical error occurred that probably indicates an\n*           internal programming error.  A message, mini-dump, and a\n*           full storage dump will be issued.\n*\n*---------------------------------------------------------------------*\n BLOCK TYPE=PROGRAM,NAME=DISPLAY,OPTIONS=(*PWA),R1SAVE=R9,AMODE=31,    +\n               RMODE=ANY\n   USING  CPPL,R9          | Establish addressability on the CPPL.\n   MVC    PWA_RC,=H'0'     | Initialize Display's return code.\n*---------------------------------------------------------------------*\n*  Get symbols & macros, and establish deault parameter values.\n*---------------------------------------------------------------------*\n   COPY   SRVESMAC         | Get Environment Support symbols & macros.\n   COPY   SRVFIMAC         | Get File Handler symbols & macros.\n   ES_ID  ID=ES,SPEPNAME=&MVS_ENVIRONMENT_SUPPORT   Set defaults.\n   FI_ID  ID=FI,SPEPNAME=&FI_OS_FILE_HANDLER        Set defaults.\n*---------------------------------------------------------------------*\n*  Load and start Environment Support. Both functions will succeed or\n*  abend trying, so their return codes are not checked.\n*---------------------------------------------------------------------*\n   ES_MVS_LOAD    ID=ES            | Load Environment Support.\n   ES_START       ID=ES            | Start Environment Support.\n*---------------------------------------------------------------------*\n*  Attempt to load the File Handler.  Issue a message on failure.\n*---------------------------------------------------------------------*\n   ES_LOAD_MODULE ID=ES,SPID=FI    | Load File Handler.\n   IF NOT,(%ES_SUCCESS)            | If unable to load File Handler.\n     ES_DISPLAY_MESSAGE ID=ES,     |   Display an error message.       +\n               MESSAGE='Unable to load File Handler.'\n     ERREXIT CODE=12               |   Quit with a return code.\n   ENDIF                           | EndIf.\n*---------------------------------------------------------------------*\n*  Get the FileSpecification's length and address from the command\n*  buffer, and attempt to open it for sequential input.\n*---------------------------------------------------------------------*\n   L        R2,CPPLCBUF            | R2 := address of command buffer.\n   LH       R3,2(,R2)              | R3 := offset after command name.\n   LA       R3,4(,R3)              | R3 := offset from R2 to filename.\n   LH       R0,0(,R2)              | R0 := total buffer length.\n   SR       R0,R3                  | R0 := filename's length.\n   ST       R0,PWA_LEN             | Save for parmlist.\n*                                  |\n   FI_START ID=FI,FILE=(0(R3,R2),PWA_LEN),ACCESS=&FI_INPUT_SEQUENTIAL\n*                                  |\n   IF NOT,(%FI_SUCCESS)            | If file could not be opened.\n     IF (%FI_CRITICAL)             |   For CRITICAL errors...\n       ES_DISPLAY_DEBUG_INFO_AND_ABEND ID=ES  Abend immediately.\n     ELSEIF (%FI_SEVERE)           |   For severe errors...\n       ES_DISPLAY_DEBUG_INFO ID=ES |     Print debugging info.\n       ERREXIT CODE=12             |     Shut-down and exit.\n     ENDIF                         |   EndIf.\n*                                  |   For all other errors...\n     FI_GET_INFO ID=FI,MSG=PWA_MSG,MSGLEN=PWA_MSG_LEN  Get the msg.\n     IF (%FI_SUCCESS)              |   If success: display it.\n       ES_DISPLAY_MESSAGE ID=ES,MESSAGE=(PWA_MSG,PWA_MSG_LEN)\n       ERREXIT CODE=8              |     Shut-down and exit.\n     ELSE                          |   Else.\n       ES_DISPLAY_DEBUG_INFO_AND_ABEND ID=ES  Abend immediately.\n     ENDIF                         |   EndIf.\n   ENDIF                           | EndIf.\n*---------------------------------------------------------------------*\n*  Read every line in the file and display it on the terminal.\n*---------------------------------------------------------------------*\n   LOOP UNTIL                      | Loop over all input lines.\n     FI_READLINE ID=FI,LINE=PWA_LINE,RESULTLEN=PWA_LEN  Read a line.\n     LEAVE       LOOP=*,(%FI_END_OF_FILE)               Leave if done.\n*                                  |\n     IF NOT,(%FI_SUCCESS)          |   If something went wrong.\n       IF (%FI_CRITICAL)           |     For CRITICAL errors...\n         ES_DISPLAY_DEBUG_INFO_AND_ABEND ID=ES  Abend immediately.\n       ELSEIF (%FI_SEVERE)         |     For severe errors...\n         ES_DISPLAY_DEBUG_INFO ID=ES       Print debugging info.\n         ERREXIT CODE=12           |       Shut-down and exit.\n       ENDIF                       |     EndIf.\n*                                  |\n       LR        R2,R15            |     Remember READLINE's return-code.\n       FI_GET_INFO ID=FI,MSG=PWA_MSG,MSGLEN=PWA_MSG_LEN Obtain the msg.\n       IF NOT,(%FI_SUCCESS)        |     If no message was obtained.\n         ES_DISPLAY_DEBUG_INFO_AND_ABEND ID=ES  Abend immediately.\n       ELSE                        |     Else, display the message.\n         ES_DISPLAY_MESSAGE ID=ES,MESSAGE=(PWA_MSG,PWA_MSG_LEN)\n         ERREXIT (CH,R2,NE,=H'&FI_WARNING'),CODE=8 Shut-down and exit.\n         MVC     PWA_RC,=H'4'      |       Set return-code to warning.\n       ENDIF                       |     EndIf.\n     ENDIF                         |   EndIf.\n*                                  |\n     ES_DISPLAY_MESSAGE ID=ES,     |   Display the line just read in.  +\n               MESSAGE=(PWA_LINE,PWA_LEN)\n   ENDLOOP UNTIL,LEAVE             | EndLoop.\n*---------------------------------------------------------------------*\n*  Close the file, terminate and unload service processors, and quit.\n*---------------------------------------------------------------------*\n   FI_TERMINATE     ID=FI          | Close and de-allocate file.\n   ES_UNLOAD_MODULE ID=ES,SPID=FI  | Unload file handler.\n   ES_TERMINATE     ID=ES          | Shut down Environment Support.\n   ES_MVS_UNLOAD    ID=ES          | Unload Environment Support.\n   LH               R15,PWA_RC     | Set R15 to final return-code.\n ENDBLK BLOCK=DISPLAY,RC=(R15)     | Exit with a succesful return code.\n\n\n*---------------------------------------------------------------------*\n*  Error Exit - On entry R14 will equal the integer value supplied on\n*  the CODE= keyword of the ERREXIT macro.  This value will be used as\n*  Display's return code.\n*---------------------------------------------------------------------*\n BLOCK TYPE=ERREXIT                | Exit was entered with CODE=rc.\n   LR               R2,R14         |   Set R2 to the value on CODE=.\n   FI_TERMINATE     ID=FI          |   Close and de-allocate file.\n   ES_UNLOAD_MODULE ID=ES,SPID=FI  |   Unload file handler.\n   ES_TERMINATE     ID=ES          |   Shut down Environment Support.\n   ES_MVS_UNLOAD    ID=ES          |   Unload Environment Support.\n ENDBLK RC=(R2)                    | Set R15 to return-code and exit.\n\n\n*---------------------------------------------------------------------*\n*  Program Work Area.\n*---------------------------------------------------------------------*\n              PWA    ,             | Program Work Area.\nPWA_RC        DS     H             |   Display's return code.\nPWA_LEN       DS     F             |   Used for filename & line length.\nPWA_LINE      DS     CL80          |   Current input line.\nPWA_MSG_LEN   DS     F             |   Length of message text.\nPWA_MSG       DS     CL256         |   Warning or error message.\n              ENDPWA ,             | End of PWA.\n              IKJCPPL              | Command Processor Parameter List.\n              END\n\n------------------------------------------------------------------------\n\n\n  Chapter 3. Service Processors And The Structured Macros <#ToC_18>\n\n(intro paragraphs)\n\n------------------------------------------------------------------------\n\n\n    Useful Structured Macro Constructs <#ToC_19>\n\n------------------------------------------------------------------------\n\n\n    Service Processor Support <#ToC_20>\n\nThe Clemson Structured Macros contain several features to support the\noperation of Service Processors. The fastest way to familiarize yourself\nwith these options is to use an existing service processor as a model.\nRefer to the \u00f4Cheap Calculator\u00f6 service processor in Appendix A of this\nguide and in the SRVCCxxx members of the Service Processor source library.\n\n\n      BLOCK Macro <#ToC_21>\n\nTypically, a service processor will use the following PROGRAM block options:\n\n**SRVPRC, NOCLEARPWA, PARMS(USING(reg)), (COUNT,parm_count_field)*\n\nAn unusually large program may also use the *LONG*and *LOCTR*options to\nmake it easier to manage base registers, as well as the subroutine\noptions **SWA*and *LOADBASE*.\n\nTypically, the Structured Macros' reentrant linkage will getmain and\nfreemain a program workarea, or PWA. Service processors usually need to\nremember information from one call to the next (an open DCB, pointers to\ndata defined by earlier calls, etc), so the *SRVPRC super option\nincludes an option that prevents the freemain from occurring unless\nrequested. Typically, the service processor's TERMINATE function will\ninclude the macro\n\nSMCTRL FREEPWA=YES\n\nwhich sets a flag to tell the linkage code to issue a FREEMAIN during\nthe return linkage.\n\n\n      ERREXIT Macro <#ToC_22>\n\nService processor errors can usually share one unnamed errexit routine\nthat contains an *ES_DISPLAY_DEBUG_INFO_AND_ABEND*macro. This macro will\nsnap out the debug information area chain and issue a U1000 abend. For\nexample:\n\n  LOOP  UNTIL                        | Loop until explicit LEAVE\n    FI_READLINE ID=FI_SYSIN, etc     | Read a line from SYSIN\n    LEAVE LOOP=*,(%FI_END_OF_FILE)   | Leave loop if EOF\n    ERREXIT (NOT,%FI_SUCCESS)        | Any other error is fatal.\n       :                             | .. process ..\n  ENDLOOP UNTIL,LEAVE                |\n  FI_CLOSE ID=FI_SYSIN               | Close file at EOF.\n       :\nBLOCK TYPE=ERREXIT                   | General service processor errexit\n  ES_DISPLAY_DEBUG_INFO_AND_ABEND ID=ES  | Display DIA's and abend.\nENDBLK                               |\n\nOther error routines may be defined as ERREXIT blocks, but since\nthe Structured Macros only support one unnamed errexit block,\nadditional blocks must be named.\n\n\n      User-Defined Conditions <#ToC_23>\n\nThe DEFUCOND macro defines conditions that can be used in Structured\nMacro conditional statements (IF, LOOP WHILE, ENDLOOP UNTIL, LEAVE, etc)\nto test for various Service Processor return codes by the retorn code's\nsymbol name. The DEFUCOND macros that set these conditions up at\nassembly time are usually defined in the SRVxxMAC member. For example,\nhere are the DEFUCOND macros from SRVDTMAC that define all the return\ncodes for SRVDT:\n\n*---------------------------------------------------------------------*\n\n* DEFUCOND macros to facilitate checking return codes. If new return\n\n* codes are added, don't forget to add a DEFUCOND for them.\n\n*---------------------------------------------------------------------*\n\nDEFUCOND MACRO=SRV##RC,NAME=DT_SUCCESS\n\nDEFUCOND MACRO=SRV##RC,NAME=DT_INVALID_FUNCTION\n\nDEFUCOND MACRO=SRV##RC,NAME=DT_INVALID_NUMBER_OF_PARMS\n\nDEFUCOND MACRO=SRV##RC,NAME=DT_INVALID_DT_ID\n\nDEFUCOND MACRO=SRV##RC,NAME=DT_ENVIRONMENT_SUPPORT_ERROR\n\nDEFUCOND MACRO=SRV##RC,NAME=DT_STRING_HANDLER_ERROR\n\nDEFUCOND MACRO=SRV##RC,NAME=DT_INVALID_DATE_FORMAT\n\nDEFUCOND MACRO=SRV##RC,NAME=DT_INVALID_TIME_FORMAT\n\nDEFUCOND MACRO=SRV##RC,NAME=DT_INVALID_INTERVAL_FORMAT\n\nDEFUCOND MACRO=SRV##RC,NAME=DT_INVALID_INPUT_DATE\n\nDEFUCOND MACRO=SRV##RC,NAME=DT_INVALID_INPUT_TIME\n\nDEFUCOND MACRO=SRV##RC,NAME=DT_INVALID_INPUT_INTERVAL\n\nDEFUCOND MACRO=SRV##RC,NAME=DT_OVERFLOW\n\nDEFUCOND MACRO=SRV##RC,NAME=DT_OUT_OF_RANGE\n\n------------------------------------------------------------------------\n\n\n  Part 2. Service Processors Reference <#ToC_24>\n\n------------------------------------------------------------------------\n\n\n  Chapter 4. Description Of Service Processors <#ToC_25>\n\nThis chapter contains reference information that applies to all service\nprocessors. Each of the remaining chapters in Part 2, \"Service\nProcessors Reference\" <#HDRSPREF> describes a different kind of service\nprocessor, with the name of the processor at the bottom of odd-numbered\npages for easy reference.\n\n------------------------------------------------------------------------\n\n\n    Service Processors <#ToC_26>\n\nA *service processor* is a subroutine that provides a set of related\nservices using normal subroutine calls to a single point of entry. The\nfirst two parameters are the same for all service processors: a *token*\nand a *function code*. The *function code* parameter is a signed\nfullword integer set by the calling program to select the desired\nservice. Two function codes, START and TERMINATE, are supported by all\nservice processors. The *token* parameter is a four byte value whose\ncontents are set by the service processor itself when the START function\ncode is selected. Additional parameters may be required or optional,\ndepending on the selected function code. The general form of a service\nprocessor subroutine call looks like:\n\ncall service_processor,(token,function_code,additional_parameters)\n\nAs a general rule, each service processor supports a unique set of\nservices. For example, there is only one Memory Manager and only one\nString Handler. In some cases though, several service processors may\nsupport the same set of services but provide access to different\nexecution environments or to a different kind of resource. For example,\nthere are several File Handler service processors. They all support\npretty much the same services, but for completely different kinds of files.\n\nWhen more than one service processor supports the same set of services,\nit is helpful to distinguish between a /service processor/ and the\n/protocol/ it follows. Remember that a service processor is a\nsubroutine. The protocol it follows includes everything a program must\nknow in order to use it: calling sequences, required and optional\nparameters, function codes, return codes, data structures, etc.\n\nWhile the distinction between a service processor and its protocol is\noften blurred, the distinction is important as it allows for flexible\ncode to be written. The only part of a program that must know what\nservice processor is being used for a given set of services is the part\nthat chooses which subroutine to load. The remaining code can use the\nprocessor's services without knowing or caring what subroutine is being\ninvoked, so long as it follows the correct protocol. This makes it easy\nto access various resources or environments that are similar in nature,\nwith little or no change in code.\n\n------------------------------------------------------------------------\n\n\n    Naming Conventions <#ToC_27>\n\nA unique two-letter identification code has been assigned to every\npublicly available service processor. This code is used as part of every\nname associated with a service processor protocol. The service processor\nidentification codes for all public service processors are shown in\nTable 1 <#TBLSPICS>.\n\nUsing /sp/ to represent the two-letter service processor identifier\ncodes shown in Table 1 <#TBLSPICS>, the various components of a service\nprocessor are named as follows:\n\n 1.\n\n    The names of *Macros, Symbols, Conditions, Data areas*, and\n    everything other than PDS member names are prefixed with the\n    two-letter code followed by an underscore, \"_\", followed by an\n    arbitrary name. Any name beginning with \"/sp_/\" is a part of the\n    service processor protocol assigned to the /sp/ service processor\n    identification code.\n\n 2.\n\n    *PDS Members* for service processors are named as follows:\n\n     1.\n\n        *Load Modules* are named SRV/sp/, unless a service processor has\n        an environmental dependency in which case the name is\n        SRV/sp//*env*/, where /*env*/ is up to three letters chosen to\n        indicate the dependency. For example, SRVES*MVS* is the name of\n        the /*MVS*/ Environment Support service processor load module.\n\n     2.\n\n        *Assembler COPY members* are named SRV/sp/MAC.\n\n     3.\n\n        *Internal COPY members* are named SRV/sp/IMC.\n\n     4.\n\n        *Excerciser* programs and data are named SRV/sp/XR/z/, where /z/\n        is an arbitrary character (usually Z).\n\n     5.\n\n        *BookMaster Reference Chapters* for are named SRVDOC/sp/.\n\n 3.\n\n    *A composite load module* containing various service processors\n    link-edited together with a Module Name Table and an Environment\n    Support service processor is named SRVCM/*env*/. The corresponding\n    Environment Support load module is an alias of the composite (e.g.\n    SRVESMVS is an alias of SRVCMMVS, where SRVCMMVS contains MVS\n    Environment Support as the main entry point, a module name table,\n    and a number of service processors that have been linked into the\n    module).\n\n\n\n*Table 1. Service processor codes and member names*\n\nService Processor\n\n\n\nCode\n\n\n\nEnvironment Dependent\n\n\n\nCopy Member\n\n\n\nLoad Module(s)\n\nData In Virtual Manager\n\n\n\n*DV*\n\n\n\nYES\n\n\n\nSRV*DV*MAC\n\n\n\nSRV*DV*MVS\n\nDate/Time Services\n\n\n\n*DT*\n\n\n\nNO\n\n\n\nSRV*DT*MAC\n\n\n\nSRV*DT *\n\nEnvironment Support\n\n\n\n*ES*\n\n\n\nYES\n\n\n\nSRV*ES*MAC\n\n\n\nSRV*ES*MVS\n\nFile Handler\n\n\n\n*FI*\n\n\n\nYES\n\n\n\nSRV*FI*MAC\n\n\n\nSRV*FI*OS SRV*FI*XID SRV*FI*PDF SRV*FI*SMS SRV*FI*SUB\n\nItem Manager\n\n\n\n*IM*\n\n\n\nNO\n\n\n\nSRV*IM*MAC\n\n\n\nSRV*IM *\n\nMemory Manager\n\n\n\n*MM*\n\n\n\nNO\n\n\n\nSRV*MM*MAC\n\n\n\nSRV*MM *\n\nMessage\n\n\n\n*MS*\n\n\n\nNO\n\n\n\nSRV*MS*MAC\n\n\n\nSRV*MS *\n\nPrintLine\n\n\n\n*PL*\n\n\n\nYES\n\n\n\nSRV*PL*MAC\n\n\n\nSRV*PL*MVS\n\nString Handler\n\n\n\n*ST*\n\n\n\nNO\n\n\n\nSRV*ST*MAC\n\n\n\nSRV*ST *\n\nSymbol Manager\n\n\n\n*SY*\n\n\n\nNO\n\n\n\nSRV*SY*MAC\n\n\n\nSRV*SY *\n\n------------------------------------------------------------------------\n\n\n    Linkage Conventions <#ToC_28>\n\nService processors conform to standard System/370 linkage conventions\nfor programs running in 31-bit addressing mode. When the calling program\ninvokes a service processor function, registers 1, 13, 14, and 15 must\ncontain the following values, all of which are 31-bit addresses:\n\n  *\n\n    Register 1 must contain the address of a variable-length service\n    processor parameter list.\n\n  *\n\n    Register 13 must contain the address of a 72-byte register save area\n    aligned on a fullword boundary.\n\n  *\n\n    Register 14 must contain the address to which control will be returned.\n\n  *\n\n    Register 15 must contain the service processor's entry point address\n\nThe parameter list pointed to by register 1 is a sequence of fullword\naddresses aligned on fullword boundaries. All addresses but the final\none in the list contain a *0* in their high-order bit. The final address\nis denoted by a *1* in its high-order bit. Each address in the list\npoints to the corresponding parameter that is being passed to the\nservice processor.\n\nOptional parameters may be omitted by setting their corresponding\nparameter list address (parameter /x/) to zero. If the parameters to be\nomitted occur at the end of the parameter list, the list may be\nterminated early by setting the high-order bit of the last supplied (not\nomitted) parameter address. The token and function code parameters are\n/never/ optional. Thus, the minimum possible call to invoke a service\nprocessor function looks like the following (for a program written with\nthe Structured Macros):\n\nCALLX SERVICE_PROCESSOR,(TOKEN,FUNCTION_CODE),VL\n\nOn return from a service processor function, all registers except\nregister 15 will contain their original values. Register 15 will be set\nto an integer indicating the results of the function's operation. This\nvalue is the function's /return code/, and each function has its own set\nof return codes. A return code of zero always indicates success. The\nreference section for each service processor's function describes the\npossible return codes, their meanings, and the appropriate actions to be\ntaken by the calling program.\n\n------------------------------------------------------------------------\n\n\n  Chapter 5. Date/Time Services <#ToC_29>\n\nThe Date/Time service processor is intended to reduce or eliminate the\ntasks normally associated with handling date and time values in a\nprogram. Date/Time Services may be used to:\n\n  *\n\n    Return the current date and/or time, in a variety of formats\n\n  *\n\n    Convert a date and/or time value from one format to another\n\n  *\n\n    Recognize the format of a character date or time value\n\n  *\n\n    Return the difference, or /duration/, between two date/time values\n\n  *\n\n    Add or subtract an interval value to a date and/or time\n\nThere are two major operations during each call to the Date/Time service\nprocessor: these are /input conversion/ and /output conversion/. Input\nconversion validates that the date and/or time value provided conforms\nto the format specified, then converts the date and/or time values to an\ninternal representation. Output conversion converts the internal\nrepresentation to the date and/or time format requested by the caller.\n\nInput validation is necessarily limited for performance reasons:\nincoming date and time values are validity-checked to ensure that\nnumbers, words and other characters are in the right positions and\nspelled correctly, but 'sanity checking' is only minimal. (For example,\nan input Gregorian date of 02/30/1989 is considered valid: however, if\nconverted to another format, the output date will be equivalent to March\n2, 1989.) Character input data (names of days and months, etc) may be\nmixed case: character output data is always capitalized lowercase. (If a\nprogram requires data returned from Date/Time Services to be uppercase,\nthe program can fold the data to uppercase itself.)\n\nA /general input/ format is provided. This format actually supports a\nvariety of actual date or time formats by attempting to recognize the\nformat, then proceeding as though the date or time's true format was\nspecified by the caller. The true format is not returned to the caller:\nhowever, the caller may use the DT_Convert function to convert the date\nor time to any other supported format as required. This function may be\nextremely useful for applications where a user is asked to provide a\ndate or time value: the application doesn't need to care what format the\ndates and times are, but can get Date/Time Services to recognize, then\nconvert the dates and times to any format required.\n\nDate/Time Services internally uses four tableless date conversion\nalgorithms. These were adapted from algorithms 199 and 398 from\n/Collected Algorithms From Communications Of The ACM/. The algorithms\nshould be correct for any date between March 1, 0000 and December 31,\n9999. Note, however, that Date/Time Services do not account for Pope\nGregory XIII's calendar adjustment in 1582 A.D: hence, date values prior\nto October 15, 1582, although numerically accurate, will be 11 (or more)\ndays greater than the actual date.\n\n\n      Obtaining Date/Time Services' Symbols & Macros <#ToC_30>\n\nDate/Time Services' symbols and interface macros can be found in the\nassembler copy member SRVDTMAC. This member contains symbols naming\nDate/Time Services' load module, function codes, return codes, and\nparameter values. It also contains macros for using all of the Date/Time\nServices' functions. The following statement or its equivalent should\nappear at the beginning of any program that uses Date/Time Services:\n\n   COPY SRVDTMAC      Obtain Date/Time Services' symbols & macros.\n\n\n      Establishing Date/Time Services Defaults <#ToC_31>\n\nSome parameters are general to Date/Time Services and not specific to\nany function. These parameters include its load module name\n(/DT_epname/), entry point address (/DT_epa/), and token value\n(/DT_token/). The DT_ID macro can be used to establish defaults for\nthese parameters and associate them with a unique service processor\nidentifier. The identifier may then be supplied on any Date/Time\nServices macro instruction to refer to the default parameter values.\n\n\n      Identifying Date/Time Services <#ToC_32>\n\nThe Date/Time service processor resides in the load module named by the\nfollowing symbol definition in copy member SRVDTMAC:\n\n&DATETIME_SERVICES SETC '''SRVDT   '''\n\nThis symbolic name should be used as the service processor entry point\nname for Date/Time Services as shown in the following macro instruction:\n\nDT_ID ID=DT,SPEPNAME=&DATETIME_SERVICES  Set Date/Time Defaults.\n\n\n      Loading Date/Time Services <#ToC_33>\n\nThe recommended method for loading Date/Time Services is through\nEnvironment Support's ES_LOAD_MODULE function, as shown in the following\nexample:\n\nES_LOAD_MODULE ID=ES,SPID=DT            Load Date/Time Services\n\n\n      Specifying Date, Time And Interval Formats <#ToC_34>\n\nAlthough most of the Date/Time Services macros support both a date and a\ntime value as input and/or output, both need not be specified: a date or\ntime specification may be used alone as input or output if desired. For\nexample, to convert a date from one format to another, the DT_Convert\nfunction could be called using the Datein and Dateout parameters alone.\nNote that if a date or time value is not specified, it is treated as\nhaving a value of zero: for dates, this is equivalent to Jan. 1, 0000,\nwhile for times, this translates to 00:00:00.00, or exactly midnight.\n\nDate/Time Services support a number of date and time formats. Each\nformat is actually an integer value, with its own symbol associated with\nit (for example, format /&DT_Julian/ is equated to integer 2.) These are\nlisted in the following tables.\n\n*Table 2. Date/Time Services Supported Date Formats*\n\nSymbol Name\n\n\n\nFormat Value\n\n\n\nFormat Type\n\n\n\nDescription\n\n\n\nLength\n\n\n\nExample\n\n*&DT_ES_Format*\n\n^1 <#FNFNDATE1>\n\n\n\n1\n\n\n\nBoth\n\n\n\nEnvironment Support format date and time\n\n\n\n8\n\n\n\nX'1989359F', X'0047BF58'\n\n*&DT_Julian*\n\n\n\n2\n\n\n\nBoth\n\n\n\nStandard Julian date\n\n\n\n7\n\n\n\nC'1989359'\n\n*&DT_Juliand*\n\n\n\n3\n\n\n\nBoth\n\n\n\n7-digit Julian date with decimal\n\n\n\n8\n\n\n\nC'1989.359'\n\n*&DT_Pjulian*\n\n\n\n4\n\n\n\nBoth\n\n\n\nPacked-decimal Julian date\n\n\n\n4\n\n\n\nP'1989359'\n\n*&DT_Ijulian*\n\n\n\n5\n\n\n\nBoth\n\n\n\nInteger (binary) Julian date\n\n\n\n4\n\n\n\nF'1989359'\n\n*&DT_Sjulian*\n\n\n\n6\n\n\n\nBoth\n\n\n\nShort Julian date\n\n\n\n5\n\n\n\nC'89359'\n\n*&DT_Sjuliand*\n\n\n\n7\n\n\n\nBoth\n\n\n\nShort Julian date with decimal\n\n\n\n6\n\n\n\nC'89.359'\n\n*&DT_Number_Of_Days*\n\n\n\n8\n\n\n\nBoth\n\n\n\nNumber of days since Jan 1, 00\n\n\n\n4\n\n\n\nF'726767'\n\n*&DT_Sgregorian*\n\n^2 <#FNFNDATE2>\n\n\n\n11\n\n\n\nBoth\n\n\n\nShort Gregorian date\n\n\n\n8\n\n\n\nC'12/25/89'\n\n*&DT_Gregorian*\n\n^2 <#FNFNDATE2>\n\n\n\n12\n\n\n\nBoth\n\n\n\nStandard Gregorian date\n\n\n\n10\n\n\n\nC'12/25/1989'\n\n*&DT_Sortdate*\n\n\n\n13\n\n\n\nBoth\n\n\n\nDate format suitable for sorting\n\n\n\n10\n\n\n\nC'1989-12-25'\n\n*&DT_Ssortdate*\n\n\n\n14\n\n\n\nBoth\n\n\n\nShort version of DT_Sortdate\n\n\n\n8\n\n\n\nC'89-12-25'\n\n*&DT_Year*\n\n\n\n15\n\n\n\nOutput\n\n\n\nCharacter year value\n\n\n\n4\n\n\n\nC'1989'\n\n*&DT_Year2*\n\n\n\n16\n\n\n\nOutput\n\n\n\n2-digit character year\n\n\n\n2\n\n\n\nC'89'\n\n*&DT_Pyear*\n\n\n\n17\n\n\n\nOutput\n\n\n\nPacked-decimal year value\n\n\n\n4\n\n\n\nPL4'1989'\n\n*&DT_Iyear*\n\n\n\n18\n\n\n\nOutput\n\n\n\nHalfword integer year value\n\n\n\n2\n\n\n\nH'1989'\n\n*&DT_Days*\n\n\n\n19\n\n\n\nOutput\n\n\n\n2-digit day number within month\n\n\n\n2\n\n\n\nC'25'\n\n*&DT_Pdays*\n\n\n\n20\n\n\n\nOutput\n\n\n\nPacked day number within month\n\n\n\n2\n\n\n\nPL2'25'\n\n*&DT_Idays*\n\n\n\n21\n\n\n\nOutput\n\n\n\nInteger day number within month\n\n\n\n2\n\n\n\nH'25'\n\n*&DT_Month*\n\n\n\n22\n\n\n\nOutput\n\n\n\n2-digit month number\n\n\n\n2\n\n\n\nC'12'\n\n*&DT_Pmonth*\n\n\n\n23\n\n\n\nOutput\n\n\n\nPacked month number\n\n\n\n2\n\n\n\nPL2'12'\n\n*&DT_Imonth*\n\n\n\n24\n\n\n\nOutput\n\n\n\nInteger month number\n\n\n\n2\n\n\n\nH'12'\n\n*&DT_Snormal*\n\n\n\n31\n\n\n\nBoth\n\n\n\nShort Normal format date\n\n\n\n9\n\n\n\nC'25 Dec 89'\n\n*&DT_Normal*\n\n\n\n32\n\n\n\nBoth\n\n\n\nNormal format date\n\n\n\n11\n\n\n\nC'25 Dec 1989'\n\n*&DT_SASdate7*\n\n\n\n33\n\n\n\nBoth\n\n\n\n7-character SAS 'DATE7.' format\n\n\n\n7\n\n\n\nC'25DEC89'\n\n*&DT_SASdate9*\n\n\n\n34\n\n\n\nBoth\n\n\n\n9-character SAS 'DATE9.' format\n\n\n\n9\n\n\n\nC'25DEC1989'\n\n*&DT_Text*\n\n\n\n41\n\n\n\nBoth\n\n\n\nText format date\n\n\n\n11-18\n\n\n\nC'December 25, 1989'\n\n*&DT_Textd*\n\n\n\n42\n\n\n\nBoth\n\n\n\nText format with weekday\n\n\n\n19-28\n\n\n\nC'Monday, December 25, 1989'\n\n*&DT_Weekday*\n\n\n\n43\n\n\n\nOutput\n\n\n\nCharacter weekday name\n\n\n\n6-9\n\n\n\nC'Monday'\n\n*&DT_Weekday3*\n\n\n\n44\n\n\n\nOutput\n\n\n\n3-character weekday name\n\n\n\n3\n\n\n\nC'Mon'\n\n*&DT_Monthname*\n\n\n\n45\n\n\n\nOutput\n\n\n\nCharacter month name\n\n\n\n3-9\n\n\n\nC'December'\n\n*&DT_Monthname3*\n\n\n\n46\n\n\n\nOutput\n\n\n\n3-character month name\n\n\n\n3\n\n\n\nC'Dec'\n\n\n\n*Table 3. Date/Time Services Supported Time Formats*\n\nSymbol Name\n\n\n\nFormat Value\n\n\n\nFormat Type\n\n\n\nDescription\n\n\n\nLength\n\n\n\nExample\n\n*&DT_Hundredths*\n\n\n\n2\n\n\n\nBoth\n\n\n\nNumber of .01-second units since midnight\n\n\n\n4\n\n\n\nX'0047BF58'\n\n*&DT_HHMM*\n\n\n\n3\n\n\n\nBoth\n\n\n\nTime in hours and minutes\n\n\n\n5\n\n\n\nC'13:03'\n\n*&DT_HHMMSS*\n\n\n\n4\n\n\n\nBoth\n\n\n\nTime in hours, minutes, seconds\n\n\n\n8\n\n\n\nC'13:03:40'\n\n*&DT_HHMMSSTH*\n\n\n\n5\n\n\n\nBoth\n\n\n\nTime in hours, minutes, seconds, hundredths\n\n\n\n11\n\n\n\nC'13:03:40.40'\n\n*&DT_Civilian*\n\n\n\n6\n\n\n\nBoth\n\n\n\nTime in hours, minutes, seconds, AM/PM\n\n\n\n11\n\n\n\nC' 1:03:40 PM'\n\n*&DT_TODCLOCK*\n\n^*3* <#FNFNTIME1>\n\n\n\n7\n\n\n\nBoth\n\n\n\nSystem/370 time-of-day clock format^5 <#FNFNTIME3>\n\n\n\n8\n\n\n\nXL8'/TOD value/'\n\n*&DT_Hours*\n\n^*4* <#FNFNTIME2>\n\n\n\n8\n\n\n\nOutput\n\n\n\n2-character hour value\n\n\n\n2\n\n\n\nC'13'\n\n*&DT_Phours*\n\n^*4* <#FNFNTIME2>\n\n\n\n9\n\n\n\nOutput\n\n\n\n2-byte packed-decimal hours\n\n\n\n2\n\n\n\nPL2'13'\n\n*&DT_Ihours*\n\n^*4* <#FNFNTIME2>\n\n\n\n10\n\n\n\nOutput\n\n\n\nHalfword hours value\n\n\n\n2\n\n\n\nH'13'\n\n*&DT_Minutes*\n\n^*4* <#FNFNTIME2>\n\n\n\n11\n\n\n\nOutput\n\n\n\nCharacter minutes value\n\n\n\n2\n\n\n\nC'03'\n\n*&DT_PMinutes*\n\n^*4* <#FNFNTIME2>\n\n\n\n12\n\n\n\nOutput\n\n\n\nPacked-decimal minutes value\n\n\n\n2\n\n\n\nPL2'3'\n\n*&DT_Iminutes*\n\n^*4* <#FNFNTIME2>\n\n\n\n13\n\n\n\nOutput\n\n\n\nHalfword integer minutes value\n\n\n\n2\n\n\n\nH'3'\n\n*&DT_Seconds*\n\n^*4* <#FNFNTIME2>\n\n\n\n14\n\n\n\nOutput\n\n\n\nCharacter seconds value\n\n\n\n2\n\n\n\nC'51'\n\n*&DT_Pseconds*\n\n^*4* <#FNFNTIME2>\n\n\n\n15\n\n\n\nOutput\n\n\n\nPacked-decimal seconds value\n\n\n\n2\n\n\n\nPL2'51'\n\n*&DT_Iseconds*\n\n^*4* <#FNFNTIME2>\n\n\n\n16\n\n\n\nOutput\n\n\n\nHalfword integer seconds value\n\n\n\n2\n\n\n\nH'51'\n\n\n\n*Table 4. Date/Time Services Supported Interval Formats*\n\nSymbol Name\n\n\n\nFormat Value\n\n\n\nFormat Type\n\n\n\nDescription\n\n\n\nLength\n\n\n\nExample\n\n*&DT_Delta*\n\n\n\n1\n\n\n\nBoth\n\n\n\nInterval in days, hours, minutes, seconds, hundredths\n\n\n\n14\n\n\n\nC'79-15:20:25.43'\n\n*&DT_Days*\n\n\n\n19\n\n\n\nBoth\n\n\n\n2-digit number of days\n\n\n\n5\n\n\n\nC'00025'\n\n*&DT_Pdays*\n\n\n\n20\n\n\n\nBoth\n\n\n\nPacked number of days\n\n\n\n4\n\n\n\nPL4'25'\n\n*&DT_Idays*\n\n\n\n21\n\n\n\nBoth\n\n\n\nInteger number of days\n\n\n\n2\n\n\n\nH'25'\n\n*&DT_Hours*\n\n^*6* <#FNFNINTVL>\n\n\n\n8\n\n\n\nBoth\n\n\n\n2-character hour value\n\n\n\n5\n\n\n\nC'00013'\n\n*&DT_Phours*\n\n^*6* <#FNFNINTVL>\n\n\n\n9\n\n\n\nBoth\n\n\n\n4-byte packed-decimal hours\n\n\n\n4\n\n\n\nPL4'13'\n\n*&DT_Ihours*\n\n^*6* <#FNFNINTVL>\n\n\n\n10\n\n\n\nBoth\n\n\n\nHalfword hours value\n\n\n\n2\n\n\n\nH'13'\n\n*&DT_Minutes*\n\n^*6* <#FNFNINTVL>\n\n\n\n11\n\n\n\nBoth\n\n\n\nCharacter minutes value\n\n\n\n5\n\n\n\nC'00003'\n\n*&DT_PMinutes*\n\n^*6* <#FNFNINTVL>\n\n\n\n12\n\n\n\nBoth\n\n\n\nPacked-decimal minutes value\n\n\n\n4\n\n\n\nPL4'3'\n\n*&DT_Iminutes*\n\n^*6* <#FNFNINTVL>\n\n\n\n13\n\n\n\nBoth\n\n\n\nHalfword integer minutes value\n\n\n\n2\n\n\n\nH'3'\n\n*&DT_Seconds*\n\n^*6* <#FNFNINTVL>\n\n\n\n14\n\n\n\nBoth\n\n\n\nCharacter seconds value\n\n\n\n5\n\n\n\nC'00051'\n\n*&DT_Pseconds*\n\n^*6* <#FNFNINTVL>\n\n\n\n15\n\n\n\nBoth\n\n\n\nPacked-decimal seconds value\n\n\n\n4\n\n\n\nPL4'51'\n\n*&DT_Iseconds*\n\n^*6* <#FNFNINTVL>\n\n\n\n16\n\n\n\nBoth\n\n\n\nHalfword integer seconds value\n\n\n\n2\n\n\n\nH'51'\n\n*&DT_Hundredths*\n\n\n\n2\n\n\n\nBoth\n\n\n\nNumber of .01-second units\n\n\n\n5\n\n\n\nC'01578'\n\n*&DT_Phundredths*\n\n\n\n17\n\n\n\nBoth\n\n\n\nNumber of .01-second units\n\n\n\n4\n\n\n\nPL4'1578'\n\n*&DT_Ihundredths*\n\n\n\n18\n\n\n\nBoth\n\n\n\nNumber of .01-second units\n\n\n\n2\n\n\n\nH'1578'\n\n\n      The General Input Format <#ToC_35>\n\nDate/Time Services provide a generalized input format, known as\n*&DT_General_Input*, which actually provides a format recognition\nfunction for a variety of character date and time formats. If an input\nvalue is declared to be of this format, Date/Time Services attempts to\ndetermine the format: once the format is recognized, Date/Time Services\ntreats the value as though that input format was specified by the\ncaller. The invalid-input return codes indicate that the format was not\nrecognized.\n\nThe following date, time and interval formats are supported by the\n*&DT_General_Input* format:\n\n  *\n\n    *&DT_Civilian*\n\n  *\n\n    *&DT_Gregorian*\n\n  *\n\n    *&DT_HHMM*\n\n  *\n\n    *&DT_HHMMSS*\n\n  *\n\n    *&DT_HHMMSSTH*\n\n  *\n\n    *&DT_Julian*\n\n  *\n\n    *&DT_Juliand*\n\n  *\n\n    *&DT_Normal*\n\n  *\n\n    *&DT_Sgregorian*\n\n  *\n\n    *&DT_Sjulian*\n\n  *\n\n    *&DT_Sjuliand*\n\n  *\n\n    *&DT_Snormal*\n\n  *\n\n    *&DT_Sortdate*\n\n  *\n\n    *&DT_Ssortdate*\n\n  *\n\n    *&DT_SASdate7*\n\n  *\n\n    *&DT_SASdate9*\n\n  *\n\n    *&DT_Text*\n\n\n      Common Parameters <#ToC_36>\n\nThere are several parameters common to any Date/Time Services function\ncall. These are:\n\n\n      Parameter\n\n\n\nDescription\n\nid_name\n\n\n\nspecifies the name of a service processor identifier created by the\nDT_ID macro which will be used by the DT_START macro to automatically\nobtain values for /DT_epa/ and /DT_token/. This parameter is required\nunless both /DT_epa/ and /DT_token/ are specified.\n\nDT_epa\n\n\n\nspecifies the label of a fullword in storage that contains the entry\npoint address of an already-started Date/Time Services service\nprocessor. The value specified by /DT_epa/ overrides any value obtained\nfrom ID=/id_name/.\n\nDT_token\n\n\n\nspecifies the label of a fullword in storage that contains the value\nreturned by DT_START for the /DT_token/ parameter. The value specified\nby /DT_token/ overrides any value obtained from ID=/id_name/.\n\n\n      Return Codes <#ToC_38>\n\nDate/Time Services may issue any of the following return codes in\nvarious situations. Some of the return codes may be received from any\ncall to Date/Time Services, while others are specific to individual\nfunctions.\n\n*Table 5. Return Codes*\n\n*Return Code *\n\n\n\nSymbol\n\n\n\nDescription\n\n0\n\n\n\nDT_SUCCESS\n\n\n\nThe Date/Time Services function has completed successfully.\n\n1\n\n\n\nDT_INVALID_FUNCTION\n\n\n\nAn unsupported function code was received by Date/Time Services.\n\n2\n\n\n\nDT_INVALID_NUMBER_OF_PARMS\n\n\n\nThe Date/Time Services function received an invalid number of\nparameters. This may be due to an improperly coded CALLX or PLIST macro,\nor the inadvertent use of the NOVL option.\n\n3\n\n\n\nDT_INVALID_DT_ID\n\n\n\nDate/Time Services detected an invalid PWA address in DT_token.\n\n4\n\n\n\nDT_ENVIRONMENT_SUPPORT_ERROR\n\n\n\nAn Environment Support function suffered an error.\n\n5\n\n\n\nDT_STRING_HANDLER_ERROR\n\n\n\nAn error was reported by the String Handler service processor. More\ninformation may be found by issuing the ES_DISPLAY_DEBUG_INFO function.\n\n6\n\n\n\nDT_INVALID_DATE_FORMAT\n\n\n\nThe integer fullword provided via the /date_format/ parameter was not a\nsupported Date/Time Services date format.\n\n7\n\n\n\nDT_INVALID_TIME_FORMAT\n\n\n\nThe integer fullword provided via the /time_format/ parameter was not a\nsupported Date/Time Services time format.\n\n8\n\n\n\nDT_INVALID_INTERVAL_FORMAT\n\n\n\nThe integer fullword provided via the /interval_format/ parameter was\nnot a supported Date/Time Services interval format.\n\n9\n\n\n\nDT_INVALID_INPUT_DATE\n\n\n\nThe date value provided by the caller failed validity checking for the\nspecified date format.\n\n10\n\n\n\nDT_INVALID_INPUT_TIME\n\n\n\nThe time value provided by the caller failed validity checking for the\nspecified time format.\n\n11\n\n\n\nDT_INVALID_INPUT_INTERVAL\n\n\n\nThe interval value provided by the caller failed validity checking for\nthe specified interval format.\n\n12\n\n\n\nDT_OVERFLOW\n\n\n\nThe interval value produced by the function is too large for the\nspecified output interval format.\n\n13\n\n\n\nDT_OUT_OF_RANGE\n\n\n\nThe output date/time value is not within the acceptable range for the\nspecified format. This will only occur when using DT_TODclock format,\nwhen the date and time values are outside the range of Jan. 1, 1900 at\n00:00:00.00 and Sept. 17, 2042 at 23:53:47.37.\n\n------------------------------------------------------------------------\n\n\n    Date/Time Services Functions <#ToC_40>\n\nThe remaining sections of this chapter describe all functions provided\nby Date/Time Services, arranged in alphabetical order. Each function's\ndescription begins on a new page, and the name of the function being\ndescribed appears in the top outside corner of every page.\n\n\n      _DT_ADD - __Add Interval To Date And Time_\n\nThe DT_ADD function will add an interval to a date and/or time value.\n\nDT_ADD ID=/id_name/ \u00dd,SPEPA=/DT_epa/\u00a8 \u00dd,SPTOKEN=/DT_token/\u00a8\n   \u00dd,DATEIN=(/date_address,date_format/)\u00a8\n   \u00dd,TIMEIN=(/time_address,time_format/)\u00a8\n   \u00dd,INTERVAL=(/interval_address,interval_format/)\u00a8\n   \u00dd,DATEOUT=(/date_address,time_format/)\u00a8\n   \u00dd,TIMEOUT=(/time_address,time_format/)\u00a8\n\nCALLX /DT_epa/,(/DT_token/,&DT_ADD,/datein_address/\n              ,/datein_format/,/timein_address/,/timein_format/\n              ,/interval_address,interval_format,dateout_address/\n              ,/dateout_format,timeout_address,timeout_format/)\n\n\nParameter\n\n\n\n*Description *\n\ndatein_address\n\n\n\nSpecifies the address of the input date value. For variable-length input\nformats, the field needs only to be as long as the date value, and does\nnot need to be padded with spaces. This is true for all input values for\nDT_ADD.\n\ndatein_format\n\n\n\nSpecifies the format of the input date value. This value may be an\ninteger, numeric symbol, or the address of a fullword in storage. This\nis true of all format specifications for DT_ADD.\n\ntimein_address\n\n\n\nProvides the address of the input time value.\n\ntimein_format\n\n\n\nSpecifies the format of the input time value.\n\ninterval_address\n\n\n\nSpecifies the address of the input interval value.\n\ninterval_format\n\n\n\nSpecifies the format of the input interval value.\n\ndateout_address\n\n\n\nSpecifies the address of the output date value. The area should be large\nenough to hold the longest possible date value for the requested format.\nIf the format is variable-length, it should be cleared to spaces before\nthe call to DT_ADD.\n\ndateout_format\n\n\n\nSpecifies the format of the output date value.\n\ntimeout_address\n\n\n\nProvides the address of the output time value.\n\ntimeout_format\n\n\n\nSpecifies the format of the output time value.\n\n\n\n*Examples*\n\n\nTo add a constant of 75 hours to the date and time values in pwa_date\nand pwa_time, one would code:\n\n     DT_ADD  ID=DT,\n             DATEIN=(pwa_date,&DT_NORMAL),\n             TIMEIN=(pwa_time,&DT_HHMMSS),\n             INTERVAL=('75',&DT_HOURS),\n             DATEOUT=(pwa_date,&DT_NORMAL),\n             TIMEOUT=(pwa_time,&DT_HHMMSS)\n\nThis would replace the contents of pwa_date and pwa_time with the\nupdated date and time values.\n\n\n      _DT_CONVERT - __Date And Time Format Conversion_\n\nThe DT_CONVERT function will convert a date and/or time value from one\nsupported format to another.\n\n     DT_CONVERT ID=/id_name/ \u00dd,SPEPA=/DT_epa/\u00a8 \u00dd,SPTOKEN=/DT_token/\u00a8\n        \u00dd,FROMDATE=(/date_address,date_format/)\u00a8\n        \u00dd,FROMTIME=(/time_address,time_format/)\u00a8\n        \u00dd,TODATE=(/date_address,date_format/)\u00a8\n        \u00dd,TOTIME=(/time_address,time_format/)\u00a8\n\n     CALLX /DT_epa/,(/DT_token/,&DT_CONVERT,/fromdate_address/\n                   ,/fromdate_format/,/fromtime_address/,/fromtime_format/\n                   ,/todate_address/,/todate_format/,/totime_address/\n                   ,/totime_format/)\n\n\n*Parameter *\n\n\n\n*Description *\n\nfromdate_address\n\n\n\nSpecifies the address of the input date value. For variable-length input\nformats, the field needs only to be as long as the date value, and does\nnot need to be padded with spaces. This is true for all input values for\nDT_CONVERT.\n\nfromdate_format\n\n\n\nSpecifies the format of the input date value. This value may be an\ninteger, numeric symbol, or the address of a fullword in storage. This\nis true of all format specifications for DT_CONVERT.\n\nfromtime_address\n\n\n\nProvides the address of the input time value.\n\nfromtime_format\n\n\n\nSpecifies the format of the input time value.\n\ntodate_address\n\n\n\nSpecifies the address of the output date value. The area should be large\nenough to hold the longest possible date value for the requested format.\nIf the format is variable-length, it should be cleared to spaces before\nthe call to DT_CONVERT.\n\ntodate_format\n\n\n\nSpecifies the format of the output date value.\n\ntotime_address\n\n\n\nProvides the address of the output time value.\n\ntotime_format\n\n\n\nSpecifies the format of the output time value.\n\n\n      Examples\n\nIf the current contents of fields pwa_date and pwa_time are date and\ntime are January 7, 1990 and 16:11:30 respectively, the following\nDT_CONVERT macro:\n\nDT_CONVERT  ID=DT,\n            FROMDATE=(pwa_date,&DT_TEXT),\n            FROMTIME=(pwa_time,&DT_HHMMSS),\n            TODATE=(pwa_dateout,&DT_NORMAL),\n            TOTIME=(pwa_timeout,&DT_CIVILIAN)\n\nwould return date and time values in pwa_dateout and pwa_timeout\nrespectively. These values would appear as:\n\n   pwa_dateout    07 JAN 1990\n   pwa_timeout     4:11:30 PM\n\n_*DT_DURATION - *__*Duration Between Two Date/Time Values *_\n\nThe DT_DURATION function will return the duration, or difference,\nbetween two date and/or time values. This duration, returned in interval\nformat, is always a positive number of days, hours, etc.\n\nDT_DURATION ID=/id_name/ \u00dd,SPEPA=/DT_epa/\u00a8 \u00dd,SPTOKEN=/DT_token/\u00a8\n   \u00dd,DATE1=(/date_address,date_format/)\u00a8\n   \u00dd,TIME1=(/date_address,time_format/)\u00a8\n   \u00dd,DATE2=(/date_address,date_format/)\u00a8\n   \u00dd,TIME2=(/date_address,time_format/)\u00a8\n   \u00dd,DURATION=(/duration_address,duration_format/)\u00a8\n\nCALLX /DT_epa/,(/DT_token/,&DT_CONVERT,/date1_address/\n              ,/date1_format/,/time1_address/,/time1_format/\n              ,/date2_address/,/date2_format/,/time2_address/\n              ,/time2_format/,/duration_address/,/duration_format/)\n\n\n*Parameter*\n\n\n\nDescription\n\ndate1_address\n\n\n\nSpecifies the address of the first input date value. For variable-length\ninput formats, the field needs only to be as long as the date value, and\ndoes not need to be padded with spaces. This is true for all input\nvalues for DT_DURATION.\n\ndate1_format\n\n\n\nSpecifies the format of the first input date value. This value may be an\ninteger, numeric symbol, or the address of a fullword in storage. This\nis true of all format specifications for DT_DURATION.\n\ntime1_address\n\n\n\nProvides the address of the first input time value.\n\ntime1_format\n\n\n\nSpecifies the format of the first input time value.\n\ndate2_address\n\n\n\nSpecifies the address of the second input date value.\n\ndate2_format\n\n\n\nSpecifies the format of the second input date value.\n\ntime2_address\n\n\n\nProvides the address of the second input time value.\n\ntime2_format\n\n\n\nSpecifies the format of the second input time value.\n\nduration_address\n\n\n\nProvides the address of the output interval value. The area should be\nlarge enough to hold the longest possible interval value for the\nrequested format. If the format is variable-length, it should be cleared\nto spaces before the call to DT_DURATION.\n\nduration_format\n\n\n\nSpecifies the format of the output interval value.\n\n\n      Examples\n\nIf the fields pwa_date, pwa_date2, pwa_time, and pwa_time2 contain\nvarious date and time values, the following call to DT_DURATION would\nreturn the difference between them in DT_Delta format.\n\nDT_DURATION ID=DT,\n            DATE1=(pwa_date,&DT_TEXT),\n            TIME1=(pwa_time,&DT_HHMMSS),\n            DATE2=(pwa_date2,&DT_NORMAL),\n            TIME2=(pwa_time2,&DT_CIVILIAN)\n            DURATION=(pwa_interval,&DT_DELTA)\n\n_*DT_GET_CURRENT - *__*Return Current Date And Time*_\n\nThe DT_GET_CURRENT function retrieves the current date and/or time. The\nformat requested may be any valid date format for date, and any valid\ntime format for time.\n\nDT_GET_CURRENT ID=/id_name/ \u00dd,SPEPA=/DT_epa/\u00a8 \u00dd,SPTOKEN=/DT_token/\u00a8\n   \u00dd,DATE=(/date_address,date_format/)\u00a8\n   \u00dd,TIME=(/date_address,time_format/)\u00a8\n\nCALLX /DT_epa/,(/DT_token/,&DT_GET_CURRENT,/date_address/\n              ,/date_format\u00dd,time_address,time_format\u00a8/)\n\n\nParameter\n\n\n\nDescription\n\nDescription\n\n\n\n\ndate_address\n\n\n\nProvides the address of an area where Date/Time Services will return the\ncurrent date. The area should be large enough to hold the longest\npossible date value for the requested format. If the format is\nvariable-length, it should be cleared to spaces before the call to\nDT_GET_CURRENT.\n\ndate_format\n\n\n\nSpecifies a format for the date value returned by DT_GET_CURRENT. This\nvalue may be an integer, numeric symbol, or the address of a fullword in\nstorage. This is true of all format specifications for DT_GET_CURRENT.\n\ntime_address\n\n\n\nProvides the address of an area where Date/Time Services will return the\ncurrent time.\n\ntime_format\n\n\n\nSpecifies a format for the time value returned by DT_GET_CURRENT.\n\n\n      Examples\n\nIf the current date and time are January 7, 1990 and 16:11:30\nrespectively, the following DT_GET_CURRENT macro:\n\nDT_GET_CURRENT  ID=DT,\n                DATE=(pwa_date,&DT_NORMAL),\n                TIME=(pwa_time,&DT_CIVILIAN)\n\nwould return date and time values in pwa_date and pwa_time respectively.\nThese values would appear as:\n\n   pwa_date    07 JAN 1990\n   pwa_time     4:11:30 PM\n\n_*DT_ID - *__*Establish Default Date/Time Services Values*_\n\nThe DT_ID macro is used to establish default values for use by other\nDate/Time Services macros, which may access those values through a\nunique identifier, /id_name/, specified by the user. When allowed to\ngenerate default values, this macro will create Program Work Area (PWA)\nstorage for /DT_epa/ and /DT_token/. These values, whether generated by\nthe macro or provided by the user, are accessable from all other\nDate/Time Services macros via the ID=/id_name /parameter.\n\nDT_ID ID=/id_name/\n   \u00dd,SPEPNAME=/DT_epname/\u00a8\n   \u00dd,SPEPA=/DT_epa/\u00a8\n   \u00dd,SPTOKEN=/DT_token/\u00a8\n   \u00dd,ESID=/esid_name/\u00a8\n   \u00dd,ESVA=/esva/\u00a8\n\n\n*Parameter*\n\n\n\nDescription\n\nesid_name\n\n\n\nthe name of a service processor identifier, created by the ES_ID macro,\nwhich will be used by the DT_ID macro to automatically obtain the value\nfor esv (see below).\n\nesva\n\n\n\nSpecifies the label of a fullword in storage that contains (or will\ncontain) the address of the Environment Support Vector (ESV) created by\nthe ES_START function.\n\n\n      Examples\n\nThe following DT_ID macro will associate everything required by the\nDate/Time Services macros with the service processor identifier DT, as\nwell as establish the sizelength value for the Date/Time Services session.\n\n    DT_ID  ID=DT,\n           SPEPNAME=&DATETIME_SERVICES,\n           SPEPA=PWA_DT_ENTRY,\n           SPTOKEN=PWA_DT_TOKEN,\n           ESID=ES,\n           ESVA=PWA_ESVA\n\nPWA_DT_ENTRY  DS    F         Entrypoint for Date/Time Services\nPWA_DT_TOKEN  DS    F         Unique token for Date/Time Services\nPWA_ESVA      DS    F         Environment Support Vector address\n\nNote that this example forces the various operands to specific values\nand addresses. If these are not specified and do not need to be\nexplicitly referenced, simply coding the DT_ID macro with only the ID\nand SPEPNAME operands will cause all of them to be generated automatically.\n\n_*DT_START - Begin A Date/Time Services Session *_\n\nThe DT_START function establishes a new Date/Time Services session and\nreturns its session identifier in the /DT_token/parameter.\n\nDT_START ID=/id_name/ \u00dd,SPEPA=/DT_epa/\u00a8 \u00dd,SPTOKEN=/DT_token/\u00a8\n   \u00dd,ESVA=/esva/\u00a8\n   \u00dd,OPTION=(/option_list/)\u00a8\n\nCALLX /DT_epa/,(/DT_token/,&DT_START,/esva/,/option_byte/)\n\n\n*Parameter *\n\n\n\nDescription\n\nesva\n\n\n\nSpecifies the label of a fullword in storage that contains the address\nof the Environment Support Vector (ESV) created by the ES_START function.\n\noption_list\n\n\n\nA list of additional options for this Date/Time Services session. If\nmultiple option values are specified, they must be enclosed in\nparentheses. The only options currently supported are /EUROPEAN/ and\n/AMERICAN/.\n\n  *\n\n    *EUROPEAN* - Gregorian dates processed by Date/Time Services will be\n    of the format /\"dd/mm/yyyy\"/ If using the CALLX form of /DT_START/,\n    the EUROPEAN option corresponds to a bit setting of X'80' in the\n    option byte.\n\n  *\n\n    *AMERICAN* - Gregorian dates processed by Date/Time Services will be\n    of the format /\"mm/dd/yyyy\"/ If using the CALLX form of /DT_START/,\n    the AMERICAN option corresponds to the X'80' bit being set to zero\n    in the option byte. AMERICAN is the default Gregorian date format.\n\n\n      Examples\n\nThe following DT_START macro will initialize a Date/Time Services session.\n\n  DT_START ID=DT\n\n_*DT_SUBTRACT - Subtract Interval From Date And Time *_\n\nThe DT_SUBTRACT function will subtract an interval from a date and/or\ntime value.\n\nDT_SUBTRACT ID=/id_name/ \u00dd,SPEPA=/DT_epa/\u00a8 \u00dd,SPTOKEN=/DT_token/\u00a8\n   \u00dd,DATEIN=(/date_address,date_format/)\u00a8\n   \u00dd,TIMEIN=(/time_address,time_format/)\u00a8\n   \u00dd,INTERVAL=(/interval_address,interval_format/)\u00a8\n   \u00dd,DATEOUT=(/date_address,time_format/)\u00a8\n   \u00dd,TIMEOUT=(/time_address,time_format/)\u00a8\n\nCALLX /DT_epa/,(/DT_token/,&DT_SUBTRACT,/datein_address/\n              ,/datein_format/,/timein_address/,/timein_format/\n              ,/interval_address,interval_format,dateout_address,/\n              ,/dateout_format,timeout_address,timeout_format/)\n\n\n*Parameter *\n\n\n\nDescription\n\ndatein_address\n\n\n\nSpecifies the address of the input date value. For variable-length input\nformats, the field needs only to be as long as the date value, and does\nnot need to be padded with spaces. This is true for all input values for\nDT_SUBTRACT.\n\ndatein_format\n\n\n\nSpecifies the format of the input date value. This value may be an\ninteger, numeric symbol, or the address of a fullword in storage. This\nis true of all format specifications for DT_ADD.\n\ntimein_address\n\n\n\nProvides the address of the input time value.\n\ntimein_format\n\n\n\nSpecifies the format of the input time value.\n\ninterval_address\n\n\n\nSpecifies the address of the input interval value.\n\ninterval_format\n\n\n\nSpecifies the format of the input interval value.\n\ndateout_address\n\n\n\nSpecifies the address of the output date value. The area should be large\nenough to hold the longest possible date value for the requested format.\nIf the format is variable-length, it should be cleared to spaces before\nthe call to DT_SUBTRACT.\n\ndateout_format\n\n\n\nSpecifies the format of the output date value.\n\ntimeout_address\n\n\n\nProvides the address of the output time value.\n\ntimeout_format\n\n\n\nSpecifies the format of the output time value.\n\n\n      Examples\n\nTo subtract a constant of 75 hours to the date and time values in\npwa_date and pwa_time, one would code:\n\nDT_SUBTRACT ID=DT,\n        DATEIN=(pwa_date,&DT_NORMAL),\n        TIMEIN=(pwa_time,&DT_HHMMSS),\n        INTERVAL=(75,&DT_HOURS),\n        DATEOUT=(pwa_date,&DT_NORMAL),\n        TIMEOUT=(pwa_time,&DT_HHMMSS)\n\nThis would replace the contents of pwa_date and pwa_time with the\nupdated date and time values.\n\n_*DT_TERMINATE - Terminate A Date/Time Services Session *_\n\nThe DT_TERMINATE function concludes the Date/Time Services session\nidentified by the /DT_token/parameter, and releases any resources held\nby the Date/Time Services service processor.\n\nDT_TERMINATE ID=/id_name/ \u00dd,SPEPA=/DT_epa/\u00a8 \u00dd,SPTOKEN=/DT_token/\u00a8\nCALLX /DT_epa/,(/DT_token/,&DT_TERMINATE)\n\n\n      Examples\n\nThe following DT_TERMINATE macro will cause Date/Time Services to\nrelease any resources that it acquired.\n\nDT_TERMINATE ID=DT\n\n------------------------------------------------------------------------\n\n\n  Chapter 6. Environment Support <#ToC_41>\n\nEnvironment Support is both a service processor and the foundation on\nwhich other service processors build. As a service processor, it acts as\nan interface between the programs that use it and the environment in\nwhich they run. As a foundation for other service processors, it\nprovides additional support through a data area called the Environment\nSupport Vector, or ESV.\n\nServices are available in Environment Support for obtaining and\nreleasing main storage, loading and unloading modules, issuing messages,\nand managing debugging information. Services are also available for\nobtaining information about the current execution environment such as\nthe current time and date, userid and group name, JOB card parameters,\nand the prefix to use for qualifying data set names.\n\nEnvironment support consists of a single load module and an assembler\ncopy member containing symbol definitions and macros. The load module\nfor Environment Support must be loaded into main storage and invoked\nwith the ES_START function (see ) before it can be used. After it has\nbeen started, all of Environment Support's functions will remain\navailable until the ES_TERMINATE function (see ) has been invoked.\n\n\n_*Warning:*_Some function descriptions are labeled\n/*Clemson-Specific.*/These functions require operating system extensions\navailable only in Clemson University's production z/OS environment.\nAttempts to use these functions will probably result in unusual return\ncodes or assorted abends.\n\n\n    Symbols & Macros <#ToC_42>\n\nEnvironment Support's symbols and macros can be found in the assembler\ncopy member SRVESMAC. This member contains symbols naming Environment\nSupport's load module, function codes, return codes, and parameter\nvalues. It also contains macros for using all of Environment Support's\nfunctions. The following statement or its equivalent should appear at\nthe beginning of any program that uses Environment Support:\n\n*Figure 13. Environment Support's Symbols and Macros* <#FT_Figure_13>\n\n\n\n  COPY  SRVESMAC      | Obtain Environment Support's symbols & macros.\n\n------------------------------------------------------------------------\n\n\n    Establishing Service Processor Identifiers <#ToC_43>\n\nSeveral parameters are general to Environment Support and not specific\nto any function. These parameters include the load module's name\n(/es_epname/), the entry point address (/es_epa/), the token value\n(/es_token/), and the Environment Support Vector's address (/esva/). The\nES_ID macro (see ) can be used to establish defaults for these\nparameters and associate them with a unique service processor\nidentifier. The identifier may then be supplied on any Environment\nSupport macro instruction to refer to the default parameter values.\n\n------------------------------------------------------------------------\n\n\n    Choosing an Environment Support Load Module <#ToC_44>\n\nIn order to support different execution environments, there may be more\nthan one Environment Support service processor. However, all will have\nthe same basic protocol and will use the same COPY member. Each\nEnvironment Support will reside in a separate load module, and the COPY\nmember will contain a different symbol for each one's load module name.\nThis provides programs with a degree of independence from their\nenvironment, as switching to the appropriate Environment Support service\nprocessor may be all that is required in order to run under different\nenvironments.\n\nEnvironment Support, acting as an interface between programs and their\nexecution environment, has intimate knowledge of the environment in\nwhich it runs. It directly invokes system services and may interrogate\ncontrol blocks. To support multiple execution environments, there must\nbe separate Environment Support service processors for each environment,\nidentical in appearance to calling programs, but existing in separate\nload modules. For example, in addition to the Environment Support that\nruns directly under MVS, there might be one for VM, one for CICS and\nanother for IDMS/DC.\n\nAt the time of this writing, only the MVS/XA programming environment is\nsupported. However, a program that uses Environment Support's services\ninstead of directly accessing its environment can run under different\nenvironments in the future simply by switching to the appropriate\nEnvironment Support module.\n\nSymbols defined in copy member SRVESMAC contain Environment Support's\nload module names enclosed in single quotation marks. The symbol for the\nMVS/XA Environment Support service processor looks like the following:\n\n&MVS_ENVIRONMENT_SUPPORT   SETC  '''SRVESMVS'''\n\nThis symbolic name should be used as the service processor entry point\nname for environment support as shown in the following ES_ID macro.\n\nES_ID ID=UNIQUE_NAME,SPEPNAME=&MVS_ENVIRONMENT_SUPPORT\n\n------------------------------------------------------------------------\n\n\n    Loading Environment Support <#ToC_45>\n\nThe application program or its caller is responsible for loading\nEnvironment Support's load module into storage. Because Environment\nSupport's services are not available until it has been loaded and\nstarted, the load process is environment-dependent. For example, an\nassembler program running under MVS/XA would need to issue a LOAD\nEPNAME=&MVS_ENVIRONMENT_SUPPORT macro instruction and save register 0\n(R0) as the entry point address.\n\nTo take advantage of the defaults established by ES_ID, use one of the\nenvironment-specific load macros available for loading Environment\nSupport. In the MVS/XA environment, the code to identify and load\nEnvironment Support would look like the following:\n\nCOPY        SRVESMAC            Obtain Env. Sup. symbols and macros.\nES_ID       ID=UNIQUE_NAME,SPEPNAME=&MVS_ENVIRONMENT_SUPPORT\nES_MVS_LOAD ID=UNIQUE_NAME      Load Environment Support into storage.\n\nThe ES_MVS_LOAD macro issues the same LOAD instruction described above,\nbut it has access to the entry point address field (/es_epa/) generated\nby the ES_ID macro instruction so nothing needs to be expicitly\nspecified. A complimentary macro, ES_MVS_UNLOAD, will generate the\nappropriate DELETE instruction to remove Environment Support from storage.\n\n------------------------------------------------------------------------\n\n\n    Data Areas <#ToC_46>\n\nThere are three data areas associated with Environment Support: the\nEnvironment Support Vector (ESV), Module Name Tables (MNTs), and the\nDebugging Information Area (DIA). Of these, only the DIA is not directly\naccessable to programs using Environment Support: it is accessed via\nfunction calls instead.\n\n\n      The Environment Support Vector <#ToC_47>\n\nThe ESV is a data area created by Environment during the ES_START\nfunction to hold information specific to the current execution\nenvironment. This information is used internally by Environment Support\nand by other service processors. The fields of the ESV are mapped by the\nES_ESV macro ().\n\nFor the most part, programs do not have any reason to access the ESV's\nfields. However, two of the fields contained in the ESV may be needed\noccasionally. These are the ESVESEPA and the ESVESTKN. The ESVESEPA\ncontains the entry point address of Environment Support, and ESVESTKN\ncontains the token for the service processor session used to create the\nESV. These fields are of particular use to a routine that is called when\nEnvironment Support is already active: if the routine has the address of\nthe ESV, it can easily obtain the entry point address and token needed\nfor calling Environment Support's functions. This is illustrated in the\nfollowing example, which establishes addressability on the ESV just long\nenough to copy the EPA and TOKEN of Environment Support (neither value\nwill change until Environment Support is terminated or unloaded). /(Ref\n#1.)/\n\nBLOCK NAME=CMDEXEC,PARMS=(COMMAND,LENGTH,ESV),                       +\n             OPTIONS=(*PWA,(ESV,3),(PARMS,COPY,PREFIX,VL)\n  L     R1,&PPL.ESV              | R1 -> Environment Support Vector.\n  USING ESV,R1                   | Establish addressability.\n  MVC   &PWA.ES_SPEPA,ESVESEPA   | Copy Environment Support's EPA.\n  MVC   &PWA.ES_SPTOKEN,ESVESEPA | Copy Environment Support's TOKEN.\n  DROP  R1                       | Drop addressability.\n  ES_ID ID=ES,SPEPA=&PWA.ES_SPEPA,SPTOKEN=&PWA.ES_SPTOKEN\n*\n  ES_DISPLAY_MESSAGE ID=ES,MESSAGE='The command to execute is:'\n  ES_DISPLAY_MESSAGE ID=ES,MESSAGE=(*&PPL.COMMAND,*&PPL.LENGTH)\n\n  ... Remainder of program code ...\n\nENDBLK BLOCK=CMDEXEC\n                  PWA\n&PWA.ES_SPEPA     DS  A\n&PWA.ES_SPTOKEN   DS  F\n\n                  ... Remainder of program work area ...\n\n                  ENDPWA\n                  ES_ESV         Environment Support Vector DSECT.\n\n\n      Module Name Tables <#ToC_48>\n\nThe purpose of module name tables (MNTs) is to reduce the number of\nsystem loads that must be performed by the ES_LOAD_MODULE function. Two\nMNTs may be searched by ES_LOAD_MODULE: an application MNT and\nEnvironment Support's MNT. The application MNT is provided as an\noptional parameter to the ES_START function by the calling program. The\nES_LOAD_MODULE function will search the application MNT first and then\nEnvironment Support's MNT.\n\nA module name table is an array of module names and addresses, with each\nrow in the array consisting of an eight character name followed by a\nfour byte address. The final entry in the array is denoted by all zeros.\nTypically, the modules named in an MNT are link-edited with the MNT and\nthe addresses are filled in by the system loader. A module name table\nmay also be filled in by the application program before it starts\nEnvironment Support.\n\nThe structure of an MNT is depicted in Figure 14 <#FIGMNTSTR>, which has\nentries for three service processor modules:\n\n*Figure 14. Module Name Table Layout* <#FT_FIGMNTSTR>\n\n\n\n                Name    TrueName        EPA\n\n------------------------------------------------------------------------\n\n        +0      SRVMM   SRVMM   025BF700        Memory Manager.\n\n------------------------------------------------------------------------\n\n        +20     SRVMS   SRVMSMVS        00000000        Message Services.\n\n------------------------------------------------------------------------\n\n        +40     SRVPL   SRVPLMVS        00000000        Printline.\n\n------------------------------------------------------------------------\n\n        +80     SRVST   SRVST   02487AC0        String Handler.\n\n------------------------------------------------------------------------\n\n        +100    SRVSY   SRVSY   00000000        Symbol Manager.\n\n------------------------------------------------------------------------\n\n        +120    00                      End of MNT.\n\n------------------------------------------------------------------------\n\n\n\nThe first two entries in Figure 14 <#FIGMNTSTR> show modules that have\nbeen loaded into storage. The third entry shows a module that has not\nbeen loaded into storage, so its address field has been set to zeros.\n\nWhen a module's name is found in an MNT and it has a non-zero value in\nthe address field, its address is simply returned to the calling\nprogram. If the address field is zero, ES_LOAD_MODULE will load the\nmodule into storage and return the address to the calling program (which\nmay then fill in the module's address in the MNT). If the module's name\nis not in any MNT, it will always be loaded into storage and its address\nwill be returned to the calling program.\n\n\n      The Debugging Information Area <#ToC_49>\n\nError tracking and reporting capabilities are provided by Environment\nSupport, permitting service processors and other programs to save vital\ndiagnostic information and messages when errors are detected. Service\nprocessors update this area and set a return code whenever they\nencounter problems. The calling program may then issue a single function\ncall to Environment Support to display the diagnostic information and\noptionally abort with a full storage dump. This scheme enables\napplications to make their own decisions about how errors should be\nhandled, but provides an easy way for them to abort execution\nimmediately while providing the user with messages and diagnostic\ninformation.\n\nThe following services are provided for accessing the DIA:\n\n  *\n\n    ES_CLEAR_DEBUG_INFO,\n\n  *\n\n    ES_DISPLAY_DEBUG_INFO,\n\n  *\n\n    ES_DISPLAY_DEBUG_INFO_AND_ABEND, and\n\n  *\n\n    ES_SAVE_DEBUG_INFO\n\n------------------------------------------------------------------------\n\n\n    Common Parameters <#ToC_50>\n\nThere are several parameters common to any Environment Support function\ncall. These parameters are listed below:\n\n\n*Field *\n\n\n\n*Description *\n\nid_name\n\n\n\nthe name of a service processor identifier created by the ES_ID macro\nwhich will be used by all other function invocation macros to\nautomatically obtain values for /es_epa/and /es_token/. This parameter\nis required unless both /es_epa/and /es_token/are specified.\n\nes_epa\n\n\n\na fullword in storage containing the entry point address of the\nEnvironment Support service processor. The value specified by\n/es_epa/overrides any value obtained from ID=/id_name/.\n\nes_token\n\n\n\na fullword in storage containing the value (to be) returned by ES_START\nfor the /es_token/parameter. The value specified by /es_token/overrides\nany value obtained from ID=/id_name/.\n\n\n\n------------------------------------------------------------------------\n\n\n    Complete List of Environment Support Return Codes <#ToC_51>\n\nMany return codes can be returned from each function. In the function\ndescriptions later in this chapter, the most common return codes\nreturned by the particular function are documented. The following is a\ncomplete list of Environment Support return codes.\n\n\n*Return Code *\n\n\n\n*Symbol Name*\n\n\n\n*Description *\n\n0\n\n\n\nES_SUCCESS\n\n\n\nThe invoked Environment Support function performed the requested service\nwithout encountering any problems.\n\n1\n\n\n\nES_MISSING_EXIT_ROUTINE\n\n\n\nThis return code indicates that the ES_START function was unable to\nlocate one of its exit routines, which must either be link-edited into\nthe standard or application module name table or accessable via the\nstandard system load mechanism.\n\n2\n\n\n\nES_INTERNAL_ERROR\n\n\n\nA self-examination within Environment Support determined that something\nwas wrong. This return code indicates a programming error within\nEnvironment Support.\n\n4\n\n\n\nES_INVALID_FUNCTION\n\n\n\nAn invalid /FunctionCode/(the second parameter in any service processor\nfunction call) was specified.\n\n8\n\n\n\nES_COULD_NOT_LOCATE\n\n\n\nThis return code is used by all ES_GET_... functions to indicate that\nthe requested information is unavailable.\n\n12\n\n\n\nES_INVALID_BOUNDARY\n\n\n\nThe /boundary/parameter used for an ES_OBTAIN_STORAGE function call does\nnot contain a valid value.\n\n16\n\n\n\nES_INVALID_LOCATION\n\n\n\nThe /location/parameter used for an ES_OBTAIN_STORAGE function call does\nnot contain a valid value.\n\n17\n\n\n\nES_INVALID_ACTION\n\n\n\nThe /action/parameter used for an ES_CLEAR_DEBUG_INFO function call does\nnot contain a valid value.\n\n18\n\n\n\nES_CLEAR_DEBUG_INHIBITED\n\n\n\nAn explicit attempt was made to clear the debugging information area\n(function call ES_CLEAR_DEBUG_INFO ID=xx,ACTION=EXECUTE), but this\nfunction had been inhibited by a previous call (with ACTION=INHIBIT).\nThe content of the debugging information area has been left intact.\n\n20\n\n\n\nES_STORAGE_NOT_AVAILABLE\n\n\n\nAn ES_OBTAIN_STORAGE function call requested more storage than is\ncurrently available.\n\n24\n\n\n\nES_STORAGE_NOT_RELEASED\n\n\n\nAn ES_RELEASE_STORAGE function call failed because the storage could not\nbe released for some reason (perhaps it was not allocated in the first\nplace?).\n\n28\n\n\n\nES_UNDETERMINED\n\n\n\nAn (internal, probably) error of indeterminate nature has occurred\nwithin Environment Support.\n\n32\n\n\n\nES_MODULE_NOT_LOADED\n\n\n\nAn ES_LOAD_MODULE function call was not able to load the requested\nmodule into storage.\n\n36\n\n\n\nES_MODULE_NOT_UNLOADED\n\n\n\nAn ES_UNLOAD_MODULE function call was not able to unload the requested\nmodule from storage.\n\n40\n\n\n\nES_WRONG_NUMBER_OF_PARMS\n\n\n\nEither too few parameters were supplied for the function call or too\nmany were supplied. Check the parameter list to ensure that it is right\nfor the function being invoked.\n\n\n\n\n    Environment Support Service Processor Functions and Macros <#ToC_52>\n\nThe remaining sections of this chapter describe all functions provided\nby the Environment Support Service Processor, arranged in alphabetical\norder. Each function's description begins on a new page, and the name of\nthe function being described appears in the top outside corner of every\npage. \\\n\n_*ES_CLEAR_DEBUG_INFO - Reset the Debugging Information Area*_\n\nThe ES_CLEAR_DEBUG_INFO function removes all information from the\ndebugging information area. This function is invoked automatically by\nall service processors functions so that the only information retained\nin the debugging area is for the most recent problem.\n\n*Note: *The only return code you should expect from invoking this\nfunction is ES_SUCESS.\n\nES_CLEAR_DEBUG_INFO ID=/id_name/ \u00dd,SPEPA=/es_epa/\u00a8 \u00dd,SPTOKEN=/es_token/\u00a8\n  \u00dd,ACTION=/action/\u00a8\nCALLX /es_epa/,(/es_token/,&ES_CLEAR_DEBUG_INFO,\u00dd/action/\u00a8)\n\n\n*Parameter *\n\n\n\nDescription\n\naction\n\n\n\nAn optional fullword value that specifies what action\nES_CLEAR_DEBUG_INFO should take with respect to clearing the debugging\ninformation area. The default value for /action/is *EXECUTE*(or set\nsymbol &ES_CDI_EXECUTE, a fullword value of *1*), which will clear the\ndebugging information area if this function has not been inhibited. A\nvalue of *INHIBIT*(set symbol &ES_CDI_INHIBIT, a fullword value of *2*)\nwill inhibit clearing of the debugging information area. A value of\n*ENABLE*(set symbol &ES_CDI_ENABLE, a fullword value of *3*) will\nreverse the effect of *INHIBIT*.\n\n\n\n*Note: *Clearing of the debugging information area should not be\ninhibited except under one circumstance: after an error has occurred, an\napplication program or service processor may need to call upon one or\nmore service processor functions to help gather and/or format additional\ndiagnostic information, without losing the information already present\nin the debugging information area. The INHIBIT action should only be\ninvoked under this one condition, and the ENABLE action should be\ninvoked as soon as the additional diagnostic information has been\ngathered and added to the debugging area. Calling on the ENABLE, action\ndoes not, in itself, cause the debugging information area to be cleared.\n\n*Note: *If ES_CLEAR_DEBUG_INFO is invoked while the function is\ninhibited, it will not perform any action but will return a non-zero\nreturn-code (ES_CLEAR_DEBUG_INHIBITED).\n\n\n      Example\n\nSuppose an application program invokes the ST_FORMAT function of the\nstring-handler service processor to format a message. The last field in\nthe message will contain text of unknown length, so the application\nprogram expects to receive the ST_TRUNCATED return code occasionally. In\nthat specific case, the application program has no need for the\ndebugging information and clears it out to avoid having it show up in a\ncore dump if an abend occurs later.\n\n\n\n\n  ST_FORMAT ID=ST,CONTROL='APM0282 Remaining text discarded: %C(V)',        +\n               SOURCE=(INPUT_BUFFER,INPUT_LENGTH),                          +\n               STRING=MESSAGE_BUFFER,RESULT_LENGTH=MESSAGE_LENGTH\n  IF (CH,R15,EQ,=H'&ST_TRUNCATED')    | If some text got truncated.\n    ES_CLEAR_DEBUG_INFO ID=ES         |   Don't worry about it.\n  ELSEIF (TREG,R15,NZ)                | ElseIf there was another problem.\n    STH     R15,PWA_LASTRC            |   Save the return code.\n    MVC     PWA_LASTSP,=C&STRING_HANDLER  Save service processor's name.\n    ERREXIT CODE=&ST_FORMAT           |   Let the error exit handle it.\n  ENDIF                               | EndIf.\n\n\n\n_*ES_DISPLAY_DEBUG_INFO - Display Debugging Information*_\n\nThe ES_DISPLAY_DEBUG_INFO function displays all information currently in\nthe debugging area. This function, or the\nES_DISPLAY_DEBUG_INFO_AND_ABEND function, should be invoked whenever an\nunexpected return code is returned by any service processor function.\n\n*Note: *The only return code you should expect from invoking this\nfunction is ES_SUCESS.\n\nES_DISPLAY_DEBUG_INFO ID=/id_name/ \u00dd,SPEPA=/es_epa/\u00a8 \u00dd,SPTOKEN=/es_token/\u00a8\nCALLX /es_epa/,(/es_token/,&ES_DISPLAY_DEBUG_INFO)\n\n\n      Example\n\nThe error exit of an application program has determined that the return\ncode from a service processor function indicates an environmental\nproblem beyond its control, such as a data set that is allocated to\nanother user, or insufficient storage. The problem needs to be corrected\nbefore execution can continue, so the debugging information is displayed\nand the program terminates execution.\n\nES_DISPLAY_DEBUG_INFO ID=ES              | Dump debugging information.\n\n_*ES_DISPLAY_DEBUG_INFO_AND_ABEND - Abend with Dump*_\n\nThe ES_DISPLAY_DEBUG_INFO_AND_ABEND function displays all information\ncurrently in the debugging area and then issues a system request for an\nabend and storage dump. The actual abend code issued is dependent on the\nimplementation of Environment Support. For the MVS/XA version of\nEnvironment Support, an MVS ABEND instruction with User Code 1000 will\nbe issued.\n\n*Note: *This function does not return control to the application\nprogram. It causes a task abend with a user code of 1000.\n\nES_DISPLAY_DEBUG_INFO_AND_ABEND ID=/id_name/ \u00dd,SPEPA=/es_epa/\u00a8\n  \u00dd,SPTOKEN=/es_token/\u00a8\nCALLX /es_epa/,(/es_token/,&ES_DISPLAY_DEBUG_INFO_AND_ABEND)\n\n\n      Example\n\nThe error exit of an application program has determined that the return\ncode from a service processor function indicates a programming error,\neither within the application or within a service processor. Because the\nerror may be internal to the code being executed, all code and data\nareas should be dumped.\n\nES_DISPLAY_DEBUG_INFO_AND_ABEND ID=ES    | Abort with a core dump.\n\n_*ES_DISPLAY_MESSAGE - Display Text on the User's Screen*_\n\nThe ES_DISPLAY_MESSAGE function is used to write a textual message to\nthe default output device. For a TSO user, it is to the terminal screen;\nfor background TSO, it is to file SYSTSPRT; for a started task, it is to\nthe operator's console.\n\nES_DISPLAY_MESSAGE ID=/id_name/ \u00dd,SPEPA=/es_epa/\u00a8 \u00dd,SPTOKEN=/es_token/\u00a8\n   ,MESSAGE={/message/ | (/message/,/length/)}\nCALLX /es_epa/,(/es_token/,&ES_DISPLAY_MESSAGE,/message/\u00dd,/length/\u00a8)\n\n\n\n*Parameter *\n\n\n\nDescription\n\nmessage\n\n\n\nspecifies the label of a character string in storage containing the\nmessage to be displayed. For both forms of invoking this function,\n/message/may be specified as text enclosed in single quotation marks,\nwhich will cause a character-literal to be generated.\n\nlength\n\n\n\n\u00ddoptional\u00a8 specifies the label of a fullword in storage containing the\nlength of the character string named by /message/. If /length/is\n/not/specified, the storage named by /message/must be prefixed with a\nsigned halfword containing the length of the text to be displayed.\n\n*Note: *For the macro form of invoking this function, if /message/is\nprovided as a quoted string and /length/is not specified, it will be\nautomatically supplied by the macro.\n\n\n      Example\n\nAn application program invokes the ST_FORMAT function of the\nstring-handler to format a message, and then invokes the\nES_DISPLAY_MESSAGE function to display it to the user.\n\nST_FORMAT ID=ST,CONTROL='APM0282 Remaining text discarded: %C(V)',   +\n             SOURCE=(INPUT_BUFFER,INPUT_LENGTH),                     +\n             STRING=MESSAGE_BUFFER,RESULT_LENGTH=MESSAGE_LENGTH\nIF (CH,R15,EQ,=H'&ST_TRUNCATED')    | If some text got truncated.\n  ES_CLEAR_DEBUG_INFO ID=ES         |   Don't worry about it.\nELSEIF (TREG,R15,NZ)                | ElseIf there was another problem.\n  STH     R15,PWA_LASTRC            |   Save the return code.\n  MVC     PWA_LASTSP,=C&STRING_HANDLER  Save service processor's name.\n  ERREXIT CODE=&ST_FORMAT           |   Let the error exit handle it.\nENDIF                               | EndIf.\nES_DISPLAY_MESSAGE ID=ES,MESSAGE=(MESSAGE_BUFFER,MESSAGE_LENGTH)\n\n_*ES_ESV - Environment Support Vector Mapping Macro *_\n\nThe ES_ESV macro is used to map the fields of the Environment Support\nVector, or ESV. For an example of using this macro, see page reference\n#1 <#SPTESVXMP>.\n\nES_ESV\n  \u00dd,DSECT={_*YES*_ | *NO*}\u00a8\n  \u00dd,PREFIX={_*ESV*_ | /prefix/}\u00a8\n\n\n\n*Parameter *\n\n\n\nDescription\n\nDSECT\n\n\n\nthe *DSECT*keyword controls whether or not an assembler DSECT directive\nis generated. The default is *YES*. The value of /prefix/will be used to\nname the DSECT. If DSECT=NO is specified, a label named /prefix/will be\ngenerated at the beginning of the ESV storage.\n\nprefix\n\n\n\nspecifies the name to use for the generated DSECT or label, as well as\nthe prefix for all the labels of all other ESV fields.\n\n\n\n_*ES_GET_CACCT - Get the Computer Center Account Number*_(Clemson-Specific)\n\nThe ES_GET_CACCT function returns to the application the Computer Center\nAccount Number (CACCT) of the currently running job.\n\n*Note: *This function is specific to the /*Clemson University*/computing\nenvironment.\n\nES_GET_CACCT ID=/id_name/ \u00dd,SPEPA=/es_epa/\u00a8 \u00dd,SPTOKEN=/es_token/\u00a8\n   ,CACCT=/cacct/\nCALLX /es_epa/,(/es_token/,&ES_GET_CACCT,/cacct/)\n\n\n\n*Parameter *\n\n\n\nDescription\n\ncacct\n\n\n\nspecifies an eight (8) byte field into which the computer center account\nnumber of the currently running job will be placed.\n\n\n\n_*ES_GET_DEFAULT_DESTINATION - Get Printer Destination*_(Clemson-Specific)\n\nThe ES_GET_DEFAULT_DESTINATION function returns to the application the\nprinter destination of the currently running job.\n\nES_GET_DEFAULT_DESTINATION ID=/id_name/ \u00dd,SPEPA=/es_epa/\u00a8 \u00dd,SPTOKEN=/es_token/\u00a8\n   ,DEST=/dest/\nCALLX /es_epa/,(/es_token/,&ES_GET_DEFAULT_DESTINATION,/dest/)\n\n\n\n*Parameter *\n\n\n\nDescription\n\ndest\n\n\n\nspecifies an eight (8) byte field into which the default printer\ndestination of the currently running job will be placed.\n\n\n\n_*ES_GET_FORMATTED_TIME - Get Time and Date*_\n\nThe ES_GET_FORMATTED_TIME function returns to the application the\ncurrent time of day, gregorian date, and julian date.\n\nES_GET_FORMATTED_TIME ID=/id_name/ \u00dd,SPEPA=/es_epa/\u00a8 \u00dd,SPTOKEN=/es_token/\u00a8\n  \u00dd,TIME=/time/\u00a8\n  \u00dd,GREGORIAN=/gregorian/\u00a8\n  \u00dd,JULIAN=/julian/\u00a8\nCALLX /es_epa/,(/es_token/,&ES_GET_FORMATTED_TIME,\u00dd/time/\u00a8,\n  \u00dd/gregorian/\u00a8,\u00dd/julian/\u00a8)\n\n\n\n*Parameter *\n\n\n\nDescription\n\ntime\n\n\n\nspecifies an eleven (11) byte field into which the current time, in\nHH:MM:SS.TH character format (e.g. 18:09:53.78) will be placed. The time\nis returned in 24-hour format.\n\ngregorian\n\n\n\nspecifies an eight (8) byte field into which the current date, in\nMM/DD/YY character format (e.g. 05/04/89) will be placed.\n\njulian\n\n\n\nspecifies an eight (8) byte field into which the current date, in\nCCYY.DDD character format (e.g. 1989.124) will be placed.\n\n\n\n_*ES_GET_GROUP - Get the RACF Group Name of the Current User*_\n\nThe ES_GET_GROUP function returns to the application the RACF group name\nunder which the current job is running.\n\nES_GET_GROUP ID=/id_name/ \u00dd,SPEPA=/es_epa/\u00a8 \u00dd,SPTOKEN=/es_token/\u00a8\n   ,GROUP=/group/\nCALLX /es_epa/,(/es_token/,&ES_GET_GROUP,/group/)\n\n\n\n*Parameter *\n\n\n\nDescription\n\ngroup\n\n\n\nspecifies an eight (8) byte field into which the RACF group name under\nwhich the currently running job is running will be placed.\n\n_*ES_GET_JOBCARD_NAME - Get the Programmer Comment Field\n*_(Clemson-Specific)\n\nThe ES_GET_JOBCARD_NAME function returns to the application the user\ncomment field from the job card of the currently running job.\n\nES_GET_JOBCARD_NAME_FIELD ID=/id_name/ \u00dd,SPEPA=/es_epa/\u00a8 \u00dd,SPTOKEN=/es_token/\u00a8\n   ,NAME=/name/\nCALLX /es_epa/,(/es_token/,&ES_GET_JOBCARD_NAME,/name/)\n\n\n\n*Parameter *\n\n\n\nDescription\n\nname\n\n\n\nspecifies a twenty (20) byte field into which the programmer name field\nof the currently running job's JOB card will be placed.\n\n\n\n_*ES_GET_JOBCARD_ROOM - Get the Programmer Room Field*_(Clemson-Specific)\n\nThe ES_GET_JOBCARD_ROOM function returns to the application the room\nfield from the job card of the currently running job.\n\nES_GET_JOBCARD_ROOM ID=/id_name/ \u00dd,SPEPA=/es_epa/\u00a8 \u00dd,SPTOKEN=/es_token/\u00a8\n   ,ROOM=/room/\nCALLX /es_epa/,(/es_token/,&ES_GET_JOBCARD_ROOM,/room/)\n\n\n\n*Parameter *\n\n\n\nDescription\n\nroom\n\n\n\nspecifies a four (4) byte field into which the room field of the\ncurrently running job's JOB card will be placed.\n\n\n\n_*ES_GET_JOBID - Get the System Assigned Job Identifier*_(Clemson-Specific)\n\nThe ES_GET_JOBID function returns to the application the system assigned\njob identifier of the currently running job.\n\nES_GET_JOBID ID=/id_name/ \u00dd,SPEPA=/es_epa/\u00a8 \u00dd,SPTOKEN=/es_token/\u00a8\n   ,JOBID=/jobid/\nCALLX /es_epa/,(/es_token/,&ES_GET_JOBID,/jobid/)\n\n\n\n*Parameter *\n\n\n\nDescription\n\njobid\n\n\n\nspecifies an eight (8) byte field into which the system-assigned job\nidentifier for the currently running job will be placed.\n\n_*ES_GET_PREFIX - Get Data Set Name Prefix*_\n\nThe ES_GET_PREFIX function returns to the application the data set name\nprefix to use for unqualified data set names encountered under the\ncurrently running job.\n\nES_GET_PREFIX ID=/id_name/ \u00dd,SPEPA=/es_epa/\u00a8 \u00dd,SPTOKEN=/es_token/\u00a8\n   ,PREFIX=/prefix/\nCALLX /es_epa/,(/es_token/,&ES_GET_PREFIX,/prefix/)\n\n\n\n*Parameter *\n\n\n\nDescription\n\nprefix\n\n\n\nspecifies an eight (8) byte field into which the current TSO user's data\nset name prefix will be placed.\n\n_*ES_GET_SYSRES_VOLUME_NAME - Get Volser of IPL Volume*_\n\nThe ES_GET_SYSRES_VOLUME_NAME function returns to the application the\nvolume serial name of the volume from which the system was IPLed.\n\nES_GET_SYSRES_VOLUME_NAME ID=/id_name/ \u00dd,SPEPA=/es_epa/\u00a8 \u00dd,SPTOKEN=/es_token/\u00a8\n   ,VOLSER=/volser/\nCALLX /es_epa/,(/es_token/,&ES_GET_SYSRES_VOLUME_NAME,/volser/)\n\n\n\n*Parameter *\n\n\n\nDescription\n\nvolser\n\n\n\nspecifies a six (6) byte field into which the volume serial number of\nthe volume from which the currently running system was IPLed will be placed.\n\n_*ES_GET_TERMINAL_NAME - Get the User's Terminal Name*_(Clemson-Specific)\n\nThe ES_GET_TERMINAL_NAME function returns to the application the\nterminal name of the terminal assigned to the current user.\n\nES_GET_TERMINAL_NAME ID=/id_name/ \u00dd,SPEPA=/es_epa/\u00a8 \u00dd,SPTOKEN=/es_token/\u00a8\n   ,NAME=/name/\nCALLX /es_epa/,(/es_token/,&ES_GET_TERMINAL_NAME,/name/)\n\n\n\n*Parameter *\n\n\n\nDescription\n\nname\n\n\n\nspecifies an eight (8) byte field into which the current TSO user's\nterminal name will be placed.\n\n\n\n_*ES_GET_TIME - Get Time and Date*_\n\nThe ES_GET_TIME function returns to the application the current time and\ndate.\n\nES_GET_TIME ID=/id_name/ \u00dd,SPEPA=/es_epa/\u00a8 \u00dd,SPTOKEN=/es_token/\u00a8\n  \u00dd,TIME=/time/\u00a8\n  \u00dd,DATE=/date/\u00a8\nCALLX /es_epa/,(/es_token/,&ES_GET_TIME,/time/,/date/)\n\n\n\n*Parameter *\n\n\n\nDescription\n\ntime\n\n\n\nspecifies a fullword into which the current time of day, in .01 second\nunits, will be placed.\n\ndate\n\n\n\nspecifies a fullword into which the current date, in packed-decimal\nCCYYDDDs format, will be placed.\n\n_*ES_GET_TSU_STC_OR_JOB - Determine the Current Environment*_\n\nThe ES_GET_TSU_STC_OR_JOB function returns to the application an\nindicator of the environment under which it is running.\n\nES_GET_TSU_STC_OR_JOB ID=/id_name/ \u00dd,SPEPA=/es_epa/\u00a8 \u00dd,SPTOKEN=/es_token/\u00a8\n   ,TYPE=/type/\nCALLX /es_epa/,(/es_token/,&ES_GET_TSU_STC_OR_JOB,/type/)\n\n\n\n*Parameter *\n\n\n\nDescription\n\ntype\n\n\n\nspecifies a three (3) byte field into which an indicator of the current\nexecution environment will be placed. The indicator will be \"TSU\" if\nexecuting under foreground TSO, \"STC\" if executing as a started-task,\nand \"JOB\" if executing as a batch job.\n\n\n\n_*ES_GET_USERID - Get the Userid of the Current User*_\n\nThe ES_GET_USERID function returns to the application the userid of the\ncurrently running TSU session.\n\nES_GET_USERID ID=/id_name/ \u00dd,SPEPA=/es_epa/\u00a8 \u00dd,SPTOKEN=/es_token/\u00a8\n   ,USERID=/userid/\nCALLX /es_epa/,(/es_token/,&ES_GET_USERID,/userid/)\n\n\n\n*Parameter *\n\n\n\nDescription\n\nuserid\n\n\n\nspecifies a seven (7) byte field into which the userid of the TSO user\ncurrently logged on will be placed.\n\n\n\n_*ES_ID - Establish Default Environment Support Values*_\n\nThe ES_ID macro is used to establish default values for use by other\nEnvironment Support macros, which may access those defaults through a\nunique identifier, /id_name/, specified by the user. Default values can\nbe established for the following parameters: /es_epname/, /es_epa/,\n/es_token/, and /esva/.\n\nIn most cases, nothing other than the entry point name needs to be\nspecified on the ES_ID macro: it will automatically define working\nstorage fields for the remaining parameters if they are not specified.\nThese values, whether generated by the macro or provided by the user,\nare accessable from all other Environment Support macros.\n\nIf the application program needs to access the parameters directly, then\nthey should be explicitly specified. For example, suppose a program\nreceives as one of its parameters the Environment Support Vector of an\nalready-started Environment Support service processor. In that case, the\nmodule name would not be needed but the entry point address and token\nvalue, already defined within the ESV, would need to be specified.\nAssuming addressability on the ESV, the following ES_ID macro\ninstruction might be used to specify these fields.\n\nES_ID ID=STARTED_ES,SPEPA=ESVESEPA,SPTOKEN=ESVESTKN\nES_ID ID=/id_name/\n  \u00dd,SPEPNAME=/es_epname/\u00a8\n  \u00dd,SPEPA=/es_epa/\u00a8\n  \u00dd,SPTOKEN=/es_token/\u00a8\n  \u00dd,ESVA=/esva/\u00a8\n\n\n\n*Parameter *\n\n\n\nDescription\n\nid_name\n\n\n\nthe identifier to assign to the service processor identifier being\nestablished. This name must be unique for all service processor\nidentifier's.\n\nes_epname\n\n\n\nthe entry point name of the Environment Support service processor module\nthat is being used.\n\nes_epa\n\n\n\nspecifies the label of a fullword in storage that will contain the entry\npoint address of the Environment Support service processor.\n\nes_token\n\n\n\nspecifies the label of a fullword in storage that will contain the token\nassigned by the ES_START function of Environment Support.\n\nesva\n\n\n\nspecifies the label of a fullword in storage that will contain the\naddress of the environment support vector created by the ES_START\nfunction of Environment Support.\n\n\n      Example 1\n\nThe ES_ID macro below is the one most likely to be used in an MVS\nassembler program. It specifies an /id_name/of ES and the entry point\nname for the MVS environment support module, but allows all other values\nto default. The ES_ID macro will generate fields in the Structured\nMacros PWA for holding environment support's entry point address,\nservice processor token fullword, and a pointer to the environment\nsupport vector. All other environment support macros will be able to\naccess those fields simply by specifying ID=ES\n\nES_ID     ID=ES,SPEPNAME=&MVS_ENVIRONMENT_SUPPORT\n\n\n      Example 2\n\nThe next example shows how a program would be set up if it were called\nwith environment support already active. Presumably, the program would\nhave the environment support vector passed to it as one of its\nparameters, and the example shows surrounding program text that takes\nthis into account. This is, in fact, the situation with service\nprocessors themselves; their START function is always called with an ESV\nas one of the parameters.\n\nBLOCK NAME=SERVER,TYPE=PROGRAM,OPTIONS=(*PWA),R1SAVE=R9\n  USING PARM_LIST,R9                       | R9 -> Parm list passed in.\n  L     R8,PARM_ESV                        | R8 -> Active ESV.\n  USING ESV,R8                             | Establish addressability.\n  ES_ID ID=ACTIVE_ES,ESV=PARM_ESV,SPEPA=ESVESEPA,SPTOKEN=ESVESTKN\n  .\n  . Remaining program.\n  .\nENDBLK BLOCK=SERVER\n\nNotice that since the ESV contains fields within it for the EPA and\nTOKEN, its fields may be named directly on the ES_ID macro. However, if\nthis is done, all environment support macros must have addressability to\nthe ESV. It is usually easier to copy these two values to the PWA to\nsave on register usage.\n\n_*ES_LOAD_MODULE - Load a Module into Main Storage*_\n\nThe ES_LOAD_MODULE function is used to load a module into storage. If\nthe module name is in the application Module Name Table (MNT) or the\nstandard MNT and the table entry contains a nonzero entry point address,\nES_LOAD_MODULE returns this address to the caller; otherwise, the\nrequest is satisfied by issuing an MVS LOAD macro.\n\nES_LOAD_MODULE ID=/id_name/ \u00dd,SPEPA=/es_epa/\u00a8 \u00dd,SPTOKEN=/es_token/\u00a8\n  \u00dd,SPID=/spid_name/\u00a8\n  \u00dd,EPNAME=/epname/\u00a8\n  \u00dd,EPA=/epa/\u00a8\n  \u00dd,TYPE={:us.STANDARD:eus. | MNT_ONLY}\nCALLX /es_epa/,(/es_token/,&ES_LOAD_MODULE,/epname/,/epa/\u00dd,/type/\u00a8)\n\n\n\n*Parameter *\n\n\n\nDescription\n\nspid_name\n\n\n\nspecifies the name of a service processor identifier created by any\n/xx/_ID macro which will be used by the ES_LOAD_MODULE macro to\nautomatically obtain values for /epname/and /epa/(see below). This\nparameter is required unless both /epname/and /epa/are specified.\n\nepname\n\n\n\nan eight byte field containing the name of the entry point to be loaded.\nThis parameter may be specified in single quotes if desired, in which\ncase a literal will be created for it. The value specified by\n/epname/overrides any value obtained from SPID=/spid_name/.\n\nepa\n\n\n\nspecifies the address of a fullword into which will be stored the\naddress of the module loaded. The value specified by /epa/overrides any\nvalue obtained from SPID=/spid_name/.\n\ntype\n\n\n\nspecifies the process by which a module may be loaded. The\n*STANDARD*process is to search the application MNT first (if there is\none), then the standard MNT; if the module is not in either MNT or if\nthe located MNT entry contains zeros for its EPA, a normal system load\nwill be performed. The *MNT_ONLY*process will not perform any load if\nthe module is not named in one of the MNTs, although a load may still be\ndone if the module's MNT entry contains zeros for its EPA. For the CALLX\nform of invoking this function, symbols *&ES_LM_STANDARD*and\n*&ES_LM_MNT_ONLY*may be used.\n\n\n      Example\n\nThis example illustrates a program loading several service processors.\nSince each service processor is assigned a unique service processor\nidentifier through xx_ID macro instructions, no tags are explicitly\ncreated in working storage.\n\n*\n* Obtain symbols & macros for all service processors.\n*\n  COPY           SRVESMAC   Environment Support's symbols & macros.\n  COPY           SRVMMMAC   Memory Manager symbols & macros.\n  COPY           SRVSTMAC   String Handler symbols & macros.\n  COPY           SRVSYMAC   Symbol Manager symbols & macros.\n  COPY           SRVFIMAC   Standard File Handler symbols & macros.\n*\n* Establish default values for all service processors.\n*\n  ES_ID          ID=ES,SPEPNAME=&MVS_ENVIRONMENT_SUPPORT\n  MM_ID          ID=MM,SPEPNAME=&MEMORY_MANAGER\n  ST_ID          ID=ST,SPEPNAME=&STRING_HANDLER\n  SY_ID          ID=SY,SPEPNAME=&SYMBOL_MANAGER\n  FI_ID          ID=FI,SPEPNAME=&FI_OS_FILE_HANDLER\n*\n  ES_MVS_LOAD    ID=ES                Load environment support.\n  ES_START       ID=ES                Start environment support.\n  ES_LOAD_MODULE ID=ES,SPID=MM        Load the memory manager.\n  ES_LOAD_MODULE ID=ES,SPID=ST        Load the string handler.\n  ES_LOAD_MODULE ID=ES,SPID=SY        Load the symbol manager.\n  ES_LOAD_MODULE ID=ES,SPID=FI        Load the standard file handler.\n\n_*ES_MNT - Module Name Table Mapping Macro*_\n\nThe ES_MNT macro is used to map individual entries in a Module Name\nTable, or MNT.\n\nES_MNT\n  \u00dd,DSECT={_*YES*_ | *NO*}\u00a8\n  \u00dd,ID={_*ES_MNT*_ | /prefix/}\u00a8\n\n\n\n*Parameter *\n\n\n\nDescription\n\nDSECT\n\n\n\nthe *DSECT*keyword controls whether or not an assembler DSECT directive\nis generated. The default is *YES*. The value of /prefix/will be used to\nname the DSECT. If DSECT=NO is specified, a label named /prefix/will be\ngenerated at the beginning of the MNT storage.\n\nprefix\n\n\n\nspecifies the name to use for the generated DSECT or label, as well as\nthe prefix for all the labels of all other MNT fields.\n\n_*ES_MODULE_NAME - Module Name Table Creation Macro *_\n\nThe ES_MODULE_NAME macro is used generate entries in a static Module\nName Table.\n\nES_MODULE_NAME START,NAME='/table_name/'\n\n- or -\n\nES_MODULE_NAME NAME='/generic_name/'\u00dd,TRUENAME='/entry_name/'\u00a8\n\n- or -\n\nES_MODULE_NAME END\n\n\n\n*Parameter *\n\n\n\nDescription\n\ntable_name\n\n\n\nWill be documented at a later time.\n\ngeneric_name\n\n\n\nWill be documented at a later time.\n\nentry_name\n\n\n\nWill be documented at a later time.\n\n\n\n_*ES_MVS_LOAD - Load MVS Environment Support*_\n\nThe ES_MVS_LOAD macro is used in an MVS environment to load the\nEnvironment Support module into main storage. This is only one possible\nmethod that may be used and is provided as a convenience. This macro has\naccess to all fields identified by the ES_ID macro.\n\nES_MVS_LOAD ID=/id_name/ \u00dd,SPEPNAME=/es_epname/\u00a8 \u00dd,SPEPA=/es_epa/\u00a8\n\n\n\n*Parameter *\n\n\n\nDescription\n\nid_name\n\n\n\nspecifies the name of a service processor identifier created by the\nES_ID macro.\n\nes_epname\n\n\n\nspecifies the entry point name of the Environment Support service\nprocessor module that is being loaded.\n\nes_epa\n\n\n\nspecifies the label of a fullword in storage that will contain the entry\npoint address of the Environment Support service processor.\n\n\n        Return Codes\n\nThe ES_MVS_LOAD macro generates an MVS LOAD instruction, which will\ncause a task abend if the module could not be found or loaded. The\ncontent of register 15 (R15) is unpredictable.\n\n\n      Example\n\nThis example illustrates the intended use of ES_MVS_LOAD. The macro has\naccess to all fields generated by the ES_ID macro, relieving the\nprogrammer of the need to explicitly create any tags.\n\nES_ID       ID=ES,SPEPNAME=&MVS_ENVIRONMENT_SUPPORT  Set up an ES_ID.\nES_MVS_LOAD ID=ES                                    Load Env. Support.\n\n_*ES_MVS_UNLOAD - Unload MVS Environment Support *_\n\nThe ES_MVS_UNLOAD macro complements the ES_MVS_LOAD macro by unloading\nthe environment support module from main storage.\n\nES_MVS_UNLOAD ID=/id_name/ \u00dd,SPEPNAME=/es_epname/\u00a8 \u00dd,SPEPA=/es_epa/\u00a8\n\n\n\n*Parameter *\n\n\n\nDescription\n\nid_name\n\n\n\nspecifies the name of a service processor identifier created by the\nES_ID macro.\n\nes_epname\n\n\n\nspecifies the entry point name of the Environment Support service\nprocessor module that is being loaded.\n\nes_epa\n\n\n\nspecifies the label of a fullword in storage that will contain the entry\npoint address of the Environment Support service processor.\n\n\n\nThe ES_MVS_UNLOAD macro generates an MVS DELETE instruction, which will\nset register 15 (R15) to 0 for successful completion and 4 for\nunsuccessful completion.\n\n\n      Example\n\nThis example illustrates the use of ES_MVS_UNLOAD to complement\nES_MVS_LOAD.\n\nES_ID       ID=ES,SPEPNAME=&MVS_ENVIRONMENT_SUPPORT  Set up an ES_ID.\nES_MVS_LOAD ID=ES                                    Load Env. Support.\n   .\n   . main body of program.\n   .\nES_MVS_UNLOAD ID=ES                                  Unload Env. Sup.\n\n_*ES_OBTAIN_STORAGE - Obtain a Block of Main Storage*_\n\nThe ES_OBTAIN_STORAGE function is used to obtain storage above or below\nthe 16 megabyte line on a doubleword or page boundary. This request for\nstorage is satisfied by issuing an MVS RC-form GETMAIN SVC.\n\nES_OBTAIN_STORAGE ID=/id_name/ \u00dd,SPEPA=/es_epa/\u00a8 \u00dd,SPTOKEN=/es_token/\u00a8\n  \u00dd,SUBPOOL={/subpool/ | *:us.0:eus.*}\u00a8\n  \u00dd,LOCATION={*:us.ANY:eus.* | *BELOW*}\u00a8\n  \u00dd,BOUNDARY={*:us.DOUBLEWORD:eus.* | *PAGE*}\u00a8\n   ,SIZE=/size/\n   ,ADDRESS=/address/\nCALLX /es_epa/,(/es_token/,&ES_OBTAIN_STORAGE,/size/,/subpool/,/boundary/,\n              /location/,/address/)\n\n\n\n*Parameter *\n\n\n\nDescription\n\nsize\n\n\n\na fullword containing the size in bytes of the storage area requested.\n\nsubpool\n\n\n\na fullword containing a binary 0 - 127 for the subpool that the storage\nshould be obtained from.\n\nboundary\n\n\n\nspecifies whether the storage to be obtained should be allocated on a\n*DOUBLEWORD*boundary or a *PAGE*boundary. For the macro, the default is\n*DOUBLEWORD*. There is no default value for the CALLX form of invoking\nthis function, which requires that /boundary/indicate a fullword\ncontaining a 1 (set symbol &ES_DOUBLEWORD_BOUNDARY) if the storage\nshould be obtained on a doubleword boundary and 2 (set symbol\n&ES_PAGE_BOUNDARY) if it should be obtained on a page boundary.\n\nlocation\n\n\n\nspecifies whether the storage to obtained must be allocated from below\nthe 16-megabyte line (*BELOW*) or if it may be obtained from any address\n(*ANY*). The default value for the macro is *ANY*. There is no default\nvalue for the CALLX form of invoking this macro, which requires that\n/location/indicate a fullword containing a 1 (set symbol\n&ES_LOCATION_ANY) if the storage may be allocated at any location and a\n2 (set symbol &ES_LOCATION_BELOW) if the storage must be allocated below\nthe 16-megabyte line.\n\naddress\n\n\n\nspecifies the address of a fullword into which the ES_OBTAIN_STORAGE\nfunction will store the address of the newly obtained storage. This\naddress will only be updated if the request for storage was successful.\n\n\n      Example\n\nThe following macro instruction obtains 256 bytes of storage and saves\nits address in PWA_MSGPTR.\n\n  ES_OBTAIN_STORAGE ID=ES,SIZE=256,ADDRESS=PWA_MSGPTR\n\nAssuming that ID=ES has established ES_EPA and ES_TOKEN as default\nvalues for the /es_epa/and /es_token/parameters, respectively, this\ninstruction could also have been written as\n\n  CALLX ES_EPA,(ES_TOKEN,&ES_OBTAIN_STORAGE,0,&ES_DOUBLEWORD_BOUNDARY,+\n              &ES_LOCATION_ANY,256,PWA_MSGPTR)\n\n_*ES_RELEASE_STORAGE - Release a Block of Main Storage*_\n\nThe ES_RELEASE_STORAGE function is used to release storage obtained by\nthe ES_OBTAIN_STORAGE function. This storage is released by issuing an\nMVS RC-form FREEMAIN SVC.\n\nES_RELEASE_STORAGE ID=/id_name/ \u00dd,SPEPA=/es_epa/\u00a8 \u00dd,SPTOKEN=/es_token/\u00a8\n  \u00dd,SUBPOOL={/subpool/ | *:us.0:eus.*}\u00a8\n   ,SIZE=/size/\n   ,ADDRESS=/address/\nCALLX /es_epa/,(/es_token/,&ES_RELEASE_STORAGE,/size/,/subpool/,/address/)\n\n\n\n*Parameter *\n\n\n\nDescription\n\nsize\n\n\n\na fullword containing the size in bytes of the storage area to be released.\n\nsubpool\n\n\n\na fullword containing a binary 0 - 127 for the subpool of the storage.\n\naddress\n\n\n\nspecifies the address of a fullword that contains the address of ahe\nstorage area to be released.\n\n\n\n_*ES_SAVE_DEBUG_INFO - Save Debugging Information *_\n\nThe ES_SAVE_DEBUG_INFO function stores information in the debugging area\nmaintained by Environment Support. This information may then be\ndisplayed by any service processor.\n\nES_SAVE_DEBUG_INFO ID=/id_name/ \u00dd,SPEPA=/es_epa/\u00a8 \u00dd,SPTOKEN=/es_token/\u00a8\n\nSelect one of\n\n   ,GDI=/gdi/\nor\n   ,TEXT={/text/ | *(*/*text*/*,*/*length*/*)*}\n   \u00dd,LABEL={/label/ | *(*/*label*/*,*/*length*/*)*}\u00a8\nor\n   ,HEX={/hex/ | *(*/*hex*/*,*/*length*/*)*}\n   \u00dd,LABEL={/label/ | *(*/*label*/*,*/*length*/*)*}\u00a8\n\nCALLX /es_epa/,(/es_token/,&ES_SAVE_DEBUG_INFO,\n\nSelect one of\n\n              &ES_DEBUG_ID_GDI,/gdi/)\nor\n              &ES_DEBUG_ID_TEXT,/text/,\u00dd/length/\u00a8,\u00dd/label/\u00a8,\u00dd/length/\u00a8)\nor\n              &ES_DEBUG_ID_HEX,/hex/,\u00dd/length/\u00a8,\u00dd/label/\u00a8,\u00dd/length/\u00a8)\n\n\n\n*Parameter *\n\n\n\nDescription\n\ngdi\n\n\n\ngeneral debug information. Macro SRVGSI will map this control block.\n\ntext\n\n\n\ntext to be saved in debug area. If /length/is not specified, the first\ntwo bytes of the storage referenced by /text/must contain the length of\nthe text.\n\nhex\n\n\n\nhex data to be saved in debug area. If /length/is not specified, the\nfirst two bytes of the storage referenced by /text/must contain the\nlength of the text.\n\nlength\n\n\n\noptional fullword length of the text or hex data to be saved in the\ndebug area.\n\n\n\n_*ES_START - Begin an Environment Support Session *_\n\nThe ES_START function obtains and initializes a new Environment Support\nVector (ESV) and sets up Environment Support's internal working storage.\nA unique session identifier is returned in the /es_token/parameter,\nwhich must be specified when invoking any Environment Support function.\nThe address of the new ESV is returned to the application program via\nthe /es_epa/parameter. If the application provides a Module Name Table\n(MNT), that will be retained within environment support for use by the\nES_LOAD_MODULE and ES_UNLOAD_MODULE functions.\n\nES_START ID=/id_name/ \u00dd,SPEPA=/es_epa/\u00a8 \u00dd,SPTOKEN=/es_token/\u00a8\n  \u00dd,ESVA=/esva/\u00a8\n  \u00dd,MNT=/mnt_address/\u00a8\n  \u00dd,EXITINFO=/exit_info/\u00a8\nCALLX /es_epa/,(/es_token/,&ES_START,/esva/\u00dd,/mnt_address/\u00a8\u00dd,/exit_info/\u00a8)\n\n\n\n*Parameter *\n\n\n\nDescription\n\nmnt_address\n\n\n\n\u00ddoptional\u00a8 specifies the label of a fullword in storage that contains\nthe address of an application Module Name Table.\n\nexit_info\n\n\n\n\u00ddoptional\u00a8 specifies the label of a fullword in storage whose\n/address/will be passed to all Environment Support exit modules as the\nsecond parameter.\n\n\n\n_*ES_TERMINATE - Stop an Environment Support session*_\n\nThe ES_TERMINATE function shuts-down Environment Support. It unloads all\nmodules that have been loaded by the ES_LOAD_MODULE function and are\nstill in storage, frees the storage occupied by the Environment Support\nVector, and releases Environment Support's working storage. Because\nES_TERMINATE frees the ESV, which is used by all service processors, it\nshould be issued only after all other service processors have been\nterminated.\n\nES_TERMINATE ID=/id_name/ \u00dd,SPEPA=/es_epa/\u00a8 \u00dd,SPTOKEN=/es_token/\u00a8\nCALLX /es_epa/,(/es_epa/,&TERMINATE)\n\n_*ES_UNLOAD_MODULE - Remove a Module from Main Storage*_\n\nThe ES_UNLOAD_MODULE function is used to remove a module from storage.\nIf the module name is in the application Module Name Table (MNT) or the\nstandard MNT and the table entry contains a nonzero entry point address,\nES_LOAD_MODULE simply returns to the caller; otherwise, the request is\nsatisfied by issuing an MVS DELETE macro instruction.\n\nES_UNLOAD_MODULE ID=/id_name/ \u00dd,SPEPA=/es_epa/\u00a8 \u00dd,SPTOKEN=/es_token/\u00a8\n  \u00dd,SPID=/spid_name/\u00a8\n  \u00dd,EPNAME={/epname/\u00a8\n  \u00dd,EPA=/epa/\u00a8\nCALLX /es_epa/,(/es_token/,&ES_UNLOAD_MODULE,/epname/)\n\n\n*Parameter *\n\n\n\nDescription\n\nspid_name\n\n\n\nspecifies the name of a service processor identifier created by any\nxx_ID macro, which will be used by the ES_UNLOAD_MODULE macro to\nautomatically obtain values for /epname/and /epa/.\n\nepname\n\n\n\nan eight byte field containing the name of the entry point to be unloaded.\n\nepa\n\n\n\nthe field containing the module's entry point address. This can only be\nspecified on the macro form of ES_UNLOAD_MODULE and will cause the field\nto be set to zeros.\n\n\n------------------------------------------------------------------------\n\n\n  Chapter 7. File Handlers <#ToC_53>\n\nThe File Handlers provide a generalized way to read and write sequential\nfiles. The file handlers all work with the same parameters and produce\nthe same sets of return codes.\n\nThe File Handlers are each environment-dependent, but may be used with\nany Environment Support service processor.\n\n------------------------------------------------------------------------\n\n\n    The Standard File Handler <#ToC_54>\n\nThe standard, or OS, file handler can be used to read and write\nsequential files, in the form of a physical sequential file or an\nindividual PDS member. The OS file handler can also be made to\nconditionally create, replace, or append to a sequential or partitioned\ndataset, or a member of an existing PDS.\n\nIf used to create a file, the OS file handler will translate generalized\nfile characteristic information (estimated number of records, average\nand maximum record length, etc) into information needed by MVS dynamic\nallocation to create the disk dataset. In addition, the file creation\nprocess may be provided with the UNIT, VOLUME and/or DIRBLKS parameters,\nwhich can be set up using the FI_OS_INFO macro. An optimum blocksize is\ncalculated internally based on the type of device the file is being\ncreated on.\n\nWhen creating a dataset, the OS file handler has to determine the\noptimum blocksize before calling MVS dynamic allocation. The OS file\nhandler currently allocates the new dataset in blocks, and attempts to\nfit 6 blocks per track. (For example, a fixed-length file with 80-byte\nrecords would cause a blocksize of 7440 to be selected on a 3380 disk\ndevice.) If a specific volume is requested via the FI_OS_INFO macro, the\nOS file handler will determine what type of device the volume is mounted\non, and calculate an optimum blocksize based on that device type. If a\nvolume is not specified, the device type of the MVS system's IPL volume\nis used.\n\n------------------------------------------------------------------------\n\n\n    The ISPF/PDF File Handler <#ToC_56>\n\n------------------------------------------------------------------------\n\n\n    Preparing to use a File Handler <#ToC_58>\n\n\n      Obtaining File Handler Symbols & Macros <#ToC_59>\n\nThe File Handler symbols and interface macros can be found in the\nassembler copy member SRVFIMAC. This member contains symbols naming the\nFile Handler's load module, function codes, return codes, and parameter\nvalues. It also contains macros for using all of the File Handler's\nfunctions. The following statement or its equivalent should appear at\nthe beginning of any program that uses the string handler:\n\n   COPY SRVFIMAC      Obtain the File Handler symbols & macros.\n\n\n      Establishing File Handler Defaults <#ToC_60>\n\nSome parameters are general to the strihg handler and not specific to\nany function. These parameters include its load module name\n(/fi_epname/), entry point address (/fi_epa/), and token value\n(/fi_token/). The FI_ID macro (see ) can be used to establish defaults\nfor these parameters and associate them with a unique service processor\nidentifier. The identifier may then be supplied on any File Handler\nmacro instruction to refer to the default parameter values.\n\n\n      Identifying the File Handler <#ToC_61>\n\nThe File Handler service processor resides in the load module named by\nthe following symbol definition in copy member SRVFIMAC:\n\n&FI_OS_FILE_HANDLER  SETC  '''SRVFIOS  '''\n\nThis symbolic name should be used as the service processor entry point\nname for the File Handler as shown in the following FI_ID macro\ninstruction.\n\nFI_ID ID=FI,SPEPNAME=&FI_OS_FILE_HANDLER  Set File Handler Defaults.\n\n\n      Loading the File Handler <#ToC_62>\n\nThe recommended method for loading the File Handler is through\nEnvironment Support's ES_LOAD_MODULE function, as shown in the following\nexample:\n\nES_LOAD_MODULE ID=ES,SPID=FI            Load the File Handler\n\n------------------------------------------------------------------------\n\n\n    Common Parameters <#ToC_63>\n\nSeveral parameters are common to all File Handler function calls. These\nparameters are listed below:\n\n\n*Parameter *\n\n\n\nDescription\n\nid_name\n\n\n\nspecifies the name of a service processor identifier created by the\nFI_ID macro which will be used by all other function invocation macros\nto automatically obtain values for /fi_epa/and /fi_token/. This\nparameter is required unless both /fi_epa/and /fi_token/are specified.\n\nfi_epa\n\n\n\na fullword in storage containing the entry point address of the String\nHandler service processor. The value specified by /fi_epa/overrides any\nvalue obtained from ID=/id_name/.\n\nfi_token\n\n\n\nspecifies the label of a fullword in storage that contains the value (to\nbe) returned by FI_START for the /fi_token/parameter. The value\nspecified by /fi_token/overrides any value obtained from ID=/id_name/.\n\n\n\n------------------------------------------------------------------------\n\n\n    Return Codes <#ToC_64>\n\nMany return codes can be returned from each function. In the function\ndescriptions later in this chapter, the most common return codes\nreturned by the particular function are documented. The following is a\ncomplete list of File Handler return codes.\n\n\n*Return Code *\n\n\n\nSymbol\n\n\n\nDescription\n\n0\n\n\n\nFI_SUCCESS\n\n\n\nThe File Handler function has completed successfully.\n\n1\n\n\n\nFI_END_OF_FILE\n\n\n\nEnd of File has been reached.\n\n2\n\n\n\nFI_WARNING\n\n\n\nNon-terminating error occurred.\n\n3\n\n\n\nFI_ERROR\n\n\n\nTerminating error occurred.\n\n4\n\n\n\nFI_SEVERE\n\n\n\nA severe terminating error.\n\n5\n\n\n\nFI_INVALID_SYNTAX\n\n\n\nUnsupported filename syntax. The code is returned by the FI_START\nfunction only; it is used when file-servers are being cascaded to\nindicate that the file name is not for the type of file supported by\nthat particular file server and that the next server should be tried. If\nfile-servers are not being cascaded or if the last one has been tried,\nFI_INVALID_SYNTAX should be treated in the same manner as FI_ERROR.\n\n6\n\n\n\nFI_INVALID_FILEID\n\n\n\nA bad file-token was used.\n\n\n    File Handler Service Processor Functions <#ToC_65>\n\nThe remaining sections of this chapter describe all functions provided\nby the File Handler service processor, arranged in alphabetical order.\nEach function's description begins on a new page, and the name of the\nfunction being described appears in the top outside corner of every page.\n\n_*FI_CLOSE - Close the File Being Processed*_\n\nThe FI_CLOSE function closes the file currently being processed but does\nnot deallocate from it. This function is normally not needed since\nFI_TERMINATE will always close the file for you. However, if you need to\nread the file again from the start and do not want to go through\nallocation again, this function may be used.\n\nFI_CLOSE ID=/id_name/ \u00dd,SPEPA=/fi_epa/\u00a8 \u00dd,SPTOKEN=/fi_token/\u00a8\nCALLX /fi_epa/,(/fi_token/,&FI_CLOSE)\n\n_*FI_GET_INFO - Obtain Information About a File*_\n\nThe FI_GET_INFO function retrieves information about the file identified\nby the /fi_token/parameter. Information that can be obtained through\nthis function includes the most recent message issued, the file's name,\nits logical record length, and its record format.\n\nFI_GET_INFO ID=/id_name/ \u00dd,SPEPA=/fi_epa/\u00a8 \u00dd,SPTOKEN=/fi_token/\u00a8\n  {\n     ,NAME={(/name/,/length/) | /name/},NAMELEN=/namelen/\n    |,MSG={(/msg/,/length/) | /msg/},MSGLEN=/msglen/\n    |,LRECL=/lrecl/\n    |,RECFM=/recfm/\n    |,IDSTRING=/idstring/\n  }\n\nCALLX /fi_epa/,(/fi_token/,&FI_GET_INFO,\n             {\n              &FI_GI_NAME,/name/,/length/,/namelen/\n             |&FI_GI_MSG,/msg/,/length/,/msglen/\n             |&FI_GI_LRECL,/lrecl/\n             |&FI_GI_RECFM,/recfm/\n             |&FI_GI_IDSTRING,/idstring/\n             })\n\n\n\n*Parameter *\n\n\n\nDescription\n\nName, length,namelen\n\n\n\nThese three parameters specify an area in which to return the name of\nthe file being processed, a fullword containing the length of the area,\nand a fullword into which the length of the file's name will be returned.\n\nMsg, length,\nmsglen\n\n\n\nThese three parameters specify an area in which to return the most\nrecently created File Handler message, a fullword containing the length\nof the area, and a fullword into which the length of the message will be\nreturned.\n\nlrecl\n\n\n\nA halfword into which the logical record length of the file being\nprocessed will be returned.\n\nrecfm\n\n\n\nAn eight (8) character area into which the record format of the file\nbeing processed will be returned.\n\nidstring\n\n\n\nAn eight (8) character area into which a file-identifier string will be\nreturned. For members of a partitioned data set or other directory, the\nmember name will be used. For sequential data sets, one of the data\nset's qualifiers will be used.\n\n\n\n_*FI_ID - Establish Default File Handler Values *_\n\nThe FI_ID macro is used to establish default values for use by other\nFile Handler macros, which may access those values through a unique\nidentifier, /id_name/, specified by the user. When allowed to generate\ndefault values, this macro will create Program Work Area (PWA) storage\nfor /fi_epa/and /fi_token/. These values, whether generated by the macro\nor provided by the user, are accessable from all other File Handler\nmacros via the ID=/id_name/parameter.\n\nFI_ID ID=/id_name/\n  \u00dd,SPEPNAME=/fi_epname/\u00a8\n  \u00dd,SPEPA=/fi_epa/\u00a8\n  \u00dd,SPTOKEN=/fi_token/\u00a8\n  \u00dd,ESID=/esid_name/\u00a8\n  \u00dd,ESVA=/esva/\u00a8\n\n\n\n*Parameter *\n\n\n\nDescription\n\nid_name\n\n\n\nthe identifier to assign to the service processor identifier being\nestablished. This name must be unique for all service processor\nidentifier's.\n\nfi_epname\n\n\n\nthe entry point name of the File Handler service processor module that\nis being used. :pLt.fi_epa :pLd.specifies the label of a fullword in\nstorage that will contain the entry point address of the File Handler.\n\nfi_token\n\n\n\nspecifies the label of a fullword in storage that will contain the token\nassigned by the FI_START function of the File Handler.\n\nesid_name\n\n\n\nthe name of a service processor identifier, created by the ES_ID macro,\nwhich will be used by the FI_ID macro to automatically obtain the value\nfor esv (see below).\n\nesva\n\n\n\nspecifies the label of a fullword in storage that contains (or will\ncontain) the address of the Environment Support Vector (ESV) created by\nthe ES_START function.\n\n\n      Example 1\n\nFI_ID     ID=FI_SMS,SPEPNAME=&SMS_FILE_HANDLER\n\n_*FI_OPEN - Open the File For Processing *_\n\nThe FI_OPEN function opens the file currently allocated to and prepares\nfor processing. This will be done automatically by the FI_START function\nunless option *MANUALOPEN*is specified. If an application needs to\nallocate to a file once and then repeatedly open and close the file,\nthis function may be used in conjunction with the *MANUALOPEN*option.\n\nFI_OPEN ID=/id_name/ \u00dd,SPEPA=/fi_epa/\u00a8 \u00dd,SPTOKEN=/fi_token/\u00a8\nCALLX /fi_epa/,(/fi_token/,&FI_OPEN)\n\n_*FI_OS_INFO - Provide OS-Specific Information About A File *_\n\nThe FI_OS_INFO macro is used to build a list of those parameters unique\nto dataset creation using MVS dynamic allocation.\n\nUnlike the other File Handler macros, FI_OS_INFO does not generate a\ncall to a service processor, or establish or use service processor\ndefaults. Instead, FI_OS_INFO generates a parameter list and constructs\ndynamic allocation textunits in the caller's program workarea: this\nlist, in turn, is passed to FI_START using the INFO keyword.\n\nThere is no CALLX equivalent of the FI_OS_INFO macro.\n\nFI_OS_INFO  PL=/parmlist_address/\n          \u00dd,DIRBLKS=/PDS_dirblks/\u00a8\n          \u00dd,UNIT=/unit_name/\u00a8\n          \u00dd,VOLUME=/volume_ID/\u00a8\n          \u00dd,FREE=/free_value/\u00a8\n          \u00dd,SPIN=/spin_value/\u00a8\n          \u00dd,SYSOUT=/sysout_class/\u00a8\n          \u00dd,DS=/storage_area/\u00a8\n\n\n\n*Parameter *\n\n\n\nDescription\n\nPDS_dirblks\n\n\n\nSpecifies the number of PDS directory blocks to be used when creating a\npartitioned dataset. If not specified, the default is 10.\n\nunit_name\n\n\n\nSpecifies the MVS unit name to be used when creating a dataset. If not\nspecified, the default is /SYSDA/.\n\nvolume\n\n\n\nSpecifies the volume serial number where the OS File Handler should\ncreate a dataset. There is no default if volume is not specified, which\nwill cause the dataset to be created on an eligible disk volume mounted\nas /storage/.\n\nfree_value\n\n\n\nKeyword *CLOSE*or *END*, specifying that the file should be freed\n(unallocated) by the system when it is closed or at the end of the\njobstep, respectively.\n\nspin_value\n\n\n\nKeyword *UNALLOC*or *NO*, specifying that the file should be release for\nprinting by the system when it is unallocated or at the end of the job,\nrespectively.\n\n*Note: *When SPIN is used, the corresponding FI_START call should\nspecify OPTIONS=(SYSOUT). :pLt.sysout_class :pLd.specifies that this is\na sysout file and provides the sysout class to use. A sysout class of\n'*' specifies that the system default sysout class should be used.\n\n*Note: *When SYSOUT is used, the corresponding FI_START call should\nspecify OPTIONS=(SYSOUT).\n\nparmlist_address\n\n\n\nProvides a tag that FI_OS_INFO will generate when creating its parameter\nlist. This tag should be specified on the associated FI_START macro.\nThis is the only required parameter on the FI_OS_INOF macro.\n\nstorage_area\n\n\n\nInstructs FI_OS_INFO to construct its parameter list in the program's\n/PWA/or /SWA/. The default is for FI_OS_INFO to construct its parameters\nin the storage area local to the block from which it was called.\n\n\n\n_*FI_READLINE - Read the next Sequential Line from a File *_\n\nThe FI_READLINE function returns the next sequential input line of the\nfile specified by the /fi_token/parameter. The file must have been\nopened with the INPUT_SEQUENTIAL access value.\n\nFI_READLINE ID=/id_name/ \u00dd,SPEPA=/fi_epa/\u00a8 \u00dd,SPTOKEN=/fi_token/\u00a8\n   ,LINE={/line/ | (/line/,/length/)}\n   ,RESULTLEN=/result_len/\nCALLX /fi_epa/,(/fi_token/,&FI_READLINE,/line/,/length/,/result_len/)\n\n\n\n*Parameter *\n\n\n\nDescription\n\nline\n\n\n\nProvides the address of an area in storage where FI_READLINE should\nreturn the next line of input.\n\nlength\n\n\n\nProvides a fullword length of line.\n\nresultlen\n\n\n\nProvides a fullword in storage where FI_READLINE will return the length\nof the line returned.\n\n\n\n_*FI_START - Allocate to and Open a File*_\n\nThe FI_START function locates and opens the file named by /file/, and\nprepares to access it in the manner specified in the /OPTIONS/parameter.\nCurrently, sequential input is supported for all file handlers, and\nsequential output is supported by the OS file handler. Once the file has\nbeen opened, it is ready for processing.\n\nFI_START ID=/id_name/ \u00dd,SPEPA=/fi_epa/\u00a8 \u00dd,SPTOKEN=/fi_token/\u00a8\n  \u00dd,ESVA=/esva/\u00a8\n   ,FILE={/file/ | *(*/*file*/*,*/*length*/*)*}\n  \u00dd,INFO=/info/\u00a8\n  \u00dd,OPTIONS=(/option_list/)\u00a8\n  \u00dd,RECORDLENGTH=/average/ | *(*/*average,maximum*/*)*\u00a8\n  \u00dd,FILESIZE=/initial/ | *(*/*initial,increment*/*)*\u00a8\nCALLX /fi_epa/,(/fi_token/,&FI_START,/esva/,/info/,/file/,/length/,/optionbyte/,\n              /avgreclen/,/maxreclen/,/initialsize/,/increment/\u00a8)\n\n\n\n*Parameter *\n\n\n\nDescription\n\nfile\n\n\n\nspecifies the label of an area in storage containing the name of the\nfile to be opened. The file name must follow standard convention for\nfiles of its type.\n\nlength\n\n\n\nspecifies the label of a fullword in storage that contains a signed\nbinary integer equal to the length of the file name specified by /file/\n\ninfo\n\n\n\nSpecifies the label of a fullword in storage containing a value whose\nmeaning may be different for each file handler service processor. In the\ncase of the OS file handler, the INFO parameter will point to a\nparameter list built by the FI_OS_INFO macro.\n\noptions\n\n\n\nProvides a list of options for handling the file being allocated and\nopened. The supported options are:\n\n  *\n\n    *FILENAME*- The filename provided by the filename parameter is an\n    actual filename (for example, an OS dataset name).\n\n  *\n\n    *FILEID*- The filename provided by the filename parameter is a file\n    identifier of some kind (for example, a preallocated DDNAME if the\n    OS file handler is being used).\n\n  *\n\n    *FILETEMP*- A temporary work file is being created.\n\n  *\n\n    *SYSOUT*- A sysout file is being created. *SYSOUT*requires\n    *OUTPUT*and *NEW*, and implies *ISOCC*.\n\n  *\n\n    *INPUT*- The file is being opened for input processing.\n\n  *\n\n    *OUTPUT*- The file should be opened for output processing.\n\n  *\n\n    *NEW*- The file being opened for *OUTPUT*should be created. If the\n    file already exists, an error will be returned. *NEW*is not valid\n    for files being opened for *INPUT*.\n\n  *\n\n    *REPLACE*- The file being opened for *OUTPUT*should be created if it\n    does not already exist. If it does already exist, its contents will\n    be replaced. *REPLACE*is not valid for files being opened for *INPUT*.\n\n  *\n\n    *EXISTING*- The file must already exist. If the file is being opened\n    for *OUTPUT*, its contents will be replaced.\n\n  *\n\n    *APPEND*- The file being opened for *OUTPUT*should be created if it\n    does not already exist. If it does already exist, all new lines\n    written to it will be appended to the existing contents. *APPEND*is\n    not valid for files being opened for *INPUT*.\n\n  *\n\n    *ISOCC*- Indicates that lines contain ISO carriage control in the\n    first byte. If the file handler supplies the record format for a\n    file, the ISOCC option will cause the appropriate effect; otherwise,\n    the ISOCC option is ignored.\n\n  *\n\n    *AUTOOPEN*- The file will automatically be opened for processing by\n    the FI_START function. This is the default. Related parameter:\n    *MANUALOPEN*.\n\n  *\n\n    *MANUALOPEN*- The file will not be automatically opened by FI_START:\n    it must be opened using the FI_OPEN function before any processing\n    may begin.\n\n  *\n\n    *AUTOFREE*- If the FI_START function allocates a new DDNAME to\n    access the file, it will automatically be unallocated by the\n    corresponding FI_TERMINATE function. Related parameter: *MANUALFREE*.\n\n  *\n\n    *MANUALFREE*- The file will not be unallocated by the FI_TERMINATE\n    function, regardless of how it was allocated.\n\n    The following OPTIONS parameters are mutually exclusive:\n\n  *\n\n    *FILENAME*and *FILEID*.\n\n  *\n\n    *AUTOFREE*and *MANUALFREE*\n\n  *\n\n    *AUTOOPEN*and *MANUALOPEN*\n\n  *\n\n    *INPUT*and *OUTPUT*\n\n  *\n\n    *APPEND*, *EXISTING*, *NEW*, and *REPLACE*\n\n  *\n\n    *INPUT*and any of *APPEND*, *NEW*, *REPLACE*, or *SYSOUT*.\n\noptionvalue\n\n\n\nProvides a one-byte value containing the option flag bits that\ncorrespond to the possible OPTIONS values. Refer to the macro definition\nfor FI_START in copy member SRVFIMAC for the macro variable names that\nrepresent the individual options' bit flags.\n\nrecordlength\n\n\n\nProvides an average and (optionally) a maximum recordlength for a file\nbeing created. During OUTPUT processing, the OS file handler uses the\naverage recordlength to determine the amount of disk space to request,\nas well as to choose an optimum blocksize for the disk device being used\nfor the new file. For variable-length records, the maximum recordlength\nis used to set the logical recordlength.\n\nfilesize\n\n\n\nProvides a primary and (optionally) an incremental number of records\nthat will be stored in the file being created. These values are used to\ndetermine how much disk space to request when a file is being created.\n\n\n\n_*FI_TERMINATE - Close and Release a File *_\n\nThe FI_TERMINATE function ends a session with the File Handler. If the\nfile identified by /fi_token/has been allocated and opened, it will be\nclosed and released. All resources allocated to the session, including\nbuffers, working storage, and enqueues, are released back to the system.\nThis function must be invoked in order to cleanly terminate a File\nHandler session, even if the FI_START function did not complete\nsuccessfully.\n\nFI_TERMINATE ID=/id_name/ \u00dd,SPEPA=/fi_epa/\u00a8 \u00dd,SPTOKEN=/fi_token/\u00a8\nCALLX /fi_epa/,(/fi_token/,&FI_TERMINATE)\n\n\n      Example\n\nThe following statement is all that is needed to shut-down a session\nwith the File Handler.\n\nFI_TERMINATE ID=DATA           Close and release input data file.\n\n_*FI_WRITELINE - Add A Sequential Line To a File*_\n\nThe FI_WRITELINE function adds the line provided by the caller to the\nfile specified on the /FI_START/macro. The file must have been opened\nwith the OUTPUT option.\n\nFI_WRITELINE ID=/id_name/ \u00dd,SPEPA=/fi_epa/\u00a8 \u00dd,SPTOKEN=/fi_token/\u00a8\n   ,LINE={/line/ | (/line/,/length/)}\nCALLX /fi_epa/,(/fi_token/,&FI_WRITELINE,/line/,/length/)\n\n\n*Parameter *\n\n\n\nDescription\n\nline\n\n\n\nProvides the address of a record in storage to be added to the file\nbeing created.\n\nlength\n\n\n\nProvides a fullword length of the record being added to the file.\n\n\n  Chapter 8. Item Manager <#ToC_66>\n\nThe Item Manager can be used to manage units of data, refered to as\nitems. Items can be associated with various data structures, such as,\nlinked lists and hash tables.\n\nThe Item Manager and this chapter are still under development.\n\nThe Item Manager is environment independent.\n\n\n      Obtaining Item Manager Symbols & Macros <#ToC_67>\n\nThe Item Manager's symbols and interface macros can be found in the\nassembler copy member SRVIMMAC. This member contains symbols naming the\nItem Manager's load module, function codes, return codes, and parameter\nvalues. It also contains macros for using all of the Item Manager's\nfunctions. The following statement or its equivalent should appear at\nthe beginning of any program that uses the Item Manager:\n\n   COPY SRVIMMAC      Obtain the Item Manager's symbols & macros.\n\n\n      Establishing Item Manager Defaults <#ToC_68>\n\nSome parameters are general to the Item Manager and not specific to any\nfunction. These parameters include its load module name (/IM_epname/),\nentry point address (/IM_epa/), and token value (/IM_token/). The IM_ID\nmacro (see ) can be used to establish defaults for these parameters and\nassociate them with a unique service processor identifier. The\nidentifier may then be supplied on any Item Manager macro instruction to\nrefer to the default parameter values.\n\n\n      Identifying the Item Manager <#ToC_69>\n\nThe Item Manager service processor resides in the load module named by\nthe following symbol definition in copy member SRVIMMAC:\n\n&ITEM_MANAGER     SETC  '''SRVIM  '''\n\nThis symbolic name should be used as the service processor entry point\nname for the Item Manager as shown in the following IM_ID macro\ninstruction.\n\nIM_ID ID=ST,SPEPNAME=&ITEM_MANAGER     Set Item Manager Defaults.\n\n\n      Loading the Item Manager <#ToC_70>\n\nThe recommended method for loading the Item Manager is through\nEnvironment Support's ES_LOAD_MODULE function, as shown in the following\nexample:\n\nES_LOAD_MODULE ID=ES,SPID=IM            Load the Item Manager\n\n\n      Common Parameters <#ToC_71>\n\nThere are several parameters common to any Item Manager function call.\nThese parameters are listed below:\n\n\n\n*Parameter *\n\n\n\nDescription\n\nid_name\n\n\n\nspecifies the name of a service processor identifier created by the\nIM_ID macro which will be used by all other function invocation macros\nto automatically obtain values for /im_epa/and /im_token/. This\nparameter is required unless both /im_epa/and /im_token/are specified.\n\nim_epa\n\n\n\na fullword in storage containing the entry point address of the Item\nManager service processor. The value specified by /im_epa/overrides any\nvalue obtained from ID=/id_name/.\n\nim_token\n\n\n\nspecifies the label of a fullword in storage that contains the value (to\nbe) returned by IM_START for the /im_token/parameter. The value\nspecified by /im_token/overrides any value obtained from ID=/id_name/.\n\n\n      Complete List of Item Manager Return Codes <#ToC_72>\n\nMany return codes can be returned from each function. In the function\ndescriptions later in this chapter, the most common return codes\nreturned by the particular function, are documented. The following is a\ncomplete list of return code.\n\n\n\n*RC *\n\n\n\nSymbol\n\n\n\nDescription\n\n0\n\n\n\nIM_SUCCESS\n\n\n\nThe function was completely successful.\n\n2\n\n\n\nIM_INVALID_NUMBER_OF_PARMS\n\n\n\nThe number of parameters supplied on the call to a function is not correct.\n\n3\n\n\n\nIM_INVALID_FUNCTION\n\n\n\nThe function code specified on a call to the Item Manager is not valid.\n\n4\n\n\n\nIM_FUNCTION_UNSUPPORTED_FOR_CLASS\n\n\n\nThe function is not supported for the class of the item supplied.\n\n5\n\n\n\nIM_DIV_START_FAILED\n\n\n\nThe Item Manager was not able to start the supplied DIV service processor.\n\n6\n\n\n\nIM_MEMORY_MANAGER_LOAD_ FAILED\n\n\n\nThe Item Manager was not able to load the memory manager.\n\n7\n\n\n\nIM_MEMORY_MANAGER_START_ FAILED\n\n\n\nThe Memory Manager failed when the Item Manager tried to start it.\n\n8\n\n\n\nIM_ITEM_STORAGE_NOT_ INITIALIZED\n\n\n\nItem Manager Managed Storage had not been initialized yet. See for more\ninformation.\n\n9\n\n\n\nIM_SETUP_ALREADY_COMPLETE\n\n\n\nA second call was made to the IM_INITIALIZE function.\n\n11\n\n\n\nIM_INTERNAL_ERROR\n\n\n\nSome kind of internal error has occured in the Item Manager. Use the\ndebug area to find out more information.\n\n12\n\n\n\nIM_INVALID_TOKEN\n\n\n\nAn invalid token was encountered when processing a function.\n\n14\n\n\n\nIM_STORAGE_NOT_AVAILABLE\n\n\n\nThe was not enough memory available in the user region to process the\nfunction.\n\n15\n\n\n\nIM_DV_OPEN_WINDOW_FAILED\n\n\n\nA call to the DV_OPEN_WINDOW function of the associated DIV service\nprocessor has ended with a non-zero return code.\n\n16\n\n\n\nIM_DV_SAVE_FAILED\n\n\n\nA call to the DV_SAVE function of the associated DIV service processor\nhas ended with a non-zero return code.\n\n17\n\n\n\nIM_DV_RESET_FAILED\n\n\n\nA call to the DV_RESET function of the associated DIV service processor\nhas ended with a non-zero return code.\n\n18\n\n\n\nIM_FUNCTION_REQUIRES_DIV\n\n\n\nThe function envoked requires a DIV service processor EPA to be supplied\non the IM_START.\n\n19\n\n\n\nIM_INVALID_ITEM_TYPE_TOKEN\n\n\n\nAn item type token is not valid.\n\n20\n\n\n\nIM_ITEM_SIZE_REQUIRED\n\n\n\nThe itemsize parameter is required on the function call.\n\n21\n\n\n\nIM_NO_ROOM\n\n\n\nThere is not more room in Item Manager Managed Storage and no more can\nbe obtained.\n\n22\n\n\n\nIM_OFFSET_SPECIFIED_WHEN_ SIZE_WAS_ZERO\n\n\n\nThe offset parameter was supplied when the size was zero.\n\n23\n\n\n\nIM_LENGTH_REQUIRED\n\n\n\nThe length parameter is required.\n\n24\n\n\n\nIM_INVALID_OFFSET\n\n\n\nAn invalid offset was supplied.\n\n25\n\n\n\nIM_NOT_YET_SUPPORTED\n\n\n\nThe function of a part of the function is not yet supported.\n\n26\n\n\n\nIM_MISSING_PARAMETER\n\n\n\nA parameter is missing.\n\n27\n\n\n\nIM_INVALID_ITEM_TYPE\n\n\n\nA invalid item type was encountered.\n\n28\n\n\n\nIM_INVALID_ITEM\n\n\n\nA invalid item was encountered.\n\n29\n\n\n\nIM_INVALID_SIZE\n\n\n\nThe size supplied was not valid.\n\n30\n\n\n\nIM_DESCRIPTION_TOO_LONG\n\n\n\nThe description supplied was not valid.\n\n31\n\n\n\nIM_LENGTH_PARM_ERROR\n\n\n\nThe length supplied was not valid.\n\n32\n\n\n\nIM_#_LINKS_PARM_ERROR\n\n\n\nThe #links parmameter supplied was not valid.\n\n33\n\n\n\nIM_LINKS_OFFSET_PARM_ERROR\n\n\n\nThe linksoffset parmameter supplied was not valid.\n\n34\n\n\n\nIM_ITEM_CHARACTERISTICS_ CHANGED\n\n\n\nThe characteristics of the item have changed. An item's length, offset\nof links and number of links, can not be modified.\n\n36\n\n\n\nIM_INVALID_RETURN_AREA_SIZE\n\n\n\nThe return area size supplied is not valid.\n\n37\n\n\n\nIM_KEY_LENGTH_PARM_ERROR\n\n\n\nThe keylength parameter supplied is not valid.\n\n38\n\n\n\nIM_KEY_OFFSET_PARM_ERROR\n\n\n\nThe keyoffset parameter supplied is not valid.\n\n39\n\n\n\nIM_INVALID_DESCRIPTOR_TOKEN\n\n\n\nThe descriptor token parameter supplied is not valid.\n\n40\n\n\n\nIM_INVALID_ITEM_TOKEN\n\n\n\nAn item token is not valid.\n\n41\n\n\n\nIM_CURRENCY_ERROR\n\n\n\nThe proper currency is not established for the function.\n\n42\n\n\n\nIM_INVALID_LINK_NUMBER\n\n\n\nThe link number supplied is not valid.\n\n43\n\n\n\nIM_LINK_NOT_NULL\n\n\n\nA link field is not null that is needed to connect an item to a structure.\n\n44\n\n\n\nIM_AT_END\n\n\n\nAt the end of a structure. For example, a IM_OBTAIN_NEXT was issued and\nthere were no more items in a list.\n\n45\n\n\n\nIM_REQUIRES_PRIOR_LINK\n\n\n\nThis function requires that the structure have prior links.\n\n46\n\n\n\nIM_REQUIRES_FINAL_LINK\n\n\n\nThis function requires that the structure have a final link.\n\n47\n\n\n\nIM_REQUIRES_OWNER_LINK\n\n\n\nThis function requires that the structure have owner links.\n\n48\n\n\n\nIM_NOT_FOUND\n\n\n\nThe item could not be found.\n\n49\n\n\n\nIM_HEAD_NOT_VALID_FOR_ THIS_DESCRIPTOR\n\n\n\nThe headtkn is not valid for this descriptor because the heads are in\nthe descriptor.\n\n50\n\n\n\nIM_INVALID_SFD\n\n\n\nThe Sort Fields Definitions (SFD) is not valid.\n\n51\n\n\n\nIM_INVALID_SORT_TECHNIQUE\n\n\n\nThe sort technique supplied is not valid.\n\n52\n\n\n\nIM_PRTKN_INVALID\n\n\n\nPRTKN specified is not valid.\n\n53\n\n\n\nIM_PRTKN_REQUIRED\n\n\n\nPRTKN required if prior links do not exist.\n\n54\n\n\n\nIM_HEADTKN_INVALID\n\n\n\nHEADTKN specified is not valid.\n\n55\n\n\n\nIM_CURTKN_INVALID\n\n\n\nCURTKN specified is not valid.\n\n56\n\n\n\nIM_ITEMTYPE_MISMATCH\n\n\n\nThe item type of the item being processed does not match the MEMTYPE\nspecified on the create for the corresponding descriptor.\n\n\n\n    Item Manager Service Processor Functions <#ToC_73>\n\nThe remaining sections of this chapter describe all functions provided\nby the Item Manager service processor, arranged in alphabetical order.\nEach function's description begins on a new page, and the name of the\nfunction being described appears in the top outside corner of every page.\n\n_*IM_ADD_TO_DIRECTORY - Add An Item Token to The Token Directory*_\n\nThe IM_ADD_TO_DIRECTORY macro is used to add an item token to the Token\nDirectory. The Token Directory provides a way to symbolically remember\nan item's token.\n\nThis function is not yet implemented.\n\nIM_ADD_TO_DIRECTORY ID=/id_name/ \u00dd,SPEPA=/im_epa/\u00a8 \u00dd,SPTOKEN=/im_token/\u00a8\n   ,NAME={/name/ | (/name/,/name_length/)}\n   ,TOKEN=/token/\nCALLX /im_epa/,(/im_token/,&IM_ADD_TO_DIRECTORY,&c\n/name_length/,/name/,/token/)\n\n\n\n*Parameter *\n\n\n\nDescription\n\nname\n\n\n\nspecifies the label of a string that contains the name to be associated\nwith the token specified with the /token/parameter.\n\nname_length\n\n\n\nspecifies the label of a signed binary integer indicating the length of\nthe string identified by the /name/parameter.\n\ntoken\n\n\n\nspecifies the label of a fullword of storage that contains the token of\nan item.\n\n\n      Example\n\nIM_ADD_TO_DIRECTORY ID=IM,NAME=\"MYTOKEN\",TOKEN=TOKEN_TAG\n\n_*IM_CONVERT_TOKEN_TO_ADDRESS - Convert a Token to an Address*_\n\nThe IM_CONVERT_TOKEN_TO_ADDRESS macro is used to convert a token to its\nvirtual storage address. To use this macro, the token conversion routine\naddress must be obtained. See to find out how to retrieve this address.\n\nIM_CONVERT_TOKEN_TO_ADDRESS ID=/id_name/ \u00dd,SPTOKEN=/im_token/\u00a8\n  \u00dd,TKNCNVT=/tkncnvt/\u00a8\n   ,ITEMTKN=/itemtkn/\n   ,ITEMADDR=/itemaddr/\nNone\n\n\n\n*Parameter *\n\n\n\nDescription\n\ntkncnvt\n\n\n\nspecifies the label of a fullword in storage that contains the entry\npoint address of the token conversion routine.\n\nitemtkn\n\n\n\nspecifies the label of a fullword that contains the token of the item\nfor with a virtual address should be obtained.\n\nitemaddr\n\n\n\nspecifies the label of a fullword into which will be place the virtual\nstorage address of the time.\n\n\n      Example\n\nThis instruction will get the virtual storage address of the item whose\ntoken is in A_TOKEN.\n\n      IM_CONVERT_TOKEN_TO_ADDRESS ID=IM,ITEMTKN=A_TOKEN,            +\n               ITEMADDR=THE_ADDRESS\n\n\n\n*RC *\n\n\n\nSymbol\n\n\n\nDescription\n\n12\n\n\n\nIM_INVALID_TOKEN\n\n\n\nThe token supplied was not valid.\n\n_*IM_CONNECT - Connect An Item*_\n\nThe IM_CONNECT macro is used to connect an item to the structure\ndescribed by a descriptor. This structure can be a linked list or a hash\ntable. See and for information on how to create a structure descriptor.\nThe IM_CONNECT function does not changed currency.\n\nIM_CONNECT ID=/id_name/ \u00dd,SPEPA=/im_epa/\u00a8 \u00dd,SPTOKEN=/im_token/\u00a8\n   ,DESCTKN=/desctkn/\n  \u00dd,ITEMTKN=/itemtkn/\u00a8\n  \u00dd,HEADTKN=/headtkn/\u00a8\nCALLX /im_epa/,(/im_token/,&IM_CONNECT,/desctkn/,/itemtkn/,/headtkn/)\n\n\n\n*Parameter *\n\n\n\nDescription\n\ndesctkn\n\n\n\nspecifies the label of a fullword that contains the token of a\ndescriptor that describes the structure to which the item is to be\nconnected. The descriptor must describe a linked list or a hash table.\n\nitemtkn\n\n\n\nspecifies the label of a fullword that contains the token of the item to\nbe connected. If this parameter is not specified, the item that is\ncurrent of Item Manager is connected.\n\nheadtkn\n\n\n\nspecifies the label of a fullword that contains the token of the item\nthat contains the heads when a structure can have multiple occurances.\nIf this parameter is not specified, the item that is current of item\ntype of the item type specified with the /headtype/parameter on the\nassociated descriptor create function is used.\n\n\n      Example\n\nThis instruction will connect the item that is current of Item Manager\nto the structure described by the descriptor whose token is in the\nfullword at tag A_LIST_DESCRIPTOR_TOKEN.\n\nIM_CONNECT ID=IM,DESCTKN=A_LIST_DESCRIPTOR_TOKEN\n\n_*IM_CREATE_GROUP_DESCRIPTOR - Create A Group Descriptor*_\n\nThe IM_CREATE_GROUP_DESCRIPTOR macro is used to create a group\ndescriptor. A group is used to group items of certain item types in Item\nManager Managed Storage. See for information on specifying a group\ndescriptor when creating an item type descriptor.\n\nIM_CREATE_GROUP_DESCRIPTOR ID=/id_name/ \u00dd,SPEPA=/im_epa/\u00a8 \u00dd,SPTOKEN=/im_token/\u00a8\n   ,DESCTKN=/desctkn/\n  \u00dd,TEXT=/text/\u00a8\n  \u00dd,STGINCR=/stgincr/\u00a8\nCALLX /im_epa/,\n  (/im_token/,&IM_CREATE_GROUP_DESCRIPTOR,/desctkn/,/text/,/stgincr/)\n\n\n\n*Parameter *\n\n\n\nDescription\n\ndesctkn\n\n\n\nspecifies the label of a fullword into which the token of the group\ndescriptor created will be returned.\n\ntext\n\n\n\nspecifies the label of text to be associated with this descriptor. See\nfor information on creating text.\n\nstgincr\n\n\n\nspecifies the label of a fullword that contains the size of the\nincrement of storage that will be obtained each time that more storage\nis required for items that are in this group. If the parameter is not\nspecified, 4K bytes is assumed.\n\n\n      Example\n\nThis instruction will create a group descriptor. The Item Manager will\nassign storage to this group in 128K increments.\n\n      IM_CREATE_GROUP_DESCRIPTOR ID=IM,                             +\n               DESCTKN=A_GROUP_DESCRIPTOR,                             +\n               STGINCR==A(128*1024)\n\n_*IM_CREATE_HASH_TABLE_DESCRIPTOR - Create A Hash Table Descriptor *_\n\nThe IM_CREATE_HASH_TABLE_DESCRIPTOR macro is used to create a structure\ndescriptor for a hash table.\n\nBecause of the number of links involved, the Item Manager does not\nsupport multiple occurrences of a hash table. You can simulate multiple\noccurrences by creating multiple hash table descriptors and storing\ntheir tokens in the link fields of the appropriate items.\n\nIM_CREATE_HASH_TABLE_DESCRIPTOR ID=/id_name/\n  \u00dd,SPEPA=/im_epa/\u00a8 \u00dd,SPTOKEN=/im_token/\u00a8\n   ,DESCTKN=/desctkn/\n  \u00dd,MEMTYPE=/memtype/\u00a8\n  \u00dd,TEXT=/text/\u00a8\n  \u00dd,OPTIONS=(\u00ddDUPLICATE_KEYS_ALLOWED\u00a8)\u00a8\n  \u00dd,ENTRIES=/entries/\u00a8\n   ,SYNLNK#=/synlnk#/\n   ,KEYOFF=/keyoff/\n   ,KEYSZ=/keysz/|(IN_ITEM,/keysz_offset/)\nCALLX /im_epa/,(/im_token/,&IM_CREATE_HASH_TABLE_DESCRIPTOR,/desctkn/,/text/,\n      /optbyte/,/entries./,/synlnk#/,/keyoff/,/keysz/,/keysz_offset/,/memtype/)\n\n\n\n*Parameter *\n\n\n\nDescription\n\ndesctkn\n\n\n\nspecifies the label of a fullword into which the token of the hash table\ndescriptor created will be returned.\n\nmemtype\n\n\n\nspecifies the label of a halfword which contains the item type of items\nthat can be members of the hash table. If this parameter is not\nspecified, items with a mixture of item types can be connected to the\nhash table.\n\ntext\n\n\n\nspecifies the label of text to be associated with this descriptor. See\nfor information on creating text.\n\noptbyte\n\n\n\nspecifies the options byte. :pLt.entries :pLd.specifies a fullword that\ncontains the number of entries that should be in the root part of the\nhash table. Although the item manager does not check, this number should\nbe prime. If this parameter is not specified, 101 entries is assumed.\n\nsynlnk#\n\n\n\nspecifies a fullword that contains the link number within item connected\nto this hash table, that will be used to chain synonyms.\n\nkeyoff\n\n\n\nspecifies a fullword that contains the offset of the key within each\nitem connected to this hash table. :pLt.keysz :pLd.specifies a fullword\nthat contains the size of the key. If this parameter is not specified,\nthe /keysize_offset/parameter must be specified. Keys can not be greater\nthan 255 bytes long.\n\nkeysz_offset\n\n\n\nspecifies a fullword that contains the offset within each item of one\nbyte that contains the size of the key in that item. This parameter is\nmutually exclusive with the /keysz/parameter.\n\n\n      Example\n\nThis instruction will create a hash table descriptor. A 5 byte key is in\neach item at an offset of 6. The 2nd link field of each item is used for\nthe hash table synonym chain.\n\n      IM_CREATE_HASH_TABLE_DESCRIPTOR ID=IM,                           +\n               DESCTKN=A_HASH_TABLE_DESCRIPTOR,                        +\n               SYNLNK#=2,                                              +\n               KEYOFF=6,                                               +\n               KEYSZ=5\n\n_*IM_ID - Establish Default Item Manager Values*_\n\nThe IM_ID macro is used to establish default values for use by other\nItem Manager macros, which may access those values through a unique\nidentifier, /id_name/, specified by the user. When allowed to generate\ndefault values, this macro will create Program Work Area (PWA) storage\nfor /im_epa/and /im_token/. These values, whether generated by the macro\nor provided by the user, are accessable from all other Item Manager\nmacros via the ID=/id_name/parameter.\n\nIM_ID ID=/id_name/\n  \u00dd,SPEPNAME=/IM_epname/\u00a8\n  \u00dd,SPEPA=/im_epa/\u00a8\n  \u00dd,SPTOKEN=/im_token/\u00a8\n  \u00dd,ESID=/esid_name/\u00a8\n  \u00dd,ESVA=/esva/\u00a8\n  \u00ddoptional keywords specific to Item Manager\u00a8\n\n\n\n*Parameter *\n\n\n\nDescription\n\nid_name\n\n\n\nthe identifier to assign to the service processor identifier being\nestablished. This name must be unique for all service processor identifiers.\n\nIM_epname\n\n\n\nthe entry point name of the Item Manager service processor module that\nis being used.\n\nim_epa\n\n\n\nspecifies the label of a fullword in storage that will contain the entry\npoint address of the Environment Support service processor.\n\nim_token\n\n\n\nspecifies the label of a fullword in storage that will contain the token\nassigned by the IM_START function of the String Handler.\n\nesid_name\n\n\n\nthe name of a service processor identifier, created by the ES_ID macro,\nwhich will be used by the IM_ID macro to automatically obtain the value\nfor esv (see below).\n\nesva\n\n\n\nspecifies the label of a fullword in storage that contains (or will\ncontain) the address of the Environment Support Vector (ESV) created by\nthe ES_START function.\n\n\n      Example 1\n\nIM_ID ID=ES,SPEPNAME=&ITEM_MANAGER\n\n_*IM_CREATE_ITEM_TYPE_DESCRIPTOR - Create An Item Type Descriptor *_\n\nThe IM_CREATE_ITEM_TYPE_DESCRIPTOR macro is used to create a item type\ndescriptor.\n\nUnlike all other tokens, which are four bytes long, the token for an\nitem type descriptor is only two bytes long. The first two bytes of\nevery item is the token of the item type descriptor that describes that\nitem's characteristics.\n\nIM_CREATE_ITEM_TYPE_DESCRIPTOR ID=/id_name/\n  \u00dd,SPEPA=/im_epa/\u00a8 \u00dd,SPTOKEN=/im_token/\u00a8\n   ,ITEMTYPE=/itemtype/\n  \u00dd,TEXT=/text/\u00a8\n  \u00dd,OPTIONS=(/\u00ddFIRST_LINK_HAS_DESCRIPTION\u00a8/)\n  \u00dd,GROUPTKN=/grouptkn/\u00a8\n   ,ITEMSZ=/itemsz/ | (IN_ITEM,/itemsz_offset/,/itemsz_lensize/)\n  \u00dd,#LINKS=/#links/ | (IN_ITEM,/#links_offset/,/#links_lensize/)\u00a8\n  \u00dd,LINKSOFF=/linksoff/ | (IN_ITEM,/linksoff_offset/,/linksoff_lensize/)\u00a8\nCALLX /im_epa/,(/im_token/,&IM_CREATE_ITEM_TYPE_DESCRIPTOR,/itemtype/,/text/,\n      /optbyte/,/grouptkn/,/itemsz/,/#links/,/linksoff/,\n      /itemsz_lensize/,/itemsz_offset/,/#links_lensize/,/#links_offset/,\n      /linksoff_lensize/,/linksoff_offset/)\n\n\n\n*Parameter *\n\n\n\nDescription\n\nitemtype\n\n\n\nspecifies the label of a halfword into which the token of the item type\ndescriptor created will be returned.\n\ntext\n\n\n\nspecifies the label of text to be associated with this descriptor. See\nfor information on creating text.\n\noptbyte\n\n\n\nspecifies the options byte.\n\ngrouptkn\n\n\n\nspecifies the label of a fullword that contains the token of the group\ndescriptor to be used when creating items of this type. See for further\ninformation on creating group descriptors. If this parameter is not\nspecified, items of this type will go into the default user group. See\nfor information on the size of the storage increment for the default\nuser group.\n\nitemsz\n\n\n\nspecifies a fullword that contains the length of items of this type.\nThis parameter is mutually exclusive with the /itemsz_offset/and\n/itemsz_lensize/parameters and is required if they are not specified.\n\nitemsz_offset\n\n\n\nspecifies a fullword that contains the offset within each item of this\ntype of the item's length.\n\nitemsz_lensize\n\n\n\nspecifies a fullword that contains the size of the item length within\neach item of this type. This length can be 1, 2, 3 or 4.\n\n#links\n\n\n\nspecifies a fullword that contains the number of links in items of this\ntype. This parameter is mutually exclusive with the /#links_offset/and\n/#links_lensize/parameters and is required if they are not specified.\n\n#links_offset\n\n\n\nspecifies a fullword that contains the offset within each item of this\ntype of the item's number of links.\n\n#links_lensize\n\n\n\nspecifies a fullword that contains the size of the field within each\nitem of this type that contains its number of links. This length can be\n1, 2, 3 or 4.\n\nlinksoff\n\n\n\nspecifies a fullword that contains the offset of the links in items of\nthis type. This parameter is mutually exclusive with the\n/linksoff_offset/and /linksoff_lensize/parameters an is required if they\nare not specified.\n\nlinksoff_offset\n\n\n\nspecifies a fullword that contains the offset within each item of this\ntype of the item's links offset.\n\nlinksoff_lensize\n\n\n\nspecifies a fullword that contains the size of the field within each\nitem of this type that contains its links offset. This length can be 1,\n2, 3 or 4.\n\n\n      Example\n\nThis instruction will create an item type descriptor. Each items stored\nwith the token returned by this function in its first two bytes will be\n32 bytes long with two links at its end.\n\n      IM_CREATE_ITEM_TYPE_DESCRIPTOR ID=IM,                         +\n               ITEMTYPE=ITEM_TYPE_DESCRIPTOR,                          +\n               ITEMSZ=32,#LINKS=2,LINKOFF=24\n\n_*IM_CREATE_LINKED_LIST_DESCRIPTOR - Create A Linked List Descriptor*_\n\nThe IM_CREATE_LINKED_LIST_DESCRIPTOR macro is used to create a linked\nlist descriptor.\n\nThe sorted list related options and parameters for this function are not\nyet implemented. Also, LIST_ORDER_NEXT and LIST_ORDER_PRIOR are not yet\nimplemented.\n\nIM_CREATE_LINKED_LIST_DESCRIPTOR ID=/id_name/\n  \u00dd,SPEPA=/im_epa/\u00a8 \u00dd,SPTOKEN=/im_token/\u00a8\n   ,DESCTKN=/desctkn/\n  \u00dd,TEXT=/text/\u00a8\n  \u00dd,OPTIONS=(\u00ddHEADS_IN_DESCRIPTOR\u00a8\n             \u00dd,DUPLICATE_KEYS_ALLOWED\u00a8\n             \u00dd,LIST_ORDER_FIRST\u00a8\n             \u00dd,LIST_ORDER_FINAL\u00a8\n             \u00dd,LIST_ORDER_NEXT\u00a8\n             \u00dd,LIST_ORDER_PRIOR\u00a8\n             \u00dd,LIST_ORDER_SORTED_ASCENDING\u00a8\n             \u00dd,LIST_ORDER_SORTED_DESCENDING\u00a8)\n  \u00dd,FSTLNK#=/fstlnk#/\u00a8\n  \u00dd,FNLLNK#=/fnllnk#/\u00a8\n   ,NXTLNK#=/nxtlnk#/\n  \u00dd,PRLNK#=/prvlnk#/\u00a8\n  \u00dd,OWNLNK#=/ownlnk#/\u00a8\n  \u00dd,HEADTYPE=/headtype/\u00a8\n  \u00dd,MEMTYPE=/memtype/\u00a8\n  \u00dd,KEYOFF=/keyoff/\u00a8\n  \u00dd,KEYSZ=/keysz/|(IN_ITEM,/keysz_offset/)\u00a8\nCALLX /im_epa/,(/im_token/,&IM_CREATE_LINKED_LIST_DESCRIPTOR,/desctkn/,/text/,\n      /optbyte/,/fstlnk#./,/fnllk#/,/nxtlk#/,/prlnk#/,\n      /headtype/,/keyoff/,/keysz/,/keysz_offset/,/memtype/)\n\n\n\n*Parameter *\n\n\n\nDescription\n\ndesctkn\n\n\n\nspecifies the label of a fullword into which will be returned the token\nof the linked list descriptor created.\n\ntext\n\n\n\nspecifies the label of text to be associated with this descriptor. See\nfor information on creating text.\n\noptbyte\n\n\n\nspecifies the options byte.\n\nHEADS_IN_ DESCRIPTOR\n\n\n\nindicates that the heads for the list will be contained in the list\ndescriptor.\n\nLIST_ORDER_FIRST\n\n\n\nindicates that normally items will be connected to the start of the list.\n\nLIST_ORDER_FINAL\n\n\n\nindicates that normally items will be connected to the end of the list.\n\nfstlnk#\n\n\n\nspecifies the label of a fullword that contains the link number of the\n\"first link\" in the associated head items. Do not specify this parameter\nif OPTIONS=HEADS_IN_DESCRIPTOR is specified. If\nOPTIONS=HEADS_IN_DESCRIPTOR is not specified, this parameter is required.\n\nfnllnk#\n\n\n\nspecifies the label of a fullword that contains the link number of the\n\"final link\" in the associated head items. Do not specify this parameter\nif OPTIONS=HEADS_IN_DESCRIPTOR is specified.\n\nnxtlnk#\n\n\n\nspecifies the label of a fullword that contains the link number of the\n\"next link\" in the associated member items.\n\nprlnk#\n\n\n\nspecifies the label of a fullword that contains the link number of the\n\"prior link\" in the associated member items.\n\nownlnk#\n\n\n\nspecifies the label of a fullword that contains the link number of the\n\"owner link\" in the associated member items.\n\nheadtype\n\n\n\nspecifies the label of a halfword which contains the item type of the\nitems that will head the lists. Do not specify this parameter if\nOPTIONS=HEADS_IN_DESCRIPTOR is specified. If OPTIONS=HEADS_IN_DESCRIPTOR\nis not specified, this parameter is required.\n\nmemtype\n\n\n\nspecifies the label of a halfword which contains the item type of items\nthat can be members of the linked list. If this parameter is not\nspecified, items with a mixture of item types can be connected to the\nlinked list.\n\nkeyoff\n\n\n\nspecifies the label of a fullword which contains the offset of the key\nin items of the list.\n\nkeysz\n\n\n\nspecifies the label of a fullword which contains the size of the key.\n\nkeysz_offset\n\n\n\nspecifies the label of a fullword which contains the offset of the one\nbyte key size in associated item.\n\n\n      Example\n\nThis instruction will create a\n\n      IM_CREATE_LINKED_LIST_DESCRIPTOR ID=IM,                          +\n               DESCTKN=A_LINKED_LIST_DESCRIPTOR,                       +\n               NXTLNK#=4\n\n_*IM_DESTORY - Destroy A Descriptor*_\n\nThe IM_DESTORY macro is used to destroy a descriptor created by one of\nthe create functions.\n\nThis function is not yet implemented.\n\nIM_DESTORY ID=/id_name/ \u00dd,SPEPA=/im_epa/\u00a8 \u00dd,SPTOKEN=/im_token/\u00a8\n   ,DESCTKN=/desctkn/\nCALLX /im_epa/,(/im_token/,&IM_DESTROY,/desctkn/)\n\n\n\n*Parameter *\n\n\n\nDescription\n\ndesctkn\n\n\n\nspecifies the label of a fullword that contains the token of a\ndescriptor to destroy. The descriptor must not be associated with any items.\n\n\n      Example\n\nThis instruction will destroy the descriptor whose token is in the\nfullword at tag A_DESCRIPTOR_TOKEN.\n\n      IM_DESTORY ID=IM,DESCTKN=A_DESCRIPTOR_TOKEN\n\n_*IM_DISCONNECT - Disconnect An Item *_\n\nThe IM_DISCONNECT macro is used to disconnect an item from the structure\ndescribed by a descriptor. This structure can be a linked list or a hash\ntable. See for information on how to connect an item to a structure. No\nitem is current of descriptor for the descriptor specified after this\nfunction has completed. Other currency remains unchanged.\n\nThis function is only implemented for linked lists.\n\nIM_DISCONNECT ID=/id_name/ \u00dd,SPEPA=/im_epa/\u00a8 \u00dd,SPTOKEN=/im_token/\u00a8\n   ,DESCTKN=/desctkn/\n  \u00dd,ITEMTKN=/itemtkn/\u00a8\n  \u00dd,HEADTKN=/headtkn/\u00a8\n  \u00dd,PRTKN=/prtkn/\u00a8\nCALLX /im_epa/,(/im_token/,&IM_DISCONNECT,/desctkn/,/itemtkn/,/headtkn/,/prtkn/)\n\n\n\n*Parameter *\n\n\n\nDescription\n\ndesctkn\n\n\n\nspecifies the label of a fullword that contains the token of a\ndescriptor that describes the structure to which the item is to be\ndisconnected. The descriptor must describe a linked list or a hash table.\n\nitemtkn\n\n\n\nspecifies the label of a fullword that contains the token of the item to\nbe disconnected. If this parameter is not specified, the item that is\ncurrent of Item Manager is disconnected.\n\nheadtkn\n\n\n\nspecifies the label of a fullword that contains the token of the item\nthat contains the heads when a structure can have multiple occurances.\nIf this parameter is not specified, the item that is current of item\ntype of the item type specified with the /headtype/parameter on the\nassociated descriptor create function is used.\n\nprtkn\n\n\n\nspecifies the label of a fullword that contains the token of the item\nprior to the one to be disconnected. If this parameter is not specified,\nthe associated descriptor must have a prior link.\n\n\n      Example\n\nThis instruction will disconnect the item that is current of Item\nManager from the structure described by the descriptor whose token is in\nthe fullword at tag A_LIST_DESCRIPTOR_TOKEN.\n\n      IM_DISCONNECT ID=IM,DESCTKN=A_LIST_DESCRIPTOR_TOKEN\n\n_*IM_ERASE - Erase An Item *_\n\nThe IM_ERASE macro is used to erase an item from Item Manager Managed\nStorage.\n\nIM_ERASE ID=/id_name/ \u00dd,SPEPA=/im_epa/\u00a8 \u00dd,SPTOKEN=/im_token/\u00a8\n  \u00dd,OPTIONS=(\u00ddBYPASS_LINKS_CHECK\u00a8)\u00a8\n  \u00dd,ITEMTKN=/itemtkn/\u00a8\nCALLX /im_epa/,(/im_token/,&IM_ERASE,/optbyte/,/itemtkn/)\n\n\n\n*Parameter *\n\n\n\nDescription\n\noptbyte\n\n\n\nspecifies the label of a byte that contains options.\n\nitemtkn\n\n\n\nspecifies the label of a fullword that contains the token of the item to\nbe erased. If this parameter is not specified, the item that is current\nof Item Manager is erased.\n\n\n      Example\n\nThis instruction will erase the item that is current of Item Manager\nfrom Item Manager Managed Storage.\n\n      IM_ERASE ID=IM\n\n\n\n*Return Code *\n\n\n\nSymbol\n\n\n\nDescription\n\n0\n\n\n\nIM_SUCCESS\n\n\n\nThe IM_ERASE function has successfully erased the item from Item Manager\nManaged Storage.\n\n_*IM_FIND - Find An Item By Its Token*_\n\nThe IM_FIND macro is used to locate an item by its item token. The item\nfound will become current of Item Manager and current of item type.\n\nIM_FIND ID=/id_name/ \u00dd,SPEPA=/im_epa/\u00a8 \u00dd,SPTOKEN=/im_token/\u00a8\n   ,ITEMTKN=/itemtkn/\n  \u00dd,ACTUALSZ=/actualsz/\u00a8\nCALLX /im_epa/,(/im_token/,&IM_FIND,/itemtkn/,/actualsz/)\n\n\n\n*Parameter *\n\n\n\nDescription\n\nid_name\n\n\n\nspecifies the name of a service processor identifier created by the\nIM_ID macro which will be used by the IM_FIND macro to automatically\nobtain values for /im_epa/and /im_token/. This parameter is required\nunless both /im_epa/and /im_token/are specified.\n\nim_epa\n\n\n\nspecifies the label of a fullword in storage that contains the entry\npoint address of an already-started Item Manager service processor. The\nvalue specified by /im_epa/overrides any value obtained from ID=/id_name/.\n\nim_token\n\n\n\nspecifies the label of a fullword in storage that contains the value\nreturned by IM_START for the /im_token/parameter. The value specified by\n/im_token/overrides any value obtained from ID=/id_name/.\n\nitemtkn\n\n\n\nspecifies the label of a fullword that contains the token of the item to\nbe located.\n\nactualsz\n\n\n\nspecifies the label of a fullword into which will be place the actual\nsize of the item found.\n\n\n      Example\n\nThis instruction will find the item whose token is in the fullword at\nlabel ITEM_TOKEN.\n\n      IM_FIND ID=IM,ITEMTKN=ITEM_TOKEN\n\n_*IM_FIND_BY_KEY - Find An Item By Key*_\n\nThe IM_FIND_BY_KEY macro is used to locate an item by its key. The item\nfound will become current of Item Manager and current of item type.\n\nIM_FIND_BY_KEY ID=/id_name/ \u00dd,SPEPA=/im_epa/\u00a8 \u00dd,SPTOKEN=/im_token/\u00a8\n   ,DESCTKN=/desctkn/\n   ,KEY=/key/ | (/key/,/key_length/)\n  \u00dd,ITEMTKN=/itemtkn/\u00a8\n  \u00dd,ACTUALSZ=/actualsz/\u00a8\nCALLX /im_epa/,(/im_token/,&IM_FIND_BY_KEY,/desctkn/,/key_length/,/key/,\n      /actualsz/,/itemtkn/)\n\n\n\n*Parameter *\n\n\n\nDescription\n\ndesctkn\n\n\n\nspecifies the label of a fullword that contains the token of descriptor\nthat describes the structure in which the item should be found.\n\nkey_length\n\n\n\nspecifies a fullword that contains the length of the key. Trailing\nblanks are ignored in the compare, so the key can still match a item in\nItem Manager Managed Storage even if the key length of that item is not\nthe same as the key length specified.\n\nkey\n\n\n\nspecifies the label of a field that contains the key of the item to locate.\n\nactualsz\n\n\n\nspecifies the label of a fullword into which will be placed the actual\nsize of the item found.\n\nitemtkn\n\n\n\nspecifies the label of a fullword into which will be placed the token of\nthe item located.\n\n\n      Example\n\nThis instruction will find the item in the linked list described by\nA_LIST_DESCRIPTOR that has a key of \"XYZZY\".\n\n      IM_FIND_BY_KEY ID=IM,DESCTKN=A_LIST_DESCRIPTOR,KEY=\"XYZZY\"\n\n_*IM_FIND_CURRENT_OF_DESCRIPTOR - Find the Item That is Current of\nDescriptor*_\n\nThe IM_FIND_CURRENT_OF_DESCRIPTOR macro is used to locate an item that\nis current of a given descriptor. The item found will become current of\nItem Manager and current of item type.\n\nIM_FIND_CURRENT_OF_DESCRIPTOR ID=/id_name/\n  \u00dd,SPEPA=/im_epa/\u00a8 \u00dd,SPTOKEN=/im_token/\u00a8\n   ,DESCTKN=/desctkn/\n  \u00dd,ITEMTKN=/itemtkn/\u00a8\n  \u00dd,ACTUALSZ=/actualsz/\u00a8\nCALLX /im_epa/,(/im_token/,&IM_FIND_CURRENT_OF_DESCRIPTOR,/desctkn/,\n      /actualsz/,/itemtkn/)\n\n\n\n*Parameter *\n\n\n\nDescription\n\ndesctkn\n\n\n\nspecifies the label of a fullword that contains the token of descriptor\nthat describes the structure in which the item should be found.\n\nactualsz\n\n\n\nspecifies the label of a fullword into which will be placed the actual\nsize of the item found.\n\nitemtkn\n\n\n\nspecifies the label of a fullword into which will be placed the token of\nthe item located.\n\n\n      Example\n\nThis instruction will find the item that is current of descriptor for\nthe structure described by A_LIST_DESCRIPTOR.\n\n      IM_FIND_CURRENT_OF_DESCRIPTOR ID=IM,DESCTKN=A_LIST_DESCRIPTOR\n\n_*IM_FIND_CURRENT_OF_ITEM_TYPE - Find the Item That is Current of Item\nType*_\n\nThe IM_FIND_CURRENT_OF_ITEM_TYPE macro is used to locate an item that is\ncurrent of a given item type. The item found will become current of Item\nManager and remain current of item type.\n\nIM_FIND_CURRENT_OF_ITEM_TYPE ID=/id_name/ \u00dd,SPEPA=/im_epa/\u00a8\u00dd,SPTOKEN=/im_token/\u00a8\n   ,ITEMTYPE=/itemtype/\n  \u00dd,ITEMTKN=/itemtkn/\u00a8\n  \u00dd,ACTUALSZ=/actualsz/\u00a8\nCALLX /im_epa/,(/im_token/,&IM_FIND_ITEM_TYPE,/itemtype/,/actualsz/,/itemtkn/)\n\n\n\n*Parameter *\n\n\n\nDescription\n\nitemtype\n\n\n\nspecifies the label of a halfword that contains the token of item type\ndescriptor for the item that should be found.\n\nactualsz\n\n\n\nspecifies the label of a fullword into which will be placed the actual\nsize of the item found.\n\nitemtkn\n\n\n\nspecifies the label of a fullword into which will be placed the token of\nthe item located.\n\n\n      Example\n\nThis instruction will find the item that is current of item type for the\nstructure described by A_LIST_DESCRIPTOR.\n\n      IM_FIND_CURRENT_OF_ITEM_TYPE ID=IM,DESCTKN=A_LIST_DESCRIPTOR\n\n_*IM_FIND_FINAL - Find the Final Item in a Structure*_\n\nThe IM_FIND_FINAL macro is used to locate the final item in a structure.\nThis functions is supported for Linked Lists. The item found will become\ncurrent of Item Manager, current of descriptor and current of item type.\n\nIM_FIND_FINAL ID=/id_name/ \u00dd,SPEPA=/im_epa/\u00a8 \u00dd,SPTOKEN=/im_token/\u00a8\n   ,DESCTKN=/desctkn/\n  \u00dd,ITEMTKN=/itemtkn/\u00a8\n  \u00dd,ACTUALSZ=/actualsz/\u00a8\n  \u00dd,HEADTKN=/headtkn/\u00a8\nCALLX /im_epa/,\n  (/im_token/,&IM_FIND_FINAL,/desctkn/,/actualsz/,/itemtkn/,/headtkn/)\n\n\n\n*Parameter *\n\n\n\nDescription\n\ndesctkn\n\n\n\nspecifies the label of a fullword that contains the token of descriptor\nthat describes the structure in which the item should be found.\n\nactualsz\n\n\n\nspecifies the label of a fullword into which will be placed the actual\nsize of the item found.\n\nitemtkn\n\n\n\nspecifies the label of a fullword into which will be placed the token of\nthe item located.\n\nheadtkn\n\n\n\nspecifies the label of a fullword that contains the token of the head\nitem for the list. This parameter only applies to lists that do not\ncontain heads in the descriptor. If this parameter is not specified, the\nitem that is current of item type of the HEADTYPE associated with the\ndescriptor will be used.\n\n\n      Example\n\nThis instruction will find the final item in the linked list described\nby A_LIST_DESCRIPTOR.\n\n      IM_FIND_FINAL ID=IM,DESCTKN=A_LIST_DESCRIPTOR\n\n_*IM_FIND_FIRST - Find the First Item in a Structure*_\n\nThe IM_FIND_FIRST macro is used to locate the first item in a structure.\nThis functions is supported for Linked Lists. The item found will become\ncurrent of Item Manager, current of descriptor and current of item type.\n\nIM_FIND_FIRST ID=/id_name/ \u00dd,SPEPA=/im_epa/\u00a8 \u00dd,SPTOKEN=/im_token/\u00a8\n   ,DESCTKN=/desctkn/\n  \u00dd,ITEMTKN=/itemtkn/\u00a8\n  \u00dd,ACTUALSZ=/actualsz/\u00a8\n  \u00dd,HEADTKN=/headtkn/\u00a8\nCALLX /im_epa/,\n  (/im_token/,&IM_FIND_FIRST,/desctkn/,/actualsz/,/itemtkn/,/headtkn/)\n\n\n\n*Parameter *\n\n\n\nDescription\n\ndesctkn\n\n\n\nspecifies the label of a fullword that contains the token of descriptor\nthat describes the structure in which the item should be found.\n\nactualsz\n\n\n\nspecifies the label of a fullword into which will be placed the actual\nsize of the item found.\n\nitemtkn\n\n\n\nspecifies the label of a fullword into which will be placed the token of\nthe item located.\n\nheadtkn\n\n\n\nspecifies the label of a fullword that contains the token of the head\nitem for the list. This parameter only applies to lists that do not\ncontain heads in the descriptor. If this parameter is not specified, the\nitem that is current of item type of the HEADTYPE associated with the\ndescriptor will be used.\n\n\n      Example\n\nThis instruction will find the first item in the linked list described\nby A_LIST_DESCRIPTOR.\n\n      IM_FIND_FIRST ID=IM,DESCTKN=A_LIST_DESCRIPTOR\n\n_*IM_FIND_IN_DIRECTORY - Find An Item Token in The Token Directory *_\n\nThe IM_FIND_IN_DIRECTORY macro is used to get an item token in the token\ndirectory. Currency is not changed.\n\nThis function is not yet implemented.\n\nIM_FIND_IN_DIRECTORY ID=/id_name/ \u00dd,SPEPA=/im_epa/\u00a8 \u00dd,SPTOKEN=/im_token/\u00a8\n   ,NAME={/name/ | (/name/,/name_length/)}\n   ,TOKEN=/token/\nCALLX /im_epa/,(/im_token/,&IM_FIND_IN_DIRECTORY,/name_length/,/name/,/token/)\n\n\n\n*Parameter *\n\n\n\nDescription\n\nname\n\n\n\nspecifies the label of a string that contains the name that is\nassociated with the token specified with the /token/parameter.\n\nname_length\n\n\n\nspecifies the label of a signed binary integer indicating the length of\nthe string identified by the /name/parameter.\n\ntoken\n\n\n\nspecifies the label of a fullword of storage into which will be placed\nthe token of the associated item.\n\n\n      Example\n\nThis instruction will find the item token associated with the name\n\"MY_TOKEN\" and put it in TOKEN_TAG.\n\n      IM_FIND_IN_DIRECTORY ID=IM,NAME=\"MY_TOKEN\",TOKEN=TOKEN_TAG\n\n_*IM_FIND_NEXT - Find the Next Item in a Structure *_\n\nThe IM_FIND_NEXT macro is used to locate the next item in a structure.\nThis functions is supported for Linked Lists. The item found will become\ncurrent of Item Manager, current of descriptor and current of item type.\n\nIM_FIND_NEXT ID=/id_name/ \u00dd,SPEPA=/im_epa/\u00a8 \u00dd,SPTOKEN=/im_token/\u00a8\n   ,DESCTKN=/desctkn/\n  \u00dd,ITEMTKN=/itemtkn/\u00a8\n  \u00dd,ACTUALSZ=/actualsz/\u00a8\n  \u00dd,CURTKN=/curtkn/\u00a8\n  \u00dd,HEADTKN=/headtkn/\u00a8\nCALLX /im_epa/,(/im_token/,&IM_FIND_NEXT,/desctkn/,/actualsz/,/itemtkn/,\n      /curtkn/,/headtkn/)\n\n\n\n*Parameter *\n\n\n\nDescription\n\ndesctkn\n\n\n\nspecifies the label of a fullword that contains the token of descriptor\nthat describes the structure in which the item should be found.\n\nactualsz\n\n\n\nspecifies the label of a fullword into which will be placed the actual\nsize of the item found.\n\nitemtkn\n\n\n\nspecifies the label of a fullword into which will be placed the token of\nthe item located.\n\ncurtkn\n\n\n\nspecifies the label of a fullword that contains the token of the current\nitem in the list. If this parameter is not specified, the item that is\ncurrent of descriptor will be used. If this parameter has a value of\nzero, the first item in the list will be found.\n\nheadtkn\n\n\n\nspecifies the label of a fullword that contains the token of the head\nitem for the list. This parameter only applies to lists that do not\ncontain heads in the descriptor. If this parameter is not specified, the\nitem that is current of item type of the HEADTYPE associated with the\ndescriptor will be used.\n\n\n      Example\n\nThis instruction will find the next item in the linked list described by\nA_LIST_DESCRIPTOR.\n\n      IM_FIND_NEXT ID=IM,DESCTKN=A_LIST_DESCRIPTOR\n\n_*IM_FIND_OWNER - Find the Owner Item of an item in a Structure *_\n\nThe IM_FIND_OWNER macro is used to locate the owner item of an item in a\nstructure. This functions is supported for Linked Lists. The item found\nwill become current of Item Manager and current of item type.\n\nIM_FIND_OWNER ID=/id_name/ \u00dd,SPEPA=/im_epa/\u00a8 \u00dd,SPTOKEN=/im_token/\u00a8\n   ,DESCTKN=/desctkn/\n  \u00dd,ITEMTKN=/itemtkn/\u00a8\n  \u00dd,ACTUALSZ=/actualsz/\u00a8\n  \u00dd,CURTKN=/curtkn/\u00a8\nCALLX /im_epa/,\n  (/im_token/,&IM_FIND_OWNER,/desctkn/,/actualsz/,/itemtkn/,/curtkn/)\n\n\n\n*Parameter *\n\n\n\nDescription\n\ndesctkn\n\n\n\nspecifies the label of a fullword that contains the token of descriptor\nthat describes the structure in which the item should be found.\n\nactualsz\n\n\n\nspecifies the label of a fullword into which will be placed the actual\nsize of the item found.\n\nitemtkn\n\n\n\nspecifies the label of a fullword into which will be placed the token of\nthe item located.\n\ncurtkn\n\n\n\nspecifies the label of a fullword that contains the token of the item in\nthe list for which the owner should be found. If this parameter is not\nspecified, the item that is current of Item Manager will be used.\n\n\n      Example\n\nThis instruction will find the owner item in the linked list described\nby A_LIST_DESCRIPTOR.\n\n      IM_FIND_OWNER ID=IM,DESCTKN=A_LIST_DESCRIPTOR\n\n_*IM_FIND_PRIOR - Find the Prior Item in a Structure*_\n\nThe IM_FIND_PRIOR macro is used to locate the prior item in a structure.\nThis functions is supported for Linked Lists. The item found will become\ncurrent of Item Manager, current of descriptor and current of item type.\n\nIM_FIND_PRIOR ID=/id_name/ \u00dd,SPEPA=/im_epa/\u00a8 \u00dd,SPTOKEN=/im_token/\u00a8\n   ,DESCTKN=/desctkn/\n  \u00dd,ITEMTKN=/itemtkn/\u00a8\n  \u00dd,ACTUALSZ=/actualsz/\u00a8\n  \u00dd,HEADTKN=/headtkn/\u00a8\n  \u00dd,CURTKN=/curtkn/\u00a8\nCALLX /im_epa/,(/im_token/,&IM_FIND_PRIOR,/desctkn/,/actualsz/,/itemtkn/,\n      /curtkn/,/headtkn/)\n\n\n\n*Parameter *\n\n\n\nDescription\n\ndesctkn\n\n\n\nspecifies the label of a fullword that contains the token of descriptor\nthat describes the structure in which the item should be found.\n\nactualsz\n\n\n\nspecifies the label of a fullword into which will be placed the actual\nsize of the item found.\n\nitemtkn\n\n\n\nspecifies the label of a fullword into which will be placed the token of\nthe item located.\n\ncurtkn\n\n\n\nspecifies the label of a fullword that contains the token of the current\nitem in the list. If this parameter is not specified, the item that is\ncurrent of descriptor will be used. If this parameter has a value of\nzero, the last item in the list will be found.\n\nheadtkn\n\n\n\nspecifies the label of a fullword that contains the token of the head\nitem for the list. This parameter only applies to lists that do not\ncontain heads in the descriptor. If this parameter is not specified, the\nitem that is current of item type of the HEADTYPE associated with the\ndescriptor will be used.\n\n\n      Example\n\nThis instruction will find the prior item in the linked list described\nby A_LIST_DESCRIPTOR.\n\n      IM_FIND_PRIOR ID=IM,DESCTKN=A_LIST_DESCRIPTOR\n\n_*IM_GET - Get an Item *_\n\nThe IM_GET macro is used to obtain the item that is current of Item\nManager. Currency is not changed.\n\nIM_GET ID=/id_name/ \u00dd,SPEPA=/im_epa/\u00a8 \u00dd,SPTOKEN=/im_token/\u00a8\n   ,ITEM={/item/ | (/item/,/item_length/)}\n  \u00dd,ITEMTKN=/itemtkn/\u00a8\n  \u00dd,ACTUALSZ=/actualsz/\u00a8\nCALLX /im_epa/,(/im_token/,&IM_GET,/item_length/,/item/,/actualsz/,/itemtkn/)\n\n\n\n*Parameter *\n\n\n\nDescription\n\nitem\n\n\n\nspecifies the label of the storage into which a copy of the item will be\nplaced.\n\nitem_length\n\n\n\nspecifies the label of a signed binary integer indicating the length of\nthe storage area specified by the /name/parameter. In the macro form, if\nitem_length is not specified, an =A(L'item) will be used to determine\nthe length of the storage. This storage can be larger than the actual\nitem, but must be large enough to hold the complete item.\n\nactualsz\n\n\n\nspecifies the label of a fullword into which will be placed the actual\nsize of the item found.\n\nitemtkn\n\n\n\nspecifies the label of a fullword into which will be placed the token of\nthe item located.\n\n\n      Example\n\nThis instruction will get the item that is current of Item Manager.\n\n      IM_GET ID=IM,ITEM=ITEM_WORK_AREA\n\n_*IM_GET_DANGEROUS_ADDRESSES - Get Dangerous Addresses *_\n\nThe IM_GET_DANGEROUS_ADDRESSES macro is used to get the address of the\ntoken-to-virtual-address conversion routine. This allows direct access\nto Item Manager Managed Storage. Direct access to Item Manager Managed\nStorage should be avoided, but can be accomplished through this routine\nif there are overriding reasons. This is the function that will be used\nto externalize any other internal Item Manager functions, as needed.\n\nIM_GET_DANGEROUS_ADDRESSES ID=/id_name/ \u00dd,SPEPA=/im_epa/\u00a8 \u00dd,SPTOKEN=/im_token/\u00a8\n  \u00dd,TKNCNVT=/tkncnvt/\u00a8\nCALLX /im_epa/,(/im_token/,&IM_GET_DANGEROUS_ADDRESSES,/tkncnvt/)\n\n\n\n*Parameter *\n\n\n\nDescription\n\ntkncnvt\n\n\n\nspecifies the label of a fullword into which will be place the address\nof the token convertion routine. If the macro form is used and this\nparameter is not specified, the value of the TKNCNVT keyword on the\ncorresponding IM_ID macro is used.\n\n\n\n      Example\n\nThis instruction will place the address of the conversion routine in\nCONVERT_ADDRESS\n\n      IM_GET_DANGEROUS_ADDRESSES ID=IM,TKNCNVT=CONVERT_ADDRESS\n\n_*IM_INITIALIZE - Initialize Item Manager Managed Storage *_\n\nThe IM_INITIALIZE macro is used to initialize Item Manager Managed\nStorage. If the Item Manager is not started with a DIV service process\nspecified or if this is the first use of a DIV data set, this function\nmust be called. IM_START return an return code of\n&IM_ITEM_STORAGE_NOT_INITIALIZED, if Item Manager Managed Storage needs\nto be initialized.\n\nSpecifying good values for the parameters of this function is the major\nway that you can tune the Item Manager.\n\nIM_INITIALIZE ID=/id_name/ \u00dd,SPEPA=/im_epa/\u00a8 \u00dd,SPTOKEN=/im_token/\u00a8\n  \u00dd,ITDSTG=/itdstg/\u00a8\n  \u00dd,UAINCR=/uaincr/\u00a8\n  \u00dd,SYSINCR=/sysincr/\u00a8\n  \u00dd,DFLTINCR=/dfltincr/\u00a8\nCALLX /im_epa/,\n  (/im_token/,&IM_INITIALIZE,/itdstg/,/uaincr/,/sysincr/,/dfltincr/)\n\n\n\n*Parameter *\n\n\n\nDescription\n\nitdstg\n\n\n\nspecifies the label of a fullword that contains the amount of Item\nManager Managed Storage that should be reserved for item type\ndescriptors. The maximum and the default is 64K.\n\nuaincr\n\n\n\nspecifies the label of a fullword that contains the amount of main\nmemory that will be obtained, each time that Item Manager Managed\nStorage needs to expand. This number should be large enough so that few\nincrements will be needed for a session of the Item Manager. The default\nincrement is 64K.\n\nsysincr\n\n\n\nspecifies the label of a fullword that contains the amount of Item\nManager Managed Storage that will be obtained, each time that the system\nItem Manager Managed Storage needs to expand. System Item Manager\nManaged Storage is used to hold structure descriptors and other system\nitems. The default increment is 4K.\n\ndfltincr\n\n\n\nspecifies the label of a fullword that contains the amount of Item\nManager Managed Storage that will be obtained each time that the default\nuser Item Manager Managed Storage needs to expand. Default user Item\nManager Managed Storage is used for user items that do not specify\nanother group. The default increment is 64K.\n\n\n      Example\n\nThis instruction will place the address of the conversion routine in\nCONVERT_ADDRESS\n\n      IM_GET_DANGEROUS_ADDRESSES ID=IM,TKNCNVT=CONVERT_ADDRESS\n\n_*IM_MODIFY - Modify an Item in Item Manager Managed Storage*_\n\nThe IM_MODIFY macro is used to modify an item in Item Manager Managed\nStorage. The length, number of links and offset of links of an item, can\nnot be modified with the IM_MODIFY function.\n\nIM_MODIFY ID=/id_name/ \u00dd,SPEPA=/im_epa/\u00a8 \u00dd,SPTOKEN=/im_token/\u00a8\n   ,ITEM=/item/\n  \u00dd,OPTIONS=(\u00ddUPDATE_LINKS\u00a8)\u00a8\n  \u00dd,ITEMTKN=/itemtkn/\u00a8\nCALLX /im_epa/,(/im_token/,&IM_MODIFY,/item/,/optstr/,/itemtkn/)\n\n\n\n*Parameter *\n\n\n\nDescription\n\nitem\n\n\n\nspecifies the label of the storage into which a copy of the item will be\nplaced.\n\nUPDATE_LINKS\n\n\n\nthis options indicates that the links will be updated. If this options\nis not specified, the link fields of the item being updated are not\nreplaced.\n\noptstr\n\n\n\nspecifies the label of a byte that contains the options. All bits except\nbit 1 are reserved. Bit one corresponds to the UPDATE_LINKS option.\n\nitemtkn\n\n\n\nspecifies the label of a fullword that contains the token of the item to\nmodify. If this parameter is not specified, the item that is current of\nItem Manager is modified.\n\n\n      Example\n\nThis instruction will modify the item that is current of Item Manager.\n\n      IM_MODIFY ID=IM,ITEM=ITEM_WORK_STORAGE\n\n_*IM_OBTAIN - Obtain An Item By Its Token *_\n\nThe IM_OBTAIN macro is used to obtain an item by its item token The item\nfound will become current of Item Manager and current of item type.\n\nIM_OBTAIN ID=/id_name/ \u00dd,SPEPA=/im_epa/\u00a8 \u00dd,SPTOKEN=/im_token/\u00a8\n   ,ITEM={/item/ | (/item/,/item_length/)}\n  \u00dd,ITEMTKN=/itemtkn/\u00a8\n  \u00dd,ACTUALSZ=/actualsz/\u00a8\nCALLX /im_epa/,(/im_token/,&IM_OBTAIN,/itemtkn/,/item_length/,/item/,/actualsz/)\n\n\n\n*Parameter *\n\n\n\nDescription\n\nitemtkn\n\n\n\nspecifies the label of a fullword that contains the token of the item to\nbe obtained.\n\nitem\n\n\n\nspecifies the label of the storage into which a copy of the item will be\nplaced.\n\nitem_length\n\n\n\nspecifies the label of a signed binary integer indicating the length of\nthe storage area specified by the /name/parameter. In the macro form, if\nitem_length is not specified, an =A(L'item) will be used to determine\nthe length of the storage. This storage can be larger than the actual\nitem, but must be large enough to hold the complete item.\n\nactualsz\n\n\n\nspecifies the label of a fullword into which will be place the actual\nsize of the item found.\n\n\n      Example\n\nThis instruction will obtain the item whose token is in the fullword at\nlabel ITEM_TOKEN.\n\n      IM_OBTAIN ID=IM,ITEMTKN=ITEM_TOKEN\n\n_*IM_OBTAIN_BY_KEY - Obtain An Item By Key*_\n\nThe IM_OBTAIN_BY_KEY macro is used to obtain an item by its key. The\nitem found will become current of Item Manager and current of item type.\n\nIM_OBTAIN_BY_KEY ID=/id_name/ \u00dd,SPEPA=/im_epa/\u00a8 \u00dd,SPTOKEN=/im_token/\u00a8\n   ,DESCTKN=/desctkn/\n   ,KEY=/key/ | (/key/,/key_length/)\n   ,ITEM={/item/ | (/item/,/item_length/)}\n  \u00dd,ITEMTKN=/itemtkn/\u00a8\n  \u00dd,ACTUALSZ=/actualsz/\u00a8\nCALLX /im_epa/,(/im_token/,&IM_OBTAIN_BY_KEY,/desctkn/,/key_length/,/key/,\n      /item_length/,/item/,/actualsz/,/itemtkn/)\n\n\n\n*Parameter *\n\n\n\nDescription\n\ndesctkn\n\n\n\nspecifies the label of a fullword that contains the token of descriptor\nthat describes the structure in which the item should be found.\n\nkey_length\n\n\n\nspecifies a fullword that contains the length of the key. Trailing\nblanks are ignored in the compare, so the key can still match a item in\nItem Manager Managed Storage even if the key length of that item is not\nthe same as the key length specified.\n\nkey\n\n\n\nspecifies the label of a field that contains the key of the item to obtain.\n\nitem\n\n\n\nspecifies the label of the storage into which a copy of the item will be\nplaced.\n\nitem_length\n\n\n\nspecifies the label of a signed binary integer indicating the length of\nthe storage area specified by the /name/parameter. In the macro form, if\nitem_length is not specified, an =A(L'item) will be used to determine\nthe length of the storage. This storage can be larger than the actual\nitem, but must be large enough to hold the complete item.\n\nactualsz\n\n\n\nspecifies the label of a fullword into which will be placed the actual\nsize of the item found.\n\nitemtkn\n\n\n\nspecifies the label of a fullword into which will be placed the token of\nthe item obtained.\n\n\n      Example\n\nThis instruction will obtain the item in the linked list described by\nA_LIST_DESCRIPTOR that has a key of \"XYZZY\".\n\n      IM_OBTAIN_BY_KEY ID=IM,DESCTKN=A_LIST_DESCRIPTOR,KEY=\"XYZZY\"\n\n_*IM_OBTAIN_CURRENT_OF_DESCRIPTOR - Obtain the Item That is Current of\nDescriptor*_\n\nThe IM_OBTAIN_CURRENT_OF_DESCRIPTOR macro is used to obtain an item that\nis current of a given descriptor. The item found will become current of\nItem Manager and current of item type.\n\nIM_OBTAIN_CURRENT_OF_DESCRIPTOR ID=/id_name/\n  \u00dd,SPEPA=/im_epa/\u00a8 \u00dd,SPTOKEN=/im_token/\u00a8\n   ,DESCTKN=/desctkn/\n   ,ITEM={/item/ | (/item/,/item_length/)}\n  \u00dd,ITEMTKN=/itemtkn/\u00a8\n  \u00dd,ACTUALSZ=/actualsz/\u00a8\nCALLX /im_epa/,(/im_token/,&IM_OBTAIN_CURRENT_OF_DESCRIPTOR,/desctkn/,\n      /item_length/,/item/,/actualsz/,/itemtkn/)\n\n\n\n*Parameter *\n\n\n\nDescription\n\ndesctkn\n\n\n\nspecifies the label of a fullword that contains the token of descriptor\nthat describes the structure in which the item should be found.\n\nitem\n\n\n\nspecifies the label of the storage into which a copy of the item will be\nplaced.\n\nitem_length\n\n\n\nspecifies the label of a signed binary integer indicating the length of\nthe storage area specified by the /name/parameter. In the macro form, if\nitem_length is not specified, an =A(L'item) will be used to determine\nthe length of the storage. This storage can be larger than the actual\nitem, but must be large enough to hold the complete item.\n\nactualsz\n\n\n\nspecifies the label of a fullword into which will be placed the actual\nsize of the item found.\n\nitemtkn\n\n\n\nspecifies the label of a fullword into which will be placed the token of\nthe item obtained.\n\n\n      Example\n\nThis instruction will obtain the item that is current of descriptor for\nthe structure described by A_LIST_DESCRIPTOR.\n\n      IM_OBTAIN_CURRENT_OF_DESCRIPTOR ID=IM,DESCTKN=A_LIST_DESCRIPTOR\n\n_*IM_OBTAIN_CURRENT_OF_ITEM_TYPE - Obtain the Item That is Current of\nItem Type *_\n\nThe IM_OBTAIN_CURRENT_OF_ITEM_TYPE macro is used to obtain an item that\nis current of a given item type. The item found will become current of\nItem Manager and remain current of item type.\n\nIM_OBTAIN_CURRENT_OF_ITEM_TYPE ID=/id_name/\n  \u00dd,SPEPA=/im_epa/\u00a8 \u00dd,SPTOKEN=/im_token/\u00a8\n   ,ITEMTYPE=/itemtype/\n   ,ITEM={/item/ | (/item/,/item_length/)}\n  \u00dd,ITEMTKN=/itemtkn/\u00a8\n  \u00dd,ACTUALSZ=/actualsz/\u00a8\nCALLX /im_epa/,(/im_token/,&IM_OBTAIN_ITEM_TYPE,/itemtype/,\n      /item_length/,/item/,/actualsz/,/itemtkn/)\n\n\n\n*Parameter *\n\n\n\nDescription\n\nitemtype\n\n\n\nspecifies the label of a halfword that contains the token of item type\ndescriptor for the item that should be found.\n\nitem\n\n\n\nspecifies the label of the storage into which a copy of the item will be\nplaced.\n\nitem_length\n\n\n\nspecifies the label of a signed binary integer indicating the length of\nthe storage area specified by the /name/parameter. In the macro form, if\nitem_length is not specified, an =A(L'item) will be used to determine\nthe length of the storage. This storage can be larger than the actual\nitem, but must be large enough to hold the complete item.\n\nactualsz\n\n\n\nspecifies the label of a fullword into which will be placed the actual\nsize of the item found.\n\nitemtkn\n\n\n\nspecifies the label of a fullword into which will be placed the token of\nthe item obtained.\n\n\n      Example\n\nThis instruction will obtain the item that is current of item type for\nthe structure described by A_LIST_DESCRIPTOR.\n\n      IM_OBTAIN_CURRENT_OF_ITEM_TYPE ID=IM,DESCTKN=A_LIST_DESCRIPTOR\n\n_*IM_OBTAIN_FINAL - Obtain the Final Item in a Structure *_\n\nThe IM_OBTAIN_FINAL macro is used to obtain the final item in a\nstructure. This functions is supported for Linked Lists. The item found\nwill become current of Item Manager, current of descriptor and current\nof item type.\n\nIM_OBTAIN_FINAL ID=/id_name/ \u00dd,SPEPA=/im_epa/\u00a8 \u00dd,SPTOKEN=/im_token/\u00a8\n   ,DESCTKN=/desctkn/\n   ,ITEM={/item/ | (/item/,/item_length/)}\n  \u00dd,ITEMTKN=/itemtkn/\u00a8\n  \u00dd,ACTUALSZ=/actualsz/\u00a8\n  \u00dd,HEADTKN=/headtkn/\u00a8\nCALLX /im_epa/,(/im_token/,&IM_OBTAIN_FINAL,/desctkn/,\n      /item_length/,/item/,/actualsz/,/itemtkn/,/headtkn/)\n\n\n\n*Parameter *\n\n\n\nDescription\n\ndesctkn\n\n\n\nspecifies the label of a fullword that contains the token of descriptor\nthat describes the structure in which the item should be found.\n\nitem\n\n\n\nspecifies the label of the storage into which a copy of the item will be\nplaced.\n\nitem_length\n\n\n\nspecifies the label of a signed binary integer indicating the length of\nthe storage area specified by the /name/parameter. In the macro form, if\nitem_length is not specified, an =A(L'item) will be used to determine\nthe length of the storage. This storage can be larger than the actual\nitem, but must be large enough to hold the complete item.\n\nactualsz\n\n\n\nspecifies the label of a fullword into which will be placed the actual\nsize of the item found.\n\nitemtkn\n\n\n\nspecifies the label of a fullword into which will be placed the token of\nthe item obtained.\n\nheadtkn\n\n\n\nspecifies the label of a fullword that contains the token of the head\nitem for the list. This parameter only applies to lists that do not\ncontain heads in the descriptor. If this parameter is not specified, the\nitem that is current of item type of the HEADTYPE associated with the\ndescriptor will be used.\n\n\n      Example\n\nThis instruction will obtain the final item in the linked list described\nby A_LIST_DESCRIPTOR.\n\n      IM_OBTAIN_FINAL ID=IM,DESCTKN=A_LIST_DESCRIPTOR\n\n_*IM_OBTAIN_FIRST - Obtain the First Item in a Structure *_\n\nThe IM_OBTAIN_FIRST macro is used to obtain the first item in a\nstructure. This functions is supported for Linked Lists. The item found\nwill become current of Item Manager, current of descriptor and current\nof item type.\n\nIM_OBTAIN_FIRST ID=/id_name/ \u00dd,SPEPA=/im_epa/\u00a8 \u00dd,SPTOKEN=/im_token/\u00a8\n   ,DESCTKN=/desctkn/\n   ,ITEM={/item/ | (/item/,/item_length/)}\n  \u00dd,ITEMTKN=/itemtkn/\u00a8\n  \u00dd,ACTUALSZ=/actualsz/\u00a8\n  \u00dd,HEADTKN=/headtkn/\u00a8\nCALLX /im_epa/,(/im_token/,&IM_OBTAIN_FIRST,/desctkn/,\n      /item_length/,/item/,/actualsz/,/itemtkn/,/headtkn/)\n\n\n\n*Parameter *\n\n\n\nDescription\n\ndesctkn\n\n\n\nspecifies the label of a fullword that contains the token of descriptor\nthat describes the structure in which the item should be found.\n\nitem\n\n\n\nspecifies the label of the storage into which a copy of the item will be\nplaced.\n\nitem_length\n\n\n\nspecifies the label of a signed binary integer indicating the length of\nthe storage area specified by the /name/parameter. In the macro form, if\nitem_length is not specified, an =A(L'item) will be used to determine\nthe length of the storage. This storage can be larger than the actual\nitem, but must be large enough to hold the complete item.\n\nactualsz\n\n\n\nspecifies the label of a fullword into which will be placed the actual\nsize of the item found.\n\nitemtkn\n\n\n\nspecifies the label of a fullword into which will be placed the token of\nthe item obtained.\n\nheadtkn\n\n\n\nspecifies the label of a fullword that contains the token of the head\nitem for the list. This parameter only applies to lists that do not\ncontain heads in the descriptor. If this parameter is not specified, the\nitem that is current of item type of the HEADTYPE associated with the\ndescriptor will be used.\n\n\n\n      Example\n\nThis instruction will obtain the first item in the linked list described\nby A_LIST_DESCRIPTOR.\n\n      IM_OBTAIN_FIRST ID=IM,DESCTKN=A_LIST_DESCRIPTOR\n\n_*IM_OBTAIN_NEXT - Obtain the Next Item in a Structure *_\n\nThe IM_OBTAIN_NEXT macro is used to obtain the next item in a structure.\nThis functions is supported for Linked Lists. The item found will become\ncurrent of Item Manager, current of descriptor and current of item type.\n\nIM_OBTAIN_NEXT ID=/id_name/ \u00dd,SPEPA=/im_epa/\u00a8 \u00dd,SPTOKEN=/im_token/\u00a8\n   ,DESCTKN=/desctkn/\n   ,ITEM={/item/ | (/item/,/item_length/)}\n  \u00dd,ITEMTKN=/itemtkn/\u00a8\n  \u00dd,ACTUALSZ=/actualsz/\u00a8\n  \u00dd,CURTKN=/curtkn/\u00a8\n  \u00dd,HEADTKN=/headtkn/\u00a8\nCALLX /im_epa/,(/im_token/,&IM_OBTAIN_NEXT,/desctkn/,\n      /item_length/,/item/,/actualsz/,/itemtkn/,/curtkn/,/headtkn/)\n\n\n\n*Parameter *\n\n\n\nDescription\n\ndesctkn\n\n\n\nspecifies the label of a fullword that contains the token of descriptor\nthat describes the structure in which the item should be found.\n\nitem\n\n\n\nspecifies the label of the storage into which a copy of the item will be\nplaced.\n\nitem_length\n\n\n\nspecifies the label of a signed binary integer indicating the length of\nthe storage area specified by the /name/parameter. In the macro form, if\nitem_length is not specified, an =A(L'item) will be used to determine\nthe length of the storage. This storage can be larger than the actual\nitem, but must be large enough to hold the complete item.\n\nactualsz\n\n\n\nspecifies the label of a fullword into which will be placed the actual\nsize of the item found.\n\nitemtkn\n\n\n\nspecifies the label of a fullword into which will be placed the token of\nthe item obtained.\n\ncurtkn\n\n\n\nspecifies the label of a fullword that contains the token of the current\nitem in the list. If this parameter is not specified, the item that is\ncurrent of descriptor will be used. If this parameter has a value of\nzero, the first item in the list will be obtained.\n\nheadtkn\n\n\n\nspecifies the label of a fullword that contains the token of the head\nitem for the list. This parameter only applies to lists that do not\ncontain heads in the descriptor. If this parameter is not specified, the\nitem that is current of item type of the HEADTYPE associated with the\ndescriptor will be used.\n\n\n      Example\n\nThis instruction will obtain the next item in the linked list described\nby A_LIST_DESCRIPTOR.\n\n      IM_OBTAIN_NEXT ID=IM,DESCTKN=A_LIST_DESCRIPTOR\n\n_*IM_OBTAIN_OWNER - Obtain the Owner Item of a Structure *_\n\nThe IM_OBTAIN_OWNER macro is used to obtain the owner item of a\nstructure. This functions is supported for Linked Lists. The item found\nwill become current of Item Manager, current of descriptor and current\nof item type.\n\nIM_OBTAIN_OWNER ID=/id_name/ \u00dd,SPEPA=/im_epa/\u00a8 \u00dd,SPTOKEN=/im_token/\u00a8\n   ,DESCTKN=/desctkn/\n   ,ITEM={/item/ | (/item/,/item_length/)}\n  \u00dd,ITEMTKN=/itemtkn/\u00a8\n  \u00dd,ACTUALSZ=/actualsz/\u00a8\n  \u00dd,CURTKN=/curtkn/\u00a8\nCALLX /im_epa/,(/im_token/,&IM_OBTAIN_OWNER,/desctkn/,\n      /item_length/,/item/,/actualsz/,/itemtkn/,/curtkn/)\n\n\n\n*Parameter *\n\n\n\nDescription\n\ndesctkn\n\n\n\nspecifies the label of a fullword that contains the token of descriptor\nthat describes the structure in which the item should be found.\n\nitem\n\n\n\nspecifies the label of the storage into which a copy of the item will be\nplaced.\n\nitem_length\n\n\n\nspecifies the label of a signed binary integer indicating the length of\nthe storage area specified by the /name/parameter. In the macro form, if\nitem_length is not specified, an =A(L'item) will be used to determine\nthe length of the storage. This storage can be larger than the actual\nitem, but must be large enough to hold the complete item.\n\nactualsz\n\n\n\nspecifies the label of a fullword into which will be placed the actual\nsize of the item found.\n\nitemtkn\n\n\n\nspecifies the label of a fullword into which will be placed the token of\nthe item obtained.\n\ncurtkn\n\n\n\nspecifies the label of a fullword that contains the token of the current\nitem in the list. If this parameter is not specified, the item that is\ncurrent of Item Manager will be used.\n\n\n      Example\n\nThis instruction will obtain the owner item in the linked list described\nby A_LIST_DESCRIPTOR.\n\n      IM_OBTAIN_OWNER ID=IM,DESCTKN=A_LIST_DESCRIPTOR\n\n_*IM_OBTAIN_PRIOR - Obtain the Prior Item in a Structure*_\n\nThe IM_OBTAIN_PRIOR macro is used to obtain the prior item in a\nstructure. This functions is supported for Linked Lists. The item found\nwill become current of Item Manager, current of descriptor and current\nof item type.\n\nIM_OBTAIN_PRIOR ID=/id_name/ \u00dd,SPEPA=/im_epa/\u00a8 \u00dd,SPTOKEN=/im_token/\u00a8\n   ,DESCTKN=/desctkn/\n   ,ITEM={/item/ | (/item/,/item_length/)}\n  \u00dd,ITEMTKN=/itemtkn/\u00a8\n  \u00dd,ACTUALSZ=/actualsz/\u00a8\n  \u00dd,CURTKN=/curtkn/\u00a8\n  \u00dd,HEADTKN=/headtkn/\u00a8\nCALLX /im_epa/,(/im_token/,&IM_OBTAIN_PRIOR,/desctkn/,\n      /item_length/,/item/,/actualsz/,/itemtkn/,/curtkn/,/headtkn/)\n\n\n\n*Parameter *\n\n\n\nDescription\n\ndesctkn\n\n\n\nspecifies the label of a fullword that contains the token of descriptor\nthat describes the structure in which the item should be found.\n\nitem\n\n\n\nspecifies the label of the storage into which a copy of the item will be\nplaced.\n\nitem_length\n\n\n\nspecifies the label of a signed binary integer indicating the length of\nthe storage area specified by the /name/parameter. In the macro form, if\nitem_length is not specified, an =A(L'item) will be used to determine\nthe length of the storage. This storage can be larger than the actual\nitem, but must be large enough to hold the complete item.\n\nactualsz\n\n\n\nspecifies the label of a fullword into which will be placed the actual\nsize of the item found.\n\nitemtkn\n\n\n\nspecifies the label of a fullword into which will be placed the token of\nthe item obtained.\n\ncurtkn\n\n\n\nspecifies the label of a fullword that contains the token of the current\nitem in the list. If this parameter is not specified, the item that is\ncurrent of descriptor will be used. If this parameter has a value of\nzero, the last item in the list will be obtained.\n\nheadtkn\n\n\n\nspecifies the label of a fullword that contains the token of the head\nitem for the list. This parameter only applies to lists that do not\ncontain heads in the descriptor. If this parameter is not specified, the\nitem that is current of item type of the HEADTYPE associated with the\ndescriptor will be used.\n\n\n      Example\n\nThis instruction will obtain the prior item in the linked list described\nby A_LIST_DESCRIPTOR.\n\n      IM_OBTAIN_PRIOR ID=IM,DESCTKN=A_LIST_DESCRIPTOR\n\n_*IM_REMOVE_FROM_DIRECTORY - Remove An Item Token from The Token\nDirectory *_\n\nThe IM_REMOVE_FROM_DIRECTORY macro is used to unassociate a name with an\nitem token in the token directory. Currency is not changed.\n\nThis function is not yet implemented.\n\nIM_REMOVE_FROM_DIRECTORY ID=/id_name/ \u00dd,SPEPA=/im_epa/\u00a8 \u00dd,SPTOKEN=/im_token/\u00a8\n   ,NAME={/name/ | (/name/,/name_length/)}\nCALLX /im_epa/,(/im_token/,&IM_REMOVE_FROM_DIRECTORY,/name_length/,/name/)\n\n\n\n*Parameter *\n\n\n\nDescription\n\nname\n\n\n\nspecifies the label of a string that contains the name that is\nassociated with the token specified with the /token/parameter.\n\nname_length\n\n\n\nspecifies the label of a signed binary integer indicating the length of\nthe string identified by the /name/parameter.\n\n\n      Example\n\nThis instruction will remove the name \"MY_TOKEN\" from the token directory.\n\n      IM_REMOVE_FROM_DIRECTORY ID=IM,NAME=\"MY_TOKEN\"\n\n_*IM_RESET - Reset Item Manager Managed Storage to Its Initial Contents *_\n\nThe IM_RESET macro is used to reset Item Manager Managed Storage to its\ncontents at the time of the last IM_SAVE function. This function is only\nvalid if a DIV service process was specified on the IM_START call. This\nfunction will invoke the DV_RESET function of the associated DIV service\nprocessor.\n\nIM_RESET ID=/id_name/ \u00dd,SPEPA=/im_epa/\u00a8 \u00dd,SPTOKEN=/im_token/\u00a8\nCALLX /im_epa/,(/im_token/,&IM_RESET)\n\n\n      Example\n\nThis instruction will reset Item Manager Managed Storage to its value\nsince the last save.\n\n      IM_RESET ID=IM\n\n_*IM_SAVE - Save Item Manager Managed Storage *_\n\nThe IM_SAVE function is used to save Item Manager Managed Storage. This\nfunction is only valid if a DIV service process was specified on the\nIM_START call. This function will invoke the DV_SAVE function of the\nassociated DIV service processor.\n\nIM_SAVE ID=/id_name/ \u00dd,SPEPA=/im_epa/\u00a8 \u00dd,SPTOKEN=/im_token/\u00a8\nCALLX /im_epa/,(/im_token/,&IM_SAVE)\n\n\n      Example\n\nThis instruction will save Item Manager Managed Storage.\n\n      IM_SAVE ID=IM\n\n_*IM_SFD - SFD Mapping Macro *_\n\nThe IM_SFD macro is used to map a Sort Fields Descriptions (SFD) entry.\n\nIM_SFD \u00ddID=cbid\u00a8\n  \u00dd,DSECT=/dsectopt/\u00a8\n\n\n\n*Parameter *\n\n\n\nDescription\n\ncbid\n\n\n\nspecifies the id to be place as a prefix to each generated tag.\n\ndsectopt\n\n\n\neither YES or NO to indicate whether a DSECT should be generated.\n\n\n      Example\n\nThis instruction will generate a mapping dsect for the SFD.\n\n      IM_SFD\n\n_*IM_SORT - Sort a List *_\n\nThe IM_SORT function is used to sort a list.\n\nIM_SORT ID=/id_name/ \u00dd,SPEPA=/im_epa/\u00a8 \u00dd,SPTOKEN=/im_token/\u00a8\n   ,DESCTKN=/desctkn/\n   ,FIELDS={/fields/ | ,FIELDSLIST=/fieldslist/\n  \u00dd,TECHNIQUE=(\u00ddQUICK_SORT\u00a8 | \u00ddBUBBLE_SORT\u00a8)\u00a8\n  \u00dd,HEADTKN=/itemtkn/\u00a8\nCALLX /im_epa/,(/im_token/,&IM_SORT,/desctkn/,/fieldslist/,\n      /headtkn/,/technique/)\n\n\n\n*Parameter *\n\n\n\nDescription\n\ndesctkn\n\n\n\nspecifies the label of a fullword that contains the token of descriptor\nthat describes the list of items to be sorted.\n\nfields\n\n\n\nspecifies the sort fields. See for the syntax of this parameter.\n\nfieldslist\n\n\n\nspecifies a location that contains the Sort Fields Definitions (SFD).\nRefer to or for information needed to build the SFD.\n\nQUICK_SORT\n\n\n\nspecifies that quick sort should be used to sort the list. This is the\ndefault sort techinque. It is very fast for all but very small lists,\nwhich are slowed by the setup required. It should always be used except\nwhen very small lists are sorted many times. It uses a partiton exchange\nsort algorithm with improvements by Richard C. Singleton. See ACM\nAlgorithm 347 \"An Efficient Algorithm For Sorting With Minimal Storage\n{M1}\" for more information.\n\nBUBBLE_SORT\n\n\n\nspecifies that bubble sort should be used to sort the list. This is a\nvery slow sort techinque except for very short list (10 or less items).\n\ntechnique\n\n\n\nspecifies a fullword that contains the sort technique to be used.\nSymbols IM_SORT_TECHNIQUE_QUICK_SORT and IM_SORT_TECHNIQUE_BUBBLE_SORT\ncan be used to specify this technique. The default is quick sort.\n\nheadtkn\n\n\n\nspecifies the label of a fullword that contains the token of the item\nthat contains the heads when a structure can have multiple occurances.\nIf this parameter is not specified, the item that is current of item\ntype of the item type specified with the /headtype/parameter on the\nassociated descriptor create function is used.\n\n\n      Example\n\nThis instruction will sort the list described by A_LIST_DESCRIPTOR in\nascending order by field CBFIELD, where CBSTART is the tag of the start\nof the item.\n\n      IM_SORT ID=IM,DESCTKN=A_LIST_DESCRIPTOR,                      +\n                FIELDS=((CBFIELD-CBSTART,L'CBFIELD))\n\n_*IM_SORT_FIELDLIST - Define Sort Fields *_\n\nThe IM_SORT_FIELDLIST macro is used to define static sort fields\ndefinitions.\n\nIM_SORT_FIELDLIST NAME=/name/\n   ,FIELDS=/fieldlist/\n\n\n\n*Parameter *\n\n\n\nDescription\n\nname\n\n\n\nthe name to be associate with the sort fields.\n\nfieldlist\n\n\n\na list of fields. The /fieldslist/is of the form:\n((/offset/,/length/| /mask/, \u00dd/type/\u00a8,\u00ddASCENDING|DESCENDING\u00a8), ... as\nmany sort field as needed)\n\nParameter /offset/is the offset of the sort field in an item and\nparameter /length/is the size of the sort field.\n\nThe valid values for /type/are: CHAR, PACKED, ZONED, FIXED, and BIT.\n\nIf BIT is specified, /mask/is required and is a one-byte value with bits\nturned on in the positions that should be checked for sorting.\n\nFor all other types, /length/is used instead. It indicates the number of\nbytes to compare for the field.\n\nThe default is CHAR.\n\nASCENDING is the default if neither ASCENDING or DESCENDING is specified.\n\n\n      Example\n\nThis instruction will generate sort fields definitions that can be used\nwith the IM_SORT function to sort a list in ascending order by field\nCBFIELD, where CBSTART is the tag of the start of the item.\n\n      IM_SORT_FIELDSLIST NAME=PSD_FIELDSLIST,                       +\n                FIELDS=((CBFIELD-CBSTART,L'CBFIELD))\n\n_*IM_START - Start a Item Manager Session *_\n\nThe IM_START function is used to start the Item Manager.\n\nIM_START ID=/id_name/ \u00dd,SPEPA=/im_epa/\u00a8 \u00dd,SPTOKEN=/im_token/\u00a8\n  \u00dd,ESVA=/esva/\u00a8\n  \u00dd,OPTIONS=(\u00ddREAD_ONLY\u00a8\n              \u00dd,ACTUAL_ADDRESS\u00a8)\n  \u00dd,DIVEPA=/divepa/\u00a8\n  \u00dd,DIVDDN=/divddn/\u00a8\nCALLX /im_epa/,(/im_token/,&IM_START,/esva/,/optbyte/,\n      /divepa/,/divddn/)\n\n\n\n*Parameter *\n\n\n\nDescription\n\nesva\n\n\n\nSpecifies the label of a fullword in storage that contains the address\nof the Environment Support Vector (ESV) created by the ES_START function.\n\nREAD_ONLY\n\n\n\noption to indicate that the DIV data set will not be updated. If this\noptions is specified, the IM_SAVE can not be used.\n\nACTUAL_ADDRESS\n\n\n\noption to indicate that actual virtual storage address should be used as\ntokens for all but item type descriptors. If this is not specified,\ntokens will be the relative byte within Item Manager Managed Storage. Do\nnot use this option if a DIV service processor is being used.\n\noptbyte\n\n\n\nspecifies a byte of storage that contains the options. Bit 0 corresponds\nto the READ_ONLY option and bit 1 corresponds to the ACTUAL_ADDRESS option.\n\ndivepa\n\n\n\nspecifies a fullword that contains the EPA of a DIV service processor.\n\ndivddn\n\n\n\nspecifies an eight byte field that contains the ddname of the file to be\nused by the DIV service processor.\n\n\n      Example\n\nThis instruction will start the Item Manager and use actual addresses as\ntoken.\n\n      IM_START ID=IM,OPTIONS=ACTUAL_ADDRESS\n\n\n\n*Return Code *\n\n\n\nSymbol\n\n\n\nDescription\n\n0\n\n\n\nIM_SUCCESS\n\n\n\nA session of the Item Manager has successfully been started.\n\n8\n\n\n\nIM_ITEM_STORAGE_NOT_INITIALIZED\n\n\n\nA session of the Item Manager has successfully been started. The\nIM_INITIALIZE needs to be called to initialize Item Manager Managed Storage.\n\n\n\n_*IM_STORE - Store an Item in Item Manager Managed Storage *_\n\nThe IM_STORE macro is used to store an item in Item Manager Managed\nStorage. The item will become current of Item Manager.\n\nIM_STORE ID=/id_name/ \u00dd,SPEPA=/im_epa/\u00a8 \u00dd,SPTOKEN=/im_token/\u00a8\n   ,ITEM={/item/ | (/item/,/item_length/)}\n  \u00dd,ITEMTKN=/itemtkn/\u00a8\nCALLX /im_epa/,(/im_token/,&IM_STORE,/item_length/,/item/,/itemtkn/)\n\n\n\n*Parameter *\n\n\n\nDescription\n\nitem\n\n\n\nspecifies the label of the storage in which the item to be placed in\nItem Manager Managed Storage resides.\n\nitem_length\n\n\n\nspecifies the label of a signed binary integer indicating the length of\nthe storage area specified by the /name/parameter. In the macro form, if\nitem_length is not specified, an =A(L'item) will be used to determine\nthe length of the storage. This storage can be larger than the actual\nitem, but must be large enough to hold the complete item.\n\nitemtkn\n\n\n\nspecifies the label of a fullword into which the token of the item will\nbe placed.\n\n\n      Example\n\nThis instruction will store the item constructed at tag ITEM_WORK_AREA\nin Item Manager Managed Storage.\n\n      IM_STORE ID=IM,ITEM=ITEM_WORK_AREA\n\n_*IM_TERMINATE - Terminate the Item Manager *_\n\nThe IM_TERMINATE function will terminate the Item Manager and release\nall associated resources. It will also terminate the associated DIV\nservice processor.\n\nIM_TERMINATE ID=/id_name/ \u00dd,SPEPA=/im_epa/\u00a8 \u00dd,SPTOKEN=/im_token/\u00a8\nCALLX /im_epa/,(/im_token/,&IM_TERMINATE)\n\n\n      Example\n\nThis instruction will terminate a session with the Item Manager.\n\n      IM_TERMINATE ID=IM\n\n_*IM_TEXT - Generating Description Text *_\n\nThe IM_TEXT macro is used to generate description text. Description text\nis used with the TEXT keyword on various Item Manager macros.\n\n/name/ IM_TEXT /string/\n\n\n\n*Parameter *\n\n\n\nDescription\n\nname\n\n\n\nspecifies the name to be associated with the text.\n\nstring\n\n\n\nspecifies a quoted string that contains the text.\n\n\n      Example\n\nSOMETEXT IM_TEXT \"This is some text.\"\n\n------------------------------------------------------------------------\n\n\n  Chapter 9. Memory Manager <#ToC_74>\n\nThe memory manager is designed to make memory allocation efficient for\napplications by reducing the number of system requests needed to obtain\nand release portions of storage. For applications that need to\nfrequently allocate small items of storage, this can drastically reduce\nsystem overhead.\n\nApplications use the memory manager to create one or more storage\n/heaps/, where each heap represents a storage space that may\nincrementally grow and shrink over time as the application program\nobtains and releases storage. The increment by which a heap grows and\nshrinks may be specified when the heap is created, as can restrictions\non its location (anywhere, or below the 16-megabyte line). All storage\nowned by a heap is automatically released when the heap is destroyed.\n\n------------------------------------------------------------------------\n\n\n    Preparing to Use the Memory Manager <#ToC_75>\n\nThe Memory Manager operates independently of its execution environment;\nall managed storage is obtained through Environment Support. Like any\nservice processor, the Memory Manager must be loaded and started before\nits functions can be used. This process is fully covered in Part 1,\n\"Service Processors User's Guide\" <#HDRPART1> and will not be repeated\nhere.\n\nThe Memory Manager's service processor identification code is *MM*so:\n\n  *\n\n    the COPY member is *SRVMMMAC*,\n\n  *\n\n    the load module, named by symbol *&MM_MEMORY_MANAGER*, is SRVMM,\n\n  *\n\n    and the names of all symbols, macros, and conditions begin with the\n    prefix *MM_*.\n\nA storage heap is identified by the /mm_token/parameter, which is\nrequired when invoking any Memory Manager function. Invoking the\nMM_START function will create a new storage heap and return its\nidentification value in /mm_token/. Using the same value for\n/mm_token/when invoking the MM_TERMINATE function will automatically\nrelease all of the heap's storage and destroy it. To allocate and\nrelease storage within a heap, use the MM_OBTAIN_STORAGE and\nMM_RELEASE_STORAGE functions, identifying the heap with /mm_token/. To\nreset all storage within a heap without giving the storage back to the\nsystem, use the MM_RESET_HEAP function.\n\n\n      Common Parameters <#ToC_76>\n\nThere are several parameters common to any Memory Manager function call.\nThese parameters are listed below:\n\n\n\n*Parameter *\n\n\n\nDescription\n\nid_name\n\n\n\nthe name of a service processor identifier created by the MM_ID macro\nwhich will be used by all other function invocation macros to\nautomatically obtain values for /mm_epa/and /mm_token/. This parameter\nis required unless both /mm_epa/and /mm_token/are specified.\n\nmm_epa\n\n\n\na fullword in storage containing the entry point address of the Memory\nManager service processor. The value specified by /mm_epa/overrides any\nvalue obtained from ID=/id_name/.\n\nmm_token\n\n\n\na fullword in storage containing the value (to be) returned by MM_START\nfor the /mm_token/parameter. The value specified by /mm_token/overrides\nany value obtained from ID=/id_name/.\n\n\n      Complete List of Memory Manager Return Codes <#ToC_77>\n\nMany return codes can be returned from each function. In the function\ndescriptions later in this chapter, the most common return codes\nreturned by the particular function are documented. The following is a\ncomplete list of Memory Manager return codes.\n\n*Return Code *\n\n\n\nSymbol\n\n\n\nDescription\n\n0\n\n\n\nMM_SUCCESS\n\n\n\nThe invoked Memory Manager function performed the requested service\nwithout encountering any problems.\n\n1\n\n\n\nMM_INVALID_FUNCTION\n\n\n\nAn invalid /FunctionCode/(the second parameter in any service processor\nfunction call) was specified.\n\n2\n\n\n\nMM_INVALID_HEAPID\n\n\n\nAn invalid value was given in /mm_token/. This parameter must contain a\nvalue previously returned by the MM_START function.\n\n3\n\n\n\nMM_INVALID_INCREMENT\n\n\n\nAn invalid value for the /increment/parameter was passed to the MM_START\nfunction of the Memory Manager.\n\n4\n\n\n\nMM_INVALID_LOCATION\n\n\n\nAn invalid value for the /location/parameter was passed to the MM_START\nfunction of the Memory Manager.\n\n5\n\n\n\nMM_INVALID_SIZE\n\n\n\nAn invalid value was provided for the /size/parameter, which must be a\npositive fullword integer value.\n\n6\n\n\n\nMM_INVALID_PARM_COUNT\n\n\n\nEither too few parameters were supplied for the function call or too\nmany were supplied. Check the parameter list to ensure that it is right\nfor the function being invoked.\n\n7\n\n\n\nMM_INVALID_ALIGNMENT\n\n\n\nThe value of /address/, a MM_RELEASE_STORAGE parameter, must be an even\nmultiple of eight (doubleword boundary).\n\n8\n\n\n\nMM_STORAGE_NOT_AVAILABLE\n\n\n\nThe system denied a request for storage.\n\n9\n\n\n\nMM_UNKNOWN_ERROR\n\n\n\nThe Memory Manager encountered an unexpected error. The application\nprogram should respond to this return code by immediately dumping the\ndebugging area with the ES_DISPLAY_DEBUG_INFO function of Environment\nSupport.\n\n*Note: *No functions other than MM_TERMINATE will be accepted by the\nMemory Manager after this error has occurred.\n\n10\n\n\n\nMM_MEMORY_NOT_IN_HEAP\n\n\n\nThe memory being released (via MM_RELEASE_STORAGE) was not allocated\nusing the supplied mm_token value.\n\n11\n\n\n\nMM_MEMORY_NOT_ALLOCATED\n\n\n\nThe memory being released (via MM_RELEASE_STORAGE) does exist in the\nheap indicated by the supplied /mm_token/value, but is not allocated and\nthus cannot be released.\n\n12\n\n\n\nMM_CORRUPT_STORAGE\n\n\n\nAn internal control block has been overwritten by invalid data. The\napplication program may have written data beyond the end of a block of\nstorage previously allocated by the MM_OBTAIN_STORAGE function, or it\nmay have continued writing to storage released via the\nMM_RELEASE_STORAGE function.\n\n*Note: *No functions other than MM_TERMINATE will be accepted by the\nMemory Manager after this error has occurred.\n\n13\n\n\n\nMM_NOT_USEABLE\n\n\n\nAll functions to the memory manager, other than MM_TERMINATE, have been\ndisabled due to a previous error. Errors that can cause the memory\nmanager to become unuseable are *MM_UNKNOWN_ERROR*and *MM_CORRUPT_STORAGE*.\n\n\n\n    Memory Manager Service Processor Functions <#ToC_78>\n\nThe remaining sections of this chapter describe all functions provided\nby the Memory Manager service processor, arranged in alphabetical order.\nEach function's description begins on a new page, and the name of the\nfunction being described appears at the top of every page.\n\n_*MM_ID - Establish Default Memory Manager Values *_\n\nThe MM_ID macro is used to establish default values for use by other\nMemory Manager macros, which may access those defaults through a unique\nidentifier, /id_name/, specified by the user. Default values can be\nestablished for the following parameters: /mm_epname/, /mm_epa/, and\n/mm_token/.\n\nIn most cases, nothing other than the entry point name needs to be\nspecified on the MM_ID macro: it will automatically define working\nstorage fields for the remaining parameters if they are not specified.\nThese values, whether generated by the macro or provided by the user,\nare accessable from all other Memory Manager macros through the\nID=/id_name/. If the application program needs to access the parameters\ndirectly, they should be explicitly specified.\n\nMM_ID ID=/id_name/\n  \u00dd,SPEPNAME=/mm_epname/\u00a8\n  \u00dd,SPEPA=/mm_epa/\u00a8\n  \u00dd,SPTOKEN=/mm_token/\u00a8\n  \u00dd,ESID=/esid_name/\u00a8\n  \u00dd,ESVA=/esva/\u00a8\n\n\n\n*Parameter *\n\n\n\nDescription\n\nid_name\n\n\n\nthe identifier to assign to the service processor identifier being\nestablished. This name must be unique for all service processor identifiers.\n\nmm_epname\n\n\n\nthe entry point name of the Memory Manager service processor module that\nis being used.\n\nmm_epa\n\n\n\nspecifies the label of a fullword in storage that will contain the entry\npoint address of the Memory Manager service processor.\n\nmm_token\n\n\n\nspecifies the label of a fullword in storage that will contain the value\nassigned by the MM_START function of the Memory Manager.\n\nesid_name\n\n\n\nthe name of a service processor identifier, created by the ES_ID macro,\nwhich will be used by the MM_ID macro to automatically obtain the value\nfor /esv/(see below). If this parameter is not specified and an\nEnvironment Support service processor ID exists, that ID will be used.\n\nesva\n\n\n\nspecifies the label of a fullword in storage that contains (or will\ncontain) the address of the Environment Support Vector (ESV) created by\nthe ES_START function.\n\n\n      Example\n\nAn application intends to use only one memory manager heap for its\nstorage and issues the following instruction:\n\n   MM_ID ID=MM,EPNAME=&MEMORY_MANAGER\n\nThis instruction will save all parameter values and generate the\nfollowing code:\n\n                  PWA TYPE=PARTIAL  | Generate fields to EPA & TOKEN.\n&PWA.MM_SPEPA    DS  A             |   ID=MM: Entry point address.\n&PWA.MM_SPTOKEN  DS  F             |   ID=MM: Token value.\n                     ENDPWA  ,         | End of generated fields.\n\nOnce the MM_ID macro instruction above has been executed by the\nassembler, specifying ID=MM on any Memory Manager macro instruction will\nbe equivalent to supplying all of the above values.\n\nIf the application needs to use more than one heap, it can either create\nan ID for each heap, or it can specify ID=MM but override the\n/mm_token/parameter on each macro instruction:\n\nMM_START          ID=MM,SPTOKEN=NEW_HEAP  Create a new storage heap.\nMM_OBTAIN_STORAGE ID=MM,SPTOKEN=NEW_HEAP,SIZE=256,ADDRESS=BUFFER_ADDR\n\n_*MM_OBTAIN_STORAGE - Allocate Managed Storage*_\n\nThe MM_OBTAIN_STORAGE function allocates a single contiguous section of\nmemory for use by an application program. The new storage will begin on\na doubleword boundary and its address will be returned in the\n/address/parameter. The storage will be initialized to all zeros before\nit is returned to the application program.\n\nIf the Memory Manager cannot locate a large enough section of storage\nwithin the specified heap, storage will be obtained from the system and\nadded to the heap. The amount of storage obtained from the system will\nequal the heap's increment size or the amount of storage being allocated\n(/size/), whichever is larger.\n\nMM_OBTAIN_STORAGE ID=/id_name/ \u00dd,SPEPA=/mm_epa/\u00a8 \u00dd,SPTOKEN=/mm_token/\u00a8\n   ,SIZE=/size/\n   ,ADDRESS=/address/\nCALLX /mm_epa/,(/mm_token/,&MM_OBTAIN_STORAGE,/size/,/address/)\n\n\n\n*Parameter *\n\n\n\nDescription\n\nsize\n\n\n\nspecifies the label of a signed fullword integer indicating the desired\namount of storage to be allocated. The amount of storage to be allocated\nmust be between 1 and 16,777,215 bytes.\n\naddress\n\n\n\nspecifies a fullword in which the address of the newly allocated storage\nis to be returned.\n\n\n\n      Example\n\nThis example shows the code needed to allocate storage for holding a\nsimple control block.\n\n          ...\n   MM_OBTAIN_STORAGE ID=MM,SIZE==A(CTL_LEN),ADDRESS=PWA_CTLPTR\n             ...\n             PWA\nPWA_CTLPTR   DS  A          Address of control block storage.\n             ENDPWA\n             ...\nCTL          DSECT          Control Block's DSECT.\n             ...              Various control block fields.\nCTL_LEN      EQU  *-CTL     Length of Control Block.\n\n_*MM_RELEASE_STORAGE - Release Managed Storage*_\n\nThe MM_RELEASE_STORAGE function releases a contiguous section of storage\nback to the managed heap identified by the mm_token parameter. The\nstorage to be released must be located within the heap identified by\n/mm_token/and must begin on a doubleword boundary. It is pointed to by\nthe /address/parameter and its length is specified by the /size/parameter.\n\nThe storage being released does not have to exactly match a previous\nMM_OBTAIN_STORAGE request in its /address/and /size/, but it must\nconsist entirely of storage allocated from heap /mm_token/. For example,\na program might allocate a single large piece of storage and then give\nit back piece-by-piece. So long as the storage being returned to the\nheap came from the heap in the first place, there is no problem.\n\nMM_RELEASE_STORAGE ID=/id_name/ \u00dd,SPEPA=/mm_epa/\u00a8 \u00dd,SPTOKEN=/mm_token/\u00a8\n   ,SIZE=/size/\n   ,ADDRESS=/address/\nCALLX /mm_epa/,(/mm_token/,&MM_RELEASE_STORAGE,/size/,/address/)\n\n\n\n*Parameter *\n\n\n\nDescription\n\nsize\n\n\n\na fullword integer indicating the desired amount of storage to be\nreleased. The memory manager will round this value up to the nearest\nmultiple of eight.\n\naddress\n\n\n\na fullword address that points to the storage to be released. This\nstorage should have been previouly allocated in the same storage heap by\nthe MM_OBTAIN_STORAGE function of the memory manager, and must be\naligned on a doubleword boundary.\n\n\n      Example\n\nThis example shows the code needed to release storage that held a simple\ncontrol block.\n\n          ...\n   MM_RELEASE_STORAGE ID=MM,SIZE==A(CTL_LEN),ADDRESS=PWA_CTLPTR\n             ...\n             PWA\nPWA_CTLPTR   DS  A          Address of control block storage.\n             ENDPWA\n             ...\nCTL          DSECT          Control Block's DSECT.\n             ...              Various control block fields.\nCTL_LEN      EQU  *-CTL     Length of Control Block.\n\n_*MM_RESET_HEAP - Release All Managed Storage*_\n\nThe MM_RESET_HEAP function releases all managed storage back to the heap\nidentified by the mm_token parameter. This function provides\napplications with a method of reusing a heap without having to terminate\nand restart a Memory Manager session. When this function is used, all\nstorage previously obtained within the heap by the MM_OBTAIN_STORAGE\nfunction is released back to the heap.\n\nMM_RESET_HEAP ID=/id_name/ \u00dd,SPEPA=/mm_epa/\u00a8 \u00dd,SPTOKEN=/mm_token/\u00a8\nCALLX /mm_epa/,(/mm_token/,&MM_RESET_HEAP)\n\n_*MM_START - Create a New Storage Heap*_\n\nThe MM_START function creates a new storage heap for management by the\nmemory manager. Two optional parameters, /increment/and\n/location/control how the heap will grow and where its storage will be\nallocated.\n\nMM_START ID=/id_name/ \u00dd,SPEPA=/mm_epa/\u00a8 \u00dd,SPTOKEN=/mm_token/\u00a8\n  \u00dd,ESVA=/esva/\u00a8\n  \u00dd,INCREMENT={:us.4096:eus. | /increment/}\u00a8\n  \u00dd,LOCATION={*:us.ANY:eus.*|*BELOW*}\u00a8\nCALLX /mm_epa/,(/mm_token/,&MM_START,/esva/,\u00dd/increment/\u00a8,\u00dd/location/\u00a8)\n\n\n\n*Parameter *\n\n\n\nDescription\n\nincrement\n\n\n\nspecifies the label of a fullword signed integer that will be used as\nthe smallest amount of storage to obtain from the system when the heap\nneeds to grow in size. A larger amount of storage will be obtained if\nneeded in order to satisfy an MM_OBTAIN_STORAGE request. If the\nspecified value for /increment/is an even multiple of the system page\nsize (4096 bytes), each increment of storage will be allocated on a page\nboundary. The default value for /increment/is 4096 bytes.\n\nlocation\n\n\n\nspecifies whether storage for the heap must come from below the\n16-megabyte line (*BELOW*) or if it may come from anywhere (*ANY*). For\nthe call form of this function, /location/specifies a fullword in\nstorage containing the value of symbol &MM_LOCATION_BELOW if the storage\nmust come from below the 16-megabyte line and &MM_LOCATION_ANY if the\nstorage may come from anywhere. These symbols are defined in copy member\nSRVMMMAC.\n\n\n\n_*MM_TERMINATE - Destroy an Existing Storage Heap *_\n\nThe MM_TERMINATE function releases all storage associated with an\nexisting storage heap and then destroys the heap. The value of\n/mm_token/will be set to zero when MM_TERMINATE returns.\n\nMM_TERMINATE ID=/id_name/ \u00dd,SPEPA=/mm_epa/\u00a8 \u00dd,SPTOKEN=/mm_token/\u00a8\nCALLX /mm_epa/,(/mm_token/,&MM_TERMINATE)\n\n------------------------------------------------------------------------\n\n\n  Chapter 10. Message Services <#ToC_79>\n\nThe Message Services service processor simplifies the tasks of defining,\nissuing and maintaining messages. This is accomplished by:\n\n  *\n\n    Defining messages in a /central place/, separate from the code that\n    issues them.\n\n  *\n\n    Defining /standards/which the messages must follow, which are\n    enforced at assembly time.\n\n  *\n\n    Associating a /severity/with a message, which the issuer may\n    optionally use to set returncodes.\n\n  *\n\n    Allowing /text substitution/within predefined messages. The\n    substitution function uses the String Formatter: hence, any message\n    may be defined using standard String Formatter format strings.\n\n  *\n\n    Defining the /message destination/at execution time.\n\n  *\n\n    Allowing the caller to /retrieve message text/if needed for special\n    routing (such as multiple destinations).\n\n\n      Defining Messages <#ToC_80>\n\nMessage Services requires its users to define messages in a message\nCSECT. Macros are provided to simplify construction of this CSECT. Up to\n25 message CSECTs may be loaded by an individual Message Services\nsession. Each message CSECT will ultimately reside as a load module:\nhowever, since Message Services uses the ES_LOAD_MODULE function to\nlocate and load the message CSECTs into storage, the message CSECT could\nbe defined via a module name table and linked with the caller's load\nmodules and/or other message CSECTs as desired.\n\nThe construction of a message CSECT is a simple matter. The CSECT itself\nis started and terminated by the MS_MESSAGE_MODULE macro, which also\ndefines the messages' prefix string, the length of the message\nidentifiers, and optionally the severity characters and their associated\nreturn codes. Each individual message is defined by a MS_MESSAGE macro,\nwhich ensures that the proper message ID prefix, length and severity\ncharacters were used. The following example defines a message CSECT with\nthree messages:\n\n*Figure 15. Sample Message Module Definition* <#FT_Figure_15>\n\n\n\n      MS_MESSAGE_MODULE   START,                                   +\n                  NAME=MSGMOD03,         This becomes the CSECT name  +\n                  PREFIX=ABC,                                         +\n                  IDLENGTH=8,            All msgids are 8 chars long  +\n                  SEVCHAR=((I,0),(W,4),(E,8),(F,12))\n\nABC0001I MS_MESSAGE  'This is merely informational; return code is 0.'\nABC0002W MS_MESSAGE  'You are being warned; return code is 4.'\nABC0003E MS_MESSAGE  'An error has occurred; return code is 8.'\n\n         MS_MESSAGE_MODULE   END\n\nMS_MESSAGE_MODULE and MS_MESSAGE do not generate any executable code.\n\n\n      Obtaining Message Services' Symbols & Macros <#ToC_81>\n\nMessage Services' symbols and interface macros can be found in the\nassembler copy member SRVMSMAC. This member contains symbols naming\nMessage Services' load module, function codes, return codes, and\nparameter values. It also contains macros for using all of the Message\nServices' functions. The following statement or its equivalent should\nappear at the beginning of any program that uses Message Services:\n\n   COPY SRVMSMAC      Obtain Message Services' symbols & macros.\n\n\n      Establishing Message Services Defaults <#ToC_82>\n\nSome parameters are general to Message Services and not specific to any\nfunction. These parameters include its load module name (/MS_epname/),\nentry point address (/MS_epa/), and token value (/MS_token/). The MS_ID\nmacro (see ) can be used to establish defaults for these parameters and\nassociate them with a unique service processor identifier. The\nidentifier may then be supplied on any Message Services macro\ninstruction to refer to the default parameter values.\n\n\n      Identifying Message Services <#ToC_83>\n\nThe Message service processor resides in the load module named by the\nfollowing symbol definition in copy member SRVMSMAC:\n\n&MESSAGE_SERVICES SETC  '''SRVMS   '''\n\nThis symbolic name should be used as the service processor entry point\nname for Message Services as shown in the following MS_ID macro\ninstruction:\n\nMS_ID ID=MS,SPEPNAME=&MESSAGE_SERVICES    Set MsgServ Defaults.\n\n\n      Loading Message Services <#ToC_84>\n\nThe recommended method for loading Message Services is through\nEnvironment Support's ES_LOAD_MODULE function, as shown in the following\nexample:\n\nES_LOAD_MODULE ID=ES,SPID=MS            Load Message Services\n\n\n      Common Parameters <#ToC_85>\n\nThere are several parameters common to any Message Services function\ncall. These are:\n\n\n\n*Parameter *\n\n\n\nDescription\n\nid_name\n\n\n\nspecifies the name of a service processor identifier created by the\nMS_ID macro which will be used by the MS_START macro to automatically\nobtain values for /MS_epa/and /MS_token/. This parameter is required\nunless both /MS_epa/and /MS_token/are specified.\n\nMS_epname\n\n\n\nthe entry point name of the Message Services service processor module\nthat is being used.\n\nMS_epa\n\n\n\nspecifies the label of a fullword in storage that contains the entry\npoint address of an already-started Message Services service processor.\nThe value specified by /MS_epa/overrides any value obtained from\nID=/id_name/.\n\nMS_token\n\n\n\nspecifies the label of a fullword in storage that contains the value\nreturned by MS_START for the /MS_token/parameter. The value specified by\n/MS_token/overrides any value obtained from ID=/id_name/.\n\n\n\n      Return Codes <#ToC_86>\n\nMessage Services may issue any of the following return codes in various\nsituations. Some of the return codes may be received from any call to\nMessage Services, while others are specific to individual functions.\n\n\n\n*Return Code *\n\n\n\nSymbol\n\n\n\nDescription\n\n0\n\n\n\nMS_SUCCESS\n\n\n\nThe Message Services function has completed successfully.\n\n1\n\n\n\nMS_INVALID_FUNCTION\n\n\n\nThe specified function code is not presently supported.\n\n2\n\n\n\nMS_INVALID_NUMBER_OF_PARMS\n\n\n\nThe Message Services function received an invalid number of parameters.\nThis may be due to an improperly coded CALLX or PLIST macro, or the\ninadvertent use of the NOVL option.\n\n3\n\n\n\nMS_INVALID_MS_ID\n\n\n\nMessage Services detected an invalid PWA address in MS_token.\n\n4\n\n\n\nMS_ENVIRONMENT_SUPPORT_ ERROR\n\n\n\nAn error was reported by Environment Support. The error probably\noccurred while attempting to load the Printline or String Handler\nservice processor.\n\n5\n\n\n\nMS_STRING_HANDLER_ERROR\n\n\n\nAn error was reported by the String Handler service processor. More\ninformation may be found by issuing the ES_DISPLAY_DEBUG_INFO function.\n\n6\n\n\n\nMS_PRINT_LINE_TRUNCATED\n\n\n\nThe formatted message was too large to fit in Message Services' internal\n256-byte buffer. The first 256 bytes of the message are printed.\n\n7\n\n\n\nMS_PRINTLINE_ERROR\n\n\n\nAn error was reported by the Printline service processor. More\ninformation may be found by issuing the ES_DISPLAY_DEBUG_INFO function.\n\n8\n\n\n\nMS_INVALID_MSGDEST_OPTION\n\n\n\nThe option byte provided did not contain a valid MSGDEST option value.\nMessage Services currently supports the following MSGDEST option values:\n\n  *\n\n    /*0*/- Not specified.\n\n  *\n\n    /*1*/- DDNAME specified.\n\n  *\n\n    /*2*/- PLID or PL specified.\n\n  *\n\n    /*3*/- CONSOLE specified.\n\n9\n\n\n\nMS_MSGMOD_MISSING\n\n\n\nEither the address of the message module list was zero, or the list's\ncount field was zero. At least one message module must be provided to\nMS_START.\n\n10\n\n\n\nMS_TOO_MANY_MSGMODS\n\n\n\nMore than 25 message modules were provided to MS_START. At present,\nMessage Services can only handle 25 message modules.\n\n11\n\n\n\nMS_MSGMOD_NOT_LOADED\n\n\n\nA particular message module could not be loaded by MS_START.\n\n12\n\n\n\nMS_MSGMOD_NOT_VALID\n\n\n\nOne of the message modules was not a valid Message Services message module.\n\n13\n\n\n\nMS_INVALID_SIZELENGTH\n\n\n\nMS_START found a sizelength value that was greater than 4. The value of\nsizelength must be between 1 and 4, or must be 0 or unspecified in order\nto use the default value of 2.\n\n14\n\n\n\nMS_MESSAGE_NOT_FOUND\n\n\n\nThe message specified by msgid_string could not be found among the\nactive message modules.\n\n15\n\n\n\nMS_INVALID_PREFIX\n\n\n\nThe message prefix specified by msgid_string was not found among the\nactive message modules.\n\n16\n\n\n\nMS_MSGDEST_NOT_PROVIDED\n\n\n\nA message destination was not provided via the MSGDEST operand of\nMS_START. This Message Services function cannot be used without a\nmessage destination.\n\n\n\n------------------------------------------------------------------------\n\n\n    Message Services Functions <#ToC_87>\n\nThe remaining sections of this chapter describe all functions provided\nby Message Services, arranged in alphabetical order. Each function's\ndescription begins on a new page, and the name of the function being\ndescribed appears in the top outside corner of every page.\n\n_*MS_GET_MESSAGE - Retrieve Message Text*_\n\nThe MS_GET_MESSAGE function retrieves and formats a message, then\nreturns the formatted message text and its length to the caller.\n\nMS_GET_MESSAGE ID=/id_name/ \u00dd,SPEPA=/MS_epa/\u00a8 \u00dd,SPTOKEN=/MS_token/\u00a8\n   ,MSGID=/msgid_ID_string/\n   ,STRING=({/string/ |(/string/,/string_length/)}\n   ,RESULTLEN=/result_length/\n   \u00dd,SOURCE=(/source1/,/source2/, ...)\u00a8\nCALLX /MS_epa/,(/MS_token/,&MS_GET_MESSAGE,/msgID_string/\n              ,/string/,/string_length/,/result_length/\n              {,/source1/,/source2/, ...})\n\n\n\n*Parameter *\n\n\n\nDescription\n\nmsgid_ID_string\n\n\n\nSpecifies the message ID to be processed.\n\nstring\n\n\n\nSpecifies the area where MS_GET_MESSAGE will return the text of the\nrequested message.\n\nstring_length\n\n\n\nProvides the length of the field named by string. The length of this\nfield is governed by the SizeLength operand specified on the MS_ID or\nMS_START macro.\n\nresult_length\n\n\n\nThe MS_GET_MESSAGE function will return the actual length of the\nformatted message into this field. The length of this field is governed\nby the SizeLength operand specified on the MS_ID or MS_START macro.\n\nsource\n\n\n\nProvides substitution parameters for the String Handler to insert into\nthe message being constructed.\n\n\n\n*Examples *\n\nIf message ABC002I were defined in a message CSECT using:\n\nABC002E MS_MESSAGE \"{I} parameters ignored due to {C}.\"\n\nthe following MS_GET_MESSAGE macro:\n\nMS_GET_MESSAGE  ID=MS,\n                MSGID==C'ABC002E',\n                SOURCE=(3,\"syntax errors\")\n\nwould result in the message:\n\n   ABC002E 3 parameters ignored due to syntax errors.\n\n_*MS_ID - Establish Default Message Services Values*_\n\nThe MS_ID macro is used to establish default values for use by other\nMessage Services macros, which may access those values through a unique\nidentifier, /id_name/, specified by the user. When allowed to generate\ndefault values, this macro will create Program Work Area (PWA) storage\nfor /MS_epa/and /MS_token/. These values, whether generated by the macro\nor provided by the user, are accessable from all other Message Services\nmacros via the ID=/id_name/parameter.\n\nMS_ID ID=/id_name/\n   \u00dd,SPEPNAME=/MS_epname/\u00a8\n   \u00dd,SPEPA=/MS_epa/\u00a8\n   \u00dd,SPTOKEN=/MS_token/\u00a8\n   \u00dd,ESID=/esid_name/\u00a8\n   \u00dd,ESVA=/esva/\u00a8\n   \u00dd,SIZELENGTH=/integer/\u00a8\n\n\n\n*Parameter *\n\n\n\nDescription\n\nesva\n\n\n\nSpecifies the label of a fullword in storage that contains (or will\ncontain) the address of the Environment Support Vector (ESV) created by\nthe ES_START function.\n\nsizelength\n\n\n\n\n\n\n*Examples*\n\nThe following MS_ID macro will associate everything required by the\nMessage Services macros with the service processor identifier PL, as\nwell as establish the sizelength value for the Message Services session.\n\n    MS_ID  ID=PL,\n           SPEPNAME=&MESSAGE_SERVICES,\n           SPEPA=PWA_MS_ENTRY,\n           SPTOKEN=PWA_MS_TOKEN,\n           ESID=ES,\n           ESVA=PWA_ESVA,\n           SIZELENGTH=4\n\nPWA_MS_ENTRY  DS    F         Entrypoint for Message Services\nPWA_MS_TOKEN  DS    F         Unique token for Message Services session\nPWA_ESVA      DS    F         Environment Support Vector address\n\n_*MS_ISSUE_MESSAGE - Issue A Message*_\n\nThe MS_ISSUE_MESSAGE function retrieves, formats and prints the message\nreferred to by /msgid_string/.\n\nMS_ISSUE_MESSAGE ID=/id_name/ \u00dd,SPEPA=/MS_epa/\u00a8 \u00dd,SPTOKEN=/MS_token/\u00a8\n   ,MSGID=/msgid_string/\n   \u00dd,SOURCE=(/source1/,/source2/, ...)\u00a8\nCALLX /MS_epa/,(/MS_token/,&MS_ISSUE_MESSAGE,/msgID_string/\n              {,/source1/,/source2/, ...})\n\n\n\n*Parameter *\n\n\n\nDescription\n\nmsgid_string\n\n\n\nSpecifies the message ID to be processed. This parameter may be coded as\na literal or an address.\n\nsource1,source2,...\n\n\n\nProvides substitution parameters for the String Handler to insert into\nthe message being constructed.\n\n\n\n*Examples *\n\nIf message ABC002I were defined in a message module using:\n\nABC002E MS_MESSAGE \"{I} parameters ignored due to {C}.\"\n\nthe following MS_ISSUE_MESSAGE macro:\n\nMS_ISSUE_MESSAGE  ID=MS,\n                  MSGID='ABC002E',\n                  SOURCE=(3,\"syntax errors\")\n\nwould result in the message:\n\nABC002E 3 parameters ignored due to syntax errors.\n\n_*MS_MESSAGE - Define A Message *_\n\nThe MS_MESSAGE macro is used to define the text of a message. MS_MESSAGE\nwill also use the values specified by the MS_MESSAGE_MODULE operands\nprefix, idlength and sevchar to enforce the respective attributes of the\nmessage.\n\nmessage_id  MS_MESSAGE  '      message_text      '\n\n\n\n*Parameter *\n\n\n\nDescription\n\nmessage_id\n\n\n\nProvides the message ID for the message. The message ID will be\ngenerated at the beginning of the message text. The message ID is\nexpected to be of the format: {msg_prefix}||{msg_number}||{sev_char} .\nThe contents and length of msg_prefix, as well as the value of sev_char\nand the overall length of the message ID are enforced by the values\nspecified on MS_MESSAGE_MODULE.\n\nmessage_text\n\n\n\nSpecifies a String Handler control string. The length of this string may\nbe up to 255 characters: however, the length of the resulting formatted\nstring cannot exceed 255 bytes.\n\n\n\n*Examples *\n\nThe following MS_MESSAGE macros define a series of messages. They also\npoint out the default severity characters.\n\nXYZ001I  MS_MESSAGE  \"Information message, severity value of 0.\"\nXYZ002W  MS_MESSAGE  \"Warning message, severity value of 4.\"\nXYZ003E  MS_MESSAGE  \"Error message, severity value of 8.\"\nXYZ004S  MS_MESSAGE  \"Severe message, severity value of 12.\"\nXYZ005C  MS_MESSAGE  \"Catastrophic message, severity value of 16.\"\n\n_*MS_MESSAGE_MODULE - Define A Message Module *_\n\nThe MS_MESSAGE_MODULE macro is used to start or end a message module.\nMS_MESSAGE_MODULE also sets various attributes of the messages prefix,\nidlength and sevchar to enforce the respective attributes of the message.\n\nMS_MESSAGE_MODULE START\n                 ,NAME=/csectname/\n                 ,PREFIX=/msgid_prefix/\n                 ,IDLENGTH={/msgid_length/ |/*8*/}\n                 \u00dd,SEVCHAR=/sevchar_def/\u00a8\n\n     -- or --\n\nMS_MESSAGE_MODULE END\n\n\n\n*Parameter *\n\n\n\nDescription\n\nSTART\n\n\n\nDefines the beginning of a message module. :pLt.END :pLd.Defines the end\nof the message module. This must be coded after all MS_MESSAGE macros.\nNo other parameters are valid when END is coded.\n\ncsectname\n\n\n\nProvides the name of the CSECT that MS_MESSAGE_MODULE will generate.\n\nmsgid_prefix\n\n\n\nSpecifies that all messages defined in this message module must be\nprefixed with this string. A message prefix may be up to 6 characters in\nlength.\n\nmsgid_length\n\n\n\nSpecifies the required length, in bytes, for all message IDs coded on\nMS_MESSAGE macros.\n\nsevchar_def\n\n\n\nProvides a list of message suffix characters and an associated severity.\nThese are coded as (character,severity), where character is a single\nmessage suffix character, and severity is the associated severity code.\nA maximum of these severity codes will be returned to the caller if the\nMAXSEV keyword is specified on the MS_START macro. Any message suffixes\ncoded on MS_MESSAGE macros that do not appear among the valid severity\ncharacters will cause an assembly error. The default sevchar_def list is:\n\nSEVCHAR=((I,0),(W,4),(E,8),(S,12),(C,16))\n\n\n\n*Examples *\n\nThe following macros define a complete message module.\n\n  MS_MESSAGE_MODULE START,\n                    NAME=ABC$MSGS,\n                    PREFIX=ABC,\n                    IDLENGTH=7,\n                    SEVCHAR=((I,0),(W,4),(E,8),(F,16))\n\nABC001I  MS_MESSAGE  \"Informational message, severity = 0.\"\nABC002W  MS_MESSAGE  \"Warning message, severity = 4.\"\nABC003E  MS_MESSAGE  \"Error message, severity = 8.\"\nABC004F  MS_MESSAGE  \"Fatal message, severity = 16.\"\n\n  MS_MESSAGE_MODULE END\n  END\n\n_*MS_START - Begin A Message Services Session*_\n\nThe MS_START function establishes a new Message Services session and\nreturns its session identifier in the /MS_token/parameter. The message\ndestination, maximum severity field, message CSECT list and other global\nMessage Services parameters are provided here.\n\nMS_START ID=/id_name/ \u00dd,SPEPA=/MS_epa/\u00a8 \u00dd,SPTOKEN=/MS_token/\u00a8\n   \u00dd,ESVA=/esva/\u00a8\n   ,MSGDEST=(DDNAME,/ddnamespec/)     |\n            (PLID,/msgserv_procid/)   |\n            (PL,/PL_EPA/,/PL_token/)    |\n            (CONSOLE)\n   ,MSGMOD=(/msgmod_csect/,/msgmod_csect/, ...)\n   ,MSGMODLIST=/msgmod_list/\n   \u00dd,MAXSEV=/maxsev_address/\u00a8\n   \u00dd,PLCC=/carriage_control/\u00a8\n   \u00dd,SIZELENGTH={/sizelength/ | *2*}\u00a8\n   \u00dd,OPTIONS=(/option_list/)\u00a8\nCALLX /MS_epa/,(/MS_token/,&MS_START,/esva/,\n              /msgmod_list/,/sizelengthmaxsev_address/,\n              /carriage_control/,/MSGDEST_option,/\n              /MSGDEST_specific_parameters/,/option_byte/)\n\n\n\n*Parameter *\n\n\n\nDescription\n\nesva\n\n\n\nSpecifies the label of a fullword in storage that contains the address\nof the Environment Support Vector (ESV) created by the ES_START function.\n\nMSGDEST\n\n\n\nSpecifies the message destination that Message Services will use to\nwrite its formatted messages. The MSGDEST keyword supports the following\noperands:\n\n  *\n\n    /*DDNAME*/: This provides the DDname that Message Services should\n    use to start a Printline session. The Printline session will be\n    terminated when MS_TERMINATE is called.\n\n  *\n\n    /*PLID*/: This specifies the service processor ID of an existing\n    Printline session. The ID is used to find the\n\n  *\n\n    /*PL*/: This is used to provide the /PL_EPA/and /PL_token/of an\n    existing Printline session.\n\n  *\n\n    /*CONSOLE*/: This specifies that the /console/is the message\n    destination. The ES_DISPLAY_MESSAGE service is actually used to\n    display the message.\n\nMSGDEST_option\n\n\n\nIf the CALLX form is used, the MSGDEST keyword must be represented as a\nsingle byte, containing one of the following values:\n\n  *\n\n    /*0*/- MSGDEST not specified. There are no additional parameters.\n\n  *\n\n    /*1*/- DDNAME specified. This is followed by the address of an\n    8-character DDname.\n\n  *\n\n    /*2*/- PLID or PL specified. This is followed by the addresses of\n    PL_EPA and PL_token respectively.\n\n  *\n\n    /*3*/- CONSOLE specified. There are no additional parameters.\n\nmsgmod_csect\n\n\n\nProvides the names of one or more message modules. These modules will be\nloaded by ES_LOAD_MODULE, and thus must either exist as separate load\nmodules in STEPLIB or be defined in an application module name table.\n\nmsgmod_list\n\n\n\nIf the application has a need to construct its own message module list,\nit may be provided to MS_START using the MSGMODLIST keyword. The message\nmodule list must consist of a fullword containing the number of message\nmodule names, followed by a list of 8-character module names, as follows:\n\nMOD_LIST DC   F'3'\n         DC   CL8'ABC$MSGS'\n         DC   CL8'DEF$MSGS'\n         DC   CL8'XYZ$MSGS'\n\nA list of this format is constructed when the MSGMOD keyword is used.\nThe MSGMOD and MSGMODLIST keywords are mutually exclusive.\n\nmaxsev_address\n\n\n\nThe optional address of a halfword where Message Services will maintain\nthe highest severity level of any message issued. This field should be\ninitialized to zeros before MS_ISSUE_MESSAGE or MS_GET_MESSAGE are invoked.\n\ncarriage_control\n\n\n\nOptionally provides an ASA carriage control character to be used when\nprinting messages. If MSGDEST is not specified or is set to CONSOLE, use\nof the PLCC keyword will generate an MNOTE. The operand of PLCC may be\nspecified as a quoted character or as an address.\n\nsizelength\n\n\n\nAn integer value from 1 and 4 that determines the size, in bytes, of all\nvalues representing string lengths by the String Handler. For example, a\n/sizelength/value of 4 would cause all lengths returned by the String\nHandler to be 4 bytes in length.\n\noption_list\n\n\n\nA list of additional options for this Message Services session. The only\noption currently supported is /FOLD/.\n\n    *FOLD*- All output produced by Message Services should be folded to\n    uppercase. If using the CALLX form to call /MS_START/, the FOLD\n    option corresponds to a bit setting of X'80' in the option byte.\n    Note that when using a MSGDEST of /PLID/, the PrintLine session must\n    have been started with /OPTIONS=FOLD/.\n\n\n\n*Examples *\n\nThe following MS_START macro will initialize a Message Services session.\nThis MS_START example will cause the following to occur:\n\n  *\n\n    A Printline session will be started by Message Services, using\n    DDname SYSPRINT and a SizeLength value of 4.\n\n  *\n\n    The message modules ABC$MSGS, DEF$MSGS and XYZ$MSGS are loaded and\n    validated.\n\n  *\n\n    The address of PWA_MAXSEV is bound as the MaxSev halfword's address.\n    PWA_MAXSEV will be maintained with the highest message severity code\n    of any message issued by this Message Services session.\n\n  *\n\n    A carriage control byte of '0' will prefix all messages built by\n    this Message Services session. This will cause messages to be\n    double-spaced by PrintLine.\n\n    MS_START ID=PL,\n             MSGDEST=(DDNAME,=C'SYSPRINT'),\n             MSGMOD=(ABC$MSGS,DEF$MSGS,XYZ$MSGS),\n             MAXSEV=PWA_MAXSEV,\n             PLCC='0',\n             SIZELENGTH=4\n\nPWA_MAXSEV   DS    H         Max. severity, maintained by MsgServ\n\n_*MS_TERMINATE - Terminate A Message Services Session *_\n\nThe MS_TERMINATE function concludes the Message Services session\nidentified by the /MS_token/parameter, and releases any resources held\nby the Message Services service processor.\n\nMS_TERMINATE ID=/id_name/ \u00dd,SPEPA=/MS_epa/\u00a8 \u00dd,SPTOKEN=/MS_token/\u00a8\nCALLX /MS_epa/,(/MS_token/,&MS_TERMINATE)\n\n*Examples *\n\nThe following MS_TERMINATE macro will cause Message Services to close\nits report file and release any resources that it acquired.\n\nMS_TERMINATE ID=MS\n\n------------------------------------------------------------------------\n\n\n  Chapter 11. Printline <#ToC_88>\n\nThe Printline service processor is intended to simplify report writing\nby managing such typical \"housekeeping\" tasks of report writing as\nheaders and footers, page ejects, and page numbers. This can reduce the\ncomplexity of programs that need to produce reports, freeing the\ndeveloper to concentrate on other aspects of the report program.\n\nThe Printline service processor is dependent on the MVS operating system\nenvironment, primarily due to its use of QSAM.\n\nThe Printline service processor can make use of the String Handler to\nconstruct header, footer and data lines from String Handler control\nstrings and source parameters. Heading and footing definitions may be\nadded, changed or deleted dynamically. Page counters are defined as part\nof a heading or footing data line: while the actual counters reside in\nthe caller's storage, they are incremented automatically by Printline,\nand formatted under control of the associated format control string.\nMultiple page counters may be defined at once, and they need not contain\nthe same values.\n\n\n      Basic Operation Of Printline <#ToC_89>\n\nPrintline has three types of lines: /header/lines, /footer/lines, and\n/data/lines. Header and footer lines are generally established once, and\nremain \"current\" until either Printline is told to remove them or\nPrintline is terminated. Data lines are printed as they are passed to\nPrintline. If a data line would not fit on the current page, Printline\nwill print any footers that are currently defined, then print any\nheaders that are defined. Any page counters active at the time will be\nincremented. The caller can also force a page \"break\" to occur by\ncalling a Printline function.\n\nPrintline uses the OS file handler for output. When the OS file handler\nis started, option ISOCC and RECORDLENGTH=(4,maxlnsz) is specified.\n\nBy default, Printline will print exactly what is passed to it,\npreserving lowercase data. An option can be used to cause Printline to\nconvert everything it prints to uppercase. This may be a consideration\nif reports produced using Printline might print on uppercase-only printers.\n\n\n      The Format Of A Page <#ToC_90>\n\nPrintline allows its caller to define the format of a report's page in\nterms of:\n\n  *\n\n    The length of the page (number of total print lines),\n\n  *\n\n    The /header/, or those lines that appear at the top of each page,\n\n  *\n\n    The /footer/, or those lines that appear at the bottom of each page,\n\n  *\n\n    The body of the page.\n\nPrintline provides function macros to manage each of these components a\nreport: these are defined below.\n\n\n        The Length Of The Page\n\nWhen a Printline session is started, the caller specifies the space on a\npage available for printing. The default page length is 66 print lines.\nThe actual space available for printing data is determined by the total\npage length minus any headers and footers defined. Since headers and\nfooters can be defined, changed or removed in mid-report, the amount of\nspace available for printing data may change. The PL_QUERY_LINES_LEFT\nfunction can return the amount of space remaining on the current page at\nany point in a Printline session.\n\n\n        Headers\n\nHeaders as defined by Printline, appear at the top of each printed page.\nWhen a page break occurs (by either reaching the end of the current page\nor calling the PL_PAGE_BREAK function), the headers are printed\naccording to the current header definition.\n\nHeader lines are defined individually by the PL_SET_HEADER and\nPL_SET_FORMATTED_HEADER functions, and may be subsequently removed by\nthe PL_RESET_HEADER function. Each header line is assigned a \"line\nnumber\": this number is used to determine the order that header lines\nare printed in. A header may be redefined \"in-place\" using the same line\nnumber, even if the number or size of its parameters changes. The line\nnumbers do not need to be consecutive: in fact, header lines can be\ninserted by using a line number value between existing line numbers.\nThis example shows how a header line can be inserted and later removed\nin mid-report, as shown in Figure 16 <#FIGPLHDREX>.\n\n*Figure 16. Printline Header Definition Example* <#FT_FIGPLHDREX>\n\n\n\nPL_SET_HEADER  ID=PL,LINE=10,STRING='1  The first header line.'\nPL_SET_HEADER  ID=PL,LINE=20,STRING='0  The last header line.'\n      :                         :\nPL_PRINT       ID=PL, ...           Print some stuff.\n      :                         :\nPL_SET_HEADER  ID=PL,LINE=15,STRING='0  An inserted header line.'\n      :                         :\nPL_PRINT       ID=PL, ...           Print some more stuff.\n      :                         :\nPL_RESET_HEADER  ID=PL,LINE=15\n\n\n\nPrintline requires each print line provided by its caller to contain an\nASA carriage control character as its first character. This allows the\ncaller to retain some control over the appearance of the report. While\nPrintline does not set or change carriage control characters itself, it\nuses the carriage controls provided by its caller to count the number of\nlines printed and remaining on the current page. The first header line\non a page should contain a carriage control character of '1', to ensure\nthat a page eject occurs before that line is printed.\n\nWhen using PL_SET_FORMATTED_HEADER, the caller can provide a fullword\nthat will be treated as a /page counter/. The page number is coded as\none of the String Formatter's substitution parameters in the SOURCE=\nparameter: Printline is told which parameter to use as the page counter\nvia the PAGENUM parameter, which provides the position of the page\nnumber's address in the SOURCE= list, as shown in Figure 17 <#FIGPLFMTHD>.\n\n*Figure 17. Sample Header Definition With Page Counter* <#FT_FIGPLFMTHD>\n\n\n\nPL_SET_FORMATTED_HEADER  ID=PL,                                       +\n                LINE=10,                                              +\n                STRING=format_string,                                 +\n                SOURCE=(todays_date,page_number),                     +\n                PAGENUM=2\n         :                     :\nformat_string  DC  C'1  Date: {CL8}       This is the report that you +\n                     always wanted.                  Page: {IL4}'\ntodays_date    DS  CL8\npage_number    DS  F\n\n\n\nIn this case, the second SOURCE parameter provides the address of the\npage counter: hence, the PAGENUM parameter specifies a value of \"2\".\nMultiple page numbers may be defined throughout the report, although\nonly one may be defined per header or footer line: each will be\nauto-incremented as the header or footer referencing it is printed. The\npage counter values should be initially set to zero, but may be modified\nby the calling program at any time. These counter fields are incremented\neach time they are printed: hence, they should not be referred to by\nmore than one header or footer definition at a time.\n\n\n        Footers\n\nFooters, if defined, will appear at the bottom of each page printed.\nFooters may be used for legends, footnotes, or to provide additional\ninformation that should appear on each page of a report. Like headers,\nfooter lines are defined with unique \"line numbers\", which determine the\norder in which the footer lines are printed.\n\nFooter lines are defined individually by the PL_SET_FOOTER and\nPL_SET_FORMATTED_FOOTER functions, and removed by the PL_RESET_FOOTER\nfunction, in much the same way as headers are defined. Unlike headers,\nhowever, Printline needs to know how many lines to reserve as footer\nspace, since it needs to be able to skip to the footer area if a page\neject is forced by PL_PAGE_BREAK. The PL_RESERVE_FOOTER function will\nreserve a number of lines at the bottom of a report page for footer lines.\n\nLike headers, footers may contain page counters, which are treated the\nsame way as page counters in headers. Use the PL_SET_FORMATTED_FOOTER\nfunction to define page counters in footer lines. These counter fields\nare incremented each time they are printed: hence, they should not be\nreferred to by more than one header or footer definition at a time.\n\n\n        The Body Of The Page\n\nAfter any headers have been defined and the space reserved by\nPL_RESERVE_FOOTER has been deducted, the space remaining on a page is\navailable for the body of the report. Use the PL_PRINT and\nPL_PRINT_FORMATTED functions to write data lines to the report.\n\n\n      Obtaining Printline Symbols & Macros <#ToC_95>\n\nPrintline's symbols and interface macros can be found in the assembler\ncopy member SRVPLMAC. This member contains symbols naming Printline's\nload module, function codes, return codes, and parameter values. It also\ncontains macros for using all of the Printline's functions. The\nfollowing statement or its equivalent should appear at the beginning of\nany program that uses the Printline:\n\n   COPY SRVPLMAC      Obtain Printline's symbols & macros.\n\n\n      Establishing Printline Defaults <#ToC_96>\n\nSome parameters are general to Printline and not specific to any\nfunction. These parameters include its load module name (/PL_epname/),\nentry point address (/PL_epa/), and token value (/PL_token/). The PL_ID\nmacro (see ) can be used to establish defaults for these parameters and\nassociate them with a unique service processor identifier. The\nidentifier may then be supplied on any Printline macro instruction to\nrefer to the default parameter values.\n\n\n      Identifying Printline <#ToC_97>\n\nThe Printline service processor resides in the load module named by the\nfollowing symbol definition in copy member SRVPLMAC:\n\n&PRINT_LINE       SETC  '''SRVMVSPL  '''\n\nThis symbolic name should be used as the service processor entry point\nname for Printline as shown in the following PL_ID macro instruction.\n\nPL_ID ID=ST,SPEPNAME=&PRINT_LINE       Set Printline Defaults.\n\n\n      Loading Printline <#ToC_98>\n\nThe recommended method for loading Printline is through Environment\nSupport's ES_LOAD_MODULE function, as shown in the following example:\n\nES_LOAD_MODULE ID=ES,SPID=PL            Load Printline\n\n\n      Common Parameters <#ToC_99>\n\nThere are several parameters common to many Printline function calls.\nThese are:\n\n\n\n*Parameter *\n\n\n\nDescription\n\nid_name\n\n\n\nspecifies the name of a service processor identifier created by the\nPL_ID macro which will be used by the PL_START macro to automatically\nobtain values for /PL_epa/and /PL_token/. This parameter is required\nunless both /PL_epa/and /PL_token/are specified.\n\nPL_epname\n\n\n\nthe entry point name of the Printline service processor module that is\nbeing used.\n\nPL_epa\n\n\n\nspecifies the label of a fullword in storage that contains the entry\npoint address of an already-started Date/Time Services service\nprocessor. The value specified by /PL_epa/overrides any value obtained\nfrom ID=/id_name/.\n\nPL_token\n\n\n\nspecifies the label of a fullword in storage that contains the value\nreturned by PL_START for the /PL_token/parameter. The value specified by\n/PL_token/overrides any value obtained from ID=/id_name/.\n\n\n\n      Return Codes <#ToC_100>\n\nPrintline may issue any of the following return codes in various\nsituations. Some of the return codes may be received from any call to\nDate/Time Services, while others are specific to individual functions.\n\n\n\n*Return Code *\n\n\n\nSymbol\n\n\n\nDescription\n\n0\n\n\n\nPL_SUCCESS\n\n\n\nThe Printline function has completed successfully.\n\n1\n\n\n\nPL_INVALID_FUNCTION\n\n\n\nPrintline does not support this function code.\n\n2\n\n\n\nPL_INVALID_NUMBER_OF_PARMS\n\n\n\nThe Printline function received an invalid number of parameters. This\nmay be due to an improperly coded CALLX or PLIST macro, or the\ninadvertent use of the NOVL option.\n\n3\n\n\n\nPL_INVALID_PL_ID\n\n\n\nThe Printline service processor detected an invalid PWA address in\nPL_token.\n\n4\n\n\n\nPL_MEMORY_MANAGER_ERROR\n\n\n\nAn attempt to invoke the Memory Manager resulted in an error. Debug\ninformation should be available via the ES_DISPLAY_DEBUG_INFO function.\n\n5\n\n\n\nPL_CANNOT_OPEN_DCB\n\n\n\nThe DDname provided by the caller could not be used to OPEN the report\nfile. A \"DDNAME MISSING\" message may accompany this error.\n\n6\n\n\n\nPL_ENVIRONMENT_SUPPORT_ERROR\n\n\n\nAn attempt to invoke Environment Support resulted in an error. Debug\ninformation should be available via the ES_DISPLAY_DEBUG_INFO function.\n\n7\n\n\n\nPL_STRING_HANDLER_ERROR\n\n\n\nAn error was detected by the String Handler while attempting to format a\nfooter line for printing. Debug information should be available via the\nES_DISPLAY_DEBUG_INFO function.\n\n8\n\n\n\nPL_PRINT_LINE_TRUNCATED\n\n\n\nThe length of string print_string exceeded the maximum line length\nspecified on the PL_START macro. The portion of print_string that would\nfit in the print line is printed.\n\n9\n\n\n\nReserved\n\n\n\nThis return code is currently unused.\n\n10\n\n\n\nPL_HEADER_NOT_FOUND\n\n\n\nThe header referred to by /line_number/was not found.\n\n11\n\n\n\nPL_FOOTER_NOT_FOUND\n\n\n\nThe footer referred to by /line_number/was not found.\n\n12\n\n\n\nPL_INVALID_PAGEDISP\n\n\n\nThe /pagenum/parameter's value was greater than the number of\n/source/parameters.\n\n13\n\n\n\nPL_INVALID_SIZELENGTH\n\n\n\nThe /sizelength/parameter is not valid. It may only be a fullword\ninteger between 1 and 4.\n\n14\n\n\n\nPL_MISSING_PARAMETER\n\n\n\nA required parameter is missing.\n\n15\n\n\n\nPL_HEADER_LINE_TRUNCATED\n\n\n\nA simple or formatted header line has exceeded MaxLineSize in length.\nThe un-truncated portion of the header line is printed. Note that by the\ntime the caller is informed of this error, several header lines may have\nbeen printed.\n\n16\n\n\n\nPL_FOOTER_LINE_TRUNCATED\n\n\n\nA simple or formatted footer line has exceeded MaxLineSize in length.\nThe un-truncated portion of the footer line is printed. Note that by the\ntime the caller is informed of this error, several footer lines may have\nbeen printed.\n\n\n------------------------------------------------------------------------\n\n\n    Printline Service Processor Functions <#ToC_101>\n\nThe remaining sections of this chapter describe all functions provided\nby the Printline service processor, arranged in alphabetical order. Each\nfunction's description begins on a new page, and the name of the\nfunction being described appears in the top outside corner of every page.\n\n_*PL_ID - Establish Default Printline Values*_\n\nThe PL_ID macro is used to establish default values for use by other\nPrintline macros, which may access those values through a unique\nidentifier, /id_name/, specified by the user. When allowed to generate\ndefault values, this macro will create Program Work Area (PWA) storage\nfor /PL_epa/and /PL_token/. These values, whether generated by the macro\nor provided by the user, are accessable from all other Printline macros\nvia the ID=/id_name/parameter.\n\nPL_ID ID=/id_name/\n   \u00dd,SPEPNAME=/PL_epname/\u00a8\n   \u00dd,SPEPA=/PL_epa/\u00a8\n   \u00dd,SPTOKEN=/PL_token/\u00a8\n   \u00dd,ESID=/esid_name/\u00a8\n   \u00dd,ESVA=/esva/\u00a8\n   \u00dd,SIZELENGTH=/integer/\u00a8\n\n*Parameter *\n\n\n\nDescription\n\nesid_name\n\n\n\nthe name of a service processor identifier, created by the ES_ID macro,\nwhich will be used by the PL_ID macro to automatically obtain the value\nfor esv (see below).\n\nesva\n\n\n\nSpecifies the label of a fullword in storage that contains (or will\ncontain) the address of the Environment Support Vector (ESV) created by\nthe ES_START function.\n\nsizelength\n\n\n\nAn integer value from 1 and 4 that determines the size, in bytes, of all\nvalues representing string lengths by the String Handler. For example, a\n/sizelength/value of 4 would cause all lengths returned by the String\nHandler to be 4 bytes in length.\n\n\n\n*Examples *\n\nThe following PL_ID macro will associate everything required by the\nPrintline macros with the service processor identifier PL, as well as\nestablish the sizelength value for the Printline session.\n\n    PL_ID  ID=PL,\n           SPEPNAME=&PRINT_LINE,\n           SPEPA=PWA_PL_ENTRY,\n           SPTOKEN=PWA_PL_TOKEN,\n           ESID=ES,\n           ESVA=PWA_ESVA,\n           SIZELENGTH=4\n\nPWA_PL_ENTRY  DS    F         Entrypoint for Printline\nPWA_PL_TOKEN  DS    F         Unique token for Printline session\nPWA_ESVA      DS    F         Environment Support Vector address\n\n_*PL_PAGE_BREAK - Force A Page Break *_\n\nThe PL_PAGE_BREAK function causes a page break to occur immediately. As\na result, footers (if any) are printed at the bottom of the page, and\nthe next call to PL_PRINT or PL_PRINT_FORMATTED will cause headers (if\nany) to be printed.\n\nPL_PAGE_BREAK ID=/id_name/ \u00dd,SPEPA=/PL_epa/\u00a8 \u00dd,SPTOKEN=/PL_token/\u00a8\nCALLX /PL_epa/,(/PL_token/,&PL_PAGE_BREAK)\n\n*Examples *\n\nThe following Printline macro forces a page break to occur.\n\nPL_PAGE_BREAK ID=PL\n\n_*PL_PRINT - Unformatted Print *_\n\nThe PL_PRINT function prints an unformatted data line. The data line\nmust have an ASA carriage control character as its first character,\n\nPL_PRINT ID=/id_name/ \u00dd,SPEPA=/PL_epa/\u00a8 \u00dd,SPTOKEN=/PL_token/\u00a8\n   ,STRING={/print_string/ | /(print_string,string_len)/}\nCALLX /PL_epa/,(/PL_token/,&PL_PRINT,/print_string/,/string_len/)\n\n\n\n*Parameter *\n\n\n\nDescription\n\nprint_string\n\n\n\nSpecifies a character string to be printed.\n\nstring_len\n\n\n\nProvides the length of print_string. This operand is not required on the\nPL_PRINT macro if the macro can determine the length attribute of\nprint_string. The /string_len/value may be coded as an integer or other\nnumeric term, or may refer to a field in storage of /size_length/bytes\nin length, containing the string's length.\n\n\n\n*Examples *\n\nThe following Printline macro causes an unformatted print to occur.\n\nPL_PRINT ID=PL,STRING==C\"0 This data line will be double-spaced.\"\n\n_*PL_PRINT_FORMATTED - Formatted Print*_\n\nThe PL_PRINT_FORMATTED function uses the String Handler to format and\nprint a data line. The data line (as produced by the String Handler)\nmust have an ASA carriage control character as its first character.\n\nPL_PRINT_FORMATTED ID=/id_name/ \u00dd,SPEPA=/PL_epa/\u00a8 \u00dd,SPTOKEN=/PL_token/\u00a8\n   ,CONTROL={/format_string/ | /(format_string,string_len)/}\n   ,SOURCE={/(source1,source2,...)/}\nCALLX /PL_epa/,(/PL_token/,&PL_PRINT_FORMATTED,/format_string/,/string_len/\n             \u00dd,/arguments/\u00a8)\n\n\n\n*Parameter *\n\n\n\nDescription\n\nformat_string\n\n\n\nSpecifies the String Handler format string.\n\nstring_len\n\n\n\nProvides the length of format_string. This operand is not required on\nthe PL_PRINT_FORMATTED macro if the macro can determine the length\nattribute of print_string. The /string_len/value may be coded as an\ninteger or other numeric term, or may refer to a field in storage of\n/size_length/bytes in length, containing the string's length.\n\nsource\n\n\n\nSpecifies up to 50 substitution parameters to be processed by the String\nHandler.\n\n\n\n*Examples *\n\nThe following Printline macro requests a formatted print.\n\nPL_PRINT_FORMATTED ID=PL,\n          STRING==C\"0 Line {I}   A {CL20} print line.\",\n          SOURCE=(LINECTR,RPTNAME)\n\nLINECTR  DC   F'35'\nSPACING  DC   CL20\"double-spaced\"\n\nAs a result, the following is produced:\n\n Line 35   A double-spaced print line.\n\n_*PL_QUERY_LINES_LEFT - Query Remaining Lines On A Page *_\n\nThe PL_QUERY_LINES_LEFT function returns the number of lines remaining\non the current page. This is computed using the current line pointer and\nthe footer space reserved at the bottom of the page. Note that\nPL_QUERY_LINES_LEFT will cause headers to be printed if there are no\nheaders yet on the current page.\n\nPL_QUERY_LINES_LEFT ID=/id_name/ \u00dd,SPEPA=/PL_epa/\u00a8 \u00dd,SPTOKEN=/PL_token/\u00a8\n   ,LINES=/lines_remaining/\nCALLX /PL_epa/,(/PL_token/,&PL_PAGE_BREAK,/lines_remaining/)\n\n\n\n*Parameter *\n\n\n\nDescription\n\nlines_remaining\n\n\n\nspecifies the address of a fullword where the PL_QUERY_LINES_LEFT\nfunction will return the number of lines remaining on the current page.\n\n:plist. :pLt.:pLd. :eplist.\n\n*Examples *\n\nThe following Printline macro returns the lines remaining on the current\npage.\n\n     PL_QUERY_LINES_LEFT  ID=PL,LINES=PWA_Lines_Remaining\n                :\n                :\nPWA_Lines_Remaining  DS   F\n\n_*PL_RESERVE_FOOTER - Reserve Footer Space *_\n\nThe PL_RESERVE_FOOTER function reserves a number of lines at the bottom\nof each page for footer space. If footers are used, the value specified\nvia PL_RESERVE_FOOTER is used in conjunction with the pagesize parameter\nof PL_START to determine when and where page footers need to be printed.\n\nPL_RESERVE_FOOTER ID=/id_name/ \u00dd,SPEPA=/PL_epa/\u00a8 \u00dd,SPTOKEN=/PL_token/\u00a8\n   ,LINES=/footer_space/\nCALLX /PL_epa/,(/PL_token/,&PL_RESERVE_FOOTER,/footer_space/)\n\n\n\n*Parameter *\n\n\n\nDescription\n\nfooter_space\n\n\n\nSpecifies the number of lines to be reserved at the bottom of each page\nfor footer space.\n\n*Examples*\n\nThe following Printline macro requests 5 lines of footer space to be\nreserved.\n\nPL_RESERVE_FOOTER ID=PL,LINES=5\n\n_*PL_RESET_FOOTER - Delete Footer Definitions*_\n\nThe PL_RESET_FOOTER function deletes one or all existing footer\ndefinitions. The footers are referred to by their line number: if a line\nnumber of zero is specified, all existing footer definitions are deleted.\n\nPL_RESET_FOOTER ID=/id_name/ \u00dd,SPEPA=/PL_epa/\u00a8 \u00dd,SPTOKEN=/PL_token/\u00a8\n   ,LINE=/line_number/\nCALLX /PL_epa/,(/PL_token/,&PL_RESET_FOOTER,/line_number/)\n\n\n\n*Parameter *\n\n\n\nDescription\n\nline_number\n\n\n\nSpecifies an integer value denoting the footer line to be deleted. A\n/line_number/value of zero requests all existing footer definitions to\nbe deleted.\n\n\n\n*Examples *\n\nThe following Printline macro requests the footer created as line 10 to\nbe deleted.\n\nPL_RESET_FOOTER ID=PL,LINE=10\n\nThis example requests all footer definitions to be deleted.\n\nPL_RESET_FOOTER ID=PL,LINE=0\n\n_*PL_RESET_HEADER - Delete Header Definitions *_\n\nThe PL_RESET_HEADER function deletes one or all existing header\ndefinitions. The headers are referred to by their line number: if a line\nnumber of zero is specified, all existing header definitions are deleted.\n\nPL_RESET_HEADER ID=/id_name/ \u00dd,SPEPA=/PL_epa/\u00a8 \u00dd,SPTOKEN=/PL_token/\u00a8\n   ,LINE=/line_number/\nCALLX /PL_epa/,(/PL_token/,&PL_RESET_HEADER,/line_number/)\n\n\n\n*Parameter *\n\n\n\nDescription\n\nline_number\n\n\n\nSpecifies an integer value denoting the header line to be deleted. A\n/line_number/value of zero requests all existing header definitions to\nbe deleted.\n\n\n\n*Examples*\n\nThe following Printline macro requests the header created as line 10 to\nbe deleted.\n\nPL_RESET_HEADER ID=PL,LINE=10\n\nThis example requests all header definitions to be deleted.\n\nPL_RESET_HEADER ID=PL,LINE=0\n\n_*PL_SET_FOOTER - Establish Simple Footers *_\n\nThe PL_SET_FOOTER function defines a footer line to the Printline session.\n\nPL_SET_FOOTER ID=/id_name/ \u00dd,SPEPA=/PL_epa/\u00a8 \u00dd,SPTOKEN=/PL_token/\u00a8\n   ,LINE=/line_number/\n   ,STRING={/string_spec/ | /(string_spec,string_len)/}\nCALLX /PL_epa/,(/PL_token/,&PL_SET_FOOTER,/line_number/,/string_spec/,\n             /string_len/)\n\n\n\n*Parameter *\n\n\n\nDescription\n\nline_number\n\n\n\nSpecifies an integer value denoting this footer line's relative position\namong other footer lines. Footer lines are printed in ascending line\nnumber order. The line numbers need not be contiguous: indeed, it may be\ndesirable to 'insert' footer definitions under program control. If a\nline number specifies an already-defined footer line, that footer line's\ndefinition is replaced. The /line_number/parameter may be coded as an\ninteger or as the address of a fullword.\n\nstring_spec\n\n\n\nSpecifies the character string, including ASA carriage control, for the\nfooter definition. The /string_spec/may be coded as a character literal\nor as the address of a character string.\n\nstring_len\n\n\n\nSpecifies the length of the footer's /string_spec/value. If\n/string_len/is not specified, the PL_SET_FOOTER macro will try to use\nthe length attribute of /string_spec/. The /string_len/value may be\ncoded as an integer or other numeric term, or may refer to a field in\nstorage of /size_length/bytes in length, containing the string's length.\n\n*Examples *\n\nThe following example will define a simple footer line. Since the first\ncharacter of the footer string is a '0', this footer line will always be\ndouble-spaced (i.e. preceded by a blank line). The footer's line number\nis set to 10, for subsequent reference by other PL_SET_FOOTER,\nPL_SET_FORMATTED_FOOTER, and PL_RESET_FOOTER macros.\n\nPL_SET_FOOTER ID=PL,\n          LINE=10,\n          STRING==C\"0 This footer line causes a double-space to occur.\"\n\n_*PL_SET_FORMATTED_FOOTER - Establish Formatted Footers *_\n\nThe PL_SET_FORMATTED_FOOTER function defines a footer line to the\nPrintline session. The footer line will be formatted by the String\nHandler before it is printed, thus allowing variable data to be included\nin report footers.\n\nPL_SET_FORMATTED_FOOTER ID=/id_name/ \u00dd,SPEPA=/PL_epa/\u00a8 \u00dd,SPTOKEN=/PL_token/\u00a8\n   ,LINE=/line_number/\n   ,CONTROL={/format_spec/ | /(fmtspec,fmtlen)/}\n   \u00dd,PAGENUM=/page_offset/\u00a8\n   \u00dd,SOURCE={/source/ | /(source1,source2,...)/}\u00a8\nCALLX /PL_epa/,(/PL_token/,&PL_SET_FORMATTED_FOOTER,/line_number/,/format_spec/,\n             /format_length/,{/pagedisp/,/arguments/})\n\n\n\n*Parameter *\n\n\n\nDescription\n\nline_number\n\n\n\nSpecifies an integer value denoting this footer line's relative position\namong other footer lines. Footer lines are printed in ascending line\nnumber order. The line numbers need not be contiguous: indeed, it may be\ndesirable to 'insert' footer definitions under program control. If a\nline number specifies an already-defined footer line, that footer line's\ndefinition is replaced. The /line_number/parameter may be coded as an\ninteger or as the address of a fullword.\n\nformat_spec\n\n\n\nSpecifies a format specification string, including ASA carriage control,\nfor the footer definition. The /format_spec/may be coded as a character\nliteral or as the address of a character string.\n\nformat_length\n\n\n\nSpecifies the length of the footer's /format_spec/value. If\n/format_length/is not specified, the PL_SET_FORMATTED_FOOTER macro will\ntry to use the length attribute of /format_spec/. The\n/format_length/value may be coded as an integer or other numeric term,\nor may refer to a field in storage of /size_length/bytes in length,\ncontaining the string's length.\n\npage_disp\n\n\n\nSpecifies the displacement into the list of /source/parameters where the\nPrintline service processor will find a page number. For example, a\n/page_disp/value of \"3\" tells Printline that the third /source/parameter\nshould be treated as a page number. Page numbers defined in this way are\nauto-incremented by Printline as page ejects occur.\n\nsource\n\n\n\nSpecifies source values for the String Handler to substitute into the\nformat specification provided by /format_spec/Up to 50 substitution\nvalues may be specified.\n\n\n\n*Examples *\n\nThe following Printline macro will establish a formatted footer line.\nThe definition includes a page number (fullword \"PAGECTR\") which will be\nformatted as the first substitution parameter in the format string. The\nPAGECTR field is also auto-incremented at each page eject.\n\nPL_SET_FORMATTED_FOOTER ID=PL,\n              LINE=10,\n              CONTROL=FORMAT,\n              PAGENUM=1,\n              SOURCE=(PAGECTR,RPTNAME)\n\nPAGECTR  DC   F'0'\nRPTNAME  DC   CL20\"Macneil-Lehrer\"\nFORMAT   DC   C\"0 Page {I}   The {CL20} Report.\"\n\nThe resulting string is printed as part of each subsequent page's footer:\n\n  Page 1     The MacNeil-Lehrer Report.\n\nBecause of the carriage control of '0', this footer line will always be\npreceded by a blank line.\n\n_*PL_SET_FORMATTED_HEADER - Establish Formatted Headers*_\n\nThe PL_SET_FORMATTED_HEADER function defines a header line to the\nPrintline session. The header line will be formatted by the String\nHandler before it is printed, thus allowing variable data to be included\nin report headers.\n\nPL_SET_FORMATTED_HEADER ID=/id_name/ \u00dd,SPEPA=/PL_epa/\u00a8 \u00dd,SPTOKEN=/PL_token/\u00a8\n   ,LINE=/line_number/\n   ,CONTROL={/format_spec/ | /(fmtspec,fmtlen)/}\n   \u00dd,PAGENUM=/page_offset/\u00a8\n   \u00dd,SOURCE={/source | (source1,source2,...)}\u00a8/\nCALLX PL_epa,(PL_token,&PL_SET_FORMATTED_HEADER,line_number,\n             format_spec,format_length,{pagedisp,arguments})\n\n\n\n*Parameter *\n\n\n\nDescription\n\nline_number\n\n\n\nSpecifies an integer value denoting this header line's relative position\namong other header lines. Header lines are printed in ascending line\nnumber order. The line numbers need not be contiguous: indeed, it may be\ndesirable to 'insert' header definitions under program control. If a\nline number specifies an already-defined header line, that header line's\ndefinition is replaced. The line_number parameter may be coded as an\ninteger or as the address of a fullword.\n\nformat_spec\n\n\n\nSpecifies a format specification string, including ASA carriage control,\nfor the header definition. The format_spec may be coded as a character\nliteral or as the address of a character string.\n\nformat_length\n\n\n\nSpecifies the length of the header's format_spec value. If format_length\nis not specified, the PL_SET_FORMATTED_HEADER macro will try to use the\nlength attribute of format_spec. The format_length value may be coded as\nan integer or other numeric term, or may refer to a field in storage of\nsize_length bytes in length, containing the string's length.\n\npage_disp\n\n\n\nSpecifies the displacement into the list of source parameters where the\nPrintline service processor will find a page number. For example, a\npage_disp value of \"3\" tells Printline that the third source parameter\nshould be treated as a page number. Page numbers defined in this way are\nauto-incremented by Printline as page ejects occur.\n\nsource\n\n\n\nSpecifies source values for the String Handler to substitute into the\nformat specification provided by format_spec Up to 50 substitution\nvalues may be specified.\n\n*Examples *\n\nThe following Printline macro will establish a formatted header line.\nThe definition includes a page number (fullword \"PAGECTR\") which will be\nformatted as the first substitution parameter in the format string. The\nPAGECTR field is also auto-incremented at each page eject.\n\nPL_SET_FORMATTED_HEADER ID=PL,\n              LINE=10,\n              control=FORMAT,\n              PAGENUM=1,\n              SOURCE=(PAGECTR,RPTNAME)\n\nPAGECTR  DC   F'0'\nRPTNAME  DC   CL20\"Macneil-Lehrer\"\nFORMAT   DC   C\"1 Page {I}   The {CL20} Report.\"\n\nThe resulting string is printed as part of each subsequent page's header:\n\n  Page 1     The MacNeil-Lehrer Report.\n\nBecause of the carriage control of '1', this header line will always be\nprinted at the top of a new page.\n\n_*PL_SET_HEADER - Establish Simple Headers *_\n\nThe PL_SET_HEADER function defines a header line to the Printline session.\n\nPL_SET_HEADER ID=id_name \u00dd,SPEPA=PL_epa\u00a8 \u00dd,SPTOKEN=PL_token\u00a8\n   ,LINE=line_number\n   ,STRING={string_spec | (string_spec,string_len)}\nCALLX PL_epa,(PL_token,&PL_SET_HEADER,line_number,string_spec,\n              string_len)\n\n\n\n*Parameter *\n\n\n\nDescription\n\nline_number\n\n\n\nSpecifies an integer value denoting this header line's relative position\namong other header lines. Header lines are printed in ascending line\nnumber order. The line numbers need not be contiguous: indeed, it may be\ndesirable to 'insert' header definitions under program control. If a\nline number specifies an already-defined header line, that header line's\ndefinition is replaced. The line_number parameter may be coded as an\ninteger or as the address of a fullword.\n\nstring_spec\n\n\n\nSpecifies the character string, including ASA carriage control, for the\nheader definition. The string_spec may be coded as a character literal\nor as the address of a character string.\n\nstring_len\n\n\n\nSpecifies the length of the header's string_spec value. If string_len is\nnot specified, the PL_SET_HEADER macro will try to use the length\nattribute of string_spec. The string_len value may be coded as an\ninteger or other numeric term, or may refer to a field in storage of\nsize_length bytes in length, containing the string's length.\n\n\n\n*Examples *\n\nThe following example will define a simple header line. Since the first\ncharacter of the header string is a '1', this header line will always\ncause a page eject. The header's line number is set to 10, for\nsubsequent reference by other PL_SET_HEADER, PL_SET_FORMATTED_HEADER,\nand PL_RESET_HEADER macros.\n\nPL_SET_HEADER ID=PL,\n              LINE=10,\n              STRING==C\"1 This header line causes a page eject.\"\n\n_*PL_START - Begin A Printline Session *_\n\nThe PL_START function establishes a new Printline session and returns\nits session identifier in the pl_token parameter. The page size, maximum\nline length and size of fields specifying string lengths are determined\nby the pagesize, maxlinesize and sizelength operands, respectively.\n\nPL_START ID=id_name \u00dd,SPEPA=PL_epa\u00a8 \u00dd,SPTOKEN=PL_token\u00a8\n   \u00dd,ESVA=esva\u00a8\n   ,DDNAME=ddname\n   \u00dd,PAGESIZE={pagesize | *66*}\u00a8\n   \u00dd,MAXLNSZ={maximum_linesize | *133*}\u00a8\n   \u00dd,SIZELENGTH={integer | *2*}\u00a8\n   \u00dd,OPTIONS=(option_list)\u00a8\nCALLX PL_epa,(PL_token,&PL_START,esva,ddname,pagesize,maxlinesize,\n              sizelength,option_byte)\n\n\n\n*Parameter *\n\n\n\nDescription\n\nesva\n\n\n\nSpecifies the label of a fullword in storage that contains the address\nof the Environment Support Vector (ESV) created by the ES_START function.\n\nddname\n\n\n\nSpecifies the DDname that this Printline session will use to write its\noutput. The default DCB attributes are RECFM=VBA,LRECL=maxlinesize,\nBLKSIZE=LRECL+4; however, any DCB attribute combination acceptable to\nthe OS File Handler is acceptable to Printline.\n\npagesize\n\n\n\nSpecifies the number of lines that the report page should contain. This\nvalue is used to determine when Printline should print headers and\nfooters, as well as increment page counters.\n\nmaxlinesize\n\n\n\nSpecifies a field containing the maximum linesize that Printline should\nwrite. This value will become the logical record length of the report\nfile produced. Should a data, header or footer line's length exceed the\nmaxlinesize value, the line will be truncated and printed, and a\ntruncation error will be returned.\n\nsizelength\n\n\n\nAn integer value from 1 and 4 that determines the size, in bytes, of all\nvalues representing string lengths by the String Handler. For example, a\nsizelength value of 4 would cause all lengths returned by the String\nHandler to be 4 bytes in length.\n\noption_list\n\n\n\nA list of additional options for this PrintLine session. If multiple\noption values are specified, they must be enclosed in parentheses. The\nonly option currently supported is FOLD.\n\n  *\n\n    *FOLD*- All output produced by PrintLine should be folded to\n    uppercase. If using the CALLX form to call PL_START, the FOLD option\n    corresponds to a bit setting of X'80' in the option byte.\n\n\n\n*Examples*\n\nThe following PL_START macro will initialize a Printline session.\nInvoking PL_START will cause the following to occur:\n\n  *\n\n    The SPTOKEN value is set to the new Printline session's unique token\n    value.\n\n  *\n\n    Blocksize information from the DD statement referred to by ddname is\n    merged into Printline's report DCB.\n\n  *\n\n    The report file referred to by ddname is opened.\n\n  *\n\n    All headers, footers and data lines are to be converted to uppercase.\n\n    PL_START ID=PL,\n             SPEPNAME=&PRINT_LINE,\n             SPEPA=PWA_PL_ENTRY,\n             SPTOKEN=PWA_PL_TOKEN,\n             ESID=ES,\n             ESVA=PWA_ESVA,\n             SIZELENGTH=4,\n             DDNAME==C'SYSPRINT',\n             OPTIONS=(FOLD)\n\nPWA_PL_ENTRY  DS    F         Entrypoint for Printline\nPWA_PL_TOKEN  DS    F         Unique token for Printline session\nPWA_ESVA      DS    F         Environment Support Vector address\n\nIn this example, the SPEPNAME, SPEPA, SPTOKEN, ESID, ESVA and SIZELENGTH\nparameters are included only for completeness. They may be specified on\nthe PL_ID macro and omitted from the call to PL_START, as follows:\n\n    PL_START ID=PL,\n             DDNAME==C'SYSPRINT'\n\n_*PL_TERMINATE - Terminate A Printline Session *_\n\nThe PL_TERMINATE function concludes the Printline session identified by\nthe pl_token parameter, and releases any resources held by the Printline\nservice processor.\n\nPL_TERMINATE ID=id_name \u00dd,SPEPA=PL_epa\u00a8 \u00dd,SPTOKEN=PL_token\u00a8\nCALLX PL_epa,(PL_token,&PL_TERMINATE)\n\n*Examples *\n\nThe following PL_TERMINATE macro will cause Printline to close its\nreport file and release any resources that it acquired.\n\nPL_TERMINATE ID=PL\n\n------------------------------------------------------------------------\n\n\n  Chapter 12. String Handler <#ToC_102>\n\nThe String Handler provides common functions for string manipulation,\nincluding formatting functions and data conversions.\n\nApplications use the string handler to convert back and forth between\ntextual and non-textual representations of data, and to manipulate text\nstrings. The most heavily used function of the string handler is the\nST_FORMAT function, which can construct a text string from an arbitrary\nnumber of (text and non-text) parameters. ST_FORMAT is extremely useful\nfor constructing error messages that contain imbedded information.\n\n------------------------------------------------------------------------\n\n\n    Preparing to Use the String Handler <#ToC_103>\n\nThe String Handler operates independently of its execution environment\nand may be used with any Environment Support service processor. Like any\nservice processor, the String Handler must be loaded and started before\nits functions can be used. This process is fully covered in Part 1,\n\"Service Processors User's Guide\" <#HDRPART1> and will not be repeated\nhere.\n\nThe String Handler's service processor identification code is *ST*so:\n\n  *\n\n    the COPY member is SRV*ST*MAC,\n\n  *\n\n    the load module, named by symbol &ST_STRING_HANDLER, is SRV*ST*,\n\n  *\n\n    and the names of all symbols, macros, and conditions begin with the\n    prefix *ST_*.\n\nGlobal String Handler stuff goes here as well as tips on how to make\nbetter use of it.\n\n------------------------------------------------------------------------\n\n\n    Common Parameters <#ToC_104>\n\nSeveral parameters are common to all String Handler function calls.\nThese parameters are listed below: :plist. :pLt.id_name :pLd.specifies\nthe name of a service processor identifier created by the ST_ID macro\nwhich will be used by all other function invocation macros to\nautomatically obtain values for st_epa and st_token. This parameter is\nrequired unless both st_epa and st_token are specified. :pLt.st_epa\n:pLd.a fullword in storage containing the entry point address of the\nString Handler service processor. The value specified by st_epa\noverrides any value obtained from ID=id_name. :pLt.st_token\n:pLd.specifies the label of a fullword in storage that contains the\nvalue (to be) returned by ST_START for the st_token parameter. The value\nspecified by st_token overrides any value obtained from ID=id_name.\n:eplist.\n\n------------------------------------------------------------------------\n\n\n    Complete List of String Handler Return Codes <#ToC_105>\n\nMany return codes can be returned from each function. In the function\ndescriptions later in this chapter, the most common return codes\nreturned by the particular function are documented. The following is a\ncomplete list of String Handler return codes.\n\n\n\n*Return Code *\n\n\n\nSymbol\n\n\n\nDescription\n\n0\n\n\n\nST_SUCCESS\n\n\n\nThe invoked String Handler function performed the requested service\nwithout encountering any problems.\n\n1\n\n\n\nST_INVALID_FUNCTION\n\n\n\nAn invalid FunctionCode (the second parameter in any service processor\nfunction call) was specified.\n\n2\n\n\n\nST_INVALID_SIZELENGTH\n\n\n\nThe value specified for sizelength was not *1*, *2*, *3*, or *4*.\n\n3\n\n\n\nST_TRUNCATED\n\n\n\nThe formatted string was too long to fit into the area specified by\nstring and the only the first string_length characters were used.\nResult_length has been set to the length of the truncated result and is\nequal to string_length.\n\n4\n\n\n\nST_OVERLAP\n\n\n\nThe area referenced by string overlaps in storage with the control\nstring or a source argument. Results are unpredictable because the\noverlap could be detected at any point in the formatting process.\nFormatting was halted immediately and result_length has been set to the\nlength of the formatted string up to the point of error.\n\n5\n\n\n\nST_INTERNAL_ERROR\n\n\n\nThe String Handler detected an error during an internal consistancy\ncheck. This is likely a problem with the String Handler itself and not\nthe program that called it.\n\n6\n\n\n\nST_WRONG_NUMBER_OF_ PARAMETERS\n\n\n\nThe ST_FORMAT function has seven (7) required parameters, and\nST_FORMAT2has nine (9) required parameters. Less than the required\nnumber of parameters were coded.\n\n7\n\n\n\nST_INVALID_SOURCE_LENGTH\n\n\n\nThe length of a source argument, as specified with the format specifier\n*L*/length/was outside the supported range of lengths for that\nargument's type. See for more information.\n\n8\n\n\n\nST_INVALID_SOURCE_FORMAT\n\n\n\nThe text in /string/does not conform to the required format, and could\nnot be converted to an integer.\n\n9\n\n\n\nST_MAGNITUDE\n\n\n\nST_FORMAT: the length of a source argument, as specified with the format\nspecifier *L*/length/was too large to represent as a fullword signed\nbinary integer.\n\n\nST_STRING_TO_INTEGER: the value represented by the digits in /string/is\ntoo large to be contained in a fullword binary value. It must be between\n-2147483648 and 2147483647.\n\n10\n\n\n\nST_FORMAT_COLUMN_TOO_LARGE\n\n\n\nThe specified column position was beyond the end of the area referenced\nby /string/. That is, it was larger than the value of /string_length/.\n\n11\n\n\n\nST_FORMAT_COLUMN_TOO_SMALL\n\n\n\nThe specified column position was negative.\n\n12\n\n\n\nST_FORMAT_LENGTH_TOO_LARGE\n\n\n\nThe length specified in a format specification was larger than the\nmaximum allowed length for that type.\n\n13\n\n\n\nST_FORMAT_LENGTH_TOO_SMALL\n\n\n\nThe length specified in a format specification was smaller than the\nminimum allowed length for that type.\n\n14\n\n\n\nST_FORMAT_PRECISION_ TOO_SMALL\n\n\n\nThe precision specified in a format specification was negative or zero.\nIt must be positive.\n\n15\n\n\n\nST_FORMAT_MISSING_ARGUMENT\n\n\n\nThe format specifications in the control string referenced more\n/arguments/than were present.\n\n16\n\n\n\nST_FORMAT_MISSING_ COLUMN_VALUE\n\n\n\nA format specification contained a relative column (@+ or @-), with no\ncolumn number or question mark.\n\n17\n\n\n\nST_FORMAT_MISSING_ LENGTH_VALUE\n\n\n\nA format specification contained the *L*of the *L*/length/item, but the\n/length/part (an integer or question mark) was not specified.\n\n18\n\n\n\nST_FORMAT_MISSING_ PRECISION_VALUE\n\n\n\nA format specification contained the *.*of the *.*/precision/item, but\nthe /precision/part (an integer or question mark) was not specified.\n\n19\n\n\n\nST_FORMAT_TYPE_REQUIRED\n\n\n\nA format specification contained one or more items associated with the\n/type/item, but no /type/was specified.\n\n20\n\n\n\nST_FORMAT_SPEC_EMPTY\n\n\n\nA format specification contained no items within the enclosing braces.\n\n21\n\n\n\nST_FORMAT_SPEC_NOT_ENDED\n\n\n\nThe closing brace was not present for a format specification. Check the\n/control_length/parameter to insure that it was correct.\n\n22\n\n\n\nST_FORMAT_UNSUPPORTED_ KEYWORD\n\n\n\nA keyword was specified that is not in Table 8 <#TBLFSKWDS>.\n\n23\n\n\n\nST_FORMAT_UNSUPPORTED_TYPE\n\n\n\nA /type/was specified that is not in Table 6 <#TBLFSTCDS>.\n\n24\n\n\n\nST_FORMAT_UNSUPPORTED_ITEM\n\n\n\nAn item was specified that did not conform to the syntax for format\nspecifications described on page reference #3 <#SPTFSSYNTX>.\n\n25\n\n\n\nST_FORMAT_PAD_TYPE_CONFLICT\n\n\n\nA leading zero was specified with /width/, but the /type/item specified\na non-numeric /argument/.\n\n26\n\n\n\nST_FORMAT_FILL_TOO_LONG\n\n\n\nThe fill pattern supplied within an ST_FORMAT format-specification was\nlonger than 256 characters, the maximum length permitted for fill patterns.\n\n\n------------------------------------------------------------------------\n\n\n    String Handler Service Processor Functions <#ToC_106>\n\nThe remaining sections of this chapter describe all functions provided\nby the String Handler service processor, arranged in alphabetical order.\nEach function's description begins on a new page, and the name of the\nfunction being described appears in the top outside corner of every\npage. :func id=stfrmt name='ST_FORMAT'.Build a Text String from\nArbitrary Parameters\n\nThe ST_FORMAT function constructs a formatted string from an arbitrary\nnumber of input sources and places it in the area specified by the\n/string/parameter. A control string, consisting of ordinary text and\nimbedded /format specifications/, is used to guide the formatting\nprocess. The resulting string will appear similar to the control string,\nexcept that the format specifications will be replaced with the data\nthey indicate.\n\nThis function is most useful for formatting messages. Contextual\ninformation can easily be included in a message to assist the user in\ndiagnosing and correcting problems. Consider the following message,\nwhich is produced by the FI_START function of the File Handler:\n\n/(Ref #2.)/\n'FI00104E Member {CL8} not in {CL? TRIM}.',MEMBER,DSNAME,DSNAME_LENGTH\n\nWhen the File Handler invokes ST_FORMAT, the member name and dataset\nname will be inserted into the message text itself to produce a\nformatted message such as the following:\n\n'FI00104E Member LABELS not in HENRY.ISPF.SOURCE.'\nST_FORMAT ID=/id_name/ \u00dd,SPEPA=/st_epa/\u00a8 \u00dd,SPTOKEN=/st_token/\u00a8\n   ,CONTROL={/control/ | (/control/,/control_length/)}\n  \u00dd,SOURCE=(/argument/{,/argument/}) | SOURCELIST=(/arglist/,/argcount/)\u00a8\n  \u00dd,STRING={/string/ | (/string/,/string_length/)}\u00a8\n  \u00dd,RESULTLEN=/result_length/\u00a8\nCALLX /st_epa/,(/st_token/,&ST_FORMAT,/string/,/string_length/,\n              \u00dd/result_length/\u00a8,\n              /control/,/control_length/{,/argument/})\n- or -\nCALLX /st_epa/,(/st_token/,&ST_FORMAT2,/string/,/string_length/,\n              \u00dd/result_length/\u00a8,\n              /control/,/control_length/,/arglist/,/argcount/)\n\n\n\n*Parameter *\n\n\n\nDescription\n\ncontrol\n\n\n\nspecifies the label of a string containing information to guide the\nformatting process. See the section below, , for how this string should\nbe specified.\n\ncontrol_length\n\n\n\nspecifies the label of a signed binary integer indicating the length of\nthe string identified by the /control/parameter. The\n/control_length/parameter may be from one to four bytes in length, as\ndetermined by the /sizelength/parameter of the ST_START function.\n\n\n*Note: *The macro form of ST_FORMAT will attempt to generate a value for\n/control_length/automatically if it is not specified. In order to\ngenerate the right value, however, /sizelength/must have previously been\nspecified on the ST_ID macro.\n\nstring\n\n\n\nspecifies the area of storage in which the formatted string will be\nconstructed.\n\nstring_length\n\n\n\nspecifies the label of a signed binary integer indicating the length of\nthe area referenced by /string/. This parameter may be from one to four\nbytes in length, as determined by the /sizelength/parameter of the\nST_START function.\n\n\n*Note: *The macro form of ST_FORMAT will attempt to generate a value for\n/string_length/automatically if it is not specified. In order to\ngenerate the right value, however, /sizelength/must have previously been\nspecified on the ST_ID macro.\n\nresult_length\n\n\n\nspecifies a field into which a signed binary integer containing the\nlength of the formatted string will be placed. The\n/result_length/parameter may be from one to four bytes in length, as\ndetermined by the /sizelength/parameter of the ST_START function.\n\n{argument}\n\n\n\nValues in storage that are referenced by format specifications imbedded\nin the /control/string. The number of /argument/s required, as well as\ntheir data formats, is determined by the format specifications imbedded\nin the control string.\n\narglist\n\n\n\nReferences a separate parameter list that contains the /argument/s\nreferenced by format specifications. This parameter requires the\n/argcount/parameter also, and is only used with the ST_FORMAT2 interface\nto the format function. :pLt.argcount :pLd.Specifies a signed fullword\nin storage containing the number of /argument/s contained in /arglist/.\n\n\n\n*Specifying Control Strings *\n\nThe /control/parameter is a character string consisting of normal text\nintermixed with /format specifications/that acts as a template to guide\nthe formatting process. The control string below, for example, contains\ntwo format specifications:\n\n'FI00104E Member {CL8} not in {CL? TRIM}.'\n\nAs ST_FORMAT scans /control/from left to right, it builds a formatted\nstring in the area referenced by the /string/parameter. Normal text is\ncopied directly to the /string/area. When a format specification is\nencountered, ST_FORMAT suspends the copying of normal text and performs\nthe operation indicated by the format specification. It then resumes its\nscan of the control string following the format specification.\n\nEach format specification may call for values to be taken from one or\nmore /argument/s, which are always referenced in consecutive order:\nfirst, second, third, etc. The value of an /argument/is never modified\nby ST_FORMAT, although a formatted copy of that value may be placed in\n/string/. A format specification is distinguished from surrounding text\nin the /control/string with braces (*{ }*) and has one of the following\nforms, where brackets (\u00dd \u00a8) indicate optional items. /(Ref #3.)/\n\n    *{*\u00dd*0*\u00a8\u00dd/width/\u00a8\u00dd*.*/precision/\u00a8\u00dd*@*\u00dd/column/\u00a8\u00a8/type/\u00dd*L*/length/\u00a8\u00dd\n    /keyword.../\u00a8*}*\n    *{@*\u00dd/column/\u00a8*}*\n    *{{*\n\nIn the syntax above, /type/is a single letter that references an\nassociated source /argument/, and \u00dd/keyword.../\u00a8 is a list of words that\nprovide optional formatting information.\n\n/Arguments/are taken in the same order as the items in a format\nspecification that reference them (i.e. /width/first, then /precision/,\n/column/, /type/, and /length/).\n\n/Width/, /precision/, /column/, and /length/are all integers that can be\ncoded as either a sequence of digits or as a question mark (*?*) to\nreference the value contained in an associated /argument/. When a\nquestion mark is used, the referenced /argument/must be a signed binary\ninteger that is /sizelength/bytes in length (see the\n/sizelength/parameter of ST_START on page reference #5 <#SPTSIZELEN>).\nOptionally, /sizelength/can be overridden for a given /argument/by\nsuffixing the question mark with an integer value of 1, 2, 3, or 4. For\nexample, {CL?2} indicates that the length /argument/is a halfword value\n(the 2 following the question mark) regardless of the value originally\nspecified for /sizelength/. The override applies only to the one\n/argument/--it does not change the /sizelength/parameter's value.\n\nNo blanks can appear within a format specification, except between\nkeywords. If any part of a format specification is invalid, the length\nof the text formatted so far will be returned in /result_length/and a\nreturn code indicating the problem will be set. The discussion below\ncovers the basics of format specifications and describes the general\noperation of ST_FORMAT with respect to the control string. :fh4.Type\n\nIn practice, most format specifications are fairly simple because almost\neverything is optional (as indicated by all the brackets). In fact, the\nlarge majority contain only /type/and perhaps one other item. As a\ngeneral rule, format specifications are built around /type/, with the\nremaining items being used to supply additional information.\n\n/Type/is a single letter that denotes both a source argument's layout\nand the way it should be formatted. The presence of /type/in a format\nspecification indicates that there is an associated /argument/that\nshould be formatted in a certain way, and that the format specification\nitself is acting as a placeholder to indicate the where the formatted\ntext should be placed within /string/. For example, the control string\n\n'The character {C} was encountered {I} times.'\n\ncontains two format specifications, each of which only specifies /type/.\nThis control string requires two associated /argument/s, one for each\nformat specification. The format specification {C} indicates that a\nsingle character should be taken from the first /argument/and placed in\n/string/following 'The character '. Similarly, {I} indicates that a\ntextual representation of the four byte binary integer referenced by the\nsecond /argument/should placed in /string/following ' was encountered '.\nThe resulting string would look like this:\n\n'The character Z was encountered 437 times.'\n\nThe supported values for /type/are listed below. The default, minimum,\nand maximum lengths for /argument/s of each type are listed in Table 7\n<#TBLFSLNS>.\n\n*Table 6. Format Specification Types*\n\nType\n\n\n\nDescription\n\nA\n\n\n\nFormat an unsigned binary integer as a hexadecimal number. For example,\nif a four byte integer containing the decimal value 2375373 were\nformatted with this type, it would appear as 243ECD.\n\nB\n\n\n\nFormat one or more characters (arbitrary byte values) as a sequence of\nbinary digits. Example: the EBCDIC character 'A' would format as\n11000001 (hexadecimal 'C1').\n\nC\n\n\n\nFormat one or more characters (arbitrary byte values) asis. That is, the\ncharacter(s) referenced by the associated /argument/ should be copied\nwithout modification to the appropriate position in /string/.\n\nI\n\n\n\nFormat a signed binary integer as a decimal number. Example: -32768.\n\nU\n\n\n\nFormat an unsigned binary integer as a decimal number. Example: 65535.\n\nX\n\n\n\nFormat one or more characters (arbitrary byte values) as a sequence of\nhexadecimal digits. Example: the EBCDIC character 'A' would format as C1\n(binary 11000001).\n\n\n\nEach /argument/referenced by /type/has a default length. For example,\nintegers referenced with the format specification {I} are assumed to be\nfour bytes in length. Explicit lengths can be specified in format\nspecifications with the *L*/length/item. For example, the format\nspecification {IL2} references a two byte signed integer.\n\n/Length/may be specified with a number coded directly in the format\nspecification or, if the actual length is not known until execution\ntime, as a question mark (*?*) to indicate that length of the\n/argument/to be formatted is contained in yet another /argument/. For\nexample, suppose a word of some unknown length was desired instead of a\nsingle character and the number of occurrances was held in a two byte\nvalue. The new control string would look like the following:\n\n'The word {CL?} was encountered {IL2} times.'\n\nand would produce a result that looked like:\n\n'The word SUPERCALAFRAGALISTIC was encountered 138 times.'\n\nThis control string would require /three/arguments: one for the\ncharacter string to insert, one for its length, and one for the number.\nThe arguments would have to be specified in that order, and the size of\nthe integer containing the word's length would be determined by the\n/sizelength/parameter of the ST_START function.\n\nEach type of data has minimum, maximum, and default source lengths\n(specified in bytes):\n\n*Table 7. Format Specification Source Lengths*\n\nType\n\n\n\nDefault\n\n\n\nMinimum\n\n\n\nMaximum\n\nA\n\n\n\n4\n\n\n\n1\n\n\n\n4\n\nB\n\n\n\n1\n\n\n\n1\n\n\n\n256\n\nC\n\n\n\n1\n\n\n\n0\n\n\n\n65535\n\nI\n\n\n\n4\n\n\n\n1\n\n\n\n4\n\nU\n\n\n\n4\n\n\n\n1\n\n\n\n4\n\nX\n\n\n\n1\n\n\n\n0\n\n\n\n65535\n\n\n\n/Width/is used to specify the minimum amount of space that should be\nreserved in /string/for formatted text. More space will be used if\nneeded, but if the text is shorter than /width/, it will be padded with\nblanks (to the right for character types and to the left for numeric\ntypes). Like /length/, /width/may be specified as a number or a question\nmark. Expanding on the example used so far, the following control string\nmight be used:\n\n'The word {15CL?} was encountered {5IL2} times.'\n\nwhich, if used several times with different values, would produce\nresults that looked like:\n\n'The word SUPERCALAFRAGALISTIC was encountered   138 times.'\n'The word HELLO           was encountered    27 times.'\n'The word GOODBYE         was encountered    14 times.'\n'The word CALIFORNIA      was encountered     0 times.'\n\nAn additional feature of /width/is available for numeric data types\nonly: if a /width/is coded with a leading zero, the number will be\nformatted with leading zeros. For example, the control string\n\n'The word {15CL?} was encountered {05IL2} times.'\n\nwould produce these results instead:\n\n'The word SUPERCALAFRAGALISTIC was encountered 00138 times.'\n'The word HELLO           was encountered 00027 times.'\n'The word GOODBYE         was encountered 00014 times.'\n'The word CALIFORNIA      was encountered 00000 times.'\n\n*Precision*\n\n*.*/Precision/can also be specified as a number or a question mark, but\nhas a different meaning than /width/. For non-numeric data,\n/precision/specifies the /maximum/amount of space that the formatted\ntext may use; if the text is longer, only the first\n/precision/characters will be placed in /string/. In the example above,\nif a /precision/of 15 were added to the first format specification:\n\n'The word {15.15CL?} was encountered {05IL2} times.'\n\nit would have produced\n\n'The word SUPERCALAFRAGAL was encountered 00138 times.'\n'The word HELLO           was encountered 00027 times.'\n'The word GOODBYE         was encountered 00014 times.'\n'The word CALIFORNIA      was encountered 00000 times.'\n\n*.*/Precision/currently has no meaning for numeric data, but when real\nnumbers (fixed point or floating point) are supported, it will specify\nthe number of significant digits to the right of the decimal mark.\n\n*Column *\n\nDuring the process of formatting, ST_FORMAT maintains a pointer to the\ncurrent column position within /string/. This column position, denoted\nby the symbol *@*, is initially set to 1. Whenever text (from the\ncontrol string itself or from a formatting operation) is added to\n/string/it is placed in the position indicated by *@*. After the text\nhas been added, *@*is automatically updated to the column in\n/string/immediately following the new text. This automatic operation\nproduces the expected results: the resulting string looks like the\noriginal control string except that format specifications (acting as\nplaceholders) have been replaced with formatted text. The column\nposition can also be adjusted with format specifications, giving\napplication programs the ability to control the exact placement of text\nwithin the formatted string.\n\n*@*\u00dd/Column/\u00a8 sets the value of *@*to a new column position, which can\nbe anywhere in the /string/area (even beyond the end of all text\nformatted so far). It may be specified alone or as part of a format\nspecification containing /type/. In both cases, the value of *@*is set\nbefore any text movement occurs. The new position specified by\n/column/can be an actual column number, or it can be a question mark\nthat indicates the value for column is contained in an /argument/.\nEither way, the number or question mark can be prefixed by a plus (*+*)\nor minus (*-*) sign to indicate that the new column is relative to the\ncurrent one.\n\nST_FORMAT also maintains a /high-water/mark, which is always equal to\nthe highest column position reached during formatting. If *@*is\nspecified without a column number the current position is set to the\nhigh-water mark, where new text will be appended to the string being\nformatted.\n\nWhen formatting is complete, ST_FORMAT reduces the high-water mark by\none column to produce /result_length/. This final value is normally\nequal to the column position of the last character placed in /string/and\nis considered to be the final length of the formatted text. However,\nsince format specifications can jump to any column position, portions of\nthe /string/area may have been skipped over and left untouched by\nST_FORMAT This is the way ST_FORMAT was designed to work, but it may\nproduce unexpected results if uninitialized portions of /string/are\nskipped over during formatting. :fh4.Keywords\n\n/Keyword/s are used to specify formatting options that cannot really be\nspecified any other way. The control string below, for example, contains\na format specifcation that uses the keywords CAPS and CENTER to place\ntext in the center of a line that will be printed as a page header.\n\n'{?CL? CAPS CENTER}'\n\nIf ST_FORMAT were invoked with this control string and the three\narguments (80,'Year to Date Totals',19), the following line would result:\n\n                           YEAR TO DATE TOTALS\n\nThe available keywords are listed in Table 8 <#TBLFSKWDS> below. Some of\nthese keywords can only be used with specific /type/s, as indicated in\ntheir description.\n\n*Table 8. Format Specification Keywords*\n\nKeyword\n\n\n\nDescription\n\nCAPS\n\n\n\nFold lowercase letters to capitals. This keyword only applies to type *C*.\n\nC1ST\n\n\n\nCapitalize the first letter of the formatted argument. This keyword only\napplies to type *C*.\n\nCENTER\n\n\n\nCenter the formatted argument in the field, padding it to the left and\nright with blanks.\n\nFILL or F\n\n\n\nWhen the formatted argument does not extend to the end of the format\nfield, format the remainder of the field using a fill pattern.\n\nZero or more copies of the fill pattern are concatenated and placed such\nthat the result ends at the final position of the format field. If the\nspace to be filled is not an exact multple of the size of the fill\npattern, one or more blanks will be used /before/ filling to make up the\nremainder. The default fill pattern is \" .\". Fill patterns may be\nspecified in parenthesis following the FILL keyword as:\n\n  *\n\n    A string enclosed in quotes, optionally prefixed with *C*. Either\n    single or double quotes may be used to delimit string, so long as\n    they are matched properly. If a quote of the same type as the\n    delimiter is used within the string, two quotes must be used to\n    represent one. Examples: F(\" -\") and FILL(C' -').\n\n  *\n\n    A hexadecimal string. Examples: FILL(X\"4060\"), F(X\"00\"), and F(X'9F').\n\n  *\n\n    A question mark (referencing the next supplied argument), optionally\n    followed by *L* and a length (either an integer or a question mark\n    to refer to the argument following the fill pattern argument). If no\n    length is supplied, the default length is one. Examples: F(?),\n    FILL(?L2), and FILL(?L?).\n\n  *\n\n    If the supplied fill pattern does not fit any of the above types,\n    the entire sequence of characters between parentheses will be\n    assumed to be the intended fill pattern. Examples: FILL( .) and F( -).\n\nThe maximum length for a fill pattern from any source is 256 bytes. A\nzero-length fill pattern is replaced by the default: \" .\".\n\nLEFT\n\n\n\nLeft-justify the formatted argument in the field, padding it with blanks\nif necessary in order to fill in the field.\n\nRELATIVE\n\n\n\nFor integers only: append the resulting formatted integer with the\ncharacters *st*, *nd*, *rd*, or *th* to indicate a relative number (e.g.\n1st, 2nd, 3rd, 4th, etc).\n\nRIGHT\n\n\n\nRight-justify the formatted argument in the field, prefixing it with\nblanks or zeros if necessary in order to fill in the field.\n\nTRIM or T\n\n\n\nRemove trailing blanks from the formatted data before performing any\njustification. This keyword only applies to type *C*.\n\nSince braces are used to distinguish format specifications from\nsurrounding text, an opening brace cannot be coded as part of the normal\ntext. The format specification *{{*provides a way around this problem:\nit is treated as if it were a single *&lbr*in normal text. For example,\nthe control string\n\nThis is a control string containing {{ braces }.\n\nwould result in the following formatted string:\n\nThis is a control string containing { braces }.\n\n*Examples *\n\nThe examples below are all coded using the macro interface to the\nST_FORMAT function. They assume that instructions similar to the\nfollowing have been executed to provide default values for the STRING,\nRESULTLEN, and SIZELENGTH keywords.\n\nES_ID ID=ES,SPEPNAME=&ES_MVS_ENVIRONMENT_SUPPORT\n      ST_ID ID=ST,SPEPNAME=&STRING_HANDLER,STRING=LINE,            +\n            RESULTLEN=LINE_LEN,SIZELENGTH=2\n*\n      ES_MVS_LOAD    ID=ES               Load Environment Support.\n      ES_START       ID=ES               Start Environment Support.\n      ES_LOAD_MODULE ID=ES,SPID=ST       Load the String Handler.\n      ST_START       ID=ST               Start the String Handler.\n*\n       *...... ST_FORMAT examples go here ..... *\n*\n            PWA\nLINE_LEN    DS    F                Length of string within LINE.\nLINE        DS    CL80             String returned by ST_FORMAT.\n            ENDPWA\n\nTranslated to call statements, each of the formatting examples would\nlook something like this:\n\nCALL ST_EPA,(ST_TOKEN,&ST_FORMAT,LINE,=AL2(L'LINE),LINE_LEN, ... )\n\n/*Example 1: */  This example uses the address (A) type to display a\ndump of the current (or saved) contents of all sixteen general registers.\n\n STM                R0,R15,REGS    Save all registers in storage.\n ST_FORMAT          ID=ST,CONTROL=REG_LIST,SOURCE=('REGS',0,7,REGS)\n ES_DISPLAY_MESSAGE ID=ES,MESSAGE=(LINE,LINE_LEN)\n ST_FORMAT          ID=ST,CONTROL=REG_LIST,SOURCE=('    ',8,15,REGS+(7*4))\n ES_DISPLAY_MESSAGE ID=ES,MESSAGE=(LINE,LINE_LEN)\n .\n .\n .\nREGS      DS  16F          <--- Registers 0-15 saved here.\nREG_LIST  DC C'{CL4} {1A}-{1A}: {08A} {08A} {08A} {08A} {08A} {08A} {08A} {08A}'\n\nwould produce output that looks like the following:\n\nREGS 0-7:0000DEB4 0000002C 0000DEB4 0000002C 00000018 007D5540 02729FEC\n     8-F:0000DED8 0000002C 0272EDE4 0000DE8C 0272DDF8 00011818 8272EE20 0272EDE4\n\n/*Example 2: */  This example uses the FILL keyword to demonstrate how a\nreport might use fill patterns to assist in lining up values to names.\nThe three ST_FORMAT statements below:\n\n ST_FORMAT  ID=ST,CONTROL=LINE_CONTROL,\n                  SOURCE=('NAME',4,PWA_NAME,=A(L'PWA_NAME))\n ES_DISPLAY_MESSAGE ID=ES,MESSAGE=(LINE,LINE_LEN)\n ST_FORMAT  ID=ST,CONTROL='{25CL? FILL(C\" .\")} {CL?}',\n                  SOURCE=('STREET ADDR',11,PWA_STREET,=A(L'PWA_STREET))\n ES_DISPLAY_MESSAGE ID=ES,MESSAGE=(LINE,LINE_LEN)\n ST_FORMAT  ID=ST,CONTROL='{25CL? FILL(C\" .\")} {CL?}',\n                  SOURCE=('CITY & STATE',12,PWA_CITYST,=A(L'PWA_CITYST))\n ES_DISPLAY_MESSAGE ID=ES,MESSAGE=(LINE,LINE_LEN)\n .\n .\n .\nLINE_CONTROL  DC  C'{25CL? FILL(C\" .\")} {CL?}'\n\nmight produce the lines:\n\nNAME  . . . . . . . . . . Donald Duck\nSTREET ADDR . . . . . . . 132 Mallard Lane\nCITY & STATE  . . . . . . Drake City, D.Q.\n\n_*ST_ID - Establish Default String Handler Values *_\n\nThe ST_ID macro is used to establish default values for use by other\nString Handler macros, which may access those values through a unique\nidentifier, /id_name/, specified by the user. When allowed to generate\ndefault values, this macro will create Program Work Area (PWA) storage\nfor /st_epa/and /st_token/. These values, whether generated by the macro\nor provided by the user, are accessable from all other String Handler\nmacros via the ID=/id_name/parameter.\n\nST_ID ID=/id_name/\n  \u00dd,SPEPNAME=/st_epname/\u00a8\n  \u00dd,SPEPA=/st_epa/\u00a8\n  \u00dd,SPTOKEN=/st_token/\u00a8\n  \u00dd,ESID=/esid_name/\u00a8\n  \u00dd,ESVA=/esva/\u00a8\n  \u00dd,SIZELENGTH=/sizelength/\u00a8\n  \u00dd,STRING={/string/ | (/string/,/string_length/)}\u00a8\n  \u00dd,RESULTLEN=/result_length/\u00a8\n\n*Parameter *\n\n\n\nDescription\n\nid_name\n\n\n\nthe identifier to assign to the service processor identifier (SPID)\nbeing established. This name must be unique for all service processor\nidentifiers.\n\nst_epname\n\n\n\nthe entry point name of the String Handler service processor module\nbeing used. This value defaults to 'SRVST '.\n\nst_epa\n\n\n\na fullword that will contain the entry point address of the String\nHandler service processor, after it has been loaded into storage.\n\nst_token\n\n\n\na fullword that will contain a unique value, assigned by the ST_START\nfunction. This value must be used for all String Handler function calls.\n\nesid_name\n\n\n\nthe name of a service processor identifier, created by the ES_ID macro,\nwhich will be used by the ST_ID macro to automatically obtain the value\nfor esv (see below).\n\nesva\n\n\n\nspecifies the label of a fullword in storage that contains (or will\ncontain) the address of the Environment Support Vector (ESV) created by\nthe ES_START function.\n\nsizelength\n\n\n\nIf specified, /sizelength/supplies a default value for the ST_START\nfunction. Refer to for a full description of this parameter.\n\nstring | string_length, result_length\n\n\n\nIf specified, these parameters supply default values for like-named\nparameters of other String Handler function macros. For example, if\n/result_length/were specified on the ST_ID instruction but not on a\nsubsequent ST_INTEGER_TO_STRING instruction, the default value would be\nused.\n\n\n      Example 1\n\nST_ID ID=ES,SPEPNAME=&STRING_HANDLER\n\n_*ST_INTEGER_TO_STRING - Convert Binary Integer to String*_\n\nThe ST_INTEGER_TO_STRING function produces a string that is equal to the\ntextual representation of a fullword signed binary integer. The result\nwill be a string of one or more digits with leading zeros removed,\nprefixed with a minus sign (*-*) if the integer is negative.\n\nST_INTEGER_TO_STRING ID=/id_name/ \u00dd,SPEPA=/st_epa/\u00a8 \u00dd,SPTOKEN=/st_token/\u00a8\n   ,INTEGER=/integer/\n   ,STRING={/string/ | (/string/,/string_length/)}\n   ,RESULTLEN=/result_length/\nCALLX /st_epa/,(/st_token/,&ST_INTEGER_TO_STRING,/integer/,/string/,\n              /string_length/,/result_length/)\n\n\n\n*Parameter *\n\n\n\nDescription\n\ninteger\n\n\n\nspecifies the label of a fullword in storage containing a signed binary\ninteger in two's complement format.\n\nstring\n\n\n\nspecifies the label of an area in storage where a string containing the\ntextual equivalent of the value in /integer/should be placed.\n\nstring_length\n\n\n\nspecifies the label of a signed binary integer equal to the length of\nthe storage indicated by the /string/parameter. The /stringlen/parameter\nmay be from one to four bytes in length, as determined by the\n/sizelength/parameter of the ST_START function.\n\n\n*Note: *The macro form of ST_INTEGER_TO_STRING will attempt to generate\na value for /string_length/automatically if it is not specified. In\norder to generate the right value, however, /sizelength/must have\npreviously been specified on the ST_ID macro. :pLt.result_length\n:pLd.specifies the label of a fullword in storage in which the\nST_INTEGER_TO_STRING function will place a signed binary integer equal\nto the length of the resulting string.\n\n\n\n_*ST_START - Begin a String Handler Session *_\n\nThe ST_START function establishes a new session with the String Handler\nand returns its session identifier in the /st_token/parameter. The size\n(number of bytes) of the numbers used to specify string lengths to the\nString Handler may be specified with the /sizelength/parameter. Halfword\nlength values are the default, but a session may be established using\nbyte, halfword, three-byte, or fullword length values.\n\nST_START ID=/id_name/ \u00dd,SPEPA=/st_epa/\u00a8 \u00dd,SPTOKEN=/st_token/\u00a8\n  \u00dd,ESVA=/esva/\u00a8\n  \u00dd,SIZELENGTH=/sizelength/\u00a8\nCALLX /st_epa/,(/st_token/,&ST_START,/esva/\u00dd,/sizelength/\u00a8)\n\n\n\n*Parameter *\n\n\n\nDescription\n\nsizelength\n\n\n\nthis parameter is a signed fullword integer that determines the size, in\nbytes, of all values used to represent string lengths in the String\nHandler session being started. All length-values passed to the String\nHandler or returned by the String Handler will be of this size. If, for\nexample, /sizelength/= 2 (the default) then all lengths would be\nrepresented as halfword values.\n\n\nThe macro forms of all String Handler functions will attempt to generate\nvalues for string lengths automatically if they are not specified. In\norder for these macros to generate the right values, however,\n/sizelength/must be specified on the ST_ID macro, and it must be a\nself-defining term. That is, it must be an actual number (i.e. *2*) or a\nreference to a symbolic variable (e.g. *&ST_FULLWORD*) that has been set\nto a numeric value with the assembler SETA directive. The following\nsymbols are available for this purpose: *&ST_BYTE*, *&ST_HALFWORD*,\n*&ST_THREE_BYTE*, and *&ST_FULLWORD*.\n\n:plist. :pLt./(Ref #5.)/:pLd.:eplist.\n\n_*ST_STRING_TO_INTEGER - Convert a String to a Fullword*_\n\nThe ST_STRING_TO_INTEGER function produces a fullword signed binary\ninteger that is equal to the value represented the text string in\nparameter /string/. The input string must contain a sequence of one or\nmore adjacent digits optionally prefixed with a sign character (\"*+*\" or\n\"*-*\"). Any number of blanks may appear before or after the optional\nsign or digit sequence, but not between digits.\n\nST_STRING_TO_INTEGER ID=/id_name/ \u00dd,SPEPA=/st_epa/\u00a8 \u00dd,SPTOKEN=/st_token/\u00a8\n   ,STRING={/string/ | (/string/,/string_length/)}\n   ,INTEGER=/integer/\nCALLX /st_epa/,\n   (/st_token/,&ST_STRING_TO_INTEGER,/string/,/string_length/,/integer/)\n\n\n\n*Parameter *\n\n\n\nDescription\n\ninteger\n\n\n\nspecifies the label of a fullword in storage where a signed binary\ninteger equal to the value represented by /string/will be placed.\n\nstring\n\n\n\na sequence of numeric characters representing an integer value. A\nleading sign character (\"*+*\" or \"*-*\") is optional. Blanks may appear\nat any point in the string /except/between adjacent digits. Example\nstring: ' - 672 '.\n\nstring_length\n\n\n\nspecifies the label of a signed binary integer equal to the length of\nthe storage indicated by the /string/parameter. The\n/string_length/parameter may be from one to four bytes in length, as\ndetermined by the /sizelength/parameter of the ST_START function.\n\n*Note: *The macro form of ST_STRING_TO_INTEGER will attempt to generate\na value for /string_length/automatically if it is not specified. In\norder to generate the right value, however, /sizelength/must have\npreviously been specified on the ST_ID macro.\n\n_*ST_TERMINATE - End a String Handler Session*_\n\nThe ST_TERMINATE function ends a session with the String Handler and\nsets the /st_token/value to zero.\n\nST_TERMINATE ID=/id_name/ \u00dd,SPEPA=/st_epa/\u00a8 \u00dd,SPTOKEN=/st_token/\u00a8\nCALLX /st_epa/,(/st_token/,&ST_TERMINATE)\n\n------------------------------------------------------------------------\n\n\n  Chapter 13. Symbol Manager <#ToC_109>\n\nThe Symbol Manager provides a mechanism for easily and efficiently\nkeeping track of data by name. With the Symbol Manager, data is stored\nand maintained as symbols in a table. Each symbol has two parts: (1) a\n/name/, and (2) a /value/. The /value/portion of a symbol is defined by\nthe application program and contains data to be associated with that\nparticular symbol.\n\nTo use a symbol table, an application first must invoke the SY_START\nfunction. This function will create a new table and initialize it for\nuse. SY_START accepts several optional parameters that can be used to\ntailor various aspects of the symbol table as needed.\n\nOnce SY_START has been used to set up a new symbol table, an application\ncan begin adding symbols to the table and manipulating them. Separate\nfunctions are provided for installing symbols in the table, looking up\nsymbols to see if they exist or to get their values, updating the values\nof symbols, and removing symbols from the table. When an application is\ndone using a table, the SY_TERMINATE function should be used to delete\nthe entire table (including any symbols it may contain).\n\nThere is currently no support within the Symbol Manager for scoping of\nany nature: all symbols in the table must be unique and are accessable\nat any time. If you have a need for scoping, or if you need to maintain\nmultiple sets of symbols, you can still do it by creating multiple\nsymbol tables.\n\nAs many symbol tables as needed may be created and maintained at the\nsame time. A symbol table is identified by /sy_token/, the value\nreturned by SY_START at the time the table was created. By invoking\nSY_START multiple times to create multiple tables, and by keeping track\nof the different /sy_token/values used to identify those tables, you can\nmaintain as many symbol tables as needed.\n\nHint: If you need to manage a hierarchical set of symbol tables, you can\nstore the /sy_token/value for one symbol table in the value of a symbol\nin a different table. For example, a root symbol table may contain a\nsymbol (say for a subroutine) that contains as part of its value the\n/sy_token/value of another symbol table (say for the subroutine's\ninternal symbols).\n\nThe Symbol Manager operates independently of its execution environment\nand may be used with any Environment Support service processor.\n\n\n      Obtaining Symbol Manager Symbols & Macros <#ToC_110>\n\nThe Symbol Manager's symbols and interface macros can be found in the\nassembler copy member SRVSYMAC. This member contains symbols naming the\nSymbol Manager's load module, function codes, return codes, and\nparameter values. It also contains macros for using all of the Symbol\nManager's functions. The following statement or its equivalent should\nappear at the beginning of any program that uses the string handler:\n\n   COPY SRVSYMAC      Obtain the Symbol Manager's symbols & macros.\n\n\n      Common Symbol Manager Parameters <#ToC_111>\n\nSome parameters are general to the Symbol Manager and not specific to\nany function. These parameters include its load module name\n(/sy_epname/), entry point address (/sy_epa/), and token value\n(/sy_token/). The SY_ID macro (see ) can be used to establish defaults\nfor these parameters and associate them with a unique service processor\nidentifier. The identifier may then be supplied on any Symbol Manager\nmacro instruction to refer to the default parameter values.\n\nThe parameters listed below apply to every Symbol Manager function.\n:plist. :pLt.id_name :pLd.specifies the name of a service processor\nidentifier created by the SY_ID macro which will be used by all other\nfunction invocation macros to automatically obtain values for\n/sy_epa/and /sy_token/. This parameter is required on all function\nmacros unless both /sy_epa/and /sy_token/are specified. :pLt.sy_epa\n:pLd.specifies the label of a fullword that contains the entry point\naddress of an already-started Symbol Manager service processor. The\nvalue specified by /sy_epa/overrides any value obtained from\nID=/id_name/. :pLt.sy_token :pLd.specifies the label of a fullword that\ncontains the value returned by SY_START for the /sy_token/parameter. The\nvalue specified by /sy_token/overrides any value obtained from\nID=/id_name/. :eplist.\n\n\n      Identifying the Symbol Manager <#ToC_112>\n\nThe Symbol Manager service processor resides in the load module named by\nthe following symbol definition in copy member SRVSYMAC:\n\n&SYMBOL_MANAGER  SETC  '''SRVSY   '''\n\nThis symbolic name should be used as the service processor entry point\nname for the Symbol Manager as shown in the following SY_ID macro\ninstruction.\n\nSY_ID ID=SY,SPEPNAME=&SYMBOL_MANAGER    Set Symbol Manager Defaults.\n\n\n      Loading the Symbol Manager <#ToC_113>\n\nThe recommended method for loading the Symbol Manager is through\nEnvironment Support's ES_LOAD_MODULE function, as shown in the following\nexample:\n\nES_LOAD_MODULE ID=ES,SPID=SY            Load the Symbol Manager\n\n\n      Complete List of Symbol Manager Return Codes <#ToC_114>\n\nMany return codes can be returned from each function. In the function\ndescriptions later in this chapter, the most common return codes\nreturned by the particular function are documented. The following is a\ncomplete list of Symbol Manager return codes.\n\n\n\n*Return Code *\n\n\n\nSymbol\n\n\n\nDescription\n\n0\n\n\n\nSY_SUCCESS\n\n\n\nThe invoked Symbol Manager function performed the requested service\nwithout encountering any problems.\n\n1\n\n\n\nSY_INVALID_VALUESIZE\n\n\n\nThe value specified for valuesize on the SY_START function was negative.\n\n2\n\n\n\nSY_INVALID_CAPS\n\n\n\nThe value specified for caps on the SY_START function was not equal to\nthe character string 'ON' or 'OFF'.\n\n3\n\n\n\nSY_INVALID_FUNCTION\n\n\n\nAn invalid FunctionCode (the second parameter in any service processor\nfunction call) was specified.\n\n4\n\n\n\nSY_INVALID_TOKEN\n\n\n\nThe value specified for token does not identify any symbol currently in\nthe symbol table.\n\n5\n\n\n\nSY_INVALID_HASHSIZE\n\n\n\nThe value specified for hashsize on the SY_START function was either\nzero, negative, or too large. The symbol manager can process hashsize\nvalues from 1 up to an implementation maximum of 536870911 (hexadecimal\nX\"1FFFFFFF\").\n\n6\n\n\n\nSY_INVALID_MEMINCR\n\n\n\nThe value specified for memincr on the SY_START function was either\nnegative or zero.\n\n7\n\n\n\nSY_INVALID_NUMBER_OF_PARMS\n\n\n\nEither too few parameters were supplied for the function call or too\nmany were supplied. Check the parameter list to ensure that it is right\nfor the function being invoked.\n\n8\n\n\n\nSY_INVALID_LENGTH\n\n\n\nThe value specified for length on the SY_INSTALL or SY_LOOKUP function\nwas either negative or zero.\n\n9\n\n\n\nSY_MEMORY_PROBLEM\n\n\n\nAn error was encountered while attempting to obtain or release storage\nfor symbol table management. The Symbol Manager uses the Memory Manager\nservice processor for these functions, so the error will be in the\nEnvironment Support Debug Information Area.\n\n10\n\n\n\nSY_STORAGE_NOT_AVAILABLE\n\n\n\nNot enough storage was available to create the symbol table (for\nSY_START calls) or to add a new symbol to the table (for SY_INSTALL\ncalls). Since symbol table size is limited only by the total amount of\nmemory available to your program, you must increase your region size to\nget more storage.\n\n11\n\n\n\nSY_SYMBOL_ALREADY_INSTALLED\n\n\n\nThe SY_INSTALL function was called to install a new symbol in the symbol\ntable, but the provided symbol was already there.\n\n12\n\n\n\nSY_SYMBOL_NOT_FOUND\n\n\n\nThe symbol identified by name and length is not in the symbol table.\n\n\n------------------------------------------------------------------------\n\n\n    Symbol Manager Service Processor Functions <#ToC_115>\n\nThe remaining sections of this chapter describe all functions provided\nby the Symbol Manager service processor, arranged in alphabetical order.\nEach function's description begins on a new page, and the name of the\nfunction being described appears in the top outside corner of every\npage. :func name='SY_ID' id=syid.Establish Default Symbol Manager Values\n\nThe SY_ID macro is used to establish default values for use by other\nSymbol Manager macros, which may access those values through a unique\nidentifier, id_name, specified by the user. When allowed to generate\ndefault values, this macro will create Program Work Area (PWA) storage\nfor sy_epa and sy_token. These values, whether generated by the macro or\nprovided by the user, are accessable from all other Symbol Manager\nmacros via the ID=id_name parameter.\n\nSY_ID ID=id_name\n  \u00dd,SPEPNAME=sy_epname\u00a8\n  \u00dd,SPEPA=sy_epa\u00a8\n  \u00dd,SPTOKEN=sy_token\u00a8\n  \u00dd,ESID=esid_name\u00a8\n  \u00dd,ESVA=esva\u00a8\n\n*Parameter *\n\n\n\nDescription\n\nid_name\n\n\n\nthe identifier to assign to the service processor identifier being\nestablished. This name must be unique for all service processor\nidentifier's.\n\nsy_epname\n\n\n\nthe entry point name of the Symbol Manager service processor module that\nis being used.\n\nsy_epa\n\n\n\nspecifies the label of a fullword that will contain the entry point\naddress of the Symbol Manager.\n\nsy_token\n\n\n\nspecifies the label of a fullword that will contain the token assigned\nby the SY_START function of the Symbol Manager.\n\nesid_name\n\n\n\nthe name of a service processor identifier, created by the ES_ID macro,\nwhich will be used by the SY_ID macro to automatically obtain the value\nfor esv (see below).\n\nesva\n\n\n\nspecifies the label of a fullword that contains (or will contain) the\naddress of the Environment Support Vector (ESV) created by the ES_START\nfunction.\n\n\n      Example 1\n\nSY_ID     ID=SY,SPEPNAME=&SYMBOL_MANAGER\n\n_*SY_INSTALL - Install a Symbol in the Symbol Table *_\n\nThe SY_INSTALL function inserts a new symbol into the table identified\nby the sy_token parameter. If the symbol is already in the symbol table,\nSY_INSTALL will not update that symbol's value.\n\nSY_INSTALL ID=id_name \u00dd,SPEPA=sy_epa\u00a8 \u00dd,SPTOKEN=sy_token\u00a8\n   ,NAME={'name' | name | *(name,length)*}\n  \u00dd,TOKEN=token\u00a8\n  \u00dd,VALUE=value\u00a8\nCALLX sy_epa,(sy_token,&SY_INSTALL,name,length,\u00ddtoken\u00a8,\u00ddvalue\u00a8)\n\n\n\n*Parameter *\n\n\n\nDescription\n\nname\n\n\n\nthe name of the symbol to install. If the *CAPS*option is in effect, the\nsymbol will be stored in the table with name converted to uppercase.\n\nlength\n\n\n\na signed binary fullword integer equal to the length of the text\nspecified by name.\n\ntoken\n\n\n\na fullword in which a unique four-byte identifier will be returned for\nthe newly installed symbol. The token must be used for all accesses to\nthe symbol in the future.\n\nvalue\n\n\n\nan application defined area containing the initial value to assign to\nthe symbol. The data referred to by value must be valuesize bytes in\nlength. See the SY_START function for an explanation of the valuesize\nparameter.\n\n_*SY_LOOKUP - Locate a Symbol in the Symbol Table *_\n\nThe SY_LOOKUP function locates the specified symbol in the table\nidentified by the sy_token value and returns its unique four-byte token\nvalue. The token may then be used to identify the symbol for other\nsymbol manager functions.\n\nSY_LOOKUP ID=id_name \u00dd,SPEPA=sy_epa\u00a8 \u00dd,SPTOKEN=sy_token\u00a8\n\n  ,NAME={'name' | name | *(name,length)*}\n  \u00dd,TOKEN=token\u00a8\nCALLX sy_epa,(sy_token,&SY_LOOKUP,name,length,\u00ddtoken\u00a8)\n\n\n\n*Parameter *\n\n\n\nDescription\n\nname\n\n\n\nthe name of the symbol to be located in the symbol table. If the\n*CAPS*option is in effect, the case of the symbol is not important.\n\nlength\n\n\n\nthe length (as a signed fullword integer) of the text pointed to by the\nname parameter.\n\ntoken\n\n\n\na fullword into which the unique token of the located symbol will be\nreturned.\n\n_*SY_OBTAIN_NAME - Obtain a Symbol's Name *_\n\nThe SY_OBTAIN_NAME function returns the address and length of the name\nof the specified symbol.\n\nSY_OBTAIN_NAME ID=id_name \u00dd,SPEPA=sy_epa\u00a8 \u00dd,SPTOKEN=sy_token\u00a8\n  ,TOKEN=tokennameptr\n  ,LENGTH=length\nCALLX sy_epa,(sy_token,&SY_OBTAIN_NAME,token,nameptr,length)\n\n\n\n*Parameter *\n\n\n\nDescription\n\ntoken\n\n\n\na fullword value returned by the token parameter of the SY_INSTALL or\nSY_LOOKUP function.\n\nnameptr\n\n\n\na fullword into which the address of the identified symbol's name will\nbe returned. This address will be of the symbol manager's copy of the\nsymbol's name which may have been converted to all capitals. The\napplication program must not modify this storage in any way!\n\nlength\n\n\n\na fullword into which a signed binary integer equal to the length of the\nspecified symbol's name will be returned.\n\n_*SY_OBTAIN_VALUE - Obtain a Symbol's Value *_\n\nThe SY_OBTAIN_VALUE function returns the current value of the specified\nsymbol.\n\nSY_OBTAIN_VALUE ID=id_name \u00dd,SPEPA=sy_epa\u00a8 \u00dd,SPTOKEN=sy_token\u00a8\n  ,TOKEN=tokenvalue\nCALLX sy_epa,(sy_token,&SY_OBTAIN_VALUE,token,value)\n\n\n\n*Parameter *\n\n\n\nDescription\n\ntoken\n\n\n\na fullword value returned by the token parameter of the SY_INSTALL or\nSY_LOOKUP function.\n\nvalue\n\n\n\nan application defined area into which the current value of the\nspecified symbol will be placed. This area must be valuesize bytes in\nlength. See the SY_START function for an explanation of the valuesize\nparameter.\n\n_*SY_REMOVE - Remove a Symbol from the Symbol Table*_\n\nThe SY_REMOVE function removes a symbol (with its associated value) from\nthe symbol table. The symbol to be deleted must be identified by its token.\n\nSY_REMOVE ID=id_name \u00dd,SPEPA=sy_epa\u00a8 \u00dd,SPTOKEN=sy_token\u00a8\n  ,TOKEN=token\nCALLX sy_epa,(sy_token,&SY_REMOVE,token)\n\n\n\n*Parameter *\n\n\n\nDescription\n\ntoken\n\n\n\nSpecifies the label of a fullword containing the value returned in the\ntoken parameter of the SY_INSTALL or SY_LOOKUP function.\n\n:plist. :pLt.:pLd.:eplist.\n\n_*SY_START - Begin a New Symbol Manager Session*_\n\nThe SY_START function creates a new symbol table and returns its\nidentifier in the sy_token parameter. Optional parameters specify table\ncharacteristics such as the size of the value portion of a symbol and\nwhether searches for symbols are case-sensitive.\n\nSY_START ID=id_name \u00dd,SPEPA=sy_epa\u00a8 \u00dd,SPTOKEN=sy_token\u00a8\n         \u00dd,ESVA=esva\u00a8\n         \u00dd,VALUESIZE={valuesize | :us.0:eus.}\u00a8\n         \u00dd,HASHSIZE={hashsize | :us.101:eus.}\u00a8\n         \u00dd,MEMINCR={memincr | :us.4096:eus.}\u00a8\n         \u00dd,CAPS={*ON*|*:us.OFF:eus.*}\u00a8\nCALLX sy_epa,(sy_token,&SY_START,esva,\u00ddvaluesize\u00a8,\u00ddcaps\u00a8,\u00ddhashsize\u00a8,\n              \u00ddmemincr\u00a8)\n\n\n\n*Parameter *\n\n\n\nDescription\n\nid_name\n\n\n\nspecifies the name of a service processor identifier created by the\nSY_ID macro which will be used by the SY_DELETE macro to automatically\nobtain values for sy_epa and sy_token. This parameter is required unless\nboth sy_epa and sy_token are specified.\n\nsy_epa\n\n\n\nspecifies the label of a fullword that contains the entry point address\nof an already-started Symbol Manager service processor. The value\nspecified by sy_epa overrides any value obtained from ID=id_name.\n\nsy_token\n\n\n\nspecifies the label of a fullword that contains the value returned by\nSY_START for the sy_token parameter. The value specified by sy_token\noverrides any value obtained from ID=id_name.\n\nesva\n\n\n\nspecifies the label of a fullword containing the address of an\nEnvironment Support Vector.\n\nvaluesize\n\n\n\nspecifies the label of a fullword containing the length of the value\nportion of symbols in the table being created. This value defaults to\n*0*, meaning that no information is attached to symbols in the table.\n\ncaps\n\n\n\nspecifies the label of a string equal to either 'ON' or 'OFF', which\nindicates whether or not symbol-table searches should be case-sensitive\n('OFF') or not ('ON').\n\nhashsize\n\n\n\nSpecifies the number of hash-table entries that should be reserved for\nthe symbol table being created. For maximum efficiency, this number\nshould be approximately 80% or more of the maximum number of symbols\nthat will reside in the table at any given time.\n\nmemincr\n\n\n\nThe Symbol Manager uses the Memory Manager to obtain all symbol table\nstorage, which is maintained within a single Memory Manager heap. This\nparameter is passed to the MM_START function when the heap is created,\nand should be large enough to avoid excessive system calls for obtaining\nstorage. An approximate value can be calculated as follows:\n\n 1.\n\n    The size of a symbol table entry is 12+valuesize+avg_length, where\n    avg_length is the average length of a symbol's name.\n\n 2.\n\n    If the maximum number of possible symbols is known, simply calculate\n    the total space they will require and use that.\n\n 3.\n\n    If the maximum number of possible symbols can vary wildly from\n    execution to execution, try to choose a value for memincr that will\n    be large enough to satisfy a majority of cases with a single\n    increment of storage. In cases where more symbols are used, the heap\n    will expand as needed.\n\n_*SY_TERMINATE - End a Symbol Manager Session *_\n\nThe SY_TERMINATE function deletes the symbol table identified by the\nsy_token parameter, automatically deleting all symbols currently\ninstalled and releasing all storage obtained for that symbol table.\n\nSY_TERMINATE ID=id_name \u00dd,SPEPA=sy_epa\u00a8 \u00dd,SPTOKEN=sy_token\u00a8\nCALLX sy_epa,(sy_token,&SY_TERMINATE)\n\n_*SY_UPDATE_VALUE - Replace a Symbol's Value*_\n\nThe SY_UPDATE_VALUE function replaces the value of the specified symbol.\n\nSY_UPDATE_VALUE ID=id_name \u00dd,SPEPA=sy_epa\u00a8 \u00dd,SPTOKEN=sy_token\u00a8\n  ,TOKEN=tokenvalue\nCALLX sy_epa,(sy_token,&SY_UPDATE_VALUE,token,value)\n\n\n*Parameter *\n\n\n\nDescription\n\ntoken\n\n\n\na fullword value returned by the token parameter of the SY_INSTALL or\nSY_LOOKUP function.\n\nvalue\n\n\n\nan application defined area containing the new value to assign to the\nsymbol. The data referred to by value must be valuesize bytes in length.\nSee the SY_START function for an explanation of the valuesize parameter.\n\n\n  Appendix A. Writing A Service Processor <#ToC_116>\n\nTypical programmers will often find that they have to perform certain\ntasks over and over when writing code, such as string manipulation, file\nhandling or date conversion. Usually, such programmers will find, as\nthey talk shop with their colleagues over lunch or a cup of coffee, that\nthey all perform these same tasks, and find them equally repetitive (and\nboring). Many of the existing Service Processors were conceived in this\nmanner, by programmers who were willing to write some set of functions\none last time in a nice package so they could get on with their lives.\n\nThis chapter will describe how to write a service processor, and will\nactually develop a working service processor as an example. The\nconventions which have developed over time will be explained, and the\nphilosophy behind service processors will be presented. It is assumed\nthat the reader is an experienced assembler programmer, and is familiar\nwith the Clemson Structured Macros, as they will be used in the examples.\n\n------------------------------------------------------------------------\n\n\n    Service Processor Conventions <#ToC_117>\n\nThere are several programming conventions that experience has shown to\nwork well for service processors. Many have evolved from \"unwritten\nrules\", while others are based mainly on convenience and common sense.\n\n  *\n\n    *Service processors should always be reentrant.*The Clemson\n    Structured Macros make reentrancy a simple matter. In addition, a\n    service processor can \"remember\" things across calls, since its\n    program workarea is reused. Also, a service processor may be called\n    from an authorized program, in which case reentrancy can provide\n    additional protection and security.\n\n  *\n\n    *Service processors should be able to operate normally whether in an\n    authorized state or not.*For the OS environment, an authorized state\n    generally refers to a program running in supervisor state, a system\n    key, or with APF authorization. Exceptions are those service\n    processors which require some state (such as APF authorization) to\n    perform their function.\n\n  *\n\n    *A service processor should be as efficient as\n    possible.*Assembler-language applications are often written in\n    assembler because of performance requirements. The service processor\n    cannot know this beforehand, so it should always assume that\n    performance is critical to its callers. The use of a performance\n    analysis tool such as STROBE is suggested as a way to optimize\n    routines and find \"hot spots\" in the code during development.\n\n  *\n\n    *Service processors can be called directly, or by using function\n    macros.**Direct calls*generally involve building your own parameter\n    list and coding your own CALL or CALLX, while *function macros*allow\n    you to code parameters as macro keywords. The main advantage of\n    function macros to a service processor's caller is the amount of\n    housekeeping and repetitive coding that is eliminated. The main\n    advantage to the service processor's author is that the use of\n    function macros simplifies the task of documenting the service\n    processor.\n\n  *\n\n    *A service processor should be environment-independent if\n    possible.*This simply means that the service processor should call\n    Environment Support or other environment-dependent service\n    processors to do environment-dependent things, like obtain memory or\n    deal with files. This tends to isolate the service processor from\n    its environment, and also makes it easy to transport to a different\n    environment (for example, from OS to IDMS/DC) as long as\n    environment-dependent routines are available in the new environment.\n\n  *\n\n    *A service processor should avoid abends.*This includes program\n    checks as well as \"unrecoverable\" errors where the programmer\n    assumes that the only thing left to do is terminate the caller's\n    task. If a service processor abends for any reason, it should be\n    considered as a bug unless there's a good excuse (for example, if\n    the checks required to prevent a particular abend would severely\n    impact the service processor's performance). Service processors, as\n    a rule, should make reasonable attempts to check caller-provided\n    parameters for validity: the number of parameters, nonzero addresses\n    for required information, the validity of the service processor's\n    token, and so on.\n\n  *\n\n    *Service processors should return specific return codes for any\n    error and let the caller decide if the situation merits an abend or\n    not.*The service processor environment provides a general debug\n    information area that service processors can save information in:\n    these areas can be stacked (in case one service processor calls\n    another). The debug area can be displayed by the caller using\n    ES_Display_Debug_Info or ES_Display_Debug_Info_And_Abend: a service\n    processor should not take it upon itself to display the debug\n    information.\n\n  *\n\n    *It's OK for a service processor to call other service\n    processors.*If this is done, the service processor should not\n    display its debug information due to another service processor's\n    error, but should save its own debug information instead and return\n    a meaningful error to its caller (which may be yet another service\n    processor). This way, the caller can display the debug information\n    and see a trace of how the error occurred.\n\n  *\n\n    *If a service processor cannot recover from some situation, some\n    method should be used to restrict subsequent calls.*For example,\n    when the OS File Handler cannot create a file as requested, a flag\n    is set that disallows any other call except FI_Terminate.\n\n------------------------------------------------------------------------\n\n\n    The \"Cheap Calculator\" Service Processor <#ToC_118>\n\nThroughout the rest of this chapter, examples will be used to illustrate\naspects of service processor development. Our examples will actually\ndevelop a working service processor, which will emulate a four-function\ncalculator. The \"Cheap Calculator\", or SRVCC service processor, will\nhave five simple functions: Add, Subtract, Multiply, Divide and Clear,\nas well as Start and Terminate. For the sake of brevity, this is a\nreally cheap calculator that can only handle integer arithmetic. The\ncalculator's \"display\" is maintained internally by SRVCC and returned to\nthe caller after each operation: the caller can perform operations on\nthe display, or set it to zero by clearing it.\n\nSRVCC, while simple and small, contains all of the components and\nattributes of a service processor, and can be used as a model for\ndeveloping a more elaborate set of routines.\n\n------------------------------------------------------------------------\n\n\n    Components Of A Service Processor <#ToC_119>\n\n\n      The Service Processor Load Module <#ToC_120>\n\nThe executable copy of the service processor is a load module residing\neither in the system linklist or a load library that the caller must\nreference via STEPLIB. Publicly-available service processors have a\nnaming convention, as follows:\n\n  *\n\n    The load module name begins with \"SRV\".\n\n  *\n\n    The characters \"SRV\" are followed by a two-character identifier\n    (\"CC\" in our example).\n\n  *\n\n    If the service processor is environment-dependent, the remainder of\n    the load module name identifies the environment (for example, \"MVS\"\n    for an MVS-dependent module).\n\nIn MVS/XA, the load module should have the attributes AMODE(31) and\nRMODE(ANY), unless this is not possible for some reason (for example,\nthe service processor might use QSAM, which requires RMODE(24)). The\nservice processor should expect to be called AMODE(31).\n\n\n      The Service Processor Copy Member <#ToC_121>\n\nIt is customary to provide a copy member containing global symbols,\nfunction macro definitions and any other tools that might help the\nprogrammer code up calls to the service processor.\n\n\n        The SRV##ID Macro\n\nThe SRV##ID macro can set or override the EPA, TOKEN and ESVA parameters\nvia global symbols unique for each service processor ID used in a\nprogram. SRV##ID relieves the function macro author of a number of\nprogramming chores. Generally, one would code a SRV##ID SET in the\nservice processor's ID macro to establish these symbols for the rest of\nthe macros, and to generate storage for those fields that aren't\nspecified. Subsequent function macros would issue SRV##ID GET to\nretrieve these symbols.\n\n\n        DEFUCOND Macros\n\nDEFUCOND macros should be defined for each of the service processor's\npossible return codes. These macros should have the same name as the\ncorresponding return code's global symbol. The condition name must be\npreceded with a \"%\" when used in a conditional statement, as shown in\nFigure 18 <#FIGMACDEFX>.\n\n*Figure 18. User-Defined Condition Example* <#FT_FIGMACDEFX>\n\n\n\n    CC_ADD  ID=CC,VALUE=5,DISPLAY=PWA_DISPLAY\n    IF    (TREG,R15,NZ)\n      IF    (%CC_OVERFLOW)\n        CALLSUB OVERFLOW\n      ELSE\n        ERREXIT NAME=CC_ERROR\n      ENDIF\n    ENDIF\n\nUse the SRV##RC macro to actually generate the return code comparison,\nas illustrated in Figure 19 <#FIGMACDEFU>.\n\n*Figure 19. DEFUCOND Macros For SRVCC* <#FT_FIGMACDEFU>\n\n\n\n *---------------------------------------------------------------------*\n * DEFUCOND macros to facilitate checking return codes.\n *---------------------------------------------------------------------*\n    DEFUCOND MACRO=SRV##RC,NAME=CC_INVALID_CC_ID\n    DEFUCOND MACRO=SRV##RC,NAME=CC_INVALID_NUMBER_OF_PARMS\n    DEFUCOND MACRO=SRV##RC,NAME=CC_INVALID_FUNCTION\n    DEFUCOND MACRO=SRV##RC,NAME=CC_OVERFLOW\n    DEFUCOND MACRO=SRV##RC,NAME=CC_PARAMETER_MISSING\n\n\n\n        The ID Macro\n\nThere are a number of parameters that would be coded repeatedly if a\nservice processor was called using normal means (CALL or CALLX). A major\nadvantage of the function macros is that they can be made to \"remember\"\nthis information, and can even generate some of the storage required to\nhold it.\n\nThe ID macro uses the SRV##ID SET macro to establish global symbols for\nthe service processor's session defaults, as shown in Figure 20\n<#FIGMACID>.\n\n*Figure 20. CC_ID Macro For SRVCC* <#FT_FIGMACID>\n\n\n\n *---------------------------------------------------------------------*\n *\n *  CC_ID Macro: Establish default values for a specific service\n *               processor and associate them with the specified ID\n *               name.  The values are stored in the following created\n *               global variables, which are used by the other macros:\n *\n *    Variable Name                     Description\n *    -------------  -----------------------------------------------\n *    #$&ID.$#IDMAC  Name of macro that created the ID: CC_ID.\n *    #$&ID.$#ESID   Service processor's Environment Support ID.\n *    #$&ID.$#EPN    Tag for Service processor's Entry Point Name.\n *    #$&ID.$#EPA    Tag for Service processor's Entry Point Address.\n *    #$&ID.$#TKN    Tag for Service processor's Entry Point Token.\n *\n *---------------------------------------------------------------------*\n          MACRO\n          CC_ID &ID=,&ESVA=,&SPEPNAME=,                                *\n                &SPEPA=,&SPTOKEN=,&ESID=\n .*\n .* Invoke SRV##ID to create globals used by all ID's.\n .*\n          SRV##ID SET,ID=&ID.,IDMAC=CC_ID,                             *\n                ESID=&ESID.,SPEPNAME=&SPEPNAME,                        *\n                SPEPA=&SPEPA,SPTOKEN=&SPTOKEN.\n          MEND\n\n\n        The Function Macros\n\nThe remainder of the function macros, for the most part, will generate\nexecutable code and will call the service processor with appropriate\nparameters for the function desired. The macro itself should perform\nreasonable checks for the presence and validity of parameters, and may\nperform any additional checking or processing required.\n\n\n        Global Symbols\n\nThere are several groups of global symbols used by the service processor\nmacros, the service processor code itself, and/or the program that will\nuse the service processor.\n\n*Symbols Required By SRV##ID:: *  SRV##ID SET will define and set a\nnumber of unique global symbols. The symbols are unique in that each\nsymbol name contains the ID name specified on the service processor's ID\nmacro. Symbols created by SRV##ID SET are only used by SRV##ID GET, and\nthe developer should not be concerned about them.\n\nSRV##ID GET returns the values of these symbols in a series of\nfixed-name symbols to the calling macro. The individual symbols and\ntheir meanings are:\n\n*Table 9. Variables Returned By ##SRVID GET*\n\nKeyword\n\n\n\nGET Returns\n\n\n\nDescription\n\nID\n\n\n\n&#_IDMAC\n\n\n\nThe ID value for this service processor session\n\nIDMAC\n\n\n\n&#_IDMAC\n\n\n\nName of the ID macro that generated this information\n\nESID\n\n\n\n&#_IDESID\n\n\n\nID of the associated Environment Support session\n\nESVA\n\n\n\n&#_IDESVA\n\n\n\nStorage tag containing the ESV address\n\nSPEPNAME\n\n\n\n&#_IDEPN\n\n\n\nService processor's CL8 entry name\n\nSPEPA\n\n\n\n&#_IDEPA\n\n\n\nService processor's entry point address\n\nSPTOKEN\n\n\n\n&#_IDTKN\n\n\n\nStorage tag containing token for this service processor session\n\n\n\n*Function Code And Return Code Symbols*\n\nAll function codes and return codes should have global symbols assigned\nto them. Note that when the copy member is copied into the calling\nprogram, these symbols are defined in open code: this means that the\ncaller can reference them with no additional effort, but the function\nmacros defined in the copy member must reference those global symbols\nthat they need. This will always include the function code symbol, and\noften will include any global symbols specific to the service processor.\n\n*Figure 21. Symbol Definitions For SRVCC* <#FT_FIGMACSYMS>\n\n\n\n *---------------------------------------------------------------------*\n *  Service processor module name.\n *---------------------------------------------------------------------*\n    GBLC   &CHEAP_CALCULATOR\n &CHEAP_CALCULATOR SETC '''SRVCC    '''\n *---------------------------------------------------------------------*\n *  Function symbols.\n *---------------------------------------------------------------------*\n    GBLA   &CC_START,&CC_TERMINATE\n    GBLA   &CC_ADD,&CC_SUBTRACT,&CC_MULTIPLY,&CC_DIVIDE\n    GBLA   &CC_CLEAR\n &CC_START         SETA   1\n &CC_TERMINATE     SETA   2\n &CC_ADD           SETA   3\n &CC_SUBTRACT      SETA   4\n &CC_MULTIPLY      SETA   5\n &CC_DIVIDE        SETA   6\n &CC_CLEAR         SETA   7\n *---------------------------------------------------------------------*\n *  Return code symbols.\n *---------------------------------------------------------------------*\n   GBLA    &CC_INVALID_CC_ID\n   GBLA    &CC_INVALID_NUMBER_OF_PARMS\n   GBLA    &CC_INVALID_FUNCTION\n   GBLA    &CC_OVERFLOW\n   GBLA    &CC_PARAMETER_MISSING\n &CC_INVALID_CC_ID           SETA  1\n &CC_INVALID_NUMBER_OF_PARMS SETA 2\n &CC_INVALID_FUNCTION        SETA  3\n &CC_OVERFLOW                SETA  4\n &CC_PARAMETER_MISSING       SETA  5\n\n\n\n*Other Symbols:*Generally, if additional global symbols would simplify\nthe tasks of the service processor's users or its author, they should be\nprovided. One example of such symbols is the time, date and duration\nsymbols provided by the Date/Time Service Processor.\n\n\n        Parameter Validity Checking\n\nMuch of the validity checking performed by a service processor can be\nperformed at assembly time by the function macros. This is not to say\nthat the service processor code should not validity-check the parameters\nas well: a caller may use CALLX to call the service processor, a\nparameter list may be overlaid at execution time, or some other\nunforeseen problem may occur. Validity checking by the function macros\nis primarily for the programmer's benefit, as this tends to catch common\nerrors (omitted or mutually exclusive parameters, constants where\naddresses should be specified, and so on) at assembly time.\n\n\n        CALLX Vs. ##PLIST\n\nThe Structured Macros include the ##PLIST macro, which is used\ninternally by PLIST, CALLSUB and CALLX to build parameter lists. ##PLIST\nhas 3 forms: \"START\" to initiate a parameter list, \"END\" to terminate\none, and \"PARM,parameter\" to add a parameter to the list being built.\n##PLIST is especially useful for building variable-length parameter\nlists, as shown in Figure 22 <#FIGMAC##PL>.\n\n*Figure 22. Building A Variable-Length Parameter List Using ##PLIST*\n<#FT_FIGMAC##PL>\n\n\n\n .*\n .* Given a parameter containing a VL list of things (in this case,\n .* \"SOURCE=(p1,p2,p3,...,pn)\"), generate the base parameter list.\n .*\n          ##PLIST START                   | Generate PWA tag, code\n          ##PLIST PARM,IDTKN           | Initial parms\n          ##PLIST PARM,&SRVPROC_FUNCTION  |\n          ##PLIST PARM,ESVA            |\n .*\n .* Generate a VL list from the operand(s) of SOURCE, if any.\n .*\n &N       SETA  1\n .PL_LOOP ANOP  ,                         |\n          AIF   (&N GT N'&SOURCE).PL_LOOPEND\n          ##PLIST PARM,&SOURCE(&N)        | Entry for SOURCE(n)\n &N       SETA  &N+1                      |\n          AGO   .PL_LOOP                  |\n .PL_LOOPEND ANOP ,\n .*\n .* Terminate the parameter list and call service processor.\n .*\n          ##PLIST END,VL      | Set X'80' on last parm, load R1\n          CALLX  IDEPA     | Call the service processor.\n          MEXIT\n\n\n        The CC_Add Macro\n\nFigure 23 <#FIGMACADDM> illustrates the CC_Add macro, which uses the\nbasic components of a function macro.\n\n*Figure 23. CC_ADD Macro For SRVCC* <#FT_FIGMACADDM>\n\n\n\n *---------------------------------------------------------------------*\n *  CC_Add Macro.\n *  Format:    CC_ADD    ID=CC,\n *                       SPEPA=CC_entry_point_address,  (*)\n *                       SPTOKEN=CC_token_address,      (*)\n *                       ESVA=ESV_address,              (*)\n *                       VALUE=address | constant | register,\n *                       DISPLAY=address | register\n *  (*) - These may be defaulted to values set or generated by CC_ID.\n *---------------------------------------------------------------------*\n          MACRO\n          CC_ADD  &ID=,&SPEPA=,&SPTOKEN=,&ESVA=,        |              *\n                &VALUE=,&DISPLAY=                       |\n          GBLC  IDCODE,IDMAC,IDESID,IDESVA  |  SRV##ID\n          GBLC  IDEPN,IDEPA,IDTKN              |   Symbols\n          GBLA  &CC_ADD                                 | Function code\n .*\n .* Obtain service processor ID values.\n .*\n          SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN,ESVA),  | Fill out the   *\n                ID=&ID,IDMAC=CC_ID,                   | defaults from  *\n                SPEPA=&SPEPA,SPTOKEN=&SPTOKEN,        | CC_ID macro.   *\n                ESVA=&ESVA.                           |\n          AIF  ('IDCODE' NE 'SUCCESS').MEXIT\n .*\n .* Ensure required parameters are present.\n .*\n          AIF  ('&VALUE' EQ '').MISSING     | VALUE is required\n          AIF  ('&DISPLAY' EQ '').MISSING   | DISPLAY required\n          AIF  (T'&DISPLAY EQ 'N').BADDISP  | DISPLAY can't be constant\n .*\n .* Generate the CC_ADD call.\n .*\n          ##PLIST START            |     Start parmlist generation.\n          ##PLIST PARM,IDTKN    |     Parameter 1: Token.\n          ##PLIST PARM,&CC_ADD     |     Parameter 2: ADD function.\n          ##PLIST PARM,IDESVA   |     Parameter 3: ESVA.\n          ##PLIST PARM,&VALUE      |     Parameter 4: Function-specific.\n          ##PLIST PARM,&DISPLAY    |     Parameter 5: Function-specific.\n          ##PLIST END,VL           |     Set VL bit, load register 1\n          CALLX  IDEPA          |     Call the service processor.\n          MEXIT\n .MISSING MNOTE 8,'Required parameter(s) missing.'\n          MEXIT\n .BADDISP MNOTE 8,'Invalid address of ''&DISPLAY'' for DISPLAY.'\n .MEXIT   MEND\n\n\n\n*Miscellaneous Macros*\n\nIf your service processor makes use of complex parameters (control\nblocks, parameters that point to other parmlists, text with control\ninformation, etc.), consider creating some macros that will help the\nprogrammer deal with your service processor. As an example, the Message\nServices service processor includes a set of macros to generate message\nCSECTs: these macros do not produce executable code, but create the\nmessage text and associated data structures that would be tedious and\ntime-consuming to produce manually.\n\n\n      The User's Guide And Reference <#ToC_134>\n\nThe Service Processors User's Guide And Reference (this document) should\ncontain a chapter for each publicly-available service processor, and\nwriting the chapter should be considered among the tasks involved in\nwriting a new service processor. The chapters reside in\nSYSTEMS.SRV.SOURCE, as members SRVDOCxx, where xx is the service\nprocessor's two-character ID.\n\n------------------------------------------------------------------------\n\n\n    Writing The Code <#ToC_135>\n\nBy now, it should be apparent that the task of actually writing the\nservice processor code is only part of the work involved. The code for a\nservice processor, once a basic framework is in place, is actually\nfairly simple to produce. The elements of this framework exist in all\nservice processors, and indeed are often copied from an existing service\nprocessor when a new one is being written.\n\n\n      Structured Macro Support <#ToC_136>\n\nService processors are invariably written using the Structured Macros.\nIn addition to the \"standard\" set of macros and tools, the Structured\nMacros contain support intended to facilitate the coding of service\nprocessors.\n\n\n        OPTIONS=*SRVPRC\n\nThe super option *SRVPRC must be coded on the BLOCK TYPE=PROGRAM macro\nfor any service processor. In addition to the options provided by the\n*PWA super option, *SRVPRC also includes the following:\n\n  *\n\n    *XA*: Causes XA-only instructions (BAS, BASR) to be used for linkage\n    by CALLSUB and CALLX.\n\n  *\n\n    *NO370*: Excludes bimodal code around linkage sequences.\n\n  *\n\n    *(REUSPWA,1)*: Specifies that a reusable PWA should be used, and\n    that its address is the first parameter in the parameter list (e.g.\n    the token). This option causes a PWA to be getmained and anchored\n    off of this address when the START function is invoked.\n\n  *\n\n    *(FNCODE,2,AL4(1))*: Indicates that the function code will be the\n    second parameter, and that the START function's code is 1.\n\n  *\n\n    *(ESV,3,PWAAESV)*: Specifies that the ESV address is the third\n    parameter, and provides the tag in the PWA where the ESV address\n    will be stored when START is invoked. The presence of the ESV\n    parameter will also cause BLOCK and ENDBLK to call Environment\n    Support's linkage GETMAIN and FREEMAIN routines, instead of\n    generating their own GETMAIN and FREEMAIN macros.\n\n  *\n\n    *ERRADDR*: Instructs the ERREXIT macro to use a BAS instruction to\n    call the error exit. If the code operand of ERREXIT is provided, the\n    value of code is generated as a halfword immediately following the\n    BAS instruction. This allows the ERREXIT routine to save the address\n    where the error was detected in the debug area.\n\n  *\n\n    *CLRDEBUG*: Specifies whether the debug area should be cleared upon\n    each entry to the program block.\n\nIf additional program block options are required or should be turned\noff, they can be coded normally following the *SRVPRC super option.\nRefer to the Clemson University Structured Programming Macros User's\nGuide And Reference for additional information.\n\n\n        SMCTRL\n\nThe *SRVPRC super option causes the service processor's PWA to be\ngetmained during the START call, and retained across subsequent calls:\nhence, the TERMINATE routine should include the macro SMCTRL\nFREEPWA=YES. This sets a flag in the PWA which will cause the service\nprocessor's ENDBLK macro to freemain the PWA.\n\n\n        Parameter List Support\n\nThe BLOCK macro can set up a base register for the service processor's\nparameter list, as well as counting the parameters, by specifying\n(PARMS,(USING,reg),(COUNT,pwa_fullword),VL) among the OPTIONS and coding\nthe operand PARMMAP=dsect_name. There is also a COPYPARM option which\nwill reserve PWA storage for the largest possible parameter list and\ncopy the caller's parameter list to the PWA for each call, ensuring that\nall unused parameters in the copy are set to zero. While COPYPARM may be\ndesirable, it can take an excessive amount of time if large parameter\nlists are in use. Refer to the Clemson University Structured Programming\nMacros User's Guide And Reference for additional information.\n\n\n      The Parameter List <#ToC_140>\n\nThe typical service processor parameter list, as has already been\ndemonstrated, contains a common set of parameters at its beginning\nfollowed by zero or more function-specific parameters. The common\nparameters, as well as a suggested format for the parameter list DSECT,\nare presented below.\n\n\n        The Function Code\n\nThe first parameter of any service processor call is the address of a\nfunction code. The function code is always a fullword containing some\nnonzero numeric value, and is used to request a particular function from\nthe service processor. Values of F'1' and F'2' are generally used for\nStart and Terminate respectively. Global symbols are usually defined in\nthe service processor's copy member for the function codes, as seen in\nFigure 21 <#FIGMACSYMS>.\n\n\n        The Token\n\nThe token serves to uniquely identify a service processor \"session\", and\nis returned by the START function. Each time it is called, the service\nprocessor will validate its token by ensuring that some field(s) in its\nPWA have been set to some identifiable value. The token facility allows\na program to activate multiple service processor \"sessions\" by issuing\nmultiple START calls and saving the different tokens, then using the\ntokens to refer to individual sessions on subsequent calls.\n\nFor example, one might wish to read two files and create a third file:\nthis could be done by starting three separate File Handler sessions with\nappropriate parameters, and using the three tokens as unique\nidentifiers. Using the function macros, the caller can isolate himself\nsomewhat from specifying (or even defining!) the token by allowing the\nID macro (and its call to ##SRVID SET) to generate the tokens' storage\nand associate an ID value with each token.\n\n\n        The ESV Address\n\nAs a rule, the ESVA, or ESV address, is passed as the third parameter to\nat least the START function. If an ESV address is provided to the START\nfunction, the service processor can save the address and allow\nsubsequent parameter lists to be shorter: however, an invalid-token\nerror (where the PWA pointer is not valid) may degenerate into\n\"unpredictable results\" when the service processor attempts to use\nEnvironment Support to save error information.\n\n\n        Other Parameters\n\nIndividual functions will, of course, have zero or more\nfunction-specific parameters.\n\n\n        The Parameter List DSECT\n\nTypically, the DSECT for the service processor's parameter list will\ncontain the following:\n\n  *\n\n    A \"common\" section at the beginning containing the token and\n    function code.\n\n  *\n\n    Individual sections for each set of function-specific parameters,\n    using ORG to redefine the storage for each function.\n\n  *\n\n    A tag for every parameter. The tags should contain the function name\n    (or an abbreviation) for function-specific parameters.\n\n  *\n\n    An EQU at the end of the shortest function-specific section (or at\n    the end of the common section if appropriate), set to the minimum\n    number of parameters that the service processor supports.\n\n  *\n\n    An EQU at the end of each function-specific section, set to the\n    number of parameters that the function allows. If the function\n    supports a variable number of parameters, two EQU's should be used\n    for the minimum and maximum number of parameters.\n\n  *\n\n    An EQU at the end of the DSECT, set to the maximum number of\n    parameters that the service processor supports.\n\nThe parameter list DSECT for SRVCC appears in Figure 24 <#FIGCCPARMD>.\n\n*Figure 24. SRVCC's Parameter List DSECT (Partial)* <#FT_FIGCCPARMD>\n\n\n\n title \"SRVCC -- Parameter List DSECT\"\nparmlist          dsect ,             |\nprm_CC_id         ds a                | CC_identifier === PWA base\nprm_functioncode  ds a                | Function to be performed\nprm_min_#         equ (*-parmlist)/4  | Minimum number of parameters\n*                                     |   (defined here since there are\n*                                     |   functions with no function-\n*                                     |   specific parameters).\nprm_function_dept equ *               | Function-dependent parameters:\n*---------------------------------------------------------------------*\n*                  Start function parameters\n*---------------------------------------------------------------------*\n                  org prm_function_dept\nprm_start_esv     ds a                | Environment Support Vector.\nprm_start_min_#   equ (*-parmlist)/4  | Minimum # START parameters.\nprm_start_max_#   equ (*-parmlist)/4  | Maximum # START parameters.\n*---------------------------------------------------------------------*\n*                 Terminate function parameters\n*---------------------------------------------------------------------*\n               org prm_function_dept  |\nprm_terminate_#   equ (*-parmlist)/4  | No function-specific parms.\n*---------------------------------------------------------------------*\n*                 CC_Add function parameters\n*---------------------------------------------------------------------*\n               org prm_function_dept  |\nprm_add_value     ds    f             | Value to add to display.\nprm_add_display   ds    f             | Where to store updated display.\nprm_add_#         equ (*-parmlist)/4  |\n*---------------------------------------------------------------------*\n*     Other function-dependent parameter sections defined here.\n*---------------------------------------------------------------------*\n               :\n               :\n*---------------------------------------------------------------------*\n*            End of function-dependent parameter sections.\n*---------------------------------------------------------------------*\n                org ,                 |\nprm_max_#          equ (*-parmlist)/4 | Maximum number of parameters.\n\n\n        Parameter List Validation\n\nOne of the best ways to avoid abends by a service processor is to\nscrutinize the caller's parameters carefully. Invalid numbers of\nparameters, missing parameters and incorrect data provided by the caller\nshould be checked, and a descriptive error returned if a problem is\ndetected.\n\n*Common Parameter Validation.: *  The validations listed here are\nstandard for any service processor. They should be coded following the\nprogram block macro, and prior to the main case block. The equivalent\ncode for SRVCC is shown in Figure 25 <#FIGMACENT>.\n\n  *\n\n    *Function code:*The function code should be one supported by the\n    service processor. Usually, a symbol in the copy member defining the\n    highest-used function code is used to check the function code passed\n    by the caller. A function code of zero is generally invalid (since\n    it may represent a missing parameter).\n\n  *\n\n    *Token:*After a successful START, the token should point to the\n    service processor's PWA. The START code will usually set some unique\n    value at a fixed offset in the PWA that subsequent calls can check:\n    generally, this is the PWA address followed by some short character\n    string (for example, CC_ID) that can be checked quickly.\n\n  *\n\n    *Number of parameters:*The parm count can be set by\n    OPTIONS=(...,(PARMS,(COUNT,pwa_count_field),...)) on the program\n    block macro. This count field should be checked against the minimum\n    and maximum number of parameters supported.\n\n*Function-Specific Parameter Validation.: *  The code at the start of an\nindividual function should, first of all, ensure that the number of\nparameters passed is acceptable for that function. In addition, the\nvalidation code should check for missing parameters (a zero pointer in\nthe parameter list), as well as anything that might cause a program\ncheck (a zero value to be used for division, invalid packed-decimal\ndata, etc). Keep in mind, however, that excessive validity checking will\nprobably impact the service processor's performance.\n\n\n      Entry Logic <#ToC_149>\n\nThe BLOCK macro can be made to perform most of the housekeeping chores\nof entering a service processor, such as setting up base registers,\nclearing the debug area, and counting the parameters. The remaining\nentry logic may then consist of ERREXIT macros: these should ensure that\nat least a minimum and no more than a maximum number of parameter were\nspecified, as well as performing some simple validity check on the PWA.\nThis validity check is typically a check for some unique thing in the\nPWA that the START function put there.\n\n*Figure 25. Entry Logic For SRVCC* <#FT_FIGMACENT>\n\n\n\n  title \"SRVCC -- Initialization\"\n  block name=SRVCC,type=program,amode=31,rmode=any,                    *\n                options=(*srvprc,long,                                 *\n                (parms,(using,r11),(count,pwa_number_of_parms),vl)),   *\n                parmmap=parmlist,basereg=(r12,r9),                     *\n                subopts=(*swa,loadbase)\n * *------------------------------------------------------------------*\n * * Ensure that at least the minimum and no more than the maximum\n * * number of parameters were passed in the parameter list.\n * *------------------------------------------------------------------*\n   l     r0,pwa_number_of_parms        | Save number of parms.\n   errexit    (ch,r0,lt,=y(prm_min_#)),      Ensure number of parms    *\n                or,(c,r0,gt,=a(prm_max_#)),    is within limits.       *\n                code=&CC_invalid_number_of_parms\n   l     r1,prm_functioncode           | Load the function code into\n   l     r1,0(,r1)                     |   a register for testing.\n * *------------------------------------------------------------------*\n * * If the function code is something other than start, make sure that\n * * the PWA contains the eye-catcher string and the correct value for\n * * CC_ID.   If not, then the CC_ID passed in is garbage.\n * *------------------------------------------------------------------*\n   if (c,r1,ne,=f'&CC_start')          | If not startup function:\n    errexit ((clc,pwa_visual,ne,psd_eyecatcher),  Check eyecatcher 1 *\n                or,(c,r13,ne,pwa_CC_id)),   PWA's address of itself;  *\n                code=&CC_invalid_CC_id |    error if they don't match.\n   endif                               | Endif.\n\n\n      The Main CASE Block <#ToC_150>\n\nThe simplest way to process the function code is with a case block. This\nis usually the heart of any service processor. The individual functions\nmay be coded as subroutines, or may be handled inline if they're not too\ncomplex. Refer to Figure 26 <#FIGMACSTRT> and Figure 27 <#FIGMACADD> for\nexamples.\n\n\n      The START And TERMINATE Functions <#ToC_151>\n\nThe START routine should perform whatever initialization the service\nprocessor requires, such as starting other service processors or opening\nfiles. In addition, the START function should establish some unique\nvalue or values in the PWA that can be used by other functions for\nvalidity checking. Generally, a fullword containing the PWA address and\nsome character string is used: the character string also serves as an\neyecatcher when a dump is taken.\n\nThe TERMINATE routine should take care of any end-of-task processing\nrequired, such as closing files or terminating other service processors.\nThe TERMINATE routine should also include the macro SMCTRL FREEPWA=YES\nto cause the program's ENDBLK to freemain the PWA.\n\nThe START and TERMINATE routines for SRVCC are illustrated in Figure 26\n<#FIGMACSTRT>.\n\n*Figure 26. The CC_Start And CC_Terminate Functions* <#FT_FIGMACSTRT>\n\n\n\n    title \"SRVCC -- CC_Start Function\" |\n * *------------------------------------------------------------------*\n * * Select the code to process the function.\n * *------------------------------------------------------------------*\n   caseblk reg=r1                      | Start of function case block.\n   space 1                             |\n *  *-----------------------------------------------------------------*\n *  * Start function.\n *  *-----------------------------------------------------------------*\n    case &CC_start                     |  Start function.\n *   *----------------------------------------------------------------*\n *   * Set the eyecatcher and the CC_ID fields.   These are checked\n *   * each time the CC server is entered to avoid integrity problems.\n *   *----------------------------------------------------------------*\n     mvc   pwa_visual,psd_eyecatcher   |   Set the eyecatcher and the\n     st    r13,pwa_CC_id               |   CC_ID are for validity checks\n     xc    pwa_clear_start(pwa_clear_length),pwa_clear_start\n *   *----------------------------------------------------------------*\n *   * Make sure that a valid number of parameters are specified.\n *   *----------------------------------------------------------------*\n     l     r3,pwa_number_of_parms      |   Load r3 with number of parms.\n     errexit    (ch,r3,lt,=y(prm_start_min_#)),or,   Error if out      +\n                (ch,r3,gt,=y(prm_start_max_#)),      of bounds.        +\n                code=&CC_invalid_number_of_parms\n     space 1                           |\n     l    r1,pwaaesv                   | Load pointer to ESV.\n     using esv,r1                      |\n     mvc   pwa_es_epa,esvesepa         | Copy EPA and token addresses\n     mvc   pwa_es_token,esvestkn       | for current Env. Support sess.\n     drop  r1                          |\n     slr   r0,r0                       |\n     st    r0,pwa_display              | Clear the \"display\".\n *  *-----------------------------------------------------------------*\n  title \"SRVCC -- CC_Terminate Function\"\n *  *-----------------------------------------------------------------*\n *  *  CC_Terminate function.\n *  *-----------------------------------------------------------------*\n    case &CC_Terminate                 |\n     l     r3,pwa_number_of_parms      |   Load r3 with number of parms\n     errexit    (ch,r3,lt,=y(prm_terminate_#)),  Error if not correct. +\n                code=&CC_invalid_number_of_parms\n     smctrl  freepwa=yes               |\n *  *-----------------------------------------------------------------*\n\n\n      Other Functions <#ToC_152>\n\nEach service processor function should ensure that it was passed the\nappropriate number of parameters, and that they contain or point to\nvalid information.\n\n*Figure 27. The CC_Add Function* <#FT_FIGMACADD>\n\n\n\n title \"SRVCC -- CC_Add Function\"     |\n *  *-----------------------------------------------------------------*\n *  *  CC_Add function.\n *  *-----------------------------------------------------------------*\n    case &CC_Add                       | Add function.\n     l     r3,pwa_number_of_parms      |   Load r3 w/ number of parms.\n     errexit    (ch,r3,ne,=y(prm_add_#)),  Error if not correct.       *\n                code=&CC_invalid_number_of_parms\n     l32   r1,prm_add_value            |  Get pointer to value to add\n     errexit (z),code=&CC_Parameter_Missing  Error if pointer missing\n     l     r1,0(r1)                    |  Get the value\n     a     r1,pwa_display              |  Add current display contents\n     st    r1,pwa_display              |  Update the display\n     l32   r2,prm_add_display          |  Get addr of caller's display\n     errexit (z),code=&CC_Parameter_Missing  Error if pointer missing\n     st    r1,0(r2)                    |  Return display to caller.\n     errexit (c,r1,gt,=f'99999999'),   |  Return error for             *\n                code=&CC_Overflow      |   \"overflow\" condition.\n *  *-----------------------------------------------------------------*\n\n\n      The Main Error Exit <#ToC_153>\n\nAny service processor should provide as much information as possible\nwhen it detects an error. Environment Support provides a means to allow\nservice processors to chain blocks of information (known as debug\nareas), as shown in Figure 28 <#FIGMACERRX>.\n\n*Figure 28. SRVCC's ERREXIT Routine* <#FT_FIGMACERRX>\n\n\n\n  title \"SRVCC - General Error Exit\"   |\n  block type=errexit                   |\n * *------------------------------------------------------------------*\n * * Save module/offset, registers, return-code.\n * *------------------------------------------------------------------*\n   stm   r0,r15,gdiregs                | Save registers at time of error\n   la    r0,4(,r12)                    | Point to module identification.\n   st    r0,gdimodid                   | Save in general debug area.\n   mvc   gdirc,0(r14)                  | Copy return code.\n   slr   r14,r12                       | Calculate offset at time of err\n   sth   r14,gdioffst                  | Save in debug area.\n   l     r2,pwaaesv                    | Point r2 to ESV.\n   using esv,r2                        | Establish base for ESV.\n   es_save_debug_info  id=ES,gdi=debug_area_address\n * *------------------------------------------------------------------*\n * * Look at the error code.  If add'l information would be useful,\n * * stuff into the debug area.\n * *------------------------------------------------------------------*\n   lh    r15,gdirc                     | Get return code.\n   caseblk reg=r15,mult=1              | Case on return-code.\n     case &CC_invalid_function         |\n       es_save_debug_info id=ES,       |                               *\n                text=(psd_invalid_function,l'psd_invalid_function)\n     case &CC_invalid_number_of_parms  |\n       es_save_debug_info id=ES,       |                               *\n                text=(psd_invalid_#_parms,l'psd_invalid_#_parms)\n     case &CC_invalid_CC_ID            |\n       es_save_debug_info id=ES,       |                               *\n                text=(psd_invalid_CC_ID,l'psd_invalid_CC_ID)\n   endcase                             | EndCase.\n   drop r2                             |\n * *------------------------------------------------------------------*\n * * Set the return-code and exit.\n * *------------------------------------------------------------------*\n   lh    r15,gdirc                     | Set return code.\n  endblk rc=(r15)                      |\n  title \"SRVCC -- Constants\"           |\n          psd   ,                      |\n psd_eyecatcher  dc    cl8'CHEAP_SP'   | So everyone will know ...\n psd_invalid_function   dc  c\"Unsupported function.\"\n psd_invalid_#_parms    dc  c\"Invalid number of parameters.\"\n psd_invalid_cc_id      dc  c\"Invalid token provided.\"\n psd_overflow           dc  c\"Output value is too large for requested *\n                format.\"               |\n psd_undetermined_error   dc  c\"Undetermined error.\"\n          ltorg ,                      |\n          endpsd ,                     |\n\n\n\nService processors typically contain only one error exit: hence, the\nERREXIT block may be unnamed, which simplifies coding somewhat. The\nerror exit expects the ERRADDR option to be set on the program block:\nthis generates a BAS R14,errexit, followed by the ERREXIT macro's CODE\nvalue, to call the error exit. Thus, the error exit can report where it\nwas called within the service processor.\n\nThe Environment Support service processor offers a variety of diagnostic\naids which service processors can use to save error information. The\nerror exit shown in Figure 28 <#FIGMACERRX> makes use of several of\nthese tools, and can be used as a model. This sample error exit performs\nthe following:\n\n  *\n\n    Saves all registers in the General Debug Info (GDI) area. This area\n    can be generated by coding ES_GDI DSECT=NO in the PWA. Refer t the\n    ES_GDI macro in copy member SRVESMAC for the forma of the GDI.\n\n  *\n\n    Saves the address of the module name (usually +4 from the start of\n    the main CSECT) in the GDI.\n\n  *\n\n    Saves the ERREXIT macro's CODE value in the GDI. (This is a halfword\n    pointed to by R14.)\n\n  *\n\n    Passes the GDI to the ES_SAVE_DEBUG_INFO function to be \"stacked\"\n    with any existing debug information.\n\n  *\n\n    Depending on the type of error, additional information (in the form\n    messages or hex info) may be saved by the error exit using\n    ES_SAVE_DEBUG_INFO.\n\n  *\n\n    Exits with the return code passed via the ERREXIT macro's CODE value.\n\nNormally, a service processor *should not*call any service processor\nfunctions other than ES_SAVE_DEBUG_INFO from within its error exit. This\nis because vital information about the error being handled may exist in\nthe debugging information area and calling a service processor function\ncauses that information to automatically be cleared. If a service\nprocessor's error exit needs to use service processor functions other\nthan ES_SAVE_DEBUG_INFO, the\n\nES_CLEAR_DEBUG_INFO ID=es,ACTION=INHIBIT\n\nfunction should be used to inhibit clearing of the debugging information\narea before calling other service processor functions (any service\nprocessor functions, not just Environment Support functions).\n\nAfter all function calls have been made from within the error exit, the\nfollowing function call should be made\n\nES_CLEAR_DEBUG_INFO ID=es,ACTION=ENABLE\n\nto re-enable clearing of the debugging information area. When control is\nreturned to the calling application, it may decide it can tolerate the\nerror and proceed. This function does not actually clear the debugging\ninformation area, but allows it to be cleared automatically the next\ntime any service processor function is invoked. If this is not done, and\nif the calling application proceeds with execution, the debugging area\ncannot be cleared and extraneous information may accumulate there.\n\n------------------------------------------------------------------------\n\n*Footnotes:*\n\n^1\n    This format, although specified as a date format, will accept or\n    return both a date and time value. The associated input or output\n    time parameters will be ignored.\n^2\n    If\n\nOPTIONS=EUROPEAN\n\n    was specified on the DT_START macro, the month and day values will\n    be reversed.\n^3\n    This format, although specified as a time format, will accept or\n    return both a date and time value. The associated input or output\n    date parameters will be ignored.\n^4\n    These formats may also be used as interval formats. Refer to Table 4\n    <#TBLDTINTVL> for more information.\n^5\n    The System/370 time-of-day clock can only represent a limited range\n    of dates and times, from Jan. 1, 1900 at 00:00:00.00 to Sept. 17,\n    2042 at 23:53:47:37. Attempts to convert values outside this range\n    to TOD format will result in a\n\n    &DT_Out_Of_Range\n\n    return code.\n^6\n    These formats may also be used as date or time formats, although\n    their characteristics may be slightly different. Refer to Table 2\n    <#TBLDTDATES> and Table 3 <#TBLDTTIMES> for more information.\n\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@FILE859": {"ttr": 8966, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04S\\x00&\\x01\\x110_\\x01\\x110_\\x022\\x00\\x0f\\x00\\x0f\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf8\\xf3@@@'", "ispf": {"version": "04.83", "flags": 0, "createdate": "2011-11-01T00:00:00", "modifydate": "2011-11-01T02:32:26", "lines": 15, "newlines": 15, "modlines": 0, "user": "CBT-483"}, "text": "//***FILE 859 is from Jim Blalock and contains the Clemson          *   FILE 859\n//*           University Service Processor source modules.          *   FILE 859\n//*                                                                 *   FILE 859\n//*       email:  Jim Blalock <carey@clemson.edu>                   *   FILE 859\n//*                                                                 *   FILE 859\n//*             Clemson University Service Processors               *   FILE 859\n//*                                                                 *   FILE 859\n//*     This library contains the source modules and macros for     *   FILE 859\n//*     the Clemson University Service Processors.                  *   FILE 859\n//*                                                                 *   FILE 859\n//*     These materials are being made available to cbttape.org     *   FILE 859\n//*     under the Apache 2.0 license.  See member $LICENSE or       *   FILE 859\n//*     refer to Apache's web site at                               *   FILE 859\n//*     http://www.apache.org/licenses/LICENSE-2.0                  *   FILE 859\n//*                                                                 *   FILE 859\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LNKCMMVS": {"ttr": 8968, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x02\\x00\\x00V\\x01\\x11)\\x9f\\x01\\x11)\\x9f\\t'\\x00*\\x00*\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@\"", "ispf": {"version": "02.00", "flags": 0, "createdate": "2011-10-26T00:00:00", "modifydate": "2011-10-26T09:27:56", "lines": 42, "newlines": 42, "modlines": 0, "user": "CLEMSON"}, "text": "//LNKCMMVS JOB ,'Standard MNT',TIME=(,4)\n//**********************************************************************\n//*                                                                    *\n//* This job creates a composite module containing:                    *\n//*    (1) Environment Support,                                        *\n//*    (2) A standard module name table for &<SRVES>, and              *\n//*    (3) The service processors referenced by the table.             *\n//*                                                                    *\n//* The composite load module will have an alias of the same name as   *\n//* Environment Support so that when an application program loads      *\n//* SRVESMVS it will get the composite module instead. The application *\n//* program will never know the difference, except that fewer actual   *\n//* LOADs may occur than would have otherwise.                         *\n//*                                                                    *\n//* Warning: Since the composite module has an alias of SRVESMVS, it   *\n//*          obviously should not be placed in the same PDS as the     *\n//*          real SRVESMVS load module.                                *\n//*                                                                    *\n//**********************************************************************\n//*\n//  SET PDS='TARGET.CMMVS.LIBRARY'\n//  SET SRVLOAD='PREFIX.SRV.LOAD'\n//*\n//LINK     EXEC PGM=IEWL,PARM='XREF,LIST,LET,NCAL,RENT',COND=(0,NE)\n//SYSUT1   DD UNIT=(SYSDA,SEP=(SYSLMOD,SYSLIN)),\n//            SPACE=(1024,(200,20))\n//SYSPRINT DD SYSOUT=A\n//SYSLMOD  DD DISP=SHR,DSN=&PDS\n//SRV      DD DISP=SHR,DSN=SYSTEMS.SRV.OBJ\n//SYSLIN   DD  *\n INCLUDE SRV(SRVESMVS)\n INCLUDE SRV(SRVMNMVS)\n INCLUDE SRV(SRVESX01)\n INCLUDE SRV(SRVMM)\n INCLUDE SRV(SRVSY)\n INCLUDE SRV(SRVST)\n INCLUDE SRV(SRVPLMVS)\n INCLUDE SRV(SRVMS)\n INCLUDE SRV(SRVDT)\n ENTRY   SRVESMVS\n ALIAS   SRVESMVS\n NAME    SRVCMMVS(R)\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SRV##ID": {"ttr": 8970, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x02\\x00\\x00V\\x01\\x11)\\x9f\\x01\\x11)\\x9f\\t'\\x01D\\x01D\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@\"", "ispf": {"version": "02.00", "flags": 0, "createdate": "2011-10-26T00:00:00", "modifydate": "2011-10-26T09:27:56", "lines": 324, "newlines": 324, "modlines": 0, "user": "CLEMSON"}, "text": "*---------------------------------------------------------------------*\n*  Copyright 2011 by Clemson University Research Foundation           *\n*                                                                     *\n*  Licensed under the Apache License, Version 2.0 (the \"License\");    *\n*  you may not use this file except in compliance with the License.   *\n*  You may obtain a copy of the License in this library as member     *\n*  $LICENSE, or from                                                  *\n*                                                                     *\n*      http://www.apache.org/licenses/LICENSE-2.0                     *\n*                                                                     *\n*  Unless required by applicable law or agreed to in writing,         *\n*  software distributed under the License is distributed on an \"AS    *\n*  IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either    *\n*  express or implied.  See the License for the specific language     *\n*  governing permissions and limitations under the License.           *\n*---------------------------------------------------------------------*\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   SRV##ID                                                    *\n*                                                                     *\n* Purpose: This macro stashes default values for Service Processor    *\n*          sessions and associates them with a unique identifier for  *\n*          later retreival (by this macro).                           *\n*                                                                     *\n* To create a service processor identifier, invoke SRV##ID with:      *\n*                                                                     *\n*   SRV##ID SET,                                                      *\n*           ID=identifier,IDMAC=macroName,                            *\n*           SPEPNAME=spepname,SPEPA=spepa,SPTOKEN=sptoken,            *\n*           ESID=esid                                                 *\n* To obtain the values from an existing service processor identifier: *\n*                                                                     *\n*   SRV##ID GET,                                                      *\n*           REQUIRED=(keyword,keyword,...),                           *\n*           ID=identifier,IDMAC=macroName,                            *\n*           SPEPNAME=spepname,SPEPA=spepa,SPTOKEN=sptoken,            *\n*           ESID=esid,ESVA=esva                                       *\n* where                                                               *\n*                                                                     *\n*   SET/GET     - is the operation to be performed.  SET causes a new *\n*                 service processor identifier (SPID) to be created,  *\n*                 and GET causes the values associated with an        *\n*                 existing SPID (and possibly overridden by values    *\n*                 from specified keywords) to be retrieved and        *\n*                 placed in fixed-name global variables.              *\n*   ID=         - specifies the identifier to assign to a new SPID    *\n*                 for SET, or the identifier of an existing SPID for  *\n*                 GET.  It is required for SET but optional for GET.  *\n*   IDMAC=      - specifies the name of the macro that created the    *\n*                 SPID.  It is required for SET but optional for GET. *\n*                 For GET, it may specify a list of acceptable names. *\n*   ESID=       - specifies the SPID of the Environment Support whose *\n*                 ESV address will be used when starting the service  *\n*                 processor session named by ID=.  If not specified   *\n*                 for SET, the SPID of the first Environment Support  *\n*                 service processor identifier created will be used.  *\n*                 If no Environment Support SPID exists (yet), then   *\n*                 ESID= is required.                                  *\n*   ESVA=       - specifies the tag of a fullword that contains (or   *\n*                 will contain) the address of the Environment        *\n*                 Support Vector that to use when starting the        *\n*                 service processor session named by ID=.  This       *\n*                 keyword cannot be specified with SET; it may be     *\n*                 specified on GET to override the value that would   *\n*                 have been obtained via the associated ESID SPID.    *\n*   SPEPNAME=   - specifies the entry point name of the service       *\n*                 processor session named by ID=.  It can be          *\n*                 specified as either a tag or a literal.  If not     *\n*                 specified by SET, it will be set to a null value.   *\n*   SPEPA=      - specifies the tag of a fullword that contains (or   *\n*                 will contain) the entry point address of the        *\n*                 service processor session named by ID=.  If not     *\n*                 specified by SET, a tag will be generated in the    *\n*                 PWA for it.                                         *\n*   SPTOKEN=    - specifies the tag of a fullword that contains (or   *\n*                 will contain) the token for the service processor   *\n*                 session named by ID=.  If not specified by SET, a   *\n*                 tag will be generated in the PWA for it.            *\n*   ERRMAC=     - specifies the name of a macro to invoke immediately *\n*                 following any service processor call.  This macro   *\n*                 presumably examines the results of the operation    *\n*                 and provides application-specific error handling.   *\n*   REQUIRED=   - for GET only; specifies a list of the keywords      *\n*                 whose values the invoking macro requires.  If any   *\n*                 of those values are still null after they have been *\n*                 retrieved from the ID=spid and possibly overridden  *\n*                 by specified keywords, an MNOTE will be generated.  *\n*                                                                     *\n* The SET operation creates uniquely named global variables and saves *\n* the supplied information in them.  The GET operation retrieves the  *\n* values and places them in fixed-named global variables to make it   *\n* simpler for macros to retrive SPIDs.  Variables created by SET and  *\n* returned by GET are all declared as GBLC:                           *\n*                                                                     *\n*    Keyword   SET creates       GET returns                          *\n*    -------   -------------     -----------                          *\n*                                &#_IDCODE                            *\n*    ID        &(#$&ID.$#IDMAC)  &#_IDMAC                             *\n*    ESID      &(#$&ID.$#ESID)   &#_IDESID                            *\n*    ESVA                        &#_IDESVA                            *\n*    SPEPNAME  &(#$&ID.$#EPN)    &#_IDEPN                             *\n*    SPEPA     &(#$&ID.$#EPA)    &#_IDEPA                             *\n*    SPTOKEN   &(#$&ID.$#TKN)    &#_IDTKN                             *\n*    ERRMAC    &(#$&ID.$#EMC)    &#_IDEMC                             *\n*                                                                     *\n* When GET returns, &#_IDCODE will equal 'SUCCESS' if all required    *\n* values are non-null.  If any required keyword has a null value,     *\n* the value of &#_IDCODE will be set to that keyword's name.  For     *\n* example, if you specified SRV##ID GET,REQUIRED=(ESVA) and the       *\n* value of ESVA was null, &#_IDCODE would be = 'ESVA'.                *\n*                                                                     *\n*---------------------------------------------------------------------*\n       MACRO\n       SRV##ID &OP,             SET or GET keyword.                    +\n               &ID=,            Service Processor Identifier (SPID).   +\n               &IDMAC=,         Name of macro creating this SPID.      +\n               &ESID=,          SPID of ID's Environment Support.      +\n               &SPEPNAME=,      Epname of ID's Service Processor.      +\n               &SPEPA=,         Epa of ID's Service Processor.         +\n               &SPTOKEN=,       Token of ID's Service Processor.       +\n               &ERRMAC=,        Error macro to invoke.                 +\n               &ESVA=,          (GET only) ESV address to use.         +\n               &REQUIRED=       (GET only) Values to retrieve.\n.*\n       AIF   ('&OP' EQ 'SET').SRVSETID\n       AIF   ('&OP' EQ 'GET').SRVGETID\n       MNOTE 8,'Invalid operation for SRV##ID.  Must be SET or GET.'\n       MEXIT\n.*--------------------------------------------------------------------*\n.*                                                                    *\n.*  Create a new Service Processor Identifier.                        *\n.*                                                                    *\n.*--------------------------------------------------------------------*\n.SRVSETID ANOP\n          GBLC  &PWA,&PSD,&DEFAULT_ENVIRONMENT_SUPPORT_ID\n          LCLC  &V_IDMAC,&V_ESID,&V_EPN,&V_EPA,&V_TKN,&V_EMC\n          LCLB  &GEN_PWA\n.*\n.* Check for the presence of required keywords.\n.*\n          AIF   ('&ID' NE '').ID_PR\n          MNOTE 8,'ID is a required keyword.'\n          MEXIT\n.ID_PR    ANOP\n.*\n.* Declare the global variables for tracking default information, and\n.* check to make sure that they have not already been used.\n.* Note: Created SET symbols cannot contain underscores (_).\n.*\n&V_IDMAC SETC '#$&ID.$#IDMAC'     Creating macro's name.\n&V_ESID  SETC '#$&ID.$#ESID'      Env. Supp. ID's variable name.\n&V_EPN   SETC '#$&ID.$#EPN'       SPEPNAME tag's variable name.\n&V_EPA   SETC '#$&ID.$#EPA'       SPEPA tag's variable name.\n&V_TKN   SETC '#$&ID.$#TKN'       SPTOKEN tag's variable name.\n&V_EMC   SETC '#$&ID.$#EMC'       ERRMAC tag's variable name.\n         GBLC  &(&V_IDMAC),&(&V_ESID),&(&V_EPN),&(&V_EPA),&(&V_TKN)\n         GBLC  &(&V_EMC)\n         AIF   ('&(&V_IDMAC)' EQ '').IDAVAIL\n         MNOTE 8,'ID=&ID. has already been used.'\n         MEXIT\n.IDAVAIL AIF   ('&IDMAC' NE '').IDMAC\n         MNOTE 8,'IDMAC keyword required for internal macro SRVSETID.'\n         MEXIT\n.IDMAC   ANOP\n.*\n.* Start filling in the ID's newly created global variables.\n.*\n&(&V_IDMAC)    SETC '&IDMAC'            Macro that created this ID.\n               AIF  ('&ESID' EQ '').DEFAULT_ESID\n&(&V_ESID)     SETC '&ESID'             ESID is our own ID.\n               AGO  .PAST_ESID\n.DEFAULT_ESID  AIF  ('&DEFAULT_ENVIRONMENT_SUPPORT_ID' NE '').ESID\n               MNOTE 8,'ESID not specified and no default defined.'\n               MEXIT\n.ESID          ANOP\n&(&V_ESID)     SETC '&DEFAULT_ENVIRONMENT_SUPPORT_ID'\n.PAST_ESID     ANOP\n&(&V_EPN)      SETC '&SPEPNAME'         Remember supplied SPEPNAME tag.\n&(&V_EPA)      SETC '&SPEPA'            Remember the specified SPEPA.\n&(&V_TKN)      SETC '&SPTOKEN'          Remember the specified SPTOKEN.\n&(&V_EMC)      SETC '&ERRMAC'           Remember the specified ERRMAC.\n.*\n.* Generate PWA fields for those values that are defaulting.\n.*\n&GEN_PWA  SETB (&GEN_PWA OR ('&SPEPA'   EQ ''))\n&GEN_PWA  SETB (&GEN_PWA OR ('&SPTOKEN' EQ ''))\n          AIF  (NOT &GEN_PWA).NO_PWA\n          PWA   TYPE=PARTIAL    | Generate fields for EPA and TOKEN.\n          AIF   ('&SPEPA' NE '').GENTKN\n&(&V_EPA) SETC  '&PWA.&ID._SPEPA'\n&(&V_EPA) DS    A               |   Service Processor EPA.\n.GENTKN   AIF   ('&SPTOKEN' NE '').PAST_KWDS\n&(&V_TKN) SETC  '&PWA.&ID._SPTOKEN'\n&(&V_TKN) DS    F               |   Service Processor TOKEN.\n.PAST_KWDS ANOP\n.ENDPWA   ENDPWA ,              | End of generated PWA fields.\n.NO_PWA   ANOP\n          MEXIT\n.*--------------------------------------------------------------------*\n.*                                                                    *\n.*  Obtain values from an existing Service Processor Identifier.      *\n.*                                                                    *\n.*--------------------------------------------------------------------*\n.SRVGETID ANOP\n          GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n          GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN,&#_IDEMC\n          GBLC  &DEFAULT_ENVIRONMENT_SUPPORT\n          LCLC  &V_IDMAC,&V_IDESID,&V_ESVA,&V_EPN,&V_EPA,&V_TKN,&V_EMC\n          LCLB  &B_IDMAC,&B_IDESID,&B_EPN,&B_EPA,&B_TKN,&B_EMC\n          LCLB  &B_IDESVA\n          LCLA  &N\n.*\n.* Initialize all global ID variables.\n.*\n&#_IDCODE SETC 'SUCCESS'          Hope for successful completion.\n&#_IDMAC  SETC  ''                Name of macro that created ID.\n&#_IDESID SETC  ''                Environment Support ID name.\n&#_IDESVA SETC  ''                Environment Support Vector Addr tag.\n&#_IDEPN  SETC  ''                Entry Point Name tag.\n&#_IDEPA  SETC  ''                Entry Point address tag.\n&#_IDTKN  SETC  ''                Service processor token tag.\n&#_IDEMC  SETC  ''                Error macro name.\n.*\n.* Turn the REQUIRED keyword into boolean flags.\n.*\n&N        SETA  1\n.SETFLG   AIF   (&N GT N'&REQUIRED).FLGSET\n&B_IDMAC  SETB  (&B_IDMAC  OR ('&REQUIRED(&N)' EQ 'ID'))\n&B_IDESID SETB  (&B_IDESID OR ('&REQUIRED(&N)' EQ 'ESID'))\n&B_IDESVA SETB  (&B_IDESVA OR ('&REQUIRED(&N)' EQ 'ESVA'))\n&B_EPN    SETB  (&B_EPN    OR ('&REQUIRED(&N)' EQ 'SPEPNAME'))\n&B_EPA    SETB  (&B_EPA    OR ('&REQUIRED(&N)' EQ 'SPEPA'))\n&B_TKN    SETB  (&B_TKN    OR ('&REQUIRED(&N)' EQ 'SPTOKEN'))\n&B_EMC    SETB  (&B_EMC    OR ('&REQUIRED(&N)' EQ 'ERRMAC'))\n&N        SETA  &N+1\n          AGO   .SETFLG\n.FLGSET   ANOP\n.*\n.* If ID=name was specified, get globals set by a xx_ID macro.\n.*\n          AIF   ('&ID' EQ '').PAST_ID\n&V_IDMAC  SETC '#$&ID.$#IDMAC'    Creating ID macro's name.\n&V_IDESID SETC '#$&ID.$#ESID'     ID's Env. Support. ID name.\n&V_EPN    SETC '#$&ID.$#EPN'      ID's Entry Point Name.\n&V_EPA    SETC '#$&ID.$#EPA'      ID's Entry Point Address.\n&V_TKN    SETC '#$&ID.$#TKN'      ID's Token.\n&V_EMC    SETC '#$&ID.$#EMC'      Error macro name.\n          GBLC  &(&V_IDMAC),&(&V_IDESID),&(&V_EPN),&(&V_EPA),&(&V_TKN)\n          GBLC  &(&V_EMC)\n&#_IDMAC  SETC '&(&V_IDMAC)'      Copy creating macro's name.\n&#_IDESID SETC '&(&V_IDESID)'     Copy ID's env. sup. ID name.\n&#_IDEPN  SETC '&(&V_EPN)'        Copy ID's value for SPEPNAME.\n&#_IDEPA  SETC '&(&V_EPA)'        Copy ID's value for SPEPA.\n&#_IDTKN  SETC '&(&V_TKN)'        Copy ID's value for SPTOKEN.\n&#_IDEMC  SETC '&(&V_EMC)'        Copy ID's value for ERRMAC.\n          AIF   ('&#_IDMAC' NE '').ID_DEFND\n          MNOTE 8,'Service processor ID=&ID. is not defined.'\n&#_IDCODE SETC  'ID'\n          MEXIT\n.ID_DEFND AIF   ('&IDMAC' EQ '').ID_OK\n&N        SETA  1\n.ID_CHECK AIF   (&N GT N'&IDMAC).ID_BAD\n          AIF   ('&#_IDMAC' EQ '&IDMAC(&N)').ID_OK\n&N        SETA  &N+1\n          AGO   .ID_CHECK\n.ID_BAD   MNOTE 8,'Service processor ID=&ID. cannot be used for this se+\n               rvice.'\n&#_IDCODE SETC  'ID'\n          MEXIT\n.ID_OK    ANOP\n&V_ESVA   SETC '#$&#_IDESID.$#ESVA'    ID's Env. Sup. ID's ESVA tag.\n          GBLC &(&V_ESVA)\n&#_IDESVA SETC '&(&V_ESVA)'       Copy ID's Env. Sup. ID's ESVA tag.\n.PAST_ID  ANOP\n.*\n.* Pick up override values for ESID, ESVA, SPEPNAME, SPEPA and SPTOKEN.\n.*\n               AIF ('&ESID' EQ '').NO_ESID   | If ESID kwd.\n&#_IDESID      SETC '&ESID'                  |   Pick up its value.\n.NO_ESID       ANOP                          | EndIf.\n               AIF ('&ESVA' EQ '').NO_ESVA   | If ESVA kwd.\n&#_IDESVA      SETC '&ESVA'                  |   Pick up its value.\n.NO_ESVA       ANOP                          | EndIf.\n               AIF ('&SPEPNAME' EQ '').NO_EPN  If SPEPNAME kwd.\n&#_IDEPN       SETC '&SPEPNAME'              |   Pick up its value.\n.NO_EPN        ANOP                          | EndIf.\n               AIF ('&SPEPA' EQ '').NO_EPA   | If SPEPA keyword.\n&#_IDEPA       SETC '&SPEPA'                 |   Pick up its value.\n.NO_EPA        ANOP                          | EndIf.\n               AIF ('&SPTOKEN' EQ '').NO_TKN | If SPTOKEN keyword.\n&#_IDTKN       SETC '&SPTOKEN'               |   Pick up its value.\n.NO_TKN        ANOP                          | EndIf.\n               AIF ('&ERRMAC' EQ '').NO_EMC  | If ERRMAC keyword.\n&#_IDEMC       SETC '&ERRMAC'                |   Pick up its value.\n.NO_EMC        ANOP                          | EndIf.\n.*\n.* Verify that all required ID values were actually obtained.\n.*\n               AIF (NOT (&B_IDMAC  AND ('&#_IDMAC'    EQ ''))).V10\n&#_IDCODE      SETC  'ID'\n               MNOTE 8,'ID keyword is required, but was not specified.'\n               MEXIT\n.V10           AIF (NOT (&B_IDESID AND ('&#_IDESID'   EQ ''))).V20\n&#_IDCODE      SETC  'ESID'\n               AGO   .KWDREQ\n.V20           AIF (NOT (&B_IDESVA AND ('&#_IDESVA'   EQ ''))).V30\n&#_IDCODE      SETC  'ESVA'\n               AGO   .KWDREQ\n.V30           AIF (NOT (&B_EPN    AND ('&#_IDEPN'    EQ ''))).V40\n&#_IDCODE      SETC  'SPEPNAME'\n               AGO   .KWDREQ\n.V40           AIF (NOT (&B_EPA    AND ('&#_IDEPA'    EQ ''))).V50\n&#_IDCODE      SETC  'SPEPA'\n               AGO   .KWDREQ\n.V50           AIF (NOT (&B_TKN    AND ('&#_IDTKN'    EQ ''))).V55\n&#_IDCODE      SETC  'SPTOKEN'\n               AGO   .KWDREQ\n.V55           AIF (NOT (&B_EMC    AND ('&#_IDEMC'    EQ ''))).V60\n&#_IDCODE      SETC  'ERRMAC'\n               AGO   .KWDREQ\n.V60           MEXIT\n.KWDREQ        MNOTE 8,'Keyword &#_IDCODE is required if ID not specifi+\n               ed.'\n.MEXIT         MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SRV##LI": {"ttr": 9219, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x02\\x00\\x00V\\x01\\x11)\\x9f\\x01\\x11)\\x9f\\t'\\x01\\x13\\x01\\x13\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@\"", "ispf": {"version": "02.00", "flags": 0, "createdate": "2011-10-26T00:00:00", "modifydate": "2011-10-26T09:27:56", "lines": 275, "newlines": 275, "modlines": 0, "user": "CLEMSON"}, "text": "*---------------------------------------------------------------------*\n*  Copyright 2011 by Clemson University Research Foundation           *\n*                                                                     *\n*  Licensed under the Apache License, Version 2.0 (the \"License\");    *\n*  you may not use this file except in compliance with the License.   *\n*  You may obtain a copy of the License in this library as member     *\n*  $LICENSE, or from                                                  *\n*                                                                     *\n*      http://www.apache.org/licenses/LICENSE-2.0                     *\n*                                                                     *\n*  Unless required by applicable law or agreed to in writing,         *\n*  software distributed under the License is distributed on an \"AS    *\n*  IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either    *\n*  express or implied.  See the License for the specific language     *\n*  governing permissions and limitations under the License.           *\n*---------------------------------------------------------------------*\n*---------------------------------------------------------------------*\n*\n*  Copy File:  ##LIST\n*\n*  Purpose:    General list manipulation macros.\n*\n*  Change\n*  History:    03/38/90 MJM - New\n*\n*---------------------------------------------------------------------*\n*\n*  Some notes about the list structures defined in this member.\n*\n*  o The offsets of the various fields are hardcoded in the list\n*    manipulation macros.\n*  o All lists are doubly-linked non-circular lists, where the list\n*    header forms the first and last nodes in the list.\n*  o A list header begins with the following three pointers:\n*    (Head,Tail,TailPred):\n*    1) For the head-node, (Head,Tail) are the Successor & Predecessor\n*       pointers where Head points to the first node in the list and\n*       Tail is zeros since there is no predecessor node to the header.\n*    2) For the tail-node, (Tail,TailPred) are the Successor &\n*       Predecessor pointers where Tail is zeros since there is no\n*       successor to the tail node and TailPred points to the last node\n*       in the list.\n*    3) The Successor field of the last node in a list points to Tail\n*       and the Predecessor field of the first node in a list points\n*       to Head.  For an empty list, Head points to Tail and TailPred\n*       points to Head.  Tail is, and must *always* be, zeros.\n*\n*       tag  LI_HEADER  DSECT=(YES|NO)\n*       tag  LI_NODE    DSECT=(YES|NO)\n*\n*       LI_INIT      LIST=list\n*       LI_INSERT    NODE=node,PRED=pred\n*       LI_INSERTPRI LIST=list,NODE=node\n*       LI_REMOVE    NODE=node\n*       LI_ADDHEAD   LIST=list,NODE=node\n*       LI_ADDTAIL   LIST=list,NODE=node\n*       LI_REMHEAD   LIST=list\n*       LI_REMTAIL   LIST=list\n*\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   LI_HEADER                                                  *\n* Purpose: Generate the data structure for a list header.             *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n&NAME    LI_HEADER &DSECT=NO\n              AIF       ('&NAME' NE '').OKAY\n              MNOTE     8,'A label must be specified for this macro.'\n.OKAY         LCLC      &P\n&P            SETC      '&NAME._'\n              AIF       ('&DSECT' EQ 'YES').GEN_DSECT\n&NAME.        DS  0F             | Start of a list header:\n              AGO       .GEN_FIELDS\n.GEN_DSECT    ANOP\n&NAME.        DSECT              | Start of a list header:\n.GEN_FIELDS   ANOP\n&P.HEAD       DC  A(&P.TAIL)     |   -> First node in list.\n&P.TAIL       DC  A(0)           |   Always zeros.\n&P.TAILPRED   DC  A(&P.HEAD)     |   -> Last node in list.\n&NAME._L      EQU *-&NAME.       |   Length of a list header.\n              MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   LI_NODE                                                    *\n* Purpose: Generate the data structure for a list node.               *\n*                                                                     *\n*---------------------------------------------------------------------*\n              MACRO\n&NAME         LI_NODE &DSECT=NO\n              AIF       ('&NAME' NE '').GEN_NAME\n              MNOTE     8,'A label must be specified for this macro.'\n              MEXIT\n.GEN_NAME     AIF       ('&DSECT' EQ 'YES').GEN_DSECT\n&NAME.        DS  0F             | Start of a list node:\n              AGO       .PAST_NAME\n.GEN_DSECT    ANOP\n&NAME.        DSECT              | Start of a list node:\n.PAST_NAME    LCLC      &P\n&P            SETC      '&NAME._'\n&P.SUCC       DS  A              |   -> Next node in list.\n&P.PRED       DS  A              |   -> Previous node in list.\n&P.TYPE       DS  X              |   Application-defined type-value.\n&P.PRIORITY   DS  X              |   Unsigned priority of this node.\n&P.CONTENT    DS  0C             |   Contents of this node start here.\n              MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   LI_INIT                                                    *\n* Purpose: Initialize a list-header.                                  *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         LI_INIT &LIST=\n              AIF       ('&LIST' NE '').OKAY\n              MNOTE     8,'A list address must be specified.'\n.OKAY         ANOP\n*                                   | Initialize a list to empty.\n              LA  R15,&LIST         |   Point to list HEAD field.\n              LA  R14,4(,R15)       |   Point to list TAIL field.\n              ST  R14,0(,R15)       |   Set HEAD     = A(TAIL).\n              XC  4(4,R15),4(R15)   |   Set TAIL     = A(0).\n              ST  R15,4(,R14)       |   Set TAILPRED = A(HEAD).\n              MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   LI_INSERT                                                  *\n* Purpose: Insert a node after the specified predecessor.             *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         LI_INSERT &NODE=,&PRED=\n              AIF       ('&NODE' EQ '').REQUIRED\n              AIF       ('&PRED' EQ '').REQUIRED\n              AGO       .OKAY\n.REQUIRED     MNOTE     8,'NODE and PRED must be specified.'\n.OKAY         ANOP\n*                                     | Add a node to a list:\n              ##LA R15,&NODE          |   Point to the NODE to add.\n              ##LA R14,&PRED          |   Point to the PRED node.\n              MVC  0(4,R15),0(R14)    |   Set NODE.Succ = PRED.Succ.\n              ST   R14,4(,R15)        |   Set NODE.Pred = A(PRED).\n              ST   R15,0(,R14)        |   Set PRED.Succ = A(NODE).\n              L    R14,0(,R15)        |   Point to NODE.Succ.\n              ST   R15,4(,R14)        |   Set SUCC.Pred = A(NODE).\n              MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   LI_INSERTPRI                                               *\n* Purpose: Insert a node in a list by priority.                       *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         LI_INSERTPRI &LIST=,&NODE=\n              AIF       ('&LIST' EQ '').REQUIRED\n              AIF       ('&NODE' EQ '').REQUIRED\n              AGO       .OKAY\n.REQUIRED     MNOTE     8,'LIST and NODE must be specified.'\n.OKAY         ANOP\n*                                     | Insert a node by priority:\n              ##LA R15,&NODE          |   Point to the NODE to add.\n              ##LA R14,&LIST          |   Point to the LIST header.\n              L    R14,0(,R14)        |   Point to the first node.\n              SLR  R0,R0              |   R0 := end-of-list value.\n              LOOP WHILE,(CL,R0,NE,0(R14)) Loop while not @ TAIL.\n                LEAVE LOOP=*,(CLC,9(1,R14),LT,9(R15)) Leave on low pri.\n                L     R14,0(,R14)     |             Point to successor.\n              ENDLOOP WHILE           |   EndLoop.\n              ST   R14,0(,R15)        |   Set NODE.Succ = A(SUCC).\n              MVC  4(4,R15),4(R14)    |   Set NODE.Pred = SUCC.Pred.\n              ST   R15,4(,R14)        |   Set SUCC.Pred = A(NODE).\n              L    R14,4(,R15)        |   Point to NODE.Pred.\n              ST   R15,0(,R14)        |   Set PRED.Succ = A(NODE).\n              MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   LI_REMOVE                                                  *\n* Purpose: Remove the specified node from the list it is in.          *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         LI_REMOVE &NODE=\n              AIF       ('&NODE' EQ '').REQUIRED\n              AGO       .OKAY\n.REQUIRED     MNOTE     8,'NODE must be specified.'\n.OKAY         ANOP\n*                                     | Remove a node from its list:\n              ##LA R15,&NODE          |   Point to the NODE to remove.\n              L    R14,4(,R15)        |   Point to the PRED node.\n              MVC  0(4,R14),0(R15)    |   Set PRED.Succ = NODE.Succ.\n              L    R14,0(,R15)        |   Point to NODE.Succ.\n              MVC  4(4,R14),4(R15)    |   Set SUCC.Pred = NODE.Pred.\n              MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   LI_ADDHEAD                                                 *\n* Purpose: Insert a new node at the head of a list.                   *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         LI_ADDHEAD &LIST=,&NODE=\n              AIF       ('&LIST' EQ '').REQUIRED\n              AIF       ('&NODE' EQ '').REQUIRED\n              AGO       .OKAY\n.REQUIRED     MNOTE     8,'NODE and LIST must be specified.'\n.OKAY         ANOP\n*                                     | Add node to head of list:\n              ##LA R15,&NODE          |   Point to the NODE to add.\n              ##LA R14,&LIST          |   Point to the LIST header.\n              MVC  0(4,R15),0(R14)    |   Set NODE.Succ = HEAD.\n              ST   R15,0(R14)         |   Set HEAD      = A(NODE).\n              L    R14,0(,R15)        |   Point to NODE.Succ.\n              MVC  4(4,R15),4(R14)    |   Set NODE.Pred = SUCC.Pred.\n              ST   R15,4(,R14)        |   Set SUCC.Pred = A(NODE).\n              MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   LI_ADDTAIL                                                 *\n* Purpose: Insert a new node at the tail of a list.                   *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         LI_ADDTAIL &LIST=,&NODE=\n              AIF       ('&LIST' EQ '').REQUIRED\n              AIF       ('&NODE' EQ '').REQUIRED\n              AGO       .OKAY\n.REQUIRED     MNOTE     8,'NODE and LIST must be specified.'\n.OKAY         ANOP\n*                                     | Add node to tail of list:\n              ##LA R15,&NODE          |   Point to the NODE to add.\n              ##LA R14,&LIST          |   Point to the LIST header.\n              MVC  4(4,R15),8(R14)    |   Set NODE.Pred = TAILPRED.\n              ST   R15,8(R14)         |   Set TAILPRED  = A(NODE).\n              L    R14,4(,R15)        |   Point to NODE.Pred.\n              MVC  0(4,R15),0(R14)    |   Set NODE.Succ = PRED.Succ.\n              ST   R15,0(,R14)        |   Set PRED.Succ = A(NODE).\n              MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   LI_REMHEAD                                                 *\n* Purpose: Remove the first node in a list.                           *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         LI_REMHEAD &LIST=\n              AIF       ('&LIST' EQ '').REQUIRED\n              AGO       .OKAY\n.REQUIRED     MNOTE     8,'LIST must be specified.'\n.OKAY         ANOP\n*                                     | Remove node from head of list:\n              ##LA R15,&LIST          |   Point to the specified LIST.\n              L    R14,0(,R15)        |   Point to the first NODE.\n              MVC  0(4,R15),0(R14)    |   Set HEAD = NODE.Succ.\n              L    R15,0(,R14)        |   Point to node's SUCC.\n              MVC  4(4,R15),4(R14)    |   Set SUCC.Pred = NODE.Pred.\n              MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   LI_REMTAIL                                                 *\n* Purpose: Remove the last node in a list.                            *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         LI_REMTAIL &LIST=\n              AIF       ('&LIST' EQ '').REQUIRED\n              AGO       .OKAY\n.REQUIRED     MNOTE     8,'LIST must be specified.'\n.OKAY         ANOP\n*                                     | Remove node from tail of list:\n              ##LA R15,&LIST          |   Point to the specified LIST.\n              L    R14,8(,R15)        |   Point to the last NODE.\n              MVC  8(4,R15),4(R14)    |   Set TAILPRED = NODE.Pred.\n              L    R15,4(,R14)        |   Point to node's PRED.\n              MVC  0(4,R15),0(R14)    |   Set PRED.Succ = NODE.Succ.\n              MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SRV##RC": {"ttr": 9224, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x02\\x00\\x00V\\x01\\x11)\\x9f\\x01\\x11)\\x9f\\t'\\x00,\\x00,\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@\"", "ispf": {"version": "02.00", "flags": 0, "createdate": "2011-10-26T00:00:00", "modifydate": "2011-10-26T09:27:56", "lines": 44, "newlines": 44, "modlines": 0, "user": "CLEMSON"}, "text": "*---------------------------------------------------------------------*\n*  Copyright 2011 by Clemson University Research Foundation           *\n*                                                                     *\n*  Licensed under the Apache License, Version 2.0 (the \"License\");    *\n*  you may not use this file except in compliance with the License.   *\n*  You may obtain a copy of the License in this library as member     *\n*  $LICENSE, or from                                                  *\n*                                                                     *\n*      http://www.apache.org/licenses/LICENSE-2.0                     *\n*                                                                     *\n*  Unless required by applicable law or agreed to in writing,         *\n*  software distributed under the License is distributed on an \"AS    *\n*  IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either    *\n*  express or implied.  See the License for the specific language     *\n*  governing permissions and limitations under the License.           *\n*---------------------------------------------------------------------*\n*---------------------------------------------------------------------*\n*\n*  Macro:      SRV##RC\n*\n*  Purpose:    Test named service processor condition code.\n*\n*  Change\n*  History:    11/25/89 MJM - New\n*\n*---------------------------------------------------------------------*\n            MACRO\n&NAME       SRV##RC &EXPR,&S=,&F=,&L=\n            LCLC    &V_RCNAME\n            AIF     (N'&EXPR EQ 1).DOIT\n            MNOTE   8,'Specify only the Service processor condition cod+\n               e name.'\n            MEXIT\n.DOIT       ANOP\n&V_RCNAME   SETC    '&EXPR(1)'(2,K'&EXPR(1)-1)\n            GBLA    &(&V_RCNAME)\n            AIF     ('&(&V_RCNAME)' EQ '0').LTR\n&NAME       CH      R15,=H'&(&V_RCNAME)'   | Test return-code's value.\n            ##COND  EQ,S=&S,F=&F,L=&L\n            MEXIT\n.LTR        ANOP\n&NAME       LTR     R15,R15                | Test for zero return-code.\n            ##COND  Z,S=&S,F=&F,L=&L\n            MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SRVCC": {"ttr": 9226, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x02\\x00\\x00V\\x01\\x11)\\x9f\\x01\\x11)\\x9f\\t'\\x01S\\x01S\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@\"", "ispf": {"version": "02.00", "flags": 0, "createdate": "2011-10-26T00:00:00", "modifydate": "2011-10-26T09:27:56", "lines": 339, "newlines": 339, "modlines": 0, "user": "CLEMSON"}, "text": "*---------------------------------------------------------------------*\n*  Copyright 2011 by Clemson University Research Foundation           *\n*                                                                     *\n*  Licensed under the Apache License, Version 2.0 (the \"License\");    *\n*  you may not use this file except in compliance with the License.   *\n*  You may obtain a copy of the License in this library as member     *\n*  $LICENSE, or from                                                  *\n*                                                                     *\n*      http://www.apache.org/licenses/LICENSE-2.0                     *\n*                                                                     *\n*  Unless required by applicable law or agreed to in writing,         *\n*  software distributed under the License is distributed on an \"AS    *\n*  IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either    *\n*  express or implied.  See the License for the specific language     *\n*  governing permissions and limitations under the License.           *\n*---------------------------------------------------------------------*\nSRVCC     TITLE 'Example:  Cheap Calculator Service Processor'\n*---------------------------------------------------------------------*\n*\n*  Copyright (C) 2011 Clemson University\n*\n*  Program     SRVCC\n*\n*  Abstract    This code is intended to show how service processors\n*              are structured and what the major pieces are, without\n*              any pesky meaningful, functional code in the way.\n*\n*  Inputs:\n*      Parameters  On entry R1 points to the following parameter list:\n*      Files         Standard service processor parameter list, see\n*                    dsect \"parmlist\" below.\n*      Other       None\n*\n*  Outputs:\n*      Returncodes See errexits, member srvccmac\n*      Messages    None\n*      Files       None\n*      Other       None\n*\n*  PROGRAM     Reentrant, problem key and state, standard linkage,\n*  ATTRIBUTES  non-authorized, AMODE(24), RMODE(24)\n*\n*  Special     See related documentation for description of\n*  Notes       components and how they work together.\n*              Requires\n*\n*  Change\n*  History     10/17/11 jcb - Added documentation block\n*              __/__/__ ___\n*              __/__/__ ___\n*\n*  Method of   Standard service processor.\n*  Operation\n*\n*\n*---------------------------------------------------------------------*\n         EJECT\n SMLIST CONVERT=YES                   |\n title \"SRVCC -- The Cheap Calculator Service Processor\"\n print off                            |\n copy  smsyms                         | Structured Macros symbols.\n copy  smpucond                       | DEFUCOND user conditions.\n copy  srvesmac                       | Environment support symbols.\n copy  srvccmac                       | Cheap Calculator symbols.\n print on,gen                         |\n es_id         id=ES,                 |                                *\n               spepa=pwa_ES_epa,      |                                *\n               sptoken=pwa_ES_token,  |                                *\n               esva=pwaaesv           |\n       space 1                        |\n title \"SRVCC -- Initialization\"      |\n block name=SRVCC,type=program,amode=31,rmode=any,                     *\n               options=(*srvprc,long,                                  *\n               (parms,(using,r11),(count,pwa_number_of_parms),vl)),    *\n               parmmap=parmlist,basereg=(r12,r9),                      *\n               subopts=(*swa,loadbase)\n* *-------------------------------------------------------------------*\n* * Ensure that at least the minimum and no more than the maximum\n* * number of parameters were passed in the parameter list.\n* *-------------------------------------------------------------------*\n  l     r0,pwa_number_of_parms        | Save number of parms.\n  errexit (ch,r0,lt,=y(prm_min_#)),or,(c,r0,gt,=a(prm_max_#)),         +\n               code=&CC_invalid_number_of_parms\n  l     r1,prm_functioncode           | Load the function code into\n  l     r1,0(,r1)                     |   a register for testing.\n* *-------------------------------------------------------------------*\n* * If the function code is something other than start, make sure that\n* * the PWA contains the eye-catcher string and the correct value for\n* * CC_ID.   If not, then the CC_ID passed in is garbage.\n* *-------------------------------------------------------------------*\n  if (c,r1,ne,=f'&CC_start')          | If not startup function then\n   errexit ((clc,pwa_visual,ne,psd_eyecatcher),or,                     *\n               (c,r13,ne,pwa_CC_id)), |                                *\n               code=&CC_invalid_CC_id |  go off and croak.\n  endif                               | Endif.\n   title \"SRVCC -- CC_Start Function\" |\n* *-------------------------------------------------------------------*\n* * Select the code to process the function.\n* *-------------------------------------------------------------------*\n  caseblk reg=r1                      | Start of function case block.\n  space 1                             |\n*  *------------------------------------------------------------------*\n*  * Start function.\n*  *------------------------------------------------------------------*\n   case &CC_start                     |  Start function.\n*   *-----------------------------------------------------------------*\n*   * Set the eyecatcher and the CC_ID fields.   These are checked\n*   * each time the CC server is entered to avoid integrity problems.\n*   *-----------------------------------------------------------------*\n    mvc   pwa_visual,psd_eyecatcher   |   Set the eyecatcher and the\n    st    r13,pwa_CC_id               |   CC_ID are for validity checks\n    xc    pwa_clear_start(pwa_clear_length),pwa_clear_start\n*   *-----------------------------------------------------------------*\n*   * Make sure that a valid number of parameters are specified.\n*   *-----------------------------------------------------------------*\n    l     r3,pwa_number_of_parms      |   Load r3 with number of parms.\n    errexit    (ch,r3,lt,=y(prm_start_min_#)),or,   Error if out       +\n               (ch,r3,gt,=y(prm_start_max_#)),      of bounds.         +\n               code=&CC_invalid_number_of_parms\n    space 1                           |\n    l    r1,pwaaesv                   | Load pointer to ESV.\n    using esv,r1                      |\n    mvc   pwa_es_epa,esvesepa         | Copy EPA and token addresses\n    mvc   pwa_es_token,esvestkn       |  for current Env. Support sess.\n    drop  r1                          |\n    slr   r0,r0                       |\n    st    r0,pwa_display              | Clear the \"display\".\n title \"SRVCC -- CC_Terminate Function\"\n*  *------------------------------------------------------------------*\n*  *  CC_Terminate function.\n*  *------------------------------------------------------------------*\n   case &CC_Terminate                 |\n    l     r3,pwa_number_of_parms      |   Load r3 with number of parms.\n    errexit    (ch,r3,lt,=y(prm_terminate_#)),  Error if not correct.  +\n               code=&CC_invalid_number_of_parms\n    smctrl  freepwa=yes               |\n title \"SRVCC -- CC_Add Function\"     |\n*  *------------------------------------------------------------------*\n*  *  CC_Add function.\n*  *------------------------------------------------------------------*\n   case &CC_Add                       | Add function.\n    l     r3,pwa_number_of_parms      |   Load r3 with number of parms.\n    errexit    (ch,r3,ne,=y(prm_add_#)),  Error if not correct.        +\n               code=&CC_invalid_number_of_parms\n    l32   r1,prm_add_value            |  Get pointer to value to add\n    errexit (z),code=&CC_Parameter_Missing  Error if pointer missing\n    l     r1,0(r1)                    |  Get the value\n    a     r1,pwa_display              |  Add current display contents\n    st    r1,pwa_display              |  Update the display\n    l32   r2,prm_add_display          |  Get addr of caller's display\n    errexit (z),code=&CC_Parameter_Missing  Error if pointer missing\n    st    r1,0(r2)                    |  Return display to caller.\n    errexit (c,r1,gt,=f'99999999'),   |                                *\n               code=&CC_Overflow      |\n title \"SRVCC -- CC_Subtract Function\"\n*  *------------------------------------------------------------------*\n*  *  CC_Subtract function.\n*  *------------------------------------------------------------------*\n   case &CC_Subtract                  | Subtract function.\n    l     r3,pwa_number_of_parms      |   Load r3 with number of parms.\n    errexit    (ch,r3,ne,=y(prm_subtract_#)), Error if not correct.    +\n               code=&CC_invalid_number_of_parms\n    l32   r1,prm_Subtract_value       |  Get pointer to value to subtr\n    errexit (z),code=&CC_Parameter_Missing  Error if pointer missing\n    l     r1,0(r1)                    |  Get the value\n    s     r1,pwa_display              |  Subtract current display\n    st    r1,pwa_display              |  Update the display\n    l32   r2,prm_subtract_display     |  Get addr of caller's display\n    errexit (z),code=&CC_Parameter_Missing  Error if pointer missing\n    st    r1,0(r2)                    |  Return display to caller.\n    errexit (c,r1,lt,=f'-99999999'),  |                                *\n               code=&CC_Overflow      |\n title \"SRVCC -- CC_Multiply Function\"\n*  *------------------------------------------------------------------*\n*  *  CC_Multiply function.\n*  *------------------------------------------------------------------*\n   case &CC_Multiply                  | multiply function.\n    l     r3,pwa_number_of_parms      |   Load r3 with number of parms.\n    errexit    (ch,r3,ne,=y(prm_multiply_#)), Error if not correct.    +\n               code=&CC_invalid_number_of_parms\n    l32   r1,prm_multiply_value       |  Get pointer to value to mult\n    errexit (z),code=&CC_Parameter_Missing  Error if pointer missing\n    l     r1,0(r1)                    |  Get the value\n    sr    r0,r0                       |  Clear reg for multiply\n    m     r0,pwa_display              |  multiply current display\n    errexit (c,r1,gt,=f'99999999'),or,(treg,r0,nz),                    *\n               code=&CC_Overflow      |\n    st    r1,pwa_display              |  Update the display\n    l32   r2,prm_multiply_display     |  Get addr of caller's display\n    errexit (z),code=&CC_Parameter_Missing  Error if pointer missing\n    st    r1,0(r2)                    |  Return display to caller.\n title \"SRVCC -- CC_Divide Function\"  |\n*  *------------------------------------------------------------------*\n*  *  CC_Divide function.\n*  *------------------------------------------------------------------*\n   case &CC_Divide                    | divide function.\n    l     r3,pwa_number_of_parms      |   Load r3 with number of parms.\n    errexit    (ch,r3,ne,=y(prm_divide_#)), Error if not correct.      +\n               code=&CC_invalid_number_of_parms\n    l32   r1,prm_divide_value         |  Get pointer to value to mult\n    errexit (z),code=&CC_Parameter_Missing  Error if pointer missing\n    l     r3,pwa_display              |  Get the value\n    sr    r2,r2                       |  Clear reg for divide\n    d     r2,0(r1)                    |  divide current display\n    st    r2,pwa_display              |  Update the display\n    l32   r3,prm_divide_display       |  Get addr of caller's display\n    errexit (z),code=&CC_Parameter_Missing  Error if pointer missing\n    st    r2,0(r3)                    |  Return display to caller.\n title \"SRVCC -- CC_Clear Function\"   |\n*  *------------------------------------------------------------------*\n*  *  CC_Clear function.\n*  *------------------------------------------------------------------*\n   case &CC_Clear                     | Clear function.\n    l     r3,pwa_number_of_parms      |   Load r3 with number of parms.\n    errexit    (ch,r3,ne,=y(prm_clear_#)),  Error if not correct.      +\n               code=&CC_invalid_number_of_parms\n    sr    r0,r0                       |\n    st    r0,pwa_display              |\n  endcase                             |\n endblk rc=0                          |\n title \"SRVCC - General Error Exit\"   |\n block type=errexit                   |\n* *-------------------------------------------------------------------*\n* * Save module/offset, registers, return-code.\n* *-------------------------------------------------------------------*\n  stm   r0,r15,gdiregs                | Save registers at time of error\n  sm_lal r0,srvcc+4                   | Point to module identification.\n  st    r0,gdimodid                   | Save in general debug area.\n  mvc   gdirc,0(r14)                  | Copy return code.\n  sl    r14,=a(srvcc)                 | Calculate offset at time of err\n  sth   r14,gdioffst                  | Save in debug area.\n  l     r2,pwaaesv                    | Point r2 to ESV.\n  using esv,r2                        | Establish base for ESV.\n  callx esvesepa,(esvestkn,&es_save_debug_info,&es_debug_id_gdi,gdi)\n* *-------------------------------------------------------------------*\n* * Look at the error code.  If add'l information would be useful,\n* * stuff into the debug area.\n* *-------------------------------------------------------------------*\n  lh    r15,gdirc                     | Get return code.\n  caseblk reg=r15,mult=1              | Case on return-code.\n    case &CC_invalid_function         |\n      callx esvesepa,(esvestkn,&es_save_debug_info,&es_debug_id_text,  *\n               psd_invalid_function,=a(l'psd_invalid_function))\n    case &CC_invalid_number_of_parms  |\n      callx esvesepa,(esvestkn,&es_save_debug_info,&es_debug_id_text,  *\n               psd_invalid_#_parms,=a(l'psd_invalid_#_parms))\n    case &CC_invalid_CC_ID            |\n      callx esvesepa,(esvestkn,&es_save_debug_info,&es_debug_id_text,  *\n               psd_invalid_CC_ID,=a(l'psd_invalid_CC_ID))\n  endcase                             | EndCase.\n  drop r2                             |\n* *-------------------------------------------------------------------*\n* * Set the return-code and exit.\n* *-------------------------------------------------------------------*\n  lh    r15,gdirc                     | Set return code.\n endblk rc=(r15)                      |\n title \"SRVCC -- Constants\"           |\n         psd   ,                      |\npsd_eyecatcher  dc    cl8'CHEAP_SP'   | So everyone will know ...\npsd_invalid_function     dc  c\"Unsupported function.\"\npsd_invalid_#_parms      dc  c\"Invalid number of parameters.\"\npsd_invalid_cc_id        dc  c\"Invalid token provided.\"\npsd_overflow             dc  c\"Output value is too large for requested *\n               format.\"               |\npsd_undetermined_error   dc  c\"Undetermined error.\"\n         ltorg ,                      |\n         endpsd ,                     |\n title \"SRVCC -- Parameter List DSECT\"\nparmlist          dsect ,             |\nprm_CC_id         ds a                | CC_identifier === PWA base\nprm_functioncode  ds a                | Function to be performed\nprm_min_#         equ (*-parmlist)/4  |\nprm_function_dept equ *               | Function-dependent parameters\n*---------------------------------------------------------------------*\n*                  Start function parameters\n*---------------------------------------------------------------------*\n                  org prm_function_dept\nprm_start_esv     ds a                | Environment Support Vector.\nprm_start_min_#   equ (*-parmlist)/4  |\nprm_start_max_#   equ (*-parmlist)/4  |\n*---------------------------------------------------------------------*\n*                 Terminate function parameters\n*---------------------------------------------------------------------*\n               org prm_function_dept  |\nprm_terminate_#   equ (*-parmlist)/4  |\n*---------------------------------------------------------------------*\n*                 CC_Add function parameters\n*---------------------------------------------------------------------*\n               org prm_function_dept  |\nprm_add_value     ds    f             | Value to add to display.\nprm_add_display   ds    f             | Where to store updated display.\nprm_add_#         equ (*-parmlist)/4  |\n*---------------------------------------------------------------------*\n*                 CC_Subtract function parameters\n*---------------------------------------------------------------------*\n               org prm_function_dept  |\nprm_subtract_value ds   f             | Value to subtract from display.\nprm_subtract_display ds f             | Where to store updated display.\nprm_subtract_#    equ (*-parmlist)/4  |\n*---------------------------------------------------------------------*\n*                 CC_Multiply function parameters\n*---------------------------------------------------------------------*\n               org prm_function_dept  |\nprm_multiply_value ds   f             | Value to multiply to display.\nprm_multiply_display ds f             | Where to store updated display.\nprm_multiply_#                equ (*-parmlist)/4\n*---------------------------------------------------------------------*\n*                 CC_Divide function parameters\n*---------------------------------------------------------------------*\n               org prm_function_dept  |\nprm_divide_value  ds    f             | Value to divide to display.\nprm_divide_display ds   f             | Where to store updated display.\nprm_divide_#       equ (*-parmlist)/4 |\n*---------------------------------------------------------------------*\n*                 CC-Clear function parameters\n*---------------------------------------------------------------------*\nprm_clear_#        equ (*-parmlist)/4 |\n                org ,                 |\nprm_max_#          equ (*-parmlist)/4 |\n*\n title \"SRVCC -- Environment Support Vector DSECT\"\n          es_esv ,                    |\n title \"SRVCC -- Program Work Area\"   |\n               PWA                    |\npwa_area       ds    0f               | Beginning of visible PWA stg.\npwa_visual     ds    cl8              | Character string 'CHEAP_SP'\npwa_CC_id      ds    a                | Pointer to program work area.\npwa_clear_start equ  *                | This area cleared by CC_START.\npwa_ES_epa     ds    f                | Environment Support EPA.\npwa_ES_token   ds    f                | Environment Support PWA token.\npwa_ESV        ds    f                | Environment Support vector addr\n*                                     |  is that spec'd by SizeLength.\npwa_clear_end  equ  *                 | End area cleared by CC_START.\npwa_clear_length   equ   pwa_clear_end-pwa_clear_start\npwa_number_of_parms  ds  f            |\npwa_display    ds   f                 |\n               es_gdi dsect=no        | General debugging information.\n               endpwa ,               |\n               end   ,                |\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SRVCCMAC": {"ttr": 9476, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x02\\x00\\x00V\\x01\\x11)\\x9f\\x01\\x11)\\x9f\\t'\\x01m\\x01m\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@\"", "ispf": {"version": "02.00", "flags": 0, "createdate": "2011-10-26T00:00:00", "modifydate": "2011-10-26T09:27:56", "lines": 365, "newlines": 365, "modlines": 0, "user": "CLEMSON"}, "text": "*---------------------------------------------------------------------*\n*  Copyright 2011 by Clemson University Research Foundation           *\n*                                                                     *\n*  Licensed under the Apache License, Version 2.0 (the \"License\");    *\n*  you may not use this file except in compliance with the License.   *\n*  You may obtain a copy of the License in this library as member     *\n*  $LICENSE, or from                                                  *\n*                                                                     *\n*      http://www.apache.org/licenses/LICENSE-2.0                     *\n*                                                                     *\n*  Unless required by applicable law or agreed to in writing,         *\n*  software distributed under the License is distributed on an \"AS    *\n*  IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either    *\n*  express or implied.  See the License for the specific language     *\n*  governing permissions and limitations under the License.           *\n*---------------------------------------------------------------------*\n*---------------------------------------------------------------------*\n*        Cheap Calculator Service Processor Symbols And Macros\n*---------------------------------------------------------------------*\n*  Service processor module name.\n*---------------------------------------------------------------------*\n   GBLC   &CHEAP_CALCULATOR\n&CHEAP_CALCULATOR  SETC   '''SRVCC   '''\n*---------------------------------------------------------------------*\n*  Function symbols.\n*---------------------------------------------------------------------*\n   GBLA   &CC_START\n   GBLA   &CC_TERMINATE\n   GBLA   &CC_ADD\n   GBLA   &CC_SUBTRACT\n   GBLA   &CC_MULTIPLY\n   GBLA   &CC_DIVIDE\n   GBLA   &CC_CLEAR\n&CC_START      SETA  1\n&CC_TERMINATE  SETA  2\n&CC_ADD        SETA  3\n&CC_SUBTRACT   SETA  4\n&CC_MULTIPLY   SETA  5\n&CC_DIVIDE     SETA  6\n&CC_CLEAR      SETA  7\n*---------------------------------------------------------------------*\n*  Return code symbols.\n*---------------------------------------------------------------------*\n  GBLA    &CC_INVALID_CC_ID\n  GBLA    &CC_INVALID_NUMBER_OF_PARMS\n  GBLA    &CC_INVALID_FUNCTION\n  GBLA    &CC_OVERFLOW\n  GBLA    &CC_PARAMETER_MISSING\n&CC_INVALID_CC_ID           SETA  1\n&CC_INVALID_NUMBER_OF_PARMS SETA  2\n&CC_INVALID_FUNCTION        SETA  3\n&CC_OVERFLOW                SETA  4\n&CC_PARAMETER_MISSING       SETA  5\n*---------------------------------------------------------------------*\n* DEFUCOND macros to facilitate checking return codes.\n*---------------------------------------------------------------------*\n   DEFUCOND MACRO=SRV##RC,NAME=CC_INVALID_CC_ID\n   DEFUCOND MACRO=SRV##RC,NAME=CC_INVALID_NUMBER_OF_PARMS\n   DEFUCOND MACRO=SRV##RC,NAME=CC_INVALID_FUNCTION\n   DEFUCOND MACRO=SRV##RC,NAME=CC_OVERFLOW\n   DEFUCOND MACRO=SRV##RC,NAME=CC_PARAMETER_MISSING\n*---------------------------------------------------------------------*\n*\n*  CC_ID Macro: Establish default values for a specific service\n*               processor and associate them with the specified ID\n*               name.  The values are stored in the following created\n*               global variables, which are used by the other macros:\n*\n*    Variable Name                     Description\n*    -------------  -----------------------------------------------\n*    #$&ID.$#IDMAC  Name of macro that created the ID: CC_ID.\n*    #$&ID.$#ESID   Service processor's Environment Support ID.\n*    #$&ID.$#EPN    Tag for Service processor's Entry Point Name.\n*    #$&ID.$#EPA    Tag for Service processor's Entry Point Address.\n*    #$&ID.$#TKN    Tag for Service processor's Entry Point Token.\n*\n*---------------------------------------------------------------------\n         MACRO\n         CC_ID &ID=,&ESVA=,&SPEPNAME=,&SPEPA=,&SPTOKEN=,&ESID=,        *\n               &SIZELENGTH=\n.*\n.* Invoke SRV##ID to create globals used by all ID's.\n.*\n         SRV##ID SET,                                                  +\n               ID=&ID.,IDMAC=CC_ID,ESID=&ESID.,SPEPNAME=&SPEPNAME,     +\n               SPEPA=&SPEPA,SPTOKEN=&SPTOKEN.\n         MEND\n*---------------------------------------------------------------------*\n*  CC_START Macro.\n*  Format:    CC_START  ID=CC,\n*                       SPEPA=CC_entry_point_address,  (*)\n*                       SPTOKEN=CC_token_address,      (*)\n*                       ESVA=ESV_address               (*)\n*  (*) - These may be defaulted to values set or generated by CC_ID.\n*---------------------------------------------------------------------*\n         MACRO\n         CC_START &ID=,&SPEPA=,&SPTOKEN=,&ESVA=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN\n         GBLA  &CC_START                  SETC in open code.\n.*\n.* Obtain service processor ID values.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN,ESVA),                    +\n               ID=&ID,IDMAC=CC_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN,       +\n               ESVA=&ESVA.\n         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT\n         MVC   &#_IDTKN,=F'0'            Set token to 0 before START.\n.*\n.* Generate the CC_START call.\n.*\n.PARMLIST ANOP ,\n         ##PLIST START\n         ##PLIST PARM,&#_IDTKN\n         ##PLIST PARM,&CC_START\n         ##PLIST PARM,&#_IDESVA\n.PLEND   ##PLIST END,VL\n         CALLX  &#_IDEPA\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*  CC_Terminate Macro.\n*  Format:    CC_TERMINATE  ID=CC,\n*                       SPEPA=CC_entry_point_address,  (*)\n*                       SPTOKEN=CC_token_address,      (*)\n*                       ESVA=ESV_address               (*)\n*  (*) - These may be defaulted to values set or generated by CC_ID.\n*---------------------------------------------------------------------*\n         MACRO\n         CC_TERMINATE &ID=,&SPEPA=,&SPTOKEN=,&ESVA=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN\n         GBLA  &CC_TERMINATE\n.*\n.* Obtain service processor ID values.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN,ESVA),                    +\n               ID=&ID,IDMAC=CC_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN,       +\n               ESVA=&ESVA.\n         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT\n.*\n.* Generate the CC_TERMINATE call.\n.*\n.PARMLIST ANOP ,\n         ##PLIST START\n         ##PLIST PARM,&#_IDTKN\n         ##PLIST PARM,&CC_TERMINATE\n         ##PLIST PARM,&#_IDESVA\n.PLEND   ##PLIST END,VL\n         CALLX  &#_IDEPA\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*  CC_Add Macro.\n*  Format:    CC_ADD    ID=CC,\n*                       SPEPA=CC_entry_point_address,  (*)\n*                       SPTOKEN=CC_token_address,      (*)\n*                       ESVA=ESV_address,              (*)\n*                       VALUE=address | constant | register,\n*                       DISPLAY=address | register\n*  (*) - These may be defaulted to values set or generated by CC_ID.\n*---------------------------------------------------------------------*\n         MACRO\n         CC_ADD  &ID=,&SPEPA=,&SPTOKEN=,&ESVA=,                        +\n               &VALUE=,&DISPLAY=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN\n         GBLA  &CC_ADD\n.*\n.* Obtain service processor ID values.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN,ESVA),                    +\n               ID=&ID,IDMAC=CC_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN,       +\n               ESVA=&ESVA.\n         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT\n.*\n.* Ensure required parameters are present.\n.*\n         AIF  ('&VALUE' EQ '').MISSING\n         AIF  ('&DISPLAY' EQ '').MISSING\n         AIF  (T'&DISPLAY EQ 'N').BADDISP\n.*\n.* Generate the CC_ADD call.\n.*\n.PARMLIST ANOP ,\n         ##PLIST START\n         ##PLIST PARM,&#_IDTKN\n         ##PLIST PARM,&CC_ADD\n         ##PLIST PARM,&#_IDESVA\n         ##PLIST PARM,&VALUE\n         ##PLIST PARM,&DISPLAY\n.PLEND   ##PLIST END,VL\n         CALLX  &#_IDEPA\n         MEXIT\n.MISSING MNOTE 8,'Required parameter(s) missing.'\n         MEXIT\n.BADDISP MNOTE 8,'Invalid address of ''&DISPLAY'' for DISPLAY.'\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*  CC_Subtract Macro.\n*  Format:    CC_SUBTRACT ID=CC,\n*                       SPEPA=CC_entry_point_address,  (*)\n*                       SPTOKEN=CC_token_address,      (*)\n*                       ESVA=ESV_address,              (*)\n*                       VALUE=address | constant | register,\n*                       DISPLAY=address | register\n*  (*) - These may be defaulted to values set or generated by CC_ID.\n*---------------------------------------------------------------------*\n         MACRO\n         CC_SUBTRACT &ID=,&SPEPA=,&SPTOKEN=,&ESVA=,                    +\n               &VALUE=,&DISPLAY=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN\n         GBLA  &CC_SUBTRACT\n.*\n.* Obtain service processor ID values.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN,ESVA),                    +\n               ID=&ID,IDMAC=CC_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN,       +\n               ESVA=&ESVA.\n         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT\n.*\n.* Ensure required parameters are present.\n.*\n         AIF  ('&VALUE' EQ '').MISSING\n         AIF  ('&DISPLAY' EQ '').MISSING\n         AIF  (T'&DISPLAY EQ 'N').BADDISP\n.*\n.* Generate the CC_SUBTRACT call.\n.*\n.PARMLIST ANOP ,\n         ##PLIST START\n         ##PLIST PARM,&#_IDTKN\n         ##PLIST PARM,&CC_SUBTRACT\n         ##PLIST PARM,&#_IDESVA\n         ##PLIST PARM,&VALUE\n         ##PLIST PARM,&DISPLAY\n.PLEND   ##PLIST END,VL\n         CALLX  &#_IDEPA\n         MEXIT\n.MISSING MNOTE 8,'Required parameter(s) missing.'\n         MEXIT\n.BADDISP MNOTE 8,'Invalid address of ''&DISPLAY'' for DISPLAY.'\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*  CC_Multiply Macro.\n*  Format:    CC_MULTIPLY ID=CC,\n*                       SPEPA=CC_entry_point_address,  (*)\n*                       SPTOKEN=CC_token_address,      (*)\n*                       ESVA=ESV_address,              (*)\n*                       VALUE=address | constant | register,\n*                       DISPLAY=address | register\n*  (*) - These may be defaulted to values set or generated by CC_ID.\n*---------------------------------------------------------------------*\n         MACRO\n         CC_MULTIPLY &ID=,&SPEPA=,&SPTOKEN=,&ESVA=,                    +\n               &VALUE=,&DISPLAY=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN\n         GBLA  &CC_MULTIPLY\n.*\n.* Obtain service processor ID values.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN,ESVA),                    +\n               ID=&ID,IDMAC=CC_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN,       +\n               ESVA=&ESVA.\n         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT\n.*\n.* Ensure required parameters are present.\n.*\n         AIF  ('&VALUE' EQ '').MISSING\n         AIF  ('&DISPLAY' EQ '').MISSING\n         AIF  (T'&DISPLAY EQ 'N').BADDISP\n.*\n.* Generate the CC_MULTIPLY call.\n.*\n.PARMLIST ANOP ,\n         ##PLIST START\n         ##PLIST PARM,&#_IDTKN\n         ##PLIST PARM,&CC_MULTIPLY\n         ##PLIST PARM,&#_IDESVA\n         ##PLIST PARM,&VALUE\n         ##PLIST PARM,&DISPLAY\n.PLEND   ##PLIST END,VL\n         CALLX  &#_IDEPA\n         MEXIT\n.MISSING MNOTE 8,'Required parameter(s) missing.'\n         MEXIT\n.BADDISP MNOTE 8,'Invalid address of ''&DISPLAY'' for DISPLAY.'\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*  CC_Divide Macro.\n*  Format:    CC_DIVIDE ID=CC,\n*                       SPEPA=CC_entry_point_address,  (*)\n*                       SPTOKEN=CC_token_address,      (*)\n*                       ESVA=ESV_address,              (*)\n*                       VALUE=address | constant | register,\n*                       DISPLAY=address | register\n*  (*) - These may be defaulted to values set or generated by CC_ID.\n*---------------------------------------------------------------------*\n         MACRO\n         CC_DIVIDE &ID=,&SPEPA=,&SPTOKEN=,&ESVA=,                      +\n               &VALUE=,&DISPLAY=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN\n         GBLA  &CC_DIVIDE\n.*\n.* Obtain service processor ID values.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN,ESVA),                    +\n               ID=&ID,IDMAC=CC_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN,       +\n               ESVA=&ESVA.\n         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT\n.*\n.* Ensure required parameters are present.\n.*\n         AIF  ('&VALUE' EQ '').MISSING\n         AIF  ('&DISPLAY' EQ '').MISSING\n         AIF  (T'&DISPLAY EQ 'N').BADDISP\n.*\n.* Generate the CC_DIVIDE call.\n.*\n.PARMLIST ANOP ,\n         ##PLIST START\n         ##PLIST PARM,&#_IDTKN\n         ##PLIST PARM,&CC_DIVIDE\n         ##PLIST PARM,&#_IDESVA\n         ##PLIST PARM,&VALUE\n         ##PLIST PARM,&DISPLAY\n.PLEND   ##PLIST END,VL\n         CALLX  &#_IDEPA\n         MEXIT\n.MISSING MNOTE 8,'Required parameter(s) missing.'\n         MEXIT\n.BADDISP MNOTE 8,'Invalid address of ''&DISPLAY'' for DISPLAY.'\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*  CC_Clear Macro.\n*  Format:    CC_CLEAR ID=CC,\n*                       SPEPA=CC_entry_point_address,  (*)\n*                       SPTOKEN=CC_token_address,      (*)\n*                       ESVA=ESV_address               (*)\n*  (*) - These may be defaulted to values set or generated by CC_ID.\n*---------------------------------------------------------------------*\n         MACRO\n         CC_CLEAR &ID=,&SPEPA=,&SPTOKEN=,&ESVA=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN\n         GBLA  &CC_CLEAR\n.*\n.* Obtain service processor ID values.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN,ESVA),                    +\n               ID=&ID,IDMAC=CC_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN,       +\n               ESVA=&ESVA.\n         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT\n.*\n.* Generate the CC_CLEAR call.\n.*\n.PARMLIST ANOP ,\n         ##PLIST START\n         ##PLIST PARM,&#_IDTKN\n         ##PLIST PARM,&CC_CLEAR\n         ##PLIST PARM,&#_IDESVA\n.PLEND   ##PLIST END,VL\n         CALLX  &#_IDEPA\n.MEXIT   MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SRVCLRDB": {"ttr": 9483, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x02\\x00\\x00V\\x01\\x11)\\x9f\\x01\\x11)\\x9f\\t'\\x002\\x002\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@\"", "ispf": {"version": "02.00", "flags": 0, "createdate": "2011-10-26T00:00:00", "modifydate": "2011-10-26T09:27:56", "lines": 50, "newlines": 50, "modlines": 0, "user": "CLEMSON"}, "text": "*---------------------------------------------------------------------*\n*  Copyright 2011 by Clemson University Research Foundation           *\n*                                                                     *\n*  Licensed under the Apache License, Version 2.0 (the \"License\");    *\n*  you may not use this file except in compliance with the License.   *\n*  You may obtain a copy of the License in this library as member     *\n*  $LICENSE, or from                                                  *\n*                                                                     *\n*      http://www.apache.org/licenses/LICENSE-2.0                     *\n*                                                                     *\n*  Unless required by applicable law or agreed to in writing,         *\n*  software distributed under the License is distributed on an \"AS    *\n*  IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either    *\n*  express or implied.  See the License for the specific language     *\n*  governing permissions and limitations under the License.           *\n*---------------------------------------------------------------------*\n         MACRO\n*---------------------------------------------------------------------*\n*\n*  MACRO:      SRVCLRDB\n*\n*  TITLE:      Clear Debug Area\n*\n*  PURPOSE:    This macro is used to reset the debug stack pointed to\n*              by the ESV.  It has no parameters.\n*\n*  SPECIAL     This macro is only intended for use by environment\n*  NOTES:      support modules.  The same function is performed\n*              by the CLRDEBUG option of the OS environment block\n*              macro.  Environment support modules can not specify\n*              this option because is has functions that process\n*              the debug stack.\n*\n*  CHANGE\n*  HISTORY:    05/13/87 MGG - NEW\n*              01/10/91 MJM - Added code to check a flag in the ESV\n*                             and skip resetting the debug stack if\n*                             the flag is on.\n*              06/01/06 MGG - Changed BNE to an IF for ARCHLVL=1.\n*\n*---------------------------------------------------------------------*\n         SRVCLRDB &CONDITIONAL=YES\n         SPACE 1\n         AIF   ('&CONDITIONAL' EQ 'YES').CHECK\n         MVC   ESVDBTOP,ESVDBBTM        SET TOP TO BOTTOM\n         MEXIT\n.CHECK   IF (CLI,ESVDBINHIBIT,EQ,X'00') If ClearDebug not inhibited:\n          MVC   ESVDBTOP,ESVDBBTM        SET TOP TO BOTTOM\n         ENDIF                          Endif.\n         MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SRVDOC$$": {"ttr": 9485, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x02\\x00\\x00V\\x01\\x11)\\x9f\\x01\\x11)\\x9f\\t'\\x00$\\x00$\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@\"", "ispf": {"version": "02.00", "flags": 0, "createdate": "2011-10-26T00:00:00", "modifydate": "2011-10-26T09:27:56", "lines": 36, "newlines": 36, "modlines": 0, "user": "CLEMSON"}, "text": ":userdoc sec='Internal Use Only'\n copyr='Clemson University DCIT 1989-1997'.\n.* Prolog section\n.im SRVDOC$1\n.* Customization section\n.im SRVDOC$2\n.* Front-matter stuff.\n.im SRVDOC$3\n.* Part I. User's Guide.\n.im SRVDOC$4\n.* Part II. Reference.\n.im SRVDOC$5\n.* Date/Time Services Reference\n.im SRVDOCDT\n.* Environment Support Reference\n.im SRVDOCES\n.* File Handler Reference\n.im SRVDOCFI\n.* Item Manager Reference\n.im SRVDOCIM\n.* Memory Manager Reference\n.im SRVDOCMM\n.* Message Services Reference\n.im SRVDOCMS\n.* Printline Reference\n.im SRVDOCPL\n.* String Handler Reference\n.im SRVDOCST\n.* Symbol Manager Reference\n.im SRVDOCSY\n:appendix.\n.* Appendix: Writing a Service Proc.\n.im SRVDOC$6\n:backm.\n:index.\n:euserdoc.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SRVDOC$R": {"ttr": 9729, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x02\\x00\\x00V\\x01\\x11)\\x9f\\x01\\x11)\\x9f\\t'\\x01A\\x01A\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@\"", "ispf": {"version": "02.00", "flags": 0, "createdate": "2011-10-26T00:00:00", "modifydate": "2011-10-26T09:27:56", "lines": 321, "newlines": 321, "modlines": 0, "user": "CLEMSON"}, "text": ".*\n.* The GML text below is a skeleton reference chapter for one service\n.* processor.  The suggested approach for writing a new chapter is to\n.*    1) create a new member called SRVDOCxx, where xx is the two\n.*       letter service processor identification code.\n.*    2) copy this member into it.\n.*    3) Change all occurrances of the skeleton names below to the\n.*       appropriate values.\n.*    4) format a copy of the manual with the new chapter included.\n.*    5) use the formatted copy of the new chapter to decided what\n.*       changes/additions/deletions need to be made.\n.*\n.*   <srvproc_name>  - The name used when referring to the service\n.*                     processor in general. e.g. \"String Handler\",\n.*                     \"Environment Support\", \"Memory Manager\", etc.\n.*   <srvload_sym>   - The symbolic name used for the load module, such\n.*                     as STRING_HANDLER, MVS_ENVIRONMENT_SUPPORT, etc.\n.*   <srvload_name>  - The actual name of the load module identified by\n.*                     <srvload_sym>, such as SRVSTR or SRVMVSES.       .\n.*   <>              - The two-letter code assigned to the service\n.*                     processor, such as ES, ST, MM, SY, or FI.\n.*   <func_name>     - The name used for specific function's reference\n.*                     section.  This name would be something like\n.*                     ES_LOAD_MODULE, ST_FORMAT, etc.\n.*   idid            - The header id used on the section for the xx_ID\n.*                     macro.\n.*\n.*\n.* Lines that begin with .*===> describe what should appear in the\n.*   text at that point or provide information on how something should\n.*   be formatted.\n.*\n.**********************************************************************\n.*                                                                    *\n.*                    Chapter. <srvproc_name>                         *\n.*                                                                    *\n.**********************************************************************\n:h1.<srvproc_name>\n:p.\nDiscussion of what the service processor is, in general terms.  This\nparagraph should contain just enough information to tell the reader\nright away whether or not the service processor will fill his needs.\n:p.\nIf the service processor is environment independent, state it in this\nparagraph.\n:p.\nA quick paragraph or two advertising the service processor's strengths\nand weaknesses, and the most common uses for its services.\n.*--------------------------------------------------------------------*\n:h3.Obtaining <srvproc_name> Symbols &amp. Macros\n.*--------------------------------------------------------------------*\n:p.\nThe <srvproc_name>'s symbols and interface macros can be found in the\nassembler copy member :#x.SRV<>MAC:e#x.. This member contains symbols\nnaming the <srvproc_name>'s load module, function codes, return codes,\nand parameter values.  It also contains macros for using all of the\n<srvproc_name>'s functions.  The following statement or its equivalent\nshould appear at the beginning of any program that uses the\n<srvproc_name>:\n:xmp.\n   COPY SRV<>MAC      Obtain the <srvproc_name>'s symbols & macros.\n:exmp.\n.*===> if there is more than one load module that implements the\n.*===> service processor's protocol, that should be mentioned here.\n.*--------------------------------------------------------------------*\n:h3.Establishing <srvproc_name> Defaults\n.*--------------------------------------------------------------------*\nSome parameters are general to the <srvproc_name> and not specific to\nany function.  These parameters include its load module name\n(:#xi.<>_epname:e#xi.), entry point address\n(:#xi.<>_epa:e#xi.), and token value\n(:#xi.<>_token:e#xi.). The :#x.<>_ID:e#x. macro (see\n:hdref refid=idid.) can be used to establish defaults for these\nparameters and associate them with a unique service processor\nidentifier.  The identifier may then be supplied on any <srvproc_name>\nmacro instruction to refer to the default parameter values.\n.*--------------------------------------------------------------------*\n:h3.Identifying the <srvproc_name>\n.*--------------------------------------------------------------------*\n:p.\nThe <srvproc_name> service processor resides in the load module named by\nthe following symbol definition in copy member :#x.SRV<>MAC:e#x.:\n:xmp.\n&amp.<srvload_sym>    SETC  '''<srvload_name>  '''\n:exmp.\nThis symbolic name should be used as the service processor entry point\nname for the <srvproc_name> as shown in the following :#x.<>_ID:e#x.\nmacro instruction.\n:xmp.\n<>_ID ID=ST,SPEPNAME=&amp.<srvload_sym>    Set <srvproc_name> Defaults.\n:exmp.\n.*--------------------------------------------------------------------*\n:h3.Loading the <srvproc_name>\n.*--------------------------------------------------------------------*\n:p.\nThe recommended method for loading the <srvproc_name> is through\nEnvironment Support's :#x.ES_LOAD_MODULE:e#x. function, as shown in\nthe following example:\n:xmp.\nES_LOAD_MODULE ID=ES,SPID=<>            Load the <srvproc_name>\n:exmp.\n.*--------------------------------------------------------------------*\n:h3.Other sections\n.*--------------------------------------------------------------------*\n:p.\nOther sections should be added here as needed to decribe things that are\ngeneral to the entire service processor and not specific to any function\nor macro.  For example, Environment Support has a section here called\n\"Data Areas\" which is subdivided into one section for each data area\nused by Environment Support.\n.*--------------------------------------------------------------------*\n:h2.<srvproc_name> Service Processor Functions\n.*--------------------------------------------------------------------*\n:p.\nThe remaining sections of this chapter describe all functions provided\nby the <srvproc_name> service processor, arranged in alphabetical order.\nEach function's description begins on a new page, and the name of the\nfunction being described appears in the top outside corner of every\npage.\n.*===>\n.*===> The section below a describes a generic function for a service\n.*===> processor.  There should be one section for each function\n.*===> supported, as well as a chapter for each macro defined by the\n.*===> service processor's SRV<>MAC member (there should be a separate\n.*===> chapter for each mapping macro, for example).  All of these\n.*===> chapters should be arranged in alphabetical order.\n.*===>\n.**********************************************************************\n.se temp = 'One-liner that will go in the table-of-contents'\n:func id=funcid name='<func_name>'.&temp.\n.**********************************************************************\n:p.\nA paragraph or two describing the function/macro's purpose and the most\ncommon uses for it.\n.*===>\n.*===> The :mac. and :callx. tags below are used to describe the\n.*===> syntax for invoking the function/macro.\n.*===>\n.*---------------------------------------------------------------------*\n.* Syntax box for the macro form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:mac.\n<func_name> ID=:hp1.id_name:ehp1.\n  &lbt.,SPEPA=:hp1.<>_epa:ehp1.&rbt.\n  &lbt.,SPTOKEN=:hp1.<>_token:ehp1.&rbt.\n.*===> The lines above are in every function-invocation macro, and\n.*===> probably in a lot of data-mapping macros.  The lines below\n.*===> describe function/macro-specific parameters.  Parameters that\n.*===> are optional should be enclosed in brackets.  The example\n.*===> parameters below are:\n   ,KEYWORD1=:hp1.parameter1:ehp1.\n  &lbt.,KEYWORD2=&lbr.:hp1.parameter2:ehp1. | &cont.\n(:hp1.parameter2:ehp1.,:hp1.parameter2_length:ehp1.)&rbr.&rbt.\n  &lbt.,KEYWORD3=:hp1.parameter3:ehp1.&rbt.\n  &lbt.,KEYWORD4=(:hp1.parameter4:ehp1.&cont.\n&lbr.,:hp1.parameter4:ehp1.&rbr.)&rbt.\n:emac.\n.*---------------------------------------------------------------------*\n.* Syntax box for the CALLX form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:callx.\nCALLX :hp1.<>_epa:ehp1.,(:hp1.<>_token:ehp1.,&amp.<func_name>,&cont.\n:hp1.parameter1:ehp1.,&cont.\n:hp1.parameter2:ehp1.,:hp1.parameter2_length:ehp1.,\n&lbt.:hp1.parameter3:ehp1.&rbt.,&cont.\n&lbr.,:hp1.parameter4:ehp1.&rbr.)\n.*===> If there are alternate forms, where the parameter list is\n.*===> significantly different depending on the first few parameter\n.*===> values, do something like the following:\n\n- or -\n\nCALLX :hp1.<>_epa:ehp1.,(:hp1.<>_token:ehp1.,&amp.<func_name>,&cont.\n:hp1.alternate-parameter-list:ehp1.)\n:ecallx.\n.*---------------------------------------------------------------------*\n.* Parameter-list table describing each parameter.\n.*\n.* :plist.\n.* :pLt.parameter      | One pLt/pLd pair for each parameter that may\n.* :pLd.description    | be specified.\n.* :eplist.\n.*\n.*---------------------------------------------------------------------*\n:plist.\n:pLt.id_name\n:pLd.specifies the name of a service processor identifier created by the\n:#x.<>_ID:e#x. macro which will be used by the :#x.<func_name>:e#x.\nmacro to automatically obtain values for :#xi.<>_epa:e#xi.\nand\n:#xi.<>_token:e#xi.. This parameter is required unless both\n:#xi.<>_epa:e#xi. and :#xi.<>_token:e#xi. are\nspecified.\n:pLt.<>_epa\n:pLd.specifies the label of a fullword in storage that contains the\nentry point address of an already-started <srvproc_name> service\nprocessor.  The value specified by :#xi.<>_epa:e#xi.\noverrides any value obtained from\n:#x.ID=:e#x.:#xi.id_name:e#xi..\n:pLt.<>_token\n:pLd.specifies the label of a fullword in storage that contains the\nvalue returned by :#x.<>_START:e#x. for the\n:#xi.<>_token:e#xi. parameter.  The value specified by\n:#xi.<>_token:e#xi. overrides any value obtained from\n:#x.ID=:e#x.:#xi.id_name:e#xi..\n:pLt.parameter1\n:pLd.specifies the label of etc, etc, etc.\n:pLt.parameter2\n:pLd.specifies the label of a string etc, etc, etc.\n:pLt.parameter2_length\n:pLd.specifies the label of a signed binary integer indicating the\nlength of the string identified by the :#xi.parameter2:e#xi.\nparameter.\n:pLt.parameter3\n:pLd.specifies a field into which a signed binary integer containing the\nlength of etc, etc.\n:pLt.&lbr.parameter4&rbr.\n:pLd.one or more values, etc, etc.\n:eplist.\n.*---------------------------------------------------------------------*\n.* Optional sections for describing how to use the function/macro.\n.*---------------------------------------------------------------------*\n.*===>\n.*===> Any significant information on how to use the function/macro\n.*===> should be placed here.  The sections should use the :fh3. and\n.*===> :fh4. tags, as needed.\n.*===>\n.*---------------------------------------------------------------------*\n.* Examples showing how to use it and neat ways to take advantage of\n.* the function's capabilities.\n.*\n.*===> If one or two separate examples are being done, simply use\n.*===>\n.*===> :fh3.Example 1\n.*===>   ...example 1 stuff...\n.*===> :fh3.Example 2\n.*===>   ...example 2 stuff...\n.*===>\n.*===> If a whole system of related examples are being done, use\n.*===>\n.*===> :fh3.Examples\n.*===>   ....description general to all examples.\n.*===> :h5.Example 1\n.*===>   ...example 1 stuff...\n.*===> :h5.Example 2\n.*===>   ...example 2 stuff...\n.*===>\n.*---------------------------------------------------------------------*\n:fh3.Examples\n.*---------------------------------------------------------------------*\n.* ReturnCode section: table of return codes and their meanings.\n.*\n.*===> This section should be elimitated for things that do not have\n.*===> return codes, such as the <>_ID macro or data-mapping macros.\n.*\n.* :rclist.\n.* :rcn.number           | One rcn/rct/rcd triple for each return code\n.* :rct.symbol           | that the function may generate.\n.* :rcd.description      |\n.* :erclist.\n.*\n.*---------------------------------------------------------------------*\n:rclist.\n:rcn.0\n:rct.<>_SUCCESS\n:rcd.The :#x.<func_name>:e#x. function has completed successfully.  Such\nand such values have been returned in parameter such and such.\n:erclist.\n:efunc.\n.**********************************************************************\n:func name='<>_ID' id=idid.Establish Default <srvproc_name> Values\n.**********************************************************************\n:p.The :#x.<>_ID:e#x. macro is used to establish default values for\nuse by other <srvproc_name> macros, which may access those values\nthrough a unique identifier, :#xi.id_name:e#xi., specified by\nthe user.  When allowed to generate default values, this macro will\ncreate Program Work Area (PWA) storage for :#xi.<>_epa:e#xi.\nand\n:#xi.<>_token:e#xi.. These values, whether generated by the\nmacro or provided by the user, are accessable from all other\n<srvproc_name> macros via the :#x.ID=:e#x.:#xi.id_name:e#xi.  parameter.\n:mac.\n<>_ID ID=:hp1.id_name:ehp1.\n  &lbt.,SPEPNAME=:hp1.<>_epname:ehp1.&rbt.\n  &lbt.,SPEPA=:hp1.<>_epa:ehp1.&rbt.\n  &lbt.,SPTOKEN=:hp1.<>_token:ehp1.&rbt.\n  &lbt.,ESID=:hp1.esid_name:ehp1.&rbt.\n  &lbt.,ESVA=:hp1.esva:ehp1.&rbt.\n  &lbt.optional keywords specific to <srvproc_name>&rbt.\n:emac.\n.*****\n:plist.\n:pLt.id_name\n:pLd.the identifier to assign to the service processor identifier being\nestablished.  This name must be unique for all service processor\nidentifier's.\n:pLt.<>_epname\n:pLd.the entry point name of the <srvproc_name> service processor module\nthat is being used.\n:pLt.<>_epa\n:pLd.specifies the label of a fullword in storage that will contain the\nentry point address of the Environment Support service processor.\n:pLt.<>_token\n:pLd.specifies the label of a fullword in storage that will contain the\ntoken assigned by the :#x.<>_START:e#x. function of the String\nHandler.\n:pLt.esid_name\n:pLd.the name of a service processor identifier, created by the\n:#x.ES_ID:e#x.  macro, which will be used by the :#x.<>_ID:e#x. macro to\nautomatically obtain the value for :#x.esv:e#x. (see below).\n:pLt.esva\n:pLd.specifies the label of a fullword in storage that contains (or\nwill contain) the address of the Environment Support Vector\n(:#x.ESV:e#x.) created by the :#x.ES_START:e#x. function.\n:eplist.\n:fh3.Example 1\n:p.\n:xmp.\n<>_ID ID=ES,SPEPNAME=&amp.<srvload_sym>\n:exmp.\n:efunc.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SRVDOC$1": {"ttr": 9735, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x02\\x00\\x00V\\x01\\x11)\\x9f\\x01\\x11)\\x9f\\t'\\x00.\\x00.\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@\"", "ispf": {"version": "02.00", "flags": 0, "createdate": "2011-10-26T00:00:00", "modifydate": "2011-10-26T09:27:56", "lines": 46, "newlines": 46, "modlines": 0, "user": "CLEMSON"}, "text": ".**********************************************************************\n.*                                                                    *\n.*                    Bookmaster Prolog Section                       *\n.*                                                                    *\n.**********************************************************************\n.*                                                                    *\n.* This member contains the BookMaster prolog for the \"Clemson        *\n.* University Service Processors User's Guide and Reference\" manual.  *\n.*                                                                    *\n.* In addition to defining the layout of the title-page, the prolog   *\n.* defines the general document layout (:docprof.), and establishes   *\n.* definitions for figures, examples, and the table structure for     *\n.* parameter lists and return-codes.                                  *\n.*                                                                    *\n.**********************************************************************\n:prolog.\n:docprof bodyhd0='Part' bodyhd1='Chapter' duplex=yes hyphen=yes\n  justify=yes ldrdots=yes.\n:figdef frame=box width=column place=inline.\n:xmpdef scale=auto width=72 keep=5.\n:tdef id=plistrw frame=box rules=both cols='1.0i *'\n      align='left justify' concat=yes hp='1 0' arrange='1 2'\n      mindepth=p5 split=yes.\n:tdef id=plisthd frame=box hdframe=rule rules=both cols='1.0i *'\n      concat=no arrange='1 1' arrange='2 3' align='center left left'\n      valign='center top top' headhi='2 2 2' mindepth='0.6i * *'.\n:tdef id=rcrw frame=box rules=both cols='0.2i 1.7i *' mindepth=p5\n      arrange='1 2 3' align='right left justify' concat=yes\n      hp='0 0 0' split=yes.\n:tdef id=rchd frame=box hdframe=rule rules=both cols='0.2i 1.7i *'\n      concat=no arrange='1 1 1' arrange='2 3 4' mindepth='0.6i * * *'\n      align='center right left left' valign='center top top top'\n      headhi='2 2 2 2' split=yes.\n:title stitle='Clemson Service Processors'.\n:library.\nClemson University Research Foundation\n:topic.\nService Processors\nUser's Guide And Reference\n:etitle.\n:author.Last revision: July 14, 1997\n:address.\nClemson University Research Foundation\n:eaddress.\n:date.\n:eprolog.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SRVDOC$2": {"ttr": 9737, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x02\\x00\\x00V\\x01\\x11)\\x9f\\x01\\x11)\\x9f\\t'\\x01\\x19\\x01\\x19\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@\"", "ispf": {"version": "02.00", "flags": 0, "createdate": "2011-10-26T00:00:00", "modifydate": "2011-10-26T09:27:56", "lines": 281, "newlines": 281, "modlines": 0, "user": "CLEMSON"}, "text": ".**********************************************************************\n.*                                                                    *\n.*                        Customization Section                       *\n.*                                                                    *\n.**********************************************************************\n.*                                                                    *\n.* This member contains customization code for the \"Clemson           *\n.* University Service Processors User's Guide and Reference\" manual.  *\n.*                                                                    *\n.* It defines all of the special GML tags and fonts that are used     *\n.* throughout the document.  Some of these tags depend on the way     *\n.* the underlying Bookmaster tags are implemented.  In particular,    *\n.* some of the heading stuff sets variables that are later used by    *\n.* Bookmaster.  Look in 'SCRIPT.EDFLIB20.MACLIB' to find the macros   *\n.* in question.                                                       *\n.*                                                                    *\n.*                                                                    *\n.*  :us.underscored_word:eus.\n.*  :#x.xmpfont:e#x.\n.*  :#xb.xmpbold:e#xb.\n.*  :#xi.xmpital:e#xi.\n.*  :#hd3.header-3 font:e#hd3.\n.*  :#hd4.header-4 font:e#hd4.\n.*\n.*  :func name='function'. as a special-case :h2. heading tag.\n.*  :fh3. for h3 headers w/in function-description sections.\n.*  :fh4. for h4 headers w/in function-description sections.\n.*  :sbox. tag is for labeled boxes containing syntax notations.\n.*  :mac. and :callx. tags are for function-invocation syntax boxes.\n.*  :plist.\n.*    :pLt.parm_name\n.*    :pLd.description text, which will be offset and flowed.\n.*    more :pLt. and :pLd. tags.\n.*  :eplist.\n.*  :rclist.\n.*    :rcn.####\n.*    :rct.name\n.*    :rcd.description text, which will be offset and flowed.\n.*    more :rcn., :rct., and :rcd. tags.\n.*  :erclist.\n.*                                                                    *\n.* Special note: The BookMaster User's Guide states that you should   *\n.*               not directly code any script commands other than a   *\n.*               very limited (and useless) subset of 'safe' control  *\n.*               words.  This section is where all violations of that *\n.*               statement are located.                               *\n.*                                                                    *\n.**********************************************************************\n.dr thin   weight .1mm\n.dr medium weight .3mm\n.dr thick  weight .4mm\n.if &E'&@xmpfont eq 0 .se #xmpfont '&@basefont\n.el .se #xmpfont '&@xmpfont\n.df xmpfont type(&#xmpfont.)        codepage &@xmpcdpg\n.df xmpbold type(&#xmpfont. bold)   codepage &@xmpcdpg\n.df xmpital type(&#xmpfont. italic) codepage &@xmpcdpg\n.*----------*\n.gs tag off\n.*---------------------------------------------------------------------*\n.* Define GML tags for special highlighting phrases:\n.*  :us.underscored_word:eus.\n.*  :#x.xmpfont:e#x.\n.*  :#xb.xmpbold:e#xb.\n.*  :#xi.xmpital:e#xi.\n.*  :#hd3.header-3 font:e#hd3.\n.*  :#hd4.header-4 font:e#hd4.\n.*---------------------------------------------------------------------*\n.dm ustag  /.'us on\n.dm eustag /.'us off\n.aa us ustag (noatt) eustag\n.*-----*\n.dm #xtag  /.'bf xmpfont\n.dm #xbtag /.'bf xmpbold\n.dm #xitag /.'bf xmpital\n.dm #hd3tag /.'bf @hd3\n.dm #hd4tag /.'bf @hd4 althi1 hi1\n.dm #extag /.'pf\n.aa #x   #xtag  (noatt) #extag\n.aa #xb  #xbtag (noatt) #extag\n.aa #xi  #xitag (noatt) #extag\n.aa #hd3 #hd3tag (noatt) #extag\n.aa #hd4 #hd4tag (noatt) #extag\n.***********************************************************************\n.* Set up :func name='function'. as a special-case :h2. heading tag.\n.**********************************************************************\n.dm func on               ;.cm Macro for function sections.\n.gs copy *desc            ;.cm   Get residual text in *desc variable.\n.gs scan *junk            ;.cm\n.gs attval name as #func  ;.cm   Get name=function in #func variable.\n.gs attval id as *id      ;.cm   If id= specified, save the info.\n.rh on                    ;.cm   Define a running heading.\n.sa                       ;.cm     Save the current environment.\n.fo outside               ;.cm     Justify function name on outside.\n.bf @hd3                  ;.cm     Print name in header 3's font.\n&#func\n.re                       ;.cm     Restore settings.\n.sp 1.0mm                 ;.cm     Space down by 1 millimeter.\n.hr thin left right       ;.cm     Draw a thin line across the page.\n.sp 3                     ;.cm     Space down by one whole line.\n.rh off                   ;.cm   End of running heading.\n.pa                       ;.cm   Function headers go to a new page.\n.if X&*id \u00ac= X .go funcid ;.cm\n:h3.&#func - &*desc\n.go funcix                ;.cm\n...funcid                 ;.cm\n:h3 id=&*id..&#func - &*desc\n...funcix                 ;.cm\n.sp 2                     ;.cm   Space down 2 extra lines.\n:i1 pg=start.&#func\n.dm off                   ;.cm End of function section header macro.\n.*-----*\n.dm efunc on\n:i1 pg=end.&#func\n.rh cancel\n.dm off\n.aa func func (att) efunc ;.cm Create the function-heading tags.\n.***********************************************************************\n.* Set up :fh3. for h3 headers w/in function-description sections.\n.**********************************************************************\n.dm fh3 on              ;.* Create a macro for non-toc level 3 headers.\n.gs copy @head          ;.*   Place residual text in a variable.\n.gs scan *junk          ;.*   Place residual text in a variable.\n.gs attval id as *id    ;.*   If id= specified, save the info.\n.se @headlvl = 3        ;.*   Set @headlvl for the edf@idh macro.\n.cp 8                   ;.*   Conditional page when < 4 lines left.\n.sk 2                   ;.*   Skip down two lines.\n:#hd3.&@head:e#hd3.\n.if X&*id = X .go skipid;.*\n.edf@idh &*id\n...skipid\n.sp 1                   ;.*   Space down one line.\n.dm off                 ;.* End of fh3 macro definition.\n.aa fh3 fh3             ;.* Create GML tag :fh3.\n.***********************************************************************\n.* Set up :fh4. for h4 headers w/in function-description sections.\n.**********************************************************************\n.dm fh4 on              ;.* Create a macro for non-toc level 4 headers.\n.gs copy @head          ;.*   Place residual text in a variable.\n.gs scan *junk          ;.*   Place residual text in a variable.\n.gs attval id as *id    ;.*   If id= specified, save the info.\n.se @headlvl = 4        ;.*   Set @headlvl for the edf@idh macro.\n.cp 8                   ;.*   Conditional page when < 4 lines left.\n.sk 1                   ;.*   Skip down two lines.\n:#hd4.&@head:e#hd4.\n.if X&*id = X .go skipid;.*\n.edf@idh &*id\n...skipid\n.sp 1                   ;.*   Space down one line.\n.dm off                 ;.* End of fh4 macro definition.\n.aa fh4 fh4             ;.* Create GML tag :fh4.\n.**********************************************************************\n.* :sbox. tag is for labeled boxes containing syntax notations.\n.**********************************************************************\n.dm sbox on\n.gs copy *label\n.gs scan *junk\n.sp\n:lblbox.&*label.\n.sa;.fo off;.in 0.15I;.kp on;.sp 1;.bf xmpbold\n.dm off\n.*-----*\n.dm esbox on\n.pf;.sp 1;.kp off;.re\n:elblbox.\n.dm off\n.*-----*\n.aa sbox sbox (att) esbox\n.**********************************************************************\n.* :mac. and :callx. tags are for function-invocation syntax boxes.\n.**********************************************************************\n.dm mac /:sbox.Macro Invocation Format\n.dm callx /:sbox.Call Invocation Format\n.aa mac mac (noatt) esbox\n.aa callx callx (noatt) esbox\n.**********************************************************************\n.* Define GML tags for describing parameters. Usage:\n.*   :plist.\n.*   :pLt.parm_name\n.*   :pLd.description text, which will be offset and flowed.\n.*   ..... more :pLt. and :pLd. tags.\n.*   :eplist.\n.**********************************************************************\n.dm plist on                ;.* Begin a new parameter description list.\n.cp 6\n.sk 2\n.se contin = 'Description of Parameters'\n:table refid=plistrw split=yes.\n:thd refid=plisthd temp.\n:c.:#hd3.&contin.:e#hd3.\n:c.Parameter\n:c.Description\n:ethd.\n.dm off                     ;.* EndofMacro.\n.*---------------------------------------------------------------------*\n.dm eplist on\n:etable.\n.dm off\n.*---------------------------------------------------------------------*\n.dm pterm on\n.gs copy *p\n.gs scan *junk\n:row split=yes.\n:c.:#xi.&*p:e#xi.\n.dm off\n.*---------------------------------------------------------------------*\n.dm pdefn on\n.gs copy *p\n.gs scan *junk\n:c.&*p\n.se contin = 'Description of Parameters (continued)'\n.dm off\n.aa plist plist (noatt) eplist\n.aa pLt pterm (noatt)\n.aa pLd pdefn (noatt)\n.**********************************************************************\n.* Define GML tags for describing return codes. Usage:\n.*   :rclist.\n.*   :rcn.####\n.*   :rct.name\n.*   :rcd.description text, which will be offset and flowed.\n.*   ..... more :rcn., :rct., and :rcd. tags.\n.*   :erclist.\n.**********************************************************************\n.*-------------------------------------- :rclist. ---------------------*\n.dm rclist on\n.sk 2\n.se contin = 'Return Codes'\n:table refid=rcrw split=yes.\n:thd refid=rchd temp.\n:c.:#hd3.&contin.:e#hd3.\n:c.RC\n:c.Symbol\n:c.Description\n:ethd.\n.dm off\n.*-------------------------------------- :erclist. --------------------*\n.dm erclist on\n:etable.\n.dm off\n.*-------------------------------------- :rcn.ReturnCodeNumber --------*\n.dm rcnum on\n.gs copy *p\n.gs scan *junk\n:row.\n:c.:#x.:hp2.&*p:ehp2.:e#x.\n.dm off\n.*-------------------------------------- :rct.ReturnCodeSymbol --------*\n.dm rcterm on\n.gs copy *p\n.gs scan *junk\n:c.:#x.&*p:e#x.\n.dm off\n.*-------------------------------------- :rcd.Description -------------*\n.dm rcdefn on\n.gs copy *p\n.gs scan *junk\n:c.&*p\n.se contin = 'Return Codes (continued)'\n.dm off\n.*---------------------------------------------------------------------*\n.aa rclist rclist (noatt) erclist\n.aa rcn rcnum  (noatt)\n.aa rct rcterm (noatt)\n.aa rcd rcdefn (noatt)\n.*---------------------------------------------------------------------*\n.gs tag on                ;.cm Turn GML scanning back on.\n.*\n.*---------------------------------------------------------------------*\n.*                                                                     *\n.* The terms below are index-header terms.                             *\n.*                                                                     *\n.*---------------------------------------------------------------------*\n:ih1 id=pwa.Program Work Area\n:ih1 id=esv.Environment Support Vector\n:ih1 id=spid.Service Processor Identifier\n:ih1 id=rc.Return Codes\n.*\n:ih1 seeid=pwa.PWA\n:ih1 seeid=esv.ESV\n:ih1 seeid=spid.SPID\n:ih1 seeid=spid.ID\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SRVDOC$3": {"ttr": 9988, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x02\\x00\\x00V\\x01\\x11)\\x9f\\x01\\x11)\\x9f\\t'\\x00<\\x00<\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@\"", "ispf": {"version": "02.00", "flags": 0, "createdate": "2011-10-26T00:00:00", "modifydate": "2011-10-26T09:27:56", "lines": 60, "newlines": 60, "modlines": 0, "user": "CLEMSON"}, "text": ".**********************************************************************\n.*                                                                    *\n.*                           Title Page                               *\n.*                                                                    *\n.**********************************************************************\n:frontm.\n:tipage.\n:cover.\n.**********************************************************************\n.*                                                                    *\n.*                      Edition Notice                                *\n.*                                                                    *\n.**********************************************************************\n:vnotice.\n:p.This document contains information that is proprietary and\nconfidential information of the Clemson University Research\nFoundation.  This document may not be reproduced in part or in\nwhole without the written permission of the Clemson University\nResearch Foundation.\n:p.This document is intended for internal use by the Clemson\nUniversity Research Foundation.\nStorage Technology Corporation has permission to use this manual\nfor the support of ExLM.\n:coprnote.&copyr.Clemson University Research Foundation 1989,1990,1992.\n:evnotice.\n.**********************************************************************\n.*                                                                    *\n.*                         Preface                                    *\n.*                                                                    *\n.**********************************************************************\n:preface.\n:p.\nService processors were created at Clemson University to assist in the\ndevelopment and maintenance of assembly language programs.  They provide\nan efficient, flexible, environment that can be used as a foundation for\nconstructing large and complex programs.  Service processors provide a\nvariety of functions, including most of those directly available to\nprograms written in high-level programming languages, and are designed\nso that new functions can be added as needed.\n:p.\nIn conjunction with the :hp3.Clemson University Structured Macros:ehp3.,\nservice processors bring assembler language programming to a level\napproaching that of high-level programming languages.  However, their\nuse is not restricted to assembly language programs: any program written\nin a language that supports standard System/370 calling conventions can\nbenefit from service processors.\n:p.\nThe Clemson University Service Processors are packaged in a load library\nand accompanying macro library.  The load library is accessed through\nthe system linklist or link pack area, so no :#x.STEPLIB:e#x. is\nrequired for its use.  The macro library should be concatenated to the\nassembler's :#x.SYSLIB:e#x. file, and requires Assembler H.\n.**********************************************************************\n.*                                                                    *\n.*                      Table Of Contents                             *\n.*                                                                    *\n.**********************************************************************\n:toc.\n:figlist.\n:body.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SRVDOC$4": {"ttr": 9990, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x02\\x00\\x00V\\x01\\x11)\\x9f\\x01\\x11)\\x9f\\t'\\x03\\x0e\\x03\\x0e\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@\"", "ispf": {"version": "02.00", "flags": 0, "createdate": "2011-10-26T00:00:00", "modifydate": "2011-10-26T09:27:56", "lines": 782, "newlines": 782, "modlines": 0, "user": "CLEMSON"}, "text": ".*--------------------------------------------------------------------*\n.*                                                                    *\n.*                                                                    *\n:h0 id=part1.Service Processors User's Guide\n.*                                                                    *\n.*                                                                    *\n.*--------------------------------------------------------------------*\n.**********************************************************************\n.*                                                                    *\n.*                    Chapter. Introduction                           *\n.*                                                                    *\n.**********************************************************************\n:h1.Introduction to Service Processors\n:p.\nYou are driving home from work when suddenly your car's engine, knowing\nthat your warranty expired just yesterday, starts sputtering and spews\nout lots of black smoke.  Then it dies completely and you have to call\nfor a wrecker to take it to the shop for repairs.  When you finally make\nit home, its too late to cook anything so you order a pizza and have it\ndelivered.  After eating, you load up the dishwasher and turn it on only\nto find out that a pipe has burst.  Water floods your kitchen.  You turn\nthe dishwasher off and, grumbling to yourself while cleaning up the\nmess, resolve to call a plumber in the morning.  What a lousy day!\n:p.\nWhat does all of this have to do with service processors?  Well, in real\nlife you call on various companies or service industries to do things\nfor you.  Towing service was provided by the wrecker, car repairs by the\nshop, cooking and delivery by the pizza restaurant, water and\nelectricity to operate your dishwasher were provided by utility\ncompanies, and plumbing repairs by the plumber.  Many of the services\nyou call on are things you might be able to do for yourself, but its\neasier and often more efficient to have it done by someone else.\n:p.\nService processors perform analagous services for programs.  Services\nare available for extracting information about a program's execution\nenvironment, efficiently managing storage, manipulating textual data,\nreading from arbitrary files, and managing symbols.  A service processor\ngroups related services together into a single \"company\" that programs\ncan call upon without having to worry about the implementation details.\nThis can dramatically reduce the amount of code that must be written to\ndevelop a new program.\n.*---------------------------------------------------------------------*\n:h2.What Are Service Processors?\n:p.\nService processors are an integrated system of subroutines that serve as\nbuilding-blocks for program construction.  Each service processor is a\nsubroutine that provides one or more related services, usually for\nmanaging a specific type of software resource such as a file or a symbol\ntable.  Service processors take advantage of the building-blocks offered\nby other service processors, building on their services wherever\npossible.  The services within a processor share internal code and\nworking storage, as well as data and other resources.  They are able to\nretain information and resources across invocations, providing them with\nthe ability to keep track of things on a program's behalf.  Additional\nfeatures of service processors include a built-in mechanism for tracking\ndebugging information and a method of supporting multiple execution\nenvironments.  Some of the service processors available include:\n:ul.\n:i1.Date/Time\n:li.Date/Time: provides services for obtaining the current date and time\nand for manipulating date/time values.  The Date/Time service processor\nsupports numerous formats and may be used to convert values from one\nformat to another.  Services are also available for subtracting or\nadding a duration to a given date/time value, and for calculating the\nduration between two date/time values.\n:i1.execution environment\n:i1.Environment Support\n:li.Environment Support: acts as an interface between the calling\nprogram and its execution environment (an operating system, online\nsystem, high-level language, etc), and provides services for extracting\ninformation such as the time and date, userid and group name, and\nwhether a program is executing in the forground or background.\n:i1.Memory Manager\n:i1.heap\n:li.Memory Manager: provides an efficient storage management scheme for\nprograms that need to frequently allocate small items of storage and\nthen free them all at once.  Storage can be set up in separate\n:hp1.heaps:ehp1. and entire storage heaps can be released with a single\ncall.  Items of storage can, of course, be individually released as\nwell.\n:i1.String Handler\n:li.String Handler: provides services for manipulating and formatting\nstring data, and services for converting various types of data to and\nfrom character format.\n:i1.Symbol Manager\n:li.Symbol Manager: provides services for storing symbols with attached\ninformation and retrieving them by name at a later time. The information\nattached to a symbol is controlled entirely by the calling program.\n:i1.File Handler\n:li.File Handlers: provide services for reading from various types of\nfiles without concern for the actual record layout or access method\nrequired.\n:i1.PrintLine\n:li.PrintLine: this service processor provides an application program\nwith a good set of basic report-writing services.  It can be used to\nset up headers and footers on the printed page, keep track of the\ncurrent page number and perform automatic ejects.\n:eul.\n:p.\nFor a more detailed look at the services available, see :hdref\nrefid=spref page=no.: there is a separate chapter for each service\nprocessor that describes its purpose and details the services it\nprovides.  Also, scanning the table of contents is a quick way to get a\nfeel for what services are available.\n.*---------------------------------------------------------------------*\n:h2.How Programs use Service Processors\n:p.\n:i1 id=funcd.function code\nPrograms use service processors by calling them with a function code\nindicating the service to be performed (the terms function and service\nare used interchangeably in this manual).  For example, a program might\ncall the Environment Support service processor with the\n:#x.ES_GET_TIME:e#x. function code to obtain the current time and date.\nThe program would, of course, provide parameters in which Environment\nSupport would return the requested information.  Each function of a\nservice processor has its own set of function-specific parameters.\n:p.\n:i1.session identifier\n:i1.session\n:i1.token\n:i2 refid=funcd.START\n:ih1.resource\n:i2.software\nBefore a program can use any of a processor's services, it must\nestablish a session with the service processor by calling it with the\n:#x.START:e#x. function code. The :hp2.start:ehp2. function establishes\na session between the calling program and the service processor, and\nreturns a unique session identifier to the caller.  This session\nidentifier, or :hp1.token:ehp1., usually represents a software resource\nbeing managed by the newly established session, such as an open file or\na new symbol table.\n:p.\nThe token returned by :hp2.start:ehp2. is used on future calls to the\nservice processor, along with a function code, to identify the session\n(or resource) for which a service is being requested.  A program can\nstart as many sessions as desired, and most service processors provide\noptional parameters that tailor the new session to the caller's needs.\n:i2 refid=funcd.TERMINATE\nA complimentary function code, :#x.TERMINATE:e#x., ends a service\nprocessor session and resets the session identifier token to a null\nvalue.\n.*---------------------------------------------------------------------*\n:h2.The Service Processor Execution Environment\n:p.\n:i1.execution environment\n:i1.Environment Support\nAlthough service processors reside in separate subroutines, they are\ninterdependent to varying degrees.  For example, the Symbol Manager uses\nthe Memory Manager to deal with the storage in which symbols are kept\nand the File Handler uses the String Handler to format its messages.\nOne service processor, Environment Support, is used by all service\nprocessors for such basic services as allocating working storage,\nmanaging debugging information, and gaining access to other service\nprocessors.\n:p.\n:i1.Environment Support Vector\n:i2 refid=esv.address\nWhen Environment Support is started (invoked with the :#x.START:e#x.\nfunction code), it creates a data area called the Environment Support\nVector that represents an execution environment for service processors.\nEnvironment Support returns the address of the :#x.ESV:e#x. to the\ncalling program, which is then responsible for passing it to other\nservice processors as they are started.  Thus, Environment Support must\nbe the first service processor started.  Once the address of the\n:#x.ESV:e#x. has been passed to a service processor it will be retained,\nso there is no need to provide it with subsequent function calls.\n.**********************************************************************\n.*                                                                    *\n.*                                                                    *\n.*                  Chapter. Using Service Processors                 *\n.*                                                                    *\n.*                                                                    *\n.**********************************************************************\n:h1.Using Service Processors\n:p.\nThis chapter describes the general concepts and procedures needed to\nmake use of service processors.  The focus in this chapter (as well as\nin the rest of the manual) is on assembly language programming with the\n:hp3.Clemson University Structured Macros:ehp3., and all examples are\nshown in assembler.  However, service processors can be used from any\nlanguage that supports standard System/370 linkage conventions and they\nhave the potential of running within the execution environment of\nhigh-level languages such as PL/I.\n:p.\nWhile service processors are easy to use, some setting up is required\nbefore a program can begin invoking their functions.  As mentioned in\nthe introduction, each service processor is a subroutine. The subroutine,\nwhich must be invoked in 31-bit addressing mode, must be loaded into\nstorage somehow and invoked with the :#x.START:e#x. function code\nbefore any other functions can be used.\n:i1.execution environment\nAlso, all service processors depend on the execution environment\nestablished by Environment Support, which must be loaded and started\nbefore any other service processors.\n.*---------------------------------------------------------------------*\n:h2.Copy Members\n:p.\n:i1.copy member\nEach service processor has a :hp1.copy member:ehp1. containing macros\nfor invoking its services and symbols that name its load module,\nfunction codes, and return codes.  Assembler programs should have a\n:#x.COPY:e#x. statement for each service processor they use, and it\nshould appear as close to the beginning of the program as possible.  For\nexample, the following statements would be used to obtain the symbolic\ndefinitions and macros for the Environment Support and String Handler\nservice processors:\n:fig.\n:#x.\nCOPY  SRVESMAC    | Copy Environment Support's symbols &amp. macros.\nCOPY  SRVSTMAC    | Copy the String Handler's symbols &amp. macros.\n:e#x.\n:figcap.Obtaining Service Processor Symbols and Macros\n:efig.\n:p.\nAfter a service processor's copy member has been processed, all\nof its symbols and macros are available for use.  Look in the\nappropriate chapters of :hdref refid=spref page=no. for complete\ndescriptions of service processor copy members and how to use them.\nPrograms written in a language other than assembler should contain\nequivalent symbols or named constants for the function codes and return\ncodes they use.\n.*---------------------------------------------------------------------*\n:h2.Loading Service Processors\n:p.\nAs a general rule, each service processor resides in its own load\nmodule, although there are exceptions that will be described later.  The\nonly service processor that must be loaded directly by the application\nprogram is Environment Support.  How this is done is dependent on the\nprogramming language used and the environment in which it is running.\n:i1.ES_LOAD_MODULE\nOnce Environment Support has been loaded and started, other service\nprocessors may be loaded through the :#x.ES_LOAD_MODULE:e#x. function.\nFor example, an assembler program running under MVS/XA might issue the\nfollowing sequence of instructions to load Environment Support and two\nother service processors.\n:fig id=losps.\n.sp;:#x.\nLOAD  EPLOC==&amp.MVS_ENVIRONMENT_SUPPORT   | Load Environment Support.\nST    R0,ES_EPA                         | Save its EPA.\nCALLX ES_EPA,(ES_TKN,&amp.ES_START,ES_ESVA) | Start Environment Support.\nCALLX ES_EPA,(ES_TKN,&amp.ES_LOAD_MODULE,&amp.STRING_HANDLER,ST_EPA)\nCALLX ES_EPA,(ES_TKN,&amp.ES_LOAD_MODULE,&amp.MEMORY_MANAGER,MM_EPA)\n:e#x.\n:figcap.Loading service processors\n:efig.\n.*---------------------------------------------------------------------*\n:h2.Invoking Services\n:p.\n:i1.function code\n:i1.token\nService processors are called using standard linkage conventions for\nprograms running in 31-bit addressing mode (see :hdref refid=linkage.).\nThe first two parameters of the subroutine call are always the same: a\n:#x.:hp2.token:ehp2.:e#x. followed by a :#x.:hp2.function\ncode:ehp2.:e#x.. The minimum call to invoke one of a service processor's\nfunctions looks like the following for an assembler program written with\nthe Structured Macros:\n:xmp.\nCALLX SERVICE_PROCESSOR,(TOKEN,FUNCTION_CODE)\n:exmp.\n:i1.function code\n:i2 refid=funcd.START\n:i2 refid=funcd.TERMINATE\n:i1.token\nThe :#x.:hp2.function code:ehp2.:e#x. parameter is a four byte signed\nbinary integer that selects the desired function.  Two function codes,\n:#x.START:e#x. and :#x.TERMINATE:e#x., are supported by all service\nprocessors.  Other function codes are dependent on the particular\nservice processor.  The :#x.:hp2.token:ehp2.:e#x. parameter is a four\nbyte value whose contents are set by the service processor itself when\nthe\n:#x.START:e#x. function is invoked. Additional parameters may be\nrequired or optional, depending on the service being requested.\n.*---------------------------------------------------------------------*\n:h3.Symbol Definitions\n:p.\n:i2 refid=funcd.symbols\nThe function code symbols provided by a service processor's copy member\nshould always be used in place of the actual integer values they\nrepresent.  For example, the instructions in :figref refid=ctusps\npage=no. load and start three service processors and invoke several of\ntheir functions.\n:fig id=ctusps.\n.sp;:#x.\nLOAD  EPLOC==C&amp.MVS_ENVIRONMENT_SUPPORT\nST    R0,ES_EPA\nCALLX ES_EPA,(ES_TKN,&amp.ES_START,ES_ESVA)\nCALLX ES_EPA,(ES_TKN,&amp.ES_LOAD_MODULE,&amp.STRING_HANDLER,ST_EPA)\nCALLX ST_EPA,(ST_TKN,&amp.ST_START,ES_ESVA)\nCALLX ES_EPA,(ES_TKN,&amp.ES_LOAD_MODULE,&amp.MEMORY_MANAGER,MM_EPA)\nCALLX MM_EPA,(MM_TKN,&amp.MM_START,ES_ESVA)\nCALLX MM_EPA,(MM_TKN,&amp.MM_OBTAIN_STORAGE,80,MSG_BUFFER)\nCALLX ES_EPA,(ES_TKN,&amp.ES_GET_FORMATTED_TIME,TIME,,DATE)\nL     R2,MSG_BUFFER\nCALLX ST_EPA,(ST_TKN,&amp.ST_FORMAT,(R2),80,MSG_LENGTH,&cont.\n                       +\n           'Execution beginning at %CL5 on %CL8.',36,TIME,DATE)\nCALLX ES_EPA,(ES_TKN,&amp.ES_DISPLAY_MESSAGE,(R2),MSG_LENGTH)\n:e#x.\n:figcap.Code that uses service processor symbols\n:efig.\nBecause symbols are used for specifying function codes, it is easy to\ndetermine what functions are being invoked.  After the instructions in\n:figref refid=ctusps page=no. have been executed, a message like the\none below will be written to the user's terminal or to the job message\nlog:\n:xmp.\nExecution beginning at 14:10 on 06/01/89.\n:exmp.\n:p.\nUse of service processor symbols makes for code that is much easier to\nunderstand than the following instruction sequence, which produces\nidentical code to that in :figref refid=ctusps page=no. but uses the\nactual integer values instead of their symbolic names:\n:fig id=ctnsps.\n.sp;:#x.\nLOAD  EPLOC==C'SRVESMVS'\nST    R0,ES_EPA\nCALLX ES_EPA,(ES_TKN,1,ES_ESVA)\nCALLX ES_EPA,(ES_TKN,5,'SRVSTR',ST_EPA)\nCALLX ST_EPA,(ST_TKN,1,ES_ESVA)\nCALLX ES_EPA,(ES_TKN,5,'SRVMEM',MM_EPA)\nCALLX MM_EPA,(MM_TKN,1,ES_ESVA)\nCALLX MM_EPA,(MM_TKN,3,80,MSG_BUFFER)\nCALLX ES_EPA,(ES_TKN,24,TIME,JULIAN,,DATE)\nL     R2,MSG_BUFFER\nCALLX ST_EPA,(ST_TKN,3,(R2),80,MSG_LENGTH,&cont.\n                                +\n         'Execution beginning at %CL5 on %CL8.',36,TIME,DATE)\nCALLX ES_EPA,(ES_TKN,7,(R2),MSG_LENGTH)\n:e#x.\n:figcap.Code that does not use service processor symbols\n:efig.\n.*---------------------------------------------------------------------*\n:h3.Function Macros and Service Processor Identifiers\n:p.\nIn programs that make heavy use of service processor functions, coding\nsubroutine calls can be a chore.  After all, the first few items in the\nsubroutine call are always the same: an entry point address, a token\nvalue, and a function code.  Furthermore, if a large number of service\nprocessors or service processor sessions are needed, creating labels and\nstorage for the entry point addresses and token values can become\ntedious (e.g.&rbl.:#x.ES_EPA:e#x., :#x.ES_TKN:e#x., etc).\n:p.\nThe macros defined within each service processor's copy member can do\nmost of this automatically.  There is a separate macro for invoking each\nservice processor function.  The name of each function invocation macro\nis the same as that of the function it invokes, and all values are\nspecified using keyword parameters instead of the positional parameters\nused in :#x.CALLX:e#x. statements.\n:p.\nIn addition to the function invocation macros, each service processor\nhas a macro for establishing :hp1.service processor identifiers:ehp1..\n:i1.service processor identifier\nA service processor identifier is a collection of parameters that will\nbe automatically used whenever the identifier is referenced.  For\nexample, the :#x.ES_ID:e#x. instruction in\n.*\n.*  If this (or any other) figure reference is the last thing on a\n.*  line, the line after it will be used as residual text and no\n.*  blank will follow the reference:  \"...in Figure 5creates...\"\n.*\n:figref refid=espd page=no. creates an Environment Support service\nprocessor identifier, :#x.ENV_SUP:e#x., and associates it with four\ndifferent values.  Once it has been created, specifying\n:#x.ID=ENV_SUP:e#x. on any Environment Support macro is equivalent to\nspecifying all of those values.\n:fig id=espd.\n.sp;:#x.\nES_ID ID=ENV_SUP,SPEPNAME=&amp.MVS_ENVIRONMENT_SUPPORT,&cont.\n                       +\n             SPEPA=ES_EPA,SPTOKEN=ES_TKN,ESVA=ES_ESVA\n:e#x.\n:figcap.Establishing service processor defaults\n:efig.\nAny number of service processor identifiers can be created: they are\nsimply used for grouping several different parameters under a single\nname. Each service processor has its own macro for creating identifiers,\nbut they are all similar and have at least the following keywords:\n:#x.SPEPNAME:e#x., :#x.SPEPA:e#x., :#x.SPTOKEN:e#x., and :#x.ESVA:e#x..\nAdditional keywords may be specified for some service processor\nidentifiers.\n:p.\nAll keywords other than :#x.ID=:e#x. are optional when creating any\nservice processor identifier and most will be set to default values if\nthey are omitted.  In particular, if the entry point address and token\nvalue keywords are omitted, storage will be reserved for them in the\n:i1.Program Work Area\n:i2 refid=esv.address\nStructured Macros Program Work Area (:#x.PWA:e#x.). The same is true\nfor the :#x.ESV:e#x. address, except that the :#x.ES_ID:e#x. macro\nwill generate the storage, and all other service processor identifiers\nwill default to the existing value.\n:p.\n:i1.Structuired Macros\nAny storage field generated in the :#x.PWA:e#x. by a service processor\nmacro will be named using Structured Macros global variable\n:#x.&amp.PWA.:e#x. followed by the service processor identifier, an\nunderscore, and the keyword to which the value applies.  For example, if\n:#x.SPTOKEN:e#x. had not been specified in :figref refid=espd page=no.,\nthe instruction\n:xmp.\n&amp.PWA.ENV_SUP_SPTOKEN  DS  F\n:exmp.\nwould have been generated for it in the :#x.PWA:e#x..\n:p.\nThe code in :figref refid=ctuspim page=no. performs the same function as\nthat in :figref refid=ctusps page=no., but uses service processor macro\ninstructions in place of the :#x.LOAD:e#x. and :#x.CALLX:e#x.\ninstructions.\n:fig id=ctuspim.\n.sp;:#x.\nES_ID                 ID=ES,SPEPNAME=&amp.MVS_ENVIRONMENT_SUPPORT\nST_ID                 ID=ST,SPEPNAME=&amp.STRING_HANDLER\nMM_ID                 ID=MM,SPEPNAME=&amp.MEMORY_MANAGER\nES_MVS_LOAD           ID=ES              | Load Env. Support.\nES_START              ID=ES              | Start Env. Support.\nES_LOAD_MODULE        ID=ES,SPID=ST      | Load String Handler.\nES_LOAD_MODULE        ID=ES,SPID=MM      | Load Memory Manager.\nST_START              ID=ST              | Start String Handler.\nMM_START              ID=MM              | Start Memory Manager.\nMM_OBTAIN_STORAGE     ID=MM,SIZE=80,ADDRESS=MSG_BUFFER\nES_GET_FORMATTED_TIME ID=ES,TIME=TIME,GREGORIAN=DATE\nST_FORMAT    ID=ST,CONTROL='Execution beginning at %CL5 on %CL8.',&cont.\n        +\n             SOURCE=(TIME,DATE),TARGET=(*MSG_BUFFER,80),&cont.\nRESULTLEN=MSG_LENGTH\nES_DISPLAY_MESSAGE    ID=ES,MESSAGE=(*MSG_BUFFER,MSG_LENGTH)\n:e#x.\n:figcap.Code that uses service processor interface macros\n:efig.\n:p.\nThe first instruction in :figref refid=ctuspim page=no. establishes\ndefault values for Environment Support and associates them with service\nprocessor identifier :#x.ES:e#x.. While Environment Support's entry\npoint name was explicitly specified, its entry point address, token\nvalue, and :#x.ESV:e#x. address were not: :#x.ES_ID:e#x.\nautomatically reserves storage for them in the :#x.PWA:e#x.. The next\ntwo instructions do the same thing for the String Handler and the Memory\nManager, but use the previouly established value for :#x.ESVA:e#x.\ninstead of generating new fields.  After these three instructions have\nbeen seen by the assembler, the following fields will have been created\nin the :#x.PWA:e#x. and named as shown:\n:fig id=gpwafs.\n.sp;:#x.\n&amp.PWA.ES_SPEPA   DS A  &cont.\n| ID=ES: Environment Support's Entry Point Address.\n&amp.PWA.ES_SPTOKEN DS F  &cont.\n| ID=ES: Environment Support's Token.\n&amp.PWA.ES_ESVA    DS F  &cont.\n| ID=ES: Environment Support's ESV Address.\n&amp.PWA.ST_SPEPA   DS A  &cont.\n| ID=ST: String Handler's Entry Point Address.\n&amp.PWA.ST_SPTOKEN DS F  &cont.\n| ID=ST: String Handler's Token.\n&amp.PWA.MM_SPEPA   DS A  &cont.\n| ID=MM: Memory Manager's Entry Point Address.\n&amp.PWA.MM_SPTOKEN DS F  &cont.\n| ID=MM: Memory Manager's Token.\n:e#x.\n:figcap.Generated Program Work Area (PWA) fields\n:efig.\nThe remaining instructions in :figref refid=ctuspim page=no. produce the\nsame code as their counterparts in :figref refid=ctusps page=no.,\nautomatically obtaining the correct parameters and values through\nservice processor identifiers.\n.*---------------------------------------------------------------------*\n:h2.Checking Return Codes\n:i2 refid=rc.checking\n:p.\nOn return from any service processor function, register 15 will contain\nan integer value indicating the results of the function's operation.\nThis value is the function's return code.  Each service processor has\nits own set of return codes, but a value of zero (:#x.:hp2.0:ehp2.:e#x.)\nalways means a function call has completed successfully.\n:p.\nWhen most service processor functions cannot complete successfully, they\nsave information in Environment Support's debugging information area,\nset the return code, and return to the calling program.  The return code\nfrom these functions should always be checked to insure successful\n:i1.abend\noperation.  However, some functions are designed to succeed or abend\nthe program, so there is no need to examine their return codes.  Refer\nto the description of a particular function for details on how it\nhandles abnormal conditions.\n:p.\nChecking the return code after a service processor function call is\neasy.  Each service processor :#x.COPY:e#x. member defines symbols for\nall of its return codes.  These symbols may be used in open code while\nchecking return codes, as in the following :#x.IF:e#x. statement:\n:xmp.\nIF (CH,R15,EQ,=H'&amp.MM_STORAGE_NOT_AVAILABLE')   | If out of storage.\n:exmp.\n:p.\nIn addition to the return code symbols, user-conditions are defined (via\nthe Structured Macros :#x.DEFUCOND:e#x. macro) for checking them. To use\none of these conditions, simply prefix the condition code's name with a\npercent sign.  This statement is identical to the one above and happens\nto generate the same assembler code:\n:xmp.\nIF (%MM_STORAGE_NOT_AVAILABLE)                 | If out of storage.\n:exmp.\n:p.\n:i1.MM_OBTAIN_STORAGE\n:i1.Memory Manager\n:figref refid=csprcs page=no. shows a typical sequence of instructions\nfor checking a function's return code.  In this case, the Memory\nManager's :#x.MM_OBTAIN_STORAGE:e#x. function is being invoked. While\nno attempt is made to recover from errors, the out-of-storage return\ncode is handled as a special case. All other non-successful return codes\nfrom this function indicate more serious problems and are handled by\ndisplaying Environment Support's debugging information area and then\nabending the program with a dump.  The return codes from Environment\nSupport's display services are not checked because they will either\nsucceed or abend the program.\n:fig id=csprcs.\n.sp;:#x.\nMM_OBTAIN_STORAGE ID=MM,SIZE=133,ADDRESS=LINE  | Obtain 133 bytes stg.\nIF (%MM_STORAGE_NOT_AVAILABLE)                 | If out of storage.\n  ES_DISPLAY_MESSAGE ID=ES,MESSAGE='Not enough storage to operate.'\n  ERREXIT  CODE=8                              |   Exit with RC=8.\nELSEIF (NOT,(%MM_SUCCESS))                     | ElseIf other &cont.\nfailure.\n  ES_DISPLAY_DEBUG_INFO_AND_ABEND ID=ES        |   Abend with a &cont.\ndump.\nENDIF                                          | EndIf.\n:e#x.\n:figcap.Checking service processor return codes\n:efig.\n.*---------------------------------------------------------------------*\n:h2.Multiple Sessions With the Same Processor\n.*---------------------------------------------------------------------*\n:h2.Cascading Service Processors of the Same Type\n.*---------------------------------------------------------------------*\n:h2.Putting it Together\n:p.\nNow that the basic features and requirements of service processors have\nbeen covered, a complete program can be written.  This program is a TSO\ncommand processor written in assembler using the Structured Macros and\nthe service processor macros.  It uses Environment Support and the File\nHandler to read in and display every line in a sequential data set or\nmember of a partitioned data set, and is invoked with the following\nsyntax:\n.sp\n:#x.DISPLAY:e#x. :hp1.file-specification:ehp1.\n:p.\nOn entry to the program, register 1 must point to the TSO Command\nProcessor Parameter List, or :#x.CPPL:e#x.. The first word in the\n:#x.CPPL:e#x. is a pointer to the command buffer containing the\ncommand entered by the user.  The command buffer looks like the\nfollowing:\n:fig.\n.sp;.in 0.15i\n:hp2.Command Buffer:ehp2.\n.bx new thick thick 0.15i 0.85i 1.55i 4.85i\n.ti ~ 05;.tp 0.22i 0.92i 1.62i\n~:#x.length~offset~command-text:e#x.\n.bx off\n~&uar.~&uar.~&uar.\n.br\n.ti ~ 05;.tp 0.22i center 0.92i center 1.62i center\n~+0~+2~+4\n:figcap.TSO command buffer layout\n:efig.\n:p.\nThe first field, :#x.length:e#x., is a signed halfword equal to the\nlength of the entire command buffer, including the four-byte prefix.\nThe second field, :#x.offset:e#x., is a signed halfword equal to the\noffset from the beginning of :#x.command-text:e#x. to the current\nposition (thus, an offset of :#x.0000:e#x. would indicate the first\ncharacter in :#x.command-text:e#x.). The last field,\n:#x.command-text:e#x., is the text of the command as entered by the\nuser.\n:p.\nBefore invoking DISPLAY, TSO will set the value of :#x.offset:e#x. to\nindicate the first non-blank character after the command name itself\n(i.e. :#x.:hp2.DISPLAY:ehp2.:e#x.). For example, if a user entered the\ncommand :#x.:hp2.display source(notes):ehp2.:e#x., the command buffer\nwould contain the following values, with :#x.length:e#x. and\n:#x.offset:e#x. shown in decimal:\n:fig.\n.sp;.in 0.15i\n:hp2.Command Buffer:ehp2.\n.bx new thick thick 0.15i 0.85i 1.55i 3.40i\n.ti ~ 05;.tp 0.78i right 1.48i right 1.62i left\n:#x.~0025~0008~display source(notes):e#x.\n.bx off\n:figcap.Example command buffer contents\n:efig.\n:p.\nThe listing below was taken directly from a working copy of the DISPLAY\nprogram, and is well commented.  To understand the code of this program\nin detail, refer to the reference chapters for the Environment Support\nand File Handler service processors.\n:fig id=display width=column concat=no.\n:figcap.The DISPLAY program\n.in +2\n:#x.\n:figseg fit=34.\n*---------------------------------------------------------------------*\n*\n*  DISPLAY FileSpecification\n*\n*  A TSO command to display the contents of the specified sequential\n*  data set or PDS member on the user's terminal.  If the file cannot\n*  be opened for some reason, or if an error occurs while it is reading\n*  a line, the program will issue an error message and terminate\n*  normally.\n*\n*  Inputs:  On entry to this program, Register 1 (R1) must point to the\n*           TSO Command Processor Parameter List (CPPL), which is\n*           mapped by macro IKJCPPL in SYS1.MACLIB.\n*\n*  Outputs: Normally, each line in the file named by FileSpecification\n*           will be written to the user's terminal. If an error occurs,\n*           a message will be written to the terminal.  Some messages\n*           are created by this program, but most are obtained from the\n*           File Handler.\n*\n*  Return Codes:\n*    0    - The specified file was successfully displayed.\n*    4    - The file was displayed, but warning(s) were issued.\n*    8    - The file was not displayed.  An error message was issued.\n*   12    - A severe error occurred.  A message and dump were issued.\n:i1.abend\n*   Abend - A critical error occurred that probably indicates an\n*           internal programming error.  A message, mini-dump, and a\n*           full storage dump will be issued.\n*\n*---------------------------------------------------------------------*\n BLOCK TYPE=PROGRAM,NAME=DISPLAY,OPTIONS=(*PWA),R1SAVE=R9,AMODE=31,    +\n               RMODE=ANY\n   USING  CPPL,R9          | Establish addressability on the CPPL.\n   MVC    PWA_RC,=H'0'     | Initialize Display's return code.\n:figseg fit=7.\n*---------------------------------------------------------------------*\n*  Get symbols &amp. macros, and establish deault parameter values.\n*---------------------------------------------------------------------*\n   COPY   SRVESMAC         | Get Environment Support symbols & macros.\n   COPY   SRVFIMAC         | Get File Handler symbols & macros.\n   ES_ID  ID=ES,SPEPNAME=&MVS_ENVIRONMENT_SUPPORT   Set defaults.\n   FI_ID  ID=FI,SPEPNAME=&FI_OS_FILE_HANDLER        Set defaults.\n:figseg fit=5.\n*---------------------------------------------------------------------*\n*  Load and start Environment Support. Both functions will succeed or\n*  abend trying, so their return codes are not checked.\n*---------------------------------------------------------------------*\n   ES_MVS_LOAD    ID=ES            | Load Environment Support.\n   ES_START       ID=ES            | Start Environment Support.\n:figseg fit=9.\n*---------------------------------------------------------------------*\n*  Attempt to load the File Handler.  Issue a message on failure.\n*---------------------------------------------------------------------*\n   ES_LOAD_MODULE ID=ES,SPID=FI    | Load File Handler.\n   IF NOT,(%ES_SUCCESS)            | If unable to load File Handler.\n     ES_DISPLAY_MESSAGE ID=ES,     |   Display an error message.       +\n               MESSAGE='Unable to load File Handler.'\n     ERREXIT CODE=12               |   Quit with a return code.\n   ENDIF                           | EndIf.\n:figseg fit=29.\n*---------------------------------------------------------------------*\n*  Get the FileSpecification's length and address from the command\n*  buffer, and attempt to open it for sequential input.\n*---------------------------------------------------------------------*\n   L        R2,CPPLCBUF            | R2 := address of command buffer.\n   LH       R3,2(,R2)              | R3 := offset after command name.\n   LA       R3,4(,R3)              | R3 := offset from R2 to filename.\n   LH       R0,0(,R2)              | R0 := total buffer length.\n   SR       R0,R3                  | R0 := filename's length.\n   ST       R0,PWA_LEN             | Save for parmlist.\n*                                  |\n   FI_START ID=FI,FILE=(0(R3,R2),PWA_LEN),ACCESS=&FI_INPUT_SEQUENTIAL\n*                                  |\n   IF NOT,(%FI_SUCCESS)            | If file could not be opened.\n     IF (%FI_CRITICAL)             |   For CRITICAL errors...\n       ES_DISPLAY_DEBUG_INFO_AND_ABEND ID=ES  Abend immediately.\n     ELSEIF (%FI_SEVERE)           |   For severe errors...\n       ES_DISPLAY_DEBUG_INFO ID=ES |     Print debugging info.\n       ERREXIT CODE=12             |     Shut-down and exit.\n     ENDIF                         |   EndIf.\n*                                  |   For all other errors...\n     FI_GET_INFO ID=FI,MSG=PWA_MSG,MSGLEN=PWA_MSG_LEN  Get the msg.\n     IF (%FI_SUCCESS)              |   If success: display it.\n       ES_DISPLAY_MESSAGE ID=ES,MESSAGE=(PWA_MSG,PWA_MSG_LEN)\n       ERREXIT CODE=8              |     Shut-down and exit.\n     ELSE                          |   Else.\n       ES_DISPLAY_DEBUG_INFO_AND_ABEND ID=ES  Abend immediately.\n     ENDIF                         |   EndIf.\n   ENDIF                           | EndIf.\n:figseg fit=40.\n*---------------------------------------------------------------------*\n*  Read every line in the file and display it on the terminal.\n*---------------------------------------------------------------------*\n   LOOP UNTIL                      | Loop over all input lines.\n     FI_READLINE ID=FI,LINE=PWA_LINE,RESULTLEN=PWA_LEN  Read a line.\n     LEAVE       LOOP=*,(%FI_END_OF_FILE)               Leave if done.\n*                                  |\n     IF NOT,(%FI_SUCCESS)          |   If something went wrong.\n       IF (%FI_CRITICAL)           |     For CRITICAL errors...\n         ES_DISPLAY_DEBUG_INFO_AND_ABEND ID=ES  Abend immediately.\n       ELSEIF (%FI_SEVERE)         |     For severe errors...\n         ES_DISPLAY_DEBUG_INFO ID=ES       Print debugging info.\n         ERREXIT CODE=12           |       Shut-down and exit.\n       ENDIF                       |     EndIf.\n*                                  |\n       LR        R2,R15            |     Remember READLINE's return-code.\n       FI_GET_INFO ID=FI,MSG=PWA_MSG,MSGLEN=PWA_MSG_LEN Obtain the msg.\n       IF NOT,(%FI_SUCCESS)        |     If no message was obtained.\n         ES_DISPLAY_DEBUG_INFO_AND_ABEND ID=ES  Abend immediately.\n       ELSE                        |     Else, display the message.\n         ES_DISPLAY_MESSAGE ID=ES,MESSAGE=(PWA_MSG,PWA_MSG_LEN)\n         ERREXIT (CH,R2,NE,=H'&amp.FI_WARNING'),CODE=8 &cont.\nShut-down and exit.\n         MVC     PWA_RC,=H'4'      |       Set return-code to warning.\n       ENDIF                       |     EndIf.\n     ENDIF                         |   EndIf.\n*                                  |\n     ES_DISPLAY_MESSAGE ID=ES,     |   Display the line just read in.  +\n               MESSAGE=(PWA_LINE,PWA_LEN)\n   ENDLOOP UNTIL,LEAVE             | EndLoop.\n*---------------------------------------------------------------------*\n*  Close the file, terminate and unload service processors, and quit.\n*---------------------------------------------------------------------*\n   FI_TERMINATE     ID=FI          | Close and de-allocate file.\n   ES_UNLOAD_MODULE ID=ES,SPID=FI  | Unload file handler.\n   ES_TERMINATE     ID=ES          | Shut down Environment Support.\n   ES_MVS_UNLOAD    ID=ES          | Unload Environment Support.\n   LH               R15,PWA_RC     | Set R15 to final return-code.\n ENDBLK BLOCK=DISPLAY,RC=(R15)     | Exit with a succesful return code.\n\n\n:figseg fit=14.\n*---------------------------------------------------------------------*\n*  Error Exit - On entry R14 will equal the integer value supplied on\n*  the CODE= keyword of the ERREXIT macro.  This value will be used as\n*  Display's return code.\n*---------------------------------------------------------------------*\n BLOCK TYPE=ERREXIT                | Exit was entered with CODE=rc.\n   LR               R2,R14         |   Set R2 to the value on CODE=.\n   FI_TERMINATE     ID=FI          |   Close and de-allocate file.\n   ES_UNLOAD_MODULE ID=ES,SPID=FI  |   Unload file handler.\n   ES_TERMINATE     ID=ES          |   Shut down Environment Support.\n   ES_MVS_UNLOAD    ID=ES          |   Unload Environment Support.\n ENDBLK RC=(R2)                    | Set R15 to return-code and exit.\n\n\n:figseg fit=12.\n*---------------------------------------------------------------------*\n*  Program Work Area.\n*---------------------------------------------------------------------*\n              PWA    ,             | Program Work Area.\nPWA_RC        DS     H             |   Display's return code.\nPWA_LEN       DS     F             |   Used for filename &amp. &cont.\nline length.\nPWA_LINE      DS     CL80          |   Current input line.\nPWA_MSG_LEN   DS     F             |   Length of message text.\nPWA_MSG       DS     CL256         |   Warning or error message.\n              ENDPWA ,             | End of PWA.\n              IKJCPPL              | Command Processor Parameter List.\n              END\n:e#x.\n.in -2\n:efig.\n.**********************************************************************\n.**********************************************************************\n.*                                                                    *\n.*                                                                    *\n.*       Chapter. Service Processors And The Structured Macros        *\n.*                                                                    *\n.*                                                                    *\n.**********************************************************************\n:h1.Service Processors And The Structured Macros\n.**********************************************************************\n(intro paragraphs)\n.**********************************************************************\n:h2.Useful Structured Macro Constructs\n.**********************************************************************\n:h2.Service Processor Support\n(intro)\n:h3.BLOCK Macro\n:h3.ERREXIT Macro\n:h3.User-Defined Conditions\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SRVDOC$5": {"ttr": 10248, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x02\\x00\\x00V\\x01\\x11)\\x9f\\x01\\x11)\\x9f\\t'\\x01\\x0b\\x01\\x0b\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@\"", "ispf": {"version": "02.00", "flags": 0, "createdate": "2011-10-26T00:00:00", "modifydate": "2011-10-26T09:27:56", "lines": 267, "newlines": 267, "modlines": 0, "user": "CLEMSON"}, "text": ".*--------------------------------------------------------------------*\n.*                                                                    *\n.*                                                                    *\n.*               Part II. Service Processors Reference                *\n.*                                                                    *\n.*                                                                    *\n.*--------------------------------------------------------------------*\n:h0 id=spref.Service Processors Reference\n.*SRVESMVS*************************************************************\n.*                                                                    *\n.*              Chapter. Description of Service Processors            *\n.*                                                                    *\n.**********************************************************************\n:h1.Description Of Service Processors\n:p.\nThis chapter contains reference information that applies to all service\nprocessors.  Each of the remaining chapters in :hdref refid=spref\npage=no. describes a different kind of service processor, with the\nname of the processor at the bottom of odd-numbered pages for easy\nreference.\n.*--------------------------------------------------------------------*\n:h2.Service Processors\n.*--------------------------------------------------------------------*\n:p.\nA :hp2.service processor:ehp2. is a subroutine that provides a set of\nrelated services using normal subroutine calls to a single point of\nentry.  The first two parameters are the same for all service\nprocessors: a :#xb.token:e#xb. and a :#xb.function code:e#xb..  The\n:#xb.function code:e#xb. parameter is a signed fullword integer set by\nthe calling program to select the desired service.  Two function codes,\n:#x.START:e#x. and :#x.TERMINATE:e#x., are supported by all service\nprocessors.  The :#xb.token:e#xb. parameter is a four byte value whose\ncontents are set by the service processor itself when the\n:#x.START:e#x. function code is selected.  Additional parameters may be\nrequired or optional, depending on the selected function code. The\ngeneral form of a service processor subroutine call looks like:\n:xmp.\ncall service_processor,(token,function_code,additional_parameters)\n:exmp.\n:p.\nAs a general rule, each service processor supports a unique set of\nservices.  For example, there is only one :#x.Memory Manager:e#x. and\nonly one :#x.String Handler:e#x..  In some cases though, several service\nprocessors may support the same set of services but provide access to\ndifferent execution environments or to a different kind of resource.\nFor example, there are several :#x.File Handler:e#x. service processors.\nThey all support pretty much the same services, but for completely\ndifferent kinds of files.\n:p.\nWhen more than one service processor supports the same set of services,\nit is helpful to distinguish between a :hp1.service processor:ehp1. and\nthe :hp1.protocol:ehp1. it follows.  Remember that a service processor\nis a subroutine.  The protocol it follows includes everything a program\nmust know in order to use it: calling sequences, required and optional\nparameters, function codes, return codes, data structures, etc.\n:p.\nWhile the distinction between a service processor and its protocol is\noften blurred, the distinction is important as it allows for flexible\ncode to be written.  The only part of a program that must know what\nservice processor is being used for a given set of services is the part\nthat chooses which subroutine to load.  The remaining code can use the\nprocessor's services without knowing or caring what subroutine is being\ninvoked, so long as it follows the correct protocol.  This makes it easy\nto access various resources or environments that are similar in nature,\nwith little or no change in code.\n.*--------------------------------------------------------------------*\n:h2.Naming Conventions\n.*--------------------------------------------------------------------*\n:p.\nA unique two-letter identification code has been assigned to every\npublicly available service processor.  This code is used as part of\nevery name associated with a service processor protocol.  The service\nprocessor identification codes for all public service processors are\nshown in :tref refid=spics..\n:p.\nUsing :hp1.sp:ehp1. to represent the two-letter service processor\nidentifier codes shown in :tref refid=spics page=no., the various\ncomponents of a service processor are named as follows:\n:ol.\n:li.The names of :hp2.Macros, Symbols, Conditions, Data areas:ehp2., and\neverything other than PDS member names are prefixed with the two-letter\ncode followed by an underscore, \":#x._:e#x.\", followed by an arbitrary\nname.  Any name beginning with \":hp1.sp_:ehp1.\" is a part of the service\nprocessor protocol assigned to the :hp1.sp:ehp1. service processor\nidentification code.\n:li.:hp2.PDS Members:ehp2. for service processors are named as follows:\n:ol.\n:li.:hp2.Load Modules:ehp2. are named :#x.SRV:e#x.:hp1.sp:ehp1., unless\na service processor has an environmental dependency in which case the\nname is :#x.SRV:e#x.:hp1.sp:ehp1.:hp3.env:ehp3., where :hp3.env:ehp3. is\nup to three letters chosen to indicate the dependency.  For example,\n:#x.SRVES:e#x.:#xb.MVS:e#xb.  is the name of the\n:hp3.MVS:ehp3. Environment Support service processor load module.\n:li.:hp2.Assembler COPY members:ehp2. are named\n:#x.SRV:e#x.:hp1.sp:ehp1.:#x.MAC:e#x..\n:li.:hp2.Internal COPY members:ehp2.  are named\n:#x.SRV:e#x.:hp1.sp:ehp1.:#x.IMC:e#x..\n:li.:hp2.Excerciser:ehp2. programs and data are named\n:#x.SRV:e#x.:hp1.sp:ehp1.:#x.XR:e#x.:hp1.z:ehp1., where :hp1.z:ehp1.\nis an arbitrary character (usually :#x.Z:e#x.).\n:li.:hp2.BookMaster Reference Chapters:ehp2. for are named\n:#x.SRVDOC:e#x.:hp1.sp:ehp1..\n:eol.\n:li.:hp2.A composite load module:ehp2. containing various service\nprocessors link-edited together with a Module Name Table and an\nEnvironment Support service processor is named\n:#x.SRVCM:e#x.:hp3.env:ehp3..  The\ncorresponding Environment Support load module is an alias of the\ncomposite (e.g. :#x.SRVESMVS:e#x. is an alias of\n:#x.SRVCMMVS:e#x., where :#x.SRVCMMVS:e#x.\ncontains MVS Environment Support as the main entry point, a module name\ntable, and a number of service processors that have been linked into the\nmodule).\n:eol.\n.*\n:tdef id=spicsd cols='* 0.30i 0.60i 0.60i 0.60i'\n      align='left center center left left'\n      frame=box rules=vert hdframe=rules compact mindepth=p5.\n:table id=spics refid=spicsd.\n:tcap.Service processor codes and member names\n:thd.\n:c.Service Processor\n:c.Code\n:c.Environment Dependent\n:c.Copy Member\n:c.Load Module(s)\n:ethd.\n:tft refid=spicsd temp.\n:c.\n:etft.\n:row.\n:c.Data In Virtual Manager\n:c.:#xb.DV:e#xb.\n:c.:#x.YES:e#x.\n:c.:#x.SRV:#xb.DV:e#xb.MAC:e#x.\n:c.:#x.SRV:#xb.DV:e#xb.MVS:e#x.\n:row.\n:c.Date/Time Services\n:c.:#xb.DT:e#xb.\n:c.:#x.NO:e#x.\n:c.:#x.SRV:#xb.DT:e#xb.MAC:e#x.\n:c.:#x.SRV:#xb.DT:e#x.\n:row.\n:c.Environment Support\n:c.:#xb.ES:e#xb.\n:c.:#x.YES:e#x.\n:c.:#x.SRV:#xb.ES:e#xb.MAC:e#x.\n:c.:#x.SRV:#xb.ES:e#xb.MVS:e#x.\n:row.\n:c.File Handler\n:c.:#xb.FI:e#xb.\n:c.:#x.YES:e#x.\n:c.:#x.SRV:#xb.FI:e#xb.MAC:e#x.\n:c.\n:#x.SRV:#xb.FI:e#xb.OS:e#x.\n:#x.SRV:#xb.FI:e#xb.XID:e#x.\n:#x.SRV:#xb.FI:e#xb.PDF:e#x.\n:#x.SRV:#xb.FI:e#xb.SMS:e#x.\n:#x.SRV:#xb.FI:e#xb.SUB:e#x.\n:row.\n:c.Item Manager\n:c.:#xb.IM:e#xb.\n:c.:#x.NO:e#x.\n:c.:#x.SRV:#xb.IM:e#xb.MAC:e#x.\n:c.:#x.SRV:#xb.IM:e#x.\n:row.\n:c.Memory Manager\n:c.:#xb.MM:e#xb.\n:c.:#x.NO:e#x.\n:c.:#x.SRV:#xb.MM:e#xb.MAC:e#x.\n:c.:#x.SRV:#xb.MM:e#x.\n:row.\n:c.Message\n:c.:#xb.MS:e#xb.\n:c.:#x.NO:e#x.\n:c.:#x.SRV:#xb.MS:e#xb.MAC:e#x.\n:c.:#x.SRV:#xb.MS:e#x.\n:row.\n:c.PrintLine\n:c.:#xb.PL:e#xb.\n:c.:#x.YES:e#x.\n:c.:#x.SRV:#xb.PL:e#xb.MAC:e#x.\n:c.:#x.SRV:#xb.PL:e#xb.MVS:e#x.\n:row.\n:c.String Handler\n:c.:#xb.ST:e#xb.\n:c.:#x.NO:e#x.\n:c.:#x.SRV:#xb.ST:e#xb.MAC:e#x.\n:c.:#x.SRV:#xb.ST:e#x.\n:row.\n:c.Symbol Manager\n:c.:#xb.SY:e#xb.\n:c.:#x.NO:e#x.\n:c.:#x.SRV:#xb.SY:e#xb.MAC:e#x.\n:c.:#x.SRV:#xb.SY:e#x.\n:etable.\n.*--------------------------------------------------------------------*\n:h2 id=linkage.Linkage Conventions\n.*--------------------------------------------------------------------*\n:p.\nService processors conform to standard System/370 linkage conventions\nfor programs running in 31-bit addressing mode.  When the calling\nprogram invokes a service processor function, registers 1, 13, 14, and\n15 must contain the following values, all of which are 31-bit addresses:\n:ul compact.\n:li.Register 1 must contain the address of a variable-length service\nprocessor parameter list.\n:li.Register 13 must contain the address of a 72-byte register save area\naligned on a fullword boundary.\n:li.Register 14 must contain the address to which control will be\nreturned.\n:li.Register 15 must contain the service processor's entry point\naddress\n:eul.\n:p.\nThe parameter list pointed to by register 1 is a sequence of fullword\naddresses aligned on fullword boundaries.  All addresses but the final\none in the list contain a :#x.:hp2.0:ehp2.:e#x. in their high-order\nbit. The final address is denoted by a :#x.:hp2.1:ehp2.:e#x. in its\nhigh-order bit.  Each address in the list points to the corresponding\nparameter that is being passed to the service processor.  This is\ndepicted by :figref refid=plist page=no. below:\n:fig id=plist.\n.sp;.in 0.15i\n.bf hi2\nRegister 1\n.pf\n.bx new thick thick 0.15i 1.15i\n.ti ~ 05;.tp 0.20i\n~&uar.Parmlist\n.bx off\n.sp\n:i1.function code\n:i1.token\n.bf hi2\nParmlist\n.pf\n.se temp='thick 0.15i 1.15i 2.15i 3.15i 3.85i thin 3.95i medium 4.85i'\n.bx new thick &temp.\n.ti ~ 05;.tp 0.18i 1.18i 2.18i 3.40i 3.86i 3.98i\n:elines.\n~&uar.token~&uar.function code~&uar.parameter 1~...\n:#x.:hp2.~1:ehp2.:e#x.~&uar.parameter n\n.bx off\n:figcap.Parameter list conventions\n:efig.\n:p.\nOptional parameters may be omitted by setting their corresponding\nparameter list address (&uar.parameter :hp1.x:ehp1.) to zero.  If the\nparameters to be omitted occur at the end of the parameter list, the\nlist may be terminated early by setting the high-order bit of the last\nsupplied (not omitted) parameter address.  The token and function code\nparameters are :hp1.never:ehp1. optional.  Thus, the minimum possible\ncall to invoke a service processor function looks like the following\n(for a program written with the Structured Macros):\n:xmp.\nCALLX SERVICE_PROCESSOR,(TOKEN,FUNCTION_CODE),VL\n:exmp.\n:p.\nOn return from a service processor function, all registers except\nregister 15 will contain their original values.  Register 15 will be set\nto an integer indicating the results of the function's operation.  This\nvalue is the function's :hp1.return code:ehp1., and each function has\nits own set of return codes.  A return code of zero always indicates\nsuccess.  The reference section for each service processor's function\ndescribes the possible return codes, their meanings, and the appropriate\nactions to be taken by the calling program.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SRVDOC$6": {"ttr": 10499, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x02\\x00\\x00V\\x01\\x11)\\x9f\\x01\\x11)\\x9f\\t'\\x04&\\x04&\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@\"", "ispf": {"version": "02.00", "flags": 0, "createdate": "2011-10-26T00:00:00", "modifydate": "2011-10-26T09:27:56", "lines": 1062, "newlines": 1062, "modlines": 0, "user": "CLEMSON"}, "text": ".**********************************************************************\n.**********************************************************************\n.*                                                                    *\n.*                                                                    *\n.*            Chapter. Writing A Service Processor                    *\n.*                                                                    *\n.*                                                                    *\n.**********************************************************************\n:h1.Writing A Service Processor\n.**********************************************************************\nTypical programmers will often find that they have to perform certain\ntasks over and over when writing code, such as string manipulation, file\nhandling or date conversion.  Usually, such programmers will find, as\nthey talk shop with their colleagues over lunch or a cup of coffee, that\nthey all perform these same tasks, and find them equally repetitive (and\nboring).  Many of the existing Service Processors were conceived in this\nmanner, by programmers who were willing to write some set of functions\none last time in a nice package so they could get on with their lives.\n.*\n:p.This chapter will describe how to write a service processor, and will\nactually develop a working service processor as an example.  The\nconventions which have developed over time will be explained, and the\nphilosophy behind service processors will be presented.  It is assumed\nthat the reader is an experienced assembler programmer, and is familiar\nwith the Clemson Structured Macros, as they will be used in the\nexamples.\n.**********************************************************************\n:h2.Service Processor Conventions\n.*\nThere are several programming conventions that experience has shown to\nwork well for service processors.  Many have evolved from \"unwritten\nrules\", while others are based mainly on convenience and common sense.\n.*\n:ul.\n:li.:hp2.Service processors should always be reentrant.:ehp2.  The\nClemson Structured Macros make reentrancy a simple matter.  In\naddition, a service processor can \"remember\" things across calls,\nsince its program workarea is reused.  Also, a service processor may\nbe called from an authorized program, in which case reentrancy can\nprovide additional protection and security.\n.*\n:li.:hp2.Service processors should be able to operate normally whether\nin an authorized state or not.:ehp2.  For the OS environment, an\n:hp1.authorized state:ehp1. generally refers to a program running\nin supervisor state, a system key, or with APF authorization.\nExceptions are those service processors which require some state (such\nas APF authorization) to perform their function.\n.*\n:li.:hp2.A service processor should be as efficient as possible.:ehp2.\nAssembler-language applications are often written in assembler because\nof performance requirements.  The service processor cannot know this\nbeforehand, so it should always assume that performance is critical to\nits callers.  The use of a performance analysis tool such as STROBE is\nsuggested as a way to optimize routines and find \"hot spots\" in the\ncode during development.\n.*\n:li.:hp2.Service processors can be called directly, or by using\n:hp3.function macros.:ehp3.:ehp2.\n:hp2.Direct calls:ehp2.  generally involve building your own parameter\nlist and coding your own CALL or CALLX, while\n:hp2.function macros:ehp2. allow you to code parameters as macro\nkeywords.  The main advantage of function macros to a service\nprocessor's caller is the amount of housekeeping and repetitive coding\nthat is eliminated.  The main advantage to the service processor's\n:hp1.author:ehp1. is that the use of function macros simplifies the\ntask of documenting the service processor.\n.*\n:li.:hp2.A service processor should be environment-independent if\npossible.:ehp2.  This simply means that the service processor should\ncall Environment Support or other environment-dependent service\nprocessors to do environment-dependent things, like obtain memory or\ndeal with files.  This tends to isolate the service processor from its\nenvironment, and also makes it easy to transport to a different\nenvironment (for example, from OS to IDMS/DC) as long as\nenvironment-dependent routines are available in the new environment.\n.*\n:li.:hp2.A service processor should avoid abends.:ehp2.  This includes\nprogram checks as well as \"unrecoverable\" errors where the programmer\nassumes that the only thing left to do is terminate the caller's task.\nIf a service processor abends :hp1.for any reason:ehp1., it should be\nconsidered as a bug unless there's a good excuse (for example, if the\nchecks required to prevent a particular abend would severely impact\nthe service processor's performance).  Service processors, as a rule,\nshould make reasonable attempts to check caller-provided parameters\nfor validity:  the number of parameters, nonzero addresses for\nrequired information, the validity of the service processor's token,\nand so on.\n.*\n:li.:hp2.Service processors should return specific return codes for\nany error and let the caller decide if the situation merits an abend\nor not.:ehp2.  The service processor environment provides a\n:hp1.general debug information:ehp1. area that service processors can\nsave information in:  these areas can be stacked (in case one service\nprocessor calls another).  The debug area can be displayed by the\ncaller using\n:#x.ES_Display_Debug_Info:e#x. or\n:#x.ES_Display_Debug_Info_And_Abend:e#x.: a service processor should\nnot take it upon itself to display the debug information.\n.*\n:li.:hp2.It's OK for a service processor to call other service\nprocessors.:ehp2.\nIf this is done, the service processor should not display its debug\ninformation due to another service processor's error, but should save\nits own debug information instead and return a meaningful error to its\ncaller (which may be yet another service processor).  This way, the\ncaller can display the debug information and see a trace of how the\nerror occurred.\n.*\n:li.:hp2.If a service processor cannot recover from some situation,\nsome method should be used to restrict subsequent calls.:ehp2.  For\nexample, when the OS File Handler cannot create a file as requested, a\nflag is set that disallows any other call except\n:#x.FI_Terminate:e#x..\n.*\n:eul.\n.**********************************************************************\n:h2 id=spcc.The \"Cheap Calculator\" Service Processor\n.*\nThroughout the rest of this chapter, examples will be used to\nillustrate aspects of service processor development.  Our examples\nwill actually develop a working service processor, which will emulate\na four-function calculator.  The \"Cheap Calculator\", or :#x.SRVCC:e#x.\nservice processor, will have five simple functions: Add, Subtract,\nMultiply, Divide and Clear, as well as Start and Terminate.  For the\nsake of brevity, this is a really cheap calculator that can only\nhandle integer arithmetic.  The calculator's \"display\" is maintained\ninternally by SRVCC and returned to the caller after each operation:\nthe caller can perform operations on the display, or set it to zero by\nclearing it.\n.*\n:p.SRVCC, while simple and small, contains all of the components and\nattributes of a service processor, and can be used as a model for\ndeveloping a more elaborate set of routines.\n.**********************************************************************\n:h2.Components Of A Service Processor\n.*\n:h3.The Service Processor Load Module\nThe executable copy of the service processor is a load module residing\neither in the system linklist or a load library that the caller must\nreference via :#x.STEPLIB:e#x..  Publicly-available service processors\nhave a naming convention, as follows:\n:ul.\n:li.The load module name begins with \"SRV\".\n:li.The characters \"SRV\" are followed by a two-character\nidentifier (\"CC\" in our example).\n:li.If the service processor is environment-dependent, the remainder\nof the load module name identifies the environment (for example,\n\"MVS\" for an MVS-dependent module).\n:eul.\n:p.In MVS/XA, the load module should have the attributes\nAMODE(31) and RMODE(ANY), unless this is not possible\nfor some reason (for example, the service processor might use QSAM,\nwhich requires RMODE(24)).  The service processor should expect to be\ncalled AMODE(31).\n.*\n:h3.The Service Processor Copy Member\nIt is customary to provide a copy member containing global symbols,\nfunction macro definitions and any other tools that might\nhelp the programmer code up calls to the service processor.\n.*\n:h4.The SRV##ID Macro\n.*\nThe :#x.SRV##ID:e#x. macro can set or override the\n:#x.EPA:e#x., :#x.TOKEN:e#x. and :#x.ESVA:e#x. parameters via global\nsymbols unique for each service processor ID used in a program.\n:#x.SRV##ID:e#x. relieves the function macro author of a number of\nprogramming chores.  Generally, one would code a :#x.SRV##ID\nSET:e#x. in the service processor's ID macro to establish these\nsymbols for the rest of the macros, and to generate storage for\nthose fields that aren't specified.  Subsequent function macros\nwould issue :#x.SRV##ID GET:e#x. to retrieve these symbols.\n.*\n:h4.DEFUCOND Macros\n.*\nDEFUCOND macros should be defined for each of the service processor's\npossible return codes.  These macros should have the same name as the\ncorresponding return code's global symbol.  The condition name must\nbe preceded with a \"%\" when used in a conditional statement, as\nshown in\n:figref refid=macdefx..\n.*\n:fig id=macdefx width=column concat=no.\n:figcap.User-Defined Condition Example\n:#x.\n    CC_ADD  ID=CC,VALUE=5,DISPLAY=PWA_DISPLAY\n    IF    (TREG,R15,NZ)\n      IF    (%CC_OVERFLOW)\n        CALLSUB OVERFLOW\n      ELSE\n        ERREXIT NAME=CC_ERROR\n      ENDIF\n    ENDIF\n:e#x.\n:efig.\n.*\n:p.Use the :#x.SRV##RC:e#x. macro to actually generate\nthe return code comparison, as illustrated in\n:figref refid=macdefu..\n.*\n:fig id=macdefu width=column concat=no.\n:figcap.DEFUCOND Macros For SRVCC\n:#x.\n *---------------------------------------------------------------------*\n * DEFUCOND macros to facilitate checking return codes.\n *---------------------------------------------------------------------*\n    DEFUCOND MACRO=SRV##RC,NAME=CC_INVALID_CC_ID\n    DEFUCOND MACRO=SRV##RC,NAME=CC_INVALID_NUMBER_OF_PARMS\n    DEFUCOND MACRO=SRV##RC,NAME=CC_INVALID_FUNCTION\n    DEFUCOND MACRO=SRV##RC,NAME=CC_OVERFLOW\n    DEFUCOND MACRO=SRV##RC,NAME=CC_PARAMETER_MISSING\n :e#x.\n:efig.\n:h4.The ID Macro\nThere are a number of parameters that would be coded repeatedly if a\nservice processor was called using normal means (:#x.CALL:e#x. or\n:#x.CALLX:e#x.).  A major advantage of the function macros is that\nthey can be made to \"remember\" this information, and can even generate\nsome of the storage required to hold it.\n.*\n:p.The ID macro uses the :#x.SRV##ID SET:e#x. macro to\nestablish global symbols for the service processor's session\ndefaults, as shown in :figref refid=macid..\n.*\n:fig id=macid   width=column concat=no.\n:figcap.CC_ID Macro For SRVCC\n:#x.\n.su off\n *---------------------------------------------------------------------*\n *\n *  CC_ID Macro: Establish default values for a specific service\n *               processor and associate them with the specified ID\n *               name.  The values are stored in the following created\n *               global variables, which are used by the other macros:\n *\n *    Variable Name                     Description\n *    -------------  -----------------------------------------------\n *    #$&ID.$#IDMAC  Name of macro that created the ID: CC_ID.\n *    #$&ID.$#ESID   Service processor's Environment Support ID.\n *    #$&ID.$#EPN    Tag for Service processor's Entry Point Name.\n *    #$&ID.$#EPA    Tag for Service processor's Entry Point Address.\n *    #$&ID.$#TKN    Tag for Service processor's Entry Point Token.\n *\n *---------------------------------------------------------------------*\n          MACRO\n          CC_ID &ID=,&ESVA=,&SPEPNAME=,                                *\n                &SPEPA=,&SPTOKEN=,&ESID=\n .*\n .* Invoke SRV##ID to create globals used by all ID's.\n .*\n          SRV##ID SET,ID=&ID.,IDMAC=CC_ID,                             *\n                ESID=&ESID.,SPEPNAME=&SPEPNAME,                        *\n                SPEPA=&SPEPA,SPTOKEN=&SPTOKEN.\n          MEND\n.su on\n:e#x.\n:efig.\n.*\n.*\n:h4.The Function Macros\n.*\nThe remainder of the function macros, for the most part, will\ngenerate executable code and will call the service processor\nwith appropriate parameters for the function desired.\nThe macro itself should perform reasonable checks for the\npresence and validity of parameters, and may perform any\nadditional checking or processing required.\n.*\n:h4.Global Symbols\n.*\nThere are several groups of global symbols used by the service\nprocessor macros, the service processor code itself, and/or the\nprogram that will use the service processor.\n.*\n:h5.Symbols Required By SRV##ID:\n.*\n:#x.SRV##ID SET:e#x. will define and set a number of unique global\nsymbols.  The symbols are unique in that each symbol name contains the\nID name specified on the service processor's ID macro.  Symbols\ncreated by :#x.SRV##ID SET:e#x. are only used by :#x.SRV##ID GET:e#x.,\nand the developer should not be concerned about them.\n.*\n:p.:#x.SRV##ID GET:e#x. returns the values of these symbols in a\nseries of fixed-name symbols to the calling macro.  The individual\nsymbols and their meanings are:\n.*--------------------------------------------------------------------*\n:tdef id=tsrvidf cols='*'.\n:tdef id=tsrvidd cols='2* 2* 5*' frame=box rules=both\n     hdframe=rules compact mindepth=p5\n     split=yes concat=yes width=column.\n:table id=tsrvids refid=tsrvidd.\n:tcap.Variables Returned By ##SRVID GET\n:thd.\n:c.Keyword\n:c.GET Returns\n:c.Description\n:ethd.\n:row.:c.ID\n     :c.&amp.#_IDMAC\n     :c.The ID value for this service processor session\n:row.:c.IDMAC\n     :c.&amp.#_IDMAC\n     :c.Name of the ID macro that generated this information\n:row.:c.ESID\n     :c.&amp.#_IDESID\n     :c.ID of the associated Environment Support session\n:row.:c.ESVA\n     :c.&amp.#_IDESVA\n     :c.Storage tag containing the ESV address\n:row.:c.SPEPNAME\n     :c.&amp.#_IDEPN\n     :c.Service processor's CL8 entry name\n:row.:c.SPEPA\n     :c.&amp.#_IDEPA\n     :c.Service processor's entry point address\n:row.:c.SPTOKEN\n     :c.&amp.#_IDTKN\n     :c.Storage tag containing token for this service\nprocessor session\n:etable.\n.*\n:h5.Function Code And Return Code Symbols:\n.*\nAll function codes and return codes should have global symbols\nassigned to them.  Note that when the copy member is copied into the\ncalling program, these symbols are defined in open code:  this means\nthat the caller can reference them with no additional effort, but the\nfunction macros defined in the copy member must reference those global\nsymbols that they need.  This will always include the function code\nsymbol, and often will include any global symbols specific to the\nservice processor.\n.*\n:fig id=macsyms width=column concat=no.\n:figcap.Symbol Definitions For SRVCC\n:#x.\n.su off\n *---------------------------------------------------------------------*\n *  Service processor module name.\n *---------------------------------------------------------------------*\n    GBLC   &CHEAP_CALCULATOR\n &CHEAP_CALCULATOR SETC '''SRVCC    '''\n *---------------------------------------------------------------------*\n *  Function symbols.\n *---------------------------------------------------------------------*\n    GBLA   &CC_START,&CC_TERMINATE\n    GBLA   &CC_ADD,&CC_SUBTRACT,&CC_MULTIPLY,&CC_DIVIDE\n    GBLA   &CC_CLEAR\n &CC_START         SETA   1\n &CC_TERMINATE     SETA   2\n &CC_ADD           SETA   3\n &CC_SUBTRACT      SETA   4\n &CC_MULTIPLY      SETA   5\n &CC_DIVIDE        SETA   6\n &CC_CLEAR         SETA   7\n *---------------------------------------------------------------------*\n *  Return code symbols.\n *---------------------------------------------------------------------*\n   GBLA    &CC_INVALID_CC_ID\n   GBLA    &CC_INVALID_NUMBER_OF_PARMS\n   GBLA    &CC_INVALID_FUNCTION\n   GBLA    &CC_OVERFLOW\n   GBLA    &CC_PARAMETER_MISSING\n &CC_INVALID_CC_ID           SETA  1\n &CC_INVALID_NUMBER_OF_PARMS SETA 2\n &CC_INVALID_FUNCTION        SETA  3\n &CC_OVERFLOW                SETA  4\n &CC_PARAMETER_MISSING       SETA  5\n.su on\n:e#x.\n:efig.\n.*\n:h5.Other Symbols:\n.*\nGenerally, if additional global symbols would simplify the tasks of\nthe service processor's users or its author, they should be provided.\nOne example of such symbols is the time, date and duration symbols\nprovided by the Date/Time Service Processor.\n.*\n:h4.Parameter Validity Checking\n.*\nMuch of the validity checking performed by a service processor can be\nperformed at assembly time by the function macros.  This is not to say\nthat the service processor code should not validity-check the\nparameters as well:  a caller may use :#x.CALLX:e#x. to call the\nservice processor, a parameter list may be overlaid at execution time,\nor some other unforeseen problem may occur.  Validity checking by the\nfunction macros is primarily for the programmer's benefit, as this\ntends to catch common errors (omitted or mutually exclusive\nparameters, constants where addresses should be specified, and so on)\nat assembly time.\n.*\n:h4.CALLX Vs. ##PLIST\n.*\nThe Structured Macros include the ##PLIST macro, which is used\ninternally by PLIST, CALLSUB and CALLX to build parameter lists.\n##PLIST has 3 forms: :#x.\"START\":e#x. to initiate a parameter list,\n:#x.\"END\":e#x. to terminate one, and :#x.\"PARM,parameter\":e#x.\nto add a parameter to the list being built.  ##PLIST is\nespecially useful for building variable-length parameter lists,\nas shown in :figref refid=mac##pl..\n:fig id=mac##pl  width=column concat=no.\n:figcap.Building A Variable-Length Parameter List Using ##PLIST\n:#x.\n.su off\n .*\n .* Given a parameter containing a VL list of things (in this case,\n .* \"SOURCE=(p1,p2,p3,...,pn)\"), generate the base parameter list.\n .*\n          ##PLIST START                   | Generate PWA tag, code\n          ##PLIST PARM,&#_IDTKN           | Initial parms\n          ##PLIST PARM,&SRVPROC_FUNCTION  |\n          ##PLIST PARM,&#_ESVA            |\n .*\n .* Generate a VL list from the operand(s) of SOURCE, if any.\n .*\n &N       SETA  1\n .PL_LOOP ANOP  ,                         |\n          AIF   (&N GT N'&SOURCE).PL_LOOPEND\n          ##PLIST PARM,&SOURCE(&N)        | Entry for SOURCE(n)\n &N       SETA  &N+1                      |\n          AGO   .PL_LOOP                  |\n .PL_LOOPEND ANOP ,\n .*\n .* Terminate the parameter list and call service processor.\n .*\n          ##PLIST END,VL      | Set X'80' on last parm, load R1\n          CALLX  &#_IDEPA     | Call the service processor.\n          MEXIT\n.su on\n:e#x.\n:efig.\n.*\n:h4.The CC_Add Macro\n.*\n:figref refid=macaddm. illustrates the :#x.CC_Add:e#x. macro,\nwhich uses the basic components of a function macro.\n.*\n:fig id=macaddm  width=column concat=no.\n:figcap.CC_ADD Macro For SRVCC\n:#x.\n.su off\n *---------------------------------------------------------------------*\n *  CC_Add Macro.\n *  Format:    CC_ADD    ID=CC,\n *                       SPEPA=CC_entry_point_address,  (*)\n *                       SPTOKEN=CC_token_address,      (*)\n *                       ESVA=ESV_address,              (*)\n *                       VALUE=address | constant | register,\n *                       DISPLAY=address | register\n *  (*) - These may be defaulted to values set or generated by CC_ID.\n *---------------------------------------------------------------------*\n          MACRO\n          CC_ADD  &ID=,&SPEPA=,&SPTOKEN=,&ESVA=,        |              *\n                &VALUE=,&DISPLAY=                       |\n          GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA  |  SRV##ID\n          GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN              |   Symbols\n          GBLA  &CC_ADD                                 | Function code\n .*\n .* Obtain service processor ID values.\n .*\n          SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN,ESVA),  | Fill out the   *\n                ID=&ID,IDMAC=CC_ID,                   | defaults from  *\n                SPEPA=&SPEPA,SPTOKEN=&SPTOKEN,        | CC_ID macro.   *\n                ESVA=&ESVA.                           |\n          AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT\n .*\n .* Ensure required parameters are present.\n .*\n          AIF  ('&VALUE' EQ '').MISSING     | VALUE is required\n          AIF  ('&DISPLAY' EQ '').MISSING   | DISPLAY required\n          AIF  (T'&DISPLAY EQ 'N').BADDISP  | DISPLAY can't be constant\n .*\n .* Generate the CC_ADD call.\n .*\n          ##PLIST START            |     Start parmlist generation.\n          ##PLIST PARM,&#_IDTKN    |     Parameter 1: Token.\n          ##PLIST PARM,&CC_ADD     |     Parameter 2: ADD function.\n          ##PLIST PARM,&#_IDESVA   |     Parameter 3: ESVA.\n          ##PLIST PARM,&VALUE      |     Parameter 4: Function-specific.\n          ##PLIST PARM,&DISPLAY    |     Parameter 5: Function-specific.\n          ##PLIST END,VL           |     Set VL bit, load register 1\n          CALLX  &#_IDEPA          |     Call the service processor.\n          MEXIT\n .MISSING MNOTE 8,'Required parameter(s) missing.'\n          MEXIT\n .BADDISP MNOTE 8,'Invalid address of ''&DISPLAY'' for DISPLAY.'\n .MEXIT   MEND\n.su on\n:e#x.\n:efig.\n.*\n.*\n:h5.Miscellaneous Macros:\n.*\nIf your service processor makes use of complex parameters\n(control blocks, parameters that point to other parmlists,\ntext with control information, etc.), consider creating some\nmacros that will help the programmer deal with your service\nprocessor.\nAs an example, the Message Services service processor includes\na set of macros to generate message CSECTs: these macros do not\nproduce executable code, but create the message text and\nassociated data structures that would be tedious and\ntime-consuming to produce manually.\n.*\n:h3.The User's Guide And Reference\n.*\nThe :hp1.Service Processors User's Guide And Reference:ehp1. (this\ndocument) should contain a chapter for each publicly-available service\nprocessor, and writing the chapter should be considered among the tasks\ninvolved in writing a new service processor.  The chapters reside in\n:#x.SYSTEMS.SRV.SOURCE:e#x., as members :#x.SRVDOCxx:e#x.,\nwhere :#x.xx:e#x. is the service processor's two-character ID.\n.*\n:h2.Writing The Code\n.*\nBy now, it should be apparent that the task of actually writing the\nservice processor code is only part of the work involved.  The code\nfor a service processor, once a basic framework is in place, is\nactually fairly simple to produce.  The elements of this framework\nexist in all service processors, and indeed are often copied from\nan existing service processor when a new one is being written.\n.*\n:h3.Structured Macro Support\n.*\nService processors are invariably written using the Structured Macros.\nIn addition to the \"standard\" set of macros and tools, the Structured\nMacros contain support intended to facilitate the coding of service\nprocessors.\n.*\n:h4.OPTIONS=*SRVPRC\n.*\nThe super option *SRVPRC must be coded on the\n:#x.BLOCK TYPE=PROGRAM:e#x. macro for any service processor.  In\naddition to the options provided by the *PWA super option,\n*SRVPRC also includes the following:\n.*\n:ul.\n:li.:hp2.XA:ehp2.: Causes XA-only instructions (BAS, BASR) to be\nused for linkage by CALLSUB and CALLX.\n.*\n:li.:hp2.NO370:ehp2.: Excludes bimodal code around linkage sequences.\n.*\n:li.:hp2.(REUSPWA,1):ehp2.: Specifies that a reusable PWA should be\nused, and that its address is the first parameter in the parameter\nlist (e.g. the token).  This option causes a PWA to be getmained and\nanchored off of this address when the START function is invoked.\n.*\n:li.:hp2.(FNCODE,2,AL4(1)):ehp2.: Indicates that the function code\nwill be the second parameter, and that the START function's code\nis 1.\n.*\n:li.:hp2.(ESV,3,PWAAESV):ehp2.: Specifies that the ESV address is the\nthird parameter, and provides the tag in the PWA where the ESV address\nwill be stored when START is invoked.  The presence of the ESV\nparameter will also cause BLOCK and ENDBLK to call Environment\nSupport's linkage GETMAIN and FREEMAIN routines, instead of generating\ntheir own GETMAIN and FREEMAIN macros.\n.*\n:li.:hp2.ERRADDR:ehp2.: Instructs the ERREXIT macro to use a BAS\ninstruction to call the error exit.  If the :#x.code:e#x. operand of\nERREXIT is provided, the value of :#x.code:e#x. is generated as a\nhalfword immediately following the BAS instruction.  This allows the\nERREXIT routine to save the address where the error was detected in\nthe debug area.\n:li.:hp2.CLRDEBUG:ehp2.: Specifies whether the debug area should be\ncleared upon each entry to the program block.\n:eul.\n.*\n:p.If additional program block options are required or should be\nturned off, they can be coded normally following the *SRVPRC super\noption.\nRefer to the\n:hp1.Clemson University Structured Programming Macros\nUser's Guide And Reference:ehp1. for additional information.\n.*\n:h4.SMCTRL\n.*\nThe *SRVPRC super option causes the service processor's PWA to be\ngetmained during the START call, and retained across subsequent\ncalls: hence, the TERMINATE routine should include the macro\n:#x.SMCTRL FREEPWA=YES:e#x..  This sets a flag in the PWA which\nwill cause the service processor's ENDBLK macro to freemain the\nPWA.\n.*\n:h4.Parameter List Support\n.*\nThe BLOCK macro can set up a base register for the service processor's\nparameter list, as well as counting the parameters, by specifying\n:#x.(PARMS,(USING,reg),(COUNT,pwa_fullword),VL):e#x.  among the\n:#x.OPTIONS:e#x.  and coding the operand :#x.PARMMAP=dsect_name:e#x..\nThere is also a :#x.COPYPARM:e#x. option which will reserve PWA\nstorage for the largest possible parameter list and copy the caller's\nparameter list to the PWA for each call, ensuring that all unused\nparameters in the copy are set to zero.  While :#x.COPYPARM:e#x. may\nbe desirable, it can take an excessive amount of time if large\nparameter lists are in use.\nRefer to the\n:hp1.Clemson University Structured Programming Macros\nUser's Guide And Reference:ehp1. for additional information.\n.*\n:h3.The Parameter List\n.*\nThe typical service processor parameter list, as has already been\ndemonstrated, contains a common set of parameters at its beginning\nfollowed by zero or more function-specific parameters.  The common\nparameters, as well as a suggested format for the parameter list\nDSECT, are presented below.\n.*\n:h4.The Function Code\nThe first parameter of any service processor call is the address\nof a :#x.function code.:e#x.  The\n:#x.function code:e#x.\nis always a fullword containing some nonzero numeric value, and is\nused to request a particular function from the service processor.\nValues of F'1' and F'2' are generally used for :#x.Start:e#x.  and\n:#x.Terminate:e#x. respectively.\nGlobal symbols are usually defined in the service processor's\ncopy member for the function codes, as seen in\n:figref refid=macsyms..\n.*\n:h4.The Token\n.*\n:p.The token serves to uniquely identify a service processor \"session\",\nand is returned by the :#x.START:e#x. function.  Each time it is called,\nthe service processor will validate its token by ensuring that some\nfield(s) in its PWA have been set to some identifiable value.  The token\nfacility allows a program to activate multiple service processor\n\"sessions\" by issuing multiple\n:#x.START:e#x. calls and saving the different tokens, then using the\ntokens to refer to individual sessions on subsequent calls.\n.*\n:p.For example, one might wish to read two files and create a third\nfile:  this could be done by starting three separate File Handler\nsessions with appropriate parameters, and using the three tokens as\nunique identifiers.  Using the function macros, the caller can isolate\nhimself somewhat from specifying (or even defining!) the token by\nallowing the ID macro (and its call to :#x.##SRVID SET:e#x.)  to\ngenerate the tokens' storage and associate an ID value with each token.\n.*\n:h4.The ESV Address\n.*\nAs a rule, the ESVA, or ESV address, is passed as the third\nparameter to at least the :#x.START:e#x. function. If an ESV address is\nprovided to the :#x.START:e#x. function, the service processor can\nsave the address and allow subsequent parameter lists to be shorter:\nhowever, an invalid-token error (where the PWA pointer is not valid)\nmay degenerate into \"unpredictable results\" when the service processor\nattempts to use Environment Support to save error information.\n.*\n:h4.Other Parameters\n.*\nIndividual functions will, of course, have zero or more\nfunction-specific parameters.\n.*\n:h4.The Parameter List DSECT\n.*\nTypically, the DSECT for the service processor's parameter list will\ncontain the following:\n:ul.\n:li.A \"common\" section at the beginning containing the token and\nfunction code.\n:li.Individual sections for each set of function-specific parameters,\nusing :#x.ORG:e#x. to redefine the storage for each function.\n:li.A tag for every parameter.  The tags should contain the function\nname (or an abbreviation) for function-specific parameters.\n:li.An :#x.EQU:e#x. at the end of the shortest function-specific\nsection (or at the end of the common section if appropriate), set to\nthe minimum number of parameters that the service processor supports.\n:li.An :#x.EQU:e#x. at the end of each function-specific section, set\nto the number of parameters that the function allows.  If the function\nsupports a variable number of parameters, two\n:#x.EQU:e#x.'s should be used for the minimum and maximum number of\nparameters.\n:li.An :#x.EQU:e#x. at the end of the DSECT, set to the maximum\nnumber of parameters that the service processor supports.\n:eul.\n.*\n:p.The parameter list DSECT for SRVCC appears in\n:figref refid=ccparmd..\n:fig id=ccparmd width=column concat=no.\n:figcap.SRVCC's Parameter List DSECT (Partial)\n:#x.\n.su off\n title \"SRVCC -- Parameter List DSECT\"\nparmlist          dsect ,             |\nprm_CC_id         ds a                | CC_identifier === PWA base\nprm_functioncode  ds a                | Function to be performed\nprm_min_#         equ (*-parmlist)/4  | Minimum number of parameters\n*                                     |   (defined here since there are\n*                                     |   functions with no function-\n*                                     |   specific parameters).\nprm_function_dept equ *               | Function-dependent parameters:\n*---------------------------------------------------------------------*\n*                  Start function parameters\n*---------------------------------------------------------------------*\n                  org prm_function_dept\nprm_start_esv     ds a                | Environment Support Vector.\nprm_start_min_#   equ (*-parmlist)/4  | Minimum # START parameters.\nprm_start_max_#   equ (*-parmlist)/4  | Maximum # START parameters.\n*---------------------------------------------------------------------*\n*                 Terminate function parameters\n*---------------------------------------------------------------------*\n               org prm_function_dept  |\nprm_terminate_#   equ (*-parmlist)/4  | No function-specific parms.\n*---------------------------------------------------------------------*\n*                 CC_Add function parameters\n*---------------------------------------------------------------------*\n               org prm_function_dept  |\nprm_add_value     ds    f             | Value to add to display.\nprm_add_display   ds    f             | Where to store updated display.\nprm_add_#         equ (*-parmlist)/4  |\n*---------------------------------------------------------------------*\n*     Other function-dependent parameter sections defined here.\n*---------------------------------------------------------------------*\n               :\n               :\n*---------------------------------------------------------------------*\n*            End of function-dependent parameter sections.\n*---------------------------------------------------------------------*\n                org ,                 |\nprm_max_#          equ (*-parmlist)/4 | Maximum number of parameters.\n.su on\n:e#x.\n:efig.\n.*\n:h4.Parameter List Validation\n.*\nOne of the best ways to avoid abends by a service processor is to\nscrutinize the caller's parameters carefully.  Invalid numbers of\nparameters, missing parameters and incorrect data provided by the\ncaller should be checked, and a descriptive error returned if\na problem is detected.\n.*\n:h5.Common Parameter Validation.\nThe validations listed here are standard for any service processor.\nThey should be coded following the program block macro, and prior\nto the main case block.\nThe equivalent code for SRVCC is shown in :figref refid=macent..\n.*\n:ul.\n:li.:hp2.Function code::ehp2.  The function code should be one\nsupported by the service processor.  Usually, a symbol in the\ncopy member defining the highest-used function code is used to\ncheck the function code passed by the caller.  A function code\nof zero is generally invalid (since it may represent a\nmissing parameter).\n.*\n:li.:hp2.Token::ehp2.  After a successful START, the token should\npoint to the service processor's PWA.  The START code will usually set\nsome unique value at a fixed offset in the PWA that subsequent\ncalls can check: generally, this is the PWA address followed by some\nshort character string (for example, :#x.CC_ID:e#x.) that can be\nchecked quickly.\n.*\n:li.:hp2.Number of parameters::ehp2.  The parm count can be set by\n:#x.OPTIONS=(...,(PARMS,(COUNT,:hp1.pwa_count_field:ehp1.),...)):e#x.\non the program block macro.  This count field should be checked\nagainst the minimum and maximum number of parameters supported.\n:eul.\n.*\n:h5.Function-Specific Parameter Validation.\n.*\nThe code at the start of an individual function should, first of all,\nensure that the number of parameters passed is acceptable for that\nfunction.  In addition, the validation code should check for missing\nparameters (a zero pointer in the parameter list), as well as anything\nthat might cause a program check (a zero value to be used for\ndivision, invalid packed-decimal data, etc).  Keep in mind, however,\nthat excessive validity checking will probably impact the service\nprocessor's performance.\n.*\n:h3.Entry Logic\n.*\nThe BLOCK macro can be made to perform most of the housekeeping chores\nof entering a service processor, such as setting up base registers,\nclearing the debug area, and counting the parameters.  The remaining\nentry logic may then consist of ERREXIT macros: these should ensure\nthat at least a minimum and no more than a maximum number of parameter\nwere specified, as well as performing some simple validity check on\nthe PWA.  This validity check is typically a check for some unique\nthing in the PWA that the START function put there.\n.*\n:fig id=macent  width=column concat=no.\n:figcap.Entry Logic For SRVCC\n:#x.\n.su off\n  title \"SRVCC -- Initialization\"\n  block name=SRVCC,type=program,amode=31,rmode=any,                    *\n                options=(*srvprc,long,                                 *\n                (parms,(using,r11),(count,pwa_number_of_parms),vl)),   *\n                parmmap=parmlist,basereg=(r12,r9),                     *\n                subopts=(*swa,loadbase)\n * *------------------------------------------------------------------*\n * * Ensure that at least the minimum and no more than the maximum\n * * number of parameters were passed in the parameter list.\n * *------------------------------------------------------------------*\n   l     r0,pwa_number_of_parms        | Save number of parms.\n   errexit    (ch,r0,lt,=y(prm_min_#)),      Ensure number of parms    *\n                or,(c,r0,gt,=a(prm_max_#)),    is within limits.       *\n                code=&CC_invalid_number_of_parms\n   l     r1,prm_functioncode           | Load the function code into\n   l     r1,0(,r1)                     |   a register for testing.\n * *------------------------------------------------------------------*\n * * If the function code is something other than start, make sure that\n * * the PWA contains the eye-catcher string and the correct value for\n * * CC_ID.   If not, then the CC_ID passed in is garbage.\n * *------------------------------------------------------------------*\n   if (c,r1,ne,=f'&CC_start')          | If not startup function:\n    errexit ((clc,pwa_visual,ne,psd_eyecatcher),  Check eyecatcher &  *\n                or,(c,r13,ne,pwa_CC_id)),   PWA's address of itself;  *\n                code=&CC_invalid_CC_id |    error if they don't match.\n   endif                               | Endif.\n.su on\n:e#x.\n:efig.\n.*\n:h3.The Main CASE Block\n.*\nThe simplest way to process the function code is with a case block.\nThis is usually the heart of any service processor.  The individual\nfunctions may be coded as subroutines, or may be handled inline if\nthey're not too complex. Refer to\n:figref refid=macstrt. and\n:figref refid=macadd. for examples.\n.*\n:h3.The START And TERMINATE Functions\n.*\nThe START routine should perform whatever initialization the\nservice processor requires, such as starting other service\nprocessors or opening files.\nIn addition, the START function\nshould establish some unique value or values\nin the PWA that can be used by other functions for validity\nchecking.  Generally, a fullword containing the PWA address\nand some character string is used: the character string also\nserves as an eyecatcher when a dump is taken.\n.*\n:p.The TERMINATE routine should take care of any\nend-of-task processing required, such as closing files or\nterminating other service processors.  The TERMINATE\nroutine should also include the macro\n:#x.SMCTRL FREEPWA=YES:e#x. to cause the program's ENDBLK\nto freemain the PWA.\n.*\n:p.The START and TERMINATE routines for SRVCC are illustrated\nin :figref refid=macstrt..\n.*\n:fig id=macstrt width=column concat=no.\n:figcap.The CC_Start And CC_Terminate Functions\n:#x.\n.su off\n    title \"SRVCC -- CC_Start Function\" |\n * *------------------------------------------------------------------*\n * * Select the code to process the function.\n * *------------------------------------------------------------------*\n   caseblk reg=r1                      | Start of function case block.\n   space 1                             |\n *  *-----------------------------------------------------------------*\n *  * Start function.\n *  *-----------------------------------------------------------------*\n    case &CC_start                     |  Start function.\n *   *----------------------------------------------------------------*\n *   * Set the eyecatcher and the CC_ID fields.   These are checked\n *   * each time the CC server is entered to avoid integrity problems.\n *   *----------------------------------------------------------------*\n     mvc   pwa_visual,psd_eyecatcher   |   Set the eyecatcher and the\n     st    r13,pwa_CC_id               |   CC_ID are for validity checks\n     xc    pwa_clear_start(pwa_clear_length),pwa_clear_start\n *   *----------------------------------------------------------------*\n *   * Make sure that a valid number of parameters are specified.\n *   *----------------------------------------------------------------*\n     l     r3,pwa_number_of_parms      |   Load r3 with number of parms.\n     errexit    (ch,r3,lt,=y(prm_start_min_#)),or,   Error if out      +\n                (ch,r3,gt,=y(prm_start_max_#)),      of bounds.        +\n                code=&CC_invalid_number_of_parms\n     space 1                           |\n     l    r1,pwaaesv                   | Load pointer to ESV.\n     using esv,r1                      |\n     mvc   pwa_es_epa,esvesepa         | Copy EPA and token addresses\n     mvc   pwa_es_token,esvestkn       | for current Env. Support sess.\n     drop  r1                          |\n     slr   r0,r0                       |\n     st    r0,pwa_display              | Clear the \"display\".\n *  *-----------------------------------------------------------------*\n  title \"SRVCC -- CC_Terminate Function\"\n *  *-----------------------------------------------------------------*\n *  *  CC_Terminate function.\n *  *-----------------------------------------------------------------*\n    case &CC_Terminate                 |\n     l     r3,pwa_number_of_parms      |   Load r3 with number of parms\n     errexit    (ch,r3,lt,=y(prm_terminate_#)),  Error if not correct. +\n                code=&CC_invalid_number_of_parms\n     smctrl  freepwa=yes               |\n *  *-----------------------------------------------------------------*\n.su on\n:e#x.\n:efig.\n.*\n:h3.Other Functions\n.*\nEach service processor function should ensure that it was passed the\nappropriate number of parameters, and that they contain or point to\nvalid information.\n.*\n:fig id=macadd width=column concat=no.\n:figcap.The CC_Add Function\n:#x.\n.su off\n title \"SRVCC -- CC_Add Function\"     |\n *  *-----------------------------------------------------------------*\n *  *  CC_Add function.\n *  *-----------------------------------------------------------------*\n    case &CC_Add                       | Add function.\n     l     r3,pwa_number_of_parms      |   Load r3 w/ number of parms.\n     errexit    (ch,r3,ne,=y(prm_add_#)),  Error if not correct.       *\n                code=&CC_invalid_number_of_parms\n     l32   r1,prm_add_value            |  Get pointer to value to add\n     errexit (z),code=&CC_Parameter_Missing  Error if pointer missing\n     l     r1,0(r1)                    |  Get the value\n     a     r1,pwa_display              |  Add current display contents\n     st    r1,pwa_display              |  Update the display\n     l32   r2,prm_add_display          |  Get addr of caller's display\n     errexit (z),code=&CC_Parameter_Missing  Error if pointer missing\n     st    r1,0(r2)                    |  Return display to caller.\n     errexit (c,r1,gt,=f'99999999'),   |  Return error for             *\n                code=&CC_Overflow      |   \"overflow\" condition.\n *  *-----------------------------------------------------------------*\n.su on\n:e#x.\n:efig.\n.*\n:h3.The Main Error Exit\n.*\nAny service processor should provide as much information as possible\nwhen it detects an error.  Environment Support provides a means to\nallow service processors to chain blocks of information (known as\n:hp1.debug areas:ehp1.), as shown in :figref refid=macerrx..\n.*\n:fig id=macerrx width=column concat=no.\n:figcap.SRVCC's ERREXIT Routine\n:#x.\n.su off\n  title \"SRVCC - General Error Exit\"   |\n  block type=errexit                   |\n * *------------------------------------------------------------------*\n * * Save module/offset, registers, return-code.\n * *------------------------------------------------------------------*\n   stm   r0,r15,gdiregs                | Save registers at time of error\n   la    r0,4(,r12)                    | Point to module identification.\n   st    r0,gdimodid                   | Save in general debug area.\n   mvc   gdirc,0(r14)                  | Copy return code.\n   slr   r14,r12                       | Calculate offset at time of err\n   sth   r14,gdioffst                  | Save in debug area.\n   l     r2,pwaaesv                    | Point r2 to ESV.\n   using esv,r2                        | Establish base for ESV.\n   es_save_debug_info  id=ES,gdi=debug_area_address\n * *------------------------------------------------------------------*\n * * Look at the error code.  If add'l information would be useful,\n * * stuff into the debug area.\n * *------------------------------------------------------------------*\n   lh    r15,gdirc                     | Get return code.\n   caseblk reg=r15,mult=1              | Case on return-code.\n     case &CC_invalid_function         |\n       es_save_debug_info id=ES,       |                               *\n                text=(psd_invalid_function,l'psd_invalid_function)\n     case &CC_invalid_number_of_parms  |\n       es_save_debug_info id=ES,       |                               *\n                text=(psd_invalid_#_parms,l'psd_invalid_#_parms)\n     case &CC_invalid_CC_ID            |\n       es_save_debug_info id=ES,       |                               *\n                text=(psd_invalid_CC_ID,l'psd_invalid_CC_ID)\n   endcase                             | EndCase.\n   drop r2                             |\n * *------------------------------------------------------------------*\n * * Set the return-code and exit.\n * *------------------------------------------------------------------*\n   lh    r15,gdirc                     | Set return code.\n  endblk rc=(r15)                      |\n  title \"SRVCC -- Constants\"           |\n          psd   ,                      |\n psd_eyecatcher  dc    cl8'CHEAP_SP'   | So everyone will know ...\n psd_invalid_function   dc  c\"Unsupported function.\"\n psd_invalid_#_parms    dc  c\"Invalid number of parameters.\"\n psd_invalid_cc_id      dc  c\"Invalid token provided.\"\n psd_overflow           dc  c\"Output value is too large for requested *\n                format.\"               |\n psd_undetermined_error   dc  c\"Undetermined error.\"\n          ltorg ,                      |\n          endpsd ,                     |\n.su on\n:e#x.\n:efig.\n.*\nService processors typically contain only one error exit: hence, the\nERREXIT block may be unnamed, which simplifies coding somewhat.  The\nerror exit expects the :#x.ERRADDR:e#x. option to be set on the\nprogram block: this generates a :#x.BAS  R14,:hp1.errexit:ehp1.:e#x.,\nfollowed by the :#x.ERREXIT:e#x. macro's :#x.CODE:e#x. value,\nto call the error exit.  Thus, the error exit can report where it was\ncalled within the service processor.\n.*\n:p.The Environment Support service processor offers a variety of\ndiagnostic aids which service processors can use to save error\ninformation.  The error exit shown in :figref refid=macerrx. makes use\nof several of these tools, and can be used as a model.  This sample\nerror exit performs the following:\n.*\n:ul.\n:li.Saves all registers in the General Debug Info (GDI) area.  This area\ncan be generated by coding :#x.ES_GDI  DSECT=NO:e#x. in the PWA. Refer t\nthe :#x.ES_GDI:e#x. macro in copy member :#x.SRVESMAC:e#x. for the forma\nof the GDI.\n.*\n:li.Saves the address of the module name (usually +4 from the start of\nthe main CSECT) in the GDI.\n.*\n:li.Saves the :#x.ERREXIT:e#x. macro's\n:#x.CODE:e#x. value in the GDI.  (This is a halfword\npointed to by R14.)\n.*\n:li.Passes the GDI to the :#x.ES_SAVE_DEBUG_INFO:e#x. function to be\n\"stacked\" with any existing debug information.\n.*\n:li.Depending on the type of error, additional information (in the form\nmessages or hex info) may be saved by the error exit using\n:#x.ES_SAVE_DEBUG_INFO:e#x..\n.*\n:li.Exits with the return code passed\nvia the :#x.ERREXIT:e#x. macro's\n:#x.CODE:e#x. value.\n.*\n:eul.\n:p.\nNormally, a service processor :hp2.should not:ehp2. call any service\nprocessor functions other than :#x.ES_SAVE_DEBUG_INFO:e#x. from within\nits error exit.  This is because vital information about the error being\nhandled may exist in the debugging information area and calling a\nservice processor function causes that information to automatically be\ncleared.  If a service processor's error exit needs to use service\nprocessor functions other than :#x.ES_SAVE_DEBUG_INFO:e#x., the\n:xmp.\nES_CLEAR_DEBUG_INFO ID=es,ACTION=INHIBIT\n:exmp.\nfunction should be used to inhibit clearing of the debugging information\narea before calling other service processor functions (any service\nprocessor functions, not just Environment Support functions).\n:p.\nAfter all function calls have been made from within the error exit, the\nfollowing function call should be made\n:xmp.\nES_CLEAR_DEBUG_INFO ID=es,ACTION=ENABLE\n:exmp.\nto re-ebable clearing of the debugging information area.  When control\nis returned to the calling application, it may decide it can tolerate\nthe error and proceed.  This function does not actually clear the\ndebugging information area, but allows it to be cleared automatically\nthe next time any service processor function is invoked.  If this is not\ndone, and if the calling application proceeds with execution, the\ndebugging area cannot be cleared and extraneous information may\naccumulate there.\n.*\n.**********************************************************************\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SRVDOCDT": {"ttr": 10762, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x02\\x00\\x00V\\x01\\x11)\\x9f\\x01\\x11)\\x9f\\t'\\x05\\xca\\x05\\xca\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@\"", "ispf": {"version": "02.00", "flags": 0, "createdate": "2011-10-26T00:00:00", "modifydate": "2011-10-26T09:27:56", "lines": 1482, "newlines": 1482, "modlines": 0, "user": "CLEMSON"}, "text": ".*\n.* The GML text below is a skeleton reference chapter for one service\n.* processor.  The suggested approach for writing a new chapter is to\n.*    1) create a new member called SRVDOCxx, where xx is the two\n.*       letter service processor identification code.\n.*    2) copy this member into it.\n.*    3) Change all occurrances of the skeleton names below to the\n.*       appropriate values.\n.*    4) format a copy of the manual with the new chapter included.\n.*    5) use the formatted copy of the new chapter to decided what\n.*       changes/additions/deletions need to be made.\n.*\n.*   <srvproc_name>  - The name used when referring to the service\n.*                     processor in general. e.g. \"String Handler\",\n.*                     \"Environment Support\", \"Memory Manager\", etc.\n.*   <srvload_sym>   - The symbolic name used for the load module, such\n.*                     as STRING_HANDLER, MVS_ENVIRONMENT_SUPPORT, etc.\n.*   <srvload_name>  - The actual name of the load module identified by\n.*                     <srvload_sym>, such as SRVSTR or SRVMVSES.\n.*   <>              - The two-letter code assigned to the service\n.*                     processor, such as ES, ST, MM, SY, or FI.\n.*   <func_name>     - The name used for specific function's reference\n.*                     section.  This name would be something like\n.*                     ES_LOAD_MODULE, ST_FORMAT, etc.\n.*   idid            - The header id used on the section for the xx_ID\n.*                     macro.\n.*\n.*\n.* Lines that begin with .*===> describe what should appear in the\n.*   text at that point or provide information on how something should\n.*   be formatted.\n.*\n.**********************************************************************\n.*                                                                    *\n.*                    Chapter. Date/Time Services                     *\n.*                                                                    *\n.**********************************************************************\n:h1.Date/Time Services\n:p.\nThe Date/Time service processor is intended to reduce or eliminate the\ntasks normally associated with handling date and time values in a\nprogram.  Date/Time Services may be used to:\n:ul.\n:li.Return the current date and/or time, in a variety of formats\n:li.Convert a date and/or time value from one format to another\n:li.Recognize the format of a character date or time value\n:li.Return the difference, or :hp1.duration:ehp1., between two date/time\nvalues\n:li.Add or subtract an interval value to a date and/or time\n:eul.\n.*\n:p.There are two major operations during each call to the Date/Time\nservice processor: these are :hp1.input conversion:ehp1. and\n:hp1.output conversion:ehp1..  Input conversion validates that the\ndate and/or time value provided conforms to the format specified, then\nconverts the date and/or time values to an internal representation.\nOutput conversion converts the internal representation to the date\nand/or time format requested by the caller.\n.*\n:p.Input validation is necessarily limited for performance reasons:\nincoming date and time values are validity-checked to ensure that\nnumbers, words and other characters are in the right positions and\nspelled correctly, but 'sanity checking' is only minimal.  (For example,\nan input Gregorian date of 02/30/1989 is considered valid:  however, if\nconverted to another format, the output date will be equivalent to March\n2, 1989.)  Character input data (names of days and months, etc) may be\nmixed case:  character output data is always capitalized lowercase.  (If\na program requires data returned from Date/Time Services to be\nuppercase, the program can fold the data to uppercase itself.)\n.*\n:p.A :hp1.general input:ehp1. format is provided.  This format actually\nsupports a variety of actual date or time formats by attempting to\nrecognize the format, then proceeding as though the date or time's true\nformat was specified by the caller. The true format is not returned to\nthe caller: however, the caller may use the :#x.DT_Convert:e#x. function\nto convert the date or time to any other supported format as required.\nThis function may be extremely\nuseful for applications where a user is asked to provide a date or time\nvalue: the application doesn't need to care what format the dates and\ntimes are, but can get Date/Time Services to recognize, then convert the\ndates and times to any format required.\n.*\n:p.Date/Time Services internally uses four tableless date conversion\nalgorithms.  These were adapted from algorithms 199 and 398 from\n:hp1.Collected Algorithms From Communications Of The ACM:ehp1..\nThe algorithms should be correct for any date between March 1, 0000 and\nDecember 31, 9999.\nNote, however, that Date/Time Services do not account for Pope Gregory\nXIII's calendar adjustment in 1582 A.D: hence, date values prior to\nOctober 15, 1582, although numerically accurate, will be 11 (or more)\ndays greater than the actual date.\n.*\n.*--------------------------------------------------------------------*\n:h3.Obtaining Date/Time Services' Symbols &amp. Macros\n.*--------------------------------------------------------------------*\n:p.\nDate/Time Services' symbols and interface macros can be found in the\nassembler copy member :#x.SRVDTMAC:e#x.. This member contains symbols\nnaming Date/Time Services' load module, function codes, return codes,\nand parameter values.  It also contains macros for using all of the\nDate/Time Services' functions. The following statement or its equivalent\nshould appear at the beginning of any program that uses\nDate/Time Services:\n:xmp.\n   COPY SRVDTMAC      Obtain Date/Time Services' symbols & macros.\n:exmp.\n.*===> if there is more than one load module that implements the\n.*===> service processor's protocol, that should be mentioned here.\n.*--------------------------------------------------------------------*\n:h3.Establishing Date/Time Services Defaults\n.*--------------------------------------------------------------------*\nSome parameters are general to Date/Time Services and not specific to\nany function.  These parameters include its load module name\n(:#xi.DT_epname:e#xi.), entry point address\n(:#xi.DT_epa:e#xi.), and token value\n(:#xi.DT_token:e#xi.). The :#x.DT_ID:e#x. macro (see\n:hdref refid=dtid.) can be used to establish defaults for these\nparameters and associate them with a unique service processor\nidentifier.  The identifier may then be supplied on any Date/Time\nServices\nmacro instruction to refer to the default parameter values.\n.*--------------------------------------------------------------------*\n:h3.Identifying Date/Time Services\n.*--------------------------------------------------------------------*\n:p.\nThe Date/Time service processor resides in the load module named by\nthe following symbol definition in copy member :#x.SRVDTMAC:e#x.:\n:xmp.\n&amp.DATETIME_SERVICES SETC '''SRVDT   '''\n:exmp.\nThis symbolic name should be used as the service processor entry point\nname for Date/Time Services\nas shown in the following :#x.DT_ID:e#x.\nmacro instruction:\n:xmp.\nDT_ID ID=DT,SPEPNAME=&amp.DATETIME_SERVICES  Set Date/Time Defaults.\n:exmp.\n.*--------------------------------------------------------------------*\n:h3.Loading Date/Time Services\n.*--------------------------------------------------------------------*\n:p.\nThe recommended method for loading Date/Time Services is through\nEnvironment Support's :#x.ES_LOAD_MODULE:e#x. function, as shown in\nthe following example:\n:xmp.\nES_LOAD_MODULE ID=ES,SPID=DT            Load Date/Time Services\n:exmp.\n.*--------------------------------------------------------------------*\n:h3.Specifying Date, Time And Interval Formats\n.*--------------------------------------------------------------------*\n:p.Although most of the Date/Time Services macros support both a date\nand a time value as input and/or output, both need not be specified:\na date or time specification may be used alone as input or output if\ndesired.  For example, to convert a date from one format to another,\nthe :#x.DT_Convert:e#x. function could be called using the\n:#x.Datein:e#x. and :#x.Dateout:e#x. parameters alone.\nNote that if a date or time value is not specified, it is treated as\nhaving a value of zero: for dates, this is equivalent to Jan. 1, 0000,\nwhile for times, this translates to 00:00:00.00, or exactly midnight.\n.*\n:p.Date/Time Services support a number of date and time formats.\nEach format is actually an integer value, with its own symbol associated\nwith it (for example, format :hp1.&amp.DT_Julian:ehp1.\nis equated to integer 2.)\nThese are listed in the following tables.\n.*\n:tdef id=dtdated cols='2* * * 3* * 2*' frame=box rules=both\n     hdframe=rules compact mindepth=p5 split=yes concat=yes width=page.\n:table id=dtdates refid=dtdated.\n:tcap.Date/Time Services Supported Date Formats\n:thd.\n:c.Symbol Name\n:c.Format Value\n:c.Format Type\n:c.Description\n:c.Length\n:c.Example\n:ethd.\n:tft refid=dtdated temp.\n:c.\n:etft.\n:row.:c.:#xb.&amp.DT_ES_Format:e#xb.:fnref refid=fndate1.\n     :c.1\n     :c.Both\n     :c.Environment Support format date and time\n     :c.8\n     :c.X'1989359F', X'0047BF58'\n:row.:c.:#xb.&amp.DT_Julian:e#xb.\n     :c.2\n     :c.Both\n     :c.Standard Julian date\n     :c.7\n     :c.C'1989359'\n:row.:c.:#xb.&amp.DT_Juliand:e#xb.\n     :c.3\n     :c.Both\n     :c.7-digit Julian date with decimal\n     :c.8\n     :c.C'1989.359'\n:row.:c.:#xb.&amp.DT_Pjulian:e#xb.\n     :c.4\n     :c.Both\n     :c.Packed-decimal Julian date\n     :c.4\n     :c.P'1989359'\n:row.:c.:#xb.&amp.DT_Ijulian:e#xb.\n     :c.5\n     :c.Both\n     :c.Integer (binary) Julian date\n     :c.4\n     :c.F'1989359'\n:row.:c.:#xb.&amp.DT_Sjulian:e#xb.\n     :c.6\n     :c.Both\n     :c.Short Julian date\n     :c.5\n     :c.C'89359'\n:row.:c.:#xb.&amp.DT_Sjuliand:e#xb.\n     :c.7\n     :c.Both\n     :c.Short Julian date with decimal\n     :c.6\n     :c.C'89.359'\n:row.:c.:#xb.&amp.DT_Number_Of_Days:e#x.\n     :c.8\n     :c.Both\n     :c.Number of days since Jan 1, 00\n     :c.4\n     :c.F'726767'\n:row.:c.:#xb.&amp.DT_Sgregorian:e#xb.:fnref refid=fndate2.\n     :c.11\n     :c.Both\n     :c.Short Gregorian date\n     :c.8\n     :c.C'12/25/89'\n:row.:c.:#xb.&amp.DT_Gregorian:e#xb.:fnref refid=fndate2.\n     :c.12\n     :c.Both\n     :c.Standard Gregorian date\n     :c.10\n     :c.C'12/25/1989'\n:row.:c.:#xb.&amp.DT_Sortdate:e#x.\n     :c.13\n     :c.Both\n     :c.Date format suitable for sorting\n     :c.10\n     :c.C'1989-12-25'\n:row.:c.:#xb.&amp.DT_Ssortdate:e#x.\n     :c.14\n     :c.Both\n     :c.Short version of :#x.DT_Sortdate:e#x.\n     :c.8\n     :c.C'89-12-25'\n:row.:c.:#xb.&amp.DT_Year:e#x.\n     :c.15\n     :c.Output\n     :c.Character year value\n     :c.4\n     :c.C'1989'\n:row.:c.:#xb.&amp.DT_Year2:e#x.\n     :c.16\n     :c.Output\n     :c.2-digit character year\n     :c.2\n     :c.C'89'\n:row.:c.:#xb.&amp.DT_Pyear:e#x.\n     :c.17\n     :c.Output\n     :c.Packed-decimal year value\n     :c.4\n     :c.PL4'1989'\n:row.:c.:#xb.&amp.DT_Iyear:e#x.\n     :c.18\n     :c.Output\n     :c.Halfword integer year value\n     :c.2\n     :c.H'1989'\n:row.:c.:#xb.&amp.DT_Days:e#x.\n     :c.19\n     :c.Output\n     :c.2-digit day number within month\n     :c.2\n     :c.C'25'\n:row.:c.:#xb.&amp.DT_Pdays:e#x.\n     :c.20\n     :c.Output\n     :c.Packed day number within month\n     :c.2\n     :c.PL2'25'\n:row.:c.:#xb.&amp.DT_Idays:e#x.\n     :c.21\n     :c.Output\n     :c.Integer day number within month\n     :c.2\n     :c.H'25'\n:row.:c.:#xb.&amp.DT_Month:e#x.\n     :c.22\n     :c.Output\n     :c.2-digit month number\n     :c.2\n     :c.C'12'\n:row.:c.:#xb.&amp.DT_Pmonth:e#x.\n     :c.23\n     :c.Output\n     :c.Packed month number\n     :c.2\n     :c.PL2'12'\n:row.:c.:#xb.&amp.DT_Imonth:e#x.\n     :c.24\n     :c.Output\n     :c.Integer month number\n     :c.2\n     :c.H'12'\n:row.:c.:#xb.&amp.DT_Snormal:e#xb.\n     :c.31\n     :c.Both\n     :c.Short Normal format date\n     :c.9\n     :c.C'25 Dec 89'\n:row.:c.:#xb.&amp.DT_Normal:e#xb.\n     :c.32\n     :c.Both\n     :c.Normal format date\n     :c.11\n     :c.C'25 Dec 1989'\n:row.:c.:#xb.&amp.DT_SASdate7:e#x.\n     :c.33\n     :c.Both\n     :c.7-character SAS 'DATE7.' format\n     :c.7\n     :c.C'25DEC89'\n:row.:c.:#xb.&amp.DT_SASdate9:e#x.\n     :c.34\n     :c.Both\n     :c.9-character SAS 'DATE9.' format\n     :c.9\n     :c.C'25DEC1989'\n:row.:c.:#xb.&amp.DT_Text:e#xb.\n     :c.41\n     :c.Both\n     :c.Text format date\n     :c.11-18\n     :c.C'December 25, 1989'\n:row.:c.:#xb.&amp.DT_Textd:e#xb.\n     :c.42\n     :c.Both\n     :c.Text format with weekday\n     :c.19-28\n     :c.C'Monday, December 25, 1989'\n:row.:c.:#xb.&amp.DT_Weekday:e#x.\n     :c.43\n     :c.Output\n     :c.Character weekday name\n     :c.6-9\n     :c.C'Monday'\n:row.:c.:#xb.&amp.DT_Weekday3:e#x.\n     :c.44\n     :c.Output\n     :c.3-character weekday name\n     :c.3\n     :c.C'Mon'\n:row.:c.:#xb.&amp.DT_Monthname:e#x.\n     :c.45\n     :c.Output\n     :c.Character month name\n     :c.3-9\n     :c.C'December'\n:row.:c.:#xb.&amp.DT_Monthname3:e#x.\n     :c.46\n     :c.Output\n     :c.3-character month name\n     :c.3\n     :c.C'Dec'\n:etable.\n:fn id=fndate1.\nThis format, although specified as a date format, will accept or return\nboth a date and time value.  The associated input or output\ntime parameters will be ignored.\n:efn.\n:fn id=fndate2.\nIf :#x.OPTIONS=EUROPEAN:e#x. was specified on the :#x.DT_START:e#x.\nmacro, the month and day values will be reversed.\n:efn.\n.*\n:tdef id=dttimed cols='2* * * 3* * 2*' frame=box rules=both\n     hdframe=rules compact mindepth=p5 split=yes concat=yes width=page.\n:table id=dttimes refid=dttimed.\n:tcap.Date/Time Services Supported Time Formats\n:thd.\n:c.Symbol Name\n:c.Format Value\n:c.Format Type\n:c.Description\n:c.Length\n:c.Example\n:ethd.\n:tft refid=dttimed temp.\n:c.\n:etft.\n:row.:c.:#xb.&amp.DT_Hundredths:e#x.\n     :c.2\n     :c.Both\n     :c.Number of .01-second units since midnight\n     :c.4\n     :c.X'0047BF58'\n:row.:c.:#xb.&amp.DT_HHMM:e#x.\n     :c.3\n     :c.Both\n     :c.Time in hours and minutes\n     :c.5\n     :c.C'13:03'\n:row.:c.:#xb.&amp.DT_HHMMSS:e#x.\n     :c.4\n     :c.Both\n     :c.Time in hours, minutes, seconds\n     :c.8\n     :c.C'13:03:40'\n:row.:c.:#xb.&amp.DT_HHMMSSTH:e#x.\n     :c.5\n     :c.Both\n     :c.Time in hours, minutes, seconds, hundredths\n     :c.11\n     :c.C'13:03:40.40'\n:row.:c.:#xb.&amp.DT_Civilian:e#x.\n     :c.6\n     :c.Both\n     :c.Time in hours, minutes, seconds, AM/PM\n     :c.11\n     :c.C' 1:03:40 PM'\n:row.:c.:#xb.&amp.DT_TODCLOCK:e#x.:fnref refid=fntime1.\n     :c.7\n     :c.Both\n     :c.System/370 time-of-day clock format:fnref refid=fntime3.\n     :c.8\n     :c.XL8':hp1.TOD value:ehp1.'\n:row.:c.:#xb.&amp.DT_Hours:e#x.:fnref refid=fntime2.\n     :c.8\n     :c.Output\n     :c.2-character hour value\n     :c.2\n     :c.C'13'\n:row.:c.:#xb.&amp.DT_Phours:e#x.:fnref refid=fntime2.\n     :c.9\n     :c.Output\n     :c.2-byte packed-decimal hours\n     :c.2\n     :c.PL2'13'\n:row.:c.:#xb.&amp.DT_Ihours:e#x.:fnref refid=fntime2.\n     :c.10\n     :c.Output\n     :c.Halfword hours value\n     :c.2\n     :c.H'13'\n:row.:c.:#xb.&amp.DT_Minutes:e#x.:fnref refid=fntime2.\n     :c.11\n     :c.Output\n     :c.Character minutes value\n     :c.2\n     :c.C'03'\n:row.:c.:#xb.&amp.DT_PMinutes:e#x.:fnref refid=fntime2.\n     :c.12\n     :c.Output\n     :c.Packed-decimal minutes value\n     :c.2\n     :c.PL2'3'\n:row.:c.:#xb.&amp.DT_Iminutes:e#x.:fnref refid=fntime2.\n     :c.13\n     :c.Output\n     :c.Halfword integer minutes value\n     :c.2\n     :c.H'3'\n:row.:c.:#xb.&amp.DT_Seconds:e#x.:fnref refid=fntime2.\n     :c.14\n     :c.Output\n     :c.Character seconds value\n     :c.2\n     :c.C'51'\n:row.:c.:#xb.&amp.DT_Pseconds:e#x.:fnref refid=fntime2.\n     :c.15\n     :c.Output\n     :c.Packed-decimal seconds value\n     :c.2\n     :c.PL2'51'\n:row.:c.:#xb.&amp.DT_Iseconds:e#x.:fnref refid=fntime2.\n     :c.16\n     :c.Output\n     :c.Halfword integer seconds value\n     :c.2\n     :c.H'51'\n:etable.\n:fn id=fntime1.\nThis format, although specified as a time format, will accept or return\nboth a date and time value.  The associated input or output\ndate parameters will be ignored.\n:efn.\n:fn id=fntime2.\nThese formats may also be used as interval formats.  Refer to\n:tref refid=dtintvl. for more information.\n:efn.\n:fn id=fntime3.\nThe System/370 time-of-day clock can only represent a limited range of\ndates and times, from Jan. 1, 1900 at 00:00:00.00 to Sept. 17, 2042\nat 23:53:47:37.  Attempts to convert values outside this range to TOD\nformat will result in a :#x.&amp.DT_Out_Of_Range:e#x. return code.\n:efn.\n.*\n:tdef id=dtintvd cols='2* * * 3* * 2*' frame=box rules=both\n     hdframe=rules compact mindepth=p5 split=yes concat=yes width=page.\n:table id=dtintvl refid=dtintvd.\n:tcap.Date/Time Services Supported Interval Formats\n:thd.\n:c.Symbol Name\n:c.Format Value\n:c.Format Type\n:c.Description\n:c.Length\n:c.Example\n:ethd.\n:tft refid=dtintvd temp.\n:c.\n:etft.\n:row.:c.:#xb.&amp.DT_Delta:e#x.\n     :c.1\n     :c.Both\n     :c.Interval in days, hours, minutes, seconds, hundredths\n     :c.14\n     :c.C'79-15:20:25.43'\n:row.:c.:#xb.&amp.DT_Days:e#x.\n     :c.19\n     :c.Both\n     :c.2-digit number of days\n     :c.5\n     :c.C'00025'\n:row.:c.:#xb.&amp.DT_Pdays:e#x.\n     :c.20\n     :c.Both\n     :c.Packed number of days\n     :c.4\n     :c.PL4'25'\n:row.:c.:#xb.&amp.DT_Idays:e#x.\n     :c.21\n     :c.Both\n     :c.Integer number of days\n     :c.2\n     :c.H'25'\n:row.:c.:#xb.&amp.DT_Hours:e#x.:fnref refid=fnintvl.\n     :c.8\n     :c.Both\n     :c.2-character hour value\n     :c.5\n     :c.C'00013'\n:row.:c.:#xb.&amp.DT_Phours:e#x.:fnref refid=fnintvl.\n     :c.9\n     :c.Both\n     :c.4-byte packed-decimal hours\n     :c.4\n     :c.PL4'13'\n:row.:c.:#xb.&amp.DT_Ihours:e#x.:fnref refid=fnintvl.\n     :c.10\n     :c.Both\n     :c.Halfword hours value\n     :c.2\n     :c.H'13'\n:row.:c.:#xb.&amp.DT_Minutes:e#x.:fnref refid=fnintvl.\n     :c.11\n     :c.Both\n     :c.Character minutes value\n     :c.5\n     :c.C'00003'\n:row.:c.:#xb.&amp.DT_PMinutes:e#x.:fnref refid=fnintvl.\n     :c.12\n     :c.Both\n     :c.Packed-decimal minutes value\n     :c.4\n     :c.PL4'3'\n:row.:c.:#xb.&amp.DT_Iminutes:e#x.:fnref refid=fnintvl.\n     :c.13\n     :c.Both\n     :c.Halfword integer minutes value\n     :c.2\n     :c.H'3'\n:row.:c.:#xb.&amp.DT_Seconds:e#x.:fnref refid=fnintvl.\n     :c.14\n     :c.Both\n     :c.Character seconds value\n     :c.5\n     :c.C'00051'\n:row.:c.:#xb.&amp.DT_Pseconds:e#x.:fnref refid=fnintvl.\n     :c.15\n     :c.Both\n     :c.Packed-decimal seconds value\n     :c.4\n     :c.PL4'51'\n:row.:c.:#xb.&amp.DT_Iseconds:e#x.:fnref refid=fnintvl.\n     :c.16\n     :c.Both\n     :c.Halfword integer seconds value\n     :c.2\n     :c.H'51'\n:row.:c.:#xb.&amp.DT_Hundredths:e#x.\n     :c.2\n     :c.Both\n     :c.Number of .01-second units\n     :c.5\n     :c.C'01578'\n:row.:c.:#xb.&amp.DT_Phundredths:e#x.\n     :c.17\n     :c.Both\n     :c.Number of .01-second units\n     :c.4\n     :c.PL4'1578'\n:row.:c.:#xb.&amp.DT_Ihundredths:e#x.\n     :c.18\n     :c.Both\n     :c.Number of .01-second units\n     :c.2\n     :c.H'1578'\n:etable.\n:fn id=fnintvl.\nThese formats may also be used as date or time formats, although their\ncharacteristics may be slightly different.\nRefer to\n:tref refid=dtdates. and :tref refid=dttimes. for more information.\n:efn.\n.*\n.*--------------------------------------------------------------------*\n:h3.The General Input Format\n.*--------------------------------------------------------------------*\nDate/Time Services provide a generalized input format, known as\n:#xb.&amp.DT_General_Input:e#xb., which actually provides a format\nrecognition function for a variety of character date and time\nformats.  If an input value is declared to be of this format, Date/Time\nServices attempts to determine the format:  once the format is\nrecognized, Date/Time Services treats the value as though that input\nformat was specified by the caller.\nThe invalid-input return codes indicate that the format was not\nrecognized.\n.*\n:p.The following date, time and interval formats are supported by the\n:#xb.&amp.DT_General_Input:e#xb. format:\n:ul compact.\n:li.:#xb.&amp.DT_Civilian:e#xb.\n:li.:#xb.&amp.DT_Gregorian:e#xb.\n:li.:#xb.&amp.DT_HHMM:e#xb.\n:li.:#xb.&amp.DT_HHMMSS:e#xb.\n:li.:#xb.&amp.DT_HHMMSSTH:e#xb.\n:li.:#xb.&amp.DT_Julian:e#xb.\n:li.:#xb.&amp.DT_Juliand:e#xb.\n:li.:#xb.&amp.DT_Normal:e#xb.\n:li.:#xb.&amp.DT_Sgregorian:e#xb.\n:li.:#xb.&amp.DT_Sjulian:e#xb.\n:li.:#xb.&amp.DT_Sjuliand:e#xb.\n:li.:#xb.&amp.DT_Snormal:e#xb.\n:li.:#xb.&amp.DT_Sortdate:e#xb.\n:li.:#xb.&amp.DT_Ssortdate:e#xb.\n:li.:#xb.&amp.DT_SASdate7:e#xb.\n:li.:#xb.&amp.DT_SASdate9:e#xb.\n:li.:#xb.&amp.DT_Text:e#xb.\n:eul.\n.*--------------------------------------------------------------------*\n:h3.Common Parameters\n.*--------------------------------------------------------------------*\n:p.There are several parameters common to any\nDate/Time Services\nfunction call.  These are:\n:plist.\n:pLt.id_name\n:pLd.specifies the name of a service processor identifier created by the\n:#x.DT_ID:e#x. macro which will be used by the :#x.DT_START:e#x.\nmacro to automatically obtain values for :#xi.DT_epa:e#xi.\nand\n:#xi.DT_token:e#xi.. This parameter is required unless both\n:#xi.DT_epa:e#xi. and :#xi.DT_token:e#xi. are\nspecified.\n:pLt.DT_epa\n:pLd.specifies the label of a fullword in storage that contains the\nentry point address of an already-started Date/Time Services service\nprocessor.  The value specified by :#xi.DT_epa:e#xi.\noverrides any value obtained from\n:#x.ID=:e#x.:#xi.id_name:e#xi..\n:pLt.DT_token\n:pLd.specifies the label of a fullword in storage that contains the\nvalue returned by :#x.DT_START:e#x. for the\n:#xi.DT_token:e#xi. parameter.  The value specified by\n:#xi.DT_token:e#xi. overrides any value obtained from\n:#x.ID=:e#x.:#xi.id_name:e#xi..\n:eplist.\n.*--------------------------------------------------------------------*\n:h3.Return Codes\n.*--------------------------------------------------------------------*\n:p.\nDate/Time Services may issue any of the following return codes in\nvarious situations.  Some of the return codes may be received from any\ncall to Date/Time Services, while others are specific to individual\nfunctions.\n.*---------------------------------------------------------------------*\n.* ReturnCode section: table of return codes and their meanings.\n.*\n.*===> This section should be elimitated for things that do not have\n.*===> return codes, such as the DT_ID macro or data-mapping macros.\n.*\n.* :rclist.\n.* :rcn.number           | One rcn/rct/rcd triple for each return code\n.* :rct.symbol           | that the function may generate.\n.* :rcd.description      |\n.* :erclist.\n.*\n.*---------------------------------------------------------------------*\n:rclist.\n:rcn.0\n:rct.DT_SUCCESS\n:rcd.The Date/Time Services\nfunction has completed successfully.\n:rcn.1\n:rct.DT_INVALID_FUNCTION\n:rcd.An unsupported function code was received\nby Date/Time Services.\n:rcn.2\n:rct.DT_INVALID_NUMBER_OF_PARMS\n:rcd.The Date/Time Services\nfunction received an invalid number of\nparameters.  This may be due to an improperly coded CALLX or PLIST\nmacro, or the inadvertent use of the NOVL option.\n:rcn.3\n:rct.DT_INVALID_DT_ID\n:rcd.Date/Time Services detected an invalid\nPWA address in :#x.DT_token:e#x..\n:rcn.4\n:rct.DT_ENVIRONMENT_SUPPORT_ERROR\n:rcd.An Environment Support function suffered an error.\n:rcn.5\n:rct.DT_STRING_HANDLER_ERROR\n:rcd.An error was reported by the String Handler service processor.\nMore information may be found by issuing the\n:#x.ES_DISPLAY_DEBUG_INFO:e#x. function.\n:rcn.6\n:rct.DT_INVALID_DATE_FORMAT\n:rcd.The integer fullword provided via the :ehp1.date_format:ehp1.\nparameter was not a supported Date/Time Services date format.\n:rcn.7\n:rct.DT_INVALID_TIME_FORMAT\n:rcd.The integer fullword provided via the :ehp1.time_format:ehp1.\nparameter was not a supported Date/Time Services time format.\n:rcn.8\n:rct.DT_INVALID_INTERVAL_FORMAT\n:rcd.The integer fullword provided via the :ehp1.interval_format:ehp1.\nparameter was not a supported Date/Time Services interval format.\n:rcn.9\n:rct.DT_INVALID_INPUT_DATE\n:rcd.The date value provided by the caller failed validity checking for\nthe specified date format.\n:rcn.10\n:rct.DT_INVALID_INPUT_TIME\n:rcd.The time value provided by the caller failed validity checking for\nthe specified time format.\n:rcn.11\n:rct.DT_INVALID_INPUT_INTERVAL\n:rcd.The interval value provided by the caller failed validity checking\nfor the specified interval format.\n:rcn.12\n:rct.DT_OVERFLOW\n:rcd.The interval value produced by the function is too large for the\nspecified output interval format.\n:rcn.13\n:rct.DT_OUT_OF_RANGE\n:rcd.The output date/time value is not within the acceptable range for\nthe specified format. This will only occur when using\n:#x.DT_TODclock:e#x. format, when the date and time values are outside\nthe range of Jan. 1, 1900 at 00:00:00.00 and\nSept. 17, 2042 at 23:53:47.37.\n:erclist.\n.*--------------------------------------------------------------------*\n:h2.Date/Time Services Functions\n.*--------------------------------------------------------------------*\n:p.\nThe remaining sections of this chapter describe all functions provided\nby Date/Time Services, arranged in alphabetical order.\nEach function's description begins on a new page, and the name of the\nfunction being described appears in the top outside corner of every\npage.\n.**********************************************************************\n.se temp = 'Add Interval To Date And Time'\n:func id=dtadd name='DT_ADD'.&temp.\n.**********************************************************************\n:p.\nThe :#x.DT_ADD:e#x. function will add an interval to a date and/or\ntime value.\n.*===>\n.*===> The :mac. and :callx. tags below are used to describe the\n.*===> syntax for invoking the function/macro.\n.*===>\n.*---------------------------------------------------------------------*\n.* Syntax box for the macro form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:mac.\nDT_ADD ID=:hp1.id_name:ehp1. &cont.\n&lbt.,SPEPA=:hp1.DT_epa:ehp1.&rbt. &cont.\n&lbt.,SPTOKEN=:hp1.DT_token:ehp1.&rbt.\n   &lbt.,DATEIN=(:hp1.date_address,date_format:ehp1.)&rbt.\n   &lbt.,TIMEIN=(:hp1.time_address,time_format:ehp1.)&rbt.\n   &lbt.,INTERVAL=(:hp1.interval_address,interval_format:ehp1.)&rbt.\n   &lbt.,DATEOUT=(:hp1.date_address,time_format:ehp1.)&rbt.\n   &lbt.,TIMEOUT=(:hp1.time_address,time_format:ehp1.)&rbt.\n:emac.\n.*---------------------------------------------------------------------*\n.* Syntax box for the CALLX form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:callx.\nCALLX :hp1.DT_epa:ehp1.,&cont.\n(:hp1.DT_token:ehp1.,&amp.DT_ADD,&cont.\n:hp1.datein_address:ehp1.\n              ,:hp1.datein_format:ehp1.,&cont.\n:hp1.timein_address:ehp1.,:hp1.timein_format:ehp1.\n              ,:hp1.interval_address,interval_format,:ehp1.&cont.\n:hp1.dateout_address:ehp1.\n              ,:hp1.dateout_format,timeout_address,:ehp1.&cont.\n:hp1.timeout_format:ehp1.)\n:ecallx.\n.*---------------------------------------------------------------------*\n.* Parameter-list table describing each parameter.\n.*\n.* :plist.\n.* :pLt.parameter      | One pLt/pLd pair for each parameter that may\n.* :pLd.description    | be specified.\n.* :eplist.\n.*\n.*---------------------------------------------------------------------*\n:plist.\n:pLt.datein_address\n:pLd.Specifies the address of the input date value.\nFor variable-length input formats, the field needs only to be as long as\nthe date value, and does not need to be padded with spaces.  This is\ntrue for all input values for\n:#x.DT_ADD:e#x..\n:pLt.datein_format\n:pLd.Specifies the format of the input date value.\nThis value may be an integer, numeric symbol, or the address of a\nfullword in storage.  This is true of all format specifications\nfor :#x.DT_ADD:e#x..\n:pLt.timein_address\n:pLd.Provides the address of the input time value.\n:pLt.timein_format\n:pLd.Specifies the format of the input time value.\n:pLt.interval_address\n:pLd.Specifies the address of the input interval value.\n:pLt.interval_format\n:pLd.Specifies the format of the input interval value.\n:pLt.dateout_address\n:pLd.Specifies the address of the output date value.\nThe area should be large enough to hold the\nlongest possible date value for the requested format. If the format is\nvariable-length, it should be cleared to spaces before the call to\n:#x.DT_ADD:e#x..\n:pLt.dateout_format\n:pLd.Specifies the format of the output date value.\n:pLt.timeout_address\n:pLd.Provides the address of the output time value.\n:pLt.timeout_format\n:pLd.Specifies the format of the output time value.\n:eplist.\n.*---------------------------------------------------------------------*\n:fh3.Examples\nTo add a constant of\n75 hours to the date and time values in :#x.pwa_date:e#x. and\n:#x.pwa_time:e#x.,\none would code:\n:xmp.\nDT_ADD  ID=DT,\n        DATEIN=(pwa_date,&DT_NORMAL),\n        TIMEIN=(pwa_time,&DT_HHMMSS),\n        INTERVAL=('75',&DT_HOURS),\n        DATEOUT=(pwa_date,&DT_NORMAL),\n        TIMEOUT=(pwa_time,&DT_HHMMSS)\n:exmp.\nThis would replace the contents of :#x.pwa_date:e#x. and\n:#x.pwa_time:e#x. with the updated date and time values.\n:efunc.\n.**********************************************************************\n.se temp = 'Date And Time Format Conversion'\n:func id=dtcnvt name='DT_CONVERT'.&temp.\n.**********************************************************************\n:p.\nThe :#x.DT_CONVERT:e#x. function will convert a date and/or time value\nfrom one supported format to another.\n.*===>\n.*===> The :mac. and :callx. tags below are used to describe the\n.*===> syntax for invoking the function/macro.\n.*===>\n.*---------------------------------------------------------------------*\n.* Syntax box for the macro form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:mac.\nDT_CONVERT ID=:hp1.id_name:ehp1. &cont.\n&lbt.,SPEPA=:hp1.DT_epa:ehp1.&rbt. &cont.\n&lbt.,SPTOKEN=:hp1.DT_token:ehp1.&rbt.\n   &lbt.,FROMDATE=(:hp1.date_address,date_format:ehp1.)&rbt.\n   &lbt.,FROMTIME=(:hp1.time_address,time_format:ehp1.)&rbt.\n   &lbt.,TODATE=(:hp1.date_address,date_format:ehp1.)&rbt.\n   &lbt.,TOTIME=(:hp1.time_address,time_format:ehp1.)&rbt.\n:emac.\n.*---------------------------------------------------------------------*\n.* Syntax box for the CALLX form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:callx.\nCALLX :hp1.DT_epa:ehp1.,&cont.\n(:hp1.DT_token:ehp1.,&amp.DT_CONVERT,&cont.\n:hp1.fromdate_address:ehp1.\n              ,:hp1.fromdate_format:ehp1.,&cont.\n:hp1.fromtime_address:ehp1.,:hp1.fromtime_format:ehp1.\n              ,:hp1.todate_address:ehp1.,:hp1.todate_format:ehp1.,&cont.\n:hp1.totime_address:ehp1.\n              ,:hp1.totime_format:ehp1.)\n:ecallx.\n.*---------------------------------------------------------------------*\n.* Parameter-list table describing each parameter.\n.*\n.* :plist.\n.* :pLt.parameter      | One pLt/pLd pair for each parameter that may\n.* :pLd.description    | be specified.\n.* :eplist.\n.*\n.*---------------------------------------------------------------------*\n:plist.\n:pLt.fromdate_address\n:pLd.Specifies the address of the input date value.\nFor variable-length input formats, the field needs only to be as long as\nthe date value, and does not need to be padded with spaces.  This is\ntrue for all input values for\n:#x.DT_CONVERT:e#x..\n:pLt.fromdate_format\n:pLd.Specifies the format of the input date value.\nThis value may be an integer, numeric symbol, or the address of a\nfullword in storage.  This is true of all format specifications\nfor :#x.DT_CONVERT:e#x..\n:pLt.fromtime_address\n:pLd.Provides the address of the input time value.\n:pLt.fromtime_format\n:pLd.Specifies the format of the input time value.\n:pLt.todate_address\n:pLd.Specifies the address of the output date value.\nThe area should be large enough to hold the\nlongest possible date value for the requested format. If the format is\nvariable-length, it should be cleared to spaces before the call to\n:#x.DT_CONVERT:e#x..\n:pLt.todate_format\n:pLd.Specifies the format of the output date value.\n:pLt.totime_address\n:pLd.Provides the address of the output time value.\n:pLt.totime_format\n:pLd.Specifies the format of the output time value.\n:eplist.\n.*---------------------------------------------------------------------*\n:fh3.Examples\nIf the current contents of fields :#x.pwa_date:e#x. and\n:#x.pwa_time:e#x. are\ndate and time are :#x.January 7, 1990:e#x. and\n:#x.16:11:30:e#x. respectively,\nthe following DT_CONVERT macro:\n:xmp.\nDT_CONVERT  ID=DT,\n            FROMDATE=(pwa_date,&DT_TEXT),\n            FROMTIME=(pwa_time,&DT_HHMMSS),\n            TODATE=(pwa_dateout,&DT_NORMAL),\n            TOTIME=(pwa_timeout,&DT_CIVILIAN)\n:exmp.\nwould return date and time values in :#x.pwa_dateout:e#x. and\n:#x.pwa_timeout:e#x. respectively.    These values would appear as:\n:xmp.\n   pwa_dateout    07 JAN 1990\n   pwa_timeout     4:11:30 PM\n:exmp.\n:efunc.\n.**********************************************************************\n.se temp = 'Duration Between Two Date/Time Values'\n:func id=dtdur name='DT_DURATION'.&temp.\n.**********************************************************************\n:p.\nThe :#x.DT_DURATION:e#x.\nfunction will return the duration, or difference, between\ntwo date and/or time values.\nThis duration, returned in :#x.interval:e#x. format, is always a\npositive number of days, hours, etc.\n.*===>\n.*===> The :mac. and :callx. tags below are used to describe the\n.*===> syntax for invoking the function/macro.\n.*===>\n.*---------------------------------------------------------------------*\n.* Syntax box for the macro form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:mac.\nDT_DURATION ID=:hp1.id_name:ehp1. &cont.\n&lbt.,SPEPA=:hp1.DT_epa:ehp1.&rbt. &cont.\n&lbt.,SPTOKEN=:hp1.DT_token:ehp1.&rbt.\n   &lbt.,DATE1=(:hp1.date_address,date_format:ehp1.)&rbt.\n   &lbt.,TIME1=(:hp1.date_address,time_format:ehp1.)&rbt.\n   &lbt.,DATE2=(:hp1.date_address,date_format:ehp1.)&rbt.\n   &lbt.,TIME2=(:hp1.date_address,time_format:ehp1.)&rbt.\n   &lbt.,DURATION=(:hp1.duration_address,duration_format:ehp1.)&rbt.\n:emac.\n.*---------------------------------------------------------------------*\n.* Syntax box for the CALLX form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:callx.\nCALLX :hp1.DT_epa:ehp1.,&cont.\n(:hp1.DT_token:ehp1.,&amp.DT_CONVERT,&cont.\n:hp1.date1_address:ehp1.\n              ,:hp1.date1_format:ehp1.,&cont.\n:hp1.time1_address:ehp1.,:hp1.time1_format:ehp1.\n              ,:hp1.date2_address:ehp1.,:hp1.date2_format:ehp1.,&cont.\n:hp1.time2_address:ehp1.\n              ,:hp1.time2_format:ehp1.,&cont.\n:hp1.duration_address:ehp1.,:hp1.duration_format:ehp1.)\n:ecallx.\n.*---------------------------------------------------------------------*\n.* Parameter-list table describing each parameter.\n.*\n.* :plist.\n.* :pLt.parameter      | One pLt/pLd pair for each parameter that may\n.* :pLd.description    | be specified.\n.* :eplist.\n.*\n.*---------------------------------------------------------------------*\n:plist.\n:pLt.date1_address\n:pLd.Specifies the address of the first input date value.\nFor variable-length input formats, the field needs only to be as long as\nthe date value, and does not need to be padded with spaces.  This is\ntrue for all input values for\n:#x.DT_DURATION:e#x..\n:pLt.date1_format\n:pLd.Specifies the format of the first input date value.\nThis value may be an integer, numeric symbol, or the address of a\nfullword in storage.  This is true of all format specifications\nfor :#x.DT_DURATION:e#x..\n:pLt.time1_address\n:pLd.Provides the address of the first input time value.\n:pLt.time1_format\n:pLd.Specifies the format of the first input time value.\n:pLt.date2_address\n:pLd.Specifies the address of the second input date value.\n:pLt.date2_format\n:pLd.Specifies the format of the second input date value.\n:pLt.time2_address\n:pLd.Provides the address of the second input time value.\n:pLt.time2_format\n:pLd.Specifies the format of the second input time value.\n:pLt.duration_address\n:pLd.Provides the address of the output interval value.\nThe area should be large enough to hold the\nlongest possible interval\nvalue for the requested format. If the format is\nvariable-length, it should be cleared to spaces before the call to\n:#x.DT_DURATION:e#x..\n:pLt.duration_format\n:pLd.Specifies the format of the output interval value.\n:eplist.\n.*---------------------------------------------------------------------*\n:fh3.Examples\nIf the fields\n:#x.pwa_date:e#x.,\n:#x.pwa_date2:e#x.,\n:#x.pwa_time:e#x., and\n:#x.pwa_time2:e#x. contain various date and time values, the following\ncall to :#x.DT_DURATION:e#x. would return the difference between them\nin :#x.DT_Delta:e#x. format.\n:xmp.\nDT_DURATION ID=DT,\n            DATE1=(pwa_date,&DT_TEXT),\n            TIME1=(pwa_time,&DT_HHMMSS),\n            DATE2=(pwa_date2,&DT_NORMAL),\n            TIME2=(pwa_time2,&DT_CIVILIAN)\n            DURATION=(pwa_interval,&DT_DELTA)\n:exmp.\n:efunc.\n.**********************************************************************\n.se temp = 'Return Current Date And Time'\n:func id=dtget  name='DT_GET_CURRENT'.&temp.\n.**********************************************************************\n:p.\nThe :#x.DT_GET_CURRENT:e#x. function retrieves the current date and/or\ntime.  The format requested may be any valid date format for date, and\nany valid time format for time.\n.*===>\n.*===> The :mac. and :callx. tags below are used to describe the\n.*===> syntax for invoking the function/macro.\n.*===>\n.*---------------------------------------------------------------------*\n.* Syntax box for the macro form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:mac.\nDT_GET_CURRENT ID=:hp1.id_name:ehp1. &cont.\n&lbt.,SPEPA=:hp1.DT_epa:ehp1.&rbt. &cont.\n&lbt.,SPTOKEN=:hp1.DT_token:ehp1.&rbt.\n   &lbt.,DATE=(:hp1.date_address,date_format:ehp1.)&rbt.\n   &lbt.,TIME=(:hp1.date_address,time_format:ehp1.)&rbt.\n:emac.\n.*---------------------------------------------------------------------*\n.* Syntax box for the CALLX form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:callx.\nCALLX :hp1.DT_epa:ehp1.,&cont.\n(:hp1.DT_token:ehp1.,&amp.DT_GET_CURRENT,&cont.\n:hp1.date_address:ehp1.\n              ,:hp1.date_format&lbt.,time_address,time_format&rbt.)\n:ecallx.\n.*---------------------------------------------------------------------*\n.* Parameter-list table describing each parameter.\n.*\n.* :plist.\n.* :pLt.parameter      | One pLt/pLd pair for each parameter that may\n.* :pLd.description    | be specified.\n.* :eplist.\n.*\n.*---------------------------------------------------------------------*\n:plist.\n:pLt.date_address\n:pLd.Provides the address of an area where Date/Time Services will\nreturn the current date.\nThe area should be large enough to hold the\nlongest possible date value for the requested format. If the format is\nvariable-length, it should be cleared to spaces before the call to\n:#x.DT_GET_CURRENT:e#x..\n:pLt.date_format\n:pLd.Specifies a format for the date value returned by\n:#x.DT_GET_CURRENT:e#x..\nThis value may be an integer, numeric symbol, or the address of a\nfullword in storage.  This is true of all format specifications\nfor :#x.DT_GET_CURRENT:e#x..\n:pLt.time_address\n:pLd.Provides the address of an area where Date/Time Services will\nreturn the current time.\n:pLt.time_format\n:pLd.Specifies a format for the time value returned by\n:#x.DT_GET_CURRENT:e#x..\n:eplist.\n.*---------------------------------------------------------------------*\n:fh3.Examples\nIf the current date and time are :#x.January 7, 1990:e#x.\nand :#x.16:11:30:e#x. respectively,\nthe following DT_GET_CURRENT macro:\n:xmp.\nDT_GET_CURRENT  ID=DT,\n                DATE=(pwa_date,&DT_NORMAL),\n                TIME=(pwa_time,&DT_CIVILIAN)\n:exmp.\nwould return date and time values in :#x.pwa_date:e#x. and\n:#x.pwa_time:e#x. respectively.    These values would appear as:\n:xmp.\n   pwa_date    07 JAN 1990\n   pwa_time     4:11:30 PM\n:exmp.\n:efunc.\n.**********************************************************************\n.se temp = 'Establish Default Date/Time Services Values'\n:func id=dtid name='DT_ID'.&temp.\n.**********************************************************************\n:p.The :#x.DT_ID:e#x. macro is used to establish default values for\nuse by other Date/Time Services macros, which may access those values\nthrough a unique identifier, :#xi.id_name:e#xi., specified by\nthe user.  When allowed to generate default values, this macro will\ncreate Program Work Area (PWA) storage for :#xi.DT_epa:e#xi.\nand\n:#xi.DT_token:e#xi.. These values, whether generated by the\nmacro or provided by the user, are accessable from all other\nDate/Time Services\nmacros via the :#x.ID=:e#x.:#xi.id_name:e#xi. parameter.\n:mac.\nDT_ID ID=:hp1.id_name:ehp1.\n   &lbt.,SPEPNAME=:hp1.DT_epname:ehp1.&rbt.\n   &lbt.,SPEPA=:hp1.DT_epa:ehp1.&rbt.\n   &lbt.,SPTOKEN=:hp1.DT_token:ehp1.&rbt.\n   &lbt.,ESID=:hp1.esid_name:ehp1.&rbt.\n   &lbt.,ESVA=:hp1.esva:ehp1.&rbt.\n:emac.\n.*****\n:plist.\n:pLt.esid_name\n:pLd.the name of a service processor identifier, created by the\n:#x.ES_ID:e#x.  macro, which will be used by the :#x.DT_ID:e#x. macro to\nautomatically obtain the value for :#x.esv:e#x. (see below).\n:pLt.esva\n:pLd.Specifies the label of a fullword in storage that contains (or\nwill contain) the address of the Environment Support Vector\n(:#x.ESV:e#x.) created by the :#x.ES_START:e#x. function.\n:eplist.\n:fh3.Examples\n:p.\nThe following :#x.DT_ID:e#x. macro will associate everything required by\nthe Date/Time Services\nmacros with the service processor identifier :#x.DT:e#x.,\nas well as establish the :#x.sizelength:e#x. value for the\nDate/Time Services\nsession.\n:xmp.\n    DT_ID  ID=DT,\n           SPEPNAME=&amp.DATETIME_SERVICES,\n           SPEPA=PWA_DT_ENTRY,\n           SPTOKEN=PWA_DT_TOKEN,\n           ESID=ES,\n           ESVA=PWA_ESVA\n.sp 2\nPWA_DT_ENTRY  DS    F         Entrypoint for Date/Time Services\nPWA_DT_TOKEN  DS    F         Unique token for Date/Time Services\nPWA_ESVA      DS    F         Environment Support Vector address\n:exmp.\nNote that this example forces the various operands to specific values\nand addresses.  If these are not specified and do not need to be\nexplicitly referenced, simply coding the :#x.DT_ID:e#x. macro with only\nthe :#x.ID:e#x. and :#x.SPEPNAME:e#x.\noperands will cause all of them to be generated automatically.\n:efunc.\n.**********************************************************************\n.se temp = 'Begin A Date/Time Services Session'\n:func id=dtstart name='DT_START'.&temp.\n.**********************************************************************\n:p.\nThe :#x.DT_START:e#x. function establishes\na new Date/Time Services\nsession and returns its session identifier in the\n:hp1.DT_token:ehp1. parameter.\n.*===>\n.*===> The :mac. and :callx. tags below are used to describe the\n.*===> syntax for invoking the function/macro.\n.*===>\n.*---------------------------------------------------------------------*\n.* Syntax box for the macro form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:mac.\nDT_START ID=:hp1.id_name:ehp1. &cont.\n&lbt.,SPEPA=:hp1.DT_epa:ehp1.&rbt. &cont.\n&lbt.,SPTOKEN=:hp1.DT_token:ehp1.&rbt.\n   &lbt.,ESVA=:hp1.esva:ehp1.&rbt.\n   &lbt.,OPTION=(:hp1.option_list:ehp1.)&rbt.\n:emac.\n.*---------------------------------------------------------------------*\n.* Syntax box for the CALLX form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:callx.\nCALLX :hp1.DT_epa:ehp1.,(:hp1.DT_token:ehp1.,&amp.DT_START,&cont.\n:hp1.esva:ehp1.,:hp1.option_byte:ehp1.)\n.*===> If there are alternate forms, where the parameter list is\n.*===> significantly different depending on the first few parameter\n.*===> values, do something like the following:\n:ecallx.\n.*---------------------------------------------------------------------*\n.* Parameter-list table describing each parameter.\n.*\n.* :plist.\n.* :pLt.parameter      | One pLt/pLd pair for each parameter that may\n.* :pLd.description    | be specified.\n.* :eplist.\n.*\n.*---------------------------------------------------------------------*\n:plist.\n:pLt.esva\n:pLd.Specifies the label of a fullword in storage that contains the\naddress of the Environment Support Vector (ESV) created by the\nES_START function.\n:pLt.option_list\n:pLd.A list of additional options for this\nDate/Time Services\nsession. If\nmultiple option values are specified, they must be enclosed in\nparentheses.\nThe only\noptions currently supported are :hp1.EUROPEAN:ehp1. and\n:hp1.AMERICAN:ehp1..\n:ul.\n:li.:hp2.EUROPEAN:ehp2. - Gregorian dates processed by Date/Time\nServices will be of the format :hp1.\"dd/mm/yyyy\":ehp1.\nIf using the CALLX form of\n:hp1.DT_START:ehp1., the EUROPEAN\noption corresponds to a bit setting of\nX'80' in the option byte.\n:li.:hp2.AMERICAN:ehp2. - Gregorian dates processed by Date/Time\nServices will be of the format :hp1.\"mm/dd/yyyy\":ehp1.\nIf using the CALLX form of\n:hp1.DT_START:ehp1., the AMERICAN\noption corresponds to the X'80' bit being set to zero\nin the option byte.\nAMERICAN is the default Gregorian date format.\n:eul.\n:pLd.\n:eplist.\n.*---------------------------------------------------------------------*\n.* Optional sections for describing how to use the function/macro.\n.*---------------------------------------------------------------------*\n.*---------------------------------------------------------------------*\n.* Examples showing how to use it and neat ways to take advantage of\n.* the function's capabilities.\n.*\n.*===> If one or two separate examples are being done, simply use\n.*===>\n.*===> :fh3.Example 1\n.*===>   ...example 1 stuff...\n.*===> :fh3.Example 2\n.*===>   ...example 2 stuff...\n.*===>\n.*===> If a whole system of related examples are being done, use\n.*===>\n.*===> :fh3.Examples\n.*===>   ....description general to all examples.\n.*===> :h5.Example 1\n.*===>   ...example 1 stuff...\n.*===> :h5.Example 2\n.*===>   ...example 2 stuff...\n.*===>\n.*---------------------------------------------------------------------*\n:fh3.Examples\n:p.\nThe following :#x.DT_START:e#x.  macro will initialize a Date/Time\nServices session.\n:xmp.\n    DT_START ID=DT\n:exmp.\n:efunc.\n.**********************************************************************\n.se temp = 'Subtract Interval From Date And Time'\n:func id=dtsub name='DT_SUBTRACT'.&temp.\n.**********************************************************************\n:p.\nThe :#x.DT_SUBTRACT:e#x. function will subtract\nan interval from a date and/or\ntime value.\n.*===>\n.*===> The :mac. and :callx. tags below are used to describe the\n.*===> syntax for invoking the function/macro.\n.*===>\n.*---------------------------------------------------------------------*\n.* Syntax box for the macro form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:mac.\nDT_SUBTRACT ID=:hp1.id_name:ehp1. &cont.\n&lbt.,SPEPA=:hp1.DT_epa:ehp1.&rbt. &cont.\n&lbt.,SPTOKEN=:hp1.DT_token:ehp1.&rbt.\n   &lbt.,DATEIN=(:hp1.date_address,date_format:ehp1.)&rbt.\n   &lbt.,TIMEIN=(:hp1.time_address,time_format:ehp1.)&rbt.\n   &lbt.,INTERVAL=(:hp1.interval_address,interval_format:ehp1.)&rbt.\n   &lbt.,DATEOUT=(:hp1.date_address,time_format:ehp1.)&rbt.\n   &lbt.,TIMEOUT=(:hp1.time_address,time_format:ehp1.)&rbt.\n:emac.\n.*---------------------------------------------------------------------*\n.* Syntax box for the CALLX form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:callx.\nCALLX :hp1.DT_epa:ehp1.,&cont.\n(:hp1.DT_token:ehp1.,&amp.DT_SUBTRACT,&cont.\n:hp1.datein_address:ehp1.\n              ,:hp1.datein_format:ehp1.,&cont.\n:hp1.timein_address:ehp1.,:hp1.timein_format:ehp1.\n              ,:hp1.interval_address,interval_format,:ehp1.&cont.\n:hp1.dateout_address,:ehp1.\n              ,:hp1.dateout_format,timeout_address,:ehp1.&cont.\n:hp1.timeout_format:ehp1.)\n:ecallx.\n.*---------------------------------------------------------------------*\n.* Parameter-list table describing each parameter.\n.*\n.* :plist.\n.* :pLt.parameter      | One pLt/pLd pair for each parameter that may\n.* :pLd.description    | be specified.\n.* :eplist.\n.*\n.*---------------------------------------------------------------------*\n:plist.\n:pLt.datein_address\n:pLd.Specifies the address of the input date value.\nFor variable-length input formats, the field needs only to be as long as\nthe date value, and does not need to be padded with spaces.  This is\ntrue for all input values for\n:#x.DT_SUBTRACT:e#x..\n:pLt.datein_format\n:pLd.Specifies the format of the input date value.\nThis value may be an integer, numeric symbol, or the address of a\nfullword in storage.  This is true of all format specifications\nfor :#x.DT_ADD:e#x..\n:pLt.timein_address\n:pLd.Provides the address of the input time value.\n:pLt.timein_format\n:pLd.Specifies the format of the input time value.\n:pLt.interval_address\n:pLd.Specifies the address of the input interval value.\n:pLt.interval_format\n:pLd.Specifies the format of the input interval value.\n:pLt.dateout_address\n:pLd.Specifies the address of the output date value.\nThe area should be large enough to hold the\nlongest possible date value for the requested format. If the format is\nvariable-length, it should be cleared to spaces before the call to\n:#x.DT_SUBTRACT:e#x..\n:pLt.dateout_format\n:pLd.Specifies the format of the output date value.\n:pLt.timeout_address\n:pLd.Provides the address of the output time value.\n:pLt.timeout_format\n:pLd.Specifies the format of the output time value.\n:eplist.\n.*---------------------------------------------------------------------*\n:fh3.Examples\nTo subtract a constant of\n75 hours to the date and time values in :#x.pwa_date:e#x. and\n:#x.pwa_time:e#x.,\none would code:\n:xmp.\nDT_SUBTRACT ID=DT,\n        DATEIN=(pwa_date,&DT_NORMAL),\n        TIMEIN=(pwa_time,&DT_HHMMSS),\n        INTERVAL=(75,&DT_HOURS),\n        DATEOUT=(pwa_date,&DT_NORMAL),\n        TIMEOUT=(pwa_time,&DT_HHMMSS)\n:exmp.\nThis would replace the contents of :#x.pwa_date:e#x. and\n:#x.pwa_time:e#x. with the updated date and time values.\n:efunc.\n.**********************************************************************\n.se temp = 'Terminate A Date/Time Services Session'\n:func id=dtterm name='DT_TERMINATE'.&temp.\n.**********************************************************************\n:p.\nThe :#x.DT_TERMINATE:e#x. function concludes\nthe Date/Time Services session identified by the\n:hp1.DT_token:ehp1. parameter, and releases any resources held\nby the Date/Time Services service processor.\n.*===>\n.*===> The :mac. and :callx. tags below are used to describe the\n.*===> syntax for invoking the function/macro.\n.*===>\n.*---------------------------------------------------------------------*\n.* Syntax box for the macro form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:mac.\nDT_TERMINATE ID=:hp1.id_name:ehp1. &cont.\n&lbt.,SPEPA=:hp1.DT_epa:ehp1.&rbt. &cont.\n&lbt.,SPTOKEN=:hp1.DT_token:ehp1.&rbt.\n:emac.\n.*---------------------------------------------------------------------*\n.* Syntax box for the CALLX form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:callx.\nCALLX :hp1.DT_epa:ehp1.,(:hp1.DT_token:ehp1.,&amp.DT_TERMINATE)\n.*===> If there are alternate forms, where the parameter list is\n.*===> significantly different depending on the first few parameter\n.*===> values, do something like the following:\n:ecallx.\n.*---------------------------------------------------------------------*\n.* Parameter-list table describing each parameter.\n.*\n.* :plist.\n.* :pLt.parameter      | One pLt/pLd pair for each parameter that may\n.* :pLd.description    | be specified.\n.* :eplist.\n.*\n.*---------------------------------------------------------------------*\n.* There are no function-specific parameters for DT_TERMINATE.\n.*---------------------------------------------------------------------*\n.* Optional sections for describing how to use the function/macro.\n.*---------------------------------------------------------------------*\n.*===> If one or two separate examples are being done, simply use\n.*===>\n.*===> :fh3.Example 1\n.*===>   ...example 1 stuff...\n.*===> :fh3.Example 2\n.*===>   ...example 2 stuff...\n.*===>\n.*===> If a whole system of related examples are being done, use\n.*===>\n.*===> :fh3.Examples\n.*===>   ....description general to all examples.\n.*===> :h5.Example 1\n.*===>   ...example 1 stuff...\n.*===> :h5.Example 2\n.*===>   ...example 2 stuff...\n.*===>\n.*---------------------------------------------------------------------*\n:fh3.Examples\n:p.The following :#x.DT_TERMINATE:e#x. macro will cause\nDate/Time Services to\nrelease any resources that it acquired.\n:xmp.\nDT_TERMINATE ID=DT\n:exmp.\n:efunc.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SRVDOCES": {"ttr": 11525, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x02\\x00\\x00V\\x01\\x11)\\x9f\\x01\\x11)\\x9f\\t'\\x06&\\x06&\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@\"", "ispf": {"version": "02.00", "flags": 0, "createdate": "2011-10-26T00:00:00", "modifydate": "2011-10-26T09:27:56", "lines": 1574, "newlines": 1574, "modlines": 0, "user": "CLEMSON"}, "text": ".*SRVESMVS*************************************************************\n.*                                                                    *\n.*                    Chapter. Environment Support                    *\n.*                                                                    *\n.**********************************************************************\n:h1 id=srves.Environment Support\n:p.\nEnvironment Support is both a service processor and the foundation on\nwhich other service processors build.  As a service processor, it acts\nas an interface between the programs that use it and the environment in\nwhich they run.\n:i1.Environment Support Vector\nAs a foundation for other service processors, it provides additional\nsupport through a data area called the Environment Support Vector, or\n:#x.ESV:e#x..\n:p.\nServices are available in Environment Support for obtaining and\nreleasing main storage, loading and unloading modules, issuing messages,\nand managing debugging information.  Services are also available for\nobtaining information about the current execution environment such as\nthe current time and date, userid and group name, JOB card parameters,\nand the prefix to use for qualifying data set names.\n:p.\nEnvironment support consists of a single load module and an assembler\n:#x.copy:e#x. member containing symbol definitions and macros. The\nload module for Environment Support must be loaded into main storage and\n:i1.ES_START\ninvoked with the :#x.ES_START:e#x. function (see :hdref\nrefid=esstart.)  before it can be used.  After it has been started, all\nof Environment Support's functions will remain available until the\n:i1.ES_TERMINATE\n:#x.ES_TERMINATE:e#x. function (see :hdref refid=esterm.) has been\ninvoked.\n.*--------------------------------------------------------------------*\n:h2.Symbols &amp. Macros\n.*--------------------------------------------------------------------*\n:ih1.copymember\n:i2.Environment Support\n:p.\nEnvironment Support's symbols and macros can be found in the assembler\ncopy member :#x.SRVESMAC:e#x.. This member contains symbols naming\nEnvironment Support's load module, function codes, return codes, and\nparameter values.  It also contains macros for using all of Environment\nSupport's functions.  The following statement or its equivalent should\nappear at the beginning of any program that uses Environment Support:\n:fig.\n:#x.\nCOPY  SRVESMAC      | Obtain Environment Support's symbols &amp. macros.\n:e#x.\n:figcap.Environment Support's Symbols and Macros\n:efig.\n.*--------------------------------------------------------------------*\n:h2.Establishing Service Processor Identifiers\n.*--------------------------------------------------------------------*\nSeveral parameters are general to Environment Support and not specific\nto any function.  These parameters include the load module's name\n(:#xi.es_epname:e#xi.), the entry point address (:#xi.es_epa:e#xi.), the\ntoken value (:#xi.es_token:e#xi.), and the Environment Support Vector's\naddress (:#xi.esva:e#xi.). The :#x.ES_ID:e#x. macro (see :hdref\nrefid=esid.) can be used to establish defaults for these parameters and\nassociate them with a unique service processor identifier.  The\nidentifier may then be supplied on any Environment Support macro\ninstruction to refer to the default parameter values.\n.*--------------------------------------------------------------------*\n:h2.Choosing an Environment Support Load Module\n.*--------------------------------------------------------------------*\n:p.\nIn order to support different execution environments, there may be more\nthan one Environment Support service processor.  However, all will have\nthe same basic protocol and will use the same :#x.COPY:e#x. member.\nEach Environment Support will reside in a separate load module, and the\n:#x.COPY:e#x. member will contain a different symbol for each one's\nload module name.  This provides programs with a degree of independence\nfrom their environment, as switching to the appropriate Environment\nSupport service processor may be all that is required in order to run\nunder different environments.\n:p.\nEnvironment Support, acting as an interface between programs and their\nexecution environment, has intimate knowledge of the environment in\nwhich it runs.  It directly invokes system services and may interrogate\ncontrol blocks.  To support multiple execution environments, there must\nbe separate Environment Support service processors for each environment,\nidentical in appearance to calling programs, but existing in separate\nload modules.  For example, in addition to the Environment Support that\nruns directly under MVS/XA, there might be one for VM/XA, one for CICS\nand another for IDMS/DC.\n:p.\nAt the time of this writing, only the MVS/XA programming environment is\nsupported.  However, a program that uses Environment Support's services\ninstead of directly accessing its environment can run under different\nenvironments in the future simply by switching to the appropriate\nEnvironment Support module.\n:p.\nSymbols defined in copy member :#x.SRVESMAC:e#x. contain Environment\nSupport's load module names enclosed in single quotation marks.  The\nsymbol for the MVS/XA Environment Support service processor looks like\nthe following:\n:xmp.\n&MVS_ENVIRONMENT_SUPPORT   SETC  '''SRVESMVS'''\n:exmp.\nThis symbolic name should be used as the service processor entry point\nname for environment support as shown in the following :#x.ES_ID:e#x.\nmacro.\n:xmp.\nES_ID ID=UNIQUE_NAME,SPEPNAME=&MVS_ENVIRONMENT_SUPPORT\n:exmp.\n.*--------------------------------------------------------------------*\n:h2.Loading Environment Support\n.*--------------------------------------------------------------------*\n:p.\nThe application program or its caller is responsible for loading\nEnvironment Support's load module into storage.  Because Environment\nSupport's services are not available until it has been loaded and\nstarted, the load process is environment-dependent.  For example, an\nassembler program running under MVS/XA would need to issue a :#x.LOAD\nEPNAME=&MVS_ENVIRONMENT_SUPPORT:e#x. macro instruction and save\nregister 0 (:#x.R0:e#x.) as the entry point address.\n:p.\nTo take advantage of the defaults established by :#x.ES_ID:e#x., use\none of the environment-specific load macros available for loading\nEnvironment Support.  In the MVS/XA environment, the code to identify\nand load Environment Support would look like the following:\n:xmp.\nCOPY        SRVESMAC            Obtain Env. Sup. symbols and macros.\nES_ID       ID=UNIQUE_NAME,SPEPNAME=&MVS_ENVIRONMENT_SUPPORT\nES_MVS_LOAD ID=UNIQUE_NAME      Load Environment Support into storage.\n:exmp.\n:p.\nThe :#x.ES_MVS_LOAD:e#x. macro (see :hdref refid=esmvsld.) issues the\nsame :#x.LOAD:e#x. instruction described above, but it has access to\nthe entry point address field (:#xi.es_epa:e#xi.) generated\nby the\n:#x.ES_ID:e#x. macro instruction so nothing needs to be expicitly\nspecified.  A complimentary macro, :#x.ES_MVS_UNLOAD:e#x., will\ngenerate the appropriate :#x.DELETE:e#x. instruction to remove\nEnvironment Support from storage.\n.*--------------------------------------------------------------------*\n:h2.Data Areas\n.*--------------------------------------------------------------------*\n:p.\nThere are three data areas associated with Environment Support: the\nEnvironment Support Vector (:#x.ESV:e#x.), Module Name Tables\n(:#x.MNT:e#x.s), and the Debugging Information Area (:#x.DIA:e#x.). Of\nthese, only the :#x.DIA:e#x. is not directly accessable to programs\nusing Environment Support: it is accessed via function calls instead.\n.*--------------------------------------------------------------------*\n:h3.The Environment Support Vector\n.*--------------------------------------------------------------------*\n:i1.Environment Support Vector\n:p.\nThe :#x.ESV:e#x. is a data area created by Environment during the\n:#x.ES_START:e#x. function to hold information specific to the current\nexecution environment.  This information is used internally by\nEnvironment Support and by other service processors.  The fields of the\n:#x.ESV:e#x. are mapped by the :#x.ES_ESV:e#x. macro (:hdref\nrefid=esesv.).\n:p.\nFor the most part, programs do not have any reason to access the\n:#x.ESV:e#x.'s fields.  However, two of the fields contained in the\n:#x.ESV:e#x. may be needed occasionally. These are the :#x.ESVESEPA:e#x.\nand the :#x.ESVESTKN:e#x..  The :#x.ESVESEPA:e#x. contains the entry\npoint address of Environment Support, and :#x.ESVESTKN:e#x. contains the\ntoken for the service processor session used to create the :#x.ESV:e#x..\nThese fields are of particular use to a routine that is called when\nEnvironment Support is already active: if the routine has the address of\nthe :#x.ESV:e#x., it can easily obtain the entry point address and token\nneeded for calling Environment Support's functions.  This is illustrated\nin the following example, which establishes addressability on the\n:#x.ESV:e#x. just long enough to copy the :#x.EPA:e#x. and\n:#x.TOKEN:e#x. of Environment Support (neither value will change until\nEnvironment Support is terminated or unloaded).\n:spot id=esvxmp.\n:xmp.\nBLOCK NAME=CMDEXEC,PARMS=(COMMAND,LENGTH,ESV),                       +\n             OPTIONS=(*PWA,(ESV,3),(PARMS,COPY,PREFIX,VL)\n  L     R1,&amp.PPL.ESV              | &cont.\nR1 -> Environment Support Vector.\n  USING ESV,R1                   | Establish addressability.\n  MVC   &amp.PWA.ES_SPEPA,ESVESEPA   | &cont.\nCopy Environment Support's EPA.\n  MVC   &amp.PWA.ES_SPTOKEN,ESVESEPA | &cont.\nCopy Environment Support's TOKEN.\n  DROP  R1                       | Drop addressability.\n  ES_ID ID=ES,SPEPA=&amp.PWA.ES_SPEPA,SPTOKEN=&amp.PWA.ES_SPTOKEN\n*\n  ES_DISPLAY_MESSAGE ID=ES,MESSAGE='The command to execute is:'\n  ES_DISPLAY_MESSAGE ID=ES,MESSAGE=(*&amp.PPL.COMMAND,&cont.\n*&amp.PPL.LENGTH)\n\n  ... Remainder of program code ...\n\nENDBLK BLOCK=CMDEXEC\n                  PWA\n&PWA.ES_SPEPA     DS  A\n&PWA.ES_SPTOKEN   DS  F\n\n                  ... Remainder of program work area ...\n\n                  ENDPWA\n                  ES_ESV         Environment Support Vector DSECT.\n:exmp.\n.*--------------------------------------------------------------------*\n:h3 id=MNTs.Module Name Tables\n.*--------------------------------------------------------------------*\n:i1.Module Name Table\n:i1.reentrant\n:p.\nThe purpose of module name tables (:#x.MNT:e#x.s) is to reduce the\nnumber of system loads that must be performed by the\n:#x.ES_LOAD_MODULE:e#x. function.  Two :#x.MNT:e#x.s may be searched by\n:#x.ES_LOAD_MODULE:e#x.: an application :#x.MNT:e#x. and Environment\nSupport's :#x.MNT:e#x..  The application :#x.MNT:e#x. is provided as an\noptional parameter to the :#x.ES_START:e#x. function by the calling\nprogram.  The :#x.ES_LOAD_MODULE:e#x. function will search the\napplication :#x.MNT:e#x. first and then Environment Support's\n:#x.MNT:e#x..\n:p.\nA module name table is an array of module names and addresses, with each\nrow in the array consisting of an eight character name followed by a\nfour byte address.  The final entry in the array is denoted by all\nzeros.  Typically, the modules named in an :#x.MNT:e#x. are link-edited\nwith the :#x.MNT:e#x. and the addresses are filled in by the system\nloader.  A module name table may also be filled in by the application\nprogram before it starts Environment Support.\n:p.\nThe structure of an :#x.MNT:e#x. is depicted in :figref refid=mntstr\npage=no., which has entries for three service processor modules:\n:fig id=mntstr.\n:#x.\n.ti ~ 05\n.tp 0.40i right 0.55i 1.25i 1.95i 2.65i\n.sp\n~~Name~TrueName~EPA\n.bx new thick thick 0.50i 1.20i 1.90i 2.60i\n~+0~SRVMM~SRVMM~025BF700~Memory Manager.\n.bx\n~+20~SRVMS~SRVMSMVS~00000000~Message Services.\n.bx\n~+40~SRVPL~SRVPLMVS~00000000~Printline.\n.bx\n~+80~SRVST~SRVST~02487AC0~String Handler.\n.bx\n~+100~SRVSY~SRVSY~00000000~Symbol Manager.\n.bx thick thick 0.50i 0.75i\n~+120~00~~~End of MNT.\n.bx off\n:e#x.\n:figcap.Module Name Table Layout\n:efig.\n:p.\nThe first two entries in :figref refid=mntstr page=no. show modules that\nhave been loaded into storage.  The third entry shows a module that has\nnot been loaded into storage, so its address field has been set to\nzeros.\n:p.\nWhen a module's name is found in an :#x.MNT:e#x. and it has a non-zero\nvalue in the address field, its address is simply returned to the\ncalling program.  If the address field is zero, :#x.ES_LOAD_MODULE:e#x.\nwill load the module into storage and return the address to the calling\nprogram (which may then fill in the module's address in the\n:#x.MNT:e#x.).  If the module's name is not in any :#x.MNT:e#x., it will\nalways be loaded into storage and its address will be returned to the\ncalling program.\n.sk 5\n.*--------------------------------------------------------------------*\n:h3.The Debugging Information Area\n.*--------------------------------------------------------------------*\n:p.\n:ih1.errors\n:i2.handling\nError tracking and reporting capabilities are provided by Environment\nSupport, permitting service processors and other programs to save vital\ndiagnostic information and messages when errors are detected.  Service\nprocessors update this area and set a return code whenever they\nencounter problems.  The calling program may then issue a single\nfunction call to Environment Support to display the diagnostic\ninformation and optionally abort with a full storage dump.  This scheme\nenables applications to make their own decisions about how errors should\nbe handled, but provides an easy way for them to abort execution\nimmediately while providing the user with messages and diagnostic\ninformation.\n:p.\nThe following services are provided for accessing the :#x.DIA:e#x.:\n:ul compact.\n:li.:#x.ES_CLEAR_DEBUG_INFO:e#x.,\n:li.:#x.ES_DISPLAY_DEBUG_INFO:e#x.,\n:li.:#x.ES_DISPLAY_DEBUG_INFO_AND_ABEND:e#x., and\n:li.:#x.ES_SAVE_DEBUG_INFO:e#x.\n:eul.\n.*--------------------------------------------------------------------*\n:h2.Common Parameters\n.*--------------------------------------------------------------------*\n:p.\nThere are several parameters common to any Environment Support function\ncall.  These parameters are listed below:\n.*****\n:plist.\n:pLt.id_name\n:pLd.the name of a service processor identifier created by the\n:#x.ES_ID:e#x. macro which will be used by all other function invocation\nmacros to automatically obtain values for :#xi.es_epa:e#xi. and\n:#xi.es_token:e#xi.. This parameter is required unless both\n:#xi.es_epa:e#xi. and :#xi.es_token:e#xi. are specified.\n:pLt.es_epa\n:pLd.a fullword in storage containing the entry point address of the\nEnvironment Support service processor.  The value specified by\n:#xi.es_epa:e#xi. overrides any value obtained from\n:#x.ID=:e#x.:#xi.id_name:e#xi..\n:pLt.es_token\n:pLd.a fullword in storage containing the value (to be) returned by\n:#x.ES_START:e#x. for the :#xi.es_token:e#xi. parameter.  The value\nspecified by :#xi.es_token:e#xi. overrides any value obtained from\n:#x.ID=:e#x.:#xi.id_name:e#xi..\n:eplist.\n.*--------------------------------------------------------------------*\n:h2.Complete List of Environment Support Return Codes\n.*--------------------------------------------------------------------*\n:p.\nMany return codes can be returned from each function.  In the function\ndescriptions later in this chapter, the most common return codes\nreturned by the particular function are documented.  The following\nis a complete list of Environment Support return codes.\n.*****\n:rclist.\n:rcn.0\n:rct.ES_SUCCESS\n:rcd.The invoked Environment Support function performed the requested\nservice without encountering any problems.\n:rcn.1\n:rct.ES_MISSING_EXIT_ROUTINE\n:rcd.This return code indicates that the :#x.ES_START:e#x. function was\nunable to locate one of its exit routines, which must either be link-edited\ninto the standard or application module name table or accessable via the\nstandard system load mechanism.\n:rcn.2\n:rct.ES_INTERNAL_ERROR\n:rcd.A self-examination within Environment Support determined that\nsomething was wrong.  This return code indicates a programming error\nwithin Environment Support.\n:rcn.4\n:rct.ES_INVALID_FUNCTION\n:rcd.An invalid :#xi.FunctionCode:e#xi. (the second parameter in any\nservice processor function call) was specified.\n:rcn.8\n:rct.ES_COULD_NOT_LOCATE\n:rcd.This return code is used by all :#x.ES_GET_...:e#x. functions to\nindicate that the requested information is unavailable.\n:rcn.12\n:rct.ES_INVALID_BOUNDARY\n:rcd.The :#xi.boundary:e#xi. parameter used for an\n:#x.ES_OBTAIN_STORAGE:e#x. function call does not contain a valid\nvalue.\n:rcn.16\n:rct.ES_INVALID_LOCATION\n:rcd.The :#xi.location:e#xi. parameter used for an\n:#x.ES_OBTAIN_STORAGE:e#x. function call does not contain a valid\nvalue.\n:rcn.17\n:rct.ES_INVALID_ACTION\n:rcd.The :#xi.action:e#xi. parameter used for an\n:#x.ES_CLEAR_DEBUG_INFO:e#x. function call does not contain a valid\nvalue.\n:rcn.18\n:rct.ES_CLEAR_DEBUG_INHIBITED\n:rcd.An explicit attempt was made to clear the debugging information\narea (function call :#x.ES_CLEAR_DEBUG_INFO ID=xx,ACTION=EXECUTE:e#x.),\nbut this function had been inhibited by a previous call (with\n:#x.ACTION=INHIBIT:e#x.).  The content of the debugging information area\nhas been left intact.\n:rcn.20\n:rct.ES_STORAGE_NOT_AVAILABLE\n:rcd.An :#x.ES_OBTAIN_STORAGE:e#x. function call requested more\nstorage than is currently available.\n:rcn.24:rct.ES_STORAGE_NOT_RELEASED\n:rcd.An :#x.ES_RELEASE_STORAGE:e#x. function call failed because\nthe storage could not be released for some reason (perhaps it was\nnot allocated in the first place?).\n:rcn.28:rct.ES_UNDETERMINED\n:rcd.An (internal, probably) error of indeterminate nature has\noccurred within Environment Support.\n:rcn.32:rct.ES_MODULE_NOT_LOADED\n:rcd.An :#x.ES_LOAD_MODULE:e#x. function call was not able to load\nthe requested module into storage.\n:rcn.36:rct.ES_MODULE_NOT_UNLOADED\n:rcd.An :#x.ES_UNLOAD_MODULE:e#x. function call was not able to unload\nthe requested module from storage.\n:rcn.40:rct.ES_WRONG_NUMBER_OF_PARMS\n:rcd.Either too few parameters were supplied for the function call or\ntoo many were supplied.  Check the parameter list to ensure that it is\nright for the function being invoked.\n:erclist.\n.*--------------------------------------------------------------------*\n:h2.Environment Support Service Processor Functions and Macros\n.*--------------------------------------------------------------------*\n:p.\nThe remaining sections of this chapter describe all functions provided\nby the Environment Support Service Processor, arranged in alphabetical\norder. Each function's description begins on a new page, and the name of\nthe function being described appears in the top outside corner of every\npage.\n.**********************************************************************\n.se temp = 'Reset the Debugging Information Area'\n:func name='ES_CLEAR_DEBUG_INFO'.&temp.\n.**********************************************************************\n:p.\nThe :#x.ES_CLEAR_DEBUG_INFO:e#x. function removes all information from\nthe debugging information area.  This function is invoked automatically\nby all service processors functions so that the only information\nretained in the debugging area is for the most recent problem.\n:note.The only return code you should expect from invoking this function\nis :#x.ES_SUCESS:e#x..\n:mac.\nES_CLEAR_DEBUG_INFO ID=:#xi.id_name:e#xi. &cont.\n&lbt.,SPEPA=:#xi.es_epa:e#xi.&rbt. &cont.\n&lbt.,SPTOKEN=:#xi.es_token:e#xi.&rbt.\n  &lbt.,ACTION=:#xi.action:e#xi.&rbt.\n:emac.\n:callx.\nCALLX :#xi.es_epa:e#xi.,(:#xi.es_token:e#xi.,&amp.ES_CLEAR_DEBUG_INFO,&cont.\n&lbt.:#xi.action:e#xi.&rbt.)\n:ecallx.\n.*****\n:plist.\n:pLt.action\n:pLd.an optional fullword value that specifies what action\n:#x.ES_CLEAR_DEBUG_INFO:e#x. should take with respect to clearing the\ndebugging information area.  The default value for :#xi.action:e#xi. is\n:#xb.EXECUTE:e#xb. (or set symbol :#x.&amp.ES_CDI_EXECUTE:e#x., a\nfullword value of :#xb.1:e#xb.), which will clear the debugging\ninformation area if this function has not been inhibited.  A value of\n:#xb.INHIBIT:e#xb. (set symbol :#x.&amp.ES_CDI_INHIBIT:e#x., a fullword\nvalue of :#xb.2:e#xb.) will inhibit clearing of the debugging\ninformation area.  A value of :#xb.ENABLE:e#xb. (set symbol\n:#x.&amp.ES_CDI_ENABLE:e#x., a fullword value of :#xb.3:e#xb.)\nwill reverse the effect of :#xb.INHIBIT:e#xb..\n:eplist.\n:note.Clearing of the debugging information area should not be inhibited\nexcept under one circumstance: after an error has occurred, an application\nprogram or service processor may need to call upon one or more service\nprocessor functions to help gather and/or format additional diagnostic\ninformation, without losing the information already present in the\ndebugging information area.  The :#x.INHIBIT:e#x. action should only be\ninvoked under this one condition, and the :#x.ENABLE:e#x. action should\nbe invoked as soon as the additional diagnostic information has been\ngathered and added to the debugging area.  Calling on the :#x.ENABLE:e#x.,\naction does not, in itself, cause the debugging information area to be\ncleared.\n:note.If :#x.ES_CLEAR_DEBUG_INFO:e#x. is invoked while the function is\ninhibited, it will not perform any action but will return a non-zero\nreturn-code (:#x.ES_CLEAR_DEBUG_INHIBITED:e#x.).\n:fh3.Example\n:p.\nSuppose an application program invokes the :#x.ST_FORMAT:e#x. function\nof the string-handler service processor to format a message.  The last\nfield in the message will contain text of unknown length, so the\napplication program expects to receive the :#x.ST_TRUNCATED:e#x.\nreturn code occasionally.  In that specific case, the application\nprogram has no need for the debugging information and clears it out to\navoid having\n:i1.abend\nit show up in a core dump if an abend occurs later.\n:fig.\n:#x.\nST_FORMAT ID=ST,CONTROL='APM0282 Remaining text discarded: %C(V)',&cont.\n        +\n             SOURCE=(INPUT_BUFFER,INPUT_LENGTH),                  &cont.\n        +\n             STRING=MESSAGE_BUFFER,RESULT_LENGTH=MESSAGE_LENGTH\nIF (CH,R15,EQ,=H'&amp.ST_TRUNCATED')    | If some text got truncated.\n  ES_CLEAR_DEBUG_INFO ID=ES         |   Don't worry about it.\nELSEIF (TREG,R15,NZ)                | ElseIf there was another problem.\n  STH     R15,PWA_LASTRC            |   Save the return code.\n  MVC     PWA_LASTSP,=C&amp.STRING_HANDLER&cont.\n  Save service processor's name.\n  ERREXIT CODE=&amp.ST_FORMAT&cont.\n           |   Let the error exit handle it.\nENDIF                               | EndIf.\n:e#x.\n:efig.\n:efunc.\n.**********************************************************************\n:func name='ES_DISPLAY_DEBUG_INFO'.Display Debugging Information\n.**********************************************************************\n:p.\nThe :#x.ES_DISPLAY_DEBUG_INFO:e#x. function displays all information\ncurrently in the debugging area.  This function, or the\n:#x.ES_DISPLAY_DEBUG_INFO_AND_ABEND:e#x. function, should be invoked\nwhenever an unexpected return code is returned by any service processor\nfunction.\n:note.The only return code you should expect from invoking this function\nis :#x.ES_SUCESS:e#x..\n:mac.\nES_DISPLAY_DEBUG_INFO ID=:hp1.id_name:ehp1. &cont.\n&lbt.,SPEPA=:hp1.es_epa:ehp1.&rbt. &cont.\n&lbt.,SPTOKEN=:hp1.es_token:ehp1.&rbt.\n:emac.\n:callx.\nCALLX :hp1.es_epa:ehp1.,(:hp1.es_token:ehp1.,&amp.ES_DISPLAY_DEBUG_INFO)\n:ecallx.\n:fh3.Example\n:p.\nThe error exit of an application program has determined that the return\ncode from a service processor function indicates an environmental\nproblem beyond its control, such as a data set that is allocated to\nanother user, or insufficient storage.  The problem needs to be\ncorrected before execution can continue, so the debugging information is\ndisplayed and the program terminates execution.\n:xmp.\nES_DISPLAY_DEBUG_INFO ID=ES              | Dump debugging information.\n:exmp.\n:efunc.\n.**********************************************************************\n:func name='ES_DISPLAY_DEBUG_INFO_AND_ABEND'.Abend with Dump\n.**********************************************************************\n:p.\n:i1.abend\nThe :#x.ES_DISPLAY_DEBUG_INFO_AND_ABEND:e#x. function displays all\ninformation currently in the debugging area and then issues a system\nrequest for an abend and storage dump.  The actual abend code issued\nis dependent on the implementation of Environment Support.  For the\nMVS/XA version of Environment Support, an MVS :#x.ABEND:e#x.\ninstruction with User Code 1000 will be issued.\n:note.This function does not return control to the application program.\nIt causes a task abend with a user code of 1000.\n:mac.\nES_DISPLAY_DEBUG_INFO_AND_ABEND ID=:hp1.id_name:ehp1. &cont.\n&lbt.,SPEPA=:hp1.es_epa:ehp1.&rbt.\n  &lbt.,SPTOKEN=:hp1.es_token:ehp1.&rbt.\n:emac.\n:callx.\nCALLX :hp1.es_epa:ehp1.,(:hp1.es_token:ehp1.,&cont.\n&amp.ES_DISPLAY_DEBUG_INFO_AND_ABEND)\n:ecallx.\n:fh3.Example\n:p.\nThe error exit of an application program has determined that the return\ncode from a service processor function indicates a programming error,\neither within the application or within a service processor.  Because\nthe error may be internal to the code being executed, all code and data\nareas should be dumped.\n:xmp.\nES_DISPLAY_DEBUG_INFO_AND_ABEND ID=ES    | Abort with a core dump.\n:exmp.\n:efunc.\n.**********************************************************************\n:func name='ES_DISPLAY_MESSAGE'.Display Text on the User's Screen\n.**********************************************************************\n:p.\nThe :#x.ES_DISPLAY_MESSAGE:e#x. function is used to write a textual\nmessage to the default output device.  For a TSO user, it is to the\nterminal screen; for background TSO, it is to file SYSTSPRT; for a\nstarted task, it is to the operator's console.\n:mac.\nES_DISPLAY_MESSAGE ID=:hp1.id_name:ehp1. &cont.\n&lbt.,SPEPA=:hp1.es_epa:ehp1.&rbt. &cont.\n&lbt.,SPTOKEN=:hp1.es_token:ehp1.&rbt.\n   ,MESSAGE=&lbr.:hp1.message:ehp1. | &cont.\n(:hp1.message:ehp1.,:hp1.length:ehp1.)&rbr.\n:emac.\n:callx.\nCALLX &cont.\n:hp1.es_epa:ehp1.,(:hp1.es_token:ehp1.,&amp.ES_DISPLAY_MESSAGE,&cont.\n:hp1.message:ehp1.&lbt.,:hp1.length:ehp1.&rbt.)\n:ecallx.\n.*****\n:plist.\n:pLt.message\n:pLd.specifies the label of a character string in storage containing the\nmessage to be displayed.  For both forms of invoking this function,\n:#xi.message:e#xi. may be specified as text enclosed in\nsingle quotation marks, which will cause a character-literal to be\ngenerated.\n:pLt.length\n:pLd.&lbt.optional&rbt. specifies the label of a fullword in storage\ncontaining the length of the character string named by\n:#xi.message:e#xi.. If :#xi.length:e#xi. is\n:hp1.not:ehp1.  specified, the storage named by\n:#xi.message:e#xi. must be prefixed with a signed halfword\ncontaining the length of the text to be displayed.\n:note.For the macro form of invoking this function, if\n:#xi.message:e#xi. is provided as a quoted string and :#xi.length:e#xi.\nis not specified, it will be automatically supplied by the\nmacro.\n:eplist.\n:fh3.Example\n:p.\nAn application program invokes the :#x.ST_FORMAT:e#x. function of the\nstring-handler to format a message, and then invokes the\n:#x.ES_DISPLAY_MESSAGE:e#x. function to display it to the user.\n:xmp.\nST_FORMAT ID=ST,CONTROL='APM0282 Remaining text discarded: %C(V)',   +\n             SOURCE=(INPUT_BUFFER,INPUT_LENGTH),                     +\n             STRING=MESSAGE_BUFFER,RESULT_LENGTH=MESSAGE_LENGTH\nIF (CH,R15,EQ,=H'&ST_TRUNCATED')    | If some text got truncated.\n  ES_CLEAR_DEBUG_INFO ID=ES         |   Don't worry about it.\nELSEIF (TREG,R15,NZ)                | ElseIf there was another problem.\n  STH     R15,PWA_LASTRC            |   Save the return code.\n  MVC     PWA_LASTSP,=C&STRING_HANDLER  Save service processor's name.\n  ERREXIT CODE=&ST_FORMAT           |   Let the error exit handle it.\nENDIF                               | EndIf.\nES_DISPLAY_MESSAGE ID=ES,MESSAGE=(MESSAGE_BUFFER,MESSAGE_LENGTH)\n:exmp.\n:efunc.\n.**********************************************************************\n.se temp = 'Environment Support Vector Mapping Macro'\n:func name='ES_ESV' id=esesv.&temp.\n.**********************************************************************\n:p.\nThe :#x.ES_ESV:e#x. macro is used to map the fields of the Environment\nSupport Vector, or :#x.ESV:e#x..  For an example of using this macro,\nsee page :spotref refid=esvxmp..\n:mac.\nES_ESV\n  &lbt.,DSECT=&lbr.:hp2.:us.YES:eus.:ehp2. | :hp2.NO:ehp2.&rbr.&rbt.\n  &lbt.,PREFIX=&lbr.:hp2.:us.ESV:eus.:ehp2. | &cont.\n:hp1.prefix:ehp1.&rbr.&rbt.\n:emac.\n.*****\n:plist.\n:pLt.DSECT\n:pLd.the :#xb.DSECT:e#xb. keyword controls whether or not an assembler\n:#x.DSECT:e#x. directive is generated.  The default is :#xb.YES:e#xb..\nThe value of :#xi.prefix:e#xi. will be used to name the :#x.DSECT:e#x..\nIf :#x.DSECT=NO:e#x. is specified, a label named :#xi.prefix:e#xi. will\nbe generated at the beginning of the :#x.ESV:e#x. storage.\n:pLt.prefix\n:pLd.specifies the name to use for the generated :#x.DSECT:e#x. or\nlabel, as well as the prefix for all the labels of all other\n:#x.ESV:e#x. fields.\n:eplist.\n:efunc.\n.**********************************************************************\n.se temp = 'Get the Computer Center Account Number'\n:func name='ES_GET_CACCT'.&temp.\n.**********************************************************************\n:p.\n:i1.account number\nThe :#x.ES_GET_CACCT:e#x. function returns to the application the\nComputer Center Account Number (CACCT) of the currently running job.\n:note.This function is specific to the :hp3.Clemson University:ehp3.\ncomputing environment.\n:mac.\nES_GET_CACCT ID=:hp1.id_name:ehp1. &cont.\n&lbt.,SPEPA=:hp1.es_epa:ehp1.&rbt. &cont.\n&lbt.,SPTOKEN=:hp1.es_token:ehp1.&rbt.\n   ,CACCT=:hp1.cacct:ehp1.\n:emac.\n:callx.\nCALLX :hp1.es_epa:ehp1.,(:hp1.es_token:ehp1.,&amp.ES_GET_CACCT,&cont.\n:hp1.cacct:ehp1.)\n:ecallx.\n.*****\n:plist.\n:pLt.cacct\n:pLd.specifies an eight (8) byte field into which the computer center\naccount number of the currently running job will be placed.\n:eplist.\n:efunc.\n.**********************************************************************\n.se temp = 'Get Printer Destination'\n:func name='ES_GET_DEFAULT_DESTINATION'.&temp\n.**********************************************************************\n:p.\nThe :#x.ES_GET_DEFAULT_DESTINATION:e#x. function returns to the\napplication the printer destination of the currently running job.\n:mac.\nES_GET_DEFAULT_DESTINATION ID=:hp1.id_name:ehp1. &cont.\n&lbt.,SPEPA=:hp1.es_epa:ehp1.&rbt. &cont.\n&lbt.,SPTOKEN=:hp1.es_token:ehp1.&rbt.\n   ,DEST=:hp1.dest:ehp1.\n:emac.\n:callx.\nCALLX :hp1.es_epa:ehp1.,(:hp1.es_token:ehp1.,&cont.\n&amp.ES_GET_DEFAULT_DESTINATION,:hp1.dest:ehp1.)\n:ecallx.\n.*****\n:plist.\n:pLt.dest\n:pLd.specifies an eight (8) byte field into which the default printer\ndestination of the currently running job will be placed.\n:eplist.\n:efunc.\n.**********************************************************************\n:func name='ES_GET_FORMATTED_TIME'.Get Time and Date\n.**********************************************************************\n:p.\nThe :#x.ES_GET_FORMATTED_TIME:e#x. function returns to the application\nthe current time of day, gregorian date, and julian date.\n:mac.\nES_GET_FORMATTED_TIME ID=:hp1.id_name:ehp1. &cont.\n&lbt.,SPEPA=:hp1.es_epa:ehp1.&rbt. &cont.\n&lbt.,SPTOKEN=:hp1.es_token:ehp1.&rbt.\n  &lbt.,TIME=:hp1.time:ehp1.&rbt.\n  &lbt.,GREGORIAN=:hp1.gregorian:ehp1.&rbt.\n  &lbt.,JULIAN=:hp1.julian:ehp1.&rbt.\n:emac.\n:callx.\nCALLX :hp1.es_epa:ehp1.,(:hp1.es_token:ehp1.,&cont.\n&amp.ES_GET_FORMATTED_TIME,&cont.\n&lbt.:hp1.time:ehp1.&rbt.,&lbt.:hp1.gregorian:ehp1.&rbt.,&cont.\n&lbt.:hp1.julian:ehp1.&rbt.)\n:ecallx.\n.*****\n:plist.\n:pLt.time\n:pLd.specifies an eleven (11) byte field into which the current time, in\nHH&colon.MM&colon.SS.TH character format\n(e.g.&rbl.:#x.18&colon.09&colon.53.78:e#x.) will be placed. The time is\nreturned in 24-hour format.\n:pLt.gregorian\n:pLd.specifies an eight (8) byte field into which the current date, in\nMM/DD/YY character format (e.g. :#x.05/04/89:e#x.) will be placed.\n:pLt.julian\n:pLd.specifies an eight (8) byte field into which the current date, in\nCCYY.DDD character format (e.g. :#x.1989.124:e#x.) will be placed.\n:eplist.\n:efunc.\n.**********************************************************************\n.se temp = 'Get the RACF Group Name of the Current User'\n:func name='ES_GET_GROUP'.&temp.\n.**********************************************************************\n:p.\nThe :#x.ES_GET_GROUP:e#x. function returns to the application\nthe RACF group name under which the current job is running.\n:mac.\nES_GET_GROUP ID=:hp1.id_name:ehp1. &cont.\n&lbt.,SPEPA=:hp1.es_epa:ehp1.&rbt. &cont.\n&lbt.,SPTOKEN=:hp1.es_token:ehp1.&rbt.\n   ,GROUP=:hp1.group:ehp1.\n:emac.\n:callx.\nCALLX :hp1.es_epa:ehp1.,(:hp1.es_token:ehp1.,&amp.ES_GET_GROUP,&cont.\n:hp1.group:ehp1.)\n:ecallx.\n.*****\n:plist.\n:pLt.group\n:pLd.specifies an eight (8) byte field into which the RACF group name\nunder which the currently running job is running will be placed.\n:eplist.\n:efunc.\n.**********************************************************************\n.se temp = 'Get the Programmer Comment Field'\n:func name='ES_GET_JOBCARD_NAME_FIELD'.&temp.\n.**********************************************************************\n:p.\nThe :#x.ES_GET_JOBCARD_NAME:e#x. function returns to the application\nthe user comment field from the job card of the currently running job.\n:mac.\nES_GET_JOBCARD_NAME_FIELD ID=:hp1.id_name:ehp1. &cont.\n&lbt.,SPEPA=:hp1.es_epa:ehp1.&rbt. &cont.\n&lbt.,SPTOKEN=:hp1.es_token:ehp1.&rbt.\n   ,NAME=:hp1.name:ehp1.\n:emac.\n:callx.\nCALLX &cont.\n:hp1.es_epa:ehp1.,(:hp1.es_token:ehp1.,&amp.ES_GET_JOBCARD_NAME,&cont.\n:hp1.name:ehp1.)\n:ecallx.\n.*****\n:plist.\n:pLt.name\n:pLd.specifies a twenty (20) byte field into which the programmer\nname field of the currently running job's :#x.JOB:e#x. card will be\nplaced.\n:eplist.\n:efunc.\n.**********************************************************************\n:func name='ES_GET_JOBCARD_ROOM'.Get the Programmer Room Field\n.**********************************************************************\n:p.\nThe :#x.ES_GET_JOBCARD_ROOM:e#x. function returns to the application\nthe room field from the job card of the currently running job.\n:mac.\nES_GET_JOBCARD_ROOM ID=:hp1.id_name:ehp1. &cont.\n&lbt.,SPEPA=:hp1.es_epa:ehp1.&rbt. &cont.\n&lbt.,SPTOKEN=:hp1.es_token:ehp1.&rbt.\n   ,ROOM=:hp1.room:ehp1.\n:emac.\n:callx.\nCALLX &cont.\n:hp1.es_epa:ehp1.,(:hp1.es_token:ehp1.,&amp.ES_GET_JOBCARD_ROOM,&cont.\n:hp1.room:ehp1.)\n:ecallx.\n.*****\n:plist.\n:pLt.room\n:pLd.specifies a four (4) byte field into which the room field of the\ncurrently running job's :#x.JOB:e#x. card will be placed.\n:eplist.\n:efunc.\n.**********************************************************************\n:func name='ES_GET_JOBID'.Get the System Assigned Job Identifier\n.**********************************************************************\n:p.\nThe :#x.ES_GET_JOBID:e#x. function returns to the application\nthe system assigned job identifier of the currently running job.\n:mac.\nES_GET_JOBID ID=:hp1.id_name:ehp1. &cont.\n&lbt.,SPEPA=:hp1.es_epa:ehp1.&rbt. &cont.\n&lbt.,SPTOKEN=:hp1.es_token:ehp1.&rbt.\n   ,JOBID=:hp1.jobid:ehp1.\n:emac.\n:callx.\nCALLX :hp1.es_epa:ehp1.,(:hp1.es_token:ehp1.,&amp.ES_GET_JOBID,&cont.\n:hp1.jobid:ehp1.)\n:ecallx.\n.*****\n:plist.\n:pLt.jobid\n:pLd.specifies an eight (8) byte field into which the system-assigned\njob identifier for the currently running job will be placed.\n:eplist.\n:efunc.\n.**********************************************************************\n:func name='ES_GET_PREFIX'.Get Data Set Name Prefix\n.**********************************************************************\n:p.\nThe :#x.ES_GET_PREFIX:e#x. function returns to the application the\ndata set name prefix to use for unqualified data set names encountered\nunder the currently running job.\n:mac.\nES_GET_PREFIX ID=:hp1.id_name:ehp1. &cont.\n&lbt.,SPEPA=:hp1.es_epa:ehp1.&rbt. &cont.\n&lbt.,SPTOKEN=:hp1.es_token:ehp1.&rbt.\n   ,PREFIX=:hp1.prefix:ehp1.\n:emac.\n:callx.\nCALLX :hp1.es_epa:ehp1.,(:hp1.es_token:ehp1.,&amp.ES_GET_PREFIX,&cont.\n:hp1.prefix:ehp1.)\n:ecallx.\n.*****\n:plist.\n:pLt.prefix\n:pLd.specifies an eight (8) byte field into which the current TSO user's\ndata set name prefix will be placed.\n:eplist.\n:efunc.\n.**********************************************************************\n:func name='ES_GET_SYSRES_VOLUME_NAME'.Get Volser of IPL Volume\n.**********************************************************************\n:p.\nThe :#x.ES_GET_SYSRES_VOLUME_NAME:e#x. function returns to the\napplication the volume serial name of the volume from which the\nsystem was IPLed.\n:mac.\nES_GET_SYSRES_VOLUME_NAME ID=:hp1.id_name:ehp1. &cont.\n&lbt.,SPEPA=:hp1.es_epa:ehp1.&rbt. &cont.\n&lbt.,SPTOKEN=:hp1.es_token:ehp1.&rbt.\n   ,VOLSER=:hp1.volser:ehp1.\n:emac.\n:callx.\nCALLX :hp1.es_epa:ehp1.,(:hp1.es_token:ehp1.,&cont.\n&amp.ES_GET_SYSRES_VOLUME_NAME,&cont.\n:hp1.volser:ehp1.)\n:ecallx.\n.*****\n:plist.\n:pLt.volser\n:pLd.specifies a six (6) byte field into which the volume serial number\nof the volume from which the currently running system was IPLed will\nbe placed.\n:eplist.\n:efunc.\n.**********************************************************************\n.se temp = 'Get the User''s Terminal Name'\n:func name='ES_GET_TERMINAL_NAME'.&temp.\n.**********************************************************************\n:p.\nThe :#x.ES_GET_TERMINAL_NAME:e#x. function returns to the application\nthe terminal name of the terminal assigned to the current user.\n:mac.\nES_GET_TERMINAL_NAME ID=:hp1.id_name:ehp1. &cont.\n&lbt.,SPEPA=:hp1.es_epa:ehp1.&rbt. &cont.\n&lbt.,SPTOKEN=:hp1.es_token:ehp1.&rbt.\n   ,NAME=:hp1.name:ehp1.\n:emac.\n:callx.\nCALLX &cont.\n:hp1.es_epa:ehp1.,(:hp1.es_token:ehp1.,&amp.ES_GET_TERMINAL_NAME,&cont.\n:hp1.name:ehp1.)\n:ecallx.\n.*****\n:plist.\n:pLt.name\n:pLd.specifies an eight (8) byte field into which the current TSO user's\nterminal name will be placed.\n:eplist.\n:efunc.\n.**********************************************************************\n:func name='ES_GET_TIME'.Get Time and Date\n.**********************************************************************\n:p.\nThe :#x.ES_GET_TIME:e#x. function returns to the application the\ncurrent time and date.\n:mac.\nES_GET_TIME ID=:hp1.id_name:ehp1. &cont.\n&lbt.,SPEPA=:hp1.es_epa:ehp1.&rbt. &cont.\n&lbt.,SPTOKEN=:hp1.es_token:ehp1.&rbt.\n  &lbt.,TIME=:hp1.time:ehp1.&rbt.\n  &lbt.,DATE=:hp1.date:ehp1.&rbt.\n:emac.\n:callx.\nCALLX :hp1.es_epa:ehp1.,(:hp1.es_token:ehp1.,&amp.ES_GET_TIME,&cont.\n:hp1.time:ehp1.,:hp1.date:ehp1.)\n:ecallx.\n.*****\n:plist.\n:pLt.time\n:pLd.specifies a fullword into which the current time of day, in .01\nsecond units, will be placed.\n:pLt.date\n:pLd.specifies a fullword into which the current date, in packed-decimal\nCCYYDDDs format, will be placed.\n:eplist.\n:efunc.\n.**********************************************************************\n:func name='ES_GET_TSU_STC_OR_JOB'.Determine the Current Environment\n.**********************************************************************\n:p.\nThe :#x.ES_GET_TSU_STC_OR_JOB:e#x. function returns to the application\nan indicator of the environment under which it is running.\n:mac.\nES_GET_TSU_STC_OR_JOB ID=:hp1.id_name:ehp1. &cont.\n&lbt.,SPEPA=:hp1.es_epa:ehp1.&rbt. &cont.\n&lbt.,SPTOKEN=:hp1.es_token:ehp1.&rbt.\n   ,TYPE=:hp1.type:ehp1.\n:emac.\n:callx.\nCALLX &cont.\n:hp1.es_epa:ehp1.,(:hp1.es_token:ehp1.,&amp.ES_GET_TSU_STC_OR_JOB,&cont.\n:hp1.type:ehp1.)\n:ecallx.\n.*****\n:plist.\n:pLt.type\n:pLd.specifies a three (3) byte field into which an indicator of the\ncurrent execution environment will be placed.  The indicator will be\n:#x.\"TSU\":e#x. if executing under foreground TSO, :#x.\"STC\":e#x. if\nexecuting as a started-task, and :#x.\"JOB\":e#x. if executing as a\nbatch job.\n:eplist.\n:efunc.\n.**********************************************************************\n:func name='ES_GET_USERID'.Get the Userid of the Current User\n.**********************************************************************\n:p.\nThe :#x.ES_GET_USERID:e#x. function returns to the application the\nuserid of the currently running TSU session.\n:mac.\nES_GET_USERID ID=:hp1.id_name:ehp1. &cont.\n&lbt.,SPEPA=:hp1.es_epa:ehp1.&rbt. &cont.\n&lbt.,SPTOKEN=:hp1.es_token:ehp1.&rbt.\n   ,USERID=:hp1.userid:ehp1.\n:emac.\n:callx.\nCALLX :hp1.es_epa:ehp1.,(:hp1.es_token:ehp1.,&amp.ES_GET_USERID,&cont.\n:hp1.userid:ehp1.)\n:ecallx.\n.*****\n:plist.\n:pLt.userid\n:pLd.specifies a seven (7) byte field into which the userid of the\nTSO user currently logged on will be placed.\n:eplist.\n:efunc.\n.**********************************************************************\n.se temp = 'Establish Default Environment Support Values'\n:func name='ES_ID' id=esid.&temp.\n.**********************************************************************\n:p.\nThe :#x.ES_ID:e#x. macro is used to establish default values for use\nby other Environment Support macros, which may access those defaults\nthrough a unique identifier, :#xi.id_name:e#xi., specified by\nthe user.  Default values can be established for the following\nparameters:\n:#xi.es_epname:e#xi., :#xi.es_epa:e#xi.,\n:#xi.es_token:e#xi., and\n:#xi.esva:e#xi..\n:p.\nIn most cases, nothing other than the entry point name needs to be\nspecified on the :#x.ES_ID:e#x. macro: it will automatically define\nworking storage fields for the remaining parameters if they are not\nspecified.  These values, whether generated by the macro or provided by\nthe user, are accessable from all other Environment Support macros.\n:p.\nIf the application program needs to access the parameters directly, then\nthey should be explicitly specified.  For example, suppose a program\nreceives as one of its parameters the Environment Support Vector of an\nalready-started Environment Support service processor.  In that case,\nthe module name would not be needed but the entry point address and\ntoken value, already defined within the :#x.ESV:e#x., would need to be\nspecified.  Assuming addressability on the :#x.ESV:e#x., the following\n:#x.ES_ID:e#x. macro instruction might be used to specify these\nfields.\n:xmp.\nES_ID ID=STARTED_ES,SPEPA=ESVESEPA,SPTOKEN=ESVESTKN\n:exmp.\n:mac.\nES_ID ID=:hp1.id_name:ehp1.\n  &lbt.,SPEPNAME=:hp1.es_epname:ehp1.&rbt.\n  &lbt.,SPEPA=:hp1.es_epa:ehp1.&rbt.\n  &lbt.,SPTOKEN=:hp1.es_token:ehp1.&rbt.\n  &lbt.,ESVA=:hp1.esva:ehp1.&rbt.\n:emac.\n.*****\n:plist.\n:pLt.id_name\n:pLd.the identifier to assign to the service processor identifier being\nestablished.  This name must be unique for all service processor\nidentifier's.\n:pLt.es_epname\n:pLd.the entry point name of the Environment Support service processor\nmodule that is being used.\n:pLt.es_epa\n:pLd.specifies the label of a fullword in storage that will contain the\nentry point address of the Environment Support service processor.\n:pLt.es_token\n:pLd.specifies the label of a fullword in storage that will contain the\ntoken assigned by the ES_START function of Environment Support.\n:pLt.esva\n:pLd.specifies the label of a fullword in storage that will contain the\naddress of the environment support vector created by the ES_START\nfunction of Environment Support.\n:eplist.\n:fh3.Example 1\n:p.\nThe :#x.ES_ID:e#x. macro below is the one most likely to be used in an\nMVS assembler program.  It specifies an :#xi.id_name:e#xi. of\n:#x.ES:e#x. and the entry point name for the MVS environment support\nmodule, but allows all other values to default.  The :#x.ES_ID:e#x.\nmacro will generate fields in the Structured Macros PWA for holding\nenvironment support's entry point address, service processor token\nfullword, and a pointer to the environment support vector.  All other\nenvironment support macros will be able to access those fields simply by\nspecifying\n:#x.ID=ES:e#x.\n:xmp.\nES_ID     ID=ES,SPEPNAME=&MVS_ENVIRONMENT_SUPPORT\n:exmp.\n:fh3.Example 2\n:p.\nThe next example shows how a program would be set up if it were called\nwith environment support already active.  Presumably, the program would\nhave the environment support vector passed to it as one of its\nparameters, and the example shows surrounding program text that takes\nthis into account.  This is, in fact, the situation with service\nprocessors themselves; their :#x.START:e#x. function is always called\nwith an ESV as one of the parameters.\n:xmp.\nBLOCK NAME=SERVER,TYPE=PROGRAM,OPTIONS=(*PWA),R1SAVE=R9\n  USING PARM_LIST,R9                       | R9 -> Parm list passed in.\n  L     R8,PARM_ESV                        | R8 -> Active ESV.\n  USING ESV,R8                             | Establish addressability.\n  ES_ID ID=ACTIVE_ES,ESV=PARM_ESV,SPEPA=ESVESEPA,SPTOKEN=ESVESTKN\n  .\n  . Remaining program.\n  .\nENDBLK BLOCK=SERVER\n:exmp.\n:p.\nNotice that since the ESV contains fields within it for the EPA and\nTOKEN, its fields may be named directly on the :#x.ES_ID:e#x. macro.\nHowever, if this is done, all environment support macros must have\naddressability to the ESV.  It is usually easier to copy these two\nvalues to the PWA to save on register usage.\n:efunc.\n.**********************************************************************\n:func name='ES_LOAD_MODULE'.Load a Module into Main Storage\n.**********************************************************************\n:p.\nThe :#x.ES_LOAD_MODULE:e#x. function is used to load a module into\nstorage.  If the module name is in the application Module Name Table\n(MNT) or the standard MNT and the table entry contains a nonzero entry\npoint address, :#x.ES_LOAD_MODULE:e#x. returns this address to the\ncaller; otherwise, the request is satisfied by issuing an MVS\n:#x.LOAD:e#x. macro.\n:mac.\nES_LOAD_MODULE ID=:hp1.id_name:ehp1. &cont.\n&lbt.,SPEPA=:hp1.es_epa:ehp1.&rbt. &cont.\n&lbt.,SPTOKEN=:hp1.es_token:ehp1.&rbt.\n  &lbt.,SPID=:hp1.spid_name:ehp1.&rbt.\n  &lbt.,EPNAME=:hp1.epname:ehp1.&rbt.\n  &lbt.,EPA=:hp1.epa:ehp1.&rbt.\n  &lbt.,TYPE=&lbr.:us.STANDARD:eus. | MNT_ONLY&rbr.\n:emac.\n:callx.\nCALLX :hp1.es_epa:ehp1.,(:hp1.es_token:ehp1.,&amp.ES_LOAD_MODULE,&cont.\n:hp1.epname:ehp1.,:hp1.epa:ehp1.&lbt.,:hp1.type:ehp1.&rbt.)\n:ecallx.\n.*****\n:plist.\n:pLt.spid_name\n:pLd.specifies the name of a service processor identifier created by any\n:#x.:hp1.xx:ehp1._ID:e#x. macro which will be used by the\n:#x.ES_LOAD_MODULE:e#x. macro to automatically obtain values for\n:#xi.epname:e#xi. and :#xi.epa:e#xi. (see below). This\nparameter is required unless both :#xi.epname:e#xi. and\n:#xi.epa:e#xi. are specified.\n:pLt.epname\n:pLd.an eight byte field containing the name of the entry point to be\nloaded. This parameter may be specified in single quotes if desired, in\nwhich case a literal will be created for it.  The value specified by\n:#xi.epname:e#xi. overrides any value obtained from\n:#x.SPID:e#x.=:#xi.spid_name:e#xi..\n:pLt.epa\n:pLd.specifies the address of a fullword into which will be stored\nthe address of the module loaded.  The value specified by\n:#xi.epa:e#xi. overrides any value obtained from\n:#x.SPID:e#x.=:#xi.spid_name:e#xi..\n:pLt.type\n:pLd.specifies the process by which a module may be loaded.  The\n:#xb.STANDARD:e#xb. process is to search the application MNT first (if\nthere is one), then the standard MNT; if the module is not in either MNT\nor if the located MNT entry contains zeros for its EPA, a normal system\nload will be performed.  The :#xb.MNT_ONLY:e#xb. process will not\nperform any load if the module is not named in one of the MNTs, although\na load may still be done if the module's MNT entry contains zeros for\nits EPA.  For the :#x.CALLX:e#x. form of invoking this function, symbols\n:#xb.&amp.ES_LM_STANDARD:e#xb. and :#xb.&amp.ES_LM_MNT_ONLY:e#xb.\nmay be used.\n:eplist.\n:fh3.Example\n:p.\nThis example illustrates a program loading several service processors.\nSince each service processor is assigned a unique service processor\nidentifier through :#x.xx_ID:e#x. macro instructions, no tags are\nexplicitly created in working storage.\n:xmp.\n*\n* Obtain symbols &amp. macros for all service processors.\n*\n  COPY           SRVESMAC   Environment Support's symbols &amp. macros.\n  COPY           SRVMMMAC   Memory Manager symbols &amp. macros.\n  COPY           SRVSTMAC   String Handler symbols &amp. macros.\n  COPY           SRVSYMAC   Symbol Manager symbols &amp. macros.\n  COPY           SRVFIMAC   Standard File Handler symbols &amp. macros.\n*\n* Establish default values for all service processors.\n*\n  ES_ID          ID=ES,SPEPNAME=&MVS_ENVIRONMENT_SUPPORT\n  MM_ID          ID=MM,SPEPNAME=&MEMORY_MANAGER\n  ST_ID          ID=ST,SPEPNAME=&STRING_HANDLER\n  SY_ID          ID=SY,SPEPNAME=&SYMBOL_MANAGER\n  FI_ID          ID=FI,SPEPNAME=&FI_OS_FILE_HANDLER\n*\n  ES_MVS_LOAD    ID=ES                Load environment support.\n  ES_START       ID=ES                Start environment support.\n  ES_LOAD_MODULE ID=ES,SPID=MM        Load the memory manager.\n  ES_LOAD_MODULE ID=ES,SPID=ST        Load the string handler.\n  ES_LOAD_MODULE ID=ES,SPID=SY        Load the symbol manager.\n  ES_LOAD_MODULE ID=ES,SPID=FI        Load the standard file handler.\n:exmp.\n:efunc.\n.**********************************************************************\n.se temp = 'Module Name Table Mapping Macro'\n:func name='ES_MNT'.&temp.\n.**********************************************************************\n:p.\nThe :#x.ES_MNT:e#x. macro is used to map individual entries in a Module\nName Table, or :#x.MNT:e#x..\n:mac.\nES_MNT\n  &lbt.,DSECT=&lbr.:hp2.:us.YES:eus.:ehp2. | :hp2.NO:ehp2.&rbr.&rbt.\n  &lbt.,ID=&lbr.:hp2.:us.ES_MNT:eus.:ehp2. | :hp1.prefix:ehp1.&rbr.&rbt.\n:emac.\n.*****\n:plist.\n:pLt.DSECT\n:pLd.the :#xb.DSECT:e#xb. keyword controls whether or not an assembler\n:#x.DSECT:e#x. directive is generated.  The default is :#xb.YES:e#xb..\nThe value of :#xi.prefix:e#xi. will be used to name the :#x.DSECT:e#x..\nIf :#x.DSECT=NO:e#x. is specified, a label named :#xi.prefix:e#xi. will\nbe generated at the beginning of the :#x.MNT:e#x. storage.\n:pLt.prefix\n:pLd.specifies the name to use for the generated :#x.DSECT:e#x. or\nlabel, as well as the prefix for all the labels of all other\n:#x.MNT:e#x. fields.\n:eplist.\n:efunc.\n.**********************************************************************\n.se temp = 'Module Name Table Creation Macro'\n:func name='ES_MODULE_NAME'.&temp.\n.**********************************************************************\n:p.\nThe :#x.ES_MODULE_NAME:e#x. macro is used generate entries in a static\nModule Name Table.\n:mac.\nES_MODULE_NAME START,NAME=':hp1.table_name:ehp1.'\n\n- or -\n\nES_MODULE_NAME NAME=':hp1.generic_name:ehp1.'&cont.\n&lbt.,TRUENAME=':hp1.entry_name:ehp1.'&rbt.\n\n- or -\n\nES_MODULE_NAME END\n:emac.\n.*****\n:plist.\n:pLt.table_name\n:pLd.Will be documented at a later time.\n:pLt.generic_name\n:pLd.Will be documented at a later time.\n:pLt.entry_name\n:pLd.Will be documented at a later time.\n:eplist.\n:efunc.\n.**********************************************************************\n.se temp = 'Load MVS Environment Support'\n:func name='ES_MVS_LOAD' id=esmvsld.&temp.\n.**********************************************************************\n:p.\nThe :#x.ES_MVS_LOAD:e#x. macro is used in an MVS environment to load\nthe Environment Support module into main storage.  This is only one\npossible method that may be used and is provided as a convenience.\nThis macro has access to all fields identified by the :#x.ES_ID:e#x.\nmacro.\n:mac.\nES_MVS_LOAD ID=:hp1.id_name:ehp1. &cont.\n&lbt.,SPEPNAME=:hp1.es_epname:ehp1.&rbt. &cont.\n&lbt.,SPEPA=:hp1.es_epa:ehp1.&rbt.\n:emac.\n.*****\n:plist.\n:pLt.id_name\n:pLd.specifies the name of a service processor identifier created by the\n:#x.ES_ID:e#x. macro.\n:pLt.es_epname\n:pLd.specifies the entry point name of the Environment Support service\nprocessor module that is being loaded.\n:pLt.es_epa\n:pLd.specifies the label of a fullword in storage that will contain the\nentry point address of the Environment Support service processor.\n:eplist.\n.*****\n:fh3.Return Codes\n:p.\n:i1.abend\nThe :#x.ES_MVS_LOAD:e#x. macro generates an MVS :#x.LOAD:e#x.\ninstruction, which will cause a task abend if the module could not be\nfound or loaded.  The content of register 15 (:#x.R15:e#x.) is\nunpredictable.\n:fh3.Example\n:p.\nThis example illustrates the intended use of :#x.ES_MVS_LOAD:e#x.. The\nmacro has access to all fields generated by the :#x.ES_ID:e#x. macro,\nrelieving the programmer of the need to explicitly create any tags.\n:xmp.\nES_ID       ID=ES,SPEPNAME=&MVS_ENVIRONMENT_SUPPORT  Set up an ES_ID.\nES_MVS_LOAD ID=ES                                    Load Env. Support.\n:exmp.\n:efunc.\n.**********************************************************************\n.se temp = 'Unload MVS Environment Support'\n:func name='ES_MVS_UNLOAD' id=esmvsul.&temp.\n.**********************************************************************\n:p.\nThe :#x.ES_MVS_UNLOAD:e#x. macro complements the\n:#x.ES_MVS_LOAD:e#x. macro by unloading the environment support\nmodule from main storage.\n:mac.\nES_MVS_UNLOAD ID=:hp1.id_name:ehp1. &cont.\n&lbt.,SPEPNAME=:hp1.es_epname:ehp1.&rbt. &cont.\n&lbt.,SPEPA=:hp1.es_epa:ehp1.&rbt.\n:emac.\n.*****\n:plist.\n:pLt.id_name\n:pLd.specifies the name of a service processor identifier created by the\nES_ID macro.\n:pLt.es_epname\n:pLd.specifies the entry point name of the Environment Support service\nprocessor module that is being loaded.\n:pLt.es_epa\n:pLd.specifies the label of a fullword in storage that will contain the\nentry point address of the Environment Support service processor.\n:eplist.\n.*****\n:p.\nThe :#x.ES_MVS_UNLOAD:e#x. macro generates an MVS :#x.DELETE:e#x.\ninstruction, which will set register 15 (:#x.R15:e#x.) to 0 for\nsuccessful completion and 4 for unsuccessful completion.\n:fh3.Example\n:p.\nThis example illustrates the use of :#x.ES_MVS_UNLOAD:e#x. to\ncomplement :#x.ES_MVS_LOAD:e#x..\n:xmp.\nES_ID       ID=ES,SPEPNAME=&MVS_ENVIRONMENT_SUPPORT  Set up an ES_ID.\nES_MVS_LOAD ID=ES                                    Load Env. Support.\n   .\n   . main body of program.\n   .\nES_MVS_UNLOAD ID=ES                                  Unload Env. Sup.\n:exmp.\n:efunc.\n.**********************************************************************\n:func name='ES_OBTAIN_STORAGE'.Obtain a Block of Main Storage\n.**********************************************************************\n:p.\nThe :#x.ES_OBTAIN_STORAGE:e#x. function is used to obtain storage\nabove or below the 16 megabyte line on a doubleword or page boundary.\nThis request for storage is satisfied by issuing an MVS RC-form\n:#x.GETMAIN:e#x. SVC.\n:mac.\nES_OBTAIN_STORAGE ID=:hp1.id_name:ehp1. &cont.\n&lbt.,SPEPA=:hp1.es_epa:ehp1.&rbt. &cont.\n&lbt.,SPTOKEN=:hp1.es_token:ehp1.&rbt.\n  &lbt.,SUBPOOL=&lbr.:hp1.subpool:ehp1. &cont.\n| :hp2.:us.0:eus.:ehp2.&rbr.&rbt.\n  &lbt.,LOCATION=&lbr.:hp2.:us.ANY:eus.:ehp2. &cont.\n| :hp2.BELOW:ehp2.&rbr.&rbt.\n  &lbt.,BOUNDARY=&lbr.:hp2.:us.DOUBLEWORD:eus.:ehp2. &cont.\n| :hp2.PAGE:ehp2.&rbr.&rbt.\n   ,SIZE=:hp1.size:ehp1.\n   ,ADDRESS=:hp1.address:ehp1.\n:emac.\n:callx.\nCALLX &cont.\n:hp1.es_epa:ehp1.,(:hp1.es_token:ehp1.,&amp.ES_OBTAIN_STORAGE,&cont.\n:hp1.size:ehp1.,:hp1.subpool:ehp1.,:hp1.boundary:ehp1.,\n              :hp1.location:ehp1.,:hp1.address:ehp1.)\n:ecallx.\n.*****\n:plist.\n:pLt.size\n:pLd.a fullword containing the size in bytes of the storage area\nrequested.\n:pLt.subpool\n:pLd.a fullword containing a binary 0 - 127 for the subpool that the\nstorage should be obtained from.\n:pLt.boundary\n:pLd.specifies whether the storage to be obtained should be allocated on\na :#x.:hp2.DOUBLEWORD:ehp2.:e#x. boundary or a\n:#x.:hp2.PAGE:ehp2.:e#x. boundary. For the macro, the default is\n:#x.:hp2.DOUBLEWORD:ehp2.:e#x.. There is no default value for the\n:#x.CALLX:e#x. form of invoking this function, which requires that\n:#xi.boundary:e#xi. indicate a fullword containing a 1 (set\nsymbol :#x.&amp.ES_DOUBLEWORD_BOUNDARY:e#x.) if the storage should be\nobtained on a doubleword boundary and 2 (set symbol\n:#x.&amp.ES_PAGE_BOUNDARY:e#x.) if it should be obtained on a page\nboundary.\n:pLt.location\n:pLd.specifies whether the storage to obtained must be allocated from\nbelow the 16-megabyte line (:#x.:hp2.BELOW:ehp2.:e#x.) or if it may be\nobtained from any address (:#x.:hp2.ANY:ehp2.:e#x.). The default value\nfor the macro is :#x.:hp2.ANY:ehp2.:e#x.. There is no default value\nfor the\n:#x.CALLX:e#x. form of invoking this macro, which requires that\n:#xi.location:e#xi. indicate a fullword containing a 1 (set\nsymbol\n:#x.&amp.ES_LOCATION_ANY:e#x.) if the storage may be allocated at any\nlocation and a 2 (set symbol :#x.&amp.ES_LOCATION_BELOW:e#x.) if the\nstorage must be allocated below the 16-megabyte line.\n:pLt.address\n:pLd.specifies the address of a fullword into which the\n:#x.ES_OBTAIN_STORAGE:e#x. function will store the address of the\nnewly obtained storage.  This address will only be updated if the\nrequest for storage was successful.\n:eplist.\n:fh3.Example\n:p.\nThe following macro instruction obtains 256 bytes of storage and saves\nits address in :#x.PWA_MSGPTR:e#x..\n:xmp.\n  ES_OBTAIN_STORAGE ID=ES,SIZE=256,ADDRESS=PWA_MSGPTR\n:exmp.\nAssuming that :#x.ID=ES:e#x. has established :#x.ES_EPA:e#x. and\n:#x.ES_TOKEN:e#x. as default values for the\n:#xi.es_epa:e#xi. and\n:#xi.es_token:e#xi. parameters, respectively, this\ninstruction could also have been written as\n:xmp.\n  CALLX ES_EPA,(ES_TOKEN,&ES_OBTAIN_STORAGE,0,&ES_DOUBLEWORD_BOUNDARY,+\n              &ES_LOCATION_ANY,256,PWA_MSGPTR)\n:exmp.\n:efunc.\n.**********************************************************************\n:func name='ES_RELEASE_STORAGE'.Release a Block of Main Storage\n.**********************************************************************\n:p.\nThe :#x.ES_RELEASE_STORAGE:e#x. function is used to release storage\nobtained by the :#x.ES_OBTAIN_STORAGE:e#x. function. This storage is\nreleased by issuing an MVS RC-form :#x.FREEMAIN:e#x. SVC.\n:mac.\nES_RELEASE_STORAGE ID=:hp1.id_name:ehp1. &cont.\n&lbt.,SPEPA=:hp1.es_epa:ehp1.&rbt. &cont.\n&lbt.,SPTOKEN=:hp1.es_token:ehp1.&rbt.\n  &lbt.,SUBPOOL=&lbr.:hp1.subpool:ehp1. &cont.\n| :hp2.:us.0:eus.:ehp2.&rbr.&rbt.\n   ,SIZE=:hp1.size:ehp1.\n   ,ADDRESS=:hp1.address:ehp1.\n:emac.\n:callx.\nCALLX &cont.\n:hp1.es_epa:ehp1.,(:hp1.es_token:ehp1.,&amp.ES_RELEASE_STORAGE,&cont.\n:hp1.size:ehp1.,:hp1.subpool:ehp1.,:hp1.address:ehp1.)\n:ecallx.\n.*****\n:plist.\n:pLt.size\n:pLd.a fullword containing the\nsize in bytes of the storage area to be released.\n:pLt.subpool\n:pLd.a fullword containing a binary 0 - 127 for the subpool of the\nstorage.\n:pLt.address\n:pLd.specifies the address of a fullword that contains the address of\nahe storage area to be released.\n:eplist.\n:efunc.\n.**********************************************************************\n.se temp = 'Save Debugging Information'\n:func name='ES_SAVE_DEBUG_INFO'.&temp.\n.**********************************************************************\n:p.\nThe :#x.ES_SAVE_DEBUG_INFO:e#x. function stores information in the\ndebugging area maintained by Environment Support.  This information\nmay then be displayed by any service processor.\n:mac.\nES_SAVE_DEBUG_INFO ID=:hp1.id_name:ehp1. &cont.\n&lbt.,SPEPA=:hp1.es_epa:ehp1.&rbt. &cont.\n&lbt.,SPTOKEN=:hp1.es_token:ehp1.&rbt.\n\n:#x.Select one of:e#x.\n\n   ,GDI=:hp1.gdi:ehp1.\n:#x.or:e#x.\n   ,TEXT=&lbr.:hp1.text:ehp1. | &cont.\n:hp2.(:hp1.text:ehp1.,:hp1.length:ehp1.):ehp2.&rbr.&cont.\n&lbt.,LABEL=&lbr.:hp1.label:ehp1. | &cont.\n:hp2.(:hp1.label:ehp1.,:hp1.length:ehp1.):ehp2.&rbr.&rbt.\n:#x.or:e#x.\n   ,HEX=&lbr.:hp1.hex:ehp1. | &cont.\n:hp2.(:hp1.hex:ehp1.,:hp1.length:ehp1.):ehp2.&rbr.&cont.\n&lbt.,LABEL=&lbr.:hp1.label:ehp1. | &cont.\n:hp2.(:hp1.label:ehp1.,:hp1.length:ehp1.):ehp2.&rbr.&rbt.\n:emac.\n:callx.\nCALLX :hp1.es_epa:ehp1.,(:hp1.es_token:ehp1.,&amp.ES_SAVE_DEBUG_INFO,\n\n:#x.Select one of:e#x.\n\n              &amp.ES_DEBUG_ID_GDI,:hp1.gdi:ehp1.)\n:#x.or:e#x.\n              &amp.ES_DEBUG_ID_TEXT,:hp1.text:ehp1.&cont.\n,&lbt.:hp1.length:ehp1.&rbt.,&lbt.:hp1.label:ehp1.&rbt.&cont.\n,&lbt.:hp1.length:ehp1.&rbt.)\n:#x.or:e#x.\n              &amp.ES_DEBUG_ID_HEX,:hp1.hex:ehp1.&cont.\n,&lbt.:hp1.length:ehp1.&rbt.,&lbt.:hp1.label:ehp1.&rbt.&cont.\n,&lbt.:hp1.length:ehp1.&rbt.)\n:ecallx.\n.*****\n:plist.\n:pLt.gdi\n:pLd.general debug information.\nMacro SRVGSI will map this control block.\n:pLt.text\n:pLd.text to be saved in debug area. If :#xi.length:e#xi. is\nnot specified, the first two bytes of the storage referenced by\n:#xi.text:e#xi. must contain the length of the text.\n:pLt.hex\n:pLd.hex data to be saved in debug area. If :#xi.length:e#xi.\nis not specified, the first two bytes of the storage referenced by\n:#xi.text:e#xi. must contain the length of the text.\n:pLt.length\n:pLd.optional fullword length of the text or hex data to be saved in the\ndebug area.\n:eplist.\n:efunc.\n.**********************************************************************\n.se temp = 'Begin an Environment Support Session'\n:func name='ES_START' id=esstart.&temp.\n.**********************************************************************\n:p.\nThe :#x.ES_START:e#x. function obtains and initializes a new\nEnvironment Support Vector (ESV) and sets up Environment Support's\ninternal working storage.  A unique session identifier is returned in\nthe\n:#xi.es_token:e#xi. parameter, which must be specified when\ninvoking any Environment Support function.  The address of the new\n:#x.ESV:e#x. is returned to the application program via the\n:#xi.es_epa:e#xi. parameter. If the application provides a\nModule Name Table (:#x.MNT:e#x.), that will be retained within\nenvironment support for use by the :#x.ES_LOAD_MODULE:e#x. and\n:#x.ES_UNLOAD_MODULE:e#x. functions.\n:mac.\nES_START ID=:hp1.id_name:ehp1. &cont.\n&lbt.,SPEPA=:hp1.es_epa:ehp1.&rbt. &cont.\n&lbt.,SPTOKEN=:hp1.es_token:ehp1.&rbt.\n  &lbt.,ESVA=:hp1.esva:ehp1.&rbt.\n  &lbt.,MNT=:hp1.mnt_address:ehp1.&rbt.\n  &lbt.,EXITINFO=:hp1.exit_info:ehp1.&rbt.\n:emac.\n:callx.\nCALLX :hp1.es_epa:ehp1.,(:hp1.es_token:ehp1.,&amp.ES_START,&cont.\n:hp1.esva:ehp1.&lbt.,:hp1.mnt_address:ehp1.&rbt.&cont.\n&lbt.,:hp1.exit_info:ehp1.&rbt.)\n:ecallx.\n.*****\n:plist.\n:pLt.mnt_address\n:pLd.&lbt.optional&rbt. specifies the label of a fullword in storage\nthat contains the address of an application Module Name Table.\n:pLt.exit_info\n:pLd.&lbt.optional&rbt. specifies the label of a fullword in storage\nwhose :hp1.address:ehp1. will be passed to all Environment Support\nexit modules as the second parameter.\n:eplist\n:efunc.\n.**********************************************************************\n.se temp = 'Stop an Environment Support session'\n:func name='ES_TERMINATE' id=esterm.&temp.\n.**********************************************************************\n:p.\nThe :#x.ES_TERMINATE:e#x. function shuts-down Environment Support. It\nunloads all modules that have been loaded by the\n:#x.ES_LOAD_MODULE:e#x.  function and are still in storage, frees the\nstorage occupied by the Environment Support Vector, and releases\nEnvironment Support's working storage.  Because :#x.ES_TERMINATE:e#x.\nfrees the :#x.ESV:e#x., which is used by all service processors, it\nshould be issued only after all other service processors have been\nterminated.\n:mac.\nES_TERMINATE ID=:hp1.id_name:ehp1. &cont.\n&lbt.,SPEPA=:hp1.es_epa:ehp1.&rbt. &cont.\n&lbt.,SPTOKEN=:hp1.es_token:ehp1.&rbt.\n:emac.\n:callx.\nCALLX :hp1.es_epa:ehp1.,(:hp1.es_epa:ehp1.,&amp.TERMINATE)\n:ecallx.\n:efunc.\n.**********************************************************************\n:func name='ES_UNLOAD_MODULE'.Remove a Module from Main Storage\n.**********************************************************************\n:p.\nThe :#x.ES_UNLOAD_MODULE:e#x. function is used to remove a module from\nstorage.  If the module name is in the application Module Name Table\n(:#x.MNT:e#x.) or the standard :#x.MNT:e#x. and the table entry\ncontains a nonzero entry point address, :#x.ES_LOAD_MODULE:e#x. simply\nreturns to the caller; otherwise, the request is satisfied by issuing an\nMVS :#x.DELETE:e#x. macro instruction.\n:mac.\nES_UNLOAD_MODULE ID=:hp1.id_name:ehp1. &cont.\n&lbt.,SPEPA=:hp1.es_epa:ehp1.&rbt. &cont.\n&lbt.,SPTOKEN=:hp1.es_token:ehp1.&rbt.\n  &lbt.,SPID=:hp1.spid_name:ehp1.&rbt.\n  &lbt.,EPNAME=&lbr.:hp1.epname:ehp1.&rbt.\n  &lbt.,EPA=:hp1.epa:ehp1.&rbt.\n:emac.\n:callx.\nCALLX &cont.\n:hp1.es_epa:ehp1.,(:hp1.es_token:ehp1.,&amp.ES_UNLOAD_MODULE,&cont.\n:hp1.epname:ehp1.)\n:ecallx.\n.*****\n:plist.\n:pLt.spid_name\n:pLd.specifies the name of a service processor identifier created by any\n:#x.xx_ID:e#x. macro, which will be used by the\n:#x.ES_UNLOAD_MODULE:e#x. macro to automatically obtain values\nfor :#xi.epname:e#xi. and :#xi.epa:e#xi..\n:pLt.epname\n:pLd.an eight byte field containing the name of the entry point to be\nunloaded.\n:pLt.epa\n:pLd.the field containing the module's entry point address. This can\nonly be specified on the macro form of :#x.ES_UNLOAD_MODULE:e#x. and\nwill cause the field to be set to zeros.\n:eplist.\n:efunc.\n.*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SRVDOCFI": {"ttr": 12042, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x02\\x00\\x00V\\x01\\x11)\\x9f\\x01\\x11)\\x9f\\t'\\x02t\\x02t\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@\"", "ispf": {"version": "02.00", "flags": 0, "createdate": "2011-10-26T00:00:00", "modifydate": "2011-10-26T09:27:56", "lines": 628, "newlines": 628, "modlines": 0, "user": "CLEMSON"}, "text": ".*SRVFILE SRVSMS SRVXSID SRVPDF****************************************\n.*                                                                    *\n.*                    Chapter. File Handlers                          *\n.*                                                                    *\n.**********************************************************************\n:h1 id=srvfi.File Handlers\n:p.\nThe File Handlers provide a generalized way to read and write\nsequential files.\nThe file handlers all work with the\nsame parameters and produce the same sets of return codes.\n:p.\nThe File Handlers are each environment-dependent, but may be used with\nany Environment Support service processor.\n.*--------------------------------------------------------------------*\n:h2.The Standard File Handler\n.*--------------------------------------------------------------------*\nThe standard, or OS, file handler can be used to read and write\nsequential files, in the form of a physical sequential file or an\nindividual PDS member.  The OS file handler can also be made to\nconditionally create, replace, or append to a sequential or partitioned\ndataset, or a member of an existing PDS.\n.*\n:p.If used to create a file, the OS file handler will translate\ngeneralized file characteristic information (estimated number of\nrecords, average and maximum record length, etc) into information\nneeded by MVS dynamic allocation to create the disk dataset.  In\naddition, the file creation process may be provided with the\n:#x.UNIT:e#x.,\n:#x.VOLUME:e#x. and/or :#x.DIRBLKS:e#x. parameters, which can be set\nup using the :#x.FI_OS_INFO:e#x. macro.  An optimum blocksize is\ncalculated internally based on the type of device the file is being\ncreated on.\n.*\n:p.When creating a dataset, the OS file handler has to\ndetermine the optimum blocksize before calling MVS dynamic allocation.\nThe OS file handler currently allocates the new dataset in blocks,\nand attempts to fit 6 blocks per track.\n(For example, a fixed-length file with 80-byte records would cause a\nblocksize of 7440 to be selected on a 3380 disk device.)\nIf a specific volume is requested via the :#x.FI_OS_INFO:e#x. macro,\nthe OS file handler will determine what type of device the volume is\nmounted on, and calculate an optimum blocksize based on that device\ntype.  If a volume is not specified, the device type of the MVS\nsystem's IPL volume is used.\n.*--------------------------------------------------------------------*\n:h2.The Source Management System File Handler\n.*--------------------------------------------------------------------*\n.*--------------------------------------------------------------------*\n:h2.The ISPF/PDF File Handler\n.*--------------------------------------------------------------------*\n.*--------------------------------------------------------------------*\n:h2.The XsubID File Handler\n.*--------------------------------------------------------------------*\n:p.\n\n\n\n\n\n\n\n.*--------------------------------------------------------------------*\n:h2.Preparing to use a File Handler\n.*--------------------------------------------------------------------*\n.*--------------------------------------------------------------------*\n:h3.Obtaining File Handler Symbols &amp. Macros\n.*--------------------------------------------------------------------*\n:p.\nThe File Handler symbols and interface macros can be found in the\nassembler copy member :#x.SRVFIMAC:e#x.. This member contains symbols\nnaming the File Handler's load module, function codes, return codes, and\nparameter values.  It also contains macros for using all of the File\nHandler's functions.    The following statement or its equivalent should\nappear at the beginning of any program that uses the string handler:\n:xmp.\n   COPY SRVFIMAC      Obtain the File Handler symbols & macros.\n:exmp.\n.*--------------------------------------------------------------------*\n:h3.Establishing File Handler Defaults\n.*--------------------------------------------------------------------*\nSome parameters are general to the strihg handler and not specific to\nany function.  These parameters include its load module name\n(:#xi.fi_epname:e#xi.), entry point address\n(:#xi.fi_epa:e#xi.), and token value\n(:#xi.fi_token:e#xi.). The :#x.FI_ID:e#x. macro (see\n:hdref refid=fiid.) can be used to establish defaults for these\nparameters and associate them with a unique service processor\nidentifier.  The identifier may then be supplied on any File Handler\nmacro instruction to refer to the default parameter values.\n.*--------------------------------------------------------------------*\n:h3.Identifying the File Handler\n.*--------------------------------------------------------------------*\n:p.\nThe File Handler service processor resides in the load module named by\nthe following symbol definition in copy member :#x.SRVFIMAC:e#x.:\n:xmp.\n&FI_OS_FILE_HANDLER  SETC  '''SRVFIOS  '''\n:exmp.\nThis symbolic name should be used as the service processor entry point\nname for the File Handler as shown in the following :#x.FI_ID:e#x.\nmacro instruction.\n:xmp.\nFI_ID ID=FI,SPEPNAME=&FI_OS_FILE_HANDLER  Set File Handler Defaults.\n:exmp.\n.*--------------------------------------------------------------------*\n:h3.Loading the File Handler\n.*--------------------------------------------------------------------*\n:p.\nThe recommended method for loading the File Handler is through\nEnvironment Support's :#x.ES_LOAD_MODULE:e#x. function, as shown in\nthe following example:\n:xmp.\nES_LOAD_MODULE ID=ES,SPID=FI            Load the File Handler\n:exmp.\n.*--------------------------------------------------------------------*\n:h2.Common Parameters\n.*--------------------------------------------------------------------*\n:p.\nSeveral parameters are common to all File Handler function calls.\nThese parameters are listed below:\n.*****\n:plist.\n:pLt.id_name\n:pLd.specifies the name of a service processor identifier created by the\n:#x.FI_ID:e#x. macro which will be used by all other function invocation\nmacros to automatically obtain values for :#xi.fi_epa:e#xi. and\n:#xi.fi_token:e#xi.. This parameter is required unless both\n:#xi.fi_epa:e#xi. and :#xi.fi_token:e#xi. are specified.\n:pLt.fi_epa\n:pLd.a fullword in storage containing the entry point address of the\nString Handler service processor.  The value specified by\n:#xi.fi_epa:e#xi.  overrides any value obtained from\n:#x.ID=:e#x.:#xi.id_name:e#xi..\n:pLt.fi_token\n:pLd.specifies the label of a fullword in storage that contains the\nvalue (to be) returned by :#x.FI_START:e#x. for the\n:#xi.fi_token:e#xi. parameter.  The value specified by\n:#xi.fi_token:e#xi. overrides any value obtained from\n:#x.ID=:e#x.:#xi.id_name:e#xi..\n:eplist.\n.*--------------------------------------------------------------------*\n:h2.Return Codes\n.*--------------------------------------------------------------------*\n:p.\nMany return codes can be returned from each function.  In the function\ndescriptions later in this chapter, the most common return codes\nreturned by the particular function are documented.  The following\nis a complete list of File Handler return codes.\n:rclist.\n:rcn.0\n:rct.FI_SUCCESS\n:rcd.The File Handler\nfunction has completed successfully.\n:rcn.1:rct.FI_END_OF_FILE\n:rcd.End of File has been reached.\n:rcn.2:rct.FI_WARNING\n:rcd.Non-terminating error occurred.\n:rcn.3:rct.FI_ERROR\n:rcd.Terminating error occurred.\n:rcn.4:rct.FI_SEVERE\n:rcd.A severe terminating error.\n:rcn.5:rct.FI_INVALID_SYNTAX\n:rcd.Unsupported filename syntax.  The code is returned by the\n:#x.FI_START:e#x. function only; it is used when file-servers are\nbeing cascaded to indicate that the file name is not for the type of\nfile supported by that particular file server and that the next server\nshould be tried. If file-servers are not being cascaded or if the last\none has been tried, :#x.FI_INVALID_SYNTAX:e#x. should be treated in\nthe same manner as :#x.FI_ERROR:e#x..\n:rcn.6:rct.FI_INVALID_FILEID\n:rcd.A bad file-token was used.\n:erclist.\n.*--------------------------------------------------------------------*\n:h2.File Handler Service Processor Functions\n.*--------------------------------------------------------------------*\n:p.\nThe remaining sections of this chapter describe all functions provided\nby the File Handler service processor, arranged in alphabetical order.\nEach function's description begins on a new page, and the name of the\nfunction being described appears in the top outside corner of every\npage.\n.**********************************************************************\n:func name='FI_CLOSE'.Close the File Being Processed\n.**********************************************************************\n:p.\nThe :#x.FI_CLOSE:e#x. function closes the file currently being processed\nbut does not deallocate from it.  This function is normally not needed\nsince :#x.FI_TERMINATE:e#x. will always close the file for you.  However,\nif you need to read the file again from the start and do not want to go\nthrough allocation again, this function may be used.\n:mac.\nFI_CLOSE ID=:hp1.id_name:ehp1. &cont.\n&lbt.,SPEPA=:hp1.fi_epa:ehp1.&rbt. &cont.\n&lbt.,SPTOKEN=:hp1.fi_token:ehp1.&rbt.\n:emac.\n:callx.\nCALLX :hp1.fi_epa:ehp1.,(:hp1.fi_token:ehp1.,&amp.FI_CLOSE)\n:ecallx.\n.**********************************************************************\n:func name='FI_GET_INFO'.Obtain Information About a File\n.**********************************************************************\n:p.\nThe :#x.FI_GET_INFO:e#x. function retrieves information about the file\nidentified by the :#xi.fi_token:e#xi. parameter. Information\nthat can be obtained through this function includes the most recent\nmessage issued, the file's name, its logical record length, and its\nrecord format.\n:mac.\nFI_GET_INFO ID=:hp1.id_name:ehp1. &cont.\n&lbt.,SPEPA=:hp1.fi_epa:ehp1.&rbt. &cont.\n&lbt.,SPTOKEN=:hp1.fi_token:ehp1.&rbt.\n  &lbr.\n     ,NAME=&lbr.(:hp1.name:ehp1.,:hp1.length:ehp1.) &cont.\n| :hp1.name:ehp1.&rbr.,NAMELEN=:hp1.namelen:ehp1.\n    |,MSG=&lbr.(:hp1.msg:ehp1.,:hp1.length:ehp1.) &cont.\n| :hp1.msg:ehp1.&rbr.,MSGLEN=:hp1.msglen:ehp1.\n    |,LRECL=:hp1.lrecl:ehp1.\n    |,RECFM=:hp1.recfm:ehp1.\n    |,IDSTRING=:hp1.idstring:ehp1.\n  &rbr.\n:emac.\n:callx.\nCALLX :hp1.fi_epa:ehp1.,(:hp1.fi_token:ehp1.,&amp.FI_GET_INFO,\n             &lbr.\n              &amp.FI_GI_NAME,:hp1.name:ehp1.,:hp1.length:ehp1.,&cont.\n:hp1.namelen:ehp1.\n             |&amp.FI_GI_MSG,:hp1.msg:ehp1.,:hp1.length:ehp1.,&cont.\n:hp1.msglen:ehp1.\n             |&amp.FI_GI_LRECL,:hp1.lrecl:ehp1.\n             |&amp.FI_GI_RECFM,:hp1.recfm:ehp1.\n             |&amp.FI_GI_IDSTRING,:hp1.idstring:ehp1.\n             &rbr.)\n:ecallx.\n.*****\n:plist.\n:pLt.name\n.br\n:#xi.length:e#xi.\n.br\n:#xi.namelen:e#xi.\n:pLd.These three parameters specify an area in which to return the\nname of the file being processed, a fullword containing the length\nof the area, and a fullword into which the length of the file's\nname will be returned.\n:pLt.msg\n.br\n:#xi.length:e#xi.\n.br\n:#xi.msglen:e#xi.\n:pLd.These three parameters specify an area in which to return the\nmost recently created File Handler message, a fullword containing the\nlength of the area, and a fullword into which the length of the message\nwill be returned.\n:pLt.lrecl\n:pLd.A halfword into which the logical record length of the file being\nprocessed will be returned.\n:pLt.recfm\n:pLd.An eight (8) character area into which the record format of the\nfile being processed will be returned.\n:pLt.idstring\n:pLd.An eight (8) character area into which a file-identifier string\nwill be returned.  For members of a partitioned data set or other\ndirectory, the member name will be used.  For sequential data sets,\none of the data set's qualifiers will be used.\n:eplist.\n.*****\n:efunc.\n.**********************************************************************\n:func name='FI_ID' id=fiid.Establish Default File Handler Values\n.**********************************************************************\n:p.The :#x.FI_ID:e#x. macro is used to establish default values for\nuse by other File Handler macros, which may access those values through\na unique identifier, :#xi.id_name:e#xi., specified by the\nuser. When allowed to generate default values, this macro will create\nProgram Work Area (PWA) storage for :#xi.fi_epa:e#xi. and\n:#xi.fi_token:e#xi..             These values, whether generated by the\nmacro or provided by the user, are accessable from all other File\nHandler macros via the\n:#x.ID=:e#x.:#xi.id_name:e#xi. parameter.\n:mac.\nFI_ID ID=:hp1.id_name:ehp1.\n  &lbt.,SPEPNAME=:hp1.fi_epname:ehp1.&rbt.\n  &lbt.,SPEPA=:hp1.fi_epa:ehp1.&rbt.\n  &lbt.,SPTOKEN=:hp1.fi_token:ehp1.&rbt.\n  &lbt.,ESID=:hp1.esid_name:ehp1.&rbt.\n  &lbt.,ESVA=:hp1.esva:ehp1.&rbt.\n:emac.\n.*****\n:plist.\n:pLt.id_name\n:pLd.the identifier to assign to the service processor identifier being\nestablished.  This name must be unique for all service processor\nidentifier's.\n:pLt.fi_epname\n:pLd.the entry point name of the File Handler service processor module\nthat is being used.\n:pLt.fi_epa\n:pLd.specifies the label of a fullword in storage that will contain the\nentry point address of the File Handler.\n:pLt.fi_token\n:pLd.specifies the label of a fullword in storage that will contain the\ntoken assigned by the :#x.FI_START:e#x. function of the File Handler.\n:pLt.esid_name\n:pLd.the name of a service processor identifier, created by the\n:#x.ES_ID:e#x.  macro, which will be used by the :#x.FI_ID:e#x. macro to\nautomatically obtain the value for :#x.esv:e#x. (see below).\n:pLt.esva\n:pLd.specifies the label of a fullword in storage that contains (or\nwill contain) the address of the Environment Support Vector\n(:#x.ESV:e#x.) created by the :#x.ES_START:e#x. function.\n:eplist.\n:fh3.Example 1\n:p.\n:xmp.\nFI_ID     ID=FI_SMS,SPEPNAME=&SMS_FILE_HANDLER\n:exmp.\n:efunc.\n.**********************************************************************\n:func name='FI_OPEN'.Open the File For Processing\n.**********************************************************************\n:p.\nThe :#x.FI_OPEN:e#x. function opens the file currently allocated to and\nprepares for processing.  This will be done automatically by the\n:#x.FI_START:e#x. function unless option :#xb.MANUALOPEN:e#xb. is\nspecified.  If an application needs to allocate to a file once and then\nrepeatedly open and close the file, this function may be used in\nconjunction with the :#xb.MANUALOPEN:e#xb. option.\n:mac.\nFI_OPEN ID=:hp1.id_name:ehp1. &cont.\n&lbt.,SPEPA=:hp1.fi_epa:ehp1.&rbt. &cont.\n&lbt.,SPTOKEN=:hp1.fi_token:ehp1.&rbt.\n:emac.\n:callx.\nCALLX :hp1.fi_epa:ehp1.,(:hp1.fi_token:ehp1.,&amp.FI_OPEN)\n:ecallx.\n.**********************************************************************\n:func name='FI_OS_INFO'.Provide OS-Specific Information About A File\n.**********************************************************************\n:p.\nThe :#x.FI_OS_INFO:e#x. macro is used to build a list of those\nparameters\nunique to dataset creation using MVS dynamic allocation.\n.*\n:p.Unlike the other File Handler macros, :#x.FI_OS_INFO:e#x. does not\ngenerate a call to a service processor, or establish or use service\nprocessor defaults.  Instead, :#x.FI_OS_INFO:e#x. generates a parameter\nlist and constructs dynamic allocation textunits in the caller's\nprogram workarea: this list, in turn, is passed to :#x.FI_START:e#x.\nusing the :#x.INFO:e#x. keyword.\n.*\n:p.There is no CALLX equivalent of the :#x.FI_OS_INFO:e#x. macro.\n.*\n:mac.\nFI_OS_INFO  PL=:hp1.parmlist_address:ehp1.\n          &lbt.,DIRBLKS=:hp1.PDS_dirblks:ehp1.&rbt.\n          &lbt.,UNIT=:hp1.unit_name:ehp1.&rbt.\n          &lbt.,VOLUME=:hp1.volume_ID:ehp1.&rbt.\n          &lbt.,FREE=:hp1.free_value:ehp1.&rbt.\n          &lbt.,SPIN=:hp1.spin_value:ehp1.&rbt.\n          &lbt.,SYSOUT=:hp1.sysout_class:ehp1.&rbt.\n          &lbt.,DS=:hp1.storage_area:ehp1.&rbt.\n:emac.\n.*****\n:plist.\n:pLt.PDS_dirblks\n:pLd.Specifies the number of PDS directory blocks to be used when\ncreating a partitioned dataset.  If not specified, the default is 10.\n:pLt.unit_name\n:pLd.Specifies the MVS unit name to be used when creating a dataset.\nIf not specified, the default is :hp1.SYSDA:ehp1..\n:pLt.volume\n:pLd.Specifies the volume serial number where the OS File Handler\nshould create a dataset.  There is no default if :#x.volume:e#x. is not\nspecified, which will cause the dataset to be created on an eligible\ndisk volume mounted as :hp1.storage:ehp1..\n:pLt.free_value\n:pLd.Keyword :hp2.CLOSE:ehp2. or :hp2.END:ehp2., specifying that the\nfile should be freed (unallocated) by the system when it is closed or\nat the end of the jobstep, respectively.\n:pLt.spin_value\n:pLd.Keyword :hp2.UNALLOC:ehp2. or :hp2.NO:ehp2., specifying that the\nfile should be release for printing by the system when it is unallocated\nor at the end of the job, respectively.\n:note.When SPIN is used, the corresponding FI_START call should\nspecify OPTIONS=(SYSOUT).\n:pLt.sysout_class\n:pLd.specifies that this is a sysout file and provides the sysout class\nto use.  A sysout class of '*' specifies that the system default sysout\nclass should be used.\n:note.When SYSOUT is used, the corresponding FI_START call should\nspecify OPTIONS=(SYSOUT).\n:pLt.parmlist_address\n:pLd.Provides a tag that :#x.FI_OS_INFO:e#x. will generate when creating\nits parameter list.  This tag should be specified on the associated\n:#x.FI_START:e#x. macro.  This is the only required parameter on the\n:#x.FI_OS_INOF:e#x. macro.\n:pLt.storage_area\n:pLd.Instructs :#x.FI_OS_INFO:e#x. to construct its parameter list in\nthe program's :hp1.PWA:ehp1. or :hp1.SWA:ehp1..  The default is for\n:#x.FI_OS_INFO:e#x. to construct its parameters in the storage area\nlocal to the block from which it was called.\n:eplist.\n.*****\n:efunc.\n.**********************************************************************\n:func name='FI_READLINE'.Read the next Sequential Line from a File\n.**********************************************************************\n:p.\nThe :#x.FI_READLINE:e#x. function returns the next sequential input\nline of the file specified by the :#xi.fi_token:e#xi.\nparameter. The file must have been opened with the\n:#x.INPUT_SEQUENTIAL:e#x. access value.\n:mac.\nFI_READLINE ID=:hp1.id_name:ehp1. &cont.\n&lbt.,SPEPA=:hp1.fi_epa:ehp1.&rbt. &cont.\n&lbt.,SPTOKEN=:hp1.fi_token:ehp1.&rbt.\n   ,LINE=&lbr.:hp1.line:ehp1. &cont.\n| (:hp1.line:ehp1.,:hp1.length:ehp1.)&rbr.\n   ,RESULTLEN=:hp1.result_len:ehp1.\n:emac.\n:callx.\nCALLX :hp1.fi_epa:ehp1.,(:hp1.fi_token:ehp1.,&amp.FI_READLINE,&cont.\n:hp1.line:ehp1.,:hp1.length:ehp1.,:hp1.result_len:ehp1.)\n:ecallx.\n.*****\n:plist.\n:pLt.line\n:pLd.Provides the address of an area in storage where\n:#x.FI_READLINE:e#x. should return the next line of input.\n:pLt.length\n:pLd.Provides a fullword length of :#x.line:e#x..\nfile.\n:pLt.resultlen\n:pLd.Provides a fullword in storage where :#x.FI_READLINE:e#x. will\nreturn the length of the line returned.\n:eplist.\n.*****\n:efunc.\n.**********************************************************************\n:func name='FI_START'.Allocate to and Open a File\n.**********************************************************************\n:p.\nThe :#x.FI_START:e#x. function locates and opens the file named by\n:#xi.file:e#xi., and prepares to access it in the manner\nspecified in the :#xi.OPTIONS:e#xi. parameter. Currently,\nsequential input is supported for all file handlers, and sequential\noutput is supported by the OS file handler.\nOnce the file has been opened, it is\nready for processing.\n:mac.\nFI_START ID=:hp1.id_name:ehp1. &cont.\n&lbt.,SPEPA=:hp1.fi_epa:ehp1.&rbt. &cont.\n&lbt.,SPTOKEN=:hp1.fi_token:ehp1.&rbt.\n  &lbt.,ESVA=:hp1.esva:ehp1.&rbt.\n   ,FILE=&lbr.:hp1.file:ehp1. | &cont.\n:hp2.(:hp1.file:ehp1.,:hp1.length:ehp1.):ehp2.&rbr.\n  &lbt.,INFO=:hp1.info:ehp1.&rbt.\n  &lbt.,OPTIONS=(:hp1.option_list:ehp1.)&rbt.\n  &lbt.,RECORDLENGTH=:hp1.average:ehp1. | &cont.\n:hp2.(:hp1.average,maximum:ehp1.):ehp2.&rbt.\n  &lbt.,FILESIZE=:hp1.initial:ehp1. | &cont.\n:hp2.(:hp1.initial,increment:ehp1.):ehp2.&rbt.\n:emac.\n:callx.\nCALLX :hp1.fi_epa:ehp1.,(:hp1.fi_token:ehp1.,&amp.FI_START,&cont.\n:hp1.esva:ehp1.,:hp1.info:ehp1.,&cont.\n:hp1.file:ehp1.,:hp1.length:ehp1.,:hp1.optionbyte:ehp1.,\n              :hp1.avgreclen:ehp1.,&cont.\n:hp1.maxreclen:ehp1.,:hp1.initialsize:ehp1.,&cont.\n:hp1.increment:ehp1.&rbt.)\n:ecallx.\n.*****\n:plist.\n:pLt.file\n:pLd.specifies the label of an area in storage containing the name of\nthe file to be opened.  The file name must follow standard convention\nfor files of its type.\n:pLt.length\n:pLd.specifies the label of a fullword in storage that contains a signed\nbinary integer equal to the length of the file name specified by\n:#xi.file:e#xi.\n:pLt.info\n:pLd.Specifies the label of a fullword in storage containing a value\nwhose meaning may be different for each file handler service processor.\nIn the case of the OS file handler, the :#x.INFO:e#x. parameter will\npoint to a parameter list built by the :#x.FI_OS_INFO:e#x. macro.\n:pLt.options\n:pLd.Provides a list of options for handling the file being allocated\nand opened.  The supported options are:\n:ul compact.\n:li.:#xb.FILENAME:e#xb. - The filename provided by the :#x.filename:e#x.\nparameter is an actual filename (for example, an OS dataset name).\n:li.:#xb.FILEID:e#xb. - The filename provided by the :#x.filename:e#x.\nparameter is a file identifier of some kind (for example, a preallocated\nDDNAME if the OS file handler is being used).\n:li.:#xb.FILETEMP:e#xb. - A temporary work file is being created.\n:li.:#xb.SYSOUT:e#xb. - A sysout file is being created.\n:#xb.SYSOUT:e#xb. requires :#xb.OUTPUT:e#xb. and :#xb.NEW:e#xb., and\nimplies :#xb.ISOCC:e#xb..\n:li.:#xb.INPUT:e#xb. - The file is being opened for input processing.\n:li.:#xb.OUTPUT:e#xb. - The file should be opened for output processing.\n:li.:#xb.NEW:e#xb. - The file being opened for :#xb.OUTPUT:e#xb. should\nbe created.  If the file already exists, an error will be returned.\n:#xb.NEW:e#xb. is not valid for files being opened for :#xb.INPUT:e#xb..\n:li.:#xb.REPLACE:e#xb. - The file being opened for :#xb.OUTPUT:e#xb.\nshould be created if it does not already exist.  If it does already\nexist, its contents will be replaced.  :#xb.REPLACE:e#xb. is not valid\nfor files being opened for :#xb.INPUT:e#xb..\n:li.:#xb.EXISTING:e#xb. - The file must already exist.  If the file is\nbeing opened for :#xb.OUTPUT:e#xb., its contents will be replaced.\n:li.:#xb.APPEND:e#xb. - The file being opened for :#xb.OUTPUT:e#xb.\nshould be created if it does not already exist.  If it does already\nexist, all new lines written to it will be appended to the existing\ncontents.  :#xb.APPEND:e#xb. is not valid for files being opened\nfor :#xb.INPUT:e#xb..\n:li.:#xb.ISOCC:e#xb. - Indicates that lines contain ISO carriage control\nin the first byte.  If the file handler supplies the record format for\na file, the ISOCC option will cause the appropriate effect; otherwise,\nthe ISOCC option is ignored.\n:eul.\n:pLt.options\n:pLd.\n:ul.\n:li.:#xb.AUTOOPEN:e#xb. - The file will automatically be opened for\nprocessing by the :#x.FI_START:e#x. function.  This is the default.\nRelated parameter: :#xb.MANUALOPEN:e#xb..\n:li.:#xb.MANUALOPEN:e#xb. - The file will not be automatically opened\nby :#x.FI_START:e#x.: it must be opened using the :#x.FI_OPEN:e#x.\nfunction before any processing may begin.\n:li.:#xb.AUTOFREE:e#xb. - If the :#x.FI_START:e#x. function allocates\na new DDNAME to access the file, it will automatically be unallocated by\nthe corresponding :#x.FI_TERMINATE:e#x. function.  Related parameter:\n:#xb.MANUALFREE:e#xb..\n:li.:#xb.MANUALFREE:e#xb. - The file will not be unallocated by the\n:#x.FI_TERMINATE:e#x. function, regardless of how it was allocated.\n:eul.\n:p.The following :#x.OPTIONS:e#x. parameters are mutually exclusive:\n:ul compact.\n:li.:#xb.FILENAME:e#xb. and :#xb.FILEID:e#xb..\n:li.:#xb.AUTOFREE:e#xb. and :#xb.MANUALFREE:e#xb.\n:li.:#xb.AUTOOPEN:e#xb. and :#xb.MANUALOPEN:e#xb.\n:li.:#xb.INPUT:e#xb. and :#xb.OUTPUT:e#xb.\n:li.:#xb.APPEND:e#xb., :#xb.EXISTING:e#xb., :#xb.NEW:e#xb., and\n:#xb.REPLACE:e#xb.\n:li.:#xb.INPUT:e#xb. and any of :#xb.APPEND:e#xb., :#xb.NEW:e#xb.,\n:#xb.REPLACE:e#xb., or :#xb.SYSOUT:e#xb..\n:eul.\n:pLt.optionvalue\n:pLd.Provides a one-byte value containing the option flag bits that\ncorrespond to the possible :#x.OPTIONS:e#x. values.\nRefer to the macro definition for :#x.FI_START:e#x. in copy member\n:#x.SRVFIMAC:e#x. for the macro variable names that represent the\nindividual options' bit flags.\n:pLt.recordlength\n:pLd.Provides an average and (optionally) a maximum recordlength\nfor a file being created.  During :#x.OUTPUT:e#x. processing, the\nOS file handler uses the\naverage recordlength to determine the amount of disk space\nto request, as well as to choose an optimum blocksize for the\ndisk device being used for the new file.\nFor variable-length records, the maximum recordlength is\nused to set the logical recordlength.\n:pLt.filesize\n:pLd.Provides a primary and (optionally) an incremental number of\nrecords that will be stored in the file being created.  These values\nare used to determine how much disk space to request when a file is\nbeing created.\n:eplist.\n.*****\n:efunc.\n.**********************************************************************\n:func name='FI_TERMINATE'.Close and Release a File\n.**********************************************************************\n:p.\nThe :#x.FI_TERMINATE:e#x. function ends a session with the File\nHandler.  If the file identified by :#xi.fi_token:e#xi. has\nbeen allocated and opened, it will be closed and released.  All\nresources allocated to the session, including buffers, working storage,\nand enqueues, are released back to the system.  This function must be\ninvoked in order to cleanly terminate a File Handler session, even if\nthe :#x.FI_START:e#x. function did not complete successfully.\n:mac.\nFI_TERMINATE ID=:hp1.id_name:ehp1. &cont.\n&lbt.,SPEPA=:hp1.fi_epa:ehp1.&rbt. &cont.\n&lbt.,SPTOKEN=:hp1.fi_token:ehp1.&rbt.\n:emac.\n:callx.\nCALLX :hp1.fi_epa:ehp1.,(:hp1.fi_token:ehp1.,&amp.FI_TERMINATE)\n:ecallx.\n.*****\n:fh3.Example\n:p.\nThe following statement is all that is needed to shut-down a session\nwith the File Handler.\n:xmp.\nFI_TERMINATE ID=DATA           Close and release input data file.\n:exmp.\n:efunc.\n.**********************************************************************\n:func name='FI_WRITELINE'.Add A Sequential Line To a File\n.**********************************************************************\n:p.\nThe :#x.FI_WRITELINE:e#x. function adds the line provided by the caller\nto the file specified on the :#xi.FI_START:e#xi. macro.\nThe file must have been opened with the\n:#x.OUTPUT:e#x. option.\n:mac.\nFI_WRITELINE ID=:hp1.id_name:ehp1. &cont.\n&lbt.,SPEPA=:hp1.fi_epa:ehp1.&rbt. &cont.\n&lbt.,SPTOKEN=:hp1.fi_token:ehp1.&rbt.\n   ,LINE=&lbr.:hp1.line:ehp1. &cont.\n| (:hp1.line:ehp1.,:hp1.length:ehp1.)&rbr.\n:emac.\n:callx.\nCALLX :hp1.fi_epa:ehp1.,(:hp1.fi_token:ehp1.,&amp.FI_WRITELINE,&cont.\n:hp1.line:ehp1.,:hp1.length:ehp1.)\n:ecallx.\n.*****\n:plist.\n:pLt.line\n:pLd.Provides the address of a record in storage to be added to the\nfile being created.\n:pLt.length\n:pLd.Provides a fullword length of the record being added to the\nfile.\n:eplist.\n:efunc.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SRVDOCIM": {"ttr": 12298, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x02\\x00\\x00V\\x01\\x11)\\x9f\\x01\\x11)\\x9f\\t'\\x0b\\x93\\x0b\\x93\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@\"", "ispf": {"version": "02.00", "flags": 0, "createdate": "2011-10-26T00:00:00", "modifydate": "2011-10-26T09:27:56", "lines": 2963, "newlines": 2963, "modlines": 0, "user": "CLEMSON"}, "text": ".*SRVIM****************************************************************\n.*                                                                    *\n.*                    Chapter. &imgr.                                 *\n.*                                                                    *\n.**********************************************************************\n.*--------------------------------------------------------------------*\n.*  Symbols\n.*--------------------------------------------------------------------*\n.se imgr     = 'Item Manager'\n.se imms     = 'Item Manager Managed Storage'\n.se curim    = 'current of Item Manager'\n.se curdesc  = 'current of descriptor'\n.se curityp  = 'current of item type'\n.se ityp     = 'item type'\n.*--------------------------------------------------------------------*\n:h1.&imgr.\n:p.\nThe &imgr. can be used to manage units of data, refered to as items.\nItems can be associated with various data structures, such as, linked\nlists and hash tables.\n:p.\nThe &imgr. and this chapter are still under development.\n:p.\nThe &imgr. is environment independent.\n.*--------------------------------------------------------------------*\n:h3.Obtaining &imgr. Symbols &amp. Macros\n.*--------------------------------------------------------------------*\n:p.\nThe &imgr.'s symbols and interface macros can be found in the\nassembler copy member :#x.SRVIMMAC:e#x.. This member contains symbols\nnaming the &imgr.'s load module, function codes, return codes,\nand parameter values.  It also contains macros for using all of the\n&imgr.'s functions.          The following statement or its equivalent\nshould appear at the beginning of any program that uses the\n&imgr.:\n:xmp.\n   COPY SRVIMMAC      Obtain the &imgr.'s symbols & macros.\n:exmp.\n.*===> if there is more than one load module that implements the\n.*===> service processor's protocol, that should be mentioned here.\n.*--------------------------------------------------------------------*\n:h3.Establishing &imgr. Defaults\n.*--------------------------------------------------------------------*\nSome parameters are general to the &imgr. and not specific to\nany function.  These parameters include its load module name\n(:#xi.IM_epname:e#xi.), entry point address\n(:#xi.IM_epa:e#xi.), and token value\n(:#xi.IM_token:e#xi.). The :#x.IM_ID:e#x. macro (see\n:hdref refid=imid.) can be used to establish defaults for these\nparameters and associate them with a unique service processor\nidentifier.  The identifier may then be supplied on any &imgr.\nmacro instruction to refer to the default parameter values.\n.*--------------------------------------------------------------------*\n:h3.Identifying the &imgr.\n.*--------------------------------------------------------------------*\n:p.\nThe &imgr. service processor resides in the load module named by\nthe following symbol definition in copy member :#x.SRVIMMAC:e#x.:\n:xmp.\n&amp.ITEM_MANAGER     SETC  '''SRVIM  '''\n:exmp.\nThis symbolic name should be used as the service processor entry point\nname for the &imgr. as shown in the following :#x.IM_ID:e#x.\nmacro instruction.\n:xmp.\nIM_ID ID=ST,SPEPNAME=&amp.ITEM_MANAGER     Set &imgr. Defaults.\n:exmp.\n.*--------------------------------------------------------------------*\n:h3.Loading the &imgr.\n.*--------------------------------------------------------------------*\n:p.\nThe recommended method for loading the &imgr. is through\nEnvironment Support's :#x.ES_LOAD_MODULE:e#x. function, as shown in\nthe following example:\n:xmp.\nES_LOAD_MODULE ID=ES,SPID=IM            Load the &imgr.\n:exmp.\n.*--------------------------------------------------------------------*\n:h3.Common Parameters\n.*--------------------------------------------------------------------*\n:p.\nThere are several parameters common to any &imgr. function call.\nThese parameters are listed below:\n.*****\n:plist.\n:pLt.id_name\n:pLd.specifies the name of a service processor identifier created by the\n:#x.IM_ID:e#x. macro which will be used by all other function invocation\nmacros to automatically obtain values for :#xi.im_epa:e#xi. and\n:#xi.im_token:e#xi.. This parameter is required unless both\n:#xi.im_epa:e#xi. and :#xi.im_token:e#xi. are specified.\n:pLt.im_epa\n:pLd.a fullword in storage containing the entry point address of the\n&imgr. service processor.  The value specified by\n:#xi.im_epa:e#xi.  overrides any value obtained from\n:#x.ID=:e#x.:#xi.id_name:e#xi..\n:pLt.im_token\n:pLd.specifies the label of a fullword in storage that contains the\nvalue (to be) returned by :#x.IM_START:e#x. for the\n:#xi.im_token:e#xi. parameter.  The value specified by\n:#xi.im_token:e#xi. overrides any value obtained from\n:#x.ID=:e#x.:#xi.id_name:e#xi..\n:eplist.\n.*--------------------------------------------------------------------*\n:h3.Complete List of &imgr. Return Codes\n.*--------------------------------------------------------------------*\n:p.\nMany return codes can be returned from each function.  In the function\ndescriptions later in this chapter, the most common return codes\nreturned by the particular function, are documented.  The following\nis a complete list of return code.\n:rclist.\n:rcn.0\n:rct.IM_SUCCESS\n:rcd.The function was completely successful.\n:rcn.2\n:rct.IM_INVALID_NUMBER_OF_PARMS\n:rcd.The number of parameters supplied on the call to a function\nis not correct.\n:rcn.3\n:rct.IM_INVALID_FUNCTION\n:rcd.The function code specified on a call to the &imgr. is not valid.\n:rcn.4\n:rct.IM_FUNCTION_UNSUPPORTED_ FOR_CLASS\n:rcd.The function is not supported for the class of the item supplied.\n:rcn.5\n:rct.IM_DIV_START_FAILED\n:rcd.The &imgr. was not able to start the supplied DIV service\nprocessor.\n:rcn.6\n:rct.IM_MEMORY_MANAGER_LOAD_ FAILED\n:rcd.The &imgr. was not able to load the memory manager.\n:rcn.7\n:rct.IM_MEMORY_MANAGER_START_ FAILED\n:rcd.The Memory Manager failed when the &imgr. tried to start it.\n:rcn.8\n:rct.IM_ITEM_STORAGE_NOT_ INITIALIZED\n:rcd.&imms. had not been initialized yet.  See :hdref refid=imstrt.\nfor more information.\n:rcn.9\n:rct.IM_SETUP_ALREADY_COMPLETE\n:rcd.A second call was made to the :#x.IM_INITIALIZE function:e#x..\n:rcn.11\n:rct.IM_INTERNAL_ERROR\n:rcd.Some kind of internal error has occured in the &imgr..  Use\nthe debug area to find out more information.\n:rcn.12\n:rct.IM_INVALID_TOKEN\n:rcd.An invalid token was encountered when processing a function.\n:rcn.14\n:rct.IM_STORAGE_NOT_AVAILABLE\n:rcd.The was not enough memory available in the user region to\nprocess the function.\n:rcn.15\n:rct.IM_DV_OPEN_WINDOW_FAILED\n:rcd.A call to the DV_OPEN_WINDOW function of the associated DIV\nservice processor has ended with a non-zero return code.\n:rcn.16\n:rct.IM_DV_SAVE_FAILED\n:rcd.A call to the DV_SAVE function of the associated DIV\nservice processor has ended with a non-zero return code.\n:rcn.17\n:rct.IM_DV_RESET_FAILED\n:rcd.A call to the DV_RESET function of the associated DIV\nservice processor has ended with a non-zero return code.\n:rcn.18\n:rct.IM_FUNCTION_REQUIRES_DIV\n:rcd.The function envoked requires a DIV service processor EPA to\nbe supplied on the :#x.IM_START:e#x..\n:rcn.19\n:rct.IM_INVALID_ITEM_TYPE_TOKEN\n:rcd.An item type token is not valid.\n:rcn.20\n:rct.IM_ITEM_SIZE_REQUIRED\n:rcd.The itemsize parameter is required on the function call.\n:rcn.21\n:rct.IM_NO_ROOM\n:rcd.There is not more room in &imms. and no more can be obtained.\n:rcn.22\n:rct.IM_OFFSET_SPECIFIED_WHEN_ SIZE_WAS_ZERO\n:rcd.The offset parameter was supplied when the size was zero.\n:rcn.23\n:rct.IM_LENGTH_REQUIRED\n:rcd.The length parameter is required.\n:rcn.24\n:rct.IM_INVALID_OFFSET\n:rcd.An invalid offset was supplied.\n:rcn.25\n:rct.IM_NOT_YET_SUPPORTED\n:rcd.The function of a part of the function is not yet supported.\n:rcn.26\n:rct.IM_MISSING_PARAMETER\n:rcd.A parameter is missing.\n:rcn.27\n:rct.IM_INVALID_ITEM_TYPE\n:rcd.A invalid item type was encountered.\n:rcn.28\n:rct.IM_INVALID_ITEM\n:rcd.A invalid item was encountered.\n:rcn.29\n:rct.IM_INVALID_SIZE\n:rcd.The size supplied was not valid.\n:rcn.30\n:rct.IM_DESCRIPTION_TOO_LONG\n:rcd.The description supplied was not valid.\n:rcn.31\n:rct.IM_LENGTH_PARM_ERROR\n:rcd.The length supplied was not valid.\n:rcn.32\n:rct.IM_#_LINKS_PARM_ERROR\n:rcd.The #links parmameter supplied was not valid.\n:rcn.33\n:rct.IM_LINKS_OFFSET_PARM_ERROR\n:rcd.The linksoffset parmameter supplied was not valid.\n:rcn.34\n:rct.IM_ITEM_CHARACTERISTICS_ CHANGED\n:rcd.The characteristics of the item have changed.  An item's length,\noffset of links and number of links, can not be modified.\n:rcn.36\n:rct.IM_INVALID_RETURN_AREA_SIZE\n:rcd.The return area size supplied is not valid.\n:rcn.37\n:rct.IM_KEY_LENGTH_PARM_ERROR\n:rcd.The keylength parameter supplied is not valid.\n:rcn.38\n:rct.IM_KEY_OFFSET_PARM_ERROR\n:rcd.The keyoffset parameter supplied is not valid.\n:rcn.39\n:rct.IM_INVALID_DESCRIPTOR_TOKEN\n:rcd.The descriptor token parameter supplied is not valid.\n:rcn.40\n:rct.IM_INVALID_ITEM_TOKEN\n:rcd.An item token is not valid.\n:rcn.41\n:rct.IM_CURRENCY_ERROR\n:rcd.The proper currency is not established for the function.\n:rcn.42\n:rct.IM_INVALID_LINK_NUMBER\n:rcd.The link number supplied is not valid.\n:rcn.43\n:rct.IM_LINK_NOT_NULL\n:rcd.A link field is not null that is needed to connect an item to\na structure.\n:rcn.44\n:rct.IM_AT_END\n:rcd.At the end of a structure.  For example, a :#x.IM_OBTAIN_NEXT:e#x.\nwas issued and there were no more items in a list.\n:rcn.45\n:rct.IM_REQUIRES_PRIOR_LINK\n:rcd.This function requires that the structure have prior links.\n:rcn.46\n:rct.IM_REQUIRES_FINAL_LINK\n:rcd.This function requires that the structure have a final link.\n:rcn.47\n:rct.IM_REQUIRES_OWNER_LINK\n:rcd.This function requires that the structure have owner links.\n:rcn.48\n:rct.IM_NOT_FOUND\n:rcd.The item could not be found.\n:rcn.49\n:rct.IM_HEAD_NOT_VALID_FOR_ THIS_DESCRIPTOR\n:rcd.The headtkn is not valid for this descriptor because the heads\nare in the descriptor.\n:rcn.50\n:rct.IM_INVALID_SFD\n:rcd.The Sort Fields Definitions (SFD) is not valid.\n:rcn.51\n:rct.IM_INVALID_SORT_TECHNIQUE\n:rcd.The sort technique supplied is not valid.\n:rcn.52\n:rct.IM_PRTKN_INVALID\n:rcd.PRTKN specified is not valid.\n:rcn.53\n:rct.IM_PRTKN_REQUIRED\n:rcd.PRTKN required if prior links do not exist.\n:rcn.54\n:rct.IM_HEADTKN_INVALID\n:rcd.HEADTKN specified is not valid.\n:rcn.55\n:rct.IM_CURTKN_INVALID\n:rcd.CURTKN specified is not valid.\n:rcn.56\n:rct.IM_ITEMTYPE_MISMATCH\n:rcd.The item type of the item being processed does not match the\nMEMTYPE specified on the create for the corresponding descriptor.\n:erclist.\n.*--------------------------------------------------------------------*\n:h2.&imgr. Service Processor Functions\n.*--------------------------------------------------------------------*\n:p.\nThe remaining sections of this chapter describe all functions provided\nby the &imgr. service processor, arranged in alphabetical order.\nEach function's description begins on a new page, and the name of the\nfunction being described appears in the top outside corner of every\npage.\n.**********************************************************************\n.se temp = 'Add An Item Token to The Token Directory'\n:func id=addtodr name='IM_ADD_TO_DIRECTORY'.&temp.\n.**********************************************************************\n:p.\nThe :#x.IM_ADD_TO_DIRECTORY:e#x. macro is used to add an item token to\nthe Token Directory.  The Token Directory provides a way to symbolically\nremember an item's token.\n:p.\nThis function is not yet implemented.\n.*---------------------------------------------------------------------*\n.* Syntax box for the macro form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:mac.\nIM_ADD_TO_DIRECTORY ID=:hp1.id_name:ehp1. &cont.\n&lbt.,SPEPA=:hp1.im_epa:ehp1.&rbt. &cont.\n&lbt.,SPTOKEN=:hp1.im_token:ehp1.&rbt.\n   ,NAME=&lbr.:hp1.name:ehp1. | &cont.\n(:hp1.name:ehp1.,:hp1.name_length:ehp1.)&rbr.\n   ,TOKEN=:hp1.token:ehp1.\n:emac.\n.*---------------------------------------------------------------------*\n.* Syntax box for the CALLX form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:callx.\nCALLX :hp1.im_epa:ehp1.,(:hp1.im_token:ehp1.,&amp.IM_ADD_TO_DIRECTORY,&c\n:hp1.name_length:ehp1.,:hp1.name:ehp1.,&cont.\n:hp1.token:ehp1.)\n:ecallx.\n.*---------------------------------------------------------------------*\n.* Parameter-list table describing each parameter.\n.*---------------------------------------------------------------------*\n:plist.\n:pLt.name\n:pLd.specifies the label of a string that contains the name to be\nassociated with the token specified with the :#xi.token:e#xi.\nparameter.\n:pLt.name_length\n:pLd.specifies the label of a signed binary integer indicating the\nlength of the string identified by the :#xi.name:e#xi.\nparameter.\n:pLt.token\n:pLd.specifies the label of a fullword of storage that contains the\ntoken of an item.\n:eplist.\n:fh3.Example\n:p.\n:xmp.\nIM_ADD_TO_DIRECTORY ID=IM,NAME=\"MYTOKEN\",TOKEN=TOKEN_TAG\n:exmp.\n:efunc.\n.**********************************************************************\n.se temp = 'Convert a Token to an Address'\n:func id=imcnvtk name='IM_CONVERT_TOKEN_TO_ADDRESS'.&temp.\n.**********************************************************************\n:p.\nThe :#x.IM_CONVERT_TOKEN_TO_ADDRESS:e#x. macro is used to\nconvert a token to its virtual storage address.  To use this macro,\nthe token conversion routine address must be obtained.\nSee :hdref refid=imgetda. to find out how to retrieve this address.\n.*---------------------------------------------------------------------*\n.* Syntax box for the macro form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:mac.\nIM_CONVERT_TOKEN_TO_ADDRESS ID=:hp1.id_name:ehp1. &cont.\n&lbt.,SPTOKEN=:hp1.im_token:ehp1.&rbt.\n  &lbt.,TKNCNVT=:hp1.tkncnvt:ehp1.&rbt.\n   ,ITEMTKN=:hp1.itemtkn:ehp1.\n   ,ITEMADDR=:hp1.itemaddr:ehp1.\n:emac.\n.*---------------------------------------------------------------------*\n.* Syntax box for the CALLX form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:callx.\nNone\n:ecallx.\n.*---------------------------------------------------------------------*\n.* Parameter-list table describing each parameter.\n.*---------------------------------------------------------------------*\n:plist.\n:pLt.tkncnvt\n:pLd.specifies the label of a fullword in storage that contains the\nentry point address of the token conversion routine.\n:pLt.itemtkn\n:pLd.specifies the label of a fullword that contains the token of\nthe item for with a virtual address should be obtained.\n:pLt.itemaddr\n:pLd.specifies the label of a fullword into which will be place the\nvirtual storage address of the time.\n:eplist.\n:fh3.Example\n:p.\nThis instruction will get the virtual storage address of the item\nwhose token is in :#x.A_TOKEN:e#x..\n:xmp.\n         IM_CONVERT_TOKEN_TO_ADDRESS ID=IM,ITEMTKN=A_TOKEN,            +\n               ITEMADDR=THE_ADDRESS\n:exmp.\n:rclist.\n:rcn.12\n:rct.IM_INVALID_TOKEN\n:rcd.The token supplied was not valid.\n:erclist.\n:efunc.\n.se temp = 'Connect An Item'\n:func id=connect name='IM_CONNECT'.&temp.\n.**********************************************************************\n:p.\nThe :#x.IM_CONNECT:e#x. macro is used to connect an item to the\nstructure described by a descriptor.  This structure can be a linked\nlist or a hash table.  See :hdref refid=crtlld. and\n:hdref refid=crthtd. for information on how to create a structure\ndescriptor.  The IM_CONNECT function does not changed currency.\n.*---------------------------------------------------------------------*\n.* Syntax box for the macro form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:mac.\nIM_CONNECT ID=:hp1.id_name:ehp1. &cont.\n&lbt.,SPEPA=:hp1.im_epa:ehp1.&rbt. &cont.\n&lbt.,SPTOKEN=:hp1.im_token:ehp1.&rbt.\n   ,DESCTKN=:hp1.desctkn:ehp1.\n  &lbt.,ITEMTKN=:hp1.itemtkn:ehp1.&rbt.\n  &lbt.,HEADTKN=:hp1.headtkn:ehp1.&rbt.\n:emac.\n.*---------------------------------------------------------------------*\n.* Syntax box for the CALLX form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:callx.\nCALLX :hp1.im_epa:ehp1.,(:hp1.im_token:ehp1.,&amp.IM_CONNECT,&cont.\n:hp1.desctkn:ehp1.,:hp1.itemtkn:ehp1.,&cont.\n:hp1.headtkn:ehp1.)\n:ecallx.\n.*---------------------------------------------------------------------*\n.* Parameter-list table describing each parameter.\n.*---------------------------------------------------------------------*\n:plist.\n:pLt.desctkn\n:pLd.specifies the label of a fullword that contains the token of a\ndescriptor that describes the structure to which the item is to be\nconnected.  The descriptor must describe a linked list or a hash\ntable.\n:pLt.itemtkn\n:pLd.specifies the label of a fullword that contains the token of\nthe item to be connected.  If this parameter is not specified, the\nitem that is &curim. is connected.\n:pLt.headtkn\n:pLd.specifies the label of a fullword that contains the token of\nthe item that contains the heads when a structure can have multiple\noccurances.  If this parameter is not specified, the item that is\n&curityp. of the &ityp. specified with the :#xi.headtype:e#xi. parameter\non the associated descriptor create function is used.\n:eplist.\n:fh3.Example\n:p.\nThis instruction will connect the item that is &curim. to the structure\ndescribed by the descriptor whose token is in the fullword at tag\n:#x.A_LIST_DESCRIPTOR_TOKEN:e#x..\n:xmp.\n         IM_CONNECT ID=IM,DESCTKN=A_LIST_DESCRIPTOR_TOKEN\n:exmp.\n:efunc.\n.**********************************************************************\n.se temp = 'Create A Group Descriptor'\n:func id=crtgrd name='IM_CREATE_GROUP_DESCRIPTOR'.&temp.\n.**********************************************************************\n:p.\nThe :#x.IM_CREATE_GROUP_DESCRIPTOR:e#x. macro is used to create a group\ndescriptor.  A group is used to group items of certain &ityp.s\nin &imms..  See :hdref refid=crtitd. for information\non specifying a group descriptor when creating an &ityp. descriptor.\n.*---------------------------------------------------------------------*\n.* Syntax box for the macro form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:mac.\nIM_CREATE_GROUP_DESCRIPTOR ID=:hp1.id_name:ehp1. &cont.\n&lbt.,SPEPA=:hp1.im_epa:ehp1.&rbt. &cont.\n&lbt.,SPTOKEN=:hp1.im_token:ehp1.&rbt.\n   ,DESCTKN=:hp1.desctkn:ehp1.\n  &lbt.,TEXT=:hp1.text:ehp1.&rbt.\n  &lbt.,STGINCR=:hp1.stgincr:ehp1.&rbt.\n:emac.\n.*---------------------------------------------------------------------*\n.* Syntax box for the CALLX form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:callx.\nCALLX :hp1.im_epa:ehp1.,(:hp1.im_token:ehp1.,&cont.\n&amp.IM_CREATE_GROUP_DESCRIPTOR,&cont.\n:hp1.desctkn:ehp1.,:hp1.text:ehp1.,&cont.\n:hp1.stgincr:ehp1.)\n:ecallx.\n.*---------------------------------------------------------------------*\n.* Parameter-list table describing each parameter.\n.*---------------------------------------------------------------------*\n:plist.\n:pLt.desctkn\n:pLd.specifies the label of a fullword into which the token of the\ngroup descriptor created will be returned.\n:pLt.text\n:pLd.specifies the label of text to be associated with this\ndescriptor.  See :hdref refid=imtext. for information\non creating text.\n:pLt.stgincr\n:pLd.specifies the label of a fullword that contains the size of\nthe increment of storage that will be obtained each time that more\nstorage is required for items that are in this group.\nIf the parameter is not specified, 4K bytes is assumed.\n:eplist.\n:fh3.Example\n:p.\nThis instruction will create a group descriptor.  The &imgr. will\nassign storage to this group in 128K increments.\n:xmp.\n         IM_CREATE_GROUP_DESCRIPTOR ID=IM,                             +\n               DESCTKN=A_GROUP_DESCRIPTOR,                             +\n               STGINCR==A(128*1024)\n:exmp.\n:efunc.\n.**********************************************************************\n.se temp = 'Create A Hash Table Descriptor'\n:func id=crthtd name='IM_CREATE_HASH_TABLE_DESCRIPTOR'.&temp.\n.**********************************************************************\n:p.\nThe :#x.IM_CREATE_HASH_TABLE_DESCRIPTOR:e#x. macro is used to create a\nstructure descriptor for a hash table.\n:p.\nBecause of the number of links involved,\nthe &imgr. does not support multiple occurrences of a hash table.  You\ncan simulate multiple occurrences by creating multiple hash table\ndescriptors and storing their tokens in the link fields of the\nappropriate items.\n.*---------------------------------------------------------------------*\n.* Syntax box for the macro form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:mac.\nIM_CREATE_HASH_TABLE_DESCRIPTOR ID=:hp1.id_name:ehp1.\n  &lbt.,SPEPA=:hp1.im_epa:ehp1.&rbt. &cont.\n&lbt.,SPTOKEN=:hp1.im_token:ehp1.&rbt.\n   ,DESCTKN=:hp1.desctkn:ehp1.\n  &lbt.,MEMTYPE=:hp1.memtype:ehp1.&rbt.\n  &lbt.,TEXT=:hp1.text:ehp1.&rbt.\n  &lbt.,OPTIONS=(&lbt.DUPLICATE_KEYS_ALLOWED&rbt.)&rbt.\n  &lbt.,ENTRIES=:hp1.entries:ehp1.&rbt.\n   ,SYNLNK#=:hp1.synlnk#:ehp1.\n   ,KEYOFF=:hp1.keyoff:ehp1.\n   ,KEYSZ=:hp1.keysz:ehp1.|(IN_ITEM,:hp1.keysz_offset:ehp1.)\n:emac.\n.*---------------------------------------------------------------------*\n.* Syntax box for the CALLX form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:callx.\nCALLX :hp1.im_epa:ehp1.,(:hp1.im_token:ehp1.,&cont.\n&amp.IM_CREATE_HASH_TABLE_DESCRIPTOR,&cont.\n:hp1.desctkn:ehp1.,:hp1.text:ehp1.,\n      :hp1.optbyte:ehp1.,:hp1.entries.:ehp1.,:hp1.synlnk#:ehp1.,&cont.\n:hp1.keyoff:ehp1.,:hp1.keysz:ehp1.,:hp1.keysz_offset:ehp1.,&cont.\n:hp1.memtype:ehp1.)\n:ecallx.\n.*---------------------------------------------------------------------*\n.* Parameter-list table describing each parameter.\n.*---------------------------------------------------------------------*\n:plist.\n:pLt.desctkn\n:pLd.specifies the label of a fullword into which the token of the\nhash table descriptor created will be returned.\n:pLt.memtype\n:pLd.specifies the label of a halfword which contains the item type\nof items that can be members of the hash table.  If this parameter\nis not specified, items with a mixture of item types can be connected to\nthe hash table.\n:pLt.text\n:pLd.specifies the label of text to be associated with this\ndescriptor.  See :hdref refid=imtext. for information\non creating text.\n:pLt.optbyte\n:pLd.specifies the options byte.\n:pLt.entries\n:pLd.specifies a fullword that contains the number of entries that\nshould be in the root part of the hash table.  Although the item\nmanager does not check, this number should be prime.\nIf this parameter is not specified, 101 entries is assumed.\n:pLt.synlnk#\n:pLd.specifies a fullword that contains the link number within item\nconnected to this hash table, that will be used to chain synonyms.\n:pLt.keyoff\n:pLd.specifies a fullword that contains the offset of the key within\neach item connected to this hash table.\n:pLt.keysz\n:pLd.specifies a fullword that contains the size of the key.  If this\nparameter is not specified, the :#xi.keysize_offset:e#xi. parameter\nmust be specified.  Keys can not be greater than 255 bytes long.\n:pLt.keysz_offset\n:pLd.specifies a fullword that contains the offset within each item\nof one byte that contains the size of the key in that item.\nThis parameter is mutually exclusive with the :#xi.keysz:e#xi.\nparameter.\n:eplist.\n:fh3.Example\n:p.\nThis instruction will create a hash table descriptor.  A 5 byte key\nis in each item at an offset of 6.  The 2nd link field of each item\nis used for the hash table synonym chain.\n:xmp.\n         IM_CREATE_HASH_TABLE_DESCRIPTOR ID=IM,                        +\n               DESCTKN=A_HASH_TABLE_DESCRIPTOR,                        +\n               SYNLNK#=2,                                              +\n               KEYOFF=6,                                               +\n               KEYSZ=5\n:exmp.\n:efunc.\n.**********************************************************************\n:func name='IM_ID' id=imid.Establish Default &imgr. Values\n.**********************************************************************\n:p.The :#x.IM_ID:e#x. macro is used to establish default values for\nuse by other &imgr. macros, which may access those values\nthrough a unique identifier, :#xi.id_name:e#xi., specified by\nthe user.  When allowed to generate default values, this macro will\ncreate Program Work Area (PWA) storage for :#xi.im_epa:e#xi.\nand\n:#xi.im_token:e#xi.. These values, whether generated by the\nmacro or provided by the user, are accessable from all other\n&imgr. macros via the :#x.ID=:e#x.:#xi.id_name:e#xi. parameter.\n:mac.\nIM_ID ID=:hp1.id_name:ehp1.\n  &lbt.,SPEPNAME=:hp1.IM_epname:ehp1.&rbt.\n  &lbt.,SPEPA=:hp1.im_epa:ehp1.&rbt.\n  &lbt.,SPTOKEN=:hp1.im_token:ehp1.&rbt.\n  &lbt.,ESID=:hp1.esid_name:ehp1.&rbt.\n  &lbt.,ESVA=:hp1.esva:ehp1.&rbt.\n  &lbt.optional keywords specific to &imgr.&rbt.\n:emac.\n.*****\n:plist.\n:pLt.id_name\n:pLd.the identifier to assign to the service processor identifier being\nestablished.  This name must be unique for all service processor\nidentifier's.\n:pLt.IM_epname\n:pLd.the entry point name of the &imgr. service processor module\nthat is being used.\n:pLt.im_epa\n:pLd.specifies the label of a fullword in storage that will contain the\nentry point address of the Environment Support service processor.\n:pLt.im_token\n:pLd.specifies the label of a fullword in storage that will contain the\ntoken assigned by the :#x.IM_START:e#x. function of the String\nHandler.\n:pLt.esid_name\n:pLd.the name of a service processor identifier, created by the\n:#x.ES_ID:e#x.  macro, which will be used by the :#x.IM_ID:e#x. macro to\nautomatically obtain the value for :#x.esv:e#x. (see below).\n:pLt.esva\n:pLd.specifies the label of a fullword in storage that contains (or\nwill contain) the address of the Environment Support Vector\n(:#x.ESV:e#x.) created by the :#x.ES_START:e#x. function.\n:eplist.\n:fh3.Example 1\n:p.\n:xmp.\nIM_ID ID=ES,SPEPNAME=&amp.ITEM_MANAGER\n:exmp.\n:efunc.\n.**********************************************************************\n.se temp = 'Create An Item Type Descriptor'\n:func id=crtitd name='IM_CREATE_ITEM_TYPE_DESCRIPTOR'.&temp.\n.**********************************************************************\n:p.\nThe :#x.IM_CREATE_ITEM_TYPE_DESCRIPTOR:e#x. macro is used to create a\nitem type descriptor.\n:p.\nUnlike all other tokens, which are four bytes long,\nthe token for an item type descriptor is only two bytes long.\nThe first two bytes of every item is the token of the item type\ndescriptor that describes that item's characteristics.\n.*---------------------------------------------------------------------*\n.* Syntax box for the macro form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:mac.\nIM_CREATE_ITEM_TYPE_DESCRIPTOR ID=:hp1.id_name:ehp1.\n  &lbt.,SPEPA=:hp1.im_epa:ehp1.&rbt. &cont.\n&lbt.,SPTOKEN=:hp1.im_token:ehp1.&rbt.\n   ,ITEMTYPE=:hp1.itemtype:ehp1.\n  &lbt.,TEXT=:hp1.text:ehp1.&rbt.\n  &lbt.,OPTIONS=(:hp1.&lbt.FIRST_LINK_HAS_DESCRIPTION&rbt.:ehp1.)\n  &lbt.,GROUPTKN=:hp1.grouptkn:ehp1.&rbt.\n   ,ITEMSZ=:hp1.itemsz:ehp1. | &cont.\n(IN_ITEM,:hp1.itemsz_offset:ehp1.,:hp1.itemsz_lensize:ehp1.)\n  &lbt.,#LINKS=:hp1.#links:ehp1. | &cont.\n(IN_ITEM,:hp1.#links_offset:ehp1.,:hp1.#links_lensize:ehp1.)&rbt.\n  &lbt.,LINKSOFF=:hp1.linksoff:ehp1. | &cont.\n(IN_ITEM,:hp1.linksoff_offset:ehp1.,:hp1.linksoff_lensize:ehp1.)&rbt.\n:emac.\n.*---------------------------------------------------------------------*\n.* Syntax box for the CALLX form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:callx.\nCALLX :hp1.im_epa:ehp1.,(:hp1.im_token:ehp1.,&cont.\n&amp.IM_CREATE_ITEM_TYPE_DESCRIPTOR,&cont.\n:hp1.itemtype:ehp1.,:hp1.text:ehp1.,\n      :hp1.optbyte:ehp1.,:hp1.grouptkn:ehp1.,&cont.\n:hp1.itemsz:ehp1.,:hp1.#links:ehp1.,:hp1.linksoff:ehp1.,\n      :hp1.itemsz_lensize:ehp1.,:hp1.itemsz_offset:ehp1.,&cont.\n:hp1.#links_lensize:ehp1.,:hp1.#links_offset:ehp1.,\n      :hp1.linksoff_lensize:ehp1.,:hp1.linksoff_offset:ehp1.)\n:ecallx.\n.*---------------------------------------------------------------------*\n.* Parameter-list table describing each parameter.\n.*---------------------------------------------------------------------*\n:plist.\n:pLt.itemtype\n:pLd.specifies the label of a halfword into which the token of the\nitem type descriptor created will be returned.\n:pLt.text\n:pLd.specifies the label of text to be associated with this\ndescriptor.  See :hdref refid=imtext. for information\non creating text.\n:pLt.optbyte\n:pLd.specifies the options byte.\n:pLt.grouptkn\n:pLd.specifies the label of a fullword that contains the token of the\ngroup descriptor to be used when creating items of this type.  See\n:hdref refid=crtgrd. for further information on creating group\ndescriptors.  If this parameter is not specified, items of this type\nwill go into the default user group.  See :hdref refid=iminit. for\ninformation on the size of the storage increment for the default\nuser group.\n:pLt.itemsz\n:pLd.specifies a fullword that contains the length of items of this\ntype.  This parameter is mutually exclusive with the\n:#xi.itemsz_offset:e#xi. and :#xi.itemsz_lensize:e#xi. parameters and\nis required if they are not specified.\n:pLt.itemsz_offset\n:pLd.specifies a fullword that contains the offset within each item\nof this type of the item's length.\n:pLt.itemsz_lensize\n:pLd.specifies a fullword that contains the size of the item length\nwithin each item of this type.  This length can be 1, 2, 3 or 4.\n:pLt.#links\n:pLd.specifies a fullword that contains the number of links in items of\nthis type.  This parameter is mutually exclusive with the\n:#xi.#links_offset:e#xi. and :#xi.#links_lensize:e#xi. parameters and\nis required if they are not specified.\n:pLt.#links_offset\n:pLd.specifies a fullword that contains the offset within each item\nof this type of the item's number of links.\n:pLt.#links_lensize\n:pLd.specifies a fullword that contains the size of the field\nwithin each item of this type that contains its number of links.\nThis length can be 1, 2, 3 or 4.\n:pLt.linksoff\n:pLd.specifies a fullword that contains the offset of the links\nin items of\nthis type.  This parameter is mutually exclusive with the\n:#xi.linksoff_offset:e#xi. and :#xi.linksoff_lensize:e#xi. parameters an\nis required if they are not specified.\n:pLt.linksoff_offset\n:pLd.specifies a fullword that contains the offset within each item\nof this type of the item's links offset.\n:pLt.linksoff_lensize\n:pLd.specifies a fullword that contains the size of the field\nwithin each item of this type that contains its links offset.\nThis length can be 1, 2, 3 or 4.\n:eplist.\n:fh3.Example\n:p.\nThis instruction will create an item type descriptor.  Each items stored\nwith the token returned by this function in its first two bytes will be\n32 bytes long with two links at its end.\n:xmp.\n         IM_CREATE_ITEM_TYPE_DESCRIPTOR ID=IM,                         +\n               ITEMTYPE=ITEM_TYPE_DESCRIPTOR,                          +\n               ITEMSZ=32,#LINKS=2,LINKOFF=24\n:exmp.\n:efunc.\n.**********************************************************************\n.se temp = 'Create A Linked List Descriptor'\n:func id=crtlld name='IM_CREATE_LINKED_LIST_DESCRIPTOR'.&temp.\n.**********************************************************************\n:p.\nThe :#x.IM_CREATE_LINKED_LIST_DESCRIPTOR:e#x. macro is used to create a\nlinked list descriptor.\n\nThe sorted list related options and parameters for this function are\nnot yet implemented.  Also, LIST_ORDER_NEXT and LIST_ORDER_PRIOR are\nnot yet implemented.\n.*---------------------------------------------------------------------*\n.* Syntax box for the macro form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:mac.\nIM_CREATE_LINKED_LIST_DESCRIPTOR ID=:hp1.id_name:ehp1.\n  &lbt.,SPEPA=:hp1.im_epa:ehp1.&rbt. &cont.\n&lbt.,SPTOKEN=:hp1.im_token:ehp1.&rbt.\n   ,DESCTKN=:hp1.desctkn:ehp1.\n  &lbt.,TEXT=:hp1.text:ehp1.&rbt.\n  &lbt.,OPTIONS=(&lbt.HEADS_IN_DESCRIPTOR&rbt.\n             &lbt.,DUPLICATE_KEYS_ALLOWED&rbt.\n             &lbt.,LIST_ORDER_FIRST&rbt.\n             &lbt.,LIST_ORDER_FINAL&rbt.\n             &lbt.,LIST_ORDER_NEXT&rbt.\n             &lbt.,LIST_ORDER_PRIOR&rbt.\n             &lbt.,LIST_ORDER_SORTED_ASCENDING&rbt.\n             &lbt.,LIST_ORDER_SORTED_DESCENDING&rbt.)\n  &lbt.,FSTLNK#=:hp1.fstlnk#:ehp1.&rbt.\n  &lbt.,FNLLNK#=:hp1.fnllnk#:ehp1.&rbt.\n   ,NXTLNK#=:hp1.nxtlnk#:ehp1.\n  &lbt.,PRLNK#=:hp1.prvlnk#:ehp1.&rbt.\n  &lbt.,OWNLNK#=:hp1.ownlnk#:ehp1.&rbt.\n  &lbt.,HEADTYPE=:hp1.headtype:ehp1.&rbt.\n  &lbt.,MEMTYPE=:hp1.memtype:ehp1.&rbt.\n  &lbt.,KEYOFF=:hp1.keyoff:ehp1.&rbt.\n  &lbt.,KEYSZ=:hp1.keysz:ehp1.|(IN_ITEM,:hp1.keysz_offset:ehp1.)&rbt.\n:emac.\n.*---------------------------------------------------------------------*\n.* Syntax box for the CALLX form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:callx.\nCALLX :hp1.im_epa:ehp1.,(:hp1.im_token:ehp1.,&cont.\n&amp.IM_CREATE_LINKED_LIST_DESCRIPTOR,&cont.\n:hp1.desctkn:ehp1.,:hp1.text:ehp1.,\n      :hp1.optbyte:ehp1.,:hp1.fstlnk#.:ehp1.,&cont.\n:hp1.fnllk#:ehp1.,:hp1.nxtlk#:ehp1.,:hp1.prlnk#:ehp1.,\n      :hp1.headtype:ehp1.,:hp1.keyoff:ehp1.,&cont.\n:hp1.keysz:ehp1.,:hp1.keysz_offset:ehp1.,:hp1.memtype:ehp1.)\n:ecallx.\n.*---------------------------------------------------------------------*\n.* Parameter-list table describing each parameter.\n.*---------------------------------------------------------------------*\n:plist.\n:pLt.desctkn\n:pLd.specifies the label of a fullword into which will be returned\nthe token of the linked list descriptor created.\n:pLt.text\n:pLd.specifies the label of text to be associated with this\ndescriptor.  See :hdref refid=imtext. for information\non creating text.\n:pLt.optbyte\n:pLd.specifies the options byte.\n:pLt.HEADS_IN_ DESCRIPTOR\n:pLd.indicates that the heads for the list will be contained in the\nlist descriptor.\n:pLt.LIST_ORDER_FIRST\n:pLd.indicates that normally items will be connected to the start of\nthe list.\n:pLt.LIST_ORDER_FINAL\n:pLd.indicates that normally items will be connected to the end of\nthe list.\n:pLt.fstlnk#\n:pLd.specifies the label of a fullword that contains the link number\nof the :q.first link:eq. in the associated head items.\nDo not specify this parameter if\nOPTIONS=HEADS_IN_DESCRIPTOR is specified.\nIf OPTIONS=HEADS_IN_DESCRIPTOR is not specified, this parameter is\nrequired.\n:pLt.fnllnk#\n:pLd.specifies the label of a fullword that contains the link number\nof the :q.final link:eq. in the associated head items.\nDo not specify this parameter if\nOPTIONS=HEADS_IN_DESCRIPTOR is specified.\n:pLt.nxtlnk#\n:pLd.specifies the label of a fullword that contains the link number\nof the :q.next link:eq. in the associated member items.\n:pLt.prlnk#\n:pLd.specifies the label of a fullword that contains the link number\nof the :q.prior link:eq. in the associated member items.\n:pLt.ownlnk#\n:pLd.specifies the label of a fullword that contains the link number\nof the :q.owner link:eq. in the associated member items.\n:pLt.headtype\n:pLd.specifies the label of a halfword which contains the item type\nof the items that will head the lists.\nDo not specify this parameter if\nOPTIONS=HEADS_IN_DESCRIPTOR is specified.\nIf OPTIONS=HEADS_IN_DESCRIPTOR is not specified, this parameter is\nrequired.\n:pLt.memtype\n:pLd.specifies the label of a halfword which contains the item type\nof items that can be members of the linked list.  If this parameter\nis not specified, items with a mixture of item types can be connected to\nthe linked list.\n:pLt.keyoff\n:pLd.specifies the label of a fullword which contains the offset of\nthe key in items of the list.\n:pLt.keysz\n:pLd.specifies the label of a fullword which contains the size of the\nkey.\n:pLt.keysz_offset\n:pLd.specifies the label of a fullword which contains the offset of the\none byte key size in associated item.\n:eplist.\n:fh3.Example\n:p.\nThis instruction will create a\n:xmp.\n         IM_CREATE_LINKED_LIST_DESCRIPTOR ID=IM,                       +\n               DESCTKN=A_LINKED_LIST_DESCRIPTOR,                       +\n               NXTLNK#=4\n:exmp.\n:efunc.\n.**********************************************************************\n.se temp = 'Destroy A Descriptor'\n:func id=destroy name='IM_DESTROY'.&temp.\n.**********************************************************************\n:p.\nThe :#x.IM_DESTORY:e#x. macro is used to destroy a descriptor created\nby one of the create functions.\n:p.\nThis function is not yet implemented.\n.*---------------------------------------------------------------------*\n.* Syntax box for the macro form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:mac.\nIM_DESTORY ID=:hp1.id_name:ehp1. &cont.\n&lbt.,SPEPA=:hp1.im_epa:ehp1.&rbt. &cont.\n&lbt.,SPTOKEN=:hp1.im_token:ehp1.&rbt.\n   ,DESCTKN=:hp1.desctkn:ehp1.\n:emac.\n.*---------------------------------------------------------------------*\n.* Syntax box for the CALLX form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:callx.\nCALLX :hp1.im_epa:ehp1.,(:hp1.im_token:ehp1.,&amp.IM_DESTROY,&cont.\n:hp1.desctkn:ehp1.)\n:ecallx.\n.*---------------------------------------------------------------------*\n.* Parameter-list table describing each parameter.\n.*---------------------------------------------------------------------*\n:plist.\n:pLt.desctkn\n:pLd.specifies the label of a fullword that contains the token of a\ndescriptor to destroy.  The descriptor must not be associated with\nany items.\n:eplist.\n:fh3.Example\n:p.\nThis instruction will destroy the descriptor whose token is in the\nfullword at tag A_DESCRIPTOR_TOKEN.\n:xmp.\n         IM_DESTORY ID=IM,DESCTKN=A_DESCRIPTOR_TOKEN\n:exmp.\n:efunc.\n.**********************************************************************\n.se temp = 'Disconnect An Item'\n:func id=disconn name='IM_DISCONNECT'.&temp.\n.**********************************************************************\n:p.\nThe :#x.IM_DISCONNECT:e#x. macro is used to disconnect an item from the\nstructure described by a descriptor.  This structure can be a linked\nlist or a hash table.  See :hdref refid=connect. for information on\nhow to connect an item to a structure.  No item is &curdesc.\nfor the descriptor specified after this function has completed.  Other\ncurrency remains unchanged.\n:p.\nThis function is only implemented for linked lists.\n.*---------------------------------------------------------------------*\n.* Syntax box for the macro form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:mac.\nIM_DISCONNECT ID=:hp1.id_name:ehp1. &cont.\n&lbt.,SPEPA=:hp1.im_epa:ehp1.&rbt. &cont.\n&lbt.,SPTOKEN=:hp1.im_token:ehp1.&rbt.\n   ,DESCTKN=:hp1.desctkn:ehp1.\n  &lbt.,ITEMTKN=:hp1.itemtkn:ehp1.&rbt.\n  &lbt.,HEADTKN=:hp1.headtkn:ehp1.&rbt.\n  &lbt.,PRTKN=:hp1.prtkn:ehp1.&rbt.\n:emac.\n.*---------------------------------------------------------------------*\n.* Syntax box for the CALLX form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:callx.\nCALLX :hp1.im_epa:ehp1.,(:hp1.im_token:ehp1.,&amp.IM_DISCONNECT,&cont.\n:hp1.desctkn:ehp1.,:hp1.itemtkn:ehp1.,&cont.\n:hp1.headtkn:ehp1.,:hp1.prtkn:ehp1.)\n:ecallx.\n.*---------------------------------------------------------------------*\n.* Parameter-list table describing each parameter.\n.*---------------------------------------------------------------------*\n:plist.\n:pLt.desctkn\n:pLd.specifies the label of a fullword that contains the token of a\ndescriptor that describes the structure to which the item is to be\ndisconnected.  The descriptor must describe a linked list or a hash\ntable.\n:pLt.itemtkn\n:pLd.specifies the label of a fullword that contains the token of\nthe item to be disconnected.  If this parameter is not specified, the\nitem that is &curim. is disconnected.\n:pLt.headtkn\n:pLd.specifies the label of a fullword that contains the token of\nthe item that contains the heads when a structure can have multiple\noccurances.  If this parameter is not specified, the item that is\n&curityp. of the &ityp. specified with the :#xi.headtype:e#xi. parameter\non the associated descriptor create function is used.\n:pLt.prtkn\n:pLd.specifies the label of a fullword that contains the token of\nthe item prior to the one to be disconnected.\nIf this parameter is not specified, the associated\ndescriptor must have a prior link.\n:eplist.\n:fh3.Example\n:p.\nThis instruction will disconnect the item that is &curim. from\nthe structure\ndescribed by the descriptor whose token is in the fullword at tag\n:#x.A_LIST_DESCRIPTOR_TOKEN:e#x..\n:xmp.\n         IM_DISCONNECT ID=IM,DESCTKN=A_LIST_DESCRIPTOR_TOKEN\n:exmp.\n:efunc.\n.**********************************************************************\n.se temp = 'Erase An Item'\n:func id=erase name='IM_ERASE'.&temp.\n.**********************************************************************\n:p.\nThe :#x.IM_ERASE:e#x. macro is used to erase an item from &imms..\n.*---------------------------------------------------------------------*\n.* Syntax box for the macro form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:mac.\nIM_ERASE ID=:hp1.id_name:ehp1. &cont.\n&lbt.,SPEPA=:hp1.im_epa:ehp1.&rbt. &cont.\n&lbt.,SPTOKEN=:hp1.im_token:ehp1.&rbt.\n  &lbt.,OPTIONS=(&lbt.BYPASS_LINKS_CHECK&rbt.)&rbt.\n  &lbt.,ITEMTKN=:hp1.itemtkn:ehp1.&rbt.\n:emac.\n.*---------------------------------------------------------------------*\n.* Syntax box for the CALLX form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:callx.\nCALLX :hp1.im_epa:ehp1.,(:hp1.im_token:ehp1.,&amp.IM_ERASE,&cont.\n:hp1.optbyte:ehp1.,:hp1.itemtkn:ehp1.)\n:ecallx.\n.*---------------------------------------------------------------------*\n.* Parameter-list table describing each parameter.\n.*---------------------------------------------------------------------*\n:plist.\n:pLt.optbyte\n:pLd.specifies the label of a byte that contains options.\n:pLt.itemtkn\n:pLd.specifies the label of a fullword that contains the token of\nthe item to be erased.  If this parameter is not specified, the\nitem that is &curim. is erased.\n:eplist.\n:fh3.Example\n:p.\nThis instruction will erase the item that is &curim. from &imms..\n:xmp.\n         IM_ERASE ID=IM\n:exmp.\n:rclist.\n:rcn.0\n:rct.IM_SUCCESS\n:rcd.The :#x.IM_ERASE:e#x. function has successfully\nerased the item from &imms..\n:erclist.\n:efunc.\n.**********************************************************************\n.se temp = 'Find An Item By Its Token'\n:func id=imfd name='IM_FIND'.&temp.\n.**********************************************************************\n:p.\nThe :#x.IM_FIND:e#x. macro is used to locate an item by its item token.\nThe item found will become &curim. and &curityp..\n.*---------------------------------------------------------------------*\n.* Syntax box for the macro form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:mac.\nIM_FIND ID=:hp1.id_name:ehp1. &cont.\n&lbt.,SPEPA=:hp1.im_epa:ehp1.&rbt. &cont.\n&lbt.,SPTOKEN=:hp1.im_token:ehp1.&rbt.\n   ,ITEMTKN=:hp1.itemtkn:ehp1.\n  &lbt.,ACTUALSZ=:hp1.actualsz:ehp1.&rbt.\n:emac.\n.*---------------------------------------------------------------------*\n.* Syntax box for the CALLX form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:callx.\nCALLX :hp1.im_epa:ehp1.,(:hp1.im_token:ehp1.,&amp.IM_FIND,&cont.\n:hp1.itemtkn:ehp1.,:hp1.actualsz:ehp1.)\n:ecallx.\n.*---------------------------------------------------------------------*\n.* Parameter-list table describing each parameter.\n.*---------------------------------------------------------------------*\n:plist.\n:pLt.id_name\n:pLd.specifies the name of a service processor identifier created by the\n:#x.IM_ID:e#x. macro which will be used by the\n:#x.IM_FIND:e#x.\nmacro to automatically obtain values for :#xi.im_epa:e#xi.\nand\n:#xi.im_token:e#xi.. This parameter is required unless both\n:#xi.im_epa:e#xi. and :#xi.im_token:e#xi. are\nspecified.\n:pLt.im_epa\n:pLd.specifies the label of a fullword in storage that contains the\nentry point address of an already-started &imgr. service\nprocessor.  The value specified by :#xi.im_epa:e#xi.\noverrides any value obtained from\n:#x.ID=:e#x.:#xi.id_name:e#xi..\n:pLt.im_token\n:pLd.specifies the label of a fullword in storage that contains the\nvalue returned by :#x.IM_START:e#x. for the\n:#xi.im_token:e#xi. parameter.  The value specified by\n:#xi.im_token:e#xi. overrides any value obtained from\n:#x.ID=:e#x.:#xi.id_name:e#xi..\n:pLt.itemtkn\n:pLd.specifies the label of a fullword that contains the token of\nthe item to be located.\n:pLt.actualsz\n:pLd.specifies the label of a fullword into which will be place the\nactual size of the item found.\n:eplist.\n:fh3.Example\n:p.\nThis instruction will find the item whose token is in the fullword\nat label ITEM_TOKEN.\n:xmp.\n         IM_FIND ID=IM,ITEMTKN=ITEM_TOKEN\n:exmp.\n:efunc.\n.**********************************************************************\n.se temp = 'Find An Item By Key'\n:func id=imfdky name='IM_FIND_BY_KEY'.&temp.\n.**********************************************************************\n:p.\nThe :#x.IM_FIND_BY_KEY:e#x. macro\nis used to locate an item by its key.\nThe item found will become &curim. and &curityp..\n.*---------------------------------------------------------------------*\n.* Syntax box for the macro form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:mac.\nIM_FIND_BY_KEY ID=:hp1.id_name:ehp1. &cont.\n&lbt.,SPEPA=:hp1.im_epa:ehp1.&rbt. &cont.\n&lbt.,SPTOKEN=:hp1.im_token:ehp1.&rbt.\n   ,DESCTKN=:hp1.desctkn:ehp1.\n   ,KEY=:hp1.key:ehp1. | &cont.\n(:hp1.key:ehp1.,:hp1.key_length:ehp1.)\n  &lbt.,ITEMTKN=:hp1.itemtkn:ehp1.&rbt.\n  &lbt.,ACTUALSZ=:hp1.actualsz:ehp1.&rbt.\n:emac.\n.*---------------------------------------------------------------------*\n.* Syntax box for the CALLX form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:callx.\nCALLX :hp1.im_epa:ehp1.,(:hp1.im_token:ehp1.,&amp.IM_FIND_BY_KEY,&cont.\n:hp1.desctkn:ehp1.,:hp1.key_length:ehp1.,:hp1.key:ehp1.,\n      :hp1.actualsz:ehp1.,:hp1.itemtkn:ehp1.)\n:ecallx.\n.*---------------------------------------------------------------------*\n.* Parameter-list table describing each parameter.\n.*---------------------------------------------------------------------*\n:plist.\n:pLt.desctkn\n:pLd.specifies the label of a fullword that contains the token of\ndescriptor that describes the structure in which the item should be\nfound.\n:pLt.key_length\n:pLd.specifies a fullword that contains the length of the key.  Trailing\nblanks are ignored in the compare, so the key can still match a item\nin &imms. even if the key length of that item is not the same\nas the key length specified.\n:pLt.key\n:pLd.specifies the label of a field that contains the key of the item\nto locate.\n:pLt.actualsz\n:pLd.specifies the label of a fullword into which will be placed the\nactual size of the item found.\n:pLt.itemtkn\n:pLd.specifies the label of a fullword into which will be placed the\ntoken of the item located.\n:eplist.\n:fh3.Example\n:p.\nThis instruction will find the item in the linked list described by\nA_LIST_DESCRIPTOR that has a key of \"XYZZY\".\n:xmp.\n         IM_FIND_BY_KEY ID=IM,DESCTKN=A_LIST_DESCRIPTOR,KEY=\"XYZZY\"\n:exmp.\n:efunc.\n.**********************************************************************\n.se temp = 'Find the Item That is Current of Descriptor'\n:func id=imfdcd name='IM_FIND_CURRENT_OF_DESCRIPTOR'.&temp.\n.**********************************************************************\n:p.\nThe :#x.IM_FIND_CURRENT_OF_DESCRIPTOR:e#x. macro\nis used to locate an item that is current of a given descriptor.\nThe item found will become &curim. and &curityp..\n.*---------------------------------------------------------------------*\n.* Syntax box for the macro form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:mac.\nIM_FIND_CURRENT_OF_DESCRIPTOR ID=:hp1.id_name:ehp1.\n  &lbt.,SPEPA=:hp1.im_epa:ehp1.&rbt. &cont.\n&lbt.,SPTOKEN=:hp1.im_token:ehp1.&rbt.\n   ,DESCTKN=:hp1.desctkn:ehp1.\n  &lbt.,ITEMTKN=:hp1.itemtkn:ehp1.&rbt.\n  &lbt.,ACTUALSZ=:hp1.actualsz:ehp1.&rbt.\n:emac.\n.*---------------------------------------------------------------------*\n.* Syntax box for the CALLX form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:callx.\nCALLX :hp1.im_epa:ehp1.,(:hp1.im_token:ehp1.,&amp.&cont.\nIM_FIND_CURRENT_OF_DESCRIPTOR,&cont.\n:hp1.desctkn:ehp1.,\n      :hp1.actualsz:ehp1.,:hp1.itemtkn:ehp1.)\n:ecallx.\n.*---------------------------------------------------------------------*\n.* Parameter-list table describing each parameter.\n.*---------------------------------------------------------------------*\n:plist.\n:pLt.desctkn\n:pLd.specifies the label of a fullword that contains the token of\ndescriptor that describes the structure in which the item should be\nfound.\n:pLt.actualsz\n:pLd.specifies the label of a fullword into which will be placed the\nactual size of the item found.\n:pLt.itemtkn\n:pLd.specifies the label of a fullword into which will be placed the\ntoken of the item located.\n:eplist.\n:fh3.Example\n:p.\nThis instruction will find the item that is current of descriptor for\nthe structure described by A_LIST_DESCRIPTOR.\n:xmp.\n         IM_FIND_CURRENT_OF_DESCRIPTOR ID=IM,DESCTKN=A_LIST_DESCRIPTOR\n:exmp.\n:efunc.\n.**********************************************************************\n.se temp = 'Find the Item That is Current of Item Type'\n:func id=imfdit name='IM_FIND_CURRENT_OF_ITEM_TYPE'.&temp.\n.**********************************************************************\n:p.\nThe :#x.IM_FIND_CURRENT_OF_ITEM_TYPE:e#x. macro is used to locate an\nitem that is current of a given item type.  The item found will become\n&curim. and remain &curityp..\n.*---------------------------------------------------------------------*\n.* Syntax box for the macro form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:mac.\nIM_FIND_CURRENT_OF_ITEM_TYPE ID=:hp1.id_name:ehp1. &cont.\n&lbt.,SPEPA=:hp1.im_epa:ehp1.&rbt. &cont.\n&lbt.,SPTOKEN=:hp1.im_token:ehp1.&rbt.\n   ,ITEMTYPE=:hp1.itemtype:ehp1.\n  &lbt.,ITEMTKN=:hp1.itemtkn:ehp1.&rbt.\n  &lbt.,ACTUALSZ=:hp1.actualsz:ehp1.&rbt.\n:emac.\n.*---------------------------------------------------------------------*\n.* Syntax box for the CALLX form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:callx.\nCALLX :hp1.im_epa:ehp1.,(:hp1.im_token:ehp1.,&amp.&cont.\nIM_FIND_ITEM_TYPE,:hp1.itemtype:ehp1.,&cont.\n:hp1.actualsz:ehp1.,:hp1.itemtkn:ehp1.)\n:ecallx.\n.*---------------------------------------------------------------------*\n.* Parameter-list table describing each parameter.\n.*---------------------------------------------------------------------*\n:plist.\n:pLt.itemtype\n:pLd.specifies the label of a halfword that contains the token of\nitem type descriptor\nfor the item that should be\nfound.\n:pLt.actualsz\n:pLd.specifies the label of a fullword into which will be placed the\nactual size of the item found.\n:pLt.itemtkn\n:pLd.specifies the label of a fullword into which will be placed the\ntoken of the item located.\n:eplist.\n:fh3.Example\n:p.\nThis instruction will find the item that is current of item type for\nthe structure described by A_LIST_DESCRIPTOR.\n:xmp.\n         IM_FIND_CURRENT_OF_ITEM_TYPE ID=IM,DESCTKN=A_LIST_DESCRIPTOR\n:exmp.\n:efunc.\n.**********************************************************************\n.se temp = 'Find the Final Item in a Structure'\n:func id=imfdfn name='IM_FIND_FINAL'.&temp.\n.**********************************************************************\n:p.\nThe :#x.IM_FIND_FINAL:e#x. macro\nis used to locate the final item in a structure.\nThis functions is supported for Linked Lists.\nThe item found will become &curim., &curdesc. and  &curityp..\n.*---------------------------------------------------------------------*\n.* Syntax box for the macro form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:mac.\nIM_FIND_FINAL ID=:hp1.id_name:ehp1. &cont.\n&lbt.,SPEPA=:hp1.im_epa:ehp1.&rbt. &cont.\n&lbt.,SPTOKEN=:hp1.im_token:ehp1.&rbt.\n   ,DESCTKN=:hp1.desctkn:ehp1.\n  &lbt.,ITEMTKN=:hp1.itemtkn:ehp1.&rbt.\n  &lbt.,ACTUALSZ=:hp1.actualsz:ehp1.&rbt.\n  &lbt.,HEADTKN=:hp1.headtkn:ehp1.&rbt.\n:emac.\n.*---------------------------------------------------------------------*\n.* Syntax box for the CALLX form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:callx.\nCALLX :hp1.im_epa:ehp1.,(:hp1.im_token:ehp1.,&amp.&cont.\nIM_FIND_FINAL,:hp1.desctkn:ehp1.,&cont.\n:hp1.actualsz:ehp1.,:hp1.itemtkn:ehp1.,:hp1.headtkn:ehp1.)\n:ecallx.\n.*---------------------------------------------------------------------*\n.* Parameter-list table describing each parameter.\n.*---------------------------------------------------------------------*\n:plist.\n:pLt.desctkn\n:pLd.specifies the label of a fullword that contains the token of\ndescriptor that describes the structure in which the item should be\nfound.\n:pLt.actualsz\n:pLd.specifies the label of a fullword into which will be placed the\nactual size of the item found.\n:pLt.itemtkn\n:pLd.specifies the label of a fullword into which will be placed the\ntoken of the item located.\n:pLt.headtkn\n:pLd.specifies the label of a fullword that contains the token of the\nhead item for the list.  This parameter only applies to lists that do\nnot contain heads in the descriptor.\nIf this parameter is not specified, the item\nthat is &curityp. of the HEADTYPE associated with the descriptor will\nbe used.\n:eplist.\n:fh3.Example\n:p.\nThis instruction will find the final item in the linked list\ndescribed by A_LIST_DESCRIPTOR.\n:xmp.\n         IM_FIND_FINAL ID=IM,DESCTKN=A_LIST_DESCRIPTOR\n:exmp.\n:efunc.\n.**********************************************************************\n.se temp = 'Find the First Item in a Structure'\n:func id=imfdfr name='IM_FIND_FIRST'.&temp.\n.**********************************************************************\n:p.\nThe :#x.IM_FIND_FIRST:e#x. macro\nis used to locate the first item in a structure.\nThis functions is supported for Linked Lists.\nThe item found will become &curim., &curdesc. and  &curityp..\n.*---------------------------------------------------------------------*\n.* Syntax box for the macro form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:mac.\nIM_FIND_FIRST ID=:hp1.id_name:ehp1. &cont.\n&lbt.,SPEPA=:hp1.im_epa:ehp1.&rbt. &cont.\n&lbt.,SPTOKEN=:hp1.im_token:ehp1.&rbt.\n   ,DESCTKN=:hp1.desctkn:ehp1.\n  &lbt.,ITEMTKN=:hp1.itemtkn:ehp1.&rbt.\n  &lbt.,ACTUALSZ=:hp1.actualsz:ehp1.&rbt.\n  &lbt.,HEADTKN=:hp1.headtkn:ehp1.&rbt.\n:emac.\n.*---------------------------------------------------------------------*\n.* Syntax box for the CALLX form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:callx.\nCALLX :hp1.im_epa:ehp1.,(:hp1.im_token:ehp1.,&amp.&cont.\nIM_FIND_FIRST,:hp1.desctkn:ehp1.,&cont.\n:hp1.actualsz:ehp1.,:hp1.itemtkn:ehp1.,:hp1.headtkn:ehp1.)\n:ecallx.\n.*---------------------------------------------------------------------*\n.* Parameter-list table describing each parameter.\n.*---------------------------------------------------------------------*\n:plist.\n:pLt.desctkn\n:pLd.specifies the label of a fullword that contains the token of\ndescriptor that describes the structure in which the item should be\nfound.\n:pLt.actualsz\n:pLd.specifies the label of a fullword into which will be placed the\nactual size of the item found.\n:pLt.itemtkn\n:pLd.specifies the label of a fullword into which will be placed the\ntoken of the item located.\n:pLt.headtkn\n:pLd.specifies the label of a fullword that contains the token of the\nhead item for the list.  This parameter only applies to lists that do\nnot contain heads in the descriptor.\nIf this parameter is not specified, the item\nthat is &curityp. of the HEADTYPE associated with the descriptor will\nbe used.\n:eplist.\n:fh3.Example\n:p.\nThis instruction will find the first item in the linked list\ndescribed by A_LIST_DESCRIPTOR.\n:xmp.\n         IM_FIND_FIRST ID=IM,DESCTKN=A_LIST_DESCRIPTOR\n:exmp.\n:efunc.\n.**********************************************************************\n.se temp = 'Find An Item Token in The Token Directory'\n:func id=imfddr name='IM_FIND_IN_DIRECTORY'.&temp.\n.**********************************************************************\n:p.\nThe :#x.IM_FIND_IN_DIRECTORY:e#x. macro\nis used to get an item token in the token directory.\nCurrency is not changed.\n:p.\nThis function is not yet implemented.\n.*---------------------------------------------------------------------*\n.* Syntax box for the macro form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:mac.\nIM_FIND_IN_DIRECTORY ID=:hp1.id_name:ehp1. &cont.\n&lbt.,SPEPA=:hp1.im_epa:ehp1.&rbt. &cont.\n&lbt.,SPTOKEN=:hp1.im_token:ehp1.&rbt.\n   ,NAME=&lbr.:hp1.name:ehp1. | &cont.\n(:hp1.name:ehp1.,:hp1.name_length:ehp1.)&rbr.\n   ,TOKEN=:hp1.token:ehp1.\n:emac.\n.*---------------------------------------------------------------------*\n.* Syntax box for the CALLX form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:callx.\nCALLX :hp1.im_epa:ehp1.,(:hp1.im_token:ehp1.,&amp.&cont.\nIM_FIND_IN_DIRECTORY,&cont.\n:hp1.name_length:ehp1.,:hp1.name:ehp1.,&cont.\n:hp1.token:ehp1.)\n:ecallx.\n.*---------------------------------------------------------------------*\n.* Parameter-list table describing each parameter.\n.*---------------------------------------------------------------------*\n:plist.\n:pLt.name\n:pLd.specifies the label of a string that contains the name that is\nassociated with the token specified with the :#xi.token:e#xi.\nparameter.\n:pLt.name_length\n:pLd.specifies the label of a signed binary integer indicating the\nlength of the string identified by the :#xi.name:e#xi.\nparameter.\n:pLt.token\n:pLd.specifies the label of a fullword of storage into which will be\nplaced the token of the associated item.\n:eplist.\n:fh3.Example\n:p.\nThis instruction will find the item token associated with the name\n\"MY_TOKEN\" and put it in TOKEN_TAG.\n:xmp.\n         IM_FIND_IN_DIRECTORY ID=IM,NAME=\"MY_TOKEN\",TOKEN=TOKEN_TAG\n:exmp.\n:efunc.\n.**********************************************************************\n.se temp = 'Find the Next Item in a Structure'\n:func id=imfdnx name='IM_FIND_NEXT'.&temp.\n.**********************************************************************\n:p.\nThe :#x.IM_FIND_NEXT:e#x. macro\nis used to locate the next item in a structure.\nThis functions is supported for Linked Lists.\nThe item found will become &curim., &curdesc. and  &curityp..\n.*---------------------------------------------------------------------*\n.* Syntax box for the macro form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:mac.\nIM_FIND_NEXT ID=:hp1.id_name:ehp1. &cont.\n&lbt.,SPEPA=:hp1.im_epa:ehp1.&rbt. &cont.\n&lbt.,SPTOKEN=:hp1.im_token:ehp1.&rbt.\n   ,DESCTKN=:hp1.desctkn:ehp1.\n  &lbt.,ITEMTKN=:hp1.itemtkn:ehp1.&rbt.\n  &lbt.,ACTUALSZ=:hp1.actualsz:ehp1.&rbt.\n  &lbt.,CURTKN=:hp1.curtkn:ehp1.&rbt.\n  &lbt.,HEADTKN=:hp1.headtkn:ehp1.&rbt.\n:emac.\n.*---------------------------------------------------------------------*\n.* Syntax box for the CALLX form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:callx.\nCALLX :hp1.im_epa:ehp1.,(:hp1.im_token:ehp1.,&amp.&cont.\nIM_FIND_NEXT,:hp1.desctkn:ehp1.,&cont.\n:hp1.actualsz:ehp1.,:hp1.itemtkn:ehp1.,\n      :hp1.curtkn:ehp1.,:hp1.headtkn:ehp1.)\n:ecallx.\n.*---------------------------------------------------------------------*\n.* Parameter-list table describing each parameter.\n.*---------------------------------------------------------------------*\n:plist.\n:pLt.desctkn\n:pLd.specifies the label of a fullword that contains the token of\ndescriptor that describes the structure in which the item should be\nfound.\n:pLt.actualsz\n:pLd.specifies the label of a fullword into which will be placed the\nactual size of the item found.\n:pLt.itemtkn\n:pLd.specifies the label of a fullword into which will be placed the\ntoken of the item located.\n:pLt.curtkn\n:pLd.specifies the label of a fullword that contains the token of the\ncurrent item in the list.  If this parameter is not specified, the item\nthat is &curdesc. will be used.  If this parameter has a value of zero,\nthe first item in the list will be found.\n:pLt.headtkn\n:pLd.specifies the label of a fullword that contains the token of the\nhead item for the list.  This parameter only applies to lists that do\nnot contain heads in the descriptor.\nIf this parameter is not specified, the item\nthat is &curityp. of the HEADTYPE associated with the descriptor will\nbe used.\n:eplist.\n:fh3.Example\n:p.\nThis instruction will find the next item in the linked list\ndescribed by A_LIST_DESCRIPTOR.\n:xmp.\n         IM_FIND_NEXT ID=IM,DESCTKN=A_LIST_DESCRIPTOR\n:exmp.\n:efunc.\n.**********************************************************************\n.se temp = 'Find the Owner Item of an item in a Structure'\n:func id=imfdow name='IM_FIND_OWNER'.&temp.\n.**********************************************************************\n:p.\nThe :#x.IM_FIND_OWNER:e#x. macro\nis used to locate the owner item of an item in a structure.\nThis functions is supported for Linked Lists.\nThe item found will become &curim. and &curityp..\n.*---------------------------------------------------------------------*\n.* Syntax box for the macro form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:mac.\nIM_FIND_OWNER ID=:hp1.id_name:ehp1. &cont.\n&lbt.,SPEPA=:hp1.im_epa:ehp1.&rbt. &cont.\n&lbt.,SPTOKEN=:hp1.im_token:ehp1.&rbt.\n   ,DESCTKN=:hp1.desctkn:ehp1.\n  &lbt.,ITEMTKN=:hp1.itemtkn:ehp1.&rbt.\n  &lbt.,ACTUALSZ=:hp1.actualsz:ehp1.&rbt.\n  &lbt.,CURTKN=:hp1.curtkn:ehp1.&rbt.\n:emac.\n.*---------------------------------------------------------------------*\n.* Syntax box for the CALLX form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:callx.\nCALLX :hp1.im_epa:ehp1.,(:hp1.im_token:ehp1.,&amp.&cont.\nIM_FIND_OWNER,:hp1.desctkn:ehp1.,&cont.\n:hp1.actualsz:ehp1.,:hp1.itemtkn:ehp1.,:hp1.curtkn:ehp1.)\n:ecallx.\n.*---------------------------------------------------------------------*\n.* Parameter-list table describing each parameter.\n.*---------------------------------------------------------------------*\n:plist.\n:pLt.desctkn\n:pLd.specifies the label of a fullword that contains the token of\ndescriptor that describes the structure in which the item should be\nfound.\n:pLt.actualsz\n:pLd.specifies the label of a fullword into which will be placed the\nactual size of the item found.\n:pLt.itemtkn\n:pLd.specifies the label of a fullword into which will be placed the\ntoken of the item located.\n:pLt.curtkn\n:pLd.specifies the label of a fullword that contains the token of the\nitem in the list for which the owner should be found.\nIf this parameter is not specified, the item\nthat is &curim. will be used.\n:eplist.\n:fh3.Example\n:p.\nThis instruction will find the owner item in the linked list\ndescribed by A_LIST_DESCRIPTOR.\n:xmp.\n         IM_FIND_OWNER ID=IM,DESCTKN=A_LIST_DESCRIPTOR\n:exmp.\n:efunc.\n.**********************************************************************\n.se temp = 'Find the Prior Item in a Structure'\n:func id=imfdpr name='IM_FIND_PRIOR'.&temp.\n.**********************************************************************\n:p.\nThe :#x.IM_FIND_PRIOR:e#x. macro\nis used to locate the prior item in a structure.\nThis functions is supported for Linked Lists.\nThe item found will become &curim., &curdesc. and  &curityp..\n.*---------------------------------------------------------------------*\n.* Syntax box for the macro form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:mac.\nIM_FIND_PRIOR ID=:hp1.id_name:ehp1. &cont.\n&lbt.,SPEPA=:hp1.im_epa:ehp1.&rbt. &cont.\n&lbt.,SPTOKEN=:hp1.im_token:ehp1.&rbt.\n   ,DESCTKN=:hp1.desctkn:ehp1.\n  &lbt.,ITEMTKN=:hp1.itemtkn:ehp1.&rbt.\n  &lbt.,ACTUALSZ=:hp1.actualsz:ehp1.&rbt.\n  &lbt.,HEADTKN=:hp1.headtkn:ehp1.&rbt.\n  &lbt.,CURTKN=:hp1.curtkn:ehp1.&rbt.\n:emac.\n.*---------------------------------------------------------------------*\n.* Syntax box for the CALLX form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:callx.\nCALLX :hp1.im_epa:ehp1.,(:hp1.im_token:ehp1.,&amp.&cont.\nIM_FIND_PRIOR,:hp1.desctkn:ehp1.,&cont.\n:hp1.actualsz:ehp1.,:hp1.itemtkn:ehp1.,\n      :hp1.curtkn:ehp1.,:hp1.headtkn:ehp1.)\n:ecallx.\n.*---------------------------------------------------------------------*\n.* Parameter-list table describing each parameter.\n.*---------------------------------------------------------------------*\n:plist.\n:pLt.desctkn\n:pLd.specifies the label of a fullword that contains the token of\ndescriptor that describes the structure in which the item should be\nfound.\n:pLt.actualsz\n:pLd.specifies the label of a fullword into which will be placed the\nactual size of the item found.\n:pLt.itemtkn\n:pLd.specifies the label of a fullword into which will be placed the\ntoken of the item located.\n:pLt.curtkn\n:pLd.specifies the label of a fullword that contains the token of the\ncurrent item in the list.  If this parameter is not specified, the item\nthat is &curdesc. will be used.  If this parameter has a value of zero,\nthe last item in the list will be found.\n:pLt.headtkn\n:pLd.specifies the label of a fullword that contains the token of the\nhead item for the list.  This parameter only applies to lists that do\nnot contain heads in the descriptor.\nIf this parameter is not specified, the item\nthat is &curityp. of the HEADTYPE associated with the descriptor will\nbe used.\n:eplist.\n:fh3.Example\n:p.\nThis instruction will find the prior item in the linked list\ndescribed by A_LIST_DESCRIPTOR.\n:xmp.\n         IM_FIND_PRIOR ID=IM,DESCTKN=A_LIST_DESCRIPTOR\n:exmp.\n:efunc.\n.**********************************************************************\n.se temp = 'Get an Item'\n:func id=imget  name='IM_GET'.&temp.\n.**********************************************************************\n:p.\nThe :#x.IM_GET:e#x. macro\nis used to obtain the item that is &curim..\nCurrency is not changed.\n.*---------------------------------------------------------------------*\n.* Syntax box for the macro form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:mac.\nIM_GET ID=:hp1.id_name:ehp1. &cont.\n&lbt.,SPEPA=:hp1.im_epa:ehp1.&rbt. &cont.\n&lbt.,SPTOKEN=:hp1.im_token:ehp1.&rbt.\n   ,ITEM=&lbr.:hp1.item:ehp1. | &cont.\n(:hp1.item:ehp1.,:hp1.item_length:ehp1.)&rbr.\n  &lbt.,ITEMTKN=:hp1.itemtkn:ehp1.&rbt.\n  &lbt.,ACTUALSZ=:hp1.actualsz:ehp1.&rbt.\n:emac.\n.*---------------------------------------------------------------------*\n.* Syntax box for the CALLX form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:callx.\nCALLX :hp1.im_epa:ehp1.,(:hp1.im_token:ehp1.,&amp.&cont.\nIM_GET,:hp1.item_length:ehp1.,:hp1.item:ehp1.,&cont.\n:hp1.actualsz:ehp1.,:hp1.itemtkn:ehp1.)\n:ecallx.\n.*---------------------------------------------------------------------*\n.* Parameter-list table describing each parameter.\n.*---------------------------------------------------------------------*\n:plist.\n:pLt.item\n:pLd.specifies the label of the storage into which a copy of the item\nwill be placed.\n:pLt.item_length\n:pLd.specifies the label of a signed binary integer indicating the\nlength of the storage area specified by the :#xi.name:e#xi.\nparameter.  In the macro form, if item_length is not specified,\nan =A(L'item) will be used to determine the length of the storage.\nThis storage can be larger than the actual item, but must be large\nenough to hold the complete item.\n:pLt.actualsz\n:pLd.specifies the label of a fullword into which will be placed the\nactual size of the item found.\n:pLt.itemtkn\n:pLd.specifies the label of a fullword into which will be placed the\ntoken of the item located.\n:eplist.\n:fh3.Example\n:p.\nThis instruction will get the item that is &curim..\n:xmp.\n         IM_GET ID=IM,ITEM=ITEM_WORK_AREA\n:exmp.\n:efunc.\n.**********************************************************************\n.se temp = 'Get Dangerous Addresses'\n:func id=imgetda name='IM_GET_DANGEROUS_ADDRESSES'.&temp.\n.**********************************************************************\n:p.\nThe :#x.IM_GET_DANGEROUS_ADDRESSES:e#x. macro\nis used to get the address of the token-to-virtual-address conversion\nroutine.  This allows direct access to &imms..  Direct access to &imms.\nshould be avoided, but can be accomplished through this routine if\nthere are overriding reasons.  This is the function that will be used\nto externalize any other internal &imgr. functions, as needed.\n.*---------------------------------------------------------------------*\n.* Syntax box for the macro form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:mac.\nIM_GET_DANGEROUS_ADDRESSES ID=:hp1.id_name:ehp1. &cont.\n&lbt.,SPEPA=:hp1.im_epa:ehp1.&rbt. &cont.\n&lbt.,SPTOKEN=:hp1.im_token:ehp1.&rbt.\n  &lbt.,TKNCNVT=:hp1.tkncnvt:ehp1.&rbt.\n:emac.\n.*---------------------------------------------------------------------*\n.* Syntax box for the CALLX form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:callx.\nCALLX :hp1.im_epa:ehp1.,(:hp1.im_token:ehp1.,&amp.&cont.\nIM_GET_DANGEROUS_ADDRESSES,&cont.\n:hp1.tkncnvt:ehp1.)\n:ecallx.\n.*---------------------------------------------------------------------*\n.* Parameter-list table describing each parameter.\n.*---------------------------------------------------------------------*\n:plist.\n:pLt.tkncnvt\n:pLd.specifies the label of a fullword into which will be place the\naddress of the token convertion routine.  If the macro form is used\nand this parameter is not specified, the value of the TKNCNVT keyword\non the corresponding IM_ID macro is used.\n:eplist.\n:fh3.Example\n:p.\nThis instruction will place the address of the conversion routine in\nCONVERT_ADDRESS\n:xmp.\n         IM_GET_DANGEROUS_ADDRESSES ID=IM,TKNCNVT=CONVERT_ADDRESS\n:exmp.\n:efunc.\n.**********************************************************************\n.se temp = 'Initialize &imgr. Managed Storage'\n:func id=iminit name='IM_INITIALIZE'.&temp.\n.**********************************************************************\n:p.\nThe :#x.IM_INITIALIZE:e#x. macro\nis used to initialize &imms..\nIf the &imgr. is not started with a DIV\nservice process specified or if this is the first use of a DIV data\nset, this function must be called.\n:#x.IM_START:e#x. return an return code of\n:#x.&IM_ITEM_STORAGE_NOT_INITIALIZED:e#x.,\nif &imms. needs to be initialized.\n:p.\nSpecifying good values for the parameters of this function is the\nmajor way that you can tune the &imgr..\n.*---------------------------------------------------------------------*\n.* Syntax box for the macro form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:mac.\nIM_INITIALIZE ID=:hp1.id_name:ehp1. &cont.\n&lbt.,SPEPA=:hp1.im_epa:ehp1.&rbt. &cont.\n&lbt.,SPTOKEN=:hp1.im_token:ehp1.&rbt.\n  &lbt.,ITDSTG=:hp1.itdstg:ehp1.&rbt.\n  &lbt.,UAINCR=:hp1.uaincr:ehp1.&rbt.\n  &lbt.,SYSINCR=:hp1.sysincr:ehp1.&rbt.\n  &lbt.,DFLTINCR=:hp1.dfltincr:ehp1.&rbt.\n:emac.\n.*---------------------------------------------------------------------*\n.* Syntax box for the CALLX form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:callx.\nCALLX :hp1.im_epa:ehp1.,(:hp1.im_token:ehp1.,&amp.&cont.\nIM_INITIALIZE,&cont.\n:hp1.itdstg:ehp1.,:hp1.uaincr:ehp1.,:hp1.sysincr:ehp1.,&cont.\n:hp1.dfltincr:ehp1.)\n:ecallx.\n.*---------------------------------------------------------------------*\n.* Parameter-list table describing each parameter.\n.*---------------------------------------------------------------------*\n:plist.\n:pLt.itdstg\n:pLd.specifies the label of a fullword that contains the amount of\n&imms. that should be reserved for item type descriptors.\nThe maximum and the default is 64K.\n:pLt.uaincr\n:pLd.specifies the label of a fullword that contains the amount of\nmain memory that will be obtained, each time that &imms. needs to\nexpand.  This number should be large enough so that few increments\nwill be needed for a session of the &imgr..\nThe default increment is 64K.\n:pLt.sysincr\n:pLd.specifies the label of a fullword that contains the amount of\n&imms. that will be obtained, each time that the system &imms.\nneeds to expand.\nSystem &imms. is used to hold structure descriptors and other system\nitems.\nThe default increment is 4K.\n:pLt.dfltincr\n:pLd.specifies the label of a fullword that contains the amount of\n&imms. that will be obtained each time that the default user &imms.\nneeds to expand.\nDefault user &imms. is used for user items that do not specify another\ngroup.\nThe default increment is 64K.\n:eplist.\n:fh3.Example\n:p.\nThis instruction will place the address of the conversion routine in\nCONVERT_ADDRESS\n:xmp.\n         IM_GET_DANGEROUS_ADDRESSES ID=IM,TKNCNVT=CONVERT_ADDRESS\n:exmp.\n:efunc.\n.**********************************************************************\n.se temp = 'Modify an Item in &imgr. Managed Storage'\n:func id=immdfy name='IM_MODIFY'.&temp.\n.**********************************************************************\n:p.\nThe :#x.IM_MODIFY:e#x. macro\nis used to modify an item in &imms..\nThe length, number of links and offset of links of an item,\ncan not be modified\nwith the :#x.IM_MODIFY:e#x. function.\n.*---------------------------------------------------------------------*\n.* Syntax box for the macro form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:mac.\nIM_MODIFY ID=:hp1.id_name:ehp1. &cont.\n&lbt.,SPEPA=:hp1.im_epa:ehp1.&rbt. &cont.\n&lbt.,SPTOKEN=:hp1.im_token:ehp1.&rbt.\n   ,ITEM=:hp1.item:ehp1.\n  &lbt.,OPTIONS=(&lbt.UPDATE_LINKS&rbt.)&rbt.\n  &lbt.,ITEMTKN=:hp1.itemtkn:ehp1.&rbt.\n:emac.\n.*---------------------------------------------------------------------*\n.* Syntax box for the CALLX form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:callx.\nCALLX :hp1.im_epa:ehp1.,(:hp1.im_token:ehp1.,&amp.&cont.\nIM_MODIFY,&cont.\n:hp1.item:ehp1.,:hp1.optstr:ehp1.,:hp1.itemtkn:ehp1.)\n:ecallx.\n.*---------------------------------------------------------------------*\n.* Parameter-list table describing each parameter.\n.*---------------------------------------------------------------------*\n:plist.\n:pLt.item\n:pLd.specifies the label of the storage into which a copy of the item\nwill be placed.\n:pLt.UPDATE_LINKS\n:pLd.this options indicates that the links will be updated.\nIf this options is not specified, the link fields of the item\nbeing updated are not replaced.\n:pLt.optstr\n:pLd.specifies the label of a byte that contains the options.\nAll bits except bit 1 are reserved.  Bit one corresponds to the\nUPDATE_LINKS option.\n:pLt.itemtkn\n:pLd.specifies the label of a fullword that contains the token of the\nitem to modify.  If this parameter is not specified, the item that\nis &curim. is modified.\n:eplist.\n:fh3.Example\n:p.\nThis instruction will modify the item that is &curim..\n:xmp.\n         IM_MODIFY ID=IM,ITEM=ITEM_WORK_STORAGE\n:exmp.\n:efunc.\n.**********************************************************************\n.se temp = 'Obtain An Item By Its Token'\n:func id=imob name='IM_OBTAIN'.&temp.\n.**********************************************************************\n:p.\nThe :#x.IM_OBTAIN:e#x. macro is used to obtain an item by its item token\nThe item found will become &curim. and &curityp..\n.*---------------------------------------------------------------------*\n.* Syntax box for the macro form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:mac.\nIM_OBTAIN ID=:hp1.id_name:ehp1. &cont.\n&lbt.,SPEPA=:hp1.im_epa:ehp1.&rbt. &cont.\n&lbt.,SPTOKEN=:hp1.im_token:ehp1.&rbt.\n   ,ITEM=&lbr.:hp1.item:ehp1. | &cont.\n(:hp1.item:ehp1.,:hp1.item_length:ehp1.)&rbr.\n  &lbt.,ITEMTKN=:hp1.itemtkn:ehp1.&rbt.\n  &lbt.,ACTUALSZ=:hp1.actualsz:ehp1.&rbt.\n:emac.\n.*---------------------------------------------------------------------*\n.* Syntax box for the CALLX form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:callx.\nCALLX :hp1.im_epa:ehp1.,(:hp1.im_token:ehp1.,&amp.IM_OBTAIN,&cont.\n:hp1.itemtkn:ehp1.,&cont.\n:hp1.item_length:ehp1.,:hp1.item:ehp1.,:hp1.actualsz:ehp1.)\n:ecallx.\n.*---------------------------------------------------------------------*\n.* Parameter-list table describing each parameter.\n.*---------------------------------------------------------------------*\n:plist.\n:pLt.itemtkn\n:pLd.specifies the label of a fullword that contains the token of\nthe item to be obtained.\n:pLt.item\n:pLd.specifies the label of the storage into which a copy of the item\nwill be placed.\n:pLt.item_length\n:pLd.specifies the label of a signed binary integer indicating the\nlength of the storage area specified by the :#xi.name:e#xi.\nparameter.  In the macro form, if item_length is not specified,\nan =A(L'item) will be used to determine the length of the storage.\nThis storage can be larger than the actual item, but must be large\nenough to hold the complete item.\n:pLt.actualsz\n:pLd.specifies the label of a fullword into which will be place the\nactual size of the item found.\n:eplist.\n:fh3.Example\n:p.\nThis instruction will obtain the item whose token is in the fullword\nat label ITEM_TOKEN.\n:xmp.\n         IM_OBTAIN ID=IM,ITEMTKN=ITEM_TOKEN\n:exmp.\n:efunc.\n.**********************************************************************\n.se temp = 'Obtain An Item By Key'\n:func id=imobky name='IM_OBTAIN_BY_KEY'.&temp.\n.**********************************************************************\n:p.\nThe :#x.IM_OBTAIN_BY_KEY:e#x. macro\nis used to obtain an item by its key.\nThe item found will become &curim. and &curityp..\n.*---------------------------------------------------------------------*\n.* Syntax box for the macro form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:mac.\nIM_OBTAIN_BY_KEY ID=:hp1.id_name:ehp1. &cont.\n&lbt.,SPEPA=:hp1.im_epa:ehp1.&rbt. &cont.\n&lbt.,SPTOKEN=:hp1.im_token:ehp1.&rbt.\n   ,DESCTKN=:hp1.desctkn:ehp1.\n   ,KEY=:hp1.key:ehp1. | &cont.\n(:hp1.key:ehp1.,:hp1.key_length:ehp1.)\n   ,ITEM=&lbr.:hp1.item:ehp1. | &cont.\n(:hp1.item:ehp1.,:hp1.item_length:ehp1.)&rbr.\n  &lbt.,ITEMTKN=:hp1.itemtkn:ehp1.&rbt.\n  &lbt.,ACTUALSZ=:hp1.actualsz:ehp1.&rbt.\n:emac.\n.*---------------------------------------------------------------------*\n.* Syntax box for the CALLX form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:callx.\nCALLX :hp1.im_epa:ehp1.,(:hp1.im_token:ehp1.,&amp.IM_OBTAIN_BY_KEY,&cont\n:hp1.desctkn:ehp1.,:hp1.key_length:ehp1.,:hp1.key:ehp1.,\n      :hp1.item_length:ehp1.,:hp1.item:ehp1.,&cont.\n:hp1.actualsz:ehp1.,:hp1.itemtkn:ehp1.)\n:ecallx.\n.*---------------------------------------------------------------------*\n.* Parameter-list table describing each parameter.\n.*---------------------------------------------------------------------*\n:plist.\n:pLt.desctkn\n:pLd.specifies the label of a fullword that contains the token of\ndescriptor that describes the structure in which the item should be\nfound.\n:pLt.key_length\n:pLd.specifies a fullword that contains the length of the key.  Trailing\nblanks are ignored in the compare, so the key can still match a item\nin &imms. even if the key length of that item is not the same\nas the key length specified.\n:pLt.key\n:pLd.specifies the label of a field that contains the key of the item\nto obtain.\n:pLt.item\n:pLd.specifies the label of the storage into which a copy of the item\nwill be placed.\n:pLt.item_length\n:pLd.specifies the label of a signed binary integer indicating the\nlength of the storage area specified by the :#xi.name:e#xi.\nparameter.  In the macro form, if item_length is not specified,\nan =A(L'item) will be used to determine the length of the storage.\nThis storage can be larger than the actual item, but must be large\nenough to hold the complete item.\n:pLt.actualsz\n:pLd.specifies the label of a fullword into which will be placed the\nactual size of the item found.\n:pLt.itemtkn\n:pLd.specifies the label of a fullword into which will be placed the\ntoken of the item obtained.\n:eplist.\n:fh3.Example\n:p.\nThis instruction will obtain the item in the linked list described by\nA_LIST_DESCRIPTOR that has a key of \"XYZZY\".\n:xmp.\n         IM_OBTAIN_BY_KEY ID=IM,DESCTKN=A_LIST_DESCRIPTOR,KEY=\"XYZZY\"\n:exmp.\n:efunc.\n.**********************************************************************\n.se temp = 'Obtain the Item That is Current of Descriptor'\n:func id=imobcd name='IM_OBTAIN_CURRENT_OF_DESCRIPTOR'.&temp.\n.**********************************************************************\n:p.\nThe :#x.IM_OBTAIN_CURRENT_OF_DESCRIPTOR:e#x. macro\nis used to obtain an item that is current of a given descriptor.\nThe item found will become &curim. and &curityp..\n.*---------------------------------------------------------------------*\n.* Syntax box for the macro form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:mac.\nIM_OBTAIN_CURRENT_OF_DESCRIPTOR ID=:hp1.id_name:ehp1.\n  &lbt.,SPEPA=:hp1.im_epa:ehp1.&rbt. &cont.\n&lbt.,SPTOKEN=:hp1.im_token:ehp1.&rbt.\n   ,DESCTKN=:hp1.desctkn:ehp1.\n   ,ITEM=&lbr.:hp1.item:ehp1. | &cont.\n(:hp1.item:ehp1.,:hp1.item_length:ehp1.)&rbr.\n  &lbt.,ITEMTKN=:hp1.itemtkn:ehp1.&rbt.\n  &lbt.,ACTUALSZ=:hp1.actualsz:ehp1.&rbt.\n:emac.\n.*---------------------------------------------------------------------*\n.* Syntax box for the CALLX form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:callx.\nCALLX :hp1.im_epa:ehp1.,(:hp1.im_token:ehp1.,&amp.&cont.\nIM_OBTAIN_CURRENT_OF_DESCRIPTOR,&cont.\n:hp1.desctkn:ehp1.,\n      :hp1.item_length:ehp1.,:hp1.item:ehp1.,&cont.\n:hp1.actualsz:ehp1.,:hp1.itemtkn:ehp1.)\n:ecallx.\n.*---------------------------------------------------------------------*\n.* Parameter-list table describing each parameter.\n.*---------------------------------------------------------------------*\n:plist.\n:pLt.desctkn\n:pLd.specifies the label of a fullword that contains the token of\ndescriptor that describes the structure in which the item should be\nfound.\n:pLt.item\n:pLd.specifies the label of the storage into which a copy of the item\nwill be placed.\n:pLt.item_length\n:pLd.specifies the label of a signed binary integer indicating the\nlength of the storage area specified by the :#xi.name:e#xi.\nparameter.  In the macro form, if item_length is not specified,\nan =A(L'item) will be used to determine the length of the storage.\nThis storage can be larger than the actual item, but must be large\nenough to hold the complete item.\n:pLt.actualsz\n:pLd.specifies the label of a fullword into which will be placed the\nactual size of the item found.\n:pLt.itemtkn\n:pLd.specifies the label of a fullword into which will be placed the\ntoken of the item obtained.\n:eplist.\n:fh3.Example\n:p.\nThis instruction will obtain the item that is current of descriptor for\nthe structure described by A_LIST_DESCRIPTOR.\n:xmp.\n         IM_OBTAIN_CURRENT_OF_DESCRIPTOR ID=IM,DESCTKN=A_LIST_DESCRIPTOR\n:exmp.\n:efunc.\n.**********************************************************************\n.se temp = 'Obtain the Item That is Current of Item Type'\n:func id=imobit name='IM_OBTAIN_CURRENT_OF_ITEM_TYPE'.&temp.\n.**********************************************************************\n:p.\nThe :#x.IM_OBTAIN_CURRENT_OF_ITEM_TYPE:e#x. macro\nis used to obtain an item that is current of a given item type.\nThe item found will become &curim. and remain &curityp..\n.*---------------------------------------------------------------------*\n.* Syntax box for the macro form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:mac.\nIM_OBTAIN_CURRENT_OF_ITEM_TYPE ID=:hp1.id_name:ehp1.\n  &lbt.,SPEPA=:hp1.im_epa:ehp1.&rbt. &cont.\n&lbt.,SPTOKEN=:hp1.im_token:ehp1.&rbt.\n   ,ITEMTYPE=:hp1.itemtype:ehp1.\n   ,ITEM=&lbr.:hp1.item:ehp1. | &cont.\n(:hp1.item:ehp1.,:hp1.item_length:ehp1.)&rbr.\n  &lbt.,ITEMTKN=:hp1.itemtkn:ehp1.&rbt.\n  &lbt.,ACTUALSZ=:hp1.actualsz:ehp1.&rbt.\n:emac.\n.*---------------------------------------------------------------------*\n.* Syntax box for the CALLX form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:callx.\nCALLX :hp1.im_epa:ehp1.,(:hp1.im_token:ehp1.,&amp.&cont.\nIM_OBTAIN_ITEM_TYPE,&cont.\n:hp1.itemtype:ehp1.,\n      :hp1.item_length:ehp1.,:hp1.item:ehp1.,&cont.\n:hp1.actualsz:ehp1.,:hp1.itemtkn:ehp1.)\n:ecallx.\n.*---------------------------------------------------------------------*\n.* Parameter-list table describing each parameter.\n.*---------------------------------------------------------------------*\n:plist.\n:pLt.itemtype\n:pLd.specifies the label of a halfword that contains the token of\nitem type descriptor\nfor the item that should be\nfound.\n:pLt.item\n:pLd.specifies the label of the storage into which a copy of the item\nwill be placed.\n:pLt.item_length\n:pLd.specifies the label of a signed binary integer indicating the\nlength of the storage area specified by the :#xi.name:e#xi.\nparameter.  In the macro form, if item_length is not specified,\nan =A(L'item) will be used to determine the length of the storage.\nThis storage can be larger than the actual item, but must be large\nenough to hold the complete item.\n:pLt.actualsz\n:pLd.specifies the label of a fullword into which will be placed the\nactual size of the item found.\n:pLt.itemtkn\n:pLd.specifies the label of a fullword into which will be placed the\ntoken of the item obtained.\n:eplist.\n:fh3.Example\n:p.\nThis instruction will obtain the item that is current of item type for\nthe structure described by A_LIST_DESCRIPTOR.\n:xmp.\n         IM_OBTAIN_CURRENT_OF_ITEM_TYPE ID=IM,DESCTKN=A_LIST_DESCRIPTOR\n:exmp.\n:efunc.\n.**********************************************************************\n.se temp = 'Obtain the Final Item in a Structure'\n:func id=imobfn name='IM_OBTAIN_FINAL'.&temp.\n.**********************************************************************\n:p.\nThe :#x.IM_OBTAIN_FINAL:e#x. macro\nis used to obtain the final item in a structure.\nThis functions is supported for Linked Lists.\nThe item found will become &curim., &curdesc. and  &curityp..\n.*---------------------------------------------------------------------*\n.* Syntax box for the macro form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:mac.\nIM_OBTAIN_FINAL ID=:hp1.id_name:ehp1. &cont.\n&lbt.,SPEPA=:hp1.im_epa:ehp1.&rbt. &cont.\n&lbt.,SPTOKEN=:hp1.im_token:ehp1.&rbt.\n   ,DESCTKN=:hp1.desctkn:ehp1.\n   ,ITEM=&lbr.:hp1.item:ehp1. | &cont.\n(:hp1.item:ehp1.,:hp1.item_length:ehp1.)&rbr.\n  &lbt.,ITEMTKN=:hp1.itemtkn:ehp1.&rbt.\n  &lbt.,ACTUALSZ=:hp1.actualsz:ehp1.&rbt.\n  &lbt.,HEADTKN=:hp1.headtkn:ehp1.&rbt.\n:emac.\n.*---------------------------------------------------------------------*\n.* Syntax box for the CALLX form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:callx.\nCALLX :hp1.im_epa:ehp1.,(:hp1.im_token:ehp1.,&amp.&cont.\nIM_OBTAIN_FINAL,&cont.\n:hp1.desctkn:ehp1.,\n      :hp1.item_length:ehp1.,:hp1.item:ehp1.,&cont.\n:hp1.actualsz:ehp1.,:hp1.itemtkn:ehp1.,:hp1.headtkn:ehp1.)\n:ecallx.\n.*---------------------------------------------------------------------*\n.* Parameter-list table describing each parameter.\n.*---------------------------------------------------------------------*\n:plist.\n:pLt.desctkn\n:pLd.specifies the label of a fullword that contains the token of\ndescriptor that describes the structure in which the item should be\nfound.\n:pLt.item\n:pLd.specifies the label of the storage into which a copy of the item\nwill be placed.\n:pLt.item_length\n:pLd.specifies the label of a signed binary integer indicating the\nlength of the storage area specified by the :#xi.name:e#xi.\nparameter.  In the macro form, if item_length is not specified,\nan =A(L'item) will be used to determine the length of the storage.\nThis storage can be larger than the actual item, but must be large\nenough to hold the complete item.\n:pLt.actualsz\n:pLd.specifies the label of a fullword into which will be placed the\nactual size of the item found.\n:pLt.itemtkn\n:pLd.specifies the label of a fullword into which will be placed the\ntoken of the item obtained.\n:pLt.headtkn\n:pLd.specifies the label of a fullword that contains the token of the\nhead item for the list.  This parameter only applies to lists that do\nnot contain heads in the descriptor.\nIf this parameter is not specified, the item\nthat is &curityp. of the HEADTYPE associated with the descriptor will\nbe used.\n:eplist.\n:fh3.Example\n:p.\nThis instruction will obtain the final item in the linked list\ndescribed by A_LIST_DESCRIPTOR.\n:xmp.\n         IM_OBTAIN_FINAL ID=IM,DESCTKN=A_LIST_DESCRIPTOR\n:exmp.\n:efunc.\n.**********************************************************************\n.se temp = 'Obtain the First Item in a Structure'\n:func id=imobfr name='IM_OBTAIN_FIRST'.&temp.\n.**********************************************************************\n:p.\nThe :#x.IM_OBTAIN_FIRST:e#x. macro\nis used to obtain the first item in a structure.\nThis functions is supported for Linked Lists.\nThe item found will become &curim., &curdesc. and  &curityp..\n.*---------------------------------------------------------------------*\n.* Syntax box for the macro form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:mac.\nIM_OBTAIN_FIRST ID=:hp1.id_name:ehp1. &cont.\n&lbt.,SPEPA=:hp1.im_epa:ehp1.&rbt. &cont.\n&lbt.,SPTOKEN=:hp1.im_token:ehp1.&rbt.\n   ,DESCTKN=:hp1.desctkn:ehp1.\n   ,ITEM=&lbr.:hp1.item:ehp1. | &cont.\n(:hp1.item:ehp1.,:hp1.item_length:ehp1.)&rbr.\n  &lbt.,ITEMTKN=:hp1.itemtkn:ehp1.&rbt.\n  &lbt.,ACTUALSZ=:hp1.actualsz:ehp1.&rbt.\n  &lbt.,HEADTKN=:hp1.headtkn:ehp1.&rbt.\n:emac.\n.*---------------------------------------------------------------------*\n.* Syntax box for the CALLX form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:callx.\nCALLX :hp1.im_epa:ehp1.,(:hp1.im_token:ehp1.,&amp.&cont.\nIM_OBTAIN_FIRST,&cont.\n:hp1.desctkn:ehp1.,\n      :hp1.item_length:ehp1.,:hp1.item:ehp1.,&cont.\n:hp1.actualsz:ehp1.,:hp1.itemtkn:ehp1.,:hp1.headtkn:ehp1.)\n:ecallx.\n.*---------------------------------------------------------------------*\n.* Parameter-list table describing each parameter.\n.*---------------------------------------------------------------------*\n:plist.\n:pLt.desctkn\n:pLd.specifies the label of a fullword that contains the token of\ndescriptor that describes the structure in which the item should be\nfound.\n:pLt.item\n:pLd.specifies the label of the storage into which a copy of the item\nwill be placed.\n:pLt.item_length\n:pLd.specifies the label of a signed binary integer indicating the\nlength of the storage area specified by the :#xi.name:e#xi.\nparameter.  In the macro form, if item_length is not specified,\nan =A(L'item) will be used to determine the length of the storage.\nThis storage can be larger than the actual item, but must be large\nenough to hold the complete item.\n:pLt.actualsz\n:pLd.specifies the label of a fullword into which will be placed the\nactual size of the item found.\n:pLt.itemtkn\n:pLd.specifies the label of a fullword into which will be placed the\ntoken of the item obtained.\n:pLt.headtkn\n:pLd.specifies the label of a fullword that contains the token of the\nhead item for the list.  This parameter only applies to lists that do\nnot contain heads in the descriptor.\nIf this parameter is not specified, the item\nthat is &curityp. of the HEADTYPE associated with the descriptor will\nbe used.\n:eplist.\n:fh3.Example\n:p.\nThis instruction will obtain the first item in the linked list\ndescribed by A_LIST_DESCRIPTOR.\n:xmp.\n         IM_OBTAIN_FIRST ID=IM,DESCTKN=A_LIST_DESCRIPTOR\n:exmp.\n:efunc.\n.**********************************************************************\n.se temp = 'Obtain the Next Item in a Structure'\n:func id=imobnx name='IM_OBTAIN_NEXT'.&temp.\n.**********************************************************************\n:p.\nThe :#x.IM_OBTAIN_NEXT:e#x. macro\nis used to obtain the next item in a structure.\nThis functions is supported for Linked Lists.\nThe item found will become &curim., &curdesc. and  &curityp..\n.*---------------------------------------------------------------------*\n.* Syntax box for the macro form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:mac.\nIM_OBTAIN_NEXT ID=:hp1.id_name:ehp1. &cont.\n&lbt.,SPEPA=:hp1.im_epa:ehp1.&rbt. &cont.\n&lbt.,SPTOKEN=:hp1.im_token:ehp1.&rbt.\n   ,DESCTKN=:hp1.desctkn:ehp1.\n   ,ITEM=&lbr.:hp1.item:ehp1. | &cont.\n(:hp1.item:ehp1.,:hp1.item_length:ehp1.)&rbr.\n  &lbt.,ITEMTKN=:hp1.itemtkn:ehp1.&rbt.\n  &lbt.,ACTUALSZ=:hp1.actualsz:ehp1.&rbt.\n  &lbt.,CURTKN=:hp1.curtkn:ehp1.&rbt.\n  &lbt.,HEADTKN=:hp1.headtkn:ehp1.&rbt.\n:emac.\n.*---------------------------------------------------------------------*\n.* Syntax box for the CALLX form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:callx.\nCALLX :hp1.im_epa:ehp1.,(:hp1.im_token:ehp1.,&amp.&cont.\nIM_OBTAIN_NEXT,&cont.\n:hp1.desctkn:ehp1.,\n      :hp1.item_length:ehp1.,:hp1.item:ehp1.,&cont.\n:hp1.actualsz:ehp1.,:hp1.itemtkn:ehp1.,&cont.\n:hp1.curtkn:ehp1.,:hp1.headtkn:ehp1.)\n:ecallx.\n.*---------------------------------------------------------------------*\n.* Parameter-list table describing each parameter.\n.*---------------------------------------------------------------------*\n:plist.\n:pLt.desctkn\n:pLd.specifies the label of a fullword that contains the token of\ndescriptor that describes the structure in which the item should be\nfound.\n:pLt.item\n:pLd.specifies the label of the storage into which a copy of the item\nwill be placed.\n:pLt.item_length\n:pLd.specifies the label of a signed binary integer indicating the\nlength of the storage area specified by the :#xi.name:e#xi.\nparameter.  In the macro form, if item_length is not specified,\nan =A(L'item) will be used to determine the length of the storage.\nThis storage can be larger than the actual item, but must be large\nenough to hold the complete item.\n:pLt.actualsz\n:pLd.specifies the label of a fullword into which will be placed the\nactual size of the item found.\n:pLt.itemtkn\n:pLd.specifies the label of a fullword into which will be placed the\ntoken of the item obtained.\n:pLt.curtkn\n:pLd.specifies the label of a fullword that contains the token of the\ncurrent item in the list.  If this parameter is not specified, the item\nthat is &curdesc. will be used.  If this parameter has a value of zero,\nthe first item in the list will be obtained.\n:pLt.headtkn\n:pLd.specifies the label of a fullword that contains the token of the\nhead item for the list.  This parameter only applies to lists that do\nnot contain heads in the descriptor.\nIf this parameter is not specified, the item\nthat is &curityp. of the HEADTYPE associated with the descriptor will\nbe used.\n:eplist.\n:fh3.Example\n:p.\nThis instruction will obtain the next item in the linked list\ndescribed by A_LIST_DESCRIPTOR.\n:xmp.\n         IM_OBTAIN_NEXT ID=IM,DESCTKN=A_LIST_DESCRIPTOR\n:exmp.\n:efunc.\n.**********************************************************************\n.se temp = 'Obtain the Owner Item of a Structure'\n:func id=imobow name='IM_OBTAIN_OWNER'.&temp.\n.**********************************************************************\n:p.\nThe :#x.IM_OBTAIN_OWNER:e#x. macro\nis used to obtain the owner item of a structure.\nThis functions is supported for Linked Lists.\nThe item found will become &curim., &curdesc. and  &curityp..\n.*---------------------------------------------------------------------*\n.* Syntax box for the macro form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:mac.\nIM_OBTAIN_OWNER ID=:hp1.id_name:ehp1. &cont.\n&lbt.,SPEPA=:hp1.im_epa:ehp1.&rbt. &cont.\n&lbt.,SPTOKEN=:hp1.im_token:ehp1.&rbt.\n   ,DESCTKN=:hp1.desctkn:ehp1.\n   ,ITEM=&lbr.:hp1.item:ehp1. | &cont.\n(:hp1.item:ehp1.,:hp1.item_length:ehp1.)&rbr.\n  &lbt.,ITEMTKN=:hp1.itemtkn:ehp1.&rbt.\n  &lbt.,ACTUALSZ=:hp1.actualsz:ehp1.&rbt.\n  &lbt.,CURTKN=:hp1.curtkn:ehp1.&rbt.\n:emac.\n.*---------------------------------------------------------------------*\n.* Syntax box for the CALLX form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:callx.\nCALLX :hp1.im_epa:ehp1.,(:hp1.im_token:ehp1.,&amp.&cont.\nIM_OBTAIN_OWNER,&cont.\n:hp1.desctkn:ehp1.,\n      :hp1.item_length:ehp1.,:hp1.item:ehp1.,&cont.\n:hp1.actualsz:ehp1.,:hp1.itemtkn:ehp1.,:hp1.curtkn:ehp1.)\n:ecallx.\n.*---------------------------------------------------------------------*\n.* Parameter-list table describing each parameter.\n.*---------------------------------------------------------------------*\n:plist.\n:pLt.desctkn\n:pLd.specifies the label of a fullword that contains the token of\ndescriptor that describes the structure in which the item should be\nfound.\n:pLt.item\n:pLd.specifies the label of the storage into which a copy of the item\nwill be placed.\n:pLt.item_length\n:pLd.specifies the label of a signed binary integer indicating the\nlength of the storage area specified by the :#xi.name:e#xi.\nparameter.  In the macro form, if item_length is not specified,\nan =A(L'item) will be used to determine the length of the storage.\nThis storage can be larger than the actual item, but must be large\nenough to hold the complete item.\n:pLt.actualsz\n:pLd.specifies the label of a fullword into which will be placed the\nactual size of the item found.\n:pLt.itemtkn\n:pLd.specifies the label of a fullword into which will be placed the\ntoken of the item obtained.\n:pLt.curtkn\n:pLd.specifies the label of a fullword that contains the token of the\ncurrent item in the list.  If this parameter is not specified, the item\nthat is &curim. will be used.\n:eplist.\n:fh3.Example\n:p.\nThis instruction will obtain the owner item in the linked list\ndescribed by A_LIST_DESCRIPTOR.\n:xmp.\n         IM_OBTAIN_OWNER ID=IM,DESCTKN=A_LIST_DESCRIPTOR\n:exmp.\n:efunc.\n.**********************************************************************\n.se temp = 'Obtain the Prior Item in a Structure'\n:func id=imobpr name='IM_OBTAIN_PRIOR'.&temp.\n.**********************************************************************\n:p.\nThe :#x.IM_OBTAIN_PRIOR:e#x. macro\nis used to obtain the prior item in a structure.\nThis functions is supported for Linked Lists.\nThe item found will become &curim., &curdesc. and  &curityp..\n.*---------------------------------------------------------------------*\n.* Syntax box for the macro form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:mac.\nIM_OBTAIN_PRIOR ID=:hp1.id_name:ehp1. &cont.\n&lbt.,SPEPA=:hp1.im_epa:ehp1.&rbt. &cont.\n&lbt.,SPTOKEN=:hp1.im_token:ehp1.&rbt.\n   ,DESCTKN=:hp1.desctkn:ehp1.\n   ,ITEM=&lbr.:hp1.item:ehp1. | &cont.\n(:hp1.item:ehp1.,:hp1.item_length:ehp1.)&rbr.\n  &lbt.,ITEMTKN=:hp1.itemtkn:ehp1.&rbt.\n  &lbt.,ACTUALSZ=:hp1.actualsz:ehp1.&rbt.\n  &lbt.,CURTKN=:hp1.curtkn:ehp1.&rbt.\n  &lbt.,HEADTKN=:hp1.headtkn:ehp1.&rbt.\n:emac.\n.*---------------------------------------------------------------------*\n.* Syntax box for the CALLX form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:callx.\nCALLX :hp1.im_epa:ehp1.,(:hp1.im_token:ehp1.,&amp.&cont.\nIM_OBTAIN_PRIOR,&cont.\n:hp1.desctkn:ehp1.,\n      :hp1.item_length:ehp1.,:hp1.item:ehp1.,&cont.\n:hp1.actualsz:ehp1.,:hp1.itemtkn:ehp1.,&cont.\n:hp1.curtkn:ehp1.,:hp1.headtkn:ehp1.)\n:ecallx.\n.*---------------------------------------------------------------------*\n.* Parameter-list table describing each parameter.\n.*---------------------------------------------------------------------*\n:plist.\n:pLt.desctkn\n:pLd.specifies the label of a fullword that contains the token of\ndescriptor that describes the structure in which the item should be\nfound.\n:pLt.item\n:pLd.specifies the label of the storage into which a copy of the item\nwill be placed.\n:pLt.item_length\n:pLd.specifies the label of a signed binary integer indicating the\nlength of the storage area specified by the :#xi.name:e#xi.\nparameter.  In the macro form, if item_length is not specified,\nan =A(L'item) will be used to determine the length of the storage.\nThis storage can be larger than the actual item, but must be large\nenough to hold the complete item.\n:pLt.actualsz\n:pLd.specifies the label of a fullword into which will be placed the\nactual size of the item found.\n:pLt.itemtkn\n:pLd.specifies the label of a fullword into which will be placed the\ntoken of the item obtained.\n:pLt.curtkn\n:pLd.specifies the label of a fullword that contains the token of the\ncurrent item in the list.  If this parameter is not specified, the item\nthat is &curdesc. will be used.  If this parameter has a value of zero,\nthe last item in the list will be obtained.\n:pLt.headtkn\n:pLd.specifies the label of a fullword that contains the token of the\nhead item for the list.  This parameter only applies to lists that do\nnot contain heads in the descriptor.\nIf this parameter is not specified, the item\nthat is &curityp. of the HEADTYPE associated with the descriptor will\nbe used.\n:eplist.\n:fh3.Example\n:p.\nThis instruction will obtain the prior item in the linked list\ndescribed by A_LIST_DESCRIPTOR.\n:xmp.\n         IM_OBTAIN_PRIOR ID=IM,DESCTKN=A_LIST_DESCRIPTOR\n:exmp.\n:efunc.\n.**********************************************************************\n.se temp = 'Remove An Item Token from The Token Directory'\n:func id=imrmdr name='IM_REMOVE_FROM_DIRECTORY'.&temp.\n.**********************************************************************\n:p.\nThe :#x.IM_REMOVE_FROM_DIRECTORY:e#x. macro\nis used to unassociate a name with an item token in the token directory.\nCurrency is not changed.\n:p.\nThis function is not yet implemented.\n.*---------------------------------------------------------------------*\n.* Syntax box for the macro form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:mac.\nIM_REMOVE_FROM_DIRECTORY ID=:hp1.id_name:ehp1. &cont.\n&lbt.,SPEPA=:hp1.im_epa:ehp1.&rbt. &cont.\n&lbt.,SPTOKEN=:hp1.im_token:ehp1.&rbt.\n   ,NAME=&lbr.:hp1.name:ehp1. | &cont.\n(:hp1.name:ehp1.,:hp1.name_length:ehp1.)&rbr.\n:emac.\n.*---------------------------------------------------------------------*\n.* Syntax box for the CALLX form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:callx.\nCALLX :hp1.im_epa:ehp1.,(:hp1.im_token:ehp1.,&amp.&cont.\nIM_REMOVE_FROM_DIRECTORY,&cont.\n:hp1.name_length:ehp1.,:hp1.name:ehp1.)\n:ecallx.\n.*---------------------------------------------------------------------*\n.* Parameter-list table describing each parameter.\n.*---------------------------------------------------------------------*\n:plist.\n:pLt.name\n:pLd.specifies the label of a string that contains the name that is\nassociated with the token specified with the :#xi.token:e#xi.\nparameter.\n:pLt.name_length\n:pLd.specifies the label of a signed binary integer indicating the\nlength of the string identified by the :#xi.name:e#xi.\nparameter.\n:eplist.\n:fh3.Example\n:p.\nThis instruction will remove the name\n\"MY_TOKEN\" from the token directory.\n:xmp.\n         IM_REMOVE_FROM_DIRECTORY ID=IM,NAME=\"MY_TOKEN\"\n:exmp.\n:efunc.\n.**********************************************************************\n.se temp = 'Reset &imms. to Its Initial Contents'\n:func id=imrset name='IM_RESET'.&temp.\n.**********************************************************************\n:p.\nThe :#x.IM_RESET:e#x. macro\nis used to reset &imms. to its contents at the time of the last\n:#x.IM_SAVE:e#x. function.\nThis function is only\nvalid if a DIV service process was specified on the :#x.IM_START:e#x.\ncall.  This function will invoke the DV_RESET function of the associated\nDIV service processor.\n.*---------------------------------------------------------------------*\n.* Syntax box for the macro form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:mac.\nIM_RESET ID=:hp1.id_name:ehp1. &cont.\n&lbt.,SPEPA=:hp1.im_epa:ehp1.&rbt. &cont.\n&lbt.,SPTOKEN=:hp1.im_token:ehp1.&rbt.\n:emac.\n.*---------------------------------------------------------------------*\n.* Syntax box for the CALLX form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:callx.\nCALLX :hp1.im_epa:ehp1.,(:hp1.im_token:ehp1.,&amp.&cont.\nIM_RESET)\n:ecallx.\n:fh3.Example\n:p.\nThis instruction will reset &imms. to its value since the last save.\n:xmp.\n         IM_RESET ID=IM\n:exmp.\n:efunc.\n.**********************************************************************\n.se temp = 'Save &imms.'\n:func id=imsave name='IM_SAVE'.&temp.\n.**********************************************************************\n:p.\nThe :#x.IM_SAVE:e#x. function\nis used to save &imms..  This function is only\nvalid if a DIV service process was specified on the :#x.IM_START:e#x.\ncall.  This function will invoke the DV_SAVE function of the associated\nDIV service processor.\n.*---------------------------------------------------------------------*\n.* Syntax box for the macro form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:mac.\nIM_SAVE ID=:hp1.id_name:ehp1. &cont.\n&lbt.,SPEPA=:hp1.im_epa:ehp1.&rbt. &cont.\n&lbt.,SPTOKEN=:hp1.im_token:ehp1.&rbt.\n:emac.\n.*---------------------------------------------------------------------*\n.* Syntax box for the CALLX form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:callx.\nCALLX :hp1.im_epa:ehp1.,(:hp1.im_token:ehp1.,&amp.&cont.\nIM_SAVE)\n:ecallx.\n:fh3.Example\n:p.\nThis instruction will save &imms..\n:xmp.\n         IM_SAVE ID=IM\n:exmp.\n:efunc.\n.**********************************************************************\n.se temp = 'SFD Mapping Macro'\n:func id=imsfd name='IM_SFD'.&temp.\n.**********************************************************************\n:p.\nThe :#x.IM_SFD:e#x. macro is used to map a Sort Fields Descriptions\n(SFD) entry.\n.*---------------------------------------------------------------------*\n.* Syntax box for the macro form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:mac.\nIM_SFD &lbt.ID=cbid&rbt.\n  &lbt.,DSECT=:hp1.dsectopt:ehp1.&rbt.\n:emac.\n.*---------------------------------------------------------------------*\n.* Parameter-list table describing each parameter.\n.*---------------------------------------------------------------------*\n:plist.\n:pLt.cbid\n:pLd.specifies the id to be place as a prefix to each generated tag.\n:pLt.dsectopt\n:pLd.either YES or NO to indicate whether a DSECT should be generated.\n:eplist.\n:fh3.Example\n:p.\nThis instruction will generate a mapping dsect for the SFD.\n:xmp.\n         IM_SFD\n:exmp.\n:efunc.\n.**********************************************************************\n.se temp = 'Sort a List'\n:func id=imsort name='IM_SORT'.&temp.\n.**********************************************************************\n:p.\nThe :#x.IM_SORT:e#x. function\nis used to sort a list.\n.*---------------------------------------------------------------------*\n.* Syntax box for the macro form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:mac.\nIM_SORT ID=:hp1.id_name:ehp1. &cont.\n&lbt.,SPEPA=:hp1.im_epa:ehp1.&rbt. &cont.\n&lbt.,SPTOKEN=:hp1.im_token:ehp1.&rbt.\n   ,DESCTKN=:hp1.desctkn:ehp1.\n   ,FIELDS=&lbr.:hp1.fields:ehp1. | &cont.\n,FIELDSLIST=:hp1.fieldslist:ehp1.\n  &lbt.,TECHNIQUE=(&lbt.QUICK_SORT&rbt. | &cont.\n&lbt.BUBBLE_SORT&rbt.)&rbt.\n  &lbt.,HEADTKN=:hp1.itemtkn:ehp1.&rbt.\n:emac.\n.*---------------------------------------------------------------------*\n.* Syntax box for the CALLX form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:callx.\nCALLX :hp1.im_epa:ehp1.,(:hp1.im_token:ehp1.,&amp.&cont.\nIM_SORT,:hp1.desctkn:ehp1.,:hp1.fieldslist:ehp1.,\n      :hp1.headtkn:ehp1.,:hp1.technique:ehp1.)\n:ecallx.\n.*---------------------------------------------------------------------*\n.* Parameter-list table describing each parameter.\n.*---------------------------------------------------------------------*\n:plist.\n:pLt.desctkn\n:pLd.specifies the label of a fullword that contains the token of\ndescriptor that describes the list of items to be sorted.\n:pLt.fields\n:pLd.specifies the sort fields.  See :hdref refid=imstfd. for the\nsyntax of this parameter.\n:pLt.fieldslist\n:pLd.specifies a location that contains the Sort Fields Definitions\n(SFD).\nRefer to :hdref refid=imstfd. or :hdref refid=imsfd. for information\nneeded to build the SFD.\n:pLt.QUICK_SORT\n:pLd.specifies that quick sort should be used to sort the list.  This\nis the default sort techinque.  It is very fast for all but very small\nlists, which are slowed by the setup required.\nIt should always be used except when\nvery small lists are sorted many times.  It uses a partiton\nexchange sort algorithm with improvements by Richard C. Singleton.\nSee ACM Algorithm 347 \"An Efficient Algorithm For Sorting With\nMinimal Storage {M1}\" for more information.\n:pLt.BUBBLE_SORT\n:pLd.specifies that bubble sort should be used to sort the list.  This\nis a very slow sort techinque except for very short list (10 or less\nitems).\n:pLt.technique\n:pLd.specifies a fullword that contains the sort technique to be used.\nSymbols :#x.IM_SORT_TECHNIQUE_QUICK_SORT:e#x. and\n:#x.IM_SORT_TECHNIQUE_BUBBLE_SORT:e#x. can be used to specify\nthis technique.  The default is quick sort.\n:pLt.headtkn\n:pLd.specifies the label of a fullword that contains the token of\nthe item that contains the heads when a structure can have multiple\noccurances.  If this parameter is not specified, the item that is\n&curityp. of the &ityp. specified with the :#xi.headtype:e#xi. parameter\non the associated descriptor create function is used.\n:eplist.\n:fh3.Example\n:p.\nThis instruction will sort the list described by A_LIST_DESCRIPTOR\nin ascending order by field CBFIELD, where CBSTART is the tag of the\nstart of the item.\n:xmp.\n         IM_SORT ID=IM,DESCTKN=A_LIST_DESCRIPTOR,                      +\n                FIELDS=((CBFIELD-CBSTART,L'CBFIELD))\n:exmp.\n:efunc.\n.**********************************************************************\n.se temp = 'Define Sort Fields'\n:func id=imstfd name='IM_SORT_FIELDLIST'.&temp.\n.**********************************************************************\n:p.\nThe :#x.IM_SORT_FIELDLIST:e#x. macro is used to define static\nsort fields definitions.\n.*---------------------------------------------------------------------*\n.* Syntax box for the macro form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:mac.\nIM_SORT_FIELDLIST NAME=:hp1.name:ehp1.\n   ,FIELDS=:hp1.fieldlist:ehp1.\n:emac.\n.*---------------------------------------------------------------------*\n.* Parameter-list table describing each parameter.\n.*---------------------------------------------------------------------*\n:plist.\n:pLt.name\n:pLd.the name to be associate with the sort fields.\n:pLt.fieldlist\n:pLd.a list of fields.  The :hp1.fieldslist:ehp1. is of the form:\n.br\n((:hp1.offset:ehp1.,:hp1.length:ehp1. | :hp1.mask:ehp1.,\n  &lbt.:hp1.type:ehp1.&rbt.,&lbt.:#x.ASCENDING|DESCENDING:e#x.&rbt.),\n  ... as many sort field as needed)\n:p.\nParameter :hp1.offset:ehp1. is the offset of the sort field in an\nitem and parameter :hp1.length:ehp1. is the size of the sort field.\n:p.\nThe valid values for :hp1.type:ehp1. are: CHAR, PACKED, ZONED, FIXED,\nand BIT.\n:p.\nIf BIT is specified, :hp1.mask:ehp1. is required and is a one-byte\nvalue with bits turned on in the positions that should be checked\nfor sorting.\n:p.\nFor all other types, :hp1.length:ehp1. is used instead.  It indicates\nthe number of bytes to compare for the field.\n:p.\nThe default is CHAR.\n:p.\nASCENDING is the default if neither ASCENDING or DESCENDING is\nspecified.\n:eplist.\n:fh3.Example\n:p.\nThis instruction will generate sort fields definitions that can be\nused with the :#x.IM_SORT:e#x. function to sort a list\nin ascending order by field CBFIELD, where CBSTART is the tag of the\nstart of the item.\n:xmp.\n         IM_SORT_FIELDSLIST NAME=PSD_FIELDSLIST,                       +\n                FIELDS=((CBFIELD-CBSTART,L'CBFIELD))\n:exmp.\n:efunc.\n.**********************************************************************\n.se temp = 'Start a &imgr. Session'\n:func id=imstrt name='IM_START'.&temp.\n.**********************************************************************\n:p.\nThe :#x.IM_START:e#x. function\nis used to start the &imgr..\n.*---------------------------------------------------------------------*\n.* Syntax box for the macro form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:mac.\nIM_START ID=:hp1.id_name:ehp1. &cont.\n&lbt.,SPEPA=:hp1.im_epa:ehp1.&rbt. &cont.\n&lbt.,SPTOKEN=:hp1.im_token:ehp1.&rbt.\n  &lbt.,ESVA=:hp1.esva:ehp1.&rbt.\n  &lbt.,OPTIONS=(&lbt.READ_ONLY&rbt.\n              &lbt.,ACTUAL_ADDRESS&rbt.)\n  &lbt.,DIVEPA=:hp1.divepa:ehp1.&rbt.\n  &lbt.,DIVDDN=:hp1.divddn:ehp1.&rbt.\n:emac.\n.*---------------------------------------------------------------------*\n.* Syntax box for the CALLX form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:callx.\nCALLX :hp1.im_epa:ehp1.,(:hp1.im_token:ehp1.,&amp.&cont.\nIM_START,:hp1.esva:ehp1.,:hp1.optbyte:ehp1.,\n      :hp1.divepa:ehp1.,:hp1.divddn:ehp1.)\n:ecallx.\n.*---------------------------------------------------------------------*\n.* Parameter-list table describing each parameter.\n.*---------------------------------------------------------------------*\n:plist.\n:pLt.esva\n:pLd.Specifies the label of a fullword in storage that contains the\naddress of the Environment Support Vector (ESV) created by the\nES_START function.\n:pLt.READ_ONLY\n:pLd.option to indicate that the DIV data set will not be updated.  If\nthis options is specified, the :#x.IM_SAVE:e#x. can not be used.\n:pLt.ACTUAL_ADDRESS\n:pLd.option to indicate that actual virtural storage address should be\nused as tokens for all but item type descriptors.  If this is not\nspecified, tokens will be the relative byte within &imms..  Do not use\nthis option if a DIV service processor is being used.\n:pLt.optbyte\n:pLd.specifies a byte of storage that contains the options.  Bit 0\ncorresponds to the :#x.READ_ONLY:e#x. option and bit 1 corresponds to\nthe :#x.ACTUAL_ADDRESS:e#x. option.\n:pLt.divepa\n:pLd.specifies a fullword that contains the EPA of a DIV service\nprocessor.\n:pLt.divddn\n:pLd.specifies an eight byte field that contains the ddname of the\nfile to be used by the DIV service processor.\n:eplist.\n:fh3.Example\n:p.\nThis instruction will start the &imgr. and use actual addresses\nas token.\n:xmp.\n         IM_START ID=IM,OPTIONS=ACTUAL_ADDRESS\n:exmp.\n:rclist.\n:rcn.0\n:rct.IM_SUCCESS\n:rcd.A session of the &imgr. has successfully been started.\n:rcn.8\n:rct.IM_ITEM_STORAGE_NOT_INITIALIZED\n:rcd.A session of the &imgr. has successfully been started.\nThe :#x.IM_INITIALIZE:e#x. needs to be called to initialize &imms..\n:erclist.\n:efunc.\n.**********************************************************************\n.se temp = 'Store an Item in &imms.'\n:func id=imstor name='IM_STORE'.&temp.\n.**********************************************************************\n:p.\nThe :#x.IM_STORE:e#x. macro is used to store an item in &imms..\nThe item will become &curim..\n.*---------------------------------------------------------------------*\n.* Syntax box for the macro form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:mac.\nIM_STORE ID=:hp1.id_name:ehp1. &cont.\n&lbt.,SPEPA=:hp1.im_epa:ehp1.&rbt. &cont.\n&lbt.,SPTOKEN=:hp1.im_token:ehp1.&rbt.\n   ,ITEM=&lbr.:hp1.item:ehp1. | &cont.\n(:hp1.item:ehp1.,:hp1.item_length:ehp1.)&rbr.\n  &lbt.,ITEMTKN=:hp1.itemtkn:ehp1.&rbt.\n:emac.\n.*---------------------------------------------------------------------*\n.* Syntax box for the CALLX form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:callx.\nCALLX :hp1.im_epa:ehp1.,(:hp1.im_token:ehp1.,&amp.IM_STORE,&cont.\n:hp1.item_length:ehp1.,:hp1.item:ehp1.,&cont.\n:hp1.itemtkn:ehp1.)\n:ecallx.\n.*---------------------------------------------------------------------*\n.* Parameter-list table describing each parameter.\n.*---------------------------------------------------------------------*\n:plist.\n:pLt.item\n:pLd.specifies the label of the storage in which the item to be placed\nin &imms. resides.\n:pLt.item_length\n:pLd.specifies the label of a signed binary integer indicating the\nlength of the storage area specified by the :#xi.name:e#xi.\nparameter.  In the macro form, if item_length is not specified,\nan =A(L'item) will be used to determine the length of the storage.\nThis storage can be larger than the actual item, but must be large\nenough to hold the complete item.\n:pLt.itemtkn\n:pLd.specifies the label of a fullword into which the token of\nthe item will be placed.\n:eplist.\n:fh3.Example\n:p.\nThis instruction will store the item constructed at tag ITEM_WORK_AREA\nin &imms..\n:xmp.\n         IM_STORE ID=IM,ITEM=ITEM_WORK_AREA\n:exmp.\n:efunc.\n.**********************************************************************\n.se temp = 'Terminate the &imgr.'\n:func id=imterm name='IM_TERMINATE'.&temp.\n.**********************************************************************\n:p.\nThe :#x.IM_TERMINATE:e#x. function will terminate the &imgr. and\nrelease all associated resources.  It will also terminate the associated\nDIV service processor.\n.*---------------------------------------------------------------------*\n.* Syntax box for the macro form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:mac.\nIM_TERMINATE ID=:hp1.id_name:ehp1. &cont.\n&lbt.,SPEPA=:hp1.im_epa:ehp1.&rbt. &cont.\n&lbt.,SPTOKEN=:hp1.im_token:ehp1.&rbt.\n:emac.\n.*---------------------------------------------------------------------*\n.* Syntax box for the CALLX form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:callx.\nCALLX :hp1.im_epa:ehp1.,(:hp1.im_token:ehp1.,&amp.IM_TERMINATE)\n:ecallx.\n:fh3.Example\n:p.\nThis instruction will terminate a session with the &imgr..\n:xmp.\n         IM_TERMINATE ID=IM\n:exmp.\n:efunc.\n.**********************************************************************\n.se temp = 'Generating Description Text'\n:func id=imtext name='IM_TEXT'.&temp.\n.**********************************************************************\n:p.\nThe :#x.IM_TEXT:e#x. macro is used to generate description text.\nDescription text is used with the :#x.TEXT:e#x. keyword on various\n&imgr. macros.\n.*---------------------------------------------------------------------*\n.* Syntax box for the macro form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:mac.\n:hp1.name:ehp1. IM_TEXT :hp1.string:ehp1.\n:emac.\n.*---------------------------------------------------------------------*\n.* Parameter-list table describing each parameter.\n.*---------------------------------------------------------------------*\n:plist.\n:pLt.name\n:pLd.specifies the name to be associated with the text.\n:pLt.string\n:pLd.specifies a quoted string that contains the text.\n:eplist.\n:fh3.Example\n:xmp.\nSOMETEXT IM_TEXT \"This is some text.\"\n:exmp.\n:efunc.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SRVDOCMM": {"ttr": 13576, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x02\\x00\\x00V\\x01\\x11)\\x9f\\x01\\x11)\\x9f\\t'\\x01\\xbb\\x01\\xbb\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@\"", "ispf": {"version": "02.00", "flags": 0, "createdate": "2011-10-26T00:00:00", "modifydate": "2011-10-26T09:27:56", "lines": 443, "newlines": 443, "modlines": 0, "user": "CLEMSON"}, "text": ".*SRVMM****************************************************************\n.*                                                                    *\n.*                    Chapter. Memory Manager                         *\n.*                                                                    *\n.**********************************************************************\n:h1 id=srvmem.Memory Manager\n:p.\nThe memory manager is designed to make memory allocation efficient for\napplications by reducing the number of system requests needed to obtain\nand release portions of storage.  For applications that need to\nfrequently allocate small items of storage, this can drastically reduce\nsystem overhead.\n:p.\nApplications use the memory manager to create one or more storage\n:hp1.heaps:ehp1., where each heap represents a storage space that may\nincrementally grow and shrink over time as the application program\nobtains and releases storage.  The increment by which a heap grows and\nshrinks may be specified when the heap is created, as can restrictions\non its location (anywhere, or below the 16-megabyte line).  All storage\nowned by a heap is automatically released when the heap is destroyed.\n.*--------------------------------------------------------------------*\n:h2.Preparing to Use the Memory Manager\n.*--------------------------------------------------------------------*\n:p.\nThe Memory Manager operates independently of its execution environment;\nall managed storage is obtained through Environment Support.  Like any\nservice processor, the Memory Manager must be loaded and started before\nits functions can be used.  This process is fully covered in\n:hdref refid=part1 page=no. and will not be repeated here.\n:p.\nThe Memory Manager's service processor identification code is :#xb.MM:e#xb.\nso:\n:ul.\n:li.the :#x.COPY:e#x. member is :#xb.SRVMMMAC:e#xb.,\n:li.the load module, named by symbol :#xb.&amp.MM_MEMORY_MANAGER:e#xb.,\nis :#x.SRVMM:e#x.,\n:li.and the names of all symbols, macros, and conditions begin with the\nprefix :#xb.MM_:e#xb..\n:eul.\n:p.\nA storage heap is identified by the :#xi.mm_token:e#xi. parameter, which\nis required when invoking any Memory Manager function.  Invoking the\n:#x.MM_START:e#x. function will create a new storage heap and return its\nidentification value in :#xi.mm_token:e#xi..  Using the same value for\n:#xi.mm_token:e#xi. when invoking the :#x.MM_TERMINATE:e#x. function will\nautomatically release all of the heap's storage and destroy it.  To allocate\nand release storage within a heap, use the\n:#x.MM_OBTAIN_STORAGE:e#x. and\n:#x.MM_RELEASE_STORAGE:e#x. functions, identifying the heap with\n:#xi.mm_token:e#xi..  To reset all storage within a heap without\ngiving the storage back to the system, use the :#x.MM_RESET_HEAP:e#x.\nfunction.\n.*--------------------------------------------------------------------*\n:h3.Common Parameters\n.*--------------------------------------------------------------------*\n:p.\nThere are several parameters common to any Memory Manager function\ncall.  These parameters are listed below:\n.*****\n:plist.\n:pLt.id_name\n:pLd.the name of a service processor identifier created by the\n:#x.MM_ID:e#x. macro which will be used by all other function invocation\nmacros to automatically obtain values for :#xi.mm_epa:e#xi. and\n:#xi.mm_token:e#xi.. This parameter is required unless both\n:#xi.mm_epa:e#xi. and :#xi.mm_token:e#xi. are specified.\n:pLt.mm_epa\n:pLd.a fullword in storage containing the entry point address of the\nMemory Manager service processor.  The value specified by\n:#xi.mm_epa:e#xi. overrides any value obtained from\n:#x.ID=:e#x.:#xi.id_name:e#xi..\n:pLt.mm_token\n:pLd.a fullword in storage containing the value (to be) returned by\n:#x.MM_START:e#x. for the :#xi.mm_token:e#xi. parameter.  The value\nspecified by :#xi.mm_token:e#xi. overrides any value obtained from\n:#x.ID=:e#x.:#xi.id_name:e#xi..\n:eplist.\n.*--------------------------------------------------------------------*\n:h3.Complete List of Memory Manager Return Codes\n.*--------------------------------------------------------------------*\n:p.\nMany return codes can be returned from each function.  In the function\ndescriptions later in this chapter, the most common return codes\nreturned by the particular function are documented.  The following\nis a complete list of Memory Manager return codes.\n.*****\n:rclist.\n:rcn.0\n:rct.MM_SUCCESS\n:rcd.The invoked Memory Manager function performed the requested\nservice without encountering any problems.\n:rcn.1\n:rct.MM_INVALID_FUNCTION\n:rcd.An invalid :#xi.FunctionCode:e#xi. (the second parameter in any\nservice processor function call) was specified.\n:rcn.2\n:rct.MM_INVALID_HEAPID\n:rcd.An invalid value was given in :#xi.mm_token:e#xi.. This\nparameter must contain a value previously returned by the\n:#x.MM_START:e#x. function.\n:rcn.3\n:rct.MM_INVALID_INCREMENT\n:rcd.An invalid value for the :#xi.increment:e#xi. parameter was passed\nto the :#x.MM_START:e#x. function of the Memory Manager.\n:rcn.4\n:rct.MM_INVALID_LOCATION\n:rcd.An invalid value for the :#xi.location:e#xi. parameter was passed\nto the :#x.MM_START:e#x. function of the Memory Manager.\n:rcn.5\n:rct.MM_INVALID_SIZE\n:rcd.An invalid value was provided for the :#xi.size:e#xi. parameter,\nwhich must be a positive fullword integer value.\n:rcn.6\n:rct.MM_INVALID_PARM_COUNT\n:rcd.Either too few parameters were supplied for the function call or\ntoo many were supplied.  Check the parameter list to ensure that it is\nright for the function being invoked.\n:rcn.7\n:rct.MM_INVALID_ALIGNMENT\n:rcd.The value of :#xi.address:e#xi., a :#x.MM_RELEASE_STORAGE:e#x.\nparameter, must be an even multiple of eight (doubleword boundary).\n:rcn.8\n:rct.MM_STORAGE_NOT_AVAILABLE\n:rcd.The system denied a request for storage.\n:rcn.9\n:rct.MM_UNKNOWN_ERROR\n:rcd.The Memory Manager encountered an unexpected error.  The\napplication program should respond to this return code by immediately\ndumping the debugging area with the :#x.ES_DISPLAY_DEBUG_INFO:e#x.\nfunction of Environment Support.\n:note.No functions other than :#x.MM_TERMINATE:e#x. will be accepted by\nthe Memory Manager after this error has ocurred.\n:rcn.10\n:rct.MM_MEMORY_NOT_IN_HEAP\n:rcd.The memory being released (via :#x.MM_RELEASE_STORAGE:e#x.) was\nnot allocated using the supplied :#x.mm_token:e#x. value.\n:rcn.11\n:rct.MM_MEMORY_NOT_ALLOCATED\n:rcd.The memory being released (via :#x.MM_RELEASE_STORAGE:e#x.) does\nexist in the heap indicated by the supplied :#xi.mm_token:e#xi. value,\nbut is not allocated and thus cannot be released.\n:rcn.12\n:rct.MM_CORRUPT_STORAGE\n:rcd.An internal control block has been overwritten by invalid data.\nThe application program may have written data beyond the end of a block\nof storage previously allocated by the :#x.MM_OBTAIN_STORAGE:e#x.\nfunction, or it may have continued writing to storage released via the\n:#x.MM_RELEASE_STORAGE:e#x. function.\n:note.No functions other than :#x.MM_TERMINATE:e#x. will be accepted by\nthe Memory Manager after this error has ocurred.\n:rcn.13\n:rct.MM_NOT_USEABLE\n:rcd.All functions to the memory manager, other than\n:#x.MM_TERMINATE:e#x., have been disabled due to a previous error.\nErrors that can cause the memory manager to become unuseable are\n:#xb.MM_UNKNOWN_ERROR:e#xb. and :#xb.MM_CORRUPT_STORAGE:e#xb..\n:erclist.\n.*--------------------------------------------------------------------*\n:h2.Memory Manager Service Processor Functions\n.*--------------------------------------------------------------------*\n:p.\nThe remaining sections of this chapter describe all functions provided\nby the Memory Manager service processor, arranged in alphabetical order.\nEach function's description begins on a new page, and the name of the\nfunction being described appears at the top of every page.\n.**********************************************************************\n:func name='MM_ID' id=mmid.Establish Default Memory Manager Values\n.**********************************************************************\n:p.\nThe :#x.MM_ID:e#x. macro is used to establish default values for use\nby other Memory Manager macros, which may access those defaults through\na unique identifier, :#xi.id_name:e#xi., specified by the\nuser. Default values can be established for the following parameters:\n:#xi.mm_epname:e#xi., :#xi.mm_epa:e#xi., and\n:#xi.mm_token:e#xi..\n:p.\nIn most cases, nothing other than the entry point name needs to be\nspecified on the :#x.MM_ID:e#x. macro: it will automatically define\nworking storage fields for the remaining parameters if they are not\nspecified.  These values, whether generated by the macro or provided by\nthe user, are accessable from all other Memory Manager macros through\nthe :#x.ID=:e#x.:#xi.id_name:e#xi.. If the application program needs\nto access the parameters directly, they should be explicitly specified.\n:mac.\nMM_ID ID=:hp1.id_name:ehp1.\n  &lbt.,SPEPNAME=:hp1.mm_epname:ehp1.&rbt.\n  &lbt.,SPEPA=:hp1.mm_epa:ehp1.&rbt.\n  &lbt.,SPTOKEN=:hp1.mm_token:ehp1.&rbt.\n  &lbt.,ESID=:hp1.esid_name:ehp1.&rbt.\n  &lbt.,ESVA=:hp1.esva:ehp1.&rbt.\n:emac.\n.*****\n:plist.\n:pLt.id_name\n:pLd.the identifier to assign to the service processor identifier being\nestablished.  This name must be unique for all service processor\nidentifier's.\n:pLt.mm_epname\n:pLd.the entry point name of the Memory Manager service processor module\nthat is being used.\n:pLt.mm_epa\n:pLd.specifies the label of a fullword in storage that will contain the\nentry point address of the Memory Manager service processor.\n:pLt.mm_token\n:pLd.specifies the label of a fullword in storage that will contain the\nvalue assigned by the :#x.MM_START:e#x. function of the Memory\nManager.\n:pLt.esid_name\n:pLd.the name of a service processor identifier, created by the\n:#x.ES_ID:e#x.  macro, which will be used by the :#x.MM_ID:e#x. macro to\nautomatically obtain the value for :#xi.esv:e#xi. (see below). If this\nparameter is not specified and an Environment Support service processor\nID exists, that ID will be used.\n:pLt.esva\n:pLd.specifies the label of a fullword in storage that contains (or\nwill contain) the address of the Environment Support Vector (ESV)\ncreated by the :#x.ES_START:e#x. function.\n:eplist.\n:fh3.Example\n:p.\nAn application intends to use only one memory manager heap for its\nstorage and issues the following instruction:\n:xmp.\nMM_ID ID=MM,EPNAME=&MEMORY_MANAGER\n:exmp.\nThis instruction will save all parameter values and generate the\nfollowing code:\n:xmp.\n                     PWA TYPE=PARTIAL  | Generate fields to EPA & TOKEN.\n&amp.PWA.MM_SPEPA    DS  A             |   ID=MM: Entry point address.\n&amp.PWA.MM_SPTOKEN  DS  F             |   ID=MM: Token value.\n                     ENDPWA  ,         | End of generated fields.\n:exmp.\n:p.\nOnce the :#x.MM_ID:e#x. macro instruction above has been executed by\nthe assembler, specifying :#x.ID=MM:e#x. on any Memory Manager macro\ninstruction will be equivalent to supplying all of the above values.\n:p.\nIf the application needs to use more than one heap, it can either create\nan ID for each heap, or it can specify :#x.ID=MM:e#x. but override the\n:#xi.mm_token:e#xi. parameter on each macro instruction:\n:xmp\nMM_START          ID=MM,SPTOKEN=NEW_HEAP  Create a new storage heap.\nMM_OBTAIN_STORAGE ID=MM,SPTOKEN=NEW_HEAP,SIZE=256,ADDRESS=BUFFER_ADDR\n:exmp.\n:efunc.\n.**********************************************************************\n:func name='MM_OBTAIN_STORAGE'.Allocate Managed Storage\n.**********************************************************************\n:p.\nThe :#x.MM_OBTAIN_STORAGE:e#x. function allocates a single contiguous\nsection of memory for use by an application program.  The new storage\nwill begin on a doubleword boundary and its address will be returned in\nthe :#xi.address:e#xi. parameter.  The storage will be initialized to\nall zeros before it is returned to the application program.\n:p.\nIf the Memory Manager cannot locate a large enough section of storage\nwithin the specified heap, storage will be obtained from the system and\nadded to the heap.  The amount of storage obtained from the system will\nequal the heap's increment size or the amount of storage being allocated\n(:#xi.size:e#xi.), whichever is larger.\n:mac.\nMM_OBTAIN_STORAGE ID=:hp1.id_name:ehp1. &cont.\n&lbt.,SPEPA=:hp1.mm_epa:ehp1.&rbt. &cont.\n&lbt.,SPTOKEN=:hp1.mm_token:ehp1.&rbt.\n   ,SIZE=:hp1.size:ehp1.\n   ,ADDRESS=:hp1.address:ehp1.\n:emac.\n:callx.\nCALLX &cont.\n:hp1.mm_epa:ehp1.,(:hp1.mm_token:ehp1.,&amp.MM_OBTAIN_STORAGE,&cont.\n:hp1.size:ehp1.,:hp1.address:ehp1.)\n:ecallx.\n.*****\n:plist.\n:pLt.size\n:pLd.specifies the label of a signed fullword integer indicating the\ndesired amount of storage to be allocated.  The amount of storage to\nbe allocated must be between 1 and 16,777,215 bytes.\n:pLt.address\n:pLd.specifies a fullword in which the address of the newly allocated\nstorage is to be returned.\n:eplist.\n:fh3.Example\n:p.\nThis example shows the code needed to allocate storage for holding a\nsimple control block.\n:xmp.\n             ...\nMM_OBTAIN_STORAGE ID=MM,SIZE==A(CTL_LEN),ADDRESS=PWA_CTLPTR\n             ...\n             PWA\nPWA_CTLPTR   DS  A          Address of control block storage.\n             ENDPWA\n             ...\nCTL          DSECT          Control Block's DSECT.\n             ...              Various control block fields.\nCTL_LEN      EQU  *-CTL     Length of Control Block.\n:exmp.\n:efunc.\n.**********************************************************************\n:func name='MM_RELEASE_STORAGE'.Release Managed Storage\n.**********************************************************************\n:p.\nThe :#x.MM_RELEASE_STORAGE:e#x. function releases a contiguous section\nof storage back to the managed heap identified by the\n:#x.mm_token:e#x. parameter.  The storage to be released must be\nlocated within the heap identified by :#xi.mm_token:e#xi. and must begin\non a doubleword boundary.  It is pointed to by the\n:#xi.address:e#xi. parameter and its length is specified by\nthe :#xi.size:e#xi. parameter.\n:p.\nThe storage being released does not have to exactly match a previous\n:#x.MM_OBTAIN_STORAGE:e#x. request in its\n:#xi.address:e#xi. and\n:#xi.size:e#xi., but it must consist entirely of storage\nallocated from heap :#xi.mm_token:e#xi.. For example, a\nprogram might allocate a single large piece of storage and then give it\nback piece-by-piece.  So long as the storage being returned to the heap\ncame from the heap in the first place, there is no problem.\n:mac.\nMM_RELEASE_STORAGE ID=:hp1.id_name:ehp1. &cont.\n&lbt.,SPEPA=:hp1.mm_epa:ehp1.&rbt. &cont.\n&lbt.,SPTOKEN=:hp1.mm_token:ehp1.&rbt.\n   ,SIZE=:hp1.size:ehp1.\n   ,ADDRESS=:hp1.address:ehp1.\n:emac.\n:callx.\nCALLX &cont.\n:hp1.mm_epa:ehp1.,(:hp1.mm_token:ehp1.,&amp.MM_RELEASE_STORAGE,&cont.\n:hp1.size:ehp1.,:hp1.address:ehp1.)\n:ecallx.\n.*****\n:plist.\n:pLt.size\n:pLd.a fullword integer indicating the desired amount of storage to be\nreleased.  The memory manager will round this value up to the nearest\nmultiple of eight.\n:pLt.address\n:pLd.a fullword address that points to the storage to be released. This\nstorage should have been previouly allocated in the same storage heap by\nthe :#x.MM_OBTAIN_STORAGE:e#x. function of the memory manager, and\nmust be aligned on a doubleword boundary.\n:eplist.\n:fh3.Example\n:p.\nThis example shows the code needed to release storage that held a simple\ncontrol block.\n:xmp.\n             ...\nMM_RELEASE_STORAGE ID=MM,SIZE==A(CTL_LEN),ADDRESS=PWA_CTLPTR\n             ...\n             PWA\nPWA_CTLPTR   DS  A          Address of control block storage.\n             ENDPWA\n             ...\nCTL          DSECT          Control Block's DSECT.\n             ...              Various control block fields.\nCTL_LEN      EQU  *-CTL     Length of Control Block.\n:exmp.\n:efunc.\n.**********************************************************************\n:func name='MM_RESET_HEAP'.Release All Managed Storage\n.**********************************************************************\n:p.\nThe :#x.MM_RESET_HEAP:e#x. function releases all managed storage back to\nthe heap identified by the :#x.mm_token:e#x. parameter.  This function\nprovides applications with a method of reusing a heap without having\nto terminate and restart a Memory Manager session.  When this function\nis used, all storage previously obtained within the heap by the\n:#x.MM_OBTAIN_STORAGE:e#x. function is released back to the heap.\n:mac.\nMM_RESET_HEAP ID=:hp1.id_name:ehp1. &cont.\n&lbt.,SPEPA=:hp1.mm_epa:ehp1.&rbt. &cont.\n&lbt.,SPTOKEN=:hp1.mm_token:ehp1.&rbt.\n:emac.\n:callx.\nCALLX &cont.\n:hp1.mm_epa:ehp1.,(:hp1.mm_token:ehp1.,&amp.MM_RESET_HEAP)\n:ecallx.\n:efunc.\n.**********************************************************************\n:func name='MM_START'.Create a New Storage Heap\n.**********************************************************************\n:p.\nThe :#x.MM_START:e#x. function creates a new storage heap for management\nby the memory manager.  Two optional parameters,\n:#xi.increment:e#xi. and :#xi.location:e#xi. control how the heap will\ngrow and where its storage will be allocated.\n:mac.\nMM_START ID=:hp1.id_name:ehp1. &cont.\n&lbt.,SPEPA=:hp1.mm_epa:ehp1.&rbt. &cont.\n&lbt.,SPTOKEN=:hp1.mm_token:ehp1.&rbt.\n  &lbt.,ESVA=:hp1.esva:ehp1.&rbt.\n  &lbt.,INCREMENT=&lbr.:us.4096:eus. | :hp1.increment:ehp1.&rbr.&rbt.\n  &lbt.,LOCATION=&lbr.:hp2.:us.ANY:eus.:ehp2.|:hp2.BELOW:ehp2.&rbr.&rbt.\n:emac.\n:callx.\nCALLX :hp1.mm_epa:ehp1.,(:hp1.mm_token:ehp1.,&amp.MM_START,&cont.\n:hp1.esva:ehp1.,&cont.\n&lbt.:hp1.increment:ehp1.&rbt.,&lbt.:hp1.location:ehp1.&rbt.)\n:ecallx.\n.*****\n:plist.\n:pLt.increment\n:pLd.specifies the label of a fullword signed integer that will be used\nas the smallest amount of storage to obtain from the system when the\nheap needs to grow in size.  A larger amount of storage will be obtained\nif needed in order to satisfy an :#x.MM_OBTAIN_STORAGE:e#x. request.  If\nthe specified value for :#xi.increment:e#xi. is an even multiple of the\nsystem page size (4096 bytes), each increment of storage will be\nallocated on a page boundary.  The default value for\n:#xi.increment:e#xi. is 4096 bytes.\n:pLt.location\n:pLd.specifies whether storage for the heap must come from below the\n16-megabyte line (:#x.:hp2.BELOW:ehp2.:e#x.) or if it may come from\nanywhere (:#x.:hp2.ANY:ehp2.:e#x.). For the call form of this\nfunction,\n:#xi.location:e#xi. specifies a fullword in storage\ncontaining the value of symbol :#x.&amp.MM_LOCATION_BELOW:e#x. if the\nstorage must come from below the 16-megabyte line and\n:#x.&amp.MM_LOCATION_ANY:e#x. if the storage may come from anywhere.\nThese symbols are defined in copy member :#x.SRVMMMAC:e#x..\n:eplist.\n:efunc.\n.**********************************************************************\n:func name='MM_TERMINATE'.Destroy an Existing Storage Heap\n.**********************************************************************\n:p.\nThe :#x.MM_TERMINATE:e#x. function releases all storage associated\nwith an existing storage heap and then destroys the heap.  The value of\n:#xi.mm_token:e#xi. will be set to zero when\n:#x.MM_TERMINATE:e#x. returns.\n:mac.\nMM_TERMINATE ID=:hp1.id_name:ehp1. &cont.\n&lbt.,SPEPA=:hp1.mm_epa:ehp1.&rbt. &cont.\n&lbt.,SPTOKEN=:hp1.mm_token:ehp1.&rbt.\n:emac.\n:callx.\nCALLX :hp1.mm_epa:ehp1.,(:hp1.mm_token:ehp1.,&amp.MM_TERMINATE)\n:ecallx.\n:efunc.\n.*\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SRVDOCMS": {"ttr": 13830, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x02\\x00\\x00V\\x01\\x11)\\x9f\\x01\\x11)\\x9f\\t'\\x03t\\x03t\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@\"", "ispf": {"version": "02.00", "flags": 0, "createdate": "2011-10-26T00:00:00", "modifydate": "2011-10-26T09:27:56", "lines": 884, "newlines": 884, "modlines": 0, "user": "CLEMSON"}, "text": ".*\n.* The GML text below is a skeleton reference chapter for one service\n.* processor.  The suggested approach for writing a new chapter is to\n.*    1) create a new member called SRVDOCxx, where xx is the two\n.*       letter service processor identification code.\n.*    2) copy this member into it.\n.*    3) Change all occurrances of the skeleton names below to the\n.*       appropriate values.\n.*    4) format a copy of the manual with the new chapter included.\n.*    5) use the formatted copy of the new chapter to decided what\n.*       changes/additions/deletions need to be made.\n.*\n.*   <srvproc_name>  - The name used when referring to the service\n.*                     processor in general. e.g. \"String Handler\",\n.*                     \"Environment Support\", \"Memory Manager\", etc.\n.*   <srvload_sym>   - The symbolic name used for the load module, such\n.*                     as STRING_HANDLER, MVS_ENVIRONMENT_SUPPORT, etc.\n.*   <srvload_name>  - The actual name of the load module identified by\n.*                     <srvload_sym>, such as SRVSTR or SRVMVSES.       .\n.*   <>              - The two-letter code assigned to the service\n.*                     processor, such as ES, ST, MM, SY, or FI.\n.*   <func_name>     - The name used for specific function's reference\n.*                     section.  This name would be something like\n.*                     ES_LOAD_MODULE, ST_FORMAT, etc.\n.*   idid            - The header id used on the section for the xx_ID\n.*                     macro.\n.*\n.*\n.* Lines that begin with .*===> describe what should appear in the\n.*   text at that point or provide information on how something should\n.*   be formatted.\n.*\n.**********************************************************************\n.*                                                                    *\n.*                    Chapter. Message Services                       *\n.*                                                                    *\n.**********************************************************************\n:h1.Message Services\n:p.\nThe Message Services service processor simplifies the tasks of defining,\nissuing and maintaining messages.  This is accomplished by:\n:ul.\n:li.Defining messages in a\n:hp1.central place:ehp1., separate from the code that\nissues them.\n:li.Defining :hp1.standards:ehp1.\nwhich the messages must follow, which are\nenforced at assembly time.\n:li.Associating a :hp1.severity:ehp1. with a message,\nwhich the issuer may optionally use to set returncodes.\n:li.Allowing :hp1.text substitution:ehp1. within predefined messages.\nThe substitution function uses the String Formatter: hence, any\nmessage may be defined using standard String Formatter format strings.\n:li.Defining the :hp1.message destination:ehp1. at execution time.\n:li.Allowing the caller to :hp1.retrieve message text:ehp1. if needed\nfor special routing (such as multiple destinations).\n:eul.\n.*\n.*--------------------------------------------------------------------*\n:h3.Defining Messages\n.*--------------------------------------------------------------------*\n:p.Message Services requires its users to define messages in a\nmessage CSECT.  Macros are provided to simplify construction of\nthis CSECT.  Up to 25 message CSECTs may be loaded by an\nindividual Message Services session.\nEach message CSECT will ultimately reside as a load module:\nhowever, since Message Services uses the :#x.ES_LOAD_MODULE:e#x.\nfunction to locate and load the message CSECTs into storage, the\nmessage CSECT could be defined via a module name table and linked with\nthe caller's load modules and/or other message CSECTs\nas desired.\n.*\n:p.The construction of a message CSECT is a simple matter.  The CSECT\nitself is started and terminated by the :#x.MS_MESSAGE_MODULE:e#x.\nmacro, which also defines the messages' prefix string, the length of\nthe message identifiers, and optionally the severity characters and\ntheir associated return codes.  Each individual message is defined by\na :#x.MS_MESSAGE:e#x. macro, which ensures that the proper message\nID prefix, length and severity characters were used.  The following\nexample defines a message CSECT with three messages:\n:fig.\n:xmp.\n         MS_MESSAGE_MODULE   START,                                   +\n                  NAME=MSGMOD03,         This becomes the CSECT name  +\n                  PREFIX=ABC,                                         +\n                  IDLENGTH=8,            All msgids are 8 chars long  +\n                  SEVCHAR=((I,0),(W,4),(E,8),(F,12))\n\nABC0001I MS_MESSAGE  'This is merely informational; return code is 0.'\nABC0002W MS_MESSAGE  'You are being warned; return code is 4.'\nABC0003E MS_MESSAGE  'An error has occurred; return code is 8.'\n\n         MS_MESSAGE_MODULE   END\n:exmp.\n:figcap.Sample Message Module Definition\n:efig.\n:p.:#x.MS_MESSAGE_MODULE:e#x. and :#x.MS_MESSAGE:e#x. do not generate\nany executable code.\n.*--------------------------------------------------------------------*\n:h3.Obtaining Message Services' Symbols &amp. Macros\n.*--------------------------------------------------------------------*\n:p.\nMessage Services' symbols and interface macros can be found in the\nassembler copy member :#x.SRVMSMAC:e#x.. This member contains symbols\nnaming Message Services' load module, function codes, return codes,\nand parameter values.  It also contains macros for using all of the\nMessage Services' functions. The following statement or its equivalent\nshould appear at the beginning of any program that uses\nMessage Services:\n:xmp.\n   COPY SRVMSMAC      Obtain Message Services' symbols & macros.\n:exmp.\n.*===> if there is more than one load module that implements the\n.*===> service processor's protocol, that should be mentioned here.\n.*--------------------------------------------------------------------*\n:h3.Establishing Message Services Defaults\n.*--------------------------------------------------------------------*\nSome parameters are general to Message Services and not specific to\nany function.  These parameters include its load module name\n(:#xi.MS_epname:e#xi.), entry point address\n(:#xi.MS_epa:e#xi.), and token value\n(:#xi.MS_token:e#xi.). The :#x.MS_ID:e#x. macro (see\n:hdref refid=msid.) can be used to establish defaults for these\nparameters and associate them with a unique service processor\nidentifier.  The identifier may then be supplied on any Message\nServices\nmacro instruction to refer to the default parameter values.\n.*--------------------------------------------------------------------*\n:h3.Identifying Message Services\n.*--------------------------------------------------------------------*\n:p.\nThe Message service processor resides in the load module named by\nthe following symbol definition in copy member :#x.SRVMSMAC:e#x.:\n:xmp.\n&amp.MESSAGE_SERVICES SETC  '''SRVMS   '''\n:exmp.\nThis symbolic name should be used as the service processor entry point\nname for Message Services\nas shown in the following :#x.MS_ID:e#x.\nmacro instruction:\n:xmp.\nMS_ID ID=MS,SPEPNAME=&amp.MESSAGE_SERVICES    Set MsgServ Defaults.\n:exmp.\n.*--------------------------------------------------------------------*\n:h3.Loading Message Services\n.*--------------------------------------------------------------------*\n:p.\nThe recommended method for loading Message Services is through\nEnvironment Support's :#x.ES_LOAD_MODULE:e#x. function, as shown in\nthe following example:\n:xmp.\nES_LOAD_MODULE ID=ES,SPID=MS            Load Message Services\n:exmp.\n.*--------------------------------------------------------------------*\n:h3.Common Parameters\n.*--------------------------------------------------------------------*\n:p.There are several parameters common to any\nMessage Services\nfunction call.  These are:\n:plist.\n:pLt.id_name\n:pLd.specifies the name of a service processor identifier created by the\n:#x.MS_ID:e#x. macro which will be used by the :#x.MS_START:e#x.\nmacro to automatically obtain values for :#xi.MS_epa:e#xi.\nand\n:#xi.MS_token:e#xi.. This parameter is required unless both\n:#xi.MS_epa:e#xi. and :#xi.MS_token:e#xi. are\nspecified.\n:pLt.MS_epname\n:pLd.the entry point name of the Message Services service processor\nmodule that is being used.\n:pLt.MS_epa\n:pLd.specifies the label of a fullword in storage that contains the\nentry point address of an already-started Message Services service\nprocessor.  The value specified by :#xi.MS_epa:e#xi.\noverrides any value obtained from\n:#x.ID=:e#x.:#xi.id_name:e#xi..\n:pLt.MS_token\n:pLd.specifies the label of a fullword in storage that contains the\nvalue returned by :#x.MS_START:e#x. for the\n:#xi.MS_token:e#xi. parameter.  The value specified by\n:#xi.MS_token:e#xi. overrides any value obtained from\n:#x.ID=:e#x.:#xi.id_name:e#xi..\n:eplist.\n.*--------------------------------------------------------------------*\n:h3.Return Codes\n.*--------------------------------------------------------------------*\n:p.\nMessage Services may issue any of the following return codes in\nvarious situations.  Some of the return codes may be received from any\ncall to Message Services, while others are specific to individual\nfunctions.\n.*---------------------------------------------------------------------*\n.* ReturnCode section: table of return codes and their meanings.\n.*\n.*===> This section should be elimitated for things that do not have\n.*===> return codes, such as the MS_ID macro or data-mapping macros.\n.*\n.* :rclist.\n.* :rcn.number           | One rcn/rct/rcd triple for each return code\n.* :rct.symbol           | that the function may generate.\n.* :rcd.description      |\n.* :erclist.\n.*\n.*---------------------------------------------------------------------*\n:rclist.\n:rcn.0\n:rct.MS_SUCCESS\n:rcd.The Message Services\nfunction has completed successfully.\n:rcn.1\n:rct.MS_INVALID_FUNCTION\n:rcd.The specified function code is not presently supported.\n:rcn.2\n:rct.MS_INVALID_NUMBER_OF_PARMS\n:rcd.The Message Services\nfunction received an invalid number of\nparameters.  This may be due to an improperly coded CALLX or PLIST\nmacro, or the inadvertent use of the NOVL option.\n:rcn.3\n:rct.MS_INVALID_MS_ID\n:rcd.Message Services detected an invalid\nPWA address in :#x.MS_token:e#x..\n:rcn.4\n:rct.MS_ENVIRONMENT_SUPPORT_ ERROR\n:rcd.An error was reported by Environment Support.  The error probably\noccurred while attempting to load the Printline or String Handler\nservice processor.\n:rcn.5\n:rct.MS_STRING_HANDLER_ERROR\n:rcd.An error was reported by the String Handler service processor.\nMore information may be found by issuing the\n:#x.ES_DISPLAY_DEBUG_INFO:e#x. function.\n:rcn.6\n:rct.MS_PRINT_LINE_TRUNCATED\n:rcd.The formatted message was too large to fit in Message Services'\ninternal 256-byte buffer.  The first 256 bytes of the message are\nprinted.\n:rcn.7\n:rct.MS_PRINTLINE_ERROR\n:rcd.An error was reported by the Printline service processor.\nMore information may be found by issuing the\n:#x.ES_DISPLAY_DEBUG_INFO:e#x. function.\n:rcn.8\n:rct.MS_INVALID_MSGDEST_OPTION\n:rcd.The option byte provided did not contain a valid :#x.MSGDEST:e#x.\noption value.  Message Services currently supports the following\nMSGDEST option values:\n:ul compact.\n:li.:hp3.0:ehp3. - Not specified.\n:li.:hp3.1:ehp3. - DDNAME specified.\n:li.:hp3.2:ehp3. - PLID or PL specified.\n:li.:hp3.3:ehp3. - CONSOLE specified.\n:eul.\n:rcn.9\n:rct.MS_MSGMOD_MISSING\n:rcd.Either the address of the message module list was zero, or the\nlist's count field was zero.\nAt least one message module must be provided to :#x.MS_START:e#x..\n:rcn.10\n:rct.MS_TOO_MANY_MSGMODS\n:rcd.More than 25 message modules were provided to :#x.MS_START:e#x..\nAt present, Message Services can only handle 25 message modules.\n:rcn.11\n:rct.MS_MSGMOD_NOT_LOADED\n:rcd.A particular message module could not be loaded by\n:#x.MS_START:e#x..\n:rcn.12\n:rct.MS_MSGMOD_NOT_VALID\n:rcd.One of the message modules was not a valid Message Services\nmessage module.\n:rcn.13\n:rct.MS_INVALID_SIZELENGTH\n:rcd.:#x.MS_START:e#x. found a :#x.sizelength:e#x. value that was\ngreater than 4. The value of :#x.sizelength:e#x. must be between 1\nand 4, or must be 0 or unspecified in order to use the default value\nof 2.\n:rcn.14\n:rct.MS_MESSAGE_NOT_FOUND\n:rcd.The message specified by :#x.msgid_string:e#x. could not be found\namong the active message modules.\n:rcn.15\n:rct.MS_INVALID_PREFIX\n:rcd.The message prefix specified by\n:#x.msgid_string:e#x. was not found\namong the active message modules.\n:rcn.16\n:rct.MS_MSGDEST_NOT_PROVIDED\n:rcd.A message destination was not provided via the :#x.MSGDEST:e#x.\noperand of :#x.MS_START:e#x.. This Message Services function cannot be\nused without a message destination.\n:erclist.\n.*--------------------------------------------------------------------*\n:h2.Message Services Functions\n.*--------------------------------------------------------------------*\n:p.\nThe remaining sections of this chapter describe all functions provided\nby Message Services, arranged in alphabetical order.\nEach function's description begins on a new page, and the name of the\nfunction being described appears in the top outside corner of every\npage.\n.**********************************************************************\n.se temp = 'Retrieve Message Text'\n:func id=msget  name='MS_GET_MESSAGE'.&temp.\n.**********************************************************************\n:p.\nThe :#x.MS_GET_MESSAGE:e#x. function retrieves and formats a message,\nthen returns the formatted message text and its length to the caller.\n.*===>\n.*===> The :mac. and :callx. tags below are used to describe the\n.*===> syntax for invoking the function/macro.\n.*===>\n.*---------------------------------------------------------------------*\n.* Syntax box for the macro form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:mac.\nMS_GET_MESSAGE ID=:hp1.id_name:ehp1. &cont.\n&lbt.,SPEPA=:hp1.MS_epa:ehp1.&rbt. &cont.\n&lbt.,SPTOKEN=:hp1.MS_token:ehp1.&rbt.\n   ,MSGID=:hp1.msgid_ID_string:ehp1.\n   ,STRING=(&lbr.:hp1.string:ehp1. |&cont.\n(:hp1.string:ehp1.,:hp1.string_length:ehp1.)&rbr.\n   ,RESULTLEN=:hp1.result_length:ehp1.\n   &lbt.,SOURCE=(:hp1.source1:ehp1.,:hp1.source2:ehp1., ...)&rbt.\n:emac.\n.*---------------------------------------------------------------------*\n.* Syntax box for the CALLX form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:callx.\nCALLX :hp1.MS_epa:ehp1.,&cont.\n(:hp1.MS_token:ehp1.,&amp.MS_GET_MESSAGE,&cont.\n:hp1.msgID_string:ehp1.\n              ,:hp1.string:ehp1.,:hp1.string_length:ehp1.,&cont.\n:hp1.result_length:ehp1.\n              &lbr.,:hp1.source1:ehp1.,:hp1.source2:ehp1., ...&rbr.)\n:ecallx.\n.*---------------------------------------------------------------------*\n.* Parameter-list table describing each parameter.\n.*\n.* :plist.\n.* :pLt.parameter      | One pLt/pLd pair for each parameter that may\n.* :pLd.description    | be specified.\n.* :eplist.\n.*\n.*---------------------------------------------------------------------*\n:plist.\n:pLt.msgid_ID_string\n:pLd.Specifies the message ID to be processed.\n:pLt.string\n:pLd.Specifies the area where :#x.MS_GET_MESSAGE:e#x. will return the\ntext of the requested message.\n:pLt.string_length\n:pLd.Provides the length of the field named by :#x.string:e#x..\nThe length of this\nfield is governed by the :#x.SizeLength:e#x. operand specified on the\n:#x.MS_ID:e#x. or :#x.MS_START:e#x. macro.\n:pLt.result_length\n:pLd.The :#x.MS_GET_MESSAGE:e#x. function will return the actual\nlength of the formatted message into this field.  The length of this\nfield is governed by the :#x.SizeLength:e#x. operand specified on the\n:#x.MS_ID:e#x. or :#x.MS_START:e#x. macro.\n:pLt.source\n:pLd.Provides substitution parameters for the String Handler to\ninsert into the message being constructed.\n:eplist.\n.*---------------------------------------------------------------------*\n:fh3.Examples\nIf message ABC002I were defined in a message CSECT using:\n:xmp.\nABC002E MS_MESSAGE \"{I} parameters ignored due to {C}.\"\n:exmp.\nthe following MS_GET_MESSAGE macro:\n:xmp.\nMS_GET_MESSAGE  ID=MS,\n                MSGID==C'ABC002E',\n                SOURCE=(3,\"syntax errors\")\n:exmp.\nwould result in the message:\n:xmp.\n   ABC002E 3 parameters ignored due to syntax errors.\n:exmp.\n:efunc.\n.**********************************************************************\n.se temp = 'Establish Default Message Services Values'\n:func id=msid name='MS_ID'.&temp.\n.**********************************************************************\n:p.The :#x.MS_ID:e#x. macro is used to establish default values for\nuse by other Message Services macros, which may access those values\nthrough a unique identifier, :#xi.id_name:e#xi., specified by\nthe user.  When allowed to generate default values, this macro will\ncreate Program Work Area (PWA) storage for :#xi.MS_epa:e#xi.\nand\n:#xi.MS_token:e#xi.. These values, whether generated by the\nmacro or provided by the user, are accessable from all other\nMessage Services\nmacros via the :#x.ID=:e#x.:#xi.id_name:e#xi. parameter.\n:mac.\nMS_ID ID=:hp1.id_name:ehp1.\n   &lbt.,SPEPNAME=:hp1.MS_epname:ehp1.&rbt.\n   &lbt.,SPEPA=:hp1.MS_epa:ehp1.&rbt.\n   &lbt.,SPTOKEN=:hp1.MS_token:ehp1.&rbt.\n   &lbt.,ESID=:hp1.esid_name:ehp1.&rbt.\n   &lbt.,ESVA=:hp1.esva:ehp1.&rbt.\n   &lbt.,SIZELENGTH=:hp1.integer:ehp1.&rbt.\n:emac.\n.*****\n:plist.\n:pLt.esva\n:pLd.Specifies the label of a fullword in storage that contains (or\nwill contain) the address of the Environment Support Vector\n(:#x.ESV:e#x.) created by the :#x.ES_START:e#x. function.\n:pLt.sizelength\n:pLd.An integer value from 1 and 4\nthat determines the size, in bytes, of all\nvalues representing string lengths by the String Handler.  For example,\na :hp1.sizelength:ehp1. value of 4 would cause all lengths returned by\nthe String Handler to be 4 bytes in length.\n:eplist.\n:fh3.Examples\n:p.\nThe following :#x.MS_ID:e#x. macro will associate everything required by\nthe Message Services\nmacros with the service processor identifier :#x.PL:e#x.,\nas well as establish the :#x.sizelength:e#x. value for the\nMessage Services\nsession.\n:xmp.\n    MS_ID  ID=PL,\n           SPEPNAME=&amp.MESSAGE_SERVICES,\n           SPEPA=PWA_MS_ENTRY,\n           SPTOKEN=PWA_MS_TOKEN,\n           ESID=ES,\n           ESVA=PWA_ESVA,\n           SIZELENGTH=4\n.sp 2\nPWA_MS_ENTRY  DS    F         Entrypoint for Message Services\nPWA_MS_TOKEN  DS    F         Unique token for Message Services session\nPWA_ESVA      DS    F         Environment Support Vector address\n:exmp.\n:efunc.\n.**********************************************************************\n.se temp = 'Issue A Message'\n:func id=msissue  name='MS_ISSUE_MESSAGE'.&temp.\n.**********************************************************************\n:p.\nThe :#x.MS_ISSUE_MESSAGE:e#x. function retrieves, formats and prints\nthe message referred to by :hp1.msgid_string:ehp1..\n.*===>\n.*===> The :mac. and :callx. tags below are used to describe the\n.*===> syntax for invoking the function/macro.\n.*===>\n.*---------------------------------------------------------------------*\n.* Syntax box for the macro form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:mac.\nMS_ISSUE_MESSAGE ID=:hp1.id_name:ehp1. &cont.\n&lbt.,SPEPA=:hp1.MS_epa:ehp1.&rbt. &cont.\n&lbt.,SPTOKEN=:hp1.MS_token:ehp1.&rbt.\n   ,MSGID=:hp1.msgid_string:ehp1.\n   &lbt.,SOURCE=(:hp1.source1:ehp1.,:hp1.source2:ehp1., ...)&rbt.\n:emac.\n.*---------------------------------------------------------------------*\n.* Syntax box for the CALLX form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:callx.\nCALLX :hp1.MS_epa:ehp1.,&cont.\n(:hp1.MS_token:ehp1.,&amp.MS_ISSUE_MESSAGE,&cont.\n:hp1.msgID_string:ehp1.\n              &lbr.,:hp1.source1:ehp1.,:hp1.source2:ehp1., ...&rbr.)\n:ecallx.\n.*---------------------------------------------------------------------*\n.* Parameter-list table describing each parameter.\n.*\n.* :plist.\n.* :pLt.parameter      | One pLt/pLd pair for each parameter that may\n.* :pLd.description    | be specified.\n.* :eplist.\n.*\n.*---------------------------------------------------------------------*\n:plist.\n:pLt.msgid_string\n:pLd.Specifies the message ID to be processed.\nThis parameter may be coded as a literal or an address.\n:pLt.source1,source2,...\n:pLd.Provides substitution parameters for the String Handler to\ninsert into the message being constructed.\n:eplist.\n.*---------------------------------------------------------------------*\n:fh3.Examples\nIf message ABC002I were defined in a message module using:\n:xmp.\nABC002E MS_MESSAGE \"{I} parameters ignored due to {C}.\"\n:exmp.\nthe following MS_ISSUE_MESSAGE macro:\n:xmp.\nMS_ISSUE_MESSAGE  ID=MS,\n                  MSGID='ABC002E',\n                  SOURCE=(3,\"syntax errors\")\n:exmp.\nwould result in the message:\n:xmp.\n   ABC002E 3 parameters ignored due to syntax errors.\n:exmp.\n:efunc.\n.**********************************************************************\n.se temp = 'Define A Message'\n:func id=msmsg name='MS_MESSAGE'.&temp.\n.**********************************************************************\n:p.The :#x.MS_MESSAGE:e#x. macro is used to\ndefine the text of a message.  :#x.MS_MESSAGE:e#x. will also use the\nvalues specified by the :#x.MS_MESSAGE_MODULE:e#x. operands\n:#x.prefix:e#x., :#x.idlength:e#x. and :#x.sevchar:e#x. to enforce\nthe respective attributes of the message.\n:mac.\nmessage_id  MS_MESSAGE  '      message_text      '\n:emac.\n.*****\n:plist.\n:pLt.message_id\n:pLd.Provides the message ID for the message.  The message ID will be\ngenerated at the beginning of the message text.  The message ID is\nexpected to be of the format:\n&lbr.:#x.msg_prefix:e#x.&rbr.||&lbr.:#x.msg_number:e#x.&rbr.||&cont.\n&lbr.:#x.sev_char:e#x.&rbr. .\nThe contents and length of :#x.msg_prefix:e#x., as well as\nthe value of :#x.sev_char:e#x. and the overall length of the message ID\nare enforced by the values specified on :#x.MS_MESSAGE_MODULE:e#x..\n:pLt.message_text\n:pLd.Specifies a String Handler control string.  The length of this\nstring may be up to 255 characters: however, the length of the\nresulting formatted string cannot exceed 255 bytes.\n:eplist.\n:fh3.Examples\n:p.\nThe following :#x.MS_MESSAGE:e#x. macros define a series of messages.\nThey also point out the default severity characters.\n:xmp.\nXYZ001I  MS_MESSAGE  \"Information message, severity value of 0.\"\nXYZ002W  MS_MESSAGE  \"Warning message, severity value of 4.\"\nXYZ003E  MS_MESSAGE  \"Error message, severity value of 8.\"\nXYZ004S  MS_MESSAGE  \"Severe message, severity value of 12.\"\nXYZ005C  MS_MESSAGE  \"Catastrophic message, severity value of 16.\"\n:exmp.\n:efunc.\n.**********************************************************************\n.se temp = 'Define A Message Module'\n:func id=msmsgmd name='MS_MESSAGE_MODULE'.&temp.\n.**********************************************************************\n:p.The :#x.MS_MESSAGE_MODULE:e#x. macro is used to\nstart or end a message module.  :#x.MS_MESSAGE_MODULE:e#x. also sets\nvarious attributes of the messages\n:#x.prefix:e#x., :#x.idlength:e#x. and :#x.sevchar:e#x. to enforce\nthe respective attributes of the message.\n:mac.\nMS_MESSAGE_MODULE START\n                 ,NAME=:hp1.csectname:ehp1.\n                 ,PREFIX=:hp1.msgid_prefix:ehp1.\n                 ,IDLENGTH=&lbr.:hp1.msgid_length:ehp1. |&cont.\n:hp3.8:ehp3.&rbr.\n                 &lbt.,SEVCHAR=:hp1.sevchar_def:ehp1.&rbt.\n\n     -- or --\n\nMS_MESSAGE_MODULE END\n:emac.\n.*****\n:plist.\n:pLt.START\n:pLd.Defines the beginning of a message module.\n:pLt.END\n:pLd.Defines the end of the message module.  This must be coded after\nall :#x.MS_MESSAGE:e#x. macros.  No other parameters are valid when\n:#x.END:e#x. is coded.\n:pLt.csectname\n:pLd.Provides the name of the CSECT that :#x.MS_MESSAGE_MODULE:e#x.\nwill generate.\n:pLt.msgid_prefix\n:pLd.Specifies that all messages defined in this message module must\nbe prefixed with this string.  A message prefix may be up to 6\ncharacters in length.\n:pLt.msgid_length\n:pLd.Specifies the required length, in bytes,\nfor all message IDs coded on :#x.MS_MESSAGE:e#x. macros.\n:pLt.sevchar_def\n:pLd.Provides a list of message suffix characters and an associated\nseverity. These are coded as :#x.(character,severity):e#x., where\n:#x.character:e#x. is a single message suffix character, and\n:#x.severity:e#x. is the associated severity code. A maximum of\nthese severity codes will be returned to the caller if the\n:#x.MAXSEV:e#x. keyword is specified on the :#x.MS_START:e#x. macro.\nAny message suffixes coded on :#x.MS_MESSAGE:e#x. macros that do not\nappear among the valid severity characters will cause an assembly error.\nThe default :#x.sevchar_def:e#x. list is:\n:p.\n:#x.SEVCHAR=((I,0),(W,4),(E,8),(S,12),(C,16)):e#x.\n:eplist.\n:fh3.Examples\n:p.\nThe following macros define a complete message module.\n:xmp.\n  MS_MESSAGE_MODULE START,\n                    NAME=ABC$MSGS,\n                    PREFIX=ABC,\n                    IDLENGTH=7,\n                    SEVCHAR=((I,0),(W,4),(E,8),(F,16))\n\nABC001I  MS_MESSAGE  \"Informational message, severity = 0.\"\nABC002W  MS_MESSAGE  \"Warning message, severity = 4.\"\nABC003E  MS_MESSAGE  \"Error message, severity = 8.\"\nABC004F  MS_MESSAGE  \"Fatal message, severity = 16.\"\n\n  MS_MESSAGE_MODULE END\n  END\n:exmp.\n:efunc.\n.**********************************************************************\n.se temp = 'Begin A Message Services Session'\n:func id=msstart name='MS_START'.&temp.\n.**********************************************************************\n:p.\nThe :#x.MS_START:e#x. function establishes\na new Message Services\nsession and returns its session identifier in the\n:hp1.MS_token:ehp1. parameter.  The message destination, maximum\nseverity field, message CSECT list and other global Message Services\nparameters are provided here.\n.*===>\n.*===> The :mac. and :callx. tags below are used to describe the\n.*===> syntax for invoking the function/macro.\n.*===>\n.*---------------------------------------------------------------------*\n.* Syntax box for the macro form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:mac.\nMS_START ID=:hp1.id_name:ehp1. &cont.\n&lbt.,SPEPA=:hp1.MS_epa:ehp1.&rbt. &cont.\n&lbt.,SPTOKEN=:hp1.MS_token:ehp1.&rbt.\n   &lbt.,ESVA=:hp1.esva:ehp1.&rbt.\n   ,MSGDEST=(DDNAME,:hp1.ddnamespec:ehp1.)     |\n            (PLID,:hp1.msgserv_procid:ehp1.)   |\n            (PL,:hp1.PL_EPA:ehp1.,:hp1.PL_token:ehp1.)    |\n            (CONSOLE)\n   ,MSGMOD=(:hp1.msgmod_csect:ehp1.,:hp1.msgmod_csect:ehp1., ...)\n   ,MSGMODLIST=:hp1.msgmod_list:ehp1.\n   &lbt.,MAXSEV=:hp1.maxsev_address:ehp1.&rbt.\n   &lbt.,PLCC=:hp1.carriage_control:ehp1.&rbt.\n   &lbt.,SIZELENGTH=&lbr.:hp1.sizelength:ehp1. | &cont.\n:hp2.2:ehp2.&rbr.&rbt.\n   &lbt.,OPTIONS=(:hp1.option_list:ehp1.)&rbt.\n:emac.\n.*---------------------------------------------------------------------*\n.* Syntax box for the CALLX form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:callx.\nCALLX :hp1.MS_epa:ehp1.,(:hp1.MS_token:ehp1.,&amp.MS_START,&cont.\n:hp1.esva:ehp1.,\n              :hp1.msgmod_list:ehp1.,:hp1.sizelength:ehp1.&cont.\n:hp1.maxsev_address:ehp1.,\n              :hp1.carriage_control:ehp1.,&cont.\n:hp1.MSGDEST_option,:ehp1.\n              :hp1.MSGDEST_specific_parameters:ehp1.,&cont.\n:hp1.option_byte:ehp1.)\n.*===> If there are alternate forms, where the parameter list is\n.*===> significantly different depending on the first few parameter\n.*===> values, do something like the following:\n:ecallx.\n.*---------------------------------------------------------------------*\n.* Parameter-list table describing each parameter.\n.*\n.* :plist.\n.* :pLt.parameter      | One pLt/pLd pair for each parameter that may\n.* :pLd.description    | be specified.\n.* :eplist.\n.*\n.*---------------------------------------------------------------------*\n:plist.\n:pLt.esva\n:pLd.Specifies the label of a fullword in storage that contains the\naddress of the Environment Support Vector (ESV) created by the\nES_START function.\n:pLt.MSGDEST\n:pLd.Specifies the message destination that Message Services will use\nto write its formatted messages.\nThe :#x.MSGDEST:e#x. keyword supports the following operands:\n:ul compact.\n:li.:hp3.DDNAME:ehp3.: This provides the DDname that Message Services\nshould use to start a Printline session.  The Printline session will\nbe terminated when :#x.MS_TERMINATE:e#x. is called.\n:li.:hp3.PLID:ehp3.: This specifies the service processor ID of an\nexisting Printline session.  The ID is used to find the\n:li.:hp3.PL:ehp3.: This is used to provide the\n:hp1.PL_EPA:ehp1. and :hp1.PL_token:ehp1. of an existing\nPrintline session.\n:li.:hp3.CONSOLE:ehp3.: This specifies that the :hp1.console:ehp1. is\nthe message destination.  The :#x.ES_DISPLAY_MESSAGE:ehp1. service is\nactually used to display the message.\n:eul.\n:pLt.MSGDEST_option\n:pLd.If the CALLX form is used, the MSGDEST keyword must be represented\nas a single byte, containing one of the following values:\n:ul compact.\n:li.:hp3.0:ehp3. - MSGDEST not specified.\nThere are no additional parameters.\n:li.:hp3.1:ehp3. - DDNAME specified. This is followed by the address\nof an 8-character DDname.\n:li.:hp3.2:ehp3. - PLID or PL specified.\nThis is followed by the addresses of :#x.PL_EPA:e#x. and\n:#x.PL_token:e#x. respectively.\n:li.:hp3.3:ehp3. - CONSOLE specified.\nThere are no additional parameters.\n:eul.\n:pLt.msgmod_csect\n:pLd.Provides the names of one or more message modules.  These modules\nwill be loaded by :#x.ES_LOAD_MODULE:e#x., and thus must either exist as\nseparate load modules in STEPLIB or be defined in an application module\nname table.\n:pLt.msgmod_list\n:pLd.If the application has a need to construct its own message module\nlist, it may be provided to :#x.MS_START:e#x. using the\n:#x.MSGMODLIST:e#x. keyword.  The message module list must consist of\na fullword containing the number of message module names, followed by\na list of 8-character module names, as follows:\n:xmp.\nMOD_LIST DC   F'3'\n         DC   CL8'ABC$MSGS'\n         DC   CL8'DEF$MSGS'\n         DC   CL8'XYZ$MSGS'\n:exmp.\nA list of this format is constructed when the :#x.MSGMOD:e#x. keyword\nis used.  The :#x.MSGMOD:e#x. and :#x.MSGMODLIST:e#x. keywords are\nmutually exclusive.\n:pLt.maxsev_address\n:pLd.The optional address of a halfword where Message Services will\nmaintain the highest severity level of any message issued. This field\nshould be initialized to zeros before :#x.MS_ISSUE_MESSAGE:e#x. or\n:#x.MS_GET_MESSAGE:e#x. are invoked.\n:pLt.carriage_control\n:pLd.Optionally provides an ASA carriage control character to be used\nwhen printing messages.  If :#x.MSGDEST:e#x. is not specified or is\nset to :#x.CONSOLE:e#x., use of the :#x.PLCC:e#x. keyword will generate\nan MNOTE. The operand of :#x.PLCC:e#x. may be specified as a quoted\ncharacter or as an address.\n:pLt.sizelength\n:pLd.An integer value from 1 and 4 that determines the size, in bytes,\nof all values representing string lengths by the String Handler.  For\nexample, a :hp1.sizelength:ehp1. value of 4 would cause all lengths\nreturned by the String Handler to be 4 bytes in length.\n:pLt.option_list\n:pLd.A list of additional options for this Message Services\nsession.  The only\noption currently supported is :hp1.FOLD:ehp1..\n:ul.\n:li.:hp2.FOLD:ehp2. - All output produced by Message Services\nshould be\nfolded to uppercase.  If using the CALLX form to call\n:hp1.MS_START:ehp1., the FOLD option corresponds to a bit setting of\nX'80' in the option byte.\nNote that when using a MSGDEST of :hp1.PLID:ehp1., the PrintLine\nsession must have been started with :hp1.OPTIONS=FOLD:ehp1..\n:eul.\n:eplist.\n.*---------------------------------------------------------------------*\n.* Optional sections for describing how to use the function/macro.\n.*---------------------------------------------------------------------*\n.*---------------------------------------------------------------------*\n.* Examples showing how to use it and neat ways to take advantage of\n.* the function's capabilities.\n.*\n.*===> If one or two separate examples are being done, simply use\n.*===>\n.*===> :fh3.Example 1\n.*===>   ...example 1 stuff...\n.*===> :fh3.Example 2\n.*===>   ...example 2 stuff...\n.*===>\n.*===> If a whole system of related examples are being done, use\n.*===>\n.*===> :fh3.Examples\n.*===>   ....description general to all examples.\n.*===> :h5.Example 1\n.*===>   ...example 1 stuff...\n.*===> :h5.Example 2\n.*===>   ...example 2 stuff...\n.*===>\n.*---------------------------------------------------------------------*\n:fh3.Examples\n:p.\nThe following :#x.MS_START:e#x.  macro will initialize a Message\nServices session.  This MS_START example\nwill cause the following to occur:\n:ul compact.\n:li.A Printline session will be started by Message Services, using\nDDname :#x.SYSPRINT:e#x. and a SizeLength value of 4.\n:li.The message modules\n:#x.ABC$MSGS:e#x.,\n:#x.DEF$MSGS:e#x. and\n:#x.XYZ$MSGS:e#x. are loaded and validated.\n:li.The address of :#x.PWA_MAXSEV:e#x. is bound as the MaxSev halfword's\naddress.  :#x.PWA_MAXSEV:e#x. will be maintained with the highest\nmessage severity code of any message issued by this Message Services\nsession.\n:li.A carriage control byte of '0' will prefix all messages built by\nthis Message Services session.  This will cause messages to be\ndouble-spaced by PrintLine.\n:eul.\n:xmp.\n    MS_START ID=PL,\n             MSGDEST=(DDNAME,=C'SYSPRINT'),\n             MSGMOD=(ABC$MSGS,DEF$MSGS,XYZ$MSGS),\n             MAXSEV=PWA_MAXSEV,\n             PLCC='0',\n             SIZELENGTH=4\n.sp 2\nPWA_MAXSEV   DS    H         Max. severity, maintained by MsgServ\n:exmp.\n:efunc.\n.**********************************************************************\n.se temp = 'Terminate A Message Services Session'\n:func id=msterm name='MS_TERMINATE'.&temp.\n.**********************************************************************\n:p.\nThe :#x.MS_TERMINATE:e#x. function concludes\nthe Message Services session identified by the\n:hp1.MS_token:ehp1. parameter, and releases any resources held\nby the Message Services service processor.\n.*===>\n.*===> The :mac. and :callx. tags below are used to describe the\n.*===> syntax for invoking the function/macro.\n.*===>\n.*---------------------------------------------------------------------*\n.* Syntax box for the macro form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:mac.\nMS_TERMINATE ID=:hp1.id_name:ehp1. &cont.\n&lbt.,SPEPA=:hp1.MS_epa:ehp1.&rbt. &cont.\n&lbt.,SPTOKEN=:hp1.MS_token:ehp1.&rbt.\n:emac.\n.*---------------------------------------------------------------------*\n.* Syntax box for the CALLX form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:callx.\nCALLX :hp1.MS_epa:ehp1.,(:hp1.MS_token:ehp1.,&amp.MS_TERMINATE)\n.*===> If there are alternate forms, where the parameter list is\n.*===> significantly different depending on the first few parameter\n.*===> values, do something like the following:\n:ecallx.\n.*---------------------------------------------------------------------*\n.* Parameter-list table describing each parameter.\n.*\n.* :plist.\n.* :pLt.parameter      | One pLt/pLd pair for each parameter that may\n.* :pLd.description    | be specified.\n.* :eplist.\n.*\n.*---------------------------------------------------------------------*\n.* There are no function-specific parameters for MS_TERMINATE.\n.*---------------------------------------------------------------------*\n.* Optional sections for describing how to use the function/macro.\n.*---------------------------------------------------------------------*\n.*===> If one or two separate examples are being done, simply use\n.*===>\n.*===> :fh3.Example 1\n.*===>   ...example 1 stuff...\n.*===> :fh3.Example 2\n.*===>   ...example 2 stuff...\n.*===>\n.*===> If a whole system of related examples are being done, use\n.*===>\n.*===> :fh3.Examples\n.*===>   ....description general to all examples.\n.*===> :h5.Example 1\n.*===>   ...example 1 stuff...\n.*===> :h5.Example 2\n.*===>   ...example 2 stuff...\n.*===>\n.*---------------------------------------------------------------------*\n:fh3.Examples\n:p.The following :#x.MS_TERMINATE:e#x. macro will cause\nMessage Services to\nclose its report file and release any resources that it acquired.\n:xmp.\nMS_TERMINATE ID=MS\n:exmp.\n:efunc.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SRVDOCPL": {"ttr": 14090, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x02\\x00\\x00V\\x01\\x11)\\x9f\\x01\\x11)\\x9f\\t'\\x05\\xdd\\x05\\xdd\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@\"", "ispf": {"version": "02.00", "flags": 0, "createdate": "2011-10-26T00:00:00", "modifydate": "2011-10-26T09:27:56", "lines": 1501, "newlines": 1501, "modlines": 0, "user": "CLEMSON"}, "text": ".*\n.* The GML text below is a skeleton reference chapter for one service\n.* processor.  The suggested approach for writing a new chapter is to\n.*    1) create a new member called SRVDOCxx, where xx is the two\n.*       letter service processor identification code.\n.*    2) copy this member into it.\n.*    3) Change all occurrances of the skeleton names below to the\n.*       appropriate values.\n.*    4) format a copy of the manual with the new chapter included.\n.*    5) use the formatted copy of the new chapter to decided what\n.*       changes/additions/deletions need to be made.\n.*\n.*   <srvproc_name>  - The name used when referring to the service\n.*                     processor in general. e.g. \"String Handler\",\n.*                     \"Environment Support\", \"Memory Manager\", etc.\n.*   <srvload_sym>   - The symbolic name used for the load module, such\n.*                     as STRING_HANDLER, MVS_ENVIRONMENT_SUPPORT, etc.\n.*   <srvload_name>  - The actual name of the load module identified by\n.*                     <srvload_sym>, such as SRVSTR or SRVMVSES.       .\n.*   <>              - The two-letter code assigned to the service\n.*                     processor, such as ES, ST, MM, SY, or FI.\n.*   <func_name>     - The name used for specific function's reference\n.*                     section.  This name would be something like\n.*                     ES_LOAD_MODULE, ST_FORMAT, etc.\n.*   idid            - The header id used on the section for the xx_ID\n.*                     macro.\n.*\n.*\n.* Lines that begin with .*===> describe what should appear in the\n.*   text at that point or provide information on how something should\n.*   be formatted.\n.*\n.**********************************************************************\n.*                                                                    *\n.*                    Chapter. Printline                              *\n.*                                                                    *\n.**********************************************************************\n:h1.Printline\n:p.\nThe Printline service processor is intended to simplify report writing\nby managing such typical \"housekeeping\" tasks of report writing\nas headers and footers,\npage ejects, and page numbers.  This can reduce the complexity of\nprograms that need to produce reports, freeing the developer to\nconcentrate on other aspects of the report program.\n:p.\nThe Printline service processor is dependent on the MVS operating\nsystem environment, primarily due to its use of QSAM.\n:p.\nThe Printline service processor can make use of the String Handler to\nconstruct header, footer and data lines from String Handler control\nstrings and source parameters.  Heading and footing definitions may be\nadded, changed or deleted dynamically.  Page counters are defined as\npart of a heading or footing data line: while the actual counters reside\nin the caller's storage, they are incremented automatically by\nPrintline, and formatted under control of the associated format control\nstring.  Multiple page counters may be defined at once, and they need\nnot contain the same values.\n.*--------------------------------------------------------------------*\n:h3.Basic Operation Of Printline\n.*--------------------------------------------------------------------*\n:p.Printline has three types of lines: :hp1.header:ehp1. lines,\n:hp1.footer:ehp1. lines, and :hp1.data:ehp1. lines.  Header and footer\nlines are generally established once, and remain \"current\" until\neither Printline is told to remove them or Printline is terminated.\nData lines are printed as they are passed to Printline.  If a data line\nwould not fit on the current page, Printline will print any footers\nthat are currently defined, then print any headers that are defined.\nAny page counters active at the time will be incremented.  The caller\ncan also force a page \"break\" to occur by calling a Printline function.\n.*\n:p.Printline uses the OS file handler for output.  When the OS file\nhandler is started, option ISOCC and RECORDLENGTH=(4,maxlnsz) is\nspecified.\n.*\n:p.By default, Printline will print exactly what is passed to it,\npreserving lowercase data.  An option can be used to cause Printline\nto convert everything it prints to uppercase.  This may be a\nconsideration if reports produced using Printline might print on\nuppercase-only printers.\n.*--------------------------------------------------------------------*\n:h3.The Format Of A Page\n.*--------------------------------------------------------------------*\n:p.Printline allows its caller to define the format of a report's page\nin terms of:\n:ul.\n:li.The length of the page (number of total print lines),\n:li.The :hp1.header:ehp1., or those lines that appear at the top\nof each page,\n:li.The :hp1.footer:ehp1., or those lines that appear at the bottom\nof each page,\n:li.The body of the page.\n:eul.\n:p.Printline provides function macros to manage each of these\ncomponents a report: these are defined below.\n.*\n:h4.The Length Of The Page\n.*\n:p.When a Printline session is started, the caller specifies the space\non a page available for printing.  The default page length is 66 print\nlines.  The actual space available for printing data is determined by\nthe total page length minus any headers and footers defined.  Since\nheaders and footers can be defined, changed or removed in mid-report,\nthe amount of space available for printing data may change.  The\n:#x.PL_QUERY_LINES_LEFT:e#x. function can return the amount of space\nremaining on the current page at any point in a Printline session.\n.*\n:h4.Headers\n.*\n:p.Headers as defined by Printline, appear at the top of each printed\npage.  When a page break occurs (by either reaching the end of the\ncurrent page or calling the :#x.PL_PAGE_BREAK:e#x. function), the\nheaders are printed according to the current header definition.\n.*\n:p.Header lines are defined individually by the\n:#x.PL_SET_HEADER:e#x. and :#x.PL_SET_FORMATTED_HEADER:e#x. functions,\nand may be subsequently removed by the\n:#x.PL_RESET_HEADER:e#x. function.\nEach header line is assigned a \"line number\":  this number is used\nto determine the order that header lines are printed in.\nA header may be redefined \"in-place\" using the same line number,\neven if the number or size of its parameters changes.\nThe line numbers do not need to be consecutive:  in fact, header lines\ncan be inserted by using a line number value between existing line\nnumbers.  This example shows how a header line can be inserted\nand later removed in mid-report, as shown in\n:figref refid=plhdrex..\n:fig id=plhdrex.\n:xmp.\nPL_SET_HEADER  ID=PL,LINE=10,STRING='1  The first header line.'\nPL_SET_HEADER  ID=PL,LINE=20,STRING='0  The last header line.'\n      :                         :\nPL_PRINT       ID=PL, ...           Print some stuff.\n      :                         :\nPL_SET_HEADER  ID=PL,LINE=15,STRING='0  An inserted header line.'\n      :                         :\nPL_PRINT       ID=PL, ...           Print some more stuff.\n      :                         :\nPL_RESET_HEADER  ID=PL,LINE=15\n:exmp.\n:figcap.Printline Header Definition Example\n:efig.\n.*\n:p.Printline requires each print line provided by its caller to\ncontain an ASA carriage control character as its first character.\nThis allows the caller to retain some control over the appearance of\nthe report.  While Printline does not set or change carriage control\ncharacters itself, it uses the carriage controls provided by its\ncaller to count the number of lines printed and remaining on the\ncurrent page.  The first header line on a page should contain a\ncarriage control character of '1', to ensure that a page eject occurs\nbefore that line is printed.\n.*\n:p.When using :#x.PL_SET_FORMATTED_HEADER:e#x., the caller can provide\na fullword that will be treated as a :hp1.page counter:ehp1..  The\npage number is coded as one of the String Formatter's substitution\nparameters in the :#x.SOURCE=:e#x. parameter:  Printline is told which\nparameter to use as the page counter via the :#x.PAGENUM:e#x. parameter,\nwhich provides the position of the page number's address in the\n:#x.SOURCE=:e#x. list, as shown in :figref refid=plfmthd..\n:fig id=plfmthd.\n:xmp.\nPL_SET_FORMATTED_HEADER  ID=PL,                                       +\n                LINE=10,                                              +\n                STRING=format_string,                                 +\n                SOURCE=(todays_date,page_number),                     +\n                PAGENUM=2\n         :                     :\nformat_string  DC  C'1  Date: {CL8}       This is the report that you +\n                     always wanted.                  Page: {IL4}'\ntodays_date    DS  CL8\npage_number    DS  F\n:exmp.\n:figcap.Sample Header Definition With Page Counter\n:efig.\n:p.In this case, the second :#x.SOURCE:e#x. parameter provides the\naddress of the page counter: hence, the :#x.PAGENUM:e#x. parameter\nspecifies a value of \"2\".  Multiple page numbers may be defined\nthroughout the report, although only one may be defined per header or\nfooter line:  each will be auto-incremented as the header or footer\nreferencing it is printed.  The page counter values should be\ninitially set to zero, but may be modified by the calling program at\nany time.  These counter fields are incremented each time they are\nprinted:  hence, they should not be referred to by more than one\nheader or footer definition at a time.\n.*\n:h4.Footers\n.*\n:p.Footers, if defined, will appear at the bottom of each page printed.\nFooters may be used for legends, footnotes, or to provide additional\ninformation that should appear on each page of a report.  Like headers,\nfooter lines are defined with unique \"line numbers\", which determine\nthe order in which the footer lines are printed.\n.*\n:p.Footer lines are defined individually by the\n:#x.PL_SET_FOOTER:e#x. and :#x.PL_SET_FORMATTED_FOOTER:e#x. functions,\nand removed by the :#x.PL_RESET_FOOTER:e#x. function, in much the same\nway as headers are defined.  Unlike headers, however, Printline needs\nto know how many lines to reserve as footer space, since it needs to\nbe able to skip to the footer area if a page eject is forced by\n:#x.PL_PAGE_BREAK:e#x.. The\n:#x.PL_RESERVE_FOOTER:e#x. function will reserve a number of lines at\nthe bottom of a report page for footer lines.\n.*\n:p.Like headers, footers may contain page counters, which are treated\nthe same way as page counters in headers.  Use the\n:#x.PL_SET_FORMATTED_FOOTER:e#x. function to define page counters in\nfooter lines.  These counter fields are incremented each time they are\nprinted:  hence, they should not be referred to by more than one\nheader or footer definition at a time.\n.*\n:h4.The Body Of The Page\n.*\nAfter any headers have been defined and the space reserved by\n:#x.PL_RESERVE_FOOTER:e#x. has been deducted, the space remaining on\na page is available for the body of the report.  Use the\n:#x.PL_PRINT:e#x. and :#x.PL_PRINT_FORMATTED:e#x. functions to write\ndata lines to the report.\n.*--------------------------------------------------------------------*\n:h3.Obtaining Printline Symbols &amp. Macros\n.*--------------------------------------------------------------------*\n:p.\nPrintline's symbols and interface macros can be found in the\nassembler copy member :#x.SRVPLMAC:e#x.. This member contains symbols\nnaming Printline's load module, function codes, return codes,\nand parameter values.  It also contains macros for using all of the\nPrintline's functions. The following statement or its equivalent\nshould appear at the beginning of any program that uses the\nPrintline:\n:xmp.\n   COPY SRVPLMAC      Obtain Printline's symbols & macros.\n:exmp.\n.*===> if there is more than one load module that implements the\n.*===> service processor's protocol, that should be mentioned here.\n.*--------------------------------------------------------------------*\n:h3.Establishing Printline Defaults\n.*--------------------------------------------------------------------*\nSome parameters are general to Printline and not specific to\nany function.  These parameters include its load module name\n(:#xi.PL_epname:e#xi.), entry point address\n(:#xi.PL_epa:e#xi.), and token value\n(:#xi.PL_token:e#xi.). The :#x.PL_ID:e#x. macro (see\n:hdref refid=idid.) can be used to establish defaults for these\nparameters and associate them with a unique service processor\nidentifier.  The identifier may then be supplied on any Printline\nmacro instruction to refer to the default parameter values.\n.*--------------------------------------------------------------------*\n:h3.Identifying Printline\n.*--------------------------------------------------------------------*\n:p.\nThe Printline service processor resides in the load module named by\nthe following symbol definition in copy member :#x.SRVPLMAC:e#x.:\n:xmp.\n&amp.PRINT_LINE       SETC  '''SRVMVSPL  '''\n:exmp.\nThis symbolic name should be used as the service processor entry point\nname for Printline as shown in the following :#x.PL_ID:e#x.\nmacro instruction.\n:xmp.\nPL_ID ID=ST,SPEPNAME=&amp.PRINT_LINE       Set Printline Defaults.\n:exmp.\n.*--------------------------------------------------------------------*\n:h3.Loading Printline\n.*--------------------------------------------------------------------*\n:p.\nThe recommended method for loading Printline is through\nEnvironment Support's :#x.ES_LOAD_MODULE:e#x. function, as shown in\nthe following example:\n:xmp.\nES_LOAD_MODULE ID=ES,SPID=PL            Load Printline\n:exmp.\n.*--------------------------------------------------------------------*\n:h3.Common Parameters\n.*--------------------------------------------------------------------*\n:p.There are several parameters common to many\nPrintline\nfunction calls.  These are:\n:plist.\n:pLt.id_name\n:pLd.specifies the name of a service processor identifier created by the\n:#x.PL_ID:e#x. macro which will be used by the :#x.PL_START:e#x.\nmacro to automatically obtain values for :#xi.PL_epa:e#xi.\nand\n:#xi.PL_token:e#xi.. This parameter is required unless both\n:#xi.PL_epa:e#xi. and :#xi.PL_token:e#xi. are\nspecified.\n:pLt.PL_epname\n:pLd.the entry point name of the Printline service processor module\nthat is being used.\n:pLt.PL_epa\n:pLd.specifies the label of a fullword in storage that contains the\nentry point address of an already-started Date/Time Services service\nprocessor.  The value specified by :#xi.PL_epa:e#xi.\noverrides any value obtained from\n:#x.ID=:e#x.:#xi.id_name:e#xi..\n:pLt.PL_token\n:pLd.specifies the label of a fullword in storage that contains the\nvalue returned by :#x.PL_START:e#x. for the\n:#xi.PL_token:e#xi. parameter.  The value specified by\n:#xi.PL_token:e#xi. overrides any value obtained from\n:#x.ID=:e#x.:#xi.id_name:e#xi..\n:eplist.\n.*--------------------------------------------------------------------*\n:h3.Return Codes\n.*--------------------------------------------------------------------*\n:p.\nPrintline may issue any of the following return codes in\nvarious situations.  Some of the return codes may be received from any\ncall to Date/Time Services, while others are specific to individual\nfunctions.\n.*---------------------------------------------------------------------*\n.* ReturnCode section: table of return codes and their meanings.\n.*\n.*===> This section should be elimitated for things that do not have\n.*===> return codes, such as the PL_ID macro or data-mapping macros.\n.*\n.* :rclist.\n.* :rcn.number           | One rcn/rct/rcd triple for each return code\n.* :rct.symbol           | that the function may generate.\n.* :rcd.description      |\n.* :erclist.\n.*\n.*---------------------------------------------------------------------*\n:rclist.\n:rcn.0\n:rct.PL_SUCCESS\n:rcd.The Printline\nfunction has completed successfully.\n:rcn.1\n:rct.PL_INVALID_FUNCTION\n:rcd.Printline does not support this function code.\n:rcn.2\n:rct.PL_INVALID_NUMBER_OF_PARMS\n:rcd.The Printline\nfunction received an invalid number of\nparameters.  This may be due to an improperly coded CALLX or PLIST\nmacro, or the inadvertent use of the NOVL option.\n:rcn.3\n:rct.PL_INVALID_PL_ID\n:rcd.The Printline service processor detected an invalid\nPWA address in :#x.PL_token:e#x..\n:rcn.4\n:rct.PL_MEMORY_MANAGER_ERROR\n:rcd.An attempt to invoke the Memory Manager resulted in an error.\nDebug information should be available via the ES_DISPLAY_DEBUG_INFO\nfunction.\n:rcn.5\n:rct.PL_CANNOT_OPEN_DCB\n:rcd.The DDname provided by the caller could not be used to OPEN the\nreport file.  A \"DDNAME MISSING\" message may accompany this error.\n:rcn.6\n:rct.PL_ENVIRONMENT_SUPPORT_ERROR\n:rcd.An attempt to invoke Environment Support resulted in an error.\nDebug information should be available via the ES_DISPLAY_DEBUG_INFO\nfunction.\n:rcn.7\n:rct.PL_STRING_HANDLER_ERROR\n:rcd.An error was detected by the String Handler while attempting\nto format a footer line for printing.\nDebug information should be available via the ES_DISPLAY_DEBUG_INFO\nfunction.\n:rcn.8\n:rct.PL_PRINT_LINE_TRUNCATED\n:rcd.The length of string :#x.print_string:e#x. exceeded the maximum\nline length specified on the :#x.PL_START:e#x. macro.  The portion of\n:#x.print_string:e#x. that would fit in the print line is printed.\n:rcn.9\n:rct.Reserved\n:rcd.This return code is currently unused.\n:rcn.10\n:rct.PL_HEADER_NOT_FOUND\n:rcd.The header referred to by :hp1.line_number:ehp1. was not found.\n:rcn.11\n:rct.PL_FOOTER_NOT_FOUND\n:rcd.The header referred to by :hp1.line_number:ehp1. was not found.\n:rcn.12\n:rct.PL_INVALID_PAGEDISP\n:rcd.The :hp1.pagenum:ehp1. parameter's value was greater than the\nnumber of\n:hp1.source:ehp1. parameters.\n:rcn.13\n:rct.PL_INVALID_SIZELENGTH\n:rcd.The :hp1.sizelength:ehp1. parameter is not valid.  It may only be\na fullword integer between 1 and 4.\n:rcn.14\n:rct.PL_MISSING_PARAMETER\n:rcd.A required parameter is missing.\n:rcn.15\n:rct.PL_HEADER_LINE_TRUNCATED\n:rcd.A simple or formatted header line\nhas exceeded\n:#x.MaxLineSize:e#x. in length.  The\nun-truncated portion of the\nheader line is printed.  Note that by the\ntime the caller is informed of this error, several header lines may\nhave been printed.\n:rcn.16\n:rct.PL_FOOTER_LINE_TRUNCATED\n:rcd.A simple or formatted footer line\nhas exceeded\n:#x.MaxLineSize:e#x. in length.  The\nun-truncated portion of the\nfooter line is printed.  Note that by the\ntime the caller is informed of this error, several footer lines may\nhave been printed.\n:erclist.\n.*--------------------------------------------------------------------*\n:h2.Printline Service Processor Functions\n.*--------------------------------------------------------------------*\n:p.\nThe remaining sections of this chapter describe all functions provided\nby the Printline service processor, arranged in alphabetical order.\nEach function's description begins on a new page, and the name of the\nfunction being described appears in the top outside corner of every\npage.\n.**********************************************************************\n:func name='PL_ID' id=idid.Establish Default Printline Values\n.**********************************************************************\n:p.The :#x.PL_ID:e#x. macro is used to establish default values for\nuse by other Printline macros, which may access those values\nthrough a unique identifier, :#xi.id_name:e#xi., specified by\nthe user.  When allowed to generate default values, this macro will\ncreate Program Work Area (PWA) storage for :#xi.PL_epa:e#xi.\nand\n:#xi.PL_token:e#xi.. These values, whether generated by the\nmacro or provided by the user, are accessable from all other\nPrintline macros via the :#x.ID=:e#x.:#xi.id_name:e#xi. parameter.\n:mac.\nPL_ID ID=:hp1.id_name:ehp1.\n   &lbt.,SPEPNAME=:hp1.PL_epname:ehp1.&rbt.\n   &lbt.,SPEPA=:hp1.PL_epa:ehp1.&rbt.\n   &lbt.,SPTOKEN=:hp1.PL_token:ehp1.&rbt.\n   &lbt.,ESID=:hp1.esid_name:ehp1.&rbt.\n   &lbt.,ESVA=:hp1.esva:ehp1.&rbt.\n   &lbt.,SIZELENGTH=:hp1.integer:ehp1.&rbt.\n:emac.\n.*****\n:plist.\n:pLt.esid_name\n:pLd.the name of a service processor identifier, created by the\n:#x.ES_ID:e#x.  macro, which will be used by the :#x.PL_ID:e#x. macro to\nautomatically obtain the value for :#x.esv:e#x. (see below).\n:pLt.esva\n:pLd.Specifies the label of a fullword in storage that contains (or\nwill contain) the address of the Environment Support Vector\n(:#x.ESV:e#x.) created by the :#x.ES_START:e#x. function.\n:pLt.sizelength\n:pLd.An integer value from 1 and 4\nthat determines the size, in bytes, of all\nvalues representing string lengths by the String Handler.  For example,\na :hp1.sizelength:ehp1. value of 4 would cause all lengths returned by\nthe String Handler to be 4 bytes in length.\n:eplist.\n:fh3.Examples\n:p.\nThe following :#x.PL_ID:e#x. macro will associate everything required by\nthe Printline macros with the service processor identifier :#x.PL:e#x.,\nas well as establish the :#x.sizelength:e#x. value for the Printline\nsession.\n:xmp.\n    PL_ID  ID=PL,\n           SPEPNAME=&amp.PRINT_LINE,\n           SPEPA=PWA_PL_ENTRY,\n           SPTOKEN=PWA_PL_TOKEN,\n           ESID=ES,\n           ESVA=PWA_ESVA,\n           SIZELENGTH=4\n.sp 2\nPWA_PL_ENTRY  DS    F         Entrypoint for Printline\nPWA_PL_TOKEN  DS    F         Unique token for Printline session\nPWA_ESVA      DS    F         Environment Support Vector address\n:exmp.\n:efunc.\n.**********************************************************************\n.se temp = 'Force A Page Break'\n:func id=plpgbrk  name='PL_PAGE_BREAK'.&temp.\n.**********************************************************************\n:p.\nThe :#x.PL_PAGE_BREAK:e#x. function causes a page break to occur\nimmediately.  As a result, footers (if any) are printed at the bottom\nof the page, and the next call to :#x.PL_PRINT:e#x. or\n:#x.PL_PRINT_FORMATTED:e#x. will cause headers (if any) to be\nprinted.\n.*===>\n.*===> The :mac. and :callx. tags below are used to describe the\n.*===> syntax for invoking the function/macro.\n.*===>\n.*---------------------------------------------------------------------*\n.* Syntax box for the macro form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:mac.\nPL_PAGE_BREAK ID=:hp1.id_name:ehp1. &cont.\n&lbt.,SPEPA=:hp1.PL_epa:ehp1.&rbt. &cont.\n&lbt.,SPTOKEN=:hp1.PL_token:ehp1.&rbt.\n:emac.\n.*---------------------------------------------------------------------*\n.* Syntax box for the CALLX form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:callx.\nCALLX :hp1.PL_epa:ehp1.,&cont.\n(:hp1.PL_token:ehp1.,&amp.PL_PAGE_BREAK)\n:ecallx.\n.*---------------------------------------------------------------------*\n.* Parameter-list table describing each parameter.\n.*\n.* :plist.\n.* :pLt.parameter      | One pLt/pLd pair for each parameter that may\n.* :pLd.description    | be specified.\n.* :eplist.\n.*\n.*---------------------------------------------------------------------*\n.* There are no function-specific parameters for PL_PAGE_BREAK.\n.*---------------------------------------------------------------------*\n:fh3.Examples\nThe following Printline macro forces a page break to occur.\n:xmp.\nPL_PAGE_BREAK ID=PL\n:exmp.\n:efunc.\n.**********************************************************************\n.se temp = 'Unformatted Print'\n:func id=plprint  name='PL_PRINT'.&temp.\n.**********************************************************************\n:p.\nThe :#x.PL_PRINT:e#x. function prints an unformatted data line.\nThe data line must have an ASA carriage control character as its\nfirst character,\n.*===>\n.*===> The :mac. and :callx. tags below are used to describe the\n.*===> syntax for invoking the function/macro.\n.*===>\n.*---------------------------------------------------------------------*\n.* Syntax box for the macro form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:mac.\nPL_PRINT ID=:hp1.id_name:ehp1. &cont.\n&lbt.,SPEPA=:hp1.PL_epa:ehp1.&rbt. &cont.\n&lbt.,SPTOKEN=:hp1.PL_token:ehp1.&rbt.\n   ,STRING=&lbr.:hp1.print_string:ehp1. | &cont.\n:hp1.(print_string,string_len):ehp1.&rbr.\n:emac.\n.*---------------------------------------------------------------------*\n.* Syntax box for the CALLX form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:callx.\nCALLX :hp1.PL_epa:ehp1.,&cont.\n(:hp1.PL_token:ehp1.,&amp.PL_PRINT,&cont.\n:hp1.print_string:ehp1.,:hp1.string_len:ehp1.)\n:ecallx.\n.*---------------------------------------------------------------------*\n.* Parameter-list table describing each parameter.\n.*\n.* :plist.\n.* :pLt.parameter      | One pLt/pLd pair for each parameter that may\n.* :pLd.description    | be specified.\n.* :eplist.\n.*\n.*---------------------------------------------------------------------*\n:plist.\n:pLt.print_string\n:pLd.Specifies a character string to be printed.\n:pLt.string_len\n:pLd.Provides the length of :#x.print_string:e#x.. This operand is not\nrequired on the :#x.PL_PRINT:e#x. macro if the macro can determine the\nlength attribute of :#x.print_string:e#x..\nThe\n:hp1.string_len:ehp1. value may be coded as an integer or other\nnumeric term, or may refer to a field in storage of\n:hp1.size_length:ehp1. bytes in length, containing the string's length.\n:eplist.\n.*---------------------------------------------------------------------*\n:fh3.Examples\nThe following Printline macro causes an unformatted print to occur.\n:xmp.\nPL_PRINT ID=PL,&cont.\nSTRING==C\"0 This data line will be double-spaced.\"\n:exmp.\n:efunc.\n.**********************************************************************\n.se temp = 'Formatted Print'\n:func id=plfmprt  name='PL_PRINT_FORMATTED'.&temp.\n.**********************************************************************\n:p.\nThe :#x.PL_PRINT_FORMATTED:e#x.\nfunction uses the String Handler to\nformat and print a data line.\nThe data line (as produced by the String Handler)\nmust have an ASA carriage control character as its\nfirst character.\n.*===>\n.*===> The :mac. and :callx. tags below are used to describe the\n.*===> syntax for invoking the function/macro.\n.*===>\n.*---------------------------------------------------------------------*\n.* Syntax box for the macro form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:mac.\nPL_PRINT_FORMATTED ID=:hp1.id_name:ehp1. &cont.\n&lbt.,SPEPA=:hp1.PL_epa:ehp1.&rbt. &cont.\n&lbt.,SPTOKEN=:hp1.PL_token:ehp1.&rbt.\n   ,CONTROL=&lbr.:hp1.format_string:ehp1. | &cont.\n:hp1.(format_string,string_len):ehp1.&rbr.\n   ,SOURCE=&lbr.:hp1.(source1,source2,...):ehp1.&rbr.\n:emac.\n.*---------------------------------------------------------------------*\n.* Syntax box for the CALLX form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:callx.\nCALLX :hp1.PL_epa:ehp1.,&cont.\n(:hp1.PL_token:ehp1.,&amp.PL_PRINT_FORMATTED,&cont.\n:hp1.format_string:ehp1.,&cont.\n:hp1.string_len:ehp1.\n             &lbt.,:hp1.arguments:ehp1.&rbt.)\n:ecallx.\n.*---------------------------------------------------------------------*\n.* Parameter-list table describing each parameter.\n.*\n.* :plist.\n.* :pLt.parameter      | One pLt/pLd pair for each parameter that may\n.* :pLd.description    | be specified.\n.* :eplist.\n.*\n.*---------------------------------------------------------------------*\n:plist.\n:pLt.format_string\n:pLd.Specifies the String Handler format string.\n:pLt.string_len\n:pLd.Provides the length of :#x.format_string:e#x.. This operand is not\nrequired on the :#x.PL_PRINT_FORMATTED:e#x.\nmacro if the macro can determine the\nlength attribute of :#x.print_string:e#x..\nThe\n:hp1.string_len:ehp1. value may be coded as an integer or other\nnumeric term, or may refer to a field in storage of\n:hp1.size_length:ehp1. bytes in length, containing the string's length.\n:pLt.source\n:pLd.Specifies up to 50 substitution parameters to be processed by\nthe String Handler.\n:eplist.\n.*---------------------------------------------------------------------*\n:fh3.Examples\nThe following Printline macro requests a formatted print.\n:xmp.\nPL_PRINT_FORMATTED ID=PL,\n          STRING==C\"0 Line &lbr.I&rbr.   A &lbr.CL20&rbr. print line.\",\n          SOURCE=(LINECTR,RPTNAME)\n.sp\nLINECTR  DC   F'35'\nSPACING  DC   CL20\"double-spaced\"\n:exmp.\n:p.As a result, the following is produced:\n:xmp.\n Line 35   A double-spaced print line.\n:exmp.\n:efunc.\n.**********************************************************************\n.se temp = 'Query Remaining Lines On A Page'\n:func id=plqleft  name='PL_QUERY_LINES_LEFT'.&temp.\n.**********************************************************************\n:p.\nThe :#x.PL_QUERY_LINES_LEFT:e#x.\nfunction returns the number of lines remaining on the current page.\nThis is computed using the current line pointer and the footer space\nreserved at the bottom\nof the page. Note that\n:#x.PL_QUERY_LINES_LEFT:e#x.\nwill cause headers to be printed if\nthere are no headers yet on the current page.\n.*===>\n.*===> The :mac. and :callx. tags below are used to describe the\n.*===> syntax for invoking the function/macro.\n.*===>\n.*---------------------------------------------------------------------*\n.* Syntax box for the macro form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:mac.\nPL_QUERY_LINES_LEFT ID=:hp1.id_name:ehp1. &cont.\n&lbt.,SPEPA=:hp1.PL_epa:ehp1.&rbt. &cont.\n&lbt.,SPTOKEN=:hp1.PL_token:ehp1.&rbt.\n   ,LINES=:hp1.lines_remaining:ehp1.\n:emac.\n.*---------------------------------------------------------------------*\n.* Syntax box for the CALLX form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:callx.\nCALLX :hp1.PL_epa:ehp1.,&cont.\n(:hp1.PL_token:ehp1.,&amp.PL_PAGE_BREAK,:hp1.lines_remaining:ehp1.)\n:ecallx.\n.*---------------------------------------------------------------------*\n.* Parameter-list table describing each parameter.\n.*\n.* :plist.\n.* :pLt.parameter      | One pLt/pLd pair for each parameter that may\n.* :pLd.description    | be specified.\n.* :eplist.\n.*\n.*---------------------------------------------------------------------*\n:plist.\n:pLt.lines_remaining\n:pLd.specifies the address of a fullword where the\n:#x.PL_QUERY_LINES_LEFT:e#x. function will return the number of lines\nremaining on the current page.\n:eplist.\n.*---------------------------------------------------------------------*\n:fh3.Examples\nThe following Printline macro returns the lines remaining on the\ncurrent page.\n:xmp.\n     PL_QUERY_LINES_LEFT  ID=PL,LINES=PWA_Lines_Remaining\n                :\n                :\nPWA_Lines_Remaining  DS   F\n:exmp.\n:efunc.\n.**********************************************************************\n.se temp = 'Reserve Footer Space'\n:func id=plrsvft  name='PL_RESERVE_FOOTER'.&temp.\n.**********************************************************************\n:p.\nThe :#x.PL_RESERVE_FOOTER:e#x.  function reserves a number of lines at\nthe bottom of each page for footer space.  If footers are used, the\nvalue specified via\n:#x.PL_RESERVE_FOOTER:e#x.  is used in conjunction with the\n:#x.pagesize:e#x. parameter of\n:#x.PL_START:e#x. to determine when and where page footers need to be\nprinted.\n.*===>\n.*===> The :mac. and :callx. tags below are used to describe the\n.*===> syntax for invoking the function/macro.\n.*===>\n.*---------------------------------------------------------------------*\n.* Syntax box for the macro form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:mac.\nPL_RESERVE_FOOTER ID=:hp1.id_name:ehp1. &cont.\n&lbt.,SPEPA=:hp1.PL_epa:ehp1.&rbt. &cont.\n&lbt.,SPTOKEN=:hp1.PL_token:ehp1.&rbt.\n   ,LINES=:hp1.footer_space:ehp1.\n:emac.\n.*---------------------------------------------------------------------*\n.* Syntax box for the CALLX form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:callx.\nCALLX :hp1.PL_epa:ehp1.,&cont.\n(:hp1.PL_token:ehp1.,&amp.PL_RESERVE_FOOTER,&cont.\n:hp1.footer_space:ehp1.)\n:ecallx.\n.*---------------------------------------------------------------------*\n.* Parameter-list table describing each parameter.\n.*\n.* :plist.\n.* :pLt.parameter      | One pLt/pLd pair for each parameter that may\n.* :pLd.description    | be specified.\n.* :eplist.\n.*\n.*---------------------------------------------------------------------*\n:plist.\n:pLt.footer_space\n:pLd.Specifies the number of lines to be reserved at the bottom of\neach page for footer space.\n:eplist.\n.*---------------------------------------------------------------------*\n:fh3.Examples\nThe following Printline macro requests 5 lines of\nfooter space to be reserved.\n:xmp.\nPL_RESERVE_FOOTER ID=PL,&cont.\nLINES=5\n:exmp.\n:efunc.\n.**********************************************************************\n.se temp = 'Delete Footer Definitions'\n:func id=plrstft  name='PL_RESET_FOOTER'.&temp.\n.**********************************************************************\n:p.\nThe :#x.PL_RESET_FOOTER:e#x.\nfunction deletes one or all existing footer definitions.\nThe footers are referred to by their line number: if a line number\nof zero is specified, all existing footer definitions are deleted.\n.*===>\n.*===> The :mac. and :callx. tags below are used to describe the\n.*===> syntax for invoking the function/macro.\n.*===>\n.*---------------------------------------------------------------------*\n.* Syntax box for the macro form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:mac.\nPL_RESET_FOOTER ID=:hp1.id_name:ehp1. &cont.\n&lbt.,SPEPA=:hp1.PL_epa:ehp1.&rbt. &cont.\n&lbt.,SPTOKEN=:hp1.PL_token:ehp1.&rbt.\n   ,LINE=:hp1.line_number:ehp1.\n:emac.\n.*---------------------------------------------------------------------*\n.* Syntax box for the CALLX form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:callx.\nCALLX :hp1.PL_epa:ehp1.,&cont.\n(:hp1.PL_token:ehp1.,&amp.PL_RESET_FOOTER,&cont.\n:hp1.line_number:ehp1.)\n:ecallx.\n.*---------------------------------------------------------------------*\n.* Parameter-list table describing each parameter.\n.*\n.* :plist.\n.* :pLt.parameter      | One pLt/pLd pair for each parameter that may\n.* :pLd.description    | be specified.\n.* :eplist.\n.*\n.*---------------------------------------------------------------------*\n:plist.\n:pLt.line_number\n:pLd.Specifies an integer value denoting the footer line to be deleted.\nA :hp1.line_number:ehp1. value of zero requests all existing footer\ndefinitions to be deleted.\n:eplist.\n.*---------------------------------------------------------------------*\n:fh3.Examples\nThe following Printline macro requests the footer created as line 10\nto be deleted.\n:xmp.\nPL_RESET_FOOTER ID=PL,&cont.\nLINE=10\n:exmp.\nThis example requests all footer definitions to be deleted.\n:xmp.\nPL_RESET_FOOTER ID=PL,&cont.\nLINE=0\n:exmp.\n:efunc.\n.**********************************************************************\n.se temp = 'Delete Header Definitions'\n:func id=plrsthd  name='PL_RESET_HEADER'.&temp.\n.**********************************************************************\n:p.\nThe :#x.PL_RESET_HEADER:e#x.\nfunction deletes one or all existing header definitions.\nThe headers are referred to by their line number: if a line number\nof zero is specified, all existing header definitions are deleted.\n.*===>\n.*===> The :mac. and :callx. tags below are used to describe the\n.*===> syntax for invoking the function/macro.\n.*===>\n.*---------------------------------------------------------------------*\n.* Syntax box for the macro form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:mac.\nPL_RESET_HEADER ID=:hp1.id_name:ehp1. &cont.\n&lbt.,SPEPA=:hp1.PL_epa:ehp1.&rbt. &cont.\n&lbt.,SPTOKEN=:hp1.PL_token:ehp1.&rbt.\n   ,LINE=:hp1.line_number:ehp1.\n:emac.\n.*---------------------------------------------------------------------*\n.* Syntax box for the CALLX form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:callx.\nCALLX :hp1.PL_epa:ehp1.,&cont.\n(:hp1.PL_token:ehp1.,&amp.PL_RESET_HEADER,&cont.\n:hp1.line_number:ehp1.)\n:ecallx.\n.*---------------------------------------------------------------------*\n.* Parameter-list table describing each parameter.\n.*\n.* :plist.\n.* :pLt.parameter      | One pLt/pLd pair for each parameter that may\n.* :pLd.description    | be specified.\n.* :eplist.\n.*\n.*---------------------------------------------------------------------*\n:plist.\n:pLt.line_number\n:pLd.Specifies an integer value denoting the header line to be deleted.\nA :hp1.line_number:ehp1. value of zero requests all existing header\ndefinitions to be deleted.\n:eplist.\n.*---------------------------------------------------------------------*\n:fh3.Examples\nThe following Printline macro requests the header created as line 10\nto be deleted.\n:xmp.\nPL_RESET_HEADER ID=PL,&cont.\nLINE=10\n:exmp.\nThis example requests all header definitions to be deleted.\n:xmp.\nPL_RESET_HEADER ID=PL,&cont.\nLINE=0\n:exmp.\n:efunc.\n.**********************************************************************\n.se temp = 'Establish Simple Footers'\n:func id=plsetft  name='PL_SET_FOOTER'.&temp.\n.**********************************************************************\n:p.\nThe :#x.PL_SET_FOOTER:e#x. function defines a footer line to the\nPrintline session.\n.*===>\n.*===> The :mac. and :callx. tags below are used to describe the\n.*===> syntax for invoking the function/macro.\n.*===>\n.*---------------------------------------------------------------------*\n.* Syntax box for the macro form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:mac.\nPL_SET_FOOTER ID=:hp1.id_name:ehp1. &cont.\n&lbt.,SPEPA=:hp1.PL_epa:ehp1.&rbt. &cont.\n&lbt.,SPTOKEN=:hp1.PL_token:ehp1.&rbt.\n   ,LINE=:hp1.line_number:ehp1.\n   ,STRING=&lbr.:hp1.string_spec:ehp1. | &cont.\n:hp1.(string_spec,string_len):ehp1.&rbr.\n:emac.\n.*---------------------------------------------------------------------*\n.* Syntax box for the CALLX form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:callx.\nCALLX :hp1.PL_epa:ehp1.,(:hp1.PL_token:ehp1.,&amp.PL_SET_FOOTER,&cont.\n:hp1.line_number:ehp1.,&cont.\n:hp1.string_spec:ehp1.,\n             :hp1.string_len:ehp1.)\n.*===> If there are alternate forms, where the parameter list is\n.*===> significantly different depending on the first few parameter\n.*===> values, do something like the following:\n:ecallx.\n.*---------------------------------------------------------------------*\n.* Parameter-list table describing each parameter.\n.*\n.* :plist.\n.* :pLt.parameter      | One pLt/pLd pair for each parameter that may\n.* :pLd.description    | be specified.\n.* :eplist.\n.*\n.*---------------------------------------------------------------------*\n:plist.\n:pLt.line_number\n:pLd.Specifies an integer value denoting this footer line's relative\nposition among other footer lines.  Footer lines are printed in\nascending line number order.  The line numbers need not be contiguous:\nindeed, it may be desirable to 'insert' footer definitions under\nprogram control.  If a line number specifies an already-defined footer\nline, that footer line's definition is replaced.\nThe :hp1.line_number:ehp1. parameter may be coded as an integer or as\nthe address of a fullword.\n:pLt.string_spec\n:pLd.Specifies the character string, including ASA carriage control,\nfor the footer definition. The :hp1.string_spec:ehp1. may be coded as a\ncharacter literal or as the address of a character string.\n:pLt.string_len\n:pLd.Specifies the length of the footer's :hp1.string_spec:ehp1. value.\nIf :hp1.string_len:ehp1. is not specified, the PL_SET_FOOTER macro\nwill try to use the length attribute of :hp1.string_spec:ehp1..\nThe\n:hp1.string_len:ehp1. value may be coded as an integer or other\nnumeric term, or may refer to a field in storage of\n:hp1.size_length:ehp1. bytes in length, containing the string's length.\n:eplist.\n.*---------------------------------------------------------------------*\n.* Optional sections for describing how to use the function/macro.\n.*---------------------------------------------------------------------*\n:fh3.Examples\n:p.The following example will define a simple footer line.  Since the\nfirst character of the footer string is a '0', this footer line will\nalways be double-spaced (i.e. preceded by a blank line).\nThe footer's line number is set to 10, for\nsubsequent reference by other\n:#x.PL_SET_FOOTER:e#x.,\n:#x.PL_SET_FORMATTED_FOOTER:e#x., and\n:#x.PL_RESET_FOOTER:e#x. macros.\n:xmp.\nPL_SET_FOOTER ID=PL,\n          LINE=10,\n          STRING==C\"0 This footer line causes a double-space to occur.\"\n:exmp.\n:efunc.\n.**********************************************************************\n.se temp = 'Establish Formatted Footers'\n:func id=plfmtft  name='PL_SET_FORMATTED_FOOTER'.&temp.\n.**********************************************************************\n:p.\nThe :#x.PL_SET_FORMATTED_FOOTER:e#x.\nfunction defines a footer line to the\nPrintline session. The footer line will be formatted by the\nString Handler before it is printed, thus allowing variable data to\nbe included in report footers.\n.*===>\n.*===> The :mac. and :callx. tags below are used to describe the\n.*===> syntax for invoking the function/macro.\n.*===>\n.*---------------------------------------------------------------------*\n.* Syntax box for the macro form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:mac.\nPL_SET_FORMATTED_FOOTER ID=:hp1.id_name:ehp1. &cont.\n&lbt.,SPEPA=:hp1.PL_epa:ehp1.&rbt. &cont.\n&lbt.,SPTOKEN=:hp1.PL_token:ehp1.&rbt.\n   ,LINE=:hp1.line_number:ehp1.\n   ,CONTROL=&lbr.:hp1.format_spec:ehp1. | &cont.\n:hp1.(fmtspec,fmtlen):ehp1.&rbr.\n   &lbt.,PAGENUM=:hp1.page_offset:ehp1.&rbt.\n   &lbt.,SOURCE=&lbr.:hp1.source | &cont.\n:hp1.(source1,source2,...):ehp1.&rbr.&rbt.\n:emac.\n.*---------------------------------------------------------------------*\n.* Syntax box for the CALLX form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:callx.\nCALLX :hp1.PL_epa:ehp1.,&cont.\n(:hp1.PL_token:ehp1.,&amp.PL_SET_FORMATTED_FOOTER,&cont.\n:hp1.line_number:ehp1.,&cont.\n:hp1.format_spec:ehp1.,\n             :hp1.format_length:ehp1.,&cont.\n&lbr.:hp1.pagedisp:ehp1.,&cont.\n:hp1.arguments:ehp1.&rbr.)\n:ecallx.\n.*---------------------------------------------------------------------*\n.* Parameter-list table describing each parameter.\n.*\n.* :plist.\n.* :pLt.parameter      | One pLt/pLd pair for each parameter that may\n.* :pLd.description    | be specified.\n.* :eplist.\n.*\n.*---------------------------------------------------------------------*\n:plist.\n:pLt.line_number\n:pLd.Specifies an integer value denoting this footer line's relative\nposition among other footer lines.  Footer lines are printed in\nascending line number order.  The line numbers need not be contiguous:\nindeed, it may be desirable to 'insert' footer definitions under\nprogram control.  If a line number specifies an already-defined footer\nline, that footer line's definition is replaced.\nThe :hp1.line_number:ehp1. parameter may be coded as an integer or as\nthe address of a fullword.\n:pLt.format_spec\n:pLd.Specifies a format specification string,\nincluding ASA carriage control,\nfor the footer definition. The :hp1.format_spec:ehp1. may be coded as a\ncharacter literal or as the address of a character string.\n:pLt.format_length\n:pLd.Specifies the length of the footer's :hp1.format_spec:ehp1. value.\nIf :hp1.format_length:ehp1. is not specified, the\nPL_SET_FORMATTED_FOOTER macro\nwill try to use the length attribute of :hp1.format_spec:ehp1..  The\n:hp1.format_length:ehp1. value may be coded as an integer or other\nnumeric term, or may refer to a field in storage of\n:hp1.size_length:ehp1. bytes in length, containing the string's length.\n:pLt.page_disp\n:pLd.Specifies the displacement into the list of\n:hp1.source:ehp1. parameters\nwhere the Printline service processor will find a page number.\nFor example, a :hp1.page_disp:ehp1. value of \"3\" tells Printline that\nthe third :hp1.source:ehp1. parameter should be treated as a page\nnumber.  Page numbers defined in this way are auto-incremented by\nPrintline as page ejects occur.\n:pLt.source\n:pLd.Specifies source values for the String Handler to substitute into\nthe format specification provided by :hp1.format_spec:ehp1.\nUp to 50 substitution values may be specified.\n:eplist.\n.*---------------------------------------------------------------------*\n:fh3.Examples\nThe following Printline macro will establish a formatted footer line.\nThe definition includes a page number (fullword\n\"PAGECTR\") which will be\nformatted as the first substitution parameter in the format string.  The\nPAGECTR field is also auto-incremented at each page eject.\n:xmp.\nPL_SET_FORMATTED_FOOTER ID=PL,\n              LINE=10,\n              CONTROL=FORMAT,\n              PAGENUM=1,\n              SOURCE=(PAGECTR,RPTNAME)\n.sp\nPAGECTR  DC   F'0'\nRPTNAME  DC   CL20\"Macneil-Lehrer\"\nFORMAT   DC   C\"0 Page &lbr.I&rbr.   The &lbr.CL20&rbr. Report.\"\n:exmp.\nThe resulting string is printed as part of each subsequent page's\nfooter:\n:xmp.\n  Page 1     The MacNeil-Lehrer Report.\n:exmp.\nBecause of the carriage control of '0', this footer line will always be\npreceded by a blank line.\n:efunc.\n.**********************************************************************\n.se temp = 'Establish Formatted Headers'\n:func id=plfmthd  name='PL_SET_FORMATTED_HEADER'.&temp.\n.**********************************************************************\n:p.\nThe :#x.PL_SET_FORMATTED_HEADER:e#x.\nfunction defines a header line to the\nPrintline session. The header line will be formatted by the\nString Handler before it is printed, thus allowing variable data to\nbe included in report headers.\n.*===>\n.*===> The :mac. and :callx. tags below are used to describe the\n.*===> syntax for invoking the function/macro.\n.*===>\n.*---------------------------------------------------------------------*\n.* Syntax box for the macro form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:mac.\nPL_SET_FORMATTED_HEADER ID=:hp1.id_name:ehp1. &cont.\n&lbt.,SPEPA=:hp1.PL_epa:ehp1.&rbt. &cont.\n&lbt.,SPTOKEN=:hp1.PL_token:ehp1.&rbt.\n   ,LINE=:hp1.line_number:ehp1.\n   ,CONTROL=&lbr.:hp1.format_spec:ehp1. | &cont.\n:hp1.(fmtspec,fmtlen):ehp1.&rbr.\n   &lbt.,PAGENUM=:hp1.page_offset:ehp1.&rbt.\n   &lbt.,SOURCE=&lbr.:hp1.source | &cont.\n:hp1.(source1,source2,...):ehp1.&rbr.&rbt.\n:emac.\n.*---------------------------------------------------------------------*\n.* Syntax box for the CALLX form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:callx.\nCALLX :hp1.PL_epa:ehp1.,&cont.\n(:hp1.PL_token:ehp1.,&amp.PL_SET_FORMATTED_HEADER,&cont.\n:hp1.line_number:ehp1.,\n             :hp1.format_spec:ehp1.,&cont.\n:hp1.format_length:ehp1.,&cont.\n&lbr.:hp1.pagedisp:ehp1.,&cont.\n:hp1.arguments:ehp1.&rbr.)\n:ecallx.\n.*---------------------------------------------------------------------*\n.* Parameter-list table describing each parameter.\n.*\n.* :plist.\n.* :pLt.parameter      | One pLt/pLd pair for each parameter that may\n.* :pLd.description    | be specified.\n.* :eplist.\n.*\n.*---------------------------------------------------------------------*\n:plist.\n:pLt.line_number\n:pLd.Specifies an integer value denoting this header line's relative\nposition among other header lines.  Header lines are printed in\nascending line number order.  The line numbers need not be contiguous:\nindeed, it may be desirable to 'insert' header definitions under\nprogram control.  If a line number specifies an already-defined header\nline, that header line's definition is replaced.\nThe :hp1.line_number:ehp1. parameter may be coded as an integer or as\nthe address of a fullword.\n:pLt.format_spec\n:pLd.Specifies a format specification string,\nincluding ASA carriage control,\nfor the header definition. The :hp1.format_spec:ehp1. may be coded as a\ncharacter literal or as the address of a character string.\n:pLt.format_length\n:pLd.Specifies the length of the header's :hp1.format_spec:ehp1. value.\nIf :hp1.format_length:ehp1. is not specified, the\nPL_SET_FORMATTED_HEADER macro\nwill try to use the length attribute of :hp1.format_spec:ehp1..  The\n:hp1.format_length:ehp1. value may be coded as an integer or other\nnumeric term, or may refer to a field in storage of\n:hp1.size_length:ehp1. bytes in length, containing the string's length.\n:pLt.page_disp\n:pLd.Specifies the displacement into the list of\n:hp1.source:ehp1. parameters\nwhere the Printline service processor will find a page number.\nFor example, a :hp1.page_disp:ehp1. value of \"3\" tells Printline that\nthe third :hp1.source:ehp1. parameter should be treated as a page\nnumber.  Page numbers defined in this way are auto-incremented by\nPrintline as page ejects occur.\n:pLt.source\n:pLd.Specifies source values for the String Handler to substitute into\nthe format specification provided by :hp1.format_spec:ehp1.\nUp to 50 substitution values may be specified.\n:eplist.\n.*---------------------------------------------------------------------*\n:fh3.Examples\nThe following Printline macro will establish a formatted header line.\nThe definition includes a page number (fullword\n\"PAGECTR\") which will be\nformatted as the first substitution parameter in the format string.  The\nPAGECTR field is also auto-incremented at each page eject.\n:xmp.\nPL_SET_FORMATTED_HEADER ID=PL,\n              LINE=10,\n              control=FORMAT,\n              PAGENUM=1,\n              SOURCE=(PAGECTR,RPTNAME)\n.sp\nPAGECTR  DC   F'0'\nRPTNAME  DC   CL20\"Macneil-Lehrer\"\nFORMAT   DC   C\"1 Page &lbr.I&rbr.   The &lbr.CL20&rbr. Report.\"\n:exmp.\nThe resulting string is printed as part of each subsequent page's\nheader:\n:xmp.\n  Page 1     The MacNeil-Lehrer Report.\n:exmp.\nBecause of the carriage control of '1', this header line will always be\nprinted at the top of a new page.\n:efunc.\n.**********************************************************************\n.se temp = 'Establish Simple Headers'\n:func id=plsethd  name='PL_SET_HEADER'.&temp.\n.**********************************************************************\n:p.\nThe :#x.PL_SET_HEADER:e#x. function defines a header line to the\nPrintline session.\n.*===>\n.*===> The :mac. and :callx. tags below are used to describe the\n.*===> syntax for invoking the function/macro.\n.*===>\n.*---------------------------------------------------------------------*\n.* Syntax box for the macro form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:mac.\nPL_SET_HEADER ID=:hp1.id_name:ehp1. &cont.\n&lbt.,SPEPA=:hp1.PL_epa:ehp1.&rbt. &cont.\n&lbt.,SPTOKEN=:hp1.PL_token:ehp1.&rbt.\n   ,LINE=:hp1.line_number:ehp1.\n   ,STRING=&lbr.:hp1.string_spec:ehp1. | &cont.\n:hp1.(string_spec,string_len):ehp1.&rbr.\n:emac.\n.*---------------------------------------------------------------------*\n.* Syntax box for the CALLX form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:callx.\nCALLX :hp1.PL_epa:ehp1.,(:hp1.PL_token:ehp1.,&amp.PL_SET_HEADER,&cont.\n:hp1.line_number:ehp1.,&cont.\n:hp1.string_spec:ehp1.,\n              :hp1.string_len:ehp1.)\n.*===> If there are alternate forms, where the parameter list is\n.*===> significantly different depending on the first few parameter\n.*===> values, do something like the following:\n:ecallx.\n.*---------------------------------------------------------------------*\n.* Parameter-list table describing each parameter.\n.*\n.* :plist.\n.* :pLt.parameter      | One pLt/pLd pair for each parameter that may\n.* :pLd.description    | be specified.\n.* :eplist.\n.*\n.*---------------------------------------------------------------------*\n:plist.\n:pLt.line_number\n:pLd.Specifies an integer value denoting this header line's relative\nposition among other header lines.  Header lines are printed in\nascending line number order.  The line numbers need not be contiguous:\nindeed, it may be desirable to 'insert' header definitions under\nprogram control.  If a line number specifies an already-defined header\nline, that header line's definition is replaced.\nThe :hp1.line_number:ehp1. parameter may be coded as an integer or as\nthe address of a fullword.\n:pLt.string_spec\n:pLd.Specifies the character string, including ASA carriage control,\nfor the header definition. The :hp1.string_spec:ehp1. may be coded as a\ncharacter literal or as the address of a character string.\n:pLt.string_len\n:pLd.Specifies the length of the header's :hp1.string_spec:ehp1. value.\nIf :hp1.string_len:ehp1. is not specified, the PL_SET_HEADER macro\nwill try to use the length attribute of :hp1.string_spec:ehp1..  The\n:hp1.string_len:ehp1. value may be coded as an integer or other\nnumeric term, or may refer to a field in storage of\n:hp1.size_length:ehp1. bytes in length, containing the string's length.\n:eplist.\n.*---------------------------------------------------------------------*\n.* Optional sections for describing how to use the function/macro.\n.*---------------------------------------------------------------------*\n:fh3.Examples\n:p.The following example will define a simple header line.  Since the\nfirst character of the header string is a '1', this header line will\nalways cause a page eject.  The header's line number is set to 10, for\nsubsequent reference by other\n:#x.PL_SET_HEADER:e#x.,\n:#x.PL_SET_FORMATTED_HEADER:e#x., and\n:#x.PL_RESET_HEADER:e#x. macros.\n:xmp.\nPL_SET_HEADER ID=PL,\n              LINE=10,\n              STRING==C\"1 This header line causes a page eject.\"\n:exmp.\n:efunc.\n.**********************************************************************\n.se temp = 'Begin A Printline Session'\n:func id=plstart name='PL_START'.&temp.\n.**********************************************************************\n:p.\nThe :#x.PL_START:e#x. function establishes\na new Printline session and returns its session identifier in the\n:hp1.pl_token:ehp1. parameter.  The page size, maximum line length\nand size of fields specifying string lengths are determined by the\n:hp1.pagesize:ehp1., :hp1.maxlinesize:ehp1. and :hp1.sizelength:ehp1.\noperands, respectively.\n.*===>\n.*===> The :mac. and :callx. tags below are used to describe the\n.*===> syntax for invoking the function/macro.\n.*===>\n.*---------------------------------------------------------------------*\n.* Syntax box for the macro form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:mac.\nPL_START ID=:hp1.id_name:ehp1. &cont.\n&lbt.,SPEPA=:hp1.PL_epa:ehp1.&rbt. &cont.\n&lbt.,SPTOKEN=:hp1.PL_token:ehp1.&rbt.\n   &lbt.,ESVA=:hp1.esva:ehp1.&rbt.\n   ,DDNAME=:hp1.ddname:ehp1.\n   &lbt.,PAGESIZE=&lbr.:hp1.pagesize:ehp1. | &cont.\n:hp2.66:ehp2.&rbr.&rbt.\n   &lbt.,MAXLNSZ=&lbr.:hp1.maximum_linesize:ehp1. | &cont.\n:hp2.133:ehp2.&rbr.&rbt.\n   &lbt.,SIZELENGTH=&lbr.:hp1.integer:ehp1. | &cont.\n:hp2.2:ehp2.&rbr.&rbt.\n   &lbt.,OPTIONS=(:hp1.option_list:ehp1.)&rbt.\n:emac.\n.*---------------------------------------------------------------------*\n.* Syntax box for the CALLX form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:callx.\nCALLX :hp1.PL_epa:ehp1.,(:hp1.PL_token:ehp1.,&amp.PL_START,&cont.\n:hp1.esva:ehp1.,&cont.\n:hp1.ddname:ehp1.,&cont.\n:hp1.pagesize:ehp1.,&cont.\n:hp1.maxlinesize:ehp1.,\n              :hp1.sizelength:ehp1.,:hp1.option_byte:ehp1.)\n.*===> If there are alternate forms, where the parameter list is\n.*===> significantly different depending on the first few parameter\n.*===> values, do something like the following:\n:ecallx.\n.*---------------------------------------------------------------------*\n.* Parameter-list table describing each parameter.\n.*\n.* :plist.\n.* :pLt.parameter      | One pLt/pLd pair for each parameter that may\n.* :pLd.description    | be specified.\n.* :eplist.\n.*\n.*---------------------------------------------------------------------*\n:plist.\n:pLt.esva\n:pLd.Specifies the label of a fullword in storage that contains the\naddress of the Environment Support Vector (ESV) created by the\nES_START function.\n:pLt.ddname\n:pLd.Specifies the DDname that this Printline session will use to\nwrite its\noutput.  The default DCB attributes are RECFM=VBA,LRECL=maxlinesize,\nBLKSIZE=LRECL+4; however, any DCB attribute combination acceptable\nto the OS File Handler is acceptable to Printline.\n:pLt.pagesize\n:pLd.Specifies the number of lines that the report page should contain.\nThis value is used to determine when Printline should print headers and\nfooters, as well as increment page counters.\n:pLt.maxlinesize\n:pLd.Specifies a field containing the maximum linesize that Printline\nshould write.  This value will become the logical record length of the\nreport file produced.  Should a data, header or footer line's length\nexceed the maxlinesize value, the line will be truncated and printed,\nand a truncation error will be returned.\n:pLt.sizelength\n:pLd.An integer value from 1 and 4 that determines the size, in bytes,\nof all values representing string lengths by the String Handler.  For\nexample, a :hp1.sizelength:ehp1. value of 4 would cause all lengths\nreturned by the String Handler to be 4 bytes in length.\n:pLt.option_list\n:pLd.A list of additional options for this PrintLine session. If\nmultiple option values are specified, they must be enclosed in\nparentheses.\nThe only\noption currently supported is :hp1.FOLD:ehp1..\n:ul.\n:li.:hp2.FOLD:ehp2. - All output produced by PrintLine should be\nfolded to uppercase.  If using the CALLX form to call\n:hp1.PL_START:ehp1., the FOLD option corresponds to a bit setting of\nX'80' in the option byte.\n:eul.\n:eplist.\n.*---------------------------------------------------------------------*\n.* Optional sections for describing how to use the function/macro.\n.*---------------------------------------------------------------------*\n.*---------------------------------------------------------------------*\n.* Examples showing how to use it and neat ways to take advantage of\n.* the function's capabilities.\n.*\n.*===> If one or two separate examples are being done, simply use\n.*===>\n.*===> :fh3.Example 1\n.*===>   ...example 1 stuff...\n.*===> :fh3.Example 2\n.*===>   ...example 2 stuff...\n.*===>\n.*===> If a whole system of related examples are being done, use\n.*===>\n.*===> :fh3.Examples\n.*===>   ....description general to all examples.\n.*===> :h5.Example 1\n.*===>   ...example 1 stuff...\n.*===> :h5.Example 2\n.*===>   ...example 2 stuff...\n.*===>\n.*---------------------------------------------------------------------*\n:fh3.Examples\n:p.\nThe following :#x.PL_START:e#x.\nmacro will initialize a Printline session.  Invoking PL_START will\ncause the following to occur:\n:ul compact.\n:li.The SPTOKEN value is set to the new Printline session's unique\ntoken value.\n:li.Blocksize information from the DD statement referred to by\n:#x.ddname:e#x. is merged into Printline's report DCB.\n:li.The report file referred to by\n:#x.ddname:e#x. is opened.\n:li.All headers, footers and data lines are to be converted to\nuppercase.\n:eul.\n:xmp.\n    PL_START ID=PL,\n             SPEPNAME=&amp.PRINT_LINE,\n             SPEPA=PWA_PL_ENTRY,\n             SPTOKEN=PWA_PL_TOKEN,\n             ESID=ES,\n             ESVA=PWA_ESVA,\n             SIZELENGTH=4,\n             DDNAME==C'SYSPRINT',\n             OPTIONS=(FOLD)\n.sp 2\nPWA_PL_ENTRY  DS    F         Entrypoint for Printline\nPWA_PL_TOKEN  DS    F         Unique token for Printline session\nPWA_ESVA      DS    F         Environment Support Vector address\n:exmp.\n:p.In this example, the :#x.SPEPNAME:e#x., :#x.SPEPA:e#x.,\n:#x.SPTOKEN:e#x., :#x.ESID:e#x., :#x.ESVA:e#x. and :#x.SIZELENGTH:e#x.\nparameters are included only for completeness.  They may be specified\non the :#x.PL_ID:e#x. macro and omitted from the call to\n:#x.PL_START:e#x., as follows:\n:xmp.\n    PL_START ID=PL,\n             DDNAME==C'SYSPRINT'\n:exmp.\n:efunc.\n.**********************************************************************\n.se temp = 'Terminate A Printline Session'\n:func id=plterm name='PL_TERMINATE'.&temp.\n.**********************************************************************\n:p.\nThe :#x.PL_TERMINATE:e#x. function concludes\nthe Printline session identified by the\n:hp1.pl_token:ehp1. parameter, and releases any resources held\nby the Printline service processor.\n.*===>\n.*===> The :mac. and :callx. tags below are used to describe the\n.*===> syntax for invoking the function/macro.\n.*===>\n.*---------------------------------------------------------------------*\n.* Syntax box for the macro form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:mac.\nPL_TERMINATE ID=:hp1.id_name:ehp1. &cont.\n&lbt.,SPEPA=:hp1.PL_epa:ehp1.&rbt. &cont.\n&lbt.,SPTOKEN=:hp1.PL_token:ehp1.&rbt.\n:emac.\n.*---------------------------------------------------------------------*\n.* Syntax box for the CALLX form of invoking this function/macro.\n.*---------------------------------------------------------------------*\n:callx.\nCALLX :hp1.PL_epa:ehp1.,(:hp1.PL_token:ehp1.,&amp.PL_TERMINATE)\n.*===> If there are alternate forms, where the parameter list is\n.*===> significantly different depending on the first few parameter\n.*===> values, do something like the following:\n:ecallx.\n.*---------------------------------------------------------------------*\n.* Parameter-list table describing each parameter.\n.*\n.* :plist.\n.* :pLt.parameter      | One pLt/pLd pair for each parameter that may\n.* :pLd.description    | be specified.\n.* :eplist.\n.*\n.*---------------------------------------------------------------------*\n.* There are no function-specific parameters for PL_TERMINATE.\n.*---------------------------------------------------------------------*\n.* Optional sections for describing how to use the function/macro.\n.*---------------------------------------------------------------------*\n.*===> If one or two separate examples are being done, simply use\n.*===>\n.*===> :fh3.Example 1\n.*===>   ...example 1 stuff...\n.*===> :fh3.Example 2\n.*===>   ...example 2 stuff...\n.*===>\n.*===> If a whole system of related examples are being done, use\n.*===>\n.*===> :fh3.Examples\n.*===>   ....description general to all examples.\n.*===> :h5.Example 1\n.*===>   ...example 1 stuff...\n.*===> :h5.Example 2\n.*===>   ...example 2 stuff...\n.*===>\n.*---------------------------------------------------------------------*\n:fh3.Examples\n:p.The following :#x.PL_TERMINATE:e#x. macro will cause Printline to\nclose its report file and release any resources that it acquired.\n:xmp.\nPL_TERMINATE ID=PL\n:exmp.\n:efunc.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SRVDOCST": {"ttr": 14853, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x02\\x00\\x00V\\x01\\x11)\\x9f\\x01\\x11)\\x9f\\t'\\x04n\\x04n\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@\"", "ispf": {"version": "02.00", "flags": 0, "createdate": "2011-10-26T00:00:00", "modifydate": "2011-10-26T09:27:56", "lines": 1134, "newlines": 1134, "modlines": 0, "user": "CLEMSON"}, "text": ".*SRVST***************************************************************\n.*                                                                    *\n.*                    Chapter. String Handler                         *\n.*                                                                    *\n.**********************************************************************\n:h1 id=srvst.String Handler\n:p.\nThe String Handler provides common functions for string manipulation,\nincluding formatting functions and data conversions.\n:p.\nApplications use the string handler to convert back and forth between\ntextual and non-textual representations of data, and to manipulate text\nstrings.  The most heavily used function of the string handler is the\n:#x.ST_FORMAT:e#x. function, which can construct a text string from an\narbitrary number of (text and non-text) parameters.\n:#x.ST_FORMAT:e#x. is extremely useful for constructing error\nmessages that contain imbedded information.\n.*--------------------------------------------------------------------*\n:h2.Preparing to Use the String Handler\n.*--------------------------------------------------------------------*\n:p.\nThe String Handler operates independently of its execution environment\nand may be used with any Environment Support service processor.  Like\nany service processor, the String Handler must be loaded and started\nbefore its functions can be used.  This process is fully covered in\n:hdref refid=part1 page=no. and will not be repeated here.\n:p.\nThe String Handler's service processor identification code is :#xb.ST:e#xb.\nso:\n:ul.\n:li.the :#x.COPY:e#x. member is :#x.SRV:#xb.ST:e#xb.MAC:e#x.,\n:li.the load module, named by symbol :#x.&amp.ST_STRING_HANDLER:e#x., is\n:#x.SRV:#xb.ST:e#xb.:e#x.,\n:li.and the names of all symbols, macros, and conditions begin with the\nprefix :#xb.ST_:e#xb..\n:eul.\n:p.\nGlobal String Handler stuff goes here as well as tips on how to make\nbetter use of it.\n.*--------------------------------------------------------------------*\n:h2.Common Parameters\n.*--------------------------------------------------------------------*\n:p.\nSeveral parameters are common to all String Handler function calls.\nThese parameters are listed below:\n.*****\n:plist.\n:pLt.id_name\n:pLd.specifies the name of a service processor identifier created by the\n:#x.ST_ID:e#x. macro which will be used by all other function invocation\nmacros to automatically obtain values for :#xi.st_epa:e#xi. and\n:#xi.st_token:e#xi.. This parameter is required unless both\n:#xi.st_epa:e#xi. and :#xi.st_token:e#xi. are specified.\n:pLt.st_epa\n:pLd.a fullword in storage containing the entry point address of the\nString Handler service processor.  The value specified by\n:#xi.st_epa:e#xi.  overrides any value obtained from\n:#x.ID=:e#x.:#xi.id_name:e#xi..\n:pLt.st_token\n:pLd.specifies the label of a fullword in storage that contains the\nvalue (to be) returned by :#x.ST_START:e#x. for the\n:#xi.st_token:e#xi. parameter.  The value specified by\n:#xi.st_token:e#xi. overrides any value obtained from\n:#x.ID=:e#x.:#xi.id_name:e#xi..\n:eplist.\n.*--------------------------------------------------------------------*\n:h2.Complete List of String Handler Return Codes\n.*--------------------------------------------------------------------*\n:p.\nMany return codes can be returned from each function.  In the function\ndescriptions later in this chapter, the most common return codes\nreturned by the particular function are documented.  The following\nis a complete list of String Handler return codes.\n.*****\n:rclist.\n:rcn.0\n:rct.ST_SUCCESS\n:rcd.The invoked String Handler function performed the requested\nservice without encountering any problems.\n:rcn.1\n:rct.ST_INVALID_FUNCTION\n:rcd.An invalid :#xi.FunctionCode:e#xi. (the second parameter in any\nservice processor function call) was specified.\n:rcn.2:rct.ST_INVALID_SIZELENGTH\n:rcd.The value specified for :#xi.sizelength:e#xi. was not :#xb.1:e#xb.,\n:#xb.2:e#xb., :#xb.3:e#xb., or :#xb.4:e#xb..\n:rcn.3\n:rct.ST_TRUNCATED\n:rcd.The formatted string was too long to fit into the area specified\nby :#xi.string:e#xi. and the only the first :#xi.string_length:e#xi.\ncharacters were used.  :#xi.Result_length:e#xi. has been set to the\nlength of the truncated result and is equal to :#xi.string_length:e#xi..\n:rcn.4\n:rct.ST_OVERLAP\n:rcd.The area referenced by :#xi.string:e#xi. overlaps in storage with\nthe control string or a source argument.  Results are unpredictable\nbecause the overlap could be detected at any point in the formatting\nprocess.  Formatting was halted immediately and :#xi.result_length:e#xi.\nhas been set to the length of the formatted string up to the point of\nerror.\n:rcn.5\n:rct.ST_INTERNAL_ERROR\n:rcd.The String Handler detected an error during an internal consistancy\ncheck.  This is likely a problem with the String Handler itself and not\nthe program that called it.\n:rcn.6\n:rct.ST_WRONG_NUMBER_OF_ PARAMETERS\n:rcd.The :#x.ST_FORMAT:e#x. function has seven (7) required parameters,\nand :#x.ST_FORMAT2:e#xi. has nine (9) required parameters.  Less than\nthe required number of parameters were coded.\n:rcn.7\n:rct.ST_INVALID_SOURCE_LENGTH\n:rcd.The length of a source argument, as specified with the format\nspecifier :#xb.L:e#xb.:#xi.length:e#xi. was outside the supported\nrange of lengths for that argument's type.  See :hdref refid=stctl. for\nmore information.\n:rcn.8\n:rct.ST_INVALID_SOURCE_FORMAT\n:rcd.The text in :#xi.string:e#xi. does not conform to the required\nformat, and could not be converted to an integer.\n:rcn.9\n:rct.ST_MAGNITUDE\n:rcd.:#x.ST_FORMAT:e#x.: the length of a source argument, as specified\nwith the format specifier :#xb.L:e#xb.:#xi.length:e#xi. was too large to\nrepresent as a fullword signed binary integer.\n:p.:#x.ST_STRING_TO_INTEGER:e#x.:  the value represented by the digits\nin :#xi.string:e#xi. is too large to be contained in a fullword binary\nvalue.  It must be between -2147483648 and 2147483647.\n:rcn.10\n:rct.ST_FORMAT_COLUMN_TOO_LARGE\n:rcd.The specified column position was beyond the end of the area\nreferenced by :#xi.string:e#xi..  That is, it was larger than the value\nof :#xi.string_length:e#xi..\n:rcn.11\n:rct.ST_FORMAT_COLUMN_TOO_SMALL\n:rcd.The specified column position was negative.\n:rcn.12\n:rct.ST_FORMAT_LENGTH_TOO_LARGE\n:rcd.The length specified in a format specification was larger than the\nmaximum allowed length for that type.\n:rcn.13\n:rct.ST_FORMAT_LENGTH_TOO_SMALL\n:rcd.The length specified in a format specification was smaller than the\nminimum allowed length for that type.\n:rcn.14\n:rct.ST_FORMAT_PRECISION_ TOO_SMALL\n:rcd.The precision specified in a format specification was negative or\nzero.  It must be positive.\n:rcn.15\n:rct.ST_FORMAT_MISSING_ARGUMENT\n:rcd.The format specifications in the control string referenced more\n:#xi.arguments:e#xi. than were present.\n:rcn.16\n:rct.ST_FORMAT_MISSING_ COLUMN_VALUE\n:rcd.A format specification contained a relative column\n(:#x.@+:e#x. or :#x.@-:e#x.), with no column number or question mark.\n:rcn.17\n:rct.ST_FORMAT_MISSING_ LENGTH_VALUE\n:rcd.A format specification contained the :#xb.L:e#xb. of the\n:#xb.L:e#xb.:#xi.length:e#xi. item, but the :#xi.length:e#xi. part\n(an integer or question mark) was not specified.\n:rcn.18\n:rct.ST_FORMAT_MISSING_ PRECISION_VALUE\n:rcd.A format specification contained the :#xb..:e#xb. of the\n:#xb..:e#xb.:#xi.precision:e#xi. item, but the :#xi.precision:e#xi.\npart (an integer or question mark) was not specified.\n:rcn.19\n:rct.ST_FORMAT_TYPE_REQUIRED\n:rcd.A format specification contained one or more items associated\nwith the :#xi.type:e#xi. item, but no :#xi.type:e#xi. was specified.\n:rcn.20\n:rct.ST_FORMAT_SPEC_EMPTY\n:rcd.A format specification contained no items within the enclosing\nbraces.\n:rcn.21\n:rct.ST_FORMAT_SPEC_NOT_ENDED\n:rcd.The closing brace was not present for a format specification.\nCheck the :#xi.control_length:e#xi. parameter to insure that it was\ncorrect.\n:rcn.22\n:rct.ST_FORMAT_UNSUPPORTED_ KEYWORD\n:rcd.A keyword was specified that is not in :tref refid=fskwds..\n:rcn.23\n:rct.ST_FORMAT_UNSUPPORTED_TYPE\n:rcd.A :#xi.type:e#xi. was specified that is not in\n:tref refid=fstcds..\n:rcn.24\n:rct.ST_FORMAT_UNSUPPORTED_ITEM\n:rcd.An item was specified that did not conform to the syntax for\nformat specifications described on page :spotref refid=fssyntx..\n:rcn.25\n:rct.ST_FORMAT_PAD_TYPE_CONFLICT\n:rcd.A leading zero was specified with :#xi.width:e#xi., but the\n:#xi.type:e#xi. item specified a non-numeric :#xi.argument:e#xi..\n:rcn.26\n:rct.ST_FORMAT_FILL_TOO_LONG\n:rcd.The fill pattern supplied within an :#x.ST_FORMAT:e#x.\nformat-specification was longer than 256 characters, the\nmaximum length permitted for fill patterns.\n:rcn.27\n:rct.ST_FORMAT_MISSING_ MULTIPLE_VALUE\n:rcd.A format specification contained the :#xb.M:e#xb. of the\n:#xb.M:e#xb.:#xi.multiple:e#xi. item, but the :#xi.multiple:e#xi. part\n(an integer or question mark) was not specified.\n:rcn.28\n:rct.ST_FORMAT_MULTIPLE_ TOO_SMALL\n:rcd.The specified multiple was zero.\n:rcn.29\n:rct.ST_FORMAT_MULTIPLE_ NOT_ALLOWED\n:rcd.You cannot specify Multiple in conjunction with keywords\nCENTER, RIGHT, or FILL.\n:rcn.30\n:rct.ST_FORMAT_KEYWORD_CONFLICT\n:rcd.Mutually exclusive keywords were specified. CSV and QST cannot be\nspecified with CENTER, RIGHT, or FILL.\n:rcn.31\n:rct.ST_FORMAT_QST_TYPE_CONFLICT\n:rcd.Keyword QST requires type character.\n:erclist.\n.*--------------------------------------------------------------------*\n:h2.String Handler Service Processor Functions\n.*--------------------------------------------------------------------*\n:p.\nThe remaining sections of this chapter describe all functions provided\nby the String Handler service processor, arranged in alphabetical order.\nEach function's description begins on a new page, and the name of the\nfunction being described appears in the top outside corner of every\npage.\n.**********************************************************************\n.se temp = 'Build a Text String from Arbitrary Parameters'\n:func id=stfrmt name='ST_FORMAT'.&temp.\n.**********************************************************************\n:i1.control string\n:i1.format specification\n:i1.format\n:i1.formatting\n:p.\nThe :#x.ST_FORMAT:e#x. function constructs a formatted string from an\narbitrary number of input sources and places it in the area specified by\nthe :#xi.string:e#xi. parameter. A control string, consisting\nof ordinary text and imbedded :hp1.format specifications:ehp1., is used\nto guide the formatting process.  The resulting string will appear\nsimilar to the control string, except that the format specifications\nwill be replaced with the data they indicate.\n:p.\nThis function is most useful for formatting messages.  Contextual\ninformation can easily be included in a message to assist the user in\ndiagnosing and correcting problems.  Consider the following message,\nwhich is produced by the :#x.FI_START:e#x. function of the File Handler:\n:xmp.\n:spot id=fi104e.\n'FI00104E Member &lbr.CL8&rbr. not in &lbr.CL? TRIM&rbr..',&cont.\nMEMBER,DSNAME,DSNAME_LENGTH\n:exmp.\nWhen the File Handler invokes :#x.ST_FORMAT:e#x., the member name and\ndataset name will be inserted into the message text itself to produce a\nformatted message such as the following:\n:xmp.\n'FI00104E Member LABELS not in HENRY.ISPF.SOURCE.'\n:exmp.\n:mac.\nST_FORMAT ID=:hp1.id_name:ehp1. &cont.\n&lbt.,SPEPA=:hp1.st_epa:ehp1.&rbt. &cont.\n&lbt.,SPTOKEN=:hp1.st_token:ehp1.&rbt.\n   ,CONTROL=&lbr.:hp1.control:ehp1. | &cont.\n(:hp1.control:ehp1.,:hp1.control_length:ehp1.)&rbr.\n  &lbt.,SOURCE=(:hp1.argument:ehp1.&cont.\n&lbr.,:hp1.argument:ehp1.&rbr.) | &cont.\nSOURCELIST=(:hp1.arglist:ehp1.,:hp1.argcount:ehp1.)&rbt.\n  &lbt.,STRING=&lbr.:hp1.string:ehp1. | &cont.\n(:hp1.string:ehp1.,:hp1.string_length:ehp1.)&rbr.&rbt.\n  &lbt.,RESULTLEN=:hp1.result_length:ehp1.&rbt.\n:emac.\n:callx.\nCALLX :hp1.st_epa:ehp1.,(:hp1.st_token:ehp1.,&amp.ST_FORMAT,&cont.\n:hp1.string:ehp1.,:hp1.string_length:ehp1.,&cont.\n&lbt.:hp1.result_length:ehp1.&rbt.,\n              :hp1.control:ehp1.,:hp1.control_length:ehp1.&cont.\n&lbr.,:hp1.argument:ehp1.&rbr.)\n\n- or -\n\nCALLX :hp1.st_epa:ehp1.,(:hp1.st_token:ehp1.,&amp.ST_FORMAT2,&cont.\n:hp1.string:ehp1.,:hp1.string_length:ehp1.,&cont.\n&lbt.:hp1.result_length:ehp1.&rbt.,\n              :hp1.control:ehp1.,:hp1.control_length:ehp1.,&cont.\n:hp1.arglist:ehp1.,:hp1.argcount:ehp1.)\n:ecallx.\n.*****\n:plist.\n:pLt.control\n:pLd.specifies the label of a string containing information to guide the\nformatting process.  See the section below, :hdref refid=stctl., for how\nthis string should be specified.\n:pLt.control_length\n:pLd.specifies the label of a signed binary integer indicating the\nlength of the string identified by the :#xi.control:e#xi.\nparameter. The\n:#xi.control_length:e#xi. parameter may be from one to four\nbytes in length, as determined by the :#xi.sizelength:e#xi.\nparameter of the :#x.ST_START:e#x. function.\n:note.The macro form of :#x.ST_FORMAT:e#x. will attempt to generate a\nvalue for :#xi.control_length:e#xi. automatically if it is not\nspecified.  In order to generate the right value, however,\n:#xi.sizelength:e#xi. must have previously been specified on the\n:#x.ST_ID:e#x. macro.\n:pLt.string\n:pLd.specifies the area of storage in which the formatted string will be\nconstructed.\n:pLt.string_length\n:pLd.specifies the label of a signed binary integer indicating the\nlength of the area referenced by :#xi.string:e#xi..  This parameter may\nbe from one to four bytes in length, as determined by the\n:#xi.sizelength:e#xi. parameter of the :#x.ST_START:e#x.\nfunction.\n:note.The macro form of :#x.ST_FORMAT:e#x. will attempt to generate a\nvalue for :#xi.string_length:e#xi. automatically if it is not\nspecified.  In order to generate the right value, however,\n:#xi.sizelength:e#xi. must have previously been specified on the\n:#x.ST_ID:e#x. macro.\n:pLt.result_length\n:pLd.specifies a field into which a signed binary integer containing the\nlength of the formatted string will be placed.  The\n:#xi.result_length:e#xi. parameter may be from one to four\nbytes in length, as determined by the :#xi.sizelength:e#xi.\nparameter of the\n:#x.ST_START:e#x. function.\n:pLt.&lbr.argument&rbr.\n:pLd.Values in storage that are referenced by format specifications\nimbedded in the :#xi.control:e#xi. string.  The number of\n:#xi.argument:e#xi.s required, as well as their data formats,\nis determined by the format specifications imbedded in the control\nstring.\n:pLt.arglist\n:pLd.References a separate parameter list that contains the\n:#xi.argument:e#xi.s referenced by format specifications.  This\nparameter requires the :#xi.argcount:e#xi. parameter also, and is only\nused with the :#x.ST_FORMAT2:e#x. interface to the format function.\n:pLt.argcount\n:pLd.Specifies a signed fullword in storage containing the number of\n:#xi.argument:e#xi.s contained in :#xi.arglist:e#xi..\n:eplist.\n:fh3 id=stctl.Specifying Control Strings\n:p.\nThe :#xi.control:e#xi. parameter is a character string consisting of\nnormal text intermixed with :hp1.format specifications:ehp1. that acts\nas a template to guide the formatting process.  The control string\nbelow, for example, contains two format specifications:\n:xmp.\n'FI00104E Member &lbr.CL8&rbr. not in &lbr.CL? TRIM&rbr..'\n:exmp.\nAs :#x.ST_FORMAT:e#x.  scans :#xi.control:e#xi. from left to right, it\nbuilds a formatted string in the area referenced by the\n:#xi.string:e#xi. parameter.  Normal text is copied directly to the\n:#xi.string:e#xi. area.  When a format specification is encountered,\n:#x.ST_FORMAT:e#x. suspends the copying of normal text and performs the\noperation indicated by the format specification.  It then resumes its\nscan of the control string following the format specification.\n:p.\nEach format specification may call for values to be taken from one or\nmore :#xi.argument:e#xi.s, which are always referenced in consecutive\norder: first, second, third, etc.  The value of an :#xi.argument:e#xi.\nis never modified by :#x.ST_FORMAT:e#x., although a formatted copy of\nthat value may be placed in :#xi.string:e#xi..  A format specification\nis distinguished from surrounding text in the :#xi.control:e#xi. string\nwith braces (:#xb.&lbr. &rbr.:e#xb.) and has one of the following forms,\nwhere brackets (&lbt. &rbt.) indicate optional items.\n:spot id=fssyntx.\n:sl.\n:li.\n:#xb.&lbr.:e#xb.&cont.\n&lbt.:#xb.0:e#xb.&rbt.&lbt.:#xi.width:e#xi.&rbt.&cont.\n&lbt.:#xb..:e#xb.:#xi.precision:e#xi.&rbt.&cont.\n&lbt.:#xb.@:e#xb.&lbt.:#xi.column:e#xi.&rbt.&rbt.&cont.\n:#xi.type:e#xi.&cont.\n&lbt.:#xb.L:e#xb.:#xi.length:e#xi.&rbt.&cont.\n&lbt.:#xb.M:e#xb.:#xi.multiple:e#xi.&rbt.&cont.\n&lbt. :#xi.keyword...:e#xi.&rbt.&cont.\n:#xb.&rbr.:e#xb.\n:li.\n:#xb.&lbr.:e#xb.&cont.\n:#xb.@:e#xb.&lbt.:#xi.column:e#xi.&rbt.&cont.\n:#xb.&rbr.:e#xb.\n:li.\n:#xb.&lbr.:e#xb.&cont.\n:#xb.&lbr.:e#xb.&cont.\n:esl.\n:p.\nIn the syntax above, :#xi.type:e#xi. is a single letter that references\nan associated source :#xi.argument:e#xi., and\n&lbt.:#xi.keyword...:e#xi.&rbt. is a list of words that provide optional\nformatting information.\n:p.\n:#xi.Arguments:e#xi. are taken in the same order as the items in a format\nspecification that reference them (i.e.&rbl.:#xi.width:e#xi. first, then\n:#xi.precision:e#xi.,\n:#xi.column:e#xi.,\n:#xi.type:e#xi., and :#xi.length:e#xi.).\n:p.\n:#xi.Width:e#xi., :#xi.precision:e#xi., :#xi.column:e#xi.,\n:#xi.length:e#xi., and :#xi.multiple:e#xi. are all integers that can be\ncoded as either a sequence of digits or as a question mark\n(:#xb.?:e#xb.) to reference the value contained in an associated\n:#xi.argument:e#xi..  When a question mark is used, the referenced\n:#xi.argument:e#xi. must be a signed binary integer that is\n:#xi.sizelength:e#xi. bytes in length (see the :#xi.sizelength:e#xi.\nparameter of :#x.ST_START:e#x. on page :spotref refid=sizelen.).\nOptionally,\n:#xi.sizelength:e#xi. can be overridden for a given :#xi.argument:e#xi. by\nsuffixing the question mark with an integer value of 1, 2, 3, or 4.  For\nexample, :xph.{CL?2}:exph. indicates that the length :#xi.argument:e#xi. is\na halfword value (the 2 following the question mark) regardless of the value\noriginally specified for :#xi.sizelength:e#xi..  The override applies only to\nthe one :#xi.argument:e#xi.&emdash.it does not change the :#xi.sizelength:e#xi.\nparameter's value.\n:p.\nNo blanks can appear within a format specification, except between\nkeywords.  If any part of a format specification is invalid, the length\nof the text formatted so far will be returned in\n:#xi.result_length:e#xi. and a return code indicating the problem will\nbe set.  The discussion below covers the basics of format specifications\nand describes the general operation of :#x.ST_FORMAT:e#x. with respect\nto the control string.\n:fh4.Type\n:p.\nIn practice, most format specifications are fairly simple because almost\neverything is optional (as indicated by all the brackets).  In fact, the\nlarge majority contain only :#xi.type:e#xi. and perhaps one other item.\nAs a general rule, format specifications are built around\n:#xi.type:e#xi., with the remaining items being used to supply\nadditional information.\n:p.\n:#xi.Type:e#xi. is a single letter that denotes both a source argument's\nlayout and the way it should be formatted.  The presence of\n:#xi.type:e#xi. in a format specification indicates that there is an\nassociated :#xi.argument:e#xi. that should be formatted in a certain\nway, and that the format specification itself is acting as a placeholder\nto indicate the where the formatted text should be placed within\n:#xi.string:e#xi..  For example, the control string\n:xmp.\n'The character &lbr.C&rbr. was encountered &lbr.I&rbr. times.'\n:exmp.\ncontains two format specifications, each of which only specifies\n:#xi.type:e#xi..  This control string requires two associated\n:#xi.argument:e#xi.s, one for each format specification.  The format\nspecification :#x.&lbr.C&rbr.:e#x. indicates that a single character\nshould be taken from the first :#xi.argument:e#xi. and placed in\n:#xi.string:e#xi. following :#x.'The character ':e#x..  Similarly,\n:#x.&lbr.I&rbr.:e#x. indicates that a textual representation of the four\nbyte binary integer referenced by the second :#xi.argument:e#xi. should\nplaced in :#xi.string:e#xi. following :#x.' was encountered ':e#x..  The\nresulting string would look like this:\n:xmp.\n'The character Z was encountered 437 times.'\n:exmp.\n:p.\nThe supported values for :#xi.type:e#xi. are listed below.  The default,\nminimum, and maximum lengths for :#xi.argument:e#xi.s of each type are\nlisted in :tref refid=fslns..\n:tdef id=fstcdsd cols='0.40i *' align='center left'\n      frame=box rules=vert hdframe=rules\n      compact mindepth=p5.\n:table id=fstcds refid=fstcdsd.\n:tcap.Format Specification Types\n:thd.\n:c.Type\n:c.Description\n:ethd.\n:tft refid=fstcdsd temp.\n:c.\n:etft.\n:row.\n:c.:#x.A:e#x.\n:c.Format an unsigned binary integer as a hexadecimal number.  For\nexample, if a four byte integer containing the decimal value 2375373\nwere formatted with this type, it would appear as :#x.243ECD:e#x..\n:row.\n:c.:#x.B:e#x.\n:c.Format one or more characters (arbitrary byte values) as a sequence\nof binary digits.  Example: the EBCDIC character :#x.'A':e#x. would\nformat as :#x.11000001:e#x. (hexadecimal :#x.'C1':e#x.).\n:row.\n:c.:#x.C:e#x.\n:c.Format one or more characters (arbitrary byte values) asis.  That is,\nthe character(s) referenced by the associated :#xi.argument:e#xi. should\nbe copied without modification to the appropriate position in\n:#xi.string:e#xi..\n:row.\n:c.:#x.I:e#x.\n:c.Format a signed binary integer as a decimal number.  Example:\n:#x.-32768:e#x..\n:row.\n:c.:#x.U:e#x.\n:c.Format an unsigned binary integer as a decimal number.  Example:\n:#x.65535:e#x..\n:row.\n:c.:#x.X:e#x.\n:c.Format one or more characters (arbitrary byte values) as a sequence\nof hexadecimal digits. Example: the EBCDIC character :#x.'A':e#x. would\nformat as :#x.C1:e#x. (binary :#x.11000001:e#x.).\n:etable.\n:fh4.Length\n:p.\nEach :#xi.argument:e#xi. referenced by :#xi.type:e#xi. has a default\nlength.  For example, integers referenced with the format specification\n:#x.&lbr.I&rbr.:e#x. are assumed to be four bytes in length.  Explicit\nlengths can be specified in format specifications with the\n:#xb.L:e#xb.:#xi.length:e#xi. item.  For example, the format\nspecification :#x.&lbr.IL2&rbr.:e#x. references a two byte signed integer.\n:p.\n:#xi.Length:e#xi. may be specified with a number coded directly in the\nformat specification or, if the actual length is not known until\nexecution time, as a question mark (:#xb.?:e#xb.) to indicate that\nlength of the :#xi.argument:e#xi.  to be formatted is contained in yet\nanother :#xi.argument:e#xi..  For example, suppose a word of some\nunknown length was desired instead of a single character and the number\nof occurrances was held in a two byte value.  The new control string\nwould look like the following:\n:xmp.\n'The word &lbr.CL?&rbr. was encountered &lbr.IL2&rbr. times.'\n:exmp.\nand would produce a result that looked like:\n:xmp.\n'The word SUPERCALAFRAGALISTIC was encountered 138 times.'\n:exmp.\nThis control string would require :hp1.three:ehp1. arguments: one for\nthe character string to insert, one for its length, and one for the\nnumber.  The arguments would have to be specified in that order, and the\nsize of the integer containing the word's length would be determined by\nthe :#xi.sizelength:e#xi. parameter of the :#x.ST_START:e#x. function.\n:p.\nEach type of data has minimum, maximum, and default source lengths\n(specified in bytes):\n.getw symbol=fslc1 gmltype=table text='Default'\n.getw symbol=fslc2 gmltype=table text='Minimum'\n.getw symbol=fslc3 gmltype=table text='Maximum'\n:tdef id=fslnsd cols='0.40i &fslc1. &fslc2. &fslc3.'\n      align='center right right right'\n      frame=box rules=vert hdframe=rules compact mindepth=p5.\n:table id=fslns refid=fslnsd.\n:tcap.Format Specification Source Lengths\n:thd.\n:c.Type\n:c.Default\n:c.Minimum\n:c.Maximum\n:ethd.\n:tft refid=fslnsd temp.\n:c.\n:etft.\n:row.\n:c.:#x.A:e#x.\n:c.4\n:c.1\n:c.4\n:row.\n:c.:#x.B:e#x.\n:c.1\n:c.1\n:c.256\n:row.\n:c.:#x.C:e#x.\n:c.1\n:c.0\n:c.65535\n:row.\n:c.:#x.I:e#x.\n:c.4\n:c.1\n:c.4\n:row.\n:c.:#x.U:e#x.\n:c.4\n:c.1\n:c.4\n:row.:c.:#x.X:e#x.\n:c.1\n:c.0\n:c.65535\n:etable.\n:fh4.Multiple\n:p.\n:#xi.Multiple:e#xi. may be specified with a number coded directly in the\nformat specification or as a question mark (:#xb.?:e#xb.) to indicate\nthat multiple is contained in yet another :#xi.argument:e#xi..\n:p.\nWhen :#xi.Multiple:e#xi. is specified, the source value is treated as\nan array, where each element is the same type and length. Multiple can\nused with any type.  For character strings, TRIM applies to each element\nof the array.\n:p.\nEach element in the array will be formatted based on type and output\nwith no separating characters unless the CSV keyword is also specified.\n:p.\nWhen :#xi.Multiple:e#xi. is specified, CENTER, RIGHT, and FILL aren't\nallowed.\n:fh4.Width\n:p.\n:#xi.Width:e#xi. is used to specify the minimum amount of space that\nshould be reserved in :#xi.string:e#xi. for formatted text.  More\nspace will be used if needed, but if the text is shorter than\n:#xi.width:e#xi., it will be padded with blanks (to the right for\ncharacter types and to the left for numeric types).  Like\n:#xi.length:e#xi., :#xi.width:e#xi. may be specified as a number or a\nquestion mark.  Expanding on the example used so far, the following\ncontrol string might be used:\n:xmp.\n'The word &lbr.15CL?&rbr. was encountered &lbr.5IL2&rbr. times.'\n:exmp.\nwhich, if used several times with different values, would produce\nresults that looked like:\n:xmp.\n'The word SUPERCALAFRAGALISTIC was encountered   138 times.'\n'The word HELLO           was encountered    27 times.'\n'The word GOODBYE         was encountered    14 times.'\n'The word CALIFORNIA      was encountered     0 times.'\n:exmp.\n:p.\nAn additional feature of :#xi.width:e#xi. is available for numeric data\ntypes only: if a :#xi.width:e#xi. is coded with a leading zero, the\nnumber will be formatted with leading zeros.  For example, the control\nstring\n:xmp.\n'The word &lbr.15CL?&rbr. was encountered &lbr.05IL2&rbr. times.'\n:exmp.\nwould produce these results instead:\n:xmp.\n'The word SUPERCALAFRAGALISTIC was encountered 00138 times.'\n'The word HELLO           was encountered 00027 times.'\n'The word GOODBYE         was encountered 00014 times.'\n'The word CALIFORNIA      was encountered 00000 times.'\n:exmp.\n:fh4.Precision\n:p.\n:#xb..:e#xb.:#xi.Precision:e#xi. can also be specified as a number or a\nquestion mark, but has a different meaning than :#xi.width:e#xi..  For\nnon-numeric data, :#xi.precision:e#xi. specifies the :hp1.maximum:ehp1.\namount of space that the formatted text may use; if the text is longer,\nonly the first :#xi.precision:e#xi. characters will be placed in\n:#xi.string:e#xi..  In the example above, if a :#xi.precision:e#xi. of\n:#x.15:e#x. were added to the first format specification:\n:xmp.\n'The word &lbr.15.15CL?&rbr. was encountered &lbr.05IL2&rbr. times.'\n:exmp.\nit would have produced\n:xmp.\n'The word SUPERCALAFRAGAL was encountered 00138 times.'\n'The word HELLO           was encountered 00027 times.'\n'The word GOODBYE         was encountered 00014 times.'\n'The word CALIFORNIA      was encountered 00000 times.'\n:exmp.\n:#xb..:e#xb.:#xi.Precision:e#xi. currently has no meaning for numeric\ndata, but when real numbers (fixed point or floating point) are\nsupported, it will specify the number of significant digits to the right\nof the decimal mark.\n:fh4.Column\n:p.\nDuring the process of formatting, :#x.ST_FORMAT:e#x. maintains a pointer\nto the current column position within :#xi.string:e#xi..  This column\nposition, denoted by the symbol :#xb.@:e#xb., is initially set to 1.\nWhenever text (from the control string itself or from a formatting\noperation) is added to :#xi.string:e#xi. it is placed in the position\nindicated by :#xb.@:e#xb..  After the text has been added, :#xb.@:e#xb.\nis automatically updated to the column in :#xi.string:e#xi. immediately\nfollowing the new text.  This automatic operation produces the expected\nresults: the resulting string looks like the original control string\nexcept that format specifications (acting as placeholders) have been\nreplaced with formatted text.  The column position can also be adjusted\nwith format specifications, giving application programs the ability to\ncontrol the exact placement of text within the formatted string.\n:p.\n:#xb.@:e#xb.&lbt.:#xi.Column:e#xi.&rbt. sets the value of :#xb.@:e#xb.\nto a new column position, which can be anywhere in the :#xi.string:e#xi.\narea (even beyond the end of all text formatted so far).  It may be\nspecified alone or as part of a format specification containing\n:#xi.type:e#xi..  In both cases, the value of :#xb.@:e#xb. is set before\nany text movement occurs.  The new position specified by\n:#xi.column:e#xi. can be an actual column number, or it can be a\nquestion mark that indicates the value for column is contained in an\n:#xi.argument:e#xi..  Either way, the number or question mark can be\nprefixed by a plus (:#xb.+:e#xb.) or minus (:#xb.-:e#xb.)  sign to\nindicate that the new column is relative to the current one.\n:p.\n:#x.ST_FORMAT:e#x. also maintains a :hp1.high-water:ehp1. mark, which is\nalways equal to the highest column position reached during formatting.\nIf :#xb.@:e#xb. is specified without a column number the current\nposition is set to the high-water mark, where new text will be appended\nto the string being formatted.\n:p.\nWhen formatting is complete, :#x.ST_FORMAT:e#x. reduces the high-water\nmark by one column to produce :#xi.result_length:e#xi..  This final\nvalue is normally equal to the column position of the last character\nplaced in :#xi.string:e#xi. and is considered to be the final length of\nthe formatted text.  However, since format specifications can jump to\nany column position, portions of the :#xi.string:e#xi. area may have\nbeen skipped over and left untouched by :#x.ST_FORMAT:e#x.  This is the\nway :#x.ST_FORMAT:e#x. was designed to work, but it may produce\nunexpected results if uninitialized portions of :#xi.string:e#xi. are\nskipped over during formatting.\n:fh4.Keywords\n:p.\n:#xi.Keyword:e#xi.s are used to specify formatting options that cannot\nreally be specified any other way.  The control string below, for\nexample, contains a format specifcation that uses the keywords\n:#x.CAPS:e#x. and :#x.CENTER:e#x. to place text in the center of a line\nthat will be printed as a page header.\n:xmp.\n'{?CL? CAPS CENTER}'\n:exmp.\nIf :#x.ST_FORMAT:e#x. were invoked with this control string and the\nthree arguments :#x.(80,'Year&rbl.to&rbl.Date&rbl.Totals',19):e#x.,\nthe following line would result:\n:xmp.\n                              YEAR TO DATE TOTALS\n:exmp.\n:p.\nThe available keywords are listed in :tref refid=fskwds page=no. below.\nSome of these keywords can only be used with specific :#xi.type:e#xi.s,\nas indicated in their description.\n:tdef id=fskwdsd cols='0.80i *'\n      frame=box rules=vert hdframe=rules split=yes\n      compact mindepth=p5.\n:table id=fskwds refid=fskwdsd.\n:tcap.Format Specification Keywords\n:thd.\n:c.Keyword\n:c.Description\n:ethd.\n:tft refid=fskwdsd temp.\n:c.\n:etft.\n:row.\n:c.:#x.CAPS:e#x.\n:c.Fold lowercase letters to capitals.\nThis keyword only applies to type :#xb.C:e#xb..\n:row.\n:c.:#x.C1ST:e#x.\n:c.Capitalize the first letter of the formatted argument.\nThis keyword only applies to type :#xb.C:e#xb..\n:row.\n:c.:#x.CENTER:e#x.\n:c.Center the formatted argument in the field, padding it to the left\nand right with blanks.\n:row.\n:c.:#x.CSV:e#x.\n:c.Separate multiple values with commas. This keyword only applies when\na multiple is specified.\n:row.\n:c.:#x.FILL:e#x. or :#x.F:e#x.\n:c.When the formatted argument does not extend to the end of the format\nfield, format the remainder of the field using a fill pattern.\n:p.\nZero or more copies of the fill pattern are concatenated and placed such\nthat the result ends at the final position of the format field.  If the\nspace to be filled is not an exact multple of the size of the fill\npattern, one or more blanks will be used :hp1.before:ehp1. filling to\nmake up the remainder.  The default fill pattern is :#x.\" .\":e#x..  Fill\npatterns may be specified in parenthesis following the :#x.FILL:e#x.\nkeyword as:\n:ul compact.\n:li.\nA string enclosed in quotes, optionally prefixed with :#xb.C:e#xb..\nEither single or double quotes may be used to delimit string, so long as\nthey are matched properly.  If a quote of the same type as the delimiter\nis used within the string, two quotes must be used to represent one.\nExamples: :#x.F(\" -\"):e#xb. and :#x.FILL(C' -'):e#x..\n:li.\nA hexadecimal string.  Examples: :#x.FILL(X\"4060\"):e#x.,\n:#x.F(X\"00\"):e#x., and :#x.F(X'9F'):e#x..\n:li.\nA question mark (referencing the next supplied argument), optionally\nfollowed by :#xb.L:e#xb. and a length (either an integer or a\nquestion mark to refer to the argument following the fill pattern\nargument).  If no length is supplied, the default length is one.\nExamples: :#x.F(?):e#x., :#x.FILL(?L2):e#xb., and :#x.FILL(?L?):e#x..\n:li.\nIf the supplied fill pattern does not fit any of the above types, the\nentire sequence of characters between parentheses will be assumed to be\nthe intended fill pattern.  Examples: :#x.FILL(&rbl..):e#x. and\n:#x.F(&rbl.-):e#x..\n:eul.\n:p.\nThe maximum length for a fill pattern from any source is 256 bytes.  A\nzero-length fill pattern is replaced by the default: \" .\".\n:row.\n:c.:#x.LEFT:e#x.\n:c.Left-justify the formatted argument in the field, padding it with\nblanks if necessary in order to fill in the field.\n:row.\n:c.:#x.QST:e#x.\n:c.Format the argument as a quoted string, with the text wrapped in\nsingle quotes, and each imbedded quote doubled.\n:row.\n:c.:#x.RELATIVE:e#x.\n:c.For integers only: append the resulting formatted integer with the\ncharacters :#xb.st:e#xb., :#xb.nd:e#xb., :#xb.rd:e#xb., or :#xb.th:e#xb.\nto indicate a relative number (e.g. 1st, 2nd, 3rd, 4th, etc).\n:row.\n:c.:#x.RIGHT:e#x.\n:c.Right-justify the formatted argument in the field, prefixing it with\nblanks or zeros if necessary in order to fill in the field.\n:row.\n:c.:#x.TRIM:e#x. or :#x.T:e#x.\n:c.Remove trailing blanks from the formatted data before performing any\njustification.  This keyword only applies to type :#xb.C:e#xb..\n:etable.\n:fh4.Braces\n:p.\nSince braces are used to distinguish format specifications from\nsurrounding text, an opening brace cannot be coded as part of the normal\ntext.  The format specification :#xb.&lbr.&lbr.:e#xb. provides a way\naround this problem: it is treated as if it were a single\n:#xb.&lbr:e#xb. in normal text.  For example, the control string\n:xmp.\nThis is a control string containing {{ braces }.\n:exmp.\nwould result in the following formatted string:\n:xmp.\nThis is a control string containing { braces }.\n:exmp.\n:fh3.Examples\n:spot id=fmtxmp.\n:p.\nThe examples below are all coded using the macro interface to the\n:#x.ST_FORMAT:e#x. function.  They assume that instructions similar\nto the following have been executed to provide default values for the\n:#x.STRING:e#x., :#x.RESULTLEN:e#x., and :#x.SIZELENGTH:e#x. keywords.\n:xmp.\n      ES_ID ID=ES,SPEPNAME=&amp.ES_MVS_ENVIRONMENT_SUPPORT\n      ST_ID ID=ST,SPEPNAME=&amp.STRING_HANDLER,STRING=LINE,            +\n            RESULTLEN=LINE_LEN,SIZELENGTH=2\n*\n      ES_MVS_LOAD    ID=ES               Load Environment Support.\n      ES_START       ID=ES               Start Environment Support.\n      ES_LOAD_MODULE ID=ES,SPID=ST       Load the String Handler.\n      ST_START       ID=ST               Start the String Handler.\n*\n      :hp2. ...... ST_FORMAT examples go here ..... :ehp2.\n.br\n*\n            PWA\nLINE_LEN    DS    F                Length of string within LINE.\nLINE        DS    CL80             String returned by ST_FORMAT.\n            ENDPWA\n:exmp.\nTranslated to call statements, each of the formatting examples would\nlook something like this:\n:xmp.\nCALL ST_EPA,(ST_TOKEN,&ST_FORMAT,LINE,=AL2(L'LINE),LINE_LEN, ... )\n:exmp.\n:H5.Example 1\n:p.\nThis example uses the address (:#x.A:e#x.) type to display a dump of the\ncurrent (or saved) contents of all sixteen general registers.\n:xmp.\n STM                R0,R15,REGS    Save all registers in storage.\n ST_FORMAT          ID=ST,CONTROL=REG_LIST,SOURCE=('REGS',0,7,REGS)\n ES_DISPLAY_MESSAGE ID=ES,MESSAGE=(LINE,LINE_LEN)\n ST_FORMAT          ID=ST,CONTROL=REG_LIST,SOURCE=&cont.\n('    ',8,15,REGS+(7*4))\n ES_DISPLAY_MESSAGE ID=ES,MESSAGE=(LINE,LINE_LEN)\n .\n .\n .\nREGS      DS  16F          <--- Registers 0-15 saved here.\nREG_LIST  DC  C'{CL4} {1A}-{1A}: {08A} {08A} {08A} {08A} {08A} &cont.\n{08A} {08A} {08A}'\n:exmp.\nwould produce output that looks like the following:\n:xmp.\nREGS 0-7: 0000DEB4 0000002C 0000DEB4 0000002C &cont.\n00000018 007D5540 02729FEC 00000000\n     8-F: 0000DED8 0000002C 0272EDE4 0000DE8C &cont.\n0272DDF8 00011818 8272EE20 0272EDE4\n:exmp.\n:H5.Example 2\n:p.\nThis example uses the :#x.FILL:e#x. keyword to demonstrate how a report\nmight use fill patterns to assist in lining up values to names.  The\nthree :#x.ST_FORMAT:e#x. statements below:\n:xmp.\n ST_FORMAT  ID=ST,CONTROL=LINE_CONTROL,\n                  SOURCE=('NAME',4,PWA_NAME,=A(L'PWA_NAME))\n ES_DISPLAY_MESSAGE ID=ES,MESSAGE=(LINE,LINE_LEN)\n ST_FORMAT  ID=ST,CONTROL='{25CL? FILL(C\" .\")} {CL?}',\n                  SOURCE=('STREET ADDR',11,PWA_STREET,=A(L'PWA_STREET))\n ES_DISPLAY_MESSAGE ID=ES,MESSAGE=(LINE,LINE_LEN)\n ST_FORMAT  ID=ST,CONTROL='{25CL? FILL(C\" .\")} {CL?}',\n                  SOURCE=('CITY & STATE',12,PWA_CITYST,=A(L'PWA_CITYST))\n ES_DISPLAY_MESSAGE ID=ES,MESSAGE=(LINE,LINE_LEN)\n .\n .\n .\nLINE_CONTROL  DC  C'{25CL? FILL(C\" .\")} {CL?}'\n:exmp.\nmight produce the lines:\n:xmp.\nNAME  . . . . . . . . . . Donald Duck\nSTREET ADDR . . . . . . . 132 Mallard Lane\nCITY & STATE  . . . . . . Drake City, D.Q.\n:exmp.\n:efunc.\n.**********************************************************************\n:func name='ST_ID' id=stid.Establish Default String Handler Values\n.**********************************************************************\n:p.The :#x.ST_ID:e#x. macro is used to establish default values for\nuse by other String Handler macros, which may access those values\nthrough a unique identifier, :#xi.id_name:e#xi., specified by\nthe user.  When allowed to generate default values, this macro will\ncreate Program Work Area (PWA) storage for :#xi.st_epa:e#xi.\nand\n:#xi.st_token:e#xi.. These values, whether generated by the\nmacro or provided by the user, are accessable from all other String\nHandler macros via the :#x.ID=:e#x.:#xi.id_name:e#xi.\nparameter.\n:mac.\nST_ID ID=:hp1.id_name:ehp1.\n  &lbt.,SPEPNAME=:hp1.st_epname:ehp1.&rbt.\n  &lbt.,SPEPA=:hp1.st_epa:ehp1.&rbt.\n  &lbt.,SPTOKEN=:hp1.st_token:ehp1.&rbt.\n  &lbt.,ESID=:hp1.esid_name:ehp1.&rbt.\n  &lbt.,ESVA=:hp1.esva:ehp1.&rbt.\n  &lbt.,SIZELENGTH=:hp1.sizelength:ehp1.&rbt.\n  &lbt.,STRING=&lbr.:hp1.string:ehp1. | &cont.\n(:hp1.string:ehp1.,:hp1.string_length:ehp1.)&rbr.&rbt.\n  &lbt.,RESULTLEN=:hp1.result_length:ehp1.&rbt.\n:emac.\n.*****\n:plist.\n:pLt.id_name\n:pLd.the identifier to assign to the service processor identifier\n:#x.(SPID):e#x. being established.  This name must be unique for all\nservice processor identifiers.\n:pLt.st_epname\n:pLd.the entry point name of the String Handler service processor module\nbeing used.  This value defaults to :#x.'SRVST   ':e#x..\n:pLt.st_epa\n:pLd.a fullword that will contain the entry point address of the String\nHandler service processor, after it has been loaded into storage.\n:pLt.st_token\n:pLd.a fullword that will contain a unique value, assigned by the\n:#x.ST_START:e#x. function.  This value must be used for all String\nHandler function calls.\n:pLt.esid_name\n:pLd.the name of a service processor identifier, created by the\n:#x.ES_ID:e#x.  macro, which will be used by the :#x.ST_ID:e#x. macro to\nautomatically obtain the value for :#x.esv:e#x. (see below).\n:pLt.esva\n:pLd.specifies the label of a fullword in storage that contains (or\nwill contain) the address of the Environment Support Vector\n(:#x.ESV:e#x.) created by the :#x.ES_START:e#x. function.\n:pLt.sizelength\n:pLd.If specified, :#xi.sizelength:e#xi. supplies a default value for\nthe :#x.ST_START:e#x. function.  Refer to :hdref refid=ststrt. for a\nfull description of this parameter.\n:pLt.string\n.br\nstring_length\n.br\nresult_length\n:pLd.If specified, these parameters supply default values for like-named\nparameters of other String Handler function macros.  For example, if\n:#xi.result_length:e#xi. were specified on the :#x.ST_ID:e#x.\ninstruction but not on a subsequent :#x.ST_INTEGER_TO_STRING:e#x.\ninstruction, the default value would be used.\n:eplist.\n:fh3.Example 1\n:p.\n:xmp.\nST_ID ID=ES,SPEPNAME=&STRING_HANDLER\n:exmp.\n:efunc.\n.**********************************************************************\n.se temp = 'Convert Binary Integer to String'\n:func name='ST_INTEGER_TO_STRING'.&temp.\n.**********************************************************************\n:p.\nThe :#x.ST_INTEGER_TO_STRING:e#x. function produces a string that is\nequal to the textual representation of a fullword signed binary integer.\nThe result will be a string of one or more digits with leading zeros\nremoved, prefixed with a minus sign (:#x.:hp2.-:ehp2.:e#x.) if the\ninteger is negative.\n:mac.\nST_INTEGER_TO_STRING ID=:hp1.id_name:ehp1. &cont.\n&lbt.,SPEPA=:hp1.st_epa:ehp1.&rbt. &cont.\n&lbt.,SPTOKEN=:hp1.st_token:ehp1.&rbt.\n   ,INTEGER=:hp1.integer:ehp1.\n   ,STRING=&lbr.:hp1.string:ehp1. | &cont.\n(:hp1.string:ehp1.,:hp1.string_length:ehp1.)&rbr.\n   ,RESULTLEN=:hp1.result_length:ehp1\n:emac.\n:callx.\nCALLX &cont.\n:hp1.st_epa:ehp1.,(:hp1.st_token:ehp1.,&amp.ST_INTEGER_TO_STRING,&cont.\n:hp1.integer:ehp1.,:hp1.string:ehp1.,\n              :hp1.string_length:ehp1.,:hp1.result_length:ehp1.)\n:ecallx.\n.*****\n:plist.\n:pLt.integer\n:pLd.specifies the label of a fullword in storage containing a signed\nbinary integer in two's complement format.\n:pLt.string\n:pLd.specifies the label of an area in storage where a string containing\nthe textual equivalent of the value in :#xi.integer:e#xi.\nshould be placed.\n:pLt.string_length\n:pLd.specifies the label of a signed binary integer equal to the length\nof the storage indicated by the :#xi.string:e#xi. parameter.  The\n:#xi.stringlen:e#xi. parameter may be from one to four bytes\nin length, as determined by the :#xi.sizelength:e#xi. parameter of\nthe :#x.ST_START:e#x. function.\n:note.The macro form of :#x.ST_INTEGER_TO_STRING:e#x. will attempt to\ngenerate a value for :#xi.string_length:e#xi. automatically if it is\nnot specified.  In order to generate the right value, however,\n:#xi.sizelength:e#xi. must have previously been specified on the\n:#x.ST_ID:e#x. macro.\n:pLt.result_length\n:pLd.specifies the label of a fullword in storage in which the\n:#x.ST_INTEGER_TO_STRING:e#x. function will place a signed binary\ninteger equal to the length of the resulting string.\n:eplist.\n:efunc.\n.**********************************************************************\n:func id=ststrt name='ST_START'.Begin a String Handler Session\n.**********************************************************************\n:p.\nThe :#x.ST_START:e#x. function establishes a new session with the\nString Handler and returns its session identifier in the\n:#xi.st_token:e#xi. parameter.  The size (number of bytes) of the\nnumbers used to specify string lengths to the String Handler may be\nspecified with the :#xi.sizelength:e#xi. parameter. Halfword length\nvalues are the default, but a session may be established using byte,\nhalfword, three-byte, or fullword length values.\n:mac.\nST_START ID=:hp1.id_name:ehp1. &cont.\n&lbt.,SPEPA=:hp1.st_epa:ehp1.&rbt. &cont.\n&lbt.,SPTOKEN=:hp1.st_token:ehp1.&rbt.\n  &lbt.,ESVA=:hp1.esva:ehp1.&rbt.\n  &lbt.,SIZELENGTH=:hp1.sizelength:ehp1.&rbt.\n:emac.\n:callx.\nCALLX :hp1.st_epa:ehp1.,(:hp1.st_token:ehp1.,&amp.ST_START,&cont.\n:hp1.esva:ehp1.&lbt.,:hp1.sizelength:ehp1.&rbt.)\n:ecallx.\n.*****\n:plist.\n:pLt.sizelength\n:spot id=sizelen.\n:pLd.this parameter is a signed fullword integer that determines the\nsize, in bytes, of all values used to represent string lengths in the\nString Handler session being started.  All length-values passed to the\nString Handler or returned by the String Handler will be of this size.\nIf, for example, :#xi.sizelength:e#xi. = :#x.2:e#x. (the default) then\nall lengths would be represented as halfword values.\n:p.\nThe macro forms of all String Handler functions will attempt to generate\nvalues for string lengths automatically if they are not specified.  In\norder for these macros to generate the right values, however,\n:#xi.sizelength:e#xi. must be specified on the :#x.ST_ID:e#x. macro, and\nit must be a self-defining term.  That is, it must be an actual number\n(i.e. :#xb.2:e#xb.) or a reference to a symbolic variable (e.g.\n:#xb.&amp.ST_FULLWORD:e#xb.) that has been set to a numeric value with\nthe assembler :#x.SETA:e#x. directive.  The following symbols are\navailable for this purpose: :#xb.&amp.ST_BYTE:e#xb.,\n:#xb.&amp.ST_HALFWORD:e#xb., :#xb.&amp.ST_THREE_BYTE:e#xb., and\n:#xb.&amp.ST_FULLWORD:e#xb..\n:eplist.\n:efunc.\n.**********************************************************************\n:func name='ST_STRING_TO_INTEGER'.Convert a String to a Fullword\n.**********************************************************************\n:p.\nThe :#x.ST_STRING_TO_INTEGER:e#x. function produces a fullword signed\nbinary integer that is equal to the value represented the text string in\nparameter :#xi.string:e#xi.. The input string must contain a\nsequence of one or more adjacent digits optionally prefixed with a sign\ncharacter (\":#x.:hp2.+:ehp2.:e#x.\" or \":#x.:hp2.-:ehp2.:e#x.\"). Any\nnumber of blanks may appear before or after the optional sign or digit\nsequence, but not between digits.\n:mac.\nST_STRING_TO_INTEGER ID=:hp1.id_name:ehp1. &cont.\n&lbt.,SPEPA=:hp1.st_epa:ehp1.&rbt. &cont.\n&lbt.,SPTOKEN=:hp1.st_token:ehp1.&rbt.\n   ,STRING=&lbr.:hp1.string:ehp1. | &cont.\n(:hp1.string:ehp1.,:hp1.string_length:ehp1.)&rbr.\n   ,INTEGER=:hp1.integer:ehp1.\n:emac.\n:callx.\nCALLX :hp1.st_epa:ehp1.,(:hp1.st_token:ehp1.,&cont.\n&amp.ST_STRING_TO_INTEGER,:hp1.string:ehp1.,&cont.\n:hp1.string_length:ehp1.,&cont.\n:hp1.integer:ehp1.)\n:ecallx.\n.*****\n:plist.\n:pLt.integer\n:pLd.specifies the label of a fullword in storage where a signed binary\ninteger equal to the value represented by :#xi.string:e#xi.  will be\nplaced.\n:pLt.string\n:pLd.a sequence of numeric characters representing an integer value.  A\nleading sign character (\":#xb.+:e#xb.\" or \":#xb.-:e#xb.\") is optional.\nBlanks may appear at any point in the string :hp1.except:ehp1. between\nadjacent digits.  Example string: :#x.'  - 672  ':e#x..\n:pLt.string_length\n:pLd.specifies the label of a signed binary integer equal to the length\nof the storage indicated by the :#xi.string:e#xi. parameter.  The\n:#xi.string_length:e#xi. parameter may be from one to four bytes\nin length, as determined by the :#xi.sizelength:e#xi. parameter of\nthe :#x.ST_START:e#x. function.\n:note.The macro form of :#x.ST_STRING_TO_INTEGER:e#x. will attempt to\ngenerate a value for :#xi.string_length:e#xi. automatically if it is not\nspecified.  In order to generate the right value, however,\n:#xi.sizelength:e#xi. must have previously been specified on the\n:#x.ST_ID:e#x. macro.\n:eplist.\n:efunc.\n.**********************************************************************\n:func name='ST_TERMINATE'.End a String Handler Session\n.**********************************************************************\n:p.\nThe :#x.ST_TERMINATE:e#x. function ends a session with the String\nHandler and sets the :#xi.st_token:e#xi. value to zero.\n:mac.\nST_TERMINATE ID=:hp1.id_name:ehp1. &cont.\n&lbt.,SPEPA=:hp1.st_epa:ehp1.&rbt. &cont.\n&lbt.,SPTOKEN=:hp1.st_token:ehp1.&rbt.\n:emac.\n:callx.\nCALLX :hp1.st_epa:ehp1.,(:hp1.st_token:ehp1.,&amp.ST_TERMINATE)\n:ecallx.\n:efunc.\n.*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SRVDOCSY": {"ttr": 15364, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x02\\x00\\x00V\\x01\\x11)\\x9f\\x01\\x11)\\x9f\\t'\\x02-\\x02-\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@\"", "ispf": {"version": "02.00", "flags": 0, "createdate": "2011-10-26T00:00:00", "modifydate": "2011-10-26T09:27:56", "lines": 557, "newlines": 557, "modlines": 0, "user": "CLEMSON"}, "text": ".*SRVSY****************************************************************\n.*                                                                    *\n.*                    Chapter. Symbol Manager                         *\n.*                                                                    *\n.**********************************************************************\n:h1 id=srvsy.Symbol Manager\n:p.\nThe Symbol Manager provides a mechanism for easily and efficiently\nkeeping track of data by name.  With the Symbol Manager, data is stored\nand maintained as symbols in a table.  Each symbol has two parts: (1) a\n:hp1.name:ehp1., and (2) a :hp1.value:ehp1..  The :hp1.value:ehp1. portion\nof a symbol is defined by the application program and contains data to\nbe associated with that particular symbol.\n:p.\nTo use a symbol table, an application first must invoke the\n:#x.SY_START:e#x. function.  This function will create a new table and\ninitialize it for use.  :#x.SY_START:e#x. accepts several optional\nparameters that can be used to tailor various aspects of the symbol\ntable as needed.\n:p.\nOnce :#x.SY_START:e#x. has been used to set up a new symbol table, an\napplication can begin adding symbols to the table and manipulating them.\nSeparate functions are provided for installing symbols in the table,\nlooking up symbols to see if they exist or to get their values, updating\nthe values of symbols, and removing symbols from the table.  When an\napplication is done using a table, the :#x.SY_TERMINATE:e#x. function\nshould be used to delete the entire table (including any symbols it may\ncontain).\n:p.\nThere is currently no support within the Symbol Manager for scoping of\nany nature: all symbols in the table must be unique and are accessable\nat any time.  If you have a need for scoping, or if you need to maintain\nmultiple sets of symbols, you can still do it by creating multiple\nsymbol tables.\n:p.\nAs many symbol tables as needed may be created and maintained at the\nsame time.  A symbol table is identified by :#xi.sy_token:e#xi., the\nvalue returned by :#x.SY_START:e#x. at the time the table was created.\nBy invoking :#x.SY_START:e#x. multiple times to create multiple tables,\nand by keeping track of the different :#xi.sy_token:e#xi. values used to\nidentify those tables, you can maintain as many symbol tables as needed.\n:p.\nHint: If you need to manage a hierarchical set of symbol tables, you can\nstore the :#xi.sy_token:e#xi. value for one symbol table in the value\nof a symbol in a different table.  For example, a root symbol table may\ncontain a symbol (say for a subroutine) that contains as part of its\nvalue the :#xi.sy_token:e#xi. value of another symbol table (say for the\nsubroutine's internal symbols).\n:p.\nThe Symbol Manager operates independently of its execution environment\nand may be used with any Environment Support service processor.\n.*--------------------------------------------------------------------*\n:h3.Obtaining Symbol Manager Symbols &amp. Macros\n.*--------------------------------------------------------------------*\n:p.\nThe Symbol Manager's symbols and interface macros can be found in the\nassembler copy member :#x.SRVSYMAC:e#x.. This member contains symbols\nnaming the Symbol Manager's load module, function codes, return codes,\nand parameter values.  It also contains macros for using all of the\nSymbol Manager's functions.  The following statement or its equivalent\nshould appear at the beginning of any program that uses the string\nhandler:\n:xmp.\n   COPY SRVSYMAC      Obtain the Symbol Manager's symbols & macros.\n:exmp.\n.*--------------------------------------------------------------------*\n:h3.Common Symbol Manager Parameters\n.*--------------------------------------------------------------------*\nSome parameters are general to the Symbol Manager and not specific to\nany function.  These parameters include its load module name\n(:#xi.sy_epname:e#xi.), entry point address (:#xi.sy_epa:e#xi.), and\ntoken value (:#xi.sy_token:e#xi.). The :#x.SY_ID:e#x. macro (see\n:hdref refid=syid.) can be used to establish defaults for these\nparameters and associate them with a unique service processor\nidentifier.  The identifier may then be supplied on any Symbol Manager\nmacro instruction to refer to the default parameter values.\n:p.\nThe parameters listed below apply to every Symbol Manager function.\n.*****\n:plist.\n:pLt.id_name\n:pLd.specifies the name of a service processor identifier created by the\n:#x.SY_ID:e#x. macro which will be used by all other function invocation\nmacros to automatically obtain values for :#xi.sy_epa:e#xi. and\n:#xi.sy_token:e#xi.. This parameter is required on all function macros\nunless both :#xi.sy_epa:e#xi. and :#xi.sy_token:e#xi. are specified.\n:pLt.sy_epa\n:pLd.specifies the label of a fullword that contains the entry point\naddress of an already-started Symbol Manager service processor.  The\nvalue specified by :#xi.sy_epa:e#xi. overrides any value obtained from\n:#x.ID=:e#x.:#xi.id_name:e#xi..\n:pLt.sy_token\n:pLd.specifies the label of a fullword that contains the value returned\nby :#x.SY_START:e#x. for the :#xi.sy_token:e#xi. parameter.  The value\nspecified by :#xi.sy_token:e#xi. overrides any value obtained from\n:#x.ID=:e#x.:#xi.id_name:e#xi..\n:eplist.\n.*--------------------------------------------------------------------*\n:h3.Identifying the Symbol Manager\n.*--------------------------------------------------------------------*\n:p.\nThe Symbol Manager service processor resides in the load module named by\nthe following symbol definition in copy member :#x.SRVSYMAC:e#x.:\n:xmp.\n&SYMBOL_MANAGER  SETC  '''SRVSY   '''\n:exmp.\nThis symbolic name should be used as the service processor entry point\nname for the Symbol Manager as shown in the following :#x.SY_ID:e#x.\nmacro instruction.\n:xmp.\nSY_ID ID=SY,SPEPNAME=&SYMBOL_MANAGER    Set Symbol Manager Defaults.\n:exmp.\n.*--------------------------------------------------------------------*\n:h3.Loading the Symbol Manager\n.*--------------------------------------------------------------------*\n:p.\nThe recommended method for loading the Symbol Manager is through\nEnvironment Support's :#x.ES_LOAD_MODULE:e#x. function, as shown in\nthe following example:\n:xmp.\nES_LOAD_MODULE ID=ES,SPID=SY            Load the Symbol Manager\n:exmp.\n.*--------------------------------------------------------------------*\n:h3.Complete List of Symbol Manager Return Codes\n.*--------------------------------------------------------------------*\n:p.\nMany return codes can be returned from each function.  In the function\ndescriptions later in this chapter, the most common return codes\nreturned by the particular function are documented.  The following\nis a complete list of Symbol Manager return codes.\n.*****\n:rclist.\n:rcn.0\n:rct.SY_SUCCESS\n:rcd.The invoked Symbol Manager function performed the requested\nservice without encountering any problems.\n:rcn.1\n:rct.SY_INVALID_VALUESIZE\n:rcd.The value specified for :#xi.valuesize:e#xi. on the :#x.SY_START:e#x.\nfunction was negative.\n:rcn.2\n:rct.SY_INVALID_CAPS\n:rcd.The value specified for :#xi.caps:e#xi. on the :#x.SY_START:e#x.\nfunction was not equal to the character string :#x.'ON':e#x. or\n:#x.'OFF':e#x..\n:rcn.3\n:rct.SY_INVALID_FUNCTION\n:rcd.An invalid :#xi.FunctionCode:e#xi. (the second parameter in any\nservice processor function call) was specified.\n:rcn.4\n:rct.SY_INVALID_TOKEN\n:rcd.The value specified for :#xi.token:e#xi. does not identify any\nsymbol currently in the syjmbol table.\n:rcn.5\n:rct.SY_INVALID_HASHSIZE\n:rcd.The value specified for :#xi.hashsize:e#x. on the :#x.SY_START:e#x.\nfunction was either zero, negative, or too large.  The symbol manager\ncan process :#xi.hashsize:e#xi. values from 1 up to an implementation\nmaximum of 536870911 (hexadecimal :#x.X\"1FFFFFFF\":e#x.).\n:rcn.6\n:rct.SY_INVALID_MEMINCR\n:rcd.The value specified for :#xi.memincr:e#x. on the :#x.SY_START:e#x.\nfunction was either negative or zero.\n:rcn.7\n:rct.SY_INVALID_NUMBER_OF_PARMS\n:rcd.Either too few parameters were supplied for the function call or\ntoo many were supplied.  Check the parameter list to ensure that it is\nright for the function being invoked.\n:rcn.8\n:rct.SY_INVALID_LENGTH\n:rcd.The value specified for :#xi.length:e#x. on the\n:#x.SY_INSTALL:e#x. or :#x.SY_LOOKUP:e#x.\nfunction was either negative or zero.\n:rcn.9\n:rct.SY_MEMORY_PROBLEM\n:rcd.An error was encountered while attempting to obtain or release\nstorage for symbol table management. The Symbol Manager uses the Memory\nManager service processor for these functions, so the error will be in\nthe Environment Support Debug Information Area.\n:rcn.10\n:rct.SY_STORAGE_NOT_AVAILABLE\n:rcd.Not enough storage was available to create the symbol table (for\n:#x.SY_START:e#x. calls) or to add a new symbol to the table (for\n:#x.SY_INSTALL:e#x. calls).  Since symbol table size is limited\nonly by the total amount of memory available to your program, you must\nincrease your region size to get more storage.\n:rcn.11\n:rct.SY_SYMBOL_ALREADY_INSTALLED\n:rcd.The :#x.SY_INSTALL:e#x. function was called to install a\nnew symbol in the symbol table, but the provided symbol was already\nthere.\n:rcn.12\n:rct.SY_SYMBOL_NOT_FOUND\n:rcd.The symbol identified by :#xi.name:e#xi. and :#xi.length:e#xi. is\nnot in the symbol table.\n:erclist.\n.*--------------------------------------------------------------------*\n:h2.Symbol Manager Service Processor Functions\n.*--------------------------------------------------------------------*\n:p.\nThe remaining sections of this chapter describe all functions provided\nby the Symbol Manager service processor, arranged in alphabetical order.\nEach function's description begins on a new page, and the name of the\nfunction being described appears in the top outside corner of every\npage.\n.**********************************************************************\n:func name='SY_ID' id=syid.Establish Default Symbol Manager Values\n.**********************************************************************\n:p.The :#x.SY_ID:e#x. macro is used to establish default values for\nuse by other Symbol Manager macros, which may access those values\nthrough a unique identifier, :#xi.id_name:e#xi., specified by\nthe user.  When allowed to generate default values, this macro will\ncreate Program Work Area (PWA) storage for :#xi.sy_epa:e#xi.\nand\n:#xi.sy_token:e#xi.. These values, whether generated by the\nmacro or provided by the user, are accessable from all other Symbol\nManager macros via the :#x.ID=:e#x.:#xi.id_name:e#xi.\nparameter.\n:mac.\nSY_ID ID=:hp1.id_name:ehp1.\n  &lbt.,SPEPNAME=:hp1.sy_epname:ehp1.&rbt.\n  &lbt.,SPEPA=:hp1.sy_epa:ehp1.&rbt.\n  &lbt.,SPTOKEN=:hp1.sy_token:ehp1.&rbt.\n  &lbt.,ESID=:hp1.esid_name:ehp1.&rbt.\n  &lbt.,ESVA=:hp1.esva:ehp1.&rbt.\n:emac.\n.*****\n:plist.\n:pLt.id_name\n:pLd.the identifier to assign to the service processor identifier being\nestablished.  This name must be unique for all service processor\nidentifier's.\n:pLt.sy_epname\n:pLd.the entry point name of the Symbol Manager service processor module\nthat is being used.\n:pLt.sy_epa\n:pLd.specifies the label of a fullword that will contain the entry point\naddress of the Symbol Manager.\n:pLt.sy_token\n:pLd.specifies the label of a fullword that will contain the token\nassigned by the :#x.SY_START:e#x. function of the Symbol Manager.\n:pLt.esid_name\n:pLd.the name of a service processor identifier, created by the\n:#x.ES_ID:e#x.  macro, which will be used by the :#x.SY_ID:e#x. macro to\nautomatically obtain the value for :#x.esv:e#x. (see below).\n:pLt.esva\n:pLd.specifies the label of a fullword that contains (or\nwill contain) the address of the Environment Support Vector\n(:#x.ESV:e#x.) created by the :#x.ES_START:e#x. function.\n:eplist.\n:fh3.Example 1\n:p.\n:xmp.\nSY_ID     ID=SY,SPEPNAME=&SYMBOL_MANAGER\n:exmp.\n:efunc.\n.**********************************************************************\n:func name='SY_INSTALL'.Install a Symbol in the Symbol Table\n.**********************************************************************\n:p.\nThe :#x.SY_INSTALL:e#x. function inserts a new symbol into the\ntable identified by the :#xi.sy_token:e#xi. parameter.  If the symbol is\nalready in the symbol table, :#x.SY_INSTALL:e#x. will not update\nthat symbol's value.\n:mac.\nSY_INSTALL ID=:hp1.id_name:ehp1. &cont.\n&lbt.,SPEPA=:hp1.sy_epa:ehp1.&rbt. &cont.\n&lbt.,SPTOKEN=:hp1.sy_token:ehp1.&rbt.\n\n   ,NAME=&lbr.:hp1.'name':ehp1. | :hp1.name:ehp1. &cont.\n| :hp2.(:hp1.name:ehp1.,:hp1.length:ehp1.):ehp2.&rbr.\n  &lbt.,TOKEN=:hp1.token:ehp1.&rbt.\n  &lbt.,VALUE=:hp1.value:ehp1.&rbt.\n:emac.\n:callx.\nCALLX :hp1.sy_epa:ehp1.,(:hp1.sy_token:ehp1.,&amp.SY_INSTALL,&cont.\n:hp1.name:ehp1.,:hp1.length:ehp1.,&lbt.:hp1.token:ehp1.&rbt.,&cont.\n&lbt.:hp1.value:ehp1.&rbt.)\n:ecallx.\n.*****\n:plist.\n:pLt.name\n:pLd.the name of the symbol to install.  If the\n:#x.:hp2.CAPS:ehp2.:e#x. option is in effect, the symbol will be stored\nin the table with :#xi.name:e#xi. converted to uppercase.\n:pLt.length\n:pLd.a signed binary fullword integer equal to the length of the text\nspecified by :#xi.name:e#xi..\n:pLt.token\n:pLd.a fullword in which a unique four-byte identifier will be\nreturned for the newly installed symbol.  The :#xi.token:e#xi. must\nbe used for all accesses to the symbol in the future.\n:pLt.value\n:pLd.an application defined area containing the initial value to assign\nto the symbol.  The data referred to by :#xi.value:e#xi. must be\n:#xi.valuesize:e#xi. bytes in length.  See the :#x.SY_START:e#x.\nfunction for an explanation of the :#xi.valuesize:e#xi. parameter.\n:eplist.\n:efunc.\n.**********************************************************************\n:func name='SY_LOOKUP'.Locate a Symbol in the Symbol Table\n.**********************************************************************\n:p.\nThe :#x.SY_LOOKUP:e#x. function locates the specified symbol in\nthe table identified by the :#xi.sy_token:e#xi. value and returns its\nunique four-byte :#xi.token:e#xi. value.  The :#xi.token:e#xi. may then\nbe used to identify the symbol for other symbol manager functions.\n:mac.\nSY_LOOKUP ID=:hp1.id_name:ehp1. &cont.\n&lbt.,SPEPA=:hp1.sy_epa:ehp1.&rbt. &cont.\n&lbt.,SPTOKEN=:hp1.sy_token:ehp1.&rbt.\n\n  ,NAME=&lbr.:hp1.'name':ehp1. | :hp1.name:ehp1. &cont.\n| :hp2.(:hp1.name:ehp1.,:hp1.length:ehp1.):ehp2.&rbr.\n  &lbt.,TOKEN=:hp1.token:ehp1.&rbt.\n:emac.\n:callx.\nCALLX :hp1.sy_epa:ehp1.,(:hp1.sy_token:ehp1.,&amp.SY_LOOKUP,&cont.\n:hp1.name:ehp1.,:hp1.length:ehp1.,&lbt.:hp1.token:ehp1.&rbt.)\n:ecallx.\n.*****\n:plist.\n:pLt.name\n:pLd.the name of the symbol to be located in the symbol table.  If the\n:#x.:hp2.CAPS:ehp2.:e#x. option is in effect, the case of the symbol is\nnot important.\n:pLt.length\n:pLd.the length (as a signed fullword integer) of the text pointed to by\nthe :#xi.name:e#xi. parameter.\n:pLt.token\n:pLd.a fullword into which the unique :#xi.token:e#xi. of the located\nsymbol will be returned.\n:eplist.\n:efunc.\n.**********************************************************************\n:func name='SY_OBTAIN_NAME'.Obtain a Symbol's Name\n.**********************************************************************\n:p.\nThe :#x.SY_OBTAIN_NAME:e#x. function returns the address and length of\nthe name of the specified symbol.\n:mac.\nSY_OBTAIN_NAME ID=:hp1.id_name:ehp1. &cont.\n&lbt.,SPEPA=:hp1.sy_epa:ehp1.&rbt. &cont.\n&lbt.,SPTOKEN=:hp1.sy_token:ehp1.&rbt.\n\n  ,TOKEN=:hp1.token:ehp1\n  ,NAMEPTR=:hp1.nameptr:ehp1.\n  ,LENGTH=:hp1.length:ehp1.\n:emac.\n:callx.\nCALLX :hp1.sy_epa:ehp1.,(:hp1.sy_token:ehp1.,&amp.SY_OBTAIN_NAME,&cont.\n:hp1.token:ehp1.,:hp1.nameptr:ehp1.,:hp1.length:ehp1.)\n:ecallx.\n.*****\n:plist.\n:pLt.token\n:pLd.a fullword value returned by the :#xi.token:e#xi.  parameter of the\n:#x.SY_INSTALL:e#x. or :#x.SY_LOOKUP:e#x. function.\n:pLt.nameptr\n:pLd.a fullword into which the address of the identified symbol's name\nwill be returned.  This address will be of the symbol manager's copy of\nthe symbol's name which may have been converted to all capitals.  The\napplication program must not modify this storage in any way!\n:pLt.length\n:pLd.a fullword into which a signed binary integer equal to the length\nof the specified symbol's name will be returned.\n:eplist.\n:efunc.\n.**********************************************************************\n:func name='SY_OBTAIN_VALUE'.Obtain a Symbol's Value\n.**********************************************************************\n:p.\nThe :#x.SY_OBTAIN_VALUE:e#x. function returns the current value of the\nspecified symbol.\n:mac.\nSY_OBTAIN_VALUE ID=:hp1.id_name:ehp1. &cont.\n&lbt.,SPEPA=:hp1.sy_epa:ehp1.&rbt. &cont.\n&lbt.,SPTOKEN=:hp1.sy_token:ehp1.&rbt.\n\n  ,TOKEN=:hp1.token:ehp1\n  ,VALUE=:hp1.value:ehp1.\n:emac.\n:callx.\nCALLX :hp1.sy_epa:ehp1.,(:hp1.sy_token:ehp1.,&amp.SY_OBTAIN_VALUE,&cont.\n:hp1.token:ehp1.,:hp1.value:ehp1.)\n:ecallx.\n.*****\n:plist.\n:pLt.token\n:pLd.a fullword value returned by the :#xi.token:e#xi.  parameter of the\n:#x.SY_INSTALL:e#x. or :#x.SY_LOOKUP:e#x. function.\n:pLt.value\n:pLd.an application defined area into which the current value of the\nspecified symbol will be placed.  This area must be\n:#xi.valuesize:e#xi. bytes in length.  See the :#x.SY_START:e#x.\nfunction for an explanation of the :#xi.valuesize:e#xi. parameter.\n:eplist.\n:efunc.\n.**********************************************************************\n:func name='SY_REMOVE'.Remove a Symbol from the Symbol Table\n.**********************************************************************\n:p.\nThe :#x.SY_REMOVE:e#x. function removes a symbol (with its\nassociated value) from the symbol table.  The symbol to be deleted must\nbe identified by its :#xi.token:e#xi..\n:mac.\nSY_REMOVE ID=:hp1.id_name:ehp1. &cont.\n&lbt.,SPEPA=:hp1.sy_epa:ehp1.&rbt. &cont.\n&lbt.,SPTOKEN=:hp1.sy_token:ehp1.&rbt.\n\n  ,TOKEN=:hp1.token:ehp1\n:emac.\n:callx.\nCALLX :hp1.sy_epa:ehp1.,(:hp1.sy_token:ehp1.,&amp.SY_REMOVE,&cont.\n:hp1.token:ehp1.)\n:ecallx.\n.*****\n:plist.\n:pLt.token\n:pLd.Specifies the label of a fullword containing the value returned in\nthe :#xi.token:e#xi. parameter of the :#x.SY_INSTALL:e#x. or\n:#x.SY_LOOKUP:e#x. function.\n:eplist.\n:efunc.\n.**********************************************************************\n:func name='SY_START'.Begin a New Symbol Manager Session\n.**********************************************************************\n:p.\nThe :#x.SY_START:e#x. function creates a new symbol table and returns\nits identifier in the :#xi.sy_token:e#xi. parameter. Optional\nparameters specify table characteristics such as the size of the\nvalue portion of a symbol and whether searches for symbols are\ncase-sensitive.\n.*\n:mac.\nSY_START ID=:hp1.id_name:ehp1. &cont.\n&lbt.,SPEPA=:hp1.sy_epa:ehp1.&rbt. &cont.\n&lbt.,SPTOKEN=:hp1.sy_token:ehp1.&rbt.\n  &lbt.,ESVA=:hp1.esva:ehp1.&rbt.\n  &lbt.,VALUESIZE=&lbr.:hp1.valuesize:ehp1. | :us.0:eus.&rbr.&rbt.\n  &lbt.,HASHSIZE=&lbr.:hp1.hashsize:ehp1. | :us.101:eus.&rbr.&rbt.\n  &lbt.,MEMINCR=&lbr.:hp1.memincr:ehp1. | :us.4096:eus.&rbr.&rbt.\n  &lbt.,CAPS=&lbr.:hp2.ON:ehp2.|:hp2.:us.OFF:eus.:ehp2.&rbr.&rbt.\n:emac.\n:callx.\nCALLX &cont.\n:hp1.sy_epa:ehp1.,(:hp1.sy_token:ehp1.,&amp.SY_START,&cont.\n:hp1.esva:ehp1.,&lbt.:hp1.valuesize:ehp1.&rbt.,&cont.\n&lbt.:hp1.caps:ehp1.&rbt.,&lbt.:hp1.hashsize:ehp1.&rbt.,\n              &lbt.:hp1.memincr:ehp1.&rbt.)\n:ecallx.\n.*****\n:plist.\n:pLt.id_name\n:pLd.specifies the name of a service processor identifier created by the\n:#x.SY_ID:e#x. macro which will be used by the :#x.SY_DELETE:e#x.\nmacro to automatically obtain values for :#xi.sy_epa:e#xi.\nand\n:#xi.sy_token:e#xi.. This parameter is required unless both\n:#xi.sy_epa:e#xi. and :#xi.sy_token:e#xi. are\nspecified.\n:pLt.sy_epa\n:pLd.specifies the label of a fullword that contains the entry point\naddress of an already-started Symbol Manager service processor.  The\nvalue specified by :#xi.sy_epa:e#xi.  overrides any value obtained from\n:#x.ID=:e#x.:#xi.id_name:e#xi..\n:pLt.sy_token\n:pLd.specifies the label of a fullword that contains the value returned\nby :#x.SY_START:e#x. for the\n:#xi.sy_token:e#xi. parameter.  The value specified by\n:#xi.sy_token:e#xi. overrides any value obtained from\n:#x.ID=:e#x.:#xi.id_name:e#xi..\n:pLt.esva\n:pLd.specifies the label of a fullword containing the address of an\nEnvironment Support Vector.\n:pLt.valuesize\n:pLd.specifies the label of a fullword containing the length of the\nvalue portion of symbols in the table being created.  This value\ndefaults to :#xb.0:e#xb., meaning that no information is attached\nto symbols in the table.\n:pLt.caps\n:pLd.specifies the label of a string equal to either 'ON' or 'OFF',\nwhich indicates whether or not symbol-table searches should be\ncase-sensitive ('OFF') or not ('ON').\n:pLt.hashsize\n:pLd.Specifies the number of hash-table entries that should be reserved\nfor the symbol table being created.  For maximum efficiency, this number\nshould be approximately 80% or more of the maximum number of symbols\nthat will reside in the table at any given time.\n:pLt.memincr\n:pLd.The Symbol Manager uses the Memory Manager to obtain all symbol\ntable storage, which is maintained within a single Memory Manager heap.\nThis parameter is passed to the :#x.MM_START:e#x. function when the heap\nis created, and should be large enough to avoid excessive system calls\nfor obtaining storage.  An approximate value can be calculated as\nfollows:\n:ol.\n:li.The size of a symbol table entry is\n12+:#xi.valuesize:e#xi.+avg_length, where avg_length is the average\nlength of a symbol's name.\n:li.If the maximum number of possible symbols is known, simply calculate\nthe total space they will require and use that.\n:li.If the maximum number of possible symbols can vary wildly from\nexecution to execution, try to choose a value for :#xi.memincr:e#xi.\nthat will be large enough to satisfy a majority of cases with a single\nincrement of storage.  In cases where more symbols are used, the heap\nwill expand as needed.\n:eol.\n:eplist.\n:efunc.\n.**********************************************************************\n:func name='SY_TERMINATE'.End a Symbol Manager Session\n.**********************************************************************\n:p.\nThe :#x.SY_TERMINATE:e#x. function deletes the symbol table identified\nby the :#xi.sy_token:e#xi. parameter, automatically deleting all symbols\ncurrently installed and releasing all storage obtained for that symbol\ntable.\n:mac.\nSY_TERMINATE ID=:hp1.id_name:ehp1. &cont.\n&lbt.,SPEPA=:hp1.sy_epa:ehp1.&rbt. &cont.\n&lbt.,SPTOKEN=:hp1.sy_token:ehp1.&rbt.\n:emac.\n:callx.\nCALLX :hp1.sy_epa:ehp1.,(:hp1.sy_token:ehp1.,&amp.SY_TERMINATE)\n:ecallx.\n:efunc.\n.**********************************************************************\n:func name='SY_UPDATE_VALUE'.Replace a Symbol's Value\n.**********************************************************************\n:p.\nThe :#x.SY_UPDATE_VALUE:e#x. function replaces the value of the\nspecified symbol.\n:mac.\nSY_UPDATE_VALUE ID=:hp1.id_name:ehp1. &cont.\n&lbt.,SPEPA=:hp1.sy_epa:ehp1.&rbt. &cont.\n&lbt.,SPTOKEN=:hp1.sy_token:ehp1.&rbt.\n\n  ,TOKEN=:hp1.token:ehp1\n  ,VALUE=:hp1.value:ehp1.\n:emac.\n:callx.\nCALLX :hp1.sy_epa:ehp1.,(:hp1.sy_token:ehp1.,&amp.SY_UPDATE_VALUE,&cont.\n:hp1.token:ehp1.,:hp1.value:ehp1.)\n:ecallx.\n.*****\n:plist.\n:pLt.token\n:pLd.a fullword value returned by the :#xi.token:e#xi.  parameter of the\n:#x.SY_INSTALL:e#x. or :#x.SY_LOOKUP:e#x. function.\n:pLt.value\n:pLd.an application defined area containing the new value to assign\nto the symbol.  The data referred to by :#xi.value:e#xi. must be\n:#xi.valuesize:e#xi. bytes in length.  See the :#x.SY_START:e#x.\nfunction for an explanation of the :#xi.valuesize:e#xi. parameter.\n:eplist.\n:efunc.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SRVDT": {"ttr": 15619, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x02\\x00\\x00V\\x01\\x11)\\x9f\\x01\\x11)\\x9f\\t'\\x12\\xcb\\x12\\xcb\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@\"", "ispf": {"version": "02.00", "flags": 0, "createdate": "2011-10-26T00:00:00", "modifydate": "2011-10-26T09:27:56", "lines": 4811, "newlines": 4811, "modlines": 0, "user": "CLEMSON"}, "text": "*---------------------------------------------------------------------*\n*  Copyright 2011 by Clemson University Research Foundation           *\n*                                                                     *\n*  Licensed under the Apache License, Version 2.0 (the \"License\");    *\n*  you may not use this file except in compliance with the License.   *\n*  You may obtain a copy of the License in this library as member     *\n*  $LICENSE, or from                                                  *\n*                                                                     *\n*      http://www.apache.org/licenses/LICENSE-2.0                     *\n*                                                                     *\n*  Unless required by applicable law or agreed to in writing,         *\n*  software distributed under the License is distributed on an \"AS    *\n*  IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either    *\n*  express or implied.  See the License for the specific language     *\n*  governing permissions and limitations under the License.           *\n*---------------------------------------------------------------------*\n         SMLIST CONVERT=YES           |\n         srvmod name=srvdt,dates='1989, 1990, 1995'\n         gblc  &srv_modname\n         copy  ##prmopt\nSRVDT TITLE \"MVS Date/Time Service Processor\"\n*---------------------------------------------------------------------*\n*\n*  Copyright (C) Clemson University Research Foundation 1989, 1990.\n*\n*  Program     SRVDT, MVS Date/Time Service Processor.\n*\n*  Abstract    This service processor is environment-independent\n*              and provides standardized Date/Time services.\n*\n*  Parameters:\n*\n*    DT_ID              ID=procid,\n*                       ,SPepname=DT_epname\n*                       ,SPepa=DT_epa\n*                       ,SPtoken=DT_token\n*                       ,ESID=esid_name\n*                       ,ESVA=esva\n*\n*    DT_Start           ID=procid\n*                       ,Format=American | European\n*\n*       CALLX  DT_epa,(DT_token,&DT_START,esva,gregorian_format)\n*\n*    DT_Terminate       ID=procid\n*\n*       CALLX  DT_epa,(DT_token,&DT_TERMINATE)\n*\n*    DT_Get_Current     ID=procid\n*                       ,Date=(dateaddr,format)\n*                       ,Time=(timeaddr,format)\n*\n*       CALLX  DT_epa,(DT_token,&DT_GET_CURRENT,\n*                   dateaddr,format,timeaddr,format)\n*\n*    DT_Convert         ID=procid\n*                       ,Fromdate=(input_date,format)\n*                       ,Todate=(output_date,format)\n*                       ,Fromtime=(input_time,format)\n*                       ,Totime=(output_time,format)\n*\n*       CALLX  DT_epa,(DT_token,&DT_CONVERT,\n*                       input_date,format,output_date,format,\n*                       input_time,format,output_time,format)\n*\n* (continued)\n*---------------------------------------------------------------------*\n          eject\n*---------------------------------------------------------------------*\n*\n*    DT_Add             ID=procid\n*                       ,Datein=(date,format)\n*                       ,Timein=(time,format)\n*                       ,Interval=(interval,format)\n*                       ,Dateout=(date,format)\n*                       ,Timeout=(time,format)\n*\n*       CALLX  DT_epa,(DT_token,&DT_ADD,\n*                       datein,format,timein,format,\n*                       interval,format,\n*                       dateout,format,timeout,format)\n*\n*    DT_Subtract        ID=procid\n*                       ,Datein=(date,format)\n*                       ,Timein=(time,format)\n*                       ,Interval=(interval,format)\n*                       ,Dateout=(date,format)\n*                       ,Timeout=(time,format)\n*\n*       CALLX  DT_epa,(DT_token,&DT_Subtract,\n*                       datein,format,timein,format,\n*                       interval,format,\n*                       dateout,format,timeout,format)\n*\n*    DT_Duration        ID=procid\n*                       ,Date1=(date1,format)\n*                       ,Date2=(date2,format)\n*                       ,Time1=(time1,format)\n*                       ,Time2=(time2,format)\n*                       ,Interval=(interval,format)\n*\n*       CALLX  DT_epa,(DT_token,&DT_SUBTRACT,\n*                       date1,format,date2,format,\n*                       time1,format,time2,format,\n*                       interval,format)\n*\n*    For complete descriptions of each function and parameter, refer\n*    to the Service Processors Users Guide And Reference.\n*\n*---------------------------------------------------------------------*\n          eject\n*---------------------------------------------------------------------*\n*\n*  Return codes:\n*\n*   For a complete list of possible return codes for each function,\n*   refer to the Service Processors Users Guide And Reference.\n*\n*  Program     Reentrant, problem key and state, server linkage,\n*  Attributes  non-authorized, AMODE(any), RMODE(any)\n*\n*  Change\n*  History   2011/10/20 JCB - Patch rollup for CBT tape distribution\n*\n*  Method of\n*  Operation   Refer to the code\n*\n*\n*  Special Notes: None\n*\n*\n*---------------------------------------------------------------------*\n space 1                              |\n print off                            |\n copy  smsyms                         | Structured Macros symbols.\n copy  smpucond                       | DEFUCOND user conditions.\n copy  srvesmac                       | Environment support symbols.\n copy  srvstmac                       | String Formatter symbols.\n copy  srvdtmac                       | Date/Time symbols.\n print on,gen                         |\n eject                                |\n**--------------------------------------------------------------------*\n**\n**               Date/Time Conversion Aid Macros\n**\n**--------------------------------------------------------------------*\n space 1                              |\n          macro                       |\n  Convert_Juldate_To_Days &Juldate=,&Work=,&Days=\n.*--------------------------------------------------------------------*\n.* Macro:      Convert_Juldate_To_Days\n.* Purpose:    Convert a Julian date into the number of days since\n.*             January 1, 0000.  The answer is placed in a register.\n.* Syntax:     Convert_Juldate_To_Days Juldate=address\n.*                                     Work=doubleword,\n.*                                     Days=register (don't use R1!)\n.* Notes:      The code generated by this macro uses R0, R1, & R15.\n.*             If you code a register in the address (ex. you want to\n.*             convert the field at 0(R2), code it as 0(4,R2) since\n.*             the macro uses ZAP to copy the field.\n.*--------------------------------------------------------------------*\n.*xc    &work.(4),&work               |\n.*mvc   &work+4(4),&juldate           |\n  zap   &work,&juldate                | Copy juldate, clear hi word\n  cvb   r1,&work                      |\n  st    r1,&work                      |\n  callsub Convert_Ijuldate_To_Gregorian,                               *\n               (pwa_i_month,pwa_i_day,pwa_i_year,&work),novl\n  callsub Convert_Gregorian_To_Days,(*,*,*,*),novl\n  l     &days,&work                   |\n          mend                        |\n          macro                       |\n  Convert_Days_To_DT_Units  &reg=R0   |\n.*--------------------------------------------------------------------*\n.* Macro:      Convert_Days_To_DT_Units\n.* Purpose:    Convert a number of days since 1/1/0000 (like that pro-\n.*             duced by Convert_Juldate_To_Days) to a number of micro-\n.*             seconds.  The result appears in the register pair named\n.*             by 'reg=', which must denote an even-numbered register.\n.* Syntax:     Convert_Days_To_DT_Units  reg=register | _R0_\n.* Notes:      This routine will multiply the number of days since\n.*             Jan. 1, 0000  by the number of microseconds in a day:\n.*                   24   *   60   *   60   *   10**6\n.*             This won't fit into a fullword, so it is reduced to:\n.*                -> 8*3  *  4*15  *  4*15  *  (15625 * 2**6)\n.*                ->  3   *   15   *   15   *   15625   *   2**13\n.*             The 2**13 is handled by a double shift.\n.*--------------------------------------------------------------------*\n  m     &reg.,=a(3*15*15*15625)       | Multiply days by (...)\n  sldl  &reg.,13                      | Multiply by 2**13\n          mend                        |\n         macro                        |\n  Convert_DT_Units_To_Days  &Units=,&Reg=R0\n.*--------------------------------------------------------------------*\n.* Macro:      Convert_DT_Units_To_Days\n.* Purpose:    Convert a number of microseconds since 1/1/0000 to the\n.*             number of days since 1/1/0000.\n.* Syntax:     Convert_DT_Units_To_Days Days=address,\n.*                                      Reg=register | _R0_\n.* Notes:      This routine will multiply the number of days since\n.*             Jan. 1, 0000  by the number of microseconds in a day:\n.*                   24   *   60   *   60   *   10**6\n.*             This won't fit into a fullword, so it is reduced to:\n.*                -> 8*3  *  4*15  *  4*15  *  (15625 * 2**6)\n.*                ->  3   *   15   *   15   *   15625   *   2**13\n.*             The 2**13 is handled by a double shift.\n.*          .. The result will be in (reg+1) at the end, as the quot-\n.*             ient of the 'divide' at the end.  Ex: if \"REG=R0\" is\n.*             used, the answer appears in R1.\n.*--------------------------------------------------------------------*\n  lclc   &reg2                        |\n  aif    ('&reg'(1,1) ne 'R').regerr  |\n  aif    ('&reg' eq 'R0').setr0       |\n  aif    ('&reg' eq 'R2').setr2       |\n  aif    ('&reg' eq 'R4').setr4       |\n  aif    ('&reg' eq 'R6').setr6       |\n  aif    ('&reg' eq 'R8').setr8       |\n  aif    ('&reg' eq 'R10').setr10     |\n  aif    ('&reg' eq 'R12').setr12     |\n  aif    ('&reg' eq 'R14').setr14     |\n.regerr  mnote 8,\"Register specification of &REG is invalid.\"\n         mexit                        |\n.setr0   anop ,                       |\n&reg2    setc  'R1'                   |\n         ago   .code                  |\n.setr2   anop ,                       |\n&reg2    setc  'R3'                   |\n         ago   .code                  |\n.setr4   anop ,                       |\n&reg2    setc  'R5'                   |\n         ago   .code                  |\n.setr6   anop ,                       |\n&reg2    setc  'R7'                   |\n         ago   .code                  |\n.setr8   anop ,                       |\n&reg2    setc  'R9'                   |\n         ago   .code                  |\n.setr10  anop ,                       |\n&reg2    setc  'R11'                  |\n         ago   .code                  |\n.setr12  anop ,                       |\n&reg2    setc  'R13'                  |\n         ago   .code                  |\n.setr14  anop ,                       |\n&reg2    setc  'R15'                  |\n.code    anop  ,                      |\n   lm    &reg.,&reg2.,&units          | Load doubleword units value\n   srdl  &reg.,13                     | Divide by 2**13\n   d     r0,=a(3*15*15*15625)         |  then by remaining\n         mend  ,                      |\n         macro                        |\n  Convert_Days_To_Juldate &Days=R1,&Work=,&Juldate=\n.*--------------------------------------------------------------------*\n.* Macro:      Convert_Days_To_Juldate\n.* Purpose:    Convert number of days since 1/1/0000 to a Julian date.\n.* Syntax:     Convert_Days_To_Juldate Days=register | _R1_,\n.*                                     Work=doubleword,\n.*                                     Juldate=julian_date_address\n.* Notes:      The code generated by this macro uses R0, R1, R14 & R15.\n.*--------------------------------------------------------------------*\n  st    r1,&work                      |\n  callsub Convert_Days_To_Gregorian,  |                                *\n               (pwa_i_month,pwa_i_day,pwa_i_year,&work),novl\n  callsub Convert_Gregorian_To_Ijuldate,(*,*,*,*),novl\n  l     r1,&work                      |\n  cvd   r1,&work                      |\n  l     r1,&work+4                    |\n  st    r1,&juldate                   |\n         mend                         |\n         macro                        |\n  Validate_Packed_Data   &Data=,&Len=,&Type=DATE\n.*--------------------------------------------------------------------*\n.* Macro:      Validate_Packed_Data\n.* Purpose:    Attempt to ensure packed-decimal input is valid and\n.*             won't cause an 0C7.\n.* Syntax:     Validate_Packed_Data Data=<RX address>,Len=<integer>\n.* Notes:      The code generated by this macro uses R15, R1, and R2.\n.*             If someone wants to make the macro smart enough to pick\n.*             apart any form of RX address someday, the use of field\n.*             pwa_packed_validation can be removed.\n.*        ---> Don't use R15 to point to the input field: the macro\n.*             wipes out the contents of R15.\n.*             Thanks to John Fisher (FISHER@RPIECS) for the basic\n.*             routine.\n.*--------------------------------------------------------------------*\n    gbla  &dt_invalid_input_date      | Globals for the errexit\n    gbla  &dt_invalid_input_time      |\n    gbla  &dt_invalid_input_interval  |\n    lcla  &errcode                    | Local errexit code\n.*--------------------------------------------------------------------*\n  sr    r2,r2                         | Clear R2\n  la    r15,pwa_packed_validation+&len.-1   | Get addr end of input\n  mvc   pwa_packed_validation(&len.),&data  | Copy input to workarea\n  trt   pwa_packed_validation(&len.),psd_packed_table | Check out data:\n  cr    r1,r15                        | R1 should -> last byte: else,\n  jne   inv&sysndx                    |  it's an error.\n  l     r15,=a(jmp&sysndx)\n  ar    r15,r2\n  br    r15\njmp&sysndx  ds  0h                    | If we got a hit, check it out.\n  j     inv&sysndx                    | Byte of 00: no sign on it.\n  j     inv&sysndx                    | Byte of 04: it's not valid.\n  j     ok&sysndx                     | Byte of 08: it's a valid sign.\ninv&sysndx ds 0h                      |\n         aif   ('&type' ne 'DATE').chktime\n&errcode seta  &dt_invalid_input_date\n         ago   .errex\n.chktime aif   ('&type' ne 'TIME').chkint\n&errcode seta  &dt_invalid_input_time\n         ago   .errex\n.chkint  aif   ('&type' ne 'INTERVAL').badtype\n&errcode seta  &dt_invalid_input_interval\n         ago   .errex\n.badtype mnote 8,\"Invalid data type of &TYPE.: must be DATE, TIME or IN*\n               TERVAL\".\n         mexit\n.errex   anop\n  errexit code=&errcode               | Generate error rtn. call\nok&sysndx  ds 0h                      |\n         mend                         |\n eject                                |\n**--------------------------------------------------------------------*\n**\n**  Identify the service processors that Date/Time will use.\n**\n**--------------------------------------------------------------------*\n       space 1                        |\n es_id         id=ES,                 |                                *\n               spepa=pwa_ES_epa,      |                                *\n               sptoken=pwa_ES_token,  |                                *\n               esva=pwaaesv           |\n       space 1                        |\n st_id         id=ST,                 |                                *\n               spepname=&String_Handler,                               *\n               spepa=pwa_ST_epa,      |                                *\n               sptoken=pwa_ST_token,  |                                *\n               sizelength=2,          |                                *\n               esid=ES                |\n       space 1                        |\n title \"SRVDT -- Initialization\"      |\n block name=&srv_modname,type=program,amode=31,rmode=any,              *\n               options=(*srvprc,noclearpwa,long,loctr,                 *\n               (parms,(using,r11),(count,pwa_number_of_parms),         *\n               copy,(copyerror,,&dt_invalid_number_of_parms),vl)),     *\n               parmmap=(parmlist,prm_max_len),                         *\n               basereg=(r12,r9,r8),   |                                *\n               subopts=(*swa,loadbase)\n* *-------------------------------------------------------------------*\n* * If the function code is something other than start, make sure that\n* * the PWA contains the eye-catcher string and the correct value for\n* * DT_ID.   If not, then the DT_ID passed in is garbage.\n* *-------------------------------------------------------------------*\n  l     r1,pwa_number_of_parms        |\n  errexit (ch,r1,lt,=y(prm_min_#)),   | Choke for too few parms        *\n               code=&dt_invalid_number_of_parms\n  l     r1,prm_functioncode           | Load the function code into\n  l     r1,0(,r1)                     |   a register for testing.\n  if (c,r1,ne,=f'&DT_start')          | If not startup function then\n   errexit ((clc,pwa_visual,ne,eyecatcher),or,(c,r13,ne,pwa_DT_id)),   +\n               code=&DT_invalid_DT_id |  go off and croak.\n  endif                               | Endif.\n   title \"SRVDT -- DT_Start Function\" |\n* *-------------------------------------------------------------------*\n* * Select the code to process the function.\n* *-------------------------------------------------------------------*\n  caseblk reg=r1                      | Start of function case block.\n  space 1                             |\n*  *------------------------------------------------------------------*\n*  *\n*  * Start function.\n*  *\n*  *------------------------------------------------------------------*\n   case &DT_start                     |  Start function.\n*   *-----------------------------------------------------------------*\n*   * Set the eyecatcher and the DT_ID fields.   These are checked\n*   * each time the PL server is entered to avoid integrity\n*   * problems.\n*   *-----------------------------------------------------------------*\n    mvc   pwa_visual,eyecatcher       |   Both the eyecatcher and the\n    st    r13,pwa_DT_id               |   DT_ID are for validity checks\n    xc    pwa_clear_start(pwa_clear_length),pwa_clear_start\n*   *-----------------------------------------------------------------*\n*   * Make sure that a valid number of parameters are specified.\n*   *-----------------------------------------------------------------*\n    l     r3,pwa_number_of_parms      |   Load r3 with number of parms.\n    errexit    (ch,r3,lt,=y(prm_start_min_#)),or,   Error if out       +\n               (ch,r3,gt,=y(prm_start_max_#)),      of bounds.         +\n               code=&DT_invalid_number_of_parms\n    space 1                           |\n    l    r1,prm_start_esv             |\n    l    r1,0(,r1)                    |\n    st   r1,pwa_esv                   |\n    using esv,r1                      |\n    mvc   pwa_es_epa,esvesepa         |\n    mvc   pwa_es_token,esvestkn       |\n    drop  r1                          |\n         space 1                      |\n*   *-----------------------------------------------------------------*\n*   * Always start a String Formatter session.\n*   *-----------------------------------------------------------------*\n    sbit  pwaf1sst                    | Note we started a String Hdlr\n    ES_Load_Module  id=ES,spid=ST     | Load string formatter.\n    errexit    (treg,r15,nz),         |                                *\n               code=&DT_environment_support_error\n    ST_Start   ID=ST                  | Start string formatter.\n    errexit    (treg,r15,nz),         |                                *\n               code=&DT_string_handler_error\n*   *-----------------------------------------------------------------*\n*   * Set Gregorian and Leading_Zeros options.\n*   *-----------------------------------------------------------------*\n    if    (clc,pwa_number_of_parms,gt,=a(prm_start_min_#))\n     l32   r1,prm_start_options       |\n     if    nz                         |\n      if    (tbit,0(r1),x'80')        |\n       sbit  pwaf1eur                 |\n      endif                           |\n      if    (tbit,0(r1),x'40')        |\n       sbit  pwaf1lz                  |\n      endif                           |\n     endif                            |\n    endif                             |\n*   *-----------------------------------------------------------------*\n   title \"SRVDT -- DT_Terminate Function\"\n*  *------------------------------------------------------------------*\n*  *\n*  * Terminate function.\n*  *\n*  *------------------------------------------------------------------*\n   case &DT_terminate                 |\n*   *-----------------------------------------------------------------*\n*   * If a String Handler session was started, shut it down.\n*   *-----------------------------------------------------------------*\n    if    (tbit,pwaf1sst)             |\n     ST_Terminate ID=ST               |\n     rbit  pwaf1sst                   | (In case someone needs to know)\n     ES_Unload_Module  id=ES,spid=ST  | Get rid of ST's loadmodule\n    endif                             |\n*   *-----------------------------------------------------------------*\n*   * Indicate PWA should be freed.\n*   *-----------------------------------------------------------------*\n    smctrl freepwa=yes                |   Free the PWA on return.\n*   *-----------------------------------------------------------------*\n   title \"SRVDT -- DT_Get_Current Function\"\n*  *------------------------------------------------------------------*\n*  *\n*  *   Get_Current function.\n*  *\n*  *------------------------------------------------------------------*\n   case &DT_Get_Current               |\n    space 1                           |\n    es_get_time  id=ES,               |   Get current date/time from   *\n               time=pwa_ES_current_time,      Environment Support      *\n               date=pwa_ES_current_date\n    errexit  (treg,r15,nz),           |                                *\n               code=&DT_Environment_Support_Error\n    space 1                           |\n    callsub  call_convert_input,      |       Convert date and time    *\n               (pwa_dt_format_time,   |       to format requested by   *\n               pwa_ES_current_date,   |              caller.           *\n               &dt_ES_format,         |                                *\n               pwa_ES_current_time,   |                                *\n               &dt_ES_format)         |\n    space 1                           |\n    lm    r2,r5,prm_get_current_date  |\n    callsub  call_convert_output,     | Convert internal format        *\n               (pwa_dt_format_time,   | to format requested by         *\n               (r2),(r3),(r4),(r5)),  |        caller.                 *\n               novl                   |\n*  *------------------------------------------------------------------*\n   title \"SRVDT -- DT_Convert Function\"\n*  *------------------------------------------------------------------*\n*  *\n*  *   Convert function.\n*  *\n*  *------------------------------------------------------------------*\n   case &DT_Convert                   |\n    space 1                           |\n    lm    r2,r5,prm_convert_fromdate\n    callsub  call_convert_input,      |       Convert date and time    *\n               (pwa_dt_format_time,   |       to internal format.      *\n               (r2),(r3),(r4),(r5)),  |                                *\n               novl                   |\n    space 1                           |\n    lm    r2,r5,prm_convert_todate    |\n    callsub  call_convert_output,     |       Convert internal format  *\n               (pwa_dt_format_time,   |       to format requested by   *\n               (r2),(r3),(r4),(r5)),  |               caller.          *\n               novl                   |\n*  *------------------------------------------------------------------*\n   title \"SRVDT -- DT_Add Function\"   |\n*  *------------------------------------------------------------------*\n*  *\n*  *   Add function.\n*  *\n*  *------------------------------------------------------------------*\n   case &DT_Add                       |\n    rbit  pwaf1rev                    | See if anyone sets reverse-sign\n*   *-----------------------------------------------------------------*\n*   *  First, convert input date and/or time values to internal format.\n*   *-----------------------------------------------------------------*\n    lm    r2,r5,prm_add_datein        |\n    callsub  call_convert_input,      |       Convert date and time    *\n               (pwa_dt_format_time,   |       to internal format.      *\n               (r2),(r3),(r4),(r5)),  |                                *\n               novl                   |\n*   *-----------------------------------------------------------------*\n*   *  Next, convert interval to internal format.\n*   *-----------------------------------------------------------------*\n    lm    r2,r3,prm_add_interval\n    callsub  call_convert_input_interval,     Convert input interval   *\n               (pwa_dt_format_interval,(r2),(r3)), to internal format. *\n               novl                   |\n*   *-----------------------------------------------------------------*\n*   *  Add input date/time and converted interval.\n*   *-----------------------------------------------------------------*\n    lm    r14,r15,pwa_dt_format_interval\n    lm    r0,r1,pwa_dt_format_time    |\n    if    (tbit,pwaf1rev,off)         | If sign not reversed\n     ar    r0,r14                     | Add-logical upper half\n     alr   r1,r15                     | Add-logical lower half\n     if    not,(cc12)                 | If overflow in low half\n      ah    r0,=h'1'                  |  carry a 1 to high 4 bytes.\n     endif                            |\n    else\n     slr   r1,r15                     | Subtract-logical lower half\n     if    (cc12)                     |\n      sh    r0,=h'1'                  |\n     endif                            |\n     sr    r0,r14                     |\n    endif\n    stm   r0,r1,pwa_dt_format_time    | Save result for output cnvt.\n       eject ,                        |\n*   *-----------------------------------------------------------------*\n*   *  Now, convert result to output format and return to caller.\n*   *-----------------------------------------------------------------*\n    lm    r2,r5,prm_add_dateout       |\n    callsub  call_convert_output,     |       Convert internal format  *\n               (pwa_dt_format_time,   |       to format requested by   *\n               (r2),(r3),(r4),(r5)),  |               caller.          *\n               novl                   |\n*  *------------------------------------------------------------------*\n   title \"SRVDT -- DT_Subtract Function\"\n*  *------------------------------------------------------------------*\n*  *\n*  *   Subtract function.\n*  *\n*  *------------------------------------------------------------------*\n   case &DT_Subtract                  |\n    rbit  pwaf1rev                    | See if anyone sets reverse-sign\n*   *-----------------------------------------------------------------*\n*   *  First, convert input date and/or time values to internal format.\n*   *-----------------------------------------------------------------*\n    lm    r2,r5,prm_subtract_datein   |\n    callsub  call_convert_input,      |       Convert date and time    *\n               (pwa_dt_format_time,   |       to internal format.      *\n               (r2),(r3),(r4),(r5)),  |                                *\n               novl                   |\n*   *-----------------------------------------------------------------*\n*   *  Next, convert interval to internal format.\n*   *-----------------------------------------------------------------*\n    lm    r2,r3,prm_subtract_interval |\n    callsub  call_convert_input_interval,     Convert input interval   *\n               (pwa_dt_format_interval,(r2),(r3)), to internal format. *\n               novl                   |\n*   *-----------------------------------------------------------------*\n*   *  Subtract input date/time and converted interval.\n*   *-----------------------------------------------------------------*\n    lm    r14,r15,pwa_dt_format_interval\n    lm    r0,r1,pwa_dt_format_time    |\n    if    (tbit,pwaf1rev)             | Sign rev'd due to negative int?\n     ar    r0,r14                     |  Add-logical upper half\n     alr   r1,r15                     |  Add-logical lower half\n     if    not,(cc12)                 |  If overflow in low half\n      ah    r0,=h'1'                  |   carry a 1 to high 4 bytes.\n     endif                            |\n    else\n     slr   r1,r15                     | Subtract-logical lower half\n     if    (cc12)                     |\n      sh    r0,=h'1'                  |\n     endif                            |\n     sr    r0,r14                     |\n    endif\n    stm   r0,r1,pwa_dt_format_time    | Save result for output cnvt.\n        eject ,\n*   *-----------------------------------------------------------------*\n*   *  Now, convert result to output format and return to caller.\n*   *-----------------------------------------------------------------*\n    lm    r2,r5,pRM_subtract_dateout  |\n    callsub  call_convert_output,     |       Convert internal format  *\n               (pwa_dt_format_time,   |       to format requested by   *\n               (r2),(r3),(r4),(r5)),  |               caller.          *\n               novl                   |\n*---------------------------------------------------------------------*\n   title \"SRVDT -- DT_Duration Function\"\n*  *------------------------------------------------------------------*\n*  *\n*  *   Duration function.\n*  *\n*  *------------------------------------------------------------------*\n   case &DT_Duration                  |\n*   *-----------------------------------------------------------------*\n*   *  First, convert input date and/or time values to internal format.\n*   *-----------------------------------------------------------------*\n    lm    r2,r5,prm_duration_date1    |\n    callsub  call_convert_input,      |       Convert date and time    *\n               (pwa_dt_format_time,   |       to internal format.      *\n               (r2),(r3),(r4),(r5)),  |                                *\n               novl                   |\n*   *-----------------------------------------------------------------*\n*   * Convert 2nd set of date/time values to internal format.\n*   *-----------------------------------------------------------------*\n    lm    r2,r5,prm_duration_date2    |\n    callsub  call_convert_input,      |       Convert date and time    *\n               (pwa_dt_format_time2,  |       to internal format.      *\n               (r2),(r3),(r4),(r5)),  |                                *\n               novl                   |\n            eject ,\n*   *-----------------------------------------------------------------*\n*   *  Now, see what the difference between them is.\n*   *-----------------------------------------------------------------*\n    if    (clc,pwa_dt_format_time,gt,pwa_dt_format_time2)\n     lm    r0,r1,pwa_dt_format_time   |  Get larger value in R0-R1\n     lm    r14,r15,pwa_dt_format_time2\n    else                              |\n     lm    r0,r1,pwa_dt_format_time2  |\n     lm    r14,r15,pwa_dt_format_time |\n    endif                             |\n    slr   r1,r15                      | Duration-logical lower half\n    if    (cc12)                      |\n     sh    r0,=h'1'                   |\n    endif                             |\n    sr    r0,r14                      |\n    stm   r0,r1,pwa_dt_format_time    | Save result for output cnvt.\n*   *-----------------------------------------------------------------*\n*   *  Now, convert result to output format and return to caller.\n*   *-----------------------------------------------------------------*\n    lm    r2,r3,prm_duration_duration |\n    callsub  call_convert_output_interval,    Convert internal format  *\n               (pwa_dt_format_time,   |       to format requested by   *\n               (r2),(r3)),novl        |               caller.\n*---------------------------------------------------------------------*\n  endcase                             |\n endblk rc=0                          | If no errexit, end RC zero.\n title \"Format Validation Routines\"   |\n*---------------------------------------------------------------------*\n*\n*  All format validation routines have the following characteristics:\n*    .. Each uses field PWA_Validate_R14 to save R14.\n*    .. R14-R2 may be destroyed.  R15 will contain a return code.\n*    .. Each of these subroutines uses *nosubopts: hence, they run\n*       under the procedure base(s) of the mainline.\n*    .. Each format validation routine will attempt to fully validate\n*       a date or time format: once passed by one of these routines, a\n*       date/time converter should not need to do its own validation.\n*    .. Some of these routines may use PWA fields: cases are noted as\n*       they occur.  Results stored in the PWA may be used by callers.\n*\n*---------------------------------------------------------------------*\n space 3                              |\n*---------------------------------------------------------------------*\n*  Subroutine: Validate_Julian_Formats\n*     Purpose: Ensure CPL_Date points to valid Julian date of one of\n*              the supported Julian formats:\n*                Julian   -- 7-digit date (1989359)\n*                Juliand  -- 7-digit w/decimal (1989.359)\n*                Sjulian  -- 5-digit date (89359)\n*                Sjuliand -- 5-digit w/decimal (89.359)\n*       Input: On entry, R1 points to a CPL.\n*      Output: R15 = 0 if date is valid, else R15 = 8.\n*---------------------------------------------------------------------*\n block name=validate_julian_formats,  |                                *\n               type=subroutine,       |                                *\n               options=*nosubopts,    |                                *\n               save=(r14,pwa_validate_r14)\n  using cpl,r1                        |\n  la    r15,8                         | Set default failure RC.\n  l     r14,cpl_date                  | Point to date to validate\n  drop  r1\n  if    (tbit,pwa_julian_flags,pwa_julian)    Julian (C'yyyyddd'):\n   if    (%trt,0(7,r14),ne,psd_numeric_table)    If not numeric, rc 8.\n    leave block=*                     |\n   endif                              |\n  elseif (tbit,pwa_julian_flags,pwa_sjulian)  Sjulian (C'yyddd'):\n   if    (%trt,0(5,r14),ne,psd_numeric_table)    If not numeric, rc 8.\n    leave block=*                     |\n   endif                              |\n  elseif (tbit,pwa_julian_flags,pwa_juliand)  Juliand (C'yyyy.ddd'):\n   if    (%trt,0(4,r14),ne,psd_numeric_table),or,      If not numeric, *\n               (%trt,5(3,r14),ne,psd_numeric_table),or,  w/decimal,    *\n               (cli,4(r14),ne,c'.')   |\n    leave block=*                     |\n   endif                              |\n  elseif (tbit,pwa_julian_flags,pwa_sjuliand) Sjuliand (C'yy.ddd'):\n   if    (%trt,0(2,r14),ne,psd_numeric_table),or,   If not numeric,    *\n               (%trt,3(3,r14),ne,psd_numeric_table),or,  w/decimal,    *\n               (cli,2(r14),ne,c'.')   |\n    leave block=*                     |\n   endif                              |\n  endif                               | If we got this far,\n  xr    r15,r15                       |   it must be OK.\n endblk rc=(r15)                      |\n eject                                |\n*---------------------------------------------------------------------*\n*  Subroutine: Validate_Gregorian_Formats\n*     Purpose: Ensure CPL_Date points to a valid Gregorian date of one\n*              of the following formats:\n*                Gregorian  -- Normal Gregorian (12/25/1989, 1/3/1990,\n*                              4/15/1991 and 03/04/1990 are all valid)\n*                Sgregorian -- Short Gregorian (12/25/89,1/3/90,4/15/91\n*                              03/04/90 are all valid)\n*                Sortdate   -- Sortable date w/dashes (1989-12-25)\n*                Ssortdate  -- Short sortable date (19-12-25)\n*       Input: On entry, R1 points to a CPL.\n*      Output: R15 = 0 if date is valid, else R15 = 8.\n*        Note: This routine fills in the following PWA fields:\n*              PWA_Numeric_Day   PWA_Numeric_Month  PWA_Numeric_Year\n*---------------------------------------------------------------------*\n block name=validate_gregorian_formats,                                *\n               type=subroutine,       |                                *\n               options=*nosubopts,    |                                *\n               save=(r14,pwa_validate_r14)\n  using cpl,r1                        |\n  la    r15,8                         | Set default 'failure' rc.\n  l     r14,cpl_date                  | Point to incoming date\n  drop  r1                            |\n  mvc   pwa_numeric_day,=c'00'        | Set all day, month, year digits\n  mvc   pwa_numeric_month,=c'00'      |  to c'00's\n  mvc   pwa_numeric_year,=c'0000'     |\n  if    (tbit,pwa_gregorian_flags,pwa_gregorian),or,  C'mm/dd/yyyy' or *\n               (tbit,pwa_gregorian_flags,pwa_sgregorian)  C'mm/dd/yy':\n   if    (%trt,0(2,r14),eq,psd_numeric_table),and,  Is 1st thing       *\n               (cli,2(r14),eq,c'/')   |            2 digits long?\n    if   (tbit,pwaf1eur)              |  If European format\n     mvc  pwa_numeric_day(2),0(r14)   |   it's the day,\n    else                              |  else\n     mvc  pwa_numeric_month(2),0(r14) |   it's the month.\n    endif                             |\n    la   r14,3(r14)                   |  Point past it.\n   elseif (%trt,0(1,r14),eq,psd_numeric_table),and,  Else is 1st thing *\n               (cli,1(r14),eq,c'/')   |                1 digit long?\n    if   (tbit,pwaf1eur)              |  If European format\n     mvc  pwa_numeric_day+1(1),0(r14) |   it's the day,\n    else                              |  else\n     mvc  pwa_numeric_month+1(1),0(r14)   it's the month.\n    endif                             |\n    la   r14,2(r14)                   |  Point past it.\n   else                               | Else\n    leave block=*                     |  invalid format.\n   endif                              |\n   if    (%trt,0(2,r14),eq,psd_numeric_table),and,  Is 2nd thing       *\n               (cli,2(r14),eq,c'/')   |            2 digits long?\n    if   (tbit,pwaf1eur)              |  If European format\n     mvc  pwa_numeric_month(2),0(r14) |   it's the month,\n    else                              |  else\n     mvc  pwa_numeric_day(2),0(r14)   |   it's the day.\n    endif                             |\n    la   r14,3(r14)                   |  Point past it.\n   elseif (%trt,0(1,r14),eq,psd_numeric_table),and,  Else is 2nd thing *\n               (cli,1(r14),eq,c'/')   |                1 digit long?\n    if   (tbit,pwaf1eur)              |  If European format\n     mvc  pwa_numeric_month+1(1),0(r14)   it's the month,\n    else                              |  else\n     mvc  pwa_numeric_day+1(1),0(r14) | it's the day.\n    endif                             |\n    la   r14,2(r14)                   |  Point past it.\n   else                               | Else\n    leave block=*                     |  invalid format.\n   endif                              |\n   if    (tbit,pwa_gregorian_flags,pwa_sgregorian)  If short-Gregorian\n    leave block=*,(%trt,0(2,r14),ne,psd_numeric_table)  Need 2 digits\n    mvc   pwa_numeric_year(2),psd_default_century    Force 20th century\n    mvc   pwa_numeric_year+2(2),0(r14)                and append years.\n   else                               | Otherwise (normal Gregorian)\n    leave block=*,(%trt,0(4,r14),ne,psd_numeric_table)  Need 4 digits\n    mvc   pwa_numeric_year,0(r14)     |             Move 4 year digits.\n   endif                              |\n      eject ,                         |\n  elseif (tbit,pwa_gregorian_flags,pwa_sortdate)      C'yyyy-mm-dd':\n   if          (%trt,0(4,r14),ne,psd_numeric_table),or,                *\n               (%trt,5(2,r14),ne,psd_numeric_table),or,                *\n               (cli,4(r14),ne,c'-'),or,                                *\n               (cli,7(r14),ne,c'-'),or,                                *\n               (%trt,8(2,r14),ne,psd_numeric_table)\n    leave block=*                     |\n   endif                              |\n   mvc   pwa_numeric_year,0(r14)      |\n   mvc   pwa_numeric_month,5(r14)     |\n   mvc   pwa_numeric_day,8(r14)       |\n  elseif (tbit,pwa_gregorian_flags,pwa_ssortdate) C'yy-mm-dd':\n   if          (%trt,0(2,r14),ne,psd_numeric_table),or,                *\n               (%trt,3(2,r14),ne,psd_numeric_table),or,                *\n               (cli,2(r14),ne,c'-'),or,                                *\n               (cli,5(r14),ne,c'-'),or,                                *\n               (%trt,6(2,r14),ne,psd_numeric_table)\n    leave block=*                     |\n   endif                              |\n   mvc   pwa_numeric_year(2),psd_default_century\n   mvc   pwa_numeric_year+2(2),0(r14) |\n   mvc   pwa_numeric_month,3(r14)     |\n   mvc   pwa_numeric_day,6(r14)       |\n  endif                               |\n  xr    r15,r15                       | Hmmm, must be OK.\n endblk rc=(r15)                      |\n eject                                |\n*---------------------------------------------------------------------*\n*  Subroutine: Validate_Normal_Formats\n*     Purpose: Ensure CPL_Date points to valid Normal date of the form\n*              'dd mon yyyy' (ex. C'01 Jan 1990'), or a valid Snormal\n*              date of the form 'dd mmm yy' (ex. 01 Jan 90').\n*       Input: On entry, R1 points to a CPL.\n*      Output: R15 = 0 if date is valid, else R15 = 8.\n*       Notes: The following PWA fields are used by this routine:\n*                   pwa_text_month           pwa_i_month\n*                   pwa_numeric_day          pwa_i_day\n*                   pwa_numeric_year         pwa_i_year\n*---------------------------------------------------------------------*\n block name=validate_normal_formats,  |                                *\n               type=subroutine,       |                                *\n               options=*nosubopts,    |                                *\n               save=(r14,pwa_validate_r14)\n  using cpl,r1                        |\n  l     r14,cpl_date                  |\n  la    r15,8\n  drop  r1\n* *-------------------------------------------------------------------*\n  if    (tbit,pwa_normal_flags,pwa_normal)             C'dd mon yyyy':\n   if       ((%trt,0(1,r14),ne,psd_numeric_table),and,                 *\n               (cli,0(r14),ne,c' ')),or,                               *\n               (%trt,1(1,r14),ne,psd_numeric_table),or,                *\n               (cli,2(r14),ne,c' '),or,                                *\n               (cli,6(r14),ne,c' '),or,                                *\n               (%trt,7(4,r14),ne,psd_numeric_table)\n    leave block=*                     |\n   endif                              |\n   mvc   pwa_numeric_year,7(r14)      | Get years from input date\n   mvc   pwa_numeric_day(2),0(r14)    | Extract the days.\n   mvc   pwa_text_month(3),3(r14)     | Extract out the month.\n* *-------------------------------------------------------------------*\n  elseif (tbit,pwa_normal_flags,pwa_snormal)        C'dd mon yy':\n   if       ((%trt,0(1,r14),ne,psd_numeric_table),and,                 *\n               (cli,0(r14),ne,c' ')),or,                               *\n               (%trt,1(1,r14),ne,psd_numeric_table),or,                *\n               (cli,2(r14),ne,c' '),or,                                *\n               (cli,6(r14),ne,c' '),or,                                *\n               (%trt,7(2,r14),ne,psd_numeric_table)\n    leave block=*                     |\n   endif                              |\n   mvc   pwa_numeric_year(2),psd_default_century Force 20th century\n   mvc   pwa_numeric_year+2(2),7(r14) |        and append years.\n   mvc   pwa_numeric_day(2),0(r14)    | Extract the days.\n   mvc   pwa_text_month,3(r14)        |\n        eject ,\n* *-------------------------------------------------------------------*\n  elseif (tbit,pwa_normal_flags,pwa_sasdate7)        C'ddmonyy':\n   if       ((%trt,0(2,r14),ne,psd_numeric_table),or,                  *\n               (%trt,5(2,r14),ne,psd_numeric_table))\n    leave block=*                     |\n   endif                              |\n   mvc   pwa_numeric_year(2),psd_default_century Force 20th century\n   mvc   pwa_numeric_year+2(2),5(r14) |        and append years.\n   mvc   pwa_numeric_day(2),0(r14)    | Extract the days.\n   mvc   pwa_text_month,2(r14)        |\n* *-------------------------------------------------------------------*\n  elseif (tbit,pwa_normal_flags,pwa_sasdate9)       C'ddmonyyyy':\n   if       ((%trt,0(2,r14),ne,psd_numeric_table),or,                  *\n               (%trt,5(4,r14),ne,psd_numeric_table))\n    la    r15,8                       |\n    leave block=*                     |\n   endif                              |\n   mvc   pwa_numeric_day(2),0(r14)    | Extract the days.\n   mvc   pwa_numeric_year,5(r14)      | Move years.\n   mvc   pwa_text_month,2(r14)        |\n* *-------------------------------------------------------------------*\n  elseif (tbit,pwa_normal_flags,pwa_yyyymmmdd)      C'yyyymondd':   @cx\n   if       ((%trt,0(4,r14),ne,psd_numeric_table),or,               @cx*\n               (%trt,7(2,r14),ne,psd_numeric_table))                @cx\n    la    r15,8                       |                             @cx\n    leave block=*                     |                             @cx\n   endif                              |                             @cx\n   mvc   pwa_numeric_year,0(r14)      | Move years.                 @cx\n   mvc   pwa_text_month,4(r14)        |                             @cx\n   mvc   pwa_numeric_day(2),7(r14)    | Extract the days.           @cx\n  endif                               |                             @cx\n* *-------------------------------------------------------------------*\n* lr    r1,r14                        | Restore CPL basereg\n  if    (cli,pwa_numeric_day,eq,c' ') | If first character is blank\n   mvi   pwa_numeric_day,c'0'         |  add a leading zero.\n  endif                               |\n  oi    pwa_text_month,x'40'          | Ensure 1st letter is caps\n  nc    pwa_text_month+1(2),=x'bfbf'  |  and others are lowercase.\n  pack  pwa_d,pwa_numeric_year        | Pack years,\n  cvb   r0,pwa_d                      |  then convert to integer.\n  st    r0,pwa_i_year                 | Save R1 past subroutine call\n  pack  pwa_d,pwa_numeric_day         | Pack days,\n  cvb   r0,pwa_d                      |  then convert to integer.\n  st    r0,pwa_i_day                  |\n  la    r14,psd_month_table           | Look up month name\n  using month_table,r14               |\n  la    r15,mt_#_entries              |\n  loop  bct                           |\n   leave loop=*,(clc,pwa_text_month(3),eq,mt_month_name)\n   la    r14,mt_length(,r14)          |\n  endloop bct,r15                     |\n  if    (treg,r15,z)                  | If R15 went to zero\n   la    r15,8                        |  Invalid month name.\n   leave block=*                      |\n  endif                               |\n  lh    r0,mt_month_num               | Move month number to PWA\n  st    r0,pwa_i_month                |  for caller.\n  xr    r15,r15                       | Success if we got this far.\n  drop  r14                           |\n endblk rc=(r15)                      |\n eject                                |\n*---------------------------------------------------------------------*\n*  Subroutine: Validate_Text_Formats\n*     Purpose: Ensure CPL_Date points to valid text date of the form:\n*                Text  -- 'December 25, 1989'\n*                Textd -- 'Monday, December 25, 1989'\n*       Input: On entry, R1 points to a CPL.\n*      Output: R15 = 0 if date is valid, else R15 = 8.\n*       Notes: The following PWA fields are used by this routine:\n*                   pwa_text_month     pwa_numeric_year\n*                   pwa_numeric_day    pwa_text_weekday\n*---------------------------------------------------------------------*\n block name=validate_text_formats,    |                                *\n               type=subroutine,       |                                *\n               options=*nosubopts,    |                                *\n               save=(r14,pwa_validate_r14)\n  using cpl,r1                        |\n  la    r14,r1                        | Save CPL address past TRT's\n  l     r15,cpl_date                  |\n  drop  r1\n* *-------------------------------------------------------------------*\n* * Validations: Monthname exists in table\n* *              Days numeric, 1 or 2 digits, not more than is valid\n* *                for month\n* *              Year numeric\n* *-------------------------------------------------------------------*\n* *  If 'textd' format requested, extract and validate weekday.\n* *-------------------------------------------------------------------*\n  if    (tbit,pwa_text_flags,pwa_textd)  Is there a weekday up front?\n   fill  pwa_text_weekday,c' '        |\n   la    r1,pwa_text_weekday          |\n   la    r2,pwa_text_weekday+l'pwa_text_weekday\n   loop  while,(cli,0(r15),ne,c' '),and,  Extract it til ' ' or ','    *\n               (cli,0(r15),ne,c','),and,                               *\n               (cr,r1,le,r2)          |\n    mvc   0(1,r1),0(r15)              |    Move a byte\n    ni    0(r1),x'bf'                 |    Make it lowercase\n    la    r15,1(,r15)                 |    Next byte\n    la    r1,1(,r1)                   |\n   endloop while                      |\n   lr    r2,r15                       | Save addr of weekday's end\n   oi    pwa_text_weekday,x'40'       | Make 1st char uppercase\n   la    r14,psd_weekday_table        | Look it up\n   la    r15,7                        |\n   loop  bct                          |\n    leave loop=*,(clc,pwa_text_weekday,eq,1(r14))    Hit? OK.\n    la    r14,l'psd_weekday_table(,r14)\n   endloop bct,r15                    |\n   if    (treg,r15,z)                 | Nothing found?\n    la    r15,8                       |  This date's not valid textd.\n    leave block=*                     |\n   endif                              |\n   loop  while,(cli,0(r2),eq,c' '),or,(cli,0(r2),eq,c',')\n    la    r2,1(,r2)                   |  Scan past delimiters\n   endloop while                      |\n   lr    r15,r2                       |  Save pointer to month\n  endif                               |\n     eject ,\n* *-------------------------------------------------------------------*\n* *  Extract month.\n* *-------------------------------------------------------------------*\n  fill  pwa_text_month,c' '           |\n  la    r1,pwa_text_month             |\n  la    r2,pwa_text_month+l'pwa_text_month\n  loop  while,(cli,0(r15),ne,c' '),and,(cr,r1,lt,r2)  Extract month:\n   mvc   0(1,r1),0(r15)               |  Move a byte\n   ni    0(r1),x'bf'                  |  Make it lowercase\n   la    r1,1(,r1)                    |  Next byte.\n   la    r15,1(,r15)                  |\n  endloop while                       |\n  oi    pwa_text_month,x'40'          | Make 1st byte uppercase\n* *-------------------------------------------------------------------*\n* *  Skip blanks, then extract and validate day.\n* *-------------------------------------------------------------------*\n  loop  while,(cli,0(r15),eq,c' ')    | Scan to start of numeric day\n   la    r15,1(,r15)                  |\n  endloop while                       |\n  if    (cli,1(r15),eq,c',')          | If day looks like 1 digit\n   mvi   pwa_numeric_day,c'0'         |  Put a 0 on front of our copy\n   mvc   pwa_numeric_day+1(1),0(r15)  |  Copy the digit\n   la    r15,2(,r15)                  |   and point past the comma,\n  elseif (cli,2(r15),eq,c',')         | If day looks like 2 digits\n   mvc   pwa_numeric_day(2),0(r15)    |  Copy both digits\n   la    r15,3(,r15)                  |   and point past the comma\n  else                                | Otherwise, dunno what this is,\n   la    r15,8                        |  so fail validation.\n   leave block=*                      |\n  endif                               |\n  if    (%trt,pwa_numeric_day,ne,psd_numeric_table)   Day not numeric?\n   la    r15,8                        |                Reject it.\n   leave block=*                      |\n  endif                               |\n* *-------------------------------------------------------------------*\n* *  Skip blanks, then extract and validate year.\n* *-------------------------------------------------------------------*\n  loop  while,(cli,0(r15),eq,c' ')    |\n   la    r15,1(,r15)                  |\n  endloop while                       |\n  mvc   pwa_numeric_year,0(r15)       | Get 4 digits worth.\n  if    (%trt,pwa_numeric_year,ne,psd_numeric_table)  Not numeric?\n   la    r15,8                        |                Reject it.\n   leave block=*                      |\n  endif                               |\n  xr    r15,r15                       | Must be OK if it got here.\n endblk rc=(r15)                      |\n eject                                |\n*---------------------------------------------------------------------*\n*  Subroutine: Validate_HHMMSS_Formats\n*     Purpose: Ensure CPL_Time points to valid time value of one of the\n*              following forms:\n*       Input: On entry, R1 points to a CPL.\n*      Output: R15 = 0 if date is valid, else R15 = 8.\n*       Notes: The following PWA fields are used by this routine:\n*---------------------------------------------------------------------*\n block name=validate_HHMMSS_formats,  |                                *\n               type=subroutine,       |                                *\n               options=*nosubopts,    |                                *\n               save=(r14,pwa_validate_r14)\n  using cpl,r1                        |\n  la    r15,8                         | Save CPL address past TRT's\n  l     r14,cpl_time                  |\n  drop  r1\n* *-------------------------------------------------------------------*\n* * Validations: Hours numeric, not > c'24', followed by c':'\n* *              Minutes numeric, not > c'60', maybe followed by c':'\n* *              Seconds numeric, not > c'60', maybe followed by c'.'\n* *              Hundredths numeric if present\n* *              If civilian: hours not > 12, time followed by AM/PM\n* *-------------------------------------------------------------------*\n  if    (cli,0(r14),eq,c' ')          |  If leading char is blank\n   if    (%trt,1(1,r14),ne,psd_numeric_table)  If 2nd char not numeric\n    leave block=*                     |\n   endif                              |\n  else                                |\n   if          (%trt,0(2,r14),ne,psd_numeric_table),or,  | HH numeric  *\n               (clc,0(2,r14),gt,=c'24')                  | HH not > 24\n    leave block=*                     |\n   endif                              |\n  endif                               |\n  if           (cli,2(r14),ne,c':'),or,                  | : after HH  *\n               (%trt,3(2,r14),ne,psd_numeric_table),or,  | MM numeric  *\n               (clc,3(2,r14),gt,=c'60')                  | MM not > 60\n   leave block=*                      |\n  endif                               |\n  if           (tbit,pwa_hhmmss_flags,pwa_hhmm,off),and, | If not HHMM:*\n               ((cli,5(r14),ne,c':'),or,                 | : after MM  *\n               (%trt,6(2,r14),ne,psd_numeric_table),or,  | SS numeric  *\n               (clc,6(2,r14),gt,=c'60'))                 | SS not > 60\n   leave block=*                      |\n  endif                               |\n  if           (tbit,pwa_hhmmss_flags,pwa_hhmmssth),and, | If HHMMSSTH:*\n               ((%trt,9(2,r14),ne,psd_numeric_table),or, | TH numeric  *\n               ((cli,8(r14),ne,c':'),and,(cli,8(r14),ne,c'.')))  : or .\n   leave block=*                      |\n  endif                               |\n  if           (tbit,pwa_hhmmss_flags,pwa_civilian),and, | If Civilian *\n               ((clc,0(2,r14),gt,=c'12'),or,             | PM if HH>12 *\n               ((clc,=c' AM',ne,8(r14)),and,(clc,=c' PM',ne,8(r14))))\n   leave block=*                      |\n  endif                               |\n  xr    r15,r15                       |\n endblk rc=(r15)                      |\n eject                                |\n*---------------------------------------------------------------------*\n*  Subroutine: Validate_Delta_Formats\n*     Purpose: Ensure CPL_Time points to valid Delta-format time value\n*              as follows:  <dddd>d-hh<:mm<:ss<.th>>>\n*       Input: On entry, R1 points to a CPL.\n*      Output: R15 = 0 if date is valid, else R15 = 8.\n*       Notes: The following PWA fields are used by this routine:\n*        PWA_Number_Of_Days  PWA_Number_Of_Hours  PWA_Number_Of_Minutes\n*             PWA_Number_Of_Seconds   PWA_Number_Of_Hundredths\n*---------------------------------------------------------------------*\n block name=validate_delta_format,    |                                *\n               type=subroutine,       |                                *\n               options=*nosubopts,    |                                *\n               save=(r14,pwa_validate_r14)\n  lr    r4,r1\n  using cpl,r4                        |\n  l     r15,cpl_interval              |\n* *-------------------------------------------------------------------*\n* * Validations: Any value before '-' is 1-5 numeric digits\n* *              Hours numeric, not > c'24', followed by c':'\n* *              Minutes numeric, not > c'60', maybe followed by c':'\n* *              Seconds numeric, not > c'60', maybe followed by c'.'\n* *              Hundredths numeric if present\n* *              If civilian: hours not > 12, time followed by AM/PM\n* *-------------------------------------------------------------------*\n  xc    pwa_interval_numbers(l_interval_numbers),pwa_interval_numbers\n  la    r14,1(,r15)                   |\n  la    r2,5                          |\n  loop  bct                           | Scan for a '-':\n   leave loop=*,(cli,0(r14),eq,c'-')  |  Quit if we found one,\n   la    r14,1(,r14)                  |  else keep looking.\n  endloop bct,r2                      |\n  lnr   r14,r2                        | Length is (maxlen + 1 - R2):\n  ah    r14,=h'6'                     | R14 is now length of operand\n  st    r14,pwa_f                     | Save\n  if    (treg,r2,nz)                  | If we got a hit\n   bctr  r14,0                        |  Decrement length for execute\n   exi   r14,(trt,0(0,r15),psd_numeric_table)    Check for numerics:\n   if    ne                           |\n    la    r15,8                       |\n    leave block=*                     |\n   endif                              |\n   fill  pwa_edit,c'0',length=5       | Initialize interval_days\n   la    r1,pwa_edit+5                | Point to field_end+1\n   s     r1,pwa_f                     | Knock off bytes_remaining in\n*                                     | original field, then move only\n   exi   r14,(mvc,0(0,r1),0(r15))     | the number of bytes provided.\n   la    r15,1+1(r14,r15)             | Point past the '-'\n   pack  pwa_d,pwa_edit(5)            | Convert to packed,\n   cvb   r1,pwa_d                     |  then to integer,\n   st    r1,pwa_number_of_days        |   then save number of days.\n  endif                               | That's it for 'days'.\n* *-------------------------------------------------------------------*\n        eject ,                       |\n  if    (%trt,0(2,r15),ne,psd_numeric_table)\n   la    r15,8                        |\n   leave block=*                      |\n  endif                               |\n  mvc   pwa_edit(2),0(r15)            |\n  pack  pwa_d,pwa_edit(2)             |\n  cvb   r1,pwa_d                      |\n  st    r1,pwa_number_of_hours        |\n  if    (cli,2(r15),eq,c':')          | If something follows hours:\n   if    (%trt,3(2,r15),ne,psd_numeric_table)\n    la    r15,8                       |  It better be numeric\n    leave block=*                     |\n   endif                              |\n   mvc   pwa_edit(2),3(r15)           |\n   pack  pwa_d,pwa_edit(2)            |\n   cvb   r1,pwa_d                     |\n   st    r1,pwa_number_of_minutes     |\n   if    (cli,5(r15),eq,c':')         | If something follows minutes:\n    if    (%trt,6(2,r15),ne,psd_numeric_table)\n     la    r15,8                      |\n     leave block=*                    |\n    endif                             |\n    mvc   pwa_edit(2),6(r15)          |\n    pack  pwa_d,pwa_edit(2)           |\n    cvb   r1,pwa_d                    |\n    st    r1,pwa_number_of_seconds    |\n    if    (cli,8(r15),eq,c'.')        | If something follows seconds:\n     if    (%trt,9(2,r15),ne,psd_numeric_table)\n      la    r15,8                     |\n      leave block=*                   |\n     endif                            |\n     mvc   pwa_edit(2),9(r15)         |\n     pack  pwa_d,pwa_edit(2)          |\n     cvb   r1,pwa_d                   |\n     st    r1,pwa_number_of_hundredths\n    elseif (cli,8(r15),ne,c' ')       |\n     la    r15,8                      |\n     leave block=*                    |\n    endif                             |\n   elseif (cli,5(r15),ne,c' ')        |\n    la    r15,8                       |\n    leave block=*                     |\n   endif                              |\n  elseif (cli,2(r15),ne,c' ')         |\n   la    r15,8                        |\n   leave block=*                      |\n  endif                               |\n* *-------------------------------------------------------------------*\n  xr    r15,r15                       |\n  drop  r4                            |\n endblk rc=(r15)                      |\n title \"Drive Input Format Routines\"  |\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Call_Convert_Input\n*  Abstract:   This routine will call the appropriate input date and\n*              time formatting routines based on the caller's request.\n*              This routine is called from the main case block, as well\n*              as from other internal routines.\n*  Inputs:     On entry, R1 points to the following parameter list:\n*                +0 -- Internal format date/time doubleword\n*                +4 -- Place to get date value to convert\n*                +8 -- Format for input date value\n*                +C -- Place to get time value to convert\n*               +10 -- Format for input time value\n*                  (This parameter list is known as a \"converter para-\n*                  meter list\", or \"CPL\", and is common to all of the\n*                  date and time format conversion subroutines.)\n*  Outputs:    Appropriate routine(s) called\n*  Special\n*  Notes:      . As new input formatting routines are coded, add add'l\n*                CASE statements and setup code to this subroutine.\n*              . This routine only saves R14.  The routines that it\n*                calls are responsible for handling their own regs.\n*\n*---------------------------------------------------------------------*\n         space 1                      |\n block name=Call_Convert_Input,type=subroutine,                        *\n               options=(*nosubopts),                                   *\n               save=(r14,pwa_call_convert_r14)\n         space 1                      |\n  lr    r4,r1                         |\n  using cpl,r4                        |\n  l     r15,cpl_internal              | Zero out internal-format time\n  xc    0(8,r15),0(r15)               |  / date doubleword.\n  fill  pwa_flags,x'00',length=l_flags\n* *-------------------------------------------------------------------*\n* * Set up for time conversion routines.  This allows less duplication\n* * of code in the actual converter routines.\n* *-------------------------------------------------------------------*\n  block name=input_time_conversion    |\n   mvi   pwa_hhmmss_flags,x'00'       |\n*  *------------------------------------------------------------------*\n*  * Special cases: If date is requested in DT_ES_Format or time is\n*  * requested in  DT_TODclock format, call one convert routine to\n*  * handle both and quit. This eliminates a subroutine call during\n*  * input conversion.\n*  *------------------------------------------------------------------*\n   l32   r14,cpl_date_format          | Get date format\n   if    (nz)                         | If nonzero\n    l     r14,0(,r14)                 |  Get the value\n    if    (c,r14,eq,=a(&dt_es_format))   If it ES_format?\n     callsub Convert_Date_From_ES_Format   Call combined converter\n     leave block=Call_Convert_Input   |    and exit input conversion.\n    endif                             |\n   endif                              |\n*                                     |\n   l32   r14,cpl_time                 | See if time parm present\n   leave block=*,(z)                  | Not there? Get out.\n   l32   r14,cpl_time_format          | Make sure we got a format\n   errexit (z),code=&dt_invalid_time_format  No? No defaults.\n   l     r14,0(,r14)                  | Get the format value\n   if    (c,r14,eq,=a(&dt_todclock))  | Is it TODCLOCK request?\n    callsub  Convert_Time_From_TODclock    Call combined converter\n    leave block=Call_Convert_Input    |     and exit input conversion.\n   elseif (c,r14,eq,=a(&dt_seconds_since_1970))\n    callsub Convert_Time_From_SecondsSince1970\n    leave block=Call_Convert_Input    |     and exit input conversion.\n   endif                              |\n*  *------------------------------------------------------------------*\n*  * Normal setup for time format processing.\n*  *------------------------------------------------------------------*\n   loop  until                        |\n    l32   r14,cpl_time_format         | Point to input time format\n    l     r14,0(,r14)                 | Get it (we know it's nonzero)\n    caseblk  reg=r14                  |\n     case &dt_hhmm                    |\n      sbit  pwa_hhmmss_flags,pwa_hhmm |\n     case &dt_hhmmss                  |\n      sbit  pwa_hhmmss_flags,pwa_hhmmss\n     case &dt_hhmmssth                |\n      sbit  pwa_hhmmss_flags,pwa_hhmmssth\n     case &dt_civilian                |\n      sbit  pwa_hhmmss_flags,pwa_civilian\n     case &dt_general_input           |\n      sbit  pwa_general_flags,pwa_general_input\n     case &dt_unspecified             |\n      leave block=Input_Time_Conversion\n     case other                       |\n    endcase                           |\n    eject ,                           |\n*  *------------------------------------------------------------------*\n*  * Call requested time conversion routine.  Note that some of these\n*  * routines may issue a LEAVE when completed, since they handle the\n*  * date conversion as well.\n*  *------------------------------------------------------------------*\n    l32   r14,cpl_time_format         | Get addr of output time format\n    l     r14,0(,r14)                 | Get the format\n    caseblk  reg=r14                  | Set up and call format routine:\n     case &dt_es_format,&dt_Hundredths   Convert to Envir. Support fmt:\n      callsub Convert_Time_From_Hundredths\n     case &dt_hhmm,&dt_hhmmss,&dt_hhmmssth,&dt_civilian\n      callsub Convert_Time_From_HHMMSS\n     case &dt_general_input           | Multiple-choice format\n      callsub Convert_Time_From_General_Input\n      la    r15,8                     |  Force loop to be redriven\n*                                     |\n     case other                       | Unknown time format:\n      l     r15,cpl_time_format       |  Point to format address\n      l     r15,0(,r15)               |  Load format into R15\n      errexit code=&dt_invalid_time_format Return error to caller.\n    endcase                           |\n   endloop until,(treg,r15,z)         |\n  endblk                              |\n         eject                        |\n* *-------------------------------------------------------------------*\n* *  Set up for date conversion routines. This allows less duplication\n* *  of code in the converter routines themselves.  Note that this is\n* *  enclosed in a Loop Until: this is for the DT_General_Input format,\n* *  which may cause the block to be redriven once the true format is\n* *  recognized.\n* *-------------------------------------------------------------------*\n  block name=input_date_conversion    |\n   loop  until                        |\n    fill  pwa_flags,x'00',length=(l_flags)\n    l32   r14,cpl_date                | Get pointer to input date\n    leave block=*,(z)                 | Get out if no date present.\n    l32   r14,cpl_date_format         | Get input date format\n    errexit (z),name=&dt_invalid_date_format  Croak if no format\n    l     r14,0(,r14)                 | Get the format\n    caseblk  reg=r14                  | Set up for converter routines:\n     case &dt_julian                  |\n      sbit  pwa_julian_flags,pwa_julian\n     case &dt_juliand                 |\n      sbit  pwa_julian_flags,pwa_juliand\n     case &dt_pjulian,&dt_es_format   |\n      sbit  pwa_julian_flags,pwa_pjulian\n     case &dt_ijulian                 |\n      sbit  pwa_julian_flags,pwa_ijulian\n     case &dt_sjulian                 |\n      sbit  pwa_julian_flags,pwa_sjulian\n     case &dt_sjuliand                |\n      sbit  pwa_julian_flags,pwa_sjuliand\n     case &dt_gregorian               |\n      sbit  pwa_gregorian_flags,pwa_gregorian\n     case &dt_sgregorian              |\n      sbit  pwa_gregorian_flags,pwa_sgregorian\n     case &dt_normal                  |\n      sbit  pwa_normal_flags,pwa_normal\n     case &dt_snormal                 |\n      sbit  pwa_normal_flags,pwa_snormal\n     case &dt_sasdate7                |\n      sbit  pwa_normal_flags,pwa_sasdate7\n     case &dt_sasdate9                |\n      sbit  pwa_normal_flags,pwa_sasdate9\n     case &dt_yyyymmmdd               |                             @cx\n      sbit  pwa_normal_flags,pwa_yyyymmmdd                          @cx\n     case &dt_text                    |\n      sbit  pwa_text_flags,pwa_text   |\n     case &dt_textd                   |\n      sbit  pwa_text_flags,pwa_textd  |\n     case &dt_sortdate                |\n      sbit  pwa_gregorian_flags,pwa_sortdate\n     case &dt_ssortdate               |\n      sbit  pwa_gregorian_flags,pwa_ssortdate\n     case &dt_general_input           |\n      sbit  pwa_general_flags,pwa_general_input\n     case &dt_unspecified             | Not provided: leave.\n      leave block=Input_Date_Conversion\n     case  other                      | Not listed here: Do nothing.\n    endcase                           |\n    eject ,                           |\n*   *-----------------------------------------------------------------*\n*   * Call requested date conversion routine.\n*   *-----------------------------------------------------------------*\n    lr    r1,r4                       | Restore CPL address in R1\n    l32   r14,cpl_date_format         | Get input date format\n    l     r14,0(,r14)                 | Get value (we know it's NZ)\n    caseblk  reg=r14                  | Set up and call format routine:\n     case &dt_ijulian,&dt_pjulian,&dt_julian,&dt_juliand,              *\n               &dt_sjulian,&dt_sjuliand,&dt_es_format\n      callsub Convert_Date_From_Julian\n     case &dt_gregorian,&dt_sgregorian,  Gregorian and Sortdate formats*\n               &dt_sortdate,&dt_ssortdate\n      callsub Convert_Date_From_Gregorian\n     case &dt_normal,&dt_snormal,     |  Normal format (01 Oct 1989)   *\n               &dt_sasdate7,&dt_sasdate9,                              *\n               &dt_yyyymmmdd          |                             @cx\n      callsub Convert_Date_From_Normal\n     case &dt_text,&dt_textd          |  Text (October 1, 1989)\n      callsub Convert_Date_From_Text  |\n     case &dt_number_of_days          |  No. of days since 1/1/0000\n      callsub Convert_Date_From_Number\n     case &dt_general_input           | Multiple-choice format\n      callsub Convert_Date_From_General_Input\n      la    r15,8                     |  Force loop to be redriven\n*                                     |\n     case other                       | Unknown date format:\n      l     r15,cpl_date_format       |  Point to format address\n      l     r15,0(,r15)               |  Load format into R15\n      errexit code=&dt_invalid_date_format Return error to caller.\n    endcase                           |\n   endloop until,(treg,r15,z)         |\n  endblk                              |\n  drop  r4                            |\n         space 1                      |\n endblk                               |\n         title \"Drive Input Interval Routines\"\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Call_Convert_Input_Interval\n*  Abstract:   This routine will call the appropriate input interval\n*              formatting routines based on the caller's request. This\n*              routine is called from the main case block, as well\n*              as from other internal routines.\n*  Inputs:     On entry, R1 points to the following parameter list:\n*                +0 -- Internal format date/time doubleword\n*                +4 -- Place to get interval value to convert\n*                +8 -- Format for input interval value\n*                +C -- Unused\n*               +10 -- Unused\n*                  (This parameter list is known as a \"converter para-\n*                  meter list\", or \"CPL\", and is common to all of the\n*                  date and time format conversion subroutines.)\n*  Outputs:    Appropriate routine(s) called\n*  Special\n*  Notes:      . As new input formatting routines are coded, add add'l\n*                CASE statements and setup code to this subroutine.\n*              . This routine only saves R14.  The routines that it\n*                calls are responsible for handling their own regs.\n*\n*---------------------------------------------------------------------*\n         space 1                      |\n block name=Call_Convert_Input_Interval,type=subroutine,               *\n               options=(*nosubopts),                                   *\n               save=(r14,pwa_call_convert_r14)\n         space 1                      |\n  lr    r4,r1                         |\n  using cpl,r4                        |\n  l     r15,cpl_internal              | Zero out internal-format time\n  xc    0(8,r15),0(r15)               |  / date doubleword.\n  fill  pwa_flags,x'00',length=l_flags\n* *-------------------------------------------------------------------*\n* * Set up for interval conversion routines.  This allows less\n* * duplication of code in the actual converter routines.\n* *-------------------------------------------------------------------*\n  block name=input_interval_conversion\n   fill  pwa_flags,x'00',length=(l_flags)\n   l32   r14,cpl_interval             | See if interval provided\n   errexit (z),code=&dt_invalid_input_interval   It better be there\n   l32   r14,cpl_interval_format      | Point to input inteval format\n   errexit (z),code=&dt_invalid_interval_format  It better be there\n   l     r14,0(,r14)                  | Get the format\n*  *------------------------------------------------------------------*\n*  * Normal setup for interval format processing.\n*  *------------------------------------------------------------------*\n   caseblk  reg=r14                   |\n    case &dt_delta                    |\n     sbit  pwa_interval_flags,pwa_delta      dd:hh:mm:ss.th format\n    case &dt_days                     |\n     sbit  pwa_day_flags,pwa_days     |\n    case &dt_pdays                    |\n     sbit  pwa_day_flags,pwa_pdays    |\n    case &dt_idays                    |\n     sbit  pwa_day_flags,pwa_idays    |\n    case &dt_hours                    |\n     sbit  pwa_hour_flags,pwa_hours   |\n    case &dt_phours                   |\n     sbit  pwa_hour_flags,pwa_phours  |\n    case &dt_ihours                   |\n     sbit  pwa_hour_flags,pwa_ihours  |\n    case &dt_minutes                  |\n     sbit  pwa_minute_flags,pwa_minutes\n    case &dt_pminutes                 |\n     sbit  pwa_minute_flags,pwa_pminutes\n    case &dt_iminutes                 |\n     sbit  pwa_minute_flags,pwa_iminutes\n    case &dt_seconds                  |\n     sbit  pwa_second_flags,pwa_seconds\n    case &dt_pseconds                 |\n     sbit  pwa_second_flags,pwa_pseconds\n    case &dt_iseconds                 |\n     sbit  pwa_second_flags,pwa_iseconds\n    case &dt_hundredths               |\n     sbit  pwa_interval_flags,pwa_hundredths\n    case &dt_phundredths              |\n     sbit  pwa_interval_flags,pwa_phundredths\n    case &dt_ihundredths              |\n     sbit  pwa_interval_flags,pwa_ihundredths\n    case &dt_todclock                 |                             @cy\n     sbit  pwa_interval_flags,pwa_todclock                          @cy\n    case other                        |\n   endcase                            |\n*  *------------------------------------------------------------------*\n*  * Call requested interval conversion routine.\n*  *------------------------------------------------------------------*\n   l32   r14,cpl_interval_format      | Get addr of interval format\n   l     r14,0(,r14)                  | Get format in R14.\n   caseblk  reg=r14                   | Set up and call format routine:\n    case       &dt_hundredths,&dt_phundredths,&dt_ihundredths,         *\n               &dt_hours,&dt_phours,&dt_ihours,                        *\n               &dt_minutes,&dt_pminutes,&dt_iminutes,                  *\n               &dt_seconds,&dt_pseconds,&dt_iseconds,                  *\n               &dt_days,&dt_pdays,&dt_idays\n     callsub Convert_Integer_Interval_To_Internal\n    case &dt_delta                    |\n     callsub Convert_Delta_Interval_To_Internal\n    case &dt_todclock                 |                             @cy\n     l     r1,cpl_interval            | Get the TODclock interval value\n     lm    r14,r15,0(r1)              |  high-order word\n     if    (treg,r14,m)               | Is it negative?\n      lcr   r14,r14                   |  Flip it\n      lcr   r15,r15                   |  Flip it\n      if    (cc3)                     |  Overflow from lo-order word?\n       la    r14,1(,r14)              |   Need to carry a bit to hi.\n      endif                           |\n      stm   r14,r15,0(r1)             |  and put it back\n*                                     |  (where cnvt_from_tod wants it)\n      sbit  pwaf1rev                  |    and note sign was reversed.\n     endif                            |\n*>>>>callsub Convert_Time_From_TODclock Don't do this, see comments @cy\n*    *----------------------------------------------------------------*\n*    * The usual TOD input routine adds the TOD's base time (1/1/1970)\n*    * to the value you send it.  Since all we want is the interval,\n*    * we want to skip that.  With that out of the way, converting a\n*    * TOD value to DT's internal format is just a doubleword shift,\n*    * so instead of a separate routine, we just do it inline here.\n*    *----------------------------------------------------------------*\n     l     r15,cpl_interval           | Get address of TOD value\n     lm    r14,r15,0(r15)             | Get TOD-clock value\n     srdl  r14,12                     | Convert to microseconds\n     l     r1,cpl_internal            | Get ptr to internal fmt answer\n     stm   r14,r15,0(r1)              | Save results\n*                                     |\n    case other                        | Unknown time format:\n     l     r15,cpl_interval_format    |  Point to format address\n     l     r15,0(,r15)                |  Load format into R15\n     errexit code=&dt_invalid_interval_format Return error to caller.\n   endcase                            |\n  endblk                              |\n endblk                               |\n title \"Drive Output Format Routines\" |\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Call_Convert_Output\n*  Abstract:   This routine will call the appropriate output date and\n*              time formatting routines based on the caller's request.\n*              This routine is called from the main case block, as well\n*              as from other internal routines.\n*  Inputs:     On entry, R1 points to the following parameter list:\n*                +0 -- Internal format date/time doubleword\n*                +4 -- Place to store converted date value\n*                +8 -- Format for converted date value\n*                +C -- Place to store converted time value\n*               +10 -- Format for converted time value\n*                  (This parameter list is known as a \"converter para-\n*                  meter list\", or \"CPL\", and is common to all of the\n*                  date and time format conversion subroutines.)\n*  Outputs:    Appropriate routine(s) called\n*  Special\n*  Notes:      . As new output formatting routines are coded, add add'l\n*                CASE statements and setup code to this subroutine.\n*              . This routine only saves R14.  The routines that it\n*                calls are responsible for handling their own regs.\n*\n*---------------------------------------------------------------------*\n         space 1                      |\n block name=Call_Convert_Output,type=subroutine,                       *\n               options=(*nosubopts),                                   *\n               save=(r14,pwa_call_convert_r14)\n         space 1                      |\n  lr    r4,r1                         | Copy CPL base.  Note that R1\n  using cpl,r4                        | should be preserved into the\n*                                     | CASEBLK, since the CPL can be\n*                                     | passed to the converter rtns.\n*                                     | with fewer instructions.\n  fill  pwa_flags,x'00',length=l_flags\n* *-------------------------------------------------------------------*\n* * Set up for time conversion routines.  This allows less duplication\n* * of code in the actual converter routines.\n* *-------------------------------------------------------------------*\n  block name=output_time_conversion   |\n   mvi   pwa_hhmmss_flags,x'00'       |\n*  *------------------------------------------------------------------*\n*  * Special case: If either date or time are requested in DT_ES_Format\n*  * or DT_TODclock format, call one convert routine to handle both and\n*  * quit. This eliminates a subroutine call during output conversion.\n*  *------------------------------------------------------------------*\n   l32   r14,cpl_date_format          |\n   if    (nz)                         |\n    l     r14,0(,r14)                 |\n    if    (c,r14,eq,=a(&dt_es_format))\n     callsub Convert_Date_To_ES_Format  Call combined converter\n     leave block=Call_Convert_Output  |    and exit input conversion.\n    endif                             |\n   endif                              |\n*                                     |\n   l32   r14,cpl_time                 |\n   leave block=*,(z)                  | No time, go on to dates.\n   l32   r14,cpl_time_format          |\n   errexit (z),code=&dt_invalid_time_format  No format, go choke.\n   l     r14,0(,r14)                  | Get the format\n   if    (c,r14,eq,=a(&dt_todclock))  | If caller wants TODCLOCK\n    callsub  Convert_Time_To_TODclock |     Call combined converter\n    leave block=Call_Convert_Output   |      and exit input conversion.\n   elseif (c,r14,eq,=a(&dt_seconds_since_1970))\n    callsub Convert_Time_To_SecondsSince1970\n    leave block=Call_Convert_Output   |\n   endif                              |\n*  *------------------------------------------------------------------*\n   l32   r14,cpl_time_format          | Point to input time format\n   l     r14,0(,r14)                  | Get the format value for CASEs\n*  *------------------------------------------------------------------*\n*  * Normal setup for time conversion.\n*  *------------------------------------------------------------------*\n   caseblk  reg=r14                   |\n    case &dt_hhmm                     |\n     sbit  pwa_hhmmss_flags,pwa_hhmm  |\n    case &dt_hhmmss                   |\n     sbit  pwa_hhmmss_flags,pwa_hhmmss\n    case &dt_hhmmssth                 |\n     sbit  pwa_hhmmss_flags,pwa_hhmmssth\n    case &dt_civilian                 |\n     sbit  pwa_hhmmss_flags,pwa_civilian\n    case &dt_hours\n     sbit  pwa_hour_flags,pwa_hours\n    case &dt_phours\n     sbit  pwa_hour_flags,pwa_phours\n    case &dt_ihours\n     sbit  pwa_hour_flags,pwa_ihours\n    case &dt_minutes\n     sbit  pwa_minute_flags,pwa_minutes\n    case &dt_pminutes\n     sbit  pwa_minute_flags,pwa_pminutes\n    case &dt_iminutes\n     sbit  pwa_minute_flags,pwa_iminutes\n    case &dt_seconds\n     sbit  pwa_second_flags,pwa_seconds\n    case &dt_pseconds\n     sbit  pwa_second_flags,pwa_pseconds\n    case &dt_iseconds\n     sbit  pwa_second_flags,pwa_iseconds\n    case &dt_unspecified              |\n     leave block=Output_Time_Conversion\n    case other                        |\n   endcase                            |\n   eject ,                            |\n*  *------------------------------------------------------------------*\n*  * Call requested time conversion routine.  Note that some of these\n*  * routines may issue a LEAVE when completed, since they handle the\n*  * date conversion as well.\n*  *------------------------------------------------------------------*\n   l32   r14,cpl_time_format          | Get addr of output time format\n   l     r14,0(,r14)                  |  Get format in R14.\n   caseblk  reg=r14                   | Set up and call format routine:\n    case &dt_Hundredths,&dt_es_format | .01-secs since midnight\n     callsub Convert_Time_To_Hundredths\n*   case &dt_es_format                | Environment Support format\n*    callsub Convert_Date_To_ES_Format\n*    leave   block=*                  |  (Get out: routine does both.)\n    case &dt_hhmm,&dt_hhmmss,&dt_hhmmssth,&dt_civilian,                *\n               &dt_hours,&dt_phours,&dt_ihours,                        *\n               &dt_minutes,&dt_pminutes,&dt_iminutes,                  *\n               &dt_seconds,&dt_pseconds,&dt_iseconds\n     callsub Convert_Time_To_HHMMSS   |\n*                                     |\n    case other                        | Unknown time format:\n     l     r15,cpl_time_format        |  Point to format address\n     l     r15,0(,r15)                |  Load format into R15\n     errexit code=&dt_invalid_time_format Return error to caller.\n   endcase                            |\n  endblk                              |\n         eject                        |\n* *-------------------------------------------------------------------*\n* *  Set up for date conversion routines. This allows less duplication\n* *  of code in the converter routines themselves.\n* *-------------------------------------------------------------------*\n  block name=output_date_conversion   |\n   fill  pwa_flags,x'00',length=(l_flags)\n   l32   r14,cpl_date                 |\n   leave block=*,(z)                  | No time present: exit.\n   l32   r14,cpl_date_format          |\n   errexit (z),name=&dt_invalid_date_format\n   l     r14,0(,r14)                  |\n   caseblk  reg=r14                   | Set up for converter routines:\n    case &dt_julian                   |\n     sbit  pwa_julian_flags,pwa_julian\n    case &dt_juliand                  |\n     sbit  pwa_julian_flags,pwa_juliand\n    case &dt_pjulian,&dt_es_format    |\n     sbit  pwa_julian_flags,pwa_pjulian\n    case &dt_ijulian                  |\n     sbit  pwa_julian_flags,pwa_ijulian\n    case &dt_sjulian                  |\n     sbit  pwa_julian_flags,pwa_sjulian\n    case &dt_sjuliand                 |\n     sbit  pwa_julian_flags,pwa_sjuliand\n    case &dt_gregorian                |\n     sbit  pwa_gregorian_flags,pwa_gregorian\n    case &dt_sgregorian               |\n     sbit  pwa_gregorian_flags,pwa_sgregorian\n    case &dt_normal                   |\n     sbit  pwa_normal_flags,pwa_normal\n    case &dt_snormal                  |\n     sbit  pwa_normal_flags,pwa_snormal\n    case &dt_sasdate7                 |\n     sbit  pwa_normal_flags,pwa_sasdate7\n    case &dt_sasdate9                 |\n     sbit  pwa_normal_flags,pwa_sasdate9\n    case &dt_yyyymmmdd                |                             @cx\n     sbit  pwa_normal_flags,pwa_yyyymmmdd                           @cx\n    case &dt_text                     |\n     sbit  pwa_text_flags,pwa_text    |\n    case &dt_textd                    |\n     sbit  pwa_text_flags,pwa_textd   |\n    case &dt_weekday                  |\n     sbit  pwa_text_flags,pwa_weekday |\n    case &dt_weekday3                 |\n     sbit pwa_text_flags,pwa_weekday3 |\n    case &dt_sortdate                 |\n     sbit  pwa_gregorian_flags,pwa_sortdate\n    case &dt_ssortdate                |\n     sbit  pwa_gregorian_flags,pwa_ssortdate\n    case &dt_days                     |\n     sbit  pwa_day_flags,pwa_days     |\n    case &dt_pdays                    |\n     sbit  pwa_day_flags,pwa_pdays    |\n    case &dt_idays                    |\n     sbit  pwa_day_flags,pwa_idays    |\n    case &dt_month                    |\n     sbit  pwa_month_flags,pwa_month  |\n    case &dt_pmonth                   |\n     sbit  pwa_month_flags,pwa_pmonth |\n    case &dt_imonth                   |\n     sbit  pwa_month_flags,pwa_imonth |\n    case &dt_monthname                |\n     sbit  pwa_month_flags,pwa_monthname\n    case &dt_monthname3               |\n     sbit  pwa_month_flags,pwa_monthname3\n    case &dt_year                     |\n     sbit  pwa_year_flags,pwa_year    |\n    case &dt_year2                    |\n     sbit  pwa_year_flags,pwa_year2   |\n    case &dt_pyear                    |\n     sbit  pwa_year_flags,pwa_pyear   |\n    case &dt_iyear                    |\n     sbit  pwa_year_flags,pwa_iyear   |\n    case &dt_unspecified              |\n     leave block=Output_Date_Conversion\n    case  other                       |\n   endcase                            |\n   eject ,                            |\n*  *------------------------------------------------------------------*\n*  * Call requested date conversion routine.\n*  *------------------------------------------------------------------*\n   lr    r1,r4                        | Restore CPL address in R1\n   l32   r14,cpl_date_format          |\n   l     r14,0(,r14)                  |\n   caseblk  reg=r14                   | Set up and call format routine:\n    case &dt_ijulian,&dt_pjulian,&dt_julian,&dt_juliand,               *\n               &dt_sjulian,&dt_sjuliand,&dt_es_format\n     callsub Convert_Date_To_Julian   | Various Julian dates\n    case &dt_gregorian,&dt_sgregorian,                                 *\n               &dt_sortdate,&dt_ssortdate\n     callsub Convert_Date_To_Gregorian  Gregorian, Sortdate formats\n    case &dt_normal,&dt_snormal,      |                                *\n               &dt_sasdate7,&dt_sasdate9,                              *\n               &dt_yyyymmmdd                                        @cx\n     callsub Convert_Date_To_Normal   | Normal format (01 Oct 1989)\n    case &dt_text,&dt_textd,          |                                *\n               &dt_weekday,&dt_weekday3\n     callsub Convert_Date_To_Text     | Text (October 1, 1989)\n    case &dt_number_of_days           | No. of days since 1/1/0000\n     callsub Convert_Date_To_Number   |\n    case &dt_days,&dt_pdays,&dt_idays |\n     callsub Convert_Date_To_Days     |\n    case &dt_month,&dt_pmonth,&dt_imonth,                              *\n               &dt_monthname,&dt_monthname3\n     callsub Convert_Date_To_Months   |\n    case &dt_year,&dt_year2,&dt_pyear,&dt_iyear\n     callsub Convert_Date_To_Years    |\n*                                     |\n    case other                        | Unknown date format:\n     l     r15,cpl_date_format        |  Point to format address\n     l     r15,0(,r15)                |  Load format into R15\n     errexit code=&dt_invalid_date_format Return error to caller.\n   endcase                            |\n  endblk                              |\n  drop  r4                            |\n         space 1                      |\n endblk                               |\n         title \"Drive Output Interval Routines\"\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Call_Convert_Output_Interval\n*  Abstract:   This routine will call the appropriate output interval\n*              formatting routines based on the caller's request. This\n*              routine is called from the main case block, as well\n*              as from other internal routines.\n*  Inputs:     On entry, R1 points to the following parameter list:\n*                +0 -- Internal format date/time doubleword\n*                +4 -- Place to get interval value to convert\n*                +8 -- Format for input interval value\n*                +C -- Unused\n*               +10 -- Unused\n*                  (This parameter list is known as a \"converter para-\n*                  meter list\", or \"CPL\", and is common to all of the\n*                  date and time format conversion subroutines.)\n*  Outputs:    Appropriate routine(s) called\n*  Special\n*  Notes:      . As new output formatting routines are coded, add add'l\n*                CASE statements and setup code to this subroutine.\n*              . This routine only saves R14.  The routines that it\n*                calls are responsible for handling their own regs.\n*\n*---------------------------------------------------------------------*\n         space 1                      |\n block name=Call_Convert_Output_Interval,type=subroutine,              *\n               options=(*nosubopts),                                   *\n               save=(r14,pwa_call_convert_r14)\n         space 1                      |\n  lr    r4,r1                         |\n  using cpl,r4                        |\n  fill  pwa_flags,x'00',length=l_flags\n* *-------------------------------------------------------------------*\n* * Set up for time conversion routines.  This allows less duplication\n* * of code in the actual converter routines.\n* *-------------------------------------------------------------------*\n  block name=output_interval_conversion\n   fill  pwa_flags,x'00',length=(l_flags)\n   l32   r14,cpl_interval             | See if interval was provided\n   errexit (z),code=&dt_invalid_input_interval    It better be there\n   l32   r14,cpl_interval_format      | Point to input inteval format\n   errexit (z),code=&dt_invalid_interval_format   It better be there\n   l     r14,0(,r14)                  | Get the format\n*  *------------------------------------------------------------------*\n*  * Normal setup for interval format processing.\n*  *------------------------------------------------------------------*\n   caseblk  reg=r14                   |\n    case &dt_delta                    |\n     sbit  pwa_interval_flags,pwa_delta      dd:hh:mm:ss.th format\n    case &dt_days                     |\n     sbit  pwa_day_flags,pwa_days     |\n    case &dt_pdays                    |\n     sbit  pwa_day_flags,pwa_pdays    |\n    case &dt_idays                    |\n     sbit  pwa_day_flags,pwa_idays    |\n    case &dt_hours                    |\n     sbit  pwa_hour_flags,pwa_hours   |\n    case &dt_phours                   |\n     sbit  pwa_hour_flags,pwa_phours  |\n    case &dt_ihours                   |\n     sbit  pwa_hour_flags,pwa_ihours  |\n    case &dt_minutes                  |\n     sbit  pwa_minute_flags,pwa_minutes\n    case &dt_pminutes                 |\n     sbit  pwa_minute_flags,pwa_pminutes\n    case &dt_iminutes                 |\n     sbit  pwa_minute_flags,pwa_iminutes\n    case &dt_seconds                  |\n     sbit  pwa_second_flags,pwa_seconds\n    case &dt_pseconds                 |\n     sbit  pwa_second_flags,pwa_pseconds\n    case &dt_iseconds                 |\n     sbit  pwa_second_flags,pwa_iseconds\n    case &dt_hundredths               |\n     sbit  pwa_interval_flags,pwa_hundredths\n    case &dt_phundredths              |\n     sbit  pwa_interval_flags,pwa_phundredths\n    case &dt_ihundredths              |\n     sbit  pwa_interval_flags,pwa_ihundredths\n    case &dt_todclock                 |\n     sbit  pwa_interval_flags,pwa_todclock\n    case other                        |\n   endcase                            |\n*  *------------------------------------------------------------------*\n*  * Call requested interval conversion routine.\n*  *------------------------------------------------------------------*\n   l32   r14,cpl_interval_format      | Get addr of interval format\n   l     r14,0(,r14)                  |  Get format in R14.\n   caseblk  reg=r14                   | Set up and call format routine:\n    case       &dt_hundredths,&dt_phundredths,&dt_ihundredths,         *\n               &dt_hours,&dt_phours,&dt_ihours,                        *\n               &dt_minutes,&dt_pminutes,&dt_iminutes,                  *\n               &dt_seconds,&dt_pseconds,&dt_iseconds,                  *\n               &dt_days,&dt_pdays,&dt_idays\n     callsub Convert_Internal_To_Integer_Interval\n    case &dt_delta                    |\n     callsub Convert_Internal_To_Delta_Interval\n    case &dt_todclock                 |                             @cy\n     callsub Convert_Time_To_Todclock |                             @cy\n*                                     |\n    case other                        | Unknown time format:\n     l     r15,cpl_interval_format    |  Point to format address\n     l     r15,0(,r15)                |  Load format into R15\n     errexit code=&dt_invalid_interval_format Return error to caller.\n   endcase                            |\n  endblk                              |\n endblk                               |\n title \"Convert Environment Support Format To Internal Format\"\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Convert_Date_From_ES_Format\n*  Abstract:   This routine converts a date and time from the format\n*              returned by ES_Get_Time (see below) to a doubleword\n*              number of microseconds since Jan. 1, 0000.\n*  Inputs:     On entry, R1 points to a converter parameter list.\n*  Outputs:    Doubleword at (parmlist+8%) filled in\n*  Special     This routine was adapted from a routine provided in\n*  Notes:      Dave Crow's presentation \"Setting A Computer's Clock\n*              Correctly\" at SHARE 67 in Atlanta.\n*\n*---------------------------------------------------------------------*\n         space 1                      |\n block name=Convert_Date_From_ES_Format,type=subroutine\n  lr    r4,r1                         |\n  using cpl,r4                        |\n  l32   r2,cpl_date                   | Point to input date\n  if    (nz)                          |\n   Convert_Juldate_To_Days Juldate=0(4,r2),                            *\n               Work=pwa_d,            |                                *\n               Days=R1                |\n   Convert_Days_To_DT_Units reg=R0    |\n  endif                               |\n  l     r15,4(,r2)                    | Get time in .01-seconds\n  m     r14,=a(10000)                 | Make it microseconds\n* *-------------------------------------------------------------------*\n* * Perform doubleword integer add.\n* *-------------------------------------------------------------------*\n  ar    r0,r14                        | Add-logical upper half\n  alr   r1,r15                        | Add-logical lower half\n  if    not,(cc12)                    | If overflow in low half\n   ah    r0,=h'1'                     |  carry a 1 to high 4 bytes.\n  endif                               |\n  l     r15,cpl_internal              | Point to place to put result\n  stm   r0,r1,0(r15)                  | Save result for caller\n  drop  r4                            |\n endblk rc=0                          | Return to caller\n title \"Convert Internal Format To Environment Support Format\"\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Convert_Date_To_ES_Format\n*  Abstract:   This routine converts an internal DT-format time into\n*              a yyyy.ddd date and .01-sec-from-midnight time.\n*  Inputs:     On entry, R1 points to a converter parameter list.\n*  Outputs:    Environment Support format date and time filled in\n*  Special     Adapted from routine provided in Dave Crow's talk at\n*  Notes:        Share 67, Atlanta (O317 Setting A Computer's Clock\n*                Correctly)\n*\n*---------------------------------------------------------------------*\n         space 1                      |\n block name=Convert_Date_To_ES_Format,type=subroutine\n  lr    r4,r1                         |\n  using cpl,r4                        |\n  l     r15,cpl_internal              |\n  Convert_DT_Units_To_Days  Reg=R0,   |                                *\n               Units=0(r15)           |\n*                                     | R1 is now # days since 1/1/0000\n  lr    r2,r0                         | Save remainder (microseconds)\n  l     r3,4(,r15)                    | Get lo-order half of msec stamp\n  sll   r3,(32-13)                    | Shift mics to hi end of r3\n  srdl  r2,(32-13)                    | Shift both back\n  d     r2,=a(10000)                  | Make into .01-sec units\n  l     r2,cpl_date                   | Point to date/time return area\n  st    r3,4(,r2)                     | Return the time at +4\n  Convert_Days_To_Juldate  Days=R1,   | Return the date at +0          *\n               Work=pwa_d,            |                                *\n               Juldate=0(,r2)         |\n  drop  r4                            |\n endblk rc=0                          |\n title \"Convert Hundredths Format Time To Internal Format\"\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Convert_Time_From_Hundredths\n*  Abstract:   This routine adds the integer .01-second units to the\n*              internal-format time value.\n*  Inputs:     On entry, R1 points to a converter parameter list.\n*  Outputs:    Hundredths format date and time filled in\n*  Special     Adapted from routine provided in Dave Crow's talk at\n*  Notes:        Share 67, Atlanta (O317 Setting A Computer's Clock\n*                Correctly)\n*\n*---------------------------------------------------------------------*\n         space 1                      |\n block name=Convert_Time_From_Hundredths,type=subroutine\n  lr    r4,r1                         |\n  using cpl,r4                        |\n  l32   r15,cpl_time                  | Get time in .01-seconds\n  if    (nz)                          |\n   l     r15,0(,r15)                  | Get the value\n   m     r14,=a(10000)                | Make it microseconds\n  endif                               |\n* *-------------------------------------------------------------------*\n* * Add time to existing (if any) internal-format time.\n* *-------------------------------------------------------------------*\n  l     r1,cpl_internal               | Get addr of internal-fmt time\n  lm    r0,r1,0(r1)                   | Get the value in a reg pair\n  ar    r0,r14                        | Add-logical upper half\n  alr   r1,r15                        | Add-logical lower half\n  if    not,(cc12)                    | If overflow in low half\n   ah    r0,=h'1'                     |  carry a 1 to high 4 bytes.\n  endif                               |\n  l     r15,cpl_internal              | Point to place to put result\n  stm   r0,r1,0(r15)                  | Save result for caller\n  drop  r4                            |\n endblk rc=0                          |\n title \"Convert Internal Format To Hundredths Format\"\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Convert_Time_To_Hundredths\n*  Abstract:   This routine converts an internal DT-format time into\n*              a .01-sec-from-midnight time.\n*  Inputs:     On entry, R1 points to a converter parameter list.\n*  Outputs:    Hundredths-format time filled in\n*  Special     Adapted from routine provided in Dave Crow's talk at\n*  Notes:        Share 67, Atlanta (O317 Setting A Computer's Clock\n*                Correctly)\n*\n*---------------------------------------------------------------------*\n         space 1                      |\n block name=Convert_Time_To_Hundredths,type=subroutine\n  lr    r4,r1                         |\n  using cpl,r4                        |\n  l     r15,cpl_internal              |\n  Convert_DT_Units_To_Days  Reg=R0,   | We want remainder in R0        *\n               Units=0(r15)           |\n*                                     | R1 is now # days since 1/1/0000\n  lr    r2,r0                         | Save remainder (microseconds)\n  l     r3,4(,r15)                    | Get lo-order half of msec stamp\n  sll   r3,(32-13)                    | Shift mics to hi end of r3\n  srdl  r2,(32-13)                    | Shift both back\n  d     r2,=a(10000)                  | Make into .01-sec units\n  l     r15,cpl_time                  | Point to time dest. field\n  st    r3,0(,r15)                    |  and save into time area.\n  drop  r4                            |\n endblk rc=0                          |\n title \"Convert TODclock Format Time To Internal Format\"\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Convert_Time_From_TODclock\n*  Abstract:   This routine converts a S/370 time-of-day clock value\n*              to the internal-format date and time value.\n*  Inputs:     On entry, R1 points to a converter parameter list.\n*  Outputs:    TODclock format date and time filled in\n*  Special     Adapted from routine provided in Dave Crow's talk at\n*  Notes:        Share 67, Atlanta (O317 Setting A Computer's Clock\n*                Correctly)\n*\n*---------------------------------------------------------------------*\n         space 1                      |\n block name=Convert_Time_From_TODclock,type=subroutine\n  lr    r4,r1                         |\n  using cpl,r4                        |\n  l     r15,cpl_time                  | Get address of TOD value\n  lm    r14,r15,0(r15)                | Get TOD-clock value\n  srdl  r14,12                        | Convert to microseconds\n  lm    r0,r1,psd_mics_lower_limit      Get TOD's true begin date\n  alr   r1,r15                        | Perform doubelword add\n  if    not,(cc12)                    |\n   ah    r0,=h'1'                     |\n  endif                               |\n  ar    r0,r14                        |\n  l     r15,cpl_internal              |\n  stm   r0,r1,0(r15)                  |\n  drop  r4                            |\n endblk rc=0                          |\n title \"Convert Internal Format To TODclock Format\"\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Convert_Time_To_TODclock\n*  Abstract:   This routine converts an internal DT-format date and\n*              time value into a S/370 time-of-day clock value.\n*  Inputs:     On entry, R1 points to a converter parameter list.\n*  Outputs:    TODclock-format time filled in\n*  Special     Adapted from routine provided in Dave Crow's talk at\n*  Notes:        Share 67, Atlanta (O317 Setting A Computer's Clock\n*                Correctly)\n*\n*---------------------------------------------------------------------*\n         space 1                      |\n block name=Convert_Time_To_TODclock,type=subroutine\n  lr    r4,r1                         |\n  using cpl,r4                        |\n  l     r15,cpl_internal              |\n  errexit      (clc,0(8,r15),lt,psd_mics_lower_limit),or,              *\n               (clc,0(8,r15),gt,psd_mics_upper_limit),                 *\n               code=&dt_out_of_range  |\n  lm    r0,r1,0(r15)                  |   Get internal-format stamp\n  lm    r14,r15,psd_mics_lower_limit      Get equiv. TOD zero value\n  slr   r1,r15                        |   Convert\n  if    (cc12)                        |\n   sh    r0,=h'1'                     |\n  endif                               |\n  sr    r0,r14                        |\n  sldl  r0,12                         | Shift microsecs to bit 51\n  l     r15,cpl_time                  |\n  stm   r0,r1,0(r15)                  |\n  drop  r4                            |\n endblk rc=0                          |\n title \"Convert Julian Format Time To Internal Format\"\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Convert_Date_From_Julian\n*  Abstract:   This routine converts various formats of Julian date to\n*              the internal format.  The following types of Julian date\n*              are presently supported:\n*                .. &DT_Julian   (ex. C'1989351')\n*                .. &DT_Juliand  (ex. C'1989.351')\n*                .. &DT_Ijulian  (ex. F'1989351')\n*                .. &DT_Pjulian  (ex. P'1989351')\n*                .. &DT_Sjulian  (ex. C'89351')\n*                .. &DT_Sjuliand (ex. C'89.351')\n*  Inputs:     On entry, R1 points to a converter parameter list.\n*  Outputs:    Julian format date converted to internal format.\n*  Notes:      Only R14 is saved and restored.\n*              Options=*NoSubOpts removed due to size constraints\n*\n*---------------------------------------------------------------------*\n         space 1                      |\n block name=Convert_Date_From_Julian,type=subroutine\n  lr    r4,r1                         |\n  using cpl,r4                        |\n  l32   r3,cpl_date                   | Get date in .01-seconds\n* *-------------------------------------------------------------------*\n* * Look at pwa_julian_flags and perform appropriate conversion.\n* * (Pjulian format does not need special attention.)\n* *-------------------------------------------------------------------*\n  if     (tbit,pwa_julian_flags,pwa_ijulian)\n*  *------------------------------------------------------------------*\n*  * Ijulian date.  Convert to decimal.\n*  *------------------------------------------------------------------*\n   l     r15,0(,r3)                   |\n   cvd   r15,pwa_d                    |\n   mvc   pwa_f,pwa_d+4                |\n*   *-----------------------------------------------------------------*\n*   * Pjulian date.  Ensure packed-decimal, then copy to workarea.\n*   *-----------------------------------------------------------------*\n  elseif (tbit,pwa_julian_flags,pwa_pjulian)\n   Validate_Packed_Data Data=0(r3),Len=4,Type=DATE\n   mvc   pwa_f,0(r3)                  |\n  else                                |\n   if    (tbit,pwa_julian_flags,pwa_julian)\n*   *----------------------------------------------------------------*\n*   * Julian date.  Validity-check, then pack into workarea.\n*   *----------------------------------------------------------------*\n    callsub validate_julian_formats   |\n    errexit (treg,r15,nz),code=&dt_invalid_input_date\n    mvc   pwa_d(7),0(r3)              |\n   elseif (tbit,pwa_julian_flags,pwa_sjulian)\n*   *----------------------------------------------------------------*\n*   * Sjulian date.  Validity-check, then pack into workarea.\n*   *----------------------------------------------------------------*\n    callsub validate_julian_formats   |\n    errexit (treg,r15,nz),code=&dt_invalid_input_date\n    mvc   pwa_d(2),psd_default_century\n    mvc   pwa_d+2(5),0(r3)            |\n         eject ,\n   elseif (tbit,pwa_julian_flags,pwa_juliand)\n*   *----------------------------------------------------------------*\n*   * Juliand date.  Validity-check, then pack into workarea.\n*   *----------------------------------------------------------------*\n    callsub validate_julian_formats   |\n    errexit (treg,r15,nz),code=&dt_invalid_input_date\n    mvc   pwa_d(4),0(r3)              |  Move the years\n    mvc   pwa_d+4(3),5(r3)            |  Append the days\n   elseif (tbit,pwa_julian_flags,pwa_sjuliand)\n*   *-----------------------------------------------------------------*\n*   * Sjuliand date.  Validity-check, then pack into workarea.\n*   *-----------------------------------------------------------------*\n    callsub validate_julian_formats   |\n    errexit (treg,r15,nz),code=&dt_invalid_input_date\n    mvc   pwa_d(2),psd_default_century\n    mvc   pwa_d+2(2),0(r3)            |\n    mvc   pwa_d+4(3),3(r3)            |\n   endif                              |\n   pack   pwa_f(4),pwa_d(7)           |\n  endif                               |\n  if    (cp,pwa_f,ne,=p'0')           | If date isn't zero\n   Convert_Juldate_To_Days Juldate=pwa_f,  Convert it,                 *\n               Work=pwa_d,            |                                *\n               Days=R1                |\n  else                                |\n   xr    r1,r1                        | else force a zero.\n  endif                               |\n  Convert_Days_To_DT_Units reg=R0     |\n* *-------------------------------------------------------------------*\n* * Add date to existing (if any) internal-format time.\n* *-------------------------------------------------------------------*\n  l     r15,cpl_internal              | Get addr of internal-fmt time\n  lm    r14,r15,0(r15)                | Get the value in a reg pair\n  ar    r0,r14                        | Add-logical upper half\n  alr   r1,r15                        | Add-logical lower half\n  if    not,(cc12)                    | If overflow in low half\n   ah    r0,=h'1'                     |  carry a 1 to high 4 bytes.\n  endif                               |\n  l     r15,cpl_internal              | Point to place to put result\n  stm   r0,r1,0(r15)                  | Save result for caller\n  drop  r4                            |\n endblk rc=0                          |\n title \"Convert Internal Format To Julian Format Date\"\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Convert_Date_To_Julian\n*  Abstract:   This routine converts an internal-format date to various\n*              Julian date formats.  The following types of Julian date\n*              are presently supported:\n*                .. &DT_Julian   (ex. C'1989351')\n*                .. &DT_Juliand  (ex. C'1989.351')\n*                .. &DT_Ijulian  (ex. F'1989351')\n*                .. &DT_Pjulian  (ex. P'1989351')\n*  Inputs:     On entry, R1 points to a converter parameter list.\n*  Outputs:    Julian format date filled in\n*  Special     Adapted from routine provided in Dave Crow's talk at\n*  Notes:        Share 67, Atlanta (O317 Setting A Computer's Clock\n*                Correctly)\n*              Only R14 is saved and restored. R15-R4 are destroyed.\n*\n*---------------------------------------------------------------------*\n         space 1                      |\n block name=Convert_Date_To_Julian,type=subroutine,                    *\n               options=(*nosubopts),                                   *\n               save=(r14,pwa_converter_r14)\n  lr    r4,r1                         |\n  using cpl,r4                        |\n  l     r15,cpl_internal              |\n  Convert_DT_Units_To_Days  Reg=R0,   |                                *\n               Units=0(r15)           |\n*                                     | R1 is now # days since 1/1/0000\n  Convert_Days_To_Juldate  Days=R1,   |                                *\n               Work=pwa_d,            |                                *\n               Juldate=pwa_f          |\n* *-------------------------------------------------------------------*\n* * Look at pwa_julian_flags and perform appropriate conversion.\n* *-------------------------------------------------------------------*\n  l     r2,cpl_date                   | Point to result area\n  if    (tbit,pwa_julian_flags,pwa_ijulian)\n*  *------------------------------------------------------------------*\n*  * Perform Ijulian conversion.\n*  *------------------------------------------------------------------*\n   zap   pwa_d,pwa_f                  |\n   cvb   r1,pwa_d                     |\n   st    r1,0(,r2)                    |\n  elseif (tbit,pwa_julian_flags,pwa_pjulian)\n*  *------------------------------------------------------------------*\n*  * Perform Pjulian conversion.\n*  *------------------------------------------------------------------*\n   mvc   0(4,r2),pwa_f                |\n  elseif (tbit,pwa_julian_flags,pwa_julian)\n*  *------------------------------------------------------------------*\n*  * Perform Julian conversion.\n*  *------------------------------------------------------------------*\n   mvc   pwa_edit(8),=x'4021202020202020'\n   ed    pwa_edit(8),pwa_f            |\n   mvc   0(7,r2),pwa_edit+1           |\n   oi    0(r2),x'f0'                  |\n        eject ,\n  elseif (tbit,pwa_julian_flags,pwa_sjulian)\n*  *------------------------------------------------------------------*\n*  * Perform Sjulian conversion.\n*  *------------------------------------------------------------------*\n   mvc   pwa_edit(6),=x'402120202020' |\n   ed    pwa_edit(6),pwa_f+1          |\n   mvc   0(5,r2),pwa_edit+1           |\n   oi    0(r2),x'f0'                  |\n  elseif (tbit,pwa_julian_flags,pwa_juliand)\n*  *------------------------------------------------------------------*\n*  * Perform Juliand conversion.\n*  *------------------------------------------------------------------*\n   mvc   pwa_edit(9),=x'40212020204b202020'\n   ed    pwa_edit(9),pwa_f            |\n   mvc   0(8,r2),pwa_edit+1           |\n   oi    0(r2),x'f0'                  |\n  elseif (tbit,pwa_julian_flags,pwa_sjuliand)\n*  *------------------------------------------------------------------*\n*  * Perform Sjuliand conversion.\n*  *------------------------------------------------------------------*\n   mvc   pwa_edit(7),=x'4021204b202020'\n   ed    pwa_edit(7),pwa_f+1          |\n   mvc   0(6,r2),pwa_edit+1           |\n   oi    0(r2),x'f0'                  |\n  endif                               |\n  drop  r4                            |\n endblk rc=0                          |\n title \"Convert Gregorian Format Time To Internal Format\"\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Convert_Date_From_Gregorian\n*  Abstract:   This routine converts an American (mm/dd/yyyy) or an\n*              English (dd/mm/yyyy) format Gregorian date to the\n*              internal format.  It also converts the Sortdate and\n*              short Sortdate formats.\n*  Inputs:     On entry, R1 points to a converter parameter list.\n*  Outputs:    Gregorian format date converted to internal format.\n*  Notes:      Only R14 is saved and restored. R15-R4 are destroyed.\n*\n*---------------------------------------------------------------------*\n         space 1                      |\n block name=Convert_Date_From_Gregorian,type=subroutine,               *\n               options=(*nosubopts),                                   *\n               save=(r14,pwa_converter_r14)\n  lr    r4,r1                         |\n  using cpl,r4                        |\n  callsub validate_gregorian_formats  |\n  errexit (treg,r15,nz),code=&dt_invalid_input_date\n*---------------------------------------------------------------------*\n*  Extract months and days.\n*---------------------------------------------------------------------*\n  pack  pwa_d,pwa_numeric_year        | Pack years,\n  cvb  r1,pwa_d                       | Convert year to integer.\n  st   r1,pwa_i_year                  |\n  pack  pwa_d,pwa_numeric_month       | Pack months,\n  cvb  r1,pwa_d                       | Convert month to integer.\n  st   r1,pwa_i_month                 |\n  pack  pwa_d,pwa_numeric_day         | Pack days,\n  cvb  r1,pwa_d                       | Convert day to integer.\n  st   r1,pwa_i_day                   |\n  callsub Convert_Gregorian_To_Days,  |                                *\n               (pwa_i_month,pwa_i_day,pwa_i_year,pwa_number_of_days),  *\n               novl                   |\n  l     r1,pwa_number_of_days         |\n  Convert_Days_To_DT_Units  reg=r0    |\n  l     r15,cpl_internal              |\n  lm    r14,r15,0(r15)                | Get the value in a reg pair\n  ar    r0,r14                        | Add-logical upper half\n  alr   r1,r15                        | Add-logical lower half\n  if    not,(cc12)                    | If overflow in low half\n   ah    r0,=h'1'                     |  carry a 1 to high 4 bytes.\n  endif                               |\n  l     r15,cpl_internal              | Point to place to put result\n  stm   r0,r1,0(r15)                  | Save result for caller\n  drop  r4                            |\n endblk rc=0                          |\n title \"Convert Internal Format Time To Gregorian Date\"\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Convert_Date_To_Gregorian\n*  Abstract:   This routine will convert the internal-format timestamp\n*              to a Gregorian format.  The following are supported:\n*              .. &DT_Gregorian  -- C'mm/dd/yyyy'  or  C'dd/mm/yyyy'\n*              .. &DT_Sgregorian -- C'mm/dd/yy'    or  C'dd/mm/yy'\n*              .. &DT_Sortdate   -- C'yyyy-mm-dd'\n*              .. &DT_Ssortdate  -- C'yy-mm-dd'\n*  Inputs:     On entry, R1 points to a converter parameter list.\n*  Outputs:    Internal format date converted to Gregorian format.\n*  Notes:      Only R14 is saved and restored. R15-R4 are destroyed.\n*\n*---------------------------------------------------------------------*\n         space 1                      |\n block name=Convert_Date_To_Gregorian,type=subroutine,                 *\n               options=(*nosubopts),                                   *\n               save=(r14,pwa_converter_r14)\n  lr    r4,r1                         |\n  using cpl,r4                        |\n  l     r15,cpl_internal              |\n  Convert_DT_Units_To_Days  Units=0(r15),Reg=R0\n  st    r1,pwa_number_of_days         |\n  callsub Convert_Days_To_Gregorian,  |                                *\n               (pwa_i_month,pwa_i_day,pwa_i_year,pwa_number_of_days)\n  l    r1,pwa_i_year                  |\n  cvd  r1,pwa_d                       | Convert years to packed,\n  mvc  pwa_edit(6),=xl6'402120202020' | then edit and save result.\n  ed   pwa_edit(6),pwa_d+5            |\n  mvc  pwa_numeric_year,pwa_edit+2    |\n  l    r1,pwa_i_day                   |\n  cvd  r1,pwa_d                       | Convert days to packed,\n  mvc  pwa_edit(6),=xl6'402120202020' | then edit and save result.\n  ed   pwa_edit(6),pwa_d+5            |\n  mvc  pwa_numeric_day,pwa_edit+4     |\n  l    r1,pwa_i_month                 |\n  cvd  r1,pwa_d                       | Convert months to packed,\n  mvc  pwa_edit(6),=xl6'402120202020' | then edit and save result.\n  ed   pwa_edit(6),pwa_d+5            |\n  mvc  pwa_numeric_month,pwa_edit+4   |\n  l     r15,cpl_date                  |\n  if  not,(tbit,pwa_gregorian_flags,(pwa_gregorian+pwa_sgregorian),off)\n   mvi   2(r15),c'/'                  |\n   mvi   5(r15),c'/'                  |\n   if    (tbit,pwa_gregorian_flags,pwa_gregorian)\n    mvc   6(4,r15),pwa_numeric_year   |\n   elseif (tbit,pwa_gregorian_flags,pwa_sgregorian)\n    mvc   6(2,r15),pwa_numeric_year+2 |\n   endif                              |\n   if    (tbit,pwaf1eur)              |\n    mvc   0(2,r15),pwa_numeric_day    |\n    mvc   3(2,r15),pwa_numeric_month  |\n   else                               |\n    mvc   0(2,r15),pwa_numeric_month  |\n    mvc   3(2,r15),pwa_numeric_day    |\n   endif                              |\n  elseif (tbit,pwa_gregorian_flags,pwa_sortdate)\n   mvc   0(4,r15),pwa_numeric_year    |\n   mvi   4(r15),c'-'                  |\n   mvc   5(2,r15),pwa_numeric_month   |\n   mvi   7(r15),c'-'                  |\n   mvc   8(2,r15),pwa_numeric_day     |\n  elseif (tbit,pwa_gregorian_flags,pwa_ssortdate)\n   mvc   0(2,r15),pwa_numeric_year+2  |\n   mvi   2(r15),c'-'                  |\n   mvc   3(2,r15),pwa_numeric_month   |\n   mvi   5(r15),c'-'                  |\n   mvc   6(2,r15),pwa_numeric_day     |\n  endif                               |\n  drop  r4                            |\n endblk rc=0                          |\n title \"Convert Number_Of_Days Format To Internal Format\"\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Convert_Date_From_Number\n*  Abstract:   This routine converts an input number of days since Jan.\n*              1, 0000 to internal format.\n*  Inputs:     On entry, R1 points to a converter parameter list.\n*  Outputs:    Number of days converted to internal format.\n*  Notes:      Only R14 is saved and restored. R15-R4 are destroyed.\n*\n*---------------------------------------------------------------------*\n         space 1                      |\n block name=Convert_Date_From_Number,type=subroutine,                  *\n               options=(*nosubopts),                                   *\n               save=(r14,pwa_converter_r14)\n  lr    r4,r1                         |\n  using cpl,r4                        |\n  l     r1,cpl_date                   |\n  l     r1,0(,r1)                     |\n  Convert_Days_To_DT_Units  reg=r0    |\n  l     r15,cpl_internal              |\n  lm    r14,r15,0(r15)                | Get the value in a reg pair\n  ar    r0,r14                        | Add-logical upper half\n  alr   r1,r15                        | Add-logical lower half\n  if    not,(cc12)                    | If overflow in low half\n   ah    r0,=h'1'                     |  carry a 1 to high 4 bytes.\n  endif                               |\n  l     r15,cpl_internal              | Point to place to put result\n  stm   r0,r1,0(r15)                  | Save result for caller\n  drop  r4                            |\n endblk rc=0                          |\n title \"Convert Internal Format Date To Number Of Days\"\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Convert_Date_To_Number\n*  Abstract:   This routine will convert the internal-format timestamp\n*              to the number of days since Jan. 1, 0000.\n*  Inputs:     On entry, R1 points to a converter parameter list.\n*  Outputs:    Internal format date converted to number-of-days format.\n*  Notes:      Only R14 is saved and restored. R15-R4 are destroyed.\n*\n*---------------------------------------------------------------------*\n         space 1                      |\n block name=Convert_Date_To_Number,type=subroutine,                    *\n               options=(*nosubopts),                                   *\n               save=(r14,pwa_converter_r14)\n  lr    r4,r1                         |\n  using cpl,r4                        |\n  l     r15,cpl_internal              |\n  Convert_DT_Units_To_Days  Units=0(r15),Reg=R0\n  l     r15,cpl_date                  |\n  st    r1,0(,r15)                    |\n  drop  r4                            |\n endblk rc=0                          |\n title \"Convert Normal Format Time To Internal Format\"\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Convert_Date_From_Normal\n*  Abstract:   This routine converts a normal-format date to the inter-\n*              format.  The following are supported:\n*              .. &DT_Normal   -- C\"dd mmm yyyy\"\n*              .. &DT_Snormal  -- C\"dd mmm yy\"\n*  Inputs:     On entry, R1 points to a converter parameter list.\n*  Outputs:    Normal format date converted to internal format.\n*  Notes:      Only R14 is saved and restored. R15-R4 are destroyed.\n*\n*---------------------------------------------------------------------*\n         space 1                      |\n block name=Convert_Date_From_Normal,type=subroutine,                  *\n               options=(*nosubopts),                                   *\n               save=(r14,pwa_converter_r14)\n  lr    r4,r1                         |\n  using cpl,r4                        |\n  callsub validate_normal_formats     | Validate, fill in PWA values\n  errexit (treg,r15,nz),code=&dt_invalid_input_date\n  callsub Convert_Gregorian_To_Days,  |                                *\n               (pwa_i_month,pwa_i_day,pwa_i_year,pwa_number_of_days),  *\n               novl                   |\n  l     r1,pwa_number_of_days         |\n  Convert_Days_To_DT_Units  reg=r0    |\n  l     r15,cpl_internal              |\n  lm    r14,r15,0(r15)                | Get the value in a reg pair\n  ar    r0,r14                        | Add-logical upper half\n  alr   r1,r15                        | Add-logical lower half\n  if    not,(cc12)                    | If overflow in low half\n   ah    r0,=h'1'                     |  carry a 1 to high 4 bytes.\n  endif                               |\n  l     r15,cpl_internal              | Point to place to put result\n  stm   r0,r1,0(r15)                  |\n  drop  r4                            |\n endblk rc=0                          |\n title \"Convert Internal Format Time To Normal Date\"\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Convert_Date_To_Normal\n*  Abstract:   This routine converts an internal format timestamp to\n*              'normal' format.  The following are supported:\n*              .. &DT_Normal   -- C\"dd mmm yyyy\"\n*              .. &DT_Snormal  -- C\"dd mmm yy\"\n*              .. &DT_Sasdate9 -- C\"ddmmmyyyy\"\n*              .. &DT_Sasdate7 -- C\"ddmmmyy\"\n*              .. &DT_yyyymmmdd -- C\"yyyymmmdd\"\n*  Inputs:     On entry, R1 points to a converter parameter list.\n*  Outputs:    Internal format date converted to normal format.\n*  Notes:      Only R14 is saved and restored. R15-R4 are destroyed.\n*\n*---------------------------------------------------------------------*\n         space 1                      |\n block name=Convert_Date_To_Normal,type=subroutine,                    *\n               options=(*nosubopts),                                   *\n               save=(r14,pwa_converter_r14)\n  lr    r4,r1                         |\n  using cpl,r4                        |\n  l     r15,cpl_internal              |\n  Convert_DT_Units_To_Days  Units=0(r15),Reg=R0\n  st    r1,pwa_number_of_days         |\n  callsub Convert_Days_To_Gregorian,  |                                *\n               (pwa_i_month,pwa_i_day,pwa_i_year,pwa_number_of_days),  *\n               novl                   |\n  l     r1,pwa_i_year                 |\n  cvd   r1,pwa_d                      | Convert years to packed,\n  mvc   pwa_edit(6),=x'402120202020'  |  then edit and save result.\n  ed    pwa_edit(6),pwa_d+5           |\n  mvc   pwa_numeric_year,pwa_edit+2   |\n  l     r1,pwa_i_day                  | Convert days to packed,\n  cvd   r1,pwa_d                      |  then edit and save result.\n  mvc   pwa_edit(4),=xl4'40212020'    |\n  ed    pwa_edit(4),pwa_d+6           |\n  mvc   pwa_numeric_day,pwa_edit+2    |\n  l     r0,pwa_i_month                | Look up month:\n  la    r14,psd_month_table           |\n  using month_table,r14               |\n  fill  pwa_text_month,c' '           |\n  la    r15,mt_#_entries              |\n  loop  bct                           |\n   leave loop=*,(ch,r0,eq,mt_month_num)\n   la    r14,mt_length(,r14)          |\n  endloop bct,r15                     |\n  mvc  pwa_text_month(3),mt_month_name\n  drop  r14                           |\n  l     r2,cpl_date                   |\n  if    (tbit,pwa_normal_flags,pwa_normal)  Build normal format date\n   fill  0(r2),c' ',length=11         |\n   mvc   0(2,r2),pwa_numeric_day      |\n   mvc   3(3,r2),pwa_text_month       |\n   mvc   7(4,r2),pwa_numeric_year     |\n  elseif (tbit,pwa_normal_flags,pwa_snormal)  Build short-normal date\n   fill  0(r2),c' ',length=9          |\n   mvc   0(2,r2),pwa_numeric_day      |\n   mvc   3(3,r2),pwa_text_month       |\n   mvc   7(2,r2),pwa_numeric_year+2   |\n  elseif (tbit,pwa_normal_flags,pwa_sasdate7)  Build SAS DATE7. date\n   mvc   0(2,r2),pwa_numeric_day      |\n   mvc   2(3,r2),pwa_text_month       |\n   mvc   5(2,r2),pwa_numeric_year+2   |\n  elseif (tbit,pwa_normal_flags,pwa_sasdate9)  Build SAS DATE9. date\n   mvc   0(2,r2),pwa_numeric_day      |\n   mvc   2(3,r2),pwa_text_month       |\n   mvc   5(4,r2),pwa_numeric_year     |\n  elseif (tbit,pwa_normal_flags,pwa_yyyymmmdd) Build YYYYMMMDD date @cx\n   mvc   0(4,r2),pwa_numeric_year     |                             @cx\n   mvc   4(3,r2),pwa_text_month       |                             @cx\n   mvc   7(2,r2),pwa_numeric_day      |                             @cx\n  endif                               |\n  drop  r4                            |\n endblk rc=0                          |\n title \"Convert Date From General_Input Format To Internal Format\"\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Convert_Date_From_General_Input\n*  Abstract:   This routine determines if the input date value is\n*              a recognized format: if so, it is converted to the\n*              internal format.\n*  Inputs:     On entry, R1 points to a converter parameter list.\n*  Outputs:    Date converted and added to internal format date/time.\n*  Special\n*  Notes:      None.\n*\n*---------------------------------------------------------------------*\n         space 1                      |\n block name=Convert_Date_From_General_Input,                           *\n               type=subroutine        |\n  lr    r5,r1                         | Save incoming CPL address\n  plist (*,*,*,*,*),novl              | Build partial CPL for\n  mvc   0(20,r1),0(r5)                |\n  lr    r4,r1                         |  validation routines\n  using cpl,r4                        | Save CPL ptr, base on it\n* *-------------------------------------------------------------------*\n* *  Date validation calls.\n* *-------------------------------------------------------------------*\n  block name=date_validation          |\n   l     r15,cpl_date                 |\n   l32   r1,0(r15)                    |\n   if    z                            | Leave if date absent. Note that\n    xr    r15,r15                     |  this causes the code after the\n    leave block=*                     |   next ENDBLK to do the right\n   endif                              |    thing if DATE wasn't coded.\n   lr    r1,r4                        |\n*  *----------------------------------------------------------------*\n*  *  Julian date validation first.\n*  *----------------------------------------------------------------*\n   mvi   pwa_julian_flags,pwa_julian  | Tell validate rtn what to do\n   callsub validate_julian_formats    | Check it out\n   if    (treg,r15,z)                 | If it was OK\n    la    r1,&dt_julian               |  return format to caller.\n    leave block=*                     |\n   endif                              |\n*  *----------------------------------------------------------------*\n   lr    r1,r4                        |\n   mvi   pwa_julian_flags,pwa_juliand |\n   callsub validate_julian_formats    |\n   if    (treg,r15,z)                 |\n    la    r1,&dt_juliand              |\n    leave block=*                     |\n   endif                              |\n*  *----------------------------------------------------------------*\n   lr    r1,r4                        |\n   mvi   pwa_julian_flags,pwa_sjulian |\n   callsub validate_julian_formats    |\n   if    (treg,r15,z)                 |\n    la    r1,&dt_sjulian              |\n    leave block=*                     |\n   endif                              |\n*  *------------------------------------------------------------------*\n   lr    r1,r4                        |\n   mvi   pwa_julian_flags,pwa_sjuliand\n   callsub validate_julian_formats    |\n   if    (treg,r15,z)                 |\n    la    r1,&dt_sjuliand             |\n    leave block=*                     |\n   endif                              |\n*  *------------------------------------------------------------------*\n*  *  Gregorian date validation.\n*  *------------------------------------------------------------------*\n   lr    r1,r4                        |\n   mvi   pwa_gregorian_flags,pwa_gregorian\n   callsub validate_gregorian_formats |\n   if    (treg,r15,z)                 |\n    la    r1,&dt_gregorian            |\n    leave block=*                     |\n   endif                              |\n*  *----------------------------------------------------------------*\n   lr    r1,r4                        |\n   mvi   pwa_gregorian_flags,pwa_sgregorian\n   callsub validate_gregorian_formats |\n   if    (treg,r15,z)                 |\n    la    r1,&dt_sgregorian           |\n    leave block=*                     |\n   endif                              |\n*  *----------------------------------------------------------------*\n*  *  Normal date validation.\n*  *----------------------------------------------------------------*\n   lr    r1,r4                        |\n   mvi   pwa_normal_flags,pwa_normal  |\n   callsub validate_normal_formats    |\n   if    (treg,r15,z)                 |\n    la    r1,&dt_normal               |\n    leave block=*                     |\n   endif                              |\n*  *------------------------------------------------------------------*\n   lr    r1,r4                        |\n   mvi   pwa_normal_flags,pwa_snormal |\n   callsub validate_normal_formats    |\n   if    (treg,r15,z)                 |\n    la    r1,&dt_snormal              |\n    leave block=*                     |\n   endif                              |\n*  *------------------------------------------------------------------*\n   lr    r1,r4                        |\n   mvi   pwa_normal_flags,pwa_sasdate9\n   callsub validate_normal_formats    |\n   if    (treg,r15,z)                 |\n    la    r1,&dt_sasdate9             |\n    leave block=*                     |\n   endif                              |\n*  *------------------------------------------------------------------*\n   lr    r1,r4                        |\n   mvi   pwa_normal_flags,pwa_sasdate7\n   callsub validate_normal_formats    |\n   if    (treg,r15,z)                 |\n    la    r1,&dt_sasdate7             |\n    leave block=*                     |\n   endif                              |\n*  *------------------------------------------------------------------*\n   lr    r1,r4                        |                             @cx\n   mvi   pwa_normal_flags,pwa_yyyymmmdd                             @cx\n   callsub validate_normal_formats    |                             @cx\n   if    (treg,r15,z)                 |                             @cx\n    la    r1,&dt_yyyymmmdd            |                             @cx\n    leave block=*                     |                             @cx\n   endif                              |                             @cx\n*  *------------------------------------------------------------------*\n*  *  Text date validation.\n*  *------------------------------------------------------------------*\n   lr    r1,r4                        |\n   mvi   pwa_text_flags,pwa_text      |\n   callsub validate_text_formats      |\n   if    (treg,r15,z)                 |\n    la    r1,&dt_text                 |\n    leave block=*                     |\n   endif                              |\n*  *------------------------------------------------------------------*\n   lr    r1,r4                        |\n   mvi   pwa_text_flags,pwa_textd     |\n   callsub validate_text_formats      |\n   if    (treg,r15,z)                 |\n    la    r1,&dt_textd                |\n    leave block=*                     |\n   endif                              |\n*  *------------------------------------------------------------------*\n*  *  Sortdate format validation.\n*  *------------------------------------------------------------------*\n   lr    r1,r4                        |\n   mvi   pwa_gregorian_flags,pwa_sortdate\n   callsub validate_gregorian_formats |\n   if    (treg,r15,z)                 |\n    la    r1,&dt_sortdate             |\n    leave block=*                     |\n   endif                              |\n*  *----------------------------------------------------------------*\n   lr    r1,r4                        |\n   mvi   pwa_gregorian_flags,pwa_ssortdate\n   callsub validate_gregorian_formats |\n   if    (treg,r15,z)                 |\n    la    r1,&dt_ssortdate            |\n    leave block=*                     |\n   endif                              |\n*  *----------------------------------------------------------------*\n  endblk                              |\n  if    (treg,r15,z)                  | If returncode is zero\n   leave block=*,(treg,r1,z)          |  Leave if no input (this OK?)\n   st    r1,pwa_actual_format         |  Save format we found\n   la    r1,pwa_actual_format         |  Point to it\n   st    r1,cpl_date_format-cpl(,r5)  |  Change the original format\n  else                                | Otherwise (all tests failed)\n   errexit code=&dt_invalid_input_date    Return 'unknown format'.\n  endif                               |\n endblk rc=(r15)                      | Just leave.  This will cause\n*                                     | the caseblock loop in Call_\n*                                     | Convert_Input to redrive the\n*                                     | conversion routines.\n title \"Convert Time From General_Input Format To Internal Format\"\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Convert_Time_From_General_Input\n*  Abstract:   This routine determines if the input time value is\n*              a recognized format: if so, it is converted to the\n*              internal format.\n*  Inputs:     On entry, R1 points to a converter parameter list.\n*  Outputs:    Date converted and added to internal format date/time.\n*  Special\n*  Notes:      None.\n*\n*---------------------------------------------------------------------*\n         space 1                      |\n block name=Convert_Time_From_General_Input,                           *\n               type=subroutine        |\n  lr    r5,r1                         | Save incoming CPL address\n  plist (*,*,*,*,*),novl              | Build partial CPL for\n  mvc   0(20,r1),0(r5)                |\n  lr    r4,r1                         |  validation routines\n  using cpl,r4                        | Save CPL ptr, base on it\n* *-------------------------------------------------------------------*\n* *  Time validation calls.\n* *-------------------------------------------------------------------*\n  block name=time_validation          |\n*  *------------------------------------------------------------------*\n*  *  HHMMSS date validation first.\n*  *------------------------------------------------------------------*\n   lr    r1,r4                        |\n   mvi   pwa_hhmmss_flags,pwa_hhmmssth\n   callsub validate_hhmmss_formats    |\n   if    (treg,r15,z)                 |\n    la    r1,&dt_hhmmssth             |\n    leave block=*                     |\n   endif                              |\n*  *------------------------------------------------------------------*\n   lr    r1,r4                        |\n   mvi   pwa_hhmmss_flags,pwa_civilian\n   callsub validate_hhmmss_formats    |\n   if    (treg,r15,z)                 |\n    la    r1,&dt_civilian             |\n    leave block=*                     |\n   endif                              |\n*  *------------------------------------------------------------------*\n   lr    r1,r4                        |\n   mvi   pwa_hhmmss_flags,pwa_hhmmss  |\n   callsub validate_hhmmss_formats    |\n   if    (treg,r15,z)                 |\n    la    r1,&dt_hhmmss               |\n    leave block=*                     |\n   endif                              |\n*  *------------------------------------------------------------------*\n   lr    r1,r4                        |\n   mvi   pwa_hhmmss_flags,pwa_hhmm    |\n   callsub validate_hhmmss_formats    |\n   if    (treg,r15,z)                 |\n    la    r1,&dt_hhmm                 |\n    leave block=*                     |\n   endif                              |\n*  *------------------------------------------------------------------*\n  endblk                              |\n  drop  r4                            |\n  if    (treg,r15,z)                  | If returncode is zero\n   leave block=*,(treg,r1,z)          |  Leave if no input (this OK?)\n   st    r1,pwa_actual_format         |\n   la    r1,pwa_actual_format         |\n   st    r1,cpl_time_format-cpl(,r5)  |  Get address of original format\n  else                                | Otherwise (all tests failed)\n   errexit code=&dt_invalid_input_time    Return 'unknown format'.\n  endif                               |\n endblk rc=(r15)                      | Just leave.  This will cause\n title \"Convert Time From HH:MM:SS.TH Format To Internal Format\"\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Convert_Time_From_HHMMSS\n*  Abstract:   This routine converts anm input time of the format\n*              hh:mm:ss.th or hh:mm:ss:th to the internal format.\n*  Inputs:     On entry, R1 points to a converter parameter list.\n*  Outputs:    Time converted and added to internal format time.\n*  Special\n*  Notes:      This subroutine only saves R14. It destroys R0, R1, R2\n*              and R15.\n*---------------------------------------------------------------------*\n         space 1                      |\n block name=Convert_Time_From_HHMMSS,type=subroutine,                  *\n               options=(*nosubopts),                                   *\n               save=(r14,pwa_converter_r14)\n  lr   r4,r1                          |\n  using cpl,r4                        |\n  callsub validate_HHMMSS_formats     |\n  errexit (treg,r15,nz),code=&dt_invalid_input_time\n  l    r15,cpl_time                   |\n* *-------------------------------------------------------------------*\n* * Reduce time as requested to .01-second units, then add to the\n* * internal-format time pointed to by the CPL.\n* *-------------------------------------------------------------------*\n  pack  pwa_d,0(2,r15)                | Pack the hours\n  cvb   r0,pwa_d                      | Convert to integer in R0\n  mh    r0,=h'60'                     | Turn into minutes\n  pack  pwa_d,3(2,r15)                | Pack the minutes\n  cvb   r1,pwa_d                      | Change to integer in R1\n  ar    r0,r1                         | Add to accumulated minutes\n  mh    r0,=h'60'                     | Turn accum. into seconds\n  if    (tbit,pwa_hhmmss_flags,pwa_hhmm,off)  If seconds present\n   pack  pwa_d,6(2,r15)               | Pack the seconds\n   cvb   r1,pwa_d                     | Change to integer in R1\n   ar    r0,r1                        | Add to accumulated seconds\n  endif                               |\n  mh    r0,=h'100'                    | Turn accum. into .01-seconds\n  if    (tbit,pwa_hhmmss_flags,pwa_hhmmssth)\n   pack  pwa_d,9(2,r15)               | Pack the hundredths\n   cvb   r1,pwa_d                     | Change to integer in R1\n   ar    r0,r1                        | Add to accum'd .01-seconds\n  endif                               |\n  if    (tbit,pwa_hhmmss_flags,pwa_civilian),and,  If civilian time    *\n               (clc,=c' PM',eq,8(r15)),and,         and it's afternoon *\n               (clc,=c'12',ne,0(r15)) |              and past 12:00\n   a     r0,=f'4320000'               | Add 1/2 day of .01-sec units\n  endif                               |\n  lr    r1,r0                         |\n  m     r0,=f'10000'                  |\n  l     r2,cpl_internal               |\n  lm    r14,r15,0(r2)                 |\n  ar    r0,r14                        | Add-logical upper half\n  alr   r1,r15                        | Add-logical lower half\n  if    not,(cc12)                    | If overflow in low half\n   ah    r0,=h'1'                     |  carry a 1 to high 4 bytes.\n  endif                               |\n  stm    r0,r1,0(r2)                  | Save result for caller\n  drop  r4                            |\n endblk rc=0                          |\n title \"Convert Time From Internal Format To HH:MM:SS:TH Format\"\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Convert_Time_To_HHMMSS\n*  Abstract:   This routine converts the internal-format time to\n*              hh:mm:ss.th format.  This routine also handles the\n*              following variations:\n*              . &DT_HHMM     -- hh:mm format\n*              . &DT_HHMMSS   -- hh:mm:ss format\n*              . &DT_CIVILIAN -- hh:mm:ss AM/PM format\n*              . &DT_HOURS,&DT_PHOURS,&DT_IHOURS\n*              . &DT_MINUTES,&DT_PMINUTES,&DT_IMINUTES\n*              . &DT_SECONDS,&DT_PSECONDS,&DT_ISECONDS\n*  Inputs:     On entry, R1 points to a converter parameter list.\n*  Outputs:    Time converted to requested format.\n*  Special\n*  Notes:      This subroutine only saves R14. It destroys R0, R1, R2\n*              and R15.\n*\n*---------------------------------------------------------------------*\n         space 1                      |\n block name=Convert_Time_To_HHMMSS,type=subroutine,                    *\n               options=(*nosubopts),                                   *\n               save=(r14,pwa_converter_r14)\n  lr    r4,r1                         |\n  using cpl,r4                        |\n  l     r15,cpl_internal              |\n  Convert_DT_Units_To_Days  Reg=R0,   | We want remainder in R0        *\n               Units=0(r15)           |\n*                                     | R1 is now # days since 1/1/0000\n  lr    r2,r0                         | Save remainder (microseconds)\n  l     r3,4(,r15)                    | Get lo-order half of msec stamp\n  sll   r3,(32-13)                    | Shift mics to hi end of r3\n  srdl  r2,(32-13)                    | Shift both back\n  d     r2,=a(10000)                  | Make into .01-sec units in R3.\n  lr    r1,r3                         |\n  xr    r0,r0                         | Clear R0 for division\n  la    r15,100                       | Get mod(.01-secs / 100)\n  dr    r0,r15                        | Quotient (R1) = seconds,\n  cvd   r0,pwa_d                      | remainder (R0) = hundredths.\n  mvc   pwa_edit(4),=x'40212020'      |\n  ed    pwa_edit(4),pwa_d+6           |\n  mvc   pwa_numeric_hundredths,pwa_edit+2\n  xr    r0,r0                         | Clear R0 for division\n  la    r15,60                        | Get mod(seconds/60)\n  dr    r0,r15                        | Quotient (R1) = minutes,\n  cvd   r0,pwa_d                      | remainder (R0) = seconds.\n  mvc   pwa_edit(4),=x'40212020'      |\n  ed    pwa_edit(4),pwa_d+6           |\n  mvc   pwa_numeric_second,pwa_edit+2 |\n* *-------------------------------------------------------------------*\n* * If partial \"seconds\" format requested, return it now and get out.\n* *-------------------------------------------------------------------*\n  if   (cli,pwa_second_flags,ne,x'00')\n   l     r15,cpl_time                 |\n   if    (tbit,pwa_second_flags,pwa_iseconds)\n    sth   r0,0(r15)                   |\n   elseif (tbit,pwa_second_flags,pwa_pseconds)\n    mvc   0(2,r15),pwa_d+6            |\n   elseif (tbit,pwa_second_flags,pwa_seconds)\n    mvc   0(2,r15),pwa_numeric_second |\n   endif                              |\n   leave block=*                      |\n  endif                               |\n* *-------------------------------------------------------------------*\n* *  Produce minutes and hours.\n* *-------------------------------------------------------------------*\n  xr    r0,r0                         | Clear R0 for division\n  la    r15,60                        | Get mod(minutes/60)\n  dr    r0,r15                        | Quotient (R1) = hours\n  cvd   r0,pwa_d                      | remainder (R0) = minutes.\n  mvc   pwa_edit(4),=x'40212020'      |\n  ed    pwa_edit(4),pwa_d+6           |\n  mvc   pwa_numeric_minute,pwa_edit+2 |\n* *-------------------------------------------------------------------*\n* * If partial \"minutes\" format requested, return it now and get out.\n* *-------------------------------------------------------------------*\n  if   (cli,pwa_minute_flags,ne,x'00')\n   l     r15,cpl_time                 |\n   if    (tbit,pwa_minute_flags,pwa_iminutes)\n    sth   r0,0(r15)                   |\n   elseif (tbit,pwa_minute_flags,pwa_pminutes)\n    mvc   0(2,r15),pwa_d+6            |\n   elseif (tbit,pwa_minute_flags,pwa_minutes)\n    mvc   0(2,r15),pwa_numeric_minute |\n   endif                              |\n   leave block=*                      |\n  endif                               |\n* *-------------------------------------------------------------------*\n  cvd   r1,pwa_d                      | Convert quotient to hours\n  if    (tbit,pwaf1lz)                |\n   mvc   pwa_edit(4),=x'40212020'     |    (w/ leading zeros)\n  else                                |\n   mvc   pwa_edit(4),=x'40202120'     |    (w/o leading zeros)\n  endif                               |\n  ed    pwa_edit(4),pwa_d+6           |\n  mvc   pwa_numeric_hour,pwa_edit+2   |\n* *-------------------------------------------------------------------*\n* * If partial \"hours\" format requested, return it now and get out.\n* *-------------------------------------------------------------------*\n  if   (cli,pwa_hour_flags,ne,x'00')   |\n   l     r15,cpl_time                 |\n   if    (tbit,pwa_hour_flags,pwa_ihours)\n    sth   r1,0(r15)                   |\n   elseif (tbit,pwa_hour_flags,pwa_phours)\n    mvc   0(2,r15),pwa_d+6            |\n   elseif (tbit,pwa_hour_flags,pwa_hours)\n    mvc   0(2,r15),pwa_numeric_hour   |\n   endif                              |\n   leave block=*                      |\n  endif                               |\n* *-------------------------------------------------------------------*\n* * Process \"full\" output time formats.\n* *-------------------------------------------------------------------*\n  if    (tbit,pwa_hhmmss_flags,pwa_civilian) If civilian time requested\n   mvc   pwa_civilian_hour,pwa_numeric_hour  Default to 'normal' hours\n   if    (ch,r1,ge,=h'12')            |      If hours are at least 12\n    sbit  pwa_hhmmss_flags,pwa_afternoon  Note we need to say PM later\n    if    (ch,r1,gt,=h'12')           |   If more than 12 ...\n     lr    r0,r1                      |\n     sh    r0,=h'12'                  |    Knock 12 off hours\n     cvd   r0,pwa_d                   |    Pack, edit, etc.\n     if    (tbit,pwaf1lz)             |\n      mvc   pwa_edit(4),=x'40212020'  |     (w/ leading zeros)\n     else                             |\n      mvc   pwa_edit(4),=x'40202120'  |     (w/o leading zeros)\n     endif                            |\n     ed    pwa_edit(4),pwa_d+6        |\n     mvc   pwa_civilian_hour,pwa_edit+2    and save civilian_hour.\n    endif                             |\n   endif                              |\n  endif                               |\n  l     r15,cpl_time                  | Start building formatted time\n  if    (tbit,pwa_hhmmss_flags,pwa_civilian) If civilian time requested\n   mvc   0(2,r15),pwa_civilian_hour   |  Move whatever's in civ. hour\n  else                                | Otherwise\n   mvc   0(2,r15),pwa_numeric_hour    |  Move normal hour.\n  endif                               |\n  mvi   2(r15),c':'                   | Append a \":\"\n  mvc   3(2,r15),pwa_numeric_minute   | Add on the minutes\n  if    not,(tbit,pwa_hhmmss_flags,pwa_hhmm) If we want more than hh:mm\n   mvi   5(r15),c':'                  |  Append a \":\"\n   mvc   6(2,r15),pwa_numeric_second  |  Add on the seconds\n   if    (tbit,pwa_hhmmss_flags,pwa_hhmmssth)  If we want .01-secs\n    mvi   8(r15),c'.'                 |   Append a \".\"\n    mvc   9(2,r15),pwa_numeric_hundredths  and hang the hundredths on\n   elseif (tbit,pwa_hhmmss_flags,pwa_civilian)  Elseif we want civ.time\n    if    (tbit,pwa_hhmmss_flags,pwa_afternoon)  If it's PM\n     mvc   8(3,r15),=c' PM'           |           say so,\n    else                              |          otherwise\n     mvc   8(3,r15),=c' AM'           |           it's AM.\n    endif                             |\n   endif                              |\n  endif                               |\n  drop  r4                            |\n endblk rc=0                          |\n title \"Convert Time From Seconds since 1970 Format To Internal Format\"\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Convert_Time_From_SecondsSince1970\n*  Abstract:   This routine converts an input time of the format\n*              #seconds since Jan 1, 1970, 00:00:00.0 to internal.\n*  Inputs:     On entry, R1 points to a converter parameter list.\n*  Outputs:    Time converted and added to internal format time.\n*  Special\n*  Notes:      This subroutine only saves R14. It destroys R0, R1, R2\n*              and R15.\n*---------------------------------------------------------------------*\n         space 1                      |\n block name=Convert_Time_From_SecondsSince1970,type=subroutine,        *\n               options=(*nosubopts),                                   *\n               save=(r14,pwa_converter_r14)\n  lr    r4,r1                         |\n  using cpl,r4                        |\n  l32   r15,cpl_time                  | Get time in SecsSince1970 fmt.\n  if    (nz)                          |\n   l     r15,0(,r15)                  | Get the value\n   m     r14,=f'1000000'              | Make it microseconds\n  endif                               |\n  lm    r0,r1,psd_mics_circa_1970     | Get value for start of 1970.\n  alr   r15,r1                        | Perform doubelword add\n  if    not,(cc12)                    |\n   ah    r14,=h'1'                    |\n  endif                               |\n  ar    r14,r0                        |\n* *-------------------------------------------------------------------*\n* * Add time to existing (if any) internal-format time.\n* *-------------------------------------------------------------------*\n  l     r1,cpl_internal               | Get addr of internal-fmt time\n  lm    r0,r1,0(r1)                   | Get the value in a reg pair\n  ar    r0,r14                        | Add-logical upper half\n  alr   r1,r15                        | Add-logical lower half\n  if    not,(cc12)                    | If overflow in low half\n   ah    r0,=h'1'                     |  carry a 1 to high 4 bytes.\n  endif                               |\n  l     r15,cpl_internal              | Point to place to put result\n  stm   r0,r1,0(r15)                  | Save result for caller\n  drop  r4                            |\n endblk block=Convert_Time_From_SecondsSince1970,rc=0\n title \"Convert Time From Internal Format To SecsSince1970 Format\"\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Convert_Time_To_SecondsSince1970\n*  Abstract:   This routine converts the internal-format time to\n*              #seconds since 1970.\n*  Inputs:     On entry, R1 points to a converter parameter list.\n*  Outputs:    Time converted to requested format.\n*  Special\n*  Notes:      This subroutine only saves R14. It destroys R0, R1, R2\n*              and R15.\n*\n*---------------------------------------------------------------------*\n         space 1                      |\n block name=Convert_Time_To_SecondsSince1970,type=subroutine,          *\n               options=(*nosubopts),                                   *\n               save=(r14,pwa_converter_r14)\n  lr    r4,r1                         |\n  using cpl,r4                        |\n*\n* Set r0:r1 = #microseconds since 1970.\n*\n  l     r15,cpl_internal              |\n  lm    r0,r1,0(r15)                  |   Get internal-format stamp\n  lm    r14,r15,psd_mics_circa_1970   |   Get value for start of 1970.\n  slr   r1,r15                        |   Convert\n  if    (cc12)                        |     #microseconds\n   sh    r0,=h'1'                     |     since 1970-01-01\n  endif                               |     to #microseconds\n  sr    r0,r14                        |     since 1970-01-01\n*\n* Convert #microseconds since 1970-01-01 to #seconds since 1970.\n*\n  d     r0,=f'1000000'                | Convert to seconds.\n  l     r15,cpl_time                  |\n  st    r1,0(r15)                     |\n  drop  r4                            |\n endblk block=Convert_Time_To_SecondsSince1970,rc=0\n title \"Convert Date From Text Format To Internal Format\"\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Convert_Date_From_Text\n*  Abstract:   This routine converts an input date of the format\n*              'monthname nn, year' to the internal format.\n*  Inputs:     On entry, R1 points to a converter parameter list.\n*  Outputs:    Date converted and added to internal format time.\n*  Special\n*  Notes:      None.\n*\n*---------------------------------------------------------------------*\n         space 1                      |\n block name=Convert_Date_From_Text,type=subroutine\n  lr    r4,r1                         |\n  using cpl,r4                        |\n  callsub validate_text_formats       |\n  errexit (treg,r15,nz),code=&dt_invalid_input_date\n* *-------------------------------------------------------------------*\n* *  Lookup and validate month, then produce Gregorian date to convert.\n* *-------------------------------------------------------------------*\n  la    r2,psd_month_table            | Look text month up\n  using month_table,r2                |\n  la    r15,mt_#_entries              |\n  loop  bct                           |\n   leave loop=*,(clc,pwa_text_month,eq,mt_month_name)\n   la    r2,mt_length(,r2)            |\n  endloop bct,r15                     |\n  errexit (treg,r15,z),code=&dt_invalid_input_date   Month not found.\n  lh    r1,mt_month_num               |\n  st    r1,pwa_i_month                |\n  pack  pwa_d,pwa_numeric_year        | Pack year\n  cvb   r1,pwa_d                      | Convert to integer\n  st    r1,pwa_i_year                 |  and save for later.\n  pack  pwa_d,pwa_numeric_day         | Validate # days in month\n  cvb   r15,pwa_d                     |\n  st    r15,pwa_i_day                 |\n  callsub Convert_Gregorian_To_Days,  |                                *\n               (pwa_i_month,pwa_i_day,pwa_i_year,pwa_number_of_days),  *\n               novl                   |\n  l     r1,pwa_number_of_days         |\n  xr    r0,r0                         |\n  Convert_Days_To_DT_Units reg=r0     |  then convert to internal fmt.\n  l     r2,cpl_internal               |\n  lm    r14,r15,0(r2)                 |\n  ar    r0,r14                        | Add-logical upper half\n  alr   r1,r15                        | Add-logical lower half\n  if    not,(cc12)                    | If overflow in low half\n   ah    r0,=h'1'                     |  carry a 1 to high 4 bytes.\n  endif                               |\n  stm   r0,r1,0(r2)                   | Save result for caller\n  drop  r4                            |\n endblk rc=0                          |\n title \"Convert Date From Internal Format To Text Or Textd Format\"\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Convert_Date_To_Text\n*  Abstract:   This routine converts the internal-format date to\n*              'monthname nn, year' format. This routine also handles\n*              the following variations:\n*              . &DT_TEXTD    -- 'weekday, monthname nn, year' format\n*  Inputs:     On entry, R1 points to a converter parameter list.\n*  Outputs:    Date,converted to requested format.\n*  Special\n*  Notes:      None.\n*\n*---------------------------------------------------------------------*\n         space 1                      |\n block name=Convert_Date_To_Text,type=subroutine\n  lr    r4,r1                         |\n  using cpl,r4                        |\n  l     r15,cpl_internal              |\n  Convert_DT_Units_To_Days  Reg=R0,   |                                *\n               Units=0(r15)           |\n*                                     | R1 is now # days since 1/1/0000\n  st    r1,pwa_number_of_days         |\n* *-------------------------------------------------------------------*\n* * If output date format includes a weekday, find it now.  If the\n* * weekday is all the caller wanted, return it and get out.\n* *-------------------------------------------------------------------*\n  if  not,(tbit,pwa_text_flags,pwa_textd+pwa_weekday+pwa_weekday3,off)\n   l     r1,pwa_number_of_days        | Get number-of-days mod 7\n   xr    r0,r0                        |\n   d     r0,=f'7'                     |\n   la    r14,psd_weekday_table        | Look up weekday\n   la    r15,7                        |\n   loop  bct                          |\n    leave loop=*,(clm,r0,b'0001',eq,0(r14))\n    la    r14,l'psd_weekday_table(,r14)\n   endloop bct,r15                    |\n   mvc   pwa_text_weekday,1(r14)      |  Save weekday text for later.\n   if  not,(tbit,pwa_text_flags,pwa_weekday+pwa_weekday3,off)\n    l     r15,cpl_date                |      If weekday format wanted:\n    if    (tbit,pwa_text_flags,pwa_weekday3)  If 3-char weekday format\n     la    r1,3                       |        Length to move = 3\n    else                              |       Otherwise\n     la    r1,l'pwa_text_weekday      |        Length is max length.\n    endif                             |\n    bctr  r1,0                        |\n    exi   r1,(mvc,0(0,r15),pwa_text_weekday)  Return weekday to caller\n    leave block=*                     |       and exit now.\n   endif                              |\n  endif                               |\n* *-------------------------------------------------------------------*\n* * The following code is for the &dt_text and &dt_textd formats. The\n* * \"weekday\" is already known if the call is for &dt_textd.\n* *-------------------------------------------------------------------*\n  callsub Convert_Days_To_Gregorian,  |                                *\n               (pwa_i_month,pwa_i_day,pwa_i_year,pwa_number_of_days),  *\n               novl                   |\n  l     r1,pwa_i_year                 | Edit out years, then save\n  cvd   r1,pwa_d                      |\n  mvc   pwa_edit(6),=x'402120202020'  |  for String Handler later.\n  ed    pwa_edit(6),pwa_d+5           |\n  mvc   pwa_numeric_year,pwa_edit+2   |\n  la    r14,psd_month_table           |\n  using month_table,r14               |\n  l     r1,pwa_i_month                |\n  la    r15,mt_#_entries              |\n  loop  bct                           |\n   leave loop=*,(ch,r1,eq,mt_month_num)\n   la    r14,mt_length(,r14)          |\n  endloop bct,r15                     |\n  mvc   pwa_text_month,mt_month_name  |\n  drop  r14                           |\n  l     r1,pwa_i_day                  |\n  cvd   r1,pwa_d                      | Change to packed, then\n  if    (tbit,pwaf1lz)\n   mvc   pwa_edit(4),=x'40212020'     |  edit for return to caller.\n  else\n   mvc   pwa_edit(4),=x'40202120'     |  edit for return to caller.\n  endif\n  ed    pwa_edit(4),pwa_d+6           |\n  mvc   pwa_numeric_day,pwa_edit+2    |\n  if    (cli,pwa_numeric_day,eq,c' ') | If day now has a leading space\n   mvc   pwa_numeric_day(1),pwa_numeric_day+1   Slide day digit left 1\n   mvi   pwa_numeric_day+1,c' '       |         position; pad w/space.\n  endif                               |\n  fill  pwa_format_string,c' '        |\n  if    (tbit,pwa_text_flags,pwa_text)  Assemble formatted text date\n   st_format   id=ST,                 |                                *\n               string=pwa_format_string,                               *\n               resultlen=pwa_format_length,                            *\n               control=\"{CL9 T} {CL2 T}, {CL4}\",                       *\n               source=(pwa_text_month,pwa_numeric_day,pwa_numeric_year)\n   errexit (treg,r15,nz),code=&dt_string_handler_error\n   l     r15,cpl_date                 |\n   lh    r1,pwa_format_length         |\n   bctr  r1,0                         |\n   exi   r1,(mvc,0(0,r15),pwa_format_string)\n  elseif (tbit,pwa_text_flags,pwa_textd) Assemble formatted textd date\n   st_format   id=ST,                 | Format it                      *\n               string=pwa_format_string,                               *\n               resultlen=pwa_format_length,                            *\n               control=\"{CL9 T}, {CL9 T} {CL2 T}, {CL4}\",              *\n               source=(pwa_text_weekday,pwa_text_month,pwa_numeric_day,*\n               pwa_numeric_year)      |\n   errexit (treg,r15,nz),code=&dt_string_handler_error\n   l     r15,cpl_date                 |\n   lh    r1,pwa_format_length         |\n   bctr  r1,0                         |\n   exi   r1,(mvc,0(0,r15),pwa_format_string)\n  endif                               |\n  drop  r4                            |\n endblk rc=0                          |\n title \"Convert Internal Format Date To Days-In-Month\"\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Convert_Date_To_Days\n*  Abstract:   This routine returns the number of days in the current\n*              month.  There is no corresponding input date routine.\n*              .. &DT_Days     -- C\"dd mmm yyyy\"\n*              .. &DT_Pdays    -- C\"dd mmm yy\"\n*              .. &DT_Idays\n*  Inputs:     On entry, R1 points to a converter parameter list.\n*  Outputs:    Days-in-month returned to caller in requested format.\n*  Notes:      None\n*\n*---------------------------------------------------------------------*\n         space 1                      |\n block name=Convert_Date_To_Days,type=subroutine\n  lr    r4,r1                         |\n  using cpl,r4                        |\n  l     r15,cpl_internal              |\n  Convert_DT_Units_To_Days  Units=0(r15),Reg=R0\n  st    r1,pwa_number_of_days         |\n  callsub Convert_Days_To_Gregorian,  |                                *\n               (pwa_i_month,pwa_i_day,pwa_i_year,pwa_number_of_days),  *\n               novl                   |\n  l     r1,pwa_i_day                  |\n  l     r15,cpl_date                  |\n  if    (tbit,pwa_day_flags,pwa_idays)\n   sth   r1,0(,r15)                   |\n  elseif (tbit,pwa_day_flags,pwa_pdays)\n   cvd   r1,pwa_d                     |\n   mvc   0(2,r15),pwa_d+6             |\n  elseif (tbit,pwa_day_flags,pwa_days)\n   cvd   r1,pwa_d                     |\n   mvc   pwa_edit(4),=xl4'40212020'   |\n   ed    pwa_edit(4),pwa_d+6          |\n   mvc   0(2,r15),pwa_edit+2          |\n  endif                               |\n endblk rc=0                          |\n title \"Convert Internal Format Time To Month Name Or Number\"\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Convert_Date_To_Months\n*  Abstract:   This routine converts an internal format timestamp to\n*              the name or number of the current month.  There is no\n*              corresponding input routine.  The following formats\n*              are supported by this routine:\n*              .. &DT_Month       -- CL2'12'\n*              .. &DT_Pmonth      -- PL2'12'\n*              .. &DT_Imonth      -- H'12'\n*              .. &DT_Monthname   -- CL9\"December\"\n*              .. &DT_Monthname3  -- CL3\"Dec\"\n*  Inputs:     On entry, R1 points to a converter parameter list.\n*  Outputs:    Internal format date converted as requested.\n*  Notes:      None\n*\n*---------------------------------------------------------------------*\n         space 1                      |\n block name=Convert_Date_To_Months,type=subroutine\n  lr    r4,r1                         |\n  using cpl,r4                        |\n  l     r15,cpl_internal              |\n  Convert_DT_Units_To_Days  Units=0(r15),Reg=R0\n  st    r1,pwa_number_of_days         |\n  callsub Convert_Days_To_Gregorian,  |                                *\n               (pwa_i_month,pwa_i_day,pwa_i_year,pwa_number_of_days),  *\n               novl                   |\n  l     r0,pwa_i_month                | Look up month:\n  l     r15,cpl_date                  |\n  if    (tbit,pwa_month_flags,pwa_imonth)\n   sth   r0,0(,r15)                   |\n  elseif (tbit,pwa_month_flags,pwa_pmonth)\n   cvd   r0,pwa_d                     |\n   mvc   0(2,r15),pwa_d+6             |\n  elseif (tbit,pwa_month_flags,pwa_month)\n   mvc   pwa_edit(4),=x'40212020'     |\n   cvd   r0,pwa_d                     |\n   ed    pwa_edit(4),pwa_d+6          |\n   mvc   0(2,r15),pwa_edit+2          |\n  else                                | Must be monthname or monthname3\n   la    r14,psd_month_table          |\n   using month_table,r14              |\n   la    r15,mt_#_entries             |\n   loop  bct                          |\n    leave loop=*,(ch,r0,eq,mt_month_num)\n    la    r14,mt_length(,r14)         |\n   endloop bct,r15                    |\n   mvc  pwa_text_month(3),mt_month_name\n   l     r2,cpl_date                  |\n   if    (tbit,pwa_month_flags,pwa_monthname)\n    mvc   0(9,r2),mt_month_name       |\n   elseif (tbit,pwa_month_flags,pwa_monthname3)\n    mvc   0(3,r2),mt_month_name       |\n   endif                              |\n   drop  r14                          |\n  endif                               |\n  drop  r4                            |\n endblk rc=0                          |\n title \"Convert Internal Format Time To Years\"\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Convert_Date_To_Years\n*  Abstract:   This routine converts an internal format timestamp to\n*              the year represented.  The following are supported:\n*              .. &DT_Years    -- C\"1989\"\n*              .. &DT_Pyears   -- PL4'1989'\n*              .. &DT_Iyears   -- H'1989'\n*  Inputs:     On entry, R1 points to a converter parameter list.\n*  Outputs:    Internal format date converted as requested.\n*  Notes:      None\n*\n*---------------------------------------------------------------------*\n         space 1                      |\n block name=Convert_Date_To_Years,type=subroutine\n  lr    r4,r1                         |\n  using cpl,r4                        |\n  l     r15,cpl_internal              |\n  Convert_DT_Units_To_Days  Units=0(r15),Reg=R0\n  st    r1,pwa_number_of_days         |\n  callsub Convert_Days_To_Gregorian,  |                                *\n               (pwa_i_month,pwa_i_day,pwa_i_year,pwa_number_of_days),  *\n               novl                   |\n  l     r1,pwa_i_year                 |\n  l     r15,cpl_date                  |\n  if    (tbit,pwa_year_flags,pwa_iyear)\n   sth   r1,0(,r15)                   |\n  elseif (tbit,pwa_year_flags,pwa_pyear)\n   cvd   r1,pwa_d                     |\n   mvc   0(4,r15),pwa_d+4             |\n  else                                | Must be year or year2\n   cvd   r1,pwa_d                     |\n   mvc   pwa_edit(6),=x'402120202020' |\n   ed    pwa_edit(6),pwa_d+5          |\n   if    (tbit,pwa_year_flags,pwa_year)\n    mvc   0(4,r15),pwa_edit+2         |\n   elseif (tbit,pwa_year_flags,pwa_year2)\n    mvc   0(2,r15),pwa_edit+4         |\n   endif                              |\n  endif                               |\n  drop  r4                            |\n endblk rc=0                          |\n title \"Convert Integer Intervals To Internal Format\"\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Convert_Integer_Interval_To_Internal\n*  Abstract:   This routine converts various integer interval input\n*              values to internal format. This routine handles the\n*              following variations:\n*              . &DT_DAYS       -- CL5 number of days\n*              . &DT_PDAYS      -- PL4 number of days\n*              . &DT_IDAYS      -- Halfword number of days\n*              . &DT_HOURS      -- CL5 number of hours\n*              . &DT_PHOURS     -- PL4 number of hours\n*              . &DT_IHOURS     -- Halfword number of hours\n*              . &DT_MINUTES    -- CL5 number of minutes\n*              . &DT_PMINUTES   -- PL4 number of minutes\n*              . &DT_IMINUTES   -- Halfword number of minutes\n*              . &DT_SECONDS    -- CL5 number of seconds\n*              . &DT_PSECONDS   -- PL4 number of seconds\n*              . &DT_ISECONDS   -- Halfword number of seconds\n*              . &DT_HUNDREDTHS -- fullword number of hundredths\n*  Inputs:     On entry, R1 points to a converter parameter list.\n*  Outputs:    Interval, converted to requested format.\n*  Special\n*  Notes:      In order to convert a number of hours, minutes, etc. to\n*              a number of microseconds, this routine has to multiply\n*              some potentially large values together, but System/370\n*              does not support a doubleword integer multiply.  This\n*              is done as follows:\n*              .. R1 will contain a 'multiplier' that will partially\n*                 convert the input interval to microseconds.\n*              .. R2 contains the rest of the multiplier, in the form\n*                 of a power-of-2 exponent to do a double shift with.\n*\n*              This routine is called by Convert_Delta_To_Interval.\n*\n*---------------------------------------------------------------------*\n         space 1                      |\n block name=Convert_Integer_Interval_To_Internal,type=subroutine\n  lr    r4,r1                         |\n  using cpl,r4                        |\n  l     r3,cpl_interval               |\n* *-------------------------------------------------------------------*\n* *  First, determine values to multiply and shift by.\n* *-------------------------------------------------------------------*\n  if    (cli,pwa_day_flags,ne,x'00')  |\n   if    (tbit,pwa_day_flags,pwa_days)    5-digit character days?\n    errexit (%trt,0(5,r3),ne,psd_numeric_table),                       *\n               code=&dt_invalid_input_interval\n    pack  pwa_d,0(5,r3)               |\n    cvb   r15,pwa_d                   |\n   elseif (tbit,pwa_day_flags,pwa_pdays)  PL4 packed-decimal days?\n    Validate_Packed_Data Data=0(r3),Len=4,Type=INTERVAL\n    zap   pwa_d,0(4,r3)               |    Trusting, aren't we?\n    cvb   r15,pwa_d                   |\n   elseif (tbit,pwa_day_flags,pwa_idays)  Halfword integer days?\n    lh    r15,0(,r3)                  |\n   endif                              |\n* *-------------------------------------------------------------------*\n  elseif (cli,pwa_hour_flags,ne,x'00')\n   if    (tbit,pwa_hour_flags,pwa_hours)  5-digit character hours?\n    errexit (%trt,0(5,r3),ne,psd_numeric_table),                       *\n               code=&dt_invalid_input_interval\n    pack  pwa_d,0(5,r3)               |\n    cvb   r15,pwa_d                   |\n   elseif (tbit,pwa_hour_flags,pwa_phours) PL4 packed-decimal hours?\n    Validate_Packed_Data Data=0(r3),Len=4,Type=INTERVAL\n    zap   pwa_d,0(4,r3)               |    Trusting, aren't we?\n    cvb   r15,pwa_d                   |\n   elseif (tbit,pwa_hour_flags,pwa_ihours) Halfword integer hours?\n    lh    r15,0(,r3)                  |\n   endif                              |\n* *-------------------------------------------------------------------*\n  elseif (cli,pwa_minute_flags,ne,x'00')\n   if    (tbit,pwa_minute_flags,pwa_minutes) 5-digit character minutes?\n    errexit (%trt,0(5,r3),ne,psd_numeric_table),                       *\n               code=&dt_invalid_input_interval\n    pack  pwa_d,0(5,r3)               |\n    cvb   r15,pwa_d                   |\n   elseif (tbit,pwa_minute_flags,pwa_pminutes) PL4 packed minutes?\n    Validate_Packed_Data Data=0(r3),Len=4,Type=INTERVAL\n    zap   pwa_d,0(4,r3)               |    Trusting, aren't we?\n    cvb   r15,pwa_d                   |\n   elseif (tbit,pwa_minute_flags,pwa_iminutes) Halfword int. minutes?\n    lh    r15,0(,r3)                  |\n   endif                              |\n* *-------------------------------------------------------------------*\n  elseif (cli,pwa_second_flags,ne,x'00')\n   if    (tbit,pwa_second_flags,pwa_seconds) 5-digit character seconds?\n    errexit (%trt,0(5,r3),ne,psd_numeric_table),                       *\n               code=&dt_invalid_input_interval\n    pack  pwa_d,0(5,r3)               |\n    cvb   r15,pwa_d                   |\n   elseif (tbit,pwa_second_flags,pwa_pseconds) PL4 packed seconds?\n    Validate_Packed_Data Data=0(r3),Len=4,Type=INTERVAL\n    zap   pwa_d,0(4,r3)               |    Trusting, aren't we?\n    cvb   r15,pwa_d                   |\n   elseif (tbit,pwa_second_flags,pwa_iseconds) Halfword int. seconds?\n    lh    r15,0(,r3)                  |\n   endif                              |\n* *-------------------------------------------------------------------*\n  elseif (cli,pwa_hundredth_flags,ne,x'00')\n    errexit (%trt,0(5,r3),ne,psd_numeric_table),                       *\n               code=&dt_invalid_input_interval\n   if    (tbit,pwa_hundredth_flags,pwa_hundredths) 5-digit?\n    pack  pwa_d,0(5,r3)               |\n    cvb   r15,pwa_d                   |\n   elseif (tbit,pwa_hundredth_flags,pwa_phundredths) PL4 packed?\n    Validate_Packed_Data Data=0(r3),Len=4,Type=INTERVAL\n    zap   pwa_d,0(4,r3)               |    Trusting, aren't we?\n    cvb   r15,pwa_d                   |\n   elseif (tbit,pwa_hundredth_flags,pwa_ihundredths) Halfword integer?\n    lh    r15,0(,r3)                  |\n   endif                              |\n  endif                               |\n* *-------------------------------------------------------------------*\n* *  At this point, the integer equivalent of our input is in R15.\n* *  We now need to come up with a value to turn R15's contents\n* *  into microseconds.\n* *-------------------------------------------------------------------*\n  if    (cli,pwa_day_flags,ne,x'00')  | Days: multiply by 8640000\n   lh    r1,=h'16875'                 |        which is 16875\n   la    r2,9                         |         times 512 (2**9).\n  elseif (cli,pwa_hour_flags,ne,x'00')  Hours: multiply by 360000\n   lh    r1,=h'5625'                  |         which is 5625\n   la    r2,6                         |           times 64 (2**6).\n  elseif (cli,pwa_minute_flags,ne,x'00')  Minutes: Times 6000,\n   la    r1,375                       |             which is 375\n   la    r2,4                         |              times 16 (2**4).\n  elseif (cli,pwa_second_flags,ne,x'00')  Seconds: Times 100,\n   la    r1,25                        |             which is 25\n   la    r2,2                         |              times 4 (2**2).\n  else ,                              |   Hundredths: Times 1,\n   la    r1,1                         |             which is 1\n   xr    r2,r2                        |             times 1 (2**0).\n  endif                               |\n  m     r0,=f'10000'                  | Multiply multiplier by 10000.\n*                                     | The largest possible answer\n*                                     | here is 87,890,625, or 53D1AC1,\n*                                     | so we don't need to worry about\n*                                     | the contents of R0.\n  mr    r14,r1                        | Multiply R14-R15 by multiplier,\n  sldl  r14,0(r2)                     | then mult. by power of 2 in R2.\n  l     r2,cpl_internal               | Get addr of internal interval\n  lm    r0,r1,0(r2)                   | Get the value so far\n  ar    r0,r14                        | Add-logical upper half\n  alr   r1,r15                        | Add-logical lower half\n  if    not,(cc12)                    | If overflow in low half\n   ah    r0,=h'1'                     |  carry a 1 to high 4 bytes.\n  endif                               |\n  stm   r0,r1,0(r2)                   | Save result for caller\n endblk rc=0                          |\n title \"Convert Internal Format To Integer Interval\"\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Convert_Internal_To_Integer_Interval\n*  Abstract:   This routine converts an internal-format interval to\n*              assorted integer intervals. This routine can produce\n*              the following variations:\n*              . &DT_DAYS       -- CL5 number of days\n*              . &DT_PDAYS      -- PL4 number of days\n*              . &DT_IDAYS      -- Halfword number of days\n*              . &DT_HOURS      -- CL5 number of hours\n*              . &DT_PHOURS     -- PL4 number of hours\n*              . &DT_IHOURS     -- Halfword number of hours\n*              . &DT_MINUTES    -- CL5 number of minutes\n*              . &DT_PMINUTES   -- PL4 number of minutes\n*              . &DT_IMINUTES   -- Halfword number of minutes\n*              . &DT_SECONDS    -- CL5 number of seconds\n*              . &DT_PSECONDS   -- PL4 number of seconds\n*              . &DT_ISECONDS   -- Halfword number of seconds\n*              . &DT_HUNDREDTHS -- CL5 number of hundredths\n*              . &DT_PHUNDREDTHS -- PL4  number of hundredths\n*              . &DT_IHUNDREDTHS -- halfword number of hundredths\n*  Inputs:     On entry, R1 points to a converter parameter list.\n*  Outputs:    Interval, converted to requested format and subtracted\n*              from the internal value pointed to by the CPL.\n*  Special\n*  Notes:      In order to convert a number of hours, minutes, etc. to\n*              a number of microseconds, this routine has to multiply\n*              some potentially large values together, but System/370\n*              does not support a doubleword integer multiply.  This\n*              is done as follows:\n*              .. R1 will contain a 'multiplier' that will partially\n*                 convert the input interval to microseconds.\n*              .. R2 contains the rest of the multiplier, in the form\n*                 of a power-of-2 exponent to do a double shift with.\n*---------------------------------------------------------------------*\n         space 1                      |\n block name=Convert_Internal_To_Integer_Interval,type=subroutine\n  lr    r4,r1                         |\n  using cpl,r4                        |\n  l     r15,cpl_internal              |\n  lm    r14,r15,0(r15)                | Get the value\n* *-------------------------------------------------------------------*\n* *  First, determine values to divide and shift by.\n* *-------------------------------------------------------------------*\n  if    (cli,pwa_day_flags,ne,x'00')  | Days: multiply by 8640000\n   lh    r1,=h'16875'                 |           which is 16875\n   la    r2,9                         |           times 512 (2**9).\n  elseif (cli,pwa_hour_flags,ne,x'00')  Hours: multiply by 360000\n   lh    r1,=h'5625'                  |             which is 5625\n   la    r2,6                         |             times 64 (2**6).\n  elseif (cli,pwa_minute_flags,ne,x'00') Minutes: Times 6000,\n   la    r1,375                       |          which is 375\n   la    r2,4                         |          times 16 (2**4).\n  elseif (cli,pwa_second_flags,ne,x'00') Seconds: Times 100,\n   la    r1,25                        |            which is 25\n   la    r2,2                         |            times 4 (2**2).\n  else                                |   Hundredths: Times 1,\n   la    r1,1                         |             which is 1\n   xr    r2,r2                        |             times 1 (2**0).\n  endif                               |\n  m     r0,=f'10000'                  | Multiply divisor by 15625.\n*                                     | The largest possible answer\n*                                     | here is 87,890,625, or 53D1AC1,\n*                                     | so we don't need to worry about\n*                                     | the contents of R0.\n  srdl  r14,0(r2)                     | Divide by power of 2 in R2,\n  dr    r14,r1                        | then divide R14-R15 by divisor.\n* *-------------------------------------------------------------------*\n* * Now, convert quotient in R15 to format requested by caller.\n* *-------------------------------------------------------------------*\n  if           (tbit,pwa_day_flags,pwa_days),or,                       *\n               (tbit,pwa_hour_flags,pwa_hours),or,                     *\n               (tbit,pwa_minute_flags,pwa_minutes),or,                 *\n               (tbit,pwa_second_flags,pwa_seconds),or,                 *\n               (tbit,pwa_hundredth_flags,pwa_hundredths)\n   errexit     (c,r15,gt,=f'99999'),  |                                *\n               code=&dt_overflow      |\n   cvd   r15,pwa_d                    |\n   l     r1,cpl_interval              |\n   unpk  0(5,r1),pwa_d+5(3)           |\n   oi    4(r1),x'f0'                  |\n  elseif       (tbit,pwa_day_flags,pwa_pdays),or,                      *\n               (tbit,pwa_hour_flags,pwa_phours),or,                    *\n               (tbit,pwa_minute_flags,pwa_pminutes),or,                *\n               (tbit,pwa_second_flags,pwa_pseconds),or,                *\n               (tbit,pwa_hundredth_flags,pwa_phundredths)\n   errexit   (c,r15,gt,=f'9999999'),  |                                *\n               code=&dt_overflow      |\n   cvd   r15,pwa_d                    |\n   l     r1,cpl_interval              |\n   mvc   0(4,r1),pwa_d+4              |\n  elseif       (tbit,pwa_day_flags,pwa_idays),or,                      *\n               (tbit,pwa_hour_flags,pwa_ihours),or,                    *\n               (tbit,pwa_minute_flags,pwa_iminutes),or,                *\n               (tbit,pwa_second_flags,pwa_iseconds),or,                *\n               (tbit,pwa_hundredth_flags,pwa_ihundredths)\n   errexit    (c,r15,gt,=f'32767'),   |                                *\n               code=&dt_overflow      |\n   l     r1,cpl_interval              |\n   sth   r15,0(,r1)                   |\n  endif                               |\n endblk rc=0                          |\n title \"Convert Delta-Format Interval To Internal Format\"\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Convert_Delta_Interval_To_Internal\n*  Abstract:   This routine converts a DT_Delta format interval value\n*              to the internal format.\n*  Input:      On entry, R1 points to a converter parameter list. See\n*              the \"CPL\" DSECT.\n*  Outputs:    Interval converted to internal format\n*  Special     The DT_Delta format is composed of sections. The general\n*  Notes:      format is  \"<ddddd>-hh<:mm<:ss<.th>>>\", where the parts\n*              enclosed in <>'s are optional. See Validate_Delta_Format\n*              for further details.\n*\n*---------------------------------------------------------------------*\n         SPACE 1\n block name=Convert_Delta_Interval_To_Internal,type=subroutine\n  lr    r4,r1\n  using cpl,r4\n  callsub Validate_Delta_Format\n  errexit (treg,r15,nz),code=&dt_invalid_input_interval\n* *-------------------------------------------------------------------*\n* *  Validate_Delta_Format has filled in the following PWA variables:\n* *    PWA_Number_Of_Days  PWA_Number_Of_Hours  PWA_Number_Of_Minutes\n* *         PWA_Number_Of_Seconds   PWA_Number_Of_Hundredths\n* *-------------------------------------------------------------------*\n  l     r1,pwa_number_of_days         | Get number of days\n  mh    r1,=h'24'                     | Turn into hours\n  lr    r2,r1                         | Save in R2\n  l     r1,pwa_number_of_hours        | Get number of hours\n  alr   r1,r2                         | Add days-as-hours\n  mh    r1,=h'60'                     | Turn into minutes\n  lr    r2,r1                         | Save in R2\n  l     r1,pwa_number_of_minutes      | Get number of minutes\n  alr   r1,r2                         | Add days+hours_as_minutes\n* *-------------------------------------------------------------------*\n* *  R1 now contains the delta value in minutes.  Convert this value\n* *  to microseconds now, then convert seconds and hundredths to\n* *  microseconds separately and add them together.  This avoids some\n* *  overflow problems with large (over 25000 days) delta values.\n* *-------------------------------------------------------------------*\n  m     r0,=f'60000000'               | Turn into microseconds in R0-R1\n*                                     |\n  l     r15,pwa_number_of_seconds     | Get number of seconds\n  mh    r15,=h'100'                   |\n  al    r15,pwa_number_of_hundredths  |\n  m     r14,=f'10000'                 | Turn seconds, hundredths into\n*                                     |    microseconds in R14-R15.\n  alr   r1,r15                        | Add lo-order halves together\n  if    not,(cc12)                    | If there was an overflow\n   ah    r0,=h'1'                     |  Add 1 to upper half.\n  endif                               |\n  alr   r0,r14                        | Add hi-order halves together.\n*                                     |\n  l     r2,cpl_internal               | Get addr of internal interval\n  lm    r14,r15,0(r2)                 | Get the value so far\n  ar    r0,r14                        | Add-logical upper half\n  alr   r1,r15                        | Add-logical lower half\n  if    not,(cc12)                    | If overflow in low half\n   ah    r0,=h'1'                     |  carry a 1 to high 4 bytes.\n  endif                               |\n  stm   r0,r1,0(r2)                   | Save result for caller\n endblk rc=0                          |\n title \"Convert Internal Format To Delta-Format Interval\"\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Convert_Internal_To_Delta_Interval\n*  Abstract:   This routine converts an internal format value to\n*              DT_Delta format.\n*  Input:      On entry, R1 points to a converter parameter list. See\n*              the \"CPL\" DSECT.\n*  Outputs:    Internal-format value converted and returned to caller.\n*  Special     The DT_Delta format is composed of sections. The general\n*  Notes:      format is  \"<ddddd>-hh<:mm<:ss<.th>>>\", where the parts\n*              enclosed in <>'s are optional. See Validate_Delta_Format\n*              for further details.\n*\n*---------------------------------------------------------------------*\ndt_delta_days       equ   0           | Handy local values.\ndt_delta_dash       equ   5           |\ndt_delta_hours      equ   6           |\ndt_delta_colon1     equ   8           |\ndt_delta_minutes    equ   9           |\ndt_delta_colon2     equ  11           |\ndt_delta_seconds    equ  12           |\ndt_delta_period     equ  14           |\ndt_delta_hundredths equ  15           |\n* *-------------------------------------------------------------------*\n         SPACE 1\n block name=Convert_Internal_To_Delta_Interval,type=subroutine\n  lr    r4,r1                         |\n  using cpl,r4                        |\n* *-------------------------------------------------------------------*\n* *  Whack the interval up into days, hours, minutes, etc.  This is\n* *  done by a BIG whack up front, then two sets of little whacks,\n* *  to avoid division overflows due to large doubleword integers.\n* *-------------------------------------------------------------------*\n  l     r15,cpl_internal              | Point to internal-format value\n  lm    r14,r15,0(r15)                | Get the value\n  d     r14,=f'60000000'              | WHACK! Convert to minutes\n  lr    r3,r14                        | Save remainder for later\n* *-------------------------------------------------------------------*\n  xr    r14,r14                       | Clear R14\n  d     r14,=f'1440'                  | Divide r14-r15 by minutes/day\n  st    r15,pwa_number_of_days        |  in a day; save quotient\n  lr    r15,r14                       | Remainder is new divisor\n  xr    r14,r14                       | Clear R14\n  d     r14,=f'60'                    | Divide R14-R15 by minutes/hour\n  st    r15,pwa_number_of_hours       |  in a day; save quotient\n  st    r14,pwa_number_of_minutes     | Remainder is minutes.\n* *-------------------------------------------------------------------*\n  lr    r15,r3                        | Copy seconds-as-microseconds\n  xr    r14,r14                       | Clear R14\n  d     r14,=f'10000'                 | Make .01-sec units, toss rmdr.\n  xr    r14,r14                       | Clear R14\n  d     r14,=f'100'                   | Split into seconds\n  st    r15,pwa_number_of_seconds     |  and hundredths.\n  st    r14,pwa_number_of_hundredths  |\n          eject ,                     |\n* *-------------------------------------------------------------------*\n* *  Now, convert days, hours, etc. to character digits and build\n* *  delta-format interval in caller's storage.  (w/leading zeros)\n* *-------------------------------------------------------------------*\n  l     r3,cpl_interval               | Point to caller's storage\n  l     r1,pwa_number_of_days         | Get days\n  errexit      (c,r1,gt,=f'99999'),   |                                *\n               code=&dt_overflow      |\n  cvd   r1,pwa_d                      | Convert to packed\n  unpk  dt_delta_days(5,r3),pwa_d+5(3)  Unpk directly to caller's stg\n  oi    4(r3),x'f0'                   | Clean up last digit\n  mvi   dt_delta_dash(r3),c'-'        |\n*                                     |\n  l     r1,pwa_number_of_hours        | Get hours\n  cvd   r1,pwa_d                      | Convert to packed\n  unpk  pwa_edit(5),pwa_d+5(3)        | Unpack to intermediate area\n  oi    pwa_edit+4,x'f0'              | Clean up behind UNPK\n  mvc   dt_delta_hours(2,r3),pwa_edit+3\n  mvi   dt_delta_colon1(r3),c':'      |             | Append a ':'\n*                                     |\n  l     r1,pwa_number_of_minutes      |\n  cvd   r1,pwa_d                      |\n  unpk  pwa_edit(5),pwa_d+5(3)        |\n  oi    pwa_edit+4,x'f0'              |\n  mvc   dt_delta_minutes(2,r3),pwa_edit+3\n  mvi   dt_delta_colon2(r3),c':'      |\n*                                     |\n  l     r1,pwa_number_of_seconds      |\n  cvd   r1,pwa_d                      |\n  unpk  pwa_edit(5),pwa_d+5(3)        |\n  oi    pwa_edit+4,x'f0'              |\n  mvc   dt_delta_seconds(2,r3),pwa_edit+3\n  mvi   dt_delta_period(r3),c'.'      |\n*                                     |\n  l     r1,pwa_number_of_hundredths   |\n  cvd   r1,pwa_d                      |\n  unpk  pwa_edit(5),pwa_d+5(3)        |\n  oi    pwa_edit+4,x'f0'              |\n  mvc   dt_delta_hundredths(2,r3),pwa_edit+3\n* *-------------------------------------------------------------------*\n endblk rc=0                          |\n title \"Convert Integer Julian Date To Gregorian Date\"\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Convert_Ijuldate_To_Gregorian\n*  Abstract:   Convert a Julian date into a Gregorian date.  This is\n*              generally done in preparation to call Convert_Gregorian_\n*              To_Days.\n*  Input:      On entry, R1 points to the following parameter list:\n*                + 00 -- Fullword month value to be returned\n*                + 04 -- Fullword day value to be returned\n*                + 08 -- Fullword year value to be returned\n*                + 12 -- Fullword Ijulian date to convert\n*  Output:     Parameters at +0, +4, +8 filled in.\n*\n*  Notes:      . This subroutine uses Algorithm 398, \"Tableless Date\n*                Conversion\", from \"Collected Algorithms From\n*                Communications Of The ACM\".  This procedure uses the\n*                \"full\" algorithm (not the short one that assumes that\n*                \"1900 < year < 2100\"), modified slightly to abbreviate\n*                the leapyear check.  The routine (coded as a rexx\n*                procedure) works as follows:\n*\n*                   convert: procedure\n*                     parse upper arg j\n*                     jy = j % 1000\n*                     jd = j // 1000\n*                     t = 0\n*                     if (jy // 4) = 0 then t = 1\n*                     if (jy // 100) = 0 then t = 0\n*                     if (jy // 400) = 0 then t = 1\n*                     d = jd\n*                     if jd > 59 + t then d = jd + 2 - t\n*                     m = ((d + 91) * 100) % 3055\n*                     d = (d + 91) - (m * 3055) % 100\n*                     m = m - 2\n*                     return (m,d,y)\n*\n* See \"Convert_Gregorian_To_Ijuldate\" for the converse of this routine.\n*\n* This routine uses R2-R5 in addition to the usual work registers.\n* These are the only registers saved and restored.\n*\n*---------------------------------------------------------------------*\n block name=Convert_Ijuldate_To_Gregorian,type=subroutine\n  lr    r7,r1                         | Copy parameter list pointer\n  lm    r2,r5,0(r7)                   | Load parameter addresses\n  l     r1,0(,r5)                     | Get Ijulian date\n* *-------------------------------------------------------------------*\n* *                   jy = j % 1000\n* *                   jd = j // 1000\n* *-------------------------------------------------------------------*\n  xr    r0,r0                         | Set up for division\n  d     r0,=f'1000'                   | Divide into years, days\n  st    r1,0(,r4)                     | Return year value now.\n  st    r0,pwa_converter_j            | Save days in local storage\n  lr    r14,r1                        | Save years\n* *-------------------------------------------------------------------*\n* *                   t = 0\n* *                   if (jy // 4) = 0 then t = 1\n* *                   if (jy // 100) = 0 then t = 0\n* *                   if (jy // 400) = 0 then t = 1\n* *-------------------------------------------------------------------*\n  xr    r6,r6                         | Use r6 for \"t\": set to zero\n  xr    r0,r0                         | R1 contains years\n  d     r0,=f'4'                      | Divide years by 4\n  if    (treg,r0,z)                   | If no remainder,\n   la    r6,1                         |  t = 1 for leapyear.\n  endif                               |\n  lr    r1,r14                        | Get years back\n  xr    r0,r0                         |\n  d     r0,=f'100'                    | Divide years by 100:\n  if    (treg,r0,z)                   | If no remainder\n   xr    r6,r6                        |  t = 0 for no leapyear.\n  endif                               |\n  lr    r1,r14                        | Get years back\n  xr    r0,r0                         |\n  d     r0,=f'400'                    | Divide years by 400:\n  if    (treg,r0,z)                   | If no remainder,\n   la    r6,1                         |  t = 1 for leapyear.\n  endif                               |\n* *-------------------------------------------------------------------*\n* *                   d = jd\n* *                   if jd > 59 + t then d = jd + 2 - t\n* *-------------------------------------------------------------------*\n  l     r1,pwa_converter_j            | Get Julian day value\n  la    r0,59                         | Get a 59\n  ar    r0,r6                         | Add whatever t is to it\n  if    (cr,r1,gt,r0)                 | If jd is more than that\n   la    r1,2(,r1)                    |  Add 2, then\n   sr    r1,r6                        |   subtract t.\n  endif                               |\n  st    r1,pwa_converter_d            | Save as d.\n* *-------------------------------------------------------------------*\n* *                   m = ((d + 91) * 100) % 3055\n* *-------------------------------------------------------------------*\n  la    r1,91(,r1)                    | R1 = d: add 91 to it\n  mh    r1,=h'100'                    | Get (d + 91) * 100\n  xr    r0,r0                         | Set up for division\n  d     r0,=f'3055'                   | Divide by 3055, toss remainder\n  st    r1,pwa_converter_m            | Save as m.\n* *-------------------------------------------------------------------*\n* *                   d = (d + 91) - (m * 3055) % 100\n* *                   m = m - 2\n* *-------------------------------------------------------------------*\n  lr    r15,r1                        | Get a copy of m in r15\n  l     r1,pwa_converter_d            | Get d\n  la    r1,91(,r1)                    | R1 = (d + 91)\n  mh    r15,=h'3055'                  | R15 = (m * 3055)\n  xr    r14,r14                       | Set up for division\n  d     r14,=f'100'                   | R15 = (m * 3055) % 100\n  sr    r1,r15                        | R1 = d (the whole thing).\n  st    r1,0(,r3)                     | Return d to caller\n  l     r1,pwa_converter_m            | Get m\n  sh    r1,=h'2'                      | m = m - 2\n  st    r1,0(,r2)                     | Return m to caller\n endblk rc=0                          |\n title \"Convert Gregorian Date To Integer Julian Date\"\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Convert_Gregorian_To_Ijuldate\n*  Abstract:   Convert a Gregorian date into a Julian date.  This is\n*              generally done when preparing a Julian-format date for\n*              output.\n*  Input:      On entry, R1 points to the following parameter list:\n*                + 00 -- Fullword month value to convert\n*                + 04 -- Fullword day value to be convert\n*                + 08 -- Fullword year value to be convert\n*                + 12 -- Fullword Ijulian date to be returned\n*  Output:     Parameter at +12 filled in.\n*\n*  Notes:      . This subroutine uses Algorithm 398, \"Tableless Date\n*                Conversion\", from \"Collected Algorithms From\n*                Communications Of The ACM\".  This procedure is\n*                actually the \"companion\" procedure that converts a\n*                day-of-year given a month, day and year.  The\n*                algorithm (coded as a rexx procedure) works as\n*                follows:\n*\n*                  convert: procedure\n*                   parse upper arg m, d, y\n*                   t = 0\n*                   if (y // 4) = 0 then t = 1\n*                   if (y // 400) = 0 then t = 0\n*                   day = ((3055 * (m + 2)) % 100)        ,  <1>\n*                            - (((m + 10) % 13) * 2 + 91)  , <2>\n*                            + (t * (m + 10) % 13) + d       <3>\n*                   j = y * 1000 + day\n*                   return (j)\n*\n*                (The three lines in the large formula are computed\n*                separately, then combined at the end.)\n*\n*                Note that the original algorithm gave the \"day\"\n*                formula as:\n*                  iday(y,m,d) = 3055*(m+2)/100-(m+10)/13*2-91\n*                         + (1-(y-y/4*4+3)/4 + (y-y/100*100+99/100)\n*                         - (y-y/400*400+399/400) * (m+10)/13+d\n*                The three routines in the middle (.../4, .../100 and\n*                .../400) determine whether it's a leapyear or not,\n*                and introduce a 1 if it's a leapyear and the date\n*                needs adjustment. (I think this is because the author\n*                wanted to be clever and write a one-line routine.)\n*                This is replaced by \"t\", which is derived beforehand.\n*                Also, the constant '91' is added to intermediate value\n*                <2>, which is then subtracted off to produce the final\n*                result.\n*\n* See \"Convert_Ijuldate_To_Gregorian\" for the converse of this routine.\n*\n* This routine uses R2-R7 in addition to the usual work registers.\n* These are the only registers saved and restored.\n*\n*---------------------------------------------------------------------*\n block name=Convert_Gregorian_To_Ijuldate,type=subroutine\n  lr    r7,r1                         | Copy parmlist pointer\n  lm    r2,r5,0(r7)                   | Get parameter addresses\n* *-------------------------------------------------------------------*\n* *                 t = 0\n* *                 if (y // 4) = 0 then t = 1\n* *                 if (y // 100) = 0 then t = 0\n* *                 if (y // 400) = 0 then t = 1\n* *-------------------------------------------------------------------*\n  xr    r6,r6                         | Use R6 as \"t\"\n  l     r1,0(,r4)                     | Get input year value\n  xr    r0,r0                         | Set up for division\n  d     r0,=f'4'                      | If (y // 4) = 0\n  if    (treg,r0,z)                   |\n   la    r6,1                         |   then t = 1.\n  endif                               |\n  l     r1,0(,r4)                     | Get year value back\n  xr    r0,r0                         | Set up for division\n  d     r0,=f'100'                    | If (y // 100) = 0\n  if    (treg,r0,z)                   |\n   xr    r6,r6                        |   then t = 0.\n  endif                               |\n  l     r1,0(,r4)                     | Get year value back\n  xr    r0,r0                         | Set up for division\n  d     r0,=f'400'                    | If (y // 400) = 0\n  if    (treg,r0,z)                   |\n   la    r6,1                         |   then t = 1.\n  endif                               |\n* *-------------------------------------------------------------------*\n* *                 day = ((3055 * (m + 2)) % 100)        ,  <1>\n* *                          - (((m + 10) % 13) * 2 + 91) ,  <2>\n* *                          + (t * (m + 10) % 13) + d       <3>\n* *-------------------------------------------------------------------*\n  l     r1,0(,r2)                     | Step <1>:\n  la    r1,2(,r1)                     | Get month value, add 2\n  mh    r1,=h'3055'                   | Multiply by 3055\n  xr    r0,r0                         |\n  d     r0,=f'100'                    | Divide by 100; ignore remainder\n  st    r1,pwa_converter_work         | Save intermediate result.\n* *-------------------------------------------------------------------*\n  l     r1,0(,r2)                     | Step <2>:\n  la    r1,10(,r1)                    | Get month value ,add 10\n  xr    r0,r0                         | Set up for division\n  d     r0,=f'13'                     | Divide by 13, toss remainder\n  lr    r15,r1                        | Save ((m + 10) % 13) in r15\n  sll   r1,1                          | Multiply by 2\n  ah    r1,=h'91'                     | << Is this in the right place?\n  st    r1,pwa_converter_work2        | Save intermediate result.\n* *-------------------------------------------------------------------*\n  lr    r1,r15                        | Step <3>:\n  mr    r0,r6                         | Get ((m + 10) % 13) * t\n  a     r1,0(,r3)                     | Add \"d\": R1 is 3rd intermediate\n* *-------------------------------------------------------------------*\n  a     r1,pwa_converter_work         | Add 1st intermediate value\n  s     r1,pwa_converter_work2        | Subtract 2nd intermediate value\n  l     r15,0(,r4)                    | Get year from caller\n  mh    r15,=h'1000'                  | Decimal shift\n  ar    r15,r1                        | Add days we derived\n  st    r15,0(,r5)                    | Return ijulian date to caller.\n* *-------------------------------------------------------------------*\n endblk rc=0                          |\n space 1                              |\n title \"Convert Gregorian Date To Number Of Days Since 1/1/0000\"\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Convert_Gregorian_To_Days\n*  Abstract:   Convert a Gregorian date to the number of days since\n*              January 1, 0000.\n*  Input:      On entry, R1 points to the following parameter list:\n*                +00 -- Address of \"m\": fullword month value\n*                +04 -- Address of \"d\": fullword day within month\n*                +08 -- Address of \"y\": fullword year value\n*                +12 -- Address of \"j\": fullword to return # days in.\n*  Output:     Parameter \"j\" at parmlist+12 filled in.\n*\n*  Notes:      . This subroutine uses Algorithm 199, \"Conversions\n*                Between Calendar Date And Julian Day Number\", from\n*                \"Collected Algorithms From Communications Of The ACM\".\n*                Procedure \"JDAY\" is used here to convert a Gregorian\n*                date (months, days, and year) into the number of days\n*                since Jan. 1, 0000.  Note that the constant '1721119',\n*                which would convert a Gregorian date to a true Julian\n*                number of days, is not used here.\n*\n*                Procedure JDAY works as follows:\n*                  If M > 2 then M = M - 3;\n*                  Else Do;\n*                    M = M + 9;\n*                    Y = Y - 1;\n*                  End;\n*                  C = Y / 100;  YA = Y - (100 * C);\n*                  J = (146097 * C)/4 + (1461 * YA)/4 +\n*                      ((153 * M) + 2)/5 + D;\n*                  Return (J);\n*\n* See \"Convert_Days_To_Gregorian\" for the converse of this routine.\n*\n* This routine uses R2-R5 in addition to the usual work registers.\n* These are the only registers saved and restored.\n*\n*---------------------------------------------------------------------*\n block name=Convert_Gregorian_To_Days,type=subroutine,                 *\n               options=(*nosubopts),                                   *\n               save=(r2,r5,pwa_iconvert_regs)\n  lr    r5,r1                         | Save parmlist pointer\n  lm    r2,r4,0(r5)                   | Get addresses of m, d, and y\n  mvc   pwa_converter_m,0(r2)         | Copy month value to workarea\n  mvc   pwa_converter_d,0(r3)         | Copy day value to workarea\n  mvc   pwa_converter_y,0(r4)         | Copy year value to workarea\n*---------------------------------------------------------------------*\n*                  If M > 2 then M = M - 3;\n*                  Else Do;\n*                    M = M + 9;\n*                    Y = Y - 1;\n*                  End;\n*---------------------------------------------------------------------*\n  l     r1,pwa_converter_m            | Get M\n  if    (ch,r1,gt,=h'2')              | If M > 2\n   sh    r1,=h'3'                     |  M = M - 3\n  else                                | Else Do\n   la    r1,9(,r1)                    |  M = M + 9\n   l     r15,pwa_converter_y          |  Get Y\n   bctr  r15,0                        |  Y = Y - 1\n   st    r15,pwa_converter_y          |  Put Y back\n  endif                               | End\n  st    r1,pwa_converter_m            | Put M back regardless\n*---------------------------------------------------------------------*\n*                  C = Y / 100;  YA = Y - (100 * C);\n*---------------------------------------------------------------------*\n  xr    r0,r0                         | Clear even reg for division\n  l     r1,pwa_converter_y            | Get Y\n  d     r0,=f'100'                    | C = Y / 100\n  st    r1,pwa_converter_c            | Put quotient in C.\n  mh    r1,=h'100'                    | YA = Y - (100 * C)\n  l     r15,pwa_converter_y           | Get Y\n  sr    r15,r1                        | Subtract (100 * C)\n  st    r15,pwa_converter_ya          | Save as YA.\n*---------------------------------------------------------------------*\n*                  J = (146097 * C)/4 + (1461 * YA)/4 +\n*                      ((153 * M) + 2)/5 + D;\n*---------------------------------------------------------------------*\n*   (1). Compute (146097 * C) / 4\n*---------------------------------------------------------------------*\n  l     r1,pwa_converter_c            | Get C\n  m     r0,=f'146097'                 | Multiply by 146097\n  srl   r1,2                          | Cheap divide by 4\n  st    r1,pwa_converter_work         | Save intermediate result.\n*---------------------------------------------------------------------*\n*   (2). Compute (1461 * YA) / 4\n*---------------------------------------------------------------------*\n  l     r1,pwa_converter_ya           | Get YA\n  mh    r1,=h'1461'                   | Multiply\n  srl   r1,2                          | Cheap divide by 4\n  a     r1,pwa_converter_work         | Add to intermediate result.\n  st    r1,pwa_converter_work         |\n*---------------------------------------------------------------------*\n*   (3). Compute ((153 * M) + 2) / 5  + D\n*---------------------------------------------------------------------*\n  l     r1,pwa_converter_m            | Get M\n  mh    r1,=h'153'                    | Multiply\n  la    r1,2(,r1)                     | Add 2\n  xr    r0,r0                         | Clear even reg for division\n  d     r0,=f'5'                      | Divide by 5\n  a     r1,pwa_converter_d            | Add D\n*---------------------------------------------------------------------*\n*   Return (j)\n*---------------------------------------------------------------------*\n  a     r1,pwa_converter_work         | Add accumulator\n  l     r15,12(,r5)                   | Get pointer to j from parms\n  st    r1,0(,r15)                    | Return j to caller\n endblk rc=0                          |\n space 1                              |\n title \"Convert Number Of Days Since 1/1/0000 To Gregorian Date\"\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Convert_Days_To_Gregorian\n*  Abstract:   Convert a the number of days since January 1, 0000 to a\n*              Gregorian date.\n*  Input:      On entry, R1 points to the following parameter list:\n*                +00 -- Address of \"m\": fullword month value to return\n*                +04 -- Address of \"d\": fullword day of month to return\n*                +08 -- Address of \"y\": fullword year value to return\n*                +12 -- Address of \"j\": fullword number of days.\n*  Output:     Parameters \"m\", \"d\", \"y\" filled in.\n*\n*  Notes:      . This subroutine uses Algorithm 199, \"Conversions\n*                Between Calendar Date And Julian Day Number\", from\n*                \"Collected Algorithms From Communications Of The ACM\".\n*                Procedure \"JDATE\" is used here to convert the number\n*                of days since Jan. 1, 0000 to a Gregorian date.  Note\n*                Note that the constant '1721119', which would convert\n*                the true Julian number of days into a Gregorian date,\n*                is not used here.\n*\n*                Procedure JDATE works as follows:\n*                  y = ((4 * j) - 1) / 146097;\n*                  j = (4 * j) - 1 - (146097 * y);\n*                  d = j / 4;\n*                  j = ((4 * d) + 3) / 1461;\n*                  d = (4 * d) + 3 - (1461 * j);\n*                  d = (d + 4) / 4;\n*                  m = ((5 * d) - 3) / 153;\n*                  d = (5 * d) - 3 - (153 * m);\n*                  d = (d + 5) / 5;\n*                  y = (100 * y) + j;\n*                  if m < 10 then m = m + 3;\n*                  else do;\n*                    m = m - 9;\n*                    y = y + 1\n*                  end;\n*                  return (m, d, y);\n*\n* See \"Convert_Gregorian_To_Days\" for the converse of this routine.\n*\n* This routine uses R2-R5 in addition to the usual work registers.\n* These are the only registers saved and restored.\n*\n*---------------------------------------------------------------------*\n block name=Convert_Days_To_Gregorian,type=subroutine,                 *\n               options=(*nosubopts),                                   *\n               save=(r2,r5,pwa_iconvert_regs)\n  lr    r5,r1                         | Save parmlist pointer\n  l     r1,12(,r5)                    | Get address of J\n  mvc   pwa_converter_j,0(r1)         | Copy J to local variable\n*---------------------------------------------------------------------*\n*                  y = ((4 * j) - 1) / 146097;\n*                  j = (4 * j) - 1 - (146097 * y);\n*                  d = j / 4;\n*  Note: If an input date of zero is passed, the value returned is\n*        forced to Jan. 1, 0000.  If a date of zero is allowed to go\n*        through the formula, unusual things occur.\n*---------------------------------------------------------------------*\n*                                     | y = ((4 * j) - 1) / 146097:\n  l32   r1,pwa_converter_j            | Get j\n  if    (z)                           |-------------------------------*\n   lm    r2,r4,0(r5)                  | If input date is zero, force\n   la    r1,1                         |  results to 1/1/0000 and exit.\n   xr    r0,r0                        |\n   st    r1,0(,r2)                    |   Set month to 1\n   st    r1,0(,r3)                    |   Set day to 1\n   st    r0,0(,r4)                    |   Set year to zero\n   leave block=*                      |     and exit.\n  endif                               |-------------------------------*\n  sll   r1,2                          | Cheap multiply by 4\n  bctr  r1,0                          | Subtract 1\n  lr    r2,r1                         | Save intermediate result\n  xr    r0,r0                         | Clear R0 for division\n  d     r0,=f'146097'                 | Divide by 146097\n  st    r1,pwa_converter_y            | Save quotient in Y.\n*                                     | j = (4 * j) - 1 - (146097 * y):\n  m     r0,=f'146097'                 | As long as we got Y in R1 ...\n  sr    r2,r1                         | And (4 * j) - 1 in R2 ...\n  st    r2,pwa_converter_j            | Save new value of j.\n*                                     | d = j / 4\n  srl   r2,2                          | As long as we got j in R2,\n  st    r2,pwa_converter_d            | divide by 4 and stuff it.\n*---------------------------------------------------------------------*\n*                  j = ((4 * d) + 3) / 1461;\n*                  d = (4 * d) + 3 - (1461 * j);\n*                  d = (d + 4) / 4;\n*---------------------------------------------------------------------*\n*                                     | j = ((4 * d) + 3) / 1461\n  lr    r1,r2                         | As long as we got d in R2\n  sll   r1,2                          | (d * 4)\n  la    r1,3(,r1)                     | Add 3\n  lr    r2,r1                         | Save intermediate value\n  xr    r0,r0                         | Clear R0 for division\n  la    r15,1461                      | Shame there's no DH instruction\n  dr    r0,r15                        | Divide by 1461\n  st    r1,pwa_converter_j            | Stuff quotient in J.\n*                                     | d = (4 * d) + 3 - (1461 * j)\n  mh    r1,=h'1461'                   | R1 = (1461 * j)\n  sr    r2,r1                         | R2 = (d * 4) + 3; now R2 = d\n*                                     | d = (d + 4) / 4\n  la    r2,4(,r2)                     | Add 4 to \"d\"\n  srl   r2,2                          | Cheap divide by 4\n  st    r2,pwa_converter_d            | Save value of d.\n*---------------------------------------------------------------------*\n*                  m = ((5 * d) - 3) / 153;\n*                  d = (5 * d) - 3 - (153 * m);\n*                  d = (d + 5) / 5;\n*---------------------------------------------------------------------*\n*                                     | m = ((5 * d) - 3) / 153;\n  lr    r1,r2                         | As long as we got d in R2 ...\n  mh    r1,=h'5'                      | (d * 5)\n  sh    r1,=h'3'                      | Subtract 3\n  lr    r2,r1                         | Save intermediate value\n  xr    r0,r0                         | Clear R0 for division\n  la    r15,153                       | Shame there's no DH instruction\n  dr    r0,r15                        | Divide by 153\n  st    r1,pwa_converter_m            | Stuff quotient in J.\n*                                     | d = (5 * d) - 3 - (153 * m);\n  mh    r1,=h'153'                    | R1 = (153 * m)\n  sr    r2,r1                         | R2 = (5 * d) - 3; now R2 = d\n*                                     | d = (d + 5) / 5;\n  la    r1,5(,r2)                     | Add 5 to \"d\"\n  xr    r0,0                          | Clear R0 for division\n  d     r0,=f'5'                      | Divide by 5\n  st    r1,pwa_converter_d            | Save value of d.\n*---------------------------------------------------------------------*\n*                  y = (100 * y) + j;\n*---------------------------------------------------------------------*\n  l     r1,pwa_converter_y            | Get value of y\n  mh    r1,=h'100'                    | (100 * y)\n  a     r1,pwa_converter_j            | Add j\n  st    r1,pwa_converter_y            | Save value of y.\n*---------------------------------------------------------------------*\n*                  if m < 10 then m = m + 3;\n*                  else do;\n*                    m = m - 9;\n*                    y = y + 1\n*                  end;\n*---------------------------------------------------------------------*\n  l     r1,pwa_converter_m            | Get value of m\n  if    (ch,r1,lt,=h'10')             | If m < 10\n   la    r1,3(,r1)                    |   Add 3 to it\n  else                                | Else do:\n   sh    r1,=h'9'                     |   Subtract 9\n   l     r15,pwa_converter_y          |   Add 1 to y.\n   la    r15,1(,r15)                  |\n   st    r15,pwa_converter_y          |\n  endif                               |\n  st    r1,pwa_converter_m            | Save m regardless.\n*---------------------------------------------------------------------*\n*                  return (m, d, y);\n*---------------------------------------------------------------------*\n  lm    r2,r4,0(r5)                   | Get pointers to m, d, y parms\n  mvc   0(4,r2),pwa_converter_m       | Return m to caller\n  mvc   0(4,r3),pwa_converter_d       | Return d to caller\n  mvc   0(4,r4),pwa_converter_y       | Return y to caller\n endblk ,                             | That's it.\n title \"General Error Exit: Save Info In Debug Area\"\n*---------------------------------------------------------------------*\n*\n*  Errexit:    Unnamed\n*  Purpose:    Save debugging information and exit with the return\n*              code pointed to by r14 at entry to this exit.\n*  Notes:      For some cases, various registers may point to info we\n*              want to display.  For example, when the MSGMOD errors\n*              are detected, R4 points to the module name in error.\n*\n*---------------------------------------------------------------------*\n         SPACE 1                      |\n block type=errexit                   |\n* es_display_debug_info_and_abend id=es << TESTING >>\n* *-------------------------------------------------------------------*\n* * Save module/offset, registers, return-code.\n* *-------------------------------------------------------------------*\n  st    r15,pwa_reason                | Save possible return-code.\n  stm   r0,r15,gdiregs                | Save registers at time of error\n  la    r0,4(,r12)                    | Point to module identification.\n  st    r0,gdimodid                   | Save in general debug area.\n  mvc   gdirc,0(r14)                  | Copy return code.\n  slr   r14,r12                       | Calculate offset at time of err\n  sth   r14,gdioffst                  | Save in debug area.\n  l     r2,pwaaesv                    | Point r2 to ESV.\n  using esv,r2                        | Establish base for ESV.\n  callx esvesepa,(esvestkn,&es_save_debug_info,&es_debug_id_gdi,gdi)\n* *-------------------------------------------------------------------*\n* * Look at the error code.  If add'l information would be useful,\n* * stuff into the debug area.\n* *-------------------------------------------------------------------*\n  lh    r15,gdirc                     | Get return code.\n  caseblk reg=r15,mult=1              | Case on return-code.\n    case &dt_invalid_function         |\n      callx esvesepa,(esvestkn,&es_save_debug_info,&es_debug_id_text,  *\n               psd_invalid_function,=a(l'psd_invalid_function))\n    case &dt_invalid_number_of_parms  |\n      callx esvesepa,(esvestkn,&es_save_debug_info,&es_debug_id_text,  *\n               psd_invalid_#_parms,=a(l'psd_invalid_#_parms))\n    case &dt_invalid_dt_id            |\n      callx esvesepa,(esvestkn,&es_save_debug_info,&es_debug_id_text,  *\n               psd_invalid_dt_id,=a(l'psd_invalid_dt_id))\n    case &dt_environment_support_error\n      callx esvesepa,(esvestkn,&es_save_debug_info,&es_debug_id_text,  *\n               psd_env_support_error,=a(l'psd_env_support_error))\n    case &dt_string_handler_error     |\n      callx esvesepa,(esvestkn,&es_save_debug_info,&es_debug_id_text,  *\n               psd_string_handler_error,=a(l'psd_string_handler_error))\n    case &dt_invalid_date_format      |\n      callx esvesepa,(esvestkn,&es_save_debug_info,&es_debug_id_text,  *\n               psd_invalid_date_format,=a(l'psd_invalid_date_format))\n    case &dt_invalid_time_format      |\n      callx esvesepa,(esvestkn,&es_save_debug_info,&es_debug_id_text,  *\n               psd_invalid_time_format,=a(l'psd_invalid_time_format))\n    case &dt_invalid_interval_format  |\n      callx esvesepa,(esvestkn,&es_save_debug_info,&es_debug_id_text,  *\n               psd_invalid_interval_format,                            *\n               =a(l'psd_invalid_interval_format))\n    case &dt_invalid_input_time       |\n      callx esvesepa,(esvestkn,&es_save_debug_info,&es_debug_id_text,  *\n               psd_invalid_input_time,=a(l'psd_invalid_input_time))\n    case &dt_invalid_input_date       |\n      callx esvesepa,(esvestkn,&es_save_debug_info,&es_debug_id_text,  *\n               psd_invalid_input_date,=a(l'psd_invalid_input_date))\n    case &dt_invalid_input_interval   |\n      callx esvesepa,(esvestkn,&es_save_debug_info,&es_debug_id_text,  *\n               psd_invalid_input_interval,                             *\n               =a(l'psd_invalid_input_interval))\n    case &dt_overflow                 |\n      callx esvesepa,(esvestkn,&es_save_debug_info,&es_debug_id_text,  *\n               psd_overflow,          |                                *\n               =a(l'psd_overflow))    |\n    case &dt_out_of_range             |\n      callx esvesepa,(esvestkn,&es_save_debug_info,&es_debug_id_text,  *\n               psd_out_of_range,      |                                *\n               =a(l'psd_out_of_range))\n    case other                        |  Don't bother w/other errors.\n      callx esvesepa,(esvestkn,&es_save_debug_info,&es_debug_id_text,  *\n               psd_undetermined_error,=a(l'psd_undetermined_error))\n  endcase                             | EndCase.\n  drop r2                             |\n* *-------------------------------------------------------------------*\n* * Set the return-code and exit.\n* *-------------------------------------------------------------------*\n  lh    r15,gdirc                     | Set return code.\n endblk rc=(r15)                      |\n eject                                |\n title \"Program Static Data\"          |\n                psd                   |\neyecatcher      dc   cl8\"DT_SP\"       | Eyecatcher value for dumps.\n*                                     |\npsd_mics_lower_limit dc xl8'00d4ff0e7fb74000' Jan. 1, 1900 @00:00:00.00\npsd_mics_circa_1970  dc xl8'00dcd81ec873e000' Jan  1, 1970 @00:00:00.00\npsd_mics_upper_limit dc xl8'00e4ff0e7fb73e10' Sep 17, 2042 @23:53:47.37\n*                                     |\npsd_month_table ds   0cl11            |\n         dc   al2(01),cl9\"January  \"  |\n         dc   al2(02),cl9\"February \"  |\n         dc   al2(03),cl9\"March    \"  |\n         dc   al2(04),cl9\"April    \"  |\n         dc   al2(05),cl9\"May      \"  |\n         dc   al2(06),cl9\"June     \"  |\n         dc   al2(07),cl9\"July     \"  |\n         dc   al2(08),cl9\"August   \"  |\n         dc   al2(09),cl9\"September\"  |\n         dc   al2(10),cl9\"October  \"  |\n         dc   al2(11),cl9\"November \"  |\n         dc   al2(12),cl9\"December \"  |\n*                                     |\npsd_weekday_table  ds    0cl10        | Jan. 1 0000 was a Tuesday\n         dc   al1(0),cl9\"Tuesday  \"   |\n         dc   al1(1),cl9\"Wednesday\"   |\n         dc   al1(2),cl9\"Thursday \"   |\n         dc   al1(3),cl9\"Friday   \"   |\n         dc   al1(4),cl9\"Saturday \"   |\n         dc   al1(5),cl9\"Sunday   \"   |\n         dc   al1(6),cl9\"Monday   \"   |\n*                                     |\npsd_numeric_table  dc   256x'ff'      | Numeric translate-n-test table\n          org  psd_numeric_table+c'0' | Set table to find anything\n          dc   10x'00'                |  but c'0'-c'9'.\n          org  ,                      |\n*---------------------------------------------------------------------*\n*\n*  The packed-decimal translate-and-test table works as follows:\n*    .. Valid non-sign bytes have a value of x'00' in the table.\n*    .. Valid sign bytes have a value of x'08' in the table. These\n*       should only occur as the last byte in the field being tested.\n*    .. All other bytes have a value of x'04' in the table. If one of\n*       these is found, the packed-decimal number is not legal.\n*  The table is used by macro \"Validate_Packed_Data\".\n*\n*---------------------------------------------------------------------*\n*                          0 1 2 3 4 5 6 7 8 9 a b c d e f\npsd_packed_table dc  xl16'00000000000000000000080808080808' 0\n                 dc  xl16'00000000000000000000080808080808' 1\n                 dc  xl16'00000000000000000000080808080808' 2\n                 dc  xl16'00000000000000000000080808080808' 3\n                 dc  xl16'00000000000000000000080808080808' 4\n                 dc  xl16'00000000000000000000080808080808' 5\n                 dc  xl16'00000000000000000000080808080808' 6\n                 dc  xl16'00000000000000000000080808080808' 7\n                 dc  xl16'00000000000000000000080808080808' 8\n                 dc  xl16'00000000000000000000080808080808' 9\n                 dc  xl16'04040404040404040404040404040404' a\n                 dc  xl16'04040404040404040404040404040404' b\n                 dc  xl16'04040404040404040404040404040404' c\n                 dc  xl16'04040404040404040404040404040404' d\n                 dc  xl16'04040404040404040404040404040404' e\n                 dc  xl16'04040404040404040404040404040404' f\npsd_default_century      dc  c\"19\"    |\npsd_invalid_function     dc  c\"Unsupported function.\"\npsd_invalid_#_parms      dc  c\"Invalid number of parameters.\"\npsd_invalid_dt_id        dc  c\"Invalid token provided.\"\npsd_env_support_error    dc  c\"Environment support error.\"\npsd_string_handler_error dc  c\"String handler error.\"\npsd_invalid_time_format  dc  c\"Unsupported time format.\"\npsd_invalid_date_format  dc  c\"Unsupported date format.\"\npsd_invalid_interval_format  dc  c\"Unsupported interval format.\"\npsd_invalid_input_time  dc  c\"Invalid time value for specified format.\"\npsd_invalid_input_date  dc  c\"Invalid date value for specified format.\"\npsd_invalid_input_interval dc  c\"Invalid interval value for specified f*\n               ormat.\"\npsd_overflow             dc  c\"Output value is too large for requested *\n               format.\"\npsd_out_of_range         dc  c\"Date/time value is not within acceptable*\n                range for requested format.\"\npsd_undetermined_error   dc  c\"Undetermined error.\"\n*                                     |\n                ltorg ,               |\n                endpsd                |\n title \"Dsects\"                       |\n          es_esv ,                    |\n          space 2                     |\n*---------------------------------------------------------------------*\n*  Converter Parameter List DSECT.  This parameter list is common to\n*  all conversion routines.  It is generally built by a CALLSUB in the\n*  mainline, then based in each converter subroutine as necessary.\n*---------------------------------------------------------------------*\ncpl       dsect ,                     | Converter Parameter List:\ncpl_internal     ds   a               |   Internal-format time value\ncpl_interval     ds   0a              |   Interval to convert from/to\ncpl_date         ds   a               |   Date to convert from or to\ncpl_interval_format ds  0a            |   Format of interval\ncpl_date_format  ds   a               |   Format of date\ncpl_time         ds   a               |   Time to convert from or to\ncpl_time_format  ds   a               |   Format of time\n*---------------------------------------------------------------------*\n*  Month Table DSECT.  Used to map psd_month_table for month lookups.\n*---------------------------------------------------------------------*\nmonth_table dsect ,                   |\nmt_month_num   ds   al2               | Character month number\nmt_month_name  ds   cl9               | Character name of month\nmt_length      equ  *-month_table     | Length of a month table entry\nmt_#_entries   equ  12                | Number of month table entries\n*                                     |  (until the calendar changes)\n          eject                       |\n title \"Parameter List\"               |\nparmlist                      dsect , |\nprm_DT_id                     ds a    | DT_identifier === PWA base\nprm_functioncode              ds a    | Function to be performed\nprm_min_#                     equ (*-parmlist)/4\nprm_function_dept             equ *   | Function-dependent parameters\n*---------------------------------------------------------------------*\n*\n*                  Start function parameters\n*\n*---------------------------------------------------------------------*\n                  org prm_function_dept\nprm_start_esv                 ds a    | Environment Support Vector.\nprm_start_min_#               equ (*-parmlist)/4\nprm_start_options             ds a    | Address of option byte\nprm_start_max_#               equ (*-parmlist)/4\n*---------------------------------------------------------------------*\n*\n*                 Terminate function parameters\n*\n*---------------------------------------------------------------------*\n               org prm_function_dept  |\nprm_terminate_#               equ (*-parmlist)/4\n*---------------------------------------------------------------------*\n*\n*                 Get_Current function parameters\n*\n*---------------------------------------------------------------------*\n               org prm_function_dept  |\nprm_get_current   ds    0f            | Parameters for DT_GET_CURRENT.\n*                                     | Note: The order of these para-\n*                                     | meters must not change, unless\n*                                     | the instruction commented as\n*                                     | <<Format-dependent>> changes.\nprm_get_current_date          ds   a  |\nprm_get_current_date_format   ds   a  |\nprm_get_current_time          ds   a  |\nprm_get_current_time_format   ds   a  |\nprm_get_current_#             equ (*-parmlist)/4\n*---------------------------------------------------------------------*\n*\n*                  Convert function parameters\n*\n*---------------------------------------------------------------------*\n                org prm_function_dept |\nprm_convert       ds    0f            | Parameters for DT_CONVERT.\n*                                     | Note: The order of these para-\n*                                     | meters must not change, unless\n*                                     | the instruction commented as\n*                                     | <<Format-dependent>> changes.\nprm_convert_fromdate          ds   a  |\nprm_convert_fromdate_format   ds   a  |\nprm_convert_fromtime          ds   a  |\nprm_convert_fromtime_format   ds   a  |\nprm_convert_todate            ds   a  |\nprm_convert_todate_format     ds   a  |\nprm_convert_totime            ds   a  |\nprm_convert_totime_format     ds   a  |\nprm_convert_#                 equ (*-parmlist)/4\n*---------------------------------------------------------------------*\n*\n*                     Add function parameters\n*\n*---------------------------------------------------------------------*\n                org prm_function_dept |\nprm_add           ds    0f            | Parameters for DT_ADD\n*                                     | Note: The order of these para-\n*                                     | meters must not change, unless\n*                                     | the instruction commented as\n*                                     | <<Format-dependent>> changes.\nprm_add_datein                ds   a  |\nprm_add_datein_format         ds   a  |\nprm_add_timein                ds   a  |\nprm_add_timein_format         ds   a  |\nprm_add_interval              ds   a  |\nprm_add_interval_format       ds   a  |\nprm_add_dateout               ds   a  |\nprm_add_dateout_format        ds   a  |\nprm_add_timeout               ds   a  |\nprm_add_timeout_format        ds   a  |\n*---------------------------------------------------------------------*\n*\n*                   Subtract function parameters\n*\n*---------------------------------------------------------------------*\n                org prm_function_dept |\nprm_subtract      ds    0f            | Parameters for DT_SUBTRACT\n*                                     | Note: The order of these para-\n*                                     | meters must not change, unless\n*                                     | the instruction commented as\n*                                     | <<Format-dependent>> changes.\nprm_subtract_datein           ds   a  |\nprm_subtract_datein_format    ds   a  |\nprm_subtract_timein           ds   a  |\nprm_subtract_timein_format    ds   a  |\nprm_subtract_interval         ds   a  |\nprm_subtract_interval_format  ds   a  |\nprm_subtract_dateout          ds   a  |\nprm_subtract_dateout_format   ds   a  |\nprm_subtract_timeout          ds   a  |\nprm_subtract_timeout_format   ds   a  |\n*---------------------------------------------------------------------*\n*\n*                   Duration function parameters\n*\n*---------------------------------------------------------------------*\n                org prm_function_dept |\nprm_duration      ds    0f            | Parameters for DT_duration\n*                                     | Note: The order of these para-\n*                                     | meters must not change, unless\n*                                     | the instruction commented as\n*                                     | <<Format-dependent>> changes.\nprm_duration_date1            ds   a  |\nprm_duration_date1_format     ds   a  |\nprm_duration_time1            ds   a  |\nprm_duration_time1_format     ds   a  |\nprm_duration_date2            ds   a  |\nprm_duration_date2_format     ds   a  |\nprm_duration_time2            ds   a  |\nprm_duration_time2_format     ds   a  |\nprm_duration_duration         ds   a  |\nprm_duration_duration_format  ds   a  |\n*---------------------------------------------------------------------*\n                  org ,               |\nprm_max_len       equ   *-parmlist    |\nprm_max_#         equ  (*-parmlist)/4 |\n*                                     |\n title \"Program Work Area\"            |\n               PWA                    |\npwa_area       ds    0f               | Beginning of visible PWA stg.\npwa_visual     ds    cl8              | Character string 'DIV_SP'.\npwa_DT_id      ds    a                | Pointer to program work area.\npwa_clear_start equ  *                | This area cleared by DT_START.\npwa_ES_epa     ds    f                | Environment Support EPA.\npwa_ES_token   ds    f                | Environment Support PWA token.\npwa_ESV        ds    f                | Environment Support vector addr\npwa_ST_epa     ds    f                | String Formatter EPA.\npwa_ST_token   ds    f                | String Formatter PWA token.\n*                                     |  is that spec'd by SizeLength.\npwa_clear_end  equ  *                 | End area cleared by DT_START.\npwa_clear_length   equ   pwa_clear_end-pwa_clear_start\n*                                     |\npwa_validate_r14      ds  f           | Validate rtns save R14 here\npwa_call_convert_r14  ds  f           | Call_Convert rtns save R14 here\npwa_converter_R14     ds  f           | Convert_From, _To routines' R14\npwa_iconvert_regs     ds  6f          | Convert_Gregorian_To_Ijuldate,\n*                                     |  Convert_Ijuldate_To_Gregorian\n*                                     |   save their registers here.\n*                                     |\n*---------------------------------------------------------------------*\n*  Assorted work variables.\n*---------------------------------------------------------------------*\npwa_converter_d   ds  f               | These are used by routines\npwa_converter_m   ds  f               | Convert_Gregorian_To_Ijuldate &\npwa_converter_y   ds  f               |  Convert_Ijuldate_To_Gregorian.\npwa_converter_ya  ds  f               |\npwa_converter_c   ds  f               |\npwa_converter_work ds f               |\npwa_converter_work2 ds f              |\npwa_converter_j   ds  f               |\n*---------------------------------------------------------------------*\npwa_ES_current_date  ds   f           |\npwa_ES_current_time  ds   f           |\npwa_DT_format_time   ds   d           |\npwa_DT_format_time2  ds   d           |\npwa_DT_format_interval ds d           |\npwa_d                ds   d           | Work doubleword.\npwa_f                ds   f           | Work word.\npwa_i_month          ds   f           |\npwa_i_day            ds   f           |\npwa_i_year           ds   f           |\npwa_interval_numbers     ds   0f      |\npwa_number_of_days       ds   f       |\npwa_number_of_hours      ds   f       |\npwa_number_of_minutes    ds   f       |\npwa_number_of_seconds    ds   f       |\npwa_number_of_hundredths ds   f       |\nl_interval_numbers       equ  *-pwa_interval_numbers\npwa_actual_format    ds   f           |\n*pwa_convert_parameters ds cl16        |\npwa_edit             ds   cl16        | Place to EDIT stuff.\npwa_packed_validation ds  cl16        |\npwa_text_month       ds   cl9         |\npwa_text_weekday     ds   cl9         |\npwa_numeric_month    ds   cl2         |\npwa_numeric_day      ds   cl2         |\npwa_numeric_year     ds   cl4         |\npwa_numeric_hour     ds   cl2         |\npwa_numeric_minute   ds   cl2         |\npwa_numeric_second   ds   cl2         |\npwa_numeric_hundredths ds cl2         |\npwa_civilian_hour    ds   cl2         |\n*                                     |\npwa_reason     ds    f                |\npwa_number_of_parms ds  f             | Number of parms.\npwa_format_length   ds  h             |\npwa_format_string   ds  cl40          |\n*                                     |\npwaf1        ds    x                  | General flag byte:\npwaf1sst     equ   x'80' |1... ....|  | .. String Handler started\npwaf1eur     equ   x'40' |.1.. ....|  | .. English-fmt Gregorian dates\npwaf1lz      equ   x'20' |..1. ....|  | .. Leading zeros on everything\npwaf1rev     equ   x'10' |...1 ....|  | .. Sign reversed, ADD=SUB, etc:\n*                                     |    see DT_ADD, DT_SUBTRACT in\n*                                     |    main CASEBLK.\n*                                     |\npwa_flags    ds    0c                 |\n*                                     |\npwa_julian_flags        ds   x        |\npwa_julian              equ  x'80'    |\npwa_juliand             equ  x'40'    |\npwa_ijulian             equ  x'20'    |\npwa_pjulian             equ  x'10'    |\npwa_sjulian             equ  x'08'    |\npwa_sjuliand            equ  x'04'    |\n*                                     |\npwa_gregorian_flags     ds   x        |\npwa_gregorian           equ  x'80'    |\npwa_sgregorian          equ  x'40'    |\npwa_sortdate            equ  x'20'    |\npwa_ssortdate           equ  x'10'    |\n*                                     |\npwa_normal_flags        ds   x        |\npwa_normal              equ  x'80'    |\npwa_snormal             equ  x'40'    |\npwa_sasdate7            equ  x'20'    |\npwa_sasdate9            equ  x'10'    |\npwa_yyyymmmdd           equ  x'08'    |                             @cx\n*                                     |\npwa_text_flags          ds   x        |\npwa_text                equ  x'80'    |\npwa_textd               equ  x'40'    |\npwa_weekday             equ  x'20'    |\npwa_weekday3            equ  x'10'    |\n*                                     |\npwa_day_flags           ds   x        |\npwa_days                equ  x'80'    |\npwa_pdays               equ  x'40'    |\npwa_idays               equ  x'20'    |\n*                                     |\npwa_year_flags           ds   x       |\npwa_year                 equ  x'80'   |\npwa_year2                equ  x'40'   |\npwa_pyear                equ  x'20'   |\npwa_iyear                equ  x'10'   |\n*                                     |\npwa_month_flags         ds   x        |\npwa_month               equ  x'80'    |\npwa_pmonth              equ  x'40'    |\npwa_imonth              equ  x'20'    |\npwa_monthname           equ  x'10'    |\npwa_monthname3          equ  x'08'    |\n*                                     |\npwa_hour_flags          ds   x        |\npwa_hours               equ  x'80'    |\npwa_phours              equ  x'40'    |\npwa_ihours              equ  x'20'    |\n*                                     |\npwa_minute_flags        ds   x        |\npwa_minutes             equ  x'80'    |\npwa_pminutes            equ  x'40'    |\npwa_iminutes            equ  x'20'    |\n*                                     |\npwa_second_flags        ds   x        |\npwa_seconds             equ  x'80'    |\npwa_pseconds            equ  x'40'    |\npwa_iseconds            equ  x'20'    |\n*                                     |\npwa_hundredth_flags     ds   x        |\npwa_hundredths          equ  x'80'    |\npwa_phundredths         equ  x'40'    |\npwa_ihundredths         equ  x'20'    |\n*                                     |\npwa_hhmmss_flags        ds   x        |\npwa_hhmm                equ  x'80'    | HH:MM format\npwa_hhmmss              equ  x'40'    | HH:MM:SS format\npwa_hhmmssth            equ  x'20'    | HH:MM:SS.TH format\npwa_civilian            equ  x'10'    | Civilian (HH:MM:SS AM/PM)\npwa_afternoon           equ  x'01'    | Note that time is \"PM\"\n*                                     |\npwa_general_flags       ds   x        |\npwa_general_input       equ  x'80'    |\n*                                     |\npwa_interval_flags      ds   x        | << Nobody looks at these! <<\n*wa_hundredths          equ  x'80'    | These values may be used here\n*wa_phundredths         equ  x'40'    |\n*wa_ihundredths         equ  x'20'    |\npwa_delta               equ  x'08'    |\npwa_todclock            equ  x'04'    |\n*                                     |\nl_flags           equ   *-pwa_flags   |\n*                                     |\npwa_sourceparm_count ds f             | Count of parms in sourcelist.\n*                                     |\n               es_gdi dsect=no        | General debugging information.\npwa_area_l     equ   *-pwa_area       | Length of visible PWA stg.\n               endpwa                 |\n               end   ,                |\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SRVDTMAC": {"ttr": 17417, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x02\\x00\\x00V\\x01\\x11)\\x9f\\x01\\x11)\\x9f\\t'\\x03\\xf1\\x03\\xf1\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@\"", "ispf": {"version": "02.00", "flags": 0, "createdate": "2011-10-26T00:00:00", "modifydate": "2011-10-26T09:27:56", "lines": 1009, "newlines": 1009, "modlines": 0, "user": "CLEMSON"}, "text": "*---------------------------------------------------------------------*\n*  Copyright 2011 by Clemson University Research Foundation           *\n*                                                                     *\n*  Licensed under the Apache License, Version 2.0 (the \"License\");    *\n*  you may not use this file except in compliance with the License.   *\n*  You may obtain a copy of the License in this library as member     *\n*  $LICENSE, or from                                                  *\n*                                                                     *\n*      http://www.apache.org/licenses/LICENSE-2.0                     *\n*                                                                     *\n*  Unless required by applicable law or agreed to in writing,         *\n*  software distributed under the License is distributed on an \"AS    *\n*  IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either    *\n*  express or implied.  See the License for the specific language     *\n*  governing permissions and limitations under the License.           *\n*---------------------------------------------------------------------*\n TITLE 'SRVDTMAC: Date/Time Service Processor Symbols && Macros.'\n*---------------------------------------------------------------------*\n*\n*  Copy File:  SRVDTMAC\n*\n*  Purpose:    Date/time service processor symbols and macros.\n*\n*  Description: See \"Service Processors User's Guide and Reference\".\n*\n*  Change\n*  History   2011/10/20 JCB - Patch rollup for CBT tape distribution\n*\n*---------------------------------------------------------------------*\n*\n***********************************************************************\n***********************************************************************\n**                                                                   **\n**                     Symbol Definitions                            **\n**                                                                   **\n***********************************************************************\n***********************************************************************\n*\n*  Name of service processor module, functions\n*\n GBLC &DATETIME_SERVICES\n GBLA &DT_START,&DT_TERMINATE,&DT_GET_CURRENT,&DT_CONVERT\n GBLA &DT_ADD,&DT_SUBTRACT,&DT_DURATION\n*\n*  Return codes\n*\n GBLA &DT_SUCCESS\n GBLA &DT_INVALID_FUNCTION,&DT_INVALID_NUMBER_OF_PARMS\n GBLA &DT_INVALID_DT_ID,&DT_ENVIRONMENT_SUPPORT_ERROR\n GBLA &DT_STRING_HANDLER_ERROR,&DT_INVALID_DATE_FORMAT\n GBLA &DT_INVALID_TIME_FORMAT,&DT_INVALID_INTERVAL_DATE\n GBLA &DT_INVALID_INPUT_TIME,&DT_INVALID_INPUT_DATE\n GBLA &DT_INVALID_INPUT_INTERVAL\n GBLA &DT_OVERFLOW,&DT_OUT_OF_RANGE\n*\n*  Date, time and interval symbols\n*\n GBLA &DT_JULIAN,&DT_JULIAND,&DT_PJULIAN,&DT_IJULIAN\n GBLA &DT_SJULIAN,&DT_SJULIAND,&DT_SGREGORIAN\n GBLA &DT_GREGORIAN,&DT_SNORMAL,&DT_NORMAL,&DT_NUMBER_OF_DAYS\n GBLA &DT_HHMMSSTH,&DT_ES_FORMAT,&DT_TEXT,&DT_TEXTD\n GBLA &DT_SORTDATE,&DT_SSORTDATE,&DT_SASDATE7,&DT_SASDATE9\n GBLA &DT_YYYYMMMDD\n GBLA &DT_WEEKDAY,&DT_WEEKDAY3,&DT_MONTH,&DT_YEAR,&DT_YEAR2\n GBLA &DT_PYEAR,&DT_IYEAR\n GBLA &DT_HHMM,&DT_HHMMSS,&DT_CIVILIAN,&DT_UNSPECIFIED\n GBLA &DT_DELTA,&DT_HOURS,&DT_MINUTES,&DT_SECONDS,&DT_HUNDREDTHS\n GBLA &DT_TODCLOCK,&DT_PHOURS,&DT_IHOURS\n GBLA &DT_PMINUTES,&DT_IMINUTES,&DT_PSECONDS,&DT_ISECONDS\n GBLA &DT_GENERAL_INPUT,&DT_DEFAULT_DATE_FORMAT,&DT_DEFAULT_TIME_FORMAT\n GBLA &DT_PHUNDREDTHS,&DT_IHUNDREDTHS\n GBLA &DT_SECONDS_SINCE_1970,&DT_POSIXTIME\n*\n* Entry point name for the Item Manager.\n*\n&DATETIME_SERVICES                      SETC '''SRVDT   '''\n*\n* Function codes.\n*\n&DT_START                               SETA 1\n&DT_TERMINATE                           SETA 2\n&DT_GET_CURRENT                         SETA 3\n&DT_CONVERT                             SETA 4\n&DT_ADD                                 SETA 5\n&DT_SUBTRACT                            SETA 6\n&DT_DURATION                            SETA 7\n*\n* Return codes.\n*\n&DT_SUCCESS                             SETA 0\n&DT_INVALID_FUNCTION                    SETA 1\n&DT_INVALID_NUMBER_OF_PARMS             SETA 2\n&DT_INVALID_DT_ID                       SETA 3\n&DT_ENVIRONMENT_SUPPORT_ERROR           SETA 4\n&DT_STRING_HANDLER_ERROR                SETA 5\n&DT_INVALID_DATE_FORMAT                 SETA 6\n&DT_INVALID_TIME_FORMAT                 SETA 7\n&DT_INVALID_INTERVAL_FORMAT             SETA 8\n&DT_INVALID_INPUT_DATE                  SETA 9\n&DT_INVALID_INPUT_TIME                  SETA 10\n&DT_INVALID_INPUT_INTERVAL              SETA 11\n&DT_OVERFLOW                            SETA 12\n&DT_OUT_OF_RANGE                        SETA 13\n*\n* Supported date formats.\n*\n&DT_UNSPECIFIED        SETA 0       Used internally by SRVDT.\n*--------------------------------------------------------------------*\n*  Numeric formats (Julian, number-of-days)\n*--------------------------------------------------------------------*\n&DT_ES_FORMAT          SETA 1       X'1989359F'\n&DT_JULIAN             SETA 2       C'1989359'\n&DT_JULIAND            SETA 3       C'1989.359'\n&DT_PJULIAN            SETA 4       X'1989359F'\n&DT_IJULIAN            SETA 5       F'1989359'\n&DT_SJULIAN            SETA 6       C'89359'\n&DT_SJULIAND           SETA 7       C'89.359\n&DT_NUMBER_OF_DAYS     SETA 8       F'726767'\n*--------------------------------------------------------------------*\n*  Month-day-year formats (Gregorian, sortdate).  Numeric year,\n*  day and month values fall within this group.\n*--------------------------------------------------------------------*\n&DT_SGREGORIAN         SETA 11      C'12/25/89' or C'25/12/89'\n&DT_GREGORIAN          SETA 12      C'12/25/1989' or C'25/12/1989'\n&DT_SORTDATE           SETA 13      1989-12-25 or 1989/12/25\n&DT_SSORTDATE          SETA 14      89-12-25 or 89/12/25\n&DT_YEAR               SETA 15      C'1989'\n&DT_YEAR2              SETA 16      C'89'\n&DT_PYEAR              SETA 17      PL2'1989'\n&DT_IYEAR              SETA 18      H'1989'\n&DT_DAYS               SETA 19      CL2'Number of days'\n&DT_PDAYS              SETA 20      PL2'Number of days'\n&DT_IDAYS              SETA 21      H'Number of days'\n&DT_MONTH              SETA 22      CL2'Month number'\n&DT_PMONTH             SETA 23      PL2'Month number'\n&DT_IMONTH             SETA 24      H'Month number'\n*--------------------------------------------------------------------*\n*  Normal formats (Normal, SAS date).\n*--------------------------------------------------------------------*\n&DT_SNORMAL            SETA 31      C'25 Dec 89'\n&DT_NORMAL             SETA 32      C'25 Dec 1989'\n&DT_SASDATE7           SETA 33      C'25DEC89'\n&DT_SASDATE9           SETA 34      C'25DEC1989'\n&DT_YYYYMMMDD          SETA 35      C'1989DEC25'\n*--------------------------------------------------------------------*\n*  Text formats. Weekday and month names appear here.\n*--------------------------------------------------------------------*\n&DT_TEXT               SETA 41      C'December 25, 1989'\n&DT_TEXTD              SETA 42      C'Monday, December 25, 1989'\n&DT_WEEKDAY            SETA 43      C'Monday'\n&DT_WEEKDAY3           SETA 44      C'Mon'\n&DT_MONTHNAME          SETA 45      C'December'\n&DT_MONTHNAME3         SETA 46      C'Dec'\n&DT_DEFAULT_DATE_FORMAT  SETA  &DT_JULIAND\n*--------------------------------------------------------------------*\n&DT_GENERAL_INPUT      SETA 50      Multiple choice\n*--------------------------------------------------------------------*\n* Supported time formats.\n*--------------------------------------------------------------------*\n&DT_ES_FORMAT          SETA 1       F'3115074'\n&DT_HUNDREDTHS         SETA 2       F'3115074'\n&DT_HHMM               SETA 3       C'08:39'\n&DT_HHMMSS             SETA 4       C'08:39:10'\n&DT_HHMMSSTH           SETA 5       C'08:39:10.74'\n&DT_CIVILIAN           SETA 6       C'08:39:10 AM'\n&DT_TODCLOCK           SETA 7       XL8'TOD clock value'\n&DT_HOURS              SETA 8       CL2'08'\n&DT_PHOURS             SETA 9       PL2'8'\n&DT_IHOURS             SETA 10      H'8'\n&DT_MINUTES            SETA 11      CL2'39'\n&DT_PMINUTES           SETA 12      PL2'39'\n&DT_IMINUTES           SETA 13      H'39'\n&DT_SECONDS            SETA 14      CL2'10'\n&DT_PSECONDS           SETA 15      PL2'10'\n&DT_ISECONDS           SETA 16      H'10'\n&DT_SECONDS_SINCE_1970 SETA 17      F'35E7AB'\n&DT_POSIXTIME          SETA &DT_SECONDS_SINCE_1970\n&DT_DEFAULT_TIME_FORMAT  SETA  &DT_HHMMSS\n*\n* Supported interval formats.\n*\n&DT_DELTA              SETA 1       C'    3-:10:25:15.25'\n*  &DT_HUNDREDTHS      SETA         Previously defined\n*  &DT_DAYS            SETA         CL2'Number of days'\n*  &DT_PDAYS           SETA         PL2'Number of days'\n*  &DT_IDAYS           SETA         H'Number of days'\n*  &DT_HOURS           SETA         Previously defined\n*  &DT_PHOURS          SETA\n*  &DT_IHOURS          SETA\n*  &DT_MINUTES         SETA\n*  &DT_PMINUTES        SETA\n*  &DT_IMINUTES        SETA\n*  &DT_SECONDS         SETA\n*  &DT_PSECONDS        SETA\n*  &DT_ISECONDS        SETA\n&DT_IHUNDREDTHS    SETA  17\n&DT_PHUNDREDTHS    SETA  18\n*---------------------------------------------------------------------*\n* DEFUCOND macros to facilitate checking return codes. If new return\n* codes are added, don't forget to add a DEFUCOND for them.\n*---------------------------------------------------------------------*\n   DEFUCOND MACRO=SRV##RC,NAME=DT_SUCCESS\n   DEFUCOND MACRO=SRV##RC,NAME=DT_INVALID_FUNCTION\n   DEFUCOND MACRO=SRV##RC,NAME=DT_INVALID_NUMBER_OF_PARMS\n   DEFUCOND MACRO=SRV##RC,NAME=DT_INVALID_DT_ID\n   DEFUCOND MACRO=SRV##RC,NAME=DT_ENVIRONMENT_SUPPORT_ERROR\n   DEFUCOND MACRO=SRV##RC,NAME=DT_STRING_HANDLER_ERROR\n   DEFUCOND MACRO=SRV##RC,NAME=DT_INVALID_DATE_FORMAT\n   DEFUCOND MACRO=SRV##RC,NAME=DT_INVALID_TIME_FORMAT\n   DEFUCOND MACRO=SRV##RC,NAME=DT_INVALID_INTERVAL_FORMAT\n   DEFUCOND MACRO=SRV##RC,NAME=DT_INVALID_INPUT_DATE\n   DEFUCOND MACRO=SRV##RC,NAME=DT_INVALID_INPUT_TIME\n   DEFUCOND MACRO=SRV##RC,NAME=DT_INVALID_INPUT_INTERVAL\n   DEFUCOND MACRO=SRV##RC,NAME=DT_OVERFLOW\n   DEFUCOND MACRO=SRV##RC,NAME=DT_OUT_OF_RANGE\n*\n* Miscellaneous definitions, if any.\n*\n                        EJECT\n***********************************************************************\n***********************************************************************\n**                                                                   **\n**                     Macro Definitions                             **\n**                                                                   **\n***********************************************************************\n***********************************************************************\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   DT_ID                                                      *\n*                                                                     *\n* Purpose: Establish default values for a specific service processor  *\n*          and associate them with the specified ID name. The values  *\n*          are stored in the following created global variables:      *\n*                                                                     *\n* Variable Name                     Description                       *\n* -------------  ---------------------------------------------------- *\n* #$&ID.$#IDMAC  Name of macro that created the ID: PL_ID.            *\n* #$&ID.$#ESID   Service processor's Environment Support ID.          *\n* #$&ID.$#EPN    Tag for Service processor's Entry Point Name.        *\n* #$&ID.$#EPA    Tag for Service processor's Entry Point Address.     *\n* #$&ID.$#TKN    Tag for Service processor's Entry Point Token.       *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         DT_ID &ID=,&ESVA=,&SPEPNAME=,&SPEPA=,&SPTOKEN=,&ESID=,        *\n               &SIZELENGTH=\n         LCLC  &L_EPNAME\n         GBLC  &DATETIME_SERVICES\n.*\n.* If no EPNAME was specified, use the generic Date/Time services.\n.*\n&L_EPNAME SETC '&SPEPNAME'\n          AIF  ('&L_EPNAME' NE '').PAST_EPN\n&L_EPNAME SETC '&DATETIME_SERVICES'\n.PAST_EPN ANOP\n.*\n.* Invoke SRV##ID to create globals used by all ID's.\n.*\n         SRV##ID SET,                                                  +\n               ID=&ID.,IDMAC=DT_ID,ESID=&ESID.,SPEPNAME=&L_EPNAME,     +\n               SPEPA=&SPEPA,SPTOKEN=&SPTOKEN.\n.*\n.* Establish defaults for parameters specific to the string handler.\n.*\n&V_SIZELENGTH    SETC '#$&ID.$#SIZELENGTH'  Variable for SIZELENGTH=.\n                 GBLC &(&V_SIZELENGTH)      Declare global variable.\n&(&V_SIZELENGTH) SETC ''                    Set sizelength's default.\n                 AIF  ('&SIZELENGTH' EQ '').GOT_SIZELENGTH\n                 AIF  (T'&SIZELENGTH EQ 'N').SL_NUMERIC\n                 MNOTE 8,'If SIZELENGTH is specified on the ST_ID macro+\n               , it must be a self-defining numeric value.'\n                 AGO   .GOT_SIZELENGTH\n.SL_NUMERIC      ANOP\n&(&V_SIZELENGTH) SETC '&SIZELENGTH'         Copy value (or nulls).\n.GOT_SIZELENGTH  ANOP\n         MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   DT_START                                                   *\n* Purpose: Generate code to start a new Date/Time Services session.   *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         DT_START &ID=,&SPEPA=,&SPTOKEN=,&ESVA=,                       +\n               &OPTIONS=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN\n         GBLA  &DT_START                  SETC in open code.\n         LCLA  &DT_FORMAT\n         LCLB  &OPT_EURO,&OPT_LZ\n.*\n.* Obtain service processor ID values.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN,ESVA),                    +\n               ID=&ID,IDMAC=DT_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN,       +\n               ESVA=&ESVA.\n         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT\n         MVC   &#_IDTKN,=F'0'            | Insure TOKEN = 0.\n.*\n.* Validate the incoming parameters.\n.*\n.*\n.* Decode the options and produce a byte flag for the parmlist.\n.*\n&I       SETA  1\n.OPTLOOP AIF   (&I GT N'&OPTIONS).PASTOPT\n         AIF   ('&OPTIONS(&I)' EQ 'EUROPEAN').OPT1\n         AIF   ('&OPTIONS(&I)' EQ 'AMERICAN').OPT1A\n         AIF   ('&OPTIONS(&I)' EQ 'LZ').OPT2\n         AIF   ('&OPTIONS(&I)' EQ 'NLZ').OPT2A\n         MNOTE 8,'Invalid option name: &OPTIONS(&I)'\n.OPT1    ANOP\n&OPT_EURO SETB 1                Gregorian dates in European format\n         AGO   .NEXTOPT         Go process the next option.\n.OPT1A   ANOP\n&OPT_EURO SETB 0                Gregorian dates in American format\n         AGO   .NEXTOPT         Go process the next option.\n.OPT2    ANOP\n&OPT_LZ   SETB 1                Leading-zeros on output stuff\n         AGO   .NEXTOPT         Go process the next option.\n.OPT2A   ANOP\n&OPT_LZ   SETB 0                No leading zeros on output\n         AGO   .NEXTOPT         Go process the next option.\n.*\n.*  Add additional options here.\n.*\n.NEXTOPT ANOP\n&I       SETA  &I+1             Increment index into options list.\n         AGO   .OPTLOOP         Branch back to top of loop.\n.PASTOPT ANOP\n&OPTSTR  SETC '&OPT_EURO.&OPT_LZ.000000'\n         AIF  ('&OPTSTR' NE '00000000').NOT_NOP\n&OPTSTR  SETC ''\n         AGO  .PAST_OPTSTR_SET\n.NOT_NOP ANOP\n&OPTSTR  SETC '=B''&OPTSTR'''\n.PAST_OPTSTR_SET ANOP\n.*\n.* Generate the DT_START call.\n.*\n.PARMLIST ANOP ,\n         ##PLIST START\n         ##PLIST PARM,&#_IDTKN\n         ##PLIST PARM,&DT_START\n         ##PLIST PARM,&#_IDESVA\n         AIF     ('&OPTIONS' EQ '').PLEND\n         ##PLIST PARM,&OPTSTR\n.PLEND   ##PLIST END,VL\n         CALLX  &#_IDEPA\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   DT_TERMINATE                                               *\n* Purpose: Generate code to terminate a Date/Time Services session.   *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         DT_TERMINATE &ID=,&SPEPA=,&SPTOKEN=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN\n         GBLA  &DT_TERMINATE              SETC in open code.\n.*\n.* Obtain service processor ID values and terminate service processor.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +\n               ID=&ID,IDMAC=DT_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN\n         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT\n         CALLX &#_IDEPA,(&#_IDTKN,&DT_TERMINATE),VL\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   DT_GET_CURRENT                                             *\n* Purpose: Generate code to make a DT_GET_CURRENT call.               *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         DT_GET_CURRENT &ID=,&SPEPA=,&SPTOKEN=,&ESVA=,                 +\n               &DATE=,&TIME=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN\n         GBLA  &DT_GET_CURRENT            SETC in open code.\n         GBLA  &DT_PJULIAN                SETC in open code.\n         GBLA  &DT_HUNDREDTHS            SETC in open code.\n         LCLC  &DATEADDR,&DATEFORMAT\n         LCLC  &TIMEADDR,&TIMEFORMAT\n         GBLA  &DT_ES_FORMAT,&DT_TODCLOCK\n.*\n.* Obtain service processor ID values.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN,ESVA),                    +\n               ID=&ID,IDMAC=DT_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN,       +\n               ESVA=&ESVA.\n         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT\n.*\n.* Validate the incoming parameters.\n.*\n.DATE    AIF  (N'&DATE GT 2).DATE2MANY\n         AIF  (N'&DATE EQ 1).DATEDFLT\n         AIF  ('&DATE' EQ '').DATENONE\n&DATEADDR    SETC  '&DATE(1)'\n&DATEFORMAT  SETC  '&DATE(2)'\n         AGO   .TIME\n.DATEDFLT ANOP  ,\n&DATEADDR    SETC  '&DATE(1)'\n&DATEFORMAT  SETC  '&DT_PJULIAN'\n         AGO   .TIME\n.DATENONE ANOP  ,\n&DATEADDR    SETC  '0'\n&DATEFORMAT  SETC  '0'\n         AGO   .TIME\n.DATE2MANY  MNOTE 8,'Too many parameters specified for DATE.'\n            MEXIT\n.*\n.TIME    AIF  (N'&TIME GT 2).TIME2MANY\n         AIF  (N'&TIME EQ 1).TIMEDFLT\n         AIF  ('&TIME' EQ '').TIMENONE\n&TIMEADDR    SETC  '&TIME(1)'\n&TIMEFORMAT  SETC  '&TIME(2)'\n         AGO   .PARMLIST\n.TIMEDFLT ANOP  ,\n&TIMEADDR    SETC  '&TIME(1)'\n&TIMEFORMAT  SETC  '&DT_HUNDREDTHS'\n         AGO   .PARMLIST\n.TIMENONE ANOP  ,\n&TIMEADDR    SETC  '0'\n&TIMEFORMAT  SETC  '0'\n         AGO   .PARMLIST\n.TIME2MANY  MNOTE 8,'Too many parameters specified for TIME.'\n            MEXIT\n.*\n.* Generate the DT_GET_CURRENT call.\n.*\n.*\n.*       CALLX &#_IDEPA,(&#_IDTKN,&DT_GET_CURRENT,&#_IDESVA,\n.*             &CSECTLIST,&(&V_SIZELENGTH),&MAXSEV,&PLCC,\n.*             &MSGDEST_OPTION,&MSGDEST_P(1),&MSGDEST_P(2)),VL\n.PARMLIST ANOP ,\n.ESCHECK ANOP ,\n         AIF   (NOT ('&DATEFORMAT' EQ '&DT_ES_FORMAT' AND              *\n               '&TIMEFORMAT' NE '0')).TODCHECK\n         MNOTE 4,'TIME format will be ignored when DATE format requests*\n                DT_ES_Format.'\n.TODCHECK AIF  (NOT ('&TIMEFORMAT' EQ '&DT_TODCLOCK' AND               *\n               '&DATEFORMAT' NE '0')).CHECKEND\n         MNOTE 4,'DATE format will be ignored when TIME format requests*\n                DT_TODclock.'\n.CHECKEND ANOP ,\n         ##PLIST START\n         ##PLIST PARM,&#_IDTKN\n         ##PLIST PARM,&DT_GET_CURRENT\n         ##PLIST PARM,&DATEADDR,&DATEFORMAT\n         AIF   ('&TIME' EQ '').PLEND\n         ##PLIST PARM,&TIMEADDR,&TIMEFORMAT\n.PLEND   ##PLIST END,VL\n         CALLX  &#_IDEPA\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   DT_CONVERT                                                 *\n* Purpose: Generate code to make a DT_CONVERT call.                   *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         DT_CONVERT &ID=,&SPEPA=,&SPTOKEN=,&ESVA=,                     +\n               &FROMDATE=,&FROMTIME=,                                  +\n               &TODATE=,&TOTIME=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN\n         GBLA  &DT_CONVERT                SETC in open code.\n         GBLA  &DT_ES_FORMAT,&DT_TODCLOCK\n         LCLC  &FDATEADDR,&FDATEFORMAT\n         LCLC  &FTIMEADDR,&FTIMEFORMAT\n         LCLC  &TDATEADDR,&TDATEFORMAT\n         LCLC  &TTIMEADDR,&TTIMEFORMAT\n.*\n.* Obtain service processor ID values.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN,ESVA),                    +\n               ID=&ID,IDMAC=DT_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN,       +\n               ESVA=&ESVA.\n         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT\n.*\n.* Validate the incoming parameters.\n.*\n.FDATE   AIF  (N'&FROMDATE GT 2).FDATE2MANY\n         AIF  (N'&FROMDATE EQ 1).FDATEDFLT\n         AIF  ('&FROMDATE' EQ '').FDATENONE\n&FDATEADDR    SETC  '&FROMDATE(1)'\n&FDATEFORMAT  SETC  '&FROMDATE(2)'\n         AGO   .FTIME\n.FDATEDFLT ANOP  ,\n&FDATEADDR    SETC  '&DATE(1)'\n&FDATEFORMAT  SETC  '&DT_PJULIAN'\n         AGO   .FTIME\n.FDATENONE ANOP  ,\n&FDATEADDR    SETC  '0'\n&FDATEFORMAT  SETC  '0'\n         AGO   .FTIME\n.FDATE2MANY  MNOTE 8,'Too many parameters specified for FROMDATE.'\n            MEXIT\n.*\n.FTIME   AIF  (N'&FROMTIME GT 2).FTIME2MANY\n         AIF  (N'&FROMTIME EQ 1).FTIMEDFLT\n         AIF  ('&FROMTIME' EQ '').FTIMENONE\n&FTIMEADDR    SETC  '&FROMTIME(1)'\n&FTIMEFORMAT  SETC  '&FROMTIME(2)'\n         AGO   .TDATE\n.FTIMEDFLT ANOP  ,\n&FTIMEADDR    SETC  '&FROMTIME(1)'\n&FTIMEFORMAT  SETC  '&DT_HUNDREDTHS'\n         AGO   .TDATE\n.FTIMENONE ANOP  ,\n&FTIMEADDR    SETC  '0'\n&FTIMEFORMAT  SETC  '0'\n         AGO   .TDATE\n.FTIME2MANY  MNOTE 8,'Too many parameters specified for TIME.'\n            MEXIT\n.*\n.TDATE   AIF  (N'&TODATE GT 2).TDATE2MANY\n         AIF  (N'&TODATE EQ 1).TDATEDFLT\n         AIF  ('&TODATE' EQ '').TDATENONE\n&TDATEADDR    SETC  '&TODATE(1)'\n&TDATEFORMAT  SETC  '&TODATE(2)'\n         AGO   .TTIME\n.TDATEDFLT ANOP  ,\n&TDATEADDR    SETC  '&DATE(1)'\n&TDATEFORMAT  SETC  '&DT_PJULIAN'\n         AGO   .TTIME\n.TDATENONE ANOP  ,\n&TDATEADDR    SETC  '0'\n&TDATEFORMAT  SETC  '0'\n         AGO   .TTIME\n.TDATE2MANY  MNOTE 8,'Too many parameters specified for TODATE.'\n            MEXIT\n.*\n.TTIME   AIF  (N'&TOTIME GT 2).TTIME2MANY\n         AIF  (N'&TOTIME EQ 1).TTIMEDFLT\n         AIF  ('&TOTIME' EQ '').TTIMENONE\n&TTIMEADDR    SETC  '&TOTIME(1)'\n&TTIMEFORMAT  SETC  '&TOTIME(2)'\n         AGO   .PARMLIST\n.TTIMEDFLT ANOP  ,\n&TTIMEADDR    SETC  '&TOTIME(1)'\n&TTIMEFORMAT  SETC  '&DT_HUNDREDTHS'\n         AGO   .PARMLIST\n.TTIMENONE ANOP  ,\n&TTIMEADDR    SETC  '0'\n&TTIMEFORMAT  SETC  '0'\n         AGO   .PARMLIST\n.TTIME2MANY  MNOTE 8,'Too many parameters specified for TOTIME.'\n            MEXIT\n.*\n.* Generate the DT_CONVERT call.\n.*\n.PARMLIST ANOP ,\n.ESCHECK ANOP ,\n         AIF   (NOT ('&FDATEFORMAT' EQ '&DT_ES_FORMAT' AND             *\n               '&FTIMEFORMAT' NE '0')).ESCHK2\n         MNOTE 4,'TIME format will be ignored when DATE format requests*\n                DT_ES_Format.'\n.ESCHK2  AIF   (NOT ('&TDATEFORMAT' EQ '&DT_ES_FORMAT' AND             *\n               '&TTIMEFORMAT' NE '0')).TODCHECK\n         MNOTE 4,'TIME format will be ignored when DATE format requests*\n                DT_ES_Format.'\n.TODCHECK AIF  (NOT ('&FTIMEFORMAT' EQ '&DT_TODCLOCK' AND              *\n               '&FDATEFORMAT' NE '0')).TODCHK2\n         MNOTE 4,'DATE format will be ignored when TIME format requests*\n                DT_TODclock.'\n.TODCHK2  AIF  (NOT ('&TTIMEFORMAT' EQ '&DT_TODCLOCK' AND              *\n               '&TDATEFORMAT' NE '0')).CHECKEND\n         MNOTE 4,'DATE format will be ignored when TIME format requests*\n                DT_TODclock.'\n.CHECKEND ANOP ,\n         ##PLIST START\n         ##PLIST PARM,&#_IDTKN\n         ##PLIST PARM,&DT_CONVERT\n         ##PLIST PARM,&FDATEADDR,&FDATEFORMAT\n         ##PLIST PARM,&FTIMEADDR,&FTIMEFORMAT\n         ##PLIST PARM,&TDATEADDR,&TDATEFORMAT\n         AIF    ('&TTIMEADDR' EQ '0').PLEND\n         ##PLIST PARM,&TTIMEADDR,&TTIMEFORMAT\n.PLEND   ##PLIST END,VL\n         CALLX  &#_IDEPA\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   DT_ADD                                                     *\n* Purpose: Generate code to make a DT_ADD call.                       *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         DT_ADD  &ID=,&SPEPA=,&SPTOKEN=,&ESVA=,                        +\n               &DATEIN=,&TIMEIN=,                                      *\n               &INTERVAL=,                                             *\n               &DATEOUT=,&TIMEOUT=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN\n         GBLA  &DT_ADD                    SETC in open code.\n         GBLA  &DT_ES_FORMAT,&DT_TODCLOCK\n         LCLC  &DATEIN_ADDR,&DATEIN_FORMAT\n         LCLC  &TIMEIN_ADDR,&TIMEIN_FORMAT\n         LCLC  &INTERVAL_ADDR,&INTERVAL_FORMAT\n         LCLC  &DATEOUT_ADDR,&DATEOUT_FORMAT\n         LCLC  &TIMEOUT_ADDR,&TIMEOUT_FORMAT\n.*\n.* Obtain service processor ID values.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN,ESVA),                    +\n               ID=&ID,IDMAC=DT_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN,       +\n               ESVA=&ESVA.\n         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT\n.*\n.* Validate the incoming parameters.\n.*\n.DATEIN  AIF  (N'&DATEIN GT 2).DATEIN_2MANY\n         AIF  (N'&DATEIN EQ 1).DATEIN_FMT_REQUIRED\n         AIF  ('&DATEIN' EQ '').DATEIN_NONE\n&DATEIN_ADDR    SETC  '&DATEIN(1)'\n&DATEIN_FORMAT  SETC  '&DATEIN(2)'\n         AGO   .TIMEIN\n.DATEIN_NONE ANOP  ,\n&DATEIN_ADDR    SETC  '0'\n&DATEIN_FORMAT  SETC  '0'\n         AGO   .TIMEIN\n.DATEIN_2MANY  MNOTE 8,'Too many parameters specified for DATEIN.'\n            MEXIT\n.DATEIN_FMT_REQUIRED ANOP ,\n            MNOTE 8,'DATEIN format missing.'\n            MEXIT\n.*\n.TIMEIN  AIF  (N'&TIMEIN GT 2).TIMEIN_2MANY\n         AIF  (N'&TIMEIN EQ 1).TIMEIN_FMT_REQUIRED\n         AIF  ('&TIMEIN' EQ '').TIMEIN_NONE\n&TIMEIN_ADDR   SETC  '&TIMEIN(1)'\n&TIMEIN_FORMAT SETC  '&TIMEIN(2)'\n         AGO   .INTERVAL\n.TIMEIN_NONE ANOP ,\n&TIMEIN_ADDR   SETC  '0'\n&TIMEIN_FORMAT SETC  '0'\n         AGO   .INTERVAL\n.TIMEIN_2MANY MNOTE 8,'Too many parameters specified for TIMEIN.'\n            MEXIT\n.TIMEIN_FMT_REQUIRED ANOP ,\n            MNOTE 8,'TIMEIN format missing.'\n            MEXIT\n.INTERVAL   ANOP ,\n         AIF  (N'&INTERVAL GT 2).INTERVAL_2MANY\n         AIF  (N'&INTERVAL EQ 1).INTERVAL_FMT_REQUIRED\n         AIF  ('&INTERVAL' EQ '').INTERVAL_NONE\n&INTERVAL_ADDR SETC  '&INTERVAL(1)'\n&INTERVAL_FORMAT SETC '&INTERVAL(2)'\n         AGO   .DATEOUT\n.INTERVAL_NONE ANOP ,\n&INTERVAL_ADDR SETC  '0'\n&INTERVAL_FORMAT SETC '0'\n         AGO   .DATEOUT\n.INTERVAL_2MANY MNOTE 8,'Too many parameters specified for INTERVAL.'\n            MEXIT\n.INTERVAL_FMT_REQUIRED ANOP ,\n            MNOTE 8,'INTERVAL format missing.'\n            MEXIT\n.DATEOUT AIF  (N'&DATEOUT GT 2).DATEOUT_2MANY\n         AIF  (N'&DATEOUT EQ 1).DATEOUT_FMT_REQUIRED\n         AIF  ('&DATEOUT' EQ '').DATEOUT_NONE\n&DATEOUT_ADDR   SETC  '&DATEOUT(1)'\n&DATEOUT_FORMAT SETC  '&DATEOUT(2)'\n         AGO   .TIMEOUT\n.DATEOUT_NONE ANOP ,\n&DATEOUT_ADDR   SETC  '0'\n&DATEOUT_FORMAT SETC  '0'\n         AGO   .TIMEOUT\n.DATEOUT_2MANY MNOTE 8,'Too many parameters specified for DATEOUT.'\n            MEXIT\n.DATEOUT_FMT_REQUIRED ANOP ,\n            MNOTE 8,'DATEOUT format missing.'\n            MEXIT\n.*\n.TIMEOUT AIF  (N'&TIMEOUT GT 2).TIMEOUT_2MANY\n         AIF  (N'&TIMEOUT EQ 1).TIMEOUT_FMT_REQUIRED\n         AIF  ('&TIMEOUT' EQ '').TIMEOUT_NONE\n&TIMEOUT_ADDR  SETC  '&TIMEOUT(1)'\n&TIMEOUT_FORMAT SETC '&TIMEOUT(2)'\n         AGO   .PARMLIST\n.TIMEOUT_NONE ANOP ,\n&TIMEOUT_ADDR  SETC  '0'\n&TIMEOUT_FORMAT SETC '0'\n         AGO   .PARMLIST\n.TIMEOUT_2MANY MNOTE 8,'Too many parameters specified for TIMEOUT.'\n            MEXIT\n.TIMEOUT_FMT_REQUIRED ANOP ,\n            MNOTE 8,'TIMEOUT format missing.'\n            MEXIT\n.PARMLIST   ANOP  ,\n.ESCHECK ANOP ,\n         AIF   (NOT ('&DATEIN_FORMAT' EQ '&DT_ES_FORMAT' AND           *\n               '&TIMEIN_FORMAT' NE '0')).ESCHK2\n         MNOTE  4,'TIME format will be ignored when DATE format request*\n               s DT_ES_Format.'\n.ESCHK2  AIF   (NOT ('&DATEOUT_FORMAT' EQ '&DT_ES_FORMAT' AND          *\n               '&TIMEOUT_FORMAT' NE '0')).TODCHECK\n         MNOTE  4,'TIME format will be ignored when DATE format request*\n               s DT_ES_Format.'\n.TODCHECK AIF  (NOT ('&TIMEIN_FORMAT' EQ '&DT_TODCLOCK' AND            *\n               '&DATEIN_FORMAT' NE '0')).TODCHK2\n         MNOTE  4,'DATE format will be ignored when TIME format request*\n               s DT_TODclock.'\n.TODCHK2  AIF  (NOT ('&TIMEOUT_FORMAT' EQ '&DT_TODCLOCK' AND           *\n               '&DATEOUT_FORMAT' NE '0')).CHECKEND\n         MNOTE  4,'DATE format will be ignored when TIME format request*\n               s DT_TODclock.'\n.CHECKEND ANOP ,\n.*\n.* Generate the DT_ADD call.\n.*\n         ##PLIST START\n         ##PLIST PARM,&#_IDTKN\n         ##PLIST PARM,&DT_ADD\n         ##PLIST PARM,&DATEIN_ADDR,&DATEIN_FORMAT\n         ##PLIST PARM,&TIMEIN_ADDR,&TIMEIN_FORMAT\n         ##PLIST PARM,&INTERVAL_ADDR,&INTERVAL_FORMAT\n         ##PLIST PARM,&DATEOUT_ADDR,&DATEOUT_FORMAT\n         AIF   ('&TIMEOUT' EQ '').PLEND\n         ##PLIST PARM,&TIMEOUT_ADDR,&TIMEOUT_FORMAT\n.PLEND   ##PLIST END,VL\n         CALLX  &#_IDEPA\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   DT_SUBTRACT                                                *\n* Purpose: Generate code to make a DT_SUBTRACT call.                  *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         DT_SUBTRACT &ID=,&SPEPA=,&SPTOKEN=,&ESVA=,                    +\n               &DATEIN=,&TIMEIN=,                                      *\n               &INTERVAL=,                                             *\n               &DATEOUT=,&TIMEOUT=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN\n         GBLA  &DT_SUBTRACT               SETC in open code.\n         GBLA  &DT_ES_FORMAT,&DT_TODCLOCK\n         LCLC  &DATEIN_ADDR,&DATEIN_FORMAT\n         LCLC  &TIMEIN_ADDR,&TIMEIN_FORMAT\n         LCLC  &INTERVAL_ADDR,&INTERVAL_FORMAT\n         LCLC  &DATEOUT_ADDR,&DATEOUT_FORMAT\n         LCLC  &TIMEOUT_ADDR,&TIMEOUT_FORMAT\n.*\n.* Obtain service processor ID values.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN,ESVA),                    +\n               ID=&ID,IDMAC=DT_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN,       +\n               ESVA=&ESVA.\n         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT\n.*\n.* Validate the incoming parameters.\n.*\n.DATEIN  AIF  (N'&DATEIN GT 2).DATEIN_2MANY\n         AIF  (N'&DATEIN EQ 1).DATEIN_FMT_REQUIRED\n         AIF  ('&DATEIN' EQ '').DATEIN_NONE\n&DATEIN_ADDR    SETC  '&DATEIN(1)'\n&DATEIN_FORMAT  SETC  '&DATEIN(2)'\n         AGO   .TIMEIN\n.DATEIN_NONE ANOP  ,\n&DATEIN_ADDR    SETC  '0'\n&DATEIN_FORMAT  SETC  '0'\n         AGO   .TIMEIN\n.DATEIN_2MANY  MNOTE 8,'Too many parameters specified for DATEIN.'\n            MEXIT\n.DATEIN_FMT_REQUIRED ANOP ,\n            MNOTE 8,'DATEIN format missing.'\n            MEXIT\n.*\n.TIMEIN  AIF  (N'&TIMEIN GT 2).TIMEIN_2MANY\n         AIF  (N'&TIMEIN EQ 1).TIMEIN_FMT_REQUIRED\n         AIF  ('&TIMEIN' EQ '').TIMEIN_NONE\n&TIMEIN_ADDR   SETC  '&TIMEIN(1)'\n&TIMEIN_FORMAT SETC  '&TIMEIN(2)'\n         AGO   .INTERVAL\n.TIMEIN_NONE ANOP ,\n&TIMEIN_ADDR   SETC  '0'\n&TIMEIN_FORMAT SETC  '0'\n         AGO   .INTERVAL\n.TIMEIN_2MANY MNOTE 8,'Too many parameters specified for TIMEIN.'\n            MEXIT\n.TIMEIN_FMT_REQUIRED ANOP ,\n            MNOTE 8,'TIMEIN format missing.'\n            MEXIT\n.INTERVAL   ANOP ,\n         AIF  (N'&INTERVAL GT 2).INTERVAL_2MANY\n         AIF  (N'&INTERVAL EQ 1).INTERVAL_FMT_REQUIRED\n         AIF  ('&INTERVAL' EQ '').INTERVAL_NONE\n&INTERVAL_ADDR SETC  '&INTERVAL(1)'\n&INTERVAL_FORMAT SETC '&INTERVAL(2)'\n         AGO   .DATEOUT\n.INTERVAL_NONE ANOP ,\n&INTERVAL_ADDR SETC  '0'\n&INTERVAL_FORMAT SETC '0'\n         AGO   .DATEOUT\n.INTERVAL_2MANY MNOTE 8,'Too many parameters specified for INTERVAL.'\n            MEXIT\n.INTERVAL_FMT_REQUIRED ANOP ,\n            MNOTE 8,'INTERVAL format missing.'\n            MEXIT\n.DATEOUT AIF  (N'&DATEOUT GT 2).DATEOUT_2MANY\n         AIF  (N'&DATEOUT EQ 1).DATEOUT_FMT_REQUIRED\n         AIF  ('&DATEOUT' EQ '').DATEOUT_NONE\n&DATEOUT_ADDR   SETC  '&DATEOUT(1)'\n&DATEOUT_FORMAT SETC  '&DATEOUT(2)'\n         AGO   .TIMEOUT\n.DATEOUT_NONE ANOP ,\n&DATEOUT_ADDR   SETC  '0'\n&DATEOUT_FORMAT SETC  '0'\n         AGO   .TIMEOUT\n.DATEOUT_2MANY MNOTE 8,'Too many parameters specified for DATEOUT.'\n            MEXIT\n.DATEOUT_FMT_REQUIRED ANOP ,\n            MNOTE 8,'DATEOUT format missing.'\n            MEXIT\n.*\n.TIMEOUT AIF  (N'&TIMEOUT GT 2).TIMEOUT_2MANY\n         AIF  (N'&TIMEOUT EQ 1).TIMEOUT_FMT_REQUIRED\n         AIF  ('&TIMEOUT' EQ '').TIMEOUT_NONE\n&TIMEOUT_ADDR  SETC  '&TIMEOUT(1)'\n&TIMEOUT_FORMAT SETC '&TIMEOUT(2)'\n         AGO   .PARMLIST\n.TIMEOUT_NONE ANOP ,\n&TIMEOUT_ADDR  SETC  '0'\n&TIMEOUT_FORMAT SETC '0'\n         AGO   .PARMLIST\n.TIMEOUT_2MANY MNOTE 8,'Too many parameters specified for TIMEOUT.'\n            MEXIT\n.TIMEOUT_FMT_REQUIRED ANOP ,\n            MNOTE 8,'TIMEOUT format missing.'\n            MEXIT\n.PARMLIST   ANOP  ,\n.ESCHECK ANOP ,\n         AIF   (NOT ('&DATEIN_FORMAT' EQ '&DT_ES_FORMAT' AND           *\n               '&TIMEIN_FORMAT' NE '0')).ESCHK2\n         MNOTE  4,'TIME format will be ignored when DATE format request*\n               s DT_ES_Format.'\n.ESCHK2  AIF   (NOT ('&DATEOUT_FORMAT' EQ '&DT_ES_FORMAT' AND          *\n               '&TIMEOUT_FORMAT' NE '0')).TODCHECK\n         MNOTE  4,'TIME format will be ignored when DATE format request*\n               s DT_ES_Format.'\n.TODCHECK AIF  (NOT ('&TIMEIN_FORMAT' EQ '&DT_TODCLOCK' AND            *\n               '&DATEIN_FORMAT' NE '0')).TODCHK2\n         MNOTE  4,'DATE format will be ignored when TIME format request*\n               s DT_TODclock.'\n.TODCHK2  AIF  (NOT ('&TIMEOUT_FORMAT' EQ '&DT_TODCLOCK' AND           *\n               '&DATEOUT_FORMAT' NE '0')).CHECKEND\n         MNOTE  4,'DATE format will be ignored when TIME format request*\n               s DT_TODclock.'\n.CHECKEND ANOP ,\n.*\n.* Generate the DT_SUBTRACT call.\n.*\n         ##PLIST START\n         ##PLIST PARM,&#_IDTKN\n         ##PLIST PARM,&DT_SUBTRACT\n         ##PLIST PARM,&DATEIN_ADDR,&DATEIN_FORMAT\n         ##PLIST PARM,&TIMEIN_ADDR,&TIMEIN_FORMAT\n         ##PLIST PARM,&INTERVAL_ADDR,&INTERVAL_FORMAT\n         ##PLIST PARM,&DATEOUT_ADDR,&DATEOUT_FORMAT\n         AIF   ('&TIMEOUT' EQ '').PLEND\n         ##PLIST PARM,&TIMEOUT_ADDR,&TIMEOUT_FORMAT\n.PLEND   ##PLIST END,VL\n         CALLX  &#_IDEPA\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   DT_DURATION                                                *\n* Purpose: Generate code to make a DT_DURATION call.                  *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         DT_DURATION &ID=,&SPEPA=,&SPTOKEN=,&ESVA=,                    +\n               &DATE1=,&TIME1=,                                        *\n               &DURATION=,                                             *\n               &DATE2=,&TIME2=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN\n         GBLA  &DT_DURATION               SETC IN OPEN CODE.\n         GBLA  &DT_ES_FORMAT,&DT_TODCLOCK\n         LCLC  &DATE1_ADDR,&DATE1_FORMAT\n         LCLC  &TIME1_ADDR,&TIME1_FORMAT\n         LCLC  &DURATION_ADDR,&DURATION_FORMAT\n         LCLC  &DATE2_ADDR,&DATE2_FORMAT\n         LCLC  &TIME2_ADDR,&TIME2_FORMAT\n.*\n.* Obtain service processor ID values.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN,ESVA),                    +\n               ID=&ID,IDMAC=DT_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN,       +\n               ESVA=&ESVA.\n         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT\n.*\n.* ValiDATE the incoming parameters.\n.*\n.DATE1   AIF  (N'&DATE1 GT 2).DATE1_2MANY\n         AIF  (N'&DATE1 EQ 1).DATE1_FMT_REQUIRED\n         AIF  ('&DATE1' EQ '').DATE1_NONE\n&DATE1_ADDR     SETC  '&DATE1(1)'\n&DATE1_FORMAT   SETC  '&DATE1(2)'\n         AGO   .TIME1\n.DATE1_NONE ANOP   ,\n&DATE1_ADDR     SETC  '0'\n&DATE1_FORMAT   SETC  '0'\n         AGO   .TIME1\n.DATE1_2MANY   MNOTE 8,'Too many parameters specified for DATE1.'\n            MEXIT\n.DATE1_FMT_REQUIRED ANOP ,\n            MNOTE 8,'DATE1 format missing.'\n            MEXIT\n.*\n.TIME1   AIF  (N'&TIME1 GT 2).TIME1_2MANY\n         AIF  (N'&TIME1 EQ 1).TIME1_FMT_REQUIRED\n         AIF  ('&TIME1' EQ '').TIME1_NONE\n&TIME1_ADDR    SETC  '&TIME1(1)'\n&TIME1_FORMAT SETC   '&TIME1(2)'\n         AGO   .DURATION\n.TIME1_NONE ANOP ,\n&TIME1_ADDR    SETC  '0'\n&TIME1_FORMAT SETC   '0'\n         AGO   .DURATION\n.TIME1_2MANY MNOTE 8,'Too many parameters specified for TIME1.'\n            MEXIT\n.TIME1_FMT_REQUIRED ANOP ,\n            MNOTE 8,'TIME1 format missing.'\n            MEXIT\n.DURATION   ANOP ,\n         AIF  (N'&DURATION GT 2).DURATION_2MANY\n         AIF  (N'&DURATION EQ 1).DURATION_FMT_REQUIRED\n         AIF  ('&DURATION' EQ '').DURATION_NONE\n&DURATION_ADDR SETC  '&DURATION(1)'\n&DURATION_FORMAT SETC '&DURATION(2)'\n         AGO   .DATE2\n.DURATION_NONE ANOP ,\n&DURATION_ADDR SETC  '0'\n&DURATION_FORMAT SETC '0'\n         AGO   .DATE2\n.DURATION_2MANY MNOTE 8,'Too many parameters specified for DURATION.'\n            MEXIT\n.DURATION_FMT_REQUIRED ANOP ,\n            MNOTE 8,'DURATION format missing.'\n            MEXIT\n.DATE2 AIF    (N'&DATE2 GT 2).DATE2_2MANY\n         AIF  (N'&DATE2 EQ 1).DATE2_FMT_REQUIRED\n         AIF  ('&DATE2' EQ '').DATE2_NONE\n&DATE2_ADDR     SETC  '&DATE2(1)'\n&DATE2_FORMAT SETC    '&DATE2(2)'\n         AGO   .TIME2\n.DATE2_NONE ANOP ,\n&DATE2_ADDR     SETC  '0'\n&DATE2_FORMAT SETC    '0'\n         AGO   .TIME2\n.DATE2_2MANY MNOTE 8,'Too many parameters specified for DATE2.'\n            MEXIT\n.DATE2_FMT_REQUIRED ANOP ,\n            MNOTE 8,'DATE2 format missing.'\n            MEXIT\n.*\n.TIME2 AIF    (N'&TIME2 GT 2).TIME2_2MANY\n         AIF  (N'&TIME2 EQ 1).TIME2_FMT_REQUIRED\n         AIF  ('&TIME2' EQ '').TIME2_NONE\n&TIME2_ADDR    SETC  '&TIME2(1)'\n&TIME2_FORMAT SETC '&TIME2(2)'\n         AGO   .PARMLIST\n.TIME2_NONE ANOP ,\n&TIME2_ADDR    SETC  '0'\n&TIME2_FORMAT SETC '0'\n         AGO   .PARMLIST\n.TIME2_2MANY MNOTE 8,'Too many parameters specified for TIME2.'\n            MEXIT\n.TIME2_FMT_REQUIRED ANOP ,\n            MNOTE 8,'TIME2 format missing.'\n            MEXIT\n.PARMLIST   ANOP  ,\n.ESCHECK ANOP ,\n         AIF   (NOT ('&DATE1_FORMAT' EQ '&DT_ES_FORMAT' AND            *\n               '&TIME1_FORMAT' NE '0')).ESCHK2\n         MNOTE  4,'TIME format will be ignored when DATE format request*\n               s DT_ES_Format.'\n.ESCHK2  AIF   (NOT ('&DATE2_FORMAT' EQ '&DT_ES_FORMAT' AND            *\n               '&TIME2_FORMAT' NE '0')).TODCHECK\n         MNOTE  4,'TIME format will be ignored when DATE format request*\n               s DT_ES_Format.'\n.TODCHECK AIF  (NOT ('&TIME1_FORMAT' EQ '&DT_TODCLOCK' AND             *\n               '&DATE1_FORMAT' NE '0')).TODCHK2\n         MNOTE 4,'DATE format will be ignored when TIME format requests*\n                DT_TODclock.'\n.TODCHK2  AIF  (NOT ('&TIME2_FORMAT' EQ '&DT_TODCLOCK' AND             *\n               '&DATE2_FORMAT' NE '0')).CHECKEND\n         MNOTE 4,'DATE format will be ignored when TIME format requests*\n                DT_TODclock.'\n.CHECKEND ANOP ,\n.*\n.* Generate the DT_DURATION call.\n.*\n         ##PLIST START\n         ##PLIST PARM,&#_IDTKN\n         ##PLIST PARM,&DT_DURATION\n         ##PLIST PARM,&DATE1_ADDR,&DATE1_FORMAT\n         ##PLIST PARM,&TIME1_ADDR,&TIME1_FORMAT\n         ##PLIST PARM,&DATE2_ADDR,&DATE2_FORMAT\n         ##PLIST PARM,&TIME2_ADDR,&TIME2_FORMAT\n         ##PLIST PARM,&DURATION_ADDR,&DURATION_FORMAT\n.PLEND   ##PLIST END,VL\n         CALLX  &#_IDEPA\n.MEXIT   MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SRVDTREX": {"ttr": 17926, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x02\\x00\\x00V\\x01\\x11)\\x9f\\x01\\x11)\\x9f\\t'\\x05<\\x05<\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@\"", "ispf": {"version": "02.00", "flags": 0, "createdate": "2011-10-26T00:00:00", "modifydate": "2011-10-26T09:27:56", "lines": 1340, "newlines": 1340, "modlines": 0, "user": "CLEMSON"}, "text": "*---------------------------------------------------------------------*\n*  Copyright 2011 by Clemson University Research Foundation           *\n*                                                                     *\n*  Licensed under the Apache License, Version 2.0 (the \"License\");    *\n*  you may not use this file except in compliance with the License.   *\n*  You may obtain a copy of the License in this library as member     *\n*  $LICENSE, or from                                                  *\n*                                                                     *\n*      http://www.apache.org/licenses/LICENSE-2.0                     *\n*                                                                     *\n*  Unless required by applicable law or agreed to in writing,         *\n*  software distributed under the License is distributed on an \"AS    *\n*  IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either    *\n*  express or implied.  See the License for the specific language     *\n*  governing permissions and limitations under the License.           *\n*---------------------------------------------------------------------*\n//SRVDTREX JOB TIME=(,4)\n/*JOBPARM L=20\n//IRXFUSER EXEC ASMPCL,PDS='SYS1.LPA2LIB',NAME=SRVDTREX,\n//  COPT=',RENT',LOPT=',RENT,REUS,REFR'\n//P.SYSIN  DD  *\n  SMLIST CONVERT=YES                  |\nDTSERVS  title \"Function Table Definition Macro\"\n         macro                        |\n         function_table &parm,&function=,&program=,&type='ADCON'\n         gbla  &function_counter      |\n         lcla  &pgmtype               |\n         aif   ('&parm' eq 'start').start\n         aif   ('&parm' eq 'end').end |\n         aif   ('&parm' eq 'define').define\n         mnote 8,\"Unknown parameter of &PARM.\"\n         mexit ,                      |\n.start   anop  ,                      |\nirxfuser csect ,                      | CSECT name of IRXFUSER\nirxfuser amode 31                     |\nirxfuser rmode any                    |\n         dc    cl8'irxfuser'          | Eyecatcher of IRXFUSER\n         dc    f'24'                  | Length of header\n         dc    f'-1'                  | Number of rows (updated later)\n         dc    f'0'                   | Reserved; must be zero\n         dc    f'32'                  | Length of one entry\n&function_counter seta  0             |\n         mexit ,                      |\n.define  anop  ,                      |\n&function_counter seta &function_counter+1\n         dc    cl8'&function'         | Name of function\n         aif   ('&type' eq 'ADCON').setadcon\n         aif   ('&type' eq 'VCON').setvcon\n         aif   ('&type' eq 'LOAD').setload\n         mnote 8,\"Unknown program type of &TYPE.\"\n         mexit ,                      |\n.setadcon anop ,                      |\n         dc    A(&program)            | Address of function routine\n         dc    F'0'                   | Reserved\n         dc    cl8' '                 | Do not issue a LOAD for it\n         dc    cl8' '                 | No DDname for LOAD\n         mexit ,                      |\n.setvcon anop ,                       |\n         dc    V(&program)            | VCON for function routine\n         dc    F'0'                   | Reserved\n         dc    cl8' '                 | Do not issue a LOAD for it\n         dc    cl8' '                 | No DDname for LOAD\n         mexit ,                      |\n.setload anop ,                       |\n         dc    F'0'                   | Empty address for function code\n         dc    F'0'                   | Reserved\n         dc    cl8'&program'          | Name to be LOADed\n         dc    cl8' '                 | DDname to load routine from\n         mexit ,                      |\n.end     anop  ,                      |\n         org   irxfuser+12            | ORG back to number of rows\n         dc    f'&function_counter'   | Set number of rows\n         org   ,                      |\n         mexit ,                      |\n         mend  ,                      |\n         title \"Define Function Table\"\n  function_table start                | Start the function table.\n    function_table define,            |   Define DTSETUP as a VCON.    *\n               function=DTSETUP,      |                                *\n               program=DTSETUP,       |                                *\n               type=VCON              |\n    function_table define,            |   Define DATECNVT as a VCON.   *\n               function=DATECNVT,     |                                *\n               program=DATECNVT,      |                                *\n               type=VCON              |\n    function_table define,            |   Define TIMECNVT as a VCON.   *\n               function=TIMECNVT,     |                                *\n               program=TIMECNVT,      |                                *\n               type=VCON              |\n    function_table define,            |   Define DATEADD as a VCON.    *\n               function=DATEADD,      |                                *\n               program=DATEADD,       |                                *\n               type=VCON              |\n    function_table define,            |   Define TIMEADD as a VCON.    *\n               function=TIMEADD,      |                                *\n               program=TIMEADD,       |                                *\n               type=VCON              |\n    function_table define,            |   Define DATEDIFF as a VCON.   *\n               function=DATEDIFF,     |                                *\n               program=DATEDIFF,      |                                *\n               type=VCON              |\n  function_table end                  |\n  TITLE \"SRVDT Interface For Rexx Programs\"\n     print off                        |\n     copy  srvdtmac                   |\n     copy  smsyms                     |\n     copy  srvesmac                   |\n     print on,gen                     |\n     eject                            |\n*---------------------------------------------------------------------*\n*\n*  Copyright (C) 1992 Clemson University\n*\n*  Program     DATECNVT\n*\n*  Abstract    This routine acts as an interface to some basic Date/\n*              Time Service Processor functions.\n*\n*  Inputs:\n*      Parameters  R0 - Address of Rexx environment block;\n*                       see SYS1.MACLIB(IRXENVB).\n*                  R1 - Address of external function parmlist;\n*                       see SYS1.MACLIB(IRXEFPL).\n*                  Standard linkage otherwise.\n*                  The EFPL points to the argument list, described by\n*                  SYS1.MACLIB(IRXARGTB), and the evaluation block,\n*                  described by SYS1.MACLIB(IRXEVALB).\n*      Files       None.\n*      Other       None.\n*\n*  Outputs:\n*      Returncodes Zero - It worked\n*                  Nonzero - It didn't work.\n*      Messages    Text description of the SRVDT error will be stored\n*                  in the function result area.\n*      Files       None.\n*      Other       Rexx variables set.\n*\n*  PROGRAM     Reentrant, problem key and state, standard linkage,\n*  ATTRIBUTES  non-authorized, AMODE(31), RMODE(ANY)\n*\n*  Special     The functions supported and their call formats are:\n*  Notes         Result = DTSETUP()\n*                  .. Creates a bunch of Rexx variables to help out.\n*                DateOut = DATECNVT(DateIn <,FormatIn <,FormatOut>>)\n*                  .. Converts a date from one format to another.  The\n*                     formatin and formatout parameters are optional.\n*                     FormatIn defaults to DT_General_Input, while\n*                     FormatOut defaults to DT_Normal.  A zero may be\n*                     specified for either format as a placeholder.\n*                TimeOut = TIMECNVT(TimeIn <,FormatIn <,FormatOut>>)\n*                  .. Converts a time from one format to another.  The\n*                     formats work like DATECNVT; the default FormatIn\n*                     is DT_General_Input, while the default FormatOut\n*                     is DT_Civilian.\n*                DateOut = DATEADD(DateIn,Interval <,FormatIn\n*                                  <,FormatIn2 <,FormatOut>>)\n*                  .. Adds an interval value to a date value, producing\n*                     a date value.  The default FormatIn is DT_General\n*                     _Input, the default FormatIn2 is DT_Days, and the\n*                     default FormatOut is DT_Normal.\n*                Difference = DATEDIFF(Datein,Datein2 <,FormatIn\n*                                     ,FormatIn2 <,FormatOut>>>)\n*                  .. Produces the difference between two date values.\n*                     The default input formats are DT_General_Input,\n*                     while the default FormatOut is DT_Days.\n*\n*  Change\n*  History     08/24/92 New - New\n*              __/__/__ ___\n*              __/__/__ ___\n*\n*  Method of   An entry stub passes the addresses of the EFPL and\n*  Operation   ENVB, as well as the name of the function called, to\n*              csect DTSERVS, which does all the hard stuff.  There\n*              is an entry stub for each function.  These stubs are\n*              at the end of the module;  this makes DTSERVS start at\n*              location counter zero, which makes debugging easier.\n*\n*---------------------------------------------------------------------*\n         EJECT                        |\n         macro                        |\n         set_immediate &text,&value   |\n         lcla  &ltext,&lvalue         |\n&ltext   seta  k'&text                |\n&lvalue  seta  k'&value               |\n         psd   type=partial           |\n#txt&sysndx  dc  c'&text'             |\n#val&sysndx  dc  c'&value'            |\n         endpsd ,                     |\n         callsub set_variable,        |                                *\n               (#txt&sysndx,=F'&ltext',#val&sysndx,=F'&lvalue')\n         mend                         |\n         macro                        |\n         set_variable &variable,&value,&len\n         lcla  &ltext,&lvalue         |\n&ltext   seta  k'&variable            |\n         psd   type=partial           |\n#txt&sysndx  dc  c'&variable'         |\n         endpsd ,                     |\n         callsub set_variable,        |                                *\n               (#txt&sysndx,=F'&ltext',&value,&len)\n         mend                         |\n         macro                        |\n  Validate_Packed_Data   &Data=,&Len=,&Type=DATE\n.*--------------------------------------------------------------------*\n.* Macro:      Validate_Packed_Data\n.* Purpose:    Attempt to ensure packed-decimal input is valid and\n.*             won't cause an 0C7.\n.* Syntax:     Validate_Packed_Data Data=<RX address>,Len=<integer>\n.* Notes:      The code generated by this macro uses R15, R1, and R2.\n.*             If someone wants to make the macro smart enough to pick\n.*             apart any form of RX address someday, the use of field\n.*             pwa_packed_validation can be removed.\n.*        ---> Don't use R15 to point to the input field: the macro\n.*             wipes out the contents of R15.\n.*             Thanks to John Fisher (FISHER@RPIECS) for the basic\n.*             routine.\n.*--------------------------------------------------------------------*\n    gbla  &dt_invalid_input_date      | Globals for the errexit\n    gbla  &dt_invalid_input_time      |\n    gbla  &dt_invalid_input_interval  |\n    lcla  &errcode                    | Local errexit code\n.*--------------------------------------------------------------------*\n  sr    r2,r2                         | Clear R2\n  la    r15,pwa_packed_validation+&len.-1   | Get addr end of input\n  mvc   pwa_packed_validation(&len.),&data  | Copy input to workarea\n  trt   pwa_packed_validation(&len.),psd_packed_table | Check out data:\n  cr    r1,r15                        | R1 should -> last byte: else,\n  bne   inv&sysndx                    |  it's an error.\n  b     *+4(r2)                       | If we got a hit, check it out.\n  b     inv&sysndx                    | Byte of 00: no sign on it.\n  b     inv&sysndx                    | Byte of 04: it's not valid.\n  b     ok&sysndx                     | Byte of 08: it's a valid sign.\ninv&sysndx ds 0h                      |\n         aif   ('&type' ne 'DATE').chktime\n&errcode seta  &dt_invalid_input_date |\n         ago   .errex                 |\n.chktime aif   ('&type' ne 'TIME').chkint\n&errcode seta  &dt_invalid_input_time |\n         ago   .errex                 |\n.chkint  aif   ('&type' ne 'INTERVAL').badtype\n&errcode seta  &dt_invalid_input_interval\n         ago   .errex                 |\n.badtype mnote 8,\"Invalid data type of &TYPE.: must be DATE, TIME or IN*\n               TERVAL\".               |\n         mexit                        |\n.errex   anop                         |\n  la    r15,&errcode                  |\n  st    r15,pwa_dt_rc                 |\n  callsub  dt_error                   | Generate error rtn. call\n  b    xit&sysndx                     |\nok&sysndx  ds 0h                      |\n  xr    r15,r15                       |\nxit&sysndx ds 0h                      |\n         mend                         |\n         macro                        |\n         tracemsg &text               |\n         gblb  &dt_trace              |\n         aif   (not &dt_trace).out    |\n         tput  #tmsg&sysndx,l'#tmsg&sysndx\n         b     #skip&sysndx           |\n#tmsg&sysndx dc c&text                |\n#skip&sysndx ds 0h                    |\n.out     mexit                        |\n         mend                         |\n        title \"Date/Time Services Interface\"\n**--------------------------------------------------------------------*\n**\n**  Date/Time Services interface.\n**\n**  On entry, R1 points to the following parameter list:\n**    +0 - CL8'function name'   (e.g DATECNVT, etc)\n**    +4 - Address of Rexx EFPL (the original R1 from Rexx's call)\n**    +8 - Address of ENVBLOCK  (the original R0 from Rexx's call)\n**\n**--------------------------------------------------------------------*\n          gblb  &dt_trace             |\n&dt_trace setb  0                     | No messages ...\n block name=DTSERVS,type=program,     |                                *\n               options=(*pwa,xa,loctr,long,noclearpwa),                *\n               amode=31,rmode=any,    |                                *\n               subopts=(*swa,loadbase),                                *\n               r1save=r2              |\n  es_id id=es,esva=pwa_esv_address,   |                                +\n               spepa=pwa_es_epa,      |                                +\n               sptoken=pwa_es_token   |\n      space 1                         |\n  dt_id id=DT,spepname=&DateTime_Services,                             *\n               spepa=pwa_dt_epa,      |                                *\n               sptoken=pwa_dt_token   |\n  lm    r7,r9,0(r2)                   | Get address of EFPL, ENVBLOCK\n  mvc   pwa_function_name,0(r7)       | Copy function name for later\n  using efpl,r8                       | Base on EFPL\n  using envblock,r9                   | Base on ENVBLOCK\n  mvc   pwa_irxexte,envblock_irxexte  | Copy address of Rexx EXTE\n  l     r6,efpleval                   | Point to evalblock address\n  l     r6,0(,r6)                     | Load up the address\n  using evalblock,r6                  |  and base on the evalblock.\n* *------------------------------------------------------------------*\n* *  Start service processors if necessary, then call function code.\n* *-------------------------------------------------------------------*\n  callsub start_service_processors    |\n  if     (clc,pwa_function_name,eq,=c'DTSETUP ')\n   callsub create_variables           |\n  elseif (clc,pwa_function_name,eq,=c'DATECNVT')\n   callsub convert_a_date             |\n  elseif (clc,pwa_function_name,eq,=c'TIMECNVT')\n   callsub convert_a_time             |\n  elseif (clc,pwa_function_name,eq,=c'DATEADD ')\n   callsub add_dates                  |\n  elseif (clc,pwa_function_name,eq,=c'TIMEADD ')\n   callsub add_times                  |\n  elseif (clc,pwa_function_name,eq,=c'DATEDIFF')\n   callsub date_difference            |\n*\n* elseif (clc,pwa_function_name,eq,=c'DATESUB ')  We can put these in\n*  callsub subtract_dates             |           if the demand exists.\n* elseif (clc,pwa_function_name,eq,=c'TIMESUB ')\n*  callsub subtract_times             |\n* elseif (clc,pwa_function_name,eq,=c'TIMEDIFF')\n*  callsub time_difference            |\n*\n  endif                               |\n* *-------------------------------------------------------------------*\n  set_immediate  DT_RC,0              | If we got here, we did OK.\n* *-------------------------------------------------------------------*\n callsub stop_service_processors      |\n endblk rc=0                          |\n title \"Convert A Date Value\"         |\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Convert_A_Date\n*  Abstract:   This subroutine calls SRVDT to convert a date value\n*              to another format.\n*  Inputs:     No parameters; the PWA contains variables that will\n*              be used for conversion.\n*  Outputs:    EVALBLOCK filled in with result.\n*  Special\n*  Notes:      None.\n*\n*---------------------------------------------------------------------*\n         SPACE 1                      |\n block name=convert_a_date,type=subroutine\n  tracemsg \"Convert_A_Date entered.\"  |\n  l     r3,efplarg                    |\n  using argtable_entry,r3             |\n* *-------------------------------------------------------------------*\n* * Set default formats.\n* *-------------------------------------------------------------------*\n  mvc   pwa_input_format,=a(&dt_general_input)  Default the input and\n  mvc   pwa_output_format,=a(&dt_normal)        output date formats.\n* *-------------------------------------------------------------------*\n* * Parse function arguments;  there must be at least one.\n* *-------------------------------------------------------------------*\n  fill  pwa_input,c' '                | Clear field to receive arg\n  callsub parse_argument,((r3),pwa_input,'C')   Copy text of input\n  errexit name=function_error,(treg,r15,nz),    Wasn't one: complain.  *\n               code=2,codereg=r14\n  la    r3,argtable_next              |         Next argument ...\n  callsub parse_argument,((r3),pwa_input_format,'V')  Get value\n  if    (treg,r15,z)                  |         If there was one\n   la    r3,argtable_next             |           Try for three\n   callsub parse_argument,((r3),pwa_output_format,'V')  Get value\n  endif                               | Finished with parsing input.\n  drop  r3                            |\n* *-------------------------------------------------------------------*\n* * Special cases:  If incoming interval format is DT_NUMBER_OF_DAYS,\n* * convert it to integer for SRVDT.\n* *-------------------------------------------------------------------*\n  callsub convert_date_formats,(pwa_input,pwa_input_format)\n* *-------------------------------------------------------------------*\n* * Call DT_CONVERT and see what happens.\n* *-------------------------------------------------------------------*\n  fill  pwa_result,c' '               |\n  DT_Convert  ID=DT,Fromdate=(pwa_input,pwa_input_format),             *\n               Todate=(pwa_result,pwa_output_format)\n  if    (treg,r15,nz)                 |\n   st    r15,pwa_dt_rc                |\n   callsub dt_error                   |\n   leave block=*                      |\n  endif                               |\n* *-------------------------------------------------------------------*\n* * Special case:  DT_Number_Of_Days is handy, but SRVDT only supports\n* * it in a binary format.  Convert it to zoned decimal.\n* *-------------------------------------------------------------------*\n  if    (clc,pwa_output_format,eq,=a(&DT_Number_Of_Days)) If #_Of_Days\n   l     r1,pwa_result                |  Result is a fullword value\n   cvd   r1,pwa_d                     |  Convert to packed\n   unpk  pwa_result(7),pwa_d          |  Doesn't need to be pretty\n   oi    pwa_result+6,x'f0'           |  Don't forget last byte\n  endif                               |\n* *-------------------------------------------------------------------*\n* * Scan from end of pwa_result looking for 1st non-blank, then pass\n* * the resulting field length and text back to Rexx.\n* *-------------------------------------------------------------------*\n  la    r14,pwa_result+l'pwa_result-1 | Point to end of result string\n  la    r1,l'pwa_result               | Load up its length\n  loop  bct                           |\n   leave loop=*,(cli,0(r14),ne,c' ')  |\n   bctr  r14,0                        |\n  endloop bct,r1                      |\n  st    r1,evalblock_evlen            | Save result's len in EvalBlock\n  bctr  r1,0                          |\n  exi   r1,(mvc,evalblock_evdata(0),pwa_result)  Set result.\n endblk                               |\n title \"Convert A Time Value\"         |\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Convert_A_Time\n*  Abstract:   This subroutine calls SRVDT to convert a time value\n*              to another format.\n*  Inputs:     No parameters; the PWA contains variables that will\n*              be used for conversion.\n*  Outputs:    EVALBLOCK filled in with result.\n*  Special\n*  Notes:      None.\n*\n*---------------------------------------------------------------------*\n         SPACE 1                      |\n block name=convert_a_time,type=subroutine\n  tracemsg \"Convert_A_Time entered.\"  |\n  l     r3,efplarg                    | Point to 1st Argtable entry\n  using argtable_entry,r3             |\n* *-------------------------------------------------------------------*\n* * Set default formats.\n* *-------------------------------------------------------------------*\n  mvc   pwa_input_format,=a(&dt_general_input)  Default the input and\n  mvc   pwa_output_format,=a(&dt_civilian)      output date formats.\n* *-------------------------------------------------------------------*\n* * Parse function arguments;  there must be at least one.\n* *-------------------------------------------------------------------*\n  fill  pwa_input,c' '                |\n  callsub parse_argument,((r3),pwa_input,'C')  Get its address\n  errexit name=function_error,(treg,r15,nz),                           *\n               code=3,codereg=r14\n   la    r3,argtable_next             |\n  callsub parse_argument,((r3),pwa_input_format,'V')  Get its value\n  if    (treg,r15,z)                  | If we got one\n   la    r3,argtable_next             |\n   callsub parse_argument,((r3),pwa_output_format,'V') Get its value.\n  endif                               |\n  drop  r3                            |\n* *-------------------------------------------------------------------*\n* * Special cases:  If incoming interval format is DT_HUNDREDTHS,\n* * DT_SECONDS, DT_MINUTES, DT_HOURS or DT_DAYS, pack it and use\n* * DT_PHUNDREDTHS, etc. internally.\n* *-------------------------------------------------------------------*\n  callsub convert_interval_formats,(pwa_input2,pwa_input_format2)\n* *-------------------------------------------------------------------*\n* * Call DT_CONVERT and see what happens.\n* *-------------------------------------------------------------------*\n  fill  pwa_result,c' '               | Swab the decks first\n  DT_Convert  ID=DT,Fromtime=(pwa_input,pwa_input_format), Convert it  *\n               Totime=(pwa_result,pwa_output_format) or tell me why not\n  if    (treg,r15,nz)                 | Bad value, huh?\n   st    r15,pwa_dt_rc                |\n   callsub dt_error                   |  Go set result to error msg\n   leave block=*                      |   and get out.\n  endif                               |\n* *-------------------------------------------------------------------*\n* * Special case:  DT_Hundredths is handy, but SRVDT only supports\n* * it in a binary format.  Convert it to zoned decimal.\n* *-------------------------------------------------------------------*\n  if    (clc,pwa_output_format,eq,=a(&DT_Hundredths)) If DT_100'ths\n   l     r1,pwa_result                |  Result is a fullword value\n   cvd   r1,pwa_d                     |  Convert to packed\n   unpk  pwa_result(7),pwa_d          |  Doesn't need to be pretty\n   oi    pwa_result+6,x'f0'           |  Don't forget last byte\n  endif                               |\n* *-------------------------------------------------------------------*\n* * Scan from end of pwa_result looking for 1st non-blank, then pass\n* * the resulting field length and text back to Rexx.\n* *-------------------------------------------------------------------*\n  la    r14,pwa_result+l'pwa_result-1 | We gotta tell Rexx how long the\n  la    r1,l'pwa_result               |  answer is ...\n  loop  bct                           |\n   leave loop=*,(cli,0(r14),ne,c' ')  |\n   bctr  r14,0                        |\n  endloop bct,r1                      |\n  st    r1,evalblock_evlen            | Save result's len in EvalBlock\n  bctr  r1,0                          |\n  exi   r1,(mvc,evalblock_evdata(0),pwa_result)  Set result.\n endblk                               |\n title \"Add Two Date Values\"          |\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Add_Dates\n*  Abstract:   This subroutine calls SRVDT to add an interval to a\n*              date value.\n*  Inputs:     No parameters; the PWA contains variables that will\n*              be used for conversion.\n*  Outputs:    EVALBLOCK filled in with result.\n*  Special\n*  Notes:      None.\n*\n*---------------------------------------------------------------------*\n         SPACE 1                      |\n block name=add_dates,type=subroutine |\n  tracemsg \"Add_Dates entered.\"       |\n  l     r3,efplarg                    | Point to 1st Argtable entry\n  using argtable_entry,r3             |\n* *-------------------------------------------------------------------*\n* * Set default formats.\n* *-------------------------------------------------------------------*\n  mvc   pwa_input_format,=a(&dt_general_input)  Default the input and\n  mvc   pwa_input_format2,=a(&dt_general_input)   input and output\n  mvc   pwa_output_format,=a(&dt_normal)            date formats.\n* *-------------------------------------------------------------------*\n* * Parse function arguments;  there must be at least two.\n* *-------------------------------------------------------------------*\n  callsub parse_argument,((r3),pwa_input,'C')  Get its address\n  errexit name=function_error,(treg,r15,nz),                           *\n               code=4,codereg=r14\n  la    r3,argtable_next              |\n  fill  pwa_input2,c' '               |\n  callsub parse_argument,((r3),pwa_input2,'C')\n  errexit name=function_error,(treg,r15,nz),                           *\n               code=5,codereg=r14\n  la    r3,argtable_next              |\n  callsub parse_argument,((r3),pwa_input_format,'V')  Get its value\n  if    (treg,r15,z)                  | If we got one\n   la    r3,argtable_next             |\n   callsub parse_argument,((r3),pwa_input_format2,'V') Get value.\n   if    (treg,r15,z)                 | If we got one\n    la    r3,argtable_next            |\n    callsub parse_argument,((r3),pwa_output_format,'V') Get value.\n   endif                              |\n  endif                               |\n  drop  r3                            |\n* *-------------------------------------------------------------------*\n* * Special cases:  If incoming interval format is DT_HUNDREDTHS,\n* * DT_SECONDS, DT_MINUTES, DT_HOURS or DT_DAYS, pack it and use\n* * DT_PHUNDREDTHS, etc. internally.\n* *-------------------------------------------------------------------*\n  callsub convert_interval_formats,(pwa_input2,pwa_input_format2)\n* *-------------------------------------------------------------------*\n* * Now, call SRVDT.\n* *-------------------------------------------------------------------*\n  fill  pwa_result,c' '               | Swab the decks first\n  DT_Add      ID=DT,Datein=(pwa_input,pwa_input_format),               *\n               Interval=(pwa_input2,pwa_input_format2),                *\n               Dateout=(pwa_result,pwa_output_format)\n  if    (treg,r15,nz)                 | Bad value, huh?\n   st    r15,pwa_dt_rc                |\n   callsub dt_error                   |  Go set result to error msg\n   leave block=*                      |   and get out.\n  endif                               |\n* *-------------------------------------------------------------------*\n* * Special case:  DT_Hundredths is handy, but SRVDT only supports\n* * it in a binary format.  Convert it to zoned decimal.\n* *-------------------------------------------------------------------*\n  if    (clc,pwa_output_format,eq,=a(&DT_Number_Of_Days)) If #_of_Days\n   l     r1,pwa_result                |  Result is a fullword value\n   cvd   r1,pwa_d                     |  Convert to packed\n   unpk  pwa_result(7),pwa_d          |  Doesn't need to be pretty\n   oi    pwa_result+6,x'f0'           |  Don't forget last byte\n  endif                               |\n* *-------------------------------------------------------------------*\n* * Scan from end of pwa_result looking for 1st non-blank, then pass\n* * the resulting field length and text back to Rexx.\n* *-------------------------------------------------------------------*\n  la    r14,pwa_result+l'pwa_result-1 | We gotta tell Rexx how long the\n  la    r1,l'pwa_result               |  answer is ...\n  loop  bct                           |\n   leave loop=*,(cli,0(r14),ne,c' ')  |\n   bctr  r14,0                        |\n  endloop bct,r1                      |\n  st    r1,evalblock_evlen            | Save result's len in EvalBlock\n  bctr  r1,0                          |\n  exi   r1,(mvc,evalblock_evdata(0),pwa_result)  Set result.\n endblk                               |\n title \"Add Two Time Values\"          |\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Add_Times\n*  Abstract:   This subroutine calls SRVDT to add an interval to a\n*              time value.\n*  Inputs:     No parameters; the PWA contains variables that will\n*              be used for conversion.\n*  Outputs:    EVALBLOCK filled in with result.\n*  Special\n*  Notes:      None.\n*\n*---------------------------------------------------------------------*\n         SPACE 1                      |\n block name=add_times,type=subroutine |\n  tracemsg \"Add_Times entered.\"       |\n  l     r3,efplarg                    | Point to 1st Argtable entry\n  using argtable_entry,r3             |\n* *-------------------------------------------------------------------*\n* * Set default formats.\n* *-------------------------------------------------------------------*\n  mvc   pwa_input_format,=a(&dt_general_input)  Default the input and\n  mvc   pwa_input_format2,=a(&dt_delta)           input and output\n  mvc   pwa_output_format,=a(&dt_civilian)          date formats.\n* *-------------------------------------------------------------------*\n* * Parse function arguments;  there must be at least two.\n* *-------------------------------------------------------------------*\n  callsub parse_argument,((r3),pwa_input,'C')  Get its address\n  errexit name=function_error,(treg,r15,nz),                           *\n               code=4,codereg=r14\n  la    r3,argtable_next              |\n  fill  pwa_input2,c' '               |\n  callsub parse_argument,((r3),pwa_input2,'C')\n  errexit name=function_error,(treg,r15,nz),                           *\n               code=5,codereg=r14\n  la    r3,argtable_next              |\n  callsub parse_argument,((r3),pwa_input_format,'V')  Get its value\n  if    (treg,r15,z)                  | If we got one\n   la    r3,argtable_next             |\n   callsub parse_argument,((r3),pwa_input_format2,'V') Get value.\n   if    (treg,r15,z)                 | If we got one\n    la    r3,argtable_next            |\n    callsub parse_argument,((r3),pwa_output_format,'V') Get value.\n   endif                              |\n  endif                               |\n  drop  r3                            |\n* *-------------------------------------------------------------------*\n* * Special cases:  If incoming interval format is DT_HUNDREDTHS,\n* * DT_SECONDS, DT_MINUTES, DT_HOURS or DT_DAYS, pack it and use\n* * DT_PHUNDREDTHS, etc. internally.\n* *-------------------------------------------------------------------*\n  callsub convert_interval_formats,(pwa_input2,pwa_input_format2)\n* *-------------------------------------------------------------------*\n* * Now, call SRVDT.\n* *-------------------------------------------------------------------*\n  fill  pwa_result,c' '               | Swab the decks first\n  DT_Add      ID=DT,Timein=(pwa_input,pwa_input_format),               *\n               Interval=(pwa_input2,pwa_input_format2),                *\n               Timeout=(pwa_result,pwa_output_format)\n  if    (treg,r15,nz)                 | Bad value, huh?\n   st    r15,pwa_dt_rc                |\n   callsub dt_error                   |  Go set result to error msg\n   leave block=*                      |   and get out.\n  endif                               |\n* *-------------------------------------------------------------------*\n* * Special case:  DT_Hundredths is handy, but SRVDT only supports\n* * it in a binary format.  Convert it to zoned decimal.\n* *-------------------------------------------------------------------*\n  if    (clc,pwa_output_format,eq,=a(&DT_Hundredths)) If .01-seconds\n   l     r1,pwa_result                |  Result is a fullword value\n   cvd   r1,pwa_d                     |  Convert to packed\n   unpk  pwa_result(7),pwa_d          |  Doesn't need to be pretty\n   oi    pwa_result+6,x'f0'           |  Don't forget last byte\n  endif                               |\n* *-------------------------------------------------------------------*\n* * Scan from end of pwa_result looking for 1st non-blank, then pass\n* * the resulting field length and text back to Rexx.\n* *-------------------------------------------------------------------*\n  la    r14,pwa_result+l'pwa_result-1 | We gotta tell Rexx how long the\n  la    r1,l'pwa_result               |  answer is ...\n  loop  bct                           |\n   leave loop=*,(cli,0(r14),ne,c' ')  |\n   bctr  r14,0                        |\n  endloop bct,r1                      |\n  st    r1,evalblock_evlen            | Save result's len in EvalBlock\n  bctr  r1,0                          |\n  exi   r1,(mvc,evalblock_evdata(0),pwa_result)  Set result.\n endblk                               |\n title \"Produce Difference Between Two Dates\"\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Date_Difference\n*  Abstract:   This subroutine calls SRVDT to determine the difference\n*              between two date values.\n*  Inputs:     No parameters; the PWA contains variables that will\n*              be used for conversion.\n*  Outputs:    EVALBLOCK filled in with result.\n*  Special\n*  Notes:      None.\n*\n*---------------------------------------------------------------------*\n         SPACE 1                      |\n block name=date_difference,type=subroutine\n  tracemsg \"Date_Difference entered.\" |\n  l     r3,efplarg                    | Point to 1st Argtable entry\n  using argtable_entry,r3             |\n* *-------------------------------------------------------------------*\n* * Set default formats.\n* *-------------------------------------------------------------------*\n  mvc   pwa_input_format,=a(&dt_general_input)  Default the input and\n  mvc   pwa_input_format2,=a(&dt_general_input)   input and output\n  mvc   pwa_output_format,=a(&dt_days)              date formats.\n* *-------------------------------------------------------------------*\n* * Parse function arguments;  there must be at least two.\n* *-------------------------------------------------------------------*\n  callsub parse_argument,((r3),pwa_input,'C')  Get its address\n  errexit name=function_error,(treg,r15,nz),                           *\n               code=4,codereg=r14\n  la    r3,argtable_next              |\n  fill  pwa_input2,c' '               |\n  callsub parse_argument,((r3),pwa_input2,'C')\n  errexit name=function_error,(treg,r15,nz),                           *\n               code=5,codereg=r14\n  la    r3,argtable_next              |\n  callsub parse_argument,((r3),pwa_input_format,'V')  Get its value\n  if    (treg,r15,z)                  | If we got one\n   la    r3,argtable_next             |\n   callsub parse_argument,((r3),pwa_input_format2,'V') Get value.\n   if    (treg,r15,z)                 | If we got one\n    la    r3,argtable_next            |\n    callsub parse_argument,((r3),pwa_output_format,'V') Get value.\n   endif                              |\n  endif                               |\n  drop  r3                            |\n* *-------------------------------------------------------------------*\n* * Now, call SRVDT.\n* *-------------------------------------------------------------------*\n  fill  pwa_result,c' '               | Swab the decks first\n  DT_Duration ID=DT,Date1=(pwa_input,pwa_input_format),                *\n               Date2=(pwa_input2,pwa_input_format2),                   *\n               Duration=(pwa_result,pwa_output_format)\n  if    (treg,r15,nz)                 | Bad value, huh?\n*  dc    h'0'\n   st    r15,pwa_dt_rc                |\n   callsub dt_error                   |  Go set result to error msg\n   leave block=*                      |   and get out.\n  endif                               |\n* *-------------------------------------------------------------------*\n* * Scan from end of pwa_result looking for 1st non-blank, then pass\n* * the resulting field length and text back to Rexx.\n* *-------------------------------------------------------------------*\n  la    r14,pwa_result+l'pwa_result-1 | We gotta tell Rexx how long the\n  la    r1,l'pwa_result               |  answer is ...\n  loop  bct                           |\n   leave loop=*,(cli,0(r14),ne,c' ')  |\n   bctr  r14,0                        |\n  endloop bct,r1                      |\n  st    r1,evalblock_evlen            | Save result's len in EvalBlock\n  bctr  r1,0                          |\n  exi   r1,(mvc,evalblock_evdata(0),pwa_result)  Set result.\n endblk                               |\n title \"Create SRVDT-Related Variables For DTSETUP Function\"\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Create_Variables\n*  Abstract:   This routine creates a bunch of handy variables that\n*              subsequent calls to SRVDT functions can use later;\n*              mainly these are date/time formats and return codes.\n*  Inputs:     None.\n*  Outputs:    Bunch of variables are set.\n*  Special\n*  Notes:      None.\n*\n*---------------------------------------------------------------------*\n         SPACE 1                      |\n block name=create_variables,type=subroutine\n* tracemsg \"Create_Variables entered.\"\n*--------------------------------------------------------------------*\n* Return code variables.\n*--------------------------------------------------------------------*\n  set_immediate DT_SUCCESS,0          |\n  set_immediate DT_INVALID_FUNCTION,1 |\n  set_immediate DT_INVALID_NUMBER_OF_PARMS,2\n  set_immediate DT_INVALID_DT_ID,3    |\n  set_immediate DT_ENVIRONMENT_SUPPORT_ERROR,4\n  set_immediate DT_STRING_HANDLER_ERROR,5\n  set_immediate DT_INVALID_DATE_FORMAT,6\n  set_immediate DT_INVALID_TIME_FORMAT,7\n  set_immediate DT_INVALID_INTERVAL_FORMAT,8\n  set_immediate DT_INVALID_INPUT_DATE,9\n  set_immediate DT_INVALID_INPUT_TIME,10\n  set_immediate DT_INVALID_INPUT_INTERVAL,11\n  set_immediate DT_OVERFLOW,12        |\n  set_immediate DT_OUT_OF_RANGE,13    |\n*--------------------------------------------------------------------*\n* Supported date formats.\n*--------------------------------------------------------------------*\n*--------------------------------------------------------------------*\n*  Numeric formats (Julian, number-of-days)\n*--------------------------------------------------------------------*\n  set_immediate DT_JULIAN,&dt_julian\n  set_immediate DT_JULIAND,&dt_juliand\n  set_immediate DT_SJULIAN,&dt_sjulian\n  set_immediate DT_SJULIAND,&dt_sjuliand\n  set_immediate DT_NUMBER_OF_DAYS,&dt_number_of_days\n*--------------------------------------------------------------------*\n*  Month-day-year formats (Gregorian, sortdate).  Numeric year,\n*  day and month values fall within this group.\n*--------------------------------------------------------------------*\n  set_immediate DT_SGREGORIAN,&dt_sgregorian\n  set_immediate DT_GREGORIAN,&dt_gregorian\n  set_immediate DT_SORTDATE,&dt_sortdate\n  set_immediate DT_SSORTDATE,&dt_ssortdate\n  set_immediate DT_YEAR,&dt_year\n  set_immediate DT_YEAR2,&dt_year2\n  set_immediate DT_DAYS,&dt_days\n  set_immediate DT_MONTH,&dt_month\n*--------------------------------------------------------------------*\n*  Normal formats (Normal, SAS date).\n*--------------------------------------------------------------------*\n  set_immediate DT_SNORMAL,&dt_snormal\n  set_immediate DT_NORMAL,&dt_normal\n  set_immediate DT_SASDATE7,&dt_sasdate7\n  set_immediate DT_SASDATE9,&dt_sasdate9\n*--------------------------------------------------------------------*\n*  Text formats. Weekday and month names appear here.\n*--------------------------------------------------------------------*\n  set_immediate DT_TEXT,&dt_text\n  set_immediate DT_TEXTD,&dt_textd\n  set_immediate DT_WEEKDAY,&dt_weekday\n  set_immediate DT_WEEKDAY3,&dt_weekday3\n  set_immediate DT_MONTHNAME,&dt_monthname\n  set_immediate DT_MONTHNAME3,&dt_monthname3\n  set_immediate DT_DEFAULT_DATE_FORMAT,&dt_default_date_format\n*--------------------------------------------------------------------*\n  set_immediate DT_GENERAL_INPUT,&dt_general_input\n*--------------------------------------------------------------------*\n* Supported time formats.\n*--------------------------------------------------------------------*\n  set_immediate DT_HUNDREDTHS,&dt_hundredths\n  set_immediate DT_HHMM,&dt_hhmm\n  set_immediate DT_HHMMSS,&dt_hhmmss\n  set_immediate DT_HHMMSSTH,&dt_hhmmssth\n  set_immediate DT_CIVILIAN,&dt_civilian\n  set_immediate DT_HOURS,&dt_hours\n  set_immediate DT_MINUTES,&dt_minutes\n  set_immediate DT_SECONDS,&dt_seconds\n  set_immediate DT_DEFAULT_TIME_FORMAT,&dt_default_time_format\n*--------------------------------------------------------------------*\n* Supported interval formats.\n*--------------------------------------------------------------------*\n  set_immediate DT_DELTA,&dt_delta    | C'    3-:10:25:15.25'\n  set_immediate DT_HUNDREDTHS,&dt_hundredths\n*--------------------------------------------------------------------*\n* Return a zero to caller.\n*--------------------------------------------------------------------*\n  mvc   evalblock_evlen,=f'1'         | Set length of result to 1\n  mvi   evalblock_evdata,c'0'         | Set result to C'0'.\n endblk                               |\n title \"Parse Arguments From Rexx\"    |\n block name=parse_argument,type=subroutine\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Parse_Argument\n*  Abstract:   This routine fills out variables based on the contents\n*              of the Rexx ARGTABLE.\n*  Inputs:     On entry, R1 points to the following parameter list:\n*                +0 - The current ARGTABLE entry.\n*                +4 - Place to save the value.\n*                +8 - Action to take with argument:\n*                      C'C' - Save text of data at +4%\n*                      C'V' - Save value of data at +4%\n*\n*  Outputs:    Area at parmlist+4% set as requested.  RC 4 indicates\n*              that the function was not done (e.g arg pointer was\n*              x'FF's or pointed to zero), while RC 8 ...\n*\n*  Special Notes:\n*\n*    For \"value\" requests, a value of zero will not be stored (e.g will\n*    not overlay any \"default\" that may have been pre-set).\n*\n*    Also, variable DT_RC will contain SRVDT's return code.  Note that\n*    all numeric variables must be zoned-decimal.\n*\n*---------------------------------------------------------------------*\n  lm    r3,r5,0(r1)                   | Pick up parameters\n  tracemsg \"Parse_Argument entered.\"  |\n  using argtable_entry,r3             | R3 points to Argtable entry.\n  if    (cli,0(r3),eq,x'ff')          | If no parameter here\n   la    r15,4                        |  Set RC for caller\n   leave block=*                      |   and exit.\n  endif                               |\n  if    (cli,0(r5),eq,c'C')           | Save address of data?\n   l     r1,argtable_argstring_length |           Get its length\n   errexit name=function_error,(ch,r1,gt,=h'32'), Sanity-check it      *\n               code=8,codereg=r14     |\n   bctr  r1,0                         |           Do a VL move.\n   l     r15,argtable_argstring_ptr   |\n   exi   r1,(mvc,0(0,r4),0(r15))      |\n  elseif (cli,0(r5),eq,c'V')          | Save value of data?\n   l     r2,argtable_argstring_ptr    |  Point to argument string\n   l     r1,argtable_argstring_length |  Get its length\n   bctr  r1,0                         |  Subtract 1 for execute\n   exi   r1,(pack,&w.d,0(0,r2))       |  Pack VL string\n   validate_packed_data data=&w.d,len=8 Make sure it's OK\n   if    (treg,r15,nz)                |\n    leave block=*                     |\n   endif                              |\n   cvb   r1,&w.d                      |  Convert to integer\n   if    (treg,r1,nz)                 |  If present and nonzero\n    st    r1,0(r4)                    |   Save for SRVDT later,\n   endif                              |   overriding the default.\n  else                                | Otherwise (bad 3rd parm)\n   errexit name=function_error,       |  We got a bad call somewhere.  *\n               code=6,codereg=r14     |\n  endif                               |\n  xr    r15,r15                       |\n  drop  r3                            |\n endblk                               |\n swa   ,                              |\n&w.d   ds   d                         |\n endswa ,                             |\n title \"Define And Set Variables By Calling IRXEXCOM\"\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Set_Variable\n*  Abstract:   This routine sets a Rexx variable using IRXEXCOM.\n*  Inputs:     On entry, R1 points to the following parameter list:\n*                +0 - Address of variable name\n*                +4 - Length of variable name\n*                +8 - Address of value to stuff in it\n*                +C - Length of value to stuff in it\n*  Outputs:    Variable set as requested.\n*  Special\n*  Notes:      Macros Set_Variable and Set_Immediate generate calls to\n*              this routine.\n*\n*---------------------------------------------------------------------*\n block name=set_variable,type=subroutine\n* *-------------------------------------------------------------------*\n* * To call IRXEXCOM, R1 points to the following parameter list:\n* *   a('IRXEXCOM')     > Address of CL8'IRXEXCOM'\n* *   a(0)              > For whatever reason, these two addresses\n* *   a(0)              > must be identical.  Zero is OK.\n* *   a(SHVBLOCK)       > Address of 1st 32-byte SHVBLOCK.  Refer to\n* *                       SYS1.MACLIB(IRXSHVB).\n* *-------------------------------------------------------------------*\n  lm    r2,r5,0(r1)                   | Pick up caller's parms\n* tracemsg \"Set_Variable entered.\"\n  fill  &w.shvb                       | Clear out the SHVB first\n  la    r6,&w.shvb                    | Point a base reg at it\n  using shvblock,r6                   |\n  mvi   shvcode,shvstore              | Set func code to \"STORE\"\n  st    r2,shvnama                    | Set address of variable name\n  l     r0,0(r3)                      |\n  mvc   shvnaml,0(r3)                 | Set length of variable name\n  st    r4,shvvala                    | Set address of variable buffer\n  mvc   shvvall,0(r5)                 | Set length of variable buffer\n  l     r2,pwa_irxexte                |\n  using irxexte,r2                    |\n  callx irxexcom,('IRXEXCOM',0,0,&w.shvb)\n  errexit name=function_error,(treg,r15,nz),code=7,codereg=r14\n  drop  r2                            |\n endblk rc=(r15)                      |\n swa   ,                              |\n&w.shvb  ds   cl32                    |\n endswa  ,                            |\n    eject ,                           |\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Convert_Integer_Formats\n*  Abstract:   This routine will convert the character \"integer\"\n*              formats to their packed-decimal equivalent.\n*  Inputs:     On entry, R1 points to the following parameter list:\n*                +0 - Address of input field\n*                +4 - Address of fullword format value\n*  Outputs:    If input format was one that we needed to convert, the\n*              input field contains the converted value and the input\n*              format field contains the new format.\n*  Special\n*  Notes:      None.\n*\n*---------------------------------------------------------------------*\n         SPACE 1                      |\n block name=convert_interval_formats,type=subroutine\n  lm    r3,r4,0(r1)                   |\n  l     r14,0(r4)                     |\n  caseblk reg=r14,mult=1              |\n   case &DT_Hundredths,&DT_Seconds,&DT_Minutes,&DT_Hours,&DT_Days,     *\n               &DT_Month\n    tracemsg \"Converter: Conversion started.\"\n    la    r1,31(,r3)                  | Point to end of input string\n    la    r15,32                      | Assumed length of input\n    loop  bct                         | Loop thru input:\n     leave loop=*,(cli,0(r1),ne,c' ') |  Quit when nonblank seen.\n     bctr  r1,0                       |  Decrement text ptr\n    endloop bct,r15                   | Decrement counter.\n    bctr  r15,0                       | Knock one off for EXI\n    exi   r15,(pack,pwa_d,0(0,r3))    | Move it to work field.\n    validate_packed_data data=pwa_d,  | Make sure it's OK ...          *\n               len=l'pwa_d,           |   macro will errexit if not.   *\n               type=INTERVAL          |\n    mvc   0(4,r3),pwa_d+4             | These formats are all PL4.\n    l     r14,0(r4)                   | Decide which packed format:\n    caseblk reg=r14,mult=1            |\n     case &DT_Hundredths              |\n      mvc   0(4,r4),=a(&DT_Phundredths)\n     case &DT_Seconds                 |\n      mvc   0(4,r4),=a(&DT_Pseconds)  |\n     case &DT_Minutes                 |\n      mvc   0(4,r4),=a(&DT_Pminutes)  |\n     case &DT_Hours                   |\n      mvc   0(4,r4),=a(&DT_Phours)    |\n     case &DT_Days                    |\n      tracemsg \"DT_Days Converted To DT_Pdays.\"\n      mvc   0(4,r4),=a(&DT_Pdays)     |\n     case &DT_Month                   |\n      tracemsg \"DT_Month Converted To DT_Pmonth.\"\n      mvc   0(4,r4),=a(&DT_Pmonth)    |\n    endcase                           |\n  endcase                             |\n endblk                               |\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Convert_Date_Formats\n*  Abstract:   This routine will convert the character \"integer\"\n*              formats to their packed-decimal equivalent.\n*  Inputs:     On entry, R1 points to the following parameter list:\n*                +0 - Address of input field\n*                +4 - Address of fullword format value\n*  Outputs:    If input format was one that we needed to convert, the\n*              input field contains the converted value and the input\n*              format field contains the new format.\n*  Special\n*  Notes:      None.\n*\n*---------------------------------------------------------------------*\n         SPACE 1                      |\n block name=convert_date_formats,type=subroutine\n  lm    r3,r4,0(r1)                   |\n  l     r14,0(r4)                     |\n  caseblk reg=r14,mult=1              |\n   case &DT_Number_Of_Days\n    tracemsg \"Converter: Conversion started.\"\n    la    r1,31(,r3)                  | Point to end of input string\n    la    r15,32                      | Assumed length of input\n    loop  bct                         | Loop thru input:\n     leave loop=*,(cli,0(r1),ne,c' ') |  Quit when nonblank seen.\n     bctr  r1,0                       |  Decrement text ptr\n    endloop bct,r15                   | Decrement counter.\n    bctr  r15,0                       | Knock one off for EXI\n    exi   r15,(pack,pwa_d,0(0,r3))    | Move it to work field.\n    validate_packed_data data=pwa_d,  | Make sure it's OK ...          *\n               len=l'pwa_d,           |   macro will errexit if not.   *\n               type=INTERVAL          |\n    mvc   0(4,r3),pwa_d+4             | These formats are all PL4.\n    l     r14,0(r4)                   | Decide which packed format:\n    tracemsg \"DT_Number_Of_Days converted to integer.\"\n    cvb   r1,pwa_d\n    st    r1,0(,r3)\n  endcase                             |\n endblk                               |\n  title \"DT_Error: Set SRVDT error code, return to caller\"\n*---------------------------------------------------------------------*\n*\n*  Subroutine: DT_Error\n*  Abstract:   Set Rexx variable DT_RC to whatever's in R15.\n*  Inputs:     R15 contains the SRVDT return code.\n*  Outputs:    DT_RC set. Also, the function return variable is set to\n*              a string describing the error (eg \"Invalid Date Format\")\n*  Special\n*  Notes:      None.\n*\n*---------------------------------------------------------------------*\n         SPACE 1                      |\n         macro                        |\n         set_message &text            |\n         lcla  &ltext                 |\n&ltext   seta  k'&text-2              | Assumes string is quoted.\n         psd   type=partial           |\n#txt&sysndx  dc c&text                |\n         endpsd ,                     |\n         mvc   evalblock_evdata(l'#txt&sysndx),#txt&sysndx\n         mvc   evalblock_evlen,=F'&ltext'\n         mend   ,                     |\n block name=dt_error,type=subroutine  |\n* ex    0,*                           |\n  l     r15,pwa_dt_rc                 |\n  cvd   r15,pwa_d                     | Convert SRVDT RC to packed\n  lr    r4,r15                        | Save SRVDT RC for CASEBLK\n  tracemsg \"*** DT_Error entered. ***\"\n  unpk  pwa_unpk,pwa_d                | Convert SRVDT RC to text\n  oi    pwa_unpk+l'pwa_unpk-1,x'f0'   | Clean up after UNPK\n  la    r3,pwa_unpk                   | Find the first nonzero digit:\n  la    r2,l'pwa_unpk                 |\n  loop  bct                           |\n   leave loop=*,(cli,0(r3),ne,c'0')   |  Exit when a digit \u00ac= zero.\n   la    r3,1(,r3)                    |  At end, R3 points to nonzero\n  endloop bct,r2                      |  digit or past end of string.\n  st    r2,&w.f                       |\n  set_variable  dt_rc,(r3),&w.f       | Set dt_rc to R3% for len of R2.\n  caseblk reg=r4,mult=1               | Select error text to return ...\n   case   &dt_invalid_function        |\n    set_message \"Invalid function for SRVDT.\"\n   case   &dt_invalid_number_of_parms |\n    set_message \"Invalid number of parameters.\"\n   case   &dt_invalid_dt_id           |\n    set_message \"SRVDT token validation error.\"\n   case   &dt_environment_support_error\n    set_message \"Environment support error.\"\n   case   &dt_string_handler_error    |\n    set_message \"String handler error.\"\n   case   &dt_invalid_date_format     |\n    set_message \"Invalid date format.\"\n   case   &dt_invalid_time_format     |\n    set_message \"Invalid time format.\"\n   case   &dt_invalid_interval_format |\n    set_message \"Invalid interval format.\"\n   case   &dt_invalid_input_date      |\n    set_message \"Invalid input date value.\"\n   case   &dt_invalid_input_time      |\n    set_message \"Invalid input time value.\"\n   case   &dt_invalid_input_interval  |\n    set_message \"Invalid input interval value.\"\n   case   &dt_overflow                |\n    set_message \"Date value overflow.\"\n   case   &dt_out_of_range            |\n    set_message \"Date out of range.\"  |\n   case   other                       |\n    set_message \"Unknown SRVDT error.\"\n  endcase                             |\n endblk                               |\n swa   ,                              |\n&w.f   ds   f                         |\n endswa ,                             |\n*---------------------------------------------------------------------*\n block name=start_service_processors,type=subroutine\n  es_MVS_load id=ES                  |\n  ES_Start id=ES                     |\n  ES_Load_Module id=ES,spid=DT       |\n  errexit name=function_error,(treg,r15,nz),code=1,codereg=r14\n  DT_Start     ID=DT                 | /* options=european */\n  if    (treg,r15,nz)                |\n   st    r15,pwa_dt_rc                |\n   callsub dt_error                  |\n   leave block=*                     |\n  endif                              |\n endblk                               |\n*---------------------------------------------------------------------*\n block name=stop_service_processors,type=subroutine\n  DT_Terminate ID=DT                  | Terminate service processors.\n  ES_Unload_Module id=ES,spid=DT      |\n  ES_Terminate ID=ES                  |\n  ES_MVS_Unload ID=ES                 |\n  xc    pwa_dt_token,pwa_dt_token     |\n endblk                               |\n*---------------------------------------------------------------------*\n*\n*  Errexit:    Function_Error\n*  Purpose:    Return RC 16 to the caller for non-SRVDT errors.\n*  Called By:  Various\n*  Inputs:     None\n*  Outputs:    RC 16 for exit.\n*  Special\n*  Notes:      None.\n*\n*---------------------------------------------------------------------*\n         SPACE 1                      |\n block name=function_error,type=errexit\n  lr    r4,r14                        |\n  tracemsg \"Errexit Function_Error entered.\"\n  callsub stop_service_processors     |\n  lr    r14,r4                        |\n endblk rc=16                         |\n title \"Program Static Data, Constants\"\n psd   ,                              |\n*---------------------------------------------------------------------*\n*\n*  The packed-decimal translate-and-test table works as follows:\n*    .. Valid non-sign bytes have a value of x'00' in the table.\n*    .. Valid sign bytes have a value of x'08' in the table. These\n*       should only occur as the last byte in the field being tested.\n*    .. All other bytes have a value of x'04' in the table. If one of\n*       these is found, the packed-decimal number is not legal.\n*  The table is used by macro \"Validate_Packed_Data\".\n*\n*---------------------------------------------------------------------*\n*                          0 1 2 3 4 5 6 7 8 9 a b c d e f\npsd_packed_table dc  xl16'00000000000000000000080808080808' 0\n                 dc  xl16'00000000000000000000080808080808' 1\n                 dc  xl16'00000000000000000000080808080808' 2\n                 dc  xl16'00000000000000000000080808080808' 3\n                 dc  xl16'00000000000000000000080808080808' 4\n                 dc  xl16'00000000000000000000080808080808' 5\n                 dc  xl16'00000000000000000000080808080808' 6\n                 dc  xl16'00000000000000000000080808080808' 7\n                 dc  xl16'00000000000000000000080808080808' 8\n                 dc  xl16'00000000000000000000080808080808' 9\n                 dc  xl16'04040404040404040404040404040404' a\n                 dc  xl16'04040404040404040404040404040404' b\n                 dc  xl16'04040404040404040404040404040404' c\n                 dc  xl16'04040404040404040404040404040404' d\n                 dc  xl16'04040404040404040404040404040404' e\n                 dc  xl16'04040404040404040404040404040404' f\n ltorg ,                              |\n endpsd ,                             |\n title \"Program Workarea, Misc. Data Areas\"\n pwa   ,                              |\npwa_d              ds  d              |\npwa_esv_address    dc  f'0'           |\npwa_es_epa         dc  f'0'           |\npwa_es_token       dc  f'0'           |\npwa_dt_epa         dc  f'0'           |\npwa_dt_token       dc  f'0'           |\npwa_dt_rc          ds  f              |\npwa_irxexte        ds  f              |\npwa_input_format   ds  f              |\npwa_input_format2  ds  f              |\npwa_output_format  ds  f              |\npwa_input_len      ds  f              |\npwa_input_len2     ds  f              |\npwa_function_name  ds  cl8            |\npwa_input          ds  cl32           |\npwa_input2         ds  cl32           |\npwa_result         ds  cl32           |\npwa_unpk           ds  cl9            |\npwa_packed_validation  ds  cl9        |\n endpwa ,                             |\n space 1                              |\n irxenvb ,                            | Rexx environment block.\n space 1                              |\n irxefpl ,                            | External function parmlist.\n space 1                              |\n irxargtb ,                           | Argument list.\n space 1                              |\n irxevalb ,                           | Evaluation block.\n space 1                              |\n irxshvb ,                            | Shared variable block.\n space 1                              |\n irxexte ,                            | Rexx external entry points.\n space 1                              |\n         title \"DATECNVT: Entry Stub For Date Conversion\"\n**--------------------------------------------------------------------*\n**\n**  Stub for date conversion.\n**\n**--------------------------------------------------------------------*\n block name=DATECNVT,type=program,    |                                *\n               options=(*pwa,xa,noregequ,noclearpwa),                  *\n               amode=31,rmode=any,r1save=r9\n  using efpl,r9                       |\n  l     r10,4(,r13)                   | Dig R0 out of the savearea\n  l     r10,20(,r10)                  |\n  callx =v(DTSERVS),('DATECNVT',(r9),(r10)),vl\n endblk                               |\n psd   ,                              |\n   ltorg ,                            |\n endpsd ,                             |\n pwa   ,                              |\n endpwa ,                             |\n drop  ,                              |\n         title \"TIMECNVT: Entry Stub For Time Conversion\"\n**--------------------------------------------------------------------*\n**\n**  Stub for time conversion.\n**\n**--------------------------------------------------------------------*\n block name=TIMECNVT,type=program,    |                                *\n               options=(*pwa,xa,noregequ,noclearpwa),                  *\n               amode=31,rmode=any,r1save=r9\n  using efpl,r9                       |\n  l     r10,4(,r13)                   | Dig R0 out of the savearea\n  l     r10,20(,r10)                  |\n  callx =v(DTSERVS),('TIMECNVT',(r9),(r10)),vl\n endblk                               |\n psd   ,                              |\n   ltorg ,                            |\n endpsd ,                             |\n pwa   ,                              |\n endpwa ,                             |\n drop  ,                              |\n         title \"DATEADD: Entry Stub For Date Addition\"\n**--------------------------------------------------------------------*\n**\n**  Stub for date addition.\n**\n**--------------------------------------------------------------------*\n block name=DATEADD,type=program,     |                                *\n               options=(*pwa,xa,noregequ,noclearpwa),                  *\n               amode=31,rmode=any,r1save=r9\n  using efpl,r9                       |\n  l     r10,4(,r13)                   | Dig R0 out of the savearea\n  l     r10,20(,r10)                  |\n  callx =v(DTSERVS),('DATEADD ',(r9),(r10)),vl\n endblk                               |\n psd   ,                              |\n   ltorg ,                            |\n endpsd ,                             |\n pwa   ,                              |\n endpwa ,                             |\n drop  ,                              |\n         title \"TIMEADD: Entry Stub For Date Addition\"\n**--------------------------------------------------------------------*\n**\n**  Stub for time addition.\n**\n**--------------------------------------------------------------------*\n block name=TIMEADD,type=program,     |                                *\n               options=(*pwa,xa,noregequ,noclearpwa),                  *\n               amode=31,rmode=any,r1save=r9\n  using efpl,r9                       |\n  l     r10,4(,r13)                   | Dig R0 out of the savearea\n  l     r10,20(,r10)                  |\n  callx =v(DTSERVS),('TIMEADD ',(r9),(r10)),vl\n endblk                               |\n psd   ,                              |\n   ltorg ,                            |\n endpsd ,                             |\n pwa   ,                              |\n endpwa ,                             |\n drop  ,                              |\n         title \"DATEDIFF: Entry Stub For Date Addition\"\n**--------------------------------------------------------------------*\n**\n**  Stub for date difference.\n**\n**--------------------------------------------------------------------*\n block name=DATEDIFF,type=program,    |                                *\n               options=(*pwa,xa,noregequ,noclearpwa),                  *\n               amode=31,rmode=any,r1save=r9\n  using efpl,r9                       |\n  l     r10,4(,r13)                   | Dig R0 out of the savearea\n  l     r10,20(,r10)                  |\n  callx =v(DTSERVS),('DATEDIFF',(r9),(r10)),vl\n endblk                               |\n psd   ,                              |\n   ltorg ,                            |\n endpsd ,                             |\n pwa   ,                              |\n endpwa ,                             |\n drop  ,                              |\n         title \"DTSETUP: Entry Stub For SRVDT Rexx Variable Setup\"\n**--------------------------------------------------------------------*\n**\n**  Stub for Rexx variable setup.\n**\n**--------------------------------------------------------------------*\n block name=DTSETUP,type=program,     |                                *\n               options=(*pwa,xa,noregequ,noclearpwa),                  *\n               amode=31,rmode=any,r1save=r9\n  using efpl,r9                       |\n  l     r10,4(,r13)                   | Dig R0 out of the savearea\n  l     r10,20(,r10)                  |\n  callx =v(DTSERVS),('DTSETUP ',(r9),(r10)),vl\n endblk                               |\n psd   ,                              |\n   ltorg ,                            |\n endpsd ,                             |\n pwa   ,                              |\n endpwa ,                             |\n drop  ,                              |\n end ,                                |\n//C.SYSLIB DD\n//         DD\n//         DD DSN=SYSTEMS.SRV.SOURCE,DISP=SHR\n//L.SYSIN  DD  *\n NAME SRVDTREX(R)                     |\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SRVDTXMM": {"ttr": 18440, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x02\\x00\\x00V\\x01\\x11)\\x9f\\x01\\x11)\\x9f\\t'\\x00P\\x00P\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@\"", "ispf": {"version": "02.00", "flags": 0, "createdate": "2011-10-26T00:00:00", "modifydate": "2011-10-26T09:27:56", "lines": 80, "newlines": 80, "modlines": 0, "user": "CLEMSON"}, "text": "*---------------------------------------------------------------------*\n*  Copyright 2011 by Clemson University Research Foundation           *\n*                                                                     *\n*  Licensed under the Apache License, Version 2.0 (the \"License\");    *\n*  you may not use this file except in compliance with the License.   *\n*  You may obtain a copy of the License in this library as member     *\n*  $LICENSE, or from                                                  *\n*                                                                     *\n*      http://www.apache.org/licenses/LICENSE-2.0                     *\n*                                                                     *\n*  Unless required by applicable law or agreed to in writing,         *\n*  software distributed under the License is distributed on an \"AS    *\n*  IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either    *\n*  express or implied.  See the License for the specific language     *\n*  governing permissions and limitations under the License.           *\n*---------------------------------------------------------------------*\n//SRVDTXMM JOB\n//  EXEC  ASMPCL,PDS='SYSTEMS.SRV.LOAD',NAME=SRVDTXMM\n//P.SYSIN  DD  *\n SMLIST CONVERT=YES\n print off\n copy  srvdtmac\n copy  srvesmac\n copy  srvstmac\n print on\n block name=srvdtxmm,type=program,options=(*pwa,xa),amode=31,rmode=any\n  es_id id=es\n  dt_id id=dt\n  st_id id=st,sizelength=4\n  es_mvs_load id=es\n  es_start    id=es\n  es_load_module id=es,spid=dt\n  dt_start     id=dt\n  es_load_module id=es,spid=st\n  st_start     id=st\n* *-------------------------------------------------------------------*\n   dt_add   id=dt,                   |                                 +\n               datein=(psd_input_date,&dt_sortdate),                   +\n               timein=(psd_input_time,&dt_hhmmss),                     +\n               interval=(psd_zeros,&dt_todclock),                      +\n               timeout=(pwa_todclock,&dt_todclock)\n   es_display_message id=es,message=\"Input:\"\n   es_display_message id=es,message=psd_input_date\n   es_display_message id=es,message=psd_input_time\n   es_display_message id=es,message=\" \"\n\n   st_format id=st,control=\"{XL4}\",string=pwa_todprint,                +\n               source=pwa_todclock\n   es_display_message id=es,message=\"TOD Clock:\"\n   es_display_message id=es,message=pwa_todprint\n   es_display_message id=es,message=\" \"\n\n   mvc        pwa_todclock+4(4),=f'0'\n   dt_convert id=dt,fromtime=(pwa_todclock,&dt_todclock),              +\n               todate=(pwa_print_date,&dt_sortdate),                   +\n               totime=(pwa_print_time,&dt_hhmmss)\n   es_display_message id=es,message=\"Output:\"\n   es_display_message id=es,message=pwa_print_date\n   es_display_message id=es,message=pwa_print_time\n   es_display_message id=es,message=\" \"\n   es_display_message id=es,message=\"------------\"\n\n* *-------------------------------------------------------------------*\n  dt_terminate id=dt\n endblk\n               psd\npsd_input_date dc c'2009-01-15'\npsd_input_time dc c'14:51:26'\npsd_zeros      dc xl8'00'\n               endpsd\n               pwa\npwa_todclock   ds  d\npwa_todprint   ds  cl8\npwa_print_date ds  c'1989-12-25'\npwa_print_time ds  c'hh:mm:ss'\n               endpwa\n               end\n//C.SYSLIB DD\n//         DD\n//         DD DSN=SYSTEMS.SRV.DONTEDIT,DISP=SHR\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SRVDTXRZ": {"ttr": 18443, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x02\\x00\\x00W\\x01\\x11)\\x9f\\x01\\x11)\\x9f\\t'\\x03\\xe3\\x03\\xe3\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@\"", "ispf": {"version": "02.00", "flags": 0, "createdate": "2011-10-26T00:00:00", "modifydate": "2011-10-26T09:27:57", "lines": 995, "newlines": 995, "modlines": 0, "user": "CLEMSON"}, "text": "*---------------------------------------------------------------------*\n*  Copyright 2011 by Clemson University Research Foundation           *\n*                                                                     *\n*  Licensed under the Apache License, Version 2.0 (the \"License\");    *\n*  you may not use this file except in compliance with the License.   *\n*  You may obtain a copy of the License in this library as member     *\n*  $LICENSE, or from                                                  *\n*                                                                     *\n*      http://www.apache.org/licenses/LICENSE-2.0                     *\n*                                                                     *\n*  Unless required by applicable law or agreed to in writing,         *\n*  software distributed under the License is distributed on an \"AS    *\n*  IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either    *\n*  express or implied.  See the License for the specific language     *\n*  governing permissions and limitations under the License.           *\n*---------------------------------------------------------------------*\n//SRVDTXRZ JOB TIME=(,8)\n/*JOBPARM LINES=25\n//  EXEC  ASMPCL,COPT=',RENT',LOPT=',RENT,REUS,REFR',\n//    PDS='SYSTEMS.SRV.LOAD',NAME=SRVDTXRZ,MAC=SYSTEMS\n//P.SYSIN  DD  *\n     SMLIST CONVERT=YES               |\nSRVDTXRZ     TITLE 'Exerciser For Message Service Processor'\n*---------------------------------------------------------------------*\n*\n*  Copyright (C) 1989 Clemson University\n*\n*  Program     SRVDTXRZ\n*\n*  Abstract    This is an exerciser routine for functions of the Date/\n*              Time Service Processor (SRVDT).  Feel free to add tests\n*              for SRVDT as development progesses.\n*\n*  Inputs:\n*      Parameters  None\n*      Files       None\n*      Other       Terminal (uses TGET for input)\n*\n*  Outputs:\n*      Returncodes None\n*      Messages    Various\n*      Files       SYSPRINT (used by Printline service processor)\n*      Other       Terminal (uses TPUT too)\n*\n*  PROGRAM     Reentrant, problem key and state, standard linkage,\n*  ATTRIBUTES  non-authorized, AMODE(31), RMODE(24)\n*\n*  Special\n*  Notes       None\n*\n*  Change\n*  History     12/01/89 JCB - New\n*              __/__/__ ___\n*              __/__/__ ___\n*\n*  Method of   SRVDTXRZ is a series of tests, each consisting of:\n*  Operation     . Prompt for the test ('enter any char for test, or\n*                  null line for next test')\n*                . Test, usually coded as loop within a subroutine\n*              Note that SRVDT errors are expected, and shouldn't cause\n*              the exerciser to terminate. A 'Callsub DT_Error' will\n*              print the debug information without terminating.\n*\n*---------------------------------------------------------------------*\n         EJECT                        |\n     copy  srvdtmac                   |\n     print off                        |\n     copy  srvesmac                   |\n     copy  srvplmac                   |\n     print on,gen                     |\n     eject                            |\n block name=SRVDTXRZ,type=program,    |                                *\n               options=(*pwa,xa,mode,long,novl),                       *\n               amode=31,              |                                *\n               subopts=(*swa,loadbase),                                *\n               basereg=(r12,r10),     |                                *\n               rmode=24               |\n     eject                            |\n  es_id id=es,esva=pwa_esv_address,   |                                +\n               spepa=pwa_es_epa,      |                                +\n               sptoken=pwa_es_token   |\n      space 1                         |\n  pl_id id=pl,esva=pwa_esv_address,   |                                *\n               esid=es,               |                                *\n               spepname=&PRINT_LINE,  |                                *\n               sizelength=2           |\n      space 1                         |\n  dt_id id=DT,spepname=&DateTime_Services\n     eject                            |\n  es_MVS_load id=ES                   |\n  ES_Start id=ES                      |\n  ES_Load_Module id=ES,spid=DT        |\n  if    (treg,r15,nz)                 |\n   ex    0,*                          |\n  endif                               |\n  ES_Load_Module id=ES,spid=PL        |\n  if    (treg,r15,nz)                 |\n   ex    0,*                          |\n  endif                               |\n  PL_Start     ID=PL,                 |                                *\n               DDname='SYSPRINT',     |                                *\n               PageSize=12,           |                                *\n               MaxLnSz=121            |\n  errexit (treg,r15,nz)               |\n  DT_Start     ID=DT                  | /* options=european */\n  errexit (treg,r15,nz)               |\n        eject                         |\n* *-------------------------------------------------------------------*\n* *  DT_Get_Current Testing\n* *-------------------------------------------------------------------*\n  ES_Get_Time  id=ES,                 |                                *\n               Date=pwa_es_date,      |                                *\n               Time=pwa_es_time       |\n* *-------------------------------------------------------------------*\n* callsub get_current_test            |\n* *-------------------------------------------------------------------*\n         eject                        |\n* *-------------------------------------------------------------------*\n* *  DT_Convert testing for dates.\n* *-------------------------------------------------------------------*\n* callsub conversion_test             |\n* *-------------------------------------------------------------------*\n* callsub general_input_test          |\n* *-------------------------------------------------------------------*\n  callsub add_test                    |\n* *-------------------------------------------------------------------*\n  callsub subtract_test               |\n* *-------------------------------------------------------------------*\n  callsub duration_test               |\n* *-------------------------------------------------------------------*\n  DT_Terminate ID=DT                  |\n  PL_Terminate ID=PL                  |\n* *-------------------------------------------------------------------*\n endblk                               |\n     eject                            |\n**--------------------------------------------------------------------*\n**\n** Get_Current_Test issues the DT_Get_Current function.\n**\n**--------------------------------------------------------------------*\n block name=get_current_test,type=subroutine\n  tput  get_current_header,l'get_current_header\n  tput  get_current_prompt,l'get_current_prompt\n  tget  pwa_answer,l'pwa_answer       |\n  oi    pwa_answer,c' '               |\n  leave block=*,(cli,pwa_answer,eq,c' ')\n  pl_print id=PL,string=\" DT_Get_Current testing:\"\n  errexit  (treg,r15,nz)              |\n  DT_Get_Current ID=DT,Date=(pwa_date,&dt_es_format)\n  errexit (treg,r15,nz)               |\n  pl_print_formatted  id=PL,source=(pwa_date,pwa_date+4),              *\n               control=\" ES_Format Date = X''{XL4}'', ES_Format Time = *\n               X''{XL4}''\"            |\n  errexit (treg,r15,nz)               |\n* *-------------------------------------------------------------------*\n  DT_Get_Current ID=DT,Date=(pwa_date,&dt_juliand),                    *\n               Time=(pwa_time,&dt_hhmmssth)\n  errexit (treg,r15,nz)               |\n  pl_print_formatted  id=PL,source=(pwa_date,pwa_time),                *\n               control=\" Juliand Date = C''{CL8}'', HHMMSSTH Time = C''*\n               {CL11}''\"              |\n  errexit (treg,r15,nz)               |\n* *-------------------------------------------------------------------*\n  DT_Get_Current ID=DT,Date=(pwa_date,&dt_gregorian)\n  errexit (treg,r15,nz)               |\n  pl_print_formatted  id=PL,source=(pwa_date),                         *\n               control=\" Gregorian Date = C''{CL10}''\"\n  errexit (treg,r15,nz)               |\n* *-------------------------------------------------------------------*\n  DT_Get_Current ID=DT,Time=(pwa_time,&dt_hhmmssth)\n  errexit (treg,r15,nz)               |\n  pl_print_formatted  id=PL,source=(pwa_time),                         *\n               control=\" HHMMSSTH Time = C''{CL11}''\"\n  errexit (treg,r15,nz)               |\n* *-------------------------------------------------------------------*\n  DT_Get_Current ID=DT,Time=(pwa_time,&dt_hours)\n  errexit (treg,r15,nz)               |\n  DT_Get_Current ID=DT,Time=(pwa_time2,&dt_phours)\n  errexit (treg,r15,nz)               |\n  DT_Get_Current ID=DT,Time=(pwa_time3,&dt_ihours)\n  errexit (treg,r15,nz)               |\n  pl_print_formatted  id=PL,source=(pwa_time,pwa_time2,pwa_time3),     *\n               control=\" DT_Hours = C''{CL2}'', DT_Phours = X''{XL2}'',*\n                DT_Ihours = X''{XL2}''.\"\n  errexit (treg,r15,nz)               |\n* *-------------------------------------------------------------------*\n  DT_Get_Current ID=DT,Time=(pwa_time,&dt_minutes)\n  errexit (treg,r15,nz)               |\n  DT_Get_Current ID=DT,Time=(pwa_time2,&dt_pminutes)\n  errexit (treg,r15,nz)               |\n  DT_Get_Current ID=DT,Time=(pwa_time3,&dt_iminutes)\n  errexit (treg,r15,nz)               |\n  pl_print_formatted  id=PL,source=(pwa_time,pwa_time2,pwa_time3),     *\n               control=\" DT_Minutes = C''{CL2}'', DT_Pminutes = X''{XL2*\n               }'', DT_Iminutes = X''{XL2}''.\"\n  errexit (treg,r15,nz)               |\n* *-------------------------------------------------------------------*\n  DT_Get_Current ID=DT,Time=(pwa_time,&dt_seconds)\n  errexit (treg,r15,nz)               |\n  DT_Get_Current ID=DT,Time=(pwa_time2,&dt_pseconds)\n  errexit (treg,r15,nz)               |\n  DT_Get_Current ID=DT,Time=(pwa_time3,&dt_iseconds)\n  errexit (treg,r15,nz)               |\n  pl_print_formatted  id=PL,source=(pwa_time,pwa_time2,pwa_time3),     *\n               control=\" DT_seconds = C''{CL2}'', DT_Pseconds = X''{XL2*\n               }'', DT_Iseconds = X''{XL2}''.\"\n  errexit (treg,r15,nz)               |\n* *-------------------------------------------------------------------*\n endblk                               |\n    eject                             |\n**--------------------------------------------------------------------*\n**\n** Conversion_Test issues the DT_Convert function.\n**\n**--------------------------------------------------------------------*\n block name=conversion_test,type=subroutine\n  tput  =c' ',1                       |\n  tput  conversion_header,l'conversion_header\n  loop  until                         |\n   fill  pwa_answer,c' '              |\n   fill  pwa_date,c' '                |\n   tput  conversion_prompt,l'conversion_prompt\n   tget  pwa_answer,l'pwa_answer      |\n   oc    pwa_answer,=cl32' '          |\n   leave loop=*,(cli,pwa_answer,eq,c' ')\n* *-------------------------------------------------------------------*\n   block name=individual_date_conversions\n    DT_Convert  ID=DT,Fromdate=(pwa_answer,&dt_gregorian),             *\n               Todate=(pwa_date,&dt_gregorian),                        *\n               Totime=(pwa_time,&dt_hhmmssth)\n    if    (treg,r15,nz)               |\n     callsub dt_error                 |\n     leave block=*                    |\n    endif                             |\n    pl_print_formatted id=PL,source=(pwa_date),                        *\n               control=\"   Gregorian -> Gregorian = C''{CL10}''\"\n    errexit (treg,r15,nz)             |\n    pl_print_formatted id=PL,source=(pwa_time),                        *\n               control=\"   Null time -> HHMMSSTH = C''{CL11}''\"\n    errexit (treg,r15,nz)             |\n* *-------------------------------------------------------------------*\n    fill  pwa_date2,c' '\n    DT_Convert  ID=DT,Fromtime=('12:31:15.20',&dt_hhmmssth),           *\n               Todate=(pwa_date2,&dt_text),                            *\n               Totime=(pwa_time,&dt_hhmmssth)\n    if    (treg,r15,nz)               |\n     callsub dt_error                 |\n     leave block=*                    |\n    endif                             |\n    pl_print_formatted id=PL,source=(pwa_date2),                       *\n               control=\"   Null date -> Text = C''{CL18 T}''\"\n    errexit (treg,r15,nz)             |\n* *-------------------------------------------------------------------*\n    DT_Convert  ID=DT,Fromdate=(pwa_date,&dt_gregorian),               *\n               Todate=(pwa_date,&dt_julian)\n    if    (treg,r15,nz)               |\n     callsub dt_error                 |\n     leave block=*                    |\n    endif                             |\n    pl_print_formatted id=PL,source=(pwa_date),                        *\n               control=\"   Gregorian -> Julian = C''{CL7}''\"\n    errexit (treg,r15,nz)             |\n* *-------------------------------------------------------------------*\n    DT_Convert  ID=DT,Fromdate=(pwa_date,&dt_julian),                  *\n               Todate=(pwa_date,&dt_juliand)\n    if    (treg,r15,nz)               |\n     callsub dt_error                 |\n     leave block=*                    |\n    endif                             |\n    pl_print_formatted id=PL,source=(pwa_date),                        *\n               control=\"   Julian -> Juliand = C''{CL8}''\"\n    errexit (treg,r15,nz)             |\n* *-------------------------------------------------------------------*\n    DT_Convert  ID=DT,Fromdate=(pwa_date,&dt_juliand),                 *\n               Todate=(pwa_date,&dt_normal)\n    if    (treg,r15,nz)               |\n     callsub dt_error                 |\n     leave block=*                    |\n    endif                             |\n    pl_print_formatted id=PL,source=(pwa_date),                        *\n               control=\"   Juliand -> Normal = C''{CL11}''\"\n    errexit (treg,r15,nz)             |\n* *-------------------------------------------------------------------*\n    DT_Convert  ID=DT,Fromdate=(pwa_date,&dt_normal),                  *\n               Todate=(pwa_date,&dt_text)\n    if    (treg,r15,nz)               |\n     callsub dt_error                 |\n     leave block=*                    |\n    endif                             |\n    pl_print_formatted id=PL,source=(pwa_date),                        *\n               control=\"   Normal -> Text = C''{CL18 T}''\"\n    errexit (treg,r15,nz)             |\n* *-------------------------------------------------------------------*\n    DT_Convert  ID=DT,Fromdate=(pwa_date,&dt_text),                    *\n               Todate=(pwa_date,&dt_number_of_days)\n    if    (treg,r15,nz)               |\n     callsub dt_error                 |\n     leave block=*                    |\n    endif                             |\n    pl_print_formatted id=PL,source=(pwa_date),                        *\n               control=\"   Text -> Number-Of-Days = I''{IL4}''\"\n    errexit (treg,r15,nz)             |\n* *-------------------------------------------------------------------*\n    DT_Convert  ID=DT,Fromdate=(pwa_date,&dt_number_of_days),          *\n               Todate=(pwa_date,&dt_textd)\n    if    (treg,r15,nz)               |\n     callsub dt_error                 |\n     leave block=*                    |\n    endif                             |\n    pl_print_formatted id=PL,source=(pwa_date),                        *\n               control=\"   Number-Of-Days -> Textd = C''{CL28}''\"\n    errexit (treg,r15,nz)             |\n* *-------------------------------------------------------------------*\n    DT_Convert  ID=DT,Fromdate=(pwa_date,&dt_textd),                   *\n               Todate=(pwa_date,&dt_sortdate)\n    if    (treg,r15,nz)               |\n     callsub dt_error                 |\n     leave block=*                    |\n    endif                             |\n    pl_print_formatted id=PL,source=(pwa_date),                        *\n               control=\"   Textd -> Sortdate = C''{CL10}''\"\n    errexit (treg,r15,nz)             |\n* *-------------------------------------------------------------------*\n    DT_Convert  ID=DT,Fromdate=(pwa_date,&dt_sortdate),                *\n               Totime=(pwa_date,&dt_todclock)\n    if    (treg,r15,nz)               |\n     callsub dt_error                 |\n     leave block=*                    |\n    endif                             |\n    pl_print_formatted id=PL,source=(pwa_date),                        *\n               control=\"   Sortdate -> TODclock = X''{XL8}''\"\n    errexit (treg,r15,nz)             |\n* *-------------------------------------------------------------------*\n    DT_Convert  ID=DT,Fromtime=(pwa_date,&dt_todclock),                *\n               Todate=(pwa_date,&dt_gregorian)\n    if    (treg,r15,nz)               |\n     callsub dt_error                 |\n     leave block=*                    |\n    endif                             |\n    pl_print_formatted id=PL,source=(pwa_date),                        *\n               control=\"   TODclock -> Gregorian = C''{CL10}''\"\n    errexit (treg,r15,nz)             |\n* *-------------------------------------------------------------------*\n    pl_print id=PL,string='0*** Short date formats: ***'\n    errexit (treg,r15,nz)             |\n* *-------------------------------------------------------------------*\n    DT_Convert ID=DT,Fromdate=(pwa_date,&dt_gregorian),                *\n               Todate=(pwa_date2,&dt_days)\n    if    (treg,r15,nz)               |\n     callsub dt_error                 |\n     leave block=*                    |\n    endif                             |\n    DT_Convert ID=DT,Fromdate=(pwa_date,&dt_gregorian),                *\n               Todate=(pwa_date3,&dt_pdays)\n    if    (treg,r15,nz)               |\n     callsub dt_error                 |\n     leave block=*                    |\n    endif                             |\n    DT_Convert ID=DT,Fromdate=(pwa_date,&dt_gregorian),                *\n               Todate=(pwa_date4,&dt_idays)\n    if    (treg,r15,nz)               |\n     callsub dt_error                 |\n     leave block=*                    |\n    endif                             |\n    pl_print_formatted id=PL,source=(pwa_date2,pwa_date3,pwa_date4),   *\n               control=\"   DT_Days = {CL2}, DT_Pdays = X\"\"{XL2}\"\", DT_I*\n               days = H\"\"{IL2}\"\".\"    |\n    errexit (treg,r15,nz)             |\n* *-------------------------------------------------------------------*\n    DT_Convert ID=DT,Fromdate=(pwa_date,&dt_gregorian),                *\n               Todate=(pwa_date2,&dt_month)\n    if    (treg,r15,nz)               |\n     callsub dt_error                 |\n     leave block=*                    |\n    endif                             |\n    DT_Convert ID=DT,Fromdate=(pwa_date,&dt_gregorian),                *\n               Todate=(pwa_date3,&dt_pmonth)\n    if    (treg,r15,nz)               |\n     callsub dt_error                 |\n     leave block=*                    |\n    endif                             |\n    DT_Convert ID=DT,Fromdate=(pwa_date,&dt_gregorian),                *\n               Todate=(pwa_date4,&dt_imonth)\n    if    (treg,r15,nz)               |\n     callsub dt_error                 |\n     leave block=*                    |\n    endif                             |\n    pl_print_formatted id=PL,source=(pwa_date2,pwa_date3,pwa_date4),   *\n               control=\"   DT_Month = {CL2}, DT_Pmonth = X\"\"{XL2}\"\", DT*\n               Imonth = H\"\"{IL2}\"\".\"  |\n    errexit (treg,r15,nz)             |\n* *-------------------------------------------------------------------*\n    DT_Convert ID=DT,Fromdate=(pwa_date,&dt_gregorian),                *\n               Todate=(pwa_date2,&dt_weekday)\n    if    (treg,r15,nz)               |\n     callsub dt_error                 |\n     leave block=*                    |\n    endif                             |\n    DT_Convert ID=DT,Fromdate=(pwa_date,&dt_gregorian),                *\n               Todate=(pwa_date3,&dt_weekday3)\n    if    (treg,r15,nz)               |\n     callsub dt_error                 |\n     leave block=*                    |\n    endif                             |\n    pl_print_formatted id=PL,source=(pwa_date2,pwa_date3),             *\n               control=\"   DT_Weekday = {CL9 T}, DT_Weekday3 = {CL3}.\"\n    errexit (treg,r15,nz)             |\n* *-------------------------------------------------------------------*\n    DT_Convert ID=DT,Fromdate=(pwa_date,&dt_gregorian),                *\n               Todate=(pwa_date2,&dt_monthname)\n    if    (treg,r15,nz)               |\n     callsub dt_error                 |\n     leave block=*                    |\n    endif                             |\n    DT_Convert ID=DT,Fromdate=(pwa_date,&dt_gregorian),                *\n               Todate=(pwa_date3,&dt_monthname3)\n    if    (treg,r15,nz)               |\n     callsub dt_error                 |\n     leave block=*                    |\n    endif                             |\n    pl_print_formatted id=PL,source=(pwa_date2,pwa_date3,pwa_date4),   *\n               control=\"   DT_Monthname = {CL9 T}, DT_Monthname3 = {CL3*\n               }.\"                    |\n    errexit (treg,r15,nz)             |\n* *-------------------------------------------------------------------*\n    DT_Convert ID=DT,Fromdate=(pwa_date,&dt_gregorian),                *\n               Todate=(pwa_date2,&dt_year)\n    if    (treg,r15,nz)               |\n     callsub dt_error                 |\n     leave block=*                    |\n    endif                             |\n    DT_Convert ID=DT,Fromdate=(pwa_date,&dt_gregorian),                *\n               Todate=(pwa_date3,&dt_year2)\n    if    (treg,r15,nz)               |\n     callsub dt_error                 |\n     leave block=*                    |\n    endif                             |\n    DT_Convert ID=DT,Fromdate=(pwa_date,&dt_gregorian),                *\n               Todate=(pwa_date4,&dt_pyear)\n    if    (treg,r15,nz)               |\n     callsub dt_error                 |\n     leave block=*                    |\n    endif                             |\n    DT_Convert ID=DT,Fromdate=(pwa_date,&dt_gregorian),                *\n               Todate=(pwa_date5,&dt_iyear)\n    if    (treg,r15,nz)               |\n     callsub dt_error                 |\n     leave block=*                    |\n    endif                             |\n    pl_print_formatted id=PL,         |                                *\n               source=(pwa_date2,pwa_date3,pwa_date4,pwa_date5),       *\n               control=\"   DT_Year = {CL4}, DT_Year2 = {CL2}, DT_Pyear *\n               = X\"\"{XL4}\"\", DT_Iyear = H\"\"{IL2}\"\".\"\n    errexit (treg,r15,nz)             |\n* *-------------------------------------------------------------------*\n   endblk                             |\n  endloop until,leave                 |\n endblk                               |\n eject                                |\n**--------------------------------------------------------------------*\n**\n** General_Input_Test exercises the DT_General_Input format.\n**\n**--------------------------------------------------------------------*\n block name=general_input_test,type=subroutine\n  tput  =c' ',1                       |\n  tput  general_header,l'general_header\n  loop  until                         |\n   fill  pwa_answer,c' '              |\n   fill  pwa_date,c' '                |\n   fill  pwa_time,c' '                |\n   tput  general_prompt,l'general_prompt\n   tget  pwa_answer,l'pwa_answer      |\n   leave loop=*,(cli,pwa_answer,eq,c' ')\n   tput  general_prompt2,l'general_prompt2\n   tget  pwa_time,l'pwa_time          |\n* *-------------------------------------------------------------------*\n   block name=individual_general_format\n    DT_Convert  ID=DT,Fromdate=(pwa_answer,&dt_general_input),         *\n               fromtime=(pwa_time,&dt_general_input),                  *\n               Totime=(pwa_time2,&dt_todclock)\n    if    (treg,r15,nz)               |\n     if    (%dt_invalid_date_format)  |\n      tput  general_invalid,l'general_invalid\n     else                             |\n      callsub dt_error                |\n     endif                            |\n     leave block=*                    |\n    endif                             |\n    PL_Print_Formatted id=PL,         |                                *\n               control=\" DT_Todclock format of date is X''{XL8}.''\",   *\n               source=(pwa_time2)     |\n   endblk                             |\n  endloop until,leave                 |\n  leave block=*  <<<<<<<<<\n  loop  until                         |\n   fill  pwa_answer,c' '              |\n   fill  pwa_date,c' '                |\n   tput  general_prompt2,l'general_prompt2\n   tget  pwa_answer,l'pwa_answer      |\n   leave loop=*,(cli,pwa_answer,eq,c' ')\n* *-------------------------------------------------------------------*\n   block name=individual_general_format2\n    DT_Convert  ID=DT,Fromtime=(pwa_answer,&dt_general_input),         *\n               Totime=(pwa_time,&dt_civilian)\n    if    (treg,r15,nz)               |\n     if    (%dt_invalid_time_format)  |\n      tput  general_invalid,l'general_invalid\n     else                             |\n      callsub dt_error                |\n     endif                            |\n     leave block=*                    |\n    endif                             |\n    PL_Print_Formatted id=PL,         |                                *\n               control=\" DT_Civilian format of time is {CL11}.\",       *\n               source=(pwa_time)      |\n   endblk                             |\n  endloop until,leave                 |\n endblk                               |\n   eject                              |\n**--------------------------------------------------------------------*\n**\n** Add_Test exercises the DT_Add function.\n**\n**--------------------------------------------------------------------*\n block name=add_test,type=subroutine  |\n  tput  =c' ',1                       |\n  tput  add_header,l'add_header       |\n  callsub add_single_test,            |                                *\n               (\"days\",4,&dt_days,&dt_pdays,&dt_idays)\n  callsub add_single_test,            |                                *\n               (\"hours\",5,&dt_hours,&dt_phours,&dt_ihours)\n  callsub add_single_test,            |                                *\n               (\"minutes\",7,&dt_minutes,&dt_pminutes,&dt_iminutes)\n  callsub add_single_test,            |                                *\n               (\"seconds\",7,&dt_seconds,&dt_pseconds,&dt_iseconds)\n  callsub add_delta_test\n endblk                               |\n* *-------------------------------------------------------------------*\n block name=add_single_test,type=subroutine\n  lm    r2,r6,0(r1)                   |\n  loop  until                         |\n   PL_Print_Formatted id=PL,          |                                *\n               control=\"   Enter number of {CL?} to add to current date*\n               , or null line for next test.\",                         *\n               source=(0(r2),2(r3))   |\n   errexit (treg,r15,nz)              |\n   fill  pwa_answer,c' '              |\n   tget  pwa_answer,l'pwa_answer      |\n   leave loop=*,(cli,pwa_answer,eq,c' ')\n   callsub copy_digits,(pwa_answer,pwa_interval)\n   fill  pwa_date,c' '\n   fill  pwa_time,c' '\n   DT_Get_Current id=DT,              |                                *\n               date=(pwa_date,&dt_normal),                             *\n               time=(pwa_time,&dt_hhmmssth)\n   if   (treg,r15,nz)                 |\n    callsub dt_error                  |\n    leave loop=*                      |\n   endif                              |\n   PL_Print id=PL,string=\"   Character format interval:\"\n   errexit (treg,r15,nz)              |\n   PL_Print_Formatted id=PL,source=(pwa_date,pwa_time),                *\n               control=\"     Current date and time are {CL16 T}, {CL16 *\n               T}.\"                   |\n   errexit (treg,r15,nz)              |\n   fill  pwa_date2,c' '               |\n   fill  pwa_time2,c' '               |\n   DT_Add      id=DT,                 |                                *\n               datein=(pwa_date,&dt_normal),                           *\n               timein=(pwa_time,&dt_hhmmssth),                         *\n               interval=(pwa_interval,(r4)),                           *\n               dateout=(pwa_date2,&dt_normal),                         *\n               timeout=(pwa_time2,&dt_hhmmssth)\n   if   (treg,r15,nz)                 |\n    callsub dt_error                  |\n   else                               |\n    PL_Print_Formatted id=PL,source=(pwa_date2,pwa_time2),             *\n               control=\"     Current date/time + interval = {CL16 T}, {*\n               CL16 T}.\"                  |\n    errexit (treg,r15,nz)             |\n   endif                              |\n* *-------------------------------------------------------------------*\n   PL_Print id=PL,string=\"   Packed-decimal format interval:\"\n   errexit (treg,r15,nz)              |\n   PL_Print_Formatted id=PL,source=(pwa_date,pwa_time),                *\n               control=\"     Current date and time are {CL16 T}, {CL16 *\n               T}.\"                   |\n   errexit (treg,r15,nz)              |\n   fill  pwa_date2,c' '               |\n   fill  pwa_time2,c' '               |\n   xc    pwa_d,pwa_d                  |\n   pack  pwa_d+5(3),pwa_interval(5)   |\n   DT_Add      id=DT,                 |                                *\n               datein=(pwa_date,&dt_normal),                           *\n               timein=(pwa_time,&dt_hhmmssth),                         *\n               interval=(pwa_d+4,(r5)),                                *\n               dateout=(pwa_date2,&dt_normal),                         *\n               timeout=(pwa_time2,&dt_hhmmssth)\n   if   (treg,r15,nz)                 |\n    callsub dt_error                  |\n   else                               |\n    PL_Print_Formatted id=PL,source=(pwa_date2,pwa_time2),             *\n               control=\"     Current date/time + interval = {CL16 T}, {*\n               CL16 T}.\"                  |\n    errexit (treg,r15,nz)             |\n   endif                              |\n* *-------------------------------------------------------------------*\n   PL_Print id=PL,string=\"   Integer format interval:\"\n   errexit (treg,r15,nz)              |\n   PL_Print_Formatted id=PL,source=(pwa_date,pwa_time),                *\n               control=\"     Current date and time are {CL16 T}, {CL16 *\n               T}.\"                   |\n   errexit (treg,r15,nz)              |\n   fill  pwa_date2,c' '               |\n   fill  pwa_time2,c' '               |\n   cvb   r1,pwa_d                     |\n   sth   r1,pwa_d                     |\n   DT_Add      id=DT,                 |                                *\n               datein=(pwa_date,&dt_normal),                           *\n               timein=(pwa_time,&dt_hhmmssth),                         *\n               interval=(pwa_d,(r6)), |                                *\n               dateout=(pwa_date2,&dt_normal),                         *\n               timeout=(pwa_time2,&dt_hhmmssth)\n   if   (treg,r15,nz)                 |\n    callsub dt_error                  |\n   else                               |\n    PL_Print_Formatted id=PL,source=(pwa_date2,pwa_time2),             *\n               control=\"     Current date/time + interval = {CL16 T}, {*\n               CL16 T}.\"                  |\n    errexit (treg,r15,nz)             |\n   endif                              |\n* *-------------------------------------------------------------------*\n  endloop until,leave                 |\n endblk                               |\n* *-------------------------------------------------------------------*\n   eject                              |\n block name=add_delta_test,type=subroutine\n  lm    r2,r6,0(r1)                   |\n  loop  until                         |\n   PL_Print    id=PL,                                                  *\n               string=\"   Enter delta value to add to current date, or *\n               null line for next test.\"\n   errexit (treg,r15,nz)              |\n   fill  pwa_answer,c' '              |\n   tget  pwa_answer,l'pwa_answer      |\n   leave loop=*,(cli,pwa_answer,eq,c' ')\n   fill  pwa_date,c' '\n   fill  pwa_time,c' '\n   DT_Get_Current id=DT,              |                                *\n               date=(pwa_date,&dt_normal),                             *\n               time=(pwa_time,&dt_hhmmssth)\n   if   (treg,r15,nz)                 |\n    callsub dt_error                  |\n    leave loop=*                      |\n   endif                              |\n   PL_Print id=PL,string=\"   Delta format interval:\"\n   errexit (treg,r15,nz)              |\n   PL_Print_Formatted id=PL,source=(pwa_date,pwa_time),                *\n               control=\"     Current date and time are {CL16 T}, {CL16 *\n               T}.\"                   |\n   errexit (treg,r15,nz)              |\n   fill  pwa_date2,c' '               |\n   fill  pwa_time2,c' '               |\n   DT_Add      id=DT,                 |                                *\n               datein=(pwa_date,&dt_normal),                           *\n               timein=(pwa_time,&dt_hhmmssth),                         *\n               interval=(pwa_answer,&dt_delta),                        *\n               dateout=(pwa_date2,&dt_normal),                         *\n               timeout=(pwa_time2,&dt_hhmmssth)\n   if   (treg,r15,nz)                 |\n    callsub dt_error                  |\n   else                               |\n    PL_Print_Formatted id=PL,source=(pwa_date2,pwa_time2),             *\n               control=\"     Current date/time + interval = {CL16 T}, {*\n               CL16 T}.\"                  |\n    errexit (treg,r15,nz)             |\n   endif                              |\n* *-------------------------------------------------------------------*\n  endloop until,leave                 |\n endblk                               |\n* *-------------------------------------------------------------------*\n   eject                              |\n**--------------------------------------------------------------------*\n**\n** Subtract_Test exercises the DT_Subtract function.\n**\n**--------------------------------------------------------------------*\n block name=Subtract_test,type=subroutine\n  tput  =c' ',1                       |\n  tput  Subtract_header,l'Subtract_header\n  callsub Subtract_single_test,       |                                *\n               (\"days\",4,&dt_days,&dt_pdays,&dt_idays)\n  callsub Subtract_single_test,       |                                *\n               (\"hours\",5,&dt_hours,&dt_phours,&dt_ihours)\n  callsub Subtract_single_test,       |                                *\n               (\"minutes\",7,&dt_minutes,&dt_pminutes,&dt_iminutes)\n  callsub Subtract_single_test,       |                                *\n               (\"seconds\",7,&dt_seconds,&dt_pseconds,&dt_iseconds)\n  callsub subtract_delta_test         |\n endblk                               |\n* *-------------------------------------------------------------------*\n block name=Subtract_single_test,type=subroutine\n  lm    r2,r6,0(r1)                   |\n  loop  until                         |\n   PL_Print_Formatted id=PL,          |                                *\n               control=\"   Enter number of {CL?} to subtract from curre*\n               nt date, or null line for next test.\",                  *\n               source=(0(r2),2(r3))   |\n   errexit (treg,r15,nz)              |\n   fill  pwa_answer,c' '              |\n   tget  pwa_answer,l'pwa_answer      |\n   leave loop=*,(cli,pwa_answer,eq,c' ')\n   callsub copy_digits,(pwa_answer,pwa_interval)\n   fill  pwa_date,c' '\n   fill  pwa_time,c' '\n   DT_Get_Current id=DT,              |                                *\n               date=(pwa_date,&dt_normal),                             *\n               time=(pwa_time,&dt_hhmmssth)\n   if   (treg,r15,nz)                 |\n    callsub dt_error                  |\n    leave loop=*                      |\n   endif                              |\n   PL_Print id=PL,string=\"   Character format interval:\"\n   errexit (treg,r15,nz)              |\n   PL_Print_Formatted id=PL,source=(pwa_date,pwa_time),                *\n               control=\"     Current date and time are {CL16 T}, {CL16 *\n               T}.\"                   |\n   errexit (treg,r15,nz)              |\n   fill  pwa_date2,c' '               |\n   fill  pwa_time2,c' '               |\n   DT_Subtract id=DT,                 |                                *\n               datein=(pwa_date,&dt_normal),                           *\n               timein=(pwa_time,&dt_hhmmssth),                         *\n               interval=(pwa_interval,(r4)),                           *\n               dateout=(pwa_date2,&dt_normal),                         *\n               timeout=(pwa_time2,&dt_hhmmssth)\n   if   (treg,r15,nz)                 |\n    callsub dt_error                  |\n   else                               |\n    PL_Print_Formatted id=PL,source=(pwa_date2,pwa_time2),             *\n               control=\"     Current date/time - interval = {CL16 T}, {*\n               CL16 T}.\"                  |\n    errexit (treg,r15,nz)             |\n   endif                              |\n* *-------------------------------------------------------------------*\n   PL_Print id=PL,string=\"   Packed-decimal format interval:\"\n   errexit (treg,r15,nz)              |\n   PL_Print_Formatted id=PL,source=(pwa_date,pwa_time),                *\n               control=\"     Current date and time are {CL16 T}, {CL16 *\n               T}.\"                   |\n   errexit (treg,r15,nz)              |\n   fill  pwa_date2,c' '               |\n   fill  pwa_time2,c' '               |\n   xc    pwa_d,pwa_d                  |\n   pack  pwa_d+5(3),pwa_interval(5)   |\n   DT_Subtract id=DT,                 |                                *\n               datein=(pwa_date,&dt_normal),                           *\n               timein=(pwa_time,&dt_hhmmssth),                         *\n               interval=(pwa_d+4,(r5)),                                *\n               dateout=(pwa_date2,&dt_normal),                         *\n               timeout=(pwa_time2,&dt_hhmmssth)\n   if   (treg,r15,nz)                 |\n    callsub dt_error                  |\n   else                               |\n    PL_Print_Formatted id=PL,source=(pwa_date2,pwa_time2),             *\n               control=\"     Current date/time - interval = {CL16 T}, {*\n               CL16 T}.\"                  |\n    errexit (treg,r15,nz)             |\n   endif                              |\n* *-------------------------------------------------------------------*\n   PL_Print id=PL,string=\"   Integer format interval:\"\n   errexit (treg,r15,nz)              |\n   PL_Print_Formatted id=PL,source=(pwa_date,pwa_time),                *\n               control=\"     Current date and time are {CL16 T}, {CL16 *\n               T}.\"                   |\n   errexit (treg,r15,nz)              |\n   fill  pwa_date2,c' '               |\n   fill  pwa_time2,c' '               |\n   cvb   r1,pwa_d                     |\n   sth   r1,pwa_d                     |\n   DT_Subtract id=DT,                 |                                *\n               datein=(pwa_date,&dt_normal),                           *\n               timein=(pwa_time,&dt_hhmmssth),                         *\n               interval=(pwa_d,(r6)), |                                *\n               dateout=(pwa_date2,&dt_normal),                         *\n               timeout=(pwa_time2,&dt_hhmmssth)\n   if   (treg,r15,nz)                 |\n    callsub dt_error                  |\n   else                               |\n    PL_Print_Formatted id=PL,source=(pwa_date2,pwa_time2),             *\n               control=\"     Current date/time - interval = {CL16 T}, {*\n               CL16 T}.\"                  |\n    errexit (treg,r15,nz)             |\n   endif                              |\n* *-------------------------------------------------------------------*\n  endloop until,leave                 |\n endblk                               |\n block name=subtract_delta_test,type=subroutine\n  loop  until                         |\n   PL_Print    id=PL,                                                  *\n               string=\"   Enter delta value to subtract from current da*\n               te, or null line for next test.\"\n   errexit (treg,r15,nz)              |\n   fill  pwa_answer,c' '              |\n   tget  pwa_answer,l'pwa_answer      |\n   leave loop=*,(cli,pwa_answer,eq,c' ')\n   fill  pwa_date,c' '\n   fill  pwa_time,c' '\n   DT_Get_Current id=DT,              |                                *\n               date=(pwa_date,&dt_normal),                             *\n               time=(pwa_time,&dt_hhmmssth)\n   if   (treg,r15,nz)                 |\n    callsub dt_error                  |\n    leave loop=*                      |\n   endif                              |\n   PL_Print id=PL,string=\"   Delta format interval:\"\n   errexit (treg,r15,nz)              |\n   PL_Print_Formatted id=PL,source=(pwa_date,pwa_time),                *\n               control=\"     Current date and time are {CL16 T}, {CL16 *\n               T}.\"                   |\n   errexit (treg,r15,nz)              |\n   fill  pwa_date2,c' '               |\n   fill  pwa_time2,c' '               |\n   DT_subtract id=DT,                 |                                *\n               datein=(pwa_date,&dt_normal),                           *\n               timein=(pwa_time,&dt_hhmmssth),                         *\n               interval=(pwa_answer,&dt_delta),                        *\n               dateout=(pwa_date2,&dt_normal),                         *\n               timeout=(pwa_time2,&dt_hhmmssth)\n   if   (treg,r15,nz)                 |\n    callsub dt_error                  |\n   else                               |\n    PL_Print_Formatted id=PL,source=(pwa_date2,pwa_time2),             *\n               control=\"     Current date/time - interval = {CL16 T}, {*\n               CL16 T}.\"                  |\n    errexit (treg,r15,nz)             |\n   endif                              |\n* *-------------------------------------------------------------------*\n  endloop until,leave                 |\n endblk                               |\n* *-------------------------------------------------------------------*\n   eject                              |\n* *-------------------------------------------------------------------*\n space 1                              |\n block name=copy_digits,type=subroutine Parms = (from,to)\n  lm    r2,r3,0(r1)                   | Get parms\n  lr    r1,r2                         | Make a copy(from) to tear up\n  lr    r4,r2                         |  and one to preserve\n  fill  0(r3),c'0',length=5           | Init. \"to\" field to c'0's\n  loop  while,(cli,0(r2),ne,c' ')     |\n   la    r2,1(r2)                     |\n  endloop while                       |\n  sr    r2,r1                         | R2 = length of input\n  la    r14,5                         |\n  sr    r14,r2                        |\n  la    r15,0(r3,r14)                 |\n  bctr  r2,0                          |\n  exi   r2,(mvc,0(0,r15),0(r4))       |\n endblk                               |\n   eject                              |\n block name=duration_test,type=subroutine\n  PL_Print  id=PL,string=\" *** Duration test ***\"\n  errexit (treg,r15,nz)               |\n  loop  until                         |\n   PL_Print  id=PL,string=\" Enter general-format date, or null line to *\n               terminate test.\"       |\n   errexit (treg,r15,nz)              |\n   fill  pwa_date2,c' '               |\n   tget  pwa_date2,l'pwa_date2        |\n   leave loop=*,(cli,pwa_date2,eq,c' ')\n   PL_Print  id=PL,string=\" Enter general-format time, or null line.\"\n   errexit (treg,r15,nz)              |\n   fill  pwa_time2,c' '               |\n   tget  pwa_time2,l'pwa_time2        |\n   if    (cli,pwa_time2,eq,c' ')      |\n    mvc   pwa_time2(11),=c'00:00:00.00'\n   endif                              |\n   fill  pwa_date,c' '                |\n   fill  pwa_time,c' '                |\n   DT_Get_Current id=DT,              |                                *\n               date=(pwa_date,&dt_normal),                             *\n               time=(pwa_time,&dt_hhmmssth)\n   if   (treg,r15,nz)                 |\n    callsub dt_error                  |\n    leave loop=*                      |\n   endif                              |\n   PL_Print_Formatted id=PL,source=(pwa_date,pwa_time),                *\n               control=\"     Current date and time are {CL16 T}, {CL16 *\n               T}.\"                   |\n   errexit (treg,r15,nz)              |\n   DT_Duration id=DT,                 |                                *\n               date1=(pwa_date,&dt_general_input),                     *\n               time1=(pwa_time,&dt_general_input),                     *\n               date2=(pwa_date2,&dt_general_input),                    *\n               time2=(pwa_time2,&dt_general_input),                    *\n               duration=(pwa_interval,&dt_days)\n   if   (treg,r15,nz)                 |\n    callsub dt_error                  |\n   else                               |\n    PL_Print_Formatted id=PL,source=(pwa_interval),                    *\n               control=\" Difference is {CL5} days.\"\n    errexit (treg,r15,nz)             |\n   endif                              |\n   DT_Duration id=DT,                 |                                *\n               date1=(pwa_date,&dt_general_input),                     *\n               time1=(pwa_time,&dt_general_input),                     *\n               date2=(pwa_date2,&dt_general_input),                    *\n               time2=(pwa_time2,&dt_general_input),                    *\n               duration=(pwa_interval,&dt_hours)\n   if   (treg,r15,nz)                 |\n    callsub dt_error                  |\n   else                               |\n    PL_Print_Formatted id=PL,source=(pwa_interval),                    *\n               control=\" Difference is {CL5} hours.\"\n    errexit (treg,r15,nz)             |\n   endif                              |\n   DT_Duration id=DT,                 |                                *\n               date1=(pwa_date,&dt_general_input),                     *\n               time1=(pwa_time,&dt_general_input),                     *\n               date2=(pwa_date2,&dt_general_input),                    *\n               time2=(pwa_time2,&dt_general_input),                    *\n               duration=(pwa_interval,&dt_minutes)\n   if   (treg,r15,nz)                 |\n    callsub dt_error                  |\n   else                               |\n    PL_Print_Formatted id=PL,source=(pwa_interval),                    *\n               control=\" Difference is {CL5} minutes.\"\n    errexit (treg,r15,nz)             |\n   endif                              |\n   DT_Duration id=DT,                 |                                *\n               date1=(pwa_date,&dt_general_input),                     *\n               time1=(pwa_time,&dt_general_input),                     *\n               date2=(pwa_date2,&dt_general_input),                    *\n               time2=(pwa_time2,&dt_general_input),                    *\n               duration=(pwa_interval,&dt_delta)\n   if   (treg,r15,nz)                 |\n    callsub dt_error                  |\n   else                               |\n    PL_Print_Formatted id=PL,source=(pwa_interval),                    *\n               control=\" Difference is delta-format {CL20 T}.\"\n    errexit (treg,r15,nz)             |\n   endif                              |\n  endloop until,leave                 |\n endblk                               |\n block type=errexit                   |\n* ex    0,*\n  es_display_debug_info_and_abend id=es\n endblk                               |\n block name=dt_error,type=subroutine  |\n* ex    0,*\n  es_display_debug_info id=es         |\n endblk                               |\n     psd   ,                          |\npsd_sysprint   dc  c'sysprint'        |\nget_current_header dc c\"*** DT_Get_Current Testing ***\"\nget_current_prompt dc c\"Enter any character for DT_Get_Current test, or*\n                null line for next test.\"\nconversion_header dc c\"*** DT_Convert Testing ***\"\nconversion_prompt dc c\"Enter Gregorian date to convert, or a null line *\n               for next test.\"        |\ngeneral_header    dc c\"*** DT_General_Input Testing ***\"\ngeneral_prompt    dc c\"Enter any format date value, or a null line for *\n               time format test.\"     |\ngeneral_prompt2   dc c\"Enter any format time value, or a null line for *\n               next test.\"            |\ngeneral_invalid dc  c\"*** Format could not be determined. ***\"\nadd_header   dc c\"*** DT_Add function testing ***\"\nsubtract_header dc c\"*** DT_Subtract function testing ***\"\n     pwa   ,                          |\npwa_d             ds   d              |\npwa_es_date       ds   f              |\npwa_es_time       ds   f              |\npwa_esv_address   ds   f              |\npwa_es_epa        ds   f              |\npwa_es_token      ds   f              |\npwa_format        ds   f              |\npwa_answer        ds   cl32           |\npwa_date          ds   cl32           |\npwa_date2         ds   cl16           |\npwa_date3         ds   cl16           |\npwa_date4         ds   cl16           |\npwa_date5         ds   cl16           |\npwa_time          ds   cl16           |\npwa_time2         ds   cl16           |\npwa_time3         ds   cl16           |\npwa_time4         ds   cl16           |\npwa_time5         ds   cl16           |\npwa_text_format   ds   cl16           |\npwa_interval      ds   cl20           |\n     endpwa ,                         |\n     end   ,                          |\n//C.SYSLIB DD\n//         DD\n//         DD DSN=SYSTEMS.SRV.SOURCE,DISP=SHR\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SRVDTXR2": {"ttr": 18950, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x02\\x00\\x00W\\x01\\x11)\\x9f\\x01\\x11)\\x9f\\t'\\x00\\x9e\\x00\\x9e\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@\"", "ispf": {"version": "02.00", "flags": 0, "createdate": "2011-10-26T00:00:00", "modifydate": "2011-10-26T09:27:57", "lines": 158, "newlines": 158, "modlines": 0, "user": "CLEMSON"}, "text": "*---------------------------------------------------------------------*\n*  Copyright 2011 by Clemson University Research Foundation           *\n*                                                                     *\n*  Licensed under the Apache License, Version 2.0 (the \"License\");    *\n*  you may not use this file except in compliance with the License.   *\n*  You may obtain a copy of the License in this library as member     *\n*  $LICENSE, or from                                                  *\n*                                                                     *\n*      http://www.apache.org/licenses/LICENSE-2.0                     *\n*                                                                     *\n*  Unless required by applicable law or agreed to in writing,         *\n*  software distributed under the License is distributed on an \"AS    *\n*  IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either    *\n*  express or implied.  See the License for the specific language     *\n*  governing permissions and limitations under the License.           *\n*---------------------------------------------------------------------*\n//SRVDTXRZ JOB TIME=(,8)\n/*JOBPARM LINES=25\n//  EXEC  ASMPCL,COPT=',RENT',LOPT=',RENT,REUS,REFR',\n//    PDS='SYSTEMS.SRV.LOAD',NAME=SRVDTXR2,MAC=SYSTEMS\n//P.SYSIN  DD  *\n     SMLIST CONVERT=YES               |\nSRVDTXRZ     TITLE 'Exerciser For Message Service Processor'\n*---------------------------------------------------------------------*\n*\n*  Copyright (C) 1989 Clemson University\n*\n*  Program     SRVDTXRZ\n*\n*  Abstract    This is an exerciser routine for functions of the Date/\n*              Time Service Processor (SRVDT).  Feel free to add tests\n*              for SRVDT as development progesses.\n*\n*  Inputs:\n*      Parameters  None\n*      Files       None\n*      Other       Terminal (uses TGET for input)\n*\n*  Outputs:\n*      Returncodes None\n*      Messages    Various\n*      Files       SYSPRINT (used by Printline service processor)\n*      Other       Terminal (uses TPUT too)\n*\n*  PROGRAM     Reentrant, problem key and state, standard linkage,\n*  ATTRIBUTES  non-authorized, AMODE(31), RMODE(24)\n*\n*  Special\n*  Notes       None\n*\n*  Change\n*  History     12/01/89 JCB - New\n*              __/__/__ ___\n*              __/__/__ ___\n*\n*  Method of   SRVDTXRZ is a series of tests, each consisting of:\n*  Operation     . Prompt for the test ('enter any char for test, or\n*                  null line for next test')\n*                . Test, usually coded as loop within a subroutine\n*              Note that SRVDT errors are expected, and shouldn't cause\n*              the exerciser to terminate. A 'Callsub DT_Error' will\n*              print the debug information without terminating.\n*\n*---------------------------------------------------------------------*\n         EJECT                        |\n     copy  srvdtmac                   |\n     print off                        |\n     copy  srvesmac                   |\n     copy  srvplmac                   |\n     print on,gen                     |\n     eject                            |\n block name=SRVDTXRZ,type=program,    |                                *\n               options=(*pwa,xa,mode,long,novl),                       *\n               amode=31,              |                                *\n               subopts=(*swa,loadbase),                                *\n               basereg=(r12,r10),     |                                *\n               rmode=24               |\n     eject                            |\n  es_id id=es,esva=pwa_esv_address,   |                                +\n               spepa=pwa_es_epa,      |                                +\n               sptoken=pwa_es_token   |\n      space 1                         |\n  pl_id id=pl,esva=pwa_esv_address,   |                                *\n               esid=es,               |                                *\n               spepname=&PRINT_LINE,  |                                *\n               sizelength=2           |\n      space 1                         |\n  dt_id id=DT,spepname=&DateTime_Services\n     eject                            |\n  es_MVS_load id=ES                   |\n  ES_Start id=ES                      |\n  ES_Load_Module id=ES,spid=DT        |\n  if    (treg,r15,nz)                 |\n   ex    0,*                          |\n  endif                               |\n  ES_Load_Module id=ES,spid=PL        |\n  if    (treg,r15,nz)                 |\n   ex    0,*                          |\n  endif                               |\n  PL_Start     ID=PL,                 |                                *\n               DDname='SYSPRINT',     |                                *\n               PageSize=12,           |                                *\n               MaxLnSz=121            |\n  errexit (treg,r15,nz)               |\n  DT_Start     ID=DT                  | /* options=european */\n  errexit (treg,r15,nz)               |\n        eject                         |\n* *-------------------------------------------------------------------*\n* *  DT_Get_Current Testing\n* *-------------------------------------------------------------------*\n  mvc   pwa_tod,=xl8'ad3d33bfb9b09121'\n  dt_convert   id=DT,                 |                                *\n               fromtime=(pwa_tod,&dt_todclock),                        *\n               todate=(pwa_date,&dt_normal),                           *\n               totime=(pwa_time,&dt_civilian)\n  errexit (treg,r15,nz)\n  pl_print_formatted id=PL,                                            *\n               control=' TOD value is {XL8}, date is {CL11}, time is {C*\n               L11}',                                                  *\n               source=(pwa_tod,pwa_date,pwa_time)\n* errexit (treg,r15,nz),and,(ch,r15,ne,=h'&pl_print_line_truncated')\n* *-------------------------------------------------------------------*\n* *-------------------------------------------------------------------*\n  DT_Terminate ID=DT                  |\n  PL_Terminate ID=PL                  |\n* *-------------------------------------------------------------------*\n endblk                               |\n block type=errexit                   |\n* ex    0,*\n  es_display_debug_info_and_abend id=es\n endblk                               |\n     eject                            |\n     pwa   ,                          |\npwa_tod           ds   d              |\npwa_es_date       ds   f              |\npwa_es_time       ds   f              |\npwa_esv_address   ds   f              |\npwa_es_epa        ds   f              |\npwa_es_token      ds   f              |\npwa_format        ds   f              |\npwa_answer        ds   cl32           |\npwa_date          ds   cl32           |\npwa_date2         ds   cl16           |\npwa_date3         ds   cl16           |\npwa_date4         ds   cl16           |\npwa_date5         ds   cl16           |\npwa_time          ds   cl16           |\npwa_time2         ds   cl16           |\npwa_time3         ds   cl16           |\npwa_time4         ds   cl16           |\npwa_time5         ds   cl16           |\npwa_text_format   ds   cl16           |\npwa_interval      ds   cl20           |\n     endpwa ,                         |\n     end   ,                          |\n//C.SYSLIB DD\n//         DD\n//         DD DSN=SYSTEMS.SRV.SOURCE,DISP=SHR\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SRVDTXR3": {"ttr": 18954, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x02\\x00\\x00W\\x01\\x11)\\x9f\\x01\\x11)\\x9f\\t'\\x01M\\x01M\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@\"", "ispf": {"version": "02.00", "flags": 0, "createdate": "2011-10-26T00:00:00", "modifydate": "2011-10-26T09:27:57", "lines": 333, "newlines": 333, "modlines": 0, "user": "CLEMSON"}, "text": "*---------------------------------------------------------------------*\n*  Copyright 2011 by Clemson University Research Foundation           *\n*                                                                     *\n*  Licensed under the Apache License, Version 2.0 (the \"License\");    *\n*  you may not use this file except in compliance with the License.   *\n*  You may obtain a copy of the License in this library as member     *\n*  $LICENSE, or from                                                  *\n*                                                                     *\n*      http://www.apache.org/licenses/LICENSE-2.0                     *\n*                                                                     *\n*  Unless required by applicable law or agreed to in writing,         *\n*  software distributed under the License is distributed on an \"AS    *\n*  IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either    *\n*  express or implied.  See the License for the specific language     *\n*  governing permissions and limitations under the License.           *\n*---------------------------------------------------------------------*\n//SRVDTXR3 JOB TIME=(,8)\n/*JOBPARM Q=H\n//  EXEC  ASMPCL,COPT=',RENT',LOPT=',RENT,REUS,REFR',\n//    PDS='SYSTEMS.SRV.LOAD',NAME=SRVDTXR3,MAC=SYSTEMS\n//P.SYSIN  DD  *\n     SMLIST CONVERT=YES               |\nSRVDTXR3     TITLE 'Exerciser For Message Service Processor'\n*---------------------------------------------------------------------*\n*\n*  Copyright (C) 1989 Clemson University\n*\n*  Program     SRVDTXR3\n*\n*  Abstract    This is an exerciser routine for functions of the Date/\n*              Time Service Processor (SRVDT).  Feel free to add tests\n*              for SRVDT as development progesses.\n*\n*  Inputs:\n*      Parameters  None\n*      Files       None\n*      Other       Terminal (uses TGET for input)\n*\n*  Outputs:\n*      Returncodes None\n*      Messages    Various\n*      Files       SYSPRINT (used by Printline service processor)\n*      Other       Terminal (uses TPUT too)\n*\n*  PROGRAM     Reentrant, problem key and state, standard linkage,\n*  ATTRIBUTES  non-authorized, AMODE(31), RMODE(24)\n*\n*  Special\n*  Notes       None\n*\n*  Change\n*  History     12/01/89 JCB - New\n*              __/__/__ ___\n*              __/__/__ ___\n*\n*  Method of   SRVDTXRZ is a series of tests, each consisting of:\n*  Operation     . Prompt for the test ('enter any char for test, or\n*                  null line for next test')\n*                . Test, usually coded as loop within a subroutine\n*              Note that SRVDT errors are expected, and shouldn't cause\n*              the exerciser to terminate. A 'Callsub DT_Error' will\n*              print the debug information without terminating.\n*\n*---------------------------------------------------------------------*\n         EJECT                        |\n     copy  srvdtmac                   |\n     print off                        |\n     copy  srvesmac                   |\n     copy  srvplmac                   |\n     print on,gen                     |\n     eject                            |\n block name=SRVDTXR3,type=program,    |                                *\n               options=(*pwa,xa,mode,long,novl),                       *\n               amode=31,              |                                *\n               subopts=(*swa,loadbase),                                *\n               basereg=(r12,r10),     |                                *\n               rmode=24               |\n     eject                            |\n  es_id id=es,esva=pwa_esv_address,   |                                +\n               spepa=pwa_es_epa,      |                                +\n               sptoken=pwa_es_token   |\n      space 1                         |\n  pl_id id=pl,esva=pwa_esv_address,   |                                *\n               esid=es,               |                                *\n               spepname=&PRINT_LINE,  |                                *\n               sizelength=4           |\n      space 1                         |\n  dt_id id=DT,spepname=&DateTime_Services\n     eject                            |\n  es_MVS_load id=ES                   |\n  ES_Start id=ES                      |\n  ES_Load_Module id=ES,spid=DT        |\n  if    (treg,r15,nz)                 |\n   ex    0,*                          |\n  endif                               |\n  ES_Load_Module id=ES,spid=PL        |\n  if    (treg,r15,nz)                 |\n   ex    0,*                          |\n  endif                               |\n  PL_Start     ID=PL,                 |                                *\n               DDname='SYSPRINT',     |                                *\n               PageSize=12,           |                                *\n               MaxLnSz=121            |\n  errexit (treg,r15,nz)               |\n  DT_Start     ID=DT                  | /* options=european */\n  errexit (treg,r15,nz)               |\n        eject                         |\n* *-------------------------------------------------------------------*\n* *\n* *-------------------------------------------------------------------*\n* ********************************************************************\n* Feed 1999-12-31 00:00:00 in, then try to get it back out.\n* ********************************************************************\n  dt_convert   id=DT,                 |                                *\n               fromdate=('1999-12-31',&dt_sortdate),                   *\n               fromtime=('00:00:00',&dt_hhmmss),                       *\n               totime=(pwa_posix_timedate,&dt_todclock)\n  errexit (treg,r15,nz)\n  pl_print_formatted id=PL,                                            *\n               control=' 1999-12-31 00:00:00 = {XL8} TodClock.',       +\n               source=(pwa_posix_timedate)\n*\n*\n*\n  dt_convert   id=DT,                 |                                *\n               fromtime=(pwa_posix_timedate,&dt_todclock),             +\n               totime=(pwa_time,&dt_hhmmssth),                         +\n               todate=(pwa_date,&dt_sortdate)\n  errexit (treg,r15,nz)\n  pl_print_formatted id=PL,                                            *\n               control=' {XL8} TodClock is {CL10} {CL11}.',            +\n               source=(pwa_posix_timedate,pwa_date,pwa_time)\n* ********************************************************************\n* Feed 1999-12-31 00:00:00 in, then try to get it back out.\n* ********************************************************************\n  dt_convert   id=DT,                 |                                *\n               fromdate=('1999-12-31',&dt_sortdate),                   *\n               fromtime=('00:00:00',&dt_hhmmss),                       *\n               totime=(pwa_posix_timedate,&dt_todclock)\n  errexit (treg,r15,nz)\n  pl_print_formatted id=PL,                                            *\n               control=' 1999-12-31 00:00:00 = {XL8} TodClock.',       +\n               source=(pwa_posix_timedate)\n* ********************************************************************\n* Move zeros to second fullword of todclock before converting back\n* ********************************************************************\n  mvc pwa_posix_timedate+4,=f'0'\n*\n  dt_convert   id=DT,                 |                                *\n               fromtime=(pwa_posix_timedate,&dt_todclock),             +\n               totime=(pwa_time,&dt_hhmmssth),                         +\n               todate=(pwa_date,&dt_sortdate)\n  errexit (treg,r15,nz)\n  pl_print_formatted id=PL,                                            *\n               control=' {XL8} TodClock is {CL10} {CL11}.',            +\n               source=(pwa_posix_timedate,pwa_date,pwa_time)\n* ********************************************************************\n* Feed 2000-01-01 00:00:00 in, then try to get it back out.\n* ********************************************************************\n  dt_convert   id=DT,                 |                                *\n               fromdate=('2000-01-01',&dt_sortdate),                   *\n               fromtime=('00:00:00',&dt_hhmmss),                       *\n               totime=(pwa_posix_timedate,&dt_todclock)\n  errexit (treg,r15,nz)\n  pl_print_formatted id=PL,                                            *\n               control=' 2000-01-01 00:00:00 = {XL8} TodClock.',       +\n               source=(pwa_posix_timedate)\n*\n*\n*\n  dt_convert   id=DT,                 |                                *\n               fromtime=(pwa_posix_timedate,&dt_todclock),             +\n               totime=(pwa_time,&dt_hhmmssth),                         +\n               todate=(pwa_date,&dt_sortdate)\n  errexit (treg,r15,nz)\n  pl_print_formatted id=PL,                                            *\n               control=' {XL8} TodClock is {CL10} {CL11}.',            +\n               source=(pwa_posix_timedate,pwa_date,pwa_time)\n*\n* Feed 2000-02-29 00:00:00 in, then try to get it back out.\n*\n  dt_convert   id=DT,                 |                                *\n               fromdate=('2000-02-29',&dt_sortdate),                   *\n               fromtime=('00:00:00',&dt_hhmmss),                       *\n               totime=(pwa_posix_timedate,&dt_todclock)\n  errexit (treg,r15,nz)\n  pl_print_formatted id=PL,                                            *\n               control=' 2000-02-29 00:00:00 = {XL8} TodClock.',       +\n               source=(pwa_posix_timedate)\n*\n*\n*\n  dt_convert   id=DT,                 |                                *\n               fromtime=(pwa_posix_timedate,&dt_todclock),             +\n               totime=(pwa_time,&dt_hhmmssth),                         +\n               todate=(pwa_date,&dt_sortdate)\n  errexit (treg,r15,nz)\n  pl_print_formatted id=PL,                                            *\n               control=' {XL8} TodClock is {CL10} {CL11}.',            +\n               source=(pwa_posix_timedate,pwa_date,pwa_time)\n*\n* Feed 1994-08-09 00:00:00 in, then try to get it back out.\n*\n  dt_convert   id=DT,                 |                                *\n               fromdate=('1994-08-09',&dt_sortdate),                   *\n               fromtime=('00:00:00',&dt_hhmmss),                       *\n               totime=(pwa_posix_timedate,&dt_todclock)\n  errexit (treg,r15,nz)\n  pl_print_formatted id=PL,                                            *\n               control=' 1994-08-09 00:00:00 = {XL8} TodClock.',       +\n               source=(pwa_posix_timedate)\n*\n*\n*\n  dt_convert   id=DT,                 |                                *\n               fromtime=(pwa_posix_timedate,&dt_todclock),             +\n               totime=(pwa_time,&dt_hhmmssth),                         +\n               todate=(pwa_date,&dt_sortdate)\n  errexit (treg,r15,nz)\n  pl_print_formatted id=PL,                                            *\n               control=' {XL8} TodClock is {CL10} {CL11}.',            +\n               source=(pwa_posix_timedate,pwa_date,pwa_time)\n*\n* Feed 2000-12-31 00:00:00 in, then try to get it back out.\n*\n  dt_convert   id=DT,                 |                                *\n               fromdate=('2000-12-31',&dt_sortdate),                   *\n               fromtime=('00:00:00',&dt_hhmmss),                       *\n               totime=(pwa_posix_timedate,&dt_todclock)\n  errexit (treg,r15,nz)\n  pl_print_formatted id=PL,                                            *\n               control=' 2000-12-31 00:00:00 = {XL8} TodClock.',       +\n               source=(pwa_posix_timedate)\n*\n*\n*\n  dt_convert   id=DT,                 |                                *\n               fromtime=(pwa_posix_timedate,&dt_todclock),             +\n               totime=(pwa_time,&dt_hhmmssth),                         +\n               todate=(pwa_date,&dt_sortdate)\n  errexit (treg,r15,nz)\n  pl_print_formatted id=PL,                                            *\n               control=' {XL8} TodClock is {CL10} {CL11}.',            +\n               source=(pwa_posix_timedate,pwa_date,pwa_time)\n*\n* Feed 2000-03-01 00:00:00 in, then try to get it back out.\n*\n  dt_convert   id=DT,                 |                                *\n               fromdate=('2000-03-01',&dt_sortdate),                   *\n               fromtime=('00:00:00',&dt_hhmmss),                       *\n               totime=(pwa_posix_timedate,&dt_todclock)\n  errexit (treg,r15,nz)\n  pl_print_formatted id=PL,                                            *\n               control=' 2000-03-01 00:00:00 = {XL8} TodClock.',       +\n               source=(pwa_posix_timedate)\n*\n*\n*\n  dt_convert   id=DT,                 |                                *\n               fromtime=(pwa_posix_timedate,&dt_todclock),             +\n               totime=(pwa_time,&dt_hhmmssth),                         +\n               todate=(pwa_date,&dt_sortdate)\n  errexit (treg,r15,nz)\n  pl_print_formatted id=PL,                                            *\n               control=' {XL8} TodClock is {CL10} {CL11}.',            +\n               source=(pwa_posix_timedate,pwa_date,pwa_time)\n*\n* Feed 2000-12-31 00:00:00 in, then try to get it back out.\n*\n  dt_convert   id=DT,                 |                                *\n               fromdate=('2000-12-31',&dt_sortdate),                   *\n               fromtime=('00:00:00',&dt_hhmmss),                       *\n               totime=(pwa_posix_timedate,&dt_todclock)\n  errexit (treg,r15,nz)\n  pl_print_formatted id=PL,                                            *\n               control=' 2000-12-31 00:00:00 = {XL8} TodClock.',       +\n               source=(pwa_posix_timedate)\n*\n*\n*\n  dt_convert   id=DT,                 |                                *\n               fromtime=(pwa_posix_timedate,&dt_todclock),             +\n               totime=(pwa_time,&dt_hhmmssth),                         +\n               todate=(pwa_date,&dt_sortdate)\n  errexit (treg,r15,nz)\n  pl_print_formatted id=PL,                                            *\n               control=' {XL8} TodClock is {CL10} {CL11}.',            +\n               source=(pwa_posix_timedate,pwa_date,pwa_time)\n* *-------------------------------------------------------------------*\n  DT_Terminate ID=DT                  |\n  PL_Terminate ID=PL                  |\n* *-------------------------------------------------------------------*\n endblk                               |\n block type=errexit                   |\n* ex    0,*\n  es_display_debug_info_and_abend id=es\n endblk                               |\n psd\npsd_tod_lower_limit dc xl8'00d4ff0e7fb74000'  Jan. 1, 1900 @00:00:01.00\npsd_tod_upper_limit dc xl8'00e4ff0e7fb73e10'  Sep 17, 2042 @23:53:47.37\n endpsd\n     eject                            |\n     pwa   ,                          |\npwa_posix_timedate ds   f\npwa_tod           ds   d              |\npwa_es_date       ds   f              |\npwa_es_time       ds   f              |\npwa_esv_address   ds   f              |\npwa_es_epa        ds   f              |\npwa_es_token      ds   f              |\npwa_format        ds   f              |\npwa_answer        ds   cl32           |\npwa_date          ds   cl32           |\npwa_date2         ds   cl16           |\npwa_date3         ds   cl16           |\npwa_date4         ds   cl16           |\npwa_date5         ds   cl16           |\npwa_time          ds   cl16           |\npwa_time2         ds   cl16           |\npwa_time3         ds   cl16           |\npwa_time4         ds   cl16           |\npwa_time5         ds   cl16           |\npwa_text_format   ds   cl16           |\npwa_interval      ds   cl20           |\n     endpwa ,                         |\n     end   ,                          |\n//C.SYSLIB DD\n//         DD\n//         DD DSN=SYSTEMS.SRV.DONTEDIT,DISP=SHR\n//S1 EXEC PGM=SRVDTXR3\n//STEPLIB DD DISP=SHR,DSN=SYSTEMS.SRV.LOAD\n//SYSPRINT DD SYSOUT=A\n//SYSUDUMP DD SYSOUT=A\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SRVDVMAC": {"ttr": 19204, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x02\\x00\\x00W\\x01\\x11)\\x9f\\x01\\x11)\\x9f\\t'\\x00J\\x00J\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@\"", "ispf": {"version": "02.00", "flags": 0, "createdate": "2011-10-26T00:00:00", "modifydate": "2011-10-26T09:27:57", "lines": 74, "newlines": 74, "modlines": 0, "user": "CLEMSON"}, "text": "*---------------------------------------------------------------------*\n*  Copyright 2011 by Clemson University Research Foundation           *\n*                                                                     *\n*  Licensed under the Apache License, Version 2.0 (the \"License\");    *\n*  you may not use this file except in compliance with the License.   *\n*  You may obtain a copy of the License in this library as member     *\n*  $LICENSE, or from                                                  *\n*                                                                     *\n*      http://www.apache.org/licenses/LICENSE-2.0                     *\n*                                                                     *\n*  Unless required by applicable law or agreed to in writing,         *\n*  software distributed under the License is distributed on an \"AS    *\n*  IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either    *\n*  express or implied.  See the License for the specific language     *\n*  governing permissions and limitations under the License.           *\n*---------------------------------------------------------------------*\n*====================================================================*\n*  DATA IN VIRTURAL SERVICE PROCESSOR.\n*====================================================================*\n&DIV_MANAGER                            SETC '''SRVDV   '''\n&MVS_DIV_MANAGER                        SETC '''SRVDVMVS'''\n*--------------------------------------------------------------------*\n*  FUNCTION CODES.\n*--------------------------------------------------------------------*\n&DV_START                               SETA 1\n&DV_TERMINATE                           SETA 2\n&DV_OPEN_WINDOW                         SETA 3\n&DV_SAVE                                SETA 4\n&DV_RESET                               SETA 5\n&DV_CLOSE_WINDOW                        SETA 6\n*--------------------------------------------------------------------*\n*  RETURN CODES.\n*--------------------------------------------------------------------*\n&DV_INVALID_DIVID                       SETA  1\n&DV_INVALID_NUMBER_OF_PARMS             SETA  2\n&DV_INVALID_MODE                        SETA  3\n&DV_INVALID_RETAIN                      SETA  4\n&DV_NOT_USEABLE                         SETA  5\n&DV_DIV_ERROR                           SETA  6\n&DV_INVALID_FUNCTION                    SETA  7\n*--------------------------------------------------------------------*\n***********************************************************************\n***********************************************************************\n**                                                                   **\n**                     Macro Definitions                             **\n**                                                                   **\n***********************************************************************\n***********************************************************************\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   DV_ID                                                      *\n*                                                                     *\n* Purpose: Establish default values for a specific service processor  *\n*          and associate them with the specified ID name. The values  *\n*          are stored in the following created global variables:      *\n*                                                                     *\n* Variable Name                     Description                       *\n* -------------  ---------------------------------------------------- *\n* #$&ID.$#IDMAC  Name of macro that created the ID: DV_ID.            *\n* #$&ID.$#ESID   Service processor's Environment Support ID.          *\n* #$&ID.$#EPN    Tag for Service processor's Entry Point Name.        *\n* #$&ID.$#EPA    Tag for Service processor's Entry Point Address.     *\n* #$&ID.$#TKN    Tag for Service processor's Entry Point Token.       *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         DV_ID &ID=,&ESVA=,&SPEPNAME=,&SPEPA=,&SPTOKEN=,&ESID=\n.*\n.* Invoke SRV##ID to create globals used by all ID's.\n.*\n         SRV##ID SET,                                                  +\n               ID=&ID.,IDMAC=DV_ID,ESID=&ESID.,SPEPNAME=&SPEPNAME,     +\n               SPEPA=&SPEPA,SPTOKEN=&SPTOKEN.\n         MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SRVDVMVS": {"ttr": 19207, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x02\\x00\\x00W\\x01\\x11)\\x9f\\x01\\x11)\\x9f\\t'\\x02k\\x02k\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@\"", "ispf": {"version": "02.00", "flags": 0, "createdate": "2011-10-26T00:00:00", "modifydate": "2011-10-26T09:27:57", "lines": 619, "newlines": 619, "modlines": 0, "user": "CLEMSON"}, "text": "*---------------------------------------------------------------------*\n*  Copyright 2011 by Clemson University Research Foundation           *\n*                                                                     *\n*  Licensed under the Apache License, Version 2.0 (the \"License\");    *\n*  you may not use this file except in compliance with the License.   *\n*  You may obtain a copy of the License in this library as member     *\n*  $LICENSE, or from                                                  *\n*                                                                     *\n*      http://www.apache.org/licenses/LICENSE-2.0                     *\n*                                                                     *\n*  Unless required by applicable law or agreed to in writing,         *\n*  software distributed under the License is distributed on an \"AS    *\n*  IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either    *\n*  express or implied.  See the License for the specific language     *\n*  governing permissions and limitations under the License.           *\n*---------------------------------------------------------------------*\n*     //SRVDVMVS JOB (H2803302,&SYSROOM,,8),'DIV Server',TIME=(,4),\n*     //        MSGCLASS=A\n*     /*JOBPARM Q=H\n*     //DISCARD OUTPUT CLASS=*,DEFAULT=YES\n*     //LASER   OUTPUT DEST=LASER,UCS=PR12,CHARS=PR12,FCB=85@8\n*     //STEP1   EXEC ASMPCL,PDS='SYSTEMS.SRV.LOAD',NAME=SRVDVMVS,\n*     //        COPT=',RENT',LOPT=',RENT,LET,NCAL',SYSOUT='(,)',\n*     //        MAC=SYSTEMS\n*     //P.SYSPRINT DD SYSOUT=A OUTPUT=*.LASER\n*     //P.SYSIN DD   *\n*     /* <source>\n*     //C.SYSLIB DD\n*     //         DD\n*     //         DD DISP=SHR,DSN=SYSTEMS.SRV.SOURCE\n*     //\nSRVDVMVS TITLE 'MVS Data In Virtual Service Processor'\n         SMLIST CONVERT=YES           |\n*---------------------------------------------------------------------*\n*\n*  Copyright (C) 1989 Clemson University\n*\n*  Program     SRVDVMVS, MVS Data In Virtual Service Processor.\n*\n*  Abstract    This service process is MVS dependent and gives access\n*              to the functions provided by the MVS DIV macro.\n*\n*  Parameters:\n*    Two parameters, DivID and FunctionCode, are required for each\n*    call to the DIV Server.  Additional parameters are required\n*    for different FunctionCodes.  The entire parameter list required\n*    for each function is listed below.\n*\n*    START\n*      CALLX SRVDVMVS,(DivID,&Start,ESV,DDName,*Mode,*Size)\n*\n*    TERMINATE\n*      CALLX SRVDVMVS,(DivID,&Terminate)\n*\n*    OPEN_WINDOW\n*      CALLX SRVDVMVS,(DivID,&DV_Open_Window,Area,Span,Offset,Retain)\n*\n*    SAVE\n*      CALLX SRVDVMVS,(DivID,&DV_Save,Span,Offset,Size)\n*\n*    RESET\n*      CALLX SRVDVMVS,(DivID,&DV_Reset,Span,Offset)\n*\n*    CLOSE_WINDOW\n*      CALLX SRVDVMVS,(DivID,&DV_Close_Window,Area,Retain)\n*\n*    The meaning of each parameter is explained below.\n*\n*    DivID is a fullword used to uniquely identify the invocation of\n*      the DIV service processor.  It is initialized during the\n*      startup function.\n*\n*    FunctionCode is a fullword integer that specifies the function to\n*      be performed.  Symbolic identifiers are provided for each\n*      function and may be accessed by placing a COPY statement for\n*      SRVDVMAC in the assembler program.  These symbols should be\n*      used in place of actual integer values.  The following\n*      FunctionCodes are supported:\n*\n*      &START = 1\n*        Identify the ddname that points to the linear data set,\n*        define the mode of access (read or update), retrieve the\n*        existing size of the object and assign a unique DivID.\n*        This function invokes the DIV macro twice: once with IDENTIFY\n*        and once with ACCESS.\n*\n*      &TERMINATE = 2\n*        Shutdown this invocation.  This function invokes the DIV macro\n*        twice: once with UNACCESS and once with UNIDENTIFY.\n*\n*      &DV_OPEN_WINDOW = 3\n*        Open a virtual window into the linear data set.\n*\n*      &DV_SAVE = 4\n*        Save updates into a linear data set.\n*\n*      &DV_RESET = 5\n*        Reset the changes since the last save.\n*\n*      &DV_CLOSE_WINDOW = 6\n*        Close a virtual window into the linear data set.\n*\n*    ESV is a fullword given to the application by the Server Manager\n*      when it was started up.\n*\n*    DDName specified the DDName of the object.\n*\n*    Mode specified 'Read' or 'Update' intent.  Only the first byte\n*      is checked.\n*\n*    Size is a fullword into which the current size of the object is\n*      returned.  The size is returned as the number of 4K blocks.\n*\n*    Offset specifies the offset into the linear data set with which\n*      the function should operate.  The offset is specified in 4K\n*      blocks.\n*\n*    Area specifies the address of a fullword that contains a pointer\n*      to the start of the virtual window.\n*\n*    Retain specifies whether the contents storage in the virtual\n*      window should be retained while opening and closing a window\n*      and after saving.\n*\n*  Return codes:\n*\n*   &DV_INVALID_FUNCTION\n*      An invalid function was specified.\n*   &DV_INVALID_DivID\n*      The DivID provided does not identify an active heap created by\n*      the START function of the DIV processor.\n*\n*  Program     reentrant, problem key and state, server linkage,\n*  Attributes  non-authorized, amode(any), rmode(any)\n*\n*  Change\n*  History   2011/10/20 JCB - Patch rollup for CBT tape distribution\n*\n*  Method of\n*  Operation\n*\n*\n*  Special Notes:\n*    This module gives access to the MVS DIV macro at a very primitive\n*    level.  For further information about how DIV works, refer to\n*    the \"MVS/XA Supervisor Services and Macro Instruction\" manual,\n*    GC28-1154-3 or later.  Any other service processors that mimic\n*    this service processor should use the information in this manual\n*    as a specification for the external interface.\n*\n*---------------------------------------------------------------------*\n eject                                |\n copy  srvesmac                       | Environment support symbols.\n copy  srvdvmac                       | Data-in-virtual symbols.\n eject                                |\n block name=SRVDVMVS,type=program,amode=31,rmode=any,                  +\n               options=(*srvprc,noclearpwa,(parms,(using,r11))),       +\n               subopts=*swa,parmmap=parmlist\n* *-------------------------------------------------------------------*\n* * Determine how many parameters were passed and load r1 with\n* * function code.\n* *-------------------------------------------------------------------*\n  la    r1,parmlist                   | Point r1 to parameter list.\n  la    r15,prm_max_#                 | Load r15 with maximum # parms.\n  loop bct                            | Loop\n   leave loop=*,(tbit,0(r1),x'80')    |  End of parms if high bit set.\n   la   r1,4(,r1)                     |  Point to next parm address.\n  endloop bct,r15                     | Endloop\n  la    r0,prm_max_#+1                | Calculate number of\n  sr    r0,r15                        |  parms.  Ok if 2 <= num <= max\n  sth   r0,pwa_number_of_parms        | Save number of parms.\n  errexit (ch,r0,lt,=y(prm_min_#)),or,(ch,r0,gt,=y(prm_max_#)),        +\n               code=&dv_invalid_number_of_parms\n  l     r1,prm_functioncode           | Load the function code into\n  l     r1,0(,r1)                     |   a register for testing.\n* *-------------------------------------------------------------------*\n* * If the function code is something other than start, make sure that\n* * the PWA contains the eye-catcher string and the correct value for\n* * DivID.   If not, then the DivID passed in is garbage.\n* *-------------------------------------------------------------------*\n  if (c,r1,ne,=f'&dv_start')          | If not startup function then\n   errexit ((clc,pwa_visual,ne,eyecatcher),or,(c,r13,ne,pwa_divid)),   +\n               code=&dv_invalid_divid |\n  endif                               | Endif.\n  space 1                             |\n* *-------------------------------------------------------------------*\n* * Select the code to process the function.\n* *-------------------------------------------------------------------*\n  caseblk reg=r1                      | Start of function case block.\n  eject                               |\n*  *------------------------------------------------------------------*\n*  * Start function.\n*  *------------------------------------------------------------------*\n   case &dv_start                     |  Start function.\n*   *-----------------------------------------------------------------*\n*   * Set the eyecatcher and the DivID fields.   These are checked\n*   * each time the DIV server is entered to avoid integrity\n*   * problems.\n*   *-----------------------------------------------------------------*\n    mvc   pwa_visual,eyecatcher       |   Both the eyecatcher and the\n    st    r13,pwa_divid               |   DivID are for validity checks\n*   *-----------------------------------------------------------------*\n*   * Make sure that a valid number of parameters are specified.\n*   *-----------------------------------------------------------------*\n    lh    r3,pwa_number_of_parms      |   Load r3 with number of parms.\n    errexit    (ch,r3,lt,=y(prm_start_min_#)),or,   Error if out       +\n               (ch,r3,gt,=y(prm_start_max_#)),      of bounds.         +\n               code=&dv_invalid_number_of_parms\n*   *-----------------------------------------------------------------*\n*   * Get ddname.\n*   *-----------------------------------------------------------------*\n    l     r1,prm_start_ddname         |   Move ddname\n    mvc   pwa_ddname,0(r1)            |   to PWA.\n*   *-----------------------------------------------------------------*\n*   * If a mode is passed, used it; otherwise, assume read only.\n*   *-----------------------------------------------------------------*\n    if (ch,r3,ge,=y(prm_start_mode_#))     If mode was specified\n     l32   r1,prm_start_mode          |\n     if nz                            |\n      if (cli,0(r1),eq,c\"U\")          |     and is \"U\" then\n       sbit  pwa_f_update             |     indicate update mode.\n      else                            |    Else error if not \"R\".\n       errexit (cli,0(r1),ne,c\"R\"),code=&dv_invalid_mode\n      endif                           |\n     endif                            |\n    endif                             |    Endif.\n*   *-----------------------------------------------------------------*\n*   * Issue the DIV identify function.\n*   *-----------------------------------------------------------------*\n    mvc  pwa_div_ef,psd_div_lf        |    Move DIV list form to PWA.\n    div        identify,              |    Issue identify.             +\n               ddname=pwa_ddname,     |                                +\n               id=pwa_div_id,         |                                +\n               type=da,               |                                +\n               mf=(e,pwa_div_ef)      |\n    errexit (treg,r15,nz),code=&dv_div_error\n*   *-----------------------------------------------------------------*\n*   * Issue the DIV access function with the correct mode.\n*   *-----------------------------------------------------------------*\n    mvc  pwa_div_ef,psd_div_lf        |    Move DIV list form to PWA.\n    if (tbit,pwa_f_update)            |    If update mode,\n     div       access,                |     Issue access with          +\n               mode=update,           |     mode=update specified.     +\n               id=pwa_div_id,         |                                +\n               size=pwa_object_size,  |                                +\n               mf=(e,pwa_div_ef)      |\n     errexit (treg,r15,nz),code=&dv_div_error\n    else                              |    Else,\n     div       access,                |     Issue access with          +\n               mode=read,             |     mode=read specified.       +\n               id=pwa_div_id,         |                                +\n               size=pwa_object_size,  |                                +\n               mf=(e,pwa_div_ef)      |\n     errexit (treg,r15,nz),code=&dv_div_error\n    endif                             |    Endif.\n*   *-----------------------------------------------------------------*\n*   * If size parm was supplied, return the size.\n*   *-----------------------------------------------------------------*\n    if (ch,r3,ge,=y(prm_start_size_#))     If caller provided a place\n     l32   r1,prm_start_size          |    to return the object size,\n     if nz                            |\n      mvc  0(4,r1),pwa_object_size    |     Return size of object.\n     endif                            |\n    endif                             |    Endif.\n*   *-----------------------------------------------------------------*\n   eject                              |\n*  *------------------------------------------------------------------*\n*  * Terminate function.\n*  *------------------------------------------------------------------*\n   case &dv_terminate                 |\n*   *-----------------------------------------------------------------*\n*   * Invoke unaccess DIV service.\n*   *-----------------------------------------------------------------*\n    mvc  pwa_div_ef,psd_div_lf        |    Move DIV list form to PWA.\n    div  unaccess,id=pwa_div_id,      |                                +\n               mf=(e,pwa_div_ef)      |\n    errexit (treg,r15,nz),code=&dv_div_error\n*   *-----------------------------------------------------------------*\n*   * Invoke unidentify DIV service.\n*   *-----------------------------------------------------------------*\n    mvc  pwa_div_ef,psd_div_lf        |    Move DIV list form to PWA.\n    div  unidentify,id=pwa_div_id,    |                                +\n               mf=(e,pwa_div_ef)      |\n    errexit (treg,r15,nz),code=&dv_div_error\n*   *-----------------------------------------------------------------*\n*   * Indicate PWA should be freed.\n*   *-----------------------------------------------------------------*\n    smctrl freepwa=yes                |   Free the PWA on return.\n*   *-----------------------------------------------------------------*\n   eject                              |\n*  *------------------------------------------------------------------*\n*  * Open window function.\n*  *------------------------------------------------------------------*\n   case &dv_open_window               |\n    lh    r3,pwa_number_of_parms      |\n    errexit    (ch,r3,lt,=y(prm_open_window_min_#)),or,                +\n               (ch,r3,gt,=y(prm_open_window_max_#)),                   +\n               code=&dv_invalid_number_of_parms\n*   *-----------------------------------------------------------------*\n*   * Load r2 with area parameter.\n*   *-----------------------------------------------------------------*\n    l32   r2,prm_open_window_area     |\n    errexit z,code=&dv_invalid_number_of_parms\n*   *-----------------------------------------------------------------*\n*   * Load r4 with offset parameter.\n*   *-----------------------------------------------------------------*\n    slr   r4,r4                       |\n    if (ch,r3,ge,=y(prm_open_window_offset_#))\n     l     r4,prm_open_window_offset  |\n    endif                             |\n*   *-----------------------------------------------------------------*\n*   * Load r5 with span parameter.\n*   *-----------------------------------------------------------------*\n    slr   r5,r5                       |\n    if (ch,r3,ge,=y(prm_open_window_span_#))\n     l     r5,prm_open_window_span    |\n    endif                             |\n*   *-----------------------------------------------------------------*\n*   * If a retain parm is passed, used it; otherwise, assume no.\n*   *-----------------------------------------------------------------*\n    rbit  pwa_f_retain                |\n    if (ch,r3,ge,=y(prm_open_window_retain_#))\n     l32   r1,prm_open_window_retain  |\n     if nz                            |\n      if (cli,0(r1),eq,c\"Y\")          |     and is \"Y\" then\n       sbit  pwa_f_retain             |     indicate update mode.\n      else                            |    Else error if not \"N\".\n       errexit (cli,0(r1),ne,c\"N\"),code=&dv_invalid_retain\n      endif                           |\n     endif                            |\n    endif                             |    Endif.\n*   *-----------------------------------------------------------------*\n*   * Issue div with appropriate retain option.\n*   *-----------------------------------------------------------------*\n    mvc  pwa_div_ef,psd_div_lf        |    Move DIV list form to PWA.\n    if (tbit,pwa_f_retain)            |    If update mode,\n     div       map,                   |     Invoke map service         +\n               id=pwa_div_id,         |     with retain=yes specified. +\n               retain=yes,            |                                +\n               area=(2),              |                                +\n               offset=(4),            |                                +\n               span=(5),              |                                +\n               mf=(e,pwa_div_ef)      |\n     errexit (treg,r15,nz),code=&dv_div_error\n    else                              |    Else,\n     div       map,                   |     Invoke map service         +\n               id=pwa_div_id,         |     with retain=no specified.  +\n               retain=no,             |                                +\n               area=(2),              |                                +\n               offset=(4),            |                                +\n               span=(5),              |                                +\n               mf=(e,pwa_div_ef)      |\n     errexit (treg,r15,nz),code=&dv_div_error\n    endif                             |    Endif.\n*   *-----------------------------------------------------------------*\n   eject                              |\n*  *------------------------------------------------------------------*\n*  * Close window function.\n*  *------------------------------------------------------------------*\n   case &dv_close_window              |\n    lh    r3,pwa_number_of_parms      |\n    errexit    (ch,r3,lt,=y(prm_close_window_min_#)),or,               +\n               (ch,r3,gt,=y(prm_close_window_max_#)),                  +\n               code=&dv_invalid_number_of_parms\n*   *-----------------------------------------------------------------*\n*   * Load r2 with area parameter.\n*   *-----------------------------------------------------------------*\n    l32   r2,prm_close_window_area    |\n    errexit z,code=&dv_invalid_number_of_parms\n*   *-----------------------------------------------------------------*\n*   * If a retain parm is passed, used it; otherwise, assume no.\n*   *-----------------------------------------------------------------*\n    rbit  pwa_f_retain                |\n    if (ch,r3,ge,=y(prm_close_window_retain_#))\n     l32   r1,prm_close_window_retain |\n     if nz                            |\n      if (cli,0(r1),eq,c\"Y\")          |     and is \"Y\" then\n       sbit  pwa_f_retain             |     indicate update mode.\n      else                            |    Else error if not \"N\".\n       errexit (cli,0(r1),ne,c\"N\"),code=&dv_invalid_retain\n      endif                           |\n     endif                            |\n    endif                             |    Endif.\n*   *-----------------------------------------------------------------*\n*   * Issue div with appropriate retain option.\n*   *-----------------------------------------------------------------*\n    mvc  pwa_div_ef,psd_div_lf        |    Move DIV list form to PWA.\n    if (tbit,pwa_f_retain)            |    If update mode,\n     div       unmap,                 |     Invoke map service         +\n               id=pwa_div_id,         |     with retain=yes specified. +\n               retain=yes,            |                                +\n               area=(2),              |                                +\n               mf=(e,pwa_div_ef)      |\n     errexit (treg,r15,nz),code=&dv_div_error\n    else                              |    Else,\n     div       unmap,                 |     Invoke unmap service       +\n               id=pwa_div_id,         |     with retain=no specified.  +\n               retain=no,             |                                +\n               area=(2),              |                                +\n               mf=(e,pwa_div_ef)      |\n     errexit (treg,r15,nz),code=&dv_div_error\n    endif                             |    Endif.\n*   *-----------------------------------------------------------------*\n   eject                              |\n*  *------------------------------------------------------------------*\n*  * Save function.\n*  *------------------------------------------------------------------*\n   case &dv_save                      |  Save function.\n    lh    r3,pwa_number_of_parms      |   Load number of parameters.\n    errexit    (ch,r3,lt,=y(prm_save_min_#)),or,  Error if out of      +\n               (ch,r3,gt,=y(prm_save_max_#)),     bounds.              +\n               code=&dv_invalid_number_of_parms\n*   *-----------------------------------------------------------------*\n*   * Load r4 with offset parameter.\n*   *-----------------------------------------------------------------*\n    slr   r4,r4                       |   Clear r4.\n    if (ch,r3,ge,=y(prm_save_offset_#))   If enough parms are specified\n     l     r4,prm_save_offset         |   to include offset, point r4\n    endif                             |   to this parm.\n*   *-----------------------------------------------------------------*\n*   * Load r5 with span parameter.\n*   *-----------------------------------------------------------------*\n    slr   r5,r5                       |   Clear r5.\n    if (ch,r3,ge,=y(prm_save_span_#)) |   If enough parms are specified\n     l     r5,prm_save_span           |   to include span, point r4\n    endif                             |   to this parm.\n*   *-----------------------------------------------------------------*\n*   * Load r6 with size parameter.\n*   *-----------------------------------------------------------------*\n    slr   r6,r6                       |   Clear r6.\n    if (ch,r3,ge,=y(prm_save_size_#)) |   If enough parms are specified\n     l     r6,prm_save_size           |   to include size, point r4\n    endif                             |   to this parm.\n*   *-----------------------------------------------------------------*\n*   * Invoke div save service.\n*   *-----------------------------------------------------------------*\n    mvc  pwa_div_ef,psd_div_lf        |    Move DIV list form to PWA.\n    div        save,                  |     Invoke save service.       +\n               id=pwa_div_id,         |                                +\n               offset=(4),            |                                +\n               span=(5),              |                                +\n               size=(6),              |                                +\n               mf=(e,pwa_div_ef)      |\n    errexit (treg,r15,nz),code=&dv_div_error\n*   *-----------------------------------------------------------------*\n   eject                              |\n*  *------------------------------------------------------------------*\n*  * Reset function.\n*  *------------------------------------------------------------------*\n   case &dv_reset                     |  reset function.\n    lh    r3,pwa_number_of_parms      |   Load number of parameters.\n    errexit    (ch,r3,lt,=y(prm_reset_min_#)),or, Error if out of      +\n               (ch,r3,gt,=y(prm_reset_max_#)),    bounds.              +\n               code=&dv_invalid_number_of_parms\n*   *-----------------------------------------------------------------*\n*   * Load r4 with offset parameter.\n*   *-----------------------------------------------------------------*\n    slr   r4,r4                       |   Clear r4.\n    if (ch,r3,ge,=y(prm_reset_offset_#))  If enough parms are specified\n     l     r4,prm_reset_offset        |   to include offset, point r4\n    endif                             |   to this parm.\n*   *-----------------------------------------------------------------*\n*   * Load r5 with span parameter.\n*   *-----------------------------------------------------------------*\n    slr   r5,r5                       |   Clear r5.\n    if (ch,r3,ge,=y(prm_reset_span_#))    If enough parms are specified\n     l     r5,prm_reset_span          |   to include span, point r4\n    endif                             |   to this parm.\n*   *-----------------------------------------------------------------*\n*   * Invoke div reset service.\n*   *-----------------------------------------------------------------*\n    mvc  pwa_div_ef,psd_div_lf        |    Move DIV list form to PWA.\n    div        reset,                 |     Invoke reset service.      +\n               id=pwa_div_id,         |                                +\n               offset=(4),            |                                +\n               span=(5),              |                                +\n               mf=(e,pwa_div_ef)      |\n    errexit (treg,r15,nz),code=&dv_div_error\n*   *-----------------------------------------------------------------*\n   eject                              |\n*  *------------------------------------------------------------------*\n*  * If any other case, this is an invalid function.\n*  *------------------------------------------------------------------*\n   case other                         |\n    errexit code=&dv_invalid_function |\n  endcase                             |\n space 1                              |\n endblk block=SRVDVMVS,rc=0           |\n eject                                |\n*---------------------------------------------------------------------*\n*\n*  Errexit:    Unnamed\n*  Purpose:    Save debugging information and exit with the return\n*              code pointed to by r14 at entry to this exit.\n*\n*---------------------------------------------------------------------*\n         SPACE 1                      |\n block type=errexit                   |\n* *-------------------------------------------------------------------*\n* * Save module/offset, registers, return-code.\n* *-------------------------------------------------------------------*\n  st    r15,pwa_reason                | Save possible return-code.\n  stm   r0,r15,gdiregs                | Save registers at time of error\n  la    r0,4(,r12)                    | Point to module identification.\n  st    r0,gdimodid                   | Save in general debug area.\n  mvc   gdirc,0(r14)                  | Copy return code.\n  slr   r14,r12                       | Calculate offset at time of err\n  sth   r14,gdioffst                  | Save in debug area.\n  l     r2,pwaaesv                    | Point r2 to ESV.\n  using esv,r2                        | Establish base for ESV.\n  callx esvesepa,(esvestkn,&es_save_debug_info,&es_debug_id_gdi,gdi)\n* *-------------------------------------------------------------------*\n* * Look at the error code.  Some errors imply that the DIV Server\n* * has lost its cookies and should not attempt to do anything other\n* * than shut-down (if it can even do that).\n* *-------------------------------------------------------------------*\n  lh    r15,gdirc                     | Get return code.\n  caseblk reg=r15,mult=1              | Case on return-code.\n    case &dv_not_useable\n      rbit  pwa_f_useable             | Indicate DIV Server unsafe.\n      callx esvesepa,(esvestkn,&es_save_debug_info,                    +\n               &es_debug_id_hex,pwa_reason,4,\"REASON\",6)\n    case other                        |  Don't bother w/other errors.\n  endcase                             | EndCase.\n  drop r2                             |\n* *-------------------------------------------------------------------*\n* * Set the return-code and exit.\n* *-------------------------------------------------------------------*\n  lh    r15,gdirc                     | Set return code.\n endblk                               |\n eject                                |\n title \"Program Static Data\"          |\n                psd                   |\npsd_div_lf      dc    8a(0)\npsd_div_lf_length equ *-psd_div_lf\neyecatcher      dc   cl8\"DIV_SP\"      | Eyecatcher value for dumps.\n                ltorg ,               |\n                endpsd                |\n         title \"Parameter List\"\nparmlist                      dsect , |\nprm_divid                     ds a    | Div identifier === PWA base\nprm_functioncode              ds a    | Function to be performed\nprm_min_#                     equ (*-parmlist)/4\nprm_function_dept             equ *   | Function-dependent parameters\n* Start function\n                  org prm_function_dept\nprm_start_esv                 ds a    | Environment Support Vector.\nprm_start_ddname              ds a    | DDName.\nprm_start_min_#               equ (*-parmlist)/4\nprm_start_mode                ds a    | Mode of access (U or R)\nprm_start_mode_#              equ (*-parmlist)/4\nprm_start_size                ds a    | Size return area.\nprm_start_size_#              equ (*-parmlist)/4\nprm_start_max_#               equ (*-parmlist)/4\n* Terminate function\n                  org prm_function_dept\nprm_terminate_#               equ (*-parmlist)/4\n* Open Window function\n                  org prm_function_dept\nprm_open_window_area          ds a    | Area.\nprm_open_window_span          ds a    | Span.\nprm_open_window_span_#        equ (*-parmlist)/4\nprm_open_window_min_#         equ (*-parmlist)/4\nprm_open_window_offset        ds a    | Offset (in 4K blocks)\nprm_open_window_offset_#      equ (*-parmlist)/4\nprm_open_window_retain        ds a    | Retain (\"Y\" or \"N\")\nprm_open_window_retain_#      equ (*-parmlist)/4\nprm_open_window_max_#         equ (*-parmlist)/4\n* Close Window function\n                  org prm_function_dept\nprm_close_window_area         ds a    | Area.\nprm_close_window_min_#        equ (*-parmlist)/4\nprm_close_window_retain       ds a    | Retain (\"Y\" or \"N\")\nprm_close_window_retain_#     equ (*-parmlist)/4\nprm_close_window_max_#        equ (*-parmlist)/4\n* Save function\n                  org prm_function_dept\nprm_save_min_#                equ (*-parmlist)/4\nprm_save_span                 ds a    | Span.\nprm_save_span_#               equ (*-parmlist)/4\nprm_save_offset               ds a    | Offset (in 4K blocks).\nprm_save_offset_#             equ (*-parmlist)/4\nprm_save_size                 ds a    | Size.\nprm_save_size_#               equ (*-parmlist)/4\nprm_save_max_#                equ (*-parmlist)/4\n* Reset function\n                  org prm_function_dept\nprm_reset_min_#               equ (*-parmlist)/4\nprm_reset_span                ds a    | Span.\nprm_reset_span_#              equ (*-parmlist)/4\nprm_reset_offset              ds a    | Offset (in 4K blocks).\nprm_reset_offset_#            equ (*-parmlist)/4\nprm_reset_max_#               equ (*-parmlist)/4\n*\n                  org ,\nprm_max_#                     equ (*-parmlist)/4\n*\n          title \"Dsects\"\n          es_esv ,\n          title \"Program Work Area\"\n               PWA                    |\npwa_area       ds    0f               | Beginning of visible PWA stg.\npwa_visual     ds    cl8              | Character string 'DIV_SP'.\npwa_ddname     ds    cl8              | DDname.\npwa_object_size ds   f                | Object size.\npwa_f          ds    bl1              | Flags for DIV Server.\npwa_f_useable  equ   b'10000000'      | DIV Server is useable.\npwa_f_retain   equ   b'01000000'      | Retain=yes should be used.\npwa_f_update   equ   b'00100000'      | Update mode.\n               ds    bl1              | Not used.\npwa_number_of_parms ds h              | Number of parms.\npwa_divid      ds    a                | Pointer to program work area.\npwa_div_id     ds    d                | Id from DIV macro.\npwa_div_ef     ds    xl(psd_div_lf_length)\npwa_reason     ds    f                | Reason DIV Server died.\n               es_gdi dsect=no        | General debugging information.\npwa_area_l     equ   *-pwa_area       | Length of visible PWA stg.\n               endpwa                 |\n               end\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SRVDVXRZ": {"ttr": 19461, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x02\\x00\\x00W\\x01\\x11)\\x9f\\x01\\x11)\\x9f\\t'\\x00\\x98\\x00\\x98\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@\"", "ispf": {"version": "02.00", "flags": 0, "createdate": "2011-10-26T00:00:00", "modifydate": "2011-10-26T09:27:57", "lines": 152, "newlines": 152, "modlines": 0, "user": "CLEMSON"}, "text": "*---------------------------------------------------------------------*\n*  Copyright 2011 by Clemson University Research Foundation           *\n*                                                                     *\n*  Licensed under the Apache License, Version 2.0 (the \"License\");    *\n*  you may not use this file except in compliance with the License.   *\n*  You may obtain a copy of the License in this library as member     *\n*  $LICENSE, or from                                                  *\n*                                                                     *\n*      http://www.apache.org/licenses/LICENSE-2.0                     *\n*                                                                     *\n*  Unless required by applicable law or agreed to in writing,         *\n*  software distributed under the License is distributed on an \"AS    *\n*  IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either    *\n*  express or implied.  See the License for the specific language     *\n*  governing permissions and limitations under the License.           *\n*---------------------------------------------------------------------*\n//SRVXRZDV JOB (H2803302,&SYSROOM,,3),'DIV Exerciser',TIME=(,2),\n//        MSGCLASS=A\n/*JOBPARM Q=H\n//DISCARD OUTPUT CLASS=*,DEFAULT=YES\n//LASER   OUTPUT DEST=LASER,UCS=PR12,CHARS=PR12,FCB=85@8\n//STEP1   EXEC ASMPCL,PDS='SYSTEMS.SRV.LOAD',NAME=SRVXRZDV,\n//        COPT=',RENT',LOPT=',RENT,LET,NCAL',SYSOUT='(,)'\n//P.SYSPRINT DD SYSOUT=A,OUTPUT=*.LASER\n//P.SYSIN DD   *\nSRVXRZDV TITLE 'Data In Virtual Service Processor Exerciser'\n         SMLIST CONVERT=YES           |\n*---------------------------------------------------------------------*\n*\n*  CSECT: SRVXRZDV\n*\n*  COPYRIGHT: (C) Copyright Clemson University 1989\n*\n*  ABSTRACT: This program is used to as a test driver for the\n*            Data in Virtual Service Processor.\n*\n*  MODULE ACTIVITY:  MGG 03/02/89 New\n*\n*---------------------------------------------------------------------*\n         SPACE 2                      |\n block type=program,name=mggtest,options=(*pwa,xa),subopts=*swa,       $\n               amode=31,rmode=any\n  copy  srvesmac\n  copy  srvdvmac\n* *-------------------------------------------------------------------*\n* *  Load and start Environment Support Module.\n* *------------------------------------------------------------------*\n  load  eploc==c&mvs_environment_support\n  st    r0,pwaes\n  callx pwaes,(pwaestkn,&start,pwaaesv)\nastes    ds   0h\n  errexit (treg,r15,nz)\n* *-------------------------------------------------------------------*\n* *  Load and start DIV Service Processor.\n* *------------------------------------------------------------------*\n  callx pwaes,(pwaestkn,&es_load_module,&mvs_div_manager,pwadv)\nalddv    ds   0h\n  errexit (treg,r15,nz)\n  callx pwadv,(pwadvtkn,&start,pwaaesv,psd_ddname,\"U\",pwa_size)\nastdv    ds   0h\n  errexit (treg,r15,nz)\n* *-------------------------------------------------------------------*\n* *  If size is zero, get 5 blocks; otherwise, get storage required.\n* *-------------------------------------------------------------------*\n  l32   r2,pwa_size\n  if z\n   la    r2,5\n   st    r2,pwa_size\n  endif\n  sla   r2,12\n  st    r2,pwa_size_bytes\n  callx pwaes,(pwaestkn,&es_obtain_storage,pwa_size_bytes,0,           $\n               &es_page_boundary,                                      $\n               &es_location_any,                                       $\n               pwa_area)\n  errexit (treg,r15,nz)\n* *-------------------------------------------------------------------*\n* *  Open window.\n* *-------------------------------------------------------------------*\n  callx pwadv,(pwadvtkn,&dv_open_window,pwa_area,pwa_size,,\"N\")\naopwd    ds   0h\n  errexit (treg,r15,nz)\n* *-------------------------------------------------------------------*\n* *  Make a change.\n* *-------------------------------------------------------------------*\n  l     r1,pwa_area\n  mvc  0(50,r1),=cl50\"THIS IS MOVED TO THE WINDOW.\"\n* *-------------------------------------------------------------------*\n* *  Save the changes.\n* *-------------------------------------------------------------------*\n  callx pwadv,(pwadvtkn,&dv_save)\nasave    ds   0h\n  errexit (treg,r15,nz)\n* *-------------------------------------------------------------------*\n* *  Move something else to the window.\n* *-------------------------------------------------------------------*\n  l     r1,pwa_area\n  mvc  0(50,r1),=cl50\"SOMETHING ELSE TO THE WINDOW.\"\n  errexit (treg,r15,nz)\n* *-------------------------------------------------------------------*\n* *  Reset this change.\n* *-------------------------------------------------------------------*\n  callx pwadv,(pwadvtkn,&dv_reset)\nareset   ds   0h\n  errexit (treg,r15,nz)\n* *-------------------------------------------------------------------*\n* *  Save again.\n* *-------------------------------------------------------------------*\n  callx pwadv,(pwadvtkn,&dv_save)\nasave2   ds   0h\n  errexit (treg,r15,nz)\nskip equ *\n* *-------------------------------------------------------------------*\n* *  Terminate service processors.\n* *-------------------------------------------------------------------*\n  callx pwadv,(pwadvtkn,&terminate)\n  errexit (treg,r15,nz)\n  callx pwaes,(pwaestkn,&es_release_storage,pwa_size_bytes,0,          $\n               pwa_area)\n  errexit (treg,r15,nz)\n  callx pwaes,(pwaestkn,&terminate)\n  errexit (treg,r15,nz)\n* *-------------------------------------------------------------------*\n* *  Unload service manager and environment support module.\n* *-------------------------------------------------------------------*\n  delete eploc==c&mvs_environment_support\n* *-------------------------------------------------------------------*\n endblk block=mggtest                 |\n space 2\n block type=errexit\n  callx pwaes,(pwaestkn,&es_display_debug_info_and_abend)\n endblk\n space 2\n         psd\npsd_ddname dc  al1(6),c\"LINEAR\"\n         ltorg ,\n         endpsd\n         title \"Program Work Area\"    |\n         pwa                          |\npwaaesv  ds    a     address of service processor global area\npwaestkn ds    a     environment support token\npwaes    ds    a     environment support entry point address\npwadvtkn ds    a     div service processor for testing\npwadv    ds    a     div entry point address\npwa_size ds    f\npwa_size_bytes ds f\npwa_area ds    a\n         endpwa                       |\n         end   ,                      |\n//C.SYSLIB DD\n//         DD\n//         DD DSN=SYSTEMS.SRV.SOURCE,DISP=SHR\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SRVESMAC": {"ttr": 19465, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x02\\x00\\x00W\\x01\\x11)\\x9f\\x01\\x11)\\x9f\\t'\\x06h\\x06h\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@\"", "ispf": {"version": "02.00", "flags": 0, "createdate": "2011-10-26T00:00:00", "modifydate": "2011-10-26T09:27:57", "lines": 1640, "newlines": 1640, "modlines": 0, "user": "CLEMSON"}, "text": "*---------------------------------------------------------------------*\n*  Copyright 2011 by Clemson University Research Foundation           *\n*                                                                     *\n*  Licensed under the Apache License, Version 2.0 (the \"License\");    *\n*  you may not use this file except in compliance with the License.   *\n*  You may obtain a copy of the License in this library as member     *\n*  $LICENSE, or from                                                  *\n*                                                                     *\n*      http://www.apache.org/licenses/LICENSE-2.0                     *\n*                                                                     *\n*  Unless required by applicable law or agreed to in writing,         *\n*  software distributed under the License is distributed on an \"AS    *\n*  IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either    *\n*  express or implied.  See the License for the specific language     *\n*  governing permissions and limitations under the License.           *\n*---------------------------------------------------------------------*\n TITLE 'SRVESMAC: Environment Support Service Processor Symbols && Macr+\n               os.'\n*---------------------------------------------------------------------*\n*\n*  Copy File:  SRVESMAC\n*\n*  Purpose:    Environment Support service processor symbols & macros.\n*\n*  Description: See \"Service Processors User's Guide and Reference\".\n*\n*  Change\n*  History   2011/10/20 JCB - Patch rollup for CBT tape distribution\n*\n*---------------------------------------------------------------------*\n***********************************************************************\n***********************************************************************\n**                                                                   **\n**                     Symbol Definitions                            **\n**                                                                   **\n***********************************************************************\n***********************************************************************\n*\n* Global declarations for all symbols defined here.\n*\n  GBLA &START,&TERMINATE,&SUCCESSFUL\n  GBLC &ENVIRONMENT_SUPPORT,&MVS_ENVIRONMENT_SUPPORT\n  GBLC &ES_MVS_MESSAGE_EXIT\n  GBLA &ES_START,&ES_TERMINATE,&ES_OBTAIN_STORAGE\n  GBLA &ES_RELEASE_STORAGE,&ES_LOAD_MODULE,&ES_UNLOAD_MODULE\n  GBLA &ES_DISPLAY_MESSAGE,&ES_SAVE_DEBUG_INFO,&ES_DISPLAY_DEBUG_INFO\n  GBLA &ES_DISPLAY_DEBUG_INFO_AND_ABEND,&ES_CLEAR_DEBUG_INFO\n  GBLA &ES_GET_USERID,&ES_GET_GROUP,&ES_GET_CACCT\n  GBLA &ES_GET_SYSRES_VOLUME_NAME,&ES_GET_TERMINAL_NAME\n  GBLA &ES_GET_JOBCARD_NAME_FIELD,&ES_GET_JOBCARD_ROOM\n  GBLA &ES_GET_TSU_STC_OR_JOB,&ES_GET_JOBID\n  GBLA &ES_GET_DEFAULT_DESTINATION,&ES_GET_PREFIX,&ES_GET_TIME\n  GBLA &ES_GET_GMT_TIME\n  GBLA &ES_GET_FORMATTED_TIME\n  GBLA &ES_SUCCESS,&ES_SUCCESSFUL\n  GBLA &ES_MISSING_EXIT_ROUTINE,&ES_INTERNAL_ERROR\n  GBLA &ES_INVALID_FUNCTION\n  GBLA &ES_COULD_NOT_LOCATE,&ES_INVALID_BOUNDARY,&ES_INVALID_LOCATION\n  GBLA &ES_INVALID_ACTION,&ES_CLEAR_DEBUG_INHIBITED\n  GBLA &ES_STORAGE_NOT_AVAILABLE,&ES_STORAGE_NOT_RELEASED\n  GBLA &ES_UNDETERMINED,&ES_MODULE_NOT_LOADED,&ES_MODULE_NOT_UNLOADED\n  GBLA &ES_DOUBLEWORD_BOUNDARY,&ES_PAGE_BOUNDARY,&ES_LOCATION_ANY\n  GBLA &ES_LOCATION_BELOW,&ES_DEBUG_ID_GDI,&ES_DEBUG_ID_TEXT\n  GBLA &ES_DEBUG_ID_HEX\n  GBLA &ES_LM_STANDARD,&ES_LM_MNT_ONLY,&ES_LM_NO_LOAD\n  GBLA &ES_CDI_EXECUTE,&ES_CDI_INHIBIT,&ES_CDI_ENABLE\n  GBLA &ES_OC_MNT,&ES_OC_STDMNT,&ES_OC_NOSTDMNT\n*\n* Common function codes for *all* service processors.\n*\n&START                                  SETA 1\n&TERMINATE                              SETA 2\n*\n* Common return codes for *all* service processors.\n*\n&SUCCESS                                SETA 0\n&SUCCESSFUL                             SETA &SUCCESSFUL\n*\n* Entry point names for all Environment Support service processors.\n*\n&ENVIRONMENT_SUPPORT      SETC '''SRVES   '''  Generic Env. Support.\n&MVS_ENVIRONMENT_SUPPORT  SETC '''SRVESMVS'''  MVS Environment Support.\n&ES_MVS_MESSAGE_EXIT      SETC '''SRVESX01'''  Message exit module.\n*\n* Function codes for Environment Support:\n*\n&ES_START                               SETA  &START\n&ES_TERMINATE                           SETA  &TERMINATE\n&ES_OBTAIN_STORAGE                      SETA  3\n&ES_RELEASE_STORAGE                     SETA  4\n&ES_LOAD_MODULE                         SETA  5\n&ES_UNLOAD_MODULE                       SETA  6\n&ES_DISPLAY_MESSAGE                     SETA  7\n&ES_SAVE_DEBUG_INFO                     SETA  8\n&ES_DISPLAY_DEBUG_INFO                  SETA  9\n&ES_DISPLAY_DEBUG_INFO_AND_ABEND        SETA 10\n&ES_CLEAR_DEBUG_INFO                    SETA 11\n&ES_GET_USERID                          SETA 12\n&ES_GET_GROUP                           SETA 13\n&ES_GET_CACCT                           SETA 14\n&ES_GET_SYSRES_VOLUME_NAME              SETA 15\n&ES_GET_TERMINAL_NAME                   SETA 16\n&ES_GET_JOBCARD_NAME_FIELD              SETA 17\n&ES_GET_JOBCARD_ROOM                    SETA 18\n&ES_GET_TSU_STC_OR_JOB                  SETA 19\n&ES_GET_JOBID                           SETA 20\n&ES_GET_DEFAULT_DESTINATION             SETA 21\n&ES_GET_PREFIX                          SETA 22\n&ES_GET_TIME                            SETA 23\n&ES_GET_FORMATTED_TIME                  SETA 24\n&ES_GET_GMT_TIME                        SETA 25\n*\n* Return codes from Environment Support.\n*\n&ES_SUCCESS                             SETA  0\n&ES_SUCCESSFUL                          SETA  &ES_SUCCESS\n&ES_MISSING_EXIT_ROUTINE                SETA  1\n&ES_INTERNAL_ERROR                      SETA  2\n&ES_INVALID_FUNCTION                    SETA  4\n&ES_COULD_NOT_LOCATE                    SETA  8\n&ES_INVALID_BOUNDARY                    SETA 12\n&ES_INVALID_LOCATION                    SETA 16\n&ES_INVALID_ACTION                      SETA 17\n&ES_CLEAR_DEBUG_INHIBITED               SETA 18\n&ES_STORAGE_NOT_AVAILABLE               SETA 20\n&ES_STORAGE_NOT_RELEASED                SETA 24\n&ES_UNDETERMINED                        SETA 28\n&ES_MODULE_NOT_LOADED                   SETA 32\n&ES_MODULE_NOT_UNLOADED                 SETA 36\n&ES_WRONG_NUMBER_OF_PARMS               SETA 40\n    DEFUCOND MACRO=SRV##RC,NAME=SUCCESS\n    DEFUCOND MACRO=SRV##RC,NAME=ES_SUCCESS\n    DEFUCOND MACRO=SRV##RC,NAME=ES_SUCCESSFUL\n    DEFUCOND MACRO=SRV##RC,NAME=ES_MISSING_EXIT_ROUTINE\n    DEFUCOND MACRO=SRV##RC,NAME=ES_INTERNAL_ERROR\n    DEFUCOND MACRO=SRV##RC,NAME=ES_INVALID_FUNCTION\n    DEFUCOND MACRO=SRV##RC,NAME=ES_COULD_NOT_LOCATE\n    DEFUCOND MACRO=SRV##RC,NAME=ES_INVALID_BOUNDARY\n    DEFUCOND MACRO=SRV##RC,NAME=ES_INVALID_LOCATION\n    DEFUCOND MACRO=SRV##RC,NAME=ES_INVALID_ACTION\n    DEFUCOND MACRO=SRV##RC,NAME=ES_CLEAR_DEBUG_INHIBITED\n    DEFUCOND MACRO=SRV##RC,NAME=ES_STORAGE_NOT_AVAILABLE\n    DEFUCOND MACRO=SRV##RC,NAME=ES_STORAGE_NOT_RELEASED\n    DEFUCOND MACRO=SRV##RC,NAME=ES_UNDETERMINED\n    DEFUCOND MACRO=SRV##RC,NAME=ES_MODULE_NOT_LOADED\n    DEFUCOND MACRO=SRV##RC,NAME=ES_MODULE_NOT_UNLOADED\n    DEFUCOND MACRO=SRV##RC,NAME=ES_WRONG_NUMBER_OF_PARMS\n*\n* Search criteria for ES_LOAD_MODULE function.\n*\n&ES_LM_STANDARD                         SETA 1  *default*\n&ES_LM_MNT_ONLY                         SETA 2  Only if named in MNT.\n&ES_LM_NO_LOAD                          SETA 3  Do not load.\n*\n* Storage boundaries for the &ES_OBTAIN_STORAGE function.\n*\n&ES_DOUBLEWORD_BOUNDARY                 SETA 1\n&ES_PAGE_BOUNDARY                       SETA 2\n*\n* Storage locations for the &ES_OBTAIN_STORAGE function.\n*\n&ES_LOCATION_ANY                        SETA 1\n&ES_LOCATION_BELOW                      SETA 2\n*\n* Debug identifiers for various DEBUG functions.\n*\n&ES_DEBUG_ID_GDI                        SETA 1\n&ES_DEBUG_ID_TEXT                       SETA 2\n&ES_DEBUG_ID_HEX                        SETA 3\n*\n* Action-codes for ES_CLEAR_DEBUG_INFO function.\n*\n&ES_CDI_EXECUTE                         SETA 1\n&ES_CDI_INHIBIT                         SETA 2\n&ES_CDI_ENABLE                          SETA 3\n*---------------------------------------------------------------------*\n* The symbols below define exit-specific function codes.              *\n*---------------------------------------------------------------------*\n GBLA &ES_X01_ISSUE_MESSAGE\n*\n* Exit-specific function codes.\n*\n&ES_X01_ISSUE_MESSAGE       SETA          3\n*\n* Option codes used during START to indicate how the file will be used.\n*\n*                            |-BYTE  1-|\n&ES_OC_MNT          SETA 128 |X... ....|Bit-mask for STDMNT:\n&ES_OC_STDMNT       SETA   0 |0... ....|  Standard MNT.\n&ES_OC_NOSTDMNT     SETA 128 |1... ....|  No Standard MNT.\n&ES_OC_RESERVED     SETA   0 |.000 0000|Reserved bits.\n                            EJECT\n***********************************************************************\n***********************************************************************\n**                                                                   **\n**                     Macro Definitions                             **\n**                                                                   **\n***********************************************************************\n***********************************************************************\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Macro:      ES_ESV                                                 *\n*  Purpose:    This macro is used to map the Environment Support      *\n*              Vector.                                                *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n&TAG     ES_ESV &DSECT=YES,&PREFIX=ESV\n         LCLC  &I,&NAME\n&I       SETC  '&PREFIX'\n&NAME    SETC  '&PREFIX'\n         AIF   ('&TAG' EQ '').NOTAG\n&NAME    SETC  '&TAG'\n.NOTAG   ANOP\n         AIF ('&DSECT' EQ 'NO').NODSECT\n&NAME    DSECT\n         AGO .TG1\n.NODSECT ANOP\n&NAME    DS    0F\n.TG1     ANOP\n&I.ID    DS    CL4         CONTROL BLOCK ID\n&I.IDT   EQU   C'ESV '     CONTROL BLOCK ID TEXT\n&I.LEN   DS    H           LENGTH OF ESV\n&I.VER   DS    X           VERSION\n&I.REL   DS    X           RELEASE\n*---------------------------------------------------------------------*\n*  The following ten (10) fields are addressed with hardcoded\n*  displacements by Structured Macros ##PEOS and ##PPOS.\n*---------------------------------------------------------------------*\n&I.ALGET     DS  A      +8 Address of linkage GETMAIN                 |\n&I.ULGET     DS  A     +12 User parameter for linkage GETMAIN         |\n&I.ALFRE     DS  A     +16 Address of linkage FREEMAIN                |\n&I.ULFRE     DS  A     +20 User parameter for linkage FREEMAIN        |\n&I.ESEPA     DS  A     +24 Environment support EPA address            |\n&I.ESTKN     DS  A     +28 Environment support TOKEN                  |\n&I.DBBTM     DS  A     +32 Bottom of stack                            |\n&I.DBTOP     DS  A     +36 Top of stack                               |\n&I.DBLMT     DS  A     +40 Limit address of stack                     |\n&I.DBINHIBIT DS  X     +44 ClearDebug Inhibit Count (0 if auto-clear) |\n*---------------------------------------------------------------------*\n         DS    3X          Reserved for future expansion; must-be-zeros\n         DS    8F          Reserved for future expansion; must-be-zeros\n         SPACE\n&I.CBLEN EQU   *-&NAME     Length of ESV.\n         MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Macro:      ES_GDI                                                 *\n*  Purpose:    This macro is used to map the General Debugging        *\n*              Information data area that is passed to the            *\n*              ES_SAVE_DEBUG_INFO function.                           *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n&TAG     ES_GDI &DSECT=YES,&PREFIX=GDI\n         LCLC  &I,&NAME\n&I       SETC  '&PREFIX'\n&NAME    SETC  '&PREFIX'\n         AIF   ('&TAG' EQ '').NOTAG\n&NAME    SETC  '&TAG'\n.NOTAG   ANOP\n         AIF ('&DSECT' EQ 'NO').NODSECT\n&NAME    DSECT\n         AGO .TG1\n.NODSECT ANOP\n&NAME    DS    0F\n.TG1     ANOP\n         SPACE 1\n*---------------------------------------------------------------------*\n*                                                                     *\n* General Debugging Information area                                  *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE\n&I.MODID DS    A        | Address of module ID.\n&I.OFFST DS    H        | Offset of error.\n&I.RC    DS    H        | Return code.\n&I.REGS  DS    16F      | Registers at time of error.\n         DS    0F       | Round GDI up to a fullword length.\n&I.CBLEN EQU   *-&NAME  | Length of GDI.\n         MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Macro:      ES_MNT                                                 *\n*  Purpose:    This macro is used to map the Environment Support      *\n*              Module Name Table.                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n             MACRO\n&LABEL       ES_MNT &DSECT=YES,&ID=ES_MNT\n             LCLC  &I,&NAME\n&I           SETC  '&ID'\n&NAME        SETC  '&ID'\n             AIF   ('&LABEL' EQ '').NOLABEL\n&NAME        SETC  '&LABEL'\n.NOLABEL     ANOP\n             AIF ('&DSECT' EQ 'NO').NODSECT\n&NAME        DSECT                | Module Name Table Mapping:\n             AGO .GEN_FIELDS\n.NODSECT     ANOP\n&NAME        DS  0F               | Module Name Table Mapping:\n.GEN_FIELDS  ANOP\n&I.NAME      DS  CL8              |   Module's Generic Name.\n&I.TRUENAME  DS  CL8              |   Module's True Name.\n&I.END       EQU X'00'            |   End-of-MNT Marker value.\n&I.EPA       DS  A                |   Module's EPA or zero (for LOAD).\n&I.CBLEN     EQU *-&NAME          | Length of Module Name Table.\n             MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Macro:      ES_MODULE_NAME                                         *\n*  Purpose:    This macro is used to create entries in an Environment *\n*              Support Module Name Table.                             *\n*  Note:       NAME= and TRUENAME= must be given as quoted strings.   *\n*              If TRUENAME= is not specified, it will be set to NAME. *\n*              DCAMODE=31 indicate that high bit of adcon should be   *\n*              set to 1.                                              *\n*                                                                     *\n*---------------------------------------------------------------------*\n                  MACRO\n&LABEL            ES_MODULE_NAME &TYPE,&NAME=,&TRUENAME=,              +\n               &DCAMODE=,&WXTRN=\n                  LCLC  &L_WXTRN,&L_TRUE\n.*\n.* Generate a TYPE = START entry.\n.*\n                  AIF   ('&TYPE' NE 'START').END\n                  AIF   ('&NAME' EQ '').NAME_MISSING\n                  AIF   ('&NAME'(1,1) NE '''').NAME_NOT_QUOTED\n&LABEL            DS    0F              | Start of Module Name Table:\n                  DC    A(MNT&SYSNDX.1) |   Address of first entry.\n                  DC    CL8&NAME        |   This module's name.\n                  DC    CL8'&SYSDATE'   |   Compile date.\n                  DC    CL6'&SYSTIME'   |   Compile time.\nMNT&SYSNDX.1      DS    0F              |   End of prefix data.\n                  MEXIT\n.*\n.* Generate a TYPE = END entry.\n.*\n.END              AIF   ('&TYPE' NE 'END').ENTRY\n&LABEL            DC    X'00'           | End of Module Name Table.\n                  MEXIT\n.*\n.* Generate a module name entry.\n.*\n.ENTRY            AIF   ('&TYPE' NE '').TYPE_ERROR\n                  AIF   ('&NAME' EQ '').NAME_MISSING\n                  AIF   ('&NAME'(1,1) NE '''').NAME_NOT_QUOTED\n&L_TRUE           SETC  '&TRUENAME'\n                  AIF   ('&L_TRUE' EQ '').USE_NAME\n                  AIF   ('&L_TRUE'(1,1) NE '''').TRUE_NOT_QUOTED\n                  AGO   .GOT_TRUE\n.USE_NAME         ANOP\n&L_TRUE           SETC  '&NAME'\n.GOT_TRUE         ANOP\n                  AIF   ('&WXTRN' EQ '').USE_TRUE\n                  AIF   ('&WXTRN'(1,1) NE '''').WXTRN_NOT_QUOTED\n&L_WXTRN          SETC  '&WXTRN'\n                  AGO   .REMOVE_WXTRN_QUOTES\n.USE_TRUE         ANOP\n&L_WXTRN          SETC  '&L_TRUE'\n.REMOVE_WXTRN_QUOTES ANOP\n&L_WXTRN          SETC  '&L_WXTRN'(2,K'&L_WXTRN-2)\n.SYM_LOOP         AIF   ('&L_WXTRN' EQ '').SYM_NULL\n                  AIF   ('&L_WXTRN'(K'&L_WXTRN,1) NE ' ').PAST_SYM\n&L_WXTRN          SETC  '&L_WXTRN'(1,K'&L_WXTRN-1)\n                  AGO   .SYM_LOOP\n.PAST_SYM         ANOP\n&LABEL            DC    CL8&NAME.       |   Module's Generic Name.\n                  DC    CL8&L_TRUE.     |   Module's True Name.\n                  AIF   (D'&L_WXTRN).ADCON\n                  WXTRN &L_WXTRN        |   Define as weak-external.\n                  AIF   ('&DCAMODE' EQ '').ADCON\n                  AIF   ('&DCAMODE' EQ '24').ADCON\n                  AIF   ('&DCAMODE' NE '31').BAD_DCAMODE\n&L_WXTRN          SETC  'X''80000000''+&L_WXTRN'\n.ADCON            DC    A(&L_WXTRN)     |   Module's EPA.\n                  MEXIT\n.TYPE_ERROR       MNOTE 8,'INVALID TYPE &TYPE'\n                  MEXIT\n.NAME_MISSING     MNOTE 8,'NAME= must be specified.'\n                  MEXIT\n.NAME_NOT_QUOTED  MNOTE 8,'NAME must be a quoted string.'\n                  MEXIT\n.TRUE_NOT_QUOTED  MNOTE 8,'TRUENAME must be a quoted string.'\n                  MEXIT\n.WXTRN_NOT_QUOTED MNOTE 8,'WXTRN must be a quoted string.'\n                  MEXIT\n.SYM_NULL         MNOTE 8,'TRUENAME= or NAME= is null.'\n                  MEXIT\n.BAD_DCAMODE      MNOTE 8,'DCAMODE=&DCAMODE is not valid.'\n                  MEND\n                  MACRO\n*---------------------------------------------------------------------*\n*\n*  MACRO:      ES_DBI\n*\n*  TITLE:      DeBug Info Mapping Macro\n*\n*  PURPOSE:    This macro maps a debug info entry.\n*\n*  SPECIAL     The entries mapped by this macro are used in\n*  NOTES:      conjunction with the &es_save_debug_info function\n*              of an Environment Support service processor.\n*\n*  CHANGE\n*  HISTORY:    05/13/87 MGG - New\n*\n*---------------------------------------------------------------------*\n&TAG     ES_DBI &DSECT=YES,&ID=DBI\n         LCLC  &I,&NAME\n         GBLA  &ES_DEBUG_ID_GDI,&ES_DEBUG_ID_TEXT,&ES_DEBUG_ID_HEX\n&I       SETC  '&ID'\n&NAME    SETC  '&ID'\n         AIF   ('&TAG' EQ '').NOTAG\n&NAME    SETC  '&TAG'\n.NOTAG   ANOP\n         AIF ('&DSECT' EQ 'NO').NODSECT\n&NAME    DSECT\n         AGO .TG1\n.NODSECT ANOP\n&NAME    DS    0F\n.TG1     ANOP\n         SPACE 1\n         SPACE 1                      |\n&I.LEN   DS    H                      | Length of entry.\n&I.TY    DS    X                      | Type of entry.\n&I.TYGDI EQU   &ES_DEBUG_ID_GDI       |  General debug information.\n&I.TYTXT EQU   &ES_DEBUG_ID_TEXT      |  Text.\n&I.TYHEX EQU   &ES_DEBUG_ID_HEX       |  Hex information.\n&I.VAR   EQU   *                      | Variable information.\n         SPACE 1                      |\n* Type 1 Debug Info - General Debug Info.\n         ORG   &I.VAR                 |\n&I.1OFST DS    H                      | Offset of error.\n&I.1RC   DS    H                      | Return code.\n&I.1REGS DS    XL(16*4)               | Registers at time of error.\n&I.1FLEN EQU   *-&I                   | Length of fixed part\n&I.1MODI EQU   *                      | (variable) module id.\n         SPACE 1                      |\n* Type 2 Debug Info - Reason Information.\n         ORG   &I.VAR                 |\n&I.2     EQU   *                      | (variable) Reason information.\n         SPACE 1                      |\n* Type 3 Debug Info - Text.           |\n*     The debug information is a one byte length followed by name\n*     followed by another one byte length followed by the text.\n         ORG   &I.VAR                 |\n&I.3     EQU   *                      | Variable info described above.\n         SPACE 1                      |\n* Type 4 Debug Info - Hex.            |\n*     The debug information is a one byte length followed by name\n*     followed by another one byte length followed by the hex.\n         ORG   &I.VAR                 |\n&I.4     EQU   *                      | Variable info described above.\n         SPACE 1                      |\n         DS    0F                     |\n         SPACE 1                      |\n&I.CBLEN EQU   *-&NAME                | Length of DBI.\n         MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   ES_ID                                                      *\n*                                                                     *\n* Purpose: Establish default values for a specific service processor  *\n*          and associate them with the specified ID name. The values  *\n*          are stored in the following created global variables:      *\n*                                                                     *\n* Variable Name                     Description                       *\n* -------------  ---------------------------------------------------- *\n* #$&ID.$#IDMAC  Name of macro that created the ID: ES_ID.            *\n* #$&ID.$#ESID   Service processor's Environment Support ID.          *\n* #$&ID.$#ESVA   Tag for ESVA Kept for Environment Support ID's only. *\n* #$&ID.$#EPN    Tag for Service processor's Entry Point Name.        *\n* #$&ID.$#EPA    Tag for Service processor's Entry Point Address.     *\n* #$&ID.$#TKN    Tag for Service processor's Entry Point Token.       *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         ES_ID &ID=,&ESVA=,&SPEPNAME=,&SPEPA=,&SPTOKEN=\n         GBLC  &PWA,&PSD,&DEFAULT_ENVIRONMENT_SUPPORT_ID\n         LCLC  &V_ESVA\n         LCLB  &GEN_PWA\n.*\n.* Invoke SRV##ID to create globals used by all ID's.\n.*\n         SRV##ID SET,                                                  +\n               ID=&ID.,IDMAC=ES_ID,ESID=&ID.,SPEPNAME=&SPEPNAME,       +\n               SPEPA=&SPEPA,SPTOKEN=&SPTOKEN.\n.*\n.* Create the global variables specific to environment support's ID.\n.*\n&V_ESVA   SETC '#$&ID.$#ESVA'      ESVA tag's variable name.\n          GBLC  &(&V_ESVA)         Create ESVA tag's variable.\n&(&V_ESVA) SETC '&ESVA'            Remember the specified ESVA.\n.*\n.* If this is the first Environment Support ID, make it the default.\n.*\n          AIF   ('&DEFAULT_ENVIRONMENT_SUPPORT_ID' NE '').ID_DEF\n&DEFAULT_ENVIRONMENT_SUPPORT_ID SETC '&ID'    ESID to use by default.\n.ID_DEF   MNOTE *,'Default environment support ID is &DEFAULT_ENVIRONME+\n               NT_SUPPORT_ID..'\n.*\n.* Generate PWA fields for those values that are defaulting.\n.*\n&GEN_PWA  SETB (&GEN_PWA OR ('&ESVA' EQ ''))\n          AIF  (NOT &GEN_PWA).NO_PWA\n          PWA   TYPE=PARTIAL    | Generate fields for Env. Sup.\n.*        AIF   ('&ESVA' NE '').ENDPWA\n&(&V_ESVA) SETC '&PWA.&ID._ESVA'\n&(&V_ESVA) DS   A               |   Environment Support's ESV Address.\n.ENDPWA   ENDPWA ,              | End of generated PWA fields.\n.NO_PWA   ANOP\n          MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   ES_MVS_LOAD                                                *\n* Purpose: Generate MVS code to load an environment support module.   *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         ES_MVS_LOAD &ID=,&SPEPNAME=,&SPEPA=\n         GBLC  &MVS_ENVIRONMENT_SUPPORT\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN\n.*\n.* Obtain service processor ID values and generate an MVS load instr.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA),                                 +\n               ID=&ID,IDMAC=(ES_ID),SPEPNAME=&SPEPNAME,                +\n               SPEPA=&SPEPA\n         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT\n         AIF  ('&#_IDEPN' NE '').GOTEPN\n&#_IDEPN SETC '&MVS_ENVIRONMENT_SUPPORT' This macro is MVS anyways.\n.GOTEPN  AIF  ('&#_IDEPN'(1,1) NE '''').LOAD\n&#_IDEPN SETC '=CL8&#_IDEPN'              | Use literal for EPLOC.\n.LOAD    LOAD EPLOC=&#_IDEPN              |  Load Env. Support.\n         ST   R0,&#_IDEPA                 | Save its EPA.\n         MEXIT\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   ES_MVS_UNLOAD                                              *\n* Purpose: Generate MVS code to unload a module.                      *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         ES_MVS_UNLOAD &ID=,&SPEPNAME=,&SPEPA=\n         GBLC  &MVS_ENVIRONMENT_SUPPORT\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN\n.*\n.* Obtain service processor ID values and generate an MVS delete instr.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA),                                 +\n               ID=&ID,IDMAC=(ES_ID),SPEPNAME=&SPEPNAME,                +\n               SPEPA=&SPEPA\n         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT\n         AIF  ('&#_IDEPN' NE '').GOTEPN\n&#_IDEPN SETC '&MVS_ENVIRONMENT_SUPPORT' This macro is MVS anyways.\n.GOTEPN  AIF  ('&#_IDEPN'(1,1) NE '''').LOAD\n&#_IDEPN SETC   '=CL8&#_IDEPN'             | Use literal for EPLOC.\n.LOAD    DELETE EPLOC=&#_IDEPN             | Delete specified module.\n         XC     &#_IDEPA,&#_IDEPA          | Clear its EPA.\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   ES_START                                                   *\n* Purpose: Generate code to start a new environment support session.  *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         ES_START &ID=,&SPEPA=,&SPTOKEN=,&ESVA=,&MNT=,&EXITINFO=,      +\n               &OPTIONS=,&OPTIONVALUE=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN\n         GBLA  &ES_START                  SETC in open code.\n         GBLA  &ES_OC_MNT,&ES_OC_STDMNT,&ES_OC_NOSTDMNT\n         LCLA  &I,&J,\n         LCLC  &O_NAME(2)                 Option names, paired up.\n         LCLB  &O_SET(2)                  Names specified, paired up.\n         LCLA  &O_VALUE,&O2_VALUE,&O3_VALUE,&O4_VALUE\n.*\n.* Obtain service processor ID values and start environment support.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN,ESVA),                    +\n               ID=&ID,IDMAC=(ES_ID),SPEPA=&SPEPA,                      +\n               SPTOKEN=&SPTOKEN,ESVA=&ESVA.\n         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT\n         MVC   &#_IDTKN,=F'0'            | Insure TOKEN = 0.\n.*\n.* Generate the OPTIONS parameter for ES_START.\n.*\n.*   The symbols in O_NAME are option keywords that may be specified.\n.*\n.*\n               AIF  ('&OPTIONS' NE '').OPT_KWDS\n&L_OPTIONS     SETC '&OPTIONVALUE'\n               AGO  .PAST_OPTIONS\n.OPT_KWDS      ANOP\n&O_NAME(1)     SETC 'STDMNT','NOSTDMNT'\n.*                  1 2 3 4 5 6 7 8 9 + 1 2 3 4 5 6 7 8 9\n&O_SET(1)      SETB 0,0\n&I             SETA 0\n.O_KWD_LOOP    AIF  (&I GE N'&OPTIONS).PAST_OPT\n&I             SETA &I+1\n&J             SETA 1\n.O_NAME_LOOP   AIF  (&J GT N'&O_NAME).PAST_NAME\n               AIF  ('&OPTIONS(&I)' EQ '&O_NAME(&J)').PAST_NAME\n&J             SETA &J+1\n               AGO  .O_NAME_LOOP\n.PAST_NAME     AIF   (&J LE N'&O_NAME).O_CHK_SET\n               MNOTE 8,'Option &OPTIONS(&I) is invalid.'\n               AGO   .O_KWD_LOOP\n.O_CHK_SET     AIF   (NOT (&O_SET(&J))).O_SET_OPT\n               MNOTE 8,'Option &OPTIONS(&I) already specified.'\n               AGO   .O_KWD_LOOP\n.O_SET_OPT     ANOP\n&O_SET(&J)     SETB  1\n               AGO   .O_KWD_LOOP\n.PAST_OPT      ANOP\n.*\n.* Check for mutually exclusive keywords and other invalid combos.\n.*\n&L_OPTIONS SETC  'STDMNT and NOSTDMNT'\n           AIF   (&O_SET(1) AND &O_SET(2)).MUTEX  (STDMNT NOSTDMNT)\n           AGO   .PAST_MUTEX\n.MUTEX     MNOTE 8,'Options &L_OPTIONS are mutually exclusive'\n.PAST_MUTEX ANOP\n.*\n.* Build the option-bytes that will be used.\n.*\n&O_VALUE       SETA  0\n&O2_VALUE      SETA  0\n&O3_VALUE      SETA  0\n&O4_VALUE      SETA  0\n&O_VALUE       SETA  &O_VALUE+(&O_SET(1)*(&ES_OC_STDMNT))\n&O_VALUE       SETA  &O_VALUE+(&O_SET(2)*(&ES_OC_NOSTDMNT))\n&L_OPTIONS     SETC  '=AL1(&O_VALUE,&O2_VALUE,&O3_VALUE,&O4_VALUE)'\n               AGO   .PAST_OPTIONS\n.PAST_OPTIONS  ANOP\n         ##PLIST START\n         ##PLIST PARM,&#_IDTKN,&ES_START,&#_IDESVA\n         AIF     ('&L_OPTIONS' NE '').OPTPRM\n         AIF     ('&EXITINFO' NE '').XIPRM\n         AIF     ('&MNT'      EQ '').CALLX\n         ##PLIST PARM,&MNT\n         AGO     .CALLX\n.XIPRM   ##PLIST PARM,&MNT,&EXITINFO\n         AGO     .CALLX\n.OPTPRM  ##PLIST PARM,&MNT,&EXITINFO,&L_OPTIONS\n.NO_OPTIONS ANOP\n.CALLX   ##PLIST END,VL\n         CALLX   &#_IDEPA                | Invoke Environment Support.\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   ES_TERMINATE                                               *\n* Purpose: Generate code to terminate an environment support session. *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         ES_TERMINATE &ID=,&SPEPA=,&SPTOKEN=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN\n         GBLA  &ES_TERMINATE              SETC in open code.\n.*\n.* Obtain service processor ID values and terminate env. sup.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +\n               ID=&ID,IDMAC=(ES_ID),SPEPA=&SPEPA,SPTOKEN=&SPTOKEN\n         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT\n         CALLX &#_IDEPA,(&#_IDTKN,&ES_TERMINATE),VL\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   ES_OBTAIN_STORAGE                                          *\n* Purpose: Generate code to obtain a new piece of storage.            *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         ES_OBTAIN_STORAGE &ID=,&SPEPA=,&SPTOKEN=,                     +\n               &SIZE=,&SUBPOOL=,&BOUNDARY=,&LOCATION=,&ADDRESS=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN\n         GBLA  &ES_OBTAIN_STORAGE\n         GBLA  &ES_DOUBLEWORD_BOUNDARY,&ES_PAGE_BOUNDARY\n         GBLA  &ES_LOCATION_ANY,&ES_LOCATION_BELOW\n         LCLC  &L_SUBPOOL,&L_BOUNDARY,&L_LOCATION\n.*\n.* Obtain service processor ID values.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +\n               ID=&ID,IDMAC=(ES_ID),SPEPA=&SPEPA,SPTOKEN=&SPTOKEN\n         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT\n.*\n.* Check for the presence of required keywords.\n.*\n         AIF   (T'&SIZE NE 'O').SIZE_PR\n         MNOTE 8,'SIZE is a required keyword.'\n         MEXIT\n.SIZE_PR AIF   (T'&ADDRESS NE 'O').ADDR_PR\n         MNOTE 8,'ADDRESS is a required keyword.'\n         MEXIT\n.ADDR_PR ANOP\n.*\n.* Set up parameters for SUBPOOL, BOUNDARY, and LOCATION keywords.\n.*\n&L_SUBPOOL    SETC '&SUBPOOL'\n              AIF ('&SUBPOOL' NE '').PAST_SP\n&L_SUBPOOL    SETC '0'\n.PAST_SP      ANOP\n              AIF ('&BOUNDARY' EQ '').BOUND_DOUBLE\n              AIF ('&BOUNDARY' EQ 'DOUBLEWORD').BOUND_DOUBLE\n              AIF ('&BOUNDARY' EQ 'PAGE').BOUND_PAGE\n              MNOTE 8,'BOUNDARY must be either DOUBLEWORD or PAGE.'\n              MEXIT\n.BOUND_DOUBLE ANOP\n&L_BOUNDARY   SETC '&ES_DOUBLEWORD_BOUNDARY'\n              AGO  .PAST_BOUND\n.BOUND_PAGE   ANOP\n&L_BOUNDARY   SETC '&ES_PAGE_BOUNDARY'\n.PAST_BOUND   ANOP\n              AIF ('&LOCATION' EQ '').LOC_ANY\n              AIF ('&LOCATION' EQ 'ANY').LOC_ANY\n              AIF ('&LOCATION' EQ 'BELOW').LOC_BELOW\n              MNOTE 8,'LOCATION must be either ANY or BELOW.'\n              MEXIT\n.LOC_ANY      ANOP\n&L_LOCATION   SETC '&ES_LOCATION_ANY'\n              AGO  .PAST_LOC\n.LOC_BELOW    ANOP\n&L_LOCATION   SETC '&ES_LOCATION_BELOW'\n.PAST_LOC    ANOP\n.*\n.* Generate the CALLX to obtain storage.\n.*\n         CALLX &#_IDEPA,(&#_IDTKN,&ES_OBTAIN_STORAGE,&SIZE,            +\n               &L_SUBPOOL,&L_BOUNDARY,&L_LOCATION,&ADDRESS),VL\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   ES_RELEASE_STORAGE                                         *\n* Purpose: Generate code to release a piece of storage.               *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         ES_RELEASE_STORAGE &ID=,&SPEPA=,&SPTOKEN=,                    +\n               &SIZE=,&SUBPOOL=,&ADDRESS=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN\n         GBLA  &ES_RELEASE_STORAGE\n         LCLC  &L_SUBPOOL\n.*\n.* Obtain service processor ID values.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +\n               ID=&ID,IDMAC=(ES_ID),SPEPA=&SPEPA,SPTOKEN=&SPTOKEN\n         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT\n.*\n.* Check for the presence of required keywords.\n.*\n         AIF   (T'&SIZE NE 'O').SIZE_PR\n         MNOTE 8,'SIZE is a required keyword.'\n         MEXIT\n.SIZE_PR AIF   (T'&ADDRESS NE 'O').ADDR_PR\n         MNOTE 8,'ADDRESS is a required keyword.'\n         MEXIT\n.ADDR_PR ANOP\n.*\n.* Set up the parameter for the SUBPOOL keyword.\n.*\n&L_SUBPOOL    SETC '&SUBPOOL'\n              AIF ('&SUBPOOL' NE '').PAST_SP\n&L_SUBPOOL    SETC '0'\n.PAST_SP      ANOP\n.*\n.* Generate the CALLX to release storage.\n.*\n         CALLX &#_IDEPA,(&#_IDTKN,&ES_RELEASE_STORAGE,&SIZE,           +\n               &L_SUBPOOL,&ADDRESS),VL\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   ES_LOAD_MODULE                                             *\n* Purpose: Generate the environment support call to load a module.    *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         ES_LOAD_MODULE &ID=,&SPEPA=,&SPTOKEN=,                        +\n               &SPID=,&EPNAME=,&EPA=,&TYPE=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN\n         GBLA  &ES_LOAD_MODULE\n         GBLA  &ES_LM_STANDARD,&ES_LM_MNT_ONLY,&ES_LM_NO_LOAD\n         LCLC  &L_EPA,&L_TKN,&L_TYPE\n.*\n.* Obtain service processor ID values.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +\n               ID=&ID,IDMAC=(ES_ID),SPEPA=&SPEPA,SPTOKEN=&SPTOKEN\n         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT\n&L_EPA   SETC '&#_IDEPA'     | Save Env. Sup. EPA in local variable.\n&L_TKN   SETC '&#_IDTKN'     | Save Env. Sup. TOKEN in local variable.\n.*\n.* Obtain ID values for service processor being loaded.\n.*\n         SRV##ID GET,REQUIRED=(SPEPNAME,SPEPA),                        +\n               ID=&SPID.,SPEPNAME=&EPNAME.,SPEPA=&EPA.\n         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT\n.*\n.* Generate the CALLX to load a module.\n.*\n         ##PLIST START\n         ##PLIST PARM,&L_TKN,&ES_LOAD_MODULE\n         ##PLIST PARM,&#_IDEPN,&#_IDEPA\n         AIF   ('&TYPE' EQ '').PAST_TYPE\n         AIF   ('&TYPE' EQ 'STANDARD').TYPE_STD\n         AIF   ('&TYPE' EQ 'MNT_ONLY').TYPE_MNT\n         AIF   ('&TYPE' EQ 'NO_LOAD').TYPE_NOLD\n         MNOTE 8,'Invalid value for TYPE; must be STANDARD, MNT_ONLY, o+\n               r NO_LOAD'\n         MEXIT\n.TYPE_STD  ##PLIST PARM,&ES_LM_STANDARD\n           AGO     .PAST_TYPE\n.TYPE_MNT  ##PLIST PARM,&ES_LM_MNT_ONLY\n           AGO     .PAST_TYPE\n.TYPE_NOLD ##PLIST PARM,&ES_LM_NO_LOAD\n.PAST_TYPE ANOP\n           ##PLIST END,VL\n           CALLX   &L_EPA\n.MEXIT     MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   ES_UNLOAD_MODULE                                           *\n* Purpose: Generate the environment support call to load a module.    *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         ES_UNLOAD_MODULE &ID=,&SPEPA=,&SPTOKEN=,                      +\n               &SPID=,&EPNAME=,&EPA=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN\n         GBLA  &ES_UNLOAD_MODULE\n         LCLC  &L_EPA,&L_TKN\n.*\n.* Obtain service processor ID values.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +\n               ID=&ID,IDMAC=(ES_ID),SPEPA=&SPEPA,SPTOKEN=&SPTOKEN\n         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT\n&L_EPA   SETC '&#_IDEPA'     | Save Env. Sup. EPA in local variable.\n&L_TKN   SETC '&#_IDTKN'     | Save Env. Sup. TOKEN in local variable.\n.*\n.* Obtain ID values for service processor (or module) being loaded.\n.*\n         SRV##ID GET,REQUIRED=(SPEPNAME),                              +\n               ID=&SPID.,SPEPNAME=&EPNAME.,SPEPA=&EPA.\n         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT\n.*\n.* Generate the CALLX to unload a module.\n.*\n         AIF   ('&#_IDEPA' NE '').CALL2\n         CALLX &L_EPA,(&L_TKN,&ES_UNLOAD_MODULE,&#_IDEPN),VL\n         MEXIT\n.CALL2   CALLX &L_EPA,(&L_TKN,&ES_UNLOAD_MODULE,&#_IDEPN,&#_IDEPA),VL\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   ES_DISPLAY_MESSAGE                                         *\n* Purpose: Generate code to display a message.                        *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         ES_DISPLAY_MESSAGE &ID=,&SPEPA=,&SPTOKEN=,&MESSAGE=\n         GBLA  &ES_DISPLAY_MESSAGE SETC in open code.\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN\n         LCLC  &L_ADDR,&L_LEN\n         LCLA  &I,&L\n.*\n.* Obtain service processor ID values.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +\n               ID=&ID,IDMAC=(ES_ID),SPEPA=&SPEPA,SPTOKEN=&SPTOKEN\n         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT\n.*\n.* Decode the MESSAGE= keyword to get an address and length.\n.*\n              AIF ('&MESSAGE' EQ '').NO_MESSAGE\n              AIF (N'&MESSAGE EQ 2).MSG_TAGLEN\n              AIF (N'&MESSAGE EQ 1).MSG_TAGONLY\n              MNOTE 8,'Too many subparameters for MESSAGE keyword.'\n              MEXIT\n.MSG_TAGLEN   ANOP\n&L_ADDR       SETC '&MESSAGE(1)'          | Set addr.\n&L_LEN        SETC '&MESSAGE(2)'          | Set len.\n              AGO  .PAST_MESSAGE          |\n.MSG_TAGONLY  ANOP\n              AIF ('&MESSAGE'(1,1) EQ '''').MSG_LITERAL\n&L_ADDR       SETC '&MESSAGE'             | Set addr to tag_name.\n&L_LEN        SETC '=A(L''&MESSAGE)'      | Set len to L'tag_name.\n              AGO  .PAST_MESSAGE          |\n.MSG_LITERAL  ANOP                        |\n&L_ADDR       SETC '&MESSAGE'             | Set addr to actual literal.\n&L            SETA 0                      | Length counter = 0.\n&I            SETA 2                      | Index counter -> past '.\n.MSG_LOOP     AIF  (&I GE K'&L_ADDR).MSG_ELOOP       Loop over message.\n              AIF  ('&L_ADDR'(&I,1) NE '''').MSG_TXT If doubled quotes.\n&I            SETA &I+1                   |            Advance past '.\n.MSG_TXT      ANOP                        |          EndIf.\n&L            SETA &L+1                   |   Add one to length.\n&I            SETA &I+1                   |   Advance to next position.\n              AGO  .MSG_LOOP              | End of counting loop.\n.MSG_ELOOP    ANOP                        |\n&L_LEN        SETC '&L'                   | Set length parameter.\n              AGO  .PAST_MESSAGE\n.NO_MESSAGE   MNOTE 8,'MESSAGE is a required keyword.'\n              MEXIT\n.PAST_MESSAGE ANOP\n.*\n.* Generate the DISPLAY_MESSAGE call statement.\n.*\n           CALLX &#_IDEPA,(&#_IDTKN,&ES_DISPLAY_MESSAGE,&L_ADDR,       +\n               &L_LEN),VL\n.MEXIT     MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   ES_SAVE_DEBUG_INFO                                         *\n* Purpose: Generate code to save debugging information.               *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         ES_SAVE_DEBUG_INFO &ID=,&SPEPA=,&SPTOKEN=,                    +\n               &GDI=,&TEXT=,&HEX=,&LABEL=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN\n         GBLA  &ES_DEBUG_ID_GDI,&ES_DEBUG_ID_TEXT,&ES_DEBUG_ID_HEX\n         GBLA  &ES_SAVE_DEBUG_INFO SETC in open code.\n         LCLC  &L_DEBUG_ID,&L_ADDR,&L_LEN,&L_LABEL,&L_LABEL_LEN\n         LCLA  &I,&L\n         LCLB  &S_GDI,&S_TEXT,&S_HEX\n.*\n.* Obtain service processor ID values.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +\n               ID=&ID,IDMAC=(ES_ID),SPEPA=&SPEPA,SPTOKEN=&SPTOKEN\n         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT\n.*\n.* Check optional LABEL keyword.\n.*\n&L_LABEL     SETC ''\n&L_LABEL_LEN SETC ''\n         AIF ('&LABEL' EQ '').PAST_LABEL\n              AIF ('&LABEL'(1,1) EQ '''').LBL_LITERAL\n              AIF (N'&LABEL EQ 1).LBL_TAGONLY\n              AIF (N'&LABEL EQ 2).LBL_TAGLEN\n              MNOTE 8,'Too many subparameters for LABEL keyword.'\n              MEXIT\n.LBL_TAGLEN   ANOP\n&L_LABEL      SETC '&LABEL(1)'            | Set addr.\n&L_LABEL_LEN  SETC '&LABEL(2)'            | Set len.\n              AGO  .PAST_LABEL            |\n.LBL_TAGONLY  ANOP\n&L_LABEL      SETC '&LABEL'               | Set addr to tag_name.\n&L_LABEL_LEN  SETC '=A(L''&LABEL)'        | Set len to L'tag_name.\n              AGO  .PAST_LABEL            |\n.LBL_LITERAL  ANOP                        |\n&L_LABEL      SETC '&LABEL'               | Set addr to actual literal.\n&L            SETA 0                      | Length counter = 0.\n&I            SETA 2                      | Index counter -> past '.\n.LBL_LOOP     AIF  (&I GE K'&L_LABEL).LBL_ELOOP      Loop over TEXT.\n              AIF  ('&L_LABEL'(&I,1) NE '''').LBL_LBL If doubled quotes\n&I            SETA &I+1                   |            Advance past '.\n.LBL_LBL      ANOP                        |          EndIf.\n&L            SETA &L+1                   |   Add one to length.\n&I            SETA &I+1                   |   Advance to next position.\n              AGO  .LBL_LOOP              | End of counting loop.\n.LBL_ELOOP    ANOP                        |\n&L_LABEL_LEN  SETC '&L'                   | Set length parameter.\n.PAST_LABEL   ANOP\n.*\n.* Check keywords GDI, TEXT, and HEX: exactly one must be specified.\n.*\n&S_GDI   SETB  ('&GDI'  NE '')      TRUE if GDI was specified.\n&S_TEXT  SETB  ('&TEXT' NE '')      TRUE if TEXT was specified.\n&S_HEX   SETB  ('&HEX'  NE '')      TRUE if HEX was specified.\n         AIF   (NOT (&S_GDI OR &S_TEXT OR &S_HEX)).K_MISS\n         AIF   (&S_GDI  AND (&S_TEXT OR &S_HEX)).MTX_ERR\n         AIF   (&S_TEXT AND (&S_GDI  OR &S_HEX)).MTX_ERR\n         AIF   (&S_HEX  AND (&S_GDI  OR &S_TEXT)).MTX_ERR\n         AGO   .PASTKWD\n.K_MISS  MNOTE 8,'Keyword GDI, TEXT or HEX must be specified.'\n         MEXIT\n.MTX_ERR MNOTE 8,'Keywords GDI, TEXT, and HEX are mutually exclusive.'\n         MEXIT\n.PASTKWD ANOP\n.*\n.* Decode the GDI/TEXT/HEX keyword to get an address and length.\n.*\n         AIF (&S_GDI).USE_GDI\n         AIF (&S_TEXT).USE_TEXT\n         AIF (&S_HEX).USE_HEX\n         MNOTE 12,'Internal error in ES_SAVE_DEBUG_INFO.'\n              MEXIT\n.USE_GDI      ANOP\n&L_DEBUG_ID   SETC '&ES_DEBUG_ID_GDI'\n&L_ADDR       SETC '&GDI'\n              AGO  .CALLX\n.USE_TEXT     ANOP\n&L_DEBUG_ID   SETC '&ES_DEBUG_ID_TEXT'\n              AIF ('&TEXT'(1,1) EQ '''').TXT_LITERAL\n              AIF (N'&TEXT EQ 1).TXT_TAGONLY\n              AIF (N'&TEXT EQ 2).TXT_TAGLEN\n              MNOTE 8,'Too many subparameters for TEXT keyword.'\n              MEXIT\n.TXT_TAGLEN   ANOP\n&L_ADDR       SETC '&TEXT(1)'             | Set addr.\n&L_LEN        SETC '&TEXT(2)'             | Set len.\n              AGO  .PAST_TEXT             |\n.TXT_TAGONLY  ANOP\n&L_ADDR       SETC '&TEXT'                | Set addr to tag_name.\n&L_LEN        SETC '=A(L''&TEXT)'         | Set len to L'tag_name.\n              AGO  .PAST_TEXT             |\n.TXT_LITERAL  ANOP                        |\n&L_ADDR       SETC '&TEXT'                | Set addr to actual literal.\n&L            SETA 0                      | Length counter = 0.\n&I            SETA 2                      | Index counter -> past '.\n.TXT_LOOP     AIF  (&I GE K'&L_ADDR).TXT_ELOOP       Loop over TEXT.\n              AIF  ('&L_ADDR'(&I,1) NE '''').TXT_TXT If doubled quotes.\n&I            SETA &I+1                   |            Advance past '.\n.TXT_TXT      ANOP                        |          EndIf.\n&L            SETA &L+1                   |   Add one to length.\n&I            SETA &I+1                   |   Advance to next position.\n              AGO  .TXT_LOOP              | End of counting loop.\n.TXT_ELOOP    ANOP                        |\n&L_LEN        SETC '&L'                   | Set length parameter.\n.PAST_TEXT    AGO  .CALLX\n.USE_HEX      ANOP\n&L_DEBUG_ID   SETC '&ES_DEBUG_ID_HEX'\n              AIF (N'&HEX EQ 1).HEX_TAGONLY\n              AIF (N'&HEX EQ 2).HEX_TAGLEN\n              MNOTE 8,'Too many subparameters for HEX keyword.'\n              MEXIT\n.HEX_TAGLEN   ANOP\n&L_ADDR       SETC '&HEX(1)'              | Set addr.\n&L_LEN        SETC '&HEX(2)'              | Set len.\n              AGO  .PAST_HEX              |\n.HEX_TAGONLY  ANOP\n&L_ADDR       SETC '&HEX'                 | Set addr to tag_name.\n&L_LEN        SETC '=A(L''&HEX)'          | Set len to L'tag_name.\n.PAST_HEX     AGO  .CALLX\n.*\n.* Generate the SAVE_DEBUG_INFO call statement.\n.*\n.CALLX     ##PLIST START\n           ##PLIST PARM,&#_IDTKN,&ES_SAVE_DEBUG_INFO,&L_DEBUG_ID\n           ##PLIST PARM,&L_ADDR\n           AIF     ('&L_LABEL_LEN' NE '').PARM3\n           AIF     ('&L_LABEL'     NE '').PARM2\n           AIF     ('&L_LEN'       NE '').PARM1\n           AGO     .PARM_END\n.PARM1     ##PLIST PARM,&L_LEN\n           AGO     .PARM_END\n.PARM2     ##PLIST PARM,&L_LEN,&L_LABEL\n           AGO     .PARM_END\n.PARM3     ##PLIST PARM,&L_LEN,&L_LABEL,&L_LABEL_LEN\n.PARM_END  ##PLIST END,VL\n           CALLX   &#_IDEPA\n.MEXIT     MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   ES_DISPLAY_DEBUG_INFO                                      *\n* Purpose: Generate code to display debugging information.            *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         ES_DISPLAY_DEBUG_INFO &ID=,&SPEPA=,&SPTOKEN=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN\n         GBLA  &ES_DISPLAY_DEBUG_INFO SETC in open code.\n.*\n.* Obtain service processor ID values and generate the CALLX.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +\n               ID=&ID,IDMAC=(ES_ID),SPEPA=&SPEPA,SPTOKEN=&SPTOKEN\n         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT\n         CALLX &#_IDEPA,(&#_IDTKN,&ES_DISPLAY_DEBUG_INFO),VL\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   ES_DISPLAY_DEBUG_INFO_AND_ABEND                            *\n* Purpose: Generate code to display debugging information.            *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         ES_DISPLAY_DEBUG_INFO_AND_ABEND &ID=,&SPEPA=,&SPTOKEN=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN\n         GBLA  &ES_DISPLAY_DEBUG_INFO_AND_ABEND SETC in open code.\n.*\n.* Obtain service processor ID values and generate the CALLX.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +\n               ID=&ID,IDMAC=(ES_ID),SPEPA=&SPEPA,SPTOKEN=&SPTOKEN\n         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT\n         CALLX &#_IDEPA,(&#_IDTKN,&ES_DISPLAY_DEBUG_INFO_AND_ABEND),VL\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   ES_CLEAR_DEBUG_INFO                                        *\n* Purpose: Generate code to display debugging information.            *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         ES_CLEAR_DEBUG_INFO &ID=,&SPEPA=,&SPTOKEN=,&ACTION=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN\n         GBLA  &ES_CLEAR_DEBUG_INFO SETC in open code.\n         GBLA  &ES_CDI_EXECUTE,&ES_CDI_INHIBIT,&ES_CDI_ENABLE\n         LCLC  &L_ACTION\n.*\n.* Obtain service processor ID values and generate the CALLX.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +\n               ID=&ID,IDMAC=(ES_ID),SPEPA=&SPEPA,SPTOKEN=&SPTOKEN\n         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT\n.*\n.* Process the optional ACTION keyword.\n.*\n             AIF  ('&ACTION' EQ 'EXECUTE').ACTNX\n             AIF  ('&ACTION' EQ 'INHIBIT').ACTNI\n             AIF  ('&ACTION' EQ 'ENABLE').ACTNE\n&L_ACTION    SETC '&ACTION'\n             AGO  .PAST_ACTION\n.ACTNX       ANOP\n&L_ACTION    SETC '&ES_CDI_EXECUTE'\n             AGO  .PAST_ACTION\n.ACTNI       ANOP\n&L_ACTION    SETC '&ES_CDI_INHIBIT'\n             AGO  .PAST_ACTION\n.ACTNE       ANOP\n&L_ACTION    SETC '&ES_CDI_ENABLE'\n.PAST_ACTION ANOP\n.*\n.* Generate the subroutine call to ES_CLEAR_DEBUG_INFO\n.*\n         ##PLIST START\n         ##PLIST PARM,&#_IDTKN,&ES_CLEAR_DEBUG_INFO\n         AIF     ('&ACTION' EQ '').CALLX\n         ##PLIST PARM,&L_ACTION\n.CALLX   ##PLIST END,VL\n         CALLX   &#_IDEPA\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   ES_GET_USERID                                              *\n* Purpose: Generate code to extract the RACF Userid under which the   *\n*          current address space is running.                          *\n*                                                                     *\n*          Keyword                    Description                     *\n*          --------  -----------------------------------------------  *\n*          USERID    Seven character RACF Userid.                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         ES_GET_USERID &ID=,&SPEPA=,&SPTOKEN=,&USERID=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN\n         GBLA  &ES_GET_USERID SETC in open code.\n.*\n.* Obtain service processor ID values and generate the CALLX.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +\n               ID=&ID,IDMAC=(ES_ID),SPEPA=&SPEPA,SPTOKEN=&SPTOKEN\n         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT\n         AIF  ('&USERID' NE '').CALL1\n         MNOTE 8,'USERID is a required keyword.'\n         MEXIT\n.CALL1   CALLX &#_IDEPA,(&#_IDTKN,&ES_GET_USERID,&USERID.),VL\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   ES_GET_GROUP                                               *\n* Purpose: Generate code to extract the RACF Group name under which   *\n*          the current address space is running.                      *\n*                                                                     *\n*          Keyword                    Description                     *\n*          --------  -----------------------------------------------  *\n*          GROUP     Eight character RACF Group name.                 *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         ES_GET_GROUP &ID=,&SPEPA=,&SPTOKEN=,&GROUP=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN\n         GBLA  &ES_GET_GROUP SETC in open code.\n.*\n.* Obtain service processor ID values and generate the CALLX.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +\n               ID=&ID,IDMAC=(ES_ID),SPEPA=&SPEPA,SPTOKEN=&SPTOKEN\n         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT\n         AIF  ('&GROUP' NE '').CALL1\n         MNOTE 8,'GROUP is a required keyword.'\n         MEXIT\n.CALL1   CALLX &#_IDEPA,(&#_IDTKN,&ES_GET_GROUP,&GROUP.),VL\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   ES_GET_CACCT                                               *\n* Purpose: Generate code to extract this address space's CACCT.       *\n*                                                                     *\n*          Keyword                    Description                     *\n*          --------  -----------------------------------------------  *\n*          CACCT     Eight character Computer Center Account number.  *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         ES_GET_CACCT &ID=,&SPEPA=,&SPTOKEN=,&CACCT=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN\n         GBLA  &ES_GET_CACCT SETC in open code.\n.*\n.* Obtain service processor ID values and generate the CALLX.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +\n               ID=&ID,IDMAC=(ES_ID),SPEPA=&SPEPA,SPTOKEN=&SPTOKEN\n         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT\n         AIF  ('&CACCT' NE '').CALL1\n         MNOTE 8,'CACCT is a required keyword.'\n         MEXIT\n.CALL1   CALLX &#_IDEPA,(&#_IDTKN,&ES_GET_CACCT,&CACCT.),VL\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   ES_GET_SYSRES_VOLUME_NAME                                  *\n* Purpose: Generate code to obtain the current Sysres volume's VOLSER *\n*                                                                     *\n*          Keyword                    Description                     *\n*          --------  -----------------------------------------------  *\n*          VOLSER    Six character volume serial name.                *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         ES_GET_SYSRES_VOLUME_NAME &ID=,&SPEPA=,&SPTOKEN=,&VOLSER=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN\n         GBLA  &ES_GET_SYSRES_VOLUME_NAME SETC in open code.\n.*\n.* Obtain service processor ID values and generate the CALLX.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +\n               ID=&ID,IDMAC=(ES_ID),SPEPA=&SPEPA,SPTOKEN=&SPTOKEN\n         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT\n         AIF  ('&VOLSER' NE '').CALL1\n         MNOTE 8,'VOLSER is a required keyword.'\n         MEXIT\n.CALL1   CALLX &#_IDEPA,(&#_IDTKN,&ES_GET_SYSRES_VOLUME_NAME,&VOLSER.),+\n               VL\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   ES_GET_TERMINAL_NAME                                       *\n* Purpose: Generate code to obtain this user's terminal name.         *\n*                                                                     *\n*          Keyword                    Description                     *\n*          --------  -----------------------------------------------  *\n*          NAME      Eight character terminal name.                   *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         ES_GET_TERMINAL_NAME &ID=,&SPEPA=,&SPTOKEN=,&NAME=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN\n         GBLA  &ES_GET_TERMINAL_NAME SETC in open code.\n.*\n.* Obtain service processor ID values and generate the CALLX.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +\n               ID=&ID,IDMAC=(ES_ID),SPEPA=&SPEPA,SPTOKEN=&SPTOKEN\n         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT\n         AIF  ('&NAME' NE '').CALL1\n         MNOTE 8,'NAME is a required keyword.'\n         MEXIT\n.CALL1   CALLX &#_IDEPA,(&#_IDTKN,&ES_GET_TERMINAL_NAME,&NAME.),VL\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   ES_GET_JOBCARD_NAME_FIELD                                  *\n* Purpose: Generate code to obtain the 20-character programmer name   *\n*          field from this address space's JOB card.                  *\n*                                                                     *\n*          Keyword                    Description                     *\n*          --------  -----------------------------------------------  *\n*          NAME      Twenty character programmer name field.          *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         ES_GET_JOBCARD_NAME_FIELD &ID=,&SPEPA=,&SPTOKEN=,&NAME=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN\n         GBLA  &ES_GET_JOBCARD_NAME_FIELD SETC in open code.\n.*\n.* Obtain service processor ID values and generate the CALLX.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +\n               ID=&ID,IDMAC=(ES_ID),SPEPA=&SPEPA,SPTOKEN=&SPTOKEN\n         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT\n         AIF  ('&NAME' NE '').CALL1\n         MNOTE 8,'NAME is a required keyword.'\n         MEXIT\n.CALL1   CALLX &#_IDEPA,(&#_IDTKN,&ES_GET_JOBCARD_NAME_FIELD,&NAME.),VL\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   ES_GET_JOBCARD_ROOM                                        *\n* Purpose: Generate code to extract this address space's ROOM.        *\n*                                                                     *\n*          Keyword                    Description                     *\n*          --------  -----------------------------------------------  *\n*          ROOM      Four character room number from JOB card.        *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         ES_GET_JOBCARD_ROOM &ID=,&SPEPA=,&SPTOKEN=,&ROOM=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN\n         GBLA  &ES_GET_JOBCARD_ROOM SETC in open code.\n.*\n.* Obtain service processor ID values and generate the CALLX.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +\n               ID=&ID,IDMAC=(ES_ID),SPEPA=&SPEPA,SPTOKEN=&SPTOKEN\n         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT\n         AIF  ('&ROOM' NE '').CALL1\n         MNOTE 8,'ROOM is a required keyword.'\n         MEXIT\n.CALL1   CALLX &#_IDEPA,(&#_IDTKN,&ES_GET_JOBCARD_ROOM,&ROOM.),VL\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   ES_GET_TSU_STC_OR_JOB                                      *\n* Purpose: Generate code to extract this address space's type.        *\n*                                                                     *\n*          Keyword                    Description                     *\n*          --------  -----------------------------------------------  *\n*          TYPE      Three character indicator of address space type: *\n*                    'TSU' - TSO Session.                             *\n*                    'JOB' - Batch job.                               *\n*                    'STC' - Started Task.                            *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         ES_GET_TSU_STC_OR_JOB &ID=,&SPEPA=,&SPTOKEN=,&TYPE=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN\n         GBLA  &ES_GET_TSU_STC_OR_JOB SETC in open code.\n.*\n.* Obtain service processor ID values and generate the CALLX.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +\n               ID=&ID,IDMAC=(ES_ID),SPEPA=&SPEPA,SPTOKEN=&SPTOKEN\n         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT\n         AIF  ('&TYPE' NE '').CALL1\n         MNOTE 8,'TYPE is a required keyword.'\n         MEXIT\n.CALL1   CALLX &#_IDEPA,(&#_IDTKN,&ES_GET_TSU_STC_OR_JOB,&TYPE.),VL\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   ES_GET_JOBID                                               *\n* Purpose: Generate code to extract this job's job identifier.        *\n*                                                                     *\n*          Keyword                    Description                     *\n*          --------  -----------------------------------------------  *\n*          JOBID     Location for eight character job identifier.     *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         ES_GET_JOBID &ID=,&SPEPA=,&SPTOKEN=,&JOBID=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN\n         GBLA  &ES_GET_JOBID SETC in open code.\n.*\n.* Obtain service processor ID values and generate the CALLX.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +\n               ID=&ID,IDMAC=(ES_ID),SPEPA=&SPEPA,SPTOKEN=&SPTOKEN\n         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT\n         AIF  ('&JOBID' NE '').CALL1\n         MNOTE 8,'JOBID is a required keyword.'\n         MEXIT\n.CALL1   CALLX &#_IDEPA,(&#_IDTKN,&ES_GET_JOBID,&JOBID.),VL\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   ES_GET_DEFAULT_DESTINATION                                 *\n* Purpose: Generate code to obtain this user's default printer dest.  *\n*                                                                     *\n*          Keyword                    Description                     *\n*          --------  -----------------------------------------------  *\n*          DEST      Location for eight character printer destination *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         ES_GET_DEFAULT_DESTINATION &ID=,&SPEPA=,&SPTOKEN=,&DEST=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN\n         GBLA  &ES_GET_DEFAULT_DESTINATION SETC in open code.\n.*\n.* Obtain service processor ID values and generate the CALLX.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +\n               ID=&ID,IDMAC=(ES_ID),SPEPA=&SPEPA,SPTOKEN=&SPTOKEN\n         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT\n         AIF  ('&DEST' NE '').CALL1\n         MNOTE 8,'DEST is a required keyword.'\n         MEXIT\n.CALL1   CALLX &#_IDEPA,(&#_IDTKN,&ES_GET_DEFAULT_DESTINATION,&DEST.), +\n               VL\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   ES_GET_PREFIX                                              *\n* Purpose: Generate code to extract this user's DSNAME prefix.        *\n*                                                                     *\n*          Keyword                     Description                    *\n*          --------   ----------------------------------------------- *\n*          PREFIX     Location for eight character TSO dsname prefix. *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         ES_GET_PREFIX &ID=,&SPEPA=,&SPTOKEN=,&PREFIX=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN\n         GBLA  &ES_GET_PREFIX SETC in open code.\n.*\n.* Obtain service processor ID values and generate the CALLX.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +\n               ID=&ID,IDMAC=(ES_ID),SPEPA=&SPEPA,SPTOKEN=&SPTOKEN\n         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT\n         AIF  ('&PREFIX' NE '').CALL1\n         MNOTE 8,'PREFIX is a required keyword.'\n         MEXIT\n.CALL1   CALLX &#_IDEPA,(&#_IDTKN,&ES_GET_PREFIX,&PREFIX.),VL\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   ES_GET_TIME                                                *\n* Purpose: Generate code to obtain current time and date. All of the  *\n*          following keywords are optional.                           *\n*                                                                     *\n*          Keyword                     Description                    *\n*          --------   ----------------------------------------------- *\n*          TIME       Location for time of day in .01 second units.   *\n*          DATE       Location for date in packed decimal CCYYDDDs.   *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         ES_GET_TIME &ID=,&SPEPA=,&SPTOKEN=,&TIME=,&DATE=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN\n         GBLA  &ES_GET_TIME SETC in open code.\n.*\n.* Obtain service processor ID values and generate the CALLX.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +\n               ID=&ID,IDMAC=(ES_ID),SPEPA=&SPEPA,SPTOKEN=&SPTOKEN\n         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT\n.CALL2   CALLX &#_IDEPA,(&#_IDTKN,&ES_GET_TIME,&TIME.,&DATE.),VL\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   ES_GET_GMT_TIME                                            *\n* Purpose: Generate code to obtain current time and date. All of the  *\n*          following keywords are optional.                           *\n*                                                                     *\n*          Keyword                     Description                    *\n*          --------   ----------------------------------------------- *\n*          TIME       Location for time of day in .01 second units.   *\n*          DATE       Location for date in packed decimal CCYYDDDs.   *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         ES_GET_GMT_TIME &ID=,&SPEPA=,&SPTOKEN=,&TIME=,&DATE=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN\n         GBLA  &ES_GET_GMT_TIME SETC in open code.\n.*\n.* Obtain service processor ID values and generate the CALLX.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +\n               ID=&ID,IDMAC=(ES_ID),SPEPA=&SPEPA,SPTOKEN=&SPTOKEN\n         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT\n.CALL2   CALLX &#_IDEPA,(&#_IDTKN,&ES_GET_GMT_TIME,&TIME.,&DATE.),VL\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   ES_GET_FORMATTED_TIME                                      *\n* Purpose: Generate code to obtain current time and date. All of the  *\n*          following keywords are optional.                           *\n*                                                                     *\n*          Keyword                     Description                    *\n*          --------   ----------------------------------------------- *\n*          TIME       Specifies a location for time as HH:MM:SS.TH    *\n*          GREGORIAN  Specifies a location for date as MM/DD/YY       *\n*          JULIAN     Specifies a location for date as CCYY.DDD       *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         ES_GET_FORMATTED_TIME &ID=,&SPEPA=,&SPTOKEN=,                 +\n               &TIME=,&GREGORIAN=,&JULIAN=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN\n         GBLA  &ES_GET_FORMATTED_TIME SETC in open code.\n.*\n.* Obtain service processor ID values and generate the CALLX.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +\n               ID=&ID,IDMAC=(ES_ID),SPEPA=&SPEPA,SPTOKEN=&SPTOKEN\n         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT\n         AIF  ('&JULIAN' EQ '' AND '&GREGORIAN' EQ '').CALL3\n         AIF  ('&JULIAN' EQ '').CALL2\n.CALL1   CALLX &#_IDEPA,(&#_IDTKN,&ES_GET_FORMATTED_TIME,&TIME.,       +\n               &GREGORIAN.,&JULIAN),VL\n         MEXIT\n.CALL2   CALLX &#_IDEPA,(&#_IDTKN,&ES_GET_FORMATTED_TIME,&TIME.,       +\n               &GREGORIAN.),VL\n         MEXIT\n.CALL3   CALLX &#_IDEPA,(&#_IDTKN,&ES_GET_FORMATTED_TIME,&TIME.),VL\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   ES_PARMLIST                                                *\n* Purpose: Map environment support's parameter list.                  *\n*---------------------------------------------------------------------*\n         MACRO\n         ES_PARMLIST\nPARMLIST DSECT ,     PARAMETER LIST   |\nPRMAPWA  DS    A     ADDRESS OF PWA ANCHOR\nPRMAFNCD DS    A     ADDRESS OF FUNCTION CODE\n         SPACE 1                      |\n*---------------------------------------------------------------------*\n*  REST OF PARAMETER LIST DEPENDS ON FUNCTION CODE.\n*---------------------------------------------------------------------*\n         SPACE 1                      |\nPRMFD    DS    0A    FUNCTION DEPENDENT PARMS\n         SPACE 1                      |\n*---------------------------------------------------------------------*\n*  PARAMETERS FOR FUNCTION START.\n*---------------------------------------------------------------------*\n         SPACE 1                      |\n         ORG   PRMFD                  |\nPRM1ESV  DS    A     ADDRESS OF ESV ANCHOR WORD\nPRM1MNT  DS    A     (OPTIONAL) APPLICATION SERVICE NAME TABLE\nPRM1XNFO DS    A     (OPTIONAL) Exit Information word.\nPRM1OPTS DS    A     (OPTIONAL) Options.\n         SPACE 1                      |\n*---------------------------------------------------------------------*\n*  PARAMETERS FOR FUNCTION TERMINATE.\n*---------------------------------------------------------------------*\n         SPACE 1                      |\n         ORG   PRMFD                  |\n* THERE ARE NO EXTRA PARAMETERS\n         SPACE 1                      |\n*---------------------------------------------------------------------*\n*  PARAMETERS FOR FUNCTION DISPLAY_MESSAGE\n*---------------------------------------------------------------------*\n            ORG   PRMFD               |\nPRM_DM_TEXT DS A                      | -> C'text of message'\nPRM_DM_LEN  DS F                      | -> F(length of text)\n*---------------------------------------------------------------------*\n*  PARAMETERS FOR FUNCTION OBTAIN_STORAGE.\n*---------------------------------------------------------------------*\n         SPACE 1                      |\n         ORG   PRMFD                  |\nPRMGSIZE DS    A                      | -> F(SIZE OF STORAGE)\nPRMGSP   DS    A                      | -> F(SUBPOOL NUMBER)\nPRMGBDY  DS    A                      | -> F(BOUNDARY)\nPRMGLOC  DS    A                      | -> F(LOCATION)\nPRMGADDR DS    A                      | -> F(ADDRESS RETURN AREA)\n         SPACE 1                      |\n*---------------------------------------------------------------------*\n*  PARAMETERS FOR FUNCTION RELEASE_STORAGE.\n*---------------------------------------------------------------------*\n         SPACE 1                      |\n         ORG   PRMFD                  |\nPRMFSIZE DS    A                      | -> F(SIZE OF STORAGE)\nPRMFSP   DS    A                      | -> F(SUBPOOL NUMBER)\nPRMFADDR DS    A                      | -> F(ADDRESS RETURN AREA)\n         SPACE 1                      |\n*---------------------------------------------------------------------*\n*  PARAMETERS FOR FUNCTION LOAD_MODULE.\n*---------------------------------------------------------------------*\n         SPACE 1                      |\n         ORG   PRMFD                  |\nPRMLEPNM DS    A                      | -> EP NAME\nPRMLEPA  DS    A                      | -> EP ADDRESS RETURNED FOR LOAD\nPRMLPATH DS    A                      | -> Search path criteria.\n         SPACE 1                      |\n*---------------------------------------------------------------------*\n*  PARAMETERS FOR CLEAR DEBUG INFO.\n*---------------------------------------------------------------------*\n         SPACE 1                      |\n         ORG   PRMFD                  |\nPRMCDACT DS    F                      | -> Action to perform (optional)\n         SPACE 1                      |\n*---------------------------------------------------------------------*\n*  PARAMETERS FOR SAVE DEBUG INFO.\n*---------------------------------------------------------------------*\n         SPACE 1                      |\n         ORG   PRMFD                  |\nPRMVTYPE DS    A                      | -> FULLWORD TYPE\nPRMVTD   EQU   *                      | TYPE DEPENDENT INFO\n*---------------------------------------------------------------------*\n*  TYPE DEPENDENT INFO FOR SAVE DEBUG INFO TYPE OF GENERAL DEBUG INFO.\n*---------------------------------------------------------------------*\n         ORG   PRMVTD                 |\nPRMVAGDI DS    A                      |\n*---------------------------------------------------------------------*\n*  TYPE DEPENDENT INFO FOR SAVE DEBUG INFO TYPE OF TEXT AND HEX.\n*---------------------------------------------------------------------*\n         ORG   PRMVTD                 |\nPRMVTXS  DS    A                      |\nPRMVTXSL DS    A                      |\nPRMVTXN  DS    A                      |\nPRMVTXNL DS    A                      |\n         SPACE 1                      |\n*---------------------------------------------------------------------*\n*  PARAMETER LIST FOR &ES_GET_... SERVICE PROCESSORS.\n*---------------------------------------------------------------------*\n            ORG   PRMFD                  |\nPRMAR1      DS    A     ADDRESS OF RETURN VALUE 1\nPRMAR2      DS    A     ADDRESS OF RETURN VALUE 2\nPRMAR3      DS    A     ADDRESS OF RETURN VALUE 2\n            ORG   ,                      |\nPARMLIST_L  EQU *-PARMLIST\n            MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SRVESMVS": {"ttr": 20229, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x02\\x00\\x00W\\x01\\x11)\\x9f\\x01\\x11)\\x9f\\t'\\x05}\\x05}\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@\"", "ispf": {"version": "02.00", "flags": 0, "createdate": "2011-10-26T00:00:00", "modifydate": "2011-10-26T09:27:57", "lines": 1405, "newlines": 1405, "modlines": 0, "user": "CLEMSON"}, "text": "*---------------------------------------------------------------------*\n*  Copyright 2011 by Clemson University Research Foundation           *\n*                                                                     *\n*  Licensed under the Apache License, Version 2.0 (the \"License\");    *\n*  you may not use this file except in compliance with the License.   *\n*  You may obtain a copy of the License in this library as member     *\n*  $LICENSE, or from                                                  *\n*                                                                     *\n*      http://www.apache.org/licenses/LICENSE-2.0                     *\n*                                                                     *\n*  Unless required by applicable law or agreed to in writing,         *\n*  software distributed under the License is distributed on an \"AS    *\n*  IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either    *\n*  express or implied.  See the License for the specific language     *\n*  governing permissions and limitations under the License.           *\n*---------------------------------------------------------------------*\n         COPY   SMSYMS        | Get Structured Macros symbols.\n         COPY   SRVESMAC      | Get Environment Support symbols.\n         SMLIST CONVERT=YES\nSRVESMVS title \"MVS/XA Environment Support service processor\"\n         srvmod name=srvesmvs,dates='1989, 1990, 1995'\n         gblb   &srv_clemson\n         gblc  &srv_modname\n         gblc  &srv_stdmnt\n*&srv_clemson setb 0   <-- temporarily inserted to assemble special\n*                           version for use by xsub in a non-clemson\n*                           environment. Re-assembled w/o this line\n*                           afterwards. -- mjm 2008-08-27\n*---------------------------------------------------------------------*\n*\n*  Copyright (C) Clemson University Research Foundation 1987, 1990.\n*\n*  Program     SRVESMVS\n*\n*  Abstract    This is the MVS/XA Environment Support service\n*              processor.  Its use is documented in the \"Clemson\n*              University Service Processors User's Guide and\n*              Reference\".\n*\n*  Program     Reentrant, problem key and state, standard linkage,\n*  Attributes  non-authorized, AMODE(31), RMODE(ANY)\n*\n*  Special   o The following programs are exit routines that may be\n*  Notes       replaced by applications (via an application MNT):\n*              SRVESX01 - Message issuer exit routine.\n*\n*  Change\n*  History   2011/10/20 JCB - Patch rollup for CBT tape distribution\n*\n*---------------------------------------------------------------------*\n block type=program,name=&srv_modname,amode=31,rmode=any,              $\n               options=(*srvprc,noesv,noclrdebug,long,                 $\n               (parms,vl,(count,pwa_#parms),(using,r11))),             $\n               parmmap=parmlist,subopts=(*swa,loadbase)\n*\n  l       r9,pwaaesv                | r9 -> Environment Support Vector.\n  using   esv,r9                    | Establish r9 as the ESV base reg.\n  lh      r15,=h'&es_wrong_number_of_parms' Set a tenative return-code.\n  l       r2,pwa_#parms             | Put parm count in a reg.\n*                                   |\n  l       r1,prmafncd               | r1 -> Function code.\n  l       r1,0(,r1)                 | r1 := function code.\n  caseblk reg=r1                    | Case on function code.\n  eject\n* *===================================================================*\n* *  ES_START function\n* *===================================================================*\n  case  &start                      | ES_START function:\n   leave   block=*,(ch,r2,lt,=h'3'),or,(ch,r2,gt,=h'6')\n   callsub start                    |   Start environment support.\n   slr     r15,r15                  |   Indicate success.\n  eject                             |\n* *===================================================================*\n* * ES_TERMINATE function.\n* *===================================================================*\n  case  &terminate                    | ES_TERMINATE function.\n*\n*  Unload all exit routines.\n*\n   callsub unload_module,(&es_mvs_message_exit)\n*\n*  Free the ESV/DIA storage and mark the PWA to be freed on return.\n*\n   l        r1,pwaaesv                |   R1 -> ESV/DIA storage.\n   freemain rc,lv=esvcblen+debug_area_size,a=(1)\n   smctrl   freepwa=yes               |   Mark the PWA to be freed.\n   slr      r15,r15                   |   Indicate success.\n  eject                               |\n* *===================================================================*\n* * ES_OBTAIN_STORAGE\n* *===================================================================*\n  case  &es_obtain_storage            |\n   srvclrdb                           |  reset debug info\n   leave block=*,(ch,r2,ne,=h'7')     |  Invalid number of parms.\n   l     r4,prmgsize                  |  Load r4\n   icm   r4,b'1111',0(r4)             |   with size of request.\n   l     r5,prmgsp                    |  Load r5\n   icm   r5,b'1111',0(r5)             |   with subpool.\n   l     r6,prmgbdy                   |  Load r6 with\n   icm   r6,b'1111',0(r6)             |   boundary.\n   l     r7,prmgloc                   |  Load r7 with\n   icm   r7,b'1111',0(r7)             |   location.\n   caseblk reg=r7                     |  do getmain based on location\n   case &es_location_any              |  for location any\n    if (ch,r6,eq,=y(&es_page_boundary))            if page boundary\n     getmain rc,lv=(4),sp=(5),bndry=page,loc=(any)  do this getmain\n    elseif (ch,r6,eq,=y(&es_doubleword_boundary))  else if doubleword\n     getmain rc,lv=(4),sp=(5),loc=(any)             do this getmain\n    else                              |            else if invalid\n     la    r15,&es_invalid_boundary   |             set bad return code\n    endif                             |            endif\n   case &es_location_below            |  for location below\n    if (ch,r6,eq,=y(&es_page_boundary))            if page boundary\n     getmain rc,lv=(4),sp=(5),bndry=page,loc=below  do this getmain\n    elseif (ch,r6,eq,=y(&es_doubleword_boundary))  else if doubleword\n     getmain rc,lv=(4),sp=(5),loc=below             do this getmain\n    else                              |            else if invalid\n     la    r15,&es_invalid_boundary   |             set bad return code\n    endif                             |            endif\n   case other                         |  for invalid locations\n    la    r15,&es_invalid_location    |   set bad return code\n   endcase                            |\n   if (treg,r15,z)                    |  if return code is zero\n    l     r2,prmgaddr                 |   store storage address\n    st    r1,0(,r2)                   |    in return area.\n   elseif (ch,r15,eq,=h'4')           |  if rc=4\n    la    r15,&es_storage_not_available   set return code\n   elseif (ch,r15,eq,=h'8')           |  if rc=8\n    la    r15,&es_invalid_boundary    |   set return code\n   elseif (ch,r15,eq,=h'12')          |  if rc=12\n    la    r15,&es_invalid_location    |   set return code\n   else                               |  if another rc\n    la    r15,&es_undetermined        |   set return code\n   endif                              |  endif\n  eject\n* *===================================================================*\n* *  release_storage\n* *===================================================================*\n  case  &es_release_storage           |\n   srvclrdb                           |  reset debug info\n   leave block=*,(ch,r2,ne,=h'5')     |  invalid number of parms.\n   l        r4,prmfsize               |  load r4\n   icm      r4,b'1111',0(r4)          |   with size of request\n   l        r5,prmfsp                 |  load r5\n   icm      r5,b'1111',0(r5)          |   with subpool\n   l        r6,prmfaddr               |  load r6 with address\n   icm      r6,b'1111',0(r6)          |   of storage to free\n   freemain rc,lv=(4),sp=(5),a=(6)    |  do freemain\n   if (ch,r15,eq,=h'4')               |  if rc=4\n    la    r15,&es_storage_not_released    set return code\n   elseif (treg,r15,nz)               |  if another rc\n    la    r15,&es_undetermined        |   set return code\n   endif                              |  endif\n  eject                               |\n* *===================================================================*\n* * ES_LOAD_MODULE function.\n* *===================================================================*\n  case  &es_load_module               | ES_LOAD_MODULE:\n   srvclrdb ,                         |   Reset the DIA stack.\n   leave    block=*,(ch,r2,lt,=h'4')  |   Leave if too few parms.\n   leave    block=*,(ch,r2,gt,=h'5')  |   Leave if too many parms.\n   la       r5,=h'&es_lm_standard'    |   r5 -> Default type.\n   if       (ch,r2,ge,=h'5')          |   If path supplied.\n     l      r5,prmlpath               |     r5 -> Supplied type.\n   endif                              |   EndIf.\n   callsub  load_module,(*prmlepnm,*prmlepa,(r5))\n  eject                               |\n* *===================================================================*\n* * ES_UNLOAD_MODULE function.\n* *===================================================================*\n  case  &es_unload_module             | ES_UNLOAD_MODULE:\n   srvclrdb ,                         |   Reset the DIA stack.\n   leave    block=*,(ch,r2,lt,=h'3')  |   Leave if too few parms.\n   leave    block=*,(ch,r2,gt,=h'4')  |   Leave if too many parms.\n   callsub  unload_module,(*prmlepnm) |   Unload the module.\n   if       (ch,r2,eq,=h'4')          |   If an EPA was supplied.\n     l      r1,prmlepa                |     r1 -> EPA of unloaded mod.\n     la     r1,0(,r1)                 |     Clear high-bit.\n     if     (treg,r1,nz)              |     If non-null parameter.\n       xc   0(4,r1),0(r1)             |       Set EPA to zeros.\n     endif                            |     EndIf.\n   endif                              |   EndIf.\n  eject\n* *===================================================================*\n* *  display message.\n* *===================================================================*\n  case  &es_display_message           | ES_DISPLAY_MESSAGE:\n   leave   block=*,(ch,r2,lt,=h'3')   |   Leave if too few parms.\n   leave   block=*,(ch,r2,gt,=h'4')   |   Leave if too many parms.\n   if      (ch,r2,ge,=h'4')           |   If explicit length.\n     l     r3,prm_dm_text             |     r3 -> message text.\n     l     r4,prm_dm_len              |     r4 -> message length.\n   else                               |   Else.\n     l     r3,prm_dm_text             |     r3 -> prefixed message.\n     l16   r0,0(r3)                   |     r0 := message length.\n     st    r0,pwa_dm_len              |     Convert to fullword.\n     la    r3,2(,r3)                  |     r3 -> message text.\n     la    r4,pwa_dm_len              |     r4 -> message length.\n   endif                              |   EndIf.\n*                                     |\n   if (clc,pwa_msg_epa,eq,=f'0')      |   If issue-message missing.\n     la      r15,&es_missing_exit_routine   Set return code.\n   else                               |   Else.\n     callx   pwa_msg_epa,(pwa_msg_token,pwa_xnfo,(r3),(r4))\n*    R15 = whatever the exit set it to, which by definition should\n*    be a valid Environment Support return code.\n   endif                              |   EndIf.\n  space\n* *===================================================================*\n* *  clear debug info.\n* *===================================================================*\n  case  &es_clear_debug_info          | start of clear debug info\n   leave   block=*,(ch,r2,lt,=h'2'),or,(ch,r2,gt,=h'3')\n   push    using                      |  save using environment\n   if      (ch,r2,eq,=h'2')           |  If no parms specified.\n     la    r1,&es_cdi_execute         |    R1 := default action.\n   else                               |  Else.\n     l     r1,prmcdact                |    r1 -> Action parm.\n     l     r1,0(r1)                   |    r1 := Action parm.\n   endif                              |  EndIf.\n   slr       r15,r15                  |  Successful return-code.\n   if    (c,r1,eq,=f'&es_cdi_execute')   If Action=EXECUTE\n     if (cli,esvdbinhibit,ne,x'00')   |    If ClearDebug inhibited.\n       la     r15,&es_clear_debug_inhibited  Set return-code.\n     else                             |    Else.\n       srvclrdb conditional=no        |      Reset debug info.\n       slr      r15,r15               |      Successful return-code.\n     endif                            |    EndIf.\n   elseif (c,r1,eq,=f'&es_cdi_inhibit')  ElseIf Action=INHIBIT\n     l8       r0,esvdbinhibit         |    R0 := inhibit count.\n     if       (ch,r0,lt,=h'255')      |    If not already @ max.\n       al     r0,=f'1'                |      Add 1.\n       stc    r0,esvdbinhibit         |      Replace value in ESV.\n     endif                            |    EndIf.\n     slr      r15,r15                 |    Successful return-code.\n   elseif (c,r1,eq,=f'&es_cdi_enable')   ElseIf Action=ENABLE\n     l8       r0,esvdbinhibit         |    R0 := inhibit count.\n     if       (treg,r0,nz)            |    If count is positive.\n       sl     r0,=f'1'                |      Subtract 1.\n       stc    r0,esvdbinhibit         |      Replace value in ESV.\n     endif                            |    EndIf.\n     slr      r15,r15                 |    Successful return-code.\n   else                               |  Else.\n     la   r15,&es_invalid_action      |    Set bad return-code.\n   endif                              |  EndIf.\n   pop     using                      |  restore using environment\n   space\n* *===================================================================*\n* *  save debug info.\n* *===================================================================*\n  case  &es_save_debug_info           | start of save debug info\n   leave   block=*,(ch,r2,lt,=h'4'),or,(ch,r2,gt,=h'7')\n   push    using                      |  save using environment\n   la      r1,prmfd                   |  point r1 past first two parms\n   callsub save_debug_info            |  save debug info\n   pop     using                      |  restore using environment\n  eject\n* *===================================================================*\n* *  display debug info and display debug info with abend.\n* *===================================================================*\n  case  &es_display_debug_info,       | start of save debug info       $\n               &es_display_debug_info_and_abend\n   leave   block=*,(ch,r2,ne,=h'2')   |  invalid number of parms.\n   push  using                        |  save using environment\n   l32   r3,esvdbtop                  |  point r3 to top of stack\n   if m                               |  if it has overflowed\n    la    r3,0(,r3)                   |   clear overflow flag\n    callsub display_and_log,          |   issue debug info lost        $\n               (msg_debugging_info_lost)   message.\n   endif                              |  endif\n   l     r4,esvdbbtm                  |  point r4 to bottom of stack\n   if (clr,r4,eq,r3)                  |  if stack is empty\n    callsub display_and_log,          |   issue stack empty            $\n               (msg_debugging_info_lost)   message.\n   else                               |  else\n    loop until                        |   print each debug entry\n     l16   r5,0(r4)                   |    load r5 with length of entry\n     l8    r1,2(r4)                   |    load r1 with type of entry\n     if     (ch,r1,eq,=al2(dbitygdi)) |    if it is general debug info\n      callsub display_debug_gdi,((r4))      call its subroutine\n     elseif (ch,r1,eq,=al2(dbitytxt)) |    if it is text info\n      callsub display_debug_text,((r4))     call its subroutine\n     elseif (ch,r1,eq,=al2(dbityhex)) |    if it is hex info\n      callsub display_debug_hex,((r4))      call its subroutine\n     else                             |    if none of the above\n      callsub display_and_log,        |     issue an error             $\n               (msg_invalid_debug_info)      message\n      callsub display_debug_hex,((r4))      assume it is hex info\n     endif                            |    endif\n     alr   r4,r5                      |    point to next entry\n    endloop until,(clr,r4,ge,r3)      |   loop through all entries\n    if (clr,r4,ne,r3)                 |   if pointers ended up strange\n     callsub display_and_log,         |    issue an error message      $\n               (msg_invalid_debug_info)\n    endif                             |   endif\n   endif                              |  endif\n   l     r1,prmafncd                  |  load address of function code\n   l     r1,0(,r1)                    |  load r1 with function code\n   if (ch,r1,eq,=h'&es_display_debug_info_and_abend')\n    abend 1000,dump                   |  abend if the function code\n   endif                              |   is display debug and abend.\n   pop   using                        |  restore using environment\n  eject                               |\n* *===================================================================*\n* *  get userid.\n* *===================================================================*\n  case  &es_get_userid                | start of get current userid\n   push  using                        |  save using environment\n   srvclrdb                           |  reset debug info\n   leave block=*,(ch,r2,ne,=h'3')     |  invalid number of parms.\n   lcba  r1,asxb                      |  point r1 to asxb\n   l     r14,prmar1                   |  point r14 to 8-byte parm area\n   mvc   0(7,r14),asxbuser-asxb(r1)   |  move seven bytes to parm area\n   mvi   7(r14),x'40'                 |  blank out last byte\n   slr   r15,r15                      |  set successful return code\n   if (tm,0(r14),z,x'bf')             |  if userid is blank or null\n    la    r15,&es_could_not_locate    |   set error return code\n   endif                              |  endif\n   pop   using                        |  restore using environment\n  eject\n* *===================================================================*\n* *  get group.\n* *===================================================================*\n  case  &es_get_group                 | start of get current userid\n   push  using                        |  save using environment\n   srvclrdb                           |  reset debug info\n   leave block=*,(ch,r2,ne,=h'3')     |  invalid number of parms.\n   la    r15,&es_could_not_locate     |  assume the worst\n   lcba  r1,acee                      |  point r1 to asxb\n   if nz                              |  if acee exist\n    l     r15,prmar1                  |   point r15 to 8-byte parm area\n    mvc   0(8,r15),aceegrpn-acee(r1)  |   move seven bytes to parm area\n    slr   r15,r15                     |   set good return code\n   endif                              |  endif\n   pop   using                        |  restore using environment\n  eject\n* *===================================================================*\n* *  get cacct.\n* *===================================================================*\n  aif (not &srv_clemson).skip7\n  case  &es_get_cacct                 | start of get current cacct\n   push  using                        |  save using environment\n   srvclrdb                           |  reset debug info\n   leave block=*,(ch,r2,ne,=h'3')     |  invalid number of parms.\n   la    r15,&es_could_not_locate     |  be pessimistic\n   lcba  r1,acee                      |  point r1 to acee\n   if nz                              |  if acee exist\n    l32   r2,aceeiep-acee(r1)         |   point r2 to iep\n    if nz                             |   if iep exist\n     l     r1,prmar1                  |    point r1 return area\n     mvc   0(8,r1),ieppact+1-iep(r2)  |    move cacct to return area\n     if (tm,0(r1),nz,x'bf')           |    if acct in not blank or null\n      slr   r15,r15                   |     set successful return code\n     endif                            |    endif\n    endif                             |   endif\n   endif                              |  endif\n   pop   using                        |  restore using environment\n  eject\n.skip7 anop\n* *===================================================================*\n* *  get sysres volume name.\n* *===================================================================*\n  case  &es_get_sysres_volume_name    | start of get sysres volume name\n   push  using                        |  save using environment\n   srvclrdb                           |  reset debug info\n   leave block=*,(ch,r2,ne,=h'3')     |  invalid number of parms.\n   lcba  r1,cvt                       |  point r1 to cvt\n   l     r1,cvtsysad-cvt(,r1)         |  point to sysres ucb\n   l     r2,prmar1                    |  point r2 return area\n   mvc   0(6,r2),ucbvoli-ucb(r1)      |  move cacct to return area\n   slr   r15,r15                      |  set successful return code\n   pop   using                        |  restore using environment\n  eject\n* *===================================================================*\n* *  get terminal identification\n* *===================================================================*\n  aif (not &srv_clemson).skip1\n  case  &es_get_terminal_name         | start of get terminal name\n   push  using                        |  save using environment\n   srvclrdb                           |  reset debug info\n   leave block=*,(ch,r2,ne,=h'3')     |  invalid number of parms.\n   clemsrv rtnname                    |  get terminal name\n   if (treg,r15,z)                    |  if terminal name located\n    l     r2,prmar1                   |   point r2 to return area\n    stcm  r0,b'1111',0(r2)            |   store terminal name\n    stcm  r1,b'1111',4(r2)            |   in return area.\n   else                               |  if terminal name not located\n    la    r15,&es_could_not_locate    |   set bad return code\n   endif                              |  endif\n   pop   using                        |  restore using environment\n  eject                               |\n.skip1 anop\n* *===================================================================*\n* *  get jobcard name field.\n* *===================================================================*\n  aif (not &srv_clemson).skip2\n  case &es_get_jobcard_name_field     | start of jobcard name field\n   push  using                        |  save using environment\n   srvclrdb                           |  reset debug info\n   leave block=*,(ch,r2,ne,=h'3')     |  invalid number of parms.\n   la    r0,c00enlen                  |  load r0 with size of area\n   la    r1,pwac00                    |  point r1 to return area\n   clemsrv c00                        |  get programmer name\n   if (treg,r15,z)                    |  if terminal name located\n    l     r2,prmar1                   |   point r2 to return area\n    mvc   0(20,r2),pwac00+c00pname-c00    move name to return area\n   else                               |  if unsuccessful\n    la    r15,&es_could_not_locate    |   set bad return code\n   endif                              |  endif\n   pop   using                        |  restore using environment\n  eject\n.skip2 anop\n* *===================================================================*\n* *  get jobcard room number.\n* *===================================================================*\n  aif (not &srv_clemson).skip3\n  case &es_get_jobcard_room           | start of jobcard room number\n   push  using                        |  save using environment\n   srvclrdb                           |  reset debug info\n   leave block=*,(ch,r2,ne,=h'3')     |  invalid number of parms.\n   la    r0,c00enlen                  |  load r0 with size of area\n   la    r1,pwac00                    |  point r2 to return area\n   clemsrv c00                        |  get programmer name\n   if (treg,r15,z)                    |  if terminal name located\n    l     r2,prmar1                   |   point r2 to return area\n    mvc   0(4,r2),pwac00+c00roomn-c00 |   move name to return area\n   else                               |  if unsuccessful\n    la    r15,&es_could_not_locate    |   set bad return code\n   endif                              |  endif\n   pop   using                        |  restore using environment\n  eject\n.skip3 anop\n* *===================================================================*\n* *  get tsu, stc or job.\n* *===================================================================*\n  aif (not &srv_clemson).skip4\n  case &es_get_tsu_stc_or_job         | start get tsu, stc or job\n   push  using                        |  save using environment\n   srvclrdb                           |  reset debug info\n   leave block=*,(ch,r2,ne,=h'3')     |  invalid number of parms.\n   la    r0,c00enlen                  |  load r0 with size of area\n   la    r1,pwac00                    |  point r1 to return area\n   clemsrv c00                        |  get programmer name\n   if (treg,r15,z)                    |  if successful\n    l     r2,prmar1                   |   point r2 to return area\n    mvc   0(3,r2),pwac00+c00jobid-c00 |   move type to return area\n   else                               |  if unsuccessful\n    la    r15,&es_could_not_locate    |   set bad return code\n   endif                              |  endif\n   pop   using                        |  restore using environment\n  eject\n.skip4 anop\n* *===================================================================*\n* *  get jobid.\n* *===================================================================*\n  aif (not &srv_clemson).skip5\n  case &es_get_jobid                  | start get jobid\n   push  using                        |  save using environment\n   srvclrdb                           |  reset debug info\n   leave block=*,(ch,r2,ne,=h'3')     |  invalid number of parms.\n   la    r0,c00enlen                  |  load r0 with size of area\n   la    r1,pwac00                    |  point r1 to return area\n   clemsrv c00                        |  get programmer name\n   if (treg,r15,z)                    |  if successful\n    l     r2,prmar1                   |   point r2 to return area\n    mvc   0(8,r2),pwac00+c00jobid-c00 |   move jobid to return area\n   else                               |  if unsuccessful\n    la    r15,&es_could_not_locate    |   set bad return code\n   endif                              |  endif\n   pop   using                        |  restore using environment\n  eject                               |\n.skip5 anop\n* *===================================================================*\n* *  get default destination.\n* *===================================================================*\n  case &es_get_default_destination    | start get default destination\n   push  using                        |  save using environment\n   srvclrdb                           |  reset debug info\n   leave block=*,(ch,r2,ne,=h'3')     |  invalid number of parms.\n   la    r15,&es_could_not_locate     |  set default return code\n   lcba  r1,asxb                      |  point r1 to asxb\n   icm   r1,b'1111',asxblwa-asxb(r1)  |  point r1 to lwa\n   if nz                              |  if lwa exist\n    l     r1,lwapscb-lwa(,r1)         |   point r1 to pscb\n    l     r14,prmar1                  |   point r14 to return area\n    mvc   0(8,r14),pscbdest-pscb(r1)  |   point r1 to upt\n    slr   r15,r15                     |   set successful return code\n   endif                              |  endif\n   pop   using                        |  restore using environment\n  eject                               |\n* *===================================================================*\n* *  get dsname prefix.\n* *===================================================================*\n  case  &es_get_prefix                | start get dsname prefix\n   push  using                        |  save using environment\n   srvclrdb                           |  reset debug info\n   leave block=*,(ch,r2,ne,=h'3')     |  invalid number of parms.\n   la    r15,&es_could_not_locate     |  set default return code\n   lcba  r1,asxb                      |  point r1 to asxb\n   icm   r1,b'1111',asxblwa-asxb(r1)  |  point r1 to lwa\n   if nz                              |  if lwa exist\n    l     r1,lwapscb-lwa(,r1)         |   point r1 to pscb\n    l     r1,pscbupt-pscb(,r1)        |   point r1 to upt\n    la    r2,uptprefx-upt(,r1)        |   point r2 to prefix\n    l8    r3,uptprefl-upt(r1)         |   load r3 with length of prefix\n    icm   r3,b'1000',=x'40'           |   fill with spaces\n    l     r0,prmar1                   |   point r0 to return area\n    la    r1,8                        |   load r1 with length of area\n    mvcl  r0,r2                       |   move prefix to return area\n    slr   r15,r15                     |   set successful return code\n   endif                              |  endif\n   pop   using                        |  restore using environment\n   eject                              |\n* *===================================================================*\n* *  get time.  date code works until the year 2087.\n* *===================================================================*\n  case  &es_get_time                  | get time\n   push  using                        |  save using environment\n   srvclrdb                           |  reset debug info\n   leave block=*,(ch,r2,lt,=h'3')     |  invalid number of parms.\n   leave block=*,(ch,r2,gt,=h'4')     |  invalid number of parms.\n   time  bin                          |  issue time macro\n*  binary form time\n   l32   r3,prmar1                    |  point r3 return area\n   la    r3,0(,r3)                    |  Clear high-order bit.\n   if (treg,r3,nz)                    |  if non-zero\n    stcm  r0,b'1111',0(r3)            |   store time in return area\n   endif                              |  endif\n*  ccyyddd packed form date\n   slr   r15,r15                      |  Clear out return-code.\n   leave block=*,(clc,pwa_#parms,lt,=f'4')\n   l32   r3,prmar2                    |  point r3 return area\n   la    r3,0(,r3)                    |  Clear high-order bit.\n   if (treg,r3,nz)                    |  if non-zero\n    if (clm,r1,b'0100',ge,=al1(87))   |   if year >= 87\n     icm   r1,b'1000',=x'19'          |    century is 19\n    else                              |   if year < 87\n     icm   r1,b'1000',=x'20'          |    century is 20\n    endif                             |   endif\n    stcm  r1,b'1111',0(r3)            |   store date in return area\n   endif                              |  endif\n*\n   slr   r15,r15                      |  set successful return code\n   pop   using                        |  restore using environment\n* *===================================================================*\n* *  get GMT time.  date code works until the year 2087.\n* *===================================================================*\n  case  &es_get_gmt_time              | get time\n   push  using                        |  save using environment\n   srvclrdb                           |  reset debug info\n   leave block=*,(ch,r2,lt,=h'3')     |  invalid number of parms.\n   leave block=*,(ch,r2,gt,=h'4')     |  invalid number of parms.\n   time  bin,zone=gmt                 |  issue time macro\n*  binary form time\n   l32   r3,prmar1                    |  point r3 return area\n   la    r3,0(,r3)                    |  Clear high-order bit.\n   if (treg,r3,nz)                    |  if non-zero\n    stcm  r0,b'1111',0(r3)            |   store time in return area\n   endif                              |  endif\n*  ccyyddd packed form date\n   slr   r15,r15                      |  Clear out return-code.\n   leave block=*,(clc,pwa_#parms,lt,=f'4')\n   l32   r3,prmar2                    |  point r3 return area\n   la    r3,0(,r3)                    |  Clear high-order bit.\n   if (treg,r3,nz)                    |  if non-zero\n    if (clm,r1,b'0100',ge,=al1(87))   |   if year >= 87\n     icm   r1,b'1000',=x'19'          |    century is 19\n    else                              |   if year < 87\n     icm   r1,b'1000',=x'20'          |    century is 20\n    endif                             |   endif\n    stcm  r1,b'1111',0(r3)            |   store date in return area\n   endif                              |  endif\n*\n   slr   r15,r15                      |  set successful return code\n   pop   using                        |  restore using environment\n  eject                               |\n* *===================================================================*\n* *  get formatted time.  date code works until the year 2087.\n* *===================================================================*\n  case  &es_get_formatted_time        | start of get formatted_time\n   push  using                        |  save using environment\n   srvclrdb                           |  reset debug info\n   leave block=*,(ch,r2,lt,=h'3')     |  invalid number of parms.\n   leave block=*,(ch,r2,gt,=h'5')     |  invalid number of parms.\n*  *------------------------------------------------------------------*\n*  *  Get time and add century to date.\n*  *------------------------------------------------------------------*\n   time  dec                          |  issue time macro\n   st    r0,pwa_dec_time              |  save time in pwa\n   st    r1,pwa_yyddd                 |  save yyddd\n*  *------------------------------------------------------------------*\n*  *  Edit time and move it to return area if provided.\n*  *------------------------------------------------------------------*\n   l32   r3,prmar1                    |  point r3 to TIME parm.\n   la    r3,0(,r3)                    |  Clear hi-bit.\n   if    (treg,r3,nz)                 |  If non-zero.\n    mvc   pwa_time_mask,psd_time_mask |   move mask to pwa\n    ed    pwa_time_mask,pwa_dec_time  |   edit time (hh:mm:ss.th)\n    mvc   0(11,r3),pwa_time_mask+1    |   store time in return area\n   endif                              |  endif\n*  *------------------------------------------------------------------*\n*  * Edit date in form mm/dd/yy and move it to return area if provided.\n*  *------------------------------------------------------------------*\n   slr   r15,r15                      |  Clear out return-code.\n   leave block=*,(clc,pwa_#parms,lt,=f'4')\n   l32   r3,prmar2                    |  Point r3 to GREGORIAN parm.\n   la    r3,0(,r3)                    |  Clear hi-bit.\n   if    (treg,r3,nz)                 |  If non-zero.\n*   *-----------------------------------------------------------------*\n*   *  convert day to binary.  if the day is past february 28 and\n*   *  this is not a leap year, add 1 to the day to skip february 29.\n*   *-----------------------------------------------------------------*\n    zap   pwad,pwa_yyddd+2(2)         |   convert ddd\n    cvb   r2,pwad                     |    to binary.\n    if (ch,r2,gt,=y(31+28))           |   if past feb 28\n     mvi   pwad+7,x'0c'               |    convert year\n     mvo   pwad,pwa_yyddd+1(1)        |     to packed.\n     cvb   r1,pwad                    |    convert year to binary\n     sll   r1,30                      |    shift mod 4 to high 2 bits\n     if (treg,r1,nz)                  |    if year is not a leap year\n      la    r2,1(,r2)                 |     add 1 to skip feb 29\n     endif                            |    endif\n    endif                             |   endif\n*   *-----------------------------------------------------------------*\n*   *  calculate month and day of month by searching table.\n*   *-----------------------------------------------------------------*\n    la    r15,=h'31,29,31,30,31,30,31,31,30,31,30' days in month\n    la    r1,11                       |   loop up to 11 times\n    loop bct                          |   start of loop\n     leave loop=*,(ch,r2,le,0(r15))   |    leave if days left <=\n*                                     |     days in this month\n     sh    r2,0(,r15)                 |    subtract days in month\n     la    r15,2(,r15)                |    point to next months days\n    endloop bct,r1                    |   continue loop\n    lcr   r1,r1                       |   calculate\n    ah    r1,=h'12'                   |    month.\n*   *-----------------------------------------------------------------*\n*   * move date to return area in form mm/dd/yy.\n*   *                 displacements => 01234567\n*   *-----------------------------------------------------------------*\n    cvd   r1,pwad                     |   convert month to decimal\n    oi    pwad+7,x'0f'                |   remove sign\n    unpk  0(2,r3),pwad+6(2)           |   convert to printable\n    mvi   2(r3),c'/'                  |   put in first slash\n    cvd   r2,pwad                     |   convert day to decimal\n    oi    pwad+7,x'0f'                |   remove sign\n    unpk  3(2,r3),pwad+6(2)           |   convert to printable\n    mvi   5(r3),c'/'                  |   put in second slash\n    unpk  pwad(3),pwa_yyddd+1(2)      |   convert year to printable\n    mvc   6(2,r3),pwad                |   return date to caller\n*   *-----------------------------------------------------------------*\n   endif                              |  endif\n*  *------------------------------------------------------------------*\n*  * edit date in form ccyy.ddd and move it to return area if provided.\n*  *------------------------------------------------------------------*\n   slr   r15,r15                      |  Clear out return-code.\n   leave block=*,(clc,pwa_#parms,lt,=f'5')\n   l     r3,prmar3                    |  point r3 to JULIAN parm.\n   la    r3,0(,r3)                    |  Clear hi-bit.\n   if    (treg,r3,nz)                 |  if non-zero.\n    l     r1,pwa_yyddd                |\n    if (clm,r1,b'0100',ge,=al1(87))   |   if year >= 87\n     icm   r1,b'1000',=x'19'          |    century is 19\n    else                              |   if year < 87\n     icm   r1,b'1000',=x'20'          |    century is 20\n    endif                             |   endif\n    st    r1,pwa_ccyyddd              |   store date in return area\n    mvc   pwa_ccyyddd_mask,psd_ccyyddd_mask move mask to pwa\n    ed    pwa_ccyyddd_mask,pwa_ccyyddd      edit (ccyy.ddd)\n    mvc   0(8,r3),pwa_ccyyddd_mask+1  |     move date to return area\n   endif                              |  endif\n*  *------------------------------------------------------------------*\n   slr   r15,r15                      |  set successful return code\n   pop   using                        |  restore using environment\n  eject                               |\n* *===================================================================*\n* *  all other function codes are invalid.\n* *===================================================================*\n  case  other                         |\n   srvclrdb                           |  reset debug info\n   la    r15,&es_invalid_function     |  set return code\n* *-------------------------------------------------------------------*\n  endcase                             | endcase\n endblk block=&srv_modname,rc=(r15)\n eject                                |\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Start\n*  Abstract:   Start environment support.\n*\n*---------------------------------------------------------------------*\n  block type=subroutine,name=start\n*\n*  Get storage for the ESV and the Debug Information Area (DIA).\n*\n   getmain rc,lv=esvcblen+debug_area_size get storage\n   st      r1,pwaaesv               |   Save address of ESV.\n   l       r15,prm1esv              |   Point r15 to ESV return area.\n   st      r1,0(,r15)               |   Store esv address.\n   lr      r9,r1                    |   Point r9 to ESV.\n*\n*  Initialize the Environment Support Vector (ESV) and the DIA.\n*\n   xc    esv(esvcblen),esv          |   Clear the entire ESV.\n   mvc   esvid,=al4(esvidt)         |   Initialize the ESV identifier.\n   la    r0,esvcblen                |   Save the ESV's length within\n   sth   r0,esvlen                  |     the ESV itself.\n   mvi   esvver,1                   |   Set the version number.\n   mvi   esvrel,1                   |   Set the release number.\n   sm_lal r1,linkage_getmain        |   Install the linkage\n   st    r1,esvalget                |     getmain routine.\n   sm_lal r1,linkage_freemain       |   Install the linkage\n   st    r1,esvalfre                |     freemain routine.\n   mvc   esvesepa,=a(&srv_modname)   Set Environment Sup\n   st    r13,esvestkn               |   Set Environment Support TOKEN.\n   lr    r1,r9                      |   R1 -> Start of ESV storage.\n   al    r1,=a(esvcblen)            |   R1 -> Start of DIA storage.\n   st    r1,esvdbbtm                |   Set DIA stack bottom.\n   st    r1,esvdbtop                |   Set DIA stack top.\n   al    r1,=a(debug_area_size)     |   R1 -> last byte in DIA storage.\n   st    r1,esvdblmt                |   Save as DIA stack limit.\n*\n*  If an application MNT was provided, save its address.\n*\n   if (clc,pwa_#parms,ge,=f'4')     |   If enough parameters given.\n     l   r1,prm1mnt                 |     R1 -> Appl MNT pointer.\n     la  r1,0(,r1)                  |     Clear high-bit, if on.\n     if  (treg,r1,nz)               |     If appl MNT provided.\n       l r1,0(,r1)                  |       R1 -> Appl MNT.\n     endif                          |     EndIf.\n     st  r1,pwaaamnt                |     Save as appl MNT address.\n   endif                            |   EndIf.\n*\n*  Load exit routines.\n*\n   if (clc,pwa_#parms,ge,=f'5')     |   If ExitInfo parameter given.\n     l       r1,prm1xnfo            |     r1 -> Exit Info word.\n     la      r1,0(,r1)              |     Turn off high-bit.\n     st      r1,pwa_xnfo            |     Save address in PWA.\n   else                             |   Else.\n     mvc     pwa_xnfo,=f'0'         |     Use default ExitInfo value.\n   endif                            |   EndIf.\n*\n*  Decode options if supplied.\n*\n   if (clc,pwa_#parms,ge,=f'6')     |   If Options parameter given.\n     l       r1,prm1opts            |     r1 -> Exit Info word.\n     la      r1,0(,r1)              |     Turn off high-bit.\n     if (treg,r1,nz)                |     If there are options:\n      mvc   pwa_oc_mnt,0(r1)        |      Move MNT option\n      ni    pwa_oc_mnt,&es_oc_mnt   |      to PWA.\n     endif                          |     Endif.\n   endif                            |   EndIf.\n*\n*  If options is STDMNT (default), try to locate the standard MNT.\n*\n   if (cli,pwa_oc_mnt,eq,&es_oc_stdmnt)\n    wxtrn &srv_stdmnt               |    &srv_stdmnt is weak reference\n    l32   r0,=a(&srv_stdmnt)        |    R0 -> Standard MNT.\n    if    z                         |    If not linked in, then.\n      load  ep=&srv_stdmnt,erret=no_standard_mnt Attempt to load it.\n    endif                           |    EndIf.\n    st    r0,pwaasmnt               |    Save address in pwa\nno_standard_mnt equ *               |   i know it's tacky!@$#$@\n   endif                            |\n*\n   macro\n   load_exit &epname,&epa\n   gbla      &es_missing_exit_routine,&es_lm_standard\n   callsub   load_module,(&epname,&epa,&es_lm_standard)\n   if        (treg,r15,nz)\n     la      r15,&es_missing_exit_routine\n     leave   block=*\n   endif\n   mend\n*\n   load_exit &es_mvs_message_exit,pwa_msg_epa\n   mvc       pwa_msg_token,=f'0'\n*\n*  Set successful return code and quit.\n*\n   slr   r15,r15                    |   Set successful return code.\n  endblk block=start                |   Return to caller.\n eject                              |\n*---------------------------------------------------------------------*\n*\n*  Subroutine: load_module,(epname,epa,path)\n*  Abstract:   Load a module into storage.\n*\n*---------------------------------------------------------------------*\n block type=subroutine,name=load_module\n  lm       r3,r5,0(r1)                | r3->epname r4->epa r5->path.\n  icm      r5,b'1111',0(r5)           | r5 := path.\n*                                     |\n  callsub loc_mnt,(pwaaamnt,(r3))     | Search application MNT.\n  if      (treg,r1,z)                 | If not in application MNT.\n    callsub loc_mnt,(pwaasmnt,(r3))   |   Search standard MNT.\n  endif                               | Endif.\n*                                     |\n  lr    r6,r1                         | R6 -> MNT entry, if located.@C2\n  using mnt,r6                        | R6 is the MNT base reg.\n*                                                                   @C2\n  if (ch,r5,eq,=h'&es_lm_no_load')    | If no_load option specified:@C2\n    la    r15,&es_module_not_loaded   |   Assume the worst.         @C2\n    xc  0(l'mntepa,r4),0(r4)          |   Clear EPA in return area. @C2\n    if (treg,r6,nz)                   |   If MNT found:             @C2\n      l32    r0,mntepa                |     Load EPA from MNT.      @C2\n      if nz,and,(cl,r0,ne,=a(x'80000000'))  If non-zero:            @C3\n        st     r0,0(,r4)              |       Store EPA in return   @C2\n        slr    r15,r15                |       area and set RC=0.    @C2\n      endif                           |     Endif.                  @C2\n    endif                             |   Endif.                    @C2\n    leave block=*                     |   Skip rest of block.       @C2\n  endif                               | Endif.                      @C2\n*                                                                   @C2\n  if    (treg,r6,z)                   | If module not located yet.  @C2\n    if (ch,r5,eq,=h'&es_lm_mnt_only') |   If MNT_ONLY specified.\n      la    r15,&es_module_not_loaded |     Set return code.\n      leave block=*                   |     Return to caller.\n    else                              |   Else, system load okay.\n      la  r6,pwawmnt                  |     Make a dummy MNT entry.\n      xc  pwawmnt,pwawmnt             |     Clear it to zeros.\n      mvc mntname,0(r3)               |     Move in module's name.\n      mvc mnttruename,0(r3)           |     Use it as TrueName.     @c1\n    endif                             |   EndIf.\n  endif                               | EndIf.\n*                                     |\n  l32 r0,mntepa                       | Load EPA from the MNT entry.\n  if  z,or,(cl,r0,eq,=a(x'80000000')) | If the module is not loaded.@C3\n    load  eploc=mnttruename,          |   Attempt to load module.   @c1+\n               erret=load_failed      |   Skip store if failure.    @c1\n  endif                               | Endif.\n  st    r0,0(,r4)                     | Store EPA in return area.\n  slr   r15,r15                       | Set return code to zero.\n  leave block=*                       | Return to caller.\n*                                     |\nload_failed la  r15,&es_module_not_loaded\n*                                     |\n endblk block=load_module,rc=(r15)    | EndBlock.\n eject                                |\n*---------------------------------------------------------------------*\n*\n*  Subroutine: unload_module,(epname)\n*  Abstract:   unload a module from storage.\n*\n*---------------------------------------------------------------------*\n block type=subroutine,name=unload_module\n   l        r3,0(r1)                  | R3 -> EPNAME.\n   callsub  loc_mnt,(pwaaamnt,(r3))   | Search application MNT.\n   if       (treg,r1,z)               | If not in application MNT.\n     callsub loc_mnt,(pwaasmnt,(r3))  |   Search standard MNT.\n   endif                              | Endif.\n*                                     |\n   ltr   r6,r1                        | R6 -> MNT entry, if located.\n   using mnt,r6                       | R6 is the MNT base reg.\n   if    z,then                       | If module not located yet.\n     la  r6,pwawmnt                   |   Make a dummy MNT entry.\n     xc  pwawmnt,pwawmnt              |   Clear it to zeros.\n     mvc mntname,0(r3)                |   Move in module's name.\n     mvc mnttruename,0(r3)            |   Use it as TrueName.       @c1\n   endif                              | EndIf.\n*                                     |\n   slr   r15,r15                      | Set success return code.\n   l32   r0,mntepa                    | Load EPA from the MNT entry.\n   if    z,or,(cl,r0,eq,=a(x'80000000')) If Zero.                   @C3\n     delete eploc=mnttruename         |   Unload the module.        @c1\n     if (treg,r15,nz)                 |   If return code is bad.\n       la  r15,&es_module_not_unloaded      Set the return code.\n     endif                            |   EndIf.\n   endif                              | EndIf.\n endblk block=unload_module,rc=(r15)  |\n eject\n*---------------------------------------------------------------------*\n*\n*  subroutine: loc_mnt\n*  abstract:   find mnt entry\n*  inputs:     (a_mnt_table_pointer,cl8_name_to_locate)\n*  outputs:    r1 points to mnt or has zero\n*\n*---------------------------------------------------------------------*\n space 1                              |\n block name=loc_mnt,type=subroutine   |\n  lm    r2,r3,0(r1)                   | point r2 to table pointer and\n*                                     |  r3 to name to locate\n  slr   r1,r1                         | set r1 to zero\n  l32   r5,0(r2)                      | point r5 to mnt pointer\n  if nz                               | if not zero\n   icm   r5,b'1111',0(r5)             |  point r5 to mnt\n  endif                               | endif\n  using mnt,r5                        | establish base for mnt\n  if nz                               | if a mnt table exist\n   loop until                         |  search for mnt for service\n    if (cli,0(r5),eq,0)               |   if end of table\n     slr   r5,r5                      |    set mnt address to null\n     leave loop=*                     |    stop search\n    endif                             |   endif\n    leave loop=*,(clc,mntname,eq,0(r3))   leave if search is complete\n    la    r5,mntcblen(,r5)            |   point to next mnt\n   endloop until,leave                |  end of search code\n   lr    r1,r5                        |  point r1 to mnt\n  endif                               | endif\n  strsa r1                            | return r1\n endblk block=loc_mnt                 |\n eject                                |\n*---------------------------------------------------------------------*\n*\n*  subroutine: save_debug_info\n*  abstract:   put debug information in debug area\n*  inputs:     (see prmfd part of prm dsect)\n*\n*---------------------------------------------------------------------*\n space 1                              |\n block name=save_debug_info,type=subroutine\n* *-------------------------------------------------------------------*\n* *  establish base and count parms.\n* *-------------------------------------------------------------------*\n  lr    r8,r1                         | point r8 to parms\n  using prmfd,r8                      | establish new parm base\n  la    r15,7                         | load r15 with max parms\n  loop bct                            | loop searching for end\n   leave loop=*,(tbit,0(r1),x'80')    |  quit loop if high bit on\n   la    r1,4(,r1)                    |  point to next parm\n  endloop bct,r15                     | endloop\n  lcr   r7,r15                        | calculate number\n  ah    r7,=y(7+1)                    |  of parms.\n* *-------------------------------------------------------------------*\n* *  process particular type of parm.\n* *-------------------------------------------------------------------*\n  l     r1,prmvtype                   | load r1 with\n  l     r1,0(,r1)                     |  type.\n  caseblk reg=r1                      | start of case block\n  case &es_debug_id_gdi               | case general debug information\n*  *------------------------------------------------------------------*\n*  *  store general debug information.\n*  *------------------------------------------------------------------*\n   if (ch,r7,ne,=h'2')                |  if number of parms is not 2\n    callsub display_and_log,(msg_debug_wrong_parms) display message\n    leave block=*                     |             leave subroutine\n   endif                              |  endif\n   l     r3,prmvagdi                  |  point r3 to gdi\n   using gdi,r3                       |  establish base for gdi\n   l     r15,gdimodid                 |  point r15 to module id\n   l8    r1,0(r15)                    |  load module id length\n   ah    r1,=y(dbi1flen+1)            |  add length of fixed part + 1\n   callsub get_debug_storage          |  get debug storage\n   ltr   r4,r1                        |  put storage address in r4\n   leave z,block=*                    |  leave if debug area is full\n   using dbi,r4                       |  establish base for storage\n   mvi   dbity,dbitygdi               |  move type to debug area\n   mvc   dbi1ofst,gdioffst            |  move offset to debug area\n   mvc   dbi1rc,gdirc                 |  move return code to debug area\n   mvc   dbi1regs,gdiregs             |  move registers to debug area\n   l     r15,gdimodid                 |  point r15 to module id\n   l8    r1,0(r15)                    |  load r1 with length of id\n   exi   r1,(mvc,dbi1modi(*-*),0(r15))   move id and length\n   drop  r4                           |  drop base for dbi\n  case &es_debug_id_text,&es_debug_id_hex\n*  *------------------------------------------------------------------*\n*  *  store text and hex debug information.\n*  *------------------------------------------------------------------*\n   if (ch,r7,gt,=h'5'),or,            |  if wrong number of parms      $\n               (ch,r7,lt,=h'3')       |\n    callsub display_and_log,(msg_debug_wrong_parms)\n    leave block=*                     |   leave subroutine\n   endif                              |  endif\n   l     r4,prmvtxsl                  |  load r4 with\n   l     r4,0(,r4)                    |   storage length.\n   slr   r3,r3                        |  assume name length of zero\n   if (ch,r7,eq,=h'4')                |  if there are 4 parms\n    la    r3,8                        |   assume name length of 8\n   elseif (ch,r7,eq,=h'5')            |  if there are 5 parms\n    l     r3,prmvtxnl                 |   load name length\n    l     r3,0(,r3)                   |    from parameter.\n   endif                              |  endif\n   if (ch,r3,gt,=h'255'),or,          |  if name length > 255 or       $\n               (ch,r4,gt,=h'32765')   |   data length > 32765.\n    callsub display_and_log,(msg_debug_bad_length)\n    leave block=*                     |   leave subroutine\n   endif                              |  endif\n   la    r1,1+2+dbivar-dbi(r3,r4)     |  calculate storage needed\n   callsub get_debug_storage          |  get storage\n   ltr   r2,r1                        |  point r2 to storage\n   using dbi,r2                       |  establish base for dbi\n   leave z,block=*                    |  leave if debug area is full\n   mvi   dbity,dbityhex               |  assume type of hex\n   l     r1,prmvtype                  |  load r1 with\n   l     r1,0(,r1)                    |   type.\n   if (ch,r1,eq,=h'&es_debug_id_text')   if text\n    mvi   dbity,dbitytxt              |   set type to text\n   endif                              |  endif\n   la    r2,dbivar                    |  point r2 to variable part\n   drop  r2                           |  drop base for fixed part\n   stc   r3,0(,r2)                    |  storage name length first\n   la    r2,1(,r2)                    |  point r2 past length\n   if (ch,r7,ge,=h'4')                |  if a name is provided\n    lr    r15,r3                      |   load r15 with length\n    l     r14,prmvtxn                 |   point r15 to name\n    mvcl  r2,r14                      |   move it to debug area\n   endif                              |  endif\n   stcm  r4,b'0011',0(r2)             |  store text/hex length\n   la    r2,2(,r2)                    |  point r2 past length\n   lr    r3,r4                        |  load r3 with text/hex length\n   lr    r15,r3                       |  load r15 with text/hex length\n   l     r14,prmvtxs                  |  point r14 to text/hex\n   mvcl  r2,r14                       |  move text/hex to debug area\n  case other                          | any other case\n   callsub display_and_log,(msg_debug_invalid_type)\n  endcase                             |\n endblk block=save_debug_info,rc=0    |\n eject                                |\n*---------------------------------------------------------------------*\n*\n*  subroutine: get_debug_storage\n*  abstract:   obtain storage from debug area\n*  inputs:     r1 has length\n*  outputs:    r1 has address or zero if no room\n*\n*---------------------------------------------------------------------*\n space 1                              |\n block name=get_debug_storage,type=subroutine\n  lr    r15,r1                        | put length in r15\n  l32   r1,esvdbtop                   | point r1 to top of stack\n  if m                                | if already an overflow\n   slr   r1,r1                        |  return zero as address\n  else                                | else\n   lr    r2,r1                        |  point r2 to new\n   alr   r2,r15                       |   top of stack.\n   if (cl,r2,le,esvdblmt),and,        |  if not past limit             $\n               (ch,r15,le,=h'32766')  |   size not to large\n    stcm  r15,b'0011',0(r1)           |   save length in first halfword\n    st    r2,esvdbtop                 |   store new top\n   else                               |  if past limit\n    callsub display_and_log,(msg_debug_area_full)\n    slr   r1,r1                       |   return zero as address\n    sbit  esvdbtop,x'80'              |   indicate overflow\n   endif                              |  endif\n  endif                               | endif\n  strsa r1                            | return r1\n endblk block=get_debug_storage,rc=0  |end of subroutine\n space 2                              |\n eject                                |\n*---------------------------------------------------------------------*\n*\n*  subroutine: display_debug_gdi\n*  abstract:   display gdi type debug information\n*  inputs:     (address_of_dbi)\n*\n*---------------------------------------------------------------------*\n space 1                              |\n block name=display_debug_gdi,type=subroutine\n  l     r3,0(,r1)                     | point r3 to dbi\n  using dbi,r3                        | establish addressibility\n  fill  ddgo,x'40',length=(ddgolen1,s)  fill output line with spaces\n  mvc   ddgoc1,=c\"SRV1000I Error\"     | Move start of message\n  lh    r1,dbi1rc                     | convert return code\n  cvd   r1,pwad                       |  to decimal.\n  mvc   ddgorc,=x'402020202120'       | edit return code\n  ed    ddgorc,pwad+5                 |  into message.\n  mvc   ddgoc2,=c\" at offset +\"       | Move next part of message\n  callsub convert_printable_hex,      | convert offset to              $\n               (dbi1ofst,2,ddgoofst)  |  printable hex.\n  mvc   ddgoc3,=c\" in \"               | Move next part of message\n  la    r0,ddgomdid                   | move\n  la    r1,l'ddgomdid                 |  module id\n  la    r14,dbi1modi+1                |  to message\n  l8    r15,dbi1modi                  |  and fill\n  icm   r15,b'1000',=x'40'            |  with\n  mvcl  r0,r14                        |  spaces.\n  callsub display_and_log,(ddgo,=a(ddgolen1)) display and log message\n  fill  ddgo,x'40',length=(ddgolen2,s)  fill output line with spaces\n  mvc   ddgorgid,=cl7'R0-R3'          |        display and\n  callsub move_regs,(dbi1regs+(0*4),ddgorgs)    log registers\n  callsub display_and_log,(ddgo,=a(ddgolen2))   r0-r3.\n  mvc   ddgorgid,=cl7'R4-R7'          |        display and\n  callsub move_regs,(dbi1regs+(4*4),ddgorgs)    log registers\n  callsub display_and_log,(ddgo,=a(ddgolen2))   r4-r7.\n  mvc   ddgorgid,=cl7'R8-R11'         |        display and\n  callsub move_regs,(dbi1regs+(8*4),ddgorgs)    log registers\n  callsub display_and_log,(ddgo,=a(ddgolen2))   r8-r11.\n  mvc   ddgorgid,=cl7'R12-R15'        |        display and\n  callsub move_regs,(dbi1regs+(12*4),ddgorgs)   log registers\n  callsub display_and_log,(ddgo,=a(ddgolen2))   r12-r15.\n endblk block=display_debug_gdi       |\n         swa                          |\nddgo     equ   *                      |\nddgoc1   ds    c\"SRV1000I Error\"\nddgorc   ds    cl6                    |\nddgoc2   ds    c\" at offset +\"        |\nddgoofst ds    cl4                    |\nddgoc3   ds    c\" in \"                |\nddgomdid ds    cl47                   |\nddgolen1 equ   *-ddgo                 |\n         org   ddgo                   |\n         ds    c\"SRV1000I \"\nddgorgid ds    cl7                    |\n         ds    cl2                    |\nddgorgs  ds    cl(4*(8+1))            |\nddgolen2 equ   *-ddgo                 |\n         org   ,                      |\n         endswa ,                     |\n eject                                |\n*---------------------------------------------------------------------*\n*\n*  subroutine: move regs\n*  abstract:   move registers for display_debug_gdi subroutine\n*  inputs:     (address_of_four_regs,address_of_dest)\n*\n*---------------------------------------------------------------------*\n space 1                              |\n block name=move_regs,type=subroutine |\n  lm    r2,r3,0(r1)                   |\n  callsub convert_printable_hex,(0*4(r2),4,0*9(r3))\n  callsub convert_printable_hex,(1*4(r2),4,1*9(r3))\n  callsub convert_printable_hex,(2*4(r2),4,2*9(r3))\n  callsub convert_printable_hex,(3*4(r2),4,3*9(r3))\n endblk block=move_regs               |\n  eject                               |\n*---------------------------------------------------------------------*\n*\n*  subroutine: display_debug_text\n*  abstract:   display text type debug information\n*  inputs:     (address_of_dbi)\n*\n*---------------------------------------------------------------------*\n space 1                              |\n block name=display_debug_text,type=subroutine\n  l     r3,0(,r1)                     | point r3 to dbi\n  la    r3,dbi3-dbi(,r3)              | point r3 to name length\n  l8    r2,0(r3)                      | load length of name\n  st    r2,ddtlen                     | save it in pwa\n  la    r3,1(,r3)                     | point r3 past length\n  if (treg,r2,nz)                     | if length of name is nonzero\n   callsub display_and_log,((r3),ddtlen) display name\n   alr   r3,r2                        |  point r3 past name\n  endif                               | endif\n  callsub display_and_log,((r3))      | display text\n endblk block=display_debug_text      |\n         space 2                      |\n         swa ,                        |\nddtlen   ds    f                      |\n         endswa                       |\n eject                                |\n*---------------------------------------------------------------------*\n*\n*  subroutine: display_debug_hex\n*  abstract:   display hex type debug information\n*  inputs:     (address_of_dbi)\n*\n*---------------------------------------------------------------------*\n space 1                              |\n block name=display_debug_hex,type=subroutine\n  l     r3,0(,r1)                     | point r3 to dbi\n  la    r3,dbi4-dbi(,r3)              | point r3 to name length\n  l8    r2,0(r3)                      | load length of name\n  st    r2,ddhlen                     | save it in pwa\n  la    r3,1(,r3)                     | point r3 past length\n  if (treg,r2,nz)                     | if length of name is nonzero\n   callsub display_and_log,((r3),ddhlen)   display name\n   alr   r3,r2                        |  point r3 past name\n  endif                               | endif\n  l16   r2,0(r3)                      | load r2 with length hex data\n  la    r3,2(,r3)                     | point r3 past length\n  xc    ddhoffst,ddhoffst             | set offset to zero\n  loop while,(treg,r2,p)              | loop while hex data is left\n   lr    r4,r2                        |  load r4 with length remaining\n   if (ch,r4,gt,=h'16')               |  if r4 is greater than 16\n    la    r4,16                       |   set length to 16\n   endif                              |  endif\n   slr   r2,r4                        |  calculate next length\n   fill  ddho,x'40',length=(ddholen,s)   fill output line with spaces\n   mvi   ddhopls,c'+'                 |  move plus to output\n   mvi   ddhoast1,c'*'                |  move asterisk to output\n   mvi   ddhoast2,c'*'                |  move second asterisk to output\n   callsub convert_printable_hex,     |  convert and move offset       $\n               (ddhoffst,2,ddhoofst)  |   to output.\n   fill  ddhotran,c'.'                |  fill trans area with periods\n   lr    r1,r4                        |  put length in r1\n   bctr  r1,0                         |  sub 1 from length for ex\n   exi   r1,(mvc,ddhotran(*-*),0(r3)) |  move and translate unprintable\n   exi   r1,(tr,ddhotran(*-*),psd_printable_chars) characters to c'.'.\n   la    r5,ddhohex                   |  point r5 to printable hex out-\n   loop while,(treg,r4,p)             |  put area and loop converting.\n    lr    r0,r4                       |   set r0 to length to convert\n    if (ch,r0,gt,=h'4')               |   if length > 4\n     la    r0,4                       |    set length to 4\n    endif                             |   endif\n    st    r0,ddhlen                   |   save this length\n    slr   r4,r0                       |   calculate next remaining\n    callsub convert_printable_hex,    |   convert this piece to        $\n               ((r3),ddhlen,(r5))     |    printable hex\n    la    r5,9(,r5)                   |   point r5 to next output area\n    la    r3,4(,r3)                   |   point r3 to next piece\n   endloop while                      |  endloop\n   callsub display_and_log,(ddho,=a(ddholen)) display message\n   lh    r1,ddhoffst                  |  increment\n   la    r1,16(,r1)                   |   offset\n   sth   r1,ddhoffst                  |   by 16.\n  endloop while                       | endloop\n endblk block=display_debug_hex       |\n         swa ,                        |\nddhlen   ds     f                     |\nddhoffst ds     h                     |\nddho     equ    *                     |\n         ds     cl1' '                |\nddhopls  ds     cl1'+'                |\nddhoofst ds     cl4                   |\n         ds     cl2'  '               |\nddhohex  ds     cl35                  |\n         ds     cl2'  '               |\nddhoast1 ds     cl1'*'                |\nddhotran ds     cl16                  |\nddhoast2 ds     cl1'*'                |\nddholen  equ    *-ddho                |\n         endswa                       |\n eject                                |\n*---------------------------------------------------------------------*\n*\n*  subroutine: convert_printable_hex\n*  abstract:   convert storage to printable hex.\n*  inputs:     (source,length_of_storage,destination)\n*  note:       length should be no greater than 4.\n*\n*---------------------------------------------------------------------*\n space 1                              |\n block name=convert_printable_hex,type=subroutine\n  lm    r3,r5,0(r1)                   | point r3 to source\n*                                     | point r5 to destination\n  l     r4,0(,r4)                     | load r4 with length of source\n  bctr  r4,0                          | sub 1 from length for exi\n  exi   r4,(mvc,chptemp1(*-*),0(r3))  | move source to temp storage\n  unpk  chptemp2,chptemp1             | unpack it\n  tr    chptemp2,psd_prt_hex_table    | translate it to printable\n  sla   r4,1                          | calculate:\n  la    r4,1(,r4)                     |   2 * length - 1\n  exi   r4,(mvc,0(*-*,r5),chptemp2)   | move result to destination\n endblk block=convert_printable_hex   |\n  space 1                             |\n         swa                          |\nchptemp1 ds    cl5                    | one more than max length\nchptemp2 ds    cl9                    | area to unpack into\n         endswa                       |\n eject                                |\n*---------------------------------------------------------------------*\n*\n*  subroutine: display_and_log\n*  abstract:   issue a message and log it to syslog\n*  inputs:     (address_of_message,length_of_message)\n*              if the second parameter is not specified, the message\n*              is assumed to have a halfword length of the message\n*              as a prefix.\n*\n*---------------------------------------------------------------------*\n block name=display_and_log,type=subroutine\n   if (tbit,0(r1),x'80',OFF)          | If explicit length.\n     lm    r3,r4,0(r1)                |   r3->text, r4->length.\n   else                               | Else.\n     l     r3,0(,r1)                  |   r3 -> prefixed message.\n     l16   r0,0(r3)                   |   r0 := message length.\n     st    r0,pwa_dm_len              |   Convert to fullword.\n     la    r3,2(,r3)                  |   r3 -> message text.\n     la    r4,pwa_dm_len              |   r4 -> message length.\n   endif                              | EndIf.\n   if (clc,pwa_msg_epa,eq,=f'0')      |   If issue-message missing.\n     la      r15,&es_missing_exit_routine   Set return code.\n   else                               |   Else.\n     callx   pwa_msg_epa,(pwa_msg_token,pwa_xnfo,(r3),(r4))\n*    R15 = whatever the exit set it to, which by definition should\n*    be a valid Environment Support return code.\n   endif                              |   EndIf.\n endblk block=display_and_log\n eject\n**--------------------------------------------------------------------*\n**  do basic r-form getmain and return.  address of storage is\n**  returned in r1.\n**--------------------------------------------------------------------*\n block type=subroutine,name=linkage_getmain,                           $\n               options=(*nosubopts,saveusing)\n  using linkage_getmain,r15           | establish base\n  getmain r,lv=(0)                    | get storage\n endblk block=linkage_getmain         |\n space 3                              |\n**--------------------------------------------------------------------*\n**  do basic r-form freemain and return.\n**--------------------------------------------------------------------*\n block type=subroutine,name=linkage_freemain,                          $\n               options=(*nosubopts,saveusing)\n  freemain r,lv=(0),a=(1)             | free storage\n endblk block=linkage_freemain        |\n         title \"Program Static Data and symbols\"\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Program Static Data and Equates.                                   *\n*                                                                     *\n*---------------------------------------------------------------------*\ndebug_area_size equ 4096              | debug area size\n         psd   ,                      |\n         ltorg ,                      |\npsd_time_mask dc x'4021207a20207a20204b2020'   hh:mm:ss.th\npsd_ccyyddd_mask dc x'40212020204b202020'      ccyy.ddd\npsd_prt_hex_table equ *-c'0'          |\n         dc    c'0123456789abcdef'    |\npsd_printable_chars equ *             |\n*                 0 1 2 3 4 5 6 7 8 9 a b c d e f\n         dc    x'4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b' 0\n         dc    x'4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b' 1\n         dc    x'4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b' 2\n         dc    x'4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b' 3\n         dc    x'404b4b4b4b4b4b4b4b4b4a4b4c4d4e4f' 4\n         dc    x'504b4b4b4b4b4b4b4b4b5a5b5c5d5e5f' 5\n         dc    x'60614b4b4b4b4b4b4b4b4b6b6c6d6e6f' 6\n         dc    x'4b4b4b4b4b4b4b4b4b4b7a7b7c7d7e7f' 7\n         dc    x'4b8182838485868788894b4b4b4b4b4b' 8\n         dc    x'4b9192939495969798994b4b4b4b4b4b' 9\n         dc    x'4b4ba2a3a4a5a6a7a8a94b4b4b4b4b4b' a\n         dc    x'4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b' b\n         dc    x'4bc1c2c3c4c5c6c7c8c94b4b4b4b4b4b' c\n         dc    x'4bd1d2d3d4d5d6d7d8d94b4b4b4b4b4b' d\n         dc    x'4b4be2e3e4e5e6e7e8e94b4b4b4b4b4b' e\n         dc    x'f0f1f2f3f4f5f6f7f8f94b4b4b4b4b4b' f\n         space 1                      |\n         macro                        |\n&name    msg   &msg                   |\n&name    dc    al2(&name._message_length)\n         dc    c&msg                  |\n&name._message_length equ *-&name-2   |\n         mend                         |\n         space 1                      |\nmsg_invalid_debug_info      msg \"SRV1000I Debug area contains invalid i$\n               nformation\"\nmsg_no_debugging_info       msg \"SRV1001I No debugging information is a$\n               vailable\"\nmsg_debugging_info_lost     msg \"SRV1002I Debugging information was los$\n               t\"\nmsg_debug_area_full         msg \"SRV1003I Debugging area is full\"\nmsg_debug_wrong_parms       msg \"SRV1004I Invalid parameters passed to $\n               Save_Debug_Information\"\nmsg_debug_bad_length        msg \"SRV1005I Invalid length passed in debu$\n               g information\"\nmsg_debug_invalid_type      msg \"SRV1006I Invalid debug type\"\n         space 5                      |\n         endpsd                       |\n         title \"Program Work Area\"\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Program Work Area                                                  *\n*                                                                     *\n*---------------------------------------------------------------------*\n                    pwa   ,     | Program Work Area\n*\npwa_oc_mnt          ds    x     | Option: &ES_OC_ STDMNT/NOSTDMNT\n*\npwa_#parms          ds    f     | Count of parameters passed in.\npwa_xnfo            ds    a     | -> Exit Information word.\npwa_msg_epa         ds    a     | EPA of Issue_Message routine.\npwa_msg_token       ds    f     | Token for Issue_Message routine.\npwad     ds    d     work doubleword  |\npwaaesv  ds    a     address of service processor global area\npwafsle  ds    a     address of first service load entry\npwaaamnt ds    a     address of application module name table\npwaasmnt ds    a     address of standard module name table\npwawepa  ds    a     entry point address work field\n         es_gdi dsect=no              |\npwawork  ds    cl133                  |\n         ds    0f                     |\npwawmnt  ds    xl(mntcblen)           |\npwafswa  ds    0f                     | function specific work area\n  aif (not &srv_clemson).skip8\n         org   pwafswa                | org to start of work area\npwac00   ds    0f,xl(c00enlen)        |\n.skip8   anop\n         org   pwafswa                | org to start of work area\npwa_dec_time  ds f                    |\npwa_yyddd     ds f                    |\npwa_ccyyddd   ds f                    |\npwa_time_mask    ds xl(l'psd_time_mask)\npwa_ccyyddd_mask ds xl(l'psd_ccyyddd_mask)\n         org   pwafswa                | org to start of work area\npwa_dm_len    ds f                    | Length for Display message.\n         org   ,                      | org to end of work area\n         endpwa                       |\n         title \"DSECTS\"               |\n*---------------------------------------------------------------------*\n*\n* Dsects.\n*\n*---------------------------------------------------------------------*\n         es_parmlist ,                |\n         iefjssob ,                   |\n         ihaasxb ,                    |\n         ihaascb ,                    |\n         ihaacee ,                    |\n         ikjeflwa ,                   |\n         ikjpscb ,                    |\n         ikjupt ,                     |\nucb      dsect ,                      |\n         iefucbob ,                   |\n         cvt   dsect=yes              |\n  aif (not &srv_clemson).skip6\n         raciep ,                     |\n         jesc00 ,                     |\n.skip6   anop\n         es_esv ,                     |\n         es_mnt id=mnt                |\n         es_dbi ,                     |\n         end   ,                      |\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SRVESX01": {"ttr": 20744, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x02\\x00\\x00W\\x01\\x11)\\x9f\\x01\\x11)\\x9f\\t'\\x00\\x8e\\x00\\x8e\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@\"", "ispf": {"version": "02.00", "flags": 0, "createdate": "2011-10-26T00:00:00", "modifydate": "2011-10-26T09:27:57", "lines": 142, "newlines": 142, "modlines": 0, "user": "CLEMSON"}, "text": "*---------------------------------------------------------------------*\n*  Copyright 2011 by Clemson University Research Foundation           *\n*                                                                     *\n*  Licensed under the Apache License, Version 2.0 (the \"License\");    *\n*  you may not use this file except in compliance with the License.   *\n*  You may obtain a copy of the License in this library as member     *\n*  $LICENSE, or from                                                  *\n*                                                                     *\n*      http://www.apache.org/licenses/LICENSE-2.0                     *\n*                                                                     *\n*  Unless required by applicable law or agreed to in writing,         *\n*  software distributed under the License is distributed on an \"AS    *\n*  IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either    *\n*  express or implied.  See the License for the specific language     *\n*  governing permissions and limitations under the License.           *\n*---------------------------------------------------------------------*\n         SMLIST CONVERT=YES\nSRVESX01 TITLE  \"MVS Environment Support Message Issuer Routine\"\n         srvmod name=srvesx01,dates='1989, 1990, 1995'\n         gblc  &srv_modname\n*---------------------------------------------------------------------*\n*\n*  Copyright (C) Clemson University Research Foundation 1989, 1990.\n*\n*  Program     SRVESX01\n*\n*  Abstract    Issue_Message routine for MVS Environment Support.\n*\n*  Parameters  (Token, Info (ignored), Text, Length)\n*\n*  Return   Exit routines use the same set of return codes that the\n*  Codes    main Environment Support modules uses.  For those errors\n*           that are a result of Environment Support calling the exit\n*           incorrectly, a return code of ES_INTERNAL_ERROR is used and\n*           Environment Support is expected to perform the equivalent\n*           of an ES_DISPLAY_DEBUG_INFO_AND_ABEND.\n*\n*  Program     Reentrant, problem key and state, standard linkage,\n*  Attributes  non-authorized, AMODE(31), RMODE(ANY)\n*\n*  Change\n*  History   2011/10/20 JCB - Patch rollup for CBT tape distribution\n*\n*---------------------------------------------------------------------*\n copy  smsyms                      Get Structured Macros symbols.\n copy  srvesmac                    Get Environment Support symbols.\n eject\n block type=program,name=&srv_modname,amode=31,rmode=any,              +\n               parms=(Token,Info,Message,Length),                      +\n               options=(*pwa,(reuspwa,1),xa,codebase,                  +\n               (parms,prefix,(using,r11),(count,pwa_#parms),vl)),      +\n               subopts=(*swa)\n*---------------------------------------------------------------------*\n*  Copy the provided message to local working storage.\n*---------------------------------------------------------------------*\n   l32 r2,&ppl.Message             | r2 -> Message text.\n   l32 r3,&ppl.Length              | r3 -> Message length.\n   l   r3,0(r3)                    | r3 := Message length.\n   if (ch,r3,gt,=y(l'pwa_work-4))  | If length larger than work area.\n    lh  r3,=y(l'pwa_work-4)        |   Truncate length to its size.\n   endif                           | EndIf.\n   la  r1,4(,r3)                   | r1 := length of msg & header.\n   stcm r1,b'0011',pwa_work        | Save in output line descriptor.\n   mvc pwa_work+2(2),=h'0'         | Set offset to zeros.\n   la  r14,pwa_work+4              | Point r14 to work area.\n   lr  r15,r3                      | Load r15 with message length.\n   mvcl r14,r2                     | Move message to work area.\n*---------------------------------------------------------------------*\n*  If running under interactive TSO, use PUTLINE to issue the message.\n*---------------------------------------------------------------------*\n   lcba r1,asxb                    | r1 -> address space extension.\n   icm r1,b'1111',asxblwa-asxb(r1) | r1 -> logon work area.\n   if nz                           | if LWA exists, use Putline.\n     xc  pwa_ecb,pwa_ecb           |   Clear Putline's ECB.\n     mvc pwa_ptpb,psd_ptpb         |   Establish parameter block.\n     l   r2,lwapect-lwa(,r1)       |   r2-> environment ctl blk.\n     l   r3,lwapscb-lwa(,r1)       |   r3-> protected step ctl blk.\n     l   r3,pscbupt-pscb(,r3)      |   r3-> user profile table.\n     putline parm=pwa_ptpb,        |                                   +\n               upt=(r3),           |                                   +\n               ect=(r2),           |     Invoke PUTLINE service.       +\n               ecb=pwa_ecb,        |                                   +\n               output=(pwa_work,term,single,data),                     +\n               mf=(e,pwa_putline)  |\n     if (treg,r15,nz)              |   If something went wrong.\n       if (c,r15,eq,=f'4')         |     If Attn interrupt\n         sbit pwa_f,pwa_f_interrupt      Remember that it happened.\n         la   r15,&es_undetermined |       Set return code.\n       elseif (c,r15,eq,=f'20')    |     ElseIf terminal disconnect.\n         la   r15,&es_undetermined |       Set return code.\n       elseif (c,r15,eq,=f'8'),or, |     ElseIf NOWAIT specified or    +\n               (c,r15,eq,=f'12')   |       Invalid parms.\n         la r15,&es_internal_error         Set return code.\n       elseif (c,r15,eq,=f'16')    |     ElseIf out of storage.\n         la r15,&es_storage_not_available  Set return code.\n       else                        |     Else, undetermined.\n         la r15,&es_undetermined   |       Set return code.\n       endif                       |     EndIf.\n     endif                         |   EndIf.\n     leave block=*                 |   Return to caller.\n   endif                           | Endif.\n*---------------------------------------------------------------------*\n*  Use WTO to write the message to the job-log.\n*---------------------------------------------------------------------*\n   wto mf=(e,pwa_work)             | Write message to job log.\n   slr r15,r15                     | Set final return code.\n endblk block=&srv_modname,rc=(r15)\n eject\n*---------------------------------------------------------------------*\n*                                                                     *\n* Program Static Data                                                 *\n*                                                                     *\n*---------------------------------------------------------------------*\n                     psd\n                     ltorg\npsd_ptpb             putline mf=l\nptpb_len             equ     *-psd_ptpb\n                     endpsd\n*---------------------------------------------------------------------*\n*                                                                     *\n* Program Work Area                                                   *\n*                                                                     *\n*---------------------------------------------------------------------*\n                     pwa\npwa_#parms           ds     f            | Count of parms passed in.\npwa_f                ds     x            | Status flags.\npwa_f_interrupt      equ    x'80'        |   Attention ocurred.\npwa_ecb              ds     f            | ECB for putline use.\npwa_ptpb             ds     cl(ptpb_len) | PutLine parameter block.\npwa_putline          ds     cl(10*4)     | PutLine parameter list.\npwa_work             ds     cl4004       | Message descriptor.\n                     endpwa\n                     eject\n*---------------------------------------------------------------------*\n*                                                                     *\n* Mapping DSECTs.                                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n                  ihaasxb  ,\n                  ikjeflwa ,\n                  ikjpscb  ,\n                  end\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SRVFIA24": {"ttr": 20748, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x02\\x00\\x00W\\x01\\x11)\\x9f\\x01\\x11)\\x9f\\t'\\x0e\\x8e\\x0e\\x8e\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@\"", "ispf": {"version": "02.00", "flags": 0, "createdate": "2011-10-26T00:00:00", "modifydate": "2011-10-26T09:27:57", "lines": 3726, "newlines": 3726, "modlines": 0, "user": "CLEMSON"}, "text": "*---------------------------------------------------------------------*\n*  Copyright 2011 by Clemson University Research Foundation           *\n*                                                                     *\n*  Licensed under the Apache License, Version 2.0 (the \"License\");    *\n*  you may not use this file except in compliance with the License.   *\n*  You may obtain a copy of the License in this library as member     *\n*  $LICENSE, or from                                                  *\n*                                                                     *\n*      http://www.apache.org/licenses/LICENSE-2.0                     *\n*                                                                     *\n*  Unless required by applicable law or agreed to in writing,         *\n*  software distributed under the License is distributed on an \"AS    *\n*  IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either    *\n*  express or implied.  See the License for the specific language     *\n*  governing permissions and limitations under the License.           *\n*---------------------------------------------------------------------*\n**********************************************************************\n**\n** This is a copy of SRVFIOS before it was converted to AMODE=31.\n**\n**********************************************************************\n            SMLIST CONVERT=YES\nSRVFIOS     title \"File service processor\"\n         srvmod name=srvfios,dates='1987, 1990, 1993, 1995, 2001'\n*\n*\n*  WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING\n*\n*  For performance reasons, this module does NOT use COPY in the\n*  options statement to copy incoming parameters.  If you want to check\n*  a parm to see if it is actually present, you must do it the old\n*  fashioned way: check the high-order bit of the last non-optional\n*  parm and go forward from there.....mjm 2001-08-13.\n*\n*  WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING\n*\n*---------------------------------------------------------------------*\n*\n*  Copyright (C) Clemson University Research Foundation 1987, 2001.\n*\n*  Program     SRVFIOS\n*\n*  Abstract    SRVFIOS reads from and writes to sequential files with\n*              either fixed length or varying length records. Programs\n*              can use SRVFIOS to read from a file or write records to\n*              a file without having to know anything more than the\n*              file's data set name or ddname.  All records passed\n*              between the file server and its caller are in the form\n*              of a varying length string, regardless of the actual\n*              characteristics of the file being accessed.\n*\n*  Parameters:\n*    Documented in the Service Processors Guide & Reference.\n*\n*  Program     reentrant, problem key and state, standard linkage,\n*  Attributes  non-authorized, amode(any), rmode(24)\n*\n*  Special     1. This program depends on the PWA being automatically\n*  Notes          cleared to all-zeros by the BLOCK macro when it is\n*                 first allocated during start-up.\n*              2. This program runs below the 16-megabyte line because\n*                 it uses standard I/O macros.  However, it expects to\n*                 be called with Amode=31.\n*              3. For sequential input, the data set is dynamically\n*                 allocated with a disposition of SHR, causing the\n*                 following enqueue to be performed:\n*\n*                 ENQ SYSDSN,CL44(dsname),S,44,SYSTEM\n*\n*                 For sequential output, if the data set exists,\n*                 dynamic allocation is invoked again to change the\n*                 disposition to OLD.  If the data set does not exist,\n*                 dynamic allocation is invoked with a disposition of\n*                 NEW to create it.  In either case, the following\n*                 enqueue results:\n*\n*                 ENQ SYSDSN,CL44(dsname),S,44,SYSTEM\n*\n*                 The above enqueues are implicitly performed as a\n*                 result of dynamic allocation.  In addition, if output\n*                 is being done to a member of a partitioned data set,\n*                 the following enqueue is explicitly performed:\n*\n*                 ENQ SPFEDIT,'CL44(dsname),CL8(member)',E,52,SYSTEMS\n*\n*  Change\n*  History   2011/10/20 JCB - Patch rollup for CBT tape distribution\n*\n*---------------------------------------------------------------------*\n EJECT\n print off\n copy  smsyms    | Obtain Structured Macros symbols.\n copy  srvesmac  | Obtain Environment Support symbols & macros.\n copy  srvstmac  | Obtain String Handler symbols & macros.\n copy  srvfimac  | Obtain File Handler symbols & macros.\n copy  smpucond  | Obtain User Conditions.\n print on,gen\n EJECT\n*---------------------------------------------------------------------*\n*\n*  Macro:      TEXT_UNIT Key,(Parm 1,Parm 2,...)\n*  Purpose:    Define storage for a dynamic allocation text unit. The\n*              value used for Key should be the name of a dynamic\n*              allocation verb defined in IEFZB4D0. The values used for\n*              Parm-n must be such that when used on a DC instruction,\n*              they will not cause alignment and will produce the\n*              correct length value for L' attributes.\n*\n*---------------------------------------------------------------------*\n                macro\n&label          text_unit &key,&parm\n                lcla &n,&i\n&n              seta n'&parm                    number of parms.\n&label._key     dc  al2(&key)                   dynalloc text unit key.\n&label._count   dc  al2(&n)                     number of parameters.\n&i              seta 1\n.parm_loop      aif (&i gt &n).noparm\n                dc  al2(l'&label._parm&i)       length of parameter.\n&label._parm&i  dc  &parm(&i)                   value of parameter.\n&i              seta &i+1\n                ago  .parm_loop\n.noparm         anop\n&label          equ &label._key,*-&label._key,c'c'  text unit storage.\n                mend\n eject\n***********************************************************************\n***********************************************************************\n**                                                                   **\n**                                                                   **\n**                      SRVFIOS Main Program                         **\n**                                                                   **\n**                                                                   **\n***********************************************************************\n***********************************************************************\n         gblb   &security_check\n&security_check setb 0        << PERMANENT: Allow S913 instead of\n*                                trying to detect RACF security\n*                                violations and issue a message.\n*\n block name=srvfios,type=program,amode=31,rmode=24,                    +\n               options=(*srvprc,main,dyn,long),r1save=r9,           @DD+\n               subopts=(*swa,loadbase)\n   es_id id=es,spepa=pwa_esepa,sptoken=pwa_estkn,esva=pwaaesv\n   st_id id=st,spepname=&string_handler,sizelength=4,                  +\n               spepa=pwa_st_spepa,sptoken=pwa_st_sptoken\n*                                     |\n   using fi_parmlist,r9               | Establish addressability.\n   mvc   gdirc,=h'0'                  | Clear out return-code.\n*---------------------------------------------------------------------*\n*  If the function code is something other than start, make sure that\n*  the PWA contains the eye-catcher string and the correct value for\n*  FileID.  If not, then the FileID passed in is garbage.\n*---------------------------------------------------------------------*\n   l  r2,fi_functioncode              | R2 -> Fullword function code.\n   l  r1,0(r2)                        | R2 := function code.\n   if (cl,r1,ne,=f'&start')           | If not startup function then\n     if ((clc,pwa_visual,ne,eyecatcher),or,(c,r13,ne,pwa_fileid))\n       errexit code=&fi_invalid_fileid\n     elseif (tbit,pwa_1_error)        |\n       caseblk reg=r1,mult=1          |     Case on function-code.\n         case &terminate,&fi_get_info,&fi_get_reference\n         case other                   |       Die on anything else.\n           callsub message,(fi00004)  |\n           errexit code=0             |\n       endcase                        |     EndCase.\n     endif                            |   Endif.\n   endif                              | Endif.\n*---------------------------------------------------------------------*\n*  Use the FunctionCode to determine which subroutine to invoke.\n*---------------------------------------------------------------------*\n   l  r1,0(r2)                        | R1 := function code.\n*                                     |\n   caseblk reg=r1,mult=1              | Case on FunctionCode.\n     case &start                      |   Open a new file.\n       callsub start                  |\n     case &terminate                  |   Terminate file handler.\n       callsub terminate              |     Kill file and buffers.\n       smctrl  freepwa=yes            |     Release the PWA on exit.\n     case &fi_open                    |   Open the file.\n       callsub open_parm              |     Process open parameters.\n       callsub open                   |     Open file.\n     case &fi_close                   |   Close the file.\n       callsub close                  |\n     case &fi_delete                  |   Delete the file.\n       callsub delete                 |\n     case &fi_readline                |   Read the next line.\n       callsub readline               |\n     case &fi_writeline               |   Read the next line.\n       callsub writeline              |\n     case &fi_get_info                |   Obtain information.\n       callsub get_info               |\n     case &fi_set_status              |   Set file status information.\n       callsub set_status             |\n     case &fi_get_reference           |   Obtain information.\n       callsub get_reference          |\n     case &fi_find                    |   Find.\n       callsub find                   |\n     case other                       |   Invalid function code.\n       callsub message,(fi00005,0(r2))\n       errexit code=0                 |\n   endcase                            | EndCase.\n*                                     |\n   lh      r15,gdirc                  | R15 := return code.\n endblk block=srvfios                 | Quit w/possible return code.\n eject\n***********************************************************************\n*                                                                     *\n*  Subroutine: START                                                  *\n*  Abstract:   Open a file for the type of access requested. The only *\n*              access modes supported are sequential input or output. *\n*                                                                     *\n***********************************************************************\n block name=start,type=subroutine\n*  *------------------------------------------------------------------*\n*  * All fields in the PWA have already been initialized to zeros by\n*  * the block macro.  Initialize those fields that must be non-zero\n*  *------------------------------------------------------------------*\n   mvc   pwa_visual,eyecatcher          | Eyecatcher and fileid are for\n   st    r13,pwa_fileid                 | validity checks and dumps.\n   l     r2,pwaaesv                     | R2 -> ESV.\n   using esv,r2                         | Establish addressability.\n   mvc   pwa_esepa,esvesepa             | Get Environment Support EPA.\n   mvc   pwa_estkn,esvestkn             | Get Env Support TOKEN.\n   drop  r2                             | Drop addressability.\n*                                       |\n   fill  pwa_ddname,c' '                | Clear out the DDNAME.\n   fill  pwa_dsname,c' '                | Clear out the DSNAME.\n   fill  pwa_member,c' '                | Clear out the MEMBER.\n   fill  pwa_volser,c' '                | Clear out the VOLSER.\n   fill  pwa_sysoutclass,c' '           | Clear out the SYSOUTCLASS.\n   fill  pwa_unitname,c' '              | Clear out the UNITNAME.\n   fill  pwa_userid,c' '                | Set the default userid value.\n   mvc   pwa_fi_reference(12),=c\"Unknown file\" | Initialize ref string\n   mvc   pwa_avglrecl,=f'0'             | Initialize to 0 (missing)\n   mvc   pwa_maxlrecl,=f'0'             | Initialize to 0 (missing)\n   mvc   pwa_sizeinit,=f'1000'          | Default SizeInit = 1000.\n   mvc   pwa_sizeincr,=f'1000'          | Default SizeIncr = 1000.\n*                                       |\n   la    r1,pwa_textunits+l'pwa_textunits-4\n   st    r1,pwa_textunits_end\n*                                       |\n   es_get_userid id=es,userid=pwa_userid   Attempt to get the real one.\n*                                       |\n*  *------------------------------------------------------------------*\n*  * Load and start the string-handler for use in message formatting.\n*  *------------------------------------------------------------------*\n   es_load_module id=es,spid=st         | Load String Handler module.\n   if (treg,r15,nz),then                | If string-handler not loaded\n     st   r15,pwa_save_r15              | Preserve r15 for errexit\n     callsub message,(fi00023)          |   Unable to load.\n     l    r15,pwa_save_r15              | Rest r15 for debug analysis\n     errexit code=0                     |\n   endif                                | EndIf.\n   st_start id=st                       | Start the String Handler.\n   if (treg,r15,nz),then                | If string-handler \u00acstarted.\n     st   r15,pwa_save_r15              | Preserve r15 for errexit\n     callsub message,(fi00024)          |   Unable to start.\n     l    r15,pwa_save_r15              | Rest r15 for debug analysis\n     errexit code=0                     |\n   endif                                | EndIf.\n*  *------------------------------------------------------------------*\n*  * Insure that required parameters were specified for FI_START.\n*  *------------------------------------------------------------------*\n   if not,((tbit,fi_fileid,x'80',off),and,         Make sure fileid,   +\n               (tbit,fi_functioncode,x'80',off),and,    functioncode,  +\n               (tbit,fi_esv,x'80',off),and,             esv, info,     +\n               (tbit,fi_info,x'80',off),and,            filename,      +\n               (tbit,fi_filename,x'80',off),and,        namelength,    +\n               (tbit,fi_namelength,x'80',off))      and options present\n     callsub message,(fi00006,'start',5) |   Issue an error message.\n     errexit code=0                      |\n   endif                                 | EndIf.\n*  *------------------------------------------------------------------*\n*  * Process the OPTIONS parameter.\n*  *------------------------------------------------------------------*\n*\n*  Make sure that all reserved OPTIONS flags are zeros.\n*\n   l  r2,fi_options                      | R2 -> options parameter.\n   la r2,0(r2)                           | Get rid of VL bit if any.\n   if (treg,r2,z)                        | If OPTIONS not supplied.\n     callsub message,(fi00007,,0)        |   Issue an error message.\n     errexit code=0                      |\n   elseif (tbit,0(r2),&fi_oc_reserved,any)\n     callsub message,(fi00007,0(r2),1)   |   Issue an error message.\n     errexit code=0                      |\n   else                                  |\n     mvc   pwa_oc_xopt,0(r2)             | Save XOPT flag.\n     ni    pwa_oc_xopt,&fi_oc_xopt       | Mask off other bits.\n     if    (cli,pwa_oc_xopt,eq,&fi_oc_xoptword)\n       if  (tbit,1(r2),&fi_oc2_reserved,any),or,                       +\n               (tbit,2(r2),&fi_oc3_reserved,any),or,                   +\n               (tbit,3(r2),&fi_oc4_reserved,any)\n         callsub message,(fi00007,0(r2),4)\n         errexit code=0\n       endif\n     endif\n   endif                                 | EndIf.\n*\n*  Separate the option-flags to make checking for specific values\n*  and combinations of values easier.\n*\n   mvc   pwa_oc_mode,0(r2)               | Save INPUT/OUTPUT flag.\n   ni    pwa_oc_mode,&fi_oc_mode         | Mask off other bits.\n   mvi   pwa_oo_mode,&fi_oo_input        | Set OO_MODE\n   if (cli,pwa_oc_mode,eq,&fi_oc_output)   to reflect\n    mvi   pwa_oo_mode,&fi_oo_output      | status of\n   endif                                 | INPUT/OUTPUT flag.\n   mvc   pwa_oc_ident,0(r2)              | Save FILENAME/FILEID flag.\n   ni    pwa_oc_ident,&fi_oc_ident       | Mask off other bits.\n   mvc   pwa_oc_filetempx,0(r2)          | Save FILETEMP flag.\n   ni    pwa_oc_filetempx,&fi_oc_filetempx Mask off other bits.\n   mvc   pwa_oc_disp,0(r2)               | EXISTING/NEW/REPLACE/APPEND.\n   ni    pwa_oc_disp,&fi_oc_disp         | Mask off other bits.\n   mvc   pwa_oc_recfm,0(r2)              | Save FIXED/VARIABLE flag.\n   ni    pwa_oc_recfm,&fi_oc_recfm       | Mask off other bits.\n   mvc   pwa_oc_open,0(r2)               | Save OPEN=AUTO|MANUAL flag.\n   ni    pwa_oc_open,&fi_oc_open         | Mask off other bits.\n*\n   if (cli,pwa_oc_xopt,eq,&fi_oc_xoptword) If extended options\n     mvc   pwa_oc2_free,1(r2)            |   Save FREE flag.\n     ni    pwa_oc2_free,&fi_oc2_free     |   Mask off other bits.\n     mvc   pwa_oc2_cc,1(r2)              |   Save ISOCC flag.\n     ni    pwa_oc2_cc,&fi_oc2_cc         |   Mask off other bits.\n     mvc   pwa_oc2_sysoutx,1(r2)         |   Save SYSOUT flag.\n     ni    pwa_oc2_sysoutx,&fi_oc2_sysoutx   Mask off other bits.\n     mvc   pwa_oc2_chkpdsmemx,1(r2)      |   Save CHKPDSMEM flag.\n     ni    pwa_oc2_chkpdsmemx,&fi_oc2_chkpdsmemx Mask off other bits.\n*\n     if (tbit,1(r2),&fi_oc2_ascii,on)    |   If ASCII option specified.\n      sbit pwa_2_ascii                   |    Turn on pwa flag.\n     endif                               |   EndIf.\n     mvc   pwa_oc2_library,1(r2)         |   Save LIBRARY flag.\n     ni    pwa_oc2_library,&fi_oc2_library   Mask off other bits.\n   endif                                 | EndIf.\n*\n*  Check for invalid combinations of options.\n*\n   if (cli,pwa_oo_mode,eq,&fi_oo_input)  | If INPUT access mode.\n     if (cli,pwa_oc_disp,ne,&fi_oc_existing) If not EXISTING file.\n       callsub message,(fi00032)         |     Issue an error message.\n       errexit code=0                    |     Exit w/return-code.\n     endif                               |   EndIf.\n   endif                                 | EndIf.\n   if (cli,pwa_oo_mode,eq,&fi_oo_output) | If OUTPUT access mode.\n     if (cli,pwa_oc2_library,eq,&fi_oc2_library) If LIBRARY option.\n       callsub message,(fi00033,         |     Issue an error message. +\n               'LIBRARY and OUTPUT',18)  |\n       errexit code=0                    |     Exit w/return-code.\n     endif                               |   EndIf.\n   endif                                 | EndIf.\n*  *------------------------------------------------------------------*\n*  * Process optional START parameters (OUTPUT mode only)\n*  *------------------------------------------------------------------*\n   block type=inline,name=&s.optional_start_parms\n    if (tbit,fi_options,x'80',on)\n     leave block=&s.optional_start_parms\n    endif\n    if (cli,pwa_oo_mode,eq,&fi_oo_input) | If INPUT mode.\n     if (tbit,fi_options,x'80',off)      |  If parm(s) follow options.\n       callsub message,(fi00034)         |   Issue an error message.\n       errexit code=0                    |   Exit w/return-code.\n     endif                               |  EndIf.\n    endif                                | EndIf.\n*   *-----------------------------------------------------------------*\n*   * Process RECORDLENGTH=(average <,maximum>)\n*   *     and FILESIZE=(initial <,increment>).\n*   *-----------------------------------------------------------------*\n    l   r1,fi_avg_reclen                 | r1 -> Avg_reclen parm.\n    la  r1,0(,r1)                        | Toss high-order bit.\n    if  (treg,r1,p)                      | If still non-zero address\n      l  r1,0(,r1)                       |   r1 := avg_reclen parm.\n      if (treg,r1,p)                     |   If value is non-zero.\n        st r1,pwa_avglrecl               |     Save in PWA.\n      endif                              |   EndIf.\n    endif                                | EndIf.\n*                                        |\n    if (tbit,fi_avg_reclen,x'80',on)     | If end of parms.\n     leave block=&s.optional_start_parms |  Done with parms.\n    endif                                | EndIf.\n*                                        |\n    l   r1,fi_max_reclen                 | r1 -> Max_reclen parm.\n    la  r1,0(,r1)                        | Toss high-order bit.\n    if  (treg,r1,p)                      | If still non-zero address\n      l  r1,0(,r1)                       |   r1 := max_reclen parm.\n      if (treg,r1,p)                     |   If value is non-zero.\n        st r1,pwa_maxlrecl               |     Save in PWA.\n      endif                              |   EndIf.\n    endif                                | EndIf.\n*                                        |\n    if (tbit,fi_max_reclen,x'80',on)     | If end of parms.\n     leave block=&s.optional_start_parms |  Done with parms.\n    endif                                | EndIf.\n*                                        |\n    l   r1,fi_size_initial               | r1 -> Initial size parm.\n    la  r1,0(,r1)                        | Toss high-order bit.\n    if  (treg,r1,p)                      | If still non-zero.\n      l  r1,0(,r1)                       |   r1 := initial size.\n      if (treg,r1,p)                     |   If value is non-zero.\n        st r1,pwa_sizeinit               |     Save in PWA.\n      endif                              |   EndIf.\n    endif                                | EndIf.\n*                                        |\n    if (tbit,fi_size_initial,x'80',on)   | If end of parms.\n     leave block=&s.optional_start_parms |  Done with parms.\n    endif                                | EndIf.\n*                                        |\n    l   r1,fi_size_increment             | r1 -> Increment size parm.\n    la  r1,0(,r1)                        | Toss high-order bit.\n    if  (treg,r1,p)                      | If still non-zero.\n      l  r1,0(,r1)                       |   r1 := increment size.\n      if (treg,r1,p)                     |   If value is non-zero.\n        st r1,pwa_sizeincr               |     Save in PWA.\n      endif                              |   EndIf.\n    endif                                | EndIf.\n*                                        |\n    if (tbit,fi_size_increment,x'80',on) | If end of parms.\n     leave block=&s.optional_start_parms |  Done with parms.\n    endif                                | EndIf.\n*   *-----------------------------------------------------------------*\n*   * Process REFERENCE string.\n*   *-----------------------------------------------------------------*\n    l   r1,fi_reference                  | r1 -> reference.\n    la  r1,0(,r1)                        | Discard high order bit.\n    if (treg,r1,nz)                      | If nonzero\n     mvc pwa_fi_reference,0(r1)          |   Save in PWA.\n     sbit pwa_2_reference_supplied       |   Set flag in pwa.\n    endif                                | EndIf.\n   endblk block=&s.optional_start_parms\n*  *------------------------------------------------------------------*\n*  * If neither avg or max specified, supply default values.  If only\n*  * one value supplied, use that same value for both avg and max.\n*  *------------------------------------------------------------------*\n   l  r2,pwa_avglrecl                    |  r2 := avg lrecl.\n   l  r3,pwa_maxlrecl                    |  r3 := max lrecl.\n   if (treg,r2,z),and,(treg,r3,z)        |  If neither parm specified.\n     mvc pwa_avglrecl,=f'80'             |    Default AvgLrecl = 80.\n     mvc pwa_maxlrecl,=f'251'            |    Default MaxLrecl = 251.\n   elseif (treg,r2,p),and,(treg,r3,z)    |  ElseIf only avg specified.\n     st  r2,pwa_maxlrecl                 |    Set maxlrecl = avglrecl.\n   elseif (treg,r2,z),and,(treg,r3,p)    |  ElseIf only max specified.\n     st  r3,pwa_avglrecl                 |    Set avglrecl = maxlrecl.\n   endif                                 |  EndIf.\n*  *------------------------------------------------------------------*\n*  * Use the avg and max lrecl values to determine the record\n*  * format of the output file.  If RECFM=V, add 4 to lrecls.\n*  *------------------------------------------------------------------*\n   l  r2,pwa_avglrecl                    |  r2 := avg lrecl.\n   l  r3,pwa_maxlrecl                    |  r3 := max lrecl.\n   if (cr,r2,eq,r3)                      |  If max lrecl = avg lrecl.\n     sbit  pwa_1_fb                      |    Force RECFM=F,\n   elseif (cr,r2,gt,r3)                  |  ElseIf Avg > max lrecl\n     callsub message,(fi00115,pwa_maxlrecl,pwa_avglrecl)\n     errexit code=0                      |\n   else                                  |  Else.\n     sbit  pwa_1_vb                      |    Force RECFM=V,\n     la    r2,4(,r2)                     |    Add 4 to avg lrecl.\n     st    r2,pwa_avglrecl               |\n     la    r3,4(,r3)                     |    Add 4 to max lrecl.\n     st    r3,pwa_maxlrecl               |\n   endif                                 |  EndIf.\n*  *------------------------------------------------------------------*\n*  * Extract information from supplied text-units.\n*  *------------------------------------------------------------------*\n   l32   r2,fi_info                  | Search caller's INFO list\n   if    (nz),and,(clc,=f'0',ne,0(r2)) If present and non-null.\n     loop until                      |   textunit pointers:\n       l  r1,0(r2)                   |\n       if (clc,0(2,r1),eq,=al2(dalvlser)) Is this VOLSER textunit?\n         lh    r15,4(r1)             |      Get volume's length\n         bctr  r15,0                 |      Set it up for EXECUTE\n         exi   r15,(mvc,pwa_volser(0),6(r1)) Copy volser to PWA\n       elseif (clc,0(2,r1),eq,=al2(dalsysou)) Is this SYSOUT textunit?\n         if (clc,2(2,r1),gt,=al2(0000))     if # not zero then\n           mvc pwa_sysoutclass,6(r1) |        copy sysout class char.\n         endif                       |      endif.\n       endif                         |     EndIf.\n       leave loop=*,(tbit,0(r2),x'80')     Leave if at final textunit.\n       la    r2,4(r2)                |     r2 -> Next entry.\n     endloop until,leave             |   EndLoop.\n   endif                             | EndIf.\n*  *------------------------------------------------------------------*\n*  * Create a better REFERENCE string if one was not supplied.\n*  *------------------------------------------------------------------*\n   if not,(tbit,pwa_2_reference_supplied)   | Ref not supplied\n     if (cli,pwa_oc2_sysoutx,eq,&fi_oc2_sysout) | If it is SYSOUT\n      mvc  pwa_fi_reference,=cl70\"a SYSOUT file\"\n     elseif (cli,pwa_oc_ident,eq,&fi_oc_fileid) | If its a DDNAME\n      l  r4,fi_filename          | R4 := file-specification's text.\n      l  r5,fi_namelength        | R5 -> length of file-specification.\n      fill  pwa_fi_reference,c' ' | Clear out the REFERENCE string.\n      st_format id=st,string=pwa_fi_reference,                         +\n               control='DDNAME {cl? caps trim}',                       +\n               source=(0(r4),0(r5))\n     elseif (cli,pwa_oc_ident,eq,&fi_oc_filename) | If its a FILENAME.\n      l  r4,fi_filename          | R4 := file-specification's text.\n      l  r5,fi_namelength        | R5 -> length of file-specification.\n      fill  pwa_fi_reference,c' ' | Clear out the REFERENCE string.\n      st_format id=st,string=pwa_fi_reference,                         +\n               control='{cl? caps trim}',source=(0(r4),0(r5))\n     elseif (cli,pwa_oc_filetempx,eq,&fi_oc_filetemp) If FILETEMP\n      mvc  pwa_fi_reference,=cl70\"a TEMPORARY DATASET\"\n     endif                                |\n   endif                                |\n*  *------------------------------------------------------------------*\n*  * Parse the file's name and allocate the file.\n*  *------------------------------------------------------------------*\n   callsub parse_filename            | If file name provided, get it.\n   callsub allocate_file             | Allocate the file now.\n*                                    |   If OPTION=LIBRARY:\n   if (cli,pwa_oc2_library,eq,&fi_oc2_library)\n     if (cli,pwa_member,ne,c\" \")     |     If member specified:\n       callsub message,(fi00037)     |      It is an error.\n       errexit code=0                |      Exit.\n     endif                           |     Endif.\n   endif                             |   Endif.\n*  *------------------------------------------------------------------*\n*  * If AUTOOPEN is in effect, open the file for INPUT/OUTPUT now.\n*  *------------------------------------------------------------------*\n   if (cli,pwa_oc_open,ne,&fi_oc_manualopen)  If OPEN=AUTO.\n     callsub open                        |      Open the data set.\n   endif                                 |    EndIf.\n   callsub message,(fi00000)          | Successful completion.\n endblk block=start\n                 swa\n&w.avg_rec_len   ds     f\n&w.max_rec_len   ds     f\n                 endswa\n eject\n***********************************************************************\n*                                                                     *\n*  Subroutine: TERMINATE                                              *\n*  Abstract:   Close out and cleanup any/all files.                   *\n*                                                                     *\n***********************************************************************\n block name=terminate,type=subroutine,amode=31\n   if (tbit,pwa_1_open)                  | If file is open.\n     callsub close                       |   Close it.\n   endif                                 | EndIf.\n*---------------------------------------------------------------------*\n*  If we allocated to the data set ourselves, and AUTOFREE is in effect\n*  then free the data set.\n*---------------------------------------------------------------------*\n   if (cli,pwa_oc2_free,eq,&fi_oc2_autofree)\n     if (tbit,pwa_1_allocated),and,(clc,pwa_ddname,ne,=cl8' ')\n       if (tbit,pwa_2_free_on_terminate)\n         mvc &w.ddname,&s.ddname         | Initialize DDNAME text unit.\n         mvc (s99tupar-s99tunit)+&w.ddname(8),pwa_ddname\n         plist (&w.ddname),vl,pl=pwa_textunits\n         callsub dynalloc,               | Releasing allocated file.   +\n               (=al1(s99vrbun),          |   Unallocate function.      +\n               =al1(s99nomnt,0),0,       |   Request-block flags.      +\n               pwa_err_msg,              |   Return message area.      +\n               =a(l'pwa_err_msg),        |   Length of message area.   +\n               pwa_err_msg_len,          |   Length of returned msg.   +\n               pwa_textunits),vl         |   Free by DDNAME.\n       endif\n     endif\n   endif\n*---------------------------------------------------------------------*\n*  Terminate and unload the string handler.\n*---------------------------------------------------------------------*\n   if (clc,pwa_st_spepa,ne,=f'0')        | If string handler loaded.\n     if (clc,pwa_st_sptoken,ne,=f'0')    |   If string-handler started.\n       st_terminate id=st                |     Terminate it.\n     endif                               |   EndIf.\n     es_unload_module id=es,spid=st      |   Unload the String Handler.\n     mvc   pwa_st_spepa,=f'0'            |   Set EPA to zeros.\n   endif                                 | EndIf.\n   callsub message,(fi00000)             | Successful completion.\n endblk block=terminate\n*---------------------------------------------------------------------*\n*  Working storage for dynamic de-allocation of OS data sets.\n*---------------------------------------------------------------------*\n             ssd\n&s.ddname    text_unit dunddnam,CL8' '   | DDNAME=<blanks>\n             endssd\n             swa\n&w.ddname    ds      cl(l'&s.ddname)     |   DUN DDNAME Text unit.\n             endswa\n             eject\n***********************************************************************\n*                                                                     *\n*  Subroutine: OPEN_PARM                                              *\n*  Abstract  : Process the FI_OPEN parms.\n*                                                                     *\n***********************************************************************\n block name=open_parm,type=subroutine,amode=31\n*---------------------------------------------------------------------*\n*  If Option is specified, process it.\n*---------------------------------------------------------------------*\n   mvi   pwa_oo_mode,&fi_oo_default   |     Assume defaulting.\n   if    (tbit,fi_functioncode,x'80',off)   If option parm is present.\n    l32   r2,fi_op_options            |      r2 -> options parm.\n    if    nz,then                     |      If a value was provided.\n     mvc   pwa_oo_mode,0(r2)          |       Save INPUT/OUTPUT flag.\n     ni    pwa_oo_mode,&fi_oo_mode    |       Mask off other bits.\n    endif                             |      Endif.\n   endif                              |     Endif.\n   if (cli,pwa_oo_mode,eq,&fi_oo_default)   If defaulting:\n     mvi   pwa_oo_mode,&fi_oo_input           Set OO_MODE\n     if (cli,pwa_oc_mode,eq,&fi_oc_output)    based on\n       mvi   pwa_oo_mode,&fi_oo_output        start\n     endif                            |       option.\n   endif                              |     Endif.\n endblk block=open_parm\n             eject\n***********************************************************************\n*                                                                     *\n*  Subroutine: OPEN                                                   *\n*  Abstract  : Open the file for processing.                          *\n*                                                                     *\n***********************************************************************\n block name=open,type=subroutine,amode=31\n*  *------------------------------------------------------------------*\n*  * Ensure that the file is not already open and reset flags.\n*  *------------------------------------------------------------------*\n   if  (tbit,pwa_1_open)                 | If file already OPEN.\n     callsub message,(fi00126,\"already\",7)   Issue an error message\n     errexit code=0                      |   and exit w/ret-code.\n   endif                                 | EndIf.\n   rbit pwa_2_fios_supplies_dcb_attributes Reset flag.\n*  *------------------------------------------------------------------*\n*  * For CLEMSON only, determine if RACF will allow the OPEN.\n*  *------------------------------------------------------------------*\n     aif (not &security_check).skip3\n     if (cli,pwa_oo_mode,eq,&fi_oo_input)    If input mode.\n       callsub security_check,(\"READ\")   |     Check for READ access.\n     else                                |   Else.\n       callsub security_check,(\"UPDATE\") |     Check for UPDATE access.\n     endif                               |   EndIf.\n.skip3 anop\n*  *------------------------------------------------------------------*\n*  * For existing data sets, perform a number of checks to (1)\n*  * avoid destroying the file and (2) avoid any ABENDs.\n*  *------------------------------------------------------------------*\n   if (clc,=c'PO',ne,pwa_dsorg),and,(clc,=c'PS',ne,pwa_dsorg)\n     callsub message,(fi00101,pwa_dsorg,pwa_dsname)\n     errexit code=0\n   endif\n   if not,(tbit,pwa_1_ds_not_existing)   | If already existed.\n*    *----------------------------------------------------------------*\n*    * Read in the JFCB for the file and extract information from it.\n*    *----------------------------------------------------------------*\n     callsub read_jfcb                   |   Read PO or PS JFCB.\n     la      r8,pwa_jfcb                 |   r8 -> JFCB storage.\n     using   infmjfcb,r8                 |   Address the JFCB.\n     mvc     pwa_volser,jfcbvols         |   Extract data set VOLSER.\n     lh      r0,jfclrecl                 |   Extract data set LRECL\n     st      r0,pwa_lrecl                |      and save in PWA.\n     lh      r1,jfcblksi                 |   Extract data set BLKSIZE\n     st      r1,pwa_blksize              |      and save in PWA.\n     mvc     pwa_recfm,jfcrecfm          |   Extract data set RECFM.\n     if      (tbit,jfcbtsdm,jfcsds)      |   If SYSIN|SYSOUT data set.\n       sbit  pwa_2_sysinout              |     Indicate in PWA.\n     endif                               |   EndIf.\n*    *----------------------------------------------------------------*\n*    * Enforce data set/member replacement rules and ensure that the\n*    * data set organization is consistent with the specified name.\n*    *----------------------------------------------------------------*\n*                                        |   If option=LIBRARY:\n     if (cli,pwa_oc2_library,eq,&fi_oc2_library)\n       if (clc,=c'PO',ne,pwa_dsorg)      |     If not PO or POU:\n         callsub message,(fi00038)       |      It is an error.\n         errexit code=0                  |      Exit.\n       endif                             |     Endif.\n     elseif (cli,pwa_member,ne,c\" \")     |   Elseif MEMBER specified.\n       if (clc,=c'PO',ne,pwa_dsorg)      |     If DSORG \u00ac= PO or POU.\n         callsub message,(fi00108,pwa_dsname,pwa_member) Format msg.\n         errexit code=0                  |                 Exit w/rc.\n       endif                             |     EndIf.\n       if (cli,pwa_oc2_chkpdsmemx,eq,&fi_oc2_chkpdsmem)\n         callsub does_member_exist       |       See if member in PDS.\n         if      (treg,r15,z)            |       If so.\n           sbit  pwa_1,pwa_1_member      |         Flag for later.\n           if    (cli,pwa_oc_disp,eq,&fi_oc_new)   If NEW specified.\n             callsub message,(fi00117,pwa_member,pwa_dsname) \u00acREPLACE.\n             errexit code=0              |           Exit w/error code.\n           endif                         |         EndIf.\n         else                            |       Else, member \u00acthere.\n           if (cli,pwa_oc_disp,eq,&fi_oc_existing) If EXISTING spec'd.\n             callsub message,(fi00104,pwa_member,pwa_dsname)\n             errexit code=0              |           Exit w/error code.\n           endif                         |         EndIf.\n         endif                           |       EndIf.\n       endif                             |     EndIf.\n     else                                |   Else.\n       if (cli,pwa_oc_disp,eq,&fi_oc_new)      If NEW was specified.\n         callsub message,(fi00128,pwa_dsname)    \u00acREPLACE.\n         errexit code=0                  |       Exit w/error code.\n       endif                             |     EndIf.\n       if (clc,=c'PO',eq,pwa_dsorg)      |     If DSORG = PO or POU.\n         callsub message,(fi00103,pwa_dsname)    Member required.\n         errexit code=0                  |       Exit w/return-code.\n       endif                             |     EndIf.\n     endif                               |   EndIf.\n*    *----------------------------------------------------------------*\n*    *\n*    * If performing OUTPUT to a DDNAME, abends (013-34's, etc) may\n*    * occur due to improperly coded or missing DCB attributes.  This\n*    * section of code attempts to detect certain *missing* DCB\n*    * attributes and supply reasonable defaults for them.  It does not\n*    * check specified (non-missing) attributes for validity.\n*    * This code only applies to DISP=NEW data sets, except as noted\n*    * below for sysout files.\n*    *\n*    *----------------------------------------------------------------*\n*    *\n*    * DSC - When read-jfcb is used on a SYSOUT file, the returned DCB\n*    * attributes for LRECL and BLKSIZE may be incorrect.  For example,\n*    * one experiment in interactive TEST resulted in\n*    * RECFM=VB,LRECL=240,BLKSIZE=240 (lrecl cannot equal blksize for\n*    * VB datasets....abend 013-34).  The values coded on the DD\n*    * statement for that experiment had a much higher BLKSIZE that was\n*    * replaced by some component...presumably JES.  Since the output\n*    * records will be stored the same regardless of the DCB attributes\n*    * used (they go to spool), this code always overrides the DCB\n*    * ---- changed, was RECFM=VB,LRECL=32756,BLKSIZE=32760 ---- mgg\n*    * attributes for SYSOUT data sets to:\n*    *   RECFM=F|FA,LRECL=pwa_maxlrecl,BLKSIZE=pwa_maxlrecl or\n*    *   RECFM=V|VA,LRECL=pwa_maxlrecl,BLKSIZE=pwa_maxlrecl+4\n*    * depending on whether variable and/or IOSCC was requested.\n*    *\n*    *----------------------------------------------------------------*\n     if (cli,pwa_oo_mode,eq,&fi_oo_output)   If OUTPUT file.\n       if (tbit,pwa_2_sysinout)          |     If SYSOUT file.\n         sbit pwa_2_fios_supplies_dcb_attributes Indicate supplied.\n         l    r1,pwa_maxlrecl            |       Set LRECL to maximum\n         st   r1,pwa_lrecl               |       LRECL.\n         if (tbit,pwa_1_fb)              |       If fixed requested:\n          mvi  pwa_recfm,dcbrecf         |         Force RECFM=F.\n         else                            |       Else:\n          mvi  pwa_recfm,dcbrecv         |         Force RECFM=V.\n          la   r1,4(,r1)                 |         BLKSIZE+=4.\n         endif                           |       Endif.\n         st   r1,pwa_blksize             |       Store BLKSIZE.\n         if (cli,pwa_oc2_cc,eq,&fi_oc2_isocc)    If ISOCC requested:\n           sbit  pwa_recfm,dcbrecca      |        Indicate in RECFM.\n         endif                           |       Endif.\n       elseif (cli,pwa_oc_ident,eq,&fi_oc_fileid), If DDname alloc'd   +\n               and,(tbit,jfcbind2,jfcnew,on)   Elseif FILEID and NEW:\n         sbit pwa_2_fios_supplies_dcb_attributes Indicate supplied.\n         l  r1,pwa_lrecl                 |  R1  := existing LRECL.\n         l  r15,pwa_blksize              |  R15 := existing BLKSIZE.\n         if (treg,r1,z),and,(treg,r15,z),   If neither specified, and  +\n               and,(tbit,pwa_recfm,dcbrecf+dcbrecv,ON)   RECFM=U then\n             mvi  pwa_recfm,x'00'        |    Assume RECFM \u00acspecified.\n         endif                           |  EndIf.\n*                                        |\n         if (cli,pwa_recfm,eq,x'00')     |  If no RECFM value.\n           if (tbit,pwa_1_vb)            |    If caller requested VB\n             sbit  pwa_recfm,dcbrecv+dcbrecbr   Make note in RECFM\n           elseif (tbit,pwa_1_fb)        |    ElseIf caller wants FB.\n             sbit  pwa_recfm,dcbrecf+dcbrecbr   Make note of FB.\n           elseif (tbit,pwa_2_sysinout)  |    ElseIf SYSINOUT file.\n             sbit  pwa_recfm,dcbrecv+dcbrecbr   Default to VB.\n           else                          |    Else\n             sbit  pwa_recfm,dcbrecf+dcbrecbr   Default to FB.\n           endif                         |    EndIf.\n           if (cli,pwa_oc2_cc,eq,&fi_oc2_isocc) If ISOCC requested:\n             sbit  pwa_recfm,dcbrecca    |     Indicate in RECFM.\n           endif                         |    Endif.\n         endif                           |  EndIf.\n*                                        |\n         if (treg,r15,z)                 |  If BLKSIZE missing.\n           lh  r15,=h'11476'             |    Assume BLKSIZE= 1/4 track\n           if (tbit,pwa_recfm,dcbrecf)   |    If RECFM=F\n             if  (treg,r1,z)             |      If LRECL missing.\n               l  r1,pwa_avglrecl        |        Choose LRECL value.\n               st r1,pwa_lrecl           |        Set chosen LRECL.\n             endif                       |      EndIf.\n             if (tbit,pwa_recfm,dcbrecbr,OFF)   If not blocked.\n               lr r15,r1                 |        BLKSIZE = LRECL.\n             elseif (cr,r1,gt,r15)       |        ElseIf LRECL>BLKSIZE.\n               lr r15,r1                 |        BLKSIZE = LRECL.\n             else                        |      Else.\n               xr r14,r14                |        Adjust BLKSIZE to\n               dr r14,r1                 |        an even multiple of\n               xr r14,r14                |        LRECL.\n               mr r14,r1                 |\n             endif                       |      EndIf.\n           else                          |    Else, RECFM = V.\n             if  (treg,r1,z)             |      If LRECL missing.\n               l  r1,pwa_maxlrecl        |        Choose LRECL value.\n               st r1,pwa_lrecl           |        Set chosen LRECL.\n             elseif (cr,r1,gt,r15)       |        ElseIf LRECL>BLKSIZE.\n               la r15,4(,r1)             |        BLKSIZE = LRECL+4.\n             endif                       |      EndIf.\n             if (tbit,pwa_recfm,dcbrecbr,OFF),or,(cr,r1,gt,r15)\n               la r15,4(,r1)             |        BLKSIZE = LRECL+4.\n             endif                       |      EndIf.\n           endif                         |    EndIf.\n           st r15,pwa_blksize            |    Save chosen BLKSIZE.\n         elseif (treg,r1,z)              |  ElseIf LRECL missing.\n           if (tbit,pwa_recfm,dcbrecf)   |    If RECFM=F\n             l  r1,pwa_avglrecl          |      Choose LRECL value.\n             if (tbit,pwa_recfm,dcbrecbr,OFF),or,(cr,r1,gt,r15)\n               lr  r1,r15                |        Use LRECL=BLKSIZE.\n             else                        |      Else.\n               xr r14,r14                |        Divide BLKSIZE by\n               dr r14,r1                 |        chosen LRECL value.\n               if (treg,r14,nz)          |        If \u00aceven multiple.\n                 callsub message,(fi00125,pwa_blksize,pwa_avglrecl)\n                 errexit code=0          |          Exit w/ret-code.\n               endif                     |        EndIf.\n             endif                       |      EndIf.\n           else                          |    Else, RECFM = VB.\n             l  r1,pwa_maxlrecl          |      Choose LRECL value.\n             s  r15,=f'4'                |\n             if (tbit,pwa_recfm,dcbrecbr,OFF),or,(cr,r1,gt,r15)\n               lr r1,r15                 |        LRECL = BLKSIZE-4.\n             endif                       |      EndIf.\n           endif                         |    EndIf.\n           st  r1,pwa_lrecl              |    Save as pwa_lrecl.\n         endif                           |   EndIf.\n       endif                             |   Not using OPTION FILEID.\n     endif                               |  EndIf.\n*    *----------------------------------------------------------------*\n   endif  <Checks on existing datasets>  | EndIf.\n   drop    r8                            | Drop the JFCB.\n*  *------------------------------------------------------------------*\n*  * Open for sequential INPUT or sequential OUTPUT.\n*  *------------------------------------------------------------------*\n   la    r8,pwa_dcb                      | Base on working DCB\n   using ihadcb,r8                       | Get addressability.\n   if (cli,pwa_oo_mode,eq,&fi_oo_input)  | If INPUT access mode.\n     if (cli,pwa_oc2_library,eq,&fi_oc2_library)\n       mvc   pwa_dcb(dcblngpo),&s.po_dcb |     Use BPAM DCB.\n     else                                |\n       mvc   pwa_dcb(dcblngps),&s.gl_dcb |     Use get-locate DCB.\n     endif                               |\n     mvc   dcbddnam,pwa_ddname           |   Set DDname in working DCB\n     mvc   pwa_open(open_l),&psd.open    |   Copy OPEN's parmlist.\n     block amode=24                      |   Begin-Amode24.\n       open  (pwa_dcb,input),mf=(e,pwa_open) Open for INPUT.\n       lr    r5,r15                      |     Save return-code.\n     endblk                              |   End Amode-24.\n   else                                  | Else, OUTPUT access mode.\n     if (cli,pwa_member,ne,c' ')         |   If writing to a member.\n       callsub spfedit_enq,(pwa_dsname,pwa_member) Enqueue on member.\n       if      (treg,r15,nz)             |           If in-use.\n         st   r15,pwa_save_r15           | Preserve r15 for errexit\n         callsub message,(fi00119,pwa_member)          Error msg.\n         l    r15,pwa_save_r15           | Rest r15 for debug analysis\n         errexit code=0                  |             Exit w/ret-code.\n       endif                             |           EndIf.\n     endif                               |   EndIf.\n     mvc   pwa_dcb(dcblngps),&s.pl_dcb   |   Use PUT-Locate DCB.\n     if (tbit,pwa_2_fios_supplies_dcb_attributes)\n       l     r1,pwa_lrecl                |   Include derived LRECL,\n       sth   r1,dcblrecl                 |   BLKSIZE and RECFM in\n       l     r1,pwa_blksize              |   DCB being built.\n       sth   r1,dcbblksi                 |\n       mvc   dcbrecfm,pwa_recfm          |\n     endif                               |\n     mvc   dcbddnam,pwa_ddname           |   Set DDname in working DCB.\n     mvc   pwa_open(open_l),&psd.open    |   Copy OPEN's parmlist.\n     block amode=24                      |   Begin-Amode24.\n       if (cli,pwa_oc_disp,eq,&fi_oc_append) If APPEND option.\n         open (pwa_dcb,extend),mf=(e,pwa_open) Open for EXTEND.\n       else                              |    Else.\n         open (pwa_dcb,output),mf=(e,pwa_open) Open for OUTPUT.\n       endif                             |    Endif.\n       lr    r5,r15                      |      Save return-code.\n     endblk                              |   End Amode-24.\n   endif                                 | EndIf.\n*  *------------------------------------------------------------------*\n*  * Check to see if OPEN succeeded and if RECFM supported.\n*  *------------------------------------------------------------------*\n   if (treg,r5,nz)                       | If OPEN failed.\n     st   r15,pwa_save_r15               | Preserve r15 for errexit\n     callsub message,(fi00102,pwa_dsname)    Format error message.\n     l    r15,pwa_save_r15               | Rest r15 for debug analysis\n     errexit code=0                      |   Exit w/return-code.\n   endif                                 | EndIf.\n   sbit    pwa_1,pwa_1_open              | Indicate past open.\n*                                        |\n   if not,(tbit,dcbrecfm,dcbrecu,mixed)  | If not FIXED or VARYING.\n     callsub message,(fi00107)           |   Issue error msg.\n     errexit code=0                      |   Exit w/ret-code.\n   endif                                 | EndIf.\n*                                        |\n   l16   r1,dcblrecl                     | r1 := actual LRECL.\n   st    r1,pwa_lrecl                    | Save as a fullword.\n   mvc   pwa_recfm,dcbrecfm              | Copy actual RECFM.\n*  *------------------------------------------------------------------*\n*  * If OPTION=LIBRARY, BPAM is used.  Get a buffer for for DECBs and\n*  * and maximum blocks.\n*  *------------------------------------------------------------------*\n   if (cli,pwa_oc2_library,eq,&fi_oc2_library)\n*   *-----------------------------------------------------------------*\n*   * Get storage for buffer entries (BENT).\n*   *-----------------------------------------------------------------*\n    lh    r1,dcbblksi                 |  Calculate size\n    sm_ahi r1,bent_fixed_len+7        |  of one buffer entry\n    srl   r1,3                        |  rounded up to\n    sll   r1,3                        |  a multiple of 8.\n    st    r1,pwa_bent_size            |  Save it.\n    l8    r15,dcbncp                  |  Calculate size\n    sth   r15,pwa_bent_count          |  of buffer needed\n    mh    r1,pwa_bent_count           |  for dcbncp buffer\n    st    r1,pwa_bent_buffer_size     |  entries.\n    es_obtain_storage id=es,          |  Get storage for               +\n               location=below,        |  all buffer entries.           +\n               size=pwa_bent_buffer_size,                              +\n               address=pwa_bent_buffer_address\n    if not,(%es_success)              |  If not successful:\n     st    r15,&w.rc                  |\n     callsub message,(fi00010,&w.rc)  |   Save error message.\n     errexit code=0                   |   Exit.\n    endif                             |  Endif.\n*   *-----------------------------------------------------------------*\n*   * Link buffer entries into a circular list.\n*   *-----------------------------------------------------------------*\n    lh    r15,pwa_bent_count          |  r15 = buffer entry count.\n    l     r1,pwa_bent_buffer_address  |  r1 -> first buffer entry.\n    using bent_start,r1               |  Establish base for entry.\n    loop until                        |  Loop chaining entries.\n      sm_decr r15                     |   Decrement count.\n      if np                           |   If last one:\n       l     r0,pwa_bent_buffer_address    Point it back to\n       st    r0,bent_next             |    first entry.\n       leave loop=*                   |    Leave loop.\n      else                            |   Else:\n       lr    r0,r1                    |    Point r0 to\n       al    r0,pwa_bent_size         |    next entry.\n       st    r0,bent_next             |    Save it in this entry.\n       lr    r1,r0                    |    Make next entry the current.\n      endif                           |   Endif.\n    endloop until,leave               |  Endloop.\n    drop   r1                         |  Drop base for entry.\n*   *-----------------------------------------------------------------*\n   endif                              | Endif.\n*  *------------------------------------------------------------------*\n   drop r8                               | Drop addressability.\n   callsub message,(fi00000)             | Successful completion.\n endblk block=open\n*---------------------------------------------------------------------*\n*  Static storage for opening an OS data set.\n*---------------------------------------------------------------------*\n          ssd\n&s.gl_dcb dcb ddname=--------,macrf=(gl),dsorg=ps,synad=synad,eodad=eof\n&s.po_dcb dcb ddname=--------,macrf=r,dsorg=po,synad=synad,eodad=eof\n&s.pl_dcb dcb ddname=--------,macrf=(pl),dsorg=ps,synad=synad\n          endssd\n          swa\n&w.rc     ds  f\n          endswa\n          eject\n***********************************************************************\n*                                                                     *\n*  Subroutine: CLOSE                                                  *\n*  Abstract  : Close the file without terminating.                    *\n*                                                                     *\n***********************************************************************\n block name=close,type=subroutine,amode=31\n   if  (tbit,pwa_1_open,OFF)            | If file is not OPEN.\n     callsub message,(fi00126,\"not\",3)   |   Issue an error message\n     errexit code=0                      |   and exit w/ret-code.\n   endif                                 | EndIf.\n*---------------------------------------------------------------------*\n*  If the data set is currently OPEN, close it and free its buffers.\n*---------------------------------------------------------------------*\n   la    r8,pwa_dcb                   | Establish addressability on\n   using ihadcb,r8                    |   the OS Data Control Block.\n   if (tbit,pwa_1_open),then\n     block type=inline,amode=24       |   Start Amode=24.\n       plist (pwa_dcb),vl             |     Set parms in working stg.\n       close (pwa_dcb),mf=(e,(1))     |     Close the file.\n       rbit   pwa_1,pwa_1_open        |     Reset OPEN flag.\n       rbit   pwa_1,pwa_1_eof         |     Reset EndOfFile flag.\n       callsub free_buffer_pool,(pwa_dcb)   Free DCB's buffer pool\n     endblk                           |\n   endif                              |\n   if (tbit,pwa_2_member_enq)         | if spfedit enq was done\n     callsub spfedit_deq,             |        Undo it.                +\n               (pwa_dsname,pwa_member)\n   endif                              |\n*---------------------------------------------------------------------*\n*  Free buffer entries buffer.\n*---------------------------------------------------------------------*\n  if (clc,pwa_bent_buffer_address,ne,=f'0')  If buffer obtained:\n    es_release_storage id=es,         |        Release it.             +\n               size=pwa_bent_buffer_size,                              +\n               address=pwa_bent_buffer_address\n    if not,(%es_success)              |        If release failed:\n     st    r15,&w.rc                  |\n     callsub message,(fi00043,&w.rc)  |         Save message.\n     errexit code=0                   |         Exit.\n    endif                             |        Endif.\n    fill   pwa_bent_buffer_size       |        Clear size and\n    fill   pwa_bent_buffer_address    |        address fields.\n   endif                              |      Endif.\n*---------------------------------------------------------------------*\n   callsub message,(fi00000)             | Successful completion.\n endblk block=close\n          swa\n&w.rc     ds    f\n          endswa\n          eject\n***********************************************************************\n*                                                                     *\n*  Subroutine: DELETE                                                 *\n*  Abstract  : Delete the sequential data set or PDS member.          *\n*                                                                     *\n*  Note: If the data set or member is enqueued on (in-use) when this  *\n*        function is invoked, it will fail.  We could add a WAIT      *\n*        option to get around this.                                   *\n*                                                                     *\n***********************************************************************\n block name=delete,type=subroutine,amode=31\n   if (tbit,pwa_1_open)                  | If file is open.\n     callsub close                       |   Close it.\n   endif                                 | EndIf.\n*---------------------------------------------------------------------*\n*  Handle the delete function for a PDS member.\n*---------------------------------------------------------------------*\n   if (clc,=c'PO',eq,pwa_dsorg)          | If deleting a member.\n     callsub read_jfcb                   |   Read in PDS's JFCB.\n     aif (not &security_check).skip1\n     callsub security_check,(\"UPDATE\")   |   Check RACF access.\n.skip1 anop\n     callsub spfedit_enq,(pwa_dsname,pwa_member) Enqueue on member.\n     if (treg,r15,nz)                    |   If in-use.\n       st   r15,pwa_save_r15             | Preserve r15 for errexit\n       callsub message,(fi00119,pwa_member)    Error msg.\n       l    r15,pwa_save_r15             | Rest r15 for debug analysis\n       errexit code=0                    |     Exit w/ret-code.\n     endif                               |   EndIf.\n     la    r8,pwa_dcb                    |   r8 -> PO DCB to use.\n     using ihadcb,r8                     |   Establish addressability.\n     la    r7,pwa_jfcb                   |   r7 -> our copy of JFCB.\n     using infmjfcb,r7                   |   Establish addressability.\n     mvc   jfcbelnm,=cl8' '              |   Clear the member name.\n     mvc   pwa_open(open_l),&psd.open    |   Copy OPEN plist to PWA.\n     block amode=24                      |   Block Amode-24.\n       open  (pwa_dcb,output),type=j,mf=(e,pwa_open)\n     endblk                              |   EndBlk Amode-24.\n     if (tbit,dcboflgs,dcbofopn,off)     |   If OPEN failed.\n       callsub message,(fi00102,pwa_dsname)    Issue an error message.\n       errexit code=0                    |     Exit with error-code.\n     endif                               |   Endif.\n     block amode=24                      |   Block Amode-24.\n       stow    pwa_dcb,pwa_member,d      |     Delete the member.\n       st      r15,&w.stow_rc            |     Save return-code.\n       plist   (pwa_dcb),vl              |     Set plist in pwa.\n       close   (pwa_dcb),mf=(e,(1))      |     Close PO DCB.\n       callsub free_buffer_pool,(pwa_dcb)      Free its buffer pool.\n     endblk                              |   EndBlk Amode-24.\n     drop    r8,r7                       |   Drop DCB, JFCB addressing.\n     callsub spfedit_deq                 |   Remove the enqueue.\n     mvc &w.ddname,&s.ddname             |   Use DDNAME allocated to.\n     mvc &w.unalloc,&s.unalloc           |   Set up UNALLOC text unit.\n     mvc (s99tupar-s99tunit)+&w.ddname(8),pwa_ddname\n     plist (&w.ddname,&w.unalloc),vl,pl=pwa_textunits\n     callsub dynalloc,                   |   Free allocated file.      +\n               (=al1(s99vrbun),          |   Unallocate function.      +\n               =al1(s99nomnt,0),0,       |   Request-block flags.      +\n               pwa_err_msg,              |   Return message area.      +\n               =a(l'pwa_err_msg),        |   Length of message area.   +\n               pwa_err_msg_len,          |   Length of returned msg.   +\n               pwa_textunits),vl         |   Free by DDNAME.\n     rbit      pwa_1,pwa_1_allocated         Reset allocated flag.\n     rbit      pwa_2,pwa_2_free_on_terminate\n     errexit (treg,r15,nz),code=0        |   If failure, exit w/code.\n     l  r15,&w.stow_rc                   |   Pick up STOW's ret-code.\n     st   r15,pwa_save_r15               | Preserve r15 for errexit\n     if (treg,r15,z)                     |   If DELETE successful.\n       callsub message,(fi00301,pwa_member,\"deleted \",pwa_dsname)\n     elseif (c,r15,eq,=f'8')             |   ElseIf member not found.\n       callsub message,(fi00104,pwa_member,pwa_dsname)\n     else                                |   Else, DELETE failed.\n       callsub message,(fi00127,pwa_member,pwa_dsname,&w.stow_rc)\n     endif                               |   EndIf.\n     l    r15,pwa_save_r15               | Rest r15 for debug analysis\n     errexit code=0                      |   Exit with return-code.\n   endif                                 | EndIf.\n   eject\n*---------------------------------------------------------------------*\n*  Handle the delete function for a sequential data set.\n*---------------------------------------------------------------------*\n   aif (not &security_check).skip2\n   callsub security_check,(\"ALTER\")      | Check RACF access.\n.skip2 anop\n*\n*  If (allocated & \u00ac(SHR | PASS)) then override to DELETE and free it.\n*\n   if (tbit,pwa_1_allocated),and,                         If allocated +\n               (cli,pwa_status,ne,pwa_status_shr),and,      and \u00acSHR   +\n               (cli,pwa_ndisp,ne,pwa_ndisp_pass)            and \u00acPASS.\n     mvc &w.ddname,&s.ddname             |   Use DDNAME allocated to.\n     mvc (s99tupar-s99tunit)+&w.ddname(8),pwa_ddname\n     mvc &w.ndisp_delete,&s.ndisp_delete |\n     mvc &w.unalloc,&s.unalloc           |\n     plist (&w.ndisp_delete,&w.ddname,&w.unalloc),vl,pl=pwa_textunits\n     callsub dynalloc,                   |   Free allocated file.      +\n               (=al1(s99vrbun),          |   Unallocate function.      +\n               =al1(s99nomnt,0),0,       |   Request-block flags.      +\n               pwa_err_msg,              |   Return message area.      +\n               =a(l'pwa_err_msg),        |   Length of message area.   +\n               pwa_err_msg_len,          |   Length of returned msg.   +\n               pwa_textunits),vl         |   Textunits\n     if    (treg,r15,z)                  |   If successful, then.\n       st   r15,pwa_save_r15             | Preserve r15 for errexit\n       rbit    pwa_1,pwa_1_allocated           Reset allocated flag.\n       callsub message,(fi00300,pwa_dsname,,0,=cl8\" \",,0,\"deleted \")\n       l    r15,pwa_save_r15             | Rest r15 for debug analysis\n       errexit code=0                    |     Exit w/return-code.\n     else                                |   Else.\n       rbit    pwa_1,pwa_1_allocated           Reset allocated flag.\n       rbit    pwa_2,pwa_2_free_on_terminate\n     endif                               |   EndIf.\n   endif                                 | EndIf.\n*---------------------------------------------------------------------*\n*  If still allocated to dataset, free it.\n*---------------------------------------------------------------------*\n   if (tbit,pwa_1_allocated)            | If allocated to dataset.\n     mvc &w.ddname,&s.ddname             |   Use DDNAME allocated to.\n     mvc (s99tupar-s99tunit)+&w.ddname(8),pwa_ddname\n     plist (&w.ddname),vl,pl=pwa_textunits\n     callsub dynalloc,                   |   Free allocated file.      +\n               (=al1(s99vrbun),          |   Unallocate function.      +\n               =al1(s99nomnt,0),0,       |   Request-block flags.      +\n               pwa_err_msg,              |   Return message area.      +\n               =a(l'pwa_err_msg),        |   Length of message area.   +\n               pwa_err_msg_len,          |   Length of returned msg.   +\n               pwa_textunits),vl         |   Free by DDNAME.\n     rbit      pwa_1,pwa_1_allocated         Reset allocated flag.\n     rbit      pwa_2,pwa_2_free_on_terminate\n     errexit (treg,r15,nz),code=0        |   If failure, exit w/code.\n   endif                                 | EndIf.\n   eject\n*---------------------------------------------------------------------*\n*  Allocate to the dataset with (OLD,DELETE) and free it.\n*---------------------------------------------------------------------*\n   rbit    pwa_1,pwa_1_ds_not_existing     Reset ds-not-existing flag.\n   mvc     &w.dsname,&s.dsname           | Copy DSNAME text unit.\n   mvc     &w.ret_ddname,&s.ret_ddname   | Copy retrun DDNAME t.u.\n   mvc     s99tupar-s99tunit+&w.dsname(44),pwa_dsname\n   mvc     &w.stat_old,&s.stat_old       |\n   mvc     &w.disp_delete,&s.disp_delete |\n   plist (&w.ret_ddname,&w.dsname,&w.stat_old,&w.disp_delete),vl,      +\n               pl=pwa_textunits\n   callsub dynalloc,                     | Allocate to the dataset...  +\n               (=al1(s99vrbal),          |     Using DSNAME allocation.+\n               =al1(s99nomnt,0),         |     nomount,         @CNENQ +\n               =al4(0),                  |     No authorized flags.    +\n               pwa_err_msg,              |     Return message area.    +\n               =a(l'pwa_err_msg),        |     Length of message area. +\n               pwa_err_msg_len,          |     Length of returned msg. +\n               pwa_textunits),vl         |     TextUnits\n   errexit (treg,r15,nz),code=0          | If failure, exit w/code.\n   mvc     pwa_ddname,s99tupar-s99tunit+&w.ret_ddname\n*                                        |\n   mvc &w.ddname,&s.ddname               | Use DDNAME allocated to.\n   mvc (s99tupar-s99tunit)+&w.ddname(8),pwa_ddname\n   mvc &w.unalloc,&s.unalloc             |\n   plist (&w.ddname,&w.unalloc),vl,pl=pwa_textunits\n   callsub dynalloc,                     | Free allocated file.        +\n               (=al1(s99vrbun),          |   Unallocate function.      +\n               =al1(s99nomnt,0),0,       |   Request-block flags.      +\n               pwa_err_msg,              |   Return message area.      +\n               =a(l'pwa_err_msg),        |   Length of message area.   +\n               pwa_err_msg_len,          |   Length of returned msg.   +\n               pwa_textunits),vl         |     TextUnits\n   errexit (treg,r15,nz),code=0          | If failure, exit w/code.\n   rbit    pwa_1,pwa_1_allocated         | Reset allocated flag.\n   rbit    pwa_2,pwa_2_free_on_terminate\n   callsub message,(fi00300,pwa_dsname,,0,=cl8\" \",,0,\"deleted \")\n endblk block=delete\n*---------------------------------------------------------------------*\n*  Storage for dynamic de-allocation of OS data sets.\n*---------------------------------------------------------------------*\n                ssd\n&s.ndisp_delete text_unit dunovdsp,x'04'    Override NDISP=DELETE.\n&s.unalloc      text_unit dununalc          Force unallocation.\n&s.dsname       text_unit dundsnam,cl44\" \"  dsname=<blanks>\n&s.ddname       text_unit dunddnam,cl8\" \"   ddname=<blanks>\n&s.stat_old     text_unit dalstats,x'01'    DISP=OLD,\n&s.disp_delete  text_unit dalndisp,x'04'         DELETE)\n&s.ret_ddname   text_unit dalrtddn,cl8\" \"   Return-DDNAME.\n                endssd\n                swa\n&w.ddname       ds        cl(l'&s.ddname)\n&w.dsname       ds        cl(l'&s.dsname)\n&w.ret_ddname   ds        cl(l'&s.ret_ddname)\n&w.unalloc      ds        cl(l'&s.unalloc)\n&w.stat_old     ds        cl(l'&s.stat_old)\n&w.disp_delete  ds        cl(l'&s.disp_delete)\n&w.ndisp_delete ds        cl(l'&s.ndisp_delete)\n&w.stow_rc      ds        f\n                endswa\n                eject\n***********************************************************************\n*                                                                     *\n*  Subroutine: READLINE                                               *\n*  Abstract:   Obtain the next line from an already open file.        *\n*                                                                     *\n***********************************************************************\n block name=readline,type=subroutine,amode=31\n*---------------------------------------------------------------------*\n*  Insure that attempting to read the next sequential line is an okay\n*  thing to do, considering the current type and status of the file\n*  and the access mode requested when the file was opened.  The error\n*  status flag has already been checked, at the beginning of the main\n*  routine.\n*---------------------------------------------------------------------*\n   if (tbit,pwa_1_open,off)\n     callsub message,(fi00114,\"READLINE\",8)\n     errexit code=0\n   elseif (tbit,pwa_1_eof)\n     callsub message,(fi00200)      | Build end-of-file message.\n     errexit code=&fi_end_of_file   | Exit w/end-of-file return-code.\n   elseif (cli,pwa_oo_mode,ne,&fi_oo_input)\n     callsub message,(fi00008)\n     errexit code=0\n   endif\n*---------------------------------------------------------------------*\n*  OK, get the next record.\n*---------------------------------------------------------------------*\n   la    r8,pwa_dcb\n   using ihadcb,r8\n   if (cli,pwa_oc2_library,eq,&fi_oc2_library),                        +\n               name=get_record        | If OPTION=LIBRARY:\n     if        not,(tbit,pwa_2_valid_find_active)\n       callsub message,(fi00039)      |   Find required.\n       errexit code=0                 |\n     endif                            |\n     l32   r0,pwa_bent_current_remaining  r0 = residual in block.\n     if np                            |   If none left:\n       l     r2,pwa_bent_current      |     Establish base\n       using bent_start,r2            |     for BENT.\n       l     r2,bent_next             |     Make next BENT\n       st    r2,pwa_bent_current      |     the current one.\n       block amode=24                 |\n        check bent_decb               |      Check for complete.\n       endblk                         |\n       leave (tbit,pwa_1_eof),if=get_record Leave if EOF.\n       lh    r0,dcbblksi              |     Calculate\n       l     r1,bent_decb+16          |     size of\n       sh    r0,14(,r1)               |     block read.\n       st    r0,pwa_bent_current_remaining  Set this as size remaining.\n       la    r1,bent_data_start       |     r1 -> first record in blk.\n       st    r1,pwa_bent_current_cursor     Set this as cursor.\n       drop  r2                       |     Drop base for bent.\n     else                             |   Else:\n       l     r1,pwa_bent_current_cursor     r1 -> next record in blk.\n     endif                            |   Endif.\n   else                               | Else:\n     block amode=24                   |\n      get   (r8)                      |   GET it.  R1 -> the record.\n     endblk                           |\n   endif                              | Endif\n   errexit (tbit,pwa_1_error),code=&fi_severe\n   if    (tbit,pwa_1_eof)             |\n     callsub message,(fi00200)        | Build end-of-file message.\n     errexit code=&fi_end_of_file     | Exit w/end-of-file return-code\n   endif                              |\n   eject                              |\n*---------------------------------------------------------------------*\n*  Set R4/R5 = Address/Length of the current logical record.\n*---------------------------------------------------------------------*\n   lr   r4,r1                       | Address of new record\n   xr r5,r5                         | R5 := length of record.\n   if (tbit,dcbrecfm,dcbrecf)       | If fixed-length records.\n     if (tbit,dcbrecfm,dcbrecbr)    |   If blocked records.\n       icm r5,b'0011',dcblrecl      |     R5 := length of record.\n     else                           |   Else.\n       icm r5,b'0011',dcbblksi      |     R5 := length of block.\n     endif                          |   EndIf.\n     la   r6,0(r5,r4)               |   R6 -> Past end of record.\n     s    r6,=f'8'                  |   R6 -> Last eight characters.\n     lr   r0,r5                     |   R0 := data length.\n   else                             | Else variable-length records.\n     icm  r5,b'0011',0(r4)          |   R5 := length of record.\n     lr   r0,r5                     |   R0 := data length.\n     sh   r5,=h'4'                  |   Subtract the RDW's length.\n     la   r4,4(,r4)                 |   R4 -> logical record's text.\n     lr   r6,r4                     |   R6 -> First eight characters.\n   endif                            | EndIf.\n   if (cli,pwa_oc2_library,eq,&fi_oc2_library)\n     l     r15,pwa_bent_current_cursor\n     ar    r15,r0                   |\n     st    r15,pwa_bent_current_cursor\n     l     r15,pwa_bent_current_remaining\n     sr    r15,r0                   |\n     st    r15,pwa_bent_current_remaining\n   endif                            |\n*---------------------------------------------------------------------*\n*  Copy the current line to the caller's storage area.\n*---------------------------------------------------------------------*\n   l    r14,fi_rl_area              | R14 -> target area for record.\n   l    r6,fi_rl_length             | R6  -> length to return.\n   l    r15,fi_rl_area_size         | R15 -> length of target area.\n   l    r15,0(r15)                  | R15 := length of target area.\n   if   (cr,r15,gt,r5)              | If more than enough room.\n     lr  r15,r5                     |   Only use the exact amount.\n   endif                            | EndIf.\n   st   r15,0(,r6)                  | Save length of current record.\n*                                   |\n   if   (treg,r5,p)                 | If anything to copy, then.\n    la   r0,256                     |  Use for increments/decrements.\n    loop while,(cr,r5,ge,r0),and,(cr,r15,ge,r0)\n     mvc   0(256,r14),0(r4)         |    Move 256 bytes.\n     if    (tbit,pwa_2_ascii)       |    If file is in ASCII.\n      tr   0(256,r14),&s.ascii_to_ebcdic   Convert to ebcdic.\n     endif                          |    EndIf.\n     ar    r14,r0                   |    Bump target pointer.\n     sr    r15,r0                   |    Decrement target length.\n     ar    r4,r0                    |    Bump source pointer.\n     sr    r5,r0                    |    Decrement source length.\n    endloop while                   |  EndLoop.\n    if (treg,r15,p),and,(treg,r5,p) |  If anything left.\n     bctr r15,0                     |   Subtract 1 for EX instr.\n     exi  r15,(mvc,0(0,r14),0(r4))  |   copy record to target area.\n     if    (tbit,pwa_2_ascii)       |    If file is in ASCII.\n      exi  r15,(tr,0(0,r14),&s.ascii_to_ebcdic)  Convert to ebcdic.\n     endif                          |    EndIf.\n     la   r15,1(,r15)               |   Add 1 back for comparison.\n    endif                           |  EndIf.\n    if   (cr,r15,lt,r5)             |  If record was truncated.\n     callsub message,(fi00201,\"Input \",0(r6))  Format a message.\n     errexit code=0                 |   Exit with return-code.\n    endif                           |  EndIf.\n   endif                            | EndIf.\n*---------------------------------------------------------------------*\n*  If OPTION=LIBRARY and there is not data remaining in current BENT,\n*  start a new READ.\n*---------------------------------------------------------------------*\n   if          (cli,pwa_oc2_library,eq,&fi_oc2_library),and,           +\n               not,(tbit,pwa_1_eof),and,                               +\n               (clc,pwa_bent_current_remaining,eq,=f'0')\n    l     r2,pwa_bent_current\n    block amode=24\n     read  bent_decb-bent_start(,r2),sf,mf=e\n    endblk\n   endif\n*---------------------------------------------------------------------*\n   drop    r8\n   callsub message,(fi00000)        | Successful completion.\n endblk block=readline\n            ssd\n&s.ascii_to_ebcdic ds    0cl256\n         SMLIST CONVERT=NO            |\n             dc c'................'   0\n             dc c'................'   1\n             dc c' !\"#$%&&''()*+,-./' 2\n             dc c'0123456789:;<=>?'   3\n             dc c'@ABCDEFGHIJKLMNO'   4\n             dc c'PQRSTUVWXYZ\u00dd\\\u00a8\u00ac_'   5\n             dc c'`abcdefghijklmno'   6\n             dc c'pqrstuvwxyz{|}~.'   7\n             dc c'................'   8\n             dc c'................'   9\n             dc c' !\"#$%&&''()*+,-./' a\n             dc c'0123456789:;<=>?'   b\n             dc c'@ABCDEFGHIJKLMNO'   c\n             dc c'PQRSTUVWXYZ\u00dd\\\u00a8\u00ac_'   d\n             dc c'`abcdefghijklmno'   e\n             dc c'pqrstuvwxyz{|}~.'   f\n         SMLIST CONVERT=YES           |\n           endssd\n eject\n***********************************************************************\n*                                                                     *\n*  Subroutine: WRITELINE                                              *\n*  Abstract:   Obtain the next line from an already open file.        *\n*                                                                     *\n***********************************************************************\n block name=writeline,type=subroutine,amode=31\n*---------------------------------------------------------------------*\n*  Insure that attempting to read the next sequential line is an okay\n*  thing to do, considering the current type and status of the file\n*  and the access mode requested when the file was opened.  The error\n*  status flag has already been checked, at the beginning of the main\n*  routine.\n*---------------------------------------------------------------------*\n   if (tbit,pwa_1_open,off)\n     callsub message,(fi00114,\"WRITELINE\",9)\n     errexit code=0                   |\n   elseif (cli,pwa_oo_mode,ne,&fi_oo_output)\n     callsub message,(fi00012)        |\n     errexit code=0                   |\n   endif                              |\n*---------------------------------------------------------------------*\n*  OK, write the record using PUT-Locate, as follows:\n*    .. If writing VL records, stuff length from caller into DCBLRECL.\n*    .. Issue PUT. R1 will contain address of place to put the record\n*       upon return.\n*    .. Move record into buffer.\n*---------------------------------------------------------------------*\n   la    r8,pwa_dcb                   | r8 -> Working output DCB.\n   using ihadcb,r8                    | Establish addressability.\n   l     r6,fi_wl_line                | r6 -> Text of new output line.\n   l     r7,fi_wl_length              | r7 -> Length of new line.\n   icm   r7,b'1111',0(r7)             | r7 := Length of new line.\n   slr   r5,r5                        | r5 := Truncation-flag register.\n*                                     |\n   if (tbit,dcbrecfm,dcbrecv)         | If variable-length output\n     la  r7,4(r7)                     |   Adjust length for RDW.\n     if  (c,r7,gt,pwa_lrecl)          |   If too large for dataset.\n       callsub message,(fi00201,\"Output\",pwa_lrecl)\n       lr      r5,r15                 |      Remember truncation.\n       l       r7,pwa_lrecl           |      Use maximum length.\n     endif                            |   EndIf.\n     sth   r7,dcblrecl                |   Stuff record length into DCB.\n     block amode=24                   |   Block-Amode24.\n      put pwa_dcb                     |     Obtain next record buffer.\n      lr  r2,r1                       |     r2 -> output record buffer.\n     endblk                           |   Endblk-Amode24.\n     errexit (tbit,pwa_1_error),code=&fi_severe\n     mvc     0(2,r2),dcblrecl         |   Set record length.\n     xc      2(2,r2),2(r2)            |   Clear reserved portion.\n     la      r14,4(r2)                |   r14 -> past RDW in buffer.\n     s       r7,=f'4'                 |   Adjust source length for RDW.\n     lr      r15,r7                   |   Dest length = source length\n*    mvcl    r14,r6 <---- used to be this Move record to buffer.\n     if   (treg,r7,p)                 |   If anything to copy, then.\n      la   r0,256                     |    For increments/decrements.\n      loop while,(cr,r7,ge,r0),and,(cr,r15,ge,r0)\n       mvc   0(256,r14),0(r6)         |      Move 256 bytes.\n       if    (tbit,pwa_2_ascii)       |      If file is in ASCII.\n        tr   0(256,r14),&s.ebcdic_to_ascii    Convert to ascii.\n       endif                          |      EndIf.\n       ar    r14,r0                   |      Bump target pointer.\n       sr    r15,r0                   |      Decrement target length.\n       ar    r6,r0                    |      Bump source pointer.\n       sr    r7,r0                    |      Decrement source length.\n      endloop while                   |    EndLoop.\n      if (treg,r15,p)                 |    If anything left.\n       bctr r15,0                     |     Subtract 1 for EX instr.\n       exi  r15,(mvc,0(0,r14),0(r6))  |     copy record to target area.\n       if    (tbit,pwa_2_ascii)       |      If file is in ASCII.\n        exi  r15,(tr,0(0,r14),&s.ebcdic_to_ascii)    Convert to ascii.\n       endif                          |      EndIf.\n      endif                           |    EndIf.\n     endif                            |   EndIf.\n     ltr     r15,r5                   |   Get truncation return-code.\n     errexit nz,code=0                |   Exit if truncated.\n   else                               | Else, fixed-length output.\n     block amode=24                   |   Block-Amode24.\n      put pwa_dcb                     |     Obtain next record buffer.\n      lr  r2,r1                       |     r2 -> output record buffer.\n     endblk                           |   Endblk-Amode24.\n     errexit (tbit,pwa_1_error),code=&fi_severe\n     if  (c,r7,gt,pwa_lrecl)          |   If too large for dataset.\n       callsub message,(fi00201,\"Output\",pwa_lrecl)\n       lr      r5,r15                 |      Remember truncation.\n       l       r7,pwa_lrecl           |      Use maximum length.\n     endif                            |   EndIf.\n     lr      r14,r2                   |   Move buffer addr to r14\n     lh      r15,dcblrecl             |   Dest length = fixed LRECL.\n*    icm     r7,b'1000',=c' '         |   Using blank for a pad char.\n*    mvcl    r14,r6 <---- used to be this Move record to buffer.\n     if   (treg,r7,p),or,(treg,r15,p) |   If anything to copy, then.\n      la   r0,256                     |    For increments/decrements.\n      loop while,(cr,r7,ge,r0),and,(cr,r15,ge,r0)\n       mvc   0(256,r14),0(r6)         |      Move 256 bytes.\n       if    (tbit,pwa_2_ascii)       |      If file is in ASCII.\n        tr   0(256,r14),&s.ebcdic_to_ascii    Convert to ascii.\n       endif                          |      EndIf.\n       ar    r14,r0                   |      Bump target pointer.\n       sr    r15,r0                   |      Decrement target length.\n       ar    r6,r0                    |      Bump source pointer.\n       sr    r7,r0                    |      Decrement source length.\n      endloop while                   |    EndLoop.\n      if (treg,r15,p),and,(treg,r7,p) |    If anything left.\n       lr  r1,r15                     |     r1 := dest length.\n       if  (cr,r1,gt,r7)              |     if more than source len\n        lr  r1,r7                     |      use source len\n       endif                          |     endif\n       bctr r1,0                      |     Subtract 1 for EX instr.\n       exi  r1,(mvc,0(0,r14),0(r6))   |     copy record to target area.\n       if    (tbit,pwa_2_ascii)       |      If file is in ASCII.\n        exi  r1,(tr,0(0,r14),&s.ebcdic_to_ascii)    Convert to ascii.\n       endif                          |      EndIf.\n       la   r1,1(,r1)                 |     Add 1 back for updates.\n       ar   r14,r1                    |     Bump target pointer.\n       sr   r15,r1                    |     Decrement target length.\n       ar   r6,r1                     |     Bump source pointer.\n       sr   r7,r1                     |     Decrement source length.\n      endif                           |    EndIf.\n      if (treg,r15,p)                 |    If padding required.\n       loop while,(cr,r15,ge,r0)      |     Loop for big chunks.\n        mvc  0(256,r14),=cl256' '     |      Fill w/blanks.\n        ar   r14,r0                   |      Bump target pointer.\n        sr   r15,r0                   |      Decrement target length.\n       endloop while                  |     EndLoop.\n       if (treg,r15,p)                |     If anything left.\n        bctr r15,0                    |      Subtract 1 for EX instr.\n        exi  r15,(mvc,0(0,r14),=cl256' ')    Pad remainder w/blanks.\n       endif                          |     EndIf.\n      endif                           |    EndIf.\n     endif                            |   EndIf.\n     ltr     r15,r5                   |   Get truncation return-code.\n     errexit nz,code=0                |   Exit if truncated.\n   endif                              | EndIf.\n   callsub message,(fi00000)          | Successful completion.\n endblk block=writeline               |\n             ssd\n&s.ebcdic_to_ascii ds    0cl256\n*                 0 1 2 3 4 5 6 7 8 9 A B C D E F\n             dc x'2E2E2E2E2E2E2E2E2E2E2E2E2E2E2E2E'   0\n             dc x'2E2E2E2E2E2E2E2E2E2E2E2E2E2E2E2E'   1\n             dc x'2E2E2E2E2E2E2E2E2E2E2E2E2E2E2E2E'   2\n             dc x'2E2E2E2E2E2E2E2E2E2E2E2E2E2E2E2E'   3\n             dc x'202E2E2E2E2E2E2E2E2E2E2E3C282B7C'   4\n             dc x'262E2E2E2E2E2E2E2E2E21242A293B5E'   5\n             dc x'2D2F2E2E2E2E2E2E2E2E7C2C255F3E3F'   6\n             dc x'2E2E2E2E2E2E2E2E2E603A2340273D22'   7\n             dc x'2E6162636465666768692E7B2E282B2B'   8\n             dc x'2E6A6B6C6D6E6F7071722E7D2E292E2E'   9\n             dc x'2E2E737475767778797A2E2E2E5B2E2E'   A\n             dc x'303132333435363738392E2E2E5D2E2D'   B\n             dc x'7B4142434445464748492E2E2E2E2E2E'   C\n             dc x'7D4A4B4C4D4E4F5051522E2E2E2E2E2E'   D\n             dc x'5C00535455565758595A2E2E2E2E2E2E'   E\n             dc x'303132333435363738392E2E2E2E2E2E'   F\n             endssd\n             swa\n&w.putbuf    ds   a\n&w.length    ds   f\n             endswa\n eject                                |\n***********************************************************************\n*                                                                     *\n*  Subroutine: GET_INFO                                               *\n*  Abstract:   Return selected information to the caller.             *\n*                                                                     *\n***********************************************************************\n block name=get_info,type=subroutine  |\n* *-------------------------------------------------------------------*\n* * Return info for each information sub-code parameter.\n* *-------------------------------------------------------------------*\n  la     r7,fi_gi_function            | r7 -> 1st info subcode parm.\n  using  fi_gi_function,r7            | Address get_info parms.\n  loop   until                        | Loop for each gi_function parm.\n   l       r2,fi_gi_function          |   R2 -> information sub-code.\n   l       r1,0(,r2)                  |   R1 := information sub-code.\n   caseblk reg=r1,wreg=r1,mult=1      |   Case on information sub-code.\n   case &fi_gi_msg                    | *-------------------------> MSG\n     if not,((tbit,fi_gi_function,x'80',off),and,    make sure area,   +\n               (tbit,fi_gi_area,x'80',off),and,      area_size, and    +\n               (tbit,fi_gi_area_size,x'80',off))     length are present\n       callsub message,(fi00006,\"GET_INFO (MSG)\",14)\n       errexit code=0                 |\n     endif                            |   EndIf.\n     lm r2,r3,fi_gi_area              |   R2/R3 -> text area, length.\n     l  r3,0(r3)                      |   R3 := length of text area.\n     lm r4,r5,pwa_msg_data            |   R4/R5 -> message text/length.\n     if (treg,r4,z),or,(treg,r5,z)    |   If no message then.\n       slr  r4,r4                     |     Ensure both address and\n       slr  r5,r5                     |     length are all zeros.\n     else                             |   Else.\n       l  r5,0(r5)                    |     R5 := length of message.\n       if (cr,r5,gt,r3)               |     If too long to fit in area.\n         lr r5,r3                     |       Reduce to exact length.\n       endif                          |     EndIf.\n     endif                            |   EndIf.\n     l    r1,fi_gi_length             |   R1 -> message length parm.\n     st   r5,0(r1)                    |   Save length of returned msg.\n     icm  r5,8,=c' '                  |   Pad copied text with blanks.\n     mvcl r2,r4                       |   Copy information to caller.\n     if   (tbit,fi_gi_length,x'80',on)    If we used the last parm.\n      leave loop=*                    |    We're done.\n     endif                            |   EndIf.\n     la   r7,4*4(,r7)                 |   Point r7 past parms we used.\n   case &fi_gi_name                   | *------------------------> NAME\n     if not,((tbit,fi_gi_function,x'80',off),and,    make sure area,   +\n               (tbit,fi_gi_area,x'80',off),and,      area_size, and    +\n               (tbit,fi_gi_area_size,x'80',off))     length are present\n       callsub message,(fi00006,\"GET_INFO (NAME)\",15)\n       errexit code=0                 |\n     endif                            |   EndIf.\n     lm r2,r4,fi_gi_area              |   R2/R4 -> area/length/retlen.\n     la r5,=f'0'                      |   Set up zero-length.\n     if (cli,pwa_member,ne,c' ')      |   If there is a member name.\n       la r5,=f'1'                    |     R1 := length of ( or ).\n     endif                            |   EndIf.\n     lr        r14,r2                 |   r14 -> area.\n     l         r15,0(r3)              |   r15 := length of area.\n     slr       r0,r0                  |   r0 -> Null source string.\n     slr       r1,r1                  |   r1 := Null source length.\n     icm       r1,b'1000',=c' '       |   Insert blank for padding.\n     mvcl      r14,r0                 |   Clear area w/blanks.\n     st_format id=st,string=(0(r2),0(r3)),resultlen=0(r4),             +\n               control=\"{CL44 TRIM}{CL?}{CL8 T}{CL?}\",                 +\n               source=(pwa_dsname,\"(\",0(r5),pwa_member,\")\",0(r5))\n     if (c,r15,eq,=f'&st_truncated')  |   If filename truncated.\n       callsub message,(fi00021)      |     Issue a message and quit.\n       errexit code=0                 |\n     elseif (treg,r15,nz)             |   ElseIf a problem occurred.\n       callsub message,(fi00003)      |     Internal error.\n       errexit code=0                 |\n     endif                            |   EndIf.\n     if   (tbit,fi_gi_length,x'80',on)    If we used the last parm.\n      leave loop=*                    |    We're done.\n     endif                            |   EndIf.\n     la   r7,4*4(,r7)                 |   Point r7 past parms we used.\n   case &fi_gi_ddname                 | *----------------------> DDNAME\n     if not,((tbit,fi_gi_function,x'80',off),and,    make sure area,   +\n               (tbit,fi_gi_area,x'80',off),and,      area_size, and    +\n               (tbit,fi_gi_area_size,x'80',off))     length are present\n       callsub message,(fi00006,\"GET_INFO (DDNAME)\",17)\n       errexit code=0                 |\n     endif                            |   EndIf.\n     lm r2,r4,fi_gi_area              |   R2/R4 -> area/length/retlen.\n     lr        r14,r2                 |   r14 -> area.\n     l         r15,0(r3)              |   r15 := length of area.\n     slr       r0,r0                  |   r0 -> Null source string.\n     slr       r1,r1                  |   r1 := Null source length.\n     icm       r1,b'1000',=c' '       |   Insert blank for padding.\n     mvcl      r14,r0                 |   Clear area w/blanks.\n     st_format id=st,string=(0(r2),0(r3)),resultlen=0(r4),             +\n               control=\"{CL? TRIM}\",                                   +\n               source=(pwa_ddname,=a(l'pwa_ddname))\n     if (c,r15,eq,=f'&st_truncated')  |   If filename truncated.\n       callsub message,(fi00021)      |     Issue a message and quit.\n       errexit code=0                 |\n     elseif (treg,r15,nz)             |   ElseIf a problem occurred.\n       callsub message,(fi00003)      |     Internal error.\n       errexit code=0                 |\n     endif                            |   EndIf.\n     if   (tbit,fi_gi_length,x'80',on)    If we used the last parm.\n      leave loop=*                    |    We're done.\n     endif                            |   EndIf.\n     la   r7,4*4(,r7)                 |   Point r7 past parms we used.\n   case &fi_gi_volume                 | *----------------------> VOLUME\n     if not,((tbit,fi_gi_function,x'80',off),and,    make sure area,   +\n               (tbit,fi_gi_area,x'80',off),and,      area_size, and    +\n               (tbit,fi_gi_area_size,x'80',off))     length are present\n       callsub message,(fi00006,\"GET_INFO (VOLUME)\",17)\n       errexit code=0                 |\n     endif                            |   EndIf.\n     lm r2,r4,fi_gi_area              |   R2/R4 -> area/length/retlen.\n     lr        r14,r2                 |   r14 -> area.\n     l         r15,0(r3)              |   r15 := length of area.\n     slr       r0,r0                  |   r0 -> Null source string.\n     slr       r1,r1                  |   r1 := Null source length.\n     icm       r1,b'1000',=c' '       |   Insert blank for padding.\n     mvcl      r14,r0                 |   Clear area w/blanks.\n     st_format id=st,string=(0(r2),0(r3)),resultlen=0(r4),             +\n               control=\"{CL? TRIM}\",                                   +\n               source=(pwa_volser,=a(l'pwa_volser))\n     st   r15,pwa_save_r15            | Preserve r15 for errexit\n     if (c,r15,eq,=f'&st_truncated')  |   If filename truncated.\n       callsub message,(fi00021)      |     Issue a message and quit.\n       l    r15,pwa_save_r15          | Rest r15 for debug analysis\n       errexit code=0                 |\n     elseif (treg,r15,nz)             |   ElseIf a problem occurred.\n       callsub message,(fi00003)      |     Internal error.\n       l    r15,pwa_save_r15          | Rest r15 for debug analysis\n       errexit code=0                 |\n     endif                            |   EndIf.\n     if   (tbit,fi_gi_length,x'80',on)    If we used the last parm.\n      leave loop=*                    |    We're done.\n     endif                            |   EndIf.\n     la   r7,4*4(,r7)                 |   Point r7 past parms we used.\n   case &fi_gi_lrecl                  | *-----------------------> LRECL\n     if not,(tbit,fi_gi_function,x'80',off)           make sure area\n       callsub message,(fi00006,\"GET_INFO (LRECL)\",16)    is present.\n       errexit code=0                 |\n     endif                            |   EndIf.\n     if (tbit,pwa_1_open,off) If file is not OPEN.\n       callsub message,(fi00114,\"GET_INFO (LRECL)\",16)\n       errexit code=0                 |     Exit w/return-code.\n     else                             |   Else.\n       l     r2,fi_gi_area            |     R2 -> Halfword for LRECL.\n       l     r1,pwa_lrecl             |     R1 := actual lrecl.\n       stcm  r1,b'0011',0(r2)         |     Copy lrecl value to area.\n     endif                            |   EndIf.\n     if   (tbit,fi_gi_area,x'80',on)  |   If we used the last parm.\n      leave loop=*                    |    We're done.\n     endif                            |   EndIf.\n     la   r7,2*4(,r7)                 |   Point r7 past parms we used.\n   case &fi_gi_recfm                  | *-----------------------> RECFM\n     if not,(tbit,fi_gi_function,x'80',off)           make sure area\n       callsub message,(fi00006,\"GET_INFO (RECFM)\",16)    is present\n       errexit code=0                 |\n     endif                            |   EndIf.\n     if (tbit,pwa_1_open,off) If file is not OPEN.\n       callsub message,(fi00114,\"GET_INFO (RECFM)\",16)\n       errexit code=0                 |     Exit w/return-code.\n     else                             |   Else.\n       l     r2,fi_gi_area            |     R2 -> Return area.\n       mvc   0(8,r2),=cl8' '          |     Blank out unused positions.\n       la    r3,pwa_dcb               |     R3 -> File's open DCB.\n       using ihadcb,r3                |     Establish addressability.\n       if  (tbit,dcbrecfm,dcbrecf)    |     If FIXED length records.\n         mvi 0(r2),c\"F\"               |       Return an 'F'.\n       else                           |     Else.\n         mvi 0(r2),c\"V\"               |       Return a 'V'.\n       endif                          |     EndIf.\n       if  (tbit,dcbrecfm,DCBRECBR)   |     If BLOCKED records.\n         mvi 1(r2),c\"B\"               |       Return a 'B'.\n       endif                          |     EndIf.\n       if  (tbit,dcbrecfm,dcbrecca)   |     IF ASA control char\n        mvi 2(r2),c\"A\"                |       Return an \"A\".\n       elseif  (tbit,dcbrecfm,dcbreccm)     ElseIF Machine control char\n        mvi 2(r2),c\"M\"                |       Return an \"M\".\n       endif                          |     EndIf.\n     endif                            |   EndIf.\n     if   (tbit,fi_gi_area,x'80',on)  |   If we used the last parm.\n      leave loop=*                    |    We're done.\n     endif                            |   EndIf.\n     la   r7,2*4(,r7)                 |   Point r7 past parms we used.\n   case &fi_gi_idstring               | *--------------------> IDSTRING\n     if not,(tbit,fi_gi_function,x'80',off)            make sure area\n       callsub message,(fi00006,\"GET_INFO (IDSTRING)\",19)  is present.\n       errexit code=0                 |\n     endif                            |   EndIf.\n     if (tbit,pwa_1_open,off) If file is not OPEN.\n       callsub message,(fi00114,\"GET_INFO (IDSTRING)\",19)\n       errexit code=0                 |     Exit w/return-code.\n     else                             |   Else.\n       l r2,fi_gi_area                |     R2 -> Return area.\n       mvc 0(8,r2),=cl8' '            |     Initialize it to blanks.\n       if (cli,pwa_member,ne,c' ')    |     If there is a member name.\n         mvc 0(8,r2),pwa_member       |       Copy member name.\n       else                           |     Else.\n         ds  0h                       |       Do nothing.\n       endif                          |     EndIf.\n     endif                            |   EndIf.\n     if   (tbit,fi_gi_area,x'80',on)  |   If we used the last parm.\n      leave loop=*                    |    We're done.\n     endif                            |   EndIf.\n     la   r7,2*4(,r7)                 |   Point r7 past parms we used.\n   case other                         | *---------------------> *ERROR*\n       callsub message,(fi00022,0(r2))\n       errexit code=0\n   endcase                            | EndCase\n  endloop until,leave                 | EndLoop.\n endblk block=get_info                |\n           swa\n           endswa\n eject\n***********************************************************************\n*                                                                     *\n*  Subroutine: SET_STATUS                                             *\n*  Abstract:   Set status information about the current file based on *\n*              the provided parameters.                               *\n*                                                                     *\n***********************************************************************\n block name=set_status,type=subroutine\n*---------------------------------------------------------------------*\n*  Call the routine that sets the specified status.\n*---------------------------------------------------------------------*\n   l       r2,fi_ss_function          | R2 -> status sub-code.\n   l       r1,0(,r2)                  | R1 := status sub-code.\n   caseblk reg=r1,wreg=r1,mult=1      | Case on status sub-code.\n   case &fi_ss_end_of_file            | *-----------------> END_OF_FILE\n     if (cli,pwa_oo_mode,eq,&fi_oo_input)    If INPUT mode.\n       sbit pwa_1,pwa_1_eof           |        Mark end-of-file.\n     elseif (cli,pwa_oo_mode,eq,&fi_oo_output) If OUTPUT mode.\n       if (cli,pwa_member,ne,c\" \"),and,        If a member written to  +\n               (tbit,pwa_1_ds_not_existing,off) existing pds.\n         if (tbit,pwa_1_member)                  If replaced.\n           la r6,=cl8\"replaced\"       |            R6 -> \"REPLACED\"\n         else                         |          Else, created.\n           la r6,=cl8\"created \"       |            R6 -> \"CREATED \"\n         endif                        |          EndIf.\n         callsub message,(fi00301,pwa_member,0(r6),pwa_dsname)\n       else                           |        ELSE\n         if (tbit,pwa_1_ds_not_existing) if dataset created.\n           la r6,=cl8\"created \"       |            R6 -> \"CREATED \"\n         else                         |          Else, replaced.\n           la r6,=cl8\"replaced\"       |            R6 -> \"REPLACED\"\n         endif                        |          EndIf.\n         la r5,=f'0'                  |          Set up zero-length.\n         if (cli,pwa_member,ne,c' ')  |          If a member name.\n           la r5,=f'1'                |            R5 := length of \"(\".\n         endif                        |          EndIf.\n         callsub message,(fi00300,    |                                +\n               pwa_dsname,\"(\",0(r5),pwa_member,\")\",0(r5),0(r6))\n       endif                          |        EndIf.\n     endif                            |      EndIf.\n     errexit code=&fi_end_of_file     |      Exit w/EOF return-code.\n   case other                         | *---------------------> *ERROR*\n     callsub message,(fi00031,0(r2))  |   Issue an error message.\n     errexit code=0                   |   Exit w/return-code.\n   endcase                            | EndCase\n   callsub message,(fi00000)          | Successful completion.\n endblk block=set_status\n***********************************************************************\n*                                                                     *\n*  Subroutine: GET_REFERENCE                                          *\n*  Abstract:   Return reference string to the caller.                 *\n*                                                                     *\n***********************************************************************\n block name=get_reference,type=subroutine  |\n* *-------------------------------------------------------------------*\n* * Return reference string.\n* *-------------------------------------------------------------------*\n  l      r7,fi_gr_reference           | r7 -> reference string.\n  mvc   0(l'pwa_fi_reference,r7),pwa_fi_reference\n endblk block=get_reference           |\n*                                     |   to caller.\n eject\n***********************************************************************\n*                                                                     *\n*  Subroutine: FIND                                                   *\n*  Abstract:   Process FIND function.                                 *\n*                                                                     *\n***********************************************************************\n block name=find,type=subroutine,amode=31,options=codebase\n*  *------------------------------------------------------------------*\n*  * Make sure file is open and OPTION=LIBRARY is specified.\n*  *------------------------------------------------------------------*\n   if (tbit,pwa_1_open,off)           |  If not open:\n     callsub message,(fi00114,\"FIND\",4) Fuss.\n     errexit code=0                   |    Exit.\n   elseif (cli,pwa_oc2_library,ne,&fi_oc2_library) If LIBRARY option.\n     callsub message,(fi00042,\"FIND\",4)  Elseif not OPTION=LIBRARY:\n     errexit code=0                   |    Fuss and exit.\n   endif                              |  Endif.\n*  *------------------------------------------------------------------*\n*  * Initialize.\n*  *------------------------------------------------------------------*\n   fill  pwa_member,x'40'             |  Blank out member name.\n   sbit  pwa_1_eof                    |  Indicate EOF.\n   rbit  pwa_2_valid_find_active      |  Indicate no active FIND.\n*  *------------------------------------------------------------------*\n*  * Move member name to PWA.\n*  *------------------------------------------------------------------*\n   l     r2,fi_fd_length              |  r2 -> length.\n   l     r15,0(,r2)                   |  r15 = length.\n   if (treg,r15,np)                   |  if not positive:\n     callsub message,(fi00014)        |    Save error message\n     errexit code=0                   |    and exit.\n   elseif (chi,r15,gt,l'pwa_member)   |  Else if too long:\n     callsub message,(fi00015,0(,r2)) |    Save error message\n     errexit code=0                   |    and exit.\n   endif                              |  Endif.\n   bctr  r15,0                        |  Sub 1 for ex.\n   l     r1,fi_fd_member              |  r1 -> requested member.\n   exi   r15,(mvc,pwa_member,0(r1))   |  Move it to pwa.\n   tr   pwa_member,fold               |  Fold member-name to caps.\n   trt  pwa_member,lettrdig           |  Scan for invalid characters.\n   if  (nz,and,(cli,0(r1),ne,c' ')),or,(cli,pwa_member,ge,c'0')\n     callsub message,(fi00016,pwa_member) Name must not start with\n     errexit code=0                   |   number or be blank.\n   endif                              |\n*  *------------------------------------------------------------------*\n*  * Find member.\n*  *------------------------------------------------------------------*\n   block amode=24                     |  Block amode=24.\n     find  pwa_dcb,pwa_member,d       |    Find member.\n     st    r0,&w.reason               |    Save reason.\n     st    r15,&w.rc                  |    Save return code.\n   endblk                             |  Endif.\n   l     r0,&w.reason                 |  r0 = reason.\n   l     r15,&w.rc                    |  r15 = return code.\n   if (treg,r15,z)                    |  If find successful:\n     sbit  pwa_2_valid_find_active    |    Indicate valid find active.\n     rbit  pwa_1_eof                  |    Reset EOF.\n*    *----------------------------------------------------------------*\n*    * Do initial reads.  Set current as final BENT with remaining\n*    * of zero so that first FI_READLINE will wrap to first BENT\n*    * and do a CHECK.\n*    *----------------------------------------------------------------*\n     fill  pwa_bent_current_remaining |    No date in current buffer.\n     l     r3,pwa_bent_buffer_address |    Establish base for\n     using bent_start,r3              |    buffer entries.\n     loop until                       |    Loop starting reads:\n      st    r3,pwa_bent_current       |      Current will be last buff.\n      mvc   bent_decb,&psd.decb       |      Move base DECB to entry.\n      block amode=24                  |      Block amode=24.\n       read  bent_decb,sf,pwa_dcb,bent_data_start,mf=e   Read block.\n      endblk                          |      Endblk.\n      l     r3,pwa_bent_buffer_address       Point to next buffer.\n     endloop until,(c,r3,eq,pwa_bent_buffer_address)\n     drop  r3                         |    Endloop.  Drop entry base.\n*    *----------------------------------------------------------------*\n   elseif (chi,r15,eq,4),and,(treg,r0,z) Else if member not found:\n     callsub message,(fi00040,pwa_member)  Save message.\n     errexit code=&fi_not_found       |    Exit.\n   else                               |  Else:\n     callsub message,(fi00041,pwa_member,&w.rc,&w.reason)\n     errexit code=0                   |    Save message and exit.\n   endif                              |  Endif.\n*  *------------------------------------------------------------------*\n   callsub message,(fi00000)          |  Successful completion.\n endblk block=find                    |\n         swa                          |\n&w.rc                          ds f   |\n&w.reason                      ds f   |\n         endswa                       |\n eject\n title \"SRVFIOS - Internal subroutines called by Function routines\"\n***********************************************************************\n*                                                                     *\n*  Subroutine: PARSE_FILENAME                                         *\n*  Abstract:   Scan the file-specification to validate it as an OS    *\n*              data set name and to split the dsname from the member. *\n*                                                                     *\n***********************************************************************\n block name=parse_filename,type=subroutine\n   fill pwa_dsname,c' '           |   Blank out the data set name.\n   mvc  pwa_member,=cl8' '        |   Blank out the member name.\n*---------------------------------------------------------------------*\n*  R4 -> file-specification.  R5 := file specification's length.\n*---------------------------------------------------------------------*\n   l     r4,fi_filename           | R4 := file-specification's text.\n   la    r4,0(,r4)                | Clear high-bit.\n   leave block=*,(treg,r4,z)      | Return now if null.\n   l  r5,fi_namelength            | R5 -> length of file-specification.\n   l  r5,0(,r5)                   | R5 := length of file-specification.\n   if (treg,r5,np)                | If zero-length filename.\n     callsub message,(fi00011)    |   Issue a message and quit.\n     errexit code=0               |\n   endif                          | EndIf.\n*---------------------------------------------------------------------*\n*  If the file is identified by DDNAME, copy it to the PWA.\n*---------------------------------------------------------------------*\n   if (cli,pwa_oc_ident,eq,&fi_oc_fileid)\n     st        r5,&w.length         | Save length for parmlist access.\n     st_format id=st,string=pwa_ddname,control='{?cl? caps trim}',     +\n               source=(=a(l'pwa_ddname),0(r4),&w.length)\n     st   r15,pwa_save_r15          | Preserve r15 for errexit\n     if (c,r15,eq,=f'&st_truncated')  if longer than 8 characters.\n       callsub message,(fi00025,=a(l'pwa_ddname),(r4),&w.length)\n       l    r15,pwa_save_r15        | Restore r15 for debug analysis\n       errexit code=0               |\n     elseif (treg,r15,nz)           | Else.\n       callsub message,(fi00003)    |   Unknown error.\n       l    r15,pwa_save_r15        | Restore r15 for debug analysis\n       errexit code=0               |   Return to caller.\n     endif                          | EndIf.\n     leave block=*\n   endif\n   eject\n*---------------------------------------------------------------------*\n*  If the file-spec is quoted, remove quotes.  Else obtain prefix.\n*---------------------------------------------------------------------*\n   fill    &w.prefix,c' '         | No dsname prefix being used, yet.\n   la      r5,0(r5,r4)            | R5 -> past end of file-spec.\n   loop    until                  | Scan back for final non-blank.\n    bctr  r5,0                    |  Back up one character.\n   endloop until,(cr,r5,le,r4),or,(cli,0(r5),gt,c' ')\n   if (cli,0(r4),eq,c'''')        | If file-spec is quoted, then.\n     la r4,1(,r4)                 |   Advance past starting quote.\n     if (cli,0(r5),eq,c'''')      |   If trailing quote is present.\n       bctr  r5,0                 |     Remove trailing quote.\n     endif                        |   EndIf.\n     if (cr,r4,gt,r5)             |   If zero-length filename.\n       callsub message,(fi00011)  |     Issue a message and quit.\n       errexit code=0             |\n     endif                        |   EndIf.\n   else                           | Else -- it needs to be prefixed --\n     es_get_prefix id=es,prefix=&w.prefix\n     if (cli,&w.prefix,ne,c' ')   |   If a prefix was obtained.\n       la      r15,&w.prefix+7    |      Point to end of 8-byte field.\n       loop    bct                |      Loop back to a non-blank.\n         leave loop=*,(cli,0(r15),ne,c' ')\n       endloop bct,r15            |      EndLoop.\n       mvi     1(r15),c'.'        |      Put '.' on end of prefix.\n     endif                        |   EndIf.\n   endif                          |\n   eject\n*---------------------------------------------------------------------*\n*  Copy the data set name to PWA storage and fold it to uppercase.\n*---------------------------------------------------------------------*\n   lr   r7,r4                     | R7 -> Start of data set name.\n   loop while,(cr,r7,le,r5)\n     leave loop=*,(cli,0(r7),le,c' ')\n     leave loop=*,(cli,0(r7),eq,c'(')\n     la r7,1(,r7)                 |   Advance to next character.\n   endloop while                  | EndLoop.\n   sr r7,r4                       | R7 := length of dsname.\n   if (treg,r7,np)                | If zero-length filename.\n     callsub message,(fi00011)    |   Issue a message and quit.\n     errexit code=0               |\n   endif                          | EndIf.\n   st        r7,&w.length         | Save length for plist access.\n   st_format id=st,string=pwa_dsname,                                  +\n               control=\"{?CL0}{@1CL9 CAPS TRIM}{CL? CAPS}\",            +\n               source=(=a(l'pwa_dsname),,&w.prefix,0(r4),&w.length)\n   st   r15,pwa_save_r15          | Preserve r15 for errexit\n   if (c,r15,eq,=f'&st_truncated')  if longer than 44 characters.\n     callsub message,(fi00018,=a(l'pwa_dsname),(r4),&w.length)\n     l    r15,pwa_save_r15        | Restore r15 for debug analysis\n     errexit code=0               |\n   elseif (treg,r15,nz)           | Else.\n     callsub message,(fi00003)    |   Unknown error.\n     l    r15,pwa_save_r15        | Restore r15 for debug analysis\n     errexit code=0               |   Return to caller.\n   endif                          | EndIf.\n   la   r4,0(r7,r4)               | R4 -> past DSNAME in file-spec.\n   eject\n*---------------------------------------------------------------------*\n*  Validate the entire (possibly prefixed) data set name's syntax.\n*---------------------------------------------------------------------*\n   la   r6,pwa_dsname             | R6 -> start of DSNAME.\n   la   r7,l'pwa_dsname(,r6)      | R7 -> past end of DSNAME.\n   loop until                     | Loop over data set name.\n     lr r3,r6                     |   R3 -> Current character.\n     loop while,(cr,r3,lt,r7)     |   Scan ahead for '.'.\n       leave loop=*,(cli,0(r3),eq,c' ')  leave if past end of dsname.\n       leave loop=*,(cli,0(r3),eq,c'.')  leave if at the dot.\n       la    r3,1(,r3)            |      Advance to next character.\n     endloop while                |   EndLoop\n     sr  r3,r6                    |   R3 := length of qualifier.\n     st  r3,&w.length             |   Save for parm access.\n*                                 |\n     if (treg,r3,np)              |   If zero-length qualifier.\n       callsub message,(fi00020)  |     Issue a message and quit.\n       errexit code=0             |\n     elseif (c,r3,gt,=f'8')       |   ElseIf qualifier longer than 8.\n       callsub message,(fi00019,0(r6),&w.length)\n       errexit code=0             |\n     endif                        |   EndIf.\n*                                 |\n     bctr r3,0                    |   Subtract 1 for EX instruction.\n     exi  r3,(trt,0(0,r6),lettrdig)   scan for invalid characters.\n     if   nz,or,(cli,0(r6),ge,c'0')   if invalid characters found.\n       callsub message,(fi00017,0(r6),&w.length)\n       errexit code=0             |\n     else                         |   Else.\n       la    r6,1(r3,r6)          |     Advance to the dot.\n       leave loop=*,(cr,r6,ge,r7) |     Leave if no dot.\n       leave loop=*,(cli,0(r6),eq,c' ') leave if past end of dsname.\n       la    r6,1(,r6)            |     Advance beyond the dot.\n     endif                        |   EndIf.\n   endloop until,leave            | EndLoop.\n   eject\n*---------------------------------------------------------------------*\n*  If a member name was specified, parse it.\n*---------------------------------------------------------------------*\n   if (cr,r4,gt,r5)               | If nothing is left.\n     mvc pwa_member,=cl8' '       |   Blank out the member name.\n   else                           | Else rest of stuff is (member).\n     if (cli,0(r5),eq,c')')       |   If closing parenthesis there.\n       bctr  r5,0                 |     Backup by one char.\n     endif                        |   EndIf.\n     slr   r5,r4                  |   R5 := member name's length.\n     la    r4,1(,r4)              |   Advance past open parenthesis.\n     if    (treg,r5,np)           |   If zero-length member name.\n       callsub message,(fi00014)  |     Issue a message and quit.\n       errexit code=0             |\n     elseif (c,r5,gt,=f'8')       |   ElseIf too long.\n       callsub message,(fi00015,8)      issue a message and quit.\n       errexit code=0             |\n     else                         |   Else.\n       la   r0,pwa_member         |     R0 -> destination of move.\n       la   r1,l'pwa_member       |     R1 := destination length.\n       icm  r5,8,=c' '            |     Pad move with blanks.\n       mvcl r0,r4                 |     Move member name.\n       tr   pwa_member,fold       |     Fold member-name to caps.\n       trt  pwa_member,lettrdig   |     Scan for invalid characters.\n       if  (nz,and,(cli,0(r1),ne,c' ')),or,(cli,pwa_member,ge,c'0')\n         callsub message,(fi00016,pwa_member)\n         errexit code=0           |\n       endif                      |\n     endif                        |   EndIf.\n   endif                          | EndIf.\n endblk block=parse_filename\n*---------------------------------------------------------------------*\n* Working storage for parsing data set names and DDNAMES.\n*---------------------------------------------------------------------*\n           swa\n&w.length  ds f\n&w.prefix  ds cl9\n           endswa\n           eject\n***********************************************************************\n*                                                                     *\n*  Subroutine: Allocate_File                                          *\n*  Abstract:   Allocate the specified file.                           *\n*                                                                     *\n***********************************************************************\n block type=subroutine,name=allocate_file\n* *-------------------------------------------------------------------*\n* * If a DDNAME was specified, use dynamic allocation to obtain info\n* * about the file.  If the DDNAME is already allocated, process the\n* * returned information and then return.  If the DDNAME is not already\n* * allocated, continue on t0 the next section of code.\n* *\n* * NOTE: Because the START function picks through caller-supplied text\n* *       units for information, the DDNAME being used may have come\n* *       from there instead of the FILE= operand.  If so, and if the\n* *       DDNAME is already allocated, we will pick the pre-existing\n* *       allocation with that DDNAME and the FILE=<dsname> operand\n* *       will not get used.  If the DDNAME is not already allocated,\n* *       we'll make a new allocation in the next section of code.\n* *\n* *-------------------------------------------------------------------*\n  if (clc,pwa_ddname,ne,=cl8' ')        | If FILE=<ddname> then\n    mvc &w.ddname,da_ir_ddname          | Copy DDNAME text unit.\n    mvc &w.ret_dsorg,da_ir_ret_dsorg    | Set up return-DSORG  t.u.\n    mvc &w.ret_dsname,da_ret_dsname     | Set up return-DSNAME t.u.\n    mvc &w.ret_member,da_ret_member     | Set up return-MEMBER t.u.\n    mvc &w.ret_status,da_ret_status     | Set up return-STATUS t.u.\n    mvc &w.ret_attrs,da_ret_attrs       | Set up return-ATTRS    @DD\n    mvc &w.ret_ndisp,da_ret_ndisp       | Set up return-DISP   t.u.\n    mvc s99tupar-s99tunit+&w.ddname(8),pwa_ddname\n    plist (&w.ddname,&w.ret_dsorg,&w.ret_dsname,&w.ret_member,         +\n               &w.ret_attrs,&w.ret_status),vl,pl=pwa_textunits\n    callsub dynalloc,                   | Invoke dynamic allocation    +\n               (=al1(s99vrbin),         |     information retrieval.   +\n               =al1(s99nomnt,0),        |     nomount,          @CNENQ +\n               =al4(0),                 |     No authorized flags.     +\n               pwa_err_msg,             |     Return message area.     +\n               =a(l'pwa_err_msg),       |     Length of message area.  +\n               pwa_err_msg_len,         |     Length of returned msg.  +\n               pwa_textunits),vl        |     TextUnits.\n    if (treg,r15,z)                     | If DDNAME allocated then.\n      sbit  pwa_1,pwa_1_allocated       |   DDNAME is allocated.\n      mvc   pwa_dsname,s99tupar-s99tunit+&w.ret_dsname\n      mvc   pwa_member,s99tupar-s99tunit+&w.ret_member\n      mvc   pwa_ndisp,s99tupar-s99tunit+&w.ret_ndisp\n      mvc   pwa_status,s99tupar-s99tunit+&w.ret_status\n      lm    r1,r3,=a(da_dsorg_table,2+4,da_dsorg_table_e)\n      loop  bxle\n        leave loop=*,(clc,0(2,r1),eq,s99tupar-s99tunit+&w.ret_dsorg)\n      endloop bxle,r1,r2\n      mvc   pwa_dsorg,2(r1)             |   Copy char DSORG to pwa.\n      if    (tbit,s99tupar-s99tunit+&w.ret_attrs,x'80',on) Concat'd?\n       sbit  pwa_2_concatenated         |   Note in PWA\n       mvc   pwa_dsorg,=c'PS  '         |   Force it to sequential.\n       fill  pwa_member,c' '            |   Destroy member name\n      endif                             |\n      if (clc,=c'****',eq,pwa_dsorg)    |   If DSORG = undefined.\n        if  (cli,pwa_oo_mode,eq,&fi_oo_output)   If OUTPUT mode.\n          mvc pwa_dsorg,=c'PS  '        |         Make it PS.\n        endif                           |       EndIf.\n      endif                             |   EndIf.\n*\n*     If the data set is sequential, but a member name was returned\n*     that looks like a generation reference, then blank out the member\n*     name and pretend we didn't see it.  A generation reference must\n*     be an optional sign followed by digits, padded with blanks.\n*     If this is the case, the data set name returned has the GxxxxVyy\n*     qualifier on it anyways so there is no need for a member name.\n*\n      if (clc,=c'PS',eq,pwa_dsorg),and,(cli,pwa_member,ne,c' ')\n        la r2,pwa_member                |     r2 -> Start of member.\n        la r3,pwa_member+l'pwa_member   |     r3 -> Past end of fiel\n        if (cli,0(r2),eq,c'+'),or,(cli,0(r2),eq,c'-')\n          la r2,1(,r2)                  |       Advance past sign.\n        endif                           |     EndIf.\n        loop while,(cr,r2,lt,r3)        |     Loop over <digits>.\n          leave loop=*,(cli,0(r2),lt,c'0'),or,(cli,0(r2),gt,c'9')\n          la    r2,1(,r2)               |       Advance 1 char.\n        endloop while                   |     EndLoop.\n        loop while,((cr,r2,lt,r3),and,(cli,0(r2),eq,c' '))\n          la    r2,1(,r2)               |       Advance 1 char.\n        endloop while                   |     EndLoop.\n        if (cr,r2,eq,r3)                |     If \u00dd+|-\u00a8<digit><blank>\n          mvc pwa_member,=cl8' '        |       Blank out member.\n        endif                           |     EndIf.\n      endif                             |   EndIf.\n      leave block=*                     |   Return to caller.\n    endif                               |   EndIf.\n  endif                                 | EndIf.\n* *-------------------------------------------------------------------*\n* * Either no DDNAME was specified or the specified DDNAME was not\n* * pre-allocated.  If a DSNAME was specified, attempt to allocate to\n* * it and retrieve information.  Again, caller-supplied text units are\n* * not used for allocation to a pre-existing data set.\n* *-------------------------------------------------------------------*\n  if (cli,pwa_dsname,ne,c' ')           | If dsname was specified.\n    fill  pwa_textunits,x'00'           |   Clear text unit pointers.\n    la    r7,pwa_textunits              |   r7 -> text unit pointers.\n    using &s.dsntup,r7                  |\n    mvc   &w.dsname,da_dsname           |   Copy DSNAME text unit.\n    mvc   s99tupar-s99tunit+&w.dsname(44),pwa_dsname\n    la    r14,&w.dsname                 |\n    st    r14,&s.dsntup_dsname          |\n    if    (cli,pwa_member,ne,c' ')      |   If MEMBER specified.\n      mvc   &w.member,da_member         |     Copy MEMBER text unit.\n      mvc   s99tupar-s99tunit+&w.member(8),pwa_member\n      la    r14,&w.member               |\n      st    r14,&s.dsntup_member        |\n    endif                               |   EndIf.\n    if    (cli,pwa_ddname,ne,c' ')      |   If DDNAME specified.\n      mvc   &w.ddname,da_ddname         |     Copy DDNAME text unit.\n      mvc   s99tupar-s99tunit+&w.ddname(8),pwa_ddname\n      la    r14,&w.ddname               |\n      st    r14,&s.dsntup_ddname        |\n    else                                |   Else\n      mvc   &w.ret_ddname,da_ret_ddname |     Set up return-DDNAME t.u.\n      la    r14,&w.ret_ddname           |\n      st    r14,&s.dsntup_ret_ddname    |\n    endif                               |   EndIf.\n    mvc   &w.ret_dsorg,da_ds_ret_dsorg  |   Set up return-DSORG t.u.\n    la    r14,&w.ret_dsorg              |\n    st    r14,&s.dsntup_ret_dsorg       |\n    mvc   &w.stat_shr,da_stat_shr       |   Set up DISP=SHR\n    la    r14,&w.stat_shr               |\n    st    r14,&s.dsntup_statshr         |\n    oi    &s.dsntup_final,x'80'         |   Set final text unit pointer\n    callsub dynalloc,(=al1(s99vrbal),   |   Use DSNAME allocation.     +\n               =al1(s99nomnt,0),        |    nomount,           @CNENQ +\n               =al4(0),                 |    No authorized flags.      +\n               pwa_err_msg,             |    Return message area.      +\n               =a(l'pwa_err_msg),       |    Length of message area.   +\n               pwa_err_msg_len,         |    Length of returned msg.   +\n               pwa_textunits),vl        |\n    if    (c,r15,lt,=f'&fi_error')      |   If allocation succeeded.\n      sbit  pwa_1,pwa_1_allocated       |     Allocation has been done.\n      sbit  pwa_2_free_on_terminate     |     Free on term if AUTOFREE.\n      mvi   pwa_status,pwa_status_shr   |     Using SHR.\n      mvi   pwa_ndisp,pwa_ndisp_keep    |     Defaulting to KEEP.\n      if (%l32,r1,&s.dsntup_ret_ddname,nz)\n        mvc pwa_ddname,s99tupar-s99tunit+&w.ret_ddname\n      endif                               | Endif.\n      lm    r1,r3,=a(da_dsorg_table,2+4,da_dsorg_table_e)\n      loop  bxle\n        leave loop=*,(clc,0(2,r1),eq,s99tupar-s99tunit+&w.ret_dsorg)\n      endloop bxle,r1,r2\n      mvc   pwa_dsorg,2(r1)             |     Copy char DSORG to pwa.\n      if (clc,=c'****',eq,pwa_dsorg)    |     If DSORG = undefined.\n        if  (cli,pwa_oo_mode,eq,&fi_oo_output) If OUTPUT mode.\n          mvc pwa_dsorg,=c'PS  '        |         Make it PS.\n        endif                           |       EndIf.\n      endif                             |     EndIf.\n      leave block=*                     |     Done with allocation.\n    elseif (tbit,pwa_1_ds_not_existing,OFF) ElseIf not DS not found\n      errexit code=0                    |     Return w/alloc error.\n    elseif (cli,pwa_oc_disp,eq,&fi_oc_existing),or,                    +\n               (cli,pwa_oo_mode,eq,&fi_oo_input)\n      errexit code=0                    |     Return w/alloc error.\n    endif                               |   EndIf.\n  endif                                 | EndIf.\n* *-------------------------------------------------------------------*\n* * If this request is for INPUT or for an EXISTING data set, it has\n* * failed.  If a DSNAME was specified, its already been taken care\n* * of and we never got here (see code a few lines above).\n* * The specified DDNAME (if any) is not allocated and the specified\n* * DSNAME (if any) does not already exist.\n* *-------------------------------------------------------------------*\n  if (cli,pwa_oo_mode,eq,&fi_oo_input),or,                             +\n               (cli,pwa_oc_disp,eq,&fi_oc_existing)\n    if (cli,pwa_dsname,ne,c' ')         |   If dsname specified.\n      errexit code=0                    |     Shouldn't get here.\n    elseif (cli,pwa_ddname,ne,c' ')     |   ElseIf ddname specified.\n      callsub message,(fi00026,pwa_ddname)    Issue an error message.\n      errexit code=0                    |     Exit w/error code.\n    else                                |   Else, ddname|dsname req'd\n      callsub message,(fi00011)         |     Issue an error message.\n      errexit code=0                    |     Exit w/error code.\n    endif                               |   EndIf.\n  endif                                 | EndIf.\n* *-------------------------------------------------------------------*\n* *                                                                   *\n* * The specified file must be created.                               *\n* *                                                                   *\n* * NOTE: Caller-supplied text-units do get used here                 *\n* *                                                                   *\n* *-------------------------------------------------------------------*\n  sbit    pwa_1_ds_not_existing         | dataset not pre-existing.\n  mvi     pwa_status,pwa_status_new     | Creating a NEW dataset.\n  callsub suggest_blocksize,            | Suggest a blocksize based    +\n               (pwa_avglrecl,           | on the device we probably    +\n               6,                       | will be allocated on.        +\n               pwa_volser,              |                              +\n               pwa_suggested_blksize)   |\n  l       r1,pwa_maxlrecl               | r1 := lrecl value.\n  if      (tbit,pwa_recfm,dcbrecf)      | If RECFM=F\n   if     (c,r1,gt,pwa_suggested_blksize)  If lrecl > blksize\n    st    r1,pwa_suggested_blksize      |   Bump blksize.\n   endif                                |  EndIf.\n  else                                  | Else, RECFM = V\n   la     r1,4(,r1)                     |\n   if     (c,r1,gt,pwa_suggested_blksize)  If lrecl+4 > blksize\n    st    r1,pwa_suggested_blksize      |   Bump blksize.\n   endif                                |  EndIf.\n  endif                                 | EndIf.\n* *-------------------------------------------------------------------*\n* * Create the internally supplied text units for this allocation.\n* *-------------------------------------------------------------------*\n  fill  pwa_textunits,x'00'          | Clear garbage out of tup list.\n  la    r7,pwa_textunits             | r7 -> textunit pointer array.\n  using &s.newtup,r7                 | Overlay with new ds pointers.\n  mvc   &w.dsorg,da_dsorg            | Copy default DSORG=PS textunit.\n  mvc   pwa_dsorg,=c\"PS   \"          | Indicate PS in pwa.\n  la    r14,&w.dsorg                 | Add dsorg\n  st    r14,&s.newtup_dsorg          |\n* *\n* * If a DDNAME was specified, use it.  Otherwise, let the system\n* * generate one and return it in &w.ret_ddname.\n* *\n  if (cli,pwa_ddname,ne,c' ')        | If ddname specified.\n    mvc   &w.ddname,da_ddname        |   Copy DDNAME text unit.\n    mvc   s99tupar-s99tunit+&w.ddname(8),pwa_ddname\n    la    r14,&w.ddname              |\n    st    r14,&s.newtup_ddname       |\n  else                               | Else.\n    mvc   &w.ret_ddname,da_ret_ddname    Set up return-DDNAME t.u.\n    la    r14,&w.ret_ddname          |   Add ret_ddname\n    st    r14,&s.newtup_ret_ddname   |\n  endif                              | EndIf.\n* *\n* * If a dataset name was supplied, allocate a new data set with that\n* * name.  Include the member name text unit as well if a member name\n* * was specified.  If no data set name was provided, let the system\n* * generate one and return it in &w.ret_dsname.\n* *\n  if (cli,pwa_dsname,ne,c' ')        | If dsname specified.\n    mvc   &w.dsname,da_dsname        |   Copy DSNAME text unit.\n    mvc   s99tupar-s99tunit+&w.dsname(44),pwa_dsname\n    la    r14,&w.dsname              |   Add dsn=dsname\n    st    r14,&s.newtup_dsname       |\n    if (cli,pwa_member,ne,c' ')      |   If member specified.\n      mvc   &w.dsorg+6(2),da_PO      |     Set DSORG textunit to PO.\n      mvc   pwa_dsorg,=c\"PO   \"      |     Indicate PO in pwa.\n      mvc   &w.member,da_member      |     Copy MEMBER text unit.\n      mvc   s99tupar-s99tunit+&w.member(8),pwa_member\n      la    r14,&w.member            |     Add member\n      st    r14,&s.newtup_member     |\n      mvc   &w.dirblks,da_dirblks    |\n      la    r14,&w.dirblks           |     Add dirblks\n      st    r14,&s.newtup_dirblks    |\n    endif                            |   EndIf.\n  else                               | Else: filetemp | sysout | etc.\n    mvc   &w.ret_dsname,da_ret_dsname_al  Set up return-DSNAME t.u.\n    la    r14,&w.ret_dsname          |    Add ret_dsname\n    st    r14,&s.newtup_ret_dsname   |\n  endif                              | EndIf.\n* *\n* * If this is a SYSOUT file, specify sysout and do not any text units\n* * that would normally be used to allocate space on disk.  For all\n* * other files, provide those things instead.\n* *\n  if (cli,pwa_oc2_sysoutx,eq,&fi_oc2_sysout),or,                       +\n               (cli,pwa_sysoutclass,ne,c' ')\n    mvc   &w.sysout,da_sysout        |   Set up SYSOUT textunit.\n    la    r14,&w.sysout              |   Add sysout\n    st    r14,&s.newtup_sysout       |\n  else                               | Else\n    callsub suggest_blockcounts,        |                              +\n               (pwa_suggested_blksize,  |                              +\n               pwa_avglrecl,            |                              +\n               pwa_sizeinit,            |                              +\n               pwa_sizeincr,            |                              +\n               pwa_primary_blocks,      |                              +\n               pwa_secondary_blocks)    |\n    mvc   &w.statnew,da_statnew      |\n    la    r14,&w.statnew             |   Add disp=new\n    st    r14,&s.newtup_statnew      |\n    mvc   &w.conddisp,da_conddisp    |\n    la    r14,&w.conddisp            |   Add conditional disposition\n    st    r14,&s.newtup_conddisp     |\n    mvc   &w.blkalloc,da_blkalloc    |\n    mvc   s99tupar-s99tunit+&w.blkalloc(3),pwa_suggested_blksize+1\n    la    r14,&w.blkalloc            | Add blkalloc\n    st    r14,&s.newtup_blkalloc     |\n    mvc   &w.prispace,da_prispace\n    mvc   s99tupar-s99tunit+&w.prispace(3),pwa_primary_blocks+1\n    la    r14,&w.prispace            |   Add primary space allocation\n    st    r14,&s.newtup_prispace     |\n    mvc   &w.secspace,da_secspace\n    mvc   s99tupar-s99tunit+&w.secspace(3),pwa_secondary_blocks+1\n    la    r14,&w.secspace            |   Add secondary space allocation\n    st    r14,&s.newtup_secspace     |\n    mvc   &w.unit,da_unit            |\n    la    r14,&w.unit                |   Add unit=SYSALLDA or WKUNIT\n    st    r14,&s.newtup_unit         |\n  endif                              | EndIf.\n* *\n* * Determine the normal disposition of the data set: if a dsname was\n* * provided that does not start with an ampersand ('&') and FILETEMP\n* * was not specified, use DISP=CATLG.  Otherwise, consider it a\n* * temporary work data set and use DISP=DELETE.  SYSOUT files cannot\n* * specify a disposition (mutually exclusive text-units).\n* *\n  if (clc,&s.newtup_sysout,eq,=f'0') | If NOT a SYSOUT file.\n    if (cli,pwa_dsname,ne,c' '),     |   If DSNAME specified and is not+\n               and,(cli,pwa_dsname,ne,c'&&'),        temporary, and if +\n               and,(cli,pwa_oc_filetempx,ne,&fi_oc_filetemp)  \u00acFILETEMP\n      mvc &w.normdisp,da_normdisp    |     Set normal disp=catlg.\n      mvi pwa_ndisp,pwa_ndisp_catlg  |     Allocating with CATLG.\n    else                             |   Else\n      mvc &w.normdisp,da_normdispdel |     Set normal disp=delete.\n      mvi pwa_ndisp,pwa_ndisp_delete |     Allocating with DELETE.\n    endif                            |   EndIf.\n    la  r14,&w.normdisp              |     Add normal disposition\n    st  r14,&s.newtup_normdisp       |      text unit.\n  endif                              | EndIf.\n* *\n* * Fill in remaining text units used for all new allocations.\n* *\n  mvc   &w.blksize,da_blksize\n  mvc   s99tupar-s99tunit+&w.blksize(2),pwa_suggested_blksize+2\n  la    r14,&w.blksize               | Add blksize\n  st    r14,&s.newtup_blksize        |\n  mvc   &w.lrecl,da_lrecl            | Copy LRECL textunit.\n  if    (tbit,pwa_1_vb),or,          | If we want VB in created        +\n               (clc,pwa_avglrecl,ne,pwa_maxlrecl)    dataset.\n    mvc s99tupar-s99tunit+&w.lrecl(2),pwa_maxlrecl+2   Desired LRECL.\n    mvc &w.recfm,da_recfm_vb         |                 Set RECFM = VB.\n    if (cli,pwa_oc2_cc,eq,&fi_oc2_isocc) If ISOCC requested:\n      mvc  &w.recfm,da_recfm_vba     |    Set RECFM=VBA.\n    endif                            |   Endif.\n  else                               | Else (we want FB).\n    mvc s99tupar-s99tunit+&w.lrecl(2),pwa_avglrecl+2   Desired LRECL.\n    mvc &w.recfm,da_recfm_fb         |                 Set RECFM = FB.\n    if (cli,pwa_oc2_cc,eq,&fi_oc2_isocc)   If ISOCC requested:\n      mvc  &w.recfm,da_recfm_fba     |     Set RECFM=FBA.\n    endif                            |   Endif.\n  endif                              | EndIf.\n  la    r14,&w.lrecl                 | Add lrecl\n  st    r14,&s.newtup_lrecl          |\n  la    r14,&w.recfm                 | Add recfm\n  st    r14,&s.newtup_recfm          |\n* *-------------------------------------------------------------------*\n* * Append the caller's list (if any) of text unit pointers to ours.\n* * Any duplicates of text units we supply can replace ours.\n* *-------------------------------------------------------------------*\n  la r6,&s.newtup_final              | r6 -> last internal text unit.\n  la r5,&s.newtup_final              | r5 -> current final tu pointer.\n  l  r2,fi_info                      | r2 -> INFO parameter.\n  la r2,0(,r2)                       | Clear high-order bit.\n  if (treg,r2,nz)                    | If INFO was specified.\n    loop until                       |   Loop thru INFO parmlist\n      l  r3,0(r2)                    |     Get a parm address\n      la r3,0(r3)                    |     Clear its VL bit\n      if (treg,r3,nz)                |     If non-null pointer then.\n        la r15,&s.newtup             |       r15 -> 1st text unit ptr.\n        loop while,(cr,r15,le,r6)    |       loop over internal tup's.\n          l  r1,0(,r15)              |         r1 -> text unit.\n          la r1,0(,r1)               |         Clear high-bit.\n          if (treg,r1,nz)            |         If TUP not null.\n            if (clc,0(2,r1),eq,0(r3))            If same text unit keys\n              st    r3,0(r15)        |             Use theirs instead.\n              slr   r3,r3            |             Done with this one.\n              leave loop=*           |             Quit looking.\n            endif                    |           EndIf.\n          endif                      |         EndIf.\n          la  r15,4(,r15)            |         r15 -> Next TU pointer.\n        endloop while                |       EndLoop.\n      endif                          |     EndIf.\n      if (treg,r3,nz)                |     If still non-null then.\n        if (c,r5,gt,pwa_textunits_end)       If textunit list full\n          callsub message,(fi00035,50)         Max # exceeded.\n          errexit code=0             |         Return w/error.\n        endif                        |       EndIf.\n        st r3,4(,r5)                 |         Stuff in DYNALLOC parms\n        la r5,4(,r5)                 |         Update to last TU ptr.\n      endif                          |       EndIf.\n      leave loop=*,(tbit,0(r2),x'80')      Leave if that was the end.\n      la    r2,4(,r2)                |     Update INFO list pointer.\n    endloop until,leave              |   EndLoop.\n  endif                              | EndIf.\n  sbit    0(r5),x'80'                | Mark final textunit pointer.\n* *-------------------------------------------------------------------*\n* * Invoke dynamic allocation to create the output data set.\n* *-------------------------------------------------------------------*\n   l    r3,&s.newtup_unit            | Set addr of UNITNAME\n   st   r3,pwa_unitname_textunit     |  textunit (for error msg. later)\n   callsub dynalloc,(=al1(s99vrbal), | Use dsname allocation.          +\n               =al1(s99nomnt,0),     | nomount,                 @CNENQ +\n               =al4(0),              | no authorized flags.           2+\n               pwa_err_msg,          | Return message area.           3+\n               =a(l'pwa_err_msg),    | Length of message area.        4+\n               pwa_err_msg_len,      | Length of returned msg.        5+\n               pwa_textunits),vl     | Text unit pointer list.        6\n   if (c,r15,ge,=f'&fi_error')       | If allocation failed.\n     errexit code=0                  |   Exit w/error message.\n   endif                             | EndIf.\n   sbit  pwa_1,pwa_1_allocated       | Allocation has been done.\n   sbit  pwa_2_free_on_terminate     | Free on terminate if AUTOFREE.\n* *-------------------------------------------------------------------*\n* * Retrieve information from ret_ text units that were specified.\n* *-------------------------------------------------------------------*\n   if (%l32,r1,&s.newtup_ret_ddname,nz)\n     mvc pwa_ddname,s99tupar-s99tunit+&w.ret_ddname\n   endif                               | Endif.\n   if (%l32,r1,&s.newtup_ret_dsname,nz)\n     mvc  pwa_dsname,s99tupar-s99tunit+&w.ret_dsname\n   endif                               | Endif.\n endblk block=Allocate_File\n                 swa\n&w.blkalloc      ds  cl(l'da_blkalloc)     |\n&w.blksize       ds  cl(l'da_blksize)      |\n&w.conddisp      ds  cl(l'da_conddisp)     |\n&w.ddname        ds  cl(l'da_ddname)       |\n&w.dirblks       ds  cl(l'da_dirblks)      |\n&w.statnew       ds  cl(l'da_statnew)      |\n&w.dsname        ds  cl(l'da_dsname)       |\n&w.dsorg         ds  cl(l'da_dsorg)        |\n&w.lrecl         ds  cl(l'da_lrecl)        |\n&w.member        ds  cl(l'da_member)       |\n&w.normdisp      ds  cl(l'da_normdisp)     |\n&w.normdispdel   ds  cl(l'da_normdispdel)  |\n&w.prispace      ds  cl(l'da_prispace)     |\n&w.recfm         ds  cl(l'da_recfm_fb)     |\n&w.ret_attrs     ds  cl(l'da_ret_attrs)    |\n&w.ret_ddname    ds  cl(l'da_ret_ddname)   |\n&w.ret_dsname    ds  cl(l'da_ret_dsname)   |\n&w.ret_dsorg     ds  cl(l'da_ds_ret_dsorg) |\n&w.ret_member    ds  cl(l'da_ret_member)   |\n&w.ret_ndisp     ds  cl(l'da_ret_ndisp)    |\n&w.ret_status    ds  cl(l'da_ret_status)   |\n&w.secspace      ds  cl(l'da_secspace)     |\n&w.stat_shr      ds  cl(l'da_stat_shr)     |\n&w.sysout        ds  cl(l'da_sysout)       |\n&w.unit          ds  cl(l'da_unit)         |\n                 endswa                    |\n&s.dsntup             dsect   Text unit ptrs (plist) for existing alloc\n&s.dsntup_dsname      ds a          |  dsname.\n&s.dsntup_member      ds a          |  member name.\n&s.dsntup_ddname      ds a          |  ddname.\n&s.dsntup_statshr     ds a          |  status = new.\n&s.dsntup_ret_ddname  ds a          |  return ddname.\n&s.dsntup_ret_dsorg   ds a          |  return dsorg.\n&s.dsntup_final       equ *-4       | Final pointer (internal)\n*\n&s.newtup             dsect   Text unit ptrs (plist) for new ds alloc\n&s.newtup_ddname      ds a          |  ddname.\n&s.newtup_dsname      ds a          |  dsname.\n&s.newtup_member      ds a          |  member name.\n&s.newtup_sysout      ds a          |  sysout specification.\n&s.newtup_dirblks     ds a          |  directory blocks\n&s.newtup_ret_dsname  ds a          |  return dsname\n&s.newtup_ret_ddname  ds a          |  return ddname\n&s.newtup_statnew     ds a          |  status = new.\n&s.newtup_normdisp    ds a          |  normal disp=<catlg|delete>\n&s.newtup_conddisp    ds a          |  cond disp=delete\n&s.newtup_blkalloc    ds a          |  SPACE=(blksize,\n&s.newtup_prispace    ds a          |          (primary,\n&s.newtup_secspace    ds a          |          secondary))\n&s.newtup_dsorg       ds a          |  DSORG = PS or PO.\n&s.newtup_unit        ds a          |  UNIT = SYSDA(*default*)\n&s.newtup_lrecl       ds a          |  LRECL = <calculated>.\n&s.newtup_blksize     ds a          |  BLKSIZE = <calculated>.\n&s.newtup_recfm       ds a          |  RECFM = FB or VB.\n&s.newtup_final       equ *-4       | Final pointer (internal)\nsrvfios             csect ,\n\n              eject\n***********************************************************************\n*                                                                     *\n*  Subroutine: DYNALLOC                                               *\n*                                                                     *\n*  Abstract:   This routine builds a dynamic allocation request       *\n*              block, invokes DYNALLOC, and constructs a message      *\n*              describing the results of the operation.               *\n*                                                                     *\n*  Parameters: (Verb,Flag1,Flag2,MsgArea,AreaLen,MsgLen,TextUnit1,... *\n*                                                                     *\n*              The parameter list passed to this routine *must* be    *\n*              terminated with a 1 in the high-order bit of the last  *\n*              parameter, and must contain at least one textunit.     *\n*                                                                     *\n*              Parameter  Description                                 *\n*              ---------  ------------------------------------------- *\n*              Verb       Value to use for S99VERB.                   *\n*              Flag1      Value to use for S99FLAG1.                  *\n*              Flag2      Value to use for S99FLAG2.                  *\n*              MsgArea    Area in which to build Info/Error message.  *\n*              AreaLen    Length of MsgArea.                          *\n*              MsgLen     Length of resulting message.                *\n*              TextUnits  List of text-unit pointers, with final      *\n*                         pointer denoted by 1 in hoigh order bit.    *\n*                                                                     *\n*  Return Codes: R15 = return code implied by the message issued.     *\n*                                                                     *\n***********************************************************************\n block type=subroutine,name=dynalloc\n*---------------------------------------------------------------------*\n*  Build the DYNALLOC request block and invoke dynamic allocation.\n*---------------------------------------------------------------------*\n   lr      r8,r1                  | R8 -> Parameter list passed in.\n   fill    &w.rb,x'00'            | Clear request block to zeros.\n   la      r7,&w.rb               | R7 -> Dynamic allocation RB.\n   using   s99rb,r7               | Establish addressability.\n   mvi     s99rbln,20             | Set request block's length.\n   lm      r1,r3,0(r8)            | R1,2,3 -> Verb,Flag1,Flag2.\n   mvc     s99verb,0(r1)          | Copy allocation VERB.\n   mvc     s99flag1,0(r2)         | Copy allocation FLAGS1 field.\n   mvc     s99flag2,0(r3)         | Copy allocation FLAGS2 field.\n   l       r1,6*4(,r8)            | R1 -> Text Unit pointers.\n   la      r1,0(,r1)              | Clear high-order bit.\n   st      r1,s99txtpp            | Set text unit pointers address.\n*                                 |\n   plist    (s99rb),vl            | R1 -> RB pointer -> Request block.\n   dynalloc ,                     | Invoke dynamic allocation.\n   leave    block=*,(treg,r15,z)  | Return if successful.\n   eject\n*---------------------------------------------------------------------*\n*  Analyze DYNALLOC's error and reason codes to form a message.\n*---------------------------------------------------------------------*\n   if (c,r15,eq,=f'8')            | If denied by installation exit.\n     callsub message,(fi00109)    |   Allocation denied.\n     leave   block=*              |   Return to caller.\n   endif                          | EndIf.\n*                                 |\n   l16 r1,s99error                | Set R1 to the error code.\n   n   r1,=x'00000f00'            | Isolate error code's class.\n   l16 r0,s99error                | Put error code in register.\n*                                 |\n   if  (ch,r0,eq,=x'0204')        | If not enough storage.\n     callsub message,(fi00009)    |   Issue an error message.\n   elseif (ch,r0,eq,=x'0210')     | ElseIf allocated to another user.\n     callsub message,(fi00110,pwa_dsname)\n   elseif (ch,r0,eq,=x'0218')     | ElseIf no acceptable volumes\n     callsub message,(fi00122)    |\n   elseif (ch,r0,eq,=x'021c')     | ElseIf invalid unitname\n     fill  pwa_unitname,c' '          | Clear working unitname\n     l     r14,pwa_unitname_textunit  | Get textunit address\n     lh    r15,4(,r14)                | Get unitname length\n     bctr  r15,0                      | Fix length for EXECUTE\n     exi   r15,(mvc,pwa_unitname(0),6(r14))   VL move for unitname\n     callsub message,(fi00123,pwa_unitname)   Issue error message.\n   elseif (ch,r0,eq,=x'0220')     | ElseIf volume not available\n     callsub message,(fi00124,pwa_volser)\n   elseif (ch,r0,eq,=x'035C')     | ElseIf invalid PARM value.\n     l16 r2,s99info               |   R2 := key of bad text unit.\n     if (ch,r2,eq,=al2(daldsnam)) |   If bad data set name.\n       callsub message,(fi00002,pwa_dsname)\n     else                         |   Else.\n       callsub message,(fi00113,s99error,s99info)\n     endif                        |   EndIf.\n   elseif (ch,r0,eq,=x'043C')     | ElseIf too-many-datasets.\n     callsub message,(fi00121)    |   Issue an error message.\n   elseif (ch,r0,eq,=x'0238')     | ElseIf TIOT is full.\n     callsub message,(fi00121)    |   Issue an error message.\n   elseif (ch,r0,eq,=x'47AC')     | ElseIf RACF failure on DEFINE.\n     callsub message,(fi00120,pwa_userid,\"CREATE\",6,pwa_dsname)\n   elseif (ch,r1,eq,=x'0700')     | ElseIf a class 7 error code.\n     if (cli,s99error,eq,x'17')   |   If a LOCATE error.\n       if (cli,s99error+1,eq,x'08')     if could not find file.\n         callsub message,(fi00111,pwa_dsname)\n         sbit  pwa_1,pwa_1_ds_not_existing\n       else                       |     Else.\n         callsub message,(fi00113,s99error,s99info) dynalloc error.\n       endif                      |     EndIf.\n     elseif (cli,s99error,eq,x'47')   elseif a dasdm allocate error.\n         callsub message,(fi00113,s99error,s99info) dynalloc error.\n     elseif (cli,s99error,eq,x'57')   elseif a catalog error.\n       callsub message,(fi00113,s99error,s99info) dynalloc error.\n     elseif (cli,s99error,eq,x'67')   elseif an obtain error.\n       callsub message,(fi00113,s99error,s99info) dynalloc error.\n     elseif (cli,s99error,eq,x'77')   elseif a subsystem error.\n       callsub message,(fi00113,s99error,s99info) dynalloc error.\n     elseif (cli,s99error,eq,x'87')   elseif a scheduler jcl error.\n       callsub message,(fi00113,s99error,s99info) dynalloc error.\n     else                         |   Else.\n       callsub message,(fi00113,s99error,s99info) unknown error.\n     endif                        |   EndIf.\n   else                           | Else.\n     callsub message,(fi00112,pwa_dsname,s99error,s99info)\n   endif                          | EndIf.\n*\n*  The last operation before this point was a call to MESSAGE, so R15\n*  has been set to the return-code we want.\n*\n endblk block=dynalloc\n*---------------------------------------------------------------------*\n* Working storage for invoking DYNALLOC.\n*---------------------------------------------------------------------*\n                swa\n&w.rb           ds   cl(s99rbend-s99rb)   | DYNALLOC request block.\n                endswa\n aif (not &security_check).skip4\n          eject\n***********************************************************************\n*                                                                     *\n*  Subroutine: Security_Check,(ACCESS)                                *\n*  Abstract  : Attempt to see if the current user/group has access to *\n*              the file about to be opened.  This check is done to    *\n*              avoid abend 913s.  If the check cannot be done, just   *\n*              continue on and hope for the best.                     *\n*                                                                     *\n***********************************************************************\n block type=subroutine,name=security_check,parms=(Access),             +\n               options=(*swa,(parms,prefix,(using,r8)))\n*---------------------------------------------------------------------*\n*  Use RACROUTE to determine if the current userid has access to the\n*  data set about to be opened.  If not, issue a message and don't\n*  open it.\n*---------------------------------------------------------------------*\n   l  r5,&spl.Access                     | R5 -> C\"Access type\".\n   la r5,0(,r5)                          | Clear high-order bit.\n   if (clc,=c\"READ\",eq,0(r5))            | If checking READ access.\n     la    r4,=f'4'                      |   r4 -> length of READ.\n     la    r2,x'02'                      |   r2 := X'02' for READ.\n   elseif (clc,=c\"ALTER\",eq,0(r5))       | ElseIf ALTER access.\n     la    r4,=f'5'                      |   r4 -> length of ALTER.\n     la    r2,x'80'                      |   r2 := X'04' for ALTER.\n   elseif (clc,=c\"UPDATE\",eq,0(r5))      | ElseIf UPDATE access.\n     la    r4,=f'6'                      |   r4 -> length of UPDATE.\n     la    r2,x'04'                      |   r2 := X'04' for UPDATE.\n   elseif (clc,=c\"CONTROL\",eq,0(r5))     | ElseIf CONTROL access.\n     la    r4,=f'7'                      |   r4 -> length of CONTROL.\n     la    r2,x'08'                      |   r2 := X'04' for CONTROL.\n   else                                  | Else....just use READ....\n     la    r5,=c\"READ\"                   |   r5 -> \"READ\".\n     la    r4,=f'4'                      |   r4 -> length of READ.\n     la    r2,x'02'                      |   r2 := X'02' for READ.\n   endif                                 | EndIf.\n*                                        |\n   mvc &w.racroute,&s.racroute           | Copy RACROUTE parm list.\n   racroute    entity=(pwa_dsname),      |                             +\n               volser=pwa_volser,        | Check access authority to   +\n               attr=(r2),                | the data set about to be    +\n               request=AUTH,             | opened for input or output. +\n               worka=&w.rac_workarea,    |                             +\n               mf=(e,&w.racroute)        |\n   leave       block=*,(treg,r15,z)      | Return if access is okay.\n   leave       block=*,(c,r15,eq,=f'4')  | Return if not denied.\n   stm         r15,r0,&w.codes           | Save return/reason codes.\n   if          (c,r15,eq,=f'8')          | If access was denied.\n     callsub message,(fi00120,pwa_userid,(r5),(r4),pwa_dsname)\n     errexit code=0                      |\n   else                                  | Else, unexpected returncode.\n     callsub message,(fi00036,pwa_dsname,&w.codes,&w.codes+4)\n     errexit code=0                      |\n   endif                                 | EndIf.\n endblk block=security_check\n*---------------------------------------------------------------------*\n* Local constants and variables for checking dataset authorization.\n*---------------------------------------------------------------------*\n                ssd\n&s.racroute     racroute mf=l,request=AUTH,class=\"DATASET\",dstype=N\n&s.racroute_l   equ      *-&s.racroute\n                endssd\n                swa\n&w.codes        ds      2f\n&w.rac_workarea ds      cl512\n&w.racroute     ds      cl(&s.racroute_l)\n                endswa\n.skip4 anop\n eject                                |\n***********************************************************************\n*                                                                     *\n*  Subroutine: Read_JFCB                                              *\n*  Abstract:   Read a copy of the dataset's JFCB into the PWA.        *\n*  NOTICE:     THIS ROUTINE SHOULD NOT DO ANYTHING ELSE.              *\n*                                                                     *\n***********************************************************************\n block type=subroutine,name=read_jfcb,amode=31\n   la    r8,pwa_dcb                   | r8 -> working DCB storage.\n   using ihadcb,r8                    | Establish addressability.\n*                                     |\n   if    (clc,=c'PO',eq,pwa_dsorg)    | If looking at a PDS.\n     mvc pwa_dcb(&psd.podcb_len),&psd.podcb Copy static po DCB to swa\n   else                               | Else, it must be sequential.\n     mvc pwa_dcb(&psd.psdcb_len),&psd.psdcb Copy static ps DCB to swa\n   endif                              | EndIf.\n*                                     |\n   mvc   dcbddnam(8),pwa_ddname       | Stuff w/DDname\n   la    r1,pwa_jfcb                  | Set up for RDJFCB:\n   st    r1,pwa_exlst                 | Build exitlist of 1 entry,\n   mvi   pwa_exlst,x'87'              | (type 07 w/ VL bit)\n   la    r1,pwa_exlst                 |  and set exlst address in DCB.\n   stcm  r1,b'0111',dcbexlsa          |\n   mvc   &w.rdjfcb,&s.rdjfcb          | Copy RDJFCB parms to SWA\n   block amode=24                     |\n    rdjfcb pwa_dcb,mf=(e,&w.rdjfcb)   | Copy JFCB to our storage\n    lr     r5,r15                     |\n   endblk                             |\n   if    (treg,r5,nz)                 | If it didn't work,\n    callsub message,                  |  OPEN wouldn't work either.    +\n               (fi00102,pwa_dsname)   |  Issue error message.\n    errexit code=0                    |\n   endif                              |\n   la    r7,pwa_jfcb                  | Base on JFCB\n   using infmjfcb,r7                  |\n   sbit  jfcbtsdm,jfcnwrit            | Don't write JFCB back to SWA\n endblk block=read_jfcb\n               ssd    ,                   |\n&s.rdjfcb      rdjfcb *,mf=l              |\n&s.rdjfcb_l    equ    *-&s.rdjfcb         |\n               endssd ,                   |\n               swa    ,                   |\n&w.rdjfcb      ds     cl(&s.rdjfcb_l)     |\n               endswa ,                   |\n eject\n***********************************************************************\n*                                                                     *\n*  Subroutine: Does_Member_Exist                                      *\n*  Abstract:   Determine using BPAM FIND whether a member exists.     *\n*              On exit, R15 = zero if member found, else R15 = 8.     *\n*              The dataset's JFCB must already be read in with PO.    *\n*  NOTICE:     THIS ROUTINE SHOULD NOT DO ANYTHING ELSE.              *\n*                                                                     *\n***********************************************************************\n block name=does_member_exist,type=subroutine,amode=31,options=codebase\n   la    r8,pwa_dcb                   | r8 -> PO dcb connected to JFCB.\n   using ihadcb,r8                    | Establish addressability.\n   la    r7,pwa_jfcb                  | r7 -> JFCB already read in.\n   using infmjfcb,r7                  | Establish addressability.\n   mvc   jfcbelnm,=cl8' '             | Clear the member name.\n   mvc   pwa_open(open_l),&psd.open   | Copy OPEN parm list to PWA.\n   block amode=24                     | Block Amode-24.\n     open  (pwa_dcb,input),type=j,mf=(e,pwa_open)\n   endblk                             | EndBlk Amode-24.\n   if (tbit,dcboflgs,dcbofopn,off)    | If OPEN failed.\n     callsub message,(fi00102,pwa_dsname) Issue an error message.\n     errexit code=0                   |    Exit with error-code.\n   endif                              | Endif.\n   block amode=24                     |\n     find  pwa_dcb,pwa_member,d       | Make BPAM find member\n     lr    r2,r15                     | Copy returncode before CLOSE\n     if    (treg,r2,nz)               | If it wasn't zero\n       la    r2,8                     |  force it to be 8.\n     endif                            |\n     plist (pwa_dcb),vl               | Set parms in working stg.\n     close (pwa_dcb),mf=(e,(1))       | Close PO DCB\n     callsub free_buffer_pool,(pwa_dcb)   Free its buffer pool\n   endblk                             |\n endblk rc=(r2)                       | Return the answer.\n         eject                        |\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Suggest_Blocksize\n*  Abstract:   This routine will attempt to derive a blocksize that\n*              will efficiently fit <n> blocks on a track, using the\n*              average record length provided by the caller.\n*  Inputs:     On entry, R1 points to the following parameter list:\n*                +0 -- Address of average record length (fullword)\n*                +4 -- Requested number of blocks per track (fullword)\n*                +8 -- Address of volume for target device or spaces\n*                +c -- Address of fullword to return blocksize into\n*  Outputs:    Result fullword at parmlist+c% filled in\n*  Special\n*  Notes:      . This routine uses DEVTYPE, and hopefully uses the\n*                right method for determining an optimum blocksize.\n*              . This routine presently uses #_blks_per_track (an\n*                equate) for carving up a DASD track.\n*---------------------------------------------------------------------*\n         space 1                      |\n block name=suggest_blocksize,type=subroutine\n  lm    r3,r6,0(r1)                   | Load up parameters\n  mvi   &w.f1,x'00'                   |\n  la    r7,&w.devtype_results         | Base on DEVTYPE answer area\n  l     r2,cvtptr                     |  Base on CVT\n  using cvt,r2                        |\n  using dvarea,r7                     |\n  if    (clc,=cl6' ',eq,0(r5))        | If no volume provided,\n   mvc   dvatrkln,=al2(47476)         |  Assume 3380 tracklength,\n   mvc   &w.ucbad,cvtsysad            |   devicetype of what we IPLed\n  else                                | Otherwise look up volume's UCB:\n   loop  until                        |  Loop calling IOSVSUCB:\n    l     r15,cvtucbsc                |\n    callx (r15),(&w.ucbwa,=al1(ucb3dacc),&w.ucbad)\n    leave loop=*,(treg,r15,nz)        |   Leave if no more UCBs\n    l     r3,&w.ucbad                 |   Get returned UCB address\n    using ucbob,r3                    |\n    if    (clc,ucbvoli,eq,0(r5))      |   If we found our volume\n     st    r3,&w.ucbad                |    Save UCB address for TRKCALC\n     sbit  &w.f1,&w.f1hit             |     and note that we found it.\n     leave loop=*                     |\n    endif                             |\n   endloop until,leave                |\n   drop  r2,r3                        | Drop CVT, UCB bases\n   if    (tbit,&w.f1,&w.f1hit,off)    | If we didn't find the volume\n    callsub message,(fi00030,&w.volser)  it isn't mounted.\n    errexit code=0                    |\n   endif                              |\n   mvc   &w.devtype(len_devtype),&s.devtype  now we can issue devtype.\n   devtype  ,(&w.devtype_results,24),  |                               +\n               ucblist=(&w.ucbad,1),  |                                +\n               mf=(e,&w.devtype)      |\n   if    (treg,r15,nz)                |\n    st   r15,pwa_save_r15             | Preserve r15 for errexit\n    callsub message,(fi00028)         |  don't try division with it.\n    l    r15,pwa_save_r15             | Rest r15 for debug analysis\n    errexit code=0                    |\n   endif                              |\n  endif                               |\n* *-------------------------------------------------------------------*\n* * DEVTYPE returned the track size. We know the average recordlength.\n* * Determine how large a block must be to fit 4 on a track.  Since\n* * together DEVTYPE and TRKCALC aren't too smart, we have to loop\n* * asking TRKCALC 'how about this one' til we get the answer we want.\n* *-------------------------------------------------------------------*\n  l16   r1,dvatrkln                   | Watch it: this is unsigned!\n  l32   r0,0(r4)                      | Check # blocks per track:\n  if    (z)                           | If it's zero,\n   callsub message,(fi00028)          |  don't try division with it.\n   errexit code=0                     |\n  endif                               |\n  l32   r0,0(r3)                      | Check average LRECL:\n  if    (z)                           | If it's zero,\n   callsub message,(fi00029)          |  don't try division with it.\n   errexit code=0                     |\n  endif                               |\n  xr    r0,r0                         | Clear R0 before division\n  d     r0,0(r4)                      | Divide by # blocks per track:\n*                                     |  R1 now = 1/4 track length.\n  xr    r0,r0                         | Clear R0 before division\n  d     r0,0(r3)                      | Divide by average LRECL:\n*                                     |  R1 now = # recs per block.\n  m     r0,0(r3)                      | R1 is now trimmed blocksize.\n  lr    r2,r1                         | Copy to R2 to save past TRKCALC\n  mvc   &w.trkcalc(len_trkcalc),&s.trkcalc\n  l     r14,&w.ucbad                  |   Get returned UCB address\n  using ucbob,r14                     |\n  mvc   pwa_UCBTBYT4,UCBTBYT4         |  Copy device type to PWA field.\n  drop  r14                           |  Drop UCB addressing.\n  loop  until                         |\n   trkcalc     functn=trkcap,         |  Will this one fit like we     +\n               type=pwa_UCBTBYT4,     |   want?                        +\n               dd=(r2),               |                                +\n               r=1,                   |                                +\n               regsave=yes,           |                                +\n               mf=(e,&w.trkcalc)      |\n   if    (treg,r15,nz)                |\n    st   r15,pwa_save_r15             | Preserve r15 for errexit\n    callsub message,(fi00028)         |\n    l    r15,pwa_save_r15             | Restore r15 for debug analysis\n    errexit code=0                    |\n   endif                              |\n   leave loop=*,(c,r0,ge,0(r4))       |  If hit, leave loop.\n   s     r2,0(r3)                     |  Knock some off the LRECL\n  endloop until,leave                 | and try again.\n  st    r2,0(r6)                      | Only a suggestion.\n  drop  r7                            |\n  xr    r15,r15                       |\n endblk rc=(r15)                      |\n         space 1                      |\n  ssd   ,                             |\n&s.devtype devtype ,(*,*),ucblist=yes,mf=l\nlen_devtype equ     *-&s.devtype      |\n&s.trkcalc trkcalc mf=l               |\nlen_trkcalc equ     *-&s.trkcalc      |\n  endssd ,                            |\n         space 1                      |\n  swa   ,                             |\n&w.devtype ds    0f,cl(len_devtype)   |\n&w.trkcalc ds    0f,cl(len_trkcalc)   |\n&w.devtype_results ds    6f           |\n&w.ucbad   ds    a                    |\n&w.ucbwa   ds    cl100                |\n&w.volser  ds    cl6                  |\n&w.f1      ds    x                    |\n&w.f1hit   equ   x'80'                |\n  endswa ,                            |\n         eject                        |\n*---------------------------------------------------------------------*\n*\n*  Subroutine: suggest_blockcounts (blksize,avglrecl,recsinit,recsincr,\n*                              priblks,secblks)\n*              will efficiently fit <n> blocks on a track, using the\n*  Abstract:   Compute primary and secondary block counts (priblks and\n*              secblks) for a new data set allocation based on the\n*              specified blocksize, average record length, and expected\n*              data set sizes (recsinit and recsincr).\n*---------------------------------------------------------------------*\n block type=subroutine,name=suggest_blockcounts,                       +\n               options=(*swa,loadbase,(parms,(using,r5),prefix)),      +\n               parms=(blksize,avglrecl,recsinit,                       +\n               recsincr,priblks,secblks)\n   l     r1,&spl.blksize             |\n   l     r1,0(,r1)                   | r1 = blocksize.\n   l     r2,&spl.avglrecl            | r2 -> average record length.\n   xr    r0,r0                       | Clear R0 before division.\n   d     r0,0(,r2)                   | R1 = records per block.\n*                                    |\n   l     r3,&spl.recsinit            |\n   l     r3,0(,r3)                   | r3 := initial #records.\n   xr    r2,r2                       | Clear R2 before division.\n   dr    r2,r1                       | R3 = # blocks primary.\n   if    (treg,r2,nz)                | If there was a remainder\n     la    r3,1(r3)                  |   Round up the quotient.\n   endif                             | EndIf.\n   l     r14,&spl.priblks            | r14 -> primary blocks parm.\n   st    r3,0(,r14)                  | Save primary allocation blks\n*\n   xr    r2,r2                       | Clear R2 before division.\n   l     r14,&spl.secblks            | r14 -> primary blocks parm.\n   st    r2,0(,r14)                  | Set secondary #blks = 0.\n   l     r3,&spl.recsincr            |\n   l32   r3,0(r3)                    | r3 := record increment amount.\n   if    (nz)                        | If secondary space requested.\n     dr    r2,r1                     |   r3 := recsincr/(recs per blk)\n     if    (treg,r2,nz)              |   If there was a remainder.\n       la    r3,1(r3)                |     Round up the quotient.\n     endif                           |   EndIf.\n     st    r3,0(,r14)                |   R3 = # blocks secondary\n   endif                             | EndIf.\n endblk block=suggest_blockcounts\n         eject                        |\n*---------------------------------------------------------------------*\n*\n*  Subroutine: SPFEDIT_ENQ\n*  Abstract:   This routine will attempt to ENQ on major name SPFEDIT,\n*              minor name of the dataset and member name.  This routine\n*              should be called whenever a PDS member is opened OUTPUT.\n*  Inputs:     On entry, R1 points to the following parameter list:\n*                +0 -- Address of dataset name\n*                +4 -- Address of member name\n*  Outputs:    R15 = 0 if ENQ was successful\n*              R15 = 8 if ENQ was held by another user\n*  Special\n*  Notes:      None.\n*\n*---------------------------------------------------------------------*\n         space 1                      |\n block name=spfedit_enq,type=subroutine\n  lm    r2,r3,0(r1)                   |\n  mvc   &w.enq(l_enq),&s.enq          |\n  fill  &w.rname,c' '                 |\n  mvc   &w.rname(44),0(r2)            |\n  mvc   &w.rname+44(8),0(r3)          |\n  enq   (,&w.rname),mf=(e,&w.enq)     |\n  if    (treg,r15,nz)                 |\n   la    r15,8                        |\n  else                                |\n   sbit pwa_2,pwa_2_member_enq        |\n  endif                               |\n endblk rc=(r15)                      |\n     ssd   ,                          |\n&s.enq   enq   (&psd.spfedit,*-*,e,52,systems),ret=use,mf=l\nl_enq    equ   *-&s.enq               |\n     endssd ,                         |\n     swa   ,                          |\n&w.enq   ds    0f,cl(l_enq)           |\n&w.rname ds    cl52                   |\n     endswa ,                         |\n         eject                        |\n*---------------------------------------------------------------------*\n*\n*  Subroutine: SPFEDIT_DEQ\n*  Abstract:   This routine will DEQ unconditionally on major name\n*              SPFEDIT, minor name of the dataset and member name.\n*              should be called whenever a PDS member is opened OUTPUT.\n*  Inputs:     On entry, R1 points to the following parameter list:\n*                +0 -- Address of dataset name\n*                +4 -- Address of member name\n*  Outputs:    None.\n*  Special\n*  Notes:      None.\n*\n*---------------------------------------------------------------------*\n         space 1                      |\n block name=spfedit_deq,type=subroutine\n  lm    r2,r3,0(r1)                   |\n  mvc   &w.deq(l_deq),&s.deq          |\n  fill  &w.rname,c' '                 |\n  mvc   &w.rname(44),0(r2)            |\n  mvc   &w.rname+44(8),0(r3)          |\n  deq   (,&w.rname),mf=(e,&w.deq)     |\n  rbit  pwa_2,pwa_2_member_enq\n endblk\n     ssd   ,\n&s.deq   deq   (&psd.spfedit,*-*,52,systems),ret=have,mf=l\nl_deq    equ   *-&s.deq\n     endssd ,\n     swa   ,\n&w.deq   ds    0f,cl(l_deq)\n&w.rname ds    cl52\n     endswa ,\n     eject ,\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Free_Buffer_Pool\n*  Abstract:   This routine serves as an intelligent FREEPOOL, taking\n*              into account that the File Handler may have been running\n*              in key zero (hence subpool 0 is actually subpool 252).\n*  Inputs:     On entry, R1 points to the following parameter list:\n*                +0 -- Address of DCB to free buffers for.\n*  Outputs:    Buffers freed\n*  Special\n*  Notes:      See below.\n*\n*---------------------------------------------------------------------*\n         SPACE 1\n block type=subroutine,name=free_buffer_pool,amode=24\n         SPACE 1\n* *-------------------------------------------------------------------*\n* *  Even though OPEN acquired our QSAM buffer pool for us, we are\n* *  responsible for freemaining it.  Worse, if we are running in\n* *  key0/supv state, the buffers must be freemained from subpool\n* *  252 instead of zero. Unfortunately, the FREEPOOL macro is not\n* *  smart enough to handle this, so we must hardcode the FREEPOOL\n* *  code ourselves.  The buffer control block pointed to by the\n* *  DCB describes the storage to be freemained.  (There is no\n* *  mapping macro for the BUFCB.)\n* *-------------------------------------------------------------------*\n* *  Format of BUFCB:\n* *    +0 -- Addr of buffer area (follows the BUFCB)\n* *    +4 -- Flags. X'40' sez the BUFCB is 16 bytes long.\n* *    +5 -- No. of buffers\n* *    +6 -- Length of 1 buffer\n* *-------------------------------------------------------------------*\n  l     r5,0(r1)                      | Get DCB address from parameters\n  using ihadcb,r5                     |\n  l24   r4,dcbbufca                   | Get BUFCB address\n  leave block=*,(z),or,               | Leave if address is zero or    *\n               (tbit,dcbbufca+2,x'01')   already marked invalid\n  oi    dcbbufca+2,x'01'              | Mark DCBBUFCA invalid\n  l8    r3,5(r4)                      | Get no. of buffers\n  mh    r3,6(r4)                      | Times buffer size\n  la    r3,8(r3)                      | Include length of header\n  if    (tbit,4(r4),x'40')            | 16-byte header?\n   la    r3,8(r3)                     |  Add that in, too.\n  endif                               |\n* *-------------------------------------------------------------------*\n* *  If we are running in key zero, any storage acquired in subpool\n* *  zero will actually be in subpool 252.\n* *-------------------------------------------------------------------*\n*                                     |  Are we supervisor state?\n  testauth     fctn=0,                |     (Don't look at APF bit)    *\n               state=yes,             |     (Require supv. state)      *\n               rblevel=1              |\n  if    (treg,r15,z)                  | If so, check PSW key:\n*  *------------------------------------------------------------------*\n*  * TESTAUTH sez we're in supervisor state.\n*  *------------------------------------------------------------------*\n   xr    r2,r2                        |  IPK puts key in R2 bits 24-27\n   ipk   ,                            |   leaving the rest of R2 alone.\n   if    (treg,r2,z)                  |  If R2 is still zero:\n*   *-----------------------------------------------------------------*\n*   * Supervisor state, key zero.  Set up FREEMAIN for subpool 252.\n*   *-----------------------------------------------------------------*\n    icm   r3,b'1000',=al1(252)        |   Freemain from subpool 252.\n   endif                              |\n  else                                | Otherwise (prob state, key=??)\n   testauth    fctn=0,                |  See what kinda key we're in   *\n               key=yes,               |     (Require system key)       *\n               rblevel=1              |\n   if    (treg,r15,z)                 |  If a system key, see if key 0.\n*   *-----------------------------------------------------------------*\n*   * Problem state, but an authorized key.\n*   *-----------------------------------------------------------------*\n    xr    r2,r2                       |  Clear R2 before IPK uses it\n    modeset mode=sup                  |  Make the IPK inst. work\n    ipk   ,                           |  Get the PSW key\n    modeset mode=prob                 |  That's enough of that.\n    if    (treg,r2,z)                 |  If R2 is still zero, we need\n*    *----------------------------------------------------------------*\n*    * Problem state, key zero.  Set up FREEMAIN for subpool 252.\n*    *----------------------------------------------------------------*\n     icm   r3,b'1000',=al1(252)       |   to freemain from subpool 252.\n    endif                             |\n   endif                              |\n  endif                               |\n  lr    r0,r3                         | Copy subpool/length\n  lr    r1,r4                         | Copy area address\n  freemain r,lv=(0),a=(1)             | Free those buffers.\n  drop  r5                            | Drop DCB base\n endblk                               | That's it.\n         eject                        |\n***********************************************************************\n*                                                                     *\n*  Subroutine: EOF                                                    *\n*  Abstract:   Set the end-of-file indicator.                         *\n*  NOTE:       AMODE = whatever it is entered with.                   *\n*                                                                     *\n***********************************************************************\n block name=eof,type=subroutine,options=(*nosubopts,custom)\n   balr  r15,0                        |\n   using *,r15                        |\n   sbit  pwa_1,pwa_1_eof              |\n   bsm   0,r14                        |\n   drop  r15                          |\n endblk block=eof                     |\n space 1                              |\n***********************************************************************\n*                                                                     *\n*  Subroutine: SYNAD                                                  *\n*  Abstract:   Handle an OS input/output error.                       *\n*                                                                     *\n***********************************************************************\n block name=synad,type=subroutine,amode=24,options=codebase\n   synadaf acsmeth=qsam            |\n   l       r13,4(,r13)             | R13 -> PWA.\n   la      r2,50(,r1)              | R2 -> Synad message text.\n   l16     r3,0(r1)                | R3 := Length of message buffer.\n   sh      r3,=h'50'               | R3 := length of message text.\n*                                  |\n   la      r4,pwa_err_msg          | R4 -> PWA storage for message.\n   la      r5,l'pwa_err_msg        | R5 := Length of message storage.\n   l       r15,fi00202             | R15 -> SYNAD message prefix.\n   la      r14,4(r15)              | R14 -> message prefix text.\n   l       r15,0(r15)              | R15 := message prefix length.\n   if      (cr,r5,gt,r15)          | If enough storage for entire msg.\n     lr    r5,r15                  |   Use exact length.\n   endif                           | EndIf.\n   st      r5,pwa_err_msg_len      | Save length before doing MVCL.\n   mvcl    r4,r14                  | Copy message prefix to the PWA.\n*                                  |\n   la      r5,l'pwa_err_msg        | R5 := Length of message storage.\n   s       r5,pwa_err_msg_len      | R5 := Remaining length.\n   if      (cr,r5,gt,r3)           | If enough storage for entire msg.\n     lr    r5,r3                   |   Use exact length.\n   endif                           | EndIf.\n   l       r1,pwa_err_msg_len      | R1 := message prefix length.\n   ar      r1,r5                   | Add SYNAD message's length.\n   st      r1,pwa_err_msg_len      | Save length before doing MVCL.\n*                                  |\n   mvcl    r4,r2                   | Copy message prefix to the PWA.\n*                                  |\n   l       r13,8(,r13)             | R13 -> SYNAD's save area.\n   synadrls                        | Release the SYNAD data areas.\n   sbit    pwa_1,pwa_1_error          |\n endblk block=synad                   |\n             eject\n*---------------------------------------------------------------------*\n*\n*  Subroutine: MESSAGE\n*  Abstract:   Format a message and exit the program.\n*\n*---------------------------------------------------------------------*\n block type=subroutine,name=message\n   lr  r2,r1                       | R2 -> Parameter list.\n   l   r4,0(r2)                    | R4 -> Message's ADCON.\n   l   r4,0(r4)                    | R4 -> Message Length, Text.\n*---------------------------------------------------------------------*\n*  Invoke the string-formatter to put together the message.\n*---------------------------------------------------------------------*\n   mvi &w.formatted,c'N'           | Message not yet formatted.\n   if (clc,pwa_st_sptoken,ne,=f'0')   if string-handler is started.\n     lr    r1,r2                   |    R1 -> parm before 1st arg.\n     loop  while,(tbit,0(r1),x'80',off) while not at last parameter.\n       la    r1,4(,r1)             |     Advance to next parameter.\n     endloop while                 |    EndLoop.\n     sr        r1,r2               |    R1 := length of plist.\n     srl       r1,2                |    R1 := number of source args.\n     st        r1,&w.count         |    Save #arguments for ST_FORMAT.\n     es_clear_debug_info id=es,action=inhibit\n     st_format id=st,string=pwa_err_msg,resultlen=pwa_err_msg_len,     +\n               control=(4(r4),0(r4)),sourcelist=(4(r2),&w.count)\n     if        (%st_success)          |   If successful format.\n       mvi     &w.formatted,c'Y'      |     Set formatted-flag.\n     else                             |   Else.\n       sth                r15,&w.rc   |     Save bad return-code.\n       es_save_debug_info id=es,text=\"ST_FORMAT failed while attempting+\n                to format a message: return code follows.\"\n       es_save_debug_info id=es,hex=(&w.rc,=a(l'&w.rc)),label=\"RETCODE\"\n       es_save_debug_info id=es,text=(4(r4),0(r4)),label=\"MESSAGE\"\n       es_display_debug_info id=es\n     endif                            |   EndIf.\n     es_clear_debug_info id=es,action=enable\n   endif                           | EndIf.\n*---------------------------------------------------------------------*\n*  If the message could not be formatted, use the unformatted version.\n*---------------------------------------------------------------------*\n   if (cli,&w.formatted,ne,c'Y')   | If message not formatted.\n     l    r5,0(r4)                 |   R5 := length of message text.\n     la   r1,l'pwa_err_msg         |   R1 -> Length of target area.\n     if   (cr,r5,gt,r1)            |   If too long to fit, then.\n       lr r5,r1                    |     Use as much as possible.\n     endif                         |   EndIf.\n     st   r5,pwa_err_msg_len       |   Save length of message\n     lr   r1,r5                    |   Set target to exact size.\n     la   r4,4(r4)                 |   R4 -> message text.\n     la   r0,pwa_err_msg           |   R0 -> Target area of move.\n     mvcl r0,r4                    |   Copy message text.\n   endif                           | EndIf.\n*---------------------------------------------------------------------*\n*  Set R15 = return-code associated with the new message.\n*---------------------------------------------------------------------*\n   la   r0,pwa_err_msg                | R4 -> Formatted message text.\n   la   r1,pwa_err_msg_len            | R5 -> Length of formatted msg.\n   stm  r0,r1,pwa_msg_data            | Save address/length of message.\n*                                     |\n   if (cli,pwa_err_msg+7,eq,c\"I\")     | If an information msg, then.\n     la r15,0                         |   Exit with zero return-code.\n   elseif (cli,pwa_err_msg+7,eq,c\"W\") | If a warning message, then.\n     la r15,&fi_warning               |   Exit with the warning-code.\n   elseif (cli,pwa_err_msg+7,eq,c\"E\") | ElseIf an error message, then.\n     la r15,&fi_error                 |   Exit with the error-code.\n   elseif (cli,pwa_err_msg+7,eq,c\"X\") | ElseIf invalid filename.\n     la  r15,&fi_invalid_syntax       |   Exit with the syntax-code.\n     mvi pwa_err_msg+7,c'e'           |   Change msg-severity to 'E'.\n   elseif (cli,pwa_err_msg+7,eq,c\"S\") | ElseIf an error message, then.\n     la r15,&fi_severe                |   Exit with the severe-code.\n   else                               | Else\n     la r15,&fi_critical              |   Exit with the critical-code.\n   endif                              | EndIf.\n endblk block=message\n*---------------------------------------------------------------------*\n* Working storage for formatting messages.\n*---------------------------------------------------------------------*\n            swa\n&w.count      ds     f                | Number of SOURCE arguments.\n&w.rc         ds     h                | ST_FORMAT return-code.\n&w.formatted  ds     c                | Successful format = Y.\n            endswa\n eject\n***********************************************************************\n*                                                                     *\n*  Error exit for all functions in the file handler.                  *\n*                                                                     *\n***********************************************************************\n block type=errexit,amode=31\n*---------------------------------------------------------------------*\n*  Save module/offset and registers.\n*---------------------------------------------------------------------*\n   stm   r0,r15,gdiregs          | Save registers at time of error.\n   sm_lal r0,srvfios+4            | Point to module identification.\n   st    r0,gdimodid             | Save in general debug area.\n   if    (clc,=h'0',eq,0(r14))   | If CODE=00, then.\n     sth r15,gdirc               |   Use R15 for final return code.\n   else                          | Else.\n     mvc gdirc,0(r14)            |   Set return code = CODE.\n   endif                         | EndIf.\n   sl    r14,=a(srvfios)         | Calculate offset at time of error.\n   sth   r14,gdioffst            | Save in debug area.\n   es_save_debug_info id=es,gdi=gdi\n*---------------------------------------------------------------------*\n*  Check the return-code, and save the debugging message accordingly.\n*---------------------------------------------------------------------*\n   lh    r3,gdirc                | R3 := return-code.\n   if    (c,r3,ge,=f'&fi_error') | If an error or worse.\n     sbit pwa_1,pwa_1_error          Remember it.\n   endif                         | EndIf.\n   caseblk reg=r3,mult=1         | Case on return-code.\n     case &fi_success,           |   Success (Information msg).        +\n               &fi_warning,      |   Warning message.                  +\n               &fi_error,        |   Error message.                    +\n               &fi_severe,       |   Severe error message.             +\n               &fi_invalid_syntax,   Error (Syntax) message.           +\n               &fi_critical,     |   Critical error message.           +\n               &fi_end_of_file\n       la r4,pwa_err_msg         |     R4 -> Formatted message text.\n       la r5,pwa_err_msg_len     |     R5 -> Length of formatted msg.\n     case &fi_invalid_fileid     |   Bad token value.\n       l  r5,fi00001             |     R5 -> Length of message.\n       la r4,4(r5)               |     R4 -> Message text.\n     case other                  |   Unknown error-code.\n       l  r5,fi00003             |     R5 -> Length of message.\n       la r4,4(r5)               |     R4 -> Message text.\n   endcase                       | EndCase.\n   stm   r4,r5,pwa_msg_data      | Save address/length of message.\n   es_save_debug_info id=es,text=((r4),(r5))\n*---------------------------------------------------------------------*\n*  Set the final return-code and exit.\n*---------------------------------------------------------------------*\n   lh    r15,gdirc               |\n endblk\n eject\n*---------------------------------------------------------------------*\n*\n*  Static Data\n*\n*---------------------------------------------------------------------*\n               psd\n               ltorg\neyecatcher     dc     c\"FIOS\"               | PWA-block eyecatcher.\n&psd.podcb     dcb    ddname=xxxxxxxx,dsorg=po,macrf=(r,w),synad=synad\n&psd.podcb_len equ    *-&psd.podcb        |\n&psd.psdcb     dcb    ddname=xxxxxxxx,dsorg=ps,macrf=(r),synad=synad\n&psd.psdcb_len equ    *-&psd.psdcb        |\n&psd.OPEN      open   *-*,mf=l              | OPEN parameter-list.\nopen_l         equ    *-&psd.open           | Length of OPEN plist.\n         read   &psd.decb_start,sf,*-*,mf=l\n&psd.decb equ   &psd.decb_start,*-&psd.decb_start\n&psd.spfedit   dc     cl8\"SPFEDIT \"         | spf-edit qname.\n*---------------------------------------------------------------------*\n*  Static data for dynamic allocation (SVC 99) of OS data sets.\n*---------------------------------------------------------------------*\nda_sysout        text_unit dalsysou\nda_ddname        text_unit dalddnam,cl8\" \"       ddname=<blanks>\nda_dsname        text_unit daldsnam,cl44\" \"      dsname=<blanks>\nda_member        text_unit dalmembr,cl8\" \"       member=<blanks>\nda_stat_shr      text_unit dalstats,x\"08\"        disp=shr\nda_ret_ddname    text_unit dalrtddn,cl8\" \"       return ddname.\nda_ds_ret_dsorg  text_unit dalrtorg,xl2\"0000\"    return dsorg.\n*\nda_ir_ddname     text_unit dinddnam,cl8\" \"       ddname=<blanks>\nda_ir_ret_dsorg  text_unit dinrtorg,xl2\"0000\"    return dsorg.\nda_ret_dsname    text_unit dinrtdsn,cl44\" \"      return dsname.\nda_ret_dsname_al text_unit dalrtdsn,cl44\" \"      return dsname (alloc).\nda_ret_member    text_unit dinrtmem,cl8\" \"       return member.\nda_ret_status    text_unit dinrtsta,X\"00\"        return status.\nda_ret_ndisp     text_unit dinrtndp,X\"00\"        return normal disp.\nda_ret_attrs     text_unit dinrtatt,x\"00\"        return attributes  @DD\nda_statnew       text_unit dalstats,x\"04\"        disp=(new,\nda_normdisp      text_unit dalndisp,x\"02\"              catlg,\nda_normdispdel   text_unit dalndisp,x\"04\"              delete,\nda_conddisp      text_unit dalcdisp,x\"04\"              delete)\nda_blkalloc      text_unit dalblkln,x\"000000\"    space=(blocksize,\nda_prispace      text_unit dalprime,x\"000000\"           (primary,\nda_secspace      text_unit dalsecnd,x\"000000\"            secondary))\nda_dirblks       text_unit daldir,x\"00000A\"      10 dir blks.\nda_dsorg         text_unit daldsorg,x\"4000\"      dsorg=ps (x\"0200\"=po)\nda_lrecl         text_unit dallrecl,x\"0000\"      lrecl=<calculated>.\nda_blksize       text_unit dalblksz,x\"0000\"      blksize=<calculated>.\nda_recfm_fb      text_unit dalrecfm,b\"10010000\"  recfm=FB.\nda_recfm_vb      text_unit dalrecfm,b\"01010000\"  recfm=VB.\nda_recfm_fba     text_unit dalrecfm,b\"10010100\"  recfm=FBA.\nda_recfm_vba     text_unit dalrecfm,b\"01010100\"  recfm=VBA.\nda_unit          text_unit dalunit,cl5\"SYSDA\"    unit=sysda\n*\nda_dsorg_table   equ  *\nda_PO    dc   x'0200',c'PO  '   | Returned DSORG=PO.\n         dc   x'0300',c'POU '   | Returned DSORG=POU.\n         dc   x'4000',c'PS  '   | Returned DSORG=PS.\n         dc   x'4100',c'PSU '   | Returned DSORG=PSU.\n         dc   x'0000',c'****'   | Returned DSORG=****.\n         dc   x'0004',c'TR  '   | Returned DSORG=TCAM.\n         dc   x'0008',c'VSAM'   | Returned DSORG=VSAM.\n         dc   x'0020',c'TQ  '   | Returned DSORG=TCAM msg queue.\n         dc   x'0040',c'TX  '   | Returned DSORG=TCAM line group.\n         dc   x'0400',c'MQ  '   | Returned DSORG=Message Queue.\n         dc   x'0800',c'CQ  '   | Returned DSORG=DA Msg Queue.\n         dc   x'1000',c'CX  '   | Returned DSORG=Comm Line group.\n         dc   x'2000',c'DA  '   | Returned DSORG=Direct Access.\n         dc   x'2100',c'DAU '   | Returned DSORG=DAU.\n         dc   x'8000',c'IS  '   | Returned DSORG=ISAM.\n         dc   x'8100',c'ISU '   | Returned DSORG=ISAM Unmovable.\nda_dsorg_table_e equ  *\n         dc   x'FFFF',c'????'   | Entry picked for unknown DSORG.\nda_status_new    dc   x'04'     | Returned STATUS=NEW.\n*\n            macro\n&label      trantab\n            lcla &n\n&label      ds   0xl256        |\n.newrow     dc   al1(&n+0,&n+1,&n+2,&n+3,&n+4,&n+5,&n+6,&n+7)\n            dc   al1(&n+8,&n+9,&n+10,&n+11,&n+12,&n+13,&n+14,&n+15)\n&n          seta &n+16\n            aif  (&n lt 256).newrow\n            mend\nfold        trantab            | Translate tbl for uppercase conv.\n            org  fold+c\"a\"     | Fold lowercase 'a' - 'i'.\n            dc   c\"ABCDEFGHI\"  |\n            org  fold+c\"j\"     | Fold lowercase 'j' - 'r'.\n            dc   c\"JKLMNOPQR\"  |\n            org  fold+c\"s\"     | Fold lowercase 's' - 'z'.\n            dc   c\"STUVWXYZ\"   |\n            org  ,             |\nlettrdig    dc   256x'ff'      |      Letter or Digit\n            org  lettrdig+c\"A\" |\n            dc   9x\"00\"        |      --- 'ABCDEFGHI'\n            org  lettrdig+c\"J\" |\n            dc   9x\"00\"        |      --- 'JKLMNOPQR'\n            org  lettrdig+c\"S\" |\n            dc   8x\"00\"        |      --- 'STUVWXYZ'\n            org  lettrdig+c\"#\" |\n            dc   1x\"00\"        |      --- '#'\n            org  lettrdig+c\"$\" |\n            dc   1x\"00\"        |      --- '$'\n            org  lettrdig+c\"@\" |\n            dc   1x\"00\"        |      --- '@'\n            org  lettrdig+c\"0\" |\n            dc   10x\"00\"       |      --- '0123456789'\n            org  ,             |\n            eject\n*---------------------------------------------------------------------*\n* Messages are made up of a message identifier followed by a control\n* string.  The message identifier has the format\n*\n*   FInnnnns\n*\n* where the characters FI always begin a file-handler's message, nnnnn\n* is the unique message number, and s indicates the message's severity.\n*\n* Severity                  Meaning\n* --------   ---------------------------------------------\n*    I       Informational.\n*    W       Warning message.\n*    E       An error occurred.\n*    X       Filename syntactically invalid.\n*    S       Severe error.  Execution cannot continue.\n*    C       Critical error.  Indicates a probable programming error.\n*\n*---------------------------------------------------------------------*\n            macro\n            msg   &number,&severity,&text\n            lclc  &msgid,&oldloc\n&oldloc     setc  '&sysloc'\n&msgid      setc  'fi&number'\n&msgid      dc    a(msgt&sysndx)\nxsmsgs      loctr ,\nmsgt&sysndx dc    al4(msgl&sysndx),c'&msgid&severity',c' ',c&text\nmsgl&sysndx equ   *-msgt&sysndx-4\n&oldloc     loctr ,\n            mend\n*\n MSG 00000,I,\"Successful completion of last operation.\"\n MSG 00001,C,\"Invalid file identifier token.\"\n MSG 00002,X,\"Not a syntactically valid file name: {CL44 TRIM}.\"\n MSG 00003,C,\"Unknown error.\"\n*\n MSG 00004,C,\"Processing halted due to a previous error.\"\n MSG 00005,C,\"Invalid function-code parameter: {I}.\"\n MSG 00006,C,\"Wrong number of parameters for the {CL?} function.\"\n MSG 00007,C,\"Invalid OPTIONS value: B\"\"{BL?}\"\".\"\n MSG 00008,C,\"Sequential input (READLINE) requires INPUT access mode.\"\n MSG 00009,S,\"Not enough storage to operate.\"\n MSG 00010,S,\"Error obtaining memory for BPAM buffer.  RC={I}.\"\n*\n MSG 00011,X,\"No file name specified.\"\n MSG 00012,C,\"Sequential output (WRITELINE) requires OUTPUT access mode+\n               .\"\n MSG 00014,X,\"Null member name specified.\"\n MSG 00015,X,\"Member name is longer than {I} characters.\"\n MSG 00016,X,\"Invalid member name: {CL8 T}.\"\n MSG 00017,X,\"Invalid qualifier: {CL?}.\"\n MSG 00018,X,\"Data set name is longer than {I} characters: {CL? T}.\"\n MSG 00019,X,\"Qualifier in data set name is longer than 8 characters: {+\n               CL?}.\"\n MSG 00020,X,\"Zero length qualifier in data set name.\"\n MSG 00021,C,\"File name truncated in GET_NAME function.\"\n MSG 00022,C,\"Invalid information code ({I}) for the GET_INFO function.+\n               \"\n MSG 00023,C,\"Unable to load the String Handler (SRVSTR).\"\n MSG 00024,C,\"Unable to start the String Handler.\"\n MSG 00025,X,\"DDNAME is longer than {I} characters: {CL? T}.\"\n MSG 00026,E,\"DDNAME {CL8 TRIM} is not allocated to any file.\"\n MSG 00028,C,\"Internal error during blocksize calculation routine.\"\n MSG 00029,C,\"Average record length of zero is invalid.\"\n MSG 00030,E,\"Requested volume {CL6} is currently not available.\"\n MSG 00031,C,\"Invalid status code ({I}) for the SET_STATUS function.\"\n MSG 00032,C,\"Option EXISTING is required for INPUT files.\"\n MSG 00033,C,\"Options {CL?} are mutually exclusive.\"\n MSG 00034,C,\"RECORDLENGTH and FILESIZE parameters are for OUTPUT files+\n                only.\"\n MSG 00035,S,\"Maximum number of INFO parameters ({I}) exceeded.\"\n MSG 00036,S,\"Unexpected return code from RACHECK for dataset {CL44 TRI+\n               M}. RC={I} Reason={I}.\"\n MSG 00037,C,\"Option LIBRARY and specifying a member name in a file nam+\n               e are mutually exclusive.\"\n MSG 00038,C,\"Option LIBRARY is only valid for a PDS or PDSE.\"\n MSG 00039,C,\"FIND required before READLINE when option LIBRARY is used+\n               .\"\n MSG 00040,W,\"Member {CL8 TRIM} not found.\"\n MSG 00041,E,\"FIND failed for member {CL8 TRIM}. RC={I} Reason={I}.\"\n MSG 00042,S,\"Function {CL?} is only allowed if OPTION=LIBRARY is speci+\n               fied.\"\n MSG 00043,E,\"Error releasing memory for BPAM buffer.  RC={I}.\"\n*\n MSG 00101,E,\"Unsupported data set organization ({CL4 T}) for {CL44 T}.+\n               \"\n MSG 00102,E,\"Open failed for data set {CL44 T}.\"\n MSG 00103,E,\"No member specified for PDS {CL44 T}.\"\n MSG 00104,E,\"Member {CL8 T} not in {CL44 T}.\"\n MSG 00107,E,\"Unsupported record format.\"\n MSG 00108,E,\"Data set {CL44 T} is not partitioned, but member {CL8 T} +\n               was specified.\"\n MSG 00109,E,\"Allocation to was denied by installation exit.\"\n MSG 00110,E,\"Data set {CL44 T} is allocated to another user.\"\n MSG 00111,E,\"Could not find data set {CL44 T}.\"\n MSG 00112,E,\"Could not allocate data set {CL44 T}: Dynamic Allocation *\n               error({XL2},{XL2}).\"\n MSG 00113,E,\"Dynamic allocation error ({XL2},{XL2}). \"\n MSG 00114,S,\"Function {CL?} not performed; file is not open.\"\n MSG 00115,S,\"Maximum RECORDLENGTH of {I} less than average RECORDLENGT+\n               H of {I}.\"\n MSG 00116,S,\"Requested record format inconsistent with that of existin+\n               g file.\"\n MSG 00117,E,\"PDS member {CL8 TRIM} in dataset {CL44 T} already exists +\n               and was not replaced.\"\n MSG 00118,E,\"Requested output LRECL of {IL2} for PDS member does not m+\n               atch existing PDS LRECL of {IL2}.\"\n MSG 00119,E,\"Member {CL8} is currently in use by another user.\"\n MSG 00120,E,\"User {CL7 T} has insufficient authority to {CL?} data set+\n                {CL44 T}.\"\n MSG 00121,E,\"Maximum number of allocations has been reached. Free unus+\n               ed files and try again.\"\n msg 00122,e,\"No acceptable volumes available for allocation.\"\n msg 00123,e,\"Requested unit name of {CL8 T} is not available.\"\n msg 00124,e,\"Requested volume {CL6 T} not available.\"\n msg 00125,e,\"Existing BLKSIZE of {I} not an even multiple of {I}.\"\n msg 00126,w,\"File is {CL?} OPEN: request denied.\"\n msg 00127,e,\"Unable to delete member {CL8 T} from {CL44 T}: STOW DELET+\n               E failed with RC={I}.\"\n msg 00128,e,\"Dataset {CL44 T} already exists and was not replaced.\"\n*\n MSG 00200,W,\"End of file.\"\n MSG 00201,E,\"{CL6 TRIM} record was truncated to {I} characters.\"\n MSG 00202,S,\"Synad error: \"\n MSG 00203,I,\"PUT {CL8} B={XL4} D={CL?}.\"\n*\n MSG 00300,I,\"Dataset {CL44 TRIM}{CL?}{CL8 TRIM}{CL?} {CL8 TRIM}.\"\n MSG 00301,I,\"Member {CL8 TRIM} {CL8 TRIM} in dataset {CL44 TRIM}.\"\n            endpsd\n            eject\n***********************************************************************\n*                                                                     *\n*  Program Work Area                                                  *\n*                                                                     *\n***********************************************************************\n                    pwa\npwa_visual          ds  cl(l'eyecatcher)\npwa_fileid          ds  a           | Unique file identifier.\npwa_esepa           ds  a           | Environment Support entry-point.\npwa_estkn           ds  f           | Environment Support token.\npwa_st_spepa        ds  a           | String Handler EPA.\npwa_st_sptoken      ds  f           | String Handler Token.\n*                                   |\npwa_1               ds  x           | Housekeeping/status flags.\npwa_1_allocated     equ b'10000000' |   File has been allocated.\npwa_1_open          equ b'01000000' |   File has been opened.\npwa_1_error         equ b'00100000' |   Processing halted due to error.\npwa_1_eof           equ b'00010000' |   End of file has been reached.\npwa_1_vb            equ b'00001000' |   Caller has requested VB output\npwa_1_fb            equ b'00000100' |   Caller has requested FB output\npwa_1_ds_not_existing equ b'00000010' | Requested dataset not found\npwa_1_member        equ b'00000001' |   Requested member exists in PDS\n*                                   |\npwa_2               ds  x           | More status flags:\npwa_2_member_enq    equ b'10000000' |   SPFEDIT ENQ done on member\npwa_2_sysinout      equ b'01000000' |   File is SYSIN | SYSOUT.\npwa_2_fios_supplies_dcb_attributes equ b'00100000'\npwa_2_concatenated  equ b'00010000' |   Allocation by DD is concat'd@DD\npwa_2_reference_supplied  equ b'00001000'  Reference supplied by caller\npwa_2_free_on_terminate   equ b'00000100'  Terminate should unallocate.\npwa_2_ascii               equ b'00000010'  File is ascii,caller ebcdic.\npwa_2_valid_find_active   equ b'00000001'  A valid find is active.\n*                                   |\npwa_oc_mode         ds  x           | Option: &FI_OC_ INPUT/OUTPUT.\npwa_oc_ident        ds  x           | Option: &FI_OC_ DSNAME/DDNAME.\npwa_oc_filetempx    ds  x           | Option: &FI_OC_ FILETEMP.\npwa_oc_disp         ds  x           | Opt: EXISTING/NEW/REPLACE/APPEND.\npwa_oc_recfm        ds  x           | Option: &FI_OC_ FIXED/VARIABLE.\npwa_oc_open         ds  x           | Option: &FI_OC_ AUTOOPEN/MANUAL*.\npwa_oc_xopt         ds  x           | Option: &FI_OC_XOPT BYTE/WORD.\npwa_oc2_cc          ds  x           | Option: &FI_OC2_ ISOCC.\npwa_oc2_free        ds  x           | Option: &FI_OC2_ AUTO/MANUAL.\npwa_oc2_sysoutx     ds  x           | Option: &FI_OC2_ SYSOUT.\npwa_oc2_chkpdsmemx  ds  x           | Option: &FI_OC2_ \u00ddNO\u00a8CHKPDSMEM.\npwa_oc2_library     ds  x           | Option: &FI_OC2_ \u00ddNO\u00a8LIBRARY.\npwa_oo_mode         ds  x           | Option: &FI_OO_ INPUT/OUTPUT.\n*                                   |\npwa_userid          ds  cl7         | Current userid, for messages.\npwa_spfedit_rname   equ *,52,c'c'   | RNAME for SPFEDIT pds members.\npwa_dsname          ds  cl44        |  Full dsn, padded w/blanks.\npwa_member          ds  cl8         |  Member name, padded w/blanks.\npwa_ddname          ds  cl8         | DDname allocated to dsname.\npwa_sysoutclass     ds  c           | SYSOUT(class) if OPTIONS(SYSOUT)\npwa_unitname        ds  cl8         | Unitname (only present for err)\npwa_volser          ds  cl6         | Volser of allocated file.\npwa_dsorg           ds  cl4         | DSORG returned by dynalloc.\npwa_recfm           ds  x           | Actual dataset RECFM.\npwa_lrecl           ds  f           | Actual dataset LRECL.\npwa_blksize         ds  f           | Actual dataset BLKSIZE.\n*  BPAM buffer entry related.\npwa_bent_count             ds h     |\npwa_bent_size              ds f     |\npwa_bent_buffer_size       ds f     |\npwa_bent_buffer_address    ds a     |\npwa_bent_current           ds a     |\npwa_bent_current_cursor    ds a     |\npwa_bent_current_remaining ds f     |\n*\npwa_status          ds  x           | Allocation status:\npwa_status_old      equ x'01'       |   OLD.\npwa_status_mod      equ x'02'       |   MOD.\npwa_status_new      equ x'04'       |   NEW.\npwa_status_shr      equ x'08'       |   SHR.\npwa_ndisp           ds  x           | Normal DISPosition value:\npwa_ndisp_uncatlg   equ x'01'       |   UNCATLG.\npwa_ndisp_catlg     equ x'02'       |   CATLG.\npwa_ndisp_delete    equ x'04'       |   DELETE.\npwa_ndisp_keep      equ x'08'       |   KEEP.\npwa_ndisp_pass      equ x'10'       |   PASS.\n*                                   |\npwa_dcb             dcb ddname=xxxxxxxx,dsorg=ps,macrf=(r)\n                    org pwa_dcb     | Overlay PS DCB with PO DCB.\n                    dcb ddname=xxxxxxxx,dsorg=po,macrf=(r)\n                    org ,           | Get back to right address.\npwa_open            ds  cl(open_l)  | OPEN parameter list.\n*                                   |\npwa_current_record ds   a           | Address of next logical record.\n*                                   |\npwa_avglrecl        ds  f           | Average LRECL\npwa_maxlrecl        ds  f           | Max. LRECL (=AVG if RECFM=FB)\npwa_sizeinit        ds  f           | Initial record count\npwa_sizeincr        ds  f           | Incremental record count\n*                                   |\npwa_primary_blocks      ds  f       | Primary # blocks for allocation\npwa_secondary_blocks    ds  f       | Secondary # blocks for alloc.\n*                                   |\npwa_suggested_blksize   ds  f       | Suggested output BLKSIZE.\npwa_recs_per_block      ds  f       | Number of records per block.\n*                                   |\npwa_unitname_textunit   ds  a       | Address of caller's DALUNIT tu\n*                                   |\npwa_msg_data        ds  2f          | Address/length of message.\npwa_err_msg_len     ds  f           | Short description of error,\npwa_err_msg         ds  cl256       | Error, Warning, or Info msg.\n*                                   |\npwa_exlst           ds  f           | Exit-list for OPEN TYPE=J.\n                    es_gdi dsect=no |\npwa_jfcb            ds  cl176       | JFCB work-area.               @DD\npwa_fi_reference    ds  cl70        | FI_START reference string\npwa_UCBTBYT4        ds  cl(l'UCBTBYT4)  Device type from UCB.\npwa_save_r15        ds  f           | Field to temporarily contain R15\n                    ds  0f          | List of text unit pointers, with\npwa_textunits       ds  cl(50*4)    |   high bit set in final pointer.\npwa_textunits_end   ds  f\n                    endpwa          |\n                    eject           |\n***********************************************************************\n*  Buffer entry used for BPAM.\n***********************************************************************\n         vda gentype=dsect,id=bent_\nbent_decb       ds   xl(l'&psd.decb)\nbent_next       ds   a\nbent_data_start ds   0d\nbent_fixed_len  equ  *-bent_start\n         endvda\n                    eject           |\n***********************************************************************\n*  Environment Support Vector DSECT\n***********************************************************************\n              es_esv  ,             |\n              eject                 |\n***********************************************************************\n*  MVS Router Parameter List used by RACROUTE.\n***********************************************************************\n              ichsafp ,             |\n              eject                 |\n***********************************************************************\n*  DEVTYPE return area DSECT\n***********************************************************************\n              ihadva ,              |\n***********************************************************************\n*  Dynamic allocation DSECTs\n***********************************************************************\n              iefzb4d0              |\n              iefzb4d2              |\n              eject                 |\n***********************************************************************\n*  Data set control block DSECT\n***********************************************************************\n              dcbd     dsorg=ps     |\n              iefucbob ,            |\njfcb          dsect                 | IEFJFCBN doesn't make a DSECT.\n              IEFJFCBN list=yes     |\n              cvt      dsect=yes    |\n              eject                 |\n***********************************************************************\n*  Parameter list for all file servers.\n***********************************************************************\n              fi_parmlist           |\n***********************************************************************\n              end ,                 |\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SRVFIMAC": {"ttr": 22282, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x02\\x00\\x00W\\x01\\x11)\\x9f\\x01\\x11)\\x9f\\t'\\x05\\x06\\x05\\x06\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@\"", "ispf": {"version": "02.00", "flags": 0, "createdate": "2011-10-26T00:00:00", "modifydate": "2011-10-26T09:27:57", "lines": 1286, "newlines": 1286, "modlines": 0, "user": "CLEMSON"}, "text": "*---------------------------------------------------------------------*\n*  Copyright 2011 by Clemson University Research Foundation           *\n*                                                                     *\n*  Licensed under the Apache License, Version 2.0 (the \"License\");    *\n*  you may not use this file except in compliance with the License.   *\n*  You may obtain a copy of the License in this library as member     *\n*  $LICENSE, or from                                                  *\n*                                                                     *\n*      http://www.apache.org/licenses/LICENSE-2.0                     *\n*                                                                     *\n*  Unless required by applicable law or agreed to in writing,         *\n*  software distributed under the License is distributed on an \"AS    *\n*  IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either    *\n*  express or implied.  See the License for the specific language     *\n*  governing permissions and limitations under the License.           *\n*---------------------------------------------------------------------*\n TITLE 'SRVFIMAC: File Handler Service Processor Symbols && Macros.'\n*---------------------------------------------------------------------*\n*\n*  Copy File:  SRVFIMAC\n*\n*  Purpose:    File Handler service processor symbols and macros.\n*\n*  Description: See \"Service Processors User's Guide and Reference\".\n*\n*  Change\n*  History   2011/10/20 JCB - Patch rollup for CBT tape distribution\n*\n*---------------------------------------------------------------------*\n*\n***********************************************************************\n***********************************************************************\n**                                                                   **\n**                     Symbol Definitions                            **\n**                                                                   **\n***********************************************************************\n***********************************************************************\n GBLC &FI_OS_FILE_HANDLER\n GBLC &FI_XSUBID_HANDLER\n GBLC &FI_PDF_FILE_HANDLER\n GBLC &FI_SMS_FILE_HANDLER\n GBLA &FI_START,&FI_TERMINATE,&FI_READLINE,&FI_GET_INFO,&FI_GI_MSG\n GBLA &FI_WRITELINE,&FI_READLINE_LOCATE\n GBLA &FI_OPEN,&FI_CLOSE,&FI_DELETE\n GBLA &FI_GI_NAME,&FI_GI_LRECL,&FI_GI_RECFM,&FI_GI_IDSTRING\n GBLA &FI_GI_VOLUME,&FI_GI_DDNAME\n GBLA &FI_OC_INPUT,&FI_OC_OUTPUT,&FI_OC_FILENAME,&FI_OC_FILEID\n GBLA &FI_OC_EXISTING,&FI_OC_NEW,&FI_OC_FIXED,&FI_OC_VARYING\n GBLA &FI_OC_REPLACE,&FI_OC_APPEND\n GBLA &FI_OC_IDENT,&FI_OC_FILETEMPX,&FI_OC_FILETEMP\n GBLA &FI_OC_AUTOOPEN,&FI_OC_MANUALOPEN\n GBLA &FI_OC_XOPT,&FI_OC_XOPTBYTE,&FI_OC_XOPTWORD\n GBLA &FI_OC_RESERVED\n GBLA &FI_OC2_FREE,&FI_OC2_AUTOFREE,&FI_OC2_MANUALFREE\n GBLA &FI_OC2_CC,&FI_OC2_ISOCC\n GBLA &FI_OC2_SYSOUT\n GBLA &FI_OC2_LIBRARY\n GBLA &FI_OC2_RESERVED,&FI_OC32_RESERVED,&FI_OC42_RESERVED\n GBLA &FI_OO_INPUT,&FI_OO_OUTPUT,&FI_OO_DEFAULT\n GBLA &FI_SUCCESS,&FI_NOT_FOUND,&FI_END_OF_FILE,&FI_WARNING\n GBLA &FI_ERROR,&FI_SEVERE,&FI_INVALID_SYNTAX,&FI_INVALID_FILEID\n GBLA &FI_GET_REFERENCE\n GBLA &FI_FIND\n GBLA &FI_SET_STATUS,&FI_SS_END_OF_FILE\n GBLA &FI_OC2_CHKPDSMEMX,&FI_OC2_CHKPDSMEM,&FI_OC2_NOCHKPDSMEM\n GBLA &FI_OC2_ASCII\n*\n* Entry point names for all file handlers.\n*\n&FI_OS_FILE_HANDLER     SETC '''SRVFIOS ''' Standard OS file handler.\n&FI_XSUBID_HANDLER      SETC '''SRVFIXID''' XsubID file handler.\n&FI_PDF_FILE_HANDLER    SETC '''SRVFIPDF''' Ispf/Pdf Edit file handler.\n&FI_SMS_FILE_HANDLER    SETC '''SRVFISMS''' Source Management System.\n&FI_SUBMIT_HANDLER      SETC '''SRVFISUB''' Job submission handler.\n*\n* Function codes.\n*\n&FI_START               SETA 1          Start a file handler session.\n&FI_TERMINATE           SETA 2          Terminate a session.\n&FI_READLINE            SETA 5          Read next sequential record.\n&FI_GET_INFO            SETA 6          Obtain messages & attributes.\n&FI_WRITELINE           SETA 7          Append a line to output file.\n&FI_SET_STATUS          SETA 8          Set the file's status.\n&FI_OPEN                SETA 9          Open the file.\n&FI_CLOSE               SETA 10         Close the file.\n&FI_DELETE              SETA 11         Delete the file.\n&FI_GET_REFERENCE       SETA 12         Get reference string.\n&FI_FIND                SETA 13         Find member.\n&FI_READLINE_LOCATE     SETA 14         Read-locate next line.\n*\n* Informational codes for use with FI_GET_INFO.\n*\n&FI_GI_MSG              SETA 1          Get most recently issued msg.\n&FI_GI_NAME             SETA 2          Get the file's full name.\n&FI_GI_LRECL            SETA 3          Get the file's logical rec len.\n&FI_GI_RECFM            SETA 4          Get the file's record format.\n&FI_GI_IDSTRING         SETA 5          Get an 8-character ID string.\n&FI_GI_DDNAME           SETA 6          Get DDNAME (SRVFIOS only).\n&FI_GI_VOLUME           SETA 7          Get VOLUME (SRVFIOS only).\n*\n* Status codes used with FI_SET_STATUS\n*\n&FI_SS_END_OF_FILE      SETA 1          Mark EOF without closing file.\n*\n* Option codes used during START to indicate how the file will be used.\n*\n*                            |-BYTE  1-|\n&FI_OC_MODE         SETA 128 |X... ....|Bit-mask for INPUT/OUTPUT:\n&FI_OC_INPUT        SETA   0 |0... ....|  Read records from file.\n&FI_OC_OUTPUT       SETA 128 |1... ....|  Write records to file.\n&FI_OC_IDENT        SETA  64 |.X.. ....|Bit-mask for FILENAME/FILEID:\n&FI_OC_FILENAME     SETA   0 |.0.. ....|  Identified by name.\n&FI_OC_FILEID       SETA  64 |.1.. ....|  Identified by ID (DDNAME).\n&FI_OC_DISP         SETA  40 |..X. X...|Bit-mask EXISTING/NEW/REPLACE\n&FI_OC_EXISTING     SETA   0 |..0. 0...|  File already exists.\n&FI_OC_NEW          SETA  32 |..1. 0...|  File is being created.\n&FI_OC_REPLACE      SETA   8 |..0. 1...|  File is being replaced.\n&FI_OC_APPEND       SETA  40 |..1. 1...|  File is being appended-to.\n&FI_OC_RECFM        SETA  16 |...X ....|Bit-mask for FIXED/VARYING:\n&FI_OC_FIXED        SETA   0 |...0 ....|  Create w/fixed length recs.\n&FI_OC_VARYING      SETA  16 |...1 ....|  Create w/varying length recs.\n&FI_OC_OPEN         SETA   4 |.... .X..|Bit-Mask for OPEN=AUTO/MANUAL.\n&FI_OC_AUTOOPEN     SETA   0 |.... .0..|  Start automatically OPENs.\n&FI_OC_MANUALOPEN   SETA   4 |.... .1..|  FI_OPEN must be used to OPEN.\n&FI_OC_FILETEMPX    SETA   2 |.... ..x.|Bit-mask for FILETEMP:\n&FI_OC_FILETEMP     SETA   2 |.... ..1.|  Temporary file.\n&FI_OC_XOPT         SETA   1 |.... ...X|Bit-mask for extended options.\n&FI_OC_XOPTBYTE     SETA   0 |.... ...0|  Basic options (byte).\n&FI_OC_XOPTWORD     SETA   1 |.... ...1|  Extended options (fullword).\n&FI_OC_RESERVED     SETA   0 |.... ....|Reserved bits: none.\n*                            |         |\n*                            |-BYTE  2-|Supplied if FI_OC_XOPTWORD = 1\n*                            |         |\n&FI_OC2_FREE        SETA 128 |x... ....|Bit-mask for MANUAL/AUTO FREE\n&FI_OC2_AUTOFREE    SETA   0 |0... ....|  AUTOFREE.\n&FI_OC2_MANUALFREE  SETA 128 |1... ....|  MANUALFREE.\n&FI_OC2_CC          SETA  64 |.x.. ....|Bit-mask for control character.\n&FI_OC2_ISOCC       SETA  64 |.1.. ....|  Records have ISO/ANSI control\n*                            |         |  characters.\n&FI_OC2_SYSOUTX     SETA  32 |..x. ....|Bit-mask for SYSOUTX:\n&FI_OC2_SYSOUT      SETA  32 |..1. ....|  SYSOUT File.\n&FI_OC2_CHKPDSMEMX  SETA  16 |...x ....|Bit-mask for PDS Member Check.\n&FI_OC2_CHKPDSMEM   SETA   0 |...0 ....|  Check to see if member exists\n&FI_OC2_NOCHKPDSMEM SETA  16 |...1 ....|  Do not check to see if member\n*                            |         |    exists.\n&FI_OC2_ASCII       SETA   8 |.... 1...|File is ASCII (caller sees only\n*                            |         |  EBCDIC).\n&FI_OC2_LIBRARY     SETA   4 |.... .1..|This is a read-only library.\n*                            |         |  FI_FIND is required.\n&FI_OC2_RESERVED    SETA   3 |.... ..00|Reserved bits: must be zero.\n*                            |         |\n*                            |-BYTE  3-|Supplied if FI_OC_XOPTWORD = 1\n*                            |         |\n&FI_OC3_RESERVED    SETA 255 |0000 0000|Reserved bits: must be zero.\n*                            |         |\n*                            |-BYTE  4-|Supplied if FI_OC_XOPTWORD = 1\n*                            |         |\n&FI_OC4_RESERVED    SETA 255 |0000 0000|Reserved bits: must be zero.\n*\n*\n* Option codes used during OPEN to indicate how the file will be used.\n*\n&FI_OO_MODE     SETA 192 |XX.. ....|  Bit-mask for INPUT/OUTPUT:\n&FI_OO_DEFAULT  SETA   0 |00.. ....|    Default to start option.\n&FI_OO_INPUT    SETA 128 |10.. ....|    Read records from file.\n&FI_OO_OUTPUT   SETA 192 |11.. ....|    Write records to file.\n&FI_OO_RESERVED SETA  63 |..00 0000|  Reserved bits: must be zero.\n*\n* Return codes.\n*   FI_INVALID_SYNTAX is returned by the START function only; it is\n*   used when file-servers are being cascaded to indicate that the file\n*   name is not for the type of file supported by that particular file\n*   server and that the next server should be tried. If file-servers\n*   are not being cascaded or if the last one has been tried,\n*   FI_INVALID_SYNTAX should be treated in the same manner as FI_ERROR.\n*\n&FI_SUCCESS             SETA  0         Successful completion.\n&FI_NOT_FOUND           SETA  1         Member or record not found.\n&FI_END_OF_FILE     SETA  &FI_NOT_FOUND Alternate name for not found.\n&FI_WARNING             SETA  2         Non-terminating error occurred.\n&FI_ERROR               SETA  3         Terminating error occurred.\n&FI_SEVERE              SETA  4         A severe terminating error.\n&FI_INVALID_SYNTAX      SETA  5         Unsupported filename syntax.\n&FI_INVALID_FILEID      SETA  6         A bad file-token was used.\n&FI_CRITICAL            SETA  7         A critical error occured.\n DEFUCOND MACRO=SRV##RC,NAME=FI_SUCCESS\n DEFUCOND MACRO=SRV##RC,NAME=FI_NOT_FOUND\n DEFUCOND MACRO=SRV##RC,NAME=FI_END_OF_FILE\n DEFUCOND MACRO=SRV##RC,NAME=FI_WARNING\n DEFUCOND MACRO=SRV##RC,NAME=FI_ERROR\n DEFUCOND MACRO=SRV##RC,NAME=FI_SEVERE\n DEFUCOND MACRO=SRV##RC,NAME=FI_INVALID_SYNTAX\n DEFUCOND MACRO=SRV##RC,NAME=FI_INVALID_FILEID\n DEFUCOND MACRO=SRV##RC,NAME=FI_CRITICAL\n                        EJECT\n***********************************************************************\n***********************************************************************\n**                                                                   **\n**                     Macro Definitions                             **\n**                                                                   **\n***********************************************************************\n***********************************************************************\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   FI_ID                                                      *\n*                                                                     *\n* Purpose: Establish default values for a specific service processor  *\n*          and associate them with the specified ID name. The values  *\n*          are stored in the following created global variables:      *\n*                                                                     *\n* Variable Name                     Description                       *\n* -------------  ---------------------------------------------------- *\n* #$&ID.$#IDMAC  Name of macro that created the ID: FI_ID.            *\n* #$&ID.$#ESID   Service processor's Environment Support ID.          *\n* #$&ID.$#EPN    Tag for Service processor's Entry Point Name.        *\n* #$&ID.$#EPA    Tag for Service processor's Entry Point Address.     *\n* #$&ID.$#TKN    Tag for Service processor's Entry Point Token.       *\n* #$&ID.$#EMC    Tag for Service processor's Error Macro name.        *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         FI_ID &ID=,&ESVA=,&SPEPNAME=,&SPEPA=,&SPTOKEN=,&ESID=,&ERRMAC=\n.*\n.* Invoke SRV##ID to create globals used by all ID's.\n.*\n         SRV##ID SET,                                                  +\n               ID=&ID.,IDMAC=FI_ID,ESID=&ESID.,SPEPNAME=&SPEPNAME,     +\n               SPEPA=&SPEPA,SPTOKEN=&SPTOKEN.,ERRMAC=&ERRMAC\n         MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   FI_START                                                   *\n* Purpose: Generate code to start a new file handler session.         *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         FI_START &ID=,&SPEPA=,&SPTOKEN=,&ESVA=,&FILE=,&INFO=,&ERRMAC=,+\n               &OPTIONS=,&OPTIONVALUE=,                                +\n               &RECORDLENGTH=,&FILESIZE=,&REFERENCE=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN,&#_IDEMC\n         GBLA  &FI_START                  SETC in open code.\n         GBLA  &FI_OC_INPUT,&FI_OC_OUTPUT,&FI_OC_FILENAME,&FI_OC_FILEID\n         GBLA  &FI_OC_EXISTING,&FI_OC_NEW,&FI_OC_REPLACE,&FI_OC_APPEND\n         GBLA  &FI_OC_AUTOOPEN,&FI_OC_MANUALOPEN\n         GBLA  &FI_OC_FILETEMP,&FI_OC2_SYSOUT\n         GBLA  &FI_OC_XOPT,&FI_OC_XOPTBYTE,&FI_OC_XOPTWORD\n         GBLA  &FI_OC2_FREE,&FI_OC2_AUTOFREE,&FI_OC2_MANUALFREE\n         GBLA  &FI_OC2_CC,&FI_OC2_ISOCC\n         GBLA  &FI_OC2_CHKPDSMEMX,&FI_OC2_CHKPDSMEM,&FI_OC2_NOCHKPDSMEM\n         GBLA  &FI_OC2_LIBRARY\n         GBLA  &FI_OC2_RESERVED,&FI_OC32_RESERVED,&FI_OC42_RESERVED\n         GBLA  &FI_OC2_ASCII\n         LCLC  &L_ADDR,&L_LEN,&L_OPTIONS\n         LCLA  &I,&J,&L\n         LCLB  &K,&NK\n         LCLC  &O_NAME(19)                Option names, paired up.\n         LCLB  &O_SET(19)                 Names specified, paired up.\n         LCLA  &O_VALUE,&O2_VALUE,&O3_VALUE,&O4_VALUE\n         LCLA  &XOPT\n.*\n.* Obtain service processor ID values.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN,ESVA),                    +\n               ID=&ID,IDMAC=FI_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN,       +\n               ESVA=&ESVA.,ERRMAC=&ERRMAC.\n         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT\n         MVC   &#_IDTKN,=F'0'            | Insure TOKEN = 0.\n.*\n.* Generate the OPTIONS parameter for FI_START.\n.*\n.*   The symbols in O_NAME are option keywords that may be specified.\n.*\n.*   Note: The RECORDLENGTH and FILESIZE checks depend on the position\n.*         of INPUT and OUTPUT in the O_NAME list, along with their\n.*         respective O_SET bits.\n.*\n               AIF  ('&OPTIONS' NE '').OPT_KWDS\n&L_OPTIONS     SETC '&OPTIONVALUE'\n               AGO  .PAST_OPTIONS\n.OPT_KWDS      ANOP\n&O_NAME(1)     SETC 'INPUT','OUTPUT','FILENAME','FILEID'\n&O_NAME(5)     SETC 'EXISTING','NEW','REPLACE'\n&O_NAME(8)     SETC 'AUTOOPEN','MANUALOPEN','APPEND','FILETEMP'\n&O_NAME(12)    SETC 'AUTOFREE','MANUALFREE','ISOCC','SYSOUT'\n&O_NAME(16)    SETC 'CHKPDSMEM','NOCHKPDSMEM','ASCII','LIBRARY'\n.*                  1 2 3 4 5 6 7 8 9 + 1 2 3 4 5 6 7 8 9\n&O_SET(1)      SETB 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\n&I             SETA 0\n.O_KWD_LOOP    AIF  (&I GE N'&OPTIONS).PAST_OPT\n&I             SETA &I+1\n&J             SETA 1\n.O_NAME_LOOP   AIF  (&J GT N'&O_NAME).PAST_NAME\n               AIF  ('&OPTIONS(&I)' EQ '&O_NAME(&J)').PAST_NAME\n&J             SETA &J+1\n               AGO  .O_NAME_LOOP\n.PAST_NAME     AIF   (&J LE N'&O_NAME).O_CHK_SET\n               MNOTE 8,'Option &OPTIONS(&I) is invalid.'\n               AGO   .O_KWD_LOOP\n.O_CHK_SET     AIF   (NOT (&O_SET(&J))).O_SET_OPT\n               MNOTE 8,'Option &OPTIONS(&I) already specified.'\n               AGO   .O_KWD_LOOP\n.O_SET_OPT     ANOP\n&O_SET(&J)     SETB  1\n               AGO   .O_KWD_LOOP\n.PAST_OPT      ANOP\n.*\n.* If SYSOUT was specified, generate options OUTPUT,NEW,FILEID,ISOCC\n.*\n               AIF  (NOT &O_SET(15)).PAST_SYSOUT_IMPLY\n               MNOTE *,'SYSOUT Implies OUTPUT,NEW,FILEID,ISOCC'\n&O_SET(2)      SETB  1     OUTPUT\n&O_SET(4)      SETB  1     FILEID\n&O_SET(6)      SETB  1     NEW\n&O_SET(14)     SETB  1     ISOCC\n.PAST_SYSOUT_IMPLY ANOP\n.*\n.* Check for mutually exclusive keywords and other invalid combos.\n.*\n&L_OPTIONS SETC  'INPUT and OUTPUT'\n           AIF   (&O_SET(1) AND &O_SET(2)).MUTEX  (INPUT OUTPUT)\n&L_OPTIONS SETC  'LIBRARY and OUTPUT'\n           AIF   (&O_SET(19) AND &O_SET(2)).MUTEX  (LIBRARY OUTPUT)\n&L_OPTIONS SETC  'FILENAME and FILEID'\n           AIF   (&O_SET(3)  AND &O_SET(4)).MUTEX\n&L_OPTIONS SETC  'SYSOUT AND INPUT'\n           AIF   (&O_SET(15) AND &O_SET(1)).MUTEX\n&L_OPTIONS SETC  'SYSOUT AND FILENAME'\n           AIF   (&O_SET(15) AND &O_SET(3)).MUTEX\n&L_OPTIONS SETC  'SYSOUT AND EXISTING'\n           AIF   (&O_SET(15) AND &O_SET(5)).MUTEX\n&L_OPTIONS SETC  'SYSOUT AND REPLACE'\n           AIF   (&O_SET(15) AND &O_SET(7)).MUTEX\n&L_OPTIONS SETC  'SYSOUT AND APPEND'\n           AIF   (&O_SET(15) AND &O_SET(10)).MUTEX\n.*\n&L_OPTIONS SETC  'EXISTING, NEW, REPLACE, and APPEND'\n           AIF   (&O_SET(5)+&O_SET(6)+&O_SET(7)+&O_SET(10) GT 1).MUTEX\n&L_OPTIONS SETC  'AUTOOPEN and MANUALOPEN'\n           AIF   (&O_SET(8) AND &O_SET(9)).MUTEX  (AUTOOPEN MANUALOPEN)\n&L_OPTIONS SETC  'AUTOFREE and MANUALFREE'\n           AIF   (&O_SET(12) AND &O_SET(13)).MUTEX\n           AGO   .PAST_MUTEX\n.MUTEX     MNOTE 8,'Options &L_OPTIONS are mutually exclusive'\n.PAST_MUTEX ANOP\n            AIF   (&O_SET(2) OR (NOT &O_SET(10))).PAST_APPCHK\n            MNOTE 8,'APPEND option only valid for OUTPUT.'\n.PAST_APPCHK ANOP\n.*\n.* Determine if using basic or extended options.\n.*\n           AIF   (&O_SET(12) OR &O_SET(13) OR &O_SET(14)).XOPT_WORD\n           AIF   (&O_SET(15) OR &O_SET(16) OR &O_SET(17)).XOPT_WORD\n           AIF   (&O_SET(18) OR &O_SET(19)).XOPT_WORD\n&XOPT      SETA  &FI_OC_XOPTBYTE\n           AGO   .PAST_XOPT\n.XOPT_WORD ANOP\n&XOPT      SETA  &FI_OC_XOPTWORD\n.PAST_XOPT ANOP\n.*\n.* Build the option-bytes that will be used.\n.*\n&O_VALUE       SETA  0\n&O_VALUE       SETA  &O_VALUE+(&O_SET(1)*(&FI_OC_INPUT))\n&O_VALUE       SETA  &O_VALUE+(&O_SET(2)*(&FI_OC_OUTPUT))\n&O_VALUE       SETA  &O_VALUE+(&O_SET(3)*(&FI_OC_FILENAME))\n&O_VALUE       SETA  &O_VALUE+(&O_SET(4)*(&FI_OC_FILEID))\n&O_VALUE       SETA  &O_VALUE+(&O_SET(5)*(&FI_OC_EXISTING))\n&O_VALUE       SETA  &O_VALUE+(&O_SET(6)*(&FI_OC_NEW))\n&O_VALUE       SETA  &O_VALUE+(&O_SET(7)*(&FI_OC_REPLACE))\n&O_VALUE       SETA  &O_VALUE+(&O_SET(8)*(&FI_OC_AUTOOPEN))\n&O_VALUE       SETA  &O_VALUE+(&O_SET(9)*(&FI_OC_MANUALOPEN))\n&O_VALUE       SETA  &O_VALUE+(&O_SET(10)*(&FI_OC_APPEND))\n&O_VALUE       SETA  &O_VALUE+(&O_SET(11)*(&FI_OC_FILETEMP))\n&O_VALUE       SETA  &O_VALUE+&XOPT\n               AIF   (&XOPT EQ &FI_OC_XOPTWORD).XOPTWORD\n&L_OPTIONS     SETC  '=AL1(&O_VALUE.)'\n               AGO   .PAST_OPTIONS\n.XOPTWORD      ANOP\n&O2_VALUE      SETA  0\n&O2_VALUE      SETA  &O2_VALUE+(&O_SET(12)*(&FI_OC2_AUTOFREE))\n&O2_VALUE      SETA  &O2_VALUE+(&O_SET(13)*(&FI_OC2_MANUALFREE))\n&O2_VALUE      SETA  &O2_VALUE+(&O_SET(14)*(&FI_OC2_ISOCC))\n&O2_VALUE      SETA  &O2_VALUE+(&O_SET(15)*(&FI_OC2_SYSOUT))\n&O2_VALUE      SETA  &O2_VALUE+(&O_SET(16)*(&FI_OC2_CHKPDSMEM))\n&O2_VALUE      SETA  &O2_VALUE+(&O_SET(17)*(&FI_OC2_NOCHKPDSMEM))\n&O2_VALUE      SETA  &O2_VALUE+(&O_SET(18)*(&FI_OC2_ASCII))\n&O2_VALUE      SETA  &O2_VALUE+(&O_SET(19)*(&FI_OC2_LIBRARY))\n&O3_VALUE      SETA  0\n&O4_VALUE      SETA  0\n&L_OPTIONS     SETC  '=AL1(&O_VALUE.,&O2_VALUE,&O3_VALUE,&O4_VALUE)'\n.PAST_OPTIONS  ANOP\n.*\n.* Decode the FILE= keyword to get an address and length.\n.*\n              AIF ('&FILE' EQ '').NO_FILE\n              AIF ('&FILE'(1,1) EQ '''').FILE_LITERAL\n              AIF (N'&FILE EQ 1).FILE_TAGONLY\n              AIF (N'&FILE EQ 2).FILE_TAGLEN\n              MNOTE 8,'Too many subparameters for FILE keyword.'\n              MEXIT\n.FILE_TAGLEN  ANOP\n&L_ADDR       SETC '&FILE(1)'             | Set addr.\n&L_LEN        SETC '&FILE(2)'             | Set len.\n              AGO  .PAST_FILE             |\n.FILE_TAGONLY ANOP\n&L_ADDR       SETC '&FILE'                | Set addr to tag_name.\n&L_LEN        SETC '=A(L''&FILE)'         | Set len to L'tag_name.\n              AGO  .PAST_FILE             |\n.FILE_LITERAL ANOP                        |\n&L_ADDR       SETC '&FILE'                | Set addr to actual literal.\n&L            SETA 0                      | Length counter = 0.\n&I            SETA 2                      | Index counter -> past '.\n.FILE_LOOP    AIF  (&I GE K'&L_ADDR).FILE_ELOOP      Loop over FILE.\n              AIF  ('&L_ADDR'(&I,1) NE '''').FILE_TXT If doubled quotes\n&I            SETA &I+1                   |            Advance past '.\n.FILE_TXT     ANOP                        |          EndIf.\n&L            SETA &L+1                   |   Add one to length.\n&I            SETA &I+1                   |   Advance to next position.\n              AGO  .FILE_LOOP             | End of counting loop.\n.FILE_ELOOP   ANOP                        |\n&L_LEN        SETC '&L'                   | Set length parameter.\n              AGO  .PAST_FILE\n.NO_FILE      AIF  (&O_SET(11) OR &O_SET(15)).PAST_FILE\n  MNOTE 8,'FILE= is required unless FILETEMP or SYSOUT option used.'\n              MEXIT\n.PAST_FILE    ANOP\n.*\n.* Make sure RECORDLENGTH is valid:\n.*   .. If not specified, parms will not be present or will be zero\n.*      addresses if needed as placeholders in parameter list.\n.*   .. Ignored if OPTIONS=INPUT specified (warning only)\n.*   .. Not valid if there's more than 2 specified.\n.*\n.RECLEN   ANOP ,\n          LCLC  &AVGLRECL,&MAXLRECL\n&AVGLRECL SETC  '0'                       Set avg, max LRECL defaults\n&MAXLRECL SETC  '0'\n          LCLB  &AVGLRECL_P,&MAXLRECL_P\n          AIF   ('&RECORDLENGTH' EQ '' AND &O_SET(2)).RLDFLT\n          AIF   ('&RECORDLENGTH' NE '' AND &O_SET(1)).RLIGNORE\n          AIF   (N'&RECORDLENGTH GT 2).RLTOOMANY\n&AVGLRECL SETC  '&RECORDLENGTH(1)'        Set average LRECL\n&AVGLRECL_P SETB 1\n          AIF   (N'&RECORDLENGTH EQ 1).PAST_RECLEN\n&MAXLRECL SETC  '&RECORDLENGTH(2)'\n&MAXLRECL_P SETB 1\n.RLDFLT   AGO   .PAST_RECLEN\n.RLIGNORE MNOTE 4,'RECORDLENGTH parameter will be ignored if OPTIONS=OU*\n               TPUT not specified.'\n          AGO  .PAST_RECLEN\n.RLTOOMANY MNOTE 8,'Too many parameters specified for RECORDLENGTH.'\n          MEXIT\n.PAST_RECLEN   ANOP\n.*\n.* Make sure FILESIZE is valid:\n.*   .. Defaults if OPTIONS=OUTPUT specified to (1000,1000)\n.*   .. Ignored if OPTIONS=INPUT specified (warning only)\n.*   .. Not valid if there's more than 2 specified.\n.*\n.FILESIZE ANOP ,\n          LCLC  &FILEINIT,&FILEINCR\n&FILEINIT SETC  '0'\n&FILEINCR SETC  '0'\n          LCLB  &FILEINIT_P,&FILEINCR_P\n          AIF   ('&FILESIZE' EQ '' AND &O_SET(2)).FSDFLT\n          AIF   ('&FILESIZE' NE '' AND &O_SET(1)).FSIGNORE\n          AIF   (N'&FILESIZE GT 2).FSTOOMANY\n&FILEINIT SETC  '&FILESIZE(1)'\n&FILEINIT_P SETB 1\n          AIF   (N'&FILESIZE EQ 1).PAST_FILESZ\n&FILEINCR SETC  '&FILESIZE(2)'\n&FILEINCR_P SETB 1\n.FSDFLT   AGO   .PAST_FILESZ\n.FSIGNORE MNOTE 4,'FILESIZE parameter will be ignored if OPTIONS=OUTPUT*\n                not specified.'\n          AGO  .PAST_FILESZ\n.FSTOOMANY MNOTE 8,'Too many parameters specified for FILESIZE.'\n          MEXIT\n.PAST_FILESZ   ANOP\n.*\n.* See if REFERENCE was specified.\n.*\n          LCLB &REFERENCE_P\n&REFERENCE_P  SETB 0\n              AIF ('&REFERENCE' EQ '').NO_REFERENCE\n&REFERENCE_P  SETB 1\n.NO_REFERENCE ANOP\n.*\n.* Build VL PLIST based on what was specified.\n.*\n         ##PLIST START\n         ##PLIST PARM,&#_IDTKN,&FI_START,&#_IDESVA,&INFO\n         ##PLIST PARM,&L_ADDR,&L_LEN,&L_OPTIONS\n         AIF   (NOT &O_SET(2)).PLEND\n         AIF   (NOT (&AVGLRECL_P OR &MAXLRECL_P OR &FILEINIT_P OR      *\n               &FILEINCR_P OR &REFERENCE_P)).PLEND\n         ##PLIST PARM,&AVGLRECL\n         AIF  (NOT (&MAXLRECL_P OR &FILEINIT_P OR &FILEINCR_P OR       *\n               &REFERENCE_P)).PLEND\n         ##PLIST PARM,&MAXLRECL\n         AIF   (NOT (&FILEINIT_P OR &FILEINCR_P OR &REFERENCE_P)).PLEND\n         ##PLIST PARM,&FILEINIT\n         AIF   (NOT (&FILEINCR_P OR &REFERENCE_P)).PLEND\n         ##PLIST PARM,&FILEINCR\n         AIF   (NOT &REFERENCE_P).PLEND\n         ##PLIST PARM,&REFERENCE\n.PLEND   ANOP ,\n         ##PLIST END,VL\n.*\n.* Generate the FI_START call statement.\n.*\n         CALLX &#_IDEPA\n.*\n.* If ERRMAC is non-null, generate error-macro instruction.\n.*\n         AIF   ('&#_IDEMC' EQ '').MEXIT\n         &#_IDEMC.\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   FI_OPEN                                                    *\n* Purpose: Generate code to OPEN a file.                              *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         FI_OPEN &ID=,&SPEPA=,&SPTOKEN=,&ERRMAC=,                      +\n               &OPTIONS=,&OPTIONVALUE\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN,&#_IDEMC\n         GBLA  &FI_OPEN                   SETC in open code.\n         GBLA  &FI_OO_INPUT,&FI_OO_OUTPUT\n         LCLC  &O_NAME(2)                 Option names, paired up.\n         LCLB  &O_SET(2)                  Names specified, paired up.\n         LCLA  &O_VALUE\n         LCLC  &L_OPTIONS\n.*\n.* Obtain service processor ID values and OPEN the file.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +\n               ID=&ID,IDMAC=FI_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN,       +\n               ERRMAC=&ERRMAC.\n         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT\n.*\n.* Generate the OPTIONS parameter for FI_OPEN.\n.*\n.*   The symbols in O_NAME are option keywords that may be specified.\n.*\n               AIF  ('&OPTIONS' NE '').OPT_KWDS\n&L_OPTIONS     SETC '&OPTIONVALUE'\n               AGO  .PAST_OPTIONS\n.OPT_KWDS      ANOP\n&O_NAME(1)     SETC 'INPUT','OUTPUT'\n&O_SET(1)      SETB 0,0\n&I             SETA 0\n.O_KWD_LOOP    AIF  (&I GE N'&OPTIONS).PAST_OPT\n&I             SETA &I+1\n&J             SETA 1\n.O_NAME_LOOP   AIF  (&J GT N'&O_NAME).PAST_NAME\n               AIF  ('&OPTIONS(&I)' EQ '&O_NAME(&J)').PAST_NAME\n&J             SETA &J+1\n               AGO  .O_NAME_LOOP\n.PAST_NAME     AIF   (&J LE N'&O_NAME).O_CHK_SET\n               MNOTE 8,'Option &OPTIONS(&I) is invalid.'\n               AGO   .O_KWD_LOOP\n.O_CHK_SET     AIF   (NOT (&O_SET(&J))).O_SET_OPT\n               MNOTE 8,'Option &OPTIONS(&I) already specified.'\n               AGO   .O_KWD_LOOP\n.O_SET_OPT     ANOP\n&O_SET(&J)     SETB  1\n               AGO   .O_KWD_LOOP\n.PAST_OPT      ANOP\n.*\n.* Check for mutually exclusive keywords.\n.*\n&L_OPTIONS SETC  'INPUT and OUTPUT'\n           AIF   (&O_SET(1) AND &O_SET(2)).MUTEX  (INPUT OUTPUT)\n           AGO   .SET_OPTION_BYTE\n.MUTEX     MNOTE 8,'Options &L_OPTIONS are mutually exclusive'\n.*\n.* Build the actual option-byte that will be used.\n.*\n.SET_OPTION_BYTE ANOP\n&O_VALUE       SETA  0\n&O_VALUE       SETA  &O_VALUE+(&O_SET(1)*(&FI_OO_INPUT))\n&O_VALUE       SETA  &O_VALUE+(&O_SET(2)*(&FI_OO_OUTPUT))\n&L_OPTIONS     SETC  '=AL1(&O_VALUE.)'\n.PAST_OPTIONS  ANOP\n.*\n         ##PLIST START\n         ##PLIST PARM,&#_IDTKN,&FI_OPEN\n         AIF ('&OPTIONS' EQ '' AND '&OPTIONVALUE' EQ '').PLEND\n         ##PLIST PARM,&L_OPTIONS\n.PLEND   ##PLIST END,VL\n.*\n.* Generate the FI_START call statement.\n.*\n         CALLX &#_IDEPA\n.*\n.* If ERRMAC is non-null, generate error-macro instruction.\n.*\n         AIF   ('&#_IDEMC' EQ '').MEXIT\n         &#_IDEMC.\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   FI_CLOSE                                                   *\n* Purpose: Generate code to CLOSE a file.                             *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         FI_CLOSE &ID=,&SPEPA=,&SPTOKEN=,&ERRMAC=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN,&#_IDEMC\n         GBLA  &FI_CLOSE                  SETC in open code.\n.*\n.* Obtain service processor ID values and CLOSE the file.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +\n               ID=&ID,IDMAC=FI_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN,       +\n               ERRMAC=&ERRMAC\n         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT\n         CALLX &#_IDEPA,(&#_IDTKN,&FI_CLOSE),VL\n.*\n.* If ERRMAC is non-null, generate error-macro instruction.\n.*\n         AIF   ('&#_IDEMC' EQ '').MEXIT\n         &#_IDEMC.\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   FI_DELETE                                                  *\n* Purpose: Generate code to DELETE a file.                            *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         FI_DELETE &ID=,&SPEPA=,&SPTOKEN=,&ERRMAC=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN,&#_IDEMC\n         GBLA  &FI_DELETE                 SETC in open code.\n.*\n.* Obtain service processor ID values and DELETE the file.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +\n               ID=&ID,IDMAC=FI_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN,       +\n               ERRMAC=&ERRMAC.\n         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT\n         CALLX &#_IDEPA,(&#_IDTKN,&FI_DELETE),VL\n.*\n.* If ERRMAC is non-null, generate error-macro instruction.\n.*\n         AIF   ('&#_IDEMC' EQ '').MEXIT\n         &#_IDEMC.\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   FI_TERMINATE                                               *\n* Purpose: Generate code to terminate a file handler session.         *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         FI_TERMINATE &ID=,&SPEPA=,&SPTOKEN=,&ERRMAC=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN,&#_IDEMC\n         GBLA  &FI_TERMINATE              SETC in open code.\n.*\n.* Obtain service processor ID values and terminate file handler.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +\n               ID=&ID,IDMAC=FI_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN,       +\n               ERRMAC=&ERRMAC.\n         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT\n         CALLX &#_IDEPA,(&#_IDTKN,&FI_TERMINATE),VL\n.*\n.* If ERRMAC is non-null, generate error-macro instruction.\n.*\n         AIF   ('&#_IDEMC' EQ '').MEXIT\n         &#_IDEMC.\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   FI_READLINE                                                *\n* Purpose: Generate code to read the next sequential input line.      *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         FI_READLINE &ID=,&SPEPA=,&SPTOKEN=,&LINE=,&RESULTLEN=,&ERRMAC=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN,&#_IDEMC\n         GBLA  &FI_READLINE\n         LCLC  &L_ADDR,&L_LEN\n.*\n.* Obtain service processor ID values.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +\n               ID=&ID,IDMAC=FI_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN,       +\n               ERRMAC=&ERRMAC.\n         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT\n         AIF  ('&RESULTLEN' NE '').PAST_RESULTLEN\n         MNOTE 8,'RESULTLEN is a required keyword.'\n         MEXIT\n.PAST_RESULTLEN ANOP\n.*\n.* Decode the LINE= keyword to get an address and length.\n.*\n              AIF ('&LINE' EQ '').NO_LINE\n              AIF (N'&LINE EQ 1).LINE_TAGONLY\n              AIF (N'&LINE EQ 2).LINE_TAGLEN\n              MNOTE 8,'Too many subparameters for LINE keyword.'\n              MEXIT\n.LINE_TAGLEN  ANOP\n&L_ADDR       SETC '&LINE(1)'             | Set addr.\n&L_LEN        SETC '&LINE(2)'             | Set len.\n              AGO  .PAST_LINE             |\n.LINE_TAGONLY ANOP\n&L_ADDR       SETC '&LINE'                | Set addr to tag_name.\n&L_LEN        SETC '=A(L''&LINE)'         | Set len to L'tag_name.\n              AGO  .PAST_LINE             |\n.NO_LINE      MNOTE 8,'LINE is a required keyword.'\n              MEXIT\n.PAST_LINE    ANOP\n.*\n.* Generate the CALLX to read a line.\n.*\n         CALLX &#_IDEPA,(&#_IDTKN,&FI_READLINE,&L_ADDR,&L_LEN,         +\n               &RESULTLEN),VL\n.*\n.* If ERRMAC is non-null, generate error-macro instruction.\n.*\n         AIF   ('&#_IDEMC' EQ '').MEXIT\n         &#_IDEMC.\n.MEXIT   MEND\n\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   FI_READLINE_LOCATE                                         *\n* Purpose: Generate code to read the next sequential input line       *\n*          and return it's address and length. Length is optional.    *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         FI_READLINE_LOCATE &ID=,&SPEPA=,&SPTOKEN=,&ADDRESS=,&ERRMAC=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN,&#_IDEMC\n         GBLA  &FI_READLINE_LOCATE\n.*\n.* Obtain service processor ID values.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +\n               ID=&ID,IDMAC=FI_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN,       +\n               ERRMAC=&ERRMAC.\n         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT\n.*\n.* Generate the CALLX to read a line.\n.*\n         CALLX &#_IDEPA,(&#_IDTKN,&FI_READLINE_LOCATE,&ADDRESS),VL\n.*\n.* If ERRMAC is non-null, generate error-macro instruction.\n.*\n         AIF   ('&#_IDEMC' EQ '').MEXIT\n         &#_IDEMC.\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   FI_WRITELINE                                               *\n* Purpose: Generate code to write a line to the current output file.  *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         FI_WRITELINE &ID=,&SPEPA=,&SPTOKEN=,&LINE=,&ERRMAC=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN,&#_IDEMC\n         GBLA  &FI_WRITELINE\n         LCLC  &L_ADDR,&L_LEN\n.*\n.* Obtain service processor ID values.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +\n               ID=&ID,IDMAC=FI_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN,       +\n               ERRMAC=&ERRMAC.\n         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT\n         AIF  ('&LINE' NE '').PAST_LINEREQ\n         MNOTE 8,'LINE is a required keyword.'\n         MEXIT\n.PAST_LINEREQ ANOP\n.*\n.* Decode the LINE= keyword to get an address and length.\n.*\n              AIF ('&LINE' EQ '').NO_LINE\n              AIF (N'&LINE EQ 1).LINE_TAGONLY\n              AIF (N'&LINE EQ 2).LINE_TAGLEN\n              MNOTE 8,'Too many subparameters for LINE keyword.'\n              MEXIT\n.LINE_TAGLEN  ANOP\n&L_ADDR       SETC '&LINE(1)'             | Set addr.\n&L_LEN        SETC '&LINE(2)'             | Set len.\n              AGO  .PAST_LINE             |\n.LINE_TAGONLY ANOP\n&L_ADDR       SETC '&LINE'                | Set addr to tag_name.\n&L_LEN        SETC '=A(L''&LINE)'         | Set len to L'tag_name.\n              AGO  .PAST_LINE             |\n.NO_LINE      MNOTE 8,'LINE is a required keyword.'\n              MEXIT\n.PAST_LINE    ANOP\n.*\n.* Generate the CALLX to write a line.\n.*\n         CALLX &#_IDEPA,(&#_IDTKN,&FI_WRITELINE,&L_ADDR,&L_LEN)\n.*\n.* If ERRMAC is non-null, generate error-macro instruction.\n.*\n         AIF   ('&#_IDEMC' EQ '').MEXIT\n         &#_IDEMC.\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   FI_GET_INFO                                                *\n* Purpose: Get information about a file handler session.              *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         FI_GET_INFO &ID=,&SPEPA=,&SPTOKEN=,&ERRMAC=,                  +\n               &NAME=,&NAMELEN=,                                       +\n               &DDNAME=,&DDNAMELEN=,                                   +\n               &VOLUME=,&VOLUMELEN=,                                   +\n               &MSG=,&MSGLEN=,                                         +\n               &LRECL=,&RECFM=,&IDSTRING=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN,&#_IDEMC\n         GBLA  &FI_GET_INFO\n         GBLA  &FI_GI_NAME,&FI_GI_MSG,&FI_GI_LRECL,&FI_GI_RECFM\n         GBLA  &FI_GI_IDSTRING,&FI_GI_DDNAME,&FI_GI_VOLUME\n         LCLC  &L_ADDR,&L_LEN\n.*\n.* Obtain service processor ID values.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +\n               ID=&ID,IDMAC=FI_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN,       +\n               ERRMAC=&ERRMAC\n         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT\n.*\n.*       Generate parameter list prelude code.\n.*\n         ##PLIST START\n         ##PLIST PARM,&#_IDTKN,&FI_GET_INFO\n.*\n.* If NAME= was specified, generate code to get NAME information.\n.*\n              AIF ('&NAME' EQ '').NO_NAME\n              AIF (N'&NAME EQ 1).NAME_TAGONLY\n              AIF (N'&NAME EQ 2).NAME_TAGLEN\n              MNOTE 8,'Too many subparameters for NAME keyword.'\n              MEXIT\n.NAME_TAGLEN  ANOP\n&L_ADDR       SETC '&NAME(1)'             | Set addr.\n&L_LEN        SETC '&NAME(2)'             | Set len.\n              AGO  .PAST_NAME             |\n.NAME_TAGONLY ANOP\n&L_ADDR       SETC '&NAME'                | Set addr to tag_name.\n&L_LEN        SETC '=A(L''&NAME)'         | Set len to L'tag_name.\n.PAST_NAME    AIF  ('&NAMELEN' NE '').CALL_NAME\n              MNOTE 8,'NAMELEN must be specified if NAME is specified.'\n              MEXIT\n.CALL_NAME    ##PLIST PARM,&FI_GI_NAME,&L_ADDR,&L_LEN,&NAMELEN\n.NO_NAME      ANOP\n.*\n.* If DDNAME= was specified, generate code to get DDNAME information.\n.*\n              AIF ('&DDNAME' EQ '').NO_DDNAME\n              AIF (N'&DDNAME EQ 1).DDNAME_TAGONLY\n              AIF (N'&DDNAME EQ 2).DDNAME_TAGLEN\n              MNOTE 8,'Too many subparameters for DDNAME keyword.'\n              MEXIT\n.DDNAME_TAGLEN  ANOP\n&L_ADDR       SETC '&DDNAME(1)'             | Set addr.\n&L_LEN        SETC '&DDNAME(2)'             | Set len.\n              AGO  .PAST_DDNAME             |\n.DDNAME_TAGONLY ANOP\n&L_ADDR       SETC '&DDNAME'                | Set addr to tag_ddname.\n&L_LEN        SETC '=A(L''&DDNAME)'         | Set len to L'tag_ddname.\n.PAST_DDNAME    AIF  ('&DDNAMELEN' NE '').CALL_DDNAME\n        MNOTE 8,'DDNAMELEN must be specified if DDNAME is specified.'\n              MEXIT\n.CALL_DDNAME  ##PLIST PARM,&FI_GI_DDNAME,&L_ADDR,&L_LEN,&DDNAMELEN\n.NO_DDNAME    ANOP\n.*\n.* If VOLUME= was specified, generate code to get VOLUME information.\n.*\n              AIF ('&VOLUME' EQ '').NO_VOLUME\n              AIF (N'&VOLUME EQ 1).VOLUME_TAGONLY\n              AIF (N'&VOLUME EQ 2).VOLUME_TAGLEN\n              MNOTE 8,'Too many subparameters for VOLUME keyword.'\n              MEXIT\n.VOLUME_TAGLEN  ANOP\n&L_ADDR       SETC '&VOLUME(1)'             | Set addr.\n&L_LEN        SETC '&VOLUME(2)'             | Set len.\n              AGO  .PAST_VOLUME             |\n.VOLUME_TAGONLY ANOP\n&L_ADDR       SETC '&VOLUME'                | Set addr to tag_VOLUME.\n&L_LEN        SETC '=A(L''&VOLUME)'         | Set len to L'tag_VOLUME.\n.PAST_VOLUME    AIF  ('&VOLUMELEN' NE '').CALL_VOLUME\n        MNOTE 8,'VOLUMELEN must be specified if VOLUME is specified.'\n              MEXIT\n.CALL_VOLUME  ##PLIST PARM,&FI_GI_VOLUME,&L_ADDR,&L_LEN,&VOLUMELEN\n.NO_VOLUME    ANOP\n.*\n.* If MSG= was specified, generate code to get MSG information.\n.*\n              AIF ('&MSG' EQ '').NO_MSG\n              AIF (N'&MSG EQ 1).MSG_TAGONLY\n              AIF (N'&MSG EQ 2).MSG_TAGLEN\n              MNOTE 8,'Too many subparameters for MSG keyword.'\n              MEXIT\n.MSG_TAGLEN   ANOP\n&L_ADDR       SETC '&MSG(1)'              | Set addr.\n&L_LEN        SETC '&MSG(2)'              | Set len.\n              AGO  .PAST_MSG              |\n.MSG_TAGONLY  ANOP\n&L_ADDR       SETC '&MSG'                 | Set addr to tag_MSG.\n&L_LEN        SETC '=A(L''&MSG)'          | Set len to L'tag_MSG.\n.PAST_MSG     AIF  ('&MSGLEN' NE '').CALL_MSG\n              MNOTE 8,'MSGLEN must be specified if MSG is specified.'\n              MEXIT\n.CALL_MSG     ##PLIST PARM,&FI_GI_MSG,&L_ADDR,&L_LEN,&MSGLEN\n.NO_MSG       ANOP\n.*\n.* If LRECL= was specified, generate code to get LRECL information.\n.*\n              AIF ('&LRECL' EQ '').NO_LRECL\n.CALL_LRECL   ##PLIST PARM,&FI_GI_LRECL,&LRECL\n.NO_LRECL     ANOP\n.*\n.* If RECFM= was specified, generate code to get RECFM information.\n.*\n              AIF ('&RECFM' EQ '').NO_RECFM\n.CALL_RECFM   ##PLIST PARM,&FI_GI_RECFM,&RECFM\n.PAST_RECFM   ANOP\n.NO_RECFM     ANOP\n.*\n.* If IDSTRING= was specified, generate code to get IDSTRING info.\n.*\n              AIF ('&IDSTRING' EQ '').NO_IDSTRING\n.CALL_IDSTRING ##PLIST PARM,&FI_GI_IDSTRING,&IDSTRING\n.PAST_IDSTRNG ANOP\n.NO_IDSTRING  ANOP\n.*\n.* Complete the parameter list and generate the call.\n.*\n               ##PLIST END,VL\n               CALLX   &#_IDEPA\n               AIF   ('&#_IDEMC' EQ '').NO_EMC\n               &#_IDEMC.\n.NO_EMC        ANOP\n.MEXIT         MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   FI_GET_REFERENCE                                           *\n* Purpose: Get reference string from file handler session.            *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         FI_GET_REFERENCE &ID=,&SPEPA=,&SPTOKEN=,&ERRMAC=,             +\n               &REFERENCE=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN,&#_IDEMC\n         GBLA  &FI_GET_REFERENCE\n.*\n.* Obtain service processor ID values.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +\n               ID=&ID,IDMAC=FI_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN,       +\n               ERRMAC=&ERRMAC\n         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT\n         AIF  ('&REFERENCE' EQ '').NO_REF\n         CALLX   &#_IDEPA,(&#_IDTKN,&FI_GET_REFERENCE,&REFERENCE),VL\n              MEXIT\n.NO_REF       MNOTE 8,'REFERENCE is a required keyword.'\n.MEXIT         MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   FI_SET_STATUS                                              *\n* Purpose: Provide information to the file handler on the file's      *\n*          current status.                                            *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         FI_SET_STATUS &ID=,&SPEPA=,&SPTOKEN=,&ERRMAC=,                +\n               &EOF=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN,&#_IDEMC\n         GBLA  &FI_SET_STATUS\n         GBLA  &FI_SS_END_OF_FILE\n         LCLC  &L_ADDR,&L_LEN\n.*\n.* Obtain service processor ID values.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +\n               ID=&ID,IDMAC=FI_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN,       +\n               ERRMAC=&ERRMAC\n         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT\n.*\n.* If EOF= (END_OF_FILE) was specified\n.*\n              AIF ('&EOF' EQ 'YES').SET_EOF\n              AIF ('&EOF' EQ '').NO_EOF\n              MNOTE 8,'Invalid value (&EOF) for the EOF keyword.'\n              MEXIT\n.SET_EOF      ANOP\n.CALL_NAME    CALLX &#_IDEPA,(&#_IDTKN,&FI_SET_STATUS,                 +\n               &FI_SS_END_OF_FILE)\n              AIF   ('&#_IDEMC' EQ '').NO_EMC\n              &#_IDEMC.\n.NO_EMC       ANOP\n.NO_EOF       ANOP\n.MEXIT        MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   FI_FIND                                                    *\n* Purpose: Specifies the member that should be read.  Resets EOF.     *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         FI_FIND &ID=,&SPEPA=,&SPTOKEN=,&ERRMAC=,                      +\n               &MEMBER=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN,&#_IDEMC\n         GBLA  &FI_FIND\n         LCLC  &L_MEM,&L_LEN\n.*\n.* Obtain service processor ID values.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +\n               ID=&ID,IDMAC=FI_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN,       +\n               ERRMAC=&ERRMAC\n         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT\n.*\n.* Process MEMBER and call function.\n.*\n         AIF   ('&MEMBER' EQ '').REQUIRED\n&L_MEM   SETC  '&MEMBER(1)'\n         AIF   (N'&MEMBER EQ 1).DFLTLEN\n         AIF   (N'&MEMBER EQ 2).LENSPEC\n         AGO   .ERRMEM\n.DFLTLEN ANOP\n&L_LEN   SETC  '=A(L''&L_MEM)'\n         AGO   .CALL\n.LENSPEC ANOP\n&L_LEN   SETC '&MEMBER(2)'\n.CALL    CALLX &#_IDEPA,(&#_IDTKN,&FI_FIND,                            +\n               &L_MEM,&L_LEN)\n         AIF   ('&#_IDEMC' EQ '').NO_EMC\n         &#_IDEMC.\n         MEXIT\n.ERRMEM  MNOTE 'MEMBER required.'\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   FI_OS_INFO                                                 *\n* Purpose: Generate OS-specific information for an allocation.  The   *\n*          macro actually generates SVC 99 textunits for the various  *\n*          parameters that it supports.  The textunit keys are hard-  *\n*          coded within the macro, so that the caller doesn't have to *\n*          include IEFZB4D2 in his code.  FI_OS_INFO and the OS file  *\n*          handler currently support 'unit', 'volume' and 'directory  *\n*          blocks' as OS_specific file creation parameters.           *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         FI_OS_INFO  &UNIT=,                                           *\n               &DDNAME=,                                               *\n               &DIRBLKS=,                                              *\n               &FREE=,                                                 *\n               &SPIN=,                                                 *\n               &SYSOUT=,                                               *\n               &VOLUME=,                                               *\n               &PL=,                                                   *\n               &DS=\n         LCLA  &L\n         AIF   ('&PL' EQ '').PLREQD\n.*--------------------------------------------------------------------*\n.* First, generate the textunits for the parms we support now.\n.*--------------------------------------------------------------------*\n           LCLB  &F_UNIT,&F_VOLUME,&F_DIRBLKS\n           LCLB  &F_SYSOUT,&F_FREE,&F_SPIN,&F_DDNAME\n&F_UNIT    SETB  ('&UNIT' NE '')\n&F_VOLUME  SETB  ('&VOLUME' NE '')\n&F_DIRBLKS SETB  ('&DIRBLKS' NE '')\n&F_SYSOUT  SETB  ('&SYSOUT' NE '')\n&F_FREE    SETB  ('&FREE' NE '')\n&F_SPIN    SETB  ('&SPIN' NE '')\n&F_DDNAME  SETB  ('&DDNAME' NE '')\n.*\n.UNIT        AIF   (NOT &F_UNIT).END_UNIT\n             MVC   ##FI_OS_UNIT_&SYSNDX.(6),=X'001500010008'\n             AIF   ('&UNIT'(1,1) EQ '''').UNITLIT\n             MVC   ##FI_OS_UNIT_&SYSNDX.+6(8),&UNIT\n             AGO   .END_UNIT\n.UNITLIT     MVC   ##FI_OS_UNIT_&SYSNDX.+6(8),=CL8&UNIT\n.END_UNIT    ANOP\n.*\n.VOLUME      AIF   (NOT &F_VOLUME).END_VOLUME\n             MVC   ##FI_OS_VOLUME_&SYSNDX.(6),=X'001000010006'\n             AIF   ('&VOLUME'(1,1) EQ '''').VOLLIT\n             MVC   ##FI_OS_VOLUME_&SYSNDX.+6(6),&VOLUME\n             AGO   .END_VOLUME\n.VOLLIT      MVC   ##FI_OS_VOLUME_&SYSNDX.+6(6),=CL6&VOLUME\n.END_VOLUME  ANOP\n.*\n.DDNAME      AIF   (NOT &F_DDNAME).END_DDNAME\n             MVC   ##FI_OS_DDNAME_&SYSNDX.(6),=X'000100010008'\n             AIF   ('&DDNAME'(1,1) EQ '''').DDNAMELIT\n             MVC   ##FI_OS_DDNAME_&SYSNDX.+6(8),&DDNAME\n             AGO   .END_DDNAME\n.DDNAMELIT   MVC   ##FI_OS_DDNAME_&SYSNDX.+6(8),=CL8&DDNAME\n.END_DDNAME  ANOP\n.*\n.DIRBLKS     AIF   (NOT &F_DIRBLKS).END_DIRBLKS\n             MVC   ##FI_OS_DIRBLKS_&SYSNDX.(6),=X'000C00010003'\n             AIF   (T'&DIRBLKS  EQ 'N').DIRLIT\n             MVC   ##FI_OS_DIRBLKS_&SYSNDX.+6(3),&DIRBLKS\n             AGO   .END_DIRBLKS\n.DIRLIT      MVC   ##FI_OS_DIRBLKS_&SYSNDX.+6(3),=AL3(&DIRBLKS)\n.END_DIRBLKS ANOP\n.*\n.SYSOUT      AIF   (NOT &F_SYSOUT).END_SYSOUT\n             MVC   ##FI_OS_SYSOUT_&SYSNDX.(6),=X'001800010001'\n             AIF   (T'&SYSOUT  EQ 'N').SOLIT\n             MVC   ##FI_OS_SYSOUT_&SYSNDX.+6(1),&SYSOUT\n             AGO   .END_SYSOUT\n.SOLIT       MVC   ##FI_OS_SYSOUT_&SYSNDX.+6(1),=AL3(&SYSOUT)\n.END_SYSOUT  ANOP\n.*\n.FREE        AIF   (NOT &F_FREE).END_FREE\n             AIF   ('&FREE' EQ 'END').FREEEND\n             AIF   ('&FREE' EQ 'CLOSE').FREECLOSE\n             MNOTE 8,'FREE=\u00ddEND|CLOSE\u00a8.  Value provided invalid.'\n             AGO   .END_FREE\n.FREEEND     MNOTE *,'FREE=END does not produce any text units.'\n.FREECLOSE   MVC   ##FI_OS_FREE_&SYSNDX.(4),=X'001C0000'\n.END_FREE    ANOP\n.*\n.SPIN        AIF   (NOT &F_SPIN).END_SPIN\n             AIF   ('&SPIN' EQ 'UNALLOC').SPINUNALC\n             AIF   ('&SPIN' EQ 'NO').SPINNO\n             MNOTE 8,'SPIN=\u00ddUNALLOC|NO\u00a8. Value provided invalid.'\n.SPINUNALC   MVC   ##FI_OS_SPIN_&SYSNDX.(7),=X'80130001000180'\n             AGO   .END_SPIN\n.SPINNO      MVC   ##FI_OS_SPIN_&SYSNDX.(7),=X'80130001000140'\n.END_SPIN    ANOP\n.*--------------------------------------------------------------------*\n.* Generate the PWA fields that the textunits will be built in.\n.*--------------------------------------------------------------------*\n.GENPWA                  PWA   TYPE=PARTIAL\n                         AIF   (NOT &F_UNIT).PWA_E_UNIT\n##FI_OS_UNIT_&SYSNDX     DS    CL14\n.PWA_E_UNIT              ANOP\n                         AIF   (NOT &F_VOLUME).PWA_E_VOLUME\n##FI_OS_VOLUME_&SYSNDX   DS    CL12\n.PWA_E_VOLUME            ANOP\n                         AIF   (NOT &F_DDNAME).PWA_E_DDNAME\n##FI_OS_DDNAME_&SYSNDX   DS    CL9\n.PWA_E_DDNAME            ANOP\n                         AIF   (NOT &F_DIRBLKS).PWA_E_DIRBLKS\n##FI_OS_DIRBLKS_&SYSNDX  DS    CL9\n.PWA_E_DIRBLKS           ANOP\n                         AIF   (NOT &F_SYSOUT).PWA_E_SYSOUT\n##FI_OS_SYSOUT_&SYSNDX   DS    CL7\n.PWA_E_SYSOUT            ANOP\n                         AIF   (NOT &F_FREE).PWA_E_FREE\n##FI_OS_FREE_&SYSNDX     DS    CL4\n.PWA_E_FREE              ANOP\n                         AIF   (NOT &F_SPIN).PWA_E_SPIN\n##FI_OS_SPIN_&SYSNDX     DS    CL7\n.PWA_E_SPIN              ANOP\n.PWAEND                  ENDPWA  ,\n.*--------------------------------------------------------------------*\n.* Now, generate the parmlist that will point to them.\n.*--------------------------------------------------------------------*\n.GENPLIST      ANOP ,\n               ##PLIST START,PL=&PL,DS=&DS\n               AIF     ('&UNIT' EQ '').GEN_E_UNIT\n               ##PLIST PARM,##FI_OS_UNIT_&SYSNDX\n.GEN_E_UNIT    ANOP\n               AIF     ('&VOLUME' EQ '').GEN_E_VOLUME\n               ##PLIST PARM,##FI_OS_VOLUME_&SYSNDX\n.GEN_E_VOLUME  ANOP\n               AIF     ('&DDNAME' EQ '').GEN_E_DDNAME\n               ##PLIST PARM,##FI_OS_DDNAME_&SYSNDX\n.GEN_E_DDNAME  ANOP\n               AIF     ('&DIRBLKS' EQ '').GEN_E_DIRBLKS\n               ##PLIST PARM,##FI_OS_DIRBLKS_&SYSNDX\n.GEN_E_DIRBLKS ANOP\n               AIF     ('&SYSOUT' EQ '').GEN_E_SYSOUT\n               ##PLIST PARM,##FI_OS_SYSOUT_&SYSNDX\n.GEN_E_SYSOUT  ANOP\n               AIF     ('&FREE' EQ '').GEN_E_FREE\n               ##PLIST PARM,##FI_OS_FREE_&SYSNDX\n.GEN_E_FREE    ANOP\n               AIF     ('&SPIN' EQ '').GEN_E_SPIN\n               ##PLIST PARM,##FI_OS_SPIN_&SYSNDX\n.GEN_E_SPIN    ANOP\n               ##PLIST END,VL\n.EXIT    MEXIT\n.PLREQD  MNOTE 8,'PL= is a required parameter on the FI_OS_INFO macro.'\n         MEXIT\n         MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   FI_PARMLIST                                                *\n* Purpose: Generate mapping fields for the parameters accepted by the *\n*          File Handler.                                              *\n*                                                                     *\n*---------------------------------------------------------------------*\n                  MACRO\n&LABEL            FI_PARMLIST &DSECT=YES\n                  LCLC  &NAME\n&NAME             SETC  'FI_PARMLIST'\n                  AIF   ('&LABEL' EQ '').PAST_LABEL\n&NAME             SETC  '&LABEL'\n.PAST_LABEL       ANOP\n                  AIF   ('&DSECT' EQ 'YES').GEN_DSECT\n&NAME             DS    0F         | File Handler Parameter List:\n                  AGO .GEN_FIELDS\n.GEN_DSECT        ANOP\n&NAME             DSECT            | File Handler Parameter List:\n.GEN_FIELDS       ANOP ,           |\nFI_FILEID         DS  A            |   Token := PWA Base Address.\nFI_FUNCTIONCODE   DS  A            |   Function to be performed.\nFI_SPECIFIC       EQU *            |   Function-specific parameters.\n                  ORG FI_SPECIFIC  |   FI_START parameters:\nFI_ESV            DS  A            |     Environment support vector.\nFI_INFO           DS  A            |     Information (not used).\nFI_FILENAME       DS  A            |     Text of file's name.\nFI_NAMELENGTH     DS  A            |     Length of file's name.\nFI_OPTIONS        DS  A            |     Option codes.\nFI_START_MIN_#_PARMS EQU (*-&NAME.)/4\n*                                  | *** The following parameters are\n*                                  |     optional FI_START parameters,\n*                                  |     and only apply when OPTIONS=\n*                                  |     OUTPUT is used.\n*                                  |   * Record lengths: If AVG is the\n*                                  |     only reclen specified, or AVG\n*                                  |     and MAX are both present and\n*                                  |     equal, RECFM will be FB: else,\n*                                  |     RECFM=VB with LRECL=MAX.\nFI_AVG_RECLEN     DS  A            |       Avg. record length.\nFI_MAX_RECLEN     DS  A            |       Max. record length\n*                                  |   * File sizes: If INITIAL is pre-\n*                                  |     sent, INITIAL * MAX_RECLEN is\n*                                  |     used to derive primary extent\n*                                  |     size.  INCREMENT, is present,\n*                                  |     is used similarly to determine\n*                                  |     secondary extent size.\nFI_SIZE_INITIAL   DS  A            |       Estimated initial # records\nFI_SIZE_INCREMENT DS  A            |       Estimated incremental # recs\nFI_REFERENCE      DS  A            |     Reference string.\nFI_START_MAX_#_PARMS EQU (*-&NAME.)/4\n                  ORG FI_SPECIFIC  |   FI_GET_INFO parameters:\nFI_GI_FUNCTION    DS  A            |     Information sub-code.\nFI_GI_AREA        DS  A            |     Area to return information.\nFI_GI_AREA_SIZE   DS  A            |     Length of return area.\nFI_GI_LENGTH      DS  A            |     Length of returned info.\n                  ORG FI_SPECIFIC  |   FI_SET_STATUS parameters:\nFI_SS_FUNCTION    DS  A            |     Status sub-code.\nFI_SS_AREA        DS  A            |     Area to return information.\nFI_SS_AREA_SIZE   DS  A            |     Length of return area.\nFI_SS_LENGTH      DS  A            |     Length of returned info.\n                  ORG FI_SPECIFIC  |   FI_GET_REFERENCE parameters:\nFI_GR_REFERENCE   DS  A            |     Status sub-code.\n                  ORG FI_SPECIFIC  |   FI_READLINE parameters:\nFI_RL_AREA        DS  A            |     Target area for reading line.\nFI_RL_AREA_SIZE   DS  A            |     Length of target area.\nFI_RL_LENGTH      DS  A            |     Length of line just read.\n                  ORG FI_SPECIFIC  |   FI_READLINE_LOCATE parms.\nFI_RLL_ADDRESS    DS  A            |     Address of line just read.\n                  ORG FI_SPECIFIC  |   FI_WRITELINE parameters:\nFI_WL_LINE        DS  A            |     Text of output line.\nFI_WL_LENGTH      DS  A            |     Length of output line.\n                  ORG FI_SPECIFIC  |   FI_FIND parameters:\nFI_FD_MEMBER      DS  A            |     Member name.\nFI_FD_LENGTH      DS  A            |     Length of member name.\n                  ORG FI_SPECIFIC  |   FI_OPEN parameters:\nFI_OP_OPTIONS     DS  A            |     Option codes.\n                  ORG ,            | Adjust to final parmlist offset.\n&NAME._L          EQU *-&NAME.     | Length of File Handler Parmlist.\n                  MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SRVFIOS": {"ttr": 23041, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x02\\x00\\x00W\\x01\\x11)\\x9f\\x01\\x11)\\x9f\\t'\\x0e\\xe1\\x0e\\xe1\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@\"", "ispf": {"version": "02.00", "flags": 0, "createdate": "2011-10-26T00:00:00", "modifydate": "2011-10-26T09:27:57", "lines": 3809, "newlines": 3809, "modlines": 0, "user": "CLEMSON"}, "text": "*---------------------------------------------------------------------*\n*  Copyright 2011 by Clemson University Research Foundation           *\n*                                                                     *\n*  Licensed under the Apache License, Version 2.0 (the \"License\");    *\n*  you may not use this file except in compliance with the License.   *\n*  You may obtain a copy of the License in this library as member     *\n*  $LICENSE, or from                                                  *\n*                                                                     *\n*      http://www.apache.org/licenses/LICENSE-2.0                     *\n*                                                                     *\n*  Unless required by applicable law or agreed to in writing,         *\n*  software distributed under the License is distributed on an \"AS    *\n*  IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either    *\n*  express or implied.  See the License for the specific language     *\n*  governing permissions and limitations under the License.           *\n*---------------------------------------------------------------------*\n            SMLIST CONVERT=YES\nSRVFIOS     title \"File service processor\"\n         srvmod name=srvfios,dates='1987, 1990, 1993, 1995, 2001'\n         gblc  &srv_modname\n*\n*\n*  WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING\n*\n*  For performance reasons, this module does NOT use COPY in the\n*  options statement to copy incoming parameters.  If you want to check\n*  a parm to see if it is actually present, you must do it the old\n*  fashioned way: check the high-order bit of the last non-optional\n*  parm and go forward from there.....mjm 2001-08-13.\n*\n*  WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING\n*\n*---------------------------------------------------------------------*\n*\n*  Copyright (C) Clemson University Research Foundation 1987, 2001.\n*\n*  Program     SRVFIOS\n*\n*  Abstract    SRVFIOS reads from and writes to sequential files with\n*              either fixed length or varying length records. Programs\n*              can use SRVFIOS to read from a file or write records to\n*              a file without having to know anything more than the\n*              file's data set name or ddname.  All records passed\n*              between the file server and its caller are in the form\n*              of a varying length string, regardless of the actual\n*              characteristics of the file being accessed.\n*\n*  Parameters:\n*    Documented in the Service Processors Guide & Reference.\n*\n*  Program     reentrant, problem key and state, standard linkage,\n*  Attributes  non-authorized, amode(any), rmode(24)\n*\n*  Special     1. This program depends on the PWA being automatically\n*  Notes          cleared to all-zeros by the BLOCK macro when it is\n*                 first allocated during start-up.\n*              2. This program runs below the 16-megabyte line because\n*                 it uses standard I/O macros.  However, it expects to\n*                 be called with Amode=31.\n*              3. For sequential input, the data set is dynamically\n*                 allocated with a disposition of SHR, causing the\n*                 following enqueue to be performed:\n*\n*                 ENQ SYSDSN,CL44(dsname),S,44,SYSTEM\n*\n*                 For sequential output, if the data set exists,\n*                 dynamic allocation is invoked again to change the\n*                 disposition to OLD.  If the data set does not exist,\n*                 dynamic allocation is invoked with a disposition of\n*                 NEW to create it.  In either case, the following\n*                 enqueue results:\n*\n*                 ENQ SYSDSN,CL44(dsname),S,44,SYSTEM\n*\n*                 The above enqueues are implicitly performed as a\n*                 result of dynamic allocation.  In addition, if output\n*                 is being done to a member of a partitioned data set,\n*                 the following enqueue is explicitly performed:\n*\n*                 ENQ SPFEDIT,'CL44(dsname),CL8(member)',E,52,SYSTEMS\n*\n*  Change\n*  History   2011/10/20 JCB - Patch rollup for CBT tape distribution\n*\n*---------------------------------------------------------------------*\n EJECT\n print off\n copy  smsyms    | Obtain Structured Macros symbols.\n copy  srvesmac  | Obtain Environment Support symbols & macros.\n copy  srvstmac  | Obtain String Handler symbols & macros.\n copy  srvfimac  | Obtain File Handler symbols & macros.\n copy  smpucond  | Obtain User Conditions.\n print on,gen\n*---------------------------------------------------------------------*\n* Set up local variable used for assemble SRVFIOS as RMODE=24 or\n* RMODE=ANY based on &SRV_SRVFIOS_RMODE.  This should be set in\n* SRVLEVEL.\n*---------------------------------------------------------------------*\n gblc  &srv_srvfios_rmode\n aif   ('&srv_srvfios_rmode' eq 'ANY').rmode_any\n aif   ('&srv_srvfios_rmode' eq '24').rmode_24\n aif   ('&srv_srvfios_rmode' eq '').rmode_24\n mnote 8,'&&SRV_SRVFIOS_RMODE must be null, 24, or ANY.'\n.rmode_24  anop\n&srvfios_program_rmode  setc '24'\n&srvfios_iosub_amode    setc '31'\n&srvfios_iocall_amode   setc '24'\n&srvfios_open_mode      setc '24'\n ago .rmode_end\n.rmode_any anop\n&srvfios_program_rmode  setc 'ANY'\n&srvfios_iosub_amode    setc ''\n&srvfios_iocall_amode   setc ''\n&srvfios_open_mode      setc '31'\n.rmode_end anop\n*---------------------------------------------------------------------*\n EJECT\n*---------------------------------------------------------------------*\n*\n*  Macro:      TEXT_UNIT Key,(Parm 1,Parm 2,...)\n*  Purpose:    Define storage for a dynamic allocation text unit. The\n*              value used for Key should be the name of a dynamic\n*              allocation verb defined in IEFZB4D0. The values used for\n*              Parm-n must be such that when used on a DC instruction,\n*              they will not cause alignment and will produce the\n*              correct length value for L' attributes.\n*\n*---------------------------------------------------------------------*\n                macro\n&label          text_unit &key,&parm\n                lcla &n,&i\n&n              seta n'&parm                    number of parms.\n&label._key     dc  al2(&key)                   dynalloc text unit key.\n&label._count   dc  al2(&n)                     number of parameters.\n&i              seta 1\n.parm_loop      aif (&i gt &n).noparm\n                dc  al2(l'&label._parm&i)       length of parameter.\n&label._parm&i  dc  &parm(&i)                   value of parameter.\n&i              seta &i+1\n                ago  .parm_loop\n.noparm         anop\n&label          equ &label._key,*-&label._key,c'c'  text unit storage.\n                mend\n eject\n***********************************************************************\n***********************************************************************\n**                                                                   **\n**                                                                   **\n**                      SRVFIOS Main Program                         **\n**                                                                   **\n**                                                                   **\n***********************************************************************\n***********************************************************************\n         gblb   &security_check\n&security_check setb 0        << PERMANENT: Allow S913 instead of\n*                                trying to detect RACF security\n*                                violations and issue a message.\n*\n block name=&srv_modname,type=program,                                 +\n               amode=31,rmode=&srvfios_program_rmode,                  +\n               options=(*srvprc,main,dyn,long),r1save=r9,           @DD+\n               subopts=(*swa,loadbase)\n   es_id id=es,spepa=pwa_esepa,sptoken=pwa_estkn,esva=pwaaesv\n   st_id id=st,spepname=&string_handler,sizelength=4,                  +\n               spepa=pwa_st_spepa,sptoken=pwa_st_sptoken\n*                                     |\n   using fi_parmlist,r9               | Establish addressability.\n   mvc   gdirc,=h'0'                  | Clear out return-code.\n*---------------------------------------------------------------------*\n*  If the function code is something other than start, make sure that\n*  the PWA contains the eye-catcher string and the correct value for\n*  FileID.  If not, then the FileID passed in is garbage.\n*---------------------------------------------------------------------*\n   l  r2,fi_functioncode              | R2 -> Fullword function code.\n   if (clc,=f'&start',ne,0(r2))       | If not startup function then\n    if ((clc,pwa_visual,ne,eyecatcher),or,(c,r13,ne,pwa_fileid))\n     errexit code=&fi_invalid_fileid  |\n    endif                             |  Endif.\n    if (tbit,pwa_1_error)             |  If previous error.\n     l  r1,0(r2)                        | R1 := function code.\n     caseblk reg=r1,mult=1            |   Case on function-code.\n      case &terminate,&fi_get_info,&fi_get_reference\n      case other                      |    Die on anything else.\n       callsub message,(fi00004)      |\n       errexit code=0                 |\n     endcase                          |   EndCase.\n    endif                             |  Endif.\n   endif                              | Endif.\n   if (clc,=f'&fi_get_info',ne,0(r2)) | If not get_info function.\n    l  r14,fi00000                    |  r14 -> success message.\n    st r14,pwa_msg_data+4             |  save address of length\n    la r14,4(,r14)                    |  save address of text.\n    st r14,pwa_msg_data+0             |\n   endif                              | Endif.\n*---------------------------------------------------------------------*\n*  Use the FunctionCode to determine which subroutine to invoke.\n*---------------------------------------------------------------------*\n   l  r1,0(r2)                        | R1 := function code.\n*                                     |\n   caseblk reg=r1,mult=1              | Case on FunctionCode.\n     case &start                      |   Open a new file.\n       callsub start                  |\n     case &terminate                  |   Terminate file handler.\n       callsub terminate              |     Kill file and buffers.\n       smctrl  freepwa=yes            |     Release the PWA on exit.\n     case &fi_open                    |   Open the file.\n       callsub open_parm              |     Process open parameters.\n       callsub open                   |     Open file.\n     case &fi_close                   |   Close the file.\n       callsub close                  |\n     case &fi_delete                  |   Delete the file.\n       callsub delete                 |\n     case &fi_readline                |   Read the next line.\n       callsub readline               |\n     case &fi_readline_locate         |   Read the next line.\n       callsub readline               |     (Note: uses same routine!)\n     case &fi_writeline               |   Write a new line.\n       callsub writeline              |\n     case &fi_get_info                |   Obtain information.\n       callsub get_info               |\n     case &fi_set_status              |   Set file status information.\n       callsub set_status             |\n     case &fi_get_reference           |   Obtain information.\n       callsub get_reference          |\n     case &fi_find                    |   Find.\n       callsub find                   |\n     case other                       |   Invalid function code.\n       callsub message,(fi00005,0(r2))\n       errexit code=0                 |\n   endcase                            | EndCase.\n*                                     |\n   lh      r15,gdirc                  | R15 := return code.\n endblk block=&srv_modname            | Quit w/possible return code.\n eject\n***********************************************************************\n*                                                                     *\n*  Subroutine: START                                                  *\n*  Abstract:   Open a file for the type of access requested. The only *\n*              access modes supported are sequential input or output. *\n*                                                                     *\n***********************************************************************\n block name=start,type=subroutine\n*  *------------------------------------------------------------------*\n*  * All fields in the PWA have already been initialized to zeros by\n*  * the block macro.  Initialize those fields that must be non-zero\n*  *------------------------------------------------------------------*\n   mvc   pwa_visual,eyecatcher          | Eyecatcher and fileid are for\n   st    r13,pwa_fileid                 | validity checks and dumps.\n   l     r2,pwaaesv                     | R2 -> ESV.\n   using esv,r2                         | Establish addressability.\n   mvc   pwa_esepa,esvesepa             | Get Environment Support EPA.\n   mvc   pwa_estkn,esvestkn             | Get Env Support TOKEN.\n   drop  r2                             | Drop addressability.\n*                                       |\n   fill  pwa_ddname,c' '                | Clear out the DDNAME.\n   fill  pwa_dsname,c' '                | Clear out the DSNAME.\n   fill  pwa_member,c' '                | Clear out the MEMBER.\n   fill  pwa_volser,c' '                | Clear out the VOLSER.\n   fill  pwa_sysoutclass,c' '           | Clear out the SYSOUTCLASS.\n   fill  pwa_unitname,c' '              | Clear out the UNITNAME.\n   fill  pwa_userid,c' '                | Set the default userid value.\n   mvc   pwa_fi_reference(12),=c\"Unknown file\" | Initialize ref string\n   mvc   pwa_avglrecl,=f'0'             | Initialize to 0 (missing)\n   mvc   pwa_maxlrecl,=f'0'             | Initialize to 0 (missing)\n   mvc   pwa_sizeinit,=f'1000'          | Default SizeInit = 1000.\n   mvc   pwa_sizeincr,=f'1000'          | Default SizeIncr = 1000.\n   mvc   pwa_dcbe,psd_dcbe              | Move DCBE.\n*                                       |\n   la    r1,pwa_textunits+l'pwa_textunits-4\n   st    r1,pwa_textunits_end\n*                                       |\n   es_get_userid id=es,userid=pwa_userid   Attempt to get the real one.\n*                                       |\n*  *------------------------------------------------------------------*\n*  * Load and start the string-handler for use in message formatting.\n*  *------------------------------------------------------------------*\n   es_load_module id=es,spid=st         | Load String Handler module.\n   if (treg,r15,nz),then                | If string-handler not loaded\n     st   r15,pwa_save_r15              | Preserve r15 for errexit\n     callsub message,(fi00023)          |   Unable to load.\n     l    r15,pwa_save_r15              | Rest r15 for debug analysis\n     errexit code=0                     |\n   endif                                | EndIf.\n   st_start id=st                       | Start the String Handler.\n   if (treg,r15,nz),then                | If string-handler \u00acstarted.\n     st   r15,pwa_save_r15              | Preserve r15 for errexit\n     callsub message,(fi00024)          |   Unable to start.\n     l    r15,pwa_save_r15              | Rest r15 for debug analysis\n     errexit code=0                     |\n   endif                                | EndIf.\n*  *------------------------------------------------------------------*\n*  * Insure that required parameters were specified for FI_START.\n*  *------------------------------------------------------------------*\n   if not,((tbit,fi_fileid,x'80',off),and,         Make sure fileid,   +\n               (tbit,fi_functioncode,x'80',off),and,    functioncode,  +\n               (tbit,fi_esv,x'80',off),and,             esv, info,     +\n               (tbit,fi_info,x'80',off),and,            filename,      +\n               (tbit,fi_filename,x'80',off),and,        namelength,    +\n               (tbit,fi_namelength,x'80',off))      and options present\n     callsub message,(fi00006,'start',5) |   Issue an error message.\n     errexit code=0                      |\n   endif                                 | EndIf.\n*  *------------------------------------------------------------------*\n*  * Process the OPTIONS parameter.\n*  *------------------------------------------------------------------*\n*\n*  Make sure that all reserved OPTIONS flags are zeros.\n*\n   l  r2,fi_options                      | R2 -> options parameter.\n   la r2,0(r2)                           | Get rid of VL bit if any.\n   if (treg,r2,z)                        | If OPTIONS not supplied.\n     callsub message,(fi00007,,0)        |   Issue an error message.\n     errexit code=0                      |\n   elseif (tbit,0(r2),&fi_oc_reserved,any)\n     callsub message,(fi00007,0(r2),1)   |   Issue an error message.\n     errexit code=0                      |\n   else                                  |\n     mvc   pwa_oc_xopt,0(r2)             | Save XOPT flag.\n     ni    pwa_oc_xopt,&fi_oc_xopt       | Mask off other bits.\n     if    (cli,pwa_oc_xopt,eq,&fi_oc_xoptword)\n       if  (tbit,1(r2),&fi_oc2_reserved,any),or,                       +\n               (tbit,2(r2),&fi_oc3_reserved,any),or,                   +\n               (tbit,3(r2),&fi_oc4_reserved,any)\n         callsub message,(fi00007,0(r2),4)\n         errexit code=0\n       endif\n     endif\n   endif                                 | EndIf.\n*\n*  Separate the option-flags to make checking for specific values\n*  and combinations of values easier.\n*\n   mvc   pwa_oc_mode,0(r2)               | Save INPUT/OUTPUT flag.\n   ni    pwa_oc_mode,&fi_oc_mode         | Mask off other bits.\n   mvi   pwa_oo_mode,&fi_oo_input        | Set OO_MODE\n   if (cli,pwa_oc_mode,eq,&fi_oc_output)   to reflect\n    mvi   pwa_oo_mode,&fi_oo_output      | status of\n   endif                                 | INPUT/OUTPUT flag.\n   mvc   pwa_oc_ident,0(r2)              | Save FILENAME/FILEID flag.\n   ni    pwa_oc_ident,&fi_oc_ident       | Mask off other bits.\n   mvc   pwa_oc_filetempx,0(r2)          | Save FILETEMP flag.\n   ni    pwa_oc_filetempx,&fi_oc_filetempx Mask off other bits.\n   mvc   pwa_oc_disp,0(r2)               | EXISTING/NEW/REPLACE/APPEND.\n   ni    pwa_oc_disp,&fi_oc_disp         | Mask off other bits.\n   mvc   pwa_oc_recfm,0(r2)              | Save FIXED/VARIABLE flag.\n   ni    pwa_oc_recfm,&fi_oc_recfm       | Mask off other bits.\n   mvc   pwa_oc_open,0(r2)               | Save OPEN=AUTO|MANUAL flag.\n   ni    pwa_oc_open,&fi_oc_open         | Mask off other bits.\n*\n   if (cli,pwa_oc_xopt,eq,&fi_oc_xoptword) If extended options\n     mvc   pwa_oc2_free,1(r2)            |   Save FREE flag.\n     ni    pwa_oc2_free,&fi_oc2_free     |   Mask off other bits.\n     mvc   pwa_oc2_cc,1(r2)              |   Save ISOCC flag.\n     ni    pwa_oc2_cc,&fi_oc2_cc         |   Mask off other bits.\n     mvc   pwa_oc2_sysoutx,1(r2)         |   Save SYSOUT flag.\n     ni    pwa_oc2_sysoutx,&fi_oc2_sysoutx   Mask off other bits.\n     mvc   pwa_oc2_chkpdsmemx,1(r2)      |   Save CHKPDSMEM flag.\n     ni    pwa_oc2_chkpdsmemx,&fi_oc2_chkpdsmemx Mask off other bits.\n*\n     if (tbit,1(r2),&fi_oc2_ascii,on)    |   If ASCII option specified.\n      sbit pwa_2_ascii                   |    Turn on pwa flag.\n     endif                               |   EndIf.\n     mvc   pwa_oc2_library,1(r2)         |   Save LIBRARY flag.\n     ni    pwa_oc2_library,&fi_oc2_library   Mask off other bits.\n   endif                                 | EndIf.\n*\n*  Check for invalid combinations of options.\n*\n   if (cli,pwa_oo_mode,eq,&fi_oo_input)  | If INPUT access mode.\n     if (cli,pwa_oc_disp,ne,&fi_oc_existing) If not EXISTING file.\n       callsub message,(fi00032)         |     Issue an error message.\n       errexit code=0                    |     Exit w/return-code.\n     endif                               |   EndIf.\n   endif                                 | EndIf.\n   if (cli,pwa_oo_mode,eq,&fi_oo_output) | If OUTPUT access mode.\n     if (cli,pwa_oc2_library,eq,&fi_oc2_library) If LIBRARY option.\n       callsub message,(fi00033,         |     Issue an error message. +\n               'LIBRARY and OUTPUT',18)  |\n       errexit code=0                    |     Exit w/return-code.\n     endif                               |   EndIf.\n   endif                                 | EndIf.\n*  *------------------------------------------------------------------*\n*  * Process optional START parameters (OUTPUT mode only)\n*  *------------------------------------------------------------------*\n   block type=inline,name=&s.optional_start_parms\n    if (tbit,fi_options,x'80',on)\n     leave block=&s.optional_start_parms\n    endif\n    if (cli,pwa_oo_mode,eq,&fi_oo_input) | If INPUT mode.\n     if (tbit,fi_options,x'80',off)      |  If parm(s) follow options.\n       callsub message,(fi00034)         |   Issue an error message.\n       errexit code=0                    |   Exit w/return-code.\n     endif                               |  EndIf.\n    endif                                | EndIf.\n*   *-----------------------------------------------------------------*\n*   * Process RECORDLENGTH=(average <,maximum>)\n*   *     and FILESIZE=(initial <,increment>).\n*   *-----------------------------------------------------------------*\n    l   r1,fi_avg_reclen                 | r1 -> Avg_reclen parm.\n    la  r1,0(,r1)                        | Toss high-order bit.\n    if  (treg,r1,p)                      | If still non-zero address\n      l  r1,0(,r1)                       |   r1 := avg_reclen parm.\n      if (treg,r1,p)                     |   If value is non-zero.\n        st r1,pwa_avglrecl               |     Save in PWA.\n      endif                              |   EndIf.\n    endif                                | EndIf.\n*                                        |\n    if (tbit,fi_avg_reclen,x'80',on)     | If end of parms.\n     leave block=&s.optional_start_parms |  Done with parms.\n    endif                                | EndIf.\n*                                        |\n    l   r1,fi_max_reclen                 | r1 -> Max_reclen parm.\n    la  r1,0(,r1)                        | Toss high-order bit.\n    if  (treg,r1,p)                      | If still non-zero address\n      l  r1,0(,r1)                       |   r1 := max_reclen parm.\n      if (treg,r1,p)                     |   If value is non-zero.\n        st r1,pwa_maxlrecl               |     Save in PWA.\n      endif                              |   EndIf.\n    endif                                | EndIf.\n*                                        |\n    if (tbit,fi_max_reclen,x'80',on)     | If end of parms.\n     leave block=&s.optional_start_parms |  Done with parms.\n    endif                                | EndIf.\n*                                        |\n    l   r1,fi_size_initial               | r1 -> Initial size parm.\n    la  r1,0(,r1)                        | Toss high-order bit.\n    if  (treg,r1,p)                      | If still non-zero.\n      l  r1,0(,r1)                       |   r1 := initial size.\n      if (treg,r1,p)                     |   If value is non-zero.\n        st r1,pwa_sizeinit               |     Save in PWA.\n      endif                              |   EndIf.\n    endif                                | EndIf.\n*                                        |\n    if (tbit,fi_size_initial,x'80',on)   | If end of parms.\n     leave block=&s.optional_start_parms |  Done with parms.\n    endif                                | EndIf.\n*                                        |\n    l   r1,fi_size_increment             | r1 -> Increment size parm.\n    la  r1,0(,r1)                        | Toss high-order bit.\n    if  (treg,r1,p)                      | If still non-zero.\n      l  r1,0(,r1)                       |   r1 := increment size.\n      if (treg,r1,p)                     |   If value is non-zero.\n        st r1,pwa_sizeincr               |     Save in PWA.\n      endif                              |   EndIf.\n    endif                                | EndIf.\n*                                        |\n    if (tbit,fi_size_increment,x'80',on) | If end of parms.\n     leave block=&s.optional_start_parms |  Done with parms.\n    endif                                | EndIf.\n*   *-----------------------------------------------------------------*\n*   * Process REFERENCE string.\n*   *-----------------------------------------------------------------*\n    l   r1,fi_reference                  | r1 -> reference.\n    la  r1,0(,r1)                        | Discard high order bit.\n    if (treg,r1,nz)                      | If nonzero\n     mvc pwa_fi_reference,0(r1)          |   Save in PWA.\n     sbit pwa_2_reference_supplied       |   Set flag in pwa.\n    endif                                | EndIf.\n   endblk block=&s.optional_start_parms\n*  *------------------------------------------------------------------*\n*  * If neither avg or max specified, supply default values.  If only\n*  * one value supplied, use that same value for both avg and max.\n*  *------------------------------------------------------------------*\n   l  r2,pwa_avglrecl                    |  r2 := avg lrecl.\n   l  r3,pwa_maxlrecl                    |  r3 := max lrecl.\n   if (treg,r2,z),and,(treg,r3,z)        |  If neither parm specified.\n     mvc pwa_avglrecl,=f'80'             |    Default AvgLrecl = 80.\n     mvc pwa_maxlrecl,=f'251'            |    Default MaxLrecl = 251.\n   elseif (treg,r2,p),and,(treg,r3,z)    |  ElseIf only avg specified.\n     st  r2,pwa_maxlrecl                 |    Set maxlrecl = avglrecl.\n   elseif (treg,r2,z),and,(treg,r3,p)    |  ElseIf only max specified.\n     st  r3,pwa_avglrecl                 |    Set avglrecl = maxlrecl.\n   endif                                 |  EndIf.\n*  *------------------------------------------------------------------*\n*  * Use the avg and max lrecl values to determine the record\n*  * format of the output file.  If RECFM=V, add 4 to lrecls.\n*  *------------------------------------------------------------------*\n   l  r2,pwa_avglrecl                    |  r2 := avg lrecl.\n   l  r3,pwa_maxlrecl                    |  r3 := max lrecl.\n   if (cr,r2,eq,r3)                      |  If max lrecl = avg lrecl.\n     sbit  pwa_1_fb                      |    Force RECFM=F,\n   elseif (cr,r2,gt,r3)                  |  ElseIf Avg > max lrecl\n     callsub message,(fi00115,pwa_maxlrecl,pwa_avglrecl)\n     errexit code=0                      |\n   else                                  |  Else.\n     sbit  pwa_1_vb                      |    Force RECFM=V,\n     la    r2,4(,r2)                     |    Add 4 to avg lrecl.\n     st    r2,pwa_avglrecl               |\n     la    r3,4(,r3)                     |    Add 4 to max lrecl.\n     st    r3,pwa_maxlrecl               |\n   endif                                 |  EndIf.\n*  *------------------------------------------------------------------*\n*  * Extract information from supplied text-units.\n*  *------------------------------------------------------------------*\n   l32   r2,fi_info                  | Search caller's INFO list\n   if    (nz),and,(clc,=f'0',ne,0(r2)) If present and non-null.\n     loop until                      |   textunit pointers:\n       l  r1,0(r2)                   |\n       if (clc,0(2,r1),eq,=al2(dalvlser)) Is this VOLSER textunit?\n         lh    r15,4(r1)             |      Get volume's length\n         bctr  r15,0                 |      Set it up for EXECUTE\n         exi   r15,(mvc,pwa_volser(0),6(r1)) Copy volser to PWA\n       elseif (clc,0(2,r1),eq,=al2(dalsysou)) Is this SYSOUT textunit?\n         if (clc,2(2,r1),gt,=al2(0000))     if # not zero then\n           mvc pwa_sysoutclass,6(r1) |        copy sysout class char.\n         endif                       |      endif.\n       endif                         |     EndIf.\n       leave loop=*,(tbit,0(r2),x'80')     Leave if at final textunit.\n       la    r2,4(r2)                |     r2 -> Next entry.\n     endloop until,leave             |   EndLoop.\n   endif                             | EndIf.\n*  *------------------------------------------------------------------*\n*  * Create a better REFERENCE string if one was not supplied.\n*  *------------------------------------------------------------------*\n   if not,(tbit,pwa_2_reference_supplied)   | Ref not supplied\n     if (cli,pwa_oc2_sysoutx,eq,&fi_oc2_sysout) | If it is SYSOUT\n      mvc  pwa_fi_reference,=cl70\"a SYSOUT file\"\n     elseif (cli,pwa_oc_ident,eq,&fi_oc_fileid) | If its a DDNAME\n      l  r4,fi_filename          | R4 := file-specification's text.\n      l  r5,fi_namelength        | R5 -> length of file-specification.\n      fill  pwa_fi_reference,c' ' | Clear out the REFERENCE string.\n      st_format id=st,string=pwa_fi_reference,                         +\n               control='DDNAME {cl? caps trim}',                       +\n               source=(0(r4),0(r5))\n     elseif (cli,pwa_oc_ident,eq,&fi_oc_filename) | If its a FILENAME.\n      l  r4,fi_filename          | R4 := file-specification's text.\n      l  r5,fi_namelength        | R5 -> length of file-specification.\n      fill  pwa_fi_reference,c' ' | Clear out the REFERENCE string.\n      st_format id=st,string=pwa_fi_reference,                         +\n               control='{cl? caps trim}',source=(0(r4),0(r5))\n     elseif (cli,pwa_oc_filetempx,eq,&fi_oc_filetemp) If FILETEMP\n      mvc  pwa_fi_reference,=cl70\"a TEMPORARY DATASET\"\n     endif                                |\n   endif                                |\n*  *------------------------------------------------------------------*\n*  * Parse the file's name and allocate the file.\n*  *------------------------------------------------------------------*\n   callsub parse_filename            | If file name provided, get it.\n   callsub allocate_file             | Allocate the file now.\n*                                    |   If OPTION=LIBRARY:\n   if (cli,pwa_oc2_library,eq,&fi_oc2_library)\n     if (cli,pwa_member,ne,c\" \")     |     If member specified:\n       callsub message,(fi00037)     |      It is an error.\n       errexit code=0                |      Exit.\n     endif                           |     Endif.\n   endif                             |   Endif.\n*  *------------------------------------------------------------------*\n*  * If AUTOOPEN is in effect, open the file for INPUT/OUTPUT now.\n*  *------------------------------------------------------------------*\n   if (cli,pwa_oc_open,ne,&fi_oc_manualopen)  If OPEN=AUTO.\n     callsub open                        |      Open the data set.\n   endif                                 |    EndIf.\n*  callsub message,(fi00000)          | Successful completion.\n   slr  r15,r15\n endblk block=start\n                 swa\n&w.avg_rec_len   ds     f\n&w.max_rec_len   ds     f\n                 endswa\n eject\n***********************************************************************\n*                                                                     *\n*  Subroutine: TERMINATE                                              *\n*  Abstract:   Close out and cleanup any/all files.                   *\n*                                                                     *\n***********************************************************************\n block name=terminate,type=subroutine,amode=&srvfios_iosub_amode\n   if (tbit,pwa_1_open)                  | If file is open.\n     callsub close                       |   Close it.\n   endif                                 | EndIf.\n*---------------------------------------------------------------------*\n*  If we allocated to the data set ourselves, and AUTOFREE is in effect\n*  then free the data set.\n*---------------------------------------------------------------------*\n   if (cli,pwa_oc2_free,eq,&fi_oc2_autofree)\n     if (tbit,pwa_1_allocated),and,(clc,pwa_ddname,ne,=cl8' ')\n       if (tbit,pwa_2_free_on_terminate)\n         mvc &w.ddname,&s.ddname         | Initialize DDNAME text unit.\n         mvc (s99tupar-s99tunit)+&w.ddname(8),pwa_ddname\n         plist (&w.ddname),vl,pl=pwa_textunits\n         callsub dynalloc,               | Releasing allocated file.   +\n               (=al1(s99vrbun),          |   Unallocate function.      +\n               =al1(s99nomnt,0),0,       |   Request-block flags.      +\n               pwa_err_msg,              |   Return message area.      +\n               =a(l'pwa_err_msg),        |   Length of message area.   +\n               pwa_err_msg_len,          |   Length of returned msg.   +\n               pwa_textunits),vl         |   Free by DDNAME.\n       endif\n     endif\n   endif\n*---------------------------------------------------------------------*\n*  Terminate and unload the string handler.\n*---------------------------------------------------------------------*\n   if (clc,pwa_st_spepa,ne,=f'0')        | If string handler loaded.\n     if (clc,pwa_st_sptoken,ne,=f'0')    |   If string-handler started.\n       st_terminate id=st                |     Terminate it.\n     endif                               |   EndIf.\n     es_unload_module id=es,spid=st      |   Unload the String Handler.\n     mvc   pwa_st_spepa,=f'0'            |   Set EPA to zeros.\n   endif                                 | EndIf.\n*  callsub message,(fi00000)             | Successful completion.\n   slr  r15,r15\n endblk block=terminate\n*---------------------------------------------------------------------*\n*  Working storage for dynamic de-allocation of OS data sets.\n*---------------------------------------------------------------------*\n             ssd\n&s.ddname    text_unit dunddnam,CL8' '   | DDNAME=<blanks>\n             endssd\n             swa\n&w.ddname    ds      cl(l'&s.ddname)     |   DUN DDNAME Text unit.\n             endswa\n             eject\n***********************************************************************\n*                                                                     *\n*  Subroutine: OPEN_PARM                                              *\n*  Abstract  : Process the FI_OPEN parms.\n*                                                                     *\n***********************************************************************\n block name=open_parm,type=subroutine,amode=&srvfios_iosub_amode\n*---------------------------------------------------------------------*\n*  If Option is specified, process it.\n*---------------------------------------------------------------------*\n   mvi   pwa_oo_mode,&fi_oo_default   |     Assume defaulting.\n   if    (tbit,fi_functioncode,x'80',off)   If option parm is present.\n    l32   r2,fi_op_options            |      r2 -> options parm.\n    if    nz,then                     |      If a value was provided.\n     mvc   pwa_oo_mode,0(r2)          |       Save INPUT/OUTPUT flag.\n     ni    pwa_oo_mode,&fi_oo_mode    |       Mask off other bits.\n    endif                             |      Endif.\n   endif                              |     Endif.\n   if (cli,pwa_oo_mode,eq,&fi_oo_default)   If defaulting:\n     mvi   pwa_oo_mode,&fi_oo_input           Set OO_MODE\n     if (cli,pwa_oc_mode,eq,&fi_oc_output)    based on\n       mvi   pwa_oo_mode,&fi_oo_output        start\n     endif                            |       option.\n   endif                              |     Endif.\n endblk block=open_parm\n             eject\n***********************************************************************\n*                                                                     *\n*  Subroutine: OPEN                                                   *\n*  Abstract  : Open the file for processing.                          *\n*                                                                     *\n***********************************************************************\n block name=open,type=subroutine,amode=&srvfios_iosub_amode\n*  *------------------------------------------------------------------*\n*  * Ensure that the file is not already open and reset flags.\n*  *------------------------------------------------------------------*\n   if  (tbit,pwa_1_open)                 | If file already OPEN.\n     callsub message,(fi00126,\"already\",7)   Issue an error message\n     errexit code=0                      |   and exit w/ret-code.\n   endif                                 | EndIf.\n   rbit pwa_2_fios_supplies_dcb_attributes Reset flag.\n*  *------------------------------------------------------------------*\n*  * For CLEMSON only, determine if RACF will allow the OPEN.\n*  *------------------------------------------------------------------*\n     aif (not &security_check).skip3\n     if (cli,pwa_oo_mode,eq,&fi_oo_input)    If input mode.\n       callsub security_check,(\"READ\")   |     Check for READ access.\n     else                                |   Else.\n       callsub security_check,(\"UPDATE\") |     Check for UPDATE access.\n     endif                               |   EndIf.\n.skip3 anop\n*  *------------------------------------------------------------------*\n*  * For existing data sets, perform a number of checks to (1)\n*  * avoid destroying the file and (2) avoid any ABENDs.\n*  *------------------------------------------------------------------*\n   if (clc,=c'PO',ne,pwa_dsorg),and,(clc,=c'PS',ne,pwa_dsorg)\n     callsub message,(fi00101,pwa_dsorg,pwa_dsname)\n     errexit code=0\n   endif\n   if not,(tbit,pwa_1_ds_not_existing)   | If already existed.\n*    *----------------------------------------------------------------*\n*    * Read in the JFCB for the file and extract information from it.\n*    *----------------------------------------------------------------*\n     callsub read_jfcb                   |   Read PO or PS JFCB.\n     la      r8,pwa_jfcb                 |   r8 -> JFCB storage.\n     using   infmjfcb,r8                 |   Address the JFCB.\n     mvc     pwa_volser,jfcbvols         |   Extract data set VOLSER.\n     lh      r0,jfclrecl                 |   Extract data set LRECL\n     st      r0,pwa_lrecl                |      and save in PWA.\n     lh      r1,jfcblksi                 |   Extract data set BLKSIZE\n     st      r1,pwa_blksize              |      and save in PWA.\n     mvc     pwa_recfm,jfcrecfm          |   Extract data set RECFM.\n     if      (tbit,jfcbtsdm,jfcsds)      |   If SYSIN|SYSOUT data set.\n       sbit  pwa_2_sysinout              |     Indicate in PWA.\n     endif                               |   EndIf.\n*    *----------------------------------------------------------------*\n*    * Enforce data set/member replacement rules and ensure that the\n*    * data set organization is consistent with the specified name.\n*    *----------------------------------------------------------------*\n*                                        |   If option=LIBRARY:\n     if (cli,pwa_oc2_library,eq,&fi_oc2_library)\n       if (clc,=c'PO',ne,pwa_dsorg)      |     If not PO or POU:\n         callsub message,(fi00038)       |      It is an error.\n         errexit code=0                  |      Exit.\n       endif                             |     Endif.\n     elseif (cli,pwa_member,ne,c\" \")     |   Elseif MEMBER specified.\n       if (clc,=c'PO',ne,pwa_dsorg)      |     If DSORG \u00ac= PO or POU.\n         callsub message,(fi00108,pwa_dsname,pwa_member) Format msg.\n         errexit code=0                  |                 Exit w/rc.\n       endif                             |     EndIf.\n       if (cli,pwa_oc2_chkpdsmemx,eq,&fi_oc2_chkpdsmem)\n         callsub does_member_exist       |       See if member in PDS.\n         if      (treg,r15,z)            |       If so.\n           sbit  pwa_1,pwa_1_member      |         Flag for later.\n           if    (cli,pwa_oc_disp,eq,&fi_oc_new)   If NEW specified.\n             callsub message,(fi00117,pwa_member,pwa_dsname) \u00acREPLACE.\n             errexit code=0              |           Exit w/error code.\n           endif                         |         EndIf.\n         else                            |       Else, member \u00acthere.\n           if (cli,pwa_oc_disp,eq,&fi_oc_existing) If EXISTING spec'd.\n             callsub message,(fi00104,pwa_member,pwa_dsname)\n             errexit code=0              |           Exit w/error code.\n           endif                         |         EndIf.\n         endif                           |       EndIf.\n       endif                             |     EndIf.\n     else                                |   Else.\n       if (cli,pwa_oc_disp,eq,&fi_oc_new)      If NEW was specified.\n         callsub message,(fi00128,pwa_dsname)    \u00acREPLACE.\n         errexit code=0                  |       Exit w/error code.\n       endif                             |     EndIf.\n       if (clc,=c'PO',eq,pwa_dsorg)      |     If DSORG = PO or POU.\n         callsub message,(fi00103,pwa_dsname)    Member required.\n         errexit code=0                  |       Exit w/return-code.\n       endif                             |     EndIf.\n     endif                               |   EndIf.\n*    *----------------------------------------------------------------*\n*    *\n*    * If performing OUTPUT to a DDNAME, abends (013-34's, etc) may\n*    * occur due to improperly coded or missing DCB attributes.  This\n*    * section of code attempts to detect certain *missing* DCB\n*    * attributes and supply reasonable defaults for them.  It does not\n*    * check specified (non-missing) attributes for validity.\n*    * This code only applies to DISP=NEW data sets, except as noted\n*    * below for sysout files.\n*    *\n*    *----------------------------------------------------------------*\n*    *\n*    * DSC - When read-jfcb is used on a SYSOUT file, the returned DCB\n*    * attributes for LRECL and BLKSIZE may be incorrect.  For example,\n*    * one experiment in interactive TEST resulted in\n*    * RECFM=VB,LRECL=240,BLKSIZE=240 (lrecl cannot equal blksize for\n*    * VB datasets....abend 013-34).  The values coded on the DD\n*    * statement for that experiment had a much higher BLKSIZE that was\n*    * replaced by some component...presumably JES.  Since the output\n*    * records will be stored the same regardless of the DCB attributes\n*    * used (they go to spool), this code always overrides the DCB\n*    * ---- changed, was RECFM=VB,LRECL=32756,BLKSIZE=32760 ---- mgg\n*    * attributes for SYSOUT data sets to:\n*    *   RECFM=F|FA,LRECL=pwa_maxlrecl,BLKSIZE=pwa_maxlrecl or\n*    *   RECFM=V|VA,LRECL=pwa_maxlrecl,BLKSIZE=pwa_maxlrecl+4\n*    * depending on whether variable and/or IOSCC was requested.\n*    *\n*    *----------------------------------------------------------------*\n     if (cli,pwa_oo_mode,eq,&fi_oo_output)   If OUTPUT file.\n       if (tbit,pwa_2_sysinout)          |     If SYSOUT file.\n         sbit pwa_2_fios_supplies_dcb_attributes Indicate supplied.\n         l    r1,pwa_maxlrecl            |       Set LRECL to maximum\n         st   r1,pwa_lrecl               |       LRECL.\n         if (tbit,pwa_1_fb)              |       If fixed requested:\n          mvi  pwa_recfm,dcbrecf         |         Force RECFM=F.\n         else                            |       Else:\n          mvi  pwa_recfm,dcbrecv         |         Force RECFM=V.\n          la   r1,4(,r1)                 |         BLKSIZE+=4.\n         endif                           |       Endif.\n         st   r1,pwa_blksize             |       Store BLKSIZE.\n         if (cli,pwa_oc2_cc,eq,&fi_oc2_isocc)    If ISOCC requested:\n           sbit  pwa_recfm,dcbrecca      |        Indicate in RECFM.\n         endif                           |       Endif.\n       elseif (cli,pwa_oc_ident,eq,&fi_oc_fileid), If DDname alloc'd   +\n               and,(tbit,jfcbind2,jfcnew,on)   Elseif FILEID and NEW:\n         sbit pwa_2_fios_supplies_dcb_attributes Indicate supplied.\n         l  r1,pwa_lrecl                 |  R1  := existing LRECL.\n         l  r15,pwa_blksize              |  R15 := existing BLKSIZE.\n         if (treg,r1,z),and,(treg,r15,z),   If neither specified, and  +\n               and,(tbit,pwa_recfm,dcbrecf+dcbrecv,ON)   RECFM=U then\n             mvi  pwa_recfm,x'00'        |    Assume RECFM \u00acspecified.\n         endif                           |  EndIf.\n*                                        |\n         if (cli,pwa_recfm,eq,x'00')     |  If no RECFM value.\n           if (tbit,pwa_1_vb)            |    If caller requested VB\n             sbit  pwa_recfm,dcbrecv+dcbrecbr   Make note in RECFM\n           elseif (tbit,pwa_1_fb)        |    ElseIf caller wants FB.\n             sbit  pwa_recfm,dcbrecf+dcbrecbr   Make note of FB.\n           elseif (tbit,pwa_2_sysinout)  |    ElseIf SYSINOUT file.\n             sbit  pwa_recfm,dcbrecv+dcbrecbr   Default to VB.\n           else                          |    Else\n             sbit  pwa_recfm,dcbrecf+dcbrecbr   Default to FB.\n           endif                         |    EndIf.\n           if (cli,pwa_oc2_cc,eq,&fi_oc2_isocc) If ISOCC requested:\n             sbit  pwa_recfm,dcbrecca    |     Indicate in RECFM.\n           endif                         |    Endif.\n         endif                           |  EndIf.\n*                                        |\n         if (treg,r15,z)                 |  If BLKSIZE missing.\n           lh  r15,=h'11476'             |    Assume BLKSIZE= 1/4 track\n           if (tbit,pwa_recfm,dcbrecf)   |    If RECFM=F\n             if  (treg,r1,z)             |      If LRECL missing.\n               l  r1,pwa_avglrecl        |        Choose LRECL value.\n               st r1,pwa_lrecl           |        Set chosen LRECL.\n             endif                       |      EndIf.\n             if (tbit,pwa_recfm,dcbrecbr,OFF)   If not blocked.\n               lr r15,r1                 |        BLKSIZE = LRECL.\n             elseif (cr,r1,gt,r15)       |        ElseIf LRECL>BLKSIZE.\n               lr r15,r1                 |        BLKSIZE = LRECL.\n             else                        |      Else.\n               xr r14,r14                |        Adjust BLKSIZE to\n               dr r14,r1                 |        an even multiple of\n               xr r14,r14                |        LRECL.\n               mr r14,r1                 |\n             endif                       |      EndIf.\n           else                          |    Else, RECFM = V.\n             if  (treg,r1,z)             |      If LRECL missing.\n               l  r1,pwa_maxlrecl        |        Choose LRECL value.\n               st r1,pwa_lrecl           |        Set chosen LRECL.\n             elseif (cr,r1,gt,r15)       |        ElseIf LRECL>BLKSIZE.\n               la r15,4(,r1)             |        BLKSIZE = LRECL+4.\n             endif                       |      EndIf.\n             if (tbit,pwa_recfm,dcbrecbr,OFF),or,(cr,r1,gt,r15)\n               la r15,4(,r1)             |        BLKSIZE = LRECL+4.\n             endif                       |      EndIf.\n           endif                         |    EndIf.\n           st r15,pwa_blksize            |    Save chosen BLKSIZE.\n         elseif (treg,r1,z)              |  ElseIf LRECL missing.\n           if (tbit,pwa_recfm,dcbrecf)   |    If RECFM=F\n             l  r1,pwa_avglrecl          |      Choose LRECL value.\n             if (tbit,pwa_recfm,dcbrecbr,OFF),or,(cr,r1,gt,r15)\n               lr  r1,r15                |        Use LRECL=BLKSIZE.\n             else                        |      Else.\n               xr r14,r14                |        Divide BLKSIZE by\n               dr r14,r1                 |        chosen LRECL value.\n               if (treg,r14,nz)          |        If \u00aceven multiple.\n                 callsub message,(fi00125,pwa_blksize,pwa_avglrecl)\n                 errexit code=0          |          Exit w/ret-code.\n               endif                     |        EndIf.\n             endif                       |      EndIf.\n           else                          |    Else, RECFM = VB.\n             l  r1,pwa_maxlrecl          |      Choose LRECL value.\n             s  r15,=f'4'                |\n             if (tbit,pwa_recfm,dcbrecbr,OFF),or,(cr,r1,gt,r15)\n               lr r1,r15                 |        LRECL = BLKSIZE-4.\n             endif                       |      EndIf.\n           endif                         |    EndIf.\n           st  r1,pwa_lrecl              |    Save as pwa_lrecl.\n         endif                           |   EndIf.\n       endif                             |   Not using OPTION FILEID.\n     endif                               |  EndIf.\n*    *----------------------------------------------------------------*\n   endif  <Checks on existing datasets>  | EndIf.\n   drop    r8                            | Drop the JFCB.\n*  *------------------------------------------------------------------*\n*  * Open for sequential INPUT or sequential OUTPUT.\n*  *------------------------------------------------------------------*\n   la    r8,pwa_dcb                      | Base on working DCB\n   using ihadcb,r8                       | Get addressability.\n   if (cli,pwa_oo_mode,eq,&fi_oo_input)  | If INPUT access mode.\n     if (cli,pwa_oc2_library,eq,&fi_oc2_library)\n       mvc   pwa_podcb,psd_podcb         |  Use BPAM DCB.\n     else                                | Else:\n       mvc   pwa_gldcb,psd_gldcb         |  Use get-locate DCB\n     endif                               | Endif.\n     la    r0,pwa_dcbe                   | Put address of\n     st    r0,pwa_dcb+dcbdcbe-ihadcb     | DCBE in DCB.\n     mvc   dcbddnam,pwa_ddname           |   Set DDname in working DCB\n     mvc   pwa_open,psd_open             |   Copy OPEN's parmlist.\n     block amode=&srvfios_iocall_amode   |\n       open  (pwa_dcb,input),mf=(e,pwa_open),  Open for INPUT.         +\n               mode=&srvfios_open_mode   |\n       lr    r5,r15                      |     Save return-code.\n     endblk                              |\n   else                                  | Else, OUTPUT access mode.\n     if (cli,pwa_member,ne,c' ')         |   If writing to a member.\n       callsub spfedit_enq,(pwa_dsname,pwa_member) Enqueue on member.\n       if      (treg,r15,nz)             |           If in-use.\n         st   r15,pwa_save_r15           | Preserve r15 for errexit\n         callsub message,(fi00119,pwa_member)          Error msg.\n         l    r15,pwa_save_r15           | Rest r15 for debug analysis\n         errexit code=0                  |             Exit w/ret-code.\n       endif                             |           EndIf.\n     endif                               |   EndIf.\n     mvc   pwa_pldcb,psd_pldcb           |   Use PUT-Locate DCB.\n     la    r0,pwa_dcbe                   |   Put address of\n     st    r0,pwa_dcb+dcbdcbe-ihadcb     |   DCBE in DCB.\n     if (tbit,pwa_2_fios_supplies_dcb_attributes)\n       l     r1,pwa_lrecl                |   Include derived LRECL,\n       sth   r1,dcblrecl                 |   BLKSIZE and RECFM in\n       l     r1,pwa_blksize              |   DCB being built.\n       sth   r1,dcbblksi                 |\n       mvc   dcbrecfm,pwa_recfm          |\n     endif                               |\n     mvc   dcbddnam,pwa_ddname           |   Set DDname in working DCB.\n     mvc   pwa_open,psd_open             |   Copy OPEN's parmlist.\n     block amode=&srvfios_iocall_amode   |\n       if (cli,pwa_oc_disp,eq,&fi_oc_append) If APPEND option.\n         open (pwa_dcb,extend),mf=(e,pwa_open), Open for EXTEND.       +\n               mode=&srvfios_open_mode   |\n       else                              |    Else.\n         open (pwa_dcb,output),mf=(e,pwa_open), Open for OUTPUT.       +\n               mode=&srvfios_open_mode   |\n       endif                             |    Endif.\n       lr    r5,r15                      |      Save return-code.\n     endblk                              |\n   endif                                 | EndIf.\n*  *------------------------------------------------------------------*\n*  * Check to see if OPEN succeeded and if RECFM supported.\n*  *------------------------------------------------------------------*\n   if (treg,r5,nz)                       | If OPEN failed.\n     st   r15,pwa_save_r15               | Preserve r15 for errexit\n     callsub message,(fi00102,pwa_dsname)    Format error message.\n     l    r15,pwa_save_r15               | Rest r15 for debug analysis\n     errexit code=0                      |   Exit w/return-code.\n   endif                                 | EndIf.\n   sbit    pwa_1,pwa_1_open              | Indicate past open.\n*                                        |\n   if not,(tbit,dcbrecfm,dcbrecu,mixed)  | If not FIXED or VARYING.\n     callsub message,(fi00107)           |   Issue error msg.\n     errexit code=0                      |   Exit w/ret-code.\n   endif                                 | EndIf.\n*                                        |\n   l16   r1,dcblrecl                     | r1 := actual LRECL.\n   st    r1,pwa_lrecl                    | Save as a fullword.\n   mvc   pwa_recfm,dcbrecfm              | Copy actual RECFM.\n*  *------------------------------------------------------------------*\n*  * If OPTION=LIBRARY, BPAM is used.  Get a buffer for for DECBs and\n*  * and maximum blocks.\n*  *------------------------------------------------------------------*\n   if (cli,pwa_oc2_library,eq,&fi_oc2_library)\n*   *-----------------------------------------------------------------*\n*   * Get storage for buffer entries (BENT).\n*   *-----------------------------------------------------------------*\n    lh    r1,dcbblksi                 |  Calculate size\n    sm_ahi r1,bent_fixed_len+7        |  of one buffer entry\n    srl   r1,3                        |  rounded up to\n    sll   r1,3                        |  a multiple of 8.\n    st    r1,pwa_bent_size            |  Save it.\n    l8    r15,dcbncp                  |  Calculate size\n    sth   r15,pwa_bent_count          |  of buffer needed\n    mh    r1,pwa_bent_count           |  for dcbncp buffer\n    st    r1,pwa_bent_buffer_size     |  entries.\n    es_obtain_storage id=es,          |  Get storage for               +\n               location=below,        |  all buffer entries.           +\n               size=pwa_bent_buffer_size,                              +\n               address=pwa_bent_buffer_address\n    if not,(%es_success)              |  If not successful:\n     st    r15,&w.rc                  |\n     callsub message,(fi00010,&w.rc)  |   Save error message.\n     errexit code=0                   |   Exit.\n    endif                             |  Endif.\n*   *-----------------------------------------------------------------*\n*   * Link buffer entries into a circular list.\n*   *-----------------------------------------------------------------*\n    lh    r15,pwa_bent_count          |  r15 = buffer entry count.\n    l     r1,pwa_bent_buffer_address  |  r1 -> first buffer entry.\n    using bent_start,r1               |  Establish base for entry.\n    loop until                        |  Loop chaining entries.\n      sm_decr r15                     |   Decrement count.\n      if np                           |   If last one:\n       l     r0,pwa_bent_buffer_address    Point it back to\n       st    r0,bent_next             |    first entry.\n       leave loop=*                   |    Leave loop.\n      else                            |   Else:\n       lr    r0,r1                    |    Point r0 to\n       al    r0,pwa_bent_size         |    next entry.\n       st    r0,bent_next             |    Save it in this entry.\n       lr    r1,r0                    |    Make next entry the current.\n      endif                           |   Endif.\n    endloop until,leave               |  Endloop.\n    drop   r1                         |  Drop base for entry.\n*   *-----------------------------------------------------------------*\n   endif                              | Endif.\n*  *------------------------------------------------------------------*\n   drop r8                               | Drop addressability.\n*  callsub message,(fi00000)             | Successful completion.\n   slr  r15,r15\n endblk block=open\n          swa\n&w.rc     ds  f\n          endswa\n          eject\n***********************************************************************\n*                                                                     *\n*  Subroutine: CLOSE                                                  *\n*  Abstract  : Close the file without terminating.                    *\n*                                                                     *\n***********************************************************************\n block name=close,type=subroutine,amode=&srvfios_iosub_amode\n   if  (tbit,pwa_1_open,OFF)            | If file is not OPEN.\n     callsub message,(fi00126,\"not\",3)   |   Issue an error message\n     errexit code=0                      |   and exit w/ret-code.\n   endif                                 | EndIf.\n*---------------------------------------------------------------------*\n*  If the data set is currently OPEN, close it and free its buffers.\n*---------------------------------------------------------------------*\n   la    r8,pwa_dcb                   | Establish addressability on\n   using ihadcb,r8                    |   the OS Data Control Block.\n   if (tbit,pwa_1_open),then\n     block type=inline,amode=&srvfios_iocall_amode\n       plist (pwa_dcb),vl             |     Set parms in working stg.\n       close (pwa_dcb),mf=(e,(1)),    |     Close the file.            +\n               mode=&srvfios_open_mode\n       rbit   pwa_1,pwa_1_open        |     Reset OPEN flag.\n       rbit   pwa_1,pwa_1_eof         |     Reset EndOfFile flag.\n       callsub free_buffer_pool,(pwa_dcb)   Free DCB's buffer pool\n     endblk                           |\n   endif                              |\n   if (tbit,pwa_2_member_enq)         | if spfedit enq was done\n     callsub spfedit_deq,             |        Undo it.                +\n               (pwa_dsname,pwa_member)\n   endif                              |\n*---------------------------------------------------------------------*\n*  Free buffer entries buffer.\n*---------------------------------------------------------------------*\n  if (clc,pwa_bent_buffer_address,ne,=f'0')  If buffer obtained:\n    es_release_storage id=es,         |        Release it.             +\n               size=pwa_bent_buffer_size,                              +\n               address=pwa_bent_buffer_address\n    if not,(%es_success)              |        If release failed:\n     st    r15,&w.rc                  |\n     callsub message,(fi00043,&w.rc)  |         Save message.\n     errexit code=0                   |         Exit.\n    endif                             |        Endif.\n    fill   pwa_bent_buffer_size       |        Clear size and\n    fill   pwa_bent_buffer_address    |        address fields.\n   endif                              |      Endif.\n*---------------------------------------------------------------------*\n*  callsub message,(fi00000)             | Successful completion.\n   slr  r15,r15\n endblk block=close\n          swa\n&w.rc     ds    f\n          endswa\n          eject\n***********************************************************************\n*                                                                     *\n*  Subroutine: DELETE                                                 *\n*  Abstract  : Delete the sequential data set or PDS member.          *\n*                                                                     *\n*  Note: If the data set or member is enqueued on (in-use) when this  *\n*        function is invoked, it will fail.  We could add a WAIT      *\n*        option to get around this.                                   *\n*                                                                     *\n***********************************************************************\n block name=delete,type=subroutine,amode=&srvfios_iosub_amode\n   if (tbit,pwa_1_open)                  | If file is open.\n     callsub close                       |   Close it.\n   endif                                 | EndIf.\n*---------------------------------------------------------------------*\n*  Handle the delete function for a PDS member.\n*---------------------------------------------------------------------*\n   if (clc,=c'PO',eq,pwa_dsorg)          | If deleting a member.\n     callsub read_jfcb                   |   Read in PDS's JFCB.\n     aif (not &security_check).skip1\n     callsub security_check,(\"UPDATE\")   |   Check RACF access.\n.skip1 anop\n     callsub spfedit_enq,(pwa_dsname,pwa_member) Enqueue on member.\n     if (treg,r15,nz)                    |   If in-use.\n       st   r15,pwa_save_r15             | Preserve r15 for errexit\n       callsub message,(fi00119,pwa_member)    Error msg.\n       l    r15,pwa_save_r15             | Rest r15 for debug analysis\n       errexit code=0                    |     Exit w/ret-code.\n     endif                               |   EndIf.\n     la    r8,pwa_dcb                    |   r8 -> PO DCB to use.\n     using ihadcb,r8                     |   Establish addressability.\n     la    r7,pwa_jfcb                   |   r7 -> our copy of JFCB.\n     using infmjfcb,r7                   |   Establish addressability.\n     mvc   jfcbelnm,=cl8' '              |   Clear the member name.\n     mvc   pwa_open,psd_open             |   Copy OPEN plist to PWA.\n     block amode=&srvfios_iocall_amode   |\n       open  (pwa_dcb,output),type=j,mf=(e,pwa_open),                  +\n               mode=&srvfios_open_mode   |\n     endblk                              |\n     if (tbit,dcboflgs,dcbofopn,off)     |   If OPEN failed.\n       callsub message,(fi00102,pwa_dsname)    Issue an error message.\n       errexit code=0                    |     Exit with error-code.\n     endif                               |   Endif.\n     block amode=&srvfios_iocall_amode   |\n       stow    pwa_dcb,pwa_member,d      |     Delete the member.\n       st      r15,&w.stow_rc            |     Save return-code.\n       plist   (pwa_dcb),vl              |     Set plist in pwa.\n       close   (pwa_dcb),mf=(e,(1)),     |     Close PO DCB.           +\n               mode=&srvfios_open_mode   |\n       callsub free_buffer_pool,(pwa_dcb)      Free its buffer pool.\n     endblk                              |\n     drop    r8,r7                       |   Drop DCB, JFCB addressing.\n     callsub spfedit_deq                 |   Remove the enqueue.\n     mvc &w.ddname,&s.ddname             |   Use DDNAME allocated to.\n     mvc &w.unalloc,&s.unalloc           |   Set up UNALLOC text unit.\n     mvc (s99tupar-s99tunit)+&w.ddname(8),pwa_ddname\n     plist (&w.ddname,&w.unalloc),vl,pl=pwa_textunits\n     callsub dynalloc,                   |   Free allocated file.      +\n               (=al1(s99vrbun),          |   Unallocate function.      +\n               =al1(s99nomnt,0),0,       |   Request-block flags.      +\n               pwa_err_msg,              |   Return message area.      +\n               =a(l'pwa_err_msg),        |   Length of message area.   +\n               pwa_err_msg_len,          |   Length of returned msg.   +\n               pwa_textunits),vl         |   Free by DDNAME.\n     rbit      pwa_1,pwa_1_allocated         Reset allocated flag.\n     rbit      pwa_2,pwa_2_free_on_terminate\n     errexit (treg,r15,nz),code=0        |   If failure, exit w/code.\n     l  r15,&w.stow_rc                   |   Pick up STOW's ret-code.\n     st   r15,pwa_save_r15               | Preserve r15 for errexit\n     if (treg,r15,z)                     |   If DELETE successful.\n       callsub message,(fi00301,pwa_member,\"deleted \",pwa_dsname)\n     elseif (c,r15,eq,=f'8')             |   ElseIf member not found.\n       callsub message,(fi00104,pwa_member,pwa_dsname)\n     else                                |   Else, DELETE failed.\n       callsub message,(fi00127,pwa_member,pwa_dsname,&w.stow_rc)\n     endif                               |   EndIf.\n     l    r15,pwa_save_r15               | Rest r15 for debug analysis\n     errexit code=0                      |   Exit with return-code.\n   endif                                 | EndIf.\n   eject\n*---------------------------------------------------------------------*\n*  Handle the delete function for a sequential data set.\n*---------------------------------------------------------------------*\n   aif (not &security_check).skip2\n   callsub security_check,(\"ALTER\")      | Check RACF access.\n.skip2 anop\n*\n*  If (allocated & \u00ac(SHR | PASS)) then override to DELETE and free it.\n*\n   if (tbit,pwa_1_allocated),and,                         If allocated +\n               (cli,pwa_status,ne,pwa_status_shr),and,      and \u00acSHR   +\n               (cli,pwa_ndisp,ne,pwa_ndisp_pass)            and \u00acPASS.\n     mvc &w.ddname,&s.ddname             |   Use DDNAME allocated to.\n     mvc (s99tupar-s99tunit)+&w.ddname(8),pwa_ddname\n     mvc &w.ndisp_delete,&s.ndisp_delete |\n     mvc &w.unalloc,&s.unalloc           |\n     plist (&w.ndisp_delete,&w.ddname,&w.unalloc),vl,pl=pwa_textunits\n     callsub dynalloc,                   |   Free allocated file.      +\n               (=al1(s99vrbun),          |   Unallocate function.      +\n               =al1(s99nomnt,0),0,       |   Request-block flags.      +\n               pwa_err_msg,              |   Return message area.      +\n               =a(l'pwa_err_msg),        |   Length of message area.   +\n               pwa_err_msg_len,          |   Length of returned msg.   +\n               pwa_textunits),vl         |   Textunits\n     if    (treg,r15,z)                  |   If successful, then.\n       st   r15,pwa_save_r15             | Preserve r15 for errexit\n       rbit    pwa_1,pwa_1_allocated           Reset allocated flag.\n       callsub message,(fi00300,pwa_dsname,,0,=cl8\" \",,0,\"deleted \")\n       l    r15,pwa_save_r15             | Rest r15 for debug analysis\n       errexit code=0                    |     Exit w/return-code.\n     else                                |   Else.\n       rbit    pwa_1,pwa_1_allocated           Reset allocated flag.\n       rbit    pwa_2,pwa_2_free_on_terminate\n     endif                               |   EndIf.\n   endif                                 | EndIf.\n*---------------------------------------------------------------------*\n*  If still allocated to dataset, free it.\n*---------------------------------------------------------------------*\n   if (tbit,pwa_1_allocated)            | If allocated to dataset.\n     mvc &w.ddname,&s.ddname             |   Use DDNAME allocated to.\n     mvc (s99tupar-s99tunit)+&w.ddname(8),pwa_ddname\n     plist (&w.ddname),vl,pl=pwa_textunits\n     callsub dynalloc,                   |   Free allocated file.      +\n               (=al1(s99vrbun),          |   Unallocate function.      +\n               =al1(s99nomnt,0),0,       |   Request-block flags.      +\n               pwa_err_msg,              |   Return message area.      +\n               =a(l'pwa_err_msg),        |   Length of message area.   +\n               pwa_err_msg_len,          |   Length of returned msg.   +\n               pwa_textunits),vl         |   Free by DDNAME.\n     rbit      pwa_1,pwa_1_allocated         Reset allocated flag.\n     rbit      pwa_2,pwa_2_free_on_terminate\n     errexit (treg,r15,nz),code=0        |   If failure, exit w/code.\n   endif                                 | EndIf.\n   eject\n*---------------------------------------------------------------------*\n*  Allocate to the dataset with (OLD,DELETE) and free it.\n*---------------------------------------------------------------------*\n   rbit    pwa_1,pwa_1_ds_not_existing     Reset ds-not-existing flag.\n   mvc     &w.dsname,&s.dsname           | Copy DSNAME text unit.\n   mvc     &w.ret_ddname,&s.ret_ddname   | Copy retrun DDNAME t.u.\n   mvc     s99tupar-s99tunit+&w.dsname(44),pwa_dsname\n   mvc     &w.stat_old,&s.stat_old       |\n   mvc     &w.disp_delete,&s.disp_delete |\n   plist (&w.ret_ddname,&w.dsname,&w.stat_old,&w.disp_delete),vl,      +\n               pl=pwa_textunits\n   callsub dynalloc,                     | Allocate to the dataset...  +\n               (=al1(s99vrbal),          |     Using DSNAME allocation.+\n               =al1(s99nomnt,0),         |     nomount,         @CNENQ +\n               =al4(0),                  |     No authorized flags.    +\n               pwa_err_msg,              |     Return message area.    +\n               =a(l'pwa_err_msg),        |     Length of message area. +\n               pwa_err_msg_len,          |     Length of returned msg. +\n               pwa_textunits),vl         |     TextUnits\n   errexit (treg,r15,nz),code=0          | If failure, exit w/code.\n   mvc     pwa_ddname,s99tupar-s99tunit+&w.ret_ddname\n*                                        |\n   mvc &w.ddname,&s.ddname               | Use DDNAME allocated to.\n   mvc (s99tupar-s99tunit)+&w.ddname(8),pwa_ddname\n   mvc &w.unalloc,&s.unalloc             |\n   plist (&w.ddname,&w.unalloc),vl,pl=pwa_textunits\n   callsub dynalloc,                     | Free allocated file.        +\n               (=al1(s99vrbun),          |   Unallocate function.      +\n               =al1(s99nomnt,0),0,       |   Request-block flags.      +\n               pwa_err_msg,              |   Return message area.      +\n               =a(l'pwa_err_msg),        |   Length of message area.   +\n               pwa_err_msg_len,          |   Length of returned msg.   +\n               pwa_textunits),vl         |     TextUnits\n   errexit (treg,r15,nz),code=0          | If failure, exit w/code.\n   rbit    pwa_1,pwa_1_allocated         | Reset allocated flag.\n   rbit    pwa_2,pwa_2_free_on_terminate\n   callsub message,(fi00300,pwa_dsname,,0,=cl8\" \",,0,\"deleted \")\n endblk block=delete\n*---------------------------------------------------------------------*\n*  Storage for dynamic de-allocation of OS data sets.\n*---------------------------------------------------------------------*\n                ssd\n&s.ndisp_delete text_unit dunovdsp,x'04'    Override NDISP=DELETE.\n&s.unalloc      text_unit dununalc          Force unallocation.\n&s.dsname       text_unit dundsnam,cl44\" \"  dsname=<blanks>\n&s.ddname       text_unit dunddnam,cl8\" \"   ddname=<blanks>\n&s.stat_old     text_unit dalstats,x'01'    DISP=OLD,\n&s.disp_delete  text_unit dalndisp,x'04'         DELETE)\n&s.ret_ddname   text_unit dalrtddn,cl8\" \"   Return-DDNAME.\n                endssd\n                swa\n&w.ddname       ds        cl(l'&s.ddname)\n&w.dsname       ds        cl(l'&s.dsname)\n&w.ret_ddname   ds        cl(l'&s.ret_ddname)\n&w.unalloc      ds        cl(l'&s.unalloc)\n&w.stat_old     ds        cl(l'&s.stat_old)\n&w.disp_delete  ds        cl(l'&s.disp_delete)\n&w.ndisp_delete ds        cl(l'&s.ndisp_delete)\n&w.stow_rc      ds        f\n                endswa\n                eject\n***********************************************************************\n*                                                                     *\n*  Subroutine: READLINE                                               *\n*  Abstract:   Obtain the next line from an already open file.        *\n*                                                                     *\n***********************************************************************\n block name=readline,type=subroutine,                                  +\n               amode=&srvfios_iosub_amode\n* *-------------------------------------------------------------------*\n* * Insure that attempting to read the next sequential line is an okay\n* * thing to do, considering the current type and status of the file\n* * and the access mode requested when the file was opened.  The error\n* * status flag has already been checked, at the beginning of the main\n* * routine.\n* *-------------------------------------------------------------------*\n  if (tbit,pwa_1_open,off)\n   callsub message,(fi00114,\"READLINE\",8)\n   errexit code=0\n  elseif (tbit,pwa_1_eof)\n   callsub message,(fi00200)            | Build end-of-file message.\n   errexit code=&fi_end_of_file         | Exit w/eof return code.\n  elseif (cli,pwa_oo_mode,ne,&fi_oo_input)\n   callsub message,(fi00008)\n   errexit code=0\n  elseif (tbit,pwa_2_ascii)\n   callsub message,(fi00044)\n   errexit code=0\n  endif\n* *-------------------------------------------------------------------*\n* * Get the next record.\n* *-------------------------------------------------------------------*\n  la    r8,pwa_dcb                      |\n  using ihadcb,r8                       |\n  if (cli,pwa_oc2_library,eq,&fi_oc2_library),                         +\n               name=get_record          | If OPTION=LIBRARY:\n   if        not,(tbit,pwa_2_valid_find_active)\n    callsub message,(fi00039)           |  Find required.\n    errexit code=0                      |\n   endif                                |\n   l32   r0,pwa_bent_current_remaining  |  r0 = residual in block.\n   if np                                |  If none left:\n    l     r2,pwa_bent_current           |   Establish base\n    using bent_start,r2                 |   for BENT.\n    l     r2,bent_next                  |   Make next BENT\n    st    r2,pwa_bent_current           |   the current one.\n    block amode=&srvfios_iocall_amode   |\n     check bent_decb                    |   Check for complete.\n    endblk                              |\n    leave (tbit,pwa_1_eof),if=get_record    Leave if EOF.\n    lh    r0,dcbblksi                   |   Calculate\n    l     r1,bent_decb+16               |   size of\n    sh    r0,14(,r1)                    |   block read.\n    st    r0,pwa_bent_current_remaining |   Set this as size remaining.\n    la    r1,bent_data_start            |   r1 -> first record in blk.\n    st    r1,pwa_bent_current_cursor    |   Set this as cursor.\n    drop  r2                            |   Drop base for bent.\n   else                                 |  Else:\n    l     r1,pwa_bent_current_cursor    |   r1 -> next record in blk.\n   endif                                |  Endif.\n  else                                  | Else:\n   block amode=&srvfios_iocall_amode    |\n    get   (r8)                          |  GET it.  R1 -> the record.\n   endblk                               |\n  endif                                 | Endif\n  errexit (tbit,pwa_1_error),code=&fi_severe\n  if    (tbit,pwa_1_eof)                | If at end of file\n   callsub message,(fi00200)            |  Build end-of-file message.\n   errexit code=&fi_end_of_file         |  Exit w/return-code\n  endif                                 | EndIf\n  st r1,&w.newrec                       | Save start of new record.\n\n* *-------------------------------------------------------------------*\n* * Set R4/R5 = Address/Length of the current logical record.\n* *-------------------------------------------------------------------*\n  lr r4,r1                              | Address of new record\n  xr r5,r5                              | R5 := length of record.\n  if (tbit,dcbrecfm,dcbrecf)            | If fixed-length records.\n   if (tbit,dcbrecfm,dcbrecbr)          |  If blocked records.\n     icm r5,b'0011',dcblrecl            |   R5 := length of record.\n   else                                 |   Else.\n     icm r5,b'0011',dcbblksi            |     R5 := length of block.\n   endif                                |   EndIf.\n   la   r6,0(r5,r4)                     |   R6 -> Past end of record.\n   s    r6,=f'8'                        |   R6 -> Last eight chars.\n   lr   r0,r5                           |   R0 := data length.\n  else                                  | Else variable-length records.\n   icm  r5,b'0011',0(r4)                |   R5 := length of record.\n   lr   r0,r5                           |   R0 := data length.\n   sh   r5,=h'4'                        |   Subtract the RDW's length.\n   la   r4,4(,r4)                       |   R4 -> logical rec's data.\n   lr   r6,r4                           |   R6 -> First eight chars.\n  endif                                 | EndIf.\n  if (cli,pwa_oc2_library,eq,&fi_oc2_library)\n   l     r15,pwa_bent_current_cursor    |\n   ar    r15,r0                         |\n   st    r15,pwa_bent_current_cursor    |\n   l     r15,pwa_bent_current_remaining |\n   sr    r15,r0                         |\n   st    r15,pwa_bent_current_remaining |\n  endif                                 | EndIf.\n*---------------------------------------------------------------------*\n*  Copy the current line to the caller's storage area\n*  --OR-- return the current line's address (including RDW)\n*---------------------------------------------------------------------*\n   l  r14,fi_functioncode           | If doing readline_locate\n   if (clc,=a(&fi_readline_locate),eq,0(r14))\n    l   r14,fi_rll_address          |  Return beginning of entire\n    mvc 0(4,r14),&w.newrec          |  line (w/RDW) to caller.\n   else                             | Else, readline with move.\n    l   r14,fi_rl_area              |  R14 -> target area.\n    l   r6,fi_rl_length             |  R6  -> length to return.\n    l   r15,fi_rl_area_size         |  R15 -> length of target.\n    l   r15,0(r15)                  |  R15 := length of target.\n    if  (cr,r15,gt,r5)              |  If more than enough room.\n      lr r15,r5                     |   Only use the exact amount.\n    endif                           |  EndIf.\n    st  r15,0(,r6)                  |  Save length of current record.\n*                                   |\n    if  (treg,r5,p)                 |  If anything to copy, then.\n     la  r0,256                     |   Use for increments/decrements.\n     loop while,(cr,r5,ge,r0),and,(cr,r15,ge,r0)\n      mvc  0(256,r14),0(r4)         |    Move 256 bytes.\n      if   (tbit,pwa_2_ascii)       |    If file is in ASCII.\n       tr  0(256,r14),&s.ascii_to_ebcdic   Convert to ebcdic.\n      endif                         |    EndIf.\n      ar   r14,r0                   |    Bump target pointer.\n      sr   r15,r0                   |    Decrement target length.\n      ar   r4,r0                    |    Bump source pointer.\n      sr   r5,r0                    |    Decrement source length.\n     endloop while                  |   EndLoop.\n     if (treg,r15,p),and,(treg,r5,p)    If anything left.\n      bctr r15,0                    |    Subtract 1 for EX instr.\n      exi r15,(mvc,0(0,r14),0(r4))  |    copy record to target area.\n      if   (tbit,pwa_2_ascii)       |     If file is in ASCII.\n       exi r15,(tr,0(0,r14),&s.ascii_to_ebcdic)  Convert to ebcdic.\n      endif                         |     EndIf.\n      la  r15,1(,r15)               |    Add 1 back for comparison.\n     endif                          |   EndIf.\n     if  (cr,r15,lt,r5)             |   If record was truncated.\n      callsub message,(fi00201,\"Input \",0(r6)) Format a message.\n      errexit code=0                |    Exit with return-code.\n     endif                          |   EndIf.\n    endif                           |  EndIf.\n   endif                            | EndIf.\n\n*---------------------------------------------------------------------*\n*  If OPTION=LIBRARY and there is not data remaining in current BENT,\n*  start a new READ.\n*---------------------------------------------------------------------*\n   if          (cli,pwa_oc2_library,eq,&fi_oc2_library),and,           +\n               not,(tbit,pwa_1_eof),and,                               +\n               (clc,pwa_bent_current_remaining,eq,=f'0')\n    l     r2,pwa_bent_current\n    block amode=&srvfios_iocall_amode\n     read  bent_decb-bent_start(,r2),sf,mf=e\n    endblk\n   endif\n*---------------------------------------------------------------------*\n   drop    r8\n*  callsub message,(fi00000)        | Successful completion.\n   slr  r15,r15\n endblk block=readline\n            ssd\n&s.ascii_to_ebcdic ds    0cl256\n         SMLIST CONVERT=NO            |\n             dc c'................'   0\n             dc c'................'   1\n             dc c' !\"#$%&&''()*+,-./' 2\n             dc c'0123456789:;<=>?'   3\n             dc c'@ABCDEFGHIJKLMNO'   4\n             dc c'PQRSTUVWXYZ\u00dd\\\u00a8\u00ac_'   5\n             dc c'`abcdefghijklmno'   6\n             dc c'pqrstuvwxyz{|}~.'   7\n             dc c'................'   8\n             dc c'................'   9\n             dc c' !\"#$%&&''()*+,-./' a\n             dc c'0123456789:;<=>?'   b\n             dc c'@ABCDEFGHIJKLMNO'   c\n             dc c'PQRSTUVWXYZ\u00dd\\\u00a8\u00ac_'   d\n             dc c'`abcdefghijklmno'   e\n             dc c'pqrstuvwxyz{|}~.'   f\n         SMLIST CONVERT=YES           |\n           endssd\n           swa\n&w.newrec  ds    a         | Address of new line @ start of RDW.\n           endswa\n eject\n***********************************************************************\n*                                                                     *\n*  Subroutine: WRITELINE                                              *\n*  Abstract:   Obtain the next line from an already open file.        *\n*                                                                     *\n***********************************************************************\n block name=writeline,type=subroutine,amode=&srvfios_iosub_amode\n*---------------------------------------------------------------------*\n*  Insure that attempting to read the next sequential line is an okay\n*  thing to do, considering the current type and status of the file\n*  and the access mode requested when the file was opened.  The error\n*  status flag has already been checked, at the beginning of the main\n*  routine.\n*---------------------------------------------------------------------*\n   if (tbit,pwa_1_open,off)\n     callsub message,(fi00114,\"WRITELINE\",9)\n     errexit code=0                   |\n   elseif (cli,pwa_oo_mode,ne,&fi_oo_output)\n     callsub message,(fi00012)        |\n     errexit code=0                   |\n   endif                              |\n*---------------------------------------------------------------------*\n*  OK, write the record using PUT-Locate, as follows:\n*    .. If writing VL records, stuff length from caller into DCBLRECL.\n*    .. Issue PUT. R1 will contain address of place to put the record\n*       upon return.\n*    .. Move record into buffer.\n*---------------------------------------------------------------------*\n   la    r8,pwa_dcb                   | r8 -> Working output DCB.\n   using ihadcb,r8                    | Establish addressability.\n   l     r6,fi_wl_line                | r6 -> Text of new output line.\n   l     r7,fi_wl_length              | r7 -> Length of new line.\n   icm   r7,b'1111',0(r7)             | r7 := Length of new line.\n   slr   r5,r5                        | r5 := Truncation-flag register.\n*                                     |\n   if (tbit,dcbrecfm,dcbrecv)         | If variable-length output\n     la  r7,4(r7)                     |   Adjust length for RDW.\n     if  (c,r7,gt,pwa_lrecl)          |   If too large for dataset.\n       callsub message,(fi00201,\"Output\",pwa_lrecl)\n       lr      r5,r15                 |      Remember truncation.\n       l       r7,pwa_lrecl           |      Use maximum length.\n     endif                            |   EndIf.\n     sth   r7,dcblrecl                |   Stuff record length into DCB.\n     block amode=&srvfios_iocall_amode |\n      put pwa_dcb                     |     Obtain next record buffer.\n      lr  r2,r1                       |     r2 -> output record buffer.\n     endblk                           |\n     errexit (tbit,pwa_1_error),code=&fi_severe\n     mvc     0(2,r2),dcblrecl         |   Set record length.\n     xc      2(2,r2),2(r2)            |   Clear reserved portion.\n     la      r14,4(r2)                |   r14 -> past RDW in buffer.\n     s       r7,=f'4'                 |   Adjust source length for RDW.\n     lr      r15,r7                   |   Dest length = source length\n*    mvcl    r14,r6 <---- used to be this Move record to buffer.\n     if   (treg,r7,p)                 |   If anything to copy, then.\n      la   r0,256                     |    For increments/decrements.\n      loop while,(cr,r7,ge,r0),and,(cr,r15,ge,r0)\n       mvc   0(256,r14),0(r6)         |      Move 256 bytes.\n       if    (tbit,pwa_2_ascii)       |      If file is in ASCII.\n        tr   0(256,r14),&s.ebcdic_to_ascii    Convert to ascii.\n       endif                          |      EndIf.\n       ar    r14,r0                   |      Bump target pointer.\n       sr    r15,r0                   |      Decrement target length.\n       ar    r6,r0                    |      Bump source pointer.\n       sr    r7,r0                    |      Decrement source length.\n      endloop while                   |    EndLoop.\n      if (treg,r15,p)                 |    If anything left.\n       bctr r15,0                     |     Subtract 1 for EX instr.\n       exi  r15,(mvc,0(0,r14),0(r6))  |     copy record to target area.\n       if    (tbit,pwa_2_ascii)       |      If file is in ASCII.\n        exi  r15,(tr,0(0,r14),&s.ebcdic_to_ascii)    Convert to ascii.\n       endif                          |      EndIf.\n      endif                           |    EndIf.\n     endif                            |   EndIf.\n     ltr     r15,r5                   |   Get truncation return-code.\n     errexit nz,code=0                |   Exit if truncated.\n   else                               | Else, fixed-length output.\n     block amode=&srvfios_iocall_amode |\n      put pwa_dcb                     |     Obtain next record buffer.\n      lr  r2,r1                       |     r2 -> output record buffer.\n     endblk                           |\n     errexit (tbit,pwa_1_error),code=&fi_severe\n     if  (c,r7,gt,pwa_lrecl)          |   If too large for dataset.\n       callsub message,(fi00201,\"Output\",pwa_lrecl)\n       lr      r5,r15                 |      Remember truncation.\n       l       r7,pwa_lrecl           |      Use maximum length.\n     endif                            |   EndIf.\n     lr      r14,r2                   |   Move buffer addr to r14\n     lh      r15,dcblrecl             |   Dest length = fixed LRECL.\n*    icm     r7,b'1000',=c' '         |   Using blank for a pad char.\n*    mvcl    r14,r6 <---- used to be this Move record to buffer.\n     if   (treg,r7,p),or,(treg,r15,p) |   If anything to copy, then.\n      la   r0,256                     |    For increments/decrements.\n      loop while,(cr,r7,ge,r0),and,(cr,r15,ge,r0)\n       mvc   0(256,r14),0(r6)         |      Move 256 bytes.\n       if    (tbit,pwa_2_ascii)       |      If file is in ASCII.\n        tr   0(256,r14),&s.ebcdic_to_ascii    Convert to ascii.\n       endif                          |      EndIf.\n       ar    r14,r0                   |      Bump target pointer.\n       sr    r15,r0                   |      Decrement target length.\n       ar    r6,r0                    |      Bump source pointer.\n       sr    r7,r0                    |      Decrement source length.\n      endloop while                   |    EndLoop.\n      if (treg,r15,p),and,(treg,r7,p) |    If anything left.\n       lr  r1,r15                     |     r1 := dest length.\n       if  (cr,r1,gt,r7)              |     if more than source len\n        lr  r1,r7                     |      use source len\n       endif                          |     endif\n       bctr r1,0                      |     Subtract 1 for EX instr.\n       exi  r1,(mvc,0(0,r14),0(r6))   |     copy record to target area.\n       if    (tbit,pwa_2_ascii)       |      If file is in ASCII.\n        exi  r1,(tr,0(0,r14),&s.ebcdic_to_ascii)    Convert to ascii.\n       endif                          |      EndIf.\n       la   r1,1(,r1)                 |     Add 1 back for updates.\n       ar   r14,r1                    |     Bump target pointer.\n       sr   r15,r1                    |     Decrement target length.\n       ar   r6,r1                     |     Bump source pointer.\n       sr   r7,r1                     |     Decrement source length.\n      endif                           |    EndIf.\n      if (treg,r15,p)                 |    If padding required.\n       loop while,(cr,r15,ge,r0)      |     Loop for big chunks.\n        mvc  0(256,r14),=cl256' '     |      Fill w/blanks.\n        ar   r14,r0                   |      Bump target pointer.\n        sr   r15,r0                   |      Decrement target length.\n       endloop while                  |     EndLoop.\n       if (treg,r15,p)                |     If anything left.\n        bctr r15,0                    |      Subtract 1 for EX instr.\n        exi  r15,(mvc,0(0,r14),=cl256' ')    Pad remainder w/blanks.\n       endif                          |     EndIf.\n      endif                           |    EndIf.\n     endif                            |   EndIf.\n     ltr     r15,r5                   |   Get truncation return-code.\n     errexit nz,code=0                |   Exit if truncated.\n   endif                              | EndIf.\n*  callsub message,(fi00000)          | Successful completion.\n   slr  r15,r15\n endblk block=writeline               |\n             ssd\n&s.ebcdic_to_ascii ds    0cl256\n*                 0 1 2 3 4 5 6 7 8 9 A B C D E F\n             dc x'2E2E2E2E2E2E2E2E2E2E2E2E2E2E2E2E'   0\n             dc x'2E2E2E2E2E2E2E2E2E2E2E2E2E2E2E2E'   1\n             dc x'2E2E2E2E2E2E2E2E2E2E2E2E2E2E2E2E'   2\n             dc x'2E2E2E2E2E2E2E2E2E2E2E2E2E2E2E2E'   3\n             dc x'202E2E2E2E2E2E2E2E2E2E2E3C282B7C'   4\n             dc x'262E2E2E2E2E2E2E2E2E21242A293B5E'   5\n             dc x'2D2F2E2E2E2E2E2E2E2E7C2C255F3E3F'   6\n             dc x'2E2E2E2E2E2E2E2E2E603A2340273D22'   7\n             dc x'2E6162636465666768692E7B2E282B2B'   8\n             dc x'2E6A6B6C6D6E6F7071722E7D2E292E2E'   9\n             dc x'2E2E737475767778797A2E2E2E5B2E2E'   A\n             dc x'303132333435363738392E2E2E5D2E2D'   B\n             dc x'7B4142434445464748492E2E2E2E2E2E'   C\n             dc x'7D4A4B4C4D4E4F5051522E2E2E2E2E2E'   D\n             dc x'5C00535455565758595A2E2E2E2E2E2E'   E\n             dc x'303132333435363738392E2E2E2E2E2E'   F\n             endssd\n             swa\n&w.putbuf    ds   a\n&w.length    ds   f\n             endswa\n eject                                |\n***********************************************************************\n*                                                                     *\n*  Subroutine: GET_INFO                                               *\n*  Abstract:   Return selected information to the caller.             *\n*                                                                     *\n***********************************************************************\n block name=get_info,type=subroutine  |\n* *-------------------------------------------------------------------*\n* * Return info for each information sub-code parameter.\n* *-------------------------------------------------------------------*\n  la     r7,fi_gi_function            | r7 -> 1st info subcode parm.\n  using  fi_gi_function,r7            | Address get_info parms.\n  loop   until                        | Loop for each gi_function parm.\n   l       r2,fi_gi_function          |   R2 -> information sub-code.\n   l       r1,0(,r2)                  |   R1 := information sub-code.\n   caseblk reg=r1,wreg=r1,mult=1      |   Case on information sub-code.\n   case &fi_gi_msg                    | *-------------------------> MSG\n     if not,((tbit,fi_gi_function,x'80',off),and,    make sure area,   +\n               (tbit,fi_gi_area,x'80',off),and,      area_size, and    +\n               (tbit,fi_gi_area_size,x'80',off))     length are present\n       callsub message,(fi00006,\"GET_INFO (MSG)\",14)\n       errexit code=0                 |\n     endif                            |   EndIf.\n     lm r2,r3,fi_gi_area              |   R2/R3 -> text area, length.\n     l  r3,0(r3)                      |   R3 := length of text area.\n     lm r4,r5,pwa_msg_data            |   R4/R5 -> message text/length.\n     if (treg,r4,z),or,(treg,r5,z)    |   If no message then.\n       slr  r4,r4                     |     Ensure both address and\n       slr  r5,r5                     |     length are all zeros.\n     else                             |   Else.\n       l  r5,0(r5)                    |     R5 := length of message.\n       if (cr,r5,gt,r3)               |     If too long to fit in area.\n         lr r5,r3                     |       Reduce to exact length.\n       endif                          |     EndIf.\n     endif                            |   EndIf.\n     l    r1,fi_gi_length             |   R1 -> message length parm.\n     st   r5,0(r1)                    |   Save length of returned msg.\n     icm  r5,8,=c' '                  |   Pad copied text with blanks.\n     mvcl r2,r4                       |   Copy information to caller.\n     if   (tbit,fi_gi_length,x'80',on)    If we used the last parm.\n      leave loop=*                    |    We're done.\n     endif                            |   EndIf.\n     la   r7,4*4(,r7)                 |   Point r7 past parms we used.\n   case &fi_gi_name                   | *------------------------> NAME\n     if not,((tbit,fi_gi_function,x'80',off),and,    make sure area,   +\n               (tbit,fi_gi_area,x'80',off),and,      area_size, and    +\n               (tbit,fi_gi_area_size,x'80',off))     length are present\n       callsub message,(fi00006,\"GET_INFO (NAME)\",15)\n       errexit code=0                 |\n     endif                            |   EndIf.\n     lm r2,r4,fi_gi_area              |   R2/R4 -> area/length/retlen.\n     la r5,=f'0'                      |   Set up zero-length.\n     if (cli,pwa_member,ne,c' ')      |   If there is a member name.\n       la r5,=f'1'                    |     R1 := length of ( or ).\n     endif                            |   EndIf.\n     lr        r14,r2                 |   r14 -> area.\n     l         r15,0(r3)              |   r15 := length of area.\n     slr       r0,r0                  |   r0 -> Null source string.\n     slr       r1,r1                  |   r1 := Null source length.\n     icm       r1,b'1000',=c' '       |   Insert blank for padding.\n     mvcl      r14,r0                 |   Clear area w/blanks.\n     st_format id=st,string=(0(r2),0(r3)),resultlen=0(r4),             +\n               control=\"{CL44 TRIM}{CL?}{CL8 T}{CL?}\",                 +\n               source=(pwa_dsname,\"(\",0(r5),pwa_member,\")\",0(r5))\n     if (c,r15,eq,=f'&st_truncated')  |   If filename truncated.\n       callsub message,(fi00021)      |     Issue a message and quit.\n       errexit code=0                 |\n     elseif (treg,r15,nz)             |   ElseIf a problem occurred.\n       callsub message,(fi00003)      |     Internal error.\n       errexit code=0                 |\n     endif                            |   EndIf.\n     if   (tbit,fi_gi_length,x'80',on)    If we used the last parm.\n      leave loop=*                    |    We're done.\n     endif                            |   EndIf.\n     la   r7,4*4(,r7)                 |   Point r7 past parms we used.\n   case &fi_gi_ddname                 | *----------------------> DDNAME\n     if not,((tbit,fi_gi_function,x'80',off),and,    make sure area,   +\n               (tbit,fi_gi_area,x'80',off),and,      area_size, and    +\n               (tbit,fi_gi_area_size,x'80',off))     length are present\n       callsub message,(fi00006,\"GET_INFO (DDNAME)\",17)\n       errexit code=0                 |\n     endif                            |   EndIf.\n     lm r2,r4,fi_gi_area              |   R2/R4 -> area/length/retlen.\n     lr        r14,r2                 |   r14 -> area.\n     l         r15,0(r3)              |   r15 := length of area.\n     slr       r0,r0                  |   r0 -> Null source string.\n     slr       r1,r1                  |   r1 := Null source length.\n     icm       r1,b'1000',=c' '       |   Insert blank for padding.\n     mvcl      r14,r0                 |   Clear area w/blanks.\n     st_format id=st,string=(0(r2),0(r3)),resultlen=0(r4),             +\n               control=\"{CL? TRIM}\",                                   +\n               source=(pwa_ddname,=a(l'pwa_ddname))\n     if (c,r15,eq,=f'&st_truncated')  |   If filename truncated.\n       callsub message,(fi00021)      |     Issue a message and quit.\n       errexit code=0                 |\n     elseif (treg,r15,nz)             |   ElseIf a problem occurred.\n       callsub message,(fi00003)      |     Internal error.\n       errexit code=0                 |\n     endif                            |   EndIf.\n     if   (tbit,fi_gi_length,x'80',on)    If we used the last parm.\n      leave loop=*                    |    We're done.\n     endif                            |   EndIf.\n     la   r7,4*4(,r7)                 |   Point r7 past parms we used.\n   case &fi_gi_volume                 | *----------------------> VOLUME\n     if not,((tbit,fi_gi_function,x'80',off),and,    make sure area,   +\n               (tbit,fi_gi_area,x'80',off),and,      area_size, and    +\n               (tbit,fi_gi_area_size,x'80',off))     length are present\n       callsub message,(fi00006,\"GET_INFO (VOLUME)\",17)\n       errexit code=0                 |\n     endif                            |   EndIf.\n     lm r2,r4,fi_gi_area              |   R2/R4 -> area/length/retlen.\n     lr        r14,r2                 |   r14 -> area.\n     l         r15,0(r3)              |   r15 := length of area.\n     slr       r0,r0                  |   r0 -> Null source string.\n     slr       r1,r1                  |   r1 := Null source length.\n     icm       r1,b'1000',=c' '       |   Insert blank for padding.\n     mvcl      r14,r0                 |   Clear area w/blanks.\n     st_format id=st,string=(0(r2),0(r3)),resultlen=0(r4),             +\n               control=\"{CL? TRIM}\",                                   +\n               source=(pwa_volser,=a(l'pwa_volser))\n     st   r15,pwa_save_r15            | Preserve r15 for errexit\n     if (c,r15,eq,=f'&st_truncated')  |   If filename truncated.\n       callsub message,(fi00021)      |     Issue a message and quit.\n       l    r15,pwa_save_r15          | Rest r15 for debug analysis\n       errexit code=0                 |\n     elseif (treg,r15,nz)             |   ElseIf a problem occurred.\n       callsub message,(fi00003)      |     Internal error.\n       l    r15,pwa_save_r15          | Rest r15 for debug analysis\n       errexit code=0                 |\n     endif                            |   EndIf.\n     if   (tbit,fi_gi_length,x'80',on)    If we used the last parm.\n      leave loop=*                    |    We're done.\n     endif                            |   EndIf.\n     la   r7,4*4(,r7)                 |   Point r7 past parms we used.\n   case &fi_gi_lrecl                  | *-----------------------> LRECL\n     if not,(tbit,fi_gi_function,x'80',off)           make sure area\n       callsub message,(fi00006,\"GET_INFO (LRECL)\",16)    is present.\n       errexit code=0                 |\n     endif                            |   EndIf.\n     if (tbit,pwa_1_open,off) If file is not OPEN.\n       callsub message,(fi00114,\"GET_INFO (LRECL)\",16)\n       errexit code=0                 |     Exit w/return-code.\n     else                             |   Else.\n       l     r2,fi_gi_area            |     R2 -> Halfword for LRECL.\n       l     r1,pwa_lrecl             |     R1 := actual lrecl.\n       stcm  r1,b'0011',0(r2)         |     Copy lrecl value to area.\n     endif                            |   EndIf.\n     if   (tbit,fi_gi_area,x'80',on)  |   If we used the last parm.\n      leave loop=*                    |    We're done.\n     endif                            |   EndIf.\n     la   r7,2*4(,r7)                 |   Point r7 past parms we used.\n   case &fi_gi_recfm                  | *-----------------------> RECFM\n     if not,(tbit,fi_gi_function,x'80',off)           make sure area\n       callsub message,(fi00006,\"GET_INFO (RECFM)\",16)    is present\n       errexit code=0                 |\n     endif                            |   EndIf.\n     if (tbit,pwa_1_open,off) If file is not OPEN.\n       callsub message,(fi00114,\"GET_INFO (RECFM)\",16)\n       errexit code=0                 |     Exit w/return-code.\n     else                             |   Else.\n       l     r2,fi_gi_area            |     R2 -> Return area.\n       mvc   0(8,r2),=cl8' '          |     Blank out unused positions.\n       la    r3,pwa_dcb               |     R3 -> File's open DCB.\n       using ihadcb,r3                |     Establish addressability.\n       if  (tbit,dcbrecfm,dcbrecf)    |     If FIXED length records.\n         mvi 0(r2),c\"F\"               |       Return an 'F'.\n       else                           |     Else.\n         mvi 0(r2),c\"V\"               |       Return a 'V'.\n       endif                          |     EndIf.\n       if  (tbit,dcbrecfm,DCBRECBR)   |     If BLOCKED records.\n         mvi 1(r2),c\"B\"               |       Return a 'B'.\n       endif                          |     EndIf.\n       if  (tbit,dcbrecfm,dcbrecca)   |     IF ASA control char\n        mvi 2(r2),c\"A\"                |       Return an \"A\".\n       elseif  (tbit,dcbrecfm,dcbreccm)     ElseIF Machine control char\n        mvi 2(r2),c\"M\"                |       Return an \"M\".\n       endif                          |     EndIf.\n     endif                            |   EndIf.\n     if   (tbit,fi_gi_area,x'80',on)  |   If we used the last parm.\n      leave loop=*                    |    We're done.\n     endif                            |   EndIf.\n     la   r7,2*4(,r7)                 |   Point r7 past parms we used.\n   case &fi_gi_idstring               | *--------------------> IDSTRING\n     if not,(tbit,fi_gi_function,x'80',off)            make sure area\n       callsub message,(fi00006,\"GET_INFO (IDSTRING)\",19)  is present.\n       errexit code=0                 |\n     endif                            |   EndIf.\n     if (tbit,pwa_1_open,off) If file is not OPEN.\n       callsub message,(fi00114,\"GET_INFO (IDSTRING)\",19)\n       errexit code=0                 |     Exit w/return-code.\n     else                             |   Else.\n       l r2,fi_gi_area                |     R2 -> Return area.\n       mvc 0(8,r2),=cl8' '            |     Initialize it to blanks.\n       if (cli,pwa_member,ne,c' ')    |     If there is a member name.\n         mvc 0(8,r2),pwa_member       |       Copy member name.\n       else                           |     Else.\n         ds  0h                       |       Do nothing.\n       endif                          |     EndIf.\n     endif                            |   EndIf.\n     if   (tbit,fi_gi_area,x'80',on)  |   If we used the last parm.\n      leave loop=*                    |    We're done.\n     endif                            |   EndIf.\n     la   r7,2*4(,r7)                 |   Point r7 past parms we used.\n   case other                         | *---------------------> *ERROR*\n       callsub message,(fi00022,0(r2))\n       errexit code=0\n   endcase                            | EndCase\n  endloop until,leave                 | EndLoop.\n endblk block=get_info                |\n           swa\n           endswa\n eject\n***********************************************************************\n*                                                                     *\n*  Subroutine: SET_STATUS                                             *\n*  Abstract:   Set status information about the current file based on *\n*              the provided parameters.                               *\n*                                                                     *\n***********************************************************************\n block name=set_status,type=subroutine\n*---------------------------------------------------------------------*\n*  Call the routine that sets the specified status.\n*---------------------------------------------------------------------*\n   l       r2,fi_ss_function          | R2 -> status sub-code.\n   l       r1,0(,r2)                  | R1 := status sub-code.\n   caseblk reg=r1,wreg=r1,mult=1      | Case on status sub-code.\n   case &fi_ss_end_of_file            | *-----------------> END_OF_FILE\n     if (cli,pwa_oo_mode,eq,&fi_oo_input)    If INPUT mode.\n       sbit pwa_1,pwa_1_eof           |        Mark end-of-file.\n     elseif (cli,pwa_oo_mode,eq,&fi_oo_output) If OUTPUT mode.\n       if (cli,pwa_member,ne,c\" \"),and,        If a member written to  +\n               (tbit,pwa_1_ds_not_existing,off) existing pds.\n         if (tbit,pwa_1_member)                  If replaced.\n           la r6,=cl8\"replaced\"       |            R6 -> \"REPLACED\"\n         else                         |          Else, created.\n           la r6,=cl8\"created \"       |            R6 -> \"CREATED \"\n         endif                        |          EndIf.\n         callsub message,(fi00301,pwa_member,0(r6),pwa_dsname)\n       else                           |        ELSE\n         if (tbit,pwa_1_ds_not_existing) if dataset created.\n           la r6,=cl8\"created \"       |            R6 -> \"CREATED \"\n         else                         |          Else, replaced.\n           la r6,=cl8\"replaced\"       |            R6 -> \"REPLACED\"\n         endif                        |          EndIf.\n         la r5,=f'0'                  |          Set up zero-length.\n         if (cli,pwa_member,ne,c' ')  |          If a member name.\n           la r5,=f'1'                |            R5 := length of \"(\".\n         endif                        |          EndIf.\n         callsub message,(fi00300,    |                                +\n               pwa_dsname,\"(\",0(r5),pwa_member,\")\",0(r5),0(r6))\n       endif                          |        EndIf.\n     endif                            |      EndIf.\n     errexit code=&fi_end_of_file     |      Exit w/EOF return-code.\n   case other                         | *---------------------> *ERROR*\n     callsub message,(fi00031,0(r2))  |   Issue an error message.\n     errexit code=0                   |   Exit w/return-code.\n   endcase                            | EndCase\n*  callsub message,(fi00000)          | Successful completion.\n   slr     r15,r15\n endblk block=set_status\n***********************************************************************\n*                                                                     *\n*  Subroutine: GET_REFERENCE                                          *\n*  Abstract:   Return reference string to the caller.                 *\n*                                                                     *\n***********************************************************************\n block name=get_reference,type=subroutine  |\n* *-------------------------------------------------------------------*\n* * Return reference string.\n* *-------------------------------------------------------------------*\n  l      r7,fi_gr_reference           | r7 -> reference string.\n  mvc   0(l'pwa_fi_reference,r7),pwa_fi_reference\n endblk block=get_reference           |\n*                                     |   to caller.\n eject\n***********************************************************************\n*                                                                     *\n*  Subroutine: FIND                                                   *\n*  Abstract:   Process FIND function.                                 *\n*                                                                     *\n***********************************************************************\n block name=find,type=subroutine,options=codebase,                     +\n               amode=&srvfios_iosub_amode\n*  *------------------------------------------------------------------*\n*  * Make sure file is open and OPTION=LIBRARY is specified.\n*  *------------------------------------------------------------------*\n   if (tbit,pwa_1_open,off)           |  If not open:\n     callsub message,(fi00114,\"FIND\",4) Fuss.\n     errexit code=0                   |    Exit.\n   elseif (cli,pwa_oc2_library,ne,&fi_oc2_library) If LIBRARY option.\n     callsub message,(fi00042,\"FIND\",4)  Elseif not OPTION=LIBRARY:\n     errexit code=0                   |    Fuss and exit.\n   endif                              |  Endif.\n*  *------------------------------------------------------------------*\n*  * Initialize.\n*  *------------------------------------------------------------------*\n   fill  pwa_member,x'40'             |  Blank out member name.\n   sbit  pwa_1_eof                    |  Indicate EOF.\n   rbit  pwa_2_valid_find_active      |  Indicate no active FIND.\n*  *------------------------------------------------------------------*\n*  * Move member name to PWA.\n*  *------------------------------------------------------------------*\n   l     r2,fi_fd_length              |  r2 -> length.\n   l     r15,0(,r2)                   |  r15 = length.\n   if (treg,r15,np)                   |  if not positive:\n     callsub message,(fi00014)        |    Save error message\n     errexit code=0                   |    and exit.\n   elseif (chi,r15,gt,l'pwa_member)   |  Else if too long:\n     callsub message,(fi00015,0(,r2)) |    Save error message\n     errexit code=0                   |    and exit.\n   endif                              |  Endif.\n   bctr  r15,0                        |  Sub 1 for ex.\n   l     r1,fi_fd_member              |  r1 -> requested member.\n   exi   r15,(mvc,pwa_member,0(r1))   |  Move it to pwa.\n   tr   pwa_member,fold               |  Fold member-name to caps.\n   trt  pwa_member,lettrdig           |  Scan for invalid characters.\n   if  (nz,and,(cli,0(r1),ne,c' ')),or,(cli,pwa_member,ge,c'0')\n     callsub message,(fi00016,pwa_member) Name must not start with\n     errexit code=0                   |   number or be blank.\n   endif                              |\n*  *------------------------------------------------------------------*\n*  * Find member.\n*  *------------------------------------------------------------------*\n   block amode=&srvfios_iocall_amode  |\n     find  pwa_dcb,pwa_member,d       |    Find member.\n     st    r0,&w.reason               |    Save reason.\n     st    r15,&w.rc                  |    Save return code.\n   endblk                             |  Endif.\n   l     r0,&w.reason                 |  r0 = reason.\n   l     r15,&w.rc                    |  r15 = return code.\n   if (treg,r15,z)                    |  If find successful:\n     sbit  pwa_2_valid_find_active    |    Indicate valid find active.\n     rbit  pwa_1_eof                  |    Reset EOF.\n*    *----------------------------------------------------------------*\n*    * Do initial reads.  Set current as final BENT with remaining\n*    * of zero so that first FI_READLINE will wrap to first BENT\n*    * and do a CHECK.\n*    *----------------------------------------------------------------*\n     fill  pwa_bent_current_remaining |    No date in current buffer.\n     l     r3,pwa_bent_buffer_address |    Establish base for\n     using bent_start,r3              |    buffer entries.\n     loop until                       |    Loop starting reads:\n      st    r3,pwa_bent_current       |      Current will be last buff.\n      mvc   bent_decb,psd_decb        |      Move base DECB to entry.\n      block amode=&srvfios_iocall_amode |\n       read  bent_decb,sf,pwa_dcb,bent_data_start,mf=e   Read block.\n      endblk                          |      Endblk.\n      l     r3,pwa_bent_buffer_address       Point to next buffer.\n     endloop until,(c,r3,eq,pwa_bent_buffer_address)\n     drop  r3                         |    Endloop.  Drop entry base.\n*    *----------------------------------------------------------------*\n   elseif (chi,r15,eq,4),and,(treg,r0,z) Else if member not found:\n     callsub message,(fi00040,pwa_member)  Save message.\n     errexit code=&fi_not_found       |    Exit.\n   else                               |  Else:\n     callsub message,(fi00041,pwa_member,&w.rc,&w.reason)\n     errexit code=0                   |    Save message and exit.\n   endif                              |  Endif.\n*  *------------------------------------------------------------------*\n*  callsub message,(fi00000)          |  Successful completion.\n   slr     r15,r15\n endblk block=find                    |\n         swa                          |\n&w.rc                          ds f   |\n&w.reason                      ds f   |\n         endswa                       |\n eject\n title \"SRVFIOS - Internal subroutines called by Function routines\"\n***********************************************************************\n*                                                                     *\n*  Subroutine: PARSE_FILENAME                                         *\n*  Abstract:   Scan the file-specification to validate it as an OS    *\n*              data set name and to split the dsname from the member. *\n*                                                                     *\n***********************************************************************\n block name=parse_filename,type=subroutine\n   fill pwa_dsname,c' '           |   Blank out the data set name.\n   mvc  pwa_member,=cl8' '        |   Blank out the member name.\n*---------------------------------------------------------------------*\n*  R4 -> file-specification.  R5 := file specification's length.\n*---------------------------------------------------------------------*\n   l     r4,fi_filename           | R4 := file-specification's text.\n   la    r4,0(,r4)                | Clear high-bit.\n   leave block=*,(treg,r4,z)      | Return now if null.\n   l  r5,fi_namelength            | R5 -> length of file-specification.\n   l  r5,0(,r5)                   | R5 := length of file-specification.\n   if (treg,r5,np)                | If zero-length filename.\n     callsub message,(fi00011)    |   Issue a message and quit.\n     errexit code=0               |\n   endif                          | EndIf.\n*---------------------------------------------------------------------*\n*  If the file is identified by DDNAME, copy it to the PWA.\n*---------------------------------------------------------------------*\n   if (cli,pwa_oc_ident,eq,&fi_oc_fileid)\n     st        r5,&w.length         | Save length for parmlist access.\n     st_format id=st,string=pwa_ddname,control='{?cl? caps trim}',     +\n               source=(=a(l'pwa_ddname),0(r4),&w.length)\n     st   r15,pwa_save_r15          | Preserve r15 for errexit\n     if (c,r15,eq,=f'&st_truncated')  if longer than 8 characters.\n       callsub message,(fi00025,=a(l'pwa_ddname),(r4),&w.length)\n       l    r15,pwa_save_r15        | Restore r15 for debug analysis\n       errexit code=0               |\n     elseif (treg,r15,nz)           | Else.\n       callsub message,(fi00003)    |   Unknown error.\n       l    r15,pwa_save_r15        | Restore r15 for debug analysis\n       errexit code=0               |   Return to caller.\n     endif                          | EndIf.\n     leave block=*\n   endif\n   eject\n*---------------------------------------------------------------------*\n*  If the file-spec is quoted, remove quotes.  Else obtain prefix.\n*---------------------------------------------------------------------*\n   fill    &w.prefix,c' '         | No dsname prefix being used, yet.\n   la      r5,0(r5,r4)            | R5 -> past end of file-spec.\n   loop    until                  | Scan back for final non-blank.\n    bctr  r5,0                    |  Back up one character.\n   endloop until,(cr,r5,le,r4),or,(cli,0(r5),gt,c' ')\n   if (cli,0(r4),eq,c'''')        | If file-spec is quoted, then.\n     la r4,1(,r4)                 |   Advance past starting quote.\n     if (cli,0(r5),eq,c'''')      |   If trailing quote is present.\n       bctr  r5,0                 |     Remove trailing quote.\n     endif                        |   EndIf.\n     if (cr,r4,gt,r5)             |   If zero-length filename.\n       callsub message,(fi00011)  |     Issue a message and quit.\n       errexit code=0             |\n     endif                        |   EndIf.\n   else                           | Else -- it needs to be prefixed --\n     es_get_prefix id=es,prefix=&w.prefix\n     if (cli,&w.prefix,ne,c' ')   |   If a prefix was obtained.\n       la      r15,&w.prefix+7    |      Point to end of 8-byte field.\n       loop    bct                |      Loop back to a non-blank.\n         leave loop=*,(cli,0(r15),ne,c' ')\n       endloop bct,r15            |      EndLoop.\n       mvi     1(r15),c'.'        |      Put '.' on end of prefix.\n     endif                        |   EndIf.\n   endif                          |\n   eject\n*---------------------------------------------------------------------*\n*  Copy the data set name to PWA storage and fold it to uppercase.\n*---------------------------------------------------------------------*\n   lr   r7,r4                     | R7 -> Start of data set name.\n   loop while,(cr,r7,le,r5)\n     leave loop=*,(cli,0(r7),le,c' ')\n     leave loop=*,(cli,0(r7),eq,c'(')\n     la r7,1(,r7)                 |   Advance to next character.\n   endloop while                  | EndLoop.\n   sr r7,r4                       | R7 := length of dsname.\n   if (treg,r7,np)                | If zero-length filename.\n     callsub message,(fi00011)    |   Issue a message and quit.\n     errexit code=0               |\n   endif                          | EndIf.\n   st        r7,&w.length         | Save length for plist access.\n   st_format id=st,string=pwa_dsname,                                  +\n               control=\"{?CL0}{@1CL9 CAPS TRIM}{CL? CAPS}\",            +\n               source=(=a(l'pwa_dsname),,&w.prefix,0(r4),&w.length)\n   st   r15,pwa_save_r15          | Preserve r15 for errexit\n   if (c,r15,eq,=f'&st_truncated')  if longer than 44 characters.\n     callsub message,(fi00018,=a(l'pwa_dsname),(r4),&w.length)\n     l    r15,pwa_save_r15        | Restore r15 for debug analysis\n     errexit code=0               |\n   elseif (treg,r15,nz)           | Else.\n     callsub message,(fi00003)    |   Unknown error.\n     l    r15,pwa_save_r15        | Restore r15 for debug analysis\n     errexit code=0               |   Return to caller.\n   endif                          | EndIf.\n   la   r4,0(r7,r4)               | R4 -> past DSNAME in file-spec.\n   eject\n*---------------------------------------------------------------------*\n*  Validate the entire (possibly prefixed) data set name's syntax.\n*---------------------------------------------------------------------*\n   la   r6,pwa_dsname             | R6 -> start of DSNAME.\n   la   r7,l'pwa_dsname(,r6)      | R7 -> past end of DSNAME.\n   loop until                     | Loop over data set name.\n     lr r3,r6                     |   R3 -> Current character.\n     loop while,(cr,r3,lt,r7)     |   Scan ahead for '.'.\n       leave loop=*,(cli,0(r3),eq,c' ')  leave if past end of dsname.\n       leave loop=*,(cli,0(r3),eq,c'.')  leave if at the dot.\n       la    r3,1(,r3)            |      Advance to next character.\n     endloop while                |   EndLoop\n     sr  r3,r6                    |   R3 := length of qualifier.\n     st  r3,&w.length             |   Save for parm access.\n*                                 |\n     if (treg,r3,np)              |   If zero-length qualifier.\n       callsub message,(fi00020)  |     Issue a message and quit.\n       errexit code=0             |\n     elseif (c,r3,gt,=f'8')       |   ElseIf qualifier longer than 8.\n       callsub message,(fi00019,0(r6),&w.length)\n       errexit code=0             |\n     endif                        |   EndIf.\n*                                 |\n     bctr r3,0                    |   Subtract 1 for EX instruction.\n     exi  r3,(trt,0(0,r6),lettrdig)   scan for invalid characters.\n     if   nz,or,(cli,0(r6),ge,c'0')   if invalid characters found.\n       callsub message,(fi00017,0(r6),&w.length)\n       errexit code=0             |\n     else                         |   Else.\n       la    r6,1(r3,r6)          |     Advance to the dot.\n       leave loop=*,(cr,r6,ge,r7) |     Leave if no dot.\n       leave loop=*,(cli,0(r6),eq,c' ') leave if past end of dsname.\n       la    r6,1(,r6)            |     Advance beyond the dot.\n     endif                        |   EndIf.\n   endloop until,leave            | EndLoop.\n   eject\n*---------------------------------------------------------------------*\n*  If a member name was specified, parse it.\n*---------------------------------------------------------------------*\n   if (cr,r4,gt,r5)               | If nothing is left.\n     mvc pwa_member,=cl8' '       |   Blank out the member name.\n   else                           | Else rest of stuff is (member).\n     if (cli,0(r5),eq,c')')       |   If closing parenthesis there.\n       bctr  r5,0                 |     Backup by one char.\n     endif                        |   EndIf.\n     slr   r5,r4                  |   R5 := member name's length.\n     la    r4,1(,r4)              |   Advance past open parenthesis.\n     if    (treg,r5,np)           |   If zero-length member name.\n       callsub message,(fi00014)  |     Issue a message and quit.\n       errexit code=0             |\n     elseif (c,r5,gt,=f'8')       |   ElseIf too long.\n       callsub message,(fi00015,8)      issue a message and quit.\n       errexit code=0             |\n     else                         |   Else.\n       la   r0,pwa_member         |     R0 -> destination of move.\n       la   r1,l'pwa_member       |     R1 := destination length.\n       icm  r5,8,=c' '            |     Pad move with blanks.\n       mvcl r0,r4                 |     Move member name.\n       tr   pwa_member,fold       |     Fold member-name to caps.\n       trt  pwa_member,lettrdig   |     Scan for invalid characters.\n       if  (nz,and,(cli,0(r1),ne,c' ')),or,(cli,pwa_member,ge,c'0')\n         callsub message,(fi00016,pwa_member)\n         errexit code=0           |\n       endif                      |\n     endif                        |   EndIf.\n   endif                          | EndIf.\n endblk block=parse_filename\n*---------------------------------------------------------------------*\n* Working storage for parsing data set names and DDNAMES.\n*---------------------------------------------------------------------*\n           swa\n&w.length  ds f\n&w.prefix  ds cl9\n           endswa\n           eject\n***********************************************************************\n*                                                                     *\n*  Subroutine: Allocate_File                                          *\n*  Abstract:   Allocate the specified file.                           *\n*                                                                     *\n***********************************************************************\n block type=subroutine,name=allocate_file\n* *-------------------------------------------------------------------*\n* * If a DDNAME was specified, use dynamic allocation to obtain info\n* * about the file.  If the DDNAME is already allocated, process the\n* * returned information and then return.  If the DDNAME is not already\n* * allocated, continue on t0 the next section of code.\n* *\n* * NOTE: Because the START function picks through caller-supplied text\n* *       units for information, the DDNAME being used may have come\n* *       from there instead of the FILE= operand.  If so, and if the\n* *       DDNAME is already allocated, we will pick the pre-existing\n* *       allocation with that DDNAME and the FILE=<dsname> operand\n* *       will not get used.  If the DDNAME is not already allocated,\n* *       we'll make a new allocation in the next section of code.\n* *\n* *-------------------------------------------------------------------*\n  if (clc,pwa_ddname,ne,=cl8' ')        | If FILE=<ddname> then\n    mvc &w.ddname,da_ir_ddname          | Copy DDNAME text unit.\n    mvc &w.ret_dsorg,da_ir_ret_dsorg    | Set up return-DSORG  t.u.\n    mvc &w.ret_dsname,da_ret_dsname     | Set up return-DSNAME t.u.\n    mvc &w.ret_member,da_ret_member     | Set up return-MEMBER t.u.\n    mvc &w.ret_status,da_ret_status     | Set up return-STATUS t.u.\n    mvc &w.ret_attrs,da_ret_attrs       | Set up return-ATTRS    @DD\n    mvc &w.ret_ndisp,da_ret_ndisp       | Set up return-DISP   t.u.\n    mvc s99tupar-s99tunit+&w.ddname(8),pwa_ddname\n    plist (&w.ddname,&w.ret_dsorg,&w.ret_dsname,&w.ret_member,         +\n               &w.ret_attrs,&w.ret_status),vl,pl=pwa_textunits\n    callsub dynalloc,                   | Invoke dynamic allocation    +\n               (=al1(s99vrbin),         |     information retrieval.   +\n               =al1(s99nomnt,0),        |     nomount,          @CNENQ +\n               =al4(0),                 |     No authorized flags.     +\n               pwa_err_msg,             |     Return message area.     +\n               =a(l'pwa_err_msg),       |     Length of message area.  +\n               pwa_err_msg_len,         |     Length of returned msg.  +\n               pwa_textunits),vl        |     TextUnits.\n    if (treg,r15,z)                     | If DDNAME allocated then.\n      sbit  pwa_1,pwa_1_allocated       |   DDNAME is allocated.\n      mvc   pwa_dsname,s99tupar-s99tunit+&w.ret_dsname\n      mvc   pwa_member,s99tupar-s99tunit+&w.ret_member\n      mvc   pwa_ndisp,s99tupar-s99tunit+&w.ret_ndisp\n      mvc   pwa_status,s99tupar-s99tunit+&w.ret_status\n      lm    r1,r3,=a(da_dsorg_table,2+4,da_dsorg_table_e)\n      loop  bxle\n        leave loop=*,(clc,0(2,r1),eq,s99tupar-s99tunit+&w.ret_dsorg)\n      endloop bxle,r1,r2\n      mvc   pwa_dsorg,2(r1)             |   Copy char DSORG to pwa.\n      if    (tbit,s99tupar-s99tunit+&w.ret_attrs,x'80',on) Concat'd?\n       sbit  pwa_2_concatenated         |   Note in PWA\n       mvc   pwa_dsorg,=c'PS  '         |   Force it to sequential.\n       fill  pwa_member,c' '            |   Destroy member name\n      endif                             |\n      if (clc,=c'****',eq,pwa_dsorg)    |   If DSORG = undefined.\n        if  (cli,pwa_oo_mode,eq,&fi_oo_output)   If OUTPUT mode.\n          mvc pwa_dsorg,=c'PS  '        |         Make it PS.\n        endif                           |       EndIf.\n      endif                             |   EndIf.\n*\n*     If the data set is sequential, but a member name was returned\n*     that looks like a generation reference, then blank out the member\n*     name and pretend we didn't see it.  A generation reference must\n*     be an optional sign followed by digits, padded with blanks.\n*     If this is the case, the data set name returned has the GxxxxVyy\n*     qualifier on it anyways so there is no need for a member name.\n*\n      if (clc,=c'PS',eq,pwa_dsorg),and,(cli,pwa_member,ne,c' ')\n        la r2,pwa_member                |     r2 -> Start of member.\n        la r3,pwa_member+l'pwa_member   |     r3 -> Past end of fiel\n        if (cli,0(r2),eq,c'+'),or,(cli,0(r2),eq,c'-')\n          la r2,1(,r2)                  |       Advance past sign.\n        endif                           |     EndIf.\n        loop while,(cr,r2,lt,r3)        |     Loop over <digits>.\n          leave loop=*,(cli,0(r2),lt,c'0'),or,(cli,0(r2),gt,c'9')\n          la    r2,1(,r2)               |       Advance 1 char.\n        endloop while                   |     EndLoop.\n        loop while,((cr,r2,lt,r3),and,(cli,0(r2),eq,c' '))\n          la    r2,1(,r2)               |       Advance 1 char.\n        endloop while                   |     EndLoop.\n        if (cr,r2,eq,r3)                |     If \u00dd+|-\u00a8<digit><blank>\n          mvc pwa_member,=cl8' '        |       Blank out member.\n        endif                           |     EndIf.\n      endif                             |   EndIf.\n      leave block=*                     |   Return to caller.\n    endif                               |   EndIf.\n  endif                                 | EndIf.\n* *-------------------------------------------------------------------*\n* * Either no DDNAME was specified or the specified DDNAME was not\n* * pre-allocated.  If a DSNAME was specified, attempt to allocate to\n* * it and retrieve information.  Again, caller-supplied text units are\n* * not used for allocation to a pre-existing data set.\n* *-------------------------------------------------------------------*\n  if (cli,pwa_dsname,ne,c' ')           | If dsname was specified.\n    fill  pwa_textunits,x'00'           |   Clear text unit pointers.\n    la    r7,pwa_textunits              |   r7 -> text unit pointers.\n    using &s.dsntup,r7                  |\n    mvc   &w.dsname,da_dsname           |   Copy DSNAME text unit.\n    mvc   s99tupar-s99tunit+&w.dsname(44),pwa_dsname\n    la    r14,&w.dsname                 |\n    st    r14,&s.dsntup_dsname          |\n    if    (cli,pwa_member,ne,c' ')      |   If MEMBER specified.\n      mvc   &w.member,da_member         |     Copy MEMBER text unit.\n      mvc   s99tupar-s99tunit+&w.member(8),pwa_member\n      la    r14,&w.member               |\n      st    r14,&s.dsntup_member        |\n    endif                               |   EndIf.\n    if    (cli,pwa_ddname,ne,c' ')      |   If DDNAME specified.\n      mvc   &w.ddname,da_ddname         |     Copy DDNAME text unit.\n      mvc   s99tupar-s99tunit+&w.ddname(8),pwa_ddname\n      la    r14,&w.ddname               |\n      st    r14,&s.dsntup_ddname        |\n    else                                |   Else\n      mvc   &w.ret_ddname,da_ret_ddname |     Set up return-DDNAME t.u.\n      la    r14,&w.ret_ddname           |\n      st    r14,&s.dsntup_ret_ddname    |\n    endif                               |   EndIf.\n    mvc   &w.ret_dsorg,da_ds_ret_dsorg  |   Set up return-DSORG t.u.\n    la    r14,&w.ret_dsorg              |\n    st    r14,&s.dsntup_ret_dsorg       |\n    mvc   &w.stat_shr,da_stat_shr       |   Set up DISP=SHR\n    la    r14,&w.stat_shr               |\n    st    r14,&s.dsntup_statshr         |\n    oi    &s.dsntup_final,x'80'         |   Set final text unit pointer\n    callsub dynalloc,(=al1(s99vrbal),   |   Use DSNAME allocation.     +\n               =al1(s99nomnt,0),        |    nomount,           @CNENQ +\n               =al4(0),                 |    No authorized flags.      +\n               pwa_err_msg,             |    Return message area.      +\n               =a(l'pwa_err_msg),       |    Length of message area.   +\n               pwa_err_msg_len,         |    Length of returned msg.   +\n               pwa_textunits),vl        |\n    if    (c,r15,lt,=f'&fi_error')      |   If allocation succeeded.\n      sbit  pwa_1,pwa_1_allocated       |     Allocation has been done.\n      sbit  pwa_2_free_on_terminate     |     Free on term if AUTOFREE.\n      mvi   pwa_status,pwa_status_shr   |     Using SHR.\n      mvi   pwa_ndisp,pwa_ndisp_keep    |     Defaulting to KEEP.\n      if (%l32,r1,&s.dsntup_ret_ddname,nz)\n        mvc pwa_ddname,s99tupar-s99tunit+&w.ret_ddname\n      endif                               | Endif.\n      lm    r1,r3,=a(da_dsorg_table,2+4,da_dsorg_table_e)\n      loop  bxle\n        leave loop=*,(clc,0(2,r1),eq,s99tupar-s99tunit+&w.ret_dsorg)\n      endloop bxle,r1,r2\n      mvc   pwa_dsorg,2(r1)             |     Copy char DSORG to pwa.\n      if (clc,=c'****',eq,pwa_dsorg)    |     If DSORG = undefined.\n        if  (cli,pwa_oo_mode,eq,&fi_oo_output) If OUTPUT mode.\n          mvc pwa_dsorg,=c'PS  '        |         Make it PS.\n        endif                           |       EndIf.\n      endif                             |     EndIf.\n      leave block=*                     |     Done with allocation.\n    elseif (tbit,pwa_1_ds_not_existing,OFF) ElseIf not DS not found\n      errexit code=0                    |     Return w/alloc error.\n    elseif (cli,pwa_oc_disp,eq,&fi_oc_existing),or,                    +\n               (cli,pwa_oo_mode,eq,&fi_oo_input)\n      errexit code=0                    |     Return w/alloc error.\n    endif                               |   EndIf.\n  endif                                 | EndIf.\n* *-------------------------------------------------------------------*\n* * If this request is for INPUT or for an EXISTING data set, it has\n* * failed.  If a DSNAME was specified, its already been taken care\n* * of and we never got here (see code a few lines above).\n* * The specified DDNAME (if any) is not allocated and the specified\n* * DSNAME (if any) does not already exist.\n* *-------------------------------------------------------------------*\n  if (cli,pwa_oo_mode,eq,&fi_oo_input),or,                             +\n               (cli,pwa_oc_disp,eq,&fi_oc_existing)\n    if (cli,pwa_dsname,ne,c' ')         |   If dsname specified.\n      errexit code=0                    |     Shouldn't get here.\n    elseif (cli,pwa_ddname,ne,c' ')     |   ElseIf ddname specified.\n      callsub message,(fi00026,pwa_ddname)    Issue an error message.\n      errexit code=0                    |     Exit w/error code.\n    else                                |   Else, ddname|dsname req'd\n      callsub message,(fi00011)         |     Issue an error message.\n      errexit code=0                    |     Exit w/error code.\n    endif                               |   EndIf.\n  endif                                 | EndIf.\n* *-------------------------------------------------------------------*\n* *                                                                   *\n* * The specified file must be created.                               *\n* *                                                                   *\n* * NOTE: Caller-supplied text-units do get used here                 *\n* *                                                                   *\n* *-------------------------------------------------------------------*\n  sbit    pwa_1_ds_not_existing         | dataset not pre-existing.\n  mvi     pwa_status,pwa_status_new     | Creating a NEW dataset.\n  callsub suggest_blocksize,            | Suggest a blocksize based    +\n               (pwa_avglrecl,           | on the device we probably    +\n               6,                       | will be allocated on.        +\n               pwa_volser,              |                              +\n               pwa_suggested_blksize)   |\n  l       r1,pwa_maxlrecl               | r1 := lrecl value.\n  if      (tbit,pwa_recfm,dcbrecf)      | If RECFM=F\n   if     (c,r1,gt,pwa_suggested_blksize)  If lrecl > blksize\n    st    r1,pwa_suggested_blksize      |   Bump blksize.\n   endif                                |  EndIf.\n  else                                  | Else, RECFM = V\n   la     r1,4(,r1)                     |\n   if     (c,r1,gt,pwa_suggested_blksize)  If lrecl+4 > blksize\n    st    r1,pwa_suggested_blksize      |   Bump blksize.\n   endif                                |  EndIf.\n  endif                                 | EndIf.\n* *-------------------------------------------------------------------*\n* * Create the internally supplied text units for this allocation.\n* *-------------------------------------------------------------------*\n  fill  pwa_textunits,x'00'          | Clear garbage out of tup list.\n  la    r7,pwa_textunits             | r7 -> textunit pointer array.\n  using &s.newtup,r7                 | Overlay with new ds pointers.\n  mvc   &w.dsorg,da_dsorg            | Copy default DSORG=PS textunit.\n  mvc   pwa_dsorg,=c\"PS   \"          | Indicate PS in pwa.\n  la    r14,&w.dsorg                 | Add dsorg\n  st    r14,&s.newtup_dsorg          |\n* *\n* * If a DDNAME was specified, use it.  Otherwise, let the system\n* * generate one and return it in &w.ret_ddname.\n* *\n  if (cli,pwa_ddname,ne,c' ')        | If ddname specified.\n    mvc   &w.ddname,da_ddname        |   Copy DDNAME text unit.\n    mvc   s99tupar-s99tunit+&w.ddname(8),pwa_ddname\n    la    r14,&w.ddname              |\n    st    r14,&s.newtup_ddname       |\n  else                               | Else.\n    mvc   &w.ret_ddname,da_ret_ddname    Set up return-DDNAME t.u.\n    la    r14,&w.ret_ddname          |   Add ret_ddname\n    st    r14,&s.newtup_ret_ddname   |\n  endif                              | EndIf.\n* *\n* * If a dataset name was supplied, allocate a new data set with that\n* * name.  Include the member name text unit as well if a member name\n* * was specified.  If no data set name was provided, let the system\n* * generate one and return it in &w.ret_dsname.\n* *\n  if (cli,pwa_dsname,ne,c' ')        | If dsname specified.\n    mvc   &w.dsname,da_dsname        |   Copy DSNAME text unit.\n    mvc   s99tupar-s99tunit+&w.dsname(44),pwa_dsname\n    la    r14,&w.dsname              |   Add dsn=dsname\n    st    r14,&s.newtup_dsname       |\n    if (cli,pwa_member,ne,c' ')      |   If member specified.\n      mvc   &w.dsorg+6(2),da_PO      |     Set DSORG textunit to PO.\n      mvc   pwa_dsorg,=c\"PO   \"      |     Indicate PO in pwa.\n      mvc   &w.member,da_member      |     Copy MEMBER text unit.\n      mvc   s99tupar-s99tunit+&w.member(8),pwa_member\n      la    r14,&w.member            |     Add member\n      st    r14,&s.newtup_member     |\n      mvc   &w.dirblks,da_dirblks    |\n      la    r14,&w.dirblks           |     Add dirblks\n      st    r14,&s.newtup_dirblks    |\n    endif                            |   EndIf.\n  else                               | Else: filetemp | sysout | etc.\n    mvc   &w.ret_dsname,da_ret_dsname_al  Set up return-DSNAME t.u.\n    la    r14,&w.ret_dsname          |    Add ret_dsname\n    st    r14,&s.newtup_ret_dsname   |\n  endif                              | EndIf.\n* *\n* * If this is a SYSOUT file, specify sysout and do not any text units\n* * that would normally be used to allocate space on disk.  For all\n* * other files, provide those things instead.\n* *\n  if (cli,pwa_oc2_sysoutx,eq,&fi_oc2_sysout),or,                       +\n               (cli,pwa_sysoutclass,ne,c' ')\n    mvc   &w.sysout,da_sysout        |   Set up SYSOUT textunit.\n    la    r14,&w.sysout              |   Add sysout\n    st    r14,&s.newtup_sysout       |\n  else                               | Else\n    callsub suggest_blockcounts,        |                              +\n               (pwa_suggested_blksize,  |                              +\n               pwa_avglrecl,            |                              +\n               pwa_sizeinit,            |                              +\n               pwa_sizeincr,            |                              +\n               pwa_primary_blocks,      |                              +\n               pwa_secondary_blocks)    |\n    mvc   &w.statnew,da_statnew      |\n    la    r14,&w.statnew             |   Add disp=new\n    st    r14,&s.newtup_statnew      |\n    mvc   &w.conddisp,da_conddisp    |\n    la    r14,&w.conddisp            |   Add conditional disposition\n    st    r14,&s.newtup_conddisp     |\n    mvc   &w.blkalloc,da_blkalloc    |\n    mvc   s99tupar-s99tunit+&w.blkalloc(3),pwa_suggested_blksize+1\n    la    r14,&w.blkalloc            | Add blkalloc\n    st    r14,&s.newtup_blkalloc     |\n    mvc   &w.prispace,da_prispace\n    mvc   s99tupar-s99tunit+&w.prispace(3),pwa_primary_blocks+1\n    la    r14,&w.prispace            |   Add primary space allocation\n    st    r14,&s.newtup_prispace     |\n    mvc   &w.secspace,da_secspace\n    mvc   s99tupar-s99tunit+&w.secspace(3),pwa_secondary_blocks+1\n    la    r14,&w.secspace            |   Add secondary space allocation\n    st    r14,&s.newtup_secspace     |\n    mvc   &w.unit,da_unit            |\n    la    r14,&w.unit                |   Add unit=SYSALLDA or WKUNIT\n    st    r14,&s.newtup_unit         |\n  endif                              | EndIf.\n* *\n* * Determine the normal disposition of the data set: if a dsname was\n* * provided that does not start with an ampersand ('&') and FILETEMP\n* * was not specified, use DISP=CATLG.  Otherwise, consider it a\n* * temporary work data set and use DISP=DELETE.  SYSOUT files cannot\n* * specify a disposition (mutually exclusive text-units).\n* *\n  if (clc,&s.newtup_sysout,eq,=f'0') | If NOT a SYSOUT file.\n    if (cli,pwa_dsname,ne,c' '),     |   If DSNAME specified and is not+\n               and,(cli,pwa_dsname,ne,c'&&'),        temporary, and if +\n               and,(cli,pwa_oc_filetempx,ne,&fi_oc_filetemp)  \u00acFILETEMP\n      mvc &w.normdisp,da_normdisp    |     Set normal disp=catlg.\n      mvi pwa_ndisp,pwa_ndisp_catlg  |     Allocating with CATLG.\n    else                             |   Else\n      mvc &w.normdisp,da_normdispdel |     Set normal disp=delete.\n      mvi pwa_ndisp,pwa_ndisp_delete |     Allocating with DELETE.\n    endif                            |   EndIf.\n    la  r14,&w.normdisp              |     Add normal disposition\n    st  r14,&s.newtup_normdisp       |      text unit.\n  endif                              | EndIf.\n* *\n* * Fill in remaining text units used for all new allocations.\n* *\n  mvc   &w.blksize,da_blksize\n  mvc   s99tupar-s99tunit+&w.blksize(2),pwa_suggested_blksize+2\n  la    r14,&w.blksize               | Add blksize\n  st    r14,&s.newtup_blksize        |\n  mvc   &w.lrecl,da_lrecl            | Copy LRECL textunit.\n  if    (tbit,pwa_1_vb),or,          | If we want VB in created        +\n               (clc,pwa_avglrecl,ne,pwa_maxlrecl)    dataset.\n    mvc s99tupar-s99tunit+&w.lrecl(2),pwa_maxlrecl+2   Desired LRECL.\n    mvc &w.recfm,da_recfm_vb         |                 Set RECFM = VB.\n    if (cli,pwa_oc2_cc,eq,&fi_oc2_isocc) If ISOCC requested:\n      mvc  &w.recfm,da_recfm_vba     |    Set RECFM=VBA.\n    endif                            |   Endif.\n  else                               | Else (we want FB).\n    mvc s99tupar-s99tunit+&w.lrecl(2),pwa_avglrecl+2   Desired LRECL.\n    mvc &w.recfm,da_recfm_fb         |                 Set RECFM = FB.\n    if (cli,pwa_oc2_cc,eq,&fi_oc2_isocc)   If ISOCC requested:\n      mvc  &w.recfm,da_recfm_fba     |     Set RECFM=FBA.\n    endif                            |   Endif.\n  endif                              | EndIf.\n  la    r14,&w.lrecl                 | Add lrecl\n  st    r14,&s.newtup_lrecl          |\n  la    r14,&w.recfm                 | Add recfm\n  st    r14,&s.newtup_recfm          |\n* *-------------------------------------------------------------------*\n* * Append the caller's list (if any) of text unit pointers to ours.\n* * Any duplicates of text units we supply can replace ours.\n* *-------------------------------------------------------------------*\n  la r6,&s.newtup_final              | r6 -> last internal text unit.\n  la r5,&s.newtup_final              | r5 -> current final tu pointer.\n  l  r2,fi_info                      | r2 -> INFO parameter.\n  la r2,0(,r2)                       | Clear high-order bit.\n  if (treg,r2,nz)                    | If INFO was specified.\n    loop until                       |   Loop thru INFO parmlist\n      l  r3,0(r2)                    |     Get a parm address\n      la r3,0(r3)                    |     Clear its VL bit\n      if (treg,r3,nz)                |     If non-null pointer then.\n        la r15,&s.newtup             |       r15 -> 1st text unit ptr.\n        loop while,(cr,r15,le,r6)    |       loop over internal tup's.\n          l  r1,0(,r15)              |         r1 -> text unit.\n          la r1,0(,r1)               |         Clear high-bit.\n          if (treg,r1,nz)            |         If TUP not null.\n            if (clc,0(2,r1),eq,0(r3))            If same text unit keys\n              st    r3,0(r15)        |             Use theirs instead.\n              slr   r3,r3            |             Done with this one.\n              leave loop=*           |             Quit looking.\n            endif                    |           EndIf.\n          endif                      |         EndIf.\n          la  r15,4(,r15)            |         r15 -> Next TU pointer.\n        endloop while                |       EndLoop.\n      endif                          |     EndIf.\n      if (treg,r3,nz)                |     If still non-null then.\n        if (c,r5,gt,pwa_textunits_end)       If textunit list full\n          callsub message,(fi00035,50)         Max # exceeded.\n          errexit code=0             |         Return w/error.\n        endif                        |       EndIf.\n        st r3,4(,r5)                 |         Stuff in DYNALLOC parms\n        la r5,4(,r5)                 |         Update to last TU ptr.\n      endif                          |       EndIf.\n      leave loop=*,(tbit,0(r2),x'80')      Leave if that was the end.\n      la    r2,4(,r2)                |     Update INFO list pointer.\n    endloop until,leave              |   EndLoop.\n  endif                              | EndIf.\n  sbit    0(r5),x'80'                | Mark final textunit pointer.\n* *-------------------------------------------------------------------*\n* * Invoke dynamic allocation to create the output data set.\n* *-------------------------------------------------------------------*\n   l    r3,&s.newtup_unit            | Set addr of UNITNAME\n   st   r3,pwa_unitname_textunit     |  textunit (for error msg. later)\n   callsub dynalloc,(=al1(s99vrbal), | Use dsname allocation.          +\n               =al1(s99nomnt,0),     | nomount,                 @CNENQ +\n               =al4(0),              | no authorized flags.           2+\n               pwa_err_msg,          | Return message area.           3+\n               =a(l'pwa_err_msg),    | Length of message area.        4+\n               pwa_err_msg_len,      | Length of returned msg.        5+\n               pwa_textunits),vl     | Text unit pointer list.        6\n   if (c,r15,ge,=f'&fi_error')       | If allocation failed.\n     errexit code=0                  |   Exit w/error message.\n   endif                             | EndIf.\n   sbit  pwa_1,pwa_1_allocated       | Allocation has been done.\n   sbit  pwa_2_free_on_terminate     | Free on terminate if AUTOFREE.\n* *-------------------------------------------------------------------*\n* * Retrieve information from ret_ text units that were specified.\n* *-------------------------------------------------------------------*\n   if (%l32,r1,&s.newtup_ret_ddname,nz)\n     mvc pwa_ddname,s99tupar-s99tunit+&w.ret_ddname\n   endif                               | Endif.\n   if (%l32,r1,&s.newtup_ret_dsname,nz)\n     mvc  pwa_dsname,s99tupar-s99tunit+&w.ret_dsname\n   endif                               | Endif.\n endblk block=Allocate_File\n                 swa\n&w.blkalloc      ds  cl(l'da_blkalloc)     |\n&w.blksize       ds  cl(l'da_blksize)      |\n&w.conddisp      ds  cl(l'da_conddisp)     |\n&w.ddname        ds  cl(l'da_ddname)       |\n&w.dirblks       ds  cl(l'da_dirblks)      |\n&w.statnew       ds  cl(l'da_statnew)      |\n&w.dsname        ds  cl(l'da_dsname)       |\n&w.dsorg         ds  cl(l'da_dsorg)        |\n&w.lrecl         ds  cl(l'da_lrecl)        |\n&w.member        ds  cl(l'da_member)       |\n&w.normdisp      ds  cl(l'da_normdisp)     |\n&w.normdispdel   ds  cl(l'da_normdispdel)  |\n&w.prispace      ds  cl(l'da_prispace)     |\n&w.recfm         ds  cl(l'da_recfm_fb)     |\n&w.ret_attrs     ds  cl(l'da_ret_attrs)    |\n&w.ret_ddname    ds  cl(l'da_ret_ddname)   |\n&w.ret_dsname    ds  cl(l'da_ret_dsname)   |\n&w.ret_dsorg     ds  cl(l'da_ds_ret_dsorg) |\n&w.ret_member    ds  cl(l'da_ret_member)   |\n&w.ret_ndisp     ds  cl(l'da_ret_ndisp)    |\n&w.ret_status    ds  cl(l'da_ret_status)   |\n&w.secspace      ds  cl(l'da_secspace)     |\n&w.stat_shr      ds  cl(l'da_stat_shr)     |\n&w.sysout        ds  cl(l'da_sysout)       |\n&w.unit          ds  cl(l'da_unit)         |\n                 endswa                    |\n&s.dsntup             dsect   Text unit ptrs (plist) for existing alloc\n&s.dsntup_dsname      ds a          |  dsname.\n&s.dsntup_member      ds a          |  member name.\n&s.dsntup_ddname      ds a          |  ddname.\n&s.dsntup_statshr     ds a          |  status = new.\n&s.dsntup_ret_ddname  ds a          |  return ddname.\n&s.dsntup_ret_dsorg   ds a          |  return dsorg.\n&s.dsntup_final       equ *-4       | Final pointer (internal)\n*\n&s.newtup             dsect   Text unit ptrs (plist) for new ds alloc\n&s.newtup_ddname      ds a          |  ddname.\n&s.newtup_dsname      ds a          |  dsname.\n&s.newtup_member      ds a          |  member name.\n&s.newtup_sysout      ds a          |  sysout specification.\n&s.newtup_dirblks     ds a          |  directory blocks\n&s.newtup_ret_dsname  ds a          |  return dsname\n&s.newtup_ret_ddname  ds a          |  return ddname\n&s.newtup_statnew     ds a          |  status = new.\n&s.newtup_normdisp    ds a          |  normal disp=<catlg|delete>\n&s.newtup_conddisp    ds a          |  cond disp=delete\n&s.newtup_blkalloc    ds a          |  SPACE=(blksize,\n&s.newtup_prispace    ds a          |          (primary,\n&s.newtup_secspace    ds a          |          secondary))\n&s.newtup_dsorg       ds a          |  DSORG = PS or PO.\n&s.newtup_unit        ds a          |  UNIT = SYSDA(*default*)\n&s.newtup_lrecl       ds a          |  LRECL = <calculated>.\n&s.newtup_blksize     ds a          |  BLKSIZE = <calculated>.\n&s.newtup_recfm       ds a          |  RECFM = FB or VB.\n&s.newtup_final       equ *-4       | Final pointer (internal)\n&srv_modname        csect ,\n\n              eject\n***********************************************************************\n*                                                                     *\n*  Subroutine: DYNALLOC                                               *\n*                                                                     *\n*  Abstract:   This routine builds a dynamic allocation request       *\n*              block, invokes DYNALLOC, and constructs a message      *\n*              describing the results of the operation.               *\n*                                                                     *\n*  Parameters: (Verb,Flag1,Flag2,MsgArea,AreaLen,MsgLen,TextUnit1,... *\n*                                                                     *\n*              The parameter list passed to this routine *must* be    *\n*              terminated with a 1 in the high-order bit of the last  *\n*              parameter, and must contain at least one textunit.     *\n*                                                                     *\n*              Parameter  Description                                 *\n*              ---------  ------------------------------------------- *\n*              Verb       Value to use for S99VERB.                   *\n*              Flag1      Value to use for S99FLAG1.                  *\n*              Flag2      Value to use for S99FLAG2.                  *\n*              MsgArea    Area in which to build Info/Error message.  *\n*              AreaLen    Length of MsgArea.                          *\n*              MsgLen     Length of resulting message.                *\n*              TextUnits  List of text-unit pointers, with final      *\n*                         pointer denoted by 1 in hoigh order bit.    *\n*                                                                     *\n*  Return Codes: R15 = return code implied by the message issued.     *\n*                                                                     *\n***********************************************************************\n block type=subroutine,name=dynalloc\n*---------------------------------------------------------------------*\n*  Build the DYNALLOC request block and invoke dynamic allocation.\n*---------------------------------------------------------------------*\n   lr      r8,r1                  | R8 -> Parameter list passed in.\n   fill    &w.rb,x'00'            | Clear request block to zeros.\n   la      r7,&w.rb               | R7 -> Dynamic allocation RB.\n   using   s99rb,r7               | Establish addressability.\n   mvi     s99rbln,20             | Set request block's length.\n   lm      r1,r3,0(r8)            | R1,2,3 -> Verb,Flag1,Flag2.\n   mvc     s99verb,0(r1)          | Copy allocation VERB.\n   mvc     s99flag1,0(r2)         | Copy allocation FLAGS1 field.\n   mvc     s99flag2,0(r3)         | Copy allocation FLAGS2 field.\n   l       r1,6*4(,r8)            | R1 -> Text Unit pointers.\n   la      r1,0(,r1)              | Clear high-order bit.\n   st      r1,s99txtpp            | Set text unit pointers address.\n*                                 |\n   plist    (s99rb),vl            | R1 -> RB pointer -> Request block.\n   dynalloc ,                     | Invoke dynamic allocation.\n   leave    block=*,(treg,r15,z)  | Return if successful.\n   eject\n*---------------------------------------------------------------------*\n*  Analyze DYNALLOC's error and reason codes to form a message.\n*---------------------------------------------------------------------*\n   if (c,r15,eq,=f'8')            | If denied by installation exit.\n     callsub message,(fi00109)    |   Allocation denied.\n     leave   block=*              |   Return to caller.\n   endif                          | EndIf.\n*                                 |\n   l16 r1,s99error                | Set R1 to the error code.\n   n   r1,=x'00000f00'            | Isolate error code's class.\n   l16 r0,s99error                | Put error code in register.\n*                                 |\n   if  (ch,r0,eq,=x'0204')        | If not enough storage.\n     callsub message,(fi00009)    |   Issue an error message.\n   elseif (ch,r0,eq,=x'0210')     | ElseIf allocated to another user.\n     callsub message,(fi00110,pwa_dsname)\n   elseif (ch,r0,eq,=x'0218')     | ElseIf no acceptable volumes\n     callsub message,(fi00122)    |\n   elseif (ch,r0,eq,=x'021c')     | ElseIf invalid unitname\n     fill  pwa_unitname,c' '          | Clear working unitname\n     l     r14,pwa_unitname_textunit  | Get textunit address\n     lh    r15,4(,r14)                | Get unitname length\n     bctr  r15,0                      | Fix length for EXECUTE\n     exi   r15,(mvc,pwa_unitname(0),6(r14))   VL move for unitname\n     callsub message,(fi00123,pwa_unitname)   Issue error message.\n   elseif (ch,r0,eq,=x'0220')     | ElseIf volume not available\n     callsub message,(fi00124,pwa_volser)\n   elseif (ch,r0,eq,=x'035C')     | ElseIf invalid PARM value.\n     l16 r2,s99info               |   R2 := key of bad text unit.\n     if (ch,r2,eq,=al2(daldsnam)) |   If bad data set name.\n       callsub message,(fi00002,pwa_dsname)\n     else                         |   Else.\n       callsub message,(fi00113,s99error,s99info)\n     endif                        |   EndIf.\n   elseif (ch,r0,eq,=x'043C')     | ElseIf too-many-datasets.\n     callsub message,(fi00121)    |   Issue an error message.\n   elseif (ch,r0,eq,=x'0238')     | ElseIf TIOT is full.\n     callsub message,(fi00121)    |   Issue an error message.\n   elseif (ch,r0,eq,=x'47AC')     | ElseIf RACF failure on DEFINE.\n     callsub message,(fi00120,pwa_userid,\"CREATE\",6,pwa_dsname)\n   elseif (ch,r1,eq,=x'0700')     | ElseIf a class 7 error code.\n     if (cli,s99error,eq,x'17')   |   If a LOCATE error.\n       if (cli,s99error+1,eq,x'08')     if could not find file.\n         callsub message,(fi00111,pwa_dsname)\n         sbit  pwa_1,pwa_1_ds_not_existing\n       else                       |     Else.\n         callsub message,(fi00113,s99error,s99info) dynalloc error.\n       endif                      |     EndIf.\n     elseif (cli,s99error,eq,x'47')   elseif a dasdm allocate error.\n         callsub message,(fi00113,s99error,s99info) dynalloc error.\n     elseif (cli,s99error,eq,x'57')   elseif a catalog error.\n       callsub message,(fi00113,s99error,s99info) dynalloc error.\n     elseif (cli,s99error,eq,x'67')   elseif an obtain error.\n       callsub message,(fi00113,s99error,s99info) dynalloc error.\n     elseif (cli,s99error,eq,x'77')   elseif a subsystem error.\n       callsub message,(fi00113,s99error,s99info) dynalloc error.\n     elseif (cli,s99error,eq,x'87')   elseif a scheduler jcl error.\n       callsub message,(fi00113,s99error,s99info) dynalloc error.\n     else                         |   Else.\n       callsub message,(fi00113,s99error,s99info) unknown error.\n     endif                        |   EndIf.\n   else                           | Else.\n     callsub message,(fi00112,pwa_dsname,s99error,s99info)\n   endif                          | EndIf.\n*\n*  The last operation before this point was a call to MESSAGE, so R15\n*  has been set to the return-code we want.\n*\n endblk block=dynalloc\n*---------------------------------------------------------------------*\n* Working storage for invoking DYNALLOC.\n*---------------------------------------------------------------------*\n                swa\n&w.rb           ds   cl(s99rbend-s99rb)   | DYNALLOC request block.\n                endswa\n aif (not &security_check).skip4\n          eject\n***********************************************************************\n*                                                                     *\n*  Subroutine: Security_Check,(ACCESS)                                *\n*  Abstract  : Attempt to see if the current user/group has access to *\n*              the file about to be opened.  This check is done to    *\n*              avoid abend 913s.  If the check cannot be done, just   *\n*              continue on and hope for the best.                     *\n*                                                                     *\n***********************************************************************\n block type=subroutine,name=security_check,parms=(Access),             +\n               options=(*swa,(parms,prefix,(using,r8)))\n*---------------------------------------------------------------------*\n*  Use RACROUTE to determine if the current userid has access to the\n*  data set about to be opened.  If not, issue a message and don't\n*  open it.\n*---------------------------------------------------------------------*\n   l  r5,&spl.Access                     | R5 -> C\"Access type\".\n   la r5,0(,r5)                          | Clear high-order bit.\n   if (clc,=c\"READ\",eq,0(r5))            | If checking READ access.\n     la    r4,=f'4'                      |   r4 -> length of READ.\n     la    r2,x'02'                      |   r2 := X'02' for READ.\n   elseif (clc,=c\"ALTER\",eq,0(r5))       | ElseIf ALTER access.\n     la    r4,=f'5'                      |   r4 -> length of ALTER.\n     la    r2,x'80'                      |   r2 := X'04' for ALTER.\n   elseif (clc,=c\"UPDATE\",eq,0(r5))      | ElseIf UPDATE access.\n     la    r4,=f'6'                      |   r4 -> length of UPDATE.\n     la    r2,x'04'                      |   r2 := X'04' for UPDATE.\n   elseif (clc,=c\"CONTROL\",eq,0(r5))     | ElseIf CONTROL access.\n     la    r4,=f'7'                      |   r4 -> length of CONTROL.\n     la    r2,x'08'                      |   r2 := X'04' for CONTROL.\n   else                                  | Else....just use READ....\n     la    r5,=c\"READ\"                   |   r5 -> \"READ\".\n     la    r4,=f'4'                      |   r4 -> length of READ.\n     la    r2,x'02'                      |   r2 := X'02' for READ.\n   endif                                 | EndIf.\n*                                        |\n   mvc &w.racroute,&s.racroute           | Copy RACROUTE parm list.\n   racroute    entity=(pwa_dsname),      |                             +\n               volser=pwa_volser,        | Check access authority to   +\n               attr=(r2),                | the data set about to be    +\n               request=AUTH,             | opened for input or output. +\n               worka=&w.rac_workarea,    |                             +\n               mf=(e,&w.racroute)        |\n   leave       block=*,(treg,r15,z)      | Return if access is okay.\n   leave       block=*,(c,r15,eq,=f'4')  | Return if not denied.\n   stm         r15,r0,&w.codes           | Save return/reason codes.\n   if          (c,r15,eq,=f'8')          | If access was denied.\n     callsub message,(fi00120,pwa_userid,(r5),(r4),pwa_dsname)\n     errexit code=0                      |\n   else                                  | Else, unexpected returncode.\n     callsub message,(fi00036,pwa_dsname,&w.codes,&w.codes+4)\n     errexit code=0                      |\n   endif                                 | EndIf.\n endblk block=security_check\n*---------------------------------------------------------------------*\n* Local constants and variables for checking dataset authorization.\n*---------------------------------------------------------------------*\n                ssd\n&s.racroute     racroute mf=l,request=AUTH,class=\"DATASET\",dstype=N\n&s.racroute_l   equ      *-&s.racroute\n                endssd\n                swa\n&w.codes        ds      2f\n&w.rac_workarea ds      cl512\n&w.racroute     ds      cl(&s.racroute_l)\n                endswa\n.skip4 anop\n eject                                |\n***********************************************************************\n*                                                                     *\n*  Subroutine: Read_JFCB                                              *\n*  Abstract:   Read a copy of the dataset's JFCB into the PWA.        *\n*  NOTICE:     THIS ROUTINE SHOULD NOT DO ANYTHING ELSE.              *\n*                                                                     *\n***********************************************************************\n block type=subroutine,name=read_jfcb,amode=&srvfios_iosub_amode\n   la    r8,pwa_dcb                   | r8 -> working DCB storage.\n   using ihadcb,r8                    | Establish addressability.\n*                                     |\n   if    (clc,=c'PO',eq,pwa_dsorg)    | If looking at a PDS.\n     mvc pwa_podcb,psd_podcb          |  Copy static po DCB to swa\n   else                               | Else, it must be sequential.\n     mvc pwa_psdcb,psd_psdcb          |  Copy static ps DCB to swa\n   endif                              | EndIf.\n   la    r0,pwa_dcbe                  | Put address of\n   st    r0,pwa_dcb+dcbdcbe-ihadcb    | DCBE in DCB.\n*                                     |\n   mvc   dcbddnam(8),pwa_ddname       | Stuff w/DDname\n   la    r1,pwa_jfcb                  | Set up for RDJFCB:\n   st    r1,pwa_exlst                 | Build exitlist of 1 entry,\n   mvi   pwa_exlst,x'87'              | (type 07 w/ VL bit)\n   la    r1,pwa_exlst                 |  and set exlst address in DCB.\n   stcm  r1,b'0111',dcbexlsa          |\n   mvc   &w.rdjfcb,&s.rdjfcb          | Copy RDJFCB parms to SWA\n   block amode=&srvfios_iocall_amode  |\n    rdjfcb pwa_dcb,mf=(e,&w.rdjfcb)   | Copy JFCB to our storage\n    lr     r5,r15                     |\n   endblk                             |\n   if    (treg,r5,nz)                 | If it didn't work,\n    callsub message,                  |  OPEN wouldn't work either.    +\n               (fi00102,pwa_dsname)   |  Issue error message.\n    errexit code=0                    |\n   endif                              |\n   la    r7,pwa_jfcb                  | Base on JFCB\n   using infmjfcb,r7                  |\n   sbit  jfcbtsdm,jfcnwrit            | Don't write JFCB back to SWA\n endblk block=read_jfcb\n               ssd    ,                   |\n&s.rdjfcb      rdjfcb *-*,mf=l            |\n&s.rdjfcb_l    equ    *-&s.rdjfcb         |\n               endssd ,                   |\n               swa    ,                   |\n&w.rdjfcb      ds     cl(&s.rdjfcb_l)     |\n               endswa ,                   |\n eject\n***********************************************************************\n*                                                                     *\n*  Subroutine: Does_Member_Exist                                      *\n*  Abstract:   Determine using BPAM FIND whether a member exists.     *\n*              On exit, R15 = zero if member found, else R15 = 8.     *\n*              The dataset's JFCB must already be read in with PO.    *\n*  NOTICE:     THIS ROUTINE SHOULD NOT DO ANYTHING ELSE.              *\n*                                                                     *\n***********************************************************************\n block name=does_member_exist,type=subroutine,                         +\n               amode=&srvfios_iosub_amode,options=codebase\n   la    r8,pwa_dcb                   | r8 -> PO dcb connected to JFCB.\n   using ihadcb,r8                    | Establish addressability.\n   la    r7,pwa_jfcb                  | r7 -> JFCB already read in.\n   using infmjfcb,r7                  | Establish addressability.\n   mvc   jfcbelnm,=cl8' '             | Clear the member name.\n   mvc   pwa_open,psd_open            | Copy OPEN parm list to PWA.\n   block amode=&srvfios_iocall_amode  |\n     open  (pwa_dcb,input),type=j,mf=(e,pwa_open),                     +\n               mode=&srvfios_open_mode\n   endblk                             |\n   if (tbit,dcboflgs,dcbofopn,off)    | If OPEN failed.\n     callsub message,(fi00102,pwa_dsname) Issue an error message.\n     errexit code=0                   |    Exit with error-code.\n   endif                              | Endif.\n   block amode=&srvfios_iocall_amode  |\n     find  pwa_dcb,pwa_member,d       | Make BPAM find member\n     lr    r2,r15                     | Copy returncode before CLOSE\n     if    (treg,r2,nz)               | If it wasn't zero\n       la    r2,8                     |  force it to be 8.\n     endif                            |\n     plist (pwa_dcb),vl               | Set parms in working stg.\n     close (pwa_dcb),mf=(e,(1)),      | Close PO DCB                   +\n               mode=&srvfios_open_mode\n     callsub free_buffer_pool,(pwa_dcb)   Free its buffer pool\n   endblk                             |\n endblk rc=(r2)                       | Return the answer.\n         eject                        |\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Suggest_Blocksize\n*  Abstract:   This routine will attempt to derive a blocksize that\n*              will efficiently fit <n> blocks on a track, using the\n*              average record length provided by the caller.\n*  Inputs:     On entry, R1 points to the following parameter list:\n*                +0 -- Address of average record length (fullword)\n*                +4 -- Requested number of blocks per track (fullword)\n*                +8 -- Address of volume for target device or spaces\n*                +c -- Address of fullword to return blocksize into\n*  Outputs:    Result fullword at parmlist+c% filled in\n*  Special\n*  Notes:      . This routine uses DEVTYPE, and hopefully uses the\n*                right method for determining an optimum blocksize.\n*              . This routine presently uses #_blks_per_track (an\n*                equate) for carving up a DASD track.\n*---------------------------------------------------------------------*\n         space 1                      |\n block name=suggest_blocksize,type=subroutine\n  lm    r3,r6,0(r1)                   | Load up parameters\n  mvi   &w.f1,x'00'                   |\n  la    r7,&w.devtype_results         | Base on DEVTYPE answer area\n  l     r2,cvtptr                     |  Base on CVT\n  using cvt,r2                        |\n  using dvarea,r7                     |\n  if    (clc,=cl6' ',eq,0(r5))        | If no volume provided,\n   mvc   dvatrkln,=al2(47476)         |  Assume 3380 tracklength,\n   mvc   &w.ucbad,cvtsysad            |   devicetype of what we IPLed\n  else                                | Otherwise look up volume's UCB:\n   loop  until                        |  Loop calling IOSVSUCB:\n    l     r15,cvtucbsc                |\n    callx (r15),(&w.ucbwa,=al1(ucb3dacc),&w.ucbad)\n    leave loop=*,(treg,r15,nz)        |   Leave if no more UCBs\n    l     r3,&w.ucbad                 |   Get returned UCB address\n    using ucbob,r3                    |\n    if    (clc,ucbvoli,eq,0(r5))      |   If we found our volume\n     st    r3,&w.ucbad                |    Save UCB address for TRKCALC\n     sbit  &w.f1,&w.f1hit             |     and note that we found it.\n     leave loop=*                     |\n    endif                             |\n   endloop until,leave                |\n   drop  r2,r3                        | Drop CVT, UCB bases\n   if    (tbit,&w.f1,&w.f1hit,off)    | If we didn't find the volume\n    callsub message,(fi00030,&w.volser)  it isn't mounted.\n    errexit code=0                    |\n   endif                              |\n   mvc   &w.devtype(len_devtype),&s.devtype  now we can issue devtype.\n   devtype  ,(&w.devtype_results,24),  |                               +\n               ucblist=(&w.ucbad,1),  |                                +\n               mf=(e,&w.devtype)      |\n   if    (treg,r15,nz)                |\n    st   r15,pwa_save_r15             | Preserve r15 for errexit\n    callsub message,(fi00028)         |  don't try division with it.\n    l    r15,pwa_save_r15             | Rest r15 for debug analysis\n    errexit code=0                    |\n   endif                              |\n  endif                               |\n* *-------------------------------------------------------------------*\n* * DEVTYPE returned the track size. We know the average recordlength.\n* * Determine how large a block must be to fit 4 on a track.  Since\n* * together DEVTYPE and TRKCALC aren't too smart, we have to loop\n* * asking TRKCALC 'how about this one' til we get the answer we want.\n* *-------------------------------------------------------------------*\n  l16   r1,dvatrkln                   | Watch it: this is unsigned!\n  l32   r0,0(r4)                      | Check # blocks per track:\n  if    (z)                           | If it's zero,\n   callsub message,(fi00028)          |  don't try division with it.\n   errexit code=0                     |\n  endif                               |\n  l32   r0,0(r3)                      | Check average LRECL:\n  if    (z)                           | If it's zero,\n   callsub message,(fi00029)          |  don't try division with it.\n   errexit code=0                     |\n  endif                               |\n  xr    r0,r0                         | Clear R0 before division\n  d     r0,0(r4)                      | Divide by # blocks per track:\n*                                     |  R1 now = 1/4 track length.\n  xr    r0,r0                         | Clear R0 before division\n  d     r0,0(r3)                      | Divide by average LRECL:\n*                                     |  R1 now = # recs per block.\n  m     r0,0(r3)                      | R1 is now trimmed blocksize.\n  lr    r2,r1                         | Copy to R2 to save past TRKCALC\n  mvc   &w.trkcalc(len_trkcalc),&s.trkcalc\n  l     r14,&w.ucbad                  |   Get returned UCB address\n  using ucbob,r14                     |\n  mvc   pwa_UCBTBYT4,UCBTBYT4         |  Copy device type to PWA field.\n  drop  r14                           |  Drop UCB addressing.\n  loop  until                         |\n   trkcalc     functn=trkcap,         |  Will this one fit like we     +\n               type=pwa_UCBTBYT4,     |   want?                        +\n               dd=(r2),               |                                +\n               r=1,                   |                                +\n               regsave=yes,           |                                +\n               mf=(e,&w.trkcalc)      |\n   if    (treg,r15,nz)                |\n    st   r15,pwa_save_r15             | Preserve r15 for errexit\n    callsub message,(fi00028)         |\n    l    r15,pwa_save_r15             | Restore r15 for debug analysis\n    errexit code=0                    |\n   endif                              |\n   leave loop=*,(c,r0,ge,0(r4))       |  If hit, leave loop.\n   s     r2,0(r3)                     |  Knock some off the LRECL\n  endloop until,leave                 | and try again.\n  st    r2,0(r6)                      | Only a suggestion.\n  drop  r7                            |\n  xr    r15,r15                       |\n endblk rc=(r15)                      |\n         space 1                      |\n  ssd   ,                             |\n&s.devtype devtype ,(*,*),ucblist=yes,mf=l\nlen_devtype equ     *-&s.devtype      |\n&s.trkcalc trkcalc mf=l               |\nlen_trkcalc equ     *-&s.trkcalc      |\n  endssd ,                            |\n         space 1                      |\n  swa   ,                             |\n&w.devtype ds    0f,cl(len_devtype)   |\n&w.trkcalc ds    0f,cl(len_trkcalc)   |\n&w.devtype_results ds    6f           |\n&w.ucbad   ds    a                    |\n&w.ucbwa   ds    cl100                |\n&w.volser  ds    cl6                  |\n&w.f1      ds    x                    |\n&w.f1hit   equ   x'80'                |\n  endswa ,                            |\n         eject                        |\n*---------------------------------------------------------------------*\n*\n*  Subroutine: suggest_blockcounts (blksize,avglrecl,recsinit,recsincr,\n*                              priblks,secblks)\n*              will efficiently fit <n> blocks on a track, using the\n*  Abstract:   Compute primary and secondary block counts (priblks and\n*              secblks) for a new data set allocation based on the\n*              specified blocksize, average record length, and expected\n*              data set sizes (recsinit and recsincr).\n*---------------------------------------------------------------------*\n block type=subroutine,name=suggest_blockcounts,                       +\n               options=(*swa,loadbase,(parms,(using,r5),prefix)),      +\n               parms=(blksize,avglrecl,recsinit,                       +\n               recsincr,priblks,secblks)\n   l     r1,&spl.blksize             |\n   l     r1,0(,r1)                   | r1 = blocksize.\n   l     r2,&spl.avglrecl            | r2 -> average record length.\n   xr    r0,r0                       | Clear R0 before division.\n   d     r0,0(,r2)                   | R1 = records per block.\n*                                    |\n   l     r3,&spl.recsinit            |\n   l     r3,0(,r3)                   | r3 := initial #records.\n   xr    r2,r2                       | Clear R2 before division.\n   dr    r2,r1                       | R3 = # blocks primary.\n   if    (treg,r2,nz)                | If there was a remainder\n     la    r3,1(r3)                  |   Round up the quotient.\n   endif                             | EndIf.\n   l     r14,&spl.priblks            | r14 -> primary blocks parm.\n   st    r3,0(,r14)                  | Save primary allocation blks\n*\n   xr    r2,r2                       | Clear R2 before division.\n   l     r14,&spl.secblks            | r14 -> primary blocks parm.\n   st    r2,0(,r14)                  | Set secondary #blks = 0.\n   l     r3,&spl.recsincr            |\n   l32   r3,0(r3)                    | r3 := record increment amount.\n   if    (nz)                        | If secondary space requested.\n     dr    r2,r1                     |   r3 := recsincr/(recs per blk)\n     if    (treg,r2,nz)              |   If there was a remainder.\n       la    r3,1(r3)                |     Round up the quotient.\n     endif                           |   EndIf.\n     st    r3,0(,r14)                |   R3 = # blocks secondary\n   endif                             | EndIf.\n endblk block=suggest_blockcounts\n         eject                        |\n*---------------------------------------------------------------------*\n*\n*  Subroutine: SPFEDIT_ENQ\n*  Abstract:   This routine will attempt to ENQ on major name SPFEDIT,\n*              minor name of the dataset and member name.  This routine\n*              should be called whenever a PDS member is opened OUTPUT.\n*  Inputs:     On entry, R1 points to the following parameter list:\n*                +0 -- Address of dataset name\n*                +4 -- Address of member name\n*  Outputs:    R15 = 0 if ENQ was successful\n*              R15 = 8 if ENQ was held by another user\n*  Special\n*  Notes:      None.\n*\n*---------------------------------------------------------------------*\n         space 1                      |\n block name=spfedit_enq,type=subroutine\n  lm    r2,r3,0(r1)                   |\n  mvc   &w.enq(l_enq),&s.enq          |\n  fill  &w.rname,c' '                 |\n  mvc   &w.rname(44),0(r2)            |\n  mvc   &w.rname+44(8),0(r3)          |\n  enq   (,&w.rname),mf=(e,&w.enq)     |\n  if    (treg,r15,nz)                 |\n   la    r15,8                        |\n  else                                |\n   sbit pwa_2,pwa_2_member_enq        |\n  endif                               |\n endblk rc=(r15)                      |\n     ssd   ,                          |\n&s.enq   enq   (psd_spfedit,*-*,e,52,systems),ret=use,mf=l\nl_enq    equ   *-&s.enq               |\n     endssd ,                         |\n     swa   ,                          |\n&w.enq   ds    0f,cl(l_enq)           |\n&w.rname ds    cl52                   |\n     endswa ,                         |\n         eject                        |\n*---------------------------------------------------------------------*\n*\n*  Subroutine: SPFEDIT_DEQ\n*  Abstract:   This routine will DEQ unconditionally on major name\n*              SPFEDIT, minor name of the dataset and member name.\n*              should be called whenever a PDS member is opened OUTPUT.\n*  Inputs:     On entry, R1 points to the following parameter list:\n*                +0 -- Address of dataset name\n*                +4 -- Address of member name\n*  Outputs:    None.\n*  Special\n*  Notes:      None.\n*\n*---------------------------------------------------------------------*\n         space 1                      |\n block name=spfedit_deq,type=subroutine\n  lm    r2,r3,0(r1)                   |\n  mvc   &w.deq(l_deq),&s.deq          |\n  fill  &w.rname,c' '                 |\n  mvc   &w.rname(44),0(r2)            |\n  mvc   &w.rname+44(8),0(r3)          |\n  deq   (,&w.rname),mf=(e,&w.deq)     |\n  rbit  pwa_2,pwa_2_member_enq\n endblk\n     ssd   ,\n&s.deq   deq   (psd_spfedit,*-*,52,systems),ret=have,mf=l\nl_deq    equ   *-&s.deq\n     endssd ,\n     swa   ,\n&w.deq   ds    0f,cl(l_deq)\n&w.rname ds    cl52\n     endswa ,\n     eject ,\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Free_Buffer_Pool\n*  Abstract:   This routine serves as an intelligent FREEPOOL, taking\n*              into account that the File Handler may have been running\n*              in key zero (hence subpool 0 is actually subpool 252).\n*  Inputs:     On entry, R1 points to the following parameter list:\n*                +0 -- Address of DCB to free buffers for.\n*  Outputs:    Buffers freed\n*  Special\n*  Notes:      See below.\n*\n*---------------------------------------------------------------------*\n         SPACE 1\n block type=subroutine,name=free_buffer_pool,                          +\n               amode=&srvfios_iocall_amode\n         SPACE 1\n* *-------------------------------------------------------------------*\n* *  Even though OPEN acquired our QSAM buffer pool for us, we are\n* *  responsible for freemaining it.  Worse, if we are running in\n* *  key0/supv state, the buffers must be freemained from subpool\n* *  252 instead of zero. Unfortunately, the FREEPOOL macro is not\n* *  smart enough to handle this, so we must hardcode the FREEPOOL\n* *  code ourselves.  The buffer control block pointed to by the\n* *  DCB describes the storage to be freemained.  (There is no\n* *  mapping macro for the BUFCB.)\n* *-------------------------------------------------------------------*\n* *  Format of BUFCB:\n* *    +0 -- Addr of buffer area (follows the BUFCB)\n* *    +4 -- Flags. X'40' sez the BUFCB is 16 bytes long.\n* *    +5 -- No. of buffers\n* *    +6 -- Length of 1 buffer\n* *-------------------------------------------------------------------*\n  l     r5,0(r1)                      | Get DCB address from parameters\n  using ihadcb,r5                     |\n  l24   r4,dcbbufca                   | Get BUFCB address\n  leave block=*,(z),or,               | Leave if address is zero or    *\n               (tbit,dcbbufca+2,x'01')   already marked invalid\n  oi    dcbbufca+2,x'01'              | Mark DCBBUFCA invalid\n  l8    r3,5(r4)                      | Get no. of buffers\n  mh    r3,6(r4)                      | Times buffer size\n  la    r3,8(r3)                      | Include length of header\n  if    (tbit,4(r4),x'40')            | 16-byte header?\n   la    r3,8(r3)                     |  Add that in, too.\n  endif                               |\n* *-------------------------------------------------------------------*\n* *  If we are running in key zero, any storage acquired in subpool\n* *  zero will actually be in subpool 252.\n* *-------------------------------------------------------------------*\n*                                     |  Are we supervisor state?\n  testauth     fctn=0,                |     (Don't look at APF bit)    *\n               state=yes,             |     (Require supv. state)      *\n               rblevel=1              |\n  if    (treg,r15,z)                  | If so, check PSW key:\n*  *------------------------------------------------------------------*\n*  * TESTAUTH sez we're in supervisor state.\n*  *------------------------------------------------------------------*\n   xr    r2,r2                        |  IPK puts key in R2 bits 24-27\n   ipk   ,                            |   leaving the rest of R2 alone.\n   if    (treg,r2,z)                  |  If R2 is still zero:\n*   *-----------------------------------------------------------------*\n*   * Supervisor state, key zero.  Set up FREEMAIN for subpool 252.\n*   *-----------------------------------------------------------------*\n    icm   r3,b'1000',=al1(252)        |   Freemain from subpool 252.\n   endif                              |\n  else                                | Otherwise (prob state, key=??)\n   testauth    fctn=0,                |  See what kinda key we're in   *\n               key=yes,               |     (Require system key)       *\n               rblevel=1              |\n   if    (treg,r15,z)                 |  If a system key, see if key 0.\n*   *-----------------------------------------------------------------*\n*   * Problem state, but an authorized key.\n*   *-----------------------------------------------------------------*\n    xr    r2,r2                       |  Clear R2 before IPK uses it\n    modeset mode=sup                  |  Make the IPK inst. work\n    ipk   ,                           |  Get the PSW key\n    modeset mode=prob                 |  That's enough of that.\n    if    (treg,r2,z)                 |  If R2 is still zero, we need\n*    *----------------------------------------------------------------*\n*    * Problem state, key zero.  Set up FREEMAIN for subpool 252.\n*    *----------------------------------------------------------------*\n     icm   r3,b'1000',=al1(252)       |   to freemain from subpool 252.\n    endif                             |\n   endif                              |\n  endif                               |\n  lr    r0,r3                         | Copy subpool/length\n  lr    r1,r4                         | Copy area address\n  freemain r,lv=(0),a=(1)             | Free those buffers.\n  drop  r5                            | Drop DCB base\n endblk                               | That's it.\n         eject                        |\n***********************************************************************\n*                                                                     *\n*  Subroutine: EOF                                                    *\n*  Abstract:   Set the end-of-file indicator.                         *\n*  NOTE:       AMODE = whatever it is entered with.                   *\n*                                                                     *\n***********************************************************************\n block name=eof,type=subroutine,options=(*nosubopts,custom)\n   balr  r15,0                        |\n   using *,r15                        |\n   sbit  pwa_1,pwa_1_eof              |\n   bsm   0,r14                        |\n   drop  r15                          |\n endblk block=eof                     |\n space 1                              |\n***********************************************************************\n*                                                                     *\n*  Subroutine: SYNAD                                                  *\n*  Abstract:   Handle an OS input/output error.                       *\n*                                                                     *\n***********************************************************************\n block name=synad,type=subroutine,amode=&srvfios_iocall_amode,         +\n               options=codebase\n   synadaf acsmeth=qsam            |\n   l       r13,4(,r13)             | R13 -> PWA.\n   la      r2,50(,r1)              | R2 -> Synad message text.\n   l16     r3,0(r1)                | R3 := Length of message buffer.\n   sh      r3,=h'50'               | R3 := length of message text.\n*                                  |\n   la      r4,pwa_err_msg          | R4 -> PWA storage for message.\n   la      r5,l'pwa_err_msg        | R5 := Length of message storage.\n   l       r15,fi00202             | R15 -> SYNAD message prefix.\n   la      r14,4(r15)              | R14 -> message prefix text.\n   l       r15,0(r15)              | R15 := message prefix length.\n   if      (cr,r5,gt,r15)          | If enough storage for entire msg.\n     lr    r5,r15                  |   Use exact length.\n   endif                           | EndIf.\n   st      r5,pwa_err_msg_len      | Save length before doing MVCL.\n   mvcl    r4,r14                  | Copy message prefix to the PWA.\n*                                  |\n   la      r5,l'pwa_err_msg        | R5 := Length of message storage.\n   s       r5,pwa_err_msg_len      | R5 := Remaining length.\n   if      (cr,r5,gt,r3)           | If enough storage for entire msg.\n     lr    r5,r3                   |   Use exact length.\n   endif                           | EndIf.\n   l       r1,pwa_err_msg_len      | R1 := message prefix length.\n   ar      r1,r5                   | Add SYNAD message's length.\n   st      r1,pwa_err_msg_len      | Save length before doing MVCL.\n*                                  |\n   mvcl    r4,r2                   | Copy message prefix to the PWA.\n*                                  |\n   l       r13,8(,r13)             | R13 -> SYNAD's save area.\n   synadrls                        | Release the SYNAD data areas.\n   sbit    pwa_1,pwa_1_error          |\n endblk block=synad                   |\n             eject\n*---------------------------------------------------------------------*\n*\n*  Subroutine: MESSAGE\n*  Abstract:   Format a message and exit the program.\n*\n*---------------------------------------------------------------------*\n block type=subroutine,name=message\n   lr  r2,r1                       | R2 -> Parameter list.\n   l   r4,0(r2)                    | R4 -> Message's ADCON.\n   l   r4,0(r4)                    | R4 -> Message Length, Text.\n*---------------------------------------------------------------------*\n*  Invoke the string-formatter to put together the message.\n*  Bypass ST_FORMAT for FI00000I: issued mucho times and not formatted\n*---------------------------------------------------------------------*\n   mvi &w.formatted,c'N'           | Message not yet formatted.\n   if (clc,pwa_st_sptoken,ne,=f'0')   if string-handler is started.\n     lr    r1,r2                   |    R1 -> parm before 1st arg.\n     loop  while,(tbit,0(r1),x'80',off) while not at last parameter.\n       la    r1,4(,r1)             |     Advance to next parameter.\n     endloop while                 |    EndLoop.\n     sr        r1,r2               |    R1 := length of plist.\n     srl       r1,2                |    R1 := number of source args.\n     st        r1,&w.count         |    Save #arguments for ST_FORMAT.\n     es_clear_debug_info id=es,action=inhibit\n     st_format id=st,string=pwa_err_msg,resultlen=pwa_err_msg_len,     +\n               control=(4(r4),0(r4)),sourcelist=(4(r2),&w.count)\n     if        (%st_success)       |   If successful format.\n       mvi  &w.formatted,c'Y'      |     Set formatted-flag.\n       la   r0,pwa_err_msg         |     Formatted message text.\n       la   r1,pwa_err_msg_len     |     Length of formatted msg.\n       stm  r0,r1,pwa_msg_data     |     Save address/length\n     else                          |   Else.\n       sth             r15,&w.rc   |     Save bad return-code.\n       es_save_debug_info id=es,text=\"ST_FORMAT failed while attempting+\n                to format a message: return code follows.\"\n       es_save_debug_info id=es,hex=(&w.rc,=a(l'&w.rc)),label=\"RETCODE\"\n       es_save_debug_info id=es,text=(4(r4),0(r4)),label=\"MESSAGE\"\n       es_display_debug_info id=es\n     endif                            |   EndIf.\n     es_clear_debug_info id=es,action=enable\n   endif                           | EndIf.\n*---------------------------------------------------------------------*\n*  If the message could not be formatted, use the unformatted version.\n*---------------------------------------------------------------------*\n   if (cli,&w.formatted,ne,c'Y')   | If message not formatted.\n    la    r1,4(,r4)                |\n    st    r1,pwa_msg_data+0        |  Save address of text.\n    st    r4,pwa_msg_data+4        |  Save address of length.\n   endif                           | EndIf.\n*---------------------------------------------------------------------*\n*  Set R15 = return-code associated with the new message.\n*---------------------------------------------------------------------*\n   l  r1,pwa_msg_data              | r1 -> message text.\n   if (cli,7(r1),eq,c\"I\")             | If an information msg, then.\n     slr r15,r15                      |   Exit with zero return-code.\n   elseif (cli,7(r1),eq,c\"W\")      | If a warning message, then.\n     la r15,&fi_warning               |   Exit with the warning-code.\n   elseif (cli,7(r1),eq,c\"E\")      | ElseIf an error message, then.\n     la r15,&fi_error                 |   Exit with the error-code.\n   elseif (cli,7(r1),eq,c\"X\")      | ElseIf invalid filename.\n     la  r15,&fi_invalid_syntax       |   Exit with the syntax-code.\n     mvi 7(r1),c'e'                   |   Change msg-severity to 'E'.\n   elseif (cli,7(r1),eq,c\"S\")      | ElseIf an error message, then.\n     la r15,&fi_severe                |   Exit with the severe-code.\n   else                               | Else\n     la r15,&fi_critical              |   Exit with the critical-code.\n   endif                              | EndIf.\n endblk block=message\n*---------------------------------------------------------------------*\n* Working storage for formatting messages.\n*---------------------------------------------------------------------*\n            swa\n&w.count      ds     f                | Number of SOURCE arguments.\n&w.rc         ds     h                | ST_FORMAT return-code.\n&w.formatted  ds     c                | Successful format = Y.\n            endswa\n eject\n***********************************************************************\n*                                                                     *\n*  Error exit for all functions in the file handler.                  *\n*                                                                     *\n***********************************************************************\n block type=errexit,amode=&srvfios_iosub_amode\n*---------------------------------------------------------------------*\n*  Save module/offset and registers.\n*---------------------------------------------------------------------*\n   stm   r0,r15,gdiregs          | Save registers at time of error.\n   sm_lal r0,&srv_modname+4       | Point to module identification.\n   st    r0,gdimodid             | Save in general debug area.\n   if    (clc,=h'0',eq,0(r14))   | If CODE=00, then.\n     sth r15,gdirc               |   Use R15 for final return code.\n   else                          | Else.\n     mvc gdirc,0(r14)            |   Set return code = CODE.\n   endif                         | EndIf.\n   sl    r14,=a(&srv_modname)    | Calculate offset at time of error.\n   sth   r14,gdioffst            | Save in debug area.\n   es_save_debug_info id=es,gdi=gdi\n*---------------------------------------------------------------------*\n*  Check the return-code, and save the debugging message accordingly.\n*---------------------------------------------------------------------*\n   lh    r3,gdirc                | R3 := return-code.\n   if    (c,r3,ge,=f'&fi_error') | If an error or worse.\n     sbit pwa_1,pwa_1_error          Remember it.\n   endif                         | EndIf.\n   caseblk reg=r3,mult=1         | Case on return-code.\n     case &fi_success,           |   Success (Information msg).        +\n               &fi_warning,      |   Warning message.                  +\n               &fi_error,        |   Error message.                    +\n               &fi_severe,       |   Severe error message.             +\n               &fi_invalid_syntax,   Error (Syntax) message.           +\n               &fi_critical,     |   Critical error message.           +\n               &fi_end_of_file\n       la r4,pwa_err_msg         |     R4 -> Formatted message text.\n       la r5,pwa_err_msg_len     |     R5 -> Length of formatted msg.\n     case &fi_invalid_fileid     |   Bad token value.\n       l  r5,fi00001             |     R5 -> Length of message.\n       la r4,4(r5)               |     R4 -> Message text.\n     case other                  |   Unknown error-code.\n       l  r5,fi00003             |     R5 -> Length of message.\n       la r4,4(r5)               |     R4 -> Message text.\n   endcase                       | EndCase.\n   stm   r4,r5,pwa_msg_data      | Save address/length of message.\n   es_save_debug_info id=es,text=((r4),(r5))\n*---------------------------------------------------------------------*\n*  Set the final return-code and exit.\n*---------------------------------------------------------------------*\n   lh    r15,gdirc               |\n endblk\n eject\n*---------------------------------------------------------------------*\n*\n*  Static Data\n*\n*---------------------------------------------------------------------*\n               psd\n               ltorg\neyecatcher     dc     c\"FIOS\"               | PWA-block eyecatcher.\n*---------------------------------------------------------------------*\n*\n*  DCBs\n*\n*---------------------------------------------------------------------*\npsd_podcb_str  dcb    ddname=--------,dsorg=po,macrf=(r,w),dcbe=*-*\npsd_podcb      equ    psd_podcb_str,*-psd_podcb_str\npsd_psdcb_str  dcb    ddname=--------,dsorg=ps,macrf=(r),dcbe=*-*\npsd_psdcb      equ    psd_psdcb_str,*-psd_psdcb_str\npsd_gldcb_str  dcb    ddname=--------,macrf=(gl),dsorg=ps,dcbe=*-*\npsd_gldcb      equ    psd_gldcb_str,*-psd_gldcb_str\npsd_pldcb_str  dcb    ddname=--------,macrf=(pl),dsorg=ps,dcbe=*-*\npsd_pldcb      equ    psd_pldcb_str,*-psd_pldcb_str\npsd_dcbe_str   dcbe   synad=synad,eodad=eof\npsd_dcbe       equ    psd_dcbe_str,*-psd_dcbe_str\n*---------------------------------------------------------------------*\npsd_open_str   open   *-*,mf=l,             | OPEN parameter-list.     +\n               mode=&srvfios_open_mode\npsd_open       equ    psd_open_str,*-psd_open_str\n         read   psd_decb_start,sf,*-*,mf=l\npsd_decb equ    psd_decb_start,*-psd_decb_start\npsd_spfedit    dc     cl8\"SPFEDIT \"         | spf-edit qname.\n*---------------------------------------------------------------------*\n*  Static data for dynamic allocation (SVC 99) of OS data sets.\n*---------------------------------------------------------------------*\nda_sysout        text_unit dalsysou\nda_ddname        text_unit dalddnam,cl8\" \"       ddname=<blanks>\nda_dsname        text_unit daldsnam,cl44\" \"      dsname=<blanks>\nda_member        text_unit dalmembr,cl8\" \"       member=<blanks>\nda_stat_shr      text_unit dalstats,x\"08\"        disp=shr\nda_ret_ddname    text_unit dalrtddn,cl8\" \"       return ddname.\nda_ds_ret_dsorg  text_unit dalrtorg,xl2\"0000\"    return dsorg.\n*\nda_ir_ddname     text_unit dinddnam,cl8\" \"       ddname=<blanks>\nda_ir_ret_dsorg  text_unit dinrtorg,xl2\"0000\"    return dsorg.\nda_ret_dsname    text_unit dinrtdsn,cl44\" \"      return dsname.\nda_ret_dsname_al text_unit dalrtdsn,cl44\" \"      return dsname (alloc).\nda_ret_member    text_unit dinrtmem,cl8\" \"       return member.\nda_ret_status    text_unit dinrtsta,X\"00\"        return status.\nda_ret_ndisp     text_unit dinrtndp,X\"00\"        return normal disp.\nda_ret_attrs     text_unit dinrtatt,x\"00\"        return attributes  @DD\nda_statnew       text_unit dalstats,x\"04\"        disp=(new,\nda_normdisp      text_unit dalndisp,x\"02\"              catlg,\nda_normdispdel   text_unit dalndisp,x\"04\"              delete,\nda_conddisp      text_unit dalcdisp,x\"04\"              delete)\nda_blkalloc      text_unit dalblkln,x\"000000\"    space=(blocksize,\nda_prispace      text_unit dalprime,x\"000000\"           (primary,\nda_secspace      text_unit dalsecnd,x\"000000\"            secondary))\nda_dirblks       text_unit daldir,x\"00000A\"      10 dir blks.\nda_dsorg         text_unit daldsorg,x\"4000\"      dsorg=ps (x\"0200\"=po)\nda_lrecl         text_unit dallrecl,x\"0000\"      lrecl=<calculated>.\nda_blksize       text_unit dalblksz,x\"0000\"      blksize=<calculated>.\nda_recfm_fb      text_unit dalrecfm,b\"10010000\"  recfm=FB.\nda_recfm_vb      text_unit dalrecfm,b\"01010000\"  recfm=VB.\nda_recfm_fba     text_unit dalrecfm,b\"10010100\"  recfm=FBA.\nda_recfm_vba     text_unit dalrecfm,b\"01010100\"  recfm=VBA.\nda_unit          text_unit dalunit,cl5\"SYSDA\"    unit=sysda\n*\nda_dsorg_table   equ  *\nda_PO    dc   x'0200',c'PO  '   | Returned DSORG=PO.\n         dc   x'0300',c'POU '   | Returned DSORG=POU.\n         dc   x'4000',c'PS  '   | Returned DSORG=PS.\n         dc   x'4100',c'PSU '   | Returned DSORG=PSU.\n         dc   x'0000',c'****'   | Returned DSORG=****.\n         dc   x'0004',c'TR  '   | Returned DSORG=TCAM.\n         dc   x'0008',c'VSAM'   | Returned DSORG=VSAM.\n         dc   x'0020',c'TQ  '   | Returned DSORG=TCAM msg queue.\n         dc   x'0040',c'TX  '   | Returned DSORG=TCAM line group.\n         dc   x'0400',c'MQ  '   | Returned DSORG=Message Queue.\n         dc   x'0800',c'CQ  '   | Returned DSORG=DA Msg Queue.\n         dc   x'1000',c'CX  '   | Returned DSORG=Comm Line group.\n         dc   x'2000',c'DA  '   | Returned DSORG=Direct Access.\n         dc   x'2100',c'DAU '   | Returned DSORG=DAU.\n         dc   x'8000',c'IS  '   | Returned DSORG=ISAM.\n         dc   x'8100',c'ISU '   | Returned DSORG=ISAM Unmovable.\nda_dsorg_table_e equ  *\n         dc   x'FFFF',c'????'   | Entry picked for unknown DSORG.\nda_status_new    dc   x'04'     | Returned STATUS=NEW.\n*\n            macro\n&label      trantab\n            lcla &n\n&label      ds   0xl256        |\n.newrow     dc   al1(&n+0,&n+1,&n+2,&n+3,&n+4,&n+5,&n+6,&n+7)\n            dc   al1(&n+8,&n+9,&n+10,&n+11,&n+12,&n+13,&n+14,&n+15)\n&n          seta &n+16\n            aif  (&n lt 256).newrow\n            mend\nfold        trantab            | Translate tbl for uppercase conv.\n            org  fold+c\"a\"     | Fold lowercase 'a' - 'i'.\n            dc   c\"ABCDEFGHI\"  |\n            org  fold+c\"j\"     | Fold lowercase 'j' - 'r'.\n            dc   c\"JKLMNOPQR\"  |\n            org  fold+c\"s\"     | Fold lowercase 's' - 'z'.\n            dc   c\"STUVWXYZ\"   |\n            org  ,             |\nlettrdig    dc   256x'ff'      |      Letter or Digit\n            org  lettrdig+c\"A\" |\n            dc   9x\"00\"        |      --- 'ABCDEFGHI'\n            org  lettrdig+c\"J\" |\n            dc   9x\"00\"        |      --- 'JKLMNOPQR'\n            org  lettrdig+c\"S\" |\n            dc   8x\"00\"        |      --- 'STUVWXYZ'\n            org  lettrdig+c\"#\" |\n            dc   1x\"00\"        |      --- '#'\n            org  lettrdig+c\"$\" |\n            dc   1x\"00\"        |      --- '$'\n            org  lettrdig+c\"@\" |\n            dc   1x\"00\"        |      --- '@'\n            org  lettrdig+c\"0\" |\n            dc   10x\"00\"       |      --- '0123456789'\n            org  ,             |\n            eject\n*---------------------------------------------------------------------*\n* Messages are made up of a message identifier followed by a control\n* string.  The message identifier has the format\n*\n*   FInnnnns\n*\n* where the characters FI always begin a file-handler's message, nnnnn\n* is the unique message number, and s indicates the message's severity.\n*\n* Severity                  Meaning\n* --------   ---------------------------------------------\n*    I       Informational.\n*    W       Warning message.\n*    E       An error occurred.\n*    X       Filename syntactically invalid.\n*    S       Severe error.  Execution cannot continue.\n*    C       Critical error.  Indicates a probable programming error.\n*\n*---------------------------------------------------------------------*\n            macro\n            msg   &number,&severity,&text\n            lclc  &msgid,&oldloc\n&oldloc     setc  '&sysloc'\n&msgid      setc  'fi&number'\n&msgid      dc    a(msgt&sysndx)\nxsmsgs      loctr ,\nmsgt&sysndx dc    al4(msgl&sysndx),c'&msgid&severity',c' ',c&text\nmsgl&sysndx equ   *-msgt&sysndx-4\n&oldloc     loctr ,\n            mend\n*\n MSG 00000,I,\"Successful completion of last operation.\"\n MSG 00001,C,\"Invalid file identifier token.\"\n MSG 00002,X,\"Not a syntactically valid file name: {CL44 TRIM}.\"\n MSG 00003,C,\"Unknown error.\"\n*\n MSG 00004,C,\"Processing halted due to a previous error.\"\n MSG 00005,C,\"Invalid function-code parameter: {I}.\"\n MSG 00006,C,\"Wrong number of parameters for the {CL?} function.\"\n MSG 00007,C,\"Invalid OPTIONS value: B\"\"{BL?}\"\".\"\n MSG 00008,C,\"Sequential input (READLINE) requires INPUT access mode.\"\n MSG 00009,S,\"Not enough storage to operate.\"\n MSG 00010,S,\"Error obtaining memory for BPAM buffer.  RC={I}.\"\n*\n MSG 00011,X,\"No file name specified.\"\n MSG 00012,C,\"Sequential output (WRITELINE) requires OUTPUT access mode+\n               .\"\n MSG 00014,X,\"Null member name specified.\"\n MSG 00015,X,\"Member name is longer than {I} characters.\"\n MSG 00016,X,\"Invalid member name: {CL8 T}.\"\n MSG 00017,X,\"Invalid qualifier: {CL?}.\"\n MSG 00018,X,\"Data set name is longer than {I} characters: {CL? T}.\"\n MSG 00019,X,\"Qualifier in data set name is longer than 8 characters: {+\n               CL?}.\"\n MSG 00020,X,\"Zero length qualifier in data set name.\"\n MSG 00021,C,\"File name truncated in GET_NAME function.\"\n MSG 00022,C,\"Invalid information code ({I}) for the GET_INFO function.+\n               \"\n MSG 00023,C,\"Unable to load the String Handler (SRVSTR).\"\n MSG 00024,C,\"Unable to start the String Handler.\"\n MSG 00025,X,\"DDNAME is longer than {I} characters: {CL? T}.\"\n MSG 00026,E,\"DDNAME {CL8 TRIM} is not allocated to any file.\"\n MSG 00028,C,\"Internal error during blocksize calculation routine.\"\n MSG 00029,C,\"Average record length of zero is invalid.\"\n MSG 00030,E,\"Requested volume {CL6} is currently not available.\"\n MSG 00031,C,\"Invalid status code ({I}) for the SET_STATUS function.\"\n MSG 00032,C,\"Option EXISTING is required for INPUT files.\"\n MSG 00033,C,\"Options {CL?} are mutually exclusive.\"\n MSG 00034,C,\"RECORDLENGTH and FILESIZE parameters are for OUTPUT files+\n                only.\"\n MSG 00035,S,\"Maximum number of INFO parameters ({I}) exceeded.\"\n MSG 00036,S,\"Unexpected return code from RACHECK for dataset {CL44 TRI+\n               M}. RC={I} Reason={I}.\"\n MSG 00037,C,\"Option LIBRARY and specifying a member name in a file nam+\n               e are mutually exclusive.\"\n MSG 00038,C,\"Option LIBRARY is only valid for a PDS or PDSE.\"\n MSG 00039,C,\"FIND required before READLINE when option LIBRARY is used+\n               .\"\n MSG 00040,W,\"Member {CL8 TRIM} not found.\"\n MSG 00041,E,\"FIND failed for member {CL8 TRIM}. RC={I} Reason={I}.\"\n MSG 00042,S,\"Function {CL?} is only allowed if OPTION=LIBRARY is speci+\n               fied.\"\n MSG 00043,E,\"Error releasing memory for BPAM buffer.  RC={I}.\"\n MSG 00044,C,\"READLINE_LOCATE not supported for ASCII files.\"\n*\n MSG 00101,E,\"Unsupported data set organization ({CL4 T}) for {CL44 T}.+\n               \"\n MSG 00102,E,\"Open failed for data set {CL44 T}.\"\n MSG 00103,E,\"No member specified for PDS {CL44 T}.\"\n MSG 00104,E,\"Member {CL8 T} not in {CL44 T}.\"\n MSG 00107,E,\"Unsupported record format.\"\n MSG 00108,E,\"Data set {CL44 T} is not partitioned, but member {CL8 T} +\n               was specified.\"\n MSG 00109,E,\"Allocation to was denied by installation exit.\"\n MSG 00110,E,\"Data set {CL44 T} is allocated to another user.\"\n MSG 00111,E,\"Could not find data set {CL44 T}.\"\n MSG 00112,E,\"Could not allocate data set {CL44 T}: Dynamic Allocation *\n               error({XL2},{XL2}).\"\n MSG 00113,E,\"Dynamic allocation error ({XL2},{XL2}). \"\n MSG 00114,S,\"Function {CL?} not performed; file is not open.\"\n MSG 00115,S,\"Maximum RECORDLENGTH of {I} less than average RECORDLENGT+\n               H of {I}.\"\n MSG 00116,S,\"Requested record format inconsistent with that of existin+\n               g file.\"\n MSG 00117,E,\"PDS member {CL8 TRIM} in dataset {CL44 T} already exists +\n               and was not replaced.\"\n MSG 00118,E,\"Requested output LRECL of {IL2} for PDS member does not m+\n               atch existing PDS LRECL of {IL2}.\"\n MSG 00119,E,\"Member {CL8} is currently in use by another user.\"\n MSG 00120,E,\"User {CL7 T} has insufficient authority to {CL?} data set+\n                {CL44 T}.\"\n MSG 00121,E,\"Maximum number of allocations has been reached. Free unus+\n               ed files and try again.\"\n msg 00122,e,\"No acceptable volumes available for allocation.\"\n msg 00123,e,\"Requested unit name of {CL8 T} is not available.\"\n msg 00124,e,\"Requested volume {CL6 T} not available.\"\n msg 00125,e,\"Existing BLKSIZE of {I} not an even multiple of {I}.\"\n msg 00126,w,\"File is {CL?} OPEN: request denied.\"\n msg 00127,e,\"Unable to delete member {CL8 T} from {CL44 T}: STOW DELET+\n               E failed with RC={I}.\"\n msg 00128,e,\"Dataset {CL44 T} already exists and was not replaced.\"\n*\n MSG 00200,W,\"End of file.\"\n MSG 00201,E,\"{CL6 TRIM} record was truncated to {I} characters.\"\n MSG 00202,S,\"Synad error: \"\n MSG 00203,I,\"PUT {CL8} B={XL4} D={CL?}.\"\n*\n MSG 00300,I,\"Dataset {CL44 TRIM}{CL?}{CL8 TRIM}{CL?} {CL8 TRIM}.\"\n MSG 00301,I,\"Member {CL8 TRIM} {CL8 TRIM} in dataset {CL44 TRIM}.\"\n            endpsd\n            eject\n***********************************************************************\n*                                                                     *\n*  Program Work Area                                                  *\n*                                                                     *\n***********************************************************************\n                    pwa\npwa_visual          ds  cl(l'eyecatcher)\npwa_fileid          ds  a           | Unique file identifier.\npwa_esepa           ds  a           | Environment Support entry-point.\npwa_estkn           ds  f           | Environment Support token.\npwa_st_spepa        ds  a           | String Handler EPA.\npwa_st_sptoken      ds  f           | String Handler Token.\n*                                   |\npwa_1               ds  x           | Housekeeping/status flags.\npwa_1_allocated     equ b'10000000' |   File has been allocated.\npwa_1_open          equ b'01000000' |   File has been opened.\npwa_1_error         equ b'00100000' |   Processing halted due to error.\npwa_1_eof           equ b'00010000' |   End of file has been reached.\npwa_1_vb            equ b'00001000' |   Caller has requested VB output\npwa_1_fb            equ b'00000100' |   Caller has requested FB output\npwa_1_ds_not_existing equ b'00000010' | Requested dataset not found\npwa_1_member        equ b'00000001' |   Requested member exists in PDS\n*                                   |\npwa_2               ds  x           | More status flags:\npwa_2_member_enq    equ b'10000000' |   SPFEDIT ENQ done on member\npwa_2_sysinout      equ b'01000000' |   File is SYSIN | SYSOUT.\npwa_2_fios_supplies_dcb_attributes equ b'00100000'\npwa_2_concatenated  equ b'00010000' |   Allocation by DD is concat'd@DD\npwa_2_reference_supplied  equ b'00001000'  Reference supplied by caller\npwa_2_free_on_terminate   equ b'00000100'  Terminate should unallocate.\npwa_2_ascii               equ b'00000010'  File is ascii,caller ebcdic.\npwa_2_valid_find_active   equ b'00000001'  A valid find is active.\n*                                   |\npwa_oc_mode         ds  x           | Option: &FI_OC_ INPUT/OUTPUT.\npwa_oc_ident        ds  x           | Option: &FI_OC_ DSNAME/DDNAME.\npwa_oc_filetempx    ds  x           | Option: &FI_OC_ FILETEMP.\npwa_oc_disp         ds  x           | Opt: EXISTING/NEW/REPLACE/APPEND.\npwa_oc_recfm        ds  x           | Option: &FI_OC_ FIXED/VARIABLE.\npwa_oc_open         ds  x           | Option: &FI_OC_ AUTOOPEN/MANUAL*.\npwa_oc_xopt         ds  x           | Option: &FI_OC_XOPT BYTE/WORD.\npwa_oc2_cc          ds  x           | Option: &FI_OC2_ ISOCC.\npwa_oc2_free        ds  x           | Option: &FI_OC2_ AUTO/MANUAL.\npwa_oc2_sysoutx     ds  x           | Option: &FI_OC2_ SYSOUT.\npwa_oc2_chkpdsmemx  ds  x           | Option: &FI_OC2_ \u00ddNO\u00a8CHKPDSMEM.\npwa_oc2_library     ds  x           | Option: &FI_OC2_ \u00ddNO\u00a8LIBRARY.\npwa_oo_mode         ds  x           | Option: &FI_OO_ INPUT/OUTPUT.\n*                                   |\npwa_userid          ds  cl7         | Current userid, for messages.\npwa_spfedit_rname   equ *,52,c'c'   | RNAME for SPFEDIT pds members.\npwa_dsname          ds  cl44        |  Full dsn, padded w/blanks.\npwa_member          ds  cl8         |  Member name, padded w/blanks.\npwa_ddname          ds  cl8         | DDname allocated to dsname.\npwa_sysoutclass     ds  c           | SYSOUT(class) if OPTIONS(SYSOUT)\npwa_unitname        ds  cl8         | Unitname (only present for err)\npwa_volser          ds  cl6         | Volser of allocated file.\npwa_dsorg           ds  cl4         | DSORG returned by dynalloc.\npwa_recfm           ds  x           | Actual dataset RECFM.\npwa_lrecl           ds  f           | Actual dataset LRECL.\npwa_blksize         ds  f           | Actual dataset BLKSIZE.\n*  BPAM buffer entry related.\npwa_bent_count             ds h     |\npwa_bent_size              ds f     |\npwa_bent_buffer_size       ds f     |\npwa_bent_buffer_address    ds a     |\npwa_bent_current           ds a     |\npwa_bent_current_cursor    ds a     |\npwa_bent_current_remaining ds f     |\n*\npwa_status          ds  x           | Allocation status:\npwa_status_old      equ x'01'       |   OLD.\npwa_status_mod      equ x'02'       |   MOD.\npwa_status_new      equ x'04'       |   NEW.\npwa_status_shr      equ x'08'       |   SHR.\npwa_ndisp           ds  x           | Normal DISPosition value:\npwa_ndisp_uncatlg   equ x'01'       |   UNCATLG.\npwa_ndisp_catlg     equ x'02'       |   CATLG.\npwa_ndisp_delete    equ x'04'       |   DELETE.\npwa_ndisp_keep      equ x'08'       |   KEEP.\npwa_ndisp_pass      equ x'10'       |   PASS.\n*                                   |\npwa_dcb             ds   0d         | Storage for max size DCB.\npwa_podcb           ds   xl(l'psd_podcb)\n                    org pwa_dcb     |\npwa_psdcb           ds   xl(l'psd_psdcb)\n                    org pwa_dcb     |\npwa_gldcb           ds   xl(l'psd_gldcb)\n                    org pwa_dcb     |\npwa_pldcb           ds   xl(l'psd_pldcb)\n                    org ,           | Get back to right address.\n                    ds  0d          |\npwa_dcbe            ds  xl(l'psd_dcbe)\n                    ds  0d          |\npwa_open            ds  xl(l'psd_open) OPEN parameter list.\n*                                   |\npwa_current_record ds   a           | Address of next logical record.\n*                                   |\npwa_avglrecl        ds  f           | Average LRECL\npwa_maxlrecl        ds  f           | Max. LRECL (=AVG if RECFM=FB)\npwa_sizeinit        ds  f           | Initial record count\npwa_sizeincr        ds  f           | Incremental record count\n*                                   |\npwa_primary_blocks      ds  f       | Primary # blocks for allocation\npwa_secondary_blocks    ds  f       | Secondary # blocks for alloc.\n*                                   |\npwa_suggested_blksize   ds  f       | Suggested output BLKSIZE.\npwa_recs_per_block      ds  f       | Number of records per block.\n*                                   |\npwa_unitname_textunit   ds  a       | Address of caller's DALUNIT tu\n*                                   |\npwa_msg_data        ds  2f          | Address/length of message.\npwa_err_msg_len     ds  f           | Short description of error,\npwa_err_msg         ds  cl256       | Error, Warning, or Info msg.\n*                                   |\npwa_exlst           ds  f           | Exit-list for OPEN TYPE=J.\n                    es_gdi dsect=no |\npwa_jfcb            ds  cl176       | JFCB work-area.               @DD\npwa_fi_reference    ds  cl70        | FI_START reference string\npwa_UCBTBYT4        ds  cl(l'UCBTBYT4)  Device type from UCB.\npwa_save_r15        ds  f           | Field to temporarily contain R15\n                    ds  0f          | List of text unit pointers, with\npwa_textunits       ds  cl(50*4)    |   high bit set in final pointer.\npwa_textunits_end   ds  f\n                    endpwa          |\n                    eject           |\n***********************************************************************\n*  Buffer entry used for BPAM.\n***********************************************************************\n         vda gentype=dsect,id=bent_\nbent_decb       ds   xl(l'psd_decb)\nbent_next       ds   a\nbent_data_start ds   0d\nbent_fixed_len  equ  *-bent_start\n         endvda\n                    eject           |\n***********************************************************************\n*  Environment Support Vector DSECT\n***********************************************************************\n              es_esv  ,             |\n              eject                 |\n***********************************************************************\n*  MVS Router Parameter List used by RACROUTE.\n***********************************************************************\n              ichsafp ,             |\n              eject                 |\n***********************************************************************\n*  DEVTYPE return area DSECT\n***********************************************************************\n              ihadva ,              |\n***********************************************************************\n*  Dynamic allocation DSECTs\n***********************************************************************\n              iefzb4d0              |\n              iefzb4d2              |\n              eject                 |\n***********************************************************************\n*  Data set control block DSECT\n***********************************************************************\n              dcbd  dsorg=(ps,po)   |\n              org   ,               |\n              ds    0d              |\ndcblngmax     equ   *-ihadcb        |\n              iefucbob ,            |\njfcb          dsect                 | IEFJFCBN doesn't make a DSECT.\n              IEFJFCBN list=yes     |\n              cvt      dsect=yes    |\n              eject                 |\n***********************************************************************\n*  Parameter list for all file servers.\n***********************************************************************\n              fi_parmlist           |\n***********************************************************************\n              end ,                 |\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SRVFIPDF": {"ttr": 24579, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x02\\x00\\x00W\\x01\\x11)\\x9f\\x01\\x11)\\x9f\\t'\\x04/\\x04/\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@\"", "ispf": {"version": "02.00", "flags": 0, "createdate": "2011-10-26T00:00:00", "modifydate": "2011-10-26T09:27:57", "lines": 1071, "newlines": 1071, "modlines": 0, "user": "CLEMSON"}, "text": "*---------------------------------------------------------------------*\n*  Copyright 2011 by Clemson University Research Foundation           *\n*                                                                     *\n*  Licensed under the Apache License, Version 2.0 (the \"License\");    *\n*  you may not use this file except in compliance with the License.   *\n*  You may obtain a copy of the License in this library as member     *\n*  $LICENSE, or from                                                  *\n*                                                                     *\n*      http://www.apache.org/licenses/LICENSE-2.0                     *\n*                                                                     *\n*  Unless required by applicable law or agreed to in writing,         *\n*  software distributed under the License is distributed on an \"AS    *\n*  IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either    *\n*  express or implied.  See the License for the specific language     *\n*  governing permissions and limitations under the License.           *\n*---------------------------------------------------------------------*\n*---------------------------------------------------------------------*\n*\n*  COPYRIGHT (C) 1987 CLEMSON UNIVERSITY\n*\n*  Program     SRVFIPDF\n*\n*  Abstract    This server is the ISPF/PDF Edit file handler for\n*              program macros, and reads lines from the file currently\n*              being edited by ISPF/PDF Edit or from another member of\n*              the same PDS, if a PDS member is currently being edited.\n*              File-specifications recognized are:\n*\n*              null-string : the file being edited.\n*              *           : the file being edited.\n*              *(member)   : another member of the file.\n*\n*  Parameters:\n*    Two parameters, FileID and FunctionCode, are required for each\n*    call to the file manager.  Additional parameters are required for\n*    different FunctionCodes.  The entire parameter list required for\n*    each function is listed below.\n*\n*    START\n*     CALLX SRVFIPDF,(FileID,&START,ESV,Info,FileName,Length,Access)\n*\n*    TERMINATE\n*     CALLX SRVFIPDF,(FileID,&TERMINATE)\n*\n*    READLINE\n*     CALLX SRVFIPDF,(FileID,&FI_READLINE,Area,AreaSize,Length)\n*\n*    GET_INFO\n*     CALLX SRVFIPDF,(FileID,&FI_GET_INFO,InfoCode,**Info Dependent**)\n*                                       &FI_GI_NAME,Area,Size,NameLen)\n*                                       &FI_GI_MSG,Area,Size,MsgLen)\n*                                       &FI_GI_LRECL,Lrecl)\n*                                       &FI_GI_RECFM,Recfm)\n*                                       &FI_GI_IDSTRING,IdString)\n*\n*  The meaning of each parameter is explained below.\n*\n*    FileID is a fullword used to uniquely identify the opened file.\n*      It is initialized during the startup function.\n*\n*    FunctionCode is a fullword integer that specifies the function to\n*      be performed.  Symbolic identifiers are provided for each\n*      function and may be accessed by placing a COPY statement for\n*      SRVFIMAC in the assembler program.  These symbols should be\n*      used in place of actual integer values.  The following\n*      FunctionCodes are supported:\n*\n*      &FI_START\n*        Open a new file and assign to it a unique identifier:  FileID.\n*        In addition to the FileID and FunctionCode parameters, the\n*        parameters ESV, FileName, and NameLength are required. The\n*        parameter Info is ignored, but its position in the parameter\n*        list must be maintained.\n*\n*      &FI_TERMINATE\n*        Close the file and FileID to zeros.\n*\n*      &FI_READLINE\n*        Read the next line of the file into the provided as the Line\n*        parameter.  A maximum of MaxLength characters will be read\n*        into the area and the actual length of the line, including\n*        truncated characters if any, will be placed in parameter\n*        Length.  Return codes will be set to indicate truncation and\n*        end of file.\n*\n*      &FI_GET_INFO\n*        Return information, selected by InfoCode, about the file.  The\n*        following InfoCodes are supported:\n*\n*        &FI_GI_MSG\n*          Return the most-recently generated message in Area.  If the\n*          message is longer than Size, it will be truncated and no\n*          indication will be returned.  The size of the returned\n*          message (or Size, whichever is smaller) will be returned in\n*          the MsgLen parameter.\n*\n*\n*        &FI_GI_NAME\n*          Return the fully qualified data set name, including member\n*          name if the file is a PDS member.  The name will be returned\n*          in Area, and will be truncated to Size if neccessary.  The\n*          length of the file's name (or Size, whichever is smaller)\n*          will be returned in the NameLen parameter.  If truncation\n*          occurs, a message will be generated.\n*\n*        &FI_GI_LRECL\n*          Return the logical record length of the file as a signed\n*          halfword value in parameter Lrecl.\n*\n*        &FI_GI_RECFM\n*          Return an eight (8) byte character string describing the\n*          file's record format.  Currently, only the first character\n*          is used: it is 'F' for fixed length records and 'V' for\n*          varying length records.  All remaining characters are set to\n*          blanks.\n*\n*        &FI_GI_IDSTRING\n*          Return an eight (8) byte character string that can be used\n*          for identification purposes.  This string is not unique.\n*          For PDS members, IdString is the member name.  For\n*          sequential data sets, it is currently set to blanks.\n*\n*  Special     This server *must* be invoked from an ISPF/PDF Edit\n*  Notes       macro environment.\n*\n*              The program that uses this server should set CONTROL\n*              ERRORS RETURN to insure that a graceful shutdown can be\n*              done in the event of an ISPF severe error.  This server\n*              equipped to handle all return codes from ISPF services.\n*\n*  Program     reentrant, problem key and state, standard linkage,\n*  Attributes  non-authorized, amode(any), rmode(any)\n*\n*  Change\n*  History     06/26/87 MJM - NEW\n*\n*---------------------------------------------------------------------*\n EJECT\n COPY  SMSYMS                         | Structured macros symbols.\n COPY  SRVESMAC                       | Environment Support symbols.\n COPY  SRVFIMAC                       | File Handler symbols.\n COPY  SRVSTMAC                       | String Handler symbols.\n EJECT\n*---------------------------------------------------------------------*\n*\n*  Macro:      ISREDIT\n*  Purpose:    Invoke the ISREDIT service with an EDIT macro command.\n*\n*---------------------------------------------------------------------*\n         MACRO\n         ISREDIT &COMMAND,&MAXRC=0\n         GBLC    &PWA\n         LCLC    &LENGTH,&BUFFER\n&BUFFER  SETC    'TXT&SYSNDX'\n&LENGTH  SETC    '=A(L''&BUFFER)'\n         PSD     TYPE=PARTIAL\n&BUFFER  DC      C&COMMAND\n         ENDPSD\n         CALLX   ISPLINK,(ISREDIT,&LENGTH,&BUFFER)\n         ST      R15,&PWA.ERR_REF\n         IF      (C,R15,GT,=A(&MAXRC))\n           MESSAGE (XP00008,&PWA.ERR_REF,&BUFFER,&LENGTH)\n         ENDIF\n         MEND\n*---------------------------------------------------------------------*\n*\n*  Macro:      TRIM\n*  Purpose:    Set R15 := the length of a string with trailing blanks\n*              removed.\n*\n*---------------------------------------------------------------------*\n         MACRO\n         TRIM &ADDR,&LEN\n         LA   R14,&ADDR             | R14 -> Start of string.\n         L    R15,&LEN              | R15 := Length of string.\n         ALR  R15,R14               | R15 -> Past end of string.\n         LOOP UNTIL                 | Loop backwards over string.\n           BCTR R15,0               |   Back up by one character.\n         ENDLOOP UNTIL,((CR,R15,LT,R14),OR,(CLI,0(R15),NE,C' '))\n         LA      R15,1(,R15)        | R15 -> Past final non-blank.\n         SLR     R15,R14            | R15 := trimmed length.\n         MEND\n*---------------------------------------------------------------------*\n*\n*  Macro:      MESSAGE (condition),(parameters)\n*              MESSAGE (parameters)\n*  Purpose:    Conditionally invoke the message subroutine.\n*\n*---------------------------------------------------------------------*\n         MACRO\n         MESSAGE\n         AIF   (N'&SYSLIST EQ 1).CALL\n         AIF   (N'&SYSLIST EQ 2).COND\n         MNOTE 8,'WRONG NUMBER OF PARMS'\n.CALL    CALLSUB MESSAGE,&SYSLIST(1)\n         MEXIT\n.COND    IF   &SYSLIST(1)\n           CALLSUB MESSAGE,&SYSLIST(2)\n         ENDIF\n         MEND\n EJECT\n***********************************************************************\n**                                                                   **\n**                                                                   **\n**                         SRVFIPDF Main Program                     **\n**                                                                   **\n**                                                                   **\n***********************************************************************\n BLOCK NAME=SRVFIPDF,TYPE=PROGRAM,AMODE=ANY,RMODE=ANY,R1SAVE=R9,       +\n               CPYRGHT='COPYRIGHT (C) 1987 CLEMSON UNIVERSITY',        +\n               OPTIONS=(*SRVPRC,LONG),SUBOPTS=(*SWA,LOADBASE)\n   ES_ID   ID=ES,SPEPA=&PWA.ESEPA,SPTOKEN=&PWA.ESTOKEN,ESVA=PWAAESV\n   ST_ID   ID=ST,SPEPNAME=&STRING_HANDLER,SIZELENGTH=4\n   FI_ID   ID=OS_FI,SPEPNAME=&FI_OS_FILE_HANDLER\n*---------------------------------------------------------------------*\n*  Copy the parameter list to the PWA and turn off high-order bit.\n*---------------------------------------------------------------------*\n   USING FI_PARMLIST,R9               | Establish addressability.\n   LA    R1,FI_PARMLIST               | R1 -> first parameter.\n   LA    R2,&PWA.PARMLIST             | R2 -> pwa copy of parmlist.\n   LOOP WHILE,(TBIT,0(R1),X'80',OFF)  | Loop over parameters.\n     MVC 0(4,R2),0(R1)                |   Copy parameter to pwa.\n     LA  R2,4(,R2)                    |   Advance to next parameter.\n     LA  R1,4(,R1)                    |   Advance to next parameter.\n   ENDLOOP WHILE                      | EndLoop.\n   MVC 0(4,R2),0(R1)                  | Copy final parameter to pwa.\n   NI  0(R2),X'7F'                    | Turn off high-order bit.\n   LA  R1,4(,R1)                      | Point past final parameter.\n   SLR R1,R9                          | Get length of entire parmlist.\n   SRL R1,2                           | Get number of parameters.\n   ST  R1,&PWA.#PARMS                 | Save in PWA for future use.\n   LA  R9,&PWA.PARMLIST               | R9 -> Copy of parmlist.\n*---------------------------------------------------------------------*\n*  Establish addressability on data areas and validate the environment.\n*---------------------------------------------------------------------*\n   MVC     GDIRC,=H'0'                | Clear out return-code.\n   CALLSUB CHECK_PARMS                | Check parms and environment.\n*---------------------------------------------------------------------*\n*  Use the FunctionCode to determine which subroutine to invoke.\n*---------------------------------------------------------------------*\n   L       R1,FI_FUNCTIONCODE         | R1 -> function code.\n   L       R1,0(R1)                   | R1 := function code.\n   CASEBLK REG=R1,MULT=1              | Case on FunctionCode.\n     CASE &START                      |   Open a new file.\n       CALLSUB START                  |\n     CASE &TERMINATE                  |   Close a file.\n       CALLSUB TERMINATE              |     Kill file and buffers.\n       SMCTRL  FREEPWA=YES            |     Release the PWA on exit.\n     CASE &FI_READLINE                |   Read the next line.\n       CALLSUB READLINE               |\n     CASE &FI_GET_INFO                |   Obtain information.\n       CALLSUB GET_INFO               |\n     CASE OTHER                       |   Invalid function code.\n       MESSAGE (XP00001,0(R2))        |\n   ENDCASE                            | EndCase.\n*                                     |\n   LH   R15,GDIRC                     |\n ENDBLK BLOCK=SRVFIPDF                | Quit w/possible return code.\n EJECT\n***********************************************************************\n*                                                                     *\n*  SUBROUTINE: CHECK_PARMS                                            *\n*  ABSTRACT:   Check parameters and calling environment.              *\n*                                                                     *\n***********************************************************************\n BLOCK NAME=CHECK_PARMS,TYPE=SUBROUTINE\n*---------------------------------------------------------------------*\n*  If the function code is something other than start, check the\n*  eye-catcher string and FileID.  If bad, the FileID is garbage.\n*---------------------------------------------------------------------*\n   L  R2,FI_FUNCTIONCODE              | R2 -> Fullword function code.\n   L  R2,0(R2)                        | R2 := Fullword function code.\n   IF (C,R2,NE,=F'&START')            | If not startup function then.\n     ERREXIT (CLC,&PWA.VISUAL,NE,EYECATCHER),CODE=&FI_INVALID_FILEID\n     ERREXIT (C,R13,NE,&PWA.FILEID),CODE=&FI_INVALID_FILEID\n     IF (TBIT,&PWA.F,&PWA.F_IN_ERROR)\n       CASEBLK REG=R2,WREG=R2,MULT=1  |   Case on FunctionCode.\n       CASE &TERMINATE,&FI_GET_INFO   |     These are always ok.\n       CASE OTHER                     |     Cannot do other functions.\n         MESSAGE (XP00011)            |     Halted by previous error.\n       ENDCASE                        |   EndCase.\n     ENDIF                            |   Endif.\n   ENDIF                              | Endif.\n*---------------------------------------------------------------------*\n*  If not invoked from under ISPF, abort execution.\n*---------------------------------------------------------------------*\n   CALLX   =V(ISPQRY)              | Set R15 = 0 if running under ISPF.\n   MESSAGE (TREG,R15,NZ),(XP00003) | If not invoked from ISPF, quit.\n ENDBLK BLOCK=CHECK_PARMS\n EJECT\n***********************************************************************\n*                                                                     *\n*  SUBROUTINE: START                                                  *\n*  ABSTRACT:   Open a file for the type of access requested.          *\n*                                                                     *\n***********************************************************************\n BLOCK NAME=START,TYPE=SUBROUTINE\n*---------------------------------------------------------------------*\n*  Insure that all parameters were specified, and initialize PWA.\n*---------------------------------------------------------------------*\n   MVC     &PWA.VISUAL,EYECATCHER   | Both the eyecatcher and the\n   ST      R13,&PWA.FILEID          | fileid are validity checks.\n   MVI     &PWA.F,X'00'             | Clear out state flags.\n   MESSAGE (CLC,&PWA.#PARMS,NE,=F'7'),(XP00002,'START',5)\n*                                   |\n   L       R1,PWAAESV               | R1 -> Environment Support Vector.\n   USING   ESV,R1                   | Establish addressability.\n   MVC     &PWA.ESEPA,ESVESEPA      | Copy Environment Support's EPA.\n   MVC     &PWA.ESTOKEN,ESVESTKN    | Copy Environment Support's TOKEN.\n   DROP    R1                       | Drop addressability.\n*---------------------------------------------------------------------*\n*  Load and start the string-handler for use in message formatting.\n*---------------------------------------------------------------------*\n   ES_LOAD_MODULE ID=ES,SPID=ST           | Load String Handler module.\n   MESSAGE        (TREG,R15,NZ),(XP00018) | String Handler not loaded.\n   ST_START       ID=ST                   | Start the String Handler.\n   MESSAGE        (TREG,R15,NZ),(XP00019) | String Handler \u00acstarted.\n   EJECT\n*---------------------------------------------------------------------*\n*  Process the OPTIONS parameter.\n*---------------------------------------------------------------------*\n*\n*  Make sure that all reserved OPTIONS flags are zeros.\n*\n   L  R2,FI_OPTIONS                      | R2 -> options parameter.\n   IF (TBIT,0(R2),&FI_OC_RESERVED,ANY)   | If any reserved options.\n     MESSAGE (XP00014,(R2))              |   Issue an error message.\n   ENDIF                                 | EndIf.\n*\n*  Separate the remaining flags to make checking for specific values\n*  and combinations of values easier.\n*\n   MVC   &PWA.MODE,0(R2)                 | Save INPUT/OUTPUT flag.\n   NI    &PWA.MODE,&FI_OC_MODE           | Mask off other bits.\n*---------------------------------------------------------------------*\n*  Define ISPF variables, parse the file-specification, and open file.\n*---------------------------------------------------------------------*\n   CALLX   ISPLINK,(VDEFINE,NAME_LIST,&PWA.VARS,FORMAT_LIST,           +\n               LENGTH_LIST,'LIST    ')\n   ST      R15,&PWA.ERR_REF\n   MESSAGE (TREG,R15,NZ),(XP00004,&PWA.ERR_REF)\n   SBIT    &PWA.F,&PWA.F_VDEFINED\n*---------------------------------------------------------------------*\n*  Get the data set name and member name from ISPF.\n*---------------------------------------------------------------------*\n   ISREDIT '(PDFTXT1) = DATASET'      | Get the data set name.\n   MVC     &PWA.DSN,&PWA.TXT1         | Copy data set name.\n   TRIM    &PWA.DSN,=A(L'&PWA.DSN)    | Get the dsname's length.\n   ST      R15,&PWA.DSN_LEN           | Save the dsname's length.\n*                                     |\n   ISREDIT '(PDFTXT1) = MEMBER'       | Get the member name.\n   MVC     &PWA.MEM,&PWA.TXT1         | Copy member name.\n   TRIM    &PWA.MEM,=A(L'&PWA.MEM)    | Get the member's length.\n   ST      R15,&PWA.MEM_LEN           | Save the member's length.\n*---------------------------------------------------------------------*\n*  Parse the file specification and open the file.\n*---------------------------------------------------------------------*\n   CALLSUB PARSE_FILESPEC              | Scan file-specification.\n   CALLSUB OPEN_FILE                   | Open the specified file.\n ENDBLK BLOCK=START\n EJECT\n***********************************************************************\n*                                                                     *\n*  SUBROUTINE: PARSE_FILESPEC                                         *\n*  ABSTRACT:   Parse the file-specification of the START function.    *\n*                                                                     *\n***********************************************************************\n BLOCK NAME=PARSE_FILESPEC,TYPE=SUBROUTINE\n*---------------------------------------------------------------------*\n*  R4 -> file-specification.  R5 -> last character in file-spec.\n*---------------------------------------------------------------------*\n   L       R4,FI_FILENAME                | R4 := file-spec's text.\n   L       R5,FI_NAMELENGTH              | R5 -> length of file-spec.\n   L       R5,0(,R5)                     | R5 := length of file-spec.\n   LA      R5,0(R5,R4)                   | R5 -> past end of file-spec.\n   BCTR    R5,0                          | R5 -> last char.\n*---------------------------------------------------------------------*\n*  Parse the file-name, which must be either null, or an asterisk (*).\n*---------------------------------------------------------------------*\n   IF (CR,R4,LE,R5)                      | If filename is non-null.\n     MESSAGE (CLI,0(R4),NE,C'*'),(XP00100)   If not *, invalid syntax.\n     LA      R4,1(,R4)                   |   Advance past the '*'.\n*---------------------------------------------------------------------*\n*    If a member name was specified, parse it and set up for OS file.\n*---------------------------------------------------------------------*\n     IF (CR,R4,LE,R5)                    |   If there is anything left.\n       MESSAGE (CLI,0(R4),NE,C'('),(XP00100)   If not (member), error.\n       IF (CLI,0(R5),EQ,C')')            |     If closing paren.\n         BCTR  R5,0                      |       R5 -> end of MEMBER.\n       ENDIF                             |     EndIf.\n       SLR     R5,R4                     |     R5 := length.\n       MESSAGE (TREG,R5,NP),(XP00100)    |     Syntax error.\n       LA      R4,1(,R4)                 |     R4 -> start of MEMBER.\n       MESSAGE (CLC,&PWA.MEM_LEN,EQ,=F'0'),(XP00009,&PWA.DSN,          +\n               &PWA.DSN_LEN,&PWA.MEM)\n       LA      R14,&PWA.MEM              |     R14 -> member name stg.\n       LA      R15,L'&PWA.MEM            |     R15 := Length of stg.\n       ST      R5,&PWA.MEM_LEN           |     Save specified member.\n       ICM     R5,8,=C' '                |     Pad copy with blanks.\n       MVCL    R14,R4                    |     Copy member name.\n       SBIT    &PWA.F,&PWA.F_OS_SERVER   |     Use the OS file server.\n     ENDIF                               |   EndIf.\n   ENDIF                                 | EndIf.\n ENDBLK BLOCK=PARSE_FILESPEC\n EJECT\n***********************************************************************\n*                                                                     *\n*  SUBROUTINE: OPEN_FILE                                              *\n*  ABSTRACT:   Set up for reading the file.                           *\n*                                                                     *\n***********************************************************************\n BLOCK NAME=OPEN_FILE,TYPE=SUBROUTINE\n*---------------------------------------------------------------------*\n*  If using the ISREDIT interface, set up current/last line numbers.\n*---------------------------------------------------------------------*\n   IF (NOT,(TBIT,&PWA.F,&PWA.F_OS_SERVER)) | If using ISREDIT.\n     ISREDIT '(PDFTXT1) = RECFM'           |   Get the record format.\n     MVC     &PWA.RECFM,&PWA.TXT1          |   Save the record format.\n     ISREDIT '(PDFINT1) = LRECL'           |   Get the LRECL.\n     L       R0,&PWA.INT1                  |   R0 := Fullword value.\n     STH     R0,&PWA.LRECL                 |   Save as a halfword.\n*                                          |\n     ISREDIT '(PDFUSR) = USER_STATE'       |   Save the user's state.\n     SBIT    &PWA.F,&PWA.F_USER_STATE      |   Remember it is saved.\n     ISREDIT 'NUMBER = OFF'                |   Turn off numbering.\n*                                          |\n     ISREDIT '(PDFINT1) = LINENUM .ZFIRST',MAXRC=19\n     MESSAGE (TREG,R15,NZ),(XP00005,'.ZFIRST',7)\n     MVC     &PWA.LINE#,&PWA.INT1          |   Copy to current line#.\n     ISREDIT '(PDFINT1) = LINENUM .ZLAST',MAXRC=19\n     MESSAGE (TREG,R15,NZ),(XP00005,'.ZLAST',6)\n     MVC     &PWA.LAST#,&PWA.INT1          |   Copy to last line#.\n*---------------------------------------------------------------------*\n*  Else, use the OS file server to open the file.\n*---------------------------------------------------------------------*\n   ELSE                                    | Else.\n     ES_LOAD_MODULE ID=ES,SPID=OS_FI       |  Load the OS File Handler.\n     MESSAGE        (TREG,R15,NZ),(XP00010)   Cannot load File Handler.\n*\n     ST_FORMAT ID=ST,STRING=&PWA.TXT1,RESULTLEN=&PWA.INT1,             +\n               CONTROL='''{CL?}({CL?})''',                             +\n               SOURCE=(&PWA.DSN,&PWA.DSN_LEN,&PWA.MEM,&PWA.MEM_LEN)\n     MESSAGE   (TREG,R15,NZ),(XP00000)     |  Internal error.\n*\n     FI_START  ID=OS_FI,                   |  Start OS File Handler    +\n               FILE=(&PWA.TXT1,&PWA.INT1), |    using 'DSNAME(MEMBER)' +\n               OPTIONVALUE=*FI_OPTIONS,    |    and the OPTIONS and    +\n               INFO=*FI_INFO               |    INFO parms passed in.\n     ST      R15,&PWA.ERR_REF              |  Save the return code.\n     ERREXIT (TREG,R15,NZ),NAME=OS_EXIT    |  Exit if in error.\n   ENDIF                                   | EndIf.\n*---------------------------------------------------------------------*\n*  Mark the file as successfully opened.\n*---------------------------------------------------------------------*\n   SBIT &PWA.F,&PWA.F_OPENED\n ENDBLK BLOCK=OPEN_FILE\n EJECT\n***********************************************************************\n*                                                                     *\n*  SUBROUTINE: READLINE                                               *\n*  ABSTRACT:   Obtain the next line from an already open file.        *\n*                                                                     *\n***********************************************************************\n BLOCK NAME=READLINE,TYPE=SUBROUTINE\n*---------------------------------------------------------------------*\n*  Validate the current file status and the parameter list.\n*---------------------------------------------------------------------*\n   IF (TBIT,&PWA.F,&PWA.F_OPENED,OFF) If file is not opened.\n     MESSAGE (XP00012,'READLINE',8) |   Issue an error message.\n   ELSEIF (TBIT,&PWA.F,&PWA.F_EOF)  | ElseIf at end of file.\n     ERREXIT CODE=&FI_END_OF_FILE   |   Exit w/EOF return-code.\n   ELSEIF (CLI,&PWA.MODE,NE,&FI_OC_INPUT)\n     MESSAGE (XP00017)              |\n   ENDIF                            | EndIf.\n*---------------------------------------------------------------------*\n*  If using the OS file server, then get it to do the work.\n*---------------------------------------------------------------------*\n   IF (TBIT,&PWA.F,&PWA.F_OS_SERVER)    If using the OS file server.\n     FI_READLINE ID=OS_FI,LINE=(*FI_RL_AREA,*FI_RL_AREA_SIZE),         +\n               RESULTLEN=*FI_RL_LENGTH\n     ST        R15,&PWA.ERR_REF     |      Save return code.\n     ERREXIT   (TREG,R15,NZ),NAME=OS_EXIT  Exit with return code.\n     LEAVE     BLOCK=*              |      Exit normally.\n   ENDIF                            |    EndIf.\n*---------------------------------------------------------------------*\n*  If &PWA.LINE# > &PWA.LAST# then past end of file.\n*---------------------------------------------------------------------*\n   IF (CLC,&PWA.LINE#,GT,&PWA.LAST#)  If past end of file, then.\n     SBIT    &PWA.F,&PWA.F_EOF      |   Set the end-of-file flag.\n     ERREXIT CODE=&FI_END_OF_FILE   |   Issue a message and quit.\n   ENDIF                            | EndIf.\n*---------------------------------------------------------------------*\n*  Invoke ISREDIT to obtain the current line.\n*---------------------------------------------------------------------*\n   MVC     &PWA.INT1,&PWA.LINE#     | Copy current line# to variable.\n   ISREDIT '(PDFTXT1) = LINE &&PDFINT1',MAXRC=19\n   MESSAGE (C,R15,EQ,=F'4'),(XP00202,=A(L'&PWA.TXT1))\n   MESSAGE (TREG,R15,NZ),(XP00006,&PWA.LINE#,&PWA.ERR_REF)\n*                                   |\n   L       R1,&PWA.LINE#            | R1 := current relative line#.\n   A       R1,=F'1'                 | Advance to next line.\n   ST      R1,&PWA.LINE#            | Save for next time.\n*---------------------------------------------------------------------*\n*  Copy the line to the caller's buffer.\n*---------------------------------------------------------------------*\n   TRIM    &PWA.TXT1,=A(L'&PWA.TXT1) Remove trailing blanks from line.\n   ST      R15,&PWA.LINE_LEN       | Save current line's length.\n   LM      R2,R3,FI_RL_AREA        | R2/R3 -> text area, length.\n   L       R3,0(R3)                | R3 := length of text area.\n   LA      R4,&PWA.TXT1            | R4 -> input line.\n   L       R5,&PWA.LINE_LEN        | R5 := length of input line.\n   IF      (CR,R3,GT,R5)           | If more than enough room.\n     LR    R3,R5                   |   Use only exact amount needed.\n   ENDIF                           | EndIf.\n   L       R6,FI_RL_LENGTH         | R6 -> line length parm.\n   ST      R3,0(R6)                | Save length of returned line.\n*                                  |\n   IF (TREG,R5,P)                  | If anything to copy, then.\n     IF (C,R3,GT,=F'256')          |   If too long for an MVC instr.\n       MVCL    R2,R4               |     Copy information to caller.\n       MESSAGE CC4,(XP00201,0(R6)) |     Record was truncated.\n     ELSE                          |   Else.\n       BCTR    R3,0                |     Subtract 1 for EX instr.\n       EXI     R3,(MVC,0(0,R2),0(R4))    Copy information to caller.\n       LA      R3,1(,R3)           |     Add 1 back for comparison.\n       MESSAGE (CR,R3,LT,R5),(XP00201,0(R6))  Record was truncated.\n     ENDIF                         |   EndIf.\n   ENDIF                           | EndIf.\n ENDBLK BLOCK=READLINE\n EJECT\n***********************************************************************\n*                                                                     *\n*  SUBROUTINE: TERMINATE                                              *\n*  ABSTRACT:   Close out and cleanup any/all files.                   *\n*                                                                     *\n***********************************************************************\n BLOCK NAME=TERMINATE,TYPE=SUBROUTINE\n*---------------------------------------------------------------------*\n*  If using the ISREDIT interface, reset the NUMBER mode.\n*---------------------------------------------------------------------*\n   IF (NOT,(TBIT,&PWA.F,&PWA.F_OS_SERVER)) If using ISREDIT.\n     IF (TBIT,&PWA.F,&PWA.F_OPENED)  |   If file has been opened.\n       IF (TBIT,&PWA.F,&PWA.F_USER_STATE)  If user's state was saved.\n         ISREDIT 'USER_STATE = (PDFUSR)'     Restore user's state.\n         RBIT    &PWA.F,&PWA.F_USER_STATE    No longer saved.\n       ENDIF                         |     EndIf.\n     ENDIF                           |   EndIf.\n*---------------------------------------------------------------------*\n*  If using the OS file server, terminate it and unload it.\n*---------------------------------------------------------------------*\n   ELSE                              | Else using the OS server.\n     IF (CLC,&PWA.OS_FI_SPEPA,NE,=F'0')   If the OS server is loaded.\n       IF (CLC,&PWA.OS_FI_SPTOKEN,NE,=F'0') If the OS server started.\n         FI_TERMINATE ID=OS_FI       |       Terminate File Handler.\n       ENDIF                         |     EndIf.\n       ES_UNLOAD_MODULE ID=ES,SPID=OS_FI   Unload OS File Handler.\n     ENDIF                           |   EndIf.\n   ENDIF                             | EndIf.\n*---------------------------------------------------------------------*\n*  Delete the variables that were created by SRVFIPDF.\n*---------------------------------------------------------------------*\n   IF (TBIT,&PWA.F,&PWA.F_VDEFINED)     | If variables were defined.\n     CALLX ISPLINK,(VDELETE,NAME_LIST)  |   Delete them.\n     RBIT  &PWA.F,&PWA.F_VDEFINED       |   No longer defined.\n   ENDIF                                | EndIf.\n*---------------------------------------------------------------------*\n*  Terminate and unload the String Handler.\n*---------------------------------------------------------------------*\n   IF (CLC,&PWA.ST_SPEPA,NE,=F'0')     | If String Handler is loaded.\n     IF (CLC,&PWA.ST_SPTOKEN,NE,=F'0') |   If String Handler started.\n       ST_TERMINATE ID=ST              |     Terminate File Handler.\n     ENDIF                             |   EndIf.\n     ES_UNLOAD_MODULE ID=ES,SPID=ST    |   Unload String Handler.\n   ENDIF                               | EndIf.\n*\n   RBIT  &PWA.F,&PWA.F_OPENED\n ENDBLK BLOCK=TERMINATE\n EJECT\n***********************************************************************\n*                                                                     *\n*  SUBROUTINE: GET_INFO                                               *\n*  ABSTRACT:   Return selected information to the caller.             *\n*                                                                     *\n***********************************************************************\n BLOCK NAME=GET_INFO,TYPE=SUBROUTINE\n*---------------------------------------------------------------------*\n*  Make sure that the information sub-code parameter was supplied.\n*---------------------------------------------------------------------*\n   MESSAGE (CLC,&PWA.#PARMS,LT,=F'3'),(XP00002,'GET_INFO',8)\n*---------------------------------------------------------------------*\n*  Call the routine that obtains the requested information.\n*---------------------------------------------------------------------*\n   L       R2,FI_GI_FUNCTION          | R2 -> information sub-code.\n   L       R1,0(,R2)                  | R1 := information sub-code.\n   CASEBLK REG=R1,WREG=R1,MULT=1      | Case on information sub-code.\n     CASE &FI_GI_MSG                  |   Get last message issued.\n       CALLSUB GET_INFO_MSG           |\n     CASE &FI_GI_NAME                 |   Get file's full name.\n       CALLSUB GET_INFO_NAME          |\n     CASE &FI_GI_LRECL                |   Get logical record length.\n       CALLSUB GET_INFO_LRECL         |\n     CASE &FI_GI_RECFM                |   Get record format.\n       CALLSUB GET_INFO_RECFM         |\n     CASE &FI_GI_IDSTRING             |   Get identification string.\n       CALLSUB GET_INFO_IDSTRING      |\n     CASE OTHER                       |   Invalid information code.\n       MESSAGE (XP00015,0(R2))        |\n   ENDCASE                            | EndCase\n ENDBLK BLOCK=GET_INFO                |\n EJECT\n***********************************************************************\n*                                                                     *\n*  SUBROUTINE: GET_INFO_MSG                                           *\n*  ABSTRACT:   Return the current message to the caller.              *\n*                                                                     *\n***********************************************************************\n BLOCK NAME=GET_INFO_MSG,TYPE=SUBROUTINE\n   MESSAGE (CLC,&PWA.#PARMS,NE,=F'6'),(XP00002,'GET_INFO (MSG)',14)\n*---------------------------------------------------------------------*\n*  If using the OS file server, then get it to do the work.\n*---------------------------------------------------------------------*\n   IF (TBIT,&PWA.F,&PWA.F_OS_SERVER)  If using the OS file server.\n     FI_GET_INFO ID=OS_FI,MSG=(*FI_GI_AREA,*FI_GI_AREA_SIZE),          +\n               MSGLEN=*FI_GI_LENGTH\n     ST      R15,&PWA.ERR_REF       |   Save return code.\n     ERREXIT (TREG,R15,NZ),NAME=OS_EXIT Exit with return code.\n     LEAVE   BLOCK=*                |   Exit normally.\n   ENDIF                            | EndIf.\n*---------------------------------------------------------------------*\n*  Copy the formatted message to the user's buffer.\n*---------------------------------------------------------------------*\n   LM   R2,R3,FI_GI_AREA            | R2/R3 -> text area, length.\n   L    R3,0(R3)                    | R3 := length of text area.\n   LM   R4,R5,&PWA.MSG_DATA         | R4/R5 -> message text/length.\n   L    R5,0(R5)                    | R5 := length of message.\n   IF   (CR,R5,GT,R3)               | If too long to fit in area.\n     LR R5,R3                       |   Reduce to exact length.\n   ENDIF                            | EndIf.\n   L    R1,FI_GI_LENGTH             | R1 -> message length parm.\n   ST   R5,0(R1)                    | Save length of returned msg.\n   ICM  R5,8,=C' '                  | Pad copied text with blanks.\n   MVCL R2,R4                       | Copy information to caller.\n ENDBLK BLOCK=GET_INFO_MSG\n EJECT\n***********************************************************************\n*                                                                     *\n*  SUBROUTINE: GET_INFO_NAME                                          *\n*  ABSTRACT:   Return the file's name to the caller.                  *\n*                                                                     *\n***********************************************************************\n BLOCK NAME=GET_INFO_NAME,TYPE=SUBROUTINE\n   MESSAGE (CLC,&PWA.#PARMS,NE,=F'6'),(XP00002,'GET_INFO (NAME)',15)\n*---------------------------------------------------------------------*\n*  If using the OS file server, then get it to do the work.\n*---------------------------------------------------------------------*\n   IF (TBIT,&PWA.F,&PWA.F_OS_SERVER)  If using the OS file server.\n     FI_GET_INFO ID=OS_FI,NAME=(*FI_GI_AREA,*FI_GI_AREA_SIZE),         +\n               NAMELEN=*FI_GI_LENGTH\n     ST      R15,&PWA.ERR_REF       |   Save return code.\n     ERREXIT (TREG,R15,NZ),NAME=OS_EXIT Exit with return code.\n     LEAVE   BLOCK=*                |   Exit normally.\n   ENDIF                            | EndIf.\n*---------------------------------------------------------------------*\n*  Build the full file name in the caller's buffer.\n*---------------------------------------------------------------------*\n   IF   (CLC,&PWA.MEM_LEN,NE,=F'0')     | If a MEMBER specified.\n     LA R2,=F'1'                        |   R2 -> length of '(' or ')'.\n   ELSE                                 | Else.\n     LA R2,=F'0'                        |   R2 -> null length value.\n   ENDIF                                | EndIf.\n*                                       |\n   ST_FORMAT ID=ST,STRING=(*FI_GI_AREA,*FI_GI_AREA_SIZE),              +\n               RESULTLEN=*FI_GI_LENGTH,                                +\n               CONTROL='{CL?}{CL?}{CL?}{CL?}',                         +\n               SOURCE=(&PWA.DSN,&PWA.DSN_LEN,'(',(R2),                 +\n               &PWA.MEM,&PWA.MEM_LEN,')',(R2))\n   IF (C,R15,EQ,=F'&ST_TRUNCATED')      | If data truncated, then.\n     CALLSUB MESSAGE,(XP00007)          |   Issue a message and quit.\n   ENDIF                                | EndIf.\n ENDBLK BLOCK=GET_INFO_NAME\n EJECT\n***********************************************************************\n*                                                                     *\n*  SUBROUTINE: GET_INFO_LRECL                                         *\n*  ABSTRACT:   Return the file's logical record length as a halfword. *\n*                                                                     *\n***********************************************************************\n BLOCK NAME=GET_INFO_LRECL,TYPE=SUBROUTINE\n   MESSAGE (CLC,&PWA.#PARMS,NE,=F'4'),(XP00002,'GET_INFO (LRECL)',16)\n*---------------------------------------------------------------------*\n*  If using the OS file server, then get it to do the work.\n*---------------------------------------------------------------------*\n   IF (TBIT,&PWA.F,&PWA.F_OS_SERVER)    | If using the OS file server.\n     FI_GET_INFO ID=OS_FI,LRECL=*FI_GI_AREA\n     ST          R15,&PWA.ERR_REF       |   Save return code.\n     ERREXIT     (TREG,R15,NZ),NAME=OS_EXIT Exit with return code.\n     LEAVE       BLOCK=*                |   Exit normally.\n   ENDIF                                | EndIf.\n*---------------------------------------------------------------------*\n*  Return the file's logical record length, which is in the DCB.\n*---------------------------------------------------------------------*\n   IF (TBIT,&PWA.F,&PWA.F_OPENED,OFF)\n     MESSAGE (XP00016,'GET_INFO (LRECL)',16)\n   ENDIF                                | EndIf.\n*                                       |\n   L       R2,FI_GI_AREA                | R2 -> Halfword for LRECL.\n   MVC     0(2,R2),&PWA.LRECL           | Copy LRECL to parameter.\n ENDBLK BLOCK=GET_INFO_LRECL\n EJECT\n***********************************************************************\n*                                                                     *\n*  SUBROUTINE: GET_INFO_RECFM                                         *\n*  ABSTRACT:   Return the file's record format in an 8-byte field.    *\n*                                                                     *\n***********************************************************************\n BLOCK NAME=GET_INFO_RECFM,TYPE=SUBROUTINE\n   MESSAGE (CLC,&PWA.#PARMS,NE,=F'4'),(XP00002,'GET_INFO (RECFM)',16)\n*---------------------------------------------------------------------*\n*  If using the OS file server, then get it to do the work.\n*---------------------------------------------------------------------*\n   IF (TBIT,&PWA.F,&PWA.F_OS_SERVER)    | If using the OS file server.\n     FI_GET_INFO ID=OS_FI,RECFM=*FI_GI_AREA\n     ST          R15,&PWA.ERR_REF       |   Save return code.\n     ERREXIT     (TREG,R15,NZ),NAME=OS_EXIT Exit with return code.\n     LEAVE       BLOCK=*                |   Exit normally.\n   ENDIF                                | EndIf.\n*---------------------------------------------------------------------*\n*  Return a single character indicating the file's record format.\n*---------------------------------------------------------------------*\n   IF (TBIT,&PWA.F,&PWA.F_OPENED,OFF)\n     CALLSUB MESSAGE,(XP00016,'GET_INFO (RECFM)',16)\n   ELSE                                 | Else.\n     L     R2,FI_GI_AREA                |   R2 -> Halfword for LRECL.\n     MVC   0(8,R2),&PWA.RECFM           |   Copy RECFM to Area.\n   ENDIF                                | EndIf.\n ENDBLK BLOCK=GET_INFO_RECFM\n EJECT\n***********************************************************************\n*                                                                     *\n*  SUBROUTINE: GET_INFO_IDSTRING                                      *\n*  ABSTRACT:   Return an 8-character identification string.           *\n*                                                                     *\n***********************************************************************\n BLOCK NAME=GET_INFO_IDSTRING,TYPE=SUBROUTINE\n   IF (CLC,&PWA.#PARMS,NE,=F'4')        | If not exactly 4 parameters.\n     MESSAGE (XP00002,'GET_INFO (IDSTRING)',19)\n   ENDIF                                | EndIf.\n*---------------------------------------------------------------------*\n*  If using the OS file server, then get it to do the work.\n*---------------------------------------------------------------------*\n   IF (TBIT,&PWA.F,&PWA.F_OS_SERVER)    | If using the OS file server.\n     FI_GET_INFO ID=OS_FI,IDSTRING=*FI_GI_AREA\n     ST          R15,&PWA.ERR_REF       |   Save return code.\n     ERREXIT     (TREG,R15,NZ),NAME=OS_EXIT Exit with return code.\n     LEAVE       BLOCK=*                |   Exit normally.\n   ENDIF                                | EndIf.\n*---------------------------------------------------------------------*\n*  Return a single character indicating the file's record format.\n*---------------------------------------------------------------------*\n   IF (TBIT,&PWA.F,&PWA.F_OPENED,OFF)\n     CALLSUB MESSAGE,(XP00016,'GET_INFO (IDSTRING)',19)\n     LEAVE   BLOCK=*                    |   Should never get here.\n   ELSE                                 | Else.\n     L   R2,FI_GI_AREA                  |   R2 -> Return area.\n     MVC 0(8,R2),=CL8' '                |   Initialize it to blanks.\n     L   R5,&PWA.MEM_LEN                |   R5 := length of member.\n     IF  (TREG,R5,P)                    |   If there is a member name.\n       BCTR  R5,0                       |     Subtract 1 for EX instr.\n       EXI   R5,(MVC,0(0,R2),&PWA.MEM)  |     Copy member name.\n     ELSE                               |   Else.\n*      Do nothing.                      |\n     ENDIF                              |   EndIf.\n   ENDIF                                | EndIf.\n ENDBLK BLOCK=GET_INFO_IDSTRING\n EJECT\n***********************************************************************\n*                                                                     *\n*  SUBROUTINE: MESSAGE                                                *\n*  ABSTRACT:   Format a message and exit the program.                 *\n*                                                                     *\n***********************************************************************\n BLOCK TYPE=SUBROUTINE,NAME=MESSAGE\n   LR   R2,R1                          | R2 -> Parameter list.\n   L    R4,0(R2)                       | R4 -> Message's ADCON.\n   L    R4,0(R4)                       | R4 -> Message Length, Text.\n*---------------------------------------------------------------------*\n*  Count arguments and invoke String Handler to format the message.\n*---------------------------------------------------------------------*\n   LA R15,8                            | Nothing formatted yet.\n   IF (CLC,&PWA.ST_SPEPA,NE,=F'0')     | If String Handler loaded.\n     IF (CLC,&PWA.ST_SPTOKEN,NE,=F'0') |   If String Handler started.\n       LR   R1,R2                      |     R1 -> parm before 1st arg.\n       LOOP WHILE,(TBIT,0(R1),X'80',OFF)     While not @ last arg.\n         LA    R1,4(,R1)               |      Advance to next arg.\n       ENDLOOP WHILE                   |     EndLoop.\n       SR      R1,R2                   |     R1 := length of plist.\n       SRL     R1,2                    |     R1 := #arguments.\n       ST      R1,&W.COUNT             |     Save for ST_FORMAT.\n       ST_FORMAT ID=ST,STRING=&PWA.ERR_MSG,RESULTLEN=&PWA.ERR_MSG_LEN, +\n               CONTROL=(4(R4),0(R4)),SOURCELIST=(4(R2),&W.COUNT)\n     ENDIF                             |   EndIf.\n   ENDIF                               | EndIf.\n*---------------------------------------------------------------------*\n*  If the message could not be formatted, use the unformatted version.\n*---------------------------------------------------------------------*\n   IF (TREG,R15,NZ)                    | If nothing formatted.\n     L    R5,0(R4)                     |   R5 := length of msg text.\n     LA   R1,L'&PWA.ERR_MSG            |   R1 -> Length of target area.\n     IF   (CR,R5,GT,R1)                |   If too long to fit, then.\n       LR R5,R1                        |     Use as much as possible.\n     ENDIF                             |   EndIf.\n     ST   R5,&PWA.ERR_MSG_LEN          |   Save length of message\n     LR   R1,R5                        |   Set target to exact size.\n     LA   R4,4(R4)                     |   R4 -> message text.\n     LA   R0,&PWA.ERR_MSG              |   R0 -> Target area of move.\n     MVCL R0,R4                        |   Copy message text.\n   ENDIF                               | EndIf.\n*---------------------------------------------------------------------*\n*  Invoke the error exit with the message's return-code.\n*---------------------------------------------------------------------*\n   IF (CLI,&PWA.ERR_MSG+7,EQ,C'W')     | If a warning message,\n     ERREXIT CODE=&FI_WARNING          |   Exit with the warning-code.\n   ELSEIF (CLI,&PWA.ERR_MSG+7,EQ,C'E') | ElseIf an error message,\n     ERREXIT CODE=&FI_ERROR            |   Exit with the error-code.\n   ELSEIF (CLI,&PWA.ERR_MSG+7,EQ,C'S') | ElseIf an error message,\n     ERREXIT CODE=&FI_SEVERE           |   Exit with the severe-code.\n   ELSEIF (CLI,&PWA.ERR_MSG+7,EQ,C'X') | ElseIf invalid filename.\n     MVI     &PWA.ERR_MSG+7,C'S'       |   Change to 'severe' message.\n     ERREXIT CODE=&FI_INVALID_SYNTAX   |   Exit with the syntax-code.\n   ELSE                                | Else\n     ERREXIT CODE=&FI_SEVERE           |   Exit with the error-code.\n   ENDIF                               | EndIf.\n ENDBLK BLOCK=MESSAGE\n           SWA\n&W.COUNT   DS  F\n           ENDSWA\n EJECT\n***********************************************************************\n*                                                                     *\n*  Error exit for all functions in the file handler.                  *\n*                                                                     *\n***********************************************************************\n BLOCK TYPE=ERREXIT\n*---------------------------------------------------------------------*\n*  Save module/offset, registers, return-code.\n*---------------------------------------------------------------------*\n   STM   R0,R15,GDIREGS          | Save registers at time of error.\n   LA    R0,4(,R12)              | Point to module identification.\n   ST    R0,GDIMODID             | Save in general debug area.\n   MVC   GDIRC,0(R14)            | Copy return code.\n   SLR   R14,R12                 | Calculate offset at time of error.\n   STH   R14,GDIOFFST            | Save in debug area.\n   ES_SAVE_DEBUG_INFO ID=ES,GDI=GDI\n*---------------------------------------------------------------------*\n*  Check the return-code, and save the debugging message accordingly.\n*---------------------------------------------------------------------*\n   LH    R3,GDIRC                | R3 := return-code.\n   CASEBLK REG=R3,MULT=1         | Case on return-code.\n     CASE &FI_END_OF_FILE        |\n       L  R5,XP00200             |     R5 -> Length of message.\n       LA R4,4(R5)               |     R4 -> Message text.\n     CASE &FI_WARNING,&FI_ERROR,&FI_SEVERE,&FI_INVALID_SYNTAX\n       LA R4,&PWA.ERR_MSG        |     R4 -> Formatted message text.\n       LA R5,&PWA.ERR_MSG_LEN    |     R5 -> Length of formatted msg.\n     CASE OTHER                  |   Unknown error-code.\n       L  R5,XP00000             |     R5 -> Length of message.\n       LA R4,4(R5)               |     R4 -> Message text.\n   ENDCASE                       | EndCase.\n   STM   R4,R5,&PWA.MSG_DATA     | Save address/length of message.\n   ES_SAVE_DEBUG_INFO ID=ES,TEXT=((R4),(R5))\n*---------------------------------------------------------------------*\n*  Set the final return-code and exit.\n*---------------------------------------------------------------------*\n   LH R15,GDIRC                  | R15 := Return-code for this call.\n   IF (C,R15,GT,=F'&FI_WARNING') | If greater than a warning.\n     SBIT &PWA.F,&PWA.F_IN_ERROR |   Set the error flag in the PWA.\n   ENDIF                         | EndIf.\n ENDBLK\n EJECT\n***********************************************************************\n*                                                                     *\n*  Error exit for when SRVFIPDF is acting as an interface to the OS   *\n*        File Handler.                                                *\n*                                                                     *\n***********************************************************************\n BLOCK TYPE=ERREXIT,NAME=OS_EXIT\n   L    R15,&PWA.ERR_REF                    | R15 := SRVFIOS's RC.\n   IF   (C,R15,EQ,=F'&FI_INVALID_SYNTAX')   | If passthru code, then.\n     LA  R15,&FI_ERROR                      |   Change to ERROR code.\n   ELSEIF (C,R15,EQ,=F'&FI_END_OF_FILE')    | ElseIf End-of-file.\n     SBIT &PWA.F,&PWA.F_EOF                 |   Set EOF flag in PWA.\n   ENDIF                                    | EndIf.\n ENDBLK BLOCK=OS_EXIT\n EJECT\n*---------------------------------------------------------------------*\n*\n*  Static Data\n*\n*---------------------------------------------------------------------*\n               PSD\n               LTORG\nEYECATCHER     DC   C'SRVFIPDF' | Value moved to PWA on initialize.\nISPLINK        DC   V(ISPLINK)  | EPA of ISPF interface routine.\nVDEFINE        DC   C'VDEFINE ' | Service name for defining variables.\nVDELETE        DC   C'VDELETE ' | Service name for deleting variables.\nISREDIT        DC   C'ISREDIT ' | Service name for edit macro commands.\n*\n* The following three lists name and map the ISPF variables used in\n* this program.  The storage used to hold their values begins at\n* &PWA.VARS.\n*\nNAME_LIST      DC   C'(PDFINT1 PDFINT2 PDFTXT1 PDFTXT2 PDFUSR)'\nFORMAT_LIST    DC   CL8'FIXED',CL8'FIXED',CL8'CHAR',CL8'CHAR',CL8'CHAR'\nLENGTH_LIST    DC   A(L'&PWA.INT1,L'&PWA.INT2,L'&PWA.TXT1,L'&PWA.TXT2)\n               DC   A(L'&PWA.USER_STATE)\n*                               |\n            MACRO\n&LABEL      TRANTAB\n            LCLA &N\n&LABEL      DS   0XL256        |\n.NEWROW     DC   AL1(&N+0,&N+1,&N+2,&N+3,&N+4,&N+5,&N+6,&N+7)\n            DC   AL1(&N+8,&N+9,&N+10,&N+11,&N+12,&N+13,&N+14,&N+15)\n&N          SETA &N+16\n            AIF  (&N LT 256).NEWROW\n            MEND\nFOLD        TRANTAB            | Translate tbl for uppercase conv.\n            ORG  FOLD+C'a'     | Fold lowercase 'a' - 'i'.\n            DC   C'ABCDEFGHI'  |\n            ORG  FOLD+C'j'     | Fold lowercase 'j' - 'r'.\n            DC   C'JKLMNOPQR'  |\n            ORG  FOLD+C's'     | Fold lowercase 's' - 'z'.\n            DC   C'STUVWXYZ'   |\n            ORG\n            EJECT\n*---------------------------------------------------------------------*\n* Messages are made up of a message identifier followed by a control\n* string.  The message identifier has the format\n*\n*   XInnnnns\n*\n* where the characters XI always begin an XsubID-handler's message,\n* nnnnn is the unique message number, and s indicates the message's\n* severity.\n*\n* Severity                  Meaning\n* --------   ---------------------------------------------\n*    I       Informational.\n*    W       Warning message.\n*    E       An error occurred, but execution can continue.\n*    S       Severe error.  Execution cannot continue.\n*    X       Filename syntactically invalid.\n*    C       Critical error.  Indicates a probable programming error.\n*\n*---------------------------------------------------------------------*\n            MACRO\n            MSG   &NUMBER,&SEVERITY,&TEXT\n            LCLC  &MSGID,&OLDLOC\n&OLDLOC     SETC  '&SYSLOC'\n&MSGID      SETC  'XP&NUMBER'\n&MSGID      DC    A(MSGT&SYSNDX)\nXSMSGS      LOCTR ,\nMSGT&SYSNDX DC    AL4(MSGL&SYSNDX),C'&MSGID&SEVERITY',C' ',C&TEXT\nMSGL&SYSNDX EQU   *-MSGT&SYSNDX-4\n&OLDLOC     LOCTR ,\n            MEND\n*\n MSG 00000,C,'Unknown error.'\n MSG 00001,C,'Invalid function-code parameter: {I}.'\n MSG 00002,C,'Wrong number of parameters for the {CL?} function.'\n MSG 00003,S,'SRVFIPDF must be invoked from an ISPF environment.'\n MSG 00004,C,'Unable to define internal variables. VDEFINE return code +\n               was {I}.'\n MSG 00005,S,'Unable to obtain the value of the {CL?} builtin label.'\n MSG 00006,S,'ISREDIT (PDFTXT1) = LINE {I} ended with return code {I}.'\n MSG 00007,S,'File name truncated in GET_NAME function.'\n MSG 00008,C,'ISREDIT return code = {I}. Command was: \"{CL? T}\".'\n MSG 00009,S,'Data set {CL? T} is not partitioned, but member {CL8 T} w+\n               as specified.'\n MSG 00010,S,'Unable to load the OS file server to read another member +\n               of a partitioned data set.'\n MSG 00011,C,'Processing halted due to a previous error.'\n MSG 00012,S,'Function {CL?} not performed; file is not open.'\n MSG 00013,C,'OUTPUT mode not supported for files being edited with ISP+\n               F Edit.'\n MSG 00014,C,'Invalid OPTIONS value: B\"{BL1}\".'\n MSG 00015,C,'Invalid information code ({I}) for the GET_INFO function.+\n               '\n MSG 00016,S,'Function {CL?} not performed; file is not open.'\n MSG 00017,E,'READLINE cannot be invoked for files opened as OUTPUT.'\n MSG 00018,S,'Unable to load the String Handler (SRVSTR).'\n MSG 00019,S,'Unable to start the String Handler (SRVSTR).'\n*\n MSG 00100,X,'Invalid syntax in file name.'\n MSG 00200,W,'End of file.'\n MSG 00201,E,'Input record was truncated to {I} characters.'\n MSG 00202,E,'Line truncated by ISREDIT to {I} characters.'\n*\n            ENDPSD\n            EJECT\n***********************************************************************\n*                                                                     *\n*  Program Work Area                                                  *\n*                                                                     *\n***********************************************************************\n                     PWA\n&PWA.VISUAL          DS  CL(L'EYECATCHER)\n&PWA.FILEID          DS  A           | Unique file identifier.\n&PWA.#PARMS          DS  F           | Number of parms passed in.\n&PWA.PARMLIST        DS  CL(4*10)    | Copy of parameter list.\n*                                    |\n&PWA.ESEPA           DS  A           | Environment Support's EPA.\n&PWA.ESTOKEN         DS  F           | Environment Support's TOKEN.\n&PWA.MODE            DS  X           | Options INPUT/OUTPUT flag.\n*                                    |\n&PWA.STEPA           DS  A           | String-handler's entry-point.\n&PWA.STTKN           DS  F           | String-handler's token.\n&PWA.F               DS  X           | State information.\n&PWA.F_OS_SERVER     EQU B'10000000' |   Using the OS file server.\n&PWA.F_OPENED        EQU B'01000000' |   File successfully opened.\n&PWA.F_IN_ERROR      EQU B'00100000' |   Halted due to an error.\n&PWA.F_EOF           EQU B'00010000' |   End of file has been reached.\n&PWA.F_USER_STATE    EQU B'00001000' |   User state saved in PWA.\n&PWA.F_VDEFINED      EQU B'00000100' |   ISPF Variables are defined.\n*                                    |\n&PWA.MEM_LEN         DS  F           | Length of member name.\n&PWA.MEM             DS  CL8         | Member name of PDS.\n&PWA.DSN_LEN         DS  F           | Length of PDSname(member).\n&PWA.DSN             DS  CL44        | OS data set name.\n&PWA.LAST#           DS  F           | Last line number = .ZLAST\n&PWA.LINE#           DS  F           | Current line number.\n&PWA.LINE_LEN        DS  F           | Length of current input line.\n&PWA.LRECL           DS  H           | Logical record length.\n&PWA.RECFM           DS  CL8         | Record format: 'F' or 'V'.\n*                                    | Error tracking information.\n&PWA.PLIST           DS  CL(4*17)    |   Parameter list area.\n&PWA.ERR_REF         DS  F           |   Latest return/reason code.\n&PWA.MSG_DATA        DS  2F          |   Address/length of message.\n&PWA.ERR_MSG_LEN     DS  F           |   Short description of error.\n&PWA.ERR_MSG         DS  CL256       |   Error, Warning, or Info.\n                     ES_GDI DSECT=NO |   Debugging area.\n*---------------------------------------------------------------------*\n* The following fields *must* correspond exactly to the mapping set up\n* for VDEFINE by the PSD values NAME_LIST, FORMAT_LIST, and LENGTH_LIST\n*---------------------------------------------------------------------*\n&PWA.VARS            DS  0F          | Storage for VDEFINEd variables.\n&PWA.INT1            DS  F           |   General integer variable.\n&PWA.INT2            DS  F           |   General integer variable.\n&PWA.TXT1            DS  CL256       |   General text variable.\n&PWA.TXT2            DS  CL256       |   General text variable.\n&PWA.USER_STATE      DS  CL2048      |   Saved user's state.\n                     ENDPWA\n                     EJECT\n***********************************************************************\n*  Parameter list for the File Handler.\n***********************************************************************\n           FI_PARMLIST        | File Handler parameter list.\n           EJECT\n           ES_ESV\n           END\n/*\n//C.SYSLIB DD\n//         DD\n//         DD DISP=SHR,DSN=SYSTEMS.SRV.SOURCE\n//         DD DISP=SHR,DSN=SYSTEMS.RACF.MACLIB\n//         DD DISP=SHR,DSN=SYS2.MACLIB\n//         DD DISP=SHR,DSN=SYS1.AMODGEN\n//L.SYSLIB DD DISP=SHR,DSN=SYS1.ISPFLINK\n//L.SYSIN  DD *\n  INCLUDE SYSLIB(ISPQRY)\n  INCLUDE SYSLIB(ISPLINK)\n//\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SRVFISUB": {"ttr": 24842, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x02\\x00\\x00W\\x01\\x11)\\x9f\\x01\\x11)\\x9f\\t'\\x03\\xe7\\x03\\xe7\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@\"", "ispf": {"version": "02.00", "flags": 0, "createdate": "2011-10-26T00:00:00", "modifydate": "2011-10-26T09:27:57", "lines": 999, "newlines": 999, "modlines": 0, "user": "CLEMSON"}, "text": "*---------------------------------------------------------------------*\n*  Copyright 2011 by Clemson University Research Foundation           *\n*                                                                     *\n*  Licensed under the Apache License, Version 2.0 (the \"License\");    *\n*  you may not use this file except in compliance with the License.   *\n*  You may obtain a copy of the License in this library as member     *\n*  $LICENSE, or from                                                  *\n*                                                                     *\n*      http://www.apache.org/licenses/LICENSE-2.0                     *\n*                                                                     *\n*  Unless required by applicable law or agreed to in writing,         *\n*  software distributed under the License is distributed on an \"AS    *\n*  IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either    *\n*  express or implied.  See the License for the specific language     *\n*  governing permissions and limitations under the License.           *\n*---------------------------------------------------------------------*\nSRVFISUB TITLE 'Batch job submit File service processor.'\n         SRVMOD NAME=SRVFISUB,DATES='1987, 1990'\n*---------------------------------------------------------------------*\n*\n*  Copyright (c) 1987 Clemson University\n*\n*  Program     SRVFISUB\n*\n*  Abstract    This server is the batch job submit file handler.  It\n*              recognizes filename *SUBMIT* and only supports writing\n*              to the file.  Writing to file *SUBMIT* causes the lines\n*              written to be submitted to the system as a batch job.\n*\n*  Special     The JES2 internal reader interface used by this program\n*  Note        is pretty obscure. It is a sanctioned interface, though\n*              and is documented in manual GG22-9207 \"JES2 Internal\n*              Reader Processing\".\n*\n*  Parameters:\n*    Two parameters, FileID and FunctionCode, are required for each\n*    call to the file manager.  Additional parameters are required for\n*    different FunctionCodes.  The entire parameter list required for\n*    each function is listed below.\n*\n*    START\n*     CALLX SRVFISUB,(FileID,&START,ESV,Info,FileName,Length,Options)\n*\n*    TERMINATE\n*     CALLX SRVFISUB,(FileID,&TERMINATE)\n*\n*    WRITELINE\n*     CALLX SRVFISUB,(FileID,&FI_WRITELINE,Line,Length)\n*\n*    GET_INFO\n*     CALLX SRVFISUB,(FileID,&FI_GET_INFO,InfoCode,**Info Dependent**)\n*                                       &FI_GI_NAME,Area,Size,NameLen)\n*                                       &FI_GI_MSG,Area,Size,MsgLen)\n*                                       &FI_GI_LRECL,Lrecl)\n*                                       &FI_GI_RECFM,Recfm)\n*                                       &FI_GI_IDSTRING,IdString)\n*    SET_STATUS\n*     CALLX SRVFISUB,(FileID,&FI_SET_STATUS,Status,\n*                     **Status Dependent**)\n*\n*  The meaning of each parameter is explained below.\n*\n*    FileID is a fullword used to uniquely identify the opened file.\n*      It is initialized during the startup function.\n*\n*    FunctionCode is a fullword integer that specifies the function to\n*      be performed.  Symbolic identifiers are provided for each\n*      function and may be accessed by placing a COPY statement for\n*      SRVFIMAC in the assembler program.  These symbols should be used\n*      in place of actual integer values.  The following FunctionCodes\n*      are supported:\n*\n*      &START\n*        Open a jobstream file and assign to it a unique identifier:\n*        FileID.  In addition to the FileID and FunctionCode\n*        parameters, the parameters ESV, FileName, and NameLength are\n*        required. The parameter Info is ignored, but its position in\n*        the parameter list must be maintained.\n*\n*\n*      &TERMINATE\n*        Close the file and set FileID to zeros.\n*\n*      &FI_WRITELINE\n*        Append a new line to the jobstream being written to the\n*        system for batch execution.  Each line recieved by this\n*        function is sent directly to the system, so the only way to\n*        keep anything from being actually run is to write a /*PURGE\n*        line.  If there are multiple JOB cards in the jobstream, each\n*        one must have a /*PURGE card before the next one is processed\n*        or it will be run anyways.\n*\n*      &FI_GET_INFO\n*        Return information, selected by InfoCode, about the file.  The\n*        following InfoCodes are supported:\n*\n*        &FI_GI_MSG\n*          Return the most-recently generated message in Area.  If the\n*          message is longer than Size, it will be truncated and no\n*          indication will be returned.  The size of the returned\n*          message (or Size, whichever is smaller) will be returned in\n*          the MsgLen parameter.\n*\n*\n*        &FI_GI_NAME\n*          Return the fully qualified data set name, including member\n*          name if the file is a PDS member.  The name will be returned\n*          in Area, and will be truncated to Size if neccessary.  The\n*          length of the file's name (or Size, whichever is smaller)\n*          will be returned in the NameLen parameter.  If truncation\n*          occurs, a message will be generated.\n*\n*        &FI_GI_LRECL\n*          Return the logical record length of the file as a signed\n*          halfword value in parameter Lrecl.\n*\n*        &FI_GI_RECFM\n*          Return an eight (8) byte character string describing the\n*          file's record format.  Currently, only the first character\n*          is used: it is 'F' for fixed length records and 'V' for\n*          varying length records.  All remaining characters are set to\n*          blanks.\n*\n*        &FI_GI_IDSTRING\n*          Return an eight (8) byte character string that can be used\n*          for identification purposes.  This string is not unique.\n*          For PDS members, IdString is the member name.  For\n*          sequential data sets, it is currently set to blanks.\n*\n*  Program     reentrant, problem key and state, standard linkage,\n*  Attributes  non-authorized, amode(any), rmode(any)\n*\n*  Change\n*  History     06/23/89 MJM - NEW\n*              04/23/90 MJM - Fixed a bug where the PWA never got   @C1\n*                             freed on session termination.  SMCTRL @C1\n*                             FREEPWA=YES was coded after the call  @C1\n*                             to subroutine TERMINATE, which always @C1\n*                             exits through the error exit.  Thus,  @C1\n*                             the PWA was never marked for release. @C1\n*                             I moved the SMCTRL instruction above  @C1\n*                             the call to TERMINATE to fix this.    @C1\n*              08/13/90 MJM - Added Dynamic allocation ERROR and    @C2\n*                             INFO codes to message FS00004S.       @C2\n*              06/01/06 MJM - Added DROPs for ESV addressing in\n*                             error exits to resolve assembly errors.\n*\n*---------------------------------------------------------------------*\n EJECT\n COPY  SMSYMS         | Obtain Structured Macros symbols.\n COPY  SRVESMAC       | Obtain Environment Support symbols & macros.\n COPY  SRVFIMAC       | Obtain File Handler symbols & macros.\n COPY  SRVSTMAC       | Obtain String Handler symbols & macros.\n*---------------------------------------------------------------------*\n*\n*  Macro:      TRIM\n*  Purpose:    Set R15 := the length of a string with trailing blanks\n*              removed.\n*\n*---------------------------------------------------------------------*\n         MACRO\n         TRIM &ADDR,&LEN\n         LA   R14,&ADDR             | R14 -> Start of string.\n         L    R15,&LEN              | R15 := Length of string.\n         ALR  R15,R14               | R15 -> Past end of string.\n         LOOP UNTIL                 | Loop backwards over string.\n           BCTR R15,0               |   Back up by one character.\n         ENDLOOP UNTIL,((CR,R15,LT,R14),OR,(CLI,0(R15),NE,C' '))\n         LA      R15,1(,R15)        | R15 -> Past final non-blank.\n         SLR     R15,R14            | R15 := trimmed length.\n         MEND\n*---------------------------------------------------------------------*\n*\n*  Macro:      MESSAGE (condition),(parameters)\n*              MESSAGE (parameters)\n*  Purpose:    Conditionally invoke the message subroutine.\n*\n*---------------------------------------------------------------------*\n         MACRO\n         MESSAGE\n         AIF   (N'&SYSLIST EQ 1).CALL\n         AIF   (N'&SYSLIST EQ 2).COND\n         MNOTE 8,'WRONG NUMBER OF PARMS'\n.CALL    CALLSUB MESSAGE,&SYSLIST(1)\n         MEXIT\n.COND    IF   &SYSLIST(1)\n           CALLSUB MESSAGE,&SYSLIST(2)\n         ENDIF\n         MEND\n EJECT\n***********************************************************************\n**                                                                   **\n**                                                                   **\n**                         SRVFISUB Main Program                     **\n**                                                                   **\n**                                                                   **\n***********************************************************************\n BLOCK NAME=SRVFISUB,TYPE=PROGRAM,AMODE=ANY,RMODE=24,R1SAVE=R9,        +\n               CPYRGHT='COPYRIGHT (C) 1987 CLEMSON UNIVERSITY',        +\n               OPTIONS=(*SRVPRC,LONG),SUBOPTS=(*SWA,LOADBASE)\n*---------------------------------------------------------------------*\n*  Establish addressability on data areas and validate the environment.\n*---------------------------------------------------------------------*\n   ST      R9,PWA_PARMLIST            | Save ParmList address in PWA.\n   USING   FI_PARMLIST,R9             | Establish addressability.\n   L       R8,PWAAESV                 | R8 -> Env Support Vector.\n   USING   ESV,R8                     | Establish addressability.\n   MVC     GDIRC,=H'0'                | Clear out return-code.\n   CALLSUB CHECK_PARMS                | Check parms and environment.\n*---------------------------------------------------------------------*\n*  Use the FunctionCode to determine which subroutine to invoke.\n*---------------------------------------------------------------------*\n   L       R1,FI_FUNCTIONCODE         | R1 -> function code.\n   L       R1,0(R1)                   | R1 := function code.\n   CASEBLK REG=R1,MULT=1              | Case on FunctionCode.\n     CASE &FI_START                   |   Open a new file.\n       CALLSUB START                  |\n     CASE &FI_TERMINATE               |   Close a file.\n       SMCTRL  FREEPWA=YES            |     Release the PWA on exit @C1\n       CALLSUB TERMINATE              |     Kill file and buffers.  @C1\n     CASE &FI_WRITELINE               |   Write a line to end of file.\n       CALLSUB WRITELINE              |\n     CASE &FI_GET_INFO                |   Obtain information.\n       CALLSUB GET_INFO               |\n     CASE &FI_SET_STATUS              |   Set file status.\n       CALLSUB SET_STATUS             |\n     CASE OTHER                       |   Invalid function code.\n       MESSAGE (FS00001,0(R2))        |\n   ENDCASE                            | EndCase.\n*                                     |\n   LH   R15,GDIRC                     |\n   DROP R8\n ENDBLK BLOCK=SRVFISUB                | Quit w/possible return code.\n EJECT\n***********************************************************************\n*                                                                     *\n*  SUBROUTINE: CHECK_PARMS                                            *\n*  ABSTRACT:   Check parameters and calling environment.              *\n*                                                                     *\n***********************************************************************\n BLOCK NAME=CHECK_PARMS,TYPE=SUBROUTINE\n*---------------------------------------------------------------------*\n*  Count the number of parameters passed in and save in PWA_#PARMS\n*---------------------------------------------------------------------*\n   LA   R1,FI_PARMLIST                | R1 -> first parameter.\n   LOOP WHILE,(TBIT,0(R1),X'80',OFF)  | Loop over parameters.\n     LA R1,4(,R1)                     |   Advance to next parameter.\n   ENDLOOP WHILE                      | EndLoop.\n   LA  R1,4(,R1)                      | Point past final parameter.\n   SLR R1,R9                          | Get length of entire parmlist.\n   SRL R1,2                           | Get number of parameters.\n   ST  R1,PWA_#PARMS                  | Save in PWA for future use.\n*---------------------------------------------------------------------*\n*  If the function code is something other than start, check the\n*  eye-catcher string and FileID.  If bad, the FileID is garbage.\n*---------------------------------------------------------------------*\n   L  R2,FI_FUNCTIONCODE              | R2 -> Fullword function code.\n   L  R2,0(R2)                        | R2 := Fullword function code.\n   IF (C,R2,NE,=F'&FI_START')         | If not startup function then.\n     ERREXIT (CLC,PWA_VISUAL,NE,EYECATCHER),CODE=&FI_INVALID_FILEID\n     ERREXIT (C,R13,NE,PWA_FILEID),CODE=&FI_INVALID_FILEID\n     IF (TBIT,PWA_F,PWA_F_IN_ERROR)\n       CASEBLK REG=R2,WREG=R2,MULT=1  |   Case on FunctionCode.\n       CASE &FI_TERMINATE,&FI_GET_INFO      These are always ok.\n       CASE OTHER                     |     Cannot do other functions.\n         MESSAGE (FS00011)            |     Halted by previous error.\n       ENDCASE                        |   EndCase.\n     ENDIF                            |   Endif.\n   ENDIF                              | Endif.\n ENDBLK BLOCK=CHECK_PARMS\n EJECT\n***********************************************************************\n*                                                                     *\n*  SUBROUTINE: START                                                  *\n*  ABSTRACT:   Open a file for the type of access requested. Since    *\n*              only OUTPUT_SEQUENTIAL is supported, insure that it    *\n*              is what was requested.                                 *\n*                                                                     *\n***********************************************************************\n BLOCK NAME=START,TYPE=SUBROUTINE\n*---------------------------------------------------------------------*\n*  Insure that all parameters were specified, and initialize PWA.\n*---------------------------------------------------------------------*\n   MVC     PWA_VISUAL,EYECATCHER      | Both the eyecatcher and the\n   ST      R13,PWA_FILEID             | fileid are validity checks.\n   MVI     PWA_F,X'00'                | Clear out state flags.\n   MESSAGE (CLC,PWA_#PARMS,LT,=F'7'),(FS00002,'START',5)\n*---------------------------------------------------------------------*\n*  Process the OPTIONS parameter.\n*---------------------------------------------------------------------*\n*\n*  Make sure that all reserved OPTIONS flags are zeros.\n*\n   L  R2,FI_OPTIONS                      | R2 -> options parameter.\n   IF (TBIT,0(R2),&FI_OC_RESERVED,ANY)   | If any reserved options.\n     MESSAGE (FS00014,(R2))              |   Issue an error message.\n   ENDIF                                 | EndIf.\n*\n*  Separate the remaining flags to make checking for specific values\n*  and combinations of values easier.\n*\n   MVC   &PWA.MODE,0(R2)                 | Save INPUT/OUTPUT flag.\n   NI    &PWA.MODE,&FI_OC_MODE           | Mask off other bits.\n   IF (CLI,&PWA.MODE,NE,&FI_OC_OUTPUT)   | If not OUTPUT mode.\n     MESSAGE (FS00013)                   |   Issue an error message.\n   ENDIF                                 | EndIf.\n*---------------------------------------------------------------------*\n*  Parse the file specification and open the file.\n*---------------------------------------------------------------------*\n   CALLSUB PARSE_FILESPEC              | Scan file-specification.\n   CALLSUB OPEN_FILE                   | Open the specified file.\n ENDBLK BLOCK=START\n EJECT\n***********************************************************************\n*                                                                     *\n*  SUBROUTINE: PARSE_FILESPEC                                         *\n*  ABSTRACT:   Parse the file-specification of the START function.    *\n*                                                                     *\n***********************************************************************\n BLOCK NAME=PARSE_FILESPEC,TYPE=SUBROUTINE\n*---------------------------------------------------------------------*\n*  R4 -> file-specification.  R5 -> last character in file-spec.\n*---------------------------------------------------------------------*\n   L       R4,FI_FILENAME             | R4 -> file-spec's text.\n   L       R5,FI_NAMELENGTH           | R5 -> length of file-spec.\n   L       R5,0(,R5)                  | R5 := length of file-spec.\n   LA      R0,=C'*SUBMIT*'            | R0 -> Only filespec allowed.\n   LA      R1,8                       | R1 := length of '*SUBMIT*'.\n   ICM     R1,B'1000',=C' '           | Pad comparison w/blanks.\n   IF      (CLCL,R4,NE,R0)            | If not *SUBMIT* then.\n     L       R4,FI_FILENAME           |   R4 -> file-spec's text.\n     L       R5,FI_NAMELENGTH         |   R5 -> length of file-spec.\n     MESSAGE (FS00100,0(R4),0(R5))    |   Issue syntax-error message.\n   ENDIF                              | EndIf.\n ENDBLK BLOCK=PARSE_FILESPEC\n EJECT\n***********************************************************************\n*                                                                     *\n*  SUBROUTINE: OPEN_FILE                                              *\n*  ABSTRACT:   Set up for writing a jobstream to the system.          *\n*                                                                     *\n***********************************************************************\n BLOCK NAME=OPEN_FILE,TYPE=SUBROUTINE,AMODE=31,OPTIONS=CODEBASE\n*---------------------------------------------------------------------*\n*  Dynamically allocate an internal reader.\n*---------------------------------------------------------------------*\n   LA    R6,O_DDNAME                | R6 -> DDNAME Text Unit.\n   USING S99TUNIT,R6                | Establish addressability.\n   MVC   S99TUKEY,=AL2(DALRTDDN)    |   Set return-ddname action key.\n   MVC   S99TUNUM,=H'1'             |   Set number of parameters = 1.\n   MVC   S99TULNG,=H'8'             |   Set length of return-area.\n*                                   |\n   LA    R7,O_RB                    | R7 -> Dynalloc request block.\n   USING S99RB,R7                   | Establish addressability.\n   FILL  O_RB,X'00'                 |   Clear request block to zeros.\n   MVI   S99RBLN,S99RBEND-S99RB     |   Set request block's length.\n   MVI   S99VERB,S99VRBAL           |   Set verb to 'allocate'.\n   PLIST (O_CLASS,O_PROGRAM,O_FREE,O_DDNAME),VL,PL=O_TXTPTRS\n   ST    R1,S99TXTPP                |   Set address of text unit plist.\n*                                   |\n   PLIST (O_RB),VL                  | R1 -> Request Block plist.\n   DYNALLOC                         | Invoke the DYNALLOC SVC.\n*                                   |\n   IF (TREG,R15,Z),THEN             | If dynamic allocation succeeded.\n     SBIT   PWA_F_ALLOCATED         |   Set allocated flag.\n     FILL   PWA_DDNAME,C' '         |   Blank out DDNAME in the PWA.\n     L16    R15,S99TULNG            |   R15 := length of DDNAME.\n     IF     NZ,THEN                 |   If a non-null DDNAME.\n       BCTR R15,0                   |     Subtract 1 for EX instr.\n       EXI  R15,(MVC,PWA_DDNAME(0),S99TUPAR)  Copy DDNAME to the PWA.\n     ENDIF                          |   EndIf.\n   ELSE                             | Else, check error/reason codes.\n     MVC PWA_S99ERROR,S99ERROR      | Remember the dynalloc error code.\n     IF  (CLC,S99ERROR,EQ,=X'0204') | If Storage not available.\n       CALLSUB MESSAGE,(FS00009)    |   Issue specific message.\n     ELSEIF (CLC,S99ERROR,EQ,=X'0214') ElseIf No internal reader avail.\n       CALLSUB MESSAGE,(FS00003)    |   Issue specific message.\n     ELSEIF (CLC,S99ERROR,EQ,=X'0238') ElseIf TIOT is full.\n       CALLSUB MESSAGE,(FS00020)    |   Issue specific message.\n     ELSEIF (CLC,S99ERROR,EQ,=X'0470') ElseIf NOJCL userid.\n       CALLSUB MESSAGE,(FS00019)    |   Issue specific message.\n     ELSE                           | Else.\n       CALLSUB MESSAGE,(FS00004,S99ERROR,S99INFO) Generic message.  @C2\n     ENDIF                          | EndIf.\n     DROP    R6,R7                  | Drop O_RB and Text Unit.\n   ENDIF                            | EndIf.\n*---------------------------------------------------------------------*\n* Build an Access Control Block (ACB).\n*---------------------------------------------------------------------*\n   BLOCK AMODE=24,TYPE=INLINE       | Switch to amode 24.\n     GENCB  BLK=ACB,DDNAME=(*,PWA_DDNAME),MF=(G,PWA_ACBPL,PWA_ACBPL_L),+\n               MACRF=(ADR,SEQ,OUT),WAREA=(S,PWA_ACB),LENGTH=PWA_ACB_L\n     ST     R15,PWA_RC              |  Save return-code.\n   ENDBLK                           | Switch back to amode 31.\n*                                   |\n   IF (CLC,PWA_RC,NE,=F'0')         | If ACB generation failed, then.\n     CALLSUB MESSAGE,(FS00005,PWA_RC)   Issue an error message.\n   ELSE                             | Else.\n     SBIT    PWA_F_ACB              |   Mark ACB as valid.\n   ENDIF                            | EndIf.\n*---------------------------------------------------------------------*\n* Open the internal reader.\n*---------------------------------------------------------------------*\n   PLIST  (PWA_ACB),VL              | R1 -> 1 entry paramter list.\n   BLOCK AMODE=24,TYPE=INLINE       | Switch to amode 24.\n     OPEN   MF=(E,(1))              |   Open the internal reader.\n     ST     R15,PWA_RC              |   Save return-code.\n   ENDBLK                           | Switch back to amode 31.\n*                                   |\n   IF (CLC,PWA_RC,NE,=F'0')         | If OPEN failed, then.\n     ST      R15,PWA_RC             |   Save bad return-code.\n     CALLSUB MESSAGE,(FS00006,PWA_RC)   Issue an error message.\n   ELSE                             | Else.\n     SBIT    PWA_F_OPENED           |   Mark file as OPEN.\n   ENDIF                            | EndIf.\n*---------------------------------------------------------------------*\n* Build the Request Parameter List (RPL).\n*---------------------------------------------------------------------*\n   BLOCK AMODE=24,TYPE=INLINE       | Switch to amode 24.\n     GENCB  BLK=RPL,WAREA=(S,PWA_RPL),LENGTH=PWA_RPL_L,                +\n               ACB=(S,PWA_ACB),OPTCD=(ADR,SEQ,SYN,NUP),                +\n               AREA=(S,PWA_LINE),RECLEN=L'PWA_LINE,                    +\n               MSGAREA=(S,PWA_MSG),MSGLEN=L'PWA_MSG,                   +\n               MF=(G,PWA_RPLPL,PWA_RPLPL_L)\n     ST     R15,PWA_RC              |   Save return-code.\n   ENDBLK                           | Switch back to amode 31.\n*                                   |\n   IF (CLC,PWA_RC,NE,=F'0')         | If RPL generation failed, then.\n     CALLSUB MESSAGE,(FS00008,PWA_RC)   Issue an error message.\n   ELSE                             | Else.\n     SBIT    PWA_F_RPL              |   Mark RPL as valid.\n   ENDIF                            | EndIf.\n*                                   |\n   MVC  PWA_RELATIVE_JOB#,=F'1'     | Processing first JOB in stream.\n   MVC  PWA_JOBID,=CL8'*NULL*'      | No job identifier assigned.\n ENDBLK BLOCK=OPEN_FILE\n*---------------------------------------------------------------------*\n*  Static data for opening a new jobstream file.\n*---------------------------------------------------------------------*\n             SSD\nO_CLASS      DC   AL2(DALSYSOU,1,1),C'A'        | SYSOUT=(A,...\nO_PROGRAM    DC   AL2(DALSPGNM,1,6),C'INTRDR'   |        ...INTRDR)\nO_FREE       DC   AL2(DALCLOSE,0)               | FREE=CLOSE\n             ENDSSD\n*---------------------------------------------------------------------*\n*  Working Storage for opening a new jobstream file.\n*---------------------------------------------------------------------*\n             SWA\nO_RB         DS  CL(S99RBEND-S99RB)  | Dynalloc request block.\nO_TXTPTRS    DS  CL(4*4)             | Parmlist for Text Unit Pointers.\nO_DDNAME     DS  CL14                | TextUnit for returned DDNAME.\n             ENDSWA\n EJECT\n***********************************************************************\n*                                                                     *\n*  SUBROUTINE: WRITELINE                                              *\n*  ABSTRACT:   Write the next line to the opened jobstream.           *\n*                                                                     *\n***********************************************************************\n BLOCK NAME=WRITELINE,TYPE=SUBROUTINE,AMODE=31\n*---------------------------------------------------------------------*\n*  Validate the current file status and the parameter list.\n*---------------------------------------------------------------------*\n   IF (TBIT,PWA_F_OPENED,OFF)       | If file is not opened.\n     MESSAGE (FS00012,'WRITELINE',9)    Issue an error message.\n   ELSEIF (TBIT,PWA_F_RPL,OFF)      | ElseIf RPL not built.\n     MESSAGE (FS00012,'WRITELINE',9)    Issue an error message.\n   ELSEIF (CLI,&PWA.MODE,NE,&FI_OC_OUTPUT)\n     MESSAGE (FS00013)\n   ENDIF                            | EndIf.\n*                                   |\n   SBIT PWA_F_IN_PROGRESS           | A non-ended job is in progress.\n   MVC  PWA_JOBID,=CL8'*NULL*'      | No job identifier assigned.\n*---------------------------------------------------------------------*\n*  Copy the output line to the RPL line-buffer.\n*---------------------------------------------------------------------*\n   LM   R0,R1,FI_WL_LINE            | R0 -> Text, R1 -> length.\n   L    R1,0(,R1)                   | R1 := length.\n   LA   R14,PWA_LINE                | R14 -> Output line area.\n   LA   R15,L'PWA_LINE              | R15 := Length of area.\n   ICM  R1,B'1000',=C' '            | Pad copy with blanks.\n   RBIT PWA_F_TRUNCATED             | Nothing truncated yet.\n   MVCL R14,R0                      | Copy output line to area.\n   IF   CC4,THEN                    | If it was truncated, then.\n     SBIT    PWA_F_TRUNCATED        |   Remember line truncated.\n   ENDIF                            | EndIf.\n*---------------------------------------------------------------------*\n*  Write the line to the internal reader and, if truncated, issue msg.\n*---------------------------------------------------------------------*\n   BLOCK AMODE=24,TYPE=INLINE       | Switch to amode 24.\n     PUT RPL=PWA_RPL                |   Write the new jobstream line.\n     ST  R15,PWA_RC                 |   Save return code.\n   ENDBLK                           | Switch back to amode 31.\n*                                   |\n   IF (CLC,PWA_RC,NE,=F'0')         | If write failed, then.\n     ST      R15,PWA_RC             |   Save bad return code.\n     CALLSUB MESSAGE,(FS00017,PWA_RC)   Issue an error message.\n   ENDIF                            | EndIf.\n*                                   |\n   IF (TBIT,PWA_F_TRUNCATED)        | If line was truncated, then.\n     CALLSUB MESSAGE,(FS00201,80)   |   Issue a warning message.\n   ENDIF                            | EndIf.\n ENDBLK BLOCK=WRITELINE\n EJECT\n***********************************************************************\n*                                                                     *\n*  SUBROUTINE: SET_STATUS                                             *\n*  ABSTRACT:   Set some item of the file's status.                    *\n*                                                                     *\n***********************************************************************\n BLOCK TYPE=SUBROUTINE,NAME=SET_STATUS\n   L       R2,FI_SS_FUNCTION         | R2 -> Status code to set.\n   L       R1,0(,R2)                 | R1 := Status code.\n   CASEBLK REG=R1,MULT=1             | Case on status code.\n     CASE &FI_SS_END_OF_FILE         |   Set end-of-file status.\n       CALLSUB ISSUE_ENDREQ          |     Tell JES about it.\n       IF (CLC,PWA_JOBID,NE,=CL8'*NULL*')  If a job submitted.\n         CALLSUB MESSAGE,(FS00200,PWA_JOBID) Issue submitted message.\n       ENDIF                         |     EndIf.\n     CASE OTHER                      |   Invalid status sub-code.\n       CALLSUB MESSAGE,(FS00018,0(R2))     Issue an error message.\n   ENDCASE                           | EndCase\n ENDBLK BLOCK=SET_STATUS\n EJECT\n***********************************************************************\n*                                                                     *\n*  SUBROUTINE: ISSUE_ENDREQ                                           *\n*  ABSTRACT:   Write the current line to the internal reader.         *\n*                                                                     *\n***********************************************************************\n BLOCK TYPE=SUBROUTINE,NAME=ISSUE_ENDREQ,AMODE=31\n*---------------------------------------------------------------------*\n*  Issue an ENDREQ to signify to JES that this is the end of the job.\n*---------------------------------------------------------------------*\n   LA     R7,PWA_RPL                 | R7 -> Request Parameter List.\n   USING  IFGRPL,R7                  | Establish addressability.\n*                                    |\n   BLOCK  AMODE=24,TYPE=INLINE       | Switch to amode 24.\n     ENDREQ RPL=(7)                  |   Tell JES this is end-of-job.\n     ST     R15,PWA_RC               |   Save return code.\n   ENDBLK                            | Switch back to amode 31.\n*                                    |\n   RBIT PWA_F_IN_PROGRESS            | No jobs currently in progress.\n   MVC  PWA_JOBID,RPLRBAR            | Copy system-assigned jobid.\n*                                    |\n   L    R1,PWA_RELATIVE_JOB#         | R1 := number of jobs submitted.\n   A    R1,=F'1'                     | Increment.\n   ST   R1,PWA_RELATIVE_JOB#         | Save back in the PWA.\n ENDBLK BLOCK=ISSUE_ENDREQ\n EJECT\n***********************************************************************\n*                                                                     *\n*  SUBROUTINE: TERMINATE                                              *\n*  ABSTRACT:   Close out and cleanup any/all files.                   *\n*                                                                     *\n***********************************************************************\n BLOCK NAME=TERMINATE,TYPE=SUBROUTINE,AMODE=31\n   LEAVE   BLOCK=*,(NOT,(TBIT,PWA_F_OPENED))  | Leave if nothing to do.\n   IF      (TBIT,PWA_F_IN_PROGRESS)           | If non-ended job, then.\n     CALLSUB ISSUE_ENDREQ                     |   End the job.\n   ENDIF                                      | EndIf.\n*---------------------------------------------------------------------*\n*  Close the internal reader, freeing it in the process.\n*---------------------------------------------------------------------*\n   PLIST  (PWA_ACB),VL               | R1 -> 1 entry paramter list.\n   BLOCK  AMODE=24,TYPE=INLINE       | Switch to amode 24.\n     CLOSE  MF=(E,(1))               |   Close internal reader.\n     ST     R15,PWA_RC               |   Save return code.\n   ENDBLK                            | Switch back to amode 31.\n   RBIT   PWA_F_OPENED               | Indicate it is now closed.\n*                                    |\n   IF (CLC,PWA_JOBID,NE,=CL8'*NULL*')  If a job submitted.\n     CALLSUB MESSAGE,(FS00200,PWA_JOBID) Issue submitted message.\n   ENDIF                             | EndIf.\n ENDBLK BLOCK=TERMINATE\n EJECT\n***********************************************************************\n*                                                                     *\n*  SUBROUTINE: GET_INFO                                               *\n*  ABSTRACT:   Return selected information to the caller.             *\n*                                                                     *\n***********************************************************************\n BLOCK NAME=GET_INFO,TYPE=SUBROUTINE\n*---------------------------------------------------------------------*\n*  Make sure that the information sub-code parameter was supplied.\n*---------------------------------------------------------------------*\n   IF (CLC,PWA_#PARMS,LT,=F'3')       | If no function sub-code.\n     CALLSUB MESSAGE,(FS00002,'GET_INFO',8)\n     LEAVE   BLOCK=*                  |   Should never get here.\n   ENDIF                              | EndIf.\n*---------------------------------------------------------------------*\n*  Call the routine that obtains the requested information.\n*---------------------------------------------------------------------*\n   L       R2,FI_GI_FUNCTION          | R2 -> information sub-code.\n   L       R1,0(,R2)                  | R1 := information sub-code.\n   CASEBLK REG=R1,WREG=R1,MULT=1      | Case on information sub-code.\n     CASE &FI_GI_MSG                  |   Get last message issued.\n       CALLSUB GET_INFO_MSG           |\n     CASE &FI_GI_NAME                 |   Get file's full name.\n       CALLSUB GET_INFO_NAME          |\n     CASE &FI_GI_LRECL                |   Get logical record length.\n       CALLSUB GET_INFO_LRECL         |\n     CASE &FI_GI_RECFM                |   Get record format.\n       CALLSUB GET_INFO_RECFM         |\n     CASE &FI_GI_IDSTRING             |   Get identification string.\n       CALLSUB GET_INFO_IDSTRING      |\n     CASE OTHER                       |   Invalid information code.\n       MESSAGE (FS00015,0(R2))        |\n   ENDCASE                            | EndCase\n ENDBLK BLOCK=GET_INFO                |\n EJECT\n***********************************************************************\n*                                                                     *\n*  SUBROUTINE: GET_INFO_MSG                                           *\n*  ABSTRACT:   Return the current message to the caller.              *\n*                                                                     *\n***********************************************************************\n BLOCK NAME=GET_INFO_MSG,TYPE=SUBROUTINE\n*---------------------------------------------------------------------*\n*  Check the number of parameters. There must be exactly 6 parms.\n*---------------------------------------------------------------------*\n   IF (CLC,PWA_#PARMS,NE,=F'6')         | If not exactly 6 parameters.\n     CALLSUB MESSAGE,(FS00002,'GET_INFO (MSG)',14)\n     LEAVE   BLOCK=*                    |   Should never get here.\n   ENDIF                                | EndIf.\n*---------------------------------------------------------------------*\n*  Copy the formatted message to the user's buffer.\n*---------------------------------------------------------------------*\n   LM   R2,R3,FI_GI_AREA            | R2/R3 -> text area, length.\n   L    R3,0(R3)                    | R3 := length of text area.\n   LM   R4,R5,PWA_MSG_DATA          | R4/R5 -> message text/length.\n   L    R5,0(R5)                    | R5 := length of message.\n   IF   (CR,R5,GT,R3)               | If too long to fit in area.\n     LR R5,R3                       |   Reduce to exact length.\n   ENDIF                            | EndIf.\n   L    R1,FI_GI_LENGTH             | R1 -> message length parm.\n   ST   R5,0(R1)                    | Save length of returned msg.\n   ICM  R5,8,=C' '                  | Pad copied text with blanks.\n   MVCL R2,R4                       | Copy information to caller.\n ENDBLK BLOCK=GET_INFO_MSG\n EJECT\n***********************************************************************\n*                                                                     *\n*  SUBROUTINE: GET_INFO_NAME                                          *\n*  ABSTRACT:   Return the file's name to the caller.                  *\n*                                                                     *\n***********************************************************************\n BLOCK NAME=GET_INFO_NAME,TYPE=SUBROUTINE\n*---------------------------------------------------------------------*\n*  Check the number of parameters. There must be exactly 6 parms.\n*---------------------------------------------------------------------*\n   IF (CLC,PWA_#PARMS,NE,=F'6')         | If not exactly 6 parameters.\n     CALLSUB MESSAGE,(FS00002,'GET_INFO (NAME)',15)\n     LEAVE   BLOCK=*                    |   Should never get here.\n   ENDIF                                | EndIf.\n*---------------------------------------------------------------------*\n*  Return the filename '*SUBMIT*'.\n*---------------------------------------------------------------------*\n   LM   R2,R3,FI_GI_AREA                | R2/R3 -> text area, length.\n   LA   R0,8                            | R0 := length of '*SUBMIT*'.\n   LA   R1,=C'*SUBMIT*'                 | R1 -> file name.\n   MVCL R2,R0                           | Copy to caller's area.\n*                                       |\n   IF   CC4,THEN                        | If message got truncated.\n     CALLSUB MESSAGE,(FS00007)          |   Issue a message and quit.\n   ENDIF                                | EndIf.\n ENDBLK BLOCK=GET_INFO_NAME\n EJECT\n***********************************************************************\n*                                                                     *\n*  SUBROUTINE: GET_INFO_LRECL                                         *\n*  ABSTRACT:   Return the file's logical record length as a halfword. *\n*                                                                     *\n***********************************************************************\n BLOCK NAME=GET_INFO_LRECL,TYPE=SUBROUTINE\n*---------------------------------------------------------------------*\n*  Check the number of parameters. There must be exactly 4 parms.\n*---------------------------------------------------------------------*\n   IF (CLC,PWA_#PARMS,NE,=F'4')         | If not exactly 4 parameters.\n     CALLSUB MESSAGE,(FS00002,'GET_INFO (LRECL)',16)\n     LEAVE   BLOCK=*             |   Should never get here.\n   ENDIF                                | EndIf.\n*---------------------------------------------------------------------*\n*  Return the internal reader's record length: 80.\n*---------------------------------------------------------------------*\n   IF (TBIT,PWA_F,PWA_F_OPENED,OFF)\n     CALLSUB MESSAGE,(FS00012,'GET_INFO (LRECL)',16)\n     LEAVE   BLOCK=*                    |   Should never get here.\n   ELSE                                 | Else.\n     L     R2,FI_GI_AREA                |   R2 -> Halfword for LRECL.\n     MVC   0(2,R2),=H'80'               |   Copy LRECL to parameter.\n   ENDIF                                | EndIf.\n ENDBLK BLOCK=GET_INFO_LRECL\n EJECT\n***********************************************************************\n*                                                                     *\n*  SUBROUTINE: GET_INFO_RECFM                                         *\n*  ABSTRACT:   Return the file's record format in an 8-byte field.    *\n*                                                                     *\n***********************************************************************\n BLOCK NAME=GET_INFO_RECFM,TYPE=SUBROUTINE\n*---------------------------------------------------------------------*\n*  Check the number of parameters. There must be exactly 4 parms.\n*---------------------------------------------------------------------*\n   IF (CLC,PWA_#PARMS,NE,=F'4')         | If not exactly 4 parameters.\n     CALLSUB MESSAGE,(FS00002,'GET_INFO (RECFM)',16)\n     LEAVE   BLOCK=*                    |   Should never get here.\n   ENDIF                                | EndIf.\n*---------------------------------------------------------------------*\n*  Return a single character indicating the file's record format.\n*---------------------------------------------------------------------*\n   IF (TBIT,PWA_F,PWA_F_OPENED,OFF)\n     CALLSUB MESSAGE,(FS00012,'GET_INFO (RECFM)',16)\n     LEAVE   BLOCK=*                    |   Should never get here.\n   ELSE                                 | Else.\n     L     R2,FI_GI_AREA                |   R2 -> Halfword for LRECL.\n     MVC   0(8,R2),PWA_RECFM            |   Copy RECFM to Area.\n   ENDIF                                | EndIf.\n ENDBLK BLOCK=GET_INFO_RECFM\n EJECT\n***********************************************************************\n*                                                                     *\n*  SUBROUTINE: GET_INFO_IDSTRING                                      *\n*  ABSTRACT:   Return the 8-character system-assigned job identifier. *\n*                                                                     *\n***********************************************************************\n BLOCK NAME=GET_INFO_IDSTRING,TYPE=SUBROUTINE\n*---------------------------------------------------------------------*\n*  Check the number of parameters. There must be exactly 4 parms.\n*---------------------------------------------------------------------*\n   IF (CLC,PWA_#PARMS,NE,=F'4')         | If not exactly 4 parameters.\n     CALLSUB MESSAGE,(FS00002,'GET_INFO (IDSTRING)',19)\n     LEAVE   BLOCK=*                    |   Should never get here.\n   ENDIF                                | EndIf.\n*                                       |\n   L    R2,FI_GI_AREA                   | R2 -> 8-byte return area.\n   MVC  0(8,R2),PWA_JOBID               | Copy job-identifier.\n ENDBLK BLOCK=GET_INFO_IDSTRING\n EJECT\n***********************************************************************\n*                                                                     *\n*  SUBROUTINE: MESSAGE                                                *\n*  ABSTRACT:   Format a message and exit the program.                 *\n*                                                                     *\n***********************************************************************\n BLOCK TYPE=SUBROUTINE,NAME=MESSAGE\n   LR   R2,R1                      | R2 -> Parameter list.\n   L    R4,0(R2)                   | R4 -> Message's ADCON.\n   L    R4,0(R4)                   | R4 -> Message Length, Text.\n*---------------------------------------------------------------------*\n*  Invoke the string-formatter to put together the message.\n*---------------------------------------------------------------------*\n   BLOCK TYPE=INLINE,NAME=FORMAT   | Block for formatting message.\n    L     R3,PWAAESV               |   R3 -> Env. support vector.\n    USING ESV,R3                   |   Establish addressability.\n    CALLX ESVESEPA,(ESVESTKN,&ES_LOAD_MODULE,&STRING_HANDLER,PWA_STEPA)\n    LEAVE BLOCK=*,(TREG,R15,NZ)    |   If string-handler not loaded.\n    CALLX PWA_STEPA,(PWA_STTKN,&START,PWAAESV,4)\n    LEAVE BLOCK=*,(TREG,R15,NZ)    |   If string-handler not started.\n*                                  |\n    PLIST (PWA_STTKN,&ST_FORMAT,PWA_MSG,=A(L'PWA_MSG),                 +\n               PWA_MSG_LEN,4(R4),0(R4)),NOVL,PL=PWA_PLIST\n*                                  |\n    LR    R1,R2                    |   R1 -> parm before 1st arg.\n    LA    R14,PWA_PLIST+(4*6)      |   R14 -> parm before 1st arg.\n    LA    R15,L'PWA_PLIST+PWA_PLIST    R15 -> last available arg.\n    LOOP  WHILE,(TBIT,0(R1),X'80',OFF) While not at last parameter.\n      LEAVE LOOP=*,(CR,R14,GE,R15) |     R15 -> last available arg.\n      LA    R1,4(,R1)              |     Advance to next parameter.\n      LA    R14,4(,R14)            |     Advance to next parameter.\n      MVC   0(4,R14),0(R1)         |     Save in plist.\n    ENDLOOP WHILE                  |   EndLoop.\n    OI    0(R14),X'80'             |   Flag it as last parm.\n    CALLX PWA_STEPA,PL=PWA_PLIST   |   Invoke the format function.\n    CALLX PWA_STEPA,(PWA_STTKN,&TERMINATE)\n    CALLX ESVESEPA,(ESVESTKN,&ES_UNLOAD_MODULE,&STRING_HANDLER,        +\n               PWA_STEPA)          |\n    DROP  R3                       |   Clean up addressability.\n    LA    R15,0                    |   Indicated string was formatted.\n   ENDBLK BLOCK=FORMAT             | EndBlk.\n*---------------------------------------------------------------------*\n*  If the message could not be formatted, use the unformatted version.\n*---------------------------------------------------------------------*\n   IF (TREG,R15,NZ)                | If formatting failed, then.\n     L    R5,0(R4)                 |   R5 := length of message text.\n     LA   R1,L'PWA_MSG             |   R1 -> Length of target area.\n     IF   (CR,R5,GT,R1)            |   If too long to fit, then.\n       LR R5,R1                    |     Use as much as possible.\n     ENDIF                         |   EndIf.\n     ST   R5,PWA_MSG_LEN           |   Save length of message\n     LR   R1,R5                    |   Set target to exact size.\n     LA   R4,4(R4)                 |   R4 -> message text.\n     LA   R0,PWA_MSG               |   R0 -> Target area of move.\n     MVCL R0,R4                    |   Copy message text.\n   ENDIF                           | EndIf.\n*---------------------------------------------------------------------*\n*  Invoke the error exit with the message's return-code.\n*---------------------------------------------------------------------*\n   IF (CLC,PWA_MSG(8),EQ,=C'FS00200I')  If end-of-job, then.\n     ERREXIT CODE=&FI_END_OF_FILE     |   Exit with the warning-code.\n   ELSEIF (CLI,PWA_MSG+7,EQ,C'W')     | If a warning message, then.\n     ERREXIT CODE=&FI_WARNING         |   Exit with the warning-code.\n   ELSEIF (CLI,PWA_MSG+7,EQ,C'E')     | ElseIf an error message, then.\n     ERREXIT CODE=&FI_ERROR           |   Exit with the error-code.\n   ELSEIF (CLI,PWA_MSG+7,EQ,C'S')     | ElseIf an error message, then.\n     ERREXIT CODE=&FI_SEVERE          |   Exit with the severe-code.\n   ELSEIF (CLI,PWA_MSG+7,EQ,C'X')     | ElseIf invalid filename.\n     MVI     PWA_MSG+7,C'E'           |   Change to 'error' message.\n     ERREXIT CODE=&FI_INVALID_SYNTAX  |   Exit with the syntax-code.\n   ELSE                               | Else\n     ERREXIT CODE=&FI_SEVERE          |   Exit with the error-code.\n   ENDIF                              | EndIf.\n ENDBLK BLOCK=MESSAGE\n EJECT\n***********************************************************************\n*                                                                     *\n*  Error exit for all functions in the file handler.                  *\n*                                                                     *\n***********************************************************************\n BLOCK TYPE=ERREXIT\n*---------------------------------------------------------------------*\n*  Save module/offset, registers, return-code.\n*---------------------------------------------------------------------*\n   STM   R0,R15,GDIREGS          | Save registers at time of error.\n   SM_LAL R0,SRVFISUB+4          | Point to module identification.\n   ST    R0,GDIMODID             | Save in general debug area.\n   MVC   GDIRC,0(R14)            | Copy return code.\n   SL    R14,=A(SRVFISUB)        | Calculate offset at time of error.\n   STH   R14,GDIOFFST            | Save in debug area.\n   L     R2,PWAAESV              |\n   USING ESV,R2                  |\n   CALLX ESVESEPA,(ESVESTKN,&ES_SAVE_DEBUG_INFO,&ES_DEBUG_ID_GDI,GDI)\n*---------------------------------------------------------------------*\n*  Check the return-code, and save the debugging message accordingly.\n*---------------------------------------------------------------------*\n   LH    R3,GDIRC                | R3 := return-code.\n   CASEBLK REG=R3,MULT=1         | Case on return-code.\n     CASE &FI_WARNING,&FI_ERROR,&FI_SEVERE,&FI_INVALID_SYNTAX,         +\n               &FI_END_OF_FILE\n       LA R4,PWA_MSG             |     R4 -> Formatted message text.\n       LA R5,PWA_MSG_LEN         |     R5 -> Length of formatted msg.\n     CASE OTHER                  |   Unknown error-code.\n       L  R5,FS00000             |     R5 -> Length of message.\n       LA R4,4(R5)               |     R4 -> Message text.\n   ENDCASE                       | EndCase.\n   STM   R4,R5,PWA_MSG_DATA      | Save address/length of message.\n*                                |\n   CALLX ESVESEPA,(ESVESTKN,&ES_SAVE_DEBUG_INFO,&ES_DEBUG_ID_TEXT,     +\n               (R4),(R5))\n*---------------------------------------------------------------------*\n*  Set the final return-code and exit.\n*---------------------------------------------------------------------*\n   LH R15,GDIRC                  | R15 := Return-code for this call.\n   IF (C,R15,GT,=F'&FI_WARNING') | If greater than a warning.\n     SBIT PWA_F_IN_ERROR         |   Set the error flag in the PWA.\n   ENDIF                         | EndIf.\n   DROP R2\n ENDBLK\n EJECT\n*---------------------------------------------------------------------*\n*\n*  Static Data\n*\n*---------------------------------------------------------------------*\n               PSD\n               LTORG\nEYECATCHER     DC   C'SRVFISUB' | Value moved to PWA on initialize.\n               EJECT\n*---------------------------------------------------------------------*\n* Messages are made up of a message identifier followed by a control\n* string.  The message identifier has the format\n*\n*   FSnnnnns\n*\n* where the characters FS always begin a Submit-file Handler's message,\n* nnnnn is the unique message number, and s indicates the message's\n* severity.\n*\n* Severity                  Meaning\n* --------   ---------------------------------------------\n*    I       Informational.\n*    W       Warning message.\n*    E       An error occurred, but execution can continue.\n*    S       Severe error.  Execution cannot continue.\n*    X       Filename syntactically invalid.\n*    C       Critical error.  Indicates a probable programming error.\n*\n*---------------------------------------------------------------------*\n            MACRO\n            MSG   &NUMBER,&SEVERITY,&TEXT\n            LCLC  &MSGID,&OLDLOC\n&OLDLOC     SETC  '&SYSLOC'\n&MSGID      SETC  'FS&NUMBER'\n&MSGID      DC    A(MSGT&SYSNDX)\nXSMSGS      LOCTR ,\nMSGT&SYSNDX DC    AL4(MSGL&SYSNDX)\n            DC    C'&MSGID&SEVERITY '\n            DC    C&TEXT\nMSGL&SYSNDX EQU   *-MSGT&SYSNDX-4\n&OLDLOC     LOCTR ,\n            MEND\n*\n MSG 00000,C,'Unknown error.'\n MSG 00001,C,'Invalid function-code parameter: {I}.'\n MSG 00002,C,'Wrong number of parameters for the {CL?} function.'\n MSG 00003,S,'No internal readers are available at this time.'\n MSG 00004,S,'Unable to allocate to an internal reader: DYNALLOC Error +\n               ({XL2},{XL2}).'                                      @C2\n MSG 00005,S,'Unable to build an Access Control Block (ACB) for writing+\n                to the internal reader. GENCB RC={I}.'\n MSG 00006,S,'Unable to open the internal reader for output.'\n MSG 00007,S,'File name truncated in GET_NAME function.'\n MSG 00008,S,'Unable to build a Request Parameter List (RPL) for writin+\n               g to the internal reader. GENCB RC={I}.'\n MSG 00009,S,'Not enough storage to operate.'\n MSG 00011,C,'Processing halted due to a previous error.'\n MSG 00012,S,'Function {CL?} not performed; file is not open.'\n MSG 00013,C,'Sequential input not supported by SRVFISUB.'\n MSG 00014,C,'Unsupported file access mode: {I}.'\n MSG 00015,C,'Invalid information code ({I}) for the GET_INFO function.+\n               '\n MSG 00016,S,'Function {CL?} not performed; file is not open.'\n MSG 00017,S,'Error while writing to internal reader. PUT RC={I}.'\n MSG 00018,C,'Invalid information code ({I}) for the SET_STATUS functio+\n               n.'\n MSG 00019,S,'Not authorized to submit batch jobs.'\n MSG 00020,S,'Dynamic allocation limit exceeded: free one or more files.\n               '\n*\n MSG 00100,X,'File name \"{CL?}\" not supported by the Submit file handle+\n               r; specify as \"*SUBMIT*\".'\n MSG 00200,I,'{CL8 T} submitted.'\n MSG 00201,W,'Output record was truncated to {I} characters.'\n*\n            ENDPSD\n            EJECT\n***********************************************************************\n*                                                                     *\n*  Program Work Area                                                  *\n*                                                                     *\n***********************************************************************\n                     PWA\nPWA_VISUAL           DS  CL(L'EYECATCHER)\nPWA_FILEID           DS  A           | Unique file identifier.\nPWA_#PARMS           DS  F           | Number of parms passed in.\nPWA_PARMLIST         DS  A           | Address of parameter list.\nPWA_RC               DS  F           | Return code from external fcns.\nPWA_S99ERROR         DS  H           | Dynalloc's error-code.\n*                                    |\n&PWA.MODE            DS  X           | Access mode: INPUT/OUTPUT.\nPWA_DDNAME           DS  CL8         | DDNAME of internal reader.\nPWA_JOBID            DS  CL8         | Job identifier.\nPWA_RELATIVE_JOB#    DS  F           | Relative JOB within jobstream.\n*                                    |\nPWA_STEPA            DS  A           | String-handler's entry-point.\nPWA_STTKN            DS  F           | String-handler's token.\nPWA_F                DS  X           | State information.\nPWA_F_ALLOCATED      EQU B'10000000' |   Internal reader allocated.\nPWA_F_ACB            EQU B'01000000' |   Internale reader allocated.\nPWA_F_OPENED         EQU B'00100000' |   File successfully opened.\nPWA_F_RPL            EQU B'00010000' |   Internale reader allocated.\nPWA_F_IN_ERROR       EQU B'00001000' |   Halted due to an error.\nPWA_F_TRUNCATED      EQU B'00000100' |   Output line truncated.\nPWA_F_IN_PROGRESS    EQU B'00000010' |   Jobstream not ENDREQed yet.\n*                                    |\nPWA_ACB              ACB ,           |   Access Control Block.\nPWA_ACB_L            EQU *-PWA_ACB   |   Length of access control block\n                     DS  0F          |   Align to a fullword boundary.\nPWA_ACBPL            DS  CL(PWA_ACBPL_L) Used by GENCB BLK=ACB.\n*                                    |\nPWA_RPL              RPL AM=VSAM     |   Request Parameter Block.\nPWA_RPL_L            EQU *-PWA_RPL   |   Length of request parm block.\n                     DS  0F          |   Align to a fullword boundary.\nPWA_RPLPL            DS  CL(PWA_RPLPL_L) Used by GENCB BLK=RPL.\n*                                    |\nPWA_LINE#            DS  F           | Current line number.\nPWA_LINE_LEN         DS  F           | Length of current input line.\nPWA_LINE             DS  CL80        | Text of output line.\nPWA_LRECL            DS  H           | Logical record length.\nPWA_RECFM            DS  CL8         | Record format: 'F' or 'V'.\n*                                    | Error tracking information.\nPWA_PLIST            DS  CL(4*17)    |   Parameter list area.\nPWA_REF              DS  F           |   Latest return/reason code.\nPWA_MSG_DATA         DS  2F          |   Address/length of message.\nPWA_MSG_LEN          DS  F           |   Short description of error.\nPWA_MSG              DS  CL256       |   Error, Warning, or Info.\n                     ES_GDI DSECT=NO |   Debugging area.\n                     ENDPWA\n                     EJECT\n***********************************************************************\n*  Parameter list for the File Handler.\n***********************************************************************\n           FI_PARMLIST         | File Handler parameter list.\n           EJECT\n           ES_ESV\n           IEFZB4D0       ,    | Dynamic allocation (SVC99) data areas.\n           IEFZB4D2       ,    | Dynamic allocation text unit keys.\n           IFGRPL    DSECT=YES | Request parameter list mapping.\n           END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SRVFIXRZ": {"ttr": 25351, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x02\\x00\\x00W\\x01\\x11)\\x9f\\x01\\x11)\\x9f\\t'\\x00\\xd6\\x00\\xd6\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@\"", "ispf": {"version": "02.00", "flags": 0, "createdate": "2011-10-26T00:00:00", "modifydate": "2011-10-26T09:27:57", "lines": 214, "newlines": 214, "modlines": 0, "user": "CLEMSON"}, "text": "*---------------------------------------------------------------------*\n*  Copyright 2011 by Clemson University Research Foundation           *\n*                                                                     *\n*  Licensed under the Apache License, Version 2.0 (the \"License\");    *\n*  you may not use this file except in compliance with the License.   *\n*  You may obtain a copy of the License in this library as member     *\n*  $LICENSE, or from                                                  *\n*                                                                     *\n*      http://www.apache.org/licenses/LICENSE-2.0                     *\n*                                                                     *\n*  Unless required by applicable law or agreed to in writing,         *\n*  software distributed under the License is distributed on an \"AS    *\n*  IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either    *\n*  express or implied.  See the License for the specific language     *\n*  governing permissions and limitations under the License.           *\n*---------------------------------------------------------------------*\n//SRVFIXRZ JOB TIME=(,3)\n/*JOBPARM LINES=9\n//  EXEC  ASMPCL,COPT=',RENT',LOPT=',RENT,REUS,REFR,AC=1',\n//    PDS='SYS1.APF.TEST',NAME=SRVFIXRZ,MAC=SYSTEMS\n//P.SYSIN  DD  *\n     SMLIST CONVERT=YES\nSRVFIXRZ     TITLE 'Exerciser For OS File Handler Service Processor'\n*---------------------------------------------------------------------*\n*\n*  Copyright (C) 1989 Clemson University\n*\n*  Program     SRVFIXRZ\n*\n*  Abstract    This routine is used as an exerciser for the macros and\n*              functions of the OS File Handler service processor.{\n*              xxx\n*\n*  Inputs:\n*      Parameters  None\n*      Files       See the code\n*      Other       None\n*\n*  Outputs:\n*      Returncodes xxxxx\n*      Messages    xxxxx\n*      Files       See the code\n*      Other       None\n*\n*  PROGRAM     Reentrant, problem key and state, standard linkage,\n*  ATTRIBUTES  non-authorized, AMODE(24), RMODE(24)\n*\n*  Special     xxx\n*  Notes       xxx\n*\n*  Change\n*  History     09/15/89 ___ - New\n*              __/__/__ ___\n*              __/__/__ ___\n*\n*  Method of   xxx\n*  Operation   xxx\n*\n*\n*---------------------------------------------------------------------*\n         EJECT\n     print off\n     copy  srvesmac\n     copy  srvplmac\n     copy  srvfimac\n     print on,gen\n     copy  ##plist\n     eject\n block name=SRVFIXRZ,type=program,options=(*pwa,xa,mode),amode=31,     *\n               rmode=any\n     eject\n  modeset key=zero,mode=sup\n  es_id id=es,esva=pwa_esv_address,                                    +\n               spepa=pwa_es_epa,                                       +\n               sptoken=pwa_es_token\n     space 3\n  pl_id        id=pl,esva=pwa_esv_address,                             *\n               esid=es,                                                *\n               spepname=&Print_Line,                                   *\n               spepa=pwa_epa,                                          *\n               sptoken=pwa_pl_token,                                   *\n               sizelength=4\n     space 3\n  fi_id        id=FI,esva=pwa_esv_address,                             *\n               esid=es,                                                *\n               spepa=pwa_fi_epa,                                       *\n               spepname=&fi_os_file_handler\n  fi_id        id=FO,esva=pwa_esv_address,                             *\n               esid=es,                                                *\n               spepa=pwa_fi_epa,                                       *\n               spepname=&fi_os_file_handler\n     eject\n  es_MVS_load id=ES\n  ES_Start id=ES\n  ES_Load_Module id=ES,spid=PL\n  if    (treg,r15,nz)\n   ex    0,*\n  endif\n  PL_Start     ID=PL,                                                  *\n               DDNAME=stcddnam,                                        *\n               PageSize=55,                                            *\n               MaxLnSz=121\n  errexit (treg,r15,nz)\n  ES_Load_Module id=ES,spid=FI\n  if    (treg,r15,nz)\n   ex    0,*\n  endif\n  FI_Start     ID=FI,                                                  *\n               file=psd_dsname,                                        *\n               options=(input,filename)\n  errexit (treg,r15,nz)\n  FI_OS_Info   unit=psd_sysda,      << not presently used >>           *\n               dirblks=psd_dirblks,                                    *\n               pl=pwa_info\n  FI_Start     ID=FO,                                                  *\n               file=psd_dsnout,                                        *\n               recordlength=(80),                                      *\n               options=(output,existing)\n*              recordlength=(80,251),\n*              filesize=(15000,5000),\n  errexit (treg,r15,nz)\n  PL_Set_Formatted_Header ID=PL,                                       *\n               Line=10,                                                *\n               control=\"1Listing of dataset {CL? T}:\",                 *\n               Source=(psd_dsname,=a(l'psd_dsname))\n  errexit (treg,r15,nz)\n  PL_Set_Header ID=PL,                                                 *\n               Line=20,                                                *\n               string=\" \"\n  errexit (treg,r15,nz)\n  la    r7,1\n  loop  until\n   st    r7,pwa_counter\n   fill  pwa_input_line,c' '\n   fi_readline id=FI,                                                  *\n               line=pwa_input_line,                                    *\n               resultlen=pwa_input_length\n   if    (treg,r15,nz)\n    if    (ch,r15,eq,=h'&fi_end_of_file')\n     PL_print_formatted ID=PL,                                         *\n               control=\"0End of listing of {CL? T}.\",                  *\n               Source=(psd_dsname,=a(l'psd_dsname))\n     errexit (treg,r15,nz)\n     leave loop=*\n    else\n     errexit (treg,r15,nz)\n    endif\n   endif\n   la    r1,pwa_input_line          Trim input line\n   la    r15,71(r1)\n   loop  bct\n    leave loop=*,(cli,0(r15),ne,c' '),or,(cr,r15,le,r1)\n   endloop bct,r15\n   la    r15,1(r15)\n   if    (cr,r15,le,r1)\n    la    r15,1\n   else\n    sr    r15,r1\n   endif\n   st    r15,pwa_line_length\n   fi_writeline id=FO,                                                 *\n               line=(pwa_input_line,pwa_line_length)\n   errexit (treg,r15,nz)\n   PL_Print_Formatted id=PL,                                          **\n               control=\" Line {I}: {CL80 T}\",                          *\n               Source=(pwa_counter,pwa_input_line)  pwa_input_length)\n   errexit (treg,r15,nz)\n   la    r7,1(r7)\n  endloop until,leave\n     eject\n  PL_Terminate   ID=PL\n  errexit (treg,r15,nz)\n  FI_Terminate   ID=FI\n  errexit (treg,r15,nz)\n  FI_Terminate   ID=FO\n  errexit (treg,r15,nz)\n     eject\n  modeset key=nzero,mode=prob\n endblk\n block type=errexit\n* ex    0,*\n  es_display_debug_info_and_abend id=es\n endblk\n     psd   ,\nstcddnam dc   cl8'sysprint'\npsd_dsname  dc  c'''MICHAEL.misc.clist(dttest)''' Something to list.\npsd_dsnout  dc  c'''MICHAEL.DOESNT.EXIST(sample2)'''\npsd_sysda   dc   cl8'sysda'\npsd_sp000a  dc   cl6'sp000a'\npsd_dirblks dc   al3(15)\n     endpsd ,\n     pwa   ,\npwa_info ds    cl12   ,3f\npwap1    ds    f\npwap2    ds    f\npwap3    ds    f\npwapage# ds    f\npwapage#2 ds   f\npwaline# ds    f\npwa_counter ds f\npwa_esv_address   ds   f\npwa_epa           ds   f\npwa_es_epa        ds   f\npwa_fi_epa        ds   f\npwa_pl_token      ds   f\npwa_es_token      ds   f\npwa_input_line    ds   cl251\npwa_input_length  ds   f\npwa_line_length   ds   f\n     endpwa ,\n     end   ,\n//C.SYSLIB DD\n//         DD\n//         DD DSN=SYSTEMS.SRV.SOURCE,DISP=SHR\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SRVIM": {"ttr": 25356, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x02\\x00\\x00W\\x01\\x11)\\x9f\\x01\\x11)\\x9f\\t'\\x1b\\xde\\x1b\\xde\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@\"", "ispf": {"version": "02.00", "flags": 0, "createdate": "2011-10-26T00:00:00", "modifydate": "2011-10-26T09:27:57", "lines": 7134, "newlines": 7134, "modlines": 0, "user": "CLEMSON"}, "text": "*---------------------------------------------------------------------*\n*  Copyright 2011 by Clemson University Research Foundation           *\n*                                                                     *\n*  Licensed under the Apache License, Version 2.0 (the \"License\");    *\n*  you may not use this file except in compliance with the License.   *\n*  You may obtain a copy of the License in this library as member     *\n*  $LICENSE, or from                                                  *\n*                                                                     *\n*      http://www.apache.org/licenses/LICENSE-2.0                     *\n*                                                                     *\n*  Unless required by applicable law or agreed to in writing,         *\n*  software distributed under the License is distributed on an \"AS    *\n*  IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either    *\n*  express or implied.  See the License for the specific language     *\n*  governing permissions and limitations under the License.           *\n*---------------------------------------------------------------------*\nSRVIM    TITLE 'Item Manager Service Processor'\n         SMLIST CONVERT=YES           |\n         srvmod name=srvim,dates='1989, 1991, 1995'\n         gblc  &srv_modname\n*---------------------------------------------------------------------*\n*\n*  Copyright (C) Clemson University Research Foundation 1989, 1991.\n*\n*  Program     SRVIM, Item Manager Service Processor.\n*\n*  Abstract    The Item Manager Service Processor can be used to\n*              manage units of storage, which this service processor\n*              refers to as items.  Items are maintained in IMMS\n*              (Item Manager Managed Storage).\n*\n*              The storage occupied by items can optionally be\n*              backed on secondary storage.  To do this, the caller\n*              must provide on startup to this processor, the EPA of\n*              a service processor similiar to the MVS DIV Service\n*              Processor (SRVMVSDV).\n*\n*  >>>>> Warning <<<<<\n*\n*  This module is still not completely developed.  It is working with\n*  limited function.  The functions that are not yet available are\n*  noted in the following description.\n*\n*  Special note:\n*     This program uses registers 4 through 8 exclusively to reference\n*     IMMS.  This should aid in the conversion of this program to\n*     use MVS data spaces.  Because of this convention, there is\n*     some code that appears to be duplicate.  Usually this is\n*     because one piece of code accesses an item in IMMS and one\n*     accesses it in the caller's space.\n*\n*  Functions, Description and Syntax:\n*\n*    Two parameters, ItemID and FunctionCode, are required for each\n*    call to the Item manager.  Additional parameters are required\n*    for different FunctionCodes.  The entire parameter list required\n*    for each function is listed below. A \"<\" before a parameter means\n*    that it is returned to the caller.  A \">\" before a parameter\n*    indicates that the parameter is passed to the service processor.\n*    \"<>\" means both.  A parameter followed by an \"|\" is optional or\n*    has a default.  If the \"|\" is followed by a value, that value is\n*    the default.\n*\n*    START\n*\n*      The start function is used to start the item manager and\n*      optionally associate a DIV manager with the item manager.\n*\n*      CALLX SRVIM,(<ItemID,&IM_Start,\n*        <ESV,\n*        >Options,\n*        >DIV_EPA|,\n*        >DIV_DDName|)\n*\n*    TERMINATE\n*\n*      The terminate function is used to terminate the item manager.\n*\n*      CALLX SRVIM,(>ItemID,&IM_Terminate)\n*\n*    INITIALIZE\n*\n*      The initialize function is used to initialize IMMS (Item manager\n*      managed storage).  This function should be called immediately\n*      after a &IM_ITEM_STORAGE_NOT_INITIALIZED return code from the\n*      IM_START function.\n*\n*      CALLX SRVIM,(>ItemID,&IM_Initialize,\n*        >ITDStgSize|65536,\n*        >UAStgIncr|65536,\n*        >SysStgIncr|4096,\n*        >DUStgIncr|65536)\n*\n*    SAVE\n*\n*      The save function will use the DIV manager supplied at startup\n*      to save all changes made to IMMS since startup or the\n*      last save function.\n*\n*      CALLX SRVIM,(>ItemID,&IM_Save)\n*\n*    RESET\n*\n*      The reset function will use the DIV manager supplied at\n*      startup to throw away all changes made to IMMS since\n*      startup or the last save function.\n*\n*      CALLX SRVIM,(>ItemID,&IM_Reset)\n*\n*    ADD_TO_DIRECTORY\n*\n*      This function adds a name and token to the token directory.\n*\n*      CALLX SRVIM,(>ItemID,&IM_Add_To_Directory,\n*        >NameLength,\n*        >Name,\n*        >Token)\n*\n*    FIND_IN_DIRECTORY\n*\n*      This function finds the token associated with a name in the\n*      token directory.\n*\n*      CALLX SRVIM,(>ItemID,&IM_Find_In_Directory,\n*        >NameLength,\n*        >Name,\n*        <Token)\n*\n*    REMOVE_FROM_DIRECTORY\n*\n*      This function removes a name from the token directory.\n*\n*      CALLX SRVIM,(>ItemID,&IM_Find_In_Directory,\n*        >NameLength,\n*        >Name)\n*\n*    CREATE_ITEM_TYPE_DESCRIPTOR\n*\n*      The create item type descriptor function will create an ITD\n*      (item type descriptor) in <64K system IMMS.  All items\n*      have a ITD token in the first two bytes.  This descriptor\n*      contains information about a item of a given type, such as size,\n*      number of links, etc.  ITD tokens will never have a value\n*      greater than 65,535, which is the largest unsigned number that\n*      can fit in two bytes.\n*\n*      CALLX SRVIM,(>ItemID,&IM_Create_Item_Type_Descriptor,\n*        <DescriptorToken,\n*        >Text|,\n*        >Options|x'00',\n*           First_Link_Has_Description\n*        >GroupDescriptorToken|DefaultUserGroup,\n*        >ItemLength|0,\n*        >NumberOfLinks|0,\n*        >FirstLinkOffset|,\n*        >ItemLengthSize|,\n*        >ItemLengthOffset|,\n*        >NumberOfLinksSize|,\n*        >NumberOfLinksOffset|,\n*        >FirstLinkOffsetSize|,\n*        >FirstLinkOffsetOffset|)\n*\n*    CREATE_GROUP_DESCRIPTOR\n*\n*      The create group descriptor function will create a GRD (group\n*      descriptor) in system IMMS.  Groups are used to group\n*      together items of certain types in IMMS.  IMMS for\n*      a groups of items are obtained in increments that are the size\n*      contained in the group descriptor or the size of the item,\n*      whichever is larger, and is rounded up to a multiple of 4096\n*      bytes.\n*\n*      CALLX SRVIM,(>ItemID,&IM_Create_Group_Descriptor,\n*        <DescriptorToken,\n*        >Text|,\n*        >IncrementSize|4096)\n*\n*    CREATE_LINKED_LIST_DESCRIPTOR\n*\n*      The create linked list descriptor function will create a LLD\n*      (linked list descriptor) in system IMMS.\n*\n*      CALLX SRVIM,(>ItemID,&IM_Create_Linked_List_Descriptor,\n*        <DescriptorToken,\n*        >Text|,\n*        >Options|x'00',\n*        >StartLinkNumber,\n*        >EndLinkNumber|,\n*        >ForwardLinkNumber,\n*        >ReverseLinkNumber|,\n*        >OwnerLinkNumber|,\n*        >KeyOffset|0,\n*        >KeyLength|0,\n*        >KeyLengthOffset|)\n*\n*\n*    CREATE_HASH_TABLE_DESCRIPTOR\n*\n*      The create hash table descriptor function will create a HTD\n*      (hash table descriptor) in system IMMS.\n*\n*      CALLX SRVIM,(>ItemID,&IM_Create_Hash_Table_Descriptor,\n*        <DescriptorToken,\n*        >Text|,\n*        >Options|x'00',\n*        >EntriesInTable,\n*        >SynonymLinkNumber,\n*        >KeyOffset,\n*        >KeyLength|0,       Either KeyLength or KeyLengthOffset is\n*        >KeyLengthOffset|)  required.\n*\n*\n*    CREATE_BINARY_TREE_DESCRIPTOR                (not yet supported)\n*\n*      The create binary tree descriptor function will create a BTD\n*      (binary tree descriptor) in system IMMS.\n*\n*      CALLX SRVIM,(>ItemID,&IM_Create_Binary_Tree_Descriptor,\n*        <DescriptorToken,\n*        >Text|,\n*        not defined yet.\n*\n*    DESTROY                                      (not yet supported)\n*\n*      The destroy function will destroy a descriptor created with\n*      one of the create functions.\n*\n*      CALLX SRVIM,(>ItemID,&IM_Destroy,\n*         >DescriptorToken,\n*         >ForceFlag|\"N\")\n*\n*    GET_DANGEROUS_ADDRESSES\n*\n*      The get dangerous addresses function get the address of certain\n*      internal item manager control blocks and service routines.  It\n*      is only intended to allow a clean interface for writing\n*      utility programs that process IMMS and is not intended\n*      for normal application programs.  MOST OF THE INTEGRITY AND\n*      REDUNDANCY BUILT INTO THE ITEM MANAGER CAN BE BYPASSED BY THE\n*      USE OF THIS FUNCTION.  Do you get the idea that its use is\n*      highly discouraged?\n*\n*      All right, I admit it ... I use this function.\n*\n*      CALLX SRVIM,(>ItemID,&IM_Get_Dangerous_Addresses,\n*        >TokenConvertRoutine|)\n*\n*    CONNECT\n*\n*      The connect function will connect an item to whatever is\n*      described by a descriptor.  The descriptor can be a LLD, HTD or\n*      BTD.  The item will become current of descriptor.  If ItemToken\n*      is not specified, the current item of item manager is used.  If\n*      HeadToken is not specified and the descriptor describes a\n*      multiple occurance, the current of item type of the heads,\n*      as specified on the associated create funtion, is used.\n*\n*      CALLX SRVIM,(>ItemID,&IM_Connect,\n*        >DescriptorToken,>ItemToken|,>HeadToken|)\n*\n*    DISCONNECT                                   (not yet supported)\n*\n*      The disconnect function will disconnect an item from whatever is\n*      described by a descriptor.  The descriptor can be a LLD, HTD or\n*      BTD.  The item will become current of descriptor.  If ItemToken\n*      is not specified, the current item of item manager is used.  If\n*      HeadToken is not specified and the descriptor describes a\n*      multiple occurance, the current of item type of the heads,\n*      as specified on the associated create funtion, is used.\n*\n*      CALLX SRVIM,(>ItemID,&IM_Disconnect,\n*        >DescriptorToken,>ItemToken|,>HeadToken|,>PreviousToken|)\n*\n*    ERASE\n*\n*      The erase function frees the storage associated with an\n*      item.  If the item token is not specified, the current item\n*      of item manager is erased.  All link pointers in the item\n*      must be null before the item can be erased unless the force\n*      option is \"Y\".\n*\n*      CALLX SRVIM,(>ItemID,&IM_Erase,\n*        >Options|x'00',>ItemToken|)\n*\n*    FIND\n*\n*      The find function will locate a given item by its item token.\n*      The item will become current for item manager and current for\n*      item type.\n*\n*      CALLX SRVIM,(>ItemID,&IM_Find,\n*        >ItemToken,\n*        <ActualItemSize|)\n*\n*    FIND_BY_KEY                                  (not yet supported)\n*\n*      The find by key function will obtain a given item by key, from\n*      whatever is associated with a given descriptor.  The item will\n*      become current for item manager, current for descriptor, and\n*      current for item type.\n*\n*      CALLX SRVIM,(>ItemID,&IM_Find_by_Key,\n*        >DescriptorToken,\n*        >KeySize,\n*        >Key,\n*        <ActualItemSize|,\n*        <ItemToken|)\n*\n*    FIND_CURRENT_OF_ITEM_TYPE\n*\n*      The find current of item type function will locate the item\n*      that is current of a given item type.  The item becomes\n*      current of item manager and remains current of item type.\n*\n*      CALLX SRVIM,(>ItemID,&IM_Find_Current_of_Item_Type,\n*        >ItemType,\n*        <ActualItemSize|,\n*        <ItemToken|)\n*\n*    FIND_CURRENT_FOR_DESCRIPTOR\n*\n*      The find current of descriptor function will locate the\n*      item that is current of descriptor for the descriptor\n*      specified.  The item obtained becomes current of item manager\n*      and current of item type and remains current of descriptor.\n*\n*      CALLX SRVIM,(>ItemID,&IM_Find_Current_for_Descriptor,\n*        >DescriptorToken,\n*        <ActualItemSize|,\n*        <ItemToken|)\n*\n*    FIND_NEXT\n*\n*      The find next function will locate the next item after the\n*      item that is current of a given descriptor.  The item will\n*      become current of item manager, current of item type and\n*      current of descriptor.\n*\n*      CALLX SRVIM,(>ItemID,&IM_Find_Next,\n*        >DescriptorToken,\n*        <ActualItemSize|,\n*        <ItemToken|)\n*\n*    FIND_PRIOR\n*\n*      The find prior function will locate the item before the\n*      item that is current of a given descriptor.  The item will\n*      become current of item manager, current of item type and\n*      current of descriptor.\n*\n*      CALLX SRVIM,(>ItemID,&IM_Find_Prior,\n*        >DescriptorToken,\n*        <ActualItemSize|,\n*        <ItemToken|)\n*\n*    FIND_OWNER\n*\n*      The find owner function will locate the owner of the\n*      item that is current of a given descriptor.  The item will\n*      become current of item manager and current of item type.\n*      The item must have owner links assigned in the descriptor\n*      specified to use this function.\n*\n*      CALLX SRVIM,(>ItemID,&IM_Find_Owner,\n*        >DescriptorToken,\n*        <ActualItemSize|,\n*        <ItemToken|)\n*\n*    FIND_FIRST\n*\n*      The find first function will locate the first item\n*      connected to a given descriptor.  The item will become\n*      current of item manager, current of item type and current of\n*      descriptor.\n*\n*      CALLX SRVIM,(>ItemID,&IM_Find_First,\n*        >DescriptorToken,\n*        <ActualItemSize|,\n*        <ItemToken|)\n*\n*    FIND_FINAL\n*\n*      The find final function will locate the final item\n*      connected to a given descriptor.  The item will become\n*      current of item manager, current of item type and current of\n*      descriptor.\n*\n*      CALLX SRVIM,(>ItemID,&IM_Find_Final,\n*        >DescriptorToken,\n*        <ActualItemSize|,\n*        <ItemToken|)\n*\n*    GET\n*\n*      The get function will get the record that is current of\n*      item manager.  Currency is not changed.\n*\n*      CALLX SRVIM,(>ItemID,&IM_Get,\n*        >ReturnSize,\n*        <Item,\n*        <ActualItemSize|,\n*        <ItemToken|)\n*\n*    MODIFY\n*\n*      The modify function will modify a record.  If the item token\n*      is not specified, the current item of item manager is changed.\n*      The item becomes current of item manager and current of item\n*      type.\n*\n*      CALLX SRVIM,(>ItemID,&IM_Modify,\n*        >ItemAddress,\n*        >Options|x'00',\n*        >ItemToken|)\n*\n*    OBTAIN\n*\n*      The obtain function will obtain a given item by its item token.\n*      The item will become current for item manager and current for\n*      item type.\n*\n*      CALLX SRVIM,(>ItemID,&IM_Obtain,\n*        >ItemToken,\n*        >ReturnSize,\n*        <Item,\n*        <ActualItemSize|)\n*\n*    OBTAIN_BY_KEY                                (not yet supported)\n*\n*      The obtain by key function will obtain a given item by key, from\n*      whatever is associated with a given descriptor.  The item will\n*      become current for item manager, current for descriptor, and\n*      current for item type.\n*\n*      CALLX SRVIM,(>ItemID,&IM_Obtain_by_Key,\n*        >DescriptorToken,\n*        >KeySize,\n*        >Key,\n*        >ReturnSize,\n*        <Item,\n*        <ActualItemSize|,\n*        <ItemToken|)\n*\n*    OBTAIN_CURRENT_OF_ITEM_TYPE\n*\n*      The obtain current of item type function will obtain the item\n*      that is current of a given item type.  The item becomes\n*      current of item manager and remains current of item type.\n*\n*      CALLX SRVIM,(>ItemID,&IM_Obtain_Current_of_Item_Type,\n*        >ItemType,\n*        >ReturnSize,\n*        <Item,\n*        <ActualItemSize|,\n*        <ItemToken|)\n*\n*    OBTAIN_CURRENT_OF_DESCRIPTOR\n*\n*      The obtain current of descriptor function will obtain the\n*      item that is current of descriptor for the descriptor\n*      specified.  The item obtained becomes current of item manager\n*      and current of item type and remains current of descriptor.\n*\n*      CALLX SRVIM,(>ItemID,&IM_Obtain_Current_for_Descriptor,\n*        >DescriptorToken,\n*        >ReturnSize,\n*        <Item,\n*        <ActualItemSize|,\n*        <ItemToken|)\n*\n*    OBTAIN_NEXT\n*\n*      The obtain next function will obtain the next item after the\n*      item that is current of a given descriptor.  The item will\n*      become current of item manager, current of item type and\n*      current of descriptor.\n*\n*      CALLX SRVIM,(>ItemID,&IM_Obtain_Next,\n*        >DescriptorToken,\n*        >ReturnSize,\n*        <Item,\n*        <ActualItemSize|,\n*        <ItemToken|)\n*\n*    OBTAIN_PRIOR\n*\n*      The obtain prior function will obtain the item before the\n*      item that is current of a given descriptor.  The item will\n*      become current of item manager, current of item type and\n*      current of descriptor.\n*\n*      CALLX SRVIM,(>ItemID,&IM_Obtain_Prior,\n*        >DescriptorToken,\n*        >ReturnSize,\n*        <Item,\n*        <ActualItemSize|,\n*        <ItemToken|)\n*\n*    OBTAIN_OWNER\n*\n*      The obtain owner function will obtain the owner of the\n*      item that is current of a given descriptor.  The item will\n*      become current of item manager and current of item type.\n*      The item must have owner links assigned in the descriptor\n*      specified to use this function.\n*\n*      CALLX SRVIM,(>ItemID,&IM_Obtain_Owner,\n*        >DescriptorToken,\n*        >ReturnSize,\n*        <Item,\n*        <ActualItemSize|,\n*        <ItemToken|)\n*\n*    OBTAIN_FIRST\n*\n*      The obtain first function will obtain the first item\n*      connected to a given descriptor.  The item will become\n*      current of item manager, current of item type and current of\n*      descriptor.\n*\n*      CALLX SRVIM,(>ItemID,&IM_Obtain_First,\n*        >DescriptorToken,\n*        >ReturnSize,\n*        <Item,\n*        <ActualItemSize|,\n*        <ItemToken|)\n*\n*    OBTAIN_FINAL\n*\n*      The obtain final function will obtain the final item\n*      connected to a given descriptor.  The item will become\n*      current of item manager, current of item type and current of\n*      descriptor.\n*\n*      CALLX SRVIM,(>ItemID,&IM_Obtain_Final,\n*        >DescriptorToken,\n*        >ReturnSize,\n*        <Item,\n*        <ActualItemSize|,\n*        <ItemToken|)\n*\n*    SORT\n*\n*      The sort function will sort the items in a structure described\n*      by a descriptor.\n*\n*      CALLX SRVIM,(>ItemID,&IM_Sort,\n*        >DescriptorToken,\n*        >Fieldslist,\n*        >HeadToken|)\n*\n*    STORE\n*\n*      The store function will store a new item.  The item becomes\n*      current of item manager and current of item type.\n*\n*      CALLX SRVIM,(>ItemID,&IM_Store,\n*        >ItemAddress,\n*        >Options|x'00',\n*        >ItemToken|)\n*\n*\n*  Special note:  Other information such as return codes can be\n*                 found the the \"Clemson University Service Processor\n*                 User Guide and Reference\" contained in the source\n*                 library.\n*\n*  Program     reentrant, problem key and state, server linkage,\n*  Attributes  non-authorized, amode(any), rmode(any)\n*\n*  Change\n*  History     03/11/89 MGG - New\n*              12/18/98 CAM - Changed to always use subpool 0\n*            2001-01-16 MJM - Added type BIT to IM_SORT function.\n*            2001-07-26 MJM - Updated get_itc instruction that      @C1\n*                             clears itc_f to use mvi instead of    @C1\n*                             mvc. Updated find_by_key to get a new @C1\n*                             ITC if the item is variable sized as  @C1\n*                             well as if the item's links have a    @C1\n*                             variable offset.                      @C1\n*\n*---------------------------------------------------------------------*\n eject                                |\n gbla  &number_of_itds                | Number of ITDs.\n gbla  &number_of_itdxs               | Number of extended ITDs.\n copy  smsyms                         | Copy structured macro symbols.\n copy  srvesmac                       | Environment support macros.\n copy  srvmmmac                       | Memory manager macros.\n copy  srvimmac                       | Item manager macros.\n copy  srvimimc                       | Item manager internal macros.\n copy  srvdvmac                       | Data in virtual macros.\n         macro                        |\n         imlks &reg,&itc,&cb,&immwreg=r8\n         gbla  &im_internal_error\n         if (tbit,&cb.f1ksi)          |\n          l     &immwreg,&cb.kszof    |\n          al    &immwreg,&itc+itc_address-itc_\n          l8    &reg,0(&immwreg)      |\n         else                         |\n          l     &reg,&cb.ksz          |\n         endif                        |\n         mend\n         macro                        |\n         imlla &addr,&lnk#,&itc       |\n         gbla  &im_invalid_link_number\n         l     r1,&lnk#               | Load link number\n         if (treg,r1,nz)              | If non-zero\n          errexit (c,r1,gt,&itc.+itc_number_links-itc_),               +\n               code=&im_invalid_link_number\n          bctr  r1,0                  |  Calculate address\n          sll   r1,2                  |  of link in IMMS.\n          al    r1,&itc.+itc_offset_links-itc_  Calc address\n          al    r1,&itc.+itc_address-itc_       of link.\n         endif                        | Endif.\n         ##st  r1,&addr               | Save result.\n         mend                         |\n*\n*\n         macro\n         litda &addr,&token\n         ##l   r1,&token              |\n         al    r1,pwa_imc_address     |\n         ##st  r1,&addr               |\n         mend\n*\n*\n         macro                        |\n         imlta &addr,&token           |\n         gblc  &pwa                   |\n         ##l   r0,&token,wreg=r1      |\n         la    r1,&pwa                |\n         callx pwa_im_quick_get_address\n         ##st  r1,&addr               |\n         mend                         |\n         space 2                      |\n         macro                        |\n         itc   &id=itc_,&dsect=no     |\n&i       setc  '&id'                  |\n         aif   ('&dsect' ne 'yes').no_dsect\n&i       dsect                        |\n         ago   .past_header           |\n.no_dsect anop                        |\n&i       ds     0f                    |\n.past_header anop                     |\n&i.token                       ds f   | Item token.\n&i.address                     ds a   | Item address.\n&i.itd_address                 ds a   | ITD address.\n&i.size                        ds a   | Item size.\n&i.number_links                ds a   | Number of links.\n&i.offset_links                ds a   | Offset of links.\n&i.itype                       ds h   | Item type.\n&i.f                           ds bl1 | Flags.\n&i.f_variable_size         equ  b'10000000'\n&i.f_variable_number_links equ  b'01000000'\n&i.f_variable_links_offset equ  b'00100000'\n                               ds bl1 |\n&i.storage equ &i,*-&i                | Equate for storage.\n         mend                         |\n         macro                        |\n         kpm   &id=kpm_,&dsect=no     |\n&i       setc  '&id'                  |\n         aif   ('&dsect' ne 'yes').no_dsect\n&i       dsect                        |\n         ago   .past_header           |\n.no_dsect anop                        |\n&i       ds     0f                    |\n.past_header anop                     |\n&i.first_token                  ds f  |\n&i.search_key_address           ds a  |\n&i.search_key_length            ds x  |\n                                ds xl2\n&i.key_length                   ds x  |\n&i.key_length_offset            ds f  |\n&i.key_offset                   ds f  |\n&i.link_number                  ds f  |\n&i.cbsze equ *-&i.\n         mend                         |\n*\n*  Define L32 user cond name.\n*\n         defucond name=l32,macro=l32_ucond\n         macro\n&name    l32_ucond &expr,&s=,&f=,&l=\n         aif (n'&expr ne 4).err0001   |\n&name    l32   &expr(2),&expr(3)      | Load address of token value.\n         ##cond &expr(4),                                              +\n               s=&s,f=&f,l=&l         |\n         mexit                        |\n.err0001 mnote 8,\"Incorrect number of parameters in %L32 expr\"\n         mend                         |\n eject                                |\n block name=&srv_modname,type=program,amode=31,rmode=any,              +\n               options=(*srvprc,novl,long,dyn,main,                    +\n               (parms,copy,(copyerror,,&im_invalid_number_of_parms),   +\n               (count,pwa_number_of_parms),(using,r9),vl)),            +\n               parmmap=(prm,prm_max_#*4),                              +\n               subopts=(*swa,loadbase,(parms,(using,r9),prefix))\n* *-------------------------------------------------------------------*\n* *  Establish ids for service processors used.\n* *-------------------------------------------------------------------*\n  es_id id=es,spepa=pwa_es_epa,       | Environment support.           +\n               sptoken=pwa_es_token,  |                                +\n               esva=pwaaesv           |\n  mm_id id=mm,spepa=pwa_mm_epa,       | Memory manager.                +\n               spepname=&memory_manager\n* *-------------------------------------------------------------------*\n* * Get function code and call subroutine to process the function.\n* *-------------------------------------------------------------------*\n  l     r2,prm_functioncode           | Load the function code into\n  l     r2,0(,r2)                     |   a register for testing.\n  la    r1,prm_function_dependent     | Point r1 to function dependent\n*                                     | parameters.\n  caseblk reg=r2,wreg=r15             | Start of function case block.\n   case &start                        |\n    errexit (clc,pwa_number_of_parms,gt,=a(prm_start_max_#)),          +\n               code=&im_invalid_number_of_parms\n    callsub start_function            |\n   case &terminate                    |\n    errexit (clc,pwa_number_of_parms,gt,=a(prm_terminate_max_#)),      +\n               code=&im_invalid_number_of_parms\n    callsub terminate_function        |\n   case &im_initialize                |\n    errexit (clc,pwa_number_of_parms,gt,=a(prm_initialize_max_#)),     +\n               code=&im_invalid_number_of_parms\n    callsub initialize_function       |\n   case &im_save                      |\n    errexit (clc,pwa_number_of_parms,gt,=a(prm_save_max_#)),           +\n               code=&im_invalid_number_of_parms\n    callsub save_function             |\n   case &im_reset                     |\n    errexit (clc,pwa_number_of_parms,gt,=a(prm_reset_max_#)),          +\n               code=&im_invalid_number_of_parms\n    callsub reset_function            |\n   case &im_add_to_directory          |\n    errexit (clc,pwa_number_of_parms,gt,=a(prm_add_to_dir_max_#)),     +\n               code=&im_invalid_number_of_parms\n    callsub add_to_directory_function |\n   case &im_find_in_directory         |\n    errexit (clc,pwa_number_of_parms,gt,=a(prm_find_in_dir_max_#)),    +\n               code=&im_invalid_number_of_parms\n    callsub find_in_directory_function\n   case &im_remove_from_directory     |\n    errexit (clc,pwa_number_of_parms,gt,=a(prm_remove_from_dir_max_#)),+\n               code=&im_invalid_number_of_parms\n    callsub remove_from_directory_function\n   case &im_create_item_type_descriptor\n    errexit (clc,pwa_number_of_parms,gt,=a(prm_create_itd_max_#)),     +\n               code=&im_invalid_number_of_parms\n    callsub create_item_type_descriptor_function\n   case &im_create_group_descriptor   |\n    errexit (clc,pwa_number_of_parms,gt,=a(prm_create_gd_max_#)),      +\n               code=&im_invalid_number_of_parms\n    callsub create_group_descriptor_function\n   case &im_create_linked_list_descriptor\n    errexit (clc,pwa_number_of_parms,gt,=a(prm_create_ld_max_#)),      +\n               code=&im_invalid_number_of_parms\n    callsub create_linked_list_descriptor_function\n   case &im_create_hash_table_descriptor\n    errexit (clc,pwa_number_of_parms,gt,=a(prm_create_ht_max_#)),      +\n               code=&im_invalid_number_of_parms\n    callsub create_hash_table_descriptor_function\n   case &im_connect                   |\n    errexit (clc,pwa_number_of_parms,gt,=a(prm_connect_max_#)),        +\n               code=&im_invalid_number_of_parms\n    callsub connect_function          |\n   case &im_disconnect                |\n    errexit (clc,pwa_number_of_parms,gt,=a(prm_disconnect_max_#)),     +\n               code=&im_invalid_number_of_parms\n    callsub disconnect_function       |\n   case &im_get                       |\n    errexit (clc,pwa_number_of_parms,gt,=a(prm_get_max_#)),            +\n               code=&im_invalid_number_of_parms\n    callsub get_function              |\n   case &im_get_dangerous_addresses   |\n    errexit (clc,pwa_number_of_parms,gt,=a(prm_gda_max_#)),            +\n               code=&im_invalid_number_of_parms\n    callsub get_dangerous_addresses_function\n   case &im_find                      |\n    errexit (clc,pwa_number_of_parms,gt,=a(prm_fd_max_#)),             +\n               code=&im_invalid_number_of_parms\n    callsub find_function             |\n   case &im_find_by_key               |\n    errexit (clc,pwa_number_of_parms,gt,=a(prm_fdky_max_#)),           +\n               code=&im_invalid_number_of_parms\n    callsub find_by_key_function      |\n   case &im_find_current_of_item_type |\n    errexit (clc,pwa_number_of_parms,gt,=a(prm_fd2_max_#)),            +\n               code=&im_invalid_number_of_parms\n    callsub find_current_of_item_type_function\n   case &im_find_current_of_descriptor\n    errexit (clc,pwa_number_of_parms,gt,=a(prm_fd2_max_#)),            +\n               code=&im_invalid_number_of_parms\n    callsub find_current_of_descriptor_function\n   case &im_find_next                 |\n    errexit (clc,pwa_number_of_parms,gt,=a(prm_fd2b_max_#)),           +\n               code=&im_invalid_number_of_parms\n    callsub find_next_function        |\n   case &im_find_prior                |\n    errexit (clc,pwa_number_of_parms,gt,=a(prm_fd2b_max_#)),           +\n               code=&im_invalid_number_of_parms\n    callsub find_prior_function       |\n   case &im_find_owner                |\n    errexit (clc,pwa_number_of_parms,gt,=a(prm_fd2c_max_#)),           +\n               code=&im_invalid_number_of_parms\n    callsub find_owner_function       |\n   case &im_find_first                |\n    errexit (clc,pwa_number_of_parms,gt,=a(prm_fd2a_max_#)),           +\n               code=&im_invalid_number_of_parms\n    callsub find_first_function       |\n   case &im_find_final                |\n    errexit (clc,pwa_number_of_parms,gt,=a(prm_fd2a_max_#)),           +\n               code=&im_invalid_number_of_parms\n    callsub find_final_function       |\n   case &im_obtain                    |\n    errexit (clc,pwa_number_of_parms,gt,=a(prm_ob_max_#)),             +\n               code=&im_invalid_number_of_parms\n    callsub obtain_function           |\n   case &im_obtain_by_key             |\n    errexit (clc,pwa_number_of_parms,gt,=a(prm_obky_max_#)),           +\n               code=&im_invalid_number_of_parms\n    callsub obtain_by_key_function    |\n   case &im_obtain_current_of_item_type\n    errexit (clc,pwa_number_of_parms,gt,=a(prm_ob2_max_#)),            +\n               code=&im_invalid_number_of_parms\n    callsub obtain_current_of_item_type_function\n   case &im_obtain_current_of_descriptor\n    errexit (clc,pwa_number_of_parms,gt,=a(prm_ob2_max_#)),            +\n               code=&im_invalid_number_of_parms\n    callsub obtain_current_of_descriptor_function\n   case &im_obtain_next               |\n    errexit (clc,pwa_number_of_parms,gt,=a(prm_ob2b_max_#)),           +\n               code=&im_invalid_number_of_parms\n    callsub obtain_next_function      |\n   case &im_obtain_prior              |\n    errexit (clc,pwa_number_of_parms,gt,=a(prm_ob2b_max_#)),           +\n               code=&im_invalid_number_of_parms\n    callsub obtain_prior_function     |\n   case &im_obtain_owner              |\n    errexit (clc,pwa_number_of_parms,gt,=a(prm_ob2c_max_#)),           +\n               code=&im_invalid_number_of_parms\n    callsub obtain_owner_function     |\n   case &im_obtain_first              |\n    errexit (clc,pwa_number_of_parms,gt,=a(prm_ob2a_max_#)),           +\n               code=&im_invalid_number_of_parms\n    callsub obtain_first_function     |\n   case &im_obtain_final              |\n    errexit (clc,pwa_number_of_parms,gt,=a(prm_ob2a_max_#)),           +\n               code=&im_invalid_number_of_parms\n    callsub obtain_final_function     |\n   case &im_sort                      |\n    errexit (clc,pwa_number_of_parms,gt,=a(prm_sort_max_#)),           +\n               code=&im_invalid_number_of_parms\n    callsub sort_function             |\n   case &im_store                     |\n    errexit (clc,pwa_number_of_parms,gt,=a(prm_store_max_#)),          +\n               code=&im_invalid_number_of_parms\n    callsub store_function            |\n   case &im_modify                    |\n    errexit (clc,pwa_number_of_parms,gt,=a(prm_modify_max_#)),         +\n               code=&im_invalid_number_of_parms\n    callsub modify_function           |\n   case &im_erase                     |\n    errexit (clc,pwa_number_of_parms,gt,=a(prm_erase_max_#)),          +\n               code=&im_invalid_number_of_parms\n    callsub erase_function            |\n   case other                         |  For all other codes\n    errexit code=&im_invalid_function |  it is an invalid function.\n  endcase                             | Endcase.\n space 1                              |\n endblk block=&srv_modname,rc=0       |\n drop   r9                            | Drop base for parms.\n eject                                |\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Start_Function\n*  Abstract:   This subroutine processes the start function.\n*\n*---------------------------------------------------------------------*\n block type=subroutine,name=start_function,                            +\n               parmmap=prm_function_dependent\n* *-------------------------------------------------------------------*\n* * Move environment support EPA and token to PWA.\n* *-------------------------------------------------------------------*\n  l     r2,pwaaesv                    |\n  using esv,r2                        |\n  mvc   pwa_es_epa,esvesepa           | Move EPA.\n  mvc   pwa_es_token,esvestkn         | Move token.\n  drop  r2                            | Drop base.\n* *-------------------------------------------------------------------*\n* * If a DIV EPA is supplied, start the DIV Service Processor.\n* *-------------------------------------------------------------------*\n  mvi   &w.mode,c\"U\"                  | Assume update mode.\n  l32   r1,prm_start_options          | If read only specified:\n  if nz,and,(tbit,0(r1),prm_start_options_read_only)\n   mvi   &w.mode,c\"R\"                 |  Make mode read.\n  endif                               |\n  l32   r1,prm_start_div_epa          | If DIV routine provided:\n  if nz                               |\n   icm   r1,b'1111',0(r1)             |\n   if nz                              |\n    st    r1,pwa_dv                   |  Start DIV.\n    callx pwa_dv,(pwa_dv_token,       |                                +\n               &start,                |                                +\n               pwaaesv,               |                                +\n               *prm_start_div_ddname, |                                +\n               &w.mode,               |                                +\n               pwa_initial_size),vl   |\n    errexit (treg,r15,nz),code=&im_div_start_failed\n    l     r1,pwa_initial_size         |   Adjust size\n    sll   r1,12                       |   from blocks\n    st    r1,pwa_initial_size         |   to bytes.\n   endif                              |  Endif.\n  endif                               | Endif.\n* *-------------------------------------------------------------------*\n* * Start the memory manager.\n* *-------------------------------------------------------------------*\n  es_load_module id=es,spid=mm        | Load memory manager.\n  errexit (treg,r15,nz),code=&im_memory_manager_load_failed\n  mm_start id=mm,increment==a(4096)   | Start memory manager.\n  errexit (treg,r15,nz),code=&im_memory_manager_start_failed\n* *-------------------------------------------------------------------*\n* * Store address of quick get address routine away.\n* *-------------------------------------------------------------------*\n  sm_lal r0,quick_get_address         | Load address of routine.\n  l32   r1,prm_start_options          | If read only specified:\n  if nz,and,(tbit,0(r1),prm_start_options_actual_address)\n   sbit  pwa_f_actual_address         |  Indicate use actual address.\n   sm_lal r0,quick_get_address_actual |  Use actual address routine.\n  endif                               | Endif.\n  st    r0,pwa_im_quick_get_address   | Save the address in PWA.\n* *-------------------------------------------------------------------*\n* * If the initial size is non-zero, get increment; otherwise,\n* * set return code that indicates that a initialize function\n* * call is required.\n* *-------------------------------------------------------------------*\n  l32   r0,pwa_initial_size           |\n  errexit z,code=&im_item_storage_not_initialized\n  callsub get_data_space_increment,   | Get a data space increment.    +\n               (pwa_initial_size,,    |                                +\n               pwa_imc_address)       |\n  l     r4,pwa_imc_address            | Load address of IMC.\n  using imc,r4                        | Establish base for IMC.\n  mvc   imc4more,imc4more+imclssz     |\n  es_get_time id=es,                  | Get date and time.             +\n               time=pwa_time,date=pwa_date\n  mvc   imclsdat,pwa_date             | Set creation date\n  mvc   imclstim,pwa_time             | and time.\n  drop  r4                            | Drop base for IMC.\n* *-------------------------------------------------------------------*\n endblk block=start_function          |\n         space 2\n         swa\n&w.mode  ds    cl1\n         endswa\n   eject                              |\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Terminate_Function\n*  Abstract:   This subroutine processes the start function.\n*\n*---------------------------------------------------------------------*\n block type=subroutine,name=terminate_function,                        +\n               parmmap=prm_function_dependent\n* *-------------------------------------------------------------------*\n* * Terminate DIV SP.\n* *-------------------------------------------------------------------*\n  l32   r15,pwa_dv                    | Point r15 to DIV service proc.\n  if nz                               | If one exist:\n   callx (r15),(pwa_dv_token,&terminate),vl Call it with terminate.\n  endif                               | Endif.\n* *-------------------------------------------------------------------*\n* * Free item memory.\n* *-------------------------------------------------------------------*\n* callsub release_data_space\n* *-------------------------------------------------------------------*\n* * Terminate Memory Manager.\n* *-------------------------------------------------------------------*\n  l32   r15,pwa_mm_epa                | Load memory manager EPA.\n  if nz                               | If it is loaded:\n   mm_terminate id=mm                 |   Terminate it.\n  endif                               | Endif.\n* *-------------------------------------------------------------------*\n* * Indicate PWA should be freed.\n* *-------------------------------------------------------------------*\n  smctrl freepwa=yes                  | Free the PWA on return.\n* *-------------------------------------------------------------------*\n endblk block=terminate_function      |\n   eject                              |\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Initialize_Function\n*  Abstract:   This subroutine processes the initialize function.\n*\n*---------------------------------------------------------------------*\n block type=subroutine,name=initialize_function,                       +\n               parmmap=prm_function_dependent\n* *-------------------------------------------------------------------*\n* * It is a error if final setup has already taken place.\n* *-------------------------------------------------------------------*\n  errexit (tbit,pwa_f_final_setup),   |                                +\n               code=&im_setup_already_complete\n* *-------------------------------------------------------------------*\n* * Get ITD storage size.\n* *-------------------------------------------------------------------*\n  l     r0,=a(64*1024)                | Put default in r0.\n  l32   r1,prm_initialize_itd_stg_size  Point r1 to parameter.\n  if nz                               | If it was specified:\n   l32   r1,0(r1)                     |  Load r1 with parameter.\n   if nz                              |  If it is non-zero:\n    lr    r0,r1                       |   Use value supplied.\n   endif                              |  Endif.\n  endif                               | Endif.\n  ah    r0,=f'4095'                   | Round size\n  srl   r0,12                         | to multiple\n  sll   r0,12                         | of 4K.\n  st    r0,pwa_lt_64k_size            | Save size.\n* *-------------------------------------------------------------------*\n* * Get unallocated storage increment size.\n* *-------------------------------------------------------------------*\n  l     r0,=a(64*1024)                | Put default in r0.\n  l32   r1,prm_initialize_ua_stg_incr   Point r1 to parameter.\n  if nz                               | If it was specified:\n   l32   r1,0(r1)                     |  Load r1 with parameter.\n   if nz                              |  If it is non-zero:\n    lr    r0,r1                       |   Use value supplied.\n   endif                              |  Endif.\n  endif                               | Endif.\n  ah    r0,=f'4095'                   | Round size\n  srl   r0,12                         | to multiple\n  sll   r0,12                         | of 4K.\n  st    r0,pwa_increment              | Save size.\n* *-------------------------------------------------------------------*\n* * Get system storage increment size.\n* *-------------------------------------------------------------------*\n  l     r0,=a(4*1024)                 | Put default in r0.\n  l32   r1,prm_initialize_sys_stg_incr  Point r1 to parameter.\n  if nz                               | If it was specified:\n   l32   r1,0(r1)                     |  Load r1 with parameter.\n   if nz                              |  If it is non-zero:\n    lr    r0,r1                       |   Use value supplied.\n   endif                              |  Endif.\n  endif                               | Endif.\n  ah    r0,=f'4095'                   | Round size\n  srl   r0,12                         | to multiple\n  sll   r0,12                         | of 4K.\n  st    r0,pwa_system_storage_increment Save size.\n* *-------------------------------------------------------------------*\n* * Get default user storage increment size.\n* *-------------------------------------------------------------------*\n  l     r0,=a(64*1024)                | Put default in r0.\n  l32   r1,prm_initialize_sys_stg_incr  Point r1 to parameter.\n  if nz                               | If it was specified:\n   l32   r1,0(r1)                     |  Load r1 with parameter.\n   if nz                              |  If it is non-zero:\n    lr    r0,r1                       |   Use value supplied.\n   endif                              |  Endif.\n  endif                               | Endif.\n  ah    r0,=f'4095'                   | Round size\n  srl   r0,12                         | to multiple\n  sll   r0,12                         | of 4K.\n  st    r0,pwa_default_user_storage_increment Save size.\n* *-------------------------------------------------------------------*\n* * Get data space large enough for first increment or <64k storage\n* * plus a system storage increment, whichever is larger.\n* *-------------------------------------------------------------------*\n  l     r1,pwa_lt_64k_size            | Calculate size\n  a     r1,pwa_system_storage_increment of initial data space.\n  if (c,r1,lt,pwa_increment)          | If this is smaller than\n   l     r1,pwa_increment             | the increment, use the\n  endif                               | increment.\n  st    r1,pwa_initial_size           | Set this to initial size.\n  callsub get_data_space_increment,   | Get a data space increment.    +\n               (pwa_initial_size,,    |                                +\n               pwa_imc_address)       |\n* *-------------------------------------------------------------------*\n* * The IMC starts at start of space.\n* *-------------------------------------------------------------------*\n  l     r4,pwa_imc_address            | Load address of IMC.\n  using imc,r4                        | Establish base for IMC.\n  l     r2,pwaaesv                    | Point r2 to ESV.\n  using esv,r2                        | Establish base for ESV.\n  es_get_time id=es,                  | Get date and time.             +\n               time=pwa_time,date=pwa_date\n  mvc   imccrdat,pwa_date             | Set creation date\n  mvc   imccrtim,pwa_time             | and time.\n  mvc   imclsdat,pwa_date             | Set last used date\n  mvc   imclstim,pwa_time             | and time.\n  mvc   imcpgmnm,=cl8'&srv_modname'   | Set program name.\n  la    r5,imcitmsz(,r4)              | Point r5 to next storage.\n* *-------------------------------------------------------------------*\n* * Assign the system storage that will be used.  This includes\n* * a GRD for the 4 standard groups and a single GSS, if needed.\n* * The GRDs and GSSs will be completed later.\n* *-------------------------------------------------------------------*\n  l     r1,pwa_lt_64k_size            | Past <64K storage is sys stg.\n  if (tbit,pwa_f_actual_address)      | If actual addresses\n   alr   r1,r4\n*  * For \"unassigned\" GRD\n   st    r1,imcgrdua                     Save \"unassigned\" GRD token.\n   st    r1,imcfrgrd                     Also first GRD in chain.\n   la    r2,grditmsz(r1)                 Increment.\n   st    r2,grdfrgss-grd(r1)             Save token of GSS in GRD.\n   la    r1,gssitmsz(r2)                 Increment.\n*  * For \"<64K storage\" GRD\n   st    r1,imcgrdls                     Save <64K GRD token.\n   la    r2,grditmsz(r1)                 Increment.\n   st    r2,grdfrgss-grd(r1)             Save token of GSS in GRD.\n   la    r1,gssitmsz(r2)                 Increment.\n*  * For \"Default user storage\" GRD\n   st    r1,imcgrddf                     Save default group token.\n   la    r1,grditmsz(r1)                 Increment.\n*  * For \"System storage\" GRD\n   st    r1,imcgrdsy                     Save token in IMC.\n   la    r2,grditmsz(r1)                 Increment.\n   st    r2,grdfrgss-grd(r1)             Save token of GSS in GRD.\n   la    r0,gssitmsz(r2)                 Increment.\n   sl    r0,imcgrdua                     Calculate sys storage used.\n   st    r0,gssused-gss(r2)              Save in GSS.\n   la    r1,gssitmsz(r2)                 Increment.\n   st    r1,gssfrfsi-gss(r2)             Store token of FSI.\n  else\n*  * For \"unassigned\" GRD\n   st    r1,imcgrdua                     Save \"unassigned\" GRD token.\n   st    r1,imcfrgrd                     Also first GRD in chain.\n   la    r2,grditmsz(r1)                 Increment.\n   st    r2,grdfrgss-grd(r1,r4)          Save token of GSS in GRD.\n   la    r1,gssitmsz(r2)                 Increment.\n*  * For \"<64K storage\" GRD\n   st    r1,imcgrdls                     Save <64K GRD token.\n   la    r2,grditmsz(r1)                 Increment.\n   st    r2,grdfrgss-grd(r1,r4)          Save token of GSS in GRD.\n   la    r1,gssitmsz(r2)                 Increment.\n*  * For \"Default user storage\" GRD\n   st    r1,imcgrddf                     Save default group token.\n   la    r1,grditmsz(r1)                 Increment.\n*  * For \"System storage\" GRD\n   st    r1,imcgrdsy                     Save token in IMC.\n   la    r2,grditmsz(r1)                 Increment.\n   st    r2,grdfrgss-grd(r1,r4)          Save token of GSS in GRD.\n   la    r0,gssitmsz(r2)                 Increment.\n   s     r0,pwa_lt_64k_size              Calculate sys storage used.\n   st    r0,gssused-gss(r2,r4)           Save in GSS.\n   la    r1,gssitmsz(r2)                 Increment.\n   st    r1,gssfrfsi-gss(r2,r4)          Store token of FSI.\n  endif\n* *-------------------------------------------------------------------*\n* * Define a macro to create the first simple ITDs.\n* *-------------------------------------------------------------------*\n  macro                               |\n  build_simple_ITD &cb=,&class=,&token=,&grd=imcgrdls,&flag=,&num=\n  gbla  &number_of_itds               | Number of ITDs.\n&number_of_itds seta &number_of_itds+1  Add 1 to number.\n  using itd,r5                        | Establish base for ITD.\n  aif ('&token' eq '').no_token       |\n  lr    r0,r5                         | Calculate token for\n  slr   r0,r4                         | item type descriptor.\n  st    r0,&token                     | Save token.\n.no_token anop                        |\n  l     r0,imctditd                   | Load token for ITD ITD.\n  sth   r0,itditype                   | Store token in ITD.\n  mvc   itdclass,=y(&class)           | Set item class.\n  aif   ('&flag' eq '').no_flag       |\n  mvi   itdf1,&flag                   | Move flag to ITD.\n.no_flag  anop                        |\n  mvc   itdiln,=al1(&cb.itmsz)        | Set item size.\n  mvc   itdinl,=al1(&cb.#lnks)        | Set item number of links.\n  mvc   itdilo,=al1(&cb.links-&cb.)   | Set item links offset.\n  aif   ('&num' eq '').no_num         |\n  mvc   itdnumit,&num                 | Move number of items to ITD.\n.no_num   anop                        |\n  aif   ('&grd' eq '').no_grd         |\n  mvc   itdgrd,&grd                   | Set GRD.\n.no_grd   anop                        |\n  drop  r5                            | Drop base for itd.\n  la    r5,itditmsz(,r5)              | Point to next storage.\n  mend                                |\n* *-------------------------------------------------------------------*\n* * Create first item type descriptors.\n* *-------------------------------------------------------------------*\n  build_simple_itd cb=itd,            | Build one for ITD itself.      +\n               class=&im_class_item_type_descriptor,                   +\n               token=imctditd,        |                                +\n               flag=itdf1dfl,         |                                +\n               grd=imcgrdls,          |                                +\n               num=psd_number_of_itds |\n  build_simple_itd cb=itdx,           | Build one for extended ITD.    +\n               class=&im_class_item_type_descriptor,                   +\n               token=imctditdx,       |                                +\n               flag=itdf1dfl,         |                                +\n               grd=imcgrdls,          |                                +\n               num=psd_number_of_itdxs\n  build_simple_itd cb=grd,            | Build one for GRD.             +\n               class=&im_class_group_descriptor,                       +\n               token=imctdgrd,        |                                +\n               flag=itdf1dfl,         |                                +\n               grd=imcgrdsy,          |                                +\n               num==a(4)              |\n  build_simple_itd cb=gss,            | Build one for GSS.             +\n               class=&im_class_unclassified,                           +\n               token=imctdgss,        |                                +\n               grd=imcgrdsy,          |                                +\n               num==a(3)              |\n  lr    r0,r5                         | Calculate token for IMC's.\n  slr   r0,r4                         | item type descriptor.\n  sth   r0,imcitype                   | Store token in IMC item type.\n  build_simple_itd cb=imc,            | Build the ITD for the IMC.     +\n               class=&im_class_unclassified,                           +\n               grd=imcgrdls,          |                                +\n               num==a(1)              |\n* *-------------------------------------------------------------------*\n* * Define a macro to create skeleton GRDs.\n* *-------------------------------------------------------------------*\n  macro                               |\n  build_skeleton_grd &token=,&increment=,&method=2,&next=\n  gbla  &im_class_freespace           | Free space class.\n  gbla  &number_of_itdxs              | Number of extended ITDs.\n  l     r6,&token                     | Calculate\n  if not,(tbit,pwa_f_actual_address)  | address\n   alr   r6,r4                        | of\n  endif                               | GRD.\n  using grd,r6                        | Establish base for ITD.\n&number_of_itdxs seta &number_of_itdxs+1 Add 1 to number.\n  using itd,r5                        | Establish base for ITD.\n  lr    r0,r5                         | Calculate token for\n  slr   r0,r4                         | item type descriptor.\n  st    r0,grdtdfsi                   | Save token.\n  l     r0,imctditdx                  | Load token for ITDX ITD.\n  sth   r0,itditype                   | Store token in ITD.\n  mvc   itdclass,=y(&im_class_freespace) Set item class.\n  mvi   itdf1,itdf1ext+itdf1lni       | Move flag to ITD.\n  mvi   itdxilnsz,4                   | Set item length size.\n  mvc   itdxilnof,=a(fsisize-fsi)     | Set item length size offset.\n  mvc   itdxinl,=a(fsi#lnks)          | Set item number of links.\n  mvc   itdxilo,=a(fsilinks-fsi)      | Set item links offset.\n  mvc   itdgrd,&token                 | Set GRD.\n  drop  r5                            | Drop base for ITD.\n  la    r5,itdxitmsz(,r5)             | Point to next storage.\n  mvc   grditype,imctdgrd+2           | Set GRD item type token.\n  mvc   grdincsz,&increment           | Set increment size.\n  mvc   grdmmthd,=y(&method)          | Method.\n  mvc   grdnxgrd,&next                | Next GRD pointer.\n  drop  r6                            | Drop base for ITD.\n  mend                                |\n* *-------------------------------------------------------------------*\n* * Build base skeleton GRDs.\n* *-------------------------------------------------------------------*\n  build_skeleton_grd token=imcgrdua,increment=pwa_increment,           +\n               next=imcgrdls,method=1 |\n  build_skeleton_grd token=imcgrdls,increment==a(0),                   +\n               next=imcgrdsy          |\n  build_skeleton_grd token=imcgrdsy,  |                                +\n               increment=pwa_system_storage_increment,                 +\n               next=imcgrddf          |\n  build_skeleton_grd token=imcgrddf,  |                                +\n               increment=pwa_default_user_storage_increment,           +\n               next==a(0)             |\n* *-------------------------------------------------------------------*\n* * Build GSS and FSI for <64K system storage.\n* *-------------------------------------------------------------------*\n  using fsi,r5                        | Establish base for FSI.\n  l     r6,imcgrdls                   | Calculate\n  if not,(tbit,pwa_f_actual_address)  | address\n   alr   r6,r4                        | of\n  endif                               | GRS.\n  using grd,r6                        | Establish base for GRD.\n  l     r7,grdfrgss                   | Calculate\n  if not,(tbit,pwa_f_actual_address)  |  address\n   alr   r7,r4                        |  of\n  endif                               |  GSS.\n  using gss,r7                        | Establish base for GSS.\n  mvc   gssitype,imctdgss+2           | Set item type for GSS.\n  lr    r0,r5                         | Calculate size of\n  slr   r0,r4                         | segment used.\n  st    r0,gssused                    | Save size in GSS.\n  st    r0,gssfrfsi                   | Store token of FSI.\n  l     r0,pwa_lt_64k_size            | Load size of segment.\n  st    r0,gsssize                    | Store size in GSS.\n  sl    r0,gssused                    | Calculate freespace remaining\n  st    r0,fsisize                    | Store amount in FSI.\n  st    r0,gsslrgst                   | Set largest free space.\n  mvc   fsiitype,grdtdfsi+2           | Move ITD token to free space.\n  mvc   fsinu1,=h'-1'                 | Set -1 field to -1.\n  drop  r5,r6,r7                      | Drop base for FSI, GRD & GSS.\n* *-------------------------------------------------------------------*\n* * Build GSS and free space entry for system storage.\n* *-------------------------------------------------------------------*\n  l     r6,imcgrdsy                   | Calculate\n  if not,(tbit,pwa_f_actual_address)  |  address\n   alr   r6,r4                        |  of\n  endif                               |  GRS.\n  using grd,r6                        | Establish base for GRD.\n  l     r7,grdfrgss                   | Calculate\n  if not,(tbit,pwa_f_actual_address)  |  address\n   alr   r7,r4                        |  of\n  endif                               |  GSS.\n  using gss,r7                        | Establish base for GSS.\n  mvc   gssitype,imctdgss+2           | Set item type for GSS.\n  l     r0,pwa_lt_64k_size            | GSS starts\n  if (tbit,pwa_f_actual_address)      | right\n   alr   r0,r4                        | after\n  endif                               | <64k\n  st    r0,gssstart                   | storage.\n  l     r5,gssfrfsi                   | Calculate\n  if not,(tbit,pwa_f_actual_address)  | address\n   alr   r5,r4                        | of\n  endif                               | FSI.\n  using fsi,r5                        | Establish base for large FSI.\n  l     r0,pwa_system_storage_increment Load size of segment.\n  st    r0,gsssize                    | Store size in GSS.\n  sl    r0,gssused                    | Calculate freespace remaining.\n  st    r0,gsslrgst                   | Set the largest free space.\n  st    r0,fsisize                    | Store amount in FSI.\n  mvc   fsiitype,grdtdfsi+2           | Move ITD token to free space.\n  mvc   fsinu1,=h'-1'                 | Set -1 field to -1.\n  drop  r5,r6,r7                      | Drop base for FSI, GRD & GSS.\n* *-------------------------------------------------------------------*\n* * Build GSS and FSI for unassigned storage.\n* *-------------------------------------------------------------------*\n  l     r6,imcgrdua                   | Calculate\n  if not,(tbit,pwa_f_actual_address)  | address\n   alr   r6,r4                        | of\n  endif                               | GRS.\n  using grd,r6                        | Establish base for GRD.\n  l     r7,grdfrgss                   | Calculate\n  if not,(tbit,pwa_f_actual_address)  |  address\n   alr   r7,r4                        |  of\n  endif                               |  GSS.\n  using gss,r7                        | Establish base for GSS.\n  mvc   gssitype,imctdgss+2           | Set item type for GSS.\n  l     r0,pwa_initial_size           | Load size of segment.\n  st    r0,gsssize                    | Store size in GSS.\n  l     r1,pwa_lt_64k_size            | Calculate storage\n  al    r1,pwa_system_storage_increment used.\n  st    r1,gssused                    | Save in GSS.\n  sr    r0,r1                         | Calculate unassigned size.\n  errexit m,code=&im_internal_error   | Error if negative.\n  st    r0,gsslrgst                   | This is the largest free space.\n  if nz                               | If unassigned stg remains.\n   if (tbit,pwa_f_actual_address)     |  If ress\n    alr   r1,r4                       |   Calculate address of FSI.\n    st    r1,gssfrfsi                 |   Save its address.\n    lr    r5,r1                       |   Point r5 to FSI.\n   else                               |  Else:\n    st    r1,gssfrfsi                 |   Gssused is also token.\n    lr    r5,r1                       |   Calculate address\n    alr   r5,r4                       |   of FSI.\n   endif                              |  Endif.\n   using fsi,r5                       |  Establish base for FSI.\n   st    r0,fsisize                   |  Store amount in FSI.\n   mvc   fsiitype,grdtdfsi+2          |  Move ITD token to freespace.\n   mvc   fsinu1,=h'-1'                |  Set -1 field to -1.\n  endif                               | Endif.\n  drop  r5,r6,r7                      | Drop base for FSI, GRD & GSS.\n* *-------------------------------------------------------------------*\n* * Make an item type descriptor for descriptions.\n* *-------------------------------------------------------------------*\n  mvc   &w.system_grd_token,imcgrdsy  | Get system GRD token.\n  callsub create_item_type_descriptor_function,                        +\n               (&w.itd,               |                                +\n               ,                      | Can't make a description yet!  +\n               ,                      | No options yet.                +\n               &w.system_grd_token,   | Put in system storage.         +\n               ,,,                    | Length, #links, links offset.  +\n               1,=a(dscsize-dsc),     | Length is in item.             +\n               ,,                     | Number of link are fixed (0).  +\n               ,)                     | Offset of links is fixed (0).\n  l16   r0,&w.itd                     | Load r0 with token of ITD.\n  st    r0,imctddsc                   | Save this in IMC.\n  litda r5,r0                         | Load address of ITD.\n  using itd,r5                        | Establish base for ITD.\n  mvc   itdclass,=y(&im_class_description) Set class.\n  drop  r5                            | Endif.\n* *-------------------------------------------------------------------*\n* * Make an item type descriptor for link list descriptors.\n* *-------------------------------------------------------------------*\n  callsub create_item_type_descriptor_function,                        +\n               (&w.itd,               |                                +\n               &s.desc_lld,           | Description.                   +\n               ,                      | No options.                    +\n               &w.system_grd_token,   | Put in system storage.         +\n               =a(llditmsz),          | Length of items.               +\n               =a(lld#lnks),          | Number of links.               +\n               =a(lldlinks-lld),      | Offset of links.               +\n               ,,                     | Length is in item.             +\n               ,,                     | Number of link are fixed (0).  +\n               ,)                     | Offset of links is fixed (0).\n  l16   r0,&w.itd                     | Load r0 with token of ITD.\n  st    r0,imctdlld                   | Save this in IMC.\n  litda r5,r0                         | Load address of ITD.\n  using itd,r5                        | Establish base for ITD.\n  mvc   itdclass,=y(&im_class_linked_list_descriptor) Set class.\n  sbit  itdf1dfl                      | Description in first link.\n  drop  r5                            | Endif.\n* *-------------------------------------------------------------------*\n* * Make an item type descriptor for hash table descriptors.\n* *-------------------------------------------------------------------*\n  callsub create_item_type_descriptor_function,                        +\n               (&w.itd,               |                                +\n               &s.desc_htd,           | Description.                   +\n               ,                      | No options.                    +\n               &w.system_grd_token,   | Put in system storage.         +\n               ,                      | Length of item in item.        +\n               ,                      | Number of links in item.       +\n               =a(htdlinks-htd),      | Offset of links.               +\n               =a(l'htdsize),=a(htdsize-htd),   Length is in the item. +\n               =a(l'htd#lnks),=a(htd#lnks-htd), Number of links in item+\n               ,)                     | Offset of links is fixed.\n  l16   r0,&w.itd                     | Load r0 with token of ITD.\n  st    r0,imctdhtd                   | Save this in IMC.\n  litda r5,r0                         | Load address of ITD.\n  using itd,r5                        | Establish base for ITD.\n  mvc   itdclass,=y(&im_class_hash_table_descriptor) Set class.\n  sbit  itdf1dfl                      | Description in first link.\n  drop  r5                            | Endif.\n* *-------------------------------------------------------------------*\n* * Make an item type descriptor for directory entries.\n* *-------------------------------------------------------------------*\n  callsub create_item_type_descriptor_function,                        +\n               (&w.itd,               |                                +\n               &s.desc_dir,           | Description.                   +\n               ,                      | No options.                    +\n               &w.system_grd_token,   | Put in system storage.         +\n               =a(diritmsz),          | Length of items.               +\n               =a(dir#lnks),          | Number of links.               +\n               =a(dirlinks-dir),      | Offset of links.               +\n               ,,                     | Length is in item.             +\n               ,,                     | Number of link are fixed (0).  +\n               ,)                     | Offset of links is fixed (0).\n  l16   r0,&w.itd                     | Load r0 with token of ITD.\n  st    r0,imctddir                   | Save this in IMC.\n  litda r5,r0                         | Load address of ITD.\n  using itd,r5                        | Establish base for ITD.\n  sbit  itdf1dfl                      | Description in first link.\n  drop  r5                            | Endif.\n* *-------------------------------------------------------------------*\n* * Make a hash table descriptor for directory.\n* *-------------------------------------------------------------------*\n  callsub create_hash_table_descriptor_function,                       +\n               (&w.token,             | Token return area.             +\n               &s.desc_directory,     | Description.                   +\n               ,                      | No options.                    +\n               101,                   | Entries in table.              +\n               =a(dirtksyn_link_number), Synonym link number.          +\n               =a(dirname-dir),       | Offset of key.                 +\n               ,                      | Not fixed size key.            +\n               =a(dirnmsz-dir))       | Offset of key size.\n  mvc   imcdsdir,&w.token             | Move token to IMC.\n* *-------------------------------------------------------------------*\n* * Make a description for ITD ITD and place it in first link of\n* * ITD.\n* *-------------------------------------------------------------------*\n  la    r1,&s.desc_itd                | Point to description.\n  callsub make_a_dsc                  | Make a DSC.\n  lr    r3,r0                         | Save token.\n  l     r1,imctditd                   | Point to\n  litda r5,r1                         | ITD for\n  using itd,r5                        | ITD.\n  st    r3,itddesc                    | Move the token to the ITD.\n  drop  r5                            | Drop base for ITD.\n* *-------------------------------------------------------------------*\n* * Make a description for ITDX ITD and place it in first link of\n* * ITD.\n* *-------------------------------------------------------------------*\n  la    r1,&s.desc_itdx               | Point to description.\n  callsub make_a_dsc                  | Make a DSC.\n  lr    r3,r0                         | Save token.\n  l     r1,imctditdx                  | Point to\n  litda r5,r1                         | ITD for\n  using itd,r5                        | ITDX.\n  st    r3,itddesc                    | Move the token to the ITD.\n  drop  r5                            | Drop base for ITD.\n* *-------------------------------------------------------------------*\n* * Make a description for IMC ITD and place it in first link of\n* * ITD.\n* *-------------------------------------------------------------------*\n  la    r1,&s.desc_imc                | Point to description.\n  callsub make_a_dsc                  | Make a DSC.\n  lr    r3,r0                         | Save token.\n  l16   r1,imcitype                   | Point to\n  litda r5,r1                         | ITD for\n  using itd,r5                        | IMC.\n  st    r3,itddesc                    | Move the token to the ITD.\n  drop  r5                            | Drop base for ITD.\n* *-------------------------------------------------------------------*\n* * Make a description for GRD ITD and place it in first link of\n* * ITD.\n* *-------------------------------------------------------------------*\n  la    r1,&s.desc_grd                | Point to description.\n  callsub make_a_dsc                  | Make a DSC.\n  lr    r3,r0                         | Save token.\n  l     r1,imctdgrd                   | Point to\n  litda r5,r1                         | ITD for\n  using itd,r5                        | GRD.\n  st    r3,itddesc                    | Move the token to the ITD.\n  drop  r5                            | Drop base for ITD.\n* *-------------------------------------------------------------------*\n* * Make a description for GSS ITD and place it in first link of\n* * ITD.\n* *-------------------------------------------------------------------*\n  la    r1,&s.desc_gss                | Point to description.\n  callsub make_a_dsc                  | Make a DSC.\n  lr    r3,r0                         | Save token.\n  l     r1,imctdgss                   | Point to\n  litda r5,r1                         | ITD for\n  using itd,r5                        | GSS.\n  st    r3,itddesc                    | Move the token to the ITD.\n  drop  r5                            | Drop base for ITD.\n* *-------------------------------------------------------------------*\n* * Make a description for DSC ITD and place it in first link of\n* * ITD.\n* *-------------------------------------------------------------------*\n  la    r1,&s.desc_dsc                | Point to description.\n  callsub make_a_dsc                  | Make a DSC.\n  lr    r3,r0                         | Save token.\n  l     r1,imctddsc                   | Point to\n  litda r5,r1                         | ITD for\n  using itd,r5                        | DSC.\n  st    r3,itddesc                    | Move the token to the ITD.\n  drop  r5                            | Drop base for ITD.\n* *-------------------------------------------------------------------*\n* * Indicate that initialization has been done.\n* *-------------------------------------------------------------------*\n  sbit  imcf1int                      | Initialization has been done.\n  drop  r4                            | Drop base for IMC.\n* *-------------------------------------------------------------------*\n endblk block=initialize_function     |\n space 1                              |\n         ssd ,                        |\n&s.desc_dsc  im_text \"Description\"\n&s.desc_grd  im_text \"Group Descriptor\"\n&s.desc_gss  im_text \"Group Storage Segment\"\n&s.desc_imc  im_text \"Item Manager Control\"\n&s.desc_itd  im_text \"Item Type Descriptor\"\n&s.desc_itdx im_text \"Item Type Descriptor - Extended\"\n&s.desc_lld  im_text \"Linked List Descriptor\"\n&s.desc_htd  im_text \"Hash Table Descriptor\"\n&s.desc_dir  im_text \"Directory Entry\"\n&s.desc_directory im_text \"Directory\"\n         endssd ,                     |\n         swa ,                        |\n&w.system_grd_token             ds f  |\n&w.token                        ds f  |\n&w.itd                          ds h  |\n         endswa ,                     |\n   eject                              |\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Save_Function\n*  Abstract:   This subroutine processes the save function.\n*\n*---------------------------------------------------------------------*\n block type=subroutine,name=save_function,                             +\n               parmmap=prm_function_dependent\n* *-------------------------------------------------------------------*\n* * If div manager epa was supplied, issue save.  If not, it is an\n* * error.\n* *-------------------------------------------------------------------*\n  l32   r15,pwa_dv                    | Point r15 to div manager epa.\n  errexit z,code=&im_function_requires_div\n  callx (r15),(pwa_dv_token,&dv_save),vl Save.\n  errexit (treg,r15,nz),code=&im_dv_save_failed\n* *-------------------------------------------------------------------*\n endblk block=save_function           |\n   eject                              |\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Reset_Function\n*  Abstract:   This subroutine processes the reset function.\n*\n*---------------------------------------------------------------------*\n block type=subroutine,name=reset_function,                            +\n               parmmap=prm_function_dependent\n* *-------------------------------------------------------------------*\n* * If div manager epa was supplied, issue save.  If not, it is an\n* * error.\n* *-------------------------------------------------------------------*\n  l32   r15,pwa_dv                    | Point r15 to div manager epa.\n  errexit z,code=&im_function_requires_div\n  callx (r15),(pwa_dv_token,&dv_reset),vl Reset.\n  errexit (treg,r15,nz),code=&im_dv_reset_failed\n* *-------------------------------------------------------------------*\n endblk block=reset_function          |\n   eject                              |\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Add_To_Directory_Function\n*  Abstract:   This subroutine processes the reset function.\n*\n*---------------------------------------------------------------------*\n block type=subroutine,name=add_to_directory_function,                 +\n               parmmap=prm_function_dependent\n* *-------------------------------------------------------------------*\n* *\n* *-------------------------------------------------------------------*\n  errexit code=&im_not_yet_supported\n* *-------------------------------------------------------------------*\n endblk block=add_to_directory_function\n   eject                              |\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Find_In_Directory_Function\n*  Abstract:   This subroutine processes the reset function.\n*\n*---------------------------------------------------------------------*\n block type=subroutine,name=find_in_directory_function,                +\n               parmmap=prm_function_dependent\n* *-------------------------------------------------------------------*\n* *\n* *-------------------------------------------------------------------*\n  errexit code=&im_not_yet_supported\n* *-------------------------------------------------------------------*\n endblk block=find_in_directory_function\n   eject                              |\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Remove_From_Directory_Function\n*  Abstract:   This subroutine processes the reset function.\n*\n*---------------------------------------------------------------------*\n block type=subroutine,name=remove_from_directory_function,            +\n               parmmap=prm_function_dependent\n* *-------------------------------------------------------------------*\n* *\n* *-------------------------------------------------------------------*\n  errexit code=&im_not_yet_supported\n* *-------------------------------------------------------------------*\n endblk block=remove_from_directory_function\n   eject                              |\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Create_Item_Type_Descriptor_Function\n*  Abstract:   This subroutine processes the create item type\n*              descriptor function.\n*\n*---------------------------------------------------------------------*\n block type=subroutine,name=create_item_type_descriptor_function,      +\n               parmmap=prm_function_dependent\n* *-------------------------------------------------------------------*\n* * Determime if long form is required because a size/offset is\n* * specified.\n* *-------------------------------------------------------------------*\n  sbit  pwa_f_short_itd_ok            | Assume short will be ok.\n  l32   r1,prm_create_itd_item_len_size Point r1 to len size.\n  if z,or,(clc,0(4,r1),eq,=a(0))      | If zero:\n   l32   r2,prm_create_itd_item_len_offset Point to offset.\n   errexit nz,and,(clc,0(4,r2),ne,=a(0)),  Error if offset not zero.   +\n               code=&im_offset_specified_when_size_was_zero\n  else                                | Else if not zero:\n   rbit  pwa_f_short_itd_ok           |  Indicate long form required.\n  endif                               | Endif.\n  l32   r1,prm_create_itd_#_links_size  Point r1 to # links size.\n  if z,or,(clc,0(4,r1),eq,=a(0))      | If zero:\n   l32   r2,prm_create_itd_#_links_offset  Point to offset.\n   errexit nz,and,(clc,0(4,r2),ne,=a(0)),  Error if offset not zero.   +\n               code=&im_offset_specified_when_size_was_zero\n  else                                | Else if not zero:\n   rbit  pwa_f_short_itd_ok           |  Indicate long form required.\n  endif                               | Endif.\n  l32   r1,prm_create_itd_offset_size | Point r1 to offset size.\n  if z,or,(clc,0(4,r1),eq,=a(0))      | If zero:\n   l32   r2,prm_create_itd_offset_offset   Point to offset.\n   errexit nz,and,(clc,0(4,r2),ne,=a(0)),  Error if offset not zero.   +\n               code=&im_offset_specified_when_size_was_zero\n  else                                | Else if not zero:\n   rbit  pwa_f_short_itd_ok           |  Indicate long form required.\n  endif                               | Endif.\n* *-------------------------------------------------------------------*\n* * Determime if long form is required because a value is too large.\n* *-------------------------------------------------------------------*\n  if (tbit,pwa_f_short_itd_ok)        | If stort still possible:\n   l32   r1,prm_create_itd_item_len   |  Point r1 to item length.\n   if z,or,(clc,0(4,r1),le,=a(255))   |  If not specified or <= 255:\n    l32   r1,prm_create_itd_#_links   |   Point r1 to # links.\n    if z,or,(clc,0(4,r1),le,=a(255))  |   If not specified of <= 255:\n     l32   r1,prm_create_itd_offset   |    Point r1 to offset.\n     if nz,and,(clc,0(4,r1),gt,=a(255))    If specified and > 255:\n      rbit  pwa_f_short_itd_ok        |     Indicate can't be short.\n     endif                            |    Endif.\n    else                              |   Else:\n     rbit  pwa_f_short_itd_ok         |    Indicate can't be short.\n    endif                             |   Endif.\n   else                               |  Else:\n    rbit  pwa_f_short_itd_ok          |   Indicate can't be short.\n   endif                              |  Endif.\n  endif                               | Endif.\n* *-------------------------------------------------------------------*\n* * Build the part of the ITD that is common to a non-extended and\n* * extended ITD.\n* *-------------------------------------------------------------------*\n  fill  pwa_itd_build_area,x'00'      | Clear build area.\n  la    r3,pwa_itd_build_area         | Point r2 to build area.\n  using itd,r3                        | Establish base for area.\n  l     r4,pwa_imc_address            | Point r4 to IMC.\n  using imc,r4                        | Establish base for IMC.\n  mvc   itdclass,=y(&im_class_unclassified) Set class.\n  l32   r1,prm_create_itd_description | Point r1 to description.\n  if nz                               | If one was passed:\n   callsub make_a_dsc                 |  Make a DSC for it.\n   st    r0,itddesc                   |  Store the token in the ITD.\n  endif                               | Endif.\n  l32   r1,prm_create_itd_grd_token   | Point r1 to grd token.\n  if z,or,(clc,0(4,r1),eq,=a(0))      | If not specified:\n   mvc   itdgrd,imcgrddf              |  Set GRD to default.\n  else                                | Else:\n   mvc   itdgrd,0(r1)                 |  Set GRD to one passed.\n  endif                               | Endif.\n* *-------------------------------------------------------------------*\n* * If a short form is possible, make a short ITD after doing further\n* * checking.\n* *-------------------------------------------------------------------*\n  if (tbit,pwa_f_short_itd_ok)        | If stort still possible:\n   mvc   itditype,imctditd+2          |  Move ITD token to ITD.\n   l32   r1,prm_create_itd_item_len   |  Point to item length.\n   errexit z,code=&im_length_required |  Error if zero.\n   l32   r1,0(r1)                     |  Load item length.\n   errexit z,code=&im_length_required |  Error if zero.\n   stc   r1,itdiln                    |  Store length in ITD.\n   slr   r0,r0                        |  Clear # links holder (r0).\n   l32   r1,prm_create_itd_#_links    |  Point r1 to # links.\n   if nz                              |  If specified:\n    l     r0,0(,r1)                   |   Load # links.\n    stc   r0,itdinl                   |   Store # in ITD.\n   endif                              |  Endif.\n   l32   r1,prm_create_itd_offset     |  Point r1 to offset.\n   if nz                              |  If specified:\n    l32   r1,0(r1)                    |   Load offset.\n    stc   r1,itdilo                   |   Store offset in ITD.\n   endif                              |  Endif.\n   errexit z,and,(treg,r0,nz),code=&im_invalid_offset\n   sll   r0,2                         |  Multiply # links by 4.\n   ar    r0,r1                        |  Add to offset.\n   if nz                              |  If there were specified:\n    l8    r1,itdiln                   |   It is an error if\n    errexit  (cli,itdilo,lt,2),or,    |   offset is < 2 or             +\n               (cr,r0,gt,r1),         |   links would extend past      +\n               code=&im_invalid_offset    end of item.\n   endif                              |  Endif.\n* *-------------------------------------------------------------------*\n* * If a long form is required, make a long ITD after doing further\n* * checking.\n* *-------------------------------------------------------------------*\n  else                                | If long form required:\n*  *------------------------------------------------------------------*\n*  * Set the extended flag and item type.\n*  *------------------------------------------------------------------*\n   sbit  itdf1ext                     |  Set extended flag.\n   mvc   itditype,imctditdx+2         |  Move ITD token to ITD.\n*  *------------------------------------------------------------------*\n*  * Process the item length parameters.\n*  *------------------------------------------------------------------*\n   slr   r0,r0                        |  Load\n   l32   r1,prm_create_itd_item_len   |  r0\n   if nz                              |  with\n    l     r0,0(,r1)                   |  item length\n   endif                              |  parameter.\n   l32   r1,prm_create_itd_item_len_size Load\n   if nz                              |  r1 with\n    l     r1,0(,r1)                   |  item length size\n   endif                              |  parameter.\n   l32   r2,prm_create_itd_item_len_offset Load\n   if nz                              |  r2 with\n    l     r2,0(,r2)                   |  item length offset\n   endif                              |  parameter.\n   if (treg,r0,nz)                    |  If length was specified:\n      errexit  (treg,r1,nz),or,       |   It is an error if            +\n               (treg,r2,nz),or,       |   item length size or          +\n               (ch,r0,lt,=h'2'),      |   offset is specified.         +\n               code=&im_length_parm_error\n    st    r0,itdxiln                  |   Store the length.\n   else                               |  If length was not specified:\n    errexit  (ch,r1,lt,=h'1'),or,     |   If length size is < 1        +\n               (ch,r1,gt,=h'4'),or,   |   or > 4 or if the length      +\n               (ch,r2,lt,=h'2'),      |   offset < 2, it is an         +\n               code=&im_length_parm_error error.\n    stc   r1,itdxilnsz                |   Store the length size.\n    st    r2,itdxilnof                |   Store the length offset.\n    sbit  itdf1lni                    |   Indicate length in item.\n   endif                              |  Endif.\n*  *------------------------------------------------------------------*\n*  * Process the number of links parameters.\n*  *------------------------------------------------------------------*\n   slr   r0,r0                        |  Load\n   l32   r1,prm_create_itd_#_links    |   r0\n   if nz                              |  with\n    l     r0,0(,r1)                   |  number links\n   endif                              |  parameter.\n   l32   r1,prm_create_itd_#_links_size Load\n   if nz                              |  r1 with\n    l     r1,0(,r1)                   |  number links size\n   endif                              |  parameter.\n   l32   r2,prm_create_itd_#_links_offset Load\n   if nz                              |  r2 with\n    l     r2,0(,r2)                   |  number links offset\n   endif                              |  parameter.\n   if (treg,r0,nz)                    |  If # links was specified:\n    errexit    (treg,r1,nz),or,       |   It is an error if            +\n               (treg,r2,nz),          |   number links size or         +\n               code=&im_#_links_parm_error offset is specified.\n    st    r0,itdxinl                  |   Store the # links.\n   elseif (treg,r1,nz),or,(treg,r2,nz)   If # links not specified:\n    errexit    (ch,r1,lt,=h'1'),or,   |   If # links size is < 1       +\n               (ch,r1,gt,=h'4'),or,   |   or > 4 or if the length      +\n               (ch,r2,lt,=h'2'),      |   offset < 2, it is an         +\n               code=&im_#_links_parm_error error.\n    stc   r1,itdxinlsz                |   Store the # links size.\n    st    r2,itdxinlof                |   Store the # links offset.\n    sbit  itdf1nli                    |   Indicate # links in item.\n   endif                              |  Endif.\n*  *------------------------------------------------------------------*\n*  * Process the links offset parameters.\n*  *------------------------------------------------------------------*\n   slr   r0,r0                        |  Load\n   l32   r1,prm_create_itd_offset     |  r0\n   if nz                              |  with\n    l     r0,0(,r1)                   |  links offset\n   endif                              |  parameter.\n   l32   r1,prm_create_itd_offset_size Load\n   if nz                              |  r1 with\n    l     r1,0(,r1)                   |  links offset size\n   endif                              |  parameter.\n   l32   r2,prm_create_itd_offset_offset Load\n   if nz                              |  r2 with\n    l     r2,0(,r2)                   |  links offset offset\n   endif                              |  parameter.\n   if (treg,r0,nz)                    |  If offset was specified:\n    errexit    (treg,r1,nz),or,       |   It is an error if            +\n               (treg,r2,nz),or,       |   links offset size or         +\n               (ch,r0,lt,=h'2'),      |   offset is specified.         +\n               code=&im_links_offset_parm_error\n    st    r0,itdxilo                  |   Store the offset.\n   elseif (treg,r1,nz),or,(treg,r2,nz)   If offset was not specified:\n    errexit    (ch,r1,lt,=h'1'),or,   |   If offset size is < 1        +\n               (ch,r1,gt,=h'4'),or,   |   or > 4 or if the length      +\n               (ch,r2,lt,=h'2'),      |   offset < 2, it is an         +\n               code=&im_links_offset_parm_error error.\n    stc   r1,itdxilosz                |   Store the offset size.\n    st    r2,itdxiloof                |   Store the offset offset.\n    sbit  itdf1loi                    |   Indicate offset in item.\n   endif                              |  Endif.\n*  *------------------------------------------------------------------*\n*  * If item has links, links offset must be specified; otherwise,\n*  * links offset must not be specified.\n*  *------------------------------------------------------------------*\n   if (clc,itdxinl,ne,=f'0'),or,      |  If item has links:            +\n               (tbit,itdf1nli)        |\n    errexit (clc,itdxilo,eq,=f'0'),and,   error if links offset        +\n               not,(tbit,itdf1loi),   |   was specified.               +\n               code=&im_links_offset_parm_error\n   else                               |  Else:\n    errexit (clc,itdxilo,ne,=f'0'),or,    error if links offset        +\n               (tbit,itdf1loi),       |   was specified.               +\n               code=&im_links_offset_parm_error\n   endif                              |  Endif.\n* *-------------------------------------------------------------------*\n  endif                               | Endif.\n* *-------------------------------------------------------------------*\n* * Store the ITD build and return its token.\n* *-------------------------------------------------------------------*\n  la    r1,pwa_itd_build_area         | Point r1 to build area.\n  callsub store_item                  | Store the item.\n  l32   r2,prm_create_itd_descriptor_token\n  if nz                               | Return the token\n   sth   r0,0(,r2)                    | to the caller.\n  endif                               |\n* *-------------------------------------------------------------------*\n endblk block=create_item_type_descriptor_function\n   eject                              |\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Create_Group_Descriptor_Function\n*  Abstract:   This subroutine processes the create group\n*              descriptor function.\n*\n*---------------------------------------------------------------------*\n block type=subroutine,name=create_group_descriptor_function,          +\n               parmmap=prm_function_dependent\n* *-------------------------------------------------------------------*\n* * Build the GRD.\n* *-------------------------------------------------------------------*\n  fill  pwa_grd_build_area,x'00'      | Clear build area.\n  la    r3,pwa_grd_build_area         | Point r2 to build area.\n  using grd,r3                        | Establish base for area.\n  l     r4,pwa_imc_address            | Point r4 to IMC.\n  using imc,r4                        | Establish base for IMC.\n  mvc   grditype,imctdgrd+2           | Move type to GRD.\n  mvc   grdmmthd,=a(2)                | Move standard method to GRD.\n  lh    r0,=y(4096)                   | Load default inc size in r0.\n  l32   r1,prm_create_gd_increment_size Point r1 to increment size.\n  if nz                               | If one was passed:\n   l32   r0,0(r1)                     |  Load size into r0.\n   if    z                            |  If zero:\n    lh    r0,=y(4096)                 |   Assume default.\n   else                               |  If not zero:\n    ah    r0,=y(4095)                 |   Round it up to\n    srl   r0,12                       |   a multiple of\n    sll   r0,12                       |   4096.\n   endif                              |  Endif.\n  endif                               | Endif.\n  st    r0,grdincsz                   | Store inc size in GRD.\n  l32   r1,prm_create_gd_description  | Point r1 to description.\n  if nz                               | If one was passed:\n   callsub make_a_dsc                 |  Make a DSC for it.\n   st    r0,grddesc                   |  Store the token in the GRD.\n  endif                               | Endif.\n  mvc   grdnxgrd,imcfrgrd             | GRD will be first in chain.\n*                                     | After GRD is stored, its token\n*                                     | will be saved in IMCFRGRD.\n* *-------------------------------------------------------------------*\n* * Store the GRD, return its token and put it at head of GRD chain\n* * in IMC.                           |\n* *-------------------------------------------------------------------*\n  drop  r3                            | Drop base for GRD.\n  la    r1,pwa_grd_build_area         | Point r1 to build area.\n  callsub store_item                  | Store the item.\n  st    r0,&w.grd_token               | Save token in work area.\n  st    r0,imcfrgrd                   | Put GRD at head of chain.\n  l32   r2,prm_create_gd_descriptor_token\n  if nz                               | Return the token\n   st    r0,0(,r2)                    | to the caller.\n  endif                               |\n  imlta r5,r0                         | Get address of GRD.\n  errexit nz,code=&im_internal_error  | Error if invalid.\n  using grd,r5                        | Establish base for GRD.\n* *-------------------------------------------------------------------*\n* * Make an ITD for this GRDs free space and update the GRD.\n* *-------------------------------------------------------------------*\n  fill  &w.fsi_token,x'00'            | Clear token.\n  callsub create_item_type_descriptor_function,                        +\n               (&w.fsi_token+2,       |                                +\n               ,                      | No description.                +\n               ,                      | No options.                    +\n               &w.grd_token,          | Put in system storage.         +\n               ,                      | Length of items is in item.    +\n               =a(fsi#lnks),          | Number of links.               +\n               =a(fsilinks-fsi),      | Offset of links.               +\n               =a(l'fsisize),         | Length is                      +\n               =a(fsisize-fsi),       | in item.                       +\n               ,,                     | Number of link are fixed (0).  +\n               ,)                     | Offset of links is fixed (0).\n  l     r0,&w.fsi_token               | Load r0 with token of FSI.\n  st    r0,grdtdfsi                   | Save this in GRD.\n  litda r6,r0                         | Load address of ITD.\n  mvc   itdclass-itd(l'itdclass,r6),=y(&im_class_freespace) Set class.\n* *-------------------------------------------------------------------*\n endblk block=create_group_descriptor_function\n         swa ,                        |\n&w.grd_token                     ds a |\n&w.fsi_token                     ds a |\n         endswa ,                     |\n   eject                              |\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Create_Linked_List_Descriptor_Function\n*  Abstract:   This subroutine processes the create linked list\n*              descriptor function.\n*\n*---------------------------------------------------------------------*\n block type=subroutine,name=create_linked_list_descriptor_function,    +\n               parmmap=prm_function_dependent\n* *-------------------------------------------------------------------*\n* * Start building the LLD based on the parameters.\n* *-------------------------------------------------------------------*\n  fill  pwa_lld_build_area,x'00'      | Clear build area.\n  la    r3,pwa_lld_build_area         | Point r2 to build area.\n  using lld,r3                        | Establish base for area.\n  l     r4,pwa_imc_address            | Point r4 to IMC.\n  using imc,r4                        | Establish base for IMC.\n  mvc   llditype,imctdlld+2           | Move type to LLD.\n  l32   r1,prm_create_ld_description  | Point r1 to description.\n  if nz                               | If one was passed:\n   callsub make_a_dsc                 |  Make a DSC for it.\n   st    r0,llddesc                   |  Store the token in the LLD.\n  endif                               | Endif.\n  l32   r1,prm_create_ld_options      | Point r1 to options parm.\n  if nz                               | If it was specified:\n   mvc   lldop,0(r1)                  |  Move option to LLD.\n  endif                               | Endif.\n  l32   r1,prm_create_ld_first_link_# | Point r1 to first link # parm.\n  if nz                               | If it was specified:\n   mvc   lldfrlk#,0(r1)               |  Store # in LLD.\n  endif                               | Endif.\n  l32   r1,prm_create_ld_final_link_# | Point r1 to final link # parm.\n  if nz                               | If it was specified:\n   mvc   lldfnlk#,0(r1)               |  Move # to LLD.\n  endif                               | Endif.\n  l32   r1,prm_create_ld_next_link_# Point r1 to next link # parm\n  if nz                               | If it was specified:\n   mvc   lldnxlk#,0(r1)               |  Move # to LLD.\n  endif                               | Endif.\n  l32   r1,prm_create_ld_prior_link_# | Point r1 to prior link #\n  if nz                               | If it was specified:\n   mvc   lldprlk#,0(r1)               |  Move # to LLD.\n  endif                               | Endif.\n  l32   r1,prm_create_ld_owner_link_# | Point r1 to owner link # parm.\n  if nz                               | If it was specified:\n   mvc   lldowlk#,0(r1)               |  Move # to LLD.\n  endif                               | Endif.\n  l32   r1,prm_create_ld_itemtype     | Point r1 to item type.\n  if nz                               | If it was specified:\n   mvc   lldmtitd(2),2(r1)            |  Move it to LLD.\n  endif                               | Endif.\n* *------------------------------------------------------------------*\n* * Process heads ITD token.\n* *------------------------------------------------------------------*\n  l32   r1,prm_create_ld_heads_item_type Point r1 to heads ITD token.\n  if nz                               | If it was specified:\n   fill  lldhditd,x'00'               |  Move heads ITD token\n   mvc   lldhditd+2(2),0(r1)          |  to LLD.\n  endif                               | Endif.\n* *------------------------------------------------------------------*\n* * Process the key offset parameter.\n* *------------------------------------------------------------------*\n  slr   r0,r0                         | Load\n  l32   r1,prm_create_ld_key_offset   | r0\n  if nz                               | with\n   l     r0,0(,r1)                    | key\n   sbit  lldf1ked                     | offset\n  endif                               | parameter.\n  st    r0,lldkof                     | Store the offset.\n* *------------------------------------------------------------------*\n* * Process the key length parameters.\n* *------------------------------------------------------------------*\n  slr   r0,r0                         | Load\n  l32   r1,prm_create_ld_key_len      | r0\n  if nz                               | with\n   l     r0,0(,r1)                    | key length parameter.\n   errexit code=&im_key_length_parm_error,                             +\n               (ch,r0,gt,=h'255')     |  Restrict length to 255.\n  endif                               |\n  l32   r2,prm_create_ld_key_len_offset Load\n  if nz                               | r2 with\n   l     r2,0(,r2)                    | key length offset\n  endif                               | parameter.\n  if (treg,r0,nz)                     | If length was specified:\n   errexit     (treg,r2,nz),          |  Error if both are specified.  +\n               code=&im_key_length_parm_error\n   st    r0,lldksz                    |  Store the offset.\n  elseif (treg,r1,nz),or,(treg,r2,nz) | If length was not specified:\n   errexit     (ch,r2,lt,=h'2'),      |  Error if offset < 2.          +\n               code=&im_key_length_parm_error error.\n   st    r2,lldkszof                  |  Store the key offset.\n   sbit  lldf1ksi                     |  Indicate offset in item.\n  endif                               | Endif.\n* *-------------------------------------------------------------------*\n* * Check for errors.\n* *-------------------------------------------------------------------*\n*>errexit\n* *-------------------------------------------------------------------*\n* * Store the lld, return its token.\n* *-------------------------------------------------------------------*\n  drop  r3                            | Drop base for lld.\n  la    r1,pwa_lld_build_area         | Point r1 to build area.\n  callsub store_item                  | Store the item.\n  st    r0,&w.lld_token               | Save token in work area.\n  l32   r2,prm_create_ld_descriptor_token\n  if nz                               | Return the token\n   st    r0,0(,r2)                    | to the caller.\n  endif                               |\n* *-------------------------------------------------------------------*\n endblk block=create_linked_list_descriptor_function\n         swa ,                        |\n&w.lld_token                     ds a |\n         endswa ,                     |\n   eject                              |\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Create_Hash_Table_Descriptor_Function\n*  Abstract:   This subroutine processes the create hash table\n*              descriptor function.\n*\n*---------------------------------------------------------------------*\n block type=subroutine,name=create_hash_table_descriptor_function,     +\n               parmmap=prm_function_dependent\n* *-------------------------------------------------------------------*\n* * Start building the HTD based on the parameters.\n* *-------------------------------------------------------------------*\n  fill  pwa_htd_build_area,x'00'      | Clear build area.\n  la    r3,pwa_htd_build_area         | Point r2 to build area.\n  using htd,r3                        | Establish base for area.\n  l     r4,pwa_imc_address            | Point r4 to IMC.\n  using imc,r4                        | Establish base for IMC.\n  mvc   htditype,imctdhtd+2           | Move type to HTD.\n  l32   r1,prm_create_ht_description  | Point r1 to description.\n  if nz                               | If one was passed:\n   callsub make_a_dsc                 |  Make a DSC for it.\n   st    r0,htddesc                   |  Store the token in the HTD.\n  endif                               | Endif.\n  l32   r1,prm_create_ht_options      | Point r1 to options parm.\n  if nz                               | If it was specified:\n   mvc   htdop,0(r1)                  |  Move option to HTD.\n  endif                               | Endif.\n  l32   r1,prm_create_ht_entries_in_table Point r1 to # entries parm.\n  if nz                               | If it was specified:\n   l     r1,0(,r1)                    |  Load r1 with number.\n  endif                               | Endif.\n  if (treg,r1,z)                      | If not supplied:\n   la    r1,101                       |  Assume 101.\n  endif                               | Endif.\n  ah    r1,=h'1'                      | Add 1 for descriptor link.\n  st    r1,htd#lnks                   | Save in HTD.\n  l32   r1,prm_create_ht_synonym_link_# Point r1 to synonym link # prm.\n  if nz                               | If it was specified:\n   mvc   htdsylk#,0(r1)               |  Move # to HTD.\n  endif                               | Endif.\n  l32   r1,prm_create_ht_itemtype     | Point r1 to item type.\n  if nz                               | If it was specified:\n   mvc   htdmtitd(2),2(r1)            |  Move it to LLD.\n  endif                               | Endif.\n* *------------------------------------------------------------------*\n* * Process the key offset parameters.\n* *------------------------------------------------------------------*\n  slr   r0,r0                         | Load\n  l32   r1,prm_create_ht_key_offset   | r0\n  if nz                               | with\n   l     r0,0(,r1)                    | key offset\n  endif                               | parameter.\n  st    r0,htdkof                     | Store the offset.\n* *------------------------------------------------------------------*\n* * Process the key length parameters.\n* *------------------------------------------------------------------*\n  slr   r0,r0                         | Load\n  l32   r1,prm_create_ht_key_len      | r0\n  if nz                               | with\n   l     r0,0(,r1)                    | key length\n   errexit code=&im_key_length_parm_error,                             +\n               (ch,r0,gt,=h'255')     |  Restrict length to 255.\n  endif                               | parameter.\n  l32   r2,prm_create_ht_key_len_offset Load\n  if nz                               | r2 with\n   l     r2,0(,r2)                    | key length offset\n  endif                               | parameter.\n  if (treg,r0,nz)                     | If length was specified:\n   errexit     (treg,r2,nz),          |  It is an error if key offset  +\n               code=&im_key_length_parm_error is specified.\n   st    r0,htdksz                    |  Store the offset.\n  elseif (treg,r1,nz),or,(treg,r2,nz) | If length was not specified:\n   errexit     (ch,r2,lt,=h'2'),      |  Error if offset < 2.          +\n               code=&im_key_length_parm_error error.\n   st    r2,htdkszof                  |  Store the key offset.\n   sbit  htdf1ksi                     |  Indicate size in item.\n  endif                               | Endif.\n* *-------------------------------------------------------------------*\n* * Check for errors.\n* *-------------------------------------------------------------------*\n*>errexit\n* *-------------------------------------------------------------------*\n* * Calculate size of HTD and obtain IMMS.\n* *-------------------------------------------------------------------*\n  l     r1,htd#lnks                   | Calculate size\n  sla   r1,2                          | of link area.\n  errexit o,code=&im_internal_error   | Error if overflow.\n  ah    r1,=y(htditmsz-4)             | Add size of rest of item.\n  errexit o,code=&im_internal_error   | Error if overflow.\n  st    r1,htdsize                    | Save result in item.\n  mvc   &w.grd_token,imcgrdsy         | System storage GRD.\n  callsub obtain_item_storage,        | Get IMMS for HTD.              +\n               (&w.grd_token,         |                                +\n               htdsize,               |                                +\n               &w.htd_token,          |                                +\n               &w.htd_address)        |\n* *-------------------------------------------------------------------*\n* * Increment number of HTDs and move HTD to item managed storage.\n* *-------------------------------------------------------------------*\n  litda r5,imctdhtd                   | Increment\n  using itd,r5                        | number\n  l     r1,itdnumit                   | of\n  ah    r1,=h'1'                      | HTDs\n  st    r1,itdnumit                   | in its\n  drop  r5                            | ITD.\n  l     r5,&w.htd_address             | Move ITD to IMMS.\n  mvc   0(l'pwa_htd_build_area,r5),pwa_htd_build_area\n* *-------------------------------------------------------------------*\n* * Store HTD token and return.\n* *-------------------------------------------------------------------*\n  l32   r2,prm_create_ht_descriptor_token\n  if nz                               | Return the token\n   mvc   0(4,r2),&w.htd_token         | to the caller.\n  endif                               |\n* *-------------------------------------------------------------------*\n endblk block=create_hash_table_descriptor_function\n         swa ,                        |\n&w.grd_token                     ds f | System storage.\n&w.htd_token                     ds f | HTD token.\n&w.htd_address                   ds a | HTD address.\n         endswa ,                     |\n   eject                              |\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Connect_Function\n*  Abstract:   This subroutine processes the connect function.\n*\n*---------------------------------------------------------------------*\n block type=subroutine,name=connect_function,                          +\n               parmmap=prm_function_dependent\n* *-------------------------------------------------------------------*\n* * Get address of item, descriptor and descriptor's ITD.\n* *-------------------------------------------------------------------*\n  l32   r1,prm_connect_item_token     | Point to item token parm.\n  if nz                               | If it was specified:\n   l32   r1,0(r1)                     |  Put it in r1.\n  endif                               | Endif.\n  if z                                | If not specified:\n   l32   r1,pwa_current_of_item_manager  Point r1 to current item tkn.\n   errexit z,code=&im_currency_error  |  Error if nothing current.\n  endif                               | Endif.\n  st    r1,&w.item_token              | Save token of item to connect.\n  l32   r1,prm_connect_descriptor_token Point r1 to descriptor token.\n  errexit z,code=&im_invalid_descriptor_token It is also required.\n  imlta r4,*r1                        | Get address of descriptor.\n  errexit nz,or,(treg,r4,z),          | Error if invalid or null.      +\n               code=&im_invalid_descriptor_token\n  l16   r1,0(r4)                      | Get address of\n  litda r5,r1                         | ITD for descriptor.\n  using itd,r5                        | Establish base for ITD.\n* *-------------------------------------------------------------------*\n* * Process based on descriptor class.\n* *-------------------------------------------------------------------*\n  lh    r1,itdclass                   | Load class into r1.\n  caseblk reg=r1                      | Process based on class.\n  case &im_class_linked_list_descriptor For linked list:\n   using lld,r4                       |  Establish base for LLD.\n   if (%l32,r1,lldmtitd,nz)           |  If member type was specified:\n    imlta r6,&w.item_token            |   Get address of item.\n    errexit nz,or,(treg,r6,z),        |   Error if invalid or null.    +\n               code=&im_invalid_item_token\n    errexit (clc,0(2,r6),ne,lldmtitd),    Error if itemtype mismatch.  +\n               code=&im_itemtype_mismatch\n   endif                              |  Endif.\n   drop   r4                          |  Drop base for LLD.\n   callsub connect_to_list,           |  Connect item to list.         +\n               (&w.item_token,        |                                +\n               *prm_connect_descriptor_token,                          +\n               *prm_connect_head_token)\n  case &im_class_hash_table_descriptor  For hash table:\n   l32   r1,prm_connect_head_token\n   errexit nz,and,(clc,0(4,r1),ne,=f'0'),                              +\n               code=&im_head_not_valid_for_this_descriptor\n   using htd,r4                       |  Establish base for htd.\n   if (%l32,r1,htdmtitd,nz)           |  If member type was specified:\n    imlta r6,&w.item_token            |   Get address of item.\n    errexit nz,or,(treg,r6,z),        |   Error if invalid or null.    +\n               code=&im_invalid_item_token\n    errexit (clc,0(2,r6),ne,htdmtitd),    Error if itemtype mismatch.  +\n               code=&im_itemtype_mismatch\n   endif                              |  Endif.\n   drop   r4                          |  Drop base for htd.\n   callsub connect_to_hash_table,     |  Connect item to table.        +\n               (&w.item_token,                                         +\n               *prm_connect_descriptor_token)\n  case &im_class_binary_tree_descriptor For binary tree:\n   errexit code=&im_not_yet_supported |\n  case other                          | If other class of item:\n   errexit code=&im_invalid_descriptor_token  It is an error.\n  endcase                             | Endif.\n* *-------------------------------------------------------------------*\n endblk block=connect_function        |\n         swa                          |\n&w.item_token                    ds f |\n         endswa                       |\n   eject                              |\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Disconnect_Function\n*  Abstract:   This subroutine processes the disconnect function.\n*\n*---------------------------------------------------------------------*\n block type=subroutine,name=disconnect_function,                       +\n               parmmap=prm_function_dependent\n* *-------------------------------------------------------------------*\n* * Get address of item, descriptor and descriptor's ITD.\n* *-------------------------------------------------------------------*\n  l32   r1,prm_disconnect_item_token  | Point to item token parm.\n  if nz                               | If it was specified:\n   l32   r1,0(r1)                     |  Put it in r1.\n  endif                               | Endif.\n  if z                                | If not specified:\n   l32   r1,pwa_current_of_item_manager  Point r1 to current item tkn.\n   errexit z,code=&im_currency_error  |  Error if nothing current.\n  endif                               | Endif.\n  st    r1,&w.item_token              | Save token of item to discon.\n  l32   r1,prm_disconnect_descriptor_token Point r1 to descriptor token\n  errexit z,code=&im_invalid_descriptor_token It is also required.\n  imlta r4,*r1                        | Get address of descriptor.\n  errexit nz,or,(treg,r4,z),          | Error if invalid or null.      +\n               code=&im_invalid_descriptor_token\n  l16   r1,0(r4)                      | Get address of\n  litda r5,r1                         | ITD for descriptor.\n  using itd,r5                        | Establish base for ITD.\n* *-------------------------------------------------------------------*\n* * Process based on descriptor class.\n* *-------------------------------------------------------------------*\n  lh    r1,itdclass                   | Load class into r1.\n  caseblk reg=r1                      | Process based on class.\n  case &im_class_linked_list_descriptor For linked list:\n   using lld,r4                       |  Establish base for LLD.\n   if (%l32,r1,lldmtitd,nz)           |  If member type was specified:\n    imlta r6,&w.item_token            |   Get address of item.\n    errexit nz,or,(treg,r6,z),        |   Error if invalid or null.    +\n               code=&im_invalid_item_token\n    errexit (clc,0(2,r6),ne,lldmtitd),    Error if itemtype mismatch.  +\n               code=&im_itemtype_mismatch\n   endif                              |  Endif.\n   drop   r4                          |  Drop base for LLD.\n   callsub disconnect_from_list,      |                                +\n               (&w.item_token,        |                                +\n               *prm_disconnect_descriptor_token,                       +\n               *prm_disconnect_head_token,                             +\n               *prm_disconnect_prior_token)\n  case &im_class_hash_table_descriptor  For hash table:\n   errexit code=&im_not_yet_supported |\n  case &im_class_binary_tree_descriptor For binary tree:\n   errexit code=&im_not_yet_supported |\n  case other                          | If other class of item:\n   errexit code=&im_invalid_descriptor_token  It is an error.\n  endcase                             | Endif.\n* *-------------------------------------------------------------------*\n endblk block=disconnect_function     |\n         swa                          |\n&w.item_token                    ds f |\n         endswa                       |\n   eject                              |\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Get_Function\n*  Abstract:   This subroutine processes the get function.\n*\n*---------------------------------------------------------------------*\n block type=subroutine,name=get_function,                              +\n               parmmap=prm_function_dependent\n* *-------------------------------------------------------------------*\n* * Get token for item and get its characteristics.\n* *-------------------------------------------------------------------*\n  l32    r3,pwa_current_of_item_manager Get current of item manager.\n  errexit z,code=&im_currency_error   | Error if nothing current.\n  st    r3,&w.itc_token               | Store token in ITC.\n  la    r1,&w.itc_                    | Get the item's\n  callsub get_itc                     | characteristics.\n  l32   r1,prm_get_item_token         | Point r2 to token return area.\n  if nz                               | If specified:\n   st    r3,0(,r1)                    |  Return item token.\n  endif                               | Endif.\n* *-------------------------------------------------------------------*\n* * Copy item to caller provided return area.\n* *-------------------------------------------------------------------*\n  callsub copy_item,(&w.itc_,         | Copy item.                     +\n               *prm_get_return_area_size,                              +\n               *prm_get_return_area,  |                                +\n               *prm_get_actual_item_size)\n* *-------------------------------------------------------------------*\n endblk block=get_function            |\n         swa ,                        |\n         itc   id=&w.itc_             |\n         endswa ,                     |\n   eject                              |\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Get_dangerous_addresses_function\n*  Abstract:   This subroutine processes the get dangerous addresses\n*              function.\n*\n*---------------------------------------------------------------------*\n block type=subroutine,name=get_dangerous_addresses_function,          +\n               parmmap=prm_function_dependent\n* *-------------------------------------------------------------------*\n* * Return address of token conversion routine.\n* *-------------------------------------------------------------------*\n  l32   r3,prm_gda_token_convert_routine\n  if nz                               | If not zero:\n   l     r1,pwa_im_quick_get_address  |  Return conversion routine\n   st    r1,0(,r3)                    |  address to caller.\n  endif                               | Endif.\n* *-------------------------------------------------------------------*\n endblk block=get_dangerous_addresses_function\n         swa ,                        |\n         itc   id=&w.itc_             |\n         endswa ,                     |\n         eject\n*---------------------------------------------------------------------*\n*\n*  Macro:      Return_results\n*  Abstract:   This macro is used by other macros of return the\n*              results of finds or obtains.\n*\n*---------------------------------------------------------------------*\n         macro\n         return_results &i=,&type=,&itemtkn=yes\n         gblc  &w\n         aif ('&type' eq 'find').find\n         aif ('&type' eq 'obtain').obtain\n         mnote 8,'TYPE=&TYPE is invalid.'\n         mexit\n.find    anop\n* *-------------------------------------------------------------------*\n* * Return size and token if requested.\n* *-------------------------------------------------------------------*\n  l32   r1,prm_fd&i._actual_item_size   Return item\n  if nz                                 size if\n   mvc   0(4,r1),&w.itc_size            requested.\n  endif\n  aif   ('&itemtkn' ne 'yes').no_find_itemtkn\n  l32   r1,prm_fd&i._item_token         Return item\n  if nz                                 size if\n   mvc   0(4,r1),&w.itc_token           requested.\n  endif\n.no_find_itemtkn anop\n         mexit\n.obtain  anop\n* *-------------------------------------------------------------------*\n* * Copy item to caller provided return area if this is an obtain\n* * function.  If find function, just return size if requested.\n* *-------------------------------------------------------------------*\n   callsub copy_item,(&w.itc_,        |  Copy item.                    +\n               *prm_ob&i._return_area_size,                            +\n               *prm_ob&i._return_area, |                               +\n               *prm_ob&i._actual_item_size)\n   aif   ('&itemtkn' ne 'yes').no_obtain_itemtkn\n   l32   r1,prm_ob&i._item_token      |  Return item\n   if nz                              |  size if\n    mvc   0(4,r1),&w.itc_token        |  requested.\n   endif                              |\n.no_obtain_itemtkn anop\n          mend\n   eject                              |\n*---------------------------------------------------------------------*\n*\n*  Macro:      specific_item\n*  Abstract:   This macro generates common code used by\n*              obtain/find subroutines.\n*  Parameter:  TYPE=OBTAIN/FIND\n*\n*---------------------------------------------------------------------*\n         macro\n         specific_item &type=\n         gblc  &w\n         gbla  &im_class_unclassified\n         gbla  &im_invalid_item\n  aif ('&type' eq 'obtain').obtain\n  aif ('&type' eq 'find').find\n  mnote 8,'TYPE=&TYPE is invalid.'\n  mexit\n.obtain anop\n&j       setc 'ob'\n  ago  .process2\n.find   anop\n&j       setc 'fd'\n.process2 anop\n* *-------------------------------------------------------------------*\n* * Get token for item and get its characteristics.\n* *-------------------------------------------------------------------*\n  l     r1,prm_&j._item_token         | Load address of token.\n  mvc   &w.itc_token,0(r1)            | Move token to ITC.\n  la    r1,&w.itc_                    | Get the item's\n  callsub get_itc                     | characteristics.\n* *-------------------------------------------------------------------*\n* * Make sure that item is unclassified.\n* *-------------------------------------------------------------------*\n  l     r5,&w.itc_itd_address         | Get address of ITD.\n  using itd,r5                        | Establish base for ITD.\n  errexit      (clc,=y(&im_class_unclassified),ne,itdclass),           +\n               code=&im_invalid_item  |\n* *-------------------------------------------------------------------*\n* * Copy item to caller provided return area if this is an obtain\n* * function.  If find function, just return size if requested.\n* *-------------------------------------------------------------------*\n  return_results i=,type=&type,itemtkn=NO\n* *-------------------------------------------------------------------*\n* * Make the item current-of-item-manager and current-of-item-type.\n* *-------------------------------------------------------------------*\n  callsub make_current,(&w.itc_token,)  Make item current.\n* *-------------------------------------------------------------------*\n         swa  type=partial            |\n         itc id=&w.itc_               |\n         endswa ,                     |\n         mend\n         eject\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Obtain_Function\n*  Abstract:   This subroutine processes the obtain function.\n*\n*---------------------------------------------------------------------*\n block type=subroutine,name=obtain_function,                           +\n               parmmap=prm_function_dependent\n  specific_item type=obtain\n endblk block=obtain_function         |\n space 1\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Find_Function\n*  Abstract:   This subroutine processes the find function.\n*\n*---------------------------------------------------------------------*\n block type=subroutine,name=find_function,                             +\n               parmmap=prm_function_dependent\n  specific_item type=find\n endblk block=find_function           |\n         eject\n*---------------------------------------------------------------------*\n*\n*  Macro:      by_key\n*  Abstract:   This macro generates common code used by\n*              obtain/find by_key subroutines.\n*  Parameter:  TYPE=OBTAIN/FIND\n*\n*---------------------------------------------------------------------*\n         macro\n         by_key &type=\n         gblc  &w\n         gbla  &im_invalid_descriptor_token\n         gbla  &im_not_yet_supported\n         gbla  &im_itemtype_mismatch\n         gbla  &im_class_linked_list_descriptor\n         gbla  &im_class_hash_table_descriptor\n         gbla  &im_class_binary_tree_descriptor\n  aif ('&type' eq 'obtain').obtain\n  aif ('&type' eq 'find').find\n  mnote 8,'TYPE=&TYPE is invalid.'\n  mexit\n.obtain anop\n&j       setc 'ob'\n  ago  .process2\n.find   anop\n&j       setc 'fd'\n.process2 anop\n* *-------------------------------------------------------------------*\n* * Get the descriptor token and its base.\n* *-------------------------------------------------------------------*\n  l     r1,prm_&j.ky_descriptor_token | Load r1 with\n  l     r0,0(,r1)                     | token of descriptor.\n  st    r0,&w.descriptor_token        | Move token to work area.\n  imlta r4,r0                         |\n  errexit nz,or,(treg,r4,z),code=&im_invalid_descriptor_token\n* *-------------------------------------------------------------------*\n* * Establish base for ITD of descriptor.\n* *-------------------------------------------------------------------*\n  l16   r1,0(r4)                      |\n  litda r5,r1                         |\n  using itd,r5                        |\n* *-------------------------------------------------------------------*\n* * Find token of item based on descriptor class.\n* *-------------------------------------------------------------------*\n  lh    r1,itdclass                   | Load class into r1.\n  caseblk reg=r1                      | Process based on class.\n  case &im_class_linked_list_descriptor For linked list:\n   errexit code=&im_not_yet_supported |\n  case &im_class_hash_table_descriptor  For hash table:\n   using htd,r4                       | Establish base for HTD.\n   callsub find_in_hash_table,        |                                +\n               (*prm_obky_key_length, |                                +\n               *prm_obky_key,         |                                +\n               *prm_obky_descriptor_token,                             +\n               &w.itc_)               |\n   if (%l32,r1,htdmtitd,nz)           |  If member type was specified:\n    l    r6,&w.itc_address            |\n    errexit (clc,0(2,r6),ne,htdmtitd),    Error if itemtype mismatch.  +\n               code=&im_itemtype_mismatch\n   endif                              |  Endif.\n   drop  r4                           |  Drop base for HTD.\n  case &im_class_binary_tree_descriptor For binary tree:\n   errexit code=&im_not_yet_supported |\n  case other                          | If other class of item:\n   errexit code=&im_invalid_descriptor_token  It is an error.\n  endcase                             | Endif.\n* *-------------------------------------------------------------------*\n* * Copy item to caller provided return area if this is an obtain\n* * function.  If find function, just return size if requested.\n* *-------------------------------------------------------------------*\n  return_results i=ky,type=&type      | Return results.\n* *-------------------------------------------------------------------*\n* * Make the item current-of-item-manager and current-of-item-type.\n* *-------------------------------------------------------------------*\n  callsub make_current,(&w.itc_token,)  Make item current.\n* *-------------------------------------------------------------------*\n         swa type=partial             |\n&w.descriptor_token            ds f\n         itc id=&w.itc_               |\n         endswa ,                     |\n         mend\n   eject                              |\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Obtain_By_Key_Function\n*  Abstract:   This subroutine processes the obtain_by_key function.\n*\n*---------------------------------------------------------------------*\n block type=subroutine,name=obtain_by_key_function,                    +\n               parmmap=prm_function_dependent\n  by_key type=obtain\n endblk block=obtain_by_key_function  |\n space 1\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Find_By_Key_Function\n*  Abstract:   This subroutine processes the find_by_key function.\n*\n*---------------------------------------------------------------------*\n block type=subroutine,name=find_by_key_function,                      +\n               parmmap=prm_function_dependent\n  by_key type=find\n endblk block=find_by_key_function    |\n   eject                              |\n*---------------------------------------------------------------------*\n*\n*  Macro:      current_of_item_type\n*  Abstract:   This macro generates common code used by\n*              obtain/find current_of_item_type subroutines.\n*  Parameter:  TYPE=OBTAIN/FIND\n*\n*---------------------------------------------------------------------*\n         macro\n         current_of_item_type &type=\n         gblc  &w\n         gbla  &im_currency_error\n         gbla  &im_class_unclassified\n         gbla  &im_invalid_item\n  aif ('&type' eq 'obtain').obtain\n  aif ('&type' eq 'find').find\n  mnote 8,'TYPE=&TYPE is invalid.'\n  mexit\n.obtain anop\n&j       setc 'ob'\n  ago  .process2\n.find   anop\n&j       setc 'fd'\n.process2 anop\n* *-------------------------------------------------------------------*\n* * Find the item that is current_of_item_type and get its ITC.\n* *-------------------------------------------------------------------*\n  l     r2,prm_&j.3_item_type         | Load pointer to item type.\n  l16   r0,0(r2)                      | Move item type\n  st    r0,&w.item_type               | to fullword work area.\n  callsub find_current,               | Find current for type.         +\n               (&w.item_type,&w.itc_token)\n  errexit (treg,r15,nz),code=&im_currency_error\n  la    r1,&w.itc_                    | Get the item's\n  callsub get_itc                     | characteristics.\n* *-------------------------------------------------------------------*\n* * Make sure that item is unclassified.\n* *-------------------------------------------------------------------*\n  l     r5,&w.itc_itd_address         | Get address of ITD.\n  using itd,r5                        | Establish base for ITD.\n  errexit      (clc,=y(&im_class_unclassified),ne,itdclass),           +\n               code=&im_invalid_item  |\n  return_results i=3,type=&type       | Return results.\n* *-------------------------------------------------------------------*\n* * Make the item current-of-item-manager.\n* *-------------------------------------------------------------------*\n  mvc  pwa_current_of_item_manager,&w.itc_token  Make item current.\n* *-------------------------------------------------------------------*\n         swa type=partial             |\n&w.item_type ds a                     |\n         itc id=&w.itc_               |\n         endswa ,                     |\n         mend\n   eject                              |\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Obtain_current_of_item_type_function\n*  Abstract:   This subroutine processes the\n*              obtain/find_current_of_item_type functions.\n*\n*---------------------------------------------------------------------*\n block type=subroutine,name=obtain_current_of_item_type_function,      +\n               parmmap=prm_function_dependent\n  current_of_item_type type=obtain\n endblk block=obtain_current_of_item_type_function\n space 1\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Find_current_of_item_type_function\n*  Abstract:   This subroutine processes the\n*              find/find_current_of_item_type functions.\n*\n*---------------------------------------------------------------------*\n block type=subroutine,name=find_current_of_item_type_function,        +\n               parmmap=prm_function_dependent\n  current_of_item_type type=find\n endblk block=find_current_of_item_type_function\n   eject                              |\n*---------------------------------------------------------------------*\n*\n*  Macro:      current_of_descriptor\n*  Abstract:   This macro generates common code used by\n*              obtain/find current_of_descriptor subroutines.\n*  Parameter:  TYPE=OBTAIN/FIND\n*\n*---------------------------------------------------------------------*\n         macro\n         current_of_descriptor &type=\n         gblc  &w\n         gbla  &im_currency_error\n* *-------------------------------------------------------------------*\n* * Find the item that is current_of_descriptor and get its ITC.\n* *-------------------------------------------------------------------*\n  aif ('&type' eq 'obtain').obtain\n  aif ('&type' eq 'find').find\n  mnote 8,'TYPE=&TYPE is invalid.'\n  mexit\n.obtain anop\n&j       setc 'ob'\n  ago  .process2\n.find   anop\n&j       setc 'fd'\n.process2 anop\n* *-------------------------------------------------------------------*\n* * Find the item that is current_of_descriptor and get its ITC.\n* *-------------------------------------------------------------------*\n  l     r2,prm_&j.2_descriptor_token  | Point r1 to descriptor token.\n  callsub find_current,               | Find current for descriptor.   +\n               ((r2),&w.itc_token)    |\n  errexit (treg,r15,nz),code=&im_currency_error\n  la    r1,&w.itc_                    | Get the item's\n  callsub get_itc                     | characteristics.\n* *-------------------------------------------------------------------*\n* * Copy item to caller provided return area if this is an obtain\n* * function.  If find function, just return size if requested.\n* *-------------------------------------------------------------------*\n  return_results i=2,type=&type       | Return results.\n* *-------------------------------------------------------------------*\n* * Make the item current-of-item-manager and current-of-item-type.\n* *-------------------------------------------------------------------*\n  callsub make_current,(&w.itc_token,)  Make item current.\n* *-------------------------------------------------------------------*\n         swa type=partial             |\n         itc id=&w.itc_               |\n         endswa ,                     |\n         mend\n         eject\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Obtain_current_of_descriptor_function\n*  Abstract:   This subroutine processes the\n*              obtain_current_of_item_type function.\n*\n*---------------------------------------------------------------------*\n block type=subroutine,name=obtain_current_of_descriptor_function,     +\n               parmmap=prm_function_dependent\n  current_of_descriptor type=obtain\n endblk block=obtain_current_of_descriptor_function\n space 1\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Find_current_of_descriptor_function\n*  Abstract:   This subroutine processes the\n*              find_current_of_item_type function.\n*\n*---------------------------------------------------------------------*\n block type=subroutine,name=find_current_of_descriptor_function,       +\n               parmmap=prm_function_dependent\n  current_of_descriptor type=find\n endblk block=find_current_of_descriptor_function\n   eject                              |\n*---------------------------------------------------------------------*\n*\n*  Macro:      Owner\n*  Abstract:   This macro generates common code used by\n*              obtain/find owner subroutines.\n*  Parameter:  TYPE=OBTAIN/FIND\n*\n*---------------------------------------------------------------------*\n         macro\n         owner &type=\n         gblc  &w\n         gbla  &im_invalid_descriptor_token\n         gbla  &im_class_linked_list_descriptor\n         gbla  &im_requires_owner_link\n         gbla  &im_internal_error\n         gbla  &im_not_found\n         gbla  &im_itemtype_mismatch\n* *-------------------------------------------------------------------*\n* * Get the descriptor token and its base.\n* *-------------------------------------------------------------------*\n  aif ('&type' eq 'obtain').obtain\n  aif ('&type' eq 'find').find\n  mnote 8,'TYPE=&TYPE is invalid.'\n  mexit\n.obtain anop\n&j       setc 'ob'\n  ago  .process2\n.find   anop\n&j       setc 'fd'\n.process2 anop\n  l     r1,prm_&j.2_descriptor_token     Load r1 with\n  l     r1,0(,r1)                        descriptor token\n  st    r1,&w.descriptor_token           and store in work area.\n  imlta r4,r1                            Establish base\n  using lld,r4                           for LLD.\n  errexit nz,or,(treg,r4,z),code=&im_invalid_descriptor_token\n* *-------------------------------------------------------------------*\n* * Establish base for ITD of descriptor.\n* *-------------------------------------------------------------------*\n  l16   r1,0(r4)\n  litda r5,r1\n  using itd,r5\n  errexit (clc,itdclass,ne,=y(&im_class_linked_list_descriptor)),      +\n               code=&im_invalid_descriptor_token\n* *-------------------------------------------------------------------*\n* * Find item token for find/obtain_owner.\n* *-------------------------------------------------------------------*\n  if (%l32,r1,prm_&j.2c_current_token,nz)\n   mvc    &w.itc_token,0(r1)          | Use current token if supplied\n  else                                | otherwise use current of item\n   mvc    &w.itc_token,pwa_current_of_item_manager       manager.\n  endif                               |\n  la    r1,&w.itc_                    | Get ITC\n  callsub get_itc                     | for item.\n  imlla r6,lldowlk#,&w.itc_           | Point to the \"owner\" link.\n  errexit (treg,r6,z),code=&im_requires_owner_link\n  l32   r0,0(r6)                      | If link is null, then\n  errexit z,code=&im_not_found        | there is on owner.\n  st    r0,&w.itc_token               | Save token of owner item.\n  drop  r5                            |\n* *-------------------------------------------------------------------*\n* * Get item's characteristics and make sure it is valid item type.\n* *-------------------------------------------------------------------*\n  la    r1,&w.itc_                    | Get the item's\n  callsub get_itc                     | characteristics.\n  if (%l32,r1,lldmtitd,nz)            | If member type was specified:\n   l    r6,&w.itc_address             |\n   errexit (clc,0(2,r6),ne,lldmtitd),    Error if itemtype mismatch.   +\n               code=&im_itemtype_mismatch\n  endif                               | Endif.\n* *-------------------------------------------------------------------*\n* * Copy item to caller provided return area if this is an obtain\n* * function.  If find function, just return size if requested.\n* *-------------------------------------------------------------------*\n  return_results i=2,type=&type       | Return results.\n* *-------------------------------------------------------------------*\n* * Make the item current-of-item-manager and current-of-item-type.\n* *-------------------------------------------------------------------*\n  callsub make_current,(&w.itc_token,)\n* *-------------------------------------------------------------------*\n         swa   type=partial           |\n&w.descriptor_token ds f              |\n&w.function         ds f              |\n         itc id=&w.itc_               |\n         itc id=&w.itc_heads_         |\n         endswa ,                     |\n         mend\n         eject                        |\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Obtain_owner_function\n*  Abstract:   This subroutine processes the obtain owner function.\n*\n*---------------------------------------------------------------------*\n block type=subroutine,name=obtain_owner_function,                     +\n               parmmap=prm_function_dependent\n  owner type=obtain                   |\n endblk block=obtain_owner_function   |\n space 1                              |\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Find_owner_function\n*  Abstract:   This subroutine processes the find owner function.\n*\n*---------------------------------------------------------------------*\n block type=subroutine,name=find_owner_function,                       +\n               parmmap=prm_function_dependent\n  owner type=find                     |\n endblk block=find_owner_function     |\n         eject                        |\n*---------------------------------------------------------------------*\n*\n*  Macro:      First_final\n*  Abstract:   This macro generates common code used by\n*              obtain/find first and obtain/find final subroutines.\n*  Parameter:  TYPE=OBTAIN/FIND,WHICH=FIRST/FINAL\n*\n*---------------------------------------------------------------------*\n         macro                        |\n         first_final &type=,&which=   |\n         gblc  &w\n         gbla  &im_invalid_descriptor_token\n         gbla  &im_headtkn_invalid\n         gbla  &im_class_linked_list_descriptor\n         gbla  &im_currency_error\n         gbla  &im_internal_error\n         gbla  &im_at_end\n         gbla  &im_itemtype_mismatch\n         aif ('&which' eq 'first').first\n         aif ('&which' eq 'final').final\n         mnote 8,'which=&WHICH is invalid.'\n         mexit                        |\n.first   anop                         |\n&i       setc 'fr'                    |\n         ago  .process                |\n.final   anop                         |\n&i       setc 'fn'                    |\n.process anop                         |\n* *-------------------------------------------------------------------*\n* * Move descriptor and optional head token to work area.\n* *-------------------------------------------------------------------*\n  aif ('&type' eq 'obtain').obtain    |\n  aif ('&type' eq 'find').find        |\n  mnote 8,'TYPE=&TYPE is invalid.'    |\n  mexit                               |\n.obtain anop                          |\n&j       setc 'ob'                    |\n  ago  .process2                      |\n.find   anop                          |\n&j       setc 'fd'                    |\n.process2 anop                        |\n  l     r1,prm_&j.2_descriptor_token  | Move descriptor\n  l     r1,0(,r1)                     | token passed to\n  st    r1,&w.descriptor_token        | work area.\n* *-------------------------------------------------------------------*\n* * Establish base for LLD and ITD of LLD.\n* *-------------------------------------------------------------------*\n  imlta r4,&w.descriptor_token        | Load address of LLD\n  using lld,r4                        | and establish base.\n  errexit nz,or,(treg,r4,z),code=&im_invalid_descriptor_token\n  l16   r1,0(r4)                      | Load address of\n  litda r5,r1                         | LLDs ITD and\n  using itd,r5                        | establish base.\n  errexit (clc,itdclass,ne,=y(&im_class_linked_list_descriptor)),      +\n               code=&im_invalid_descriptor_token\n* *-------------------------------------------------------------------*\n* * Find the first/final item.\n* *-------------------------------------------------------------------*\n  l     r1,prm_&j.2a_head_token       | Move\n  if (tbit,lldophid)                  | If heads in descriptor:\n   errexit (treg,r1,nz),code=&im_headtkn_invalid  NO HEADTKN!\n   la    r6,lld&i.lst                 |  Use first/final pointer\n  else                                | Else:\n   if (treg,r1,nz)                    |  If HEADTKN specified:\n    l     r1,0(,r1)                   |   Use head token\n    st    r1,&w.itc_heads_token       |   supplied.\n    la    r1,&w.itc_heads_            |   Get ITC\n    callsub get_itc                   |   for item.\n    l     r6,&w.itc_heads_address     |   EIF: ITD not right for LLD.\n    errexit (clc,0(2,r6),ne,lldhditd+2),code=&im_headtkn_invalid\n    imlla r6,lld&i.lk#,&w.itc_heads_  |   Calcuate address of link.\n    errexit (treg,r6,z),code=&im_headtkn_invalid\n   else                               |  Else:\n    callsub find_current,(lldhditd,&w.itc_heads_token) Find item\n    errexit (treg,r15,nz),code=&im_currency_error      that has heads.\n    la    r1,&w.itc_heads_            |   Get ITC\n    callsub get_itc                   |   for item.\n    imlla r6,lld&i.lk#,&w.itc_heads_  |   Calcuate address of link.\n    errexit (treg,r6,z),code=&im_internal_error\n   endif                              |  Endif.\n  endif                               | Endif.\n  l32   r0,0(r6)                      | If link is null, then\n  errexit z,code=&im_at_end           | at end.\n  st    r0,&w.itc_token               | Save token of item.\n  drop  r5                            |\n* *-------------------------------------------------------------------*\n* * Get item characteristics, make sure it is valid item type, and\n* * return results.\n* *-------------------------------------------------------------------*\n  la    r1,&w.itc_                    | Get the item's\n  callsub get_itc                     | characteristics.\n  if (%l32,r1,lldmtitd,nz)            | If member type was specified:\n   l    r6,&w.itc_address             |\n   errexit (clc,0(2,r6),ne,lldmtitd),    Error if itemtype mismatch.   +\n               code=&im_itemtype_mismatch\n  endif                               | Endif.\n  return_results i=2,type=&type       | Return results.\n* *-------------------------------------------------------------------*\n* * Make the item current-of-item-manager, current-of-item-type,\n* * and current_of_descriptor.\n* *-------------------------------------------------------------------*\n  callsub make_current,(&w.itc_token,&w.descriptor_token)\n* *-------------------------------------------------------------------*\n         swa  type=partial            |\n&w.descriptor_token ds f              |\n&w.function         ds f              |\n&w.head_token       ds f              |\n         itc id=&w.itc_               |\n         itc id=&w.itc_heads_         |\n         endswa ,                     |\n         mend\n         eject                        |\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Obtain_first_function\n*  Abstract:   This subroutine processes the obtain first function.\n*              functions.\n*\n*---------------------------------------------------------------------*\n block type=subroutine,name=obtain_first_function,                     +\n               parmmap=prm_function_dependent\n  first_final type=obtain,which=first\n endblk block=obtain_first_function   |\n space 1\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Find_first_function\n*  Abstract:   This subroutine processes the find first function.\n*\n*---------------------------------------------------------------------*\n block type=subroutine,name=find_first_function,                       +\n               parmmap=prm_function_dependent\n  first_final type=find,which=first\n endblk block=find_first_function     |\n   space 1                            |\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Obtain_final_function\n*  Abstract:   This subroutine processes the obtain final function.\n*\n*---------------------------------------------------------------------*\n block type=subroutine,name=obtain_final_function,                     +\n               parmmap=prm_function_dependent\n  first_final type=obtain,which=final\n endblk block=obtain_final_function   |\n   space 1                            |\n*---------------------------------------------------------------------*\n*\n*  Subroutine: find_final_function\n*  Abstract:   This subroutine processes the find final function.\n*\n*---------------------------------------------------------------------*\n block type=subroutine,name=find_final_function,                       +\n               parmmap=prm_function_dependent\n  first_final type=find,which=final\n endblk block=find_final_function     |\n         eject\n*---------------------------------------------------------------------*\n*\n*  Macro:      next_prior\n*  Abstract:   This macro generates common code used by\n*              obtain/find_next and obtain/find_prior subroutine.\n*  Parameter:  TYPE=OBTAIN/FIND,WHICH=NEXT/PRIOR\n*\n*---------------------------------------------------------------------*\n         macro\n         next_prior &type=,&which=\n         gblc  &w\n         gbla  &im_currency_error\n         gbla  &im_class_linked_list_descriptor\n         gbla  &im_invalid_descriptor_token\n         gbla  &im_headtkn_invalid\n         gbla  &im_internal_error\n         gbla  &im_at_end\n         gbla  &im_itemtype_mismatch\n         aif ('&which' eq 'next').next\n         aif ('&which' eq 'prior').prior\n         mnote 8,'which=&WHICH is invalid.'\n         mexit\n.next    anop\n&o       setc 'FR'\n&i       setc 'NX'\n         ago  .process\n.prior   anop\n&o       setc 'FN'\n&i       setc 'PR'\n.process anop\n* *-------------------------------------------------------------------*\n* * Move descriptor and optional head token to work area.\n* *-------------------------------------------------------------------*\n  aif ('&type' eq 'obtain').obtain\n  aif ('&type' eq 'find').find\n  mnote 8,'TYPE=&TYPE is invalid.'\n  mexit\n.obtain anop\n&j       setc 'ob'\n  ago  .process2\n.find   anop\n&j       setc 'fd'\n.process2 anop\n  l     r1,prm_&j.2_descriptor_token    Move descriptor\n  l     r1,0(,r1)                       token passed to\n  st    r1,&w.descriptor_token          work area.\n* *-------------------------------------------------------------------*\n* * Establish base for LLD and ITD of LLD.\n* *-------------------------------------------------------------------*\n  imlta r4,&w.descriptor_token        | Load address of LLD\n  using lld,r4                        | and establish base.\n  errexit nz,or,(treg,r4,z),code=&im_invalid_descriptor_token\n  l16   r1,0(r4)                      | Load address of\n  litda r5,r1                         | LLDs ITD and\n  using itd,r5                        | establish base.\n  errexit (clc,itdclass,ne,=y(&im_class_linked_list_descriptor)),      +\n               code=&im_invalid_descriptor_token\n* *-------------------------------------------------------------------*\n* * Find next/prior item.\n* *-------------------------------------------------------------------*\n  if (%l32,r1,prm_&j.2b_current_token,nz) If CURTKN specified:\n   mvc    &w.itc_token,0(r1)          |  Use token supplied.\n  else                                | If CURTKN not specified:\n   callsub find_current,              |  Find current of descriptor.   +\n               (&w.descriptor_token,&w.itc_token)\n   errexit (treg,r15,nz),code=&im_currency_error\n  endif                               | Endif.\n  if (clc,&w.itc_token,eq,=f'0')      | If actually a f/o first:\n   l     r1,prm_&j.2b_head_token      |  Load ptr to headtkn supplied.\n   if (tbit,lldophid)                 |  If heads in descriptor:\n    errexit (treg,r1,nz),code=&im_headtkn_invalid  NO HEADTKN!\n    la    r6,lld&o.lst                |   Use first pointer\n   else                               |  Else:\n    if (treg,r1,nz)                   |   If HEADTKN specified:\n     l     r1,0(,r1)                  |    Use head token\n     st    r1,&w.itc_heads_token      |    supplied.\n     la    r1,&w.itc_heads_           |    Get ITC\n     callsub get_itc                  |    for item.\n     l     r6,&w.itc_heads_address    |    EIF: ITD not ok for LLD.\n     errexit (clc,0(2,r6),ne,lldhditd+2),code=&im_headtkn_invalid\n     imlla r6,lld&o.lk#,&w.itc_heads_ |    Calcuate address of link.\n     errexit (treg,r6,z),code=&im_headtkn_invalid\n    else                              |   Else:\n     callsub find_current,(lldhditd,&w.itc_heads_token) Find item\n     errexit (treg,r15,nz),code=&im_currency_error     that has heads.\n     la    r1,&w.itc_heads_           |    Get ITC\n     callsub get_itc                  |    for item.\n     imlla r6,lld&o.lk#,&w.itc_heads_ |    Calcuate address of link.\n     errexit (treg,r6,z),code=&im_internal_error\n    endif                             |   Endif.\n   endif                              |  Endif.\n   l32   r0,0(r6)                     |  If link is null, then\n   errexit z,code=&im_at_end          |  at end.\n   st    r0,&w.itc_token              |  Save token of first item.\n  else                                | Else:\n   la    r1,&w.itc_                   |  Get ITC for item that is\n   callsub get_itc                    |  current of descriptor.\n   imlla r6,lld&i.lk#,&w.itc_         |  Point to the \"next\" link.\n   aif ('&type' eq 'prior').pr0010\n   errexit (treg,r6,z),code=&im_internal_error\n   ago   .pr0020\n.pr0010 anop\n   errexit (treg,r6,z),code=&im_requires_prior_link\n.pr0020 anop\n   l32   r0,0(r6)                     |  If link is null, then\n   errexit z,code=&im_at_end          |  at end of list.\n   st    r0,&w.itc_token              |  Save token of next item.\n  endif                               | Endif.\n* *-------------------------------------------------------------------*\n* * Get item characteristics, make sure item type is valid, and\n* * return results.\n* *-------------------------------------------------------------------*\n  la    r1,&w.itc_                    | Get the item's\n  callsub get_itc                     | characteristics.\n  if (%l32,r1,lldmtitd,nz)            | If member type was specified:\n   l    r6,&w.itc_address             |\n   errexit (clc,0(2,r6),ne,lldmtitd),    Error if itemtype mismatch.   +\n               code=&im_itemtype_mismatch\n  endif                               | Endif.\n  return_results i=2,type=&type       | Return results.\n* *-------------------------------------------------------------------*\n* * Make the item current-of-item-manager, current-of-item-type,\n* * and current_of_descriptor.\n* *-------------------------------------------------------------------*\n  callsub make_current,(&w.itc_token,&w.descriptor_token)\n*---------------------------------------------------------------------*\n         swa   type=partial           |\n&w.descriptor_token ds f              |\n&w.function         ds f              |\n         itc id=&w.itc_               |\n         itc id=&w.itc_heads_         |\n         endswa ,                     |\n         mend                         |\n   eject                              |\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Obtain_next_function\n*  Abstract:   This subroutine processes the obtain next function.\n*\n*---------------------------------------------------------------------*\n block type=subroutine,name=obtain_next_function,                      +\n               parmmap=prm_function_dependent\n  next_prior type=obtain,which=next   |\n endblk block=obtain_next_function    |\n   space 1                            |\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Find_next_function\n*  Abstract:   This subroutine processes the find next function.\n*\n*---------------------------------------------------------------------*\n block type=subroutine,name=find_next_function,                        +\n               parmmap=prm_function_dependent\n  next_prior type=find,which=next     |\n endblk block=find_next_function      |\n space 1                              |\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Obtain_prior_function\n*  Abstract:   This subroutine processes the obtain prior function.\n*\n*---------------------------------------------------------------------*\n block type=subroutine,name=obtain_prior_function,                     +\n               parmmap=prm_function_dependent\n  next_prior type=obtain,which=prior  |\n endblk block=obtain_prior_function   |\n space 1                              |\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Find_prior_function\n*  Abstract:   This subroutine processes the find prior function.\n*\n*---------------------------------------------------------------------*\n block type=subroutine,name=find_prior_function,                       +\n               parmmap=prm_function_dependent\n  next_prior type=find,which=prior\n endblk block=find_prior_function     |\n   eject                              |\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Modify_Function\n*  Abstract:   This subroutine processes the modify function.\n*\n*---------------------------------------------------------------------*\n block type=subroutine,name=modify_function,                           +\n               parmmap=prm_function_dependent\n* *-------------------------------------------------------------------*\n* * If a item token is not specified, modify current of item manager.\n* *-------------------------------------------------------------------*\n  l32   r1,prm_modify_item_token      | Point to item token.\n  if nz,and,(clc,=f'0',ne,0(r1))      | If token supplied:\n   mvc   &w.item_token,0(r1)          |  Use it.\n  else                                | Otherwise:\n   l32   r1,pwa_current_of_item_manager  Use current of item manager.\n   errexit z,code=&im_currency_error  |  Error if nothing current.\n   st    r1,&w.item_token             |  Save token.\n  endif                               | Endif.\n* *-------------------------------------------------------------------*\n* * Make sure that this is an unclassified item.\n* *-------------------------------------------------------------------*\n  l32   r3,prm_modify_item_address    | Point r1 item.\n  errexit z,code=&im_missing_parameter  Error if missing.\n  l16   r1,0(r3)                      | Load r0 with item type token.\n  litda r4,r1                         | Point r4 to item type desc.\n  using itd,r4                        | Establish base for ITD.\n  l     r6,pwa_imc_address            | Load pointer to IMC.\n  using imc,r6                        | Establish base for IMC.\n  errexit      (clc,itditype,ne,imctditd+2),and, Error if this is not  +\n               (clc,itditype,ne,imctditdx+2),or, a valid unclassified  +\n               (clc,itdclass,ne,=y(&im_class_unclassified)), ITD.      +\n               code=&im_invalid_item_type\n  drop  r6                            | Drop base for IMC.\n* *-------------------------------------------------------------------*\n* * Make sure that items characteristics have not changed.\n* *-------------------------------------------------------------------*\n  imlta r5,&w.item_token              | Point r5 to unmodified item.\n  errexit nz,or,(treg,r5,z),          |                                +\n               code=&im_invalid_item  |\n  errexit (clc,0(2,r3),ne,0(r5)),     |                                +\n               code=&im_item_characteristics_changed\n* *-------------------------------------------------------------------*\n* * If this is an extend ITD, make sure that length, number of links,\n* * or link offset has not changed.\n* *-------------------------------------------------------------------*\n  if (tbit,itdf1ext)                  | If this is an extended ITD:\n*  *------------------------------------------------------------------*\n*  * Make sure that size has not changed.\n*  *------------------------------------------------------------------*\n   if (tbit,itdf1lni)                 |  If length is in item:\n    l32   r1,itdxilnof                |   Get length offset.\n    errexit z,code=&im_internal_error |   Error if zero.\n    lr    r6,r5                       |   Calculate address of length\n    alr   r6,r1                       |   in unmodified copy of item.\n    al    r1,prm_modify_item_address  |   Calc same for modified copy.\n    l8    r2,itdxilnsz                |   Get size of length.\n    errexit np,or,(ch,r2,gt,=h'4'),code=&im_internal_error\n    bctr  r2,0                        |   It is an error if the length\n    exi   r2,(clc,0(*-*,r6),0(r1))    |   modified and unmodified\n    errexit ne,code=&im_item_characteristics_changed item is not same.\n   endif                              |  Endif.\n*  *------------------------------------------------------------------*\n*  * Make sure that number of links has not changed.\n*  *------------------------------------------------------------------*\n   if (tbit,itdf1nli)                 |  If # links is in item:\n    l32   r1,itdxinlof                |   Get # links offset.\n    errexit z,code=&im_internal_error |   Error if zero.\n    lr    r6,r5                       |   Calculate address of # links.\n    alr   r6,r1                       |   in unmodified copy of item.\n    al    r1,prm_modify_item_address  |   Calc same for modified copy.\n    l8    r2,itdxinlsz                |   Get size of # links.\n    errexit np,or,(ch,r2,gt,=h'4'),code=&im_internal_error\n    bctr  r2,0                        |   It is an error if the # links\n    exi   r2,(clc,0(*-*,r6),0(r1))    |   in modified and unmodified\n    errexit ne,code=&im_item_characteristics_changed items is not same.\n   endif                              |  Endif.\n*  *------------------------------------------------------------------*\n*  * Make sure that number of links has not changed.\n*  *------------------------------------------------------------------*\n   if (tbit,itdf1loi)                 |  If offset is in item:\n    l32   r1,itdxiloof                |   Get offset offset.\n    errexit z,code=&im_internal_error |   Error if zero.\n    lr    r6,r5                       |   Calculate address of offset.\n    alr   r6,r1                       |   in unmodified copy of item.\n    al    r1,prm_modify_item_address  |   Calc same for modified copy.\n    l8    r2,itdxilosz                |   Get size of offset.\n    errexit np,or,(ch,r2,gt,=h'4'),code=&im_internal_error\n    bctr  r2,0                        |   It is an error if the offset\n    exi   r2,(clc,0(*-*,r6),0(r1))    |   in modified and unmodified\n    errexit ne,code=&im_item_characteristics_changed items is not same.\n   endif                              |  Endif.\n  endif                               | Endif.\n* *-------------------------------------------------------------------*\n  drop  r4                            | Drop base for ITD.\n* *-------------------------------------------------------------------*\n* * Get the characteristics of the item and validate links if\n* * requested.\n* *-------------------------------------------------------------------*\n  mvi   &w.links_check,c\"Y\"           |\n  l32   r1,prm_modify_options         |\n  if z,or,(tbit,0(r1),                |                                +\n               prm_modify_options_bypass_links_check)\n   mvi   &w.links_check,c\"N\"          |\n  endif                               |\n  callsub get_characteristics_and_validate,                            +\n               (*prm_modify_item_address,                              +\n               &w.links_check,        |                                +\n               ,                      |                                +\n               &w.size_of_item,       |                                +\n               &w.number_of_links,    |                                +\n               &w.offset_of_links)    |\n* *-------------------------------------------------------------------*\n* * If links are not being updated, set up to move item in two parts.\n* *-------------------------------------------------------------------*\n  mvc   &w.size_of_first_part,&w.size_of_item Assume move all.\n  fill  &w.size_of_second_part,x'00'  | Assume no second part.\n  l32   r1,prm_modify_options         | If links not being updated:\n  if z,or,not,(tbit,0(r1),            |                                +\n               prm_modify_options_update_links)\n   l32   r15,&w.number_of_links       |  Load r15 with number of links.\n   if nz                              |  If there are links:\n    l     r1,&w.offset_of_links       |   Offset of links is size\n    st    r1,&w.size_of_first_part    |   of first part.\n    sla   r15,2                       |   Calculate size of links.\n    ar    r15,r1                      |   Add size of 1st part to size\n    st    r15,&w.offset_of_second_part    of link to get 2nd offset.\n    s     r15,&w.size_of_item         |   The size of the item minus\n    lcr   r15,r15                     |   the size of the 2nd offset\n    st    r15,&w.size_of_second_part  |   is the size of the 2nd part.\n   endif                              |  Endif.\n  endif                               | Endif.\n* *-------------------------------------------------------------------*\n* * Modify the first part of the item.\n* *-------------------------------------------------------------------*\n  l     r15,&w.size_of_first_part     | Load size of first part.\n  lr    r6,r5                         | Point r6 to unmodified item.\n  l     r2,prm_modify_item_address    | Point r2 to modified item.\n  loop until                          | Move modified to unmodified.\n   ltr   r1,r15                       |  Load r1 with remaining\n   leave np,loop=*                    |  move length.  Finished if\n*                                     |  length is not positive.\n   if (ch,r1,gt,=h'256')              |  Can only move\n    la    r1,256                      |  up to 256 bytes\n   endif                              |  at a time.\n   sr    r15,r1                       |  Calc new remaining length.\n   bctr  r1,0                         |  Move up to 256\n   exi   r1,(mvc,0(*-*,r6),0(r2))     |  bytes of item.\n   la    r2,256(,r2)                  |  Point to next 256 bytes\n   la    r6,256(,r6)                  |  of item.\n  endloop until,leave                 | Endloop.\n* *-------------------------------------------------------------------*\n* * Modify the second part of the item.\n* *-------------------------------------------------------------------*\n  l     r15,&w.size_of_second_part    | Load size of second part.\n  lr    r6,r5                         | Point r6 to second part of\n  a     r6,&w.offset_of_second_part   | unmodified item.\n  l     r2,prm_modify_item_address    | Point r2 to second part of\n  a     r2,&w.offset_of_second_part   | modified item.\n  loop until                          | Move modified to unmodified.\n   ltr   r1,r15                       |  Load r1 with remaining\n   leave np,loop=*                    |  move length.  Finished if\n*                                     |  length is not positive.\n   if (ch,r1,gt,=h'256')              |  Can only move\n    la    r1,256                      |  up to 256 bytes\n   endif                              |  at a time.\n   sr    r15,r1                       |  Calc new remaining length.\n   bctr  r1,0                         |  Move up to 256\n   exi   r1,(mvc,0(*-*,r6),0(r2))     |  bytes of item.\n   la    r2,256(,r2)                  |  Point to next 256 bytes\n   la    r6,256(,r6)                  |  of item.\n  endloop until,leave                 | Endloop.\n* *-------------------------------------------------------------------*\n* * Make the item current-of-item-manager and current-of-item-type.\n* *-------------------------------------------------------------------*\n  callsub make_current,(&w.item_token,)\n* *-------------------------------------------------------------------*\n endblk block=modify_function         |\n         swa ,                        |\n&w.item_token                    ds f |\n&w.size_of_item                  ds f |\n&w.size_of_first_part            ds f |\n&w.size_of_second_part           ds f |\n&w.offset_of_second_part         ds f |\n&w.number_of_links               ds f |\n&w.offset_of_links               ds f |\n&w.links_check                   ds c |\n         endswa ,                     |\n   eject                              |\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Sort_Function\n*  Abstract:   This subroutine processes the sort function.\n*\n*---------------------------------------------------------------------*\n block type=subroutine,name=sort_function,                             +\n               parmmap=prm_function_dependent\n* *-------------------------------------------------------------------*\n* * Get address descriptor and descriptor's ITD.\n* *-------------------------------------------------------------------*\n  l32   r1,prm_sort_descriptor_token  | Point r1 to descriptor token.\n  errexit z,code=&im_invalid_descriptor_token It is also required.\n  imlta r4,*r1                        | Get address of descriptor.\n  errexit nz,or,(treg,r4,z),          | Error if invalid or null.      +\n               code=&im_invalid_descriptor_token\n  l16   r1,0(r4)                      | Get address of\n  litda r5,r1                         | ITD for descriptor.\n  using itd,r5                        | Establish base for ITD.\n* *-------------------------------------------------------------------*\n* * Process based on descriptor class.\n* *-------------------------------------------------------------------*\n  lh    r1,itdclass                   | Load class into r1.\n  caseblk reg=r1                      | Process based on class.\n  case &im_class_linked_list_descriptor For linked list:\n   callsub sort_a_list,               |                                +\n               (*prm_sort_descriptor_token,                            +\n               *prm_sort_fieldslist,                                   +\n               *prm_sort_head_token,                                   +\n               *prm_sort_technique)\n  case other                          | If other class of item:\n   errexit code=&im_invalid_descriptor_token  It is an error.\n  endcase                             | Endif.\n* *-------------------------------------------------------------------*\n endblk block=sort_function           |\n   eject                              |\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Store_Function\n*  Abstract:   This subroutine processes the store function.\n*\n*---------------------------------------------------------------------*\n block type=subroutine,name=store_function,                            +\n               parmmap=prm_function_dependent\n* *-------------------------------------------------------------------*\n* * Make sure that this is an unclassified item.\n* *-------------------------------------------------------------------*\n  l32   r2,prm_store_item_address     | Point r1 item.\n  errexit z,code=&im_missing_parameter  Error if missing.\n  l16   r1,0(r2)                      | Load r1 with item type token.\n  litda r4,r1                         | Point r4 to item type desc.\n  using itd,r4                        | Establish base for ITD.\n  l     r6,pwa_imc_address            | Load pointer to IMC.\n  using imc,r6                        | Establish base for IMC.\n  errexit      (clc,itditype,ne,imctditd+2),and, Error if this is not  +\n               (clc,itditype,ne,imctditdx+2),or, a valid unclassified  +\n               (clc,itdclass,ne,=y(&im_class_unclassified)), ITD.      +\n               code=&im_invalid_item_type\n  drop  r6                            | Drop base for IMC.\n  drop  r4                            | Drop base for ITD.\n* *-------------------------------------------------------------------*\n* * Store the item and return its token.\n* *-------------------------------------------------------------------*\n  l     r1,prm_store_item_address     | Point to item.\n  callsub store_item                  | Store the item.\n  st    r0,&w.token                   | Save token.\n  l32   r1,prm_store_item_token       | Point r1 token storage.\n  if nz                               | If token should be returned:\n   st    r0,0(,r1)                    |  Save token in return area.\n  endif                               | Endif.\n* *-------------------------------------------------------------------*\n* * Make the item current-of-item-manager and current-of-item-type.\n* *-------------------------------------------------------------------*\n  callsub make_current,(&w.token,)    |\n* *-------------------------------------------------------------------*\n endblk block=store_function          |\n   space 2                            |\n         swa  ,                       |\n&w.token ds   f                       |\n         endswa ,                     |\n   eject                              |\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Erase_Function\n*  Abstract:   This subroutine processes the erase function.\n*\n*---------------------------------------------------------------------*\n block type=subroutine,name=erase_function,                            +\n               parmmap=prm_function_dependent\n* *-------------------------------------------------------------------*\n* * Make sure that this is an unclassified item.\n* *-------------------------------------------------------------------*\n  l32   r1,prm_erase_item_token       | Point r1 item token.\n  errexit z,code=&im_missing_parameter  Error if missing.\n  imlta r5,*r1                        | Point r5 to item.\n  errexit nz,or,(treg,r5,z),          | Error if invalid or null.      +\n               code=&im_invalid_item_type\n  l16   r1,0(r5)                      | Load r1 with item type token.\n  litda r4,r1                         | Point r4 to item type desc.\n  using itd,r4                        | Establish base for ITD.\n  l     r6,pwa_imc_address            | Load pointer to IMC.\n  using imc,r6                        | Establish base for IMC.\n  errexit      (clc,itditype,ne,imctditd+2),and, Error if this is not  +\n               (clc,itditype,ne,imctditdx+2),or, a valid ITD.          +\n               (clc,itdclass,ne,=y(&im_class_unclassified)),           +\n               code=&im_invalid_item_type\n  drop  r6                            | Drop base for IMC.\n  drop  r4                            | Drop base for ITD.\n* *-------------------------------------------------------------------*\n* * Erase the item.\n* *-------------------------------------------------------------------*\n  l     r0,prm_erase_item_token       | Load item token in r0.\n  callsub erase_item,                 | Erase the item.                +\n               (*prm_erase_item_token)\n* *-------------------------------------------------------------------*\n endblk block=erase_function          |\n    eject                             |\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Make a DSC.\n*  Abstract:   This subroutine store an item in the group associated\n*              with its ITD.\n*  Input:      r1 - Address of a one byte length of text followed\n*                   by the text of the description.\n*  Output:     r0 - Token of description.\n*\n*---------------------------------------------------------------------*\n block name=make_a_dsc,type=subroutine,options=noparms\n* *-------------------------------------------------------------------*\n* * Build a DSC.\n* *-------------------------------------------------------------------*\n  fill  &w.build_area,x'00'           | Clear the build area.\n  l     r4,pwa_imc_address            | Point r4 to IMC.\n  using imc,r4                        | Establish base for IMC.\n  la    r2,&w.build_area              | Point r2 to build area.\n  using dsc,r2                        | Establish base for build area.\n  mvc   dscitype,imctddsc+2           | Move type token to DSC.\n  l8    r3,0(r1)                      | Load length of text.\n  errexit (ch,r3,gt,=h'250'),         | Error if desc is too long.     +\n               code=&im_description_too_long\n  bctr  r3,0                          | Sub 1 for EX.\n  exi   r3,(mvc,dsctext(*-*),1(r1))   | Move text to description.\n  ah    r3,=y(l'dscitype+l'dscsize+1) | Calculate total size of DSC\n  stc   r3,dscsize                    | and store that in DSC.\n* *-------------------------------------------------------------------*\n* * Store the DSC and return its token.\n* *-------------------------------------------------------------------*\n  la    r1,&w.build_area              | Point to build area.\n  callsub store_item                  | Store item.\n  strsa r0                            | Return to caller.\n* *-------------------------------------------------------------------*\n endblk block=make_a_dsc              |\n         swa ,                        |\n&w.build_area                ds xl256 |\n         endswa ,                     |\n eject                                |\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Store item.\n*  Abstract:   This subroutine store an item in the group associated\n*              with its ITD.\n*  Input:      r1 - Address of item.\n*  Output:     r0 - Token of item.\n*\n*---------------------------------------------------------------------*\n block name=store_item,type=subroutine,options=noparms\n* *-------------------------------------------------------------------*\n* * Establish base for parameter list.\n* *-------------------------------------------------------------------*\n  lr    r3,r1                         | Point r3 to item.\n  st    r3,&w.item                    | Save address of item.\n* *-------------------------------------------------------------------*\n* * Get characteristics of item and validate it.\n* *-------------------------------------------------------------------*\n  callsub get_characteristics_and_validate, Validate.                  +\n               (*&w.item,\"Y\",         |                                +\n               &w.grd_token,          |                                +\n               &w.size,,)             |\n* *-------------------------------------------------------------------*\n* * Obtain storage for the item.\n* *-------------------------------------------------------------------*\n  callsub obtain_item_storage,        | Get storage for item.          +\n               (&w.grd_token,         |                                +\n               &w.size,               |                                +\n               &w.item_token,         |                                +\n               &w.item_address)       |\n* *-------------------------------------------------------------------*\n* * Increment the number of items of this item type.\n* *-------------------------------------------------------------------*\n  l16   r1,0(r3)                      | Load item type token.\n  litda r4,r1                         | Get its address.\n  using itd,r4                        | Establish base for ITD.\n  l     r1,itdnumit                   | Increment the number\n  ah    r1,=h'1'                      | of items of\n  st    r1,itdnumit                   | this type.\n  drop  r4                            | Drop bae for ITD.\n* *-------------------------------------------------------------------*\n* * Move item to item storage.\n* *-------------------------------------------------------------------*\n  l     r15,&w.size                   | Load size of item.\n  l     r6,&w.item_address            | Point r6 to new item storage.\n  l     r2,&w.item                    | Point r2 to new item.\n  loop until                          | Move item to item storage.\n   ltr   r1,r15                       |  Load r1 with remaining\n   leave np,loop=*                    |  move length.  Finished if\n*                                     |  length is not positive.\n   if (ch,r1,gt,=h'256')              |  Can only move\n    la    r1,256                      |  up to 256 bytes\n   endif                              |  at a time.\n   sr    r15,r1                       |  Calc new remaining length.\n   bctr  r1,0                         |  Move up to 256\n   exi   r1,(mvc,0(*-*,r6),0(r2))     |  bytes of item.\n   la    r2,256(,r2)                  |  Point to next 256 bytes\n   la    r6,256(,r6)                  |  of item.\n  endloop until,leave                 | Endloop.\n* *-------------------------------------------------------------------*\n* * Return the token in r0.\n* *-------------------------------------------------------------------*\n  l     r0,&w.item_token              | Load token.\n  strsa r0                            | Return it in r0.\n* *-------------------------------------------------------------------*\n endblk block=store_item              |\n         swa ,                        |\n&w.item                      ds a     |\n&w.size                      ds f     |\n&w.grd_token                 ds f     |\n&w.item_token                ds f     |\n&w.item_address              ds f     |\n&w.item_type_token           ds f     |\n         endswa ,                     |\n eject                                |\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Erase item.\n*  Abstract:   This subroutine will free the storage associated with\n*              an item and decrement the count of item of this type.\n*  Parameters: (>item_token)\n*\n*---------------------------------------------------------------------*\n block name=erase_item,type=subroutine,parms=(token)\n* *-------------------------------------------------------------------*\n* * Get address of item.\n* *-------------------------------------------------------------------*\n  imlta r4,*&p.token                  | Get address of item.\n  errexit nz,or,(treg,r4,z),          | Error if invalid or null.      +\n               code=&im_invalid_token |\n  st    r4,&w.item_address            | Save address of item.\n* *-------------------------------------------------------------------*\n* * Get a pointer to the ITD for the item.\n* *-------------------------------------------------------------------*\n  l16   r1,0(r4)                      | Load ITD token in r1.\n  litda r5,r1                         | Convert to an address.\n  using itd,r5                        | Establish base for ITD.\n* *-------------------------------------------------------------------*\n* * Establish base for IMC.\n* *-------------------------------------------------------------------*\n  l     r6,pwa_imc_address            | Load IMC address.\n  using imc,r6                        | Establish base for IMC.\n* *-------------------------------------------------------------------*\n* * If this is an extend ITD, get the length the hard way.\n* *-------------------------------------------------------------------*\n  if (tbit,itdf1ext)                  | If this is an extended ITD:\n   errexit (clc,itditype,ne,imctditdx+2), Fuss if ITD's type is not    +\n               code=&im_invalid_item  |  what it should be.\n   if (tbit,itdf1lni,off)             |  If length is not in item:\n    l32   r0,itdxiln                  |   Get length from ITD.\n    st    r0,&w.size                  |   Save length in work area.\n   else                               |  If length is in item:\n    l32   r6,itdxilnof                |   Load r6 with length offset.\n    errexit z,code=&im_internal_error |   Error if it is zero.\n    alr   r6,r4                       |   Point r6 to length in item.\n    l32   r1,itdxilnsz                |   Load length size from ITD.\n    errexit np,or,(ch,r1,gt,=y(4)),   |   Error if size is not between +\n               code=&im_internal_error    1 and 4.\n    fill  &w.size,x'00'               |   Clear size in work area.\n    la    r2,&w.size+4                |   Move the length, left\n    sr    r2,r1                       |   justified, in the size\n    bctr  r1,0                        |   field in the\n    exi   r1,(mvc,0(*-*,r2),0(r6))    |   work area.\n   endif                              |  Endif.\n* *-------------------------------------------------------------------*\n* * If this is a normal ITD, get the length the easy way.\n* *-------------------------------------------------------------------*\n  else                                |  If not an extended ITD.\n   errexit (clc,itditype,ne,imctditd+2),  Error if ITD item type is    +\n               code=&im_invalid_item  |   not valid.\n   l8    r0,itdiln                    |   Move length to\n   st    r0,&w.size                   |   field in work area.\n  endif                               |  Endif.\n* *-------------------------------------------------------------------*\n* * Free storage associated with item.\n* *-------------------------------------------------------------------*\n  mvc   &w.grd_token,itdgrd           | Get GRD token.\n  callsub free_item_storage,          | Get storage for item.          +\n               (&w.grd_token,         |                                +\n               &w.size,               |                                +\n               *&p.token,             |                                +\n               &w.item_address)       |\n* *-------------------------------------------------------------------*\n* * Decrement the number of items of this item type.\n* *-------------------------------------------------------------------*\n  l     r1,itdnumit                   | Decrement the number\n  sh    r1,=h'1'                      | of items of\n  st    r1,itdnumit                   | this type.\n* *-------------------------------------------------------------------*\n endblk block=erase_item              |\n         swa ,                        |\n&w.size                      ds f     |\n&w.grd_token                 ds f     |\n&w.item_address              ds a     |\n         endswa ,                     |\n eject                                |\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Get_characteristics_and_validate\n*  Abstract:   This subroutine will make check to help insure that\n*              the a item is valid.  It will also turn the size,\n*              number of links, and offset of links if the parameter\n*              are present.\n*  Parameters: (>item,>extensive,<size|,<number_links|,\n*               <offset_of_links|)\n*\n*---------------------------------------------------------------------*\n block name=get_characteristics_and_validate,type=subroutine,          +\n               parms=(item,option,grd,item_size,number_of_links,       +\n               links_offset)          |\n* *-------------------------------------------------------------------*\n* * Use r4 as ITD base and r5 as IMC base.\n* *-------------------------------------------------------------------*\n  l32   r2,&p.item                    |\n  errexit z,code=&im_invalid_item     |\n  l16   r1,0(r2)                      |\n  litda r4,r1                         |\n  using itd,r4                        |\n  l     r5,pwa_imc_address            |\n  using imc,r5                        |\n* *-------------------------------------------------------------------*\n* * If this is an extend ITD, get the length, number of link, and\n* * offset the hard way.\n* *-------------------------------------------------------------------*\n  if (tbit,itdf1ext)                  |\n   errexit (clc,itditype,ne,imctditdx+2),                              +\n               code=&im_invalid_item  |\n*  *------------------------------------------------------------------*\n*  * Get item size.\n*  *------------------------------------------------------------------*\n   if (tbit,itdf1lni,off)             |\n    l32   r0,itdxiln                  |\n   else                               |\n    l32   r1,itdxilnof                |\n    errexit z,code=&im_internal_error |\n    slr   r0,r0                       |\n    al    r1,&p.item                  |\n    l8    r2,itdxilnsz                |\n    caseblk reg=r2                    |\n    case 1                            |\n     ic   r0,0(,r1)                   |\n    case 2                            |\n     icm  r0,b'0011',0(r1)            |\n    case 3                            |\n     icm  r0,b'0111',0(r1)            |\n    case 4                            |\n     l    r0,0(r1)                    |\n    case other                        |\n     errexit code=&im_internal_error  |\n    endcase                           |\n   endif                              |\n   st    r0,&w.item_size              |\n*  *------------------------------------------------------------------*\n*  * Get number of links.\n*  *------------------------------------------------------------------*\n   if (tbit,itdf1nli,off)             |\n    l32   r0,itdxinl                  |\n   else                               |\n    l32   r1,itdxinlof                |\n    errexit z,code=&im_internal_error |\n    al    r1,&p.item                  |\n    l8    r2,itdxinlsz                |\n    slr   r0,r0                       |\n    caseblk reg=r2                    |\n    case 1                            |\n     ic   r0,0(,r1)                   |\n    case 2                            |\n     icm  r0,b'0011',0(r1)            |\n    case 3                            |\n     icm  r0,b'0111',0(r1)            |\n    case 4                            |\n     l    r0,0(r1)                    |\n    case other                        |\n     errexit code=&im_internal_error  |\n    endcase                           |\n   endif                              |\n   st    r0,&w.number_of_links        |\n*  *------------------------------------------------------------------*\n*  * Get links offset.\n*  *------------------------------------------------------------------*\n   if (tbit,itdf1loi,off)             |\n    l32   r0,itdxilo                  |\n   else                               |\n    l32   r1,itdxiloof                |\n    errexit z,code=&im_internal_error |\n    al    r1,&p.item                  |\n    l8    r2,itdxilosz                |\n    slr   r0,r0                       |\n    caseblk reg=r2                    |\n    case 1                            |\n     ic   r0,0(,r1)                   |\n    case 2                            |\n     icm  r0,b'0011',0(r1)            |\n    case 3                            |\n     icm  r0,b'0111',0(r1)            |\n    case 4                            |\n     l    r0,0(,r1)                   |\n    case other                        |\n     errexit code=&im_internal_error  |\n    endcase                           |\n   endif                              |\n   st    r0,&w.links_offset           |\n* *-------------------------------------------------------------------*\n* * If this is a normal ITD, get the length, number of link, and\n* * offset the easy way.\n* *-------------------------------------------------------------------*\n  else                                |\n   errexit (clc,itditype,ne,imctditd+2),                               +\n               code=&im_invalid_item  |\n   l8    r0,itdiln                    |\n   st    r0,&w.item_size              |\n   l8    r0,itdilo                    |\n   st    r0,&w.links_offset           |\n   l8    r0,itdinl                    |\n   st    r0,&w.number_of_links        |\n  endif                               |\n* *-------------------------------------------------------------------*\n* * Return whatever was asked for.\n* *-------------------------------------------------------------------*\n  l32   r1,&p.grd                     | Load pointer to return area.\n  if nz                               | If specified:\n   mvc   0(l'itdgrd,r1),itdgrd        |  Return the valid.\n  endif                               | Endif.\n  l32   r1,&p.item_size               | Load pointer to return area.\n  if nz                               | If specified:\n   mvc   0(4,r1),&w.item_size         |  Return the value.\n  endif                               | Endif.\n  l32   r1,&p.number_of_links         | Load pointer to return area.\n  if nz                               | If specified:\n   mvc   0(4,r1),&w.number_of_links   | Return the value.\n  endif                               | Endif.\n  l32   r1,&p.links_offset            | Load pointer to return area.\n  if nz                               | If specified:\n   mvc   0(4,r1),&w.links_offset      |  Return the value.\n  endif                               | Endif.\n* *-------------------------------------------------------------------*\n* check links and length, etc.        |\n endblk block=get_characteristics_and_validate\n         swa                          |\n&w.item_size                    ds f  |\n&w.number_of_links              ds f  |\n&w.links_offset                 ds f  |\n         endswa                       |\n eject                                |\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Get_ITC\n*  Abstract:   This subroutine fills in the ITC for an item in\n*              item managed storage.  Before calling this routine,\n*              ITC_token should contain the token of the item to\n*              return.\n*  Parameters: R1->ITC\n*\n*---------------------------------------------------------------------*\n block name=get_ITC,type=subroutine,  |                                +\n               options=noparms        |\n* *-------------------------------------------------------------------*\n* * Establish base for ITC and get address of item.  R3 will be\n* * used as base for the ITC and r6 will be used as base for the item.\n* * Clear ITC flag.\n* *-------------------------------------------------------------------*\n  lr    r3,r1                         | Point r3 to ITC.\n  using itc_,r3                       | Establish base for ITC.\n  imlta r6,itc_token                  | Point r6 to item.\n  errexit nz,or,(treg,r6,z),code=&im_invalid_token\n  st    r6,itc_address                | Save pointer to item.\n* mvc   itc_f,0                       | Clear flags.                @C1\n  mvi   itc_f,0                       | Clear flags.                @C1\n* *-------------------------------------------------------------------*\n* * Use r4 as ITD base and r5 as IMC base.\n* *-------------------------------------------------------------------*\n  l16   r1,0(r6)                      | Load item type into r1.\n  sth   r1,itc_itype                  | Save it in ITC.\n  litda r4,r1                         | Get address of ITD.\n  using itd,r4                        | Establish base for ITD.\n  st    r4,itc_itd_address            | Save ITD address.\n  l     r5,pwa_imc_address            | Point r5 to IMC\n  using imc,r5                        | and establish base.\n* *-------------------------------------------------------------------*\n* * If this is an extend ITD, get the length, number of link, and\n* * offset the hard way.\n* *-------------------------------------------------------------------*\n  if (tbit,itdf1ext)                  | If extended ITC:\n   errexit (clc,itditype,ne,imctditdx+2),                              +\n               code=&im_invalid_item  |\n*  *------------------------------------------------------------------*\n*  * Get item size.\n*  *------------------------------------------------------------------*\n   if (tbit,itdf1lni,off)             |  If length not in item:\n    l32   r0,itdxiln                  |   Use fixed lenght in ITD.\n   else                               |  Else:\n    sbit  itc_f_variable_size         |   Variable item size.\n    l32   r1,itdxilnof                |   Load offset of length.\n    errexit z,code=&im_internal_error |   Error if zero.\n    slr   r0,r0                       |   Clear result register.\n    al    r1,itc_address              |   Calculate address of length.\n    l8    r2,itdxilnsz                |   Load r2 with size of length.\n    caseblk reg=r2                    |   Process based on size.\n    case 1                            |   One byte:\n     ic   r0,0(,r1)                   |    Load one byte length.\n    case 2                            |   Two bytes:\n     icm  r0,b'0011',0(r1)            |    Load two byte length.\n    case 3                            |   Three bytes:\n     icm  r0,b'0111',0(r1)            |    Load three byte length.\n    case 4                            |   Four bytes:\n     l    r0,0(r1)                    |    Load four byte length.\n    case other                        |   Other size:\n     errexit code=&im_internal_error  |    This is bad news.\n    endcase                           |   Endcase.\n   endif                              |  Endif.\n   st    r0,itc_size                  |  Save size in ITC.\n*  *------------------------------------------------------------------*\n*  * Get number of links.\n*  *------------------------------------------------------------------*\n   if (tbit,itdf1nli,off)             |  If # links not in item:\n    l32   r0,itdxinl                  |   Use fixed # links from ITD.\n   else                               |  Else:\n    sbit  itc_f_variable_number_links |   Variable links offset.\n    l32   r1,itdxinlof                |   Load offset of # links.\n    errexit z,code=&im_internal_error |   Error if zero.\n    slr   r0,r0                       |   Clear result register.\n    al    r1,itc_address              |   Calculate address of # links.\n    l8    r2,itdxinlsz                |   Load size of # links field.\n    caseblk reg=r2                    |   Process based on size.\n    case 1                            |   One byte:\n     ic   r0,0(,r1)                   |    Load one byte # links.\n    case 2                            |   Two bytes:\n     icm  r0,b'0011',0(r1)            |    Load two byte # links.\n    case 3                            |   Three bytes:\n     icm  r0,b'0111',0(r1)            |    Load three byte # links.\n    case 4                            |   Four bytes:\n     l    r0,0(r1)                    |    Load four byte # links.\n    case other                        |   Other size:\n     errexit code=&im_internal_error  |    This is bad news.\n    endcase                           |   Endcase.\n   endif                              |  Endif.\n   st    r0,itc_number_links          |  Save # links in ITC.\n*  *------------------------------------------------------------------*\n*  * Get links offset.\n*  *------------------------------------------------------------------*\n   if (tbit,itdf1loi,off)             |  If links offset not in item:\n    l32   r0,itdxilo                  |   Use fixed offset from ITD.\n   else                               |  Else:\n    sbit  itc_f_variable_links_offset |   Variable links offset.\n    l32   r1,itdxiloof                |   Load offset of offset.\n    errexit z,code=&im_internal_error |   Error if zero.\n    slr   r0,r0                       |   Clear result register.\n    al    r1,itc_address              |   Calculate address if offset.\n    l8    r2,itdxilosz                |   Load r2 with size of offset.\n    caseblk reg=r2                    |   Process based on size.\n    case 1                            |   One byte:\n     ic   r0,0(,r1)                   |    Load one byte offset.\n    case 2                            |   Two bytes:\n     icm  r0,b'0011',0(r1)            |    Load two byte offset.\n    case 3                            |   Three bytes:\n     icm  r0,b'0111',0(r1)            |    Load three byte offset.\n    case 4                            |   Four bytes:\n     l    r0,0(,r1)                   |    Load four byte offset.\n    case other                        |   Other size:\n     errexit code=&im_internal_error  |    This is bad news.\n    endcase                           |   Endcase.\n   endif                              |  Endif.\n   st    r0,itc_offset_links          |  Save offset in ITC.\n* *-------------------------------------------------------------------*\n* * If this is a normal ITD, get the length, number of links, and\n* * offset the easy way.\n* *-------------------------------------------------------------------*\n  else                                | Else:\n   errexit (clc,itditype,ne,imctditd+2), Error if not valid ITD.       +\n               code=&im_invalid_item  |\n   l8    r0,itdiln                    |  Store fixed\n   st    r0,itc_size                  |  item size.\n   l8    r0,itdilo                    |  Store fixed\n   st    r0,itc_offset_links          |  links offset.\n   l8    r0,itdinl                    |  Store fixed\n   st    r0,itc_number_links          |  number of links.\n  endif                               | Endif.\n endblk block=get_ITC                 |\n eject                                |\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Connect_to_list\n*  Abstract:   This subroutine copys an item from item managed\n*              storage to a return area that is not in item managed\n*              storage.\n*  Parameters: (>item_token,>descriptor_token)\n*\n*---------------------------------------------------------------------*\n block name=connect_to_list,type=subroutine,                           +\n               parms=(item_token,descriptor_token,head_token)\n* *-------------------------------------------------------------------*\n* *  Get item characteristics.\n* *-------------------------------------------------------------------*\n  l     r1,&p.item_token              | Move item token\n  mvc   &w.itc_token,0(r1)            | to work area.\n  la    r1,&w.itc_                    | Get item\n  callsub get_itc                     | characteristics.\n* *-------------------------------------------------------------------*\n* *  Get base for descriptor.\n* *-------------------------------------------------------------------*\n  imlta r4,*&p.descriptor_token       |\n  errexit nz,or,(treg,r4,z),code=&im_invalid_descriptor_token\n  using lld,r4                        |\n* *-------------------------------------------------------------------*\n* *  Get address of list heads.\n* *-------------------------------------------------------------------*\n  if (tbit,lldophid)                  | If heads in descriptor:\n   la    r0,lldfrlst                  |  Use first pointer\n   st    r0,&w.first_ptr_addr         |  in LLD.\n   la    r0,lldfnlst                  |  Use final pointer\n   st    r0,&w.final_ptr_addr         |  in LLD.\n   errexit (%l32,r1,&p.head_token,nz),and,(clc,0(r1),ne,=f'0'),        +\n               code=&im_head_not_valid_for_this_descriptor\n  else                                | Else:\n   if (%l32,r1,&p.head_token,nz),and, |  If head token supplied        +\n               (%l32,r1,0(r1),nz)     |  by caller:\n    st    r1,&w.itc_heads_token       |   Use it.\n   else                               |  Else:\n    callsub find_current,(lldhditd,&w.itc_heads_token) Find item\n    errexit (treg,r15,nz),code=&im_currency_error      that has heads.\n    errexit nz,code=&im_internal_error\n   endif                              |  Endif.\n   la    r1,&w.itc_heads_             |               Get ITC\n   callsub get_itc                    |               for item.\n   imlla &w.first_ptr_addr,lldfrlk#,&w.itc_heads_     Get links\n   imlla &w.final_ptr_addr,lldfnlk#,&w.itc_heads_     from item.\n  endif                               | Endif.\n* *-------------------------------------------------------------------*\n* *  Get addresses of links in item.\n* *-------------------------------------------------------------------*\n  imlla r1,lldnxlk#,&w.itc_           | Point r1 to next link.\n  st    r1,&w.next_ptr_addr           | Save it.\n  ltr   r6,r1                         | Put it in r6.\n  errexit z,code=&im_internal_error   | Error if no next link.\n  errexit (clc,=f'0',ne,0(r6)),code=&im_link_not_null       Must be 0.\n  imlla r1,lldprlk#,&w.itc_           | Point r1 to prior link.\n  st    r1,&w.prior_ptr_addr          | Save it.\n  ltr   r6,r1                         | Point r6 to link.\n  errexit nz,and,(clc,=f'0',ne,0(r6)),code=&im_link_not_null Must be 0.\n  imlla r1,lldowlk#,&w.itc_           | Point r1 to owner link.\n  st    r1,&w.owner_ptr_addr          | Save it.\n  ltr   r6,r1                         | Point r6 to link.\n  errexit nz,and,(clc,=f'0',ne,0(r6)),code=&im_link_not_null Must be 0.\n* *-------------------------------------------------------------------*\n* *  Connect items based on list order.\n* *-------------------------------------------------------------------*\n  ic    r1,lldop                      | Load list\n  n     r1,=a(lldopord)               | order.\n  caseblk reg=r1                      | Process based on order.\n* *-------------------------------------------------------------------*\n* *  Connect order: first.\n* *-------------------------------------------------------------------*\n  case 0 (first)                      | Insert at start of list.\n   l32   r6,&w.first_ptr_addr         |  Point r6 to first pointer.\n   errexit z,code=&im_internal_error  |  Error if there is not one.\n   if (clc,=f'0',eq,0(r6))            |  If list is empty:\n    mvc   0(4,r6),&w.itc_token        |   Move token to first ptr.\n    l32   r6,&w.final_ptr_addr        |   If there is a\n    if nz                             |    final link:\n     mvc   0(4,r6),&w.itc_token       |    Move token to final ptr.\n    endif                             |   Endif.\n   else                               |  Else if entries in list:\n    l32   r5,&w.next_ptr_addr         |   Point to next ptr in item.\n    errexit z,code=&im_internal_error |   Error if there is not one.\n    mvc   0(4,r5),0(r6)               |   Next link <- old first link.\n    mvc   0(4,r6),&w.itc_token        |   First link <- new item token.\n    if (clc,=f'0',ne,lldprlk#)        |   If there are prior links:\n     mvc   &w.itc_wrk_token,0(r5)     |    Get ITC\n     la    r1,&w.itc_wrk_             |    for old first\n     callsub get_itc                  |    item in list.\n     imlla r5,lldprlk#,&w.itc_wrk_    |    Move new item token to\n     mvc   0(4,r5),&w.itc_token       |    prior link in old first.\n    endif                             |   Endif.\n   endif                              |  Endif.\n   l32   r6,&w.owner_ptr_addr         |  Point r6 to owner pointer.\n   if nz,and,not,(tbit,lldophid)      |  If there is one and heads\n    mvc   0(4,r6),&w.itc_heads_token  |  are not in the descriptor,\n   endif                              |  move heads token to item.\n* *-------------------------------------------------------------------*\n* *  Connect order: final.\n* *-------------------------------------------------------------------*\n  case 1 (final)                      |\n   l32   r6,&w.final_ptr_addr         |  Point r6 to final pointer.\n   errexit z,code=&im_requires_final_link Error if there is not one.\n   if (clc,=f'0',eq,0(r6))            |  If list is empty:\n    mvc   0(4,r6),&w.itc_token        |   Move token to final ptr.\n    l32   r6,&w.first_ptr_addr        |   Load first pointer.\n    errexit z,code=&im_internal_error |   Error if missing.\n    mvc   0(4,r6),&w.itc_token        |   Move token to first ptr.\n   else                               |  Else if entries in list:\n    mvc   &w.itc_wrk_token,0(r6)      |   Save old final token.\n    l32   r5,&w.prior_ptr_addr        |   Point to prior ptr in item.\n    if nz                             |   If prior link exists:\n     mvc   0(4,r5),0(r6)              |    Prior link <- old final lnk.\n    endif                             |   Endif.\n    mvc   0(4,r6),&w.itc_token        |   Final link <- new item token.\n    la    r1,&w.itc_wrk_              |   Get ITC for old final\n    callsub get_itc                   |   item in list.\n    imlla r5,lldnxlk#,&w.itc_wrk_     |   Move new item token to\n    mvc   0(4,r5),&w.itc_token        |   next link in old final.\n   endif                              |  Endif.\n   l32   r6,&w.owner_ptr_addr         |  Point r6 to owner pointer.\n   if nz,and,not,(tbit,lldophid)      |  If there is one and heads\n    mvc   0(4,r6),&w.itc_heads_token  |  are not in the descriptor,\n   endif                              |  move heads token to item.\n* *-------------------------------------------------------------------*\n* *  Connect order: next.\n* *-------------------------------------------------------------------*\n  case 2 (next)                       | Insert next in list.\n   errexit code=&im_not_yet_supported |\n* *-------------------------------------------------------------------*\n* *  Connect order: prior.\n* *-------------------------------------------------------------------*\n  case 3 (prior)                      | Insert prior in list.\n   errexit code=&im_not_yet_supported |\n* *-------------------------------------------------------------------*\n* *  Connect order: sorted ascending.\n* *-------------------------------------------------------------------*\n  case 4 (sorted ascending)           | Insert sorted in list.\n   errexit code=&im_not_yet_supported |\n* *-------------------------------------------------------------------*\n* *  Connect order: sorted descending.\n* *-------------------------------------------------------------------*\n  case 5 (sorted descending)          | Insert sorted in list.\n   errexit code=&im_not_yet_supported |\n* *-------------------------------------------------------------------*\n* *  Woops!\n* *-------------------------------------------------------------------*\n  case  other                         |\n   errexit code=&im_internal_error    |\n  endcase                             |\n* *-------------------------------------------------------------------*\n endblk block=connect_to_list         |\n         swa ,                        |\n&w.first_ptr_addr ds a                |\n&w.final_ptr_addr ds a                |\n&w.next_ptr_addr  ds a                |\n&w.prior_ptr_addr ds a                |\n&w.owner_ptr_addr ds a                |\n         itc id=&w.itc_               |\n         itc id=&w.itc_heads_         |\n         itc id=&w.itc_wrk_           |\n         endswa                       |\n eject                                |\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Connect_to_hash_table\n*  Abstract:   This subroutine copys an item from item managed\n*              storage to a return area that is not in item managed\n*              storage.\n*  Parameters: (>item_token,>descriptor_token)\n*\n*---------------------------------------------------------------------*\n block name=connect_to_hash_table,type=subroutine,                     +\n               parms=(item_token,descriptor_token)\n* *-------------------------------------------------------------------*\n* *  Get item characteristics.\n* *-------------------------------------------------------------------*\n  l     r1,&p.item_token              | Move item token\n  mvc   &w.itc_token,0(r1)            | to work area.\n  la    r1,&w.itc_                    | Get item\n  callsub get_itc                     | characteristics.\n* *-------------------------------------------------------------------*\n* *  Get base for descriptor.\n* *-------------------------------------------------------------------*\n  imlta r4,*&p.descriptor_token       |\n  errexit nz,or,(treg,r4,z),code=&im_invalid_descriptor_token\n  using htd,r4                        |\n* *-------------------------------------------------------------------*\n* * Get hash info.\n* *-------------------------------------------------------------------*\n  callsub get_hash_info,              |                                +\n               (&w.itc_,htd,          |                                +\n               &w.link_address)       |\n* *-------------------------------------------------------------------*\n* * >>>> Need to add code to check for duplicates.\n* *-------------------------------------------------------------------*\n* *-------------------------------------------------------------------*\n* * Link item to table.\n* *-------------------------------------------------------------------*\n  l     r5,&w.link_address            | Point r5 to link in hash table.\n  imlla r6,htdsylk#,&w.itc_           | Point r6 to synonym link.\n  mvc   0(4,r6),0(r5)                 | Place item in front\n  mvc   0(4,r5),&w.itc_token          | of synonym chain.\n* *-------------------------------------------------------------------*\n endblk block=connect_to_hash_table   |\n         swa ,                        |\n&w.link_address   ds a                |\n         itc id=&w.itc_               |\n         endswa                       |\n eject                                |\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Disconnect_from_list\n*  Abstract:   This subroutine disconnects an item form a linked\n*              list.\n*  Parameters: (>item_token,>descriptor_token,>head_token,>prev_token)\n*\n*---------------------------------------------------------------------*\n block name=disconnect_from_list,type=subroutine,                      +\n               parms=(item_token,descriptor_token,head_token,          +\n               prv_token)\n* *-------------------------------------------------------------------*\n* *  Get item characteristics.\n* *-------------------------------------------------------------------*\n  l     r1,&p.item_token              | Move item token\n  mvc   &w.itc_token,0(r1)            | to work area.\n  la    r1,&w.itc_                    | Get item\n  callsub get_itc                     | characteristics.\n* *-------------------------------------------------------------------*\n* *  Get base for descriptor.\n* *-------------------------------------------------------------------*\n  imlta r4,*&p.descriptor_token       |\n  errexit nz,or,(treg,r4,z),code=&im_invalid_descriptor_token\n  using lld,r4                        |\n* *-------------------------------------------------------------------*\n* *  Get address of list heads.\n* *-------------------------------------------------------------------*\n  if (tbit,lldophid)                  | If heads in descriptor:\n   la    r0,lldfrlst                  |  Use first pointer\n   st    r0,&w.first_ptr_addr         |  in LLD.\n   la    r0,lldfnlst                  |  Use final pointer\n   st    r0,&w.final_ptr_addr         |  in LLD.\n   errexit (%l32,r1,&p.head_token,nz),and,(clc,0(4,r1),ne,=f'0'),      +\n               code=&im_head_not_valid_for_this_descriptor\n  else                                | Else:\n   if (%l32,r1,&p.head_token,nz),and, |  If head token supplied        +\n               (%l32,r1,0(r1),nz)     |  by caller:\n    st    r1,&w.itc_heads_token       |   Use it.\n   else                               |  Else:\n    callsub find_current,(lldhditd,&w.itc_heads_token) Find item\n    errexit (treg,r15,nz),code=&im_currency_error      that has heads.\n    errexit nz,code=&im_internal_error\n   endif                              |  Endif.\n   la    r1,&w.itc_heads_             |               Get ITC\n   callsub get_itc                    |               for item.\n   imlla &w.first_ptr_addr,lldfrlk#,&w.itc_heads_     Get links\n   imlla &w.final_ptr_addr,lldfnlk#,&w.itc_heads_     from item.\n  endif                               | Endif.\n* *-------------------------------------------------------------------*\n* *  Destroy currency for list.\n* *-------------------------------------------------------------------*\n  callsub current,(*&p.descriptor_token,=f'0')\n* *-------------------------------------------------------------------*\n* *  Get addresses of links in item.\n* *-------------------------------------------------------------------*\n  imlla &w.next_ptr_addr,lldnxlk#,&w.itc_   Get address\n  imlla &w.prior_ptr_addr,lldprlk#,&w.itc_  of links in\n  imlla &w.owner_ptr_addr,lldowlk#,&w.itc_  item.\n* *-------------------------------------------------------------------*\n* *  Load address of first and next links.\n* *-------------------------------------------------------------------*\n  l32   r5,&w.first_ptr_addr          | Point r5 to first link.\n  errexit z,code=&im_internal_error   | Error if there is not one.\n  l32   r6,&w.next_ptr_addr           | Point r6 to next link.\n  errexit z,code=&im_internal_error   | Error if there is not one.\n* *-------------------------------------------------------------------*\n* * Process item at start of list.\n* *-------------------------------------------------------------------*\n  if (clc,&w.itc_token,eq,0(r5))      | If first item of list:\n   errexit (%l32,r1,&p.prv_token,nz),and,                              +\n               (clc,=f'0',ne,0(r1)),  |  Error if PRTKN specified and  +\n               code=&im_prtkn_invalid |  it is not zero.\n   mvc   0(4,r5),0(r6)                |  First link = Next link.\n   if (clc,=f'0',eq,0(r6))            |  If Next link is null:\n    if (%l32,r5,&w.final_ptr_addr,nz) |   If there is a final link:\n     mvc   0(4,r5),0(r6)              |    Final link = Next link.\n    endif                             |   Endif.\n   else                               |  Else if there is a next:\n    if (clc,=f'0',ne,lldprlk#)        |   If there are prior links:\n     mvc   &w.itc_wrk_token,0(r6)     |    Get ITC\n     la    r1,&w.itc_wrk_             |    for next\n     callsub get_itc                  |    item in list.\n     imlla r5,lldprlk#,&w.itc_wrk_    |    Set next's prior link\n     mvc   0(4,r5),=f'0'              |    to null.\n    endif                             |   Endif.\n   endif                              |  Endif.\n* *-------------------------------------------------------------------*\n* * Process item at middle or end of list.\n* *-------------------------------------------------------------------*\n  else                                | Else:\n   if (%l32,r1,&p.prv_token,z)        |  If PRTKN not specified:\n    errexit (clc,=f'0',eq,lldprlk#),  |   Error if there are not       +\n               code=&im_prtkn_required    Prior links.\n    l32   r5,&w.prior_ptr_addr        |   Move prior token\n    errexit z,code=&im_internal_error |   from item to\n    mvc   &w.itc_wrk_token,0(r5)      |   work ITC.\n   else                               |  Else if PRTKN specified:\n    mvc   &w.itc_wrk_token,0(r1)      |   Move PRTKN to work ITC.\n    errexit (%l32,r5,&w.prior_ptr_addr,nz),and,                        +\n               (clc,0(4,r1),ne,0(r5)),    Error if PRTKN specified     +\n               code=&im_prtkn_invalid |   doesn't match prior in item.\n   endif                              |  Endif.\n   la    r1,&w.itc_wrk_               |  Move item's\n   callsub get_itc                    |  next pointer\n   imlla r5,lldnxlk#,&w.itc_wrk_      |  to prior items\n   mvc   0(4,r5),0(r6)                |  next pointer.\n   if (clc,=f'0',eq,0(r6))            |  If at end of list:\n    if (%l32,r5,&w.final_ptr_addr,nz) |   Update final\n     mvc   0(4,r5),&w.itc_wrk_token   |   link if there\n    endif                             |   is one.\n   elseif (clc,=f'0',ne,lldprlk#)     |  Else if there are prior links:\n    l     r5,&w.itc_wrk_token         |   Save prior token in r5.\n    mvc   &w.itc_wrk_token,0(r6)      |   Get ITC\n    la    r1,&w.itc_wrk_              |   for next\n    callsub get_itc                   |   item.\n    imlla r6,lldprlk#,&w.itc_wrk_     |   Store prior token in\n    st    r5,0(,r6)                   |   prior link of next item.\n   endif                              |  Endif.\n  endif                               | Endif.\n* *-------------------------------------------------------------------*\n* * Set links in disconnected item to null.\n* *-------------------------------------------------------------------*\n  if (%l32,r5,&w.next_ptr_addr,nz)    | If there is a next link:\n   xc    0(4,r5),0(r5)                |  Set it to null.\n  endif                               | Endif.\n  if (%l32,r5,&w.prior_ptr_addr,nz)   | If there is a prior link:\n   xc    0(4,r5),0(r5)                |  Set it to null.\n  endif                               | Endif.\n  if (%l32,r5,&w.owner_ptr_addr,nz)   | If there is an owner link:\n   xc    0(4,r5),0(r5)                |  Set it to null.\n  endif                               | Endif.\n* *-------------------------------------------------------------------*\n endblk block=disconnect_from_list    |\n         swa ,                        |\n&w.first_ptr_addr ds a                |\n&w.final_ptr_addr ds a                |\n&w.next_ptr_addr  ds a                |\n&w.prior_ptr_addr ds a                |\n&w.owner_ptr_addr ds a                |\n&w.prior_token    ds f                |\n         itc id=&w.itc_               |\n         itc id=&w.itc_heads_         |\n         itc id=&w.itc_wrk_           |\n         endswa                       |\n         eject\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Find_in_hash_table\n*  Abstract:   This subroutine locates an item by key in a hash table.\n*  Parameters: (>key_length,>key_address,>descriptor_token,<itc)\n*\n*---------------------------------------------------------------------*\n block name=find_in_hash_table,type=subroutine,                        +\n               parms=(key_length,key_address,descriptor_token,itc)\n* *-------------------------------------------------------------------*\n* *  Get bases.\n* *-------------------------------------------------------------------*\n  l     r3,&p.itc                     | Load base for ITC.\n  using itc_,r3                       | Establish addressibility.\n  imlta r4,*&p.descriptor_token       |\n  errexit nz,or,(treg,r4,z),code=&im_invalid_descriptor_token\n  using htd,r4                        |\n* *-------------------------------------------------------------------*\n* * Get hash info and calculate address of link field.\n* *-------------------------------------------------------------------*\n  l     r15,htd#lnks                  | Calculate\n  sh    r15,=y(htdtable_link_#)       | number of entries\n  st    r15,&w.entries                | in hash table.\n  callsub calc_hash_key,              | Calculate hash key.            +\n               (*&p.key_address,      |                                +\n               *&p.key_length,        |                                +\n               &w.entries,            |                                +\n               &w.hash_key)           |\n  l     r5,&w.hash_key                | Calculate\n  sla   r5,2                          | address of\n  la    r5,htdtable(r5)               | link in hash table.\n  errexit (clc,=f'0',eq,0(r5)),       | Not found if link              +\n               code=&im_not_found     | is zero.\n  mvc   &w.kpm_first_token,0(r5)      | Save first link token.\n* *-------------------------------------------------------------------*\n* * Search for item in synonym chain with key matching search key.\n* *-------------------------------------------------------------------*\n  mvc   &w.kpm_search_key_address,&p.key_address\n  errexit code=&im_key_length_parm_error,                              +\n               (%l32,r1,&p.key_length,z),or,                           +\n               (%l32,r1,0(r1),z),or,  | Key length is required and     +\n               (ch,r1,gt,=h'255')     | must not exceed 255 bytes.\n  stc   r1,&w.kpm_search_key_length   | Save key in KPM.\n  if (tbit,htdf1ksi)                  | If key length in item:\n   mvi   &w.kpm_key_length,0          |    Set the offset.\n   mvc   &w.kpm_key_length_offset,htdkszof\n  else                                | Else:\n   fill  &w.kpm_key_length_offset,x'00'    Set key length.\n   mvc   &w.kpm_key_length,htdksz+3   |\n  endif                               | Endif.\n  mvc   &w.kpm_key_offset,htdkof      | Set offset. (may be zero)\n  mvc   &w.kpm_link_number,htdsylk#   | Move link number from IMMS.\n  callsub find_by_key,(&w.kpm_,itc_)  | Find item.\n  errexit (treg,r15,nz),code=&im_not_found Error if not found.\n* *-------------------------------------------------------------------*\n endblk block=find_in_hash_table      |\n         swa ,                        |\n&w.entries        ds f                |\n&w.hash_key       ds f                |\n&w.token          ds f                |\n&w.link_number    ds f                |\n         kpm id=&w.kpm_               |\n         endswa                       |\n eject                                |\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Find_by_key.\n*  Abstract:   This subroutine locates an item by key.\n*  Parameters: (>kpm,<itc)\n*\n*---------------------------------------------------------------------*\n block name=find_by_key,type=subroutine,                               +\n               parms=(kpm,itc)        |\n* *-------------------------------------------------------------------*\n* * Establish base for key parm.\n* *-------------------------------------------------------------------*\n  l     r2,&p.itc                     | Establish base\n  using itc_,r2                       | for ITC.\n  l     r3,&p.kpm                     | Establish base\n  using kpm_,r3                       | for KPM.\n  fill  itc_storage,x'00'             | Clear ITC.\n* *-------------------------------------------------------------------*\n* * Move key to work area and reduce size by number of trailing\n* * blanks.\n* *-------------------------------------------------------------------*\n  fill  &w.key_work_area,x'40'        | Fill work area with spaces.\n  l     r14,kpm_search_key_address    | Point r14 to search key.\n  l8    r15,kpm_search_key_length     | Load r15 with search key size.\n  bctr  r15,0                         | Move search key to work area.\n  exi   r15,(mvc,&w.key_work_area(*-*),0(r14))\n  la    r15,1(,r15)                   |\n  loop bct                            | Trim off\n   la    r1,&w.key_work_area-1(r15)   | trailing\n   leave loop=*,(cli,0(r1),ne,x'40')  | blanks.\n  endloop bct,r15                     |\n  stc   r15,&w.key_size               | Save trimmed size.\n* *-------------------------------------------------------------------*\n* * Search for item in chain with correct key.\n* *-------------------------------------------------------------------*\n  l32   r15,kpm_first_token           | Point r15 to first in chain.\n  loop until                          | Search for correct item:\n   if (treg,r15,z)                    |  If at end of chain:\n    la    r15,4                       |   Indicate item not found.\n    leave block=*                     |   Leave subroutine.\n   endif                              |  Endif.\n   st    r15,itc_token                |  Save token in ITC.\n   imlta r1,r15                       |  Get address\n   st    r1,itc_address               |  of item.\n   errexit (treg,r15,nz),code=&im_invalid_token\n   lr    r4,r1                        |  Point r4 to item.\n   if (tbit,itc_f,itc_f_variable_links_offset),or,                  @C1+\n               (clc,itc_itype,ne,0(r4))  If characteristics for     @C1\n    la      r1,itc_                   |    prior item are not close @C1\n    callsub get_itc                   |    enough, call get ITC.    @C1\n   elseif (tbit,itc_f_variable_size)  |  ElseIf variable item size  @C1\n    l     r14,itc_itd_address         |   Get ITD address.          @C1\n    using itd,r14                     |   Establish base for ITD.   @C1\n    l32   r1,itdxilnof                |   Load offset of length.    @C1\n    errexit z,code=&im_internal_error |   Error if zero.            @C1\n    slr   r0,r0                       |   Clear result register.    @C1\n    al    r1,itc_address              |   Calculate addr of length. @C1\n    icm   r14,b'1000',itdxilnsz       |   r14 := size of length.    @C1\n    srl   r14,24                      |                             @C1\n    drop  r14                         |   Drop ITD.                 @C1\n    caseblk reg=r14                   |   Process based on size.    @C1\n    case 1                            |   One byte:                 @C1\n     ic   r0,0(,r1)                   |    Load one byte length.    @C1\n    case 2                            |   Two bytes:                @C1\n     icm  r0,b'0011',0(r1)            |    Load two byte length.    @C1\n    case 3                            |   Three bytes:              @C1\n     icm  r0,b'0111',0(r1)            |    Load three byte length.  @C1\n    case 4                            |   Four bytes:               @C1\n     l    r0,0(r1)                    |    Load four byte length.   @C1\n    case other                        |   Other size:               @C1\n     errexit code=&im_internal_error  |    This is bad news.        @C1\n    endcase                           |   Endcase.                  @C1\n    st    r0,itc_size                 |   Save size in ITC.         @C1\n   endif                              |  EndIf.                     @C1\n   l8    r1,kpm_key_length            |  Get static key length.\n   if z                               |  If it is zero:\n    l     r8,itc_address              |   Get key\n    al    r8,kpm_key_length_offset    |   length\n    l8    r1,0(r8)                    |   from item.\n    errexit z,code=&im_invalid_item   |   Error if it is zero.\n   endif                              |  Endif.\n   if (clm,r1,b'0001',ge,&w.key_size) |  If key in item not to small:\n    l     r4,itc_address              |   Point r4\n    al    r4,kpm_key_offset           |   to key in item.\n    bctr  r1,0                        |   Compare key in item\n    exi   r1,(clc,&w.key_work_area(*-*),0(r4))    and search key.\n    if eq                             |   If they match:\n     sr    r15,r15                    |    The correct item\n     leave block=*                    |    is found.\n    endif                             |   Endif.\n   endif                              |  Endif.\n   imlla r4,kpm_link_number,itc_      |  Point to next\n   l     r15,0(,r4)                   |  item in chain.\n  endloop until,leave                 | End of search.\n* *-------------------------------------------------------------------*\n endblk block=find_by_key             |\n         swa ,                        |\n&w.key_size       ds x                |\n&w.key_work_area  ds cl256            |\n         endswa                       |\n eject                                |\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Get_hash_info.\n*  Abstract:   This subroutine applies the hash function to the key\n*              of an item and returns the address of the link field\n*              in the HTD.\n*  Parameters: (>itc,>htd,<link_address)\n*\n*---------------------------------------------------------------------*\n block name=get_hash_info,type=subroutine,                             +\n               parms=(itc,htd,link_address)\n* *-------------------------------------------------------------------*\n* *  Load bases.\n* *-------------------------------------------------------------------*\n  l     r3,&p.itc                     | Point r3 to ITC and\n  using itc_,r3                       | establish addressibility.\n  l     r4,&p.htd                     | Point r4 to HTD and\n  using htd,r4                        | establish addressibility.\n* *-------------------------------------------------------------------*\n* *  Move key from IMMS to work area.\n* *-------------------------------------------------------------------*\n  l     r5,htdkof                     | Calculate address\n  al    r5,itc_address                | of key.\n  fill  pwa_key_work_area,x'40'       | Initialize work area to spaces.\n  imlks r15,itc_,htd                  | Load key size.\n  st    r15,&w.key_size               | Save key size.\n  bctr  r15,0                         | Move key to work area.\n  exi   r15,(mvc,pwa_key_work_area(*-*),0(r5))\n* *-------------------------------------------------------------------*\n* *  Calculate hash key.\n* *-------------------------------------------------------------------*\n  l     r15,htd#lnks                  | Calculate\n  sh    r15,=y(htdtable_link_#)       | number of entries\n  st    r15,&w.entries                | in hash table.\n  callsub calc_hash_key,              | Calculate hash key.            +\n               (pwa_key_work_area,    |                                +\n               &w.key_size,           |                                +\n               &w.entries,            |                                +\n               &w.hash_key)           |\n* *-------------------------------------------------------------------*\n* *  Calculate link address and return it to caller.\n* *-------------------------------------------------------------------*\n  l     r15,&w.hash_key               | Calculate\n  sla   r15,2                         | address of\n  la    r15,htdtable(r15)             | link in hash table.\n  l     r1,&p.link_address            | Pass back this\n  st    r15,0(,r1)                    | address to caller.\n* *-------------------------------------------------------------------*\n endblk block=get_hash_info           |\n         swa ,                        |\n&w.key_size   ds f                    |\n&w.entries    ds f                    |\n&w.hash_key   ds f                    |\n         endswa ,                     |\n eject                                |\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Calc_hash_key.\n*  Abstract:   This subroutine calculates a hash key.\n*  Parameters: (>key,>key_length,>entries,<hash_key)\n*\n*---------------------------------------------------------------------*\n block name=calc_hash_key,type=subroutine,                             +\n               parms=(key,key_length,entries,hash_key)\n* *-------------------------------------------------------------------*\n* *  Apply hashing function to key.\n* *-------------------------------------------------------------------*\n  l     r3,&p.key                     | Point r3 to key.\n  l     r1,&p.key_length              | Load r15\n  l     r15,0(,r1)                    | with length.\n.newway  anop\n  xr    r1,r1                         | Clear accumulator.\n  loop until                          | Process in groups of 9 chars:\n   if (ch,r15,ge,=h'9')               |  If length >= 9:\n    mvc   &w.work,0(r3)               |   Move 9 bytes to work area.\n    la    r3,9(,r3)                   |   Point past bytes moved.\n    sh    r15,=h'9'                   |   Decrement remaining length.\n   else                               |  Else if length < 9:\n    la    r2,9                        |   Move\n    sr    r2,r15                      |   bytes\n    la    r14,&w.work(r2)             |   right\n    bctr  r15,0                       |   justified\n    exi   r15,(mvc,0(*-*,r14),0(r3))  |   to work area.\n    bctr  r2,0                        |   Clear unused\n    exi   r2,(xc,&w.work(*-*),&w.work)    bytes.\n    xr    r15,r15                     |   Set remaining to zero.\n   endif                              |  Endif.\n   oc    &w.work,=x'f0f0f0f0f0f0f0f0f0'  Set all zones to F's.\n   tr    &w.work,psd_0123456789147036 |  Translate invalid's to some-\n   pack  &w.d,&w.work                 |  thing else and pack.\n   cvb   r0,&w.d                      |  Convert number to binary.\n   alr   r1,r0                        |  Add to accumulator.\n  endloop until,(treg,r15,np)         | End loop if all processed.\n  ago   .pastold                      |\n.oldway  anop                         |\n  slr   r0,r0                         | Clear work\n  slr   r1,r1                         | registers.\n  ic    r0,=x'40'                     | Insert a space into r0.\n  bctr  r3,0                          | Reduce\n  loop bct                            | length\n   ic    r1,0(r15,r3)                 | by number\n   leave loop=*,(clr,r1,ne,r0)        | of\n  endloop bct,r15                     | trailing\n  la    r3,1(,r3)                     | spaces.\n  slr   r0,r0                         | Clear work\n  slr   r1,r1                         | registers.\n  loop until                          | Fold key:\n   if (ch,r15,ge,=h'3')               |  If at least 3 bytes left:\n    icm   r0,b'0111',0(r3)            |   Add three bytes to\n    alr   r1,r0                       |   accumulated value.\n    la    r3,3(,r3)                   |   Point to next 3 bytes.\n    sh    r15,=h'3'                   |   Drop length by 3.\n   else                               |  Else if less than 3 bytes.\n    if (ch,r15,eq,=h'1')              |   If one:\n     slr   r0,r0                      |    Just\n     ic    r0,0(r3)                   |    add that\n     alr   r1,r0                      |    one.\n    elseif (ch,r15,eq,=h'2')          |   If two:\n     slr   r0,r0                      |    Add\n     icm   r0,b'0011',0(r3)           |    last two\n     alr   r1,r0                      |    bytes.\n    endif                             |   If zero: nothing to do.\n    leave loop=*                      |   Loop is complete.\n   endif                              |  Endif.\n  endloop until,leave                 | Endloop.\n.pastold anop\n  l     r15,&p.entries                | Load number of\n  l     r15,0(,r15)                   | entries in hash table.\n  lpr   r1,r1                         | Make sure result will be >= 0.\n  slr   r0,r0                         | Divide this number\n  dr    r0,r15                        | into accumulated value.\n*                                     | Remainder is hash key.\n  l     r1,&p.hash_key                | Pass back hash\n  st    r0,0(,r1)                     | key to caller.\n* *-------------------------------------------------------------------*\n endblk block=calc_hash_key           |\n         swa                          |\n&w.d     ds    d                      |\n&w.work  ds    cl9                    |\n         endswa                       |\n eject                                |\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Sort_a_list.\n*  Abstract:   This subroutine sorts a list.\n*  Parameters: (>descriptor,>fieldslist,>head_token,>sort_technique)\n*\n*---------------------------------------------------------------------*\n block name=sort_a_list,type=subroutine,                               +\n               parms=(descriptor_token,sfd,head_token,technique)\n* *-------------------------------------------------------------------*\n* *  Get base for descriptor.\n* *-------------------------------------------------------------------*\n  imlta r4,*&p.descriptor_token       | Get address of descriptor.\n  errexit nz,or,(treg,r4,z),code=&im_invalid_descriptor_token\n  using lld,r4                        | Establish base for descriptor.\n* *-------------------------------------------------------------------*\n* *  Get address of list heads.\n* *-------------------------------------------------------------------*\n  if (tbit,lldophid)                  | If heads in descriptor:\n   la    r0,lldfrlst                  |  Use first pointer\n   st    r0,&w.first_ptr_addr         |  in LLD.\n   la    r0,lldfnlst                  |  Use final pointer\n   st    r0,&w.final_ptr_addr         |  in LLD.\n   errexit (%l32,r1,&p.head_token,nz),and,(clc,0(4,r1),ne,=f'0'),      +\n               code=&im_head_not_valid_for_this_descriptor\n  else                                | Else:\n   if (%l32,r1,&p.head_token,nz),and, |  If head token supplied        +\n               (%l32,r1,0(r1),nz)     |  by caller:\n    st    r1,&w.itc_token             |   Use it.\n   else                               |  Else:\n    callsub find_current,(lldhditd,&w.itc_token)  Find item\n    errexit (treg,r15,nz),code=&im_currency_error that has heads.\n    errexit nz,code=&im_internal_error\n   endif                              |  Endif.\n   la    r1,&w.itc_                   |               Get ITC\n   callsub get_itc                    |               for item.\n   imlla &w.first_ptr_addr,lldfrlk#,&w.itc_           Get links\n   imlla &w.final_ptr_addr,lldfnlk#,&w.itc_           from item.\n  endif                               | Endif.\n* *-------------------------------------------------------------------*\n* * Calculate offset of next and prior links within links.\n* *-------------------------------------------------------------------*\n  l     r1,lldnxlk#                   | Load number of next link.\n  sh    r1,=h'1'                      | Sub 1.\n  errexit m,code=&im_internal_error   | Bad news in negative.\n  sla   r1,2                          | Multiply number by 4.\n  st    r1,&w.next_link_offset_in_links Save result.\n  l     r1,lldprlk#                   | Load number of prior link.\n  sh    r1,=h'1'                      | Sub 1.\n  sla   r1,2                          | Multiply number by 4.\n  st    r1,&w.prior_link_offset_in_links Save result.\n* *-------------------------------------------------------------------*\n* * Save some information for the SFD and take a shoot at making\n* * sure that it is valid.  Calculate how much storage will be\n* * required for generated compare code.\n* *-------------------------------------------------------------------*\n  fill  &w.size_of_compare_code,x'00' | Set compare code size to zero.\n  l     r3,&p.sfd                     | Establish base for\n  using sfd_start,r3                  | Sort Fields Definition.\n  l32   r0,sfd_elements_in_array      | Save number\n  errexit code=&im_invalid_sfd,np     | of fields\n  st    r0,&w.elements_in_array       | in SWA.\n  la    r1,sfd_array_start            | Save address of first\n  st    r1,&w.array_start             | SFD element in SWA.\n  drop  r3                            | Drop base for SFD.\n  l     r2,&w.elements_in_array       | Load r2 with # sort fields.\n  l     r3,&w.array_start             | Point r3 to first element.\n  using sfd_element,r3                | Establish base for element.\n  loop  bct                           | Process each sort field:\n   lh    r1,sfd_type                  |  Process based on\n   errexit code=&im_invalid_sfd,      |  Don't support offsets > 4095. +\n               (clc,sfd_offset,gt,=f'4095')\n   caseblk reg=r1                     |  type of field.\n   case  &im_sfd_type_character\n    errexit code=&im_invalid_sfd,(clc,sfd_length,gt,=f'256')\n    l     r15,&w.size_of_compare_code |   Increase\n    la    r15,&s.size_for_character+&s.b_sequence_l(,r15) size of\n    st    r15,&w.size_of_compare_code |   compare code.\n   case  &im_sfd_type_packed\n    errexit code=&im_invalid_sfd,(clc,sfd_length,gt,=f'16')\n    l     r15,&w.size_of_compare_code |   Increase\n    la    r15,&s.size_for_packed+&s.b_sequence_l(,r15) size of\n    st    r15,&w.size_of_compare_code |   compare code.\n   case  &im_sfd_type_zoned\n    errexit code=&im_invalid_sfd,(clc,sfd_length,gt,=f'16')\n    l     r15,&w.size_of_compare_code |   Increase\n    la    r15,&s.size_for_zoned+&s.b_sequence_l(,r15) size of\n    st    r15,&w.size_of_compare_code |   compare code.\n   case  &im_sfd_type_fixed\n    errexit code=&im_invalid_sfd,(clc,sfd_length,ne,=f'2'),and,        +\n               (clc,sfd_length,ne,=f'4')\n    l     r15,&w.size_of_compare_code |   Increase\n    la    r15,&s.size_for_fixed+&s.b_sequence_l(,r15) | size of\n    st    r15,&w.size_of_compare_code |   compare code.\n   case  &im_sfd_type_bit\n    l     r15,&w.size_of_compare_code |   Increase\n    la    r15,&s.size_for_bit+&s.b_sequence_l(,r15) | size of\n    st    r15,&w.size_of_compare_code |   compare code.\n   case  other                        |  Other cases.\n    errexit code=&im_invalid_sfd      |   Invalid SFD.\n   endcase                            |  Endcase.\n   la    r3,sfd_size_element(,r3)     |  Point to next element.\n  endloop bct,r2                      | Endloop.\n  drop  r3                            | Drop base for SFD element.\n* *-------------------------------------------------------------------*\n* * Get storage for generated compare code and build it.\n* *-------------------------------------------------------------------*\n  mm_obtain_storage id=mm,            | Get storage for code.          +\n               address=&w.address_of_compare_code,                     +\n               size=&w.size_of_compare_code\n  if (treg,r15,nz)                    | If obtain failed:\n   errexit (ch,r15,eq,=y(&mm_storage_not_available)),                  +\n               code=&im_storage_not_available   Fail with appropriate\n   errexit code=&im_internal_error    |         error code.\n  endif                               | Endif.\n  l     r2,&w.elements_in_array       | Load r2 with # sort fields.\n  l     r3,&w.array_start             | Point r3 to first element.\n  l     r14,&w.address_of_compare_code  Point r14 to build area.\n  using sfd_element,r3                | Establish base for element.\n  loop  bct                           | Process each sort field:\n   lh    r1,sfd_type                  |  Process based on\n   errexit code=&im_invalid_sfd,      |  Don't support offsets > 4095. +\n               (clc,sfd_offset,gt,=f'4095')\n   caseblk reg=r1,wreg=r15            |  type of field.\n   case  &im_sfd_type_character       |\n*   *-----------------------------------------------------------------*\n*   * For character, generate a CLC instruction.\n*   *\n*   *  +0 CLC  offset(length,r5),offset(R6)\n*   *\n*   *-----------------------------------------------------------------*\n    mvi   0(r14),x'D5'                |   Move opcode for CLC.\n    l     r0,sfd_length               |   Set length in\n    sh    r0,=h'1'                    |   CLC instruction\n    stc   r0,1(,r14)                  |   to compare length - 1.\n    l     r0,sfd_offset               |   Op1 is the base displacement\n    o     r0,&s.base_current          |   of field in the\n    sth   r0,2(,r14)                  |   current item.\n    l     r0,sfd_offset               |   Op2 is the base displacement\n    o     r0,&s.base_next             |   of field in the\n    sth   r0,4(,r14)                  |   next item.\n&s.size_for_character equ 6           |   Size of this code.\n    la    r14,&s.size_for_character(,r14) Point r14 past this code.\n   case  &im_sfd_type_packed          |\n*   *-----------------------------------------------------------------*\n*   * For packed, generate a CP instruction.\n*   *\n*   *  +0 CP   offset(length,r5),offset(length,R6)\n*   *\n*   *-----------------------------------------------------------------*\n    mvi   0(r14),x'F9'                |   Move opcode for CP.\n    l     r1,sfd_length               |   Set LL1\n    bctr  r1,0                        |   and\n    lr    r0,r1                       |   LL2\n    sll   r0,4                        |   in CP\n    or    r0,r1                       |   instruction\n    stc   r0,1(,r14)                  |   to length - 1.\n    l     r0,sfd_offset               |   Op1 is the base displacement\n    o     r0,&s.base_current          |   of field in the\n    sth   r0,2(,r14)                  |   current item.\n    l     r0,sfd_offset               |   Op2 is the base displacement\n    o     r0,&s.base_next             |   of field in the\n    sth   r0,4(,r14)                  |   next item.\n&s.size_for_packed    equ 6           |   Size of this code.\n    la    r14,&s.size_for_packed(,r14)    Point r14 past this code.\n   case  &im_sfd_type_zoned           |\n*   *-----------------------------------------------------------------*\n*   * For zoned, generate two PACKs and a CP instruction.\n*   *\n*   *  +0 PACK  0(length/2+1,R2),offset(length,R5)\n*   *  +6 PACK  8(length/2+1,R2),offset(length,R6)\n*   *  +C CP    0(length/2+1,R2),8(length/2+1,r2)\n*   *\n*   *-----------------------------------------------------------------*\n    mvi   0(r14),x'F2'                |   Move opcode for PACK.\n    l     r1,sfd_length               |   Set\n    sra   r1,1                        |   LL1 to\n    la    r1,1(,r1)                   |   length/2+1\n    sll   r1,4                        |   and\n    o     r1,sfd_length               |   LL2 to\n    stc   r1,1(,r14)                  |   length.\n    lr    r0,r1                       |   Save LL1/LL2 for later.\n    mvc   2(2,r14),=s(0(r2))          |   Op1 is work field 1.\n    l     r1,sfd_offset               |   Op2 is the base displacement\n    o     r1,&s.base_current          |   of field in the\n    sth   r1,4(,r14)                  |   current item.\n    mvi   6(r14),x'F2'                |   Move opcode for PACK.\n    stc   r0,7(,r14)                  |   Set LL1/LL2 the same.\n    mvc   8(2,r14),=s(8(r2))          |   Op1 is work field 1.\n    l     r1,sfd_offset               |   Op2 is the base displacement\n    o     r1,&s.base_next             |   of field in the\n    sth   r1,10(,r14)                 |   next item.\n    mvi   12(r14),x'F9'               |   Move opcode for CP.\n    sra   r0,4                        |   LL1 and\n    lr    r1,r0                       |   LL2\n    sla   r0,4                        |   are\n    or    r0,r1                       |   both\n    stc   r0,13(,r14)                 |   length/2+1.\n    mvc   14(4,r14),=s(0(r2),8(r2))   |   OP2 and OP2 are work fields.\n&s.size_for_zoned     equ 6+6+6       |   Size of this code.\n    la    r14,&s.size_for_zoned(,r14) |   Point r14 past this code.\n   case  &im_sfd_type_fixed           |\n*   *-----------------------------------------------------------------*\n*   * For fixed, generate a load and compare.\n*   *\n*   *  +0 L{H}  R0,mask_based_on_length,offset_in_item(R5)\n*   *  +4 C{H}  R0,mask_based_on_length,offset_in_item(R6)\n*   *\n*   *-----------------------------------------------------------------*\n    l     r1,sfd_length               |   Load mask\n    if (ch,r1,eq,=h'2')               |   If halfword lengths:\n     mvi   0(r14),x'48'               |    Use LH and\n     mvi   4(r14),x'49'               |    CH instructions.\n    else                              |   Else, must be fullword:\n     mvi   0(r14),x'58'               |    Use L and\n     mvi   4(r14),x'59'               |    C instructions.\n    endif                             |   Endif.\n    mvi   1(r14),0                    |   Load into register zero.\n    l     r1,sfd_offset               |   Base displacement\n    o     r1,&s.base_current          |   of field in the\n    sth   r1,2(,r14)                  |   current item.\n    mvi   5(r14),0                    |   Compare to register zero.\n    l     r1,sfd_offset               |   Base displacement\n    o     r1,&s.base_next             |   of field in the\n    sth   r1,6(,r14)                  |   next item.\n&s.size_for_fixed     equ 4+4         |   Size of this code.\n    la    r14,&s.size_for_fixed(,r14) |   Point r14 past this code.\n   case  &im_sfd_type_bit             |\n*   *-----------------------------------------------------------------*\n*   *\n*   * For bit, generate code to compare bits within a byte.  The\n*   * mask specified in the SFD can have multiple bits turned on.\n*   *\n*   * Generate code that performs the comparison by loading each value\n*   * into a register, masking off unwanted bits, comparing values.\n*   *\n*   *  0  4140 00mm       LA    r1,x'mask'(0,0)\n*   *  4  5010 Dxxx       ST    r1,pwa_bit_mask\n*   *  8  4300 5ddd       IC    r0,offset_in_item(,r5)\n*   *  C  4310 6ddd       IC    r1,offset_in_item(,r6)\n*   * 10  5400 Dxxx       N     r0,pwa_bit_mask\n*   * 14  5410 Dxxx       N     r1,pwa_bit_mask\n*   * 18  1901            CR    r0,r1\n*   *\n*   *-----------------------------------------------------------------*\n    mvc   x'00'(4,r14),=x'41100000'    +0   \"LA r1,mask\"\n    oc    x'03'(1,r14),sfd_mask+3\n    mvc   x'04'(4,r14),=x'5010D000'    +4   \"ST r1,pwa_bit_mask\"\n    oc    x'06'(2,r14),=s(pwa_bit_mask)\n    mvc   x'08'(2,r14),=x'4300'        +8   \"IC R0,xxx(0,rx)\"\n    l     r1,sfd_offset                       BaseReg and Displacement\n    o     r1,&s.base_current                  of field in the\n    sth   r1,x'0A'(,r14)                      current item.\n    mvc   x'0C'(2,r14),=x'4310'        +C   \"IC R1,xxx(0,rx)\"\n    l     r1,sfd_offset                      BaseReg and Displacement\n    o     r1,&s.base_next                    of field in the\n    sth   r1,x'0E'(,r14)                     next item.\n    mvc   x'10'(4,r14),=x'5400D000'   +10   \"N r0,pwa_bit_mask\"\n    oc    x'12'(2,r14),=s(pwa_bit_mask)\n    mvc   x'14'(4,r14),=x'5410D000'   +14   \"N r1,pwa_bit_mask\"\n    oc    x'16'(2,r14),=s(pwa_bit_mask)\n    mvc   x'18'(2,r14),=x'1901'       +18   \"CR r0,r1\".\n*\n&s.size_for_bit  equ 4+4+4+4+4+4+2        Size of this code.\n    la    r14,&s.size_for_bit(,r14)   |   Point r14 past this code.\n*   *-----------------------------------------------------------------*\n   endcase                            |  Endcase.\n*  *------------------------------------------------------------------*\n*  * Generate a BHR-BLR sequence.\n*  *------------------------------------------------------------------*\n   if (tbit,sfd_f_descending)         |  If descending:\n    mvc   0(&s.b_sequence_l,r14),&s.b_descending\n   else                               |  Else:\n    mvc   0(&s.b_sequence_l,r14),&s.b_ascending\n   endif                              |  Endif.\n   la    r14,&s.b_sequence_l(,r14)    |  Point r14 past this code.\n*  *------------------------------------------------------------------*\n*  * Point to next element and continue.\n*  *------------------------------------------------------------------*\n   la    r3,sfd_size_element(,r3)     |  Point to next element.\n  endloop bct,r2                      | Endloop.\n* *-------------------------------------------------------------------*\n* *  Change last BHR R3 or BLR R3 to a BR R3.\n* *-------------------------------------------------------------------*\n  sh    r14,=y(&s.b_last_l)           | Patch last branch\n  mvc   0(&s.b_last_l,r14),&s.b_last  | to be a BR R3.\n  drop  r3                            | Drop base for SFD element.\n* *-------------------------------------------------------------------*\n* * Sort list based on technique.\n* *-------------------------------------------------------------------*\n  plist (*&w.address_of_compare_code, | Build parameter                +\n               *&w.first_ptr_addr,    | list for sort                  +\n               *&w.final_ptr_addr,    | routines.                      +\n               *&w.next_link_offset_in_links,                          +\n               *&w.prior_link_offset_in_links)\n  if (%l32,r2,&p.technique,z),or,     | If this is a Quicksort:        +\n               (%l32,r2,0(r2),z),or,  |  (that's the default)          +\n               (ch,r2,eq,=y(&im_sort_technique_quick_sort))\n   callsub Quicksort                  |  Do partition-exchange sort.\n  elseif (ch,r2,eq,=y(&im_sort_technique_bubble_sort))\n   callsub bubble_sort                | Else if bubble sort: do it.\n  else                                | Else if invalid technique:\n   errexit code=&im_invalid_sort_technique  Fail.\n  endif                               | Endif.\n* *-------------------------------------------------------------------*\n* * Release compare code storage.\n* *-------------------------------------------------------------------*\n  mm_release_storage id=mm,           | Release storage for code.      +\n               address=&w.address_of_compare_code,                     +\n               size=&w.size_of_compare_code\n  errexit (treg,r15,nz),code=&im_internal_error\n* *-------------------------------------------------------------------*\n endblk block=sort_a_list             |\n         ssd ,                        |\n&s.masks equ   *-1                    | Insert character\n         dc    al1(1,3,7,15)          | masks.\n&s.b_ascending    bhr  r14            |\n                  blr  r3             |\n&s.b_ascending_l  equ  *-&s.b_ascending\n&s.b_descending   blr  r14            |\n                  bhr  r3             |\n&s.b_descending_l equ  *-&s.b_descending\n&s.b_sequence_l   equ  &s.b_descending_l\n&s.b_last         br   r3             |\n&s.b_last_l       equ  *-&s.b_last    |\n&s.base_current dc   a(x'00005000')   |\n&s.base_next    dc   a(x'00006000')   |\n         endssd ,                     |\n         swa ,                        |\n&w.size_of_compare_code       ds f    |\n&w.address_of_compare_code    ds a    |\n&w.elements_in_array          ds f    |\n&w.array_start                ds a    |\n&w.first_ptr_addr             ds a    |\n&w.final_ptr_addr             ds a    |\n&w.next_link_offset_in_links  ds a    |\n&w.prior_link_offset_in_links ds a    |\n         itc id=&w.itc_               |\n         endswa                       |\n         eject                        |\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Bubble_sort\n*  Abstract:   This subroutine sorts a list using bubble sort.\n*\n*---------------------------------------------------------------------*\n block name=bubble_sort,type=subroutine,                               +\n               parms=(compare_code,first_ptr_addr,final_ptr_addr,      +\n               next_link_offset_in_links,prior_link_offset_in_links)\n* *-------------------------------------------------------------------*\n* *  Reset flags in ITC.\n* *-------------------------------------------------------------------*\n  mvi   &w.itc_f,0                    | Reset flags in ITC.\n* *-------------------------------------------------------------------*\n* * Sort list.\n* *-------------------------------------------------------------------*\n  fill  &w.last_token,x'00'           |  Set last token to null.\n  l     r5,&p.first_ptr_addr          |  If the list is\n  if (%l32,r0,0(r5),nz)               |  not empty:\n   loop  until                        |   Loop until sorted:\n    l     r5,&p.first_ptr_addr        |    Set ITC token\n    l     r0,0(,r5)                   |    to first item\n    st    r0,&w.itc_token             |    in list.\n    imlta r1,r0                       |    Get address\n    st    r1,&w.itc_address           |    of first item.\n    errexit (treg,r15,nz),code=&im_invalid_token\n    lr    r6,r1                       |    Point r6 to item.\n    if (tbit,&w.itc_f,&w.itc_f_variable_links_offset),or,              +\n               (clc,&w.itc_itype,ne,0(r6)) If characteristics\n     la    r1,&w.itc_                 |    for last item are\n     callsub get_itc                  |    not close enough, call\n    endif                             |    subroutine to get ITC.\n    mvc   &w.end_token,&w.last_token  |    Set end token to last token.\n    fill  &w.last_token,x'00'         |    Set last token to null.\n    mvc   &w.prior_ptr_addr,&p.first_ptr_addr Prior is head link.\n*   *-----------------------------------------------------------------*\n*   * Make a pass of the list.\n*   *-----------------------------------------------------------------*\n    loop  until                       |   Start loop:\n*    *----------------------------------------------------------------*\n*    * Set new current item.\n*    *----------------------------------------------------------------*\n     mvc   &w.current_offset_links,&w.itc_offset_links\n     mvc   &w.current_token,&w.itc_token   Set &w.current_..\n     lr    r5,r6                      |    Point r5 to new current\n*    *----------------------------------------------------------------*\n*    * This pass is finished if next token is the same as the ending\n*    * token.\n*    *----------------------------------------------------------------*\n     lr    r7,r5                      |    Calculate address\n     a     r7,&w.current_offset_links |    of next link in\n     a     r7,&p.next_link_offset_in_links current item.\n     leave loop=*,(clc,&w.end_token,eq,0(r7)) Finished if next is end.\n*    *----------------------------------------------------------------*\n*    * Get characteristics for next item.\n*    *----------------------------------------------------------------*\n     l     r0,0(,r7)                  |    Set ITC token\n     st    r0,&w.itc_token            |    to next item token.\n     imlta r1,r0                      |    Get address of next item.\n     errexit (treg,r15,nz),code=&im_invalid_token\n     st    r1,&w.itc_address          |    Save address of next item.\n     lr    r6,r1                      |    Point r6 to next item.\n     if (tbit,&w.itc_f,&w.itc_f_variable_links_offset),or,             +\n               (clc,&w.itc_itype,ne,0(r6)) If characteristics\n      la    r1,&w.itc_                |    for last item are not\n      callsub get_itc                 |    close enough, call get_itc\n     endif                            |    subroutine.\n*    *----------------------------------------------------------------*\n*    * At this point, r5 has the address of current item and r6 has\n*    * the address of the next item.  The compare code will return\n*    * after the BASR if an exchange is required, otherwise it will\n*    * go past the exchange code.\n*    *----------------------------------------------------------------*\n     la    r2,&w.work                 |    Point r2 to work area.\n     sm_lal r3,past_exchange          |    Point r3 past exchange.\n     l     r15,&p.compare_code        |    Point r15 to compare code.\n     basr  r14,r15                    |    Call compare code.\n     lr    r7,r5                      |    Calculate address\n     a     r7,&w.current_offset_links |    of next link in\n     a     r7,&p.next_link_offset_in_links current item.\n     lr    r8,r6                      |    Calculate address\n     a     r8,&w.itc_offset_links          of next link in\n     a     r8,&p.next_link_offset_in_links next item.\n     mvc   0(4,r7),0(r8)              |    Set next link of current\n*                                     |    item to next link of\n*                                     |    next item.\n     mvc   0(4,r8),&w.current_token   |    Set next link of next\n*                                     |    item to current token.\n     mvc   &w.last_token,0(r8)        |    Also set last to curr tkn.\n     l     r8,&w.prior_ptr_addr       |    If this exchange is for\n     mvc   0(4,r8),&w.itc_token       |    Update prior next token.\n     if (%l32,r8,&p.final_ptr_addr,nz),    If exchanging with last     +\n               and,(clc,&w.itc_token,eq,0(r8)) item in list:\n      mvc   0(4,r8),&w.current_token  |     Update token of last item.\n     endif                            |    Endif.\n     xr    r5,r6                      |    Exchange current\n     xr    r5,r6                      |    and next item\n     xr    r5,r6                      |    addresses.\npast_exchange ds 0h                   |    End of exchange code.\n*    *---------------------------------------------------------------*\n     lr    r0,r5                      |    Calculate address\n     a     r0,&w.current_offset_links |    of next link in\n     a     r0,&p.next_link_offset_in_links current item.\n     st    r0,&w.prior_ptr_addr       |    Save as prior link address.\n    endloop until,leave               |   Endloop.\n   endloop until,                     |  Endloop.                      +\n               (clc,&w.last_token,eq,=f'0')\n*  *------------------------------------------------------------------*\n*  * If this list has prior pointer, update them.\n*  *------------------------------------------------------------------*\n   slr   r2,r2                        |  Clear prior token holder.\n   l32   r3,&p.prior_link_offset_in_links\n   if nm                              |  If there are prior links:\n    l     r5,&p.first_ptr_addr        |   Load r0 with\n    l     r0,0(,r5)                   |   token of first item.\n    loop until                        |   Process all items in list:\n     st    r0,&w.itc_token            |    Save token.\n     imlta r5,r0                      |    Get address of item.\n     errexit (treg,r15,nz),code=&im_invalid_token\n     if (tbit,&w.itc_f,&w.itc_f_variable_links_offset),or,             +\n               (clc,&w.itc_itype,ne,0(r6)) If characteristics\n      la    r1,&w.itc_                |    for last item are not\n      callsub get_itc                 |    close enough, call get_itc\n     endif                            |    subroutine.\n     lr    r6,r5                      |    Calculate address\n     a     r6,&w.itc_offset_links     |    of prior link in\n     ar    r6,r3                      |    the item.\n     st    r2,0(,r6)                  |    Save prior item token.\n     l     r2,&w.itc_token            |    Set new prior item token.\n     a     r5,&w.itc_offset_links     |    Load token\n     a     r5,&p.next_link_offset_in_links of next\n     l32   r0,0(r5)                   |    item in list.\n    endloop until,z                   |   Endloop.\n   endif                              |  Endif.\n*  *------------------------------------------------------------------*\n  endif                               | Endif.\n* *-------------------------------------------------------------------*\n endblk block=bubble_sort             |\n         swa ,                        |\n&w.work                       ds 2d   |\n&w.prior_ptr_addr             ds a    |\n&w.current_offset_links       ds f    |\n&w.current_token              ds f    |\n&w.end_token                  ds f    |\n&w.last_token                 ds f    |\n         itc id=&w.itc_               |\n         endswa                       |\n         eject                        |\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Quicksort\n*  Abstract:   This subroutine sorts a list using Quicksort with\n*              Richard C. Singleton's improvements.  See ACM\n*              Algorithm 347 \"An Efficient Algorithm For Sorting With\n*              Minimal Storage {M1}\" by Richard C. Singleton.\n*\n*---------------------------------------------------------------------*\n block name=Quicksort,type=subroutine,                                 +\n               parms=(compare_code,first_ptr_addr,final_ptr_addr,      +\n               next_link_offset_in_links,prior_link_offset_in_links)\n* *-------------------------------------------------------------------*\n* * Initialize SWA.\n* *-------------------------------------------------------------------*\n  fill  &w.itc_storage,x'00'          | Clear ITC.\n  fill  &w.item_counter,x'00'         | Zero out item counter.\n* *-------------------------------------------------------------------*\n* * Run through list getting token and address.  Count entries in list.\n* *-------------------------------------------------------------------*\n  la    r3,&w.dummy_qsw_head          | Point r3 to dummy QSW head.\n  using qsw_head,r3                   | Establish base for head.\n  mvc   qsw_id,=cl4\"QSWH\"             | Set its id.\n  fill  qsw_next,x'00'                | Clear next and\n  fill  qsw_end,x'00'                 | end pointer.\n  st    r3,&w.current_qsw_segment     | Set current segment to dummy.\n  st    r3,&w.end_of_segment          | Make it look full.\n  l     r1,&p.first_ptr_addr          | Load r0 with\n  l32   r0,0(r1)                      | first token.\n  leave z,block=*                     | Leave if list is empty.\n  loop while,nz                       | Pass all items in list.\n*  *------------------------------------------------------------------*\n*  * Get characteristics of item.\n*  *------------------------------------------------------------------*\n   st    r0,&w.itc_token              |  Save item token.\n   imlta r1,r0                        |  Get address\n   st    r1,&w.itc_address            |  of first item.\n   errexit (treg,r15,nz),code=&im_invalid_token\n   lr    r4,r1                        |  Point r4 to item.\n   if (tbit,&w.itc_f,&w.itc_f_variable_links_offset),or,               +\n               (clc,&w.itc_itype,ne,0(r4)) If characteristics\n    la    r1,&w.itc_                  |  for last item are\n    callsub get_itc                   |  not close enough, call\n   endif                              |  subroutine to get ITC.\n*  *------------------------------------------------------------------*\n*  * If there is not room for element in the current segment, get a\n*  * new segment.\n*  *------------------------------------------------------------------*\n   la    r1,qsw_element_size(,r3)     |  Point past new element.\n   if (c,r1,gt,&w.end_of_segment)     |  If this would be past segemnt.\n    lr    r0,r3                       |   Save\n    l     r3,&w.current_qsw_segment   |   end address\n    using qsw_head,r3                 |   in segment\n    st    r0,qsw_end                  |   head.\n    es_obtain_storage id=es,          |   Get storage for another      +\n               address=qsw_next,      |   segment.  Put address in     +\n               size=&s.qsw_segment_size,  next pointer of              +\n               subpool=&s.sp_qsw,     |   current                      +\n               boundary=page          |   segment.\n    if (treg,r15,nz)                  |   If obtain failed:\n     errexit (ch,r15,eq,=y(&es_storage_not_available)),                +\n               code=&im_storage_not_available   Fail with appropriate\n     errexit code=&im_internal_error  |           error code.\n    endif                             |   Endif.\n    l     r3,qsw_next                 |   Point r3 to new head.\n    st    r3,&w.current_qsw_segment   |   Set new current.\n    l     r1,&s.qsw_segment_size      |   Set new\n    st    r1,qsw_size                 |   end of\n    ar    r1,r3                       |   segment\n    st    r1,&w.end_of_segment        |   and qsw_size.\n    mvc   qsw_id,=a(qsw_id_text)      |   Set id.\n    fill  qsw_next,x'00'              |   Clear next\n    fill  qsw_end,x'00'               |   and end pointer.\n    la    r3,qsw_head_size(,r3)       |   Point to first element.\n    using qsw_element,r3              |   Establish base for element.\n   endif                              |  Endif.\n*  *------------------------------------------------------------------*\n*  * Update this QSW entry, increment counter, and adjust bases for\n*  * next item.\n*  *------------------------------------------------------------------*\n   l     r0,&w.itc_token              |  Set token\n   st    r0,qsw_token                 |  in QSW entry.\n   st    r4,qsw_address               |  Set address in entry.\n   l     r1,&w.item_counter           |  Increment\n   la    r1,1(,r1)                    |  item\n   st    r1,&w.item_counter           |  counter.\n   la    r3,qsw_element_size(,r3)     |  Point past this QSW element.\n   drop  r3                           |  Drop base for QSW element.\n   a     r4,&w.itc_offset_links       |  Load token\n   a     r4,&p.next_link_offset_in_links  of\n   l32   r0,0(r4)                     |  next item in list.\n*  *------------------------------------------------------------------*\n  endloop while                       | Endloop.\n  l     r1,&w.current_qsw_segment     | Update\n  st    r3,qsw_end-qsw_head(,r1)      | end.\n* *-------------------------------------------------------------------*\n* * If there is more than one segment, consolidate all of them into\n* * one large segment.\n* *-------------------------------------------------------------------*\n  l     r3,&w.first_qsw_head          | Point r3 to first QSW.\n  using qsw_head,r3                   | Establish base.\n  if (clc,qsw_next,eq,=f'0')          | If next pointer is zero:\n   st    r3,&w.work_segment_address   |  Just use this segment\n   mvc   &w.work_segment_size,qsw_size   as the work segment.\n  else                                | Else if more than one segment.\n   l     r1,&w.item_counter           |  Calculate size\n   mh    r1,=y(qsw_element_size)      |  needed for\n   la    r1,qsw_head_size(,r1)        |  one large\n   st    r1,&w.work_segment_size      |  segment.\n   es_obtain_storage id=es,           |  Get storage for large segment.+\n               address=&w.work_segment_address,                        +\n               size=&w.work_segment_size,                              +\n               subpool=&s.sp_qsw,     |                                +\n               boundary=page          |\n   if (treg,r15,nz)                   |  If obtain failed:\n    errexit (ch,r15,eq,=y(&es_storage_not_available)),                 +\n               code=&im_storage_not_available   Fail with appropriate\n    errexit code=&im_internal_error   |          error code.\n   endif                              |  Endif.\n   l     r3,&w.work_segment_address   |  Point r3 to large segment.\n   xc    qsw_head(l'qsw_head),qsw_head   Clear head.\n   mvc   qsw_id,=a(qsw_id_text)       |  Set id.\n   l     r1,&w.work_segment_size      |  Set size\n   st    r1,qsw_size                  |  in new QSW.\n   ar    r1,r3                        |  Set end\n   st    r1,qsw_end                   |  in new QSW.\n   la    r2,qsw_head_size(,r3)        |  R2 is place to start building.\n   l     r3,&w.first_qsw_head         |  Point r3 to first QSW.\n   loop until                         |  Move to large segment:\n    st    r3,&w.current_qsw_segment   |   Save source segment address.\n    l     r0,qsw_next                 |   Save next QSW\n    st    r0,&w.next_qsw              |   address.\n    l     r15,qsw_end                 |   Calculate size\n    la    r3,qsw_head_size(,r3)       |   and address for\n    sr    r15,r3                      |   move from source QSW.\n    loop  until                       |   Move it:\n     if (ch,r15,lt,=h'256')           |    If <= 256 bytes to move:\n      la    r0,0(r15,r2)              |     Save r2 + length.\n      bctr  r15,0                     |     Use EXI\n      exi   r15,(mvc,0(*-*,r2),0(r3)) |     to move\n      sr    r15,r15                   |     last piece.\n      lr    r2,r0                     |     Point r2 to next dest.\n     else                             |    Else:\n      mvc  0(256,r2),0(r3)            |     Move\n      la   r2,256(,r2)                |     256\n      la   r3,256(,r3)                |     bytes\n      sh   r15,=h'256'                |     of source.\n     endif                            |    Endif.\n    endloop until,(treg,r15,z)        |   Endloop.\n    l     r3,&w.current_qsw_segment   |   Point r3 to source QSW.\n    es_release_storage id=es,         |   Release its storage.         +\n               address=&w.current_qsw_segment,                         +\n               size=qsw_size,         |                                +\n               subpool=&s.sp_qsw      |\n    errexit (treg,r15,nz),code=&im_internal_error\n   endloop until,(%l32,r3,&w.next_qsw,z) Loop for all QSWs.\n  endif                               | Endif.\n  drop  r3                            | Drop base for QSW.\n* *-------------------------------------------------------------------*\n* * Get a work stack as big as will ever be needed.\n* *-------------------------------------------------------------------*\n  lh    r1,=y(31*qss_element_size)    | Good for 2 to the 32th\n  st    r1,&w.qss_size                | (4,294,967,296) items.\n  mm_obtain_storage id=mm,            | Get storage for stack.         +\n               address=&w.qss_bottom, | (240 bytes)                    +\n               size=&w.qss_size       |\n  if (treg,r15,nz)                    | If obtain failed:\n   errexit (ch,r15,eq,=y(&mm_storage_not_available)),                  +\n               code=&im_storage_not_available   Fail with appropriate\n   errexit code=&im_internal_error    |         error code.\n  endif                               | Endif.\n  l     r3,&w.qss_bottom              | Point r3 to bottom of stack.\n  st    r3,&w.qss_top                 | Set stack top.\n  lr    r0,r3                         | Set\n  a     r0,&w.qss_size                | stack\n  st    r0,&w.qss_end                 | end.\n* *-------------------------------------------------------------------*\n* * Quicksort using Richard C. Singleton's improvements.\n* *\n* * NOTE: This code assumes that each QSW element is on a double\n* *       word boundary.  Notice the SRL R1,4;SLL R1,3 to divide by 2.\n* *\n* * ALSO: R2 *ALWAYS* points to &w.work and R15 *ALWAYS* points to\n* *       the compare code.\n* *-------------------------------------------------------------------*\n  l     r1,&w.item_counter            | If there is only\n  ch    r1,=h'1'                      | one item,\n  ##b e,singleton_end                 | it must be sorted!\n  la    r2,&w.work                    | Point r2 to work area.\n  l     r15,&p.compare_code           | Point r15 to compare code.\n  l     r1,&w.work_segment_address    |\n  la    r0,qsw_head_size(,r1)         |\n  st    r0,&w.i                       | i = first element.\n  l     r1,qsw_end-qsw_head(,r1)      |\n  sh    r1,=y(qsw_element_size)       |\n  st    r1,&w.j                       | j = last element.\n  st    r0,&w.ii                      | ii = i.\n  ##b u,singleton_l4                  | goto L4.\nsingleton_l1 equ *                    |L1:\n  l     r0,&w.i                       |\n  st    r0,&w.k                       | k = i.\n  l     r1,&w.j                       |\n  st    r1,&w.L                       | L = j.\n  alr   r1,r0                         |\n  srl   r1,4                          |\n  sll   r1,3                          |\n  st    r1,&w.ij                      | ij = (i+j)/2\n  mvc   &w.t,0(r1)                    | t = A(ij)\n  l     r1,&w.i                       |\n  l     r5,qsw_address-qsw_element(,r1)\n  l     r6,&w.t+qsw_address-qsw_element\n  sm_lal r3,singleton_l1_a            |\n  basr  r14,r15                       | if A(i) > t:\n  l     r1,&w.ij                      |\n  l     r14,&w.i                      |\n  mvc   0(qsw_element_size,r1),0(r14) |  A(ij) = A(i).\n  mvc   0(qsw_element_size,r14),&w.t  |  A(i)  = t.\n  mvc   &w.t,0(r1)                    |  t = A(ij).\nsingleton_l1_a equ *                  | endif.\n  l     r5,&w.t+qsw_address-qsw_element\n  l     r1,&w.j                       |\n  l     r6,qsw_address-qsw_element(,r1)\n  sm_lal r3,singleton_l1_b            |\n  basr  r14,r15                       | if A(j) < t:\n  l     r1,&w.ij                      |\n  l     r14,&w.j                      |\n  mvc   0(qsw_element_size,r1),0(r14) |  A(ij) = A(j).\n  mvc   0(qsw_element_size,r14),&w.t  |  A(j)  = t.\n  mvc   &w.t,0(r1)                    |  t = A(ij).\n  l     r1,&w.i                       |\n  l     r5,qsw_address-qsw_element(,r1)\n  l     r6,&w.t+qsw_address-qsw_element\n  sm_lal r3,singleton_l1_c            |\n  basr  r14,r15                       |  if A(i) > t:\n  l     r1,&w.ij                      |\n  l     r14,&w.i                      |\n  mvc   0(qsw_element_size,r1),0(r14) |   A(ij) = A(i).\n  mvc   0(qsw_element_size,r14),&w.t  |   A(i)  = t.\n  mvc   &w.t,0(r1)                    |   t = A(ij).\nsingleton_l1_c equ *                  |  endif.\nsingleton_l1_b equ *                  | endif.\nsingleton_l2   equ *                  |L2:\n  sm_lal r14,singleton_l2_a           |\n  sm_lal r3,singleton_l2_b            | {Some setup}\n  l     r6,&w.t+qsw_address-qsw_element\nsingleton_l2_a equ *                  |\n  l     r1,&w.L                       |\n  sh    r1,=y(qsw_element_size)       |\n  st    r1,&w.L                       | L = L - 1.\n  l     r5,qsw_address-qsw_element(,r1)\n  br    r15                           | if A(L) > t then goto L2.\nsingleton_l2_b equ *                  |\n  l     r1,&w.L                       |\n  mvc   &w.tt,0(r1)                   | tt = A(L).\nsingleton_l3   equ *                  |L3:\n  sm_lal r14,singleton_l3_a           |\n  sm_lal r3,singleton_l3_b            | {Some setup}\n  l     r5,&w.t+qsw_address-qsw_element\nsingleton_l3_a equ *                  |\n  l     r1,&w.k                       |\n  la    r1,qsw_element_size(,r1)      |\n  st    r1,&w.k                       | k = k + 1.\n  l     r6,qsw_address-qsw_element(,r1)\n  br    r15                           | if A(k) < t then goto L3:\nsingleton_l3_b equ *                  |\n  l     r1,&w.k                       |\n  l     r14,&w.L                      |\n  if (cr,r1,le,r14)                   | if k <= L:\n   mvc   0(qsw_element_size,r14),0(r1)   A(L) = A(k).\n   mvc   0(qsw_element_size,r1),&w.tt |  A(k) = tt.\n   ##b u,singleton_l2                 |  goto L2.\n  endif                               | endif.\n  l     r0,&w.L                       |\n  s     r0,&w.i                       |\n  l     r1,&w.j                       |\n  s     r1,&w.k                       |\n  l     r14,&w.qss_top                |\n  using qss,r14                       |\n  if (cr,r0,gt,r1)                    | if L - i > j - k :\n   l     r0,&w.i                      |\n   st    r0,qss_IL                    |  IL(m) = i.\n   l     r0,&w.L                      |\n   st    r0,qss_IU                    |  IU(m) = L.\n   l     r0,&w.k                      |\n   st    r0,&w.i                      |  i = k.\n  else                                | else:\n   l     r0,&w.k                      |\n   st    r0,qss_IL                    |  IL(m) = k.\n   l     r0,&w.j                      |\n   st    r0,qss_IU                    |  IU(m) = j.\n   l     r0,&w.L                      |\n   st    r0,&w.j                      |  j = L.\n  endif                               | endif.\n  la    r14,qss_element_size(,r14)    |\n  st    r14,&w.qss_top                | m = m + 1.\n  drop  r14                           |\nsingleton_l4 equ *                    |L4:\n  l     r1,&w.j                       |\n  s     r1,&w.i                       |\n  ch    r1,=y(qsw_element_size*10)    | if j - i > 10 then\n  ##b h,singleton_l1                  |   goto L1.\n  l     r1,&w.i                       |\n  if (c,r1,eq,&w.ii)                  | if i = ii :\n   c     r1,&w.j                      |  if i < j then\n   ##b l,singleton_l1                 |    goto L1.\n  endif                               | endif.\n  loop until                          | for i = i + 1 step 1 until j:\n   l     r1,&w.i                      |\n   la    r1,qsw_element_size(,r1)     |\n   st    r1,&w.i                      |\n   leave loop=*,(c,r1,gt,&w.j)        |\n   mvc   &w.t,0(r1)                   |  t = A(i).\n   sh    r1,=y(qsw_element_size)      |\n   st    r1,&w.k                      |  k = i - 1.\n   l     r5,qsw_address-qsw_element(,r1)\n   l     r6,&w.t+qsw_address-qsw_element\n   sm_lal r3,singleton_l5_a           |\n   basr  r14,r15                      |  if A(k) > t:\nsingleton_l5 equ *                    |L5:\n   l     r1,&w.k                      |\n   la    r14,qsw_element_size(,r1)    |\n   mvc   0(qsw_element_size,r14),0(r1)    A(k+1) = A(k).\n   sh    r1,=y(qsw_element_size)      |\n   st    r1,&w.k                      |   k = k - 1.\n   l     r5,qsw_address-qsw_element(,r1)\n   sm_lal r14,singleton_l5            |\n   basr  r3,r15                       |   if A(k) > t then goto L5.\n   l     r1,&w.k                      |\n   la    r1,qsw_element_size(,r1)     |\n   mvc   0(qsw_element_size,r1),&w.t  |   A(k+1) = t.\nsingleton_l5_a equ *                  |  endif.\n  endloop until,leave                 | endfor.\n  l     r1,&w.qss_top                 |\n  if (c,r1,gt,&w.qss_bottom)          |\n   sh    r1,=y(qss_element_size)      | m = m - 1.\n   st    r1,&w.qss_top                |\n   using qss_element,r1               | if m >= 0:\n   l     r0,qss_IL                    |\n   st    r0,&w.i                      |  i = IL(m).\n   l     r0,qss_IU                    |\n   st    r0,&w.j                      |  j = IU(m).\n   drop  r1                           |\n   ##b u,singleton_l4                 |  goto L4.\n  endif                               | endif.\nsingleton_end equ *                   | End of sort.\n* *-------------------------------------------------------------------*\n* * Now update links in list.\n* *-------------------------------------------------------------------*\n  l     r3,&w.work_segment_address    | Point r3 to\n  la    r3,qsw_head_size(,r3)         | first qsw element.\n  using qsw_element,r3                | Establish base.\n  l     r4,&p.first_ptr_addr          | Update pointer\n  mvc   0(4,r4),qsw_token             | in head for first item.\n  sr    r2,r2                         | Set prior item to null.\n  l     r15,&w.item_counter           | Load r15 with number of items.\n  loop bct                            | Process each item in list:\n   l     r4,qsw_address               |  Calculate\n   if (tbit,&w.itc_f,&w.itc_f_variable_links_offset),or,               +\n               (clc,&w.itc_itype,ne,0(r4)) If characteristics\n    l     r1,qsw_token                |    for last\n    st    r1,&w.itc_token             |    item are\n    la    r1,&w.itc_                  |    not close\n    callsub get_itc                   |    enough, call\n   endif                              |    subroutine to get ITC.\n   a     r4,&w.itc_offset_links       |  address\n   a     r4,&p.next_link_offset_in_links of next link.\n   if (ch,r15,gt,=h'1')               |  If this is not last item:\n    l     r0,qsw_token+qsw_element_size   Use token in next QSW elem.\n   else                               |  Else:\n    l32   r5,&p.final_ptr_addr        |   Update pointer\n    if    nz,then                     |    in head for final\n      mvc 0(4,r5),qsw_token           |    item if there is a\n    endif                             |    final link in the head.\n    sr    r0,r0                       |   Next link is zero.\n   endif                              |  Endif.\n   st    r0,0(,r4)                    |  Store next link in item.\n   l32   r4,&p.prior_link_offset_in_links\n   if nm                              |  If there are prior links:\n    l     r4,qsw_address              |   Point r4 to item.\n    if (tbit,&w.itc_f,&w.itc_f_variable_links_offset),or,              +\n               (clc,&w.itc_itype,ne,0(r4)) If characteristics\n     l     r1,qsw_token               |     for last\n     st    r1,&w.itc_token            |     item are\n     la    r1,&w.itc_                 |     not close\n     callsub get_itc                  |     enough, call\n    endif                             |     subroutine to get ITC.\n    a     r4,&p.prior_link_offset_in_links Calculate address\n    a     r4,&w.itc_offset_links      |   of prior link.\n    st    r2,0(,r4)                   |   Store token of prior item.\n    l     r2,qsw_token                |   Set new prior for next time.\n   endif                              |  Endif.\n   la     r3,qsw_element_size(,r3)    |  Point to next QSW.\n  endloop bct,r15                     | Endloop.\n  drop  r3                            | Drop base for QSW element.\n* *-------------------------------------------------------------------*\n* * Free Quicksort work area and stack.\n* *-------------------------------------------------------------------*\n  es_release_storage id=es,           |  Release Quicksort work area.  +\n               address=&w.work_segment_address,                        +\n               size=&w.work_segment_size,                              +\n               subpool=&s.sp_qsw      |\n  errexit (treg,r15,nz),code=&im_internal_error\n  mm_release_storage id=mm,           |  Release Quicksort stack.      +\n               address=&w.qss_bottom, |                                +\n               size=&w.qss_size       |\n  errexit (treg,r15,nz),code=&im_internal_error\n* *-------------------------------------------------------------------*\n endblk block=Quicksort               |\n         ssd ,                        |\n&s.qsw_segment_size   dc a(16*1024)   |\n&s.sp_qsw             dc f'0'         | Subpool for QSW.\n         endssd ,                     |\nqsw      dsect ,                      |\nqsw_head                    ds    0f  |\nqsw_id                      ds    f   |\nqsw_id_text             equ c\"QSW \"   |\nqsw_size                    ds    f   |\nqsw_next                    ds    a   |\nqsw_end                     ds    a   |\n                            ds    0d  |\nqsw_head_size equ *-qsw_head          |\nqsw_head_end  equ *                   |\nqsw_element                 ds    0f  |\nqsw_token                   ds    f   |\nqsw_address                 ds    a   |\nqsw_element_size equ *-qsw_element    |\nqss      dsect ,                      |\nqss_element                 ds    0f  |\nqss_IL                      ds    a   |\nqss_IU                      ds    a   |\nqss_element_size equ *-qss_element    |\n         swa ,                        |\n&w.work                       ds 2d   |\n&w.dummy_qsw_head ds 0f,xl(qsw_head_size)\n&w.first_qsw_head equ &w.dummy_qsw_head+qsw_next-qsw_head,4,c\"X\"\n&w.current_qsw_segment        ds a    |\n&w.end_of_segment             ds a    |\n&w.work_segment_address       ds a    |\n&w.work_segment_size          ds f    |\n&w.item_counter               ds f    |\n&w.next_qsw                   ds a    |\n&w.qss_size                   ds f    |\n&w.qss_bottom                 ds a    |\n&w.qss_top                    ds a    |\n&w.qss_end                    ds a    |\n&w.i                          ds a    |\n&w.j                          ds a    |\n&w.ii                         ds a    |\n&w.ij                         ds a    |\n&w.k                          ds a    |\n&w.L                          ds a    |\n&w.t            ds xl(qsw_element_size)\n&w.tt           ds xl(qsw_element_size)\n         itc id=&w.itc_               |\n         endswa                       |\n eject                                |\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Copy_item\n*  Abstract:   This subroutine copys an item from item managed\n*              storage to a return area that is not in item managed\n*              storage.\n*  Parameters: (>itc,>return_area_size,<return_area,<actual_item_size|)\n*\n*---------------------------------------------------------------------*\n block name=copy_item,type=subroutine,                                 +\n               parms=(itc,return_area_size,return_area,                +\n               actual_item_size)      |\n* *-------------------------------------------------------------------*\n* * Make sure that return area is large enough.  Return actual size\n* * if requested.\n* *-------------------------------------------------------------------*\n  l     r3,&p.itc                     | Point r3 to ITD.\n  using itc_,r3                       | Establish base for ITD.\n  l32   r1,&p.return_area_size        | Load r1 with\n  errexit z,code=&im_invalid_return_area_size\n  l     r1,0(,r1)                     | return area size.\n  errexit (c,r1,lt,itc_size),         | Error if area is not large     +\n               code=&im_invalid_return_area_size   enough.\n  l32   r1,&p.actual_item_size        | Move size of\n  if nz                               |  item to return\n   mvc   0(4,r1),itc_size             |  field, if\n  endif                               |  requested.\n* *-------------------------------------------------------------------*\n* * Copy the item.\n* *-------------------------------------------------------------------*\n  l     r15,itc_size                  | Load size of item.\n  l     r6,itc_address                | Point r6 to item in storage.\n  l     r2,&p.return_area             | Point r2 to return area.\n  loop until                          | Move item to return area.\n   ltr   r1,r15                       |  Load r1 with remaining\n   leave np,loop=*                    |  move length.  Finished if\n*                                     |  length is not positive.\n   if (ch,r1,gt,=h'256')              |  Can only move\n    la    r1,256                      |  up to 256 bytes\n   endif                              |  at a time.\n   sr    r15,r1                       |  Calc new remaining length.\n   bctr  r1,0                         |  Move up to 256\n   exi   r1,(mvc,0(*-*,r2),0(r6))     |  bytes of item.\n   la    r2,256(,r2)                  |  Point to next 256 bytes\n   la    r6,256(,r6)                  |  of item.\n  endloop until,leave                 | Endloop.\n* *-------------------------------------------------------------------*\n endblk block=copy_item               |\n eject                                |\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Obtain_item_storage\n*  Abstract:   This subroutine will get some item storage of the\n*              specified size.\n*  Parameters: (>grd_token,>size,<Item_token,<Item_address)\n*  Returncode: 0 - Went ok.\n*              4 - Could not obtain memory.\n*              CC - Set to reflect return code.\n*\n*---------------------------------------------------------------------*\n block name=obtain_item_storage,type=subroutine,                       +\n               parms=(grd_token,item_size,item_token,item_address)\n          space 1                     |\n* *-------------------------------------------------------------------*\n* * If the number of spare GSS entries is below min, get more in case\n* * they are needed.\n* *-------------------------------------------------------------------*\n  l     r4,pwa_imc_address            | Point r4 to IMC.\n  using imc,r4                        | Establish base for IMC.\n  if (clc,imc#sgss,lt,psd_min_spare_gsss) If the number of spare GSSs\n   callsub replenish_spare_gsss       |   is below min, get more.\n  endif                               | Endif.\n* *-------------------------------------------------------------------*\n* * Get and adjust item size.\n* *-------------------------------------------------------------------*\n  l     r1,&p.item_size               | Load pointer to item size.\n  l     r1,0(,r1)                     | Load item size.\n  callsub adjust_item_size            | Adjust size to valid size.\n  st    r1,&w.item_size               | Save item size in SWA.\n* *-------------------------------------------------------------------*\n* * Get storage for item.\n* *-------------------------------------------------------------------*\n  callsub get_free_storage,           | Locate some free storage.      +\n               (*&p.grd_token,        |                                +\n               &w.item_size,          |                                +\n               *&p.item_token,        |                                +\n               *&p.item_address)      |\n* *-------------------------------------------------------------------*\n* * If there was not enough free space, get a new segment for the\n* * group.\n* *-------------------------------------------------------------------*\n  if (treg,r15,nz)                    | If there was not freespace:\n*  *------------------------------------------------------------------*\n*  * Get a new segment.\n*  *------------------------------------------------------------------*\n   callsub get_a_new_segment,         | Make a new segment             +\n               (*&p.grd_token,        |                                +\n               &w.item_size)          |\n   errexit (treg,r15,nz),code=&im_internal_error\n*  *------------------------------------------------------------------*\n*  * Try again to locate storage for the item.  If storage is still\n*  * not available, there is an internal error.\n*  *------------------------------------------------------------------*\n   callsub get_free_storage,          | Locate some free storage.      +\n               (*&p.grd_token,        |                                +\n               &w.item_size,          |                                +\n               *&p.item_token,        |                                +\n               *&p.item_address)      |\n   errexit (treg,r15,nz),code=&im_internal_error\n*  *------------------------------------------------------------------*\n  endif                               |\n endblk block=obtain_item_storage     |\n space 1                              |\n          swa   ,                     |\n&w.item_size                 ds  a    |\n          endswa ,                    |\n eject                                |\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Free_item_storage\n*  Abstract:   This subroutine will free item storage for the\n*              specified size.\n*  Parameters: (>grd_token,>size,>Item_token,>Item_address)\n*\n*---------------------------------------------------------------------*\n block name=free_item_storage,type=subroutine,                         +\n               parms=(grd_token,item_size,item_token,item_address)\n* *-------------------------------------------------------------------*\n* * Move parameters to work area.\n* *-------------------------------------------------------------------*\n  mvi   &w.f1,0                       | Reset all flag.\n  l     r1,&p.item_token              | Move item token to\n  mvc   &w.fsi_token,0(r1)            | work area.\n  l     r1,&p.item_size               | Load size\n  l     r1,0(,r1)                     | of item.\n  callsub adjust_item_size            | Adjust the size.\n  st    r1,&w.item_size               | Store it in SWA.\n  l     r1,&p.grd_token               | Move GRD token\n  mvc   &w.grd_token,0(r1)            | to work area.\n  l     r1,&p.item_address            | Move item address\n  mvc   &w.item_address,0(r1)         | to work area.\n* *-------------------------------------------------------------------*\n* * Establish base for GRD and find appropriate GSS.\n* *-------------------------------------------------------------------*\n  imlta r4,&w.grd_token               | Point r4 to GRD.\n  errexit nz,or,(treg,r4,z),          | Error if invalid or null.      +\n               code=&im_internal_error\n  using grd,r4                        | Establish base for GRD.\n  using gss,r5                        | R5 will be used for GSS base.\n  l    r3,grdfrgss                    | Set r3 to token of first GSS.\n  fill &w.previous_gss_address,x'00'  | Clear GSS previous address.\n  loop until                          | Loop searching for correct GSS.\n   imlta r5,r3                        |  Convert GSS token to address.\n   errexit nz,or,(treg,r5,z),         |  Error if invalid or null.     +\n               code=&im_internal_error\n   l     r1,&w.fsi_token              |  Load r1 with token of item.\n   l     r2,gssstart                  |  If the new token\n   if (clr,r1,ge,r2)                  |  is within the bounds\n    a     r2,gsssize                  |  of the segment described\n    leave loop=*,(cr,r1,lt,r2)        |  by this GSS, the search\n   endif                              |  is over.\n   st    r5,&w.previous_gss_address   |  Save this address as previous.\n   l     r3,gssnxgss                  |  Load token of next GSS.\n  endloop until,leave                 | Endloop.\n  st    r3,&w.gss_token               | Save GSS token.\n* *-------------------------------------------------------------------*\n* * Clear the item storage.\n* *-------------------------------------------------------------------*\n  l     r6,&w.item_address            | Point r6 to item.\n  l     r15,&w.item_size              | Load r15 with size of item.\n  loop until                          | Clear item storage.\n   ltr   r1,r15                       |  Load r1 with remaining\n   leave np,loop=*                    |  length.  Finished if\n*                                     |  length is not positive.\n   if (ch,r1,gt,=h'256')              |  Can only clear\n    la    r1,256                      |  up to 256 bytes\n   endif                              |  at a time.\n   sr    r15,r1                       |  Calc new remaining length.\n   bctr  r1,0                         |  Clear up to 256\n   exi   r1,(xc,0(*-*,r6),0(r6))      |  bytes of item.\n   la    r6,256(,r6)                  |  of item.\n  endloop until,leave                 | Endloop.\n* *-------------------------------------------------------------------*\n* * Update the GSSUSED field.  If it has gone to zero, set up to\n* * free the whole segment instead of just the item.\n* *-------------------------------------------------------------------*\n  l     r1,gssused                    | Update\n  s     r1,&w.item_size               | GSS used\n  st    r1,gssused                    | field.\n  if (treg,r1,z)                      | If the amount used is zero:\n*  *------------------------------------------------------------------*\n*  * Clear storage of FSIs in segment.\n*  *------------------------------------------------------------------*\n   l     r0,gssfrfsi                  |  Load r0 with first FSI token.\n   loop until                         |  Loop through all FSI in group.\n    imlta r6,r0                       |   Convert token to address.\n    errexit nz,code=&im_internal_error    Error if invalid.\n    leave loop=*,(treg,r6,z)          |   Finished if end of chain.\n    using fsi,r6                      |   Establish base for FSI.\n    l     r0,fsinxfsi                 |   Load r0 with next FSI token.\n    xc    fsi(fsiitmsz),fsi           |   Clear this FSI.\n    drop  r6                          |   Drop base for FSI.\n   endloop until,leave                |  Endloop.\n*  *------------------------------------------------------------------*\n*  * Set up to free the whole segment.\n*  *------------------------------------------------------------------*\n   mvc   &w.item_size,gsssize         |  Make it look to\n   mvc   &w.fsi_token,gssstart        |  the rest of the\n   imlta &w.item_address,gssstart     |  block like the\n   errexit nz,code=&im_internal_error |  whole segment is\n   l32   r6,&w.previous_gss_address   |  the item to free.\n   if z                               |  If this is first GSS in chain,\n    mvc   grdfrgss,gssnxgss           |  update first GSS token in GRD;\n   else                               |  otherwise, update next GSS\n    mvc   gssnxgss-gss(4,r6),gssnxgss |  token in previous GSS.\n   endif                              |\n   xc    gss+2(gssitmsz-2),gss+2      |  Clear the GSS except for type.\n   using imc,r4                       |  Use r4 as base for IMC.\n   l     r4,pwa_imc_address           |  Change the GRD\n   l     r0,imcgrdua                  |  token to be used to\n   st    r0,&w.grd_token              |  the unallocated group's GRD.\n   mvc   gssnxgss,imcspgss            |  Chain GSS on free chain of\n   mvc   imcspgss,&w.gss_token        |  GSSs.\n   drop  r4                           |  Drop base for IMC.\n   imlta r4,r0                        |  Point r4 to unallocated GRD.\n   using grd,r4                       |  Establish base for GRD.\n   errexit nz,or,(treg,r4,z),         |  Error if invalid or null.     +\n               code=&im_internal_error\n*  *------------------------------------------------------------------*\n*  * Unchain the GSS from GRD GSS chain and place the GSS on the\n*  * free GSS chain.\n*  *------------------------------------------------------------------*\n   l    r3,grdfrgss                   |  Set r3 to token of first GSS.\n   fill &w.previous_gss_address,x'00' |  Clear GSS previous token.\n   loop until                         |  Loop searching for correct GSS\n    imlta r5,r3                       |   Convert GSS token to address.\n    errexit nz,or,(treg,r5,z),        |   Error if invalid or null.    +\n               code=&im_internal_error\n    l     r1,&w.fsi_token             |   Load r1 with token of item.\n    l     r2,gssstart                 |   If the new token\n    if (clr,r1,ge,r2)                 |   is within the bounds\n     a     r2,gsssize                 |   of the segment described\n     leave loop=*,(cr,r1,lt,r2)       |   by this GSS, the search\n    endif                             |   is over.\n    st    r5,&w.previous_gss_address  |   Save this address as prev.\n    l     r3,gssnxgss                 |   Load token of next GSS.\n   endloop until,leave                |  Endloop.\n   st    r3,&w.gss_token              |  Save GSS token.\n   l     r1,gssused                   |  Update\n   s     r1,&w.item_size              |  GSS used\n   if z                               |  field and\n    sbit  &w.f1,&w.f1_ua_segment_free |  set flag\n   endif                              |  if it is\n   st    r1,gssused                   |  zero.\n  endif                               | Endif.\n* *-------------------------------------------------------------------*\n* * Make a free space item in the item storage.\n* *-------------------------------------------------------------------*\n  l     r6,&w.item_address            | Point r6 to free space.\n  using fsi,r6                        | Establish base for FSI.\n  mvc   fsiitype,grdtdfsi+2           | Move item type to FSI.\n  mvc   fsinu1,=h'-1'                 | Set unused field to -1.\n  mvc   fsisize,&w.item_size          | Move size to FSI.\n* *-------------------------------------------------------------------*\n* * Put this FSI in the free space chain.  The Free space chain is\n* * keep in accending order.  Maintain the GSSLRGST.\n* *-------------------------------------------------------------------*\n  l     r1,&w.fsi_token               | Load r1 with token of new FSI.\n  l32   r3,gssfrfsi                   | FSI chained off of GSS.\n  if z                                | If chain is empty:\n   st    r1,gssfrfsi                  |  The new FSI is whole chain.\n* *-------------------------------------------------------------------*\n* * If chain is not empty, find place to put FSI.\n* *-------------------------------------------------------------------*\n  else                                | If the chain is not empty:\n*  *------------------------------------------------------------------*\n*  * If this FSI should be the new first in chain, put it there.\n*  *------------------------------------------------------------------*\n   if (clr,r1,lt,r3)                  |  If new FSI should go at start\n    st    r3,fsinxfsi                 |  of chain, link it in.\n    st    r1,gssfrfsi                 |\n*  *------------------------------------------------------------------*\n*  * If the FSI should not be ther first, find where it belongs and\n*  * put it there.\n*  *------------------------------------------------------------------*\n   else                               |  If should not go at head:\n*   *-----------------------------------------------------------------*\n*   * Loop through FSIs until the correct place for the new FSI is\n*   * found and place it there.\n*   *-----------------------------------------------------------------*\n    loop until                        |   Search for correct place.\n*    *----------------------------------------------------------------*\n*    * R6 will point to the new FSI.  R7 will be used to point to the\n*    * current FSI in the chain.\n*    *----------------------------------------------------------------*\n     imlta r7,r3                      |    Point r7 to current FSI.\n     errexit nz,code=&im_internal_error    Error if invalid.\n*    *----------------------------------------------------------------*\n*    * If the new FSI is immediately after the current FSI, consolidate\n*    * them and leave loop.\n*    *----------------------------------------------------------------*\n     l     r1,&w.fsi_token            |    Load r1 with tkn of new FSI.\n     lr    r0,r3                      |    Calculate token of next\n     al    r0,fsisize-fsi(,r7)        |    item after current FSI.\n     if (clr,r0,eq,r1)                |    If it is the new FSI:\n      l     r0,fsisize-fsi(,r7)       |     Consolidate\n      al    r0,fsisize                |     the\n      st    r0,fsisize-fsi(,r7)       |     two\n      xc    0(fsiitmsz,r6),0(r6)      |     FSIs.\n      lr    r1,r3                     |     Consolidated FSI will be\n      lr    r6,r7                     |     treated as new FSI now.\n      st    r1,&w.fsi_token           |     Save token of new FSI.\n      leave loop=*                    |     Leave loop.\n     endif                            |    Endif.\n*    *----------------------------------------------------------------*\n*    * Load token of next FSI in chain.  If the new FSI should go\n*    * before this next FSI, chain it in and leave the loop.\n*    *----------------------------------------------------------------*\n     l32   r3,fsinxfsi-fsi(r7)        |    Load r3 with next FSI token.\n     if (clr,r1,lt,r3),or,            |    If new FSI should go before:+\n               (treg,r3,z)            |\n      st    r0,fsinxfsi               |     Chain the new\n      st    r1,fsinxfsi-fsi(,r7)      |     FSI after the current\n      leave loop=*                    |     FSI.\n     endif                            |    Endif.\n*    *----------------------------------------------------------------*\n    endloop until,leave               |   Endloop.\n   endif                              |  Endif.\n*  *------------------------------------------------------------------*\n*  * If an FSI immediately follows the new FSI, consolidate it into\n*  * the new FSI.\n*  *------------------------------------------------------------------*\n   l     r1,&w.fsi_token              |  Load r1 with tkn of new FSI.\n   al    r1,fsisize                   |  If next item after the new\n   if (cl,r1,eq,fsinxfsi)             |  FSI is the next FSI:\n    lr    r7,r6                       |   Consolidate\n    al    r7,fsisize                  |   the\n    mvc   fsinxfsi,fsinxfsi-fsi(r7)   |   next\n    l     r0,fsisize-fsi(,r7)         |   FSI\n    al    r0,fsisize                  |   into\n    st    r0,fsisize                  |   the\n    xc    0(fsiitmsz,r7),0(r7)        |   new FSI.\n   endif                              |  Endif.\n  endif                               | Endif.\n* *-------------------------------------------------------------------*\n* * If a whole segment is being freed and the amount used in the\n* * resulting unassigned storage segment is zero, consolidate the\n* * previous and next unassigned segment if they are back to back.\n* *-------------------------------------------------------------------*\n  if (tbit,&w.f1,&w.f1_ua_segment_free) If condition is met:\n*  *------------------------------------------------------------------*\n*  * If previous segment in just before this one and it is empty,\n*  * consolidate it with this one.\n*  *------------------------------------------------------------------*\n   l32   r7,&w.previous_gss_address   |  Point r7 to previous GSS.\n   if nz,and,(clc,gssused-gss(4,r7),eq,=f'0') If prev segment empty:\n    l     r0,gssstart-gss(,r7)        |   If previous segment\n    al    r0,gsssize-gss(,r7)         |   is just before\n    if (cl,r0,eq,&w.fsi_token)        |   this segment:\n     imlta r8,gssfrfsi-gss(,r7)       |    Point r8 to previous FSI.\n     errexit nz,code=&im_internal_error    Error if invalid.\n     l     r0,fsisize-fsi(,r8)        |    Adjust size of free space\n     al    r0,fsisize                 |    in previous segment\n     st    r0,fsisize-fsi(,r8)        |    to include new free space.\n     st    r0,gsssize-gss(,r7)        |    Update size and\n     st    r0,gsslrgst-gss(,r7)       |    largest.\n     mvc   gssnxgss-gss(4,r7),gssnxgss     Set next pointer.\n     xc    fsi(fsiitmsz),fsi          |    Clear unused FSI storage.\n     lr    r6,r8                      |    Point r6 to consolidated FS.\n     xc    gss+2(gssitmsz-2),gss      |    Clear unused GSS.\n     l     r8,pwa_imc_address         |    Point r8 to IMC.\n     using imc,r8                     |    Establish base for IMC.\n     mvc   gssnxgss,imcspgss          |    Chain unused GSS onto\n     mvc   imcspgss,&w.gss_token      |    spare GSS chain.\n     drop  r8                         |    Drop base for IMC.\n     lr    r5,r7                      |    Point to consolidated GSS.\n    endif                             |   Endif.\n   endif                              |  Endif.\n*  *------------------------------------------------------------------*\n*  * If next segment is just after this one, consolidate it with\n*  * this one.\n*  *------------------------------------------------------------------*\n   imlta r7,gssnxgss                  |  Point r7 to next GSS.\n   errexit nz,code=&im_internal_error |  Error if invalid.\n   if (treg,r7,nz),and,               |  If next segment is empty:     +\n               (clc,gssused-gss(4,r7),eq,=f'0')\n    l     r0,gssstart                 |   If segment is\n    al    r0,gsssize                  |   just after\n    if (cl,r0,eq,gssstart-gss(,r7))   |   this one:\n     imlta r8,gssfrfsi-gss(,r7)       |    Point r8 to next FSI.\n     errexit nz,code=&im_internal_error    Error if invalid.\n     l     r0,fsisize-fsi(,r8)        |    Adjust size of free space\n     al    r0,fsisize                 |    to include free space\n     st    r0,fsisize                 |    in next segment.\n     st    r0,gsssize                 |    Update size and\n     st    r0,gsslrgst                |    largest.\n     l     r0,gssnxgss                |    Save token of next GSS.\n     mvc   gssnxgss,gssnxgss-gss(r7)  |    Unchain next GSS.\n     xc    0(fsiitmsz,r8),0(r8)       |    Clear unused FSI storage.\n     xc    2(gssitmsz-2,r7),2(r7)     |    Clear unused GSS.\n     l     r8,pwa_imc_address         |    Point r8 to IMC.\n     using imc,r8                     |    Establish base for IMC.\n     mvc   gssnxgss-gss(4,r7),imcspgss     Chain unused GSS onto\n     st    r0,imcspgss                |    spare GSS chain.\n     drop  r8                         |    Drop base for IMC.\n    endif                             |   Endif.\n   endif                              |  Endif.\n*  *------------------------------------------------------------------*\n*  * If this GSS is at end of chain, release the storage and leave\n*  * the block.\n*  *------------------------------------------------------------------*\n   if (clc,gssnxgss,eq,=f'0')         |\n*>>> need code.                       |\n   endif                              |\n  endif                               | Endif.\n* *-------------------------------------------------------------------*\n* * If this FSI is larger then the previous largest FSI, update\n* * GSSLRGST.\n* *-------------------------------------------------------------------*\n  if (clc,fsisize,gt,gsslrgst)        | If this new FSI is largest:\n   mvc   gsslrgst,fsisize             |  Indicate this in GSS.\n  endif                               | Endif.\n* *-------------------------------------------------------------------*\n endblk block=free_item_storage       |\n space 1                              |\n          swa   ,                     |\n&w.fsi_token                 ds  f    |\n&w.grd_token                 ds  f    |\n&w.gss_token                 ds  f    |\n&w.previous_gss_address      ds  f    |\n&w.item_address              ds  f    |\n&w.item_size                 ds  f    |\n&w.f1                        ds  bl1  |\n&w.f1_ua_segment_free equ b'10000000' |\n          endswa ,                    |\n eject                                |\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Replenish_Spare_GSSs\n*  Abstract:   This subroutine will get some item storage of the\n*              specified size.\n*\n*---------------------------------------------------------------------*\n block name=replenish_spare_gsss,type=subroutine,options=noparms\n* *-------------------------------------------------------------------*\n* * Establish base for IMC.\n* *-------------------------------------------------------------------*\n  l     r4,pwa_imc_address            | Point r4 to IMC.\n  using imc,r4                        | Establish base for IMC.\n* *-------------------------------------------------------------------*\n* * Calculate number of GSSs needed to get back up to max and the\n* * amount of storage that will be required.\n* *-------------------------------------------------------------------*\n  l     r1,psd_max_spare_gsss         | Calcuate the number\n  s     r1,imc#sgss                   | needed to get back to max.\n  errexit np,code=&im_internal_error  | Error if not a postive number.\n  st    r1,&w.number_needed           | Save the number.\n  mh    r1,=y(gssitmsz)               | Calculate the storage needed.\n  callsub adjust_item_size            | Adjust size to valid size.\n  st    r1,&w.storage_needed          | Save item size in SWA.\n* *-------------------------------------------------------------------*\n* * Get storage for new GSSs in system storage.\n* *-------------------------------------------------------------------*\n  callsub get_free_storage,           | Locate some free storage.      +\n               (imcgrdsy,             |                                +\n               &w.storage_needed,     |                                +\n               &w.gsss_token,         |                                +\n               &w.gsss_address)       |\n* *-------------------------------------------------------------------*\n* * If there was not enough free space, get a new segment of system\n* * storage.\n* *-------------------------------------------------------------------*\n  if (treg,r15,nz)                    | If there was not freespace:\n*  *------------------------------------------------------------------*\n*  * Get a new segment.\n*  *------------------------------------------------------------------*\n   callsub get_a_new_segment,         | Make a new segment             +\n               (imcgrdsy,&w.storage_needed)\n   errexit (treg,r15,nz),code=&im_internal_error\n*  *------------------------------------------------------------------*\n*  * Try again to locate storage for the item.  If storage is still\n*  * not available, there is an internal error.\n*  *------------------------------------------------------------------*\n   callsub get_free_storage,          | Locate some free storage.      +\n               (imcgrdsy,             |                                +\n               &w.storage_needed,     |                                +\n               &w.gsss_token,         |                                +\n               &w.gsss_address)       |\n   errexit (treg,r15,nz),code=&im_internal_error\n*  *------------------------------------------------------------------*\n  endif                               |\n* *-------------------------------------------------------------------*\n* * Initialize the new spare GSSs and add to spare chain.\n* *-------------------------------------------------------------------*\n  l     r5,&w.gsss_address            | Point r5 to new storage.\n  l     r15,&w.number_needed          | Load r15 with number.\n  l     r0,imcspgss                   | Load r0 with first old spare.\n  l     r1,&w.gsss_token              | Load r1 with token of first new\n  using gss,r5                        | Establish base for GSS.\n  loop bct                            | Loop the \"number needed\" times.\n   mvc   gssitype,imctdgss+2          |  Set item type for GSS.\n   st    r0,gssnxgss                  |  Set next GSS.\n   la    r5,gssitmsz(,r5)             |  Increment to\n   lr    r0,r1                        |  next GSS address\n   la    r1,gssitmsz(r1)              |  and token.\n  endloop bct,r15                     | Endloop.\n  st   r0,imcspgss                    | Store new head in IMC.\n  mvc  imc#sgss,psd_max_spare_gsss    | Set the number of spare GSSs.\n* *-------------------------------------------------------------------*\n endblk block=replenish_spare_gsss    |\n space 1                              |\n          swa   ,                     |\n&w.storage_needed            ds  a    |\n&w.number_needed             ds  f    |\n&w.gsss_token                ds  f    |\n&w.gsss_address              ds  a    |\n          endswa ,                    |\n eject                                |\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Get_a_new_segment\n*  Abstract:   This subroutine will get a new segment of storage.\n*  Parameters: (>grd_token,<segment_token,<segment_address)\n*  Returncode: 0 - Went ok.\n*              4 - Could not obtain memory.\n*              CC - Set to reflect return code.\n*\n*---------------------------------------------------------------------*\n block name=get_a_new_segment,type=subroutine,                         +\n               parms=(grd_token,min_size)\n* *-------------------------------------------------------------------*\n* * Use r5 as base for IMC and r6 as base for the GRD associated\n* * with the segment being created.\n* *-------------------------------------------------------------------*\n  l     r5,pwa_imc_address            | Load r5 with address of IMC.\n  using imc,r5                        | Establish base for IMC.\n  imlta r6,*&p.grd_token              | Load r6 with addr of item's\n  using grd,r6                        | GRD and establish base.\n  errexit nz,code=&im_internal_error  | Bad news if not valid token.\n* *-------------------------------------------------------------------*\n* * Locate free storage for the new segment from unassigned storage.\n* *-------------------------------------------------------------------*\n  l     r1,&p.min_size                | If size\n  l     r1,0(,r1)                     | needed is\n  l     r0,grdincsz                   | larger than\n  if (cr,r1,gt,r0)                    | a normal\n   la    r0,4095(,r1)                 | segement,\n   srl   r0,12                        | get a\n   sll   r0,12                        | larger\n  endif                               | segment.\n  st    r0,&w.size_needed             | Save size needed.\n  callsub get_free_storage,           | Locate some free storage.      +\n               (imcgrdua,             |                                +\n               &w.size_needed,        |                                +\n               &w.segment_token,      |                                +\n               &w.segment_address)    |\n* *-------------------------------------------------------------------*\n* * If there is not room for the segment in the unallocated group,\n* * get a new segment for the unallocated group and try again.\n* *-------------------------------------------------------------------*\n  if (treg,r15,nz)                    | If there was not free space:\n*  *------------------------------------------------------------------*\n*  * Use r7 as base for unallocated group's GRD.  Make sure that the\n*  * increment is large enough to hold a new segement for the\n*  * group.\n*  *------------------------------------------------------------------*\n   imlta r7,imcgrdua                  |  Point r7 to GRD for\n   errexit nz,code=&im_internal_error |  unassigned storage.\n   l     r0,grdincsz-grd(,r7)         |  Load increment\n   if (c,r0,lt,&w.size_needed)        |  size and make\n    l     r0,&w.size_needed           |  sure that it\n    ah    r0,=h'4095'                 |  is large enough to\n    srl   r0,12                       |  hold the new increment\n    sll   r0,12                       |  for the item's group.\n   endif                              |\n   st    r0,&w.increment_needed       |  Save increment needed.\n*  *------------------------------------------------------------------*\n*  * Extend the size of the data space.\n*  *------------------------------------------------------------------*\n   callsub get_data_space_increment,  |  Extend data space.            +\n               (&w.increment_needed,  |                                +\n               &w.increment_token,    |                                +\n               &w.increment_address)  |\n*  *------------------------------------------------------------------*\n*  * Make a new freespace for the unassigned group in this space.\n*  *------------------------------------------------------------------*\n   callsub initialize_new_freespace,  |  Make a free space in          +\n               (imcgrdua,             |   the new extention for        +\n               &w.increment_needed,   |   unassigned storage.          +\n               &w.increment_token,    |                                +\n               &w.increment_address)  |\n*  *------------------------------------------------------------------*\n*  * Try again to get space for a new segment of the group associated\n*  * with the item being obtained.  If there is still no space, there\n*  * is an internal error.\n*  *------------------------------------------------------------------*\n   callsub get_free_storage,          |  Locate some free storage.     +\n               (imcgrdua,             |                                +\n               &w.size_needed,        |                                +\n               &w.segment_token,      |                                +\n               &w.segment_address)    |\n   errexit (treg,r15,nz),code=&im_internal_error\n*  *------------------------------------------------------------------*\n  endif                               | Endif.\n* *-------------------------------------------------------------------*\n* * Make a new freespace for the item's group in the space obtained\n* * from the unassigned storage group.\n* *-------------------------------------------------------------------*\n  callsub initialize_new_freespace,   | Make a new free space for      +\n               (*&p.grd_token,        |  item's group.                 +\n               &w.size_needed,        |                                +\n               &w.segment_token,      |                                +\n               &w.segment_address)    |\n**--------------------------------------------------------------------*\n endblk block=get_a_new_segment       |\n space 1                              |\n          swa   ,                     |\n&w.segment_token             ds  a    |\n&w.segment_address           ds  a    |\n&w.size_needed               ds  f    |\n&w.increment_needed          ds  f    |\n&w.increment_token           ds  f    |\n&w.increment_address         ds  a    |\n          endswa ,                    |\n eject                                |\n*---------------------------------------------------------------------*\n*\n*  Subroutine: adjust_item_size\n*  Abstract:   This subroutine adjusts the item size to an internal\n*              item storage size.  Internal sizes are multiples of\n*              4 and no less then the size of a FSI.\n*  Parameters: R1 should have size on input and will contain adjusted\n*              size on output.\n*\n*---------------------------------------------------------------------*\n block name=adjust_item_size,type=subroutine,options=*nosubopts\n  if (ch,r1,lt,=y(fsiitmsz))          | If size < size of FSI:\n   la    r1,fsiitmsz                  |  Set size to size of FSI.\n  else                                | Else:\n   al    r1,=f'3'                     |  Round to\n   srl   r1,2                         |  a multiple\n   sll   r1,2                         |  of 4.\n  endif                               | Endif.\n endblk block=adjust_item_size        |\n eject                                |\n*---------------------------------------------------------------------*\n*\n*  Subroutine: get_free_storage\n*  Abstract:   Get the request amount of storage.\n*  Parameters: (>grd_token,>size_to_obtain,<token,<address)\n*\n*---------------------------------------------------------------------*\n block name=get_free_storage,type=subroutine,                          +\n               parms=(grd_token,size_to_obtain,token,address)\n* *-------------------------------------------------------------------*\n* * Adjust the size to a legal size and save in work area.  Also,\n* * calculate the space required for the item plus a minimum sized\n* * free space.\n* *-------------------------------------------------------------------*\n  l     r1,&p.size_to_obtain          | Load r1 with\n  l     r1,0(,r1)                     | item size needed.\n  callsub adjust_item_size            | Adjust item size.\n  st    r1,&w.actual_size             | Save this size.\n  la    r1,fsiitmsz(r1)               | Save this size added to the\n  st    r1,&w.size_plus_min_freespace | size of the smallest freespace.\n  imlta r4,*&p.grd_token              | Point r4 to GRD.\n  errexit nz,code=&im_internal_error  | Error if invalid.\n* *-------------------------------------------------------------------*\n* * Loop processing all GSS entries for this group, until space is\n* * found.\n* *-------------------------------------------------------------------*\n  using grd,r4                        | Establish base for GRD.\n  imlta r5,grdfrgss                   | Point r5 to GSS.\n  errexit nz,code=&im_internal_error  | Error if invalid.\n  using gss,r5                        | Establish base for GSS.\n  loop while,(treg,r5,nz)             | Loop while not EOC GSS chain.\n*  *------------------------------------------------------------------*\n*  * If there is a large enough freespace in this segment to satisfy\n*  * the request, loop through the FSI entries for this segment and\n*  * use the first one that is large enough.\n*  *------------------------------------------------------------------*\n   if (clc,gsslrgst,eq,&w.actual_size),  If this segment has a large   +\n               or,(clc,gsslrgst,ge,&w.size_plus_min_freespace)\n*                                     |  enough free space:\n    l     r2,gssfrfsi                 |   Load r2 with 1st FSI token.\n    imlta r6,r2                       |   Point r6 to 1st FSI.\n    errexit nz,code=&im_internal_error    Error if invalid.\n    using fsi,r6                      |   Establish base for FSI.\n    slr   r7,r7                       |   Set previous pointer to zero.\n    loop while,(treg,r6,nz)           |   Loop through FSI chain.\n*    *----------------------------------------------------------------*\n*    * If space is found, adjust the free space chain as required, and\n*    * return the token and address of the item storage.\n*    *----------------------------------------------------------------*\n     if (clc,fsisize,eq,&w.actual_size),   If FS large enough:         +\n               or,(clc,fsisize,ge,&w.size_plus_min_freespace)\n*     *---------------------------------------------------------------*\n*     * Adjust the space used in this segment.  If this freespace\n*     * was the largest, indicate that we will need to determine\n*     * what is the largest free space again.\n*     *---------------------------------------------------------------*\n      l     r1,gssused                |     Add size of item\n      al    r1,&w.actual_size         |     storage to size used\n      st    r1,gssused                |     in this segment.\n      rbit  &w.f1,&w.f1_find_largest  |     Reset flag.\n      if (clc,fsisize,eq,gsslrgst)    |     If this was largest FSI:\n       sbit  &w.f1,&w.f1_find_largest |      Set a flag for later use.\n      endif                           |     Endif.\n*     *---------------------------------------------------------------*\n*     * If the free space is exactly the correct size, unchain the FSI\n*     *---------------------------------------------------------------*\n      if (clc,fsisize,eq,&w.actual_size)    if exactly room for item:\n       if (treg,r7,z)                 |      if FSI at head of chain:\n        mvc   gssfrfsi,fsinxfsi       |       Make next FSI the first.\n       else                           |      Else:\n        mvc   fsinxfsi-fsi(4,r7),fsinxfsi     Move next FSI to prv FSI.\n       endif                          |      Endif.\n*     *---------------------------------------------------------------*\n*     * If the free space is larger than needed, carve an item from\n*     * the start of the free space.\n*     *---------------------------------------------------------------*\n      else                            |     Else if just a smaller FS:\n       l     r1,fsisize               |      Decrease the\n       sl    r1,&w.actual_size        |      size in the\n       st    r1,fsisize               |      freespace entry.\n       lr    r8,r6                    |      Scoot the\n       al    r8,&w.actual_size        |      FSI past the\n       mvc   0(fsiitmsz,r8),0(r6)     |      item storage.\n       xc    0(fsiitmsz,r6),0(r6)     |      Clear the old FSI.\n       lr    r1,r2                    |      Calculate token\n       al    r1,&w.actual_size        |      of FSI.\n       if (treg,r7,z)                 |      If it is first in chain:\n        st    r1,gssfrfsi             |       Store token in GSS.\n       else                           |      If not first in chain:\n        st    r1,fsinxfsi-fsi(,r7)    |       Store token in last FSI.\n       endif                          |      Endif.\n      endif                           |     Endif.\n*     *---------------------------------------------------------------*\n*     * Return the token and address of the item storage.\n*     *---------------------------------------------------------------*\n      l     r1,&p.token               |     Return token address\n      st    r2,0(,r1)                 |     for item.\n      l     r1,&p.address             |     Return item address\n      st    r6,0(,r1)                 |     for item.\n*     *---------------------------------------------------------------*\n*     * If this was the largest FSI, determine what the largest one\n*     * is now.\n*     *---------------------------------------------------------------*\n      if (tbit,&w.f1,&w.f1_find_largest)    If this was the largest.\n       fill  gsslrgst,x'00'           |      Set the largest to zero.\n       l32   r2,gssfrfsi              |      Load r2 with first FSI.\n       loop  while,nz                 |      Search for largest.\n        imlta r6,r2                   |       Get address of this FSI.\n        errexit nz,code=&im_internal_error    Error if invalid.\n        if (clc,fsisize,gt,gsslrgst)  |       If this FSI larger:\n         mvc   gsslrgst,fsisize       |        Put its size in GSS.\n        endif                         |       Endif.\n        l32   r2,fsinxfsi             |       Load next FSI token.\n       endloop while                  |      Endloop.\n      endif                           |     Endif.\n*     *---------------------------------------------------------------*\n*     * Return to caller with a zero return code.\n*     *---------------------------------------------------------------*\n      sr    r15,15                    |     Set return code to zero.\n      leave block=get_free_storage    |     Leave block.\n*     *---------------------------------------------------------------*\n     endif                            |    Endif.\n     lr    r7,r6                      |    Set previous pointer.\n     l     r2,fsinxfsi                |    Load next token in r2.\n     imlta r6,r2                      |    Point to next FSI.\n     errexit nz,code=&im_internal_error    Error if invalid.\n    endloop while                     |   Endloop.\n    errexit code=&im_internal_error   |   Error if fell through.\n   endif                              |\n*  *------------------------------------------------------------------*\n   imlta r5,gssnxgss                  |  Point to next GSS.\n   errexit nz,code=&im_internal_error |  Error if invalid.\n  endloop while                       | Endloop.\n* *-------------------------------------------------------------------*\n* * If we fell thru, there was not room.\n* *-------------------------------------------------------------------*\n  la    r15,&im_no_room               | No room if fell thru.\n* *-------------------------------------------------------------------*\n endblk block=get_free_storage,rc=(r15)\n*---------------------------------------------------------------------*\n* Subroutine Work Area.               |\n*---------------------------------------------------------------------*\n         swa ,                        |\n&w.actual_size               ds  f    |\n&w.size_plus_min_freespace   ds  f    |\n&w.f1                  ds  b          |\n&w.f1_find_largest     equ b'10000000'\n         endswa ,                     |\n eject                                |\n*---------------------------------------------------------------------*\n*\n*  Subroutine: initialize_new_freespace\n*  Abstract:   Initialize a new free space in the storage provided\n*              and chain it to GSS off of GRD.\n*  Parameters: (>grd_token,>size_to_make_free,>token,>address)\n*\n*---------------------------------------------------------------------*\n block name=initialize_new_freespace,type=subroutine,                  +\n               parms=(grd_token,grd_size_to_make_free,                 +\n               free_space_token,free_space_address)\n* *-------------------------------------------------------------------*\n* * Set up various bases and get a spare GSS to use for new segment.\n* *-------------------------------------------------------------------*\n  imlta r4,*&p.grd_token              | Point r4 to GRD.\n  errexit nz,code=&im_internal_error  | Internal error if invalid.\n  using grd,r4                        | Establish base for GRD.\n  l     r5,pwa_imc_address            | Point r5 to IMC.\n  using imc,r5                        | Establish base for IMC.\n  l32   r0,imcspgss                   | Load r0 with token of spare GSS\n  errexit z,code=&im_internal_error   | Internal error if none.\n  st    r0,&w.gss_token               | Save token for later use.\n  imlta r6,r0                         | Get address of spare GSS.\n  errexit nz,code=&im_internal_error  | Internal error if failed.\n  using gss,r6                        | Establish base for GSS.\n  mvc   imcspgss,gssnxgss             | Remove GSS from spare chain.\n  l     r1,imc#sgss                   | Decrement the\n  bctr  r1,0                          | number of spare GSSs\n  st    r1,imc#sgss                   | by one.\n* *-------------------------------------------------------------------*\n* * Initialize the FSI.\n* *-------------------------------------------------------------------*\n  l     r1,&p.free_space_address      | Point r7 to new\n  l     r7,0(,r1)                     | segment.\n  using fsi,r7                        | Establish base for FSI.\n  xc    fsi(fsiitmsz),fsi             | Clear it out.\n  mvc   fsiitype,grdtdfsi+2           | Set item type in FSI.\n  mvc   fsinu1,=h'-1'                 | Set unused field to -1.\n  l     r1,&p.grd_size_to_make_free   | Store size of\n  l     r1,0(,r1)                     | segment as size of\n  st    r1,fsisize                    | freespace.\n* *-------------------------------------------------------------------*\n* * Initialize the GSS and chain it into the GSS chain off of the\n* * GRD in ascending order.\n* *-------------------------------------------------------------------*\n  xc    gss(gssitmsz),gss             | Clear GSS.\n  mvc   gssitype,imctdgss+2           | Set item type in GSS.\n  l     r1,fsisize                    | Load r1 with segment size.\n  drop  r7                            | Drop base for FSI.\n  st    r1,gsssize                    | Set this in GSS.\n  st    r1,gsslrgst                   | Set largest free space.\n  l     r1,&p.free_space_token        | Move free\n  l     r1,0(,r1)                     | space token\n  st    r1,gssfrfsi                   | to GSS first FSI and\n  st    r1,gssstart                   | GSS start fields.\n  l32   r3,grdfrgss                   | Load first gss chained to GRD.\n  if z                                | If chain empty:\n   mvc   grdfrgss,&w.gss_token        |  This one is the first.\n  else                                | If not empty:\n   fill  &w.previous_gss_address,x'00'   Set previous GSS to zero.\n   loop until                         |  Search for good place.\n    imlta r7,r3                       |   Get address of next GSS.\n    errexit nz,code=&im_internal_error    Internal error if failed.\n    if (treg,r7,z)                    |   If null GSS pointer:\n     l32   r7,&w.previous_gss_address |    Put this GSS at\n     mvc   gssnxgss-gss(4,r7),&w.gss_token the end of the chain.\n     leave loop=*                     |    Loop is complete.\n    elseif (clc,gssstart,lt,gssstart-gss(r7)) If this GSS describes\n     st    r3,gssnxgss                |    a higher segment then\n     l32   r7,&w.previous_gss_address |    the new GSS, chain the\n     if z                             |    new GSS ahead of it.  If\n      mvc   grdfrgss,&w.gss_token     |    then new GSS is at the start\n     else                             |    of the chain, put its token\n      mvc   gssnxgss-gss(4,r7),&w.gss_token in the GRD first GSS\n     endif                            |    pointer.\n     leave loop=*                     |    Loop is complete.\n    endif                             |   Endif.\n    st    r7,&w.previous_gss_address  |   Save pointer to GSS.\n    l     r3,gssnxgss-gss(,r7)        |   Point to next GSS.\n   endloop until,leave                |  End of loop.\n  endif                               | Endif.\n* *-------------------------------------------------------------------*\n endblk block=initialize_new_freespace\n eject                                |\n         space 1                      |\n         swa ,                        |\n&w.gss_token                 ds  f    |\n&w.previous_gss_address      ds  a    |\n         endswa ,                     |\n         eject                        |\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Get_data_space_increment\n*  Abstract:   This subroutine gets storage for a data space\n*              increment.\n*  Inputs:     (>increment_size,<token|,<address)\n*  Outputs:    None.\n*  Special     This routine will eventually support ESA style data\n*  Notes:      spaces and may be moved to another module or server.\n*\n*---------------------------------------------------------------------*\n block name=get_data_space_increment,type=subroutine,                  +\n               parms=(increment_size,increment_token,                  +\n               increment_address)     |\n          space 1                     |\n  mm_obtain_storage id=mm,            | Get storage for a DSE.         +\n               size==a(dsecblen),     |                                +\n               address=&w.addr        |\n  if (treg,r15,nz)                    | If obtain failed:\n   errexit (ch,r15,eq,=y(&mm_storage_not_available)),                  +\n               code=&im_storage_not_available   Fail with appropriate\n   errexit code=&im_internal_error    |         error code.\n  endif                               | Endif.\n  l     r3,&w.addr                    | Load address of DSE storage.\n  using dse,r3                        | Establish base for DSE.\n  l32   r1,pwa_final_dse              | Point r1 to last DSE on chain.\n  if z                                | If chain is empty.\n   slr   r0,r0                        |  Set offset to zero.\n   st    r3,pwa_first_dse             |  This dse is first in chain.\n  else                                | Else if chain is not empty.\n   l     r0,dseoffset-dse(,r1)        |  Calculate offset of new\n   al    r0,dsespan-dse(,r1)          |  increment by adding offset\n   st    r3,dsenext-dse(,r1)          |  and span in last DSE and add\n  endif                               |  this DSE to chain.\n  st    r0,dseoffset                  | Store offset in new DSE.\n  sll   r0,12                         | Calculate token.\n  st    r0,dsetoken                   | Save token.\n  st    r3,pwa_final_dse              | Set last DSE pointer.\n  mvc   dsecbid,=a(dsecbidt)          | Move id to DSE.\n  l     r1,&p.increment_size          | Point to increment size.\n  l     r0,0(,r1)                     | Load size of increment.\n  st    r0,dsesize                    | Store size in DSE.\n  srl   r0,12                         | Calculate size in blocks.\n  st    r0,dsespan                    | Store this as span.\n  xc    dsenext,dsenext               | Clear next pointer.\n  es_obtain_storage id=es,            | Get storage for increment      +\n               subpool=0,             |                                +\n               size=dsesize,          |                                +\n               address=dsestart       |\n  if (treg,r15,nz)                    | If obtain failed:\n   errexit (ch,r15,eq,=y(&es_storage_not_available)),                  +\n               code=&im_storage_not_available   Fail with appropriate\n   errexit code=&im_internal_error    |         error code.\n  endif                               | Endif.\n  l     r1,&p.increment_address       | Point to address return area.\n  mvc   0(l'dsestart,r1),dsestart     | Return increment address.\n  l32   r1,&p.increment_token         | Point to token return area.\n  if nz                               | If token is requested:\n   mvc   0(l'dsetoken,r1),dsetoken    |  Return it also.\n   if (tbit,pwa_f_actual_address)     |  Return address instead\n    mvc   0(l'dsetoken,r1),dsestart   |  if using\n   endif                              |  actual addresses.\n  endif                               | Endif.\n  l32   r15,pwa_dv                    | Point r15 to div manager epa.\n  if nz                               | If one exist.\n   callx (r15),(pwa_dv_token,         |  Open a window for this        +\n               &dv_open_window,       |  increment.                    +\n               dsestart,              |                                +\n               dsespan,               |                                +\n               dseoffset),vl          |\n   errexit (treg,r15,nz),code=&im_dv_open_window_failed\n   l     r1,dsestart                  | Point r1\n   al    r1,dsesize                   | to last byte\n   bctr  r1,0                         | in increment.\n   mvi   0(r1),255                    | Change it so DIV will\n   mvi   0(r1),0                      | save it.\n  endif                               | Endif.\n endblk block=get_data_space_increment\n          space 1                     |\n          swa   ,                     |\n&w.addr   ds    a                     |\n          endswa ,                    |\n         eject                        |\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Make_current\n*  Abstract:   This subroutine will make an item\n*              current-of-item-manager, current-of-item-type, and\n*              optionally, current-of-descriptor.\n*  Inputs:     (>token,>desctkn|)\n*  Outputs:    None.\n*---------------------------------------------------------------------*\n block name=make_current,type=subroutine,                              +\n               parms=(item_token,desc_token)\n  l     r3,&p.item_token              | Load r3 with\n  l     r3,0(,r3)                     |  item token.\n  st    r3,pwa_current_of_item_manager  Make current-of-item-manager.\n  imlta r4,r3                         | Get address of item.\n  errexit nz,or,(treg,r4,z),          | Fail if there is an error.     +\n               code=&im_invalid_token |\n  l16   r1,0(r4)                      | Get the item-type token.\n  st    r1,&w.token                   | Save it in work area.\n  callsub current,(*&p.item_token,&w.token) Make current-of-item-type.\n  l32   r2,&p.desc_token              | If descriptor is specified:\n  if nz                               |\n   callsub current,(*&p.item_token,(r2)) Make current-of-descriptor.\n  endif                               | Endif.\n endblk block=make_current            |\n space 2                              |\n swa ,                                |\n&w.token ds a                         |\n endswa ,                             |\n eject                                |\n*---------------------------------------------------------------------*\n*\n*  Subroutine: current\n*  Abstract:   This subroutine maintaines the item currency elements.\n*              Call this to make an item current \"of\" something.\n*  Inputs:     (>item,>of)\n*  Outputs:    None.\n*---------------------------------------------------------------------*\n block name=current,type=subroutine,parms=(item,of)\n  l     r1,pwa_current_of             | Load pointer to chain.\n  slr   r2,r2                         | Clear prior pointer.\n  l     r3,&p.of                      | Load search\n  l     r3,0(,r3)                     | argument.\n  using ice,r1                        | Establish base for ICE.\n  loop until                          | Search for hit.\n   if (treg,r1,z)                     |  If hit not found:\n    l     r2,pwa_current_of           |   Save head of chain pointer.\n    mm_obtain_storage id=mm,          |   Get storage for a ICE.       +\n               size==a(icecblen),     |                                +\n               address=pwa_current_of |\n    if (treg,r15,nz)                  |   If obtain failed:\n     errexit (ch,r15,eq,=y(&mm_storage_not_available)),                +\n               code=&im_storage_not_available   Fail with appropriate\n     errexit code=&im_internal_error  |           error code.\n    endif                             |   Endif.\n    l     r1,pwa_current_of           |   Load pointer to new ICE.\n    xc    ice(icecblen),ice           |   Clear it.\n    st    r2,icenext                  |   Insert at start of chain.\n    st    r3,iceof                    |   Store \"of\" field.\n    l     r3,&p.item                  |   Make item current\n    mvc   iceitem,0(r3)               |   \"of\".\n    leave loop=*                      |   Finished.\n   else                               |  If not at end of list:\n    if (cl,r3,eq,iceof)               |   If this is the \"of\" ICE:\n     l     r3,&p.item                 |    Make item current\n     mvc   iceitem,0(r3)              |    \"of\".\n     if (treg,r2,nz)                  |    If there is a prior:\n      mvc   icenext-ice(l'icenext,r2),icenext Unchain ICE.\n     endif                            |    Endif.\n     if (cl,r1,ne,pwa_current_of)     |    If not already at start:\n      mvc   icenext,pwa_current_of    |     Put ICE at\n      st    r1,pwa_current_of         |     front of chain.\n     endif                            |    Endif.\n     leave loop=*                     |    Finished.\n    else                              |   If not correct ICE:\n     lr    r2,r1                      |    Save this ICE as prior.\n     l     r1,icenext                 |    Point to next ICE.\n    endif                             |   Endif.\n   endif                              |  Endif.\n  endloop until,leave                 | Endloop.\n endblk block=current                 |\n eject                                |\n*---------------------------------------------------------------------*\n*\n*  Subroutine: find_current\n*  Abstract:   This subroutine maintaines the item currency elements.\n*              Call this to make an item current \"of\" something.\n*  Parameters: (>current_of_what,<is_what)\n*\n*---------------------------------------------------------------------*\n block name=find_current,type=subroutine,parms=(of,is)\n  l     r3,pwa_current_of             | Load pointer to chain.\n  l     r1,&p.of                      | Load r0 with\n  l     r0,0(,r1)                     | thing to search for.\n  using ice,r3                        | Using ICE.\n  loop until                          | Search for correct ICE.\n   if (treg,r3,z)                     |  If at end of chain:\n    la    r15,4                       |   Set return code\n    leave loop=*                      |   to 4 and return.\n   elseif (cl,r0,eq,iceof)            |  Else if match:\n    l     r1,&p.is                    |   Move item token\n    mvc   0(4,r1),iceitem             |   to return area.\n    sr    r15,r15                     |   Assume current found.\n    if (clc,iceitem,eq,=f'0')         |   If item token is zero:\n     la    r15,4                      |    Currency has been removed.\n    endif                             |   Endif.\n    leave loop=*                      |   to zero and return.\n   else                               |  Else\n    l     r3,icenext                  |   Point to next ICE.\n   endif                              |  Endif.\n  endloop until,leave                 | End of search code.\n endblk block=find_current,rc=(r15)   |\n eject                                |\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Quick_get_address\n*  Abstract:   This is a routine to quickly convert a token into a\n*              virtual storage address.\n*  Inputs:     r0  - Item token to convert.\n*              r1  - Token of item manager service processor.\n*              r14 - Return address.\n*              r15 - EPA.\n*  Outputs:    r0  - Unpredictable.\n*              r1  - Virtual address of item.\n*              r14 - Unchanged.\n*              r15 - 0 - Conversion went ok.\n*                    &im_invalid_token - Conversion did not go ok.\n*              Condition code - Set to reflect return code.\n*  Special     This routine is provided with speed in mind.  It is\n*  Notes:      believed that converting tokens to addresses will be\n*              very heavily used.\n*\n*              If a zero token is passed in to this routine in r0,\n*              the return code will be zero, and r1 will be set to\n*              zero.  This is considered a \"null\".\n*\n*---------------------------------------------------------------------*\n block name=quick_get_address,type=subroutine,                         +\n               options=(*nosubopts,custom)\n  push  using                         | Push usings.\n  drop  ,                             | Drop all bases.\n  using quick_get_address,r15         | Establish base.\n  if (treg,r0,nz)                     |\n   icm   r1,b'1111',pwa_first_dse-&pwa.(r1) Point to first DSE.\n   using dse,r1                       |  Establish base for DSE.\n   if nz                              |  If one exist:\n    loop until                        |   Loop until:\n     if (c,r0,lt,dsesize)             |    If token within this extent:\n      l     r1,dsestart               |     Calculate address\n      alr   r1,r0                     |     associated with item.\n      sr    r15,r15                   |     Set RC and CC to zero.\n      br    r14                       |     Return to caller.\n     endif                            |    Endif.\n     s     r0,dsesize                 |    Sub off size of this extent.\n     icm   r1,b'1111',dsenext         |    Point to next DSE.\n    endloop until,z                   |   Endloop until end of chain.\n   endif                              |  Endif.\n   la    r15,&im_invalid_token        |  Bad return code if here.\n   treg  r15                          |  Set CC.\n   br    r14                          |  Return to caller.\n  else                                | Else\n   slr   r1,r1                        |  Set address to zero.\n   sr    r15,r15                      |  Set return code to zero.\n  endif                               | Endif.\n  treg  r15                           | Set CC.\n  br    r14                           | Return to caller.\n  pop   using                         | Pop usings.\n endblk block=quick_get_address       |\n eject                                |\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Quick_get_address_actual\n*  Abstract:   This is a routine to stub that is used when tokens are\n*              already virtual storage address.\n*  Inputs:     r0  - Item token to convert.\n*              r14 - Return address.\n*              r15 - EPA.\n*  Outputs:    r0  - Unpredictable. (actually unchanged)\n*              r1  - Virtual address of item.\n*              r14 - Unchanged.\n*              r15 - 0\n*\n*---------------------------------------------------------------------*\n block name=quick_get_address_actual,type=subroutine,                  +\n               options=(*nosubopts,custom)\n  push  using                         | Push usings.\n  drop  ,                             | Drop all bases.\n  using quick_get_address_actual,r15  | Establish base.\n  if (treg,r0,nz),and,(c,r0,lt,pwa_lt_64k_size-&pwa.(r1))\n   al    r0,pwa_imc_address-&pwa.(r1)    Item type tokens are relative\n  endif                               |  byte addresses.\n  lr    r1,r0                         | Put address in R1.\n  sr    r15,r15                       | Set return code to zero.\n  br    r14                           | Return.\n  pop   using                         | Pop usings.\n endblk block=quick_get_address_actual\n eject                                |\n*---------------------------------------------------------------------*\n*\n*  Errexit:    Unnamed\n*  Purpose:    Save debugging information and exit with the return\n*              code pointed to by r14 at entry to this exit.\n*\n*---------------------------------------------------------------------*\n         SPACE 1                      |\n block type=errexit                   |\n* *-------------------------------------------------------------------*\n* * Save module/offset, registers, return-code.\n* *-------------------------------------------------------------------*\n  st    r15,pwa_reason                | Save possible return-code.\n  stm   r0,r15,gdiregs                | Save registers at time of error\n  sm_lal r0,&srv_modname+4            | Point to module iden\n  st    r0,gdimodid                   | Save in general debug area.\n  mvc   gdirc,0(r14)                  | Copy return code.\n  sl    r14,=a(&srv_modname)          | Calculate offset at time of err\n  sth   r14,gdioffst                  | Save in debug area.\n  es_save_debug_info id=es,gdi=gdi    | Save debug information.\n* *-------------------------------------------------------------------*\n* * Look at the error code.  Some errors imply that the DIV Server\n* * has lost its cookies and should not attempt to do anything other\n* * than shut-down (if it can even do that).\n* *-------------------------------------------------------------------*\n  lh    r15,gdirc                     | Get return code.\n  caseblk reg=r15,mult=1              | Case on return-code.\n    case &dv_not_useable              |\n      rbit  pwa_f_useable             | Indicate DIV Server unsafe.\n*>>>  es_save_debug_info id=es,hex=(pwa_reason,4),label=(\"REASON\",6)\n      callx pwa_es_epa,(pwa_es_token,&es_save_debug_info,              +\n               &es_debug_id_hex,pwa_reason,4,\"REASON\",6),vl\n    case other                        |  Don't bother w/other errors.\n  endcase                             | EndCase.\n* *-------------------------------------------------------------------*\n* * Set the return-code and exit.\n* *-------------------------------------------------------------------*\n  lh    r15,gdirc                     | Set return code.\n endblk                               |\n eject                                |\n title \"Program Static Data\"          |\n                psd                   |\npsd_div_lf      dc    8a(0)           |\npsd_div_lf_length equ *-psd_div_lf    |\npsd_min_spare_gsss                  dc a(4)\npsd_max_spare_gsss                  dc a(10)\npsd_number_of_itds                  dc a(&number_of_itds)\npsd_number_of_itdxs                 dc a(&number_of_itdxs)\npsd_0123456789147036 equ *-c'0'\n                dc c'0123456789147036'\n                ltorg ,               |\n                endpsd                |\n          title \"Dsects\"              |\n          im_sfd ,                    |\nice       dsect ,                     | Item Currency Element.\nicenext   ds    a                     | Next ICE.\niceitem   ds    a                     | Item.\niceof     ds    a                     | Current \"of\"\nicecblen  equ   *-ice                 | Control block size.\n          space 3                     |\ndir       dsect ,                     | Directory Entry.\ndiritype  ds    h                     | Item type of DIR.\ndirnmsz   ds    x                     | Size of name.\ndirname   ds    cl255                 | Name of Item.\ndirlinks  ds    0f                    | Start of nodes.\ndirdesc   ds    f                     | Item description.\ndiritkn   ds    f                     | Item token.\ndirtksyn  ds    f                     | Synonym chain.\ndirtksyn_link_number equ (*-dirlinks)/4 Link number of synonym chain.\ndir#lnks  equ   (*-dirlinks)/4        | Item number of links.\ndiritmsz  equ   *-dir                 | Size of a DIR.\n          space 3                     |\ndse       dsect ,                     | Data space extent.\ndsecbid   ds    f                     | Control block id.\ndsecbidt  equ   c\"DSE \"               | Control block id text.\ndsestart  ds    a                     | Start of extent in storage.\ndsetoken  ds    f                     | Token of first item in extent.\ndseoffset ds    f                     | Offset in data space (blocks).\ndsespan   ds    f                     | Span (blocks).\ndsesize   ds    f                     | Size of extent.\ndsenext   ds    a                     | Address of next DSE.\ndsecblen  equ   *-dse                 | Size of a DSE.\n          space 1\n*--------------------------------------------------------------------*\n*  Parameter list work area.\n*--------------------------------------------------------------------*\nprm                           dsect , |\nprm_ItemID                    ds a    | Div identifier === PWA base\nprm_functioncode              ds a    | Function to be performed\nprm_min_#                     equ (*-prm)/4\nprm_function_dependent        equ *   | Function-dependent parameters\n* Start function\n                  org prm_function_dependent\nprm_start_esv                 ds a    | Environment Support Vector.\nprm_start_options             ds a    | Options.\nprm_start_options_read_only      equ b'10000000'\nprm_start_options_actual_address equ b'01000000'\nprm_start_div_epa             ds a    | DIV service process EPA.\nprm_start_div_ddname          ds a    | DIV DDName.\nprm_start_max_#               equ (*-prm)/4\n* Terminate function\n                  org prm_function_dependent\nprm_terminate_max_#           equ (*-prm)/4\n* Initialize function\n                  org prm_function_dependent\nprm_initialize_itd_stg_size   ds a    | ITD storage size.\nprm_initialize_ua_stg_incr    ds a    | Unallocated stg increment size.\nprm_initialize_sys_stg_incr   ds a    | System stg increment size.\nprm_initialize_du_stg_incr    ds a    | Dflt user stg increment size.\nprm_initialize_max_#          equ (*-prm)/4\n* Save function\n                  org prm_function_dependent\nprm_save_max_#                equ (*-prm)/4\n* Reset function\n                  org prm_function_dependent\nprm_reset_max_#               equ (*-prm)/4\n* Add to directory function\n                  org prm_function_dependent\nprm_add_to_dir_name_length      ds a  | Name Length.\nprm_add_to_dir_name             ds a  | Name.\nprm_add_to_dir_token            ds a  | Token.\nprm_add_to_dir_max_#          equ (*-prm)/4\n* Find in directory function\n                  org prm_function_dependent\nprm_find_in_dir_name_length     ds a  | Name Length.\nprm_find_in_dir_name            ds a  | Name.\nprm_find_in_dir_token           ds a  | Token.\nprm_find_in_dir_max_#         equ (*-prm)/4\n* Remove from directory function\n                  org prm_function_dependent\nprm_remove_from_dir_name_length ds a  | Name Length.\nprm_remove_from_dir_name        ds a  | Name.\nprm_remove_from_dir_max_#     equ (*-prm)/4\n* Create item type descriptor function\n                  org prm_function_dependent\nprm_create_itd_descriptor_token ds a  | Descriptor token.\nprm_create_itd_description      ds a  | Description.\nprm_create_itd_options          ds a  | Options.\nprm_create_itd_options_first_link_has_description equ b'10000000'\nprm_create_itd_grd_token        ds a  | Group descriptor token.\nprm_create_itd_item_len         ds a  | Item length.\nprm_create_itd_#_links          ds a  | Number of links in item.\nprm_create_itd_offset           ds a  | First link offset.\nprm_create_itd_item_len_size    ds a  | Item length size.\nprm_create_itd_item_len_offset  ds a  | Item length offset.\nprm_create_itd_#_links_size     ds a  | Number of links size.\nprm_create_itd_#_links_offset   ds a  | Number of links offset.\nprm_create_itd_offset_size      ds a  | First link offset size.\nprm_create_itd_offset_offset    ds a  | First link offset offset.\nprm_create_itd_max_#          equ (*-prm)/4\n* Create group descriptor function\n                  org prm_function_dependent\nprm_create_gd_descriptor_token ds a   | Descriptor token.\nprm_create_gd_description      ds a   | Description.\nprm_create_gd_increment_size  ds a    | Storage increment size.\nprm_create_gd_max_#           equ (*-prm)/4\n* Create linked list function\n                  org prm_function_dependent\nprm_create_ld_descriptor_token ds a   | Descriptor token.\nprm_create_ld_description      ds a   | Description.\nprm_create_ld_options         ds a    | Options.\nprm_create_ld_first_link_#    ds a    | First    link number.\nprm_create_ld_final_link_#    ds a    | Final    link number.\nprm_create_ld_next_link_#     ds a    | Next     link number.\nprm_create_ld_prior_link_# ds a       | prior link number.\nprm_create_ld_owner_link_#    ds a    | Owner    link number.\nprm_create_ld_heads_item_type ds a    | Item type of heads items.\nprm_create_ld_key_offset      ds a    | Key offset.\nprm_create_ld_key_len         ds a    | Key length.\nprm_create_ld_key_len_offset  ds a    | Key length offset.\nprm_create_ld_itemtype        ds a    | Itemtype.\nprm_create_ld_max_#           equ (*-prm)/4\n* Create hash table function\n                  org prm_function_dependent\nprm_create_ht_descriptor_token ds a   | Descriptor token.\nprm_create_ht_description      ds a   | Description.\nprm_create_ht_options         ds a    | Options.\nprm_create_ht_entries_in_table ds a   | Number of entries in table.\nprm_create_ht_synonym_link_#  ds a    | Synonym  link number.\nprm_create_ht_key_offset      ds a    | Key offset.\nprm_create_ht_key_len         ds a    | Key length.\nprm_create_ht_key_len_offset  ds a    | Key length offset.\nprm_create_ht_itemtype        ds a    | Itemtype.\nprm_create_ht_max_#           equ (*-prm)/4\n* Create binary tree function\n                  org prm_function_dependent\nprm_create_bt_descriptor_token ds a   | Descriptor token.\nprm_create_bt_description      ds a   | Description.\n*> not defined\nprm_create_bt_max_#           equ (*-prm)/4\n* Destroy function\n                  org prm_function_dependent\nprm_destroy_descriptor_token  ds a    | Descriptor token.\nprm_destroy_force             ds a    | Force flag.\nprm_destroy_max_#             equ (*-prm)/4\n* Connect function\n                  org prm_function_dependent\nprm_connect_descriptor_token  ds a    | Descriptor token.\nprm_connect_item_token        ds a    | Item to connect.\nprm_connect_head_token        ds a    | Head item.\nprm_connect_max_#             equ (*-prm)/4\n* Disconnect function\n                  org prm_function_dependent\nprm_disconnect_descriptor_token  ds a | Descriptor token.\nprm_disconnect_item_token        ds a | Item to connect.\nprm_disconnect_head_token        ds a | Head item.\nprm_disconnect_prior_token       ds a | Token of prior item.\nprm_disconnect_max_#             equ (*-prm)/4\n* Obtain function\n                  org prm_function_dependent\nprm_ob_item_token             ds a    | Item token.\nprm_ob_return_area_size       ds a    | Return area size.\nprm_ob_return_area            ds a    | Return area.\nprm_ob_actual_item_size       ds a    | Actual item size.\nprm_ob_max_#                  equ (*-prm)/4\n* Obtain by key function\n                  org prm_function_dependent\nprm_obky_descriptor_token     ds a    | Descriptor token.\nprm_obky_key_length           ds a    | Key size.\nprm_obky_key                  ds a    | Key.\nprm_obky_return_area_size     ds a    | Return area size.\nprm_obky_return_area          ds a    | Return area.\nprm_obky_actual_item_size     ds a    | Actual item size.\nprm_obky_item_token           ds a    | Item token.\nprm_obky_max_#                equ (*-prm)/4\n* Obtain current_of_descriptor, next, prior, owner, first and final.\n* 2a is for first and final. 2b is for next and prior. 2c for owner.\n                  org prm_function_dependent\nprm_ob2_descriptor_token      ds a    | Descriptor token.\nprm_ob2_return_area_size      ds a    | Return area size.\nprm_ob2_return_area           ds a    | Return area.\nprm_ob2_actual_item_size      ds a    | Actual item size.\nprm_ob2_item_token            ds a    | Item token.\nprm_ob2_max_#                 equ (*-prm)/4\nprm_ob2b_current_token        ds 0a   | Current token\nprm_ob2c_current_token        ds 0a   | Current token\nprm_ob2a_head_token           ds a    | Head token.\nprm_ob2c_max_#                equ (*-prm)/4\nprm_ob2a_max_#                equ (*-prm)/4\nprm_ob2b_head_token           ds a    | Head token.\nprm_ob2b_max_#                equ (*-prm)/4\n* Obtain current_of_item_type.\n                  org prm_function_dependent\nprm_ob3_item_type             ds a    | Item type.\nprm_ob3_return_area_size      ds a    | Return area size.\nprm_ob3_return_area           ds a    | Return area.\nprm_ob3_actual_item_size      ds a    | Actual item size.\nprm_ob3_item_token            ds a    | Item token.\nprm_ob3_max_#                 equ (*-prm)/4\n* Find function\n                  org prm_function_dependent\nprm_fd_item_token             ds a    | Item token.\nprm_fd_actual_item_size       ds a    | Actual item size.\nprm_fd_max_#                  equ (*-prm)/4\n* Find by key function\n                  org prm_function_dependent\nprm_fdky_descriptor_token     ds a    | Descriptor token.\nprm_fdky_key_length           ds a    | Key size.\nprm_fdky_key                  ds a    | Key.\nprm_fdky_actual_item_size     ds a    | Actual item size.\nprm_fdky_item_token           ds a    | Item token.\nprm_fdky_max_#                equ (*-prm)/4\n* Find current_of_descriptor, next, prior, owner, first and final.\n* 2a is for first and final. 2b is for next and prior. 2c for owner.\n                  org prm_function_dependent\nprm_fd2_descriptor_token      ds a    | Descriptor token.\nprm_fd2_actual_item_size      ds a    | Actual item size.\nprm_fd2_item_token            ds a    | Item token.\nprm_fd2_max_#                 equ (*-prm)/4\nprm_fd2c_current_token        ds 0a   | Current token\nprm_fd2b_current_token        ds 0a   | Current token\nprm_fd2a_head_token           ds a    | Head token.\nprm_fd2c_max_#                equ (*-prm)/4\nprm_fd2a_max_#                equ (*-prm)/4\nprm_fd2b_head_token           ds a    | Head token.\nprm_fd2b_max_#                equ (*-prm)/4\n* Find current_of_item_type.\n                  org prm_function_dependent\nprm_fd3_item_type             ds a    | Item type.\nprm_fd3_actual_item_size      ds a    | Actual item size.\nprm_fd3_item_token            ds a    | Item token.\nprm_fd3_max_#                 equ (*-prm)/4\n* Get function\n                  org prm_function_dependent\nprm_get_return_area_size      ds a    | Return area size.\nprm_get_return_area           ds a    | Return area.\nprm_get_actual_item_size      ds a    | Actual item size.\nprm_get_item_token            ds a    | Item token.\nprm_get_max_#                 equ (*-prm)/4\n* Get dangerous addresses function\n                  org prm_function_dependent\nprm_gda_token_convert_routine ds a    | Token convert routine.\nprm_gda_max_#                 equ (*-prm)/4\n* Modify function\n                  org prm_function_dependent\nprm_modify_item_address       ds a    | Item address.\nprm_modify_options            ds a    | Options.\nprm_modify_options_bypass_links_check equ b'10000000'\nprm_modify_options_update_links       equ b'01000000'\nprm_modify_item_token         ds a    | Item token.\nprm_modify_max_#              equ (*-prm)/4\n* Sort function\n                  org prm_function_dependent\nprm_sort_descriptor_token     ds a    | Item address.\nprm_sort_fieldslist           ds a    | Options.\nprm_sort_head_token           ds a    | Head item.\nprm_sort_technique            ds a    | Sort technique.\nprm_sort_max_#                equ (*-prm)/4\n* Store function\n                  org prm_function_dependent\nprm_store_item_address        ds a    | Item address.\nprm_store_options             ds a    | Options.\nprm_store_options_links_can_be_nonnull equ b'10000000'\nprm_store_item_token          ds a    | Item token.\nprm_store_max_#               equ (*-prm)/4\n* Erase function\n                  org prm_function_dependent\nprm_erase_options             ds a    | Options.\nprm_erase_options_bypass_links_check  equ b'10000000'\nprm_erase_item_token          ds a    | Item token.\nprm_erase_max_#               equ (*-prm)/4\n                  org ,               |\nprm_max_#                     equ (*-prm)/4\n          space 1                     |\n          es_esv ,                    |\n          itc dsect=yes               |\n          kpm dsect=yes               |\n          im_fsi ,                    |\n          im_grd ,                    |\n          im_gss ,                    |\n          im_htd ,                    |\n          im_imc ,                    |\n          im_itd ,                    |\n          im_lld ,                    |\n          im_dsc ,                    |\n          title \"Program Work Area\"   |\n               PWA                    |\npwa_area       ds    0f               | Beginning of visible PWA stg.\npwa_f          ds    bl1              | Flags for DIV Server.\npwa_f_useable         equ b'10000000' | DIV Server is useable.\npwa_f_final_setup     equ b'01000000' |\npwa_f_short_itd_ok    equ b'00100000' |\npwa_f_actual_address  equ b'00010000' | Actual addresses are used.\n               ds    bl1              | Not used.\npwa_number_of_parms ds f              | Number of parms.\npwa_im_token                  ds f    | Pointer to program work area.\npwa_reason                    ds f    | Reason Item Manager died.\npwa_dv                        ds a    | Div SP epa.\npwa_dv_token                  ds f    | Div SP token.\npwa_es_epa                    ds a    | Environment support EPA.\npwa_es_token                  ds f    | Environment support token.\npwa_mm_epa                    ds a    | Memory manager epa.\npwa_initial_size              ds a    | Initial size of DIV area.\npwa_im_quick_get_address      ds a    | Address of quick get addr rtn.\npwa_increment                 ds f    | Main increment size.\npwa_system_storage_increment       ds f System storage increment.\npwa_default_user_storage_increment ds f Default user storage increment.\npwa_lt_64k_size               ds f    | <64k storage size.\npwa_first_dse                 ds a    | First DSE in chain.\npwa_final_dse                 ds a    | Final DSE in chain.\npwa_time                      ds f    | Time (used during initialize)\npwa_date                      ds pl4  | Date (used during initialize)\npwa_bit_mask                  ds f    | Use by BIT compare code.\n               es_gdi dsect=no        | General debugging information.\npwa_build_area ds 0f                  |\npwa_itd_build_area ds xl(itdxitmsz)   |\n               org pwa_build_area     |\npwa_grd_build_area ds xl(grditmsz)    |\n               org pwa_build_area     |\npwa_lld_build_area ds xl(llditmsz)    |\n               org pwa_build_area     |\npwa_htd_build_area ds xl(htditmsz)    |\n               org pwa_build_area     |\npwa_key_work_area  ds xl256           |\n               org ,                  |\npwa_imc_address               ds a    |\npwa_current_of                ds a    | Head of current \"of\" chain.\npwa_current_of_item_manager   ds f    | Current of item manager.\n*--------------------------------------------------------------------*\npwa_area_l     equ   *-pwa_area       | Length of visible PWA stg.\n               endpwa                 |\n               end   ,                |\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SRVIMCB": {"ttr": 28420, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x02\\x00\\x00W\\x01\\x11)\\x9f\\x01\\x11)\\x9f\\t'\\x00,\\x00,\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@\"", "ispf": {"version": "02.00", "flags": 0, "createdate": "2011-10-26T00:00:00", "modifydate": "2011-10-26T09:27:57", "lines": 44, "newlines": 44, "modlines": 0, "user": "CLEMSON"}, "text": "*---------------------------------------------------------------------*\n*  Copyright 2011 by Clemson University Research Foundation           *\n*                                                                     *\n*  Licensed under the Apache License, Version 2.0 (the \"License\");    *\n*  you may not use this file except in compliance with the License.   *\n*  You may obtain a copy of the License in this library as member     *\n*  $LICENSE, or from                                                  *\n*                                                                     *\n*      http://www.apache.org/licenses/LICENSE-2.0                     *\n*                                                                     *\n*  Unless required by applicable law or agreed to in writing,         *\n*  software distributed under the License is distributed on an \"AS    *\n*  IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either    *\n*  express or implied.  See the License for the specific language     *\n*  governing permissions and limitations under the License.           *\n*---------------------------------------------------------------------*\nSRVIMCB  TITLE 'Item Manager Control Blocks'\nSRVIMCB  CSECT ,\n         SMLIST CONVERT=YES\n         push  print\n         print off\n         copy srvimimc\n         copy srvimmac\n         pop   print\n         title \"DSC\"\n          im_dsc ,\n         title \"FSI\"\n          im_fsi ,\n         title \"GRD\"\n          im_grd ,\n         title \"GSS\"\n          im_gss ,\n         title \"HTD\"\n          im_htd ,\n         title \"IMC\"\n          im_imc ,\n         title \"ITD\"\n          im_itd ,\n         title \"LLD\"\n          im_lld ,\nSRVIMCB  CSECT ,\n         title \"SFD\"\n          im_sfd ,\n               end   ,\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SRVIMIMC": {"ttr": 28422, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x02\\x00\\x00W\\x01\\x11)\\x9f\\x01\\x11)\\x9f\\t'\\x01\\xec\\x01\\xec\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@\"", "ispf": {"version": "02.00", "flags": 0, "createdate": "2011-10-26T00:00:00", "modifydate": "2011-10-26T09:27:57", "lines": 492, "newlines": 492, "modlines": 0, "user": "CLEMSON"}, "text": "*---------------------------------------------------------------------*\n*  Copyright 2011 by Clemson University Research Foundation           *\n*                                                                     *\n*  Licensed under the Apache License, Version 2.0 (the \"License\");    *\n*  you may not use this file except in compliance with the License.   *\n*  You may obtain a copy of the License in this library as member     *\n*  $LICENSE, or from                                                  *\n*                                                                     *\n*      http://www.apache.org/licenses/LICENSE-2.0                     *\n*                                                                     *\n*  Unless required by applicable law or agreed to in writing,         *\n*  software distributed under the License is distributed on an \"AS    *\n*  IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either    *\n*  express or implied.  See the License for the specific language     *\n*  governing permissions and limitations under the License.           *\n*---------------------------------------------------------------------*\n TITLE 'SRVIMIMC: Item Manager Service Processor Internal Macros.'\n*---------------------------------------------------------------------*\n*\n*  Copy File:  SRVIMIMC\n*\n*  Purpose:    Item Manager Service Processor internal macros.\n*\n*  Description: See \"Service Processors User's Guide and Reference\".\n*\n*  Change\n*  History:    10/12/89 MGG - New\n*\n*---------------------------------------------------------------------*\n*\n         MACRO\n&TAG     IM_DIR &DSECT=YES,&ID=DIR\n*---------------------------------------------------------------------*\n*\n*  Macro:      IM_DIR\n*\n*  Title:      Item Manager Directory Entry.\n*\n*  Purpose:    This macro maps a item manager directory entry.\n*\n*  Special\n*  Notes:      Associated with Item Manager.\n*\n*  Change\n*  History:    03/21/89 MGG - New\n*\n*---------------------------------------------------------------------*\n         SPACE 1\n         LCLC  &I,&NAME\n&I       SETC  '&ID'\n&NAME    SETC  '&ID'\n         AIF   ('&TAG' EQ '').NOTAG\n&NAME    SETC  '&TAG'\n.NOTAG   ANOP\n         AIF ('&DSECT' EQ 'NO').NODSECT\n&NAME    DSECT\n         AGO .TG1\n.NODSECT ANOP\n&NAME    DS    0F\n.TG1     ANOP\n&I.ITYPE DS    H                      | Item type (of \"item type\"!).\n&I.NAME  DS    CL64                   | Name.\n         DS    3F                     | Reserved.\n&I.LINKS DS    0F                     | Start of links.\n&I.DESC  DS    F                      | Description.\n&I.TKN   DS    F                      | Token that is saved.\n&I.NXDIR DS    F                      | Next DIR.\n&I.#LNKS EQU   (*-&I.LINKS)/4         | Number of links.\n&I.ITMSZ EQU   *-&NAME                | Length of this item.\n         SPACE 1                      |\n         MEND                         |\n*\n*\n*\n         MACRO\n&TAG     IM_DSC &DSECT=YES,&ID=DSC\n*---------------------------------------------------------------------*\n*\n*  Macro:      IM_DSC\n*\n*  Title:      Description Item\n*\n*  Purpose:    This macro maps a description.\n*\n*  Special\n*  Notes:      Associated with Item Manager.\n*\n*  Change\n*  History:    03/21/89 MGG - New\n*\n*---------------------------------------------------------------------*\n         SPACE 1\n         LCLC  &I,&NAME\n&I       SETC  '&ID'\n&NAME    SETC  '&ID'\n         AIF   ('&TAG' EQ '').NOTAG\n&NAME    SETC  '&TAG'\n.NOTAG   ANOP\n         AIF ('&DSECT' EQ 'NO').NODSECT\n&NAME    DSECT\n         AGO .TG1\n.NODSECT ANOP\n&NAME    DS    0F\n.TG1     ANOP\n&I.ITYPE DS    H                      | Item type.\n&I.SIZE  DS    X                      | Size of string plus 3.\n&I.TEXT  EQU   *                      | Text of description.\n         MEND                         |\n         MACRO\n&TAG     IM_FSI &DSECT=YES,&ID=FSI\n*---------------------------------------------------------------------*\n*\n*  Macro:      IM_FSI\n*\n*  Title:      Free Space Item\n*\n*  Purpose:    This macro maps an free space item.\n*\n*  Special     Associated with Item Manager.\n*  Notes:\n*\n*  Change\n*  History:    02/27/89 MGG - New\n*\n*---------------------------------------------------------------------*\n         SPACE 1\n         LCLC  &I,&NAME\n&I       SETC  '&ID'\n&NAME    SETC  '&ID'\n         AIF   ('&TAG' EQ '').NOTAG\n&NAME    SETC  '&TAG'\n.NOTAG   ANOP\n         AIF ('&DSECT' EQ 'NO').NODSECT\n&NAME    DSECT\n         AGO .TG1\n.NODSECT ANOP\n&NAME    DS    0F\n.TG1     ANOP\n&I.ITYPE DS    H                      | Item-type token.\n&I.NU1   DS    H                      | Always has a -1.\n&I.LINKS DS    0F                     | Start of links.\n&I.NXFSI DS    F                      | Token of next free space.\n&I.#LNKS EQU   (*-&I.LINKS)/4         | Number of links.\n&I.SIZE  DS    F                      | Size of free space.\n         SPACE 1                      |\n&I.ITMSZ EQU   *-&NAME                | Length of this item.\n         MEND                         |\n         MACRO\n&TAG     IM_GRD &DSECT=YES,&ID=GRD\n*---------------------------------------------------------------------*\n*\n*  Macro:      IM_GRD\n*\n*  Title:      Group Descriptor\n*\n*  Purpose:    This macro maps a group descriptor.\n*\n*  Special\n*  Notes:      Associated with Item Manager.\n*\n*  Change\n*  History:    02/27/89 MGG - New\n*\n*---------------------------------------------------------------------*\n         SPACE 1\n         LCLC  &I,&NAME\n&I       SETC  '&ID'\n&NAME    SETC  '&ID'\n         AIF   ('&TAG' EQ '').NOTAG\n&NAME    SETC  '&TAG'\n.NOTAG   ANOP\n         AIF ('&DSECT' EQ 'NO').NODSECT\n&NAME    DSECT\n         AGO .TG1\n.NODSECT ANOP\n&NAME    DS    0F\n.TG1     ANOP\n&I.ITYPE DS    H                      | Item type.\n&I.MMTHD DS    H                      | Storage management method.\n&I.INCSZ DS    F                      | Increment size.\n&I.LINKS DS    0F                     | Start of links.\n&I.DESC  DS    F                    1 | Description.\n&I.FRGSS DS    F                    2 | First GSS for block.\n&I.TDFSI DS    F                    3 | Item type descriptor for FSI.\n&I.NXGRD DS    F                    4 | Pointer to next GRD.\n&I.#LNKS EQU   (*-&I.LINKS)/4         | Number of links.\n         SPACE 1                      |\n&I.ITMSZ EQU   *-&NAME                | Length of this item.\n         MEND                         |\n         MACRO\n&TAG     IM_GSS &DSECT=YES,&ID=GSS\n*---------------------------------------------------------------------*\n*\n*  Macro:      IM_GSS\n*\n*  Title:      Group Storage Segment\n*\n*  Purpose:    This macro maps a group storage segment entry.\n*\n*  Special\n*  Notes:      Associated with Item Manager.\n*\n*  Change\n*  History:    03/12/89 MGG - New\n*\n*---------------------------------------------------------------------*\n         SPACE 1\n         LCLC  &I,&NAME\n&I       SETC  '&ID'\n&NAME    SETC  '&ID'\n         AIF   ('&TAG' EQ '').NOTAG\n&NAME    SETC  '&TAG'\n.NOTAG   ANOP\n         AIF ('&DSECT' EQ 'NO').NODSECT\n&NAME    DSECT\n         AGO .TG1\n.NODSECT ANOP\n&NAME    DS    0F\n.TG1     ANOP\n&I.ITYPE DS    H                      | Item type.\n         DS    H                      | Not used.\n&I.SIZE  DS    F                      | Size of segment.\n&I.USED  DS    F                      | Storage used in segment.\n&I.LRGST DS    F                      | Largest free space.\n&I.LINKS DS    0F                     | Start of links.\n&I.START DS    F                    1 | Token of first item in segment.\n&I.NXGSS DS    F                    2 | Next GSS.\n&I.FRFSI DS    F                    3 | First FSI for this segment.\n&I.#LNKS EQU   (*-&I.LINKS)/4         | Number of links.\n         SPACE 1                      |\n&I.ITMSZ EQU   *-&NAME                | Length of this item.\n         MEND                         |\n         MACRO\n&TAG     IM_HTD &DSECT=YES,&ID=HTD\n*---------------------------------------------------------------------*\n*\n*  Macro:      IM_HTD\n*\n*  Title:      Hash Table Descriptor\n*\n*  Purpose:    This macro maps a hash table descriptor.\n*\n*  Special\n*  Notes:      Associated with Item Manager.\n*\n*  Change\n*  History:    02/27/89 MGG - New\n*\n*---------------------------------------------------------------------*\n         SPACE 1\n         LCLC  &I,&NAME\n&I       SETC  '&ID'\n&NAME    SETC  '&ID'\n         AIF   ('&TAG' EQ '').NOTAG\n&NAME    SETC  '&TAG'\n.NOTAG   ANOP\n         AIF ('&DSECT' EQ 'NO').NODSECT\n&NAME    DSECT\n         AGO .TG1\n.NODSECT ANOP\n&NAME    DS    0F\n.TG1     ANOP\n&I.ITYPE DS    H                      | Item type.\n&I.OP    DS    BL1                    | Options:\n&I.OPDUP EQU   B'10000000'            |   Duplicate keys allowed.\n&I.F1    DS    BL1                    | Flag:\n&I.F1KSI EQU   B'10000000'            |   Key size in item.\n&I.KSZ   DS    F                      | Size of key if fixed (max 255)\n&I.KSZOF EQU   &I.KSZ                 | Offset of size in item.\n&I.KOF   DS    F                      | Key offset in item.\n&I.SIZE  DS    F                      | Size of this item.\n&I.SYLK# DS    F                      | Synonym link number in item.\n&I.#LNKS DS    F                      | Number of links.\n&I.LINKS DS    0F                     | Start of links.\n&I.DESC  DS    F                    1 | Description link.\n&I.MTITD DS    F                    2 | Optional token for member ITD.\n&I.TABLE DS    0F                   3 | Start of hash table.\n&I.TABLE_LINK_# EQU (*-&I.LINKS)/4    | Start of table link number.\n         SPACE 1                      |\n&I.ITMSZ EQU   *-&NAME                | Length of this item not\n*                                     |  counting the hash table.\n         MEND\n         MACRO\n&TAG     IM_IMC &DSECT=YES,&ID=IMC\n*---------------------------------------------------------------------*\n*\n*  Macro:      IM_IMC\n*\n*  Title:      Item Manager Control\n*\n*  Purpose:    This macro maps the item manager control block.\n*\n*  Special\n*  Notes:      Associated with Item Manager.\n*\n*  Change\n*  History:    02/27/89 MGG - New\n*\n*---------------------------------------------------------------------*\n         SPACE 1\n         LCLC  &I,&NAME\n&I       SETC  '&ID'\n&NAME    SETC  '&ID'\n         AIF   ('&TAG' EQ '').NOTAG\n&NAME    SETC  '&TAG'\n.NOTAG   ANOP\n         AIF ('&DSECT' EQ 'NO').NODSECT\n&NAME    DSECT\n         AGO .TG1\n.NODSECT ANOP\n&NAME    DS    0F\n.TG1     ANOP\n&I.ITYPE DS    H                      | Item-type token.\n&I.F1    DS    BL1                    | Flags.\n&I.F1INT EQU   B'10000000'            |   Has been initialized.\n&I.F1OPN EQU   B'01000000'            |   Is open.\n&I.F1SAV EQU   B'00100000'            |   In the process of being saved\n&I.LEVEL DS    FL1                    | Level of data set.\n&I.PGMNM DS    CL8                    | Item Manager Name.\n&I.CRJBN DS    CL8                    | Creation jobname.\n&I.CRDAT DS    PL4                    | Creation date.\n&I.CRTIM DS    F                      | Creation time.\n*  Next 5 fields must be together     |\n&I.4MORE DS    XL((8+4+4)*4)          | 4 previous update job/date/time\n&I.LSJBN DS    CL8                    | Last job to update.\n&I.LSDAT DS    PL4                    | Last date.\n&I.LSTIM DS    F                      | Last time.\n&I.LSSZ  EQU   *-&I.LSJBN             |\n*                                     |\n&I.#SGSS DS    F                      | Number of spare GSSs.\n         DS    10F                    | Not used.\n&I.LINKS DS    0F                     | Start of links.\n&I.DSDIR DS    F                      | Descriptor for directory.\n&I.FRGRD DS    F                      | First GRD in chain of GRDs.\n&I.SPGSS DS    F                      | Spare GSSs.\n&I.GRDUA DS    F                      | Unassigned storage group.\n&I.GRDLS DS    F                      | Low RBA system storage grp.<64K\n&I.GRDSY DS    F                      | System storage group. >64K\n&I.GRDDF DS    F                      | Default user storage group.\n&I.TDGRD DS    F                      | Group desc ITD token.\n&I.TDGSS DS    F                      | Group storage segment token.\n&I.TDITD DS    F                      | Item type ITD token.\n&I.TDITDX DS   F                      | Extended item type ITD token.\n&I.TDDSC DS    F                      | Descriptor ITD token.\n&I.TDLLD DS    F                      | List descriptor ITD token.\n&I.TDHTD DS    F                      | Hashtable descriptor ITD token.\n&I.TDBTD DS    F                      | Binary tree desc ITD token.\n&I.TDDIR DS    F                      | Directory entry ITD token.\n         DS    10F                    | Not used.\n&I.FSIST DS    F                      | Short string used for Freespace\n         DS    10F                    | Not used.\n&I.#LNKS EQU   (*-&I.LINKS)/4         | Number of links.\n         SPACE 1                      |\n&I.ITMSZ EQU   *-&NAME                | Length of this item.\n         MEND                         |\n         MACRO\n&TAG     IM_ITD &DSECT=YES,&ID=ITD\n*---------------------------------------------------------------------*\n*\n*  Macro:      IM_ITD\n*\n*  Title:      Item Type Descriptor\n*\n*  Purpose:    This macro maps a simple item type descriptor.\n*\n*  Special\n*  Notes:      Associated with Item Manager.\n*\n*  Change\n*  History:    02/27/89 MGG - New\n*\n*---------------------------------------------------------------------*\n         SPACE 1\n         LCLC  &I,&NAME\n&I       SETC  '&ID'\n&X       SETC  '&ID.X'\n&NAME    SETC  '&ID'\n         AIF   ('&TAG' EQ '').NOTAG\n&NAME    SETC  '&TAG'\n.NOTAG   ANOP\n         AIF ('&DSECT' EQ 'NO').NODSECT\n&NAME    DSECT\n         AGO .TG1\n.NODSECT ANOP\n&NAME    DS    0F\n.TG1     ANOP\n&X       EQU   *\n&I.ITYPE DS    H                      | Item type (of \"item type\"!).\n&I.CLASS DS    H                      | Item class.\n&I.NUMIT DS    F                      | Number of items of this type.\n&I.LINKS DS    0F                     | Start of links.\n&X.LINKS DS    0F                     | Start of links.\n&I.DESC  DS    F                      | Description.\n&I.GRD   DS    F                      | Group Storage Segment token.\n&I.#LNKS EQU   (*-&I.LINKS)/4         | Number of links.\n&X.#LNKS EQU   (*-&I.LINKS)/4         | Number of links.\n&I.F1    DS    BL1                    | Flags.\n&I.F1EXT EQU   B'10000000'            |   Extended form ITD.\n&I.F1LNI EQU   B'01000000'            |   Item size is in item.\n&I.F1NLI EQU   B'00100000'            |   Number of links is in item.\n&I.F1LOI EQU   B'00010000'            |   Links offset is in item.\n&I.F1DFL EQU   B'00001000'            |   Item has token of description\n*                                     |   in first link.  Otherwise,\n*                                     |   ITDDESC has the token, if\n*                                     |   any.\n&I.XFORM EQU   *                      | Where extended for starts to\n*                                     | differ.\n&I.ILN   DS    X                      | Item length.\n&I.ILO   DS    X                      | First link offset.\n&I.INL   DS    X                      | Number of links.\n         SPACE 1                      |\n&I.ITMSZ EQU   *-&NAME                | Length of this item.\n         SPACE\n         ORG   &I.XFORM               | Org to where forms differ.\n&X.ILNSZ DS    X ---------            | Item length size.\n&X.INLSZ DS    X ------  |            | Number of links size.\n&X.ILOSZ DS    X ---  |  |            | Link offset size.\n&X.ILN   DS    0F  |  |  |            | Item length.\n&X.ILNOF DS    F <--------            | Item length size offset.\n&X.ILO   DS    0F  |  |               | First link offset.\n&X.ILOOF DS    F <-----               | Link offset size offset.\n&X.INL   DS    0F  |                  | Number of links.\n&X.INLOF DS    F <--                  | Number of links size offset.\n         SPACE 1                      |\n&X.ITMSZ EQU   *-&NAME                | Length of this item.\n         MEND                         |\n         MACRO\n&TAG     IM_LLD &DSECT=YES,&ID=LLD\n*---------------------------------------------------------------------*\n*\n*  Macro:      IM_LLD\n*\n*  Title:      Linked List Descriptor\n*\n*  Purpose:    This macro maps a linked list descriptor.\n*\n*  Special\n*  Notes:      Associated with Item Manager.\n*\n*  Change\n*  History:    02/27/89 MGG - New\n*\n*---------------------------------------------------------------------*\n         SPACE 1\n         LCLC  &I,&NAME\n&I       SETC  '&ID'\n&NAME    SETC  '&ID'\n         AIF   ('&TAG' EQ '').NOTAG\n&NAME    SETC  '&TAG'\n.NOTAG   ANOP\n         AIF ('&DSECT' EQ 'NO').NODSECT\n&NAME    DSECT\n         AGO .TG1\n.NODSECT ANOP\n&NAME    DS    0F\n.TG1     ANOP                         |\n&I.ITYPE DS    H                      | Item type.\n&I.OP    DS    BL1                    | Option:\n&I.OPHID EQU   B'10000000'            |   Heads in descriptor.\n&I.OPDUP EQU   B'01000000'            |   Duplicate keys allowed.\n&I.OPORD EQU   B'00000111'            |   List order:\n&I.OPOFS EQU   0                      |     First.\n&I.OPOFN EQU   1                      |     Final.\n&I.OPONX EQU   2                      |     Next.\n&I.OPOPR EQU   3                      |     Prior.\n&I.OPOSA EQU   4                      |     Sorted: Ascending.\n&I.OPOSD EQU   5                      |     Sorted: Descending.\n&I.F1    DS    BL1                    | Flag:\n&I.F1KSI EQU   B'10000000'            |   Key size in item.\n&I.F1KED EQU   B'01000000'            |   Keyed. (otherwise entry)\n*                                     | Link number used for:\n&I.NXLK# DS    F                      |   Next     link.  Links\n&I.PRLK# DS    F                      |   Prior link.       \"\n&I.OWLK# DS    F                      |   Owner    link.    \"\n&I.FRLK# DS    F                      |   First    link.  Heads\n&I.FNLK# DS    F                      |   Final    link.    \"\n&I.KSZ   DS    F                      | Size of key if fixed.\n&I.KSZOF EQU   &I.KSZ                 | Offset of size in item.\n&I.KOF   DS    F                      | Key offset in item.\n&I.LINKS DS    0F                     | Start of links.\n&I.DESC  DS    F                    1 | Token of list description.\n&I.MTITD DS    F                    2 | Optional token for member ITD.\n&I.HDITD DS    0F                   3 | Token of heads ITD.\n&I.FRLST DS    F                    3 | Token of first item in list.\n&I.FNLST DS    F                    4 | Token of final item in list.\n&I.SPITD DS    F                    5 | Token of seperate item ITD.\n&I.#LNKS EQU   (*-&I.LINKS)/4         | Number of links.\n         SPACE 1                      |\n&I.ITMSZ EQU   *-&NAME                | Length of this item.  May be\n*                                     |  4 less if backlink does not\n*                                     |  exist.\n         MEND                         |\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SRVIMMAC": {"ttr": 28676, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x02\\x00\\x00W\\x01\\x11)\\x9f\\x01\\x11)\\x9f\\t'\\n\\xb1\\n\\xb1\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@\"", "ispf": {"version": "02.00", "flags": 0, "createdate": "2011-10-26T00:00:00", "modifydate": "2011-10-26T09:27:57", "lines": 2737, "newlines": 2737, "modlines": 0, "user": "CLEMSON"}, "text": "*---------------------------------------------------------------------*\n*  Copyright 2011 by Clemson University Research Foundation           *\n*                                                                     *\n*  Licensed under the Apache License, Version 2.0 (the \"License\");    *\n*  you may not use this file except in compliance with the License.   *\n*  You may obtain a copy of the License in this library as member     *\n*  $LICENSE, or from                                                  *\n*                                                                     *\n*      http://www.apache.org/licenses/LICENSE-2.0                     *\n*                                                                     *\n*  Unless required by applicable law or agreed to in writing,         *\n*  software distributed under the License is distributed on an \"AS    *\n*  IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either    *\n*  express or implied.  See the License for the specific language     *\n*  governing permissions and limitations under the License.           *\n*---------------------------------------------------------------------*\n TITLE 'SRVIMMAC: Item Manager Service Processor Symbols && Macros.'\n*---------------------------------------------------------------------*\n*\n*  Copy File:  SRVIMMAC\n*\n*  Purpose:    Item Manager service processor symbols and macros.\n*\n*  Description: See \"Service Processors User's Guide and Reference\".\n*\n*  Change\n*  History   2011/10/20 JCB - Patch rollup for CBT tape distribution\n*\n*---------------------------------------------------------------------*\n*\n***********************************************************************\n***********************************************************************\n**                                                                   **\n**                     Symbol Definitions                            **\n**                                                                   **\n***********************************************************************\n***********************************************************************\n GBLC &ITEM_MANAGER\n GBLA &IM_START,&IM_TERMINATE,&IM_INITIALIZE,&IM_SAVE,&IM_RESET\n GBLA &IM_CREATE_ITEM_TYPE_DESCRIPTOR,&IM_CREATE_GROUP_DESCRIPTOR\n GBLA &IM_CREATE_LINKED_LIST_DESCRIPTOR\n GBLA &IM_CREATE_HASH_TABLE_DESCRIPTOR\n GBLA &IM_CREATE_BINARY_TREE_DESCRIPTOR,&IM_DESTROY\n GBLA &IM_GET_DANGEROUS_ADDRESSES,&IM_CONNECT,&IM_DISCONNECT,&IM_OBTAIN\n GBLA &IM_OBTAIN_BY_KEY\n GBLA &IM_OBTAIN_CURRENT_OF_ITEM_TYPE\n GBLA &IM_OBTAIN_CURRENT_OF_DESCRIPTOR\n GBLA &IM_OBTAIN_FIRST,&IM_OBTAIN_FINAL,&IM_OBTAIN_NEXT\n GBLA &IM_OBTAIN_PRIOR\n GBLA &IM_OBTAIN_OWNER,&IM_FIND,&IM_FIND_FIRST,&IM_FIND_FINAL\n GBLA &IM_FIND_BY_KEY\n GBLA &IM_FIND_CURRENT_OF_ITEM_TYPE\n GBLA &IM_FIND_CURRENT_OF_DESCRIPTOR\n GBLA &IM_FIND_NEXT,&IM_FIND_PRIOR,&IM_FIND_OWNER,&IM_GET,&IM_MODIFY\n GBLA &IM_STORE,&IM_ERASE\n GBLA &IM_SUCCESS\n GBLA &IM_INVALID_NUMBER_OF_PARMS\n GBLA &IM_INVALID_FUNCTION,&IM_FUNCTION_UNSUPPORTED_FOR_CLASS\n GBLA &IM_DIV_START_FAILED,&IM_MEMORY_MANAGER_LOAD_FAILED\n GBLA &IM_MEMORY_MANAGER_START_FAILED,&IM_ITEM_STORAGE_NOT_INITIALIZED\n GBLA &IM_SETUP_ALREADY_COMPLETE,&IM_TOO_LARGE_MAXIMUM_ITEM_TYPES\n GBLA &IM_STORAGE_NOT_AVAILABLE\n GBLA &IM_INTERNAL_ERROR,&IM_INVALID_TOKEN,&IM_DV_OPEN_WINDOW_FAILED\n GBLA &IM_DV_SAVE_FAILED,&IM_DV_RESET_FAILED,&IM_FUNCTION_REQUIRES_DIV\n GBLA &IM_INVALID_ITEM_TYPE_TOKEN,&IM_ITEM_SIZE_REQUIRED,&IM_NO_ROOM\n GBLA &IM_OFFSET_SPECIFIED_WHEN_SIZE_WAS_ZERO,&IM_LENGTH_REQUIRED\n GBLA &IM_INVALID_OFFSET,&IM_NOT_YET_SUPPORTED,&IM_MISSING_PARAMETER\n GBLA &IM_INVALID_ITEM_TYPE,&IM_INVALID_ITEM,&IM_INVALID_SIZE\n GBLA &IM_DESCRIPTION_TOO_LONG,&IM_LENGTH_PARM_ERROR\n GBLA &IM_#_LINKS_PARM_ERROR,&IM_LINKS_OFFSET_PARM_ERROR\n GBLA &IM_ITEM_CHARACTERISTICS_CHANGED,&IM_ITEM_LINKS_CHANGED\n GBLA &IM_INVALID_RETURN_AREA_SIZE,&IM_KEY_LENGTH_PARM_ERROR\n GBLA &IM_KEY_OFFSET_PARM_ERROR,&IM_INVALID_DESCRIPTOR_TOKEN\n GBLA &IM_INVALID_ITEM_TOKEN\n GBLA &IM_CURRENCY_ERROR,&IM_INVALID_LINK_NUMBER\n GBLA &IM_LINK_NOT_NULL,&IM_AT_END\n GBLA &IM_REQUIRES_PRIOR_LINK\n GBLA &IM_REQUIRES_FINAL_LINK\n GBLA &IM_REQUIRES_OWNER_LINK\n GBLA &IM_NOT_FOUND\n GBLA &IM_INVALID_SORT_TECHNIQUE\n GBLA &IM_PRTKN_INVALID\n GBLA &IM_PRTKN_REQUIRED\n GBLA &IM_HEADTKN_INVALID\n GBLA &IM_CURTKN_INVALID\n GBLA &IM_ITEMTYPE_MISMATCH\n GBLA &IM_CLASS_UNCLASSIFIED\n GBLA &IM_CLASS_ITEM_TYPE_DESCRIPTOR,&IM_CLASS_GROUP_DESCRIPTOR\n GBLA &IM_CLASS_FREESPACE,&IM_CLASS_DESCRIPTION\n GBLA &IM_CLASS_LINKED_LIST_DESCRIPTOR,&IM_CLASS_HASH_TABLE_DESCRIPTOR\n GBLA &IM_CLASS_BINARY_TREE_DESCRIPTOR,&IM_ADD_TO_DIRECTORY\n GBLA &IM_REMOVE_FROM_DIRECTORY,&IM_FIND_IN_DIRECTORY\n GBLA &IM_SORT\n GBLA &IM_SFD_TYPE_CHARACTER\n GBLA &IM_SFD_TYPE_CHAR\n GBLA &IM_SFD_TYPE_PACKED\n GBLA &IM_SFD_TYPE_ZONED\n GBLA &IM_SFD_TYPE_FIXED\n GBLA &IM_SFD_TYPE_BIT\n GBLA  &IM_SORT_TECHNIQUE_QUICK_SORT\n GBLA  &IM_SORT_TECHNIQUE_BUBBLE_SORT\n*\n* Entry point name for the Item Manager.\n*\n&ITEM_MANAGER                           SETC '''SRVIM   '''\n*\n* Function codes.\n*\n&IM_START                               SETA 1\n&IM_TERMINATE                           SETA 2\n&IM_INITIALIZE                          SETA 3\n&IM_SAVE                                SETA 4\n&IM_RESET                               SETA 5\n&IM_CREATE_ITEM_TYPE_DESCRIPTOR         SETA 6\n&IM_CREATE_GROUP_DESCRIPTOR             SETA 7\n&IM_CREATE_LINKED_LIST_DESCRIPTOR       SETA 8\n&IM_CREATE_HASH_TABLE_DESCRIPTOR        SETA 9\n&IM_CREATE_BINARY_TREE_DESCRIPTOR       SETA 10\n&IM_DESTROY                             SETA 20\n&IM_CONNECT                             SETA 21\n&IM_DISCONNECT                          SETA 22\n&IM_ERASE                               SETA 23\n&IM_GET                                 SETA 24\n&IM_GET_DANGEROUS_ADDRESSES             SETA 25\n&IM_MODIFY                              SETA 26\n&IM_STORE                               SETA 27\n&IM_ADD_TO_DIRECTORY                    SETA 28\n&IM_REMOVE_FROM_DIRECTORY               SETA 29\n&IM_FIND_IN_DIRECTORY                   SETA 30\n&IM_SORT                                SETA 31\n&IM_FIND                                SETA 50\n&IM_FIND_BY_KEY                         SETA 51\n&IM_FIND_CURRENT_OF_ITEM_TYPE           SETA 52\n&IM_FIND_CURRENT_OF_DESCRIPTOR          SETA 53\n&IM_FIND_FIRST                          SETA 54\n&IM_FIND_FINAL                          SETA 55\n&IM_FIND_NEXT                           SETA 56\n&IM_FIND_PRIOR                          SETA 57\n&IM_FIND_OWNER                          SETA 58\n&IM_OBTAIN                              SETA 70\n&IM_OBTAIN_BY_KEY                       SETA 71\n&IM_OBTAIN_CURRENT_OF_ITEM_TYPE         SETA 72\n&IM_OBTAIN_CURRENT_OF_DESCRIPTOR        SETA 73\n&IM_OBTAIN_FIRST                        SETA 74\n&IM_OBTAIN_FINAL                        SETA 75\n&IM_OBTAIN_NEXT                         SETA 76\n&IM_OBTAIN_PRIOR                        SETA 77\n&IM_OBTAIN_OWNER                        SETA 78\n*\n* Return codes.\n*\n&IM_SUCCESS                             SETA  0\n&IM_INVALID_NUMBER_OF_PARMS             SETA  2\n&IM_INVALID_FUNCTION                    SETA  3\n&IM_FUNCTION_UNSUPPORTED_FOR_CLASS      SETA  4\n&IM_DIV_START_FAILED                    SETA  5\n&IM_MEMORY_MANAGER_LOAD_FAILED          SETA  6\n&IM_MEMORY_MANAGER_START_FAILED         SETA  7\n&IM_ITEM_STORAGE_NOT_INITIALIZED        SETA  8\n&IM_SETUP_ALREADY_COMPLETE              SETA  9\n&IM_INTERNAL_ERROR                      SETA 11\n&IM_INVALID_TOKEN                       SETA 12\n&IM_STORAGE_NOT_AVAILABLE               SETA 14\n&IM_DV_OPEN_WINDOW_FAILED               SETA 15\n&IM_DV_SAVE_FAILED                      SETA 16\n&IM_DV_RESET_FAILED                     SETA 17\n&IM_FUNCTION_REQUIRES_DIV               SETA 18\n&IM_INVALID_ITEM_TYPE_TOKEN             SETA 19\n&IM_ITEM_SIZE_REQUIRED                  SETA 20\n&IM_NO_ROOM                             SETA 21\n&IM_OFFSET_SPECIFIED_WHEN_SIZE_WAS_ZERO SETA 22\n&IM_LENGTH_REQUIRED                     SETA 23\n&IM_INVALID_OFFSET                      SETA 24\n&IM_NOT_YET_SUPPORTED                   SETA 25\n&IM_MISSING_PARAMETER                   SETA 26\n&IM_INVALID_ITEM_TYPE                   SETA 27\n&IM_INVALID_ITEM                        SETA 28\n&IM_INVALID_SIZE                        SETA 29\n&IM_DESCRIPTION_TOO_LONG                SETA 30\n&IM_LENGTH_PARM_ERROR                   SETA 31\n&IM_#_LINKS_PARM_ERROR                  SETA 32\n&IM_LINKS_OFFSET_PARM_ERROR             SETA 33\n&IM_ITEM_CHARACTERISTICS_CHANGED        SETA 34\n&IM_ITEM_LINKS_CHANGED                  SETA 35\n&IM_INVALID_RETURN_AREA_SIZE            SETA 36\n&IM_KEY_LENGTH_PARM_ERROR               SETA 37\n&IM_KEY_OFFSET_PARM_ERROR               SETA 38\n&IM_INVALID_DESCRIPTOR_TOKEN            SETA 39\n&IM_INVALID_ITEM_TOKEN                  SETA 40\n&IM_CURRENCY_ERROR                      SETA 41\n&IM_INVALID_LINK_NUMBER                 SETA 42\n&IM_LINK_NOT_NULL                       SETA 43\n&IM_AT_END                              SETA 44\n&IM_REQUIRES_PRIOR_LINK                 SETA 45\n&IM_REQUIRES_FINAL_LINK                 SETA 46\n&IM_REQUIRES_OWNER_LINK                 SETA 47\n&IM_NOT_FOUND                           SETA 48\n&IM_HEAD_NOT_VALID_FOR_THIS_DESCRIPTOR  SETA 49\n&IM_INVALID_SFD                         SETA 50\n&IM_INVALID_SORT_TECHNIQUE              SETA 51\n&IM_PRTKN_INVALID                       SETA 52\n&IM_PRTKN_REQUIRED                      SETA 53\n&IM_HEADTKN_INVALID                     SETA 54\n&IM_CURTKN_INVALID                      SETA 55\n&IM_ITEMTYPE_MISMATCH                   SETA 56\n    DEFUCOND MACRO=SRV##RC,NAME=IM_SUCCESS\n    DEFUCOND MACRO=SRV##RC,NAME=IM_INVALID_NUMBER_OF_PARMS\n    DEFUCOND MACRO=SRV##RC,NAME=IM_INVALID_FUNCTION\n    DEFUCOND MACRO=SRV##RC,NAME=IM_FUNCTION_UNSUPPORTED_FOR_CLASS\n    DEFUCOND MACRO=SRV##RC,NAME=IM_DIV_START_FAILED\n    DEFUCOND MACRO=SRV##RC,NAME=IM_MEMORY_MANAGER_LOAD_FAILED\n    DEFUCOND MACRO=SRV##RC,NAME=IM_MEMORY_MANAGER_START_FAILED\n    DEFUCOND MACRO=SRV##RC,NAME=IM_ITEM_STORAGE_NOT_INITIALIZED\n    DEFUCOND MACRO=SRV##RC,NAME=IM_SETUP_ALREADY_COMPLETE\n    DEFUCOND MACRO=SRV##RC,NAME=IM_INTERNAL_ERROR\n    DEFUCOND MACRO=SRV##RC,NAME=IM_INVALID_TOKEN\n    DEFUCOND MACRO=SRV##RC,NAME=IM_STORAGE_NOT_AVAILABLE\n    DEFUCOND MACRO=SRV##RC,NAME=IM_DV_OPEN_WINDOW_FAILED\n    DEFUCOND MACRO=SRV##RC,NAME=IM_DV_SAVE_FAILED\n    DEFUCOND MACRO=SRV##RC,NAME=IM_DV_RESET_FAILED\n    DEFUCOND MACRO=SRV##RC,NAME=IM_FUNCTION_REQUIRES_DIV\n    DEFUCOND MACRO=SRV##RC,NAME=IM_INVALID_ITEM_TYPE_TOKEN\n    DEFUCOND MACRO=SRV##RC,NAME=IM_ITEM_SIZE_REQUIRED\n    DEFUCOND MACRO=SRV##RC,NAME=IM_NO_ROOM\n    DEFUCOND MACRO=SRV##RC,NAME=IM_OFFSET_SPECIFIED_WHEN_SIZE_WAS_ZERO\n    DEFUCOND MACRO=SRV##RC,NAME=IM_LENGTH_REQUIRED\n    DEFUCOND MACRO=SRV##RC,NAME=IM_INVALID_OFFSET\n    DEFUCOND MACRO=SRV##RC,NAME=IM_NOT_YET_SUPPORTED\n    DEFUCOND MACRO=SRV##RC,NAME=IM_MISSING_PARAMETER\n    DEFUCOND MACRO=SRV##RC,NAME=IM_INVALID_ITEM_TYPE\n    DEFUCOND MACRO=SRV##RC,NAME=IM_INVALID_ITEM\n    DEFUCOND MACRO=SRV##RC,NAME=IM_INVALID_SIZE\n    DEFUCOND MACRO=SRV##RC,NAME=IM_DESCRIPTION_TOO_LONG\n    DEFUCOND MACRO=SRV##RC,NAME=IM_LENGTH_PARM_ERROR\n    DEFUCOND MACRO=SRV##RC,NAME=IM_#_LINKS_PARM_ERROR\n    DEFUCOND MACRO=SRV##RC,NAME=IM_LINKS_OFFSET_PARM_ERROR\n    DEFUCOND MACRO=SRV##RC,NAME=IM_ITEM_CHARACTERISTICS_CHANGED\n    DEFUCOND MACRO=SRV##RC,NAME=IM_ITEM_LINKS_CHANGED\n    DEFUCOND MACRO=SRV##RC,NAME=IM_INVALID_RETURN_AREA_SIZE\n    DEFUCOND MACRO=SRV##RC,NAME=IM_KEY_LENGTH_PARM_ERROR\n    DEFUCOND MACRO=SRV##RC,NAME=IM_KEY_OFFSET_PARM_ERROR\n    DEFUCOND MACRO=SRV##RC,NAME=IM_INVALID_DESCRIPTOR_TOKEN\n    DEFUCOND MACRO=SRV##RC,NAME=IM_INVALID_ITEM_TOKEN\n    DEFUCOND MACRO=SRV##RC,NAME=IM_CURRENCY_ERROR\n    DEFUCOND MACRO=SRV##RC,NAME=IM_INVALID_LINK_NUMBER\n    DEFUCOND MACRO=SRV##RC,NAME=IM_LINK_NOT_NULL\n    DEFUCOND MACRO=SRV##RC,NAME=IM_AT_END\n    DEFUCOND MACRO=SRV##RC,NAME=IM_REQUIRES_PRIOR_LINK\n    DEFUCOND MACRO=SRV##RC,NAME=IM_REQUIRES_FINAL_LINK\n    DEFUCOND MACRO=SRV##RC,NAME=IM_REQUIRES_OWNER_LINK\n    DEFUCOND MACRO=SRV##RC,NAME=IM_NOT_FOUND\n    DEFUCOND MACRO=SRV##RC,NAME=IM_HEAD_NOT_VALID_FOR_THIS_DESCRIPTOR\n    DEFUCOND MACRO=SRV##RC,NAME=IM_INVALID_SFD\n    DEFUCOND MACRO=SRV##RC,NAME=IM_INVALID_SORT_TECHNIQUE\n    DEFUCOND MACRO=SRV##RC,NAME=IM_PRTKN_INVALID\n    DEFUCOND MACRO=SRV##RC,NAME=IM_PRTKN_REQUIRED\n    DEFUCOND MACRO=SRV##RC,NAME=IM_HEADTKN_INVALID\n    DEFUCOND MACRO=SRV##RC,NAME=IM_CURTKN_INVALID\n    DEFUCOND MACRO=SRV##RC,NAME=IM_ITEMTYPE_MISMATCH\n*\n* Item classes.\n*\n&IM_CLASS_UNCLASSIFIED                  SETA  0\n&IM_CLASS_ITEM_TYPE_DESCRIPTOR          SETA  1\n&IM_CLASS_GROUP_DESCRIPTOR              SETA  2\n&IM_CLASS_FREESPACE                     SETA  3\n&IM_CLASS_DESCRIPTION                   SETA  4\n&IM_CLASS_LINKED_LIST_DESCRIPTOR        SETA  5\n&IM_CLASS_HASH_TABLE_DESCRIPTOR         SETA  6\n&IM_CLASS_BINARY_TREE_DESCRIPTOR        SETA  7\n*\n* Types in Sort Field Descriptors (SFD).\n*\n&IM_SFD_TYPE_CHARACTER             SETA 1\n&IM_SFD_TYPE_CHAR                  SETA 1\n&IM_SFD_TYPE_PACKED                SETA 2\n&IM_SFD_TYPE_ZONED                 SETA 3\n&IM_SFD_TYPE_FIXED                 SETA 4\n&IM_SFD_TYPE_BIT                   SETA 5\n*\n* Sort techinques.\n*\n&IM_SORT_TECHNIQUE_QUICK_SORT      SETA 1\n&IM_SORT_TECHNIQUE_BUBBLE_SORT     SETA 2\n                        EJECT\n***********************************************************************\n***********************************************************************\n**                                                                   **\n**                     Macro Definitions                             **\n**                                                                   **\n***********************************************************************\n***********************************************************************\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   IM_ID                                                      *\n*                                                                     *\n* Purpose: Establish default values for a specific service processor  *\n*          and associate them with the specified ID name. The values  *\n*          are stored in the following created global variables:      *\n*                                                                     *\n* Variable Name                     Description                       *\n* -------------  ---------------------------------------------------- *\n* #$&ID.$#IDMAC  Name of macro that created the ID: IM_ID.            *\n* #$&ID.$#ESID   Service processor's Environment Support ID.          *\n* #$&ID.$#EPN    Tag for Service processor's Entry Point Name.        *\n* #$&ID.$#EPA    Tag for Service processor's Entry Point Address.     *\n* #$&ID.$#TKN    Tag for Service processor's Entry Point Token.       *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         IM_ID &ID=,&ESVA=,&SPEPNAME=,&SPEPA=,&SPTOKEN=,&ESID=,        +\n               &TKNCNVT=\n.*\n.* Invoke SRV##ID to create globals used by all ID's.\n.*\n         SRV##ID SET,                                                  +\n               ID=&ID.,IDMAC=IM_ID,ESID=&ESID.,SPEPNAME=&SPEPNAME,     +\n               SPEPA=&SPEPA,SPTOKEN=&SPTOKEN.\n.*\n.* Establish defaults for parameters specific to the item manager.\n.*\n&V_TKNCNVT       SETC '#$&ID.$#TKNCNVT'     Variable for TKNCNVT=.\n                 GBLC &(&V_TKNCNVT)         Declare global variable.\n&(&V_TKNCNVT)    SETC '&TKNCNVT'\n.*\n         MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   IM_START                                                   *\n* Purpose: Generate code to start a new item manager session.         *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         IM_START &ID=,&SPEPA=,&SPTOKEN=,&ESVA=,&OPTIONS=,&DIVEPA=,    +\n               &DIVDDN=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN\n         GBLA  &IM_START                  SETC in open code.\n         LCLC  &OPTSTR\n         LCLB  &O_READ_ONLY\n         LCLB  &O_ACTUAL_ADDRESS\n.*\n.* Obtain service processor ID values.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN,ESVA),                    +\n               ID=&ID,IDMAC=IM_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN,       +\n               ESVA=&ESVA.\n         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT\n         MVC   &#_IDTKN,=F'0'            | Insure TOKEN = 0.\n.*\n.* Decode the options and produce a byte flag for the parmlist.\n.*\n&I       SETA  1\n.OPTLOOP AIF   (&I GT N'&OPTIONS).PASTOPT\n         AIF   ('&OPTIONS(&I)' EQ 'READ_ONLY').OPT1\n         AIF   ('&OPTIONS(&I)' EQ 'ACTUAL_ADDRESS').OPT2\n         MNOTE 8,'Invalid option name: &OPTIONS(&I)'\n.OPT1    ANOP\n&O_READ_ONLY SETB 1\n         AGO   .NEXTOPT         Go process the next option.\n.OPT2    ANOP\n&O_ACTUAL_ADDRESS SETB 1\n         AGO   .NEXTOPT         Go process the next option.\n.NEXTOPT ANOP\n&I       SETA  &I+1             Increment index into options list.\n         AGO   .OPTLOOP         Branch back to top of loop.\n.PASTOPT ANOP\n&OPTSTR  SETC '&O_READ_ONLY.&O_ACTUAL_ADDRESS'\n&OPTSTR  SETC '&OPTSTR.000000'\n         AIF  ('&OPTSTR' NE '00000000').NOT_NOP\n&OPTSTR  SETC ''\n         AGO  .PAST_OPTSTR_SET\n.NOT_NOP ANOP\n&OPTSTR  SETC '=B''&OPTSTR'''\n.PAST_OPTSTR_SET ANOP\n.*\n.* Gnerate the appropriate IM_START call.\n.*\n         AIF   ('&DIVDDN' NE '').CALL4\n         AIF   ('&DIVEPA' NE '').CALL3\n         AIF   ('&OPTSTR' NE '').CALL2\n.CALL1   CALLX &#_IDEPA,(&#_IDTKN,&IM_START,&#_IDESVA),VL\n         MEXIT\n.CALL2   CALLX &#_IDEPA,(&#_IDTKN,&IM_START,&#_IDESVA,&OPTSTR),VL\n         MEXIT\n.CALL3   CALLX &#_IDEPA,(&#_IDTKN,&IM_START,&#_IDESVA,&OPTSTR,         +\n               &DIVEPA),VL\n         MEXIT\n.CALL4   CALLX &#_IDEPA,(&#_IDTKN,&IM_START,&#_IDESVA,&OPTSTR,&DIVEPA, +\n               &DIVDDN),VL\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   IM_TERMINATE                                               *\n* Purpose: Generate code to terminate an item manager session.        *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         IM_TERMINATE &ID=,&SPEPA=,&SPTOKEN=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN\n         GBLA  &IM_TERMINATE              SETC in open code.\n.*\n.* Obtain service processor ID values and terminate item manager.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +\n               ID=&ID,IDMAC=IM_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN\n         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT\n         CALLX &#_IDEPA,(&#_IDTKN,&IM_TERMINATE),VL\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   IM_INITIALIZE                                              *\n* Purpose: Generate code to initialize the item managed storage.      *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         IM_INITIALIZE &ID=,&SPEPA=,&SPTOKEN=,&ITDSTG=,&UAINCR=,       +\n               &SYSINCR=,&DFLTINCR=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN\n         GBLA  &IM_INITIALIZE\n.*\n.* Obtain service processor ID values.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +\n               ID=&ID,IDMAC=IM_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN\n         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT\n.*\n.* Generate the CALLX to initialize item managed storage.\n.*\n         AIF   ('&DFLTINCR' NE '').CALL5\n         AIF   ('&SYSINCR' NE '').CALL4\n         AIF   ('&UAINCR' NE '').CALL3\n         AIF   ('&ITDSTG' NE '').CALL2\n.CALL1   CALLX &#_IDEPA,(&#_IDTKN,&IM_INITIALIZE),VL\n         MEXIT\n.CALL2   CALLX &#_IDEPA,(&#_IDTKN,&IM_INITIALIZE,&ITDSTG),VL\n         MEXIT\n.CALL3   CALLX &#_IDEPA,(&#_IDTKN,&IM_INITIALIZE,&ITDSTG,              +\n               &UAINCR),VL\n         MEXIT\n.CALL4   CALLX &#_IDEPA,(&#_IDTKN,&IM_INITIALIZE,&ITDSTG,              +\n               &UAINCR,&SYSINCR),VL\n         MEXIT\n.CALL5   CALLX &#_IDEPA,(&#_IDTKN,&IM_INITIALIZE,&ITDSTG,              +\n               &UAINCR,&SYSINCR,&DFLTINCR),VL\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   IM_SAVE                                                    *\n* Purpose: Generate code to save item managed storage.                *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         IM_SAVE &ID=,&SPEPA=,&SPTOKEN=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN\n         GBLA  &IM_SAVE                   SETC in open code.\n.*\n.* Obtain service processor ID values and save IM stg.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +\n               ID=&ID,IDMAC=IM_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN\n         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT\n         CALLX &#_IDEPA,(&#_IDTKN,&IM_SAVE),VL\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   IM_RESET                                                   *\n* Purpose: Generate code to reset item managed storage.               *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         IM_RESET &ID=,&SPEPA=,&SPTOKEN=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN\n         GBLA  &IM_RESET                  SETC in open code.\n.*\n.* Obtain service processor ID values and reset IM stg.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +\n               ID=&ID,IDMAC=IM_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN\n         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT\n         CALLX &#_IDEPA,(&#_IDTKN,&IM_RESET),VL\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   IM_ADD_TO_DIRECTORY                                        *\n* Purpose: Generate code to add a token to the token directory.       *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         IM_ADD_TO_DIRECTORY &ID=,&SPEPA=,                             +\n               &SPTOKEN=,&NAME=,&TOKEN=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN\n         GBLA  &IM_ADD_TO_DIRECTORY\n         LCLC  &L_LENGTH\n.*\n.* Obtain service processor ID values.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +\n               ID=&ID,IDMAC=IM_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN\n         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT\n.*\n.* Check for the presence of required keywords.\n.*\n         AIF  ('&NAME' NE '').NAMEOK\n         MNOTE 8,'NAME (address and length) is a required keyword.'\n         MEXIT\n.NAMEOK  AIF  ('&TOKEN' NE '').REQOKAY\n         MNOTE 8,'TOKEN is a required keyword.'\n         MEXIT\n.REQOKAY ANOP\n.*\n.* Process the NAME= keyword.\n.*\n          AIF   (N'&NAME EQ 2).NAMESL     Size and length specified.\n          AIF   (N'&NAME EQ 1).LGLITCH    Use length attribute.\n          MNOTE 8,'Wrong number of parameters specified for NAME.'\n          MEXIT\n.NAMESL   ANOP\n&L_LENGTH SETC '&NAME(2)'\n          AGO .PASTNAME\n.LGLITCH  ANOP\n&L_LENGTH SETC '=A(L''&NAME(1))'\n.PASTNAME ANOP\n.*\n.* Generate the appropriate call statement.\n.*\n.CALL1   CALLX &#_IDEPA,(&#_IDTKN,&IM_ADD_TO_DIRECTORY,                +\n               &L_LENGTH,&NAME(1),&TOKEN),VL\n         MEXIT\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   IM_FIND_IN_DIRECTORY                                       *\n* Purpose: Generate code to find a token in the token directory.      *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         IM_FIND_IN_DIRECTORY &ID=,&SPEPA=,                            +\n               &SPTOKEN=,&NAME=,&TOKEN=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN\n         GBLA  &IM_FIND_IN_DIRECTORY\n         LCLC  &L_LENGTH\n.*\n.* Obtain service processor ID values.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +\n               ID=&ID,IDMAC=IM_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN\n         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT\n.*\n.* Check for the presence of required keywords.\n.*\n         AIF  ('&NAME' NE '').NAMEOK\n         MNOTE 8,'NAME (address and length) is a required keyword.'\n         MEXIT\n.NAMEOK  AIF  ('&TOKEN' NE '').REQOKAY\n         MNOTE 8,'TOKEN is a required keyword.'\n         MEXIT\n.REQOKAY ANOP\n.*\n.* Process the NAME= keyword.\n.*\n          AIF   (N'&NAME EQ 2).NAMESL     Size and length specified.\n          AIF   (N'&NAME EQ 1).LGLITCH    Use length attribute.\n          MNOTE 8,'Wrong number of parameters specified for NAME.'\n          MEXIT\n.NAMESL   ANOP\n&L_LENGTH SETC '&NAME(2)'\n          AGO .PASTNAME\n.LGLITCH  ANOP\n&L_LENGTH SETC '=A(L''&NAME(1))'\n.PASTNAME ANOP\n.*\n.* Generate the appropriate call statement.\n.*\n.CALL1   CALLX &#_IDEPA,(&#_IDTKN,&IM_FIND_IN_DIRECTORY,               +\n               &L_LENGTH,&NAME(1),&TOKEN),VL\n         MEXIT\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   IM_REMOVE_FROM_DIRECTORY                                   *\n* Purpose: Generate code to remove a name from the token directory.   *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         IM_REMOVE_FROM_DIRECTORY &ID=,&SPEPA=,                        +\n               &SPTOKEN=,&ITEMTYPE=,&NAME=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN\n         GBLA  &IM_REMOVE_FROM_DIRECTORY\n         LCLC  &L_LENGTH\n.*\n.* Obtain service processor ID values.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +\n               ID=&ID,IDMAC=IM_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN\n         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT\n.*\n.* Check for the presence of required keywords.\n.*\n         AIF  ('&NAME' NE '').NAMEOK\n         MNOTE 8,'NAME (address and length) is a required keyword.'\n         MEXIT\n.NAMEOK  ANOP\n.REQOKAY ANOP\n.*\n.* Process the NAME= keyword.\n.*\n          AIF   (N'&NAME EQ 2).NAMESL     Size and length specified.\n          AIF   (N'&NAME EQ 1).LGLITCH    Use length attribute.\n          MNOTE 8,'Wrong number of parameters specified for NAME.'\n          MEXIT\n.NAMESL   ANOP\n&L_LENGTH SETC '&NAME(2)'\n          AGO .PASTNAME\n.LGLITCH  ANOP\n&L_LENGTH SETC '=A(L''&NAME(1))'\n.PASTNAME ANOP\n.*\n.* Generate the appropriate call statement.\n.*\n.CALL1   CALLX &#_IDEPA,(&#_IDTKN,&IM_REMOVE_FROM_DIRECTORY,           +\n               &L_LENGTH,&NAME(1)),VL\n         MEXIT\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   IM_CREATE_ITEM_TYPE_DESCRIPTOR                             *\n* Purpose: Generate code to do what the macro's name says.            *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         IM_CREATE_ITEM_TYPE_DESCRIPTOR &ID=,&SPEPA=,&SPTOKEN=,        +\n               &ITEMTYPE=,&TEXT=,&OPTIONS=,&ITEMSZ=,&#LINKS=,          +\n               &LINKSOFF=,&GROUPTKN=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN\n         GBLA  &IM_CREATE_ITEM_TYPE_DESCRIPTOR    SETC in open code.\n         LCLC  &L_ITEMSZ,&L_ITEMSZ_LENSIZE,&L_ITEMSZ_OFFSET\n         LCLC  &L_#LINKS,&L_#LINKS_LENSIZE,&L_#LINKS_OFFSET\n         LCLC  &L_LINKSOFF,&L_LINKSOFF_LENSIZE,&L_LINKSOFF_OFFSET\n         LCLB  &O_FIRST_LINK_HAS_DESCRIPTION\n         LCLC  &OPTSTR\n         LCLA  &I\n.*\n.* Obtain service processor ID values.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +\n               ID=&ID,IDMAC=IM_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN\n         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT\n.*\n.* Check for the presence of required keywords.\n.*\n         AIF  ('&ITEMTYPE' NE '').REQOKAY\n         MNOTE 8,'ITEMTYPE (item type) is a required keyword.'\n         MEXIT\n.REQOKAY ANOP\n.*\n.* Decode the options and produce a byte flag for the parmlist.\n.*\n&I       SETA  1\n.OPTLOOP AIF   (&I GT N'&OPTIONS).PASTOPT\n         AIF   ('&OPTIONS(&I)' EQ 'FIRST_LINK_HAS_DESCRIPTION').OPT1\n         MNOTE 8,'Invalid option name: &OPTIONS(&I)'\n.OPT1    ANOP\n&O_FIRST_LINK_HAS_DESCRIPTION SETB 1\n         AGO   .NEXTOPT         Go process the next option.\n.NEXTOPT ANOP\n&I       SETA  &I+1             Increment index into options list.\n         AGO   .OPTLOOP         Branch back to top of loop.\n.PASTOPT ANOP\n&OPTSTR  SETC '&O_FIRST_LINK_HAS_DESCRIPTION'\n&OPTSTR  SETC '&OPTSTR.0000000'\n         AIF  ('&OPTSTR' NE '00000000').NOT_NOP\n&OPTSTR  SETC ''\n         AGO  .PAST_OPTSTR_SET\n.NOT_NOP ANOP\n&OPTSTR  SETC '=B''&OPTSTR'''\n.PAST_OPTSTR_SET ANOP\n.*\n.* Process the ItemLength parameters.\n.*\n         AIF   ('&ITEMSZ' NE '').ITEMSZ_NOT_NULL\n         MNOTE 8,'ITEMSZ keyword is required.'\n         AGO   .PAST_ITEMSZ\n.ITEMSZ_NOT_NULL ANOP\n         AIF   (N'&ITEMSZ NE 1).NOT_1_ITEMSZ\n&L_ITEMSZ  SETC '&ITEMSZ'\n         AGO   .PAST_ITEMSZ\n.NOT_1_ITEMSZ ANOP\n         AIF   ('&ITEMSZ(1)' NE 'IN_ITEM').ITEMSZ_ERROR\n         AIF   (N'&ITEMSZ EQ 3).ITEMSZ_OK\n.ITEMSZ_ERROR MNOTE 8,'Invalid ITEMSZ parameter.'\n         AGO  .PAST_ITEMSZ\n.ITEMSZ_OK ANOP\n&L_ITEMSZ_LENSIZE SETC '&ITEMSZ(3)'\n&L_ITEMSZ_OFFSET  SETC '&ITEMSZ(2)'\n.PAST_ITEMSZ  ANOP\n.*\n.* Process the NumberLinks parameters.\n.*\n         AIF   ('&#LINKS' NE '').#LINKS_NOT_NULL\n         AIF   ('&LINKSOFF' EQ '').PAST_#LINKS\n         MNOTE 8,'#LINKS keyword is required if LNKSOFF keyword is spec+\n               ified.'\n         AGO   .PAST_#LINKS\n.#LINKS_NOT_NULL ANOP\n         AIF   (N'&#LINKS NE 1).NOT_1_#LINKS\n&L_#LINKS  SETC '&#LINKS'\n         AGO   .PAST_#LINKS\n.NOT_1_#LINKS ANOP\n         AIF   ('&#LINKS(1)' NE 'IN_ITEM').#LINKS_ERROR\n         AIF   (N'&#LINKS EQ 3).#LINKS_OK\n.#LINKS_ERROR MNOTE 8,'Invalid #LINKS parameter.'\n         AGO  .PAST_#LINKS\n.#LINKS_OK ANOP\n&L_#LINKS_LENSIZE SETC '&#LINKS(3)'\n&L_#LINKS_OFFSET  SETC '&#LINKS(2)'\n.PAST_#LINKS  ANOP\n.*\n.* Process the LINKSOFF parameters.\n.*\n         AIF   ('&LINKSOFF' NE '').LINKSOFF_NOT_NULL\n         AIF   ('&LINKSOFF' EQ '').PAST_LINKSOFF\n         MNOTE 8,'LNKSOFF keyword is required if #LINKS keyword is spec+\n               ified.'\n         AGO   .PAST_LINKSOFF\n.LINKSOFF_NOT_NULL ANOP\n         AIF   (N'&LINKSOFF NE 1).NOT_1_LINKSOFF\n&L_LINKSOFF SETC '&LINKSOFF'\n         AGO   .PAST_LINKSOFF\n.NOT_1_LINKSOFF ANOP\n         AIF   ('&LINKSOFF(1)' NE 'IN_ITEM').LINKSOFF_ERROR\n         AIF   (N'&LINKSOFF EQ 3).LINKSOFF_OK\n.LINKSOFF_ERROR MNOTE 8,'Invalid LINKSOFF parameter.'\n         AGO  .PAST_LINKSOFF\n.LINKSOFF_OK ANOP\n&L_LINKSOFF_LENSIZE SETC '&LINKSOFF(3)'\n&L_LINKSOFF_OFFSET SETC '&LINKSOFF(2)'\n.PAST_LINKSOFF ANOP\n.*\n.* Generate the appropriate call.\n.*\n         AIF   ('&L_LINKSOFF_OFFSET' NE '').CALL10\n         AIF   ('&L_#LINKS_OFFSET' NE '').CALL9\n         AIF   ('&L_ITEMSZ_OFFSET' NE '').CALL8\n         AIF   ('&L_LINKSOFF' NE '').CALL7\n         AIF   ('&L_#LINKS' NE '').CALL6\n         AIF   ('&L_ITEMSZ' NE '').CALL5\n         AIF   ('&GROUPTKN' NE '' ).CALL4\n         AIF   ('&OPTSTR' NE '').CALL3\n         AIF   ('&TEXT' NE '').CALL2\n.CALL1   CALLX &#_IDEPA,(&#_IDTKN,&IM_CREATE_ITEM_TYPE_DESCRIPTOR,     +\n               &ITEMTYPE),VL\n         MEXIT\n.CALL2   CALLX &#_IDEPA,(&#_IDTKN,&IM_CREATE_ITEM_TYPE_DESCRIPTOR,     +\n               &ITEMTYPE,&TEXT),VL\n         MEXIT\n.CALL3   CALLX &#_IDEPA,(&#_IDTKN,&IM_CREATE_ITEM_TYPE_DESCRIPTOR,     +\n               &ITEMTYPE,&TEXT,&OPTSTR),VL\n         MEXIT\n.CALL4   CALLX &#_IDEPA,(&#_IDTKN,&IM_CREATE_ITEM_TYPE_DESCRIPTOR,     +\n               &ITEMTYPE,&TEXT,&OPTSTR,&GROUPTKN),VL\n         MEXIT\n.CALL5   CALLX &#_IDEPA,(&#_IDTKN,&IM_CREATE_ITEM_TYPE_DESCRIPTOR,     +\n               &ITEMTYPE,&TEXT,&OPTSTR,&GROUPTKN,                      +\n               &L_ITEMSZ),VL\n         MEXIT\n.CALL6   CALLX &#_IDEPA,(&#_IDTKN,&IM_CREATE_ITEM_TYPE_DESCRIPTOR,     +\n               &ITEMTYPE,&TEXT,&OPTSTR,&GROUPTKN,                      +\n               &L_ITEMSZ,&L_#LINKS),VL\n         MEXIT\n.CALL7   CALLX &#_IDEPA,(&#_IDTKN,&IM_CREATE_ITEM_TYPE_DESCRIPTOR,     +\n               &ITEMTYPE,&TEXT,&OPTSTR,&GROUPTKN,                      +\n               &L_ITEMSZ,&L_#LINKS,&L_LINKSOFF),VL\n         MEXIT\n.CALL8   CALLX &#_IDEPA,(&#_IDTKN,&IM_CREATE_ITEM_TYPE_DESCRIPTOR,     +\n               &ITEMTYPE,&TEXT,&OPTSTR,&GROUPTKN,                      +\n               &L_ITEMSZ,&L_#LINKS,&L_LINKSOFF,                        +\n               &L_ITEMSZ_LENSIZE,&L_ITEMSZ_OFFSET),VL\n         MEXIT\n.CALL9   CALLX &#_IDEPA,(&#_IDTKN,&IM_CREATE_ITEM_TYPE_DESCRIPTOR,     +\n               &ITEMTYPE,&TEXT,&OPTSTR,&GROUPTKN,                      +\n               &L_ITEMSZ,&L_#LINKS,&L_LINKSOFF,                        +\n               &L_ITEMSZ_LENSIZE,&L_ITEMSZ_OFFSET,                     +\n               &L_#LINKS_LENSIZE,&L_#LINKS_OFFSET),VL\n         MEXIT\n.CALL10  CALLX &#_IDEPA,(&#_IDTKN,&IM_CREATE_ITEM_TYPE_DESCRIPTOR,     +\n               &ITEMTYPE,&TEXT,&OPTSTR,&GROUPTKN,                      +\n               &L_ITEMSZ,&L_#LINKS,&L_LINKSOFF,                        +\n               &L_ITEMSZ_LENSIZE,&L_ITEMSZ_OFFSET,                     +\n               &L_#LINKS_LENSIZE,&L_#LINKS_OFFSET,                     +\n               &L_LINKSOFF_LENSIZE,&L_LINKSOFF_OFFSET),VL\n         MEXIT\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   IM_CREATE_GROUP_DESCRIPTOR                                 *\n* Purpose: Generate code to create a group descriptor.                *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         IM_CREATE_GROUP_DESCRIPTOR &ID=,&SPEPA=,&SPTOKEN=,            +\n               &DESCTKN=,&TEXT=,&STGINCR=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN\n         GBLA  &IM_CREATE_GROUP_DESCRIPTOR SETC in open code.\n.*\n.* Obtain service processor ID values.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +\n               ID=&ID,IDMAC=IM_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN\n         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT\n.*\n.* Check for the presence of required keywords.\n.*\n         AIF  ('&DESCTKN' NE '').REQOKAY\n         MNOTE 8,'DESCTKN (descriptor token) is a required keyword.'\n         MEXIT\n.REQOKAY ANOP\n.*\n.* Generate the appropriate call.\n.*\n         AIF   ('&STGINCR' NE '').CALL3\n         AIF   ('&TEXT' NE '').CALL2\n.CALL1   CALLX &#_IDEPA,(&#_IDTKN,&IM_CREATE_GROUP_DESCRIPTOR,         +\n               &DESCTKN),VL\n         MEXIT\n.CALL2   CALLX &#_IDEPA,(&#_IDTKN,&IM_CREATE_GROUP_DESCRIPTOR,         +\n               &DESCTKN,&TEXT),VL\n         MEXIT\n.CALL3   CALLX &#_IDEPA,(&#_IDTKN,&IM_CREATE_GROUP_DESCRIPTOR,         +\n               &DESCTKN,&TEXT,&STGINCR),VL\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   IM_CREATE_LINKED_LIST_DESCRIPTOR                           *\n* Purpose: Generate code to create a list descriptor.                 *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         IM_CREATE_LINKED_LIST_DESCRIPTOR &ID=,&SPEPA=,&SPTOKEN=,      +\n               &DESCTKN=,&TEXT=,&OPTIONS=,                             +\n               &FSTLNK#=,&FNLLNK#=,&NXTLNK#=,&PRLNK#=,&OWNLNK#=,       +\n               &HEADTYPE=,&KEYOFF=,&KEYSZ=,&MEMTYPE=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN\n         GBLA  &IM_CREATE_LINKED_LIST_DESCRIPTOR SETC in open code.\n         LCLB  &O_HEADS_IN_DESCRIPTOR\n         LCLB  &O_DUPLICATE_KEYS_ALLOWED\n         LCLC  &O_LIST_ORDER\n         LCLC  &L_KEYSZ,&L_KEYSZ_OFFSET\n         LCLB  &KEYED\n         LCLC  &PLINK\n&O_LIST_ORDER  SETC '000'\n.*\n.* Obtain service processor ID values.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +\n               ID=&ID,IDMAC=IM_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN\n         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT\n.*\n.* Check for the presence of required keywords.\n.*\n         AIF  ('&DESCTKN' NE '').REQOKAY\n         MNOTE 8,'DESCTKN (descriptor token) is a required keyword.'\n         MEXIT\n.REQOKAY ANOP\n.*\n.* Decode the options and produce a byte flag for the parmlist.\n.*\n&I       SETA  1\n.OPTLOOP AIF   (&I GT N'&OPTIONS).PASTOPT\n         AIF   ('&OPTIONS(&I)' EQ 'HEADS_IN_DESCRIPTOR').OPT1\n         AIF   ('&OPTIONS(&I)' EQ 'DUPLICATE_KEYS_ALLOWED').OPT2\n         AIF   ('&OPTIONS(&I)' EQ 'LIST_ORDER_FIRST').OPT3\n         AIF   ('&OPTIONS(&I)' EQ 'LIST_ORDER_FINAL').OPT4\n.*>>> NS AIF   ('&OPTIONS(&I)' EQ 'LIST_ORDER_NEXT').OPT5\n.*>>> NS AIF   ('&OPTIONS(&I)' EQ 'LIST_ORDER_PRIOR').OPT6\n.*>>> NS AIF   ('&OPTIONS(&I)' EQ 'LIST_ORDER_SORTED_ASCENDING').OPT7\n.*>>> NS AIF   ('&OPTIONS(&I)' EQ 'LIST_ORDER_SORTED_DECENDING').OPT8\n         MNOTE 8,'Invalid option name: &OPTIONS(&I)'\n.OPT1    ANOP\n&O_HEADS_IN_DESCRIPTOR SETB 1\n         AGO   .NEXTOPT         Go process the next option.\n.OPT2    ANOP\n&O_DUPLICATE_KEYS_ALLOWED SETB 1\n         AGO   .NEXTOPT         Go process the next option.\n.OPT3    ANOP\n&O_LIST_ORDER  SETC '000'\n         AGO   .NEXTOPT         Go process the next option.\n.OPT4    ANOP\n&O_LIST_ORDER  SETC '001'\n         AGO   .NEXTOPT         Go process the next option.\n.OPT5    ANOP\n&O_LIST_ORDER  SETC '010'\n         AGO   .NEXTOPT         Go process the next option.\n.OPT6    ANOP\n&O_LIST_ORDER  SETC '011'\n         AGO   .NEXTOPT         Go process the next option.\n.OPT7    ANOP\n&O_LIST_ORDER  SETC '100'\n&KEYED   SETB  1\n         AGO   .NEXTOPT         Go process the next option.\n.OPT8    ANOP\n&O_LIST_ORDER  SETC '101'\n&KEYED   SETB  1\n         AGO   .NEXTOPT         Go process the next option.\n.NEXTOPT ANOP\n&I       SETA  &I+1             Increment index into options list.\n         AGO   .OPTLOOP         Branch back to top of loop.\n.PASTOPT ANOP\n&OPTSTR  SETC '&O_HEADS_IN_DESCRIPTOR'\n&OPTSTR  SETC '&OPTSTR.&O_DUPLICATE_KEYS_ALLOWED'\n&OPTSTR  SETC '&OPTSTR.000&O_LIST_ORDER'\n         AIF  ('&OPTSTR' NE '00000000').NOT_NOP\n&OPTSTR  SETC ''\n         AGO  .PAST_OPTSTR_SET\n.NOT_NOP ANOP\n&OPTSTR  SETC '=B''&OPTSTR'''\n.PAST_OPTSTR_SET ANOP\n.*\n.* Process the KeySz parameters.\n.*\n         AIF   ('&KEYSZ' EQ '').PAST_KEYSZ\n         AIF   (N'&KEYSZ NE 1).NOT_1_KEYSZ\n&L_KEYSZ   SETC '&KEYSZ'\n         AGO   .PAST_KEYSZ\n.NOT_1_KEYSZ ANOP\n         AIF   ('&KEYSZ(1)' NE 'IN_ITEM').KEYSZ_ERROR\n         AIF   (N'&KEYSZ EQ 2).KEYSZ_OK\n.KEYSZ_ERROR MNOTE 8,'Invalid KEYSZ parameter.'\n         AGO  .PAST_KEYSZ\n.KEYSZ_OK ANOP\n&L_KEYSZ_OFFSET   SETC '&KEYSZ(2)'\n.PAST_KEYSZ   ANOP\n.*\n.* Generate the appropriate call.\n.*\n         ##PLIST START\n         ##PLIST PARM,&#_IDTKN,&IM_CREATE_LINKED_LIST_DESCRIPTOR\n         ##PLIST PARM,&DESCTKN\n.*\n         AIF   ('&MEMTYPE' NE '').CALL13\n         AIF   ('&L_KEYSZ_OFFSET' NE '').CALL12\n         AIF   ('&L_KEYSZ' NE '').CALL11\n         AIF   ('&KEYOFF'  NE '').CALL10\n         AIF   ('&HEADTYPE' NE '').CALL9\n         AIF   ('&OWNLNK#' NE '').CALL8\n         AIF   ('&PRLNK#' NE '').CALL7\n         AIF   ('&NXTLNK#' NE '').CALL6\n         AIF   ('&FNLLNK#' NE '').CALL5\n         AIF   ('&FSTLNK#' NE '').CALL4\n         AIF   ('&OPTIONS' NE '').CALL3\n         AIF   ('&TEXT' NE '').CALL2\n.CALL1   AGO   .CALLX\n.CALL2   ##PLIST PARM,&TEXT\n         AGO   .CALLX\n.CALL3   ##PLIST PARM,&TEXT,&OPTSTR\n         AGO   .CALLX\n.CALL4   ##PLIST PARM,&TEXT,&OPTSTR,&FSTLNK#\n         AGO   .CALLX\n.CALL5   ##PLIST PARM,&TEXT,&OPTSTR,&FSTLNK#,&FNLLNK#\n         AGO   .CALLX\n.CALL6   ##PLIST PARM,&TEXT,&OPTSTR,&FSTLNK#,&FNLLNK#,&NXTLNK#\n         AGO   .CALLX\n.CALL7   ##PLIST PARM,&TEXT,&OPTSTR,&FSTLNK#,&FNLLNK#,&NXTLNK#,&PRLNK#\n         AGO   .CALLX\n.CALL8   ##PLIST PARM,&TEXT,&OPTSTR,&FSTLNK#,&FNLLNK#,&NXTLNK#,&PRLNK#\n         ##PLIST PARM,&OWNLNK#\n         AGO   .CALLX\n.CALL9   ##PLIST PARM,&TEXT,&OPTSTR,&FSTLNK#,&FNLLNK#,&NXTLNK#,&PRLNK#\n         ##PLIST PARM,&OWNLNK#,&HEADTYPE\n         AGO   .CALLX\n.CALL10  ##PLIST PARM,&TEXT,&OPTSTR,&FSTLNK#,&FNLLNK#,&NXTLNK#,&PRLNK#\n         ##PLIST PARM,&OWNLNK#,&HEADTYPE,&KEYOFF\n         AGO   .CALLX\n.CALL11  ##PLIST PARM,&TEXT,&OPTSTR,&FSTLNK#,&FNLLNK#,&NXTLNK#,&PRLNK#\n         ##PLIST PARM,&OWNLNK#,&HEADTYPE,&KEYOFF,&L_KEYSZ\n         AGO   .CALLX\n.CALL12  ##PLIST PARM,&TEXT,&OPTSTR,&FSTLNK#,&FNLLNK#,&NXTLNK#,&PRLNK#\n         ##PLIST PARM,&OWNLNK#,&HEADTYPE,&KEYOFF,&L_KEYSZ\n         ##PLIST PARM,&L_KEYSZ_OFFSET\n         AGO   .CALLX\n.CALL13  ##PLIST PARM,&TEXT,&OPTSTR,&FSTLNK#,&FNLLNK#,&NXTLNK#,&PRLNK#\n         ##PLIST PARM,&OWNLNK#,&HEADTYPE,&KEYOFF,&L_KEYSZ\n         ##PLIST PARM,&L_KEYSZ_OFFSET,&MEMTYPE\n.CALLX   ##PLIST END,VL\n         CALLX   &#_IDEPA\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   IM_CREATE_HASH_TABLE_DESCRIPTOR                            *\n* Purpose: Generate code to create a hash table descriptor.           *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         IM_CREATE_HASH_TABLE_DESCRIPTOR &ID=,&SPEPA=,&SPTOKEN=,       +\n               &DESCTKN=,&TEXT=,&OPTIONS=,&ENTRIES=,                   +\n               &SYNLNK#=,&KEYOFF=,&KEYSZ=,&MEMTYPE=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN\n         GBLA  &IM_CREATE_HASH_TABLE_DESCRIPTOR SETC in open code.\n         LCLB  &O_HEADS_IN_DESCRIPTOR\n         LCLB  &O_DUPLICATE_KEYS_ALLOWED\n         LCLC  &L_KEYSZ,&L_KEYSZ_OFFSET\n         LCLB  &KEYED\n.*\n.* Obtain service processor ID values.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +\n               ID=&ID,IDMAC=IM_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN\n         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT\n.*\n.* Check for the presence of required keywords.\n.*\n         AIF  ('&DESCTKN' NE '').REQOKAY\n         MNOTE 8,'DESCTKN (descriptor token) is a required keyword.'\n         MEXIT\n.REQOKAY ANOP\n.*\n.* Decode the options and produce a byte flag for the parmlist.\n.*\n&I       SETA  1\n.OPTLOOP AIF   (&I GT N'&OPTIONS).PASTOPT\n         AIF   ('&OPTIONS(&I)' EQ 'DUPLICATE_KEYS_ALLOWED').OPT1\n         MNOTE 8,'Invalid option name: &OPTIONS(&I)'\n.OPT1    ANOP\n&O_DUPLICATE_KEYS_ALLOWED SETB 1\n         AGO   .NEXTOPT         Go process the next option.\n.NEXTOPT ANOP\n&I       SETA  &I+1             Increment index into options list.\n         AGO   .OPTLOOP         Branch back to top of loop.\n.PASTOPT ANOP\n&OPTSTR  SETC '&O_DUPLICATE_KEYS_ALLOWED.0000000'\n         AIF  ('&OPTSTR' NE '00000000').NOT_NOP\n&OPTSTR  SETC ''\n         AGO  .PAST_OPTSTR_SET\n.NOT_NOP ANOP\n&OPTSTR  SETC '=B''&OPTSTR'''\n.PAST_OPTSTR_SET ANOP\n.*\n.* Process the KeySz parameters.\n.*\n         AIF   ('&KEYSZ' EQ '').PAST_KEYSZ\n         AIF   (N'&KEYSZ NE 1).NOT_1_KEYSZ\n&L_KEYSZ   SETC '&KEYSZ'\n         AGO   .PAST_KEYSZ\n.NOT_1_KEYSZ ANOP\n         AIF   ('&KEYSZ(1)' NE 'IN_ITEM').KEYSZ_ERROR\n         AIF   (N'&KEYSZ EQ 2).KEYSZ_OK\n.KEYSZ_ERROR MNOTE 8,'Invalid KEYSZ parameter.'\n         AGO  .PAST_KEYSZ\n.KEYSZ_OK ANOP\n&L_KEYSZ_OFFSET   SETC '&KEYSZ(2)'\n.PAST_KEYSZ   ANOP\n.*\n.* Generate the appropriate call.\n.*\n         AIF   ('&MEMTYPE' NE '').CALL9\n         AIF   ('&L_KEYSZ_OFFSET' NE '').CALL8\n         AIF   ('&L_KEYSZ' NE '').CALL7\n         AIF   ('&KEYOFF'  NE '').CALL6\n         AIF   ('&SYNLNK#' NE '').CALL5\n         AIF   ('&ENTRIES' NE '').CALL4\n         AIF   ('&OPTIONS' NE '').CALL3\n         AIF   ('&TEXT' NE '').CALL2\n.CALL1   CALLX &#_IDEPA,(&#_IDTKN,&IM_CREATE_HASH_TABLE_DESCRIPTOR,    +\n               &DESCTKN),VL\n         MEXIT\n.CALL2   CALLX &#_IDEPA,(&#_IDTKN,&IM_CREATE_HASH_TABLE_DESCRIPTOR,    +\n               &DESCTKN,&TEXT),VL\n         MEXIT\n.CALL3   CALLX &#_IDEPA,(&#_IDTKN,&IM_CREATE_HASH_TABLE_DESCRIPTOR,    +\n               &DESCTKN,&TEXT,&OPTSTR),VL\n         MEXIT\n.CALL4   CALLX &#_IDEPA,(&#_IDTKN,&IM_CREATE_HASH_TABLE_DESCRIPTOR,    +\n               &DESCTKN,&TEXT,&OPTSTR,                                 +\n               &ENTRIES),VL\n         MEXIT\n.CALL5   CALLX &#_IDEPA,(&#_IDTKN,&IM_CREATE_HASH_TABLE_DESCRIPTOR,    +\n               &DESCTKN,&TEXT,&OPTSTR,                                 +\n               &ENTRIES,&SYNLNK#),VL\n         MEXIT\n.CALL6   CALLX &#_IDEPA,(&#_IDTKN,&IM_CREATE_HASH_TABLE_DESCRIPTOR,    +\n               &DESCTKN,&TEXT,&OPTSTR,                                 +\n               &ENTRIES,&SYNLNK#,&KEYOFF),VL\n         MEXIT\n.CALL7   CALLX &#_IDEPA,(&#_IDTKN,&IM_CREATE_HASH_TABLE_DESCRIPTOR,    +\n               &DESCTKN,&TEXT,&OPTSTR,                                 +\n               &ENTRIES,&SYNLNK#,&KEYOFF,&L_KEYSZ),VL\n         MEXIT\n.CALL8   CALLX &#_IDEPA,(&#_IDTKN,&IM_CREATE_HASH_TABLE_DESCRIPTOR,    +\n               &DESCTKN,&TEXT,&OPTSTR,                                 +\n               &ENTRIES,&SYNLNK#,&KEYOFF,&L_KEYSZ,                     +\n               &L_KEYSZ_OFFSET),VL\n         MEXIT\n.CALL9   CALLX &#_IDEPA,(&#_IDTKN,&IM_CREATE_HASH_TABLE_DESCRIPTOR,    +\n               &DESCTKN,&TEXT,&OPTSTR,                                 +\n               &ENTRIES,&SYNLNK#,&KEYOFF,&L_KEYSZ,                     +\n               &L_KEYSZ_OFFSET,&MEMTYPE),VL\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   IM_CONNECT                                                 *\n* Purpose: Generate code to connect an item.                          *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         IM_CONNECT &ID=,&SPEPA=,&SPTOKEN=,                            +\n               &DESCTKN=,&ITEMTKN=,&HEADTKN=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN\n         GBLA  &IM_CONNECT SETC in open code.\n.*\n.* Obtain service processor ID values.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +\n               ID=&ID,IDMAC=IM_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN\n         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT\n.*\n.* Check for the presence of required keywords.\n.*\n         AIF  ('&DESCTKN' NE '').REQOKAY\n         MNOTE 8,'DESCTKN (descriptor token) is a required keyword.'\n         MEXIT\n.REQOKAY ANOP\n.*\n.* Generate the appropriate call.\n.*\n         AIF   ('&HEADTKN' NE '').CALL3\n         AIF   ('&ITEMTKN' NE '').CALL2\n.CALL1   CALLX &#_IDEPA,(&#_IDTKN,&IM_CONNECT,                         +\n               &DESCTKN),VL\n         MEXIT\n.CALL2   CALLX &#_IDEPA,(&#_IDTKN,&IM_CONNECT,                         +\n               &DESCTKN,&ITEMTKN),VL\n         MEXIT\n.CALL3   CALLX &#_IDEPA,(&#_IDTKN,&IM_CONNECT,                         +\n               &DESCTKN,&ITEMTKN,&HEADTKN),VL\n         MEXIT\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   IM_DISCONNECT                                              *\n* Purpose: Generate code to disconnect an item.                       *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         IM_DISCONNECT &ID=,&SPEPA=,&SPTOKEN=,                         +\n               &DESCTKN=,&ITEMTKN=,&HEADTKN=,&PRTKN=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN\n         GBLA  &IM_DISCONNECT SETC in open code.\n.*\n.* Obtain service processor ID values.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +\n               ID=&ID,IDMAC=IM_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN\n         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT\n.*\n.* Check for the presence of required keywords.\n.*\n         AIF  ('&DESCTKN' NE '').REQOKAY\n         MNOTE 8,'DESCTKN (descriptor token) is a required keyword.'\n         MEXIT\n.REQOKAY ANOP\n.*\n.* Generate the appropriate call.\n.*\n         AIF   ('&PRTKN' NE '').CALL4\n         AIF   ('&HEADTKN' NE '').CALL3\n         AIF   ('&ITEMTKN' NE '').CALL2\n.CALL1   CALLX &#_IDEPA,(&#_IDTKN,&IM_DISCONNECT,                      +\n               &DESCTKN),VL\n         MEXIT\n.CALL2   CALLX &#_IDEPA,(&#_IDTKN,&IM_DISCONNECT,                      +\n               &DESCTKN,&ITEMTKN),VL\n         MEXIT\n.CALL3   CALLX &#_IDEPA,(&#_IDTKN,&IM_DISCONNECT,                      +\n               &DESCTKN,&ITEMTKN,&HEADTKN),VL\n         MEXIT\n.CALL4   CALLX &#_IDEPA,(&#_IDTKN,&IM_DISCONNECT,                      +\n               &DESCTKN,&ITEMTKN,&HEADTKN,&PRTKN),VL\n         MEXIT\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   IM_ERASE                                                   *\n* Purpose: Generate code to erase an item.                            *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         IM_ERASE &ID=,&SPEPA=,&SPTOKEN=,&ITEMTKN=,&OPTIONS=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN\n         GBLA  &IM_ERASE SETC in open code.\n         LCLB  &O_BYPASS_LINKS_CHECK\n         LCLC  &OPTSTR\n.*\n.* Obtain service processor ID values.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +\n               ID=&ID,IDMAC=IM_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN\n         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT\n.*\n.* Decode the options and produce a byte flag for the parmlist.\n.*\n&I       SETA  1\n.OPTLOOP AIF   (&I GT N'&OPTIONS).PASTOPT\n         AIF   ('&OPTIONS(&I)' EQ 'BYPASS_LINKS_CHECK').OPT1\n         AIF   ('&OPTIONS(&I)' EQ '*BYPASS').OPT2\n         MNOTE 8,'Invalid option name: &OPTIONS(&I)'\n.OPT1    ANOP\n&O_BYPASS_LINKS_CHECK SETB 1\n         AGO   .NEXTOPT         Go process the next option.\n.OPT2    ANOP\n&O_BYPASS_LINKS_CHECK SETB 1\n         AGO   .NEXTOPT         Go process the next option.\n.NEXTOPT ANOP\n&I       SETA  &I+1             Increment index into options list.\n         AGO   .OPTLOOP         Branch back to top of loop.\n.PASTOPT ANOP\n&OPTSTR  SETC '&O_BYPASS_LINKS_CHECK'\n&OPTSTR  SETC '&OPTSTR.0000000'\n         AIF  ('&OPTSTR' NE '00000000').NOT_NOP\n&OPTSTR  SETC ''\n         AGO  .PAST_OPTSTR_SET\n.NOT_NOP ANOP\n&OPTSTR  SETC '=B''&OPTSTR'''\n.PAST_OPTSTR_SET ANOP\n.*\n.* Generate the appropriate call.\n.*\n         AIF   ('&ITEMTKN' NE '').CALL3\n         AIF   ('&OPTSTR' NE '').CALL2\n.CALL1   CALLX &#_IDEPA,(&#_IDTKN,&IM_ERASE,&#_IDESVA),VL\n         MEXIT\n.CALL2   CALLX &#_IDEPA,(&#_IDTKN,&IM_ERASE,                           +\n               &OPTSTR),VL\n         MEXIT\n.CALL3   CALLX &#_IDEPA,(&#_IDTKN,&IM_ERASE,                           +\n               &OPTSTR,&ITEMTKN),VL\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   IM_GET                                                     *\n* Purpose: Generate code to get an item.                              *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         IM_GET &ID=,&SPEPA=,&SPTOKEN=,&ITEM=,&ITEMTKN=,&ACTUALSZ=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN\n         GBLA  &IM_GET                     SETC in open code.\n         LCLC  &L_LENGTH\n.*\n.* Obtain service processor ID values.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +\n               ID=&ID,IDMAC=IM_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN\n         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT\n.*\n.* Check for the presence of required keywords.\n.*\n         AIF  ('&ITEM' NE '').ITEMOK\n         MNOTE 8,'ITEM (address and length) is a required keyword.'\n         MEXIT\n.ITEMOK  ANOP\n.*\n.* Process the ITEM= keyword.\n.*\n          AIF   (N'&ITEM EQ 2).ITEMSL     Size and length specified.\n          AIF   (N'&ITEM EQ 1).LGLITCH    Use length attribute.\n          MNOTE 8,'Wrong number of parameters specified for ITEM.'\n          MEXIT\n.ITEMSL   ANOP\n&L_LENGTH SETC '&ITEM(2)'\n          AGO .PASTITEM\n.LGLITCH  ANOP\n&L_LENGTH SETC '=A(L''&ITEM(1))'\n.PASTITEM ANOP\n.*\n.* Generate the appropriate call statement.\n.*\n         AIF   ('&ITEMTKN' NE '').CALL3\n         AIF   ('&ACTUALSZ' NE '').CALL2\n.CALL1   CALLX &#_IDEPA,(&#_IDTKN,&IM_GET,                             +\n               &L_LENGTH,&ITEM(1)),VL\n         MEXIT\n.CALL2   CALLX &#_IDEPA,(&#_IDTKN,&IM_GET,                             +\n               &L_LENGTH,&ITEM(1),&ACTUALSZ),VL\n         MEXIT\n.CALL3   CALLX &#_IDEPA,(&#_IDTKN,&IM_GET,                             +\n               &L_LENGTH,&ITEM(1),&ACTUALSZ,&ITEMTKN),VL\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   IM_GET_DANGEROUS_ADDRESSES                                 *\n* Purpose: Generate code to get an item.                              *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         IM_GET_DANGEROUS_ADDRESSES &ID=,&SPEPA=,&SPTOKEN=,&TKNCNVT=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN\n         GBLA  &IM_GET_DANGEROUS_ADDRESSES SETC in open code.\n.*\n.* Obtain service processor ID values.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +\n               ID=&ID,IDMAC=IM_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN\n         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT\n.*\n.* Get TKNCNVT this macro call or the default from ID macro.\n.*\n&L_TKNCNVT SETC '&TKNCNVT'\n         AIF   ('&TKNCNVT' NE '').TKNCNVT_OK\n&V_TKNCNVT       SETC '#$&ID.$#TKNCNVT'     Variable for TKNCNVT=.\n                 GBLC &(&V_TKNCNVT)         Declare global variable.\n&L_TKNCNVT SETC '&(&V_TKNCNVT)'\n.TKNCNVT_OK   ANOP\n.*\n.* Generate the appropriate call statement.\n.*\n         AIF   ('&L_TKNCNVT' NE '').CALL2\n.CALL1   CALLX &#_IDEPA,(&#_IDTKN,&IM_GET_DANGEROUS_ADDRESSES)\n         MEXIT\n.CALL2   CALLX &#_IDEPA,(&#_IDTKN,&IM_GET_DANGEROUS_ADDRESSES,         +\n               &L_TKNCNVT),VL\n         MEXIT\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   IM_CONVERT_TOKEN_TO_ADDRESS                                *\n* Purpose: Generate code to call TKNCNVT routine to convert a token   *\n*          to an address.                                             *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         IM_CONVERT_TOKEN_TO_ADDRESS &ID=,&SPEPA=,&SPTOKEN=,           +\n               &TKNCNVT=,&ITEMTKN=,&ITEMADDR=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN\n.*\n.* Obtain service processor ID values.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +\n               ID=&ID,IDMAC=IM_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN\n         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT\n.*\n.* Get TKNCNVT this macro call or the default from ID macro.\n.*\n&L_TKNCNVT SETC '&TKNCNVT'\n         AIF   ('&TKNCNVT' NE '').TKNCNVT_OK\n&V_TKNCNVT       SETC '#$&ID.$#TKNCNVT'     Variable for TKNCNVT=.\n                 GBLC &(&V_TKNCNVT)         Declare global variable.\n&L_TKNCNVT SETC '&(&V_TKNCNVT)'\n         AIF   ('&L_TKNCNVT' NE '').TKNCNVT_OK\n         MNOTE 8,'TKNCNVT keyword is required on this macro or the asso+\n               ciated IM_ID macro.'\n.TKNCNVT_OK   ANOP\n.*\n.* Check for the presence of required keywords.\n.*\n         AIF  ('&ITEMTKN' NE '').ITEMTKN_OK\n         MNOTE 8,'ITEMTKN (item token) is a required keyword.'\n         MEXIT\n.ITEMTKN_OK ANOP\n         AIF  ('&ITEMADDR' NE '').ITEMADDR_OK\n         MNOTE 8,'ITEMADDR (item address) is a required keyword.'\n         MEXIT\n.ITEMADDR_OK ANOP\n.*\n.* Generate the call.\n.*\n         ##L   R0,&ITEMTKN.,WREG=R1   | Load token into r1.\n         L     R1,&#_IDTKN            | Load token of item manager.\n         CALLX &L_TKNCNVT             | Call conversion routine.\n         ##ST  R1,&ITEMADDR           | Store result.\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   IM_MODIFY                                                  *\n* Purpose: Generate code to modify an item.                           *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         IM_MODIFY &ID=,&SPEPA=,&SPTOKEN=,&ITEM=,&ITEMTKN=,&OPTIONS=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN\n         GBLA  &IM_MODIFY SETC in open code.\n         LCLB  &O_BYPASS_LINKS_CHECK,&O_UPDATE_LINKS\n         LCLC  &OPTSTR\n.*\n.* Obtain service processor ID values.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +\n               ID=&ID,IDMAC=IM_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN\n         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT\n.*\n.* Check for the presence of required keywords.\n.*\n         AIF  ('&ITEM' NE '').REQOKAY\n         MNOTE 8,'ITEM (item address) is a required keyword.'\n         MEXIT\n.REQOKAY ANOP\n.*\n.* Decode the options and produce a byte flag for the parmlist.\n.*\n&I       SETA  1\n.OPTLOOP AIF   (&I GT N'&OPTIONS).PASTOPT\n         AIF   ('&OPTIONS(&I)' EQ 'BYPASS_LINKS_CHECK').OPT1\n         AIF   ('&OPTIONS(&I)' EQ 'UPDATE_LINKS').OPT2\n         MNOTE 8,'Invalid option name: &OPTIONS(&I)'\n.OPT1    ANOP\n&O_BYPASS_LINKS_CHECK SETB 1\n         AGO   .NEXTOPT         Go process the next option.\n.OPT2    ANOP\n&O_UPDATE_LINKS   SETB 1\n         AGO   .NEXTOPT         Go process the next option.\n.NEXTOPT ANOP\n&I       SETA  &I+1             Increment index into options list.\n         AGO   .OPTLOOP         Branch back to top of loop.\n.PASTOPT ANOP\n&OPTSTR  SETC '&O_BYPASS_LINKS_CHECK'\n&OPTSTR  SETC '&OPTSTR.&O_UPDATE_LINKS'\n&OPTSTR  SETC '&OPTSTR.000000'\n         AIF  ('&OPTSTR' NE '00000000').NOT_NOP\n&OPTSTR  SETC ''\n         AGO  .PAST_OPTSTR_SET\n.NOT_NOP ANOP\n&OPTSTR  SETC '=B''&OPTSTR'''\n.PAST_OPTSTR_SET ANOP\n.*\n.* Generate the appropriate call.\n.*\n         AIF   ('&OPTSTR' NE '').CALL3\n         AIF   ('&ITEMTKN' NE '').CALL2\n.CALL1   CALLX &#_IDEPA,(&#_IDTKN,&IM_MODIFY,                          +\n               &ITEM),VL\n         MEXIT\n.CALL2   CALLX &#_IDEPA,(&#_IDTKN,&IM_MODIFY,                          +\n               &ITEM,&OPTSTR,&ITEMTKN),VL\n         MEXIT\n.CALL3   CALLX &#_IDEPA,(&#_IDTKN,&IM_MODIFY,                          +\n               &ITEM,&OPTSTR,&ITEMTKN),VL\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   IM_SORT                                                    *\n* Purpose: Generate code to sort a structure.                         *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         IM_SORT &ID=,&SPEPA=,&SPTOKEN=,                               +\n               &DESCTKN=,&FIELDS=,&FIELDSLIST=,&HEADTKN=,&TECHNIQUE=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN\n         GBLA  &IM_SORT SETC in open code.\n         LCLC  &L_FIELDSLIST\n         LCLA  &L_TECHNIQUE\n         GBLA  &IM_SORT_TECHNIQUE_QUICK_SORT\n         GBLA  &IM_SORT_TECHNIQUE_BUBBLE_SORT\n.*\n.* Obtain service processor ID values.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +\n               ID=&ID,IDMAC=IM_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN\n         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT\n.*\n.* Check for the presence of required keywords.\n.*\n         AIF  ('&DESCTKN' NE '').REQOKAY\n         MNOTE 8,'DESCTKN (descriptor token) is a required keyword.'\n         MEXIT\n.REQOKAY ANOP\n         AIF  ('&FIELDS' NE '' OR '&FIELDSLIST' NE '').FIELDS_OKAY\n         MNOTE 8,'Either the FIELDS or the FIELDSLIST keyword is requir+\n               ed.'\n         MEXIT\n.FIELDS_OKAY ANOP\n         AIF  ('&FIELDS' EQ '' OR '&FIELDSLIST' EQ '').FIELDS_OKAY2\n         MNOTE 8,'The FIELDS and the FIELDSLIST keywords are mutually e+\n               xclusive.'\n         MEXIT\n.FIELDS_OKAY2 ANOP\n.*\n.*  Process the FIELDS or FIELDSLIST keyword.\n.*\n         AIF  ('&FIELDSLIST' EQ '').NOT_FIELDSLIST\n&L_FIELDSLIST SETC '&FIELDSLIST'\n         AGO  .PAST_FIELDS_PROCESS\n.NOT_FIELDSLIST ANOP\n&L_FIELDSLIST SETC 'IM_SORT__FIELDSLIST_&SYSNDX'\n         PSD  TYPE=PARTIAL\n         IM_SORT_FIELDSLIST NAME=&L_FIELDSLIST,FIELDS=&FIELDS\n         ENDPSD\n.PAST_FIELDS_PROCESS ANOP\n.*\n.*  Process TECHNIQUE.\n.*\n&L_TECHNIQUE  SETA 0\n         AIF   ('&TECHNIQUE' EQ '').PAST_TECHNIQUE\n         AIF   ('&TECHNIQUE' EQ 'QUICK_SORT').QUICK_SORT\n         AIF   ('&TECHNIQUE' EQ 'BUBBLE_SORT').BUBBLE_SORT\n         MNOTE 8,'Invalid TECHNIQUE &TECHNIQUE..'\n         AGO   .PAST_TECHNIQUE\n.QUICK_SORT ANOP\n&L_TECHNIQUE SETA &IM_SORT_TECHNIQUE_QUICK_SORT\n         AGO   .PAST_TECHNIQUE\n.BUBBLE_SORT ANOP\n&L_TECHNIQUE SETA &IM_SORT_TECHNIQUE_BUBBLE_SORT\n.PAST_TECHNIQUE ANOP\n.*\n.* Generate the appropriate call.\n.*\n         AIF   (&L_TECHNIQUE NE 0).CALL3\n         AIF   ('&HEADTKN' NE '').CALL2\n.CALL1   CALLX &#_IDEPA,(&#_IDTKN,&IM_SORT,&DESCTKN,&L_FIELDSLIST),VL\n         MEXIT\n.CALL2   CALLX &#_IDEPA,(&#_IDTKN,&IM_SORT,&DESCTKN,&L_FIELDSLIST,     +\n               &HEADTKN),VL\n         MEXIT\n.CALL3   CALLX &#_IDEPA,(&#_IDTKN,&IM_SORT,&DESCTKN,&L_FIELDSLIST,     +\n               &HEADTKN,&L_TECHNIQUE),VL\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   IM_SORT_FIELDSLIST                                         *\n* Purpose: Generate static SFD.                                       *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         IM_SORT_FIELDSLIST &NAME=,&FIELDS=\n           GBLA  &IM_SFD_TYPE_CHARACTER\n           GBLA  &IM_SFD_TYPE_CHAR\n           GBLA  &IM_SFD_TYPE_PACKED\n           GBLA  &IM_SFD_TYPE_ZONED\n           GBLA  &IM_SFD_TYPE_FIXED\n           GBLA  &IM_SFD_TYPE_BIT\n.*\n.* Check for the presence of required keywords.\n.*\n         AIF  ('&NAME' NE '').NAME_OK\n         MNOTE 8,'NAME (fields list name) is a required keyword.'\n         MEXIT\n.NAME_OK ANOP\n         AIF  ('&FIELDS' NE '').FIELDS_OKAY\n         MNOTE 8,'FIELDS (sort fields) is a required keyword.'\n         MEXIT\n.FIELDS_OKAY ANOP\n.*\n.*  Generate fields table.\n.*\n         DS    0F                     Fullword alignment.\n&NAME    DC    CL4'SFD '              Control block identification.\n&CNT     SETA  N'&FIELDS\n         DC    F'&CNT'                Number of entries in array.\n&CNT     SETA  1\n.LOOP    ANOP\n         AIF   (N'&FIELDS(&CNT) GE 2 AND N'&FIELDS(&CNT) LE 4).FIELD_OK\n         MNOTE 8,'Incorrect number of fields - &FIELDS(&CNT).'\n         AGO   .NEXT\n.FIELD_OK ANOP\n         DC    A(&FIELDS(&CNT,1))     Offset of field.\n         AIF   ('&FIELDS(&CNT,2)' EQ '').NO_LEN\n         DC    A(&FIELDS(&CNT,2))     Length of field, or bit-mask.\n         AGO   .PAST_LEN\n.NO_LEN  DC    A(L'&FIELDS(&CNT,1))   Length of field.\n.PAST_LEN ANOP\n         AIF   ('&FIELDS(&CNT,3)' NE '' AND '&FIELDS(&CNT,3)' NE 'CHAR'+\n               ).NOT_CHAR_A\n         DC    H'&IM_SFD_TYPE_CHARACTER' Type character.\n         AGO   .PAST_TYPE\n.NOT_CHAR_A AIF  ('&FIELDS(&CNT,3)' NE 'PACKED').NOT_PACKED_A\n         DC    H'&IM_SFD_TYPE_PACKED'    Type packed.\n         AGO   .PAST_TYPE\n.NOT_PACKED_A AIF  ('&FIELDS(&CNT,3)' NE 'ZONED').NOT_ZONED_A\n         DC    H'&IM_SFD_TYPE_ZONED'     Type zoned.\n         AGO   .PAST_TYPE\n.NOT_ZONED_A AIF  ('&FIELDS(&CNT,3)' NE 'FIXED').NOT_FIXED_A\n         DC    H'&IM_SFD_TYPE_FIXED'     Type fixed.\n         AGO   .PAST_TYPE\n.NOT_FIXED_A AIF  ('&FIELDS(&CNT,3)' NE 'BIT').NOT_BIT_A\n         DC    H'&IM_SFD_TYPE_BIT'       Type bit.\n         AIF   ('&FIELDS(&CNT,2)' EQ '').NO_MASK\n         AGO   .PAST_TYPE\n.NO_MASK ANOP\n         MNOTE 8,'Bit mask required as second parameter'\n         AGO   .PAST_TYPE\n.NOT_BIT_A ANOP\n         MNOTE 8,'Invalid type &FIELDS(&CNT,3) in field &FIELDS(&CNT).'\n.PAST_TYPE  ANOP\n         AIF   ('&FIELDS(&CNT,4)' EQ 'DESCENDING').DESCENDING\n         AIF   ('&FIELDS(&CNT,4)' EQ '' OR '&FIELDS(&CNT,4)' EQ 'ASCEND+\n               ING').ASCENDING\n         MNOTE 8,'Invalid order &FIELDS(&CNT,4) in field &FIELDS(&CNT).+\n               '\n.ASCENDING  ANOP\n         DC    X'00'                     Order ascending.\n         AGO   .PAST_ORDER\n.DESCENDING ANOP\n         DC    X'80'                     Order descending.\n.PAST_ORDER ANOP\n         DC    X'00'                  Not used.\n.NEXT    ANOP\n&CNT     SETA  &CNT+1\n         AIF   (&CNT LE N'&FIELDS).LOOP\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   IM_SORT_FIELDS START name                                  *\n*           IM_SORT_FIELD OFFSET,LENGTH,TYPE,ORDER                    *\n*           IM_SORT_FIELD OFFSET,LENGTH,TYPE,ORDER                    *\n*           IM_SORT_FIELD OFFSET,LENGTH,TYPE,ORDER                    *\n*           ...                                                       *\n*          IM_SORT_FIELDS END                                         *\n* Purpose: Generate static SFD.                                       *\n*                                                                     *\n*---------------------------------------------------------------------*\n           MACRO\n           IM_SORT_FIELDS &TYPE,&NAME\n           GBLC &SF_NAME\n           GBLA &SF_CNT\n           AIF  ('&TYPE' EQ 'START').T_START\n           AIF  ('&TYPE' EQ 'END').T_END\n           MNOTE 8,'Invalid type for IM_SORT_FIELDS macro'\n           MEXIT\n.T_START   ANOP\n&SF_NAME   SETC  '&NAME'\n           DS    0F                           Fullword alignment.\n&NAME      DC    CL4'SFD '                    Control block id.\n&NAME._CNT DC    F'0'                         #entries in array.\n&SF_CNT    SETA  0\n           MEXIT\n.T_END     ANOP\n           ORG   &SF_NAME._CNT                Org to #entries.\n&SF_NAME._#FIELDS EQU  &SF_CNT                Equate with #fields.\n           DC    F'&SF_CNT'                   Set correct value.\n           ORG   ,                            Resume location counter.\n           MEND\n           MACRO\n           IM_SORT_FIELD &OFFSET,&LENGTH,&TYPE,&ORDER\n           GBLA  &IM_SFD_TYPE_CHARACTER\n           GBLA  &IM_SFD_TYPE_CHAR\n           GBLA  &IM_SFD_TYPE_PACKED\n           GBLA  &IM_SFD_TYPE_ZONED\n           GBLA  &IM_SFD_TYPE_FIXED\n           GBLA  &IM_SFD_TYPE_BIT\n           LCLC  &T\n&T         SETC  '&TYPE'\n           AIF   ('&TYPE' NE '').HAVE_TYPE\n&T         SETC  'CHAR'\n.HAVE_TYPE ANOP\n           GBLA &SF_CNT\n&SF_CNT    SETA &SF_CNT+1\n           DC   A(&OFFSET)                    Offset of field.\n           DC   A(&LENGTH)                    Length/Mask for field.\n           DC   H'&(IM_SFD_TYPE_&T.)'         Data type for field.\n           AIF  ('&ORDER' EQ '').A\n           AIF  ('&ORDER' EQ 'A' OR '&ORDER' EQ 'ASCENDING').A\n           AIF  ('&ORDER' EQ 'D' OR '&ORDER' EQ 'DESCENDING').D\n           MNOTE 8,'Invalid sort direction: &ORDER.'\n.A         ANOP\n           DC    X'00'                        Order ascending.\n           AGO   .PAST_ORD\n.D         ANOP\n           DC    X'80'                        Order descending.\n.PAST_ORD  ANOP\n           DC    X'00'                        Not used.\n.MEXIT     MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   IM_FIND                                                    *\n* Purpose: Generate code to FIND an item.                             *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         IM_FIND &ID=,&SPEPA=,&SPTOKEN=,&ITEMTKN=,&ACTUALSZ=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN\n         GBLA  &IM_FIND                    SETC in open code.\n         LCLC  &L_LENGTH\n.*\n.* FIND service processor ID values.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +\n               ID=&ID,IDMAC=IM_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN\n         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT\n.*\n.* Check for the presence of required keywords.\n.*\n         AIF  ('&ITEMTKN' NE '').REQOKAY\n         MNOTE 8,'ITEMTKN (item token) is a required keyword.'\n         MEXIT\n.REQOKAY ANOP\n.*\n.* Generate the appropriate call statement.\n.*\n         AIF   ('&ACTUALSZ' NE '').CALL2\n.CALL1   CALLX &#_IDEPA,(&#_IDTKN,&IM_FIND,&ITEMTKN),VL\n         MEXIT\n.CALL2   CALLX &#_IDEPA,(&#_IDTKN,&IM_FIND,&ITEMTKN,&ACTUALSZ),VL\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   IM_FIND_BY_KEY                                             *\n* Purpose: Generate code to find by key.                              *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         IM_FIND_BY_KEY &ID=,&SPEPA=,                                  +\n               &SPTOKEN=,&DESCTKN=,&KEY=,                              +\n               &ITEMTKN=,&ACTUALSZ=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN\n         GBLA  &IM_FIND_BY_KEY\n         LCLC  &K_LENGTH\n.*\n.* Obtain service processor ID values.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +\n               ID=&ID,IDMAC=IM_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN\n         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT\n.*\n.* Check for the presence of required keywords.\n.*\n         AIF  ('&KEY' NE '').KEYOK\n         MNOTE 8,'KEY (search key) is a required keyword.'\n         MEXIT\n.KEYOK   AIF  ('&DESCTKN' NE '').REQOKAY\n         MNOTE 8,'DESCTKN (item type) is a required keyword.'\n         MEXIT\n.REQOKAY ANOP\n.*\n.* Process the KEY= keyword.\n.*\n          AIF   (N'&KEY EQ 2).KEYSL       Size and length specified.\n          AIF   (N'&KEY EQ 1).KYLITCH     Use length attribute.\n          MNOTE 8,'Wrong number of parameters specified for KEY.'\n          MEXIT\n.KEYSL    ANOP\n&K_LENGTH SETC '&KEY(2)'\n          AGO .PASTKEY\n.KYLITCH  ANOP\n&K_LENGTH SETC '=A(L''&KEY(1))'\n.PASTKEY ANOP\n.*\n.* Generate the appropriate call statement.\n.*\n         AIF   ('&ITEMTKN' NE '').CALL3\n         AIF   ('&ACTUALSZ' NE '').CALL2\n.CALL1   CALLX &#_IDEPA,(&#_IDTKN,&IM_FIND_BY_KEY,                     +\n               &DESCTKN,&K_LENGTH,&KEY(1)),VL\n         MEXIT\n.CALL2   CALLX &#_IDEPA,(&#_IDTKN,&IM_FIND_BY_KEY,                     +\n               &DESCTKN,&K_LENGTH,&KEY(1),                             +\n               &ACTUALSZ),VL\n         MEXIT\n.CALL3   CALLX &#_IDEPA,(&#_IDTKN,&IM_FIND_BY_KEY,                     +\n               &DESCTKN,&K_LENGTH,&KEY(1),                             +\n               &ACTUALSZ,&ITEMTKN),VL\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   IM_FIND_CURRENT_OF_ITEM_TYPE                               *\n* Purpose: Generate code to find current of item type.                *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         IM_FIND_CURRENT_OF_ITEM_TYPE &ID=,&SPEPA=,                    +\n               &SPTOKEN=,&ITEMTYPE=,&ITEMTKN=,&ACTUALSZ=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN\n         GBLA  &IM_FIND_CURRENT_OF_ITEM_TYPE\n         LCLC  &L_LENGTH\n.*\n.* FIND service processor ID values.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +\n               ID=&ID,IDMAC=IM_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN\n         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT\n.*\n.* Check for the presence of required keywords.\n.*\n         AIF  ('&ITEMTYPE' NE '').REQOKAY\n         MNOTE 8,'ITEMTYPE (item type) is a required keyword.'\n         MEXIT\n.REQOKAY ANOP\n.*\n.* Generate the appropriate call statement.\n.*\n         AIF   ('&ITEMTKN' NE '').CALL3\n         AIF   ('&ACTUALSZ' NE '').CALL2\n.CALL1   CALLX &#_IDEPA,(&#_IDTKN,&IM_FIND_CURRENT_OF_ITEM_TYPE,       +\n               &ITEMTYPE),VL\n         MEXIT\n.CALL2   CALLX &#_IDEPA,(&#_IDTKN,&IM_FIND_CURRENT_OF_ITEM_TYPE,       +\n               &ITEMTYPE,&ACTUALSZ),VL\n         MEXIT\n.CALL3   CALLX &#_IDEPA,(&#_IDTKN,&IM_FIND_CURRENT_OF_ITEM_TYPE,       +\n               &ITEMTYPE,&ACTUALSZ,&ITEMTKN),VL\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   IM_FIND_CURRENT_OF_DESCRIPTOR                              *\n* Purpose: Generate code to find current of descriptor.               *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         IM_FIND_CURRENT_OF_DESCRIPTOR &ID=,&SPEPA=,                   +\n               &SPTOKEN=,&DESCTKN=,&ITEMTKN=,&ACTUALSZ=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN\n         GBLA  &IM_FIND_CURRENT_OF_DESCRIPTOR\n         LCLC  &L_LENGTH\n.*\n.* FIND service processor ID values.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +\n               ID=&ID,IDMAC=IM_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN\n         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT\n.*\n.* Check for the presence of required keywords.\n.*\n         AIF  ('&DESCTKN' NE '').REQOKAY\n         MNOTE 8,'DESCTKN (item type) is a required keyword.'\n         MEXIT\n.REQOKAY ANOP\n.PASTITEM ANOP\n.*\n.* Generate the appropriate call statement.\n.*\n         AIF   ('&ITEMTKN' NE '').CALL3\n         AIF   ('&ACTUALSZ' NE '').CALL2\n.CALL1   CALLX &#_IDEPA,(&#_IDTKN,&IM_FIND_CURRENT_OF_DESCRIPTOR,      +\n               &DESCTKN),VL\n         MEXIT\n.CALL2   CALLX &#_IDEPA,(&#_IDTKN,&IM_FIND_CURRENT_OF_DESCRIPTOR,      +\n               &DESCTKN,&ACTUALSZ),VL\n         MEXIT\n.CALL3   CALLX &#_IDEPA,(&#_IDTKN,&IM_FIND_CURRENT_OF_DESCRIPTOR,      +\n               &DESCTKN,&ACTUALSZ,&ITEMTKN),VL\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   IM_FIND_NEXT                                               *\n* Purpose: Generate code to find the next item for a descriptor.      *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         IM_FIND_NEXT &ID=,&SPEPA=,                                    +\n               &SPTOKEN=,&DESCTKN=,&ITEMTKN=,&ACTUALSZ=,               +\n               &HEADTKN=,&CURTKN=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN\n         GBLA  &IM_FIND_NEXT\n         LCLC  &L_LENGTH\n.*\n.* FIND service processor ID values.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +\n               ID=&ID,IDMAC=IM_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN\n         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT\n.*\n.* Check for the presence of required keywords.\n.*\n         AIF  ('&DESCTKN' NE '').REQOKAY\n         MNOTE 8,'DESCTKN (item type) is a required keyword.'\n         MEXIT\n.REQOKAY ANOP\n.*\n.* Generate the appropriate call statement.\n.*\n         AIF   ('&HEADTKN' NE '').CALL5\n         AIF   ('&CURTKN' NE '').CALL4\n         AIF   ('&ITEMTKN' NE '').CALL3\n         AIF   ('&ACTUALSZ' NE '').CALL2\n.CALL1   CALLX &#_IDEPA,(&#_IDTKN,&IM_FIND_NEXT,                       +\n               &DESCTKN),VL\n         MEXIT\n.CALL2   CALLX &#_IDEPA,(&#_IDTKN,&IM_FIND_NEXT,                       +\n               &DESCTKN,&ACTUALSZ),VL\n         MEXIT\n.CALL3   CALLX &#_IDEPA,(&#_IDTKN,&IM_FIND_NEXT,                       +\n               &DESCTKN,&ACTUALSZ,&ITEMTKN),VL\n         MEXIT\n.CALL4   CALLX &#_IDEPA,(&#_IDTKN,&IM_FIND_NEXT,                       +\n               &DESCTKN,&ACTUALSZ,&ITEMTKN,&CURTKN),VL\n         MEXIT\n.CALL5   CALLX &#_IDEPA,(&#_IDTKN,&IM_FIND_NEXT,                       +\n               &DESCTKN,&ACTUALSZ,&ITEMTKN,&CURTKN,&HEADTKN),VL\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   IM_FIND_PRIOR                                              *\n* Purpose: Generate code to find the prior item for a descriptor.     *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         IM_FIND_PRIOR &ID=,&SPEPA=,                                   +\n               &SPTOKEN=,&DESCTKN=,&ITEMTKN=,&ACTUALSZ=,               +\n               &CURTKN=,&HEADTKN=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN\n         GBLA  &IM_FIND_PRIOR\n         LCLC  &L_LENGTH\n.*\n.* FIND service processor ID values.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +\n               ID=&ID,IDMAC=IM_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN\n         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT\n.*\n.* Check for the presence of required keywords.\n.*\n         AIF  ('&DESCTKN' NE '').REQOKAY\n         MNOTE 8,'DESCTKN (item type) is a required keyword.'\n         MEXIT\n.REQOKAY ANOP\n.*\n.* Generate the appropriate call statement.\n.*\n         AIF   ('&HEADTKN' NE '').CALL5\n         AIF   ('&CURTKN' NE '').CALL4\n         AIF   ('&ITEMTKN' NE '').CALL3\n         AIF   ('&ACTUALSZ' NE '').CALL2\n.CALL1   CALLX &#_IDEPA,(&#_IDTKN,&IM_FIND_PRIOR,                      +\n               &DESCTKN),VL\n         MEXIT\n.CALL2   CALLX &#_IDEPA,(&#_IDTKN,&IM_FIND_PRIOR,                      +\n               &DESCTKN,&ACTUALSZ),VL\n         MEXIT\n.CALL3   CALLX &#_IDEPA,(&#_IDTKN,&IM_FIND_PRIOR,                      +\n               &DESCTKN,&ACTUALSZ,&ITEMTKN),VL\n         MEXIT\n.CALL4   CALLX &#_IDEPA,(&#_IDTKN,&IM_FIND_PRIOR,                      +\n               &DESCTKN,&ACTUALSZ,&ITEMTKN,&CURTKN),VL\n         MEXIT\n.CALL5   CALLX &#_IDEPA,(&#_IDTKN,&IM_FIND_PRIOR,                      +\n               &DESCTKN,&ACTUALSZ,&ITEMTKN,&CURTKN,&HEADTKN),VL\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   IM_FIND_OWNER                                              *\n* Purpose: Generate code to find the owner item for a descriptor.     *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         IM_FIND_OWNER &ID=,&SPEPA=,                                   +\n               &SPTOKEN=,&DESCTKN=,&ITEMTKN=,&ACTUALSZ=,&CURTKN=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN\n         GBLA  &IM_FIND_OWNER\n         LCLC  &L_LENGTH\n.*\n.* FIND service processor ID values.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +\n               ID=&ID,IDMAC=IM_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN\n         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT\n.*\n.* Check for the presence of required keywords.\n.*\n         AIF  ('&DESCTKN' NE '').REQOKAY\n         MNOTE 8,'DESCTKN (item type) is a required keyword.'\n         MEXIT\n.REQOKAY ANOP\n.*\n.* Generate the appropriate call statement.\n.*\n         AIF   ('&CURTKN' NE '').CALL4\n         AIF   ('&ITEMTKN' NE '').CALL3\n         AIF   ('&ACTUALSZ' NE '').CALL2\n.CALL1   CALLX &#_IDEPA,(&#_IDTKN,&IM_FIND_OWNER,                      +\n               &DESCTKN),VL\n         MEXIT\n.CALL2   CALLX &#_IDEPA,(&#_IDTKN,&IM_FIND_OWNER,                      +\n               &DESCTKN,&ACTUALSZ),VL\n         MEXIT\n.CALL3   CALLX &#_IDEPA,(&#_IDTKN,&IM_FIND_OWNER,                      +\n               &DESCTKN,&ACTUALSZ,&ITEMTKN),VL\n         MEXIT\n.CALL4   CALLX &#_IDEPA,(&#_IDTKN,&IM_FIND_OWNER,                      +\n               &DESCTKN,&ACTUALSZ,&ITEMTKN,&CURTKN),VL\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   IM_FIND_FIRST                                              *\n* Purpose: Generate code to find the first item for a descriptor.     *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         IM_FIND_FIRST &ID=,&SPEPA=,                                   +\n               &SPTOKEN=,&DESCTKN=,&ITEMTKN=,&ACTUALSZ=,&HEADTKN=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN\n         GBLA  &IM_FIND_FIRST\n         LCLC  &L_LENGTH\n.*\n.* FIND service processor ID values.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +\n               ID=&ID,IDMAC=IM_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN\n         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT\n.*\n.* Check for the presence of required keywords.\n.*\n         AIF  ('&DESCTKN' NE '').REQOKAY\n         MNOTE 8,'DESCTKN (item type) is a required keyword.'\n         MEXIT\n.REQOKAY ANOP\n.*\n.* Generate the appropriate call statement.\n.*\n         AIF   ('&HEADTKN' NE '').CALL4\n         AIF   ('&ITEMTKN' NE '').CALL3\n         AIF   ('&ACTUALSZ' NE '').CALL2\n.CALL1   CALLX &#_IDEPA,(&#_IDTKN,&IM_FIND_FIRST,                      +\n               &DESCTKN),VL\n         MEXIT\n.CALL2   CALLX &#_IDEPA,(&#_IDTKN,&IM_FIND_FIRST,                      +\n               &DESCTKN,&ACTUALSZ),VL\n         MEXIT\n.CALL3   CALLX &#_IDEPA,(&#_IDTKN,&IM_FIND_FIRST,                      +\n               &DESCTKN,&ACTUALSZ,&ITEMTKN),VL\n         MEXIT\n.CALL4   CALLX &#_IDEPA,(&#_IDTKN,&IM_FIND_FIRST,                      +\n               &DESCTKN,&ACTUALSZ,&ITEMTKN,&HEADTKN),VL\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   IM_FIND_FINAL                                              *\n* Purpose: Generate code to find the final item for a descriptor.     *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         IM_FIND_FINAL &ID=,&SPEPA=,                                   +\n               &SPTOKEN=,&DESCTKN=,&ITEMTKN=,&ACTUALSZ=,&HEADTKN=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN\n         GBLA  &IM_FIND_FINAL\n         LCLC  &L_LENGTH\n.*\n.* FIND service processor ID values.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +\n               ID=&ID,IDMAC=IM_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN\n         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT\n.*\n.* Check for the presence of required keywords.\n.*\n         AIF  ('&DESCTKN' NE '').REQOKAY\n         MNOTE 8,'DESCTKN (item type) is a required keyword.'\n         MEXIT\n.REQOKAY ANOP\n.*\n.* Generate the appropriate call statement.\n.*\n         AIF   ('&HEADTKN' NE '').CALL4\n         AIF   ('&ITEMTKN' NE '').CALL3\n         AIF   ('&ACTUALSZ' NE '').CALL2\n.CALL1   CALLX &#_IDEPA,(&#_IDTKN,&IM_FIND_FINAL,                      +\n               &DESCTKN),VL\n         MEXIT\n.CALL2   CALLX &#_IDEPA,(&#_IDTKN,&IM_FIND_FINAL,                      +\n               &DESCTKN,&ACTUALSZ),VL\n         MEXIT\n.CALL3   CALLX &#_IDEPA,(&#_IDTKN,&IM_FIND_FINAL,                      +\n               &DESCTKN,&ACTUALSZ,&ITEMTKN),VL\n         MEXIT\n.CALL4   CALLX &#_IDEPA,(&#_IDTKN,&IM_FIND_FINAL,                      +\n               &DESCTKN,&ACTUALSZ,&ITEMTKN,&HEADTKN),VL\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   IM_OBTAIN                                                  *\n* Purpose: Generate code to obtain an item.                           *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         IM_OBTAIN &ID=,&SPEPA=,&SPTOKEN=,&ITEM=,&ITEMTKN=,&ACTUALSZ=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN\n         GBLA  &IM_OBTAIN                  SETC in open code.\n         LCLC  &L_LENGTH\n.*\n.* Obtain service processor ID values.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +\n               ID=&ID,IDMAC=IM_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN\n         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT\n.*\n.* Check for the presence of required keywords.\n.*\n         AIF  ('&ITEM' NE '').ITEMOK\n         MNOTE 8,'ITEM (address and length) is a required keyword.'\n         MEXIT\n.ITEMOK  AIF  ('&ITEMTKN' NE '').REQOKAY\n         MNOTE 8,'ITEMTKN (item token) is a required keyword.'\n         MEXIT\n.REQOKAY ANOP\n.*\n.* Process the ITEM= keyword.\n.*\n          AIF   (N'&ITEM EQ 2).ITEMSL     Size and length specified.\n          AIF   (N'&ITEM EQ 1).LGLITCH    Use length attribute.\n          MNOTE 8,'Wrong number of parameters specified for ITEM.'\n          MEXIT\n.ITEMSL   ANOP\n&L_LENGTH SETC '&ITEM(2)'\n          AGO .PASTITEM\n.LGLITCH  ANOP\n&L_LENGTH SETC '=A(L''&ITEM(1))'\n.PASTITEM ANOP\n.*\n.* Generate the appropriate call statement.\n.*\n         AIF   ('&ACTUALSZ' NE '').CALL2\n.CALL1   CALLX &#_IDEPA,(&#_IDTKN,&IM_OBTAIN,&ITEMTKN,                 +\n               &L_LENGTH,&ITEM(1)),VL\n         MEXIT\n.CALL2   CALLX &#_IDEPA,(&#_IDTKN,&IM_OBTAIN,&ITEMTKN,                 +\n               &L_LENGTH,&ITEM(1),&ACTUALSZ),VL\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   IM_OBTAIN_BY_KEY                                           *\n* Purpose: Generate code to obtain by key.                            *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         IM_OBTAIN_BY_KEY &ID=,&SPEPA=,                                +\n               &SPTOKEN=,&DESCTKN=,&KEY=,                              +\n               &ITEM=,&ITEMTKN=,&ACTUALSZ=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN\n         GBLA  &IM_OBTAIN_BY_KEY\n         LCLC  &L_LENGTH,&K_LENGTH\n.*\n.* Obtain service processor ID values.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +\n               ID=&ID,IDMAC=IM_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN\n         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT\n.*\n.* Check for the presence of required keywords.\n.*\n         AIF  ('&KEY' NE '').KEYOK\n         MNOTE 8,'KEY (search key) is a required keyword.'\n         MEXIT\n.KEYOK   AIF  ('&DESCTKN' NE '').REQOKAY\n         MNOTE 8,'DESCTKN (item type) is a required keyword.'\n         MEXIT\n.REQOKAY ANOP\n.*\n.* Process the KEY= keyword.\n.*\n          AIF   (N'&KEY EQ 2).KEYSL       Size and length specified.\n          AIF   (N'&KEY EQ 1).KYLITCH     Use length attribute.\n          MNOTE 8,'Wrong number of parameters specified for KEY.'\n          MEXIT\n.KEYSL    ANOP\n&K_LENGTH SETC '&KEY(2)'\n          AGO .PASTKEY\n.KYLITCH  ANOP\n&K_LENGTH SETC '=A(L''&KEY(1))'\n.PASTKEY ANOP\n.*\n.* Process the ITEM= keyword.\n.*\n          AIF   (N'&ITEM EQ 2).ITEMSL     Size and length specified.\n          AIF   (N'&ITEM EQ 1).LGLITCH    Use length attribute.\n          MNOTE 8,'Wrong number of parameters specified for ITEM.'\n          MEXIT\n.ITEMSL   ANOP\n&L_LENGTH SETC '&ITEM(2)'\n          AGO .PASTITEM\n.LGLITCH  ANOP\n&L_LENGTH SETC '=A(L''&ITEM(1))'\n.PASTITEM ANOP\n.*\n.* Generate the appropriate call statement.\n.*\n         AIF   ('&ITEMTKN' NE '').CALL3\n         AIF   ('&ACTUALSZ' NE '').CALL2\n.CALL1   CALLX &#_IDEPA,(&#_IDTKN,&IM_OBTAIN_BY_KEY,                   +\n               &DESCTKN,&K_LENGTH,&KEY(1),                             +\n               &L_LENGTH,&ITEM(1)),VL\n         MEXIT\n.CALL2   CALLX &#_IDEPA,(&#_IDTKN,&IM_OBTAIN_BY_KEY,                   +\n               &DESCTKN,&K_LENGTH,&KEY(1),                             +\n               &L_LENGTH,&ITEM(1),&ACTUALSZ),VL\n         MEXIT\n.CALL3   CALLX &#_IDEPA,(&#_IDTKN,&IM_OBTAIN_BY_KEY,                   +\n               &DESCTKN,&K_LENGTH,&KEY(1),                             +\n               &L_LENGTH,&ITEM(1),&ACTUALSZ,&ITEMTKN),VL\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   IM_OBTAIN_CURRENT_OF_ITEM_TYPE                             *\n* Purpose: Generate code to obtain current of item type.              *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         IM_OBTAIN_CURRENT_OF_ITEM_TYPE &ID=,&SPEPA=,                  +\n               &SPTOKEN=,&ITEMTYPE=,&ITEM=,&ITEMTKN=,&ACTUALSZ=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN\n         GBLA  &IM_OBTAIN_CURRENT_OF_ITEM_TYPE\n         LCLC  &L_LENGTH\n.*\n.* Obtain service processor ID values.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +\n               ID=&ID,IDMAC=IM_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN\n         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT\n.*\n.* Check for the presence of required keywords.\n.*\n         AIF  ('&ITEM' NE '').ITEMOK\n         MNOTE 8,'ITEM (address and length) is a required keyword.'\n         MEXIT\n.ITEMOK  AIF  ('&ITEMTYPE' NE '').REQOKAY\n         MNOTE 8,'ITEMTYPE (item type) is a required keyword.'\n         MEXIT\n.REQOKAY ANOP\n.*\n.* Process the ITEM= keyword.\n.*\n          AIF   (N'&ITEM EQ 2).ITEMSL     Size and length specified.\n          AIF   (N'&ITEM EQ 1).LGLITCH    Use length attribute.\n          MNOTE 8,'Wrong number of parameters specified for ITEM.'\n          MEXIT\n.ITEMSL   ANOP\n&L_LENGTH SETC '&ITEM(2)'\n          AGO .PASTITEM\n.LGLITCH  ANOP\n&L_LENGTH SETC '=A(L''&ITEM(1))'\n.PASTITEM ANOP\n.*\n.* Generate the appropriate call statement.\n.*\n         AIF   ('&ITEMTKN' NE '').CALL3\n         AIF   ('&ACTUALSZ' NE '').CALL2\n.CALL1   CALLX &#_IDEPA,(&#_IDTKN,&IM_OBTAIN_CURRENT_OF_ITEM_TYPE,     +\n               &ITEMTYPE,&L_LENGTH,&ITEM(1)),VL\n         MEXIT\n.CALL2   CALLX &#_IDEPA,(&#_IDTKN,&IM_OBTAIN_CURRENT_OF_ITEM_TYPE,     +\n               &ITEMTYPE,&L_LENGTH,&ITEM(1),&ACTUALSZ),VL\n         MEXIT\n.CALL3   CALLX &#_IDEPA,(&#_IDTKN,&IM_OBTAIN_CURRENT_OF_ITEM_TYPE,     +\n               &ITEMTYPE,&L_LENGTH,&ITEM(1),&ACTUALSZ,&ITEMTKN),VL\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   IM_OBTAIN_CURRENT_OF_DESCRIPTOR                            *\n* Purpose: Generate code to obtain current of descriptor.             *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         IM_OBTAIN_CURRENT_OF_DESCRIPTOR &ID=,&SPEPA=,                 +\n               &SPTOKEN=,&DESCTKN=,&ITEM=,&ITEMTKN=,&ACTUALSZ=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN\n         GBLA  &IM_OBTAIN_CURRENT_OF_DESCRIPTOR\n         LCLC  &L_LENGTH\n.*\n.* Obtain service processor ID values.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +\n               ID=&ID,IDMAC=IM_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN\n         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT\n.*\n.* Check for the presence of required keywords.\n.*\n         AIF  ('&ITEM' NE '').ITEMOK\n         MNOTE 8,'ITEM (address and length) is a required keyword.'\n         MEXIT\n.ITEMOK  AIF  ('&DESCTKN' NE '').REQOKAY\n         MNOTE 8,'DESCTKN (item type) is a required keyword.'\n         MEXIT\n.REQOKAY ANOP\n.*\n.* Process the ITEM= keyword.\n.*\n          AIF   (N'&ITEM EQ 2).ITEMSL     Size and length specified.\n          AIF   (N'&ITEM EQ 1).LGLITCH    Use length attribute.\n          MNOTE 8,'Wrong number of parameters specified for ITEM.'\n          MEXIT\n.ITEMSL   ANOP\n&L_LENGTH SETC '&ITEM(2)'\n          AGO .PASTITEM\n.LGLITCH  ANOP\n&L_LENGTH SETC '=A(L''&ITEM(1))'\n.PASTITEM ANOP\n.*\n.* Generate the appropriate call statement.\n.*\n         AIF   ('&ITEMTKN' NE '').CALL3\n         AIF   ('&ACTUALSZ' NE '').CALL2\n.CALL1   CALLX &#_IDEPA,(&#_IDTKN,&IM_OBTAIN_CURRENT_OF_DESCRIPTOR,    +\n               &DESCTKN,&L_LENGTH,&ITEM(1)),VL\n         MEXIT\n.CALL2   CALLX &#_IDEPA,(&#_IDTKN,&IM_OBTAIN_CURRENT_OF_DESCRIPTOR,    +\n               &DESCTKN,&L_LENGTH,&ITEM(1),&ACTUALSZ),VL\n         MEXIT\n.CALL3   CALLX &#_IDEPA,(&#_IDTKN,&IM_OBTAIN_CURRENT_OF_DESCRIPTOR,    +\n               &DESCTKN,&L_LENGTH,&ITEM(1),&ACTUALSZ,&ITEMTKN),VL\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   IM_OBTAIN_NEXT                                             *\n* Purpose: Generate code to obtain the next item for a descriptor.    *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         IM_OBTAIN_NEXT &ID=,&SPEPA=,                                  +\n               &SPTOKEN=,&DESCTKN=,&ITEM=,&ITEMTKN=,&ACTUALSZ=,        +\n               &CURTKN=,&HEADTKN=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN\n         GBLA  &IM_OBTAIN_NEXT\n         LCLC  &L_LENGTH\n.*\n.* Obtain service processor ID values.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +\n               ID=&ID,IDMAC=IM_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN\n         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT\n.*\n.* Check for the presence of required keywords.\n.*\n         AIF  ('&ITEM' NE '').ITEMOK\n         MNOTE 8,'ITEM (address and length) is a required keyword.'\n         MEXIT\n.ITEMOK  AIF  ('&DESCTKN' NE '').REQOKAY\n         MNOTE 8,'DESCTKN (item type) is a required keyword.'\n         MEXIT\n.REQOKAY ANOP\n.*\n.* Process the ITEM= keyword.\n.*\n          AIF   (N'&ITEM EQ 2).ITEMSL     Size and length specified.\n          AIF   (N'&ITEM EQ 1).LGLITCH    Use length attribute.\n          MNOTE 8,'Wrong number of parameters specified for ITEM.'\n          MEXIT\n.ITEMSL   ANOP\n&L_LENGTH SETC '&ITEM(2)'\n          AGO .PASTITEM\n.LGLITCH  ANOP\n&L_LENGTH SETC '=A(L''&ITEM(1))'\n.PASTITEM ANOP\n.*\n.* Generate the appropriate call statement.\n.*\n         AIF   ('&HEADTKN' NE '').CALL5\n         AIF   ('&CURTKN' NE '').CALL4\n         AIF   ('&ITEMTKN' NE '').CALL3\n         AIF   ('&ACTUALSZ' NE '').CALL2\n.CALL1   CALLX &#_IDEPA,(&#_IDTKN,&IM_OBTAIN_NEXT,                     +\n               &DESCTKN,&L_LENGTH,&ITEM(1)),VL\n         MEXIT\n.CALL2   CALLX &#_IDEPA,(&#_IDTKN,&IM_OBTAIN_NEXT,                     +\n               &DESCTKN,&L_LENGTH,&ITEM(1),&ACTUALSZ),VL\n         MEXIT\n.CALL3   CALLX &#_IDEPA,(&#_IDTKN,&IM_OBTAIN_NEXT,                     +\n               &DESCTKN,&L_LENGTH,&ITEM(1),&ACTUALSZ,&ITEMTKN),VL\n         MEXIT\n.CALL4   CALLX &#_IDEPA,(&#_IDTKN,&IM_OBTAIN_NEXT,                     +\n               &DESCTKN,&L_LENGTH,&ITEM(1),&ACTUALSZ,&ITEMTKN,         +\n               &CURTKN),VL\n         MEXIT\n.CALL5   CALLX &#_IDEPA,(&#_IDTKN,&IM_OBTAIN_NEXT,                     +\n               &DESCTKN,&L_LENGTH,&ITEM(1),&ACTUALSZ,&ITEMTKN,         +\n               &CURTKN,&HEADTKN),VL\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   IM_OBTAIN_PRIOR                                            *\n* Purpose: Generate code to obtain the prior item for a descriptor.   *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         IM_OBTAIN_PRIOR &ID=,&SPEPA=,                                 +\n               &SPTOKEN=,&DESCTKN=,&ITEM=,&ITEMTKN=,&ACTUALSZ=,        +\n               &CURTKN=,&HEADTKN=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN\n         GBLA  &IM_OBTAIN_PRIOR\n         LCLC  &L_LENGTH\n.*\n.* Obtain service processor ID values.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +\n               ID=&ID,IDMAC=IM_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN\n         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT\n.*\n.* Check for the presence of required keywords.\n.*\n         AIF  ('&ITEM' NE '').ITEMOK\n         MNOTE 8,'ITEM (address and length) is a required keyword.'\n         MEXIT\n.ITEMOK  AIF  ('&DESCTKN' NE '').REQOKAY\n         MNOTE 8,'DESCTKN (item type) is a required keyword.'\n         MEXIT\n.REQOKAY ANOP\n.*\n.* Process the ITEM= keyword.\n.*\n          AIF   (N'&ITEM EQ 2).ITEMSL     Size and length specified.\n          AIF   (N'&ITEM EQ 1).LGLITCH    Use length attribute.\n          MNOTE 8,'Wrong number of parameters specified for ITEM.'\n          MEXIT\n.ITEMSL   ANOP\n&L_LENGTH SETC '&ITEM(2)'\n          AGO .PASTITEM\n.LGLITCH  ANOP\n&L_LENGTH SETC '=A(L''&ITEM(1))'\n.PASTITEM ANOP\n.*\n.* Generate the appropriate call statement.\n.*\n         AIF   ('&HEADTKN' NE '').CALL5\n         AIF   ('&CURTKN' NE '').CALL4\n         AIF   ('&ITEMTKN' NE '').CALL3\n         AIF   ('&ACTUALSZ' NE '').CALL2\n.CALL1   CALLX &#_IDEPA,(&#_IDTKN,&IM_OBTAIN_PRIOR,                    +\n               &DESCTKN,&L_LENGTH,&ITEM(1)),VL\n         MEXIT\n.CALL2   CALLX &#_IDEPA,(&#_IDTKN,&IM_OBTAIN_PRIOR,                    +\n               &DESCTKN,&L_LENGTH,&ITEM(1),&ACTUALSZ),VL\n         MEXIT\n.CALL3   CALLX &#_IDEPA,(&#_IDTKN,&IM_OBTAIN_PRIOR,                    +\n               &DESCTKN,&L_LENGTH,&ITEM(1),&ACTUALSZ,&ITEMTKN),VL\n         MEXIT\n.CALL4   CALLX &#_IDEPA,(&#_IDTKN,&IM_OBTAIN_PRIOR,                    +\n               &DESCTKN,&L_LENGTH,&ITEM(1),&ACTUALSZ,&ITEMTKN,         +\n               &CURTKN),VL\n         MEXIT\n.CALL5   CALLX &#_IDEPA,(&#_IDTKN,&IM_OBTAIN_PRIOR,                    +\n               &DESCTKN,&L_LENGTH,&ITEM(1),&ACTUALSZ,&ITEMTKN,         +\n               &CURTKN,&HEADTKN),VL\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   IM_OBTAIN_OWNER                                            *\n* Purpose: Generate code to obtain the owner item for a descriptor.   *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         IM_OBTAIN_OWNER &ID=,&SPEPA=,                                 +\n               &SPTOKEN=,&DESCTKN=,&ITEM=,&ITEMTKN=,&ACTUALSZ=,&CURTKN=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN\n         GBLA  &IM_OBTAIN_OWNER\n         LCLC  &L_LENGTH\n.*\n.* Obtain service processor ID values.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +\n               ID=&ID,IDMAC=IM_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN\n         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT\n.*\n.* Check for the presence of required keywords.\n.*\n         AIF  ('&ITEM' NE '').ITEMOK\n         MNOTE 8,'ITEM (address and length) is a required keyword.'\n         MEXIT\n.ITEMOK  AIF  ('&DESCTKN' NE '').REQOKAY\n         MNOTE 8,'DESCTKN (item type) is a required keyword.'\n         MEXIT\n.REQOKAY ANOP\n.*\n.* Process the ITEM= keyword.\n.*\n          AIF   (N'&ITEM EQ 2).ITEMSL     Size and length specified.\n          AIF   (N'&ITEM EQ 1).LGLITCH    Use length attribute.\n          MNOTE 8,'Wrong number of parameters specified for ITEM.'\n          MEXIT\n.ITEMSL   ANOP\n&L_LENGTH SETC '&ITEM(2)'\n          AGO .PASTITEM\n.LGLITCH  ANOP\n&L_LENGTH SETC '=A(L''&ITEM(1))'\n.PASTITEM ANOP\n.*\n.* Generate the appropriate call statement.\n.*\n         AIF   ('&CURTKN' NE '').CALL4\n         AIF   ('&ITEMTKN' NE '').CALL3\n         AIF   ('&ACTUALSZ' NE '').CALL2\n.CALL1   CALLX &#_IDEPA,(&#_IDTKN,&IM_OBTAIN_OWNER,                    +\n               &DESCTKN,&L_LENGTH,&ITEM(1)),VL\n         MEXIT\n.CALL2   CALLX &#_IDEPA,(&#_IDTKN,&IM_OBTAIN_OWNER,                    +\n               &DESCTKN,&L_LENGTH,&ITEM(1),&ACTUALSZ),VL\n         MEXIT\n.CALL3   CALLX &#_IDEPA,(&#_IDTKN,&IM_OBTAIN_OWNER,                    +\n               &DESCTKN,&L_LENGTH,&ITEM(1),&ACTUALSZ,&ITEMTKN),VL\n         MEXIT\n.CALL4   CALLX &#_IDEPA,(&#_IDTKN,&IM_OBTAIN_OWNER,                    +\n               &DESCTKN,&L_LENGTH,&ITEM(1),&ACTUALSZ,&ITEMTKN,         +\n               &CURTKN),VL\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   IM_OBTAIN_FIRST                                            *\n* Purpose: Generate code to obtain the first item associated with     *\n*          a descriptor.\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         IM_OBTAIN_FIRST &ID=,&SPEPA=,                                 +\n               &SPTOKEN=,&DESCTKN=,&ITEM=,&ITEMTKN=,&ACTUALSZ=,        +\n               &HEADTKN=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN\n         GBLA  &IM_OBTAIN_FIRST\n         LCLC  &L_LENGTH\n.*\n.* Obtain service processor ID values.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +\n               ID=&ID,IDMAC=IM_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN\n         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT\n.*\n.* Check for the presence of required keywords.\n.*\n         AIF  ('&ITEM' NE '').ITEMOK\n         MNOTE 8,'ITEM (address and length) is a required keyword.'\n         MEXIT\n.ITEMOK  AIF  ('&DESCTKN' NE '').REQOKAY\n         MNOTE 8,'DESCTKN (item type) is a required keyword.'\n         MEXIT\n.REQOKAY ANOP\n.*\n.* Process the ITEM= keyword.\n.*\n          AIF   (N'&ITEM EQ 2).ITEMSL     Size and length specified.\n          AIF   (N'&ITEM EQ 1).LGLITCH    Use length attribute.\n          MNOTE 8,'Wrong number of parameters specified for ITEM.'\n          MEXIT\n.ITEMSL   ANOP\n&L_LENGTH SETC '&ITEM(2)'\n          AGO .PASTITEM\n.LGLITCH  ANOP\n&L_LENGTH SETC '=A(L''&ITEM(1))'\n.PASTITEM ANOP\n.*\n.* Generate the appropriate call statement.\n.*\n         AIF   ('&HEADTKN' NE '').CALL4\n         AIF   ('&ITEMTKN' NE '').CALL3\n         AIF   ('&ACTUALSZ' NE '').CALL2\n.CALL1   CALLX &#_IDEPA,(&#_IDTKN,&IM_OBTAIN_FIRST,                    +\n               &DESCTKN,&L_LENGTH,&ITEM(1)),VL\n         MEXIT\n.CALL2   CALLX &#_IDEPA,(&#_IDTKN,&IM_OBTAIN_FIRST,                    +\n               &DESCTKN,&L_LENGTH,&ITEM(1),&ACTUALSZ),VL\n         MEXIT\n.CALL3   CALLX &#_IDEPA,(&#_IDTKN,&IM_OBTAIN_FIRST,                    +\n               &DESCTKN,&L_LENGTH,&ITEM(1),&ACTUALSZ,&ITEMTKN),VL\n         MEXIT\n.CALL4   CALLX &#_IDEPA,(&#_IDTKN,&IM_OBTAIN_FIRST,                    +\n               &DESCTKN,&L_LENGTH,&ITEM(1),&ACTUALSZ,&ITEMTKN,         +\n               &HEADTKN),VL\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   IM_OBTAIN_FINAL                                            *\n* Purpose: Generate code to obtain the final item associated with     *\n*          a descriptor.\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         IM_OBTAIN_FINAL &ID=,&SPEPA=,                                 +\n               &SPTOKEN=,&DESCTKN=,&ITEM=,&ITEMTKN=,&ACTUALSZ=,        +\n               &HEADTKN=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN\n         GBLA  &IM_OBTAIN_FINAL\n         LCLC  &L_LENGTH\n.*\n.* Obtain service processor ID values.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +\n               ID=&ID,IDMAC=IM_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN\n         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT\n.*\n.* Check for the presence of required keywords.\n.*\n         AIF  ('&ITEM' NE '').ITEMOK\n         MNOTE 8,'ITEM (address and length) is a required keyword.'\n         MEXIT\n.ITEMOK  AIF  ('&DESCTKN' NE '').REQOKAY\n         MNOTE 8,'DESCTKN (item type) is a required keyword.'\n         MEXIT\n.REQOKAY ANOP\n.*\n.* Process the ITEM= keyword.\n.*\n          AIF   (N'&ITEM EQ 2).ITEMSL     Size and length specified.\n          AIF   (N'&ITEM EQ 1).LGLITCH    Use length attribute.\n          MNOTE 8,'Wrong number of parameters specified for ITEM.'\n          MEXIT\n.ITEMSL   ANOP\n&L_LENGTH SETC '&ITEM(2)'\n          AGO .PASTITEM\n.LGLITCH  ANOP\n&L_LENGTH SETC '=A(L''&ITEM(1))'\n.PASTITEM ANOP\n.*\n.* Generate the appropriate call statement.\n.*\n         AIF   ('&HEADTKN' NE '').CALL4\n         AIF   ('&ITEMTKN' NE '').CALL3\n         AIF   ('&ACTUALSZ' NE '').CALL2\n.CALL1   CALLX &#_IDEPA,(&#_IDTKN,&IM_OBTAIN_FINAL,                    +\n               &DESCTKN,&L_LENGTH,&ITEM(1)),VL\n         MEXIT\n.CALL2   CALLX &#_IDEPA,(&#_IDTKN,&IM_OBTAIN_FINAL,                    +\n               &DESCTKN,&L_LENGTH,&ITEM(1),&ACTUALSZ),VL\n         MEXIT\n.CALL3   CALLX &#_IDEPA,(&#_IDTKN,&IM_OBTAIN_FINAL,                    +\n               &DESCTKN,&L_LENGTH,&ITEM(1),&ACTUALSZ,&ITEMTKN),VL\n         MEXIT\n.CALL4   CALLX &#_IDEPA,(&#_IDTKN,&IM_OBTAIN_FINAL,                    +\n               &DESCTKN,&L_LENGTH,&ITEM(1),&ACTUALSZ,&ITEMTKN,         +\n               &HEADTKN),VL\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   IM_STORE                                                   *\n* Purpose: Generate code to store an item.                            *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         IM_STORE &ID=,&SPEPA=,&SPTOKEN=,&ITEM=,&ITEMTKN=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN\n         GBLA  &IM_STORE                   SETC in open code.\n         LCLC  &L_ITEM,&L_ITEMLEN\n.*\n.* Obtain service processor ID values.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +\n               ID=&ID,IDMAC=IM_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN\n         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT\n.*\n.* Check for the presence of required keywords.\n.*\n           AIF  ('&ITEM' NE '').ITEM\n           MNOTE 8,'ITEM (address only) is a required keyword.'\n           MEXIT\n.ITEM      AIF (N'&ITEM EQ 1).ITEMONLY\n           AIF (N'&ITEM EQ 2).ITEMLEN\n           MNOTE 8,'Specify ITEM=item or ITEM=(item,length)'\n           MEXIT\n.ITEMONLY  ANOP\n&L_ITEM    SETC  '&ITEM'\n&L_ITEMLEN SETC  ''\n           AGO   .ITEMOK\n.ITEMLEN   ANOP\n&L_ITEM    SETC  '&ITEM(1)'\n&L_ITEMLEN SETC  '&ITEM(2)'\n.ITEMOK    ANOP\n.*\n.* Generate the appropriate call statement.\n.*\n         AIF   ('&ITEMTKN' NE '').CALL3\n         AIF   ('&L_ITEMLEN' NE '').CALL2\n.CALL1   CALLX &#_IDEPA,(&#_IDTKN,&IM_STORE,&L_ITEM),VL\n         MEXIT\n.CALL2   CALLX &#_IDEPA,(&#_IDTKN,&IM_STORE,&L_ITEM,&L_ITEMLEN),VL\n         MEXIT\n.CALL3   CALLX &#_IDEPA,(&#_IDTKN,&IM_STORE,&L_ITEM,&L_ITEMLEN,        +\n               &ITEMTKN),VL\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   IM_TEXT                                                    *\n* Purpose: Generate the DC instructions for a description string.     *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n&NAME    IM_TEXT &STRING\n&NAME    DC    AL1(##_&NAME._LENGTH)\n         DC    C&STRING\n##_&NAME._LENGTH EQU *-&NAME-1\n         MEND\n*---------------------------------------------------------------------*\n*\n*  Macro       IM_SFD\n*\n*  Abstract    This is the mapping macro for Sort Field Definitions\n*              used by the IM_SORT function.\n*\n*---------------------------------------------------------------------*\n         MACRO\n         IM_SFD &DSECT=YES,&ID=SFD_\n&I       SETC  '&ID'                  |\n&CSECT   SETC  '&SYSECT'              |\n         AIF   ('&DSECT' NE 'YES').NO_DSECT\n&I.START DSECT                        | Start of TGX.\n         AGO   .PAST_HEADER           |\n.NO_DSECT ANOP                        |\n&I.START DS    0F                     | Start of TGX.\n.PAST_HEADER ANOP                     |\n&I.ID                         DS CL4  | ID\n&I.ID_TEXT                EQU C'SFD ' | Text of ID.\n&I.ELEMENTS_IN_ARRAY          DS F    | Number of elements in array.\n&I.SIZE_FIXED  EQU *-&I.START         | Size of fixed part of item.\n&I.FIXED_PART  EQU &I.START,&I.SIZE_FIXED,C'X' Fixed part.\n&I.ARRAY_START EQU *                  | Start of array.\n&I.ELEMENT     EQU *                  | Definition of an element.\n&I.OFFSET                  DS F       | Offset of field in item.\n&I.LENGTH                  DS F       | Length of field in item.\n&I.MASK    EQU &I.LENGTH              | For type BIT, last byte of\n*                                     |   length is a mask, with bit(s)\n*                                     |   to test turned on.\n&I.TYPE                    DS H       | Type of field.\n*                                     |  See &SFD_TYPE_... globals.\n&I.F                       DS B       | Flag.\n&I.F_DESCENDING       EQU B'10000000' |  Sort descending.\n                           DS X       | Not used.\n&I.SIZE_ELEMENT EQU *-&I.ELEMENT      | Size of one element of array.\n         AIF   ('&DSECT' NE 'YES').MEXIT\n&CSECT   CSECT ,                      |\n.MEXIT   MEND                         |\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SRVIMXRZ": {"ttr": 29704, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x02\\x00\\x00W\\x01\\x11)\\x9f\\x01\\x11)\\x9f\\t'\\x01\\xb9\\x01\\xb9\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@\"", "ispf": {"version": "02.00", "flags": 0, "createdate": "2011-10-26T00:00:00", "modifydate": "2011-10-26T09:27:57", "lines": 441, "newlines": 441, "modlines": 0, "user": "CLEMSON"}, "text": "*---------------------------------------------------------------------*\n*  Copyright 2011 by Clemson University Research Foundation           *\n*                                                                     *\n*  Licensed under the Apache License, Version 2.0 (the \"License\");    *\n*  you may not use this file except in compliance with the License.   *\n*  You may obtain a copy of the License in this library as member     *\n*  $LICENSE, or from                                                  *\n*                                                                     *\n*      http://www.apache.org/licenses/LICENSE-2.0                     *\n*                                                                     *\n*  Unless required by applicable law or agreed to in writing,         *\n*  software distributed under the License is distributed on an \"AS    *\n*  IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either    *\n*  express or implied.  See the License for the specific language     *\n*  governing permissions and limitations under the License.           *\n*---------------------------------------------------------------------*\nSRVIMXRZ TITLE 'Item manager exercizer'\n         SMLIST CONVERT=YES           |\n*---------------------------------------------------------------------*\n*\n*  CSECT: SRVIMXRZ\n*\n*  COPYRIGHT: (C) Copyright Clemson University 1989\n*\n*  ABSTRACT: This program is used to as a test driver for the\n*            Item Manager Service Processor.\n*\n*  MODULE ACTIVITY:  MGG 03/02/89 New\n*\n*---------------------------------------------------------------------*\n         SPACE 2                      |\n block type=program,name=srvIMXRZ,options=(*pwa,xa,norent,erraddr),    +\n               subopts=*swa,          |                                +\n               basereg=(r12,r8),      |                                +\n               amode=31,rmode=24      |\n  copy  smsyms                        | Get Structured Macro symbols.\n  copy  srvesmac                      | Get Environment Support macros.\n  copy  srvplmac                      | Get PrintLine macros.\n  copy  srvimmac                      | Get Item Manager macros.\n  copy  srvdvmac                      | Get Data-in-virtural macros.\n* *-------------------------------------------------------------------*\n* *  Establish service processor IDs.\n* *------------------------------------------------------------------*\n  es_id id=es,spepname=&mvs_environment_support Id for Env. Support.\n  pl_id id=pl,sizelength=4            | Print line service processor.\n  im_id id=im,spepname=\"NEWIM   \",    | Id for Item Manager.           +\n               tkncnvt=pwa_tkncnvt    |\n* *-------------------------------------------------------------------*\n* *  Load and start Environment Support Module.\n* *------------------------------------------------------------------*\n  es_mvs_load id=es                   | Load MVS environment support.\n  es_start    id=es                   | Start environment support.\n  errexit (treg,r15,nz),code=1        | Fail if there is an error.\n* *-------------------------------------------------------------------*\n* *  Load and start Print line service processor.\n* *------------------------------------------------------------------*\n  es_load_module id=es,spid=pl        | Load Print Line.\n  errexit (treg,r15,nz),code=100      | Fail if there is an error.\n  pl_start id=pl,ddname='SYSPRINT'    | Start environment support.\n  errexit (treg,r15,nz),code=101      | Fail if there is an error.\n* *-------------------------------------------------------------------*\n* *  Load DIV Service Processor.\n* *-------------------------------------------------------------------*\n  es_load_module id=es,               | Load MVS DIV service processor.+\n               epname=&mvs_div_manager,epa=pwadv\n  errexit (treg,r15,nz),code=2        | Fail if there is an error.\n* *-------------------------------------------------------------------*\n* *  Load and start item manager service processor. Get the address\n* *  of the token convert routine.\n* *-------------------------------------------------------------------*\n  es_load_module id=es,spid=im        | Load item manager.\n  errexit (treg,r15,nz),code=3        | Fail if there is an error.\n  im_start id=im,divepa=pwadv,divddn=psd_ddname,options=actual_address\n  if (ch,r15,eq,=y(&im_item_storage_not_initialized))\n   im_initialize id=im,itdstg=4096,   |  Initialize item managed stg.  +\n               dfltincr=4096,sysincr=4096,uaincr=4096\n   errexit (treg,r15,nz),code=4       |  Fail if there is an error.\n  else                                | Else.\n   errexit (treg,r15,nz),code=5       |  Fail if there is an error.\n  endif                               | Endif.\n  im_get_dangerous_addresses id=im    | Get address of token convert\n  errexit (treg,r15,nz),code=6        | Fail if there is an error.\n* *-------------------------------------------------------------------*\n* *  Save the changes.\n* *-------------------------------------------------------------------*\n  im_save id=im                       | Save changes.\n  errexit (treg,r15,nz),code=7        | Fail if there is an error.\n* *-------------------------------------------------------------------*\n* * Create an group for storage.\n* *-------------------------------------------------------------------*\n  im_create_group_descriptor id=im,   | Create group descriptor for    +\n               desctkn=pwa_tii_group, |  TII items.                    +\n               text=psd_group_description,                             +\n               stgincr==a(16*4096)    |\n  errexit (treg,r15,nz),code=8        | Fail if there is an error.\n* *-------------------------------------------------------------------*\n* * Create an ITD.\n* *-------------------------------------------------------------------*\n  im_create_item_type_descriptor id=im, Create ITD.                    +\n               itemtype=pwa_tii_itd,  |                                +\n               text=psd_tii_description,                               +\n               grouptkn=pwa_tii_group,                                 +\n               itemsz==a(tiiitmsz),   |                                +\n               #links==a(tii#lnks),   |                                +\n               linksoff==a(tiilinks-tii)\n  errexit (treg,r15,nz),code=9        | Fail if there is an error.\n* *-------------------------------------------------------------------*\n* * Create an list descriptor.\n* *-------------------------------------------------------------------*\n  im_create_linked_list_descriptor id=im, Create LLD.                  +\n               desctkn=pwa_lld_first, |                                +\n               options=(heads_in_descriptor,list_order_first),         +\n               nxtlnk#==a(tiinxtii_link_number),                       +\n               prvlnk#==a(tiiprtii_link_number)\n  errexit (treg,r15,nz),code=10       | Fail if there is an error.\n* *-------------------------------------------------------------------*\n* * Create an list descriptor.\n* *-------------------------------------------------------------------*\n  im_create_linked_list_descriptor id=im, Create LLD.                  +\n               desctkn=pwa_lld_sort,  |                                +\n               options=(heads_in_descriptor,list_order_first),         +\n               nxtlnk#==a(tiinxtsr_link_number),                       +\n               prvlnk#==a(tiiprtsr_link_number)\n  errexit (treg,r15,nz),code=11       | Fail if there is an error.\n* *-------------------------------------------------------------------*\n* * Create a hash table descriptor.\n* *-------------------------------------------------------------------*\n  im_create_hash_table_descriptor id=im, Create a HTD.                 +\n               desctkn=pwa_htd_token, |                                +\n               synlnk#==a(tiisytii_link_number),                       +\n               keyoff==a(tiikey-tii), |                                +\n               keysz==a(l'tiikey)     |\n  errexit (treg,r15,nz),code=12       | Fail if there is an error.\n* *-------------------------------------------------------------------*\n* * Create another list descriptor, this time in final order.\n* *-------------------------------------------------------------------*\n  im_create_linked_list_descriptor id=im, Create LLD.                  +\n               desctkn=pwa_lld_final, |                                +\n               options=(heads_in_descriptor,list_order_final),         +\n               nxtlnk#==a(tiinxti2_link_number)\n  errexit (treg,r15,nz),code=13       | Fail if there is an error.\n* *-------------------------------------------------------------------*\n* * Read a file and make an item for each record.  Connect it to\n* * both lists.\n* *-------------------------------------------------------------------*\n  la    r9,pwa_tii_build_area         |\n  using tii,r9                        |\n  mvc   tiiitype,pwa_tii_itd          |\n  block amode=24                      |\n   open  (sysin,input)                |\n  endblk                              |\n  fill  pwa_previous_token,x'00'      |\n  loop  until                         |\n   block amode=24                     |\n    get   sysin,tiistuff              |\n   endblk                             |\n   if not,(tbit,pwa_f_eof)            |\n    im_store id=im,item=tii,          |                                +\n               itemtkn=pwa_tii_token  |\n    errexit (treg,r15,nz),code=14     |\n    im_connect id=im,desctkn=pwa_lld_first\n    errexit (treg,r15,nz),code=15     |\n    im_connect id=im,desctkn=pwa_lld_final\n    errexit (treg,r15,nz),code=16     |\n    im_connect id=im,desctkn=pwa_lld_sort\n    errexit (treg,r15,nz),code=17     |\n    im_connect id=im,desctkn=pwa_htd_token\n    errexit (treg,r15,nz),code=18     |\n    im_obtain id=im,                  |                                +\n               itemtkn=pwa_tii_token, |                                +\n               item=pwa_tii_return_area\n    errexit (treg,r15,nz),code=19     |\n    im_modify id=im,                  |                                +\n               itemtkn=pwa_tii_token, |                                +\n               item=pwa_tii_return_area,                               +\n               options=update_links   |\n    errexit (treg,r15,nz),code=20     |\n   endif                              |\n  endloop until,(tbit,pwa_f_eof)      |\n  block amode=24                      |\n   close  (sysin)                     |\n  endblk                              |\n* *-------------------------------------------------------------------*\n* *  Sort source.\n* *-------------------------------------------------------------------*\n  im_sort id=im,desctkn=pwa_lld_sort, |                                +\n               fields=((tiikey-tii,l'tiikey,char,ascending)),          +\n               technique=quick_sort   |\n  errexit (treg,r15,nz),code=21       |\n* *-------------------------------------------------------------------*\n* *  Read both lists conparing results and writing results to file.\n* *-------------------------------------------------------------------*\n  la    r9,pwa_tii_return_area        |\n  im_obtain_first id=im,              |                                +\n               desctkn=pwa_lld_final, |                                +\n               item=pwa_tii_return_area\n  errexit (treg,r15,nz),code=22       | Fail if there is an error.\n  im_obtain_first id=im,              |                                +\n               desctkn=pwa_lld_sort,  |                                +\n               item=pwa_tii_return_area4\n  errexit (treg,r15,nz),code=23       | Fail if there is an error.\n  im_obtain_final id=im,              |                                +\n               desctkn=pwa_lld_first, |                                +\n               item=pwa_tii_return_area2,                              +\n               itemtkn=pwa_item_token |\n  errexit (treg,r15,nz),code=24       | Fail if there is an error.\n  loop until                          |\n   leave loop=*,(ch,r15,eq,=y(&im_at_end))\n   errexit (treg,r15,nz),code=25      |\n   if (clc,pwa_tii_return_area,ne,pwa_tii_return_area2)\n    errexit code=26                   |\n   endif                              |\n   im_convert_token_to_address id=im, |                                +\n               itemtkn=pwa_item_token,                                 +\n               itemaddr=r1            |\n   errexit (treg,r1,z),code=27        |\n   if (clc,pwa_tii_return_area2,ne,0(r1))\n    errexit code=28                   |\n   endif                              |\n   if (clc,pwa_tii_return_area,ne,pwa_tii_return_area4)\n    errexit code=29                   |\n   endif                              |\n   im_obtain_by_key id=im,key=tiikey, |                                +\n               desctkn=pwa_htd_token, |                                +\n               item=pwa_tii_return_area3\n   errexit (treg,r15,nz)              |\n   if (clc,pwa_tii_return_area,ne,pwa_tii_return_area3)\n    errexit code=30                   |\n   endif                              |\n   pl_print_formatted id=pl,                                           +\n               control=(' {CL80}'),                                    +\n               source=(pwa_tii_return_area+2)\n   errexit (treg,r15,nz),code=102\n   im_obtain_next  id=im,             |                                +\n               desctkn=pwa_lld_final, |                                +\n               item=pwa_tii_return_area\n   errexit (treg,r15,nz),and,not,(%im_at_end),code=31\n   im_obtain_next  id=im,             |                                +\n               desctkn=pwa_lld_sort,  |                                +\n               item=pwa_tii_return_area4\n   errexit (treg,r15,nz),and,not,(%im_at_end),code=32\n   im_obtain_prior id=im,             |                                +\n               desctkn=pwa_lld_first, |                                +\n               item=pwa_tii_return_area2,                              +\n               itemtkn=pwa_item_token |\n   errexit (treg,r15,nz),and,not,(%im_at_end),code=33\n  endloop until,leave                 |\n* *-------------------------------------------------------------------*\n* *  Remove every other item from sorted list until it is empty and\n* *  print results each pass.\n* *-------------------------------------------------------------------*\n  fill  pwa_counter                   |\n  loop until                          |\n   l     r1,pwa_counter               |\n   la    r1,1(,r1)                    |\n   st    r1,pwa_counter               |\n   fill  pwa_tii_token                |\n   im_find_first id=im,               |                                +\n               desctkn=pwa_lld_sort   |\n   leave loop=*,(%im_at_end)          |\n   loop until                         |\n    errexit not,(%im_success),code=34 |\n    im_disconnect id=im,              |                                +\n               desctkn=pwa_lld_sort   |\n    errexit not,(%im_success),code=35 |\n    im_find_next id=im,               |                                +\n               desctkn=pwa_lld_sort,  |                                +\n               curtkn=pwa_tii_token,  |                                +\n               itemtkn=pwa_tii_token  |\n    leave loop=*,(%im_at_end)         |\n    errexit not,(%im_success),code=36 |\n    im_find_next id=im,               |                                +\n               desctkn=pwa_lld_sort   |\n   endloop until,(%im_at_end)         |\n   pl_print_formatted id=pl,          |                                +\n               control=(\" Disconnect Pass {I}.\"),                      +\n               source=(pwa_counter)\n   errexit (treg,r15,nz),code=104\n   im_obtain_first id=im,             |                                +\n               desctkn=pwa_lld_sort,  |                                +\n               item=pwa_tii_return_area\n   loop while,not,(%im_at_end)        |\n    errexit not,(%im_success),code=37 |\n    pl_print_formatted id=pl,                                          +\n               control=(' {CL80}'),                                    +\n               source=(pwa_tii_return_area+2)\n    errexit (treg,r15,nz),code=103\n    im_obtain_next  id=im,            |                                +\n               desctkn=pwa_lld_sort, |                                 +\n               item=pwa_tii_return_area\n   endloop while                      |\n  endloop until,leave                 |\n* *-------------------------------------------------------------------*\n* *  Remove every other item from final list until it is empty and\n* *  print results each pass. This list does not have prior links.\n* *-------------------------------------------------------------------*\n  fill  pwa_counter                   |\n  loop until                          |\n   l     r1,pwa_counter               |\n   la    r1,1(,r1)                    |\n   st    r1,pwa_counter               |\n   fill  pwa_tii_token                |\n   im_find_first id=im,               |                                +\n               desctkn=pwa_lld_final  |\n   leave loop=*,(%im_at_end)          |\n   loop until                         |\n    errexit not,(%im_success),code=34 |\n    im_disconnect id=im,              |                                +\n               desctkn=pwa_lld_final, |                                +\n               prtkn=pwa_tii_token    |\n    errexit not,(%im_success),code=35 |\n    im_find_next id=im,               |                                +\n               desctkn=pwa_lld_final, |                                +\n               curtkn=pwa_tii_token,  |                                +\n               itemtkn=pwa_tii_token  |\n    leave loop=*,(%im_at_end)         |\n    errexit not,(%im_success),code=36 |\n    im_find_next id=im,               |                                +\n               desctkn=pwa_lld_final  |\n   endloop until,(%im_at_end)         |\n   pl_print_formatted id=pl,          |                                +\n               control=(\" Disconnect Pass {I}.\"),                      +\n               source=(pwa_counter)\n   errexit (treg,r15,nz),code=104\n   im_obtain_first id=im,             |                                +\n               desctkn=pwa_lld_final, |                                +\n               item=pwa_tii_return_area\n   loop while,not,(%im_at_end)        |\n    errexit not,(%im_success),code=37 |\n    pl_print_formatted id=pl,                                          +\n               control=(' {CL80}'),                                    +\n               source=(pwa_tii_return_area+2)\n    errexit (treg,r15,nz),code=103\n    im_obtain_next  id=im,            |                                +\n               desctkn=pwa_lld_final, |                                +\n               item=pwa_tii_return_area\n   endloop while                      |\n  endloop until,leave                 |\n* *-------------------------------------------------------------------*\n* *  Save the changes.\n* *-------------------------------------------------------------------*\n  im_save id=im                       |\n  errexit (treg,r15,nz),code=38       |\n* *-------------------------------------------------------------------*\n* *  Terminate service processors.\n* *-------------------------------------------------------------------*\n  pl_terminate id=pl                  | Terminate printline.\n  errexit (treg,r15,nz),code=101      | Fail if there is an error.\n  im_terminate id=im                  |\n  errexit (treg,r15,nz),code=39       |\n  es_terminate id=es                  |\n  errexit (treg,r15,nz),code=40       |\n* *-------------------------------------------------------------------*\n* *  Unload service manager and environment support module.\n* *-------------------------------------------------------------------*\n  es_mvs_unload id=es                 |\n* *-------------------------------------------------------------------*\n endblk block=srvIMXRZ                |\n space 2                              |\n block type=errexit                   |\n* *-------------------------------------------------------------------*\n* * Save module/offset, registers, return-code.\n* *-------------------------------------------------------------------*\n  stm   r0,r15,gdiregs                | Save registers at time of error\n  la    r0,4(,r12)                    | Point to module identification.\n  st    r0,gdimodid                   | Save in general debug area.\n  mvc   gdirc,0(r14)                  | Copy return code.\n  slr   r14,r12                       | Calculate offset at time of err\n  sth   r14,gdioffst                  | Save in debug area.\n  es_save_debug_info id=es,gdi=gdi    | Save debug information.\n* *-------------------------------------------------------------------*\n* * Print debug info and abend.\n* *-------------------------------------------------------------------*\n  es_display_debug_info_and_abend id=es\n endblk                               |\n block name=eof,type=subroutine,options=*nosubopts\n  sbit pwa_f_eof                      |\n endblk                               |\n space 2                              |\n         psd                          |\npsd_ddname dc  al1(6),c\"LINEAR\"       |\npsd_tii_description im_text \"Sample Test Item\"\npsd_group_description im_text \"Group for Sample Test Item\"\nsysin    dcb   ddname=sysin,dsorg=ps,macrf=gm,eodad=eof,lrecl=80\n         ltorg ,                      |\n         endpsd                       |\n         title \"Dsects\"               |\ntii      dsect ,                      |\ntiiitype ds    h                      |\ntiistuff ds    cl80                   |\ntiikey   equ   *-8,8,c'c'             |\ntiilinks ds    0f                     |\ntiinxtii ds    f                      |\ntiinxtii_link_number equ (*-tiilinks)/4\ntiiprtii ds    f                      |\ntiiprtii_link_number equ (*-tiilinks)/4\ntiinxti2 ds    f                      |\ntiinxti2_link_number equ (*-tiilinks)/4\ntiinxtsr ds    f                      |\ntiinxtsr_link_number equ (*-tiilinks)/4\ntiiprtsr ds    f                      |\ntiiprtsr_link_number equ (*-tiilinks)/4\ntiisytii ds    f                      |\ntiisytii_link_number equ (*-tiilinks)/4\ntii#lnks equ   (*-tiilinks)/4         |\ntiiitmsz equ   *-tii                  |\n         title \"Program Work Area\"    |\n         pwa                          |\npwaaesv  ds    a     address of service processor global area\npwaestkn ds    a     environment support token\npwaes    ds    a     environment support entry point address\npwadvtkn ds    a     div service processor for testing\npwadv    ds    a     div entry point address\npwaimtkn ds    a     item manager service processor for testing\npwaim    ds    a     item manager entry point address\npwa_tkncnvt ds a     token convert routine address\n         es_gdi dsect=no              |\npwa_tii_group ds f   Token of group.  |\npwa_quick_get_address ds a            |\npwa_size ds    f                      |\npwa_size_bytes ds f                   |\npwa_area ds    a                      |\npwa_counter                  ds  f    |\npwa_D                        ds  d    |\npwa_tii_token                ds  f    |\npwa_htd_token                ds  f    |\npwa_lld_first                ds  f    |\npwa_lld_final                ds  f    |\npwa_lld_sort                 ds  f    |\npwa_item_token               ds  f    |\npwa_previous_token           ds  f    |\npwa_tii_build_area      ds xl(tiiitmsz)\npwa_tii_return_area     ds xl(tiiitmsz)\npwa_tii_return_area2    ds xl(tiiitmsz)\npwa_tii_return_area3    ds xl(tiiitmsz)\npwa_tii_return_area4    ds xl(tiiitmsz)\npwa_tii_itd                  ds  h    |\npwa_f     ds    x                     |\npwa_f_eof equ  b'10000000'            |\n         endpwa                       |\n         end   ,                      |\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SRVJSMAC": {"ttr": 29958, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x02\\x00\\x00W\\x01\\x11)\\x9f\\x01\\x11)\\x9f\\t'\\x01\\xe1\\x01\\xe1\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@\"", "ispf": {"version": "02.00", "flags": 0, "createdate": "2011-10-26T00:00:00", "modifydate": "2011-10-26T09:27:57", "lines": 481, "newlines": 481, "modlines": 0, "user": "CLEMSON"}, "text": "*---------------------------------------------------------------------*\n*  Copyright 2011 by Clemson University Research Foundation           *\n*                                                                     *\n*  Licensed under the Apache License, Version 2.0 (the \"License\");    *\n*  you may not use this file except in compliance with the License.   *\n*  You may obtain a copy of the License in this library as member     *\n*  $LICENSE, or from                                                  *\n*                                                                     *\n*      http://www.apache.org/licenses/LICENSE-2.0                     *\n*                                                                     *\n*  Unless required by applicable law or agreed to in writing,         *\n*  software distributed under the License is distributed on an \"AS    *\n*  IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either    *\n*  express or implied.  See the License for the specific language     *\n*  governing permissions and limitations under the License.           *\n*---------------------------------------------------------------------*\n TITLE 'SRVJSMAC: Jobstream Handler symbols && macros.'\n*---------------------------------------------------------------------*\n*\n*  Copy File:  SRVJSMAC\n*\n*  Purpose:    Symbols and macros for the Jobstream Handler.\n*\n*  Description: See \"Service Processors User's Guide and Reference\"\n*\n*  Change\n*  History:    01/02/91 MJM - New\n*\n*---------------------------------------------------------------------*\n*\n***********************************************************************\n***********************************************************************\n**                                                                   **\n**                   SRVJS Symbols & Macros                          **\n**                                                                   **\n***********************************************************************\n***********************************************************************\n*\n* Global declarations for all Jobstream Handler symbols.\n*\n GBLC &JOBSTREAM_HANDLER\n GBLC &MVS_JOBSTREAM_HANDLER\n*\n GBLA &JS_START,&JS_TERMINATE\n GBLA &JS_GET_FEEDBACK\n GBLA &JS_SET_OPTION,&JS_APPEND_LINE\n GBLA &JS_SUBMIT,&JS_SAVE\n*\n GBLA &JS_SUCCESS\n GBLA &JS_INVALID_FUNCTION\n GBLA &JS_ENVIRONMENT_SUPPORT_ERROR\n GBLA &JS_STRING_HANDLER_ERROR\n GBLA &JS_WRONG_NUMBER_OF_PARMS\n GBLA &JS_INVALID_PARAMETER\n GBLA &JS_OUT_OF_MEMORY\n GBLA &JS_LINE_TRUNCATED\n GBLA &JS_NO_MORE_JOBS\n GBLA &JS_DATA_LOST\n GBLA &JS_NEW_JOB    (APPEND? or just SUBMIT?)\n*\n* Entry Point name for the Jobstream handler service processor.\n*\n&JOBSTREAM_HANDLER                      SETC     '''SRVJS   '''\n&MVS_JOBSTREAM_HANDLER                  SETC     '''SRVJSMVS'''\n*\n* Function codes.\n*\n&JS_START                               SETA     1\n&JS_TERMINATE                           SETA     2\n&JS_GET_FEEDBACK                        SETA     3\n&JS_SET_OPTION                          SETA     4\n&JS_APPEND_LINE                         SETA     5\n&JS_SUBMIT                              SETA     6\n&JS_SAVE                                SETA     7\n*\n* Return codes.\n*\n&JS_SUCCESS                             SETA    0\n&JS_INVALID_FUNCTION                    SETA    0\n&JS_INVALID_PARAMETER                   SETA    0\n&JS_ENVIRONMENT_SUPPORT_ERROR           SETA    1\n&JS_STRING_HANDLER_ERROR                SETA    2\n&JS_STORAGE_NOT_AVAILABLE               SETA    3\n&JS_JCL_PROBLEM                         SETA    4\n&JS_INTERNAL_ERROR                      SETA    5\n DEFUCOND MACRO=SRV##RC,NAME=JS_SUCCESS\n DEFUCOND MACRO=SRV##RC,NAME=JS_INVALID_FUNCTION\n DEFUCOND MACRO=SRV##RC,NAME=JS_ENVIRONMENT_SUPPORT_ERROR\n DEFUCOND MACRO=SRV##RC,NAME=JS_STRING_HANDLER_ERROR\n DEFUCOND MACRO=SRV##RC,NAME=JS_STORAGE_NOT_AVAILABLE\n DEFUCOND MACRO=SRV##RC,NAME=JS_JCL_PROBLEM\n DEFUCOND MACRO=SRV##RC,NAME=JS_INTERNAL_ERROR\n                              EJECT\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   JS_ID                                                      *\n*                                                                     *\n* Purpose: Establish default values for a specific service processor  *\n*          and associate them with the specified ID name. The values  *\n*          are stored in the following created global variables:      *\n*                                                                     *\n* Variable Name                     Description                       *\n* -------------  ---------------------------------------------------- *\n* #$&ID.$#IDMAC  Name of macro that created the ID: JS_ID.            *\n* #$&ID.$#ESID   Service processor's Environment Support ID.          *\n* #$&ID.$#EPN    Tag for Service processor's Entry Point Name.        *\n* #$&ID.$#EPA    Tag for Service processor's Entry Point Address.     *\n* #$&ID.$#TKN    Tag for Service processor's Entry Point Token.       *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         JS_ID &ID=,&ESVA=,&SPEPNAME=,&SPEPA=,&SPTOKEN=,&ESID=\n         LCLC  &L_EPNAME\n         GBLC  &JOBSTREAM_HANDLER\n.*\n.* If no EPNAME was specified, use the generic name.\n.*\n&L_EPNAME SETC '&SPEPNAME'\n          AIF  ('&L_EPNAME' NE '').PAST_EPN\n&L_EPNAME SETC '&JOBSTREAM_HANDLER'\n.PAST_EPN ANOP\n.*\n.* Invoke SRV##ID to create globals used by all ID's.\n.*\n         SRV##ID SET,                                                  +\n               ID=&ID.,IDMAC=JS_ID,ESID=&ESID.,SPEPNAME=&L_EPNAME,     +\n               SPEPA=&SPEPA,SPTOKEN=&SPTOKEN.\n         MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   JS_START                                                   *\n* Purpose: Generate code to start a new Jobstream.                    *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         JS_START &ID=,&SPEPA=,&SPTOKEN=,&ESVA=,&FEEDBACKA=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN\n         GBLA  &JS_START                           SETA in open code.\n.*\n.* Obtain service processor ID values.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN,ESVA),                    +\n               ID=&ID,IDMAC=JS_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN,       +\n               ESVA=&ESVA.\n         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT\n.*\n.* Generate code to START the jobstream handler.\n.*\n         ##PLIST START                   | Begin parmlist.\n         ##PLIST PARM,&#_IDTKN           |   Exit's token.\n         ##PLIST PARM,&JS_START          |   Function code.\n         AIF     ('&FEEDBACKA' EQ '').CALLX  ..if no feedback, skip.\n         ##PLIST PARM,&FEEDBACKA         |   Specified FEEDBACK ptr.\n.CALLX   ##PLIST END,VL                  | Mark end of plist.\n         CALLX   &#_IDEPA                | Invoke Jobstream Handler.\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   JS_TERMINATE                                               *\n* Purpose: Generate code to terminate a Jobstream handler session.    *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         JS_TERMINATE &ID=,&SPEPA=,&SPTOKEN=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN\n         GBLA  &JS_TERMINATE              SETA in open code.\n.*\n.* Obtain service processor ID values and terminate Jobstream handler.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +\n               ID=&ID,IDMAC=JS_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN\n         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT\n         CALLX &#_IDEPA,(&#_IDTKN,&JS_TERMINATE),VL\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   JS_GET_FEEDBACK                                            *\n* Purpose: Obtain address of feedback area.                           *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         JS_GET_FEEDBACK &ID=,&SPEPA=,&SPTOKEN=,&FEEDBACKA=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN\n         GBLA  &JS_GET_FEEDBACK                    SETA in open code.\n.*\n.* Obtain service processor ID values.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +\n               ID=&ID,IDMAC=JS_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN\n         AIF   ('&#_IDCODE' NE 'SUCCESS').MEXIT\n         AIF   ('&FEEDBACKA' NE '').PAST_FB\n         MNOTE 8,'FEEBACKA is a required parameter.'\n         MEXIT\n.PAST_FB ANOP\n.*\n.* Generate code to obtain the feedback area's address.\n.*\n         ##PLIST START                   | Begin parmlist.\n         ##PLIST PARM,&#_IDTKN           |   Exit's token.\n         ##PLIST PARM,&JS_GET_FEEDBACK   |   Function code.\n         ##PLIST PARM,&FEEDBACKA         |   Specified FEEDBACK ptr.\n.CALLX   ##PLIST END,VL                  | Mark end of plist.\n         CALLX   &#_IDEPA                | Invoke Jobstream Handler.\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   JS_SET_OPTION                                              *\n* Purpose: Set a jobstream-handler option.                            *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         JS_SET_OPTION &ID=,&SPEPA=,&SPTOKEN=,&OPTION=,&VALUE=\n         GBLA  &JS_SET_OPTION                  SETA in open code.\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN\n         LCLC  &L_ADDR,&L_LEN\n         LCLA  &I,&L\n.*\n.* Obtain service processor ID values.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +\n               ID=&ID,IDMAC=JS_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN\n         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT\n.*\n.* Decode the OPTION= keyword to get an address and length.\n.*\n              AIF ('&OPTION' EQ '').NO_OPTION\n              AIF (N'&OPTION EQ 2).OPT_TAGLEN\n              AIF (N'&OPTION EQ 1).OPT_TAGONLY\n              MNOTE 8,'Too many subparameters for OPTION keyword.'\n              MEXIT\n.OPT_TAGLEN   ANOP\n&L_ADDR       SETC '&OPTION(1)'           | Set addr.\n&L_LEN        SETC '&OPTION(2)'           | Set len.\n              AGO  .PAST_OPTION           |\n.OPT_TAGONLY  ANOP\n              AIF ('&OPTION'(1,1) EQ '''').OPT_LITERAL\n&L_ADDR       SETC '&OPTION'              | Set addr to tag_name.\n&L_LEN        SETC '=A(L''&OPTION)'       | Set len to L'tag_name.\n              AGO  .PAST_OPTION           |\n.OPT_LITERAL  ANOP                        |\n&L_ADDR       SETC '&OPTION'              | Set addr to actual literal.\n&L            SETA 0                      | Length counter = 0.\n&I            SETA 2                      | Index counter -> past '.\n.OPT_LOOP     AIF  (&I GE K'&L_ADDR).OPT_ELOOP       Loop over message.\n              AIF  ('&L_ADDR'(&I,1) NE '''').OPT_TXT If doubled quotes.\n&I            SETA &I+1                   |            Advance past '.\n.OPT_TXT      ANOP                        |          EndIf.\n&L            SETA &L+1                   |   Add one to length.\n&I            SETA &I+1                   |   Advance to next position.\n              AGO  .OPT_LOOP              | End of counting loop.\n.OPT_ELOOP    ANOP                        |\n&L_LEN        SETC '&L'                   | Set length parameter.\n              AGO  .PAST_OPTION\n.NO_OPTION    MNOTE 8,'OPTION is a required keyword.'\n              MEXIT\n.PAST_OPTION  ANOP\n.*\n.* If VALUE= was specified, make sure it is VALUE=(tag,length)\n.*\n         AIF  ('&VALUE' EQ '').PAST_VALUE\n         AIF  (N'&VALUE EQ 2).PAST_VALUE\n         MNOTE 8,'VALUE must be specified as VALUE=(tag,length)'\n         MEXIT\n.PAST_VALUE ANOP\n.*\n.* Generate the SET_OPTION call statement.\n.*\n         ##PLIST START                   | Begin parmlist.\n         ##PLIST PARM,&#_IDTKN           |   Exit's token.\n         ##PLIST PARM,&JS_SET_OPTION     |   Function code.\n         ##PLIST PARM,&L_ADDR            |   Option's name.\n         ##PLIST PARM,&L_LEN             |   Option name's length.\n         AIF     ('&VALUE' EQ '').CALLX    ..if no value, skip.\n         ##PLIST PARM,&VALUE(1)          |   Specified value.\n         ##PLIST PARM,&VALUE(2)          |   Value's length.\n.CALLX   ##PLIST END,VL                  | Mark end of plist.\n         CALLX   &#_IDEPA                | Invoke Jobstream Handler.\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   JS_APPEND_LINE                                             *\n* Purpose: Add a new line to jobstream being constructed.             *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         JS_APPEND_LINE &ID=,&SPEPA=,&SPTOKEN=,&LINE=\n         GBLA  &JS_APPEND_LINE                 SETA in open code.\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN\n         LCLC  &L_ADDR,&L_LEN\n         LCLA  &I,&L\n.*\n.* Obtain service processor ID values.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +\n               ID=&ID,IDMAC=JS_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN\n         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT\n.*\n.* Decode the LINE= keyword to get an address and length.\n.*\n              AIF ('&LINE' EQ '').NO_LINE\n              AIF (N'&LINE EQ 2).LIN_TAGLEN\n              AIF (N'&LINE EQ 1).LIN_TAGONLY\n              MNOTE 8,'Too many subparameters for LINE keyword.'\n              MEXIT\n.LIN_TAGLEN   ANOP\n&L_ADDR       SETC '&LINE(1)'             | Set addr.\n&L_LEN        SETC '&LINE(2)'             | Set len.\n              AGO  .PAST_LINE             |\n.LIN_TAGONLY  ANOP\n              AIF ('&LINE'(1,1) EQ '''').LIN_LITERAL\n&L_ADDR       SETC '&LINE'                | Set addr to tag_name.\n&L_LEN        SETC '=A(L''&LINE)'         | Set len to L'tag_name.\n              AGO  .PAST_LINE             |\n.LIN_LITERAL  ANOP                        |\n&L_ADDR       SETC '&LINE'                | Set addr to actual literal.\n&L            SETA 0                      | Length counter = 0.\n&I            SETA 2                      | Index counter -> past '.\n.LIN_LOOP     AIF  (&I GE K'&L_ADDR).LIN_ELOOP       Loop over message.\n              AIF  ('&L_ADDR'(&I,1) NE '''').LIN_TXT If doubled quotes.\n&I            SETA &I+1                   |            Advance past '.\n.LIN_TXT      ANOP                        |          EndIf.\n&L            SETA &L+1                   |   Add one to length.\n&I            SETA &I+1                   |   Advance to next position.\n              AGO  .LIN_LOOP              | End of counting loop.\n.LIN_ELOOP    ANOP                        |\n&L_LEN        SETC '&L'                   | Set length parameter.\n              AGO  .PAST_LINE\n.NO_LINE      MNOTE 8,'LINE is a required keyword.'\n              MEXIT\n.PAST_LINE    ANOP\n.*\n.* Generate the APPEND_LINE call statement.\n.*\n         CALLX &#_IDEPA,(&#_IDTKN,&JS_APPEND_LINE,&L_ADDR,&L_LEN),VL\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   JS_SUBMIT                                                  *\n* Purpose: Submit the jobstream to the system to execution.           *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         JS_SUBMIT &ID=,&SPEPA=,&SPTOKEN=,&JOBNAME=,&JOBID=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN\n         GBLA  &JS_SUBMIT SETA in open code.\n.*\n.* Obtain service processor ID values and invoke Jobstream Handler.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +\n               ID=&ID,IDMAC=JS_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN\n         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT\n.*\n.* Generate code to invoke the JS_SUBMIT function.\n.*\n         CALLX &#_IDEPA,(&#_IDTKN,&JS_SUBMIT,&JOBNAME,&JOBID),VL\n         ##PLIST START                   | Begin parmlist.\n         ##PLIST PARM,&#_IDTKN           |   Exit's token.\n         ##PLIST PARM,&JS_SUBMIT         |   Function code.\n         AIF     ('&JOBID' NE '').JOBID\n         AIF     ('&JOBNAME' EQ '').NONAME\n         ##PLIST PARM,&JOBNAME           |   Returned JOBNAME.\n         AGO     .CALLX\n.JOBID   ##PLIST PARM,&JOBNAME           |   Returned JOBNAME.\n         ##PLIST PARM,&JOBID             |   Returned JOBID.\n.CALLX   ##PLIST END,VL                  | Mark end of plist.\n         CALLX   &#_IDEPA                | Invoke Jobstream Handler.\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   JS_SAVE                                                    *\n* Purpose: Save the jobstream to a file.                              *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         JS_SAVE &ID=,&SPEPA=,&SPTOKEN=,&FILE=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN\n         GBLA  &JS_SAVE SETA in open code.\n.*\n.* Obtain service processor ID values and invoke Jobstream Handler.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +\n               ID=&ID,IDMAC=JS_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN\n         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT\n.*\n.* Generate code to invoke the JS_SAVE function.\n.*\n         CALLX &#_IDEPA,(&#_IDTKN,&JS_SAVE,&JOBNAME,&JOBID),VL\n         ##PLIST START                   | Begin parmlist.\n         ##PLIST PARM,&#_IDTKN           |   Exit's token.\n         ##PLIST PARM,&JS_SAVE           |   Function code.\n         AIF     ('&JOBID' NE '').JOBID\n         AIF     ('&JOBNAME' EQ '').NONAME\n         ##PLIST PARM,&JOBNAME           |   Returned JOBNAME.\n         AGO     .CALLX\n.JOBID   ##PLIST PARM,&JOBNAME           |   Returned JOBNAME.\n         ##PLIST PARM,&JOBID             |   Returned JOBID.\n.CALLX   ##PLIST END,VL                  | Mark end of plist.\n         CALLX   &#_IDEPA                | Invoke Jobstream Handler.\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   JS_FEEDBACK                                                *\n* Purpose: Mapping area for jobstream handler feedback area.          *\n*                                                                     *\n*---------------------------------------------------------------------*\n                  MACRO\n&LABEL            JS_FEEDBACK &DSECT=YES,&ID=JS_FB_\n                  LCLC  &NAME\n&NAME             SETC  'JS_FB_START' AIF   ('&LABEL' EQ '').PAST_LABEL\n&NAME             SETC  '&LABEL'\n.PAST_LABEL       AIF   ('&DSECT' EQ 'YES').GEN_DSECT\n&NAME             DS    0F         | Jobstream-handler FEEDBACK area:\n                  AGO .GEN_FIELDS\n.GEN_DSECT        ANOP\n&NAME             DSECT            | Jobstream-handler FEEDBACK area:\n.GEN_FIELDS       ANOP\n&ID.START         EQU *            | Start of FEEDBACK area:\n&ID.STRING        DS  CL256        |   Entire area as 256-byte string.\n                  ORG &ID.START    |   Remap fields from the start.\n&ID.REASON        DS  F            |   Reason-code.\n&ID.REASON1       EQU 0            |     No information.\n&ID.REASON2       EQU 1            |     No information.\n&ID.SEQUENCE      DS  F            |   Job sequence # (1,2,3,etc).\n&ID.JOBNAME       DS  CL8          |   Current JOBNAME.\n&ID.JOBID         DS  CL8          |   Current JOB Identifier.\n&ID.MSGLEN        DS  H            |   Message length.\n&ID.MSGTEXT       DS  CL132        |   Message text.\n                  ORG ,            |   Get to correct offset.\n&ID.LENGTH        EQU *-&ID.START  | Length of feedback area.\n                  MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   JS_PARMLIST                                                *\n* Purpose: Generate Jobstream handler's parameter list.               *\n*                                                                     *\n*---------------------------------------------------------------------*\n                  MACRO\n&LABEL            JS_PARMLIST &DSECT=YES,&ID=JS_PRM_\n                  LCLC  &NAME\n&NAME             SETC  'JS_PARMLIST'\n                  AIF   ('&LABEL' EQ '').PAST_LABEL\n&NAME             SETC  '&LABEL'\n.PAST_LABEL       ANOP\n                  AIF   ('&DSECT' EQ 'YES').GEN_DSECT\n&NAME             DS    0F         | Jobstream-handler Parameter List:\n                  AGO .GEN_FIELDS\n.GEN_DSECT        ANOP\n&NAME             DSECT            | Jobstream-handler Parameter List:\n.GEN_FIELDS       ANOP\n&ID.START         EQU *            |   Start of parameter list.\n&ID.TOKEN         DS  A            |   Token := PWA Base Address.\n&ID.FUNCTIONCODE  DS  A            |   Function to be performed.\n&ID.SPECIFIC      EQU *            |   Function-specific parameters.\n                  ORG &ID.SPECIFIC |   JS_START parameters:\n&ID.S_ESVA        DS  A            |     Environment support vector.\n&ID.S_FEEDBACKA   DS  A            |     Returned ptr to feedback area.\n                  ORG &ID.SPECIFIC |   JS_GET_FEEDBACK parameters:\n&ID.GF_FEEDBACKA  DS  A            |     Returned ptr to feedback area.\n                  ORG &ID.SPECIFIC |   JS_SET_OPTION parms:\n&ID.SO_NAME       DS  A            |     Option name.\n&ID.SO_NAME_LEN   DS  A            |     Name's length (fullword).\n&ID.SO_VALUE      DS  A            |     Specified value or null ptr.\n&ID.SO_VALUE_LEN  DS  A            |     Length of specified value.\n                  ORG &ID.SPECIFIC |   JS_APPEND_LINE parms:\n&ID.AL_LINE       DS  A            |     Text of output line.\n&ID.AL_LINE_LEN   DS  A            |     Length of output line.\n                  ORG &ID.SPECIFIC |   JS_SUBMIT parms:\n                  ORG &ID.SPECIFIC |   JS_SAVE parms:\n&ID.SA_NAME       DS  A            |     File name to receive data.\n&ID.SA_NAME_LEN   DS  A            |     Length of file name.\n&ID.SA_OPTION     DS  A            |     APPEND|REPLACE option.\n                  ORG ,            | Get to correct offset.\n&NAME._L          EQU *-&ID.START  | Length of jobstream handler plist.\n                  MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SRVJSMVS": {"ttr": 30212, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x02\\x00\\x00W\\x01\\x11)\\x9f\\x01\\x11)\\x9f\\t'\\x06;\\x06;\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@\"", "ispf": {"version": "02.00", "flags": 0, "createdate": "2011-10-26T00:00:00", "modifydate": "2011-10-26T09:27:57", "lines": 1595, "newlines": 1595, "modlines": 0, "user": "CLEMSON"}, "text": "*---------------------------------------------------------------------*\n*  Copyright 2011 by Clemson University Research Foundation           *\n*                                                                     *\n*  Licensed under the Apache License, Version 2.0 (the \"License\");    *\n*  you may not use this file except in compliance with the License.   *\n*  You may obtain a copy of the License in this library as member     *\n*  $LICENSE, or from                                                  *\n*                                                                     *\n*      http://www.apache.org/licenses/LICENSE-2.0                     *\n*                                                                     *\n*  Unless required by applicable law or agreed to in writing,         *\n*  software distributed under the License is distributed on an \"AS    *\n*  IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either    *\n*  express or implied.  See the License for the specific language     *\n*  governing permissions and limitations under the License.           *\n*---------------------------------------------------------------------*\n++* XSUB\n++* DECLARE MOD STRING = 'SRVJSMVS'\n++* DECLARE ONLY BOOLEAN CMDLINE = TRUE   /* USE FOR JUST ASMPC */\n//&<MOD>  JOB ,'ASSEMBLE AND LINK',TIME=(,8)\n/*JOBPARM Q=H,LINES=50\n//LASER   OUTPUT DEST=LASER,UCS=PR12,CHARS=PR12,FCB=85@8\n//LASER4  OUTPUT DEST=LASER,FORMDEF=RULE4,FCB=4UP\n++* IF ONLY\n//STEP1   EXEC ASMPC,\n//        COPT=',TEST,RENT',\n//        MAC=SYSTEMS\n++* ELSE\n//STEP1   EXEC ASMPCL,PDS='SYSTEMS.SRV.LOAD',NAME=&<MOD>,\n//        COPT=',TEST,RENT',LOPT=',LET,NCAL,TEST,RENT',SYSOUT='(,)',\n//        MAC=SYSTEMS\n++* ENDIF\n//P.SYSPRINT DD SYSOUT=A,OUTPUT=*.LASER\n//P.SYSIN    DD *\n         SMLIST CONVERT=YES\nSRVJSMVS title \"Jobstream Handler Service Processor.\"\n         srvmod name=srvjsmvs,dates='1991'\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Copyright (c) 1991 Clemson University                              *\n*                                                                     *\n*  Program     SRVJSMVS                                               *\n*                                                                     *\n*  Abstract    This server is the batch jobstream service processor.  *\n*              It will process JES2 jobstreams, and either submit     *\n*              them for batch execution or write them to an output    *\n*              file.                                                  *\n*                                                                     *\n*  Special     The JES2 internal reader interface used by this        *\n*  Note        program is pretty obscure. It is a sanctioned          *\n*              interface though and is documented in manual           *\n*              GG22-9207 \"JES2 Internal Reader Processing\".           *\n*                                                                     *\n*  Parameters:                                                        *\n*    Documented in the Service Processors User's Guide and Reference. *\n*    The following function calls are supported.                      *\n*                                                                     *\n*    JS_START         ID=JS,FEEDBACK=tag                              *\n*    JS_TERMINATE     ID=JS                                           *\n*    JS_GET_FEEDBACK  ID=JS,FEEDBACK=tag                              *\n*    JS_SET_OPTION    ID=JS,OPTION=(option,value)  HOLD/SCAN/etc      *\n*    JS_APPEND_LINE   ID=JS,LINE=(address,length)                     *\n*    JS_SUBMIT        ID=JS,JOBNAME=jobname,JOBID=jobid               *\n*    JS_SAVE          ID=JS,FILE=(name,length,<APPEND|REPLACE>)       *\n*                                                                     *\n*    The FEEDBACK parameter designates a fullword in which the        *\n*    address of the Jobstream handler's feedback area will be         *\n*    returned.  This area contains information in addition to that    *\n*    supplied by the actual return code.  It is mapped by the         *\n*    JS_FEEDBACK mapping macro.                                       *\n*                                                                     *\n*  Program     reentrant, problem key and state, standard linkage,    *\n*  Attributes  non-authorized, amode(31), rmode(24)                   *\n*                                                                     *\n*  Change                                                             *\n*  History     01/02/91 MJM - NEW                                     *\n*              03/29/91 MJM - Added support for instream data sets    *\n*                             following \"/*XMIT\" JES2 statements and  *\n*                             the equivalent JES3 XMIT JCL statement. *\n*                             (We don't have JES3, but this code can  *\n*                             handle the statement anyways).          *\n*                                                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n             eject\n             copy smsyms           | Copy Structured Macros symbols.\n             copy srvesmac         | Copy Environment Support symbols.\n             copy srvstmac         | Copy String Handler symbols.\n             copy srvjsmac         | Copy Jobstream Handler symbols.\n*---------------------------------------------------------------------*\n*  Symbols for use by the Block macro's COPY parameters option.\n*---------------------------------------------------------------------*\njs_parmmap   js_parmlist id=jspm_,dsect=yes   Done only for BLOCK instr\n*---------------------------------------------------------------------*\n*  Symbols for Jobstream Handler options.\n*---------------------------------------------------------------------*\n&jso_undefined            seta 0   | Not a Jobstream option.\n&jso_hold                 seta 1   |  HOLD option.\n&jso_inform               seta 2   |  INFORM option.\n&jso_jobhold              seta 3   |  JOBHOLD option.\n&jso_reroute              seta 4   |  REROUTE option.\n&jso_scan                 seta 5   |  SCAN option.\n*---------------------------------------------------------------------*\n*  Symbols for append_line processing states.\n*---------------------------------------------------------------------*\n&al_s_new                 seta  1  | Start of a new JCL statement.\n&al_s_job_stmt            seta  2  | New JOB statement.\n&al_s_dd_stmt             seta  3  | New DD statement.\n&al_s_xmit_stmt           seta  4  | New JES3 XMIT statement.\n&al_s_null_stmt           seta  5  | Job terminator statement.\n&al_s_jes2xmit_stmt       seta  6  | /*XMIT statement.\n&al_s_job_parms           seta  7  | In parameters field of JOB.\n&al_s_job_insert          seta  8  | At end of JOB parameters.\n&al_s_job_comments        seta  9  | Comments field of JOB stmt.\n&al_s_dd_parms            seta 10  | In parameters field of DD.\n&al_s_dd_comments         seta 11  | Comments field of DD stmt.\n&al_s_instream            seta 12  | Scan instream data lines.\n*---------------------------------------------------------------------*\n*  Symbols for append_line processing actions.\n*---------------------------------------------------------------------*\n&al_a_append              seta  1  | Append current line to jobstream.\n&al_a_replace             seta  2  | Replace line with another.\n&al_a_insert              seta  3  | Insert new line before current.\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Macro:      MSG (condition),(parameters)                           *\n*              MSG (parameters)                                       *\n*  Purpose:    Conditionally invoke the message subroutine.           *\n*                                                                     *\n*---------------------------------------------------------------------*\n         macro\n         msg\n         aif   (n'&syslist eq 1).nocond\n         aif   (n'&syslist eq 2).cond\n         mnote 8,'wrong number of parms'\n         mexit\n.cond    if    &syslist(1)                   If conditions apply.\n         callsub message,&syslist(2)          Invoke message routine.\n         endif                               EndIf.\n         mexit\n.nocond  callsub message,&syslist(1)         Invoke message routine.\n         mend\n         eject\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Main program code.                                                 *\n*                                                                     *\n*---------------------------------------------------------------------*\n block name=SRVJSMVS,type=program,amode=31,rmode=24,basereg=(r12,r9),  +\n               parmmap=(js_parmmap,js_parmmap_l),                      +\n               options=(*srvprc,long,                                  +\n               (parms,vl,copy,(count,pwa_#parms),                      +\n               (copyerror,,&js_wrong_number_of_parms))),               +\n               subopts=(*swa,loadbase)\n   es_id   id=es,spepa=pwa_es_epa,sptoken=pwa_es_token,esva=pwaaesv\n   st_id   id=st,spepa=pwa_st_epa,sptoken=pwa_st_token\n   mvc     js_fb_reason,=f'0'       | Initialize reason code.\n   l       r1,js_prm_functioncode   | R1 -> function code.\n   l       r1,0(r1)                 | R1 := function code.\n   caseblk reg=r1,mult=1            | Case on FunctionCode.\n   case &js_start                   | -------------------------START---\n     callsub start                  |\n   case &js_terminate               | ---------------------TERMINATE---\n     callsub terminate              |\n   case &js_get_feedback            | ------------------GET_FEEDBACK---\n     callsub get_feedback           |\n   case &js_set_option              | --------------------SET_OPTION---\n     callsub set_option             |\n   case &js_append_line             | -------------------APPEND_LINE---\n     callsub Append_Line            |\n   case &js_submit                  | ------------------------SUBMIT---\n     callsub submit_jobstream       |\n   case &js_save                    | --------------------------SAVE---\n     callsub save_to_file           |\n   case other                       | ----------------------***ERROR***\n     msg     (JS00004C,*js_prm_functioncode)\n     errexit code=&js_invalid_function\n   endcase                          | EndCase.\n endblk block=srvjsmvs,rc=0         |\n eject\n***********************************************************************\n*                                                                     *\n*  Subroutine: Start                                                  *\n*  Abstract:   Initialize all exit-related variables.                 *\n*                                                                     *\n***********************************************************************\n block type=subroutine,name=start\n*---------------------------------------------------------------------*\n*  Establish environment for using service processors ourselves.\n*---------------------------------------------------------------------*\n   l       r2,pwaaesv                  | r2 -> A(Env Support Vector).\n   l       r2,0(,r2)                   | r2 -> Env Support Vector.\n   using   esv,r2                      | Establish addressability.\n   mvc     pwa_es_epa,esvesepa         | Copy Env. Sup. EPA.\n   mvc     pwa_es_token,esvestkn       | Copy Env. Sup. TOKEN.\n   drop    r2                          | Drop addressability.\n*                                      |\n   es_load_module id=es,spid=st        | Load String Handler.\n   if (not,(%es_success))              | If unable to load.\n     sth     r15,pwa_rc                |   Save RC in PWA.\n     msg     (JS00001C)                |   Set up an error message.\n     errexit code=&js_environment_support_error\n   endif                               | EndIf.\n*                                      |\n   st_start id=st,sizelength=2         | Start string handler.\n   if (not,(%st_success))              | If unable to start.\n     sth     r15,pwa_rc                |   Save RC in PWA.\n     msg     (JS00002C)                |   Set up an error message.\n     errexit code=&js_string_handler_error\n   endif                               | EndIf.\n*---------------------------------------------------------------------*\n*  Initialize all option values for options supported by this exit.\n*---------------------------------------------------------------------*\n   mvi     pwa_hold,c\"N\"               | /HOLD = false.\n   mvi     pwa_inform,c\"N\"             | /INFORM = false.\n   mvi     pwa_reroute,c\"N\"            | /REROUTE = false.\n   mvi     pwa_typrun,c\" \"             | /JOBHOLD & /SCAN = false.\n*---------------------------------------------------------------------*\n*  Obtain the first segment of storage for holding jobstream lines.\n*---------------------------------------------------------------------*\n   es_obtain_storage id=es,size=psd_stg_incr,address=pwa_stg_current\n   if (%es_storage_not_available)      | If not enough storage.\n     msg     (JS00014S)                |   Not enough stg message.\n     errexit code=&js_storage_not_available\n   elseif (not,(%es_success))          | ElseIf unexpected error.\n     sth     r15,pwa_rc                |   Save RC in PWA.\n     msg     (JS00000C)                |   Format error message.\n     errexit code=&js_environment_support_error\n   endif                               | EndIf.\n   mvc   pwa_stg_anchor,pwa_stg_current  Copy address to anchor word.\n   l     r2,pwa_stg_current            | r2 -> New stg block.\n   using stg,r2                        | Establish addressability.\n   mvc   stg_link,=f'0'                | Force link to null.\n   mvc   stg_size,psd_stg_incr         | Remember amount allocated.\n   l     r0,stg_size                   | r0 := total size of stg.\n   s     r0,=a(stg_l)                  | r0 := size of stg_area.\n   st    r0,stg_free                   | Save remaining # bytes free.\n   drop  r2                            | Drop addressability.\n*---------------------------------------------------------------------*\n*  Initialize the JCL parsing state.  Values are used by js_append_line\n*  for tracking where it is within the jobstream being constructed.\n*---------------------------------------------------------------------*\n   mvc   al_job_count,=f'0'            | No JOB statements.\n   mvc   al_job_name,psd_blanks        | No current JOB.\n   mvc   al_state,=f'&al_s_new'        | Initial JCL parsing state.\n*---------------------------------------------------------------------*\n*  If FEEDBACKA parameter specified, return address of feedback area.\n*---------------------------------------------------------------------*\n   if (clc,pwa_#parms,ge,=f'4')        | If FEEDBACKA specified.\n     l    r1,js_prm_s_feedbacka        |   r1 -> FEEDBACKA parm.\n     la   r0,js_fb_start               |   r0 -> Start of feedback.\n     st   r0,0(,r1)                    |   Return feedbacka parm.\n   endif                               | EndIf.\n*---------------------------------------------------------------------*\n*  Make sure no unwanted parameters were specified.\n*---------------------------------------------------------------------*\n   if (clc,pwa_#parms,gt,=f'4')        | If too many parms.\n     msg     (JS00003C,\"START\",5)      |   Format a message.\n     errexit code=&js_wrong_number_of_parms\n   endif                               | EndIf.\n endblk block=start\n eject\n***********************************************************************\n*                                                                     *\n*  Subroutine: Terminate                                              *\n*  Abstract:   Release all resources held by this session.            *\n*                                                                     *\n***********************************************************************\n block type=subroutine,name=terminate\n*---------------------------------------------------------------------*\n*  Mark pwa to be released on exit and return.\n*---------------------------------------------------------------------*\n   smctrl freepwa=yes                        | Release the PWA on exit.\n endblk block=terminate\n eject\n***********************************************************************\n*                                                                     *\n* Subroutine: Get_Feedback                                            *\n*                                                                     *\n***********************************************************************\n block type=subroutine,name=Get_Feedback\n   if (clc,pwa_#parms,ne,=f'3')        | If wrong number of parms.\n     msg     (JS00003C,\"GET_FEEDBACK\",12)  Format a message.\n     errexit code=&js_wrong_number_of_parms\n   endif                               | EndIf.\n*---------------------------------------------------------------------*\n*  Return the address of the feedback information area.\n*---------------------------------------------------------------------*\n   l    r1,js_prm_gf_feedbacka         | r1 -> FEEDBACKA parm.\n   la   r0,js_fb_start                 | r0 -> Start of feedback.\n   st   r0,0(,r1)                      | Return feedbacka parm.\n endblk block=Get_Feedback\n eject\n***********************************************************************\n*                                                                     *\n* Subroutine: Set_Option                                              *\n*                                                                     *\n***********************************************************************\n block type=subroutine,name=Set_Option\n   if (clc,pwa_#parms,ne,=f'4'),and,(clc,pwa_#parms,ne,=f'6')\n     msg     (JS00003C,\"SET_OPTION\",10)    Format a message.\n     errexit code=&js_wrong_number_of_parms\n   endif                               | EndIf.\n   callsub look_up_option,(*js_prm_so_name,*js_prm_so_name_len)\n   if      (ch,r15,eq,=h'&jso_undefined')\n     msg     (JS00005E,*js_prm_so_name,*js_prm_so_name_len)\n     errexit code=&js_invalid_parameter\n   endif\n*---------------------------------------------------------------------*\n*  Set the specified option.\n*---------------------------------------------------------------------*\n   caseblk reg=r15,mult=1               | Case on option#.\n   case &jso_hold                       | -------------------------HOLD\n     callsub set_boolean_option,(pwa_hold)\n   case &jso_inform                     | -----------------------INFORM\n     callsub set_boolean_option,(pwa_inform)\n   case &jso_jobhold                    | ----------------------JOBHOLD\n     callsub set_boolean_option,(&w.boolean)\n     if (cli,&w.boolean,eq,c\"Y\")        | If /JOBHOLD = TRUE.\n       if (cli,pwa_typrun,eq,c\" \")      |   If TYPRUN not already set.\n         mvi pwa_typrun,c\"H\"            |     Set TYPRUN=HOLD.\n       elseif (cli,pwa_typrun,ne,c\"H\")  |   ElseIf not already =HOLD.\n         msg (JS00007E,\"JOBHOLD\",7,\"SCAN\",4)  Format an error message.\n         errexit code=&js_invalid_parameter   Exit w/return-code.\n       endif                            |   EndIf.\n     elseif (cli,pwa_typrun,eq,c\"H\")    |   ElseIf /JOBHOLD was set.\n       mvi pwa_typrun,c\" \"              |     Reset to blanks.\n     endif                              | EndIf.\n   case &jso_reroute                    | ----------------------REROUTE\n     callsub set_boolean_option,(pwa_reroute)\n   case &jso_scan                       | -------------------------SCAN\n     callsub set_boolean_option,(&w.boolean)\n     if (cli,&w.boolean,eq,c\"Y\")        | If /SCAN = TRUE.\n       if (cli,pwa_typrun,eq,c\" \")      |   If TYPRUN not already set.\n         mvi pwa_typrun,c\"S\"            |     Set TYPRUN=SCAN.\n       elseif (cli,pwa_typrun,ne,c\"S\")  |   ElseIf not already =SCAN.\n         msg (JS00007E,\"SCAN\",4,\"JOBHOLD\",7)  Get Xsub to format msg.\n         errexit code=&js_invalid_parameter   Exit w/return-code.\n       endif                            |   EndIf.\n     elseif (cli,pwa_typrun,eq,c\"S\")    |   ElseIf /SCAN was set.\n       mvi pwa_typrun,c\" \"              |     Reset to blanks.\n     endif                              | EndIf.\n   endcase                              | EndCase\n endblk block=Set_Option\n*---------------------------------------------------------------------*\n* Working storage for setting options.\n*---------------------------------------------------------------------*\n                swa\n&w.boolean      ds      c      | Boolean value: \"Y\" or \"N\".\n                endswa\n                eject\n***********************************************************************\n*                                                                     *\n* Subroutine: Look_Up_Option                                          *\n*                                                                     *\n***********************************************************************\n block type=subroutine,name=Look_Up_Option\n*---------------------------------------------------------------------*\n*  Set up a capitalized copy of the option's name in pwa_work.\n*---------------------------------------------------------------------*\n   lm  r4,r5,0(r1)                       | r4 -> Name. r5 -> Length.\n   icm r5,b'1111',0(r5)                  | r5 := Length of name.\n   if  (treg,r5,np),or,(c,r5,gt,=f'16')  | If too short or too long.\n     la    r15,&jso_undefined            |   Option not exit-defined.\n     leave block=*                       |   Return to caller.\n   endif                                 | EndIf.\n   st    r5,pwa_work_len                 | Save length of name.\n   bctr  r5,0                            | Subtract 1 for EX instr.\n   exi   r5,(mvc,pwa_work(0),0(r4))      | Copy option name to the SWA.\n   exi   r5,(oc,pwa_work(0),psd_blanks)  | Fold name to upper case.\n   la    r5,1(,r5)                       | Restore actual name length.\n*---------------------------------------------------------------------*\n*  Recognize the specified option and set R15 accordingly.\n*---------------------------------------------------------------------*\n   if ((c,r5,eq,=f'4'),and,(clc,=c\"HOLD\",eq,pwa_work)),or,             +\n               ((c,r5,eq,=f'1'),and,(clc,=c\"H\",eq,pwa_work))       HOLD\n     la   r15,&jso_hold              |\n   elseif ((c,r5,eq,=f'6'),and,(clc,=c\"INFORM\",eq,pwa_work)),or,       +\n               ((c,r5,eq,=f'1'),and,(clc,=c\"I\",eq,pwa_work))     INFORM\n     la   r15,&jso_inform            |\n   elseif ((c,r5,eq,=f'7'),and,(clc,=c\"JOBHOLD\",eq,pwa_work)),or,      +\n               ((c,r5,eq,=f'2'),and,(clc,=c\"JH\",eq,pwa_work))   JOBHOLD\n     la   r15,&jso_jobhold           |\n   elseif ((c,r5,eq,=f'7'),and,(clc,=c\"REROUTE\",eq,pwa_work)),or,      +\n               ((c,r5,eq,=f'1'),and,(clc,=c\"R\",eq,pwa_work))    REROUTE\n     la   r15,&jso_reroute           |\n   elseif ((c,r5,eq,=f'4'),and,(clc,=c\"SCAN\",eq,pwa_work)),or,         +\n               ((c,r5,eq,=f'1'),and,(clc,=c\"S\",eq,pwa_work))       SCAN\n     la   r15,&jso_scan              |\n   else                              | Else.\n     la   r15,&jso_undefined         |                 Not exit-defined\n   endif                             | EndIf.\n endblk block=Look_Up_Option\n                eject\n***********************************************************************\n*                                                                     *\n* Subroutine: Set_Boolean_Option (Option's Flag)                      *\n* Abstract:   Use the provided value to set the option's flag:        *\n*                                                                     *\n*             Value          Option Flag is set to                    *\n*             -----------    ---------------------                    *\n*             ..missing..    \"Y\"                                      *\n*             \"TRUE\"         \"Y\"                                      *\n*             \"FALSE\"        \"N\"                                      *\n*                                                                     *\n***********************************************************************\n block type=subroutine,name=set_boolean_option\n   l   r3,0(r1)                      | r3 -> Option's flag character.\n   slr r4,r4                         | r4 -> .missing. value.\n   if  (clc,pwa_#parms,ge,=f'6')     | If (value,length) provided.\n     l     r4,js_prm_so_value        |   r4 -> Option's value.\n     la    r4,0(,r4)                 |   Discard high-order bit.\n   endif                             | EndIf.\n   if  (treg,r4,z)                   | If r4 -> .missing. value.\n     mvi   0(r3),c\"Y\"                |   Set default boolean value.\n     leave block=*                   |   Return to caller.\n   endif                             | EndIf.\n   mvi 0(r3),c\"N\"                    | Value to use if bad-source.\n*                                    |\n   l   r5,js_prm_so_value_len        | r5 -> Length of option's value.\n   icm r5,b'1111',0(r5)              | r5 := Length of option's value.\n   if  (treg,r5,np),or,(c,r5,gt,=f'5') If too short or too long.\n     msg     (JS00006E,pwa_work,pwa_work_len)\n     errexit code=&js_invalid_parameter  Exit with return-code.\n   else                              | Else.\n     bctr r5,0                       |   Subtract 1 for EX instr.\n     exi  r5,(mvc,&w.value(0),0(r4)) |   Copy option value to the SWA.\n     exi  r5,(oc,&w.value(0),psd_blanks) Fold value to upper case.\n     la   r5,1(,r5)                  |   Restore actual name length.\n     if   (c,r5,eq,=f'4'),and,(clc,=c\"TRUE\",eq,&w.value)\n       mvi 0(r3),c\"Y\"                |     Set option's flag.\n     elseif (c,r5,eq,=f'5'),and,(clc,=c\"FALSE\",eq,&w.value)\n       mvi 0(r3),c\"N\"                |     Set option's flag.\n     else                            |   Else.\n       msg     (JS00006E,pwa_work,pwa_work_len)\n       errexit code=&js_invalid_parameter Exit with return-code.\n     endif                           |   EndIf.\n   endif                             | EndIf.\n endblk block=set_boolean_option\n*---------------------------------------------------------------------*\n* Working storage for recognizing boolean option values.\n*---------------------------------------------------------------------*\n                swa\n&w.value        ds    cl5            | TRUE or FALSE\n                endswa\n                eject\n***********************************************************************\n*                                                                     *\n* Subroutine: append_line                                             *\n*                                                                     *\n* Abstract  : Append a new line to the jobstream being built, after   *\n*             performing any needed processing on it.  Processing of  *\n*             new lines being added to the jobstream is done to:      *\n*             1. count JOB statements.                                *\n*             2. extract jobnames.                                    *\n*             3. make optional modifications to the jobstream.        *\n*             4. insert optional JES2 control statements.             *\n*                                                                     *\n*             Throughout execution of this routine and its children,  *\n*             the following register usage is in effect:              *\n*                                                                     *\n*             R4 -> Start of output line.                             *\n*             R5 := Total length of output line.                      *\n*             R6 -> Current scan position.                            *\n*             R7 -> Scan limit (Column 72 or end-of-line).            *\n*                                                                     *\n***********************************************************************\n block type=subroutine,name=append_line\n*---------------------------------------------------------------------*\n*  Validate the input parameters.\n*---------------------------------------------------------------------*\n   if (clc,pwa_#parms,ne,=f'4')       | If wrong number of parms.\n     msg     (JS00003C,\"APPEND_LINE\",11)    Format a message.\n     errexit code=&js_wrong_number_of_parms\n   endif                              | EndIf.\n*                                     |\n   l    r4,js_prm_al_line             | r4 -> Start of output line.\n   l    r5,js_prm_al_line_len         | r5 -> Line's total length.\n   icm  r5,b'1111',0(r5)              | r5 := Line's total length.\n   if   m,then                        | If negative length, then.\n     msg     (JS00008E)               |   Negative length invalid.\n     errexit code=&js_invalid_parameter\n   elseif (c,r5,gt,=f'80')            | ElseIf too long.\n     msg  (JS00009E)                  |   Line truncated to 80-chars.\n     l    r5,=f'80'                   |   Use only 80 bytes of line.\n   endif                              | EndIf.\n   lr   r6,r4                         | r6 -> Current position.\n   la   r7,70(,r4)                    | r7 -> Scan limit (column 71).\n   if   (c,r5,lt,=f'71')              | If line is shorter than 71.\n     la   r7,0(r5,r4)                 |   r7 -> Past final source char.\n     bctr r7,0                        |   r7 -> Final source position.\n   endif                              | EndIf.\n   stm  r4,r7,al_source               | Save calculated positions.\n*---------------------------------------------------------------------*\n*  Parse the current line to either find a JOB statement or decode one.\n*---------------------------------------------------------------------*\n   rbit pwa_f,pwa_f_jcl_problem       | No problems found yet.\n   mvi  al_line_done,c\"N\"             | Not done with line yet.\n   loop until                         | Loop over the current line.\n     l       r3,al_state              |   r3 := parsing state.\n     caseblk reg=r3,wreg=r1,mult=1    |   Case on State.\n     case &al_s_new                   |   Start of a new JCL statement.\n       callsub classify_JCL_statement |\n     case &al_s_job_stmt              |   New JOB statement.\n       callsub start_of_job           |\n     case &al_s_dd_stmt               |   New DD statement.\n       callsub check_for_instream     |\n     case &al_s_xmit_stmt             |   New JES3 XMIT statement.\n       mvi     al_dd_type,c\"D\"        |     Use \"DD DATA\" rules.\n       callsub scan_dd_parms          |\n     case &al_s_jes2xmit_stmt         |   New /*XMIT statement.\n       callsub scan_jes2xmit_parms    |\n     case &al_s_null_stmt             |   Job terminator statement.\n       callsub end_of_job             |\n     case &al_s_job_parms             |   In parameters field of JOB.\n       callsub scan_job_parms         |\n     case &al_s_job_insert            |   At end of JOB parameters.\n       callsub insert_job_parms       |\n     case &al_s_job_comments          |   Comments field of JOB stmt.\n       callsub Scan_jcl_Comments      |\n       if (treg,r15,z)                |     If out of comments.\n         callsub add_jes2_control     |       At jes2 insert point.\n       endif                          |     EndIf.\n     case &al_s_dd_parms              |   In parameters field of DD.\n       callsub scan_dd_parms          |\n     case &al_s_dd_comments           |   Comments field of DD stmt.\n       callsub scan_jcl_comments      |\n       if (treg,r15,z)                |     If out of comments.\n         mvc al_state,=f'&al_s_instream'      In instream data set.\n       endif                          |     EndIf.\n     case &al_s_instream              |   Scan instream data lines.\n       callsub scan_instream          |\n     endcase                          |   EndCase.\n   endloop until,(cli,al_line_done,eq,c\"Y\")\n   errexit (tbit,pwa_f,pwa_f_jcl_problem),code=&js_jcl_problem\n endblk block=append_line\n eject\n***********************************************************************\n*                                                                     *\n* Subroutine: Classify_JCL_Statement,(Type)                           *\n* Abstract  : Scan the new output line to determine if it begins one  *\n*             of the statement types we are interested in.  If it     *\n*             doesn't, the statement type will be set to unknown. The *\n*             following statement types are recognized:               *\n*                                                                     *\n*             1) JOB statement.                                       *\n*             2) DD statement.                                        *\n*             3) JOB terminator.                                      *\n*             4) /*XMIT JES2 statement (instream data follows)        *\n*                                                                     *\n*             After a statement has been recognized, the current      *\n*             source pointer will be updated to the start of the      *\n*             first parameter on the line, if there is one.  If not,  *\n*             the source position will point to column 72 (which may  *\n*             contain a continuation character) or the end of the     *\n*             line, whichever comes first.                            *\n*                                                                     *\n***********************************************************************\n block type=subroutine,name=Classify_JCL_Statement\n   lm r4,r7,al_source                   | Get Start/Length/Current/End.\n*---------------------------------------------------------------------*\n*  Check for \"/*XMIT\" first.\n*---------------------------------------------------------------------*\n   if (c,r5,ge,=f'6'),and,(clc,=c\"/*XMIT\",eq,0(r4))   If /*XMIT stmt.\n     mvc   al_state,=f'&al_s_jes2xmit_stmt' Set statement type.\n     la    r6,6(,r4)                    |   r6 -> past \"/*XMIT\".\n     st    r6,al_current                |   Update Current position.\n     leave block=*                      |   Return to caller.\n   endif                                | EndIf.\n*---------------------------------------------------------------------*\n*  Make sure the line begins with \"//\", signifying a normal JCL line.\n*---------------------------------------------------------------------*\n   if (c,r5,lt,=f'2'),or,(clc,=c\"//\",ne,0(r4)) If not \"//\" then.\n     callsub append_jcl,((r4),al_length)\n     mvi     al_line_done,c\"Y\"          |   Done with this line.\n     leave   block=*                    |   Return to caller.\n   endif                                | EndIf.\n   la    r6,2(,r4)                      | Point past the \"//\".\n*---------------------------------------------------------------------*\n*  If a JCL comment \"//*\", mark line as done and return.\n*---------------------------------------------------------------------*\n   if (c,r5,ge,=f'3'),and,(cli,0(r6),eq,c\"*\")  If \"//*\", then.\n     callsub append_jcl,((r4),al_length)\n     mvi     al_line_done,c\"Y\"          |   Done with this line.\n     leave   block=*                    |   Return to caller.\n   endif                                | EndIf.\n   eject\n*---------------------------------------------------------------------*\n*  Scan up to the \"operation\" field of \"//label operation\".\n*---------------------------------------------------------------------*\n   lr   r1,r6                           | r1 -> start of \"label\" field.\n   loop while,(cr,r6,le,r7)             | Scan for first blank.\n     leave loop=*,(cli,0(r6),eq,c\" \")   |   Leave when found.\n     la      r6,1(,r6)                  |   Advance to next char.\n   endloop while                        | EndLoop.\n   lr   r2,r6                           | r2 -> first blank.\n*                                       |\n   loop while,(cr,r6,le,r7)             | Scan for \"operation\" field.\n     leave loop=*,(cli,0(r6),ne,c\" \")   |   Leave when found.\n     la    r6,1(,r6)                    |   Advance to next char.\n   endloop while                        | EndLoop.\n*---------------------------------------------------------------------*\n*  If all blanks follow the first \"//\", the line is a Null JCL stmt.\n*---------------------------------------------------------------------*\n   if (cr,r2,eq,r1),and,(cr,r6,gt,r7)   | If all blanks after \"//\".\n     mvc   al_state,=f'&al_s_null_stmt' |   Set type to terminator.\n     st    r6,al_current                |   Update Current position.\n     leave block=*                      |   Return to caller.\n   endif                                | EndIf.\n*---------------------------------------------------------------------*\n*  Classify as either a \"JOB\" or \"DD\" statement, or unknown.\n*---------------------------------------------------------------------*\n   lr    r3,r6                          | r3 -> start of \"operation\".\n   loop  while,(cr,r3,le,r7)            | Scan for next blank.\n     leave loop=*,(cli,0(r3),eq,c\" \")   |   Leave when found.\n     la    r3,1(,r3)                    |   Advance to next char.\n   endloop while                        | EndLoop.\n   sr      r3,r6                        | r3 := length of \"operation\".\n*                                       |\n   if (c,r3,eq,=f'3'),and,(clc,=c\"JOB\",eq,0(r6))\n     mvc  al_state,=f'&al_s_job_stmt'   |   JOB statement.\n   elseif (c,r3,eq,=f'2'),and,(clc,=c\"DD\",eq,0(r6))\n     mvc  al_state,=f'&al_s_dd_stmt'    |   DD statement.\n   elseif (c,r3,eq,=f'4'),and,(clc,=c\"XMIT\",eq,0(r6))\n     mvc  al_state,=f'&al_s_xmit_stmt'  |   JES3 XMIT statement.\n   else                                 | Else....unknown operation.\n     callsub append_jcl,((r4),al_length)\n     mvi     al_line_done,c\"Y\"          |   Done with this line.\n     leave   block=*                    |   Unknown statement type.\n   endif                                | EndIf.\n*                                       |\n   la   r6,0(r3,r6)                     | r6 -> past \"operation\".\n   st   r6,al_current                   | Update Current position.\n endblk block=Classify_JCL_Statement\n               eject\n***********************************************************************\n*                                                                     *\n* Subroutine: Start_of_Job                                            *\n* Abstract  : Bump JOB count and get the new job's name.              *\n*                                                                     *\n***********************************************************************\n block type=subroutine,name=Start_of_Job\n   l    r1,al_line_type                 | r1 -> line type flag.\n   mvi  0(r1),js_f_job_start            | 1st line of a JOB statement.\n   lm   r4,r7,al_source                 | Get Start/Length/Current/End.\n   l    r0,al_job_count                 |\n   a    r0,=f'1'                        | Add 1 to # job stmts.\n   st   r0,al_job_count                 |\n   mvc  al_prev_comma,=f'0'             | No parm-breaks found yet.\n   mvc  al_prev_blanks,=f'0'            | No squeezable-blanks found.\n*---------------------------------------------------------------------*\n*  Scan the label part of \"//label JOB\" to obtain the JOB name.\n*---------------------------------------------------------------------*\n   la   r1,2(,r4)                       | r1 -> Start of jobname.\n   lr   r3,r1                           | r3 -> Start of Jobname.\n   loop while,(cr,r3,le,r7)             | Loop over jobname field.\n     leave loop=*,(cli,0(r3),eq,c\" \")   |   Done when blank found.\n     la    r3,1(,r3)                    |   Advance to next char.\n   endloop while                        | EndLoop.\n   lr  r2,r3                            | r2 -> first blank.\n   sr  r2,r1                            | r2 := length of jobname.\n   mvc al_job_name,psd_blanks           | Set jobname to blanks.\n   st  r2,al_job_name_length            | Save name's *real* length.\n   if  (treg,r2,p)                      | If non-null jobname.\n     if (cl,r2,gt,=f'8')                |   If too long.\n       la  r2,8                         |     Use 1st eight chars.\n     endif                              |   EndIf.\n     bctr r2,0                          |  Subtract 1 for EX instr.\n     exi  r2,(mvc,al_job_name(0),0(r1))    Set current JOB's name.\n   endif                                | EndIf.\n*---------------------------------------------------------------------*\n*  Locate the first parameter on the JOB statement, if any.\n*---------------------------------------------------------------------*\n   slr  r6,r3                           | Get length from blanks.\n   if   (cl,r6,ge,=f'5')                | If >=2 blanks before \"JOB\".\n     st r3,al_prev_blanks               |   Save this location.\n     lr r3,r6                           |   Remember # blanks (+3).\n   endif                                | EndIf.\n   l    r6,al_current                   | r6 -> past \"JOB\".\n   loop while,(cr,r6,le,r7)             | Loop for a non-blank.\n     leave loop=*,(cli,0(r6),ne,c\" \")   |   Done when one found.\n     la    r6,1(,r6)                    |   Advance one character.\n   endloop while                        | EndLoop.\n   if (cr,r6,le,r7)                     | If a parameter is present.\n     lr r3,r6                           |   r3 -> non-blank or end.\n     sl r3,al_current                   |   r3 := #blanks after \"JOB\".\n     if (cl,r3,ge,=f'2')                |   If >= 2 blanks after \"JOB\"\n       mvc al_prev_blanks,al_current    |     Save this location.\n     endif                              |   EndIf.\n     st  r6,al_current                  |   Update current position.\n     mvc al_state,=f'&al_s_job_parms'   |   In parameters of JOB stmt.\n   else                                 | Else, no parameters on line.\n     if  (cl,r3,le,=f'5')               |   If <=2 blanks before.\n       mvc al_prev_blanks,=f'0'         |     Can't squeeze 2 blanks.\n     endif                              |   EndIf.\n     l   r2,al_current                  |   r2 -> past \"JOB\".\n     la  r2,1(,r2)                      |   r2 -> past \"JOB \".\n*                                       |      -> col73 if \"JOB\" @ 69.\n     st  r2,al_current                  |   Update current position.\n     mvc al_state,=f'&al_s_job_insert'  |   At insertion point.\n   endif                                | EndIf.\n endblk block=Start_of_Job\n eject\n***********************************************************************\n*                                                                     *\n* Subroutine: End_of_Job                                              *\n* Abstract  : Reset the current jobname to blanks.                    *\n*                                                                     *\n***********************************************************************\n block type=subroutine,name=End_of_Job\n   callsub append_jcl,(*al_start,al_length,jls_f_job_end)\n   mvi     al_line_done,c\"Y\"            | Done with this line.\n   mvc     al_job_name,psd_blanks       | Set jobname to blanks.\n   mvc     al_state,=f'&al_s_new'       | Go back to Start state.\n endblk block=End_of_Job\n eject\n***********************************************************************\n*                                                                     *\n* Subroutine: Scan_Job_Parms                                          *\n* Abstract  : Scan from the current source position in a JOB          *\n*             statement for the end of the (positional and keyword)   *\n*             parameters field.  If the end is not found on the       *\n*             current line, the line will be appended to the job      *\n*             stream, al_line_done will be set to \"Y\" and the value   *\n*             of al_state will be left unchanged.   If found, the     *\n*             current position will be updated to point to the column *\n*             immediately following the final parameter.              *\n*                                                                     *\n***********************************************************************\n block type=subroutine,name=Scan_Job_Parms\n   lm r4,r7,al_source                   | Get Start/Length/Current/End.\n*---------------------------------------------------------------------*\n*  If a continuation of a previous line, advance past the \"// \" that\n*  should start this line.  If this line is not a legal continuation\n*  of the previous line, issue a message and proceed without JOB stmt\n*  modification.\n*---------------------------------------------------------------------*\n   if (cr,r6,eq,r4)                     | If Current = Start.\n     if (c,r5,ge,=f'3')                 |   If line is long enough.\n       if (clc,=c\"// \",eq,0(r6))        |    If it is a continuation.\n         la   r1,3(,r6)                 |      r1 -> past \"// \".\n         loop while,(cr,r1,le,r7)       |      Scan for a non-blank.\n           leave loop=*,(cli,0(r1),ne,c\" \")      Done when found.\n           la    r1,1(,r1)              |        Advance to next char.\n         endloop while                  |      EndLoop.\n         sr   r1,r4                     |      r1 := offset to char.\n         if   (c,r1,le,=f'15')          |      If not past column 16.\n           la r6,0(r1,r4)               |        r6 -> 1st non-blank.\n         endif                          |      EndIf.\n       endif                            |    EndIf.\n     endif                              |  EndIf.\n*                                       |\n     if (cr,r6,eq,r4)                   |  If still at start of line.\n       sbit  pwa_f,pwa_f_jcl_problem    |     Bad JCL statement.\n       msg     (js00010e)               |     Continuation not received\n       callsub add_jes2_control         |     Insert JES2 stmt(s) and\n       leave   block=*                  |     return to next state.\n     else                               |  Else.\n       mvc al_prev_comma,=f'0'          |    No ',' found yet.\n       lr  r1,r6                        |    r1 -> 1st non-blank.\n       slr r1,r4                        |    r1 := offset to parm.\n       if  (cl,r1,eq,=f'3')             |    If column 4 (only 1 blank)\n         mvc al_prev_blanks,=f'0'       |      No squeezable blanks.\n       else                             |    Else, can squeeze if need.\n         la r1,2(,r4)                   |      r1 -> Column 3.\n         st r1,al_prev_blanks           |      Squeezable blanks.\n       endif                            |    EndIf.\n     endif                              |  EndIf.\n   endif                                | EndIf.\n   eject\n*---------------------------------------------------------------------*\n*  Locate the next blank that is not within a quoted string.\n*---------------------------------------------------------------------*\n   loop while,(cr,r6,le,r7)             | Loop over rest of line.\n     leave loop=*,(cli,0(r6),eq,c\" \")   |   Done when blank found.\n     if (cli,0(r6),eq,c\",\")             |   If between parms.\n       st r6,al_prev_comma              |     Remember where it is.\n     elseif (cli,0(r6),eq,c\"''\")        |   ElseIf quotation mark.\n       loop until                       |     Loop over quoted string.\n         la r6,1(,r6)                   |       Advance to next char.\n         if (cr,r6,gt,r7)               |       If string never closed.\n           callsub append_jcl,(*al_start,al_length,                    +\n               jls_f_job_stmt)\n           mvi   al_line_done,c\"Y\"      |         Done w/this line.\n           sbit  pwa_f,pwa_f_jcl_problem          Bad JCL statement.\n           msg   (js00011e)             |         End-quote missing.\n           callsub add_jes2_control     |         Add JES2 stmt(s).\n           leave block=*                |         Continue processing.\n         endif                          |       EndIf.\n       endloop until,(cli,0(r6),eq,c\"''\")     EndLoop.\n     endif                              |   EndIf.\n     la  r6,1(,r6)                      |   Advance to next char.\n   endloop while                        | EndLoop\n*---------------------------------------------------------------------*\n*  Determine if the end of the parameters have been found.\n*---------------------------------------------------------------------*\n   bctr r6,0                            | r6 -> Last non-blank char.\n   if   (cli,0(r6),eq,c\",\")             | If parms continued.\n     callsub append_jcl,(*al_start,al_length,jls_f_job_stmt)\n     mvi     al_line_done,c\"Y\"          |   Return for next line.\n   else                                 | Else.\n     la  r6,1(,r6)                      |   r6 -> Column for insert.\n     st  r6,al_current                  |   Update current position.\n     mvc al_state,=f'&al_s_job_insert'  |   At insertion point.\n   endif                                | EndIf.\n endblk block=Scan_Job_Parms\n eject\n***********************************************************************\n*                                                                     *\n* Subroutine: Insert_Job_Parms                                        *\n* Abstract  : Implement options that require parameters to be added   *\n*             to the JOB statement.                                   *\n* Entry     : The current line contains the final JOB stmt parameter. *\n*                                                                     *\n***********************************************************************\n block type=subroutine,name=Insert_Job_Parms\n   if (cli,pwa_typrun,eq,c\" \")          | If nothing to insert.\n     mvc   al_state,=f'&al_s_job_comments'  Move to comments-state.\n     leave block=*                      |   Return immediately.\n   endif                                | EndIf.\n   lm      r4,r7,al_source              | Get Start/Length/Current/End.\n*---------------------------------------------------------------------*\n*  Create a copy of the JOB statement line in working storage.\n*---------------------------------------------------------------------*\n   mvi al_char72,c\" \"                   | Assume no continuation.\n   if  (c,r5,ge,=f'72')                 | If line >= 72 chars long.\n     mvc al_char72,71(r4)               |  Copy char @ col 72.\n   endif                                | EndIf.\n   la r3,1(,r6)                         | r3 -> Position for \",\" +1.\n   sr r3,r4                             | r3 := Column# for \",\".\n   la r0,pwa_work                       | r0 -> Buffer for copy.\n   lr r1,r5                             | r1 := line's length.\n   if (cr,r1,lt,r3)                     | If length < column#.\n     if (c,r3,gt,=f'71')                |   If special-case col#.\n       la  r1,71                        |     r1 := desired length.\n     else                               |   Else.\n       lr r1,r3                         |     r1 := desired length.\n     endif                              |   EndIf.\n   endif                                | EndIf.\n   st   r1,pwa_work_len                 | Save new line's length.\n   icm  r1,b'1000',psd_blanks           | Pad copy with blanks.\n   mvcl r0,r4                           | Copy line & pad w/blanks.\n   eject\n*---------------------------------------------------------------------*\n*  Add a continuation comma to line, splitting at last parm if needed.\n*---------------------------------------------------------------------*\n   if (c,r3,le,=f'71')                  | If room to add a comma.\n     la      r3,pwa_work-1(r3)          |   r3 -> place for \",\".\n     mvi     0(r3),c\",\"                 |   Add continuation-comma.\n     callsub append_jcl,(pwa_work,pwa_work_len,<jobstmt>)\n   elseif (clc,al_prev_blanks,ne,=f'0') | ElseIf squeezable blanks.\n     l    r14,al_prev_blanks            |   r14->first of blanks.\n     sl   r14,al_start                  |   r14:=offset to blanks.\n     la   r14,pwa_work+1(r14)           |   r14->start of blanks.\n     if   (c,r3,eq,=f'73')              |   If \"JOB\" is in col 69.\n       la   r15,pwa_work+68             |     r15:= length to move\n       slr  r15,r14                     |     minus 1 for EXI.\n       exi  r15,(mvc,0(0,r14),2(r14))   |     Squeeze 2 blanks.\n       mvc  pwa_work+69(2),=c\" ,\"       |     \"JOB ,\" in col 67.\n     else                               |   Else.\n       la  r15,pwa_work+69              |     r15:= length to move\n       slr r15,r14                      |     minus 1 for EXI.\n       exi r15,(mvc,0(0,r14),1(r14))    |     Squeeze out 1 blank.\n       la  r3,pwa_work-2(r3)            |     r3 -> place for \",\".\n       mvi 0(r3),c\",\"                   |     Add continuation.\n     endif                              |   EndIf.\n     callsub append_jcl,(pwa_work,pwa_work_len,<jobstmt>)\n   elseif (clc,al_prev_comma,ne,=f'0')  | ElseIf break-point known.\n     l       r14,al_prev_comma          |   r14->\",\" between parms.\n     sl      r14,al_start               |   r14:=offset to \",\".\n     la      r14,pwa_work+1(r14)        |   r14->copy of parm.\n     la      r15,pwa_work+71            |   r15->column 72.\n     slr     r15,r14                    |   r15:=length to move.\n     st      r15,pwa_parameter_length   |   Save as parm's len.\n     bctr    r15,0                      |   Subtract 1 for EXIs.\n     exi     r15,(mvc,pwa_parameter(0),0(r14)) Copy parameter.\n     bctr    r15,0                      |   Subtract 1 for EXIs.\n     mvi     0(r14),c\" \"                |   Fill in old copy of\n     exi     r15,(mvc,1(0,r14),0(r14))  |   parameter with blanks.\n     callsub append_jcl,(pwa_work,pwa_work_len,<jobstmt>)\n     mvc     pwa_work_len,=f'72'        |   Inserting 72-byte line.\n     fill    pwa_work,c\" \",length=72    |   Set new line to:\n     mvc     pwa_work(2),=c\"//\"         |   \"//\"      in column 1.\n     la      r14,pwa_work+3             |   r14 -> place for parm.\n     l       r15,pwa_parameter_length   |   r15 := length to move.\n     la      r0,pwa_parameter           |   r0  -> saved parm.\n     lr      r1,r15                     |   r1  := length t0 move.\n     mvcl    r14,r0                     |   Copy saved parameter.\n     mvi     0(r14),c\",\"                |   Mark as continued.\n     mvc     pwa_work+71(1),al_char72   |   Continuation-char 72.\n     callsub append_jcl,(pwa_work,pwa_work_len,<jobstmt>)\n   else                                 | Else.\n     mvc     al_state,=f'&al_s_job_comments'  Give up.\n     sbit    pwa_f_jcl_problem          |     Note we had problem.\n     msg     (js00012e)                 |     Cut a message.\n     leave   block=*                    |   Return immediately.\n   endif                                | EndIf.\n   eject\n*---------------------------------------------------------------------*\n*  Continue the JOB statement with the additional parameter(s).\n*---------------------------------------------------------------------*\n   mvc  pwa_work_len,=f'72'             | Inserting 72-byte line.\n   fill pwa_work,c\" \",length=72         | Set new line to:\n   mvc  pwa_work(2),=c\"//\"              |   \"//\"      in column 1.\n   mvc  pwa_work+5(7),=c\"TYPRUN=\"       |   \"TYPRUN=\"           6.\n   if   (cli,pwa_typrun,eq,c\"H\")        | If TYPRUN=HOLD.\n     mvc pwa_work+12(4),=c\"HOLD\"        |   \"HOLD\"             13.\n   elseif (cli,pwa_typrun,eq,c\"S\")      | ElseIf TYPERUN=SCAN.\n     mvc pwa_work+12(4),=c\"SCAN\"        |   \"SCAN\"             13.\n   else                                 | Else.\n     msg     (js00000c)                 |   Cut a message.\n     errexit code=&js_internal_error    |   Internal error.\n   endif                                | EndIf.\n   mvc  pwa_work+63(8),=c\"**XSUB**\"     |   \"**XSUB**\"         64.\n   mvc  pwa_work+71(1),al_char72        |   Continuation-char  72.\n   callsub append_jcl,(pwa_work,pwa_work_len,<jobstmt>)\n*---------------------------------------------------------------------*\n*  All parameter(s) inserted, move on to the next state.\n*---------------------------------------------------------------------*\n   mvi al_line_done,c'y'                | Done with this line.\n   if  (cli,al_char72,ne,c' ')          | If comments are continued.\n     mvc al_state,=f'&al_s_job_comments'   Comments-state in next line.\n   else                                 | Else.\n     callsub add_jes2_control           |  Add JES2 control stmt(s).\n   endif                                | EndIf.\n endblk block=Insert_Job_Parms\n eject\n***********************************************************************\n*                                                                     *\n* Subroutine: Scan_JCL_Comments                                       *\n* Abstract  : Scan over the comments field of the current JCL stmt.   *\n* Returns   : r15=0 if past comments.  r15=8 if still in comments.    *\n*                                                                     *\n***********************************************************************\n block type=subroutine,name=Scan_JCL_Comments\n   lm r4,r7,al_source                   | Get Start/Length/Current/End.\n*---------------------------------------------------------------------*\n*  If a continuation of a previous line, advance past the \"// \" that\n*  should start this line.  If this line is not a legal continuation\n*  of the previous line, treat it as if it were a new statement.\n*---------------------------------------------------------------------*\n   if (cr,r6,eq,r4)                     | If Current = Start.\n     if (c,r5,ge,=f'3')                 |   If line is long enough.\n       if (clc,=c\"// \",eq,0(r6))        |    If it is a continuation.\n         la  r6,3(,r6)                  |      r6 -> past the \"// \".\n       endif                            |    EndIf.\n     endif                              |  EndIf.\n     if (cr,r6,eq,r4)                   |  If still at start of line.\n       la    r15,0                      |    Out of comments.\n       leave block=*                    |    Return to caller.\n     endif                              |  EndIf.\n   endif                                | EndIf.\n*---------------------------------------------------------------------*\n*  If column-72 is non-blank, still in comments on next line.\n*---------------------------------------------------------------------*\n   callsub append_jcl,(pwa_work,pwa_work_len)\n   mvi     al_line_done,c\"Y\"            | Done with this line.\n   if (c,r5,ge,=f'72'),and,(cli,71(r4),ne,c\" \") If column 72 \u00acblank.\n     mvc   al_char72,71(r4)             |   Copy that character.\n     la    r15,8                        |   Still in comments.\n   else                                 | Else.\n     la    r15,0                        |   Out of comments.\n   endif                                | EndIf.\n endblk block=Scan_JCL_Comments\n eject\n***********************************************************************\n*                                                                     *\n* Subroutine: Add_Jes2_Control                                        *\n* Abstract  : Add JES2 control statements to the job stream.          *\n*             This routine is invoked after all lines of a JOB stmt   *\n*             have been added to the jobstream, but before any        *\n*             processing on a subsequent statement can begin.         *\n*                                                                     *\n***********************************************************************\n block type=subroutine,name=Add_JES2_Control\n*---------------------------------------------------------------------*\n*  Check JES2 options and insert appropriate /*JOBPARM statements.\n*---------------------------------------------------------------------*\n   if (cli,pwa_hold,eq,c\"Y\")              | If /HOLD specified.\n     mvc     pwa_work(l'&s.jobparm),&s.jobparm\n     mvc     pwa_work+10(3),=c\"Q=H\"\n     mvc     pwa_work_len,=a(l'&s.jobparm)\n     callsub append_jcl,(pwa_work,pwa_work_len)\n   endif                                  | EndIf.\n*\n   if (cli,pwa_inform,eq,c\"Y\")            | If /INFORM specified.\n     mvc     pwa_work(l'&s.jobparm),&s.jobparm\n     mvc     pwa_work+10(1),=c\"I\"\n     mvc     pwa_work_len,=a(l'&s.jobparm)\n     callsub append_jcl,(pwa_work,pwa_work_len)\n   endif                                  | EndIf.\n*\n   if (cli,pwa_reroute,eq,c\"Y\")           | If /REROUTE specified.\n     mvc     pwa_work(l'&s.jobparm),&s.jobparm\n     mvc     pwa_work+10(3),=c\"Q=R\"\n     mvc     pwa_work_len,=a(l'&s.jobparm)\n     callsub append_jcl,(pwa_work,pwa_work_len)\n   endif                                  | EndIf.\n*\n   mvc  al_state,=f'&al_s_new'  <--- Start processing current line.\n endblk block=Add_JES2_Control\n*---------------------------------------------------------------------*\n* Patterns for JES2 control statements to be inserted.\n*---------------------------------------------------------------------*\n            ssd\n&s.jobparm  dc     cl72\"/*JOBPARM\"\n            org    &s.jobparm+63\n            dc     c\"**XSUB**\"        <--- ends in column 71.\n            org\n            endssd\n            eject\n***********************************************************************\n*                                                                     *\n* Subroutine: Check_For_Instream                                      *\n* Abstract  : Examine the current DD statement to see if it defines   *\n*             an instream data set.                                   *\n*                                                                     *\n***********************************************************************\n block type=subroutine,name=Check_For_Instream\n   lm   r4,r7,al_source                 | Get Start/Length/Current/End.\n*---------------------------------------------------------------------*\n*  Locate the first parameter on the DD statement, if any.\n*---------------------------------------------------------------------*\n   loop while,(cr,r6,le,r7)             | Loop for a non-blank.\n     leave loop=*,(cli,0(r6),ne,c\" \")   |   Done when one found.\n     la    r6,1(,r6)                    |   Advance one character.\n   endloop while                        | EndLoop.\n*                                       |\n   if (cr,r6,gt,r7)                     | If no parameter is present.\n     callsub append_jcl,((r4),al_length)    Add line to jobstream.\n     mvi     al_line_done,c\"Y\"          |   Done with this line.\n     mvc     al_state,=f'&al_s_new'     |   Back to normal processing.\n     leave   block=*                    |   Return to caller.\n   endif                                | EndIf.\n*---------------------------------------------------------------------*\n*  See if the parameter is \"*\" or \"DATA\", defining an instream dataset.\n*---------------------------------------------------------------------*\n   if  (cli,0(r6),eq,c\"*\")              | If \"DD *\" statement.\n     la  r6,1(,r6)                      |   r6 -> past \"*\" parameter.\n     mvi al_dd_type,c\"*\"                |   In a \"DD *\" statement.\n   else                                 | Else, check for \"DD DATA\".\n     la r1,1(,r7)                       |   r1 -> 1 past last position.\n     sr r1,r6                           |   r1 := remaining length.\n     if (c,r1,ge,=f'4'),and,(clc,=c\"DATA\",eq,0(r6))\n       la  r6,4(,r6)                    |     r6 -> past \"DATA\" parm.\n       mvi al_dd_type,c\"D\"              |     In a \"DD *\" statement.\n     else                               |   Else.\n       callsub append_jcl,((r4),al_length)    Add line to jobstream.\n       mvi     al_line_done,c\"Y\"        |     Done with this line.\n       mvc     al_state,=f'&al_s_new'   |     Back to normal state.\n       leave   block=*                  |     Return to caller.\n     endif                              |   EndIf.\n   endif                                | EndIf.\n*---------------------------------------------------------------------*\n*  See if the parameter is \"*\" or \"DATA\", defining an instream dataset.\n*---------------------------------------------------------------------*\n   st  r6,al_current                    | Update current position.\n   mvc al_dlm,psd_blanks                | No DLM= recognized yet.\n   mvc al_state,=f'&al_s_dd_parms'      | Scan for DLM= keyword.\n endblk block=Check_For_Instream\n eject\n***********************************************************************\n*                                                                     *\n* Subroutine: Scan_DD_Parms   (Also used for Scan_XMIT_Parms)         *\n* Abstract  : Scan from the current source position in a DD or XMIT   *\n*             JCL statement looking for the DLM=xx keyword.  If       *\n*             found, save the specified delimiter and continue        *\n*             scanning until the end of the parameters have been      *\n*             located.                                                *\n* Note      : Because we are following the same syntax rules and      *\n*             looking for the same parameter in both the DD and XMIT  *\n*             statements, the code simply processes an XMIT statement *\n*             from this point on as if it were a DD statement.        *\n*                                                                     *\n***********************************************************************\n block type=subroutine,name=Scan_DD_Parms\n   lm r4,r7,al_source                   | Get Start/Length/Current/End.\n*---------------------------------------------------------------------*\n*  If a continuation of a previous line, advance past the \"// \" that\n*  should start this line.  If this line is not a legal continuation\n*  of the previous line, just proceed as if we were within the instream\n*  data set.\n*---------------------------------------------------------------------*\n   if (cr,r6,eq,r4)                     | If Current = Start.\n     if (c,r5,ge,=f'3')                 |   If line is long enough.\n       if (clc,=c\"// \",eq,0(r6))        |    If it is a continuation.\n         la   r1,3(,r6)                 |      r1 -> past \"// \".\n         loop while,(cr,r1,le,r7)       |      Scan for a non-blank.\n           leave loop=*,(cli,0(r1),ne,c\" \")      Done when found.\n           la    r1,1(,r1)              |        Advance to next char.\n         endloop while                  |      EndLoop.\n         sr   r1,r4                     |      r1 := offset to char.\n         if   (c,r1,le,=f'15')          |      If not past column 16.\n           la r6,0(r1,r4)               |        r6 -> 1st non-blank.\n         endif                          |      EndIf.\n       endif                            |    EndIf.\n     endif                              |  EndIf.\n*                                       |\n     if (cr,r6,eq,r4)                   |  If still at start of line.\n       mvc   al_state,=f'&al_s_instream'     1st line of instream data.\n       leave block=*                    |    Return to process it.\n     endif                              |  EndIf.\n   endif                                | EndIf.\n*---------------------------------------------------------------------*\n*  Locate the next blank that is not within a quoted string, looking\n*  for DLM=xx during the scan.\n*---------------------------------------------------------------------*\n   loop while,(cr,r6,le,r7)             | Loop over rest of line.\n     leave loop=*,(cli,0(r6),eq,c\" \")   |   Done when blank found.\n     if    (cli,0(r6),eq,c\"''\")         |   If quotation mark.\n       loop until                       |     Loop over quoted string.\n         la    r6,1(,r6)                |       Advance to next char.\n         leave loop=*,(cr,r6,gt,r7)     |       If string never closed.\n       endloop until,(cli,0(r6),eq,c\"''\")     EndLoop.\n     elseif (clc,al_dlm,eq,psd_blanks) |    Elseif no DLM found yet.\n       la r1,1(,r7)                     |     r1 -> past scan area.\n       sr r1,r6                         |     r1 := remaining length.\n       if (c,r1,ge,=f'6')               |     If enough for DLM=xx.\n         if (clc,=c\"DLM=\",eq,0(r6))     |       If at \"DLM=\".\n           mvc  al_dlm,4(r6)            |         Save xx DLM value.\n         endif                          |       EndIf.\n       endif                            |     EndIf.\n     endif                              |   EndIf.\n     la  r6,1(,r6)                      |   Advance to next char.\n   endloop while                        | EndLoop\n*---------------------------------------------------------------------*\n*  Determine if the end of the parameters have been found.\n*---------------------------------------------------------------------*\n   bctr r6,0                            | r6 -> Last non-blank char.\n   if   (cli,0(r6),eq,c\",\")             | If parms continued.\n     callsub append_jcl,((r4),al_length)    Add line to jobstream.\n     mvi     al_line_done,c\"Y\"          |   Done with this line.\n   else                                 | Else.\n     la  r6,1(,r6)                      |   r6 -> Column for insert.\n     st  r6,al_current                  |   Update current position.\n     mvc al_state,=f'&al_s_dd_comments' |   In DD comments field.\n   endif                                | EndIf.\n endblk block=Scan_DD_Parms\n eject\n***********************************************************************\n*                                                                     *\n* Subroutine: Scan_jes2XMIT_parms                                     *\n* Abstract  : Scan from the current source position in a /*XMIT stmt  *\n*             looking for the DLM=xx keyword.  If found, save the     *\n*             specified delimiter and continue scanning until the     *\n*             end of the parameters have been located.                *\n* Note      : The manual says not to continue /*XMIT statements. For  *\n*             consistency with the rest of this program, any illegally*\n*             continued lines are considered part of the instream     *\n*             data set.  In other words, the code does not check for  *\n*             continuations at all - any continuation is illegal.     *\n*                                                                     *\n***********************************************************************\n block type=subroutine,name=Scan_JES2XMIT_parms\n   lm r4,r7,al_source                   | Get Start/Length/Current/End.\n*---------------------------------------------------------------------*\n*  Locate the first parameter following node-specification.\n*---------------------------------------------------------------------*\n   loop while,(cr,r6,le,r7)             | Loop over rest of line.\n     leave loop=*,(cli,0(r6),ne,c\" \")   |   Done when nonblank found.\n     la    r6,1(,r6)                    |   Advance to next char.\n   endloop while                        | EndLoop.\n   loop while,(cr,r6,le,r7)             | Loop over node-specification.\n     leave loop=*,(cli,0(r6),eq,c\" \")   |   Done when blank found.\n     la    r6,1(,r6)                    |   Advance to next char.\n   endloop while                        | EndLoop.\n   loop while,(cr,r6,le,r7)             | Loop over rest of line.\n     leave loop=*,(cli,0(r6),ne,c\" \")   |   Done when nonblank found.\n     la    r6,1(,r6)                    |   Advance to next char.\n   endloop while                        | EndLoop.\n*---------------------------------------------------------------------*\n*  Determine the instream end-of-data delimiter.\n*---------------------------------------------------------------------*\n   la r1,1(,r7)                         | r1 -> past scan area.\n   sr r1,r6                             | r1 := remaining length.\n   if (c,r1,ge,=f'6')                   | If enough for DLM=xx.\n     if (clc,=c\"DLM=\",eq,0(r6))         |   If at \"DLM=\".\n       mvc  al_dlm,4(r6)                |     Save xx DLM value.\n     endif                              |   EndIf.\n   endif                                | EndIf.\n   mvi     al_dd_type,c\"D\"              | Always use \"DD DATA\" rules.\n   callsub append_jcl,((r4),al_length)    Add line to jobstream.\n   mvi     al_line_done,c\"Y\"            | Done: no continuation allowed\n   mvc     al_state,=f'&al_s_instream'  | Now in instream data set.\n endblk block=Scan_JES2XMIT_Parms\n eject\n***********************************************************************\n*                                                                     *\n* Subroutine: Scan_Instream                                           *\n* Abstract  : Scan instream data for a data-terminator line.          *\n* Note      : While the rules for locating the data-delimiter are     *\n*             commented as being for \"DD\" statement instream data     *\n*             sets, they also apply for \"/*XMIT\" statements.          *\n*                                                                     *\n***********************************************************************\n block type=subroutine,name=Scan_Instream\n   lm r4,r7,al_source                   | Get Start/Length/Current/End.\n*---------------------------------------------------------------------*\n*  Check for the end of the instream data set:\n*    1) Any \"//\" JCL line will terminate a \"DD *\" data set.\n*    2) The two-character delimiter specified on DLM=xx.\n*    3) \"/*\" in the input stream if no DLM=xx was specified.\n*---------------------------------------------------------------------*\n   if (c,r5,ge,=f'2')                   | If two-chars or longer.\n     if (cli,al_dd_type,eq,c\"*\")        |   If \"DD *\" instream data.\n       if (clc,=c\"//\",eq,0(r4))         |     If any JCL statement.\n         mvc   al_state,=f'&al_s_new'   |       Data terminated.\n         leave block=*                  |       Return immediately.\n       endif                            |     EndIf.\n     endif                              |   EndIf.\n     if (clc,al_dlm,ne,psd_blanks)      |   If DLM=xx in effect.\n       if (clc,al_dlm,eq,0(r4))         |     If line has delimiter.\n         mvc   al_state,=f'&al_s_new'   |       Data terminated.\n       endif                            |     EndIf.\n     elseif (clc,=c\"/*\",eq,0(r4))       |   ElseIf starts with \"/*\".\n       if (c,r5,lt,=f'3'),or,(cli,2(r4),eq,c\" \") If terminator.\n         mvc al_state,=f'&al_s_new'     |       Data terminated.\n       endif                            |     EndIf.\n     endif                              |   EndIf.\n   endif                                | EndIf.\n*---------------------------------------------------------------------*\n*  Done with the current line...go back for the next one.\n*---------------------------------------------------------------------*\n   callsub append_jcl,((r4),al_length)  | Add line to jobstream.\n   mvi     al_line_done,c\"Y\"            | Done with this line.\n endblk block=Scan_Instream\n                eject\n***********************************************************************\n*                                                                     *\n* Subroutine: append_jcl,(Line,Length{,Flag})                         *\n* Abstract  : Add a new line to the jobstream being built.            *\n*                                                                     *\n***********************************************************************\n block type=subroutine,name=append_jcl\n   lm  r4,r5,0(r1)                     | r4 -> Text, r5 -> Length.\n   l   r5,0(,r5)                       | r5 := length of line.\n   slr r6,r6                           | r6 := Flag byte to use.\n   if  (tbit,4(r1),x'80',off)          | If Flag parameter specified.\n     l  r15,8(,r1)                     |   r15 -> Flag byte to use.\n     l8 r6,0(r15)                      |   r6 := Flag byte to use.\n   endif                               | EndIf.\n*---------------------------------------------------------------------*\n*  Make sure the current STG block has enough space to hold the line.\n*---------------------------------------------------------------------*\n   l     r8,pwa_stg_current            | r8 -> Current stg block.\n   using stg,r8                        | Establish addressability.\n   la    r3,jsl_l(,r5)                 | r3 := amount of stg needed.\n   if    (c,r3,gt,stg_free)            | If more than we have in STG.\n     es_obtain_storage id=es,          |   Obtain a new STG block and  +\n               size=psd_stg_incr,      |   link it to the end of the   +\n               address=stg_link        |   STG chain.\n     if (not,(%es_success))            |   If unable to obtain.\n       sth     r15,pwa_rc              |     Save RC in PWA.\n       msg     (JS00001S)              |     Format error message.\n       errexit code=&js_environment_support_error\n     endif                             |   EndIf.\n     mvc  pwa_stg_current,stg_link     |   Switch current to new block.\n     l    r8,stg_link                  |   r8 -> New STG block.\n     mvc  stg_link,=f'0'               |   Force link to null.\n     mvc  stg_size,psd_stg_incr        |   Remember amount allocated.\n     l    r0,stg_size                  |   r0 := total size of stg.\n     s    r0,=a(stg_l)                 |   r0 := size of stg_area.\n     st   r0,stg_free                  |   Save remaining # bytes free.\n   endif                               | EndIf.\n*---------------------------------------------------------------------*\n*  Add the new line to the end of the jobstream.\n*---------------------------------------------------------------------*\n   la      r14,stg+stg_l               | r14 -> past end of STG.\n   sl      r14,stg_free                | r14 -> next free byte in STG.\n   using   jsl,r14                     | Establish addressability.\n   stc     r6,jsl_flags                | Set line's flag byte value.\n   stc     r5,jsl_length               | Save length of line.\n   bctr    r5,0                        | Subtract 1 for EXI instr.\n   exi     r5,(mvc,jsl_text(0),0(r4))  | Copy line to end of jobstream.\n   l       r1,stg_free                 | r1 := remaining free bytes.\n   la      r5,jsl_l+1(,r5)             | r5 := # bytes used for line.\n   slr     r1,r5                       | Adjust remaining bytes.\n   st      r1,stg_free                 | Save adjusted value.\n endblk block=append_jcl\n eject\n*---------------------------------------------------------------------*\n*                                                                     *\n* Subroutine: Submit_Jobstream                                        *\n*                                                                     *\n*---------------------------------------------------------------------*\n block type=subroutine,name=Submit_Jobstream\n*---------------------------------------------------------------------*\n*  If no JOB statements in jobstream, issue an error message.\n*---------------------------------------------------------------------*\n   if (clc,al_job_count,eq,=f'0')     | If no job statements present.\n     msg     (js00013e)               |   Issue a message.\n     errexit code=&js_jcl_problem     |   Indicate we had a problem.\n   endif                              | Endif.\n*---------------------------------------------------------------------*\n*  Write entire jobstream to an internal reader.\n*---------------------------------------------------------------------*\n*  callsub  open_reader               |\n*  loop through jobstream lines.\n*    callsub write_line_to_reader\n*  endloop\n*  callsub  close_reader\n endblk block=Submit_Jobstream\n eject\n***********************************************************************\n*                                                                     *\n* Subroutine: Save_To_File                                            *\n* Abstract  : Write the entire jobstream to a file.                   *\n*                                                                     *\n***********************************************************************\n block type=subroutine,name=save_to_file\n endblk block=save_to_file\n eject\n***********************************************************************\n*                                                                     *\n* Subroutine: Message,(msg_tag,arg1,...)                              *\n* Abstract  : Format a message and update the feedback area.          *\n*                                                                     *\n***********************************************************************\n block type=subroutine,name=message\n*---------------------------------------------------------------------*\n*  Use the supplied parameters to set up for an ST_FORMAT call.\n*---------------------------------------------------------------------*\n   lr  r3,r1                          | r3 -> Parameter list.\n   l   r4,0(,r3)                      | r4 -> A(Message to issue).\n   l   r4,0(,r4)                      | r4 -> Message to issue.\n   l8  r1,0(r4)                       | r1 := message length.\n   sth r1,&w.length                   | Save for later.\n   st  r1,&w.length                   | Save as fullword also.\n   l8  r1,1(r4)                       | r1 := reason-code.\n   st  r1,js_fb_reason                | Save reason-code in feedback.\n   mvi &w.formatted,c'n'              | Set msg-formatted flag...\n   if  (clc,pwa_stepa,ne,=f'0'),and,  | If String Handler loaded, and  +\n               (clc,pwa_sttkn,ne,=f'0'),and,  String Handler started,  +\n               (tbit,0(r3),x'80',off) |       and arguments to format.\n     la  r1,4(,r3)                    |   r1 -> 1st argument.\n     loop while,(tbit,0(r1),X'80',off)    Loop over argument list.\n       la r1,4(,r1)                   |     r1 -> next argument.\n     endloop while                    |   EndLoop.\n     slr     r1,r4                    |   r1 := length of arg-list.\n     srl     r1,2                     |   r1 := number of arguments.\n     st      r1,&w.count              |   Save for ST_FORMAT.\n     es_clear_debug_info id=es,action=inhibit\n     st_format id=st,control=2(r4),sourcelist=(4(r3),&w.count),        +\n               string=js_fb_msgtext,resultlen=js_fb_msglen\n     if        (%st_success)          |   If successful format.\n       mvi     &w.formatted,c'Y'      |     Set formatted-flag.\n     else                             |   Else.\n       sth                r15,&w.rc   |     Save bad return-code.\n       es_save_debug_info id=es,text=(2(r4),&w.length4),label=\"MESSAGE\"\n       es_save_debug_info id=es,hex=(&w.rc,l'&w.rc),label=\"RETCODE\"\n       es_save_debug_info id=es,text=\"ST_FORMAT failed while attempting+\n                to format a message: return code follows.\"\n     endif                            |   EndIf.\n     es_clear_debug_info id=es,action=enable\n   endif                              | EndIf.\n*                                     |\n   if (cli,&w.formatted,eq,c'N')      | If format not called or failed.\n     la   r0,js_fb_msgtext            |   r0 -> mvcl destination.\n     la   r1,l'js_fb_msgtext          |   r1 := length of destination.\n     la   r14,2(,r4)                  |   r14 -> mvcl source.\n     lh   r15,&w.length               |   r15 := length of source.\n     icm  r15,b'1000',=c' '           |   Pad destination w/blanks.\n     mvcl r0,r14                      |   Copy message w/o formatting.\n     mvc  js_fb_msglen,&w.length      |   Copy message length.\n   endif                              | EndIf.\n*\n endblk block=message\n*---------------------------------------------------------------------*\n* Working storage for formatting messages.\n*---------------------------------------------------------------------*\n            swa\n&w.count    ds  f                | Number of source arguments.\n&w.length4  ds  f                | Length of control string (msg).\n&w.length   ds  h                | Length of control string (msg).\n&w.rc       ds  h                | Returncode from ST_FORMAT.\n            endswa\n eject\n***********************************************************************\n*                                                                     *\n*  Error exit for all functions.                                      *\n*                                                                     *\n***********************************************************************\n block type=errexit\n*\n*  Save module/offset, registers, and return-code.\n*\n   stm   r0,r15,pwa_gdiregs      | save registers at time of error.\n   la    r0,4(,r12)              | point to module identification.\n   st    r0,pwa_gdimodid         | save in general debug area.\n   mvc   pwa_gdirc,0(r14)        | copy return code.\n   slr   r14,r12                 | calculate offset at time of error.\n   sth   r14,pwa_gdioffst        | save in debug area.\n   es_save_debug_info id=es,gdi=pwa_gdi\n   lh    r15,pwa_gdirc           | r15 := return-code for this call.\n endblk\n eject\n***********************************************************************\n*                                                                     *\n*  Copy-Error exit.                                                   *\n*                                                                     *\n***********************************************************************\n block type=errexit,name=copy_exit\n*\n*  Save module/offset, registers, and return-code.\n*\n   stm   r0,r15,pwa_gdiregs      | save registers at time of error.\n   la    r0,4(,r12)              | point to module identification.\n   st    r0,pwa_gdimodid         | save in general debug area.\n   mvc   pwa_gdirc,0(r14)        | copy return code.\n   slr   r14,r12                 | calculate offset at time of error.\n   sth   r14,pwa_gdioffst        | save in debug area.\n   es_save_debug_info id=es,gdi=pwa_gdi\n   lh    r15,pwa_gdirc           | r15 := return-code for this call.\n endblk\n eject\n*---------------------------------------------------------------------*\n*\n*  static data\n*\n*---------------------------------------------------------------------*\n           psd\n           ltorg\npsd_stg_incr  dc f'32768'      | Enough for about 400 80-byte lines.\npsd_blanks dc   cl16\" \"        | For compares and captialization.\n*---------------------------------------------------------------------*\n* Messages are made up of a message identifier followed by a control\n* string.  The message identifier has the format\n*\n*   JSnnnnns\n*\n* where the characters JS always begin a Jobstream Handler's message,\n* nnnnn is the unique message number, and s indicates the message's\n* severity.\n*\n* Severity                  Meaning\n* --------   ---------------------------------------------\n*    I       Informational.\n*    W       Warning message.\n*    E       An error occurred, but execution can continue.\n*    S       Severe error.  Execution cannot continue.\n*    X       Filename syntactically invalid.\n*    C       Critical error.  Indicates a probable programming error.\n*\n*---------------------------------------------------------------------*\n            macro\n            dm    &msgid,&text\n            lclc  &oldloc,&reason\n&reason     setc  '&msgid'(3,5)\n&oldloc     setc  '&sysloc'\n&msgid      dc    a(msgt&sysndx)\nmsgs        loctr ,\nmsgt&sysndx dc    al1(msgl&sysndx.,&reason),c'&msgid',c' ',c&text\nmsgl&sysndx equ   *-msgt&sysndx-2\n&oldloc     loctr ,\n            mend\n*\n  dm JS00000C,\"Unknown or internal error.\"\n  dm JS00001C,\"Unable to load the String Handler.\"\n  dm JS00002C,\"Unable to start the String Handler.\"\n  dm JS00003C,\"Wrong number of parameters for the {CL?} function.\"\n  dm JS00004C,\"Invalid function-code parameter: {I}.\"\n  dm JS00005E,\"Option {CL?} is unknown.\"\n  dm JS00006E,\"Invalid value supplied for option {CL?}.\"\n  dm JS00007E,\"Options {CL?} and {CL?} are mutually exclusive.\"\n  dm JS00008E,\"Negative line length invalid for APPEND_LINE function.\"\n  dm JS00009E,\"Line truncated to 80 characters.\"\n  dm JS00010E,\"Illegal JOB statement: expected continuation not receive+\n               d.\"\n  dm JS00011E,\"Illegal JOB statement: ending quote not found.\"\n  dm JS00012E,\"Unable to append parameters to this JOB statement.\"\n  dm JS00013E,\"The JCL being submitted does not contain any JOB stateme+\n               nts.  Check for possible JCL errors.\"\n  dm JS00014S,\"Not enough storage to operate.\"\n*\n*\n           endpsd\n           eject\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Program Work Area                                                  *\n*                                                                     *\n*---------------------------------------------------------------------*\n                     pwa\npwa_#parms           ds  f           | Number of parms passed in.\n                     org &ppl.       | Overlay program parameter list.\n                     js_parmlist dsect=no\n                     org ,           | Back to normal offsets.\npwa_es_epa           ds  a           | Environment Support EPA.\npwa_es_token         ds  f           | Environment Support TOKEN.\npwa_st_epa           ds  a           | String Handler EPA.\npwa_st_token         ds  f           | String Handler TOKEN.\npwa_stg_anchor       ds  a           | Addr of 1st stg block.\npwa_stg_current      ds  a           | Addr of current stg block.\npwa_rc               ds  h           | Saved return-code from s.p.\n*                                    | Option values:\npwa_hold             ds  c           |   /*JOBPARM Q=H  (\"Y\" or \"N\").\npwa_inform           ds  c           |   /*JOBPARM I    (\"Y\" or \"N\").\npwa_reroute          ds  c           |   /*JOBPARM Q=R  (\"Y\" or \"N\").\npwa_typrun           ds  c           |   Typrun =       (\" \"|\"H\"|\"S\").\n*\n* Miscellaneous working storage.\n*\npwa_work_len         ds  f           | Length of pwa_work's contents.\npwa_work             ds  cl256       | Changed/inserted line.\npwa_parameter        ds  cl72        | Saved parm from JOB statement.\npwa_parameter_length ds  f           | Length of saved parameter.\n*                                    |\npwa_line#            ds  f           | Current line number.\npwa_line_len         ds  f           | Length of current input line.\npwa_line             ds  cl80        | Text of output line.\npwa_s99error         ds  h           | Dynalloc's error-code.\npwa_ddname           ds  cl8         | DDNAME of internal reader.\npwa_jobid            ds  cl8         | Job identifier.\npwa_f                ds  x           | State information.\npwa_f_allocated      equ b'10000000' |   Internal reader allocated.\npwa_f_acb            equ b'01000000' |   ACB successfully built.\npwa_f_opened         equ b'00100000' |   File successfully opened.\npwa_f_rpl            equ b'00010000' |   RPL successfully built.\npwa_f_in_error       equ b'00001000' |   Halted due to an error.\npwa_f_truncated      equ b'00000100' |   Output line truncated.\npwa_f_in_progress    equ b'00000010' |   Jobstream not ENDREQed yet.\npwa_f_jcl_problem    equ b'00000001' |   Problem found in JCL stmt.\n*\n* The following fields describe static storage used for parsing lines.\n*\nal_job_name          ds  cl8         | Current JOB's name.\nal_job_name_length   ds  f           | Length of jobname.\nal_job_count         ds  f           | Count of JOBs in jobstream.\nal_line_done         ds  c           | Done with this line (Y or N).\nal_line_type         ds  b           | Current line's type.\nal_state             ds  f           | Current parsing state.\nal_source            equ *           | Source-position variables:\nal_start             ds  a           |   Start of line.\nal_length            ds  f           |   Length of source area.\nal_current           ds  a           |   Current character.\nal_end               ds  a           |   Past end of source area.\nal_insert_state      ds  f           | Parameters added to JOB stmt.\nal_char72            ds  c           | Character in column 72.\nal_dlm               ds  cl2         | Value of DLM=xx parameter.\nal_dd_type           ds  c           | Instream data \"*\" or \"D\".\nal_prev_comma        ds  a           | -> to ',' between parameters.\nal_prev_blanks       ds  a           | -> to squeezable blanks.\n*\n* Control blocks and parmlists for Internal Reader use.\n*\npwa_acb              acb ,           |   Access Control Block.\npwa_acb_l            equ *-pwa_acb   |   Length of access control block\n                     ds  0f          |   Align to a fullword boundary.\npwa_acbpl            ds  cl(pwa_acbal_l) Used by GENCB BLK=ACB.\n*                                    |\npwa_rpl              rpl am=vsam     |   Request Parameter Block.\npwa_ral_l            equ *-pwa_rpl   |   Length of request parm block.\n                     ds  0f          |   Align to a fullword boundary.\npwa_rplpl            ds  cl(pwa_rplal_l) Used by GENCB BLK=RPL.\n*\n* Error tracking and debugging information.\n*\n                     js_feedback dsect=no\n                     es_gdi      dsect=no,prefix=pwa_gdi\n                     endpwa\n                     eject\n*---------------------------------------------------------------------*\n* Storage block for holding jobstream lines.                          *\n*---------------------------------------------------------------------*\nstg               dsect\nstg_link          ds     a           | Link to next stg block.\nstg_size          ds     f           | Size of stg_area below.\nstg_free          ds     a           | Remaining bytes in stg_area.\nstg_area          ds     0c          | Area for jobstream_line storage.\nstg_l             equ    *-stg       | Length of stg block header info.\n*---------------------------------------------------------------------*\n* Jobstream line (stored w/in stg_area)                               *\n*---------------------------------------------------------------------*\njsl               dsect\njsl_flags         ds     b           | Information about this line.\njsl_f_job_start   equ    b'10000000' |   Line is 1st line of JOB stmt.\njsl_f_job_stmt    equ    b'01000000' |   Line is part of a JOB stmt.\njsl_f_job_end     equ    b'00100000' |   Line is a job-terminator.\njsl_length        ds     x           | Length of jobstream line's text.\njsl_text          ds     0c          | Actual text of jobstream line.\njsl_l             equ    *-jsl       | Length of this dsect.\n                  eject\n           es_esv         ,    |\n*          iefzb4d0       ,    | Dynamic allocation (SVC99) data areas.\n*          iefzb4d2       ,    | Dynamic allocation text unit keys.\n*          ifgrpl    dsect=yes | Request parameter list mapping.\n           end\n//C.SYSPRINT DD SYSOUT=A,OUTPUT=*.LASER4\n//C.SYSLIB DD\n//         DD\n//         DD DSN=SYSTEMS.SRV.SOURCE,DISP=SHR\n//         DD DSN=SYSTEMS.RACF.MACLIB,DISP=SHR\n//         DD DSN=SYS1.MODGEN,DISP=SHR\n//         DD DSN=SYS2.MACLIB,DISP=SHR\n//         DD DSN=SYSTEMS.JES2.SOURCE,DISP=SHR\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SRVJS001": {"ttr": 30729, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x02\\x00\\x00W\\x01\\x11)\\x9f\\x01\\x11)\\x9f\\t'\\x00\\xe6\\x00\\xe6\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@\"", "ispf": {"version": "02.00", "flags": 0, "createdate": "2011-10-26T00:00:00", "modifydate": "2011-10-26T09:27:57", "lines": 230, "newlines": 230, "modlines": 0, "user": "CLEMSON"}, "text": "*---------------------------------------------------------------------*\n*  Copyright 2011 by Clemson University Research Foundation           *\n*                                                                     *\n*  Licensed under the Apache License, Version 2.0 (the \"License\");    *\n*  you may not use this file except in compliance with the License.   *\n*  You may obtain a copy of the License in this library as member     *\n*  $LICENSE, or from                                                  *\n*                                                                     *\n*      http://www.apache.org/licenses/LICENSE-2.0                     *\n*                                                                     *\n*  Unless required by applicable law or agreed to in writing,         *\n*  software distributed under the License is distributed on an \"AS    *\n*  IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either    *\n*  express or implied.  See the License for the specific language     *\n*  governing permissions and limitations under the License.           *\n*---------------------------------------------------------------------*\n eject\n***********************************************************************\n*                                                                     *\n*  Subroutine: OPEN_FILE                                              *\n*  Abstract:   Set up for writing a jobstream to the system.          *\n*                                                                     *\n***********************************************************************\n BLOCK NAME=OPEN_FILE,TYPE=SUBROUTINE,AMODE=31\n*---------------------------------------------------------------------*\n*  Dynamically allocate an internal reader.\n*---------------------------------------------------------------------*\n   LA    R6,O_DDNAME                | R6 -> DDNAME Text Unit.\n   USING S99TUNIT,R6                | Establish addressability.\n   MVC   S99TUKEY,=AL2(DALRTDDN)    |   Set return-ddname action key.\n   MVC   S99TUNUM,=H'1'             |   Set number of parameters = 1.\n   MVC   S99TULNG,=H'8'             |   Set length of return-area.\n*                                   |\n   LA    R7,O_RB                    | R7 -> Dynalloc request block.\n   USING S99RB,R7                   | Establish addressability.\n   FILL  O_RB,X'00'                 |   Clear request block to zeros.\n   MVI   S99RBLN,S99RBEND-S99RB     |   Set request block's length.\n   MVI   S99VERB,S99VRBAL           |   Set verb to 'allocate'.\n   PLIST (O_CLASS,O_PROGRAM,O_FREE,O_DDNAME),VL,PL=O_TXTPTRS\n   ST    R1,S99TXTPP                |   Set address of text unit plist.\n*                                   |\n   PLIST (O_RB),VL                  | R1 -> Request Block plist.\n   DYNALLOC                         | Invoke the DYNALLOC SVC.\n*                                   |\n   IF (TREG,R15,Z),THEN             | If dynamic allocation succeeded.\n     SBIT   PWA_F_ALLOCATED         |   Set allocated flag.\n     FILL   PWA_DDNAME,C' '         |   Blank out DDNAME in the PWA.\n     L16    R15,S99TULNG            |   R15 := length of DDNAME.\n     IF     NZ,THEN                 |   If a non-null DDNAME.\n       BCTR R15,0                   |     Subtract 1 for EX instr.\n       EXI  R15,(MVC,PWA_DDNAME(0),S99TUPAR)  Copy DDNAME to the PWA.\n     ENDIF                          |   EndIf.\n   ELSE                             | Else, check error/reason codes.\n     MVC PWA_S99ERROR,S99ERROR      | Remember the dynalloc error code.\n     IF  (CLC,S99ERROR,EQ,=X'0204') | If Storage not available.\n       CALLSUB MESSAGE,(JS00009)    |   Issue specific message.\n     ELSEIF (CLC,S99ERROR,EQ,=X'0214') ElseIf No internal reader avail.\n       CALLSUB MESSAGE,(JS00003)    |   Issue specific message.\n     ELSEIF (CLC,S99ERROR,EQ,=X'0238') ElseIf TIOT is full.\n       CALLSUB MESSAGE,(JS00020)    |   Issue specific message.\n     ELSEIF (CLC,S99ERROR,EQ,=X'0470') ElseIf NOJCL userid.\n       CALLSUB MESSAGE,(JS00019)    |   Issue specific message.\n     ELSE                           | Else.\n       CALLSUB MESSAGE,(JS00004,S99ERROR,S99INFO) Generic message.  @C2\n     ENDIF                          | EndIf.\n     DROP    R6,R7                  | Drop O_RB and Text Unit.\n   ENDIF                            | EndIf.\n*---------------------------------------------------------------------*\n* Build an Access Control Block (ACB).\n*---------------------------------------------------------------------*\n   BLOCK AMODE=24,TYPE=INLINE       | Switch to amode 24.\n     GENCB  BLK=ACB,DDNAME=(*,PWA_DDNAME),MF=(G,PWA_ACBPL,PWA_ACBal_L),+\n               MACRF=(ADR,SEQ,OUT),WAREA=(S,PWA_ACB),LENGTH=PWA_ACB_L\n     ST     R15,PWA_RC              |  Save return-code.\n   ENDBLK                           | Switch back to amode 31.\n*                                   |\n   IF (CLC,PWA_RC,NE,=F'0')         | If ACB generation failed, then.\n     CALLSUB MESSAGE,(JS00005,PWA_RC)   Issue an error message.\n   ELSE                             | Else.\n     SBIT    PWA_F_ACB              |   Mark ACB as valid.\n   ENDIF                            | EndIf.\n*---------------------------------------------------------------------*\n* Open the internal reader.\n*---------------------------------------------------------------------*\n   PLIST  (PWA_ACB),VL              | R1 -> 1 entry paramter list.\n   BLOCK AMODE=24,TYPE=INLINE       | Switch to amode 24.\n     OPEN   MF=(E,(1))              |   Open the internal reader.\n     ST     R15,PWA_RC              |   Save return-code.\n   ENDBLK                           | Switch back to amode 31.\n*                                   |\n   IF (CLC,PWA_RC,NE,=F'0')         | If OPEN failed, then.\n     ST      R15,PWA_RC             |   Save bad return-code.\n     CALLSUB MESSAGE,(JS00006,PWA_RC)   Issue an error message.\n   ELSE                             | Else.\n     SBIT    PWA_F_OPENED           |   Mark file as OPEN.\n   ENDIF                            | EndIf.\n*---------------------------------------------------------------------*\n* Build the Request Parameter List (RPL).\n*---------------------------------------------------------------------*\n   BLOCK AMODE=24,TYPE=INLINE       | Switch to amode 24.\n     GENCB  BLK=RPL,WAREA=(S,PWA_RPL),LENGTH=PWA_Ral_L,                +\n               ACB=(S,PWA_ACB),OPTCD=(ADR,SEQ,SYN,NUP),                +\n               AREA=(S,PWA_LINE),RECLEN=L'PWA_LINE,                    +\n               MSGAREA=(S,PWA_MSG),MSGLEN=L'PWA_MSG,                   +\n               MF=(G,PWA_RPLPL,PWA_RPLal_L)\n     ST     R15,PWA_RC              |   Save return-code.\n   ENDBLK                           | Switch back to amode 31.\n*                                   |\n   IF (CLC,PWA_RC,NE,=F'0')         | If RPL generation failed, then.\n     CALLSUB MESSAGE,(JS00008,PWA_RC)   Issue an error message.\n   ELSE                             | Else.\n     SBIT    PWA_F_RPL              |   Mark RPL as valid.\n   ENDIF                            | EndIf.\n*                                   |\n   MVC  pwa_job_sequence#,=F'1'     | Processing first JOB in stream.\n   MVC  PWA_JOBID,=CL8'*NULL*'      | No job identifier assigned.\n ENDBLK BLOCK=OPEN_FILE\n*---------------------------------------------------------------------*\n*  Static data for opening a new jobstream file.\n*---------------------------------------------------------------------*\n             SSD\nO_CLASS      DC   AL2(DALSYSOU,1,1),C'A'        | SYSOUT=(A,...\nO_PROGRAM    DC   AL2(DALSPGNM,1,6),C'INTRDR'   |        ...INTRDR)\nO_FREE       DC   AL2(DALCLOSE,0)               | FREE=CLOSE\n             ENDSSD\n*---------------------------------------------------------------------*\n*  Working Storage for opening a new jobstream file.\n*---------------------------------------------------------------------*\n             SWA\nO_RB         DS  CL(S99RBEND-S99RB)  | Dynalloc request block.\nO_TXTPTRS    DS  CL(4*4)             | Parmlist for Text Unit Pointers.\nO_DDNAME     DS  CL14                | TextUnit for returned DDNAME.\n             ENDSWA\n EJECT\n***********************************************************************\n*                                                                     *\n*  SUBROUTINE: WRITELINE                                              *\n*  ABSTRACT:   Write the next line to the opened jobstream.           *\n*                                                                     *\n***********************************************************************\n BLOCK NAME=WRITELINE,TYPE=SUBROUTINE,AMODE=31\n*---------------------------------------------------------------------*\n*  Validate the current file status and the parameter list.\n*---------------------------------------------------------------------*\n   IF (TBIT,PWA_F_OPENED,OFF)       | If file is not opened.\n     MESSAGE (JS00012,'WRITELINE',9)    Issue an error message.\n   ELSEIF (TBIT,PWA_F_RPL,OFF)      | ElseIf RPL not built.\n     MESSAGE (JS00012,'WRITELINE',9)    Issue an error message.\n   ELSEIF (CLI,&PWA.MODE,NE,&FI_OC_OUTPUT)\n     MESSAGE (JS00013)\n   ENDIF                            | EndIf.\n*                                   |\n   SBIT PWA_F_IN_PROGRESS           | A non-ended job is in progress.\n   MVC  PWA_JOBID,=CL8'*NULL*'      | No job identifier assigned.\n*---------------------------------------------------------------------*\n*  Copy the output line to the RPL line-buffer.\n*---------------------------------------------------------------------*\n   LM   R0,R1,FI_WL_LINE            | R0 -> Text, R1 -> length.\n   L    R1,0(,R1)                   | R1 := length.\n   LA   R14,PWA_LINE                | R14 -> Output line area.\n   LA   R15,L'PWA_LINE              | R15 := Length of area.\n   ICM  R1,B'1000',=C' '            | Pad copy with blanks.\n   RBIT PWA_F_TRUNCATED             | Nothing truncated yet.\n   MVCL R14,R0                      | Copy output line to area.\n   IF   CC4,THEN                    | If it was truncated, then.\n     SBIT    PWA_F_TRUNCATED        |   Remember line truncated.\n   ENDIF                            | EndIf.\n*---------------------------------------------------------------------*\n*  Write the line to the internal reader and, if truncated, issue msg.\n*---------------------------------------------------------------------*\n   BLOCK AMODE=24,TYPE=INLINE       | Switch to amode 24.\n     PUT RPL=PWA_RPL                |   Write the new jobstream line.\n     ST  R15,PWA_RC                 |   Save return code.\n   ENDBLK                           | Switch back to amode 31.\n*                                   |\n   IF (CLC,PWA_RC,NE,=F'0')         | If write failed, then.\n     ST      R15,PWA_RC             |   Save bad return code.\n     CALLSUB MESSAGE,(JS00017,PWA_RC)   Issue an error message.\n   ENDIF                            | EndIf.\n*                                   |\n   IF (TBIT,PWA_F_TRUNCATED)        | If line was truncated, then.\n     CALLSUB MESSAGE,(JS00201,80)   |   Issue a warning message.\n   ENDIF                            | EndIf.\n ENDBLK BLOCK=WRITELINE\n EJECT\n***********************************************************************\n*                                                                     *\n*  SUBROUTINE: SET_STATUS                                             *\n*  ABSTRACT:   Set some item of the file's status.                    *\n*                                                                     *\n***********************************************************************\n BLOCK TYPE=SUBROUTINE,NAME=SET_STATUS\n   L       R2,FI_SS_FUNCTION         | R2 -> Status code to set.\n   L       R1,0(,R2)                 | R1 := Status code.\n   CASEBLK REG=R1,MULT=1             | Case on status code.\n     CASE &FI_SS_END_OF_FILE         |   Set end-of-file status.\n       CALLSUB ISSUE_ENDREQ          |     Tell JES about it.\n       IF (CLC,PWA_JOBID,NE,=CL8'*NULL*')  If a job submitted.\n         CALLSUB MESSAGE,(JS00200,PWA_JOBID) Issue submitted message.\n       ENDIF                         |     EndIf.\n     CASE OTHER                      |   Invalid status sub-code.\n       CALLSUB MESSAGE,(JS00018,0(R2))     Issue an error message.\n   ENDCASE                           | EndCase\n ENDBLK BLOCK=SET_STATUS\n EJECT\n***********************************************************************\n*                                                                     *\n*  SUBROUTINE: ISSUE_ENDREQ                                           *\n*  ABSTRACT:   Write the current line to the internal reader.         *\n*                                                                     *\n***********************************************************************\n BLOCK TYPE=SUBROUTINE,NAME=ISSUE_ENDREQ,AMODE=31\n*---------------------------------------------------------------------*\n*  Issue an ENDREQ to signify to JES that this is the end of the job.\n*---------------------------------------------------------------------*\n   LA     R7,PWA_RPL                 | R7 -> Request Parameter List.\n   USING  IFGRPL,R7                  | Establish addressability.\n*                                    |\n   BLOCK  AMODE=24,TYPE=INLINE       | Switch to amode 24.\n     ENDREQ RPL=(7)                  |   Tell JES this is end-of-job.\n     ST     R15,PWA_RC               |   Save return code.\n   ENDBLK                            | Switch back to amode 31.\n*                                    |\n   RBIT PWA_F_IN_PROGRESS            | No jobs currently in progress.\n   MVC  PWA_JOBID,RPLRBAR            | Copy system-assigned jobid.\n*                                    |\n   L    R1,pwa_job_sequence#         | R1 := number of jobs submitted.\n   A    R1,=F'1'                     | Increment.\n   ST   R1,pwa_job_sequence#         | Save back in the PWA.\n ENDBLK BLOCK=ISSUE_ENDREQ\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SRVJS002": {"ttr": 30980, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x02\\x00\\x00W\\x01\\x11)\\x9f\\x01\\x11)\\x9f\\t'\\x00(\\x00(\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@\"", "ispf": {"version": "02.00", "flags": 0, "createdate": "2011-10-26T00:00:00", "modifydate": "2011-10-26T09:27:57", "lines": 40, "newlines": 40, "modlines": 0, "user": "CLEMSON"}, "text": "*---------------------------------------------------------------------*\n*  Copyright 2011 by Clemson University Research Foundation           *\n*                                                                     *\n*  Licensed under the Apache License, Version 2.0 (the \"License\");    *\n*  you may not use this file except in compliance with the License.   *\n*  You may obtain a copy of the License in this library as member     *\n*  $LICENSE, or from                                                  *\n*                                                                     *\n*      http://www.apache.org/licenses/LICENSE-2.0                     *\n*                                                                     *\n*  Unless required by applicable law or agreed to in writing,         *\n*  software distributed under the License is distributed on an \"AS    *\n*  IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either    *\n*  express or implied.  See the License for the specific language     *\n*  governing permissions and limitations under the License.           *\n*---------------------------------------------------------------------*\n  dm JS00003S,\"No internal readers are available at this time.\"\n  dm JS00004S,\"Unable to allocate to an internal reader: DYNALLOC Error+\n                ({XL2},{XL2}).\"\n  dm JS00005S,\"Unable to build an Access Control Block (ACB) for writin+\n               g to the internal reader. GENCB RC={I}.\"\n  dm JS00006S,\"Unable to open the internal reader for output.\"\n  dm JS00007S,\"File name truncated in GET_NAME function.\"\n  dm JS00008S,\"Unable to build a Request Parameter List (RPL) for writi+\n               ng to the internal reader. GENCB RC={I}.\"\n  dm JS00011C,\"Processing halted due to a previous error.\"\n  dm JS00012S,\"Function {CL?} not performed; file is not open.\"\n  dm JS00013C,\"Sequential input not supported by SRVJSMVS.\"\n  dm JS00014C,\"Unsupported file access mode: {I}.\"\n  dm JS00015C,\"Invalid information code ({I}) for the GET_INFO function+\n               .\"\n  dm JS00016S,\"Function {CL?} not performed; file is not open.\"\n  dm JS00017S,\"Error while writing to internal reader. PUT RC={I}.\"\n  dm JS00018C,\"Invalid information code ({I}) for the SET_STATUS functi+\n               on.\"\n  dm JS00019S,\"Not authorized to submit batch jobs.\"\n  dm JS00020S,\"Dynamic allocation limit exceeded: free one or more files\n               .\"\n  dm JS00200I,\"{CL8 T} submitted.\"\n  dm JS00201W,\"Output record was truncated to 80 characters.\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SRVLEVEL": {"ttr": 30982, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x02\\x00\\x00W\\x01\\x11)\\x9f\\x01\\x11)\\x9f\\t'\\x00\\x18\\x00\\x18\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@\"", "ispf": {"version": "02.00", "flags": 0, "createdate": "2011-10-26T00:00:00", "modifydate": "2011-10-26T09:27:57", "lines": 24, "newlines": 24, "modlines": 0, "user": "CLEMSON"}, "text": "*---------------------------------------------------------------------*\n*  Copyright 2011 by Clemson University Research Foundation           *\n*                                                                     *\n*  Licensed under the Apache License, Version 2.0 (the \"License\");    *\n*  you may not use this file except in compliance with the License.   *\n*  You may obtain a copy of the License in this library as member     *\n*  $LICENSE, or from                                                  *\n*                                                                     *\n*      http://www.apache.org/licenses/LICENSE-2.0                     *\n*                                                                     *\n*  Unless required by applicable law or agreed to in writing,         *\n*  software distributed under the License is distributed on an \"AS    *\n*  IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either    *\n*  express or implied.  See the License for the specific language     *\n*  governing permissions and limitations under the License.           *\n*---------------------------------------------------------------------*\n* SRV LEVEL OF MODULES IN THIS LIBRARY\n&SRV_FMID     SETC   'N/A'\n&SRV_PTF      SETC   'DEVELOP'\n&SRV_COMPID   SETC   'SRV'               COMPONENT ID.\n&SRV_SMP      SETB   0\n&SRV_CLEMSON  SETB   1\n              SPLEVEL SET=6\n              SYSSTATE ARCHLVL=1\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SRVMM": {"ttr": 30984, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x02\\x00\\x00X\\x01\\x11)\\x9f\\x01\\x11)\\x9f\\t'\\x030\\x030\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@\"", "ispf": {"version": "02.00", "flags": 0, "createdate": "2011-10-26T00:00:00", "modifydate": "2011-10-26T09:27:58", "lines": 816, "newlines": 816, "modlines": 0, "user": "CLEMSON"}, "text": "*---------------------------------------------------------------------*\n*  Copyright 2011 by Clemson University Research Foundation           *\n*                                                                     *\n*  Licensed under the Apache License, Version 2.0 (the \"License\");    *\n*  you may not use this file except in compliance with the License.   *\n*  You may obtain a copy of the License in this library as member     *\n*  $LICENSE, or from                                                  *\n*                                                                     *\n*      http://www.apache.org/licenses/LICENSE-2.0                     *\n*                                                                     *\n*  Unless required by applicable law or agreed to in writing,         *\n*  software distributed under the License is distributed on an \"AS    *\n*  IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either    *\n*  express or implied.  See the License for the specific language     *\n*  governing permissions and limitations under the License.           *\n*---------------------------------------------------------------------*\nSRVMM     TITLE 'Memory Service Processor'\n         SRVMOD NAME=SRVMM,DATES='1987, 1990, 1995'\n         gblc  &srv_modname\n*---------------------------------------------------------------------*\n*\n*  Copyright (C) Clemson University Research Foundation 1987, 1990.\n*\n*  Program     SRVMM, Memory Service Processor\n*\n*  Abstract    This processor is designed to make memory allocation\n*              efficient for applications by reducing the number of\n*              system requests needed to allocate and release portions\n*              of storage.  For applications that need to frequently\n*              allocate small items of storage, this can drastically\n*              reduce system overhead.\n*\n*  Parameters:\n*    Two parameters, HeapID and FunctionCode, are required for each\n*    call to the memory manager.  Additional parameters are required\n*    for different FunctionCodes.  The entire parameter list required\n*    for each function is listed below.\n*\n*    START\n*      CALLX SRVMM,(HeapID,&Start,ESV,Increment,Location)\n*\n*    TERMINATE\n*      CALLX SRVMM,(HeapID,&Terminate)\n*\n*    OBTAIN\n*      CALLX SRVMM,(HeapID,&MM_OBTAIN_STORAGE,Bytes,Address)\n*\n*    RELEASE\n*      CALLX SRVMM,(HeapID,&MM_RELEASE_STORAGE,Bytes,Address)\n*\n*    The meaning of each parameter is explained below.\n*\n*    HeapID is a fullword used to uniquely identify the heap of memory\n*      being managed.  It is initialized during the startup function.\n*\n*    FunctionCode is a fullword integer that specifies the function to\n*      be performed.  Symbolic identifiers are provided for each\n*      function and may be accessed by placing a COPY statement for\n*      SRVMMMAC in the assembler program.  These symbols should be\n*      used in place of actual integer values.  The following\n*      FunctionCodes are supported:\n*\n*      &START = 1\n*        Create a new memory heap and assign to it a unique identifier:\n*        HeapID.  In addition to the HeapID and FunctionCode\n*        parameters, the parameter ESV is required and the Increment\n*        parameter is optional.\n*\n*      &TERMINATE = 2\n*        Free all memory associated with the identified memory heap and\n*        destroy the heap, setting HeapID to zeros.\n*\n*      &MM_OBTAIN_STORAGE = 3\n*        Allocate the specified amount of memory, rounded up to the\n*        next eight byte boundary, out of the specified memory heap and\n*        return its address.  In addition to the HeapID and\n*        FunctionCode parameters, Bytes and Address are required.\n*\n*      &MM_RELEASE_STORAGE = 4\n*        Free a specific portion of memory previously allocated within\n*        the specified memory heap.  In addition to the HeapID and\n*        FunctionCode parameters, Bytes and Address are required.\n*\n*      &MM_RESET_HEAP = 5\n*        Free all memory previously allocated within the specified\n*        memory heap, without requiring termination.  This permits\n*        re-use of storage obtained from the system, potentially\n*        reducing the number of system getmains/freemains required.\n*\n*    ESV is a fullword given to the application by the Server Manager\n*      when it was started up.\n*\n*    Increment is an optional parameter specifying, as a fullword\n*      integer, the incremental size of the heap.  When there is not\n*      enough memory in the heap to satisfy an Obtain request, the heap\n*      is increased by the number of bytes requested or HeapIncrement,\n*      whichever is larger.  This parameter defaults to a value of\n*      4096 and can have a maximum value of 16777215 and a minimum\n*      value of 1.  If the parameter is missing or zero, the default\n*      value will be used.\n*\n*    Location is an optional parameter specifying, as a fullword,\n*      where the storage should be allocated: anywhere, or below the\n*      16 Megabyte line.\n*\n*    Bytes is a fullword describing how much memory is to be obtained\n*      or released.  It can have a maximum value of 16777215 and a\n*      minimum value of 1.\n*\n*    Address is returned by the obtain function as the address of the\n*      newly allocated memory and passed to the release function as the\n*      address of the memory to be freed.\n*\n*  Return codes:\n*\n*   &MM_INVALID_FUNCTION\n*      An invalid function was specified.  The memory manager only\n*      supports the functions START, TERMINATE, OBTAIN, and RELEASE.\n*   &MM_INVALID_HEAPID\n*      The HeapID provided does not identify an active heap created by\n*      the START function of the memory processor.\n*   &MM_INVALID_INCREMENT\n*      The heap increment was non-positive or greater than the maximum\n*      allowed.\n*   &MM_INVALID_LOCATION\n*      The specified location value is not one of &ES_LOCATION_ANY or\n*      &ES_LOCATION_BELOW.  The location for memory returned by the\n*      memory manager must be specified as being anywhere or below the\n*      16 megabyte line.  It defaults to above.\n*   &MM_INVALID_SIZE\n*      The number of bytes specified to be obtained or released was\n*      greater than the maximum allowed, or was non-positive.\n*   &MM_INVALID_PARM_COUNT\n*      The number of parameters was incorrect for the specified\n*      function, or the FunctionCode or HeapID was not provided.\n*   &MM_INVALID_ALIGNMENT\n*      Memory being released must be on a doubleword boundary.\n*   &MM_STORAGE_NOT_AVAILABLE\n*      The memory manager was unable to get enough memory from the\n*      system to satisfy the request for storage.\n*   &MM_UNKNOWN_ERROR\n*      An unknown error occurred while attempting to obtain memory\n*      from the system.\n*   &MM_MEMORY_NOT_IN_HEAP\n*      The storage being released is not currently allocated in the\n*      specified memory heap.\n*   &MM_MEMORY_NOT_ALLOCATED\n*      The storage being released is within the specified memory heap,\n*      but is not allocated.\n*   &MM_CORRUPT_STORAGE\n*      The internal data structure used to manage storage has been\n*      corrupted.\n*   &MM_NOT_USEABLE\n*      The memory manager is not useable due to a previous error.  The\n*      previous error may be found in the reason-code.  It should be\n*      shut down by the application.\n*\n*  Program     reentrant, problem key and state, server linkage,\n*  Attributes  non-authorized, amode(any), rmode(any)\n*\n*  Change\n*  History     05/25/87 MJM - New\n*              01/27/89 MJM - Added code to MM_RELEASE_STORAGE to\n*                 insure that FREE_BLOCKs adjacent to the storage being\n*                 freed are also in the same STG_BLOCK as the storage\n*                 being freed.  What was happening was that FREE_BLOCKs\n*                 adjacent in memory but not in the same STG_BLOCK (the\n*                 STG_BLOCKS themselves were adjacent in memory) were\n*                 being merged into a single FREE_BLOCK, which was\n*                 later given away to a MM_OBTAIN_STORAGE request.\n*                 When the request came in to free it again, since the\n*                 storage was not entirely contained in a single\n*                 STG_BLOCK, the RELEASE_STORAGE code detected the\n*                 error and complained.\n*              11/08/89 MJM - Added the MM_RESET_HEAP function.\n*              11/01/02 MJM - Fixed release_storage code that checks\n*                             for adjacent free_blocks: the check to\n*                             make sure two free_blocks were in the\n*                             same stg_block was in error.\n*            2009-09-02 mjm - Fized invalid_size error code.\n*\n*  Method of   o The memory server keeps a list of storage blocks and\n*  Operation     a list of free-storage elements.  Initially, both\n*                lists are empty.  A free-storage element represents\n*                a portion of storage within one of the storage blocks.\n*              o Both lists are maintained with a special header node,\n*                which initially points to itself - representing an\n*                empty list.  The link field of each list element must\n*                be at displacement zero so that it will map properly\n*                over the header node.\n*              o When no free-storage element is large enough to\n*                satisfy an allocation request, a new block of storage\n*                is allocated and chained to front of the storage block\n*                list.  The size of the allocated block is equal to the\n*                increment value or the size of the allocation request,\n*                whichever is larger.  A single free-storage element is\n*                created that is equal to the entire block and added to\n*                the front of the free-storage list.\n*              o When memory is freed, it is first checked to insure\n*                that it lies entirely within one of the storage\n*                blocks.  Then it is turned into a free-storage element\n*                and inserted into the beginning of the list.  No\n*                attempt is made to coalesce adjacent blocks.\n*              o On termination of the memory server, all storage\n*                blocks are freed, along with the PWA and every other\n*                piece of storage.  No storage block is freed before\n*                termination, even if all memory within the block has\n*                been explicitly freed.\n*\n*  Special Notes:\n*  . The memory manager must be kept compact and efficient, with\n*    special attention given to short instruction paths.\n*  . The intended use of the memory manager is for an application to\n*    do lots of obtains for storage and then to terminate the manager\n*    without ever releasing any specific portion of storage.  For this\n*    reason, the code was written to make allocation as efficient as\n*    possible, at the expense of efficiency for releasing specific\n*    portions of memory.\n*  . When an application releases storage, it is quite possible that\n*    one or more of the values pointed to by the parameter list are\n*    contained in the storage being released.  This is perfectly legal.\n*    Any changes made to the RELEASE_STORAGE code should take care to\n*    pick up all needed parameter values before wiping the contents of\n*    the storage being released.\n*\n*  Possible Enhancements\n*  . The current implementation retains all getmained storage until it\n*    its terminated.  If there is a need to do so, a RETAIN parameter\n*    can be added to the start function.  It would default to a value\n*    that means *ALL, but applications could specify that any storage\n*    block that contains no allocated storage should be freed (*NONE)\n*    or that an empty block should be freed only if xxx number of bytes\n*    would still be available after its release.\n*  . The control blocks used to maintain incremental-getmained chunks\n*    are getmained themselves.  This means that every time the heap is\n*    incremented, two getmains are done.  What could be done instead\n*    is to start with a good-sized array of storage control blocks\n*    in the PWA, and getmain overflow arrays as needed.\n*---------------------------------------------------------------------\n EJECT\n   COPY   SRVESMAC                    | Copy service processor symbols.\n   COPY   SRVMMMAC                    | Copy service processor symbols.\n   COPY   SMSYMS                      | Get structured macro syms.\n EJECT\n***********************************************************************\n*\n*  The following macro is for setting and checking the error detection\n*  code of a free_block or stg_block.  If an error is detected, the\n*  error-exit is invoked with the appropriate error code.  The macros\n*  assumes addressability on the free_block or stg_block being\n*  examined.\n*\n***********************************************************************\n         MACRO\n         EDC    &TYPE,&OPER\n         GBLA   &MM_CORRUPT_STORAGE\n         XR     R0,R0                     | R0 := EDC Accumulator.\n         ICM    R0,B'0111',&TYPE._SIZE    | Get the size value.\n         X      R0,&TYPE._LINK            | Exclusive-OR link field.\n         AIF    ('&TYPE' NE 'STG').NOADDR\n         X      R0,&TYPE._ADDR            | Exclusive-OR addr field.\n.NOADDR  ANOP\n         LR     R15,R0                    | R15 := EDC so far.\n         SRL    R15,16                    | Shift upper half down.\n         XR     R0,R15                    | XOR with real EDC.\n         LR     R15,R0                    | R15 := EDC so far.\n         SRL    R15,8                     | Shift last byte down.\n         XR     R0,R15                    | XOR with real EDC.\n         AIF    ('&OPER' EQ 'SET').SET\n         AIF    ('&OPER' EQ 'CHECK').CHK\n         MNOTE  8,'Invalid EDC operation'\n         MEXIT\n.SET     STC    R0,&TYPE._EDC             | Move the result to the EDC.\n         MEXIT\n.CHK     ERREXIT (CLM,R0,1,NE,&TYPE._EDC),CODE=&MM_CORRUPT_STORAGE\n         MEND\n EJECT\n***********************************************************************\n*\n*  Main program code.\n*\n***********************************************************************\n BLOCK NAME=&srv_modname,TYPE=PROGRAM,AMODE=31,RMODE=ANY,              +\n               OPTIONS=(*SRVPRC,NOCLEARPWA),R1SAVE=R11,SUBOPTS=*SWA\n   USING PARMLIST,R11                 | Establish addressability.\n*                                     |\n   ERREXIT (TBIT,PRM_HEAPID,X'80'),CODE=&MM_INVALID_PARM_COUNT\n   L     R1,PRM_FUNCTIONCODE          | Load the function code into\n   L     R1,0(,R1)                    |   a register for testing.\n*---------------------------------------------------------------------*\n*  If the function code is something other than start, make sure that\n*  the PWA contains the eye-catcher string and the correct value for\n*  HeapID.  If not, then the HeapID passed in is garbage.  Also check\n*  to see if the Heap is useable -- it may have been messed up due to\n*  a previous error.\n*---------------------------------------------------------------------*\n   IF (C,R1,NE,=F'&START'),THEN       | If not startup function then\n     ERREXIT ((CLC,PWA_VISUAL,NE,EYECATCHER),OR,(C,R13,NE,PWA_HEAPID)),+\n               CODE=&MM_INVALID_HEAPID\n     IF (C,R1,NE,=F'&TERMINATE'),THEN |   If not Terminate either then\n       ERREXIT (NOT,(TBIT,PWA_F_USEABLE)),CODE=&MM_NOT_USEABLE\n     ENDIF                            |   Endif.\n   ENDIF                              | Endif.\n*                                     |\n   CASEBLK REG=R1                     |\n   EJECT\n***********************************************************************\n*                                                                     *\n*    Start a new memory heap.                                         *\n*                                                                     *\n***********************************************************************\n     CASE &START\n*---------------------------------------------------------------------*\n*       Set the eyecatcher and the heapid fields.  These are checked\n*       each time the memory server is entered to avoid integrity\n*       problems.\n*---------------------------------------------------------------------*\n        MVC  PWA_VISUAL,EYECATCHER    | Both the eyecatcher and the\n        ST   R13,PWA_HEAPID           | HeapID are for validity checks.\n*---------------------------------------------------------------------*\n*       Initialize the storage block and free-storage block lists.\n*---------------------------------------------------------------------*\n        LA   R1,PWA_STG_HDR           | Initialize the list header\n        ST   R1,PWA_STG_HDR           | by pointing it to itself.\n        ST   R1,PWA_STG               |\n        LA   R1,PWA_FREE_HDR          | Initialize the list header\n        ST   R1,PWA_FREE_HDR          | by pointing it to itself.\n        ST   R1,PWA_FREE              |\n*---------------------------------------------------------------------*\n*       If the heap increment parameter is present, use it instead of\n*       the default.  If it is invalid, the error exit is invoked, but\n*       the memory manager is still in a useable state.\n*---------------------------------------------------------------------*\n        MVC PWA_INCREMENT,DFLT_INCREMENT | Set the minimum block size.\n        IF  (NOT,(TBIT,PRM_ESV,X'80'))   | If increment parm present.\n          L  R1,PRM_INCREMENT            |   R1 -> increment value.\n          LA R1,0(,R1)                   |   Clear high-order bit.\n          IF (TREG,R1,NZ)                |   If parameter not missing.\n            L  R1,0(,R1)                 |     R1 := Heap increment.\n            ERREXIT ((TREG,R1,M),OR,(C,R1,GT,MAX_INCREMENT)),          +\n               CODE=&MM_INVALID_INCREMENT\n            IF (TREG,R1,NZ)              |     If not zero.\n              ST   R1,PWA_INCREMENT      |       Save increment size.\n            ENDIF                        |     EndIf.\n          ENDIF                          |   EndIf.\n        ENDIF                            | EndIf\n*---------------------------------------------------------------------*\n*       If the increment is an even-multiple of a page, use page-\n*       boundary for storage-block allocations.  Otherwise, use\n*       doubleword boundaries.\n*---------------------------------------------------------------------*\n        LA R2,&ES_DOUBLEWORD_BOUNDARY    | Default boundary.\n        XR R0,R0                         | Clear for division instr.\n        L  R1,PWA_INCREMENT              | R0 := remainder of increment\n        D  R0,=A(&MM_PAGE_SIZE)          |       divided by page-size.\n        IF (TREG,R0,Z),THEN              | If an even page-multiple.\n          LA R2,&ES_PAGE_BOUNDARY        |   Use page alignment.\n        ENDIF                            | EndIf.\n        ST  R2,PWA_BOUNDARY              | Save selected boundary.\n*---------------------------------------------------------------------*\n*       If the location parameter is present, use it instead of the\n*       default.\n*---------------------------------------------------------------------*\n        LA R2,&ES_LOCATION_ANY           | Set the default location.\n        IF (NOT,((TBIT,PRM_ESV,X'80'),OR,(TBIT,PRM_INCREMENT,X'80')))\n          L  R1,PRM_LOCATION             |   R1 -> location value.\n          LA R1,0(,R1)                   |   Clear high-order bit.\n          IF ((TREG,R1,NZ),AND,(CLC,=F'0',NE,0(R1)))\n            ICM R2,15,0(R1)              |     Use instead of default\n          ENDIF                          |   EndIf.\n        ENDIF                            | EndIf\n        ST   R2,PWA_LOCATION             | Save location.\n        CASEBLK REG=R2,MULT=1\n          CASE &ES_LOCATION_BELOW,&ES_LOCATION_ANY\n          CASE OTHER\n            ERREXIT CODE=&MM_INVALID_LOCATION\n        ENDCASE\n*---------------------------------------------------------------------*\n*       If all parameters have checked-out, indicate memory is okay.\n*---------------------------------------------------------------------*\n        SBIT PWA_F_USEABLE            | Indicate Memory Manager is ok.\n     EJECT\n***********************************************************************\n*                                                                     *\n*    Destroy an existing memory heap.                                 *\n*                                                                     *\n***********************************************************************\n     CASE &TERMINATE\n*---------------------------------------------------------------------*\n*       Free each block of storage and its associated descriptor.  Then\n*       wipe out the integrity-checking data in the PWA so that if the\n*       HeapID (which is really the PWA base) is used again, it will be\n*       recognized as a garbage pointer before getting us into deep\n*       trouble.\n*---------------------------------------------------------------------*\n        L      R10,PWAAESV            |\n        USING  ESV,R10                |\n        L      R3,PWA_STG_HDR         | Point to 1st storage block\n        USING  STG_BLOCK,R3           |   and establish addressability.\n        LOOP   WHILE,(C,R3,NE,PWA_STG)\n          L    R4,STG_LINK            |   Save address of next block.\n          L24  R1,STG_SIZE            |   Get free storage parameters.\n          ST   R1,PWA_WORK            |\n          CALLX ESVESEPA,(ESVESTKN,&ES_RELEASE_STORAGE,PWA_WORK,0,     +\n               STG_ADDR)\n          ST   R3,PWA_WORK\n          CALLX ESVESEPA,(ESVESTKN,&ES_RELEASE_STORAGE,=A(STG_BLOCK_L),+\n               0,PWA_WORK)\n          LR   R3,R4                  |   Point to next block in list.\n        ENDLOOP WHILE                 | EndLoop.\n        DROP    R3,R10                |\n*                                     |\n        XC   PWA_VISUAL,PWA_VISUAL    | Insure that the PWA cannot be\n        XC   PWA_HEAPID,PWA_HEAPID    | accidentally used again.\n*                                     |\n        SMCTRL FREEPWA=YES            | Free the PWA.\n     EJECT\n***********************************************************************\n*                                                                     *\n*    Allocate some memory.                                            *\n*                                                                     *\n***********************************************************************\n     CASE &MM_OBTAIN_STORAGE\n*---------------------------------------------------------------------*\n*       Verify that the parameters BYTES and ADDRESS were provided\n*       and that BYTES is a reasonable number.  Put BYTES in R3.\n*---------------------------------------------------------------------*\n        ERREXIT ((TBIT,PRM_FUNCTIONCODE,X'80'),OR,                     +\n               (TBIT,PRM_BYTES,X'80'),OR,                              +\n               (NOT,(TBIT,PRM_ADDRESS,X'80'))),                        +\n               CODE=&MM_INVALID_PARM_COUNT\n        L       R3,PRM_BYTES          | Point R3 to BYTES parameter.\n        L       R3,0(,R3)             | Load up the value.\n        ERREXIT ((TREG,R3,NP),OR,(C,R3,GT,MAX_BYTES)),                 +\n               CODE=&MM_INVALID_SIZE\n        A       R3,=F'7'              | Round the request up to an\n        N       R3,=X'FFFFFFF8'       |   eight-byte boundary.\n*---------------------------------------------------------------------*\n*       Search the free-storage list for a block large enough to\n*       satisfy the request.\n*---------------------------------------------------------------------*\n        L     R6,PWA_FREE             | Initialize previous node addr.\n        L     R4,PWA_FREE_HDR         | Point to 1st free-stg element\n        USING FREE_BLOCK,R4           | and establish addressability.\n        LOOP  WHILE,(C,R4,NE,PWA_FREE)  Loop over free-storage list.\n          EDC   FREE,CHECK            |   Check error detection code.\n          LEAVE LOOP=*,(CLM,R3,B'0111',LE,FREE_SIZE)\n          LR    R6,R4                 |   Save as the previous node.\n          L     R4,FREE_LINK          |   Point to next element.\n        ENDLOOP WHILE                 | EndLoop.\n*---------------------------------------------------------------------*\n*       If none is found, then allocate a new storage block and create\n*       a single free-storage element for it.\n*---------------------------------------------------------------------*\n        IF (C,R4,EQ,PWA_FREE)         | If no free-stg element found...\n          L       R10,PWAAESV         |\n          USING   ESV,R10             |\n          CALLX   ESVESEPA,(ESVESTKN,&ES_OBTAIN_STORAGE,               +\n               =A(STG_BLOCK_L),0,&ES_DOUBLEWORD_BOUNDARY,              +\n               &ES_LOCATION_ANY,PWA_WORK)\n          ERREXIT (C,R15,EQ,=A(&ES_STORAGE_NOT_AVAILABLE)),            +\n               CODE=&MM_STORAGE_NOT_AVAILABLE\n          ERREXIT (TREG,R15,NZ),CODE=&MM_UNKNOWN_ERROR\n          L       R5,PWA_WORK         |   Establish addressability on\n          USING   STG_BLOCK,R5        |     the storage descriptor.\n          MVC     STG_LINK,PWA_STG_HDR    Insert the new descriptor in\n          ST      R5,PWA_STG_HDR      |     front of the list.\n          LR      R2,R3               |   R2 := Size block to allocate.\n          IF (C,R2,LT,PWA_INCREMENT)  |   If minimum size larger then\n            L  R2,PWA_INCREMENT       |     Use the minimum block size.\n          ENDIF                       |   Endif.\n          ST      R2,PWA_WORK         |\n          CALLX   ESVESEPA,(ESVESTKN,&ES_OBTAIN_STORAGE,PWA_WORK,0,    +\n               PWA_BOUNDARY,PWA_LOCATION,STG_ADDR)\n          ERREXIT (C,R15,EQ,=A(&ES_STORAGE_NOT_AVAILABLE)),            +\n               CODE=&MM_STORAGE_NOT_AVAILABLE\n          ERREXIT (TREG,R15,NZ),CODE=&MM_UNKNOWN_ERROR\n          L       R4,STG_ADDR         |   Establish addr on Free_block.\n          STCM    R2,7,STG_SIZE       |   Save the block's total size.\n          MVC     FREE_LINK,PWA_FREE_HDR  Link the new free block in\n          ST      R4,PWA_FREE_HDR     |     front and make it equal to\n          MVC     FREE_SIZE,STG_SIZE  |     the entire storage block.\n          L       R6,PWA_FREE         |   Set previous node addr.\n          EDC     STG,SET             |   Set the Error Detection Code.\n          DROP    R5,R10              |   Clean up addressability.\n        ENDIF                         | EndIf\n*---------------------------------------------------------------------*\n*       Obtain memory for the user out of the located/created\n*       free-storage element, insuring that it is aligned okay.  When\n*       finished, R4 will point to the user's storage and not to a\n*       free_block element.\n*---------------------------------------------------------------------*\n        L24     R5,FREE_SIZE          | R5 := number of bytes after\n        SR      R5,R3                 |   user's chunk carved out.\n        IF      (C,R5,GE,=F'8'),THEN  | If enough left to keep block\n          STCM  R5,7,FREE_SIZE        |   then save amount left.\n          EDC   FREE,SET              |   Set the Error Detection Code.\n          LA    R4,FREE_BLOCK(R5)     |   Point to user's storage.\n        ELSE                          | Else remove entire free_block.\n          MVC   FREE_LINK-FREE_BLOCK(L'FREE_LINK,R6),FREE_LINK\n          DROP  R4                    | Clean up on addressability.\n          IF    (C,R6,NE,PWA_FREE)    | If previous not equal header.\n            USING FREE_BLOCK,R6       |   Establish addressability.\n            EDC   FREE,SET            |   Set the Error Detection Code.\n            DROP  R6                  |   Clean up addressability.\n          ENDIF                       |   EndIf.\n        ENDIF                         | EndIf.\n*                                     |\n        LR   R14,R4                   | R14 := address of user's stg.\n        LR   R15,R3                   | R15 := length of user's stg.\n        LOOP WHILE,(C,R15,GE,=F'256') | Loop over large chunks.\n          XC  0(256,R14),0(R14)       |   Clear out the chunk of stg.\n          LA  R14,256(,R14)           |   Advance to the next chunck.\n          S   R15,=F'256'             |   Adjust remaining length.\n        ENDLOOP WHILE                 | EndLoop.\n        IF (TREG,R15,P),THEN          | If anything left, then.\n          BCTR R15,0                  |   Subtract 1 for EX instr.\n          EXI  R15,(XC,0(0,R14),0(R14))   Clear out remaining stg.\n        ENDIF                         | EndIf.\n*                                     |\n        L       R1,PRM_ADDRESS        | Point to user's ADDRESS parm\n        ST      R4,0(,R1)             |   and save the new storage.\n   EJECT\n***********************************************************************\n*                                                                     *\n*    Free some memory.\n*                                                                     *\n***********************************************************************\n     CASE &MM_RELEASE_STORAGE\n*---------------------------------------------------------------------*\n*       Verify that the parameters BYTES and ADDRESS were provided\n*       and that they are reasonable numbers.  Put ADDRESS in R4 and\n*       ADDRESS + BYTES in R3.\n*---------------------------------------------------------------------*\n        ERREXIT ((TBIT,PRM_FUNCTIONCODE,X'80'),OR,                     +\n               (TBIT,PRM_BYTES,X'80'),OR,                              +\n               (NOT,(TBIT,PRM_ADDRESS,X'80'))),                        +\n               CODE=&MM_INVALID_PARM_COUNT\n        L       R3,PRM_BYTES          | Point R3 to BYTES parameter.\n        L       R3,0(,R3)             | R3 := BYTES.\n        ERREXIT ((TREG,R3,NP),OR,(C,R3,GT,MAX_BYTES)),                 +\n               CODE=&MM_INVALID_SIZE\n        A       R3,=F'7'              | Round the request up to an\n        N       R3,=X'FFFFFFF8'       |   eight-byte boundary.\n        L       R4,PRM_ADDRESS        | Point R4 to ADDRESS parameter.\n        L       R4,0(,R4)             | R4 := ADDRESS.\n        LA      R4,0(,R4)             | Clear high-order bit/byte.\n        LR      R0,R4                 |\n        N       R0,=F'7'              | R0 := low-order 3 bits of addr.\n        ERREXIT (TREG,R0,NZ),CODE=&MM_INVALID_ALIGNMENT\n        LA      R2,0(R3,R4)           | R2 := ADDRESS + BYTES.\n*---------------------------------------------------------------------*\n*       Loop over the PWA_STG to insure that the storage to be\n*       freed is completely within one of the storage blocks owned by\n*       this heap.  It must start and end within the bounds of one of\n*       the blocks. If it partially overlaps a block or is not within\n*       a block, then end in error.\n*---------------------------------------------------------------------*\n        L     R5,PWA_STG_HDR          | Point R5 to the 1st STG_BLOCK\n        USING STG_BLOCK,R5            | and establish addressability.\n        LOOP  WHILE,(C,R5,NE,PWA_STG) | Loop over STG_BLOCK list.\n          EDC STG,CHECK               |   Check the Error code.\n          L24 R6,STG_SIZE             |   R6 := STG_ADDR + STG_SIZE.\n          A   R6,STG_ADDR             |   If new stg starts w/in block\n          IF  ((C,R4,GE,STG_ADDR),AND,(CR,R4,LT,R6)),THEN\n            ERREXIT (CR,R2,GT,R6),CODE=&MM_MEMORY_NOT_IN_HEAP\n            LEAVE LOOP=*              |     Storage is non-overlapping\n          ENDIF                       |   EndIf.\n          L   R5,STG_LINK             | Point to next STG_BLOCK.\n        ENDLOOP WHILE                 | EndLoop.\n        ERREXIT (C,R5,EQ,PWA_STG),CODE=&MM_MEMORY_NOT_IN_HEAP\n*---------------------------------------------------------------------*\n*       Loop over the list of free storage blocks to insure that the\n*       storage to be freed does not overlap any of the existing free\n*       storage blocks.  While at it, check for free blocks in the same\n*       STG_BLOCK that are adjacent to the beginning or the end of the\n*       storage being released and check the error detection code of\n*       each free storage block examined.\n*---------------------------------------------------------------------*\n        MVC   PWA_ADJ_BEFORE,=F'0'    | Initially, no free storage\n        MVC   PWA_ADJ_AFTER,=F'0'     | blocks known to be adjacent.\n        L     R7,PWA_FREE_HDR         | Point to 1st free storage block\n        USING FREE_BLOCK,R7           |   and establish addressability.\n        L     R8,PWA_FREE             | R8 points to previous block.\n        LOOP  WHILE,(C,R7,NE,PWA_FREE)  Loop over the free storage list\n          EDC   FREE,CHECK            |   Check Error Detection Code.\n          L24   R1,FREE_SIZE          |\n          AR    R1,R7                 |   R1 := FREE_ADDR + FREE_SIZE\n          ERREXIT (((CR,R4,GE,R7),AND,(CR,R4,LT,R1)),OR,               +\n               ((CR,R2,GT,R7),AND,(CR,R2,LE,R1))),                     +\n               CODE=&MM_MEMORY_NOT_ALLOCATED\n          IF (C,R7,GE,STG_ADDR),AND,(CR,R1,LT,R6)  If in STG_BLOCK.\n            IF (CR,R1,EQ,R4)          |        If adjacent before.\n              ST  R7,PWA_ADJ_BEFORE   |          Remember this block.\n            ELSEIF (CR,R2,EQ,R7)      |        ElseIf adjacent after.\n              ST  R7,PWA_ADJ_AFTER    |          Remember this block\n              ST  R8,PWA_ADJ_PREV     |          and previous block.\n            ENDIF                     |        EndIf.\n          ENDIF                       |      EndIf\n          LR    R8,R7                 |      R8 -> Previous block.\n          L     R7,FREE_LINK          |      R7 -> New current block.\n        ENDLOOP WHILE                 | EndLoop\n        DROP    R7                    | FREE_BLOCK\n        DROP    R5                    | STG_BLOCK\n*---------------------------------------------------------------------*\n*       If there was a free block adjacent to the end of the storage\n*       being released, pull the existing block out of the free-chain\n*       and update the total size being released.\n*---------------------------------------------------------------------*\n        IF    (CLC,PWA_ADJ_AFTER,NE,=F'0'),THEN\n          L     R7,PWA_ADJ_AFTER      | Go to the adjacent block ...\n          USING FREE_BLOCK,R7         |   Establish addressability.\n          L24   R1,FREE_SIZE          |   Get its size and add it to\n          AR    R3,R1                 |   the total size being freed.\n          L     R1,FREE_LINK          |   Get the link.\n          L     R7,PWA_ADJ_PREV       | Point to the previous block...\n          ST    R1,FREE_LINK          |   Update its linkage.\n          IF    (C,R7,NE,PWA_FREE)    |   If not pointing to the hdr.\n            EDC   FREE,SET            |     Update its Error Detection.\n          ENDIF                       |   EndIf.\n          DROP  R7                    |   Clean up addressability.\n        ENDIF                         | EndIf\n*---------------------------------------------------------------------*\n*       If there was a free block adjacent to the beginning of the\n*       storage being released, merge the two, updating the size.\n*       Otherwise, create a new free block for the released storage\n*       and insert it in front of the free-storage list.\n*---------------------------------------------------------------------*\n        USING FREE_BLOCK,R4           |   Establish addressability.\n        IF    (CLC,PWA_ADJ_BEFORE,NE,=F'0'),THEN\n          L     R4,PWA_ADJ_BEFORE     |   Point to the adjacent block\n          L24   R1,FREE_SIZE          |   Get the size into a register\n          AR    R3,R1                 |   and add the size being freed.\n        ELSE                          | Else\n          L     R1,PWA_FREE_HDR       |   Get link to 1st block.\n          ST    R4,PWA_FREE_HDR       |   Replace w/link to new block.\n          ST    R1,FREE_LINK          |   Set link to the next block.\n        ENDIF                         | EndIf\n*                                     |\n        STCM  R3,7,FREE_SIZE          | Update with the new size.\n        EDC   FREE,SET                | Set the Error Detection Code.\n        DROP  R4                      | Clean up addressability.\n*---------------------------------------------------------------------*\n*       Since the storage is not allocated, wipe the caller's pointer.\n*---------------------------------------------------------------------*\n        L     R1,PRM_ADDRESS          | R1 -> Caller's pointer to stg.\n        XC    0(4,R1),0(R1)           | Clear it to zeros.\n   EJECT\n***********************************************************************\n*                                                                     *\n*  Reset the heap but retain all getmained storage.                   *\n*                                                                     *\n***********************************************************************\n     CASE &MM_RESET_HEAP\n*---------------------------------------------------------------------*\n*       Set the free-list to empty.\n*---------------------------------------------------------------------*\n        LA   R1,PWA_FREE_HDR          | Initialize the list header\n        ST   R1,PWA_FREE_HDR          | by pointing it to itself.\n        ST   R1,PWA_FREE              |\n*---------------------------------------------------------------------*\n*       Run the storage blocks, adding each as a free-element.\n*---------------------------------------------------------------------*\n        L      R3,PWA_STG_HDR         | Point to 1st storage block\n        USING  STG_BLOCK,R3           | and establish addressability.\n        LOOP   WHILE,(C,R3,NE,PWA_STG)  Loop over storage blocks.\n          EDC     STG,CHECK           |   Check the Error code.\n          USING   FREE_BLOCK,R4       |   Make it a free_block.\n          L       R4,STG_ADDR         |   R4 -> storage block.\n          MVC     FREE_LINK,PWA_FREE_HDR  Link the new free block in\n          ST      R4,PWA_FREE_HDR     |   front and make it equal to\n          MVC     FREE_SIZE,STG_SIZE  |   the entire storage block.\n          EDC     FREE,SET            |   Set the Error Detection Code.\n          DROP    R4                  |   Drop free_block addressing.\n          L       R3,STG_LINK         |   Point to next block in list.\n        ENDLOOP WHILE                 | EndLoop.\n        DROP    R3                    | Drop storage-block addressing.\n   EJECT\n***********************************************************************\n*                                                                     *\n*    Invalid Function Code.                                           *\n*                                                                     *\n***********************************************************************\n     CASE OTHER                       |\n        ERREXIT CODE=&MM_INVALID_FUNCTION\n   ENDCASE                            |\n*                                     |\n ENDBLK BLOCK=&srv_modname,RC=0       |\n*\n***********************************************************************\n*                                                                     *\n*  Exit with a return code equal to the code passed in.               *\n*                                                                     *\n***********************************************************************\n BLOCK TYPE=ERREXIT\n*---------------------------------------------------------------------*\n*  Save module/offset, registers, return-code.\n*---------------------------------------------------------------------*\n   ST    R15,PWA_REASON          | Save possible return-code.\n   STM   R0,R15,GDIREGS          | Save registers at time of error.\n   SM_LAL R0,&srv_modname+4      | Point to module identification.\n   ST    R0,GDIMODID             | Save in general debug area.\n   MVC   GDIRC,0(R14)            | Copy return code.\n   SL    R14,=A(&srv_modname)    | Calculate offset at time of error.\n   STH   R14,GDIOFFST            | Save in debug area.\n   L     R2,PWAAESV              |\n   USING ESV,R2                  |\n   CALLX ESVESEPA,(ESVESTKN,&ES_SAVE_DEBUG_INFO,&ES_DEBUG_ID_GDI,GDI)\n*---------------------------------------------------------------------*\n*  Look at the error code.  Some errors imply that the memory manager\n*  has lost its cookies and should not attempt to do anything other\n*  than shut-down (if it can even do that).\n*---------------------------------------------------------------------*\n   LH    R15,GDIRC               | Get return code.\n   CASEBLK REG=R15,MULT=1        | Case on return-code.\n     CASE &MM_UNKNOWN_ERROR,&MM_NOT_USEABLE\n       RBIT  PWA_F_USEABLE       |   Indicate memory manager unsafe.\n       CALLX ESVESEPA,(ESVESTKN,&ES_SAVE_DEBUG_INFO,                   +\n               &ES_DEBUG_ID_HEX,PWA_REASON,4,'REASON',6)\n     CASE &MM_CORRUPT_STORAGE    |\n       RBIT  PWA_F_USEABLE       |   Indicate memory manager unsafe.\n       MVC  PWA_REASON,GDIRC     |   Remember reason it can't be used.\n     CASE OTHER                  |   Don't bother w/other errors.\n   ENDCASE                       | EndCase.\n   DROP  R2                      |\n*---------------------------------------------------------------------*\n*  Set the return-code and exit.\n*---------------------------------------------------------------------*\n   LH    R15,GDIRC               | Set return code.\n ENDBLK\n EJECT\n*---------------------------------------------------------------------*\n*\n*  Static Data\n*\n*---------------------------------------------------------------------*\n                PSD\nEYECATCHER      DC   CL8'MEMORY'      | Eyecatcher value for dumps.\nDFLT_INCREMENT  DC   F'4096'          | Default minimum block size.\nMAX_INCREMENT   DC   F'16777215'      | Largest possible increment.\nMAX_BYTES       DC   F'16777215'      | Maximum allowed size for\n*                                     | allocation -- limited by the\n*                                     | data structures to a maximum of\n*                                     | 16777215 bytes.\n                LTORG\n                ENDPSD\n                EJECT\n*-----m---------------------------------------------------------------*\n*\n*  Program Work Area\n*\n*---------------------------------------------------------------------*\n               PWA\nPWA_AREA       DS    0F               | Beginning of visible PWA stg.\nPWA_VISUAL     DS    CL8              | Character string 'MEMORY'.\nPWA_F          DS    X                | Flags for memory manager.\nPWA_F_USEABLE  EQU   X'80'            | Memory manager is useable.\nPWA_HEAPID     DS    A                | Unique heap identifier.\nPWA_INCREMENT  DS    A                | Minimum block size.\nPWA_BOUNDARY   DS    A                | Doubleword/page for stg_blocks.\nPWA_LOCATION   DS    A                | Above/below the 16M line.\nPWA_STG        DS    A                | Address of PWA_STG_HDR.\nPWA_STG_HDR    DS    A                | List of STG_BLOCK elements.\nPWA_FREE       DS    A                | Address of PWA_FREE_HDR.\nPWA_FREE_HDR   DS    A                | List of free_storage elements.\nPWA_ADJ_BEFORE DS    A                | Free_block's adjacent to the\nPWA_ADJ_AFTER  DS    A                |   storage being released.\nPWA_ADJ_PREV   DS    A                | Block previous to PWA_ADJ_AFTER\nPWA_WORK       DS    F                | Fullword work area.\n               ORG   PWA_WORK         |\nPWA_WORK_H1    DS    H                | Halfword work area 1.\nPWA_WORK_H2    DS    H                | Halfword work area 2.\n               ORG   PWA_WORK         |\nPWA_WORK_B1    DS    X                | Byte work area 1.\nPWA_WORK_B2    DS    X                | Byte work area 2.\n               ORG   ,                |\nPWA_REASON     DS    F                | Reason memory manager died.\n               ES_GDI DSECT=NO        | General debugging information.\nPWA_AREA_L     EQU   *-PWA_AREA       | Length of visible PWA stg.\n               ENDPWA\n               EJECT\n*---------------------------------------------------------------------\n*\n*  Storage description DSECTs.\n*\n*---------------------------------------------------------------------\nSTG_BLOCK     DSECT                   | Storage block Descriptor\nSTG_LINK      DS     A                | Link to next STG_BLOCK.\nSTG_ADDR      DS     A                | Address of storage block.\nSTG_EDC       DS     X                | Error Detection Code.\nSTG_SIZE      DS     FL3              | Total size of allocated block.\nSTG_BLOCK_L   EQU    *-STG_BLOCK      | Length of descriptor.\n*\nFREE_BLOCK    DSECT                   | Describes a free storage area.\nFREE_LINK     DS     A                | Pointer to next free storage.\nFREE_EDC      DS     X                | Error Detection Code.\nFREE_SIZE     DS     FL3              | Size of free storage area.\n              EJECT\n*---------------------------------------------------------------------\n*  Parameter list for the memory server.\n*---------------------------------------------------------------------\nPARMLIST          DSECT              |\nPRM_HEAPID        DS  A              | Heap identifier === PWA base\nPRM_FUNCTIONCODE  DS  A              | Function to be performed\nPRM_FUNCTION_DEPT EQU *              | Function-dependent parameters\nPRM_ESV           DS  A              | Environment Support Vector.\nPRM_INCREMENT     DS  A              | Heap increment size.\nPRM_LOCATION      DS  A              | Location of obtained storage.\n                  ORG PRM_FUNCTION_DEPT\nPRM_BYTES         DS  A              | Bytes to allocate/free\nPRM_ADDRESS       DS  A              | Address allocated/to be freed\n*---------------------------------------------------------------------\n*  Environment support vector mapping dsect.\n*---------------------------------------------------------------------\n                  ES_ESV\n                  END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SRVMMMAC": {"ttr": 31240, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x02\\x00\\x00X\\x01\\x11)\\x9f\\x01\\x11)\\x9f\\t'\\x01\\x0f\\x01\\x0f\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@\"", "ispf": {"version": "02.00", "flags": 0, "createdate": "2011-10-26T00:00:00", "modifydate": "2011-10-26T09:27:58", "lines": 271, "newlines": 271, "modlines": 0, "user": "CLEMSON"}, "text": "*---------------------------------------------------------------------*\n*  Copyright 2011 by Clemson University Research Foundation           *\n*                                                                     *\n*  Licensed under the Apache License, Version 2.0 (the \"License\");    *\n*  you may not use this file except in compliance with the License.   *\n*  You may obtain a copy of the License in this library as member     *\n*  $LICENSE, or from                                                  *\n*                                                                     *\n*      http://www.apache.org/licenses/LICENSE-2.0                     *\n*                                                                     *\n*  Unless required by applicable law or agreed to in writing,         *\n*  software distributed under the License is distributed on an \"AS    *\n*  IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either    *\n*  express or implied.  See the License for the specific language     *\n*  governing permissions and limitations under the License.           *\n*---------------------------------------------------------------------*\n TITLE 'SRVMMMAC: Memory Manager Service Processor Symbols && Macros.'\n*---------------------------------------------------------------------*\n*\n*  Copy File:  SRVMMMAC\n*\n*  Purpose:    Memory manager service processor symbols and macros.\n*\n*  Description: See \"Service Processors User's Guide and Reference\".\n*\n*  Change\n*  History:    04/04/89 MJM - New\n*            2009-09-02 MJM - Fixed two error codes.\n*\n*---------------------------------------------------------------------*\n*\n***********************************************************************\n***********************************************************************\n**                                                                   **\n**                     Symbol Definitions                            **\n**                                                                   **\n***********************************************************************\n***********************************************************************\n*\n* Global declarations for all Memory Manager symbols.\n*\n  GBLC &MEMORY_MANAGER\n  GBLC &MM_MEMORY_MANAGER\n  GBLA &MM_START,&MM_TERMINATE,&MM_OBTAIN_STORAGE\n  GBLA &MM_RELEASE_STORAGE,&MM_RESET_HEAP\n  GBLA &MM_PAGE_SIZE,&MM_INVALID_FUNCTION\n  GBLA &MM_INVALID_HEAPID,&MM_INVALID_INCREMENT,&MM_INVALID_LOCATION\n  GBLA &MM_INVALID_SIZE,&MM_INVALID_PARM_COUNT\n  GBLA &MM_INVALID_ALIGNMENT,&MM_STORAGE_NOT_AVAILABLE\n  GBLA &MM_UNKNOWN_ERROR,&MM_MEMORY_NOT_IN_HEAP\n  GBLA &MM_MEMORY_NOT_ALLOCATE,&MM_CORRUPT_STORAGE,&MM_NOT_USEABLE\n  GBLA &MM_LOCATION_ANY,&MM_LOCATION_BELOW\n*\n* Entry point name for the memory manager.\n*\n&MEMORY_MANAGER               SETC '''SRVMM   '''\n&MM_MEMORY_MANAGER            SETC '''SRVMM   '''\n*\n*  Function codes.\n*\n&MM_START                     SETA 1\n&MM_TERMINATE                 SETA 2\n&MM_OBTAIN_STORAGE            SETA 3\n&MM_RELEASE_STORAGE           SETA 4\n&MM_RESET_HEAP                SETA 5\n*\n* Start function parameter values.\n*\n&MM_PAGE_SIZE                 SETA  4096\n&MM_LOCATION_ANY              SETA  &ES_LOCATION_ANY\n&MM_LOCATION_BELOW            SETA  &ES_LOCATION_BELOW\n*\n* Return codes from the Memory Manager.\n*\n&MM_SUCCESS                   SETA  0\n&MM_INVALID_FUNCTION          SETA  1\n&MM_INVALID_HEAPID            SETA  2\n&MM_INVALID_INCREMENT         SETA  3\n&MM_INVALID_LOCATION          SETA  4\n&MM_INVALID_SIZE              SETA  5\n&MM_INVALID_PARM_COUNT        SETA  6\n&MM_INVALID_ALIGNMENT         SETA  7\n&MM_STORAGE_NOT_AVAILABLE     SETA  8\n&MM_UNKNOWN_ERROR             SETA  9\n&MM_MEMORY_NOT_IN_HEAP        SETA 10\n&MM_MEMORY_NOT_ALLOCATED      SETA 11\n&MM_CORRUPT_STORAGE           SETA 12\n&MM_NOT_USEABLE               SETA 13\n DEFUCOND MACRO=SRV##RC,NAME=MM_SUCCESS\n DEFUCOND MACRO=SRV##RC,NAME=MM_INVALID_FUNCTION\n DEFUCOND MACRO=SRV##RC,NAME=MM_INVALID_HEAPID\n DEFUCOND MACRO=SRV##RC,NAME=MM_INVALID_INCREMENT\n DEFUCOND MACRO=SRV##RC,NAME=MM_INVALID_LOCATION\n DEFUCOND MACRO=SRV##RC,NAME=MM_INVALID_SIZE\n DEFUCOND MACRO=SRV##RC,NAME=MM_INVALID_PARM_COUNT\n DEFUCOND MACRO=SRV##RC,NAME=MM_INVALID_ALIGNMENT\n DEFUCOND MACRO=SRV##RC,NAME=MM_STORAGE_NOT_AVAILABLE\n DEFUCOND MACRO=SRV##RC,NAME=MM_UNKNOWN_ERROR\n DEFUCOND MACRO=SRV##RC,NAME=MM_MEMORY_NOT_IN_HEAP\n DEFUCOND MACRO=SRV##RC,NAME=MM_MEMORY_NOT_ALLOCATED\n DEFUCOND MACRO=SRV##RC,NAME=MM_CORRUPT_STORAGE\n DEFUCOND MACRO=SRV##RC,NAME=MM_NOT_USEABLE\n                        EJECT\n***********************************************************************\n***********************************************************************\n**                                                                   **\n**                     Macro Definitions                             **\n**                                                                   **\n***********************************************************************\n***********************************************************************\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   MM_ID                                                      *\n*                                                                     *\n* Purpose: Establish default values for a specific service processor  *\n*          and associate them with the specified ID name. The values  *\n*          are stored in the following created global variables:      *\n*                                                                     *\n* Variable Name                     Description                       *\n* -------------  ---------------------------------------------------- *\n* #$&ID.$#IDMAC  Name of macro that created the ID: MM_ID.            *\n* #$&ID.$#ESID   Service processor's Environment Support ID.          *\n* #$&ID.$#EPN    Tag for Service processor's Entry Point Name.        *\n* #$&ID.$#EPA    Tag for Service processor's Entry Point Address.     *\n* #$&ID.$#TKN    Tag for Service processor's Entry Point Token.       *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         MM_ID &ID=,&ESVA=,&SPEPNAME=,&SPEPA=,&SPTOKEN=,&ESID=\n         LCLC  &L_EPNAME\n         GBLC  &MEMORY_MANAGER\n.*\n.* If no EPNAME was specified, use the generic Memory Manager.\n.*\n&L_EPNAME SETC '&SPEPNAME'\n          AIF  ('&L_EPNAME' NE '').PAST_EPN\n&L_EPNAME SETC '&MEMORY_MANAGER'\n.PAST_EPN ANOP\n.*\n.* Invoke SRV##ID to create globals used by all ID's.\n.*\n         SRV##ID SET,                                                  +\n               ID=&ID.,IDMAC=MM_ID,ESID=&ESID.,SPEPNAME=&L_EPNAME,     +\n               SPEPA=&SPEPA,SPTOKEN=&SPTOKEN.\n         MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   MM_START                                                   *\n* Purpose: Generate code to start a new memory manager session.       *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         MM_START &ID=,&SPEPA=,&SPTOKEN=,&ESVA=,                       +\n               &INCREMENT=,&LOCATION=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN\n         GBLA  &MM_START                           SETC in open code.\n         GBLA  &MM_LOCATION_ANY,&MM_LOCATION_BELOW SETC in open code.\n         LCLC  &L_LOC\n.*\n.* Obtain service processor ID values.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN,ESVA),                    +\n               ID=&ID,IDMAC=MM_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN,       +\n               ESVA=&ESVA.\n         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT\n         MVC   &#_IDTKN,=F'0'            | Insure TOKEN = 0.\n.*\n.* Set up the optional LOCATION parameter.\n.*\n&L_LOC    SETC ''\n          AIF   ('&LOCATION' EQ '').PAST_LOC\n          AIF   ('&LOCATION' EQ 'ANY').LOC_ANY\n          AIF   ('&LOCATION' EQ 'BELOW').LOC_BELO\n          MNOTE 8,'LOCATION must be ANY or BELOW.'\n          MEXIT\n.LOC_ANY  ANOP\n&L_LOC    SETC '&MM_LOCATION_ANY'\n          AGO  .PAST_LOC\n.LOC_BELO ANOP\n&L_LOC    SETC '&MM_LOCATION_BELOW'\n.PAST_LOC ANOP\n.*\n.* Generate the MM_START call statement.\n.*\n         AIF   ('&LOCATION' NE '').CALL3\n         AIF   ('&INCREMENT' NE '').CALL2\n.CALL1   CALLX &#_IDEPA,(&#_IDTKN,&MM_START,&#_IDESVA),VL\n         MEXIT\n.CALL2   CALLX &#_IDEPA,(&#_IDTKN,&MM_START,&#_IDESVA,&INCREMENT),VL\n         MEXIT\n.CALL3   CALLX &#_IDEPA,(&#_IDTKN,&MM_START,&#_IDESVA,&INCREMENT,      +\n               &L_LOC),VL\n         MEXIT\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   MM_TERMINATE                                               *\n* Purpose: Generate code to terminate a memory manager session.       *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         MM_TERMINATE &ID=,&SPEPA=,&SPTOKEN=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN\n         GBLA  &MM_TERMINATE              SETC in open code.\n.*\n.* Obtain service processor ID values and terminate memory manager.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +\n               ID=&ID,IDMAC=MM_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN\n         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT\n         CALLX &#_IDEPA,(&#_IDTKN,&MM_TERMINATE),VL\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   MM_OBTAIN_STORAGE                                          *\n* Purpose: Generate code to obtain a piece of storage.                *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         MM_OBTAIN_STORAGE &ID=,&SPEPA=,&SPTOKEN=,&SIZE=,&ADDRESS=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN\n         GBLA  &MM_OBTAIN_STORAGE\n.*\n.* Obtain service processor ID values and generate obtain_storage call.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +\n               ID=&ID,IDMAC=MM_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN\n         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT\n.*\n         AIF  ('&SIZE' NE '').SIZE_OK\n         MNOTE 8,'SIZE is a required keyword.'\n         MEXIT\n.SIZE_OK ANOP\n         AIF  ('&ADDRESS' NE '').ADDR_OK\n         MNOTE 8,'ADDRESS is a required keyword.'\n         MEXIT\n.ADDR_OK ANOP\n         CALLX &#_IDEPA,(&#_IDTKN,&MM_OBTAIN_STORAGE,&SIZE,&ADDRESS),VL\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   MM_RELEASE_STORAGE                                         *\n* Purpose: Generate code to release a piece of storage.               *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         MM_RELEASE_STORAGE &ID=,&SPEPA=,&SPTOKEN=,&SIZE=,&ADDRESS=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN\n         GBLA  &MM_RELEASE_STORAGE\n.*\n.* Obtain service processor ID values & generate RELEASE_STORAGE call.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +\n               ID=&ID,IDMAC=MM_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN\n         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT\n.*\n         AIF  ('&SIZE' NE '').SIZE_OK\n         MNOTE 8,'SIZE is a required keyword.'\n         MEXIT\n.SIZE_OK ANOP\n         AIF  ('&ADDRESS' NE '').ADDR_OK\n         MNOTE 8,'ADDRESS is a required keyword.'\n         MEXIT\n.ADDR_OK ANOP\n         CALLX &#_IDEPA,(&#_IDTKN,&MM_RELEASE_STORAGE,&SIZE,&ADDRESS), +\n               VL\n.MEXIT   MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SRVMNMVS": {"ttr": 31491, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x02\\x00\\x00X\\x01\\x11)\\x9f\\x01\\x11)\\x9f\\t'\\x00D\\x00D\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@\"", "ispf": {"version": "02.00", "flags": 0, "createdate": "2011-10-26T00:00:00", "modifydate": "2011-10-26T09:27:58", "lines": 68, "newlines": 68, "modlines": 0, "user": "CLEMSON"}, "text": "*---------------------------------------------------------------------*\n*  Copyright 2011 by Clemson University Research Foundation           *\n*                                                                     *\n*  Licensed under the Apache License, Version 2.0 (the \"License\");    *\n*  you may not use this file except in compliance with the License.   *\n*  You may obtain a copy of the License in this library as member     *\n*  $LICENSE, or from                                                  *\n*                                                                     *\n*      http://www.apache.org/licenses/LICENSE-2.0                     *\n*                                                                     *\n*  Unless required by applicable law or agreed to in writing,         *\n*  software distributed under the License is distributed on an \"AS    *\n*  IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either    *\n*  express or implied.  See the License for the specific language     *\n*  governing permissions and limitations under the License.           *\n*---------------------------------------------------------------------*\nSRVMNMVS TITLE 'Standard MVS Service Processors'\n*---------------------------------------------------------------------*\n*\n*  Copyright (C) 1989 Clemson University\n*\n*  Module      SRVMNMVS\n*\n*  Abstract    Standard Module Name Table for Environment Support.\n*\n*  Change      10/13/89 MJM - New\n*  History\n*\n*---------------------------------------------------------------------*\n         EJECT\n         PRINT OFF            | Copy statements for symbols.\n         COPY  SRVESMAC       |   Environment Support symbols & macros.\n         COPY  SRVMMMAC       |   Memory Manager symbols & macros.\n         COPY  SRVSYMAC       |   Symbol Manager symbols & macros.\n         COPY  SRVSTMAC       |   String Handler symbols & macros.\n         COPY  SRVPLMAC       |   Print Line symbols & macros.\n         COPY  SRVMSMAC       |   Messages Services symbols & macros.\n         COPY  SRVIMMAC       |   Item Manager symbols & macros.\n         COPY  SRVDVMAC       |   Data-in-virtual symbols & macros.\n         COPY  SRVDTMAC       |   Date/Time service processor.\n         COPY  SRVFIMAC       |   File handler.\n         PRINT ON             | End of service processor copy stmts.\nSRVMNMVS CSECT ,              |\nSRVMNMVS AMODE ANY            |\nSRVMNMVS RMODE ANY            |\nNAMES    ES_MODULE_NAME START,NAME='SRVMNMVS'\n         ES_MODULE_NAME NAME=&ES_MVS_MESSAGE_EXIT,                     +\n               DCAMODE=31\n         ES_MODULE_NAME NAME=&MEMORY_MANAGER,                          +\n               DCAMODE=31\n         ES_MODULE_NAME NAME=&SYMBOL_MANAGER,                          +\n               DCAMODE=31\n         ES_MODULE_NAME NAME=&STRING_HANDLER,                          +\n               DCAMODE=31\n         ES_MODULE_NAME NAME=&PRINT_LINE,TRUENAME=&MVS_PRINT_LINE,     +\n               DCAMODE=31\n         ES_MODULE_NAME NAME=&MESSAGE_SERVICES,                        +\n               DCAMODE=31\n         ES_MODULE_NAME NAME=&ITEM_MANAGER,                            +\n               DCAMODE=31\n         ES_MODULE_NAME NAME=&DIV_MANAGER,TRUENAME=&MVS_DIV_MANAGER,   +\n               DCAMODE=31\n         ES_MODULE_NAME NAME=&DATETIME_SERVICES,                       +\n               DCAMODE=31\n         ES_MODULE_NAME NAME=&FI_OS_FILE_HANDLER,                      +\n               DCAMODE=31\n         ES_MODULE_NAME END   | End of Module Name Table.\n         END   ,              |\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SRVMOD": {"ttr": 31493, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x02\\x00\\x00X\\x01\\x11)\\x9f\\x01\\x11)\\x9f\\t'\\x00Q\\x00Q\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@\"", "ispf": {"version": "02.00", "flags": 0, "createdate": "2011-10-26T00:00:00", "modifydate": "2011-10-26T09:27:58", "lines": 81, "newlines": 81, "modlines": 0, "user": "CLEMSON"}, "text": "*---------------------------------------------------------------------*\n*  Copyright 2011 by Clemson University Research Foundation           *\n*                                                                     *\n*  Licensed under the Apache License, Version 2.0 (the \"License\");    *\n*  you may not use this file except in compliance with the License.   *\n*  You may obtain a copy of the License in this library as member     *\n*  $LICENSE, or from                                                  *\n*                                                                     *\n*      http://www.apache.org/licenses/LICENSE-2.0                     *\n*                                                                     *\n*  Unless required by applicable law or agreed to in writing,         *\n*  software distributed under the License is distributed on an \"AS    *\n*  IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either    *\n*  express or implied.  See the License for the specific language     *\n*  governing permissions and limitations under the License.           *\n*---------------------------------------------------------------------*\n         MACRO\n         SRVMOD &NAME=,&DATES='1990, 1995'\n         GBLC  &SRV_NAME\n         GBLC  &SRV_MODNAME\n         GBLC  &SRV_COMPID\n         GBLC  &SRV_FMID\n         GBLC  &SRV_PTF\n         GBLC  &SRV_DATES\n         GBLC  &SRV_STDMNT\n         GBLB  &SRV_SMP\n         GBLB  &SRV_CLEMSON\n         LCLA  &L\n&SRV_NAME    SETC '&NAME'\n&SRV_DATES   SETC '&DATES'\n&SRV_MODNAME SETC '&SRV_NAME'\n         COPY  SRVLEVEL\n         AIF   ('&SRV_STDMNT' NE '').PAST_SET_STDMNT\n&SRV_STDMNT SETC 'SRVMNMVS'\n.PAST_SET_STDMNT ANOP\n         AIF   (K'&NAME LE 3).ERR_NAME\n         AIF   ('&SRV_COMPID' EQ '').DFLT_COMPID\n         AIF   (K'&SRV_COMPID NE 3).ERR_COMPID\n         AGO   .SET_MODNAME\n.DFLT_COMPID ANOP\n&SRV_COMPID SETC 'SRV'\n.SET_MODNAME ANOP\n.* MODNAME IS COMPID CONCATINATED WITH 4TH AND REMAINING CHARS OF NAME.\n&L       SETA  K'&NAME-3\n&SRV_MODNAME SETC '&SRV_COMPID'.'&NAME'(4,&L)\n         AIF   (NOT &SRV_SMP).NO_SMP\n         PUNCH '++ MOD (&SRV_MODNAME) DISTLIB(SYSPUNCH) .'\n.NO_SMP  ANOP\n         MACRO\n         ##MODPFX &NAME,                NAME OF BLOCK                  +\n               &CPYRGHT                 COPYRIGHT NOTICE\n         GBLC  &SRV_FMID\n         GBLC  &SRV_PTF\n         GBLC  &SRV_DATES\n         GBLC  &SRV_NAME\n         GBLC  &SRV_MODNAME\n         AIF   ('&NAME' EQ '&SRV_MODNAME').NAME_OK\n         MNOTE 8,'MODULE NAME AND PROGRAM BLOCK MACRO MUST MATCH.'\n.NAME_OK ANOP\n##MODPFX__START_&SYSNDX EQU *\n         DC    AL1(##MODPFX__SIZE_&SYSNDX)\n         DC    CL8'&SRV_MODNAME'        MODULE NAME\n         DC    CL10' &SYSDATE '         ASSEMBLE DATE\n         DC    CL6'&SYSTIME'            ASSEMBLE TIME\n         DC    CL8'&SRV_FMID'           FUNCTION ID\n         DC    CL8'&SRV_PTF'            PTF ID\n         DC    C'(C) COPYRIGHT CLEMSON UNIVERSITY RESEARCH FOUNDATION, +\n               '\n         DC    C&SRV_DATES\n         DC    C'.'\n         DS    0H\n##MODPFX__SIZE_&SYSNDX EQU *-##MODPFX__START_&SYSNDX\n.BLD0010 ANOP\n         MEND\n         MEXIT\n.ERR_NAME MNOTE 8,'NAME=&NAME IS INVALID.  NAME MUST BE AT LEAST 3 CHAR+\n               ACTERS LONG.'\n         MEXIT\n.ERR_COMPID MNOTE 8,'COMPID &SRV_COMPID IS INVALID.  COMPID MUST BE 3 C+\n               HARACTERS LONG.'\n         MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SRVMS": {"ttr": 31496, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x02\\x00\\x00X\\x01\\x11)\\x9f\\x01\\x11)\\x9f\\t'\\x04\\xcc\\x04\\xcc\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@\"", "ispf": {"version": "02.00", "flags": 0, "createdate": "2011-10-26T00:00:00", "modifydate": "2011-10-26T09:27:58", "lines": 1228, "newlines": 1228, "modlines": 0, "user": "CLEMSON"}, "text": "*---------------------------------------------------------------------*\n*  Copyright 2011 by Clemson University Research Foundation           *\n*                                                                     *\n*  Licensed under the Apache License, Version 2.0 (the \"License\");    *\n*  you may not use this file except in compliance with the License.   *\n*  You may obtain a copy of the License in this library as member     *\n*  $LICENSE, or from                                                  *\n*                                                                     *\n*      http://www.apache.org/licenses/LICENSE-2.0                     *\n*                                                                     *\n*  Unless required by applicable law or agreed to in writing,         *\n*  software distributed under the License is distributed on an \"AS    *\n*  IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either    *\n*  express or implied.  See the License for the specific language     *\n*  governing permissions and limitations under the License.           *\n*---------------------------------------------------------------------*\nSRVMS TITLE 'MVS Message Service Processor'\n         SMLIST CONVERT=YES           |\n         srvmod name=srvms,dates='1989, 1990, 1995'\n         gblc  &srv_modname\n*---------------------------------------------------------------------*\n*\n*  Copyright (C) Clemson University Research Foundation 1989, 1990.\n*\n*  Program     SRVMS, MVS Message Service Processor.\n*\n*  Abstract    This service processor is MVS dependent and provides\n*              standardized message services.\n*\n*  Parameters:\n*\n*    MS_Start\n*      CALLX SRVMS,(MS_token,&MS_Start,ESV,\n*                      msgmod_csect_list_address,maxsev,sizelength,\n*                      option_byte,option_specific_parameters)\n*\n*    MS_Terminate\n*      CALLX SRVMS,(MS_token,&MS_Terminate)\n*\n*\n*    MS_Issue_Message\n*      CALLX SRVMS,(MS_token,&MS_Issue_Message,\n*                      message_ID,source1,source2,...)\n*\n*    MS_Get_Message\n*      CALLX SRVMS,(MS_token,&MS_Get_Message,\n*                      message_ID,target,target_length,result_length,\n*                      source1,source2,...)\n*\n*    The meaning of each parameter is explained below.\n*\n*    MS_ID is a fullword used to uniquely identify the invocation of\n*      the Print_Line service processor.  It is initialized during the\n*      startup function.\n*\n*    FunctionCode is a fullword integer that specifies the function to\n*      be performed.  Symbolic identifiers are provided for each\n*      function and may be accessed by placing a COPY statement for\n*      SRVMSMAC in the assembler program.  These symbols should be\n*      used in place of actual integer values.  The following\n*      FunctionCodes are supported:\n*\n*      &MS_Start                   =  1\n*        Identify the ddname that points to the report file, set the\n*        maximum page and line lengths.\n*\n*      &MS_Terminate               =  2\n*        Shutdown this invocation.  This function causes any incomplete\n*        pages to be completed and closes the report file.\n*\n*\n*      &MS_Issue_Message           =  3\n*        Formats and prints a message based on the user's format\n*        specifications.\n*\n*      &MS_Get_Message             =  4\n*        Formats and returns the text of a message.\n*\n*      &MS_Put_Message             =  5\n*        Routes the message text provided by the caller to the\n*        current message destination.  As this function sort of\n*        defeats the purpose of Message Services, its use is not\n*        recommended except for applications that really need it.\n*\n*    ESV is a fullword given to the application by the Server Manager\n*      when it was started up.\n*\n*    DDName specified the DDName of the report file.  This file will\n*      be a RECFM=VBA file.  Its blocksize will default to (LRECL+4),\n*      unless overridden by JCL.\n*\n*\n*  Return codes:\n*\n*   &MS_Invalid_Function\n*      An invalid function was specified.\n*   &MS_Invalid_Number_Of_Parms\n*      An invalid number of parameters for a specific function was\n*      specified.\n*   &MS_Invalid_MS_ID\n*      The service processor token does not point to the correct data.\n*   &MS_Environment_Support_Error\n*      The Environment Support service processor returned an error.\n*   &MS_Printline_Error\n*      The Printline service processor returned an error.\n*   &MS_Print_Line_Truncated\n*      The length of the caller-provided string or the formatted string\n*      exceeded the maximum line length.  The truncated line is printed\n*      before control is returned to the caller.\n*\n*  Program     Reentrant, key and state of caller, server linkage,\n*  Attributes  authorization of caller, AMODE(any), RMODE(any)\n*\n*  Change\n*  History   2011/10/20 JCB - Patch rollup for CBT tape distribution\n*\n*  Method of\n*  Operation   Refer to the code\n*\n*\n*  Special Notes:\n*\n*---------------------------------------------------------------------*\n space 1                              |\n print off                            |\n copy  smsyms                         | Structured Macros symbols.\n copy  srvesmac                       | Environment support symbols.\n copy  srvdtmac                       | Date services symbols.      @C2\n copy  srvstmac                       | String Formatter symbols.\n copy  srvplmac                       | Print Line symbols.\n copy  srvmsmac                       | Message symbols.\n print on,gen                         |\n eject                                |\n**--------------------------------------------------------------------*\n**\n**  Identify the service processors that Message will use.\n**\n**--------------------------------------------------------------------*\n       space 1                        |\n es_id         id=ES,                 |                                *\n               spepa=pwa_ES_epa,      |                                *\n               sptoken=pwa_ES_token,  |                                *\n               esva=pwa_esv           |\n       space 1                        |\n PL_id         id=PL,                 |                                *\n               spepname=&Print_Line,  |                                *\n               spepa=pwa_PL_epa,      |                                *\n               sptoken=pwa_PL_token,  |                                *\n               esid=ES                |\n       space 1                        |\n st_id         id=ST,                 |                                *\n               spepname=&String_Handler,                               *\n               spepa=pwa_ST_epa,      |                                *\n               sptoken=pwa_ST_token,  |                                *\n               esid=ES                |\n       space 1                        |                             @C2\n dt_id         id=DT,                 |                             @C2*\n               spepa=pwa_DT_epa,      |                             @C2*\n               sptoken=pwa_DT_token,  |                             @C2*\n               esid=ES                |                             @C2\n       space 1                        |\n eject                                |\n block name=&srv_modname,type=program,amode=31,rmode=any,              +\n               options=(*srvprc,noclearpwa,(parms,(using,r11))),       +\n               subopts=*swa,parmmap=parmlist,basereg=(r12,r10)\n* *-------------------------------------------------------------------*\n* * Determine how many parameters were passed and load r1 with\n* * function code.\n* *-------------------------------------------------------------------*\n  la    r1,parmlist                   | Point r1 to parameter list.\n  la    r15,prm_max_#                 | Load r15 with maximum # parms.\n  loop bct                            | Loop\n   leave loop=*,(tbit,0(r1),x'80')    |  End of parms if high bit set.\n   la   r1,4(,r1)                     |  Point to next parm address.\n  endloop bct,r15                     | Endloop\n  la    r0,prm_max_#+1                | Calculate number of\n  sr    r0,r15                        |  parms.  Ok if 2 <= num <= max\n  sth   r0,pwa_number_of_parms        | Save number of parms.\n  errexit (ch,r0,lt,=y(prm_min_#)),or,(ch,r0,gt,=y(prm_max_#)),        +\n               code=&MS_invalid_number_of_parms\n  l     r1,prm_functioncode           | Load the function code into\n  l     r1,0(,r1)                     |   a register for testing.\n* *-------------------------------------------------------------------*\n* * If the function code is something other than start, make sure that\n* * the PWA contains the eye-catcher string and the correct value for\n* * MS_ID.   If not, then the MS_ID passed in is garbage.\n* *-------------------------------------------------------------------*\n  if (c,r1,ne,=f'&MS_start')          | If not startup function then\n   errexit ((clc,pwa_visual,ne,eyecatcher),or,(c,r13,ne,pwa_MS_id)),   +\n               code=&MS_invalid_MS_id |  go off and croak.\n   lr    r2,r1                        |  Save function code\n   es_clear_debug_info id=ES          |  Clear debug info\n   lr    r1,r2                        |  Restore function code.\n  endif                               | Endif.\n  eject ,                             |\n* *-------------------------------------------------------------------*\n* * Select the code to process the function.\n* *-------------------------------------------------------------------*\n  caseblk reg=r1                      | Start of function case block.\n  eject                               |\n*  *------------------------------------------------------------------*\n*  *\n*  * Start function.\n*  *\n*  *------------------------------------------------------------------*\n   case &MS_start                     |  Start function.\n*   *-----------------------------------------------------------------*\n*   * Set the eyecatcher and the MS_ID fields.   These are checked\n*   * each time the PL server is entered to avoid integrity\n*   * problems.\n*   *-----------------------------------------------------------------*\n    mvc   pwa_visual,eyecatcher       |   Both the eyecatcher and the\n    st    r13,pwa_MS_id               |   MS_ID are for validity checks\n    xc    pwa_clear_start(pwa_clear_length),pwa_clear_start\n    mvi   pwaf1,x'00'                 |   Clear working flag        @C6\n*   *-----------------------------------------------------------------*\n*   * Make sure that a valid number of parameters are specified.\n*   *-----------------------------------------------------------------*\n    lh    r3,pwa_number_of_parms      |   Load r3 with number of parms.\n    errexit    (ch,r3,lt,=y(prm_start_min_#)),or,   Error if out       +\n               (ch,r3,gt,=y(prm_start_max_#)),      of bounds.         +\n               code=&MS_invalid_number_of_parms\n*   *-----------------------------------------------------------------*\n*   *  Set SizeLength value.\n*   *-----------------------------------------------------------------*\n    la    r1,&MS_default_sizelength   | Set default sizelength\n    l     r2,prm_start_sizelength     | Get the parm\n    l32   r2,0(r2)                    | Get the value\n    errexit (ch,r2,gt,=h'4'),         |                                *\n               code=&ms_invalid_sizelength\n    if    nz                          | If it's nonzero,\n     lr    r1,r2                      |  we'll use that.\n    endif                             |\n    st    r1,pwa_sizelength           |\n    bctr  r1,0                        | r1 := offset into bit-masks\n    la    r1,psd_bit_mask(r1)         | r1 -> bit-mask for icm/stcm's.\n    l8    r0,0(r1)                    | r0 := bit-mask for icm/stcm's.\n    st    r0,pwa_size_mask            | save for dealing w/ lengths.\n         eject                        |\n*   *-----------------------------------------------------------------*\n*   * Start the Environment Support service processor.\n*   *-----------------------------------------------------------------*\n*   ES_MVS_Load id=ES                 | Bootstrap in env. support\n*   ES_Start   id=ES                  | Start environment support\n    l    r1,prm_start_esv             |\n    l    r1,0(r1)                     |\n    st   r1,pwa_esv                   |\n    using esv,r1                      |\n    mvc   pwa_es_epa,esvesepa         |\n    mvc   pwa_es_token,esvestkn       |\n    drop  r1                          |\n         space 1                      |\n    l     r2,prm_start_dest_option    |\n*   *-----------------------------------------------------------------*\n*   * If MSGDEST uses a DDname, set up for starting Printline.  We\n*   * won't actually start Printline until we know the FOLD option.\n*   *-----------------------------------------------------------------*\n    if    (cli,0(r2),eq,prm_destopt_DDname) Is MSGDEST 'DDNAME,thing?'\n     sbit pwaf1spl                    | Note we need to start Printline\n     l     r1,prm_start_dest_DDname   |\n     mvc   pwa_ddname,0(r1)           |\n     ES_Load_Module  id=ES,spid=PL    | Load Printline (we'll start\n     errexit   (treg,r15,nz),         |  it a little later).           *\n               code=&MS_environment_support_error\n     la    r5,prm_destopt_DDname_#    |                             @C1\n*   *-----------------------------------------------------------------*\n*   * If MSGDEST uses an existing Printline session, save EPA, token.\n*   *-----------------------------------------------------------------*\n    elseif (cli,0(r2),eq,prm_destopt_pl)  Does MSGDEST say PL,stuff?\n     l     r3,prm_start_dest_plepa    |  Copy existing Printline\n     mvc   pwa_pl_epa,0(r3)           |  session's EPA and token.\n     l     r3,prm_start_dest_pltoken  |\n     mvc   pwa_pl_token,0(r3)         |\n     sbit  pwaf1epl                   | Note use of existing PrintLine.\n     la    r5,prm_destopt_PL_#        |                             @C1\n*   *-----------------------------------------------------------------*\n*   * If MSGDEST specifies CONSOLE, we don't need to do anything (now).\n*   *-----------------------------------------------------------------*\n    elseif (cli,0(r2),eq,prm_destopt_console)  Is MSGDEST 'CONSOLE'?\n     sbit  pwaf1cns                   | Note it for later\n     la    r5,prm_destopt_console_#   |                             @C1\n*   *-----------------------------------------------------------------*\n*   * If MSGDEST was not specified, we need to fail Issue_Msg later.\n*   *-----------------------------------------------------------------*\n    elseif (cli,0(r2),eq,prm_destopt_nodest)  Is MSGDEST missing?\n     sbit  pwaf1nmd                   | Note it for later\n     la    r5,prm_destopt_nodest_#    |                             @C1\n*   *-----------------------------------------------------------------*\n*   * Unknown MSGDEST option: return error to caller.\n*   *-----------------------------------------------------------------*\n    else                              |\n     errexit code=&ms_invalid_msgdest_option\n    endif                             |\n    bctr  r5,0                        | Turn parm count into offset @C1\n    sll   r5,2                        | * 4 for disp into parmlist  @C1\n    alr   r5,r11                      | Add parmlist base for addr  @C1\n    if    (tbit,0(r5),x'80',off)      | If this wasnt last parm:    @C1\n     l     r1,4(r5)                   |  Next parm is OPTIONS       @C1\n     mvc   pwaop,0(r1)                |  Copy options byte to PWA.  @C1\n    endif                             |                             @C1\n*   *---------------------------------------------------------------@C2\n*   * If timestamp was specified, load and start date service       @C2\n*   * processor.                                                    @C2\n*   *---------------------------------------------------------------@C2\n    if (tbit,pwaoptim)                |   If timestamp option:      @C2\n     es_load_module  id=es,spid=dt    |    Load date srv processor. @C2\n     errexit not,(%es_success),       |                             @C2*\n               code=&ms_environment_support_error                   @C2\n     dt_start id=dt                   |    Start date service.      @C2\n     errexit not,(%es_success),code=&ms_dt_error                    @C2\n    endif                             |   Endif.                    @C2\n*   *-----------------------------------------------------------------*\n*   * Start Printline, with or without the FOLD option as requested.\n*   *-----------------------------------------------------------------*\n    if    (tbit,pwaf1spl)             |  With fold option or not?   @C1\n     if    (tbit,pwaopfld)            |  With fold option or not?   @C1\n      PL_Start ID=PL,                 |  Start PrintLine w/FOLD     @C1*\n               DDname=pwa_ddname,     |                             @C1*\n               options=fold,          |                             @C1*\n               SizeLength=pwa_sizelength                            @C1\n     else                             | Else (boy, this is lazy)    @C1\n      PL_Start ID=PL,                 |  Start PrintLine w/o FOLD.  @C1*\n               DDname=pwa_ddname,     |                             @C1*\n               SizeLength=pwa_sizelength                            @C1\n     endif                            |                             @C1\n     errexit   ((treg,r15,nz),and,not,(%pl_line_wrapping)),         @C4*\n               code=&MS_Printline_error                             @C1\n    endif                             | Note we started a PrintLine @C1\n*   *-----------------------------------------------------------------*\n*   * Always start a String Formatter session, since the caller may\n*   * want to use MS_Get_Message whether he's using PrintLine or not.\n*   *-----------------------------------------------------------------*\n    sbit  pwaf1sst                    | Note we started a String Hdlr\n    ES_Load_Module  id=ES,spid=ST     | Load string formatter.\n    errexit    (treg,r15,nz),         |                                *\n               code=&ms_environment_support_error\n    ST_Start   ID=ST,                 | Start string formatter.        *\n               SizeLength=pwa_sizelength\n    errexit    (treg,r15,nz),         |                                *\n               code=&ms_string_handler_error\n          eject ,                     |\n*   *-----------------------------------------------------------------*\n*   * If MaxSev was specified, save the MaxSev halfword's address and\n*   * note that it's present.\n*   *-----------------------------------------------------------------*\n    l32   r2,prm_start_max_severity   | Get MaxSev field's address\n    if    nz                          | If parm is present\n     sbit  pwaf1mxs                   |  Flag that it's there\n     st    r2,pwa_maxsev_address      |   and save MaxSev's address.\n    endif                             |\n*   *-----------------------------------------------------------------*\n*   * If PLCC was specified, copy the ASA CC byte for Printline to\n*   * local storage: if not provided, default it to a blank.\n*   *-----------------------------------------------------------------*\n    l32   r2,prm_start_printline_cc   | Get PLCC field's address\n    if    nz                          | If parm is present\n     mvc   pwa_printline_cc,0(r2)     |  Copy byte to PWA\n    else                              | Otherwise\n     mvi   pwa_printline_cc,c' '      |  default it to a space.\n    endif                             |\n*   *-----------------------------------------------------------------*\n*   * Load the message modules.  Validate each one as it's loaded, and\n*   * complain if it doesn't have the right prolog.\n*   *-----------------------------------------------------------------*\n    l32  r2,prm_start_message_modlist | Get module list from caller\n    errexit z,code=&ms_msgmod_missing | Parm missing? Report error.\n    l32  r3,0(r2)                     | Get module count\n    errexit z,code=&ms_msgmod_missing | No modules? Report error.\n    errexit    (ch,r3,gt,=h'25'),     | More than we wanna handle?     *\n               code=&ms_too_many_msgmods  Report as error.\n    st    r3,pwa_msgmod_count         | Save module count\n    la    r4,4(r2)                    | Point to 1st CL8 modulename\n    fill  pwa_msgmod_list,x'00',      | Wipe out message module list   *\n               length=(pwa_msgmod_list_length,medium)\n    la    r5,pwa_msgmod_list          | Point to our module list\n    loop  bct                         | Loop thru caller's module list:\n     mvc  dsp_msgmod_name(8,r5),0(r4) |  Copy module name to local stg\n     es_load_module ID=ES,            |  Load the module               *\n               epname=dsp_msgmod_name(r5),                             *\n               epa=dsp_msgmod_mmp(r5) |\n     errexit (treg,r15,nz),           |  Not loaded? Report error.     *\n               code=&ms_msgmod_not_loaded\n     l     r1,dsp_msgmod_mmp(r5)      |  Point to start of MSG mod. @C3\n     if (clc,=c'OF',eq,0(r1))         |  If mod begins with c'OF':  @C3\n      ah    r1,2(,r1)                 |   2nd halfword is offset of @C3\n      st    r1,dsp_msgmod_mmp(r5)     |   of MMP. Fixup MMP pointer.@C3\n     endif                            |  Endif.                     @C3\n     using mmp_start,r1               |  Ensure msg module is vaild:@C3\n     st    r1,pwa_current_mmp         |  Save for ERREXIT if needed\n     errexit   (clc,mmp_id,ne,=a(mmp_id_text)),or,  Make sure MMP ID & *\n               (clc,mmp_module_name,ne,0(r5)),  CSECT name match what  *\n               code=&ms_msgmod_not_valid        a msg module oughta be.\n     drop  r1                         |\n     la    r4,8(r4)                   |  Point to caller's next module\n     la    r5,12(r5)                  |  Point to next modlist entry\n    endloop bct,r3                    | That's it.\n*   *-----------------------------------------------------------------*\n   eject                              |\n*  *------------------------------------------------------------------*\n*  *\n*  * Terminate function.\n*  *\n*  *------------------------------------------------------------------*\n   case &MS_terminate                 |\n*   *-----------------------------------------------------------------*\n*   * If a PrintLine session was started, shut it down.\n*   *-----------------------------------------------------------------*\n    if    (tbit,pwaf1spl)             |\n     PL_Terminate  ID=PL              |\n     ES_Unload_Module  id=ES,spid=PL  | Get rid of PL's loadmodule\n    endif                             |\n*   *-----------------------------------------------------------------*\n*   * If a String Handler session was started, shut it down.\n*   *-----------------------------------------------------------------*\n    if    (tbit,pwaf1sst)             |\n     ST_Terminate ID=ST               |\n     ES_Unload_Module  id=ES,spid=ST  | Get rid of ST's loadmodule\n    endif                             |\n*   *-----------------------------------------------------------------*\n*   * Unload all message modules that MS_START loaded.\n*   *-----------------------------------------------------------------*\n    l     r3,pwa_msgmod_count         |\n    la    r4,pwa_msgmod_list          |\n    loop  bct                         |\n     es_unload_module id=es,          |                                *\n               epname=dsp_msgmod_name(r4)\n     la    r4,12(r4)                  |\n    endloop bct,r3                    |\n*   *---------------------------------------------------------------@C2\n*   * If timestamp was specified, terminate and unload date service @C2\n*   * processor.                                                    @C2\n*   *---------------------------------------------------------------@C2\n    if (tbit,pwaoptim)                |   If timestamp option:      @C2\n     dt_terminate id=dt               |    Terminate date service.  @C2\n     errexit not,(%es_success),code=&ms_dt_error                    @C2\n     es_unload_module id=es,spid=dt   |    Unload service processor.@C2\n     errexit not,(%es_success),       |                             @C2*\n               code=&ms_environment_support_error                   @C2\n    endif                             |   Endif.                    @C2\n*   *-----------------------------------------------------------------*\n*   * Indicate PWA should be freed.\n*   *-----------------------------------------------------------------*\n    smctrl freepwa=yes                |   Free the PWA on return.\n*   *-----------------------------------------------------------------*\n   eject                              |\n*  *------------------------------------------------------------------*\n*  *\n*  * Issue_Message function.\n*  *\n*  *------------------------------------------------------------------*\n   case &MS_issue_message             |\n    lh    r3,pwa_number_of_parms      |   Load number of parameters.\n    errexit    (ch,r3,lt,=y(prm_issuemsg_min_#)),or,  Exit if wrong    *\n               (ch,r3,gt,=y(prm_issuemsg_max_#)),      no. of parms.   *\n               code=&MS_invalid_number_of_parms\n        space 1                       |\n    errexit    (tbit,pwaf1nmd),       |                                *\n               code=&MS_msgdest_not_provided\n        space 1                       |\n    l     r2,prm_issuemsg_msgid       |\n    callsub lookup_and_copy_message,((r2)) | See if message defined\n    if    (treg,r15,nz)               | If not:\n     errexit (ch,r15,eq,=h'4'),       |  If RC 4                       *\n               code=&ms_message_not_found the message was not defined\n     errexit (ch,r15,eq,=h'8'),       |  If RC 8                       *\n               code=&ms_invalid_prefix    the prefix wasn't loaded.\n    endif                             |\n    lr    r3,r1                       | Copy MSE pointer\n    using mse_start,r3                |  and base on it\n    l     r5,pwa_base_msg_length      |\n    l     r15,pwa_size_mask           |\n    exi   r15,(stcm,r5,b'0000',pwa_msglength_adj)\n       space 1                        |\n    if    not,(tbit,(pwaf1spl+pwaf1epl),off)\n*    *----------------------------------------------------------------*\n*    * Build PrintLine parameter list\n*    *----------------------------------------------------------------*\n     plist    (pwa_PL_token,          | 1: String Formatter's token    *\n               &PL_print_formatted,   | 2: Function code               *\n               pwa_base_message,      | 3: Control string              *\n               pwa_msglength_adj),    | 4: Adjusted msg. length        *\n               pl=(pwa_PL_format_pl,57),   Build it here,              *\n               novl                   | and don't flip no x'80' bits.\n     lr    r7,r1                      |\n     if    (clc,pwa_number_of_parms,eq,=y(prm_issuemsg_min_#))\n      sbit  12(r7),x'80'              |\n     else                             |\n      callsub build_sourcelist,       |                                *\n               (16(r7),               |                                *\n               prm_issuemsg_sourcelist)\n     endif                            |\n     lr    r1,r7                      | Restore ptr to parmlist start\n     callx pwa_pl_epa                 | Call formatted Printline.\n     errexit   (treg,r15,nz),         |                                *\n               code=&ms_printline_error\n    elseif (tbit,pwaf1cns)            | Else if issuing to console(s)\n     la    r1,l'pwa_formatted_message |\n     st    r1,pwa_formatted_msg_length\n     if    (clc,pwa_number_of_parms,eq,=y(prm_issuemsg_min_#))\n      xr    r2,r2                     | If no sourcelist, wipe pointer\n     else                             |\n      la    r2,prm_issuemsg_sourcelist  Otherwise, point to the list.\n     endif                            |\n     callsub   format,                |  Format the message            *\n               (pwa_base_message,     |                                *\n               pwa_msglength_adj,     |                                *\n               pwa_formatted_message, |                                *\n               pwa_formatted_msg_length,                               *\n               (r2))                  |\n     es_display_message id=ES,        |    ... and write it out.       *\n               message=(pwa_formatted_message,pwa_formatted_msg_length)\n    endif                             |\n*   *-----------------------------------------------------------------*\n*   * If MaxSev was specified, adjust caller's MAXCC as needed.\n*   *-----------------------------------------------------------------*\n    if    (tbit,pwaf1mxs)             | Need to keep up w/MAXSEV?\n     l     r15,pwa_maxsev_address     | Get user's maxCC halfword\n     if    (clc,mse_severity,gt,0(r15)) Is it less than MSE's severity?\n      mvc   0(2,r15),mse_severity     |  Then copy it over.\n     endif                            |\n    endif                             |\n    drop  r3                          |\n*   *-----------------------------------------------------------------*\n   eject                              |\n*  *------------------------------------------------------------------*\n*  *\n*  * Get_Message function.\n*  *\n*  *------------------------------------------------------------------*\n   case &MS_get_message               |\n    lh    r3,pwa_number_of_parms      |   Load number of parameters.\n    errexit    (ch,r3,lt,=y(prm_getmsg_min_#)),or,  Exit if wrong      *\n               (ch,r3,gt,=y(prm_getmsg_max_#)),      no. of parms.     *\n               code=&MS_invalid_number_of_parms\n        space 1                       |\n    l     r2,prm_getmsg_msgid         |\n    callsub lookup_and_copy_message,((r2)) | See if message is around\n    if    (treg,r15,nz)               | If not:\n     errexit (ch,r15,eq,=h'4'),       |  If RC 4                       *\n               code=&ms_message_not_found the message was not defined\n     errexit (ch,r15,eq,=h'8'),       |  If RC 8                       *\n               code=&ms_invalid_prefix    the prefix wasn't loaded.\n    endif                             |\n    lr    r3,r1                       | Copy MSE pointer\n    using mse_start,r3                |  and base on it\n    l     r5,pwa_base_msg_length      |\n    l     r15,pwa_size_mask           |\n    exi   r15,(stcm,r5,b'0000',pwa_msglength_adj)\n    la    r1,l'pwa_formatted_message  |\n    st    r1,pwa_formatted_msg_length |\n    if    (clc,pwa_number_of_parms,eq,=y(prm_getmsg_min_#))\n     xr    r2,r2                      | If no sourcelist, wipe pointer\n    else                              |\n     la    r2,prm_getmsg_sourcelist   | Otherwise, point to the list.\n    endif                             |\n    callsub    format,                |  Format the message            *\n               (pwa_base_message,     |                                *\n               pwa_msglength_adj,     |                                *\n               pwa_formatted_message, |                                *\n               pwa_formatted_msg_length,                               *\n               (r2))                  |\n*   *-----------------------------------------------------------------*\n*   * Return formatted string to caller.  It may get truncated.\n*   *-----------------------------------------------------------------*\n    l     r2,prm_getmsg_target        | Point to target\n    l     r1,prm_getmsg_target_length | Point to target's length\n    l     r1,0(r1)                    | Get target length value\n    if    (c,r1,lt,pwa_formatted_msg_length)  If message won't fit\n     sbit pwaf1trn                    |   Note that it got whacked\n    else                              |  Otherwise\n     l    r1,pwa_formatted_msg_length |   use the formatted length.\n    endif                             |\n    l    r14,prm_getmsg_result_length | Point to where resultlen goes\n    l    r15,pwa_size_mask            | Get sizelength mask\n    exi  r15,(stcm,r1,b'0000',0(r14)) | Return resultlen to caller\n    bctr r1,0                         | Fix up length for EXECUTE\n    exi  r1,(mvc,0(0,r2),pwa_formatted_message)  Give string to caller.\n*   *-----------------------------------------------------------------*\n*   * If MaxSev was specified, adjust caller's MAXCC as needed.\n*   *-----------------------------------------------------------------*\n    if    (tbit,pwaf1mxs)             | Need to keep up w/MAXSEV?\n     l     r15,pwa_maxsev_address     | Get user's maxCC halfword\n     if    (clc,mse_severity,gt,0(r15)) Is it less than MSE's severity?\n      mvc   0(2,r15),mse_severity     |  Then copy it over.\n     endif                            |\n    endif                             |\n    drop  r3                          |\n*   *-----------------------------------------------------------------*\n   eject                              |\n*  *------------------------------------------------------------------*\n*  *\n*  * Put_Message function.\n*  *\n*  *------------------------------------------------------------------*\n   case &MS_put_message               |\n    lh    r3,pwa_number_of_parms      |   Load number of parameters.\n    errexit    (ch,r3,lt,=y(prm_putmsg_min_#)),or,  Exit if wrong      *\n               (ch,r3,gt,=y(prm_putmsg_max_#)),      no. of parms.     *\n               code=&MS_invalid_number_of_parms\n        space 1                       |\n    errexit    (tbit,pwaf1nmd),       |                                *\n               code=&MS_msgdest_not_provided\n        space 1                       |\n    l     r2,prm_putmsg_strlen\n    l     r15,pwa_size_mask\n    exi   r15,(icm,r1,0,0(r2))        | Get length of provided string\n    exi   r15,(stcm,r1,0,pwa_msglength_adj)\n    st    r1,pwa_formatted_msg_length | Save for later\n    l     r2,prm_putmsg_string\n    bctr  r1,0\n    exi   r1,(mvc,pwa_formatted_message(0),0(r2))\n    if    (tbit,pwaopfld)             | If folding to uppercase     @C1\n     callsub fold_output,                                              *\n               (pwa_formatted_message,pwa_formatted_msg_length)\n    endif                             |                             @C1\n    if    not,(tbit,(pwaf1spl+pwaf1epl),off)\n*    *----------------------------------------------------------------*\n*    * Msgdest = Printline: Build PrintLine parameter list\n*    *----------------------------------------------------------------*\n     callx pwa_pl_epa,                | Call basic Printline:          *\n               (pwa_PL_token,         | 1: String Formatter's token    *\n               &PL_print,             | 2: Function code               *\n               pwa_formatted_message, | 3: Message string              *\n               pwa_msglength_adj),vl  | 4: Adjusted msg. length\n     errexit   (treg,r15,nz),         |                                *\n               code=&ms_printline_error\n    elseif (tbit,pwaf1cns)            | Else if issuing to console(s)\n*    *----------------------------------------------------------------*\n*    * Msgdest = Console: Call ES_Display Message to do a WTO.\n*    *----------------------------------------------------------------*\n     es_display_message id=ES,        |    ... and write it out.       *\n               message=(pwa_formatted_message,pwa_formatted_msg_length)\n    endif                             |\n*   *-----------------------------------------------------------------*\n   eject                              |\n*  *------------------------------------------------------------------*\n*  * If any other case, this is an invalid function.\n*  *------------------------------------------------------------------*\n   case other                         | Unknown functioncode?\n    errexit code=&MS_invalid_function |  Return error to caller.\n  endcase                             |\n space 1                              |\n* *-------------------------------------------------------------------*\n* *  When exiting, see if we truncated a print line: if so, return a\n* *  \"truncated\" return code, else set returncode zero.\n* *-------------------------------------------------------------------*\n  if    (tbit,pwaf1trn)               | Did we truncate a print line?\n   rbit  pwaf1trn                     |  Turn the flag off\n   errexit code=&MS_print_line_truncated  and save error info\n  else                                | Otherwise,\n   xr    r15,r15                      |  end normally w/RC zero.\n  endif                               |\n space 1                              |\n endblk block=&srv_modname,rc=(r15)   |\n eject                                |\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Build_Sourcelist\n*  Purpose:    Append a list of \"source\" parameters to the end of a\n*              standard parameter list.\n*  Parameters: On entry, R1 points to the following parameter list:\n*                +0 -- Address in dest. parmlist to start stuffing\n*                +4 -- List of \"source\" parameters\n*  Calls:      None\n*  Notes:      There should be at least 1 parameter in the source list.\n*\n*---------------------------------------------------------------------*\n block name=build_sourcelist,type=subroutine\n  lm    r2,r3,0(r1)                   | Get dest, source list pointers\n  loop  until                         | Loop thru list til 80 bit found\n   l     r14,0(r3)                    |  Get a parm\n   la    r14,0(r14)                   |  Make sure the 80 bit is off\n   st    r14,0(r2)                    |  Save into ST_FORMAT parmlist.\n   leave loop=*,(tbit,0(r3),x'80')    |  Quit if we moved the last one\n   la    r2,4(r2)                     |  Point to next dest and\n   la    r3,4(r3)                     |   next sourceparm\n  endloop until,leave                 |    and go move them.\n  sbit  0(r2),x'80'                   |  Set VL bit at end of VL plist\n endblk                               | That's it.\n        eject ,                       |\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Lookup_And_Copy_Message\n*  Purpose:    Scan the message module(s) loaded by MS_START for the\n*              caller-provided message ID.  If the msg is found, it is\n*              copied to pwa_base_message after being prefixed by an\n*              ASA CC character is needed.  The new string's length is\n*              in pwa_base_msg_length.\n*  Parameters: On entry, R1 points to the following parameter list:\n*                +0 -- Message ID text address\n*  Calls:      None\n*  Returns:    R15 = 0: Message found, MSE address in R1\n*              R15 = 4: Message not found\n*              R15 = 8: Message's prefix not contained in any MMP\n*                PWA_Base_Message contains the message, prefixed as\n*                necessary with the Printline ASA CC byte.\n*\n*---------------------------------------------------------------------*\n block name=lookup_and_copy_message,type=subroutine,amode=31\n  l     r3,pwa_msgmod_count           | Get module count\n  la    r4,pwa_msgmod_list            | Point to our module list\n  l     r7,0(r1)                      | Point to MSGID text\n  rbit  pwaf1pfx                      |\n  loop  bct,name=mmp_scan             | Loop thru caller's module list:\n   l     r2,dsp_msgmod_mmp(r4)        | Ensure msg module is valid: @C3\n   using mmp_start,r2                 |\n   st    r2,pwa_current_mmp           |  Save MMP addr for ERREXIT\n   l8    r15,mmp_prefix_length        | Get MMP's prefix length\n   bctr  r15,0                        | Fix up for VL compares\n   exi   r15,(clc,mmp_prefix(0),0(r7))  See if prefix is in MMP:\n   if    eq                           | If so:\n    sbit  pwaf1pfx                    |  Note that we found the prefix\n    l     r6,mmp_first_mse            |  Get starting MSE pointer\n    using mse_start,r6                |\n    l32   r5,mmp_mse_count            |   and how many MSE's there are\n    if    nz                          |  If any MSE's exist\n     loop  bct,name=mse_scan          |   Loop thru them:\n      l     r1,mse_address_text       |   Point to message text\n      l8    r15,mmp_id_length         |   Get MMP's msgID length\n      bctr  r15,0                     |   Fix length up for VL compare\n      exi   r15,(clc,0(0,r1),0(r7))   |   Do message ID's match?\n      leave loop=mmp_scan,(eq)        |    Yes: R6 points to MSE.\n      ah    r6,mmp_mse_element_size   |   Otherwise, point to next MSE\n     endloop bct,r5                   |  and loop through them all.\n    endif                             |\n    drop  r6                          |\n   endif                              |\n   la    r4,12(r4)                    |  Point to next modlist entry\n  endloop bct,r3                      |\n  if    (treg,r3,z)                   | If we ran out without a hit:\n   if    (tbit,pwaf1pfx,on)           |  If we found the prefix\n    la    r15,4                       |   Message ID was missing\n   else                               |  Otherwise (bad prefix)\n    la    r15,8                       |   Return \"prefix_error\"\n   endif                              |\n  else                                | Else (we found it)\n   using mse_start,r6                 |  Base on the MSE we found\n   if (tbit,pwaoptim)                 |  If timestamp option:       @C2\n    fill  &w.prefix,x'40'             |   Blank out prefix.         @C2\n    dt_get_current id=dt,             |   Get current time and date.@C2+\n               date=(&w.date,&dt_sortdate),                         @C5+\n               time=(&w.prefix_time,&dt_hhmmss)                     @C2\n    errexit not,(%dt_success),code=&ms_dt_error                     @C2\n    mvc  &w.prefix_date,&w.date       |???DT seems to wipe 11 bytes.@C2\n    if    (tbit,(pwaf1spl+pwaf1epl),off)  If not using Printline:   @C2\n     mvc   pwa_base_message(l'&w.prefix),&w.prefix                  @C2\n     la    r14,pwa_base_message+l'&w.prefix      Move prefix to msg.@C2\n    else                              |   Else:                     @C2\n     mvc   pwa_base_message(1),pwa_printline_cc  Stuff in ASA CC    @C2\n     mvc   pwa_base_message+1(l'&w.prefix),&w.prefix                @C2\n     la    r14,pwa_base_message+l'&w.prefix+1    Move prefix to msg.@C2\n    endif                             |   Endif.                    @C2\n    la    r0,pwa_base_message+l'pwa_base_message                    @C2\n    slr   r0,r14                      |   Calculate remaining len.  @C2\n    l8    r15,mse_length_text         |   Get message length.       @C2\n    if (cr,r15,gt,r0)                 |   If message longer than    @C2\n     lr    r0,r15                     |   remaining length, use     @C2\n*>>> issue error                      |   remaining length.         @C2\n    endif                             |                             @C2\n    bctr  r15,0                       |   Fix up for Execute        @C2\n    l     r1,mse_address_text         |   Point to text itself      @C2\n    exi   r15,(mvc,0(0,r14),0(r1))    |   Move message text to msg. @C2\n    la    r15,1(r15,r14)              |   Calculate                 @C2\n    la    r0,pwa_base_message         |   total length              @C2\n    slr   r15,r0                      |   of message.               @C2\n   else                               |  Else if not timestamp opt  @C2\n    l8    r15,mse_length_text         |   Get message length        @C2\n    bctr  r15,0                       |   Fix up for Execute        @C2\n    l     r1,mse_address_text         |   Point to text itself      @C2\n    if    (tbit,(pwaf1spl+pwaf1epl),off)  If not using Printline:   @C2\n     exi   r15,(mvc,pwa_base_message(0),0(r1))  Copy w/o ASA CC     @C2\n     la    r15,1(r15)                 |         Restore original len@C2\n    else                              |   Otherwise (tag on ASA CC) @C2\n     exi   r15,(mvc,pwa_base_message+1(0),0(r1)) Copy, offset by 1  @C2\n     mvc   pwa_base_message(1),pwa_printline_cc  Stuff in ASA CC    @C2\n     la    r15,2(r15)                 |          Add 1 to old length@C2\n    endif                             |   Endif.                    @C2\n   endif                              |  Endif.                     @C2\n   st    r15,pwa_base_msg_length      |  Set length of base message\n   lr    r1,r6                        |  Copy MSE ptr to R1 for STRSA\n   strsa r1                           |  Return R1 to caller\n   xr    r15,r15                      |  and set returncode zero.\n   drop  r6                           |\n  endif                               |\n endblk rc=(15)                       |\n space 3                              |                             @C2\n         swa                          |                             @C2\n&w.date         ds  cl11              |                             @C2\n&w.prefix_start equ *                 |                             @C2\n&w.prefix_date  ds  cl10              |                             @C5\n                ds  c                 |                             @C2\n&w.prefix_time  ds  cl8               |                             @C2\n                ds  c                 |                             @C2\n&w.prefix       equ &w.prefix_start,*-&w.prefix_start               @C2\n         endswa                       |                             @C2\n eject                                |\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Format\n*  Purpose:    Call the String Formatter to format the data provided\n*              by the caller.  Parameters are:\n*                +0 -- Address of the entire message\n*                +4 -- Address of message's length\n*                +8 -- Address of target string\n*               +12 -- Length of target string.  The resulting\n*                      formatted string length is returned here.\n*               +16 -- Address of beginning of source parm list, or 0\n*  Calls:      String Formatter (external, service processor)\n*\n*  Notes:      This routine was modified such that the message ID can't\n*              be inadvertently wiped by the String Formatter.  This is\n*              done by:\n*                .. Breaking the message into the message ID and text\n*                .. Formatting the text as requested by the caller\n*                .. Formatting the msgid and text back together,\n*                   returning the result to the caller.\n*\n*---------------------------------------------------------------------*\n block name=format,type=subroutine,amode=31\n  lm    r2,r6,0(r1)                   | Grab caller's parms\n  la    r6,0(r6)                      | Kill VL bit from parmlist\n  fill  0(r4),c' ',length=255         | Format may not clear printline\n  fill  &w.temp_target,c' '           | Clear work text fields\n  fill  &w.temp_msgid,c' '            |\n  l     r15,pwa_size_mask             | Get sizemask\n  la    r1,l'&w.temp_target           | Get real length of temp. target\n  exi   r15,(stcm,r1,b'0000',&w.tgtsize_adj)  and set up ST's length.\n  l     r7,pwa_current_mmp            | Point to current mmp\n  using mmp_start,r7                  |\n  l8    r1,mmp_id_length              | Get length of msgids\n  exi   r1,(mvc,&w.temp_msgid(0),0(r2)) Copy out the message ID\n  la    r1,1(,r1)                     | Add one for blank after msgid\n  drop  r7                            |\n  la    r7,0(r1,r2)                   | Point to text portion of msg\n  l     r14,pwa_size_mask             | Get the size mask\n  exi   r14,(icm,r15,b'0000',0(r3))   | Get length of full message\n  sr    r15,r1                        | Knock off length of msgid and\n  exi   r14,(stcm,r15,b'0000',&w.length_without_msgid)   save for ST.\n  plist       (pwa_st_token,          | 1: String Formatter's token    *\n               &st_format,            | 2: Function code               *\n               &w.temp_target,        | 3: Target area                 *\n               &w.tgtsize_adj,        | 4: Adjusted tgt. area size     *\n               &w.result_len,         | 5: Returned result length      *\n               (r7),                  | 6: Control string past msgid   *\n               &w.length_without_msgid), 7: Control string length      *\n               pl=(pwa_st_format_pl,57),   Build it here,              *\n               novl                   | and don't flip no x'80' bits.\n  lr    r7,r1                         | Save PLIST's parmlist pointer\n  if    (treg,r6,z)                   |\n   sbit  24(r7),x'80'                 | If no sourceparms, note end of\n  else                                | list: otherwise, let build_\n   callsub build_sourcelist,          | sourcelist figure it out.      *\n               (28(r7),(r6))          |\n  endif                               |\n  lr    r1,r7                         | Restore top-of-parmlist address\n  callx pwa_st_epa                    | Call ST_FORMAT w/custom parms.\n  if    (treg,r15,nz)                 | If formatter found a problem\n   if    (ch,r15,ne,=y(&st_truncated))   Was it truncation?\n    sbit  pwaf1trn                    |   Note that it got whacked\n   else                               |  Otherwise ...\n    errexit code=&MS_string_handler_error              Go choke.\n   endif                              |\n  endif                               |\n  l     r15,pwa_size_mask             | Get the size mask\n  l     r1,0(,r5)                     | Get length of final target\n  exi   r15,(stcm,r1,b'0000',&w.tgtsize_adj) Set it up for SRVST\n  la    r1,l'&s.final_format          | Get l'2nd format string\n  exi   r15,(stcm,r1,b'0000',&w.l_final_format) Set it up for SRVST\n  plist       (pwa_st_token,          | 1: String Formatter's token    *\n               &st_format,            | 2: Function code               *\n               (r4),                  | 3: Target string               *\n               &w.tgtsize_adj,        | 4: Adjusted target string len  *\n               &w.result_len,         | 5: Length of returned stuff    *\n               &s.final_format,       | 6: Control string              *\n               &w.l_final_format,     | 7: Adjusted control string len *\n               &w.temp_msgid,         | 8: Parm 1: message ID          *\n               &w.temp_target),       | 9: Parm 2: message text.       *\n               pl=(pwa_st_format_pl,9),vl  Build it here\n  callx  pwa_st_epa                   |\n* st_format    id=ST,                 |\n*              control=\"{CL15 T} {CL255 T}\",\n*              source=(&w.temp_msgid,&w.temp_target),\n*              string=((r4),&w.tgtsize_adj),\n*              resultlen=&w.result_len\n  if    (treg,r15,nz)                 | If formatter found a problem\n   if    (ch,r15,eq,=y(&st_truncated))   Was it truncation?\n    sbit  pwaf1trn                    |   Note that it got whacked\n   else                               |  Otherwise ...\n    errexit code=&MS_string_handler_error              Go choke.\n   endif                              |\n  endif                               |\n  xr    r1,r1                         |\n  l     r15,pwa_size_mask             | Get the SizeLength ICM mask\n  exi   r15,(icm,r1,0,&w.result_len)  | Get the length\n  st    r1,0(r5)                      | Save fullword length\n  if    (tbit,pwaopfld)               | If folding to uppercase     @C1\n   callsub fold_output,((r4),(r5))    |  call routine to do it.     @C1\n  endif                               |                             @C1\n endblk                               |\n       ssd   ,                        |\n&s.final_format  dc  c\"{CL15 T} {CL255 T}\"\n       endssd ,                       |\n       swa  ,                         |\n&w.tgtsize_adj  ds   f                |\n&w.result_len   ds   f                |\n&w.length_without_msgid  ds   f       |\n&w.l_final_format        ds   f       |\n&w.temp_msgid   ds   cl16             |\n&w.temp_target  ds   cl255            |\n       endswa ,                       |\n eject                                |\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Fold_Output\n*  Purpose:    Translate caller-provided output line (or line produced\n*              by String Handler) to uppercase.\n*  Parameters: On entry, R1 points to the following parameter list:\n*                +0 -- Address of record to translate\n*                +4 -- Address of fullword length of record\n*  Returned:   Output line folded in place\n*  Calls:      None\n*\n*---------------------------------------------------------------------*\n         SPACE 1                      |\n block name=Fold_Output,type=subroutine                             @C1\n  lm   r3,r4,0(r1)                    | Point to record to fold     @C1\n  l    r4,0(r4)                       | Get its length              @C1\n  bctr r4,0                           | Subtract 4, plus 1 for EXI  @C1\n  exi  r4,(tr,0(0,r3),psd_fold_table) | Make data uppercase.        @C1\n endblk rc=(r15)                      |                             @C1\n eject                                |\n*---------------------------------------------------------------------*\n*\n*  Errexit:    Unnamed\n*  Purpose:    Save debugging information and exit with the return\n*              code pointed to by r14 at entry to this exit.\n*  Notes:      For some cases, various registers may point to info we\n*              want to display.  For example, when the MSGMOD errors\n*              are detected, R4 points to the module name in error.\n*\n*---------------------------------------------------------------------*\n         SPACE 1                      |\n block type=errexit                   |\n* es_display_debug_info_and_abend id=es << TESTING >>\n* *-------------------------------------------------------------------*\n* * Save module/offset, registers, return-code.\n* *-------------------------------------------------------------------*\n  st    r15,pwa_reason                | Save possible return-code.\n  stm   r0,r15,gdiregs                | Save registers at time of error\n  sm_lal r0,&srv_modname+4            | Point to module identification.\n  st    r0,gdimodid                   | Save in general debug area.\n  mvc   gdirc,0(r14)                  | Copy return code.\n  sl    r14,=a(&srv_modname)          | Calculate offset at time of err\n  sth   r14,gdioffst                  | Save in debug area.\n  l     r2,pwaaesv                    | Point r2 to ESV.\n  using esv,r2                        | Establish base for ESV.\n  callx esvesepa,(esvestkn,&es_save_debug_info,&es_debug_id_gdi,gdi)\n* *-------------------------------------------------------------------*\n* * Look at the error code.  If add'l information would be useful,\n* * (ie. the msgid of the message we couldn't find), stuff into the\n* * debug area.\n* *-------------------------------------------------------------------*\n  lh    r15,gdirc                     | Get return code.\n  caseblk reg=r15,mult=1              | Case on return-code.\n    case &ms_message_not_found        | Message_not_found:\n      l     r3,pwa_current_mmp        |\n      using mmp_start,r3              |\n      l     r5,prm_issuemsg_msgid     |\n      fill  pwa_base_message,c' '     |\n      mvc   pwa_base_message(l'psd_nomsg_1),psd_nomsg_1\n      l8    r1,mmp_id_length          |\n      bctr  r1,0                      |\n      exi   r1,(mvc,pwa_base_message+l'psd_nomsg_1(0),0(r5))\n      la    r1,pwa_base_message+l'psd_nomsg_1+1(r1)\n      mvc   0(l'psd_nomsg_2,r1),psd_nomsg_2\n      la    r1,l'psd_nomsg_2(r1)      |\n      la    r15,pwa_base_message      |\n      sr    r1,r15                    |\n      st    r1,pwa_base_msg_length    |\n      callx esvesepa,(esvestkn,&es_save_debug_info,&es_debug_id_text,  *\n               pwa_base_message,pwa_base_msg_length)\n      drop  r3                        |\n    case &ms_msgmod_not_loaded        | Msgmod_not_loaded (r4 -> name)\n      fill  pwa_base_message,c' '     |\n      mvc   pwa_base_message(l'psd_msgload_1),psd_msgload_1\n      mvc   pwa_base_message+l'psd_msgload_1(8),0(r4)\n      la    r1,pwa_base_message+l'psd_msgload_1+8\n      mvc   0(l'psd_msgload_2,r1),psd_msgload_2\n      la    r1,l'psd_msgload_2(r1)    |\n      la    r15,pwa_base_message      |\n      sr    r1,r15                    |\n      st    r1,pwa_base_msg_length    |\n      callx esvesepa,(esvestkn,&es_save_debug_info,&es_debug_id_text,  *\n               pwa_base_message,pwa_base_msg_length)\n    case &ms_msgmod_not_valid         | Msgmod_invalid    (r4 -> name)\n      fill  pwa_base_message,c' '     |\n      mvc   pwa_base_message(l'psd_msgmod_1),psd_msgmod_1\n      mvc   pwa_base_message+l'psd_msgmod_1(8),0(r4)\n      la    r1,pwa_base_message+l'psd_msgmod_1+8\n      mvc   0(l'psd_msgmod_2,r1),psd_msgmod_2\n      la    r1,l'psd_msgmod_2(r1)     |\n      la    r15,pwa_base_message      |\n      sr    r1,r15                    |\n      st    r1,pwa_base_msg_length    |\n      callx esvesepa,(esvestkn,&es_save_debug_info,&es_debug_id_text,  *\n               pwa_base_message,pwa_base_msg_length)\n    case other                        |  Don't bother w/other errors.\n  endcase                             | EndCase.\n  drop r2                             |\n* *-------------------------------------------------------------------*\n* * Set the return-code and exit.\n* *-------------------------------------------------------------------*\n  lh    r15,gdirc                     | Set return code.\n endblk                               |\n eject                                |\n title \"Program Static Data\"          |\n                psd                   |\neyecatcher      dc   cl8\"MS_SP\"       | Eyecatcher value for dumps.\npsd_bit_mask    dc   b'0001',b'0011',b'0111',b'1111'\npsd_nomsg_1     dc   c\"Message ID \"   |\npsd_nomsg_2     dc   c\" not found.\"   |\npsd_msgmod_1    dc   c\"Message module \"\npsd_msgmod_2    dc   c\" has invalid format.\"\npsd_msgload_1   dc   c\"Message module \"\npsd_msgload_2   dc   c\" could not be loaded.\"\n*\npsd_fold_table    dc   256al1(*-psd_fold_table)                     @C1\n             org psd_fold_table+c\"a\"  |                             @C1\n             dc   c'ABCDEFGHI'        |                             @C1\n             org psd_fold_table+c\"j\"  |                             @C1\n             dc   c'JKLMNOPQR'        |                             @C1\n             org psd_fold_table+c\"s\"  |                             @C1\n             dc   c'STUVWXYZ'         |                             @C1\n             org  ,                   |                             @C1\n                ltorg ,               |\n                endpsd                |\n          title \"Dsects\"              |\n          ms_mmp dsect=yes,id=mmp_    |\n          eject                       |\n          ms_mse dsect=yes,id=mse_    |\n          eject                       |\n          es_esv ,                    |\n         title \"Parameter List\"       |\nparmlist                      dsect , |\nprm_MS_id                     ds a    | Div identifier === PWA base\nprm_functioncode              ds a    | Function to be performed\nprm_min_#                     equ (*-parmlist)/4\nprm_function_dept             equ *   | Function-dependent parameters\n*---------------------------------------------------------------------*\n*\n*                  Start function parameters\n*\n*---------------------------------------------------------------------*\n                  org prm_function_dept\nprm_start_esv                 ds a    | Environment Support Vector.\nprm_start_message_modlist     ds a    | Message module list address.\nprm_start_sizelength          ds a    | Size return area.\nprm_start_max_severity        ds a    | Halfword maxcc (optional)\nprm_start_printline_cc        ds a    | ASA carriage ctl for Printline\n*                                     |   messages (' ' if not spec'd)\nprm_start_dest_option         ds a    | MsgDest option byte address\nprm_start_min_#               equ (*-parmlist)/4\nprm_start_dest_specific       equ *   | MsgDest-specific parameters:\n*---------------------------------------------------------------------*\n*  MsgDest option = 0:  No message destination specified.\n*---------------------------------------------------------------------*\nprm_destopt_nodest            equ  0  |\nprm_destopt_nodest_#          equ  (*-parmlist)/4\n*---------------------------------------------------------------------*\n*  MsgDest option = 1:  Write message to specific DDname via Printline\n*---------------------------------------------------------------------*\n      org   prm_start_dest_specific   |\nprm_destopt_DDname            equ  1  |\nprm_start_dest_DDname         ds a    | Address of DDname to write to\nprm_destopt_DDname_#          equ  (*-parmlist)/4\n*---------------------------------------------------------------------*\n*  MsgDest option = 2:  Write message using existing Printline session\n*---------------------------------------------------------------------*\n      org   prm_start_dest_specific   |\nprm_destopt_PL                equ  2  |\nprm_start_dest_plepa          ds a    | Address of PrintLine EPA\nprm_start_dest_pltoken        ds a    | Address of PrintLine token\nprm_destopt_PL_#              equ  (*-parmlist)/4\n*---------------------------------------------------------------------*\n*  MsgDest option = 3:  Write message to console.  (no extra parms)\n*---------------------------------------------------------------------*\n      org   prm_start_dest_specific   |\nprm_destopt_console           equ  3  |\nprm_destopt_console_#         equ  (*-parmlist)/4\n      org   ,                         |\nprm_start_option              ds   a  | Note: Since this parm may   @C1\n*                                     |       appear behind a vari- @C1\n*                                     |       able-length list, its @C1\n*                                     |       position must be der- @C1\n*                                     |       ived.                 @C1\nprm_start_max_#               equ (*-parmlist)/4\n*---------------------------------------------------------------------*\n*\n*                 Terminate function parameters\n*\n*---------------------------------------------------------------------*\n                  org prm_function_dept\nprm_terminate_#               equ (*-parmlist)/4\n*---------------------------------------------------------------------*\n*\n*                Issue_Message function parameters\n*\n*---------------------------------------------------------------------*\n                  org prm_function_dept\nprm_issuemsg_msgid            ds a    | Message number\nprm_issuemsg_min_#            equ (*-parmlist)/4\nprm_issuemsg_sourcelist       ds 50a  |\nprm_issuemsg_max_#            equ (*-parmlist)/4\n*---------------------------------------------------------------------*\n*\n*                 Get_Message function parameters\n*\n*---------------------------------------------------------------------*\n                  org prm_function_dept\nprm_getmsg_msgid              ds a    | Message number\nprm_getmsg_target             ds a    | Address of target string\nprm_getmsg_target_length      ds a    | Max. length of target string\nprm_getmsg_result_length      ds a    | Length of returned string\nprm_getmsg_min_#              equ (*-parmlist)/4\nprm_getmsg_sourcelist         ds 50a  |\nprm_getmsg_max_#              equ (*-parmlist)/4\n*---------------------------------------------------------------------*\n*\n*                Put_Message function parameters\n*\n*---------------------------------------------------------------------*\n                  org prm_function_dept\nprm_putmsg_string             ds a    | Message number\nprm_putmsg_strlen             ds a    |\nprm_putmsg_min_#              equ (*-parmlist)/4\nprm_putmsg_max_#              equ (*-parmlist)/4\n                  org ,               |\nprm_max_#                     equ (*-parmlist)/4\n*\n          title \"Program Work Area\"   |\n               PWA                    |\npwa_area       ds    0f               | Beginning of visible PWA stg.\npwa_visual     ds    cl8              | Character string 'DIV_SP'.\npwa_MS_id      ds    a                | Pointer to program work area.\npwa_clear_start equ  *                | This area cleared by MS_START.\npwa_ES_epa     ds    f                | Environment Support EPA.\npwa_ddname     ds    cl8              | DDname to pass to Printline.\npwa_ES_token   ds    f                | Environment Support PWA token.\npwa_MM_epa     ds    f                | Memory Manager EPA.\npwa_MM_token   ds    f                | Memory Manager PWA token.\npwa_DT_epa     ds    f                | Date services EPA.          @C2\npwa_DT_token   ds    f                | Date services PWA token.    @C2\npwa_ST_epa     ds    f                | String Formatter EPA.\npwa_ST_token   ds    f                | String Formatter PWA token.\npwa_PL_epa     ds    f                | Printline EPA.\npwa_PL_token   ds    f                | Printline PWA token.\n*                                     |  is that spec'd by SizeLength.\npwa_msglength_adj    ds  f            | Adjusted MSE message length.\npwa_sizelength ds    f                |\npwa_maxsev_address ds f               | Address of MaxSev (if any)\npwa_reason     ds    f                |\npwa_size_mask  ds    f                | Mask to load lengths using ICM\npwa_current_MMP  ds  f                |\npwa_clear_end  equ  *                 | End area cleared by MS_START.\npwa_clear_length   equ   pwa_clear_end-pwa_clear_start\npwa_ESV        ds    f                |\npwa_number_of_parms ds h              | Number of parms.\n*                                     |\npwa_printline_cc  ds  c               | ASA CC for Printline.\n*                                     |\npwaf1        ds    x                  | General flag byte:\n*                                     |\npwaf1spl     equ   x'80'  |1... ....| | . Printline session should be\n*                                     |   started. This means that\n*                                     |   MS_Terminate needs to shut\n*                                     |   Printline down.\npwaf1epl     equ   x'40'  |.1.. ....| | . Use existing PrintLine, EPA &\n*                                     |   token provided by caller.\npwaf1sst     equ   x'20'  |..1. ....| | . StringHandler session started\n*                                     |   This means that MS_Terminate\n*                                     |   needs to shut it down.\npwaf1cns     equ   x'10'  |...1 ....| | . MSGDEST=CONSOLE specified.\n*                                     |   This means that PrintLine\n*                                     |   cannot be used.\npwaf1mxs     equ   x'08'  |.... 1...| | . MaxSev was specified. This\n*                                     |   means that PWA_Maxsev_Address\n*                                     |   points to a 'MaxCC' halfword\n*                                     |   that Message Services should\n*                                     |   maintain based on messages'\n*                                     |   message ID severity.\npwaf1trn     equ   x'04'  |.... .1..| | . Formatted string was trunc'd.\n*                                     |   This was actually returned by\n*                                     |   StringHandler.  As much data\n*                                     |   as will fit is printed or\n*                                     |   returned to the caller.\npwaf1nmd     equ   x'02'  |.... ..1.| | . No message destination was\n*                                     |   provided.  This means that\n*                                     |   we must fail ISSUE_MESSAGE\n*                                     |   requests and only allow GET_\n*                                     |   MESSAGE.\npwaf1pfx     equ   x'01'  |.... ...1| | . Prefix found (used internally\n*                                     |   by lookup_and_copy_message).\n*                                     |\n*                                     |\npwaop         ds    x                 | OPTIONS from MS_START:      @C1\npwaopfld      equ   x'80' '1... ....' | . Fold msgs to uppercase.   @C1\npwaoptim      equ   x'40' '.1.. ....' | . Time stamp messages.      @C2\n*             equ   x'7f' '..11 1111' | . Reserved.                 @C2\n*                                     |\npwa_sourceparm_count ds f             | Count of parms in sourcelist.\n*                                     |   Used by set_fmt_hdr, _ftr.\npwa_pl_format_pl  ds    0f            | Parms for Printline, -or-\npwa_st_format_pl  ds    57a           | Parms for string formatter.\n*                                     |\npwa_base_msg_length       ds  f       |\npwa_base_message          ds  cl256   |\npwa_formatted_msg_length  ds  f       |\npwa_formatted_message     ds  cl512   |\n*                                     |\n               es_gdi dsect=no        | General debugging information.\npwa_msgmod_count  ds    f             |\npwa_msgmod_list   ds    25cl12        |\ndsp_msgmod_name   equ   0             |\ndsp_msgmod_mmp    equ   8             |                             @C3\npwa_msgmod_list_length equ *-pwa_msgmod_list\npwa_area_l     equ   *-pwa_area       | Length of visible PWA stg.\n               endpwa                 |\n               end   ,                |\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SRVMSMAC": {"ttr": 32006, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x02\\x00\\x00X\\x01\\x11)\\x9f\\x01\\x11)\\x9f\\t'\\x03\\xbd\\x03\\xbd\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@\"", "ispf": {"version": "02.00", "flags": 0, "createdate": "2011-10-26T00:00:00", "modifydate": "2011-10-26T09:27:58", "lines": 957, "newlines": 957, "modlines": 0, "user": "CLEMSON"}, "text": "*---------------------------------------------------------------------*\n*  Copyright 2011 by Clemson University Research Foundation           *\n*                                                                     *\n*  Licensed under the Apache License, Version 2.0 (the \"License\");    *\n*  you may not use this file except in compliance with the License.   *\n*  You may obtain a copy of the License in this library as member     *\n*  $LICENSE, or from                                                  *\n*                                                                     *\n*      http://www.apache.org/licenses/LICENSE-2.0                     *\n*                                                                     *\n*  Unless required by applicable law or agreed to in writing,         *\n*  software distributed under the License is distributed on an \"AS    *\n*  IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either    *\n*  express or implied.  See the License for the specific language     *\n*  governing permissions and limitations under the License.           *\n*---------------------------------------------------------------------*\n TITLE 'SRVMSMAC: Message Service Processor Symbols && Macros.'\n*---------------------------------------------------------------------*\n*\n*  Copy File:  SRVMSMAC\n*\n*  Purpose:    Message service processor symbols and macros.\n*\n*  Description: See \"Service Processors User's Guide and Reference\".\n*\n*  Change\n*  History:    10/04/89 JCB and MGG - New\n*              11/20/90 MJM - Added default SPEPNAME=&MESSAGE_SERVICES\n*                             to the MS_ID macro.\n*\n*---------------------------------------------------------------------*\n*\n***********************************************************************\n***********************************************************************\n**                                                                   **\n**                     Symbol Definitions                            **\n**                                                                   **\n***********************************************************************\n***********************************************************************\n GBLC &MESSAGE_SERVICES\n GBLA &MS_START,&MS_TERMINATE\n GBLA &MS_ISSUE_MESSAGE,&MS_GET_MESSAGE,&MS_PUT_MESSAGE\n*\n GBLA &MS_SUCCESS\n GBLA &MS_INVALID_FUNCTION\n GBLA &MS_INVALID_NUMBER_OF_PARMS\n GBLA &MS_INVALID_MS_ID\n GBLA &MS_ENVIRONMENT_SUPPORT_ERROR\n GBLA &MS_STRING_HANDLER_ERROR\n GBLA &MS_PRINT_LINE_TRUNCATED\n GBLA &MS_PRINTLINE_ERROR\n GBLA &MS_INVALID_MSGDEST_OPTION\n GBLA &MS_MSGMOD_MISSING\n GBLA &MS_TOO_MANY_MSGMODS\n GBLA &MS_MSGMOD_NOT_LOADED\n GBLA &MS_MSGMOD_NOT_VALID\n GBLA &MS_INVALID_SIZELENGTH\n GBLA &MS_MESSAGE_NOT_FOUND\n GBLA &MS_INVALID_PREFIX\n GBLA &MS_MSGDEST_NOT_PROVIDED\n GBLA &MS_DT_ERROR\n*\n* Entry point name for the Item Manager.\n*\n&MESSAGE_SERVICES                       SETC '''SRVMS   '''\n*\n* Function codes.\n*\n&MS_START                               SETA 1\n&MS_TERMINATE                           SETA 2\n&MS_ISSUE_MESSAGE                       SETA 3\n&MS_GET_MESSAGE                         SETA 4\n&MS_PUT_MESSAGE                         SETA 5\n*\n* Return codes.\n*\n&MS_SUCCESS                             SETA  0\n&MS_INVALID_FUNCTION                    SETA  1\n&MS_INVALID_NUMBER_OF_PARMS             SETA  2\n&MS_INVALID_MS_ID                       SETA  3\n&MS_ENVIRONMENT_SUPPORT_ERROR           SETA  4\n&MS_STRING_HANDLER_ERROR                SETA  5\n&MS_PRINT_LINE_TRUNCATED                SETA  6\n&MS_PRINTLINE_ERROR                     SETA  7\n&MS_INVALID_MSGDEST_OPTION              SETA  8\n&MS_MSGMOD_MISSING                      SETA  9\n&MS_TOO_MANY_MSGMODS                    SETA  10\n&MS_MSGMOD_NOT_LOADED                   SETA  11\n&MS_MSGMOD_NOT_VALID                    SETA  12\n&MS_INVALID_SIZELENGTH                  SETA  13\n&MS_MESSAGE_NOT_FOUND                   SETA  14\n&MS_INVALID_PREFIX                      SETA  15\n&MS_MSGDEST_NOT_PROVIDED                SETA  16\n&MS_DT_ERROR                            SETA  17\n*\n* DEFUCOND macros to facilitate checking return codes. If new return\n* codes are added, don't forget to add a DEFUCOND for them.\n*\n   DEFUCOND MACRO=SRV##RC,NAME=MS_SUCCESS\n   DEFUCOND MACRO=SRV##RC,NAME=MS_INVALID_FUNCTION\n   DEFUCOND MACRO=SRV##RC,NAME=MS_INVALID_NUMBER_OF_PARMS\n   DEFUCOND MACRO=SRV##RC,NAME=MS_INVALID_MS_ID\n   DEFUCOND MACRO=SRV##RC,NAME=MS_ENVIRONMENT_SUPPORT_ERROR\n   DEFUCOND MACRO=SRV##RC,NAME=MS_STRING_HANDLER_ERROR\n   DEFUCOND MACRO=SRV##RC,NAME=MS_PRINT_LINE_TRUNCATED\n   DEFUCOND MACRO=SRV##RC,NAME=MS_PRINTLINE_ERROR\n   DEFUCOND MACRO=SRV##RC,NAME=MS_INVALID_MSGDEST_OPTION\n   DEFUCOND MACRO=SRV##RC,NAME=MS_MSGMOD_MISSING\n   DEFUCOND MACRO=SRV##RC,NAME=MS_TOO_MANY_MSGMODS\n   DEFUCOND MACRO=SRV##RC,NAME=MS_MSGMOD_NOT_LOADED\n   DEFUCOND MACRO=SRV##RC,NAME=MS_MSGMOD_NOT_VALID\n   DEFUCOND MACRO=SRV##RC,NAME=MS_INVALID_SIZELENGTH\n   DEFUCOND MACRO=SRV##RC,NAME=MS_MESSAGE_NOT_FOUND\n   DEFUCOND MACRO=SRV##RC,NAME=MS_INVALID_PREFIX\n   DEFUCOND MACRO=SRV##RC,NAME=MS_MSGDEST_NOT_PROVIDED\n*\n* Miscellaneous definitions.\n*\n GBLA   &MS_DEFAULT_SIZELENGTH\n&MS_DEFAULT_SIZELENGTH      SETA  4\n                        EJECT\n***********************************************************************\n***********************************************************************\n**                                                                   **\n**                     Macro Definitions                             **\n**                                                                   **\n***********************************************************************\n***********************************************************************\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   MS_ID                                                      *\n*                                                                     *\n* Purpose: Establish default values for a specific service processor  *\n*          and associate them with the specified ID name. The values  *\n*          are stored in the following created global variables:      *\n*                                                                     *\n* Variable Name                     Description                       *\n* -------------  ---------------------------------------------------- *\n* #$&ID.$#IDMAC  Name of macro that created the ID: PL_ID.            *\n* #$&ID.$#ESID   Service processor's Environment Support ID.          *\n* #$&ID.$#EPN    Tag for Service processor's Entry Point Name.        *\n* #$&ID.$#EPA    Tag for Service processor's Entry Point Address.     *\n* #$&ID.$#TKN    Tag for Service processor's Entry Point Token.       *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         MS_ID &ID=,&ESVA=,&SPEPNAME=,&SPEPA=,&SPTOKEN=,&ESID=,        *\n               &SIZELENGTH=\n         LCLC  &L_EPNAME\n         GBLC  &MESSAGE_SERVICES\n.*\n.* If no EPNAME was specified, use the generic Message Services.\n.*\n&L_EPNAME SETC '&SPEPNAME'\n          AIF  ('&L_EPNAME' NE '').PAST_EPN\n&L_EPNAME SETC '&MESSAGE_SERVICES'\n.PAST_EPN ANOP\n.*\n.* Invoke SRV##ID to create globals used by all ID's.\n.*\n         SRV##ID SET,                                                  +\n               ID=&ID.,IDMAC=MS_ID,ESID=&ESID.,SPEPNAME=&L_EPNAME,     +\n               SPEPA=&SPEPA,SPTOKEN=&SPTOKEN.\n.*\n.* Establish defaults for parameters specific to the string handler.\n.*\n&V_SIZELENGTH    SETC '#$&ID.$#SIZELENGTH'  Variable for SIZELENGTH=.\n                 GBLC &(&V_SIZELENGTH)      Declare global variable.\n&(&V_SIZELENGTH) SETC ''                    Set sizelength's default.\n                 AIF  ('&SIZELENGTH' EQ '').GOT_SIZELENGTH\n                 AIF  (T'&SIZELENGTH EQ 'N').SL_NUMERIC\n                 MNOTE 8,'If SIZELENGTH is specified on the ST_ID macro+\n               , it must be a self-defining numeric value.'\n                 AGO   .GOT_SIZELENGTH\n.SL_NUMERIC      ANOP\n&(&V_SIZELENGTH) SETC '&SIZELENGTH'         Copy value (or nulls).\n.GOT_SIZELENGTH  ANOP\n         MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   MS_START                                                   *\n* Purpose: Generate code to start a new Message Services session.     *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         MS_START &ID=,&SPEPA=,&SPTOKEN=,&ESVA=,                       +\n               &MSGDEST=,                                              *\n               &MSGMOD=,                                               *\n               &MSGMODLIST=,                                           *\n               &MAXSEV=,                                               *\n               &PLCC=,                                                 *\n               &OPTIONS=,                                              *\n               &SIZELENGTH=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN\n         GBLA  &MS_START                  SETC in open code.\n         GBLC  &MS_PL_ID,&MS_PL_EPA,&MS_PL_TOKEN\n         LCLC  &MSGDEST_OPTION,&MSGDEST_P(2)\n         LCLC  &CSECTLIST\n         LCLC  &MS_PL_CC\n         LCLA  &I\n         LCLB  &OPT_FOLD\n         LCLB  &OPT_TIMESTAMP\n.*\n.* Obtain service processor ID values.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN,ESVA),                    +\n               ID=&ID,IDMAC=MS_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN,       +\n               ESVA=&ESVA.\n         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT\n         MVC   &#_IDTKN,=F'0'            | Insure TOKEN = 0.\n.*\n.*                 Validate the incoming parameters.\n.*\n.*\n.* Process the MSGDEST keyword.\n.*\n         AIF   ('&MSGDEST' NE '').MSGDEST_PRESENT\n.MSGDEST_MISSING ANOP ,\n&MSGDEST_OPTION SETC '=AL1(0)'\n         AGO   .MSGMODS\n.MSGDEST_PRESENT ANOP ,\n         AIF   ('&MSGDEST(1)' EQ 'DDNAME').MSGDEST_DDNAME\n         AIF   ('&MSGDEST(1)' EQ 'PLID').MSGDEST_PLID\n         AIF   ('&MSGDEST(1)' EQ 'PL').MSGDEST_PL\n         AIF   ('&MSGDEST(1)' EQ 'CONSOLE').MSGDEST_CONSOLE\n         MNOTE 8,'Message destination of &MSGDEST(1) is not supported.'\n         MNOTE 8,'Supported MSGDESTs are DDNAME, PLID, PL and CONSOLE.'\n         MEXIT\n.*\n.* Process the MSGDEST=(DDNAME,thing) option.\n.*\n.MSGDEST_DDNAME ANOP ,\n         AIF   (N'&MSGDEST EQ 2).MSGDEST_DDOK\n         MNOTE 8,'Supported MSGDESTs are DDNAME, PLID, PL and CONSOLE.'\n         MEXIT\n.MSGDEST_DDOK   ANOP ,\n&MSGDEST_OPTION SETC '=AL1(1)'\n&MSGDEST_P(1)   SETC '&MSGDEST(2)'\n         AGO   .MSGMODS\n.*\n.* Process the MSGDEST=(PLID,thing) option.\n.*\n.MSGDEST_PLID   ANOP ,\n         AIF   (N'&MSGDEST EQ 2).MSGDEST_PLIDOK\n         MNOTE 8,'The PLID option of MSGDEST supports only one paramete*\n               r.'\n         MEXIT\n.MSGDEST_PLIDOK ANOP ,\n&MSGDEST_OPTION SETC '=AL1(2)'\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         *\n               ID=&MSGDEST(2),                                         *\n               IDMAC=PL_ID\n         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT\n&MSGDEST_P(1)   SETC '&#_IDEPA'                Save SRV##ID values &\n&MSGDEST_P(2)   SETC '&#_IDTKN'                 set back to MS's stuff\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN,ESVA),                    +\n               ID=&ID,IDMAC=MS_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN,       +\n               ESVA=&ESVA.\n         AGO   .MSGMODS\n.*\n.* Process the MSGDEST=(PL,epa,token) option.\n.*\n.MSGDEST_PL     ANOP ,\n         AIF   (N'&MSGDEST EQ 3).MSGDEST_PLOK\n         MNOTE 8,'The PL option of MSGDEST supports only two parameters*\n               .'\n         MEXIT\n.MSGDEST_PLOK   ANOP ,\n&MSGDEST_OPTION SETC '=AL1(2)'\n&MSGDEST_P(1)   SETC '&MSGDEST(2)'\n&MSGDEST_P(2)   SETC '&MSGDEST(3)'\n         AGO   .MSGMODS\n.*\n.* Process the MSGDEST=CONSOLE option.\n.*\n.MSGDEST_CONSOLE ANOP ,\n         AIF   (N'&MSGDEST EQ 1).MSGDEST_CONSOK\n         MNOTE 8,'The CONSOLE operand of MSGDEST has no additional para*\n               meters.'\n         MEXIT\n.MSGDEST_CONSOK ANOP ,\n&MSGDEST_OPTION SETC '=AL1(3)'\n.*\n.* Process MsgMod and MsgModList keywords.\n.*\n.MSGMODS ANOP  ,\n         AIF   ('&MSGMOD' EQ '' OR '&MSGMODLIST' EQ '').MSGMOD_EITHER\n         MNOTE 8,'The MSGMOD and MSGMODLIST keywords are mutually exclu*\n               sive.'\n         MEXIT\n.MSGMOD_EITHER ANOP ,\n         AIF   ('&MSGMOD' NE '').MSGMOD\n         AIF   ('&MSGMODLIST' NE '').MSGMODLIST\n         MNOTE 8,'Either the MSGMOD or the MSGMODLIST keyword must be s*\n               pecified.'\n         MEXIT\n.*\n.*  Process the MSGMOD=(csectlist) keyword.  This involves building the\n.*  module list in the caller's PSD.\n.*\n.MSGMOD  ANOP  ,\n&CSECTLIST SETC '##MS_MSGMOD_&SYSNDX'      Generate csectlist tag\n         PSD   TYPE=PARTIAL\n&CSECTLIST DS  0F                       Generated by MS_START:\n         LCLA  &MSGMOD_COUNT\n&MSGMOD_COUNT SETA N'&MSGMOD\n         DC  A(&MSGMOD_COUNT)                . Count of MSGMOD CSECTs\n&I       SETA  1\n.MSGMOD_ENTRY ANOP ,\n         DC    CL8'&MSGMOD(&I)'              . MSGMOD CSECT entry\n         AIF   (&I EQ N'&MSGMOD).MSGMOD_DONE\n&I       SETA  &I+1\n         AGO   .MSGMOD_ENTRY\n.MSGMOD_DONE  ANOP ,\n         ENDPSD ,\n         AGO   .MAXSEV\n.MSGMODLIST ANOP\n&CSECTLIST SETC '&MSGMODLIST'           Generate csectlist tag\n         AGO   .MAXSEV\n.*\n.*  Process the MAXSEV=halfword keyword.\n.*\n.MAXSEV  ANOP ,\n         AIF   ('&MAXSEV' EQ '').SIZELENGTH   If not specified, skip.\n         AIF   (T'&MAXSEV NE 'N').MAXSEV_OK\n         MNOTE 8,'The MAXSEV parameter must be the address of a halfwor*\n               d in storage.'\n         MEXIT\n.MAXSEV_OK  ANOP ,\n.SIZELENGTH ANOP ,\n.*\n.* Obtain the value for the SIZELENGTH keyword.\n.*\n&V_SIZELENGTH    SETC '#$&ID.$#SIZELENGTH'  Variable for SIZELENGTH=.\n                 GBLC &(&V_SIZELENGTH)      Declare global variable.\n&L_SIZELENGTH    SETC '&(&V_SIZELENGTH)'    Set default value.\n                 AIF  ('&L_SIZELENGTH' EQ '').SL_OKAY\n                 AIF  ('&SIZELENGTH' EQ '').SL_DONE\n                 AIF  ('&L_SIZELENGTH' EQ '&SIZELENGTH').SL_DONE\n                 MNOTE 4,'Warning: SIZELENGTH was specified with a diff+\n               erent value on the ST_ID ID=&ID. instruction.'\n.SL_OKAY         ANOP\n&L_SIZELENGTH    SETC '&SIZELENGTH'\n.SL_DONE         ANOP\n.*\n.*  Process the PLCC=halfword keyword.\n.*\n.PLCC    ANOP ,\n         AIF   ('&PLCC' EQ '').PLCC_OK If not specified, null parm.\n&MS_PL_CC SETC '&PLCC'\n         AIF  ('&MSGDEST(1)' NE 'CONSOLE' AND '&MSGDEST' NE '').PLCC_OK\n         MNOTE 4,'PLCC keyword is ignored for CONSOLE and null MSGDEST *\n               options.'\n.PLCC_OK  ANOP ,\n.*\n.* Decode the options and produce a byte flag for the parmlist.\n.*\n&I       SETA  1\n.OPTLOOP AIF   (&I GT N'&OPTIONS).PASTOPT\n         AIF   ('&OPTIONS(&I)' EQ 'FOLD').OPT1\n         AIF   ('&OPTIONS(&I)' EQ 'TIMESTAMP').OPT2\n         MNOTE 8,'Invalid option name: &OPTIONS(&I)'\n.OPT1    ANOP\n&OPT_FOLD SETB 1\n         AGO   .NEXTOPT         Go process the next option.\n.OPT2    ANOP\n&OPT_TIMESTAMP SETB 1\n         AGO   .NEXTOPT         Go process the next option.\n.*\n.*  Add additional options here.\n.*\n.NEXTOPT ANOP\n&I       SETA  &I+1             Increment index into options list.\n         AGO   .OPTLOOP         Branch back to top of loop.\n.PASTOPT ANOP\n&OPTSTR  SETC '&OPT_FOLD.&OPT_TIMESTAMP'\n&OPTSTR  SETC '&OPTSTR.000000'\n         AIF  ('&OPTSTR' NE '00000000').NOT_NOP\n&OPTSTR  SETC ''\n         AGO  .PAST_OPTSTR_SET\n.NOT_NOP ANOP\n&OPTSTR  SETC '=B''&OPTSTR'''\n.PAST_OPTSTR_SET ANOP\n.*\n.*\n.* Generate the MS_START call.\n.*\n.CALL    ANOP ,\n.*       CALLX &#_IDEPA,(&#_IDTKN,&MS_START,&#_IDESVA,\n.*             &CSECTLIST,&(&V_SIZELENGTH),&MAXSEV,&PLCC,\n.*             &MSGDEST_OPTION,&MSGDEST_P(1),&MSGDEST_P(2)),VL\n         ##PLIST START\n         ##PLIST PARM,&#_IDTKN\n         ##PLIST PARM,&MS_START\n         ##PLIST PARM,&#_IDESVA\n         ##PLIST PARM,&CSECTLIST\n         ##PLIST PARM,&(&V_SIZELENGTH)\n         ##PLIST PARM,&MAXSEV\n         ##PLIST PARM,&MS_PL_CC\n         ##PLIST PARM,&MSGDEST_OPTION\n&I       SETA  1\n.PL_LOOP ANOP\n         AIF   ('&MSGDEST_P(&I)' EQ '').PL_LOOPEND\n         ##PLIST PARM,&MSGDEST_P(&I)\n&I       SETA  &I+1\n         AGO   .PL_LOOP\n.PL_LOOPEND ANOP ,\n         AIF   ('&OPTSTR' EQ '').CALLEND\n         ##PLIST PARM,&OPTSTR\n.CALLEND ANOP ,\n         ##PLIST END,VL\n         CALLX  &#_IDEPA\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   MS_TERMINATE                                               *\n* Purpose: Generate code to terminate a Message Services session.     *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         MS_TERMINATE &ID=,&SPEPA=,&SPTOKEN=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN\n         GBLA  &MS_TERMINATE              SETC in open code.\n.*\n.* Obtain service processor ID values and terminate service processor.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +\n               ID=&ID,IDMAC=MS_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN\n         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT\n         CALLX &#_IDEPA,(&#_IDTKN,&MS_TERMINATE),VL\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   MS_ISSUE_MESSAGE                                           *\n* Purpose: Issue a message for the caller.                            *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         MS_ISSUE_MESSAGE &ID=,&SPEPA=,&SPTOKEN=,                      *\n               &MSGID=,                                                *\n               &SOURCE=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN\n         GBLA  &MS_ISSUE_MESSAGE\n         LCLA  &I\n.*\n.* Obtain service processor ID values.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +\n               ID=&ID,IDMAC=MS_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN\n         AIF  ('&#_IDCODE' EQ 'SUCCESS').VALIDATE\n         MNOTE 8,'SRV##ID unable to set global variables.'\n         MEXIT\n.VALIDATE ANOP\n.*\n.*                  Validate incoming parameters.\n.*\n.*\n.*  Ensure MSGID is present and isn't a numeric value.\n.*\n         AIF   ('&MSGID' EQ '').MSGID_MISSING\n         AIF   (T'&MSGID NE 'N').MSGIDOK\n.MSGID_NUMERIC MNOTE 8,'The MSGID parameter must specify the address of*\n               the message ID to be issued.'\n         MEXIT\n.MSGID_MISSING MNOTE 8,'MSGID is a required parameter.'\n         MEXIT\n.MSGIDOK ANOP\n.*\n.*  Ensure that no more than 50 SOURCE parameters were specified.\n.*\n         AIF   (N'&SOURCE LE 50).SOURCEOK\n         MNOTE 8,'No more than 50 SOURCE parameters may be specified.'\n         MEXIT\n.SOURCEOK ANOP ,\n.*\n.* Generate the parmlist and call to MS_ISSUE_MESSAGE.\n.*\n         ##PLIST START\n         ##PLIST PARM,&#_IDTKN\n         ##PLIST PARM,&MS_ISSUE_MESSAGE\n         ##PLIST PARM,&MSGID\n&I       SETA  1\n.SOURCELOOP ANOP ,\n         AIF   (&I GT N'&SOURCE).SOURCEDONE\n         ##PLIST PARM,&SOURCE(&I)\n&I       SETA  &I+1\n         AGO   .SOURCELOOP\n.SOURCEDONE ANOP ,\n         ##PLIST END,VL\n         CALLX  &#_IDEPA\n         MEXIT\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   MS_GET_MESSAGE                                             *\n* Purpose: Return the formatted text of a message to the caller.      *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         MS_GET_MESSAGE &ID=,&SPEPA=,&SPTOKEN=,                        *\n               &MSGID=,                                                *\n               &STRING=,                                               *\n               &RESULTLEN=,                                            *\n               &SOURCE=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN\n         GBLA  &MS_GET_MESSAGE\n         LCLA  &I\n         LCLC  &L_STRING(2),&V_STRING(2)\n.*\n.* Obtain service processor ID values.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +\n               ID=&ID,IDMAC=MS_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN\n         AIF  ('&#_IDCODE' EQ 'SUCCESS').VALIDATE\n         MNOTE 8,'SRV##ID unable to set global variables.'\n         MEXIT\n.VALIDATE ANOP\n.*\n.*                  Validate incoming parameters.\n.*\n.*\n.*  Ensure MSGID is present and isn't a numeric value.\n.*\n         AIF   ('&MSGID' EQ '').MSGID_MISSING\n         AIF   (T'&MSGID NE 'N').MSGIDOK\n.MSGID_NUMERIC MNOTE 8,'The MSGID parameter must specify the address of*\n               the message ID to be issued.'\n         MEXIT\n.MSGID_MISSING MNOTE 8,'MSGID is a required parameter.'\n         MEXIT\n.MSGIDOK ANOP\n.*\n.*  Ensure that no more than 50 SOURCE parameters were specified.\n.*\n         AIF   (N'&SOURCE LE 50).SOURCEOK\n         MNOTE 8,'No more than 50 SOURCE parameters may be specified.'\n         MEXIT\n.SOURCEOK ANOP ,\n&V_SIZELENGTH    SETC '#$&ID.$#SIZELENGTH'  Variable for SIZELENGTH=.\n                 GBLC &(&V_SIZELENGTH)      Declare global variable.\n         AIF   ('&RESULTLEN' NE '').RESULTOK\n         MNOTE 8,'RESULTLEN is required, and must be the address of a l*\n               ength field &(&V_SIZELENGTH) bytes in length.'\n         MEXIT\n.RESULTOK  ANOP ,\n.*\n.* If STRING= is missing, supply default values.\n.*\n&L_STRING(1)    SETC '&STRING(1)'\n&L_STRING(2)    SETC '&STRING(2)'\n                AIF ('&L_STRING(1)' NE '').STRING_NBLK\n&V_STRING(1)    SETC '#$&ID.$#STRING1'     Variable for STRING=.\n&V_STRING(2)    SETC '#$&ID.$#STRING2'     Variable for STRING=.\n                GBLC &(&V_STRING(1))       Declare global variable.\n                GBLC &(&V_STRING(2))       Declare global variable.\n&L_STRING(1)    SETC '&(&V_STRING(1))'     Copy default value.\n&L_STRING(2)    SETC '&(&V_STRING(2))'     Copy default value.\n.STRING_NBLK    ANOP\n.*\n.*\n.* Process the STRING keyword to get an address and length.\n.*\n&KEYWORD      SETC 'STRING'\n              AIF ('&L_STRING(1)' EQ '').NO_STRING\n              AIF ('&L_STRING(1)'(1,1) EQ '''').STR_LITERAL\n              AIF ('&L_STRING(2)' EQ '').STR_TAGONLY\n              MEXIT , ??????\n.STR_TAGLEN   ANOP\n&S_ADDR       SETC '&L_STRING(1)'         | Set addr.\n&S_LEN        SETC '&L_STRING(2)'         | Set len.\n              AGO  .PAST_STRING           |\n.STR_TAGONLY  AIF  ('&(&V_SIZELENGTH)' EQ '').NO_SIZELENGTH\n&S_ADDR       SETC '&L_STRING(1)'         | Set addr to tag_name.\n&S_LEN        SETC '=AL&(&V_SIZELENGTH).(L''&L_STRING(1))'\n              AGO  .PAST_STRING           |\n.STR_LITERAL  ANOP                        |\n              MNOTE 8,'STRING string cannot be a literal.'\n              MEXIT\n.NO_STRING    MNOTE 8,'STRING is a required keyword.'\n              MEXIT\n.PAST_STRING  ANOP\n.*\n.* Generate the parmlist and call to MS_GET_MESSAGE.\n.*\n         ##PLIST START\n         ##PLIST PARM,&#_IDTKN\n         ##PLIST PARM,&MS_GET_MESSAGE\n         ##PLIST PARM,&MSGID\n         ##PLIST PARM,&S_ADDR\n         ##PLIST PARM,&S_LEN\n         ##PLIST PARM,&RESULTLEN\n&I       SETA  1\n.SOURCELOOP ANOP ,\n         AIF   (&I GT N'&SOURCE).SOURCEDONE\n         ##PLIST PARM,&SOURCE(&I)\n&I       SETA  &I+1\n         AGO   .SOURCELOOP\n.SOURCEDONE ANOP ,\n         ##PLIST END,VL\n         CALLX  &#_IDEPA\n         MEXIT\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   MS_PUT_MESSAGE                                             *\n* Purpose: Write the caller-provided text to the message destination. *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         MS_PUT_MESSAGE &ID=,&SPEPA=,&SPTOKEN=,                        *\n               &STRING=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN\n         GBLA  &MS_PUT_MESSAGE\n         LCLA  &I\n         LCLC  &L_STRING(2),&V_STRING(2)\n.*\n.* Obtain service processor ID values.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +\n               ID=&ID,IDMAC=MS_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN\n         AIF  ('&#_IDCODE' EQ 'SUCCESS').VALIDATE\n         MNOTE 8,'SRV##ID unable to set global variables.'\n         MEXIT\n.VALIDATE ANOP\n.*\n.*                  Validate incoming parameters.\n.*\n&V_SIZELENGTH    SETC '#$&ID.$#SIZELENGTH'  Variable for SIZELENGTH=.\n                 GBLC &(&V_SIZELENGTH)      Declare global variable.\n.*\n.* If STRING= is missing, supply default values.\n.*\n&L_STRING(1)    SETC '&STRING(1)'\n&L_STRING(2)    SETC '&STRING(2)'\n                AIF ('&L_STRING(1)' NE '').STRING_NBLK\n&V_STRING(1)    SETC '#$&ID.$#STRING1'     Variable for STRING=.\n&V_STRING(2)    SETC '#$&ID.$#STRING2'     Variable for STRING=.\n                GBLC &(&V_STRING(1))       Declare global variable.\n                GBLC &(&V_STRING(2))       Declare global variable.\n&L_STRING(1)    SETC '&(&V_STRING(1))'     Copy default value.\n&L_STRING(2)    SETC '&(&V_STRING(2))'     Copy default value.\n.STRING_NBLK    ANOP\n.*\n.*\n.* Process the STRING keyword to get an address and length.\n.*\n&KEYWORD      SETC 'STRING'\n              AIF ('&L_STRING(1)' EQ '').NO_STRING\n              AIF ('&L_STRING(1)'(1,1) EQ '''').STR_LITERAL\n              AIF ('&L_STRING(2)' EQ '').STR_TAGONLY\n.STR_TAGLEN   ANOP\n&S_ADDR       SETC '&L_STRING(1)'         | Set addr.\n&S_LEN        SETC '&L_STRING(2)'         | Set len.\n              AGO  .PAST_STRING           |\n.STR_TAGONLY  AIF  ('&(&V_SIZELENGTH)' EQ '').NO_SIZELENGTH\n&S_ADDR       SETC '&L_STRING(1)'         | Set addr to tag_name.\n&S_LEN        SETC '=AL&(&V_SIZELENGTH).(L''&L_STRING(1))'\n              AGO  .PAST_STRING           |\n.STR_LITERAL  ANOP                        |\n&S_ADDR         SETC '&L_STRING(1)'         | Set addr to value.\n&L              SETA 0                      | Length counter = 0.\n&I              SETA 2                      | Index counter -> past '.\n.STR_LOOP       AIF  (&I GE K'&S_ADDR).STR_ELOOP     Loop over STRING.\n                AIF  ('&S_ADDR'(&I,1) NE '''').STR_TXT If doubled.\n&I              SETA &I+1                   |             Advance.\n.STR_TXT        ANOP                        |          EndIf.\n&L              SETA &L+1                   |   Add one to length.\n&I              SETA &I+1                   |   Advance.\n                AGO  .STR_LOOP              | End of counting loop.\n.STR_ELOOP      ANOP                        |\n&S_LEN          SETC '=AL&(&V_SIZELENGTH).(&L)'  Set length parameter.\n                AGO  .PAST_STRING\n.NO_STRING    MNOTE 8,'STRING is a required keyword.'\n              MEXIT\n.PAST_STRING  ANOP\n.*\n.* Generate the parmlist and call to MS_PUT_MESSAGE.\n.*\n         ##PLIST START\n         ##PLIST PARM,&#_IDTKN\n         ##PLIST PARM,&MS_PUT_MESSAGE\n         ##PLIST PARM,&S_ADDR\n         ##PLIST PARM,&S_LEN\n         ##PLIST END,VL\n         CALLX  &#_IDEPA\n         MEXIT\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   MS_MMP                                                     *\n* Purpose: This is the mapping macro for a Message Module Prolog.     *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO                        |\n         MS_MMP &DSECT=YES,&ID=MMP_,  |                                +\n               &MSECOUNT=*-*,         |                                +\n               &FIRSTMSE=*-*,         |                                +\n               &ELEMSIZE=*-*,         |                                +\n               &MOD=*,                |                                +\n               &PFXLENGTH=*-*,        |                                +\n               &PREFIX=*,             |                                +\n               &IDLENGTH=*-*          |\n&I       SETC  '&ID'                  |\n&CSECT   SETC  '&SYSECT'              |\n         AIF   ('&DSECT' NE 'YES').NO_DSECT\n&I.START DSECT                        | Start of MMP.\n         AGO   .PAST_HEADER           |\n.NO_DSECT ANOP                        |\n&I.START DS    0F                     | Start of MMP.\n.PAST_HEADER ANOP                     |\n&I.ID                DC CL4'MMP '     | Control block id.\n&I.ID_TEXT           EQU  C'MMP '     |\n&I.MODULE_NAME       DC CL8'&MOD'     | Module name.\n&I.ASSEMBLY_DATE     DC CL10'&SYSDATE'  Assembly date.\n&I.ASSEMBLY_TIME     DC CL6'&SYSTIME' | Assembly time.\n&I.VERSION           DC AL1(1)        | Version of map.\n                     DC X'00'         | Not used.\n&I.MSE_ELEMENT_SIZE  DC Y(&ELEMSIZE)  | MSE element size.\n&I.MSE_COUNT         DC A(&MSECOUNT)  | Number of messages.\n&I.FIRST_MSE         DC A(&FIRSTMSE)  | Pointer to first MSE.\n&I.ID_LENGTH         DC AL1(&IDLENGTH)  Message Identification size.\n&I.PREFIX_LENGTH     DC AL1(&PFXLENGTH) Prefix size.\n&I.PREFIX            DC CL6'&PREFIX'  | Prefix\n&I.CB_SIZE          EQU *-&I.START    | Size of this control block.\n&I.CB_STORAGE       EQU &I.START,&I.CB_SIZE,C'X'\n         AIF   ('&DSECT' NE 'YES').MEXIT\n&CSECT   CSECT ,                      |\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   MS_MSE                                                     *\n* Purpose: This is the mapping macro for a Message Entry.             *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO                        |\n         MS_MSE &DSECT=YES,&ID=MSE_\n&I       SETC  '&ID'                  |\n&CSECT   SETC  '&SYSECT'              |\n         AIF   ('&DSECT' NE 'YES').NO_DSECT\n&I.START DSECT                        | Start of MSE.\n         AGO   .PAST_HEADER           |\n.NO_DSECT ANOP                        |\n&I.START DS    0F                     | Start of MSE.\n.PAST_HEADER ANOP                     |\n&I.ADDRESS_TEXT           DS  A       | Address of message text.\n&I.SEVERITY               DS  H       | Severity.\n&I.LENGTH_TEXT            DS  X       | Length of message text.\n                          DS  X       | Not used.\n&I.CB_SIZE          EQU *-&I.START    | Size of this control block.\n&I.CB_STORAGE       EQU &I.START,&I.CB_SIZE,C'X'\n         AIF   ('&DSECT' NE 'YES').MEXIT\n&CSECT   CSECT ,                      |\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   MS__SEVERITY                                               *\n* Purpose: This is an internal macro used by MS_MESSAGE_MODULE to     *\n*          define severity codes.                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         MS__SEVERITY &SEVCHAR,&NUMBER\n         AIF  (K'&SEVCHAR NE 1).INVALID_SEVCHAR\n&CODEDEF SETC 'MS__SEVERITY_&SEVCHAR._DEFINED'\n         GBLB  &(&CODEDEF)\n         AIF  (&(&CODEDEF)).ALREADY_DEFINED\n&(&CODEDEF) SETB 1\n&CODEVAL SETC 'MS__SEVERITY_&SEVCHAR._VALUE'\n         GBLA  &(&CODEVAL)\n&(&CODEVAL) SETA &NUMBER\n         MEXIT\n.ALREADY_DEFINED MNOTE 8,'Severity character (&SEVCHAR) is already defi+\n               ned.'\n         MEXIT\n.INVALID_SEVCHAR MNOTE 8,'Invalid severity character (&SEVCHAR).'\n         MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   MS_MESSAGE_MODULE                                          *\n* Purpose: This is the macro used to start and end a message module.  *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         MS_MESSAGE_MODULE &TYPE,&NAME=,&PREFIX=,&IDLENGTH=8,&SEVCHAR=\n         GBLC  &MS__PREFIX\n         GBLA  &MS__PREFIX_LENGTH\n         GBLA  &MS__IDLENGTH\n         GBLA  &MS__LAST_MESSAGE_NUMBER\n         GBLC  &MS__MODULE_NAME\n         LCLC  &CODEDEF,&CODEVAL\n.*\n.* If type is START, process it.\n.*\n         AIF  ('&TYPE' NE 'START').NOT_START\n&MS__PREFIX              SETC  '&PREFIX'\n&MS__PREFIX_LENGTH       SETA  K'&PREFIX\n&MS__IDLENGTH            SETA  &IDLENGTH\n&MS__MODULE_NAME         SETC  '&NAME'\n&MS__LAST_MESSAGE_NUMBER SETA  -1\n.*\n.* Check for required keywords.\n.*\n         AIF  ('&NAME' NE '').NAME_OK\n         MNOTE 8,'NAME (message module name) is a required keyword.'\n         MEXIT\n.NAME_OK ANOP\n         AIF  ('&PREFIX' NE '').PREFIX_OK\n         MNOTE 8,'PREFIX (message prefix) is a required keyword.'\n         MEXIT\n.PREFIX_OK ANOP\n.*\n.* Other checks.\n.*\n         AIF  (K'&PREFIX LE 6).PREFIX_LENGTH_OK\n         MNOTE 8,'Prefix length is greater than 6.'\n         MEXIT\n.PREFIX_LENGTH_OK ANOP\n.*\n.* Generate prolog for message module.\n.*\n&NAME    CSECT                        Csect name.\n&NAME    RMODE ANY                    Rmode any.\n##HEAD   LOCTR ,                      LOCTR for start of module.\n##NDX    LOCTR ,                      LOCTR for table of MSEs.\nMS__FIRSTMSE   DS   0F                Tag for first MSE.\n##MSG    LOCTR ,                      LOCTR for message text.\n##HEAD   LOCTR ,                      Get bact to head.\n         MS_MMP DSECT=NO,ID=MS__MMP_, Generate MMP.                    +\n               MSECOUNT=MS__MSECOUNT,                                  +\n               FIRSTMSE=MS__FIRSTMSE,                                  +\n               ELEMSIZE=MS__MSE_CB_SIZE,                               +\n               MOD=&NAME,                                              +\n               IDLENGTH=&IDLENGTH,                                     +\n               PFXLENGTH=&MS__PREFIX_LENGTH,                           +\n               PREFIX=&PREFIX\n         MS_MSE DSECT=YES,ID=MS__MSE_\n.*\n.* Define severity codes.\n.*\n         AIF ('&SEVCHAR' NE '').USER_DEFINED_SEVCHAR\n         MS__SEVERITY I,0             Informational\n         MS__SEVERITY W,4             Minor error.\n         MS__SEVERITY E,8             Significant error.\n         MS__SEVERITY S,12            Serious error.\n         MS__SEVERITY C,16            Critical error.\n         MEXIT\n.USER_DEFINED_SEVCHAR ANOP\n&CTR     SETA  1\n.SEVLOOP AIF   (N'&SEVCHAR(&CTR) NE 2).INVALID_SEVCHAR\n         MS__SEVERITY &SEVCHAR(&CTR,1),&SEVCHAR(&CTR,2)\n&CTR     SETA  &CTR+1\n         AIF   (&CTR LE N'&SEVCHAR).SEVLOOP\n         MEXIT\n.NOT_START ANOP\n.*\n.* If type is END, then process.\n.*\n         AIF  ('&TYPE' NE 'END').BAD_TYPE\n         AIF  ('&NAME' NE '').NOT_END_KEYWORD\n         AIF  ('&PREFIX' NE '').NOT_END_KEYWORD\n##NDX    LOCTR ,\nMS__MSECOUNT EQU (*-MS__FIRSTMSE)/MS__MSE_CB_SIZE\n         MEXIT\n.*\n.*  Errors.\n.*\n.INVALID_SEVCHAR MNOTE 8,'Invalid severity parameter - &SEVCHAR(&CTR)'\n         MEXIT\n.BAD_TYPE MNOTE 8,'&TYPE is not a valid type.'\n         MEXIT\n.NOT_END_KEYWORD MNOTE 8,'Keywords not supported for type END.'\n         MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   MS_MESSAGE                                                 *\n* Purpose: This is the macro used to generate a message in a message  *\n*          module.                                                    *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n&MSGID   MS_MESSAGE &TEXT\n         GBLC  &MS__PREFIX\n         GBLA  &MS__PREFIX_LENGTH\n         GBLA  &MS__IDLENGTH\n         GBLA  &MS__LAST_MESSAGE_NUMBER\n         LCLC  &PREFIX\n         LCLC  &NUMBER\n         LCLC  &SEVCHAR\n         LCLA  &COLUMN,&LENGTH\n         LCLC  &CODEDEF,&CODEVAL\n.*\n.* Check for required keywords.\n.*\n         AIF  ('&MSGID' NE '').MSGID_OK\n         MNOTE 8,'MSGID (Message Identifier) is a required keyword.'\n         MEXIT\n.MSGID_OK ANOP\n         AIF  ('&TEXT' NE '').TEXT_OK\n         MNOTE 8,'TEXT (Message Text) is a required keyword.'\n         MEXIT\n.TEXT_OK ANOP\n.*\n.* Seperate message identifier into prefix, number, and severity and\n.* do further checking.\n.*\n         AIF   (K'&MSGID NE &MS__IDLENGTH).MSGID_LENGTH_ERROR\n.IDLENGTH_OK ANOP\n&PREFIX  SETC  '&MSGID'(1,&MS__PREFIX_LENGTH)\n         AIF   ('&PREFIX' NE '&MS__PREFIX').MSGID_FORMAT_ERROR\n&COLUMN  SETA  &MS__PREFIX_LENGTH+1\n&LENGTH  SETA  &MS__IDLENGTH-&MS__PREFIX_LENGTH-1\n&NUMBER  SETC  '&MSGID'(&COLUMN,&LENGTH)\n&CNT     SETA  1\n.NUMLOOP AIF   (&CNT GT &LENGTH).NUMBER_OK\n         AIF   ('&NUMBER'(&CNT,1) LT '0').MSGID_FORMAT_ERROR\n&CNT     SETA  &CNT+1\n         AGO   .NUMLOOP\n.NUMBER_OK ANOP\n         AIF   (&NUMBER LE &MS__LAST_MESSAGE_NUMBER).MSGID_SEQUENCE_ERR+\n               OR\n&MS__LAST_MESSAGE_NUMBER SETA &NUMBER\n&SEVCHAR SETC  '&MSGID'(&MS__IDLENGTH,1)\n&CODEDEF SETC 'MS__SEVERITY_&SEVCHAR._DEFINED'\n         GBLB  &(&CODEDEF)\n         AIF (NOT &(&CODEDEF)).MSGID_INVALID_SEVCHAR\n&CODEVAL SETC 'MS__SEVERITY_&SEVCHAR._VALUE'\n         GBLA  &(&CODEVAL)\n.*\n.* Generate a message entry and the message text.\n.*\n##NDX    LOCTR ,                      LOCTR for index.\n         DC    A(&MSGID)              Address of message text.\n         DC    Y(&(&CODEVAL))         Severity code.\n         DC    AL1(&MSGID._LENGTH)    Message length.\n         DC    AL1(*-*)               Not used.\n##MSG    LOCTR ,                      LOCTR for message text.\n&MSGID   DC C'&MSGID ',C&TEXT         Message text.\n&MSGID._LENGTH EQU *-&MSGID           Length of message text.\n         MEXIT\n.*\n.*  Errors.\n.*\n.MSGID_FORMAT_ERROR   MNOTE 8,'MSGID (&MSGID) is not in valid format.'\n         MEXIT\n.MSGID_SEQUENCE_ERROR MNOTE 8,'MSGID is not in the correct sequence.'\n         MEXIT\n.MSGID_LENGTH_ERROR   MNOTE 8,'MSGID is not the correct length.'\n         MEXIT\n.MSGID_INVALID_SEVCHAR MNOTE 8,'Invalid severity character (&SEVCHAR) i+\n               n MSGID.'\n         MEXIT\n         MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SRVMSXRB": {"ttr": 32513, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x02\\x00\\x00X\\x01\\x11)\\x9f\\x01\\x11)\\x9f\\t'\\x00W\\x00W\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@\"", "ispf": {"version": "02.00", "flags": 0, "createdate": "2011-10-26T00:00:00", "modifydate": "2011-10-26T09:27:58", "lines": 87, "newlines": 87, "modlines": 0, "user": "CLEMSON"}, "text": "*---------------------------------------------------------------------*\n*  Copyright 2011 by Clemson University Research Foundation           *\n*                                                                     *\n*  Licensed under the Apache License, Version 2.0 (the \"License\");    *\n*  you may not use this file except in compliance with the License.   *\n*  You may obtain a copy of the License in this library as member     *\n*  $LICENSE, or from                                                  *\n*                                                                     *\n*      http://www.apache.org/licenses/LICENSE-2.0                     *\n*                                                                     *\n*  Unless required by applicable law or agreed to in writing,         *\n*  software distributed under the License is distributed on an \"AS    *\n*  IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either    *\n*  express or implied.  See the License for the specific language     *\n*  governing permissions and limitations under the License.           *\n*---------------------------------------------------------------------*\n//SRVMSXRB JOB TIME=(,3)\n/*JOBPARM LINES=9\n//  EXEC  ASMPCL,COPT=',RENT',LOPT=',RENT,REUS,REFR',\n//    PDS='SYSTEMS.SRV.LOAD',NAME=SRVMSXRB,MAC=SYSTEMS\n//P.SYSIN  DD  *\n     SMLIST CONVERT=YES\nSRVMSXRB     TITLE 'Exercise Message Service Processor Message Macros'\n*---------------------------------------------------------------------*\n*\n*  Copyright (C) 1989 Clemson University\n*\n*  Program     SRVMSXRB\n*\n*  Abstract    xxx\n*              xxx\n*              xxx\n*\n*  Inputs:\n*      Parameters  xxxxx\n*      Files       xxxxx\n*      Other       None\n*\n*  Outputs:\n*      Returncodes xxxxx\n*      Messages    xxxxx\n*      Files       xxxxx\n*      Other       None\n*\n*  PROGRAM     Reentrant, problem key and state, standard linkage,\n*  ATTRIBUTES  non-authorized, non-executable, AMODE(24), RMODE(24)\n*\n*  Special     xxx\n*  Notes       xxx\n*\n*  Change\n*  History     09/15/89 ___ - New\n*              __/__/__ ___\n*              __/__/__ ___\n*\n*  Method of   xxx\n*  Operation   xxx\n*\n*\n*---------------------------------------------------------------------*\n         EJECT\n     print off\n     copy  srvmsmac\n     print on\n     eject\n  MS_Message_Module  START,                                            *\n               name=srvMSXRB,                                          *\n               prefix=XRB,                                             *\n               idlength=7\n     eject\nXRB001i ms_message \"Informational message.\"\n     space 2\nXRB002e ms_message \"Error message, which should set MAXSEV to 8.\"\n     space 2\nXRB003c ms_message \"Fatal message, which should set MAXSEV to 16.\"\n     space 2\nXRB004i ms_message \"Test message with 3 integers: {I}, {I}, {I}.\"\n     space 2\nXRB005i ms_message \"MAXSEV value is now {IL2}.\"\n     space 2\nXRB006i ms_message \"{@1}Step on @1.{@15}Step on @15.{@5}Step on @5.\"\n     space 2\n  MS_Message_Module  END\n     end   ,\n//C.SYSLIB DD\n//         DD\n//         DD DSN=SYSTEMS.SRV.SOURCE,DISP=SHR\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SRVMSXRZ": {"ttr": 32516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x02\\x00\\x00X\\x01\\x11)\\x9f\\x01\\x11)\\x9f\\t'\\x00\\xaf\\x00\\xaf\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@\"", "ispf": {"version": "02.00", "flags": 0, "createdate": "2011-10-26T00:00:00", "modifydate": "2011-10-26T09:27:58", "lines": 175, "newlines": 175, "modlines": 0, "user": "CLEMSON"}, "text": "*---------------------------------------------------------------------*\n*  Copyright 2011 by Clemson University Research Foundation           *\n*                                                                     *\n*  Licensed under the Apache License, Version 2.0 (the \"License\");    *\n*  you may not use this file except in compliance with the License.   *\n*  You may obtain a copy of the License in this library as member     *\n*  $LICENSE, or from                                                  *\n*                                                                     *\n*      http://www.apache.org/licenses/LICENSE-2.0                     *\n*                                                                     *\n*  Unless required by applicable law or agreed to in writing,         *\n*  software distributed under the License is distributed on an \"AS    *\n*  IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either    *\n*  express or implied.  See the License for the specific language     *\n*  governing permissions and limitations under the License.           *\n*---------------------------------------------------------------------*\n//SRVMSXRZ JOB TIME=(,3)\n/*JOBPARM LINES=9\n//  EXEC  ASMPCL,COPT=',RENT',LOPT=',RENT,REUS,REFR',\n//    PDS='SYSTEMS.SRV.LOAD',NAME=SRVMSXRZ,MAC=SYSTEMS\n//P.SYSIN  DD  *\n     SMLIST CONVERT=YES\nSRVMSXRZ     TITLE 'Exerciser For Message Service Processor'\n*---------------------------------------------------------------------*\n*\n*  Copyright (C) 1989 Clemson University\n*\n*  Program     SRVMSXRZ\n*\n*  Abstract    xxx\n*              xxx\n*              xxx\n*\n*  Inputs:\n*      Parameters  xxxxx\n*      Files       xxxxx\n*      Other       None\n*\n*  Outputs:\n*      Returncodes xxxxx\n*      Messages    xxxxx\n*      Files       xxxxx\n*      Other       None\n*\n*  PROGRAM     Reentrant, problem key and state, standard linkage,\n*  ATTRIBUTES  non-authorized, AMODE(24), RMODE(24)\n*\n*  Special     xxx\n*  Notes       xxx\n*\n*  Change\n*  History     09/15/89 ___ - New\n*              __/__/__ ___\n*              __/__/__ ___\n*\n*  Method of   xxx\n*  Operation   xxx\n*\n*\n*---------------------------------------------------------------------*\n         EJECT\n     print off\n     copy  srvesmac\n     copy  srvplmac\n     print on,gen\n     copy  srvmsmac\n     eject\n block name=SRVMSXRZ,type=program,options=(*pwa,xa,mode),amode=31,     *\n               subopts=*swa,                                           *\n               rmode=any\n     eject\n  es_id id=es,esva=pwa_esv_address,                                    +\n               spepa=pwa_es_epa,                                       +\n               sptoken=pwa_es_token\n     space 3\n* pl_id        id=pl,esva=pwa_esv_address,\n*              esid=es,\n*              spepname=&Print_Line,\n*              spepa=pwa_PL_epa,\n*              sptoken=pwa_pl_token,\n*              sizelength=2\n     space 3\n  ms_id        id=ms,esva=pwa_esv_address,                             *\n               esid=es,                                                *\n               spepname=&Message_Services,                             *\n               spepa=pwa_ms_epa,                                       *\n               sptoken=pwa_ms_token,                                   *\n               sizelength=2\n     eject\n  es_MVS_load id=ES\n  ES_Start id=ES\n* ES_Load_Module id=ES,spid=PL\n  ES_Load_Module id=ES,spid=MS\n  if    (treg,r15,nz)\n   ex    0,*\n  endif\n* PL_Start     ID=PL,\n*              DDNAME=psd_sysprint,\n*              PageSize=55,\n*              MaxLnSz=121,\n*              sizelength=2\n* errexit (treg,r15,nz)\n        eject\n* *-------------------------------------------------------------------*\n* * Various cases of MS_START.\n* *-------------------------------------------------------------------*\n  MS_Start     ID=MS,                                                  *\n               MsgDest=CONSOLE,                                        *\n               MsgMod=(srvmsxra,srvmsxrb),                             *\n               MaxSev=pwa_maxcc,             ** succeed **             *\n               SizeLength=2\n  errexit (treg,r15,nz)\n* *-------------------------------------------------------------------*\n  ms_issue_message ID=MS,                                              *\n               Msgid==c'xrb006i'\n  errexit (treg,r15,nz)\n* *-------------------------------------------------------------------*\n  ms_put_message id=MS,                                                *\n               string=\" This is a test message.\"\n  errexit (treg,r15,nz)\n  ms_put_message id=MS,                                                *\n               string=\" This is another test message.\"\n  errexit (treg,r15,nz)\n  ms_put_message id=MS,                                                *\n               string=\" This is yet another test message.\"\n  errexit (treg,r15,nz)\n  ms_put_message id=MS,                                                *\n               string=\" This is still another test message.\"\n  errexit (treg,r15,nz)\n* callsub display_it\n* *-------------------------------------------------------------------*\n* *-------------------------------------------------------------------*\n  MS_Terminate ID=MS\n* *-------------------------------------------------------------------*\n     eject\n endblk\n block name=display_it,type=subroutine\n  lh    r0,pwa_resultlen\n  la    r1,pwa_message\n  tput  (1),(0),r\n endblk\n block type=errexit\n* ex    0,*\n  es_display_debug_info_and_abend id=es\n endblk\n     psd   ,\npsd_sysprint   dc  c'sysprint'\npsd_csectlist  dc  f'2',cl8'srvmsxra',cl8'srvmsxrb'\n     endpsd ,\n     pwa   ,\np1    ds    f\np2    ds    f\np3    ds    f\np4    ds    f\np5    ds    f\np6    ds    f\npwapage#          ds   f\npwapage#2         ds   f\npwaline#          ds   f\npwa_counter       ds   f\npwa_esv_address   ds   f\npwa_pl_epa        ds   f\npwa_es_epa        ds   f\npwa_ms_epa        ds   f\npwa_pl_token      ds   f\npwa_es_token      ds   f\npwa_ms_token      ds   f\npwa_message       ds   cl256\npwa_resultlen     ds   h\npwa_maxcc         ds   h\n     endpwa ,\n     end   ,\n//C.SYSLIB DD\n//         DD\n//         DD DSN=SYSTEMS.SRV.SOURCE,DISP=SHR\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SRVMSXR2": {"ttr": 32520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x02\\x00\\x00X\\x01\\x11)\\x9f\\x01\\x11)\\x9f\\t'\\x00\\xb8\\x00\\xb8\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@\"", "ispf": {"version": "02.00", "flags": 0, "createdate": "2011-10-26T00:00:00", "modifydate": "2011-10-26T09:27:58", "lines": 184, "newlines": 184, "modlines": 0, "user": "CLEMSON"}, "text": "*---------------------------------------------------------------------*\n*  Copyright 2011 by Clemson University Research Foundation           *\n*                                                                     *\n*  Licensed under the Apache License, Version 2.0 (the \"License\");    *\n*  you may not use this file except in compliance with the License.   *\n*  You may obtain a copy of the License in this library as member     *\n*  $LICENSE, or from                                                  *\n*                                                                     *\n*      http://www.apache.org/licenses/LICENSE-2.0                     *\n*                                                                     *\n*  Unless required by applicable law or agreed to in writing,         *\n*  software distributed under the License is distributed on an \"AS    *\n*  IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either    *\n*  express or implied.  See the License for the specific language     *\n*  governing permissions and limitations under the License.           *\n*---------------------------------------------------------------------*\n//SRVMSXRZ JOB TIME=(,3)\n/*JOBPARM LINES=9\n//  EXEC  ASMPCL,COPT=',RENT',LOPT=',RENT,REUS,REFR',\n//    PDS='SYSTEMS.SRV.LOAD',NAME=SRVMSXRZ,MAC=SYSTEMS\n//P.SYSIN  DD  *\n     SMLIST CONVERT=YES\nSRVMSXRZ     TITLE 'Exerciser For Message Service Processor'\n*---------------------------------------------------------------------*\n*\n*  Copyright (C) 1989 Clemson University\n*\n*  Program     SRVMSXRZ\n*\n*  Abstract    xxx\n*              xxx\n*              xxx\n*\n*  Inputs:\n*      Parameters  xxxxx\n*      Files       xxxxx\n*      Other       None\n*\n*  Outputs:\n*      Returncodes xxxxx\n*      Messages    xxxxx\n*      Files       xxxxx\n*      Other       None\n*\n*  PROGRAM     Reentrant, problem key and state, standard linkage,\n*  ATTRIBUTES  non-authorized, AMODE(24), RMODE(24)\n*\n*  Special     xxx\n*  Notes       xxx\n*\n*  Change\n*  History     09/15/89 ___ - New\n*              __/__/__ ___\n*              __/__/__ ___\n*\n*  Method of   xxx\n*  Operation   xxx\n*\n*\n*---------------------------------------------------------------------*\n         EJECT\n     print off\n     copy  srvesmac\n     copy  srvplmac\n     copy  srvmsmac\n     print on,gen\n     eject\n block name=SRVMSXRZ,type=program,options=(*pwa,xa,mode),amode=31,     *\n               subopts=*swa,                                           *\n               rmode=any\n     eject\n  es_id id=es,esva=pwa_esv_address,                                    +\n               spepa=pwa_es_epa,                                       +\n               sptoken=pwa_es_token\n     space 3\n  pl_id        id=pl,esva=pwa_esv_address,                             *\n               esid=es,                                                *\n               spepname=&Print_Line,                                   *\n               spepa=pwa_PL_epa,                                       *\n               sptoken=pwa_pl_token,                                   *\n               sizelength=2\n     space 3\n  ms_id        id=ms,esva=pwa_esv_address,                             *\n               esid=es,                                                *\n               spepname=&Message_Services,                             *\n               spepa=pwa_ms_epa,                                       *\n               sptoken=pwa_ms_token,                                   *\n               sizelength=2\n     eject\n  es_MVS_load id=ES\n  ES_Start id=ES\n  ES_Load_Module id=ES,spid=PL\n  ES_Load_Module id=ES,spid=MS\n  if    (treg,r15,nz)\n   ex    0,*\n  endif\n  PL_Start     ID=PL,                                                  *\n               DDNAME=psd_sysprint,                                    *\n               PageSize=55,                                            *\n               MaxLnSz=121,                                            *\n               sizelength=2\n  errexit (treg,r15,nz)\n        eject\n* *-------------------------------------------------------------------*\n* * Various cases of MS_START.\n* *-------------------------------------------------------------------*\n  MS_Start     ID=MS,                                                  *\n               MsgDest=CONSOLE,                                        *\n               MsgMod=(srvxrams,srvxrbms),                             *\n               MaxSev=pwa_maxcc,             ** succeed **             *\n               SizeLength=2\n  errexit (treg,r15,nz)\n* *-------------------------------------------------------------------*\n  MS_issue_message ID=MS,                                              *\n               Msgid='xra001i'\n  errexit (treg,r15,nz)\n  MS_issue_message ID=MS,                                              *\n               Msgid='xra005i',                                        *\n               source=(pwa_maxcc)\n  errexit (treg,r15,nz)\n* *-------------------------------------------------------------------*\n  MS_issue_message ID=MS,                                              *\n               Msgid==c'xra002e'\n  errexit (treg,r15,nz)\n  MS_issue_message ID=MS,                                              *\n               Msgid==c'xra005i',                                      *\n               source=(pwa_maxcc)\n  errexit (treg,r15,nz)\n* *-------------------------------------------------------------------*\n  MS_issue_message ID=MS,                                              *\n               Msgid==c'xra999c'\n  errexit (treg,r15,nz)\n  MS_issue_message ID=MS,                                              *\n               Msgid==c'xra005i',                                      *\n               source=(pwa_maxcc)\n  errexit (treg,r15,nz)\n* *-------------------------------------------------------------------*\n  MS_issue_message ID=MS,                                              *\n               Msgid==c'xra001i'\n  errexit (treg,r15,nz)\n  MS_issue_message ID=MS,                                              *\n               Msgid==c'xra005i',                                      *\n               source=(pwa_maxcc)\n  errexit (treg,r15,nz)\n* *-------------------------------------------------------------------*\n* *-------------------------------------------------------------------*\n  MS_Terminate ID=MS\n* *-------------------------------------------------------------------*\n     eject\n endblk\n block type=errexit\n* ex    0,*\n  es_display_debug_info_and_abend id=es\n endblk\n     psd   ,\npsd_sysprint   dc  c'sysprint'\npsd_csectlist  dc  f'2',cl8'srvxrams',cl8'srvxrams'\n     endpsd ,\n     pwa   ,\np1    ds    f\np2    ds    f\np3    ds    f\np4    ds    f\np5    ds    f\np6    ds    f\npwapage#          ds   f\npwapage#2         ds   f\npwaline#          ds   f\npwa_counter       ds   f\npwa_esv_address   ds   f\npwa_pl_epa        ds   f\npwa_es_epa        ds   f\npwa_ms_epa        ds   f\npwa_pl_token      ds   f\npwa_es_token      ds   f\npwa_ms_token      ds   f\npwa_message       ds   cl256\npwa_resultlen     ds   h\npwa_maxcc         ds   h\n     endpwa ,\n     end   ,\n//C.SYSLIB DD\n//         DD\n//         DD DSN=SYSTEMS.SRV.SOURCE,DISP=SHR\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SRVPLMAC": {"ttr": 32524, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x02\\x00\\x00X\\x01\\x11)\\x9f\\x01\\x11)\\x9f\\t'\\x05\\x9f\\x05\\x9f\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@\"", "ispf": {"version": "02.00", "flags": 0, "createdate": "2011-10-26T00:00:00", "modifydate": "2011-10-26T09:27:58", "lines": 1439, "newlines": 1439, "modlines": 0, "user": "CLEMSON"}, "text": "*---------------------------------------------------------------------*\n*  Copyright 2011 by Clemson University Research Foundation           *\n*                                                                     *\n*  Licensed under the Apache License, Version 2.0 (the \"License\");    *\n*  you may not use this file except in compliance with the License.   *\n*  You may obtain a copy of the License in this library as member     *\n*  $LICENSE, or from                                                  *\n*                                                                     *\n*      http://www.apache.org/licenses/LICENSE-2.0                     *\n*                                                                     *\n*  Unless required by applicable law or agreed to in writing,         *\n*  software distributed under the License is distributed on an \"AS    *\n*  IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either    *\n*  express or implied.  See the License for the specific language     *\n*  governing permissions and limitations under the License.           *\n*---------------------------------------------------------------------*\n TITLE 'SRVPLMAC: Item Manager Service Processor Symbols && Macros.'\n*---------------------------------------------------------------------*\n*\n*  Copy File:  SRVPLMAC\n*\n*  Purpose:    Print_Line service processor symbols and macros.\n*\n*  Description: See \"Service Processors User's Guide and Reference\".\n*\n*  Change\n*  History:    09/12/89 JCB - New\n*              05/02/95 MGG - Added file handler support.\n*              09/06/95 MSA - Added keyword REFERENCE to PL_START and\n*                             added macro PL_GET_REFERENCE.\n*              11/14/96 REM - Added PL_INVALID_MAXLINESIZE,\n*                             PL_INVALID_LRECL, and\n*                             PL_LINE_WRAPPING codes.\n*\n*---------------------------------------------------------------------*\n*\n***********************************************************************\n***********************************************************************\n**                                                                   **\n**                     Symbol Definitions                            **\n**                                                                   **\n***********************************************************************\n***********************************************************************\n GBLC &PRINT_LINE,&MVS_PRINT_LINE\n GBLA &PL_START,&PL_TERMINATE\n GBLA &PL_SET_HEADER,&PL_SET_FORMATTED_HEADER,&PL_RESET_HEADER\n GBLA &PL_SET_FOOTER,&PL_SET_FORMATTED_FOOTER,&PL_RESET_FOOTER\n GBLA &PL_RESERVE_FOOTER\n GBLA &PL_PAGE_BREAK,&PL_PRINT,&PL_PRINT_FORMATTED\n GBLA &PL_QUERY_LINES_LEFT\n GBLA &PL_GET_INFO\n GBLA &PL_GET_REFERENCE\n*\n GBLA &PL_SUCCESS\n GBLA &PL_INVALID_FUNCTION\n GBLA &PL_INVALID_NUMBER_OF_PARMS\n GBLA &PL_INVALID_PL_ID\n GBLA &PL_MEMORY_MANAGER_ERROR\n GBLA &PL_CANNOT_OPEN_DCB\n GBLA &PL_FILE_HANDLER_ERROR\n GBLA &PL_ENVIRONMENT_SUPPORT_ERROR\n GBLA &PL_STRING_HANDLER_ERROR\n GBLA &PL_PRINT_LINE_TRUNCATED\n GBLA &PL_PAGE_OVERFLOW\n GBLA &PL_HEADER_NOT_FOUND\n GBLA &PL_FOOTER_NOT_FOUND\n GBLA &PL_INVALID_PAGEDISP\n GBLA &PL_INVALID_SIZELENGTH\n GBLA &PL_MISSING_PARAMETER\n GBLA &PL_HEADER_LINE_TRUNCATED\n GBLA &PL_FOOTER_LINE_TRUNCATED\n GBLA &PL_INVALID_GI_SUBCODE\n GBLA &PL_INVALID_MAXLINESIZE\n GBLA &PL_INVALID_LRECL\n GBLA &PL_LINE_WRAPPING\n GBLA &PL_INTERNAL_ERROR\n*\n GBLA &PL_GI_LRECL\n GBLA &PL_GI_RECFM\n GBLA &PL_GI_FIMSG\n GBLA &PL_GI_FIRC\n*\n* Entry point name for the Item Manager.\n*\n&PRINT_LINE                             SETC '''SRVPL   '''\n&MVS_PRINT_LINE                         SETC '''SRVPLMVS'''\n*\n* Function codes.\n*\n&PL_START                               SETA 1\n&PL_TERMINATE                           SETA 2\n&PL_SET_HEADER                          SETA 3\n&PL_SET_FORMATTED_HEADER                SETA 4\n&PL_RESET_HEADER                        SETA 5\n&PL_SET_FOOTER                          SETA 6\n&PL_SET_FORMATTED_FOOTER                SETA 7\n&PL_RESET_FOOTER                        SETA 8\n&PL_RESERVE_FOOTER                      SETA 9\n&PL_PAGE_BREAK                          SETA 10\n&PL_PRINT                               SETA 11\n&PL_PRINT_FORMATTED                     SETA 12\n&PL_QUERY_LINES_LEFT                    SETA 13\n&PL_GET_INFO                            SETA 14\n&PL_GET_REFERENCE                       SETA 15\n*\n* Informational codes for use with PL_GET_INFO.\n*\n&PL_GI_LRECL            SETA 1          Get the file's logical rec len.\n&PL_GI_FIMSG            SETA 2          Get file handler's message.\n&PL_GI_FIRC             SETA 3          Get file handler's retcode.\n&PL_GI_RECFM            SETA 4          Get the file's record format.\n*\n* Return codes.\n*\n&PL_SUCCESS                             SETA  0\n&PL_INVALID_FUNCTION                    SETA  1\n&PL_INVALID_NUMBER_OF_PARMS             SETA  2\n&PL_INVALID_PL_ID                       SETA  3\n&PL_MEMORY_MANAGER_ERROR                SETA  4\n&PL_CANNOT_OPEN_DCB                     SETA  5\n&PL_FILE_HANDLER_ERROR                  SETA  5 Same as CANNOT_OPEN_DCB\n&PL_ENVIRONMENT_SUPPORT_ERROR           SETA  6\n&PL_STRING_HANDLER_ERROR                SETA  7\n&PL_PRINT_LINE_TRUNCATED                SETA  8\n&PL_PAGE_OVERFLOW                       SETA  9\n&PL_HEADER_NOT_FOUND                    SETA 10\n&PL_FOOTER_NOT_FOUND                    SETA 11\n&PL_INVALID_PAGEDISP                    SETA 12\n&PL_INVALID_SIZELENGTH                  SETA 13\n&PL_MISSING_PARAMETER                   SETA 14\n&PL_HEADER_LINE_TRUNCATED               SETA 15\n&PL_FOOTER_LINE_TRUNCATED               SETA 16\n&PL_INVALID_GI_SUBCODE                  SETA 17\n&PL_INVALID_MAXLINESIZE                 SETA 18\n&PL_INVALID_LRECL                       SETA 19\n&PL_LINE_WRAPPING                       SETA 20\n&PL_INTERNAL_ERROR                      SETA 21\n*\n* DEFUCOND macros to facilitate checking return codes. If new return\n* codes are added, don't forget to add a DEFUCOND for them.\n*\n   DEFUCOND MACRO=SRV##RC,NAME=PL_SUCCESS\n   DEFUCOND MACRO=SRV##RC,NAME=PL_INVALID_FUNCTION\n   DEFUCOND MACRO=SRV##RC,NAME=PL_INVALID_NUMBER_OF_PARMS\n   DEFUCOND MACRO=SRV##RC,NAME=PL_INVALID_PL_ID\n   DEFUCOND MACRO=SRV##RC,NAME=PL_MEMORY_MANAGER_ERROR\n   DEFUCOND MACRO=SRV##RC,NAME=PL_CANNOT_OPEN_DCB\n   DEFUCOND MACRO=SRV##RC,NAME=PL_FILE_HANDLER_ERROR\n   DEFUCOND MACRO=SRV##RC,NAME=PL_ENVIRONMENT_SUPPORT_ERROR\n   DEFUCOND MACRO=SRV##RC,NAME=PL_STRING_HANDLER_ERROR\n   DEFUCOND MACRO=SRV##RC,NAME=PL_PRINT_LINE_TRUNCATED\n   DEFUCOND MACRO=SRV##RC,NAME=PL_PAGE_OVERFLOW\n   DEFUCOND MACRO=SRV##RC,NAME=PL_HEADER_NOT_FOUND\n   DEFUCOND MACRO=SRV##RC,NAME=PL_FOOTER_NOT_FOUND\n   DEFUCOND MACRO=SRV##RC,NAME=PL_INVALID_PAGEDISP\n   DEFUCOND MACRO=SRV##RC,NAME=PL_INVALID_SIZELENGTH\n   DEFUCOND MACRO=SRV##RC,NAME=PL_MISSING_PARAMETER\n   DEFUCOND MACRO=SRV##RC,NAME=PL_HEADER_LINE_TRUNCATED\n   DEFUCOND MACRO=SRV##RC,NAME=PL_FOOTER_LINE_TRUNCATED\n   DEFUCOND MACRO=SRV##RC,NAME=PL_INVALID_GI_SUBCODE\n   DEFUCOND MACRO=SRV##RC,NAME=PL_INVALID_MAXLINESIZE\n   DEFUCOND MACRO=SRV##RC,NAME=PL_INVALID_LRECL\n   DEFUCOND MACRO=SRV##RC,NAME=PL_LINE_WRAPPING\n*\n* Miscellaneous definitions.\n*\n GBLA   &PL_DEFAULT_PAGESIZE\n GBLA   &PL_DEFAULT_MAXLINESIZE\n GBLA   &PL_DEFAULT_SIZELENGTH\n&PL_DEFAULT_PAGESIZE        SETA  66\n&PL_DEFAULT_MAXLINESIZE     SETA  133\n&PL_DEFAULT_SIZELENGTH      SETA  4\n                        EJECT\n***********************************************************************\n***********************************************************************\n**                                                                   **\n**                     Macro Definitions                             **\n**                                                                   **\n***********************************************************************\n***********************************************************************\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   PL_ID                                                      *\n*                                                                     *\n* Purpose: Establish default values for a specific service processor  *\n*          and associate them with the specified ID name. The values  *\n*          are stored in the following created global variables:      *\n*                                                                     *\n* Variable Name                     Description                       *\n* -------------  ---------------------------------------------------- *\n* #$&ID.$#IDMAC  Name of macro that created the ID: PL_ID.            *\n* #$&ID.$#ESID   Service processor's Environment Support ID.          *\n* #$&ID.$#EPN    Tag for Service processor's Entry Point Name.        *\n* #$&ID.$#EPA    Tag for Service processor's Entry Point Address.     *\n* #$&ID.$#TKN    Tag for Service processor's Entry Point Token.       *\n* #$&ID.$#EMC    Tag for Service processor's error macro name.        *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         PL_ID &ID=,&ESVA=,&SPEPNAME=,&SPEPA=,&SPTOKEN=,&ESID=,        *\n               &SIZELENGTH=,&ERRMAC=\n         LCLC  &L_EPNAME\n         GBLC  &PRINT_LINE\n.*\n.* If no EPNAME was specified, use the generic PrintLine.\n.*\n&L_EPNAME SETC '&SPEPNAME'\n          AIF  ('&L_EPNAME' NE '').PAST_EPN\n&L_EPNAME SETC '&PRINT_LINE'\n.PAST_EPN ANOP\n.*\n.* Invoke SRV##ID to create globals used by all ID's.\n.*\n         SRV##ID SET,                                                  +\n               ID=&ID.,IDMAC=PL_ID,ESID=&ESID.,SPEPNAME=&L_EPNAME,     +\n               SPEPA=&SPEPA,SPTOKEN=&SPTOKEN.,ERRMAC=&ERRMAC.\n.*\n.* Establish defaults for parameters specific to the string handler.\n.*\n&PL_SIZELENGTH   SETC '#$&ID.$#SIZELENGTH'  Variable for SIZELENGTH=.\n                 GBLC &(&PL_SIZELENGTH)     Declare global variable.\n&(&PL_SIZELENGTH) SETC '4'                  Set sizelength's default.\n                 AIF  ('&SIZELENGTH' EQ '').GOT_SIZELENGTH\n                 AIF  (T'&SIZELENGTH EQ 'N').SL_NUMERIC\n                 MNOTE 8,'If SIZELENGTH is specified on the ST_ID macro+\n               , it must be a self-defining numeric value.'\n                 AGO   .GOT_SIZELENGTH\n.SL_NUMERIC      ANOP\n&(&PL_SIZELENGTH) SETC '&SIZELENGTH'        Copy value (or nulls).\n.GOT_SIZELENGTH  ANOP\n         MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   PL_START                                                   *\n* Purpose: Generate code to start a new Print_Line session.           *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         PL_START &ID=,&SPEPA=,&SPTOKEN=,&ESVA=,&ERRMAC=,              +\n               &DDNAME=,                                               *\n               &SIZELENGTH=,                                           *\n               &PAGESIZE=60,                                           *\n               &MAXLNSZ=133,                                           *\n               &OPTIONS=,                                              *\n               &REFERENCE=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN,&#_IDEMC\n         GBLA  &PL_START                  SETC in open code.\n         LCLA  &I\n         LCLB  &OPT_FOLD\n.*\n.* Obtain service processor ID values.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN,ESVA),                    +\n               ID=&ID,IDMAC=PL_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN,       +\n               ESVA=&ESVA.,ERRMAC=&ERRMAC.\n         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT\n         MVC   &#_IDTKN,=F'0'            | Insure TOKEN = 0.\n.*\n.* Validate the incoming parameters.\n.*\n.*\n.* Decode the options and produce a byte flag for the parmlist.\n.*\n&I       SETA  1\n.OPTLOOP AIF   (&I GT N'&OPTIONS).PASTOPT\n         AIF   ('&OPTIONS(&I)' EQ 'FOLD').OPT1\n         MNOTE 8,'Invalid option name: &OPTIONS(&I)'\n.OPT1    ANOP\n&OPT_FOLD SETB 1\n         AGO   .NEXTOPT         Go process the next option.\n.*\n.*  Add additional options here.\n.*\n.NEXTOPT ANOP\n&I       SETA  &I+1             Increment index into options list.\n         AGO   .OPTLOOP         Branch back to top of loop.\n.PASTOPT ANOP\n&OPTSTR  SETC '&OPT_FOLD'\n&OPTSTR  SETC '&OPTSTR.0000000'\n         AIF  ('&OPTSTR' NE '00000000').NOT_NOP\n&OPTSTR  SETC ''\n         AGO  .PAST_OPTSTR_SET\n.NOT_NOP ANOP\n&OPTSTR  SETC '=B''&OPTSTR'''\n.PAST_OPTSTR_SET ANOP\n.*\n         AIF   ('&DDNAME' NE '').DDOK\n         MNOTE 8,'DDname must be specified.'\n         MEXIT\n.DDOK    ANOP\n.*       AIF   (T'&PAGESIZE EQ 'N' AND &PAGESIZE LE 66).PGSZOK\n.*       MNOTE 8,'Pagesize must be numeric and have a value of 66 or le\n.*             ss.'\n.*       MEXIT\n.PGSZOK  ANOP\n.*       AIF   (T'&MAXLNSZ EQ 'N' AND &MAXLNSZ LE 255).LNSZOK\n.*       MNOTE 8,'MaxLnSz must be numeric and have a value of 255 or le\n.*             ss.'\n.*       MEXIT\n.LNSZOK  ANOP\n.*\n.* Obtain the value for the SIZELENGTH keyword.\n.*\n&PL_SIZELENGTH   SETC '#$&ID.$#SIZELENGTH'  Variable for SIZELENGTH=.\n                 GBLC &(&PL_SIZELENGTH)     Declare global variable.\n&L_SIZELENGTH    SETC '&(&PL_SIZELENGTH)'   Set default value.\n                 AIF  ('&L_SIZELENGTH' EQ '').SL_OKAY\n                 AIF  ('&SIZELENGTH' EQ '').SL_DONE\n                 AIF  ('&L_SIZELENGTH' EQ '&SIZELENGTH').SL_DONE\n*                MNOTE 4,'Warning: SIZELENGTH was specified with a diff\n*              erent value on the ST_ID ID=&ID. instruction.'\n.SL_OKAY         ANOP\n&L_SIZELENGTH    SETC '&SIZELENGTH'\n&(&PL_SIZELENGTH) SETC '&SIZELENGTH'     Set default value.\n.SL_DONE         ANOP\n.*\n.* Generate the PL_START call.\n.*\n.*       CALLX &#_IDEPA,(&#_IDTKN,&PL_START,&#_IDESVA,&DDNAME,\n.*             &PAGESIZE,&MAXLNSZ,&(&PL_SIZELENGTH)),VL\n         ##PLIST START\n         ##PLIST PARM,&#_IDTKN\n         ##PLIST PARM,&PL_START\n         ##PLIST PARM,&#_IDESVA\n         ##PLIST PARM,&DDNAME\n         ##PLIST PARM,&PAGESIZE\n         ##PLIST PARM,&MAXLNSZ\n         ##PLIST PARM,&(&PL_SIZELENGTH)\n         AIF   ('&OPTSTR' EQ '' AND '&REFERENCE' EQ '').CALLEND\n         ##PLIST PARM,&OPTSTR\n         AIF   ('&REFERENCE' EQ '').CALLEND\n         ##PLIST PARM,&REFERENCE\n.CALLEND ANOP ,\n         ##PLIST END,VL\n         CALLX  &#_IDEPA\n         AIF    ('&#_IDEMC' EQ '').MEXIT\n         &#_IDEMC.\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   PL_TERMINATE                                               *\n* Purpose: Generate code to terminate a Print_Line session.           *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         PL_TERMINATE &ID=,&SPEPA=,&SPTOKEN=,&ERRMAC=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN,&#_IDEMC\n         GBLA  &PL_TERMINATE              SETC in open code.\n.*\n.* Obtain service processor ID values and terminate service processor.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +\n               ID=&ID,IDMAC=PL_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN,       +\n               ERRMAC=&ERRMAC.\n         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT\n         CALLX &#_IDEPA,(&#_IDTKN,&PL_TERMINATE),VL\n         AIF    ('&#_IDEMC' EQ '').MEXIT\n         &#_IDEMC.\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   PL_SET_HEADER                                              *\n* Purpose: Establish a header line from a simple print line.          *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         PL_SET_HEADER &ID=,&SPEPA=,&SPTOKEN=,&ERRMAC=,                +\n               &LINE=0,                                                +\n               &STRING=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN,&#_IDEMC\n         GBLA  &PL_SET_HEADER\n         LCLC  &S_ADDR,&S_LEN\n         LCLC  &V_STRING(2),&PL_SIZELENGTH\n         LCLC  &L_STRING(2)\n         LCLA  &N\n         LCLC  &KEYWORD\n.*\n.* Obtain service processor ID values.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +\n               ID=&ID,IDMAC=PL_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN,       +\n               ERRMAC=&ERRMAC.\n         AIF  ('&#_IDCODE' EQ 'SUCCESS').VALIDATE\n         MNOTE 8,'SRV##ID unable to set global variables.'\n         MEXIT\n.VALIDATE ANOP\n.*\n.* Validate incoming parameters.\n.*\n         AIF   (T'&LINE EQ 'N').LINEOK\n         AIF   ('&LINE' NE '').LINEOK\n.LINEBAD MNOTE 8,'Line must be specified as the address of a fullword o*\n               r a numeric value.'\n         MEXIT\n.LINEOK  ANOP\n&PL_SIZELENGTH SETC '#$&ID.$#SIZELENGTH'  Variable for SIZELENGTH=.\n               GBLC &(&PL_SIZELENGTH)     Declare global variable.\n.*\n.* If STRING= is missing, supply default values.\n.*\n&L_STRING(1)    SETC '&STRING(1)'\n&L_STRING(2)    SETC '&STRING(2)'\n                AIF ('&L_STRING(1)' NE '').STRING_NBLK\n&V_STRING(1)    SETC '#$&ID.$#STRING1'     Variable for STRING=.\n&V_STRING(2)    SETC '#$&ID.$#STRING2'     Variable for STRING=.\n                GBLC &(&V_STRING(1))       Declare global variable.\n                GBLC &(&V_STRING(2))       Declare global variable.\n&L_STRING(1)    SETC '&(&V_STRING(1))'     Copy default value.\n&L_STRING(2)    SETC '&(&V_STRING(2))'     Copy default value.\n.STRING_NBLK    ANOP\n.*\n.*\n.* Process the STRING keyword to get an address and length.\n.*\n&KEYWORD      SETC 'STRING'\n              AIF ('&L_STRING(1)' EQ '').NO_STRING\n              AIF ('&L_STRING(1)'(1,1) EQ '''').STR_LITERAL\n              AIF ('&L_STRING(2)' EQ '').STR_TAGONLY\n.STR_TAGLEN   ANOP\n&S_ADDR       SETC '&L_STRING(1)'         | Set addr.\n&S_LEN        SETC '&L_STRING(2)'         | Set len.\n              AGO  .PAST_STRING           |\n.STR_TAGONLY  AIF  ('&(&PL_SIZELENGTH)' EQ '').NO_SIZELENGTH\n&S_ADDR       SETC '&L_STRING(1)'         | Set addr to tag_name.\n&S_LEN        SETC '=AL&(&PL_SIZELENGTH).(L''&L_STRING(1))'\n              AGO  .PAST_STRING           |\n.STR_LITERAL  ANOP                        |\n&S_ADDR         SETC '&L_STRING(1)'         | Set addr to value.\n&L              SETA 0                      | Length counter = 0.\n&I              SETA 2                      | Index counter -> past '.\n.STR_LOOP       AIF  (&I GE K'&S_ADDR).STR_ELOOP     Loop over STRING.\n                AIF  ('&S_ADDR'(&I,1) NE '''').STR_TXT If doubled.\n&I              SETA &I+1                   |             Advance.\n.STR_TXT        ANOP                        |          EndIf.\n&L              SETA &L+1                   |   Add one to length.\n&I              SETA &I+1                   |   Advance.\n                AGO  .STR_LOOP              | End of counting loop.\n.STR_ELOOP      ANOP                        |\n&S_LEN          SETC '=AL&(&PL_SIZELENGTH).(&L)' Set length parameter.\n                AGO  .PAST_STRING\n.NO_STRING    MNOTE 8,'STRING is a required keyword.'\n              MEXIT\n.PAST_STRING  ANOP\n.*\n.* Generate the call to PL_SET_HEADER.\n.*\n.CALL    ANOP\n         CALLX &#_IDEPA,(&#_IDTKN,&PL_SET_HEADER,                      +\n               &LINE,&S_ADDR,&S_LEN),VL\n         AIF    ('&#_IDEMC' EQ '').MEXIT\n         &#_IDEMC.\n         MEXIT\n.NO_SIZELENGTH ANOP\n         MNOTE 8,'Explicit lengths must be specified unless the SIZELEN+\n               GTH keyword has been coded on the ST_ID macro.'\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   PL_SET_FORMATTED_HEADER                                    *\n* Purpose: Establish a header line from a format string and a set     *\n*          of substitution values.                                    *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         PL_SET_FORMATTED_HEADER &ID=,&SPEPA=,&SPTOKEN=,&ERRMAC=,      *\n               &LINE=0,                                                *\n               &CONTROL=,                                              *\n               &SOURCE=,                                               *\n               &PAGENUM=0\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN,&#_IDEMC\n         GBLA  &PL_SET_FORMATTED_HEADER\n         LCLC  &C_ADDR,&C_LEN\n         LCLC  &V_CONTROL(2),&PL_SIZELENGTH\n         LCLC  &L_CONTROL(2)\n         LCLA  &N\n         LCLC  &KEYWORD\n.*\n.* Obtain service processor ID values.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +\n               ID=&ID,IDMAC=PL_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN,       +\n               ERRMAC=&ERRMAC.\n         AIF  ('&#_IDCODE' EQ 'SUCCESS').VALIDATE\n         MNOTE 8,'SRV##ID unable to set global variables.'\n         MEXIT\n.VALIDATE ANOP\n.*\n.*\n.* Validate incoming parameters.\n.*\n         AIF   (T'&LINE EQ 'N').LINEOK\n         AIF   ('&LINE' NE '').LINEOK\n.LINEBAD MNOTE 8,'Line must be specified as the address of a fullword o*\n               r a numeric value.'\n         MEXIT\n.LINEOK  ANOP\n.*\n&PL_SIZELENGTH SETC '#$&ID.$#SIZELENGTH'  Variable for SIZELENGTH=.\n               GBLC &(&PL_SIZELENGTH)     Declare global variable.\n.*\n.* If CONTROL= is missing, supply default values.\n.*\n&L_CONTROL(1)   SETC '&CONTROL(1)'\n&L_CONTROL(2)   SETC '&CONTROL(2)'\n                AIF ('&L_CONTROL(1)' NE '').CONTROL_NBLK\n&V_CONTROL(1)   SETC '#$&ID.$#CONTROL1'    Variable for CONTROL=.\n&V_CONTROL(2)   SETC '#$&ID.$#CONTROL2'    Variable for CONTROL=.\n                GBLC &(&V_CONTROL(1))      Declare global variable.\n                GBLC &(&V_CONTROL(2))      Declare global variable.\n&L_CONTROL(1)   SETC '&(&V_CONTROL(1))'    Copy default value.\n&L_CONTROL(2)   SETC '&(&V_CONTROL(2))'    Copy default value.\n.CONTROL_NBLK   ANOP\n.*\n.*\n.* Process the CONTROL keyword to get an address and length.\n.*\n&KEYWORD      SETC 'CONTROL'\n              AIF ('&CONTROL' EQ '').NO_CONTROL\n              AIF (N'&CONTROL EQ 1).CTL_TAGONLY  CONTROL=tag.\n              AIF (N'&CONTROL EQ 2).CTL_TAGLEN   CONTROL=(tag,len).\n              MNOTE 8,'Too many subparameters for CONTROL keyword.'\n              MEXIT\n.*\n.CTL_TAGLEN   ANOP\n&C_ADDR       SETC '&CONTROL(1)'          | Set addr.\n&C_LEN        SETC '&CONTROL(2)'          | Set len.\n              AGO  .PAST_CONTROL          |\n.CTL_TAGONLY  AIF  ('&(&PL_SIZELENGTH)' EQ '').NO_SIZELENGTH\n              AIF  ('&CONTROL'(1,1) EQ '''').CTL_LITERAL\n&C_ADDR       SETC '&CONTROL'             | Set addr to tag_name.\n&C_LEN        SETC '=AL&(&PL_SIZELENGTH).(L''&CONTROL)' Get tag length.\n              AGO  .PAST_CONTROL          |\n.CTL_LITERAL  ANOP                        |\n&C_ADDR       SETC '&CONTROL'             | Set addr to actual literal.\n&L            SETA 0                      | Length counter = 0.\n&I            SETA 2                      | Index counter -> past '.\n.CTL_LOOP     AIF  (&I GE K'&C_ADDR).CTL_ELOOP       Loop over CONTROL.\n              AIF  ('&C_ADDR'(&I,1) NE '''').CTL_TXT If doubled quotes.\n&I            SETA &I+1                   |            Advance past '.\n.CTL_TXT      ANOP                        |          EndIf.\n&L            SETA &L+1                   |   Add one to length.\n&I            SETA &I+1                   |   Advance to next position.\n              AGO  .CTL_LOOP              | End of counting loop.\n.CTL_ELOOP    ANOP                        |\n&C_LEN        SETC '=AL&(&PL_SIZELENGTH).(&L)' Set length parameter.\n              AGO  .PAST_CONTROL\n.NO_CONTROL   MNOTE 8,'CONTROL is a required keyword.'\n              MEXIT\n.PAST_CONTROL ANOP\n.*\n.* Generate the format call to the CONTROL handler.\n.*\n         ##PLIST START\n         ##PLIST PARM,&#_IDTKN\n         ##PLIST PARM,&PL_SET_FORMATTED_HEADER\n         ##PLIST PARM,&LINE\n         ##PLIST PARM,&C_ADDR\n         ##PLIST PARM,&C_LEN\n         ##PLIST PARM,&PAGENUM\n&N       SETA  1\n.PL_LOOP ANOP\n         AIF   (&N GT N'&SOURCE).PL_LOOPEND\n         ##PLIST PARM,&SOURCE(&N)\n&N       SETA  &N+1\n         AGO   .PL_LOOP\n.PL_LOOPEND ANOP ,\n         ##PLIST END,VL\n         CALLX  &#_IDEPA\n         AIF    ('&#_IDEMC' EQ '').MEXIT\n         &#_IDEMC.\n         MEXIT\n.NO_SIZELENGTH ANOP\n         MNOTE 8,'Explicit lengths must be specified unless the SIZELEN+\n               GTH keyword has been coded on the ST_ID macro.'\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   PL_RESET_HEADER                                            *\n* Purpose: Delete the definition for one or all header lines.         *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         PL_RESET_HEADER &ID=,&SPEPA=,&SPTOKEN=,&ERRMAC=,              +\n               &LINE=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN,&#_IDEMC\n         GBLA  &PL_RESET_HEADER\n.*\n.* Obtain service processor ID values.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +\n               ID=&ID,IDMAC=PL_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN,       +\n               ERRMAC=&ERRMAC.\n         AIF  ('&#_IDCODE' EQ 'SUCCESS').VALIDATE\n         MNOTE 8,'SRV##ID unable to set global variables.'\n         MEXIT\n.VALIDATE ANOP\n.*\n.* Validate incoming parameters.\n.*\n         AIF   (T'&LINE EQ 'N').LINEOK\n         AIF   ('&LINE' NE '').LINEOK\n.LINEBAD MNOTE 8,'Line must be specified as the address of a fullword o*\n               r a numeric value.'\n         MEXIT\n.LINEOK  ANOP\n.*\n.* Generate the call to PL_RESET_HEADER.\n.*\n.CALL    ANOP\n         CALLX &#_IDEPA,(&#_IDTKN,&PL_RESET_HEADER,                    +\n               &LINE),VL\n         AIF    ('&#_IDEMC' EQ '').MEXIT\n         &#_IDEMC.\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   PL_SET_FOOTER                                              *\n* Purpose: Establish a footer line from a simple print line.          *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         PL_SET_FOOTER &ID=,&SPEPA=,&SPTOKEN=,&ERRMAC=,                +\n               &LINE=0,                                                +\n               &STRING=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN,&#_IDEMC\n         GBLA  &PL_SET_FOOTER\n         LCLC  &S_ADDR,&S_LEN\n         LCLC  &V_STRING(2),&PL_SIZELENGTH\n         LCLC  &L_STRING(2)\n         LCLA  &N\n         LCLC  &KEYWORD\n.*\n.* Obtain service processor ID values.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +\n               ID=&ID,IDMAC=PL_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN,       +\n               ERRMAC=&ERRMAC.\n         AIF  ('&#_IDCODE' EQ 'SUCCESS').VALIDATE\n         MNOTE 8,'SRV##ID unable to set global variables.'\n         MEXIT\n.VALIDATE ANOP\n.*\n.* Validate incoming parameters.\n.*\n         AIF   (T'&LINE EQ 'N').LINEOK\n         AIF   ('&LINE' NE '').LINEOK\n.LINEBAD MNOTE 8,'Line must be specified as the address of a fullword o*\n               r a numeric value.'\n         MEXIT\n.LINEOK  ANOP\n&PL_SIZELENGTH SETC '#$&ID.$#SIZELENGTH'  Variable for SIZELENGTH=.\n               GBLC &(&PL_SIZELENGTH)     Declare global variable.\n.*\n.* If STRING= is missing, supply default values.\n.*\n&L_STRING(1)    SETC '&STRING(1)'\n&L_STRING(2)    SETC '&STRING(2)'\n                AIF ('&L_STRING(1)' NE '').STRING_NBLK\n&V_STRING(1)    SETC '#$&ID.$#STRING1'     Variable for STRING=.\n&V_STRING(2)    SETC '#$&ID.$#STRING2'     Variable for STRING=.\n                GBLC &(&V_STRING(1))       Declare global variable.\n                GBLC &(&V_STRING(2))       Declare global variable.\n&L_STRING(1)    SETC '&(&V_STRING(1))'     Copy default value.\n&L_STRING(2)    SETC '&(&V_STRING(2))'     Copy default value.\n.STRING_NBLK    ANOP\n.*\n.*\n.* Process the STRING keyword to get an address and length.\n.*\n&KEYWORD      SETC 'STRING'\n              AIF ('&L_STRING(1)' EQ '').NO_STRING\n              AIF ('&L_STRING(1)'(1,1) EQ '''').STR_LITERAL\n              AIF ('&L_STRING(2)' EQ '').STR_TAGONLY\n.STR_TAGLEN   ANOP\n&S_ADDR       SETC '&L_STRING(1)'         | Set addr.\n&S_LEN        SETC '&L_STRING(2)'         | Set len.\n              AGO  .PAST_STRING           |\n.STR_TAGONLY  AIF  ('&(&PL_SIZELENGTH)' EQ '').NO_SIZELENGTH\n&S_ADDR       SETC '&L_STRING(1)'         | Set addr to tag_name.\n&S_LEN        SETC '=AL&(&PL_SIZELENGTH).(L''&L_STRING(1))'\n              AGO  .PAST_STRING           |\n.STR_LITERAL  ANOP                        |\n&S_ADDR         SETC '&L_STRING(1)'         | Set addr to value.\n&L              SETA 0                      | Length counter = 0.\n&I              SETA 2                      | Index counter -> past '.\n.STR_LOOP       AIF  (&I GE K'&S_ADDR).STR_ELOOP     Loop over STRING.\n                AIF  ('&S_ADDR'(&I,1) NE '''').STR_TXT If doubled.\n&I              SETA &I+1                   |             Advance.\n.STR_TXT        ANOP                        |          EndIf.\n&L              SETA &L+1                   |   Add one to length.\n&I              SETA &I+1                   |   Advance.\n                AGO  .STR_LOOP              | End of counting loop.\n.STR_ELOOP      ANOP                        |\n&S_LEN          SETC '=AL&(&PL_SIZELENGTH).(&L)' Set length parameter.\n                AGO  .PAST_STRING\n.NO_STRING    MNOTE 8,'STRING is a required keyword.'\n              MEXIT\n.PAST_STRING  ANOP\n.*\n.* Generate the call to PL_SET_FOOTER.\n.*\n.CALL    ANOP\n         CALLX &#_IDEPA,(&#_IDTKN,&PL_SET_FOOTER,                      +\n               &LINE,&S_ADDR,&S_LEN),VL\n         AIF    ('&#_IDEMC' EQ '').MEXIT\n         &#_IDEMC.\n         MEXIT\n.NO_SIZELENGTH ANOP\n         MNOTE 8,'Explicit lengths must be specified unless the SIZELEN+\n               GTH keyword has been coded on the ST_ID macro.'\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   PL_SET_FORMATTED_FOOTER                                    *\n* Purpose: Establish a footer line from a format string and a set     *\n*          of substitution values.                                    *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         PL_SET_FORMATTED_FOOTER &ID=,&SPEPA=,&SPTOKEN=,&ERRMAC=,      *\n               &LINE=0,                                                *\n               &CONTROL=,                                              *\n               &SOURCE=,                                               *\n               &PAGENUM=0\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN,&#_IDEMC\n         GBLA  &PL_SET_FORMATTED_FOOTER\n         LCLC  &C_ADDR,&C_LEN\n         LCLC  &V_CONTROL(2),&PL_SIZELENGTH\n         LCLC  &L_CONTROL(2)\n         LCLA  &N\n         LCLC  &KEYWORD\n.*\n.* Obtain service processor ID values.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +\n               ID=&ID,IDMAC=PL_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN,       +\n               ERRMAC=&ERRMAC.\n         AIF  ('&#_IDCODE' EQ 'SUCCESS').VALIDATE\n         MNOTE 8,'SRV##ID unable to set global variables.'\n         MEXIT\n.VALIDATE ANOP\n.*\n.*\n.* Validate incoming parameters.\n.*\n         AIF   (T'&LINE EQ 'N').LINEOK\n         AIF   ('&LINE' NE '').LINEOK\n.LINEBAD MNOTE 8,'Line must be specified as the address of a fullword o*\n               r a numeric value.'\n         MEXIT\n.LINEOK  ANOP\n.*\n&PL_SIZELENGTH SETC '#$&ID.$#SIZELENGTH'  Variable for SIZELENGTH=.\n               GBLC &(&PL_SIZELENGTH)     Declare global variable.\n.*\n.* If CONTROL= is missing, supply default values.\n.*\n&L_CONTROL(1)   SETC '&CONTROL(1)'\n&L_CONTROL(2)   SETC '&CONTROL(2)'\n                AIF ('&L_CONTROL(1)' NE '').CONTROL_NBLK\n&V_CONTROL(1)   SETC '#$&ID.$#CONTROL1'    Variable for CONTROL=.\n&V_CONTROL(2)   SETC '#$&ID.$#CONTROL2'    Variable for CONTROL=.\n                GBLC &(&V_CONTROL(1))      Declare global variable.\n                GBLC &(&V_CONTROL(2))      Declare global variable.\n&L_CONTROL(1)   SETC '&(&V_CONTROL(1))'    Copy default value.\n&L_CONTROL(2)   SETC '&(&V_CONTROL(2))'    Copy default value.\n.CONTROL_NBLK   ANOP\n.*\n.*\n.* Process the CONTROL keyword to get an address and length.\n.*\n&KEYWORD      SETC 'CONTROL'\n              AIF ('&L_CONTROL(1)' EQ '').NO_CONTROL\n              AIF ('&L_CONTROL(1)'(1,1) EQ '''').CTL_LITERAL\n              AIF ('&L_CONTROL(2)' EQ '').CTL_TAGONLY\n.CTL_TAGLEN   ANOP\n&C_ADDR       SETC '&L_CONTROL(1)'        | Set addr.\n&C_LEN        SETC '&L_CONTROL(2)'        | Set len.\n              AGO  .PAST_CONTROL          |\n.CTL_TAGONLY  AIF  ('&(&PL_SIZELENGTH)' EQ '').NO_SIZELENGTH\n&C_ADDR       SETC '&L_CONTROL(1)'        | Set addr to tag_name.\n&C_LEN        SETC '=AL&(&PL_SIZELENGTH).(L''&L_CONTROL(1))'\n              AGO  .PAST_CONTROL          |\n.CTL_LITERAL  ANOP                        |\n&C_ADDR         SETC '&L_CONTROL(1)'        | Set addr to value.\n&L              SETA 0                      | Length counter = 0.\n&I              SETA 2                      | Index counter -> past '.\n.CTL_LOOP       AIF  (&I GE K'&C_ADDR).CTL_ELOOP     Loop over CONTROL.\n                AIF  ('&C_ADDR'(&I,1) NE '''').CTL_TXT If doubled.\n&I              SETA &I+1                   |             Advance.\n.CTL_TXT        ANOP                        |          EndIf.\n&L              SETA &L+1                   |   Add one to length.\n&I              SETA &I+1                   |   Advance.\n                AGO  .CTL_LOOP              | End of counting loop.\n.CTL_ELOOP      ANOP                        |\n&C_LEN          SETC '=AL&(&PL_SIZELENGTH).(&L)' Set length parameter.\n                AGO  .PAST_CONTROL\n.NO_CONTROL   MNOTE 8,'CONTROL is a required keyword.'\n              MEXIT\n.PAST_CONTROL ANOP\n.*\n.* Generate the format call to the CONTROL handler.\n.*\n         ##PLIST START\n         ##PLIST PARM,&#_IDTKN\n         ##PLIST PARM,&PL_SET_FORMATTED_FOOTER\n         ##PLIST PARM,&LINE\n         ##PLIST PARM,&C_ADDR\n         ##PLIST PARM,&C_LEN\n         ##PLIST PARM,&PAGENUM\n&N       SETA  1\n.PL_LOOP ANOP\n         AIF   (&N GT N'&SOURCE).PL_LOOPEND\n         ##PLIST PARM,&SOURCE(&N)\n&N       SETA  &N+1\n         AGO   .PL_LOOP\n.PL_LOOPEND ANOP ,\n         ##PLIST END,VL\n         CALLX  &#_IDEPA\n         AIF    ('&#_IDEMC' EQ '').MEXIT\n         &#_IDEMC.\n         MEXIT\n.NO_SIZELENGTH ANOP\n         MNOTE 8,'Explicit lengths must be specified unless the SIZELEN+\n               GTH keyword has been coded on the ST_ID macro.'\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   PL_RESET_FOOTER                                            *\n* Purpose: Delete the definition for one or all footer lines.         *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         PL_RESET_FOOTER &ID=,&SPEPA=,&SPTOKEN=,&ERRMAC=,              +\n               &LINE=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN,&#_IDEMC\n         GBLA  &PL_RESET_FOOTER\n.*\n.* Obtain service processor ID values.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +\n               ID=&ID,IDMAC=PL_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN,       +\n               ERRMAC=&ERRMAC.\n         AIF  ('&#_IDCODE' EQ 'SUCCESS').VALIDATE\n         MNOTE 8,'SRV##ID unable to set global variables.'\n         MEXIT\n.VALIDATE ANOP\n.*\n.* Validate incoming parameters.\n.*\n         AIF   (T'&LINE EQ 'N').LINEOK\n         AIF   ('&LINE' NE '').LINEOK\n.LINEBAD MNOTE 8,'Line must be specified as the address of a fullword o*\n               r a numeric value.'\n         MEXIT\n.LINEOK  ANOP\n.*\n.* Generate the call to PL_RESET_FOOTER.\n.*\n.CALL    ANOP\n         CALLX &#_IDEPA,(&#_IDTKN,&PL_RESET_FOOTER,                    +\n               &LINE),VL\n         AIF    ('&#_IDEMC' EQ '').MEXIT\n         &#_IDEMC.\n         MEXIT\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   PL_RESERVE_FOOTER                                          *\n* Purpose: Reserve space at the bottom of a page for the footer.      *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         PL_RESERVE_FOOTER &ID=,&SPEPA=,&SPTOKEN=,&ERRMAC=,            *\n               &LINES=0\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN,&#_IDEMC\n         GBLA  &PL_RESERVE_FOOTER\n.*\n.* Obtain service processor ID values.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +\n               ID=&ID,IDMAC=PL_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN,       +\n               ERRMAC=&ERRMAC.\n         AIF  ('&#_IDCODE' EQ 'SUCCESS').VALIDATE\n         MNOTE 8,'SRV##ID unable to set global variables.'\n         MEXIT\n.VALIDATE ANOP\n.*\n.* Validate incoming parameters.\n.*\n.*       AIF   (T'&LINES EQ 'N').LINEOK\n.LINEOK  ANOP\n.*\n.* Generate the call to PL_RESERVE_FOOTER.\n.*\n.CALL    ANOP\n         CALLX &#_IDEPA,(&#_IDTKN,&PL_RESERVE_FOOTER,                  +\n               &LINES),VL\n         AIF    ('&#_IDEMC' EQ '').MEXIT\n         &#_IDEMC.\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   PL_PAGE_BREAK                                              *\n* Purpose: Force a page break to occur.                               *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         PL_PAGE_BREAK &ID=,&SPEPA=,&SPTOKEN=,&ERRMAC=,                *\n               &LINES=0\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN,&#_IDEMC\n         GBLA  &PL_PAGE_BREAK\n.*\n.* Obtain service processor ID values.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +\n               ID=&ID,IDMAC=PL_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN,       +\n               ERRMAC=&ERRMAC.\n         AIF  ('&#_IDCODE' EQ 'SUCCESS').CALL\n         MNOTE 8,'SRV##ID unable to set global variables.'\n         MEXIT\n.*\n.* Generate the call to PL_PAGE_BREAK.\n.*\n.CALL    ANOP\n         CALLX &#_IDEPA,(&#_IDTKN,&PL_PAGE_BREAK),VL\n         AIF    ('&#_IDEMC' EQ '').MEXIT\n         &#_IDEMC.\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   PL_PRINT                                                   *\n* Purpose: Print an unformatted data line.                            *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         PL_PRINT &ID=,&SPEPA=,&SPTOKEN=,&ERRMAC=,                     +\n               &STRING=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN,&#_IDEMC\n         GBLA  &PL_PRINT\n         LCLC  &S_ADDR,&S_LEN\n         LCLC  &V_STRING(2),&PL_SIZELENGTH\n         LCLC  &L_STRING(2)\n         LCLA  &N\n         LCLC  &KEYWORD\n.*\n.* Obtain service processor ID values.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +\n               ID=&ID,IDMAC=PL_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN,       +\n               ERRMAC=&ERRMAC\n         AIF  ('&#_IDCODE' EQ 'SUCCESS').VALIDATE\n         MNOTE 8,'SRV##ID unable to set global variables.'\n         MEXIT\n.VALIDATE ANOP\n.*\n.* Validate incoming parameters.\n.*\n&PL_SIZELENGTH SETC '#$&ID.$#SIZELENGTH'  Variable for SIZELENGTH=.\n               GBLC &(&PL_SIZELENGTH)     Declare global variable.\n.*\n.* If STRING= is missing, supply default values.\n.*\n&L_STRING(1)    SETC '&STRING(1)'\n&L_STRING(2)    SETC '&STRING(2)'\n                AIF ('&L_STRING(1)' NE '').STRING_NBLK\n&V_STRING(1)    SETC '#$&ID.$#STRING1'     Variable for STRING=.\n&V_STRING(2)    SETC '#$&ID.$#STRING2'     Variable for STRING=.\n                GBLC &(&V_STRING(1))       Declare global variable.\n                GBLC &(&V_STRING(2))       Declare global variable.\n&L_STRING(1)    SETC '&(&V_STRING(1))'     Copy default value.\n&L_STRING(2)    SETC '&(&V_STRING(2))'     Copy default value.\n.STRING_NBLK    ANOP\n.*\n.*\n.* Process the STRING keyword to get an address and length.\n.*\n&KEYWORD      SETC 'STRING'\n              AIF ('&L_STRING(1)' EQ '').NO_STRING\n              AIF ('&L_STRING(1)'(1,1) EQ '''').STR_LITERAL\n              AIF ('&L_STRING(2)' EQ '').STR_TAGONLY\n.STR_TAGLEN   ANOP\n&S_ADDR       SETC '&L_STRING(1)'         | Set addr.\n&S_LEN        SETC '&L_STRING(2)'         | Set len.\n              AGO  .PAST_STRING           |\n.STR_TAGONLY  AIF  ('&(&PL_SIZELENGTH)' EQ '').NO_SIZELENGTH\n&S_ADDR       SETC '&L_STRING(1)'         | Set addr to tag_name.\n&S_LEN        SETC '=AL&(&PL_SIZELENGTH).(L''&L_STRING(1))'\n              AGO  .PAST_STRING           |\n.STR_LITERAL  ANOP                        |\n&S_ADDR         SETC '&L_STRING(1)'         | Set addr to value.\n&L              SETA 0                      | Length counter = 0.\n&I              SETA 2                      | Index counter -> past '.\n.STR_LOOP       AIF  (&I GE K'&S_ADDR).STR_ELOOP     Loop over STRING.\n                AIF  ('&S_ADDR'(&I,1) NE '''').STR_TXT If doubled.\n&I              SETA &I+1                   |             Advance.\n.STR_TXT        ANOP                        |          EndIf.\n&L              SETA &L+1                   |   Add one to length.\n&I              SETA &I+1                   |   Advance.\n                AGO  .STR_LOOP              | End of counting loop.\n.STR_ELOOP      ANOP                        |\n&S_LEN          SETC '=AL&(&PL_SIZELENGTH).(&L)' Set length parameter.\n                AGO  .PAST_STRING\n.NO_STRING    MNOTE 8,'STRING is a required keyword.'\n              MEXIT\n.PAST_STRING  ANOP\n.*\n.* Generate the call to PL_PRINT.\n.*\n.CALL    ANOP\n         CALLX &#_IDEPA,(&#_IDTKN,&PL_PRINT,                           +\n               &S_ADDR,&S_LEN),VL\n         AIF    ('&#_IDEMC' EQ '').MEXIT\n         &#_IDEMC.\n         MEXIT\n.NO_SIZELENGTH ANOP\n         MNOTE 8,'Explicit lengths must be specified unless the SIZELEN+\n               GTH keyword has been coded on the ST_ID macro.'\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   PL_PRINT_FORMATTED                                         *\n* Purpose: Format and print a data line.                              *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         PL_PRINT_FORMATTED &ID=,&SPEPA=,&SPTOKEN=,&ERRMAC=,           *\n               &CONTROL=,                                              *\n               &SOURCE=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN,&#_IDEMC\n         GBLA  &PL_PRINT_FORMATTED\n         LCLC  &C_ADDR,&C_LEN\n         LCLC  &V_CONTROL(2),&PL_SIZELENGTH\n         LCLC  &L_CONTROL(2)\n         LCLA  &N\n         LCLC  &KEYWORD\n.*\n.* Obtain service processor ID values.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +\n               ID=&ID,IDMAC=PL_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN,       +\n               ERRMAC=&ERRMAC.\n         AIF  ('&#_IDCODE' EQ 'SUCCESS').VALIDATE\n         MNOTE 8,'SRV##ID unable to set global variables.'\n         MEXIT\n.VALIDATE ANOP\n.*\n.*\n.* Validate incoming parameters.\n.*\n.*\n&PL_SIZELENGTH SETC '#$&ID.$#SIZELENGTH'  Variable for SIZELENGTH=.\n               GBLC &(&PL_SIZELENGTH)     Declare global variable.\n.*\n.* If CONTROL= is missing, supply default values.\n.*\n&L_CONTROL(1)   SETC '&CONTROL(1)'\n&L_CONTROL(2)   SETC '&CONTROL(2)'\n                AIF ('&L_CONTROL(1)' NE '').CONTROL_NBLK\n&V_CONTROL(1)   SETC '#$&ID.$#CONTROL1'    Variable for CONTROL=.\n&V_CONTROL(2)   SETC '#$&ID.$#CONTROL2'    Variable for CONTROL=.\n                GBLC &(&V_CONTROL(1))      Declare global variable.\n                GBLC &(&V_CONTROL(2))      Declare global variable.\n&L_CONTROL(1)   SETC '&(&V_CONTROL(1))'    Copy default value.\n&L_CONTROL(2)   SETC '&(&V_CONTROL(2))'    Copy default value.\n.CONTROL_NBLK   ANOP\n.*\n.*\n.* Process the CONTROL keyword to get an address and length.\n.*\n&KEYWORD      SETC 'CONTROL'\n              AIF ('&L_CONTROL(1)' EQ '').NO_CONTROL\n              AIF ('&L_CONTROL(1)'(1,1) EQ '''').CTL_LITERAL\n              AIF ('&L_CONTROL(2)' EQ '').CTL_TAGONLY\n.CTL_TAGLEN   ANOP\n&C_ADDR       SETC '&L_CONTROL(1)'        | Set addr.\n&C_LEN        SETC '&L_CONTROL(2)'        | Set len.\n              AGO  .PAST_CONTROL          |\n.CTL_TAGONLY  AIF  ('&(&PL_SIZELENGTH)' EQ '').NO_SIZELENGTH\n&C_ADDR       SETC '&L_CONTROL(1)'        | Set addr to tag_name.\n&C_LEN        SETC '=AL&(&PL_SIZELENGTH).(L''&L_CONTROL(1))'\n              AGO  .PAST_CONTROL          |\n.CTL_LITERAL  ANOP                        |\n&C_ADDR         SETC '&L_CONTROL(1)'        | Set addr to value.\n&L              SETA 0                      | Length counter = 0.\n&I              SETA 2                      | Index counter -> past '.\n.CTL_LOOP       AIF  (&I GE K'&C_ADDR).CTL_ELOOP     Loop over CONTROL.\n                AIF  ('&C_ADDR'(&I,1) NE '''').CTL_TXT If doubled.\n&I              SETA &I+1                   |             Advance.\n.CTL_TXT        ANOP                        |          EndIf.\n&L              SETA &L+1                   |   Add one to length.\n&I              SETA &I+1                   |   Advance.\n                AGO  .CTL_LOOP              | End of counting loop.\n.CTL_ELOOP      ANOP                        |\n&C_LEN          SETC '=AL&(&PL_SIZELENGTH).(&L)' Set length parameter.\n                AGO  .PAST_CONTROL\n.NO_CONTROL   MNOTE 8,'CONTROL is a required keyword.'\n              MEXIT\n.PAST_CONTROL ANOP\n.*\n.* Generate the format call to the CONTROL handler.\n.*\n         ##PLIST START\n         ##PLIST PARM,&#_IDTKN\n         ##PLIST PARM,&PL_PRINT_FORMATTED\n         ##PLIST PARM,&C_ADDR\n         ##PLIST PARM,&C_LEN\n&N       SETA  1\n.PL_LOOP ANOP\n         AIF   (&N GT N'&SOURCE).PL_LOOPEND\n         ##PLIST PARM,&SOURCE(&N)\n&N       SETA  &N+1\n         AGO   .PL_LOOP\n.PL_LOOPEND ANOP ,\n         ##PLIST END,VL\n         CALLX  &#_IDEPA\n         AIF    ('&#_IDEMC' EQ '').MEXIT\n         &#_IDEMC.\n         MEXIT\n.NO_SIZELENGTH ANOP\n         MNOTE 8,'Explicit lengths must be specified unless the SIZELEN+\n               GTH keyword has been coded on the ST_ID macro.'\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   PL_QUERY_LINES_LEFT                                        *\n* Purpose: Return # lines remaining on current page to caller.        *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         PL_QUERY_LINES_LEFT &ID=,&SPEPA=,&SPTOKEN=,&ERRMAC=,          *\n               &LINES=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN,&#_IDEMC\n         GBLA  &PL_QUERY_LINES_LEFT\n.*\n.* Obtain service processor ID values.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +\n               ID=&ID,IDMAC=PL_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN,       +\n               ERRMAC=&ERRMAC\n         AIF  ('&#_IDCODE' EQ 'SUCCESS').VALIDATE\n         MNOTE 8,'SRV##ID unable to set global variables.'\n         MEXIT\n.VALIDATE ANOP\n.*\n.* Validate incoming parameters.\n.*\n         AIF   ('&LINES' EQ '').LINESERR\n         AIF   ('&LINES'(1,1) NE '''').LINESOK\n.LINESERR MNOTE 8,'LINES is a required parameter, and must be specified*\n                as an address.'\n         MEXIT\n.LINESOK ANOP\n.*\n.* Generate the call to PL_QUERY_LINES_LEFT.\n.*\n.CALL    ANOP\n         CALLX &#_IDEPA,(&#_IDTKN,&PL_QUERY_LINES_LEFT,                +\n               &LINES),VL\n         AIF    ('&#_IDEMC' EQ '').MEXIT\n         &#_IDEMC.\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   PL_GET_INFO                                                *\n* Purpose: Get information about a print line session.                *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         PL_GET_INFO &ID=,&SPEPA=,&SPTOKEN=,&ERRMAC=,                  +\n               &LRECL=,&RECFM=,                                        +\n               &FIMSG=,&FIMSGLEN=,&FIRC=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN,&#_IDEMC\n         GBLA  &PL_GET_INFO\n         GBLA  &PL_GI_LRECL\n         GBLA  &PL_GI_RECFM\n         GBLA  &PL_GI_FIMSG\n         GBLA  &PL_GI_FIRC\n         LCLC  &L_ADDR,&L_LEN\n.*\n.* Obtain service processor ID values.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +\n               ID=&ID,IDMAC=PL_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN,       +\n               ERRMAC=&ERRMAC\n         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT\n.*\n.*       Generate parameter list prelude code.\n.*\n         ##PLIST START\n         ##PLIST PARM,&#_IDTKN,&PL_GET_INFO\n.*\n.* If FIMSG= was specified, generate code to get FIMSG information.\n.*\n              AIF ('&FIMSG' EQ '').NO_FIMSG\n              AIF (N'&FIMSG EQ 1).FIMSG_TAGONLY\n              AIF (N'&FIMSG EQ 2).FIMSG_TAGLEN\n              MNOTE 8,'Too many subparameters for FIMSG keyword.'\n              MEXIT\n.FIMSG_TAGLEN ANOP\n&L_ADDR       SETC '&FIMSG(1)'            | Set addr.\n&L_LEN        SETC '&FIMSG(2)'            | Set len.\n              AGO  .PAST_FIMSG            |\n.FIMSG_TAGONLY ANOP\n&L_ADDR       SETC '&FIMSG'               | Set addr to tag_FIMSG.\n&L_LEN        SETC '=A(L''&FIMSG)'        | Set len to L'tag_FIMSG.\n.PAST_FIMSG   AIF  ('&FIMSGLEN' NE '').CALL_FIMSG\n    MNOTE 8,'FIMSGLEN must be specified if FIMSG is specified.'\n              MEXIT\n.CALL_FIMSG   ##PLIST PARM,&PL_GI_FIMSG,&L_ADDR,&L_LEN,&FIMSGLEN\n.NO_FIMSG     ANOP\n.*\n.* If FIRC= was specified, generate code to get FIRC information.\n.*\n              AIF ('&FIRC' EQ '').NO_FIRC\n.CALL_FIRC    ##PLIST PARM,&PL_GI_FIRC,&FIRC\n.NO_FIRC      ANOP\n.*\n.* If LRECL= was specified, generate code to get it.\n.*\n              AIF ('&LRECL' EQ '').NO_LRECL\n.CALL_LRECL   ##PLIST PARM,&PL_GI_LRECL,&LRECL\n.NO_LRECL     ANOP\n.*\n.* If RECFM= was specified, generate code to get it.\n.*\n              AIF ('&RECFM' EQ '').NO_RECFM\n.CALL_RECFM   ##PLIST PARM,&PL_GI_RECFM,&RECFM\n.NO_RECFM     ANOP\n.*\n.* Complete the parameter list and generate the call.\n.*\n               ##PLIST END,VL\n               CALLX   &#_IDEPA\n               AIF   ('&#_IDEMC' EQ '').NO_EMC\n               &#_IDEMC.\n.NO_EMC        ANOP\n.MEXIT         MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   PL_GET_REFERENCE                                           *\n* Purpose: Get reference string from file handler session.            *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         PL_GET_REFERENCE &ID=,&SPEPA=,&SPTOKEN=,&ERRMAC=,             +\n               &REFERENCE=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN,&#_IDEMC\n         GBLA  &PL_GET_REFERENCE\n.*\n.* Obtain service processor ID values.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +\n               ID=&ID,IDMAC=PL_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN,       +\n               ERRMAC=&ERRMAC\n         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT\n         AIF  ('&REFERENCE' EQ '').NO_REF\n         CALLX   &#_IDEPA,(&#_IDTKN,&PL_GET_REFERENCE,&REFERENCE),VL\n              MEXIT\n.NO_REF       MNOTE 8,'REFERENCE is a required keyword.'\n.MEXIT         MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   PL_PARMLIST                                                *\n* Purpose: Generate mapping fields for the parameters accepted by the *\n*          PrintLine service processor.                               *\n*                                                                     *\n*---------------------------------------------------------------------*\n                  MACRO\n&LABEL            PL_PARMLIST &DSECT=YES\n                  LCLC  &NAME\n&NAME             SETC  'PL_PARMLIST'\n                  AIF   ('&LABEL' EQ '').PAST_LABEL\n&NAME             SETC  '&LABEL'\n.PAST_LABEL       ANOP\n                  AIF   ('&DSECT' EQ 'YES').GEN_DSECT\n&NAME             DS    0F         | Parameter List:\n                  AGO .GEN_FIELDS\n.GEN_DSECT        ANOP\n&NAME             DSECT            | Parameter List:\n.GEN_FIELDS       ANOP ,           |\nPL_PL_ID                      DS A    | Div identifier === PWA base\nPL_FUNCTIONCODE               DS A    | Function to be performed\nPL_MIN_#                      EQU (*-&NAME)/4\nPL_FUNCTION_DEPT              EQU *   | Function-dependent parameters\n*---------------------------------------------------------------------*\n* Start function\n*---------------------------------------------------------------------*\n                  ORG PL_FUNCTION_DEPT\nPL_START_ESV                  DS A    | Environment Support Vector.\nPL_START_DDNAME               DS A    | DDName.\nPL_START_MIN_#                EQU (*-&NAME)/4\nPL_START_PAGESIZE             DS A    | Mode of access (U or R)\nPL_START_PAGESIZE_#           EQU (*-&NAME)/4\nPL_START_MAXLINESIZE          DS A    | Size return area.\nPL_START_MAXLINESIZE_#        EQU (*-&NAME)/4\nPL_START_SIZELENGTH           DS A    | Size return area.\nPL_START_SIZELENGTH_#         EQU (*-&NAME)/4\nPL_START_OPTIONS              DS A    | Options area.\nPL_START_OPTIONS_#            EQU (*-&NAME)/4\nPL_START_REFERENCE            DS A    | Options area.\nPL_START_REFERENCE_#          EQU (*-&NAME)/4\nPL_START_MAX_#                EQU (*-&NAME)/4\n*---------------------------------------------------------------------*\n* Terminate function\n*---------------------------------------------------------------------*\n                  ORG PL_FUNCTION_DEPT\nPL_TERMINATE_#                EQU (*-&NAME)/4\n*---------------------------------------------------------------------*\n* Set_Header function\n*---------------------------------------------------------------------*\n                  ORG PL_FUNCTION_DEPT\nPL_SETHDR_LINENBR             DS A    | Line number.\nPL_SETHDR_STRING              DS A    | Unformatted string.\nPL_SETHDR_STRINGLEN           DS A    | Length of string.\nPL_SETHDR_MIN_#               EQU (*-&NAME)/4\nPL_SETHDR_MAX_#               EQU (*-&NAME)/4\n*---------------------------------------------------------------------*\n* Set_Formatted_Header function.\n*---------------------------------------------------------------------*\n                  ORG PL_FUNCTION_DEPT\nPL_SETFMTHDR_LINENBR          DS A    | Line number.\nPL_SETFMTHDR_FMTSTRING        DS A    | Format string.\nPL_SETFMTHDR_FMTSTRING_LEN    DS A    | Format string length.\nPL_SETFMTHDR_MIN_#            EQU (*-&NAME)/4\nPL_SETFMTHDR_PAGEDISP         DS A    | Page number disp or zero.\nPL_SETFMTHDR_PAGEDISP_#       EQU (*-&NAME)/4\nPL_SETFMTHDR_SOURCELIST       DS 50A  | Source addresses for formatter.\nPL_SETFMTHDR_MAX_#            EQU (*-&NAME)/4\n*---------------------------------------------------------------------*\n* Reset_Header function\n*---------------------------------------------------------------------*\n                  ORG PL_FUNCTION_DEPT\nPL_RESETHDR_LINENBR           DS A    | Line # to reset, 0 for all.\nPL_RESETHDR_MIN_#             EQU (*-&NAME)/4\nPL_RESETHDR_MAX_#             EQU (*-&NAME)/4\n*---------------------------------------------------------------------*\n* Set_Footer function\n*---------------------------------------------------------------------*\n                  ORG PL_FUNCTION_DEPT\nPL_SETFTR_LINENBR             DS A    | Line number.\nPL_SETFTR_STRING              DS A    | Unformatted string.\nPL_SETFTR_STRINGLEN           DS A    | Length of string.\nPL_SETFTR_MIN_#               EQU (*-&NAME)/4\nPL_SETFTR_MAX_#               EQU (*-&NAME)/4\n*---------------------------------------------------------------------*\n* Set_Formatted_Footer function.\n*---------------------------------------------------------------------*\n                  ORG PL_FUNCTION_DEPT\nPL_SETFMTFTR_LINENBR          DS A    | Line number.\nPL_SETFMTFTR_FMTSTRING        DS A    | Format string.\nPL_SETFMTFTR_FMTSTRING_LEN    DS A    | Format string length.\nPL_SETFMTFTR_MIN_#            EQU (*-&NAME)/4\nPL_SETFMTFTR_PAGEDISP         DS A    | Page number disp or zero.\nPL_SETFMTFTR_PAGEDISP_#       EQU (*-&NAME)/4\nPL_SETFMTFTR_SOURCELIST       DS 50A  | Format substitution values.\nPL_SETFMTFTR_MAX_#            EQU (*-&NAME)/4\n*---------------------------------------------------------------------*\n* Reset_Footer function\n*---------------------------------------------------------------------*\n                  ORG PL_FUNCTION_DEPT\nPL_RESETFTR_LINENBR           DS A    | Line # to reset, 0 for all.\nPL_RESETFTR_MIN_#             EQU (*-&NAME)/4\nPL_RESETFTR_MAX_#             EQU (*-&NAME)/4\n*---------------------------------------------------------------------*\n* Reserve_Footer function\n*---------------------------------------------------------------------*\n                  ORG PL_FUNCTION_DEPT\nPL_RSVFTR_LINES               DS A    | Lines to reserve\nPL_RSVFTR_MIN_#               EQU (*-&NAME)/4\nPL_RSVFTR_MAX_#               EQU (*-&NAME)/4\n*---------------------------------------------------------------------*\n* Page_Break function  (no function-specific parameters)\n*---------------------------------------------------------------------*\n                  ORG PL_FUNCTION_DEPT\nPL_PAGEBREAK_MIN_#            EQU (*-&NAME)/4\nPL_PAGEBREAK_MAX_#            EQU (*-&NAME)/4\n*---------------------------------------------------------------------*\n* Print function\n*---------------------------------------------------------------------*\n                  ORG PL_FUNCTION_DEPT\nPL_PRINT_STRING               DS A    | Unformatted string to print\nPL_PRINT_STRINGLEN            DS A    | Length of string\nPL_PRINT_MIN_#                EQU (*-&NAME)/4\nPL_PRINT_MAX_#                EQU (*-&NAME)/4\n*---------------------------------------------------------------------*\n* Print_Formatted function.\n*---------------------------------------------------------------------*\n                  ORG PL_FUNCTION_DEPT\nPL_PRINTFMT_FMTSTRING         DS A    | Format string.\nPL_PRINTFMT_FMTSTRING_LEN     DS A    | Format string length.\nPL_PRINTFMT_MIN_#             EQU (*-&NAME)/4\nPL_PRINTFMT_SOURCELIST        DS 50A  | Retain (\"Y\" or \"N\")\nPL_PRINTFMT_MAX_#             EQU (*-&NAME)/4\n*---------------------------------------------------------------------*\n* Query_Lines_Left function\n*---------------------------------------------------------------------*\n                  ORG PL_FUNCTION_DEPT\nPL_QLINES_LINES               DS A    | Line # to reset, 0 for all.\nPL_QLINES_MIN_#               EQU (*-&NAME)/4\nPL_QLINES_MAX_#               EQU (*-&NAME)/4\n*---------------------------------------------------------------------*\n* Get_Info; multiple information sub-codes can be provided, each with\n* a required return area and some with required area_size and length.\n*---------------------------------------------------------------------*\n                  ORG PL_FUNCTION_DEPT\nPL_GI_FUNCTION    DS  A            |     Information sub-code.\nPL_GI_MIN_#       EQU (*-&NAME)/4  |\nPL_GI_AREA        DS  A            |     Area to return information.\nPL_GI_AREA_SIZE   DS  A            |     Length of return area.\nPL_GI_LENGTH      DS  A            |     Length of returned info.\n*---------------------------------------------------------------------*\n* Get_Info; multiple information sub-codes can be provided, each with\n* a required return area and some with required area_size and length.\n*---------------------------------------------------------------------*\n                  ORG PL_FUNCTION_DEPT\nPL_GR_REFERENCE   DS  A            |     PL_START Reference string.\nPL_GR_MIN_#       EQU (*-&NAME)/4  |\nPL_GR_MAX_#       EQU (*-&NAME)/4  |\n                  ORG ,            |\nPL_MAX_#                      EQU (*-&NAME)/4\n                  ORG ,            | Adjust to final parmlist offset.\n&NAME._L          EQU *-&NAME.     | Length of File Handler Parmlist.\n                  MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SRVPLMVS": {"ttr": 33283, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x02\\x00\\x00X\\x01\\x11)\\x9f\\x01\\x11)\\x9f\\t'\\x07\\x96\\x07\\x96\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@\"", "ispf": {"version": "02.00", "flags": 0, "createdate": "2011-10-26T00:00:00", "modifydate": "2011-10-26T09:27:58", "lines": 1942, "newlines": 1942, "modlines": 0, "user": "CLEMSON"}, "text": "*---------------------------------------------------------------------*\n*  Copyright 2011 by Clemson University Research Foundation           *\n*                                                                     *\n*  Licensed under the Apache License, Version 2.0 (the \"License\");    *\n*  you may not use this file except in compliance with the License.   *\n*  You may obtain a copy of the License in this library as member     *\n*  $LICENSE, or from                                                  *\n*                                                                     *\n*      http://www.apache.org/licenses/LICENSE-2.0                     *\n*                                                                     *\n*  Unless required by applicable law or agreed to in writing,         *\n*  software distributed under the License is distributed on an \"AS    *\n*  IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either    *\n*  express or implied.  See the License for the specific language     *\n*  governing permissions and limitations under the License.           *\n*---------------------------------------------------------------------*\nSRVPLMVS TITLE 'MVS Print_Line Service Processor'\n         SMLIST CONVERT=YES           |\n         srvmod name=srvplmvs,dates='1989, 1990, 1995'\n         gblc  &srv_modname\n*---------------------------------------------------------------------*\n*\n*  Copyright (C) Clemson University Research Foundation 1989, 1990.\n*\n*  Program     SRVPLMVS, MVS Print_Line Service Processor.\n*\n*  Abstract    This service processor is MVS dependent and relieves the\n*              caller of many chores associated with report writing.\n*\n*  Parameters:\n*\n*    PL_Start\n*      CALLX SRVPLMVS,(pl_ID,&PL_Start,ESV,DDName,PageSize,MaxLineSize,\n*                      SizeLength,Reference)\n*\n*    PL_Terminate\n*      CALLX SRVPLMVS,(pl_ID,&PL_Terminate)\n*\n*    PL_Set_Header\n*      CALLX SRVPLMVS,(pl_ID,&PL_Set_Header,LineNbr,String,StringLen)\n*\n*    PL_Set_Formatted_Header\n*      CALLX SRVPLMVS,(pl_ID,&PL_Set_Formatted_Header,\n*                      LineNbr,FormatString,FormatStringLen,PageDisp,\n*                      Source(1),...,Source(50))\n*\n*    PL_Reset_Header\n*      CALLX SRVPLMVS,(pl_ID,&PL_Reset_Header,LineNbr)\n*\n*    PL_Set_Footer\n*      CALLX SRVPLMVS,(pl_ID,&PL_Set_Footer,LineNbr,String,StringLen)\n*\n*    PL_Set_Formatted_Footer\n*      CALLX SRVPLMVS,(pl_ID,&PL_Set_Formatted_Footer,\n*                      FormatString,FormatStringLen,PageDisp,\n*                      Source(1),...,Source(50))\n*\n*    PL_Reset_Footer\n*      CALLX SRVPLMVS,(pl_ID,&PL_Reset_Footer,LineNbr)\n*\n*    PL_Reserve_Footer\n*      CALLX SRVPLMVS,(pl_ID,&PL_Reserve_Footer,Lines)\n*\n*    PL_Page_Break\n*      CALLX SRVPLMVS,(pl_ID,&PL_Page_Break)\n*\n*    PL_Print\n*      CALLX SRVPLMVS,(pl_ID,&PL_Print,String,StringLen)\n*\n*    PL_Formatted_Print\n*      CALLX SRVPLMVS,(pl_ID,&PL_Formatted_Print,\n*                      FormatString,FormatStringLen,\n*                      Source(1),...,Source(50))\n*\n*    The meaning of each parameter is explained below.\n*\n*    pl_ID is a fullword used to uniquely identify the invocation of\n*      the Print_Line service processor.  It is initialized during the\n*      startup function.\n*\n*    FunctionCode is a fullword integer that specifies the function to\n*      be performed.  Symbolic identifiers are provided for each\n*      function and may be accessed by placing a COPY statement for\n*      SRVPLMAC in the assembler program.  These symbols should be\n*      used in place of actual integer values.  The following\n*      FunctionCodes are supported:\n*\n*      &PL_Start = 1\n*        Identify the ddname that points to the report file, set the\n*        maximum page and line lengths.\n*\n*      &PL_Terminate = 2\n*        Shutdown this invocation.  This function causes any incomplete\n*        pages to be completed and closes the report file.\n*\n*      &PL_Set_Header              =  3\n*        Define a header line.  The LineNum parameter determines the\n*        position of the header line in the header.  Respecifying a\n*        LineNum parameter causes that header line to be replaced.\n*\n*      &PL_Set_Formatted_Header    =  4\n*        Define a header line to be formatted using the String Format-\n*        ter.\n*\n*      &PL_Reset_Header            =  5\n*        Causes one or all header line definitions to be deleted.\n*\n*      &PL_Set_Footer              =  6\n*        Define a footing line.  The LineNum parameter determines the\n*        position of the footing line in the footer.  Respecifying a\n*        LineNum parameter causes that footer line to be replaced.\n*\n*      &PL_Set_Formatted_Footer    =  7\n*        Define a footing line to be formatted using the String Format-\n*        ter.\n*\n*      &PL_Reset_Footer            =  8\n*        Causes one or all footing line definitions to be deleted.\n*\n*      &PL_Reserve_Footer          =  9\n*        Causes a number of lines to be 'reserved' at the bottom of\n*        a logical page for the footing.  The number specified is used\n*        to determine when end-of-logical-page occurs.\n*\n*      &PL_Page_Break              =  10\n*        Forces a page break, causing the current page to be printed\n*        with footing.  If printing continues, the next data line will\n*        cause the headers to come out.\n*\n*      &PL_Print                   =  11\n*        Prints a data line as-is.\n*\n*      &PL_Formatted_Print         =  12\n*        Formats and prints a data line based on the user's format\n*        specifications.\n*\n*      &PL_Get_Info  =  14\n*        Return requested information.\n*\n*      &PL_Get_Reference =  15\n*        Return reference string.\n*\n*    ESV is a fullword given to the application by the Server Manager\n*      when it was started up.\n*\n*    DDName specified the DDName of the report file.  This file will\n*      be a RECFM=VBA file.  Its blocksize will default to (LRECL+4),\n*      unless overridden by JCL.\n*\n*\n*  Return codes:\n*\n*   &PL_Invalid_Function\n*      An invalid function was specified.\n*   &PL_Invalid_Number_Of_Parms\n*      An invalid number of parameters for a specific function was\n*      specified.\n*   &PL_Invalid_PL_ID\n*      The service processor token does not point to the correct data.\n*   &PL_Environment_Support_Error\n*      The Environment Support service processor returned an error.\n*   &PL_Memory_Manager_Error\n*      The Memory Manager service processor returned an error.\n*   &PL_String_Handler_Error\n*      The String Handler service processor returned an error.\n*   &PL_Cannot_Open_DCB\n*      A DCB for the DDname provided could not be opened.\n*   &PL_Invalid_PageDisp\n*      A page displacement value exceeds the number of source parms\n*      in a formatted header or footer definition.\n*   &PL_Header_Not_Found\n*      The line number specified on a reset_header call wasn't found.\n*   &PL_Footer_Not_Found\n*      The line number specified on a reset_footer call wasn't found.\n*   &PL_Print_Line_Truncated\n*      The length of the caller-provided string or the formatted string\n*      exceeded the maximum line length.  The truncated line is printed\n*      before control is returned to the caller.\n*\n*  Program     Reentrant, problem key and state, server linkage,\n*  Attributes  non-authorized, AMODE(31), RMODE(ANY)\n*\n*  Change\n*  History   2011/10/20 JCB - Patch rollup for CBT tape distribution\n*\n*  Method of\n*  Operation   Refer to the code\n*\n*\n*  Special Notes:\n*\n*---------------------------------------------------------------------*\n space 1                              |\n print off                            |\n copy  smsyms                         | Structured Macros symbols.\n copy  srvesmac                       | Environment support symbols.\n copy  srvmmmac                       | Memory Manager symbols.\n copy  srvstmac                       | String Formatter symbols.\n copy  srvplmac                       | Print Line symbols.\n copy  srvfimac                       | File handler symbols.\n print on,gen                         |\n eject                                |\n**--------------------------------------------------------------------*\n**\n**  Identify the service processors that Print Line will use.\n**\n**--------------------------------------------------------------------*\n       space 1                        |\n es_id         id=ES,                 |                                *\n               spepa=pwa_ES_epa,      |                                *\n               sptoken=pwa_ES_token,  |                                *\n               esva=pwa_esv           |\n       space 1                        |\n mm_id         id=MM,                 |                                *\n               spepname=&Memory_Manager,                               *\n               spepa=pwa_MM_epa,      |                                *\n               sptoken=pwa_MM_token,  |                                *\n               esid=ES                |\n       space 1                        |\n st_id         id=ST,                 |                                *\n               spepname=&String_Handler,                               *\n               spepa=pwa_ST_epa,      |                                *\n               sptoken=pwa_ST_token,  |                                *\n               esid=ES                |\n       space 1                        |\n fi_id         id=FI,                 |                                *\n               spepname=&FI_OS_File_Handler,                           *\n               spepa=pwa_FI_epa,      |                                *\n               sptoken=pwa_FI_token,  |                                *\n               esid=ES                |\n       space 1                        |\n eject                                |\n block name=&srv_modname,type=program,amode=31,rmode=any,              +\n               options=(*srvprc,long,dyn,main,(parms,(using,r9))),     +\n               parmmap=pl_parmlist,                                    +\n               subopts=(*swa,loadbase)\n* *-------------------------------------------------------------------*\n* * Determine how many parameters were passed and load r1 with\n* * function code.\n* *-------------------------------------------------------------------*\n  la    r1,pl_parmlist                | Point r1 to parameter list.\n  la    r15,pl_max_#                  | Load r15 with maximum # parms.\n  loop bct                            | Loop\n   leave loop=*,(tbit,0(r1),x'80')    |  End of parms if high bit set.\n   la   r1,4(,r1)                     |  Point to next parm address.\n  endloop bct,r15                     | Endloop\n  la    r0,pl_max_#+1                 | Calculate number of\n  sr    r0,r15                        |  parms.  Ok if 2 <= num <= max\n  sth   r0,pwa_number_of_parms        | Save number of parms.\n  errexit (ch,r0,lt,=y(pl_min_#)),or,(ch,r0,gt,=y(pl_max_#)),          +\n               code=&pl_invalid_number_of_parms\n  l     r1,pl_functioncode            | Load the function code into\n  l     r1,0(,r1)                     |   a register for testing.\n* *-------------------------------------------------------------------*\n* * If the function code is something other than start, make sure that\n* * the PWA contains the eye-catcher string and the correct value for\n* * pl_ID.   If not, then the pl_ID passed in is garbage.\n* *-------------------------------------------------------------------*\n  if (c,r1,ne,=f'&pl_start')          | If not startup function then\n   errexit ((clc,pwa_visual,ne,eyecatcher),or,(c,r13,ne,pwa_pl_id)),   +\n               code=&pl_invalid_pl_id |  go off and croak.\n  endif                               | Endif.\n  space 1                             |\n  mvi   pwatf,x'00'                   | Clear 'truncation' flag\n  rbit  pwaf1wrap                     | Clear 'wrapping' flag       @C2\n  eject ,                             |\n* *-------------------------------------------------------------------*\n* * Select the code to process the function.\n* *-------------------------------------------------------------------*\n  caseblk reg=r1                      | Start of function case block.\n  eject                               |\n*  *------------------------------------------------------------------*\n*  *\n*  * Start function.\n*  *\n*  *------------------------------------------------------------------*\n   case &pl_start                     |  Start function.            @C2\n    callsub  start                    |                             @C2\n   case &pl_terminate                 |                             @C2\n    callsub  terminate                |                             @C2\n   case &pl_set_header                |                             @C2\n    callsub  set_header               |                             @C2\n   case &pl_set_formatted_header      |                             @C2\n    callsub  set_formatted_header     |                             @C2\n   case &pl_reset_header              |                             @C2\n    callsub  reset_header             |                             @C2\n   case &pl_set_footer                |                             @C2\n    callsub  set_footer               |                             @C2\n   case &pl_set_formatted_footer      |                             @C2\n    callsub  set_formatted_footer     |                             @C2\n   case &pl_reset_footer              |                             @C2\n    callsub  reset_footer             |                             @C2\n   case &pl_reserve_footer            |                             @C2\n    callsub  reserve_footer           |                             @C2\n   case &pl_page_break                |                             @C2\n    callsub  page_break               |                             @C2\n   case &pl_print                     |                             @C2\n    callsub  print                    |                             @C2\n   case &pl_print_formatted           |                             @C2\n    callsub  print_formatted          |                             @C2\n   case &pl_query_lines_left          |                             @C2\n    callsub  query_lines_left         |                             @C2\n   case &pl_get_info                  |                             @C2\n    callsub  get_info                 |                             @C2\n   case &pl_get_reference             |                             @C2\n    callsub  get_reference            |                             @C2\n   case other                         | Unknown functioncode?\n    errexit code=&pl_invalid_function |  Return error to caller.\n  endcase                             |\n space 1                              |\n* *-------------------------------------------------------------------*\n* *  When exiting, see if we truncated a print line: if so, return a\n* *  \"truncated\" return code, else set returncode zero.\n* *-------------------------------------------------------------------*\n errexit       (tbit,pwatfhdr),       |                                *\n               code=&pl_header_line_truncated\n errexit       (tbit,pwatfftr),       |                                *\n               code=&pl_footer_line_truncated\n errexit       (tbit,pwatflin),       |                                *\n               code=&pl_print_line_truncated\n errexit       (tbit,pwaf1wrap),      |  indicate that lines will   @C2*\n               code=&pl_line_wrapping |   be wrapped if we continue @C2\n xr    r15,r15                        |  end normally w/RC zero.\n space 1                              |\n endblk block=&srv_modname,rc=(r15)   |\n eject                                |\n*---------------------------------------------------------------------*\n*\n*  Subroutine: start\n*\n*---------------------------------------------------------------------*\n block name=start,type=subroutine     |\n* *-------------------------------------------------------------------*\n* * Set the eyecatcher and the PL_ID fields.   These are checked\n* * each time the PL server is entered to avoid integrity\n* * problems.\n* *-------------------------------------------------------------------*\n  mvc   pwa_visual,eyecatcher         |   Both the eyecatcher and the\n  st    r13,pwa_pl_id                 |   PL_ID are for validity checks\n  xc    pwa_clear_start(pwa_clear_length),pwa_clear_start\n  mvc   pwa_line_count,psd_force_eject  Force pagebreak\n* *-------------------------------------------------------------------*\n* * Make sure that a valid number of parameters are specified.\n* *-------------------------------------------------------------------*\n  lh    r3,pwa_number_of_parms        |   Load r3 with number of parms.\n  errexit    (ch,r3,lt,=y(pl_start_min_#)),or,    Error if out         +\n               (ch,r3,gt,=y(pl_start_max_#)),       of bounds.         +\n               code=&pl_invalid_number_of_parms\n* *-------------------------------------------------------------------*\n* * Get ddname.\n* *-------------------------------------------------------------------*\n  l     r1,pl_start_ddname            |   Move ddname\n  mvc   pwa_ddname,0(r1)              |   to PWA.\n* *-------------------------------------------------------------------*\n* * Determine if REFERENCE string was specified.\n* *-------------------------------------------------------------------*\n* lh    r3,pwa_number_of_parms\n* if    (ch,r3,ge,=y(pl_start_reference_#))\n*  l     r1,pl_start_reference        | Move reference string\n*  mvc    pwa_pl_reference,0(r1)      | to pwa.\n* else\n*  fill   pwa_pl_reference,x'40'      | Fill with blanks.\n*  mvc    pwa_pl_ref_part1,=c'DDNAME '\n*  mvc    pwa_pl_ref_part2,pwa_ddname\n* endif                               |\n* *-------------------------------------------------------------------*\n* * Copy optional parameters if they're present; else set defaults.\n* *-------------------------------------------------------------------*\n  la    r1,&pl_default_pagesize       |   Set default pagesize\n  if    (ch,r3,ge,=al2(pl_start_pagesize_#))   If PageSize is there\n   l     r2,pl_start_pagesize         |     Get it\n   l32   r2,0(r2)                     |\n   if    nz                           |     If it's nonzero,\n    lr    r1,r2                       |      we'll use that.\n   endif                              |\n  endif                               |\n  st    r1,pwa_pagesize               |\n       space 1                        |\n  la    r1,&pl_default_sizelength     |   Set default sizelength\n  if    (ch,r3,ge,=al2(pl_start_sizelength_#)) If sizelength there\n   l     r2,pl_start_sizelength       |     Get it\n   la    r2,0(r2)                     |     Strip any x'80' VL bit\n   if    (treg,r2,nz)                 |     If address present\n    l32   r2,0(r2)                    |      Get the value\n    errexit (ch,r2,gt,=h'4'),         |      More than 4? Trash!       *\n               code=&pl_invalid_sizelength\n    if    nz                          |     If it's nonzero,\n     lr    r1,r2                      |      we'll use what they said.\n    endif                             |\n   endif                              |\n  endif                               |\n  st    r1,pwa_sizelength             | Whatever we decided = sizelen.\n  bctr  r1,0                          |  r1 := offset into bit-masks\n  la    r1,psd_bit_mask(r1)           |  r1 -> bit-mask for icm/stcm's.\n  l8    r0,0(r1)                      |  r0 := bit-mask for icm/stcm's.\n  st    r0,pwa_size_mask              |  save for dealing w/ lengths.\n       space 1                        |\n  la    r1,&pl_default_maxlinesize    |   Set default linesize\n  if    (ch,r3,ge,=al2(pl_start_maxlinesize_#)) If lineSize is there\n   l     r2,pl_start_maxlinesize      |     Get it\n   l32   r2,0(r2)                     |\n   if    nz                           |     If it's nonzero,\n    lr    r1,r2                       |      we'll use that.\n   endif                              |\n  endif                               |\n  st    r1,pwa_maxlinesize            | Save true MaxLineSize value\n* *-------------------------------------------------------------------*\n* * Verify that a valid maxlinesize was supplied.  Maxlinesize must\n* * be >= 2 to avoid looping in the wrapping code due to the carriage\n* * controls and must be <= 32768 in order to avoid line truncation.\n* *-------------------------------------------------------------------*\n  errexit (clc,pwa_maxlinesize,gt,=f'32768'),or,                    @C2+\n               (clc,pwa_maxlinesize,lt,=f'2'),                      @C2+\n               code=&pl_invalid_maxlinesize                         @C2\n  l     r15,pwa_size_mask             | Get the SizeLength ICM mask\n  exi   r15,(stcm,r1,0,pwa_maxlinesize_adj) Save adj. for ST_FORMAT\n       eject                          |\n* *-------------------------------------------------------------------*\n* * Start the Memory Manager and String Formatter service processors.\n* *-------------------------------------------------------------------*\n  l    r1,pl_start_esv                |\n  l    r1,0(r1)                       |\n  st   r1,pwa_esv                     |\n  using esv,r1                        |\n  mvc   pwa_es_epa,esvesepa           |\n  mvc   pwa_es_token,esvestkn         |\n  drop  r1                            |\n  ES_Load_Module  id=ES,spid=MM       | Use E.S. to load memory mgr.\n  errexit    (treg,r15,nz),           |                                *\n               code=&pl_environment_support_error\n  MM_Start   ID=MM,                   | Start memory manager.          *\n               Increment=4096,        |                                *\n               Location=Any           |\n  errexit    (treg,r15,nz),           |                                *\n               code=&pl_memory_manager_error\n         space 1                      |\n  ES_Load_Module  id=ES,spid=ST       | Load string formatter.\n  errexit    (treg,r15,nz),           |                                *\n               code=&pl_environment_support_error\n  ST_Start   ID=ST,                   | Start string formatter.        *\n               SizeLength=pwa_sizelength\n  errexit    (treg,r15,nz),           |                                *\n               code=&pl_string_handler_error\n* *-------------------------------------------------------------------*\n* * Load and start File Handler for print file.\n* *\n* * Note: A 4 is coded for average record length.  For option fileid,\n* * average record length is ignored except to determine the default\n* * RECFM.  If the average record length matches the maximum record\n* * length, the default RECFM is fixed, otherwise it is variable.\n* * The default RECFM for PLMVS should be variable.\n* *\n* *-------------------------------------------------------------------*\n  ES_Load_Module  id=ES,spid=FI       | Use E.S. to load file handler.\n  errexit    (treg,r15,nz),           |                                *\n               code=&pl_environment_support_error\n  fi_start id=fi,                                                      *\n               file=pwa_ddname,                                        *\n               options=(output,fileid,isocc),                          *\n               recordlength=(4,pwa_maxlinesize)\n  st     r15,pwa_fi_last_rc           Save return code.\n  errexit not,(%fi_success),code=&pl_file_handler_error\n* *-------------------------------------------------------------------*\n* *  Verify that the LRECL of the DDNAME is the same or greater     @C2\n* *  than the specified maxlinesize.  If the lrecl is smaller than  @C2\n* *  the specified maxlinesize, then we indicate that wrapping will @C2\n* *  occur to the caller and the caller can decide if it is ok to   @C2\n* *  continue processing.                                           @C2\n* *-------------------------------------------------------------------*\n  fi_get_info id=fi,recfm=pwa_recfm,  | get RECFM and LRECL values  @C2+\n               lrecl=pwa_lrecl        |                             @C2\n  errexit not,(%fi_success),code=&pl_file_handler_error             @C2\n  lh    r1,pwa_lrecl                  | r1 := lrecl                 @C2\n  errexit (c,r1,lt,=f'2'),code=&pl_invalid_lrecl   lrecl too small  @C2\n  if   (clc,pwa_recfm(1),eq,=c'V')    | if recfm = variable         @C2\n   sh   r1,=h'4'                      |  r1 := lrecl-4 (adj for RDW)@C2\n  endif                               | endif                       @C2\n  if   (c,r1,lt,pwa_maxlinesize)      | if lrecl < maxlinesize      @C2\n   sbit pwaf1wrap                     |  indicate output wrapping   @C2\n   st   r1,pwa_maxlinesize            |  set maxlinesize = lrecl    @C2\n  endif                               | endif                       @C2\n* *-------------------------------------------------------------------*\n* *  Allocate temporary buffers to hold long formatted lines        @C2\n* *-------------------------------------------------------------------*\n  mvc   pwa_buffer_size,=f'32768'     | allocate 32K                @C2\n  mvc   pwa_buffer_data_len,pwa_buffer_size                         @C2\n  mm_obtain_storage id=mm,            | obtain the storage          @C2+\n               size=pwa_buffer_size,  |                             @C2+\n               address=pwa_buffer_data  buffer for data lines       @C2\n  errexit not,(%mm_success),code=&pl_memory_manager_error           @C2\n  mvc   pwa_buffer_head_len,pwa_buffer_size                         @C2\n  mm_obtain_storage id=mm,            | obtain the storage          @C2+\n               size=pwa_buffer_size,  |                             @C2+\n               address=pwa_buffer_head  buffer for header           @C2\n  errexit not,(%mm_success),code=&pl_memory_manager_error           @C2\n  mvc   pwa_buffer_foot_len,pwa_buffer_size                         @C2\n  mm_obtain_storage id=mm,            | obtain the storage          @C2+\n               size=pwa_buffer_size,  |                             @C2+\n               address=pwa_buffer_foot  buffer for footer           @C2\n  errexit not,(%mm_success),code=&pl_memory_manager_error           @C2\n* *-------------------------------------------------------------------*\n* * Determine if the FOLD option was specified.\n* *-------------------------------------------------------------------*\n  lh    r3,pwa_number_of_parms        |\n  if    (ch,r3,ge,=y(pl_start_options_#))\n   l     r1,pl_start_options          |\n   if    (tbit,0(r1),x'80')           |\n    sbit  pwaopfld                    |\n   endif                              |\n  endif                               |\n endblk                               |\n eject                                |\n*---------------------------------------------------------------------*\n*\n*  Subroutine: terminate\n*\n*---------------------------------------------------------------------*\n block name=terminate,type=subroutine |\n*   *-----------------------------------------------------------------*\n*   * Print footers on the current page if necessary.\n*   *-----------------------------------------------------------------*\n    if    (tbit,pwaf1hdr)             | If header exists on this page\n     callsub print_footers            |  Go put footers on it.\n    endif                             |\n*  *------------------------------------------------------------------*\n*  * Release the allocated buffer storage\n*  *------------------------------------------------------------------*\n    mm_release_storage id=mm,         |                             @C2+\n               size=pwa_buffer_size,  |                             @C2+\n               address=pwa_buffer_data                              @C2\n    errexit not,(%mm_success),code=&pl_memory_manager_error         @C2\n    mm_release_storage id=mm,         |                             @C2+\n               size=pwa_buffer_size,  |                             @C2+\n               address=pwa_buffer_head                              @C2\n    errexit not,(%mm_success),code=&pl_memory_manager_error         @C2\n    mm_release_storage id=mm,         |                             @C2+\n               size=pwa_buffer_size,  |                             @C2+\n               address=pwa_buffer_foot                              @C2\n    errexit not,(%mm_success),code=&pl_memory_manager_error         @C2\n*   *-----------------------------------------------------------------*\n*   * Terminate File Handler, Memory Manager and String Formatter.\n*   *-----------------------------------------------------------------*\n    FI_Terminate id=FI                | Release storage, shut down FI\n    ES_Unload_Module  id=ES,spid=FI   | Get rid of FI's loadmodule\n           space 1                    |\n    MM_Terminate id=MM                | Release storage, shut down MM\n    ES_Unload_Module  id=ES,spid=MM   | Get rid of MM's loadmodule\n           space 1                    |\n    ST_Terminate id=ST                | Shut down string formatter\n    ES_Unload_Module  id=ES,spid=ST   | Get rid of ST's loadmodule\n*   *-----------------------------------------------------------------*\n*   * Indicate PWA should be freed.\n*   *-----------------------------------------------------------------*\n    smctrl freepwa=yes                |   Free the PWA on return.\n endblk                               |\n eject                                |\n*---------------------------------------------------------------------*\n*\n*  Subroutine: set_header\n*\n*---------------------------------------------------------------------*\n block name=set_header,type=subroutine\n  lh    r3,pwa_number_of_parms        | Ensure right no. of parameters\n  errexit    (ch,r3,lt,=y(pl_sethdr_min_#)),or,                        +\n               (ch,r3,gt,=y(pl_sethdr_max_#)),                         +\n               code=&pl_invalid_number_of_parms\n  l     r3,pl_sethdr_linenbr          | Grab the line number\n  callsub find_hfd,(pwa_header_anchor,(r3))  See if already exists\n  if    (treg,r15,nz)                 | If no HFD for line number\n   callsub create_hfd,(pwa_header_anchor,(r3))  Go make one\n  endif                               |\n  lr    r5,r1                         | HFD addr from either routine\n  using hfd,r5                        |  is returned in R1.\n  mvc   hfd_iball,=c'HEAD'            | Set eyecatcher.\n  mvc   hfd_string,pl_sethdr_string   | Bind string and length\n  mvc   hfd_strlen,pl_sethdr_stringlen     addresses.\n  sbit  hfdf1hdr                      | Note HFD is for a header.\n  drop  r5                            |\n endblk                               |\n eject                                |\n*---------------------------------------------------------------------*\n*\n*  Subroutine: set_formatted_header\n*\n*---------------------------------------------------------------------*\n block name=set_formatted_header,type=subroutine\n    lh    r3,pwa_number_of_parms      | Validate number of parameters\n    errexit    (ch,r3,lt,=y(pl_setfmthdr_min_#)),or,                   +\n               (ch,r3,gt,=y(pl_setfmthdr_max_#)),                      +\n               code=&pl_invalid_number_of_parms\n    if    (ch,r3,gt,=y(pl_setfmthdr_pagedisp_#))   If pagedisp present\n     lr    r4,r3                      | Copy # of parms\n     sh    r4,=y(pl_setfmthdr_pagedisp_#) Get # source parms\n     l     r2,pl_setfmthdr_pagedisp   | Get pointer to pagedisp\n     errexit   (c,r4,lt,0(r2)),       | Error if sourceparms < pagedisp*\n               code=&pl_invalid_pagedisp\n    elseif (eq)                       | Else if only pagedisp present\n     l     r2,pl_setfmthdr_pagedisp   |  It better be zero\n     l32   r2,0(r2)                   |\n     errexit (nz),code=&pl_invalid_pagedisp\n     xr    r4,r4                      | OK so far: clear # sourceparms.\n    else                              | Else no pagedisp,\n     xr    r4,r4                      |  so clear it out.\n    endif                             |\n    st    r4,pwa_sourceparm_count     | Save\n    l     r2,pl_setfmthdr_linenbr     | Point to linenumber\n    callsub   find_hfd,(pwa_header_anchor,(r2))  Try to find its HFD\n    if    (treg,r15,nz)               | If no HFD exists yet, make one\n     callsub  create_hfd,(pwa_header_anchor,(r2),pwa_sourceparm_count)\n    else                              | Otherwise (line# has an HFD)\n*    *----------------------------------------------------------------*\n*    * We found an HFD, but it may not be large enough to hold our\n*    * source string.  For that matter, it may be too large.  So, if\n*    * it's not the same size, we nuke it and make a new one.\n*    *----------------------------------------------------------------*\n     if    (ch,r4,ne,hfd_#parms-hfd(r1)) If it isn't the right size\n      callsub destroy_hfd,(pwa_header_anchor,(r2))  Make a new one\n      callsub create_hfd,(pwa_header_anchor,(r2),pwa_sourceparm_count)\n     endif                            |\n    endif                             |\n    lr    r5,r1                       | HFD address in R1 regardless\n    using hfd,r5                      |\n    mvc   hfd_iball,=c'HEAD'          | Set eyecatcher.\n    mvc   hfd_string,pl_setfmthdr_fmtstring   Bind string and length\n    mvc   hfd_strlen,pl_setfmthdr_fmtstring_len    addresses.\n    sbit  (hfdf1hdr,hfdf1fmt)         | Note HFD is for a header.\n    if    (treg,r4,nz)                | If source parms present:\n     lr    r1,r4                      | Get # source parms\n     sll   r1,2                       | Multiply by 4, then subtract 1\n     bctr  r1,0                       | Use it to move sources to HFD.\n     exi   r1,(mvc,hfd_sourcelist(0),pl_setfmthdr_sourcelist)\n    endif                             |\n    lh    r3,pwa_number_of_parms      |\n    if    (ch,r3,ge,=y(pl_setfmthdr_pagedisp_#))   If pagedisp present\n     l     r2,pl_setfmthdr_pagedisp   | Get pagedisp address\n     l32   r2,0(r2)                   | Get pagedisp value\n     if    (nz)                       | If present\n      bctr  r2,0                      |  Subtract 1 to displace from 0\n      sll   r2,2                      |  Multiply by 4\n      la    r2,hfd_sourcelist(r2)     |  Displace into HFD sourcelist\n      mvc   hfd_page#,0(r2)           |  Copy n'th sourceparm to page#\n      sbit  hfdf1pg#                  |   and note that it's present.\n     endif                            |\n    endif                             |\n    drop  r5                          |\n endblk                               |\n eject                                |\n*---------------------------------------------------------------------*\n*\n*  Subroutine: reset_header\n*\n*---------------------------------------------------------------------*\n block name=reset_header,type=subroutine\n  lh    r3,pwa_number_of_parms        | Validate number of parameters.\n  errexit    (ch,r3,lt,=y(pl_resethdr_min_#)),or,                      *\n               (ch,r3,gt,=y(pl_resethdr_max_#)),                       *\n               code=&pl_invalid_number_of_parms\n  l     r4,pl_resethdr_linenbr        | Get line# to reset\n  callsub destroy_hfd,(pwa_header_anchor,(r4))  Nuke that HFD(s)\n  errexit    (treg,r15,nz),           | Report error if not found      *\n               code=&pl_header_not_found\n endblk                               |\n eject                                |\n*---------------------------------------------------------------------*\n*\n*  Subroutine: set_footer\n*\n*---------------------------------------------------------------------*\n block name=set_footer,type=subroutine\n  lh    r3,pwa_number_of_parms        | Validate number of parameters.\n  errexit    (ch,r3,lt,=y(pl_setftr_min_#)),or,                        +\n               (ch,r3,gt,=y(pl_setftr_max_#)),                         +\n               code=&pl_invalid_number_of_parms\n  l     r3,pl_setftr_linenbr          | Grab the line number\n  callsub find_hfd,(pwa_footer_anchor,(r3))  See if already exists\n  if    (treg,r15,nz)                 | If HFD not found for line#\n   callsub create_hfd,(pwa_footer_anchor,(r3))  Create a new one\n  endif                               |\n  lr    r5,r1                         | HFD addr from either routine\n  using hfd,r5                        |  is returned in R1.\n  mvc   hfd_iball,=c'FOOT'            | Set eyecatcher.\n  mvc   hfd_string,pl_setftr_string   Bind string and length\n  mvc   hfd_strlen,pl_setftr_stringlen     addresses.\n  drop  r5                            |\n endblk                               |\n eject                                |\n*---------------------------------------------------------------------*\n*\n*  Subroutine: set_formatted_footer\n*\n*---------------------------------------------------------------------*\n block name=set_formatted_footer,type=subroutine\n    lh    r3,pwa_number_of_parms      | Validate number of parameters.\n    errexit    (ch,r3,lt,=y(pl_setfmtftr_min_#)),or,                   +\n               (ch,r3,gt,=y(pl_setfmtftr_max_#)),                      +\n               code=&pl_invalid_number_of_parms\n    if    (ch,r3,gt,=y(pl_setfmtftr_pagedisp_#))   If pagedisp present\n     lr    r4,r3                      | Copy # of parms\n     sh    r4,=y(pl_setfmtftr_pagedisp_#) Get # source parms\n     l     r2,pl_setfmtftr_pagedisp   | Get pointer to pagedisp\n     errexit   (c,r4,lt,0(r2)),       | Error if sourceparms < pagedisp*\n               code=&pl_invalid_pagedisp\n    elseif (eq)                       | Else if only pagedisp present\n     l     r2,pl_setfmtftr_pagedisp   |  It better be zero\n     l32   r2,0(r2)                   |\n     errexit (nz),code=&pl_invalid_pagedisp\n     xr    r4,r4                      | OK so far: clear # sourceparms.\n    else                              | Else no pagedisp,\n     xr    r4,r4                      |  so clear it out.\n    endif                             |\n    st    r4,pwa_sourceparm_count     | Save\n    l     r2,pl_setfmtftr_linenbr     | Point to linenumber\n    callsub   find_hfd,(pwa_footer_anchor,(r2))\n    if    (treg,r15,nz)               |\n     callsub  create_hfd,(pwa_footer_anchor,(r2),pwa_sourceparm_count)\n    else                              |\n*    *----------------------------------------------------------------*\n*    * We found an HFD, but it may not be large enough to hold our\n*    * source string.  For that matter, it may be too large.  So, if\n*    * it's not the same size, we nuke it and make a new one.\n*    *----------------------------------------------------------------*\n     if    (ch,r4,ne,hfd_#parms-hfd(r1)) If it isn't the right size\n      callsub destroy_hfd,(pwa_footer_anchor,(r2))  Make a new one.\n      callsub create_hfd,(pwa_footer_anchor,(r2),pwa_sourceparm_count)\n     endif                            |\n    endif                             |\n    lr    r5,r1                       |\n    using hfd,r5                      |\n    mvc   hfd_iball,=c'FOOT'          | Set eyecatcher.\n    mvc   hfd_string,pl_setfmtftr_fmtstring   Bind string and length\n    mvc   hfd_strlen,pl_setfmtftr_fmtstring_len    addresses.\n    sbit  hfdf1fmt                    | Note HFD formatted, not a hdr.\n    if    (treg,r4,nz)                |\n     lr    r1,r4                      | Get # source parms\n     sll   r1,2                       | Multiply by 4, then subtract 1\n     bctr  r1,0                       | Use it to move sources to HFD.\n     exi   r1,(mvc,hfd_sourcelist(0),pl_setfmtftr_sourcelist)\n    endif                             |\n    lh    r3,pwa_number_of_parms      |\n    if    (ch,r3,ge,=y(pl_setfmtftr_pagedisp_#))   If pagedisp present\n     l     r2,pl_setfmtftr_pagedisp   | Get pagedisp address\n     l32   r2,0(r2)                   | Get pagedisp value\n     if    (nz)                       | If present\n      bctr  r2,0                      |  Subtract 1 to displace from 0\n      sll   r2,2                      |  Multiply by 4\n      la    r2,hfd_sourcelist(r2)     |  Displace into HFD sourcelist\n      mvc   hfd_page#,0(r2)           |  Copy n'th sourceparm to page#\n      sbit  hfdf1pg#                  |   and note that it's present.\n     endif                            |\n    endif                             |\n    drop  r5                          |\n endblk                               |\n eject                                |\n*---------------------------------------------------------------------*\n*\n*  Subroutine: reset_footer\n*\n*---------------------------------------------------------------------*\n block name=reset_footer,type=subroutine\n  lh    r3,pwa_number_of_parms        |   Load number of parameters.\n  errexit    (ch,r3,lt,=y(pl_resetftr_min_#)),or,                      *\n               (ch,r3,gt,=y(pl_resetftr_max_#)),                       *\n               code=&pl_invalid_number_of_parms\n  l     r4,pl_resetftr_linenbr        | Get line# to reset\n  callsub destroy_hfd,(pwa_footer_anchor,(r4))  Nuke that HFD(s)\n  errexit    (treg,r15,nz),           | Report error if not found      *\n               code=&pl_footer_not_found\n endblk                               |\n eject                                |\n*---------------------------------------------------------------------*\n*\n*  Subroutine: reserve_footer\n*\n*---------------------------------------------------------------------*\n block name=reserve_footer,type=subroutine\n  lh    r3,pwa_number_of_parms        | Validate number of parameters.\n  errexit    (ch,r3,lt,=y(pl_rsvftr_min_#)),or,                        *\n               (ch,r3,gt,=y(pl_rsvftr_max_#)),                         *\n               code=&pl_invalid_number_of_parms\n  l     r2,pl_rsvftr_lines            | Point to # lines to reserve\n  mvc   pwa_footer_size,0(r2)         | Copy value to PWA for later.\n endblk                               |\n eject                                |\n*---------------------------------------------------------------------*\n*\n*  Subroutine: page_break\n*\n*---------------------------------------------------------------------*\n block name=page_break,type=subroutine\n  lh    r3,pwa_number_of_parms        |   Load number of parameters.\n  errexit    (ch,r3,lt,=y(pl_pagebreak_min_#)),or,                     *\n               (ch,r3,gt,=y(pl_pagebreak_max_#)),                      *\n               code=&pl_invalid_number_of_parms\n       space 1                        |\n  if    (tbit,pwaf1hdr)               | If there is a header on page\n   callsub print_footers              |  Print the footers\n  endif                               |\n endblk                               |\n eject                                |\n*---------------------------------------------------------------------*\n*\n*  Subroutine: print\n*\n*---------------------------------------------------------------------*\n block name=print,type=subroutine\n  lh    r3,pwa_number_of_parms        | Load number of parameters.\n  errexit    (ch,r3,lt,=y(pl_print_min_#)),or,    Exit if wrong no.    *\n               (ch,r3,gt,=y(pl_print_max_#)),        of parms.         *\n               code=&pl_invalid_number_of_parms\n  callsub clear_buffer,(*pwa_buffer_data,pwa_buffer_data_len)       @C2\n  l     r2,pl_print_stringlen         | r2 -> address of the length @C2\n  xr    r1,r1                         | clear a reg for icm         @cx\n  l     r15,pwa_size_mask             | get icm mask for sizelength @cx\n  exi   r15,(icm,r1,0,0(r2))          | get the length -> r1        @cx\n*>l     r2,0(,r2)                     | r2 := length                @Cx\n  st    r1,pwa_buffer_data_len        | Save line length.           @Cx\n  callsub copy_buffer,(*pwa_buffer_data,*pl_print_string,           @C2+\n               pwa_buffer_data_len)\n  if    (tbit,pwaf1hdr,off)           | If page needs a header\n   callsub print_headers              |  Give it one.\n  endif                               |\n  if    (tbit,pwaopfld)               | If folding to uppercase     @C2\n   callsub upcase_buffer,(*pwa_buffer_data,pwa_buffer_data_len)     @C2\n  endif                               |                             @C2\n  callsub  writeline,(*pwa_buffer_data,pwa_buffer_data_len,         @C2+\n               psd_print_headers)     |                             @C2\n endblk                               |\n eject                                |\n*---------------------------------------------------------------------*\n*\n*  Subroutine: print_formatted\n*\n*---------------------------------------------------------------------*\n block name=print_formatted,type=subroutine\n  lh    r3,pwa_number_of_parms        |   Load number of parameters.\n  errexit    (ch,r3,lt,=y(pl_printfmt_min_#)),or,   Exit if wrong      *\n               (ch,r3,gt,=y(pl_printfmt_max_#)),       no. of parms.   *\n               code=&pl_invalid_number_of_parms\n  callsub clear_buffer,(*pwa_buffer_data,pwa_buffer_data_len)       @C2\n* *-------------------------------------------------------------------*\n* *  Build parameter list for string formatter, then call it.\n* *-------------------------------------------------------------------*\n  l     r2,pl_printfmt_fmtstring      | Point to control string\n  l     r3,pl_printfmt_fmtstring_len Point to ctl string's length\n  l     r1,pwa_buffer_size            | Point to full buff format\n  l     r5,pwa_size_mask              | Get the SizeLength ICM mask\n  exi   r5,(stcm,r1,0,pwa_maxlinesize_adj) Save adj. for ST_FORMAT\n  l     r1,pwa_buffer_data_len\n  exi   r5,(stcm,r1,0,&w.datalen_adj) | Save adj. for ST_FORMAT\n  if    (ch,r3,gt,=y(pl_printfmt_max_#))  If sourcelist provided.\n    la    r4,pl_printfmt_sourcelist     |     r4-> sourceparmlist\n    plist (0(r2),0(r3),*pwa_buffer_data,&w.datalen_adj,(r4))\n  else\n    plist (0(r2),0(r3),*pwa_buffer_data,&w.datalen_adj)\n  endif\n  callsub format                      | Format it.\n  slr   r1,r1                         | Clear before ICM instr.\n  exi   r5,(icm,r1,0,&w.datalen_adj)  | Load adj. from ST_FORMAT\n  st    r1,pwa_buffer_data_len        | Save fullword length.\n  if    (tbit,pwaf1sft)               | If formatter truncated it\n   sbit  pwatflin                     |\n  endif                               |\n  if    (tbit,pwaf1hdr,off)           | If page needs a header\n   callsub print_headers              |  Give it one.\n  endif                               |\n  if    (tbit,pwaopfld)               | If folding to uppercase     @C2\n   callsub upcase_buffer,(*pwa_buffer_data,pwa_buffer_data_len)     @C2\n  endif                               |                             @C2\n  callsub  writeline,(*pwa_buffer_data,pwa_buffer_data_len,         @C2+\n               psd_print_headers)     |                             @C2\n endblk                               |\n               swa\n&w.datalen_adj ds f\n               endswa\n eject                                |\n*---------------------------------------------------------------------*\n*\n*  Subroutine: query_lines_left\n*\n*---------------------------------------------------------------------*\n block name=query_lines_left,type=subroutine\n  lh    r3,pwa_number_of_parms        |   Load number of parameters.\n  errexit    (ch,r3,lt,=y(pl_qlines_min_#)),or,     Exit if wrong      *\n               (ch,r3,gt,=y(pl_qlines_max_#)),         no. of parms.   *\n               code=&pl_invalid_number_of_parms\n  l     r7,pl_qlines_lines            | Get LINES parameter\n  la    r7,0(r7)                      | Strip off the VL bit\n  errexit (treg,r7,z),                | If address is zero, required   *\n               code=&pl_missing_parameter  parameter is missing.\n  if    (clc,pwa_line_count,eq,=f'0'),or, If at bottom of page or      *\n               (clc,pwa_line_count,eq,psd_force_eject)   forcing eject\n   callsub print_headers              |  Force headers out.\n  endif                               |\n  l     r1,pwa_pagesize               | Get current pagesize\n  s     r1,pwa_footer_size            | Minus footer size (if any)\n  s     r1,pwa_line_count             | Minus current line counter\n  st    r1,0(r7)                      | Return value to caller.\n endblk                               |\n eject                                |\n*---------------------------------------------------------------------*\n*\n*  Subroutine: get_info\n*\n*---------------------------------------------------------------------*\n block name=get_info,type=subroutine\n    lh     r6,pwa_number_of_parms     |   r6 := total #parms passed in.\n    s      r6,=f'2'                   |   subtract token, function-code\n    la     r7,pl_gi_function          |   r7 -> 1st info subcode parm.\n    using  pl_gi_function,r7          |   Address get_info parms.\n    loop   while,(treg,r6,p)          |   Loop while parms remain.\n     l       r2,pl_gi_function        |    R2 -> information sub-code.\n     l       r1,0(,r2)                |    R1 := information sub-code.\n     caseblk reg=r1,wreg=r1,mult=1    |    Case on info sub-code:\n     case &pl_gi_lrecl                |    *--------------> LRECL\n      if (c,r6,lt,=f'2')              |     If not enough parameters.\n        errexit code=&pl_missing_parameter   Complain now.\n      endif                           |     EndIf.\n      s       r6,=f'2'                |     We'll use 2 parms.\n      l       r2,pl_gi_area           |     r2 -> caller area.\n      fi_get_info id=fi,lrecl=0(r2)         Return LRECL value.\n      st      r15,pwa_fi_last_rc      |     Save return code.\n      errexit (not,(%fi_success)),code=&pl_file_handler_error\n      la      r7,2*4(,r7)             |     Point r7 past parms used.\n     case &pl_gi_recfm                |    *--------------> RECFM.\n      if (c,r6,lt,=f'2')              |     If not enough parameters.\n        errexit code=&pl_missing_parameter   Complain now.\n      endif                           |     EndIf.\n      s       r6,=f'2'                |     We'll use 2 parms.\n      l       r2,pl_gi_area           |     r2 -> caller area.\n      fi_get_info id=fi,recfm=0(r2)         Return recfm value.\n      st      r15,pwa_fi_last_rc      |     Save return code.\n      errexit (not,(%fi_success)),code=&pl_file_handler_error\n      la      r7,2*4(,r7)             |     Point r7 past parms used.\n     case &pl_gi_fimsg                |    *-------------------> FIMSG\n      if (c,r6,lt,=f'4')              |     If not enough parameters.\n        errexit code=&pl_missing_parameter   Complain now.\n      endif                           |     EndIf.\n      s  r6,=f'4'                     |     We'll use 4 parms.\n      lm      r2,r4,pl_gi_area        |     r2/3/4 -> area/size/retlen\n      fi_get_info id=fi,msg=(0(r2),0(r3)),msglen=0(r4)\n      st      r15,pwa_fi_last_rc      |     Save return code.\n      errexit (not,(%fi_success)),code=&pl_file_handler_error\n      la      r7,4*4(,r7)             |     Point r7 past parms used.\n     case &pl_gi_firc                 |    *-------------------> FIRC\n      if (c,r6,lt,=f'2')              |     If not enough parameters.\n        errexit code=&pl_missing_parameter   Complain now.\n      endif                           |     EndIf.\n      s     r6,=f'2'                  |     We'll use 2 parms.\n      l     r2,pl_gi_area             |     Return last RC\n      mvc   0(4,r2),pwa_fi_last_rc    |     to caller.\n      la    r7,2*4(,r7)               |     Point r7 past parms used.\n     case other                       |    *-------------------> *ERROR\n      errexit code=&pl_invalid_gi_subcode\n     endcase                          |    EndCase\n    endloop while                     |   EndLoop.\n    drop    r7                        |   Drop info subcode parms.\n endblk                               |\n eject                                |\n*---------------------------------------------------------------------*\n*\n*  Subroutine: get_reference\n*\n*---------------------------------------------------------------------*\n block name=get_reference,type=subroutine\n  lh    r3,pwa_number_of_parms        |   Load number of parameters.\n  errexit    (ch,r3,lt,=y(pl_qlines_min_#)),or,     Exit if wrong      *\n               (ch,r3,gt,=y(pl_qlines_max_#)),         no. of parms.   *\n               code=&pl_invalid_number_of_parms\n  l     r7,pl_gr_reference            | Get REFERENCE parameter.\n  la    r7,0(r7)                      | Strip off the VL bit\n  errexit (treg,r7,z),                | If address is zero, required   *\n               code=&pl_missing_parameter  parameter is missing.\n  fill   pwa_pl_reference,x'40'       | Fill with blanks.\n  fi_get_reference id=fi,             |  Get reference string.         +\n               reference=pwa_pl_reference\n  errexit (not,(%fi_success)),code=&pl_file_handler_error\n  mvc   0(L'pwa_pl_reference,r7),pwa_pl_reference\n*                                     |   to caller.\n endblk                               |\n eject                                |\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Format\n*  Purpose:    Call the String Formatter to format the data provided\n*              by the caller.  Parameters are:\n*                +0 -- Address of format control string\n*                +4 -- Address of format control string length\n*                +8 -- Address of target string\n*               +12 -- Address of target string size\n*               +16 -- Address of beginning of source parm list\n*  Calls:      String Formatter (external, service processor)\n*\n*---------------------------------------------------------------------*\n block name=format,type=subroutine    |\n  lr    r6,r1                         | Save incoming parmlist address\n  lm    r2,r5,0(r1)                   | Grab caller's parms\n  rbit  pwaf1sft                      | Clear 'formatter truncated' flg\n  plist       (pwa_st_token,          | 1: String Formatter's token    *\n               &st_format,            | 2: Function code               *\n               0(r4),                 | 3: Target area                 *\n               pwa_maxlinesize_adj,   | 4: Adjusted MaxLineSize        *\n               pwa_result_length,     | 5: Returned result length      *\n               0(r2),                 | 6: Control string              *\n               0(r3)),                | 7: Control string length       *\n               pl=(pwa_st_format_pl,57),   Build it here,              *\n               novl                   | and don't flip no x'80' bits.\n  lr    r7,r1                         | Save PLIST's parmlist pointer\n  la    r1,28(r1)                     | Point to VL part of parmlist\n  if    (tbit,12(r6),x'80',off)       | If targetlen wasn't last parm\n   l     r15,16(,r6)                  |\n   la    r0,pwa_st_format_ple         |  Point to stg past end of pl.\n   st    r0,&w.pl_end                 |    Save for limit-check.\n   loop  until                        | Loop thru list til 80 bit found\n    errexit (c,r1,ge,&w.pl_end),code=&pl_invalid_number_of_parms\n    l     r14,0(r15)                  |  Get a parm\n    la    r14,0(r14)                  |  Make sure the 80 bit is off\n    st    r14,0(r1)                   |  Save into ST_FORMAT parmlist.\n    leave loop=*,(tbit,0(r15),x'80')  |  Quit if we moved the last one\n    la    r1,4(r1)                    |  Point to next dest and\n    la    r15,4(r15)                  |   next sourceparm\n   endloop until,leave                |    and go move them.\n   sbit  0(r1),x'80'                  |  Set VL bit at end of VL plist\n  else                                | Otherwise (no substitutions)\n   sbit  24(r7),x'80'                 |  Set VL at end of fixed plist.\n  endif                               |\n  callx pwa_st_epa,pl=(pwa_st_format_pl) Call ST_FORMAT w/custom parms.\n  if    (treg,r15,nz)                 | If formatter found a problem\n   if    (ch,r15,eq,=y(&st_truncated))   Was it truncation?\n    sbit  pwaf1sft                    |   Note that it got whacked\n   else                               |  Otherwise ...\n    errexit code=&pl_string_handler_error              Go choke.\n   endif                              |\n  endif                               |\n  l     r15,pwa_size_mask             | Get the SizeLength ICM mask\n  exi   r15,(icm,r1,0,pwa_result_length)  Get the length\n  l     r15,12(,r6)                   | Return length as\n  st    r1,0(,r15)                    | a parameter.\n endblk                               |\n          swa\n&w.pl_end ds   a\n          endswa\n       eject                          |\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Count_Print_Lines\n*  Purpose:    Look at carriage control, and decide how many lines\n*              are currently on the physical page.  If a page break\n*              is needed, r15 will be nonzero upon return.\n*  Parameters: On entry, R1 points to the following parameter list:\n*                +0 -- Address of data line to be examined.\n*  Returncode: 0 -- Line counts updated.\n*              4 -- Page break needed due to page overflow.\n*              8 -- Page break forced due to carriage control of C'1'.\n*  Calls:      None\n*\n*---------------------------------------------------------------------*\n block name=Count_Print_Lines,type=subroutine\n  l     r2,0(r1)                      |\n  la    r1,1                          | Assume single space.\n  if    (cli,0(r2),eq,c'0')           | If ASA control '0'\n   la    r1,2                         |  Double-space.\n  elseif (cli,0(r2),eq,c'-')          | If ASA control = '-'\n   la    r1,3                         |  Triple-space.\n  elseif (cli,0(r2),eq,c'+')          | If ASA control = '+'\n   xr    r1,r1                        |  Overprint.\n  elseif (cli,0(r2),eq,c'1')          | If ASA control = '1'\n   st    r1,pwa_line_count            | Save F'1' in R1 as linecount\n   la    r15,8                        |  Indicate page eject needed\n   leave block=*                      |  (page_break sets line count)\n  endif                               |\n  a    r1,pwa_line_count              | Add existing line count\n  l    r3,pwa_footer_size             | See if we blew out footer area\n  ar   r3,r1                          |\n  if   (c,r3,gt,pwa_pagesize)         | Did we fall off the edge?\n   la    r15,4                        |  Need to 'force' an eject.\n  else                                | Otherwise (everything looks OK)\n   st    r1,pwa_line_count            |  Save updated line count\n   xr    r15,r15                      |   and end RC zero.\n  endif                               |\n endblk rc=(r15)                      |\n eject                                |\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Print_Footers\n*  Purpose:    Print any footers defined by the caller.\n*  Calls:      Count_Print_Lines\n*              Format\n*              Update_Page_Counts\n*\n*---------------------------------------------------------------------*\n         SPACE 1                      |\n block name=print_footers,type=subroutine\n  leave block=*,(clc,pwa_line_count,eq,psd_force_eject)\n* *-------------------------------------------------------------------*\n* *  See if we need to skip down to where the footers go.\n* *-------------------------------------------------------------------*\n  l32   r15,pwa_footer_size           |\n* leave block=*,(z)                   |\n  l     r1,pwa_pagesize               | Get the page size\n  sr    r1,r15                        | Get what line footers start on\n  s     r1,pwa_line_count             | Get how many lines away we are\n  if    (p),and,(treg,r15,nz)         | Do we need to skip any?\n   lr    r5,r1                        |  Get divisor\n   xr    r4,r4                        |  Clear 1st of reg pair\n   d     r4,=f'3'                     |  Divide reg pair by 3\n   if    (treg,r5,nz)                 |  If quotient nonzero\n    loop  bct                         |  Triple-space that many times.\n     fi_writeline id=fi,line=psd_skip_3_lines\n     st     r15,pwa_fi_last_rc        |    Save return code.\n     errexit not,(%fi_success),code=&pl_file_handler_error\n    endloop bct,r5                    |\n   endif                              |\n   if    (treg,r4,nz)                 |  If remainder nonzero\n    loop  bct                         |  Single-space that many times.\n     fi_writeline id=fi,line=psd_skip_1_line\n     st     r15,pwa_fi_last_rc        |   Save return code.\n     errexit not,(%fi_success),code=&pl_file_handler_error\n    endloop bct,r4                    |\n   endif                              |\n  endif                               |\n* *-------------------------------------------------------------------*\n* *  Now, print all footers that have HFD's.\n* *-------------------------------------------------------------------*\n  l     r7,pwa_footer_anchor          |\n  loop  while,(treg,r7,nz),and,(clc,pwa_footer_size,ne,=f'0')\n   callsub clear_buffer,(*pwa_buffer_foot,pwa_buffer_foot_len)      @C2\n   using hfd,r7                       | establish hfd addressability\n   l     r2,hfd_string                | r2 -> hfd string\n   l     r3,hfd_strlen                | r3 -> hfd length\n   if    (tbit,hfdf1fmt,off)          |\n    xr    r14,r14                     | clear a reg for icm         @cx\n    l     r15,pwa_size_mask           | get mask for icm            @cx\n    exi   r15,(icm,r14,0,0(r3))       | get the value -> r14        @cx\n*>  l     r14,0(,r3)                  | r14 := hfd length           @Cx\n    st    r14,pwa_buffer_foot_len     | Save footer size.           @C2\n    callsub copy_buffer,(*pwa_buffer_foot,*hfd_string,              @C2+\n               pwa_buffer_foot_len)   |\n    if    (tbit,pwaopfld)             | If folding to uppercase     @C1\n     callsub upcase_buffer,(*pwa_buffer_foot,pwa_buffer_foot_len)   @C2\n    endif                             |                             @C1\n    callsub writeline,(*pwa_buffer_foot,pwa_buffer_foot_len,        @C2*\n               psd_dont_print_headers)                              @C2\n   else                               |\n    l     r5,pwa_buffer_size          | Point to full buff format\n    l     r15,pwa_size_mask           | Get the SizeLength ICM mask\n    exi   r15,(stcm,r5,0,pwa_maxlinesize_adj) Save adj. for ST_FORMAT\n    if    (clc,hfd_#parms,eq,=h'0')   |\n     plist  ((r2),(r3),*pwa_buffer_foot,pwa_buffer_foot_len)        @C2\n    else                              |\n     plist  ((r2),(r3),*pwa_buffer_foot,pwa_buffer_foot_len,        @C2*\n               hfd_sourcelist)        |                             @C2\n    endif                             |\n    callsub format                    |\n    if    (tbit,pwaf1sft)             |\n     sbit  pwatfftr                   |\n    endif                             |\n    if    (tbit,pwaopfld)             | If folding to uppercase     @C1\n     callsub upcase_buffer,(*pwa_buffer_foot,pwa_buffer_foot_len)   @C2\n    endif                             |                             @C1\n    callsub writeline,(*pwa_buffer_foot,pwa_buffer_foot_len,        @C2*\n               psd_dont_print_headers)                              @C2\n   endif                              |\n   l     r7,hfd_link                  |\n  endloop while                       |\n  drop  r7                            |\n  rbit  pwaf1hdr                      |\n  xc    pwa_line_count,pwa_line_count | Zero line count.\n endblk                               |\n eject                                |\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Update_Page_Counts\n*  Purpose:    Run through header and footer definitions and increment\n*              any page counters defined by the caller.\n*  Calls:      None\n*\n*---------------------------------------------------------------------*\n         SPACE 1                      |\n block name=update_page_counts,type=subroutine\n  l     r1,pwa_page_count             | Update PL's counter first\n  la    r1,1(r1)                      |\n  st    r1,pwa_page_count             |\n  l32   r7,pwa_header_anchor          | See what headers exist\n  if    nz                            | If there are some\n   using hfd,r7                       |  Set base\n   loop  while,(treg,r7,nz)           |  Loop thru them:\n    if    (tbit,hfdf1fmt)             |   If this one uses formatter\n     l32   r1,hfd_page#               |    See if there's a page# addr\n     if    nz                         |    If so:\n      l     r15,0(r1)                 |     Increment it.\n      la    r15,1(r15)                |\n      st    r15,0(r1)                 |\n     endif                            |\n    endif                             |\n    l     r7,hfd_link                 | Go thru all header HFD's.\n   endloop while                      |\n   drop  r7                           |\n  endif                               |\n  l32   r7,pwa_footer_anchor          | Same with footers ....\n  if    nz                            | If some exist\n   using hfd,r7                       |\n   loop  while,(treg,r7,nz)           |  Loop through them\n    if    (tbit,hfdf1fmt)             |   If this one's formatted\n     l32   r1,hfd_page#               |    Get page# address\n     if    nz                         |    If there is one\n      l     r15,0(r1)                 |     Increment it.\n      la    r15,1(r15)                |\n      st    r15,0(r1)                 |\n     endif                            |\n    endif                             |\n    l     r7,hfd_link                 |   Loop thru all footer HFD's.\n   endloop while                      |\n   drop  r7                           |\n  endif                               |\n endblk                               |\n eject                                |\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Print_Headers\n*  Purpose:    Print any headers defined by the caller.\n*  Calls:      Count_Print_Lines\n*              Update_Page_Counts\n*              Format\n*\n*---------------------------------------------------------------------*\n         SPACE 1                      |\n block name=print_headers,type=subroutine\n  callsub update_page_counts          | Bump all active page counters\n  l     r7,pwa_header_anchor          | Get header HFD anchor\n  if    (clc,pwa_line_count,eq,psd_force_eject)\n   mvc   pwa_line_count,=f'1'         |\n  endif                               |\n  loop  while,(treg,r7,nz)            | Loop thru all defined HFD's:\n   callsub clear_buffer,(*pwa_buffer_head,pwa_buffer_head_len)      @C2\n   using hfd,r7                       |\n   l     r2,hfd_string                |  Point to header string\n   l     r3,hfd_strlen                |   and its length\n   if    (tbit,hfdf1fmt,off)          |  If it's not formatted\n    xr    r14,r14                     |   Clear a reg for icm       @cx\n    l     r15,pwa_size_mask           |   Get mask for icm          @cx\n    exi   r15,(icm,r14,0,0(r3))       |   Get the value -> r14      @cx\n*>  l     r14,0(,r3)                  |   r14 := hfd length         @Cx\n    st    r14,pwa_buffer_head_len     |   Save header size.         @C2\n    callsub copy_buffer,(*pwa_buffer_head,*hfd_string,              @C2+\n               pwa_buffer_head_len)   |                             @C2\n    if    (tbit,pwaopfld)             | If folding to uppercase     @C1\n     callsub upcase_buffer,(*pwa_buffer_head,pwa_buffer_head_len)   @C2\n    endif                             |                             @C1\n    callsub writeline,(*pwa_buffer_head,pwa_buffer_head_len,        @C2*\n               psd_dont_print_headers)                              @C2\n   else                               | Otherwise (HFD for formatter)\n    l     r5,pwa_buffer_size          | Point to full buff format\n    l     r15,pwa_size_mask           | Get the SizeLength ICM mask\n    exi   r15,(stcm,r5,0,pwa_maxlinesize_adj) Save adj. for ST_FORMAT\n    if    (clc,hfd_#parms,eq,=h'0')   |  If no sourceparms\n     plist ((r2),(r3),*pwa_buffer_head,   3 parms to \"format\"       @C2*\n               pwa_buffer_head_len)   |                             @C2\n    else                              |  Otherwise, send formatter the\n     plist ((r2),(r3),*pwa_buffer_head,          sourcelist.        @C2*\n               pwa_buffer_head_len,hfd_sourcelist)                  @C2\n    endif                             |\n    callsub format                    |  Format the stuff out\n    if    (tbit,pwaf1sft)             |\n     sbit  pwatfhdr                   |\n    endif                             |\n    if    (tbit,pwaopfld)             | If folding to uppercase     @C1\n     callsub upcase_buffer,(*pwa_buffer_head,pwa_buffer_head_len)   @C2\n    endif                             |                             @C1\n    callsub writeline,(*pwa_buffer_head,pwa_buffer_head_len,        @C2*\n               psd_dont_print_headers)                              @C2\n   endif                              |  Endif (formatted HFD or not?)\n   l     r7,hfd_link                  |  Point to next HFD\n  endloop while                       | and do them all.\n  drop  r7                            |\n  sbit  pwaf1hdr                      | Note that header is on page.\n endblk                               |\n eject                                |\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Create_HFD\n*  Purpose:    Acquire storage and initialize an HFD.\n*  Parameters: On entry, R1 points to the following parameter list:\n*                +0 -- Address of HFD anchor\n*                +4 -- Address of fullword line number for header.\n*                +8 -- Number of string formatter sources (optional)\n*  Returned:   Upon return, R1 will point to the new HFD.\n*  Calls:      Memory Manager (external)\n*\n*---------------------------------------------------------------------*\n         SPACE 1                      |\n block name=Create_HFD,type=subroutine\n  lm    r4,r5,0(r1)                   |\n  if    (tbit,8(r1),x'80')            | If there's a 3rd parm\n   l     r6,8(r1)                     |  Get its address\n   l     r6,0(r6)                     |  Get # source parms\n  else                                | Otherwise\n   xr    r6,r6                        |  Set it to zero.\n  endif                               |\n  lr    r2,r6                         | Get # source parms (if any)\n  sll   r2,2                          | Multiply by 4 for fullwords\n  la    r2,HFD_Base_Length(r2)        | Add length of base HFD\n  st    r2,&s.length                  |\n  MM_Obtain_Storage ID=MM,            | Get storage for it             *\n               Size=&s.length,        |                                *\n               Address=&s.hfdaddr     |\n  errexit      (treg,r15,nz),         |                                *\n               code=&pl_memory_manager_error\n  l     r3,&s.hfdaddr                 | Base on new HFD\n  using hfd,r3                        |\n  fill  0(r3),x'00',length=((r2),long) Set it all to zeros\n  st    r2,hfd_length                 | Set its length\n  mvc   hfd_line#,0(r5)               | Copy in the line number\n  sth   r6,hfd_#parms                 | Save # source parms\n  l32   r7,0(r4)                      | Load anchor word\n  if    z                             | If it's zero,\n*  *------------------------------------------------------------------*\n*  * Anchor word is zero: this is the first HFD on the chain.\n*  *------------------------------------------------------------------*\n   st    r3,0(r4)                     |  this is the first one.\n  else                                | Otherwise, we gotta link it in:\n   loop  until                        | Loop thru the HFD chain\n*   *-----------------------------------------------------------------*\n*   *   R3 points to the new HFD, and is based on it.\n*   *   R7 points to the current HFD.\n*   *   R8 points to the next HFD, and may contain zero.\n*   *-----------------------------------------------------------------*\n    l     r8,0(r7)                    | Get address of next HFD\n    if    (clc,hfd_line#,lt,hfd_line#-hfd(r7))\n*    *----------------------------------------------------------------*\n*    * New HFD's line number is less than the 'prior' HFD's, implying\n*    * that new HFD should be inserted ahead of 1st HFD on the chain.\n*    *----------------------------------------------------------------*\n     st    r7,0(r3)                   | Set old 1st HFD link in new HFD\n     st    r3,0(r4)                   | Reset anchor -> new HFD\n     leave loop=*                     | That's it.\n    elseif (treg,r8,z)                | Elseif no 'next' HFD\n*    *----------------------------------------------------------------*\n*    * We ran the chain without finding a place for this HFD, and the\n*    * first check covered the case of the new HFD's linenumber being\n*    * less than that of the only HFD on the chain.  Therefore, the\n*    * new HFD should go on the end of the chain.\n*    *----------------------------------------------------------------*\n     st    r3,0(r7)                   | Hang new HFD after last one\n     leave loop=*                     |  and leave the loop.\n    elseif     (clc,hfd_line#,lt,hfd_line#-hfd(r8)),and,  Else if be-  *\n               (clc,hfd_line#,gt,hfd_line#-hfd(r7))       tween 2 HFDs\n*    *----------------------------------------------------------------*\n*    * New HFD's line number is between that of prior and current HFD.\n*    * Insert the new HFD between them.\n*    *----------------------------------------------------------------*\n     st    r8,0(r3)                   |  Link new HFD to next one,\n     st    r3,0(r7)                   |  link current HFD to new one,\n     leave loop=*                     |   and get out.\n    elseif (eq)                       | There's an error if they match:\n*    *----------------------------------------------------------------*\n*    * The HFD line number matches either the prior or current HFD's.\n*    * This is an ERROR: we're outta here.  R3, R7, R8 point to the\n*    * new, current and next HFDs respectively.\n*    *----------------------------------------------------------------*\n     errexit code=&pl_internal_error  | This is one of those that   @cz\n    endif                             |   should never happen!!!\n    lr    r7,r8                       |  Update prior HFD address\n   endloop until,leave                | Loop until we're done.\n  endif                               |\n  lr    r1,r3                         | Set new HFD address\n  strsa r1                            |  in caller's R1.\n  drop  r3                            |\n endblk                               |\n         space 1                      |\n         swa   ,                      |\n&s.hfdaddr  ds a                      |\n&s.length   ds a                      |\n         endswa ,                     |\n eject                                |\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Destroy_HFD\n*  Purpose:    Track down an HFD, unlink it from the HFD chain it's on,\n*              and release its storage.\n*  Parameters: On entry, R1 points to the following parameter list:\n*                +0 -- Address of HFD anchor\n*                +4 -- Address of fullword line number for header.\n*                      If the line number provided is zero, ALL HFD's\n*                      chained from the anchor will be deleted.\n*  Returned:   R15 will be nonzero if the HFD wasn't found.\n*  Calls:      Memory Manager (external)\n*\n*---------------------------------------------------------------------*\n         SPACE 1                      |\n block name=Destroy_HFD,type=subroutine\n  lm    r4,r5,0(r1)                   | Get parm addresses\n  l     r3,0(r4)                      | Load HFD anchor: -> HFD or zero\n  using hfd,r3                        |\n  l     r6,0(r5)                      | Get line number for compares\n  lr    r7,r4                         | Copy HFD anchor address\n         space 1                      |\n  loop  until                         |\n*  *------------------------------------------------------------------*\n*  *   R3 points to the 1st HFD, and is based on it.\n*  *   R6 contains the line number to compare for, or zero.\n*  *   R7 points to the current HFD.\n*  *   R8 points to the next HFD, and may contain zero.\n*  *------------------------------------------------------------------*\n   l     r8,0(r7)                     | Get address of first | next HFD\n   if    (treg,r8,z)                  | If we reached end of chain\n    leave loop=*                      |  leave the loop\n   elseif      (treg,r6,z),or,        | Else if deleting them all or   *\n               (c,r6,eq,hfd_line#-hfd(r8)) we found the one we want:\n*   *-----------------------------------------------------------------*\n*   * We found the HFD we wanna delete.  Copy its link to the previous\n*   * HFD's link (which will be the anchor word if this is the first\n*   * HFD on the chain), then release the HFD's storage.\n*   *-----------------------------------------------------------------*\n    mvc   0(4,r7),0(r8)               |  Move this HFD's link to prev\n    st    r8,&s.hfdaddr               |  Save address of stg to release\n    MM_Release_Storage ID=MM,         |  Blow it away                  *\n               Size=hfd_length-hfd(,r8),                               *\n               Address=&s.hfdaddr     |\n    leave loop=*,(treg,r6,nz)         | If only zapping one, get out.\n   endif                              |\n*  *------------------------------------------------------------------*\n*  * If we are deleting one HFD, continue looping through the HFD chain\n*  * until we nuke the one we're after.  If we're deleting all HFDs,\n*  * each 'delete' will take the 1st one off the chain and update the\n*  * anchor word, so we reload the anchor address into R7 instead of\n*  * the next HFD address.\n*  *------------------------------------------------------------------*\n   if    (treg,r6,nz)                 | If doing a single HFD\n    lr    r7,r8                       |  Copy next HFD addr to current\n   else                               | Otherwise (we're doing 'em all)\n    lr    r7,r4                       |  Point \"next HFD\" R7 to anchor.\n   endif                              |\n  endloop until,leave                 |\n        space 1                       |\n  if           (treg,r8,z),and,       | If we missed it and we weren't *\n               (treg,r6,nz)           |  deleting them all\n   la    r15,8                        |  Set 'not-found' returncode\n  else                                | Otherwise\n   xr    r15,r15                      |  Say we did it all OK.\n  endif                               |\n  drop  r3                            |\n endblk rc=(r15)                      |\n        space 1                       |\n        swa   ,                       |\n&s.hfdaddr  ds f                      |\n        endswa ,                      |\n eject                                |\n*---------------------------------------------------------------------*\n*\n*  Subroutine: Find_HFD\n*  Purpose:    Find an HFD and return its address to the caller via R1.\n*  Parameters: On entry, R1 points to the following parameter list:\n*                +0 -- Address of HFD anchor\n*                +4 -- Address of fullword line number for header.\n*  Returned:   R15 will be nonzero if the HFD wasn't found.\n*  Calls:      None\n*\n*---------------------------------------------------------------------*\n         SPACE 1                      |\n block name=Find_HFD,type=subroutine  |\n  lm    r4,r5,0(r1)                   | Get parm addresses\n  l     r6,0(r5)                      | Get line number\n  l     r3,0(r4)                      | Load HFD anchor: -> HFD or zero\n  using hfd,r3                        |\n  loop  while,(treg,r3,nz)            | Look for matching line#'s\n   leave loop=*,(c,r6,eq,hfd_line#)   |  Hop out if we got one,\n   l     r3,hfd_link                  | else look at the next one.\n  endloop while                       |\n  if    (treg,r3,nz)                  | If we got a hit\n   lr    r1,r3                        |  Give address to caller via R1\n   strsa r1                           |\n   xr    r15,r15                      |  and set RC zero\n  else                                | Otherwise,\n   la    r15,8                        |  set RC 8.\n  endif                               |\n  drop  r3                            |\n endblk rc=(r15)                      |\n eject                                |\n*---------------------------------------------------------------------*\n*\n*  Errexit:    Unnamed\n*  Purpose:    Save debugging information and exit with the return\n*              code pointed to by r14 at entry to this exit.\n*\n*---------------------------------------------------------------------*\n         SPACE 1                      |\n block type=errexit                   |\n* *-------------------------------------------------------------------*\n* * Save module/offset, registers, return-code.\n* *-------------------------------------------------------------------*\n  st    r15,pwa_reason                | Save possible return-code.\n  stm   r0,r15,gdiregs                | Save registers at time of error\n  sm_lal r0,&srv_modname+4            | Point to module identification.\n  st    r0,gdimodid                   | Save in general debug area.\n  mvc   gdirc,0(r14)                  | Copy return code.\n  sl    r14,=a(&srv_modname)          | Calculate offset at time of err\n  sth   r14,gdioffst                  | Save in debug area.\n  l     r2,pwaaesv                    | Point r2 to ESV.\n  using esv,r2                        | Establish base for ESV.\n  callx esvesepa,(esvestkn,&es_save_debug_info,&es_debug_id_gdi,gdi)\n* *-------------------------------------------------------------------*\n* * Look at the error code.  Some errors imply that the DIV Server\n* * has lost its cookies and should not attempt to do anything other\n* * than shut-down (if it can even do that).\n* *-------------------------------------------------------------------*\n  lh    r15,gdirc                     | Get return code.\n  caseblk reg=r15,mult=1              | Case on return-code.\n*   case x\n*     callx esvesepa,(esvestkn,&es_save_debug_info,\n*              &es_debug_id_hex,pwa_reason,4,\"REASON\",6)\n    case other                        |  Don't bother w/other errors.\n  endcase                             | EndCase.\n  drop r2                             |\n* *-------------------------------------------------------------------*\n* * Set the return-code and exit.\n* *-------------------------------------------------------------------*\n  lh    r15,gdirc                     | Set return code.\n endblk                               |\n eject                                |\n*---------------------------------------------------------------------*\n*\n*  Subroutine: writeline\n*  Purpose:    Splits the specified line according to the maximum\n*              printable length so that message wrapping can occur.\n*              (Created in response to incident V1499)\n*  Parameters: On entry, R1 points to the following parameter list:\n*                +0 -- address of the data to print\n*                +4 -- length of the data to print\n*                +8 -- print header/footer flag\n*\n*---------------------------------------------------------------------*\n block name=writeline,type=subroutine                               @C2\n  mvi   &w.f,x'00'                    | Clear local flag byte.\n  lm    r2,r4,0(r1)                   |                             @C2\n  st    r2,&w.pos_start               | save the address of the line@C2\n  st    r2,&w.pos_start_mark          | keep starting address marker@C2\n  l     r3,0(,r3)                     | r3 := length                @C2\n  st    r3,&w.length                  | save line length            @C2\n  lh    r4,0(,r4)                     | r5 := print header/footer   @C2\n  if   (ch,r4,eq,psd_dont_print_headers)                            @C2\n   sbit &w.f,&w.f_no_headers          |  don't print headers/footers@C2\n  endif                               |                             @C2\n  l     r1,&w.pos_start               | r1 := starting position     @C2\n  al    r1,pwa_buffer_size            | r1 := end of print line buff@C2\n  st    r1,&w.pos_end                 | save end position           @C2\n  st    r1,&w.pos_current             | prime current position      @C2\n  rbit  &w.f,&w.f_add_cc              | make sure add CC bit is off @C2\n* *-------------------------------------------------------------------*\n* *  bypass wrapping code if the line doesn't need wrapping         @C2\n* *-------------------------------------------------------------------*\n  if    (clc,&w.length,le,pwa_maxlinesize)  if len < max print len  @C2\n   if    (tbit,&w.f,&w.f_no_headers,off)     want to print headers? @C2\n    callsub Count_Print_Lines,(*&w.pos_start)                       @C2\n    if    (treg,r15,nz)               |      if needed?             @C2\n     if    (ch,r15,eq,=h'4')          | If page overflow            @C2\n      callsub print_footers           |  Do controlled page-eject   @C2\n     endif                            | Endif                       @C2\n     if    (tbit,pwaf1hdr,off)        | If page now needs a header  @C2\n      callsub print_headers           |  Give it one.               @C2\n     endif                            | Endif                       @C2\n     callsub Count_Print_Lines,(*&w.pos_start) Better count'em again@C2\n    endif                             |                             @C2\n   else                               |                             @C2\n    callsub Count_Print_Lines,(*&w.pos_start)                       @C2\n   endif                              |                             @C2\n   fi_writeline id=fi,                | write the line              @C2+\n               line=(*&w.pos_start,&w.length)                       @C2\n   st     r15,pwa_fi_last_rc          | Save return code.           @C2\n   errexit not,(%fi_success),code=&pl_file_handler_error            @C2\n   leave block=*                      | return to the caller        @C2\n  endif                               |                             @C2\n* *-------------------------------------------------------------------*\n* *  Find the middle position of the string                         @C2\n* *-------------------------------------------------------------------*\n  sr   r8,r8                          | clear r8                    @C2\n  l    r9,pwa_maxlinesize             | r9 := dividend              @C2\n  d    r8,=f'2'                       | r9 := pwa_maxlinesize / 2   @C2\n  st   r9,&w.middlemax                | save middle                 @C2\n* *-------------------------------------------------------------------*\n* *  loop through the string wrapping print lines that are too long @C2\n* *-------------------------------------------------------------------*\n  loop until                          | loop until completly wrapped@C2\n*  *------------------------------------------------------------------*\n*  *  Find the offset to the middle of the string                   @C2\n*  *------------------------------------------------------------------*\n   l    r1,&w.pos_start               | r1 -> pos_start             @C2\n   al   r1,&w.middlemax               | r1 := pos_start + middlemax @C2\n   st   r1,&w.pos_middle              | save the middle position    @C2\n*  *------------------------------------------------------------------*\n*  *  Add control characters if needed                              @C2\n*  *------------------------------------------------------------------*\n   if    (tbit,&w.f,&w.f_add_cc,on)   | if we need CC character     @C2\n    l     r1,&w.pos_start             |  r1 -> start position       @C2\n    bctr  r1,0                        |  r1 := position - 1 for CC  @C2\n    st    r1,&w.pos_start             |  save adjusted start pos    @C2\n    mvc   0(1,r1),=c' '               |  set CC at start position   @C2\n    l     r1,&w.length                |  r1 := length remaining     @C2\n    al    r1,=f'1'                    |  r1 := length + 1 for CC    @C2\n    st    r1,&w.length                |  save the adjusted length   @C2\n   endif                              | endif                       @C2\n*  *------------------------------------------------------------------*\n*  *  See if we need to wrap this line                              @C2\n*  *------------------------------------------------------------------*\n   if    (clc,&w.length,le,pwa_maxlinesize)  if len < max print len @C2\n    mvc   &w.print_length,&w.length   |  set print length           @C2\n    mvc   &w.length,=f'0'             |  set remaining length to 0  @C2\n   else                               | else line needs to wrap     @C2\n*   *-----------------------------------------------------------------*\n*   *  Save the address of the current line print boundary          @C2\n*   *-----------------------------------------------------------------*\n    l     r1,&w.pos_start             |  r1 := starting position    @C2\n    al    r1,pwa_maxlinesize          |  r1 -> start + max line len @C2\n    st    r1,&w.pos_current           |  save current postion       @C2\n    st    r1,&w.pos_line_end          |  save line end postion      @C2\n*   *-----------------------------------------------------------------*\n*   *  Loop over string until we find whitespace or hit start pos   @C2\n*   *-----------------------------------------------------------------*\n    loop until                        |  loop over string.          @C2\n     l     r1,&w.pos_current          |   r1 := current position    @C2\n     leave loop=*,(clc,0(1,r1),eq,=c' '), leave if curr char = space@C2+\n               and,(cl,r1,gt,&w.pos_start), and not at start pos    @C2+\n               or,(cl,r1,le,&w.pos_start)   or at start             @C2\n     bctr  r1,0                       |   r1 := current position-1  @C2\n     st    r1,&w.pos_current          |   save new current position @C2\n    endloop until,leave               |  endloop.                   @C2\n*   *-----------------------------------------------------------------*\n*   *  Adjust current pointer back to line end if it is at start    @C2\n*   *-----------------------------------------------------------------*\n    if    (clc,&w.pos_current,lt,&w.pos_middle)                     @C2\n     mvc   &w.pos_current,&w.pos_line_end                           @C2\n    endif                             |                             @C2\n*   *-----------------------------------------------------------------*\n*   *  Calculate the print length (must be in range 2=<len<=max)    @C2\n*   *-----------------------------------------------------------------*\n    l     r1,&w.pos_current           |  r1 -> current position     @C2\n    sl    r1,&w.pos_start             |  r1 := current - start      @C2\n    st    r1,&w.print_length          |   save print length         @C2\n    if   (clc,&w.print_length,le,=f'2')                             @C2\n     mvc  &w.print_length,pwa_maxlinesize                           @C2\n     mvc  &w.pos_current,&w.pos_line_end                            @C2\n    endif                                                           @C2\n*   *-----------------------------------------------------------------*\n*   *  Calculate the remaining string length                        @C2\n*   *-----------------------------------------------------------------*\n    l     r1,&w.length                |  r1 := string length        @C2\n    sl    r1,&w.print_length          |  r1 := str len - prt len    @C2\n    st    r1,&w.length                |  save the new string length @C2\n    sbit  &w.f,&w.f_add_cc            |  next line needs CC inserted@C2\n   endif                              | endif                       @C2\n*  *------------------------------------------------------------------*\n*  *  Write the line and count the lines                            @C2\n*  *------------------------------------------------------------------*\n   if (tbit,&w.f,&w.f_no_headers,off) | Do we want to print headers @C2\n    callsub Count_Print_Lines,(*&w.pos_start)                       @C2\n    if    (treg,r15,nz)               |      if needed?             @C2\n     if    (ch,r15,eq,=h'4')          | If page overflow            @C2\n      callsub print_footers           |  Do controlled page-eject   @C2\n     endif                            |                             @C2\n     if    (tbit,pwaf1hdr,off)        | If page now needs a header  @C2\n      callsub print_headers           |  Give it one.               @C2\n     endif                            |                             @C2\n     callsub Count_Print_Lines,(*&w.pos_start) Better count'em again@C2\n    endif                             |                             @C2\n   else                               |                             @C2\n    callsub Count_Print_Lines,(*&w.pos_start)                       @C2\n   endif                              |                             @C2\n   errexit (clc,&w.pos_start,ge,&w.pos_end)                         @C2\n   fi_writeline id=fi,                |                             @C2+\n               line=(*&w.pos_start,&w.print_length)                 @C2\n   st     r15,pwa_fi_last_rc          | Save return code.           @C2\n   errexit not,(%fi_success),code=&pl_file_handler_error            @C2\n*  *------------------------------------------------------------------*\n*  *  Calculate the next starting address                           @C2\n*  *------------------------------------------------------------------*\n   mvc   &w.pos_start,&w.pos_current  | set next starting position  @C2\n   leave loop=*,(clc,&w.pos_start,ge,&w.pos_end),or,            do  @C2+\n               (clc,&w.pos_start,le,&w.pos_start_mark),or,    sanity@C2+\n               (clc,&w.length,le,=f'0')                     checking@C2\n*  *------------------------------------------------------------------*\n*  *  remove leading whitespace characters from the continued line  @C2\n*  *------------------------------------------------------------------*\n   loop until                         | loop over string.           @C2\n    l     r1,&w.pos_start             |  r1 := start position       @C2\n    leave loop=*,(clc,0(1,r1),ne,=c' '), leave if curr char\u00ac=space  @C2+\n               or,(cl,r1,ge,&w.pos_end)   or we are at the end      @C2\n    al    r1,=f'1'                    |  r1 := current position + 1 @C2\n    st    r1,&w.pos_start             |  save new start position    @C2\n    l     r1,&w.length                |  r1 := length remaining     @C2\n    sl    r1,=f'1'                    |  r1 := length - 1           @C2\n    st    r1,&w.length                |  save the adjusted length   @C2\n   endloop until,leave                | endloop.                    @C2\n  endloop until,leave                 |                             @C2\n endblk                               |                             @C2\n         swa                          |                             @C2\n&w.pos_start    ds    a               | address of start position   @C2\n&w.pos_start_mark ds  a               | address of start position   @C2\n&w.pos_current  ds    a               | address of current position @C2\n&w.pos_middle   ds    a               | address of middle position  @C2\n&w.pos_end      ds    a               | address of end position     @C2\n&w.pos_line_end ds    a               | address of end position     @C2\n&w.pos_last     ds    a               | address of last position    @C2\n&w.print_length ds    f               | print length of the line    @C2\n&w.length       ds    f               | remaining length to print   @C2\n&w.middlemax    ds    f               | middle position             @C2\n&w.f            ds    bl1             | writeline flags             @C2\n&w.f_add_cc     equ   b'10000000'     | add CC character flag       @C2\n&w.f_no_headers equ   b'01000000'     | don't print headers&footers @C2\n         endswa                       |                             @C2\n eject                                |\n*---------------------------------------------------------------------*\n*\n*  Subroutine: clear_buffer\n*  Purpose:    clears large buffers with spaces\n*  Parameters: On entry, R1 points to the following parameter list:\n*                +0 -- address of the buffer to clear\n*                +4 -- length to clear\n*\n*---------------------------------------------------------------------*\n block name=clear_buffer,type=subroutine                            @C2\n  l     r2,0(,r1)                     | r2 -> address of buffer     @C2\n  l     r3,4(,r1)                     | r3 -> address of the length @C2\n  l     r3,0(,r3)                     | r3 := length to clear       @C2\n  loop until                          | loop                        @C2\n   if (treg,r3,p)                     |  if length > 0              @C2\n    if (c,r3,le,=f'256')              |   if length <= 256          @C2\n     mvi   0(r2),x'40'                |    blank first character    @C2\n     bctr  r3,0                       |    r3 := length - 1         @C2\n     if (treg,r3,p)                   |    if length > 0            @C2\n      bctr  r3,0                      |     r3 := length - 1 for EX @C2\n      exi   r3,(mvc,1(*-*,r2),0(r2))  |     propogate fill character@C2\n     endif                            |    endif                    @C2\n     leave loop=*                     |    return to caller         @C2\n    else                              |   else length > 256         @C2\n     mvi   0(r2),x'40'                |    blank first character    @C2\n     mvc   1(255,r2),0(r2)            |    propogate fill character @C2\n     s     r3,=f'256'                 |    r3 := length - 256       @C2\n     la    r2,256(,r2)                |    r2 := buffer addr + 256  @C2\n    endif                             |   endif                     @C2\n   else                               |  else length <= 0           @C2\n    leave loop=*                      |   return to caller          @C2\n   endif                              |  endif                      @C2\n  endloop until,leave                 | endloop                     @C2\n endblk                               |                             @C2\n eject                                |                             @C2\n*---------------------------------------------------------------------*\n*\n*  Subroutine: copy_buffer\n*  Purpose:    copy data to a large data buffer\n*  Parameters: On entry, R1 points to the following parameter list:\n*                +0 -- address of the destination buffer\n*                +4 -- address of the source to copy from\n*                +8 -- length of data to copy\n*\n*---------------------------------------------------------------------*\n block name=copy_buffer,type=subroutine                             @C2\n  l     r2,0(,r1)                     | r2 -> address of buffer     @C2\n  l     r3,4(,r1)                     | r3 -> address of source     @C2\n  l     r4,8(,r1)                     | r4 -> address of the length @C2\n  l     r4,0(,r4)                     | r4 := length to copy        @C2\n  loop until                          | loop                        @C2\n   if (treg,r4,p)                     |  if length > 0              @C2\n    if (c,r4,le,=f'256')              |   if length <= 256          @C2\n     bctr  r4,0                       |    r3 := length - 1 for EX  @C2\n     exi   r4,(mvc,0(*-*,r2),0(r3))   |    copy data chunk          @C2\n     leave loop=*                     |    return to caller         @C2\n    else                              |   else length > 256         @C2\n     mvc   0(256,r2),0(r3)            |    copy data chunk          @C2\n     s     r4,=f'256'                 |    r3 := length - 256       @C2\n     la    r2,256(,r2)                |    r2 := buffer addr + 256  @C2\n     la    r3,256(,r3)                |    r3 := source addr + 256  @C2\n    endif                             |   endif                     @C2\n   else                               |  else length <= 0           @C2\n    leave loop=*                      |   return to caller          @C2\n   endif                              |  endif                      @C2\n  endloop until,leave                 | endloop                     @C2\n endblk                               |                             @C2\n eject                                |                             @C2\n*---------------------------------------------------------------------*\n*\n*  Subroutine: upcase_buffer\n*  Purpose:    translate the data buffer to all uppercase characters\n*  Parameters: On entry, R1 points to the following parameter list:\n*                +0 -- address of the buffer\n*                +4 -- length to translate\n*\n*---------------------------------------------------------------------*\n block name=upcase_buffer,type=subroutine                           @C2\n  l     r2,0(,r1)                     | r2 -> address of buffer     @C2\n  l     r3,4(,r1)                     | r3 -> address of the length @C2\n  l     r3,0(,r3)                     | r3 := length to clear       @C2\n  loop until                          | loop                        @C2\n   if (treg,r3,p)                     |  if length > 0              @C2\n    if (c,r3,le,=f'256')              |   if length <= 256          @C2\n     bctr  r3,0                       |    r3 := length - 1 for EX  @C2\n     exi   r3,(tr,0(*-*,r2),psd_fold_table)  translate to uppercase @C2\n     leave loop=*                     |    return to caller         @C2\n    else                              |   else length > 256         @C2\n     tr    0(256,r2),psd_fold_table   |    translate to uppercase   @C2\n     s     r3,=f'256'                 |    r3 := length - 256       @C2\n     la    r2,256(,r2)                |    r2 := buffer addr + 256  @C2\n    endif                             |   endif                     @C2\n   else                               |  else length <= 0           @C2\n    leave loop=*                      |   return to caller          @C2\n   endif                              |  endif                      @C2\n  endloop until,leave                 | endloop                     @C2\n endblk                               |                             @C2\n eject                                |                             @C2\n*---------------------------------------------------------------------*\n title \"Program Static Data\"          |\n                psd                   |\neyecatcher      dc   cl8\"PL_SP\"       | Eyecatcher value for dumps.\npsd_print_headers      dc   h'0'                                    @C2\npsd_dont_print_headers dc   h'1'                                    @C2\npsd_bit_mask   dc   b'0001',b'0011',b'0111',b'1111'\npsd_force_eject dc  f'99999999'       |\npsd_skip_3_lines  dc   c'-'\npsd_skip_1_line   dc   c' '\n          space 1\npsd_fold_table   dc   256al1(*-psd_fold_table)\n                 org  psd_fold_table+c\"a\"\n                 dc   c'ABCDEFGHI'\n                 org  psd_fold_table+c\"j\"\n                 dc   c'JKLMNOPQR'\n                 org  psd_fold_table+c\"s\"\n                 dc   c'STUVWXYZ'\n                 org  ,\n          space 1\n                ltorg ,               |\n                endpsd                |\n*\n          title \"Dsects\"              |\n          pl_parmlist ,\n          es_esv ,                    |\n          eject ,                     |\n*---------------------------------------------------------------------*\n*\n*  DSECT:     Header/Footer Descriptor (HFD)\n*\n*  Purpose:   Describes headers and footers established by calls to\n*             PL_Set_Header, PL_Set_Formatted_Header, PL_Set_Footer\n*             and PL_Set_Formatted_Footer.\n*\n*  Service    . Create_HFD will allocate storage and partially initial-\n*  Routines:    ize an HFD.\n*             . Destroy_HFD will unlink an HFD and release its storage.\n*             . Find_HFD will locate an HFD based on the line number\n*               provided by PrintLine's caller.\n*\n*  Special    Fields marked by <1> are set by Create_HFD, based on\n*  Notes:     parms provided by the caller.\n*\n*---------------------------------------------------------------------*\nhfd       dsect ,                     | Header/Footer Descriptor DSECT\nhfd_link    ds  a                 <1> | Fwd link to next HFD or zero.\n*                                     | This must be the 1st field!\nhfd_iball   ds  cl4                   | Eyecatcher \"HEAD\"/\"FOOT\"\nhfd_length  ds  a                 <1> | Length of this HFD\nhfd_line#   ds  f                 <1> | Line number for this HFD\nhfd_string  ds  a                     | Addr of string or formatspec\nhfd_strlen  ds  a                     | Addr of length of str/fmtspec\nhfd_page#   ds  a                     | Address of page# if hfdf1pg# on\nhfdf1     ds    c                     | Flags:\nhfdf1hdr  equ   x'80'   |1... ....|   | . This HFD describes a header\nhfdf1fmt  equ   x'40'   |.1.. ....|   | . HFD_String describes fmtspec\nhfdf1pg#  equ   x'20'   |..1. ....|   | . This HFD has a page # assoc'd\n*         equ   x'1f'   |...1 1111|   | . Reserved\n            ds  c                     | Reserved\nhfd_#parms  ds  h                 <1> | No. of parms for formatter\nhfd_base_length equ   *-hfd           | Minimum HFD length\nhfd_sourcelist  equ   *               | 0 to 50 substitution parms\n          title \"Program Work Area\"   |\n               PWA                    |\npwa_area       ds    0f               | Beginning of visible PWA stg.\npwa_visual     ds    cl8              | Character string 'PL_SP'.\npwa_pl_id      ds    a                | Pointer to program work area.\npwa_clear_start equ  *                | This area cleared by PL_START.\npwa_ddname     ds    cl8              | DDname.\npwa_ES_epa     ds    f                | Environment Support EPA.\npwa_ES_token   ds    f                | Environment Support PWA token.\npwa_MM_epa     ds    f                | Memory Manager EPA.\npwa_MM_token   ds    f                | Memory Manager PWA token.\npwa_ST_epa     ds    f                | String Formatter EPA.\npwa_ST_token   ds    f                | String Formatter PWA token.\npwa_FI_epa     ds    f                | File Handler EPA.\npwa_FI_token   ds    f                | File Handler PWA token.\npwa_FI_last_rc ds    f                | File Handler last return code.\npwa_pagesize   ds    f                |\npwa_maxlinesize ds   f                | Max. linesize from PL_START\npwa_maxlinesize_adj  ds  f            | Adjusted max. linesize. Length\n*                                     |  is that spec'd by SizeLength.\npwa_sizelength ds    f                |\npwa_footer_size ds   f                | Footer space requested or zero\npwa_header_anchor ds f                | HFD anchor for headers\npwa_footer_anchor ds f                | HFD anchor for footers\npwa_line_count ds    f                | Current line count\npwa_page_count ds    f                | Current page count\npwa_reason     ds    f                |\npwa_size_mask  ds    f                | Mask to load lengths using ICM\npwa_clear_end  equ  *                 | End area cleared by PL_START.\npwa_clear_length   equ   pwa_clear_end-pwa_clear_start\npwa_ESV        ds    f                | Address of ESV.\npwa_number_of_parms ds h              | Number of parms.\npwaf1        ds    x                  | General flag byte:\npwaf1sft     equ   x'80'  |1... ....| | . String formatter truncated\npwaf1hdr     equ   x'40'  |.1.. ....| | . Header on this page\npwaf1wrap    equ   x'20'  |..1. ....| | . Line wrapping will occur  @C2\n*            equ   x'1f'  |...1 1111| | . Reserved                  @C2\npwatf        ds    x                  | Truncation flag:\npwatflin     equ   x'80'  |1... ....| | . Print line truncated\npwatfhdr     equ   x'40'  |.1.. ....| | . Header line truncated\npwatfftr     equ   x'20'  |..1. ....| | . Footer line truncated\n*            equ   x'1f'  |...1 1111| | . Reserved\npwaop        ds    x                  | OPTIONS flag:\npwaopfld     equ   x'80'  |1... ....| | . FOLD specified\n*            equ   x'7f'  |.111 1111| | . Reserved\npwa_result_length   ds f              | Result length from ST_FORMAT.\n*                                     |   Actual length is SizeLength.\npwa_sourceparm_count ds f             | Count of parms in sourcelist.\n*                                     |   Used by set_fmt_hdr, _ftr.\npwa_st_format_pl  ds    57a           | Parms for string formatter.\npwa_st_format_ple equ   *             |   END-OF-PARMLIST-AREA.\n               es_gdi dsect=no        | General debugging information.\npwa_print_len   ds    f               | Print size.\npwa_header_len  ds    f               | Footer size.\npwa_footer_len  ds    f               | Footer size.\npwa_buffer_size ds    f               | allocated buffer size\npwa_buffer_data ds    a               | buffer for data printing\npwa_buffer_data_len   ds f            | data print length\npwa_buffer_head ds    a               | buffer for header printing\npwa_buffer_head_len   ds f            | header print length\npwa_buffer_foot ds    a               | buffer for footer printing\npwa_buffer_foot_len   ds f            | footer print length\npwa_recfm       ds    cl8             | recfm of ddname\npwa_lrecl       ds    h               | lrecl of ddname\npwa_pl_reference ds   cl70            | Reference string for PL_START.\n               org pwa_pl_reference\npwa_pl_ref_part1 ds    c'DDNAME '\npwa_pl_ref_part2 ds    cl8\npwa_pl_ref_part3 ds    cl55\n               org   ,\n               endpwa                 |\n               end   ,                |\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SRVPLXRZ": {"ttr": 34052, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x02\\x00\\x00X\\x01\\x11)\\x9f\\x01\\x11)\\x9f\\t'\\x00\\xbf\\x00\\xbf\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@\"", "ispf": {"version": "02.00", "flags": 0, "createdate": "2011-10-26T00:00:00", "modifydate": "2011-10-26T09:27:58", "lines": 191, "newlines": 191, "modlines": 0, "user": "CLEMSON"}, "text": "*---------------------------------------------------------------------*\n*  Copyright 2011 by Clemson University Research Foundation           *\n*                                                                     *\n*  Licensed under the Apache License, Version 2.0 (the \"License\");    *\n*  you may not use this file except in compliance with the License.   *\n*  You may obtain a copy of the License in this library as member     *\n*  $LICENSE, or from                                                  *\n*                                                                     *\n*      http://www.apache.org/licenses/LICENSE-2.0                     *\n*                                                                     *\n*  Unless required by applicable law or agreed to in writing,         *\n*  software distributed under the License is distributed on an \"AS    *\n*  IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either    *\n*  express or implied.  See the License for the specific language     *\n*  governing permissions and limitations under the License.           *\n*---------------------------------------------------------------------*\n//SRVPLXRZ JOB TIME=(,6)\n/*JOBPARM LINES=9\n//  EXEC  ASMPCL,COPT=',RENT',LOPT=',RENT,REUS,REFR',\n//    PDS='SYSTEMS.SRV.LOAD',NAME=SRVPLXRZ,MAC=SYSTEMS\n//P.SYSIN  DD  *\n     SMLIST CONVERT=YES\nSRVPLXRZ     TITLE 'Exerciser For Print_Line Service Processor'\n*---------------------------------------------------------------------*\n*\n*  Copyright (C) 1989 Clemson University\n*\n*  Program     SRVPLXRZ\n*\n*  Abstract    xxx\n*              xxx\n*              xxx\n*\n*  Inputs:\n*      Parameters  xxxxx\n*      Files       xxxxx\n*      Other       None\n*\n*  Outputs:\n*      Returncodes xxxxx\n*      Messages    xxxxx\n*      Files       xxxxx\n*      Other       None\n*\n*  PROGRAM     Reentrant, problem key and state, standard linkage,\n*  ATTRIBUTES  non-authorized, AMODE(24), RMODE(24)\n*\n*  Special     xxx\n*  Notes       xxx\n*\n*  Change\n*  History     09/15/89 ___ - New\n*              __/__/__ ___\n*              __/__/__ ___\n*\n*  Method of   xxx\n*  Operation   xxx\n*\n*\n*---------------------------------------------------------------------*\n         EJECT\n     print off\n     copy  srvesmac\n     print on,gen\n     copy  srvplmac\n     eject\n block name=SRVPLXRZ,type=program,options=(*pwa,xa,mode,erraddr),      *\n               amode=31,                                               *\n               rmode=any\n     eject\n  es_id id=es,esva=pwa_esv_address,                                    +\n               spepa=pwa_es_epa,                                       +\n               sptoken=pwa_es_token\n     space 3\n  pl_id        id=pl,esva=pwa_esv_address,                             *\n               esid=es,                                                *\n               spepname=&PRINT_LINE,                                   *\n               spepa=pwa_epa,                                          *\n               sptoken=pwa_pl_token,                                   *\n               sizelength=3\n     eject\n  es_MVS_load id=ES\n  ES_Start id=ES\n  ES_Load_Module id=ES,spid=PL\n  errexit (treg,r15,nz)\n  PL_Start     ID=PL,                                                  *\n               DDNAME=stcddnam,                                        *\n               PageSize=60,                                            *\n               MaxLnSz=121,    options=fold,                           *\n               sizelength=3\n  errexit (treg,r15,nz)\n  PL_Set_Header ID=PL,                                                 *\n               Line=10,                                                *\n               string=stcheader1\n  errexit (treg,r15,nz)\n  PL_Set_Formatted_Header ID=PL,                                       *\n               Line=20,                                                *\n               control=\"  Header line 2. This page starts with line {I}*\n               , and is page {I}.\",                                    *\n               Pagenum=2,                                              *\n               Source=(pwa_counter,pwapage#)\n  errexit (treg,r15,nz)\n* PL_Reserve_Footer ID=PL,\n*              Lines=5\n* errexit (treg,r15,nz)\n* PL_Set_Footer ID=PL,\n*              Line=10,\n*              string=stcfooter1\n* errexit (treg,r15,nz)\n* PL_Set_Formatted_Footer ID=PL,\n*              Line=20,\n*              control=\"  Footer line 2. This page ends with line {I},\n*              and is page {I}.\",\n*              Pagenum=2,\n*              Source=(pwa_counter,pwapage#2)\n* errexit (treg,r15,nz)\n  la    r7,1\n  loop  until\n    st    r7,pwa_counter\n    pl_query_lines_left  id=PL,lines=pwa_lines_on_page\n    errexit  (treg,r15,nz)\n    if    (clc,pwa_lines_on_page,eq,=f'0')\n     pl_page_break id=PL\n*              string=\" This line should force a page eject.\"\n     pl_query_lines_left  id=PL,lines=pwa_lines_on_page\n     errexit  (treg,r15,nz)\n    endif\n    PL_Print_Formatted id=PL,                                          *\n               control=\" {I}:  There are {I} lines left on this page.\",*\n               Source=(pwa_counter,pwa_lines_on_page)\n    errexit (treg,r15,nz)\n    la    r7,1(r7)\n  endloop until,(ch,r7,gt,=h'200')\n     eject\n  PL_Terminate   ID=PL\n     eject\n endblk\n block type=errexit\n* *-------------------------------------------------------------------*\n* * Save module/offset, registers, return-code.\n* *-------------------------------------------------------------------*\n  st    r15,pwa_reason                | Save possible return-code.\n  stm   r0,r15,gdiregs                | Save registers at time of error\n  la    r0,4(,r12)                    | Point to module identification.\n  st    r0,gdimodid                   | Save in general debug area.\n  mvc   gdirc,0(r14)                  | Copy return code.\n  slr   r14,r12                       | Calculate offset at time of err\n  sth   r14,gdioffst                  | Save in debug area.\n  l     r2,pwa_esv_address            | Point r2 to ESV.\n  using esv,r2                        | Establish base for ESV.\n  callx esvesepa,(esvestkn,&es_save_debug_info,&es_debug_id_gdi,gdi)\n  es_display_debug_info_and_abend id=es\n endblk\n     psd   ,\nstcddnam dc   cl8'sysprint'\nstctestfmt  dc c\" This is data line number {I}, I think.\"\nstctestfmt2 dc c\" This is an associated data line with a different leng*\n               th.\"\nstcheader1  dc c\"1 Header line 1, which should cause a page eject.\"\nstcheader2  dc c\"  Header line 2, which should print below the first he*\n               ader line initially.\"\nstcheader2a dc c\" This is the inserted second header line, which should*\n                appear between header lines 1 and 3.\"\nstcheader3  dc c\"  Header line 3, which should follow header 2.\"\nstcfooter1  dc c\"0 Footer line 1, which should appear at the bottom of *\n               the current page.\"\nstcfooter2a dc c\" This is the inserted second footer line, which should*\n                appear between footer lines 1 and 3.\"\n     endpsd ,\n     es_esv ,\n     pwa   ,\npwa_reason  ds f\npwap1    ds    f\npwap2    ds    f\npwap3    ds    f\npwapage# ds    f\npwapage#2 ds   f\npwaline# ds    f\npwa_counter ds f\npwa_lines_on_page ds   f\npwa_esv_address   ds   f                     *\npwa_epa           ds   f                          *\npwa_es_epa        ds   f                          *\npwa_pl_token      ds   f\npwa_es_token      ds   f\n     es_gdi dsect=no\n     endpwa ,\n     end   ,\n//C.SYSLIB DD\n//         DD\n//         DD DSN=SYSTEMS.SRV.DONTEDIT,DISP=SHR\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SRVST": {"ttr": 34056, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x02\\x00\\x00X\\x01\\x11)\\x9f\\x01\\x11)\\x9f\\t'\\x07\\xe4\\x07\\xe4\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@\"", "ispf": {"version": "02.00", "flags": 0, "createdate": "2011-10-26T00:00:00", "modifydate": "2011-10-26T09:27:58", "lines": 2020, "newlines": 2020, "modlines": 0, "user": "CLEMSON"}, "text": "*---------------------------------------------------------------------*\n*  Copyright 2011 by Clemson University Research Foundation           *\n*                                                                     *\n*  Licensed under the Apache License, Version 2.0 (the \"License\");    *\n*  you may not use this file except in compliance with the License.   *\n*  You may obtain a copy of the License in this library as member     *\n*  $LICENSE, or from                                                  *\n*                                                                     *\n*      http://www.apache.org/licenses/LICENSE-2.0                     *\n*                                                                     *\n*  Unless required by applicable law or agreed to in writing,         *\n*  software distributed under the License is distributed on an \"AS    *\n*  IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either    *\n*  express or implied.  See the License for the specific language     *\n*  governing permissions and limitations under the License.           *\n*---------------------------------------------------------------------*\nSRVST     TITLE 'String Handler'\n         SRVMOD NAME=SRVST,DATES='1987, 1989, 1995'\n         gblc  &srv_modname\n*---------------------------------------------------------------------*\n*\n*  Copyright (C) Clemson University Research Foundation 1987, 1989.\n*\n*  Program     SRVST, String Handler\n*\n*  Abstract    This server provides common functions for string\n*              manipulation.  Because most high-level languages have\n*              string manipulation functions as part of their\n*              definition, the functions in this server are most useful\n*              for assembler language programs.\n*\n*  Parameters:\n*    Two parameters, StringTkn, and FunctionCode, are required for each\n*    call to the symbol manager.  Additional parameters are required\n*    for different FunctionCodes.  The entire parameter list required\n*    for each function is listed below.\n*\n*    START\n*      CALLX SRVST,(StringTkn,&START,ESV,SizeLength)\n*\n*    TERMINATE\n*      CALLX SRVST,(StringTkn,&TERMINATE)\n*\n*    FORMAT\n*      CALLX SRVST,(StringTkn,&ST_FORMAT,String,StringLen,ResultLen,\n*                    Control,ControlLen,Arg1,...)\n*   or CALLX SRVST,(StringTkn,&ST_FORMAT2,String,StringLen,ResultLen,\n*                    Control,ControlLen,ArgList,ArgCount)\n*\n*    CONVERSION FUNCTIONS\n*      CALLX SRVST,(StringTkn,&ST_STRING_TO_INTEGER,\n*                    String,StringLen,Integer)\n*      CALLX SRVST,(StringTkn,&ST_INTEGER_TO_STRING,\n*                    Integer,String,StringLen,ResultLen)\n*\n*  The meaning of each parameter is explained below.\n*\n*    StringTkn is a fullword used to identify the string session\n*      in progress.  It is initialized during the startup function.\n*\n*    FunctionCode is a fullword integer that specifies the function to\n*      be performed.  Symbolic identifiers are provided for each\n*      function and may be accessed by placing a COPY statement for\n*      SRVSTMAC in the assembler program.  These symbols should be\n*      used in place of actual integer values.  The following\n*      FunctionCodes are supported:\n*\n*      &START\n*        Begin a new string-handler session.  In addition to the\n*        StringTkn and FunctionCode parameters, the parameter ESV\n*        is required and the parameter SizeLength is optional.\n*\n*      &TERMINATE\n*        Terminate the string-handler session identified by StringTkn.\n*\n*      &FORMAT\n*        Build a formatted string based on control information and\n*        supplied arguments.  This function is most useful for\n*        processing messages and lines of output text files.\n*\n*      &STRING_TO_INTEGER\n*        Convert an integer literal to its equivalent fullword signed\n*        binary value.  The literal is an optional sign character\n*        ('+' or '-') followed by a sequence of digits.  Blanks\n*        appearing before or after the sign or digit-sequence are\n*        ignored.\n*\n*  SizeLength\n*    A fullword integer indicating the size, in bytes, of the length\n*    specifier for strings on which the service processor will operate.\n*    It must be 1, 2, 3, or 4 to designate byte, halfword, 3-byte, or\n*    fullword lengths.\n*\n*  String\n*    An area of storage for assembling a string to return to the\n*    calling program, or providing the source data for conversion\n*    from string data to some other data-type.\n*\n*  StringLen\n*    A unsigned <SizeLength> byte integer specifying the length of\n*    the String area.\n*\n*  ResultLen\n*    A an unsigned <SizeLength> byte integer set by the string-handler\n*    to indicate the length of the string returned in String.\n*\n*  Control\n*    A string containing text and imbedded format information that is\n*    used to control the formatting process.  The format information\n*    if used to determine how many Arg-n arguments are needed.\n*\n*  ControlLen\n*    A an unsigned <SizeLength> byte integer specifying the length of\n*    the control string.\n*\n*  Arg1, ...\n*    Data to be formatted.  The type and length of the data is\n*    specified in the control string.\n*\n*  ArgList\n*    References a separatly built variable-length parameter list that\n*    contains the arguments Arg1, Arg2, ....\n*\n*  ArgCount\n*    A fullword integer equal to the number of parameters in ArgList.\n*\n*  Integer\n*    A fullword signed binary integer value that is either input for\n*    a function (i.e. &ST_INTEGER_TO_STRING) or returned by a function\n*    (i.e. &ST_STRING_TO_INTEGER).\n*\n*  Program     reentrant, problem key and state, standard linkage,\n*  Attributes  non-authorized, amode(31), rmode(any)\n*\n*  Change\n*  History   2011/10/20 JCB - Patch rollup for CBT tape distribution\n*\n*---------------------------------------------------------------------\n EJECT\n*\n* COPY statements for SMSYMS, SRVESMAC, and SRVSTMAC.\n*\n PRINT   OFF\n   COPY  SMSYMS               | Copy Structured Macros symbols.\n   COPY  SMPUCOND             | Copy User-conditions.\n   COPY  SRVESMAC             | Copy Environment Support symbols.\n   COPY  SRVSTMAC             | Copy String Handler symbols.\n PRINT   ON\n EJECT\n*---------------------------------------------------------------------*\n* Main program - Uses the FunctionCode to invoke the right function.\n*---------------------------------------------------------------------*\n BLOCK NAME=&srv_modname,TYPE=PROGRAM,AMODE=31,RMODE=ANY,R1SAVE=R11,   +\n               OPTIONS=(*SRVPRC,NOVL,LONG),                            +\n               SUBOPTS=(*SWA,LOADBASE)\n   USING   PARMLIST,R11         | Establish addressability.\n   MVC     GDIRC,=H'0'          | Initialize the return-code.\n*---------------------------------------------------------------------*\n*  Count the number of parameters passed in.\n*---------------------------------------------------------------------*\n   LA   R1,PARMLIST                   | R1 -> first parameter.\n   LOOP WHILE,(TBIT,0(R1),X'80',OFF)  | Loop over parameters.\n     LA R1,4(,R1)                     |   Advance to next parameter.\n   ENDLOOP WHILE                      | EndLoop.\n   LA  R1,4(,R1)                      | Point past final parameter.\n   SLR R1,R11                         | Get length of entire parmlist.\n   SRL R1,2                           | Get number of parameters.\n   ST  R1,&PWA.#PARMS                 | Save in PWA for future use.\n*---------------------------------------------------------------------*\n*  Use the function code to determine what routine to invoke.\n*---------------------------------------------------------------------*\n   L       R1,PRM_FUNCTIONCODE  | Load the function code into\n   L       R1,0(,R1)            |   a register for testing.\n   CASEBLK REG=R1               | Case on FunctionCode.\n     CASE &START                |   Start a new string handler session.\n       CALLSUB START_STRING_HANDLER\n     CASE &TERMINATE            |   Destroy an existing symbol table.\n       SMCTRL FREEPWA=YES       |     Free the PWA on return.\n     CASE &ST_FORMAT,&ST_FORMAT2    Format a string for output.\n       CALLSUB FORMAT_STRING    |\n     CASE &ST_INTEGER_TO_STRING |   Convert a fullword to a string.\n       CALLSUB INTEGER_TO_STRING\n     CASE &ST_STRING_TO_INTEGER |   Convert a string to a fullword.\n       CALLSUB STRING_TO_INTEGER,     Invoke conversion function with: +\n               (*PRM_STI_STRING,        Source text of integer,        +\n               *PRM_STI_LENGTH,         Length of source text, and     +\n               *PRM_STI_INTEGER)        Return-integer area.\n       ERREXIT (TREG,R15,NZ),CODE=00  Errexit w/R15 as return-code.\n     CASE OTHER                 |   Invalid Function Code.\n       ERREXIT CODE=&ST_INVALID_FUNCTION\n   ENDCASE                      | EndCase.\n   LH   R15,GDIRC               | Pick up non-terminating RC.\n ENDBLK BLOCK=&srv_modname,RC=(R15)\n EJECT\n***********************************************************************\n*                                                                     *\n*  Subroutine: START_STRING_HANDLER                                   *\n*  Abstract:   Begin a new string handler session, establishing the   *\n*              size of string-length values (halfword lengths, etc).  *\n*                                                                     *\n***********************************************************************\n BLOCK TYPE=SUBROUTINE,NAME=START_STRING_HANDLER\n*---------------------------------------------------------------------*\n*  Process the optional SIZELENGTH parameter.\n*---------------------------------------------------------------------*\n   LA  R1,2                       | Default := halfword lengths.\n   IF  (CLC,&PWA.#PARMS,GE,=F'4') | If SizeLength parameter present.\n     L  R1,PRM_S_SIZELENGTH       |   R1 -> SizeLength's Value.\n     LA R1,0(,R1)                 |   Clear high-bit.\n     IF (TREG,R1,NZ)              |   If SizeLength specified.\n       L R1,0(R1)                 |     R1 := SizeLength's Value.\n       ERREXIT ((C,R1,LT,=F'1'),OR,(C,R1,GT,=F'4')),                   +\n               CODE=&ST_INVALID_SIZELENGTH\n     ENDIF                        |   EndIf.\n   ENDIF                          | EndIf.\n   ST R1,&PWA.SIZELENGTH          | Save sizelength's value.\n   S  R1,=F'1'                    | R1 := offset into bit-mask array.\n   LA R1,&PSD.BIT_MASK(R1)        | R1 -> bit-mask for ICM/STCM's.\n   L8 R0,0(R1)                    | R0 := bit-mask for ICM/STCM's.\n   ST R0,&PWA.SIZEMASK            | Save for getting/setting lengths.\n ENDBLK BLOCK=START_STRING_HANDLER\n EJECT\n***********************************************************************\n*                                                                     *\n*  Subroutine: FORMAT_STRING                                          *\n*  Abstract:   See \"Service Processors User's Guide and Reference\",   *\n*              ST_FORMAT function for a description of this routine.  *\n*                                                                     *\n***********************************************************************\n BLOCK NAME=FORMAT_STRING,TYPE=SUBROUTINE\n   L       R6,&PWA.#PARMS         | R6 := number of parameters passed.\n   ERREXIT (C,R6,LT,=F'7'),CODE=&ST_WRONG_NUMBER_OF_PARAMETERS\n*---------------------------------------------------------------------*\n*  Initialize PWA variables for tracking the Control string position.\n*---------------------------------------------------------------------*\n   L   R1,PRM_F_CONTROL           | R1 -> Control string.\n   L   R2,PRM_F_CONTROL_LEN       | R2 -> Control string's length.\n   SLR R3,R3                      | Clear for the ICM below.\n   L   R15,&PWA.SIZEMASK          | R15 := length-mask.\n   EXI R15,(ICM,R3,0,0(R2))       | R3 := Length of control string.\n   SL  R3,=F'1'                   | R3 := Offset to last byte.\n   ALR R3,R1                      | R3 -> Last byte.\n   ST  R1,&PWA.CONTROL_START      | Save start-of-control address.\n   ST  R1,&PWA.CONTROL_CURRENT    | Save current Control position.\n   ST  R3,&PWA.CONTROL_END        | Save end-of-control address.\n*---------------------------------------------------------------------*\n*  Initialize PWA variables for tracking the String position.\n*---------------------------------------------------------------------*\n   L   R1,PRM_F_STRING            | R1 -> target String.\n   L   R2,PRM_F_STRING_LEN        | R2 -> Length of target String.\n   SLR R3,R3                      | Clear R3 for ICM below.\n   L   R15,&PWA.SIZEMASK          | R15 := length-mask.\n   EXI R15,(ICM,R3,0,0(R2))       | R3 := Length of String area.\n   SL  R3,=F'1'                   | R3 := Offset to last byte.\n   ALR R3,R1                      | R3 -> Last byte.\n   ST  R1,&PWA.STRING_START       | Save start-of-String address.\n   ST  R1,&PWA.STRING_CURRENT     | Save Current String position.\n   ST  R1,&PWA.STRING_HIGHWATER   | Save Highwater String position.\n   ST  R3,&PWA.STRING_END         | Save End of String address.\n*---------------------------------------------------------------------*\n*  Initialize PWA variables for tracking the current Argument.\n*---------------------------------------------------------------------*\n   L   R1,PRM_FUNCTIONCODE            | R1 -> Function code passed in.\n   L   R1,0(,R1)                      | R1 := Function code.\n*                                     |\n   S   R6,=F'7'                       | R6 := #parms after control_len.\n   IF  (TREG,R6,NP)                   | If no <argument>s passed in.\n     SLR  R7,R7                       |   R7 -> null parameter list.\n   ELSEIF (C,R1,EQ,=F'&ST_FORMAT')    | ElseIf FORMAT parmlist.\n     LA   R7,PRM_F_ARGLIST            |   R7 -> First argument.\n   ELSEIF (C,R1,EQ,=F'&ST_FORMAT2')   | ElseIf FORMAT2 parmlist.\n     IF (C,R6,NE,=F'2')               |   If ArgCount is missing.\n       ERREXIT CODE=&ST_WRONG_NUMBER_OF_PARAMETERS\n     ELSE                             |   Else.\n       L   R6,PRM_F_ARGCOUNT          |     R6 -> Number of arguments.\n       IF  (TREG,R6,NZ)               |     If parameter not missing.\n         L  R6,0(,R6)                 |       R6 := number <arguments>.\n       ENDIF                          |     EndIf.\n       L   R7,PRM_F_ARGLIST           |     R7 -> First argument.\n     ENDIF                            |   EndIf.\n   ENDIF                              | EndIf.\n*                                     |\n   STM R6,R7,&PWA.ARGUMENT_LIST       | Save <arg> count/address.\n   EJECT\n*---------------------------------------------------------------------*\n*  Loop over the Control string to produce the result in String.\n*---------------------------------------------------------------------*\n   LOOP UNTIL                     | Loop over control string.\n     L       R2,&PWA.CONTROL_CURRENT            R2 -> Current txt.\n     LEAVE   LOOP=*,(C,R2,GT,&PWA.CONTROL_END)  Done if @ end.\n     CALLSUB FIND_CONTROL_CHARACTER,('{',&W.TEXT_LENGTH)\n     L       R3,&W.TEXT_LENGTH    |             R3 := Length to '{'.\n     CALLSUB COPY_TO_STRING,((R2),(R3))         Copy text.\n     ALR     R2,R3                |             R2 -> Format-spec.\n     ST      R2,&PWA.CONTROL_CURRENT            Update Current pos.\n     LEAVE   LOOP=*,(C,R2,GT,&PWA.CONTROL_END)  Done if @ end.\n     CALLSUB PROCESS_FORMAT_SPECIFICATION       Format data.\n   ENDLOOP UNTIL,LEAVE            | EndLoop.\n   L   R2,&PWA.STRING_HIGHWATER   | R2 := Last byte formatted, + 1.\n   SL  R2,&PWA.STRING_START       | R2 := Length formatted.\n   L   R1,PRM_F_FMT_LEN           | R1 -> Formatted string length parm.\n   IF  (TREG,R1,NZ)               | If parameter is not missing.\n     L   R15,&PWA.SIZEMASK        |   R15 := length-mask.\n     EXI R15,(STCM,R2,0,0(R1))    |   Save as target string's length.\n   ENDIF                          | EndIf.\n ENDBLK BLOCK=FORMAT_STRING\n*---------------------------------------------------------------------*\n* Working storage for the ST_FORMAT function.\n*---------------------------------------------------------------------*\n                SWA\n&W.TEXT_LENGTH  DS    F    | Length of text up to format-specification.\n                ENDSWA\n                EJECT\n**********************************************************************\n*                                                                    *\n*  Subroutine: FIND_CONTROL_CHARACTER,(Char,OffsetFromCurrent)       *\n*  Abstract:   Using the &PWA.CONTROL_xxx markers, scan the Control  *\n*              string from the current position towards the end to   *\n*              locate the next occurance of the specified character. *\n*              Return the offset from &PWA.CONTROL_CURRENT to the    *\n*              located character. (The offset can also be thought of *\n*              as the length of the Control string's text up to the  *\n*              character).  If the character is not found, it will   *\n*              be assumed to magically have been appended to the end *\n*              of the Control string.                                *\n*                                                                    *\n**********************************************************************\n BLOCK TYPE=SUBROUTINE,NAME=FIND_CONTROL_CHARACTER\n   LM    R8,R9,0(R1)                | R8->Char, R9->OffsetFromCurrent.\n*---------------------------------------------------------------------*\n*  Point R1 (via the TRT instruction) to the next control character\n*  or past the end of the entire control string if there is not one.\n*---------------------------------------------------------------------*\n   L     R7,&PWA.CONTROL_CURRENT    | R7 -> Current Control position.\n   L     R6,&PWA.CONTROL_END        | R6 -> Last control byte.\n*\n*  Scan loop below does the same thing as the TRTs below.  It\n*  is shorter, but is it faster? NO! STROBE SAYS IT TAKES LONGER.\n*\n*  LR    R1,R7                      | R1 -> CURRENT CONTROL CHARACTER.\n*  LOOP  WHILE,(CR,R1,LE,R6),AND,(CLC,0(1,R1),NE,0(R8))\n*   LA   R1,1(,R1)                  |\n*  ENDLOOP WHILE                    |\n*  SLR   R1,R7                      | R1 := OFFSETFROMCURRENT.\n*  ST    R1,0(,R9)                  | SAVE IN CALLER'S PARM.\n*  LEAVE BLOCK=*                    | RETURN TO CALLER.\n*\n   SR    R6,R7                      | R6 := length remaining - 1.\n   LA    R6,1(,R6)                  | R6 := Length remaining.\n   LR    R5,R7                      | R5 -> Current control character.\n   L8    R4,0(R8)                   | R4 := Desired character.\n   LA    R4,&PWA.TRANTAB(R4)        | R4 -> Table position.\n   MVI   0(R4),X'FF'                | Flag as character we want.\n   LOOP  WHILE,(C,R6,GT,=F'256')    | Scan in 256-byte chunks.\n     TRT   0(256,R5),&PWA.TRANTAB   |   Scan for wanted character.\n     LEAVE LOOP=*,NZ                |   Exit if found.\n     A     R5,=F'256'               |   Advance to next 256-byte chunk.\n     S     R6,=F'256'               |   Subtract length covered.\n   ENDLOOP WHILE                    | EndLoop.\n   IF (C,R6,LE,=F'256')             | If Char was NOT found,\n     BCTR R6,0                      |   Subtract 1 for the EX instr.\n     EXI  R6,(TRT,0(0,R5),&PWA.TRANTAB) Scan for wanted Char.\n     IF   Z,THEN                    |   If NOT found then\n       L  R1,&PWA.CONTROL_END       |     R1 -> last byte in control.\n       A  R1,=F'1'                  |     R1 -> past end of control.\n     ENDIF                          |   EndIf.\n   ENDIF                            | EndIf.\n   MVI   0(R4),X'00'                | Reset translate table character.\n*---------------------------------------------------------------------*\n*  Calculate the offset from &PWA.CONTROL_CURRENT to 0(R1) and return.\n*---------------------------------------------------------------------*\n   SLR  R1,R7                       | R1 := Offset to '{' character.\n   ST   R1,0(,R9)                   | Save as OffsetFromCurrent.\n ENDBLK BLOCK=FIND_CONTROL_CHARACTER\n EJECT\n**********************************************************************\n*                                                                    *\n*  Subroutine: PROCESS_FORMAT_SPECIFICATION                          *\n*  Abstract:   When this routine is called, &PWA.CONTROL_CURRENT     *\n*              points to the start of a format specification.  This  *\n*              routine decodes the entire specification, updates     *\n*              &PWA.CONTROL_CURRENT to the position following the    *\n*              format specification, and then performs the indicated *\n*              formatting function.                                  *\n*                                                                    *\n**********************************************************************\n BLOCK NAME=PROCESS_FORMAT_SPECIFICATION,TYPE=SUBROUTINE\n   L       R8,&PWA.CONTROL_CURRENT       | R8 -> Current position.\n   LA      R8,1(,R8)                     | R8 -> Past initial '{' char.\n   ERREXIT (CL,R8,GT,&PWA.CONTROL_END),CODE=&ST_FORMAT_SPEC_NOT_ENDED\n   ST      R8,&PWA.FS_CURRENT            | Set current fmt-spec pos.\n*---------------------------------------------------------------------*\n*  If it is the special format specification '{{', process it now.\n*---------------------------------------------------------------------*\n   IF (CLI,0(R8),EQ,C'{')                | If spec is equal to '{{'.\n     LA      R7,1                        |   R7 := length to copy.\n     CALLSUB COPY_TO_STRING,((R8),(R7))  |   Copy 1 '{'.\n     LA      R8,1(,R8)                   |   R8 -> Past '{{'.\n     ST      R8,&PWA.CONTROL_CURRENT     |   Update Control position.\n     LEAVE   BLOCK=*                     |   Return to caller.\n   ENDIF                                 | EndIf.\n*--------------------------------------------------------------------*\n*  Find the end of the format specification and decode its contents.\n*---------------------------------------------------------------------*\n   CALLSUB FIND_CONTROL_CHARACTER,('}',&PWA.FS_LENGTH)\n   L       R9,&PWA.CONTROL_CURRENT       | R9 -> '{' character.\n   AL      R9,&PWA.FS_LENGTH             | R9 -> '}' character.\n   ERREXIT (CL,R9,GT,&PWA.CONTROL_END),CODE=&ST_FORMAT_SPEC_NOT_ENDED\n   BCTR    R9,0                          | R9 -> Before final '}' char.\n   ST      R9,&PWA.FS_END                | Save end of spec position.\n   MVI     &PWA.FS_FIELDS,X'00'          | No fields specified so far.\n*                                        |\n   CALLSUB GETFMT_LEADING_PAD            | Scan leading '0' field.\n   CALLSUB GETFMT_WIDTH                  | Scan width field.\n   CALLSUB GETFMT_PRECISION              | Scan .precision field.\n   CALLSUB GETFMT_COLUMN                 | Scan @column field.\n   CALLSUB GETFMT_TYPE                   | Scan Type field.\n   CALLSUB GETFMT_LENGTH                 | Scan Length field.\n   CALLSUB GETFMT_MULTIPLE               | Scan Multiple field.\n   CALLSUB GETFMT_KEYWORDS               | Scan Keywords field.\n*                                        |\n   LA      R8,2(,R9)                     | R8 -> Past '}' character.\n   ST      R8,&PWA.CONTROL_CURRENT       | Update Control position.\n*---------------------------------------------------------------------*\n*  Check to make sure that things were specified right.\n*---------------------------------------------------------------------*\n   IF (TBIT,&PWA.FS_FIELDS,&PWA.FSF_TYPE,OFF)  | If type not specified.\n     IF (CLI,&PWA.FS_FIELDS,EQ,X'00')          |   If nothing there.\n       ERREXIT CODE=&ST_FORMAT_SPEC_EMPTY      |     Invalid fmt-spec.\n     ELSEIF (CLI,&PWA.FS_FIELDS,NE,&PWA.FSF_COLUMN) If not {@column}.\n       ERREXIT CODE=&ST_FORMAT_TYPE_REQUIRED   |     Invalid fmt-spec.\n     ENDIF                                     |   EndIf.\n   ENDIF                                       | EndIf.\n*---------------------------------------------------------------------*\n*  Perform column-adjustment based on the @column format specification.\n*---------------------------------------------------------------------*\n   CALLSUB ADJUST_COLUMN_POSITION\n   LEAVE   BLOCK=*,(CLI,&PWA.FS_FIELDS,EQ,&PWA.FSF_COLUMN)\n*---------------------------------------------------------------------*\n*  Set the default justification if needed.\n*---------------------------------------------------------------------*\n   L32   R7,&PWA.FSV_TYPE              | R7 := Type-index.\n   USING TYPE_ENTRY,R7                 | Establish addressability.\n   IF (CLI,&PWA.FSV_LEFT,NE,C'Y'),AND,(CLI,&PWA.FSV_RIGHT,NE,C'Y'),    +\n               AND,(CLI,&PWA.FSV_CENTER,NE,C'Y')\n    IF (CLI,TE_JUSTIFY,EQ,C'R')\n     MVI &PWA.FSV_RIGHT,C'Y'\n    ELSEIF (CLI,TE_JUSTIFY,EQ,C'C')\n     MVI &PWA.FSV_CENTER,C'Y'\n    ELSE\n     MVI &PWA.FSV_LEFT,C'Y'\n    ENDIF\n   ENDIF                               | EndIf.\n*---------------------------------------------------------------------*\n*  Format the source argument(s).\n*---------------------------------------------------------------------*\n   L32    R15,TE_ROUTINE               | R15 -> Formatting routine.\n   BASR   R14,R15                      | Format source data.\n*\n   IF (TBIT,&PWA.FS_FIELDS,&PWA.FSF_MULTIPLE,ON)\n    L    R2,&PWA.FSV_MULTIPLE          |  r2 := #elements.\n    LOOP UNTIL                         |  Loop over elements.\n     S     R2,=F'1'                    |   Just did one.\n     LEAVE LOOP=*,(NP)                 |   Done if no more.\n     L     R0,&PWA.FSV_SOURCE          |   r0 -> source address.\n     A     R0,&PWA.FSV_LENGTH          |   r0 -> next source element.\n     ST    R0,&PWA.FSV_SOURCE          |   Update source address.\n     IF (CLI,&PWA.FSV_CSV,EQ,C'Y')     |   If CSV requested.\n      LA      R3,1                     |       Set length to 1.\n      CALLSUB COPY_TO_STRING,(',',(R3)),NOVL   Insert comma.\n     ENDIF                             |   EndIf.\n     L32   R15,TE_ROUTINE              |   R15 -> Formatting routine.\n     BASR  R14,R15                     |   Format source data.\n    ENDLOOP UNTIL,LEAVE                |  EndLoop over elements.\n   ENDIF                               | EndIf (multiple)\n*\n ENDBLK BLOCK=PROCESS_FORMAT_SPECIFICATION\n EJECT\n**********************************************************************\n*                                                                    *\n*  Subroutine: GETFMT_LEADING_PAD                                    *\n*  Abstract:   Obtain the leading pad character.                     *\n*                                                                    *\n**********************************************************************\n BLOCK TYPE=SUBROUTINE,NAME=GETFMT_LEADING_PAD\n   L       R8,&PWA.FS_CURRENT          | R8->Current. R9->Limit.\n   LEAVE   BLOCK=*,(C,R8,GT,&PWA.FS_END) Return if past end.\n*                                      |\n   MVI &PWA.FSV_LEADING_PAD,C' '       | Set default pad character.\n   IF  (CLI,0(R8),EQ,C'0')             | If padding with zeros.\n     LA   R8,1(,R8)                    |   Point past the '0'.\n     ST   R8,&PWA.FS_CURRENT           |   Update current position.\n     MVI  &PWA.FSV_LEADING_PAD,C'0'    |   Set pad character.\n     SBIT &PWA.FS_FIELDS,&PWA.FSF_LEADING_PAD\n   ENDIF                               | EndIf.\n ENDBLK BLOCK=GETFMT_LEADING_PAD       |\n**********************************************************************\n*                                                                    *\n*  Subroutine: GETFMT_WIDTH                                          *\n*  Abstract:   Obtain the width field of a format-specification.     *\n*                                                                    *\n**********************************************************************\n BLOCK TYPE=SUBROUTINE,NAME=GETFMT_WIDTH\n   L       R8,&PWA.FS_CURRENT              | R8->Current. R9->Limit.\n   LEAVE   BLOCK=*,(C,R8,GT,&PWA.FS_END)   | Return if past end.\n   CALLSUB GETFMT_INTEGER,(&PWA.FSV_WIDTH) | Parse <digits> or '?'.\n   IF (TREG,R15,Z)                         | If a value was obtained.\n     SBIT &PWA.FS_FIELDS,&PWA.FSF_WIDTH    |   Width was specified.\n   ELSE                                    | Else not specified.\n     MVC  &PWA.FSV_WIDTH,=F'0'             |   Set default width.\n   ENDIF                                   | EndIf.\n ENDBLK BLOCK=GETFMT_WIDTH\n**********************************************************************\n*                                                                    *\n*  Subroutine: GETFMT_PRECISION                                      *\n*  Abstract:   Obtain the precision field of a format-specification. *\n*                                                                    *\n**********************************************************************\n BLOCK TYPE=SUBROUTINE,NAME=GETFMT_PRECISION\n   L       R8,&PWA.FS_CURRENT              | R8->Current. R9->Limit.\n   LEAVE   BLOCK=*,(C,R8,GT,&PWA.FS_END)   | Return if past end.\n   LEAVE   BLOCK=*,(CLI,0(R8),NE,C'.')     | Leave if no .precision.\n   SBIT    &PWA.FS_FIELDS,&PWA.FSF_PRECISION .precision was specified.\n   LA      R8,1(,R8)                       | Advance past the '.'.\n   ST      R8,&PWA.FS_CURRENT              | Update current position.\n*\n   CALLSUB GETFMT_INTEGER,(&PWA.FSV_PRECISION)\n   ERREXIT (TREG,R15,NZ),CODE=&ST_FORMAT_MISSING_PRECISION_VALUE\n   L32     R1,&PWA.FSV_PRECISION\n   ERREXIT NP,CODE=&ST_FORMAT_PRECISION_TOO_SMALL\n ENDBLK BLOCK=GETFMT_PRECISION\n EJECT\n**********************************************************************\n*                                                                    *\n*  Subroutine: GETFMT_COLUMN                                         *\n*  Abstract:   Obtain the column field of a format-specification.    *\n*                                                                    *\n**********************************************************************\n BLOCK TYPE=SUBROUTINE,NAME=GETFMT_COLUMN\n   L       R8,&PWA.FS_CURRENT              | R8->Current. R9->Limit.\n   LEAVE   BLOCK=*,(C,R8,GT,&PWA.FS_END)   | Return if past end.\n   LEAVE   BLOCK=*,(CLI,0(R8),NE,C'@')     | Return if @column \u00acthere.\n   SBIT    &PWA.FS_FIELDS,&PWA.FSF_COLUMN  | @column field is present.\n   MVI     &PWA.FSV_COLUMN,C'@'            | Default = EndOfString.\n   LA      R8,1(,R8)                       | Advance to next char.\n   ST      R8,&PWA.FS_CURRENT              | Update current position.\n   LEAVE   BLOCK=*,(C,R8,GT,&PWA.FS_END)   | Leave if past end.\n*                                          |\n   IF (CLI,0(R8),EQ,C'+'),OR,(CLI,0(R8),EQ,C'-')\n     MVC   &PWA.FSV_COLUMN(1),0(R8)        |   Relative Column#.\n     LA    R8,1(,R8)                       |   Advance to next char.\n     ST    R8,&PWA.FS_CURRENT              |   Update current position.\n   ENDIF                                   | EndIf.\n*                                          |\n   CALLSUB GETFMT_INTEGER,(&PWA.FSV_COLUMN+1)\n*                                          |\n   IF (TREG,R15,NZ)                        | If no value was specified.\n     IF (CLI,&PWA.FSV_COLUMN,NE,C'@')      |   If +/- was specified.\n       ERREXIT CODE=&ST_FORMAT_MISSING_COLUMN_VALUE\n     ENDIF                                 |   EndIf.\n   ELSEIF (CLI,&PWA.FSV_COLUMN,EQ,C'@')    | ElseIf not relative col#.\n     MVI &PWA.FSV_COLUMN,C'='              |   Set to absolute column#.\n   ENDIF                                   | EndIf.\n ENDBLK BLOCK=GETFMT_COLUMN\n EJECT\n**********************************************************************\n*                                                                    *\n*  Subroutine: GETFMT_TYPE                                           *\n*  Abstract:   Obtain the type field of a format-specification.      *\n*                                                                    *\n**********************************************************************\n BLOCK TYPE=SUBROUTINE,NAME=GETFMT_TYPE\n   L       R8,&PWA.FS_CURRENT              | R8->Current. R9->Limit.\n   LEAVE   BLOCK=*,(C,R8,GT,&PWA.FS_END)   | Leave if past end.\n   SBIT    &PWA.FS_FIELDS,&PWA.FSF_TYPE    | Type *must* be there.\n*                                          |\n   LM     R15,R1,=A(&PSD.TYPES-TYPE_ENTRY_L,TYPE_ENTRY_L,&PSD.TYPES_E)\n   USING  TYPE_ENTRY,R15                   | Establish addressability.\n   LOOP   BXH,R15,R0                       | Loop over valid types.\n     LEAVE LOOP=*,(CLC,TE_CHAR,EQ,0(R8))   |   Leave if valid type.\n   ENDLOOP BXH                             | EndLoop.\n   ERREXIT (CR,R15,GT,R1),CODE=&ST_FORMAT_UNSUPPORTED_TYPE\n   STCM    R15,B'1111',&PWA.FSV_TYPE       | Save type's entry address.\n*                                          |\n   IF (CLI,&PWA.FSV_LEADING_PAD,EQ,C'0')   | If leading pad = '0'.\n     IF (C,R15,NE,=A(&PSD.TYPE_I)),AND,    |   If not signed-integer or+\n               (C,R15,NE,=A(&PSD.TYPE_U)),AND,   unsigned-integer or   +\n               (C,R15,NE,=A(&PSD.TYPE_A))  |     address.\n       ERREXIT CODE=&ST_FORMAT_PAD_TYPE_CONFLICT   Illegal pad-char.\n     ENDIF                                 |   EndIf.\n   ENDIF                                   | EndIf.\n*                                          |\n   LM R2,R3,&PWA.ARGUMENT_LIST             | R2:=count, R3->current.\n   IF (TREG,R2,NP),OR,(TREG,R3,Z),THEN     | If no more <arguments>.\n     ERREXIT CODE=&ST_FORMAT_MISSING_ARGUMENT  Exit with error code.\n   ENDIF                                   | EndIf.\n   MVC     &PWA.FSV_SOURCE,0(R3)           | Copy <argument> address.\n   LA      R3,4(,R3)                       | Point to next <argument>.\n   BCTR    R2,0                            | Subtract 1 from count.\n   STM     R2,R3,&PWA.ARGUMENT_LIST        | Update current arg.\n*                                          |\n   LA      R8,1(,R8)                       | Advance to next char.\n   ST      R8,&PWA.FS_CURRENT              | Update current position.\n ENDBLK BLOCK=GETFMT_TYPE\n EJECT\n**********************************************************************\n*                                                                    *\n*  Subroutine: GETFMT_LENGTH                                         *\n*  Abstract:   Obtain the length field of a format-specification.    *\n*                                                                    *\n**********************************************************************\n BLOCK TYPE=SUBROUTINE,NAME=GETFMT_LENGTH\n   L     R8,&PWA.FS_CURRENT                  | R8->Current. R9->Limit.\n   L32   R7,&PWA.FSV_TYPE                    | R7 -> Type Entry.\n   USING TYPE_ENTRY,R7                       | Get addressability.\n   MVC   &PWA.FSV_LENGTH,TE_DEFAULT          | Set default length.\n   LEAVE BLOCK=*,((C,R8,GT,&PWA.FS_END),OR,(CLI,0(R8),NE,C'L'))\n*                                            |\n   SBIT    &PWA.FS_FIELDS,&PWA.FSF_LENGTH    | Llength was specified.\n   LA      R8,1(,R8)                         | Advance past the 'L'.\n   ST      R8,&PWA.FS_CURRENT                | Update position.\n   CALLSUB GETFMT_INTEGER,(&PWA.FSV_LENGTH)  | Obtain integer value.\n   ERREXIT (TREG,R15,NZ),CODE=&ST_FORMAT_MISSING_LENGTH_VALUE\n   L32     R1,&PWA.FSV_LENGTH                | R1 := Specified len.\n   ERREXIT M,CODE=&ST_FORMAT_LENGTH_TOO_SMALL\n   ERREXIT (CLM,R1,B'1111',LT,TE_MIN),CODE=&ST_FORMAT_LENGTH_TOO_SMALL\n   ERREXIT (CLM,R1,B'1111',GT,TE_MAX),CODE=&ST_FORMAT_LENGTH_TOO_LARGE\n ENDBLK BLOCK=GETFMT_LENGTH\n EJECT\n**********************************************************************\n*                                                                    *\n*  Subroutine: GETFMT_MULTIPLE                                       *\n*  Abstract:   Obtain the multiple field of a format-specification.  *\n*                                                                    *\n**********************************************************************\n BLOCK TYPE=SUBROUTINE,NAME=GETFMT_MULTIPLE\n   L     R8,&PWA.FS_CURRENT                  | R8->Current. R9->Limit.\n   L32   R7,&PWA.FSV_TYPE                    | R7 -> Type Entry.\n   USING TYPE_ENTRY,R7                       | Get addressability.\n   LEAVE BLOCK=*,((C,R8,GT,&PWA.FS_END),OR,(CLI,0(R8),NE,C'M'))\n*                                            |\n   SBIT    &PWA.FS_FIELDS,&PWA.FSF_MULTIPLE  | Mmultiple was specified.\n   LA      R8,1(,R8)                         | Advance past the 'M'.\n   ST      R8,&PWA.FS_CURRENT                | Update position.\n   CALLSUB GETFMT_INTEGER,(&PWA.FSV_MULTIPLE)  Obtain integer value.\n   ERREXIT (TREG,R15,NZ),CODE=&ST_FORMAT_MISSING_MULTIPLE_VALUE\n   L32     R1,&PWA.FSV_MULTIPLE              | R1 := Specified len.\n   ERREXIT M,CODE=&ST_FORMAT_MULTIPLE_TOO_SMALL\n ENDBLK BLOCK=GETFMT_MULTIPLE\n EJECT\n**********************************************************************\n*                                                                    *\n*  Subroutine: GETFMT_KEYWORDS                                       *\n*  Abstract:   Obtain the keywords field of a format-specification.  *\n*                                                                    *\n**********************************************************************\n BLOCK TYPE=SUBROUTINE,NAME=GETFMT_KEYWORDS\n   FILL  &PWA.FSV_KEYWORDS,C'N',LENGTH=(&PWA.FSV_KEYWORDS_LEN,S)\n   L     R8,&PWA.FS_CURRENT              | R8->Current position.\n   LEAVE BLOCK=*,(C,R8,GT,&PWA.FS_END)   | Leave if past end.\n*                                        |\n   IF (CLI,0(R8),NE,C' '),THEN           | If no blank after TYPE.\n     ERREXIT CODE=&ST_FORMAT_UNSUPPORTED_ITEM\n   ENDIF                                 | EndIf.\n   LA   R8,1(,R8)                        | Advance past 1st blank.\n*                                        |\n   LOOP NAME=KWD_LOOP,WHILE,(C,R8,LE,&PWA.FS_END)\n     LOOP WHILE,(CLI,0(R8),EQ,C' ')      |   Scan for a non-blank.\n       LA    R8,1(,R8)                   |     Advance to next char.\n       LEAVE LOOP=KWD_LOOP,(C,R8,GT,&PWA.FS_END)\n     ENDLOOP WHILE                       |   EndLoop.\n     SBIT  &PWA.FS_FIELDS,&PWA.FSF_KEYWORDS  At least one KWD.\n*                                        |\n     LR   R7,R8                          |   Use R7 to find end-of-kwd.\n     LOOP WHILE,(C,R7,LE,&PWA.FS_END)    |   Scan for a delimiter.\n       L8    R1,0(R7)                    |     R1 := actual character.\n       LA    R1,CLASSIFICATION(R1)       |     R1 -> char's class.\n       LEAVE LOOP=*,(CLI,0(R1),EQ,DELIMITER)   Leave if delimiter.\n       LA    R7,1(,R7)                   |     Advance to next char.\n     ENDLOOP WHILE                       |   EndLoop.\n     SLR     R7,R8                       |   R7 := keyword's length.\n     ERREXIT (TREG,R7,NP),CODE=&ST_FORMAT_UNSUPPORTED_ITEM\n*                                        |\n     LA   R14,GFK_TABLE                  |   R14 -> Keyword table.\n     LR   R15,R7                         |   Use R15 for Executed\n     BCTR R15,0                          |     comparison instructions.\n     LOOP WHILE,(CLC,=X'00',NE,2(R14))   |   Loop over keywords.\n       IF (C,R7,LE,=F'256'),AND,(CLM,R7,B'0001',EQ,2(R14))\n         EXI   R15,(CLC,0(0,R8),3(R14))  |     Compare keyword entry.\n         LEAVE LOOP=*,EQ                 |     Leave loop if match.\n       ENDIF                             |   EndIf.\n       L8    R1,2(R14)                   |   R1 := keyword's length.\n       LA    R14,3(R1,R14)               |   R14 -> Next table entry.\n     ENDLOOP WHILE                       |   EndLoop.\n*                                        |\n     ERREXIT (CLI,2(R14),EQ,X'00'),CODE=&ST_FORMAT_UNSUPPORTED_KEYWORD\n     L16 R1,0(R14)                       |   R1 := keyword offset\n     LA  R1,&PWA.FSV_KEYWORDS(R1)        |   R1 -> keyword's flag.\n     MVI 0(R1),C'Y'                      |   Set keyword's flag.\n     LA R8,0(R7,R8)                      |   Advance past the word.\n     ST R8,&PWA.FS_CURRENT               |   Save current position.\n*                                        |\n     IF (CLI,&PWA.FSV_FILL,EQ,C'Y')      |   If FILL keyword\n       CALLSUB GETFMT_FILL_OPERANDS      |     Get optional operand(s).\n       L       R8,&PWA.FS_CURRENT        |     Obtain new position.\n       IF      (%L32,R1,&PWA.FSV_FILL_LENGTH,NP)  If no valid filler.\n         MVC &PWA.FSV_FILL_LENGTH,=F'2'  |          Set default filler\n         MVC &PWA.FSV_FILL_VALUE(2),=C' .'          to FILL( .)\n       ENDIF                             |        EndIf.\n     ENDIF                               |   EndIf.\n   ENDLOOP WHILE                         | EndLoop.\n   ST R8,&PWA.FS_CURRENT                 | Save current position.\n*  *------------------------------------------------------------------*\n*  * LEFT, RIGHT and CENTER are mutually exclusive.\n*  *------------------------------------------------------------------*\n   IF (CLI,&PWA.FSV_LEFT,EQ,C'Y')\n    IF (CLI,&PWA.FSV_CENTER,EQ,C'Y'),OR,(CLI,&PWA.FSV_RIGHT,EQ,C'Y')\n     ERREXIT CODE=&ST_FORMAT_KEYWORD_CONFLICT  |   Not allowed.\n    ENDIF\n   ELSEIF (CLI,&PWA.FSV_RIGHT,EQ,C'Y')\n    IF (CLI,&PWA.FSV_CENTER,EQ,C'Y'),OR,(CLI,&PWA.FSV_LEFT,EQ,C'Y')\n     ERREXIT CODE=&ST_FORMAT_KEYWORD_CONFLICT  |   Not allowed.\n    ENDIF\n   ELSEIF (CLI,&PWA.FSV_CENTER,EQ,C'Y')\n    IF (CLI,&PWA.FSV_LEFT,EQ,C'Y'),OR,(CLI,&PWA.FSV_RIGHT,EQ,C'Y')\n     ERREXIT CODE=&ST_FORMAT_KEYWORD_CONFLICT  |   Not allowed.\n    ENDIF\n   ENDIF\n*  *------------------------------------------------------------------*\n*  * RIGHT and CENTER are not allowed with MULTIPLE or CSV.\n*  *------------------------------------------------------------------*\n   IF (CLI,&PWA.FSV_CENTER,EQ,C'Y'),OR,(CLI,&PWA.FSV_RIGHT,EQ,C'Y')\n    IF (TBIT,&PWA.FS_FIELDS,&PWA.FSF_MULTIPLE,ON)\n     ERREXIT CODE=&ST_FORMAT_MULTIPLE_NOT_ALLOWED  Not allowed.\n    ENDIF\n    IF (CLI,&PWA.FSV_CSV,EQ,C'Y'),OR,(CLI,&PWA.FSV_QST,EQ,C'Y')\n     ERREXIT CODE=&ST_FORMAT_KEYWORD_CONFLICT   |   Not allowed.\n    ENDIF\n   ENDIF\n*  *------------------------------------------------------------------*\n*  * QST only valid for type character.\n*  *------------------------------------------------------------------*\n   L32   R7,&PWA.FSV_TYPE              | R7 := Type-index.\n   USING TYPE_ENTRY,R7                 | Establish addressability.\n   IF (CLI,&PWA.FSV_QST,EQ,C'Y'),AND,(CLI,TE_CHAR,NE,C'C')\n    ERREXIT CODE=&ST_FORMAT_QST_TYPE_CONFLICT\n   ENDIF\n   DROP R7\n ENDBLK BLOCK=GETFMT_KEYWORDS\n EJECT\n*---------------------------------------------------------------------*\n*  Local static data for a keyword-table.\n*---------------------------------------------------------------------*\n           SSD\n           MACRO\n&LABEL     KEYWORD &OFFSET,&STRING\n           AIF  ('&STRING' EQ '').NULLSTR\n&LABEL     DC   AL2(&OFFSET)\n           DC   AL1(L'STR&SYSNDX)\nSTR&SYSNDX DC   C&STRING\n           MEXIT\n.NULLSTR   ANOP\n&LABEL     DC   AL2(0),AL1(0)\n           MEND\nGFK_TABLE  DS   0X\n           KEYWORD &PWA.FSV_LEFT-&PWA.FSV_KEYWORDS,'LEFT'\n           KEYWORD &PWA.FSV_RIGHT-&PWA.FSV_KEYWORDS,'RIGHT'\n           KEYWORD &PWA.FSV_TRIM-&PWA.FSV_KEYWORDS,'TRIM'\n           KEYWORD &PWA.FSV_TRIM-&PWA.FSV_KEYWORDS,'T'\n           KEYWORD &PWA.FSV_RELATIVE-&PWA.FSV_KEYWORDS,'RELATIVE'\n           KEYWORD &PWA.FSV_RELATIVE-&PWA.FSV_KEYWORDS,'REL'\n           KEYWORD &PWA.FSV_RELATIVE-&PWA.FSV_KEYWORDS,'R'\n           KEYWORD &PWA.FSV_CAPS-&PWA.FSV_KEYWORDS,'CAPITALIZE'\n           KEYWORD &PWA.FSV_CAPS-&PWA.FSV_KEYWORDS,'CAPS'\n           KEYWORD &PWA.FSV_C1ST-&PWA.FSV_KEYWORDS,'C1ST'\n           KEYWORD &PWA.FSV_CENTER-&PWA.FSV_KEYWORDS,'CENTER'\n           KEYWORD &PWA.FSV_FILL-&PWA.FSV_KEYWORDS,'FILL'\n           KEYWORD &PWA.FSV_FILL-&PWA.FSV_KEYWORDS,'F'\n           KEYWORD &PWA.FSV_CSV-&PWA.FSV_KEYWORDS,'CSV'\n           KEYWORD &PWA.FSV_QST-&PWA.FSV_KEYWORDS,'QST'\n           KEYWORD 0\n           ENDSSD\n           EJECT\n**********************************************************************\n*                                                                    *\n* Subroutine : GETFMT_FILL_OPERANDS                                  *\n* Abstract   : Scan from Current up to (but not including) End to    *\n*              extract any operands to the FILL keyword in a         *\n*              format-specification.  The syntax being parsed is     *\n*              FILL\u00dd(string)\u00a8  where                                 *\n*                                                                    *\n*                string => word                                      *\n*                        | ?\u00ddL\u00dd1 | nn | ?\u00a8\u00a8 /* default length: 1 */  *\n*                        | \u00ddC|X\u00a8\"string\"    /* default type  : C */  *\n*                word   => any character sequence that does not look *\n*                          like anything else.                       *\n*                                                                    *\n*              Either single or double quotes may be used to delimit *\n*              string, so long as they are matched properly.  If a   *\n*              quote of the same type as the delimiter is used w/in  *\n*              the string, two quotes must be used to represent one. *\n*                                                                    *\n*              The maximum length for a fill value from any source   *\n*              is 256 bytes.  A zero-length filler is replaced by    *\n*              the default fill string: \" .\".                        *\n*                                                                    *\n**********************************************************************\n BLOCK NAME=GETFMT_FILL_OPERANDS,TYPE=SUBROUTINE\n   L      R8,&PWA.FS_CURRENT             | R8->Current position.\n   LEAVE  BLOCK=*,(C,R8,GT,&PWA.FS_END)  | Leave if past end.\n   LEAVE  BLOCK=*,(CLI,0(R8),NE,C'(')    | Leave if no operands.\n*                                        |\n   LA   R8,1(,R8)                        | R8 -> Past opening paren.\n   LA   R7,0(,R8)                        | Use R7 to find non-blank.\n   LOOP WHILE,(C,R7,LE,&PWA.FS_END)      | Scan for a non-blank.\n     LEAVE LOOP=*,(CLI,0(R7),NE,C' ')    |   Leave if one found.\n     LA    R7,1(,R7)                     |   Advance to next char.\n   ENDLOOP WHILE                         | EndLoop.\n   LA   R6,1(,R7)                        | Use R6 to find end-of-fill.\n   LOOP WHILE,(C,R6,LE,&PWA.FS_END)      | Scan for a closing paren.\n     LEAVE LOOP=*,(CLI,0(R6),EQ,C')')    |   Leave if one found.\n     LA    R6,1(,R6)                     |   Advance to next char.\n   ENDLOOP WHILE                         | EndLoop.\n   ERREXIT (C,R6,GT,&PWA.FS_END),CODE=&ST_FORMAT_SPEC_NOT_ENDED\n*                                        |\n   BLOCK NAME=FILL_QUOTE,TYPE=INLINE     | Begin quoted-string checks.\n     LR  R5,R7                           |   r5 -> 1st nonblank.\n     IF  (CLI,0(R5),EQ,C'C')             |   If character = \"C\"\n       LA    R5,1(,R5)                   |     Advance 1 position.\n     ENDIF                               |   EndIf.\n     LEAVE BLOCK=*,(CR,R5,GE,R6)         |   Leave if not quoted-string\n     LEAVE BLOCK=*,(CLI,0(R5),NE,C''''),AND,(CLI,0(R5),NE,C'\"')\n     LA    R4,1(,R5)                     |   R4 -> 1st char past quote\n     LA    R3,&PWA.FSV_FILL_VALUE        |   R3 -> Current value posn.\n     LA    R2,L'&PWA.FSV_FILL_VALUE-1(R3)    R2 -> Value Limit.\n     LOOP  UNTIL                         |   Loop over quoted string.\n       LEAVE BLOCK=*,(CR,R4,GE,R6)       |     Leave if not ended.\n       IF (CLC,0(1,R4),EQ,0(R5))         |     If char = opening-quote\n         LA    R4,1(,R4)                 |       R4 -> Next char.\n         LEAVE LOOP=*,(CR,R4,GE,R6),OR,(CLC,0(1,R4),NE,0(R5))\n       ENDIF                             |     EndIf\n       ERREXIT (CR,R3,GT,R2),CODE=&ST_FORMAT_FILL_TOO_LONG\n       MVC   0(1,R3),0(R4)               |     Copy one character.\n       LA    R3,1(,R3)                   |     R3 -> Next value posn.\n       LA    R4,1(,R4)                   |     R4 -> Next source char.\n     ENDLOOP UNTIL,LEAVE                 |   EndLoop\n     LOOP WHILE,(CR,R4,LT,R6)            |   Loop over remaining stuff.\n       LEAVE BLOCK=*,(CLI,0(R4),NE,C' ') |     Must be all blanks.\n     ENDLOOP WHILE                       |   EndIf.\n     LA    R0,&PWA.FSV_FILL_VALUE        |   R0 -> Start of fill value\n     SLR   R3,R0                         |   R3 := Fill value length.\n     LEAVE BLOCK=*,(TREG,R3,NP)          |   Leave if null-string.\n     ST    R3,&PWA.FSV_FILL_LENGTH       |   Save in the PWA.\n     LA    R8,1(,R6)                     |   R8 -> past closing \")\".\n     ST    R8,&PWA.FS_CURRENT            |   Save current position.\n     LEAVE BLOCK=GETFMT_FILL_OPERANDS    |   Return to caller.\n   ENDBLK BLOCK=FILL_QUOTE               | End quoted-string checks.\n*                                        |\n   BLOCK NAME=FILL_HEX,TYPE=INLINE       | Begin hex-string checks.\n     LEAVE BLOCK=*,(CLI,0(R7),NE,C'X')   |   Leave if not \"X\".\n     LA    R5,1(,R7)                     |   r5 -> char after \"X\".\n     LEAVE BLOCK=*,(CR,R5,GE,R6)         |   Leave if nothing else.\n     LEAVE BLOCK=*,(CLI,0(R5),NE,C''''),AND,(CLI,0(R5),NE,C'\"')\n     LA    R4,1(,R5)                     |   R4 -> 1st char past quote\n     LA    R3,&PWA.FSV_FILL_VALUE        |   R3 -> Current value posn.\n     LA    R2,L'&PWA.FSV_FILL_VALUE-1(R3)    R2 -> Value Limit.\n     LOOP  UNTIL                         |   Loop over hex-string.\n       LEAVE   BLOCK=*,(CR,R4,GE,R6)     |     Leave if not ended.\n       LEAVE   LOOP=*,(CLC,0(1,R4),EQ,0(R5))   Leave on end-quote.\n       ERREXIT (CR,R3,GE,R2),CODE=&ST_FORMAT_FILL_TOO_LONG\n       MVC     &W.CHAR+0(1),0(R4)        |     Copy 1st of hex-pair.\n       LA      R4,1(,R4)                 |     Advance to next.\n       LEAVE   BLOCK=*,(CR,R4,GE,R6)     |     Leave if no 2nd-half.\n       LEAVE   BLOCK=*,(CLC,0(1,R4),EQ,0(R5))  Leave if no 2nd-half.\n       MVC     &W.CHAR+1(1),0(R4)        |     Copy 2nd of hex-pair.\n       LA      R4,1(,R4)                 |     Advance to next.\n       TR      &W.CHAR,&PSD.HEX_TAB      |     Translate for convert.\n       LEAVE   BLOCK=*,(CLI,&W.CHAR+0,EQ,X'00') Leave if bad hex-char.\n       LEAVE   BLOCK=*,(CLI,&W.CHAR+1,EQ,X'00') Leave if bad hex-char.\n       PACK    &W.HEX,&W.CHAR_PLUS       |      Pack w/garbage byte.\n       MVC     0(1,R3),&W.HEX            |     Copy one character.\n       LA      R3,1(,R3)                 |     R3 -> Next value posn.\n     ENDLOOP UNTIL,LEAVE                 |   EndLoop\n     LA   R4,1(,R4)                      |   R4 -> past end-quote.\n     LOOP WHILE,(CR,R4,LT,R6)            |   Loop over remaining stuff.\n       LEAVE BLOCK=*,(CLI,0(R4),NE,C' ') |     Must be all blanks.\n     ENDLOOP WHILE                       |   EndIf.\n     LA    R0,&PWA.FSV_FILL_VALUE        |   R0 -> Start of fill value\n     SLR   R3,R0                         |   R3 := Fill value length.\n     LEAVE BLOCK=*,(TREG,R3,NP)          |   Leave if null-string.\n     ST    R3,&PWA.FSV_FILL_LENGTH       |   Save in the PWA.\n     LA    R8,1(,R6)                     |   R8 -> past closing \")\".\n     ST    R8,&PWA.FS_CURRENT            |   Save current position.\n     LEAVE BLOCK=GETFMT_FILL_OPERANDS    |   Return to caller.\n   ENDBLK BLOCK=FILL_HEX                 | End hex-string checks.\n*                                        |\n   BLOCK NAME=FILL_REF,TYPE=INLINE       | Begin reference (?) checks.\n     LEAVE BLOCK=*,(CLI,0(R7),NE,C'?')   |   Leave if not \"?\".\n     LA    R5,1(,R7)                     |   R5 -> next char.\n     LM    R3,R4,&PWA.ARGUMENT_LIST      |   R3:=count, R4->A(<arg>).\n     IF    (TREG,R3,NP),OR,(CLC,=A(0),EQ,0(R4))  If no argument.\n       ERREXIT CODE=&ST_FORMAT_MISSING_ARGUMENT  Exit with error code.\n     ENDIF                               |   EndIf.\n     L     R2,0(R4)                      |   R2 -> Fill string.\n     LA    R4,4(,R4)                     |   R4 -> Next argument.\n     BCTR  R3,0                          |   Subtract 1 from count.\n     STM   R3,R4,&PWA.ARGUMENT_LIST      |   Update current args.\n     MVC   &PWA.FSV_FILL_LENGTH,=F'1'    |   Default length = 1.\n     IF    (CR,R5,LT,R6),AND,(CLI,0(R5),EQ,C'L')\n       LA  R5,1(,R5)                     |     Advance past \"L\".\n       IF  (CR,R5,LT,R6)                 |     If more stuff, then.\n         ST      R5,&PWA.FS_CURRENT      |       Update current posn.\n         CALLSUB GETFMT_INTEGER,(&PWA.FSV_FILL_LENGTH)\n         L       R5,&PWA.FS_CURRENT      |       R5 -> past length.\n       ENDIF                             |     EndIf.\n     ENDIF                               |   EndIf.\n     LOOP WHILE,(CR,R5,LT,R6)            |   Loop over remaining stuff.\n       LEAVE LOOP=*,(CLI,0(R5),NE,C' ')  |     Must be all blanks.\n     ENDLOOP WHILE                       |   EndIf.\n     L     R1,&PWA.FSV_FILL_LENGTH       |   R1 := filler length.\n     ERREXIT (C,R1,GT,=A(L'&PWA.FSV_FILL_VALUE)),                      +\n               CODE=&ST_FORMAT_FILL_TOO_LONG\n     IF    (TREG,R1,NP),OR,(CR,R5,NE,R6) |   If null-string or badchars\n       SL  R4,=F'4'                      |     Restore argument_list\n       LA  R3,1(,R3)                     |     to the values it had\n       STM R3,R4,&PWA.ARGUMENT_LIST      |     before this block.\n       LEAVE BLOCK=*                     |     Don't use as ? filler.\n     ENDIF                               |   EndIf.\n     BCTR  R1,0                          |   Subtract 1 for EXI.\n     EXI   R1,(MVC,&PWA.FSV_FILL_VALUE(0),0(R2))  Copy filler.\n     LA    R8,1(,R6)                     |   R8 -> past closing \")\".\n     ST    R8,&PWA.FS_CURRENT            |   Update current posn.\n     LEAVE BLOCK=GETFMT_FILL_OPERANDS    |   Return to caller.\n   ENDBLK BLOCK=FILL_REF                 | End reference (?) checks.\n*                                        |\n   LA      R5,1(,R6)                     | R5 -> past closing \")\".\n   ST      R5,&PWA.FS_CURRENT            | Update current position.\n   SR      R6,R8                         | R6 := Length w/in (...).\n   ERREXIT (C,R6,GT,=A(L'&PWA.FSV_FILL_VALUE)),                        +\n               CODE=&ST_FORMAT_FILL_TOO_LONG\n   ST      R6,&PWA.FSV_FILL_LENGTH       | Save Length of filler.\n   IF      (TREG,R6,P)                   | If positive.\n     BCTR  R6,0                          |    Subtract 1 for EXI.\n     EXI   R6,(MVC,&PWA.FSV_FILL_VALUE(0),0(R8))  Copy fill string.\n   ENDIF                                 | EndIf.\n ENDBLK BLOCK=GETFMT_FILL_OPERANDS\n              SWA\n&W.CHAR_PLUS  DS 0CL3\n&W.CHAR       DS  CL2                   | Source chars being converted\n              DS  CL1                   | Garbage for PACK to eat.\n&W.HEX        DS  XL2                   | 1st-byte = hex-equivalent.\n              ENDSWA\n              EJECT\n**********************************************************************\n*                                                                    *\n* Subroutine : GETFMT_INTEGER(Value)                                 *\n* Abstract   : Scan from Current up to (but not including) End to    *\n*              extract a format-specification's integer value.  The  *\n*              value must be a '?' or a sequence of digits.  Value   *\n*              will be set to the integer value specified, or if a   *\n*              '?' was provided, the current argument's value (which *\n*              must be a <sizelength> signed binary integer).        *\n*                                                                    *\n**********************************************************************\n BLOCK NAME=GETFMT_INTEGER,TYPE=SUBROUTINE\n   L       R9,0(R1)                      | R9 -> Return value.\n   L       R8,&PWA.FS_CURRENT            | R8 -> Current character.\n   IF      (C,R8,GT,&PWA.FS_END)         | If past end, then\n     LA    R15,4                         |   Indicate no value.\n     LEAVE BLOCK=*                       |   Return to caller.\n   ENDIF                                 | EndIf.\n*                                        |\n   L8 R3,0(R8)                           | R3 := actual character.\n   LA R3,CLASSIFICATION(R3)              | R3 -> character's class.\n   IF (CLI,0(R3),EQ,C'D')                | If string of <digits>.\n     LR    R3,R8                         |   Use R3 to scan ahead.\n     LOOP  WHILE,(C,R3,LE,&PWA.FS_END)   |   Loop over digit-sequence.\n       L8    R2,0(R3)                    |     R2 := actual character.\n       LA    R2,CLASSIFICATION(R2)       |     R2 -> character's class.\n       LEAVE LOOP=*,(CLI,0(R2),NE,C'D')  |     Leave on non-<digit>.\n       LA    R3,1(,R3)                   |     Advance to next char.\n     ENDLOOP WHILE                       |   EndLoop.\n     SLR     R3,R8                       |   R3 := length of <digits>.\n     ERREXIT (C,R3,GT,=F'16'),CODE=&ST_MAGNITUDE\n     BCTR    R3,0                        |   Subtract 1 for EX instr.\n     EXI     R3,(PACK,GSI_DECIMAL,0(0,R8))   Convert to packed-decimal.\n     ERREXIT (CP,GSI_DECIMAL,GT,=P'2147483648'),  If too large for a   +\n               CODE=&ST_MAGNITUDE        |          fullword, error.\n     LA      R8,1(R3,R8)                 |   Advance past <digits>.\n     ST      R8,&PWA.FS_CURRENT          |   Update current position.\n     CVB     R3,GSI_DECIMAL              |   Convert to binary.\n     STCM    R3,B'1111',0(R9)            |   Save value.\n     LA      R15,0                       |   Successful return-code.\n   ELSEIF (CLI,0(R8),EQ,C'?')            | ElseIf a referenced value.\n     LA R8,1(,R8)                        |   Advance to next char.\n     ST R8,&PWA.FS_CURRENT               |   Update current position.\n*                                        |   ...look for <digits>\n     L8 R3,0(R8)                         |   R3 := actual character.\n     LA R3,CLASSIFICATION(R3)            |   R3 -> character's class.\n     IF (CLI,0(R3),NE,C'D')              |   If not a <digit>.\n       MVC  &W.SIZEMASK,&PWA.SIZEMASK    |     Use global SIZELENGTH\n       MVC  &W.SIZELENGTH,&PWA.SIZELENGTH      to obtain length value.\n     ELSE                                |   Else, a string of <digits>\n       LR    R3,R8                       |     Use R3 to scan ahead.\n       LOOP  WHILE,(C,R3,LE,&PWA.FS_END) |     Loop over digits.\n         L8    R2,0(R3)                  |       R2 := actual char.\n         LA    R2,CLASSIFICATION(R2)     |       R2 -> char's class\n         LEAVE LOOP=*,(CLI,0(R2),NE,C'D')        Leave on non-<digit>.\n         LA    R3,1(,R3)                 |       Advance to next char.\n       ENDLOOP WHILE                     |     EndLoop.\n       SLR     R3,R8                     |     R3 := length, <digits>.\n       ERREXIT (C,R3,GT,=F'16'),CODE=&ST_INVALID_SIZELENGTH\n       BCTR    R3,0                      |     Subtract 1 for EX instr.\n       EXI     R3,(PACK,GSI_DECIMAL,0(0,R8))   Convert, packed-decimal\n       ERREXIT (CP,GSI_DECIMAL,GT,=P'2147483648'),  If too large for a +\n               CODE=&ST_INVALID_SIZELENGTH          fullword, error.\n       LA      R8,1(R3,R8)               |     Advance past <digits>.\n       ST      R8,&PWA.FS_CURRENT        |     Update current position.\n       CVB     R3,GSI_DECIMAL            |     Convert to binary.\n       ERREXIT ((C,R3,LT,=F'1'),OR,(C,R3,GT,=F'4')),                   +\n               CODE=&ST_INVALID_SIZELENGTH\n       ST      R3,&W.SIZELENGTH          |     R3 = SIZELENGTH override\n       S       R3,=F'1'                  |     R3 := offset, bit-mask.\n       LA      R3,&PSD.BIT_MASK(R3)      |     R3 -> bit-mask to use.\n       L8      R0,0(R3)                  |     R0 := bit-mask.\n       ST      R0,&W.SIZEMASK            |     Save for getting length.\n     ENDIF                               |   EndIf.\n*                                        |\n     LM R6,R7,&PWA.ARGUMENT_LIST         |   R6:=count, R7->A(<arg>).\n     IF (TREG,R6,NP),OR,(TREG,R7,Z)      |   If no more <arguments>.\n       ERREXIT CODE=&ST_FORMAT_MISSING_ARGUMENT  Exit with error code.\n     ENDIF                               |   EndIf.\n     L     R2,0(,R7)                     |   R2 -> <argument>'s value.\n     LA    R7,4(,R7)                     |   Point to next <argument>.\n     BCTR  R6,0                          |   Subtract 1 from count.\n     STM   R6,R7,&PWA.ARGUMENT_LIST      |   Update current arg.\n     XR    R3,R3                         |   Use R3 to load integer.\n     L     R15,&W.SIZEMASK               |   R15 := length-mask.\n     EXI   R15,(ICM,R3,0,0(R2))          |   R3  := <argument> value.\n     L     R15,&W.SIZELENGTH             |   R15 := #bytes in R3.\n     SLL   R15,3                         |   R15 := #bits in R3.\n     LCR   R15,R15                       |   R15 := #bits ....\n     A     R15,=F'32'                    |       .... to sign-extend.\n     SLL   R3,0(R15)                     |   Shift value to sign-bit.\n     SRA   R3,0(R15)                     |   Shift back, keeping sign.\n     STCM  R3,B'1111',0(R9)              |   Save sign-extended value.\n     LA    R15,0                         |   Successful return-code.\n   ELSE                                  | Else.\n     LA    R15,4                         |   Indicate no value.\n   ENDIF                                 | EndIf.\n ENDBLK BLOCK=GETFMT_INTEGER\n                SWA\nGSI_DECIMAL     DS   D         | Packed-decimal value.\n&W.SIZELENGTH   DS   F         | Size of string length-specifiers.\n&W.SIZEMASK     DS   F         | Mask for <sizelength> values.\n                ENDSWA\n             EJECT\n**********************************************************************\n*                                                                    *\n* Subroutine: ADJUST_COLUMN_POSITION                                 *\n* Abstract:   Implement the @column portion of format-specifications *\n*                                                                    *\n**********************************************************************\n BLOCK TYPE=SUBROUTINE,NAME=ADJUST_COLUMN_POSITION\n   LEAVE BLOCK=*,(TBIT,&PWA.FS_FIELDS,&PWA.FSF_COLUMN,OFF)\n*                                        |\n   IF (CLI,&PWA.FSV_COLUMN,EQ,C'@')      | If Highwater column wanted.\n     MVC &PWA.STRING_CURRENT,&PWA.STRING_HIGHWATER\n     LEAVE BLOCK=*                       |   Return to caller.\n   ENDIF                                 | EndIf.\n*                                        |\n   IF (CLI,&PWA.FSV_COLUMN,EQ,C'=')      | If absolute column#.\n     L32 R9,&PWA.FSV_COLUMN+1            |   R9 := Column# specified.\n   ELSE                                  | Else, +/- relative column#.\n     L32  R8,&PWA.FSV_COLUMN+1           |   R8 := Column# specified.\n     L    R9,&PWA.STRING_CURRENT         |   R9 := current position.\n     SL   R9,&PWA.STRING_START           |   R9 := current offset.\n     LA   R9,1(,R9)                      |   R9 := current column#.\n     IF   (CLI,&PWA.FSV_COLUMN,EQ,C'+')  |   If +relative column.\n       AR   R9,R8                        |     Add to current column#.\n     ELSEIF (CLI,&PWA.FSV_COLUMN,EQ,C'-')    ElseIf -relative column#.\n       SR   R9,R8                        |     Subtract from column#.\n     ELSE                                |   Else.\n       ERREXIT CODE=&ST_INTERNAL_ERROR   |     Internal error.\n     ENDIF                               |   EndIf.\n   ENDIF                                 | EndIf.\n*                                        |\n   ERREXIT (TREG,R9,NP),CODE=&ST_FORMAT_COLUMN_TOO_SMALL\n   BCTR    R9,0                          | Change to an offset.\n   AL      R9,&PWA.STRING_START          | Add to start-address.\n   ERREXIT (C,R9,GT,&PWA.STRING_END),CODE=&ST_FORMAT_COLUMN_TOO_LARGE\n   ST    R9,&PWA.STRING_CURRENT          | Save as new column.\n   IF    (C,R9,GT,&PWA.STRING_HIGHWATER) | If a new high-water mark.\n     ST  R9,&PWA.STRING_HIGHWATER        |   Update Highwater mark.\n   ENDIF                                 | EndIf.\n ENDBLK BLOCK=ADJUST_COLUMN_POSITION\n             EJECT\n**********************************************************************\n*                                                                    *\n* FORMAT_ADDRESS: Format the next argument as an address.            *\n*                                                                    *\n**********************************************************************\n BLOCK NAME=FORMAT_ADDRESS,TYPE=SUBROUTINE\n   L32  R2,&PWA.FSV_SOURCE    | R2 -> Source data to format.\n   L32  R3,&PWA.FSV_LENGTH    | R3 -> Length of source data.\n*---------------------------------------------------------------------*\n*  Convert entire address to an eight-byte text string w/leading zeros.\n*---------------------------------------------------------------------*\n   IF  (TREG,R3,NZ),THEN      | If any data to convert, then\n     BCTR R3,0                |   Subtract 1 for EX instr.\n     EXI  R3,(MVC,&PWA.WORK0,0(R2))\n     LA   R3,1(,R3)           |   Use a garbage sign-byte.\n     EXI  R3,(UNPK,DECIMAL9,&PWA.WORK0)\n     TR   DECIMAL,HEXCHARS    |   Convert ABCDEF to printables.\n   ELSE                       | Else\n     MVC  DECIMAL,=8X'F0'     |   Pretend all zeros were converted.\n   ENDIF                      | EndIf\n*---------------------------------------------------------------------*\n*  Set up R2 and R3 for addr/length of formatted address.  Point to\n*  1st non-zero byte or the last byte if all zeros.\n*---------------------------------------------------------------------*\n   SLL  R3,1                  | R3 := length of formatted address.\n   LA   R2,DECIMAL+L'DECIMAL  |\n   SR   R2,R3                 | R2 -> 1st byte of formatted address.\n   IF   (CLI,&PWA.FSV_LEADING_PAD,NE,C'0')\n     S    R3,=F'1'            |\n     XR   R14,R14             | R2 -> 1st non-zero digit or last\n     ICM  R15,15,=X'F0000000' |       digit in number if all zeros.\n     CLCL R2,R14              | R3 := length of whatever remains\n     LA   R3,1(,R3)           |       from R2 to the end of number.\n   ENDIF                      |\n*---------------------------------------------------------------------*\n*  Pad to the left with blanks/zeros if right-justified and then copy\n*  the formatted address to the target area.\n*---------------------------------------------------------------------*\n   CALLSUB PAD_LEFT,((R3)),NOVL\n   CALLSUB COPY_TO_STRING,((R2),(R3)),NOVL\n   CALLSUB PAD_RIGHT,((R3)),NOVL\n ENDBLK BLOCK=FORMAT_ADDRESS\n EJECT\n**********************************************************************\n*                                                                    *\n* FORMAT_BINARY: Format a bit-string.                                *\n*                                                                    *\n**********************************************************************\n BLOCK NAME=FORMAT_BINARY,TYPE=SUBROUTINE\n   L32  R2,&PWA.FSV_SOURCE       | R2 -> Source data to format.\n   L32  R3,&PWA.FSV_LENGTH       | R3 := Length of source data.\n*---------------------------------------------------------------------*\n*  Determine the formatted data's length and insert pad characters\n*  if neccessary to get the correct justification.\n*---------------------------------------------------------------------*\n   LR      R4,R3                 | R4 := source bit-string length.\n   SLL     R4,3                  | R4 := length of formatted result.\n   CALLSUB PAD_LEFT,((R4)),NOVL  | Insert leading pad characters.\n*---------------------------------------------------------------------*\n*  Loop over the source data, formatting/moving a byte at a time.\n*---------------------------------------------------------------------*\n   LOOP BCT                   | Loop over the source data.\n     ICM   R14,1,0(R2)        |   R11 := byte to format.\n     LA    R1,8               |   R1  := number of bits.\n     LOOP  BCT                |   Loop over bits in byte.\n       SRDL R14,1             |     Shift next bit into R15.\n       SRL  R15,31            |     Shift to low bit.\n       O    R15,=C'...0'      |     Create a character 0 or 1.\n       STC  R15,&PWA.WORK8-1(R1)    Save the new character.\n     ENDLOOP BCT,R1           |   EndLoop.\n     CALLSUB COPY_TO_STRING,(&PWA.WORK8,L'&PWA.WORK8),NOVL\n     LA      R2,1(,R2)        |   Point to next byte to format.\n   ENDLOOP BCT,R3             | EndLoop.\n*---------------------------------------------------------------------*\n*  Pad with trailing spaces if necessary.\n*---------------------------------------------------------------------*\n   CALLSUB PAD_RIGHT,((R4)),NOVL | Pad with trailing spaces.\n ENDBLK BLOCK=FORMAT_BINARY\n EJECT\n**********************************************************************\n*                                                                    *\n* FORMAT_CHARACTER: Move a character string into the target string.  *\n*                                                                    *\n**********************************************************************\n BLOCK NAME=FORMAT_CHARACTER,TYPE=SUBROUTINE\n   L32  R2,&PWA.FSV_SOURCE    | R2 -> Source data to format.\n   L32  R3,&PWA.FSV_LENGTH    | R3 := Length of source data.\n*---------------------------------------------------------------------*\n*  If a precision was specified, set the source length to the minimum\n*  of the actual source-length and the precision.\n*---------------------------------------------------------------------*\n   IF (TBIT,&PWA.FS_FIELDS,&PWA.FSF_PRECISION) If .precision specified.\n     IF  (C,R3,GT,&PWA.FSV_PRECISION)     |   If sourcelen > precision.\n       L  R3,&PWA.FSV_PRECISION           |    Use specified precision.\n     ENDIF                                |   EndIf.\n   ENDIF                                  | EndIf.\n*---------------------------------------------------------------------*\n*  If the trim function was requested, adjust the length of the source\n*  string to leave off trailing blanks.  The length may go to zero\n*  when doing this.\n*---------------------------------------------------------------------*\n   IF (CLI,&PWA.FSV_TRIM,EQ,C'Y')             | If TRIM specified.\n     IF (TREG,R3,P)                           |   If anything to trim.\n       LA   R15,0(R3,R2)                      |     R15 -> past end.\n       LOOP BCT                               |   Scan backwards.\n         BCTR  R15,0                          |     Back up 1 char.\n         LEAVE LOOP=*,(CLI,0(R15),NE,C' ')    |     Leave on nonblank.\n       ENDLOOP BCT,R3                         |   EndLoop.\n     ENDIF                                    | EndIf.\n   ENDIF                                      | EndIf.\n*---------------------------------------------------------------------*\n* If QST was specified, quote the text as we copy.\n*---------------------------------------------------------------------*\n   IF (CLI,&PWA.FSV_QST,EQ,C'Y')        | If QST specified.\n    MVC  &W.OUTADDR,&PWA.STRING_CURRENT |  Save start position.\n    L    R8,&PWA.STRING_CURRENT         |  R8 -> current target pos.\n    L    R9,&PWA.STRING_END             |  R9 -> last target byte.\n    IF (CR,R8,LE,R9)                    |  If room.\n     MVI 0(R8),C''''                    |   Add opening quote to\n     LA  R8,1(,R8)                      |   target.\n    ENDIF                               |  EndIf.\n    LOOP WHILE,(TREG,R3,P),AND,(CR,R8,LE,R9)  While source & room.\n     MVC  0(1,R8),0(R2)                 |      Copy source to target.\n     LA   R8,1(,R8)                     |      Bump target position.\n     IF   (CLI,0(R2),EQ,C''''),AND,(CR,R8,LE,R9)  If quote & room.\n      MVI  0(R8),C''''                  |          Add quote to target.\n      LA   R8,1(,R8)                    |          Bump target position\n     ENDIF                              |         EndIf.\n     LA   R2,1(,R2)                     |      Bump source position.\n     BCTR R3,0                          |      One less source char.\n    ENDLOOP WHILE                       |     EndLoop\n    IF (TREG,R3,P),OR,(CR,R8,GE,R9)     |  If no room.\n     ERREXIT CC4,CODE=&ST_TRUNCATED.    |   We're done.\n    ENDIF                               |  EndIf.\n    MVI 0(R8),C''''                     |  Add closing quote.\n    LA  R8,1(,R8)                       |  Bump target position.\n    ST  R8,&PWA.STRING_CURRENT          |  Update current position.\n    IF (C,R8,GT,&PWA.STRING_HIGHWATER)  |  If a new high-water mark.\n     ST R8,&PWA.STRING_HIGHWATER        |   Update Highwater mark.\n    ENDIF                               |  EndIf.\n    S   R8,&W.OUTADDR                   |  R8 := formatted length.\n    ST  R8,&W.OUTLEN                    |\n*---------------------------------------------------------------------*\n*   Otherwise, copy string directly.\n*---------------------------------------------------------------------*\n   ELSE\n    CALLSUB PAD_LEFT,((R3)),NOVL\n    MVC     &W.OUTADDR,&PWA.STRING_CURRENT\n    ST      R3,&W.OUTLEN\n    CALLSUB COPY_TO_STRING,((R2),0(R3)),NOVL\n    CALLSUB PAD_RIGHT,((R3)),NOVL\n   ENDIF                                      | EndIf.\n*---------------------------------------------------------------------*\n*  Capitalize the new copy of the character string if requested.\n*---------------------------------------------------------------------*\n   L  R8,&W.OUTADDR\n   L  R3,&W.OUTLEN\n   IF (CLI,&PWA.FSV_CAPS,EQ,C'Y')   | If CAPS specified.\n     LOOP  WHILE,(C,R3,GT,=F'256')  |   Loop over large chunks.\n       TR  0(256,R8),FOLD           |     Fold segment to caps.\n       LA  R8,256(,R8)              |     Advance to next segment.\n       S   R3,=F'256'               |     Adjust remaining len.\n     ENDLOOP WHILE                  |   EndLoop.\n     IF (TREG,R3,P)                 |   If anything left.\n       BCTR R3,0                    |     Subtract 1 for EX instr.\n       EXI  R3,(TR,0(0,R8),FOLD)    |     Fold segment to caps.\n     ENDIF                          |   EndIf.\n   ELSEIF (CLI,&PWA.FSV_C1ST,EQ,C'Y') ElseIf cap 1st letter\n     TR 0(1,R8),FOLD                |   Capitalize 1st letter of fld.\n   ENDIF                            | EndIf.\n ENDBLK BLOCK=FORMAT_CHARACTER\n           SWA\n&W.OUTLEN  DS   F\n&W.OUTADDR DS   A\n           ENDSWA\n EJECT\n**********************************************************************\n*                                                                    *\n* FORMAT_SIGNED_INTEGER: Format 1,2,3,4 byte signed binary integer.  *\n*                                                                    *\n**********************************************************************\n BLOCK NAME=FORMAT_SIGNED_INTEGER,TYPE=SUBROUTINE\n   L32  R2,&PWA.FSV_SOURCE    | R2 -> Source data to format.\n   L32  R3,&PWA.FSV_LENGTH    | R3 := Length of source data.\n*---------------------------------------------------------------------*\n*  Get the integer, sign extended, into a register and convert to\n*  decimal. Then convert it to printable characters -- inserting a\n*  sign if needed.\n*---------------------------------------------------------------------*\n   IF (TREG,R3,P),THEN        | If any data to convert, then\n     BCTR R3,0                |    Subtract 1 for EX instr.\n     XC   &PWA.WORK4,&PWA.WORK4 |  Clear out holding area.\n     EXI  R3,(MVC,&PWA.WORK0,0(R2)) Copy number over.\n     L    R5,&PWA.WORK4       |    Load number into R5.\n     LA   R3,1(,R3)           |    Add 1 back to length.\n     SLL  R3,3                |    Convert to number-of-bits.\n     LCR  R3,R3               |    Change to a negative number to\n     A    R3,=F'32'           |    subtract from total number of bits.\n     SRA  R5,0(R3)            |    Sign-extend to a fullword integer.\n     CVD  R5,DECIMAL          |    Convert the integer to decimal.\n     UNPK &PWA.WORK16,DECIMAL |    Convert decimal to printable.\n   ELSE                       | Else\n     FILL &PWA.WORK16,X'F0'   |   Pretend all zeros were converted.\n   ENDIF                      | EndIf\n*---------------------------------------------------------------------*\n*  Set up R2 and R3 for addr/length of formatted integer.  Point to\n*  1st non-zero byte or the last byte if all zeros.  Don't worry about\n*  leading-zeros ... they will be taken care of by pad_left.\n*---------------------------------------------------------------------*\n   LA   R3,L'&PWA.WORK16      | R3 := length of formatted integer.\n   LA   R2,&PWA.WORK          | R2 -> 1st byte of formatted integer.\n   S    R3,=F'1'              |\n   XR   R14,R14               | R2 -> 1st non-zero digit or last\n   ICM  R15,15,=X'F0000000'   |       digit in number if all zeros.\n   CLCL R2,R14                | R3 := length of whatever remains\n   LA   R3,1(,R3)             |       from R2 to the end of number.\n*---------------------------------------------------------------------*\n*  If the number is negative, insert a minus sign in front of it.  The\n*  number cannot possibly be as long as 16 bytes in length, so it is\n*  safe to assume that there will be room in the formatted field of\n*  DECIMAL16 to insert the minus sign.  Set the four-bit sign to a\n*  hexadecimal 'F' so that the last digit will print.\n*---------------------------------------------------------------------*\n   L8  R1,DECIMAL+L'DECIMAL-1  | Pick up last digit of integer.\n   N   R1,=F'15'               | Throw away all but sign.\n   IF (CLM,R1,1,EQ,=X'0D')     | If negative, then\n     S   R2,=F'1'              |   Retract start-of-number pointer.\n     A   R3,=F'1'              |   Add 1 to total length of integer.\n     MVI 0(R2),C'-'            |   Insert minus sign.\n   ENDIF                       | EndIf.\n   OI &PWA.WORK16+15,X'F0'     | Make last digit printable.\n*---------------------------------------------------------------------*\n*  If the integer is to be printed as a 'relative' number, then append\n*  a -st, -nd, -rd, or -th suffix as appropriate.\n*---------------------------------------------------------------------*\n   IF (CLI,&PWA.FSV_RELATIVE,EQ,C'Y')  If relative numbers.\n     A    R3,=F'2'             |   Add 2 to total length of integer.\n     SLR  R4,R4                |   Clear out R4 for division.\n     LPR  R5,R5                |   Force integer to be positive.\n     D    R4,=F'10'            |   Divide by 10 to get remainder in R4.\n     IF   (C,R4,EQ,=F'1')      |   If it ends w/a 1, then.\n       MVC &PWA.SUFFIX,=C'st'  |     Use the -st suffix.\n     ELSEIF (C,R4,EQ,=F'2')    |   Else if it ends w/a 2, then.\n       MVC &PWA.SUFFIX,=C'nd'  |     Use the -nd suffix.\n     ELSEIF (C,R4,EQ,=F'3')    |   Else if it ends w/a 3, then.\n       MVC &PWA.SUFFIX,=C'rd'  |     Use the -rd suffix.\n     ELSE                      |   Else\n       MVC &PWA.SUFFIX,=C'th'  |     Use the -th suffix.\n     ENDIF                     |\n   ENDIF                       | EndIf.\n*---------------------------------------------------------------------*\n*  Pad to the left with blanks/zeros if right-justified and then copy\n*  the formatted integer to the target area.\n*---------------------------------------------------------------------*\n   CALLSUB PAD_LEFT,((R3)),NOVL\n   CALLSUB COPY_TO_STRING,((R2),(R3)),NOVL\n   CALLSUB PAD_RIGHT,((R3)),NOVL\n ENDBLK BLOCK=FORMAT_SIGNED_INTEGER\n EJECT\n**********************************************************************\n*                                                                    *\n* FORMAT_UNSIGNED_INTEGER: Format an unsigned binary integer.        *\n*                                                                    *\n**********************************************************************\n BLOCK NAME=FORMAT_UNSIGNED_INTEGER,TYPE=SUBROUTINE\n   L32  R2,&PWA.FSV_SOURCE          | R2 -> Source data to format.\n   L32  R3,&PWA.FSV_LENGTH          | R3 := Length of source data.\n*---------------------------------------------------------------------*\n*  Get the integer into a register and convert to decimal.  Since the\n*  CVD instruction converts from signed-binary to decimal, the result\n*  may need to be adjusted to make it right.\n*---------------------------------------------------------------------*\n   XC   &PWA.WORK4,&PWA.WORK4       | Clear out holding area.\n   LM   R4,R5,=D'0'                 | Clear out R4/R5 entirely.\n   BCTR R3,0                        | R3 := offset into ICM mask table.\n   LA   R3,&PSD.BIT_MASK(R3)        | R3 -> Bit mask to use.\n   L8   R15,0(R3)                   | R15 := Bit mask to use.\n   EXI  R15,(ICM,R5,0,0(R2))        | R5 := Number to convert.\n   SLDL R4,1                        | Shift high-bit to R4.\n   SRL  R5,1                        | Shift rest of number back.\n   CVD  R5,DECIMAL                  | Convert the integer to decimal.\n   IF   (TREG,R4,NZ)                | If high-order bit was on.\n     AP DECIMAL,=P'2147483648'      |   Add X'80000000' back to number.\n   ENDIF                            | EndIf.\n   UNPK &PWA.WORK16,DECIMAL         | Convert decimal to printable.\n*---------------------------------------------------------------------*\n*  Set up R2 and R3 for addr/length of formatted integer.  Point to\n*  1st non-zero byte or the last byte if all zeros.  Don't worry about\n*  leading-zeros ... they will be taken care of by pad_left.\n*---------------------------------------------------------------------*\n   LA   R3,L'&PWA.WORK16      | R3 := length of formatted integer.\n   LA   R2,&PWA.WORK          | R2 -> 1st byte of formatted integer.\n   S    R3,=F'1'              |\n   XR   R14,R14               | R2 -> 1st non-zero digit or last\n   ICM  R15,15,=X'F0000000'   |       digit in number if all zeros.\n   CLCL R2,R14                | R3 := length of whatever remains\n   LA   R3,1(,R3)             |       from R2 to the end of number.\n   OI   &PWA.WORK16+15,X'F0'  | Make last digit printable.\n*---------------------------------------------------------------------*\n*  If the integer is to be printed as a 'relative' number, then append\n*  a -st, -nd, -rd, or -th suffix as appropriate.\n*---------------------------------------------------------------------*\n   IF (CLI,&PWA.FSV_RELATIVE,EQ,C'Y')  If relative numbers.\n     A    R3,=F'2'             |   Add 2 to total length of integer.\n     SLR  R4,R4                |   Clear out R4 for division.\n     LPR  R5,R5                |   Force integer to be positive.\n     D    R4,=F'10'            |   Divide by 10 to get remainder in R4.\n     IF   (C,R4,EQ,=F'1')      |   If it ends w/a 1, then.\n       MVC &PWA.SUFFIX,=C'st'  |     Use the -st suffix.\n     ELSEIF (C,R4,EQ,=F'2')    |   Else if it ends w/a 2, then.\n       MVC &PWA.SUFFIX,=C'nd'  |     Use the -nd suffix.\n     ELSEIF (C,R4,EQ,=F'3')    |   Else if it ends w/a 3, then.\n       MVC &PWA.SUFFIX,=C'rd'  |     Use the -rd suffix.\n     ELSE                      |   Else\n       MVC &PWA.SUFFIX,=C'th'  |     Use the -th suffix.\n     ENDIF                     |\n   ENDIF                       | EndIf.\n*---------------------------------------------------------------------*\n*  Pad to the left with blanks/zeros if right-justified and then copy\n*  the formatted integer to the target area.\n*---------------------------------------------------------------------*\n   CALLSUB PAD_LEFT,((R3)),NOVL\n   CALLSUB COPY_TO_STRING,((R2),(R3)),NOVL\n   CALLSUB PAD_RIGHT,((R3)),NOVL\n ENDBLK BLOCK=FORMAT_UNSIGNED_INTEGER\n EJECT\n**********************************************************************\n*                                                                    *\n* FORMAT_HEX_CHARACTER: Format a hexadecimal character string.       *\n*                                                                    *\n**********************************************************************\n BLOCK NAME=FORMAT_HEX_CHARACTER,TYPE=SUBROUTINE\n   L32  R2,&PWA.FSV_SOURCE    | R2 -> Source data to format.\n   L32  R3,&PWA.FSV_LENGTH    | R3 := Length of source data.\n*---------------------------------------------------------------------*\n*  Determine the formatted data's length and insert pad characters\n*  if neccessary to get the correct justification.\n*---------------------------------------------------------------------*\n   LR      R4,R3                 | R4 := source bit-string length.\n   SLL     R4,1                  | R4 := length of formatted result.\n   CALLSUB PAD_LEFT,((R4)),NOVL  | Insert leading pad characters.\n*---------------------------------------------------------------------*\n*  Loop over the source data, formatting/moving a byte at a time.\n*---------------------------------------------------------------------*\n   LA   R5,2\n   IF   (TREG,R3,NZ)             | If any hex data then.\n     LOOP BCT                    |   Loop over the source data.\n       MVC   &PWA.WORK1,0(R2)    |     Copy byte to be formatted.\n       UNPK  DECIMAL9,&PWA.WORK2 |     Unpack, along with junk-byte.\n       TR    DECIMAL,HEXCHARS    |     Convert ABCDEF to printables.\n       CALLSUB COPY_TO_STRING,(DECIMAL+6,(R5)),NOVL\n       LA    R2,1(,R2)           |     Point to next byte to format.\n     ENDLOOP BCT,R3              |   EndLoop.\n   ENDIF                         | EndIf.\n   CALLSUB PAD_RIGHT,((R4)),NOVL | Add trailing spaces.\n ENDBLK BLOCK=FORMAT_HEX_CHARACTER\n EJECT\n**********************************************************************\n*                                                                    *\n* Subroutine: PAD_LEFT(formatted-length)                             *\n* Abstract: Insert the appropriate number of leading blanks/zeros    *\n*           to cause right-justification or centering to work out.   *\n*           The parameter is call-by-value.  R1 -> directly to the   *\n*           formatted-length value.                                  *\n*                                                                    *\n**********************************************************************\n BLOCK NAME=PAD_LEFT,TYPE=SUBROUTINE\n*---------------------------------------------------------------------*\n*  If right-justification or centering is enabled and if the target\n*  field width is greater than the width of the formatted data, then\n*  padding to the left is required.\n*---------------------------------------------------------------------*\n  IF (CLI,&PWA.FSV_CENTER,EQ,C'Y'),OR,(CLI,&PWA.FSV_RIGHT,EQ,C'Y')\n     L     R8,&PWA.STRING_CURRENT  R8 -> current target position.\n     L     R9,&PWA.STRING_END  |   R9 -> last target byte.\n     SLR   R9,R8               |   R9 := length of target - 1.\n     AL    R9,=F'1'            |   R9 := length of target area.\n     IF (C,R9,GT,&PWA.FSV_WIDTH)   If enough room for data.\n       L   R9,&PWA.FSV_WIDTH   |     Set length = specified width.\n     ENDIF                     |   EndIf.\n     L     R1,0(R1)            |   R1 := Length of formatted data.\n     IF (CR,R9,GT,R1)          |   If one or more pad chars needed.\n       SR R9,R1                |     R9 = number of pad characters.\n       IF (CLI,&PWA.FSV_CENTER,EQ,C'Y') If centering text.\n         LR  R15,R9            |\n         XR  R14,R14           |       Divide pad-length by two.\n         D   R14,=F'2'         |\n         LR  R9,R15            |\n       ENDIF                   |     EndIf.\n       XR   R14,R14            |\n       XR   R15,R15            |\n       ICM  R15,8,&PWA.FSV_LEADING_PAD Get leading pad character.\n       MVCL R8,R14             |\n       ST   R8,&PWA.STRING_CURRENT   Update current target position.\n       IF   (C,R8,GT,&PWA.STRING_HIGHWATER)  If a new high-water mark.\n         ST R8,&PWA.STRING_HIGHWATER   Update Highwater mark.\n       ENDIF                   |     EndIf.\n     ENDIF                     |   EndIf.\n   ENDIF                       | EndIf\n ENDBLK BLOCK=PAD_LEFT\n EJECT\n**********************************************************************\n*                                                                    *\n* Subroutine: COPY_TO_STRING,(Text,*Length*)                         *\n* Abstract:   Move formatted data described by addr/length parms     *\n*             to the target string.  The length parameter is passed  *\n*             by value -- that is, it is actually in the parameter   *\n*             list itself instead of following normal conventions.   *\n*                                                                    *\n**********************************************************************\n BLOCK NAME=COPY_TO_STRING,TYPE=SUBROUTINE\n   LM    R0,R1,0(R1)          | R0 -> text, R1 -> length of text.\n*---------------------------------------------------------------------*\n*  Copy the formatted data pointed to by R0 with length (R1).\n*---------------------------------------------------------------------*\n   L     R8,&PWA.STRING_CURRENT R8 -> current target position.\n   L     R9,&PWA.STRING_END   | R9 -> last target byte.\n   SLR   R9,R8                | R9 := length of target - 1.\n   AL    R9,=F'1'             | R9 := length of target area.\n   IF    (CR,R9,GT,R1)        | If enough room in target area.\n     LR  R9,R1                |   R9 := length of data to move.\n   ENDIF                      | EndIf.\n   STM   R8,R9,MF_TARGET      | Save target area address, length.\n   MVCL  R8,R0                | Copy the formatted bit-string.\n   ST    R8,&PWA.STRING_CURRENT Update current target position.\n   ERREXIT CC4,CODE=&ST_TRUNCATED.\n   ERREXIT CC1,CODE=&ST_OVERLAP.\n   IF (C,R8,GT,&PWA.STRING_HIGHWATER)  If a new high-water mark.\n     ST R8,&PWA.STRING_HIGHWATER   Update Highwater mark.\n   ENDIF                      | EndIf.\n ENDBLK BLOCK=COPY_TO_STRING\n           SWA\nMF_TARGET  DS      2F\n           ENDSWA\n EJECT\n**********************************************************************\n*                                                                    *\n* PAD_RIGHT: Add the appropriate number of trailing characters to    *\n*            cause left-justification or centering to work out.      *\n*            The parameter is call-by-value.  R1 -> directly to the  *\n*            formatted-length value.                                 *\n*                                                                    *\n**********************************************************************\n BLOCK NAME=PAD_RIGHT,TYPE=SUBROUTINE\n*---------------------------------------------------------------------*\n*  If left-justification, centering, or filling is enabled and if the\n*  target field width is greater than the width of the formatted data,\n*  then padding to the RIGHT is required.\n*---------------------------------------------------------------------*\n   IF (CLI,&PWA.FSV_LEFT,EQ,C'Y'),OR,(CLI,&PWA.FSV_CENTER,EQ,C'Y'),OR, +\n               (CLI,&PWA.FSV_FILL,EQ,C'Y')\n     L   R8,&PWA.STRING_CURRENT       R8 -> current target position.\n     L   R9,&PWA.STRING_END       |   R9 -> last target byte.\n     SLR R9,R8                    |   R9 := length of target - 1.\n     AL  R9,=F'1'                 |   R9 := length of target area.\n     L   R15,&PWA.FSV_WIDTH       |   R15 := number of pad characters\n     IF  (C,R15,GT,0(R1))         |   If one or more pad chars needed.\n       S R15,0(R1)                |     R15 := number of pad chars.\n       IF  (CLI,&PWA.FSV_CENTER,EQ,C'Y')  If centering.\n         XR  R14,R14              |\n         D   R14,=F'2'            |       Divide pad-length by 2 and\n         AR  R15,R14              |       Add back the remainder.\n       ENDIF                      |     EndIf.\n       IF (CR,R15,LT,R9)          |     If pad-length < available room.\n         LR   R9,R15              |       Use pad-length.\n       ENDIF                      |     EndIf.\n       LA   R1,0(R9,R8)           |     R1 -> past end of pad/fill area\n       ST   R1,&PWA.STRING_CURRENT      Update current target position.\n       IF   (C,R1,GT,&PWA.STRING_HIGHWATER)  If a new high-water mark.\n         ST R1,&PWA.STRING_HIGHWATER      Update Highwater mark.\n       ENDIF                      |     EndIf.\n*---------------------------------------------------------------------*\n*      Now perform actual padding or filling operation.\n*---------------------------------------------------------------------*\n       IF (CLI,&PWA.FSV_FILL,EQ,C'Y')   If fill-string.\n         LA   R1,0(R8,R9)         |       R1 -> past end.\n         SL   R1,&PWA.FSV_FILL_LENGTH     R1 -> MVC target.\n         L    R2,&PWA.FSV_FILL_LENGTH     R2 := l'filler\n         BCTR R2,0                |       Subtract 1 for EXIs\n         LOOP WHILE,(CR,R1,GE,R8) |       Loop backwards.\n           EXI R2,(MVC,0(0,R1),&PWA.FSV_FILL_VALUE)  Move 1 fill segmt\n           SL  R1,&PWA.FSV_FILL_LENGTH               Back up 1 segmt.\n         ENDLOOP WHILE            |       EndLoop.\n         AL  R1,&PWA.FSV_FILL_LENGTH      Add back l'filler.\n         IF  (CR,R1,NE,R8)        |       If not an exact fit.\n           SR   R1,R8             |         R1 := remaining length.\n           MVI  0(R8),C' '        |         Fill in remainder.\n           IF   (C,R1,GT,=F'1')   |         If more than 1 char.\n             BCTR R1,0            |          Subtract 1 for MVI above.\n             BCTR R1,0            |          Subtract 1 for EXI.\n             EXI  R1,(MVC,1(0,R8),0(R8))     Fill remaining area.\n           ENDIF                  |         EndIf.\n         ENDIF                    |       EndIf.\n       ELSE                       |     Else.\n         XR   R14,R14             |\n         XR   R15,R15             |\n         ICM  R15,8,=C' '         |       Get trailing pad character.\n         MVCL R8,R14              |\n       ENDIF                      |     EndIf.\n     ENDIF                        |   EndIf.\n   ENDIF                          | EndIf\n ENDBLK BLOCK=PAD_RIGHT\n TITLE 'String Server - Conversion routines.'\n***********************************************************************\n*                                                                     *\n*  Subroutine: STRING_TO_INTEGER                                      *\n*  Abstract:   Convert a string of digits, with optional leading      *\n*              sign, to an integer fullword.                          *\n*  Parameters: (Address, Length, Integer)                             *\n*                                                                     *\n***********************************************************************\n BLOCK TYPE=SUBROUTINE,NAME=STRING_TO_INTEGER\n   LM  R2,R4,0(R1)                    | R2/R3 -> String/Length.\n   SLR R1,R1                          | Clear out for an ICM instr.\n   L   R15,&PWA.SIZEMASK              | R15 := length-mask.\n   EXI R15,(ICM,R1,0,0(R3))           | R1 := string-length.\n   LR  R3,R1                          | R3 := string-length.\n*---------------------------------------------------------------------*\n*  If the first non-blank character is a sign, remember it.\n*---------------------------------------------------------------------*\n   LOOP WHILE,((C,R3,GT,=F'1'),AND,(CLI,0(R2),EQ,C' '))\n     LA   R2,1(,R2)                   |   R2 -> past leading blank.\n     BCTR R3,0                        |   Adjust remaining length.\n   ENDLOOP WHILE                      | EndLoop while.\n*                                     |\n   LA R5,X'0C'                        | R5 := Zoned sign-nibble.\n   IF (C,R3,GT,=F'1')                 | If non-null string.\n     IF (CLI,0(R2),EQ,C'+')           |   If first character is '+'.\n       LA   R2,1(,R2)                 |     R2 -> past leading '+'.\n       BCTR R3,0                      |     Adjust remaining length.\n     ELSEIF (CLI,0(R2),EQ,C'-')       |   ElseIf first char is '-'.\n       LA   R2,1(,R2)                 |     R2 -> past leading '+'.\n       BCTR R3,0                      |     Adjust remaining length.\n       LA R5,X'0D'                    |     Switch to a minus sign.\n     ENDIF                            |   EndIf.\n   ENDIF                              | EndIf.\n*---------------------------------------------------------------------*\n*  Strip leading and trailing blanks from the remaining string.\n*---------------------------------------------------------------------*\n   LOOP WHILE,((C,R3,GT,=F'1'),AND,(CLI,0(R2),EQ,C' '))\n     LA   R2,1(,R2)                   |   R2 -> past leading blank.\n     BCTR R3,0                        |   Adjust remaining length.\n   ENDLOOP WHILE                      | EndLoop while.\n   LOOP WHILE,((C,R3,GT,=F'1'),AND,(CLI,0(R2),EQ,C'0'))\n     LA   R2,1(,R2)                   |   R2 -> past leading zero.\n     BCTR R3,0                        |   Adjust remaining length.\n   ENDLOOP WHILE                      | EndLoop while.\n*                                     |\n   LA   R3,0(R3,R2)                   | R3 -> past end of string.\n   LOOP UNTIL                         | Loop backwards.\n     BCTR R3,0                        |   Back up by one character.\n   ENDLOOP UNTIL,((CR,R3,LT,R2),OR,(CLI,0(R3),NE,C' '))\n   LA      R3,1(,R3)                  | R3 -> past trimmed string.\n   SLR     R3,R2                      | R3 := trimmed length.\n*---------------------------------------------------------------------*\n*  Check the adjusted source-string for validity.\n*---------------------------------------------------------------------*\n   IF (C,R3,LT,=F'1')                 | If nothing left, then.\n     L     R15,=F'&ST_INVALID_SOURCE_FORMAT'\n     LEAVE BLOCK=*                    |   Return with error-code.\n   ENDIF                              | EndIf.\n*                                     |\n   LA   R14,0(R3,R2)                  | R14 -> past last character.\n   LOOP WHILE,(CR,R14,GT,R2)          | Loop over digits.\n     BCTR   R14,0                     |   Back up to previous char.\n     L8     R1,0(R14)                 |   R1 := character.\n     LA     R1,CLASSIFICATION(R1)     |   R1 := character's class.\n     IF     (CLI,0(R1),NE,DIGIT)      |   If not a digit, then.\n       L     R15,=F'&ST_INVALID_SOURCE_FORMAT'\n       LEAVE BLOCK=*                  |     Return with error-code.\n     ENDIF                            |   EndIf.\n   ENDLOOP WHILE                      | EndLoop.\n*                                     |\n   IF (C,R3,GT,=F'16')                | If too many digits, then\n     L     R15,=F'&ST_MAGNITUDE'      |   Magnitude too big to handle.\n     LEAVE BLOCK=*                    |   Return with error-code.\n   ENDIF                              | EndIf.\n*                                     |\n   BCTR R3,0                          | Subtract 1 for the EX instr.\n*---------------------------------------------------------------------*\n*  Pack the source text to a decimal number and check its size.\n*---------------------------------------------------------------------*\n   EXI  R3,(PACK,STI_DECIMAL,0(0,R2)) | Pack into decimal fmt.\n   ICM  R0,1,STI_DECIMAL+7            | Pick up last digit of number.\n   N    R0,=X'000000F0'               | Discard all but the digit.\n   OR   R0,R5                         | Insert sign-nibble.\n   STCM R0,1,STI_DECIMAL+7            | Put signed-digit back.\n   IF (CP,STI_DECIMAL,GT,=P'2147483647'),OR,                           +\n               (CP,STI_DECIMAL,LT,=P'-2147483648')\n     L     R15,=F'&ST_MAGNITUDE'      |      Indicate magnitude error.\n     LEAVE BLOCK=*\n   ENDIF\n*---------------------------------------------------------------------*\n*  Attempt to convert the decimal number to binary.\n*---------------------------------------------------------------------*\n   CVB  R1,STI_DECIMAL                | Convert to binary.\n   ST   R1,0(R4)                      | Save in return-parameter.\n   LA   R15,0                         | Indicate successful conversion.\n ENDBLK BLOCK=STRING_TO_INTEGER\n             SWA\nSTI_DECIMAL  DS   D                   |\n             ENDSWA\n             EJECT\n***********************************************************************\n*                                                                     *\n*  Subroutine: INTEGER_TO_STRING(Integer,String,Length,ResultLen)     *\n*  Abstract:   Convert a signed fullword binary integer to a string.  *\n*                                                                     *\n***********************************************************************\n BLOCK TYPE=SUBROUTINE,NAME=INTEGER_TO_STRING\n   IF (CLC,&PWA.#PARMS,NE,=F'6')      | If #parms \u00ac= 6, then.\n     ERREXIT CODE=&ST_WRONG_NUMBER_OF_PARAMETERS\n   ENDIF                              | EndIf.\n*                                     |\n   L    R1,PRM_ITS_INTEGER            | R1 -> INTEGER to convert.\n   ICM  R1,B'1111',0(R1)              | R1 := INTEGER to convert.\n   CVD  R1,DECIMAL                    | Convert INTEGER to decimal.\n   UNPK &PWA.WORK16,DECIMAL           | Convert decimal to STRING.\n   OI   &PWA.WORK16+15,X'F0'          | Make last digit printable.\n*                                     |\n   LA   R4,&PWA.WORK                  | R4 -> new STRING.\n   LA   R5,L'&PWA.WORK16-1            | R5 := length(new STRING) - 1.\n   XR   R14,R14                       | R14 -> Null string.\n   ICM  R15,15,=X'F0000000'           | R15 := C'0'.\n   CLCL R4,R14                        | Set R4/R5 := address/length of\n   LA   R5,1(,R5)                     | string from 1st non-zero digit.\n*                                     |\n   L8 R6,DECIMAL+L'DECIMAL-1          | R6 := last digit of decimal.\n   N  R6,=F'15'                       | Throw away all but sign.\n   IF (CLM,R6,1,EQ,=X'0D')            | If INTEGER was negative, then\n     S   R4,=F'1'                     |   Retract start-of-number.\n     A   R5,=F'1'                     |   Add 1 to total length.\n     MVI 0(R4),C'-'                   |   Insert minus sign.\n   ENDIF                              | EndIf.\n*                                     |\n   L       R15,&PWA.SIZEMASK          | R15 := length-mask.\n   L       R14,PRM_ITS_RESLEN         | R14 -> result-length parm.\n   EXI     R15,(STCM,R5,0,0(R14))     | Save result-length.\n*                                     |\n   L       R2,PRM_ITS_STRING          | R2 -> STRING return area.\n   L       R1,PRM_ITS_LENGTH          | R1 -> STRING return area len.\n   SLR     R3,R3                      | Clear R3 for ICM below.\n   EXI     R15,(ICM,R3,0,0(R1))       | R3 := length of return area.\n   IF      (CR,R3,GT,R5)              | If larger than needed.\n     LR    R3,R5                      |   Use exact length needed.\n   ENDIF                              | EndIf.\n   MVCL    R2,R4                      | Copy formatted text to STRING.\n   ERREXIT CC4,CODE=&ST_TRUNCATED.    | Error if not enough room.\n ENDBLK BLOCK=INTEGER_TO_STRING\n EJECT\n**********************************************************************\n*                                                                    *\n* Error Exit: Save debugging information and perform any needed      *\n*             clean-up.  If CODE=xx is non-zero, it is used for the  *\n*             value of GDIRC. If it is zero, R15 is used for GDIRC.  *\n*                                                                    *\n**********************************************************************\n BLOCK TYPE=ERREXIT\n*---------------------------------------------------------------------*\n*  Save module/offset, registers, return-code.\n*---------------------------------------------------------------------*\n   STM   R0,R15,GDIREGS          | Save registers at time of error.\n   SM_LAL R0,&srv_modname+4      | Point to module identification.\n   ST    R0,GDIMODID             | Save in general debug area.\n   IF    (CLC,=H'0',EQ,0(R14))   | If CODE=00, then.\n     STH R15,GDIRC               |   GDIRC := R15.\n   ELSE                          | Else.\n     MVC   GDIRC,0(R14)          |   GDIRC := CODE.\n   ENDIF                         | EndIf.\n   SL    R14,=A(&srv_modname)    | Calculate offset at time of error.\n   STH   R14,GDIOFFST            | Save in debug area.\n   L     R2,PWAAESV              |\n   USING ESV,R2                  |\n   CALLX ESVESEPA,(ESVESTKN,&ES_SAVE_DEBUG_INFO,&ES_DEBUG_ID_GDI,GDI), +\n               VL\n   DROP  R2                      |\n*---------------------------------------------------------------------*\n*  If the format function was in progress, save the length of the\n*  incompletely formatted string.\n*---------------------------------------------------------------------*\n   L  R1,PRM_FUNCTIONCODE\n   L  R1,0(R1)\n   IF (C,R1,EQ,=F'&ST_FORMAT'),OR,(C,R1,EQ,=F'&ST_FORMAT2')\n     L   R1,PRM_F_STRING        |   R1 -> Target string.\n     L   R0,&PWA.STRING_HIGHWATER   R0 := Last byte formatted, + 1.\n     IF (C,R0,LT,&PWA.STRING_CURRENT) If highwater not up-to-date.\n       L R0,&PWA.STRING_CURRENT |       Use current position instead.\n     ENDIF                      |   EndIf.\n     SLR R0,R1                  |   R0 := Length formatted.\n     L   R1,PRM_F_FMT_LEN       |   R1 -> Formatted string length parm.\n     IF (TREG,R1,NZ)            |   If parameter is not missing.\n       L   R15,&PWA.SIZEMASK    |     R15 := length-mask.\n       EXI R15,(STCM,R0,0,0(R1))      Save as target string's length.\n     ENDIF                      |   EndIf.\n   ENDIF                        | EndIf.\n*---------------------------------------------------------------------*\n*  Pick up the return-code and exit the string-handler entirely.\n*---------------------------------------------------------------------*\n   LH   R15,GDIRC               |\n ENDBLK                         | Exit entire program w/return code.\n EJECT\n*---------------------------------------------------------------------*\n*\n*  Static Data\n*\n*---------------------------------------------------------------------*\n                 PSD\n                 LTORG\n&PSD.BIT_MASK    DC  B'0001',B'0011',B'0111',B'1111'\n*\n         MACRO\n&LABEL   TE  &TYPE,&JUSTIFY,&MIN,&MAX,&DEFAULT,&ROUTINE\n         GBLC &PWA\n&LABEL   DC  C'&TYPE'            | Format-spec letter for this type.\n         DC  C'&JUSTIFY'         | Default justification for this type.\n         DC  AL4(&MIN)           | Minimum length for this type.\n         DC  AL4(&MAX)           | Maximum length for this type.\n         DC  AL4(&DEFAULT)       | Default length for this type.\n         DC  AL4(&ROUTINE)       | A(routine to format this type).\n         MEND\n*\n*                      Min   Max   Dflt    Formatting\n&PSD.TYPES EQU *  T J -----Lengths-----    Subroutine\n*\n&PSD.TYPE_A    TE A,R,00001,00004,00004,FORMAT_ADDRESS\n&PSD.TYPE_B    TE B,L,00001,00256,00001,FORMAT_BINARY\n&PSD.TYPE_C    TE C,L,00000,65535,00001,FORMAT_CHARACTER\n&PSD.TYPE_I    TE I,R,00001,00004,00004,FORMAT_SIGNED_INTEGER\n&PSD.TYPE_U    TE U,R,00001,00004,00004,FORMAT_UNSIGNED_INTEGER\n&PSD.TYPE_X    TE X,L,00000,65535,00001,FORMAT_HEX_CHARACTER\n&PSD.TYPES_E   EQU *-TYPE_ENTRY_L\n*\nCLASSIFICATION  DC   256C';'       <- default value = delimiter.\nDELIMITER       EQU  C';'\nLETTER          EQU  C'L'\nDIGIT           EQU  C'D'\n                ORG  CLASSIFICATION+C' '\n                DC   C';'\n                ORG  CLASSIFICATION+C'a'\n                DC   C'LLLLLLLLL'          LETTERS: abcdefghi\n                ORG  CLASSIFICATION+C'j'\n                DC   C'LLLLLLLLL'          LETTERS: jklmnopqr\n                ORG  CLASSIFICATION+C's'\n                DC   C'LLLLLLLL'           LETTERS: stuvwxyz\n                ORG  CLASSIFICATION+C'A'\n                DC   C'LLLLLLLLL'          LETTERS: ABCDEFGHI\n                ORG  CLASSIFICATION+C'J'\n                DC   C'LLLLLLLLL'          LETTERS: JKLMNOPQR\n                ORG  CLASSIFICATION+C'S'\n                DC   C'LLLLLLLL'           LETTERS: STUVWXYZ\n                ORG  CLASSIFICATION+C'0'\n                DC   C'DDDDDDDDDD'         DIGITS: 0123456789\n                ORG\n*---------------------------------------------------------------------*\n*  Translation table for folding character strings to uppercase.\n*---------------------------------------------------------------------*\nFOLD        DC  256AL1(*-FOLD) | Translate tbl for uppercase conv.\n            ORG FOLD+C'a'      | Fold lowercase 'a' - 'i'.\n            DC  C'ABCDEFGHI'   |\n            ORG FOLD+C'j'      | Fold lowercase 'j' - 'r'.\n            DC  C'JKLMNOPQR'   |\n            ORG FOLD+C's'      | Fold lowercase 's' - 'z'.\n            DC  C'STUVWXYZ'    |\n            ORG  ,\n*---------------------------------------------------------------------*\n*  Translation tables for converting char-to-hex and hex-to-char.\n*---------------------------------------------------------------------*\n&PSD.HEX_TAB  DC  256X'00'\n              ORG &PSD.HEX_TAB+C'a'\n              DC  X'FAFBFCFDFEFF'\n              ORG &PSD.HEX_TAB+C'A'\n              DC  X'FAFBFCFDFEFF'\n              ORG &PSD.HEX_TAB+C'0'\n              DC  C'0123456789'\n*\n              DC   C'0123456789ABCDEF'\nHEXCHARS      EQU  *-256\n              ENDPSD\n              EJECT\n*---------------------------------------------------------------------*\n*\n*  Program Work Area\n*\n*---------------------------------------------------------------------*\n                  PWA\n&PWA.#PARMS       DS   F         | Number of parameters passed in.\n&PWA.SIZELENGTH   DS   F         | Size of string length-specifiers.\n&PWA.SIZEMASK     DS   F         | Mask for <sizelength> values.\n*---------------------------------------------------------------------*\n* General use work area for performing conversions.\n*---------------------------------------------------------------------*\n&PWA.WORK         DS   0D,CL16   | &PWA.WORK for conversions.\n                  ORG  &PWA.WORK |\n&PWA.WORK0        DS   0CL1      | Conversion &PWA.WORK, with L'=1.\n&PWA.WORK1        DS   0CL1      |\n&PWA.WORK2        DS   0CL2      |\n&PWA.WORK3        DS   0CL3      |\n&PWA.WORK4        DS   0CL4      |\n&PWA.WORK8        DS   0CL8      | Conversion &PWA.WORK, with L'=8.\n&PWA.WORK9        DS   0CL9      | Conversion &PWA.WORK, with L'=9.\n&PWA.WORK16       DS   0CL16     | Conversion &PWA.WORK, with L'=16.\n                  ORG  ,         |\n&PWA.SUFFIX       DS   CL2       | st/nd/th suffix for integers.\nDECIMAL           DS   0D,CL9    | Packed decimal holding area.\n                  ORG  DECIMAL   |\nDECIMAL9          DS   0CL9      |\n                  ORG  ,         |\n&PWA.TRANTAB      DS   CL256     | General purpose tranlation table.\nFUNCTION_SPECIFIC DS   0D        | Function-specific work areas.\n*---------------------------------------------------------------------*\n* Format-string function's work area.\n*---------------------------------------------------------------------*\n&PWA.STRING_START     DS  A           | A(String).\n&PWA.STRING_CURRENT   DS  A           | A(current position in String).\n&PWA.STRING_HIGHWATER DS  A           | A(last char in String).\n&PWA.STRING_END       DS  A           | A(last char in String).\n*                                     |\n&PWA.CONTROL_START    DS  A           | A(Control string).\n&PWA.CONTROL_CURRENT  DS  A           | A(current position in Control).\n&PWA.CONTROL_END      DS  A           | A(last char in Control).\n&PWA.CONTROL_LEN      DS  F           | Length of Control string.\n*                                     |\n&PWA.ARGUMENT_LIST DS     2F          | <Argument> count/current.\n*                                     |\n&PWA.ST_FS_WORK       EQU *           | Workarea for 1 format-spec.\n&PWA.FS_CURRENT       DS  A           | A(current position in spec).\n&PWA.FS_LENGTH        DS  F           | Length from '{' to '}'.\n&PWA.FS_END           DS  A           | A(end of specification).\n&PWA.FS_FIELDS        DS  B           | Format-specification fields:\n&PWA.FSF_LEADING_PAD  EQU B'10000000' |   Leading '0' was specified.\n&PWA.FSF_WIDTH        EQU B'01000000' |   Width was specified.\n&PWA.FSF_PRECISION    EQU B'00100000' |   Precision was specified.\n&PWA.FSF_COLUMN       EQU B'00010000' |   Column was specified.\n&PWA.FSF_TYPE         EQU B'00001000' |   Type was specified.\n&PWA.FSF_LENGTH       EQU B'00000100' |   Length was specified.\n&PWA.FSF_MULTIPLE     EQU B'00000010' |   Multiple was specified.\n&PWA.FSF_KEYWORDS     EQU B'00000001' |   Keyword(s) were specified.\n&PWA.FSV_LEADING_PAD  DS  B           | Leading pad character.\n&PWA.FSV_WIDTH        DS  F           | Width value.\n&PWA.FSV_PRECISION    DS  F           | Precision value.\n&PWA.FSV_COLUMN       DS  C,FL4       | Column sign, value.\n&PWA.FSV_TYPE         DS  A           | Address of TYPE_ENTRY.\n&PWA.FSV_SOURCE       DS  A           | Address of source argument.\n&PWA.FSV_LENGTH       DS  F           | Length value.\n&PWA.FSV_MULTIPLE     DS  F           | Multiple value.\n&PWA.FSV_KEYWORDS     EQU *           | Keyword-specified flags.\n&PWA.FSV_CAPS         DS  C           |   Y|N                      CAPS\n&PWA.FSV_C1ST         DS  C           |   Y|N                      C1ST\n&PWA.FSV_CENTER       DS  C           |   Y|N                    CENTER\n&PWA.FSV_LEFT         DS  C           |   Y|N                      LEFT\n&PWA.FSV_RELATIVE     DS  C           |   Y|N                  RELATIVE\n&PWA.FSV_RIGHT        DS  C           |   Y|N                     RIGHT\n&PWA.FSV_TRIM         DS  C           |   Y|N                      TRIM\n&PWA.FSV_FILL         DS  C           |   Y|N                      FILL\n&PWA.FSV_CSV          DS  C           |   Y|N                       CSV\n&PWA.FSV_QST          DS  C           |   Y|N                       QST\n&PWA.FSV_KEYWORDS_LEN EQU *-&PWA.FSV_KEYWORDS\n&PWA.FSV_FILL_LENGTH  DS  F           | Fill string length.\n&PWA.FSV_FILL_VALUE   DS  CL256       | Fill string value.\n&PWA.ST_FS_WORK_L     EQU *-&PWA.ST_FS_WORK\n*---------------------------------------------------------------------*\n* Debugging information in case of error.\n*---------------------------------------------------------------------*\n                  ES_GDI DSECT=NO\n                  ENDPWA\n                  EJECT\n*---------------------------------------------------------------------*\n* Mapping DSECT for one type-entry in the PSD Type-table.\n*---------------------------------------------------------------------*\nTYPE_ENTRY       DSECT\nTE_CHAR          DS CL1  | Format-spec letter for this type.\nTE_JUSTIFY       DS CL1  | Default justification: Left/Center/Right.\nTE_MIN           DS FL4  | Minimum length for this type.\nTE_MAX           DS FL4  | Maximum length for this type.\nTE_DEFAULT       DS FL4  | Default length for this type.\nTE_ROUTINE       DS AL4  | Address of routine to format this type.\nTYPE_ENTRY_L     EQU     *-TYPE_ENTRY\n*---------------------------------------------------------------------*\n* Environment Support Vector.\n*---------------------------------------------------------------------*\n                  ES_ESV\n                  EJECT\n*---------------------------------------------------------------------*\n* Parameter list for the string handler\n*---------------------------------------------------------------------*\nPARMLIST          DSECT              |\nPRM_STRINGTKN     DS  A              | String handler work area.\nPRM_FUNCTIONCODE  DS  A              | Function to be performed.\nPRM_FUNCTION_DEPT EQU *              | Function dependent parameters.\n*\n* Parameters for FunctionCode START.\n*\nPRM_S_ESV         DS  A              | Server Global Area.\nPRM_S_SIZELENGTH  DS  A              | Length of size-'bytes'.\n*\n* Parameters for FunctionCode FORMAT.\n*\n                  ORG PRM_FUNCTION_DEPT\nPRM_F_STRING      DS  A              | Target str for format results.\nPRM_F_STRING_LEN  DS  A              | Length of entire target area.\nPRM_F_FMT_LEN     DS  A              | Length of formatted string.\nPRM_F_CONTROL     DS  A              | Formatting control string.\nPRM_F_CONTROL_LEN DS  A              | Length of control string.\nPRM_F_ARGLIST     DS  A              | Separatly built argument plist.\nPRM_F_ARGCOUNT    DS  A              | Number of arguments in ARGLIST.\n*\n* Parameters for FunctionCode String_to_Integer.\n*\n                  ORG PRM_FUNCTION_DEPT\nPRM_STI_STRING    DS  A              | Source string of digits.\nPRM_STI_LENGTH    DS  A              | Length of source string.\nPRM_STI_INTEGER   DS  A              | Resulting binary integer.\n                  ORG\n*\n* Parameters for FunctionCode Integer_to_String.\n*\n                  ORG PRM_FUNCTION_DEPT\nPRM_ITS_INTEGER   DS  A              | Integer value to convert.\nPRM_ITS_STRING    DS  A              | Area to place converted integer.\nPRM_ITS_LENGTH    DS  A              | Length of target string.\nPRM_ITS_RESLEN    DS  A              | Length of result.\n                  ORG\n                  END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SRVSTBAK": {"ttr": 34825, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x02\\x00\\x00X\\x01\\x11)\\x9f\\x01\\x11)\\x9f\\t'\\x07u\\x07u\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@\"", "ispf": {"version": "02.00", "flags": 0, "createdate": "2011-10-26T00:00:00", "modifydate": "2011-10-26T09:27:58", "lines": 1909, "newlines": 1909, "modlines": 0, "user": "CLEMSON"}, "text": "*---------------------------------------------------------------------*\n*  Copyright 2011 by Clemson University Research Foundation           *\n*                                                                     *\n*  Licensed under the Apache License, Version 2.0 (the \"License\");    *\n*  you may not use this file except in compliance with the License.   *\n*  You may obtain a copy of the License in this library as member     *\n*  $LICENSE, or from                                                  *\n*                                                                     *\n*      http://www.apache.org/licenses/LICENSE-2.0                     *\n*                                                                     *\n*  Unless required by applicable law or agreed to in writing,         *\n*  software distributed under the License is distributed on an \"AS    *\n*  IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either    *\n*  express or implied.  See the License for the specific language     *\n*  governing permissions and limitations under the License.           *\n*---------------------------------------------------------------------*\nSRVST     TITLE 'String Handler'\n         SRVMOD NAME=SRVST,DATES='1987, 1989, 1995'\n         gblc  &srv_modname\n*---------------------------------------------------------------------*\n*\n*  Copyright (C) Clemson University Research Foundation 1987, 1989.\n*\n*  Program     SRVST, String Handler\n*\n*  Abstract    This server provides common functions for string\n*              manipulation.  Because most high-level languages have\n*              string manipulation functions as part of their\n*              definition, the functions in this server are most useful\n*              for assembler language programs.\n*\n*  Parameters:\n*    Two parameters, StringTkn, and FunctionCode, are required for each\n*    call to the symbol manager.  Additional parameters are required\n*    for different FunctionCodes.  The entire parameter list required\n*    for each function is listed below.\n*\n*    START\n*      CALLX SRVST,(StringTkn,&START,ESV,SizeLength)\n*\n*    TERMINATE\n*      CALLX SRVST,(StringTkn,&TERMINATE)\n*\n*    FORMAT\n*      CALLX SRVST,(StringTkn,&ST_FORMAT,String,StringLen,ResultLen,\n*                    Control,ControlLen,Arg1,...)\n*   or CALLX SRVST,(StringTkn,&ST_FORMAT2,String,StringLen,ResultLen,\n*                    Control,ControlLen,ArgList,ArgCount)\n*\n*    CONVERSION FUNCTIONS\n*      CALLX SRVST,(StringTkn,&ST_STRING_TO_INTEGER,\n*                    String,StringLen,Integer)\n*      CALLX SRVST,(StringTkn,&ST_INTEGER_TO_STRING,\n*                    Integer,String,StringLen,ResultLen)\n*\n*  The meaning of each parameter is explained below.\n*\n*    StringTkn is a fullword used to identify the string session\n*      in progress.  It is initialized during the startup function.\n*\n*    FunctionCode is a fullword integer that specifies the function to\n*      be performed.  Symbolic identifiers are provided for each\n*      function and may be accessed by placing a COPY statement for\n*      SRVSTMAC in the assembler program.  These symbols should be\n*      used in place of actual integer values.  The following\n*      FunctionCodes are supported:\n*\n*      &START\n*        Begin a new string-handler session.  In addition to the\n*        StringTkn and FunctionCode parameters, the parameter ESV\n*        is required and the parameter SizeLength is optional.\n*\n*      &TERMINATE\n*        Terminate the string-handler session identified by StringTkn.\n*\n*      &FORMAT\n*        Build a formatted string based on control information and\n*        supplied arguments.  This function is most useful for\n*        processing messages and lines of output text files.\n*\n*      &STRING_TO_INTEGER\n*        Convert an integer literal to its equivalent fullword signed\n*        binary value.  The literal is an optional sign character\n*        ('+' or '-') followed by a sequence of digits.  Blanks\n*        appearing before or after the sign or digit-sequence are\n*        ignored.\n*\n*  SizeLength\n*    A fullword integer indicating the size, in bytes, of the length\n*    specifier for strings on which the service processor will operate.\n*    It must be 1, 2, 3, or 4 to designate byte, halfword, 3-byte, or\n*    fullword lengths.\n*\n*  String\n*    An area of storage for assembling a string to return to the\n*    calling program, or providing the source data for conversion\n*    from string data to some other data-type.\n*\n*  StringLen\n*    A unsigned <SizeLength> byte integer specifying the length of\n*    the String area.\n*\n*  ResultLen\n*    A an unsigned <SizeLength> byte integer set by the string-handler\n*    to indicate the length of the string returned in String.\n*\n*  Control\n*    A string containing text and imbedded format information that is\n*    used to control the formatting process.  The format information\n*    if used to determine how many Arg-n arguments are needed.\n*\n*  ControlLen\n*    A an unsigned <SizeLength> byte integer specifying the length of\n*    the control string.\n*\n*  Arg1, ...\n*    Data to be formatted.  The type and length of the data is\n*    specified in the control string.\n*\n*  ArgList\n*    References a separatly built variable-length parameter list that\n*    contains the arguments Arg1, Arg2, ....\n*\n*  ArgCount\n*    A fullword integer equal to the number of parameters in ArgList.\n*\n*  Integer\n*    A fullword signed binary integer value that is either input for\n*    a function (i.e. &ST_INTEGER_TO_STRING) or returned by a function\n*    (i.e. &ST_STRING_TO_INTEGER).\n*\n*  Program     reentrant, problem key and state, standard linkage,\n*  Attributes  non-authorized, amode(31), rmode(any)\n*\n*  Change\n*  History     06/05/87 MJM - New\n*              08/09/91 MJM - Added FILL keyword to the format-\n*                             specification syntax to support padding\n*                             to the right with a specified or default\n*                             value.  The default fill string is \" .\".\n*              02/06/92 MJM - Added C1ST keyword: capitalize 1st letter\n*                             of a character field.\n*              06/03/93 MJM - Added optional numeric operand after any\n*                             question-mark in a format specification,\n*                             which if specified overrides sizelength:\n*                             {CL?2} means that the length of the data\n*                             is in a halfword, regardless of the value\n*                             specified for SIZELENGTH on startup.\n*             2001-08-05 mjm  Updated FIND_CONTROL_CHARACTER to use a\n*                             simple loop when searching for a control\n*                             character--faster in practise than TRTs.\n*             2006-06-01      Made changes required for compatibility\n*                             with ARCHLVL=1.\n*\n*---------------------------------------------------------------------\n EJECT\n*\n* COPY statements for SMSYMS, SRVESMAC, and SRVSTMAC.\n*\n PRINT   OFF\n   COPY  SMSYMS               | Copy Structured Macros symbols.\n   COPY  SMPUCOND             | Copy User-conditions.\n   COPY  SRVESMAC             | Copy Environment Support symbols.\n   COPY  SRVSTMAC             | Copy String Handler symbols.\n PRINT   ON\n EJECT\n*---------------------------------------------------------------------*\n* Main program - Uses the FunctionCode to invoke the right function.\n*---------------------------------------------------------------------*\n BLOCK NAME=&srv_modname,TYPE=PROGRAM,AMODE=31,RMODE=ANY,R1SAVE=R11,   +\n               OPTIONS=(*SRVPRC,NOVL,LONG),                            +\n               SUBOPTS=(*SWA,LOADBASE)\n   USING   PARMLIST,R11         | Establish addressability.\n   MVC     GDIRC,=H'0'          | Initialize the return-code.\n*---------------------------------------------------------------------*\n*  Count the number of parameters passed in.\n*---------------------------------------------------------------------*\n   LA   R1,PARMLIST                   | R1 -> first parameter.\n   LOOP WHILE,(TBIT,0(R1),X'80',OFF)  | Loop over parameters.\n     LA R1,4(,R1)                     |   Advance to next parameter.\n   ENDLOOP WHILE                      | EndLoop.\n   LA  R1,4(,R1)                      | Point past final parameter.\n   SLR R1,R11                         | Get length of entire parmlist.\n   SRL R1,2                           | Get number of parameters.\n   ST  R1,&PWA.#PARMS                 | Save in PWA for future use.\n*---------------------------------------------------------------------*\n*  Use the function code to determine what routine to invoke.\n*---------------------------------------------------------------------*\n   L       R1,PRM_FUNCTIONCODE  | Load the function code into\n   L       R1,0(,R1)            |   a register for testing.\n   CASEBLK REG=R1               | Case on FunctionCode.\n     CASE &START                |   Start a new string handler session.\n       CALLSUB START_STRING_HANDLER\n     CASE &TERMINATE            |   Destroy an existing symbol table.\n       SMCTRL FREEPWA=YES       |     Free the PWA on return.\n     CASE &ST_FORMAT,&ST_FORMAT2    Format a string for output.\n       CALLSUB FORMAT_STRING    |\n     CASE &ST_INTEGER_TO_STRING |   Convert a fullword to a string.\n       CALLSUB INTEGER_TO_STRING\n     CASE &ST_STRING_TO_INTEGER |   Convert a string to a fullword.\n       CALLSUB STRING_TO_INTEGER,     Invoke conversion function with: +\n               (*PRM_STI_STRING,        Source text of integer,        +\n               *PRM_STI_LENGTH,         Length of source text, and     +\n               *PRM_STI_INTEGER)        Return-integer area.\n       ERREXIT (TREG,R15,NZ),CODE=00  Errexit w/R15 as return-code.\n     CASE OTHER                 |   Invalid Function Code.\n       ERREXIT CODE=&ST_INVALID_FUNCTION\n   ENDCASE                      | EndCase.\n   LH   R15,GDIRC               | Pick up non-terminating RC.\n ENDBLK BLOCK=&srv_modname,RC=(R15)\n EJECT\n***********************************************************************\n*                                                                     *\n*  Subroutine: START_STRING_HANDLER                                   *\n*  Abstract:   Begin a new string handler session, establishing the   *\n*              size of string-length values (halfword lengths, etc).  *\n*                                                                     *\n***********************************************************************\n BLOCK TYPE=SUBROUTINE,NAME=START_STRING_HANDLER\n*---------------------------------------------------------------------*\n*  Process the optional SIZELENGTH parameter.\n*---------------------------------------------------------------------*\n   LA  R1,2                       | Default := halfword lengths.\n   IF  (CLC,&PWA.#PARMS,GE,=F'4') | If SizeLength parameter present.\n     L  R1,PRM_S_SIZELENGTH       |   R1 -> SizeLength's Value.\n     LA R1,0(,R1)                 |   Clear high-bit.\n     IF (TREG,R1,NZ)              |   If SizeLength specified.\n       L R1,0(R1)                 |     R1 := SizeLength's Value.\n       ERREXIT ((C,R1,LT,=F'1'),OR,(C,R1,GT,=F'4')),                   +\n               CODE=&ST_INVALID_SIZELENGTH\n     ENDIF                        |   EndIf.\n   ENDIF                          | EndIf.\n   ST R1,&PWA.SIZELENGTH          | Save sizelength's value.\n   S  R1,=F'1'                    | R1 := offset into bit-mask array.\n   LA R1,&PSD.BIT_MASK(R1)        | R1 -> bit-mask for ICM/STCM's.\n   L8 R0,0(R1)                    | R0 := bit-mask for ICM/STCM's.\n   ST R0,&PWA.SIZEMASK            | Save for getting/setting lengths.\n ENDBLK BLOCK=START_STRING_HANDLER\n EJECT\n***********************************************************************\n*                                                                     *\n*  Subroutine: FORMAT_STRING                                          *\n*  Abstract:   See \"Service Processors User's Guide and Reference\",   *\n*              ST_FORMAT function for a description of this routine.  *\n*                                                                     *\n***********************************************************************\n BLOCK NAME=FORMAT_STRING,TYPE=SUBROUTINE\n   L       R6,&PWA.#PARMS         | R6 := number of parameters passed.\n   ERREXIT (C,R6,LT,=F'7'),CODE=&ST_WRONG_NUMBER_OF_PARAMETERS\n*---------------------------------------------------------------------*\n*  Initialize PWA variables for tracking the Control string position.\n*---------------------------------------------------------------------*\n   L   R1,PRM_F_CONTROL           | R1 -> Control string.\n   L   R2,PRM_F_CONTROL_LEN       | R2 -> Control string's length.\n   SLR R3,R3                      | Clear for the ICM below.\n   L   R15,&PWA.SIZEMASK          | R15 := length-mask.\n   EXI R15,(ICM,R3,0,0(R2))       | R3 := Length of control string.\n   SL  R3,=F'1'                   | R3 := Offset to last byte.\n   ALR R3,R1                      | R3 -> Last byte.\n   ST  R1,&PWA.CONTROL_START      | Save start-of-control address.\n   ST  R1,&PWA.CONTROL_CURRENT    | Save current Control position.\n   ST  R3,&PWA.CONTROL_END        | Save end-of-control address.\n*---------------------------------------------------------------------*\n*  Initialize PWA variables for tracking the String position.\n*---------------------------------------------------------------------*\n   L   R1,PRM_F_STRING            | R1 -> target String.\n   L   R2,PRM_F_STRING_LEN        | R2 -> Length of target String.\n   SLR R3,R3                      | Clear R3 for ICM below.\n   L   R15,&PWA.SIZEMASK          | R15 := length-mask.\n   EXI R15,(ICM,R3,0,0(R2))       | R3 := Length of String area.\n   SL  R3,=F'1'                   | R3 := Offset to last byte.\n   ALR R3,R1                      | R3 -> Last byte.\n   ST  R1,&PWA.STRING_START       | Save start-of-String address.\n   ST  R1,&PWA.STRING_CURRENT     | Save Current String position.\n   ST  R1,&PWA.STRING_HIGHWATER   | Save Highwater String position.\n   ST  R3,&PWA.STRING_END         | Save End of String address.\n*---------------------------------------------------------------------*\n*  Initialize PWA variables for tracking the current Argument.\n*---------------------------------------------------------------------*\n   L   R1,PRM_FUNCTIONCODE            | R1 -> Function code passed in.\n   L   R1,0(,R1)                      | R1 := Function code.\n*                                     |\n   S   R6,=F'7'                       | R6 := #parms after control_len.\n   IF  (TREG,R6,NP)                   | If no <argument>s passed in.\n     SLR  R7,R7                       |   R7 -> null parameter list.\n   ELSEIF (C,R1,EQ,=F'&ST_FORMAT')    | ElseIf FORMAT parmlist.\n     LA   R7,PRM_F_ARGLIST            |   R7 -> First argument.\n   ELSEIF (C,R1,EQ,=F'&ST_FORMAT2')   | ElseIf FORMAT2 parmlist.\n     IF (C,R6,NE,=F'2')               |   If ArgCount is missing.\n       ERREXIT CODE=&ST_WRONG_NUMBER_OF_PARAMETERS\n     ELSE                             |   Else.\n       L   R6,PRM_F_ARGCOUNT          |     R6 -> Number of arguments.\n       IF  (TREG,R6,NZ)               |     If parameter not missing.\n         L  R6,0(,R6)                 |       R6 := number <arguments>.\n       ENDIF                          |     EndIf.\n       L   R7,PRM_F_ARGLIST           |     R7 -> First argument.\n     ENDIF                            |   EndIf.\n   ENDIF                              | EndIf.\n*                                     |\n   STM R6,R7,&PWA.ARGUMENT_LIST       | Save <arg> count/address.\n   EJECT\n*---------------------------------------------------------------------*\n*  Loop over the Control string to produce the result in String.\n*---------------------------------------------------------------------*\n   LOOP UNTIL                     | Loop over control string.\n     L       R2,&PWA.CONTROL_CURRENT            R2 -> Current txt.\n     LEAVE   LOOP=*,(C,R2,GT,&PWA.CONTROL_END)  Done if @ end.\n     CALLSUB FIND_CONTROL_CHARACTER,('{',&W.TEXT_LENGTH)\n     L       R3,&W.TEXT_LENGTH    |             R3 := Length to '{'.\n     CALLSUB COPY_TO_STRING,((R2),(R3))         Copy text.\n     ALR     R2,R3                |             R2 -> Format-spec.\n     ST      R2,&PWA.CONTROL_CURRENT            Update Current pos.\n     LEAVE   LOOP=*,(C,R2,GT,&PWA.CONTROL_END)  Done if @ end.\n     CALLSUB PROCESS_FORMAT_SPECIFICATION       Format data.\n   ENDLOOP UNTIL,LEAVE            | EndLoop.\n   L   R2,&PWA.STRING_HIGHWATER   | R2 := Last byte formatted, + 1.\n   SL  R2,&PWA.STRING_START       | R2 := Length formatted.\n   L   R1,PRM_F_FMT_LEN           | R1 -> Formatted string length parm.\n   IF  (TREG,R1,NZ)               | If parameter is not missing.\n     L   R15,&PWA.SIZEMASK        |   R15 := length-mask.\n     EXI R15,(STCM,R2,0,0(R1))    |   Save as target string's length.\n   ENDIF                          | EndIf.\n ENDBLK BLOCK=FORMAT_STRING\n*---------------------------------------------------------------------*\n* Working storage for the ST_FORMAT function.\n*---------------------------------------------------------------------*\n                SWA\n&W.TEXT_LENGTH  DS    F    | Length of text up to format-specification.\n                ENDSWA\n                EJECT\n**********************************************************************\n*                                                                    *\n*  Subroutine: FIND_CONTROL_CHARACTER,(Char,OffsetFromCurrent)       *\n*  Abstract:   Using the &PWA.CONTROL_xxx markers, scan the Control  *\n*              string from the current position towards the end to   *\n*              locate the next occurance of the specified character. *\n*              Return the offset from &PWA.CONTROL_CURRENT to the    *\n*              located character. (The offset can also be thought of *\n*              as the length of the Control string's text up to the  *\n*              character).  If the character is not found, it will   *\n*              be assumed to magically have been appended to the end *\n*              of the Control string.                                *\n*                                                                    *\n**********************************************************************\n BLOCK TYPE=SUBROUTINE,NAME=FIND_CONTROL_CHARACTER\n   LM    R8,R9,0(R1)                | R8->Char, R9->OffsetFromCurrent.\n*---------------------------------------------------------------------*\n*  Point R1 (via the TRT instruction) to the next control character\n*  or past the end of the entire control string if there is not one.\n*---------------------------------------------------------------------*\n   L     R7,&PWA.CONTROL_CURRENT    | R7 -> Current Control position.\n   L     R6,&PWA.CONTROL_END        | R6 -> Last control byte.\n*\n*  Scan loop below does the same thing as the TRTs below.  It\n*  is shorter, but is it faster? NO! STROBE SAYS IT TAKES LONGER.\n*\n*  LR    R1,R7                      | R1 -> CURRENT CONTROL CHARACTER.\n*  LOOP  WHILE,(CR,R1,LE,R6),AND,(CLC,0(1,R1),NE,0(R8))\n*   LA   R1,1(,R1)                  |\n*  ENDLOOP WHILE                    |\n*  SLR   R1,R7                      | R1 := OFFSETFROMCURRENT.\n*  ST    R1,0(,R9)                  | SAVE IN CALLER'S PARM.\n*  LEAVE BLOCK=*                    | RETURN TO CALLER.\n*\n   SR    R6,R7                      | R6 := length remaining - 1.\n   LA    R6,1(,R6)                  | R6 := Length remaining.\n   LR    R5,R7                      | R5 -> Current control character.\n   L8    R4,0(R8)                   | R4 := Desired character.\n   LA    R4,&PWA.TRANTAB(R4)        | R4 -> Table position.\n   MVI   0(R4),X'FF'                | Flag as character we want.\n   LOOP  WHILE,(C,R6,GT,=F'256')    | Scan in 256-byte chunks.\n     TRT   0(256,R5),&PWA.TRANTAB   |   Scan for wanted character.\n     LEAVE LOOP=*,NZ                |   Exit if found.\n     A     R5,=F'256'               |   Advance to next 256-byte chunk.\n     S     R6,=F'256'               |   Subtract length covered.\n   ENDLOOP WHILE                    | EndLoop.\n   IF (C,R6,LE,=F'256')             | If Char was NOT found,\n     BCTR R6,0                      |   Subtract 1 for the EX instr.\n     EXI  R6,(TRT,0(0,R5),&PWA.TRANTAB) Scan for wanted Char.\n     IF   Z,THEN                    |   If NOT found then\n       L  R1,&PWA.CONTROL_END       |     R1 -> last byte in control.\n       A  R1,=F'1'                  |     R1 -> past end of control.\n     ENDIF                          |   EndIf.\n   ENDIF                            | EndIf.\n   MVI   0(R4),X'00'                | Reset translate table character.\n*---------------------------------------------------------------------*\n*  Calculate the offset from &PWA.CONTROL_CURRENT to 0(R1) and return.\n*---------------------------------------------------------------------*\n   SLR  R1,R7                       | R1 := Offset to '{' character.\n   ST   R1,0(,R9)                   | Save as OffsetFromCurrent.\n ENDBLK BLOCK=FIND_CONTROL_CHARACTER\n EJECT\n**********************************************************************\n*                                                                    *\n*  Subroutine: PROCESS_FORMAT_SPECIFICATION                          *\n*  Abstract:   When this routine is called, &PWA.CONTROL_CURRENT     *\n*              points to the start of a format specification.  This  *\n*              routine decodes the entire specification, updates     *\n*              &PWA.CONTROL_CURRENT to the position following the    *\n*              format specification, and then performs the indicated *\n*              formatting function.                                  *\n*                                                                    *\n**********************************************************************\n BLOCK NAME=PROCESS_FORMAT_SPECIFICATION,TYPE=SUBROUTINE\n   L       R8,&PWA.CONTROL_CURRENT       | R8 -> Current position.\n   LA      R8,1(,R8)                     | R8 -> Past initial '{' char.\n   ERREXIT (CL,R8,GT,&PWA.CONTROL_END),CODE=&ST_FORMAT_SPEC_NOT_ENDED\n   ST      R8,&PWA.FS_CURRENT            | Set current fmt-spec pos.\n*---------------------------------------------------------------------*\n*  If it is the special format specification '{{', process it now.\n*---------------------------------------------------------------------*\n   IF (CLI,0(R8),EQ,C'{')                | If spec is equal to '{{'.\n     LA      R7,1                        |   R7 := length to copy.\n     CALLSUB COPY_TO_STRING,((R8),(R7))  |   Copy 1 '{'.\n     LA      R8,1(,R8)                   |   R8 -> Past '{{'.\n     ST      R8,&PWA.CONTROL_CURRENT     |   Update Control position.\n     LEAVE   BLOCK=*                     |   Return to caller.\n   ENDIF                                 | EndIf.\n*--------------------------------------------------------------------*\n*  Find the end of the format specification and decode its contents.\n*---------------------------------------------------------------------*\n   CALLSUB FIND_CONTROL_CHARACTER,('}',&PWA.FS_LENGTH)\n   L       R9,&PWA.CONTROL_CURRENT       | R9 -> '{' character.\n   AL      R9,&PWA.FS_LENGTH             | R9 -> '}' character.\n   ERREXIT (CL,R9,GT,&PWA.CONTROL_END),CODE=&ST_FORMAT_SPEC_NOT_ENDED\n   BCTR    R9,0                          | R9 -> Before final '}' char.\n   ST      R9,&PWA.FS_END                | Save end of spec position.\n   MVI     &PWA.FS_FIELDS,X'00'          | No fields specified so far.\n*                                        |\n   CALLSUB GETFMT_LEADING_PAD            | Scan leading '0' field.\n   CALLSUB GETFMT_WIDTH                  | Scan width field.\n   CALLSUB GETFMT_PRECISION              | Scan .precision field.\n   CALLSUB GETFMT_COLUMN                 | Scan @column field.\n   CALLSUB GETFMT_TYPE                   | Scan Type field.\n   CALLSUB GETFMT_LENGTH                 | Scan Length field.\n   CALLSUB GETFMT_KEYWORDS               | Scan Keywords field.\n*                                        |\n   LA      R8,2(,R9)                     | R8 -> Past '}' character.\n   ST      R8,&PWA.CONTROL_CURRENT       | Update Control position.\n*---------------------------------------------------------------------*\n*  Check to make sure that things were specified right.\n*---------------------------------------------------------------------*\n   IF (TBIT,&PWA.FS_FIELDS,&PWA.FSF_TYPE,OFF)  | If type not specified.\n     IF (CLI,&PWA.FS_FIELDS,EQ,X'00')          |   If nothing there.\n       ERREXIT CODE=&ST_FORMAT_SPEC_EMPTY      |     Invalid fmt-spec.\n     ELSEIF (CLI,&PWA.FS_FIELDS,NE,&PWA.FSF_COLUMN) If not {@column}.\n       ERREXIT CODE=&ST_FORMAT_TYPE_REQUIRED   |     Invalid fmt-spec.\n     ENDIF                                     |   EndIf.\n   ENDIF                                       | EndIf.\n   EJECT\n*---------------------------------------------------------------------*\n*  Perform column-adjustment based on the @column format specification.\n*---------------------------------------------------------------------*\n   CALLSUB ADJUST_COLUMN_POSITION\n   LEAVE   BLOCK=*,(CLI,&PWA.FS_FIELDS,EQ,&PWA.FSF_COLUMN)\n*---------------------------------------------------------------------*\n*  Format the source argument.\n*---------------------------------------------------------------------*\n   L32     R7,&PWA.FSV_TYPE            | R7 := Type-index.\n   USING   TYPE_ENTRY,R7               | Establish addressability.\n   IF (TBIT,&PWA.FSV_KEYWORDS,&PWA.FSV_LEFT+&PWA.FSV_CENTER+&PWA.FSV_RI+\n               GHT,OFF),THEN           | If LEFT/CENTER/RIGHT all off.\n     OC &PWA.FSV_KEYWORDS,TE_JUSTIFY   |   Set default justification.\n   ENDIF                               | EndIf.\n   L32     R15,TE_ROUTINE              | R15 -> Formatting routine.\n   BASR    R14,R15                     | Format source data.\n ENDBLK BLOCK=PROCESS_FORMAT_SPECIFICATION\n EJECT\n**********************************************************************\n*                                                                    *\n*  Subroutine: GETFMT_LEADING_PAD                                    *\n*  Abstract:   Obtain the leading pad character.                     *\n*                                                                    *\n**********************************************************************\n BLOCK TYPE=SUBROUTINE,NAME=GETFMT_LEADING_PAD\n   L       R8,&PWA.FS_CURRENT          | R8->Current. R9->Limit.\n   LEAVE   BLOCK=*,(C,R8,GT,&PWA.FS_END) Return if past end.\n*                                      |\n   MVI &PWA.FSV_LEADING_PAD,C' '       | Set default pad character.\n   IF  (CLI,0(R8),EQ,C'0')             | If padding with zeros.\n     LA   R8,1(,R8)                    |   Point past the '0'.\n     ST   R8,&PWA.FS_CURRENT           |   Update current position.\n     MVI  &PWA.FSV_LEADING_PAD,C'0'    |   Set pad character.\n     SBIT &PWA.FS_FIELDS,&PWA.FSF_LEADING_PAD\n   ENDIF                               | EndIf.\n ENDBLK BLOCK=GETFMT_LEADING_PAD       |\n**********************************************************************\n*                                                                    *\n*  Subroutine: GETFMT_WIDTH                                          *\n*  Abstract:   Obtain the width field of a format-specification.     *\n*                                                                    *\n**********************************************************************\n BLOCK TYPE=SUBROUTINE,NAME=GETFMT_WIDTH\n   L       R8,&PWA.FS_CURRENT              | R8->Current. R9->Limit.\n   LEAVE   BLOCK=*,(C,R8,GT,&PWA.FS_END)   | Return if past end.\n   CALLSUB GETFMT_INTEGER,(&PWA.FSV_WIDTH) | Parse <digits> or '?'.\n   IF (TREG,R15,Z)                         | If a value was obtained.\n     SBIT &PWA.FS_FIELDS,&PWA.FSF_WIDTH    |   Width was specified.\n   ELSE                                    | Else not specified.\n     MVC  &PWA.FSV_WIDTH,=F'0'             |   Set default width.\n   ENDIF                                   | EndIf.\n ENDBLK BLOCK=GETFMT_WIDTH\n**********************************************************************\n*                                                                    *\n*  Subroutine: GETFMT_PRECISION                                      *\n*  Abstract:   Obtain the precision field of a format-specification. *\n*                                                                    *\n**********************************************************************\n BLOCK TYPE=SUBROUTINE,NAME=GETFMT_PRECISION\n   L       R8,&PWA.FS_CURRENT              | R8->Current. R9->Limit.\n   LEAVE   BLOCK=*,(C,R8,GT,&PWA.FS_END)   | Return if past end.\n   LEAVE   BLOCK=*,(CLI,0(R8),NE,C'.')     | Leave if no .precision.\n   SBIT    &PWA.FS_FIELDS,&PWA.FSF_PRECISION .precision was specified.\n   LA      R8,1(,R8)                       | Advance past the '.'.\n   ST      R8,&PWA.FS_CURRENT              | Update current position.\n*\n   CALLSUB GETFMT_INTEGER,(&PWA.FSV_PRECISION)\n   ERREXIT (TREG,R15,NZ),CODE=&ST_FORMAT_MISSING_PRECISION_VALUE\n   L32     R1,&PWA.FSV_PRECISION\n   ERREXIT NP,CODE=&ST_FORMAT_PRECISION_TOO_SMALL\n ENDBLK BLOCK=GETFMT_PRECISION\n EJECT\n**********************************************************************\n*                                                                    *\n*  Subroutine: GETFMT_COLUMN                                         *\n*  Abstract:   Obtain the column field of a format-specification.    *\n*                                                                    *\n**********************************************************************\n BLOCK TYPE=SUBROUTINE,NAME=GETFMT_COLUMN\n   L       R8,&PWA.FS_CURRENT              | R8->Current. R9->Limit.\n   LEAVE   BLOCK=*,(C,R8,GT,&PWA.FS_END)   | Return if past end.\n   LEAVE   BLOCK=*,(CLI,0(R8),NE,C'@')     | Return if @column \u00acthere.\n   SBIT    &PWA.FS_FIELDS,&PWA.FSF_COLUMN  | @column field is present.\n   MVI     &PWA.FSV_COLUMN,C'@'            | Default = EndOfString.\n   LA      R8,1(,R8)                       | Advance to next char.\n   ST      R8,&PWA.FS_CURRENT              | Update current position.\n   LEAVE   BLOCK=*,(C,R8,GT,&PWA.FS_END)   | Leave if past end.\n*                                          |\n   IF (CLI,0(R8),EQ,C'+'),OR,(CLI,0(R8),EQ,C'-')\n     MVC   &PWA.FSV_COLUMN(1),0(R8)        |   Relative Column#.\n     LA    R8,1(,R8)                       |   Advance to next char.\n     ST    R8,&PWA.FS_CURRENT              |   Update current position.\n   ENDIF                                   | EndIf.\n*                                          |\n   CALLSUB GETFMT_INTEGER,(&PWA.FSV_COLUMN+1)\n*                                          |\n   IF (TREG,R15,NZ)                        | If no value was specified.\n     IF (CLI,&PWA.FSV_COLUMN,NE,C'@')      |   If +/- was specified.\n       ERREXIT CODE=&ST_FORMAT_MISSING_COLUMN_VALUE\n     ENDIF                                 |   EndIf.\n   ELSEIF (CLI,&PWA.FSV_COLUMN,EQ,C'@')    | ElseIf not relative col#.\n     MVI &PWA.FSV_COLUMN,C'='              |   Set to absolute column#.\n   ENDIF                                   | EndIf.\n ENDBLK BLOCK=GETFMT_COLUMN\n EJECT\n**********************************************************************\n*                                                                    *\n*  Subroutine: GETFMT_TYPE                                           *\n*  Abstract:   Obtain the type field of a format-specification.      *\n*                                                                    *\n**********************************************************************\n BLOCK TYPE=SUBROUTINE,NAME=GETFMT_TYPE\n   L       R8,&PWA.FS_CURRENT              | R8->Current. R9->Limit.\n   LEAVE   BLOCK=*,(C,R8,GT,&PWA.FS_END)   | Leave if past end.\n   SBIT    &PWA.FS_FIELDS,&PWA.FSF_TYPE    | Type *must* be there.\n*                                          |\n   LM     R15,R1,=A(&PSD.TYPES-TYPE_ENTRY_L,TYPE_ENTRY_L,&PSD.TYPES_E)\n   USING  TYPE_ENTRY,R15                   | Establish addressability.\n   LOOP   BXH,R15,R0                       | Loop over valid types.\n     LEAVE LOOP=*,(CLC,TE_CHAR,EQ,0(R8))   |   Leave if valid type.\n   ENDLOOP BXH                             | EndLoop.\n   ERREXIT (CR,R15,GT,R1),CODE=&ST_FORMAT_UNSUPPORTED_TYPE\n   STCM    R15,B'1111',&PWA.FSV_TYPE       | Save type's entry address.\n*                                          |\n   IF (CLI,&PWA.FSV_LEADING_PAD,EQ,C'0')   | If leading pad = '0'.\n     IF (C,R15,NE,=A(&PSD.TYPE_I)),AND,    |   If not signed-integer or+\n               (C,R15,NE,=A(&PSD.TYPE_U)),AND,   unsigned-integer or   +\n               (C,R15,NE,=A(&PSD.TYPE_A))  |     address.\n       ERREXIT CODE=&ST_FORMAT_PAD_TYPE_CONFLICT   Illegal pad-char.\n     ENDIF                                 |   EndIf.\n   ENDIF                                   | EndIf.\n*                                          |\n   LM R2,R3,&PWA.ARGUMENT_LIST             | R2:=count, R3->current.\n   IF (TREG,R2,NP),OR,(TREG,R3,Z),THEN     | If no more <arguments>.\n     ERREXIT CODE=&ST_FORMAT_MISSING_ARGUMENT  Exit with error code.\n   ENDIF                                   | EndIf.\n   MVC     &PWA.FSV_SOURCE,0(R3)           | Copy <argument> address.\n   LA      R3,4(,R3)                       | Point to next <argument>.\n   BCTR    R2,0                            | Subtract 1 from count.\n   STM     R2,R3,&PWA.ARGUMENT_LIST        | Update current arg.\n*                                          |\n   LA      R8,1(,R8)                       | Advance to next char.\n   ST      R8,&PWA.FS_CURRENT              | Update current position.\n ENDBLK BLOCK=GETFMT_TYPE\n EJECT\n**********************************************************************\n*                                                                    *\n*  Subroutine: GETFMT_LENGTH                                         *\n*  Abstract:   Obtain the length field of a format-specification.    *\n*                                                                    *\n**********************************************************************\n BLOCK TYPE=SUBROUTINE,NAME=GETFMT_LENGTH\n   L     R8,&PWA.FS_CURRENT                  | R8->Current. R9->Limit.\n   L32   R7,&PWA.FSV_TYPE                    | R7 -> Type Entry.\n   USING TYPE_ENTRY,R7                       | Get addressability.\n   MVC   &PWA.FSV_LENGTH,TE_DEFAULT          | Set default length.\n   LEAVE BLOCK=*,((C,R8,GT,&PWA.FS_END),OR,(CLI,0(R8),NE,C'L'))\n*                                            |\n   SBIT    &PWA.FS_FIELDS,&PWA.FSF_LENGTH    | Llength was specified.\n   LA      R8,1(,R8)                         | Advance past the 'L'.\n   ST      R8,&PWA.FS_CURRENT                | Update position.\n   CALLSUB GETFMT_INTEGER,(&PWA.FSV_LENGTH)  | Obtain integer value.\n   ERREXIT (TREG,R15,NZ),CODE=&ST_FORMAT_MISSING_LENGTH_VALUE\n   L32     R1,&PWA.FSV_LENGTH                | R1 := Specified len.\n   ERREXIT M,CODE=&ST_FORMAT_LENGTH_TOO_SMALL\n   ERREXIT (CLM,R1,B'1111',LT,TE_MIN),CODE=&ST_FORMAT_LENGTH_TOO_SMALL\n   ERREXIT (CLM,R1,B'1111',GT,TE_MAX),CODE=&ST_FORMAT_LENGTH_TOO_LARGE\n ENDBLK BLOCK=GETFMT_LENGTH\n EJECT\n**********************************************************************\n*                                                                    *\n*  Subroutine: GETFMT_KEYWORDS                                       *\n*  Abstract:   Obtain the keywords field of a format-specification.  *\n*                                                                    *\n**********************************************************************\n BLOCK TYPE=SUBROUTINE,NAME=GETFMT_KEYWORDS\n   MVI   &PWA.FSV_KEYWORDS,X'00'         | Reset all keyword flags.\n   L     R8,&PWA.FS_CURRENT              | R8->Current position.\n   LEAVE BLOCK=*,(C,R8,GT,&PWA.FS_END)   | Leave if past end.\n*                                        |\n   IF (CLI,0(R8),NE,C' '),THEN           | If no blank after TYPE.\n     ERREXIT CODE=&ST_FORMAT_UNSUPPORTED_ITEM\n   ENDIF                                 | EndIf.\n   LA   R8,1(,R8)                        | Advance past 1st blank.\n*                                        |\n   LOOP NAME=KWD_LOOP,WHILE,(C,R8,LE,&PWA.FS_END)\n     LOOP WHILE,(CLI,0(R8),EQ,C' ')      |   Scan for a non-blank.\n       LA    R8,1(,R8)                   |     Advance to next char.\n       LEAVE LOOP=KWD_LOOP,(C,R8,GT,&PWA.FS_END)\n     ENDLOOP WHILE                       |   EndLoop.\n     SBIT  &PWA.FS_FIELDS,&PWA.FSF_KEYWORDS  At least one KWD.\n*                                        |\n     LR   R7,R8                          |   Use R7 to find end-of-kwd.\n     LOOP WHILE,(C,R7,LE,&PWA.FS_END)    |   Scan for a delimiter.\n       L8    R1,0(R7)                    |     R1 := actual character.\n       LA    R1,CLASSIFICATION(R1)       |     R1 -> char's class.\n       LEAVE LOOP=*,(CLI,0(R1),EQ,DELIMITER)   Leave if delimiter.\n       LA    R7,1(,R7)                   |     Advance to next char.\n     ENDLOOP WHILE                       |   EndLoop.\n     SLR     R7,R8                       |   R7 := keyword's length.\n     ERREXIT (TREG,R7,NP),CODE=&ST_FORMAT_UNSUPPORTED_ITEM\n*                                        |\n     LA   R14,GFK_TABLE                  |   R14 -> Keyword table.\n     LR   R15,R7                         |   Use R15 for Executed\n     BCTR R15,0                          |     comparison instructions.\n     LOOP WHILE,(CLI,0(R14),NE,X'00')    |   Loop over keywords.\n       IF (C,R7,LE,=F'256'),AND,(CLM,R7,B'0001',EQ,1(R14))\n         EXI   R15,(CLC,0(0,R8),2(R14))  |     Compare keyword entry.\n         LEAVE LOOP=*,EQ                 |     Leave loop if match.\n       ENDIF                             |   EndIf.\n       L8    R1,1(R14)                   |   R1 := keyword's length.\n       LA    R14,2(R1,R14)               |   R14 -> Next table entry.\n     ENDLOOP WHILE                       |   EndLoop.\n*                                        |\n     ERREXIT (CLI,0(R14),EQ,X'00'),CODE=&ST_FORMAT_UNSUPPORTED_KEYWORD\n     OC &PWA.FSV_KEYWORDS,0(R14)         |   Set keyword's flag.\n     LA R8,0(R7,R8)                      |   Advance past the word.\n     ST R8,&PWA.FS_CURRENT               |   Save current position.\n*                                        |\n     IF (TBIT,&PWA.FSV_KEYWORDS,&PWA.FSV_FILL) If FILL keyword\n       CALLSUB GETFMT_FILL_OPERANDS      |     Get optional operand(s).\n       L       R8,&PWA.FS_CURRENT        |     Obtain new position.\n       IF      (%L32,R1,&PWA.FSV_FILL_LENGTH,NP)  If no valid filler.\n         MVC &PWA.FSV_FILL_LENGTH,=F'2'  |          Set default filler\n         MVC &PWA.FSV_FILL_VALUE(2),=C' .'          to FILL( .)\n       ENDIF                             |        EndIf.\n     ENDIF                               |   EndIf.\n   ENDLOOP WHILE                         | EndLoop.\n   ST R8,&PWA.FS_CURRENT                 | Save current position.\n ENDBLK BLOCK=GETFMT_KEYWORDS\n EJECT\n*---------------------------------------------------------------------*\n*  Local static data for a keyword-table.\n*---------------------------------------------------------------------*\n           SSD\n           MACRO\n&LABEL     KEYWORD &NUMBER,&STRING\n           AIF  ('&STRING' EQ '').NULLSTR\n&LABEL     DC   AL1(&NUMBER,L'STR&SYSNDX)\nSTR&SYSNDX DC   C&STRING\n           MEXIT\n.NULLSTR   ANOP\n&LABEL     DC   AL1(0,0)\n           MEND\nGFK_TABLE  DS   0X\n           KEYWORD &PWA.FSV_LEFT,'LEFT'\n           KEYWORD &PWA.FSV_RIGHT,'RIGHT'\n           KEYWORD &PWA.FSV_TRIM,'TRIM'\n           KEYWORD &PWA.FSV_TRIM,'T'\n           KEYWORD &PWA.FSV_RELATIVE,'RELATIVE'\n           KEYWORD &PWA.FSV_RELATIVE,'REL'\n           KEYWORD &PWA.FSV_RELATIVE,'R'\n           KEYWORD &PWA.FSV_CAPS,'CAPITALIZE'\n           KEYWORD &PWA.FSV_CAPS,'CAPS'\n           KEYWORD &PWA.FSV_C1ST,'C1ST'\n           KEYWORD &PWA.FSV_CENTER,'CENTER'\n           KEYWORD &PWA.FSV_FILL,'FILL'\n           KEYWORD &PWA.FSV_FILL,'F'\n           KEYWORD 0\n           ENDSSD\n           EJECT\n**********************************************************************\n*                                                                    *\n* Subroutine : GETFMT_FILL_OPERANDS                                  *\n* Abstract   : Scan from Current up to (but not including) End to    *\n*              extract any operands to the FILL keyword in a         *\n*              format-specification.  The syntax being parsed is     *\n*              FILL\u00dd(string)\u00a8  where                                 *\n*                                                                    *\n*                string => word                                      *\n*                        | ?\u00ddL\u00dd1 | nn | ?\u00a8\u00a8 /* default length: 1 */  *\n*                        | \u00ddC|X\u00a8\"string\"    /* default type  : C */  *\n*                word   => any character sequence that does not look *\n*                          like anything else.                       *\n*                                                                    *\n*              Either single or double quotes may be used to delimit *\n*              string, so long as they are matched properly.  If a   *\n*              quote of the same type as the delimiter is used w/in  *\n*              the string, two quotes must be used to represent one. *\n*                                                                    *\n*              The maximum length for a fill value from any source   *\n*              is 256 bytes.  A zero-length filler is replaced by    *\n*              the default fill string: \" .\".                        *\n*                                                                    *\n**********************************************************************\n BLOCK NAME=GETFMT_FILL_OPERANDS,TYPE=SUBROUTINE\n   L      R8,&PWA.FS_CURRENT             | R8->Current position.\n   LEAVE  BLOCK=*,(C,R8,GT,&PWA.FS_END)  | Leave if past end.\n   LEAVE  BLOCK=*,(CLI,0(R8),NE,C'(')    | Leave if no operands.\n*                                        |\n   LA   R8,1(,R8)                        | R8 -> Past opening paren.\n   LA   R7,0(,R8)                        | Use R7 to find non-blank.\n   LOOP WHILE,(C,R7,LE,&PWA.FS_END)      | Scan for a non-blank.\n     LEAVE LOOP=*,(CLI,0(R7),NE,C' ')    |   Leave if one found.\n     LA    R7,1(,R7)                     |   Advance to next char.\n   ENDLOOP WHILE                         | EndLoop.\n   LA   R6,1(,R7)                        | Use R6 to find end-of-fill.\n   LOOP WHILE,(C,R6,LE,&PWA.FS_END)      | Scan for a closing paren.\n     LEAVE LOOP=*,(CLI,0(R6),EQ,C')')    |   Leave if one found.\n     LA    R6,1(,R6)                     |   Advance to next char.\n   ENDLOOP WHILE                         | EndLoop.\n   ERREXIT (C,R6,GT,&PWA.FS_END),CODE=&ST_FORMAT_SPEC_NOT_ENDED\n*                                        |\n   BLOCK NAME=FILL_QUOTE,TYPE=INLINE     | Begin quoted-string checks.\n     LR  R5,R7                           |   r5 -> 1st nonblank.\n     IF  (CLI,0(R5),EQ,C'C')             |   If character = \"C\"\n       LA    R5,1(,R5)                   |     Advance 1 position.\n     ENDIF                               |   EndIf.\n     LEAVE BLOCK=*,(CR,R5,GE,R6)         |   Leave if not quoted-string\n     LEAVE BLOCK=*,(CLI,0(R5),NE,C''''),AND,(CLI,0(R5),NE,C'\"')\n     LA    R4,1(,R5)                     |   R4 -> 1st char past quote\n     LA    R3,&PWA.FSV_FILL_VALUE        |   R3 -> Current value posn.\n     LA    R2,L'&PWA.FSV_FILL_VALUE-1(R3)    R2 -> Value Limit.\n     LOOP  UNTIL                         |   Loop over quoted string.\n       LEAVE BLOCK=*,(CR,R4,GE,R6)       |     Leave if not ended.\n       IF (CLC,0(1,R4),EQ,0(R5))         |     If char = opening-quote\n         LA    R4,1(,R4)                 |       R4 -> Next char.\n         LEAVE LOOP=*,(CR,R4,GE,R6),OR,(CLC,0(1,R4),NE,0(R5))\n       ENDIF                             |     EndIf\n       ERREXIT (CR,R3,GT,R2),CODE=&ST_FORMAT_FILL_TOO_LONG\n       MVC   0(1,R3),0(R4)               |     Copy one character.\n       LA    R3,1(,R3)                   |     R3 -> Next value posn.\n       LA    R4,1(,R4)                   |     R4 -> Next source char.\n     ENDLOOP UNTIL,LEAVE                 |   EndLoop\n     LOOP WHILE,(CR,R4,LT,R6)            |   Loop over remaining stuff.\n       LEAVE BLOCK=*,(CLI,0(R4),NE,C' ') |     Must be all blanks.\n     ENDLOOP WHILE                       |   EndIf.\n     LA    R0,&PWA.FSV_FILL_VALUE        |   R0 -> Start of fill value\n     SLR   R3,R0                         |   R3 := Fill value length.\n     LEAVE BLOCK=*,(TREG,R3,NP)          |   Leave if null-string.\n     ST    R3,&PWA.FSV_FILL_LENGTH       |   Save in the PWA.\n     LA    R8,1(,R6)                     |   R8 -> past closing \")\".\n     ST    R8,&PWA.FS_CURRENT            |   Save current position.\n     LEAVE BLOCK=GETFMT_FILL_OPERANDS    |   Return to caller.\n   ENDBLK BLOCK=FILL_QUOTE               | End quoted-string checks.\n*                                        |\n   BLOCK NAME=FILL_HEX,TYPE=INLINE       | Begin hex-string checks.\n     LEAVE BLOCK=*,(CLI,0(R7),NE,C'X')   |   Leave if not \"X\".\n     LA    R5,1(,R7)                     |   r5 -> char after \"X\".\n     LEAVE BLOCK=*,(CR,R5,GE,R6)         |   Leave if nothing else.\n     LEAVE BLOCK=*,(CLI,0(R5),NE,C''''),AND,(CLI,0(R5),NE,C'\"')\n     LA    R4,1(,R5)                     |   R4 -> 1st char past quote\n     LA    R3,&PWA.FSV_FILL_VALUE        |   R3 -> Current value posn.\n     LA    R2,L'&PWA.FSV_FILL_VALUE-1(R3)    R2 -> Value Limit.\n     LOOP  UNTIL                         |   Loop over hex-string.\n       LEAVE   BLOCK=*,(CR,R4,GE,R6)     |     Leave if not ended.\n       LEAVE   LOOP=*,(CLC,0(1,R4),EQ,0(R5))   Leave on end-quote.\n       ERREXIT (CR,R3,GE,R2),CODE=&ST_FORMAT_FILL_TOO_LONG\n       MVC     &W.CHAR+0(1),0(R4)        |     Copy 1st of hex-pair.\n       LA      R4,1(,R4)                 |     Advance to next.\n       LEAVE   BLOCK=*,(CR,R4,GE,R6)     |     Leave if no 2nd-half.\n       LEAVE   BLOCK=*,(CLC,0(1,R4),EQ,0(R5))  Leave if no 2nd-half.\n       MVC     &W.CHAR+1(1),0(R4)        |     Copy 2nd of hex-pair.\n       LA      R4,1(,R4)                 |     Advance to next.\n       TR      &W.CHAR,&PSD.HEX_TAB      |     Translate for convert.\n       LEAVE   BLOCK=*,(CLI,&W.CHAR+0,EQ,X'00') Leave if bad hex-char.\n       LEAVE   BLOCK=*,(CLI,&W.CHAR+1,EQ,X'00') Leave if bad hex-char.\n       PACK    &W.HEX,&W.CHAR_PLUS       |      Pack w/garbage byte.\n       MVC     0(1,R3),&W.HEX            |     Copy one character.\n       LA      R3,1(,R3)                 |     R3 -> Next value posn.\n     ENDLOOP UNTIL,LEAVE                 |   EndLoop\n     LA   R4,1(,R4)                      |   R4 -> past end-quote.\n     LOOP WHILE,(CR,R4,LT,R6)            |   Loop over remaining stuff.\n       LEAVE BLOCK=*,(CLI,0(R4),NE,C' ') |     Must be all blanks.\n     ENDLOOP WHILE                       |   EndIf.\n     LA    R0,&PWA.FSV_FILL_VALUE        |   R0 -> Start of fill value\n     SLR   R3,R0                         |   R3 := Fill value length.\n     LEAVE BLOCK=*,(TREG,R3,NP)          |   Leave if null-string.\n     ST    R3,&PWA.FSV_FILL_LENGTH       |   Save in the PWA.\n     LA    R8,1(,R6)                     |   R8 -> past closing \")\".\n     ST    R8,&PWA.FS_CURRENT            |   Save current position.\n     LEAVE BLOCK=GETFMT_FILL_OPERANDS    |   Return to caller.\n   ENDBLK BLOCK=FILL_HEX                 | End hex-string checks.\n*                                        |\n   BLOCK NAME=FILL_REF,TYPE=INLINE       | Begin reference (?) checks.\n     LEAVE BLOCK=*,(CLI,0(R7),NE,C'?')   |   Leave if not \"?\".\n     LA    R5,1(,R7)                     |   R5 -> next char.\n     LM    R3,R4,&PWA.ARGUMENT_LIST      |   R3:=count, R4->A(<arg>).\n     IF    (TREG,R3,NP),OR,(CLC,=A(0),EQ,0(R4))  If no argument.\n       ERREXIT CODE=&ST_FORMAT_MISSING_ARGUMENT  Exit with error code.\n     ENDIF                               |   EndIf.\n     L     R2,0(R4)                      |   R2 -> Fill string.\n     LA    R4,4(,R4)                     |   R4 -> Next argument.\n     BCTR  R3,0                          |   Subtract 1 from count.\n     STM   R3,R4,&PWA.ARGUMENT_LIST      |   Update current args.\n     MVC   &PWA.FSV_FILL_LENGTH,=F'1'    |   Default length = 1.\n     IF    (CR,R5,LT,R6),AND,(CLI,0(R5),EQ,C'L')\n       LA  R5,1(,R5)                     |     Advance past \"L\".\n       IF  (CR,R5,LT,R6)                 |     If more stuff, then.\n         ST      R5,&PWA.FS_CURRENT      |       Update current posn.\n         CALLSUB GETFMT_INTEGER,(&PWA.FSV_FILL_LENGTH)\n         L       R5,&PWA.FS_CURRENT      |       R5 -> past length.\n       ENDIF                             |     EndIf.\n     ENDIF                               |   EndIf.\n     LOOP WHILE,(CR,R5,LT,R6)            |   Loop over remaining stuff.\n       LEAVE LOOP=*,(CLI,0(R5),NE,C' ')  |     Must be all blanks.\n     ENDLOOP WHILE                       |   EndIf.\n     L     R1,&PWA.FSV_FILL_LENGTH       |   R1 := filler length.\n     ERREXIT (C,R1,GT,=A(L'&PWA.FSV_FILL_VALUE)),                      +\n               CODE=&ST_FORMAT_FILL_TOO_LONG\n     IF    (TREG,R1,NP),OR,(CR,R5,NE,R6) |   If null-string or badchars\n       SL  R4,=F'4'                      |     Restore argument_list\n       LA  R3,1(,R3)                     |     to the values it had\n       STM R3,R4,&PWA.ARGUMENT_LIST      |     before this block.\n       LEAVE BLOCK=*                     |     Don't use as ? filler.\n     ENDIF                               |   EndIf.\n     BCTR  R1,0                          |   Subtract 1 for EXI.\n     EXI   R1,(MVC,&PWA.FSV_FILL_VALUE(0),0(R2))  Copy filler.\n     LA    R8,1(,R6)                     |   R8 -> past closing \")\".\n     ST    R8,&PWA.FS_CURRENT            |   Update current posn.\n     LEAVE BLOCK=GETFMT_FILL_OPERANDS    |   Return to caller.\n   ENDBLK BLOCK=FILL_REF                 | End reference (?) checks.\n*                                        |\n   LA      R5,1(,R6)                     | R5 -> past closing \")\".\n   ST      R5,&PWA.FS_CURRENT            | Update current position.\n   SR      R6,R8                         | R6 := Length w/in (...).\n   ERREXIT (C,R6,GT,=A(L'&PWA.FSV_FILL_VALUE)),                        +\n               CODE=&ST_FORMAT_FILL_TOO_LONG\n   ST      R6,&PWA.FSV_FILL_LENGTH       | Save Length of filler.\n   IF      (TREG,R6,P)                   | If positive.\n     BCTR  R6,0                          |    Subtract 1 for EXI.\n     EXI   R6,(MVC,&PWA.FSV_FILL_VALUE(0),0(R8))  Copy fill string.\n   ENDIF                                 | EndIf.\n ENDBLK BLOCK=GETFMT_FILL_OPERANDS\n              SWA\n&W.CHAR_PLUS  DS 0CL3\n&W.CHAR       DS  CL2                   | Source chars being converted\n              DS  CL1                   | Garbage for PACK to eat.\n&W.HEX        DS  XL2                   | 1st-byte = hex-equivalent.\n              ENDSWA\n              EJECT\n**********************************************************************\n*                                                                    *\n* Subroutine : GETFMT_INTEGER(Value)                                 *\n* Abstract   : Scan from Current up to (but not including) End to    *\n*              extract a format-specification's integer value.  The  *\n*              value must be a '?' or a sequence of digits.  Value   *\n*              will be set to the integer value specified, or if a   *\n*              '?' was provided, the current argument's value (which *\n*              must be a <sizelength> signed binary integer).        *\n*                                                                    *\n**********************************************************************\n BLOCK NAME=GETFMT_INTEGER,TYPE=SUBROUTINE\n   L       R9,0(R1)                      | R9 -> Return value.\n   L       R8,&PWA.FS_CURRENT            | R8 -> Current character.\n   IF      (C,R8,GT,&PWA.FS_END)         | If past end, then\n     LA    R15,4                         |   Indicate no value.\n     LEAVE BLOCK=*                       |   Return to caller.\n   ENDIF                                 | EndIf.\n*                                        |\n   L8 R3,0(R8)                           | R3 := actual character.\n   LA R3,CLASSIFICATION(R3)              | R3 -> character's class.\n   IF (CLI,0(R3),EQ,C'D')                | If string of <digits>.\n     LR    R3,R8                         |   Use R3 to scan ahead.\n     LOOP  WHILE,(C,R3,LE,&PWA.FS_END)   |   Loop over digit-sequence.\n       L8    R2,0(R3)                    |     R2 := actual character.\n       LA    R2,CLASSIFICATION(R2)       |     R2 -> character's class.\n       LEAVE LOOP=*,(CLI,0(R2),NE,C'D')  |     Leave on non-<digit>.\n       LA    R3,1(,R3)                   |     Advance to next char.\n     ENDLOOP WHILE                       |   EndLoop.\n     SLR     R3,R8                       |   R3 := length of <digits>.\n     ERREXIT (C,R3,GT,=F'16'),CODE=&ST_MAGNITUDE\n     BCTR    R3,0                        |   Subtract 1 for EX instr.\n     EXI     R3,(PACK,GSI_DECIMAL,0(0,R8))   Convert to packed-decimal.\n     ERREXIT (CP,GSI_DECIMAL,GT,=P'2147483648'),  If too large for a   +\n               CODE=&ST_MAGNITUDE        |          fullword, error.\n     LA      R8,1(R3,R8)                 |   Advance past <digits>.\n     ST      R8,&PWA.FS_CURRENT          |   Update current position.\n     CVB     R3,GSI_DECIMAL              |   Convert to binary.\n     STCM    R3,B'1111',0(R9)            |   Save value.\n     LA      R15,0                       |   Successful return-code.\n   ELSEIF (CLI,0(R8),EQ,C'?')            | ElseIf a referenced value.\n     LA R8,1(,R8)                        |   Advance to next char.\n     ST R8,&PWA.FS_CURRENT               |   Update current position.\n*                                        |   ...look for <digits>\n     L8 R3,0(R8)                         |   R3 := actual character.\n     LA R3,CLASSIFICATION(R3)            |   R3 -> character's class.\n     IF (CLI,0(R3),NE,C'D')              |   If not a <digit>.\n       MVC  &W.SIZEMASK,&PWA.SIZEMASK    |     Use global SIZELENGTH\n       MVC  &W.SIZELENGTH,&PWA.SIZELENGTH      to obtain length value.\n     ELSE                                |   Else, a string of <digits>\n       LR    R3,R8                       |     Use R3 to scan ahead.\n       LOOP  WHILE,(C,R3,LE,&PWA.FS_END) |     Loop over digits.\n         L8    R2,0(R3)                  |       R2 := actual char.\n         LA    R2,CLASSIFICATION(R2)     |       R2 -> char's class\n         LEAVE LOOP=*,(CLI,0(R2),NE,C'D')        Leave on non-<digit>.\n         LA    R3,1(,R3)                 |       Advance to next char.\n       ENDLOOP WHILE                     |     EndLoop.\n       SLR     R3,R8                     |     R3 := length, <digits>.\n       ERREXIT (C,R3,GT,=F'16'),CODE=&ST_INVALID_SIZELENGTH\n       BCTR    R3,0                      |     Subtract 1 for EX instr.\n       EXI     R3,(PACK,GSI_DECIMAL,0(0,R8))   Convert, packed-decimal\n       ERREXIT (CP,GSI_DECIMAL,GT,=P'2147483648'),  If too large for a +\n               CODE=&ST_INVALID_SIZELENGTH          fullword, error.\n       LA      R8,1(R3,R8)               |     Advance past <digits>.\n       ST      R8,&PWA.FS_CURRENT        |     Update current position.\n       CVB     R3,GSI_DECIMAL            |     Convert to binary.\n       ERREXIT ((C,R3,LT,=F'1'),OR,(C,R3,GT,=F'4')),                   +\n               CODE=&ST_INVALID_SIZELENGTH\n       ST      R3,&W.SIZELENGTH          |     R3 = SIZELENGTH override\n       S       R3,=F'1'                  |     R3 := offset, bit-mask.\n       LA      R3,&PSD.BIT_MASK(R3)      |     R3 -> bit-mask to use.\n       L8      R0,0(R3)                  |     R0 := bit-mask.\n       ST      R0,&W.SIZEMASK            |     Save for getting length.\n     ENDIF                               |   EndIf.\n*                                        |\n     LM R6,R7,&PWA.ARGUMENT_LIST         |   R6:=count, R7->A(<arg>).\n     IF (TREG,R6,NP),OR,(TREG,R7,Z)      |   If no more <arguments>.\n       ERREXIT CODE=&ST_FORMAT_MISSING_ARGUMENT  Exit with error code.\n     ENDIF                               |   EndIf.\n     L     R2,0(,R7)                     |   R2 -> <argument>'s value.\n     LA    R7,4(,R7)                     |   Point to next <argument>.\n     BCTR  R6,0                          |   Subtract 1 from count.\n     STM   R6,R7,&PWA.ARGUMENT_LIST      |   Update current arg.\n     XR    R3,R3                         |   Use R3 to load integer.\n     L     R15,&W.SIZEMASK               |   R15 := length-mask.\n     EXI   R15,(ICM,R3,0,0(R2))          |   R3  := <argument> value.\n     L     R15,&W.SIZELENGTH             |   R15 := #bytes in R3.\n     SLL   R15,3                         |   R15 := #bits in R3.\n     LCR   R15,R15                       |   R15 := #bits ....\n     A     R15,=F'32'                    |       .... to sign-extend.\n     SLL   R3,0(R15)                     |   Shift value to sign-bit.\n     SRA   R3,0(R15)                     |   Shift back, keeping sign.\n     STCM  R3,B'1111',0(R9)              |   Save sign-extended value.\n     LA    R15,0                         |   Successful return-code.\n   ELSE                                  | Else.\n     LA    R15,4                         |   Indicate no value.\n   ENDIF                                 | EndIf.\n ENDBLK BLOCK=GETFMT_INTEGER\n                SWA\nGSI_DECIMAL     DS   D         | Packed-decimal value.\n&W.SIZELENGTH   DS   F         | Size of string length-specifiers.\n&W.SIZEMASK     DS   F         | Mask for <sizelength> values.\n                ENDSWA\n             EJECT\n**********************************************************************\n*                                                                    *\n* Subroutine: ADJUST_COLUMN_POSITION                                 *\n* Abstract:   Implement the @column portion of format-specifications *\n*                                                                    *\n**********************************************************************\n BLOCK TYPE=SUBROUTINE,NAME=ADJUST_COLUMN_POSITION\n   LEAVE BLOCK=*,(TBIT,&PWA.FS_FIELDS,&PWA.FSF_COLUMN,OFF)\n*                                        |\n   IF (CLI,&PWA.FSV_COLUMN,EQ,C'@')      | If Highwater column wanted.\n     MVC &PWA.STRING_CURRENT,&PWA.STRING_HIGHWATER\n     LEAVE BLOCK=*                       |   Return to caller.\n   ENDIF                                 | EndIf.\n*                                        |\n   IF (CLI,&PWA.FSV_COLUMN,EQ,C'=')      | If absolute column#.\n     L32 R9,&PWA.FSV_COLUMN+1            |   R9 := Column# specified.\n   ELSE                                  | Else, +/- relative column#.\n     L32  R8,&PWA.FSV_COLUMN+1           |   R8 := Column# specified.\n     L    R9,&PWA.STRING_CURRENT         |   R9 := current position.\n     SL   R9,&PWA.STRING_START           |   R9 := current offset.\n     LA   R9,1(,R9)                      |   R9 := current column#.\n     IF   (CLI,&PWA.FSV_COLUMN,EQ,C'+')  |   If +relative column.\n       AR   R9,R8                        |     Add to current column#.\n     ELSEIF (CLI,&PWA.FSV_COLUMN,EQ,C'-')    ElseIf -relative column#.\n       SR   R9,R8                        |     Subtract from column#.\n     ELSE                                |   Else.\n       ERREXIT CODE=&ST_INTERNAL_ERROR   |     Internal error.\n     ENDIF                               |   EndIf.\n   ENDIF                                 | EndIf.\n*                                        |\n   ERREXIT (TREG,R9,NP),CODE=&ST_FORMAT_COLUMN_TOO_SMALL\n   BCTR    R9,0                          | Change to an offset.\n   AL      R9,&PWA.STRING_START          | Add to start-address.\n   ERREXIT (C,R9,GT,&PWA.STRING_END),CODE=&ST_FORMAT_COLUMN_TOO_LARGE\n   ST    R9,&PWA.STRING_CURRENT          | Save as new column.\n   IF    (C,R9,GT,&PWA.STRING_HIGHWATER) | If a new high-water mark.\n     ST  R9,&PWA.STRING_HIGHWATER        |   Update Highwater mark.\n   ENDIF                                 | EndIf.\n ENDBLK BLOCK=ADJUST_COLUMN_POSITION\n             EJECT\n**********************************************************************\n*                                                                    *\n* FORMAT_ADDRESS: Format the next argument as an address.            *\n*                                                                    *\n**********************************************************************\n BLOCK NAME=FORMAT_ADDRESS,TYPE=SUBROUTINE\n   L32  R2,&PWA.FSV_SOURCE    | R2 -> Source data to format.\n   L32  R3,&PWA.FSV_LENGTH    | R3 -> Length of source data.\n*---------------------------------------------------------------------*\n*  Convert entire address to an eight-byte text string w/leading zeros.\n*---------------------------------------------------------------------*\n   IF  (TREG,R3,NZ),THEN      | If any data to convert, then\n     BCTR R3,0                |   Subtract 1 for EX instr.\n     EXI  R3,(MVC,&PWA.WORK0,0(R2))\n     LA   R3,1(,R3)           |   Use a garbage sign-byte.\n     EXI  R3,(UNPK,DECIMAL9,&PWA.WORK0)\n     TR   DECIMAL,HEXCHARS    |   Convert ABCDEF to printables.\n   ELSE                       | Else\n     MVC  DECIMAL,=8X'F0'     |   Pretend all zeros were converted.\n   ENDIF                      | EndIf\n*---------------------------------------------------------------------*\n*  Set up R2 and R3 for addr/length of formatted address.  Point to\n*  1st non-zero byte or the last byte if all zeros.\n*---------------------------------------------------------------------*\n   SLL  R3,1                  | R3 := length of formatted address.\n   LA   R2,DECIMAL+L'DECIMAL  |\n   SR   R2,R3                 | R2 -> 1st byte of formatted address.\n   IF   (CLI,&PWA.FSV_LEADING_PAD,NE,C'0')\n     S    R3,=F'1'            |\n     XR   R14,R14             | R2 -> 1st non-zero digit or last\n     ICM  R15,15,=X'F0000000' |       digit in number if all zeros.\n     CLCL R2,R14              | R3 := length of whatever remains\n     LA   R3,1(,R3)           |       from R2 to the end of number.\n   ENDIF                      |\n*---------------------------------------------------------------------*\n*  Pad to the left with blanks/zeros if right-justified and then copy\n*  the formatted address to the target area.\n*---------------------------------------------------------------------*\n   CALLSUB PAD_LEFT,((R3)),NOVL\n   CALLSUB COPY_TO_STRING,((R2),(R3)),NOVL\n   CALLSUB PAD_RIGHT,((R3)),NOVL\n ENDBLK BLOCK=FORMAT_ADDRESS\n EJECT\n**********************************************************************\n*                                                                    *\n* FORMAT_BINARY: Format a bit-string.                                *\n*                                                                    *\n**********************************************************************\n BLOCK NAME=FORMAT_BINARY,TYPE=SUBROUTINE\n   L32  R2,&PWA.FSV_SOURCE       | R2 -> Source data to format.\n   L32  R3,&PWA.FSV_LENGTH       | R3 := Length of source data.\n*---------------------------------------------------------------------*\n*  Determine the formatted data's length and insert pad characters\n*  if neccessary to get the correct justification.\n*---------------------------------------------------------------------*\n   LR      R4,R3                 | R4 := source bit-string length.\n   SLL     R4,3                  | R4 := length of formatted result.\n   CALLSUB PAD_LEFT,((R4)),NOVL  | Insert leading pad characters.\n*---------------------------------------------------------------------*\n*  Loop over the source data, formatting/moving a byte at a time.\n*---------------------------------------------------------------------*\n   LOOP BCT                   | Loop over the source data.\n     ICM   R14,1,0(R2)        |   R11 := byte to format.\n     LA    R1,8               |   R1  := number of bits.\n     LOOP  BCT                |   Loop over bits in byte.\n       SRDL R14,1             |     Shift next bit into R15.\n       SRL  R15,31            |     Shift to low bit.\n       O    R15,=C'...0'      |     Create a character 0 or 1.\n       STC  R15,&PWA.WORK8-1(R1)    Save the new character.\n     ENDLOOP BCT,R1           |   EndLoop.\n     CALLSUB COPY_TO_STRING,(&PWA.WORK8,L'&PWA.WORK8),NOVL\n     LA      R2,1(,R2)        |   Point to next byte to format.\n   ENDLOOP BCT,R3             | EndLoop.\n*---------------------------------------------------------------------*\n*  Pad with trailing spaces if necessary.\n*---------------------------------------------------------------------*\n   CALLSUB PAD_RIGHT,((R4)),NOVL | Pad with trailing spaces.\n ENDBLK BLOCK=FORMAT_BINARY\n EJECT\n**********************************************************************\n*                                                                    *\n* FORMAT_CHARACTER: Move a character string into the target string.  *\n*                                                                    *\n**********************************************************************\n BLOCK NAME=FORMAT_CHARACTER,TYPE=SUBROUTINE\n   L32  R2,&PWA.FSV_SOURCE    | R2 -> Source data to format.\n   L32  R3,&PWA.FSV_LENGTH    | R3 := Length of source data.\n*---------------------------------------------------------------------*\n*  If a precision was specified, set the source length to the minimum\n*  of the actual source-length and the precision.\n*---------------------------------------------------------------------*\n   IF (TBIT,&PWA.FS_FIELDS,&PWA.FSF_PRECISION) If .precision specified.\n     IF  (C,R3,GT,&PWA.FSV_PRECISION)     |   If sourcelen > precision.\n       L  R3,&PWA.FSV_PRECISION           |    Use specified precision.\n     ENDIF                                |   EndIf.\n   ENDIF                                  | EndIf.\n*---------------------------------------------------------------------*\n*  If the trim function was requested, adjust the length of the source\n*  string to leave off trailing blanks.  The length may go to zero\n*  when doing this.\n*---------------------------------------------------------------------*\n   IF (TBIT,&PWA.FSV_KEYWORDS,&PWA.FSV_TRIM)  | If TRIM specified.\n     IF (TREG,R3,P)                           |   If anything to trim.\n       LA   R15,0(R3,R2)                      |     R15 -> past end.\n       LOOP BCT                               |   Scan backwards.\n         BCTR  R15,0                          |     Back up 1 char.\n         LEAVE LOOP=*,(CLI,0(R15),NE,C' ')    |     Leave on nonblank.\n       ENDLOOP BCT,R3                         |   EndLoop.\n     ENDIF                                    | EndIf.\n   ENDIF                                      | EndIf.\n*---------------------------------------------------------------------*\n*  Copy the character data directly to the String field.\n*---------------------------------------------------------------------*\n   CALLSUB PAD_LEFT,((R3)),NOVL\n   L       R8,&PWA.STRING_CURRENT   | Save new text's position.\n   CALLSUB COPY_TO_STRING,((R2),0(R3)),NOVL\n   CALLSUB PAD_RIGHT,((R3)),NOVL\n*---------------------------------------------------------------------*\n*  Capitalize the new copy of the character string if requested.\n*---------------------------------------------------------------------*\n   IF (TBIT,&PWA.FSV_KEYWORDS,&PWA.FSV_CAPS) If CAPS specified.\n     LOOP  WHILE,(C,R3,GT,=F'256')  |   Loop over large chunks.\n       TR  0(256,R8),FOLD           |     Fold segment to caps.\n       LA  R8,256(,R8)              |     Advance to next segment.\n       S   R3,=F'256'               |     Adjust remaining len.\n     ENDLOOP WHILE                  |   EndLoop.\n     IF (TREG,R3,P)                 |   If anything left.\n       BCTR R3,0                    |     Subtract 1 for EX instr.\n       EXI  R3,(TR,0(0,R8),FOLD)    |     Fold segment to caps.\n     ENDIF                          |   EndIf.\n   ELSEIF (TBIT,&PWA.FSV_KEYWORDS,&PWA.FSV_C1ST) ElseIf cap 1st letter\n     TR 0(1,R8),FOLD                |   Capitalize 1st letter of fld.\n   ENDIF                            | EndIf.\n ENDBLK BLOCK=FORMAT_CHARACTER\n EJECT\n**********************************************************************\n*                                                                    *\n* FORMAT_SIGNED_INTEGER: Format 1,2,3,4 byte signed binary integer.  *\n*                                                                    *\n**********************************************************************\n BLOCK NAME=FORMAT_SIGNED_INTEGER,TYPE=SUBROUTINE\n   L32  R2,&PWA.FSV_SOURCE    | R2 -> Source data to format.\n   L32  R3,&PWA.FSV_LENGTH    | R3 := Length of source data.\n*---------------------------------------------------------------------*\n*  Get the integer, sign extended, into a register and convert to\n*  decimal. Then convert it to printable characters -- inserting a\n*  sign if needed.\n*---------------------------------------------------------------------*\n   IF (TREG,R3,P),THEN        | If any data to convert, then\n     BCTR R3,0                |    Subtract 1 for EX instr.\n     XC   &PWA.WORK4,&PWA.WORK4 |  Clear out holding area.\n     EXI  R3,(MVC,&PWA.WORK0,0(R2)) Copy number over.\n     L    R5,&PWA.WORK4       |    Load number into R5.\n     LA   R3,1(,R3)           |    Add 1 back to length.\n     SLL  R3,3                |    Convert to number-of-bits.\n     LCR  R3,R3               |    Change to a negative number to\n     A    R3,=F'32'           |    subtract from total number of bits.\n     SRA  R5,0(R3)            |    Sign-extend to a fullword integer.\n     CVD  R5,DECIMAL          |    Convert the integer to decimal.\n     UNPK &PWA.WORK16,DECIMAL |    Convert decimal to printable.\n   ELSE                       | Else\n     FILL &PWA.WORK16,X'F0'   |   Pretend all zeros were converted.\n   ENDIF                      | EndIf\n*---------------------------------------------------------------------*\n*  Set up R2 and R3 for addr/length of formatted integer.  Point to\n*  1st non-zero byte or the last byte if all zeros.  Don't worry about\n*  leading-zeros ... they will be taken care of by pad_left.\n*---------------------------------------------------------------------*\n   LA   R3,L'&PWA.WORK16      | R3 := length of formatted integer.\n   LA   R2,&PWA.WORK          | R2 -> 1st byte of formatted integer.\n   S    R3,=F'1'              |\n   XR   R14,R14               | R2 -> 1st non-zero digit or last\n   ICM  R15,15,=X'F0000000'   |       digit in number if all zeros.\n   CLCL R2,R14                | R3 := length of whatever remains\n   LA   R3,1(,R3)             |       from R2 to the end of number.\n*---------------------------------------------------------------------*\n*  If the number is negative, insert a minus sign in front of it.  The\n*  number cannot possibly be as long as 16 bytes in length, so it is\n*  safe to assume that there will be room in the formatted field of\n*  DECIMAL16 to insert the minus sign.  Set the four-bit sign to a\n*  hexadecimal 'F' so that the last digit will print.\n*---------------------------------------------------------------------*\n   L8  R1,DECIMAL+L'DECIMAL-1  | Pick up last digit of integer.\n   N   R1,=F'15'               | Throw away all but sign.\n   IF (CLM,R1,1,EQ,=X'0D')     | If negative, then\n     S   R2,=F'1'              |   Retract start-of-number pointer.\n     A   R3,=F'1'              |   Add 1 to total length of integer.\n     MVI 0(R2),C'-'            |   Insert minus sign.\n   ENDIF                       | EndIf.\n   OI &PWA.WORK16+15,X'F0'     | Make last digit printable.\n*---------------------------------------------------------------------*\n*  If the integer is to be printed as a 'relative' number, then append\n*  a -st, -nd, -rd, or -th suffix as appropriate.\n*---------------------------------------------------------------------*\n   IF (TBIT,&PWA.FSV_KEYWORDS,&PWA.FSV_RELATIVE)  If relative numbers.\n     A    R3,=F'2'             |   Add 2 to total length of integer.\n     SLR  R4,R4                |   Clear out R4 for division.\n     LPR  R5,R5                |   Force integer to be positive.\n     D    R4,=F'10'            |   Divide by 10 to get remainder in R4.\n     IF   (C,R4,EQ,=F'1')      |   If it ends w/a 1, then.\n       MVC &PWA.SUFFIX,=C'st'  |     Use the -st suffix.\n     ELSEIF (C,R4,EQ,=F'2')    |   Else if it ends w/a 2, then.\n       MVC &PWA.SUFFIX,=C'nd'  |     Use the -nd suffix.\n     ELSEIF (C,R4,EQ,=F'3')    |   Else if it ends w/a 3, then.\n       MVC &PWA.SUFFIX,=C'rd'  |     Use the -rd suffix.\n     ELSE                      |   Else\n       MVC &PWA.SUFFIX,=C'th'  |     Use the -th suffix.\n     ENDIF                     |\n   ENDIF                       | EndIf.\n*---------------------------------------------------------------------*\n*  Pad to the left with blanks/zeros if right-justified and then copy\n*  the formatted integer to the target area.\n*---------------------------------------------------------------------*\n   CALLSUB PAD_LEFT,((R3)),NOVL\n   CALLSUB COPY_TO_STRING,((R2),(R3)),NOVL\n   CALLSUB PAD_RIGHT,((R3)),NOVL\n ENDBLK BLOCK=FORMAT_SIGNED_INTEGER\n EJECT\n**********************************************************************\n*                                                                    *\n* FORMAT_UNSIGNED_INTEGER: Format an unsigned binary integer.        *\n*                                                                    *\n**********************************************************************\n BLOCK NAME=FORMAT_UNSIGNED_INTEGER,TYPE=SUBROUTINE\n   L32  R2,&PWA.FSV_SOURCE          | R2 -> Source data to format.\n   L32  R3,&PWA.FSV_LENGTH          | R3 := Length of source data.\n*---------------------------------------------------------------------*\n*  Get the integer into a register and convert to decimal.  Since the\n*  CVD instruction converts from signed-binary to decimal, the result\n*  may need to be adjusted to make it right.\n*---------------------------------------------------------------------*\n   XC   &PWA.WORK4,&PWA.WORK4       | Clear out holding area.\n   LM   R4,R5,=D'0'                 | Clear out R4/R5 entirely.\n   BCTR R3,0                        | R3 := offset into ICM mask table.\n   LA   R3,&PSD.BIT_MASK(R3)        | R3 -> Bit mask to use.\n   L8   R15,0(R3)                   | R15 := Bit mask to use.\n   EXI  R15,(ICM,R5,0,0(R2))        | R5 := Number to convert.\n   SLDL R4,1                        | Shift high-bit to R4.\n   SRL  R5,1                        | Shift rest of number back.\n   CVD  R5,DECIMAL                  | Convert the integer to decimal.\n   IF   (TREG,R4,NZ)                | If high-order bit was on.\n     AP DECIMAL,=P'2147483648'      |   Add X'80000000' back to number.\n   ENDIF                            | EndIf.\n   UNPK &PWA.WORK16,DECIMAL         | Convert decimal to printable.\n*---------------------------------------------------------------------*\n*  Set up R2 and R3 for addr/length of formatted integer.  Point to\n*  1st non-zero byte or the last byte if all zeros.  Don't worry about\n*  leading-zeros ... they will be taken care of by pad_left.\n*---------------------------------------------------------------------*\n   LA   R3,L'&PWA.WORK16      | R3 := length of formatted integer.\n   LA   R2,&PWA.WORK          | R2 -> 1st byte of formatted integer.\n   S    R3,=F'1'              |\n   XR   R14,R14               | R2 -> 1st non-zero digit or last\n   ICM  R15,15,=X'F0000000'   |       digit in number if all zeros.\n   CLCL R2,R14                | R3 := length of whatever remains\n   LA   R3,1(,R3)             |       from R2 to the end of number.\n   OI   &PWA.WORK16+15,X'F0'  | Make last digit printable.\n*---------------------------------------------------------------------*\n*  If the integer is to be printed as a 'relative' number, then append\n*  a -st, -nd, -rd, or -th suffix as appropriate.\n*---------------------------------------------------------------------*\n   IF (TBIT,&PWA.FSV_KEYWORDS,&PWA.FSV_RELATIVE)  If relative numbers.\n     A    R3,=F'2'             |   Add 2 to total length of integer.\n     SLR  R4,R4                |   Clear out R4 for division.\n     LPR  R5,R5                |   Force integer to be positive.\n     D    R4,=F'10'            |   Divide by 10 to get remainder in R4.\n     IF   (C,R4,EQ,=F'1')      |   If it ends w/a 1, then.\n       MVC &PWA.SUFFIX,=C'st'  |     Use the -st suffix.\n     ELSEIF (C,R4,EQ,=F'2')    |   Else if it ends w/a 2, then.\n       MVC &PWA.SUFFIX,=C'nd'  |     Use the -nd suffix.\n     ELSEIF (C,R4,EQ,=F'3')    |   Else if it ends w/a 3, then.\n       MVC &PWA.SUFFIX,=C'rd'  |     Use the -rd suffix.\n     ELSE                      |   Else\n       MVC &PWA.SUFFIX,=C'th'  |     Use the -th suffix.\n     ENDIF                     |\n   ENDIF                       | EndIf.\n*---------------------------------------------------------------------*\n*  Pad to the left with blanks/zeros if right-justified and then copy\n*  the formatted integer to the target area.\n*---------------------------------------------------------------------*\n   CALLSUB PAD_LEFT,((R3)),NOVL\n   CALLSUB COPY_TO_STRING,((R2),(R3)),NOVL\n   CALLSUB PAD_RIGHT,((R3)),NOVL\n ENDBLK BLOCK=FORMAT_UNSIGNED_INTEGER\n EJECT\n**********************************************************************\n*                                                                    *\n* FORMAT_HEX_CHARACTER: Format a hexadecimal character string.       *\n*                                                                    *\n**********************************************************************\n BLOCK NAME=FORMAT_HEX_CHARACTER,TYPE=SUBROUTINE\n   L32  R2,&PWA.FSV_SOURCE    | R2 -> Source data to format.\n   L32  R3,&PWA.FSV_LENGTH    | R3 := Length of source data.\n*---------------------------------------------------------------------*\n*  Determine the formatted data's length and insert pad characters\n*  if neccessary to get the correct justification.\n*---------------------------------------------------------------------*\n   LR      R4,R3                 | R4 := source bit-string length.\n   SLL     R4,1                  | R4 := length of formatted result.\n   CALLSUB PAD_LEFT,((R4)),NOVL  | Insert leading pad characters.\n*---------------------------------------------------------------------*\n*  Loop over the source data, formatting/moving a byte at a time.\n*---------------------------------------------------------------------*\n   LA   R5,2\n   IF   (TREG,R3,NZ)             | If any hex data then.\n     LOOP BCT                    |   Loop over the source data.\n       MVC   &PWA.WORK1,0(R2)    |     Copy byte to be formatted.\n       UNPK  DECIMAL9,&PWA.WORK2 |     Unpack, along with junk-byte.\n       TR    DECIMAL,HEXCHARS    |     Convert ABCDEF to printables.\n       CALLSUB COPY_TO_STRING,(DECIMAL+6,(R5)),NOVL\n       LA    R2,1(,R2)           |     Point to next byte to format.\n     ENDLOOP BCT,R3              |   EndLoop.\n   ENDIF                         | EndIf.\n   CALLSUB PAD_RIGHT,((R4)),NOVL | Add trailing spaces.\n ENDBLK BLOCK=FORMAT_HEX_CHARACTER\n EJECT\n**********************************************************************\n*                                                                    *\n* Subroutine: PAD_LEFT(formatted-length)                             *\n* Abstract: Insert the appropriate number of leading blanks/zeros    *\n*           to cause right-justification or centering to work out.   *\n*           The parameter is call-by-value.  R1 -> directly to the   *\n*           formatted-length value.                                  *\n*                                                                    *\n**********************************************************************\n BLOCK NAME=PAD_LEFT,TYPE=SUBROUTINE\n*---------------------------------------------------------------------*\n*  If right-justification or centering is enabled and if the target\n*  field width is greater than the width of the formatted data, then\n*  padding to the left is required.\n*---------------------------------------------------------------------*\n  IF (TBIT,&PWA.FSV_KEYWORDS,&PWA.FSV_CENTER+&PWA.FSV_RIGHT,ANY)\n     L     R8,&PWA.STRING_CURRENT  R8 -> current target position.\n     L     R9,&PWA.STRING_END  |   R9 -> last target byte.\n     SLR   R9,R8               |   R9 := length of target - 1.\n     AL    R9,=F'1'            |   R9 := length of target area.\n     IF (C,R9,GT,&PWA.FSV_WIDTH)   If enough room for data.\n       L   R9,&PWA.FSV_WIDTH   |     Set length = specified width.\n     ENDIF                     |   EndIf.\n     L     R1,0(R1)            |   R1 := Length of formatted data.\n     IF (CR,R9,GT,R1)          |   If one or more pad chars needed.\n       SR R9,R1                |     R9 = number of pad characters.\n       IF (TBIT,&PWA.FSV_KEYWORDS,&PWA.FSV_CENTER) If centering text.\n         LR  R15,R9            |\n         XR  R14,R14           |       Divide pad-length by two.\n         D   R14,=F'2'         |\n         LR  R9,R15            |\n       ENDIF                   |     EndIf.\n       XR   R14,R14            |\n       XR   R15,R15            |\n       ICM  R15,8,&PWA.FSV_LEADING_PAD Get leading pad character.\n       MVCL R8,R14             |\n       ST   R8,&PWA.STRING_CURRENT   Update current target position.\n       IF   (C,R8,GT,&PWA.STRING_HIGHWATER)  If a new high-water mark.\n         ST R8,&PWA.STRING_HIGHWATER   Update Highwater mark.\n       ENDIF                   |     EndIf.\n     ENDIF                     |   EndIf.\n   ENDIF                       | EndIf\n ENDBLK BLOCK=PAD_LEFT\n EJECT\n**********************************************************************\n*                                                                    *\n* Subroutine: COPY_TO_STRING,(Text,*Length*)                         *\n* Abstract:   Move formatted data described by addr/length parms     *\n*             to the target string.  The length parameter is passed  *\n*             by value -- that is, it is actually in the parameter   *\n*             list itself instead of following normal conventions.   *\n*                                                                    *\n**********************************************************************\n BLOCK NAME=COPY_TO_STRING,TYPE=SUBROUTINE\n   LM    R0,R1,0(R1)          | R0 -> text, R1 -> length of text.\n*---------------------------------------------------------------------*\n*  Copy the formatted data pointed to by R0 with length (R1).\n*---------------------------------------------------------------------*\n   L     R8,&PWA.STRING_CURRENT R8 -> current target position.\n   L     R9,&PWA.STRING_END   | R9 -> last target byte.\n   SLR   R9,R8                | R9 := length of target - 1.\n   AL    R9,=F'1'             | R9 := length of target area.\n   IF    (CR,R9,GT,R1)        | If enough room in target area.\n     LR  R9,R1                |   R9 := length of data to move.\n   ENDIF                      | EndIf.\n   STM   R8,R9,MF_TARGET      | Save target area address, length.\n   MVCL  R8,R0                | Copy the formatted bit-string.\n   ST    R8,&PWA.STRING_CURRENT Update current target position.\n   ERREXIT CC4,CODE=&ST_TRUNCATED.\n   ERREXIT CC1,CODE=&ST_OVERLAP.\n   IF (C,R8,GT,&PWA.STRING_HIGHWATER)  If a new high-water mark.\n     ST R8,&PWA.STRING_HIGHWATER   Update Highwater mark.\n   ENDIF                      | EndIf.\n ENDBLK BLOCK=COPY_TO_STRING\n           SWA\nMF_TARGET  DS      2F\n           ENDSWA\n EJECT\n**********************************************************************\n*                                                                    *\n* PAD_RIGHT: Add the appropriate number of trailing characters to    *\n*            cause left-justification or centering to work out.      *\n*            The parameter is call-by-value.  R1 -> directly to the  *\n*            formatted-length value.                                 *\n*                                                                    *\n**********************************************************************\n BLOCK NAME=PAD_RIGHT,TYPE=SUBROUTINE\n*---------------------------------------------------------------------*\n*  If left-justification, centering, or filling is enabled and if the\n*  target field width is greater than the width of the formatted data,\n*  then padding to the RIGHT is required.\n*---------------------------------------------------------------------*\n   IF (TBIT,&PWA.FSV_KEYWORDS,&PWA.FSV_LEFT+&PWA.FSV_CENTER+&PWA.FSV_FI+\n               LL,ANY)\n     L   R8,&PWA.STRING_CURRENT       R8 -> current target position.\n     L   R9,&PWA.STRING_END       |   R9 -> last target byte.\n     SLR R9,R8                    |   R9 := length of target - 1.\n     AL  R9,=F'1'                 |   R9 := length of target area.\n     L   R15,&PWA.FSV_WIDTH       |   R15 := number of pad characters\n     IF  (C,R15,GT,0(R1))         |   If one or more pad chars needed.\n       S R15,0(R1)                |     R15 := number of pad chars.\n       IF  (TBIT,&PWA.FSV_KEYWORDS,&PWA.FSV_CENTER)  If centering.\n         XR  R14,R14              |\n         D   R14,=F'2'            |       Divide pad-length by 2 and\n         AR  R15,R14              |       Add back the remainder.\n       ENDIF                      |     EndIf.\n       IF (CR,R15,LT,R9)          |     If pad-length < available room.\n         LR   R9,R15              |       Use pad-length.\n       ENDIF                      |     EndIf.\n       LA   R1,0(R9,R8)           |     R1 -> past end of pad/fill area\n       ST   R1,&PWA.STRING_CURRENT      Update current target position.\n       IF   (C,R1,GT,&PWA.STRING_HIGHWATER)  If a new high-water mark.\n         ST R1,&PWA.STRING_HIGHWATER      Update Highwater mark.\n       ENDIF                      |     EndIf.\n*---------------------------------------------------------------------*\n*      Now perform actual padding or filling operation.\n*---------------------------------------------------------------------*\n       IF (TBIT,&PWA.FSV_KEYWORDS,&PWA.FSV_FILL)  If fill-string.\n         LA   R1,0(R8,R9)         |       R1 -> past end.\n         SL   R1,&PWA.FSV_FILL_LENGTH     R1 -> MVC target.\n         L    R2,&PWA.FSV_FILL_LENGTH     R2 := l'filler\n         BCTR R2,0                |       Subtract 1 for EXIs\n         LOOP WHILE,(CR,R1,GE,R8) |       Loop backwards.\n           EXI R2,(MVC,0(0,R1),&PWA.FSV_FILL_VALUE)  Move 1 fill segmt\n           SL  R1,&PWA.FSV_FILL_LENGTH               Back up 1 segmt.\n         ENDLOOP WHILE            |       EndLoop.\n         AL  R1,&PWA.FSV_FILL_LENGTH      Add back l'filler.\n         IF  (CR,R1,NE,R8)        |       If not an exact fit.\n           SR   R1,R8             |         R1 := remaining length.\n           MVI  0(R8),C' '        |         Fill in remainder.\n           IF   (C,R1,GT,=F'1')   |         If more than 1 char.\n             BCTR R1,0            |          Subtract 1 for MVI above.\n             BCTR R1,0            |          Subtract 1 for EXI.\n             EXI  R1,(MVC,1(0,R8),0(R8))     Fill remaining area.\n           ENDIF                  |         EndIf.\n         ENDIF                    |       EndIf.\n       ELSE                       |     Else.\n         XR   R14,R14             |\n         XR   R15,R15             |\n         ICM  R15,8,=C' '         |       Get trailing pad character.\n         MVCL R8,R14              |\n       ENDIF                      |     EndIf.\n     ENDIF                        |   EndIf.\n   ENDIF                          | EndIf\n ENDBLK BLOCK=PAD_RIGHT\n TITLE 'String Server - Conversion routines.'\n***********************************************************************\n*                                                                     *\n*  Subroutine: STRING_TO_INTEGER                                      *\n*  Abstract:   Convert a string of digits, with optional leading      *\n*              sign, to an integer fullword.                          *\n*  Parameters: (Address, Length, Integer)                             *\n*                                                                     *\n***********************************************************************\n BLOCK TYPE=SUBROUTINE,NAME=STRING_TO_INTEGER\n   LM  R2,R4,0(R1)                    | R2/R3 -> String/Length.\n   SLR R1,R1                          | Clear out for an ICM instr.\n   L   R15,&PWA.SIZEMASK              | R15 := length-mask.\n   EXI R15,(ICM,R1,0,0(R3))           | R1 := string-length.\n   LR  R3,R1                          | R3 := string-length.\n*---------------------------------------------------------------------*\n*  If the first non-blank character is a sign, remember it.\n*---------------------------------------------------------------------*\n   LOOP WHILE,((C,R3,GT,=F'1'),AND,(CLI,0(R2),EQ,C' '))\n     LA   R2,1(,R2)                   |   R2 -> past leading blank.\n     BCTR R3,0                        |   Adjust remaining length.\n   ENDLOOP WHILE                      | EndLoop while.\n*                                     |\n   LA R5,X'0C'                        | R5 := Zoned sign-nibble.\n   IF (C,R3,GT,=F'1')                 | If non-null string.\n     IF (CLI,0(R2),EQ,C'+')           |   If first character is '+'.\n       LA   R2,1(,R2)                 |     R2 -> past leading '+'.\n       BCTR R3,0                      |     Adjust remaining length.\n     ELSEIF (CLI,0(R2),EQ,C'-')       |   ElseIf first char is '-'.\n       LA   R2,1(,R2)                 |     R2 -> past leading '+'.\n       BCTR R3,0                      |     Adjust remaining length.\n       LA R5,X'0D'                    |     Switch to a minus sign.\n     ENDIF                            |   EndIf.\n   ENDIF                              | EndIf.\n*---------------------------------------------------------------------*\n*  Strip leading and trailing blanks from the remaining string.\n*---------------------------------------------------------------------*\n   LOOP WHILE,((C,R3,GT,=F'1'),AND,(CLI,0(R2),EQ,C' '))\n     LA   R2,1(,R2)                   |   R2 -> past leading blank.\n     BCTR R3,0                        |   Adjust remaining length.\n   ENDLOOP WHILE                      | EndLoop while.\n   LOOP WHILE,((C,R3,GT,=F'1'),AND,(CLI,0(R2),EQ,C'0'))\n     LA   R2,1(,R2)                   |   R2 -> past leading zero.\n     BCTR R3,0                        |   Adjust remaining length.\n   ENDLOOP WHILE                      | EndLoop while.\n*                                     |\n   LA   R3,0(R3,R2)                   | R3 -> past end of string.\n   LOOP UNTIL                         | Loop backwards.\n     BCTR R3,0                        |   Back up by one character.\n   ENDLOOP UNTIL,((CR,R3,LT,R2),OR,(CLI,0(R3),NE,C' '))\n   LA      R3,1(,R3)                  | R3 -> past trimmed string.\n   SLR     R3,R2                      | R3 := trimmed length.\n*---------------------------------------------------------------------*\n*  Check the adjusted source-string for validity.\n*---------------------------------------------------------------------*\n   IF (C,R3,LT,=F'1')                 | If nothing left, then.\n     L     R15,=F'&ST_INVALID_SOURCE_FORMAT'\n     LEAVE BLOCK=*                    |   Return with error-code.\n   ENDIF                              | EndIf.\n*                                     |\n   LA   R14,0(R3,R2)                  | R14 -> past last character.\n   LOOP WHILE,(CR,R14,GT,R2)          | Loop over digits.\n     BCTR   R14,0                     |   Back up to previous char.\n     L8     R1,0(R14)                 |   R1 := character.\n     LA     R1,CLASSIFICATION(R1)     |   R1 := character's class.\n     IF     (CLI,0(R1),NE,DIGIT)      |   If not a digit, then.\n       L     R15,=F'&ST_INVALID_SOURCE_FORMAT'\n       LEAVE BLOCK=*                  |     Return with error-code.\n     ENDIF                            |   EndIf.\n   ENDLOOP WHILE                      | EndLoop.\n*                                     |\n   IF (C,R3,GT,=F'16')                | If too many digits, then\n     L     R15,=F'&ST_MAGNITUDE'      |   Magnitude too big to handle.\n     LEAVE BLOCK=*                    |   Return with error-code.\n   ENDIF                              | EndIf.\n*                                     |\n   BCTR R3,0                          | Subtract 1 for the EX instr.\n*---------------------------------------------------------------------*\n*  Pack the source text to a decimal number and check its size.\n*---------------------------------------------------------------------*\n   EXI  R3,(PACK,STI_DECIMAL,0(0,R2)) | Pack into decimal fmt.\n   ICM  R0,1,STI_DECIMAL+7            | Pick up last digit of number.\n   N    R0,=X'000000F0'               | Discard all but the digit.\n   OR   R0,R5                         | Insert sign-nibble.\n   STCM R0,1,STI_DECIMAL+7            | Put signed-digit back.\n   IF (CP,STI_DECIMAL,GT,=P'2147483647'),OR,                           +\n               (CP,STI_DECIMAL,LT,=P'-2147483648')\n     L     R15,=F'&ST_MAGNITUDE'      |      Indicate magnitude error.\n     LEAVE BLOCK=*\n   ENDIF\n*---------------------------------------------------------------------*\n*  Attempt to convert the decimal number to binary.\n*---------------------------------------------------------------------*\n   CVB  R1,STI_DECIMAL                | Convert to binary.\n   ST   R1,0(R4)                      | Save in return-parameter.\n   LA   R15,0                         | Indicate successful conversion.\n ENDBLK BLOCK=STRING_TO_INTEGER\n             SWA\nSTI_DECIMAL  DS   D                   |\n             ENDSWA\n             EJECT\n***********************************************************************\n*                                                                     *\n*  Subroutine: INTEGER_TO_STRING(Integer,String,Length,ResultLen)     *\n*  Abstract:   Convert a signed fullword binary integer to a string.  *\n*                                                                     *\n***********************************************************************\n BLOCK TYPE=SUBROUTINE,NAME=INTEGER_TO_STRING\n   IF (CLC,&PWA.#PARMS,NE,=F'6')      | If #parms \u00ac= 6, then.\n     ERREXIT CODE=&ST_WRONG_NUMBER_OF_PARAMETERS\n   ENDIF                              | EndIf.\n*                                     |\n   L    R1,PRM_ITS_INTEGER            | R1 -> INTEGER to convert.\n   ICM  R1,B'1111',0(R1)              | R1 := INTEGER to convert.\n   CVD  R1,DECIMAL                    | Convert INTEGER to decimal.\n   UNPK &PWA.WORK16,DECIMAL           | Convert decimal to STRING.\n   OI   &PWA.WORK16+15,X'F0'          | Make last digit printable.\n*                                     |\n   LA   R4,&PWA.WORK                  | R4 -> new STRING.\n   LA   R5,L'&PWA.WORK16-1            | R5 := length(new STRING) - 1.\n   XR   R14,R14                       | R14 -> Null string.\n   ICM  R15,15,=X'F0000000'           | R15 := C'0'.\n   CLCL R4,R14                        | Set R4/R5 := address/length of\n   LA   R5,1(,R5)                     | string from 1st non-zero digit.\n*                                     |\n   L8 R6,DECIMAL+L'DECIMAL-1          | R6 := last digit of decimal.\n   N  R6,=F'15'                       | Throw away all but sign.\n   IF (CLM,R6,1,EQ,=X'0D')            | If INTEGER was negative, then\n     S   R4,=F'1'                     |   Retract start-of-number.\n     A   R5,=F'1'                     |   Add 1 to total length.\n     MVI 0(R4),C'-'                   |   Insert minus sign.\n   ENDIF                              | EndIf.\n*                                     |\n   L       R15,&PWA.SIZEMASK          | R15 := length-mask.\n   L       R14,PRM_ITS_RESLEN         | R14 -> result-length parm.\n   EXI     R15,(STCM,R5,0,0(R14))     | Save result-length.\n*                                     |\n   L       R2,PRM_ITS_STRING          | R2 -> STRING return area.\n   L       R1,PRM_ITS_LENGTH          | R1 -> STRING return area len.\n   SLR     R3,R3                      | Clear R3 for ICM below.\n   EXI     R15,(ICM,R3,0,0(R1))       | R3 := length of return area.\n   IF      (CR,R3,GT,R5)              | If larger than needed.\n     LR    R3,R5                      |   Use exact length needed.\n   ENDIF                              | EndIf.\n   MVCL    R2,R4                      | Copy formatted text to STRING.\n   ERREXIT CC4,CODE=&ST_TRUNCATED.    | Error if not enough room.\n ENDBLK BLOCK=INTEGER_TO_STRING\n EJECT\n**********************************************************************\n*                                                                    *\n* Error Exit: Save debugging information and perform any needed      *\n*             clean-up.  If CODE=xx is non-zero, it is used for the  *\n*             value of GDIRC. If it is zero, R15 is used for GDIRC.  *\n*                                                                    *\n**********************************************************************\n BLOCK TYPE=ERREXIT\n*---------------------------------------------------------------------*\n*  Save module/offset, registers, return-code.\n*---------------------------------------------------------------------*\n   STM   R0,R15,GDIREGS          | Save registers at time of error.\n   SM_LAL R0,&srv_modname+4      | Point to module identification.\n   ST    R0,GDIMODID             | Save in general debug area.\n   IF    (CLC,=H'0',EQ,0(R14))   | If CODE=00, then.\n     STH R15,GDIRC               |   GDIRC := R15.\n   ELSE                          | Else.\n     MVC   GDIRC,0(R14)          |   GDIRC := CODE.\n   ENDIF                         | EndIf.\n   SL    R14,=A(&srv_modname)    | Calculate offset at time of error.\n   STH   R14,GDIOFFST            | Save in debug area.\n   L     R2,PWAAESV              |\n   USING ESV,R2                  |\n   CALLX ESVESEPA,(ESVESTKN,&ES_SAVE_DEBUG_INFO,&ES_DEBUG_ID_GDI,GDI), +\n               VL\n   DROP  R2                      |\n*---------------------------------------------------------------------*\n*  If the format function was in progress, save the length of the\n*  incompletely formatted string.\n*---------------------------------------------------------------------*\n   L  R1,PRM_FUNCTIONCODE\n   L  R1,0(R1)\n   IF (C,R1,EQ,=F'&ST_FORMAT'),OR,(C,R1,EQ,=F'&ST_FORMAT2')\n     L   R1,PRM_F_STRING        |   R1 -> Target string.\n     L   R0,&PWA.STRING_HIGHWATER   R0 := Last byte formatted, + 1.\n     IF (C,R0,LT,&PWA.STRING_CURRENT) If highwater not up-to-date.\n       L R0,&PWA.STRING_CURRENT |       Use current position instead.\n     ENDIF                      |   EndIf.\n     SLR R0,R1                  |   R0 := Length formatted.\n     L   R1,PRM_F_FMT_LEN       |   R1 -> Formatted string length parm.\n     IF (TREG,R1,NZ)            |   If parameter is not missing.\n       L   R15,&PWA.SIZEMASK    |     R15 := length-mask.\n       EXI R15,(STCM,R0,0,0(R1))      Save as target string's length.\n     ENDIF                      |   EndIf.\n   ENDIF                        | EndIf.\n*---------------------------------------------------------------------*\n*  Pick up the return-code and exit the string-handler entirely.\n*---------------------------------------------------------------------*\n   LH   R15,GDIRC               |\n ENDBLK                         | Exit entire program w/return code.\n EJECT\n*---------------------------------------------------------------------*\n*\n*  Static Data\n*\n*---------------------------------------------------------------------*\n                 PSD\n                 LTORG\n&PSD.BIT_MASK    DC  B'0001',B'0011',B'0111',B'1111'\n*\n         MACRO\n&LABEL   TE  &LETTER,&JUSTIFY,&MIN,&MAX,&DEFAULT,&ROUTINE\n         GBLC &PWA\n         LCLC &JKWD\n&JKWD    SETC '&PWA.FSV_LEFT'\n         AIF  ('&JUSTIFY' EQ 'L').GENDC\n&JKWD    SETC '&PWA.FSV_RIGHT'\n         AIF  ('&JUSTIFY' EQ 'R').GENDC\n         MNOTE 8,'Default justification not (L)EFT or (R)IGHT.'\n.GENDC   ANOP\n&LABEL   DC  C'&LETTER'          | Format-spec letter for this type.\n         DC  AL1(&JKWD)          | Default justification for this type.\n         DC  AL4(&MIN)           | Minimum length for this type.\n         DC  AL4(&MAX)           | Maximum length for this type.\n         DC  AL4(&DEFAULT)       | Default length for this type.\n         DC  AL4(&ROUTINE)       | A(routine to format this type).\n         MEND\n*\n*                      Min   Max   Dflt    Formatting\n&PSD.TYPES EQU *  T J -----Lengths-----    Subroutine\n*\n&PSD.TYPE_A    TE A,R,00001,00004,00004,FORMAT_ADDRESS\n&PSD.TYPE_B    TE B,L,00001,00256,00001,FORMAT_BINARY\n&PSD.TYPE_C    TE C,L,00000,65535,00001,FORMAT_CHARACTER\n&PSD.TYPE_I    TE I,R,00001,00004,00004,FORMAT_SIGNED_INTEGER\n&PSD.TYPE_U    TE U,R,00001,00004,00004,FORMAT_UNSIGNED_INTEGER\n&PSD.TYPE_X    TE X,L,00000,65535,00001,FORMAT_HEX_CHARACTER\n&PSD.TYPES_E   EQU *-TYPE_ENTRY_L\n*\nCLASSIFICATION  DC   256C';'       <- default value = delimiter.\nDELIMITER       EQU  C';'\nLETTER          EQU  C'L'\nDIGIT           EQU  C'D'\n                ORG  CLASSIFICATION+C' '\n                DC   C';'\n                ORG  CLASSIFICATION+C'a'\n                DC   C'LLLLLLLLL'          LETTERS: abcdefghi\n                ORG  CLASSIFICATION+C'j'\n                DC   C'LLLLLLLLL'          LETTERS: jklmnopqr\n                ORG  CLASSIFICATION+C's'\n                DC   C'LLLLLLLL'           LETTERS: stuvwxyz\n                ORG  CLASSIFICATION+C'A'\n                DC   C'LLLLLLLLL'          LETTERS: ABCDEFGHI\n                ORG  CLASSIFICATION+C'J'\n                DC   C'LLLLLLLLL'          LETTERS: JKLMNOPQR\n                ORG  CLASSIFICATION+C'S'\n                DC   C'LLLLLLLL'           LETTERS: STUVWXYZ\n                ORG  CLASSIFICATION+C'0'\n                DC   C'DDDDDDDDDD'         DIGITS: 0123456789\n                ORG\n*---------------------------------------------------------------------*\n*  Translation table for folding character strings to uppercase.\n*---------------------------------------------------------------------*\nFOLD        DC  256AL1(*-FOLD) | Translate tbl for uppercase conv.\n            ORG FOLD+C'a'      | Fold lowercase 'a' - 'i'.\n            DC  C'ABCDEFGHI'   |\n            ORG FOLD+C'j'      | Fold lowercase 'j' - 'r'.\n            DC  C'JKLMNOPQR'   |\n            ORG FOLD+C's'      | Fold lowercase 's' - 'z'.\n            DC  C'STUVWXYZ'    |\n            ORG  ,\n*---------------------------------------------------------------------*\n*  Translation tables for converting char-to-hex and hex-to-char.\n*---------------------------------------------------------------------*\n&PSD.HEX_TAB  DC  256X'00'\n              ORG &PSD.HEX_TAB+C'a'\n              DC  X'FAFBFCFDFEFF'\n              ORG &PSD.HEX_TAB+C'A'\n              DC  X'FAFBFCFDFEFF'\n              ORG &PSD.HEX_TAB+C'0'\n              DC  C'0123456789'\n*\n              DC   C'0123456789ABCDEF'\nHEXCHARS      EQU  *-256\n              ENDPSD\n              EJECT\n*---------------------------------------------------------------------*\n*\n*  Program Work Area\n*\n*---------------------------------------------------------------------*\n                  PWA\n&PWA.#PARMS       DS   F         | Number of parameters passed in.\n&PWA.SIZELENGTH   DS   F         | Size of string length-specifiers.\n&PWA.SIZEMASK     DS   F         | Mask for <sizelength> values.\n*---------------------------------------------------------------------*\n* General use work area for performing conversions.\n*---------------------------------------------------------------------*\n&PWA.WORK         DS   0D,CL16   | &PWA.WORK for conversions.\n                  ORG  &PWA.WORK |\n&PWA.WORK0        DS   0CL1      | Conversion &PWA.WORK, with L'=1.\n&PWA.WORK1        DS   0CL1      |\n&PWA.WORK2        DS   0CL2      |\n&PWA.WORK3        DS   0CL3      |\n&PWA.WORK4        DS   0CL4      |\n&PWA.WORK8        DS   0CL8      | Conversion &PWA.WORK, with L'=8.\n&PWA.WORK9        DS   0CL9      | Conversion &PWA.WORK, with L'=9.\n&PWA.WORK16       DS   0CL16     | Conversion &PWA.WORK, with L'=16.\n                  ORG  ,         |\n&PWA.SUFFIX       DS   CL2       | st/nd/th suffix for integers.\nDECIMAL           DS   0D,CL9    | Packed decimal holding area.\n                  ORG  DECIMAL   |\nDECIMAL9          DS   0CL9      |\n                  ORG  ,         |\n&PWA.TRANTAB      DS   CL256     | General purpose tranlation table.\nFUNCTION_SPECIFIC DS   0D        | Function-specific work areas.\n*---------------------------------------------------------------------*\n* Format-string function's work area.\n*---------------------------------------------------------------------*\n&PWA.STRING_START     DS  A           | A(String).\n&PWA.STRING_CURRENT   DS  A           | A(current position in String).\n&PWA.STRING_HIGHWATER DS  A           | A(last char in String).\n&PWA.STRING_END       DS  A           | A(last char in String).\n*                                     |\n&PWA.CONTROL_START    DS  A           | A(Control string).\n&PWA.CONTROL_CURRENT  DS  A           | A(current position in Control).\n&PWA.CONTROL_END      DS  A           | A(last char in Control).\n&PWA.CONTROL_LEN      DS  F           | Length of Control string.\n*                                     |\n&PWA.ARGUMENT_LIST DS     2F          | <Argument> count/current.\n*                                     |\n&PWA.ST_FS_WORK       EQU *           | Workarea for 1 format-spec.\n&PWA.FS_CURRENT       DS  A           | A(current position in spec).\n&PWA.FS_LENGTH        DS  F           | Length from '{' to '}'.\n&PWA.FS_END           DS  A           | A(end of specification).\n&PWA.FS_FIELDS        DS  B           | Format-specification fields:\n&PWA.FSF_LEADING_PAD  EQU B'10000000' |   Leading '0' was specified.\n&PWA.FSF_WIDTH        EQU B'01000000' |   Width was specified.\n&PWA.FSF_PRECISION    EQU B'00100000' |   Precision was specified.\n&PWA.FSF_COLUMN       EQU B'00010000' |   Column was specified.\n&PWA.FSF_TYPE         EQU B'00001000' |   Type was specified.\n&PWA.FSF_LENGTH       EQU B'00000100' |   Length was specified.\n&PWA.FSF_KEYWORDS     EQU B'00000010' |   Keyword(s) were specified.\n&PWA.FSV_LEADING_PAD  DS  B           | Leading pad character.\n&PWA.FSV_WIDTH        DS  F           | Width value.\n&PWA.FSV_PRECISION    DS  F           | Precision value.\n&PWA.FSV_COLUMN       DS  C,FL4       | Column sign, value.\n&PWA.FSV_TYPE         DS  A           | Address of TYPE_ENTRY.\n&PWA.FSV_SOURCE       DS  A           | Address of source argument.\n&PWA.FSV_LENGTH       DS  F           | Length value.\n&PWA.FSV_KEYWORDS     DS  B           | Keyword value:\n&PWA.FSV_CAPS         EQU B'10000000' |   CAPS specified.\n&PWA.FSV_C1ST         EQU B'01000000' |   Capitalize 1st letter in fld.\n&PWA.FSV_CENTER       EQU B'00100000' |   CENTER specified.\n&PWA.FSV_LEFT         EQU B'00010000' |   LEFT specified.\n&PWA.FSV_RELATIVE     EQU B'00001000' |   RELATIVE specified.\n&PWA.FSV_RIGHT        EQU B'00000100' |   RIGHT specified.\n&PWA.FSV_TRIM         EQU B'00000010' |   TRIM specified.\n&PWA.FSV_FILL         EQU B'00000001' |   FILL specified.\n&PWA.FSV_FILL_LENGTH  DS  F           | Fill string length.\n&PWA.FSV_FILL_VALUE   DS  CL256       | Fill string value.\n&PWA.ST_FS_WORK_L     EQU *-&PWA.ST_FS_WORK\n*---------------------------------------------------------------------*\n* Debugging information in case of error.\n*---------------------------------------------------------------------*\n                  ES_GDI DSECT=NO\n                  ENDPWA\n                  EJECT\n*---------------------------------------------------------------------*\n* Mapping DSECT for one type-entry in the PSD Type-table.\n*---------------------------------------------------------------------*\nTYPE_ENTRY       DSECT\nTE_CHAR          DS CL1  | Format-spec letter for this type.\nTE_JUSTIFY       DS BL1  | Default justification: Left/Center/Right.\nTE_MIN           DS FL4  | Minimum length for this type.\nTE_MAX           DS FL4  | Maximum length for this type.\nTE_DEFAULT       DS FL4  | Default length for this type.\nTE_ROUTINE       DS AL4  | Address of routine to format this type.\nTYPE_ENTRY_L     EQU     *-TYPE_ENTRY\n*---------------------------------------------------------------------*\n* Environment Support Vector.\n*---------------------------------------------------------------------*\n                  ES_ESV\n                  EJECT\n*---------------------------------------------------------------------*\n* Parameter list for the string handler\n*---------------------------------------------------------------------*\nPARMLIST          DSECT              |\nPRM_STRINGTKN     DS  A              | String handler work area.\nPRM_FUNCTIONCODE  DS  A              | Function to be performed.\nPRM_FUNCTION_DEPT EQU *              | Function dependent parameters.\n*\n* Parameters for FunctionCode START.\n*\nPRM_S_ESV         DS  A              | Server Global Area.\nPRM_S_SIZELENGTH  DS  A              | Length of size-'bytes'.\n*\n* Parameters for FunctionCode FORMAT.\n*\n                  ORG PRM_FUNCTION_DEPT\nPRM_F_STRING      DS  A              | Target str for format results.\nPRM_F_STRING_LEN  DS  A              | Length of entire target area.\nPRM_F_FMT_LEN     DS  A              | Length of formatted string.\nPRM_F_CONTROL     DS  A              | Formatting control string.\nPRM_F_CONTROL_LEN DS  A              | Length of control string.\nPRM_F_ARGLIST     DS  A              | Separatly built argument plist.\nPRM_F_ARGCOUNT    DS  A              | Number of arguments in ARGLIST.\n*\n* Parameters for FunctionCode String_to_Integer.\n*\n                  ORG PRM_FUNCTION_DEPT\nPRM_STI_STRING    DS  A              | Source string of digits.\nPRM_STI_LENGTH    DS  A              | Length of source string.\nPRM_STI_INTEGER   DS  A              | Resulting binary integer.\n                  ORG\n*\n* Parameters for FunctionCode Integer_to_String.\n*\n                  ORG PRM_FUNCTION_DEPT\nPRM_ITS_INTEGER   DS  A              | Integer value to convert.\nPRM_ITS_STRING    DS  A              | Area to place converted integer.\nPRM_ITS_LENGTH    DS  A              | Length of target string.\nPRM_ITS_RESLEN    DS  A              | Length of result.\n                  ORG\n                  END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SRVSTMAC": {"ttr": 35594, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x02\\x00\\x00X\\x01\\x11)\\x9f\\x01\\x11)\\x9f\\t'\\x02H\\x02H\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@\"", "ispf": {"version": "02.00", "flags": 0, "createdate": "2011-10-26T00:00:00", "modifydate": "2011-10-26T09:27:58", "lines": 584, "newlines": 584, "modlines": 0, "user": "CLEMSON"}, "text": "*---------------------------------------------------------------------*\n*  Copyright 2011 by Clemson University Research Foundation           *\n*                                                                     *\n*  Licensed under the Apache License, Version 2.0 (the \"License\");    *\n*  you may not use this file except in compliance with the License.   *\n*  You may obtain a copy of the License in this library as member     *\n*  $LICENSE, or from                                                  *\n*                                                                     *\n*      http://www.apache.org/licenses/LICENSE-2.0                     *\n*                                                                     *\n*  Unless required by applicable law or agreed to in writing,         *\n*  software distributed under the License is distributed on an \"AS    *\n*  IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either    *\n*  express or implied.  See the License for the specific language     *\n*  governing permissions and limitations under the License.           *\n*---------------------------------------------------------------------*\n TITLE 'SRVSTMAC: String Handler Service Processor Symbols && Macros.'\n*---------------------------------------------------------------------*\n*\n*  Copy File:  SRVSTMAC\n*\n*  Purpose:    String Handler service processor symbols and macros.\n*\n*  Description: See \"Service Processors User's Guide and Reference\".\n*\n*  Change\n*  History:    04/04/89 MJM - New\n*              06/18/07 MJM - Added return codes.\n*\n*---------------------------------------------------------------------*\n*\n***********************************************************************\n***********************************************************************\n**                                                                   **\n**                     Symbol Definitions                            **\n**                                                                   **\n***********************************************************************\n***********************************************************************\n*\n* Global declarations for all string handler symbols.\n*\n GBLC &STRING_HANDLER\n GBLC &ST_STRING_HANDLER\n GBLA &ST_START,&ST_TERMINATE,&ST_FORMAT,&ST_FORMAT2\n GBLA &ST_STRING_TO_INTEGER,&ST_INTEGER_TO_STRING\n GBLA &ST_SUCCESS,&ST_INVALID_FUNCTION\n GBLA &ST_INVALID_SIZELENGTH,&ST_TRUNCATED\n GBLA &ST_OVERLAP\n GBLA &ST_INTERNAL_ERROR\n GBLA &ST_INVALID_SOURCE_LENGTH,&ST_INVALID_SOURCE_FORMAT\n GBLA &ST_MAGNITUDE\n GBLA &ST_FORMAT_COLUMN_TOO_LARGE,&ST_FORMAT_COLUMN_TOO_SMALL\n GBLA &ST_FORMAT_LENGTH_TOO_LARGE,&ST_FORMAT_LENGTH_TOO_SMALL\n GBLA &ST_FORMAT_MULTIPLE_TOO_SMALL\n GBLA &ST_FORMAT_PRECISION_TOO_SMALL,&ST_FORMAT_MISSING_ARGUMENT\n GBLA &ST_FORMAT_MISSING_COLUMN_VALUE,&ST_FORMAT_MISSING_LENGTH_VALUE\n GBLA &ST_FORMAT_MISSING_MULTIPLE_VALUE\n GBLA &ST_FORMAT_MISSING_PRECISION_VALUE,&ST_FORMAT_TYPE_REQUIRED\n GBLA &ST_FORMAT_SPEC_EMPTY,&ST_FORMAT_SPEC_NOT_ENDED\n GBLA &ST_FORMAT_UNSUPPORTED_KEYWORD,&ST_FORMAT_UNSUPPORTED_TYPE\n GBLA &ST_FORMAT_UNSUPPORTED_ITEM,&ST_FORMAT_PAD_TYPE_CONFLICT\n GBLA &ST_FORMAT_KEYWORD_CONFLICT,&ST_FORMAT_QST_TYPE_CONFLICT\n GBLA &ST_FORMAT_FILL_TOO_LONG\n GBLA &ST_BYTE,&ST_HALFWORD,&ST_THREE_BYTE,&ST_FULLWORD\n*\n* Entry Point name for the string handler.\n*\n&STRING_HANDLER                         SETC '''SRVST   '''\n&ST_STRING_HANDLER                      SETC '''SRVST   '''\n*\n* Function codes.\n*\n&ST_START                               SETA 1\n&ST_TERMINATE                           SETA 2\n&ST_FORMAT                              SETA 3\n&ST_STRING_TO_INTEGER                   SETA 4\n&ST_INTEGER_TO_STRING                   SETA 5\n&ST_FORMAT2                             SETA 6\n*\n* Return codes.\n*\n&ST_SUCCESS                             SETA 0\n&ST_INVALID_FUNCTION                    SETA 1\n&ST_INVALID_SIZELENGTH                  SETA 2\n&ST_TRUNCATED                           SETA 3\n&ST_OVERLAP                             SETA 4\n&ST_INTERNAL_ERROR                      SETA 5\n&ST_WRONG_NUMBER_OF_PARAMETERS          SETA 6\n&ST_INVALID_SOURCE_LENGTH               SETA 7\n&ST_INVALID_SOURCE_FORMAT               SETA 8\n&ST_MAGNITUDE                           SETA 9\n&ST_FORMAT_COLUMN_TOO_LARGE             SETA 10\n&ST_FORMAT_COLUMN_TOO_SMALL             SETA 11\n&ST_FORMAT_LENGTH_TOO_LARGE             SETA 12\n&ST_FORMAT_LENGTH_TOO_SMALL             SETA 13\n&ST_FORMAT_PRECISION_TOO_SMALL          SETA 14\n&ST_FORMAT_MISSING_ARGUMENT             SETA 15\n&ST_FORMAT_MISSING_COLUMN_VALUE         SETA 16\n&ST_FORMAT_MISSING_LENGTH_VALUE         SETA 17\n&ST_FORMAT_MISSING_PRECISION_VALUE      SETA 18\n&ST_FORMAT_TYPE_REQUIRED                SETA 19\n&ST_FORMAT_SPEC_EMPTY                   SETA 20\n&ST_FORMAT_SPEC_NOT_ENDED               SETA 21\n&ST_FORMAT_UNSUPPORTED_KEYWORD          SETA 22\n&ST_FORMAT_UNSUPPORTED_TYPE             SETA 23\n&ST_FORMAT_UNSUPPORTED_ITEM             SETA 24\n&ST_FORMAT_PAD_TYPE_CONFLICT            SETA 25\n&ST_FORMAT_FILL_TOO_LONG                SETA 26\n&ST_FORMAT_MISSING_MULTIPLE_VALUE       SETA 27\n&ST_FORMAT_MULTIPLE_TOO_SMALL           SETA 28\n&ST_FORMAT_MULTIPLE_NOT_ALLOWED         SETA 29\n&ST_FORMAT_KEYWORD_CONFLICT             SETA 30\n&ST_FORMAT_QST_TYPE_CONFLICT            SETA 31\n DEFUCOND MACRO=SRV##RC,NAME=ST_SUCCESS\n DEFUCOND MACRO=SRV##RC,NAME=ST_INVALID_FUNCTION\n DEFUCOND MACRO=SRV##RC,NAME=ST_INVALID_SIZELENGTH\n DEFUCOND MACRO=SRV##RC,NAME=ST_TRUNCATED\n DEFUCOND MACRO=SRV##RC,NAME=ST_OVERLAP\n DEFUCOND MACRO=SRV##RC,NAME=ST_INTERNAL_ERROR\n DEFUCOND MACRO=SRV##RC,NAME=ST_WRONG_NUMBER_OF_PARAMETERS\n DEFUCOND MACRO=SRV##RC,NAME=ST_INVALID_SOURCE_LENGTH\n DEFUCOND MACRO=SRV##RC,NAME=ST_INVALID_SOURCE_FORMAT\n DEFUCOND MACRO=SRV##RC,NAME=ST_MAGNITUDE\n DEFUCOND MACRO=SRV##RC,NAME=ST_FORMAT_COLUMN_TOO_LARGE\n DEFUCOND MACRO=SRV##RC,NAME=ST_FORMAT_COLUMN_TOO_SMALL\n DEFUCOND MACRO=SRV##RC,NAME=ST_FORMAT_LENGTH_TOO_LARGE\n DEFUCOND MACRO=SRV##RC,NAME=ST_FORMAT_LENGTH_TOO_SMALL\n DEFUCOND MACRO=SRV##RC,NAME=ST_FORMAT_MISSING_MULTIPLE_VALUE\n DEFUCOND MACRO=SRV##RC,NAME=ST_FORMAT_MULTIPLE_TOO_SMALL\n DEFUCOND MACRO=SRV##RC,NAME=ST_FORMAT_PRECISION_TOO_SMALL\n DEFUCOND MACRO=SRV##RC,NAME=ST_FORMAT_MISSING_ARGUMENT\n DEFUCOND MACRO=SRV##RC,NAME=ST_FORMAT_MISSING_COLUMN_VALUE\n DEFUCOND MACRO=SRV##RC,NAME=ST_FORMAT_MISSING_LENGTH_VALUE\n DEFUCOND MACRO=SRV##RC,NAME=ST_FORMAT_MISSING_PRECISION_VALUE\n DEFUCOND MACRO=SRV##RC,NAME=ST_FORMAT_TYPE_REQUIRED\n DEFUCOND MACRO=SRV##RC,NAME=ST_FORMAT_SPEC_EMPTY\n DEFUCOND MACRO=SRV##RC,NAME=ST_FORMAT_SPEC_NOT_ENDED\n DEFUCOND MACRO=SRV##RC,NAME=ST_FORMAT_UNSUPPORTED_KEYWORD\n DEFUCOND MACRO=SRV##RC,NAME=ST_FORMAT_UNSUPPORTED_TYPE\n DEFUCOND MACRO=SRV##RC,NAME=ST_FORMAT_UNSUPPORTED_ITEM\n DEFUCOND MACRO=SRV##RC,NAME=ST_FORMAT_PAD_TYPE_CONFLICT\n DEFUCOND MACRO=SRV##RC,NAME=ST_FORMAT_FILL_TOO_LONG\n DEFUCOND MACRO=SRV##RC,NAME=ST_FORMAT_KEYWORD_CONFLICT\n DEFUCOND MACRO=SRV##RC,NAME=ST_FORMAT_QST_TYPE_CONFLICT\n*\n* Valid SIZELENGTH values.\n*\n&ST_BYTE                                SETA 1\n&ST_HALFWORD                            SETA 2\n&ST_THREE_BYTE                          SETA 3\n&ST_FULLWORD                            SETA 4\n                        EJECT\n***********************************************************************\n***********************************************************************\n**                                                                   **\n**                     Macro Definitions                             **\n**                                                                   **\n***********************************************************************\n***********************************************************************\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   ST_ID                                                      *\n*                                                                     *\n* Purpose: Establish default values for a specific service processor  *\n*          and associate them with the specified ID name. The values  *\n*          are stored in the following created global variables:      *\n*                                                                     *\n* Variable Name                     Description                       *\n* -------------  ---------------------------------------------------- *\n* #$&ID.$#IDMAC  Name of macro that created the ID: ST_ID.            *\n* #$&ID.$#ESID   Service processor's Environment Support ID.          *\n* #$&ID.$#EPN    Tag for Service processor's Entry Point Name.        *\n* #$&ID.$#EPA    Tag for Service processor's Entry Point Address.     *\n* #$&ID.$#TKN    Tag for Service processor's Entry Point Token.       *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         ST_ID &ID=,&ESVA=,&SPEPNAME=,&SPEPA=,&SPTOKEN=,&ESID=,        +\n               &SIZELENGTH=,&STRING=,&RESULTLEN=\n         LCLC  &V_STRING(2),&V_RESULTLEN,&V_SIZELENGTH\n         LCLC  &L_EPNAME\n         GBLC  &STRING_HANDLER\n.*\n.* If no EPNAME was specified, use the generic String Handler.\n.*\n&L_EPNAME SETC '&SPEPNAME'\n          AIF  ('&L_EPNAME' NE '').PAST_EPN\n&L_EPNAME SETC '&STRING_HANDLER'\n.PAST_EPN ANOP\n.*\n.* Invoke SRV##ID to create globals used by all ID's.\n.*\n         SRV##ID SET,                                                  +\n               ID=&ID.,IDMAC=ST_ID,ESID=&ESID.,SPEPNAME=&L_EPNAME,     +\n               SPEPA=&SPEPA,SPTOKEN=&SPTOKEN.\n.*\n.* Establish defaults for parameters specific to the string handler.\n.*\n&V_SIZELENGTH    SETC '#$&ID.$#SIZELENGTH'  Variable for SIZELENGTH=.\n                 GBLC &(&V_SIZELENGTH)      Declare global variable.\n&(&V_SIZELENGTH) SETC ''                    Set sizelength's default.\n                 AIF  ('&SIZELENGTH' EQ '').GOT_SIZELENGTH\n                 AIF  (T'&SIZELENGTH EQ 'N').SL_NUMERIC\n                 MNOTE 8,'If SIZELENGTH is specified on the ST_ID macro+\n               , it must be a self-defining numeric value.'\n                 AGO   .GOT_SIZELENGTH\n.SL_NUMERIC      ANOP\n&(&V_SIZELENGTH) SETC '&SIZELENGTH'         Copy value (or nulls).\n.GOT_SIZELENGTH  ANOP\n.*\n&V_STRING(1)     SETC '#$&ID.$#STRING1'     Variable for STRING=.\n&V_STRING(2)     SETC '#$&ID.$#STRING2'     Variable for STRING=.\n                 GBLC &(&V_STRING(1)),&(&V_STRING(2))\n.*\n&(&V_STRING(1))  SETC '&STRING(1)'\n&(&V_STRING(2))  SETC '&STRING(2)'\n.*\n&V_RESULTLEN     SETC '#$&ID.$#RESULTLEN'   Variable for RESULTLEN=.\n                 GBLC &(&V_RESULTLEN)\n&(&V_RESULTLEN)  SETC '&RESULTLEN'\n                 MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   ST_START                                                   *\n* Purpose: Generate code to start a new string handler session.       *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         ST_START &ID=,&SPEPA=,&SPTOKEN=,&ESVA=,&SIZELENGTH=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN\n         GBLA  &ST_START                  SETC in open code.\n         LCLC  &V_SIZELENGTH\n         LCLC  &L_SIZELENGTH\n.*\n.* Obtain service processor ID values and start string handler.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN,ESVA),                    +\n               ID=&ID,IDMAC=ST_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN,       +\n               ESVA=&ESVA.\n         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT\n.*\n.* Obtain the value for the SIZELENGTH keyword.\n.*\n&V_SIZELENGTH    SETC '#$&ID.$#SIZELENGTH'  Variable for SIZELENGTH=.\n                 GBLC &(&V_SIZELENGTH)      Declare global variable.\n&L_SIZELENGTH    SETC '&(&V_SIZELENGTH)'    Set default value.\n                 AIF  ('&L_SIZELENGTH' EQ '').SL_OKAY\n                 AIF  ('&SIZELENGTH' EQ '').SL_DONE\n                 AIF  ('&L_SIZELENGTH' EQ '&SIZELENGTH').SL_DONE\n                 MNOTE 4,'Warning: SIZELENGTH was specified with a diff+\n               erent value on the ST_ID ID=&ID. instruction.'\n.SL_OKAY         ANOP\n&L_SIZELENGTH    SETC '&SIZELENGTH'\n.SL_DONE         ANOP\n.*\n.* Generate the call to the ST_START function.\n.*\n         MVC   &#_IDTKN,=F'0'            | Insure TOKEN = 0.\n         ##PLIST START\n         ##PLIST PARM,&#_IDTKN,&ST_START,&#_IDESVA\n         AIF     ('&L_SIZELENGTH' EQ '').CALLX\n.PARM1   ##PLIST PARM,&L_SIZELENGTH\n.CALLX   ##PLIST END,VL                  | Finish off parm list.\n         CALLX   &#_IDEPA                | Invoke String Handler.\n         MEXIT\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   ST_TERMINATE                                               *\n* Purpose: Generate code to terminate a string handler session.       *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         ST_TERMINATE &ID=,&SPEPA=,&SPTOKEN=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN\n         GBLA  &ST_TERMINATE              SETC in open code.\n.*\n.* Obtain service processor ID values and terminate service processor.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +\n               ID=&ID,IDMAC=ST_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN\n         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT\n         CALLX &#_IDEPA,(&#_IDTKN,&ST_TERMINATE),VL\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   ST_FORMAT                                                  *\n* Purpose: Build a formatted string from arguments, based on a format *\n*          control string.                                            *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         ST_FORMAT &ID=,&SPEPA=,&SPTOKEN=,                             +\n               &CONTROL=,&SOURCE=,&SOURCELIST=,&STRING=,&RESULTLEN=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN\n         GBLA  &ST_FORMAT,&ST_FORMAT2\n         LCLC  &C_ADDR,&C_LEN\n         LCLC  &S_ADDR,&S_LEN\n         LCLC  &V_STRING(2),&V_RESULTLEN,&V_SIZELENGTH\n         LCLC  &L_STRING(2),&L_RSLTLEN\n         LCLA  &N\n         LCLC  &KEYWORD\n.*\n.* Obtain service processor ID values.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +\n               ID=&ID,IDMAC=ST_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN\n         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT\n.*\n&V_SIZELENGTH  SETC '#$&ID.$#SIZELENGTH'  Variable for SIZELENGTH=.\n               GBLC &(&V_SIZELENGTH)      Declare global variable.\n.*\n.* If STRING= or RESULTLEN= are missing, supply default values.\n.*\n&L_STRING(1)    SETC '&STRING(1)'\n&L_STRING(2)    SETC '&STRING(2)'\n                AIF ('&L_STRING(1)' NE '').STRING_NBLK\n&V_STRING(1)    SETC '#$&ID.$#STRING1'     Variable for STRING=.\n&V_STRING(2)    SETC '#$&ID.$#STRING2'     Variable for STRING=.\n                GBLC &(&V_STRING(1))       Declare global variable.\n                GBLC &(&V_STRING(2))       Declare global variable.\n&L_STRING(1)    SETC '&(&V_STRING(1))'     Copy default value.\n&L_STRING(2)    SETC '&(&V_STRING(2))'     Copy default value.\n.STRING_NBLK    ANOP\n.*\n&L_RSLTLEN     SETC '&RESULTLEN'\n               AIF ('&RESULTLEN' NE '').RESLT_NBLK\n&V_RESULTLEN   SETC '#$&ID.$#RESULTLEN'   Variable for RESULTLEN=.\n               GBLC &(&V_RESULTLEN)       Declare global variable.\n&L_RSLTLEN     SETC '&(&V_RESULTLEN)'     Copy default value.\n.RESLT_NBLK    ANOP\n.*\n.* Process the CONTROL keyword to get an address and length.\n.*\n&KEYWORD      SETC 'CONTROL'\n              AIF ('&CONTROL' EQ '').NO_CONTROL\n              AIF (N'&CONTROL EQ 1).CTL_TAGONLY  CONTROL=tag.\n              AIF (N'&CONTROL EQ 2).CTL_TAGLEN   CONTROL=(tag,len).\n              MNOTE 8,'Too many subparameters for CONTROL keyword.'\n              MEXIT\n.*\n.CTL_TAGLEN   ANOP\n&C_ADDR       SETC '&CONTROL(1)'          | Set addr.\n&C_LEN        SETC '&CONTROL(2)'          | Set len.\n              AGO  .PAST_CONTROL          |\n.CTL_TAGONLY  AIF  ('&(&V_SIZELENGTH)' EQ '').NO_SIZELENGTH\n              AIF  ('&CONTROL'(1,1) EQ '''').CTL_LITERAL\n&C_ADDR       SETC '&CONTROL'             | Set addr to tag_name.\n&C_LEN        SETC '=AL&(&V_SIZELENGTH).(L''&CONTROL)'  Get tag length.\n              AGO  .PAST_CONTROL          |\n.CTL_LITERAL  ANOP                        |\n&C_ADDR       SETC '&CONTROL'             | Set addr to actual literal.\n&L            SETA 0                      | Length counter = 0.\n&I            SETA 2                      | Index counter -> past '.\n.CTL_LOOP     AIF  (&I GE K'&C_ADDR).CTL_ELOOP       Loop over CONTROL.\n              AIF  ('&C_ADDR'(&I,1) NE '''').CTL_TXT If doubled quotes.\n&I            SETA &I+1                   |            Advance past '.\n.CTL_TXT      ANOP                        |          EndIf.\n&L            SETA &L+1                   |   Add one to length.\n&I            SETA &I+1                   |   Advance to next position.\n              AGO  .CTL_LOOP              | End of counting loop.\n.CTL_ELOOP    ANOP                        |\n&C_LEN        SETC '=AL&(&V_SIZELENGTH).(&L)'  Set length parameter.\n              AGO  .PAST_CONTROL\n.NO_CONTROL   MNOTE 8,'CONTROL is a required keyword.'\n              MEXIT\n.PAST_CONTROL ANOP\n.*\n.* Process the STRING keyword to get an address and length.\n.*\n&KEYWORD      SETC 'STRING'\n              AIF ('&L_STRING(1)' EQ '').NO_STRING\n              AIF ('&L_STRING(1)'(1,1) EQ '''').STR_LITERAL\n              AIF ('&L_STRING(2)' EQ '').STR_TAGONLY\n&S_ADDR       SETC '&L_STRING(1)'         | Set addr.\n&S_LEN        SETC '&L_STRING(2)'         | Set len.\n              AGO  .PAST_STRING           |\n.STR_TAGONLY  AIF  ('&(&V_SIZELENGTH)' EQ '').NO_SIZELENGTH\n&S_ADDR       SETC '&L_STRING(1)'         | Set addr to tag_name.\n&S_LEN        SETC '=AL&(&V_SIZELENGTH).(L''&L_STRING(1))'\n              AGO  .PAST_STRING           |\n.STR_LITERAL  ANOP                        |\n              MNOTE 8,'STRING string cannot be a literal.'\n              MEXIT\n.NO_STRING    MNOTE 8,'STRING is a required keyword.'\n              MEXIT\n.PAST_STRING  ANOP\n.*\n.* Check to see that SOURCE and SOURCELIST weren't both specified.\n.*\n        AIF  ('&SOURCELIST' EQ '' OR '&SOURCE' EQ '').PAST_SOURCE\n        MNOTE 8,'Keywords SOURCE and SOURCELIST are mutually exclusive'\n        MEXIT\n.PAST_SOURCE ANOP\n.*\n.* Generate the CALLX to the string handler.\n.*\n         ##PLIST START\n         AIF  ('&SOURCELIST' NE '').FORMAT2\n         ##PLIST PARM,&#_IDTKN,&ST_FORMAT,&S_ADDR,&S_LEN,&L_RSLTLEN\n         ##PLIST PARM,&C_ADDR,&C_LEN\n&N       SETA    1\n.SOURCES AIF     (&N GT N'&SOURCE).CALLX\n         ##PLIST PARM,&SOURCE(&N)\n&N       SETA    &N+1\n         AGO     .SOURCES\n.FORMAT2 ##PLIST PARM,&#_IDTKN,&ST_FORMAT2,&S_ADDR,&S_LEN,&L_RSLTLEN\n         ##PLIST PARM,&C_ADDR,&C_LEN,&SOURCELIST(1),&SOURCELIST(2)\n.CALLX   ##PLIST END,VL\n         CALLX   &#_IDEPA\n         MEXIT\n.*\n.* Generate an error message when SIZELENGTH is needed but \u00acavailable.\n.*\n.NO_SIZELENGTH ANOP\n         MNOTE 8,'Explicit lengths must be specified unless the SIZELEN+\n               GTH keyword has been coded on the ST_ID macro.'\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   ST_STRING_TO_INTEGER                                       *\n* Purpose: Convert a text string to a signed binary fullword integer. *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         ST_STRING_TO_INTEGER &ID=,&SPEPA=,&SPTOKEN=,                  +\n               &STRING=,&INTEGER=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN\n         GBLA  &ST_STRING_TO_INTEGER\n         LCLC  &V_SIZELENGTH,&V_STRING(2)\n         LCLC  &S_ADDR,&S_LEN\n         LCLC  &L_STRING(2)\n.*\n.* Obtain service processor ID values.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +\n               ID=&ID,IDMAC=ST_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN\n         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT\n&V_SIZELENGTH  SETC '#$&ID.$#SIZELENGTH'  Variable for SIZELENGTH=.\n               GBLC &(&V_SIZELENGTH)      Declare global variable.\n.*\n.* Process the STRING keyword to get an address and length.\n.*\n                AIF   (N'&STRING LE 2).STRING1\n                MNOTE 8,'Too many subparameters for STRING keyword.'\n                MEXIT\n.STRING1        ANOP\n&L_STRING(1)    SETC '&STRING(1)'\n&L_STRING(2)    SETC '&STRING(2)'\n                AIF ('&L_STRING(1)' NE '').GOT_STRING\n&V_STRING(1)    SETC '#$&ID.$#STRING1'     Variable for STRING=.\n&V_STRING(2)    SETC '#$&ID.$#STRING2'     Variable for STRING=.\n                GBLC &(&V_STRING(1))       Declare global variable.\n                GBLC &(&V_STRING(2))       Declare global variable.\n&L_STRING(1)    SETC '&(&V_STRING(1))'     Copy default value.\n&L_STRING(2)    SETC '&(&V_STRING(2))'     Copy default value.\n.GOT_STRING     ANOP\n                AIF ('&L_STRING(1)' EQ '').NO_STRING\n                AIF ('&L_STRING(2)' EQ '').STR_TAGONLY\n&S_ADDR         SETC '&L_STRING(1)'         | Set addr.\n&S_LEN          SETC '&L_STRING(2)'         | Set len.\n                AGO  .PAST_STRING           |\n.STR_TAGONLY    AIF  ('&(&V_SIZELENGTH)' EQ '').NO_SIZELENGTH\n                AIF ('&L_STRING(1)'(1,1) EQ '''').STR_LITERAL\n&S_ADDR         SETC '&L_STRING(1)'         | Set addr to tag_name.\n&S_LEN          SETC '=AL&(&V_SIZELENGTH).(L''&L_STRING(1))'\n                AGO  .PAST_STRING           |\n.STR_LITERAL    ANOP                        |\n&S_ADDR         SETC '&L_STRING(1)'         | Set addr to value.\n&L              SETA 0                      | Length counter = 0.\n&I              SETA 2                      | Index counter -> past '.\n.STR_LOOP       AIF  (&I GE K'&S_ADDR).STR_ELOOP     Loop over STRING.\n                AIF  ('&S_ADDR'(&I,1) NE '''').STR_TXT If doubled.\n&I              SETA &I+1                   |             Advance.\n.STR_TXT        ANOP                        |          EndIf.\n&L              SETA &L+1                   |   Add one to length.\n&I              SETA &I+1                   |   Advance.\n                AGO  .STR_LOOP              | End of counting loop.\n.STR_ELOOP      ANOP                        |\n&S_LEN          SETC '=AL&(&V_SIZELENGTH).(&L)'  Set length parameter.\n                AGO  .PAST_STRING\n.NO_STRING      MNOTE 8,'STRING is a required keyword.'\n                MEXIT\n.PAST_STRING    ANOP\n.*\n.* Verify that the INTEGER keyword was specified.\n.*\n              AIF   ('&INTEGER' NE '').PAST_INTEGER\n.NO_INTEGER   MNOTE 8,'INTEGER is a required keyword.'\n              MEXIT\n.PAST_INTEGER ANOP\n.*\n.* Generate the conversion call to the string handler.\n.*\n         CALLX &#_IDEPA,(&#_IDTKN,&ST_STRING_TO_INTEGER,&S_ADDR,&S_LEN,+\n               &INTEGER),VL\n         MEXIT\n.NO_SIZELENGTH ANOP\n         MNOTE 8,'Explicit string lengths must be provided unless SIZEL+\n                ENGTH was specified on the ST_ID macro.'\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   ST_INTEGER_TO_STRING                                       *\n* Purpose: Convert a signed binary fullword integer to text.          *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         ST_INTEGER_TO_STRING &ID=,&SPEPA=,&SPTOKEN=,                  +\n               &INTEGER=,&STRING=,&RESULTLEN=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN\n         GBLA  &ST_INTEGER_TO_STRING\n         LCLC  &V_SIZELENGTH,&V_STRING(2),&V_RESULTLEN\n         LCLC  &L_STRING(2)\n         LCLC  &S_ADDR,&S_LEN,&L_RSLTLEN\n.*\n.* Obtain service processor ID values.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +\n               ID=&ID,IDMAC=ST_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN\n         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT\n&V_SIZELENGTH  SETC '#$&ID.$#SIZELENGTH'  Variable for SIZELENGTH=.\n               GBLC &(&V_SIZELENGTH)      Declare global variable.\n.*\n&L_RSLTLEN     SETC '&RESULTLEN'\n               AIF ('&RESULTLEN' NE '').RESLT_NBLK\n&V_RESULTLEN   SETC '#$&ID.$#RESULTLEN'   Variable for RESULTLEN=.\n               GBLC &(&V_RESULTLEN)       Declare global variable.\n&L_RSLTLEN     SETC '&(&V_RESULTLEN)'     Copy default value.\n.RESLT_NBLK    ANOP\n.*\n.* Process the STRING keyword to get an address and length.\n.*\n                AIF   (N'&STRING LE 2).STRING1\n                MNOTE 8,'Too many subparameters for STRING keyword.'\n                MEXIT\n.STRING1        ANOP\n&L_STRING(1)    SETC '&STRING(1)'\n&L_STRING(2)    SETC '&STRING(2)'\n                AIF ('&L_STRING(1)' NE '').GOT_STRING\n&V_STRING(1)    SETC '#$&ID.$#STRING1'     Variable for STRING=.\n&V_STRING(2)    SETC '#$&ID.$#STRING2'     Variable for STRING=.\n                GBLC &(&V_STRING(1))       Declare global variable.\n                GBLC &(&V_STRING(2))       Declare global variable.\n&L_STRING(1)    SETC '&(&V_STRING(1))'     Copy default value.\n&L_STRING(2)    SETC '&(&V_STRING(2))'     Copy default value.\n.GOT_STRING     AIF ('&L_STRING(1)' EQ '').NO_STRING\n                AIF ('&L_STRING(2)' EQ '').STR_TAGONLY\n&S_ADDR         SETC '&L_STRING(1)'         | Set addr.\n&S_LEN          SETC '&L_STRING(2)'         | Set len.\n                AGO  .PAST_STRING           |\n.STR_TAGONLY    AIF  ('&(&V_SIZELENGTH)' EQ '').NO_SIZELENGTH\n                AIF ('&L_STRING(1)'(1,1) EQ '''').STR_LITERAL\n&S_ADDR         SETC '&L_STRING(1)'         | Set addr to tag_name.\n&S_LEN          SETC '=AL&(&V_SIZELENGTH).(L''&L_STRING(1))'\n                AGO  .PAST_STRING           |\n.STR_LITERAL    ANOP                        |\n                MNOTE 8,'Cannot use a literal for STRING.'\n                MEXIT\n.NO_STRING      MNOTE 8,'STRING is a required keyword.'\n                MEXIT\n.PAST_STRING    ANOP\n.*\n.* Verify that the INTEGER keyword was specified.\n.*\n              AIF   ('&INTEGER' NE '').PAST_INTEGER\n.NO_INTEGER   MNOTE 8,'INTEGER is a required keyword.'\n              MEXIT\n.PAST_INTEGER ANOP\n.*\n.* Generate the conversion call to the string handler.\n.*\n         CALLX &#_IDEPA,(&#_IDTKN,&ST_INTEGER_TO_STRING,&INTEGER,      +\n               &S_ADDR,&S_LEN,&L_RSLTLEN),VL\n         MEXIT\n.NO_SIZELENGTH ANOP\n         MNOTE 8,'Explicit lengths must be provided unless the SIZELENG+\n                TH keyword is specified on the ST_ID macro.'\n.MEXIT   MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SRVSTXRZ": {"ttr": 35850, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x02\\x00\\x00X\\x01\\x11)\\x9f\\x01\\x11)\\x9f\\t'\\x00\\xdd\\x00\\xdd\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@\"", "ispf": {"version": "02.00", "flags": 0, "createdate": "2011-10-26T00:00:00", "modifydate": "2011-10-26T09:27:58", "lines": 221, "newlines": 221, "modlines": 0, "user": "CLEMSON"}, "text": "*---------------------------------------------------------------------*\n*  Copyright 2011 by Clemson University Research Foundation           *\n*                                                                     *\n*  Licensed under the Apache License, Version 2.0 (the \"License\");    *\n*  you may not use this file except in compliance with the License.   *\n*  You may obtain a copy of the License in this library as member     *\n*  $LICENSE, or from                                                  *\n*                                                                     *\n*      http://www.apache.org/licenses/LICENSE-2.0                     *\n*                                                                     *\n*  Unless required by applicable law or agreed to in writing,         *\n*  software distributed under the License is distributed on an \"AS    *\n*  IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either    *\n*  express or implied.  See the License for the specific language     *\n*  governing permissions and limitations under the License.           *\n*---------------------------------------------------------------------*\nSRVSTXRZ     TITLE 'String Handler Exercise Program'\n*---------------------------------------------------------------------*\n*\n*  Copyright (C) 1989 Clemson University\n*\n*  Program     SRVXRSTR\n*\n*  Abstract    This program is a test suite for the String Handler.  It\n*              calls the String Handler repeatedly with different\n*              functions and values to exercise as much code as\n*              possible.\n*\n*  To use, first assemble using %ASM and then run this job:\n*\n*  //SRVSTXRZ JOB\n*  //RUNST    EXEC PGM=SRVSTXRZ\n*  //STEPLIB  DD DISP=SHR,DSN=SYSTEMS.SRV.LOAD\n*\n*  Output is in the JOB's messages log.\n*\n*---------------------------------------------------------------------*\n  EJECT\n  COPY SMSYMS\n  COPY SRVESMAC\n  COPY SRVSTMAC\n  BLOCK TYPE=PROGRAM,NAME=SRVXRSTR,OPTIONS=(*PWA,XA),                  +\n               AMODE=31,RMODE=ANY,BASEREG=(R12,R11),SUBOPTS=(*SWA)\n*---------------------------------------------------------------------*\n*   Load and start Environment Support and the String Handler sessions.\n*---------------------------------------------------------------------*\n    ES_ID ID=ES,SPEPNAME=&MVS_ENVIRONMENT_SUPPORT\n    ST_ID ID=ST,SPEPNAME=&STRING_HANDLER,SIZELENGTH=4,                 +\n               STRING=&PWA.STRING,RESULTLEN=&PWA.STRING_LEN\n    ES_MVS_LOAD    ID=ES\n    ES_START       ID=ES\n    ES_LOAD_MODULE ID=ES,SPID=ST\n    ST_START       ID=ST\n*\n    ES_GET_FORMATTED_TIME ID=ES,JULIAN=&PWA.JULIAN\n    ES_GET_FORMATTED_TIME ID=ES,GREGORIAN=&PWA.GREGORIAN\n    ES_GET_FORMATTED_TIME ID=ES,TIME=&PWA.TIME\n    ES_GET_FORMATTED_TIME ID=ES,TIME=&PWA.TIME,JULIAN=&PWA.JULIAN\n    ES_GET_FORMATTED_TIME ID=ES,TIME=&PWA.TIME,GREGORIAN=&PWA.GREGORIAN\n    ES_GET_FORMATTED_TIME ID=ES,GREGORIAN=&PWA.GREGORIAN,              +\n               JULIAN=&PWA.JULIAN\n*---------------------------------------------------------------------*\n*   Invoke the ST_STRING_TO_INTEGER and ST_INTEGER_TO_STRING functions.\n*---------------------------------------------------------------------*\n    ST_STRING_TO_INTEGER ID=ST,STRING='  -   987654321    ',           +\n               INTEGER=&PWA.INTEGER\n    ERREXIT (TREG,R15,NZ)\n    ST_INTEGER_TO_STRING ID=ST,INTEGER=&PWA.INTEGER\n    ERREXIT (TREG,R15,NZ)\n    ES_DISPLAY_MESSAGE   ID=ES,MESSAGE='Converted INTEGER:'\n    ES_DISPLAY_MESSAGE   ID=ES,MESSAGE=(&PWA.STRING,&PWA.STRING_LEN)\n*---------------------------------------------------------------------*\n*   Invoke the ST_FORMAT macro directly several times to make sure it\n*   is doing the right checks and generating the right code.\n*---------------------------------------------------------------------*\n*   ST_FORMAT ID=ST,....\n*---------------------------------------------------------------------*\n*   The macro below is for invoking ST_FORMAT2 by way of a subroutine.\n*---------------------------------------------------------------------*\n            MACRO\n            FMT &CONTROL,&SOURCE\n            GBLC    &PWA\n            LCLC    &OLDLOC\n            LCLA    &N\n&OLDLOC     SETC    '&SYSLOC'\nCTLSTR      LOCTR\nC_L&SYSNDX  DC     AL4(L'C_T&SYSNDX)\nC_T&SYSNDX  DC     C&CONTROL\n&OLDLOC     LOCTR\n&N          SETA      N'&SOURCE\n            AIF       (&N EQ 0).CALLSUB\n            PLIST     &SOURCE,PL=(&PWA.ARGLIST,20)\n.CALLSUB    CALLSUB   FORMAT,(C_T&SYSNDX,C_L&SYSNDX,&PWA.ARGLIST,&N)\n            MEND\n*---------------------------------------------------------------------*\n* FILL Keyword string-format tests.\n*---------------------------------------------------------------------*\n FMT  '{40CL? F( .)}{CL?}',('Name',4,'Michael J Miller',16)\n FMT  '{40CL? F(\" .\")}{CL?}',('Address',7,'1401 Garden Circle',18)\n FMT  '{40CL? F(C\"-FILL\")}{CL?}',('City',4,'Seneca',6)\n FMT  '{40CL? F(X\"6040\")}{CL?}',('State',5,'S.C.',4)\n FMT  '{40CL? FILL(?L2)}{CL?}',('Country',7,' $','America',7)\n FMT  '{40CL? FILL(?L?)}{CL?}',('Planet',6,'-where',6,'Earth',5)\n*---------------------------------------------------------------------*\n* General string-format tests.\n*---------------------------------------------------------------------*\n FMT  'No format-specifications in this string.'\n FMT  '{///}at{@?} either!',&PWA.STRING_LEN\n FMT  'EveryThing: {{ xxx {?2.?@+?CL?1 TRIM CENTER}{@15}-->{@}.',      +\n               (=AL2(30),15,=A(-1),'<<>> ',=AL1(5))\n*---------------------------------------------------------------------*\n* TYPE(Address) string-format tests.\n*---------------------------------------------------------------------*\n FMT  '{A}',(=A(SRVXRSTR))\n FMT  '{0A}',(=A(SRVXRSTR))\n FMT  '{0AL2}',(=A(SRVXRSTR))\n*---------------------------------------------------------------------*\n* TYPE(Bit string) string-format tests.\n*---------------------------------------------------------------------*\n FMT  '{B}',(=A(SRVXRSTR))\n FMT  '{BL2}',(=A(SRVXRSTR))\n*---------------------------------------------------------------------*\n* TYPE(Character string) string-format tests.\n*---------------------------------------------------------------------*\n FMT  '{C}',('X')\n FMT  '{CL?}',('Substitution Text',17)\n FMT  '{CL8 T}<',('MICHAEL ')\n FMT  'Unrecognized parameter beginning with \"{.30CL? T}\".',           +\n               ('Blah, Blah, Blah',16)\n FMT  'No value supplied for option {CL? T}',('/GOOBER        ',15)\n*---------------------------------------------------------------------*\n* TYPE(Signed Integer) string-format tests.\n*---------------------------------------------------------------------*\n FMT  '{I}',(987654)\n FMT  '{05IL2}',(=H'1')\n FMT  '{02I}/{02I}/{02I}',(9,18,89)\n FMT  '{02I}:{02I}:{02I}',(10,42,54)\n FMT  '{02I}.{03I}',(89,271)\n FMT  '{I RELATIVE}',(431)\n FMT  '{I RELATIVE}',(672)\n FMT  '{I RELATIVE}',(23)\n FMT  '{I RELATIVE}',(874)\n FMT  '{I RELATIVE}',(75)\n FMT  'X\"FFFFFFFF\" = {I}',(=X'FFFFFFFF')\n FMT  'X\"80000000\" = {I}',(=X'80000000')\n FMT  'X\"7FFFFFFF\" = {I}',(=X'7FFFFFFF')\n FMT  'X\"CE91FE20\" = {I}',(=X'CE91FE20')\n FMT  'FL1(255) = {IL1}',(=X'FFFFFFFF')\n FMT  'FL2(65535) = {IL2}',(=X'FFFFFFFF')\n FMT  'FL3(16777215) = {IL3}',(=X'FFFFFFFF')\n*---------------------------------------------------------------------*\n* TYPE(Unsigned Integer) string-format tests.\n*---------------------------------------------------------------------*\n FMT  'F\"987654\" = {U}',(987654)\n FMT  'X\"FFFFFFFF\" 4294967295 = {U}',(=X'FFFFFFFF')\n FMT  'X\"80000000\" 2147483648 = {U}',(=X'80000000')\n FMT  'X\"7FFFFFFF\" 2147483647 = {U}',(=X'7FFFFFFF')\n FMT  'X\"CE91FE20\" 3465674272 = {U}',(=X'CE91FE20')\n FMT  'FL1(255) = {UL1}',(=X'FFFFFFFF')\n FMT  'FL2(65535) = {UL2}',(=X'FFFFFFFF')\n FMT  'FL3(16777215) = {UL3}',(=X'FFFFFFFF')\n*---------------------------------------------------------------------*\n* TYPE(Hex Character) string-format tests.\n*---------------------------------------------------------------------*\n FMT  'F\"987654\" = {XL4}',(987654)\n FMT  'X\"FFFFFFFF\" = {XL4}',(=X'FFFFFFFF')\n FMT  'X\"80000000\" = {XL4}',(=X'80000000')\n FMT  'X\"7FFFFFFF\" = {XL4}',(=X'7FFFFFFF')\n FMT  'X\"CE91FE20\" = {XL4}',(=X'CE91FE20')\n FMT  'FL1(255) = {XL1}',(=X'FFFFFFFF')\n FMT  'FL2(65535) = {XL2}',(=X'FFFFFFFF')\n FMT  'FL3(16777215) = {XL3}',(=X'FFFFFFFF')\n*---------------------------------------------------------------------*\n* MULTIPLES and CSV tests.\n*---------------------------------------------------------------------*\n FMT  'VOLLIST = {CL6M5 CSV}.',('A00001A00002A00003A00004A00005')\n FMT  'VOLLIST = {CL6M5 CSV T}.',('SHORT VOL   SERS  TRIM  CSV   ')\n*---------------------------------------------------------------------*\n* QST - Quoted string output.\n*---------------------------------------------------------------------*\n FMT  'QSTRING = {CL12 QST T}.',('What''s up?  ')\n  ENDBLK BLOCK=SRVXRSTR\n*---------------------------------------------------------------------*\n*\n*  Subroutine: FORMAT(Control,Length,ArgumentList,ArgumentCount)\n*\n*---------------------------------------------------------------------*\n  BLOCK TYPE=SUBROUTINE,NAME=FORMAT\n   LM                  R3,R6,0(R1)\n   ES_DISPLAY_MESSAGE  ID=ES,MESSAGE=' '\n   ES_DISPLAY_MESSAGE  ID=ES,MESSAGE=((R3),(R4))\n   ST_FORMAT           ID=ST,CONTROL=((R3),(R4)),SOURCELIST=((R5),(R6))\n   IF                  (TREG,R15,NZ)\n     ES_DISPLAY_DEBUG_INFO  ID=ES\n   ENDIF\n   ES_DISPLAY_MESSAGE  ID=ES,MESSAGE=(&PWA.STRING,&PWA.STRING_LEN)\n  ENDBLK BLOCK=FORMAT\n*---------------------------------------------------------------------*\n*\n*  Errexit\n*\n*---------------------------------------------------------------------*\n  BLOCK TYPE=ERREXIT\n    ES_DISPLAY_DEBUG_INFO ID=ES\n  ENDBLK\n                   EJECT\n                   PSD\n                   LTORG\n                   ENDPSD\n                   PWA\n&PWA.R14           DS    F\n&PWA.ARGCOUNT      DS    F           Number of arguments in ARGLIST.\n&PWA.ARGLIST       DS    CL(20*4)    Room for 20 arguments.\n&PWA.INTEGER       DS    F\n&PWA.STRING        DS    CL80\n&PWA.STRING_LEN    DS    F\n&PWA.GREGORIAN     DS    CL8\n&PWA.JULIAN        DS    CL8\n&PWA.TIME          DS    CL11\n                   ENDPWA\n                   END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SRVSY": {"ttr": 36101, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x02\\x00\\x00X\\x01\\x11)\\x9f\\x01\\x11)\\x9f\\t'\\x04x\\x04x\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@\"", "ispf": {"version": "02.00", "flags": 0, "createdate": "2011-10-26T00:00:00", "modifydate": "2011-10-26T09:27:58", "lines": 1144, "newlines": 1144, "modlines": 0, "user": "CLEMSON"}, "text": "*---------------------------------------------------------------------*\n*  Copyright 2011 by Clemson University Research Foundation           *\n*                                                                     *\n*  Licensed under the Apache License, Version 2.0 (the \"License\");    *\n*  you may not use this file except in compliance with the License.   *\n*  You may obtain a copy of the License in this library as member     *\n*  $LICENSE, or from                                                  *\n*                                                                     *\n*      http://www.apache.org/licenses/LICENSE-2.0                     *\n*                                                                     *\n*  Unless required by applicable law or agreed to in writing,         *\n*  software distributed under the License is distributed on an \"AS    *\n*  IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either    *\n*  express or implied.  See the License for the specific language     *\n*  governing permissions and limitations under the License.           *\n*---------------------------------------------------------------------*\nSRVSY     TITLE 'Symbol Manager'\n         SRVMOD NAME=SRVSY,DATES='1987'\n         gblc  &srv_modname\n*---------------------------------------------------------------------*\n*\n*  Copyright (C) Clemson University Research Foundation 1987.\n*\n*  Program     SRVSY, Symbol Manager\n*\n*  Abstract    This processor is designed to manage symbols for an\n*              application.  It does the housekeeping of storing the\n*              symbols away and looking them up later, as well as\n*              other related functions.\n*\n*              A symbol has two distinct parts contributing to its\n*              definition:\n*\n*              Name       : The actual text string that the symbol\n*                           represents.\n*              Attributes : An an application-defined area containing\n*                           information about the symbol.\n*  Parameters:\n*\n*    The TableID and FunctionCode parameters are required for each call\n*    to the symbol manager.  In addition to these two parameters, each\n*    function has its own parameter list containing both required and\n*    optional parameters.\n*\n*    A call to the symbol-manager always looks like the following:\n*\n*    CALLX SRVSY,(TableId,<function-code>,<other-parameters>)\n*\n*    Function specific parameter lists:\n*\n*    (TableId,&START,ESV,AttrSize,Caps,HashSize,MemIncr)\n*\n*      Create a new symbol table and assign to it a unique identifier\n*      which is returned in TableID.\n*\n*    (TableId,&TERMINATE)\n*\n*      Delete the identified symbol table and set TableID to zeros.\n*\n*    (TableID,&SY_TRACE,OnOff)\n*\n*      Turn tracing on/off.\n*\n*    (TableId,&SY_OPEN_BLOCK,Block#,NestLevel)\n*    (TableId,&SY_ENTER_BLOCK,Block#,NestLevel)\n*    (TableId,&SY_EXIT_BLOCK,Block#,NestLevel)\n*\n*      o Create and activate a new block, returning its unique block\n*        number and its nesting level.\n*      o Activate an existing block, returning its nesting level.\n*        The block to be opened must be a child of the currently\n*        active block.\n*      o Inactivate the current block, returning to its parent as the\n*        current active block.  The block# and level of the parent\n*        are returned.  The block and all of its symbols are retained\n*        and it may be re-activated.\n*\n*    (TableID,&SY_INSTALL     ,Name,Length,Handle,Attr,NamePtr)\n*    (TableID,&SY_LOCATE      ,Name,Length,Handle,Attr,NamePtr)\n*    (TableID,&SY_LOCATE_NEXT ,Name,Length,Handle,Attr,NamePtr)\n*    (TableID,&SY_UPDATE      ,Name,Length,Handle,Attr,NamePtr)\n*    (TableID,&SY_DELETE      ,Name,Length,Handle)\n*\n*      A symbol may be identified to the symbol-manager either by\n*      providing its Name and Length, or by providing its Handle.\n*      If the Name/Length are provided, the Handle will be passed\n*      back to the caller.  If the Handle is provided, NamePtr and\n*      Length will be passed back to the caller.\n*\n*      o Install a new symbol in the table, giving it an initial\n*        attribute.  If the symbol is already in the table, return\n*        the existing attribute for it and indicate via return-code\n*        that it was already there.\n*      o Locate a symbol in the symbol table by name or handle, and\n*        return its attribute.\n*      o Remove the specified symbol from the symbol table.\n*      o Replace the identified symbol's attribute with the one\n*        provided.\n*\n*    The meaning of each parameter is explained below:\n*\n*    TableID\n*      A fullword used to uniquely identify the symbol table being\n*      managed.  It is initialized during the startup function.\n*\n*    FunctionCode\n*      A fullword integer that specifies the function to be performed.\n*      Symbolic identifiers are provided for each function and may be\n*      accessed by placing a COPY statement for SRVSYMAC in the\n*      assembler program.  These symbols should be used in place of\n*      actual integer values.\n*\n*    HashSize\n*      A fullword signed integer specifying the number of slots to\n*      reserve in the internal hash table.\n*\n*    Caps\n*      An optional parameter containing the string 'CAPS' or 'ASIS' to\n*      indicate that symbols should (not) be captialized when installed\n*      in the symbol table.  If CAPS is specified, symbol-table lookups\n*      will be case-insensitive.  The Name parameter (text passed in\n*      from the user's storage) is never modified.  Values 'ON' and\n*      'OFF' are also accepted as synonyms for 'CAPS' and 'ASIS'.\n*\n*    MemIncr\n*      A fullword integer specifying the increment, in bytes, that the\n*      symbol manager should use when obtaining storage.  This number\n*      can be used for tuning the symbol manager when a very small or\n*      very large amount of symbol storage is expected to be needed.\n*\n*    Name\n*      A text string representing the name being placed in the table or\n*      being searched for.  On installation, the name is copied to\n*      storage owned by the symbol-manager.  The caller's copy of the\n*      string is never modified.\n*\n*    Length\n*      The length of the symbol being operated upon.  This parameter\n*      is updated if the symbol was looked up using its Handle.\n*\n*    Attr\n*      A caller-supplied value whose length is specified during\n*      startup.\n*\n*    Handle\n*      A fullword providing an alternate method of identifying a\n*      symbol.  The symbol-manager assigns a unique value to each\n*      symbol installed in the table.  Because they are fixed in\n*      length, Handles provide an easy way for applications to\n*      pass symbols around.\n*\n*    NamePtr\n*      If a symbol is located using its Handle, NamePtr will be set to\n*      point to the text of the symbol's name.  The text pointed to\n*      will be the copy stored within the symbol-table and thus may\n*      be capitalized.\n*\n*  Return codes:\n*\n*  Program     reentrant, problem key and state, standard linkage,\n*  Attributes  non-authorized, amode(any), rmode(any)\n*\n*  Change\n*  History   2011/10/20 JCB - Patch rollup for CBT tape distribution\n*\n*---------------------------------------------------------------------\n EJECT\n COPY  SMSYMS                    | Structured Macros symbols.\n COPY  SRVESMAC                  | Environment Support symbols.\n COPY  SRVMMMAC                  | Memory Manager symbols.\n COPY  SRVSYMAC                  | Symbol Manger symbols.\n COPY  SRVSTMAC                  | String Handler symbols.\n BLOCK NAME=&srv_modname,TYPE=PROGRAM,AMODE=31,RMODE=ANY,              +\n               PARMMAP=(PARMLIST,PARMLIST_L),                          +\n               OPTIONS=(*SRVPRC,LONG,                                  +\n               (PARMS,COPY,VL,                                         +\n               (COPYERROR,,&SY_INVALID_NUMBER_OF_PARMS),               +\n               (COUNT,PWA_#PARMS),                                     +\n               (USING,R9))),                                           +\n               SUBOPTS=(*SWA,LOADBASE)\n*\n   ES_ID   ID=ES,SPEPA=&PWA.ES_SPEPA,SPTOKEN=&PWA.ES_SPTOKEN,          +\n               ESVA=PWAAESV\n   MM_ID   ID=MM,SPEPNAME=&MEMORY_MANAGER\n   ST_ID   ID=ST,SPEPNAME=&STRING_HANDLER,SIZELENGTH=4\n*---------------------------------------------------------------------*\n*  If the function code is something other than start, make sure that\n*  the PWA contains the eye-catcher string and the correct value for\n*  tableid. If not, then the tableid passed in is garbage.\n*---------------------------------------------------------------------*\n   L  R7,PRM_FUNCTIONCODE          | Load the function code into\n   L  R7,0(,R7)                    | a register for testing.\n   IF (C,R7,NE,=F'&START')         | If not startup function then\n     IF ((CLC,&PWA.VISUAL,NE,EYECATCHER),OR,(C,R13,NE,&PWA.TABLEID))\n       ERREXIT CODE=&SY_INVALID_SYMBOL_TABLE\n     ELSEIF (NOT,((C,R9,EQ,=F'&TERMINATE'),OR,(TBIT,&PWA.F_USEABLE)))\n       ERREXIT CODE=&SY_SYMBOL_TABLE_NOT_USEABLE\n     ENDIF                            |   Endif.\n   ENDIF                              | Endif.\n   EJECT\n*---------------------------------------------------------------------*\n*  If the FunctionCode is one of Install, Locate, Delete or Update\n*  then perform the operations common to all of them.\n*---------------------------------------------------------------------*\n   CASEBLK REG=R7,WREG=R1              | Case on FunctionCode.\n     CASE &SY_INSTALL,&SY_LOCATE,&SY_DELETE,&SY_UPDATE\n       ERREXIT (CLC,&PWA.OPEN_BLOCKS,EQ,=F'0'),CODE=&SY_NO_BLOCKS_OPEN\n*                                      |\n       L   R2,PRM_SY_NAME              |    R2 -> symbol's name.\n       LA  R2,0(R2)                    |    Clear high-order bit.\n       L   R5,PRM_SY_LENGTH            |    R5 -> symbol's length.\n       L   R5,0(,R5)                   |    R5 := symbol's length.\n       IF  ((TREG,R2,NZ),AND,(TREG,R5,NZ))  If a symbol's name given.\n         SLR R4,R4                     |      Set R4 := Mod(length,4).\n         D   R4,=F'4'                  |          R5 := Length / 4.\n         XR  R15,R15                   |      Clear the accumulator.\n         IF  (TREG,R5,P)               |      If more than 4 chars.\n           LOOP BCT                    |        Loop 4-at-a-time.\n             MVC  &PWA.WORK1,0(R2)     |          Copy 4 chars.\n             TR   &PWA.WORK1,FOLD      |          Fold to capitals.\n             X    R15,&PWA.WORK1       |          XOR with accumulator.\n             LA   R2,4(,R2)            |          Advance to next 4\n           ENDLOOP BCT,R5              |        EndLoop.\n         ENDIF                         |      EndIf.\n         IF (TREG,R4,P)                |      If any characters left.\n           MVC  &PWA.WORK1,=F'0'       |        Clear for XOR instr.\n           BCTR R4,0                   |        Subtract 1 for EX.\n           EXI  R4,(MVC,&PWA.WORK1(0),0(R2))    Copy char(s).\n           TR   &PWA.WORK1,FOLD        |        Fold to capitals.\n           X    R15,&PWA.WORK1         |        XOR with accumulator.\n         ENDIF                         |      EndIf.\n         XR   R14,R14                  |      Clear out upper word.\n         D    R14,&PWA.HASHSIZE        |      R14 := Mod(R15,Hash).\n         LPR  R15,R14                  |      Set R15 = ABS(Remainder).\n         MH   R15,=AL2(BLOCK_HASH_L)   |      Adjust R15 to offset.\n         ST   R15,&PWA.HASHVALUE       |      Save in PWA.\n       ENDIF                           |\n     CASE OTHER                        | -- Ignore other functioncodes.\n   ENDCASE                             | EndCase.\n   EJECT\n*---------------------------------------------------------------------*\n*  Invoke the routines needed to accomplish the specified function.\n*---------------------------------------------------------------------*\n   CASEBLK REG=R7,WREG=R1              | Case on FunctionCode.\n     CASE &START                       | SY_START:\n       CALLSUB START                   |   Create a new symbol table.\n     CASE &TERMINATE                   | SY_TERMINATE:\n       CALLSUB TERMINATE               |   Delete a symbol table.\n     CASE &SY_TRACE                    | SY_TRACE:\n       CALLSUB SET_TRACE,(*PRM_T_ONOFF)    Set TRACE to ON or OFF.\n     CASE &SY_OPEN_BLOCK               | SY_OPEN_BLOCK:\n       CALLSUB OPEN_BLOCK              |   Create a new scope.\n     CASE &SY_ENTER_BLOCK              | SY_ENTER_BLOCK:\n       CALLSUB ENTER_BLOCK             |   Enter an existing block.\n     CASE &SY_EXIT_BLOCK               | SY_EXIT_BLOCK:\n       CALLSUB EXIT_BLOCK              |   Exit the current block.\n     CASE &SY_INSTALL                  | SY_INSTALL:\n       CALLSUB INSTALL_SYMBOL          |   Install a new symbol.\n     CASE &SY_LOCATE                   | SY_LOCATE:\n       CALLSUB LOCATE_SYMBOL           |   Locate an existing symbol.\n     CASE &SY_DELETE                   | SY_DELETE:\n       CALLSUB DELETE_SYMBOL           |   Delete a symbol.\n     CASE &SY_UPDATE                   | SY_UPDATE:\n       CALLSUB UPDATE_SYMBOL           |   Update a symbol's attribute.\n     CASE OTHER                        | <invalid function code>.\n       ERREXIT CODE=&SY_INVALID_FUNCTION\n   ENDCASE                             |\n ENDBLK BLOCK=&srv_modname,RC=0\n EJECT\n***********************************************************************\n*                                                                     *\n*  Subroutine: START                                                  *\n*  Abstract:   Process the optional startup parameters, establish a   *\n*              memory heap, and allocate the root symbol block.       *\n*                                                                     *\n***********************************************************************\n BLOCK TYPE=SUBROUTINE,NAME=START\n*---------------------------------------------------------------------*\n*  All fields in the PWA have already been initialized to zeros by\n*  the block macro.  Initialize those fields that must be non-zero\n*---------------------------------------------------------------------*\n   L     R1,PWAAESV                | R1 -> Environment Support Vector.\n   USING ESV,R1                    | Establish addressability.\n   MVC   &PWA.ES_SPEPA,ESVESEPA    | Copy Environment Support's EPA.\n   MVC   &PWA.ES_SPTOKEN,ESVESTKN  | Copy Environment Support's EPA.\n   DROP  R1                        | Drop addressability.\n*                                  |\n   MVC  &PWA.VISUAL,EYECATCHER     | Both the eyecatcher and the\n   ST   R13,&PWA.TABLEID           | tableid are for validity checks.\n   SBIT &PWA.F_USEABLE             | Reset whenever table is corrupt.\n   RBIT &PWA.F_TRACE               | Tracing is not active.\n   MVC  &PWA.ATTRSIZE,=F'0'        | Default attribute size.\n   MVI  &PWA.CAPS,C'N'             | Default CAPS mode = ASIS.\n   MVC  &PWA.HASHSIZE,=F'101'      | Default # hash slots.\n   MVC  &PWA.MEMINCR,=F'4096'      | Default memory increment value.\n*---------------------------------------------------------------------*\n*  Evaluate the optional parameters of the START function.\n*---------------------------------------------------------------------*\n   LM R2,R6,PRM_S_ATTRSIZE           | R2:R6 -> optional parameters:\n*                                    |\n   IF (TREG,R2,NZ)                   | If ATTRSIZE parameter present.\n     MVC &PWA.ATTRSIZE,0(R2)         |   Copy it to the PWA.\n   ENDIF                             | EndIf.\n*                                    |\n   IF (TREG,R3,NZ)                   | If CAPS parameter present.\n     CALLSUB SET_CAPS,((R3))         |   Set current CAPS mode.\n   ENDIF                             | EndIf.\n*                                    |\n   IF (TREG,R4,NZ)                   | If HASHSIZE parameter present.\n     L       R4,0(,R4)               |   R4 := HashSize.\n     ERREXIT (TREG,R4,NP),CODE=&SY_INVALID_HASHSIZE\n     ST      R4,&PWA.HASHSIZE        |   Save HashSize value.\n   ENDIF                             | EndIf.\n*                                    |\n   IF (TREG,R5,NZ)                   | If MEMINCR parameter present.\n     L       R5,0(,R5)               |   R5 := MemIncr.\n     ERREXIT (TREG,R5,NP),CODE=&SY_INVALID_INCREMENT\n     ST      R5,&PWA.MEMINCR         |   Save MemIncr value.\n   ENDIF                             | EndIf.\n*                                    |\n   IF (TREG,R6,NZ)                   | If TRACE parameter present.\n     CALLSUB SET_TRACE,(0(R6))       |   Set tracing ON | OFF.\n   ENDIF                             | EndIf.\n   EJECT\n*---------------------------------------------------------------------*\n*  Load the memory manager and begin a new heap.\n*---------------------------------------------------------------------*\n   ES_LOAD_MODULE ID=ES,SPID=MM      | Load the Memory Manager.\n   ERREXIT        (TREG,R15,NZ),CODE=&SY_MEMORY_PROBLEM\n   MM_START       ID=MM,INCREMENT=&PWA.MEMINCR\n   ERREXIT        (TREG,R15,NZ),CODE=&SY_MEMORY_PROBLEM\n*---------------------------------------------------------------------*\n*  Create the root symbol-table block.  The block's entire contents,\n*  and thus its block number and nesting level, will equal zeros.\n*---------------------------------------------------------------------*\n   MVC     &PWA.HIGH_BLOCK#,=F'0'   | Cause 1st block# to equal 0.\n   MVC     &PWA.NEST_LEVEL,=F'0'    | Cause 1st block's nest level = 0.\n   L       R3,&PWA.HASHSIZE         | R3 := # hash slots needed.\n   MH      R3,=AL2(BLOCK_HASH_L)    | R3 := Size of hash-table.\n   LA      R3,BLOCK_L(,R3)          | R3 := Size of a block node.\n   ST      R3,&PWA.BLOCK_SIZE       | Save total block-node size.\n   MM_OBTAIN_STORAGE ID=MM,         | Obtain storage for a block       +\n               SIZE=&PWA.BLOCK_SIZE,    using calculated size.         +\n               ADDRESS=&PWA.ROOT_BLOCK\n   MVC     &PWA.OPEN_BLOCKS,&PWA.ROOT_BLOCK\n   ERREXIT (C,R15,EQ,=A(&MM_STORAGE_NOT_AVAILABLE)),                   +\n               CODE=&SY_STORAGE_NOT_AVAILABLE\n   ERREXIT (TREG,R15,NZ),CODE=&SY_MEMORY_PROBLEM\n*---------------------------------------------------------------------*\n*  Issue a trace message showing initialization values.\n*---------------------------------------------------------------------*\n   IF (CLI,&PWA.CAPS,EQ,C'Y')\n     LA  R2,=C'CAPS'\n   ELSE\n     LA  R2,=C'ASIS'\n   ENDIF\n   CALLSUB TRACE,(TM_START,&PWA.ATTRSIZE,0(R2),&PWA.HASHSIZE,          +\n               &PWA.MEMINCR)\n ENDBLK BLOCK=START\n EJECT\n***********************************************************************\n*                                                                     *\n*  Subroutine: TERMINATE                                              *\n*  Abstract:  Terminate the memory manager to free all storage, wipe  *\n*             out the contents of the PWA, and indicate that it       *\n*             should be freed.                                        *\n*                                                                     *\n***********************************************************************\n BLOCK TYPE=SUBROUTINE,NAME=TERMINATE\n   CALLSUB      TRACE,(TM_TERMINATE)    | Issue a TRACE message.\n*                                       |\n   IF (CLC,&PWA.MM_SPEPA,NE,=F'0')      | If Memory Manager loaded.\n     IF (CLC,&PWA.MM_SPTOKEN,NE,=F'0')  |   If Memory Manager started.\n       MM_TERMINATE ID=MM               |     Terminate Memory Manager.\n     ENDIF                              |   EndIf.\n     ES_UNLOAD_MODULE ID=ES,SPID=MM     |   Unload Memory Manager.\n   ENDIF                                | EndIf.\n*                                       |\n   IF (CLC,&PWA.ST_SPEPA,NE,=F'0')      | If String Handler loaded.\n     IF (CLC,&PWA.ST_SPTOKEN,NE,=F'0')  |   If String Handler started.\n       ST_TERMINATE ID=ST               |     Terminate String Handler.\n     ENDIF                              |   EndIf.\n     ES_UNLOAD_MODULE ID=ES,SPID=ST     |   Unload String Handler.\n   ENDIF                                | EndIf.\n*                                       |\n   FILL    &PWA.AREA,X'00',LENGTH=(&PWA.AREA_L,MEDIUM)\n   SMCTRL  FREEPWA=YES                  | Free the PWA on return.\n ENDBLK BLOCK=TERMINATE\n EJECT\n***********************************************************************\n*                                                                     *\n*  Subroutine: SET_CAPS                                               *\n*  Abstract:   Set the current CAPS mode according to the provided    *\n*              parameter.                                             *\n*                                                                     *\n***********************************************************************\n BLOCK TYPE=SUBROUTINE,NAME=SET_CAPS\n   L   R1,0(,R1)                          | Point to only parameter.\n   MVC &PWA.WORK1,0(R1)                   | Copy CAPS parameter to PWA.\n   OC  &PWA.WORK1,=CL4' '                 | Convert to capitals.\n   IF  (CLC,&PWA.WORK1(2),EQ,=C'ON')      | If equal to 'ON'.\n     MVI  &PWA.CAPS,C'Y'                  |   Set mode to CAPS on.\n   ELSEIF (CLC,&PWA.WORK1(2),EQ,=C'NO')   | If equal to 'NO'.\n     MVI  &PWA.CAPS,C'N'                  |   Set mode to CAPS off.\n   ELSEIF (CLC,&PWA.WORK1(3),EQ,=C'YES')  | ElseIf equal to 'YES'.\n     MVI  &PWA.CAPS,C'Y'                  |   Set mode to CAPS on.\n   ELSEIF (CLC,&PWA.WORK1(3),EQ,=C'OFF')  | ElseIf equal to 'OFF'.\n     MVI  &PWA.CAPS,C'N'                  |   Set mode to CAPS off.\n   ELSEIF (CLC,&PWA.WORK1(4),EQ,=C'CAPS') | ElseIf equal to 'CAPS'.\n     MVI  &PWA.CAPS,C'Y'                  |   Set mode to CAPS on.\n   ELSEIF (CLC,&PWA.WORK1(4),EQ,=C'ASIS') | ElseIf equal to 'ASIS'.\n     MVI  &PWA.CAPS,C'N'                  |   Set mode to CAPS off.\n   ELSE                                   | Else.\n     ERREXIT CODE=&SY_INVALID_CAPS_PARAMETER  Return with error-code.\n   ENDIF                                  | EndIf.\n ENDBLK BLOCK=SET_CAPS\n EJECT\n***********************************************************************\n*                                                                     *\n*  Subroutine: SET_TRACE                                              *\n*  Abstract:   Turn on/off the trace function.                        *\n*                                                                     *\n***********************************************************************\n BLOCK TYPE=SUBROUTINE,NAME=SET_TRACE\n*---------------------------------------------------------------------*\n*  Set the trace flag.\n*---------------------------------------------------------------------*\n   L     R1,0(R1)                     | R1 -> Trace parameter.\n   IF    (TREG,R1,Z),THEN             | If no Trace parameter.\n     SBIT  &PWA.F_TRACE               |   Turn tracing on.\n   ELSE                               | Else.\n     MVC &PWA.WORK1(3),0(R1)          |   Copy parameter to PWA.\n     OC  &PWA.WORK1,=CL4' '           |   Convert to capitals.\n     IF  (CLC,&PWA.WORK1(2),EQ,=C'ON') |  If trace parameter = 'ON'.\n       SBIT  &PWA.F_TRACE             |     Turn tracing on.\n     ELSEIF (CLC,&PWA.WORK1(3),EQ,=C'OFF') ElseIf it = 'OFF'.\n       RBIT  &PWA.F_TRACE             |   Turn tracing off.\n     ENDIF                            |   EndIf.\n   ENDIF                              | EndIf.\n*---------------------------------------------------------------------*\n*  If tracing is active, insure that the string handler is accessable.\n*  Otherwise, insure that it is not tying up space.\n*---------------------------------------------------------------------*\n   L  R3,&PWA.ST_SPEPA                | R3 -> Str Handler, if loaded.\n   IF (TBIT,&PWA.F_TRACE),THEN        | If tracing is active then.\n     IF (TREG,R3,Z),THEN              |   If string Handler not loaded.\n       ES_LOAD_MODULE ID=ES,SPID=ST   |     Load String Handler.\n       ST_START       ID=ST           |     Start String Handler.\n     ENDIF                            |   EndIf.\n     CALLSUB TRACE,(TM_TRACE)         |   Issue TRACE on message.\n   ELSEIF (TREG,R3,NZ)                | ElseIf String Handler loaded.\n     ST_TERMINATE     ID=ST           |   Terminate String Handler.\n     ES_UNLOAD_MODULE ID=ES,SPID=ST   |   Unload String Handler.\n   ENDIF                              | EndIf.\n ENDBLK BLOCK=SET_TRACE\n EJECT\n***********************************************************************\n*                                                                     *\n*  Subroutine: OPEN_BLOCK                                             *\n*  Abstract  : Allocate a new block, assign it a block number and     *\n*              level, and return its address.                         *\n*                                                                     *\n***********************************************************************\n BLOCK TYPE=SUBROUTINE,NAME=OPEN_BLOCK\n*--------------------------------------------------------------------*\n*  Attempt to allocate storage for the new block.\n*--------------------------------------------------------------------*\n   MM_OBTAIN_STORAGE ID=MM,SIZE=&PWA.BLOCK_SIZE,ADDRESS=&PWA.WORK1\n   ERREXIT (C,R15,EQ,=A(&MM_STORAGE_NOT_AVAILABLE)),                   +\n               CODE=&SY_STORAGE_NOT_AVAILABLE\n   ERREXIT (TREG,R15,NZ),CODE=&SY_MEMORY_PROBLEM\n   L       R3,&PWA.WORK1           | R3 -> new block.\n*--------------------------------------------------------------------*\n*  The new block is the child of the currently active block.  Link\n*  it to its parent and siblings, and make it the currently active\n*  block.\n*--------------------------------------------------------------------*\n   L     R1,&PWA.OPEN_BLOCKS        | R1 -> front of active-block list.\n   ST    R1,BLOCK_PARENT-BLOCK(,R3) | Point to the new block's parent.\n   USING BLOCK,R1                   | Get addressability on parent.\n   IF    (CLC,BLOCK_CHILD,EQ,=F'0') | If this is the first child, then.\n     ST  R3,BLOCK_CHILD             |   Set as first in child-list.\n   ELSE                             | Else.\n     L   R2,BLOCK_CHILDL            |   Point to last child in list.\n     ST  R3,BLOCK_SIBLING-BLOCK(,R2)    Make sibling of last child.\n   ENDIF                            | EndIf.\n   ST    R3,BLOCK_CHILDL            | New block is the last child.\n   ST    R3,&PWA.OPEN_BLOCKS        | Make the new block active.\n   DROP  R1                         | Change addressability to\n   USING BLOCK,R3                   | that of the new block node.\n*--------------------------------------------------------------------*\n*  Assign the block a number.\n*--------------------------------------------------------------------*\n   L       R1,&PWA.HIGH_BLOCK#     | R1 := Highest block# so far.\n   LA      R1,1(,R1)               | Bump the highest block#.\n   ST      R1,BLOCK_NUMBER         | Assign it to current block.\n   ST      R1,&PWA.HIGH_BLOCK#     | Save for next time.\n*--------------------------------------------------------------------*\n*  Assign the block its nesting level.\n*--------------------------------------------------------------------*\n   L       R1,&PWA.NEST_LEVEL      | R1 := Current nesting level.\n   LA      R1,1(,R1)               | Bump the current nesting level.\n   ST      R1,BLOCK_LEVEL          | Assign it to current block.\n   ST      R1,&PWA.NEST_LEVEL      | Save for next time.\n   CALLSUB TRACE,(TM_BLOCK,'Create',BLOCK_NUMBER,&PWA.NEST_LEVEL)\n*--------------------------------------------------------------------*\n*  Return the opened block's number and the new nesting level.\n*--------------------------------------------------------------------*\n   L       R1,PRM_BL_BLOCK#        | R1 -> Block # parameter.\n   IF      (TREG,R1,NZ)            | If Block# parameter present.\n     MVC   0(4,R1),BLOCK_NUMBER    |   Copy opened block's number.\n   ENDIF                           | EndIf.\n   L       R1,PRM_BL_NESTLEVEL     | R1 -> NestLevel parameter.\n   IF      (TREG,R1,NZ)            | If NestLevel parameter present.\n     MVC   0(4,R1),&PWA.NEST_LEVEL |   Copy uncovered nesting level.\n   ENDIF                           | EndIf.\n   DROP    R3                      | Clean up on addressability.\n ENDBLK BLOCK=OPEN_BLOCK\n EJECT\n***********************************************************************\n*                                                                     *\n*  Subroutine: ENTER_BLOCK                                            *\n*  Abstract  : Open an existing block that is either a child of the   *\n*              currently active block or is the root-block.           *\n*                                                                     *\n***********************************************************************\n BLOCK TYPE=SUBROUTINE,NAME=ENTER_BLOCK\n   L     R3,PRM_BL_BLOCK#           Pick up address of block# desired.\n*--------------------------------------------------------------------*\n*  If there is no block active, activate the root block.  Otherwise\n*  activate a child of the currently active block.\n*--------------------------------------------------------------------*\n   L     R4,&PWA.OPEN_BLOCKS        | Point to 1st active block.\n   USING BLOCK,R4                   | Establish addressability.\n   IF    (TREG,R4,Z)                | If no active blocks, then.\n     L   R4,&PWA.ROOT_BLOCK         |   Point to the root-block.\n     IF  (TREG,R3,NZ)               |   If a block# was provided, then.\n       ERREXIT (CLC,0(R3),NE,BLOCK_NUMBER),CODE=&SY_CANNOT_OPEN_BLOCK\n     ENDIF                          |   EndIf.\n   ELSE                             | Else.\n     L   R4,BLOCK_CHILD             |   Point to 1st child in list.\n     IF  (TREG,R3,NZ)               |   If a block# was provided, then.\n       LOOP WHILE,((TREG,R4,NZ),AND,(CLC,0(R3),NE,BLOCK_NUMBER))\n         L  R4,BLOCK_SIBLING        |      Point to next child in list.\n       ENDLOOP WHILE                |     EndLoop.\n     ENDIF                          |   EndIf.\n     ERREXIT (TREG,R4,Z),CODE=&SY_CANNOT_OPEN_BLOCK\n   ENDIF                            | EndIf.\n   ST  R4,&PWA.OPEN_BLOCKS          | Set current active block.\n   CALLSUB TRACE,(TM_BLOCK,'Open  ',BLOCK_NUMBER,&PWA.NEST_LEVEL)\n*--------------------------------------------------------------------*\n*  Return the newly activated block's number and nest level.\n*--------------------------------------------------------------------*\n   L       R1,PRM_BL_BLOCK#        | R1 -> Block # parameter.\n   IF      (TREG,R1,NZ)            | If Block# parameter present.\n     MVC   0(4,R1),BLOCK_NUMBER    |   Copy opened block's number.\n   ENDIF                           | EndIf.\n   L       R1,PRM_BL_NESTLEVEL     | R1 -> NestLevel parameter.\n   IF      (TREG,R1,NZ)            | If NestLevel parameter present.\n     MVC   0(4,R1),&PWA.NEST_LEVEL |   Copy uncovered nesting level.\n   ENDIF                           | EndIf.\n   DROP    R4                      | Clean up on addressability.\n ENDBLK BLOCK=ENTER_BLOCK\n EJECT\n***********************************************************************\n*                                                                     *\n*  Subroutine: EXIT_BLOCK                                             *\n*  Abstract  : Remove the block on top of the active list, but do NOT *\n*              delete it.                                             *\n*                                                                     *\n***********************************************************************\n BLOCK TYPE=SUBROUTINE,NAME=EXIT_BLOCK\n*--------------------------------------------------------------------*\n*  If any blocks are active, remove the one in front of the list.\n*--------------------------------------------------------------------*\n   L       R2,&PWA.OPEN_BLOCKS           | Point to 1st active block.\n   USING   BLOCK,R2                      | Establish addressability.\n   ERREXIT (TREG,R2,Z),CODE=&SY_NO_BLOCKS_OPEN\n   MVC     &PWA.OPEN_BLOCKS,BLOCK_PARENT | Remove from active list.\n*--------------------------------------------------------------------*\n*  Decrement the current nesting level.\n*--------------------------------------------------------------------*\n   L       R1,&PWA.NEST_LEVEL          | Load into a reg for subtract.\n   S       R1,=F'1'                    | Decrement current nest level.\n   ST      R1,&PWA.NEST_LEVEL          | Save adjusted nest level.\n*--------------------------------------------------------------------*\n*  Return the closed block's number and the uncovered nesting level.\n*--------------------------------------------------------------------*\n   L       R1,PRM_BL_BLOCK#            | R1 -> Block # parameter.\n   IF      (TREG,R1,NZ)                | If Block# parameter present.\n     MVC   0(4,R1),BLOCK_NUMBER        |   Copy closed block's number.\n   ENDIF                               | EndIf.\n   L       R1,PRM_BL_NESTLEVEL         | R1 -> NestLevel parameter.\n   IF      (TREG,R1,NZ)                | If Block# parameter present.\n     MVC   0(4,R1),&PWA.NEST_LEVEL     |   Copy new nesting level.\n   ENDIF                               | EndIf.\n   CALLSUB TRACE,(TM_BLOCK,'Close ',BLOCK_NUMBER,&PWA.NEST_LEVEL)\n   DROP    R2                          | Clean up on addressability.\n ENDBLK BLOCK=EXIT_BLOCK\n EJECT\n***********************************************************************\n*                                                                     *\n*  Subroutine: INSTALL_SYMBOL                                         *\n*  Abstract:   Install a new symbol into the symbol table.            *\n*  Parameters:                                                        *\n*                                                                     *\n***********************************************************************\n BLOCK TYPE=SUBROUTINE,NAME=INSTALL_SYMBOL\n   ERREXIT (CLC,PWA_#PARMS,LT,=F'4'),CODE=&SY_INVALID_NUMBER_OF_PARMS\n   ERREXIT (CLC,PWA_#PARMS,GT,=F'7'),CODE=&SY_INVALID_NUMBER_OF_PARMS\n   L       R3,&PWA.OPEN_BLOCKS     | Point to current block.\n   USING   BLOCK,R3                | Establish addressability.\n*--------------------------------------------------------------------*\n*  If the symbol is in the current block, copy attribute and leave.\n*--------------------------------------------------------------------*\n   CALLSUB FIND_SYMBOL,(BLOCK)     | Attempt to find symbol in block.\n   IF (TREG,R15,NZ),THEN           | If the symbol was located.\n     L     R4,0(R15)               |   R4 -> Name node containing it.\n     USING NAME,R4                 |   Establish addressability.\n     L     R6,PRM_SY_ATTR          |   R6 -> Attribute to return.\n     L     R7,&PWA.ATTRSIZE        |   R7 := Attribute's length.\n     IF ((TREG,R6,NZ),AND,(TREG,R7,P)) If okay to copy attribute.\n       LA    R0,NAME_TEXT          |     R0 -> Symbol's Text.\n       A     R0,NAME_SIZE          |     R0 -> Symbol's Attribute.\n       LR    R1,R7                 |     R1 := Source length for MVCL.\n       MVCL  R6,R0                 |     Copy Attribute to return-parm.\n     ENDIF                         |   EndIf.\n     ERREXIT CODE=&SY_SYMBOL_ALREADY_INSTALLED\n   ELSE\n*--------------------------------------------------------------------*\n*    Allocate memory for holding the new symbol's node.\n*--------------------------------------------------------------------*\n     L       R4,PRM_SY_LENGTH  |   R4 -> Symbol's length.\n     L       R4,0(,R4)         |   R4 := Symbol's length.\n     A       R4,&PWA.ATTRSIZE  |   R4 := Symbol's Length + Attr Size.\n     LA      R4,NAME_L(R4)     |   R4 := Total size to allocate.\n     ST      R4,&PWA.WORK1     |   Save length of new NAME.\n     MM_OBTAIN_STORAGE ID=MM,SIZE=&PWA.WORK1,ADDRESS=&PWA.WORK2\n     ERREXIT (C,R15,EQ,=A(&MM_STORAGE_NOT_AVAILABLE)),                 +\n               CODE=&SY_STORAGE_NOT_AVAILABLE\n     ERREXIT (TREG,R15,NZ),CODE=&SY_MEMORY_PROBLEM\n     L       R4,&PWA.WORK2     |   Point to newly allocated stg.\n     USING   NAME,R4           |   Establish addressability.\n*--------------------------------------------------------------------*\n*    Insert the new symbol's node.\n*--------------------------------------------------------------------*\n     ST      R3,NAME_BLOCK     |   Save parent-block pointer of name.\n     L       R5,&PWA.HASHVALUE |   Pick up symbol's hash value.\n     LA      R5,BLOCK_HASH(R5) |   Point to hash-bucket for symbol.\n     L       R1,0(R5)          |   Point to current 1st node.\n     ST      R1,NAME_LINK      |   Copy hash chain head pointer.\n     ST      R4,0(R5)          |   Place new item in front of list.\n*--------------------------------------------------------------------*\n*    Copy the supplied symbol to the new block.\n*--------------------------------------------------------------------*\n     L       R6,PRM_SY_NAME    |   R6 -> Symbol's name.\n     L       R7,PRM_SY_LENGTH  |   R7 -> length of symbol's text.\n     MVC     NAME_SIZE,0(R7)   |   Save in the NAME.\n     LA      R0,NAME_TEXT      |   R0 -> Target for move long.\n     L       R1,NAME_SIZE      |   R1 := Length of symbol's text.\n     L       R7,NAME_SIZE      |   R7 := Length of symbol's text.\n     MVCL    R0,R6             |   Copy the symbol into blk.\n*--------------------------------------------------------------------*\n*    After the MVCL instr, R0 will point to the location following the\n*    last byte of the copied text.  Copy the attribute to this\n*    position, if attributes are non-zero in length.\n*--------------------------------------------------------------------*\n     L  R1,&PWA.ATTRSIZE       |   R1 := MVCL length for attribute.\n     IF (TREG,R1,P)            |   If attribute length positive.\n       L  R6,PRM_SY_ATTR       |     R6 -> Supplied Attribute.\n       IF (TREG,R6,NZ)         |     If an attribute was supplied.\n         LR   R7,R1            |       R7 := MVCL source length.\n         MVCL R0,R6            |       Copy attribute to NAME node.\n       ENDIF                   |     EndIf.\n     ENDIF                     |   EndIf.\n*--------------------------------------------------------------------*\n*    If CAPS mode is on, fold the symbol's text to upper case.\n*--------------------------------------------------------------------*\n     IF (CLI,&PWA.CAPS,EQ,C'Y') |  If current mode = CAPS then.\n       LA   R14,NAME_TEXT      |     R14 -> curent segment of text.\n       L    R15,NAME_SIZE      |     R15 := remaining length.\n       LOOP WHILE,(C,R15,GT,=F'256') Loop over big chunks.\n         TR 0(256,R14),FOLD    |       Fold segment to uppercase.\n         A  R14,=F'256'        |       Advance to next big chunk.\n         S  R15,=F'256'        |       Adjust remaining length.\n       ENDLOOP WHILE           |     EndLoop.\n       IF (TREG,R14,P)         |     If more characters left.\n         BCTR R15,0            |       Subtract 1 for EX instr.\n         EXI  R15,(TR,0(0,R14),FOLD)    Fold last chunk to upper.\n       ENDIF                   |     EndIf.\n     ENDIF                     |   EndIf.\n   ENDIF                       | EndIf\n*--------------------------------------------------------------------*\n*  If the Handle parameter was supplied, set its value.\n*--------------------------------------------------------------------*\n   L   R2,PRM_SY_HANDLE        | R2 -> Handle parameter.\n   IF  (TREG,R2,NZ)            | If not a null parameter.\n     ST  R4,0(R2)              |   Save name-node address.\n   ENDIF                       | EndIf.\n*--------------------------------------------------------------------*\n*  If the NamePtr parameter was supplied, set its value.\n*--------------------------------------------------------------------*\n   L   R2,PRM_SY_NAMEPTR       | Point to return name pointer.\n   IF  (TREG,R2,NZ)            | If NamePtr parm given.\n     LA  R1,NAME_TEXT          |   R1 -> Internal name text storage.\n     ST  R1,0(R2)              |   Save address of symbol's name.\n   ENDIF                       | EndIf.\n*                              |\n   CALLSUB TRACE_SYMBOL,('Install   ',NAME)\n   DROP R3,R4                  | Clean up on addressability.\n ENDBLK BLOCK=INSTALL_SYMBOL\n EJECT\n***********************************************************************\n*                                                                     *\n*  Subroutine: LOCATE_SYMBOL                                          *\n*  Abstract:   Locate an existing symbol in the symbol table.         *\n*  Parameters:                                                        *\n*                                                                     *\n***********************************************************************\n BLOCK TYPE=SUBROUTINE,NAME=LOCATE_SYMBOL\n   ERREXIT (CLC,PWA_#PARMS,LT,=F'4'),CODE=&SY_INVALID_NUMBER_OF_PARMS\n   ERREXIT (CLC,PWA_#PARMS,GT,=F'7'),CODE=&SY_INVALID_NUMBER_OF_PARMS\n*--------------------------------------------------------------------*\n*  Scan the active block list for a block containing the symbol.\n*--------------------------------------------------------------------*\n   L       R3,&PWA.OPEN_BLOCKS     | Point to current block.\n   USING   BLOCK,R3                | Establish addressability.\n   LOOP    WHILE,(TREG,R3,NZ)      | While there are blocks to search.\n     CALLSUB FIND_SYMBOL,(BLOCK)   |   Attempt to find symbol in block.\n     LEAVE   LOOP=*,(TREG,R15,NZ)  |   Leave if symbol was found.\n     L       R3,BLOCK_PARENT       |   Advance to next block.\n   ENDLOOP WHILE                   | EndLoop.\n   ERREXIT (TREG,R15,Z),CODE=&SY_SYMBOL_NOT_FOUND\n*--------------------------------------------------------------------*\n*  If the symbol was found, the return-code from FIND_SYMBOL, R15,\n*  will point to a pointer to the NAME node containing it.\n*--------------------------------------------------------------------*\n   L     R4,0(R15)                   | R4 -> Name node containing it.\n   USING NAME,R4                     | Establish addressability.\n   L     R6,PRM_SY_ATTR              | R6 -> Attribute to return.\n   L     R7,&PWA.ATTRSIZE            | R7 := Attribute's length.\n   IF ((TREG,R6,NZ),AND,(TREG,R7,P)) | If okay to copy attribute.\n     LA    R0,NAME_TEXT              |   R0 -> Symbol's Text.\n     A     R0,NAME_SIZE              |   R0 -> Symbol's Attribute.\n     LR    R1,R7                     |   R1 := Source length for MVCL.\n     MVCL  R6,R0                     |   Copy Attribute to return-parm.\n   ENDIF                             | EndIf.\n   CALLSUB TRACE_SYMBOL,('Locate    ',NAME)\n   DROP  R3,R4                       | Clean up on addressability.\n ENDBLK BLOCK=LOCATE_SYMBOL\n EJECT\n***********************************************************************\n*                                                                     *\n*  Subroutine: DELETE_SYMBOL                                          *\n*  Abstract:   DELETE an existing symbol in the symbol table.         *\n*  Parameters:                                                        *\n*                                                                     *\n***********************************************************************\n BLOCK TYPE=SUBROUTINE,NAME=DELETE_SYMBOL\n   ERREXIT (CLC,PWA_#PARMS,LT,=F'4'),CODE=&SY_INVALID_NUMBER_OF_PARMS\n   ERREXIT (CLC,PWA_#PARMS,GT,=F'5'),CODE=&SY_INVALID_NUMBER_OF_PARMS\n*--------------------------------------------------------------------*\n*  Scan the active block list for a block containing the symbol.\n*--------------------------------------------------------------------*\n   L       R3,&PWA.OPEN_BLOCKS     | Point to current block.\n   USING   BLOCK,R3                | Establish addressability.\n   LOOP    WHILE,(TREG,R3,NZ)      | While there are blocks to search.\n     CALLSUB FIND_SYMBOL,(BLOCK)   |   Attempt to find symbol in block.\n     LEAVE   LOOP=*,(TREG,R15,NZ)  |   Leave if symbol was found.\n     L       R3,BLOCK_PARENT       |   Advance to next block.\n   ENDLOOP WHILE                   | EndLoop.\n   ERREXIT (TREG,R15,Z),CODE=&SY_SYMBOL_NOT_FOUND\n*--------------------------------------------------------------------*\n*  If the symbol was found, the return-code from FIND_SYMBOL, R15,\n*  will point to a pointer to the NAME node containing it.\n*--------------------------------------------------------------------*\n   L       R4,0(R15)               | R4 -> Name node containing it.\n   USING   NAME,R4                 | Establish addressability.\n   MVC     0(4,R15),NAME_LINK      | Un-link the node from the chain.\n   CALLSUB TRACE_SYMBOL,('Delete    ',NAME)\n   MM_RELEASE_STORAGE ID=MM,SIZE=NAME_SIZE,ADDRESS=NAME\n   ERREXIT            (TREG,R15,NZ),CODE=&SY_MEMORY_PROBLEM\n   DROP    R4                      | Clean up on addressability.\n ENDBLK BLOCK=DELETE_SYMBOL\n EJECT\n***********************************************************************\n*                                                                     *\n*  Subroutine: UPDATE_SYMBOL                                          *\n*  Abstract:   Replace an existing symbol's attribute.                *\n*                                                                     *\n***********************************************************************\n BLOCK TYPE=SUBROUTINE,NAME=UPDATE_SYMBOL\n   ERREXIT (CLC,PWA_#PARMS,LT,=F'4'),CODE=&SY_INVALID_NUMBER_OF_PARMS\n   ERREXIT (CLC,PWA_#PARMS,GT,=F'7'),CODE=&SY_INVALID_NUMBER_OF_PARMS\n*--------------------------------------------------------------------*\n*  Scan the active block list for a block containing the symbol.\n*--------------------------------------------------------------------*\n   L       R3,&PWA.OPEN_BLOCKS     | Point to current block.\n   USING   BLOCK,R3                | Establish addressability.\n   LOOP    WHILE,(TREG,R3,NZ)      | While there are blocks to search.\n     CALLSUB FIND_SYMBOL,(BLOCK)   |   Attempt to find symbol in block.\n     LEAVE   LOOP=*,(TREG,R15,NZ)  |   Leave if symbol was found.\n     L       R3,BLOCK_PARENT       |   Advance to next block.\n   ENDLOOP WHILE                   | EndLoop.\n   ERREXIT (TREG,R15,Z),CODE=&SY_SYMBOL_NOT_FOUND\n*--------------------------------------------------------------------*\n*  If the symbol was found, the return-code from FIND_SYMBOL, R15,\n*  will point to a pointer to the NAME node containing it.\n*--------------------------------------------------------------------*\n   L     R4,0(R15)                   | R4 -> Name node containing it.\n   USING NAME,R4                     | Establish addressability.\n   L  R6,PRM_SY_ATTR                 | R6 -> Attribute to copy.\n   L  R7,&PWA.ATTRSIZE               | R7 := Attribute's length.\n   IF ((TREG,R7,P),AND,(TREG,R6,NZ)) | If okay to copy attribute.\n     LA    R0,NAME_TEXT              |   R0 -> Symbol's Text.\n     A     R0,NAME_SIZE              |   R0 -> Symbol's Attribute.\n     LR    R1,R7                     |   R1 := Dest length for MVCL.\n     MVCL  R0,R6                     |   Copy Attribute to return-parm.\n   ENDIF                             | EndIf.\n   CALLSUB TRACE_SYMBOL,('SetAttr  ',NAME)\n   DROP  R3,R4                       | Clean up on addressability.\n ENDBLK BLOCK=UPDATE_SYMBOL\n EJECT\n***********************************************************************\n*                                                                     *\n*  Subroutine: FIND_SYMBOL                                            *\n*  Abstract:   Scan the specified block for the symbol supplied by    *\n*              the application program.  If found, the address of     *\n*              the link pointer to the Name node will be returned in  *\n*              R15.  This will either be the address of the header    *\n*              link in the chain or the link of the previous name's   *\n*              node.                                                  *\n*  Parameters: Block Address.                                         *\n*                                                                     *\n***********************************************************************\n BLOCK TYPE=SUBROUTINE,NAME=FIND_SYMBOL\n   L  R3,0(R1)                         | R3 -> BLOCK node.\n   L  R4,PRM_SY_NAME                   | R4 -> Text of symbol.\n   L  R5,PRM_SY_LENGTH                 | R5 -> Length of symbol.\n*---------------------------------------------------------------------*\n*  If no (symbol,length) was supplied, use the Handle.\n*---------------------------------------------------------------------*\n   IF (TREG,R4,NZ)                     | If (Symbol,Length) supplied.\n     ERREXIT (TREG,R5,Z),CODE=&SY_INVALID_NAME  No length supplied.\n     ICM     R0,B'1111',0(R5)          |        R0 := supplied length.\n     ERREXIT NP,CODE=&SY_INVALID_NAME  |        Non-positive length.\n   ELSE                                | Else, use the handle.\n     L  R3,PRM_SY_HANDLE               |   R3 -> Handle, if any.\n     LA R3,0(R3)                       |   CLEAR HIGH ORDER BIT.\n     ERREXIT (TREG,R3,Z),CODE=&SY_MISSING_NAME\n     ERREXIT (CLC,=F'0',EQ,0(R3)),CODE=&SY_MISSING_NAME\n     L       R4,PRM_SY_NAMEPTR         |   R4 -> Return name pointer.\n     IF      (TREG,R4,NZ)              |   If NamePtr parm given.\n       L     R1,0(R3)                  |     R1 -> Name node.\n       USING NAME,R1                   |     Establish addressability.\n       LA    R0,NAME_TEXT              |     Save address of name in\n       ST    R0,0(R4)                  |     NamePtr.\n       IF    (TREG,R5,NZ)              |     If Length parameter given.\n         MVC 0(4,R5),NAME_SIZE         |       Save length of name.\n       ENDIF                           |     EndIf.\n       DROP  R1                        |     Clean up addressability.\n     ENDIF                             |   EndIf.\n     LEAVE BLOCK=*                     |   Return from subroutine.\n   ENDIF                               | EndIf.\n*---------------------------------------------------------------------*\n*  Scan through the Name nodes of the application symbol's hash-bucket.\n*---------------------------------------------------------------------*\n   LA    R3,BLOCK_HASH-BLOCK(,R3) | Point to the hash table.\n   A     R3,&PWA.HASHVALUE        | R3 -> Hash bucket header link.\n   L     R5,0(R3)                 | R5 -> Current NAME node.\n   USING NAME,R5                  | Establish addressability.\n   LOOP WHILE,(TREG,R5,NZ)        | While more elements, loop.\n     L   R14,PRM_SY_NAME          |   R14 -> Test Symbol Name.\n     L   R15,PRM_SY_LENGTH        |   R15 -> Test Symbol Length.\n     ICM R15,15,0(R15)            |   R15 := Test Symbol Length.\n     LA  R6,NAME_TEXT             |   R6 -> Name Symbol's text.\n     L   R7,NAME_SIZE             |   R7 := Name Symbol's Length.\n     IF  (CR,R15,EQ,R7)           |   If lengths are equal then.\n       IF  (CLI,&PWA.CAPS,EQ,C'N') |    If current mode = ASIS.\n         LEAVE LOOP=*,(CLCL,R6,EQ,R14)    If equal, leave loop now.\n       ELSE                       |     Else must fold to uppercase.\n         LOOP WHILE,(C,R7,GE,=F'256')     While big hunks to compare.\n           MVC   &PWA.SEGMENT,0(R14)        Copy hunk to PWA.\n           TR    &PWA.SEGMENT,FOLD |        Fold to upper-case.\n           LEAVE LOOP=*,(CLC,&PWA.SEGMENT,NE,0(R6)) Stop compare if NE.\n           S     R7,=F'256'       |         Adjust remaining length.\n           A     R14,=F'256'      |         Adjust source-pointer.\n           A     R6,=F'256'       |         Adjust Symbol pointer.\n         ENDLOOP WHILE            |       EndLoop.\n         IF (C,R7,LT,=F'256')     |       If comparison not aborted.\n           LEAVE LOOP=*,(TREG,R7,Z)         Leave if symbols equal.\n           BCTR  R7,0             |         Subtract 1 for EX instr.\n           EXI   R7,(MVC,&PWA.SEGMENT(0),0(R14))\n           EXI   R7,(TR,&PWA.SEGMENT(0),FOLD)\n           EXI   R7,(CLC,&PWA.SEGMENT(0),0(R6))\n           LEAVE LOOP=*,EQ        |         Leave if symbols equal.\n         ENDIF                    |       EndIf.\n       ENDIF                      |     EndIf.\n     ENDIF                        |   EndIf.\n     LA    R3,NAME_LINK           |   Remember pointer to next node.\n     L     R5,NAME_LINK           |   Point to next NAME element.\n   ENDLOOP WHILE                  | EndWhile\n   IF (TREG,R5,Z)                 | If the symbol was not located.\n     LR  R3,R5                    |   Set A(LinkPtr) := 0;\n   ELSE                           | Else.\n     L   R2,PRM_SY_HANDLE         |   Point to handle parameter.\n     IF  (TREG,R2,NZ)             |   If not a null parameter.\n       ST  R5,0(R2)               |     Save name-node address.\n     ENDIF                        |   EndIf.\n     L   R2,PRM_SY_NAMEPTR        |   Point to return name pointer.\n     IF  (TREG,R2,NZ)             |   If NamePtr parm given.\n       LA  R0,NAME_TEXT           |     Save address of symbol's name.\n       ST  R0,0(R2)               |\n     ENDIF                        |   EndIf.\n   ENDIF                          | EndIf.\n   DROP R5                        | Clean up on addressability.\n ENDBLK BLOCK=FIND_SYMBOL,RC=((R3))\n EJECT\n***********************************************************************\n*                                                                     *\n*  Subroutine: TRACE_SYMBOL                                           *\n*  Abstract:   Format and issue a trace message for the given name    *\n*              node.                                                  *\n*  Parameters: (TextStr, NAME)                                        *\n*                                                                     *\n***********************************************************************\n BLOCK TYPE=SUBROUTINE,NAME=TRACE_SYMBOL\n   L       R2,0(R1)                     | R2 -> Function Name.\n   L       R3,4(R1)                     | R3 -> Name node.\n   USING   NAME,R3                      | Establish addressability.\n   L       R4,NAME_BLOCK                | R4 -> Parent block.\n   USING   BLOCK,R4                     | Establish addressability.\n   LA      R5,=C' '                     | Symbol length <= 60.\n   IF      (CLC,NAME_SIZE,GT,=F'60')    | If not true, then.\n     LA    R5,=C'+'                     |   Indicate > 60.\n   ENDIF                                | EndIf.\n   CALLSUB TRACE,(TM_SYMBOL,0(R2),BLOCK_NUMBER,BLOCK_LEVEL,            +\n               NAME_TEXT,NAME_SIZE,0(R5))\n   IF (CLC,&PWA.ATTRSIZE,NE,=F'0')      | If symbols have attributes.\n     LA      R6,NAME_TEXT                 |\n     AL      R6,NAME_SIZE                 | R6 -> Attribute value.\n     LA      R7,=C' '                     | Attribute length <= 30.\n     IF      (CLC,&PWA.ATTRSIZE,GT,=F'30') | If not true, then.\n       LA    R7,=C'+'                     |   Indicate > 30.\n     ENDIF                                | EndIf.\n     CALLSUB TRACE,(TM_ATTR,0(R6),&PWA.ATTRSIZE,0(R7))\n   ENDIF\n ENDBLK BLOCK=TRACE_SYMBOL\n EJECT\n***********************************************************************\n*                                                                     *\n*  Subroutine: TRACE                                                  *\n*  Abstract:   Format and issue a trace message with the provided     *\n*              arguments.                                             *\n*  Parameters: (MessageAddr, formatting arguments)                    *\n*                                                                     *\n***********************************************************************\n BLOCK TYPE=SUBROUTINE,NAME=TRACE\n   LEAVE BLOCK=*,(TBIT,&PWA.F_TRACE,OFF)\n*---------------------------------------------------------------------*\n*  Invoke the String Handler format function to format a message.\n*---------------------------------------------------------------------*\n   LR    R2,R1                      | R2 -> Parameter List.\n   LOOP  WHILE,(TBIT,0(R1),X'80',OFF) While not at last parameter.\n     LA    R1,4(,R1)                |   Advance to next parameter.\n   ENDLOOP WHILE                    | EndLoop.\n   SLR     R1,R2                    | R1 := length of argument list.\n   SRL     R1,2                     | R1 := number of arguments.\n   ST      R1,&W.ARGCOUNT           | Save argument count.\n*                                   |\n   L         R3,0(R2)               | R3 -> Trace message to format.\n   ST_FORMAT ID=ST,STRING=&W.DATA,RESULTLEN=&W.LEN,                    +\n               CONTROL=(4(R3),0(R3)),SOURCELIST=(4(R2),&W.ARGCOUNT)\n*---------------------------------------------------------------------*\n*    Issue the error message formatted above.\n*---------------------------------------------------------------------*\n   ES_DISPLAY_MESSAGE ID=ES,MESSAGE=(&W.DATA,&W.LEN)\n ENDBLK BLOCK=TRACE\n SPACE\n*---------------------------------------------------------------------*\n* Working storage needed for the FORMAT interface.\n*---------------------------------------------------------------------*\n             SWA\n&W.ARGCOUNT  DS  F              | Amount formatted in last call.\n&W.LEN       DS  F              | Length of formatted message.\n&W.DATA      DS  CL255          | Target area for formatted message.\n             ENDSWA\n             EJECT\n***********************************************************************\n*                                                                     *\n*  Exit with a return code equal to the current contents of R14.      *\n*                                                                     *\n***********************************************************************\n BLOCK TYPE=ERREXIT\n*---------------------------------------------------------------------*\n*  Save module/offset, registers, return-code.\n*---------------------------------------------------------------------*\n   STM   R0,R15,GDIREGS          | Save registers at time of error.\n   SM_LAL R0,&srv_modname+4      | Point to module identification.\n   ST    R0,GDIMODID             | Save in general debug area.\n   MVC   GDIRC,0(R14)            | Copy return code.\n   SL    R14,=A(&srv_modname)    | Calculate offset at time of error.\n   STH   R14,GDIOFFST            | Save in debug area.\n   ES_SAVE_DEBUG_INFO ID=ES,GDI=GDI\n*---------------------------------------------------------------------*\n*  Exit with the terminating return code.\n*---------------------------------------------------------------------*\n   L       R2,PRM_FUNCTIONCODE\n   CALLSUB TRACE,(TM_ERROR,0(R2),GDIRC)\n   LH   R15,GDIRC                   | Set return-code on exit.\n ENDBLK\n EJECT\n*---------------------------------------------------------------------\n*\n*  Static Data\n*\n*---------------------------------------------------------------------\n                 PSD\nEYECATCHER       DC   C'SYM '      | Value moved to PWA on initialize.\nMAX_NAME_LENGTH  DC   F'16777215'  | Maximum length of a symbol name.\n                 MACRO\n&LABEL           TRANTAB\n                 LCLA &N\n&LABEL           DS 0XL256        |\n.NEWROW          DC AL1(&N+0,&N+1,&N+2,&N+3,&N+4,&N+5,&N+6,&N+7)\n                 DC AL1(&N+8,&N+9,&N+10,&N+11,&N+12,&N+13,&N+14,&N+15)\n&N               SETA &N+16\n                 AIF  (&N LT 256).NEWROW\n                 MEND\nFOLD             TRANTAB           | Translate tbl for uppercase conv.\n                 ORG  FOLD+C'a'    | Fold lowercase 'a' - 'i'.\n                 DC   C'ABCDEFGHI' |\n                 ORG  FOLD+C'j'    | Fold lowercase 'j' - 'r'.\n                 DC   C'JKLMNOPQR' |\n                 ORG  FOLD+C's'    | Fold lowercase 's' - 'z'.\n                 DC   C'STUVWXYZ'  |\n                 ORG\n                 MACRO\n&LABEL           MSG  &TEXT\n&LABEL           DC   A(L'MSG&SYSNDX)\nMSG&SYSNDX       DC   C&TEXT\n                 MEND\nTM_START  MSG 'SRVSY: Start : Attrsize={I} Mode={CL4} HashSize={I}, Mem+\n               Incr={I}.'\nTM_TERMINATE MSG 'SRVSY: Terminate.'\nTM_SYMBOL MSG 'SRVSY: {CL10 T R} :{03I}/{03I}: \"{.60CL? T}\"{C T}.'\nTM_ATTR   MSG '       Attribute {.60XL? T}{C T}.'\nTM_TRACE  MSG 'SRVSY: Trace : ON.'\nTM_BLOCK  MSG 'SRVSY: {CL6 T}Block : BlockNumber={I} New NestLevel={I}.+\n               '\nTM_ERROR  MSG 'SRVSY: Ending from function {I} with error code {IL2}.'\n                 LTORG\n                 ENDPSD\n                 EJECT\n*---------------------------------------------------------------------*\n*\n*  Program Work Area\n*\n*---------------------------------------------------------------------*\n                  PWA\n&PWA.AREA         DS  0F           | Beginning of visible PWA stg.\n&PWA.VISUAL       DS  CL4          | Character string 'SYM '.\n&PWA.TABLEID      DS  A            | Unique table identifier.\nPWA_#PARMS        DS  F            | Number of parameters passed in.\n&PWA.ES_SPEPA     DS  A            | Environment Support's EPA.\n&PWA.ES_SPTOKEN   DS  F            | Environment Support's TOKEN.\n&PWA.F            DS  X            | Housekeeping flags.\n&PWA.F_USEABLE    EQU X'80'        | Symbol table is useable.\n&PWA.F_TRACE      EQU X'40'        | Tracing is active.\n&PWA.CAPS         DS  C            | Caps mode ON/OFF = Y | N.\n&PWA.MEMINCR      DS  F            | Memory heap increment.\n&PWA.ATTRSIZE     DS  F            | Size of a symbol's attribute.\n&PWA.HIGH_BLOCK#  DS  F            | Block# of newest block.\n&PWA.NEST_LEVEL   DS  F            | Nesting level of current block.\n&PWA.BLOCK_SIZE   DS  F            | Total size of a block node.\n&PWA.HASHSIZE     DS  A            | Number of hash slots in a block.\n&PWA.HASHVALUE    DS  F            | Current symbol's Hash value.\n&PWA.ROOT_BLOCK   DS  A            | Root block of symbol-table.\n&PWA.OPEN_BLOCKS  DS  A            | List of open blocks.\n&PWA.WORK1        DS  F            |\n&PWA.WORK2        DS  F            |\n&PWA.SEGMENT      DS  CL256        | Area for folding to CAPS.\n                  ES_GDI DSECT=NO  | Debugging information.\n&PWA.AREA_L       EQU *-&PWA.AREA  | Length of visible PWA stg.\n                  ENDPWA\n                  EJECT\n*---------------------------------------------------------------------\n*\n*  Symbol Table DSECTs.\n*\n*---------------------------------------------------------------------\nBLOCK         DSECT                   | Describes one block's symbols.\nBLOCK_PARENT  DS     A                | Link to parent block.\nBLOCK_SIBLING DS     A                | Link to next sibling block.\nBLOCK_CHILD   DS     A                | Link to first child block.\nBLOCK_CHILDL  DS     A                | Link to last child block.\nBLOCK_NUMBER  DS     A                | Unique block identifier.\nBLOCK_LEVEL   DS     A                | Nesting level of this block.\nBLOCK_HASH    DS     0A               | Hash array for name lists.\nBLOCK_HASH_L  EQU    4                | Size of one hash-slot.\nBLOCK_L       EQU    *-BLOCK          | Length of structure.\n*\nNAME          DSECT                   | Describes one symbol.\nNAME_LINK     DS     A                | Pointer to next NAME.\nNAME_BLOCK    DS     A                | Pointer to owning block.\nNAME_SIZE     DS     F                | Size of name's text string.\nNAME_TEXT     DS     0C               | Actual text of symbol's name.\nNAME_ATTR     DS     0X               | Application supplied attribute.\nNAME_L        EQU    *-NAME           | Length of one name block.\n              EJECT\n*---------------------------------------------------------------------\n*  Environment Support Vector\n*---------------------------------------------------------------------\n              ES_ESV\n              EJECT\n*---------------------------------------------------------------------\n*  Parameter list for the symbol manager\n*---------------------------------------------------------------------\nPARMLIST          DSECT\nPRM_TABLEID       DS  A             | Table identifier === PWA base.\nPRM_FUNCTIONCODE  DS  A             | Function to be performed.\nPRM_SPECIFIC      EQU *             | Function dependent parameters:\n                  ORG PRM_SPECIFIC  | SY_START parameters:\nPRM_S_ESV         DS  A             |   Server Global Area.\nPRM_S_ATTRSIZE    DS  A             |   Size of Attr field of symbols.\nPRM_S_CAPS        DS  A             |   Default Caps mode.\nPRM_S_HASHSIZE    DS  A             |   Number of hash table slots.\nPRM_S_MEMINCR     DS  A             |   Increment value for memory mgr.\nPRM_S_TRACE       DS  A             |   Trace 'ON' or trace 'OFF'.\n                  ORG PRM_SPECIFIC  | SY_TRACE parameters:\nPRM_T_ONOFF       DS  A             |   'ON' or 'OFF' for tracing.\n                  ORG PRM_SPECIFIC  | SY_OPEN_BLOCK and SY_CLOSE_BLOCK:\nPRM_BL_BLOCK#     DS  A             |   Return Block# of new block.\nPRM_BL_NESTLEVEL  DS  A             |   Return nesting of new block.\n                  ORG PRM_SPECIFIC  | SY_INSTALL LOCATE UPDATE DELETE:\nPRM_SY_NAME       DS  A             |   Symbol's name.\nPRM_SY_LENGTH     DS  A             |   Symbol's length.\nPRM_SY_HANDLE     DS  A             |   Symbol's handle.\n*                                   |   Not used by SY_DELETE:\nPRM_SY_ATTR       DS  A             |     Symbol's attribute value.\nPRM_SY_NAMEPTR    DS  A             |     Address of symbol's name.\n                  ORG ,             | Get back to right address.\nPARMLIST_L        EQU *-PARMLIST    | Total size of parmlist.\n                  END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SRVSYMAC": {"ttr": 36612, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x02\\x00\\x00X\\x01\\x11)\\x9f\\x01\\x11)\\x9f\\t'\\x02\\xf2\\x02\\xf2\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@\"", "ispf": {"version": "02.00", "flags": 0, "createdate": "2011-10-26T00:00:00", "modifydate": "2011-10-26T09:27:58", "lines": 754, "newlines": 754, "modlines": 0, "user": "CLEMSON"}, "text": "*---------------------------------------------------------------------*\n*  Copyright 2011 by Clemson University Research Foundation           *\n*                                                                     *\n*  Licensed under the Apache License, Version 2.0 (the \"License\");    *\n*  you may not use this file except in compliance with the License.   *\n*  You may obtain a copy of the License in this library as member     *\n*  $LICENSE, or from                                                  *\n*                                                                     *\n*      http://www.apache.org/licenses/LICENSE-2.0                     *\n*                                                                     *\n*  Unless required by applicable law or agreed to in writing,         *\n*  software distributed under the License is distributed on an \"AS    *\n*  IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either    *\n*  express or implied.  See the License for the specific language     *\n*  governing permissions and limitations under the License.           *\n*---------------------------------------------------------------------*\n TITLE 'SRVSYMAC: Symbol Manager Service Processor Symbols && Macros.'\n*---------------------------------------------------------------------*\n*\n*  Copy File:  SRVSYMAC\n*\n*  Purpose:    Symbol Manager service processor symbols and macros.\n*\n*  Description: See \"Service Processors User's Guide and Reference\".\n*\n*  Change\n*  History   2011/10/20 JCB - Patch rollup for CBT tape distribution\n*\n*---------------------------------------------------------------------*\n*\n***********************************************************************\n***********************************************************************\n**                                                                   **\n**                     Symbol Definitions                            **\n**                                                                   **\n***********************************************************************\n***********************************************************************\n*\n* Global declarations for all string handler symbols.\n*\n GBLC &SYMBOL_MANAGER\n GBLA &SY_START,&SY_TERMINATE,&SY_TRACE,&SY_OPEN_BLOCK\n GBLA &SY_CLOSE_BLOCK,&SY_ENTER_BLOCK,&SY_EXIT_BLOCK,&SY_INSTALL\n GBLA &SY_LOCATE,&SY_LOCATE_NEXT,&SY_DELETE,&SY_UPDATE\n GBLA &SY_GET_NAME,&SY_SYMBOL_NOT_FOUND,&SY_SYMBOL_ALREADY_INSTALLED\n GBLA &SY_MEMORY_PROBLEM,&SY_INVALID_CAPS_PARAMETER\n GBLA &SY_INVALID_FUNCTION,&SY_INVALID_NAME\n GBLA &SY_INVALID_NUMBER_OF_PARMS,&SY_INVALID_SYMBOL_TABLE\n GBLA &SY_NO_BLOCKS_OPEN,&SY_CANNOT_OPEN_BLOCK\n GBLA &SY_STORAGE_NOT_AVAILABLE,&SY_SYMBOL_TABLE_NOT_USEABLE\n GBLA &SY_NO_NEXT_SYMBOL,&SY_INVALID_HASHSIZE,&SY_INVALID_INCREMENT\n*\n* Entry Point name for the symbol manager.\n*\n&SYMBOL_MANAGER                         SETC '''SRVSY   '''\n*\n* Function codes.\n*\n&SY_START                               SETA  1\n&SY_TERMINATE                           SETA  2\n&SY_TRACE                               SETA  3\n&SY_OPEN_BLOCK                          SETA  4\n&SY_CLOSE_BLOCK                         SETA  5\n&SY_ENTER_BLOCK                         SETA  6\n&SY_EXIT_BLOCK                          SETA  7\n&SY_INSTALL                             SETA  8\n&SY_LOCATE                              SETA  9\n&SY_LOCATE_NEXT                         SETA 10\n&SY_DELETE                              SETA 11\n&SY_UPDATE                              SETA 12\n&SY_GET_NAME                            SETA 13\n*\n* Return codes.\n*\n&SY_SYMBOL_NOT_FOUND                    SETA  1\n&SY_SYMBOL_ALREADY_INSTALLED            SETA  2\n&SY_MEMORY_PROBLEM                      SETA  3\n&SY_INVALID_CAPS_PARAMETER              SETA  4\n&SY_INVALID_FUNCTION                    SETA  5\n&SY_INVALID_LENGTH                      SETA  6\n&SY_INVALID_NUMBER_OF_PARMS             SETA  7\n&SY_INVALID_SYMBOL_TABLE                SETA  8\n&SY_NO_BLOCKS_OPEN                      SETA  9   <--- not used now.\n&SY_CANNOT_OPEN_BLOCK                   SETA 10   <--- not used now.\n&SY_STORAGE_NOT_AVAILABLE               SETA 11\n&SY_SYMBOL_TABLE_NOT_USEABLE            SETA 12\n&SY_NO_NEXT_SYMBOL                      SETA 13   <--- not used now.\n&SY_INVALID_HASHSIZE                    SETA 14\n&SY_INVALID_INCREMENT                   SETA 15\n&SY_MISSING_NAME                        SETA 16\n DEFUCOND MACRO=SRV##RC,NAME=SY_SYMBOL_NOT_FOUND\n DEFUCOND MACRO=SRV##RC,NAME=SY_SYMBOL_ALREADY_INSTALLED\n DEFUCOND MACRO=SRV##RC,NAME=SY_MEMORY_PROBLEM\n DEFUCOND MACRO=SRV##RC,NAME=SY_INVALID_CAPS_PARAMETER\n DEFUCOND MACRO=SRV##RC,NAME=SY_INVALID_FUNCTION\n DEFUCOND MACRO=SRV##RC,NAME=SY_INVALID_LENGTH\n DEFUCOND MACRO=SRV##RC,NAME=SY_INVALID_NUMBER_OF_PARMS\n DEFUCOND MACRO=SRV##RC,NAME=SY_INVALID_SYMBOL_TABLE\n DEFUCOND MACRO=SRV##RC,NAME=SY_NO_BLOCKS_OPEN\n DEFUCOND MACRO=SRV##RC,NAME=SY_CANNOT_OPEN_BLOCK\n DEFUCOND MACRO=SRV##RC,NAME=SY_STORAGE_NOT_AVAILABLE\n DEFUCOND MACRO=SRV##RC,NAME=SY_SYMBOL_TABLE_NOT_USEABLE\n DEFUCOND MACRO=SRV##RC,NAME=SY_NO_NEXT_SYMBOL\n DEFUCOND MACRO=SRV##RC,NAME=SY_INVALID_HASHSIZE\n DEFUCOND MACRO=SRV##RC,NAME=SY_INVALID_INCREMENT\n DEFUCOND MACRO=SRV##RC,NAME=SY_MISSING_NAME\n                        EJECT\n***********************************************************************\n***********************************************************************\n**                                                                   **\n**                     Macro Definitions                             **\n**                                                                   **\n***********************************************************************\n***********************************************************************\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   SY_ID                                                      *\n*                                                                     *\n* Purpose: Establish default values for a specific service processor  *\n*          and associate them with the specified ID name. The values  *\n*          are stored in the following created global variables:      *\n*                                                                     *\n* Variable Name                     Description                       *\n* -------------  ---------------------------------------------------- *\n* #$&ID.$#IDMAC  Name of macro that created the ID: SY_ID.            *\n* #$&ID.$#ESID   Service processor's Environment Support ID.          *\n* #$&ID.$#EPN    Tag for Service processor's Entry Point Name.        *\n* #$&ID.$#EPA    Tag for Service processor's Entry Point Address.     *\n* #$&ID.$#TKN    Tag for Service processor's Entry Point Token.       *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         SY_ID &ID=,&ESVA=,&SPEPNAME=,&SPEPA=,&SPTOKEN=,&ESID=\n         LCLC  &L_EPNAME\n         GBLC  &SYMBOL_MANAGER\n.*\n.* If no EPNAME was specified, use the generic Symbol Manager.\n.*\n&L_EPNAME SETC '&SPEPNAME'\n          AIF  ('&L_EPNAME' NE '').PAST_EPN\n&L_EPNAME SETC '&SYMBOL_MANAGER'\n.PAST_EPN ANOP\n.*\n.* Invoke SRV##ID to create globals used by all ID's.\n.*\n         SRV##ID SET,                                                  +\n               ID=&ID.,IDMAC=SY_ID,ESID=&ESID.,SPEPNAME=&L_EPNAME,     +\n               SPEPA=&SPEPA,SPTOKEN=&SPTOKEN.\n         MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   SY_START                                                   *\n* Purpose: Generate code to start a new symbol manager session.       *\n*                                                                     *\n*   Keyword                     Description                           *\n* -----------  ------------------------------------------------------ *\n* ATTRSIZE     =tag containing the (fixed) length of an attribute.    *\n* HASHSIZE     =tag containing the number of hash-table slots.        *\n* MEMINCR      =tag containing the memory increment size.             *\n* CAPS         =ON if symbols to be capitalized in table. Else =OFF.  *\n* TRACE        =ON if symbol-manager calls to produce trace info.     *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         SY_START &ID=,&SPEPA=,&SPTOKEN=,&ESVA=,                       +\n               &ATTRSIZE=,&HASHSIZE=,&MEMINCR=,&CAPS=,&TRACE=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN\n         GBLA  &SY_START                  SETC in open code.\n         LCLC  &S_CAPS,&S_TRACE\n.*\n.* Obtain service processor ID values.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN,ESVA),                    +\n               ID=&ID,IDMAC=SY_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN,       +\n               ESVA=&ESVA.\n         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT\n.*\n.* Validate the CAPS keyword.\n.*\n            AIF   ('&CAPS' EQ ''  ).CAPS_NS\n            AIF   ('&CAPS' EQ 'Y'  ).CAPS_ON\n            AIF   ('&CAPS' EQ 'YES').CAPS_ON\n            AIF   ('&CAPS' EQ 'ON' ).CAPS_ON\n            AIF   ('&CAPS' EQ 'N'  ).CAPS_OF\n            AIF   ('&CAPS' EQ 'NO' ).CAPS_OF\n            AIF   ('&CAPS' EQ 'OFF').CAPS_OF\n            MNOTE 8,'CAPS must be either ON or OFF.'\n            MEXIT\n.CAPS_NS    ANOP\n&S_CAPS     SETC ''\n            AGO .PAST_CAPS\n.CAPS_ON    ANOP\n&S_CAPS     SETC '''ON'''\n            AGO .PAST_CAPS\n.CAPS_OF    ANOP\n&S_CAPS     SETC '''OFF'''\n.PAST_CAPS  ANOP\n.*\n.* Validate the TRACE keyword.\n.*\n            AIF   ('&TRACE' EQ '' ).TRACE_NS\n            AIF   ('&TRACE' EQ 'Y' ).TRACE_ON\n            AIF   ('&TRACE' EQ 'YES').TRACE_ON\n            AIF   ('&TRACE' EQ 'ON' ).TRACE_ON\n            AIF   ('&TRACE' EQ 'N' ).TRACE_OF\n            AIF   ('&TRACE' EQ 'NO' ).TRACE_OF\n            AIF   ('&TRACE' EQ 'OFF').TRACE_OF\n            MNOTE 8,'TRACE must be either ON or OFF.'\n            MEXIT\n.TRACE_NS   ANOP\n&S_TRACE    SETC ''\n            AGO .PAST_TRACE\n.TRACE_ON   ANOP\n&S_TRACE    SETC '''ON'''\n            AGO .PAST_TRACE\n.TRACE_OF   ANOP\n&S_TRACE    SETC '''OFF'''\n.PAST_TRACE ANOP\n.*\n.* Start the Symbol Manager.\n.*\n         MVC   &#_IDTKN,=F'0'            | Insure TOKEN = 0.\n         AIF   ('&S_TRACE'  NE '').CALL5\n         AIF   ('&MEMINCR'  NE '').CALL4\n         AIF   ('&HASHSIZE' NE '').CALL3\n         AIF   ('&S_CAPS'   NE '').CALL2\n         AIF   ('&ATTRSIZE' NE '').CALL1\n.CALL1   CALLX &#_IDEPA,(&#_IDTKN,&SY_START,&#_IDESVA,&ATTRSIZE),VL\n         MEXIT\n.CALL2   CALLX &#_IDEPA,(&#_IDTKN,&SY_START,&#_IDESVA,&ATTRSIZE,       +\n               &S_CAPS),VL\n         MEXIT\n.CALL3   CALLX &#_IDEPA,(&#_IDTKN,&SY_START,&#_IDESVA,&ATTRSIZE,       +\n               &S_CAPS,&HASHSIZE),VL\n         MEXIT\n.CALL4   CALLX &#_IDEPA,(&#_IDTKN,&SY_START,&#_IDESVA,&ATTRSIZE,       +\n               &S_CAPS,&HASHSIZE,&MEMINCR),VL\n         MEXIT\n.CALL5   CALLX &#_IDEPA,(&#_IDTKN,&SY_START,&#_IDESVA,&ATTRSIZE,       +\n               &S_CAPS,&HASHSIZE,&MEMINCR,&S_TRACE),VL\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   SY_TERMINATE                                               *\n* Purpose: Generate code to terminate a symbol manager session.       *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         SY_TERMINATE &ID=,&SPEPA=,&SPTOKEN=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN\n         GBLA  &SY_TERMINATE              SETC in open code.\n.*\n.* Obtain service processor ID values and terminate service processor.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +\n               ID=&ID,IDMAC=SY_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN\n         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT\n         CALLX &#_IDEPA,(&#_IDTKN,&SY_TERMINATE),VL\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   SY_TRACE                                                   *\n* Purpose: Generate code to turn symbol management tracing on/off.    *\n*                                                                     *\n*   Keyword                     Description                           *\n* -----------  ------------------------------------------------------ *\n* TRACE        =ON if symbol-manager calls to produce trace info.     *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         SY_TRACE &ID=,&SPEPA=,&SPTOKEN=,&TRACE=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN\n         GBLA  &SY_TRACE                  SETC in open code.\n         LCLC  &S_TRACE\n.*\n.* Obtain service processor ID values.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +\n               ID=&ID,IDMAC=SY_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN\n         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT\n.*\n.* Validate the TRACE keyword.\n.*\n         AIF   ('&TRACE' EQ '' ).TRACE_NS\n         AIF   ('&TRACE' EQ 'Y' ).TRACE_ON\n         AIF   ('&TRACE' EQ 'YES').TRACE_ON\n         AIF   ('&TRACE' EQ 'ON' ).TRACE_ON\n         AIF   ('&TRACE' EQ 'N' ).TRACE_OF\n         AIF   ('&TRACE' EQ 'NO' ).TRACE_OF\n         AIF   ('&TRACE' EQ 'OFF').TRACE_OF\n         MNOTE 8,'TRACE must be either ON or OFF.'\n         MEXIT\n.TRACE_NS   ANOP\n&S_TRACE    SETC ''\n            AGO .PAST_TRACE\n.TRACE_ON   ANOP\n&S_TRACE    SETC '''ON'''\n            AGO .PAST_TRACE\n.TRACE_OF   ANOP\n&S_TRACE    SETC '''OFF'''\n.PAST_TRACE ANOP\n.*\n.* Turn tracing on/off.\n.*\n         AIF   ('&S_TRACE'  NE '').CALL2\n.CALL1   CALLX &#_IDEPA,(&#_IDTKN,&SY_TRACE),VL\n         MEXIT\n.CALL2   CALLX &#_IDEPA,(&#_IDTKN,&SY_TRACE,&S_TRACE),VL\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   SY_INSTALL                                                 *\n* Purpose: Generate code to install a new symbol.                     *\n*                                                                     *\n*   Keyword                     Description                           *\n* -----------  ------------------------------------------------------ *\n* SYMBOL       ='text', =tag or =(tag,length) of symbol to install.   *\n* HANDLE       =tag of a fullword to return symbol's handle in.       *\n* ATTR         =tag containing attribute to attach to the new symbol. *\n* RETSYMBOL    =symbol_ptr                                            *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         SY_INSTALL &ID=,&SPEPA=,&SPTOKEN=,                            +\n               &SYMBOL=,&ATTR=,&HANDLE=,&RETSYMBOL=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN\n         GBLA  &SY_INSTALL                SETC in open code.\n         LCLA  &L,&I\n         LCLC  &S_ADDR,&S_LEN             Input symbol addr & len.\n.*\n.* Obtain service processor ID values.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +\n               ID=&ID,IDMAC=SY_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN\n         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT\n.*\n.* Process the SYMBOL keyword to obtain an address and a length.\n.*\n              AIF ('&SYMBOL' EQ '').NO_SYMBOL\n              AIF ('&SYMBOL'(1,1) EQ '''').SYM_LITERAL\n              AIF (N'&SYMBOL EQ 1).SYM_TAGONLY\n              AIF (N'&SYMBOL EQ 2).SYM_TAGLEN\n              MNOTE 8,'Too many subparameters for SYMBOL keyword.'\n              MEXIT\n.SYM_TAGLEN   ANOP\n&S_ADDR       SETC '&SYMBOL(1)'           | Set addr.\n&S_LEN        SETC '&SYMBOL(2)'           | Set len to specified tag.\n              AGO  .PAST_SYMBOL           |\n.SYM_TAGONLY  ANOP                        |\n&S_ADDR       SETC '&SYMBOL'              | Set addr to tag_SYMBOL.\n&S_LEN        SETC '=A(L''&SYMBOL)'       | Set len to L'tag_SYMBOL.\n              AGO  .PAST_SYMBOL           |\n.SYM_LITERAL  ANOP                        |\n&S_ADDR       SETC '&SYMBOL'              | Set addr to actual literal.\n&L            SETA 0                      | Length counter = 0.\n&I            SETA 2                      | Index counter -> past '.\n.SYM_LOOP     AIF  (&I GE K'&S_ADDR).SYM_ELOOP       Loop over SYMBOL.\n              AIF  ('&S_ADDR'(&I,1) NE '''').SYM_TXT If doubled.\n&I            SETA &I+1                   |            Advance past '.\n.SYM_TXT      ANOP                        |          EndIf.\n&L            SETA &L+1                   |   Add one to length.\n&I            SETA &I+1                   |   Advance to next position.\n              AGO  .SYM_LOOP              | End of counting loop.\n.SYM_ELOOP    ANOP                        |\n&S_LEN        SETC '=F''&L'''             | Set length parameter.\n              AGO  .PAST_SYMBOL\n.NO_SYMBOL    ANOP\n              MNOTE 8,'SYMBOL is a required keyword.'\n              MEXIT\n.PAST_SYMBOL  ANOP\n.*\n.* Generate the PLIST for the CALLX.\n.*\n         ##PLIST START\n         ##PLIST PARM,&#_IDTKN,&SY_INSTALL,&S_ADDR,&S_LEN\n         AIF   ('&RETSYMBOL' NE '').PLIST3\n         AIF   ('&ATTR'      NE '').PLIST2\n         AIF   ('&HANDLE'    NE '').PLIST1\n         AGO   .CALLX\n.PLIST1  ##PLIST PARM,&HANDLE\n         AGO   .CALLX\n.PLIST2  ##PLIST PARM,&HANDLE,&ATTR\n         AGO   .CALLX\n.PLIST3  ##PLIST PARM,&HANDLE,&ATTR,&RETSYMBOL\n         AGO   .CALLX\n.CALLX   ##PLIST END,VL\n         CALLX   &#_IDEPA                | Invoke the symbol manager.\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   SY_LOCATE                                                  *\n* Purpose: Generate code to locate an existing symbol.                *\n*                                                                     *\n*   Keyword                     Description                           *\n* -----------  ------------------------------------------------------ *\n* SYMBOL       ='text', =tag or =(tag,length) of symbol to locate.    *\n* HANDLE       =tag of a fullword...see notes below.                  *\n* ATTR         =tag to which symbol's attribute is to be copied.      *\n* RETSYMBOL    =(tag,length) to return symbol's address/length.       *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         SY_LOCATE &ID=,&SPEPA=,&SPTOKEN=,                             +\n               &SYMBOL=,&ATTR=,&HANDLE=,&RETSYMBOL=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN\n         GBLA  &SY_LOCATE                 SETC in open code.\n         LCLA  &L,&I\n         LCLC  &S_ADDR,&S_LEN             Input symbol addr & len.\n         LCLC  &S_RETADDR\n.*\n&S_ADDR       SETC ''                    | No symbol provided.\n&S_LEN        SETC ''                    | No symbol-length provided.\n&S_RETADDR    SETC ''                    | No return-address provided.\n.*\n.* Obtain service processor ID values.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +\n               ID=&ID,IDMAC=SY_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN\n         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT\n.*\n.* Process the SYMBOL keyword to obtain an address and a length.\n.*\n              AIF ('&SYMBOL'    EQ '').NO_SYMBOL\n              AIF ('&RETSYMBOL' NE '').MUTEX_ERROR\n              AIF ('&SYMBOL'(1,1) EQ '''').SYM_LITERAL\n              AIF (N'&SYMBOL EQ 1).SYM_TAGONLY\n              AIF (N'&SYMBOL EQ 2).SYM_TAGLEN\n              MNOTE 8,'Too many subparameters for SYMBOL keyword.'\n              MEXIT\n.SYM_TAGLEN   ANOP\n&S_ADDR       SETC '&SYMBOL(1)'           | Set addr.\n&S_LEN        SETC '&SYMBOL(2)'           | Set len to specified tag.\n              AGO  .PAST_SYMBOL           |\n.SYM_TAGONLY  ANOP                        |\n&S_ADDR       SETC '&SYMBOL'              | Set addr to tag_SYMBOL.\n&S_LEN        SETC '=A(L''&SYMBOL)'       | Set len to L'tag_SYMBOL.\n              AGO  .PAST_SYMBOL           |\n.SYM_LITERAL  ANOP                        |\n&S_ADDR       SETC '&SYMBOL'              | Set addr to actual literal.\n&L            SETA 0                      | Length counter = 0.\n&I            SETA 2                      | Index counter -> past '.\n.SYM_LOOP     AIF  (&I GE K'&S_ADDR).SYM_ELOOP       Loop over SYMBOL.\n              AIF  ('&S_ADDR'(&I,1) NE '''').SYM_TXT If doubled.\n&I            SETA &I+1                   |            Advance past '.\n.SYM_TXT      ANOP                        |          EndIf.\n&L            SETA &L+1                   |   Add one to length.\n&I            SETA &I+1                   |   Advance to next position.\n              AGO  .SYM_LOOP              | End of counting loop.\n.SYM_ELOOP    ANOP                        |\n&S_LEN        SETC '=F''&L'''             | Set length parameter.\n              AGO  .PAST_SYMBOL\n.LENGTH_MUTEX MNOTE 8,'RETSYMBOL is mutually exclusice with SYMBOL.'\n              MEXIT\n.NO_SYMBOL    AIF  ('&RETSYMBOL' EQ '').PAST_RETSYM\n              AIF  (N'&RETSYMBOL GT 2).BAD_RETCOUNT\n&S_RETADDR    SETC '&RETSYMBOL(1)'\n              AIF  (N'&RETSYMBOL EQ 1).PAST_RETSYM\n&S_LEN        SETC '&RETSYMBOL(2)'\n.PAST_RETSYM  AIF  ('&HANDLE' NE '').PAST_SYMBOL\n              MNOTE 8,'Either SYMBOL or HANDLE must be specified.'\n              MEXIT\n.BAD_RETCOUNT MNOTE 8,'RETSYMBOL must be specified as (address,length)'\n              MEXIT\n.PAST_SYMBOL  ANOP\n.*\n.* Generate the call to the symbol manager.\n.*\n         ##PLIST START\n         ##PLIST PARM,&#_IDTKN,&SY_LOCATE,&S_ADDR,&S_LEN\n         AIF     ('&S_RETADDR' NE '').PLIST3\n         AIF     ('&ATTR'      NE '').PLIST2\n         AIF     ('&HANDLE'    NE '').PLIST1\n         AGO     .CALLX\n.PLIST1  ##PLIST PARM,&HANDLE\n         AGO     .CALLX\n.PLIST2  ##PLIST PARM,&HANDLE,&ATTR\n         AGO     .CALLX\n.PLIST3  ##PLIST PARM,&HANDLE,&ATTR,&S_RETADDR\n         AGO     .CALLX\n.CALLX   ##PLIST END,VL\n         CALLX   &#_IDEPA\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   SY_UPDATE                                                  *\n* Purpose: Generate code to update an existing symbol.                *\n*                                                                     *\n*   Keyword                     Description                           *\n* -----------  ------------------------------------------------------ *\n* SYMBOL       ='text', =tag or =(tag,length) of symbol to update.    *\n* HANDLE       =tag of a fullword...see notes below.                  *\n* ATTR         =tag to which symbol's attribute is to be copied.      *\n* RETSYMBOL    =(tag,length) to return symbol's address/length.       *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         SY_UPDATE &ID=,&SPEPA=,&SPTOKEN=,                             +\n               &SYMBOL=,&ATTR=,&HANDLE=,&RETSYMBOL=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN\n         GBLA  &SY_UPDATE                 SETC in open code.\n         LCLA  &L,&I\n         LCLC  &S_ADDR,&S_LEN             Input symbol addr & len.\n         LCLC  &S_RETADDR\n.*\n&S_ADDR       SETC ''                    | No symbol provided.\n&S_LEN        SETC ''                    | No symbol-length provided.\n&S_RETADDR    SETC ''                    | No return-address provided.\n              AIF  ('&ATTR' NE '').ATTROK\n              MNOTE 4,'Invoking SY_UPDATE without supplying an ATTR is +\n               meaningless.'\n.ATTROK       ANOP\n.*\n.* Obtain service processor ID values.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +\n               ID=&ID,IDMAC=SY_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN\n         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT\n.*\n.* Process the SYMBOL keyword to obtain an address and a length.\n.*\n              AIF ('&SYMBOL'    EQ '').NO_SYMBOL\n              AIF ('&RETSYMBOL' NE '').MUTEX_ERROR\n              AIF ('&SYMBOL'(1,1) EQ '''').SYM_LITERAL\n              AIF (N'&SYMBOL EQ 1).SYM_TAGONLY\n              AIF (N'&SYMBOL EQ 2).SYM_TAGLEN\n              MNOTE 8,'Too many subparameters for SYMBOL keyword.'\n              MEXIT\n.SYM_TAGLEN   ANOP\n&S_ADDR       SETC '&SYMBOL(1)'           | Set addr.\n&S_LEN        SETC '&SYMBOL(2)'           | Set len to specified tag.\n              AGO  .PAST_SYMBOL           |\n.SYM_TAGONLY  ANOP                        |\n&S_ADDR       SETC '&SYMBOL'              | Set addr to tag_SYMBOL.\n&S_LEN        SETC '=A(L''&SYMBOL)'       | Set len to L'tag_SYMBOL.\n              AGO  .PAST_SYMBOL           |\n.SYM_LITERAL  ANOP                        |\n&S_ADDR       SETC '&SYMBOL'              | Set addr to actual literal.\n&L            SETA 0                      | Length counter = 0.\n&I            SETA 2                      | Index counter -> past '.\n.SYM_LOOP     AIF  (&I GE K'&S_ADDR).SYM_ELOOP       Loop over SYMBOL.\n              AIF  ('&S_ADDR'(&I,1) NE '''').SYM_TXT If doubled.\n&I            SETA &I+1                   |            Advance past '.\n.SYM_TXT      ANOP                        |          EndIf.\n&L            SETA &L+1                   |   Add one to length.\n&I            SETA &I+1                   |   Advance to next position.\n              AGO  .SYM_LOOP              | End of counting loop.\n.SYM_ELOOP    ANOP                        |\n&S_LEN        SETC '=F''&L'''             | Set length parameter.\n              AGO  .PAST_SYMBOL\n.LENGTH_MUTEX MNOTE 8,'RETSYMBOL is mutually exclusice with SYMBOL.'\n              MEXIT\n.NO_SYMBOL    AIF  ('&RETSYMBOL' EQ '').PAST_RETSYM\n              AIF  (N'&RETSYMBOL GT 2).BAD_RETCOUNT\n&S_RETADDR    SETC '&RETSYMBOL(1)'\n              AIF  (N'&RETSYMBOL EQ 1).PAST_RETSYM\n&S_LEN        SETC '&RETSYMBOL(2)'\n.PAST_RETSYM  AIF  ('&HANDLE' NE '').PAST_SYMBOL\n              MNOTE 8,'Either SYMBOL or HANDLE must be specified.'\n              MEXIT\n.BAD_RETCOUNT MNOTE 8,'RETSYMBOL must be specified as (address,length)'\n              MEXIT\n.PAST_SYMBOL  ANOP\n.*\n.* Generate the call to the symbol manager.\n.*\n         ##PLIST START\n         ##PLIST PARM,&#_IDTKN,&SY_UPDATE,&S_ADDR,&S_LEN\n         AIF     ('&S_RETADDR' NE '').PLIST3\n         AIF     ('&ATTR'      NE '').PLIST2\n         AIF     ('&HANDLE'    NE '').PLIST1\n         AGO     .CALLX\n.PLIST1  ##PLIST PARM,&HANDLE\n         AGO     .CALLX\n.PLIST2  ##PLIST PARM,&HANDLE,&ATTR\n         AGO     .CALLX\n.PLIST3  ##PLIST PARM,&HANDLE,&ATTR,&S_RETADDR\n         AGO     .CALLX\n.CALLX   ##PLIST END,VL\n         CALLX   &#_IDEPA\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   SY_DELETE                                                  *\n* Purpose: Generate code to delete a symbol from the symbol table.    *\n*                                                                     *\n*   Keyword                     Description                           *\n* -----------  ------------------------------------------------------ *\n* SYMBOL       ='text', =tag or =(tag,length) of symbol to locate.    *\n* HANDLE       =tag of a fullword identifying the symbol to delete.   *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         SY_DELETE &ID=,&SPEPA=,&SPTOKEN=,                             +\n               &SYMBOL=,&HANDLE=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN\n         GBLA  &SY_DELETE                 SETC in open code.\n         LCLA  &L,&I\n         LCLC  &S_ADDR,&S_LEN             Input symbol addr & len.\n.*\n.* Obtain service processor ID values.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +\n               ID=&ID,IDMAC=SY_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN\n         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT\n.*\n.* Process the SYMBOL keyword to obtain an address and a length.\n.*\n              AIF ('&SYMBOL' EQ '').NO_SYMBOL\n              AIF  ('&HANDLE' NE '').HANDLE_MUTEX\n              AIF ('&SYMBOL'(1,1) EQ '''').SYM_LITERAL\n              AIF (N'&SYMBOL EQ 1).SYM_TAGONLY\n              AIF (N'&SYMBOL EQ 2).SYM_TAGLEN\n              MNOTE 8,'Too many subparameters for SYMBOL keyword.'\n              MEXIT\n.SYM_TAGLEN   ANOP\n&S_ADDR       SETC '&SYMBOL(1)'           | Set addr.\n&S_LEN        SETC '&SYMBOL(2)'           | Set len to specified tag.\n              AGO  .PAST_SYMBOL           |\n.SYM_TAGONLY  ANOP                        |\n&S_ADDR       SETC '&SYMBOL'              | Set addr to tag_SYMBOL.\n&S_LEN        SETC '=A(L''&SYMBOL)'       | Set len to L'tag_SYMBOL.\n              AGO  .PAST_SYMBOL           |\n.SYM_LITERAL  ANOP                        |\n&S_ADDR       SETC '&SYMBOL'              | Set addr to actual literal.\n&L            SETA 0                      | Length counter = 0.\n&I            SETA 2                      | Index counter -> past '.\n.SYM_LOOP     AIF  (&I GE K'&S_ADDR).SYM_ELOOP       Loop over SYMBOL.\n              AIF  ('&S_ADDR'(&I,1) NE '''').SYM_TXT If doubled.\n&I            SETA &I+1                   |            Advance past '.\n.SYM_TXT      ANOP                        |          EndIf.\n&L            SETA &L+1                   |   Add one to length.\n&I            SETA &I+1                   |   Advance to next position.\n              AGO  .SYM_LOOP              | End of counting loop.\n.SYM_ELOOP    ANOP                        |\n&S_LEN        SETC '=F''&L'''             | Set length parameter.\n              AGO  .PAST_SYMBOL\n.HANDLE_MUTEX MNOTE 8,'SYMBOL and HANDLE are mutually exclusive.'\n              MEXIT\n.NO_SYMBOL    ANOP\n&S_ADDR       SETC ''                     | Set addr.\n&S_LEN        SETC ''                     | Set len.\n              AIF  ('&HANDLE' NE '').PAST_SYMBOL\n              MNOTE 8,'Either SYMBOL or HANDLE must be specified.'\n              MEXIT\n.PAST_SYMBOL  ANOP\n.*\n.* Generate the call to the symbol manager.\n.*\n         AIF   ('&HANDLE' NE '').CALL2\n.CALL1   CALLX &#_IDEPA,(&#_IDTKN,&SY_DELETE,&S_ADDR,&S_LEN),VL\n         MEXIT\n.CALL2   CALLX &#_IDEPA,(&#_IDTKN,&SY_DELETE,&S_ADDR,&S_LEN,&HANDLE),VL\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   SY_OPEN_BLOCK                                              *\n* Purpose: Generate code to enter a new symbol-table scope.           *\n*                                                                     *\n*   Keyword                     Description                           *\n* -----------  ------------------------------------------------------ *\n* BLOCK#       =tag of a fullword to return the new block's number.   *\n* NESTLEVEL    =tag of a fullword to return the new nesting level.    *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         SY_OPEN_BLOCK &ID=,&SPEPA=,&SPTOKEN=,&BLOCK#=,&NESTLEVEL=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN\n         GBLA  &SY_OPEN_BLOCK             SETC in open code.\n.*\n.* Obtain service processor ID values and call the symbol manager.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +\n               ID=&ID,IDMAC=SY_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN\n         AIF   ('&#_IDCODE'   NE 'SUCCESS').MEXIT\n         AIF   ('&BLOCK#'     NE '').CALL3\n         AIF   ('&NESTLEVEL'  NE '').CALL2\n.CALL1   CALLX &#_IDEPA,(&#_IDTKN,&SY_OPEN_BLOCK),VL\n         MEXIT\n.CALL2   CALLX &#_IDEPA,(&#_IDTKN,&SY_OPEN_BLOCK,&BLOCK#),VL\n         MEXIT\n.CALL3   CALLX &#_IDEPA,(&#_IDTKN,&SY_OPEN_BLOCK,&BLOCK#,&NESTLEVEL),VL\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   SY_ENTER_BLOCK                                             *\n* Purpose: Generate code to enter an existing symbol-table scope.     *\n*                                                                     *\n*   Keyword                     Description                           *\n* -----------  ------------------------------------------------------ *\n* BLOCK#       =tag of a fullword containing block# to enter. The     *\n*              identified block must be a child of the current block. *\n* NESTLEVEL    =tag of a fullword to return the new nesting level.    *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         SY_ENTER_BLOCK &ID=,&SPEPA=,&SPTOKEN=,&BLOCK#=,&NESTLEVEL=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN\n         GBLA  &SY_ENTER_BLOCK            SETC in open code.\n.*\n.* Obtain service processor ID values and call the symbol manager.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +\n               ID=&ID,IDMAC=SY_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN\n         AIF   ('&#_IDCODE'   NE 'SUCCESS').MEXIT\n         AIF   ('&BLOCK#'     NE '').CALL3\n         AIF   ('&NESTLEVEL'  NE '').CALL2\n.CALL1   CALLX &#_IDEPA,(&#_IDTKN,&SY_ENTER_BLOCK),VL\n         MEXIT\n.CALL2   CALLX &#_IDEPA,(&#_IDTKN,&SY_ENTER_BLOCK,&BLOCK#),VL\n         MEXIT\n.CALL3   CALLX &#_IDEPA,(&#_IDTKN,&SY_ENTER_BLOCK,&BLOCK#,&NESTLEVEL), +\n               VL\n.MEXIT   MEND\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro:   SY_EXIT_BLOCK                                              *\n* Purpose: Generate code to exit the current block to the surrounding *\n*          block.                                                     *\n*                                                                     *\n*   Keyword                     Description                           *\n* -----------  ------------------------------------------------------ *\n* BLOCK#       =tag of a fullword to return the new block's number.   *\n* NESTLEVEL    =tag of a fullword to return the new nesting level.    *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MACRO\n         SY_EXIT_BLOCK &ID=,&SPEPA=,&SPTOKEN=,&BLOCK#=,&NESTLEVEL=\n         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA\n         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN\n         GBLA  &SY_EXIT_BLOCK             SETC in open code.\n.*\n.* Obtain service processor ID values and call the symbol manager.\n.*\n         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +\n               ID=&ID,IDMAC=SY_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN\n         AIF   ('&#_IDCODE'   NE 'SUCCESS').MEXIT\n         AIF   ('&BLOCK#'     NE '').CALL3\n         AIF   ('&NESTLEVEL'  NE '').CALL2\n.CALL1   CALLX &#_IDEPA,(&#_IDTKN,&SY_EXIT_BLOCK),VL\n         MEXIT\n.CALL2   CALLX &#_IDEPA,(&#_IDTKN,&SY_EXIT_BLOCK,&BLOCK#),VL\n         MEXIT\n.CALL3   CALLX &#_IDEPA,(&#_IDTKN,&SY_EXIT_BLOCK,&BLOCK#,&NESTLEVEL),  +\n               VL\n.MEXIT   MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SRVSYXRZ": {"ttr": 36870, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x02\\x00\\x00X\\x01\\x11)\\x9f\\x01\\x11)\\x9f\\t'\\x00}\\x00}\\x00\\x00\\xc3\\xd3\\xc5\\xd4\\xe2\\xd6\\xd5@@@\"", "ispf": {"version": "02.00", "flags": 0, "createdate": "2011-10-26T00:00:00", "modifydate": "2011-10-26T09:27:58", "lines": 125, "newlines": 125, "modlines": 0, "user": "CLEMSON"}, "text": "*---------------------------------------------------------------------*\n*  Copyright 2011 by Clemson University Research Foundation           *\n*                                                                     *\n*  Licensed under the Apache License, Version 2.0 (the \"License\");    *\n*  you may not use this file except in compliance with the License.   *\n*  You may obtain a copy of the License in this library as member     *\n*  $LICENSE, or from                                                  *\n*                                                                     *\n*      http://www.apache.org/licenses/LICENSE-2.0                     *\n*                                                                     *\n*  Unless required by applicable law or agreed to in writing,         *\n*  software distributed under the License is distributed on an \"AS    *\n*  IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either    *\n*  express or implied.  See the License for the specific language     *\n*  governing permissions and limitations under the License.           *\n*---------------------------------------------------------------------*\n//SRVSYXRZ JOB TIME=(,6)\n/*JOBPARM Q=H,LINES=9\n//JOBROUTE OUTPUT DEFAULT=Y,JESDS=ALL,DEST=LASER,GROUPID=JOB,\n//         PAGEDEF=2UP,FORMDEF=RULE2\n//  EXEC  ASMPCL,COPT=',RENT',LOPT=',RENT,REUS,REFR',\n//    PDS='SYSTEMS.SRV.LOAD',NAME=SRVSYXRZ,MAC=SYSTEMS\n//P.SYSIN  DD  *\n     SMLIST CONVERT=YES\n*---------------------------------------------------------------------*\n*\n*  This program is a simple exerciser for the symbol manager.\n*  It creates some symbols, retrieves values, deletes symbols, etc.\n*\n*---------------------------------------------------------------------*\n     print off\n     copy  srvesmac\n     copy  mjmsymac\n     print on,gen\n     eject\n block name=SRVSYXRZ,type=program,options=(*pwa,xa,erraddr),           +\n               amode=31,rmode=any\n*---------------------------------------------------------------------*\n* Load and start Service Processors.\n*---------------------------------------------------------------------*\n  es_id          id=es            | Set Environment Support defaults.\n  sy_id          id=sy            | Set Symbol Manager defaults.\n  es_mvs_load    id=es            | Load Environment Support.\n  es_start       id=es            | Start Environment Support.\n  errexit        (treg,r15,nz)    |\n  es_load_module id=es,spid=sy    | Load the symbol manager.\n  errexit        (treg,r15,nz)    |\n*---------------------------------------------------------------------*\n* Begin testing the Symbol Manager's functions.\n*---------------------------------------------------------------------*\n  sy_start   id=sy,caps=yes,hashsize=1,valuesize=8,memincr=256\n  errexit    (treg,r15,nz)\n*\n  sy_install_symbol id=sy,name=\"Symbol-1\",token=pwa_token1\n  sy_install_symbol id=sy,name=\"Symbol-2\"\n  sy_install_symbol id=sy,name=\"Symbol-3\",value=psd_value3\n  sy_install_symbol id=sy,name=\"Symbol-4\",token=pwa_token4,            +\n               value=psd_value4\n*\n  sy_lookup_symbol  id=sy,name=\"Symbol-2\",token=pwa_token2\n  sy_update_value   id=sy,token=pwa_token2,value=psd_value2\n  sy_obtain_name    id=sy,token=pwa_token2,                            +\n               nameptr=pwa_token2_ptr,length=pwa_length2\n  sy_obtain_value   id=sy,token=pwa_token2,value=pwa_value2\n  sy_remove_symbol  id=sy,token=pwa_token2\n  sy_obtain_value   id=sy,token=pwa_token2,value=pwa_value2\n  sy_lookup_symbol  id=sy,name=\"Symbol-2\",token=pwa_token2\n  sy_install_symbol id=sy,name=\"Symbol-1\",token=pwa_token_null\n*\n  sy_terminate     id=sy\n  es_unload_module id=es,spid=sy\n  es_terminate     id=es\n  es_mvs_unload    id=es\n endblk block=srvsyxrz\n eject\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Error exit - ES_DISPLAY_DEBUG_INFO_AND_ABEND                       *\n*                                                                     *\n*---------------------------------------------------------------------*\n block type=errexit\n  stm   r0,r15,gdiregs                | Save registers at time of error\n  la    r0,4(,r12)                    | Point to module identification.\n  st    r0,gdimodid                   | Save in general debug area.\n  mvc   gdirc,0(r14)                  | Copy return code.\n  slr   r14,r12                       | Calculate offset at time of err\n  sth   r14,gdioffst                  | Save in debug area.\n  es_save_debug_info              id=es,gdi=gdi\n  es_display_debug_info_and_abend id=es\n endblk\n eject\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Static storage area                                                *\n*                                                                     *\n*---------------------------------------------------------------------*\n                 psd\npsd_value2       dc     cl8\"ABCDEFGH\"\npsd_value3       dc     cl8\"IJKLMNOP\"\npsd_value4       dc     cl8\"QRSTUVWX\"\n                 ltorg\n                 endpsd\n                 eject\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Static storage area                                                *\n*                                                                     *\n*---------------------------------------------------------------------*\n                 pwa\npwa_token1       sy_token\npwa_token2       sy_token\npwa_token3       sy_token\npwa_token4       sy_token\npwa_token_null   sy_token\n*\npwa_token2_ptr   ds a\npwa_length2      ds f\npwa_value2       ds cl8\n                 es_gdi dsect=no\n                 endpwa\n                 es_esv\n                 end\n//C.SYSLIB DD\n//         DD\n//         DD DSN=SYSTEMS.SRV.SOURCE,DISP=SHR\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT859/FILE859.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT859", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}