{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012535000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 1175720, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 35, "INMDSNAM": "CBT.V500.FILE656.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 1175720, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 1175720, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE656.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x15\\x12'", "DS1TRBAL": "b'KN'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x04\\xa0\\x00\\x0e\\x04\\xa2\\x00\\x05\\x00\\x16'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x02\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00\\x10\\x00\\x10\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:02", "lines": 16, "newlines": 16, "modlines": 0, "user": "KANNAN"}, "text": "/* Rexx $                                                            */\n/* ..................................................................*/\n/* Author  : Kannan AK                                               */\n/* $       : Returns cost of the session incurred so far             */\n/* Notice  : Shop dependent                                          */\n/* Version : Alpha                                                   */\n/* ..................................................................*/\ncpu = sysvar(syscpu)                        /* get cpu time          */\nhour = substr(time(),1,2)                   /* get hour of the day   */\nif (hour > 16) | (hour < 8)                 /* prime or non-prime?   */\n  then cost = .07                           /* non-prime cost factor */\n  else cost = .13944444                     /* prime cost factor     */\nzedlmsg = '$'strip(format(3.2*cpu*cost,4,2))' for' strip(cpu) 'seconds'\nspent   = '$'strip(format(3.2*cpu*cost,4,2))' for' strip(cpu) 'seconds'\naddress ispexec 'setmsg msg (isrz001)'\nreturn\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$$$#DATE": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04?\\x00\\x00\\x01\\x033\\x1f\\x01\\x033\\x1f\\x11\\x03\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf6\\xf3@@@'", "ispf": {"version": "04.63", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T11:03:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-463"}, "text": "REGULAR CBT TAPE - VERSION 463    FILE:  656\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT463.FILE656\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 178 MEMBERS COUNTED; CUMULATIVE SIZE IS 10,176 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   11/27/03    11:03:57    GMT-5:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$INDEX": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x02\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00\\xae\\x00\\xae\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:02", "lines": 174, "newlines": 174, "modlines": 0, "user": "KANNAN"}, "text": "$........|GIVES AN ESTIMATE OF THE SESSION COST. SHOP-DEPENDENT.\nALT......|SIMPLE ALTER OF IDCAMS TO USE IN 3.4\nAMBCLIST.|MARK ZELDEN'S INTERACTIVE AMBLIST\nAMBPNL...|PANEL FOR THE ABOVE\nAPLBOX...|AN EXPERIMENTAL GRAPHIC ECSCAPE FORMALATOR.\nBATCHPDF.|DOUG NADEL'S ISPF BATCH RUN MODULE\nBATCHSMS.|FORCE CHANGE MGMTCLASSES. CAN BE USED AS A TEMPLATE.\nBTSO.....|ANOTHER FLOATING VERSION OF TSO OUTTRAP\nCDATE....|CREATION DATE EXPLORER\nCDATEPNL.|CREATION DATE EXPLORER PANEL\nCE.......|A FUNNY-WRITTEN FUNCTION-RICH CUSTOM EDITOR. OPTIMZABLE.\nCHANGE...|REXX BASED CHANGE STRING WITH EXAMPLES. WROTE FOR SOMEONE.\nCHECKVOL.|FIND IF THE VOLUME IS PRESENT OR NOT.\nCOLADD...|MARK ZELDEN'S MACRO TO ADD NUMERIC DATA IN MEDLEY FORMATS.\nCOM......|COMMENT JCL OR COBOL SOURCE.\nCOMPACT..|I DO NOT USE THIS :-). DEFRAGMENT THE FILES. COMPRESS.\nCOMREX...|COMMENT REXX SOURCE.\nCOMSQL...|COMMENT SQL SOURCE. SPUFI.\nCOPYPEND.|SHOW COPY PEND IN DB2.\nCOUNT....|ANOTHER FLOATING VERSION TO COUNT DATASET RECORDS, BYTES...\nCURPOS...|EXAMPLE TO READ CURSOR ROW, COLUMN.\nCURRGEN..|A VARIANT USING LM TO GET ABS NAME FOR GDG.\nCX.......|CURSOR SENSITIVE DATA EXTRACTION. DOUG NADEL, I THINK.\nDB2PEND..|CALLABLE ROUTINE FOR DB2 COMMAND (DISPLAY DATABASE).\nDB2SPNL..|PANEL USED IN IMAGEJCL AND DISPPEND.\nDB2TPNL..|PANEL USED IN IMAGEJCL AND DISPPEND.\nDB2UTIL..|CALLABLE ROUTINE FOR DB2 COMMAND (DISPLAY UTILITY).\nDEAL.....|DEAL CARDS. FROM WWW.\nDEBUGCMD.|AS NAME SUGGESTS.\nDEFVSAM..|DEFINE THE VSAM BY GETTING ATTRIBUTES. GETS A JCL TO RUN.\nDELAY....|JUST A SIMPLE AND CRUDE VERSION OF DELAY USING TIME(R).\nDELDUPE..|MARK ZELDEN'S DELETING DUPES. EDIT MACRO.\nDELMEM...|DELETE THE MEMBER IN EDIT.\nDESC.....|A TRY LIKE UNIX DESC COMMAND FOR DB2. FROM SYSCOLUMNS.\nDIR......|DSLIST.\nDIRPNL...|A PANEL USED IN CE. TO COLLECT A DSLIST INITIAL VIEW.\nDISPPEND.|DISPLAY PENDING UTILITES ON DB2 SUBSYSTEM.\nDISPUTIL.|DISPLAY RUNNING UTILITIES ON DB2 SUBSYSTEM.\nDSN......|DB2 DISPLAY UTIL SNIPPET IN REXX\nDSNREXX..|DSNREXX HOST COMMAND ENV SNIPPET.\nDSNTIAUL.|RUN PROGRAM(DSNTIAUL) PLAN(DSNTIAUL).\nDYN......|EXAMPLE FROM WWW FOR DYNAMIC AREAS.\nDYNAREA..|EXAMPLE FROM WWW FOR DYNAMIC AREAS, PANEL IS HERE.\nEDITALL..|FAMOUS EDITALL. APPLY MACRO TO A WHOLE PDS.\nEMPTYPDS.|WROTE FOR SOMEONE. CLEAN A PDS.\nEOF......|CHECK WHETHER A FILE IS EMPTY.\nEOL......|CLEAN COLUMNS 73-80.\nFINDMOD..|FIND THE MODULE WHERE. MARK ZELDEN'S FINE PIECE.\nFOCERR...|MY TRYST WITH FOCUS TO GET ERROR DESCRIPTION.\nFRAGPNL..|FOR COMPACT, A PANEL.\nGDGL.....|LIST GDG.\nGE.......|GRAPHIC ESCAPE CHARACTERS ILLUSTRATION.\nGEBAR....|GRAPHIC ESCAPE.\nGEBARPNL.|GRAPHIC ESCAPE.\nGEBARR...|GRAPHIC ESCAPE.\nGEPNL....|GRAPHIC ESCAPE CHARACTERS ILLUSTRATION PANEL.\nGMT......|GMT CALC.\nGOTCHAS..|SOME TIPS GATHERED ON TSO/ISPF.\nGREP.....|FIND MEMBERS. SCANPDS IS THE NAME OUTSIDE.\nHIST.....|WROTE TO GET HISTORY OF DATASETS EDITED. REFLIST IS THERE NOW.\nHISTPNL..|PANEL FOR HIST.\nHOLD.....|CONTENTION FINDER.\nHOLD2....|CONTENTION FINDER.\nHR.......|HRECALL ENCAPSULATED IN REXX.\nHREC.....|HRECALL FOR SOME DATASETS IN A PARTICULAR DAY.\nICSF.....|FIND IF ICSF IS INSTALLED. THIERRY FALISSARD'S.\nIEHL.....|CALL TO GET CONTENTS OF VTOC. IEHLIST.\nIMAGEJCL.|CREATES A JCL FOR TAKING IMAGECOPY.\nIMBED....|IMBEDDED PANELS. EXAMPLE.\nIMBEDPNL.|PANEL FOR IMBED.\nINIT.....|GET ALL INITIATORS IN THE SYSTEM. DOUG NADEL'S.\nINS......|INSERT DATA IN COLUMNAR FASHION IN EDIT.\nINSTREAM.|FRAGMENT TO INSTREAM THE DATA FROM SOURCELINES.\nISPCMDU..|ADD COMMANDS ON-THE-FLY.\nISUB.....|INTERACTIVE SUBMIT.\nJC.......|JOBCARD CREATOR.\nJC2......|JOBCARD CREATOR. BASED ON ZLLGJOBX. CUT AND PASTE.\nJOBNAME..|GET THE CURRENT JOB NAME. CAN BE USED IN BATCH.\nJSEND....|WRAPPED TSO SENDS FOR MUTIPLE TIME.\nJ2S......|JULIAN TO STANDARD DATE CONVERION.\nKILL.....|KILL THE SESSION.\nLASTJCL..|OPENS IN EDIT MODE THE LAST KNOWN JCL SUBMITTED.\nLASTMM...|GETS LAST MONTH MM.\nLEN......|LENGTH OF THE STRING. JIM MOORE'S.\nLIBRARN..|INITIATE CA-ELIPS. YMMV.\nLISTALL..|LISTCAT ALL FOR USING WITH 3.4 PREFERABLY.\nLOCDD....|LOCATE DD. PARSE LISTA ST.\nLOGONCMD.|FINDS IF YOU HAVE ANY LOGON COMMAND.\nLOOKE....|MACRO TO GO TO ELIPS EDIT.\nLRECL....|LRECL/BLKSIZE FINDER AS EDIT MACRO.\nLS.......|DSLIST CUSTOM-MADE.\nLSPNL....|PANEL OF LS.\nMAIN.....|MAIN PANEL FOR THE CE UTILITY. CONCOCTED WITH ISR@PRIM.\nMAKEJCL..|CREATES JCL OUT OF SAVED JOBLOGS.\nMASSCOPY.|AS THE NAME SUGGESTS. BUILDS HUGE JCLS.\nMASSDEL..|AS THE NAME SUGGESTS. BUILDS HUGE JCLS.\nMASSDELP.|AS THE NAME SUGGESTS. BUILDS HUGE JCLS.\nMASSSTAT.|GETS ISPF STATISTICS. AGAIN FOR MULTIPLE DATASETS.\nMEMBER...|FIND WHICH DATA SETS IN A DSLIST CONTAIN A MEMBER. DOUG NADEL.\nMQRC.....|I LEFT A SNIPPET FOR MQSERIES RETURN CODE.\nMSGPNL...|JUST A MESSAGE PANEL TO BE (RE)USED.\nNAB......|GRAB A 8 CHAR STRING. MEMBER NAME PROBABLY. CHOPS TO 8 CHARS.\nNOTMACRO.|DECIDE WHETHER A EDIT MACRO OR TSO COMMAND IS RUNNING.\nONLY.....|X ALL;F ALL COMBO.\nOPENTAB..|ALL OPEN TABLES DISPLAYED. DOUG NADEL'S.\nPAD......|CLIPBOARD IN THE MAINFRAME.\nPATTERN..|PATTERN MATCHING. FROM WWW.\nPROFDUMP.|DUMP PROFILE VARIABLES.\nPROFILE..|SYSUEXEC ASSIGNMENT.\nPROGBAR..|PROGRESS BAR. WINDOWS-LIKE. BASED IN GRAPHIC ESCAPE.\nPROGPNL..|PANEL FOR PROGRESS BAR.\nPROGRESS.|VARIANT OF PROGRESS BAR.\nPT.......|PANEL TEST. 7.2.\nQB.......|QUICK BROWSE. CURSOR-SENSTITIVE.\nQBASE....|QBASE SERVICE EXAMPLE.\nQC.......|QUICK COPY JCL CREATOR. NO PDSE.\nQCC......|QUICK COPY AS EDIT MACRO. CURSOR-SENSTITIVE.\nQD.......|QUICK DELETE. CURSOR-SENSTITIVE.\nQE.......|QUICK EDIT. CURSOR-SENSTITIVE.\nQH.......|QUICK HRECALL. CURSOR-SENSTITIVE.\nQI.......|QUICK INFO. CURSOR-SENSTITIVE. USES GRAPHIC PANEL.\nQIPNL....|PANEL FOR QI. GOOD EXAMPLE FOR GRAPHIC ESCAPES.\nQL.......|QUICK LOCATE. CURSOR-SENSTITIVE.\nQM.......|QUICK MENU. CURSOR-SENSTITIVE.\nQMPNL....|QUICK MENU PANEL.\nQN.......|QUICK NUMBER OF LINES. CURSOR-SENSTITIVE.\nQR.......|QUICK RENAME. CURSOR-SENSTITIVE.\nQS.......|QUICK SDSF.\nQV.......|QUICK VIEW. CURSOR-SENSTITIVE.\nREFDD....|USED IN CE.\nREX......|RECURSIVE EDIT.\nREXE.....|REXX SYNTAX CHECK.\nREXI.....|REXX SYNTAX CHECK.\nREXXTRY..|REXX SYNTAX CHECK.\nRUNSQL...|RUN SQL IN THE EDIT. AS EDIT MACRO. DEPLOYS DSNTEP2.\nSAMPLECL.|ALTER MANAGEMENT CLASS.\nSDSFREXX.|GRAB SDSF STATUS SCREEN. WROTE FOR SOMEONE AS AN EXAMPLE.\nSDSFST...|WHAT IS IN OUTPUT QUEUE? CAPTURE INA FILE.\nSHADOW...|SHADOW AREAS EXAMPLE.\nSHOWBAR..|VARIANT ON PROGRESS BAR.\nSITECMDS.|ADD COMMANDS ON-THE-FLY. MY VERION. INSTREAMED AND SIMPLE.\nSJ.......|CUSTOM SUBMIT. WRITES JOBNAME TO THE MEMBER/DSN.\nSL.......|SET LABEL FOR COBOL SOURCE.\nSLEEP....|SLEEP FOR N SECS.\nSMS......|SHOW SMS CLASSES FOR A DATASET.\nSMSPNL...|PANEL FOR SMS.\nSQLC.....|RETURNS SQL CODE DESCRIPTION FOR A VALID SQLCODE.\nSRCHLIST.|JIM NARRAMORE'S 3.14.\nSTEMVAR..|STEM VAR OR SIMPLE VAR. AN EXERCISE.\nSUBSYS...|FIND ALL SUBSYSTEMS KNOWN TO MVS. FROM WWW.\nSUICIDE..|KILL THE SESSION. ANOTHER VARIANT.\nSWID.....|CHANGE JOB CHAR AND NOTIFY.\nTBV......|CREATE ISPF TABLE VIEW DYNAMICALLY. FROM WWW.\nTBVIEW...|CREATE ISPF TABLE VIEW DYNAMICALLY. FROM WWW.\nTBVWPNL..|CREATE ISPF TABLE VIEW DYNAMICALLY. FROM WWW.\nTESTBAR..|PROGRESS METER.\nTHINK....|HOW MUCH TIME AN EXEC HAS TAKEN?\nTIDYUP...|CLEAN SUPERC OUTPUT AND GET ONLY MEMBERS.\nTOVIEW...|SWITCH TO VIEW OR BROWSE MODE.\nUCOM.....|UNCOMMENT JCL OR COBOL SOURCE.\nUCOMSQL..|UNCOMMENT SQL.\nUNAME....|USER NAME FROM DATA AREA.\nUSERNAME.|USER NAME FROM DATA AREA.\nUTILPNL..|PANEL FOR UTILSTAT.\nUTILSTAT.|SHOW RUNNING DB2 UTILITIES.\nVB.......|VSAM BROWSE.\nVBKEY....|VSAM BROWSE WITH KEY.\nWAIT.....|WAIT VIA SYSCALL. A VARIANT.\nWHOPDS...|EXAMPLE TO GET PDS NAME AND MEMBER DDNAME UNDER EDIT.\nWILDEL...|WILD DELETE.\nXCOPY....|JCL CREATOR FOR MASSCOPY. CLONE OF MASSCOPY.\nYESNOPNL.|USED IN QD. CONFIRMATION PANEL. REUSABLE IF ZWINTTL PASSED.\nZAPPDS...|DELETE ALL MEMBERS OF A PDS.\nZAPSHELL.|CLEARS TSO COMMANDS IN OPTION 6.\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$README": {"ttr": 524, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x02\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00\\x12\\x00\\x12\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:02", "lines": 18, "newlines": 18, "modlines": 0, "user": "KANNAN"}, "text": "Hi,\n\nThe collection of Rexx Execs you will find here in one way or other\ncomprises :\n1. My interest in graphic escape character set and execs as a sequel.\n2. Comment/uncomment suite for jcl, cobol, sql and rexx. Edit macros.\n3. Focus, MQ, SQL RC - error text retrievers.\n4. CA-elips invocation. We had Librarian in one of the shops.\n5. Various utilities for ispf. Productivity-enablers.\n6. DB2 utilties. Imagecopy, Copypend, Utils and RUNSQL as edit macro.\n7. Quick cursor-sensitive suite.\n8. Useful utilities gathered in time.\n\nSee $INDEX for a comprehensive list.\n\nHope this helps,\nKannan AK.\nhanna_a_k@hotmail.com\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "@FILE656": {"ttr": 526, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04?\\x00\\x00\\x01\\x033\\x1f\\x01\\x033\\x1f\\x11\\x03\\x00\\xea\\x00\\xea\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf6\\xf3@@@'", "ispf": {"version": "04.63", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T11:03:00", "lines": 234, "newlines": 234, "modlines": 0, "user": "CBT-463"}, "text": "//***FILE 656 is from Kannan AK in Madras, India, and contains a    *   FILE 656\n//*           large collection of very handy REXX utilities, for    *   FILE 656\n//*           the most part.                                        *   FILE 656\n//*                                                                 *   FILE 656\n//*           Kannan AK                                             *   FILE 656\n//*           Patni Computer Systems Ltd,                           *   FILE 656\n//*           Guna Bldg, 304-305, Anna Salai,                       *   FILE 656\n//*           Teynampet, Chennai 60018,                             *   FILE 656\n//*           India.                                                *   FILE 656\n//*                                                                 *   FILE 656\n//*           email:  hanna_a_k@hotmail.com                         *   FILE 656\n//*                   a.kannan@patni.com                            *   FILE 656\n//*                                                                 *   FILE 656\n//*     Description of file contents:                               *   FILE 656\n//*                                                                 *   FILE 656\n//*     $        - GIVES AN ESTIMATE OF THE SESSION COST.           *   FILE 656\n//*                SHOP-DEPENDENT.                                  *   FILE 656\n//*     ALT      - SIMPLE ALTER OF IDCAMS TO USE IN 3.4             *   FILE 656\n//*     AMBCLIST - MARK ZELDEN'S INTERACTIVE AMBLIST                *   FILE 656\n//*     AMBPNL   - PANEL FOR THE ABOVE                              *   FILE 656\n//*     APLBOX   - AN EXPERIMENTAL GRAPHIC ECSCAPE FORMALATOR.      *   FILE 656\n//*     BATCHPDF - DOUG NADEL'S ISPF BATCH RUN MODULE               *   FILE 656\n//*     BATCHSMS - FORCE CHANGE MGMTCLASSES. CAN BE USED AS A       *   FILE 656\n//*                TEMPLATE.                                        *   FILE 656\n//*     BTSO     - ANOTHER FLOATING VERSION OF TSO OUTTRAP          *   FILE 656\n//*     CDATE    - CREATION DATE EXPLORER                           *   FILE 656\n//*     CDATEPNL - CREATION DATE EXPLORER PANEL                     *   FILE 656\n//*     CE       - A FUNNY-WRITTEN FUNCTION-RICH CUSTOM EDITOR.     *   FILE 656\n//*                OPTIMIZABLE.                                     *   FILE 656\n//*     CHANGE   - REXX BASED CHANGE STRING WITH EXAMPLES.          *   FILE 656\n//*                WROTE FOR SOMEONE.                               *   FILE 656\n//*     CHECKVOL - FIND IF THE VOLUME IS PRESENT OR NOT.            *   FILE 656\n//*     COLADD   - MARK ZELDEN'S MACRO TO ADD NUMERIC DATA IN       *   FILE 656\n//*                MEDLEY FORMATS.                                  *   FILE 656\n//*     COM      - COMMENT JCL OR COBOL SOURCE.                     *   FILE 656\n//*     COMPACT  - I DO NOT USE THIS :-). DEFRAGMENT THE FILES.     *   FILE 656\n//*                COMPRESS.                                        *   FILE 656\n//*     COMREX   - COMMENT REXX SOURCE.                             *   FILE 656\n//*     COMSQL   - COMMENT SQL SOURCE. SPUFI.                       *   FILE 656\n//*     COPYPEND - SHOW COPY PEND IN DB2.                           *   FILE 656\n//*     COUNT    - ANOTHER FLOATING VERSION TO COUNT DATASET        *   FILE 656\n//*                RECORDS, BYTES...                                *   FILE 656\n//*     CURPOS   - EXAMPLE TO READ CURSOR ROW, COLUMN.              *   FILE 656\n//*     CURRGEN  - A VARIANT USING LM TO GET ABS NAME FOR GDG.      *   FILE 656\n//*     CX       - CURSOR SENSITIVE DATA EXTRACTION. DOUG           *   FILE 656\n//*                NADEL, I THINK.                                  *   FILE 656\n//*     DB2PEND  - CALLABLE ROUTINE FOR DB2 COMMAND (DISPLAY        *   FILE 656\n//*                DATABASE).                                       *   FILE 656\n//*     DB2SPNL  - PANEL USED IN IMAGEJCL AND DISPPEND.             *   FILE 656\n//*     DB2TPNL  - PANEL USED IN IMAGEJCL AND DISPPEND.             *   FILE 656\n//*     DB2UTIL  - CALLABLE ROUTINE FOR DB2 COMMAND (DISPLAY        *   FILE 656\n//*                UTILITY).                                        *   FILE 656\n//*     DEAL     - DEAL CARDS. FROM WWW.                            *   FILE 656\n//*     DEBUGCMD - AS NAME SUGGESTS.                                *   FILE 656\n//*     DEFVSAM  - DEFINE THE VSAM BY GETTING ATTRIBUTES. GETS      *   FILE 656\n//*                A JCL TO RUN.                                    *   FILE 656\n//*     DELAY    - JUST A SIMPLE AND CRUDE VERSION OF DELAY         *   FILE 656\n//*                USING TIME(R).                                   *   FILE 656\n//*     DELDUPE  - MARK ZELDEN'S DELETING DUPES. EDIT MACRO.        *   FILE 656\n//*     DELMEM   - DELETE THE MEMBER IN EDIT.                       *   FILE 656\n//*     DESC     - A TRY LIKE UNIX DESC COMMAND FOR DB2. FROM       *   FILE 656\n//*                SYSCOLUMNS.                                      *   FILE 656\n//*     DIR      - DSLIST.                                          *   FILE 656\n//*     DIRPNL   - A PANEL USED IN CE. TO COLLECT A DSLIST          *   FILE 656\n//*                INITIAL VIEW.                                    *   FILE 656\n//*     DISPPEND - DISPLAY PENDING UTILITES ON DB2 SUBSYSTEM.       *   FILE 656\n//*     DISPUTIL - DISPLAY RUNNING UTILITIES ON DB2 SUBSYSTEM.      *   FILE 656\n//*     DSN      - DB2 DISPLAY UTIL SNIPPET IN REXX                 *   FILE 656\n//*     DSNREXX  - DSNREXX HOST COMMAND ENV SNIPPET.                *   FILE 656\n//*     DSNTIAUL - RUN PROGRAM(DSNTIAUL) PLAN(DSNTIAUL).            *   FILE 656\n//*     DYN      - EXAMPLE FROM WWW FOR DYNAMIC AREAS.              *   FILE 656\n//*     DYNAREA  - EXAMPLE FROM WWW FOR DYNAMIC AREAS, PANEL IS     *   FILE 656\n//*                HERE.                                            *   FILE 656\n//*     EDITALL  - FAMOUS EDITALL. APPLY MACRO TO A WHOLE PDS.      *   FILE 656\n//*     EMPTYPDS - WROTE FOR SOMEONE. CLEAN A PDS.                  *   FILE 656\n//*     EOF      - CHECK WHETHER A FILE IS EMPTY.                   *   FILE 656\n//*     EOL      - CLEAN COLUMNS 73-80.                             *   FILE 656\n//*     FINDMOD  - FIND THE MODULE WHERE. MARK ZELDEN'S FINE        *   FILE 656\n//*                PIECE.                                           *   FILE 656\n//*     FOCERR   - MY TRYST WITH FOCUS TO GET ERROR                 *   FILE 656\n//*                DESCRIPTION.                                     *   FILE 656\n//*     FRAGPNL  - FOR COMPACT, A PANEL.                            *   FILE 656\n//*     GDGL     - LIST GDG.                                        *   FILE 656\n//*     GE       - GRAPHIC ESCAPE CHARACTERS ILLUSTRATION.          *   FILE 656\n//*     GEBAR    - GRAPHIC ESCAPE.                                  *   FILE 656\n//*     GEBARPNL - GRAPHIC ESCAPE.                                  *   FILE 656\n//*     GEBARR   - GRAPHIC ESCAPE.                                  *   FILE 656\n//*     GEPNL    - GRAPHIC ESCAPE CHARACTERS ILLUSTRATION           *   FILE 656\n//*                PANEL.                                           *   FILE 656\n//*     GMT      - GMT CALC.                                        *   FILE 656\n//*     GOTCHAS  - SOME TIPS GATHERED ON TSO/ISPF.                  *   FILE 656\n//*     GREP     - FIND MEMBERS. SCANPDS IS THE NAME OUTSIDE.       *   FILE 656\n//*     HIST     - WROTE TO GET HISTORY OF DATASETS EDITED.         *   FILE 656\n//*                REFLIST IS THERE NOW.                            *   FILE 656\n//*     HISTPNL  - PANEL FOR HIST.                                  *   FILE 656\n//*     HOLD     - CONTENTION FINDER.                               *   FILE 656\n//*     HOLD2    - CONTENTION FINDER.                               *   FILE 656\n//*     HR       - HRECALL ENCAPSULATED IN REXX.                    *   FILE 656\n//*     HREC     - HRECALL FOR SOME DATASETS IN A PARTICULAR        *   FILE 656\n//*                DAY.                                             *   FILE 656\n//*     ICSF     - FIND IF ICSF IS INSTALLED. THIERRY               *   FILE 656\n//*                FALISSARD'S.                                     *   FILE 656\n//*     IEHL     - CALL TO GET CONTENTS OF VTOC. IEHLIST.           *   FILE 656\n//*     IMAGEJCL - CREATES A JCL FOR TAKING IMAGECOPY.              *   FILE 656\n//*     IMBED    - IMBEDDED PANELS. EXAMPLE.                        *   FILE 656\n//*     IMBEDPNL - PANEL FOR IMBED.                                 *   FILE 656\n//*     INIT     - GET ALL INITIATORS IN THE SYSTEM. DOUG           *   FILE 656\n//*                NADEL'S.                                         *   FILE 656\n//*     INS      - INSERT DATA IN COLUMNAR FASHION IN EDIT.         *   FILE 656\n//*     INSTREAM - FRAGMENT TO INSTREAM THE DATA FROM               *   FILE 656\n//*                SOURCELINES.                                     *   FILE 656\n//*     ISPCMDU  - ADD COMMANDS ON-THE-FLY.                         *   FILE 656\n//*     ISUB     - INTERACTIVE SUBMIT.                              *   FILE 656\n//*     JC       - JOBCARD CREATOR.                                 *   FILE 656\n//*     JC2      - JOBCARD CREATOR. BASED ON ZLLGJOBX. CUT AND      *   FILE 656\n//*                PASTE.                                           *   FILE 656\n//*     JOBNAME  - GET THE CURRENT JOB NAME. CAN BE USED IN         *   FILE 656\n//*                BATCH.                                           *   FILE 656\n//*     JSEND    - WRAPPED TSO SENDS FOR MUTIPLE TIME.              *   FILE 656\n//*     J2S      - JULIAN TO STANDARD DATE CONVERION.               *   FILE 656\n//*     KILL     - KILL THE SESSION.                                *   FILE 656\n//*     LASTJCL  - OPENS IN EDIT MODE THE LAST KNOWN JCL            *   FILE 656\n//*                SUBMITTED.                                       *   FILE 656\n//*     LASTMM   - GETS LAST MONTH MM.                              *   FILE 656\n//*     LEN      - LENGTH OF THE STRING. JIM MOORE'S.               *   FILE 656\n//*     LIBRARN  - INITIATE CA-ELIPS. YMMV.                         *   FILE 656\n//*     LISTALL  - LISTCAT ALL FOR USING WITH 3.4 PREFERABLY.       *   FILE 656\n//*     LOCDD    - LOCATE DD. PARSE LISTA ST.                       *   FILE 656\n//*     LOGONCMD - FINDS IF YOU HAVE ANY LOGON COMMAND.             *   FILE 656\n//*     LOOKE    - MACRO TO GO TO ELIPS EDIT.                       *   FILE 656\n//*     LRECL    - LRECL/BLKSIZE FINDER AS EDIT MACRO.              *   FILE 656\n//*     LS       - DSLIST CUSTOM-MADE.                              *   FILE 656\n//*     LSPNL    - PANEL OF LS.                                     *   FILE 656\n//*     MAIN     - MAIN PANEL FOR THE CE UTILITY. CONCOCTED         *   FILE 656\n//*                WITH ISR@PRIM.                                   *   FILE 656\n//*     MAKEJCL  - CREATES JCL OUT OF SAVED JOBLOGS.                *   FILE 656\n//*     MASSCOPY - AS THE NAME SUGGESTS. BUILDS HUGE JCLS.          *   FILE 656\n//*     MASSDEL  - AS THE NAME SUGGESTS. BUILDS HUGE JCLS.          *   FILE 656\n//*     MASSDELP - AS THE NAME SUGGESTS. BUILDS HUGE JCLS.          *   FILE 656\n//*     MASSSTAT - GETS ISPF STATISTICS. AGAIN FOR MULTIPLE         *   FILE 656\n//*                DATASETS.                                        *   FILE 656\n//*     MEMBER   - FIND WHICH DATA SETS IN A DSLIST CONTAIN A       *   FILE 656\n//*                MEMBER. DOUG NADEL.                              *   FILE 656\n//*     MQRC     - I LEFT A SNIPPET FOR MQSERIES RETURN CODE.       *   FILE 656\n//*     MSGPNL   - JUST A MESSAGE PANEL TO BE (RE)USED.             *   FILE 656\n//*     NAB      - GRAB A 8 CHAR STRING. MEMBER NAME PROBABLY.      *   FILE 656\n//*                CHOPS TO 8 CHARS.                                *   FILE 656\n//*     NOTMACRO - DECIDE WHETHER A EDIT MACRO OR TSO COMMAND       *   FILE 656\n//*                IS RUNNING.                                      *   FILE 656\n//*     ONLY     - X ALL;F ALL COMBO.                               *   FILE 656\n//*     OPENTAB  - ALL OPEN TABLES DISPLAYED. DOUG NADEL'S.         *   FILE 656\n//*     PAD      - CLIPBOARD IN THE MAINFRAME.                      *   FILE 656\n//*     PATTERN  - PATTERN MATCHING. FROM WWW.                      *   FILE 656\n//*     PROFDUMP - DUMP PROFILE VARIABLES.                          *   FILE 656\n//*     PROFILE  - SYSUEXEC ASSIGNMENT.                             *   FILE 656\n//*     PROGBAR  - PROGRESS BAR. WINDOWS-LIKE. BASED IN GRAPHIC     *   FILE 656\n//*                ESCAPE.                                          *   FILE 656\n//*     PROGPNL  - PANEL FOR PROGRESS BAR.                          *   FILE 656\n//*     PROGRESS - VARIANT OF PROGRESS BAR.                         *   FILE 656\n//*     PT       - PANEL TEST. 7.2.                                 *   FILE 656\n//*     QB       - QUICK BROWSE. CURSOR-SENSTITIVE.                 *   FILE 656\n//*     QBASE    - QBASE SERVICE EXAMPLE.                           *   FILE 656\n//*     QC       - QUICK COPY JCL CREATOR. NO PDSE.                 *   FILE 656\n//*     QCC      - QUICK COPY AS EDIT MACRO. CURSOR-SENSTITIVE.     *   FILE 656\n//*     QD       - QUICK DELETE. CURSOR-SENSTITIVE.                 *   FILE 656\n//*     QE       - QUICK EDIT. CURSOR-SENSTITIVE.                   *   FILE 656\n//*     QH       - QUICK HRECALL. CURSOR-SENSTITIVE.                *   FILE 656\n//*     QI       - QUICK INFO. CURSOR-SENSTITIVE. USES GRAPHIC      *   FILE 656\n//*                PANEL.                                           *   FILE 656\n//*     QIPNL    - PANEL FOR QI. GOOD EXAMPLE FOR GRAPHIC           *   FILE 656\n//*                ESCAPES.                                         *   FILE 656\n//*     QL       - QUICK LOCATE. CURSOR-SENSTITIVE.                 *   FILE 656\n//*     QM       - QUICK MENU. CURSOR-SENSTITIVE.                   *   FILE 656\n//*     QMPNL    - QUICK MENU PANEL.                                *   FILE 656\n//*     QN       - QUICK NUMBER OF LINES. CURSOR-SENSTITIVE.        *   FILE 656\n//*     QR       - QUICK RENAME. CURSOR-SENSTITIVE.                 *   FILE 656\n//*     QS       - QUICK SDSF.                                      *   FILE 656\n//*     QV       - QUICK VIEW. CURSOR-SENSTITIVE.                   *   FILE 656\n//*     REFDD    - USED IN CE.                                      *   FILE 656\n//*     REX      - RECURSIVE EDIT.                                  *   FILE 656\n//*     REXE     - REXX SYNTAX CHECK.                               *   FILE 656\n//*     REXI     - REXX SYNTAX CHECK.                               *   FILE 656\n//*     REXXTRY  - REXX SYNTAX CHECK.                               *   FILE 656\n//*     RUNSQL   - RUN SQL IN THE EDIT. AS EDIT MACRO. DEPLOYS      *   FILE 656\n//*                DSNTEP2.                                         *   FILE 656\n//*     SAMPLECL - ALTER MANAGEMENT CLASS.                          *   FILE 656\n//*     SDSFREXX - GRAB SDSF STATUS SCREEN. WROTE FOR SOMEONE       *   FILE 656\n//*                AS AN EXAMPLE.                                   *   FILE 656\n//*     SDSFST   - WHAT IS IN OUTPUT QUEUE? CAPTURE INA FILE.       *   FILE 656\n//*     SHADOW   - SHADOW AREAS EXAMPLE.                            *   FILE 656\n//*     SHOWBAR  - VARIANT ON PROGRESS BAR.                         *   FILE 656\n//*     SITECMDS - ADD COMMANDS ON-THE-FLY. MY VERSION.             *   FILE 656\n//*                INSTREAMED AND SIMPLE.                           *   FILE 656\n//*     SJ       - CUSTOM SUBMIT. WRITES JOBNAME TO THE             *   FILE 656\n//*                MEMBER/DSN.                                      *   FILE 656\n//*     SL       - SET LABEL FOR COBOL SOURCE.                      *   FILE 656\n//*     SLEEP    - SLEEP FOR N SECS.                                *   FILE 656\n//*     SMS      - SHOW SMS CLASSES FOR A DATASET.                  *   FILE 656\n//*     SMSPNL   - PANEL FOR SMS.                                   *   FILE 656\n//*     SQLC     - RETURNS SQL CODE DESCRIPTION FOR A VALID         *   FILE 656\n//*                SQLCODE.                                         *   FILE 656\n//*     SRCHLIST - JIM NARRAMORE'S 3.14.                            *   FILE 656\n//*     STEMVAR  - STEM VAR OR SIMPLE VAR. AN EXERCISE.             *   FILE 656\n//*     SUBSYS   - FIND ALL SUBSYSTEMS KNOWN TO MVS. FROM WWW.      *   FILE 656\n//*     SUICIDE  - KILL THE SESSION. ANOTHER VARIANT.               *   FILE 656\n//*     SWID     - CHANGE JOB CHAR AND NOTIFY.                      *   FILE 656\n//*     TBV      - CREATE ISPF TABLE VIEW DYNAMICALLY. FROM         *   FILE 656\n//*                WWW.                                             *   FILE 656\n//*     TBVIEW   - CREATE ISPF TABLE VIEW DYNAMICALLY. FROM         *   FILE 656\n//*                WWW.                                             *   FILE 656\n//*     TBVWPNL  - CREATE ISPF TABLE VIEW DYNAMICALLY. FROM         *   FILE 656\n//*                WWW.                                             *   FILE 656\n//*     TESTBAR  - PROGRESS METER.                                  *   FILE 656\n//*     THINK    - HOW MUCH TIME AN EXEC HAS TAKEN?                 *   FILE 656\n//*     TIDYUP   - CLEAN SUPERC OUTPUT AND GET ONLY MEMBERS.        *   FILE 656\n//*     TOVIEW   - SWITCH TO VIEW OR BROWSE MODE.                   *   FILE 656\n//*     UCOM     - UNCOMMENT JCL OR COBOL SOURCE.                   *   FILE 656\n//*     UCOMSQL  - UNCOMMENT SQL.                                   *   FILE 656\n//*     UNAME    - USER NAME FROM DATA AREA.                        *   FILE 656\n//*     USERNAME - USER NAME FROM DATA AREA.                        *   FILE 656\n//*     UTILPNL  - PANEL FOR UTILSTAT.                              *   FILE 656\n//*     UTILSTAT - SHOW RUNNING DB2 UTILITIES.                      *   FILE 656\n//*     VB       - VSAM BROWSE.                                     *   FILE 656\n//*     VBKEY    - VSAM BROWSE WITH KEY.                            *   FILE 656\n//*     WAIT     - WAIT VIA SYSCALL. A VARIANT.                     *   FILE 656\n//*     WHOPDS   - EXAMPLE TO GET PDS NAME AND MEMBER DDNAME        *   FILE 656\n//*                UNDER EDIT.                                      *   FILE 656\n//*     WILDEL   - WILD DELETE.                                     *   FILE 656\n//*     XCOPY    - JCL CREATOR FOR MASSCOPY. CLONE OF MASSCOPY.     *   FILE 656\n//*     YESNOPNL - USED IN QD. CONFIRMATION PANEL. REUSABLE IF      *   FILE 656\n//*                ZWINTTL PASSED.                                  *   FILE 656\n//*     ZAPPDS   - DELETE ALL MEMBERS OF A PDS.                     *   FILE 656\n//*     ZAPSHELL - CLEARS TSO COMMANDS IN OPTION 6.                 *   FILE 656\n//*                                                                 *   FILE 656\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ALT": {"ttr": 531, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x02\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00\\x0c\\x00\\x0c\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:02", "lines": 12, "newlines": 12, "modlines": 0, "user": "KANNAN"}, "text": "/* Rexx Alt                                                           */\n/* .................................................................. */\n/* Author  : Kannan AK                                                */\n/* ALT     : Alters GDG LIMIT                                         */\n/* Notice  : Do not decrease Limits                                   */\n/* Version : Alpha                                                    */\n/* Usage   : In 3.4; ALT 45 _dataset_                                 */\n/* .................................................................. */\nARG LIMNO STR\nADDRESS TSO\n\"ALTER\" STR \"LIMIT(\"LIMNO\")\"\nEXIT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "AMBCLIST": {"ttr": 533, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x02\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x004\\x004\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:02", "lines": 52, "newlines": 52, "modlines": 0, "user": "KANNAN"}, "text": "CONTROL NOMSG NOLIST NOCONLIST NOFLUSH\n/* AUTHOR: MARK ZELDEN                                                */\nLOOP: +\nISPEXEC DISPLAY PANEL(AMBPNL)\n\nIF &LASTCC = 8 THEN DO\n  EXIT CODE(0)\nEND\n\nFREE FI(SYSLIB SYSIN SYSPRINT)\nFREE ATTRLIST(DCB1 DCB2)\nCONTROL MSG\nIF &O \u00ac= 5 THEN DO\n  IF &STR(&AMBVOL) = &STR() THEN +\n    ALLOC FI(SYSLIB) DA(&AMBDSN) SHR\n  ELSE +\n    ALLOC FI(SYSLIB) DA(&AMBDSN) VOLUME(&AMBVOL) SHR\nEND\nSET &CC = &LASTCC\nCONTROL NOMSG\nIF &CC NE 0 THEN GOTO LOOP\nATTRIB DCB1 RECFM(F) LRECL(80) BLKSIZE(80)\nATTRIB DCB2 RECFM(F) LRECL(121) BLKSIZE(5687)\nALLOC FILE(SYSIN) UNIT(VIO) SP(1,1) TRACK US(DCB1)\nALLOC FILE(SYSPRINT) UNIT(VIO) SP(5,5) TRACK US(DCB2)\nOPENFILE SYSIN OUTPUT\nIF &O = 1 THEN DO\n  SET &SYSIN=&STR( LISTIDR MEMBER=&AMBMEM)\nEND\nIF &O = 2 THEN DO\n  SET &SYSIN=&STR( LISTLOAD OUTPUT=XREF,MEMBER=&AMBMEM)\nEND\nIF &O = 3 THEN DO\n  SET &SYSIN=&STR( LISTLOAD MEMBER=&AMBMEM)\nEND\nIF &O = 4 THEN DO\n  SET &SYSIN=&STR( LISTOBJ MEMBER=&AMBMEM)\nEND\nIF &O = 5 THEN DO\n  SET &SYSIN=&STR( LISTLPA)\nEND\nPUTFILE SYSIN\nCLOSFILE SYSIN\nCALL 'SYS1.LINKLIB(AMBLIST)'\nISPEXEC LMINIT DATAID(AMBROWSE) DDNAME(SYSPRINT)\nISPEXEC BROWSE DATAID(&AMBROWSE)\nISPEXEC LMFREE DATAID(&AMBROWSE)\nFREE FI(SYSLIB SYSIN SYSPRINT)\nFREE ATTRLIST(DCB1 DCB2)\nALLOC FI(SYSPRINT) DA(*)\n\nGOTO LOOP\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "AMBPNL": {"ttr": 769, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x02\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00)\\x00)\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:02", "lines": 41, "newlines": 41, "modlines": 0, "user": "KANNAN"}, "text": ")ATTR\n      + TYPE(TEXT)  INTENS(LOW)\n      % TYPE(TEXT)  INTENS(HIGH)\n      _ TYPE(INPUT) INTENS(HIGH)\n)BODY EXPAND (//)\n%-/-/ INTERACTIVE AMBLIST  -/-/\n%COMMAND ===>_ZCMD                                                     +\n+\n+\n+    VALID OPTIONS:\n+    1=LISTIDR  2=LISTLOAD XREF  3=LISTLOAD  4=LISTOBJ  5=LISTLPA\n+\n+    LIST OPTION  ===>_O+\n+    LIBRARY NAME ===>_AMBDSN                                      +\n+    MEMBER NAME  ===>_AMBMEM  +\n+    VOLSER       ===>_AMBVOL+\n+\n+\n+    CHOOSE AN AMBLIST OPTION. YOU MUST ENTER A LIBRARY NAME\n+    AND A MEMBER NAME WHEN USING OPTIONS 1 THROUGH 4.\n+\n+\n+\n+    PRESS%PF3+TO EXIT+\n)INIT\n  &ZPRIM = NO\n .CURSOR = O\n &O = &AMBOPT\n IF (&O = &Z )\n    &O = 1\n)PROC\n  VER (&O,NONBLANK)\n  VER (&O,LIST,1,2,3,4,5)\n  IF  (&O NE 5)\n    VER (&AMBDSN,NONBLANK)\n    VER (&AMBDSN,DSNAME)\n    VER (&AMBMEM,NONBLANK)\n    VER (&AMBMEM,NAME)\n  &AMBOPT = &O\n  VPUT (AMBDSN AMBMEM AMBOPT AMBVOL) PROFILE\n)END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "APLBOX": {"ttr": 771, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x02\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00)\\x00)\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:02", "lines": 41, "newlines": 41, "modlines": 0, "user": "KANNAN"}, "text": "/* Rexx - Generate characters for APLBox */\narg width leng\nif width < 2 | leng < 2 then return\nsqrwidth = width*leng\nboxdata = copies(' ',sqrwidth)\nsay 'Length of the string = 'sqrwidth\n/* fix vertical */\nsay 'Vertical Periphery:Left'\ndo i = width+1 to sqrwidth-width by width\n   say i\n   boxdata=overlay('e',boxdata,i)\nend\nsay 'Vertical Periphery:Right'\ndo j = width+width to sqrwidth-width by width\n   say j\n   boxdata=overlay('e',boxdata,j)\nend\n/* fix corners */\nsay 'Corners:TL,TR,BL,BR'\nboxdata=overlay('E',boxdata,1)\nboxdata=overlay('N',boxdata,width)\nboxdata=overlay('D',boxdata,sqrwidth-width+1)\nboxdata=overlay('M',boxdata,sqrwidth)\ntl = 1\ntr = width\nbr = sqrwidth\nsay tl tr sqrwidth-width+1 br\n/* fix horizontal */\nsay 'Horizontal Periphery:Top'\ndo k = 2 to width-1\n   say k\n   boxdata=overlay('s',boxdata,k)\nend\nsay 'Horizontal Periphery:Bottom'\ndo l = sqrwidth-width+2 to sqrwidth-1\n   say l\n   boxdata=overlay('s',boxdata,l)\nend\nsay 'Box Data'\nsay boxdata\nreturn\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "BATCHPDF": {"ttr": 773, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x02\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00\\xe7\\x00\\xe7\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:02", "lines": 231, "newlines": 231, "modlines": 0, "user": "KANNAN"}, "text": "/* REXX - Generate JCL to run ISPF in batch using the current        */\n/*        TSO session allocations.                                   */\n/*                                                                   */\n/*        This is an ISPF edit macro.                                */\n/*                                                                   */\n/*     Usage:  Place this in your REXX or CLIST library as           */\n/*             Member BATCHPDF.                                      */\n/*             Edit any edit session and enter BATCHPDF.             */\n/*             The edit session should then contain working JCL for  */\n/*             using ISPF in batch.  Change the job card as          */\n/*             needed and add or remove ddnames and data sets as     */\n/*             needed.                                               */\n/*                                                                   */\n/*                                                                   */\n/*     Author: Doug Nadel  http://somebody.home.mindspring.com/      */\n/*                                                                   */\n/*             I'd like to thank Gilbert Saint-Flour for the SWAREQ  */\n/*             subroutine. http://members.home.net/gsf/              */\n/*                                                                   */\n/*     Notes:  The JCL generated creates a cataloged data set for    */\n/*             Use as an ISPF profile and tables data set.  This     */\n/*             data set is used for ISPPROF, ISPTABL and ISPTABL.    */\n/*             You can add an iebcopy step before the ikjeft01       */\n/*             step if you need to copy an existing profile onto     */\n/*             that data set.  That data set is automatically        */\n/*             deleted in the end change the 'tempdsn' name if       */\n/*             needed.                                               */\n/*                                                                   */\n/*             If you have a member called jobcard in the pds you    */\n/*             are editing when you run this, it will be copied in   */\n/*             to the JCL automatically.  Otherwise a default        */\n/*             job card will be inserted.                            */\n/*                                                                   */\n/*             The JCL generated also uses a temporary CLIST.        */\n/*             Place invocation of your program there.               */\n/*                                                                   */\n/*     Version History: 1.00 Feb 10, 2000  - initial release         */\n/*     Version History: 1.01 Feb 11, 2000  - profile init step       */\n/*                                         - minor reformatting      */\n/*     Version History: 1.02 Jul 08, 2002  - added ZACCTNUM          */\n/*-------------------------------------------------------------------*/\nAddress isredit\n'MACRO'\nIf sysvar(syspref) <> '' Then\n  If sysvar(syspref) <> userid() Then\n    prefix=sysvar(syspref)'.'userid()\n  Else\n    prefix=sysvar(syspref)\nElse\n  prefix=userid()\nDo Until sysdsn(\"'\"tempdsn\"'\") <> 'OK' /* set up temp ds name        */\n  tempdsn=prefix'.T'substr(reverse(time('L')),1,6)'.ISPPROF'\nEnd\n'X ALL .ZL .ZF'                        /* exclude all                */\n'DEL ALL X'                            /* and now delete everything  */\n'CAPS OFF'                             /* insure lower case is\n                                          allowed                    */\nlineno=0\nddnames='ISPLLIB ISPPLIB ISPSLIB ISPMLIB ISPILIB'\nCall listdsi 'SYSPROC FILE'\nAddress ispexec 'CONTROL ERRORS RETURN'\n'COPY JOBCARD AFTER 0'\ncopyrc=rc\nAddress ispexec 'CONTROL ERRORS CANCEL'\n'CAPS OFF'                             /* in case copy changed caps  */\nAddress ISPEXEC 'VGET (ZACCTNUM)'\nAC = ZACCTNUM\nIf copyrc>0 Then\n  Call add '//'userid()'I JOB ('AC'),NOTIFY='userid()',MSGLEVEL=(1,1)'\n'(LINENO) = linenum .zl'               /* Start adding at top        */\n/*-------------------------------------------------------------------*/\nCall comment 'Create Startup CLIST'\nCall add '//GENER0   EXEC PGM=IEBGENER                              '\nCall add '//SYSUT1   DD *                                          '\nCall add '                          '\nCall add ' ISPEXEC VGET (ZTIMEL)       /* ISPF services can run here */'\nCall add ' WRITE &ZTIMEL            '\nCall add ' '\nCall scomment 'Add any setup here'\nCall scomment 'And start your program here.  Use ISPEXEC SELECT.'\nCall scomment ' '\nCall scomment 'To invoke the editor, code a line like:'\nCall scomment \"  ISPEXEC EDIT DATASET('FRED.CNTL(BUBBA)') MACRO(BINKY)\"\nCall scomment 'and remember that the macro must do an END or CANCEL.'\nCall add ' '\nCall add ' '\nCall scomment 'You can set the step return code if you want.'\nCall add ' SET ZISPFRC = 0          '\nCall add ' ISPEXEC VPUT (ZISPFRC) SHARED     /* set step return code */'\nCall add ' '\nCall add '//SYSUT2   DD DISP=(NEW,PASS),DSN=&&CLIST0(TEMPNAME),'\nCall add '//            SPACE=(TRK,(1,1,2),RLSE),UNIT=SYSALLDA,    '\nCall add '//            DCB=(LRECL='syslrecl',BLKSIZE=0,'||,\n  'DSORG=PO,RECFM='sysrecfm')   '\nCall add '//PROFILE  DD DISP=(NEW,CATLG),DSN='tempdsn','\nCall add '//            SPACE=(TRK,(10,10,5)),UNIT=SYSALLDA,'\nCall add '//            DCB=(LRECL=80,BLKSIZE=0,DSORG=PO,RECFM=FB) '\nCall add '//SYSPRINT DD DUMMY                                      '\nCall add '//SYSIN    DD DUMMY                                      '\n/*-------------------------------------------------------------------*/\nCall comment 'Initialize profile data set (optional)'\nCall add '//* COPY     EXEC PGM=IEBCOPY                               '\nCall add '//* SYSPRINT DD  DUMMY                                      '\nCall add '//* SYSIN    DD  DUMMY                                      '\nCall get_allocations 'ISPPROF '\nCall add '//* SYSUT1   DD  DISP=SHR,DSN='dsname.1\nCall add '//* SYSUT2   DD  DISP=(OLD,PASS),DSN=*.GENER0.PROFILE'\n/*-------------------------------------------------------------------*/\nCall comment 'Invoke ISPF'\nCall add '//BATCHPDF EXEC PGM=IKJEFT01,DYNAMNBR=128                 '\nCall insert 'STEPLIB ','STEPLIB '\nDo dds=1 to words(ddnames)\n  ddname=subword(ddnames,dds,1)\n  Call insert ddname,ddname\nEnd\nCall add '//ISPPROF  DD DISP=(OLD,PASS),DSN='tempdsn\nCall add '//ISPTABL  DD DISP=(OLD,PASS),DSN='tempdsn\nCall add '//ISPTLIB  DD DISP=(OLD,PASS),DSN='tempdsn\nCall insert 'ISPTLIB ',' '\nCall add '//ISPCTL0  DD DISP=(NEW,DELETE),SPACE=(TRK,(10,10)),UNIT=VIO,'\nCall add '//            DCB=(LRECL=80,BLKSIZE=0,DSORG=PS,RECFM=FB)  '\nCall add '//ISPCTL1  DD DISP=(NEW,DELETE),SPACE=(TRK,(10,10)),UNIT=VIO,'\nCall add '//            DCB=(LRECL=80,BLKSIZE=0,DSORG=PS,RECFM=FB)  '\nCall add '//ISPWRK1  DD DISP=(NEW,DELETE),SPACE=(TRK,(10,10)),UNIT=VIO,'\nCall add '//            DCB=(LRECL=80,BLKSIZE=0,DSORG=PS,RECFM=FB)  '\nCall add '//ISPLST1  DD DISP=(NEW,DELETE),SPACE=(TRK,(10,10)),'\nCall add '//            DCB=(LRECL=133,BLKSIZE=0,DSORG=PS,RECFM=VB)'\nCall add '//ISPLOG   DD SYSOUT=*,'\nCall add '//            DCB=(LRECL=120,BLKSIZE=2400,DSORG=PS,RECFM=FB)'\nCall add '//ISPLIST  DD SYSOUT=*,DCB=(LRECL=121,BLKSIZE=1210,RECFM=FBA)'\nCall add '//* 'copies('- ',32)\nCall add '//SYSTSPRT DD SYSOUT=*'\nCall add '//SYSTSIN  DD *'\nIf sysvar(syspref) <> '' Then\n  Call add ' PROFILE PREFIX('sysvar(syspref)')'\nElse\n  Call add ' PROFILE NOPREFIX'\nCall add ' ISPSTART CMD(%TEMPNAME) NEWAPPL(ISR)'\nCall insert 'SYSEXEC ','SYSEXEC'\nCall add '//SYSPROC  DD DSN=&&CLIST0,DISP=(OLD,DELETE)'\nCall insert 'SYSPROC ',''\nCall add '//*'copies('-',67)'*'\nCall add '//*'center(' Delete temporary profile data set ',67)'*'\nCall add '//*'copies('-',67)'*'\nCall add '//DELPROF  EXEC PGM=IEFBR14         '\nCall add '//DELETEDD DD DSN='tempdsn',DISP=(OLD,DELETE)'\n'LOCATE .ZF'\nExit 1\n/*------------------ Subroutines follow -----------------------------*/\n/*-------------------------------------------------------------------*/\nget_allocations:  Procedure Expose ddname. dsname. volume.\nNumeric digits 10                      /* Allow up to 7fffffff       */\nDrop ddname. dsname. volume.\ntiotptr=24+ptr(12+ptr(ptr(ptr(16))))   /* Get ddname array           */\ntioelngh=c2d(stg(tiotptr,1))           /* Nength of 1st entry        */\na=0\nddname=' '\nDo Until tioelngh=0                    /* Scan until dd found        */\n  tioeddnm=strip(stg(tiotptr+4,8))     /* Get ddname from tiot       */\n  If substr(tioeddnm,1,1) <>'00'x Then\n    Do\n      If substr(tioeddnm,1,1) <>\" \" Then\n        ddname=tioeddnm\n      If ddname=Arg(1) Then\n        Do\n          a=a+1\n          ddname.a=ddname\n          tioelngh=c2d(stg(tiotptr,1)) /* Length of next entry       */\n          tioejfcb=stg(tiotptr+12,3)\n          jfcb=swareq(tioejfcb)        /* Convert sva to 31-Bit addr */\n          dsname.a=strip(stg(jfcb,44)) /* Dsname jfcbdsnm            */\n          volume.a=storage(d2x(jfcb+118),6)/* Volser jfcbvols (Not\n                                          used)                      */\n        End\n    End\n  tiotptr=tiotptr+tioelngh             /* Get next entry             */\n  tioelngh=c2d(stg(tiotptr,1))         /* Get entry length           */\nEnd\nddname.0=a\nReturn\n/*-------------------------------------------------------------------*/\nptr:  Return c2d(storage(d2x(Arg(1)),4)) /* Return a pointer         */\n/*-------------------------------------------------------------------*/\nstg:  Return storage(d2x(Arg(1)),Arg(2)) /* Return storage           */\n/*-------------------------------------------------------------------*/\nswareq:  Procedure\nIf right(c2x(Arg(1)),1) \\= 'F' Then    /* SWA=BELOW ?                */\n  Return c2d(Arg(1))+16                /* YES, RETURN SVA+16         */\nsva = c2d(Arg(1))                      /* CONVERT TO DECIMAL         */\ntcb = ptr(540)                         /* TCB PSATOLD                */\njscb = ptr(tcb+180)                    /* JSCB TCBJSCB               */\nqmpl = ptr(jscb+244)                   /* QMPL JSCBQMPI              */\nqmat = ptr(qmpl+24)                    /* QMAT QMADD                 */\nDo While sva>65536\n  qmat = ptr(qmat+12)                  /* NEXT QMAT QMAT+12          */\n  sva=sva-65536                        /* 010006F -> 000006F         */\nEnd\nReturn ptr(qmat+sva+1)+16\n/*-------------------------------------------------------------------*/\nscomment:                              /* Add comments in sample     */\nCall add ' /* 'left(Arg(1),56)' */'\nReturn\n/*-------------------------------------------------------------------*/\ncomment:                               /* Add block comments         */\n/* Add comments in sample                                            */\nCall add '//*'copies('-',67)'*'\nCall add '//*'center(' 'Arg(1)' ',67)'*'\nCall add '//*'copies('-',67)'*'\nReturn\n/*-------------------------------------------------------------------*/\nadd:                                   /* Add lines to the JCL       */\nParse Arg line\n'LINE_AFTER 'lineno' = (LINE)'\nlineno=lineno+1\nReturn\n/*-------------------------------------------------------------------*/\ninsert:  Procedure Expose ddname. dsname. lineno\nddname=Arg(2)\nCall get_allocations Arg(1)\nIf ddname.0>0 Then\n  Do a = 1 to ddname.0\n    line= '//'left(ddname,9)'DD DISP=SHR,DSN='dsname.a\n    If length(line)<63 Then\n      line=substr(line,1,63)||volume.a;else\n    If length(line)<65 Then\n      line=line volume.a\n    Call add line\n    ddname=''\n  End\nReturn\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "BATCHSMS": {"ttr": 778, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x02\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00{\\x00{\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:02", "lines": 123, "newlines": 123, "modlines": 0, "user": "KANNAN"}, "text": "/* REXX BATCHSMS                                                      */\n/* .................................................................. */\n/* Author  : Kannan AK                                                */\n/* BATCHSMS: Force change MGMTCLAS                                    */\n/* Notice  : None                                                     */\n/* Version : Beta                                                     */\n/* .................................................................. */\narg hlq opt\n      if opt \\= 'ALTER' then do\n         say \"Option unknown.\"\n         say \"Syntax : BATCHSMS (_userid_) (ALTER)\"\n         exit 12\n      end\nsms1    = 'SAMPLE1'\nsms2    = 'SAMPLE2'\nsms3    = 'SAMPLE3'\ncn      = 0\nif opt = 'ALTER' then do\n   call BuildJobCard\n   call BuildJCL\nend\ncall GetHList\n\ndo k=6 by 1 while k <= hline.0\n  if pos(hlq,hline.k) > 0 then do\n    if pos('CMTLIB',hline.k)  > 0 then iterate\n    if pos('ISPF',hline.k)    > 0 then iterate\n    if pos('SPFLOG',hline.k)  > 0 then iterate\n    if pos('USERLOG',hline.k) > 0 then iterate\n    if pos('TERMLOG',hline.k) > 0 then iterate\n    parse value hline.k with dsname . . . . . . dsorg .\n    if dsorg = 'PS' then do\n       call SMS\n    end\n  end\nend\n\nif opt = 'ALTER' then do\n   call GoJCL\nend\n\nqui :\nexit 0\n\nSMS :\nstr = \"'\" || dsname || \"'\"\naddress ispexec\nf = OUTTRAP('OUTL.','*','NOCONCAT')\naddress tso \"LISTCAT ENTRIES(\"str\") ALL\"\nf = OUTTRAP(OFF)\n       if RC > 0 then do\n          ZEDSMSG = '*Obtain Failed*'\n          \"ISPEXEC SETMSG MSG(ISRZ000)\"\n          exit 0\n       end\nif pos('$IAM',outl.4) > 0  then\n   say dsname IAM\n\ndo i=1 by 1 while i <= outl.trapped\n\n  if pos('MANAGEMENTCLAS',outl.i) > 0  then do\n       mgmtclas = outl.i\n       TTAB  = \"-()\"\n       mgmtclas = TRANSLATE(mgmtclas,\" \",TTAB)\n       parse value mgmtclas with m1 m2 m3 m4\n       mgmtclas = m4\n  end\nend\nif mgmtclas \\= sms1 & mgmtclas \\= sms2 & mgmtclas \\= sms3 then do\n   if opt = '' then do\n      say left(dsname,60)  || left((strip(mgmtclas)),8)\n   end\n   else do\n      if opt = 'ALTER' then do\n        cn = cn + 1\n        say left(cn,5) || ,\n            left(dsname,46)  || ,\n            left(strip(mgmtclas),10) || ,\n            left(strip(dsorg),4)\n        queue \"  ALTER \" || ,\n                left(dsname,45)  || ,\n                \"MGMTCLAS(\" || ,\n               'SAMPLECL'|| ') '\n      end\n   end\nend\nreturn\n\nGetHList :\nd = date(j)\nt = time();parse value t with hh ':' mm ':' ss;tt=hh||mm||ss\nhlistdsn = \"'\"||userid()||\".HLIST\"||'.t'tt||'.j'd||\"'\"\nhlistdd  = 'HL'tt\naddress tso \"hlist level('\"hlq\"') ods(\"hlistdsn\")\"\naddress tso \"alloc ds(\"hlistdsn\") dd(\"hlistdd\") old reu\"\naddress tso \"execio * diskr\" hlistdd \"(stem hline. finis\"\naddress tso \"free dd(\"hlistdd\") delete\"\nreturn\n\n\nBuildJobCard :\naddress tso\ncall wj(\"//\"userid()\"$ JOB (000000),'BT:KANNAN AK',                   \")\ncall wj(\"//         CLASS=P,MSGCLASS=X,NOTIFY=&SYSUID,TYPRUN=SCAN     \")\nreturn\n\nBuildJCL :\ncall wj(\"//*---------------------------------------------------------*\")\ncall wj(\"//STEP0001 EXEC PGM=IDCAMS                                   \")\ncall wj(\"//SYSPRINT DD SYSOUT=*                                       \")\ncall wj(\"//SYSIN    DD *                                              \")\nreturn\n\nwj :\nparse arg stream\nqueue stream\nreturn\n\nGoJCL :\ncall wj(\"/*                                                           \")\naddress tso \"alloc f(fjcl) sysout writer(intrdr)\"\naddress tso \"execio\" queued()\" diskw fjcl (finis\"\nreturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "BTSO": {"ttr": 781, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x02\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00\\x14\\x00\\x14\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:02", "lines": 20, "newlines": 20, "modlines": 0, "user": "KANNAN"}, "text": "/* Rexx BTSO */\nArg cmd\nIf cmd='' Then Do;\n  Address ispexec 'SETMSG MSG(ISPG054)'\n  Exit\n  End\nq=outtrap(trap.,10000,concat)\ncmd\nq=outtrap(off)\nIf trap.0 > 0 Then\nDo\n Address ispexec 'VGET (ZSCREEN) SHARED'\n ddname='$TRAP$'zscreen\n 'ALLOC F('ddname') UNIT(VIO) DSO(PS) RECFM(V B) LRECL(255) NEW DEL REU'\n 'EXECIO 'trap.0' DISKW 'ddname' (FINIS STEM TRAP.'\n Address ispexec 'LMINIT DATAID(TRAP) DDNAME('ddname') ENQ(SHR)'\n Address ispexec 'BROWSE DATAID('trap')'\n Address ispexec 'LMFREE DATAID('trap')'\n 'FREE F('ddname')'\nEnd\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CDATE": {"ttr": 783, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x03\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00\\x85\\x00\\x85\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:03", "lines": 133, "newlines": 133, "modlines": 0, "user": "KANNAN"}, "text": "/* Rexx CDate                                                         */\n/* .................................................................. */\n/* Author  : Kannan AK                                                */\n/* CDATE   : Show date of creation                                    */\n/* Notice  : Type against GDG Base if all CDates are needed           */\n/* Version : Alpha                                                    */\n/* Usage   : 3.4                                                      */\n/* .................................................................. */\nArg Str\n h0 = copies('s',03)||'P'||copies('s',27)\n h1 = 'E'h0'sssssssssssssssssssPssssssssssssPssssssN'\n h2 = 'D'h0'sssssssssssssssssssGssssssssssssGssssssM'\n s1 = copies('#',80)\n s1 = copies('#',80)\n Address ISPEXEC \"Control Errors Return\"\n Call TestDsn\nqui :\nExit 0\n\nGetDate :\nAddress ISPEXEC\nf = OUTTRAP('OUTL.','*','NOCONCAT')\nAddresS TSO \"LISTCAT ENTRIES(\"Str\") ALL\"\nf = OUTTRAP(OFF)\n       If RC > 0 Then Do\n          ZEDSMSG = '*Obtain Failed*'\n          \"ISPEXEC SETMSG MSG(ISRZ000)\"\n          Exit 0\n       End\n\nDo i=1 BY 1 While i <= OUTL.TRAPPED\n  If Pos('CREATION',outl.i) > 0  Then Do\n       dcreated = outl.i\n       TTAB  = \"-()\"\n       dcreated = Translate(dcreated,\" \",TTAB)\n       Parse Value dcreated with m1 m2 m3 m4\n       Parse Value m4 with m1 dcreated\n       Leave\n  End\nEnd\nCall j2s Strip(dcreated)\nZEDSMSG = RESULT\n\"ISPEXEC SETMSG MSG(ISRZ000)\"\nReturn RESULT\n\nTestDsn :\ng = OUTTRAP('DSN.','*','NOCONCAT')\nx = listdsi(\"\"Str\"\" directory norecall)\ng = OUTTRAP(OFF)\nIf sysreason = 8 Then Do\n   ZEDSMSG = '*Not on DASD*'\n   \"ISPEXEC SETMSG MSG(ISRZ000)\"\n   Exit 0\nEnd\nIf sysreason = 5 Then Do\n   ZEDSMSG = '*GDGBASE*'\n   \"ISPEXEC SETMSG MSG(ISRZ000)\"\n   Call ProcessGDG\n   Exit 0\nEnd\nCall GetDate\nreturn\n\nProcessGDG :\nh = OUTTRAP('GDG.','*','NOCONCAT')\nAddresS TSO \"LISTC ENTRIES(\"Str\") GDG ALL\"\nh = OUTTRAP(OFF)\n       If RC > 0 Then Do\n          ZEDSMSG = '*Obtain Failed*'\n          \"ISPEXEC SETMSG MSG(ISRZ000)\"\n          Exit 0\n       End\nCall TBinit\nCall TBcreate\nDo J=1 BY 1 while J <= GDG.TRAPPED\n  If pos('NONVSAM',GDG.j) > 0  Then Do\n       parse value GDG.j with 'NONVSAM--' Str\n       stq = Str\n       Str = \"'\" || Str || \"'\"\n       Call GetDate\n       TTStr = stq\n       TTCDATE = RESULT\n       STAR = ' '\n       Address ISPEXEC \"TBMOD QLP ORDER\"\n  End\nEnd\nAddress ISPEXEC \"TBTOP QLP\"\nDo Forever Until RC >= 8\n   Address ISPEXEC \"TBDISPL QLP PANEL(CDATEPNL)\"\n   If RC > 4 Then Leave\n   Call TBservice\nEnd\nAddress ISPEXEC \"TBEND QLP\"\nReturn\n\nTBcreate :\n   Address ISPEXEC 'TBOPEN QLP'                             /* exist? */\n   If RC = 8 Then Do\n      Nop                                         /* well, do nothing */\n   End\n   Else Do\n      Address ISPEXEC 'TBEND QLP'              /* send to recycle bin */\n   End\n                                                       /* create anew */\n   Address ISPEXEC \"TBCREATE QLP KEYS(TTSTR) ,\n                                 NAMES(TTCDATE, STAR)\"\nReturn\n\nTBinit :\nMESSAGE = 'MSG()'\nCURSOR  = 'CURSOR()'\nCSRROW  = 'CSRROW(1)'\nRETCODE = 0\nReturn\n\nTBservice :\n        If L = 'H' Then Do\n           HRSTR = \"'\" || TTSTR || \"'\"\n           Address TSO \"HRECALL \" HRSTR\n           STAR = '*'\n           L = ''\n           Address ISPEXEC 'TBMOD   QLP ORDER'\n           Address ISPEXEC 'TBDISPL QLP'\n           If RC > 4 Then Leave\n        End\n        Else Do\n           Zerrsm=''\n           Zerrhm='*'\n           Zerrlm='Use H for recalling datasets.'\n           Zerralrm='NO'\n           Address ISPEXEC 'SETMSG MSG(ISRZ003)'\n        End\nReturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CDATEPNL": {"ttr": 1027, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x03\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00\\x15\\x00\\x15\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:03", "lines": 21, "newlines": 21, "modlines": 0, "user": "KANNAN"}, "text": ")Attr\n! TYPE(CH     ) GE(ON     )\n* AREA(DYNAMIC) SCROLL(OFF) EXTEND(OFF)\n# TYPE(CHAR   ) COLOR(TURQ) GE(ON     )\n@ TYPE(OUTPUT ) COLOR(TURQ)\n} TYPE(NT     )\n_ TYPE(INPUT  ) CAPS(ON)\n)Body  expand(//)\n%-/-/-  Creation Date Discovery  -/-/-\n%Command ===>_ZCMD                                  / / %Scroll ===>_AMT +\n+\n}     C   Dataset                                        Created on   HREC +\n    *h1,s1                                                                 *\n)Model\n   !|_L!|@TTSTR                                       !|@TTCDATE   !|@STAR!|\n)Init\n&L = ''\n)Reinit\n  IF (&STAR = '*')\n    .ATTRCHAR('@') = 'COLOR(PINK)'\n)End\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CE": {"ttr": 1029, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x03\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x01=\\x01=\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:03", "lines": 317, "newlines": 317, "modlines": 0, "user": "KANNAN"}, "text": "/* Rexx CE                                                            */\n/* .................................................................. */\n/* Author  : Kannan AK                                                */\n/* CE      : Custom Editor and Functions                              */\n/* Notice  : None                                                     */\n/* Version : Crazy...optimizable                                      */\n/* .................................................................. */\nAddress TSO \"Profile Prefix(\"Userid()\")\"                /* Set Prefix */\nAddress TSO \"Sitecmds Quiet\"             /* Get USER Commands onboard */\nCEFPNL = 'MAIN'                                     /* Set Panel Name */\nDYE = 'YELLOW'                                  /* Dynamic Color Attr */\nWildcard = 0                                   /* PDS Wildcard Toggle */\nAddress ISPEXEC\n\"Control Errors Return\"\n\"VGET (ZSYSID) SHARED\"\nSYSWHAT = ZSYSID\n\"VGET (DBET)\"                                  /* Get DB2 Test Subsys */\nDSNS = DBET\nIVIEW   = 'ATTRIB'                          /* Initial View on DSLIST */\nRC = 0\nJul = Julian || '.' || Date(d)\nDat = Date( );\nCost = ''\nCurrpds = Userid()'.HANNA.EXEC'                 /* Where this EXEC is */\nCall Populate_Refdd\n\nRedo :\nCall CostSession                              /* What has been spent? */\nCost = Result\n\nInit :\n     Pre = SYSVAR(SYSPREF)\n     A='';B='';C='';D='';E='';F='';G='';\n     H='';I='';J='';K='';L='';M='';N='';\n     P='';Q='';R='';S='';T='';U='';\n     V='';W='';X='';Z='';OVR='';ME='';STR='';HLQ=Pre;\n     HI=Pre;MI='';LO='';OP = '(';CP = ')'; DOT = '.';\n     DS1='';DS2='';DS3='';DS4='';DS5='';DS6='';DS7='';DS8='';DS9='';\n     DSA='';DSB='';\n     SHELL    = 'Shell'\n     HISTORY  = 'History'\n     LAST30   = 'Last30'\n     IMAGEJCL = 'IMAGEJCL'\n     RESERVED = 'RESERVED'\n     COPYPEND = 'COPYPEND'\n     UTILITY  = 'UTILITY'\n     ISRDDN   = 'ISRDDN'\n     Change   = 'Change'\n     UTILID   = '*'\n     STATUS   = 'Status'\n     Tim = Time();Parse Value T With HH ':' MM ':' SS;TT=HH||MM||SS\n     If Pre = '' Then Do\n            ZEDSMSG = \"=CE Closure=\"\n            ZEDLMSG = \" TSO Prefix Not Found - Please Set Up \"\n            \"ISPEXEC SETMSG MSG(ISRZ001)\" ; Exit\n     End\n\nDisp :\n     Address ISPEXEC\n     'Display Panel ('CEFPNL')'\n     If RC = 8 Then Do\n        ZEDSMSG = \"=CE Closure=\"\n        \"ISPEXEC SETMSG MSG(ISRZ001)\" ; Exit\n     End\n     Call PutPool\n\nParse :\n      If Wildcard Then ME = '*' || ME || '*'\n      If Y \\= ' ' | CNAME = 'Y' Then Do\n            NAME = 'CMDPROC.CLIST'\n            Call EditService\n      End\n      Upper O\n      If O \\= ' ' & O \\= 'E' & O \\= 'B' Then Do\n            ZEDSMSG = \"Invalid Option\"\n            \"ISPEXEC SETMSG MSG(ISRZ001)\"\n      End                                             /*blank brakets*/\n      If ME = '' Then Do\n            OP = '';CP = '';\n      End\n      If  Translate(CNAME) = 'CHANGE' Then Do         /*edit me....*/\n            NAME = \"'\"||Userid()\".HANNA.EXEC\"||'('||CE||')'||\"'\"\n            Call EditService\n      End\n\n      If OVR \\= ' ' Then Do\n            NAME = \"'\"||OVR||OP||ME||CP||\"'\"\n            Call EditService\n      End\n      If Pos('DS',CNAME) > 0 & CNAME \\= 'DSNLVL' Then Do\n         \"SELECT CMD(%REFDD \"CNAME O\")\"\n      End\n\nSelect\n      When A \\= ' ' | CNAME = 'A' Then\n            NAME = 'HANNA.CNTL'||OP||ME||CP\n      When B \\= ' ' | CNAME = 'B' Then\n            NAME = 'HANNA.EXEC'||OP||ME||CP\n      When C \\= ' ' | CNAME = 'C' Then\n            NAME = 'HANNA.SQL'||OP||ME||CP\n      When D \\= ' ' | CNAME = 'D' Then\n            NAME = 'HANNA.BOOK'||OP||ME||CP\n      When E \\= ' ' | CNAME = 'E' Then\n            NAME = 'HANNA.SRCH'||OP||ME||CP\n      When F \\= ' ' | CNAME = 'F' Then\n            NAME = 'HANNA.SQLFA'||OP||ME||CP\n      When G \\= ' ' | CNAME = 'G' Then\n            NAME = 'HANNA.FAPARM'||OP||ME||CP\n      When H \\= ' ' | CNAME = 'H' Then\n            NAME = 'HANNA.SORT'||OP||ME||CP\n      When I \\= ' '| CNAME = 'I' Then\n            NAME = 'HANNA.LOADLIB'||OP||ME||CP\n      When J \\= ' ' | CNAME = 'J' Then\n            NAME = 'HANNA.EZT'||OP||ME||CP\n      When L \\= ' ' | CNAME = 'L' Then\n            NAME = \"'\"||Currpds||\"'\"\n      When N \\= ' ' | CNAME = 'N' Then\n            NAME = \"'\"||TEST.TEST.TEST||OP||ME||CP||\"'\"\n      When P \\= ' ' | CNAME = 'P' Then\n            NAME = \"'\"||TEST.TEST.TEST||OP||ME||CP||\"'\"\n      When Q \\= ' ' | CNAME = 'Q' Then\n            NAME = \"'\"||TEST.TEST.TEST||OP||ME||CP||\"'\"\n      When R \\= ' ' | CNAME = 'R' Then\n            NAME = \"'\"||TEST.TEST.TEST||OP||ME||CP||\"'\"\n      When S \\= ' ' | CNAME = 'S' Then\n            NAME = \"'\"||TEST.TEST.TEST||OP||ME||CP||\"'\"\n      When T \\= ' ' | CNAME = 'T' Then\n            NAME = \"'\"||TEST.TEST.TEST||OP||ME||CP||\"'\"\n      When U \\= ' ' | CNAME = 'U' Then\n            NAME = \"'\"||TEST.TEST.TEST||OP||ME||CP||\"'\"\n      When V \\= ' ' | CNAME = 'V' Then\n            NAME = \"'\"||TEST.TEST.TEST||OP||ME||CP||\"'\"\n      When W \\= ' ' | CNAME = 'W' Then\n            NAME = \"'\"||TEST.TEST.TEST||OP||ME||CP||\"'\"\n      When X \\= ' ' | CNAME = 'X' Then\n            NAME = \"'\"||TEST.TEST.TEST||OP||ME||CP||\"'\"\n      When N \\= ' ' | CNAME = 'N' Then\n            NAME = \"'\"||TEST.TEST.TEST||OP||ME||CP||\"'\"\n      Otherwise Name = ''\nEnd\nCall EditService\nIf HI \\= ' ' & MI \\= ' '&  LO \\= ' ' Then Do\n   NAME = \"'\"||HI||DOT||MI||DOT||LO||\"'\"\n   If Wildcard Then ME = '*' || ME || '*'\n      NAME = \"'\"||HI||DOT||MI||DOT||LO||OP||ME||CP||\"'\"\n   Call EditService\n   Signal Redo\nEnd\n\nIF K \\= ' ' | CNAME = 'K' Then Do\n   ZEDSMSG = \"Not Installed\"\n   \"ISPEXEC SETMSG MSG(ISRZ000)\"\n   Signal Redo\nEnd\n                                         /* PDS Refer Utility - Link */\nIf DS1 = 'UPD' |,\n   DS2 = 'UPD' |,\n   DS3 = 'UPD' |,\n   DS4 = 'UPD' |,\n   DS5 = 'UPD' |,\n   DS6 = 'UPD' |,\n   DS7 = 'UPD' |,\n   DS8 = 'UPD' |,\n   DS9 = 'UPD' |,\n   DSA = 'UPD' |,\n   DSB = 'UPD' Then Call Update_Refdd\n                                                       /* Functions */\nSelect\n  When ZCMD  = 'PAD'      Then \"SELECT CMD(%PAD)\"\n  When CNAME = 'HISTORY'  Then \"SELECT CMD(%HIST)\"\n  When CNAME = 'LAST30'   Then \"SELECT PGM(ISRDSLST) PARM(PL2) SUSPEND\"\n  When CNAME = 'IMAGEJCL' Then \"SELECT CMD(%IMAGEJCL)\"\n  When CNAME = 'RESERVED' Then Do\n       ZEDSMSG = \"Not Installed\"\n       \"ISPEXEC SETMSG MSG(ISRZ000)\"\n  End\n  When CNAME = 'UTILITY'  Then \"SELECT CMD(%DISPUTIL)\"\n  When CNAME = 'COPYPEnd' Then \"SELECT CMD(%DISPPEnd)\"\n  When CNAME = 'ISRDDN'   Then \"SELECT CMD(ISRDDN)\"\n  When CNAME = 'SHELL'    Then \"SELECT PGM(ISRRCL) PARM(C1) SUSPEND\"\n  When CNAME = 'STATUS'   Then \"SELECT PGM(ISPSAM) PARM(POP)\"\n  When CNAME = 'DSNLVL'   Then \"SELECT CMD(%Dir \"strip(DSNLVL) IVIEW\")\"\n  When CNAME = 'DSNS'|CNAME = 'UTILID' Then\n              \"SELECT CMD(%UTILSTAT \"DSNS UTILID\")\"\n  When CNAME = 'IVIEW'    Then Do\n               Address ISPEXEC \"ADDPOP Poploc(IVIEW)\"\n               'Display Panel ('DIRPNL')'\n               IVIEW = CNAME\n               \"REMPOP\"\n       End\n  When CNAME = 'SYSWHAT'  Then Do\n               Address TSO \"SITECMDS\"\n               DYE = 'TURQ'\n       End\n  Otherwise Nop\nEnd\nIf ZCMD  = '*'   Then Wildcard = 1\nIf ZCMD  = '**'  Then Wildcard = 0\nIf Wildcard = 1  Then WIATTR   = 'BLINK'\nIf Wildcard = 0  Then WIATTR   = ''\nIF ZCMD = 'L' Then Do                                        /* Last */\n   Call GetPool\n   Signal Disp                                            /* refresh */\nEnd\nZCMD = ''                                          /*reset variables */\nSignal Redo\nExit\n\n/*-------------------------------------------------------------------*/\n/*                       LIBRARY SERVICES                            */\n/*-------------------------------------------------------------------*/\nDsnOK :\nAVAIL = SYSDSN(NAME)\nIF AVAIL \\= \"OK\" Then Do\n       If LENGTH(AVAIL) < 30 Then ZEDSMSG = AVAIL\n       Else                       ZEDLMSG = AVAIL\n       \"ISPEXEC SETMSG MSG(ISRZ001)\";SIGNAL Redo\nEnd\nReturn\n\nPopulate_Refdd :\nAddress TSO\n   PDSN =\"'\"||Userid()\".hanna.refdd\"||\"'\"\n   NAME = PDSN\n   Call DsnOK\n   \"ALLOC DS(\"PDSN\") DD(IODD) SHR REUSE\"\n   If RC \\= 0 Then Do\n       \"ISPEXEC SETMSG MSG(ISRZ002)\" ;Exit\n   End\nREFBUF. = ''\n\"EXECIO *  DISKR IODD (stem REFBUF. FINIS\"\nIF RC \\= 0 Then Do\n       \"ISPEXEC SETMSG MSG(ISRZ002)\" ;Exit\nEnd\nRF1 = REFBUF.1\nRF2 = REFBUF.2\nRF3 = REFBUF.3\nRF4 = REFBUF.4\nRF5 = REFBUF.5\nRF6 = REFBUF.6\nRF7 = REFBUF.7\nRF8 = REFBUF.8\nRF9 = REFBUF.9\nRFA = REFBUF.10\nRFB = REFBUF.11\nNAME = ''\nReturn\n\nUpdate_Refdd :\nAddress TSO\n      REFBUF.1  = RF1\n      REFBUF.2  = RF2\n      REFBUF.3  = RF3\n      REFBUF.4  = RF4\n      REFBUF.5  = RF5\n      REFBUF.6  = RF6\n      REFBUF.7  = RF7\n      REFBUF.8  = RF8\n      REFBUF.9  = RF9\n      REFBUF.10 = RFA\n      REFBUF.11 = RFB\n\"EXECIO *  DISKW IODD (stem REFBUF. FINIS\"\nIf RC \\= 0 Then Do\n       \"ISPEXEC SETMSG MSG(ISRZ002)\" ;Exit\nEnd\nElse Do\n       ZEDSMSG = \"List was refreshed.\"\n       \"ISPEXEC SETMSG MSG(ISRZ000)\"\nEnd\nReturn\n\nPutPool :\nIF LENGTH(OVR) > 0 Then\n    \"VPUT (OVR) \"\nIF LENGTH(MI) > 0  Then\n    \"VPUT (MI) \"\nIF LENGTH(ME) > 0  Then\n    \"VPUT (ME) \"\nIF LENGTH(LO) > 0  Then\n    \"VPUT (LO) \"\nIF LENGTH(STR) > 0 Then\n    \"VPUT (STR) \"\nIF LENGTH(HI) > 0  Then\n    \"VPUT (HI) \"\nIF LENGTH(DSNLVL) > 0  Then\n    \"VPUT (DSNLVL) \"\nReturn\n\nGetPool :\n    \"VGET (OVR)   \"\n    \"VGET (MI)    \"\n    \"VGET (LO)    \"\n    \"VGET (ME)    \"\n    \"VGET (STR)   \"\n    \"VGET (HI)    \"\n    \"VGET (DSNLVL)\"\nZCMD = ''\nReturn\n\nCostSession :\ncpu = sysvar(syscpu)                        /* get cpu time          */\nhour = substr(time(),1,2)                   /* get hour of the day   */\nIf (hour > 16) | (hour < 8)                 /* prime or non-prime?   */\n  Then cost = .07                           /* non-prime cost factor */\n  Else cost = .13944444                     /* prime cost factor     */\nResult = '$'strip(format(3.2*cpu*cost,4,2))\nReturn Result\n\nEditService :\nIf Name = '' Then Return\nIf O = ' ' | O = 'E' Then\n   \"ISPEXEC EDIT DATASET(\"NAME\")\"\nIf O = 'B' Then\n   \"ISPEXEC BROWSE DATASET(\"NAME\")\"\nIf RC > 4 Then\n   \"ISPEXEC SETMSG MSG(ISRZ002)\"\nReturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CHANGE": {"ttr": 1035, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x03\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00\\x1b\\x00\\x1b\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:03", "lines": 27, "newlines": 27, "modlines": 0, "user": "KANNAN"}, "text": "/* rexx change */\n\n            /*target old  new                  result       */\ncall change '--??--' '??' '*'     ;say result /* --*--      */\ncall change '--??--' '??' '**'    ;say result /* --**--     */\ncall change '--??--' '??' '***'   ;say result /* --***--    */\ncall change '--??--' '?'  '*'     ;say result /* --*?--     */\ncall change '--??--' '?'  '**'    ;say result /* --**?--    */\ncall change '--??--' '?'  '***'   ;say result /* --***?--   */\ncall change '--??--' '???'  '***' ;say result /* error      */\ncall change '--?? -' '??' '*'     ;say result /* unexpected */\n                                              /* space interleaved */\nexit\n\nchange :\narg target oldstr newstr\nif pos(oldstr,target) = 0 then return 'ERROR'\n\nif length(oldstr) >= length(newstr) then\ntarget = space(overlay(newstr,target,pos(oldstr,target),length(oldstr)),0)\n\nif length(oldstr) < length(newstr) then\ntarget = substr(target,1,pos(oldstr,target)-1) || newstr || ,\n         substr(target,pos(oldstr,target)+length(oldstr))\n\nreturn target\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CHECKVOL": {"ttr": 1037, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x03\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00\\x0e\\x00\\x0e\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:03", "lines": 14, "newlines": 14, "modlines": 0, "user": "KANNAN"}, "text": "/* Rexx CheckVol - Only DASD                                          */\n/* Assumption : Prevailing convention of sys1.vtocix.volser           */\nArg volser .\nAddress ISPEXEC \"Control errors return\"\nCall Msg(OFF)\ndsname = 'SYS1.VTOCIX.'volser\nddname = '$'||random(100,499)||random(500,999)||'$'\n\"alloc file(\"ddname\") dataset('\"dsname\"') volume(\"volser\") shr reu\"\nCall Listdsi(ddname 'file')\nIf rc = 0 Then Say 'Volume' volser ' is present'\nElse           Say volser 'is not present'\nCall Msg(ON)\n\"free file(\"ddname\")\"\nReturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "COLADD": {"ttr": 1039, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x03\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x01G\\x01G\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:03", "lines": 327, "newlines": 327, "modlines": 0, "user": "KANNAN"}, "text": "/* REXX */\n/*                                       */\n/* AUTHOR: Mark Zelden                   */\n/*                                       */\n/*********************************************************************/\n/*                                                                   */\n/* This EDIT macro totals numbers in a specified column range.       */\n/* An optional parameter of \"HEX\", \"ZONE\", \"PACK\", or \"BIN\" is       */\n/* needed to add hexadecimal, zoned decimal, packed decimal, or      */\n/* binary data. \"DEC\" is the default addition type.                  */\n/*                                                                   */\n/* Hexadecimal numbers to be added may be represented with or        */\n/* without an \"X\". In other words, x'1E' and 1E can both be          */\n/* processed and are treated the same.                               */\n/*                                                                   */\n/* The result is displayed as an ISPF short message in the top       */\n/* right hand corner in the same format as the addition type         */\n/* (decimal or hexadecimal). If extended help is chosen after        */\n/* the result is displayed (normally PF1), then the result is        */\n/* displayed in both decimal and hexadecimal and the average         */\n/* is also displayed.                                                */\n/*                                                                   */\n/* Line range labels can be used, and excluded lines are always      */\n/* omitted.                                                          */\n/*                                                                   */\n/*********************************************************************/\n/* COMMAND SYNTAX:                                                   */\n/*                                                                   */\n/* COLADD begcol endcol <DEC | HEX | ZONE | PACK | BIN> (.L1) (.L2)  */\n/*                    ** DEC is the default                          */\n/*                                                                   */\n/*  ** NOTE 1: If using line range labels then DEC, HEX, ZONE,       */\n/*             PACK, or BIN must be specified as the 3rd positional  */\n/*             parameter.                                            */\n/*                                                                   */\n/*  ** NOTE 2: Excluded lines are ALWAYS omitted.                    */\n/*                                                                   */\n/*  ** NOTE 3: DEC, HEX, ZONE, PACK, and BIN may be abbreviated by   */\n/*             using one or more of their characters. HEX may also   */\n/*             be abbreviated as \"X\".                                */\n/*                                                                   */\n/*********************************************************************/\n/*  EXAMPLES:                                                        */\n/*         COLADD 10 25                                              */\n/*         COLADD 33 40 HEX                                          */\n/*         COLADD 25 30 DEC .A .B                                    */\n/*         COLADD 10 29 ZONE                                         */\n/*         COLADD 10 16 PACK                                         */\n/*         COLADD 40 44 BIN                                          */\n/*         COLADD 44 57 X .FROM .TO                                  */\n/*********************************************************************/\n/* LASTUPD = '04/19/2002'    */   /* date of last update             */\n/*********************************************************************/\n/* TRACE ?R */\nAddress ISREDIT\n\"MACRO (begcol endcol type label1 label2)\"\n /* Address ISPEXEC \"CONTROL ERRORS RETURN\"  */\n/***********************************************/\n/*   VERIFY INPUT PARAMETERS                   */\n/***********************************************/\nbegcol = Translate(begcol) /* chage to upper case if alpha */\n\"(width) = DATA_WIDTH \"   /* length of line       */\nwidth = Format(width)     /* remove leading zeros */\nIf begcol = '' then do\n  zedsmsg = 'MISSING PARAMETER'\n  zedlmsg = 'A BEGINNING COLUMN NUMBER',\n            'MUST BE SPECIFIED.'\n  Address ISPEXEC \"SETMSG MSG(ISRZ001)\"  /* msg - with alarm */\n  Exit 12\nEnd\nSelect\n  When Datatype(begcol,Number) = 1 & endcol = '' then do\n    zedsmsg = 'NO ENDING COLUMN'\n    zedlmsg = 'AN ENDING COLUMN NUMBER',\n              'MUST BE SPECIFIED.'\n    Address ISPEXEC \"SETMSG MSG(ISRZ001)\"        /* msg - with alarm */\n    Exit 12\n  End /* when */\n  When Datatype(begcol,Number) <> 1 | ,\n       Datatype(endcol,Number) <> 1 then do\n    zedsmsg = 'COL NUMBER NOT NUMERIC'\n    zedlmsg = 'THE BEGINNING AND ENDING COLUMN NUMBERS',\n              'MUST BE NUMERIC.'\n    Address ISPEXEC \"SETMSG MSG(ISRZ001)\"        /* msg - with alarm */\n    Exit 12\n  End /* when */\n  When Datatype(begcol,Number) =1 & Datatype(endcol,Number) =1 then do\n    If endcol < begcol then do\n      zedsmsg = 'END COL < START COL'\n      zedlmsg = 'THE ENDING COLUMN MUST BE GREATER THAN OR',\n                'EQUAL TO THE STARTING COLUMN.'\n      Address ISPEXEC \"SETMSG MSG(ISRZ001)\"      /* msg - with alarm */\n      Exit 12\n    End\n    If type = '' then type = 'DEC'        /* default add type is DEC */\n    else do\n      type = Translate(type)              /* change to upper case    */\n      If Abbrev('DECIMAL',type,1) = 0 & ,\n         Abbrev('HEXADECIMAL',type,1) = 0 & ,\n         Abbrev('ZONE',type,1) = 0 & ,\n         Abbrev('PACK',type,1) = 0 & ,\n         Abbrev('BIN',type,1) = 0 & ,\n         type <> 'X' then do\n        zedsmsg = 'INVALID ADDITION TYPE'\n        zedlmsg = 'ADDITION TYPE MUST BE \"DEC\", \"HEX\",' ,\n                  '\"ZONE\", \"PACK\", or \"BIN\".'\n        Address ISPEXEC \"SETMSG MSG(ISRZ001)\"    /* msg - with alarm */\n        Exit 12\n      End\n    End /* else do */\n    If begcol < 1 | endcol < 1 then do\n      zedsmsg = 'INVALID COLUMN NUMBER'\n      zedlmsg = 'ALL COLUMN SPECIFICATIONS MUST BE' ,\n                'BETWEEN 1 AND' width\n      Address ISPEXEC \"SETMSG MSG(ISRZ001)\"      /* msg - with alarm */\n      Exit 12\n    End\n    If begcol > width | endcol > width then do\n      zedsmsg = 'INVALID COLUMN NUMBER'\n      zedlmsg = 'ALL COLUMN SPECIFICATIONS MUST BE' ,\n                'BETWEEN 1 AND' width\n      Address ISPEXEC \"SETMSG MSG(ISRZ001)\"      /* msg - with alarm */\n      Exit 12\n    End\n  End /* when */\nEnd /* select */\n/***********************************************/\n/*   FIND OUT IF LABELS ARE BEING USED         */\n/***********************************************/\nCall FIND_LABELS\n/***************************************************/\n/* INITIALIZE VARIABLES NEEDED IN PROCESSING LOOP  */\n/***************************************************/\nNumeric digits 15                    /* default of 9 not enough      */\ncount        = 0                     /* count of added lines         */\nnot_counted  = 0                     /* count of \"not counted\" lines */\ntotal        = 0                     /* total of numbers added       */\ntgtlen       = endcol-begcol+1       /* length of mumbers to add     */\n/*********************************************************************/\n/*   Begin column addition loop                                      */\n/*********************************************************************/\nDo until lastln = firstln-1\n  /* copy the data in the current line to variable 'data1' */\n  \"(data1) = LINE \"firstln\n  \"ISREDIT (chkexcl) = XSTATUS\" firstln\n  If chkexcl = \"NX\" then do       /* only process non-excluded lines */\n    add_data = Substr(data1,begcol,tgtlen) /* find data              */\n    If add_data = '' then do       /* no data within cols specified  */\n      warnmsg = \"'*** WARNING - NEXT LINE WAS NOT COUNTED ***'\"\n      \"ISREDIT LINE_BEFORE\" firstln \"= NOTELINE \" warnmsg\n      not_counted = not_counted + 1 /* bump up \"not counted\" counter */\n      firstln = firstln + 1        /* bump up line counter           */\n      iterate                      /* get next record                */\n    End /* if add_data = '' */\n    count = count + 1             /* add one to line count           */\n    Signal on SYNTAX /* trap errors */\n    /*****************************************************************/\n    /*   Binary data                                                 */\n    /*****************************************************************/\n    If Abbrev('BIN',type,1) <> 0 then ,          /* add bin numbers  */\n      add_data = C2d(add_data)                   /* convert to dec   */\n    /*****************************************************************/\n    /*   Packed decimal data                                         */\n    /*****************************************************************/\n    If Abbrev('PACK',type,1) <> 0 then do /* add packed dec numbers  */\n      add_data = Strip(add_data)                   /* remove blanks  */\n      add_data = C2x(add_data)                     /* convert to hex */\n      len_add_data = Length(add_data)              /* length of data */\n      sign     = Substr(add_data,len_add_data,1)   /* sign portion   */\n      If Verify(sign,'CFD') <> 0 then do           /* valid sign?    */\n        warnmsg = \"'*** ERROR - NEXT LINE HAS BAD SIGN ***'\"\n        \"ISREDIT LINE_BEFORE\" firstln \"= NOTELINE \" warnmsg\n        zedsmsg = 'CAN''T ADD LINE' firstln\n        zedlmsg = 'ERROR - THE DATA TO ADD ON LINE' firstln 'IS NOT',\n                  'VALID PACKED DECIMAL - BAD SIGN.'\n        Address ISPEXEC \"SETMSG MSG(ISRZ001)\"  /* msg - with alarm   */\n        Exit 12\n      End  /* If Verify(sign */\n      add_data = Left(add_data,len_add_data-1)     /* remove sign    */\n      If sign = 'D' then add_data = '-' || add_data /* negative num  */\n    End /* If Abbrev('PACK' */\n    /*****************************************************************/\n    /*   Zoned decimal data                                          */\n    /*****************************************************************/\n    If Abbrev('ZONE',type,1) <> 0 then do /* add zone dec. numbers   */\n      add_data = Strip(add_data)                   /* remove blanks  */\n      len_add_data = Length(add_data)              /* length of data */\n      zone     = Substr(add_data,len_add_data,1)   /* zone portion   */\n      add_data = Substr(add_data,1,len_add_data-1) /* non-zone part  */\n      If Datatype(add_data,N) <> 1 then ,          /* valid number?  */\n        call SYNTAX                        /* no, call error routine */\n      zonedtab = '0123456789ABCDEFGHIJKLMNOPQR{}'\n      If Verify(zone,zonedtab) <> 0 then do      /* valid zone?      */\n        warnmsg = \"'*** ERROR - NEXT LINE HAS BAD ZONE ***'\"\n        \"ISREDIT LINE_BEFORE\" firstln \"= NOTELINE \" warnmsg\n        zedsmsg = 'CAN''T ADD LINE' firstln\n        zedlmsg = 'ERROR - THE DATA TO ADD ON LINE' firstln 'IS NOT',\n                  'VALID ZONED DECIMAL - BAD ZONE.'\n        Address ISPEXEC \"SETMSG MSG(ISRZ001)\"  /* msg - with alarm   */\n        Exit 12\n      End  /* If Verify(zone */\n      outxtab   = '012345678912345678912345678900'\n      add_xzone = Translate(zone,outxtab,zonedtab)\n      If Verify(zone,'JKLMNOPQR}') <> 0 then ,\n        add_data  = add_data ||  add_xzone       /* concat zone      */\n      Else\n        add_data  = '-' || add_data || add_xzone /* concat zone (neg)*/\n    End  /* If Abbrev('ZONE' */\n    /*****************************************************************/\n    /*   Hexadecimal data                                            */\n    /*****************************************************************/\n    If Abbrev('HEXADECIMAL',type,1) <> 0 | ,     /* add              */\n       type = 'X' then do                        /*     hex numbers  */\n      add_data = Translate(add_data,\"\",\"xX'\") /* remove hex notation */\n      add_data = Strip(add_data)              /* remove blanks       */\n      add_data = X2d(add_data)                /* translate to dec.   */\n    End /* If Abbrev('HEXADECIMAL' */\n    /*****************************************************************/\n    /*   Decimal data                                                */\n    /*****************************************************************/\n    total = total + add_data                /* add to prev. total    */\n  End /* of chkexcl */\n  firstln = firstln + 1                     /* bump up line counter  */\nEnd /* do until   */\n/*********************************************************************/\n/*   End column addition loop                                        */\n/*********************************************************************/\nIf not_counted = 0 then do /* all lines counted */\n  endmsg = 'ISRZ000'  /* message - no alarm     */\n  endrc  = 0          /* RC=0                   */\nEnd\nElse do               /* some lines not counted */\n  endmsg = 'ISRZ001'  /* message - with alarm   */\n  endrc  = 4          /* RC=4                   */\nEnd\nIf Abbrev('HEXADECIMAL',type,1) <> 0 | type = 'X' then do\n  zedsmsg = \"Total = x'\"D2x(total)\"'\"\n  zedlmsg = \"Total = x'\"D2x(total)\"' (\"total\" decimal,\" ,\n               \"Avg =\"  Format(total / count,,5) / 1 || \").\" ,\n            count \"lines were counted (\" || ,\n            not_counted \"not counted).\"\n  Address ISPEXEC \"SETMSG MSG(\"|| endmsg ||\")\"\n  Exit endrc\nEnd /* If abbrev */\nElse do\n  total   = total / 1   /* remove trailing zeros  */\n  zedsmsg = \"Total =\" total\n  If total >= 0 & total <  999999999999999 & ,\n     total=Trunc(total,0) then ,\n    zedlmsg = \"Total =\" total \"(x'\"D2x(total)\"' hex),\" ,\n               \"Avg =\" Format(total / count,,5) / 1 || \".\" ,\n               count \"lines were counted (\" || ,\n               not_counted \"not counted).\"\n  Else ,\n    zedlmsg = \"Total =\" total \"(hex not available),\" ,\n               \"Avg =\" Format(total / count,,5) / 1 || \".\" ,\n               count \"lines were counted (\" || ,\n               not_counted \"not counted).\"\n  Address ISPEXEC \"SETMSG MSG(\"|| endmsg ||\")\"\n  Exit endrc\nEnd /* else do */\n/*********************************/\n/*  Sub-routine to find labels   */\n/*********************************/\nFIND_LABELS:\nIf label1 = '' then do\n  firstln  = 1\n  \"(lastln) = LINENUM .ZLAST\"\nEnd\nElse do\n  If label2 = '' then label2 = label1\n  firstsv = 'NOTFOUND'\n  lastsv  = 'NOTFOUND'\n  label1 = Translate(label1)\n  label2 = Translate(label2)\n  \"(saveln) = DISPLAY_LINES\"\n  \"UP MAX\"\n  Do forever\n    \"LOCATE LAB NEXT\"\n    if rc <> 0 then leave\n    \"(labline,junk) = DISPLAY_LINES\"\n    \"(lab,junk) = LABEL\" labline\n    if lab = label1 then firstsv = labline\n    if lab = label2 then lastsv  = labline\n  End\n  /*                                             */\n  /* return display lines to original position   */\n  /*                                             */\n  \"UP MAX\"\n  If saveln <> 1 then \"DOWN \" saveln  /* don't scroll if at top */\n  /*                                             */\n  If firstsv = 'NOTFOUND'  then do\n    zedsmsg = 'RANGE LABEL ERROR'\n    zedlmsg = 'THE SPECIFIED RANGE LABEL \"' || label1 '\" WAS',\n              'NOT FOUND'\n    Address ISPEXEC \"SETMSG MSG(ISRZ001)\"  /* msg - with alarm */\n    Exit 12\n  End\n  If lastsv  = 'NOTFOUND'  then do\n    zedsmsg = 'RANGE LABEL ERROR'\n    zedlmsg = 'THE SPECIFIED RANGE LABEL \"' || label2 '\" WAS',\n              'NOT FOUND'\n    Address ISPEXEC \"SETMSG MSG(ISRZ001)\"  /* msg - with alarm */\n    Exit 12\n  End\n  If firstsv > lastsv then do\n    firstln = lastsv\n    lastln  = firstsv\n  End\n  Else do\n    firstln = firstsv\n    lastln  = lastsv\n  End\nEnd\nReturn\n/*********************************/\n/*  error sub-routine            */\n/*********************************/\nSYNTAX:\nwarnmsg = \"'*** ERROR - NEXT LINE HAS BAD DATA ***'\"\n\"ISREDIT LINE_BEFORE\" firstln \"= NOTELINE \" warnmsg\nzedsmsg = 'CAN''T ADD LINE' firstln\nzedlmsg = 'ERROR - THE DATA TO ADD ON LINE' firstln 'IS NOT',\n          'VALID FOR THE ADDITION TYPE.'\nAddress ISPEXEC \"SETMSG MSG(ISRZ001)\"    /* msg - with alarm */\nExit 12\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "COM": {"ttr": 1285, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x03\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00<\\x00<\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:03", "lines": 60, "newlines": 60, "modlines": 0, "user": "KANNAN"}, "text": "/* REXX COM                                                           */\n/* .................................................................. */\n/* Author  : Kannan AK                                                */\n/* COM     : To comment JCL or COBOL                                  */\n/* Notice  : None                                                     */\n/* Version : Alpha                                                    */\n/* .................................................................. */\nADDRESS ISPEXEC\n\"ISREDIT MACRO (OPT) NOPROCESS\"\nIF RC = 20 THEN DO\n    ZEDSMSG = \"NOT A TSO COMMAND\"\n   \"SETMSG MSG(ISRZ000)\";EXIT\nEND\nOPT=STRIP(OPT,B);OPT = TRANSLATE(OPT)\nIF  (OPT \\= 'S' & OPT \\= 'O' & OPT \\= '?')  THEN\n     DO\n          ZEDSMSG = \"SPECIFY 'COM ?' FOR HELP\"\n          \"SETMSG MSG(ISRZ001)\"\n          EXIT\n     END\nIF OPT = '?' THEN DO\n  zerrtp = 'CRITICAL'\n  zerrlm   = ,\n  left(        \"  Comment Edit Macro Help                         \",80),\n  left('22'x   \"  Utility        : To comment JCL or COBOL        \",80),\n  left('22'x   \"  Syntax         : COM S/O/?                      \",80),\n  left('22'x   \"  Line Command   : J for JCL/C for COBOL          \",80),\n  left('22'x   \"  S Shifts lines being commented                  \",80),\n  left('22'x   \"  O Overlays the * inplace 3/7                    \",80)\n  zerrsm   = \"\"\n  zerrhm   = \"*\"\n  zerralrm = \"NO\"\n  \"ISPEXEC SETMSG MSG(ISRZ003)\"\n  EXIT\nEND\n\"ISREDIT PROCESS RANGE J C\"\nIF RC > 0 THEN DO\n      ZEDSMSG = \"IMPROPER LINE COMMAND\"\n      \"SETMSG MSG(ISRZ001)\"\n       EXIT\nEND\n\"ISREDIT (RANG) = RANGE_CMD\"\n\"ISREDIT (FIRST) = LINENUM .ZFRANGE\";\n\"ISREDIT (LAST) = LINENUM .ZLRANGE\" ;\nDO I = FIRST TO LAST BY 1\n     \"ISREDIT (LINEBUF) = LINE\" I\n     IF RANG = 'C' & OPT = 'S' THEN\n        LINEBUF=INSERT('*',LINEBUF,6)\n     IF RANG = 'C' & OPT = 'O' THEN\n        LINEBUF=OVERLAY('*',LINEBUF,7,1)\n     IF RANG = 'J' & OPT = 'S' THEN\n        LINEBUF=INSERT('*',LINEBUF,2)\n     IF RANG = 'J' & OPT = 'O' THEN\n        LINEBUF=OVERLAY('*',LINEBUF,3,1)\n\n     \"ISREDIT LINE\" I \" = \" '(LINEBUF)'\nEND\nZEDSMSG = (LAST-FIRST+1) \"LINE(S) COMMENTED\"\n\"SETMSG MSG(ISRZ000)\"\nEXIT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "COMPACT": {"ttr": 1287, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x03\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00`\\x00`\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:03", "lines": 96, "newlines": 96, "modlines": 0, "user": "KANNAN"}, "text": "/* Rexx                                                               */\n/* .................................................................. */\n/* Author  : Kannan AK                                                */\n/* COMPACT : tso compact \u00dddsnlvl\u00a8 \u00dd.\u00a8                                 */\n/* Notice  : Migrated datasets are excluded                           */\n/*         : space or . will default your userid as dsn level         */\n/*         : Does not augment sysextents                              */\n/* Version : Alpha                                                    */\n/* .................................................................. */\ntrace off\narg hlq\nif  hlq = '?' then signal assist\nif  hlq = ''  then hlq = userid()\nif  hlq = '.' then hlq = userid()\na = ')|/_\\|!0o..o0!|\\_/|('\nf = 1\ncall tempdsn co tempdd tempdsn\nif result = 'ERROR' then exit\naddress ispexec\nCONTROL ERRORS RETURN\nZWINTTL=' Defrag Diskfiles '\n\"vput (ZWINTTL)\"\n\"CONTROL DISPLAY LOCK\"\n\"ADDPOP COLUMN(6) ROW(3)\"\n\"DISPLAY PANEL(FRAGPNL)\"\nindx = 1\ncompact. = ''\nqueue \"*** Disk Files Compressed in the Session ***\"\nX = OUTTRAP('OUT.','*','NOCONCAT')\naddress tso \"LISTC LVL('\"hlq\"')\"\nX = OUTTRAP(OFF)\nDo I=1 by 1 while I <= OUT.TRAPPED\n  if pos('GDG BASE',out.i) > 0  then nop\n  else do\n       parse value out.i with . . dsname .\n       x = listdsi(\"'\"dsname\"'\" directory norecall)\n       if sysdsorg = 'PO' & (sysmembers > 0) then do\n          pdsout  = dsname\n          statout = 'Being compressed....'\n          fun = substr(a,f,1);ZEDSMSG = fun;\"SETMSG MSG(ISRZ000)\";f=f+1;\n          if f = 18 then f =1\n          \"CONTROL DISPLAY LOCK\"\n          \"DISPLAY PANEL(FRAGPNL)\"\n          call defragmentor\n          queue dsname\n          statout = 'Compressed!' 'Return code =' RC\n          fun = substr(a,f,1);ZEDSMSG = fun;\"SETMSG MSG(ISRZ000)\";f=f+1;\n          if f = 18 then f =1\n          \"CONTROL DISPLAY LOCK\"\n          \"DISPLAY PANEL(FRAGPNL)\"\n       end\n  end\nEnd\nqui :\ndrop compact.\n\"REMPOP\"\nqueue \"//eol\"\nqueue \"\"\naddress tso \"EXECIO * DISKW\" tempdd \"(FINIS\"\n\"ISPEXEC EDIT DATASET(\"tempdsn\")\"\naddress tso\nIF LENGTH(tempdd) > 7 THEN \"FREE DD(\"tempdd\") DELETE\"\nExit 0\n\ndefragmentor : procedure expose dsname\n  FILEN =\"'\"||dsname||\"'\"\n  address tso\n  \"ALLOC F(INPUT) DS(\"FILEN\") REUSE OLD\"\n  address ispexec\n  'LMINIT  DATAID('DATAID') DDNAME(INPUT) ENQ(EXCL)'\n  'LMCOMP  DATAID('DATAID')'\n  'LMFREE  DATAID('DATAID')'\n  return\n\nassist :\naddress ispexec\nZEDLMSG = 'Format : \"tso compact _highlevelqual_\"' || ' . to default'\n\"SETMSG MSG(ISRZ000)\"\nExit 0\n\nTEMPDSN : PROCEDURE EXPOSE CUECHAR TEMPDD TEMPDSN\nARG CUECHAR\nCUECHAR = SUBSTR(CUECHAR,1,2)\nD = DATE(J);P = SYSVAR(SYSPREF);\nR1 = RANDOM(100,999);R2 = RANDOM(100,999);\nT = TIME();PARSE VALUE T WITH HH ':' MM ':' SS;TT=HH||MM||SS\nTEMPDSN = CUECHAR||D||'.T'||R1||TRUNC(R1*R2/RANDOM()/10)||'.Z'||TT\nNT = TEMPDSN\nTEMPDD  = CUECHAR ||R2||R1\n\"ALLOC DS(\"NT\") DD(\"TEMPDD\") DSORG(PS) LRECL(80) RECFM(F) NEW KEEP\"\nIF RC \\= 0 THEN DO\n       \"ISPEXEC SETMSG MSG(ISRZ002)\"\n       RESULT = 'ERROR'\n       EXIT\nEND\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "COMREX": {"ttr": 1290, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x03\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00=\\x00=\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:03", "lines": 61, "newlines": 61, "modlines": 0, "user": "KANNAN"}, "text": "/* REXX COMREX                                                        */\n/* .................................................................. */\n/* Author  : Kannan AK                                                */\n/* COMREX  : To comment REXX                                          */\n/* Notice  : None                                                     */\n/* Version : Alpha                                                    */\n/* .................................................................. */\nADDRESS ISPEXEC\n\"ISREDIT MACRO (OPT) NOPROCESS\"\nIF RC = 20 THEN DO\n    ZEDSMSG = \"NOT A TSO COMMAND\"\n   \"SETMSG MSG(ISRZ000)\";EXIT\nEND\nOPT=STRIP(OPT,B);OPT = TRANSLATE(OPT)\nIF  (OPT \\= 'S' & OPT \\= 'O' & OPT \\= '?')  THEN\n     DO\n          ZEDSMSG = \"'COMREX ?' FOR HELP\"\n          \"SETMSG MSG(ISRZ001)\"\n          EXIT\n     END\nIF OPT = '?' THEN DO\n  zerrtp = 'CRITICAL'\n  zerrlm   = ,\n  left(        \"  Comment Edit Macro Help                         \",80),\n  left('22'x   \"  Utility        : To comment REXX                \",80),\n  left('22'x   \"  Command Format : COMREX S/O/?                   \",80),\n  left('22'x   \"  Line Command   : P                              \",80),\n  left('22'x   \"  S Shifts lines being commented                  \",80),\n  left('22'x   \"  O Overlays the /* */inplace 1/72                \",80)\n  zerrsm   = \"\"\n  zerrhm   = \"*\"\n  zerralrm = \"NO\"\n  \"ISPEXEC SETMSG MSG(ISRZ003)\"\n  EXIT\nEND\n\"ISREDIT PROCESS RANGE P\"\nIF RC > 0 THEN DO\n      ZEDSMSG = \"IMPROPER LINE COMMAND\"\n      \"SETMSG MSG(ISRZ001)\"\n       EXIT\nEND\n\"ISREDIT (RANG) = RANGE_CMD\"\n\"ISREDIT (FIRST) = LINENUM .ZFRANGE\";\n\"ISREDIT (LAST) = LINENUM .ZLRANGE\" ;\nDO I = FIRST TO LAST BY 1\n     \"ISREDIT (LINEBUF) = LINE\" I\n\n     IF RANG = 'P' & OPT = 'S' THEN DO\n        LINEBUF=INSERT('/*',LINEBUF,0,2)\n        LINEBUF=INSERT('*/',LINEBUF,70,2)\n     END\n     IF RANG = 'P' & OPT = 'O' THEN DO\n        LINEBUF=OVERLAY('/*',LINEBUF,1,2)\n        LINEBUF=OVERLAY('*/',LINEBUF,71,2)\n     END\n\n     \"ISREDIT LINE\" I \" = \" '(LINEBUF)'\nEND\nZEDSMSG = (LAST-FIRST+1) \"LINE(S) COMMENTED\"\n\"SETMSG MSG(ISRZ000)\"\nEXIT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "COMSQL": {"ttr": 1292, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x03\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00;\\x00;\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:03", "lines": 59, "newlines": 59, "modlines": 0, "user": "KANNAN"}, "text": "/* REXX COMSQL                                                        */\n/* .................................................................. */\n/* Author  : Kannan AK                                                */\n/* COMREX  : To comment SQL                                           */\n/* Notice  : None                                                     */\n/* Version : Alpha                                                    */\n/* .................................................................. */\nADDRESS ISPEXEC\n\"ISREDIT MACRO (OPT) NOPROCESS\"\nIF RC = 20 THEN DO\n    ZEDSMSG = \"NOT A TSO COMMAND\"\n   \"SETMSG MSG(ISRZ000)\";EXIT\nEND\nOPT=STRIP(OPT,B);OPT = TRANSLATE(OPT)\nIF  (OPT \\= 'S' & OPT \\= 'O' & OPT \\= '?')  THEN\n     DO\n          ZEDSMSG = \"'COMSQL ?' FOR HELP\"\n          \"SETMSG MSG(ISRZ001)\"\n          EXIT\n     END\nIF OPT = '?' THEN DO\n  zerrtp = 'CRITICAL'\n  zerrlm   = ,\n  left(        \"  Comment Edit Macro Help                         \",80),\n  left('22'x   \"  Utility        : To comment SQL                 \",80),\n  left('22'x   \"  Syntax         : COMSQL S/O/?                   \",80),\n  left('22'x   \"  Line Command   : Q                              \",80),\n  left('22'x   \"  S Shifts lines being commented                  \",80),\n  left('22'x   \"  O Overlays the - inplace 1-3                    \",80)\n  zerrsm   = \"\"\n  zerrhm   = \"*\"\n  zerralrm = \"NO\"\n  \"ISPEXEC SETMSG MSG(ISRZ003)\"\n  EXIT\nEND\n\"ISREDIT PROCESS RANGE Q\"\nIF RC > 0 THEN DO\n      ZEDSMSG = \"IMPROPER LINE COMMAND\"\n      \"SETMSG MSG(ISRZ001)\"\n       EXIT\nEND\n\"ISREDIT (RANG) = RANGE_CMD\"\n\"ISREDIT (FIRST) = LINENUM .ZFRANGE\";\n\"ISREDIT (LAST) = LINENUM .ZLRANGE\" ;\nDO I = FIRST TO LAST BY 1\n     \"ISREDIT (LINEBUF) = LINE\" I\n\n     IF RANG = 'Q' & OPT = 'S' THEN DO\n        LINEBUF=INSERT('---',LINEBUF,0,3)\n     END\n     IF RANG = 'Q' & OPT = 'O' THEN DO\n        LINEBUF=OVERLAY('---',LINEBUF,1,3)\n     END\n\n     \"ISREDIT LINE\" I \" = \" '(LINEBUF)'\nEND\nZEDSMSG = (LAST-FIRST+1) \"LINE(S) COMMENTED\"\n\"SETMSG MSG(ISRZ000)\"\nEXIT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "COPYPEND": {"ttr": 1294, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x03\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x000\\x000\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:03", "lines": 48, "newlines": 48, "modlines": 0, "user": "KANNAN"}, "text": "/* REXX */\n/* .................................................................. */\n/* Author  : Kannan AK                                                */\n/* COPYPEND: tso copypend                                             */\n/* Notice  : Displays results in stdout                               */\n/* Version : Alpha                                                    */\n/* .................................................................. */\nM = 'TSIN*'\nG = 'X'\naddress ispexec\nZWINTTL='* Select DB2 Subsystem *'\n\"vput (ZWINTTL)\"\naddress ispexec \"addpop\"\naddress ispexec \"display panel(DB2SPNL)\"\nupper cname\nselect\n  when cname  = 'A' then subsys = TEST\n  when cname  = 'B' then subsys = PROD\n  otherwise nop\nend\nredo:\naddress ispexec\nZWINTTL='* Select tablespace/database *'\n\"vput (ZWINTTL)\"\naddress ispexec \"addpop\"\naddress ispexec \"display panel(DB2TPNL)\"\nupper cname\nselect\n  when cname  = 'C' then dbase = INSTANC1\n  when cname  = 'D' then dbase = INSTANC2\n  when cname  = 'E' then dbase = INSTANC3\n  when cname  = 'F' then dbase = INSTANC4\n  otherwise nop\nend\nif M = '' then do\n   address ispexec \"rempop all\"\n   signal redo\nend\nupper G\nif G = 'X' | G ='S' then\n   restrict = 'R'\nelse\n   restrict = 'X'\nupper M\ntspace = M\naddress tso \"DB2PEND\" subsys dbase tspace restrict\naddress ispexec \"rempop all\"\nexit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "COUNT": {"ttr": 1296, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x03\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00W\\x00W\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:03", "lines": 87, "newlines": 87, "modlines": 0, "user": "KANNAN"}, "text": "/* REXX COUNT\n   TSO and/or ISPF ONLY\n   REXX command to count records if sequential,\n       count members if a pds\n\n   to use:\n   COUNT the-dataset-to-be-counted\n\n   IF INPUT IS SEQUENTIAL, COUNTS RECORDS\n   IF INPUT IS A PDS, COUNTS MEMBERS\n   NO OTHER TYPES OF INPUT WILL WORK.\n\n   FOR TSO/ISPF ONLY\n\n  for REXX information, Sample Code, books see\n\n                 HTTP://WWW.REXXFILES.COM\n\n\n\n  provided this entire comment is included\n\n*/\n\nARG DSN  .\nIF DSN = \"\" THEN SIGNAL ADIOS\n\nSYSDSORG = \"\"\nCALL LISTDSI DSN \"DIRECTORY\" \"RECALL\"\n\nIF SYSDSORG = \"PS\" THEN DO\n  NAME_TO_COUNT = TRANSLATE(DSN,\" \",\"'\")\n  NAME_TO_COUNT = SPACE(NAME_TO_COUNT,0)\n  \"ALLOC DSN(*) DDN(SYSPRINT) REUSE\"\n  \"ALLOC DDN(INFILE) SHR REUSE DSN(\"DSN\")\"\n  \"ALLOC DUMMY DDN(OUTFILE) REUSE  BLKSIZE(32000)\"\n\n\n  CALL OUTTRAP \"SYSPRINT.\" , \"*\"\n\n  \"REPRO INFILE(INFILE) OUTFILE(OUTFILE) \"\n  CALL OUTTRAP \"OFF\"\n\n  DO I = 1 TO SYSPRINT.0\n    /*SAY SYSPRINT.I*/\n    PARSE VAR SYSPRINT.I \"WAS\" RECORD_COUNT\n    IF DATATYPE(RECORD_COUNT) = \"NUM\" THEN LEAVE\n  END I\n\n  IF DATATYPE(SYSLRECL) = \"NUM\" THEN DO\n     SAY \"RECORD COUNT  = \" RECORD_COUNT\n     SAY \"RECORD LENGTH = \" SYSLRECL\n     SAY \"BYTE COUNT    = \" SYSLRECL * RECORD_COUNT\n     END\n\n  \"ALLOC DDN(SYSIN) DSN(*) REUSE\"\n  \"ALLOC DDN(SYSPRINT) DSN(*) REUSE\"\n  \"FREE DDN(INFILE OUTFILE )\"\n\n  EXIT\n  END /* FOR PS */\n\nIF SYSDSORG = \"PO\" THEN DO\nSAY SYSMEMBERS \"MEMBERS IN PDS\"\nEXIT\nEND\n\nIF SYSDSORG = \"VS\" THEN DO\nSAY \"CANNOT COUNT RECORDS IN VSAM DATASET\"\nEXIT\nEND\n\nADIOS:\nSAY \"COUNT WILL COUNT RECORDS IN A SEQUENTIAL FILE\"\nSAY \"OR MEMBERS IN A PDS\"\nSAY \"ANYTHING ELSE, CAN'T DO\"\nSAY \"REEXECUTE. PUT COUNT TO LEFT OF DSNAME ON ISPF 3.4 DSLIST\"\nEXIT\n\n/***\n   may be freely distributed\n    provided that this notice is attached.\n    See WWW.REXXFILES.COM and\n    http://www.touniteamerica.com/programming/index.html\n    I am an independant consultant and trainer.\n    For information write to gabe1@touniteamerica.com\n***/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CURPOS": {"ttr": 1539, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x03\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00\\x19\\x00\\x19\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:03", "lines": 25, "newlines": 25, "modlines": 0, "user": "KANNAN"}, "text": "/* REXX CURPOS                                                        */\nADDRESS \"ISREDIT\"\n\"MACRO\"\n\"(DSPLINES) = DISPLAY_LINES\"\n\"(DSPCOLS)  = DISPLAY_COLS\"\n\"(L,C)      = CURSOR\"\n\nSAY \"DISPLAY_LINES =\" DSPLINES + 0           /* REMOVE LEADING ZEROES */\nSAY \"DISPLAY_COLS  =\" DSPCOLS  + 0\nSAY \"CURSOR LINE   =\" L + 0\nSAY \"CURSOR COLUMN =\" C + 0\n\nIF   C    > 0                           /* CALCULATE RELATIVE CSR COL */\nTHEN CREL = C - DSPCOLS + 1\nELSE CREL = 0\n\nIF   L    > 0\nTHEN LREL = L - DSPLINES + 1           /* CALCULATE RELATIVE CSR LINE */\nELSE LREL = 0\n\nSAY \"REL. CSR LINE =\" LREL\nSAY \"REL. CSR COL  =\" CREL\n              DISPLAY_LINES = (DSPLINES)\"\n              DISPLAY_COLS  = (DSPCOLS)\"\nEXIT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CURRGEN": {"ttr": 1541, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x03\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00\\x0e\\x00\\x0e\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:03", "lines": 14, "newlines": 14, "modlines": 0, "user": "KANNAN"}, "text": "/* REXX Get GDG absolute version from relative */\nArg gdgdsn\nIf Length(Arg) = 0 Then Exit 1\nAddress ISPEXEC\n\"LMINIT DATAID(DATAID) DATASET('\"gdgdsn\"') ENQ(SHR)\"\nIf RC > 0 Then Do\n   \"ISPEXEC SETMSG MSG(ISRZ002)\"\n   Exit RC\nEnd\n\"LMQUERY DATAID(\"dataid\") DDNAME(DDNAME)\"\nW = Listdsi(ddname\" DDNAME\")\nSay Sysdsname\n\"LMFREE DATAID(\"dataid\")\"\nExit 1\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CX": {"ttr": 1543, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x03\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00\\xc6\\x00\\xc6\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:03", "lines": 198, "newlines": 198, "modlines": 0, "user": "KANNAN"}, "text": "/* REXX exec to do cursor sensitive data extraction from an ISPF     */\n/*      Screen.                                                      */\n/*      Uses undocumented/Unsupported variables zscreeni & Zscreenc  */\n/*      available in ISPF for OS/390 R2.5 (ISPF4.5).                 */\n/*                                                                   */\n/*------------------------------------------------------------------ */\n/* ---> NOTE: ZSCREENI and ZSCREENC may give odd results in some     */\n/* --->       situations such as command line at the bottom!!!!      */\n/* --->       If this is a problem, force a call to subroutine       */\n/* --->       GET_ZSCREEN_VALUES instead of using ISPF's variables.  */\n/*------------------------------------------------------------------ */\n/*                                                                   */\n/*      Screen image may translate attr bytes to dsn chars causing   */\n/*      extra characters like '#' to be added to the dsname          */\n/*                                                                   */\n/*      Will not work in popups if invoked with the SUSPEND keyword. */\n/*      Note that the default command table entry for TSO does have  */\n/*      the SUSPEND keyword.                                         */\n/*                                                                   */\n/*      Usage:                                                       */\n/*        Name this VCURSOR, set a pfkey to VCURSOR and              */\n/*        create a command table entry:                              */\n/*            VCURSOR   0  SELECT CMD(%VCURSOR)                      */\n/*        (Or setting pfkey to TSO %VCURSOR will work in most cases) */\n/*        Then place cursor on dsname and press the pf key.          */\n/*        ZSCREENC may be wrong if initial command doesn't start     */\n/*        with a percent or have MODE(FSCR) on the SELECT statement. */\n/*                                                                   */\n/*      Author : Doug Nadel  April 24, 1999                          */\n/*      Updates: Apr 26, 1999 now views PDS members also.            */\n/*               Aug 18, Allow dsname in parentheses.                */\n/*                       Added additional information re MODE(FSCR). */\n/*                       Bypass ZSCREENI and ZSCREENC if needed.     */\n/*                       (ISPF version <4.5 but will work in 4.5+)   */\n/*               March 31, 2000 Added basic recognition of GDG names */\n/*                              and view/edit/browse customization   */\n/*               April 3, 2000  Added prompt panel.                  */\n/*------------------------------------------------------------------ */\n/*       Customization to set service to view edit or browse         */\n/*       or to use prompt panel.                                     */\n/*------------------------------------------------------------------ */\nservice='EDIT'                       /* set to VIEW, EDIT, or BROWSE */\n                                     /* or PROMPT.                   */\n/*------------------------------------------------------------------ */\nAddress ispexec\n'VGET (ZSCREENI,ZSCREENC,ZENVIR)'      /* Extract screen image,\n                                          cursor pos and ISPF level  */\nIf substr(zenvir,5,4) <4.5 Then\n  Call get_zscreen_values\ntrtable='abcdefghijklmnopqrstuvwxyz'   /* Setup valid dsname chars   */\ntrtable=trtable||translate(trtable)||'$#@0123456789.''-{()'\ntrtable=translate(xrange('00'x,'FF'x),,trtable,' ')\nzscreeni=translate(zscreeni,,trtable,' ') /* Remove non-Dsn chars    */\nIf substr(zscreeni,zscreenc+1,1) <> ' ' Then /* Maybe csr on dsn     */\n  Do                                   /* Extract dsn from screen image\n                                          and view dataset           */\n    name=word(substr(zscreeni,1+lastpos(' ',zscreeni,zscreenc)),1)\n    name=translate(strip(substr(name,1,56))) /* Max of 56 char name  */\n    If substr(name,1,1)='(' Then\n      Parse Var name '('name')'.\n    Parse Var name dsn '('mem')'       /* Is there a member name?    */\n    omem=mem\n    If mem<>'' Then                    /* If so, reformat for view\n                                          cmd                        */\n      Do\n        gdg=0\n        name=dsn                       /* Get dsn                    */\n        If substr(name,1,1)='''' Then  /* if original name started with\n                                          quotes                     */\n          name=name''''                /* Fix quotes                 */\n        If datatype(mem,'N') = 1 Then  /* Gdg?                       */\n          Do\n            Drop otrap.\n            Call outtrap 'otrap.'\n            Address tso 'LISTCAT ENT('name')' /* Get real gdg names  */\n            Call outtrap 'OFF'\n            If otrap.0>(2-2*mem) Then  /* If enough lines returned   */\n              Do\n                a=otrap.0-1+2*mem      /* Parse listcat output       */\n                n=\"'\"subword(otrap.a,3,1)\"'\" /* Get real dsname      */\n                If sysdsn(n)='OK' Then /* Verify that ds exists      */\n                  Do                   /* If real gdg name exists    */\n                    name=n             /* Use rea name as dsname     */\n                    mem=''             /* Forget the member name     */\n                    omem=''            /* Forget the member name     */\n                    gdg=1              /* Indicate we forgot member\n                                          name                       */\n                  End\n              End\n          End\n        If gdg=0 Then                  /* If gdg check failed        */\n          mem='MEMBER('mem')'          /* Add member keyword for view*/\n      End\n    'CONTROL ERRORS RETURN'            /* Return errors to program   */\n    'LMINIT DATAID(VCURSOR) DATASET('name')' /* Alloc w/ Tso naming  */\n    If rc>0 & substr(name,1,1) <> \"'\" Then /* Alloc w/O tso name     */\n      'LMINIT DATAID(VCURSOR) DATASET('''name''')'\n    If rc=0 Then\n      Do\n        service=translate(service)\n        If service='PROMPT' Then\n          Call getservice\n        If service<>\"\" Then\n        service 'DATAID('vcursor')' mem    /* View the dataset     */\n      End\n    Else                               /* Allocs failed: Set original\n                                          message                    */\n      'LMINIT DATAID(VCURSOR) DATASET('name')'\n    If rc>7 Then\n      'SETMSG MSG(ISRZ002)'            /* If error, show messages    */\n    'LMFREE DATAID(&VCURSOR)'          /* Free ds if allocated       */\n  End\nElse                                   /* Cursor was not on a dsname */\n  Do                                   /* Give user an error message */\n    zerrsm = 'Invalid cursor position'\n    Parse Value '* YES The cursor was not on a data set name.',\n      With zerrhm zerralrm zerrlm\n    'SETMSG MSG(ISRZ002)'\n  End\nExit 0\nget_zscreen_values:                    /* obtain the screen image    */\nAddress ispexec 'VGET (ZSCREENW,ZSCREEND)'\np = ptr(96+ptr(ptr(24+ptr(112+ptr(132+ptr(540))))))\nzscreeni=translate(storage(d2x(p),,\n  zscreenw*zscreend),,xrange('00'x,'3f'x))\nzscreenc = c2d(storage(,\n  d2x(164+ptr(ptr(24+ptr(112+ptr(132+ptr(540)))))),4))\nReturn\nptr:  Return c2d(bitand(storage(d2x(Arg(1)),4),'7FFFFFFF'x))\ngetservice: Procedure Expose service name omem\n'VGET ZSCREEN'\nservice='EDIT'\ndsn=name\nParse Source  . . me .\nIf omem <> \"\" Then\n  Do\n   If substr(dsn,1,1)='''' Then\n     dsn=substr(dsn,1,length(dsn)-1)'('omem')'''\n   Else\n     dsn=dsn'('omem')'\n  End\nAddress tso\nddname='$VCSR$'zscreen\n'alloc f('ddname') reuse new del dso(po) dir(1) sp(1)' ,\n  'track recfm(f b) lrecl(80)'\nAddress ispexec\n'LMINIT DATAID(DID) DDNAME('ddname') ENQ(EXCLU)'\n'LMOPEN DATAID(&DID) OPTION(OUTPUT)'\nCall write \")ATTR\"\nCall write \"+ TYPE(NT)\"\nCall write \"@ TYPE(PT)\"\nCall write \"? TYPE(CH)\"\nCall write \"# TYPE(output) just(asis) caps(off)\"\nCall write \")BODY WINDOW(60,14)\"\nCall write \"                  @Cursor Sensitive Action+\"\nCall write \"+%\"\nCall write \"+Dataset:+&DSN\"\nCall write \"+\"\nCall write \"?  Select action:\"\nCall write \"      _Z% 1. Edit\"\nCall write \"     %#VCAXXY      +\"\nCall write \"     %#VCAXXZ      +\"\nCall write \" \"\nCall write \"? Press%END?to cancel this action.\"\nCall write \" \"\nCall write \"? To avoid this panel, modify your \"me\" exec.\"\nCall write \")INIT\"\nCall write \" VGET (VCACTNX) PROFILE\"\nCall write \" .ZVARS = 'VCACTNX'\"\nCall write \" &VCAXXY = '   2. View'\"\nCall write \" &VCAXXZ = '   3. Browse'\"\nCall write \")REINIT\"\nCall write \" REFRESH(*)\"\nCall write \")PROC\"\nCall write \" IF (.CURSOR = VCAXXY) &VCACTNX = '2' /* allow csr selct*/\"\nCall write \" IF (.CURSOR = VCAXXZ) &VCACTNX = '3'\"\nCall write \" VER (&VCACTNX, NB ,LIST,1,2,3)\"\nCall write \" IF (.MSG NE &Z) &VCACTNX=1\"\nCall write \" VPUT (VCACTNX) PROFILE\"\nCall write \")END\"\n'LMMADD DATAID(&DID) MEMBER(FOO)'\n'LMFREE DATAID(&DID)'\n'LIBDEF ISPPLIB LIBRARY ID('ddname')'\n'ADDPOP'\n'DISPLAY PANEL(FOO)'\nIf rc>0 Then service=\"\"\nElse If vcactnx=2 Then service='VIEW'\nElse If vcactnx=3 Then service='BROWSE'\n'REMPOP'\n'LIBDEF ISPPLIB'\nAddress tso\n'FREE F('ddname')'\nReturn\nwrite:\nParse Arg p1\n\"LMPUT DATAID(&DID) MODE(INVAR) DATALOC(P1) DATALEN(80)\"\nReturn\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DB2PEND": {"ttr": 1547, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x03\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00\\t\\x00\\t\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:03", "lines": 9, "newlines": 9, "modlines": 0, "user": "KANNAN"}, "text": "PROC 4 SUBSYS DBASE TSPACE VERB1\nDSN S(&SUBSYS)\nIF &VERB1 = R THEN DO\n   -DISPLAY DATABASE(&DBASE) SPACE(&TSPACE) LIMIT(400) RESTRICT\nEND\nELSE DO\n   -DISPLAY DATABASE(&DBASE) SPACE(&TSPACE) LIMIT(400)\nEND\nEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DB2SPNL": {"ttr": 1549, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x03\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00\\x0b\\x00\\x0b\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:03", "lines": 11, "newlines": 11, "modlines": 0, "user": "KANNAN"}, "text": ")ATTR\n% TYPE(TEXT)   INTENS(HIGH) SKIP(ON) COLOR(PINK)\n_ TYPE(INPUT)  INTENS(HIGH) JUST(LEFT)  PAD(' ') CAPS(ON)\n)BODY WINDOW(29,04)\n\n   _A+TEST %(TEST)\n   _B+PROD %(PRODUCTION)\n\n)PROC\n&CNAME  = .CURSOR\n)END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DB2TPNL": {"ttr": 1551, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x03\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00\\x13\\x00\\x13\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:03", "lines": 19, "newlines": 19, "modlines": 0, "user": "KANNAN"}, "text": ")ATTR\n% TYPE(TEXT)   INTENS(HIGH) SKIP(ON)\n+ TYPE(TEXT)   INTENS(LOW)\n_ TYPE(INPUT)  INTENS(HIGH) JUST(LEFT)  PAD(' ') CAPS(ON)\n@ TYPE(TEXT  ) INTENS(LOW)  JUST(LEFT)  PAD(' ') CAPS(OFF) COLOR(YELLOW)\n)BODY WINDOW(35,10)\n\n     +TABLE SPACE MASK _M       +\n\n   _G@Restrict only\n\n   _C+INSTANC1 %(PROD      )\n   _D+INSTANC2 %(TEST1     )\n   _E+INSTANC3 %(TEST2     )\n   _F+INSTANC4 %(TEST3     )\n\n)PROC\n&CNAME  = .CURSOR\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "DB2UTIL": {"ttr": 1553, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x03\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00\\x04\\x00\\x04\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:03", "lines": 4, "newlines": 4, "modlines": 0, "user": "KANNAN"}, "text": "PROC 1 SUBSYS\nDSN S(&SUBSYS)\n-DISPLAY UTILITY(*)\nEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DEAL": {"ttr": 1555, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x03\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00\\x1b\\x00\\x1b\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:03", "lines": 27, "newlines": 27, "modlines": 0, "user": "KANNAN"}, "text": "/*rexx */\nface='Ace 2 3 4 5 6 7 8 9 10 Jack Queen King'\nsuit='Hearts Diamonds Clubs Spades'\ndeck=xrange('00'x,d2c(51))\nhands.=''\ndo player=1 to 4\n do cardinhand=1 to 5\n   card=random(1,length(deck))\n   hands.player.cardinhand=substr(deck,card,1)\n   deck=delstr(deck,card,1)\n end\nend\ndo player=1 to 4\n  say 'Player 'player':'\n  do cardinhand=1 to 5\n     say '     ',\n         right(word(face,1+c2d(hands.player.cardinhand) // 13),5)' of '||,\n              word(suit,1+c2d(hands.player.cardinhand) %  13)\n  end\nend\n/* Show card  name for each card in a full deck ---- */\ndo a=0 to 51\n  say a '     ',\n         right(Word(face,1+a//13),5)' of '||,\n         word(suit,1+a%13)\nend\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "DEBUGCMD": {"ttr": 1557, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x03\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00.\\x00.\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:03", "lines": 46, "newlines": 46, "modlines": 0, "user": "KANNAN"}, "text": "/* REXX Enable TSO TEST trapping of SELECT CMD(xxx) programs.        */\n/* Very release dependent and subject to breakage at any time.       */\n/* DO NOT USE AS PART OF A SUPPORTED INTERFACE.  Side effects unknown*/\n/* This code is not supported . Doug Nadel                           */\nNumeric digits 12\ncatp = ptr(16+ptr(120+ptr(56+ptr(ptr(24+ptr(112+ptr(132+ptr(540))))))))\nfound = 0\nDo offset = 40 to 50 by 2 Until found = 1\n  If storage(d2x(offset+catp),2)='9210'x Then /* MVI INSTR           */\n    Do\n      /* alter the setrp to be rc=0                                  */\n      If '' \\= storage(d2x(offset+catp),2,'9200'x) Then\n        Do\n          Say 'TSO TEST will now catch abends in SELECT CMD() commands'\n          found = 1\n        End\n    End\n  Else\n    If storage(d2x(46+catp),2)='9200'x Then\n      Do\n        /* alter the setrp to be rc=16                               */\n        If ''\\= storage(d2x(46+catp),2,'9210'x) Then\n          Do\n            Say 'TSO TEST will no longer trap abends',\n                'in SELECT CMD() commands'\n            found = 1\n          End\n      End\nEnd\nIf found=0 Then\n  Do\n    Say 'SELECT CMD() abend handling was not changed.'\n    Say 'Module ISPSUBX must not be in read-only storage.'\n    Say 'You can preload ISPSUBX with TSO TEST before starting ISPF.'\n    Say 'For example:'\n    Say\n    Say '    TEST ''SYS1.ISP.SISPLPA(ISRPCP)'' CP'\n    Say '    ISPF TEST'\n    Say '    LOAD ''SYS1.ISP.SISPLPA(ISPSUBX)'''\n    Say '    GO'\n    Say\n  End\nExit\nptr:\nReturn c2d(bitand(storage(d2x(Arg(1)),4),'7FFFFFFF'x))\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "DEFVSAM": {"ttr": 1559, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x03\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00\\xa5\\x00\\xa5\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:03", "lines": 165, "newlines": 165, "modlines": 0, "user": "KANNAN"}, "text": "/* REXX ----------------------------------------------------------*/\n/* This exec creates IDCAMS DEFINE JCL for a VSAM dataset.        */\n/* Invoked as a prefix command from a 3.4 DSLIST panel or as a    */\n/* command with the cluster name as an argument, it puts the user */\n/* into en edit session with the created JCL and IDCAMS DEFINE    */\n/* statements.                                                    */\n/*----------------------------------------------------------------*/\nArg dsn .\nIf Left(dsn,1) = \"'\"    Then /* dsn arg from 3.4 comes with tickies */\n   Do\n      dsn = Strip(Translate(dsn,\" \",\"'\"))\n   End\nElse               /* dsn entered as primary command without tickies */\n   Do\n      dsn = Userid()\".\"dsn\n   End\nqdsn = \"'\"dsn\"'\"   /* qdsn gets quoted version of dsn with tickies */\nStat = SYSDSN(qdsn)  /* See if data set exists */\nIf Stat <> \"OK\" Then\n   Do\n     Say qdsn \"not found.\"\n     Exit\n   End\n/* Make sure it's VSAM */\nfc = LISTDSI(qdsn)\nIf fc > 4 Then\n   Do\n      Say \"LISTDSI returned function code\" fc\n      Say \"Reason Code =\" SYSREASON\n      Exit\n   End\ndsorg = SYSDSORG\nIf dsorg <> \"VS\" Then\n   Do\n      Say \"DV supports only VSAM data sets.\"\n      Exit\n   End\nCall OUTTRAP O.\n\"LISTCAT ENTRY(\"qdsn\") ALL\"\nIf rc <> 0 then do\n   Say \"Error from LISTCAT. RC =\" rc\n   Exit\nEnd\nsection = \"CLUSTER\"\ndvolser = \"\"\nivolser = \"\"\nDo l = 1 to o.0\n   o.l = translate(o.l,\" \",\"-\")\n   word1 = Word(o.l,1)\n   word2 = Word(o.l,2)\n   If word1 = \"IN\" Then    /* Change sections on \"IN CAT\" lines */\n      Do\n        p = l - 1\n        section = Word(o.p,1)\n      End\n   Select     /* Select based on section of listcat output */\n      When section = \"CLUSTER\" Then\n         Select /* Select based on line within a given section */\n            When word1 = \"CLUSTER\"           Then\n               clname = Word(o.l,2)\n            When word1 = \"DATA\"              Then\n               dname = Word(o.l,2)\n            When word1 = \"INDEX\"             Then\n               iname = Word(o.l,2)\n            Otherwise Nop\n         End /* End of Select on line within CLUSTER section */\n      When section = \"DATA\" Then\n         Select /* Select based on line within a given section */\n            When word1 = \"KEYLEN\"            Then\n               Parse var o.l . keylen . avglrecl . bufspace . dcisize .\n            When word1 = \"RKP\"               Then\n               Parse var o.l . rkp . maxlrecl .\n            When Left(word1,8) = \"SHROPTNS\"  Then\n               Do\n                  Parse var o.l \"(\" shroptns \")\" recovery unique ,\n                                erase type writechk imbed replicat .\n                  n = l + 1\n                  Parse var o.n ordered reuse spanned .\n                  writechk = Insert(\"EC\",writechk,Index(writechk,\"H\"))\n               End\n            When word1 = \"REC\" & word2 = \"INSERTED\"  Then\n                  dfreeci = Word(o.l,6)\n            When word1 = \"REC\" & word2 = \"UPDATED\"  Then\n                  dfreeca = Word(o.l,6)\n            When word1 = \"SPACE\" & word2 = \"TYPE\"  Then\n                  dspacetype = Word(o.l,3)\n            When word1 = \"SPACE\" & word2 = \"PRI\"  Then\n                  dspacepri = Word(o.l,3)\n            When word1 = \"SPACE\" & word2 = \"SEC\"  Then\n                  dspacesec = Word(o.l,3)\n            When word1 = \"VOLSER\" Then\n                  dvolser = dvolser Word(o.l,2)\n            Otherwise Nop\n         End /* End of Select on line within DATA section */\n      When section = \"INDEX\" Then\n         Select /* Select based on line within a given section */\n            When word1 = \"KEYLEN\"            Then\n               icisize = Word(o.l,8)\n            When word1 = \"SPACE\" & word2 = \"TYPE\"  Then\n                  ispacetype = Word(o.l,3)\n            When word1 = \"SPACE\" & word2 = \"PRI\"  Then\n                  ispacepri = Word(o.l,3)\n            When word1 = \"SPACE\" & word2 = \"SEC\"  Then\n                  ispacesec = Word(o.l,3)\n            When word1 = \"VOLSER\" Then\n                  ivolser = ivolser Word(o.l,2)\n            Otherwise Nop\n         End /* End of Select on line within INDEX section */\n      Otherwise Nop\n   End /* End of Select on section */\nEnd /* End of  Do l = 1 to o.0 */\nCall OUTTRAP \"OFF\"\nNewstack\n\"ISPEXEC VGET (ZLLGJOB1 ZLLGJOB2 ZLLGJOB3 ZLLGJOB4) PROFILE\"\nDo i = 1 To 4\n   If Value(zllgjob || i) <> \"\" Then Queue Value(zllgjob || i)\nEnd\nQueue \"//IDCAMS   EXEC PGM=IDCAMS\"\nQueue \"//SYSPRINT DD SYSOUT=*\"\nQueue \"//SYSIN    DD *\"\nQueue \" DEFINE CLUSTER -\"\nQueue \"           (NAME(\"clname\") -\"\nQueue \"           \"type\" -\"\nQueue \"           SHAREOPTIONS(\"shroptns\") -\"\nQueue \"           \"erase\" -\"\nQueue \"           \"recovery\" -\"\nQueue \"           \"writechk\" -\"\nQueue \"           \"reuse\") -\"\nQueue \"        DATA -\"\nQueue \"           (NAME(\"dname\") -\"\nIf type = \"INDEXED\" Then\n   Do\n      Queue \"           KEYS(\"keylen rkp\") -\"\n   End\nQueue \"           CONTROLINTERVALSIZE(\"dcisize\") -\"\nQueue \"           \"dspacetype\"(\"dspacepri dspacesec\") -\"\nQueue \"           FREESPACE(\"dfreeci dfreeca\") -\"\nQueue \"           RECORDSIZE(\"avglrecl maxlrecl\") -\"\nQueue \"           \"spanned\" -\"\nQueue \"           VOLUMES(\"dvolser\") -\"\nIf type = \"INDEXED\" Then\n   Do\n      Queue \"           )-\"\n      Queue \"        INDEX -\"\n      Queue \"           (NAME(\"iname\") -\"\n      Queue \"           CONTROLINTERVALSIZE(\"icisize\") -\"\n      Queue \"           \"ispacetype\"(\"ispacepri ispacesec\") -\"\n      Queue \"           \"imbed\" -\"\n      Queue \"           \"ordered\" -\"\n      Queue \"           \"replicat\"E -\"\n      Queue \"           VOLUMES(\"ivolser\"))\"\n   End\nElse  Queue \"           )\"\nQueue \"/*\"\nCall MSG 'OFF'\nAddress ispexec 'VGET (ZSCREEN) SHARED'\nddname='$TRAP$'zscreen\n'ALLOC F('ddname') UNIT(VIO) DSO(PS) RECFM(F B) LRECL(80) NEW DEL REU'\n'EXECIO 'Queued()' DISKW 'ddname' (FINIS'\nAddress ispexec 'LMINIT DATAID(TRAP) DDNAME('ddname') ENQ(SHR)'\nAddress ispexec 'EDIT   DATAID('trap')'\nAddress ispexec 'LMFREE DATAID('trap')'\n'FREE F('ddname')'\nDelstack\nExit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DELAY": {"ttr": 1795, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x03\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00\\x10\\x00\\x10\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:03", "lines": 16, "newlines": 16, "modlines": 0, "user": "KANNAN"}, "text": "/* Rexx Delay                                                         */\n/* .................................................................. */\n/* Author  : Kannan AK                                                */\n/* Delay   : Produce a delay                                          */\n/* Notice  : Not a perfect delay caused;perfectionists crib           */\n/* Version : Alpha                                                    */\n/* .................................................................. */\narg DelaySec\nif DelaySec = '' then DelaySec = 0.008000           /* readable width */\nelapsed = TIME(R)\nsignal on halt    name qui\nDo until elapsed >= DelaySec\n   elapsed   = TIME('E')\nEnd\nqui :\nExit 0\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "DELDUPE": {"ttr": 1797, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x03\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00\\x13\\x00\\x13\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:03", "lines": 19, "newlines": 19, "modlines": 0, "user": "KANNAN"}, "text": "/* Rexx DELDUPE */\nAddress isredit\n\"ISREDIT MACRO (LCOL,RCOL)\"  /* Indicate macro with 2 parms    */\n\"ISREDIT (DW) = DATA_WIDTH\"  /* Tet maximum data width         */\n\"ISREDIT (LAST) = LINENUM .ZLAST\"    /* Get number of last line*/\n\"ISREDIT RESET X\"            /* Un-Exclude all lines           */\nIf datatype(lcol,'N')=0 Then lcol=1  /* Set left column        */\nIf datatype(rcol,'N')=0 | rcol>dw Then rcol = dw /* Right col  */\nlen=abs(rcol-lcol)+1         /* Get length of compare area     */\nlcol=min(lcol,rcol)          /* Tet left col                   */\nDo linenum = 1 to last       /* Loop through all lines         */\n  \"ISREDIT (LINE) = LINE \"linenum /* Place line data in 'line' */\n  test=substr(line,lcol,len) /* Take just columns to compare   */\n  If test = testold Then     /* Compare against previous line  */\n    \"ISREDIT XSTATUS \"linenum\" = X\"  /* If match, exclude line */\n  testold = test             /* Save current line compare area */\nEnd                          /*                                */\n\"ISREDIT DEL ALL X\"       /* Finally, delete all excluded lines*/\nExit 1                       /* Reset cursor to command line   */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DELMEM": {"ttr": 1799, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x03\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00\\t\\x00\\t\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:03", "lines": 9, "newlines": 9, "modlines": 0, "user": "KANNAN"}, "text": "/* Rexx                                                               */\n\"ISREDIT Macro\"\nAddress ISPEXEC\n'ISREDIT (Openpds) = Dataset'\n'ISREDIT (Openmbr) = Member'\n'ISREDIT End'\nDelstr = Strip(Openpds)'('Strip(Openmbr)')'\nAddress TSO \"Delete '\"Delstr\"'\"\nReturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DESC": {"ttr": 1801, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x03\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00F\\x00F\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:03", "lines": 70, "newlines": 70, "modlines": 0, "user": "KANNAN"}, "text": "/* Rexx                                                               */\n/* .................................................................. */\n/* Author  : Kannan AK                                                */\n/* Desc    : Give struture of the DB2 tables                          */\n/* Syntax  : TSO DESC DB2SSID CREATOR.TABLE                           */\n/* Version : Alpha                                                    */\n/* .................................................................. */\nAddress ISPEXEC 'Control Errors Return'\nPARSE UPPER ARG DB2sub Creator .\nPARSE VALUE Creator with Creator '.' Table\n\nIf strip(DB2sub)='' | strip(Creator) = '' | strip(Table) = '' Then Do\n   Say 'Syntax : TSO DESC DB2SSID CREATOR.TABLE'\n   Exit 8\nEnd\n\nx = OutTrap(\"DB2out.\",\"*\")\nCALL AllocateIn\nCALL AllocateOut\nCall ExecuteDSNTEP2\nCall CleanUp\nx = OutTrap(\"OFF\")\nExit 1\n\nAllocateIn :\nAddress TSO\n\nDo queued();Pull;End\nQueue \"SELECT   NAME, COLTYPE, LENGTH, SCALE, NULLS\"\nQueue \"FROM     SYSIBM.SYSCOLUMNS\"\nQueue \"WHERE    TBNAME    = '\"Table\"'\"\nQueue \"AND      TBCREATOR = '\"Creator\"'\"\nQueue \"ORDER BY COLNO\"\nQueue \"WITH     UR;\"\n\n'ALLOC F(SYSIN) REUSE NEW DEL UNIT(SYSDA) LRECL(80) RECFM(F B)\n SPACE(10,10) TRACK RELEASE DSO(PS) BLKSIZE(80)'\n'EXECIO 6 DISKW SYSIN (FINIS'\n\n\"delete \"USERID()\".SYSPRINT\"\nDo queued();Pull;End\nRETURN\n\nAllocateOut :\nAddress TSO\n            \"ALLOC F(SYSPRINT) NEW UNIT(SYSDA) SPACE(8,2)\",\n            \"UNIT(sysda)\",\n            \"TRACKS REUSE DSNAME('\"USERID()\".SYSPRINT')\"\nReturn\n\nExecuteDSNTEP2:\nAddress ISPEXEC\n\"LIBDEF STEPLIB DATASET ID(\"'SYS0.DB2.PROD.DSNLOAD'\")\"\nAddress TSO \"NEWSTACK\"\nQUEUE \"RUN PROGRAM(DSNTEP2) PLAN(DSNTEP2) \",\n      \"LIBRARY('SYS0.DB2.#510.PROD.RUNLIB.LOAD') PARMS('ALIGN(LHS)')\"\nQUEUE \"END\"\nQUEUE\naddress TSO \"DSN SYSTEM(\"DB2sub\")\"\nAddress TSO \"DELSTACK\"\n\nADDRESS ISPEXEC \"LMINIT DATAID(DSID) DDNAME(SYSPRINT)\"\nADDRESS ISPEXEC \"BROWSE DATAID(\"DSID\")\"\nADDRESS ISPEXEC \"LMFREE DATAID(\"DSID\")\"\nRETURN\n\nCleanUp:\n  address TSO \"delete '\"USERID()\".SYSPRINT'\"\nRETURN\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DIR": {"ttr": 1803, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x03\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00 \\x00 \\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:03", "lines": 32, "newlines": 32, "modlines": 0, "user": "KANNAN"}, "text": "/*Rexx Dir                                                            */\n/* .................................................................. */\n/* Author  : Kannan AK                                                */\n/* Dir     : Do DSLIST                                                */\n/* Notice  : None                                                     */\n/* Version : Alpha                                                    */\n/* .................................................................. */\narg DSNLVL IVIEW\nif DSNLVL = '' then Exit 0\nif IVIEW  = '' then IVIEW = 'ATTRIB'\naddress ispexec\nZEDSMSG = ''\nZEDLMSG = ''\n\"ISPEXEC SETMSG MSG(ISRZ001)\"\nCONTROL ERRORS RETURN\n'LMDINIT LISTID(dsnlist)  LEVEL('DSNLVL')'\nCall CheckRC\n'LMDDISP LISTID('dsnlist') VIEW('IVIEW') CONFIRM(YES)'\nCall CheckRC\n'LMDFREE LISTID('dsnlist')'\nCall CheckRC\nExit 0\n\nCheckRC :\n  If rc \u00ac= 0 Then\n    Do\n       \"ISPEXEC SETMSG MSG(ISRZ002)\"\n       Exit\n    End\n  Else\n       Nop\nReturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DIRPNL": {"ttr": 1805, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x03\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00\\x13\\x00\\x13\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:03", "lines": 19, "newlines": 19, "modlines": 0, "user": "KANNAN"}, "text": ")ATTR\n+ TYPE(TEXT)   INTENS(LOW)\n_ TYPE(INPUT)  INTENS(HIGH) CAPS(OFF) HILITE(USCORE) COLOR(YELLOW)\n)BODY WINDOW(16,06)\n\n   _Volume+\n   _Space+\n   _Attrib+\n   _Total+\n\n)INIT\n&ZWINTTL=' Initial View '\n&Volume = 'Volume'\n&Space  = 'Space'\n&Attrib = 'Attrib'\n&Total  = 'Total'\n)PROC\n&CNAME  = .CURSOR\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "DISPPEND": {"ttr": 1807, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x03\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00Z\\x00Z\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:03", "lines": 90, "newlines": 90, "modlines": 0, "user": "KANNAN"}, "text": "/* REXX */\n/* .................................................................. */\n/* Author  : Kannan AK                                                */\n/* DISPPEND: tso disppend                                             */\n/* Notice  : Captures results in Edit Panel                           */\n/* Version : Alpha                                                    */\n/* .................................................................. */\ncall tempdsn cp tempdd tempdsn\nSERVICE = 'VIEW'\nM = 'TSIN*'\nG = 'X'\naddress ispexec\nzwinttl='* Select DB2 Subsystem *'\n\"vput (zwinttl)\"\n\"addpop\"\n\"display panel(db2spnl)\"\nif rc = 8 then do\n   'rempop'\n   zedsmsg = 'Function canceled'\n   'setmsg msg(isrz001)'\n   exit\nend\nupper cname\nselect\n  when cname  = 'A' then subsys = TEST\n  when cname  = 'B' then subsys = PROD\n  otherwise nop\nend\nredo:\nzwinttl='* Select tablespace/database *'\n\"vput (zwinttl)\"\n\"addpop\"\n\"display panel(db2tpnl)\"\nif rc = 8 then do\n   'rempop all'\n   zedsmsg = 'Function canceled'\n   'setmsg msg(isrz001)'\n   exit\nend\nupper cname\nselect\n  when cname  = 'C' then dbase = INSTANC1\n  when cname  = 'D' then dbase = INSTANC2\n  when cname  = 'E' then dbase = INSTANC3\n  when cname  = 'F' then dbase = INSTANC4\n  otherwise nop\nend\nif M = '' then do\n   \"rempop all\"\n   signal redo\nend\nupper G\nif G = 'X' | G ='S' then\n   restrict = 'R'\nelse\n   restrict = 'X'\nupper M\ntspace = M\nqueue \"SSID       \" subsys\nqueue \"DATABASE   \" dbase\nqueue \"TABLESPACE \" tspace\nx = outtrap('out.','*','noconcat')\naddress tso \"db2pend\" subsys dbase tspace restrict\nx = outtrap(off)\n\"rempop all\"\ndo i=1 by 1 while i <= out.trapped\n   queue out.i\nend\nqueue \"\"\naddress tso \"execio * diskw\" tempdd \"(finis\"                                0000\nservice \" dataset(\"tempdsn\")\"\naddress tso \"free dd(\"tempdd\") delete\"\nexit\n\n/* invocation : call tempdsn co tempdd tempdsn */\ntempdsn : procedure expose cuechar tempdd tempdsn\narg cuechar\ncuechar = substr(cuechar,1,2)\nd = date(j);p = sysvar(syspref);\nr1 = random(100,999);r2 = random(100,999);\nt = time();parse value t with hh ':' mm ':' ss;tt=hh||mm||ss\ntempdsn = cuechar||d||'.t'||r1||trunc(r1*r2/random()/10)||'.z'||tt\nnt = tempdsn\ntempdd  = cuechar ||r2||r1\n\"alloc ds(\"nt\") dd(\"tempdd\") dsorg(ps) lrecl(80) recfm(f) new keep\"\nif rc \\= 0 then do\n       \"ispexec setmsg msg(isrz002)\"\n       exit\nend\nreturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DISPUTIL": {"ttr": 1810, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x03\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00\\x16\\x00\\x16\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:03", "lines": 22, "newlines": 22, "modlines": 0, "user": "KANNAN"}, "text": "/* REXX */\n/* .................................................................. */\n/* Author  : Kannan AK                                                */\n/* DISPUTIL: Displays active utilities on SSID                        */\n/* Notice  : None                                                     */\n/* Version : Alpha                                                    */\n/* .................................................................. */\naddress tso\n\"clear\"\naddress ispexec\nZWINTTL='* Select DB2 Subsystem *'\n\"vput (ZWINTTL)\"\n\"addpop\"\n\"display panel(DB2SPNL)\"\nupper cname\nselect\n  when cname  = 'A' then subsys = TEST\n  when cname  = 'B' then subsys = PROD\n  otherwise return\nend\naddress tso \"DB2UTIL\" subsys\nexit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DSN": {"ttr": 1812, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x03\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00\\x06\\x00\\x06\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:03", "lines": 6, "newlines": 6, "modlines": 0, "user": "KANNAN"}, "text": "address tso\ndb2cmd1 = \"TEST\"\nqueue '-DISPLAY UTIL(*)'\nqueue 'END'\n\"ispexec SELECT CMD(DSN SYSTEM(\"db2cmd1\")) NEST\"\nexit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DSNREXX": {"ttr": 1814, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x03\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00\\x0c\\x00\\x0c\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:03", "lines": 12, "newlines": 12, "modlines": 0, "user": "KANNAN"}, "text": "/* REXX */\nTRACE ?R\n/* S_RC = RXSUBCOM('ADD','DSNREXX','DSNREXX') */\nADDRESS DSNREXX 'CONNECT' 'TEST'\n'SUBCOM DSNREXX'                          /* HOST CMD ENV AVAILABLE? */\nIF RC THEN                              /* IF NOT, MAKE IT AVAILABLE */\nADDRESS DSNREXX                           /* SEND ALL COMMANDS OTHER */\nS_RC = RXSUBCOM('ADD','DSNREXX','DSNREXX')\n                                         /* ADD HOST CMD ENVIRONMENT */\nADDRESS DSNREXX                           /* SEND ALL COMMANDS OTHER */\nS_RC = RXSUBCOM('DELETE','DSNREXX','DSNREXX')\n                                         /* DEL HOST CMD ENVIRONMENT */\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DSNTIAUL": {"ttr": 1816, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x03\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00V\\x00V\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:03", "lines": 86, "newlines": 86, "modlines": 0, "user": "KANNAN"}, "text": "/* REXX  */\n/********************************************************************/\n/*   RUNSQL subroutine                                              */\n/*                                                                  */\n/*  Invocation:  TSO RUNSQL DB2SSID SYSINDSN                        */\n/*  This REXX takes the DB2 SSID and the SYSIN dataset as argument  */\n/*  It then runs DSNTIAUL and stores the result in a file           */\n/*  named as PREFX.USERID.SYSRECXX                                  */\n/*  The SYSPRINT dataset is also present and the code can be        */\n/*  turned on or off to browse the same                             */\n/*  Use proper values for PREFX as allowed by your installation     */\n/********************************************************************/\nTRACE o\nPARSE UPPER ARG P_db2sub P_dsname .\nsay 'Running RUNSQL'\nif strip(P_db2sub)='' | strip(P_dsname) = '' then\ndo\n   say 'Proper execution is RUNSQL DB2SSID SYSIN-DSNAME  ...'\n   exit(8)\nend\nPREFX = userid()\nx = outtrap(\"zap.\",\"*\")\nCALL P1XXX_Allocate_Sysin\nCALL P2XXX_Allocate_Output\nCall P3XXX_Execute_DSNTIAUL\nCall P4XXX_Clean_up\nx = outtrap(\"OFF\")\nEXIT\n\nP1XXX_Allocate_Sysin:\n   P_pds_in = strip(P_dsname)\n   Sysin = SYSDSN(\"'\"P_pds_in||\"'\")\n   if Sysin = \"OK\" then do\n     address TSO \"ALLOCATE DDNAME(SYSIN) SHR reu \",\n      \"DSNAME('\"P_pds_in||\"')\"\n   end\n   if Sysin /= \"OK\"  then do\n     SAY  '*** Error *** 'P_pds_in Sysin\n     exit(8)\n   end\n   address TSO \"delete \"USERID()\".SYSPRINT\"\n   address TSO \"delete \"USERID()\".SYSPUNCH\"\nRETURN\n\nP2XXX_Allocate_Output:\naddress TSO \"ALLOC F(SYSREC00) NEW UNIT(SYSDA) SPACE(1,10)\",\n            \"UNIT(sysda)\",\n            \"CYL    REUSE DSNAME('\"USERID()\".SYSREC00')\"\naddress TSO \"ALLOC F(SYSPRINT) NEW UNIT(SYSDA) SPACE(8,2)\",\n            \"UNIT(sysda)\",\n            \"TRACKS REUSE DSNAME('\"USERID()\".SYSPRINT')\"\naddress TSO \"ALLOC F(SYSPUNCH) NEW UNIT(SYSDA) SPACE(8,2)\",\n            \"UNIT(sysda)\",\n            \"TRACKS REUSE DSNAME('\"USERID()\".SYSPUNCH')\"\nReturn\n\nP3XXX_Execute_DSNTIAUL:\n/*******************************************************************/\n/*  Specify the proper DSNLOAD and DSNEXIT  Dataset library names  */\n/*******************************************************************/\n\n  Address ISPEXEC \"libdef steplib dataset id(\",\n                  \"'SYS0.DB2.PROD.DSNLOAD')\"\n\n/*                                                                 */\n\"NEWSTACK\"\nQUEUE \"RUN PROGRAM(DSNTIAUL) PLAN(DSNTIAUL) \",\n      \"LIBRARY('SYSPROD.RUNLIB.LOAD') \",\n      \"PARM('SQL')\"\nQUEUE \"END\"\nQUEUE\naddress TSO \"DSN SYSTEM(\"P_db2sub\")\"\n\"DELSTACK\"\n\n/*  comment the signal code below to browse SYSPRINT dataset       */\n\n/*     BROWSE THE SYSPRINT FILE                                    */\nADDRESS ISPEXEC \"LMINIT DATAID(DSID) DDNAME(SYSPRINT)\"\nADDRESS ISPEXEC \"BROWSE DATAID(\"DSID\")\"\nADDRESS ISPEXEC \"LMFREE DATAID(\"DSID\")\"\nRETURN\n\nP4XXX_Clean_up:\naddress TSO \"delete '\"USERID()\".SYSPRINT'\"\naddress TSO \"delete '\"USERID()\".SYSPUNCH'\"\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DYN": {"ttr": 1819, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x03\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00+\\x00+\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:03", "lines": 43, "newlines": 43, "modlines": 0, "user": "KANNAN"}, "text": "/* REXX - Dynamic area example */\nAddress ispexec                            /* Calls go to ISPF       */\nred   = '01'x                              /* Assign colors to       */\nblue  = '02'x                              /*   Attribute bytes      */\ngreen = '03'x                              /*   found in the data    */\nwhite = '04'x\nmaxlines = 600                             /* set max number of lines*/\ndyndata  = ''                              /* initialize data        */\nDo a = 1 to maxlines by 3                  /* Create some dummy data */\n  dyndata=dyndata||white||left('This is'red  ||'red  'white|| a  , 29)\n  dyndata=dyndata||white||left('This is'blue ||'blue 'white|| a+1, 29)\n  dyndata=dyndata||white||left('This is'green||'green'white|| a+2, 29)\nEnd\n\n/*    Add a bottom of data maker to the end of the data      */\ndyndata = dyndata||blue||centre(green||'BOTTOM'||blue,29,'*')\n\ncurline = 1;                               /* set current line #     */\n\n/*-------------------------------------------------------------------*/\n/* Display loop until end or error                                   */\n/*-------------------------------------------------------------------*/\n\nDo Until disprc > 0\n  dynarea = substr(dyndata,1+(curline-1)*30) /* set dynamic variable */\n  size = length(dynarea)                   /* Set a scalar variable  */\n  'ISPEXEC DISPLAY PANEL(DYNAREA)'         /* Display the data       */\n  disprc = rc                              /* save return code       */\n  'ISPEXEC VGET (ZVERB,ZSCROLLA,ZSCROLLN)' /* get scroll values      */\n  SELECT                                   /* Process scrolling      */\n    When(zverb  = 'UP')   Then             /* Scroll up              */\n     If zscrolla = 'MAX' Then              /*  if scroll was max     */\n      curline = 1                          /*    scroll to top       */\n     Else                                  /*  else a number is known*/\n      curline = max(1,curline-zscrolln);   /* (maximum is top)       */\n    When(zverb  = 'DOWN') Then             /* Scroll down            */\n     If zscrolla = 'MAX' Then              /*  if scroll was max     */\n      curline = maxlines                   /*    scroll to bottom    */\n     Else                                  /*  else a number is known*/\n      curline = min(maxlines,curline+zscrolln); /* (max is bottom)   */\n    Otherwise;                      /* could use left & right too    */\n  End\nEnd                                        /* End of display loop    */\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "DYNAREA": {"ttr": 1821, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x03\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00\\x14\\x00\\x14\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:03", "lines": 20, "newlines": 20, "modlines": 0, "user": "KANNAN"}, "text": ")ATTR\n @ AREA(DYNAMIC)   SCROLL(ON) EXTEND(ON)\n 01 TYPE(DATAOUT)  COLOR(RED)\n 02 TYPE(DATAOUT)  COLOR(BLUE)\n 03 TYPE(DATAOUT)  COLOR(GREEN)\n 04 TYPE(DATAOUT)  COLOR(WHITE)\n $  TYPE(TEXT)     COLOR(YELLOW)\n)BODY\n%------------------  EXAMPLE FOR USING A DYNAMIC AREA  ------------------------%\n%COMMAND ===>_ZCMD                                            %SCROLL ===>_AMT +\n%\n+ This area is fixed.   size: &size\n+\n+ This is an input field%===>_somevar +\n+\n+This is extendable  @DYNAREA                     @\n\n       $This should be at the bottom of the screen when in full screen.\n)END\n\u001a\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "EDITALL": {"ttr": 2049, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x03\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00\\x1e\\x00\\x1e\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:03", "lines": 30, "newlines": 30, "modlines": 0, "user": "KANNAN"}, "text": "/* Rexx */\narg dsn exec opt3\nif dsn = '' then do\n   say 'Need pds name to process'\n   say 'Syntax : EDITALL _dsn_ _imacro_ (VERBOSE)'\n   exit 1\nend\nif exec  = '' then do\n   say 'Need initial macro to apply'\n   say 'Syntax : EDITALL _dsn_ _imacro_ (VERBOSE)'\n   exit 1\nend\nif left(dsn,1) <> \"'\" then do\n   dsn = sysvar(syspref)\".\"dsn\nend\nelse do\n   dsn = substr(dsn,2,length(dsn)-2)\nend\nx = outtrap(\"lm.\",\"*\")\n\"listd\" \"'\"dsn\"'\" \"members\"\nx = outtrap(\"off\")\ndo i = 1 to lm.0\n   if lm.i = \"--MEMBERS--\" then signal domem\nend\ndomem:  do j = i+1 to lm.0\n        parse value lm.j with mem extra\n        address ispexec \"edit dataset('\"dsn\"(\"mem\")') macro(\"exec\")\"\n        if opt3 = 'VERBOSE' then\n           say j-6 '--' mem 'has been applied with macro' exec\n        end\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "EMPTYPDS": {"ttr": 2051, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x03\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00#\\x00#\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:03", "lines": 35, "newlines": 35, "modlines": 0, "user": "KANNAN"}, "text": "/* Rexx EmptyPDS                                                      */\n/* .................................................................. */\n/* Author  : AK                                                       */\n/* EmptyPDS: Zap PDS and compress                                     */\n/* Notice  : Supply unquoted DSN and 'C' for if compress needed       */\n/*         : There is a ZAPPDS in this pack with TSO Deletes          */\n/* Version : Alpha                                                    */\n/* .................................................................. */\nelapsed = time(r)\narg dsname opt\nif dsname = '' then exit\nfilen  = \"'\"||dsname||\"'\"\n  address tso \"alloc f(input) ds(\"filen\") reuse old\"\n  address ispexec\n  'lminit  dataid('dataid') ddname(input) enq(excl)'\n  'lmopen  dataid('dataid') option(output)'\n       x = listdsi(\"'\"dsname\"'\" directory norecall)\n       if sysdsorg = 'PO' & (sysmembers > 0) then do\n            x = outtrap('mout.','*','noconcat')\n            address tso \"listds '\"dsname\"' members\"\n            x = outtrap(off)\n            do c=7 by 1 while c <= mout.0\n              address ispexec\n             'lmmdel  dataid('dataid') member('strip(mout.c)')'\n            end\n       end\n  'lmclose dataid('dataid')'\n   if opt = 'C' then do\n     'lmcomp  dataid('dataid')'\n      say dsname ' has been compressed.'\n   end\n  'lmfree  dataid('dataid')'\nelapsed = time('e')\nsay 'Delete took' elapsed 'seconds.'\nexit 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "EOF": {"ttr": 2053, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x03\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00\\r\\x00\\r\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:03", "lines": 13, "newlines": 13, "modlines": 0, "user": "KANNAN"}, "text": "/* Rexx Check Emptiness */\nArg NT\nAddress TSO\n\"ALLOC DS(\"NT\") DD(\"TEMPDD\") SHR REUSE\"\n\"EXECIO 1 DISKR\" TEMPDD\nIf RC = 2 Then Say 'File is empty'\nElse\n   If RC = 0 Then Say 'File is not empty'\n   Else Say 'Error encountered ' RC\n\"EXECIO 0 DISKR\" TEMPDD \"(FINIS\"\n\"FREE DD(\"TEMPDD\")\"\n\"Delstack\"\nReturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "EOL": {"ttr": 2055, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x03\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00\\r\\x00\\r\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:03", "lines": 13, "newlines": 13, "modlines": 0, "user": "KANNAN"}, "text": "/* REXX  EOL */\nADDRESS ISPEXEC\n\"ISREDIT MACRO \"\n\"ISREDIT NUMBER OFF\"\n\"ISREDIT CHANGE P'========' '        ' 73 ALL\"\n ZEDSMSG = \".73-80 CLEARED.\"\n\"SETMSG MSG(ISRZ000)\"\n\"ISREDIT RESET\"\n\"ISREDIT FIND P'=' 1\"\nEXIT 1\n/* INCLUDE FOR RUNNING IN BATCH */\n\"ISREDIT SAVE\"\n\"ISREDIT END\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FINDMOD": {"ttr": 2057, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x03\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x01d\\x01d\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:03", "lines": 356, "newlines": 356, "modlines": 0, "user": "KANNAN"}, "text": "/* REXX  */\n/*                           */\n/* AUTHOR: MARK ZELDEN       */\n/*                           */\n/***********************************************************/\n/*  Quickly find the location of a module (or modules).    */\n/*  The specified module name may be fully qualified or    */\n/*  any valid ISPF member pattern.                         */\n/*                                                         */\n/*  By default, the LPA and LNKLST concatenation are       */\n/*  searched. Alternatively, a \"search list member\" may    */\n/*  be specified. In order to use the search list, the     */\n/*  libraries to search must be manually added to a        */\n/*  PDS member (or members).                               */\n/*                                                         */\n/*  The library that the optional search member list must  */\n/*  reside in is defined by the MBRLIB variable below.     */\n/*  A suggested member list name is FINDxxxx where xxxx is */\n/*  the SMFID of the system, or a descriptive name such    */\n/*  as FINDPROC or FINDCICS. The search list should        */\n/*  specify only one library per line. An \"*\" in column    */\n/*  one indicates the line is a comment.                   */\n/*                                                         */\n/*  SAMPLE SEARCH LIST:                                    */\n/*  *---+----1----+----2----+----3----+----4----+----5     */\n/*  ******************************                         */\n/*  * PROC LIBS                                            */\n/*  ******************************                         */\n/*  SYS1.PROCLIB                                           */\n/*  SYS1.IBM.PROCLIB                                       */\n/*  USER.PROCLIB                                           */\n/*  ******************************                         */\n/*  * CLIST LIBS                                           */\n/*  ******************************                         */\n/*  SYS1.CLIST                                             */\n/*  USER.CLIST1                                            */\n/*  USER.CLIST2                                            */\n/*                                                         */\n/***********************************************************/\n/* EXECUTION SYNTAX:                                       */\n/*                                                         */\n/* TSO %FINDMOD <mbr pattern> (search list name) (BOTH)    */\n/*                                                         */\n/* If a search list name is specified, only the libraries  */\n/* in the search list will be searched, unless the \"BOTH\"  */\n/* option is used. The \"BOTH\" option will search the       */\n/* libraries in the search list first, then the LPA and    */\n/* LNKLST.                                                 */\n/*                                                         */\n/* EXAMPLES:                                               */\n/* TSO %FINDMOD         (will prompt for module name)      */\n/* TSO %FINDMOD IEFBR14 (search LPA & LNKLST for IEFBR14)  */\n/* TSO %FINDMOD LLA FINDPROC (find LLA using FINDPROC list)*/\n/* TSO %FINDMOD A%R*  (use mask to search LPA & LNKLST)    */\n/* TSO %FINDMOD MYPROG BOTH (use list, LPA, & LNKLST)      */\n/*                                                         */\n/* NOTE: This exec can be executed as an ISPF EDIT MACRO   */\n/*   from ISPF EDIT or VIEW from the command line without  */\n/*   using the \"TSO\" prefix.  Example: FINDMOD IEFBR14     */\n/***********************************************************/\narg NAME MEMBER OPT DEBUG\n/***********************************************************/\nLASTUPD = '04/24/2001'     /* date of last update          */\n/***********************************************************/\nparse upper arg\nIf Sysvar(SYSISPF) <> 'ACTIVE' then do\n  Say 'FINDMOD must be invoked from ISPF, terminating!'\n  Exit 12\nEnd\naddress ISREDIT \"MACRO (NAME MEMBER OPT DEBUG)\"\nNAME   = translate(NAME)    /* chg to upper case for edit macro */\nMEMBER = translate(MEMBER)  /* chg to upper case for edit macro */\nOPT    = translate(OPT)     /* chg to upper case for edit macro */\nDEBUG  = translate(DEBUG)   /* chg to upper case for edit macro */\nIf OPT <> '' & OPT <> 'BOTH' then do\n  Say '\"BOTH\" is the only valid option'\n  Exit 8\nEnd\nIf debug = 'DEBUG' then trace ?i\n/*********************************************************/\n/* MBRLIB  = 'SYS2.PARMLIB'  */\nMBRLIB  = 'MPSYS3.USZ1000.CNTL'\n/*********************************************************/\nNUMLIBS = 0  /* total number of libraries to be searched */\ncall CHECK_MODNAME           /* check module name syntax */\nIf MEMBER = '' then call GET_LPALNK  /* use LPA/LNKLST   */\nElse do\n  Call GET_LIBNAMES          /* use optional search list */\n  If OPT = 'BOTH' then call GET_LPALNK /* use LPA/LNKLST */\nEnd\n/*********************************************************/\n/*   BEGIN MODULE SEARCH                                 */\n/*********************************************************/\nFOUND = 'NO' /* found flag */\nIf member = '' then do\n  Say   '...Searching for 'name' in 'numlibs' libraries'\n  Say   '   (Using LPA & LNKLST' || setname || ')'\n  Queue '...Searching for 'name' in 'numlibs' libraries'\n  Queue '   (Using LPA & LNKLST' || setname || ')'\nEnd\nElse do\n  If OPT = 'BOTH' then do\n    Say   '...Searching for 'name' in 'numlibs' libraries'\n    Say   '   (Using list 'member || ', LPA,' ,\n          '& LNKLST' || setname || ')'\n    Queue '...Searching for 'name' in 'numlibs' libraries'\n    Queue '   (Using list 'member || ', LPA,' ,\n          '& LNKLST' || setname || ')'\n  End\n  Else Do\n    Say   '...Searching for 'name' in 'numlibs' libraries'\n    Say   '   (Using search list 'member || ')'\n    Queue '...Searching for 'name' in 'numlibs' libraries'\n    Queue '   (Using search list 'member || ')'\n  End\nEnd\nSay   '   '\nQueue '   '\nDo SEARCH = 1 to LIB.0\n  LIB.SEARCH = word(LIB.SEARCH,1)\n  /* Say   'Searching' lib.search  */\n  /* Queue 'Searching' lib.search  */\n  Address ISPEXEC \"LMINIT DATAID(FINDMOD1) DATASET('\"lib.search\"')\"\n  If RC <> 0 then do\n    Say   Strip(ZERRLM)\n    Queue Strip(ZERRLM)\n    Iterate  /* go get next library to search on error */\n  End /* if RC <> 0 */\n  Address ISPEXEC \"LMOPEN DATAID(\"FINDMOD1\") RECFM(RFVAR)\"\n  If RC <> 0 then do\n    Say   Strip(ZERRLM)\n    Queue Strip(ZERRLM)\n    Address ISPEXEC \"LMFREE DATAID(\"FINDMOD1\")\"\n    Iterate  /* go get next library to search on error */\n  End /* if RC <> 0 */\n  MEMVAR = ' '\n  ZLM4DATE = '' /* reset each new library because of stats yes/no */\n  Do forever\n    If RFVAR = 'FB' then ,\n      Address ISPEXEC \"LMMLIST DATAID(\"FINDMOD1\") OPTION(LIST) \",\n              \"MEMBER(MEMVAR) PATTERN(\"NAME\") STATS(YES)\"\n    Else ,\n      Address ISPEXEC \"LMMLIST DATAID(\"FINDMOD1\") OPTION(LIST) \",\n              \"MEMBER(MEMVAR) PATTERN(\"NAME\") STATS(NO)\"\n    If RC = 0 then do  /* match found */\n      FOUND = 'YES'\n      If ZLM4DATE = 'ZLM4DATE' | ZLM4DATE = '' then do /* no stats */\n        Say   memvar 'found in' lib.search\n        Queue memvar 'found in' lib.search\n      End\n      Else do /* stats */\n        Say   memvar 'found in' lib.search \"(Lastupd \"ZLM4DATE\")\"\n        Queue memvar 'found in' lib.search \"(Lastupd \"ZLM4DATE\")\"\n      End\n    End\n    Else do  /* no match found, or no more in list */\n      Address ISPEXEC \"LMCLOSE DATAID(\"FINDMOD1\")\"\n      Address ISPEXEC \"LMFREE DATAID(\"FINDMOD1\")\"\n      Leave /* leave loop, go search next library if any */\n    End /* else do */\n  End  /* do forever */\nEnd /* do SEARCH */\nIf FOUND = 'NO' then do\n  Say   NAME 'was not found in any library'\n  Queue NAME 'was not found in any library'\nEnd\n/*********************************************************************/\n/* Browse results                                                    */\n/*********************************************************************/\nQueue ''  /* null queue to end stack   */\nAddress ISPEXEC \"CONTROL ERRORS RETURN\"\nAddress ISPEXEC \"VGET ZENVIR\"\nAddress TSO\nprefix = sysvar('SYSPREF')        /* tso profile prefix            */\nuid    = sysvar('SYSUID')         /* tso userid                    */\nIf prefix = '' then prefix = uid  /* use uid if null prefix        */\nIf prefix <> '' & prefix <> uid then /* different prefix than uid  */\n   prefix = prefix || '.' || uid /* use  prefix.uid                */\nddnm1 = 'DD'||random(1,99999)   /* choose random ddname            */\nddnm2 = 'DD'||random(1,99999)   /* choose random ddname            */\njunk = msg(off)\n\"ALLOC FILE(\"||ddnm1||\") UNIT(SYSALLDA) NEW TRACKS SPACE(2,1) DELETE\",\n      \" REUSE LRECL(80) RECFM(F B) BLKSIZE(3120)\"\n\"ALLOC FILE(\"||ddnm2||\") UNIT(SYSALLDA) NEW TRACKS SPACE(1,1) DELETE\",\n      \" REUSE LRECL(80) RECFM(F B) BLKSIZE(3120) DIR(1)\",\n      \" DA('\"||prefix||\".FINDMOD.\" ||ddnm2|| \".ISPPLIB')\"\njunk = msg(on)\nNewstack\n/*************************/\n/* FINDMODP Panel source */\n/*************************/\nIf Substr(ZENVIR,6,1) >= 4 then\n  Queue \")PANEL KEYLIST(ISRSPBC,ISR)\"\nQueue \")ATTR\"\nQueue \"  _ TYPE(INPUT)   INTENS(HIGH) COLOR(TURQ) CAPS(OFF)\" ,\n      \"FORMAT(&MIXED)\"\nQueue \"  | AREA(DYNAMIC) EXTEND(ON)   SCROLL(ON)\"\nQueue \"  + TYPE(TEXT)    INTENS(LOW)  COLOR(BLUE)\"\nQueue \"  @ TYPE(TEXT)    INTENS(LOW)  COLOR(TURQ)\"\nQueue \"  % TYPE(TEXT)    INTENS(HIGH) COLOR(GREEN)\"\nQueue \"  ! TYPE(OUTPUT)  INTENS(HIGH) COLOR(TURQ) PAD(-)\"\nQueue \" 01 TYPE(DATAOUT) INTENS(LOW)\"\nQueue \" 02 TYPE(DATAOUT) INTENS(HIGH)\"\nQueue \" 0B TYPE(DATAOUT) INTENS(HIGH) FORMAT(DBCS)\"\nQueue \" 0C TYPE(DATAOUT) INTENS(HIGH) FORMAT(EBCDIC)\"\nQueue \" 0D TYPE(DATAOUT) INTENS(HIGH) FORMAT(&MIXED)\"\nQueue \" 10 TYPE(DATAOUT) INTENS(LOW)  FORMAT(DBCS)\"\nQueue \" 11 TYPE(DATAOUT) INTENS(LOW)  FORMAT(EBCDIC)\"\nQueue \" 12 TYPE(DATAOUT) INTENS(LOW)  FORMAT(&MIXED)\"\nQueue \")BODY EXPAND(//)\"\nQueue \"%BROWSE  @&ZTITLE  / /  %Line!ZLINES  %Col!ZCOLUMS+\"\nQueue \"%Command ===>_ZCMD / /           %Scroll ===>_Z   +\"\nQueue \"|ZDATA ---------------/ /-------------------------|\"\nQueue \"|                     / /                         |\"\nQueue \"| --------------------/-/-------------------------|\"\nQueue \")INIT\"\nQueue \"  .HELP = ISR10000\"\nQueue \"  .ZVARS = 'ZSCBR'\"\nQueue \"  &ZTITLE = 'Mark''s MVS Utilities - FINDMOD'\"\nQueue \"  &MIXED = MIX\"\nQueue \"  IF (&ZPDMIX = N)\"\nQueue \"   &MIXED = EBCDIC\"\nQueue \"  VGET (ZSCBR) PROFILE\"\nQueue \"  IF (&ZSCBR = ' ')\"\nQueue \"   &ZSCBR = 'CSR'\"\nQueue \")REINIT\"\nQueue \"  REFRESH(ZCMD,ZSCBR,ZDATA,ZLINES,ZCOLUMS)\"\nQueue \")PROC\"\nQueue \"  &ZCURSOR = .CURSOR\"\nQueue \"  &ZCSROFF = .CSRPOS\"\nQueue \"  &ZLVLINE = LVLINE(ZDATA)\"\nQueue \"  VPUT (ZSCBR) PROFILE\"\nQueue \")END\"\nQueue \"\"\n/*                                    */\n\"ALLOC FILE(FINDMODP) SHR REUSE\",\n      \" DA('\"||prefix||\".FINDMOD.\" ||ddnm2|| \".ISPPLIB(FINDMODP)')\"\n\"EXECIO * DISKW FINDMODP (FINIS\"\n\"FREE FI(FINDMODP)\"\nDelstack\n\"EXECIO * DISKW\" ddnm1 \"(FINIS\"\nIf FOUND = 'NO' then zedsmsg = NAME 'NOT FOUND'\n                else zedsmsg = NAME 'WAS FOUND'\nzedlmsg = 'FINDMOD - Last updated  on' ,\n           LASTUPD ||'. Written by' ,\n          'Mark Zelden. Mark''s MVS Utilities -' ,\n          'http://home.flash.net/~mzelden/mvsutil.html'\nAddress ISPEXEC \"LIBDEF ISPPLIB LIBRARY ID(\"ddnm2\") STACK\"\nIf FOUND = 'NO' then ,\n  Address ISPEXEC \"SETMSG MSG(ISRZ001)\"  /* msg - with alarm  */\nElse ,\n  Address ISPEXEC \"SETMSG MSG(ISRZ000)\"  /* msg - no alarm    */\nAddress ISPEXEC \"LMINIT DATAID(TEMP) DDNAME(\"ddnm1\")\"\nAddress ISPEXEC \"BROWSE DATAID(\"temp\") PANEL(FINDMODP)\"\nAddress ISPEXEC \"LMFREE DATAID(\"temp\")\"\nAddress ISPEXEC \"LIBDEF ISPPLIB\"\njunk = msg(off)\n\"FREE FI(\"ddnm1\")\"\n\"FREE FI(\"ddnm2\")\"\nExit\n\n/*******************************************/\n/*  SUB ROUTINES                           */\n/*******************************************/\n\nCHECK_MODNAME:\nIf NAME = '' then do\n  Say 'Please enter module name or pattern to find:'\n  Parse upper pull name\n  Call CHECK_MODNAME\nEnd\nIf length(NAME) >8  then do\n  Say 'Module name' NAME 'invalid - must be less that 8 chars.'\n  Say 'Please re-enter module name or pattern to find:'\n  Parse upper pull name\n  Call CHECK_MODNAME\nEnd\nReturn\n\nGET_LIBNAMES:\nCHKMBR = sysdsn(\"'\"mbrlib\"(\"member\")'\")\nIf  CHKMBR <> 'OK' then do\n  Say ''\n  Say 'Search list member 'member' does not exist in 'mbrlib\n  Say ''\n  Exit 8\nEnd\njunk = msg(off)\n\"ALLOC DA('\"||mbrlib||\"(\"||member||\")') F(LIBLIST) SHR REUSE\"\n\"EXECIO * DISKR LIBLIST (STEM LIST. FINIS\"\n\"FREE F(LIBLIST)\"\njunk = msg(on)\nDo COUNT = 1 to LIST.0\n  LIBNAME = word(LIST.COUNT,1)\n  If substr(LIBNAME,1,1) = '*' then iterate\n  NUMLIBS = NUMLIBS + 1\n  LIB.NUMLIBS = LIBNAME\nEnd /* do count */\nLIB.0 = NUMLIBS   /* tot libs to search*/\nReturn\n\nGET_LPALNK:\nCVT      = C2d(Storage(10,4))                /* point to CVT        */\nFMIDNUM  = Storage(D2x(CVT - 32),7)          /* point to fmid       */\n/*                                                                  */\n/* GET LPA LIST                                                     */\n/*                                                                  */\nCVTSMEXT = C2d(Storage(D2x(CVT + 1196),4))  /* point to stg map ext.*/\nCVTEPLPS = C2d(Storage(D2x(CVTSMEXT+56),4)) /* point to stg map ext.*/\nNUMLPA   = C2d(Storage(D2x(CVTEPLPS+4),4))  /* # LPA libs in table  */\nLPAOFF   = 8                                /* first ent in LPA tbl */\nDo I = 1 to NUMLPA\n  LEN = C2d(Storage(D2x(CVTEPLPS+LPAOFF),1)) /* length of entry     */\n  DSN = Storage(D2x(CVTEPLPS+LPAOFF+1),LEN)  /* DSN of LPA library  */\n  LPAOFF = LPAOFF + 44 + 1                   /* next entry in table */\n  NUMLIBS = NUMLIBS + 1                      /* add 1 to tot libs   */\n  LIB.NUMLIBS = DSN                          /* add dsn to stem     */\nEnd\n/*                                                                  */\n/* GET LNKLST                                                       */\n/*                                                                  */\nIf Substr(FMIDNUM,4,4) < 6602 then do   /* pre os/390 1.2 system?   */\n  CVTLLTA  = C2d(Storage(D2x(CVT + 1244),4))  /* point to lnklst tbl*/\n  NUMLNK   = C2d(Storage(D2x(CVTLLTA+4),4))   /* # LNK libs in table*/\n  LNKOFF   = 8                                /*first ent in LBK tbl*/\n  SETNAME  = ''   /* no LNKLST set for pre OS/390 1.2 systems       */\n  Do I = 1 to NUMLNK\n     LEN = C2d(Storage(D2x(CVTLLTA+LNKOFF),1)) /* length of entry   */\n     DSN = Storage(D2x(CVTLLTA+LNKOFF+1),LEN)  /* DSN of LNK lib    */\n     LNKOFF = LNKOFF + 44 + 1                  /* next entry in tbl */\n     NUMLIBS = NUMLIBS + 1                     /* add 1 to tot libs */\n     LIB.NUMLIBS = DSN                         /* add dsn to stem   */\n  End\nEnd\nElse do  /* OS/390 1.2 and above - PROGxx capable LNKLST            */\n  ASCB     = C2d(Storage(224,4))             /* point to ASCB       */\n  ASSB     = C2d(Storage(D2x(ASCB+336),4))   /* point to ASSB       */\n  DLCB     = C2d(Storage(D2x(ASSB+236),4))   /* point to CSVDLCB    */\n  SETNAME  = Storage(D2x(DLCB + 36),16)      /* LNKLST set name     */\n  SETNAME  = Strip(SETNAME,T)                /* del trailing blanks */\n  CVTLLTA  = C2d(Storage(D2x(DLCB + 16),4))  /* point to lnklst tbl */\n  LLTX     = C2d(Storage(D2x(DLCB + 20),4))  /* point to LLTX       */\n  NUMLNK   = C2d(Storage(D2x(CVTLLTA+4),4))  /* # LNK libs in table */\n  LNKOFF   = 8                               /*first ent in LLT tbl */\n  Do I = 1 to NUMLNK\n    LEN = C2d(Storage(D2x(CVTLLTA+LNKOFF),1))  /* length of entry   */\n    LKDSN = Storage(D2x(CVTLLTA+LNKOFF+1),LEN) /* DSN of LNK lib    */\n    LNKOFF = LNKOFF + 44 + 1                   /* next entry in LLT */\n    NUMLIBS = NUMLIBS + 1                      /* add 1 to tot libs */\n    LIB.NUMLIBS = LKDSN                        /* add dsn to stem   */\n  End\n  SETNAME  = ' Set 'SETNAME\nEnd\nLIB.0 = NUMLIBS                                /* tot libs to search*/\nReturn\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FOCERR": {"ttr": 2064, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x03\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00T\\x00T\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:03", "lines": 84, "newlines": 84, "modlines": 0, "user": "KANNAN"}, "text": "/* Rexx                                                               */\n/* Function : Return FOCUS Error for Message Number                   */\n/* A bit of my tryst with FOCUS                                       */\nAddress ISPEXEC\nArg MsgNum\nParse Value MsgNum With m1 m2 m3 m4 m5 .\nIf Length(MsgNum) = 0 Then Do\n   ZEDLMSG = \"Provide a message number to query\"\n   \"SETMSG MSG(ISRZ001)\"\n   Return\nEnd\nIf (Datatype(m1) <> 'NUM' & Length(m1) <> 0) |,\n   (Datatype(m2) <> 'NUM' & Length(m2) <> 0) |,\n   (Datatype(m3) <> 'NUM' & Length(m3) <> 0) |,\n   (Datatype(m4) <> 'NUM' & Length(m4) <> 0) |,\n   (Datatype(m5) <> 'NUM' & Length(m5) <> 0) Then Do\n   ZEDLMSG = \"FOCUS error message number should be numeric\"\n   \"SETMSG MSG(ISRZ001)\"\n   Return\nEnd\n'Control Errors Return'\nAddress TSO\n/* System Files */\n\"Alloc DD(ERRORS  ) DS('SYS1.FOCUS.PROD.ERRORS.DATA'          ) SHR REU\"\n\"Alloc DD(FOCEXEC ) DS('SYS1.FOCUS.PROD.FOCEXEC.DATA'         ) SHR REU\"\n\"Alloc DD(FOCCTL  ) DS('SYS1.FOCUS.PROD.FOCCTL.DATA'          ) SHR REU\"\n/* Work Files */\n\"Alloc DD(FOCSTACK) UNIT(VIO) NEW DEL REU\"\n\"Alloc DD(HOLDMAST) UNIT(VIO) NEW DEL REU\"\n\"Alloc DD(FOCSORT ) UNIT(VIO) NEW DEL REU\"\n\"Alloc DD(HOLD    ) UNIT(VIO) NEW DEL REU\"\n\"Alloc DD(QQREPQQ) REU NEW DEL UNIT(SYSDA) LRECL(80) RECFM(F B)\" ,\n      \"SPACE(10,10) TRACK RELEASE DSO(PS) BLKSIZE(0)\"\n\"Alloc DD(SYSIN) REU NEW DEL UNIT(SYSDA) LRECL(80) RECFM(F B)\" ,\n      \"SPACE(10,10) TRACK RELEASE DSO(PS) BLKSIZE(0)\"\nCall GetTempFile\n/* Write the query */\nDo Queued();Pull;End\nQueue '-TYPE  ----------------------------------------'\nQueue '-TYPE  QUERY FOCUS ERROR AND DISPLAY ERROR TEXT'\nQueue '-TYPE  ----------------------------------------'\nIf Length(m1) <> 0 Then Queue '? 'm1\nIf Length(m2) <> 0 Then Queue '? 'm2\nIf Length(m3) <> 0 Then Queue '? 'm3\nIf Length(m4) <> 0 Then Queue '? 'm4\nIf Length(m5) <> 0 Then Queue '? 'm5\n\"EXECIO\" Queued() \"DISKW QQREPQQ (FINIS\"\n/* Tell FOCUS to run it */\nDo Queued();Pull;End\nQueue 'EX QQREPQQ'\nQueue 'FIN'\n\"EXECIO\" Queued() \"DISKW SYSIN (FINIS\"\nAddress TSO \"CALL 'SYS6.FOCUS.PROD.FOCLIB.LOAD(FOCUS)'\"\nDo Queued();Pull;End\nAddress ISPEXEC 'LMINIT DATAID(TRAP) DDNAME('ddname') ENQ(SHR)'\nAddress ISPEXEC 'BROWSE DATAID('TRAP')'\nAddress ISPEXEC 'LMFREE DATAID('TRAP')'\n\n\"Free DD(ERRORS  )\"\n\"Free DD(FOCEXEC )\"\n\"Free DD(FOCCTL  )\"\n\"Free DD(FOCSTACK)\"\n\"Free DD(HOLDMAST)\"\n\"Free DD(FOCSORT )\"\n\"Free DD(HOLD    )\"\n\"Free DD(QQREPQQ )\"\nX = OUTTRAP('juNk','*','NOCONCAT')\nAddress TSO \"Delete \"NT\nX = OUTTRAP(OFF)\nReturn\n\nGetTempFile :\nddname = 'SYSPRINT'\nD = Date(j);R1 = Random(100,999);R2 = Random(100,999);\nT = Time();Parse Value T with hh ':' mm ':' ss;TT=hh||mm||ss\nNT = 'FOC'D||'.T'||R1||Trunc(R1*R2/Random()/10)||'.Z'||TT\nAddress TSO\n\"Alloc DS(\"NT\") DD(\"ddname\") Dsorg(PS) Lrecl(80) Recfm(F B)\" ,\n\"New Reu Unit(VIO)\"\nIf RC \\= 0 Then Do\n       \"ISPEXEC SetMsg Msg(ISRZ002)\"\n       Exit\nEnd\nReturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FRAGPNL": {"ttr": 2067, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x03\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00\\x08\\x00\\x08\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:03", "lines": 8, "newlines": 8, "modlines": 0, "user": "KANNAN"}, "text": ")ATTR\n$ TYPE(OUTPUT) INTENS(HIGH) PAD(' ')\n)BODY WINDOW(50,3)\n PDS:$pdsout\n Status:$statout\n\n)PROC\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "GDGL": {"ttr": 2305, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x03\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00\\x10\\x00\\x10\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:03", "lines": 16, "newlines": 16, "modlines": 0, "user": "KANNAN"}, "text": "/* Rexx GDGL                                                          */\n/* .................................................................. */\n/* Author  : Kannan AK                                                */\n/* GDGL    : LISTCAT GDG ALL                                          */\n/* Notice  : None                                                     */\n/* Version : Alpha                                                    */\n/* .................................................................. */\nArg str\nAddress TSO Clear\nAddress TSO \"LISTC ENTRIES(\"str\") GDG ALL\"\n       If RC > 0 Then Do\n          ZEDSMSG = '*Obtain Failed*'\n          \"ISPEXEC SETMSG MSG(ISRZ001)\"\n          Exit 0\n       End\nExit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GE": {"ttr": 2307, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x03\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00\\x1f\\x00\\x1f\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:03", "lines": 31, "newlines": 31, "modlines": 0, "user": "KANNAN"}, "text": "/* REXX */\n  vals='85c4c5c6c7c7d3d4d5d6d7a2'x\n  d=xrange('00'x,'FF'x)\n  shad =copies('#',18)||copies('#'copies('$',16)'#',16)copies('#',18)\n  shad2=copies('#',18)||copies('#'copies('\"',16)'#',16)copies('#',18)\n  bot='c4'x||copies('a2'x,16)||'d4'x\n  dyn='c5'x||copies('a2'x,16)||'d5'x\n  Do a = 1 to 16\n     dyn=dyn||'85'x||substr(d,1+(a-1)*16,16)||'85'x\n  End\n  dyn=dyn||bot\n  dyn2 = dyn\n  alpha='ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n  alpha=alpha||'abcdefghijklmnopqrstuvwxyz'\n  alphage=alpha\n  shad3=copies('$',52)\n  dyn4= copies('s',80)\n  shad4=copies('#',80)\n\n  d='EsssssssNe EsPsN ee e e e ee FsLsO ee e e e ee DsGsM eDsssssssM'\n  e=d\n  s='########## $$$$$ ## $ $ $ ## $$$$$ ## $ $ $ ## $$$$$ ##########'\n  t='########## \"\"\"\"\" ## \" \" \" ## \"\"\"\"\" ## \" \" \" ## \"\"\"\"\" ##########'\n\n  b='EsssssssNe klllj ee k C j ee k n j ee kmmmj eDsssssssM'\n  c='EsssssssNe klllj ee k C j ee k n j ee kmmmj eDsssssssM'\n  q='########## $$$$$ ## $ $ $ ## $ $ $ ## $$$$$ ##########'\n  v='########## \"\"\"\"\" ## \" \" \" ## \" \" \" ## \"\"\"\"\" ##########'\n  Do Until rc > 0\n    Address ispexec 'DISPLAY PANEL(GEPNL)'\n  End\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GEBAR": {"ttr": 2309, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x03\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00&\\x00&\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:03", "lines": 38, "newlines": 38, "modlines": 0, "user": "KANNAN"}, "text": "/* Rexx GEBAR                                                         */\n/* .................................................................. */\n/* Author  : AK                                                       */\n/* GEBAR   : Display progress bar with Graphic Escape                 */\n/* Notice  : Use ON parmeter to enable color cycling                  */\n/* Version : Alpha                                                    */\n/* .................................................................. */\nArg ColorCyl\nAddress Ispexec\nBARCHAR    = ''\nBARDYE     = 'TURQ'\nbarpointer = 0\nWIPMSG     = 'Processing...'\nDo I = 1 To 1000\n      If barpointer > 50 Then Do\n         BARCHAR = ''\n         barpointer = 0\n         If ColorCyl = 'ON' Then Do\n            Select\n              When BARDYE  = 'YELLOW' Then BARDYE  = 'RED'\n              When BARDYE  = 'RED'    Then BARDYE  = 'BLUE'\n              When BARDYE  = 'BLUE'   Then BARDYE  = 'TURQ'\n              When BARDYE  = 'TURQ'   Then BARDYE  = 'WHITE'\n              When BARDYE  = 'WHITE'  Then BARDYE  = 'PINK'\n              When BARDYE  = 'PINK'   Then BARDYE  = 'YELLOW'\n            End\n         End\n      End\n      Else Do\n         BARCHAR = Copies('k',barpointer)\n         barpointer = barpointer + 1\n      End\n      \"Control display lock\"\n      \"Addpop\"\n      \"Display panel(gebarpnl)\"\n      \"Rempop\"\nEnd\nReturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GEBARPNL": {"ttr": 2311, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x03\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00\\x10\\x00\\x10\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:03", "lines": 16, "newlines": 16, "modlines": 0, "user": "KANNAN"}, "text": ")ATTR\n+ TYPE(TEXT)\n* AREA(DYNAMIC) SCROLL(OFF)     EXTEND(OFF)\n# TYPE(CHAR)    COLOR(&BARDYE)  GE(ON)\n)BODY  WINDOW(52,5)\n%                                                +\n+ &WIPMSG                                        +\n%                                                +\n *BARCHAR,BARSHAD                                *\n%                                                +\n)INIT\n &ZWINTTL = ''\n &BARSHAD = '##################################################'\n)PROC\n &ZWINTTL = ''\n)END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "GEBARR": {"ttr": 2313, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x03\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00&\\x00&\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:03", "lines": 38, "newlines": 38, "modlines": 0, "user": "KANNAN"}, "text": "/* Rexx */\nArg ColorCyl\nAddress Ispexec\nBARCHAR = ''\nBARDYE  = 'TURQ'\nbarpointer = 0\n\"Control display lock\"\nDo I = 1 To 400\n      If barpointer = 50 Then Do\n         Do until barpointer = 0\n            barpointer = barpointer - 1\n            BARCHAR = Reverse(Copies('k',barpointer))\n      \"Addpop\"\n      \"Display panel(gebarpnl)\"\n      \"Rempop\"\n         End\n      End\n      If barpointer = 0 Then Do\n         Do until barpointer = 50\n            barpointer = barpointer + 1\n            BARCHAR = Copies('k',barpointer)\n      \"Addpop\"\n      \"Display panel(gebarpnl)\"\n      \"Rempop\"\n         End\n      End\nEnd\nReturn\n         If ColorCyl = 'ON' Then Do\n            Select\n              When BARDYE  = 'YELLOW' Then BARDYE  = 'RED'\n              When BARDYE  = 'RED'    Then BARDYE  = 'BLUE'\n              When BARDYE  = 'BLUE'   Then BARDYE  = 'TURQ'\n              When BARDYE  = 'TURQ'   Then BARDYE  = 'WHITE'\n              When BARDYE  = 'WHITE'  Then BARDYE  = 'PINK'\n              When BARDYE  = 'PINK'   Then BARDYE  = 'YELLOW'\n            End\n         End\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GEPNL": {"ttr": 2315, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x03\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00!\\x00!\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:03", "lines": 33, "newlines": 33, "modlines": 0, "user": "KANNAN"}, "text": ")ATTR\n + type(text) color(turq)\n ! type(text) color(yellow)\n \" type(char) color(white)\n $ type(char) color(yellow) ge(on)\n # type(char) color(white ) ge(on)\n @ area(dynamic) scroll(off) extend(off)\n)BODY\n%------------------------  GRAPHIC ESCAPE CHARACTERS  ------------------------%\n           +   0123456789ABCDEF        0123456789ABCDEF      Terminal:!&ZTERM\n+             @DYN,SHAD2       @      @DYN2,SHAD       @    +ZGE setting:!&ZGE\n  %Normal-->+0@                @0    0@                @0%<--Graphic\n  +          1@                @1    1@                @1 %  Escape\n  +          2@                @2    2@                @2\n             3@                @3    3@                @3\n             4@                @4    4@                @4  @b,v    @@c,q    @\n             5@                @5    5@                @5  @       @@       @\n             6@                @6    6@                @6  @       @@       @\n             7@                @7    7@                @7  @       @@       @\n             8@                @8    8@                @8  @       @@       @\n             9@                @9    9@                @9  @       @@       @\n             A@                @A    A@                @A  @d,t    @@e,s    @\n             B@                @B    B@                @B  @       @@       @\n             C@                @C    C@                @C  @       @@       @\n             D@                @D    D@                @D  @       @@       @\n             E@                @E    E@                @E  @       @@       @\n             F@                @F    F@                @F  @       @@       @\n              @                @      @                @   @       @@       @\n               0123456789ABCDEF        0123456789ABCDEF %\n@dyn4,shad4                                                                    @\n            %&ALPHA                                              %\n             @ALPHAGE,SHAD3                                     @\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GMT": {"ttr": 2317, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x03\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00\\n\\x00\\n\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:03", "lines": 10, "newlines": 10, "modlines": 0, "user": "KANNAN"}, "text": "/* REXX GMT OFFSET */\n/* GET THE LOCAL OFFSET FROM GMT */\nCVT   = STORAGE(10,4)                      /*GET THE CVT ADDRESS*/\nCVTTZ = STORAGE(D2X(C2D(CVT)+X2D(130)),4)  /*GET CVTTZ VALUE*/\nGMT_OFFSET = TRUNC(C2D(CVTTZ,4) * 1.048576 / 3600) /*CONVERT TO OFFSET*/\nIF SIGN(GMT_OFFSET) < 0 THEN GMT_SIGN = '-'\n                        ELSE GMT_SIGN = '+'\nGMT_OFFSET_HHMM = GMT_SIGN||RIGHT(ABS(GMT_OFFSET)*100,4,'0') /*FORMAT*/\nSAY GMT_OFFSET_HHMM\nEXIT\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "GOTCHAS": {"ttr": 2319, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x03\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00C\\x00C\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:03", "lines": 67, "newlines": 67, "modlines": 0, "user": "KANNAN"}, "text": "-*- ca-librarian call for index -*-\ntso libindex * dssource('sysak.lib.cobol') short/long\n\n-*- ispf configuration utility -*-\ntso ispcconf\n\ntso ispmlist 'sys1.vtocix.by3214' format\n\ntso isrepdf 'sysak.hanna.exec($)' view\ntso isrepdf ?\n\nsdsf: xdc to unspool block- xd-x-x-x-xc\n\n-*- edit macro upper case and lower case -*-\nlc and uc edit commands\n\n-*- what is being edited -*-\nisredit dataid,dataset,member\n\ntso ispvcall status\n\n-*- temp files probably on vio -*-\nispctl\u00dd0-4\u00a8\n\n3.4: b /(member)\n\n3.4: dataset can be overtyped w/ command\n\nhit on system id to get sysplex/sysnode in status area\n\n\"vget (zeditcmd)\" gives last known edit operation\n\nexit 1 will return cursor to home;clear zcmd\n\ntso isrddn;browse 00aff5a0. for your username. include dot.\n\nsys1.samplib(iggcsirx)  catalog search interface (csi) example\n\ntso isrddn;enq;\n\n\"control display line start(1)\"\n\n-*- get hilite dump -*-\nhi dump;enter twice; see plex.dump\n\nhas hilite strings sys1.sispsamp(isrpxasm)\n\nmax tiot - max concat in dd name (1635) | sys1.parmlib(alloc00)\n\nprocessing_mode=sysvar(sysenv)\n\nlast_command=sysvar(sysicmd)\n\n-*- read elsewhere -*-\nthe missing (s806), the glutton (sb37), the undivided (s0cb)\n the confused (s0c1), the lost (s0c4),\n the square peg in a round hole (s0c7), and the mismatched (s013).\n\nto find a member in tso isrrdn : m tsopcnct\n\nfile-aid: check out nep (not equal packed) and nen (not equalnumeric)\n\nedset to remove the  edit/view settings. remove abc. c&p defaults.\n\ncmde for extra space on tso command\n\ncolors : color/pscolor/mlc\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GREP": {"ttr": 2321, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x03\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00\\xc7\\x00\\xc7\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:03", "lines": 199, "newlines": 199, "modlines": 0, "user": "KANNAN"}, "text": "/* REXX find string outside of member and show the member list */\n/* (c) Copyright IBM Corp, 1995, 1999  All rights Reserved     */\n/*                                                             */\n/* *** WARNING ***                                             */\n/*   This depends on internal structures within ISPF.  These   */\n/*   structures are not an intended programming interface and  */\n/*   are subject to change at any time.                        */\n/*                                                             */\n/*   IBM PROVIDES THIS CODE ON AN \"AS IS\" BASIS WITHOUT        */\n/*   WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,          */\n/*   INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES     */\n/*   OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR            */\n/*   PURPOSE.                                                  */\n/*-------------------------------------------------------------*/\n/* Invocation:                                                 */\n/*    This is an edit macro.  If it is called SCANPDS then     */\n/*    the invocation is                                        */\n/*                                                             */\n/*          SCANPDS string                                     */\n/*                                                             */\n/*    where string is a quoted or non-quoted string.           */\n/*    The search is case-insensitive.                          */\n/*    The result is a member list of members containing the    */\n/*    string.  Concatenations are honored.                     */\n/*                                                             */\n/*    Version 1.00 - June 12, 1999 - initial release           */\n/*    Version 1.01 - June 14, 1999 - use popup for status      */\n/*    Version 1.02 - Sept 14, 1999 - free allocated dd names   */\n/*    Version 1.03 - Sept 14, 1999 - fix 1.02 (oops)           */\n/*ak  Version 1.04 - Aprl 05, 2002 - use space as edit service */\n/*                                   delay for readablity      */\n/*  Author: Doug Nadel                                         */\n/*          nadel@us.ibm.com                                   */\n/*-------------------------------------------------------------*/\nunitname = 'VIO'           /* Change this if allocations fail  */\nParse Source . . mname .\nAddress isredit\n'MACRO (INPARMS)';\nIf rc>0 Then\n  Do; Say mname 'must be invoked as an edit command.' ;Exit 0 ;End\nIf inparms='' Then\nDo;Say 'The 'mname' command requires a string to find.';Exit 12;End\nIf substr(inparms,1,1)=\"'\" Then Parse Var inparms \"'\" inparms \"'\" rest\nElse\nIf substr(inparms,1,1)='\"' Then Parse Var inparms '\"' inparms '\"' rest\nElse rest=''\nrest=translate(space(rest))\nIf rest\\='' Then rest=','rest\nUpper inparms\nCall getdsns\nParse Value zdsn.0 zdsn.1 zdsn.2 zdsn.3 With zdsn0 zdsn1 zdsn2 zdsn3\n'(MEMBER) = MEMBER'\nIf member = '' Then\n  Do\n   zerrsm='Must be partitioned'\n   zerrlm=mname' is only valid with partitioned data sets.'\n   zerrhm='*'\n   zerralrm='YES'\n   Address ispexec 'SETMSG MSG(ISRZ002)'\n   Exit 12\n  End\nAddress 'TSO'\n'ALLOC F(SYSIN) REUSE NEW DEL UNIT('unitname') LRECL(80) RECFM(F B)\n SPACE(10,10) TRACK RELEASE DSO(PS) BLKSIZE(80)'\nDo queued();Pull;End\nQueue 'SRCHFOR '''inparms''''rest\nAddress 'TSO'   'EXECIO 1 DISKW SYSIN (FINIS'\n'ALLOC F(NEWDD) DA('strip(zdsn.0 zdsn.1 zdsn.2 zdsn.3)') SHR REUSE'\nrdd='$'right(time(s),7,'0')\n'ALLOC F('rdd') DA('strip(zdsn.0 zdsn.1 zdsn.2 zdsn.3)') SHR REUSE'\n'ALLOC F(OUTDD) REUSE NEW DEL UNIT('unitname') LRECL(80) RECFM(F B)\nSPACE(10,10) TRACK RELEASE DSO(PS)'\nsupparm='SRCHCMP,ANYC,LMTO,NOSUMS,NOPRTCC,CKPACKL'\na=1\n'ALLOC NEW DEL F($UPDPAN) DSO(PO) DIR(1) SP(3,3) TRACK\n        REUSE RECFM(F B) BLKSIZE(0) LRECL(80) UNIT('unitname')'\nDo Until substr(line,1,7)='/*PANEL'\n  line = sourceline(a)\n  a=a+1\nEnd\nParse Var line . panelname .\nAddress ispexec\n'LMINIT DATAID(TMPPNL) ENQ(EXCLU) DDNAME($UPDPAN)'\n'LMOPEN DATAID('tmppnl') OPTION(OUTPUT)'\nDo Until substr(line,1,4)=')END'\n  line = sourceline(a)\n  'LMPUT DATAID(&TMPPNL) MODE(INVAR) DATALOC(LINE) DATALEN(80)'\n  a=a+1\nEnd\n'LMMADD DATAID(&TMPPNL) MEMBER('panelname')'\n'LMFREE DATAID(&TMPPNL)'\n'LIBDEF ISPPLIB LIBRARY ID($UPDPAN) STACK'\n'ADDPOP'\n'CONTROL DISPLAY LOCK'\nCALL Delay\n'DISPLAY PANEL(POPUP)'\n'SELECT PGM(ISRSUPC) PARM(&SUPPARM)'\nsupercrc=rc\n'REMPOP'\n'LIBDEF ISPPLIB '\nAddress tso\n'FREE F($UPDPAN)'\nIf supercrc=1 Then\n  Do\n    'EXECIO * DISKR OUTDD (FINIS STEM MEM.'\n    Address ispexec\n    'CONTROL ERRORS RETURN'\n    'LMINIT DATAID(DATAID) DDNAME('rdd') ENQ(SHR)'\n    'LMOPEN DATAID('dataid')'\n    'CONTROL NONDISPL END'\n   zerrsm='Found in 'mem.0-5' members'\n   zerrlm='The string \"'inparms'\" was found in 'mem.0-5' members.'\n   zerrhm='*'\n   zerralrm='NO'\n   Address ispexec 'SETMSG MSG(ISRZ002)'\n    option='DISPLAY) COMMANDS(ANY'\n    zcmd = ''\n    Do a=6 to mem.0\n       Parse Var mem.a member .\n       'LMMDISP DATAID('dataid') OPTION('option') ',\n                               'MEMBER('member')'\n       If rc<=8 Then  /* ignore bad names for now */\n         option='ADD'\n       Else\n         'CONTROL NONDISPL END' /* don't display next attempt*/\n    End\n    address tso 'FREE F(NEWDD SYSIN OUTDD)'\n    zlmember=''\n    Do Until disprc>0\n      'LMMDISP DATAID('dataid')  OPTION(DISPLAY) COMMANDS(ANY) ,\n               TOP('zlmember')'\n      disprc=rc\n      If disprc=0 & zlmember\\='' Then\n        Do\n          service = ''\n          SELECT\n            When (zllcmd='V') Then service='VIEW'\n            When (zllcmd='B') Then service='BROWSE'\n            When (zllcmd='S') Then service='EDIT'\n            When (zllcmd='/') Then service='EDIT'\n            When (zllcmd='E') Then service='EDIT'\n            When (zllcmd=' ') Then service='EDIT'\n            Otherwise\n             Do\n            zerrsm='Invalid command:'zllcmd\n            zerrlm='Use B for BROWSE, V for VIEW or E, S or / for EDIT.'\n            zerrhm='*'\n            zerralrm='YES'\n            Address ispexec 'SETMSG MSG(ISRZ002)'\n             End\n          End\n          If service \\= '' Then\n           Do\n            service 'DATAID('dataid') MEMBER('zlmember')'\n            If rc>=12 Then 'SETMSG MSG(ISRZ002)'\n           End\n        End\n    End\n    'LMMDISP DATAID('dataid')  OPTION(FREE)'\n    'LMFREE DATAID('dataid')'\n  End\nElse\n  Do\n   zerrsm='String not found'\n   zerrlm='The string \"'inparms'\" was not found in any members.'\n   zerrhm='*'\n   zerralrm='YES'\n   Address ispexec 'SETMSG MSG(ISRZ002)'\n   address tso 'FREE F(NEWDD SYSIN OUTDD)'\n  End\naddress tso 'FREE F('rdd')'\n\nExit 0\ngetdsns: Procedure Expose zdsn. panel zwidth\nzdsn.=''\ntfdp = ptr(76+ptr(640+ptr(ptr(24+ptr(112+ptr(132+ptr(540)))))))\npanel=storage(d2x(344+ptr(ptr(24+ptr(112+ptr(132+ptr(540)))))),8)\nDo a=0 to 3\n  Parse Value storage(d2x(ptr(140+a*4+tfdp)),46) With d 3 n\n  If d>'0000'x Then zdsn.a=\"'\"strip(n)\"'\"\nEnd\nReturn\nptr: Return c2d(bitand(storage(d2x(Arg(1)),4),'7FFFFFFF'x))\n/*PANEL POPUP\n)ATTR\n @ type(pt)\n + type(nt)\n / type(text) color(red)\n)BODY window(60,08)\n+                 @Searching Data Set(s)+\n+\n+String    :/&inparms\n+Data sets :%&zdsn0\n+           %&zdsn1\n+           %&zdsn2\n+           %&zdsn3\n)END\n*/\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "HIST": {"ttr": 2325, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x03\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00\\xed\\x00\\xed\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:03", "lines": 237, "newlines": 237, "modlines": 0, "user": "KANNAN"}, "text": "/* rexx hist - now reflist are there */\narg hlimit\ncall BarInit\nelapsed = sysvar(syscpu)\nif hlimit > 0 then maxdatasets = hlimit\nelse maxdatasets = 100\ncall tbinit\ncall tbcreate\naddress ispexec\n\"control errors return\"\n\"vget (zlogname) shared\"\nsyslog = zlogname\n   hdsn =\"'\"||syslog||\"'\"\n   avail = sysdsn(hdsn)\n   if avail \\= \"OK\" then do\n       zedsmsg = avail\n      \"ispexec setmsg msg(isrz000)\";exit\n   end\n   address tso \"alloc ds(\"hdsn\") dd(histdd) shr\"\n   if rc \\= 12 then\n      if rc \\= 0 then do\n       zedsmsg = \"file alloc error \" rc\n       \"ispexec setmsg msg(isrz001)\" ;exit\n      end\nhline. = ''\narch.  = ''\naddress ispexec\n\"control errors return\"\ncall getlog\nhyp = '-';threshold = 0\ndo i=hline.0 to 1 by -1  until threshold = maxdatasets\n   /* say i '-' threshold '-' maxdatasets '-' h_dset */\n   if pos('Edit - Save',hline.i)  = 0  then iterate\n   if pos('SYS'date('j'),hline.i) > 0  then iterate\n   parse upper value hline.i with h_time h_func hyp ,\n                     h_fate hyp h_dset hyp h_rest\n   if h_func = 'EDIT' & h_fate = 'SAVE' then do\n      call dedup\n      if dup then nop\n      else call hit\n   end\n   Address Ispexec \"Rempop\"\n   If threshold // 10 = 0 Then Call ShowProgress\nend\ncall popdataset\n\nqui :\n   drop hline. junk\n   address ispexec \"tbend   qlp\"\n   if zcmd = 'r' then\n      address ispexec \"select cmd(%hist1)\"\n   exit 0\n\nhit :\nthreshold = threshold + 1\narch.threshold = h_dset\nttstr = h_dset\nstar = ' '\naddress ispexec \"tbmod   qlp order\"\nreturn\n\npopdataset :\n       elapsed = sysvar(syscpu) - elapsed\n       ZEDLMSG = 'Search took' elapsed 'seconds.'\n       \"ISPEXEC SETMSG MSG(ISRZ000)\"\n       address ispexec \"tbtop   qlp\"\n       do forever until rc >= 8\n          address ispexec \"tbdispl qlp panel(histpnl) autosel(no)\" ,\n                           message cursor csrrow \"position(crp)\"\n          call navigate\n       end\nreturn\n\ndedup2 : /* not called - dedup with presence check */\ndup = 0\nif sysdsn(\"'\"||h_dset||\"'\") == 'OK' then do\n   do k = threshold to 1 by -1 while dup = 0\n      if arch.k =  h_dset then dup = 1\n   end\nend\nelse dup = 1\nreturn\n\ndedup :\ndup = 0\ndo k = threshold to 1 by -1 while dup = 0\n   if arch.k =  h_dset then dup = 1\nend\nreturn\n\neditarch :\nif ttstr = '' then return\nif editmode = 'B' then do\n      \"ISPEXEC browse dataset('\"ttstr\"')\";star = 'Browsed';end\nelse\n   if editmode = 'V' then do\n      \"ISPEXEC view dataset('\"ttstr\"')\";star = 'Viewed';end\n   else do\n      \"ISPEXEC edit dataset('\"ttstr\"')\";star = 'Edited';end\nif rc > 4 then do\n    star = 'Error RC='RC\n   \"ISPEXEC setmsg msg(isrz002)\";\nend\nreturn\n\ntbinit :\nmessage = 'msg()'\ncursor  = 'cursor()'\ncsrrow  = 'csrrow(1)'\nretcode = 0\nreturn\n\ntbcreate :\n    address ispexec\n   \"control errors return\"\n   address ispexec \"tbopen qlp\"                             /* exist? */\n   if rc = 8 then do\n      nop                                      /* send to recycle bin */\n   end\n   else do\n      address ispexec \"tbend    qlp\"           /* send to recycle bin */\n   end\n                                                       /* create anew */\n   address ispexec \"tbcreate qlp keys(ttstr) names(star)\"\nreturn\n\nnavigate :\n   upper zcmd\n   if zcmd = 'CANCEL' | zcmd = 'END' then do\n          address ispexec \"tbend qlp\"\n          exit 0\n   end\ndo while ztdsels > 0\n   if zcmd = 'CANCEL' | zcmd = 'END' then do\n          address ispexec \"tbend qlp\"\n          exit 0\n   end\n\n   if (l \\= ' ') then do\n       editmode = l\n       l = ''\n       call editarch\n       address ispexec \"tbmod   qlp order\"\n       address ispexec \"tbdispl qlp panel(histpnl) autosel(no)\" ,\n                           message cursor csrrow \"position(crp)\"\n   end\n   else do\n       l = ''\n       address ispexec \"tbdispl qlp panel(histpnl) autosel(no)\" ,\n                           message cursor csrrow \"position(crp)\"\n   end\n   if rc >= 12 then 'ispexec setmsg msg(isrz002)'\nend\nif rc = 8 then return\naddress ispexec \"tbtop  qlp\"\naddress ispexec \"tbskip qlp number(\"ztdtop\")\"\nreturn\n\ngetlog :\naddress ispexec\n'lminit  dataid(did) ddname(histdd) enq(shr)'\n'lmopen  dataid('did') option(input)'\nlmgetrc=rc\nj = 0\naddress ispexec\n\"control errors return\"\ndo while(lmgetrc=0)\n  'lmget dataid('did') mode(invar) dataloc(line) datalen(len)',\n    ' maxlen(32760)'\n  lmgetrc=rc\n  if lmgetrc=0 then\n    do\n      j = j + 1\n      hline.j = line\n      If j // 200 = 0 Then Call ShowProgress\n    end\nend\n'lmfree dataid('did')'\naddress tso 'free f(histdd)'\nhline.0 = j\nreturn\n\nBarInit:\nColorCyl= 'ON'\nwipmsg  = 'Reading log file...'\nBARDYE  = 'TURQ'\nbarpointer = 0\nAddress Ispexec\n      \"Control display lock\"\n      \"Addpop\"\n      \"Display panel(gebarpnl)\"\n      \"Rempop\"\nwipmsg  = 'Formatting history...'\nReturn\n\nShowProgress :\n      Address Ispexec\n      If barpointer > 50 Then Do\n         BARCHAR = ''\n         barpointer = 0\n\n         If ColorCyl = 'ON' Then Do\n            Select\n              When BARDYE  = 'YELLOW' Then BARDYE  = 'RED'\n              When BARDYE  = 'RED'    Then BARDYE  = 'BLUE'\n              When BARDYE  = 'BLUE'   Then BARDYE  = 'TURQ'\n              When BARDYE  = 'TURQ'   Then BARDYE  = 'WHITE'\n              When BARDYE  = 'WHITE'  Then BARDYE  = 'PINK'\n              When BARDYE  = 'PINK'   Then BARDYE  = 'YELLOW'\n              otherwise NOP\n            End\n         End\n\n      End\n      Else Do\n         BARCHAR = Copies('k',barpointer)\n         barpointer = barpointer + 1\n\n         If ColorCyl = 'ON' Then Do\n            Select\n              When BARDYE  = 'YELLOW' Then BARDYE  = 'RED'\n              When BARDYE  = 'RED'    Then BARDYE  = 'BLUE'\n              When BARDYE  = 'BLUE'   Then BARDYE  = 'TURQ'\n              When BARDYE  = 'TURQ'   Then BARDYE  = 'WHITE'\n              When BARDYE  = 'WHITE'  Then BARDYE  = 'PINK'\n              When BARDYE  = 'PINK'   Then BARDYE  = 'YELLOW'\n              otherwise NOP\n            End\n         End\n\n      End\n      \"Control display lock\"\n      \"Addpop\"\n      \"Display panel(gebarpnl)\"\n      \"Rempop\"\nReturn\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "HISTPNL": {"ttr": 2565, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x03\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00\\x0e\\x00\\x0e\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:03", "lines": 14, "newlines": 14, "modlines": 0, "user": "KANNAN"}, "text": ")Attr\n! TYPE(INPUT ) INTENS(HIGH) JUST(LEFT)  CAPS(ON ) PAD('_') COLOR(YELLOW )\n@ TYPE(INPUT ) INTENS(LOW ) JUST(LEFT)  CAPS(ON )          COLOR(TURQ   )\n} TYPE(TEXT  ) INTENS(HIGH) JUST(LEFT)  CAPS(ON ) PAD(' ') COLOR(PINK   )\n_ TYPE(INPUT ) INTENS(HIGH) JUST(LEFT)  CAPS(OFF) PAD(' ')\n)Body  expand(//)\n%-/-/-  Dataset Edit History  -/-/-\n%Command ===>_ZCMD                                  / / %Scroll ===>_AMT +\n+\n+     }Dataset                                             Status\n)Model\n !L+  @TTSTR                                            + @STAR        +\n)Proc\n)End\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "HOLD": {"ttr": 2567, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x03\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00\\x18\\x00\\x18\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:03", "lines": 24, "newlines": 24, "modlines": 0, "user": "KANNAN"}, "text": "/* Rexx Hold - Display contention                                     */\nAddress ISPEXEC\nArg dsname\n\n   zerralrm = 'NO'\n   zerrhm   = 'ISR2MACR'\n   zerrtp   = 'WARNING'\n   zerrwn   = 'NORESP'\n\n   dsname = strip(dsname,,\"'\")\n   \"LMINIT DATAID(DID) DATASET('\"dsname\"') ENQ(EXCLU)\"\n   If RC > 0 Then Do\n       \"SETMSG MSG(ISRZ002)\"\n       \"DISPLAY PANEL(ISRQDSP)\"\n       Exit\n   End\n   Else Do\n       zerrsm = 'No Contention'\n       zerrlm = 'for' dsname\n       \"SETMSG MSG(ISRZ003)\"\n   End\n   \"LMFREE DATAID(\"did\")\"\n\nExit 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "HOLD2": {"ttr": 2569, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x03\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00\\x08\\x00\\x08\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:03", "lines": 8, "newlines": 8, "modlines": 0, "user": "KANNAN"}, "text": "/* rexx */\nparse var dsn .\nsubcom console\nif rc = 0 then\n     \"console activate name(\"userid()\"c)\"\n\"console  syscmd(d grs,res=(sysdsn,\"dsn\")\"\ny = getmsg(\"msg.\",,,,1)\nexit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "HR": {"ttr": 2571, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x03\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00\\x04\\x00\\x04\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:03", "lines": 4, "newlines": 4, "modlines": 0, "user": "KANNAN"}, "text": "/* REXX HREC */\nARG DSN\nADDRESS TSO 'HRECALL' DSN 'WAIT'\nRETURN\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "HREC": {"ttr": 2573, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x03\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00\\x12\\x00\\x12\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:03", "lines": 18, "newlines": 18, "modlines": 0, "user": "KANNAN"}, "text": "/* REXX HREC */\n/* HRECALLS ALL LISTED DSETS AND WRITES A FLAG TO AVOID THIS          */\n/* ON A RELOGIN ON SAME DAY                                           */\nADDRESS ISPEXEC\nAVAIL = SYSDSN('HRECLOG')\nIF AVAIL = \"OK\" THEN SIGNAL QUI\nDAT = DATE( );\nDATF = SUBSTR(DAT,1,2)\nIF DATF // 7 = 0 THEN DO\n       ADDRESS TSO\n       HRECALL 'HANNA.*' NOWAIT\n       SUBMIT 'HANNA.CNTL(HRECLOG)'\nEND\nADDRESS TSO\nHRECALL 'HANNA.CUE'       NOWAIT\nHRECALL 'HANNA.HISTORY'   NOWAIT\nQUI :\nEXIT 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ICSF": {"ttr": 2575, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x03\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00\\x17\\x00\\x17\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:03", "lines": 23, "newlines": 23, "modlines": 0, "user": "KANNAN"}, "text": "/* rexx */\n/* Thierry Falissard in ibm-main */\ncvt  = storage(10,4)                   /* cvt address in memory */\nscvt   = storage(d2x(200+c2d(cvt)),4)  /* address of SCVT       */\nccvt   = storage(d2x(184+c2d(scvt)),4) /* address of CCVT       */\nif ccvt = '00000000'x then do\n                      say 'Cryptography not installed'\n                      exit(8)\n                      end\n                      else do\nccvtfl = storage(d2x(36+c2d(ccvt)),1)  /* CCVTSFG1 Status byte  */\nif bitand(ccvtfl,'80'x) <> '80'x then do\n                                say  'Cryptography is installed',\n                                'but is inactive'\n                                exit(4)\n                                end\n                                else do\n                                say  'Cryptography is active'\nccvtas = storage(d2x(42+c2d(ccvt)),2)  /* CCVTASID ASID of ICSF */\n say 'ASID of ICSF/MVS address space is' c2x(ccvtas) '('c2d(ccvtas)')'\n                                 exit(0)\n                                 end\nend\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "IEHL": {"ttr": 2577, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x03\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00%\\x00%\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:03", "lines": 37, "newlines": 37, "modlines": 0, "user": "KANNAN"}, "text": "/* REXX --------------------------------------------------------------*/\n/*                                                                    */\n/* KLEINE TRICK :-)                                                   */\n/* - ALLOC VTOCIX DATASET FOR IEHLIST                                 */\n/* - OBTAIN DEVICE-TYPE VIA VTOCIX ALLOC                              */\n/*                                                                    */\n/* Z6TKL                                                              */\n/* 1996.10.11                                                         */\n/*                                                                    */\n/*--------------------------------------------------------------------*/\nARG VOLSER .\n\nDSNAME = 'SYS1.VTOCIX.'VOLSER\nDDNAME = 'I'RIGHT(SYSVAR('SYSSRV'),7,'0')\n\n\"ALLOC FILE(\"DDNAME\") DATASET('\"DSNAME\"')    VOLUME(\"VOLSER\")   SHR REU\"\n\"ALLOC FILE(SYSIN)    UNIT(VIO) RECFM(F B)\n    LRECL(80) SP(1,1)  TRACKS  NEW REU\"\n\"ALLOC FILE(SYSPRINT) UNIT(VIO) RECFM(F B A)\n    LRECL(121) SP(9,9) CYLINDERS  NEW REU\"\n\nCALL LISTDSI(DDNAME 'FILE')\n\nQUEUE \" LISTVTOC FORMAT,VOL=\"SYSUNIT\"=\"VOLSER\n\"EXECIO 1 DISKW SYSIN (FINIS\"\n\nADDRESS ISPEXEC \"SELECT PGM(IEHLIST)\"\n\"FREE FILE(\"DDNAME \"SYSIN)\"\n\nADDRESS ISPEXEC \"CONTROL ERRORS  RETURN\"\nADDRESS ISPEXEC \"LMINIT  DATAID(DATAID) DDNAME(SYSPRINT)\"\nADDRESS ISPEXEC \"BROWSE  DATAID(\"DATAID\")\"\nADDRESS ISPEXEC \"LMFREE  DATAID(\"DATAID\")\"\nADDRESS ISPEXEC \"CONTROL ERRORS  CANCEL\"\n\n\"ALLOCATE FILE(SYSPRINT) DATASET(*) REUSE\"\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "IMAGEJCL": {"ttr": 2579, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x03\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00\\xa2\\x00\\xa2\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:03", "lines": 162, "newlines": 162, "modlines": 0, "user": "KANNAN"}, "text": "/* REXX ImageJCL                                                      */\n/* .................................................................. */\n/* Author  : Kannan AK                                                */\n/* ImageJCL: Create JCL for IMAGECOPY for all COPYPENDs/RESTRICTs     */\n/* Notice  : None                                                     */\n/* Version : Alpha                                                    */\n/* .................................................................. */\ncall tempdsn cp tempdd tempdsn\nM = 'TSIN*'\nG = 'X'\naddress ispexec\nzwinttl='* Select DB2 Subsystem *'\n\"vput (zwinttl)\"\n\"addpop\"\n\"display panel(db2spnl)\"\nif rc = 8 then do\n   'rempop'\n   zedsmsg = 'Function canceled'\n   'setmsg msg(isrz001)'\n   exit\nend\nupper cname\nselect\n  when cname  = 'A' then subsys = TEST\n  when cname  = 'B' then subsys = PROD\n  otherwise nop\nend\nredo:\naddress ispexec\nzwinttl='* Select Tablespace/Database *'\n\"vput (zwinttl)\"\n\"addpop column(27) row(3)\"\n\"display panel(db2tpnl)\"\nif rc = 8 then do\n   'rempop all'\n   zedsmsg = 'Function canceled'\n   'setmsg msg(isrz001)'\n   exit\nend\nupper cname\nselect\n  when cname  = 'C' then dbase = INSTANC1\n  when cname  = 'D' then dbase = INSTANC2\n  when cname  = 'E' then dbase = INSTANC3\n  when cname  = 'F' then dbase = INSTANC4\n  otherwise nop\nend\nif M = '' then do\n   \"rempop all\"\n   signal redo\nend\nupper G\nif G = 'X' | G ='S' then\n   restrict = 'R'\nelse\n   restrict = 'X'\nupper M\ntspace = M\nx = outtrap('out.','*','noconcat')\naddress tso \"db2pend\" subsys dbase tspace restrict\nx = outtrap(off)\n\"rempop all\"\nJ = 1\ndo i=1 by 1 while i <= out.trapped\n   if pos('------',out.i) > 0  then leave\n   J = J + 1\nEnd\npend. = ''\nk = 1\ndo i=j+1 by 1 while i <= out.trapped-2\n   tbname = substr(out.i,1,8)\n   tbtype = substr(out.i,10,2)\n   tbpart = substr(out.i,15,4)\n   tbstat = substr(out.i,20,18)\n   if pos('COPY',tbstat) > 0  then do\n      pend.k = tbname\n      k=k+1;\n   end\nEnd\npoint   = 1\nif k = 1 then do\n   zedsmsg = \"Nothing to display\"\n   \"setmsg msg(isrz001)\"\n   signal qui\nend\ndo i=1 by 1 while i < k\n   call writejobcard\n   call buildjcl\nend\ncall eof\n\"edit dataset(\"tempdsn\")\"\n\nqui :\naddress tso \"free dd(\"tempdd\") delete\"\nexit\n\n/* invocation : call tempdsn co tempdd tempdsn */\ntempdsn : procedure expose cuechar tempdd tempdsn\narg cuechar\ncuechar = substr(cuechar,1,2)\nd = date(j);p = sysvar(syspref);\nr1 = random(100,999);r2 = random(100,999);\nt = time();parse value t with hh ':' mm ':' ss;tt=hh||mm||ss\ntempdsn = cuechar||d||'.t'||r1||trunc(r1*r2/random()/10)||'.z'||tt\nnt = tempdsn\ntempdd  = cuechar ||r2||r1\n\"alloc ds(\"nt\") dd(\"tempdd\") dsorg(ps) lrecl(80) recfm(f) new keep\"\nif rc \\= 0 then do\n       \"ispexec setmsg msg(isrz002)\"\n       result = 'ERROR'\n       exit\nend\nreturn\n\nwritejobcard :\ncall getjobchar\ncall push(\"//\"userid()jobchar\" JOB (000000),'IMAGECOPY',             \")\ncall push(\"//           MSGCLASS=X,NOTIFY=&SYSUID,CLASS=U            \")\ncall push(\"//*                                                       \")\nreturn\n\nbuildjcl:\nEOJ = \"/*\"\ncall push(\"//IC       EXEC  DSNUPROC,COND=(5,LT),                    \")\ncall push(\"//             SYSTEM='\"subsys\"',                         \")\ncall push(\"//             UID='IMAGE.\"pend.i\"',UTPROC=''             \")\ndatestamp = DATE(O)\nparse value datestamp with yy '/' mm '/' dd\ndatestamp = \"D\" || yy || mm || dd\nsysco = userid()\".\" || dbase || \".\" || pend.i || \".SYSCO.\" || datestamp\ncall push(\"//SYSCOPY  DD  DSN=\"sysco\",                               \")\ncall push(\"//             DISP=(,CATLG,DELETE),                      \")\ncall push(\"//             SPACE=(CYL,(600,100),RLSE)                 \")\ncall push(\"//SYSDBOUT DD SYSOUT=*                                    \")\ncall push(\"//SYSABOUT DD SYSOUT=*                                    \")\ncall push(\"//SYSPRINT DD SYSOUT=*                                    \")\ncall push(\"//SYSOUT   DD SYSOUT=*                                    \")\ncall push(\"//SYSIN    DD  *                                          \")\ncard1 = \"  COPY TABLESPACE \" ||dbase\".\"pend.i\ncall push(card1)\ncall push(EOJ)\ncall push(\"//*-------------------------------------------------------\")\nreturn\n\neof :\naddress tso\n\"EXECIO 0 DISKR\" TEMPDD \"( FINIS\"\nreturn\n\npush :\nparse arg stream\npush stream\naddress tso\n\"EXECIO 1 DISKW\" TEMPDD\nif rc >= 2 then call qui\nreturn\n\ngetjobchar :\nalpha = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890'\n  jobchar  = substr(alpha,point,1);point=point+1\n  if point = 37 then point = 1\nreturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "IMBED": {"ttr": 2583, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x03\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00\\x88\\x00\\x88\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:03", "lines": 136, "newlines": 136, "modlines": 0, "user": "KANNAN"}, "text": "/* Rexx Imbed */\n/*REXX Edit macro showing how to create a panel, display it, and    */\n/*     use input from that panel.  This makes it possible to        */\n/*     ship an exec with panels imbedded in the exec file.          */\n/*     This example also includes imbedded messages.                */\n/*     This example runs on the latest ISPF releases for CMS and    */\n/*     TSO.                                                         */\n/*                                                                  */\n/*     Panels are imbedded at the end of the exec in comments.      */\n/*     The comments are of the form:                                */\n/*         /+PANEL panelname                                        */\n/*             panel or message definition                          */\n/*         +/                                                       */\n/*      where /+ and +/ are really REXX comment delimiters in col 1 */\n/*                                                                  */\n/*     Although this is shown as an edit macro, the method used     */\n/*     is not dependent on any edit macro facilities.               */\n/*                                                                  */\n/*     The method used is:                                          */\n/*      1) Create a temporary panel library (PDS on MVS, flat       */\n/*         files on CMS)                                            */\n/*      2) use LIBDEF to point to the new panel/message library.    */\n/*      3) Display the panel, which will set some variables.        */\n/*      4) Use LIBDEF again to clean up.                            */\n/********************************************************************/\n\n\nAddress 'ISPEXEC'\n'ISREDIT MACRO (DSN)'\nParse Source system . cmdname .\nCall createlib\n'ISREDIT LINE_BEFORE .ZFIRST = (LINE3)'\n'ISREDIT LINE_BEFORE .ZFIRST = (LINE2)'\n'ISREDIT LINE_BEFORE .ZFIRST = (LINE1)'\n'ISREDIT LOCATE .ZFIRST'\nExit 1\n\n/**** createlib: Create and display a temporary panel ***************/\n\ncreatelib:\nexec_line=1   /* Start looking for imbeds at line 1 of the exec */\nif system = 'TSO' then\n  Address tso 'ALLOC NEW CAT F($TMPLIB$) DSO(PO) DIR(1) SP(3,3) TRACK\n              da($WWWSAMP.TEMP.ISPFLIB) REUSE\n              RECFM(F B) BLKSIZE(0) LRECL(80) UNIT(SYSALLDA)'\nCall make_member   /* call make_member once for each imbedded member*/\nCall make_member\nCall make_member\nif system = 'TSO' then\n  Address tso 'ALLOC F($TMPLIB$) OLD DA($WWWSAMP.TEMP.ISPFLIB) REUSE'\nif system = 'TSO' then\n  do\n    'VGET ZENVIR'\n    If substr(zenvir,6,1)>='4' Then stack='STACK' /* Use STACK in V4 */\n    Else stack = ''\n    'LIBDEF ISPPLIB LIBRARY ID($TMPLIB$)' stack\n    'LIBDEF ISPMLIB LIBRARY ID($TMPLIB$)' stack\n  end\nelse /* do CMS style libdef */\n  Do\n    'LIBDEF ISPPLIB FILE ID(ISRNULL $TMPLIB$ A)'\n    'LIBDEF ISPMLIB FILE ID(ISRNULL $TMPLIB$ A)'\n  END\n'ADDPOP'\nDo Until rc>0\n  'DISPLAY PANEL(TEMPPAN)'\nEnd\n'REMPOP'\n'LIBDEF ISPPLIB '\n'LIBDEF ISPMLIB '\nif system = 'TSO' then Address tso 'FREE F($TMPLIB$) DELETE'\nElse                   Address '' 'ERASE * $TMPLIB$ A '\n\nDo queued();Pull;End\nReturn\n\n/* make_member: scan this exec for imbeded parts and add to temporary */\n/*              library using EXECIO for I/O operations.              */\nmake_member:\n\nDo queued();Pull;End\nDo Until substr(line,1,7)='/*PANEL'\n  line = sourceline(exec_line)\n  exec_line=exec_line+1\nEnd\nParse Var line . panelname .\nDo until substr(line,1,2)='*/'\n  line = sourceline(exec_line)\n  if substr(line,1,2)\u00ac='*/' then\n    Queue line\n  exec_line=exec_line+1\nEnd\nif system = 'TSO' then\n  do\n    pands='$WWWSAMP.TEMP.ISPFLIB('panelname')'\n    Address tso 'ALLOC OLD F($TMPLIB$) DSO(PO) DIR(1) SP(3,3) TRACK\n                da('pands') RECFM(F B) BLKSIZE(0) LRECL(80) REUSE\n                UNIT(SYSALLDA)'\n    Address 'TSO' 'EXECIO 'queued()' DISKW $TMPLIB$ ( FINIS'\n  end\nelse\n do\n  Address '' 'ERASE 'panelname' $TMPLIB$ A '\n Address '' 'EXECIO 'queued()' DISKW 'panelname' $TMPLIB$ A 1 F ( FINIS'\n end\nDo queued();Pull;End\nReturn\n\n\n/*PANEL TEMPPAN\n)BODY WINDOW(73,12) CMD(ZCMD)\n%Command ===>_ZCMD                                                   %\n\n+ This is a sample temporary panel defined in the &cmdname exec file.\n\n+ Enter data for line 1%===>_line1                                   +\n+ Enter data for line 2%===>_line2                                   +\n+ Enter data for line 3%===>_line3                                   +\n\n+Enter%HELP+on the command line to show a temporary help panel.\n+Enter or press%END+to leave this panel.\n)INIT\n  .HELP = TEMPPANT\n  .MSG  = TEMP001\n)END\n*/\n/*PANEL TEMPPANT\n)BODY WINDOW(35,5) CMD()\n%\n+ This is a%temporary+help panel.\n)END\n*/\n/*PANEL TEMP00\nTEMP001 'Here is a message'\n'This is a tempirary message from the exec'\n*/\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "IMBEDPNL": {"ttr": 2819, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x03\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00]\\x00]\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:03", "lines": 93, "newlines": 93, "modlines": 0, "user": "KANNAN"}, "text": "DisplayPanel :\nAddress 'ISPEXEC'\nexec_line=1\nif system = 'TSO' then\n  Address tso 'ALLOC NEW CAT F($TMPLIB$) DSO(PO) DIR(1) SP(3,3) TRACK\n               DA($WWWSAMP.TEMP.ISPFLIB) REUSE\n               RECFM(F B) BLKSIZE(0) LRECL(80) UNIT(SYSALLDA)'\nCall MakeMember\nif system = 'TSO' then\n  Address tso 'ALLOC F($TMPLIB$) OLD DA($WWWSAMP.TEMP.ISPFLIB) REUSE'\nIf system = 'TSO' Then\n  Do\n    'VGET ZENVIR'\n    If substr(zenvir,6,1)>='4' Then stack='STACK' /* Use STACK in V4 */\n    Else stack = ''\n    'LIBDEF ISPPLIB LIBRARY ID($TMPLIB$)' stack\n    'LIBDEF ISPMLIB LIBRARY ID($TMPLIB$)' stack\n  End\nElse\n  Do\n    'LIBDEF ISPPLIB FILE ID(ISRNULL $TMPLIB$ A)'\n    'LIBDEF ISPMLIB FILE ID(ISRNULL $TMPLIB$ A)'\n  End\n'ADDPOP'\nDo Until rc > 0\n  'DISPLAY PANEL(CLIPPNL)'\nEnd\n'REMPOP'\n\n'LIBDEF ISPPLIB '\n'LIBDEF ISPMLIB '\nIf system = 'TSO' Then Address tso 'FREE F($TMPLIB$) DELETE'\nElse                   Address '' 'ERASE * $TMPLIB$ A '\n\nDo queued();Pull;End\nReturn\n\nMakeMember :\nDo queued();Pull;End\nDo Until substr(line,1,7)='/*PANEL'\n  line = sourceline(exec_line)\n  exec_line=exec_line+1\nEnd\nParse Var line . panelname .\nDo until substr(line,1,2)='*/'\n  line = sourceline(exec_line)\n  if substr(line,1,2)\u00ac='*/' then\n    Queue line\n  exec_line=exec_line+1\nEnd\nif system = 'TSO' then\n  do\n    pands='$WWWSAMP.TEMP.ISPFLIB('panelname')'\n    Address tso 'ALLOC OLD F($TMPLIB$) DSO(PO) DIR(1) SP(3,3) TRACK\n                da('pands') RECFM(F B) BLKSIZE(0) LRECL(80) REUSE\n                UNIT(SYSALLDA)'\n    Address 'TSO' 'EXECIO 'queued()' DISKW $TMPLIB$ ( FINIS'\n  end\nelse\n do\n  Address '' 'ERASE 'panelname' $TMPLIB$ A '\n Address '' 'EXECIO 'queued()' DISKW 'panelname' $TMPLIB$ A 1 F ( FINIS'\n end\nDo queued();Pull;End\nReturn\n\n/*PANEL CLIPPNL\n)ATTR\n? TYPE(INPUT) INTENS(LOW) JUST(LEFT)\n_ TYPE(INPUT) INTENS(LOW) JUST(LEFT) PAD(' ') COLOR(YELLOW) CAPS(OFF)\n)BODY WINDOW(70,18)\n Command ==>?ZCMD\n_cue1\n_cue2\n_cue3\n_cue4\n_cue5\n_cue6\n_cue7\n_cue8\n_cue9\n_cue10\n_cue11\n_cue12\n_cue13\n_cue14\n_cue15\n_cue16\n_cue17\n)INIT\n&ZWINTTL = '* ClipBoard *'\n)END\n*/\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "INIT": {"ttr": 2822, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x03\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00U\\x00U\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:03", "lines": 85, "newlines": 85, "modlines": 0, "user": "KANNAN"}, "text": "/* Rexx - Print a list of address spaces                             */\nNumeric digits 10\nParse Upper Arg specific_names .\ninitiators=0\nnames.=\"\"\nnames.0=0\nCall get_list_of_names\nCall sort\nCall show_results\nExit\n/*-------------------------------------------------------------------*/\nget_list_of_names:\nProcedure Expose names. initiators specific_names\ncvt=ptr(16)                            /* Get CVT                    */\nasvt=ptr(cvt+556)+512                  /* Get asvt                   */\nasvtmaxu=ptr(asvt+4)                   /* Get max asvt entries       */\nDo a = 0 to asvtmaxu - 1\n  ascb=stg(asvt+16+a*4,4)              /* Get ptr to ascb (Skip\n                                          master)                    */\n  If bitand(ascb,'80000000'x) = '00000000'x Then /* If in use        */\n    Do\n      ascb=c2d(ascb)                   /* Get ascb address           */\n      cscb=ptr(ascb+56)                /* Get CSCB address           */\n      chtrkid=stg(cscb+28,1)           /* Check addr space type      */\n      ascbjbns=ptr(ascb+176)           /* Get ascbjbns               */\n      ascbjbni=ptr(ascb+172)           /* Get ascbjbni               */\n      If chtrkid='01'x Then            /* If tso user                */\n        If stg(ascbjbns,1)>='4a'x & stg(ascbjbns,1)<='Z' Then\n          Call add 'TSO',stg(ascbjbns,8) /* Print tso user           */\n      If chtrkid='02'x Then            /* If tso user                */\n        Call add 'STC',stg(ascbjbns,8) /* Print started task         */\n      If chtrkid='03'x Then            /* If tso user                */\n        Do\n          If stg(ascbjbns,8) ='INIT    ' Then\n            initiators=initiators+1    /* Bump initiator count       */\n          If ascbjbni<>0 Then\n            Call add 'Job',stg(ascbjbni,8)\n        End\n      If chtrkid='04'x Then            /* If tso user                */\n        Call add 'System',stg(ascbjbns,8)/* Print system address\n                                          space                      */\n    End\nEnd\nReturn\n/*-------------------------------------------------------------------*/\nptr:\nReturn c2d(storage(d2x(Arg(1)),4))     /* Return a pointer           */\n/*-------------------------------------------------------------------*/\nstg:\nReturn storage(d2x(Arg(1)),Arg(2))     /* Return storage             */\n/*-------------------------------------------------------------------*/\nadd:\nProcedure Expose names. specific_names\nIf specific_names=\"\",\n  | 0<pos(specific_names,translate(Arg(1) Arg(2))) Then\n  Do\n    names.0=names.0+1\n    n=names.0\n    names.n=left(Arg(1),8)||Arg(2)\n  End\nReturn\n/*-------------------------------------------------------------------*/\nsort:\nProcedure Expose names.                /* Just a bubble sort. Dumb but\n                                          adequate                   */\nn=names.0\nDo i= 1 to n-1\n  Do j=i+1 to n\n    If names.i>names.j Then\n      Do\n        t=names.i\n        names.i=names.j\n        names.j=t\n      End\n  End\nEnd\nReturn\n/*-------------------------------------------------------------------*/\nshow_results:\nProcedure Expose names. initiators\nDo n = 1 to names.0\n  Say names.n\nEnd\nSay 'Initiators: 'initiators\nReturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "INS": {"ttr": 2825, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x03\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00,\\x00,\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:03", "lines": 44, "newlines": 44, "modlines": 0, "user": "KANNAN"}, "text": "/* REXX INS                                                           */\n/* .................................................................. */\n/* AUTHOR: KANNAN                                                     */\n/* SYNTAX: CMD STR  COL OPT                                           */\n/* USAGE : INS THIS 23  S  >> WILL SHIFT;LINE IS FULL CHARS WILL BE   */\n/*                         >> LOST AT THE END OF LINE                 */\n/* USAGE : INS THAT 23  O  >> OVERLAY GIVEN STRING                    */\n/* .................................................................. */\nADDRESS ISPEXEC\nPARSE SOURCE . . ME .\n\"ISREDIT MACRO (CHAR COL OPT) NOPROCESS\"\nIF RC = 20 THEN DO\n    ZEDSMSG = \"NOT A TSO COMMAND\"\n   \"SETMSG MSG(ISRZ000)\";EXIT\nEND\nOPT=STRIP(OPT,B);OPT = TRANSLATE(OPT)\nIF  (OPT \\= 'S' & OPT \\= 'O')  THEN DO\n          ZEDSMSG = ME \"NEEDS PARM S/O\"\n          \"SETMSG MSG(ISRZ001)\"\n          EXIT\n     END\n\"ISREDIT PROCESS RANGE J\"\nIF RC > 0 THEN DO\n      ZEDSMSG = \"IMPROPER LINE COMMAND\"\n      \"SETMSG MSG(ISRZ001)\"\n       EXIT\nEND\n\"ISREDIT (RANG)  = RANGE_CMD\"\n\"ISREDIT (FIRST) = LINENUM .ZFRANGE\";\n\"ISREDIT (LAST)  = LINENUM .ZLRANGE\" ;\nCLEN = LENGTH(CHAR)\n\nDO I = FIRST TO LAST BY 1\n     \"ISREDIT (LINEBUF) = LINE\" I\n     IF RANG = 'J' & OPT = 'S' THEN\n        LINEBUF=INSERT(CHAR,LINEBUF,COL)\n     IF RANG = 'J' & OPT = 'O' THEN\n        LINEBUF=OVERLAY(CHAR,LINEBUF,COL,CLEN)\n     \"ISREDIT LINE\" I \" = \" '(LINEBUF)'\nEND\n\nZEDSMSG = (LAST-FIRST+1) \"LINE(S) EDITED\"\n\"SETMSG MSG(ISRZ000)\"\nEXIT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "INSTREAM": {"ttr": 2827, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x03\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00'\\x00'\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:03", "lines": 39, "newlines": 39, "modlines": 0, "user": "KANNAN"}, "text": "/* Rexx - Just an example */\nsignal there\naddress ispexec\n\"isredit macro\"\n\"isredit (first) = linenum .zf\"\n\"isredit (last)  = linenum .zl\"\n   do i = first to last by 1\n     \"isredit (linebuf) = line\" i\n     queue linebuf\n   end\nqueue ''\naddress tso\n\"alloc f(fjcl) sysout writer(intrdr)\"\n\"execio * diskw fjcl \"\n\"free f(fjcl)\"\nreturn\n\nthere :\nCall GetInstreamData\nReturn\nGetInstreamData :\nDo queued();Pull;End\nDo i = 1 To sourceline() By 1\n  line = sourceline(i)\n  say line\nEnd\nDo queued();Pull;End\nReturn\n\n\n\n\n\n\n\n\n\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ISPCMDU": {"ttr": 2829, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x03\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00}\\x00}\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:03", "lines": 125, "newlines": 125, "modlines": 0, "user": "KANNAN"}, "text": "/* Rexx                                                         */\n/* Add Commands to ispf in-storage command table                */\n/*                                                              */\n/* parms:   DA(dsname member)    member is optional, default    */\n/*                               is 'ispcomnd'.                 */\n/*                               if not specified, then         */\n/*          QUIET                dont show confirmation.        */\n/*          ID(id)               set 'desc' field to id.        */\n/*                                                              */\n/* ------------------------------------------------------------ */\n address command\n arg pm\n parse var pm \"DA(\"pmda\")\" .\n address ispexec \"control errors return\"\n address isredit \"MACRO NOPROCESS\"\n Select\n   when rc = 0 then call edit_load                /* edit macro */\n   when pmda \u00ac= \"\" then call Dsn_Load pmda\n   otherwise,\n     call Dsn_Load Locate_Ispprof()\n end\n\n address ispexec\n added=0\n updated=0\n deleted=0\n do i=1 to r.0\n   c = translate(r.i)\n   if word(c,1) = \"/*\" then iterate\n   if c = \"\"           then iterate\n   dlm=substr(c,1,1)\n   parse var c (dlm) verb (dlm) trunc,\n               (dlm) act  (dlm) desc (dlm) .\n   upper verb act\n   if dlm = '-' then call tbldel\n   else call tblupd\n end\n\n if wordpos('QUIET',pm) = 0 then\n    zedlmsg = \"<ISPCMDU> \" || ,\n              \"added(\"added\") updated(\"updated\") deleted(\"deleted\")\"\n    address ispexec \"setmsg msg(isrz000)\"\n return\n\ntblupd:\n if locate(verb) = 0 then do\n   call updvars\n   'tbput ispcmds'\n   updated=updated+1\n   return\n end\n /* verb not found, add it */\n 'tbtop ispcmds'\n call updvars\n 'tbadd ispcmds'\n added=added+1\n return\n\ntbldel:\n if locate(verb) > 0 then return\n 'tbdelete ispcmds'\n deleted=deleted+1\n return\n\nupdvars:\n zctverb=verb\n zcttrunc=trunc\n zctact=act\n parse var pm \"ID(\"id\")\" .\n if desc = \"\" then desc = \"*\"id\"*\"\n zctdesc=desc\n return\n\nlocate:\n \"tbtop    ispcmds\"\n arg zctverb\n \"tbscan   ispcmds arglist(zctverb)\"\n return rc\n\nEdit_Load:           /* load data to stem from edit session */\n do i=1 to 9999\n   address isredit '(l) = line' i\n   if rc > 0 then leave\n   r.i = strip(l,t)\n end\n r.0=i-1\n return\n\nDsn_Load:   /* load from library */\n arg d m .\n d = strip(d,\"b\",\"'\")\n if m = \"\" then m = \"ISPCOMND\"\n d = \"'\"d\"(\"m\")'\"\n address tso\n if sysdsn(d) \u00ac= \"OK\" then do\n   call xmsg \"*could not find input:\" d\n   exit\n end\n \"alloc dd(zcmdui) da(\"d\") shr reuse\"\n rc1 = rc\n if rc1 = 0 then 'execio * diskr zcmdui (stem r. finis'\n rc2 = rc\n 'free  dd(zcmdui)'\n if rc1+rc2 > 0 then do\n   call xmsg \"*readin failed alloc(\"rc1\") read(\"rc2\")\"\n   exit\n end\n drop rc1 rc2\n return\n\nLocate_Ispprof:   /* locate profile dataset */\n x=outtrap('ddl.')\n Address TSO \"lista st\"\n x=outtrap('off')\n\n do i=1 to ddl.0\n   c = word(ddl.i,1)\n   if pos(\".\",c) > 0 then iterate /* not ddname */\n   if c = \"ISPPROF\" then do\n     i = i-1\n     return ddl.i\n   end\n end\n return \"\"\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ISUB": {"ttr": 2832, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x03\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00&\\x00&\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:03", "lines": 38, "newlines": 38, "modlines": 0, "user": "KANNAN"}, "text": "/* Rexx ISUB*/\n\"ISREDIT MACRO\"\naddress ispexec\n'ISREDIT (openmbr) = MEMBER'\n'ISREDIT (opendsn)  = DATASET'\nCALL OUTTRAP 'OUT.'\nif openmbr = '' then\n   address tso \"submit '\"opendsn\"'\"\nelse\n   address tso \"submit '\"opendsn'('openmbr')'\"'\"\nCALL OUTTRAP 'OFF'\nDO I = 1 TO OUT.0\n   PARSE VAR OUT.I 'JOB' JOBNAME '(' JOBID ')' STATUS\nEND I\nSUBJOBNAME = STRIP(JOBNAME,B)\nSUBJOBID   = STRIP(JOBID,B)\nSUBJOB     = SUBJOBNAME || \"(\" || SUBJOBID || \")\"\nSAY \"SUBMITTED JOB =\" SUBJOB\nJOBDONE = 'NO'\nDO UNTIL JOBDONE = 'YES'\n     CALL OUTTRAP 'OUT.'\n     ADDRESS TSO \"ST\" SUBJOB\n     CALL OUTTRAP 'OFF'\n     DO I = 1 TO OUT.0\n        PARSE VAR OUT.I 'JOB ' JOBNAME '(' JOBID ')' STATUS\n        STATUS = STRIP(STATUS)\n        IF POS('ON OUTPUT QUEUE',STATUS) > 0\n        THEN JOBDONE = 'YES'\n        ELSE NOP\n           /* ADDRESS TSO \"TSOWAIT \" WAITAMOUNT */\n     END I\nEND\nPRINTDSN = \"'\"||USERID()||\".JOBTEMP.\"||JOBNAME||\".\"||JOBID||\"'\"\nADDRESS TSO \"OUTPUT \" SUBJOB \" PRINT(\"PRINTDSN\") KEEP HOLD\"\n\nEDITDSNAME = PRINTDSN\nADDRESS ISPEXEC \"BROWSE DATASET(\"EDITDSNAME\")\"\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "JC": {"ttr": 2834, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x03\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x001\\x001\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:03", "lines": 49, "newlines": 49, "modlines": 0, "user": "KANNAN"}, "text": "/* Rexx JC                                                            */\n/* .................................................................. */\n/* Author  : Kannan AK                                                */\n/* JC      : Jobcard creator                                          */\n/* Notice  : None                                                     */\n/* Version : Alpha                                                    */\n/* .................................................................. */\nAddress ISREDIT\n'MACRO'\nIF RC = 20 THEN DO\n    ZEDSMSG = \"NOT A TSO COMMAND\"\n    ADDRESS ISPEXEC \"SETMSG MSG(ISRZ000)\"\n    EXIT\nEND\nLineNo=0\n\nIf sysvar(Syspref) <> '' Then\n    Prefix = sysvar(Syspref)\nElse\n    Prefix = userid()\n\nAddress ISPEXEC 'VGET (ZACCTNUM)'\nAcct = ZACCTNUM\n\nCall Getname\nName=\"'\"||Name||\"'\"\n\nCall Add '//'||Prefix||'A'||' JOB '||Acct||\",\"||Name||\",\"\nCall Add '//         CLASS=U,'\nCall Add '//         MSGLEVEL=(1,1),'\nCall Add '//         MSGCLASS=X,'\nCall add '//         NOTIFY=&SYSUID'\nCall Add '//*'\nReturn\n\nAdd:\nParse Arg line\n'LINE_AFTER' LineNo' = (LINE)'\nLineNo=LineNo+1\nReturn\n\nGetName:\nascbasxb=d2x(c2d(storage(224,4))+108)\nasxbsenv=d2x(c2d(storage(ascbasxb,4))+200)\naceeunam=d2x(c2d(storage(asxbsenv,4))+100)\nadr=c2x(storage(aceeunam,4))\nName=storage(d2x(c2d(storage(aceeunam,4))+1),c2d(storage(adr,1))-1)\nName=space(strip(Name,\"b\",\" \"),0)\nReturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "JC2": {"ttr": 2836, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x03\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00\\x06\\x00\\x06\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:03", "lines": 6, "newlines": 6, "modlines": 0, "user": "KANNAN"}, "text": "/* Rexx */\n\"ISPEXEC VGET (ZLLGJOB1 ZLLGJOB2 ZLLGJOB3 ZLLGJOB4) PROFILE\"\nDo i = 1 To 4\n   If Value(zllgjob || i) <> \"\" Then Say Value(zllgjob || i)\nEnd\nReturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "JOBNAME": {"ttr": 3074, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x03\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00\\t\\x00\\t\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:03", "lines": 9, "newlines": 9, "modlines": 0, "user": "KANNAN"}, "text": "/* REXX */\nASCB = C2D(STORAGE(224,4))\nASSB = C2D(STORAGE(D2X(ASCB+336),4))\nJSAB = C2D(STORAGE(D2X(ASSB+168),4))\nJBNM = STORAGE(D2X(JSAB+28),8)\nJBID = STORAGE(D2X(JSAB+20),8)\nUSID = STORAGE(D2X(JSAB+44),8)\nSAY \"JOBNAME=\"JBNM\" JOBID=\"JBID\" USERID=\"USID\nEXIT 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "JSEND": {"ttr": 3076, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x04\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00\\x0c\\x00\\x0c\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:04", "lines": 12, "newlines": 12, "modlines": 0, "user": "KANNAN"}, "text": "/* REXX */\nARG UID N\nADDRESS ISPEXEC\n\"ISREDIT MACRO (UID N) NOPROCESS\"\nIF N = '' THEN N = 1\nADDRESS TSO\nSAY \"TEXT TO SEND ?\";PULL TXT\nDO N\n\"SEND '\"TXT\"'  USER(\"UID\") NOW\"\nEND\nEXIT\n\"SEND '\"TXT\"'  USER(\"UID\") LOGON\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "J2S": {"ttr": 3078, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x04\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00\\x0c\\x00\\x0c\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:04", "lines": 12, "newlines": 12, "modlines": 0, "user": "KANNAN"}, "text": "/* REXX J2S                                                           */\n/* JULIAN DATE TO STARDARD  YYYY.DDD ==> YYYY/MM/DD                   */\n/* JULIAN DATE TO STARDARD  YYYY/DDD ==> YYYY/MM/DD                   */\n/* CALL J2S STRIP('1999/166');SAY RESULT                              */\nARG JD\nIF POS('.',JD)>0 THEN PARSE VALUE JD WITH YYYY '.' DDD\nIF POS('/',JD)>0 THEN PARSE VALUE JD WITH YYYY '/' DDD\nDI = \"'\" || SUBSTR(YYYY,3,2) || DDD || \"'\"\nDI =        SUBSTR(YYYY,3,2) || DDD\nDD = DATE('S',DI,'J')\nRESULT =  INSERT('/', INSERT('/',DD,4), 7)\nRETURN RESULT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "KILL": {"ttr": 3080, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x04\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00\\x07\\x00\\x07\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:04", "lines": 7, "newlines": 7, "modlines": 0, "user": "KANNAN"}, "text": "PROC 1 UID\nCONTROL NOMSG\nSET &KILL = &STR(/*)\nSET &USER = &STR($VS,'C U=&UID')\nSUB * END(@@)\n&KILL&USER\n@@\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "LASTJCL": {"ttr": 3082, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x04\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00\\x17\\x00\\x17\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:04", "lines": 23, "newlines": 23, "modlines": 0, "user": "KANNAN"}, "text": "/* REXX LastJCL */\nddname = 'ISPCTL0'\nAddress ISPEXEC\n                'Control Errors Return'\n                'LMINIT DATAID(LASTJCL) DDNAME('ddname') ENQ(SHR)'\n                'EDIT   DATAID('LASTJCL')'\n                'LMFREE DATAID('LASTJCL')'\nExit\n\nOlderMethod:\n   ljdsn = \"'\"|| userid() || '.SPFTEMP0.CNTL' || \"'\"\n   AVAIL = SYSDSN(ljdsn)\n   IF AVAIL \\= \"OK\" THEN DO\n       ZEDSMSG = AVAIL\n      \"ISPEXEC SETMSG MSG(ISRZ000)\"\n       EXIT\n   END\n\"ISPEXEC Edit DATASET(\"ljdsn\")\"\nIF RC > 4 THEN DO\n    ZEDSMSG = \"//Unexpected Error \"||RC\n    \"ISPEXEC SETMSG MSG(ISRZ000)\"\nEND\nEXIT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LASTMM": {"ttr": 3084, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x04\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00\\x15\\x00\\x15\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:04", "lines": 21, "newlines": 21, "modlines": 0, "user": "KANNAN"}, "text": "/* REXX  Return Last Month*/\ncall getlastmonth\nsay date(s) YYMM\nfini :\nexit 0\n\ngetlastmonth : procedure expose YYMM\nd = date(s)\nYYMM = substr(d,3,4)\nYY   = substr(d,3,2)\nMM   = substr(d,5,2)\nif MM = '01' then do\n   MM = '12'\n   YY = YY - 1\nend\nelse\n   MM   = MM - 1\nif length(MM) = 1 then MM = '0' || MM\nif length(YY) = 1 then YY = '0' || YY\nYYMM = YY || MM\nreturn\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LEN": {"ttr": 3086, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x04\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x009\\x009\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:04", "lines": 57, "newlines": 57, "modlines": 0, "user": "KANNAN"}, "text": "/* REXX LEN*/\nISREDIT \"MACRO\"\nA = \"'\" ; Q = '\"' ; LN = 0 ; C = \"EQ\"\nCOLUMNS = \"----+----1----+----2\"| |,\n\"----+----3----+----4----+----5\"| |,\n\"----+----6----+----7----+----8\";\nISREDIT \"(NUM1,NUM2) = \"NUMBER\nPARSE VAR NUM2 NBR COB XTRA;\nISREDIT \"(CURSROW,CURSCOL) = \"CURSOR\nISREDIT \"(LRECL) = \"LRECL\nISREDIT \"(EDITLINE) = LINE \"CURSROW\nIF NBR = \"STD\" THEN LRECL = LRECL - 8;\nIF COB = \"COBOL\" THEN LRECL = LRECL - 6;\nIF CURSCOL > 0 THEN DO\n   BEGPOS = CURSCOL - 1\n   STRING1 = SUBSTR(EDITLINE,CURSCOL,(LRECL - BEGPOS))\n   IF SUBSTR(STRING1,1,1) = A THEN DO\n      X = A ; BEGPOS = BEGPOS + 1\n      CALL BYTESCAN ; END\n   ELSE\n   IF SUBSTR(STRING1,1,1) = Q THEN DO\n      X = Q ; BEGPOS = BEGPOS + 1\n      CALL BYTESCAN ; END\n   ELSE\n   IF SUBSTR(STRING1,1,1) = \" \" THEN DO\n      LN = LENGTH(STRING1) ; C = \"NE\"\n      CALL BYTESCAN ; END\n   ELSE DO\n   PARSE VAR STRING1 FIRST XTRA\n   LN = LENGTH(FIRST)\n   END\nEND\nIF LN > 0 THEN DO\n   ZMSG000S = LN\" CHARACTERS LONG\"\n   WRK1 = SUBSTR(\" \",1,BEGPOS)| |SUBSTR(COLUMNS,1,LN)\n   ISREDIT \"LINE_AFTER \"CURSROW\" = INFOLINE '&WRK1'\"\n   ISREDIT \"CURSOR = (CURSROW,CURSCOL)\"\n   END\nELSE DO\nZMSG000S = \"CANNOT DETERMINE LENGTH\"\nZMSG000L = \"CURSOR NOT IN DATA, STRIN\"| |,\n\"G CONTAINS MIS-MATCHED QUOTES OR OTH\"| |,\n\"ER ERROR OCCURED.\"\nEND\nISPEXEC \"SETMSG MSG(ISPZ000)\"\nEXIT\n/* -------- SCANNING SUBROUTINES---------------*/\nBYTESCAN: DO I=2 TO LENGTH(STRING1) BY 1\nIF C = \"EQ\" THEN CALL EQSCN\nELSE CALL NESCN\nEND ; RETURN\nEQSCN:  IF SUBSTR(STRING1,I,1) = X THEN DO\nLN = I - 2 ; I = LENGTH(STRING1)\nEND ; RETURN\nNESCN:  IF SUBSTR(STRING1,I,1) \\= \" \" THEN DO\nLN = I - 1 ; I = LENGTH(STRING1)\nEND ; RETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LIBRARN": {"ttr": 3088, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x04\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00\\x18\\x00\\x18\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:04", "lines": 24, "newlines": 24, "modlines": 0, "user": "KANNAN"}, "text": "/* REXX - TO INVOKE CA-LIBRARIAN */\n ADDRESS ISPEXEC\n CONTROL ERRORS RETURN\n \"LIBDEF ISPTLIB DATASET ID(                         ,\n            'SYS6.LIBRN.#420002.CLJ42CTL'            ,\n            'SYS6.LIBRN.#420002.CLU42ETL'            ,\n  )\"\n \"LIBDEF ISPPLIB DATASET ID(                         ,\n            'SYS6.LIBRN.#420002.CLJ42CPL'            ,\n            'SYS6.LIBRN.#420002.CLU42EPL'            ,\n  )\"\n \"LIBDEF ISPMLIB DATASET ID(                         ,\n            'SYS6.LIBRN.#420002.CLJ42CML'            ,\n            'SYS6.LIBRN.#420002.CLU42EML'            ,\n  )\"\n \"LIBDEF ISPSLIB DATASET ID(                         ,\n            'SYS6.LIBRN.#420002.CLJ42CSL'            ,\n  )\"\n \"SELECT PANEL(LIBRPDF) NEWAPPL(LIB@) PASSLIB\"\n \"LIBDEF ISPTLIB\"\n \"LIBDEF ISPPLIB\"\n \"LIBDEF ISPMLIB\"\n \"LIBDEF ISPSLIB\"\nEXIT 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LISTALL": {"ttr": 3090, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x04\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00\\x0b\\x00\\x0b\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:04", "lines": 11, "newlines": 11, "modlines": 0, "user": "KANNAN"}, "text": "/* REXX LISTCAT                                                       */\n/* .................................................................. */\n/* Author  : Kannan AK                                                */\n/* LISTCAT : LISTCAT ALL                                              */\n/* Notice  : None                                                     */\n/* Version : Alpha                                                    */\n/* Usage   : 3.4                                                      */\n/* .................................................................. */\narg str\nAddress TSO \"LISTC ENTRIES(\"str\") ALL\"\nReturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LOCDD": {"ttr": 3092, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x04\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00\\x15\\x00\\x15\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:04", "lines": 21, "newlines": 21, "modlines": 0, "user": "KANNAN"}, "text": "/* Rexx LocDD */\n\"ISREDIT MACRO\"\naddress ispexec\n'ISREDIT (openmbr) = MEMBER'\n'ISREDIT (opendsn) = DATASET'\ncall locatedd\nexit\n\nlocatedd :\n x=outtrap('ddl.')\n address tso \"lista st\"\n x=outtrap('off')\n do i=1 to ddl.0\n   c = word(ddl.i,1)\n   if pos(\".\",c) = 0 then iterate\n   if c = strip(opendsn) then do\n     say ddl.i;k=i+1;say ddl.k\n     say '--------------------------------------------'\n   end\n end\n return\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LOGONCMD": {"ttr": 3094, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x04\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00\\x12\\x00\\x12\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:04", "lines": 18, "newlines": 18, "modlines": 0, "user": "KANNAN"}, "text": "/* rexx - logoncmd */\n\n ASXBPTR  = storage(224,4)\n ASXB     = storage(d2x(c2d(ASXBPTR)+108),4)\n LWA      = storage(d2x(c2d(ASXB)+20),4)\n LWALGCMD = storage(d2x(c2d(LWA)+186),80)\n\n parse source . calltype .\n if calltype = 'COMMAND' then\n   do\n     if strip(lwalgcmd) = \"\" then\n       say \"You currently have no logon command.\"\n     else\n       say \"Your current logon command is:\" lwalgcmd\n     return\n   end\n else\n   return lwalgcmd\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LOOKE": {"ttr": 3096, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x04\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00^\\x00^\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:04", "lines": 94, "newlines": 94, "modlines": 0, "user": "KANNAN"}, "text": "/* Rexx                                                               */\n/* .................................................................. */\n/* Author  : Kannan AK                                                */\n/* LOOKE   : Look-up Elips and edit the member                        */\n/* Notice  : Shop dependencies may prevail. Do not put in command tab */\n/* Version : Beta                                                     */\n/* .................................................................. */\narg clpgm\nsignal on syntax  name qui\nsignal on novalue name qui\n\naddress ISPEXEC\n'ISREDIT MACRO'\n'control errors return'\nif clpgm \\= '' then signal skipcur\n\n'ISREDIT (ln,co) = cursor'\nif co = 0 then do\n             zedsmsg = ''\n             zedlmsg='cursor not located in screen text area'\n             'setmsg msg(isrz001)'\n             call curset\n             exit 1\nend\n'ISREDIT (ld) = line ' ln\nif substr(ld,co,1) = ' ' then do\n             zedsmsg = ''\n             zedlmsg='cursor must be on a word in text area'\n             'setmsg msg(isrz001)'\n             call curset\n             exit 1\nend\nttab  = \",=+*/.'\"\"()-\"\ntdata = translate(ld,\" \",ttab)\nstart = lastpos(\" \",tdata,co)\nif start = 0  then start = 1\ntemp = strip(substr(tdata,start),\"l\")\nparse var temp member . 1\n\nskipcur :\nif clpgm \\= '' then member = clpgm\nmember = strip(substr(member,1,8))\ncall goelips\ncall curset\nexit 0\n\ncurset:\n'ISREDIT cursor = (ln,co)'\nreturn\n\nqui :\nexit\n\ngoelips:\n   \"ISPEXEC libdef isptlib dataset id(\",\n           \"'sys6.librn.#420002.clj42ctl',\",\n           \"'sys6.librn.#420002.clu42etl')\"\n   \"ISPEXEC libdef ispplib dataset id(\",\n           \"'sys6.librn.#420002.clj42cpl',\",\n           \"'sys6.librn.#420002.clu42epl')\"\n   \"ISPEXEC libdef ispmlib dataset id(\",\n           \"'sys6.librn.#420002.clj42cml',\",\n           \"'sys6.librn.#420002.clu42eml')\"\n   \"ISPEXEC libdef ispslib dataset id(\",\n           \"'sys6.librn.#420002.clj42csl')\"\n\n    LIB = Userid()'.LIB'\n\n   \"ISPEXEC SELECT PGM(ELIPS)\"  ,\n   \"NEWAPPL(LIB@) PASSLIB\"      ,\n   \"PARM(EDREC(NOQUERY)\"        ,\n   \"DSN('\"LIB\"')\"               ,\n   \"CMD('INFO \"MEMBER\";END')\"   ,\n   \"RETURN )\"\n\n   \"ISPEXEC  SELECT PGM(ELIPS)\" ,\n   \"NEWAPPL(LIB@) PASSLIB\"      ,\n   \"PARM(EDREC(QUERY)\"          ,\n   \"DSN('\"LIB\"(\"MEMBER\")')\"     ,\n   \"CMD(EDIT)\"                  ,\n   \"RETURN)\"\n\n    if rc < 5 then do\n      ISPEXEC \"libdef isptlib\"\n      ISPEXEC \"libdef ispplib\"\n      ISPEXEC \"libdef ispmlib\"\n      ISPEXEC \"libdef ispslib\"\n      return\n    end\n    else do\n         'setmsg msg(isrz001)'\n         return\n    end\nreturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LRECL": {"ttr": 3099, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x04\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00\\x13\\x00\\x13\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:04", "lines": 19, "newlines": 19, "modlines": 0, "user": "KANNAN"}, "text": "/* REXX LRECL                                                         */\n/* .................................................................. */\n/* Author  : Kannan AK                                                */\n/* LRECL   : To get logical record length                             */\n/* Notice  : None                                                     */\n/* Version : Alpha                                                    */\n/* .................................................................. */\nADDRESS ISPEXEC\n\"ISREDIT MACRO\"\nIF RC = 20 THEN DO\n    ZEDSMSG = \"NOT A TSO COMMAND\"\n   \"SETMSG MSG(ISRZ000)\";EXIT\nEND\nADDRESS ISREDIT \"(LREC) = LRECL\"\nADDRESS ISREDIT \"(BLKS) = BLKSIZE\"\nLREC=LREC+0;BLKS=BLKS+0\nZEDSMSG = \"LRECL/BLKSZ:\"LREC\"/\"BLKS\n\"SETMSG MSG(ISRZ000)\"\nEXIT 1\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LS": {"ttr": 3101, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x04\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00`\\x00`\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:04", "lines": 96, "newlines": 96, "modlines": 0, "user": "KANNAN"}, "text": "/* Rexx LS */\narg DSNLVL\nif DSNLVL = '' then exit\nDSNLVL = Translate(DSNLVL,'',\"'\")\nvolume = 'VOLUME'\naddress ispexec\ntablename = LSP\ncall TBCreate\n'LMDINIT LISTID(dsnlist)  LEVEL('DSNLVL')'\nDSNAME = ''\nlistrc = 0\nDo While listrc = 0\n  'LMDLIST LISTID('dsnlist') OPTION(LIST) DATASET(DSNAME) STATS(YES)'\n  If rc = 0 & ZDLMIGR = 'NO' Then do\n    TTD = DSNAME\n    TTV = ZDLVOL\n    TTO = ZDLDSORG\n    TTF = ZDLRECFM\n    TTL = ZDLLRECL\n    TTB = ZDLLRECL\n    address ispexec \"TBADD\" tablename\n  End\n  listrc=rc\nEnd\n'LMDLIST LISTID('dsnlist') OPTION(FREE)'\n'LMDFREE LISTID('dsnlist')'\naddress ispexec \"TBTOP\" tablename\ndo forever until RC >= 8\n   address ispexec \"TBDISPL\" tablename \"PANEL(LSPNL) AUTOSEL(NO)\" ,\n            MESSAGE CURSOR CSRROW \"POSITION(CRP)\"\n   call navigate\nend\naddress ispexec \"TBEND\" tablename\nexit\n\nTBcreate :\n   call TBinit\n   address ispexec \"TBOPEN\" tablename                       /* exist? */\n   if RC = 8 then do\n      nop                                         /* well, do nothing */\n   end\n   else do\n      address ispexec \"TBEND\" tablename        /* send to recycle bin */\n   end\n                                                       /* create anew */\n   address ispexec \"TBCREATE \" tablename \"KEYS(TTD) ,\n                    NAMES(TTV,TTO,TTF,TTL,TTB)\"\nreturn\n\nnavigate :\n   if ZCMD = 'CANCEL' then do\n          address ispexec \"TBEND\" tablename\n          exit 0\n   end\ndo while ZTDSELS > 0\n   if ZCMD = 'CANCEL' then do\n          address ispexec \"TBEND\" tablename\n          exit 0\n   end\n\n   if ZTDSELS > 1 then\n      address ispexec \"TBDISPL\" tablename \"POSITION(CRP)\"\n   else\n      ZTDSELS = 0\n\n          SELECT\n            When (L='V') Then service='VIEW'\n            When (L='B') Then service='BROWSE'\n            When (L='S') Then service='EDIT'\n            When (L='/') Then service='EDIT'\n            When (L='E') Then service='EDIT'\n            Otherwise         service=''\n          End\n          If service \\= '' Then Do\n            L = ''\n            TTD = \"'\" || TTD || \"'\"\n            'ISPEXEC' service 'DATASET('TTD')'\n            If rc >= 12 Then 'SETMSG MSG(ISRZ002)'\n          End\n          Else do\n            L = ''\n            ZEDLMSG = 'V-View E-Edit S-Edit /-Edit B-Browse'\n            \"ISPEXEC SETMSG MSG(ISRZ000)\"\n          End\n   address ispexec \"TBTOP\" tablename\n   address ispexec \"TBSKIP\" tablename \"NUMBER(\"ZTDTOP\")\"\nend\nreturn\n\nTBinit :\nMESSAGE = 'MSG()'\nCURSOR  = 'CURSOR()'\nCSRROW  = 'CSRROW(1)'\nRETCODE = 0\nReturn\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LSPNL": {"ttr": 3104, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x04\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00\\x11\\x00\\x11\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:04", "lines": 17, "newlines": 17, "modlines": 0, "user": "KANNAN"}, "text": ")Attr\n! TYPE(INPUT ) INTENS(HIGH) JUST(LEFT ) CAPS(ON ) PAD('_') COLOR(YELLOW)\n@ TYPE(OUTPUT) INTENS(LOW ) JUST(LEFT ) CAPS(OFF) PAD(' ') COLOR(TURQ)\n{ TYPE(OUTPUT) INTENS(HIGH) JUST(LEFT ) CAPS(OFF) PAD(' ')\n? TYPE(INPUT ) INTENS(HIGH) JUST(LEFT)  CAPS(OFF) PAD(' ') HILITE(USCORE)\n_ TYPE(INPUT ) INTENS(HIGH) JUST(LEFT)  PAD(' ') CAPS(OFF)\n} TYPE(TEXT  ) INTENS(HIGH) JUST(LEFT)  PAD(' ') CAPS(OFF) COLOR(PINK)\n)Body  expand(//)\n%DSLIST - Data Sets Matching &DSNLVL\n%Command ===>_ZCMD                                  / / %Scroll ===>_AMT +\n+\n+}  Dataset                                        Volume  Org Fmt Lrecl Blksz\n)Model\n!L+@TTD                                           @TTV    @TTO@TTF@TTL  @TTB\n)Proc\n&CNAME  = .CURSOR\n)End\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "MAIN": {"ttr": 3329, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x04\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00\\xd0\\x00\\xd0\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:04", "lines": 208, "newlines": 208, "modlines": 0, "user": "KANNAN"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "MAKEJCL": {"ttr": 3333, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x04\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00\\x15\\x00\\x15\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:04", "lines": 21, "newlines": 21, "modlines": 0, "user": "KANNAN"}, "text": "/* REXX ***************************************************************/\n/* UTILITY: SYS2JCL                                                   */\n/* AUTHOR: DAVID LEIGH                                                */\n/* FUNCTION: THIS EDIT MACRO PROCESSES A FILE OF JES OUTPUT AND       */\n/*           EXTRACTS JUST THE SUBMITTED JCL AND SHIFTS IT BACK TO    */\n/*           THE LEFT TO MAKE EXECUTABLE JCL OUT OF THE THE SYSOUT.   */\n/*           IT DOES NOT, HOWEVER, RESTORE ANY INSTREAM DATA.         */\n/**********************************************************************/\nADDRESS ISPEXEC\n'CONTROL ERRORS RETURN'\nADDRESS ISREDIT\n\"MACRO\"\n\"EXCLUDE ALL P'=' 1\"\n\"FIND ALL '//' 12\"\n\"DELETE ALL X\"\n\"FIND FIRST P'=' 1\"\nDO WHILE RC = 0\n    \"SHIFT ( .ZCSR 11\"\n    \"FIND NEXT P'=' 1\"\nEND\n\"UP MAX\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MASSCOPY": {"ttr": 3335, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x04\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00w\\x00w\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:04", "lines": 119, "newlines": 119, "modlines": 0, "user": "KANNAN"}, "text": "/* Rexx Masscopy                                                     */\n/* Syntax : tso YYMM                                                 */\narg YYMM\nif YYMM = '' | datatype(YYMM) <> 'NUM' then do\n   ZEDSMSG = '*Need numeric YYMM*'\n   \"ISPEXEC SETMSG MSG(ISRZ000)\"\n   exit 1\nend\nlocaluser = Userid()\nwjcount = 0\ncn      = 0\naddress ISPEXEC\n\naddress ISPEXEC \"Control Errors Return\"\ncall parse_listcat\ncall build_jobcard\ncall feed_job_details\ncall edit_jcl\n\nqui :\naddress ISPEXEC 'LMFREE DATAID('trap')'\naddress TSO 'FREE F('ddname')'\nexit\n\nbuild_jobcard:\naddress TSO\ncall wj(\"//\"userid()\"$ JOB (000000),'BT:KANNAN AK\" yymm\"',            \")\ncall wj(\"//         CLASS=U,MSGCLASS=X,NOTIFY=&SYSUID,COND=(5,LT)     \")\nreturn\n\nbuild_jcl :\ncn = cn + 1\ntx = translate(format(cn,3,0),'0',' ')\ncall wj(\"//*---------------------------------------------------------*\")\ncall wj(\"//QCOPY\"tx\" EXEC PGM=IDCAMS                                  \")\ncall wj(\"//SYSPRINT DD SYSOUT=*                                       \")\ncall wj(\"//SYSUT1   DD DISP=SHR,DSN=\"fstr\"                            \")\ncall wj(\"//SYSUT2   DD DSN=\"udsname\",                                 \")\ncall wj(\"//            DISP=(NEW,CATLG,DELETE),                       \")\ncall wj(\"//            SPACE=(CYL,(100,100),RLSE),                    \")\ncall wj(\"//            RECFM=FB,LRECL=135,BLKSIZE=0                   \")\ncall wj(\"//*           DCB=(userid.model.VB)                          \")\ncall wj(\"//SYSIN    DD *                                              \")\ncall wj(\"  REPRO INFILE(SYSUT1) OUTFILE(SYSUT2)                       \")\ncall wj(\"/*                                                           \")\nreturn\n\nwj :\nparse arg stream\nqueue stream\nwjcount = wjcount + 1\nreturn\n\nedit_jcl :\nZEDSMSG = '*Verify & submit*'\n\"ISPEXEC SETMSG MSG(ISRZ000)\"\nif queued() > 0 then\ndo\n address ISPEXEC 'VGET (ZSCREEN) SHARED'\n ddname='$MASS$'zscreen\n address TSO\n 'ALLOC F('ddname') UNIT(VIO) DSO(PS) RECFM(F B) LRECL(080) NEW DEL REU'\n 'EXECIO 'queued()' DISKW 'ddname' (FINIS'\n address ISPEXEC 'LMINIT DATAID(TRAP) DDNAME('ddname') ENQ(SHR)'\n address ISPEXEC 'EDIT   DATAID('trap')'\nend\nreturn\n\nparse_listcat :\ntapedsn. = ''\nk = 1\nf = outtrap('out.','*','noconcat')\naddress TSO \"LISTCAT LEVEL ('SYSAK.FILES\"YYMM\"') NAME NVSAM\"\nlistrc = RC\nf = outtrap(off)\nif listrc \\= 0 then do\n   do j = 1 to out.0\n      say out.j\n   end\n   exit listrc\nend\nhlq = 'SYSAK.FILES'\ndo i = 1 to out.0\n  if pos(hlq,out.i) <> 0 then\n    if pos(hlq,out.i) > 0 then do\n       parse value out.i with . . dsname\n       if pos('REJECT1',out.i) = 0 & ,\n          pos('REJECT2',out.i) = 0 then do\n             tapedsn.k = dsname\n             k = k + 1\n       end\n    end\nend\ntapedsn.0 = k-1\nreturn\n\n\nfeed_job_details :\ndo i = 1 to tapedsn.0\n   fstr = tapedsn.i\n   udsname = localuser || substr(tapedsn.i,8)\n   call change udsname 'TAPES' 'DISK'\n   udsname = target\n   call build_jcl\nend\nreturn\n\nchange : procedure expose target oldstr newstr\narg target oldstr newstr\nif pos(oldstr,target) = 0 then return 'ERROR'\n\nif length(oldstr) >= length(newstr) then\ntarget = space(overlay(newstr,target,pos(oldstr,target),length(oldstr)),0)\n\nif length(oldstr) < length(newstr) then\ntarget = substr(target,1,pos(oldstr,target)-1) || newstr || ,\n         substr(target,pos(oldstr,target)+length(oldstr))\nreturn target\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MASSDEL": {"ttr": 3338, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x04\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00d\\x00d\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:04", "lines": 100, "newlines": 100, "modlines": 0, "user": "KANNAN"}, "text": "/* Rexx Massdel to scratch tapes                                     */\n/* Syntax : tso YYMM                                                 */\narg YYMM\nif YYMM = '' | datatype(YYMM) <> 'NUM' then do\n   ZEDSMSG = '*Need numeric YYMM*'\n   \"ISPEXEC SETMSG MSG(ISRZ000)\"\n   exit 1\nend\nlocaluser = Userid()\nwjcount = 0\ncn      = 0\naddress ISPEXEC\n\naddress ISPEXEC \"Control Errors Return\"\ncall parse_listcat\ncall build_jobcard\ncall feed_job_details\ncall edit_jcl\n\nqui :\naddress ISPEXEC 'LMFREE DATAID('trap')'\naddress TSO 'FREE F('ddname')'\nexit\n\nbuild_jobcard:\naddress TSO\ncall wj(\"//\"userid()\"@ JOB (000000),'BT:KANNAN AK',                   \")\ncall wj(\"//         CLASS=U,MSGCLASS=X,NOTIFY=&SYSUID,COND=(5,LT)     \")\nreturn\n\nbuild_jcl :\ncn = cn + 1\ntx = translate(format(cn,3,0),'0',' ')\ncall wj(\"//*---------------------------------------------------------*\")\ncall wj(\"//QDELE\"tx\" EXEC PGM=IEFBR14                                 \")\ncall wj(\"//SYSPRINT DD SYSOUT=*                                       \")\ncall wj(\"//FILE01   DD DSN=\"fstr\",                                    \")\ncall wj(\"//            DISP=(MOD,DELETE)                              \")\ncall wj(\"//*           UNIT=TAPE                                      \")\ncall wj(\"/*                                                           \")\nreturn\n\nwj :\nparse arg stream\nqueue stream\nwjcount = wjcount + 1\nreturn\n\nedit_jcl :\nZEDSMSG = '*Verify & submit*'\n\"ISPEXEC SETMSG MSG(ISRZ000)\"\nif queued() > 0 then\ndo\n address ISPEXEC 'VGET (ZSCREEN) SHARED'\n ddname='$MASS$'zscreen\n address TSO\n 'ALLOC F('ddname') UNIT(VIO) DSO(PS) RECFM(F B) LRECL(080) NEW DEL REU'\n 'EXECIO 'queued()' DISKW 'ddname' (FINIS'\n address ISPEXEC 'LMINIT DATAID(TRAP) DDNAME('ddname') ENQ(SHR)'\n address ISPEXEC 'EDIT   DATAID('trap')'\nend\nreturn\n\nparse_listcat :\ntapedsn. = ''\nk = 1\nf = outtrap('out.','*','noconcat')\naddress TSO \"LISTCAT LEVEL ('SYSAK.FILES\"YYMM\"') NAME NVSAM\"\nlistrc = RC\nf = outtrap(off)\nif listrc \\= 0 then do\n   do j = 1 to out.0\n      say out.j\n   end\n   exit listrc\nend\nhlq = 'SYSAK.FILES'\ndo i = 1 to out.0\n  if pos(hlq,out.i) <> 0 then\n    if pos(hlq,out.i) > 0 then do\n       parse value out.i with . . dsname\n       if pos('REJECT1',out.i) = 0 & ,\n          pos('REJECT2',out.i) = 0 & ,\n          pos('REJECT3',out.i) = 0 then do\n             tapedsn.k = dsname\n             k = k + 1\n       end\n    end\nend\ntapedsn.0 = k-1\nreturn\n\n\nfeed_job_details :\ndo i = 1 to tapedsn.0\n   fstr = tapedsn.i\n   call build_jcl\nend\nreturn\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MASSDELP": {"ttr": 3341, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x04\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00`\\x00`\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:04", "lines": 96, "newlines": 96, "modlines": 0, "user": "KANNAN"}, "text": "/* Rexx Massdelp to scratch tapes                                    */\n/* Syntax : tso dsnlevel                                             */\narg dsnlevel\nif dsnlevel = '' then do\n   ZEDSMSG = '*Need non-numeric dsnlevel*'\n   \"ISPEXEC SETMSG MSG(ISRZ000)\"\n   exit 1\nend\nlocaluser = Userid()\nwjcount = 0\ncn      = 0\naddress ISPEXEC\n\naddress ISPEXEC \"Control Errors Return\"\ncall parse_listcat\ncall build_jobcard\ncall feed_job_details\ncall edit_jcl\n\nqui :\naddress ISPEXEC 'LMFREE DATAID('trap')'\naddress TSO 'FREE F('ddname')'\nexit\n\nbuild_jobcard:\naddress TSO\ncall wj(\"//\"userid()\"@ JOB (000000),'BT:KANNAN AK',TYPRUN=SCAN,       \")\ncall wj(\"//         CLASS=U,MSGCLASS=X,NOTIFY=&SYSUID,COND=(5,LT)     \")\nreturn\n\nbuild_jcl :\ncn = cn + 1\ntx = translate(format(cn,3,0),'0',' ')\ncall wj(\"//*---------------------------------------------------------*\")\ncall wj(\"//QDELE\"tx\" EXEC PGM=IEFBR14                                 \")\ncall wj(\"//SYSPRINT DD SYSOUT=*                                       \")\ncall wj(\"//FILE01   DD DSN=\"fstr\",                                    \")\ncall wj(\"//            DISP=(MOD,DELETE),                             \")\ncall wj(\"//            UNIT=TAPE                                      \")\ncall wj(\"/*                                                           \")\nreturn\n\nwj :\nparse arg stream\nqueue stream\nwjcount = wjcount + 1\nreturn\n\nedit_jcl :\nZEDSMSG = '*Verify & submit*'\n\"ISPEXEC SETMSG MSG(ISRZ000)\"\nif queued() > 0 then\ndo\n address ISPEXEC 'VGET (ZSCREEN) SHARED'\n ddname='$MASS$'zscreen\n address TSO\n 'ALLOC F('ddname') UNIT(VIO) DSO(PS) RECFM(F B) LRECL(080) NEW DEL REU'\n 'EXECIO 'queued()' DISKW 'ddname' (FINIS'\n address ISPEXEC 'LMINIT DATAID(TRAP) DDNAME('ddname') ENQ(SHR)'\n address ISPEXEC 'EDIT   DATAID('trap')'\nend\nreturn\n\nparse_listcat :\ntapedsn. = ''\nk = 1\nf = outtrap('out.','*','noconcat')\naddress TSO \"LISTCAT LEVEL ('\"dsnlevel\"') NAME NVSAM\"\nlistrc = RC\nf = outtrap(off)\nif listrc \\= 0 then do\n   do j = 1 to out.0\n      say out.j\n   end\n   exit listrc\nend\nhlq = dsnlevel\ndo i = 1 to out.0\n  if pos(hlq,out.i) <> 0 then\n    if pos(hlq,out.i) > 0 then do\n       parse value out.i with . . dsname\n       tapedsn.k = dsname\n       k = k + 1\n    end\nend\ntapedsn.0 = k-1\nreturn\n\n\nfeed_job_details :\ndo i = 1 to tapedsn.0\n   fstr = tapedsn.i\n   call build_jcl\nend\nreturn\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MASSSTAT": {"ttr": 3585, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x04\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00J\\x00J\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:04", "lines": 74, "newlines": 74, "modlines": 0, "user": "KANNAN"}, "text": "/* Rexx */\n/* .................................................................. */\n/* Author  : Kannan AK                                                */\n/* MASSSTAT: Mass ISPF statistic generator                            */\n/* Notice  : Include your datasets at the bottom of the exec          */\n/*           Output will be under <userid>.<cue>.MEMBERS              */\n/*           Exceptions will not generate output                      */\n/* Version : Alpha                                                    */\n/* .................................................................. */\ndlm = '/'\nCall GetInstreamCommands\n Do Queued()\n   Pull  c\n   Upper c\n   If word(c,1) = \"/*\" Then Iterate\n   If c = \"\"           Then Iterate\n   dlm=substr(c,1,1)\n   Parse Var c (dlm) dsn (dlm) mid .\n   Call GetStat dsn mid\n End\nDo queued();Pull;End\nExit 0\n\n\nGetStat:\nArg LMDsn Cue\nIf LMDsn = '' Then Do\n   Say 'Missing input file name.'\n   Return\nEnd\nIf Cue = ''   Then Do\n   Say 'Missing Cue name. USERID.CUE.MEMBERS will be the output file.'\n   Return\nEnd\n\nAddress ISPEXEC\n RC = 0\n \"CONTROL ERRORS RETURN\"\n \"LMINIT DATAID(STATID)  DATASET('\"LMDsn\"')\"\n LastRC = RC\n If RC = 0 Then Do\n   \"LMOPEN  DATAID(\"STATID\")\"\n   \"LMMLIST DATAID(\"STATID\") OPTION(SAVE) STATS(YES) GROUP(\"Cue\")\"\n End\n Else Do\n   \"ISPEXEC GETMSG MSG(ISRZ002) SHORTMSG(SMSG)\"\n   Say 'LMINIT Service has returned 'LastRC\n   Say LMDsn ':' SMSG\n   Return\n End\n \"LMFREE DATAID(\"STATID\")\"\nSay userid()||'.'Cue'.'||MEMBERS has been created\nReturn\n\nGetInstreamCommands:\nexec_line = 40\nDo queued();Pull;End\nDo Until substr(line,1,9)='/*COMMAND'\n  line = sourceline(exec_line)\n  exec_line = exec_line + 1\nEnd\nDo until substr(line,1,2)='*/'\n  line = sourceline(exec_line)\n  If substr(line,1,2) \\= '*/' Then\n    Queue line\n    exec_line = exec_line + 1\nEnd\nReturn\n\n/*COMMAND\n/USERID.HANNA.LOADLIB/STAT1\n/USERID.HANNA.CNTL/STAT2\n/USERID.HANNA.CNTL.BACKUP/STAT3\n*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MEMBER": {"ttr": 3588, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x04\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00:\\x00:\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:04", "lines": 58, "newlines": 58, "modlines": 0, "user": "KANNAN"}, "text": "/* Rexx  find which data sets in a dslist contain a member           */\n/*       Syntax: Tso findmem pattern                                 */\n/*       where pattern is a name or pattern with % And * Characters  */\n/*       requires ISPF 4.5+              Doug nadel 6/2001           */\n/*       ** Uses some undocumented or unsupported methods ***        */\n/*       ** Renamed to Member to reflect z/os command                */\nParse Upper Arg pattern .\nIf pattern=\"\" Then                     /* Insure parm was passed     */\n  Do\n    Say \"No member pattern specified\"\n    Exit\n  End\ndta = ptr(76+ptr(ptr(24+ptr(112+ptr(132+ptr(540))))))\ntname=storage(d2x(dta+196),8)          /* Get dslist table name      */\nIf substr(tname,1,3)=\"DSL\" & \"NUM\"=datatype(delstr(tname,1,3)) Then\n  Do\n    say tname\n    Address ispexec\n    \"CONTROL ERRORS RETURN\"            /* Trap errors                */\n    \"TBTOP  \"tname                     /* Move to top of table       */\n    \"TBSKIP \"tname                     /* Go to 1st row              */\n    Do While rc=0                      /* Loop through rows          */\n      zudxstat=\"Y\"                     /* Exclude the line           */\n      If zudvol \\= \"MIGRAT\" & substr(zudvol,1,1)\\= \"*\" Then\n        Do                             /* If online real dataset     */\n          \"LMINIT DATAID(MS) DATASET('&ZUDSNS') ENQ(SHR) ORG(DSO)\"\n          If rc=0 Then                 /* Allocated?                 */\n            Do\n              If dso=\"PO\" Then         /* Known pds or pdse          */\n                Do\n                  check=\"\"             /* Init for LMMLIST           */\n                  \"LMOPEN DATAID(&MS) OPTION(INPUT)\" /* Open the ds  */\n                  If rc=0 Then         /* Open OK?                   */\n                    If pos(\"*\",pattern)>0 | pos(\"%\",pattern)>0 Then\n                      \"LMMLIST DATAID(&MS) MEMBER(CHECK) \",\n                        \"PATTERN(&PATTERN) OPTION(LIST)\"\n                    Else\n                      \"LMMFIND DATAID(&MS) MEMBER(&PATTERN) \"\n                  If rc=0 Then         /* If found                   */\n                    Do\n                      zudxstat=\"N\"     /* Unexclude list             */\n                      zulmsg=\"07\"x||\"FOUND: \"pattern /* Set message  */\n                    End\n                End\n              \"LMFREE DATAID(&MS)\"     /* Free the allocation        */\n            End\n        End\n      \"TBPUT  \"tname                   /* Update the table           */\n      \"TBSKIP \"tname                   /* Move to next row           */\n    End\n    \"CONTROL NONDISPL ENTER\"           /* Force refresh              */\n  End\nElse\n  Say \" The data set list table could not be found \" tname\nReturn\n\nptr:Return c2d(storage(d2x(Arg(1)),4))\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MQRC": {"ttr": 3590, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x04\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00\\x17\\x00\\x17\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:04", "lines": 23, "newlines": 23, "modlines": 0, "user": "KANNAN"}, "text": "/* Rexx */\narg mqrcc\nif  mqrcc = '' | mqrcc = '?' then do\n    ZEDLMSG = ' MQ ReturnCode Translator Syntax : tso mqrc _returncode_ '\n    signal Qui\nend\nif  mqrcc < 0 | mqrcc > 9999 | length(mqrcc) > 4 then do\n    ZEDLMSG = ' Value is out of range or non-numeric '\n    signal Qui\nend\nRXMQVTRACE = ''\nrcc = RXMQV('INIT')\n   interpret 'MQRC_TEXT = RXMQV.RCMAP.'mqrcc\nif pos('RXMQV.RCMAP',MQRC_TEXT) > 0 then\n       ZEDLMSG = ' No Text Found; Refer Manuals!'\nelse\n       ZEDLMSG = mqrcc ':' MQRC_TEXT\naddress ispexec \"SETMSG MSG(ISRZ000)\"\nRXMQVTRACE = ''\nrcc= RXMQV('TERM')\nQui :\n    address ispexec \"SETMSG MSG(ISRZ000)\"\n    Exit 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MSGPNL": {"ttr": 3592, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x04\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00\\t\\x00\\t\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:04", "lines": 9, "newlines": 9, "modlines": 0, "user": "KANNAN"}, "text": ")ATTR\n$ TYPE(OUTPUT) INTENS(HIGH) PAD(' ')\n)BODY WINDOW(25,2)\n$Msgout\n)PROC\n  &CPOS   = .CSRPOS             /* GET CURSOR OFFSET                  */\n  &CNAME  = .CURSOR             /* GET CURSOR FIELD NAME              */\n  &CSEL   = &ZKEY\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "NAB": {"ttr": 3594, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x04\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x001\\x001\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:04", "lines": 49, "newlines": 49, "modlines": 0, "user": "KANNAN"}, "text": "/* rexx nab 8 char at cursor                                          */\narg grabbed\naddress ISPEXEC\n'ISREDIT macro'\n\nsignal on halt    name qui\nsignal on syntax  name qui\nsignal on error   name qui\nsignal on failure name qui\n\nif grabbed \\= '' then signal skipcur\n'ISREDIT (ln,co) = cursor'\nif co = 0 then\n   do\n             zedsmsg = ''\n             zedlmsg='cursor not located in screen text area'\n             'setmsg msg(isrz001)'\n             call curset\n   exit\nend\n'ISREDIT (ld) = line ' ln\nif substr(ld,co,1) = ' ' then\n   do\n             zedsmsg = ''\n             zedlmsg='cursor must be on a word in text area'\n             'setmsg msg(isrz001)'\n             call curset\n    exit\nend\nttab  = \",=+*/.'\"\"()-\"\ntdata = translate(ld,\" \",ttab)\nstart = lastpos(\" \",tdata,co)\nif start = 0  then start = 1\ntemp = strip(substr(tdata,start),\"l\")\nparse var temp parmer . 1\n\nskipcur :\nif grabbed \\= '' then parmer = grabbed\n\nparmer = strip(substr(parmer,1,8))\n\nsay parmer\ncall curset\nexit 0\n\ncurset:\n'ISREDIT cursor = (ln,co)'; return\nqui :\nexit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "NOTMACRO": {"ttr": 3596, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x04\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00\\x0e\\x00\\x0e\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:04", "lines": 14, "newlines": 14, "modlines": 0, "user": "KANNAN"}, "text": "/* Rexx - Test for TSO invocation to go, prevent MACRO mode */\nParse Source . . Me .\nAddress ISPEXEC \"Control Errors Return\"\nAddress ISREDIT \"Locate .ZF\"\nIf RC = 28 Then Do\n   ZEDSMSG = 'Not an Edit Macro'\n   ZEDLMSG = Me 'has to be invoked as TSO command'\n   'ISPEXEC SETMSG MSG(ISRZ001)'\n   Exit 1\nEnd\nZEDSMSG = 'Proceeding...'\n'ISPEXEC SETMSG MSG(ISRZ001)'\nNop /* Rest of the processing */\nExit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ONLY": {"ttr": 3598, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x04\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00\\x07\\x00\\x07\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:04", "lines": 7, "newlines": 7, "modlines": 0, "user": "KANNAN"}, "text": "/* REXX ONLY */\n\"ISREDIT MACRO (STRING) NOPROCESS\"\nADDRESS ISPEXEC\n  \"ISREDIT EXCLUDE ALL\"\n  STRING = \"'\"||STRING||\"'\";\n  \"ISREDIT FIND\" STRING \"ALL\"\n  EXIT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "OPENTAB": {"ttr": 3600, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x04\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00\\x1b\\x00\\x1b\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:04", "lines": 27, "newlines": 27, "modlines": 0, "user": "KANNAN"}, "text": "/* REXX  - show open ISPF tables - assumes exec run from ISPF        */\n/* Doug Nadel                                                        */\ntcb=ptr(132+ptr(540))                  /* parent of tcb of rexx exec */\ntld = ptr(ptr(24+ptr(112+tcb)))        /* screen tld                 */\ntld = ptr(128+ptr(60+ptr(56+tld)))     /* parent tld (TLD0)          */\nSay 'Global '\nCall listtables\ntcb = ptr(136+ptr(132+tcb))\nDo While tcb \\= 0\n  tld = ptr(ptr(24+ptr(112+tcb)))\n  If stg(tld,3) = 'TLD' Then Say 'Screen 'stg(tld+3,1)\n  Call listtables\n  tcb = ptr(128+tcb)\nEnd\nExit\nlisttables:  Procedure Expose tld\nIf stg(tld,3) = 'TLD' Then\n  Do\n    dtb = ptr(44+ptr(76+tld))\n    Do While dtb \\= 0\n      Say '   'stg(dtb+6,8)\n      dtb = ptr(68+dtb)\n    End\n  End\nReturn\nptr:  Return c2d(storage(d2x(Arg(1)),4)) /* return pointer at offset*/\nstg:  Return storage(d2x(Arg(1)),Arg(2))     /* Return storage */\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAD": {"ttr": 3602, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x04\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00\\x8e\\x00\\x8e\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:04", "lines": 142, "newlines": 142, "modlines": 0, "user": "KANNAN"}, "text": "/* REXX PAD */\nPARSE SOURCE SYSTEM . CMDNAME .\nADDRESS ISPEXEC\nCONTROL ERRORS RETURN\nADDRESS TSO\n   CDSN =\"'\"||USERID()||\".##PAD##\"||\"'\"\n   AVAIL = SYSDSN(CDSN)\n   IF AVAIL \\= \"OK\" THEN DO\n      IF AVAIL = \"DATASET NOT FOUND\" THEN DO\n               ADDRESS TSO\n              'ALLOC NEW CAT F(CUEDD) DSO(PS) DIR(0) SP(1,1) TRACK\n               DA(##PAD##) REUSE\n               RECFM(F B) BLKSIZE(0) LRECL(80) UNIT(SYSALLDA)'\n               ZEDLMSG = \"CLIPBOARD FILE DID NOT EXIST. CREATED NEW.\"\n               \"ISPEXEC SETMSG MSG(ISRZ001)\"\n      END\n      ELSE DO\n               ZEDSMSG = AVAIL\n               \"ISPEXEC SETMSG MSG(ISRZ001)\";EXIT\n      END\n   END\n    \"ALLOC DS(\"CDSN\") DD(CUEDD) SHR REUSE\"\n   IF RC \\= 0 THEN DO\n       ZEDSMSG = cmdname\":FILE ALLOC ERROR\"\n       \"ISPEXEC SETMSG MSG(ISRZ001)\" ;EXIT\n   END\nCUE = ' '\n\"EXECIO *  DISKRU CUEDD (STEM CUE FINIS\"\nIF RC \\= 0 THEN DO\n       ZEDSMSG = cmdname\":I/O ERROR \"\n       \"ISPEXEC SETMSG MSG(ISRZ001)\" ;SIGNAL QUI\nEND\nCall DisplayPanel\nADDRESS TSO \"EXECIO 17 DISKW CUEDD (STEM CUE FINIS\"\nIF RC \\= 0 THEN DO\n       ZEDSMSG = cmdname\":I/O BUFFER EMPTY\"\n       \"ISPEXEC SETMSG MSG(ISRZ001)\" ;SIGNAL QUI\nEND\nELSE DO\n       ZEDSMSG = cmdname\":Ok\"\n       \"ISPEXEC SETMSG MSG(ISRZ001)\"\nEND\nQUI :\nZCMD = ''\nDROP CUE\nEXIT\n\n\nDisplayPanel :\nAddress 'ISPEXEC'\nexec_line=1\nif system = 'TSO' then\n  Address tso 'ALLOC NEW CAT F($TMPLIB$) DSO(PO) DIR(1) SP(3,3) TRACK\n               DA($WWWSAMP.TEMP.ISPFLIB) REUSE\n               RECFM(F B) BLKSIZE(0) LRECL(80) UNIT(SYSALLDA)'\nCall MakeMember\nif system = 'TSO' then\n  Address tso 'ALLOC F($TMPLIB$) OLD DA($WWWSAMP.TEMP.ISPFLIB) REUSE'\nIf system = 'TSO' Then\n  Do\n    'VGET ZENVIR'\n    If substr(zenvir,6,1)>='4' Then stack='STACK' /* Use STACK in V4 */\n    Else stack = ''\n    'LIBDEF ISPPLIB LIBRARY ID($TMPLIB$)' stack\n    'LIBDEF ISPMLIB LIBRARY ID($TMPLIB$)' stack\n  End\nElse\n  Do\n    'LIBDEF ISPPLIB FILE ID(ISRNULL $TMPLIB$ A)'\n    'LIBDEF ISPMLIB FILE ID(ISRNULL $TMPLIB$ A)'\n  End\n'ADDPOP'\nDo Until rc > 0\n  'DISPLAY PANEL(CLIPPNL)'\nEnd\n'REMPOP'\n\n'LIBDEF ISPPLIB '\n'LIBDEF ISPMLIB '\nIf system = 'TSO' Then Address tso 'FREE F($TMPLIB$) DELETE'\nElse                   Address '' 'ERASE * $TMPLIB$ A '\n\nDo queued();Pull;End\nReturn\n\nMakeMember :\nDo queued();Pull;End\nDo Until substr(line,1,7)='/*PANEL'\n  line = sourceline(exec_line)\n  exec_line=exec_line+1\nEnd\nParse Var line . panelname .\nDo until substr(line,1,2)='*/'\n  line = sourceline(exec_line)\n  if substr(line,1,2)\u00ac='*/' then\n    Queue line\n  exec_line=exec_line+1\nEnd\nif system = 'TSO' then\n  do\n    pands='$WWWSAMP.TEMP.ISPFLIB('panelname')'\n    Address tso 'ALLOC OLD F($TMPLIB$) DSO(PO) DIR(1) SP(3,3) TRACK\n                da('pands') RECFM(F B) BLKSIZE(0) LRECL(80) REUSE\n                UNIT(SYSALLDA)'\n    Address 'TSO' 'EXECIO 'queued()' DISKW $TMPLIB$ ( FINIS'\n  end\nelse\n do\n  Address '' 'ERASE 'panelname' $TMPLIB$ A '\n Address '' 'EXECIO 'queued()' DISKW 'panelname' $TMPLIB$ A 1 F ( FINIS'\n end\nDo queued();Pull;End\nReturn\n\n/*PANEL CLIPPNL\n)ATTR\n? TYPE(INPUT) INTENS(LOW) JUST(LEFT)\n_ TYPE(INPUT) INTENS(LOW) JUST(LEFT) PAD(' ') COLOR(YELLOW) CAPS(OFF)\n$ TYPE(INPUT) INTENS(LOW)            PAD(' ') COLOR(WHITE ) CAPS(OFF)\n)BODY WINDOW(70,18)\n Command ==>?ZCMD\n_cue1\n_cue2\n_cue3\n_cue4\n_cue5\n_cue6\n_cue7\n_cue8\n_cue9\n_cue10\n_cue11\n_cue12\n_cue13\n_cue14\n_cue15\n_cue16\n$cue17\n)INIT\n&ZWINTTL = '* ClipBoard *'\n)END\n*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PATTERN": {"ttr": 3606, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x04\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00\\xff\\x00\\xff\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:04", "lines": 255, "newlines": 255, "modlines": 0, "user": "KANNAN"}, "text": "/*---------Language: REXX-------------------------------------$$PROLOG*/\n/*     Program Name: PATMATCH.CMD                                     */\n/*      Description: REXX exec to perform QA tests for patmatch.      */\n/*    Customization: None                                             */\n/* Input Parameters: None                                             */\n/*    Statvars Used: None                                             */\n/*          Invokes: None                                             */\n/*     Return Codes: 0  - Successful Completion                       */\n/* Related Routines: None                                             */\n/*     Restrictions: None                                             */\n/*     Dependencies: None                                             */\n/*       Change log: Add new entries to the top                       */\n/*-----------------Changed 12-MAY-2001 by: Bob Stark -----------------*/\n/* 1. Cleanup for posting                                             */\n/*--------------------------------------------------------------------*/\n/* Copyright (C) 2000 ProTech Professional Technical Services. No war-*/\n/* ranty expressed or implied. Permission to use, copy, and distribute*/\n/* this document without fee is hereby granted, provided that this    */\n/* copyright notice appear in all copies.  Permission to modify the   */\n/* code is granted, but not the right to distribute the modified code,*/\n/* which should be returned to the maintainer for inclusion into the  */\n/* distributed version.  Contacts: 412-373-8855  www.protechpts.com   */\n/*--------------------------------------------------------------------*/\n\nCALL   ON ERROR   NAME RXERROR\nSIGNAL ON SYNTAX  NAME RXERROR\nSIGNAL ON NOVALUE NAME RXERROR\n\nsay patmatch('ABCDWxyz','ABCDwxyz')' = 1'\nSAY PATMATCH('ABCDWXYZ','ABCDWXYZ')' = 1'\nSAY PATMATCH('ABC*XYZ','ABCDWXYZ')' = 1'\nSAY PATMATCH('ABC*XYZ','ABCDXYZ')' = 1'\nSAY PATMATCH('ABC*XYZ','ABCXYZ')' = 1'\nSAY PATMATCH('*','ABCXYZ')' = 1'\nSAY PATMATCH('*XYZ','ABCDWXYZ')' = 1'\nSAY PATMATCH('%XYZ','WXYZ')' = 1'\nSAY PATMATCH('%X*','WXYZ')' = 1'\nSAY PATMATCH('%%%%','WXYZ')' = 1'\nSAY PATMATCH('WXYZ*','WXYZ')' = 1'\nSAY PATMATCH('*XY%','WXYZ')' = 1'\nSAY PATMATCH('%B%D%F%H','ABCDEFGH')' = 1'\nSAY PATMATCH('*B*D*F*H','ABCDEFGH')' = 1'\nSAY PATMATCH('A*C*E*G*','ABCDEFGH')' = 1'\nSAY PATMATCH('*EFG*','ABCDEFGH')' = 1'\nTRACE N\nSAY PATMATCH('ABC*XYZ','ABCXYZA')' = 0'\nTRACE N\nSAY PATMATCH('ABC*XYZ','ABCXY')' = 0'\nSAY PATMATCH('*WXY','ABCDWXYZ')' = 0'\nSAY PATMATCH('ABC*XYZ','ABDDWXYZ')' = 0'\nSAY PATMATCH('*DWW*','ABDDWXYZ')' = 0'\nSAY PATMATCH('ABC*XYZ','ABCDWYYZ')' = 0'\nSAY 'All tests completed'\nEXIT\n\n/*RXCOPY PATMATCH **** 67 LINES COPIED ON 05-12-01 AT 08:01************/\n/*-Start of PATMATCH function---------------------------Version-01.01-*/\n/*:PATMATCH function - Performs ISPF-type pattern matching on a pair  */\n/* of strings: 1st string is the pattern, 2nd is the data.            */\n/* Example: rc=PATMATCH('*EFG*','ABCDEFGH')                           */\n/* Returns: 0:    Pattern does not match the data.                    */\n/*          1:    Pattern does match the data.                        */\n/*          text: Error occured, text gives the details.              */\n/* Copyright (C) 1996, 1998 Washington Systems. All rights reserved.  */\n/*--------------------------------------------------------------------*/\nPATMATCH: PROCEDURE EXPOSE gbl.\nTRACE N\nIF ARG() <> 2 THEN RETURN 'PATMATCH ERROR: 2 parms required, caller',\n                          'passed 'ARG()' parms'\nhaystack = ARG(2)                  /* Data to be searched w/ pattern  */\npattern = ARG(1)                   /* Search pattern                  */\nwild = 0                           /* No '*' seen (yet)               */\n  DO WHILE pattern <> ''           /* Process pattern from L to R     */\n\n  a = POS('*',pattern)             /* Look for '*' in pattern         */\n  IF a > 0 THEN                    /* If found, extract any           */\n    DO                             /*  preceeding search string       */\n    PARSE VAR pattern needle '*' +0 newpattern\n    IF needle = '' THEN\n      DO                           /* If no preceeding search string, */\n      wild = 1                     /*  mark next search as 'wild card'*/\n      PARSE VAR newpattern 2 pattern /* remove '*' from pattern       */\n      ITERATE                      /*    and continue testing         */\n      END\n    END\n\n  p = POS('%',pattern)             /* Look for '%' in pattern         */\n  IF p > 0 & (a = 0 | p < a) THEN  /* If found before any '*', extract*/\n    DO                             /*  any preceeding search string   */\n    PARSE VAR pattern needle '%' +0 newpattern\n    IF needle = '' THEN\n      DO                           /* If no preceeding search string, */\n      needle = LEFT(haystack,1)    /* take next text as search string */\n      PARSE VAR newpattern 2 newpattern\n      wild = 0                     /* Mark next search 'not wild card'*/\n      END\n    END\n\n  IF p = 0 & a = 0                 /* No special chars, use remainder */\n  THEN PARSE VAR pattern needle newpattern\n\n  pattern = newpattern             /* Update pattern for next pass    */\n  pos = POS(needle,haystack)       /* Look for this pattern           */\n  IF pos = 0 THEN RETURN 0         /* Not found, outta here           */\n  IF pos > 1 THEN                  /* Found, but not at start-of-text */\n    IF wild <> 1                   /* Wild card char in effect?       */\n    THEN RETURN 0                  /* No wild card, outta here        */\n  wild = 0                         /* Reset wild card character       */\n  len = LENGTH(haystack)-LENGTH(needle)-pos+1\n  haystack = RIGHT(haystack,len)   /* Remove data that we just scanned*/\n  IF haystack = '' THEN\n    DO                             /* No more data to scan...         */\n    IF pattern = ''                /* Out of pattern as well?         */\n    THEN RETURN 1                  /* Yes, that's a match.            */\n    IF pattern = '*'               /* Did pattern end with wild card? */\n    THEN RETURN 1                  /* Yes, that's a match too.        */\n    RETURN 0                       /* Else, sorry, not a match.       */\n    END\n  END                              /* Ran out of pattern to scan      */\nIF wild = 1                        /* Did pattern end with wild card? */\nTHEN RETURN 1                      /* Yes, that's a match.            */\nELSE RETURN 0                      /* Else, sorry, not a match.       */\n/*-End of PATMATCH function-------------------------------------------*/\n\n/*RXCOPY RXERROR **** 129 LINES COPIED ON 05-12-01 AT 08:01************/\n/*START OF RXERROR--------------------------------------Version-01.07-*/\n/*:RXERROR SUBROUTINE: Generic REXX error condition handler. This     */\n/* routine gets control when a condition is raised, and:              */\n/* a. Validates that the condition is ok, and returns quietly, or     */\n/* b. Issues diagnostic messages about the error & where it occured.  */\n/*                                                                    */\n/* To use this routine, code the following near the top of your exec: */\n/* CALL   ON ERROR   NAME RXERROR                                     */\n/* SIGNAL ON SYNTAX  NAME RXERROR                                     */\n/* SIGNAL ON NOVALUE NAME RXERROR                                     */\n/*                                                                    */\n/* In addition, set the variable 'ok' to any return code values       */\n/* that are acceptable for host commands.  For example:               */\n/*                                                                    */\n/* ok=4; ADDRESS TSO 'GETVARL GLOBAL_*'; DROP ok                      */\n/* ok='4 8';\"host cmd\"; DROP ok <-- return codes 4 or 8 are ok        */\n/* ok='all';\"host cmd\"; DROP ok <-- all return codes are acceptable   */\n/*                                                                    */\n/* The first example permits GETVARL to get rc 4 and not fail or      */\n/* issue any error messages.  Note that \"ok=0\" is always implied      */\n/* because the REXX ERROR condition is not raised if rc=0.            */\n/*------------------------------------------------------------------- */\n/*NOTES: This subroutine does not use the PROCEDURE instruction, so   */\n/*       variable names used within it must be _hidden.               */\n/*                                                                    */\n/*       If an error occurs that's not one of the 'OK' values,        */\n/*       execution will fall thru this subroutine and any statements  */\n/*       following it will be executed.  This is a good place to put  */\n/*       cleanup logic, or a signal to your \"cleanup-and-exit\" label. */\n/*                                                                    */\n/*       Variables _RXERRORMSG1 and _RXERRORMSG2 are created when     */\n/*       RXERROR falls thru, and may be used to send error msgs to    */\n/*       other destinations, such as a GUI MSGBOX or ADDRESS AXC WTXC.*/\n/*                                                                    */\n/*       As a side effect, RXERROR sets ISPF \"CONTROL ERRORS RETURN\". */\n/*       If your routine doesn't run this way, you'll need to restore */\n/*       your ISPF CONTROL ERRORS setting.                            */\n/* Copyright (C) 1996,1999 Washington Systems. All rights reserved.   */\n/*--------------------------------------------------------------------*/\n\nRXERROR: TRACE N                  /* Turn off tracing for this func.  */\n_sigl = sigl\nRXERROR1: TRACE N                 /* Turn off tracing for this func.  */\nCALL   OFF ERROR\nSIGNAL OFF SYNTAX\nIF SYMBOL('rc') = 'VAR' THEN _rc = rc\nELSE _rc = 'n/a'\nPARSE SOURCE _EX_ENV . _EX_NAME . . . . _EX_ADDRSPC .\nIF POS(CONDITION('C'),'ERROR FAILURE') > 0 THEN  /* Error or Failure? */\n                                       /* Yes. Were we CALLed?        */\n  IF CONDITION('I') = 'CALL' | _EX_ENV = 'OPS/REXX' THEN\n    IF SYMBOL('OK') = 'VAR' THEN       /* Yes.  Is OK a variable?     */\n      IF WORDPOS(_rc,ok)>0 | TRANSLATE(ok)='ALL' THEN /* Is error ok? */\n        DO                                            /* Yes, return  */\n        CALL   ON ERROR   NAME RXERROR /*  Restore the                */\n        SIGNAL ON SYNTAX  NAME RXERROR /*   Error handler             */\n        DROP ZERRLM                    /* Toss any ISPF error msg     */\n        rc = _rc                       /* Restore orig RC for caller  */\n        RETURN                         /* Return to point of error    */\n        END\nIF SYMBOL('_errtext') = 'LIT'\nTHEN _errtext = '';                /* Initialize error text           */\nIF CONDITION('C') = 'SYNTAX' THEN  /* If a REXX syntax error,         */\n  IF _rc >= 0 & _rc < 100          /*  and rc is within valid range,  */\n  THEN _errtext = ' ('ERRORTEXT(_rc)')';/* then get REXX error text.  */\n  ELSE NOP;\nELSE\n  IF CONDITION('C') = 'NOVALUE' THEN /* See if undefined variable     */\n    DO;\n    _errtext = ' (No value for variable 'CONDITION('D')')';\n    _rc = 'n/a';                   /* RC not set for NOVALUE          */\n    END\n  ELSE\n    IF POS(CONDITION('C'),'ERROR FAILURE') > 0 THEN /*Hostcmd problem?*/\n      DO   /* Extract host cmd name... */\n      _cmd = STRIP(STRIP(WORD(CONDITION('D'),1),'B','\"'),'B',\"'\")\n      _errtext = ' (Host command '_cmd')'\n      _addr = ADDRESS()            /* Find environment of failing cmd */\n      IF _sigl <= SOURCELINE() THEN/* Is source code avail?           */\n        IF TRANSLATE(WORD(SOURCELINE(_sigl),1)) = 'ADDRESS'\n        THEN _addr = TRANSLATE(WORD(SOURCELINE(_sigl),2))\n      _addr = STRIP(TRANSLATE(_addr,,'!@#$%&*()_-+=;:,./?\"'\"'\",' '))\n      IF _addr = 'PPQ' & SYMBOL('PPQ.ERROR') = 'VAR'\n      THEN _errtext = ' (Host command PPQ, 'ppq.error')'\n      IF _addr = 'VOX' & SYMBOL('VOX.ERROR') = 'VAR'\n      THEN _errtext = ' (Host command VOX, 'vox.error')'\n      IF _addr = 'ASODDE' | SYMBOL('ASODDE.ERROR') = 'VAR'\n      THEN _errtext = ' (Host command ASODDE, 'asodde.error')'\n      IF SYMBOL('SQLCODE') = 'VAR'\n      THEN _errtext = ' ( SQLCODE=' sqlcode')'\n      END\n    ELSE IF CONDITION('C') <> '' THEN\n      _errtext = ' (Condition='CONDITION('C')', Description=',\n        CONDITION('D')')'\n\n_rxerrormsg1 = \"RXERROR Error RC \"_rc\"\"_errtext\" at line \"_sigl,\n               \"in EXEC\" _ex_name\nIF _sigl <= SOURCELINE()           /* Is source code avail?           */\nTHEN _rxerrormsg2 = \"RXERROR Line \"_sigl\": \"STRIP(SOURCELINE(_sigl))\nELSE _rxerrormsg2 = \"\"\n\nIF _ex_addrspc = 'ISPF' THEN       /* Running under ISPF?             */\n  DO                               /* Yes, issue short & long msgs... */\n  ADDRESS ISPEXEC \"CONTROL ERRORS RETURN\" /* Capture all ISPF RCs     */\n  zedsmsg = ''                     /* Format ISPF short message       */\n  zedlmsg = \"Error RC \"_rc\"\"_errtext\" at line \"_sigl\" in EXEC\" _ex_name\n  IF _sigl <= SOURCELINE()         /* Is source code avail?           */\n  THEN zedlmsg = LEFT(zedlmsg': ',78)STRIP(SOURCELINE(_sigl))\n  IF SYMBOL('ZERRLM') = 'VAR'\n  THEN zedlmsg = LEFT(zedlmsg,156) 'ISPF Error: 'STRIP(ZERRLM)\n  ADDRESS ISPEXEC \"SETMSG MSG(ISRZ001)\"\n  IF rc = 12 THEN                  /* ISPMLIB MESSAGE found?          */\n    DO                             /* No, use SAY instead.            */\n    SAY 'RXERROR ISPMLIB Message ISRZ001 Not Found'\n    SIGNAL _SAY_ERRMSG;\n    END\n  SIGNAL _SAY_SQLMSG;\n  END\n\n_SAY_ERRMSG:\nSAY _rxerrormsg1; IF _rxerrormsg2 <> '' THEN SAY _rxerrormsg2; SAY ''\n_SAY_SQLMSG:\nIF SYMBOL('SQLCODE') = 'VAR' & QUEUED() > 0 THEN\n  IF WORDPOS(sqlcode,'0 100') = 0 THEN\n    DO _i = 1 BY 1 WHILE QUEUED() > 0\n    PULL _stack\n    SAY 'SQL STACK:'RIGHT(_i,2)':'_stack\n    END\n/*END OF RXERROR------------------------------------------------------*/\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PROFDUMP": {"ttr": 3845, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x04\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00/\\x00/\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:04", "lines": 47, "newlines": 47, "modlines": 0, "user": "KANNAN"}, "text": "/* PROFDUMP Rexx - Dump the contents of current profile to a file    */\n/* Version 1.1  - allow other profiles including ISPSPROF            */\n/* Syntax: TSO PROFDUMP dsn prof                                     */\n/*           dsn is required - it will be deleted and reallocated.   */\n/*           prof is the applid to be searched (ISR, ISP, ISPS, etc) */\n/*           prof is optional and will default to the current applid.*/\nParse Arg dsn appl .\ndumpdsn = dsn\nIf dsn='' Then\n  Do\n    Say 'NO DUMP DATA SET GIVEN '\n    Exit\n  End\n'ALLOC F(FOOBAR) DA('dsn') MOD DEL UNIT(SYSDA) REU'\n'ALLOC F(FOOBAR) DA('dsn') NEW CAT TR SPA(20,20) RELEASE REUSE',\n  'DSORG(PS) RECFM(V B) LRECL(500) BLKSIZE(0) UNIT(SYSDA)'\nDo queued()\n  Pull\nEnd                                    /* JUST IN CASE               */\nAddress ispexec\n'CONTROL ERRORS RETURN'\n'VGET ZAPPLID'\nparse upper value appl zapplid with appl .\ntablenam=appl'PROF'\n'TBTOP ' tablenam\n'TBSKIP' tablenam 'NUMBER(1) SAVENAME(SAVES)'\nsay skip rc\nParse Var saves'('saves')'\nQueue tablenam': TOTAL VARIABLES:' words(saves)\nQueue copies('-',length(tablenam': TOTAL VARIABLES:' words(saves)))\ntlen=0\nDo While saves \\= ''\n  Parse Var saves word saves\n  'VGET 'word' PROFILE'\n  Interpret 'LEN = LENGTH('word')'\n  tlen=tlen+len\n  Interpret 'VAL = 'word\n  Queue left(word,9)right(len,5)' 'val\nEnd\nQueue 'Total variable lengths: 'tlen\nAddress tso\n'EXECIO 'queued()' DISKW FOOBAR (FINIS'\n'FREE F(FOOBAR)'\nDo queued()\n  Pull\nEnd /* JUST IN CASE */\n\"ISPEXEC BROWSE DATASET(\"dumpdsn\")\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PROFILE": {"ttr": 3847, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x04\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00\\x07\\x00\\x07\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:04", "lines": 7, "newlines": 7, "modlines": 0, "user": "KANNAN"}, "text": "/* REXX */\n\"ALLOC FI(SYSUEXEC) DA('\"USERID()\".HANNA.EXEC') SHR\"\n\"ALTLIB ACTIVATE USER(EXEC)\"\n\"ALTLIB DISPLAY\"\nZEDLMSG = 'SYSUEXEC ONBOARD'\nADDRESS ISPEXEC 'SETMSG MSG (ISRZ001)'\nEXIT 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PROGBAR": {"ttr": 3849, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x04\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00\\x16\\x00\\x16\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:04", "lines": 22, "newlines": 22, "modlines": 0, "user": "KANNAN"}, "text": "/* Rexx */\nAddress Ispexec\nloopmax = 9999\nmax_disps = 10\nprogress_step = Max(loopmax%max_disps,1)\nwaitmsg = \"Please wait...\"\nDo counter = 1 to loopmax\n   If counter // progress_step = 0 Then do\n      thisperc =  counter / loopmax\n      indll    =  Trunc(50 * thisperc)\n      ProcInd  = '?'||Copies(' ',indll)||'#'\n      If length(ProcInd) > 8 then do\n          strtpos = (Length(ProcInd) % 2) - 2\n          txt     = Strip(format(thisperc*100,3,0),'L','0') || ' %'\n          ProcInd = Overlay(txt,ProcInd,strtpos)\n      End\n/*     \"Control Display Lock\" */\n       \"AddPop\"\n       \"Display Panel(PROGPNL)\"\n       \"RemPop\"\n   End\nEnd\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PROGPNL": {"ttr": 3851, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x04\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00\\x14\\x00\\x14\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:04", "lines": 20, "newlines": 20, "modlines": 0, "user": "KANNAN"}, "text": ")ATTR\n % COLOR(TURQ)    INTENS(HIGH) TYPE(TEXT)\n + COLOR(YELLOW)  INTENS(HIGH) TYPE(TEXT)\n @ COLOR(PINK)    INTENS(HIGH) TYPE(OUTPUT) CAPS(OFF)\n ` COLOR(RED)     INTENS(HIGH) TYPE(TEXT)   HILITE(BLINK)\n $ COLOR(GREEN)   INTENS(HIGH) TYPE(TEXT)   CAPS(OFF)\n # COLOR(PINK)    INTENS(HIGH) TYPE(DATAOUT)\n ? COLOR(&BARDYE) INTENS(HIGH) TYPE(DATAOUT) HILITE(REVERSE)\n * AREA(DYNAMIC) SCROLL(OFF)  EXTEND(OFF)\n)BODY  WINDOW(55,5)\n%                                                +\n+&WaitMsg                                        +\n%                                                +\n *PROCIND                                        *\n%                                                +\n)INIT\n &ZWINTTL = ' Progress Meter '\n)PROC\n &ZWINTTL = ''\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PROGRESS": {"ttr": 3853, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x04\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00\\x08\\x00\\x08\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:04", "lines": 8, "newlines": 8, "modlines": 0, "user": "KANNAN"}, "text": "/* Rexx */\nbarstp = Max(999%10,1)\ndo i = 1 to 999\n   If i // barstp = 0 Then do\n   call showbar 999 i\n   end\nend\nexit\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PT": {"ttr": 3855, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x04\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00\\x15\\x00\\x15\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:04", "lines": 21, "newlines": 21, "modlines": 0, "user": "KANNAN"}, "text": "/* Rexx PT                                                            */\n/* .................................................................. */\n/* Author  : Kannan AK                                                */\n/* PT      : Do 7.2  (Panel Test)                                     */\n/* Notice  : None                                                     */\n/* Version : Alpha                                                    */\n/* .................................................................. */\narg panel w\naddress ISREDIT\n'MACRO PROCESS (PANEL W)'\n\"isredit save\"\n\"isredit (panel) = member\"\nif panel = '' then exit\naddress ispexec\nif w = 'W' then \"addpop\"\ndo until disprc >= 8\n                \"display panel(\"panel\")\"\n                disprc = rc\nend\nif w = 'W' then \"rempop\"\nexit 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "QB": {"ttr": 3857, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x04\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00\\x1d\\x00\\x1d\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:04", "lines": 29, "newlines": 29, "modlines": 0, "user": "KANNAN"}, "text": "/* Rexx qb - QuickBrowse */\nAddress ISPEXEC\n'CONTROL ERRORS RETURN'\nAddress ISREDIT\n'MACRO PROCESS'\n'(CL,CC) = CURSOR'\nIf cc = 0 Then Exit\n\ndelim = \"~'!*%&-_=+\\{};:`<,>/?\" '\"'\n'ISREDIT (LINE) = LINE .ZCSR'\nend = length(line)\nstart = end - verify(reverse(line)\" \",delim,\"M\",end-cc+1)+2\nend = verify(line\"\",delim,\"M\",cc)-1\n\nIf start > end Then Exit\nword = substr(line,start,end-start+1)\n\nAddress ISPEXEC\n'CONTROL DISPLAY SAVE'\n\"BROWSE DATASET('\"word\"')\"\nIf RC > 4 Then Do\n   'SETMSG MSG(ISRZ002)'\n   Signal Qui\nEnd\n'CONTROL DISPLAY RESTORE'\n\nQui:\n\"ISREDIT CURSOR = \"cl cc\nExit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "QBASE": {"ttr": 3859, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x04\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00\\x12\\x00\\x12\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:04", "lines": 18, "newlines": 18, "modlines": 0, "user": "KANNAN"}, "text": "/* Rexx QbaseLib Service Invoker */\nArg dd\nIf dd = '' Then Exit\n\"ISREDIT MACRO (DD) NOPROCESS\"\n Address ISPEXEC \"QBASELIB\" dd \"ID(LIST)\"\n If RC = 0 Then Do\n     zedlmsg = 'DD' dd 'contains' list\n     list = translate(list,' ',',')\n     Do i=1 To words(list)\n        x = ListDSI(word(list,i))\n        Address ISPEXEC \"DSINFO DATASET(\"word(list,i)\")\"\n        Say 'DSN' i 'is' sysdsname 'created' zdscdate\n     End\n    End\n Else\n zedlmsg = 'DD' dd 'does not exist'\n Address ISPEXEC \"SETMSG MSG(ISRZ000)\"\nExit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "QC": {"ttr": 3861, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x04\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00\\xdb\\x00\\xdb\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:04", "lines": 219, "newlines": 219, "modlines": 0, "user": "KANNAN"}, "text": "/* REXX QC */\n/* syntax : tso qc dsname */\n/*                                                                   */\narg str\naddress tso \"MAKEBUF\"\naddress ispexec\ncall init\nf = OUTTRAP('OUT.','*','NOCONCAT')\nx = listdsi(\"\"str\"\" directory norecall)\nf = OUTTRAP(OFF)\nif sysreason = 8 then do\n   ZEDSMSG = 'Warning *Not on DASD*'\n   \"ISPEXEC SETMSG MSG(ISRZ000)\"\n   signal bypass\nend\n\nif sysreason = 9 then do\n   ZEDSMSG = 'Warning *Migrated*'\n   \"ISPEXEC SETMSG MSG(ISRZ000)\"\n   signal bypass\nend\nif sysreason = 5 then do\n   ZEDSMSG = 'Warning *GDGBASE*'\n   \"ISPEXEC SETMSG MSG(ISRZ000)\"\n   signal bypass\nend\nif x > 0 then do\n   ZEDSMSG = '*Obtain Failed* ' || sysreason\n   \"ISPEXEC SETMSG MSG(ISRZ000)\"\n   exit 0\nend\nbypass :\nTTAB  = \"'\"\nfstr = TRANSLATE(str,\" \",TTAB)\nfstr = strip(fstr)\ndot = '.'\nparse value fstr with hlq (dot) rlq\nudsname = userid() || dot || rlq\ncall dataset\nif length(f_name) > 7 then udsname = f_name\nudsname = strip(udsname)\nupper udsname\nselect\n  when sysunits = 'TRACK'    then sysunits = 'TRK'\n  when sysunits = 'CYLINDER' then sysunits = 'CYL'\n  when sysunits = 'BLOCK'    then sysunits = sysblksize\n  when sysunits = ''         then do\n                                     sysunits = 'CYL'\n                                     sysprimary = 10\n                                     sysseconds = 10\n                                     sysseconds = 10\n                                     dcb='no'\n                                  end\n  otherwise nop\nend\n\ncall print\ncall build_jcl\ncall edit_jcl\nqui :\naddress tso\n\"DROPBUF\"\nIF LENGTH(COPYJCL) > 3 THEN \"FREE DD(\"COPYJCL\") DELETE\"\nexit\n\nbuild_jcl:\nD = DATE(J);R1 = RANDOM(100,999);R2 = RANDOM(100,999);\nT = TIME();PARSE VALUE T WITH HH ':' MM ':' SS;TT=HH||MM||SS\nFRAG = '.T'||R1||TRUNC(R1*R2/RANDOM()/10)||'.Z'||TT\ntempf = USERID()||\".COPYJCL\" || FRAG\njcl_dsn = \"'\"||tempf||\"'\"\nCOPYJCL = 'CJ'||R2||R1\n\naddress tso\n\"ALLOC DS(\"jcl_dsn\") DD(\"COPYJCL\") DSORG(PS) LRECL(80) RECFM(F) NEW KEEP\"\n\ncall wj(\"//\"userid()\"C JOB (000000),'QUICKCOPY',                      \")\ncall wj(\"//         CLASS=U,TIME=1440,MSGCLASS=X,NOTIFY=&SYSUID       \")\ncall wj(\"//*---------------------------------------------------------*\")\nif sysdsorg \\= '' then\ncall wj(\"// SET UDSORG=\"sysdsorg\"                                             \")\nif sysrecfm \\= '' then\ncall wj(\"// SET URECFM=\"sysrecfm\"                                             \")\nif syslrecl \\= '' then\ncall wj(\"// SET ULRECL=\"syslrecl\"                                             \")\nif sysblksize \\= '' then\ncall wj(\"// SET UBLKSIZE=\"sysblksize\"                                         \")\ncall wj(\"// SET UTYPE=\"sysunits\"                                              \")\ncall wj(\"// SET UPRI=\"sysprimary\"                                             \")\ncall wj(\"// SET USEC=\"sysseconds\"                                             \")\nif mgmtclas = '' then mgmtclas = 'SAMPLECL'\ncall wj(\"// SET UMGMT=\"mgmtclas\"                                              \")\nif sysadirblk \\= '' then\ncall wj(\"// SET UDIRBLK=\"sysadirblk\"                                          \")\ncall wj(\"//*---------------------------------------------------------*\")\nif sysdsorg = 'PO' then\ncall wj(\"//QCOPY    EXEC PGM=IEBCOPY                                  \")\nif sysdsorg \\= 'PO' then\ncall wj(\"//QCOPY    EXEC PGM=IDCAMS                                   \")\ncall wj(\"//SYSPRINT DD SYSOUT=*                                       \")\ncall wj(\"//SYSUT1   DD DISP=SHR,DSN=\"fstr\"                            \")\ncall wj(\"//SYSUT2   DD DSN=\"udsname\",                                 \")\ncall wj(\"//            DISP=(NEW,CATLG,DELETE),                       \")\ncall wj(\"//            MGMTCLAS=&UMGMT,                               \")\ncall wj(\"//*           DATACLAS=\"dataclas\"                            \")\ncall wj(\"//*           STORCLAS=\"storclas\"                            \")\nif sysdsorg = 'PO' then\ncall wj(\"//            SPACE=(&UTYPE,(&UPRI,&USEC,&UDIRBLK),RLSE),    \")\nif sysdsorg \\= 'PO' then do\ncall wj(\"//            SPACE=(&UTYPE,(&UPRI,&USEC),RLSE),             \")\n   if dcb ='no' then signal refdd\ncall wj(\"//            RECFM=&URECFM,LRECL=&ULRECL,BLKSIZE=&UBLKSIZE, \")\nend\nrefdd :\ncall wj(\"//            REFDD=*.SYSUT1                                 \")\nif sysdsorg = 'PO' then do\ncall wj(\"//SYSIN    DD DUMMY                                          \")\nend\nif sysdsorg \\= 'PO' then do\ncall wj(\"//SYSIN    DD *                                              \")\ncall wj(\"    REPRO INFILE(SYSUT1) OUTFILE(SYSUT2)                     \")\nend\ncall wj(\"/*                                                           \")\naddress tso \"EXECIO\" wjcount \"DISKW\" COPYJCL \"(FINIS\"\nif rc > 2 then do\n    ZEDSMSG = \"//Error writing JCL \"||RC\n    \"ISPEXEC SETMSG MSG(ISRZ000)\"\n    call qui\nend\nreturn\n\nwj :\nparse arg stream\nqueue stream\nwjcount = wjcount + 1\nreturn\n\nedit_jcl :\nZEDSMSG = '*Verify & submit*'\n\"ISPEXEC SETMSG MSG(ISRZ000)\"\n\"ISPEXEC Edit DATASET(\"jcl_dsn\")\"\nIF RC > 4 THEN DO\n    ZEDSMSG = \"Unexpected Error \"||RC\n    \"ISPEXEC SETMSG MSG(ISRZ000)\"\n    call qui\nEND\nreturn\n\nprint :\nreturn\naddress tso clear\nsay sysdsname\nsay sysvolume\nsay sysunit\nsay sysdsorg\nsay sysrecfm\nsay syslrecl\nsay sysblksize\nsay syskeylen\nsay sysprimary\nsay sysseconds\nsay sysunits\nsay sysadirblk\nsay sysvolume\nreturn\n\ninit  :\n    sysdsname = ''\n    sysvolume = ''\n    sysunit = ''\n    sysdsorg = ''\n    sysrecfm = ''\n    syslrecl = ''\n    sysblksize  = ''\n    syskeylen = ''\n    sysprimary = ''\n    sysseconds = ''\n    sysunits = ''\n    sysadirblk = ''\n    wjcount  = 0\n    dcb ='yes'\nreturn\n\ndataset :\ngetline = udsname\ntitle = 'qc'\ncall sms str getline title\nif result = 'IAM' then do\n     ZWINTTL='* Message *'\n    \"vput (ZWINTTL)\"\n    \"ADDPOP\"\n     ZEDLMSG = \"QuickCopy does not support IAM\"\n    \"ISPEXEC SETMSG MSG(ISRZ000)\"\n    \"REMPOP\"\n     exit 0\nend\n\nparse value result with getline dataclas storclas mgmtclas\nmyline = getline\n\nCheckDsn = \"'\"||TRANSLATE(STRIP(myline))||\"'\"\nLTAB  = \"\"\"'()\";\nf_name = strip(translate(myline,\" \",LTAB))\nCheckDsn = \"'\"||f_name||\"'\"\navail = SYSDSN(CheckDsn)\nif avail \\= 'OK' then do\n   upper f_name\n   return\nend\nelse do\n     ZWINTTL='* ERROR *'\n    \"vput (ZWINTTL)\"\n    \"ADDPOP\"\n     ZEDLMSG = \"Dataset already exists! Retry\"\n    \"ISPEXEC SETMSG MSG(ISRZ000)\"\n    \"REMPOP\"\n     ZCMD = ''\n     signal dataset\nend\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "QCC": {"ttr": 4100, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x04\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00\\x17\\x00\\x17\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:04", "lines": 23, "newlines": 23, "modlines": 0, "user": "KANNAN"}, "text": "/* Rexx qcc */\nAddress ISPEXEC\n'CONTROL ERRORS RETURN'\nAddress ISREDIT\n'MACRO PROCESS'\n'(CL,CC) = CURSOR'\nIf cc = 0 Then Exit\n\ndelim = \"~'!%&-_=+\\{};:`<,>/?\" '\"'\n'ISREDIT (LINE) = LINE .ZCSR'\nend = length(line)\nstart = end - verify(reverse(line)\" \",delim,\"M\",end-cc+1)+2\nend = verify(line\"\",delim,\"M\",cc)-1\n\nIf start > End Then Exit\nword = substr(line,start,End-start+1)\n\nAddress TSO\n\"QC '\"word\"'\"\n\nqui :\n\"ISREDIT CURSOR = \"cl cc\nExit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "QD": {"ttr": 4102, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x04\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00\"\\x00\"\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:04", "lines": 34, "newlines": 34, "modlines": 0, "user": "KANNAN"}, "text": "/* Rexx qd - QuickDelete */\nAddress ISPEXEC\n'CONTROL ERRORS RETURN'\nAddress ISREDIT\n'MACRO PROCESS'\n'(CL,CC) = CURSOR'\nIf cc = 0 Then Exit\n\ndelim = \"~'!%*&-_=+\\{};:`<,>/?\" '\"'\n'ISREDIT (LINE) = LINE .ZCSR'\nend = length(line)\nstart = end - verify(reverse(line)\" \",delim,\"M\",end-cc+1)+2\nend = verify(line\"\",delim,\"M\",cc)-1\n\nIf start > end Then Exit\nword = substr(line,start,end-start+1)\ncx = right(cl,2);cx = cx + 3\ncy = right(cc,2);cy = cy + 3\nAddress ISPEXEC \"addpop Row(\"cx\") Column(\"cy\")\"\nAddress ISPEXEC \"display panel(YESNOPNL)\"\nUpper cname\nIf cname = 'YES' Then do\n   Address tso \"DEL '\"word\"'\"\n   Address ISPEXEC \"rempop all\"\n   NOP\nEnd\nIf cname = 'NO' Then do\n   Address ISPEXEC 'Rempop All'\n   NOP\nEnd\n\nIf rc > 0 Then 'ISPEXEC SETMSG MSG('zerrmsg')'\n\"ISREDIT CURSOR = \"cl cc\nExit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "QE": {"ttr": 4104, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x04\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00\\x1d\\x00\\x1d\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:04", "lines": 29, "newlines": 29, "modlines": 0, "user": "KANNAN"}, "text": "/* Rexx qe - QuickEdit */\nAddress ISPEXEC\n'CONTROL ERRORS RETURN'\nAddress ISREDIT\n'MACRO PROCESS'\n'(CL,CC) = CURSOR'\nif cc = 0 Then Exit\n\ndelim = \"~'!%*&-_=+\\{};:`<,>/?\" '\"'\n'ISREDIT (LINE) = LINE .ZCSR'\nend = length(line)\nstart = end - verify(reverse(line)\" \",delim,\"M\",end-cc+1)+2\nend = verify(line\"\",delim,\"M\",cc)-1\n\nIf start > end Then Exit\nword = substr(line,start,end-start+1)\n\nAddress ISPEXEC\n'CONTROL DISPLAY SAVE'\n\"EDIT DATASET('\"word\"')\"\nIf RC > 4 Then Do\n   'SETMSG MSG(ISRZ002)'\n   Signal Qui\nEnd\n'CONTROL DISPLAY RESTORE'\n\nQui:\n'ISREDIT CURSOR = 'cl cc\nExit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "QH": {"ttr": 4106, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x04\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00\\x15\\x00\\x15\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:04", "lines": 21, "newlines": 21, "modlines": 0, "user": "KANNAN"}, "text": "/* Rexx qh - QuickHrecall */\nAddress ISPEXEC\n'CONTROL ERRORS RETURN'\nAddress ISREDIT\n'MACRO PROCESS'\n'(CL,CC) = CURSOR'\nIf cc = 0 Then Exit\n\ndelim = \"~'!*%&-_=+\\{};:`<,>/?\" '\"'\n'ISREDIT (LINE) = LINE .ZCSR'\nend = length(line)\nstart = end - verify(reverse(line)\" \",delim,\"M\",end-cc+1)+2\nend = verify(line\"\",delim,\"M\",cc)-1\n\nIf start > end Then Exit\nword = substr(line,start,end-start+1)\n\nAddress TSO\n\"HRECALL '\"word\"'\"\n'ISREDIT CURSOR = 'cl cc\nExit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "QI": {"ttr": 4108, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x04\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00\\xbb\\x00\\xbb\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:04", "lines": 187, "newlines": 187, "modlines": 0, "user": "KANNAN"}, "text": "/* Rexx qi */\narg word\nif word = '' | word = 'QWORD' then address ispexec 'VGET (QWORD)'\nif QWORD = '' then exit\nelse word = QWORD\nword = space(translate(word,\" \",\"'\"))\nif word = '' then exit\nparse source system . cmdname .\naddress ispexec\n'control errors return'\n a1 = 'FsssssssssssssssssssssssLsssssssssssssssO'\n a2 = 'FsssssssssssssssssssssssLsssssssssssssssO'\n a3 = 'FsssssssssssssssssssssssLsssssssssssssssO'\n a4 = 'DsssssssssssssssssssssssGsssssssssssssssM'\n s1 = '##########################################'\n h0 = copies('s',23)\n h1 = 'E'h0'PssssssssssssPsssssssssssssssssssssssPsssssssssssssssN'\n h2 = 'D'h0'GssssssssssssGsssssssssssssssssssssssGsssssssssssssssM'\n s2 = copies('#',80)\naddress isredit\n'MACRO PROCESS'\nif rc = 20 then signal commandline\n'(CL,CC) = CURSOR'\nif cc = 0 then exit\n\ndelim = \"~'!*%&-_=+\\{};:`<,>/?\" '\"'\n'ISREDIT (LINE) = LINE .ZCSR'\nend = length(line)\nstart = end - verify(reverse(line)\" \",delim,\"M\",end-cc+1)+2\nend = verify(line\"\",delim,\"M\",cc)-1\n\nif start > end then exit\nword = substr(line,start,end-start+1)\n\ncommandline :\naddress tso\nx = listdsi(\"'\"word\"'\" directory norecall smsinfo)\nif sysreason = 5 then do\n   address tso\n   clear\n   \"LISTC ENTRIES('\"word\"') GDG ALL\"\n   exit\nend\nif sysmsglvl2 \\= ' ' then do\n  zedlmsg = sysmsglvl2\n  address ispexec \"setmsg msg(isrz001)\"\n  \"ISREDIT CURSOR = \"cl cc\n  exit\nend\n          dsname     =   sysdsname\n          volume     =   sysvolume\n          unit       =   sysunit\n          dsorg      =   sysdsorg\n          recfm      =   sysrecfm\n          lrecl      =   syslrecl\n          blksize    =   sysblksize\n          units      =   sysunits\n          alloc      =   sysalloc\n          used       =   sysused\n          primary    =   sysprimary\n          seconds    =   sysseconds\n          extents    =   sysextents\n          call j2s strip(syscreate)\n          create     =   result\n          exdate     =   sysexdate\n          dssms      =   sysdssms\n          dataclas   =   sysdataclass\n          storclas   =   sysstorclass\n          mgmtclas   =   sysmgmtclass\n          password   =   syspassword\n          racfa      =   sysracfa\n          updated    =   sysupdated\n          members    =   sysmembers\n          adirblk    =   sysadirblk\n          udirblk    =   sysudirblk\n          trkscyl    =   systrkscyl\n          blkstrk    =   sysblkstrk\n\n          if dataclas = '' then dataclas = 'NONE'\n          if storclas = '' then storclas = 'NONE'\n          if mgmtclas = '' then mgmtclas = 'NONE'\n\nCall DisplayPanel\nqui :\n\"ISREDIT CURSOR = \"cl cc\nexit\n\nDisplayPanel :\nAddress 'ISPEXEC'\nexec_line=1\nif system = 'TSO' then\n  Address tso 'ALLOC NEW CAT F($TMPLIB$) DSO(PO) DIR(1) SP(3,3) TRACK\n               DA($WWWSAMP.TEMP.ISPFLIB) REUSE\n               RECFM(F B) BLKSIZE(0) LRECL(80) UNIT(SYSALLDA)'\nCall MakeMember\nif system = 'TSO' then\n  Address tso 'ALLOC F($TMPLIB$) OLD DA($WWWSAMP.TEMP.ISPFLIB) REUSE'\nIf system = 'TSO' Then\n  Do\n    'VGET ZENVIR'\n    If substr(zenvir,6,1)>='4' Then stack='STACK' /* Use STACK in V4 */\n    Else stack = ''\n    'LIBDEF ISPPLIB LIBRARY ID($TMPLIB$)' stack\n    'LIBDEF ISPMLIB LIBRARY ID($TMPLIB$)' stack\n  End\nElse\n  Do\n    'LIBDEF ISPPLIB FILE ID(ISRNULL $TMPLIB$ A)'\n    'LIBDEF ISPMLIB FILE ID(ISRNULL $TMPLIB$ A)'\n  End\nDo Until rc > 0\n  'DISPLAY PANEL(QIPNL)'\nEnd\n\n'LIBDEF ISPPLIB '\n'LIBDEF ISPMLIB '\nIf system = 'TSO' Then Address tso 'FREE F($TMPLIB$) DELETE'\nElse                   Address '' 'ERASE * $TMPLIB$ A '\n\nDo queued();Pull;End\nReturn\n\nMakeMember :\nDo queued();Pull;End\nDo Until substr(line,1,7)='/*PANEL'\n  line = sourceline(exec_line)\n  exec_line=exec_line+1\nEnd\nParse Var line . panelname .\nDo until substr(line,1,2)='*/'\n  line = sourceline(exec_line)\n  if substr(line,1,2)\u00ac='*/' then\n    Queue line\n  exec_line=exec_line+1\nEnd\nif system = 'TSO' then\n  do\n    pands='$WWWSAMP.TEMP.ISPFLIB('panelname')'\n    Address tso 'ALLOC OLD F($TMPLIB$) DSO(PO) DIR(1) SP(3,3) TRACK\n                da('pands') RECFM(F B) BLKSIZE(0) LRECL(80) REUSE\n                UNIT(SYSALLDA)'\n    Address 'TSO' 'EXECIO 'queued()' DISKW $TMPLIB$ ( FINIS'\n  end\nelse\n do\n  Address '' 'ERASE 'panelname' $TMPLIB$ A '\n Address '' 'EXECIO 'queued()' DISKW 'panelname' $TMPLIB$ A 1 F ( FINIS'\n end\nDo queued();Pull;End\nReturn\n\n/*PANEL QIPNL\n)ATTR\n! TYPE(CH) GE(ON)\n% TYPE(TEXT)   INTENS(HIGH) SKIP(ON) COLOR(TURQ)\n@ TYPE(OUTPUT) INTENS(LOW)  JUST(LEFT)  PAD(' ') CAPS(OFF) COLOR(WHITE)\n$ TYPE(OUTPUT) INTENS(HIGH) SKIP(ON) COLOR(YELLOW)\n* AREA(DYNAMIC) SCROLL(OFF) EXTEND(OFF)\n# TYPE(CHAR)   COLOR(TURQ) GE(ON)\n04 TYPE(ABSL) GE(ON)\n)BODY\n%COMMAND ===>_ZCMD\n\n%Dataset Name           $dsname                                                +\n *h1,s2                                                                        *\n!|% Volume serial       !|@volume    !|% Data class          !|@dataclas     !|\n!|% Device type         !|@unit      !|% Storage class       !|@storclas     !|\n!|% Organization        !|@dsorg     !|% Management class    !|@mgmtclas     !|\n!|% Record format       !|@recfm     !*a1,s1                                  *\n!|% Record length       !|@lrecl     !|% Password protection !|@password     !|\n!|% Block size          !|@blksize   !|% RACF attribute      !|@racfa        !|\n!|% Allocation units    !|@units     !|% Change indicator    !|@updated      !|\n!|% Space allocated     !|@alloc     !*a2,s1                                  *\n!|% Space used          !|@used      !|% Members in directory!|@members      !|\n!|% Primary allocation  !|@primary   !|% Allocated dir blocks!|@adirblk      !|\n!|% Secondary allocation!|@seconds   !|% Used dir blocks     !|@udirblk      !|\n!|% Extents used        !|@extents   !*a3,s1                                  *\n!|% Creation date       !|@create    !|% Tracks per cylinder !|@trkscyl      !|\n!|% Expiration date     !|@exdate    !|% Blocks per track    !|@blkstrk      !|\n!|% Type of dataset     !|@dssms     !|                      !|              !|\n *h2,s2                                                                        *\n\n)INIT\n&ZWINTTL = ''\n)PROC\n)END\n*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "QIPNL": {"ttr": 4112, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x04\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00\"\\x00\"\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:04", "lines": 34, "newlines": 34, "modlines": 0, "user": "KANNAN"}, "text": ")ATTR\n! TYPE(CH) GE(ON)\n% TYPE(TEXT)   INTENS(HIGH) SKIP(ON) COLOR(TURQ)\n@ TYPE(OUTPUT) INTENS(LOW)  JUST(LEFT)  PAD(' ') CAPS(OFF) COLOR(WHITE)\n$ TYPE(OUTPUT) INTENS(HIGH) SKIP(ON) COLOR(YELLOW)\n* AREA(DYNAMIC) SCROLL(OFF) EXTEND(OFF)\n# TYPE(CHAR)   COLOR(TURQ) GE(ON)\n04 TYPE(ABSL) GE(ON)\n)BODY\n%COMMAND ===>_ZCMD\n\n%Dataset Name           $dsname                                                +\n *h1,s2                                                                        *\n!|% Volume serial       !|@volume    !|% Data class          !|@dataclas     !|\n!|% Device type         !|@unit      !|% Storage class       !|@storclas     !|\n!|% Organization        !|@dsorg     !|% Management class    !|@mgmtclas     !|\n!|% Record format       !|@recfm     !*a1,s1                                  *\n!|% Record length       !|@lrecl     !|% Password protection !|@password     !|\n!|% Block size          !|@blksize   !|% RACF attribute      !|@racfa        !|\n!|% Allocation units    !|@units     !|% Change indicator    !|@updated      !|\n!|% Space allocated     !|@alloc     !*a2,s1                                  *\n!|% Space used          !|@used      !|% Members in directory!|@members      !|\n!|% Primary allocation  !|@primary   !|% Allocated dir blocks!|@adirblk      !|\n!|% Secondary allocation!|@seconds   !|% Used dir blocks     !|@udirblk      !|\n!|% Extents used        !|@extents   !*a3,s1                                  *\n!|% Creation date       !|@create    !|% Tracks per cylinder !|@trkscyl      !|\n!|% Expiration date     !|@exdate    !|% Blocks per track    !|@blkstrk      !|\n!|% Type of dataset     !|@dssms     !|                      !|              !|\n *h2,s2                                                                        *\n\n)INIT\n&ZWINTTL = ''\n)PROC\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "QL": {"ttr": 4114, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x04\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00\\x1c\\x00\\x1c\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:04", "lines": 28, "newlines": 28, "modlines": 0, "user": "KANNAN"}, "text": "/* Rexx ql - QuickLocate */\nAddress ISPEXEC\n'CONTROL ERRORS RETURN'\nAddress ISREDIT\n'MACRO PROCESS'\n'(CL,CC) = CURSOR'\nif cc = 0 Then Exit\n\ndelim = \"~'!*%&-_=+\\{};:`<,>/?\" '\"'\n'ISREDIT (LINE) = LINE .ZCSR'\nend = length(line)\nstart = end - verify(reverse(line)\" \",delim,\"M\",end-cc+1)+2\nend = verify(line\"\",delim,\"M\",cc)-1\n\nif start > end Then Exit\nword = substr(line,start,end-start+1)\n\nAddress ISPEXEC\nx = SYSDSN(\"'\"word\"'\")\nIf x = 'OK' Then Do\n     ZEDSMSG = x\", File located\"\nEnd\nElse Do\n     ZEDSMSG = x\nEnd\nAddress ISPEXEC 'SETMSG MSG(ISRZ001)'\n'ISREDIT CURSOR = 'cl cc\nExit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "QM": {"ttr": 4116, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x04\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00'\\x00'\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:04", "lines": 39, "newlines": 39, "modlines": 0, "user": "KANNAN"}, "text": "/* Rexx qm */\naddress ISREDIT\n'MACRO PROCESS'\n'(CL,CC) = CURSOR'\nif cc = 0 then exit\n\naddress ISPEXEC\n'control errors return'\n\ndelim = \"~'!*%&-_=+\\{};:`<,>/?\" '\"'\n'ISREDIT (LINE) = LINE .ZCSR'\nend = length(line)\nstart = end - verify(reverse(line)\" \",delim,\"M\",end-cc+1)+2\nend = verify(line\"\",delim,\"M\",cc)-1\n\nif start > end then exit\nword = substr(line,start,end-start+1)\n   name = \"'\"word\"'\"\n   avail = sysdsn(name)\n   if avail \\= \"OK\" then do\n       zedlmsg = avail\n      \"setmsg msg(isrz000)\";exit\n   end\n\nQWORD = word\n'VPUT (QWORD) PROFILE'\n'Addpop'\n'SELECT PANEL(QMPNL)'\nDispRC = RC\n'Rempop'\nIf DispRC = 8 Then Do\n   ZEDSMSG = 'Function canceled'\n   'ISPEXEC SETMSG MSG(ISRZ001)'\n   Return\nEnd\n\nqui :\n\"ISREDIT CURSOR = \"cl cc\nexit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "QMPNL": {"ttr": 4118, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x04\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00,\\x00,\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:04", "lines": 44, "newlines": 44, "modlines": 0, "user": "KANNAN"}, "text": ")ATTR\n    @ TYPE(TEXT)   INTENS(HIGH) COLOR(WHITE)\n    # TYPE(OUTPUT) INTENS(HIGH) COLOR(WHITE)\n    $ TYPE(TEXT)   INTENS(HIGH) COLOR(YELLOW)\n    ! TYPE(TEXT)   INTENS(HIGH) COLOR(RED)\n    _ TYPE(INPUT)  INTENS(HIGH) COLOR(TURQ)\n)BODY WINDOW(45,14)\n+\n@OPTION ===>_ZCMD                         +\n+\n       @B   qB - BROWSE dataset\n       @D   qD - DELETE dataset\n       @E   qE - EDIT dataset\n       @I   qI - dataset INFORMATION\n       @H   qH - HRECALL migrated dataset\n       @L   qL - LOCATE a dataset\n       @R   qR - RENAME dataset\n       @V   qV - VIEW dataset\n\n    Press PF3 to cancel\n\n)INIT\n&ZWINTTL= 'Quick Menu'\n.CURSOR = ZCMD\nVGET (QWORD) PROFILE\n)REINIT\n&ZWINTTL= 'Quick Menu'\n.CURSOR = ZCMD\nVGET (QWORD) PROFILE\n)PROC\n&ZWINTTL= ''\n VER(&ZCMD,LIST,' ','B','D','E','I','H','L','R','V')\n &ZSEL = TRANS( TRUNC (&ZCMD,'.')\n           B,'CMD(QB) SUSPEND'\n           D,'CMD(QD)'\n           E,'CMD(QE) SUSPEND'\n           I,'CMD(QI QWORD) SUSPEND'\n           H,'CMD(QH)'\n           L,'CMD(QL)'\n           R,'CMD(QR)'\n           V,'CMD(QV) SUSPEND'\n        ' ',' '\n        *,'?' )\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "QN": {"ttr": 4353, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x04\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00\\x07\\x00\\x07\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:04", "lines": 7, "newlines": 7, "modlines": 0, "user": "KANNAN"}, "text": "/* REXX qn QuickNumber */\nAddress ISREDIT\n\"MACRO NOPROCESS\"\n\"(LAST) = LINENUM .ZLAST\"\nZedsMsg = Format(last) 'lines'\nAddress ISPEXEC \"SETMSG MSG(ISRZ001)\"\nExit 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "QR": {"ttr": 4355, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x04\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00 \\x00 \\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:04", "lines": 32, "newlines": 32, "modlines": 0, "user": "KANNAN"}, "text": "/* Rexx qr - QuickRename */\nAddress ISPEXEC\n'CONTROL ERRORS RETURN'\nAddress ISREDIT\n'MACRO PROCESS'\n'(CL,CC) = CURSOR'\nIf cc = 0 Then Exit\n\ndelim = \"~'!*%&-_=+\\{};:`<,>/?\" '\"'\n'ISREDIT (LINE) = LINE .ZCSR'\nend = length(line)\nstart = end - verify(reverse(line)\" \",delim,\"M\",end-cc+1)+2\nend = verify(line\"\",delim,\"M\",cc)-1\n\nIf start > end Then Exit\nword = substr(line,start,end-start+1)\n\nSay 'The dataset to rename is 'word'.'\nSay;Say;Say 'Please enter at the prompt the new name,'\nSay ' or \"HI\" to Exit. ';Say\nPull word2\nIf word2 = 'HI' Then Exit\nAddress TSO\n\"RENAME '\"word\"','\"word2\"'\"\nIf RC = 0 Then\n   Say 'Rename to \"'word2'\" was successful.'\nElse\n   Say 'Rename to \"'word2'\" was not successful.'\n\nIf rc > 0 Then Address ISPEXEC 'SETMSG MSG('zerrmsg')'\n'ISREDIT CURSOR = 'cl cc\nExit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "QS": {"ttr": 4357, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x04\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00,\\x00,\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:04", "lines": 44, "newlines": 44, "modlines": 0, "user": "KANNAN"}, "text": "/* Rexx QS                                                            */\n/* .................................................................. */\n/* Author  : Kannan AK                                                */\n/* QS      : Quick SDSF and return back to edit/view                  */\n/* Notice  : Use END;END to get back                                  */\n/* Version : Alpha                                                    */\n/* .................................................................. */\n   Parse Source . . Me .\n   'ISREDIT MACRO (OPT) NOPROCESS'\n   If RC = 20 Then Do\n      ZEDSMSG = 'Not a TSO command'\n      ZEDLMSG = Me 'should be invoked as an Edit/View macro'\n      Address ISPEXEC 'SETMSG MSG(ISRZ000)'\n      Exit 1\n   End\n   Upper OPT\n   ZPARM = 'ST'\n   If Length(OPT) > 0 Then ZPARM = OPT\n   Service = ''\n   Address ISPEXEC\n   'VGET (ZSCREENI)'\n   TitleScr = strip(substr(ZSCREENI,162,6))\n   If TitleScr = 'VIEW' | TitleScr = 'EDIT' Then Do\n      If TitleScr = 'EDIT' Then Service = ''\n      If TitleScr = 'VIEW' Then Service = 'VIEW'\n   End\n\n   'ISREDIT (openmbr) = MEMBER'\n   'ISREDIT (opendsn) = DATASET'\n   'ISREDIT End'\n\n   'SELECT PGM(ISFISP) NOCHECK NEWAPPL(ISF) PARM(&ZPARM)'\n\n   openmbr = strip(openmbr)\n   opendsn = strip(opendsn)\n   If openmbr = '' Then\n      viewdsn = \"'\"||opendsn||\"'\"\n   Else\n      viewdsn = \"'\"||opendsn||'('||openmbr||\")'\"\n\n   ZCMD = 'END;TSO ISREPDF' viewdsn  Service\n   'CONTROL NONDISPL ENTER'\n   'DISPLAY PANEL (ISR@PRIM)'\nExit 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "QV": {"ttr": 4359, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x04\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00\\x18\\x00\\x18\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:04", "lines": 24, "newlines": 24, "modlines": 0, "user": "KANNAN"}, "text": "/* Rexx qv - QuickView */\nAddress ISPEXEC\n'CONTROL ERRORS RETURN'\nAddress ISREDIT\n'MACRO PROCESS'\n'(CL,CC) = CURSOR'\nif cc = 0 Then Exit\n\ndelim = \"~'!*%&-_=+\\{};:`<,>/?\" '\"'\n'ISREDIT (LINE) = LINE .ZCSR'\nend = length(line)\nstart = end - verify(reverse(line)\" \",delim,\"M\",end-cc+1)+2\nend = verify(line\"\",delim,\"M\",cc)-1\n\nIf start > end Then Exit\nword = substr(line,start,end-start+1)\nAddress ISPEXEC\n'CONTROL DISPLAY SAVE'\n\"VIEW DATASET('\"word\"')\"\nif rc > 0 Then  'SETMSG MSG(ISRZ002)'\n'CONTROL DISPLAY RESTORE'\n\n'ISREDIT CURSOR = 'cl cc\nExit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REFDD": {"ttr": 4361, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x04\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00)\\x00)\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:04", "lines": 41, "newlines": 41, "modlines": 0, "user": "KANNAN"}, "text": "/* Rexx REFDD */\nARG Refno Editmode\nAddress ISPEXEC\nControl Errors Return\nAddress TSO\nIf Refno = '' Then  Exit\n   PDSN =\"'\"||Userid().HANNA.REFDD||\"'\"\n   Avail = SysDsn(PDSN)\n   If Avail \\= \"OK\" Then Do\n       ZEDSMSG = Avail\n      \"ISPEXEC SETMSG MSG(ISRZ000)\";Exit\n   End\n    \"ALLOC DS(\"PDSN\") DD(IODD) SHR REUSE\"\n   If RC \\= 0 Then Do\n       \"ISPEXEC SETMSG MSG(ISRZ002)\" ;Exit\n   End\nSRC. = ''\n\"EXECIO *  DISKR IODD (stem SRC. FINIS\"\nIf RC \\= 0 Then Do\n       \"ISPEXEC SETMSG MSG(ISRZ002)\" ;Exit\nEnd\nPATT = ':'\nDo I=1 By 1 While I <= SRC.0\n   Parse Value SRC.I with Locator (PATT) Dsname\n   Locator = Strip(Locator)\n   Refno = Strip(Refno)\n   If Locator == Refno Then Signal Hit\nEnd\n\nHit :\nDsname = Strip(Translate(Dsname))\nIf Editmode = 'B' Then\n\"ISPEXEC Browse DATASET('\"Dsname\"')\"\nelse\n\"ISPEXEC Edit DATASET('\"Dsname\"')\"\nIf RC > 4 Then Do\n    \"ISPEXEC SETMSG MSG(ISRZ002)\"\nEnd\n\"FREE DD(\"IODD\")\"\nDrop SRC.\nExit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REX": {"ttr": 4363, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x04\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00%\\x00%\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:04", "lines": 37, "newlines": 37, "modlines": 0, "user": "KANNAN"}, "text": "/* REXX REX RECURSIVE EDIT EXTENDED                                   */\n/* TO GET A MEMBER LIST USE 'REX **'; WILDCARDS B*,*ABC*,*Y ALLOWED   */\n/* TO EDIT/VIEW/BROWSE ANOTHER DATASET: REX 'USERID.DSN.NAME' /(E|V|B)*/\n/* OR USE PATTERN, REX %% WILL BRING UP ALL 2 CHAR MEMBERS            */\nADDRESS ISPEXEC\n\"CONTROL ERRORS RETURN\"\n\"ISREDIT MACRO (NAME OP) NOPROCESS\"\nIF OP \\= '' THEN DO\n       IF (STRIP(TRANSLATE(OP))) = \"/E\" THEN\n       'ISPEXEC EDIT DATASET('NAME')'\n       IF (STRIP(TRANSLATE(OP))) = \"/B\" THEN\n       'ISPEXEC BROWSE DATASET('NAME')'\n       IF (STRIP(TRANSLATE(OP))) = \"/V\" THEN\n       'ISPEXEC VIEW DATASET('NAME')'\n       IF RC > 4 THEN DO\n          \"SETMSG MSG(ISRZ002)\"\n          EXIT\n       END\nEND\nELSE DO\n   IF LENGTH(NAME) = 0 THEN DO\n       ZEDSMSG = \"SPECIFY MEMBER OR DSNAME\"\n       \"SETMSG MSG(ISRZ001)\"\n       EXIT\n   END\n   IF LENGTH(NAME) > 8 THEN DO\n       ZEDSMSG = \"INVALID MEMBER OR DSNAME\"\n       \"SETMSG MSG(ISRZ001)\"\n       EXIT\n   END\n   \"ISREDIT EDIT\" NAME\n   IF RC > 4 THEN DO\n       \"SETMSG MSG(ISRZ002)\"\n       EXIT\n   END\nEND\nEXIT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXE": {"ttr": 4365, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x04\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00\\x1b\\x00\\x1b\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:04", "lines": 27, "newlines": 27, "modlines": 0, "user": "KANNAN"}, "text": "/* Rexx Rexe */\naddress tso \"clear\"\nstart:\nsay center(\"S y n t a x   C h e c k e r \",50)\nsignal on syntax\ncall input\ndo while(translate(inst) \u00ac= \"\")\n   say 'Result:'\n   interpret inst\n\n   say '         '\n   call input\nend\nsay center(\"H a p p y     R e x x i n g\",50)\nexit\ninput :\nsay center(\"\",50,'_')\nsay\nsay \"Input==>\"\nparse pull inst\nreturn\nsyntax :\nsay errortext(rc)\nsay 'Error Code........' rc\nsay 'Process Line......' sigl\nsay sourceline(sigl)\nsignal start\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXI": {"ttr": 4367, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x04\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00\\x04\\x00\\x04\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:04", "lines": 4, "newlines": 4, "modlines": 0, "user": "KANNAN"}, "text": "/* Rexx Rexi Rexx Command-Interpreter */\narg cmdline\ninterpret say cmdline\nexit\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "REXXTRY": {"ttr": 4369, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x04\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00\\xbb\\x00\\xbb\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:04", "lines": 187, "newlines": 187, "modlines": 0, "user": "KANNAN"}, "text": "/* SAA-portable REXXTRY procedure     11/08/91  version 1.05\n  Owned by IBM SAA REXX Development, Endicott, New York.\n    Loosely derived from an ancient formulation of Mike Cowlishaw.\n\n  This procedure lets you interactively try REXX statements.\n    If you run it with no parameter, or with a question mark\n    as a parameter, it will briefly describe itself.\n  You may also enter a REXX statement directly on the command line\n    for immediate execution and exit.  Example:  rexxtry call show\n\n  Enter 'call show' to see user variables provided by REXXTRY.\n  Enter '=' to repeat your previous statement.\n  Enter '?' to invoke system-provided online help for REXX.\n  The subroutine named 'sub' can be CALLed or invoked as 'sub()'.\n  REXXTRY can be run recursively with CALL.\n\n  Except for the signal instructions after a syntax error, this\n    procedure is an example of structured programming.\n  The 'clear' routine illustrates system-specific SAA-portable coding.\n*/\n  parse arg argrx                      /* Get user's arg string.    */\n  call house                           /* Go do some housekeeping.  */\n  select                               /* 3 modes of operation...   */\n    when argrx = '?' then call tell    /*   1.  Tell user how.      */\n    when argrx = ''  then do           /*   2.  Interactive mode.   */\n      call intro ; call main ; end\n    otherwise push argrx ; call main   /*   3.  One-liner and exit. */\n  end\ndone:  exit                            /* The only exit.            */\n\nhouse:                                 /* Housekeeping.             */\n  parse version version                /* Fill-in 2 user variables. */\n  parse source source                  /*                           */\n  parse source sysrx . procrx .        /* Get system & proc names.  */\n  remindrx = \"Enter 'exit' to end.\"    /* How to escape rexxtry.    */\n  helprx=''                            /* Null if not CMS or OS/2.  */\n  if sysrx = 'CMS' | sysrx = 'OS/2'    /*   Extra reminder for CMS  */\n    then helprx = '   ',               /*     or OS/2.              */\n    \"  Or '?' for online REXX help.\"   /*   Not used in intro.      */\n  promptrx=''                          /* Null if not one-liner.    */\n  if argrx<>'' then promptrx=procrx' ' /*   Name part of user line. */\n  if sysrx = 'OS/2' then do            /* OS/2-specific...          */\n    posrx = lastpos('\\',procrx)        /*   Find name separator.    */\n    procrx = substr(procrx,posrx+1)    /*   Pick up the proc name.  */\n    end\n  temprx = ' 'procrx' on 'sysrx        /* Make border...            */\n    posrx = 69-length(temprx)          /*   where to overlay name,  */\n    bordrx = copies('.',68)            /*   background of periods,  */\n    bordrx =,                          /*   name right-adjusted.    */\n      overlay(temprx,bordrx,posrx)\n  save = ''                            /* Don't save user input.    */\n  trace = 'Off'                        /* Init user trace variable. */\n  return result                        /* Preserve result contents. */\n\ntell:  call clear ; do irx = 1 to 20   /* Tell about rexxtry by     */\n  say sourceline(irx) ; end            /*   displaying the prolog.  */\n  return result                        /* Preserve result contents. */\n\nclear:  select                         /* SAA-portable code.        */\n  when sysrx = 'CMS'  then 'VMFCLEAR'  /* No such command on        */\n  when sysrx = 'OS/2' then 'CLS'       /*   OS/400 or TSO.          */\n  otherwise nop ; end ; say\n  return result                        /* Preserve result contents. */\n\nintro:                                 /* Display brief             */\n  say '  'procrx' lets you',           /*   introductory            */\n    'interactively try REXX',          /*   remarks for             */\n    'statements.'                      /*   interactive mode.       */\n  say '    Each string is executed',\n    'when you hit Enter.'\n  say \"      Enter 'call tell' for\",   /* How to see description.   */\n    \"a description of the features.\"\n  say '  Go on - try a few...   ',\n    '         'remindrx\n  return result                        /* Preserve result contents. */\n\nsub:  say '  ...test subroutine',      /* User can CALL this        */\n  \"'sub'  ...returning 1234...\"        /*   subroutine or           */\n  return 1234                          /*   invoke with 'sub()'.    */\n\nmain:  signal on syntax                /* Enable syntax trap.       */\n  do foreverrx = 1                     /* Loop forever.             */\n    prev = inputrx                     /* User can repeat previous. */\n    parse pull inputrx                 /* Input keyboard or queue.  */\n    current = inputrx                  /* Current line for 'show'.  */\n    if save <> '' then call save       /* Save before interpreting. */\n    if inputrx = '=' then inputrx=prev /* '=' means repeat previous */\n    select\n      when inputrx = '' then say ' ',  /* If null line, remind      */\n        procrx':  'remindrx helprx     /*   user how to escape.     */\n      when inputrx='?' then call help  /* Request for online help.  */\n      otherwise\n        rc = 'X'                       /* Make rc change visible.   */\n        call set2 ; trace (trace)      /* Need these on same line.  */\n        interpret inputrx              /* Try the user's input.     */\n        trace 'Off'                    /* Don't trace rexxtry.      */\n        call border                    /* Go write the border.      */\n    end\n    if argrx <> '' & queued() = 0      /* For one-liner, loop until */\n      then leave                       /*   queue is empty.         */\n  end ; return result                  /* Preserve result contents. */\n\nset1:  siglrx1 = sigl                  /* Save pointer to lineout.  */\n  return result                        /* Preserve result contents. */\n\nset2:  siglrx2 = sigl                  /* Save pointer to trace.    */\n  return result                        /* Preserve result contents. */\n\nsave:                                  /* Save before interpreting. */\n  call set1;rcrx=lineout(save,inputrx) /* Need on same line.        */\n  if rcrx <> 0 then                    /* Catch non-syntax error    */\n    say \"  Error on save=\"save         /*   from lineout.           */\n  return result                        /* Preserve result contents. */\n\nhelp:  select                          /* Request for online help.  */\n  when sysrx = 'CMS' then              /* Invoke CMS help menu for  */\n    address CMS 'HELP REXX MENU'       /*   for REXX.               */\n  when sysrx = 'OS/2' then             /* Invoke OS/2 online REXX   */\n    'view rexx.inf'                    /*   Reference.              */\n  otherwise say '  'sysrx' has',       /* Todate, only CMS and OS/2 */\n    'no online help for REXX.'         /*   provide online help     */\n    rc = 'Sorry !' ; end               /*   for REXX.               */\n  call border ; return result          /* Preserve result contents. */\n\nborder:  if rc = 'X' then              /* Display border.           */\n    say '  'bordrx\n  else say ' ',                        /* Show return code if it    */\n    overlay('rc = 'rc' ',bordrx)       /*   has changed.            */\n  return result                        /* Preserve result contents. */\n\nsyntax:  trace 'Off'                   /* Stop any tracing.         */\n  select\n    when sigl = siglrx1 then do        /* User's 'save' value bad.  */\n      say \"  Invalid 'save' value\",\n        \"'\"save\"', resetting to ''.\"\n      save='' ; end\n    when sigl = siglrx2 then do        /* User's 'trace' value bad. */\n      say \"  Invalid 'trace' value\",\n        \"'\"trace\"', resetting to\",\n        \"'Off'.\" ; trace='Off' ; end\n    otherwise                          /* Some other syntax error.  */\n         say '  Oooops ! ... try',     /*                           */\n      'again.     'errortext(rc)       /* Show the error msg text.  */\n      if sysrx='CMS' then call cmstax  /* More syntax stuff for CMS */\n  end ; call border                    /* Go write the border.      */\n  if argrx <> '' & queued() = 0 then   /* One-liner not finished    */\n    signal done                        /*   until queue is empty.   */\n  signal main                          /* Resume main loop.         */\n\ncmstax:  rcrx = rc                     /* More syntax stuff for CMS */\n  if exist('PROMPT MODULE') then       /* User's input to cmd line. */\n    'PROMPT' promptrx||'13'x||inputrx  /*   '13'x places cursor.    */\n  if exist('REXX EXEC') & argrx=''     /* Not for one-liners.       */\n  then do; more='EXEC REXX' rcrx+20000 /* CMS rc is 20,000 higher.  */\n    say \"  Enter 'more' to see\",       /* Prepare 'more' to access  */\n      'information about this',        /*  REXX IOSLIB information. */\n      'syntax error.' ; end            /* Tell user what to do.     */\n  rc = rcrx ; return result            /* Preserve result contents. */\n\nexist:  arg inrx ; outrx = 0           /* Assume file is missing.   */\n  address command 'ESTATE' inrx        /* Does the file exist ?     */\n  if rc = 0 then outrx = 1             /* estate says it exists.    */\n  return outrx                         /* 1 makes condition true.   */\n\nshow:  trace 'Off' ; call clear        /* Display user variables    */\n  say '  'procrx' provides',           /*   provided by rexxtry.    */\n    'these user variables.'\n  say '  The current values are...'    /* Show current values.      */\n  say\n  say \"    'version'   = '\"version\"'\"  /* What level of REXX.       */\n  say \"    'source'    = '\"source\"'\"   /* What oper system etc.     */\n  say \"    'result'    = '\"result\"'\"   /* REXX special variable.    */\n  say\n  say '     Previous line entered by',\n    'user.  Initial value=INPUTRX.'\n  say \"    'prev'      = '\"prev\"'\"     /* Previous user statement.  */\n  say \"    'current'   = '\"current\"'\"  /* Compare curr with prev.   */\n  say\n  say '     Save your input with',\n    'save=filespec.',\n    \" Stop saving with save=''.\"\n  say \"    'save'      = '\"save\"'\"     /* Filespec for input keep.  */\n  say\n  say '     Enter trace=i, trace=o',\n    ' etc. to control tracing.'\n  say \"    'trace'     = '\"trace\"'\"    /* Trace user statements.    */\n  return result                        /* Preserve result contents. */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RUNSQL": {"ttr": 4373, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x04\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00m\\x00m\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:04", "lines": 109, "newlines": 109, "modlines": 0, "user": "KANNAN"}, "text": "/* Rexx RunSQL */\nTrace O\nParse Source . . Me .\nAddress ISPEXEC\n'ISREDIT MACRO (DB2sub) NOPROCESS'\nIf RC = 20 Then Do\n    ZEDSMSG = 'Not a TSO command'\n    ZEDLMSG = Me 'should be invoked as an Edit/View macro'\n   'SETMSG MSG(ISRZ000)'\n    Exit 1\nEnd\n\nPARSE VALUE DB2sub with '-' DB2sub\nIf strip(DB2sub)= '' Then Do\n   ZEDSMSG = 'Syntax : RUNSQL -DB2SSID'\n   'SETMSG MSG(ISRZ000)'\n   Exit 1\nEnd\n\n'Control Errors Return'\nx = OutTrap(\"DB2out.\",\"*\")\n    CALL AllocateIn\n    CALL AllocateOut\n    Call ExecuteDSNTEP2\n    Call CleanUp\nx = OutTrap(\"OFF\")\nExit 1\n\nAllocateIn :\nDo queued();Pull;End\n\"ISREDIT (first) = linenum .zf\"\n\"ISREDIT (last)  = linenum .zl\"\n   Do i = first to last by 1\n     \"ISREDIT (Linebuf) = line\" i\n     Queue Linebuf\n   End\nQueue ''\n\nAddress TSO\n'ALLOC F(SYSIN) REUSE NEW DEL UNIT(SYSDA) LRECL(80) RECFM(F B)\n SPACE(10,10) TRACK RELEASE DSO(PS) BLKSIZE(80)'\n'EXECIO' Queued() 'DISKW SYSIN (FINIS'\n\"Delete '\"USERID()\".SYSPRINT'\"\nDo queued();Pull;End\n\nRETURN\n\nAllocateOut :\nAddress TSO \"ALLOC F(SYSPRINT) NEW UNIT(SYSDA) SPACE(8,2)\",\n            \"TRACKS REUSE DSNAME('\"USERID()\".SYSPRINT')\"\nReturn\n\nExecuteDSNTEP2:\nAddress ISPEXEC \"LIBDEF STEPLIB DATASET ID(\"'SYS0.DB2.PROD.DSNLOAD'\")\"\n\nCall MeasureStart\nAddress TSO \"NEWSTACK\"\nQueue \"RUN PROGRAM(DSNTEP2) PLAN(DSNTEP2) \",\n      \"LIBRARY('SYS0.DB2.#510.PROD.RUNLIB.LOAD') PARMS('ALIGN(LHS)')\"\nQueue \"END\"\nQueue\nAddress TSO \"DSN SYSTEM(\"DB2sub\")\"\nAddress TSO \"DELSTACK\"\nCall MeasureEnd\n\nAddress ISPEXEC \"LMINIT DATAID(DSID) DDNAME(SYSPRINT)\"\nAddress ISPEXEC \"BROWSE DATAID(\"DSID\")\"\nAddress ISPEXEC \"LMFREE DATAID(\"DSID\")\"\nReturn\n\nCleanUp:\nAddress TSO \"Delete '\"USERID()\".SYSPRINT'\"\nRETURN\n\nMeasureStart: Procedure Expose ELA CPU SRV CostB CostE\nELA = TIME('R')\nCPU = SYSVAR(SYSCPU)\nSRV = SYSVAR(SYSSRV)\nCall CostSession\nCostB = RESULT\nReturn\n\nMeasureEnd: Procedure Expose ELA CPU SRV CostB CostE\nELA = TIME('R')      - ELA\nCPU = SYSVAR(SYSCPU) - CPU\nSRV = SYSVAR(SYSSRV) - SRV\nCall CostSession\nCostE = RESULT - CostB\nQueue '                                         '\nQueue '-----------------------------------------'\nQueue ' Elapsed Time Wall Clock : 'ELA\nQueue ' CPU Seconds             : 'CPU\nQueue ' Service Units           : 'SRV\nQueue ' Estimated Cost          :$'CostE\nQueue '-----------------------------------------'\nQueue '                                         '\nAddress TSO 'EXECIO' 0 'DISKW SYSPRINT (FINIS'\nAddress TSO \"ALLOC F(SYSPRINT) MOD REUSE DSNAME('\"USERID()\".SYSPRINT')\"\nAddress TSO 'EXECIO' Queued() 'DISKW SYSPRINT (FINIS'\nReturn\n\nCostSession:\ncp1 = sysvar(syscpu)                        /* get cpu time          */\nhour = substr(time(),1,2)                   /* get hour of the day   */\nIf (hour > 16) | (hour < 8)                 /* prime or non-prime?   */\n  Then cost = .07                           /* non-prime cost factor */\n  Else cost = .13944444                     /* prime cost factor     */\nResult = 3.2*cp1*cost\nReturn Result\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SAMPLECL": {"ttr": 4609, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x04\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00\\x16\\x00\\x16\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:04", "lines": 22, "newlines": 22, "modlines": 0, "user": "KANNAN"}, "text": "/* Rexx SAMPLECL                                                      */\n/* .................................................................. */\n/* Author  : Kannan AK                                                */\n/* SAMPLECL: Alter MGMTCLAS                                           */\n/* Notice  : Shop dependent                                           */\n/* Version : Alpha                                                    */\n/* Usage   : 3.4                                                      */\n/* .................................................................. */\narg str\naddress ispexec\nX = OUTTRAP('juNk','*','NOCONCAT')\nADDRESS TSO \"ALTER \"str\" MGMTCLAS(SAMPLECL)\"\n       if RC > 0 then do\n          ZEDSMSG = '*Request Failed*'\n          \"ISPEXEC SETMSG MSG(ISRZ000)\"\n       end\n       else do\n          ZEDSMSG = '*MGMTCLAS altered*'\n          \"ISPEXEC SETMSG MSG(ISRZ000)\"\n       end\nX = OUTTRAP(OFF)\nexit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SDSFREXX": {"ttr": 4611, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x04\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00\\x16\\x00\\x16\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:04", "lines": 22, "newlines": 22, "modlines": 0, "user": "KANNAN"}, "text": "/* REXX */\nIf sdsfCmd(\"ST\") = 0 Then\n    Do sdsfLine = 1 To sdsfOut.0\n      If Length(Strip(sdsfOut.sdsfLine)) > 0 Then\n         Say sdsfOut.sdsfLine\n    End\nExit 0\n\n  sdsfCmd: Procedure Expose sdsfOut.\n    Parse Upper Arg sdsfCmd\n    Address 'TSO'\n    'NEWSTACK'\n    'ALLOC FILE(ISFIN)  RECFM(F,B) LRECL(80) BLKSIZE(0) NEW DELETE REU'\n    'ALLOC FILE(ISFOUT) RECFM(F,B) LRECL(80) BLKSIZE(0) NEW DELETE REU'\n    Queue sdsfCmd\n    'EXECIO ' QUEUED() ' DISKW ISFIN (FINIS)'\n    Address 'LINKMVS' 'SDSF'\n    sdsfRC = RC\n    'EXECIO * DISKR ISFOUT (STEM sdsfOut. FINIS)'\n    'FREE FILE(ISFIN,ISFOUT)'\n    'DELSTACK'\n  Return sdsfRC\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SDSFST": {"ttr": 4613, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x04\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00'\\x00'\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:04", "lines": 39, "newlines": 39, "modlines": 0, "user": "KANNAN"}, "text": "/* REXX - SDSFST : Display the SDSF STATUS data                       */\n/* No parm default to your userid                                     */\n/* Give userid as parm if you need to look at other ids's jobs        */\n/* .................................................................. */\n/* Author  : Kannan AK                                                */\n/* SDSFST  : Return job status                                        */\n/* Notice  : None                                                     */\n/* Version : Alpha                                                    */\n/* .................................................................. */\nArg User\nalpha = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890@#$'\nIf User = '' Then User = Userid()\nk = 1\nAddress TSO\nDo i = 1 To 39\n   x = outtrap(\"var.\")\n   'ST' User||substr(alpha,i,1)\n   x = outtrap(off)\n   Do n = 1 To var.trapped\n      sto.k = var.n\n      k = k + 1\n   End\nEnd\nsto.0 = k - 1\nQueue Date() ':' Time() ':' SDSF STATUS ':' User\nQueue copies(' ',255)\nDo j = 1 To sto.0\n   If pos('NOT FOUND',sto.j) > 0 Then NOP\n   Else queue sto.j\nEnd\nAddress ispexec 'VGET (ZSCREEN) SHARED'\nddname='$TRAP$'zscreen\n'ALLOC F('ddname') UNIT(VIO) DSO(PS) RECFM(V B) LRECL(255) NEW DEL REU'\n'EXECIO 'queued()' DISKW 'ddname' (FINIS'\nAddress ispexec 'LMINIT DATAID(TRAP) DDNAME('ddname') ENQ(SHR)'\nAddress ispexec 'BROWSE DATAID('trap')'\nAddress ispexec 'LMFREE DATAID('trap')'\n'FREE F('ddname')'\nExit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SHADOW": {"ttr": 4615, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x04\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00\\x17\\x00\\x17\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:04", "lines": 23, "newlines": 23, "modlines": 0, "user": "KANNAN"}, "text": ")ATTR\n* AREA(DYNAMIC) scroll(off) extend(off)\n$ TYPE(CHAR) COLOR(YELLOW) GE(ON)\n^ TYPE(CHAR) COLOR(RED)    GE(ON)\n# TYPE(CHAR) COLOR(YELLOW) GE(ON)\n_ TYPE(DATAIN)\n)BODY\n%-------------------CHARACTER ATTRIBUTE PANEL------------------------\n%COMMAND ===>_ZCMD                                                  +\n*B,S  * *X,Y*\n*     * *   *\n*     *\n*     *\n*     *\n*     *\n*     *\n)INIT\n&B = 'EsssssNeYYYYYee     eeYYYYYeeYYYYYeeYYYYYeDsssssM   '\n&X = 'EsssNDsssM                                          '\n&S = '########     ##     ##     ##     ##     ###########'\n&Y = '####################################################'\n)END\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SHOWBAR": {"ttr": 4617, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x04\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00\\x17\\x00\\x17\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:04", "lines": 23, "newlines": 23, "modlines": 0, "user": "KANNAN"}, "text": "/* Rexx */\narg barlop barcnt barmsg barhdr\nAddress Ispexec\nIf barlop = 0  Then barlop = 9999\nIf barmsg = '' Then barmsg = 'Please wait...'\nwaitmsg = barmsg\n/* barstp = Max(barlop%barmax,1) */\n/* barcnt = 1 to barlop */\n/* If barcnt // barstp = 0 Then do */\n      thisperc =  barcnt / barlop\n      indll    =  Trunc(50 * thisperc)\n      ProcInd  = '?'||Copies(' ',indll)||'#'\n      If length(ProcInd) > 8 then do\n          strtpos = (Length(ProcInd) % 2) - 2\n          txt     = Strip(format(thisperc*100,3,0),'L','0') || ' %'\n          ProcInd = Overlay(txt,ProcInd,strtpos)\n      End\n/*     \"Control Display Lock\" */\n       \"AddPop\"\n       \"Display Panel(PROGPNL)\"\n       \"RemPop\"\n/* End */\nreturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SITECMDS": {"ttr": 4619, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x04\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00\\x80\\x00\\x80\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:04", "lines": 128, "newlines": 128, "modlines": 0, "user": "KANNAN"}, "text": "/* Rexx SiteCMDS                                                      */\n/* .................................................................. */\n/* Author  : Kannan AK                                                */\n/* SiteCMDS: Add User Commands to in-storage ISPF Command Table       */\n/* Notice  : Not Sitewide, effects session wide                       */\n/*         : Just named so. You can do site commands in ISPCCONF      */\n/*         : QUIET option will suppress message                       */\n/* Refer   : http://www.naspa.com/PDF/97/T9712009.pdf                 */\n/*         : http://www.naspa.com/PDF/99/T9906008.pdf                 */\n/* Version : Alpha                                                    */\n/* .................................................................. */\nArg opt\nParse Source System . CmdName .\nAddress Ispexec\nadded     = 0\nupdated   = 0\ndeleted   = 0\nexec_line = 70\nCall GetInstreamCommands\n Do Queued()\n   Pull  c\n   Upper c\n   If word(c,1) = \"/*\" Then Iterate\n   If c = \"\"           Then Iterate\n   dlm=substr(c,1,1)\n   Parse Var c (dlm) verb (dlm) trunc,\n               (dlm) act  (dlm) desc (dlm) .\n   Upper verb act\n   If dlm = '-' Then Call TableDelete\n   Else Call TableUpdate\n End\n   If wordpos('QUIET',opt) = 0 Then\n   zedlmsg = CmdName || ,\n             \" : Added(\"added\") Updated(\"updated\") Deleted(\"deleted\")\"\n   Address Ispexec \"setmsg msg(isrz001)\"\nExit 0\n\nTableUpdate:\n If LocateCommand(verb) = 0 Then Do\n   Call UpdateVar\n   'tbput ISPCMDS'\n   updated = updated + 1\n   Return\n End\n 'tbtop ISPCMDS'\n Call UpdateVar\n 'tbadd ISPCMDS'\n added = added + 1\n Return\n\nTableDelete:\n If LocateCommand(verb) > 0 Then return\n 'tbdelete ISPCMDS'\n deleted = deleted + 1\n Return\n\nUpdateVar:\n zctverb=verb\n zcttrunc=trunc\n zctact=act\n zctdesc=desc\n Return\n\nLocateCommand:\n \"tbtop    ISPCMDS\"\n Arg zctverb\n \"tbscan   ISPCMDS arglist(zctverb)\"\n Return RC\n\nGetInstreamCommands:\nDo queued();Pull;End\nDo Until substr(line,1,9)='/*COMMAND'\n  line = sourceline(exec_line)\n  exec_line = exec_line + 1\nEnd\nDo until substr(line,1,2)='*/'\n  line = sourceline(exec_line)\n  If substr(line,1,2) \\= '*/' Then\n    Queue line\n    exec_line = exec_line + 1\nEnd\nReturn\n\n/*COMMAND\n/SX/0/ALIAS SAVE/SHORT FORM OF SAVE/\n/PREV/0/ALIAS RETRIEVE/SHORT FORM OF RETRIEVE/\n/PDE/0/SELECT PANEL(PDS@PRIM)/STARTOOL OR PDS 8.5 MAIN ENTRY PANEL/\n/SP0/0/SELECT PGM(ISPISM) SCRNAME(SETTINGS)/ISPF 0/\n/SP1/0/SELECT PGM(ISRBRO) PARM(ISRBRO01) SCRNAME(VIEW)/ISPF 1/\n/SP2/0/SELECT PGM(ISREDIT) PARM(P,ISREDM01) SCRNAME(EDIT)/ISPF 2/\n/SP3/0/SELECT PANEL(ISRUTIL) SCRNAME(UTIL)/ISPF 3/\n/SP4/0/SELECT PANEL(ISRFPA) SCRNAME(FOREGRND)/ISPF 4/\n/SP5/0/SELECT PGM(ISRJB1) PARM(ISRJPA) SCRNAME(BATCH) NOCHECK/ISPF 5/\n/SP6/0/SELECT PGM(ISRPTC) SCRNAME(CMD)/ISPF 6/\n/SP7/0/SELECT PGM(ISPYXDR) PARM(&ZTAPPLID) SCRNAME(DTEST) NOCHECK/SP7/\n/SP8/0/SELECT PANEL(ISRLPRIM) SCRNAME(LMF)/ISPF8/\n/SP9/0/SELECT PANEL(ISRDIIS) ADDPOP/ISPF 9/\n/SP10/0/SELECT PGM(ISRSCLM) SCRNAME(SCLM) NOCHECK/ISPF 10/\n/SP11/0/SELECT PGM(ISRUDA) PARM(ISRWORK) SCRNAME(WORK)/ISPF 11/\n/SP31/0/SELECT PGM(ISRUDA) PARM(ISRUDA1) SCRNAME(LIBUTIL)/ISPF 3.1/\n/SP32/0/SELECT PGM(ISRUDA) PARM(ISRUDA2) SCRNAME(DSUTIL)/ISPF 3.2/\n/SP33/0/SELECT PGM(ISRUMC) SCRNAME(MCOPY)/ISPF 3.3/\n/SP34/0/SELECT PGM(ISRUDL) PARM(ISRUDLP) SCRNAME(DSLIST)/ISPF 3.4/\n/SP35/0/SELECT PGM(ISRURS) SCRNAME(RESET)/ISPF 3.5/\n/SP36/0/SELECT PGM(ISRUHC) SCRNAME(HARDCOPY)/ISPF 3.6/\n/SP37/0/SELECT PANEL(ISPUDL) SCRNAME(DOWNLOAD)/ISPF 3.7/\n/SP38/0/SELECT PGM(ISRUOLP) SCRNAME(OUTLIST)/ISPF 3.8/\n/SP39/0/SELECT PANEL(ISPUCMA) ADDPOP SCRNAME(CMDTABLE)/ISPF 3.9/\n/SP311/0/SELECT PGM(ISRFMT) SCRNAME(FORMAT)/ISPF 3.11/\n/SP312/0/SELECT PGM(ISRSSM) SCRNAME(SUPERC)/ISPF 3.12/\n/SP313/0/SELECT PGM(ISRSEPRM) SCRNAME(SUPERCE) NOCHECK/ISPF 3.13/\n/SP314/0/SELECT PGM(ISRSFM) SCRNAME(SRCHFOR)/ISPF 3.14/\n/SP315/0/SELECT PGM(ISRSEPRM) PARM(S4) SCRNAME(SRCHFORE) NOCHECK/3.15/\n/SCANMEM/0/SELECT CMD(%SCANMEM &ZPARM)/SCAN MEMBER PATTERN FOR PDS/\n/U2/0/SELECT CMD(%CE)/CUSTOM EDITOR/\n/CE/0/SELECT CMD(%CE)/CUSTOM EDITOR/\n/CX/0/SELECT CMD(%CX)/SCREEN EDITOR/\n/IMAGEJCL/0/SELECT CMD(%IMAGEJCL)/IMAGECOPY JCL WRITER/\n/DISPUTIL/0/SELECT CMD(%DISPUTIL)/DISPLAY RUNNING DB2 UTILITIES/\n/DISPPEND/0/SELECT CMD(%DISPPEND)/DISPLAY RESTRICTED DATABASES/\n/PAD/0/SELECT CMD(%PAD)/CLIPBOARD/\n/$/0/SELECT CMD(%$)/SESSION COST/\n/DS/0/SELECT PGM(ISRUDL) PARM(ISRUDLP) SCRNAME(DSLIST)/ISPF 3.4/\n/DLE/0/SELECT CMD(%LIBRARN)/ELIPS/\n/ISPCMDU/0/SELECT CMD(%ISPCMDU)/USER COMMANDS TABLE/\n/SITECMDS/4/SELECT CMD(%SITECMDS)/USER COMMANDS TABLE/\n/QST/0/SELECT PGM(ISFISP) NOCHECK NEWAPPL(ISF) PARM(&ZPARM)/SDSF/\n*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SJ": {"ttr": 4622, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x04\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00\\x14\\x00\\x14\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:04", "lines": 20, "newlines": 20, "modlines": 0, "user": "KANNAN"}, "text": "/* Rexx Custom Submit */\n\"isredit macro\"\naddress ispexec\n'isredit (openmbr) = member'\n'isredit (opendsn) = dataset'\ncall outtrap 'out.'\naddress tso \"submit '\"opendsn'('openmbr')'\"'\"\ncall outtrap 'off'\ndo i = 1 to out.0\n   parse var out.i 'JOB' jobname '(' jobid ')' status\nend i\nsubjobname = strip(jobname,b)\nsubjobid   = strip(jobid,b)\nsubjob     = subjobname || \"(\" || subjobid || \")\"\nsay out.1\n\"isredit locate .zfirst\"\n\"isredit change p'========'\" subjobid \"65 72\"\n\"isredit locate 0\"\n\"isredit cursor = \" 1 1\nexit 1\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SL": {"ttr": 4624, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x04\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00 \\x00 \\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:04", "lines": 32, "newlines": 32, "modlines": 0, "user": "KANNAN"}, "text": "/* REXX */\nADDRESS ISPEXEC\nMRC=0\n\"ISREDIT MACRO \"\n\"ISREDIT FIND 'ENVIRONMENT DIVISION' FIRST\";MRC=MRC+RC\nIF RC = 0 THEN\n\"ISREDIT LABEL .ZCSR = .ED 0\"\n\"ISREDIT FIND 'DATA DIVISION' NEXT\";MRC=MRC+RC\nIF RC = 0 THEN\n\"ISREDIT LABEL .ZCSR = .DD 0\"\n\"ISREDIT FIND 'PROCEDURE DIVISION' NEXT\";MRC=MRC+RC\nIF RC = 0 THEN\n\"ISREDIT LABEL .ZCSR = .PD 0\"\n\"ISREDIT FIND 'FILE SECTION'  FIRST\";MRC=MRC+RC\nIF RC = 0 THEN\n\"ISREDIT LABEL .ZCSR = .FS 0\"\n\"ISREDIT FIND 'WORKING-STORAGE SECTION' FIRST\";MRC=MRC+RC\nIF RC = 0 THEN\n\"ISREDIT LABEL .ZCSR = .WS 0\"\n\"ISREDIT FIND 'LINKAGE SECTION' FIRST\";MRC=MRC+RC\nIF RC = 0 THEN\n\"ISREDIT LABEL .ZCSR = .LS 0\"\nIF MRC = 24 THEN DO\n    ZEDSMSG = \"NO LABEL SET\"\n    \"SETMSG MSG(ISRZ001)\"\nEND\nELSE DO\n    ZEDSMSG = \"LABEL(S) SET\"\n    \"SETMSG MSG(ISRZ000)\"\nEND\n\"ISREDIT LOCATE .ZFIRST\"\nEXIT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SLEEP": {"ttr": 4626, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x04\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00\\x05\\x00\\x05\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:04", "lines": 5, "newlines": 5, "modlines": 0, "user": "KANNAN"}, "text": "/* Rexx Sleep */\nCBL_PARM = '0004'X\nADDRESS LINKPGM \"ILBOWAT0 CBL_PARM\"\nSAY 'ILBOWAT0 RETURN CODE = ' RC\nReturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SMS": {"ttr": 4628, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x04\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00L\\x00L\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:04", "lines": 76, "newlines": 76, "modlines": 0, "user": "KANNAN"}, "text": "/* Rexx SMS                                                           */\n/* .................................................................. */\n/* Author  : Kannan AK                                                */\n/* SMS     : Return SMS Classes                                       */\n/* Notice  : 2 versions are given. LISTDSI is terse                   */\n/* Version : Alpha                                                    */\n/* .................................................................. */\narg str getline title\nCall ShowSMS2 str dataclas storclas mgmtclas\n\nif title = 'QC' & result = 'IAM' then return IAM\n\nif title = '' then\n   ZWINTTL ='* SMS Classes *'\nif title = 'QC' then\n   ZWINTTL ='* Change parameters if needed *'\nif getline = '' then getline = str\naddress ispexec \"vput (ZWINTTL)\"\naddress ispexec \"addpop\"\naddress ispexec \"display panel(smspnl)\"\naddress ispexec \"rempop\"\nif title = '' then exit 0\nsp = ' '\nresult = getline || sp || dataclas || sp || storclas || sp || mgmtclas\nreturn result\n\nShowSMS : procedure expose str dataclas storclas mgmtclas\n\naddress ispexec\nf = OUTTRAP('OUTL.','*','NOCONCAT')\nADDRESS TSO \"LISTCAT ENTRIES(\"str\") ALL\"\nf = OUTTRAP(OFF)\n       if RC > 0 then do\n          ZEDSMSG = '*Obtain Failed*'\n          \"ISPEXEC SETMSG MSG(ISRZ000)\"\n          exit 0\n       end\nif pos('$IAM',outl.4) > 0  then\n   return IAM\n\nDO I=1 BY 1 while I <= OUTL.TRAPPED\n\n  if pos('DATACLAS',outl.i) > 0  then do\n       dataclas = outl.i\n       TTAB  = \"-()\"\n       dataclas = TRANSLATE(dataclas,\" \",TTAB)\n       parse value dataclas with d1 d2 d3 d4\n       dataclas = d2\n  end\n  if pos('STORAGECLAS',outl.i) > 0  then do\n       storclas = outl.i\n       TTAB  = \"-()\"\n       storclas = TRANSLATE(storclas,\" \",TTAB)\n       parse value storclas with s1 s2 s3 s4\n       storclas = s2\n  end\n  if pos('MANAGEMENTCLAS',outl.i) > 0  then do\n       mgmtclas = outl.i\n       TTAB  = \"-()\"\n       mgmtclas = TRANSLATE(mgmtclas,\" \",TTAB)\n       parse value mgmtclas with m1 m2 m3 m4\n       mgmtclas = m4\n  end\nend\nreturn\n\nShowSMS2 : procedure expose str dataclas storclas mgmtclas\n\naddress ispexec\nx = listdsi(\"\"str\"\" directory norecall smsinfo)\ndataclas = SYSDATACLASS\nstorclas = SYSSTORCLASS\nmgmtclas = SYSMGMTCLASS\nreturn\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SMSPNL": {"ttr": 4631, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x04\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00\\r\\x00\\r\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:04", "lines": 13, "newlines": 13, "modlines": 0, "user": "KANNAN"}, "text": ")ATTR\n+ TYPE(TEXT)  INTENS(LOW)\n_ TYPE(INPUT) INTENS(HIGH) JUST(LEFT) PAD(' ')\n? TYPE(INPUT) INTENS(LOW ) JUST(LEFT) PAD(' ') COLOR(YELLOW)\n)BODY  WINDOW(61,7)\n CMD >?ZCMD\n\n => Dataset  : _getline                                     +\n => DataClas : _dataclas               +\n => StorClas : _storclas               +\n => MgmtClas : _mgmtclas               +\n\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SQLC": {"ttr": 4633, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x04\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00\\r\\x00\\r\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:04", "lines": 13, "newlines": 13, "modlines": 0, "user": "KANNAN"}, "text": "/* Rexx SQLC                                                          */\naddress tso 'clear'\narg sqlcode\nif datatype(sqlcode) <> 'NUM' then exit\nsqlc     = d2x(sqlcode,8)\nsqlc     = x2c(sqlc)\nsqlca    = 'SQLCA   'x2c(00000088)sqlc||x2c(0000)||copies(' ',78)\nsqlca    = sqlca||copies(x2c(00),24)copies(' ',16)\ntiar_msg = x2c(0190)copies(' ',400)\ntext_len = x2c(00000050)\naddress attchpgm 'dsntiar sqlca tiar_msg text_len'\nsay substr(tiar_msg,4,400)\nreturn\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SRCHLIST": {"ttr": 4635, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x04\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x01\\t\\x01\\t\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:04", "lines": 265, "newlines": 265, "modlines": 0, "user": "KANNAN"}, "text": "/* REXX  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n/*                                                                 */\n/* SRCHLIST - Create Option 3.14 Search Results Member List        */\n/*                                                                 */\n/* Author   - Jim Narramore                                        */\n/*            jim.narramore@bankofamerica.com                      */\n/*            narramor@swbell.net                                  */\n/*                                                                 */\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n  Arg parm\n  sysicmd = sysvar('SYSICMD')\n  x = outtrap('DUMMY',1)\n  \"ISPEXEC CONTROL ERRORS RETURN\"\n  \"ISREDIT MACRO\"\n  If rc <> 0 Then Signal notmacro\n  \"ISPEXEC VGET   SRCHPARM SHARED\"\n  \"ISPEXEC VERASE SRCHPARM SHARED\"\n  If word(srchparm,1) =  \"INIT\"   Then Signal initprof\n  If srchparm         <> \"\"       Then Signal showfound\n/* SRCHRPT * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n/* \"Report-scrape\" Search-For Report to obtain date and time       */\n/* search was run, statistics generated by search and members in   */\n/* which search string(s) were found.                              */\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\nsrchrpt:\n  \"ISREDIT (LINE1) = LINE .ZF\"\n  If rc <> 0 Then Signal badparm\n  Parse Var line1 . . . . . . . . . . rptdate rpttime .\n  rpttime = translate(rpttime,':','.')\n  If length(rptdate) <> 10 Then Signal badparm\n  \"ISREDIT SEEK 'SRCH DSN:' 45 FIRST\"\n  If rc <> 0 Then Exit\n  \"ISREDIT SEEK '   CONCAT#(' 9 FIRST\"\n  If rc = 0 Then Exit\n  \"ISREDIT (CURLINE) = LINE .ZCSR\"\n  libname = word(curline,6)\n  \"ISREDIT SEEK 'LINES-FOUND  LINES-PROC' 2 FIRST\"\n  If rc <> 0 Then Exit\n  \"ISREDIT (HDGLINE) = LINE .ZCSR\"\n  hdgline = \"Lines!found Lines!processed Members!with!lines\",\n            \"Members!without!lines\"\n  \"ISREDIT SEEK p'=' 1 NEXT\"\n  \"ISREDIT (CNTLINE) = LINE .ZCSR\"\n  cntlm = \"\"\n  Do w = 1 to 4\n      curhdg = left(word(hdgline,w)\":\",22)\n      curcnt = right(word(cntline,w),8)\n      cntlm = cntlm\"\"left(curhdg curcnt,80)\n  End\n  If rc <> 0 Then Exit\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n/* Build member selection list from member names found in report   */\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n  \"ISREDIT SEEK '- STRING(S) FOUND -' 39 FIRST\"\n  If rc <> 0 Then Exit\n  \"ISREDIT (CURLINE) = LINE .ZCSR\"\n  curmem  = word(curline,1)\n  \"ISPEXEC LMINIT DATAID(LIBID) DATASET('\"libname\"')\",\n          \"ENQ(SHRW)  ORG(LIBORG)\"\n  \"ISPEXEC LMOPEN DATAID(\"libid\") OPTION(INPUT) LRECL(LIBRECL)\",\n          \"RECFM(LIBRECFM) ORG(LIBORG)\"\n  If rc <> 0 Then Exit\n  zlmpd = \"_\"\n  \"ISPEXEC VPUT ZLMPD PROFILE\"\n  \"ISPEXEC CONTROL NONDISPL END\"\n  \"ISPEXEC LMMDISP DATAID(\"libid\")  OPTION(DISPLAY)  MEMBER(\"curmem\")\",\n            \"STATS(YES) COMMANDS(ANY) FIELD(1)\"\n  \"ISREDIT SEEK '- STRING(S) FOUND -' 39 NEXT\"\n  Do While rc = 0\n      \"ISREDIT (CURLINE) = LINE .ZCSR\"\n      curmem  = word(curline,1)\n      \"ISPEXEC LMMDISP DATAID(\"libid\")  OPTION(ADD) MEMBER(\"curmem\")\"\n      \"ISREDIT SEEK '- STRING(S) FOUND -' 39 NEXT\"\n  End\n  zerrlm   = left(libname \"Search Results\",80),\n             left('04'x '   as of' rptdate rpttime,80),\n             translate(cntlm,' ','!')\n  zerrsm   = \"\"\n  zerrhm   = \"*\"\n  zerralrm = \"NO\"\n  \"ISPEXEC SETMSG MSG(ISRZ002)\"\n  lastlcmd = \"E\"\n/* DISPLAY * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n/* Display member selection list until 'END' or 'RETURN' requested */\n/* Primary commands:                                               */\n/*  '?' - View original Search-For report.                         */\n/* Member line commands:                                           */\n/*  'S' - Edit, excluding all lines but those with found strings   */\n/*  'E' - Edit                                                     */\n/*  'V' - View                                                     */\n/*  'E' - Browse                                                   */\n/*  '=' - Execute last line command specified                      */\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\ndisplay:\n  \"ISPEXEC LMMDISP DATAID(\"libid\")  OPTION(DISPLAY)\"\n  If rc > 0 Then Signal endit\n  Do While rc = 0\n      zlmember = strip(zlmember)\n      If zcmd = \"?\" Then\n          Call showrpt\n      zcmd = \"\"\n      If pos(zllcmd,\"SBEV=\") = 0 Then Signal display\n      \"ISPEXEC VERASE SRCHPARM SHARED\"\n      edmacro = \"\"\n      If zllcmd = \"=\" Then zllcmd  = lastlcmd\n      If zllcmd = \"B\" Then service = \"BROWSE\"\n      If zllcmd = \"E\" Then service = \"EDIT\"\n      If zllcmd = \"V\" Then service = \"VIEW\"\n      If zllcmd = \"S\" Then\n          Do\n              service  = \"EDIT\"\n              edmacro  = \"MACRO(\"sysicmd\")\"\n              srchparm = getlist(zlmember)\n              fndcnt   = words(lnumlist)\n              zerrsm   = fndcnt \"Lines Found\"\n              zerrlm   = fndcnt \"lines were found in\",\n                         libname\"(\"zlmember\") that meet the\",\n                         \"search criteria specified for the\",\n                         \"Search-For Utility on \"rptdate\" at \"rpttime\".\"\n              zerrhm   = \"*\"\n              zerralrm = \"NO\"\n              \"ISPEXEC SETMSG MSG(ISRZ002)\"\n              \"ISPEXEC VPUT SRCHPARM SHARED\"\n          End\n      lastlcmd = zllcmd\n      \"ISPEXEC LMINIT DATAID(EDITID) DATASET('\"libname\"')\",\n              \"ENQ(SHRW)  ORG(LIBORG)\"\n      \"ISPEXEC \"service\" DATAID(\"editid\") MEMBER(\"zlmember\")\" edmacro\n      \"ISPEXEC LMFREE DATAID(\"editid\")\"\n      \"ISPEXEC LMMDISP DATAID(\"libid\")  OPTION(GET)\"\n  End\n  Signal display\n/* SHOWRPT * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n/* Display original Search-For report under VIEW                   */\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\nshowrpt:\n  \"ISREDIT (DATASET) = DATASET\"\n  \"ISPEXEC LMINIT DATAID(RPTID) DATASET('\"dataset\"') ENQ(SHR)\"\n  \"ISPEXEC VIEW DATAID(\"rptid\") MACRO(RESET)\"\n  \"ISPEXEC LMFREE DATAID(\"rptid\")\"\n  Return\n/* GETLIST * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n/* Return list of line numbers containing string(s) searched for   */\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\ngetlist:\n  Arg curmem\n  lnumlist = \"\"\n  \"ISREDIT SEEK ' \"curmem\" ' 2 FIRST\"\n  If rc <> 0 Then Return lnumlist\n  Address isredit\n  \"SEEK P'=' 1 NEXT\"\n  \"LABEL .ZCSR = .LISTF\"\n  \"LABEL .ZL   = .LISTL\"\n  \"SEEK '- STRING(S) FOUND -' 39 NEXT\"\n  If rc = 0 Then\n      Do\n          \"SEEK P'=' 1 PREV\"\n          \"SEEK P'=' 1 PREV\"\n          \"LABEL .ZCSR = .LISTL\"\n      End\n  \"SEEK p'# ' 8 FIRST .LISTF .LISTL\"\n  Do While rc = 0\n      \"(CURLINE) = LINE .ZCSR\"\n      curlnum = word(curline,1)\n      lnumlist = lnumlist curlnum\n      \"SEEK p'#  ' 8 NEXT .LISTF .LISTL\"\n  End\n  Address tso\n  Return lnumlist\n/* SHOWFOUND * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n/* Exclude from display all lines in Edit session except those     */\n/* line numbers returned by the GETLIST function                   */\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\nshowfound:\n  \"ISREDIT RESET\"\n  \"ISREDIT EXCLUDE ALL .ZF .ZL\"\n  Do f = 1 to words(srchparm)\n      curnum = word(srchparm,f)\n      If datatype(curnum) <> 'NUM' Then Signal badparm\n      \"ISREDIT RESET EXCLUDED\" curnum curnum\n  End\n  \"ISREDIT SEEK p'=' NX FIRST\"\n  \"ISREDIT CURSOR = .ZCSR 0\"\n  Exit 1\n/* NOTMACRO  * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n/* Allow user to turn SRCHLIST feature ON or OFF plus specify      */\n/* a target LLQ other than '@', if desired                         */\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\nnotmacro:\n  If parm = \"\" Then parm = \"ON\"\n  If words(parm) > 2 Then Signal badparm\n  llq = \"@\"\n  switch = \"ON\"\n  Do p = 1 to words(parm)\n      curparm = word(parm,p)\n      If length(curparm) > 8 Then Signal badparm\n      If curparm = \"ON\"  Then switch = \"ON\"\n      Else If curparm = \"OFF\" Then switch = \"OFF\"\n           Else llq = curparm\n  End\n  tmpdd    = \"@@@\"time('S')\n  syspref  = sysvar(\"SYSPREF\")\n  If syspref = '' Then syspref = userid()\n  tmpdsn   = syspref\".\"tmpdd\".\"llq\n  \"DELETE '\"tmpdsn\"'\"\n  \"ALLOC F(\"tmpdd\") DA('\"tmpdsn\"') NEW DELETE REUSE\",\n  \"SPACE(1) TRACKS RECFM(F B) LRECL(133) BLKSIZE(1330) DSORG(PS)\"\n  If rc <> 0 Then Signal badparm\n  \"ISPEXEC LMINIT DATAID(TEMPID) DDNAME(\"tmpdd\") ENQ(SHRW)\"\n  srchparm = \"INIT\" switch\n  \"ISPEXEC VPUT   SRCHPARM SHARED\"\n  \"ISPEXEC EDIT   DATAID(\"tempid\") MACRO(\"sysicmd\")\"\n  \"ISPEXEC VERASE SRCHPARM SHARED\"\n  \"ISPEXEC LMFREE DATAID(\"tempid\")\"\n  \"FREE  F(\"tmpdd\")\"\n  swdisp = \"now\"\n  If switch = \"OFF\" Then swdisp = \"no longer\"\n  zerrlm = \"The Search-For Utility (ISPF 3.14) will \"swdisp,\n          \"display a member selection list of search results whenever\",\n          \"the Low Level Qualifier (LLQ) of the Listing Data Set\",\n          \"name specified is '\"llq\"'\"\n  zerralrm = \"YES\"\n  zerrhm = \"*\"\n  zerrsm = \"\"\n  \"ISPEXEC SETMSG MSG(ISRZ002)\"\n  Exit\n/* INITPROF  * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n/* Force initial edit macro for target LLQ to 'SRCHLIST' if 'ON'   */\n/* is requested, otherwise set initial edit macro to 'NONE'        */\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\ninitprof:\n  imacro = sysicmd\n  If word(srchparm,2) = \"OFF\" Then imacro = \"NONE\"\n  \"ISREDIT PROFILE UNLOCK\"\n  \"ISREDIT IMACRO = \"imacro\n  \"ISREDIT PROFILE LOCK\"\n  \"ISREDIT CANCEL\"\n  Exit\n/* BADPARM * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n/* Format variables for ISRZ002 message and display to user        */\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\nbadparm:\n  zerrlm = \"'\"parm\"' is an invalid parm for \"sysicmd,\n          copies(' ',80),\n          \"Valid \"sysicmd\" parms are:\",\n          copies(' ',80),\n          \"ON or OFF - turn the facility ON or OFF\",\n          copies(' ',80),\n          \"llq       - valid dataset name low level qualifier for\",\n          \"Listing Data Set\"\n  zerralrm = \"YES\"\n  zerrhm = \"*\"\n  zerrsm = \"\"\n  \"ISPEXEC SETMSG MSG(ISRZ002)\"\n  Exit\n/* ENDIT * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n/* Terminate Search-For report data id and Cancel Edit session     */\n/* of Search-For report                                            */\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\nendit:\n  \"ISPEXEC LMCLOSE DATAID(\"libid\")\"\n  \"ISPEXEC LMFREE DATAID(\"libid\")\"\n  \"ISREDIT CANCEL\"\n  Exit\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "STEMVAR": {"ttr": 4869, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x04\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00\\x0f\\x00\\x0f\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:04", "lines": 15, "newlines": 15, "modlines": 0, "user": "KANNAN"}, "text": "/* rexx */\na.0 = 3\na.1 = 'stem'\na.2 = a.1\na.3 = a.1\nb = 'var'\ncall sub\nexit\n\nsub : procedure expose a. b\nif datatype(a.0) = \"NUM\" then say 'arg a is stem- contains item(s)' a.0\nelse say 'arg a is var'\nif datatype(b.0) = \"NUM\" then say 'arg a is stem- contains item(s)' b.0\nelse say 'arg b is var'\nreturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SUBSYS": {"ttr": 4871, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x04\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00I\\x00I\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:04", "lines": 73, "newlines": 73, "modlines": 0, "user": "KANNAN"}, "text": "/* REXX                                                              */\n/*   THIS REXX REPORTS ALL SUBSYSTEMS KNOWN TO MVS AT THE TIME       */\n/*   IT IS RUN AND THE ACTIVE FUNCTIONS FOR EACH ONE.                */\n/*                                                                   */\n/*********************************************************************/\nPARSE UPPER ARG A1 A2                    /* LOOK FOR POSSIBLE PARM   */\nDEBUG = 'X'                              /* MAKE DEFAULTS 'X'        */\nTRACE = 'X'\nIF LENGTH(A1) < 1 THEN A1 = 'X'          /* ASSURE NON-NULL ARGS     */\nIF LENGTH(A2) < 1 THEN A2 = 'X'\nIF ABBREV('DEBUG',A1) = 1 | ,            /* CHECK FOR PARTIAL MATCH  */\n   ABBREV('DEBUG',A2) = 1 THEN ,         /* & SET FULL = IF FOUND    */\n     DEBUG = 'DEBUG'\nIF ABBREV('TRACE',A1) = 1 | ,            /* CHECK FOR PARTIAL MATCH  */\n   ABBREV('TRACE',A2) = 1 THEN DO        /* & START TRACE IF FOUND   */\n     ADDRESS 'TSO'\n     TS\nEND\n\n/*********************************************************************/\n/* REXX :       S U B S Y S T E M   S T A T U S                      */\n/* DISPLAY ALL SUBSYSTEM NAMES AND WHICH FUNCTIONS ARE ACTIVE        */\n/*********************************************************************/\n\nNUMERIC DIGITS 10                        /* CHOOSE INT. PRECISION    */\nCVT   = ADDC(0,'10')                     /* POINT TO CVT             */\nIF VALUE(DEBUG) = 'DEBUG' THEN DO        /* IF DEBUG SET, TELL HIM   */\n  SAY 'VALUE FROM MEMORY LOCATION' ,\n    D2X(AD1+X2D(AD2)) 'IS' C2X(STORAGE(D2X(AD1+X2D(AD2)),4))\n  SAY 'CVT IS AT' D2X(CVT)\nEND\nJESCT = ADDC(CVT, '0128' )               /* POINT TO JESCT           */\nIF VALUE(DEBUG) = 'DEBUG' THEN DO        /* IF DEBUG SET REPORT      */\n  SAY 'VALUE FROM MEMORY LOCATION' D2X(AD1+X2D(AD2)) 'IS' ,\n    C2X(STORAGE(D2X(AD1+X2D(AD2)),4))\n  SAY 'JESCT IS AT' D2X(JESCT)\nEND\nSSCT  = ADDC(JESCT, '18' )               /* POINT TO SSCT            */\nIF VALUE(DEBUG) = 'DEBUG' THEN DO        /* REPORT ONLY IF DEBUG SET */\n  SAY 'VALUE FROM MEMORY LOCATION' D2X(AD1+X2D(AD2)) 'IS' ,\n    C2X(STORAGE(D2X(AD1+X2D(AD2)),4))\n  SAY 'SSCT IS AT' D2X(SSCT)\nEND\nDO WHILE ( SSCT > 0 )\n  NM = STORAGE(D2X(SSCT+8),4)\n  SAY 'SUBSYSTEM NAME IS \"'NM'\" HEX =' C2X(NM) /* SHOW NAME AND HEX  */\n  SSVT = ADDC(SSCT,'10')                 /* FIND SSCT ADDRESS        */\n  IF SSVT > 0 THEN DO\n    AL = SSVT + X2D('04')                /* OFFSET 4 = FUNC TABLE    */\n    TB = STORAGE(D2X(AL),255)            /* TABLE ITSELF, 255 BYTES  */\n    DO J = 1 TO 255\n      IF SUBSTR(TB,J,1) \u00ac= '00'X THEN    /* FUNCTION IS ACTIVE       */\n        SAY 'ACTIVE FUNCTION ' J\n    END\n  END\n  ELSE SAY 'NO SSVT'\n  SAY ' '\n  SSCT = ADDC(SSCT,'04')                 /* FIND NEXT SSCT ADDRESS   */\nEND\nEXIT 0\n/* */\n/*********************************************************************/\n/*                                                                   */\n/*     ROUTINE TO RETURN A VALUE FROM STORAGE.  VALUE'S LOCATION IS  */\n/* AT THE ADDRESS SPECIFIED BY THE SUM OF THE TWO ARGUMENTS.  THE    */\n/* FIRST ARGUMENT IS A STANDARD DECIMAL NUMBER.  THE SECOND ONE IS   */\n/* A HEXADECIMAL CONSTANT.                                           */\n/*                                                                   */\n/*********************************************************************/\n/* */\nADDC:ARG AD1, AD2                        /* CALC ADDRESS FUNCTION    */\nRETURN C2D(STORAGE(D2X(AD1+X2D(AD2)),4)) /* AD1 = DEC, AD2 = HEX     */\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SUICIDE": {"ttr": 4874, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x04\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00\\t\\x00\\t\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:04", "lines": 9, "newlines": 9, "modlines": 0, "user": "KANNAN"}, "text": "/* Rexx */\njobname = mvsvar('SYMDEF',JOBNAME)\ntcb      = storage(21c,4)\njscb     = storage(d2x(c2d(tcb)+180),4)\nssib     = storage(d2x(c2d(jscb)+316),4)\njobnum   = storage(d2x(c2d(ssib)+12),8)\nSAY JOBNAME JOBNUM 'CANCELED ITSELF AT' TIME() 'ON' DATE()\nAddress TSO 'CANCEL' jobname'('jobnum')'\nExit 12\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SWID": {"ttr": 4876, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x04\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x004\\x004\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:04", "lines": 52, "newlines": 52, "modlines": 0, "user": "KANNAN"}, "text": "/* Rexx Swid */\n/* .................................................................. */\n/* Author  : Kannan AK                                                */\n/* Swid    : Switch ID and Job Character                              */\n/* Notice  : None                                                     */\n/* Version : Alpha                                                    */\n/* .................................................................. */\naddress ispexec\n\"ISREDIT MACRO NOPROCESS\"\nif RC = 20 then do\n    zedsmsg = \"Not a TSO Command\"\n   \"setmsg msg(isrz000)\";exit\nend\nalpha = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890'\n\"VGET JPOINT PROFILE\"\nif RC > 0 then do\n   JPOINT = 1\n   \"VPUT JPOINT PROFILE\"\nend\n\"isredit (first) = linenum .zf\"\n\"isredit (last)  = linenum .zl\"\n\"isredit (linebuf) = line\" 1\nif substr(linebuf,1,2) \\= \"//\" then do\n    zedsmsg = \"Error identifying JCL\"\n   \"setmsg msg(isrz000)\";exit\nend\n\n   o_jobchar = substr(linebuf,10,1)\n   jobname = substr(linebuf,3,7)\n   n_jobchar  = \"'\"||substr(alpha,jpoint,1)||\"'\";jpoint=jpoint+1\n   if jpoint >= 37 then jpoint = 1\n   \"VPUT JPOINT PROFILE\"\n\n   \"isredit change p'======='\" USERID() \"3 9\"\n   \"isredit change p'='\" n_jobchar \"10\"\n\n   do i = first to last by 1\n     \"isredit (linebuf) = line\" i\n      posnoti = pos('NOTIFY=',linebuf)\n      befnoti = posnoti + 6\n      aftnoti = posnoti + 7\n      if posnoti > 0 then do\n         s1 = substr(linebuf,1,befnoti)\n         s2 = substr(linebuf,aftnoti,7)\n         s3 = substr(linebuf,aftnoti+7)\n         s2 = USERID()\n         newline =  s1||s2||s3\n         \"isredit line\" i \" = \" '(newline)'\n         leave\n      end\n   end\nexit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TBV": {"ttr": 4878, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x04\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00\\x1e\\x00\\x1e\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:04", "lines": 30, "newlines": 30, "modlines": 0, "user": "KANNAN"}, "text": "/* TBV - Invokes ISPF Table View Utility ( REXX ) */\n Trace Off\n Parse Arg tblname tbllib\n Address ISPEXEC \"LIBDEF ISPTLIB DATASET ID(\"tbllib\")\"\n Address ISPEXEC \"TBSTATS\" tblname \"STATUS1(\"sta1\") STATUS2(\"sta2\")\"\n opened_it = 0\n If sta1 = 1 & sta2 = 1 /* on input lib(sta1=1) but not open(sta2=1)*/\n Then do\n Address ISPEXEC \"TBOPEN\" tblname \"NOWRITE\"\n opened_it = 1\n end\nIf ( sta1 > 1 & sta2 = 1 )         /* otherwise unavailable */\n Then do\n Zerrsm = \"Table not found\"\n Zerrlm = \"Table could not be opened? Status:\" sta1 sta2\n Zerralrm = \"YES\"\n Zerrhm = \"*\"\n Address ISPEXEC \"SETMSG MSG(ISRZ002)\"\n Call Ending\n end\n                                  /* call the table viewer */\n Address ISPEXEC ,\n \"SELECT CMD(EX '\"userid()\".hanna.exec(TBVIEW)' '\"tblname\"' EXEC)\"\n If opened_it = 1\n Then Address ISPEXEC \"TBEND\" tblname\n If tbllib = ''\n Then Address ISPEXEC \"LIBDEF ISPTLIB\"\n Ending:\n Address ISPEXEC \"LIBDEF ISPPLIB\"\n Exit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TBVIEW": {"ttr": 4880, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x04\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00n\\x00n\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:04", "lines": 110, "newlines": 110, "modlines": 0, "user": "KANNAN"}, "text": "                      /* Generic ISPF table viewer ( REXX ) */\n Trace Off\n tblname = arg(1)\n/* Address ISPEXEC \"CONTROL ERRORS RETURN\" */\n         /* Phase 1 - query the table, capture variable names */\n Address ISPEXEC \"TBQUERY\" tblname \"KEYS(KEYS) NAMES(NAMES)\",\n \"KEYNUM(KEYNUM) NAMENUM(NAMENUM)\"\n keys  = strip(keys,l,'(')  ; keys  = strip(keys,t,')')\n names = strip(names,l,'(') ; names = strip(names,t,')')\n varnum = keynum + namenum\n allvars = keys names   /* chain keys and names together */\n do col = 1 to varnum /* arrays of column headings, widths*/\n name.col = word(allvars,col)     /* name of the variable */\n hdw.col  = length(name.col)             /* width of name */\n dwid.col = 0                  /* max width of data found */\n end\n     /* Phase 2 - Review the table for data displayed widths --\n        currently fixed to max out at zscreenw-1 (usually 79) */\n Address ISPEXEC \"VGET ZSCREENW\"\n maxwid = zscreenw - 1     /* need one for attribute byte */\n Address ISPEXEC \"TBTOP\" tblname\n tbrc = 0\n do while tbrc = 0\n Address ISPEXEC \"TBSKIP\" tblname\n tbrc = rc\n if tbrc = 0\n then do col = 1 to varnum\n if length(value(name.col)) > dwid.col\n then dwid.col = length(value(name.col))\n end\n end\n     /* Phase 3 - Set reserved width, headings for each\n                     column, and use to build screen widths. */\n maxscr = 1\n              /* total screens required to display all columns */\n modhdrs = '' ; modvars = '' ; mdzvars = ''\n cols_this_screen = 0          /* what's been used so far */\n do col = 1 to varnum\n if dwid.col = 0\n then dwid.col = 1\n if dwid.col > maxwid\n then dwid.col = maxwid\n grtrwid  = max(hdw.col,dwid.col)\n rsvd.col = 1 + grtrwid      /* one space between columns */\n hdng.col = ' ' || center(name.col,grtrwid,'-')\n if cols_this_screen + rsvd.col > zscreenw\n then do    /* starting a new screen for this column */\n modhdr.maxscr = modhdrs     /* save prior screen formats */\n modvar.maxscr = modvars\n mdzvar.maxscr = mdzvars\n modhdrs = '' ; modvars = '' ; mdzvars = ''\n maxscr = maxscr + 1              /* begin a new screen */\n cols_this_screen = 0\n end\n modhdrs = modhdrs || hdng.col\n if col <= keynum        /* these are high intensity */\n then marker = left('@z',dwid.col+1)\n else marker = left('\\z',dwid.col+1)\n modvars = modvars || center(marker, rsvd.col)\n mdzvars = mdzvars name.col\n cols_this_screen = cols_this_screen + rsvd.col\n end\n modhdr.maxscr = modhdrs   /* save the last screen format */\n modvar.maxscr = modvars\n mdzvar.maxscr = mdzvars\n      /* Phase 4 - Display the table using prepared screens. Saves and\n           sets 4 pkfeys to allow left and right scrolling effect. */\n Address ISPEXEC \"VGET (ZPF10 ZPF11 ZPF22 ZPF23) PROFILE\"\n spf10 = zpf10 ; spf11 = zpf11 ; spf22 = zpf22 ; spf23 = zpf23\n zpf10 = 'TLEFT' ; zpf11 = 'TRIGHT'\n zpf22 = 'TLEFT' ; zpf23 = 'TRIGHT'\n Address ISPEXEC \"VPUT (ZPF10 ZPF11 ZPF22 ZPF23) PROFILE\"\n curscrn = 1\n crp = 1\n call load_screen_vars\n viewrc = 0\n do while viewrc < 8\n Address ISPEXEC \"TBTOP\" tblname\n Address ISPEXEC \"TBSKIP\" tblname \"NUMBER(\"crp\")\"\n Address ISPEXEC \"TBDISPL\" tblname \"PANEL(TBVWPNL)\"\n viewrc = rc\n if viewrc < 8\n then do\n crp = ztdtop\n if zcmd = 'TRIGHT'\n then do\n curscrn = curscrn + 1\n if curscrn > maxscr\n then curscrn = 1\n call load_screen_vars\n end\n else if zcmd = 'TLEFT'\n then do\n curscrn = curscrn - 1\n if curscrn = 0\n then curscrn = maxscr\n call load_screen_vars\n end\n end\n end\n zpf10 = spf10 ; zpf11 = spf11 ; zpf22 = spf22 ; zpf23 = spf23\n Address ISPEXEC \"VPUT (ZPF10 ZPF11 ZPF22 ZPF23) PROFILE\"\n Ending:\n Return\n load_screen_vars :\n                 /* moves current screen formats to actives */\n modhdrs = modhdr.curscrn\n modvars = modvar.curscrn\n mdzvars = mdzvar.curscrn\n Return\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TBVWPNL": {"ttr": 4883, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x04\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00\\x13\\x00\\x13\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:04", "lines": 19, "newlines": 19, "modlines": 0, "user": "KANNAN"}, "text": ")attr default(%+_)\n  @ type(output) intens(high) color(red )\n  \\ type(output) intens(high) color(green)\n  ~ type(output) intens(high) just(right) caps(off)\n\n)body width(&zscreenw) expand(//)\n+ISPF Table :\\TBLNAME +/-/\n%Command ==>_ZCM D ~scrnum\n+\n&modhdrs\n)model\n&modvars\n)init\n .zvars = '&mdzvars'\n &pt1 = 'Screen'\n &pt2 = 'of'\n &scrnum  = '&pt1 &curscrn &pt2 &maxscr'\n &ztdmark = '---------- Bottom of Table ----------'\n)end\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TESTBAR": {"ttr": 4885, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x04\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00 \\x00 \\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:04", "lines": 32, "newlines": 32, "modlines": 0, "user": "KANNAN"}, "text": "/* Rexx */\nArg ColorCyl\nAddress Ispexec\nWaitMsg = 'Please wait...'\nPROCIND = '?'||'#'\nBARDYE  = 'TURQ'\nbarpointer = 0\nDo I = 1 To 1000\n      If barpointer > 50 Then Do\n         PROCIND = '?'||'#'\n         barpointer = 0\n         If ColorCyl = 'ON' Then Do\n            Select\n              When BARDYE  = 'YELLOW' Then BARDYE  = 'RED'\n              When BARDYE  = 'RED'    Then BARDYE  = 'BLUE'\n              When BARDYE  = 'BLUE'   Then BARDYE  = 'TURQ'\n              When BARDYE  = 'TURQ'   Then BARDYE  = 'WHITE'\n              When BARDYE  = 'WHITE'  Then BARDYE  = 'PINK'\n              When BARDYE  = 'PINK'   Then BARDYE  = 'YELLOW'\n            End\n         End\n      End\n      Else Do\n         PROCIND = '?'||Copies(' ',barpointer)||'#'\n         barpointer = barpointer + 1\n      End\n      \"Control display lock\"\n      \"Addpop\"\n      \"Display panel(progpnl)\"\n      \"Rempop\"\nEnd\nReturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "THINK": {"ttr": 5121, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x04\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00\\t\\x00\\t\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:04", "lines": 9, "newlines": 9, "modlines": 0, "user": "KANNAN"}, "text": "/* Rexx Think */\nArg TimeExec\nT = SysVar(syscpu)\n    Interpret TimeExec\nT = SysVar(syscpu) - T\nZedsmsg = 'Took' t 'seconds'\nZedlmsg = Word(TimeExec,1) ': Process took' T 'seconds'\n'ISPEXEC Setmsg Msg(Isrz000)'\nReturn\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TIDYUP": {"ttr": 5123, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x04\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00\\x0f\\x00\\x0f\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:04", "lines": 15, "newlines": 15, "modlines": 0, "user": "KANNAN"}, "text": "/* REXX */\nADDRESS ISREDIT\n\"MACRO\"\n\n\"X ISRSUPC ALL\"\n\"X LINE-#  ALL\"\n\"X '  ' 3  ALL\"\n\"X SEARCH-FOR 7 ALL\"\n\"X LINES-FOUND 2 ALL\"\n\"X 'PROCESS OPTIONS' 2 ALL\"\n\"X 'THE FOLLOWING'  2  ALL \"\n\"X SRCHFOR 5 ALL\"\n\"DEL X ALL\"\n\"RESET EXCLUDED\"\nEXIT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TOVIEW": {"ttr": 5125, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x04\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x007\\x007\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:04", "lines": 55, "newlines": 55, "modlines": 0, "user": "KANNAN"}, "text": "/* Rexx ToView                                                        */\n/* .................................................................. */\n/* Author  : Kannan AK                                                */\n/* TOVIEW  : Switch to View/Browse mode while in Edit                 */\n/* Notice  : Use -B for browse and -V for View (default)              */\n/* Version : Alpha                                                    */\n/* .................................................................. */\nParse Source . . Me .\n\"ISREDIT MACRO (OPT) NOPROCESS\"\nIf RC = 20 Then Do\n    ZEDSMSG = 'Not a TSO command'\n    ZEDLMSG = Me 'should be invoked as an Edit/View macro'\n    Address ISPEXEC 'SETMSG MSG(ISRZ000)'\n    Exit 1\nEnd\nUpper OPT\nIf OPT = '-B' Then Service = 'Browse'\nElse               Service = 'View'\n\nAddress ISPEXEC\n   'ISREDIT (openmbr) = MEMBER'\n   'ISREDIT (opendsn) = DATASET'\n   'ISREDIT End'\n\nopenmbr = strip(openmbr)\nopendsn = strip(opendsn)\nIf openmbr = '' Then\n    viewdsn = \"'\"||opendsn||\"'\"\nElse\n    viewdsn = \"'\"||opendsn||'('||openmbr||\")'\"\n\nZCMD = 'END;TSO ISREPDF' viewdsn  Service\n'CONTROL NONDISPL ENTER'\n'DISPLAY PANEL (ISR@PRIM)'\nZEDSMSG = 'Switched to' Service\nZEDLMSG = 'Dataset has been switched to 'Service' mode'\n'SETMSG MSG(ISRZ000)'\nExit 0\n\n\n\n\n\n\n\n\n\n\n/* Address ISPEXEC 'VPUT (ZCMD)'  */\n/* Address TSO 'ISREPDF' viewdsn  Service */\nADDRESS ISPEXEC 'DISPLAY PANEL (ISR@PRIM)'\n   'LMCLOSE DATAID('opendid')'\n   'LMFREE  DATAID('opendid')'\nAddress TSO \"Free Dataset('\"strip(opendsn)\"')\"\nService \"Dataset('\"strip(opendsn)\"(\"strip(openmbr)\")')\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "UCOM": {"ttr": 5127, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x04\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00;\\x00;\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:04", "lines": 59, "newlines": 59, "modlines": 0, "user": "KANNAN"}, "text": "/* REXX UCOM                                                          */\n/* .................................................................. */\n/* Author  : Kannan AK                                                */\n/* UCOM    : To uncomment JCL or COBOL                                */\n/* Notice  : None                                                     */\n/* Version : Alpha                                                    */\n/* .................................................................. */\nADDRESS ISPEXEC\n\"ISREDIT MACRO (OPT) NOPROCESS\"\nIF RC = 20 THEN DO\n    ZEDSMSG = \"NOT A TSO COMMAND\"\n   \"SETMSG MSG(ISRZ000)\";EXIT\nEND\nOPT=STRIP(OPT,B);OPT = TRANSLATE(OPT)\nIF  (OPT \\= 'S' & OPT \\= 'O' & OPT \\= '?')  THEN\n     DO\n          ZEDSMSG = \"TYPE 'UCOM ?' FOR HELP\"\n          \"SETMSG MSG(ISRZ001)\"\n          EXIT\n     END\nIF OPT = '?' THEN DO\n  zerrtp = 'CRITICAL'\n  zerrlm   = ,\n  left(        \"  Uncomment Edit Macro Help                       \",80),\n  left('22'x   \"  Utility        : To uncomment JCL or COBOL      \",80),\n  left('22'x   \"  Syntax         : UCOM S/O/?                     \",80),\n  left('22'x   \"  Line Command   : J for JCL/C for COBOL          \",80),\n  left('22'x   \"  S Shifts lines being commented                  \",80),\n  left('22'x   \"  O Overlays the * inplace 3/7                    \",80)\n  zerrsm   = \"\"\n  zerrhm   = \"*\"\n  zerralrm = \"NO\"\n  \"ISPEXEC SETMSG MSG(ISRZ003)\"\n  EXIT\nEND\n\"ISREDIT PROCESS RANGE C J\"\nIF RC > 0 THEN DO\n      ZEDSMSG = \"IMPROPER LINE COMMAND\"\n      \"SETMSG MSG(ISRZ001)\"\n       EXIT\nEND\n\"ISREDIT (RANG) = RANGE_CMD\"\n\"ISREDIT (FIRST) = LINENUM .ZFRANGE\";\n\"ISREDIT (LAST) = LINENUM .ZLRANGE\" ;\nDO I = FIRST TO LAST BY 1\n     \"ISREDIT (LINEBUF) = LINE\" I\n     IF RANG = 'C' & OPT = 'S' THEN\n        LINEBUF=DELSTR(LINEBUF,7,1)\n     IF RANG = 'C' & OPT = 'O' THEN\n        LINEBUF=OVERLAY(' ',LINEBUF,7,1)\n     IF RANG = 'J' & OPT = 'S' THEN\n        LINEBUF=DELSTR(LINEBUF,3,1)\n     IF RANG = 'J' & OPT = 'O' THEN\n        LINEBUF=OVERLAY(' ',LINEBUF,3,1)\n     \"ISREDIT LINE\" I \" = \" '(LINEBUF)'\nEND\nZEDSMSG = (LAST-FIRST+1) \"LINE(S) UNCOMMENTED\"\n\"SETMSG MSG(ISRZ000)\"\nEXIT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "UCOMSQL": {"ttr": 5129, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x04\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00;\\x00;\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:04", "lines": 59, "newlines": 59, "modlines": 0, "user": "KANNAN"}, "text": "/* REXX UCOMSQL                                                       */\n/* .................................................................. */\n/* Author  : Kannan AK                                                */\n/* UCOMSQL : To uncomment SQL                                         */\n/* Notice  : None                                                     */\n/* Version : Alpha                                                    */\n/* .................................................................. */\nADDRESS ISPEXEC\n\"ISREDIT MACRO (OPT) NOPROCESS\"\nIF RC = 20 THEN DO\n    ZEDSMSG = \"NOT A TSO COMMAND\"\n   \"SETMSG MSG(ISRZ000)\";EXIT\nEND\nOPT=STRIP(OPT,B);OPT = TRANSLATE(OPT)\nIF  (OPT \\= 'S' & OPT \\= 'O' & OPT \\= '?')  THEN\n     DO\n          ZEDSMSG = \"'UCOMSQL ?' FOR HELP\"\n          \"SETMSG MSG(ISRZ001)\"\n          EXIT\n     END\nIF OPT = '?' THEN DO\n  zerrtp = 'CRITICAL'\n  zerrlm   = ,\n  left(        \"  Uncomment Edit Macro Help                       \",80),\n  left('22'x   \"  Utility        : To uncomment SQL               \",80),\n  left('22'x   \"  Syntax         : UCOMSQL S/O/?                  \",80),\n  left('22'x   \"  Line Command   : Q                              \",80),\n  left('22'x   \"  S Shifts lines being commented                  \",80),\n  left('22'x   \"  O Overlays the - inplace 1-3                    \",80)\n  zerrsm   = \"\"\n  zerrhm   = \"*\"\n  zerralrm = \"NO\"\n  \"ISPEXEC SETMSG MSG(ISRZ003)\"\n  EXIT\nEND\n\"ISREDIT PROCESS RANGE Q\"\nIF RC > 0 THEN DO\n      ZEDSMSG = \"IMPROPER LINE COMMAND\"\n      \"SETMSG MSG(ISRZ001)\"\n       EXIT\nEND\n\"ISREDIT (RANG) = RANGE_CMD\"\n\"ISREDIT (FIRST) = LINENUM .ZFRANGE\";\n\"ISREDIT (LAST) = LINENUM .ZLRANGE\" ;\nDO I = FIRST TO LAST BY 1\n     \"ISREDIT (LINEBUF) = LINE\" I\n\n     IF RANG = 'Q' & OPT = 'S' THEN DO\n        LINEBUF=DELSTR(LINEBUF,1,3)\n     END\n     IF RANG = 'Q' & OPT = 'O' THEN DO\n        LINEBUF=OVERLAY('   ',LINEBUF,1,3)\n     END\n\n     \"ISREDIT LINE\" I \" = \" '(LINEBUF)'\nEND\nZEDSMSG = (LAST-FIRST+1) \"LINE(S) UNCOMMENTED\"\n\"SETMSG MSG(ISRZ000)\"\nEXIT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "UNAME": {"ttr": 5131, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x04\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00\\x12\\x00\\x12\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:04", "lines": 18, "newlines": 18, "modlines": 0, "user": "KANNAN"}, "text": "/* Rexx Username                                                      */\n/* Obtain user name from data areas                                   */\nsay get_username()\nexit\n\nget_username:\nascb = storage(224,4)                                      /* psaaold */\nasxb = storage(d2x(c2d(ascb)+108),4)                      /* ascbasxb */\n                     /* this is USERID(), if you don't need it delete */\nasxbuser=strip(storage(d2x(c2d(asxb)+192),8))             /* asxbuser */\n                                                          /*___RACF___*/\nacee=storage(d2x(c2d(asxb)+200),4)                            /* acee */\n                                      /* if you don't need it, delete */\naceegrpn=strip(storage(d2x(c2d(acee)+30),8))              /* aceegrpn */\nunam=storage(d2x(c2d(acee)+100),4)                        /* aceeunam */\nuser_name=strip(storage(d2x(c2d(unam)+1),24))\nreturn user_name\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "USERNAME": {"ttr": 5133, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x04\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00\\x1f\\x00\\x1f\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:04", "lines": 31, "newlines": 31, "modlines": 0, "user": "KANNAN"}, "text": "/* Rexx Username                                                      */\n/* Obtain user name from data area                                    */\n\nascbasxb=d2x(c2d(storage(224,4))+108)\nasxbsenv=d2x(c2d(storage(ascbasxb,4))+200)\naceeunam=d2x(c2d(storage(asxbsenv,4))+100)\nadr=c2x(storage(aceeunam,4))\nname=storage(d2x(c2d(storage(aceeunam,4))+1),c2d(storage(adr,1))-1)\nname=strip(name,\"b\",\" \")\n\nasxb=storage(d2x(c2d(storage(224,4))+108),4)\nasxbuser=strip(storage(d2x(c2d(asxb)+192),8))\nsay asxbuser':'name\n\nexit\n\n\n/* Aliter */\nget_username:\nascb = storage(224,4)                                      /* psaaold */\nasxb = storage(d2x(c2d(ascb)+108),4)                      /* ascbasxb */\n                     /* this is USERID(), if you don't need it delete */\nasxbuser=strip(storage(d2x(c2d(asxb)+192),8))             /* asxbuser */\n                                                          /*___RACF___*/\nacee=storage(d2x(c2d(asxb)+200),4)                            /* acee */\n                                      /* if you don't need it, delete */\naceegrpn=strip(storage(d2x(c2d(acee)+30),8))              /* aceegrpn */\nunam=storage(d2x(c2d(acee)+100),4)                        /* aceeunam */\nuser_name=strip(storage(d2x(c2d(unam)+1),24))\nreturn user_name\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "UTILPNL": {"ttr": 5135, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x04\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00\\x13\\x00\\x13\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:04", "lines": 19, "newlines": 19, "modlines": 0, "user": "KANNAN"}, "text": ")ATTR\n? TYPE(INPUT) INTENS(LOW) JUST(LEFT)\n_ TYPE(INPUT) INTENS(LOW) JUST(LEFT) PAD(' ') COLOR(YELLOW)\n)BODY WINDOW(70,10)\n Command ==>?ZCMD                                         _C\n_UT1\n_UT2\n_UT3\n_UT4\n_UT5\n_UT6\n_UT7\n_UT8\n)PROC\n  &CPOS   = .CSRPOS             /* GET CURSOR OFFSET                  */\n  &CNAME  = .CURSOR             /* GET CURSOR FIELD NAME              */\n  &CSEL   = &ZKEY\n  .CURSOR = ZCMD\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "UTILSTAT": {"ttr": 5137, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x04\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00*\\x00*\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:04", "lines": 42, "newlines": 42, "modlines": 0, "user": "KANNAN"}, "text": "/* REXX                                                               */\n/* .................................................................. */\n/* Author  : Kannan AK                                                */\n/* DISPUTIL: Displays active utilities on SSID                        */\n/* Notice  : None                                                     */\n/* Version : Beta                                                     */\n/* .................................................................. */\n\nSignal On Halt    Name Qui\nSignal On Syntax  Name Qui\nSignal On Error   Name Qui\nSignal On Failure Name Qui\n\nArg Subsys Utilid\nIf SUBSYS = '' Then Signal Qui\nIf UTILID = '' Then Signal Qui\nC = 0\n\nRedo :\nAddress TSO \"$\"\nC = C + 1\nAddress ISPEXEC\nUT. = ''\nX = OUTTRAP('UT.','*','NOCONCAT')\nAddress TSO\nQueue '-DISPLAY UTIL('utilid')'\nQueue 'END'\n\"ISPEXEC SELECT CMD(DSN SYSTEM(\"subsys\")) NEST\"\nUT1 = UT.1\nUT2 = UT.2\nUT3 = UT.3\nUT4 = UT.4\nUT5 = UT.5\nUT6 = UT.6\nX = OUTTRAP(OFF)\nISPEXEC \"Addpop\"\nISPEXEC \"Display Panel(UTILPNL)\";Disprc = RC\nISPEXEC \"Rempop\"\nIF Disprc = 8 Then Signal Qui\nSignal Redo\nQui :\nExit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "VB": {"ttr": 5139, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x05\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00\\x91\\x00\\x91\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:05", "lines": 145, "newlines": 145, "modlines": 0, "user": "KANNAN"}, "text": "/* REXX VB */\nArg Count Dsn\nParms = 'Count('Count')'\n'ISPEXEC CONTROL ERRORS RETURN'\nIf SysDsn(Dsn) \\='OK' then DO\n    ZedSmsg=''\n    'ISPEXEC SETMSG MSG(ISRZ000)'\n    Exit(12)\nEnd\n/**** Create temp file ddnames     ****/\nCall GenDd\n/**** Allocate the VSAM file.      ****/\n'ALLOC F('Vsam') DA('Dsn') SH REU '\n/**** Get the dataset's attributes.****/\nCall GetFileAttr\n/**** Allocate the temp QSAM file. ****/\n'ALLOC F('Flat') NEW CAT REU RECFM('Recfm') LRECL('Lrecl') BLKSIZE(0)',\n    SpaceStr' DSORG(PS)'\nIf Rc \\=0 Then do\n    Say 'ALLOC F('Flat') NEW CAT REU RECFM('Recfm') LRECL('Lrecl') BLKSIZE(0)',\n        SpUnit ' SP('Pri' 'Sec') DSORG(PS)'\n    Exit\nEnd\n/*X=OutTrap(Msgs.) */\n/**** Copy the VSAM to the QSAM.   ****/\n'REPRO IFI('Vsam') OFI('Flat') 'Parms\n/**** Free the VSAM                ****/\n'FREE F('Vsam')'\nZedSmsg=''\nZedLmsg=''\n/**** Browse the QSAM file.        ****/\nCall BrowseDd\n/**** Free the QSAM file.          ****/\n'FREE F('Flat')'\n/**** Adios, amigos...             ****/\nExit\n/**** Create unique file names.    ****/\nGenDd:\nGdd='F'||Time(s)\nFlat='FL'||Time(s)\nVsam='VS'||Time(s)\nReturn\n/**** Invoke ISPF browse service   ****/\nBrowseDd:\nADDRESS ISPEXEC\n'LMINIT DATAID(DAID) DDNAME('Flat') ENQ(SHR)'\n'ISPEXEC BROWSE DATAID('Daid')'\n'LMFREE  DATAID('Daid')'\nADDRESS TSO\nReturn\n/**** Get the LRECL and space      ****/\n/**** attributes for the file.     ****/\n/**** Invoke a listcat and examine ****/\n/**** the output. If non-vsam      ****/\n/**** use the LISTDSI function to  ****/\n/**** get them.                    ****/\nGetFileAttr:\n'ALLOC F('Gdd') NEW DEL REU RECFM(V B) LRECL(129) BLKSIZE(0) TR SP(5)',\n    'DSORG(PS)'\n'LISTCAT ENT('Dsn') ALL OUTFILE('Gdd')'\n/**** Load a stem variable with    ****/\n/**** the output from the listcat. ****/\n'EXECIO * DISKR 'Gdd' (STEM LCDATA. FINIS)'\n'FREE F('Gdd')'\nRecFm='V B'     /* We'll assume variable for VSAM */\nIf Word(LcData.2,1)='0NONVSAM' Then do\n    X=ListDsi(Vsam FILE)\n    If x=0 then do\n        RecFm=SysRecFm\n        lrecfm=Length(RecFm)\n        RecFm=''\n        /****   Split the recfm string up  ****/\n        /****   as FB has to become F B    ****/\n        Do a=1 to lrecfm by +1\n            RecFm=RecFm||subStr(SysRecFm,a,1)||' '\n        End\n        Lrecl=SysLrecl\n        SpUnit=SysUnits\n        Pri=SysPrimary\n        Sec=SysSeconds\n        SpaceStr=SpUnit||' SP('Pri' 'Sec')'\n        /****   If we're going to be over  ****/\n        /****   100 cylinders then let the ****/\n        /****   user know and give an      ****/\n        /****   option to override.        ****/\n        If ((SpUnit='CYLINDER' & (Pri>99 | Sec>99)) |,\n            (SpUnit='TRACK' & (Pri>1485 | Sec>1485))) Then do\n            Say 'Allocation is 'SpaceStr\n            Say 'Enter revised allocation or hit ENTER to accept...'\n            Pull Ans\n            If Ans \\='' Then do\n                SpaceStr=Ans\n            End\n        End\n        Return\n    End\n    Say ListDsi(Vsam FILE)\n    Exit\nEnd\n/**** If VSAM, process the listcat ****/\n/**** output to extract the info...****/\nDo x=3 to LcData.0 by +1\n    If Word(LcData.x,1)='ATTRIBUTES' Then do\n        y=x+1\n        z=x+2\n        OneLine=Translate(LcData.y,' ','-')\n        TwoLine=Translate(LcData.z,' ','-')\n        Lrecl=Word(TwoLine,4)\n        Lrecl=Lrecl+4         /* Add 4 for variable QSAM format. */\n        Iterate\n    End\n    If Word(LcData.x,1)='ALLOCATION' Then do\n        y=x+1\n        z=x+2\n        a=x+3\n        OneLine=Translate(LcData.y,' ','-')\n        TwoLine=Translate(LcData.z,' ','-')\n        TreLine=Translate(LcData.a,' ','-')\n        SpUnit=Word(OneLine,3)\n        Pri=Word(TwoLine,3)\n        Sec=Word(TreLine,3)\n        SpaceStr=SpUnit||' SP('Pri' 'Sec')'\n        /****   If we're going to be over  ****/\n        /****   100 cylinders then let the ****/\n        /****   user know and give an      ****/\n        /****   option to override.        ****/\n        If ((SpUnit='CYLINDER' & (Pri>99 | Sec>99)) |,\n            (SpUnit='TRACK' & (Pri>1485 | Sec>1485))) Then do\n            Say 'Space allocation is in excess of 100 cylinders...'\n            Say 'Allocation is 'SpaceStr\n            Say 'Enter revised allocation or hit ENTER to accept...'\n            Say 'or enter EXIT to cancel command.'\n            Pull Ans\n            If Ans=Exit Then do\n                'FREE F('Vsam')'\n                Exit\n            End\n            If Ans \\='' Then do\n                SpaceStr=Ans\n            End\n        End\n        Leave    /* We're done here... */\n    End\nEnd\nReturn\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "VBKEY": {"ttr": 5143, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x05\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00\\x93\\x00\\x93\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:05", "lines": 147, "newlines": 147, "modlines": 0, "user": "KANNAN"}, "text": "/* REXX VBKEY */\nArg Dsn\nParms = \"FROMKEY('000000005S')\" ||\" Count(5)\"\n/* Parms = 'Count('Count')' */\nsay Parms\n'ISPEXEC CONTROL ERRORS RETURN'\nIf SysDsn(Dsn) \\='OK' then DO\n    ZedSmsg=''\n    'ISPEXEC SETMSG MSG(ISRZ000)'\n    Exit(12)\nEnd\n/**** Create temp file ddnames     ****/\nCall GenDd\n/**** Allocate the VSAM file.      ****/\n'ALLOC F('Vsam') DA('Dsn') SH REU '\n/**** Get the dataset's attributes.****/\nCall GetFileAttr\n/**** Allocate the temp QSAM file. ****/\n'ALLOC F('Flat') NEW CAT REU RECFM('Recfm') LRECL('Lrecl') BLKSIZE(0)',\n    SpaceStr' DSORG(PS)'\nIf Rc \\=0 Then do\n    Say 'ALLOC F('Flat') NEW CAT REU RECFM('Recfm') LRECL('Lrecl') BLKSIZE(0)',\n        SpUnit ' SP('Pri' 'Sec') DSORG(PS)'\n    Exit\nEnd\n/*X=OutTrap(Msgs.) */\n/**** Copy the VSAM to the QSAM.   ****/\n'REPRO IFI('Vsam') OFI('Flat') 'Parms\n/**** Free the VSAM                ****/\n'FREE F('Vsam')'\nZedSmsg=''\nZedLmsg=''\n/**** Browse the QSAM file.        ****/\nCall BrowseDd\n/**** Free the QSAM file.          ****/\n'FREE F('Flat')'\n/**** Adios, amigos...             ****/\nExit\n/**** Create unique file names.    ****/\nGenDd:\nGdd='F'||Time(s)\nFlat='FL'||Time(s)\nVsam='VS'||Time(s)\nReturn\n/**** Invoke ISPF browse service   ****/\nBrowseDd:\nADDRESS ISPEXEC\n'LMINIT DATAID(DAID) DDNAME('Flat') ENQ(SHR)'\n'ISPEXEC BROWSE DATAID('Daid')'\n'LMFREE  DATAID('Daid')'\nADDRESS TSO\nReturn\n/**** Get the LRECL and space      ****/\n/**** attributes for the file.     ****/\n/**** Invoke a listcat and examine ****/\n/**** the output. If non-vsam      ****/\n/**** use the LISTDSI function to  ****/\n/**** get them.                    ****/\nGetFileAttr:\n'ALLOC F('Gdd') NEW DEL REU RECFM(V B) LRECL(129) BLKSIZE(0) TR SP(5)',\n    'DSORG(PS)'\n'LISTCAT ENT('Dsn') ALL OUTFILE('Gdd')'\n/**** Load a stem variable with    ****/\n/**** the output from the listcat. ****/\n'EXECIO * DISKR 'Gdd' (STEM LCDATA. FINIS)'\n'FREE F('Gdd')'\nRecFm='V B'     /* We'll assume variable for VSAM */\nIf Word(LcData.2,1)='0NONVSAM' Then do\n    X=ListDsi(Vsam FILE)\n    If x=0 then do\n        RecFm=SysRecFm\n        lrecfm=Length(RecFm)\n        RecFm=''\n        /****   Split the recfm string up  ****/\n        /****   as FB has to become F B    ****/\n        Do a=1 to lrecfm by +1\n            RecFm=RecFm||subStr(SysRecFm,a,1)||' '\n        End\n        Lrecl=SysLrecl\n        SpUnit=SysUnits\n        Pri=SysPrimary\n        Sec=SysSeconds\n        SpaceStr=SpUnit||' SP('Pri' 'Sec')'\n        /****   If we're going to be over  ****/\n        /****   100 cylinders then let the ****/\n        /****   user know and give an      ****/\n        /****   option to override.        ****/\n        If ((SpUnit='CYLINDER' & (Pri>99 | Sec>99)) |,\n            (SpUnit='TRACK' & (Pri>1485 | Sec>1485))) Then do\n            Say 'Allocation is 'SpaceStr\n            Say 'Enter revised allocation or hit ENTER to accept...'\n            Pull Ans\n            If Ans \\='' Then do\n                SpaceStr=Ans\n            End\n        End\n        Return\n    End\n    Say ListDsi(Vsam FILE)\n    Exit\nEnd\n/**** If VSAM, process the listcat ****/\n/**** output to extract the info...****/\nDo x=3 to LcData.0 by +1\n    If Word(LcData.x,1)='ATTRIBUTES' Then do\n        y=x+1\n        z=x+2\n        OneLine=Translate(LcData.y,' ','-')\n        TwoLine=Translate(LcData.z,' ','-')\n        Lrecl=Word(TwoLine,4)\n        Lrecl=Lrecl+4         /* Add 4 for variable QSAM format. */\n        Iterate\n    End\n    If Word(LcData.x,1)='ALLOCATION' Then do\n        y=x+1\n        z=x+2\n        a=x+3\n        OneLine=Translate(LcData.y,' ','-')\n        TwoLine=Translate(LcData.z,' ','-')\n        TreLine=Translate(LcData.a,' ','-')\n        SpUnit=Word(OneLine,3)\n        Pri=Word(TwoLine,3)\n        Sec=Word(TreLine,3)\n        SpaceStr=SpUnit||' SP('Pri' 'Sec')'\n        /****   If we're going to be over  ****/\n        /****   100 cylinders then let the ****/\n        /****   user know and give an      ****/\n        /****   option to override.        ****/\n        If ((SpUnit='CYLINDER' & (Pri>99 | Sec>99)) |,\n            (SpUnit='TRACK' & (Pri>1485 | Sec>1485))) Then do\n            Say 'Space allocation is in excess of 100 cylinders...'\n            Say 'Allocation is 'SpaceStr\n            Say 'Enter revised allocation or hit ENTER to accept...'\n            Say 'or enter EXIT to cancel command.'\n            Pull Ans\n            If Ans=Exit Then do\n                'FREE F('Vsam')'\n                Exit\n            End\n            If Ans \\='' Then do\n                SpaceStr=Ans\n            End\n        End\n        Leave    /* We're done here... */\n    End\nEnd\nReturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "WAIT": {"ttr": 5380, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x05\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00\\x14\\x00\\x14\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:05", "lines": 20, "newlines": 20, "modlines": 0, "user": "KANNAN"}, "text": "/* REXX */\n   Arg parms\n   exitrc = 0\n   seconds = WORD(parms,1)\n   default_seconds = 15\n   If seconds = '' then seconds = default_seconds\n   If DATATYPE(seconds,\"WHOLE NUMBER\") then\n     seconds = ABS(seconds)\n   Else\n     seconds = default_seconds\n   If SYSCALLS('ON') > 0 then\n     Do\n       Say 'Unable to establish the Unix SYSCALL Environment'\n       exitrc = SYSCALLS('ON')\n       Signal EXIT\n     End\n   Address SYSCALL 'SLEEP ' SECONDS\n   exitrc = rc\n EXIT:\n   Exit exitrc\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "WHOPDS": {"ttr": 5382, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x05\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00\\x19\\x00\\x19\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:05", "lines": 25, "newlines": 25, "modlines": 0, "user": "KANNAN"}, "text": "/* Rexx WhoDSN                 */\n\"ISREDIT MACRO\"\naddress ispexec\n\n'ISREDIT (openpds) = DATAID'\n'ISREDIT (openmbr) = MEMBER'\n'ISREDIT (opendsn) = DATASET'\nopenmbr = strip(openmbr)\nopendsn = strip(opendsn)\n\nif openmbr <> '' then\n   say 'By ISREDIT: 'opendsn'('openmbr') --' openpds\nelse\n   say 'By ISREDIT: 'opendsn '--' openpds\n\n/* Alternate approach */\n'LMQUERY DATAID('openpds') DATASET(DDN) PROJECT(P1) GROUP1(G1) TYPE(TY)'\nP1 = strip(P1);G1 = strip(G1);TY = strip(TY);\n\nif DDN <> '' then\n   say 'By LMQUERY: 'strip(DDN)\nelse\n   say 'By LMQUERY: 'P1'.'G1'.'TY'('OPENMBR')'\n\nreturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "WILDEL": {"ttr": 5384, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x05\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00\\x14\\x00\\x14\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:05", "lines": 20, "newlines": 20, "modlines": 0, "user": "KANNAN"}, "text": "/* Rexx  find which data sets in a dslist contain a member           */\ndta = ptr(76+ptr(ptr(24+ptr(112+ptr(132+ptr(540))))))\ntname=storage(d2x(dta+196),8)\nsay tname\nIf substr(tname,1,3)=\"DSL\" & \"NUM\"=datatype(delstr(tname,1,3)) Then\n  Do\n    Address ispexec\n    \"CONTROL ERRORS RETURN\"\n    \"TBTOP  \"tname\n    \"TBSKIP \"tname\n    Do While rc=0\n      address tso \"delete '\"zudsns\"'\"\n      \"TBSKIP \"tname\n    End\n  End\nElse\n  Say \" The data set list table could not be found \" tname\nReturn\n\nptr:Return c2d(storage(d2x(Arg(1)),4))\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "XCOPY": {"ttr": 5386, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x05\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00v\\x00v\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:05", "lines": 118, "newlines": 118, "modlines": 0, "user": "KANNAN"}, "text": "/* Rexx Xcopy                                                        */\n/* syntax : tso HLQ                                                  */\n/*                                                                   */\narg hlq patt1\nif hlq = '' then do\n   ZEDSMSG = '*Need DSN Level*'\n   \"ISPEXEC SETMSG MSG(ISRZ000)\"\n   exit 1\nend\nlocaluser = userid()\nwjcount = 0\ncn      = 0\naddress ISPEXEC\n\naddress ISPEXEC \"Control Errors Return\"\ncall parse_listcat\ncall build_jobcard\ncall feed_job_details\ncall edit_jcl\n\nqui :\naddress ISPEXEC 'LMFREE DATAID('trap')'\naddress TSO 'FREE F('ddname')'\nexit\n\nbuild_jobcard:\naddress TSO\ncall wj(\"//\"userid()\"$ JOB (000000),'BT:KANNAN AK',                   \")\ncall wj(\"//         CLASS=U,MSGCLASS=X,NOTIFY=&SYSUID,COND=(5,LT)     \")\nreturn\n\nbuild_jcl :\ncn = cn + 1\ntx = translate(format(cn,3,0),'0',' ')\ncall wj(\"//*---------------------------------------------------------*\")\ncall wj(\"//QCOPY\"tx\" EXEC PGM=IDCAMS                                  \")\ncall wj(\"//SYSPRINT DD SYSOUT=*                                       \")\ncall wj(\"//SYSUT1   DD DISP=SHR,DSN=\"fstr\"                            \")\ncall wj(\"//SYSUT2   DD DSN=\"udsname\".VB,                              \")\ncall wj(\"//            DISP=(NEW,CATLG,DELETE),                       \")\ncall wj(\"//            MGMTCLAS=WORK1,                                \")\ncall wj(\"//            SPACE=(CYL,(100,100),RLSE),                    \")\ncall wj(\"//            RECFM=VB,BLKSIZE=0,LRECL=23472                 \")\ncall wj(\"//SYSIN    DD *                                              \")\ncall wj(\"  REPRO INFILE(SYSUT1) OUTFILE(SYSUT2)                       \")\ncall wj(\"/*                                                           \")\nreturn\n\nwj :\nparse arg stream\nqueue stream\nwjcount = wjcount + 1\nreturn\n\nedit_jcl :\nZEDSMSG = '*Verify & submit*'\n\"ISPEXEC SETMSG MSG(ISRZ000)\"\nif queued() > 0 then\ndo\n address ISPEXEC 'VGET (ZSCREEN) SHARED'\n ddname='$MASS$'zscreen\n address TSO\n 'ALLOC F('ddname') UNIT(VIO) DSO(PS) RECFM(F B) LRECL(080) NEW DEL REU'\n 'EXECIO 'queued()' DISKW 'ddname' (FINIS'\n address ISPEXEC 'LMINIT DATAID(TRAP) DDNAME('ddname') ENQ(SHR)'\n address ISPEXEC 'EDIT   DATAID('trap')'\nend\nreturn\n\nparse_listcat :\ntapedsn. = ''\nk = 1\nf = outtrap('out.','*','noconcat')\naddress TSO \"LISTCAT LEVEL ('\"hlq\"') NAME NVSAM\"\nlistrc = RC\nf = outtrap(off)\nif listrc \\= 0 then do\n   do j = 1 to out.0\n      say out.j\n   end\n   exit listrc\nend\ndo i = 1 to out.0\n  if pos(hlq,out.i) <> 0 then\n    if pos(hlq,out.i) > 0 then do\n       parse value out.i with . . dsname\n       if pos(patt1,out.i) > 0 then do\n          tapedsn.k = dsname\n          k = k + 1\n       end\n    end\nend\ntapedsn.0 = k-1\nreturn\n\n\nfeed_job_details :\ndo i = 1 to tapedsn.0\n   fstr = tapedsn.i\n   udsname = localuser || substr(tapedsn.i,8)\n   call change udsname 'TAPES' 'DISK'\n   udsname = target\n   call build_jcl\nend\nreturn\n\nchange : procedure expose target oldstr newstr\narg target oldstr newstr\nif pos(oldstr,target) = 0 then return 'ERROR'\n\nif length(oldstr) >= length(newstr) then\ntarget = space(overlay(newstr,target,pos(oldstr,target),length(oldstr)),0)\n\nif length(oldstr) < length(newstr) then\ntarget = substr(target,1,pos(oldstr,target)-1) || newstr || ,\n         substr(target,pos(oldstr,target)+length(oldstr))\nreturn target\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "YESNOPNL": {"ttr": 5389, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x05\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00\\x0e\\x00\\x0e\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:05", "lines": 14, "newlines": 14, "modlines": 0, "user": "KANNAN"}, "text": ")ATTR\n+ TYPE(TEXT)   INTENS(LOW) COLOR(WHITE)\n_ TYPE(INPUT)  INTENS(LOW) JUST(LEFT)  PAD(' ') CAPS(OFF) COLOR(YELLOW)\n)BODY WINDOW(21,02)\n   _Yes+<< Proceed\n   _No +<< Cancel\n)INIT\n&ZWINTTL= '* Delete? *'\n&Yes    = Yes\n&No     = No\n)PROC\n&ZWINTTL= ''\n&CNAME  = .CURSOR\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ZAPPDS": {"ttr": 5391, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x05\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00)\\x00)\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:05", "lines": 41, "newlines": 41, "modlines": 0, "user": "KANNAN"}, "text": "/* REXX */\n/* Usage  : tso zappds quoted_pdsname opt */\n/* Option QUIET gives not delete messages */\narg dsname opt\nif length(dsname) = 0 then exit\nsay 'Members in this dataset will be deleted 'dsname\nif opt = 'QUIET' then say 'Quiet mode selected'\nelse say 'Verbose mode selected'\nelapsed = time(r)\ndsname = translate(strip(dsname))\n       x = listdsi(dsname directory norecall)\n       if sysdsorg = 'PO' & (sysmembers > 0) then do\n          call del_mem\n       end\n       else do\n          say \"No/Empty/Migrated DSN\"\n       end\n       if rc = 0 then do\n           say \"PDS ZAP Successful\"\n       end\n       else do\n           say \"PDS ZAP Failed\"\n       end\nelapsed = time('e')\nsay 'Process took' elapsed 'seconds.'\nexit\n\ndel_mem :\nsay \"Delete in progress...\"\nsay \" \"\nX = OUTTRAP('MOUT.','*','NOCONCAT')\naddress tso \"LISTDS \"dsname\" MEMBERS\"\nX = OUTTRAP(OFF)\nif opt = 'QUIET' then Y = OUTTRAP('junk.','*','NOCONCAT')\nDO C=7 BY 1 while C <= MOUT.0\n   mmname = \"'\"substr(dsname,2,length(dsname)-2)\"(\"strip(MOUT.C)\")'\"\n   address tso \"DELETE\" mmname\nend\nif opt = 'QUIET' then Y = OUTTRAP(OFF)\ndrop MOUT. junk.\nreturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZAPSHELL": {"ttr": 5393, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x05\\x01\\x033\\x1f\\x01\\x033\\x1f\\x057\\x00\\x12\\x00\\x12\\x00\\x00\\xd2\\xc1\\xd5\\xd5\\xc1\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-27T00:00:00", "modifydate": "2003-11-27T05:37:05", "lines": 18, "newlines": 18, "modlines": 0, "user": "KANNAN"}, "text": "/* Rexx Zapshell                                                      */\n/* .................................................................. */\n/* Author  : Kannan AK                                                */\n/* Zapshell: Clear 'Ten (TSO) Commands' in Shell Panel                */\n/* Notice  : Do not run in ISPF Option 6 itself                       */\n/* Version : Alpha                                                    */\n/* .................................................................. */\nAddress ISPEXEC\n'VERASE (PTCRET01 PTCRET02 PTCRET03 PTCRET04 PTCRET05 ,\n         PTCRET06 PTCRET07 PTCRET08 PTCRET09 PTCRET10) BOTH'\n  If rc \\= 0 Then\n    Do\n      If rc =  8 Then Say 'Atleast one variable not found'\n      If rc = 20 Then Say 'Severe error                  '\n    End\n  Else\n                      Say 'Variables cleared             '\nExit 0\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT656/FILE656.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT656", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}