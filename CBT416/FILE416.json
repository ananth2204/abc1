{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220011957000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 411502, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 6, "INMDSNAM": "CBT.V500.FILE416.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 411502, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 411502, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE416.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x08\\x05'", "DS1TRBAL": "b'\\x8a\\x86'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x03\\x04\\x00\\x0e\\x03\\x05\\x00\\x07\\x00\\t'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$$DISC": {"ttr": 516, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "                *************************\n                *                       *\n                *  D I S C L A I M E R  *\n                *                       *\n                *************************\n\n\n     THE MODIFICATONS, ROUTINES, PANELS, CLISTS, AND OTHER DATA ON THIS\n TAPE HAVE BEEN USED SUCCESSFULLY AND TO THE BEST OF OUR KNOWLEDGE THEY\n ARE OPERATIONAL, HOWEVER NO WARRANTY IS MADE TO THE ACCURACY OF THE\n PROGRAMS AND RELATED MATERIAL AND NO RESPONSIBILTY IS ASSUMED FOR ANY\n MODIFICATIONS DIRECTLY OR INDIRECTLY CAUSED BY THEIR USE.  IT IS THE\n USERS RESPONSIBILITY TO EVALUATE THE USEFULNESS OF THE MATERIAL\n SUPPLIED.\n\n     WE DO NOT GUARANTEE TO KEEP ANY MATERIAL PROVIDED UP TO DATE NOR\n DO WE GUARANTEE TO PROVIDE ANY CORRECTIONS OR EXTENSIONS DESCRIBED\n BY THE USER OR CORRECTIONS OR EXTENSIONS MADE IN THE FUTURE.\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$INDEX": {"ttr": 518, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "THIS PDS CONTAINS THE FOLLOWING PROGRAMS:\n\nCATLIST   -  THIS PROGRAM WILL DO A VERY FAST LISTING OF AN ICF CATALOG\n             FOR GENERATIONDATASETS AND NONVSAM DATASETS.  THE LISTING\n             IS IN THE SAME FORMAT AS IDCAMS (WE USED IT TO BUILD A TMC)\n             BUT THE OUTPUT FORMAT WOULD BE EASY TO CHANGE.  THE PROGRAM\n             MUST RUN AUTHORIZED (AC=1) BECAUSE IT OPENS THE CATALOG AS\n             A DATASET.  ALSO THERE IS A MODESET WE USED TO ALLOW US TO\n             BYPASS RACF CHECKING. (RACF THINKS YOU NEED ALTER ACCESS TO\n             READ THE DATASET AND ALL OF OUR CATALOGS HAVE A UACC OF\n             UPDATE). ALL THAT WAS DONE IN KEY ZERO WAS TO SET THE\n             JSCBPASS BIT ON.  THE SPEED INCREASE OF THIS PROGRAM WAS\n             SEVERAL ORDERS OF MAGNITUDE BETTER THAN IDCAMS ON A LARGE\n             ICF CATALOG.\n\nCMDLOFF   -  THIS COMMAND WILL ISSUE THE COMMAND PASSED TO IT AND\n             THEN CAUSE LOGOFF OF THE USER.  THIS IS USEFUL IN THE\n             SITUATION WHERE YOU WANT A USER TO EXIST IN A PROTECTED\n             ENVIRONMENT. EX. CMDLOFF ISPSTART PANEL(USERSEL)\n\nDLXAUTHC  -  THIS COMMAND WILL ISSUE THE COMMAND PASSED TO AFTER\n             SETTING THE JSCBAUTH BIT ON. WHEN THE COMMAND COMPLETES\n             THE JSCBAUTH BIT WILL BE SET OFF. THE JSCB TAMPERING IS\n             DONE IN A USER SVC. YOU MUST REPLACE THE USERSVC MACRO\n             WITH YOUR OWN INTEGRITY VIOLATION. THIS COMMAND IS\n             ESPECIALLY USEFUL FOR ENTERING RACF COMMANDS FROM\n             ISPF DIALOGS.  EX. DLXAUTHC LISTDSD DA('DSN1.EXAMPLE') ALL\n\nEXIMPORT     DESCRIPTIVE NAME = GENERATE THE JCL NECESSARY FOR\n             EXPORTING AND IMPORTING THE DATA SETS ON A\n             SPECIFIED VOLUME.\n             CREATES ONE DATA SET WITH THE JCL FOR EXPORTING\n             THE DATA SETS ON A SPECIFIED VOLUME AND ANOTHER\n             FOR IMPORTING THE SAME DATA SETS.  FOR VSAM\n             FILES, THE JCL WILL BE SET UP TO EXECUTE\n             IDCAMS, EXPORTING TO TAPE AND THEN IMPORTING\n             BACK ONTO THE SAME VOLUME FROM THE TAPE.\n             FOR NON-VSAM PS FILES, THE PROGRAM IEBGENER IS\n             EXECUTED TO COPY THE DATA SET TO TAPE AND THEN\n             BACK TO THE SAME VOLUME.  FOR PO FILES, IEBCOPY\n             IS USED.  ALSO A CLIST IS GENERATED TO SCRATCH\n             THE TAPE FILES AFTER THE DATA SETS HAVE BEEN\n             IMPORTED.\n\nIGGPRE00     DF/DS ALLOCATE PRE PROCCESSING EXIT TESTER'\n\nINMRZ01      RECEIVE INITIALIZATION EXIT\n             ALLOWS AUTHORIZATION CHECKING FOR USER\n             IDS EXECUTING RECEIVE IN BACKGROUND.\n\nINMRZ11      RECEIVE PRE-PROCESSING EXIT\n             ALLOWS RECEIVE TO RUN IN BACKGROUND WITH\n             THE  EXIT REPLACING THE USER INTERACTION IN\n             DETERMINING THE RECEIVING DATA SET NAME.\n\nRACFALT   -  THIS PROGRAM WILL GENERATE A CLIST TO CHANGE THE VOLUME\n             SERIAL NUMBERS IN THE RACF PROFILES OF ALL NONVSAM DATASETS\n             ON A SPECIFIED VOLUME.\n\nRACFCLST  -  THIS PROGRAM WILL GENERATE A CLIST TO REDEFINE (VIA RACF\n             COMMANDS DELDSD, ADDSD, AND PERMIT) FOR ALL DATASETS ON A\n             SPECIFIED VOLUME. DUE TO USE OF RACF INTERNAL MACROS THIS\n             PROGRAM MUST BE RUN AUTHORIZED. IF SYSIN IS PRESENT YOU\n             CAN INCLUDE COMMANDS TO SELECT BY DATASET GROUP ON A VOLUME\n             AND/OR DATASET NAME WITH OR WITHOUT VOLUME SPECIFICATION.\n             WARNING: IF SYSIN IS PRESENT AND DUMMIED OUT OR EMPTY THEN\n             A NULL CLIST WILL BE CREATED.\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CATLIST": {"ttr": 520, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         TITLE 'CATLIST'\nCATLIST CSECT\n         SAVE  (14,12),,CATLIST_&SYSDATE_&SYSTIME\n         LR    R12,R15                  ESTABLISH R12 AS BASE REG\n         USING CATLIST,R12              TELL ASSEMBLER\n         ST    R13,SAVEAREA+4           SAVE OS SAVE AREA ADDRESS\n         LR    R6,R13                   SAVE IT IN R6\n         LA    R13,SAVEAREA             POINT R13 AT OUR SAVE AREA\n         ST    R13,8(R6)                STORE OUR SAVEAREA ADDR IN OS\nGETDATE  EQU   *\n         TIME  DEC                      GET THE TIME AND DATE\n         SRL   R0,4                     R0 = 0HHMMSST\n         ST    R0,WORK                  WORK = 0HHMMSST\n         OI    WORK+3,X'0F'             WORK = 0HHMMSSF\n         ED    TIME,WORK                TIME = HH:MM:SS\n         MVC   TIME,TIME+1\n         ST    R1,WORK                  WORK = 00YYDDDF\n         XC    WORK(2),WORK             WORK = 0000DDDF\n         SRL   R1,12                    R1 = 00000YYD\n         ST    R1,DWORK+4               DWORK+4 = 00000YYD\n         OI    DWORK+7,X'0F'            DWORK+4 = 00000YYF\n         UNPK  YY,DWORK+6(2)            STORE THE YEAR\n         CVB   R1,DWORK                 CONVERT THE YEAR TO BINARY\n         N     R1,=F'3'                 LEAP YEAR?\n         BNZ   GT10                     IF NOT, BRANCH\n         AP    DAYSYEAR,=P'1'           INCREASE DAYS IN A YEAR\n         AP    MONTH-1,=P'1'            ADD A DAY TO FEBRUARY\nGT10     EQU   *\n         LA    R1,MONTH                 POINT TO JANUARY\nGT20     EQU   *\n         SP    WORK,0(1,R1)             SUBTRACT DAYS IN THE MONTH\n         SP    WORK,=P'30'\n         BNP   GT30                     WHEN NEGATIVE, BRANCH OUT\n         BCTR  R1,0                     GO BACKWARDS THRU TABLE\n         AP    COUNT,=P'1'              COUNT THE MONTHS\n         B     GT20                     AND LOOP\nGT30     EQU   *\n         AP    WORK,0(1,R1)             ADD LAST MONTH BACK IN\n         AP    WORK,=P'30'\n         OI    COUNT+L'COUNT-1,X'0F'    COUNT = 0MMF\n         UNPK  MM,COUNT                 STORE THE MONTH\n         OI    WORK+3,X'0F'\n         UNPK  DD,WORK                  STORE THE DAY\nOPENIT   EQU   *\n         MODESET KEY=ZERO,MODE=SUP\n         L     R3,540\n         LA    R3,0(R3)\n         L     R4,180(R3)\n         OI    243(R4),X'80'\n         MODESET KEY=NZERO,MODE=PROB\n         OPEN  GETACB                   OPEN THE CATALOG\n         LTR   R15,R15\n         BNZ   ERROR01\n         LA    R2,GETACB                GET ADDRESS TO ACB\n         USING IFGACB,R2                ESTABLISH ADDRESSABILITY\n         L     R3,ACBAMBL               GET ADDRESS TO AMBL\n         L     R4,52(R3)                GET ADDRESS TO AMB\n         MVC   CATNAME,136(R4)          GET THE ACTUAL CATALOG NAME\n         DROP  R2\n         OPEN  (OUTFILE,OUTPUT)         OPEN THE OUTPUT FILE\n         LTR   R15,R15\n         BNZ   ERROR02\nGETLOOP  EQU   *\n         GET   RPL=GETRPL               READ A CATALOG RECORD\n         LTR   R15,R15\n         BNZ   ERROR03\n         L     R7,RECADDR               GET RECORD ADDRESS\n         LA    R7,2(R7)                 SKIP OVER RECORD LENGTH\n         CLI   2(R7),C'A'               NON-VSAM DATA SET?\n         BE    NONVSAM                  IF SO, PROCESS FOR NON-VSAM\n         CLI   2(R7),C'B'               GDG DATA SET?\n         BE    GDG                      IF SO, PROCESS FOR GDG\n         B     GETLOOP                  IF NEITHER, GO BACK FOR ANOTHER\n*\nNONVSAM  EQU   *\n         MVI   TYPE,C'0'                SET FLAG FOR NON-VSAM\n         MVC   DSNAME,7(R7)             STORE DATA SET NAME\n         MVC   LINE7,LINE7A             STORE NON-VSAM ASSOCIATIONS\n         SLR   R2,R2\n         ICM   R2,B'0011',4(R7)         GET # OF VOLUME CELLS\n         B     BOTH                     BRANCH TO COMMON SECTION\n*\nGDG      EQU   *\n         MVI   TYPE,C'1'                SET FLAG FOR GDG\n         MVC   GDGNAME,7(R7)            STORE GDG NAME\n         MVC   DSNAME,7(R7)             GET DATA SET NAME\n         LA    R4,DSNAME                POINT TO BEGINNING OF DSNAME\nGD10     EQU   *\n         CLI   0(R4),X'40'              LOOK FOR FIRST BLANK\n         BE    GD20                     WHEN FOUND, STOP\n         LA    R4,1(R4)                 GO TO NEXT CHARACTER\n         B     GD10\nGD20     EQU   *\n         MVC   0(2,R4),=C'.G'           GET READY TO ADD GEN# & VER#\n         SLR   R9,R9\n         ICM   R9,B'0011',0(R7)         GET RECORD LENGTH\n         AR    R7,R9                    GO TO NEXT RECORD\n         ICM   R9,B'0011',0(R7)         GET RECORD LENGTH\n         AR    R7,R9                    GO TO NEXT RECORD\n         SLR   R6,R6\n         ICM   R6,B'0001',5(R7)\n         ICM   R9,B'0011',0(R7)         GET RECORD LENGTH\n         AR    R7,R9                    GO TO NEXT RECORD\nGD30     EQU   *\n         CLI   2(R7),C'H'               DATA SET NAME CELL?\n         BNE   GD50                     IF NOT, END LOOP\n         ICM   R9,B'0011',5(R7)         GET GENERATION NUMBER\n         CVD   R9,DWORK                 CONVERT TO PACKED DECIMAL\n         UNPK  DECNUM,DWORK             UNPACK\n         MVZ   DECNUM+7(1),DECNUM+6     MOVE ZONE BYTE\n         MVC   2(4,R4),DECNUM+4         MOVE INTO DATA SET NAME\n         MVI   6(R4),C'V'               GET READY TO ADD VER#\n         SLR   R9,R9\n         ICM   R9,B'0001',7(R7)         GET VERSION NUMBER\n         CVD   R9,DWORK                 CONVERT TO PACKED DECIMAL\n         UNPK  DECNUM,DWORK             UNPACK\n         MVZ   DECNUM+7(1),DECNUM+6     MOVE ZONE BYTE\n         MVC   7(2,R4),DECNUM+6         MOVE INTO DATA SET NAME\n         SLR   R2,R2\n         ICM   R2,B'0011',8(R7)         SAVE # OF VOLUME CELLS\n         MVC   LINE7,LINE7B             STORE GDG ASSOCIATIONS\n         ST    R4,SAVEPTR               SAVE R4 FOR LATER\n         B     BOTH\nGD40     EQU   *\n         L     R4,SAVEPTR               GET R4 BACK\n         BCT   R6,GD30                  LOOP TIL ALL GDG'S DONE\nGD50     EQU   *\n         B     GETLOOP\n*\nBOTH     EQU   *\n         MVC   LINE(L'LINE1),LINE1      SET UP FIRST LINE\n         MVI   CNTL,C'0'                SET CONTROL TO SPACE 2 LINES\n         BAL   R10,PRINT                OUTPUT THE LINE\n         MVC   LINE+5(L'LINE2),LINE2    SET UP SECOND LINE\n         BAL   R10,PRINT                OUTPUT THE LINE\n         SLR   R9,R9\n         ICM   R9,B'0011',0(R7)         GET RECORD LENGTH\n         AR    R7,R9                    GO TO NEXT RECORD\n         MVC   LINE+7(L'LINE3A),LINE3A  START THIRD LINE\n         CLC   3(8,R7),NULLCHK          ANYTHING IN OWNER-IDENT?\n         BE    B10                      IF NOT, SKIP IT\n         MVC   LINE+23(8),3(R7)         ADD OWNER-IDENT\nB10      EQU   *\n         MVC   LINE+36(L'LINE3B),LINE3B ADD TO THIRD LINE\n         UNPK  DATE,12(3,R7)            UNPACK CREATION DATE\n         MVZ   DATE+4(1),DATE+3         MOVE ZONE BYTE\n         MVC   LINE+54(2),DATE          STORE THE YEAR\n         MVI   LINE+56,C'.'             INSERT PERIOD\n         MVC   LINE+57(3),DATE+2        ADD DAY\n         BAL   R10,PRINT                OUTPUT THE LINE\n         MVC   LINE+7(L'LINE4A),LINE4A  START FOURTH LINE\n         MVC   LINE+36(L'LINE4B),LINE4B ADD TO FOURTH LINE\n         UNPK  DATE,15(3,R7)            UNPACK EXPIRATION DATE\n         MVZ   DATE+4(1),DATE+3         MOVE ZONE BYTE\n         MVC   LINE+54(2),DATE          STORE THE YEAR\n         MVI   LINE+56,C'.'             INSERT PERIOD\n         MVC   LINE+57(3),DATE+2        ADD DAY\n         BAL   R10,PRINT                OUTPUT THE LINE\n         MVC   LINE+5(L'LINE5),LINE5    SET UP THE FIFTH LINE\n         BAL   R10,PRINT                OUTPUT THE LINE\n         SLR   R9,R9\n         ICM   R9,B'0011',0(R7)         GET RECORD LENGTH\n         AR    R7,R9                    GO TO NEXT RECORD\n         CLI   2(R7),X'04'              VOLUME RECORD?\n         BE    B20                      IF SO, BRANCH\n         ICM   R9,B'0011',0(R7)         GET RECORD LENGTH\n         AR    R7,R9                    GO TO NEXT RECORD\nB20      EQU   *\n         MVC   LINE+7(L'LINE6A),LINE6A  START THE SIXTH LINE\n         MVC   LINE+25(6),4(R7)         GET VOLUME SERIAL NUMBER\n         MVC   LINE+36(L'LINE6B),LINE6B ADD TO SIXTH LINE\n         LA    R8,LINE+51               GET ADDRESS FOR DEVICE TYPE\n         LA    R3,8                     GET LENGTH OF DEVICE TYPE\n         L     R5,10(R7)                GET DEVICE TYPE\nB30      EQU   *\n         SLR   R4,R4\n         SLDL  R4,4(0)                  PUT HIGHEST 4 BITS INTO R4\n         STC   R4,CHAR+1                STORE LOWEST 8 BITS\n         OI    CHAR+1,X'F0'             SET TOP 4 BITS OF THOSE 8\n         CLI   CHAR+1,X'F9'             WAS THE NUMBER GREATER THAN 9?\n         BNH   B40                      IF NOT, BRANCH\n         XI    CHAR+1,X'38'             CONVERT TO EBCDIC CHARACTER\n         ICM   R4,B'0011',CHAR\n         SH    R4,=H'1'                   OF 'A' THRU 'F'\n         STH   R4,CHAR\nB40      EQU   *\n         MVC   0(1,R8),CHAR+1           STORE IN LINE\n         LA    R8,1(R8)                 GO TO NEXT LINE POSITION\n         BCT   R3,B30                   LOOP TIL ALL 8 CHARS STORED\n         MVC   LINE+65(L'LINE6C),LINE6C ADD TO SIXTH LINE\n         ICM   R9,B'0011',20(R7)        GET FILE SEQUENCE NUMBER\n         CVD   R9,DWORK                 CONVERT TO PACKED DECIMAL\n         MVC   LINE+83(6),FSEQFMT       GET FORMAT FOR FILE SEQ NUMBER\n         ED    LINE+83(6),DWORK+5       STORE IN THE PRINT LINE\n         BAL   R10,PRINT                OUTPUT THE LINE\n         ICM   R9,B'0011',0(R7)         GET RECORD LENGTH\n         AR    R7,R9                    GO TO NEXT RECORD\n         BCT   R2,B20                   LOOP TIL ALL VOLUMES DONE\n         MVC   LINE+5(L'LINE7),LINE7    SET UP LINE 7\n         BAL   R10,PRINT                OUTPUT THE LINE\n         CLI   TYPE,C'1'                IS THIS A GDG?\n         BNE   GETLOOP                  IF NOT, THAT'S IT\n         MVC   LINE+7(L'LINE8),LINE8    SET UP LINE 8\n         BAL   R10,PRINT                OUTPUT THE LINE\n         B     GD40\n*\nCLOSEIT  EQU   *\n         CLOSE GETACB                   CLOSE CATALOG\n         LTR   R15,R15\n         BNZ   ERROR04\n         CLOSE OUTFILE                  CLOSE OUTPUT FILE\n         LTR   R15,R15\n         BNZ   ERROR05\nRETURN0  EQU   *\n         SLR   R15,R15\nRETURNX  L     R13,SAVEAREA+4           LOAD OS SAVE AREA ADDR TO R13\n         RETURN (14,12),RC=(15)         RETURN TO OS\n*\nPRINT    EQU   *\n         L     R11,LINE#                GET CURRENT LINE NUMBER\n         CLI   CNTL,C' '                SPACE ONE LINE?\n         BNE   PT10                     IF NOT, BRANCH\n         C     R11,=F'53'               TIME FOR HEADERS?\n         BL    PT30                     IF NOT, BRANCH AROUND\n         B     PT20                     OTHERWISE, GO OUTPUT HEADERS\nPT10     EQU   *\n         C     R11,=F'52'               TIME FOR HEADERS?\n         BL    PT30                     IF NOT, BRANCH AROUND\nPT20     EQU   *\n         AP    PAGENO,=P'1'             INCREMENT PAGE NUMBER\n         MVC   PAGE#,PAGEFMT            GET EDIT FORMAT\n         ED    PAGE#,PAGENO             STORE IN HEADER\n         PUT   OUTFILE,HEADER1          WRITE OUT FIRST HEADER\n         PUT   OUTFILE,HEADER2          WRITE OUT SECOND HEADER\n         LA    R11,4                    INIT LINE NUMBER\n         MVI   CNTL,C'0'                FORCE EXTRA SPACE\nPT30     EQU   *\n         LA    R4,LINE                  POINT TO BEGINNING OF DATA\n         LA    R5,OUTREC                GET BEGINNING OF OUTPUT RECORD\nPT40     EQU   *\n         CLC   0(16,R4),=CL16' '        LOOK FOR END OF DATA\n         BE    PT50                     WHEN FOUND, BRANCH\n         LA    R4,1(R4)                 GO TO NEXT POSITION\n         B     PT40                     AND LOOP\nPT50     EQU   *\n         SR    R4,R5                    CALCULATE LENGTH OF LINE\n         STH   R4,OUTREC                STORE THE LENGTH\n         MVC   OUTREC+2(2),=X'0000'\n         PUT   OUTFILE,OUTREC           WRITE OUT RECORD\n         MVI   LINE,C' '                CLEAR PRINT LINE\n         MVC   LINE+1(L'LINE-1),LINE\n         A     R11,=F'1'                INCREMENT LINE NUMBER\n         CLI   CNTL,C' '                EXTRA SPACE?\n         BE    PT60                     IF NOT, BRANCH\n         A     R11,=F'1'                ADD ANOTHER LINE\nPT60     EQU   *\n         ST    R11,LINE#                AND STORE IT\n         MVI   CNTL,C' '                RESET SPACING CONTROL\n         BR    R10\n*\nSAVEAREA DC    18F'0'                   OUR SAVE AREA\nRECADDR  DS    F                        ADDRESS OF RECORD WITHIN BUFFER\nLINE#    DC    F'53'\nSAVEPTR  DC    F'0'\nDWORK    DC    D'0'\nWORK     DC    F'0'\nDAYSYEAR DC    P'365'\nCOUNT    DC    P'001'\nPAGENO   DC    P'00000'\nPAGEFMT  DC    X'402020202020'\nFSEQFMT  DC    X'602020202120'\nDECNUM   DS    CL8\nTYPE     DC    C'0'\nDATE     DS    CL5\nCHAR     DC    H'0'\nNULLCHK  DC    X'FFFFFFFFFFFFFFFF'\n*                                       MONTH DISPLACEMENT FROM 30 DAY\n         DS    0CL12                      (BACKWARD TABLE)\n         DC    P'1'                     DECEMBER\n         DC    P'0'                     NOVEMBER\n         DC    P'1'                     OCTOBER\n         DC    P'0'                     SEPTEMBER\n         DC    P'1'                     AUGUST\n         DC    P'1'                     JULY\n         DC    P'0'                     JUNE\n         DC    P'1'                     MAY\n         DC    P'0'                     APRIL\n         DC    P'1'                     MARCH\n         DC    P'-2'                    FEBRUARY\nMONTH    DC    P'1'                     JANUARY\n*\nOUTREC   DS    0CL125                   OUTPUT FILE RECORD\n         DC    X'005A'                    VARIABLE RECORD LENGTH\n         DC    X'0000'\nCNTL     DC    C' '                       PRINTER CONTROL CHARACTER\nLINE     DC    CL120' '                   MAIN OUTPUT LINE\n*\nLINE1    DS    0CL60\n         DC    C'NONVSAM ------- '\nDSNAME   DS    CL44\nLINE2    DC    C'HISTORY'\nLINE3A   DC    C'OWNER-IDENT-------(NULL)'\nLINE3B   DC    C'CREATION----------00.000'\nLINE4A   DC    C'RELEASE----------------2'\nLINE4B   DC    C'EXPIRATION--------00.000'\nLINE5    DC    C'VOLUMES'\nLINE6A   DC    C'VOLSER------------XXXXXX'\nLINE6B   DC    C'DEVTYPE------X''99999999'''\nLINE6C   DC    C'FSEQN------------------0'\nLINE7    DS    CL26\nLINE7A   DC    C'ASSOCIATIONS--------(NULL)'\nLINE7B   DC    C'ASSOCIATIONS              '\nLINE8    DS    0CL53\n         DC    C'GDG------'\nGDGNAME  DS    CL44\n*\nHEADER1  DS    0CL116\n         DC    X'0074'\n         DC    X'0000'\n         DC    C'1'\n         DC    C'IDCAMS  SYSTEM SERVICES'\n         DC    CL43' '\n         DC    C'TIME: '\nTIME     DC    X'2120207A20207A2020'\n         DC    CL7' '\nMM       DC    CL2' '\n         DC    C'/'\nDD       DC    CL2' '\n         DC    C'/'\nYY       DC    CL2' '\n         DC    CL5' '\n         DC    C'PAGE'\nPAGE#    DC    XL6'00'\nHEADER2  DS    0CL102\n         DC    X'0066'\n         DC    X'0000'\n         DC    C'-'\n         DC    CL29' '\n         DC    C'LISTING FROM CATALOG -- '\nCATNAME  DC    CL44' '\n*\nGETACB   ACB   AM=VSAM,CATALOG=NO,DDNAME=CATALOG,EXLST=ERROR,          X\n               MACRF=(KEY,NFX,NDF,SEQ,NCI,IN,NIS,NRM,NRS,NUB)\nERROR    EXLST AM=VSAM,EODAD=CLOSEIT\nGETRPL   RPL   ACB=GETACB,AM=VSAM,AREA=RECADDR,AREALEN=4,              X\n               OPTCD=(KEY,SEQ,ARD,FWD,SYN,NUP,LOC)\nOUTFILE  DCB   DDNAME=OUTFILE,DSORG=PS,RECFM=VBA,LRECL=125,            X\n               MACRF=(PM),BLKSIZE=6233\n*\n         PRINT NOGEN\nERROR01  EQU   *\n         WTO   'CATLIST01 OPEN FOR THE CATALOG FAILED',                X\n               ROUTCDE=(11)\n         LA    R15,12                   SET RETURN CODE 12\n         B     RETURNX\nERROR02  EQU   *\n         WTO   'CATLIST02 OPEN FOR THE OUTPUT FILE FAILED',            X\n               ROUTCDE=(11)\n         LA    R15,12                   SET RETURN CODE 12\n         B     RETURNX\nERROR03  EQU   *\n         WTO   'CATLIST03 GET MACRO FAILED',                           X\n               ROUTCDE=(11)\n         LA    R15,12                   SET RETURN CODE 12\n         B     RETURNX\nERROR04  EQU   *\n         WTO   'CATLIST05 CLOSE FOR CATALOG FAILED',                   X\n               ROUTCDE=(11)\n         LA    R15,12                   SET RETURN CODE 12\n         B     RETURNX\nERROR05  EQU   *\n         WTO   'CATLIST06 CLOSE FOR OUTPUT FILE FAILED',               X\n               ROUTCDE=(11)\n         LA    R15,12                   SET RETURN CODE 12\n         B     RETURNX\n         PRINT GEN\n         LTORG\n         PRINT NOGEN\n         EQUATE                         REGISTER EQUATES\n         IFGACB\n         PRINT GEN\n         END   CATLIST\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CMDLOFF": {"ttr": 527, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         TITLE 'DELUXE COMMAND AUTHORIZATION INTERFACE'\n*\n*        COMMAND AUTHORIZATION INTERFACE\n*\nCMDLOFF CSECT\n*********************************************************************** 00022\n*                                                                     * 00023\n*   COMMAND PROCESSOR FOR COMMAND 'CMDLOFF'                           * 00024\n*   THIS COMMAND PROCESSOR ALLOWS ANOTHER COMMAND TO BE ISSUED AFTER  * 00025\n*   SETTING THE ECTLOGF BIT TO 1 SO THAT AFTER THE COMMAND FINISHES   * 00026\n*   THE TMP WILL LOG THE USER OFF.                                    * 00027\n*                                                                     * 00031\n*    -COMMAND PROCESSOR                                               * 00053\n*       ENTER:                                                        * 00056\n*       CMDLOFF 'COMMAND NAME' 'COMMAND OPERANDS'                     * 00057\n*         -COMMAND NAME IS THE COMMAND DESIRED FOR EXECUTION.         * 00064\n*       THE COMMAND IS ATTACHED .                                     * 00065\n*       BEFORE ATTACHING, THE CPPL PASSED TO CMDLOFF IS REBUILT       * 00066\n*       FOR THE COMMAND BEING ATTACHED.                               * 00067\n*       THE COMMAND BUFFER AND THE ENVIRONMENT CONTROL TABLE ARE      * 00068\n*       MODIFIED.                                                     * 00069\n*                                                                     * 00070\n*********************************************************************** 00071\n         SAVE  (14,12),,CMDLOFF_DELUXE_CMD_FRTEND_&SYSDATE_&SYSTIME\n         LR    R12,R15          EXTABLISH R12 AS BASE REG\n         USING CMDLOFF,R12      TELL ASSEMBLER\n         ST    R13,SAVEAREA+4   SAVE OS SAVE AREA ADDRESS\n         LR    R6,R13           SAVE IT IN R6\n         LA    R13,SAVEAREA     POINT R13 AT OUR SAVEAREA\n         ST    R13,8(R6)        STORE OUR SAVEAREA ADDRESS IN OS\n         EJECT\n         LR    R2,R1                   R2 ---> CPPL\n         L     R4,12(R2)               R4 ---> ECT\n         USING ECT,R4\n         OI    ECTSWS,ECTLOGF     TELL TMP THAT LOGOFF HAS BEEN ENTERED\n         DROP  R4\n         L     R4,0(R2)                R4 ---> COMMAND BUFFER\n         SR    R5,R5\n         LH    R5,0(R4)                R5 = LENGTH(CBUF)\n         S     R5,F5                   R5 - 4(PREFIX) -1(FOR MOVE)\n         EX    R5,UPCASE               XLATE TO UPPERCASE\n         LH    R5,0(R4)                R5 = LENGTH(CBUF)\n         S     R5,F4                   MINUS LENGTH OF PREFIX (4)\n         SR    R6,R6\n         LH    R6,2(R4)                R6 = OFFSET TO OPERANDS\n         SR    R7,R7\n         LA    R7,4(R4)                START OF TEXT\n         AR    R7,R6                   R7 ---> OPERANDS\n         SR    R5,R6                   R5 = LENGTH(OPERANDS)\n         BCTR  R5,0                    MINUS ONE FOR MOVE\n         EX    R5,MOVETEXT             CREATE NEW CBUF TEXT\n         A     R5,F5                   R5 + $(PREFIX) +1(FROM MOVE)\n         STH   R5,CBUF                 STORE NEW CBUF LENGTH\n         BAL   R14,FINDOPND            FIND FIRST OPERAND\n         STH   R8,OFFSET               AND STORE OFFSET IN CBUF\n         BCTR  R8,0                    MINUS ONE FOR MOVE\n         EX    R8,MOVECMND             MOVE COMMAND NAME FOR LINK\n         LA    R8,CBUF                 ADDRESS OF NEW CBUF\n         ST    R8,0(R2)                AND STORE IN CPPL\n         LR    R1,R2                   GET CPPL ADDRESS\n         SPACE\nLINK     LINK  EPLOC=COMMAND           LINK TO COMMAND\n         LA    R8,LOFFCMD              ADDRESS OF NEW CBUF\n         ST    R8,0(R2)                AND STORE IN CPPL\n         LR    R1,R2                   GET CPPL ADDRESS\n         SPACE\nLINK2    LINK  EPLOC=LOGOFF            LINK TO LOGOFF\n         SPACE\n         SLR   R15,R15                 LOAD RETURN CODE\n         L     R13,SAVEAREA+4          LOAD OS SAVEAREA ADDR IN R13\n         RETURN (14,12),RC=(15)        RETURN TO CALLER\n         EJECT\nFINDOPND LA    R7,TEXT                 R7 ---> COMMAND BUFFER TEXT\n         SR    R8,R8                   COUNTER FOR OPERAND OFFSET\n         LR    R9,R5                   COMMAND BUFFER LENGTH\n         S     R9,F4                   MINUS PREFIX LENGTH\n         SPACE\nLOOP1    CLI   0(R7),C' '              FOUND BLANK\n         BE    LOOP2                       YES..NEXT LOOP\n         SPACE\n         LA    R7,1(R7)                UPDATE POINTER\n         LA    R8,1(R8)                UPDATE OFFSET\n         BCT   R9,LOOP1                LOOP IF STILL IN BUFFER\n         BR    R14                     AND EXIT\n         SPACE\nLOOP2    CLI   0(R7),C' '              FOUND BLANK\n         BNE   ENDLOOP                     NO...END OF ROUTINE\n         SPACE\n         LA    R7,1(R7)                UPDATE POINTER\n         LA    R8,1(R8)                UPDATE OFFSET\n         BCT   R9,LOOP2                LOOP IF STILL IN BUFFER\n         BCTR  R8,0                    IF NO OPERANDS, BACK UP ONE\n         SPACE\nENDLOOP  BR    R14                     RETURN TO CALLER\n         EJECT\n         SPACE\n         DS   0D\nOLDLEN   DC    F'0'                    ORIGINAL CBUF LENGTH\nF4       DC    F'4'\nF5       DC    F'5'\nCOMMAND  DC    CL8' '\nCBUF     DS   0D                       NEW COMMAND BUFFER\n         DC    H'0'                    BUFFER LENGTH\nOFFSET   DC    H'0'                    OFFSET TO OPERANDS\nTEXT     DC    CL255' '                COMMAND TEXT\nBLANKS   DC    CL255' '\nUPCASE   OC    4(*-*,R4),BLANKS\nMOVETEXT MVC   TEXT,0(R7)              MOVE COMMAND TEXT TO NEW CBUF\nMOVECMND MVC   COMMAND(*-*),TEXT       MOVE COMMAND NAME TO WORK AREA\nLOGOFF   DC    CL8'LOGOFF  '\nLOFFCMD  DC    XL2'000A',XL2'0006',CL7'LOGOFF '\nSAVEAREA DC    18F'0'\n         EQUATE\n         IKJECT\n         SPACE\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DLXAUTHC": {"ttr": 771, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         TITLE 'DELUXE COMMAND AUTHORIZATION INTERFACE'\n*\n*        COMMAND AUTHORIZATION INTERFACE\n*\nDLXAUTHC CSECT\n         SAVE  (14,12),,DLXAUTHC_DELUXE_CMD_AUTH_&SYSDATE_&SYSTIME\n         LR    R12,R15          EXTABLISH R12 AS BASE REG\n         USING DLXAUTHC,R12     TELL ASSEMBLER\n         ST    R13,SAVEAREA+4   SAVE OS SAVE AREA ADDRESS\n         LR    R6,R13           SAVE IT IN R6\n         LA    R13,SAVEAREA     POINT R13 AT OUR SAVEAREA\n         ST    R13,8(R6)        STORE OUR SAVEAREA ADDRESS IN OS\n         EJECT\n         LR    R2,R1                   R2 ---> CPPL\n         L     R4,0(R2)                R4 ---> COMMAND BUFFER\n         SR    R5,R5\n         LH    R5,0(R4)                R5 = LENGTH(CBUF)\n         S     R5,F5                   R5 - 4(PREFIX) -1(FOR MOVE)\n         EX    R5,UPCASE               XLATE TO UPPERCASE\n         LH    R5,0(R4)                R5 = LENGTH(CBUF)\n         S     R5,F4                   MINUS LENGTH OF PREFIX (4)\n         SR    R6,R6\n         LH    R6,2(R4)                R6 = OFFSET TO OPERANDS\n         SR    R7,R7\n         LA    R7,4(R4)                START OF TEXT\n         AR    R7,R6                   R7 ---> OPERANDS\n         SR    R5,R6                   R5 = LENGTH(OPERANDS)\n         BCTR  R5,0                    MINUS ONE FOR MOVE\n         EX    R5,MOVETEXT             CREATE NEW CBUF TEXT\n         A     R5,F5                   R5 + $(PREFIX) +1(FROM MOVE)\n         STH   R5,CBUF                 STORE NEW CBUF LENGTH\n         BAL   R14,FINDOPND            FIND FIRST OPERAND\n         STH   R8,OFFSET               AND STORE OFFSET IN CBUF\n         BCTR  R8,0                    MINUS ONE FOR MOVE\n         EX    R8,MOVECMND             MOVE COMMAND NAME FOR LINK\n         LA    R8,CBUF                 ADDRESS OF NEW CBUF\n         ST    R8,0(R2)                AND STORE IN CPPL\n         LA    R0,1                    SET AUTH = ON\n         USERSVC AUTHON                ISSUE SETAUTH SVC TO AUTHON\n         LR    R1,R2                   GET CPPL ADDRESS\n         SPACE\nLINK     LINK  EPLOC=COMMAND           LINK TO COMMAND\n         SPACE\n         LR    R2,R15                  SAVE RETURN CODE\n         USERSVC AUTHOFF               ISSUE SETAUTH SVC TO AUTHOFF\n         SPACE\n         LR    R15,R2                  LOAD RETURN CODE\n         L     R13,SAVEAREA+4          LOAD OS SAVEAREA ADDR IN R13\n         RETURN (14,12),RC=(15)        RETURN TO CALLER\n         EJECT\nFINDOPND LA    R7,TEXT                 R7 ---> COMMAND BUFFER TEXT\n         SR    R8,R8                   COUNTER FOR OPERAND OFFSET\n         LR    R9,R5                   COMMAND BUFFER LENGTH\n         S     R9,F4                   MINUS PREFIX LENGTH\n         SPACE\nLOOP1    CLI   0(R7),C' '              FOUND BLANK\n         BE    LOOP2                       YES..NEXT LOOP\n         SPACE\n         LA    R7,1(R7)                UPDATE POINTER\n         LA    R8,1(R8)                UPDATE OFFSET\n         BCT   R9,LOOP1                LOOP IF STILL IN BUFFER\n         BR    R14                     AND EXIT\n         SPACE\nLOOP2    CLI   0(R7),C' '              FOUND BLANK\n         BNE   ENDLOOP                     NO...END OF ROUTINE\n         SPACE\n         LA    R7,1(R7)                UPDATE POINTER\n         LA    R8,1(R8)                UPDATE OFFSET\n         BCT   R9,LOOP2                LOOP IF STILL IN BUFFER\n         BCTR  R8,0                    IF NO OPERANDS, BACK UP ONE\n         SPACE\nENDLOOP  BR    R14                     RETURN TO CALLER\n         EJECT\n         SPACE\n         DS   0D\nOLDLEN   DC    F'0'                    ORIGINAL CBUF LENGTH\nF4       DC    F'4'\nF5       DC    F'5'\nCOMMAND  DC    CL8' '\nCBUF     DS   0D                       NEW COMMAND BUFFER\n         DC    H'0'                    BUFFER LENGTH\nOFFSET   DC    H'0'                    OFFSET TO OPERANDS\nTEXT     DC    CL255' '                COMMAND TEXT\nBLANKS   DC    CL255' '\nUPCASE   OC    4(*-*,R4),BLANKS\nMOVETEXT MVC   TEXT,0(R7)              MOVE COMMAND TEXT TO NEW CBUF\nMOVECMND MVC   COMMAND(*-*),TEXT       MOVE COMMAND NAME TO WORK AREA\nSAVEAREA DC    18F'0'\n         EQUATE\n         SPACE\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "EXIMPORT": {"ttr": 774, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         TITLE 'EXIMPORT - GEN JCL FOR EXPORTS AND IMPORTS'\n***********************************************************************\n*                                                                     *\n*             MODULE NAME = EXIMPORT                                  *\n*                                                                     *\n*             DESCRIPTIVE NAME = GENERATE THE JCL NECESSARY FOR       *\n*                EXPORTING AND IMPORTING THE DATA SETS ON A           *\n*                SPECIFIED VOLUME.                                    *\n*                                                                     *\n*             FUNCTION =                                              *\n*                CREATES ONE DATA SET WITH THE JCL FOR EXPORTING      *\n*                THE DATA SETS ON A SPECIFIED VOLUME AND ANOTHER      *\n*                FOR IMPORTING THE SAME DATA SETS.  FOR VSAM          *\n*                FILES, THE JCL WILL BE SET UP TO EXECUTE             *\n*                IDCAMS, EXPORTING TO TAPE AND THEN IMPORTING         *\n*                BACK ONTO THE SAME VOLUME FROM THE TAPE.             *\n*                FOR NON-VSAM PS FILES, THE PROGRAM IEBGENER IS       *\n*                EXECUTED TO COPY THE DATA SET TO TAPE AND THEN       *\n*                BACK TO THE SAME VOLUME.  FOR PO FILES, IEBCOPY      *\n*                IS USED.  ALSO A CLIST IS GENERATED TO SCRATCH       *\n*                THE TAPE FILES AFTER THE DATA SETS HAVE BEEN         *\n*                IMPORTED.                                            *\n*                                                                     *\n*                OPERATION =                                          *\n*                   READ THE PROGRAM PARAMETERS                       *\n*                   OPEN THE VTOC FOR THE SPECIFIED VOLUME            *\n*                   FIGURE OUT THE DEVICE TYPE FOR BOTH THE CURRENT   *\n*                     AND THE NEW DEVICES                             *\n*                   OPEN THE SPECIFIED OUTPUT FILES (FOR THE JCL)     *\n*                   READ FORMAT 1 RECORDS OF VTOC FOR DATA SET NAME   *\n*                   FOR VSAM FILES, IGNORE .INDEX FILES AND           *\n*                     REMOVE THE .DATA FROM THE REST SO EXPORT-       *\n*                     IMPORT IS SET UP FOR THE CLUSTER.               *\n*                   FOR NON-VSAM FILE, CALCULATE PARAMETERS           *\n*                     TO RECONSTUCT THE DATA SET WHEN COPYING         *\n*                     BACK TO THE VOLUME.                             *\n*                   WRITE OUT JCL TO BOTH EXPORT AND IMPORT DATA      *\n*                     SETS.                                           *\n*                   WRITE OUT THE SCRATCH STATEMENTS INTO THE CLIST   *\n*                     DATA SET.\n*                   CONTINUE READING VTOC TIL ALL DATA SETS PROCESSED *\n*                   CLOSE VTOC AND OUTPUT FILES                       *\n*                   EXIT                                              *\n*                                                                     *\n*              NOTES =                                                *\n*                                                                     *\n*                 REGISTER CONVENTIONS = STANDARD CONVENTIONS.        *\n*                    REGISTERS 0 TO 1  = WORK REGISTERS               *\n*                    REGISTERS 2 TO 4  = LINKAGE & WORK REGISTERS     *\n*                    REGISTERS 5 TO 9  = WORK REGISTERS               *\n*                    REGISTER  10      = ADDRESSABILITY TO DCB,       *\n*                                        JFCB & DSCB                  *\n*                    REGISTER  11      = ADDRESSABILITY TO REST OF    *\n*                                        EXIMPORT CSECT               *\n*                    REGISTER  12      = ADDRESSABILITY TO EXIMPORT   *\n*                                        CSECT                        *\n*                    REGISTER  13      = SAVE AREA REGISTER AND       *\n*                                        ADDRESSABILITY TO GETMAINED  *\n*                                        WORK AREA                    *\n*                    REGISTERS 14,15   = WORK REGISTERS               *\n*                                                                     *\n*             MACROS =                                                *\n*                SAVE, GETMAIN, RDJFCB, OPEN, CVAFSEQ, CVAFDIR,       *\n*                CLOSE, TRKCALC, PUT, DEVTYPE                         *\n*                                                                     *\n*             CHANGE ACTIVITY =                                       *\n*                10/21/83  WRITTEN.      BC.                          *\n*                10/28/83  ADDED SYSPRINT & CLIST                     *\n*                          CHANGED READING OF VTOC TO                 *\n*                            USE CVAF MACROS.     BC.                 *\n*                02/28/83  FIXED BUG IN 'SYSIN DD DUMMY' LINE         *\n*                          ADDED SUPPORT FOR PARTITIONED DATA SETS    *\n*                          ADDED SUPPORT FOR 3375'S                   *\n*                          CHANGE 'VOL=' AND 'UNIT=' PARAMETERS TO    *\n*                            APPLY TO ALL DATA SETS             BC.   *\n*                03/02/83  MODIFIED ALLOCATION REQUIREMENTS FOR       *\n*                            NEW DEVICE TYPE.                         *\n*                          ADDED CAPABILITY TO SPECIFY NO VSAM.   BC. *\n*                                                                     *\n* SAMPLE JCL =                                                        *\n*                                                                     *\n*  BOTH VSAM AND NON-VSAM (PO AND PS ONLY) FILES:                     *\n*                                                                     *\n*     //JOBNAME  JOB (GEE1,0104),'PROG NAME',CLASS=S,MSGCLASS=A,      *\n*     //         MSGLEVEL=(2,0),USER=SYSPGM,PASSWORD=????????         *\n*     //STEP1    EXEC  PGM=EXIMPORT,PARM='DATE=OCT14'                 *\n*     //VTOC   DD UNIT=3350,VOL=SER=DLX170,DISP=OLD                   *\n*     //EXPORT DD DSN=T99999.TEST.EXPJCL,VOL=SER=DLXTS1,UNIT=3380,    *\n*     //            DISP=(NEW,CATLG),SPACE=(TRK,(10,1)),              *\n*     //            DCB=(RECFM=FB,LRECL=80,BLKSIZE=6160)              *\n*     //IMPORT DD DSN=T99999.TEST.IMPJCL,VOL=SER=DLXTS1,UNIT=3380,    *\n*     //            DISP=(NEW,CATLG),SPACE=(TRK,(10,1)),              *\n*     //            DCB=(RECFM=FB,LRECL=80,BLKSIZE=6160)              *\n*     //CLIST  DD DSN=T99999.TEST.CLIST,VOL=SER=DLXTS1,UNIT=3380,     *\n*     //            DISP=(NEW,CATLG),SPACE=(TRK,(5,1)),               *\n*     //            DCB=(RECFM=VB,LRECL=255,BLKSIZE=6233)             *\n*     //SYSPRINT DD SYSOUT=*                                          *\n*                                                                     *\n*  VSAM ONLY:                                                         *\n*                                                                     *\n*     //JOBNAME  JOB (GEE1,0104),'PROG NAME',CLASS=S,MSGCLASS=A,      *\n*     //         MSGLEVEL=(2,0),USER=SYSPGM,PASSWORD=????????         *\n*     //STEP1    EXEC  PGM=EXIMPORT,                                  *\n*     //         PARM='DATE=OCT14,VSAMONLY'                           *\n*     //VTOC   DD UNIT=3350,VOL=SER=DLX170,DISP=OLD                   *\n*     //EXPORT DD DSN=T99999.TEST.EXPJCL,VOL=SER=DLXTSO,UNIT=3350,    *\n*     //            DISP=(NEW,CATLG),SPACE=(TRK,(10,1)),              *\n*     //            DCB=(RECFM=FB,LRECL=80,BLKSIZE=6160)              *\n*     //IMPORT DD DSN=T99999.TEST.IMPJCL,VOL=SER=DLXTSO,UNIT=3350,    *\n*     //            DISP=(NEW,CATLG),SPACE=(TRK,(10,1)),              *\n*     //            DCB=(RECFM=FB,LRECL=80,BLKSIZE=6160)              *\n*     //CLIST  DD DSN=T99999.TEST.CLIST,VOL=SER=DLXTS1,UNIT=3380,     *\n*     //            DISP=(NEW,CATLG),SPACE=(TRK,(5,1)),               *\n*     //            DCB=(RECFM=VB,LRECL=255,BLKSIZE=6233)             *\n*     //SYSPRINT DD SYSOUT=*                                          *\n*                                                                     *\n*  NO VSAM:                                                           *\n*                                                                     *\n*     //JOBNAME  JOB (GEE1,0104),'PROG NAME',CLASS=S,MSGCLASS=A,      *\n*     //         MSGLEVEL=(2,0),USER=SYSPGM,PASSWORD=????????         *\n*     //STEP1    EXEC  PGM=EXIMPORT,                                  *\n*     //         PARM='DATE=OCT14,NOVSAM'                             *\n*     //VTOC   DD UNIT=3350,VOL=SER=DLX170,DISP=OLD                   *\n*     //EXPORT DD DSN=T99999.TEST.EXPJCL,VOL=SER=DLXTSO,UNIT=3350,    *\n*     //            DISP=(NEW,CATLG),SPACE=(TRK,(10,1)),              *\n*     //            DCB=(RECFM=FB,LRECL=80,BLKSIZE=6160)              *\n*     //IMPORT DD DSN=T99999.TEST.IMPJCL,VOL=SER=DLXTSO,UNIT=3350,    *\n*     //            DISP=(NEW,CATLG),SPACE=(TRK,(10,1)),              *\n*     //            DCB=(RECFM=FB,LRECL=80,BLKSIZE=6160)              *\n*     //CLIST  DD DSN=T99999.TEST.CLIST,VOL=SER=DLXTS1,UNIT=3380,     *\n*     //            DISP=(NEW,CATLG),SPACE=(TRK,(5,1)),               *\n*     //            DCB=(RECFM=VB,LRECL=255,BLKSIZE=6233)             *\n*     //SYSPRINT DD SYSOUT=*                                          *\n*                                                                     *\n*  IMPORTING TO A DIFFERENT VOLUME:                                   *\n*                                                                     *\n*     //JOBNAME  JOB (GEE1,0104),'PROG NAME',CLASS=S,MSGCLASS=A,      *\n*     //         MSGLEVEL=(2,0),USER=SYSPGM,PASSWORD=????????         *\n*     //STEP1    EXEC  PGM=EXIMPORT,                                  *\n*     //         PARM='DATE=OCT14,UNIT=3380,VOL=DLXTS3'               *\n*     //VTOC   DD UNIT=3350,VOL=SER=DLX170,DISP=OLD                   *\n*     //EXPORT DD DSN=T99999.TEST.EXPJCL,VOL=SER=DLXTSO,UNIT=3350,    *\n*     //            DISP=(NEW,CATLG),SPACE=(TRK,(10,1)),              *\n*     //            DCB=(RECFM=FB,LRECL=80,BLKSIZE=6160)              *\n*     //IMPORT DD DSN=T99999.TEST.IMPJCL,VOL=SER=DLXTSO,UNIT=3350,    *\n*     //            DISP=(NEW,CATLG),SPACE=(TRK,(10,1)),              *\n*     //            DCB=(RECFM=FB,LRECL=80,BLKSIZE=6160)              *\n*     //CLIST  DD DSN=T99999.TEST.CLIST,VOL=SER=DLXTS1,UNIT=3380,     *\n*     //            DISP=(NEW,CATLG),SPACE=(TRK,(5,1)),               *\n*     //            DCB=(RECFM=VB,LRECL=255,BLKSIZE=6233)             *\n*     //SYSPRINT DD SYSOUT=*                                          *\n*                                                                     *\n*  NOTE:  WHEN IMPORTING TO A NEW VOLUME, IF 'VOL=' IS SPECIFIED      *\n*         WITHOUT 'UNIT=', THE NEW UNIT WILL DEFAULT TO THE SAME      *\n*         AS THE OLD.  IF 'UNIT=' IS SPECIFIED WITHOUT 'VOL=',        *\n*         BOTH VOLUME AND UNIT WILL REMAIN UNCHANGED.                 *\n*                                                                     *\n***********************************************************************\n         PRINT NOGEN\n*\nEXIMPORT CSECT\n         SAVE  (14,12)                 SAVE REGISTERS\n         LR    R12,R15\n         USING EXIMPORT,R12            ESTABLISH ADDRESSABILITY\n         LA    R11,4095(R12)\n         USING EXIMPORT+4095,R11       ESTABLISH ADDRESSABILITY TO REST\n         LR    R2,R1                   PRESERVE PTR TO PARMS\n         GETMAIN R,LV=LDATA            GET DYNAMIC WORK AREA\n         LR    R10,R1                  PRESERVE PTR TO WORK AREA\n         ST    R13,4(R10)              STORE ADDR OF PREVIOUS SA\n         ST    R10,8(,R13)             STORE ADDR OF CURRENT SA\n         LR    R13,R10                 LOAD ADDR OF CURRENT SA\n         USING WORKAREA,R13            ESTABLISH ADDRESSABILITY\n*\n*  GET PARMS FOR DATE, VSAM ONLY, VOLUME AND UNIT.\n*\nGETPARM  EQU   *\n         L     R5,0(R2)                GET PARM ADDRESS\n         LH    R3,0(R5)                SAVE PARM LENGTH\n         LTR   R3,R3                   ANY PARM DATA?\n         BZ    GP40                    IF NOT, BRANCH\n         LA    R5,2(R5)                SKIP PARM LENGTH FIELD\n         MVI   VSAMONLY,C'N'           INIT VSAM ONLY FLAG\n         MVI   NOVSAM,C'N'             INIT NO VSAM FLAG\n         MVI   NEWUNIT,X'40'           CLEAR UNIT BUFFER\n         MVC   NEWUNIT+1(L'NEWUNIT-1),NEWUNIT\n         MVI   NEWVOL,X'40'            CLEAR VOLUME BUFFER\n         MVC   NEWVOL+1(L'NEWVOL-1),NEWVOL\nGP05     EQU   *\n         LA    R4,PARMBUF              SET POINTER INTO PARM BUFFER\n         MVI   PARMBUF,X'40'           CLEAR PARM BUFFER\n         MVC   PARMBUF+1(L'PARMBUF-1),PARMBUF\nGP10     EQU   *\n         CLI   0(R5),C','              DELIMITING COMMA?\n         BE    GP20                    IF SO, BRANCH\n         MVC   0(1,R4),0(R5)           STORE PARM CHARACTER\n         LA    R4,1(R4)                INCREMENT PARM BUFFER POINTER\n         LA    R5,1(R5)                GO TO NEXT PARM CHARACTER\n         BCT   R3,GP10                 LOOP BACK TIL DONE\nGP20     EQU   *\n         CLC   PARMBUF(5),=C'DATE='    CHECK FOR DATE PARAMETER\n         BNE   GP30                    IF NOT, BRANCH\n         MVC   DATE,PARMBUF+5          STORE DATE\n         B     GP70\nGP30     EQU   *\n         CLC   PARMBUF(4),=C'VOL='     CHECK FOR VOLUME PARAMETER\n         BNE   GP40                    IF NOT, BRANCH\n         MVC   NEWVOL,PARMBUF+4        STORE NEW VOLUME\n         B     GP70\nGP40     EQU   *\n         CLC   PARMBUF(5),=C'UNIT='    CHECK FOR UNIT PARAMETER\n         BNE   GP50                    IF NOT, BRANCH\n         MVC   NEWUNIT,PARMBUF+5       STORE NEW UNIT\n         B     GP70\nGP50     EQU   *\n         CLC   PARMBUF(8),=C'VSAMONLY' DO VSAM ONLY?\n         BNE   GP60                    IF NOT, BRANCH\n         MVI   VSAMONLY,C'Y'           IF SO, SET FLAG\n         B     GP70\nGP60     EQU   *\n         CLC   PARMBUF(6),=C'NOVSAM'   IGNORE VSAM?\n         BNE   GP70                    IF NOT, BRANCH\n         MVI   NOVSAM,C'Y'             IF SO, SET FLAG\nGP70     EQU   *\n         LA    R4,PARMBUF              RESET POINTER INTO PARM BUFFER\n         MVI   PARMBUF,X'40'           CLEAR PARM BUFFER\n         MVC   PARMBUF+1(L'PARMBUF-1),PARMBUF\n         LTR   R3,R3                   ANY MORE PARMS?\n         BZ    GP80                    IF NOT, EXIT\n         LA    R5,1(R5)                IF SO, SKIP COMMA\n         B     GP05                    AND LOOP BACK\nGP80     EQU   *\n*\n*  INITIALIZE THE WORK AREA.  OPEN THE VTOC, EXPORT, AND IMPORT\n*  DATA SETS.  INITIALIZE DEVICE PARAMETERS.\n*\nINIT     EQU   *\n         LA    R6,DATA                 SET UP REGISTERS FOR\n         LA    R7,MOVEL                  LONG MOVE\n         LA    R8,CDATA\n         LA    R9,MOVEL\n         MVCL  R6,R8                   LOAD INITIAL DATA INTO WORKAREA\n         LA    R10,VTOC                GET ADDRESS OF DCB1\n         USING IHADCB,R10              ADDRESSIBILITY TO DCB\n         LA    R9,JFCBA                GET ADDRESS OF BUFFER\n         ST    R9,EXLIST               STORE ADDRESS IN EXIT LIST\n         MVI   EXLIST,X'87'            SET END OF LIST & JFCB BYTE\n         LA    R6,EXLIST               GET ADDRESS OF EXIT LIST\n         ST    R6,DCBEXLST             STORE IN DCB\n         DROP  R10\n         LR    R10,R9\n         RDJFCB (VTOC,),MF=(E,EX1)     READ JOB FILE CONTROL BLOCK\n         USING INFMJFCB,R10            ESTABLISH ADDRESSABILITY\n         LTR   R15,R15                 CHECK RETURN CODE\n         BNZ   RETURN                  IF NOT SUCCESSFUL, EXIT\n         MVI   JFCBDSNM,X'04'          CHANGE DATASET NAME TO\n         MVC   JFCBDSNM+1(43),JFCBDSNM   44 X'04'S\n         OI    JFCBTSDM,JFCNWRIT       SET FLAG NOT TO WRITE BACK\n         MVC   VOL,JFCBVOLS            SAVE VOLSER\n         DROP  R10\n         OPEN  (VTOC,INPUT),TYPE=J,MF=(E,EX2) OPEN THE VTOC\n         LTR   R15,R15\n         BNZ   CLOSEX\n         LA    R10,VTOC                GET ADDRESSING TO THE\n         USING IHADCB,R10                VTOC DCB AGAIN\n         L     R9,DCBDEBAD             SAVE THE ADDRESS OF THE DEB\n         ST    R9,DEBADDR                FOR READING THE VTOC\n         DROP  R10\n         OPEN  (EXPORT,OUTPUT),MF=(E,EX2)  OPEN EXPORT DATA SET\n         LTR   R15,R15\n         BNZ   CLOSEX\n         OPEN  (IMPORT,OUTPUT),MF=(E,EX2)  OPEN IMPORT DATA SET\n         LTR   R15,R15\n         BNZ   CLOSEX\n         OPEN  (CLIST,OUTPUT),MF=(E,EX2)  OPEN CLIST DATA SET\n         LTR   R15,R15\n         BNZ   CLOSEX\n         MVI   CLINE,X'40'             INITIALIZE CLIST LINE\n         MVC   CLINE+1(L'CLINE-1),CLINE   TO ALL SPACES\n         MVC   CMDLINE(L'FSTLINE),FSTLINE  OUTPUT FIRST LINE OF CLIST\n         BAL   R3,PRINTC\n         MVC   CMDLINE(L'SNDLINE),SNDLINE  OUTPUT SECOND LINE OF CLIST\n         BAL   R3,PRINTC\n         OPEN  (SYSPRINT,OUTPUT),MF=(E,EX2)  OPEN SYSPRINT DATA SET\n         LTR   R15,R15\n         BNZ   CLOSEX\n         MVI   SPLINE,X'40'            INITIALIZE LINE\n         MVC   SPLINE+1(L'SPLINE-1),SPLINE\n         MVC   SPLINE(L'AIXLINE),AIXLINE LOAD FIRST LINE INTO SYSPRINT\n         PUT   SYSPRINT,SPLINE\n         MVI   SPLINE,X'40'            RE-INITIALIZE LINE\n         MVC   SPLINE+1(L'SPLINE-1),SPLINE\n         PUT   SYSPRINT,SPLINE         OUTPUT BLANK LINE\n         MVI   LINE,X'40'              INITIALIZE LINE\n         MVC   LINE+1(L'LINE-1),LINE     TO ALL SPACES\n         DEVTYPE VTOCLBL,DEVBUF,DEVTAB  GET DEVICE PARAMETERS\n         USING IECSDSL1,R10            ESTABLISH ADDRESSABILITY\n         LA    R10,DSCB                LOAD DSCB ADDRESS\n         MVI   BUFLIST,X'00'           INITIALIZE BUFFER LIST\n         MVC   BUFLIST+1(BUFLEN-1),BUFLIST\n         OI    BFLHFL,BFLHDSCB         DSCB'S TO BE READ WITH LIST\n         MVI   BFLHNOE,1               ONE BUFFER LIST ENTRY\n         LA    R9,DS1FMTID             GET ADDRESS OF DSCB BUFFER\n         ST    R9,BFLEBUF              AND STORE IN BUFFER LIST\n         MVI   BFLELTH,DSCBLTH         READ ONLY DATA PORTION\n         MVI   DS1DSNAM,X'00'          INITIALIZE DATA SET NAME\n         MVC   DS1DSNAM+1(L'DS1DSNAM-1),DS1DSNAM\n*\n*  FIGURE OUT DEVICE TYPE\n*\nGETDEVT  EQU   *\n         MVC   TYPE,=CL5' '            INIT TO SPACES\n         CLI   DEVBUF+3,X'0B'          IS THIS A 3350?\n         BNE   GD10                    IF NOT, BRANCH\n         MVC   TYPE,=C'3350,'          STORE TYPE\n         B     GD30                    AND CONTINUE\nGD10     EQU   *\n         CLI   DEVBUF+3,X'0C'          IS THIS A 3375?\n         BNE   GD20                    IF NOT, BRANCH\n         MVC   TYPE,=C'3375,'          STORE TYPE\n         B     GD30                    AND CONTINUE\nGD20     EQU   *\n         CLI   DEVBUF+3,X'0E'          IS THIS A 3380?\n         BNE   CALCPRI                 IF NOT, BRANCH\n         MVC   TYPE,=C'3380,'          STORE TYPE\nGD30     EQU   *\n         SLR   R7,R7\n         SLR   R8,R8\n         LA    R6,TYPE                 POINT TO DEVICE TYPE\n         CLI   NEWUNIT,C' '            CHANGING TO NEW UNIT?\n         BE    GD40                    IF NOT, BRANCH\n         LA    R6,NEWUNIT              POINT TO NEW UNIT\nGD40     EQU   *\n         CLC   0(4,R6),=C'3350'        3350?\n         BNE   GD50                    IF NOT, BRANCH\n         LA    R7,36                   SET FOR MULTIPLES OF 36 DIR BLKS\n         MVI   NEWDEV,X'0B'            SET NEW DEVICE BYTE\n         LA    R8,30                   SET FOR 30 TRACKS/CYL\n         B     GD70\nGD50     EQU   *\n         CLC   0(4,R6),=C'3375'        3375?\n         BNE   GD60                    IF NOT, BRANCH\n         LA    R7,43                   SET FOR MULTIPLES OF 43 DIR BLKS\n         MVI   NEWDEV,X'0C'            SET NEW DEVICE BYTE\n         LA    R8,12                   SET FOR 12 TRACKS/CYL\n         B     GD70\nGD60     EQU   *\n         CLC   0(4,R6),=C'3380'        3380?\n         BNE   GD70                    IF NOT, BRANCH\n         LA    R7,46                   SET FOR MULTIPLES OF 46 DIR BLKS\n         MVI   NEWDEV,X'0E'            SET NEW DEVICE BYTE\n         LA    R8,15                   SET FOR 15 TRACKS/CYL\nGD70     EQU   *\n         ST    R7,IDEAL#               SAVE THE NUMBER\n         ST    R8,TRKPCYL2             SAVE # OF TRACKS PER CYLINDER\n*\n*  READ THE VTOC FORMAT-1 RECORDS.  PROCESS ALL DATA SETS ON VOLUME\n*    WITH THE EXCEPTION OF A FEW (SUCH AS THE VTOC INDEX, CATALOG\n*    CATALOG INDEX, TEMPORARY DATA SETS, ETC.)\n*\nREADIT   EQU   *\n         L     R9,DEBADDR              GET DEB ADDRESS AND READ VTOC\n         CVAFSEQ DEB=(R9),BUFLIST=BUFLIST,DSN=DS1DSNAM,MF=(E,EX3)\n         LTR   R15,R15                 IF SUCCESSFUL,\n         BZ    RI05                      BRANCH\n         LR    R9,R15                  SAVE RETURN CODE\n         MVC   RCODE,CVSTAT              AND STATUS\n         CVAFDIR ACCESS=RLSE,BUFLIST=0,IXRCDS=NOKEEP,MF=(E,EX3)\n         LR    R15,R9                  RELEASE BUFFERS & RESTORE RC\n         C     R15,=F'4'               JUST A 4?\n         BNE   CLOSEX                  IF NOT, BRANCH TO ERROR EXIT\n         CLI   RCODE,STAT032           IS IT END OF DATA?\n         BE    CLOSE                   IF SO, NORMAL EXIT\n         ABEND 10,DUMP\n         B     CLOSEX                  ELSE, BRANCH TO ERROR EXIT\nRI05     EQU   *\n         CLI   DS1FMTID,C'1'           FORMAT 1 RECORD?\n         BNE   READIT                  IF NOT, GO BACK FOR ANOTHER\n         CLC   DS1DSNAM(11),=C'SYS1.VTOCIX'\n         BE    IGNORE\n         CLC   DS1DSNAM(9),=C'SYS1.VVDS'\n         BE    IGNORE\n         CLC   DS1DSNAM(7),=C'CATALOG'            IGNORE CERTAIN\n         BE    IGNORE                              DATA SETS\n         CLC   DS1DSNAM(8),=C'CATINDEX'\n         BE    IGNORE\n         CLC   DS1DSNAM(8),=C'FDRABR.V'\n         BE    IGNORE\n         CLC   DS1DSNAM(3),=C'SYS'\n         BNE   PROCDS\n         LA    R7,DS1DSNAM+3\n         LA    R8,5\nRI10     EQU   *\n         TM    0(R7),X'F0'\n         BNO   PROCDS\n         LA    R7,1(R7)\n         BCT   R8,RI10\nIGNORE   EQU   *\n         MVC   SPDSN(L'DS1DSNAM),DS1DSNAM  GET DATA SET NAME\n         PUT   SYSPRINT,SPLINE             WRITE INTO SYSPRINT FILE\n         B     READIT\n*\n*  IF VSAM .INDEX FILE, SKIP IT.  IF .DATA, REMOVE THE .DATA SO\n*    ONLY THE CLUSTER NAME IS LEFT.  IF VSAM ALTERNATE INDEX,\n*    OUTPUT MESSAGE TO SYSPRINT AND GO ON TO THE NEXT DATA SET.\n*    FOR ALL DATA SETS TO BE PROCESSED, BUILED THE TAPE DATA SET\n*    NAME AND CALCULATE THE SEQUENCE NUMBER.\n*\nPROCDS   EQU   *\n         MVC   SAVDSNAM,DS1DSNAM       SAVE THE DATA SET NAME\n         TM    DS1DSORG+1,DS1ACBM      VSAM FILE?\n         BO    PD05                    IF SO, BRANCH\n         CLI   VSAMONLY,C'Y'           VSAM ONLY?\n         BE    READIT                  IF SO, GO BACK FOR ANOTHER\n         TM    DS1DSORG,DS1DSGPS+DS1DSGPO  IS IT EITHER PS OR PO?\n         BM    PD30                    IF SO, GO AHEAD\n         B     IGNORE                  IF NEITHER, SKIP IT\nPD05     EQU   *\n         CLI   NOVSAM,C'Y'             IGNORE VSAM?\n         BE    READIT                  IF SO, LOOP BACK TO READ\n         LA    R7,SAVDSNAM             GET ADDRESS OF DATA SET NAME\n         LA    R8,L'SAVDSNAM           SET LOOP FOR MAX OF 44\nPD10     EQU   *\n         CLI   0(R7),C' '              LOOK FOR END OF NAME\n         BE    PD20                    IF FOUND, BRANCH\n         LA    R7,1(R7)                IF NOT, INCREMENT ADDRESS\n         BCT   R8,PD10                 AND LOOP\nPD20     EQU   *\n         S     R7,=F'5'                GO BACK 5 CHARACTERS\n         CLC   0(5,R7),=C'.DATA'       IS THIS THE DATA COMPONENT?\n         BNE   READIT                  IF NOT, SKIP IT\n         MVC   0(5,R7),=C'     '       IF SO, CLEAR OUT FOR CLUSTER\n         S     R7,=F'4'                GO BACK 5 MORE CHARACTERS\n         CLC   0(3,R7),=C'AIX'         IS THIS AN ALTERNATE INDEX?\n         BE    IGNORE                  IF SO, SKIP IT\nPD30     EQU   *\n         MVC   TAPEDSN,SAVDSNAM        BUILD TAPE DATA SET NAME\n         LA    R5,TAPEDSN\n         BAL   R2,NXTSPC               POINT TO END OF DATA SET NAME\n         MVI   0(R5),C'.'              TACK ON DATE GIVEN IN PARAMETERS\n         MVC   1(5,R5),DATE\n         MVC   6(3,R5),=C'EXP'\n         AP    SEQNUM,=P'1'            INCREMENT SEQUENCE NUMBER\n         UNPK  SEQ#,SEQNUM             UNPACK SEQUENCE NUMBER\n         MVZ   SEQ#+7(1),SEQ#+6        MOVE ZONE BYTE\n         LA    R6,SEQ#+4               LEFT JUSTIFY & SPACE FILL\n         MVI   NUM,X'40'               INIT NUMBER\n         MVC   NUM+1(L'NUM-1),NUM\n         LA    R7,NUM\n         LA    R8,4                    ONLY WORRY ABOUT LAST 4 DIGITS\nPD40     EQU   *\n         CLI   0(R6),C'0'              LEADING ZERO?\n         BNE   PD50                    IF NOT, GET IT\n         LA    R6,1(R6)                INCREMENT POINTER\n         BCT   R8,PD40                 LOOP THRU 4 CHARACTERS\n         B     PD60\nPD50     EQU   *\n         MVC   0(1,R7),0(R6)           IF SOMETHING ELSE, MOVE IT\n         LA    R7,1(R7)                INCREMENT POINTER\n         LA    R6,1(R6)                INCREMENT POINTER\n         BCT   R8,PD50                 LOOP THRU 4 CHARACTERS\nPD60     EQU   *\n         TM    DS1DSORG+1,DS1ACBM      VSAM FILE?\n         BO    VSAM                    IF SO, BRANCH TO VSAM SECTION\n         TM    DS1DSORG,DS1DSGPO       PARTITIONED DATA SET?\n         BNO   NONVSAM                 IF NOT, BRANCH\n*\n*  FOR PARTITIONED DATA SET, CALCULATE NUMBER OF DIRECTORY BLOCKS\n*\nPODS     EQU   *\n         LA    R9,PARTDS               GET ADDRESS OF DCB6\n         USING IHADCB,R9               ADDRESSIBILITY TO DCB\n         LA    R8,JFCBA2               GET ADDRESS OF BUFFER\n         ST    R8,EXLIST2              STORE ADDRESS IN EXIT LIST\n         MVI   EXLIST2,X'87'           SET END OF LIST & JFCB BYTE\n         LA    R6,EXLIST2              GET ADDRESS OF EXIT LIST\n         ST    R6,DCBEXLST             STORE IN DCB\n         DROP  R9\n         LR    R9,R8\n         RDJFCB (PARTDS,),MF=(E,EX1)   READ JOB FILE CONTROL BLOCK\n         USING INFMJFCB,R9             ESTABLISH ADDRESSABILITY\n         LTR   R15,R15                 CHECK RETURN CODE\n         BNZ   RETURN                  IF NOT SUCCESSFUL, EXIT\n         MVC   JFCBDSNM,SAVDSNAM       CHANGE DATASET NAME TO\n         OI    JFCBTSDM,JFCNWRIT       SET FLAG NOT TO WRITE BACK\n         DROP  R9\n         OPEN  (PARTDS,INPUT),TYPE=J,MF=(E,EX2) OPEN THE DATASET\n         LTR   R15,R15\n         BNZ   CLOSEX\n         SLR   R7,R7                   INITIALIZE R7\nPO10     EQU   *\n         READ  DECB,SF,PARTDS,DSCB2,'S',MF=E  READ THE 256-BYTE BLOCKS\n         CHECK DECB                    WAIT UNTIL I/O DONE\n         LA    R7,1(R7)                COUNT THE NUMBER OF BLOCKS\n         B     PO10\nPO20     EQU   *\n         L     R5,IDEAL#               GET IDEAL NUMBER OF DIR BLKS\n         LTR   R5,R5                   MAKE SURE IT'S NOT ZERO\n         BE    PO30                    IF IT IS, LEAVE IT ALONE\n         SLR   R6,R6                   CLEAR OUT R6 FOR THE REMAINDER\n         DR    R6,R5                   DIVIDE BY IDEAL NUMBER\n         LTR   R6,R6                   ANY REMAINDER?\n         BE    PO30                    IF NOT, BRANCH\n         LA    R7,1(R7)                IF SO, INCREMENT R7\n         SLR   R6,R6                   CLEAR OUT R6 FOR THE MULTIPLY\nPO30     EQU   *\n         MR    R6,R5                   MULTIPLY (RESULT WILL BE IN R7)\n         BAL   R2,CNVEBC               CONVERT # OF BLOCKS TO EBCDIC\n         MVC   DIRBLKS,WORK2           AND SAVE IT FOR LATER\n         CLOSE PARTDS,MF=(E,EX4)       CLOSE THE FILE\n*\n*  GENERATE JCL FOR NON-VSAM FILES (PO AND PS ONLY).\n*\nNONVSAM  EQU   *\n*\n*  CONVERT SECONDARY ALLOCATION TO PROPER VALUE FOR NEW DEVICE.\n*  CONVERT PARMS INTO EBCDIC - SECONDARY ALLOCATION, RECORD LENGTH,\n*    AND BLOCK LENGTH.\n*\n         TM    NEWDEV,X'0B'            ARE WE GOING TO A 3350?\n         BNO   NV03                    IF NOT, BRANCH\n         SLR   R6,R6                   CLEAR OUT R6\n         ICM   R6,B'0011',DS1BLKL      GET THE BLOCK SIZE\n         C     R6,=F'19069'            IS THE BLOCK SIZE TOO BIG?\n         BH    IGNORE                  IF SO, IGNORE IT\nNV03     EQU   *\n         STM   R1,R14,WORK3            SAVE REGISTERS\n         TRKCALC FUNCTN=TRKCAP,TYPE=DEVBUF+3,DD=DS1BLKL,R=1,MF=(E,EX5)\n         ST    R0,NUMBLKS              SAVE # OF BLKS/TRK (ORIG UNIT)\n         LM    R1,R14,WORK3            RESTORE REGISTERS\n         TRKCALC FUNCTN=TRKCAP,TYPE=NEWDEV,DD=DS1BLKL,R=1,MF=(E,EX5)\n         ST    R0,NUMBLKS2             SAVE # OF BLKS/TRK (NEW UNIT)\n         LTR   R15,R15\n         BNZ   IGNORE\n         LM    R1,R14,WORK3            RESTORE REGISTERS\n         MVC   TRKSPCYL(2),DEVBUF+10   SAVE # TRACKS / CYLINDER\n         MVI   WORK3,X'00'\n         MVC   WORK3+1(3),DS1SCALO+1   GET SECONDARY ALLOCATION\n         L     R7,WORK3\n         TM    DS1SCALO,X'C0'          IS ALLOCATION IN CYLINDERS?\n         BO    NV05                    IF SO, BRANCH\n         TM    DS1SCALO,X'40'          IS ALLOCATION IN BLOCKS?\n         BO    NV30                    IF SO, BRANCH\n         B     NV10                    ELSE, IT MUST BE TRACKS\nNV05     EQU   *\n         MH    R7,TRKSPCYL             CONVERT TO TRACKS\nNV10     EQU   *\n         SLR   R6,R6                   ZERO OUT R6 FOR MULTIPLY\n         M     R6,NUMBLKS              CONVERT TO NUMBER OF BLOCKS\n         SLR   R6,R6                   ZERO OUT R6 FOR DIVIDE\n         D     R6,NUMBLKS2             CONVERT TO TRACKS FOR NEW DEVICE\n         LTR   R6,R6                   ANY REMAINDER?\n         BZ    NV20                    IF NOT, BRANCH\n         LA    R7,1(R7)                IF SO, UP THE ALLOCATION\nNV20     EQU   *\n         TM    DS1SCALO,X'C0'          ALLOCATION IN CYLINDERS?\n         BNO   NV30                    IF NOT, ALL DONE\n         SLR   R6,R6                   ZERO OUT R6 FOR DIVIDE\n         D     R6,TRKPCYL2             CONVERT TO CYLINDERS FOR NEW DEV\n         LTR   R6,R6                   ANY REMAINDER?\n         BZ    NV30                    IF NOT, BRANCH\n         LA    R7,1(R7)                IF SO, UP THE ALLOCATION\nNV30     EQU   *\n         BAL   R2,CNVEBC               CONVERT TO EBCDIC\n         MVC   SECALLOC,WORK2          AND STORE\n         MVC   LRECL(2),=X'0000'       PUT RECORD LENGTH INTO\n         MVC   LRECL+2(2),DS1LRECL       A FULL WORD\n         L     R7,LRECL                GET RECORD LENGTH\n         BAL   R2,CNVEBC               CONVERT TO EBCDIC\n         MVC   RECLEN,WORK2            AND STORE\n         MVC   WORK3(2),DS1BLKL        GET BLOCK SIZE\n         SLR   R7,R7\n         LH    R7,WORK3\n         BAL   R2,CNVEBC               CONVERT TO EBCDIC\n         MVC   BLKSIZE,WORK2           AND STORE\n*\n*  CALCULATE PRIMARY ALLOCATION\n*\nCALCPRI  EQU   *\n         MVC   HIHH(2),DS1EXT1+8       SAVE UPPER TRACK\n         MVC   LOHH(2),DS1EXT1+4       SAVE LOWER TRACK\n         MVC   HICC(2),DS1EXT1+6       SAVE UPPER CYLINDER\n         MVC   LOCC(2),DS1EXT1+2       SAVE LOWER CYLINDER\n         LA    R5,ALLOC                GET ADDRESS TO BUILD ALLOC PARMS\n         MVI   ALLOC,X'40'             CLEAR THE BUFFER\n         MVC   ALLOC+1(L'ALLOC-1),ALLOC\n         SLR   R6,R6\n         LH    R6,HIHH                 GET UPPER TRACK\n         SLR   R7,R7\n         LH    R7,HICC                 GET UPPER CYLINDER\n         CH    R6,LOHH                 UPPER TRACK > LOWER TRACK?\n         BNL   CP10                    IF SO, BRANCH\n         SH    R7,=X'0001'             OTHERWISE, BORROW A CYLINDER\n         AH    R6,TRKSPCYL             AND ADD A CYL OF TRACKS\nCP10     EQU   *\n         SH    R7,LOCC                 UPPER CYL - LOWER CYL\n         MH    R7,TRKSPCYL             CONVERT TO TRACKS\n         SH    R6,LOHH                 UPPER TRK - LOWER TRK\n         AR    R7,R6                   ADD TOGETHER FOR TOTAL TRACKS\n         AH    R7,=X'0001'             ADJUSTMENT OF 1 TRACK\n         SLR   R6,R6                   ZERO OUT R6 FOR MULTIPLY\n         M     R6,NUMBLKS              CONVERT FROM TRACKS TO BLOCKS\n         TM    DS1SCALO,X'C0'          IS ALLOCATION IN CYLINDERS?\n         BO    CP20                    IF SO, BRANCH\n         TM    DS1SCALO,X'40'          IS ALLOCATION IN BLOCKS?\n         BNO   CP20                    IF NOT, BRANCH\n         MVC   0(8,R5),BLKSIZE         GET BLOCK SIZE\n         BAL   R2,NXTSPC\n         MVC   0(2,R5),=C',('\n         B     CP60\nCP20     EQU   *\n         SLR   R6,R6                   ZERO OUT R6 FOR DIVIDE\n         D     R6,NUMBLKS2             CONVERT FROM BLOCKS TO TRACKS\n         LTR   R6,R6                   ANY REMAINDER?\n         BZ    CP30                    IF NOT, BRANCH\n         LA    R7,1(R7)                IF SO, ADD ON ANOTHER TRACK\nCP30     EQU   *\n         TM    DS1SCALO,X'C0'          IS ALLOCATION IN CYLINDERS?\n         BO    CP40                    IF SO, BRANCH\n         MVC   0(5,R5),=C'TRK,('       INDICATE TRACKS\n         TM    DS1DSORG,DS1DSGPO       PARTITIONED DATA SET?\n         BNO   CP60                    IF NOT, BRANCH\n         C     R7,=F'1'                ONLY 1 TRACK?\n         BNE   CP60                    IF MORE, BRANCH\n         LA    R7,1(R7)                INCREASE BY 1\n         B     CP60                    AND CONTINUE\nCP40     EQU   *\n         SLR   R6,R6                   ZERO OUT R6 FOR DIVIDE\n         D     R6,TRKPCYL2             CONVERT FROM TRACKS TO CYLINDERS\n         LTR   R6,R6                   ANY REMAINDER?\n         BZ    CP50                    IF NOT, BRANCH\n         LA    R7,1(R7)                IF SO, ADD ON ANOTHER TRACK\nCP50     EQU   *\n         MVC   0(5,R5),=C'CYL,('       INDICATE CYLINDERS\nCP60     EQU   *\n         BAL   R2,CNVEBC               CONVERT TO EBCDIC\n         MVC   PRIALLOC,WORK2          AND STORE\n         TM    DS1DSORG,DS1DSGPO       PARTITIONED DATA SET?\n         BO    CNSTJCL                 IF SO, SKIP AHEAD\n*\n*  FIGURE OUT RECORD FORMAT\n*\nGETRECF  EQU   *\n         MVI   RECFMT,X'40'            CLEAR OUT RECORD FORMAT\n         MVC   RECFMT+1(L'RECFMT-1),RECFMT\n         LA    R6,RECFMT               GET STARTING ADDRESS\n         TM    DS1RECFM,X'C0'          UNDEFINED RECORD FORMAT?\n         BNO   GR10                    IF NOT, BRANCH\n         MVI   0(R6),C'U'              SET TO 'U' FOR UNDEFINED\n         B     GR30\nGR10     EQU   *\n         TM    DS1RECFM,X'80'          FIXED LENGTH RECORD?\n         BNO   GR20                    IF NOT, BRANCH\n         MVI   0(R6),C'F'              SET TO 'F' FOR FIXED BLOCKED\n         B     GR30\nGR20     EQU   *\n         TM    DS1RECFM,X'40'          VARIABLE LENGTH RECORD?\n         BNO   GR40                    IF NOT, BRANCH\n         MVI   0(R6),C'V'              SET TO 'V' FOR VARIABLE\nGR30     EQU   *\n         LA    R6,1(R6)                GO TO NEXT CHARACTER\nGR40     EQU   *\n         TM    DS1RECFM,X'10'          BLOCKED?\n         BNO   GR50                    IF NOT, BRANCH\n         MVI   0(R6),C'B'              SET TO 'B' FOR BLOCKED\n         LA    R6,1(R6)                GO TO NEXT CHARACTER\nGR50     EQU   *\n         TM    DS1RECFM,X'20'          TRACK OVERFLOW?\n         BNO   GR60                    IF NOT, BRANCH\n         MVI   0(R6),C'T'              SET TO 'T' FOR TRACK OVERFLOW\n         LA    R6,1(R6)                GO TO NEXT CHARACTER\nGR60     EQU   *\n         TM    DS1RECFM,X'08'          SPANNED OR STANDARD?\n         BNO   GR70                    IF NOT, BRANCH\n         MVI   0(R6),C'S'              SET TO 'S' FOR SPAN OR STANDARD\n         LA    R6,1(R6)                GO TO NEXT CHARACTER\nGR70     EQU   *\n         TM    DS1RECFM,X'04'          ASA CONTROL CHARACTER?\n         BNO   GR80                    IF NOT, BRANCH\n         MVI   0(R6),C'A'              SET TO 'A' FOR ASA CHARACTER\n         LA    R6,1(R6)                GO TO NEXT CHARACTER\nGR80     EQU   *\n         TM    DS1RECFM,X'02'          MACHINE CONTROL CHARACTER?\n         BNO   GR90                    IF NOT, BRANCH\n         MVI   0(R6),C'M'              SET TO 'M' FOR MACHINE CHARACTER\nGR90     EQU   *\n*\n*  FIGURE OUT TAPE BLOCK SIZE\n*\nGETTBLK  EQU   *\n         L     R7,=F'32760'\n         CLI   RECFMT,C'F'             FIXED RECORD LENGTH?\n         BNE   GB10                    IF NOT, BRANCH\n         SLR   R6,R6\n         D     R6,LRECL                GET INTEGER PART OF 32760/LRECL\n         M     R6,LRECL                AND MULTIPLY BY LRECL\nGB10     EQU   *\n         BAL   R2,CNVEBC               CONVERT TO EBCDIC\n         MVC   TBLKSIZE,WORK2          AND STORE\n*\n*  CONSTUCT JCL\n*\nCNSTJCL  EQU   *\n         MVC   LINE(2),=C'//'          GET READY FOR JCL LINES\n         MVC   LLABEL(4),=C'STEP'      START LINE1\n         MVC   LLABEL+4(L'NUM),NUM     GIVE STEP A SEQUENCE NUMBER\n         TM    DS1DSORG,DS1DSGPO       PARTITIONED DATA SET?\n         BNO   CJ10                    IF NOT, BRANCH\n         MVC   LCOL1(L'LINE1C),LINE1C  SET UP EXECUTE LINE FOR IEBCOPY\n         B     CJ20\nCJ10     EQU   *\n         MVC   LCOL1(L'LINE1B),LINE1B  SET UP EXECUTE LINE FOR IEBGENER\nCJ20     EQU   *\n         MVI   PRNTFLG,C'B'            SET FLAG TO OUTPUT TO BOTH\n         BAL   R3,PRINTIT              OUTPUT JCL LINES\n         MVC   LLABEL(L'LINE2A),LINE2A SET UP SYSPRINT LINE\n         BAL   R3,PRINTIT              OUTPUT TO BOTH FILES\n         MVC   LLABEL(6),=C'SYSUT2'    SET UP FIRST SYSUT2 LINE\n         MVC   LCOL1(L'LINE3A),LINE3A  ADD TAPE DATA SET NAME\n         MVC   LCOL1+L'LINE3A(L'TAPEDSN),TAPEDSN\n         LA    R5,LCOL1\n         BAL   R2,NXTSPC\n         MVI   0(R5),C','              END WITH A COMMA\n         MVI   PRNTFLG,C'E'            PUT THIS LINE IN EXPORT ONLY\n         BAL   R3,PRINTIT\n         MVC   LLABEL(6),=C'SYSUT1'    MODIFY TO SYSUT1 FOR IMPORT\n         MVI   PRNTFLG,C'I'            PUT INTO IMPORT FILE ONLY\n         BAL   R3,PRINTIT\n         MVC   LCOL2(L'LINE3B),LINE3B  ADD DATA SET DISPOSITION\n         MVI   PRNTFLG,C'E'            PUT THIS LINE IN EXPORT ONLY\n         BAL   R3,PRINTIT\n         MVC   LCOL2(L'LINE3C),LINE3C  CHANGE DISPOSITION\n         MVI   PRNTFLG,C'I'            PUT INTO IMPORT FILE ONLY\n         BAL   R3,PRINTIT\n         MVC   LCOL2(L'LINE4A),LINE4A  SET UP NEXT SYSUT2 LINE\n         MVC   LCOL2+L'LINE4A(L'LINE4B),LINE4B\n         LA    R5,LCOL2\n         CLI   REF,C' '                REFER BACK TO A PREVIOUS DD?\n         BNE   CJ30                    IF SO, BRANCH\n         MVC   REF(L'REFSYSUT),REFSYSUT  IF NOT, LOAD IT FOR NEXT TIME\n         B     CJ40\nCJ30     EQU   *\n         BAL   R2,NXTSPC\n         MVC   0(L'REF,R5),REF         REFER BACK TO PREVIOUS DD\nCJ40     EQU   *\n         BAL   R2,NXTSPC               FIND END OF LINE SO FAR\n         MVC   0(L'LINE4C,R5),LINE4C   ADD TAPE LABEL\n         MVC   L'LINE4C(L'NUM,R5),NUM  LOAD SEQUENCE NUMBER\n         TM    DS1DSORG,DS1DSGPO       PARTITIONED DATA SET?\n         BO    CJ45                    IF SO, SKIP COMMA\n         BAL   R2,NXTSPC\n         MVI   0(R5),C','\nCJ45     EQU   *\n         MVI   PRNTFLG,C'E'            PRINT IN EXPORT FILE ONLY\n         BAL   R3,PRINTIT\n         MVI   LLABEL,X'40'            CLEAR OUT LINE\n         MVC   LLABEL+1(77),LLABEL\n         MVC   LCOL2(L'LINE4B),LINE4B  SET UP SECOND SYSUT1 LINE\n         MVI   LCOL2+L'LINE4B,C')'\n         MVI   PRNTFLG,C'I'            PRINT IN IMPORT FILE ONLY\n         BAL   R3,PRINTIT\n         TM    DS1DSORG,DS1DSGPO       PARTITIONED DATA SET?\n         BO    CJ60                    IF SO, SKIP NEXT LINE\n         MVC   LCOL2(L'LINE5A),LINE5A  SET UP THIRD SYSUT2 LINE\n         MVC   LCOL2+L'LINE5A(L'TBLKSIZE),TBLKSIZE  GET TAPE BLK SIZE\n         LA    R5,LCOL2\n         BAL   R2,NXTSPC\n         MVC   0(L'LINE5B,R5),LINE5B   ADD TAPE DENSITY\n         CLI   RECLEN,X'40'            RECORD LENGTH OF ZERO?\n         BE    CJ50                    IF SO, BRANCH\n         MVC   L'LINE5B(L'LINE5C,R5),LINE5C  ADD RECORD LENGTH\n         MVC   L'LINE5B+L'LINE5C(L'RECLEN,R5),RECLEN\nCJ50     EQU   *\n         BAL   R2,NXTSPC\n         MVC   0(L'LINE5D,R5),LINE5D   ADD RECORD FORMAT\n         MVC   L'LINE5D(L'RECFMT,R5),RECFMT\n         BAL   R2,NXTSPC\n         MVI   0(R5),C')'              ADD ENDING PAREN\n         MVC   PRNTFLG,C'E'            OUTPUT INTO EXPORT FILE ONLY\n         BAL   R3,PRINTIT\n         MVI   LLABEL,C' '             CLEAR OUT LINE BUFFER\n         MVC   LLABEL+1(77),LLABEL\nCJ60     EQU   *\n         MVC   LLABEL(6),=C'SYSUT1'    SET UP FIRST SYSUT1 EXPORT LINE\n         MVC   LCOL1(L'LINE3A),LINE3A  PUT IN DATA SET NAME\n         MVC   LCOL1+L'LINE3A(L'SAVDSNAM),SAVDSNAM\n         LA    R5,LCOL1\n         BAL   R2,NXTSPC\n         MVI   0(R5),C','              PUT COMMA AT END\n         MVI   PRNTFLG,C'E'\n         BAL   R3,PRINTIT              PUT INTO EXPORT FILE ONLY\n         MVC   LLABEL(6),=C'SYSUT2'    CHANGE TO SYSUT2 FOR IMPORT\n         MVC   1(L'LINE3B,R5),LINE3B   ADD DISPOSITION\n         MVI   PRNTFLG,C'I'            PUT INTO IMPORT FILE ONLY\n         BAL   R3,PRINTIT\n         MVC   LCOL2(L'LINE7C),LINE7C   SET UP NEXT LINE FOR EXPORT\n         MVC   LCOL2+L'LINE7C(L'VOL),VOL  ADD VOLSER\n         MVC   LCOL2+L'LINE7C+L'VOL(L'LINE7D),LINE7D  ADD UNIT\n         MVC   LCOL2+L'LINE7C+L'VOL+L'LINE7D(L'TYPE),TYPE\n         MVI   PRNTFLG,C'E'            PUT INTO EXPORT FILE\n         BAL   R3,PRINTIT\n         CLI   NEWVOL,X'40'            NEW VOLUME FOR IMPORT?\n         BE    CJ70                    IF NOT, BRANCH\n         MVC   LCOL2+L'LINE7C(L'NEWVOL),NEWVOL  ADD NEW VOLSER\n         CLI   NEWUNIT,X'40'           NEW UNIT FOR IMPORT?\n         BE    CJ70                    IF NOT, BRANCH\n         MVC   LCOL2+L'LINE7C+L'NEWVOL+L'LINE7D(L'NEWUNIT),NEWUNIT\nCJ70     EQU   *\n         MVI   PRNTFLG,C'I'            PUT INTO IMPORT FILE\n         BAL   R3,PRINTIT\n         MVC   LCOL2(L'LINE6B),LINE6B  ADD DATA SET DISPOSITION\n         MVI   PRNTFLG,C'E'            PUT INTO EXPORT ONLY\n         BAL   R3,PRINTIT\n         MVI   LLABEL,X'40'            RESET THE LINE BUFFER\n         MVC   LLABEL+1(77),LLABEL       TO SPACES\n         MVC   LCOL2(L'LINE6C),LINE6C  ADD PROPER ALLOCATION\n         MVC   LCOL2+L'LINE6C(L'ALLOC),ALLOC\n         LA    R5,LCOL2\n         BAL   R2,NXTSPC\n         MVC   0(L'PRIALLOC,R5),PRIALLOC  ADD PRIMARY ALLOCATION\n         TM    DS1DSORG,DS1DSGPO          PARTITIONED DATA SET?\n         BO    CJ80                       LEAVE SPACE FOR SEC ALLOC\n         CLI   SECALLOC,X'40'             ANY SECONDARY ALLOCATION?\n         BE    CJ90                       IF NOT, BRANCH\nCJ80     EQU   *\n         BAL   R2,NXTSPC\n         MVI   0(R5),C','\n         MVC   1(L'SECALLOC,R5),SECALLOC  ADD SECONDARY ALLOCATION\nCJ90     EQU   *\n         BAL   R2,NXTSPC\n         TM    DS1DSORG,DS1DSGPO        PARTITIONED DATA SET?\n         BNO   CJ100                    IF NOT, END OF LINE\n         MVI   0(R5),C','               PUT IN ANOTHER COMMA\n         MVC   1(L'DIRBLKS,R5),DIRBLKS  ADD # OF DIRECTORY BLOCKS\n         BAL   R2,NXTSPC\nCJ100    EQU   *\n         MVC   0(2,R5),=C'))'\n         TM    DS1DSORG,DS1DSGPO        PARTITIONED DATA SET?\n         BO    CJ105                    IF SO, END OF LINE\n         MVI   2(R5),C','               IF NOT, ADD COMMA\nCJ105    EQU   *\n         MVI   PRNTFLG,C'I'             PUT INTO IMPORT FILE ONLY\n         BAL   R3,PRINTIT\n         TM    DS1DSORG,DS1DSGPO        PARTITIONED DATA SET?\n         BNO   CJ110                    IF NOT, BRANCH\n         MVC   LLABEL(L'LINE9A),LINE9A  SET UP SYSUT3 LINE\n         MVI   PRNTFLG,C'B'             PUT INTO BOTH FILES\n         BAL   R3,PRINTIT\n         MVC   LLABEL(L'LINE9B),LINE9B  SET UP SYSUT4 LINE\n         BAL   R3,PRINTIT               PUT INTO BOTH FILES\n         B     CJ130\nCJ110    EQU   *\n         MVC   LCOL2(L'LINE5A),LINE5A\n         LA    R5,LCOL2\n         BAL   R2,NXTSPC\n         MVC   0(L'BLKSIZE,R5),BLKSIZE  ADD BLOCK SIZE\n         BAL   R2,NXTSPC\n         CLI   RECLEN,X'40'             RECORD LENGTH PRESENT?\n         BE    CJ120                    IF NOT, BRANCH\n         MVC   0(L'LINE5C,R5),LINE5C    ADD RECORD LENGTH\n         MVC   L'LINE5C(L'RECLEN,R5),RECLEN\n         BAL   R2,NXTSPC\nCJ120    EQU   *\n         MVC   0(L'LINE5D,R5),LINE5D    ADD RECORD FORMAT\n         MVC   L'LINE5D(L'RECFMT,R5),RECFMT\n         BAL   R2,NXTSPC\n         MVI   0(R5),C')'\n         MVI   PRNTFLG,C'I'             PUT INTO IMPORT FILE ONLY\n         BAL   R3,PRINTIT\nCJ130    EQU   *\n         MVC   LLABEL(L'LINE8A),LINE8A  SET UP 'SYSIN DD DUMMY'\n         MVI   PRNTFLG,C'B'            PUT INTO BOTH FILES\n         BAL   R3,PRINTIT\n         B     GENCLIST                GO TO CREATE RECORD IN CLIST\n*\n*  GENERATE OUTPUT RECORDS FOR VSAM FILES.\n*\nVSAM     EQU   *\n         MVC   LINE(2),=C'//'          GET READY FOR JCL LINES\n         MVC   LLABEL(4),=C'STEP'      START LINE 1\n         MVC   LLABEL+4(L'NUM),NUM     GIVE STEP A SEQUENCE NUMBER\n         MVC   LCOL1(L'LINE1A),LINE1A  SET UP EXECUTE LINE\n         MVI   PRNTFLG,C'B'            SET FLAG TO OUTPUT TO BOTH\n         BAL   R3,PRINTIT              PRINT THE LINES\n         MVC   LLABEL(L'LINE2A),LINE2A SET UP SYSPRINT LINE\n         BAL   R3,PRINTIT              PRINT THE LINES\n         MVC   LLABEL(3),=C'DD1'       START DD1 LINE\n         MVC   LCOL1(L'LINE3A),LINE3A  INDICATE TAPE DATA SET NAME\n         MVC   LCOL1+L'LINE3A(L'TAPEDSN),TAPEDSN\n         LA    R5,LCOL1\n         BAL   R2,NXTSPC               FIND BLANK SPACE\n         MVI   0(R5),C','              INSERT COMMA\n         MVC   1(L'LINE3B,R5),LINE3B   ADD DATA SET DISPOSITION\n         MVI   PRNTFLG,C'E'            PRINT IN EXPORT FILE\n         BAL   R3,PRINTIT\n         MVC   1(L'LINE3C,R5),LINE3C   CHANGE DATA SET DISPOSITION\n         MVI   PRNTFLG,C'I'            PRINT IN IMPORT FILE\n         BAL   R3,PRINTIT\n         MVC   LCOL2(L'LINE4A),LINE4A  SET UP SECOND DD1 LINE\n         MVC   LCOL2+L'LINE4A(L'LINE4B),LINE4B  BY ADDING UNIT & VOL\n         LA    R5,LCOL2\n         CLI   REF,C' '                REFER BACK TO PREVIOUS?\n         BNE   VS10                    IF SO, BRANCH\n         MVC   REF(L'REFDD1),REFDD1    IF NOT, LOAD IT FOR NEXT TIME\n         B     VS20\nVS10     EQU   *\n         BAL   R2,NXTSPC\n         MVC   0(L'REF,R5),REF         REFER BACK TO PREVIOUS DD\nVS20     EQU   *\n         BAL   R2,NXTSPC               FIND END OF LINE SO FAR\n         MVC   0(L'LINE4C,R5),LINE4C   ADD TAPE LABEL\n         MVC   L'LINE4C(L'NUM,R5),NUM  LOAD SEQUENCE NUMBER\n         BAL   R2,NXTSPC\n         MVI   0(R5),C','\n         MVI   PRNTFLG,C'E'            PRINT IN EXPORT FILE\n         BAL   R3,PRINTIT\n         MVI   LLABEL,X'40'            CLEAR OUT LINE\n         MVC   LLABEL+1(77),LLABEL\n         MVC   LCOL2(L'LINE4B),LINE4B  SET UP SECOND DD1 FOR IMPORT\n         MVI   LCOL2+L'LINE4B,C')'     END WITH PAREN\n         MVI   PRNTFLG,C'I'            PRINT IN IMPORT FILE\n         BAL   R3,PRINTIT\n         MVC   LCOL2(L'LINE5A),LINE5A  SET UP THIRE DD1 FOR EXPORT\n         MVC   LCOL2+L'LINE5A(5),=C'32760'  SET TAPE BLOCK SIZE\n         MVC   LCOL2+L'LINE5A+5(L'LINE5B),LINE5B  SET TAPE DENSITY\n         MVI   LCOL2+L'LINE5A+5+L'LINE5B,C')'\n         MVC   PRNTFLG,C'E'            OUTPUT INTO EXPORT FILE ONLY\n         BAL   R3,PRINTIT\n         MVI   LLABEL,C' '             CLEAR OUT LINE BUFFER\n         MVC   LLABEL+1(77),LLABEL\n         CLI   NEWVOL,X'40'            NEW VOLUME SPECIFIED?\n         BE    VS30                    IF NOT, BRANCH\n         MVC   LLABEL(3),=C'DD2'       IF SO, SET UP SPECIAL DD2 LINE\n         MVC   LCOL1(L'LINE5E),LINE5E  GET THE UNIT INFORMATION\n         MVC   LCOL1+L'LINE5E(L'NEWUNIT),NEWUNIT\n         MVI   LCOL1+L'LINE5E+L'NEWUNIT,C','\n         LA    R5,LCOL1+L'LINE5E+L'NEWUNIT+1  CHANGE GEARS TO SHORTEN\n         MVC   0(L'LINE7C,R5),LINE7C   GET THE VOLUME\n         MVC   L'LINE7C(L'NEWVOL,R5),NEWVOL\n         MVC   L'LINE7C+L'NEWVOL(L'LINE5F,R5),LINE5F  FINISH LINE\n         MVI   PRNTFLG,C'I'             OUTPUT TO IMPORT ONLY\n         BAL   R3,PRINTIT               PRINT THE LINE\nVS30     EQU   *\n         MVC   LLABEL(L'LINE6A),LINE6A SET UP 'SYSIN DD *' LINE\n         MVI   PRNTFLG,C'B'            SET FLAG FOR BOTH\n         BAL   R3,PRINTIT              OUTPUT THE LINES\n         MVC   LINE(8),=C'  EXPORT'    SET UP 'SYSIN' LINE FOR EXPORT\n         MVC   LINE+9(L'SAVDSNAM),SAVDSNAM  LOAD DATA SET NAME\n         LA    R5,LINE+8\n         BAL   R2,NXTSPC\n         MVC   1(L'LINE7A,R5),LINE7A   LOAD REST OF 'SYSIN' LINE\n         MVC   PRNTFLG,C'E'            WRITE INTO EXPORT FILE ONLY\n         BAL   R3,PRINTIT\n         MVI   LLABEL,C' '             CLEAR OUT LINE\n         MVC   LLABEL+1(77),LLABEL\n         MVC   LINE(8),=C'  IMPORT'    SET UP 'SYSIN' LINE FOR IMPORT\n         MVC   LINE+9(11),=C'OUTDATASET('\n         MVC   LINE+20(L'SAVDSNAM),SAVDSNAM  ADD DATA SET NAME\n         LA    R5,LINE+20\n         BAL   R2,NXTSPC\n         MVC   0(L'LINE7B,R5),LINE7B   LOAD REST OF 'SYSIN' LINE\n         MVI   PRNTFLG,C'I'            WRITE INTO IMPORT FILE ONLY\n         CLI   NEWVOL,X'40'            SPECIAL VSAM REQUESTED?\n         BE    VS40                    IF NOT, BRANCH\n         BAL   R2,NXTSPC               FIND END OF LINE\n         MVI   1(R5),C'-'              AND INDICATE CONTINUED\n         BAL   R3,PRINTIT              WRITE THE LINE\n         LA    R5,LINE+9               POINT TO START FOR NEXT LINE\n         MVC   0(9,R5),=C'OBJECTS(('   START OUT NEXT LINE\n         MVC   9(L'SAVDSNAM,R5),SAVDSNAM  LOAD DATA SET NAME\n         BAL   R2,NXTSPC               FIND NEXT SPACE\n         MVC   1(L'LINE7E,R5),LINE7E   ADD VOLUME\n         MVC   1+L'LINE7E(L'NEWVOL,R5),NEWVOL\n         MVC   1+L'LINE7E+L'NEWVOL(L'LINE7F,R5),LINE7F  FINISH LINE\nVS40     EQU   *\n         BAL   R3,PRINTIT              PRINT THE LINE\n*\n*  CREATE RECORD FOR CLIST\n*\nGENCLIST EQU   *\n         MVC   CMDLINE(6),=C'DELETE'        SET UP CLIST LINE\n         MVC   CMDLINE+7(L'TAPEDSN),TAPEDSN   ADD TAPE DATA SET NAME\n         LA    R5,CMDLINE                     FIND NEXT SPACE\n         BAL   R2,NXTSPC\n         MVC   1(9,R5),=C'NOSCRATCH'          JUST DELETE FROM CATALOG\n         BAL   R3,PRINTC                    PRINT THE LINE\n         B     READIT\n*\n*  CLOSE FILES AND TERMINATE PROGRAM.\n*\nCLOSEX   EQU   *                       ERROR EXIT\n         LR    R7,R15                  SAVE CONTENTS OF R15\n         CLOSE (VTOC,,EXPORT,,IMPORT,,CLIST,,SYSPRINT),MF=(E,EX4)\n         LR    R15,R7                  RESTORE CONTENTS OF R15\n         B     RETURN\nCLOSE    EQU   *\n         MVC   CMDLINE(L'LSTLINE),LSTLINE  PUT LAST LINE INTO CLIST\n         BAL   R3,PRINTC\n         CLOSE (VTOC,,EXPORT,,IMPORT,,CLIST,,SYSPRINT),MF=(E,EX4)\n         SLR   R15,R15\nRETURN   EQU   *\n         FREEMAIN R,LV=LDATA,A=(13)    FREE DYNAMIC WORK AREA\n         L     R13,4(R13)              RESTORE REGISTERS\n         RETURN (14,12),RC=(15)        AND END\n*\n***********************************************************************\n*                                                                     *\n*                      SUBROUTINES                                    *\n*                                                                     *\n***********************************************************************\n*\n*  SUBROUTINE TO WRITE THE OUTPUT LINES INTO THE JCL DATA SETS\n*\nPRINTIT  EQU   *\n         CLI   PRNTFLG,C'I'            IMPORT ONLY?\n         BE    PI10                    IF SO, BRANCH\n         PUT   EXPORT,LINE             WRITE INTO EXPORT FILE\n         CLI   PRNTFLG,C'B'            IMPORT ALSO?\n         BNE   PI20                    IF NOT, BRANCH\nPI10     EQU   *\n         PUT   IMPORT,LINE             WRITE INTO IMPORT FILE\n         MVI   LLABEL,X'40'            RESET THE LINE BUFFER\n         MVC   LLABEL+1(77),LLABEL     TO SPACES\nPI20     EQU   *\n         BR    R3                      RETURN\n*\n*  SUBROUTINE TO PRINT THE CLIST\n*\nPRINTC   EQU   *\n         AP    LINE#,=P'100'           INCREMENT LINE NUMBER\n         UNPK  LINENO,LINE#            UNPACK LINE NUMBER\n         MVZ   LINENO+7(1),LINENO+6      & MOVE ZONE BYTE\n         LA    R5,CMDLINE\n         BAL   R2,NXTSPC               FIND LINE LENGTH\n         LA    R2,CLINE\n         SR    R5,R2                   CALCULATE LINE LENGTH\n         STH   R5,CLINE                  AND STORE\n         MVC   CLINE+2(2),=X'0000'\n         PUT   CLIST,CLINE             WRITE INTO CLIST FILE\n         MVI   CLINE,X'40'             RESET THE LINE BUFFER\n         MVC   CLINE+1(L'CLINE-1),CLINE  TO SPACES\n         BR    R3                      RETURN\n*\n*  SUBROUTINE TO POINT TO THE NEXT DATA POSITION IN THE OUTPUT LINE.\n*\nNXTSPC   EQU   *\n         LA    R5,1(R5)                INCREMENT POINTER\n         CLC   0(4,R5),=C'    '        CHECK FOR A SPACE\n         BNE   NXTSPC                  LOOP TIL SPACE FOUND\n         BR    R2                      RETURN\n*\n*  SUBROUTINE TO CONVERT FROM BINARY TO EBCDIC AND LEFT JUSTIFY.\n*\nCNVEBC   EQU   *\n         CVD   R7,PWORK                CONVERT TO PACKED DECIMAL\n         UNPK  WORK1,PWORK+3(5)        UNPACK RESULTS\n         MVZ   WORK1+7(1),WORK1+6      MOVE THE ZONE BYTE\n         MVI   WORK2,X'40'             CLEAR OUT OTHER WORK BUFFER\n         MVC   WORK2+1(L'WORK2-1),WORK2\n         LA    R6,WORK2                GET ADDRESSES FOR MOVE\n         LA    R8,WORK1\n         LA    R9,8                    MOVE MAX OF 8 CHARACTERS\nCE10     EQU   *\n         CLI   0(R8),C'0'              LEADING ZERO?\n         BE    CE30                    IF SO, BRANCH\nCE20     EQU   *\n         MVC   0(1,R6),0(R8)           MOVE A CHARACTER\n         LA    R6,1(R6)                INCREMENT POINTERS\n         LA    R8,1(R8)\n         BCT   R9,CE20                 AND LOOP TIL DONE\n         B     CE40\nCE30     EQU   *\n         LA    R8,1(R8)                INCREMENT ONE POINTER\n         BCT   R9,CE10                 AND LOOP\nCE40     EQU   *\n         BR    R2                      RETURN\n*\n***********************************************************************\n*                                                                     *\n*                     CONSTANT DATA                                   *\n*                                                                     *\n***********************************************************************\n*\n*  REGISTER EQUATES\n*\nR0       EQU   00\nR1       EQU   01\nR2       EQU   02\nR3       EQU   03\nR4       EQU   04\nR5       EQU   05\nR6       EQU   06\nR7       EQU   07\nR8       EQU   08\nR9       EQU   09\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n*\n         LTORG\n*\n*    THE FOLLOWING DATA IS USED TO INIT PART OF THE GETMAIN'ED AREA\n*\nCDATA    DS    0F\nISEQNUM  DC    P'00000000'\nILINE#   DC    P'00000000'\nIREF     DC    CL20' '\nDCB1     DCB   DDNAME=VTOC,DSORG=PS,RECFM=U,KEYLEN=44,BLKSIZE=96,      X\n               MACRF=(R),EODAD=CLOSE\nDCB2     DCB   DDNAME=EXPORT,DSORG=PS,RECFM=FB,LRECL=80,               X\n               MACRF=(PM)\nDCB3     DCB   DDNAME=IMPORT,DSORG=PS,RECFM=FB,LRECL=80,               X\n               MACRF=(PM)\nDCB4     DCB   DDNAME=CLIST,DSORG=PS,RECFM=VB,LRECL=255,               X\n               MACRF=(PM)\nDCB5     DCB   DDNAME=SYSPRINT,DSORG=PS,RECFM=FB,LRECL=132,            X\n               MACRF=(PM)\nDCB6     DCB   DDNAME=VTOC,DSORG=PS,KEYLEN=8,BLKSIZE=256,              X\n               MACRF=(R),EODAD=PO20\nLIST1    RDJFCB (,),MF=L\nLIST2    OPEN   (,),MF=L\nLIST3    CVAFSEQ ACCESS=GT,IXRCDS=KEEP,BRANCH=NO,MF=L\nLIST4    CLOSE  (,),MF=L\nLIST5    TRKCALC MF=L\nLIST6    READ   DECB1,SF,MF=L\nMOVEL    EQU   *-CDATA\n*\n*\n*  MISCELLANEOUS CONSTANTS\n*\nLINE1A   DC    C'EXEC PGM=IDCAMS'\nLINE1B   DC    C'EXEC PGM=IEBGENER'\nLINE1C   DC    C'EXEC PGM=IEBCOPY'\nLINE2A   DC    C'SYSPRINT DD SYSOUT=*'\nLINE3A   DC    C'DD DSN='\nLINE3B   DC    C'DISP=(,CATLG),'\nLINE3C   DC    C'DISP=(OLD,PASS),'\nLINE4A   DC    C'UNIT=TAPE62,'\nLINE4B   DC    C'VOL=(,RETAIN'\nLINE4C   DC    C'),LABEL='\nLINE5A   DC    C'DCB=(BLKSIZE='\nLINE5B   DC    C',DEN=4'\nLINE5C   DC    C',LRECL='\nLINE5D   DC    C',RECFM='\nLINE5E   DC    C'DD UNIT='\nLINE5F   DC    C',DISP=SHR'\nLINE6A   DC    C'SYSIN    DD *'\nLINE6B   DC    C'DISP=(OLD,DELETE,KEEP)'\nLINE6C   DC    C'SPACE=('\nLINE7A   DC    C'OUTFILE(DD1) PURGE PERMANENT'\nLINE7B   DC    C') INFILE(DD1)'\nLINE7C   DC    C'VOL=SER='\nLINE7D   DC    C',UNIT='\nLINE7E   DC    C'VOLUMES('\nLINE7F   DC    C') FILE(DD2)))'\nLINE8A   DC    C'SYSIN    DD DUMMY'\nLINE9A   DC    C'SYSUT3   DD UNIT=SYSDA,SPACE=(CYL,(2,1))'\nLINE9B   DC    C'SYSUT4   DD UNIT=SYSDA,SPACE=(CYL,(2,1))'\nREFDD1   DC    C',REF=*.STEP1.DD1'\nREFSYSUT DC    C',REF=*.STEP1.SYSUT2'\nVTOCLBL  DC    CL8'VTOC'\nFSTLINE  DC    C'PROC 0'\nSNDLINE  DC    C'CONTROL LIST NOFLUSH PROMPT MSG'\nLSTLINE  DC    C'END'\nAIXLINE  DC    C'THE FOLLOWING DATA SETS WILL NOT BE EXPORTED:'\n*\n***********************************************************************\n*                                                                     *\n*                    DSECTS FOR GETMAIN'ED AREA                       *\n*                                                                     *\n***********************************************************************\nWORKAREA DSECT\nSAVEAREA DS    18F\n*\nLINE     DS    0CL80\n         DS    CL2\nLLABEL   DS    CL8\n         DS    CL1\nLCOL1    DS    CL2\n         DS    CL1\nLCOL2    DS    CL66\n*\nCLINE    DS    0CL255\n         DS    CL2\nLINENO   DS    CL8\nCMDLINE  DS    CL245\n*\nSPLINE   DS    0CL132\n         DS    CL5\nSPDSN    DS    CL127\n*\nALLOC    DS    CL10\nBLKSIZE  DS    CL8\nDATE     DS    CL5\nDIRBLKS  DS    CL8\nNEWUNIT  DS    CL4\nNEWVOL   DS    CL6\nNUM      DS    CL4\nPRNTFLG  DS    CL1\nPARMBUF  DS    CL20\nPARTREC  DS    CL256\nPRIALLOC DS    CL8\nRCODE    DS    CL1\nRECFMT   DS    CL4\nRECLEN   DS    CL8\nSAVDSNAM DS    CL44\nSECALLOC DS    CL8\nSEQ#     DS    CL8\nTAPEDSN  DS    CL44\nTBLKSIZE DS    CL8\nTYPE     DS    CL5\nVSAMONLY DS    CL1\nNOVSAM   DS    CL1\nVOL      DS    CL6\nWORK1    DS    CL8\nWORK2    DS    CL8\nDSCB     DS    XL140\nJFCBA    DS    XL176\nDSCB2    DS    XL140\nJFCBA2   DS    XL176\nNEWDEV   DS    1X\nHICC     DS    1H\nLOCC     DS    1H\nHIHH     DS    1H\nLOHH     DS    1H\nTRKSPCYL DS    1H\nTRKPCYL2 DS    1F\nDEBADDR  DS    1F\nEXLIST   DS    1F\nEXLIST2  DS    1F\nDEVBUF   DS    5F\nLRECL    DS    1F\nNUMBLKS  DS    1F\nNUMBLKS2 DS    1F\nIDEAL#   DS    1F\nWORK3    DS    7D\nPWORK    DS    1D\nBUFLIST  ICVAFBFL DSECT=NO\nBUFLEN   EQU   *-BUFLIST\n*\nDATA     DS    0F\nSEQNUM   DS    P'00000000'\nLINE#    DS    P'00000000'\nREF      DS    CL20\nVTOC     DCB   DDNAME=VTOC,DSORG=PS,RECFM=U,KEYLEN=44,BLKSIZE=96,      X\n               MACRF=(R),EODAD=CLOSE\nEXPORT   DCB   DDNAME=EXPORT,DSORG=PS,RECFM=FB,LRECL=80,               X\n               MACRF=(PM)\nIMPORT   DCB   DDNAME=IMPORT,DSORG=PS,RECFM=FB,LRECL=80,               X\n               MACRF=(PM)\nCLIST    DCB   DDNAME=CLIST,DSORG=PS,RECFM=VB,LRECL=255,               X\n               MACRF=(PM)\nSYSPRINT DCB   DDNAME=SYSPRINT,DSORG=PS,RECFM=FB,LRECL=132,            X\n               MACRF=(PM)\nPARTDS   DCB   DDNAME=VTOC,DSORG=PS,KEYLEN=8,BLKSIZE=256,              X\n               MACRF=(R),EODAD=PO20\nEX1      RDJFCB (,),MF=L\nEX2      OPEN   (,),MF=L\nEX3      CVAFSEQ ACCESS=GT,IXRCDS=KEEP,BRANCH=NO,MF=L\n         ORG   EX3\nCVPLMAP  ICVAFPL DSECT=NO\nEX4      CLOSE  (,),MF=L\nEX5      TRKCALC MF=L\nEX6      READ   DECB,SF,MF=L\n*\nLDATA    EQU   *-WORKAREA\n*\n*\nDSCB1    DSECT\n         IECSDSL1 1\nDSCBLTH  EQU   *-DSCB1-L'DS1DSNAM\nJFCB     DSECT\n         IEFJFCBN ,\nDCBSECT  DSECT\n         DCBD  DSORG=PS,DEVD=DA\n         END   EXIMPORT\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "IGGPRE00": {"ttr": 1286, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         TITLE 'IGGPRE00 -DF/DS ALLOCATE PRE PROCCESSING EXIT TESTER'\n*\n*        ATTRIBUTES:  RENT REUS\n*        REGISTER USAGE:\n*        R0\n*        R1    ON ENTRY, ADDRESS OF EXIT PARAMETER LIST\n*        R2    EXIT PARAMETER LIST BASE REG\n*        R3    JFCB DSECT BASE\n*        R4    WORK\n*        R5    WORK\n*        R6    WORK\n*        R7    WORK\n*        R8    WORK\n*        R9    WORK\n*        R10   WORK\n*        R11   WORK\n*        R12   PROGRAM BASE REG\n*        R13   SAVE AREA POINTER\n*        R14   RETURN ADDRESS\n*        R15   RETURN CODES: 0 = ALLOW ALLOCATE\n*                            4 = CONDITIONAL REJECTION (THIS VOLUME)\n*                            8 = UNCONDITIONAL REJECTION\n*\n*        MACROS:\n*              SAVE\n*              GETMAIN\n*              FREEMAIN\n*              RETURN\n*              EQUATE        DELUXE REGISTER EQUATES\n*              IECIEXPL      PRE/POST PARAMETER LIST MAP\n*              IEFJFCBN      JFCB MAPPING\n*              CVT           CVT MAPPING\n*              IEFASIOT      SIOT MAPPING\n*              IEFASCTB      SCT MAPPING\n*              IKJTCB        TCB MAPPING\n*              IEZJSCB       JSCB MAPPING\n*              IHARB         RB (PRB,SVRB) MAPPING\n*              IEFZB4D0      SVC 99 (DYNALLOC) PARAMETER LIST MAPPING\n*              IEFZB4D2      SVC 99 (DYNALLOC) TEXT UNIT KEYS MAPPING\n*\nIGGPRE00 CSECT\n         SAVE  (14,12),,IGGPRE00_DFDS_ALLOC_PRE_TEST_&SYSDATE_&SYSTIME\n         LR    R12,R15                  PROGRAM ADDRESSABILITY\n         USING IGGPRE00,R12             TELL ASSEMBLER\n         LR    R2,R1                    SAVE PARM LIST ADDRESS IN R2\n         USING IEXPL,R2                 TELL ASSEMBLER\n         CLI   IEXFUNC,IEXALL           IS THIS ALLOCATE?\n         BNE   RETURN                   QUICK RETURN\n         CLI   IEXFLAG,IEXVIO           IS THIS VIO REQUEST?\n         BE    RETURN                   QUICK RETURN\n         L     R3,IEXPTR1               ADDRESS OF JFCB\n         USING JFCBDSCT,R3              TELL ASSEMBLER\n         CLI   JFCDSRG2,JFCORGAM        IS THIS VSAM?\n         BE    RETURN                   ALLOW IT\n         LH    R11,MAXBLKSI             MAXIMUM BLKSIZE TO R11\n         CH    R11,JFCBLKSI             FOR COMPARE WITH JFCBLKSI\n         BNL   RETURN                   LESS OR EQUAL MAX IS OK\n         CH    R11,JFCLRECL             SEE IF LRECL IS HIGH\n         BNL   CHKUNIT                  GO SEE WHAT UNIT NAME IS\n         B     RETURN                   ALLOW EXCEPTION CONDITION\n         DROP  R2,R3\nCHKUNIT  EQU   *                        FIND OUT WHAT UNITNAME IS\n         L     R0,SIZDATD               DYNAMIC AREA SIZE TO R0\n         GETMAIN R,LV=(0)               GETMAIN DYNAMIC AREA\n         LR    R2,R1                    DYNAMIC AREA ADDRESSABILITY\n         USING DATD,R2                  TELL ASSEMBLER\n         MVC   WTOE(WTOLEN),WTOLIST     PRIME WTO AREA\n         L     R4,16                    ADDRESS OF CVT\n         L     R4,0(R4)                 ADDRESS OF TCB ADDRESS WORDS\n         L     R4,4(R4)                 ADDRESS OF CURRENT TCB\n         L     R5,TCBRBP-TCB(R4)        ADDRESS OF CURRENT RB\nRBLOOP   EQU   *\n         LR    R6,R5                    R6 POINTS TO RBBASIC\n         SL    R5,=F'2'                 POINT TO INT CODE RBBASIC-2\n         CLC   0(2,R5),=X'0020'         SVC 32?\n         BNE   RBBUMP                   NO GO TO NEXT RB\n         L     R7,RBGRS1-RBBASIC(R6)    SAVE R1 - PTR TO SVC99 PLIST\n         L     R5,RBLINK-RBBASIC(R6)    BUMP TO NEXT RB\n         SL    R5,=F'2'                 POINT TO INT CODE RBBASIC-2\n         CLC   0(2,R5),=X'0063'         SVC99\n         BE    ISSVC99                  MUST BE A DYNALLOC\n         B     NOTSVC99                 MUST NOT BE DYNALLOC\nRBBUMP   EQU   *\n         L     R5,RBLINK-RBBASIC(R6)    BUMP TO NEXT RB\n         CLR   R4,R5                    IS IT THE TCB\n         BE    NOTSVC99                 NOT DYNALLOC\n         B     RBLOOP                   TRY NEXT RB\nISSVC99  EQU   *                        FIND DYNALLOC TEXT UNIT PTRS\n         L     R4,S99RBPTR-S99RBP(R7)   POINT TO SVC99 RB\n         L     R5,S99TXTPP-S99RB(R4)    POINT TO LIST OF TEXT UNIT PTRS\n         LR    R6,R5                    R6 WILL POINT TO CURRENT TUP\n         USING S99TUPL,R6               TELL ASSEMBLER\n         LA    R10,DALUNIT              UNITNAME KEY FOR COMPARE\nS99LOOP  EQU   *\n         L     R7,S99TUPTR              ADDRESS OF TEXT UNIT\n         USING S99TUNIT,R7              TELL ASSEMBLER\n         LTR   R7,R7                    NULL PARAMETER?\n         BZ    S99BUMP                  GO GET NEXT\n         CH    R10,S99TUKEY             UNITNAME KEY?\n         BNE   S99BUMP                  GO GET NEXT\n         CLI   S99TUPAR,C'3'            GENERIC DISKS START WITH A \"3\"\n         BE    RETURNF                  ALLOW ALLOCATION\n         B     WTOIT                    GO FAIL THE ALLOCATION\nS99BUMP  EQU   *\n         TM    S99TUPTR,S99TUPLN        LAST TEXT UNIT POINTER?\n         BO    RETURNF                  ALLOW ALLOCATION\n         LA    R6,4(R6)                 BUMP TO NEXT POINTER\n         B     S99LOOP\nNOTSVC99 EQU   *                        FIND OUT WHAT UNITNAME IS\n         L     R4,16                    ADDRESS OF CVT\n         L     R4,CVTJESCT-CVTMAP(R4)   ADDRESS OF JESCT\n         L     R4,JESEDT-JESCT(R4)      ADDRESS OF EDT\n         L     R4,0(R4)                 ADDRESS OF NAME TABLE\n         LM    R10,R11,0(R4)            LOAD # NAMES AND NAME LENGTH\n         LA    R4,8(R4)                 POINT AT FIRST NAME\n         L     R6,16                    ADDRESS OF CVT\n         L     R6,0(R6)                 ADDRESS OF TCB ADDRESS WORDS\n         L     R6,4(R6)                 ADDRESS OF CURRENT TCB\n         L     R6,TCBJSCB-TCB(R6)       ADDRESS OF JSCB\n         L     R6,JSCBACT-IEZJSCB(R6)   ADDRESS OF ACTIVE JSCB\n         L     R6,JSCSCT-IEZJSCB(R6)    ADDRESS OF SCT\n         LA    R6,16(R6)                PASS THE PREFIX\n         L     R7,SCTFSIOT-INSMSCT(R6)  ADDRESS OF FIRST SIOT AAAZ\n         SRL   R7,8                     SHIFT RIGHT ONE BYTE\n         LA    R7,16(R7)                PASS THE PREFIX\n         L     R8,SCTLSIOT-INSMSCT(R6) ADDRESS OF LAST SIOT AAAZ\n         SRL   R8,8                     SHIFT RIGHT ONE BYTE\n         LA    R8,16(R8)                PASS THE PREFIX\nSIOTLOOP EQU   *\n         L     R9,SCTPJFCB-INDMSIOT(R7) ADDRESS OF JFCB AAAZ\n         SRL   R9,8                     SHIFT RIGHT ONE BYTE\n         LA    R9,16(R9)                PASS THE PREFIX\n         CLR   R3,R9                    RIGHT JFCB = RIGHT SIOT\n         BNE   SIOTBUMP                 TRY ANOTHER\n         B     NAMELOOP                 FIND ESOTERIC NAME\nSIOTBUMP EQU   *\n         CLR   R7,R8                    WAS THIS THE LAST ONE?\n         BE    RETURNF                  YES GET OUT\n         L     R7,SCTPSIOT-INDMSIOT(R7) GET NEXT SIOT ADDR AAAZ\n         SRL   R7,8                     SHIFT RIGHT ONE BYTE\n         LA    R7,16(R7)                PASS THE PREFIX\n         B     SIOTLOOP                 TRY AGAIN\nNAMELOOP EQU   *\n         CLC   SIOTDEVT-INDMSIOT(4,R7),8(R4) IS THE DEVTYPE THE SAME\n         BNE   NAMEBUMP                 NO GO GET NEXT ONE\n         CLI   0(R4),C'3'               GENERIC DISKS START WITH A \"3\"\n         BE    RETURNF                  ALLOW ALLOCATION\n         MVC   WTOE+78(8),4(R7)         MOVE IN DDNAME\n         B     WTOIT\nNAMEBUMP LA    R4,0(R11,R4)             ADD LENGTH OF ENTRY\n         BCT   R10,NAMELOOP             NOT FOUND, TRY AGAIN\n         B     RETURNF\nRETURN   SLR   R15,R15                  SET RC=0\nRETURNX  RETURN (14,12),RC=(15)         RETURN TO CONTROL PROGRAM\nRETURNF  L     R0,SIZDATD               DYNAMIC AREA SIZE TO R0\n         LR    R1,R2                    DYNAMIC AREA ADDRESS TO R1\n         FREEMAIN R,LV=(0),A=(1)        FREEMAIN DYNAMIC AREA\n         B     RETURN                   ALLOW ALLOCATION\nWTOIT    WTO   MF=(E,WTOE)\n         L     R0,SIZDATD               DYNAMIC AREA SIZE TO R0\n         LR    R1,R2                    DYNAMIC AREA ADDRESS TO R1\n         FREEMAIN R,LV=(0),A=(1)        FREEMAIN DYNAMIC AREA\n         LA    R15,8                    SET RETURN CODE 8\n         LA    R15,0(R15)               CLEAR HI ORDER BIT\n         B     RETURNX                  FAIL ALLOCATION\n         DROP  R2\nMAXBLKSI DC    H'6233'                  MAXIMUM BLKSIZE\n         CNOP  0,4\nTTAB     DC    240X'00'\n         DC    C'0123456789ABCDEF'\nWTOLIST  WTO   'DLXPRE00  ALLOCATION FAILED BY INSTALLATION EXIT - DCB +\n               BLKSIZE TOO LARGE.          ',ROUTCDE=(11),DESC=(7),    +\n               MCSFLAG=HRDCPY,MF=L\nENDWTOL  EQU   *\nWTOLEN   EQU   ENDWTOL-WTOLIST\n         CNOP  0,4\nSIZDATD  DC    AL1(0)                   DYNAMIC AREA SIZE\n         DC    AL3(ENDDATD-DATD)        END MINUS BEGINNING ADRESS\n         LTORG\n         EQUATE\nDATD     DSECT                          DYNAMIC AREA\nWTOE     WTO   'DLXPRE00  ALLOCATION FAILED BY INSTALLATION EXIT - DCB +\n               BLKSIZE TOO LARGE.          ',ROUTCDE=(11),DESC=(7),    +\n               MCSFLAG=HRDCPY,MF=L\nENDDATD  EQU   *\nIEXPL    IECIEXPL DSECT=YES\nJFCBDSCT DSECT\n         IEFJFCBN\n         IEFJESCT\n         CVT\n         IEFASIOT\n         IEFASCTB\n         IKJTCB\n         IEZJSCB\n         IHARB\n         IEFZB4D0\n         IEFZB4D2\n         END   IGGPRE00\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "INMRZ01": {"ttr": 1290, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         TITLE 'INMRZ01' - RECEIVE INITIALIZATION EXIT\n***********************************************************************\n*                                                                     *\n*             MODULE NAME = INMRZ01                                   *\n*                                                                     *\n*             DESCRIPTIVE NAME = RECEIVE INITIALIZATION EXIT          *\n*                                                                     *\n*             FUNCTION =                                              *\n*                EXIT ALLOWS AUTHORIZATION CHECKING FOR USER          *\n*                IDS EXECUTING RECEIVE IN BACKGROUND.                 *\n*                                                                     *\n*                OPERATION =                                          *\n*                   SAVE REGISTERS AND ESTABLISH ADDRESSABILITY       *\n*                   GET ASCB ADDRESSABILITY                           *\n*                   IF REQUEST IS FROM TSO USER,                      *\n*                     EXIT WITH RC=0                                  *\n*                   GET ASXB ADDRESSABILITY                           *\n*                   DROP ASCB ADDRESSABILITY                          *\n*                   GET ACEE ADDRESSABILITY                           *\n*                   DROP ASXB ADDRESSABILITY                          *\n*                   IF USER HAS SPECIAL ATTRIBUTE,                    *\n*                     SET BYPASS AUTHORIZATION CHECKING FLAG          *\n*                     EXIT WITH RC=0                                  *\n*                   IF USERID MATCHES RECEIVE USERID,                 *\n*                     EXIT WITH RC=0                                  *\n*                   GET DYNAMIC WORK AREA FOR RACF MACRO              *\n*                   TRY TO LOCATE USERID IN RACF FILE                 *\n*                   IF USERID FOUND,                                  *\n*                     EXIT WITH RC=4                                  *\n*                   IF USERID NOT FOUND,                              *\n*                     SET BYPASS AUTHORIZATION CHECKING FLAG          *\n*                     EXIT WITH RC=0                                  *\n*                                                                     *\n*              NOTES =                                                *\n*                                                                     *\n*                 REGISTER CONVENTIONS = STANDARD CONVENTIONS.        *\n*                    REGISTER  1       = PARAMETER LIST POINTER       *\n*                    REGISTER  2       = ASCB AND LATER TCB           *\n*                                        ADDRESSABILITY AND           *\n*                                        WORK REGISTER                *\n*                    REGISTER  3       = ASXB AND LATER TIOT          *\n*                                        ADDRESSABILITY AND           *\n*                                        WORK REGISTER                *\n*                    REGISTERS 4 - 10  = WORK REGISTERS               *\n*                    REGISTER  11      = ACEE ADDRESSABILITY          *\n*                    REGISTER  12      = BASE REGISTER                *\n*                    REGISTER  13      = SAVE AREA POINTER            *\n*                    REGISTER  14      = RETURN ADDRESS               *\n*                    REGISTER  15      = ENTRY POINT ADDRESS AND      *\n*                                        RETURN CODE REGISTER         *\n*                                                                     *\n*             MACROS =                                                *\n*                SAVE, RETURN, EQUATE, GETMAIN, FREEMAIN, ICHEINTY    *\n*                                                                     *\n*             MAPPING MACROS USED =                                   *\n*                IHAACEE       ACEE MAP                               *\n*                IHAASCB       ASCB MAP                               *\n*                IHAASXB       ASXB MAP                               *\n*                                                                     *\n*                                                                     *\n*             CHANGE ACTIVITY =                                       *\n*                02/07/84  WRITTEN.      BC.                          *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n*\nINMRZ01 CSECT\n         SAVE  (14,12),,INMRZ01_DELUXE_CHECK_&SYSDATE_&SYSTIME\n         LR    R12,R15\n         USING INMRZ01,R12             ESTABLISH ADDRESSABILITY\n         LR    R7,R1                   PRESERVE PTR TO PARMS\n*\n*  CHECK TO SEE IF THIS IS A BATCH JOB.  IF IT ISN'T, EXIT.\n*\nBTCHCHK  EQU   *\n         L     R2,16                   GET ADDRESS OF CVT\n         L     R2,0(R2)                GET ADDR OF TCB ADDRESS WORD\n         L     R2,12(R2)               GET ADDRESS OF CURRENT ASCB\n         USING ASCB,R2                 TELL ASSEMBLER\n         L     R3,ASCBTSB              GET ADDRESS OF TSB\n         LTR   R3,R3                   IF NOT ZERO,\n         BNZ   EXIT                      THIS IS A TSO USER\n*\n*  IF USER HAS SPECIAL ATTRIBUTE, EXIT WITHOUT FURTHER CHECKING\n*\n         L     R3,ASCBASXB             GET ADDRESS OF ASXB\n         DROP  R2\n         USING ASXB,R3                 TELL ASSEMBLER\n         L     R11,ASXBSENV            GET ADDRESS OF ACEE\n         DROP  R3                      DROP ASXB ADDRESSABILITY\n         USING ACEE,R11                ESTABLISH ADDRESSABILITY TO ACEE\n         TM    ACEEFLG1,ACEESPEC       USER HAVE SPECIAL ATTRIBUTE?\n         BNO   CHKMTCH                 IF NOT, CHECK FURTHER\n         L     R5,8(R7)                GET ADDRESS TO FLAGS\n         OI    0(R5),X'08'             SET BYPASS AUTH CHECKING FLAG\n         B     EXIT                    AND EXIT\n*\n*  IF USERID MATCHES RECEIVE USERID, EXIT WITH RC=0\n*\nCHKMTCH  EQU   *\n         L     R5,24(R7)               GET ADDRESS OF USERID FIELD\n         L     R6,28(R7)               GET ADDR OF RECEIVE USERID\n         CLC   0(8,R5),0(R6)           ARE THEY THE SAME?\n         BNE   LOCUSER                 IF NOT, CHECK FURTHER\n         B     EXIT                    IF MATCH, EXIT\n*\n*  IF USERID IS DEFINED TO RACF, EXIT WITH RC=4.  OTHERWISE,\n*    SET THE BYPASS AUTHORIZATION CHECKING FLAG AND EXIT WITH\n*    RC=0.\n*\nLOCUSER  EQU   *\n         GETMAIN R,LV=LAREA            GET DYNAMIC WORK AREA\n         LR    R10,R1                  PRESERVE POINTER TO AREA\n         USING WORKAREA,R10            ESTABLISH ADDRESSABILITY\n         MVC   EXLOC(LDATA),DATA       MOVE DATA INTO WORK AREA\n         LA    R3,8                    LOAD LENGTH OF USERID\n         MVC   USERID+1(8),0(R6)       LOAD RECEIVE USERID\n         LA    R4,USERID+8             POINT TO LAST POSSIBLE CHAR\nLU10     EQU   *\n         CLI   0(R4),X'40'             LOOK FOR LAST ACTUAL CHAR IN ID\n         BNE   LU20                    WHEN FOUND, BRANCH\n         BCTR  R4,0                    MOVE POINTER BACK\n         BCT   R3,LU10                 CHECK PREVIOUS CHARACTER\nLU20     EQU   *\n         STCM  R3,B'0001',USERID\n         LA    R3,LOCAEND-LOCAREA\n         ST    R3,LOCAREA\n         ICHEINTY LOCATE,TYPE='USR',ENTRY=USERID,                      X\n               WKAREA=LOCAREA,MF=(E,EXLOC)\n         LR    R3,R15                  SAVE RETURN CODE\n         FREEMAIN R,LV=LAREA,A=(10)    FREE THE GETMAINED AREA\n         LTR   R3,R3                   USER FOUND?\n         BZ    LU30                    IF SO, BRANCH\n         L     R5,8(R7)                GET ADDRESS TO FLAGS\n         OI    0(R5),X'08'             SET BYPASS AUTH CHECKING FLAG\n         B     EXIT                    AND EXIT\nLU30     EQU   *\n         LA    R15,4                   SET RC = 4\n         B     EXITX                   AND EXIT\n*\n*  EXIT THE EXIT\n*\nEXIT     EQU   *\n         SLR   R15,R15                 SET RETURN CODE TO ZERO\nEXITX    EQU   *\n         RETURN (14,12),RC=(15)        END THE EXIT\n*\n         LTORG\n*\n*  REGISTER EQUATES\n*\n         EQUATE\n*\n*  INITIAL DATA FOR WORK AREA\n*\nDATA    ICHEINTY LOCATE,TYPE='USR',MF=L\nLDATA   EQU  *-DATA\n*\n*  WORK AREA DESECT\n*\nWORKAREA DSECT\n*\nEXLOC   ICHEINTY LOCATE,TYPE='USR',MF=L\nUSERID  DS   AL1\n        DS   CL8\nLOCAREA DS   F\n        DS   CL24\n        DS   F\nLOCAEND EQU  *\nLAREA   EQU  *-WORKAREA\n*\n*  DSECTS\n*\n         IHAACEE\n         IHAASCB\n         IHAASXB\n*\n         END   INMRZ01\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "INMRZ11": {"ttr": 1537, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         TITLE 'INMRZ11' - RECEIVE PRE-PROCESSING EXIT\n***********************************************************************\n*                                                                     *\n*             MODULE NAME = INMRZ11                                   *\n*                                                                     *\n*             DESCRIPTIVE NAME = RECEIVE PRE-PROCESSING EXIT          *\n*                                                                     *\n*             FUNCTION =                                              *\n*                EXIT ALLOWS RECEIVE TO RUN IN BACKGROUND WITH        *\n*                THE EXIT REPLACING THE USER INTERACTION IN           *\n*                DETERMINING THE RECEIVING DATA SET NAME.             *\n*                                                                     *\n*                OPERATION =                                          *\n*                   SAVE REGISTERS AND ESTABLISH ADDRESSABILITY       *\n*                   GET ASCB ADDRESSABILITY                           *\n*                   IF REQUEST IS FROM TSO USER,                      *\n*                     EXIT WITH RC=0                                  *\n*                   GET ADDRESS FOR BUILDING RECEIVE REPLY            *\n*                   GET ASXB ADDRESSABILITY                           *\n*                   DROP ASCB ADDRESSABILITY                          *\n*                   GET ACEE ADDRESSABILITY                           *\n*                   DROP ASXB ADDRESSABILITY                          *\n*                   GET TCB ADDRESSABILITY                            *\n*                   GET TIOT ADDRESSABILITY                           *\n*                   DROP TCB ADDRESSSABILITY                          *\n*                   SEARCH DD NAMES FOR 'SYSUT2'                      *\n*                   IF 'SYSUT2' PRESENT,                              *\n*                     GET ADDRESSABILITY TO JFCB                      *\n*                     STORE SYSUT2 DATA SET NAME IN REPLY FIELD       *\n*                     IF VOLUME PRESENT IN JFCB,                      *\n*                       IF VOLSER=SCRTCH, REPORT ERROR AND EXIT       *\n*                          WITH RC=4                                  *\n*                       ELSE, ADD VOLUME TO REPLY                     *\n*                     ADD 'OLD' OR 'MOD' INDICATOR TO REPLY           *\n*                     SET FLAG TO TELL RECEIVE TO USE THIS REPLY      *\n*                     EXIT WITH RC=0                                  *\n*                   IF 'SYSUT2' NOT PRESENT,                          *\n*                     IF 4TH CHARACTER OF USERID IS 'J' OR 'R',       *\n*                       USE 1ST 3 CHARS FOR DSNAME'S 1ST QUALIFIER    *\n*                     ELSE,                                           *\n*                       USE ENTIRE USERID FOR 1ST QUALIFIER           *\n*                     IF 2ND QUALIFIER OF XMITTED DSNAME IS 'DDNAME', *\n*                       STORE TEMPORARY DATA SET ERROR MESSAGE        *\n*                       SET FLAGS TO USE THIS ERROR MESSAGE           *\n*                       EXIT WITH RC=4                                *\n*                     SKIP THE FIRST QUALIFIER OF THE XMITTED DSNAME  *\n*                     FINISH CONSTRUCTING NEW DSNAME WITH THE REST    *\n*                     INDICATE 'NEW' ON THE REPLY                     *\n*                     SET FLAG TO TELL RECEIVE TO USE THIS REPLY      *\n*                     EXIT WITH RC=0                                  *\n*                                                                     *\n*              NOTES =                                                *\n*                                                                     *\n*                 REGISTER CONVENTIONS = STANDARD CONVENTIONS.        *\n*                    REGISTER  1       = PARAMETER LIST POINTER       *\n*                    REGISTER  2       = ASCB AND LATER TCB           *\n*                                        ADDRESSABILITY AND           *\n*                                        WORK REGISTER                *\n*                    REGISTER  3       = ASXB AND LATER TIOT          *\n*                                        ADDRESSABILITY AND           *\n*                                        WORK REGISTER                *\n*                    REGISTERS 4 - 10  = WORK REGISTERS               *\n*                    REGISTER  11      = ACEE ADDRESSABILITY          *\n*                    REGISTER  12      = BASE REGISTER                *\n*                    REGISTER  13      = SAVE AREA POINTER            *\n*                    REGISTER  14      = RETURN ADDRESS               *\n*                    REGISTER  15      = ENTRY POINT ADDRESS AND      *\n*                                        RETURN CODE REGISTER         *\n*                                                                     *\n*             MACROS =                                                *\n*                SAVE, RETURN, EQUATE                                 *\n*                                                                     *\n*             MAPPING MACROS USED =                                   *\n*                IHAACEE       ACEE MAP                               *\n*                IHAASCB       ASCB MAP                               *\n*                IHAASXB       ASXB MAP                               *\n*                IEFJFCBN      JFCB MAP                               *\n*                IKJTCB        TCB MAP                                *\n*                IEFTIOT1      TIOT MAP                               *\n*                                                                     *\n*                                                                     *\n*             CHANGE ACTIVITY =                                       *\n*                02/06/84  WRITTEN.      BC.                          *\n*                02/13/84  GENERATE ERROR MESSAGE IF VOLSER           *\n*                          OF 'SCRTCH' SPECIFIED ON SYSUT2.   BC.     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n*\nINMRZ11 CSECT\n         SAVE  (14,12),,INMRZ11_DELUXE_CHECK_&SYSDATE_&SYSTIME\n         LR    R12,R15\n         USING INMRZ11,R12             ESTABLISH ADDRESSABILITY\n         LR    R7,R1                   PRESERVE PTR TO PARMS\n*\n*  CHECK TO SEE IF THIS IS A BATCH JOB.  IF IT ISN'T, EXIT.\n*\nBTCHCHK  EQU   *\n         L     R2,16                   GET ADDRESS OF CVT\n         L     R2,0(R2)                GET ADDR OF TCB ADDRESS WORD\n         L     R2,12(R2)               GET ADDRESS OF CURRENT ASCB\n         USING ASCB,R2                 TELL ASSEMBLER\n         L     R3,ASCBTSB              GET ADDRESS OF TSB\n         LTR   R3,R3                   IF NOT ZERO,\n         BNZ   EXIT                      THIS IS A TSO USER\n*        L     R3,ASCBJBNS             GET STC/MNT/LOGON JOBNAME PTR\n*        LTR   R3,R3                   IF THIS IS ZERO THEN THIS MAY\n*        BNZ   EXIT                    BE A BATCH JOB ELSE EXIT\n*        L     R3,ASCBJBNI             GET INITIATED JOB JOBNAME PTR\n*        LTR   R3,R3                   IF THIS IS ZERO THIS IS NOT A\n*        BZ    EXIT                    BATCH JOB IT IS A STC\n*\n*     IF WE GET HERE WE ARE FAIRLY CONFIDENT THAT WE ARE RUNNING BATCH\n*\n         L     R8,44(R7)               GET ADDRESS FOR BUILDING REPLY\n         LA    R8,4(R8)                GET ADDRESS FOR ACTUAL BEGINNING\n         MVC   0(8,R8),=CL8'DATASET('  START OUT WITH DATA SET NAME\n*\n*  GET ADDRESSABILITY TO THE ACEE IN CASE USERID IS NEEDED\n*\n         L     R3,ASCBASXB             GET ADDRESS OF ASXB\n         DROP  R2\n         USING ASXB,R3                 TELL ASSEMBLER\n         L     R11,ASXBSENV            GET ADDRESS OF ACEE\n         DROP  R3                      DROP ASXB ADDRESSABILITY\n         USING ACEE,R11                ESTABLISH ADDRESSABILITY TO ACEE\n*\n*  LOOK FOR SYSUT2 DD NAME\n*\nCHKDD    EQU   *\n         L     R2,16                   POINT TO CVT\n         L     R2,0(R2)                GET ADDRESS OF TCB ADDR WORDS\n         L     R2,4(R2)                GET ADDR OF CURRENT TCB\n         USING TCB,R2                  TELL ASSEMBLER\n         L     R3,TCBTIO               GET ADDRESS OF THIS TCB'S TIOT\n         DROP  R2\n         USING TIOT1,R3                TELL ASSEMBLER\n         LA    R2,TIOELNGH             POINT TO START OF DD ENTRIES\n         DROP  R3\n         SLR   R3,R3                   CLEAR R3\nCD10     EQU   *\n         IC    R3,0(R2)                GET LENGTH OF ENTRY\n         LTR   R3,R3                   ENTRY PRESENT?\n         BZ    NEWDSN                  IF NOT, CONSTRUCT NEW DSN\n         CLC   4(8,R2),=CL8'SYSUT2'    IS IT SYSUT2?\n         BE    GETJFCB                 IF SO, GO FIND JFCB\n         AR    R2,R3                   GO TO NEXT DD ENTRY\n         B     CD10                    LOOP BACK\n*\n*  GET THE JFCB AND CONSTRUCT THE REPLY TO THE RECEIVE COMMAND\n*\nGETJFCB  EQU   *\n         SLR   R5,R5\n         ICM   R5,B'0111',12(R2)       GET ADDRESS OF JFCB PREFIX\n         LA    R5,16(R5)               GET ADDRESS OF JFCB\n         USING INFMJFCB,R5             TELL ASSEMBLER\n         MVI   8(R8),X'7D'             MOVE IN QUOTE\n         MVC   9(44,R8),JFCBDSNM       LOAD DATA SET NAME INTO REPLY\n         LA    R8,53(R8)               GET ADDR OF END OF NAME\nGJ10     EQU   *\n         BCTR  R8,0                    LOOK AT PREVIOUS CHARACTER\n         CLI   0(R8),X'40'             END OF DATA SET NAME?\n         BE    GJ10                    IF NOT, KEEP LOOKING\n         MVI   1(R8),X'7D'             MOVE IN QUOTE\n         LA    R8,2(R8)                MOVE AHEAD TO NEXT SPACE\n         CLI   JFCBVOLS,X'40'          VOLUME PRESENT?\n         BE    GJ20                    IF NOT, BRANCH\n         CLC   JFCBVOLS(6),=CL6'SCRTCH'  DOES VOLSER=SCRTCH?\n         BNE   GJ15                    IF NOT, OK\n         L     R5,16(R7)               GET ADDRESS FOR ERROR MESSAGE\n         MVC   0(L'ERRMSG2,R5),ERRMSG2 STORE ERROR MESSAGE\n         L     R8,8(R7)                GET ADDRESS TO FLAG\n         OI    0(R8),X'C0'             SET FLAG TO ISSUE MESSAGE\n         LA    R15,4                   SET A RETURN CODE OF 4\n         B     EXITX                   AND EXIT\nGJ15     EQU   *\n         MVC   0(9,R8),=C') VOLUME('   GET READY TO ADD VOLUME\n         MVC   9(6,R8),JFCBVOLS        LOAD THE VOLUME\n         LA    R8,15(R8)\nGJ20     EQU   *\n         MVC   0(2,R8),=C') '          CLOSE OFF\n         LA    R8,2(R8)\n         TM    JFCBIND2,JFCNEW         NEW DATA SET?\n         BNO   GJ30                    IF NOT, BRANCH\n         MVC   0(3,R8),=C'OLD'         INDICATE OLD SO REALLOCATE IS\n*                                      NOT ATTEMPTED\n         LA    R8,3(R8)\n         B     GJ50\nGJ30     EQU   *\n         TM    JFCBIND2,JFCMOD         MODIFY DATA SET?\n         BNO   GJ40                    IF NOT, BRANCH\n         MVC   0(3,R8),=C'MOD'         INDICATE MODIFY\n         LA    R8,3(R8)\n         B     GJ50\nGJ40     EQU   *\n         TM    JFCBIND2,JFCOLD         OLD DATA SET?\n         BNO   GJ50                    IF NOT, BRANCH\n         MVC   0(3,R8),=C'OLD'         INDICATE OLD\n         LA    R8,3(R8)\nGJ50     EQU   *\n         B     FINI\n*\n*  CONSTRUCT NEW DATA SET NAME\n*\nNEWDSN   EQU   *\n         MVI   8(R8),X'7D'             MOVE IN QUOTE\n         CLI   ACEEUSRI+3,C'R'         REGION ID?\n         BE    ND10                    IF SO, BRANCH\n         CLI   ACEEUSRI+3,C'J'         ADMIN ID?\n         BE    ND10                    IF SO, BRANCH\n         MVC   9(8,R8),ACEEUSRI        LOAD COMPLETE USERID\n         LA    R8,17(R8)               POINT TO END OF USER ID FIELD\nND05     EQU   *\n         BCTR  R8,0                    LOOK AT PREVIOUS CHARACTER\n         CLI   0(R8),X'40'             END OF USER ID?\n         BE    ND05                    IF NOT, KEEP LOOKING\n         LA    R8,1(R8)                GO TO AVAILABLE SPACE\n         B     ND20\nND10     EQU   *\n         MVC   9(3,R8),ACEEUSRI        LOAD ONLY FIRST 3 LETTERS OF ID\n         LA    R8,12(R8)\nND20     EQU   *\n         L     R9,28(R7)               GET ADDR OF TEXT UNIT PTR LIST\nND30     EQU   *\n         L     R10,0(R9)               GET ADDR OF TEXT UNIT\n         CLC   0(2,R10),=X'0002'       DATA SET NAME?\n         BE    ND40                    IF SO, GO TO IT\n         TM    0(R9),X'80'             END OF LIST?\n         BO    EXIT                    IF SO, NOW WHAT?\n         LA    R9,4(R9)                GO TO NEXT ADDR IN LIST\n         B     ND30                    AND LOOP\nND40     EQU   *\n         SLR   R3,R3\n         ICM   R3,B'0011',2(R10)       GET NUMBER OF QUALIFIERS\n         SLR   R5,R5\n         ICM   R5,B'0011',4(R10)       GET LENGTH OF FIRST QUALIFIER\n         LA    R10,6(R10)              GO TO FIRST QUALIFIER\n         AR    R10,R5                  SKIP IT\n         BCTR  R3,0                    COUNT IT\n         LTR   R3,R3                   CHECK TO SEE IF THERE'RE MORE\n         BZ    ND60                    IF NOT, BRANCH\n         LA    R5,2(R10)               GET ADDRESS OF QUALIFIER\n*\n*  IF XMITTED DATA SET IS TEMPORARY, GENERATE ERROR MESSAGE AND\n*    FORCE THEM TO USE SYSUT2 TO RECEIVE IT.\n*\n         CLC   0(6,R5),=C'DDNAME'      IS THIS A TEMPORARY DATASET?\n         BNE   ND50                    IF NOT, BRANCH\n         L     R5,16(R7)               GET ADDRESS FOR ERROR MESSAGE\n         MVC   0(L'ERRMSG1,R5),ERRMSG1 STORE ERROR MESSAGE\n         L     R8,8(R7)                GET ADDRESS TO FLAG\n         OI    0(R8),X'C0'             SET FLAG TO ISSUE MESSAGE\n         LA    R15,4                   SET A RETURN CODE OF 4\n         B     EXITX                   AND EXIT\n*\n*  FINISH CONSTUCTING NEW DATA SET NAME FROM NAME OF XMITTED FILE.\n*\nND50     EQU   *\n         SLR   R5,R5\n         ICM   R5,B'0011',0(R10)       GET LENGTH OF QUALIFIER\n         LA    R10,2(R10)\n         MVI   0(R8),C'.'              INSERT PERIOD\n         LA    R8,1(R8)\n         BCTR  R5,0                    DECREMENT LENGTH\n         MVC   0(*-*,R8),0(R10)        EXECUTED MOVE\n         EX    R5,*-6                  LOAD QUALIFIER\n         LA    R5,1(R5)                INCREMENT LENGTH\n         AR    R10,R5                  POINT TO NEXT QUALIFIER\n         AR    R8,R5\n         BCT   R3,ND50                 COUNT NUMBER OF QUALIFIERS\nND60     EQU   *\n         MVI   0(R8),X'7D'             MOVE IN QUOTE\n         MVC   1(5,R8),=C') NEW'       FINISH REPLY\n         LA    R8,6(R8)\n*\n*  UPDATE REPLY LENGTH FIELD AND SET FLAG TO TELL RECEIVE TO USE\n*    THE REPLY FIELD\n*\nFINI     EQU   *\n         L     R6,44(R7)               GET BEGINNING ADDRESS\n         SLR   R8,R6                   CALCULATE LENGTH OF REPLY\n         STH   R8,0(R6)                AND STORE IT\n         L     R8,8(R7)                ADDRESS OF FLAG BIT\n         OI    0(R8),X'08'             SET FLAG TO USE REPLY\n*\n*  EXIT THE EXIT\n*\nEXIT     EQU   *\n         SLR   R15,R15                 SET RETURN CODE TO ZERO\nEXITX    EQU   *\n         RETURN (14,12),RC=(15)        END THE EXIT\n*\n         LTORG\nERRMSG1  DS 0CL65\n         DC H'0063'\n         DC C'CREATION OF TEMPORARY DATA SET NAMES NOT SUPPORTED '\n         DC C'- USE SYSUT2'\n*\n         DS 0H\nERRMSG2  DS 0CL40\n         DC H'0038'\n         DC C'VOLSER OF SCRTCH NOT ALLOWED ON SYSUT2'\n*\n*  REGISTER EQUATES\n*\n         EQUATE\n*\n*\n*  DSECTS\n*\n         IHAACEE\n         IHAASCB\n         IHAASXB\n         IEFJFCBN\n         IKJTCB\n         IEFTIOT1\n*\n         END   INMRZ11\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RACFALT": {"ttr": 1543, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         TITLE 'RACFALT - GEN CLIST FOR ALTERING RACF DATA SET DEF'\n***********************************************************************\n*                                                                     *\n*             MODULE NAME = RACFALT                                   *\n*                                                                     *\n*             DESCRIPTIVE NAME = GENERATE CLIST TO CHANGE THE         *\n*                VOLUME SERIAL NUMBERS IN THE NON-VSAM DATA           *\n*                SETS ON THE SPECIFIED VOLUME.                        *\n*                                                                     *\n*             FUNCTION =                                              *\n*                CREATES CLIST WHICH WILL ALLOW A SYSTEM              *\n*                PROGRAMMER TO CHANGE THE VOLUME SERIAL               *\n*                NUMBER IN EACH DATA SET ON A SPECIFIED               *\n*                VOLUME.  THIS WILL BE ACCOMPLISHED WITH              *\n*                THE 'ALTDSD' RACF COMMAND.                           *\n*                                                                     *\n*                OPERATION =                                          *\n*                   GET NEW VOLUME SERIAL NUMBER FROM PARAMETERS      *\n*                   OPEN THE VTOC FOR THE SPECIFIED VOLUME            *\n*                   OPEN THE SPECIFIED OUTPUT FILE (FOR CLIST)        *\n*                   READ FORMAT 1 RECORDS OF VTOC FOR DATA SET NAME   *\n*                   IGNORE CERTAIN DATA SETS, INCLUDING ALL VSAM      *\n*                   IF RACF PROTECTED,                                *\n*                     WRITE LINE TO CHANGE VOLUME SERIAL NUMBER       *\n*                   CONTINUE READING VTOC TIL ALL DATA SETS PROCESSED *\n*                   CLOSE VTOC AND OUTPUT FILE                        *\n*                   EXIT                                              *\n*                                                                     *\n*              NOTES =                                                *\n*                                                                     *\n*                 REGISTER CONVENTIONS = STANDARD CONVENTIONS.        *\n*                    REGISTERS 0 TO 1  = WORK REGISTERS               *\n*                    REGISTERS 2 TO 4  = LINKAGE & WORK REGISTERS     *\n*                    REGISTERS 5 TO 9  = WORK REGISTERS               *\n*                    REGISTER  10      = ADDRESSABILITY TO DCB        *\n*                    REGISTER  11      = ADDRESSABILITY TO JFCB &     *\n*                                        DSCB                         *\n*                    REGISTER  12      = WORK REGISTER                *\n*                    REGISTER  13      = SAVE AREA REGISTER AND       *\n*                                        ADDRESSABILITY TO GETMAINED  *\n*                                        WORK AREA                    *\n*                    REGISTERS 14,15   = WORK REGISTERS               *\n*                                                                     *\n*             MACROS =                                                *\n*                SAVE, GETMAIN, RDJFCB, OPEN, READ, CHECK,            *\n*                CLOSE, PUT                                           *\n*                                                                     *\n*             CHANGE ACTIVITY =                                       *\n*                10/21/83  WRITTEN.      BC.                          *\n*                                                                     *\n* SAMPLE JCL =                                                        *\n*                                                                     *\n*   //JOBNAME JOB (GEE1,0104),'PROG NAME',CLASS=S,MSGCLASS=A,         *\n*   //        MSGLEVEL=(2,0),USER=SYSPGM,PASSWORD=????????            *\n*   //STEP1 EXEC  PGM=RACFALT,PARM='NEWVOL'                           *\n*   //VTOC  DD UNIT=3350,VOL=SER=DLX170,DISP=OLD                      *\n*   //CLIST DD DSN=T99999.TEST.CLIST,VOL=SER=DLXTSO,UNIT=3380,        *\n*   //         DISP=(NEW,CATLG),SPACE=(TRK,(10,1)),                   *\n*   //         DCB=(RECFM=VB,LRECL=255,BLKSIZE=6233)                  *\n*                                                                     *\n***********************************************************************\n*\n         PRINT NOGEN\nRACFALT CSECT\n         SAVE  (14,12)                 SAVE REGISTERS\n         LR    R12,R15\n         USING RACFALT,R12             ESTABLISH ADDRESSABILITY\n         LR    R2,R1                   PRESERVE PTR TO PARMS\n         GETMAIN R,LV=LDATA            GET DYNAMIC WORK AREA\n         LR    R10,R1                  PRESERVE PTR TO WORK AREA\n         ST    R13,4(R10)              STORE ADDR OF PREVIOUS SA\n         ST    R10,8(,R13)             STORE ADDR OF CURRENT SA\n         LR    R13,R10                 LOAD ADDR OF CURRENT SA\n         USING WORKAREA,R13            ESTABLISH ADDRESSABILITY\n*\n*  GET PARMS TO DETERMINE THE ALTERNATE VOLUME.\n*\nGETPARM  EQU   *\n         L     R5,0(R2)                GET PARM ADDRESS\n         LH    R3,0(R5)                SAVE PARM LENGTH\n         LTR   R3,R3                   ANY PARM DATA?\n         BZ    GP40                    IF NOT, BRANCH TO ABEND\n         LA    R5,2(R5)                SKIP PARM LENGTH FIELD\n         LA    R4,PARMBUF              SET POINTER INTO PARM BUFFER\n         MVI   PARMBUF,X'40'           CLEAR PARM BUFFER\n         MVC   PARMBUF+1(L'PARMBUF-1),PARMBUF\nGP10     EQU   *\n         CLI   0(R5),C','              DELIMITING COMMA?\n         BE    GP20                    IF SO, BRANCH\n         MVC   0(1,R4),0(R5)           STORE PARM CHARACTER\n         LA    R4,1(R4)                INCREMENT PARM BUFFER POINTER\n         LA    R5,1(R5)                GO TO NEXT PARM CHARACTER\n         BCT   R3,GP10                 LOOP BACK TIL DONE\nGP20     EQU   *\n         MVC   ALTVOL,PARMBUF          STORE ALTERNATE VOLUME\n         B     INIT                    AND IGNORE ANYTHING ELSE\nGP40     EQU   *\n         ABEND 16,DUMP\n*\n*  INITIALIZE THE WORK AREA.  OPEN THE VTOC AND CLIST OUTPUT FILE.\n*    WRITE THE FIRST 2 LINES OF THE CLIST INTO THE OUTPUT FILE.\n*\nINIT     EQU   *\n         LA    R6,DATA                 SET UP REGISTERS FOR\n         LA    R7,MOVEL                  LONG MOVE\n         LA    R8,CDATA\n         LA    R9,MOVEL\n         MVCL  R6,R8                   LOAD INITIAL DATA INTO WORKAREA\n         LA    R10,VTOC                GET ADDRESS OF DCB1\n         USING IHADCB,R10              ADDRESSIBILITY TO DCB\n         LA    R11,JFCBA               GET ADDRESS OF BUFFER\n         ST    R11,EXLIST              STORE ADDRESS IN EXIT LIST\n         MVI   EXLIST,X'87'            SET END OF LIST & JFCB BYTE\n         LA    R6,EXLIST               GET ADDRESS OF EXIT LIST\n         ST    R6,DCBEXLST             STORE IN DCB\n         DROP  R10\n         RDJFCB (VTOC,),MF=(E,EX1)     READ JOB FILE CONTROL BLOCK\n         USING INFMJFCB,R11            ESTABLISH ADDRESSABILITY\n         LTR   R15,R15                 CHECK RETURN CODE\n         BNZ   RETURN                  IF NOT SUCCESSFUL, EXIT\n         MVI   JFCBDSNM,X'04'          CHANGE DATASET NAME TO\n         MVC   JFCBDSNM+1(43),JFCBDSNM   44 X'04'S\n         OI    JFCBTSDM,JFCNWRIT       SET FLAG NOT TO WRITE BACK\n         MVC   VOL,JFCBVOLS            SAVE VOLSER\n         DROP  R11\n         OPEN  (VTOC,INPUT),TYPE=J,MF=(E,EX2) OPEN THE VTOC\n         LTR   R15,R15\n         BNZ   CLOSEX\nIN10     EQU   *\n         OPEN  (PRINT,OUTPUT),MF=(E,EX2) OPEN OUTPUT FILE\n         LTR   R15,R15\n         BNZ   CLOSEX\n         MVI   LINE,X'40'              INITIALIZE LINE\n         MVC   LINE+1(L'LINE-1),LINE     TO ALL SPACES\n         LA    R5,RPARMS               SET R5 TO PARM ADDRESS\n         MVC   DLXCMD(L'FSTLINE),FSTLINE\n         BAL   R3,PRINTIT              OUTPUT FIRST LINE OF CLIST\n         MVC   DLXCMD(L'SNDLINE),SNDLINE\n         BAL   R3,PRINTIT              OUTPUT SECOND LINE OF CLIST\n*\n*  READ THE VTOC FORMAT-1 RECORDS.  PROCESS ALL NON-VSAM DATA SETS\n*    ON VOLUME WITH THE EXCEPTION OF A FEW (SUCH AS THE VTOC INDEX,\n*    CATALOG, CATALOG INDEX, TEMPORARY DATA SETS, ETC.)\n*\nREADIT   EQU   *\n         READ  DECB,SF,VTOC,DSCB,'S',MF=E  READ A VTOC RECORD\n         CHECK DECB                    WAIT TIL DONE\n         USING IECSDSL1,R11            ESTABLISH ADDRESSABILITY\n         LA    R11,DSCB                LOAD DSCB ADDRESS\n         CLI   DS1FMTID,C'1'           FORMAT 1 RECORD?\n         BNE   READIT                  IF NOT, GO BACK FOR ANOTHER\n         CLC   DS1DSNAM(11),=C'SYS1.VTOCIX'\n         BE    READIT\n         CLC   DS1DSNAM(9),=C'SYS1.VVDS'\n         BE    READIT\n         CLC   DS1DSNAM(7),=C'CATALOG'            IGNORE CERTAIN\n         BE    READIT                              DATA SETS\n         CLC   DS1DSNAM(8),=C'CATINDEX'\n         BE    READIT\n         CLC   DS1DSNAM(8),=C'FDRABR.V'\n         BE    READIT\n         CLC   DS1DSNAM(3),=C'SYS'\n         BNE   RI30\n         LA    R7,DS1DSNAM+3\n         LA    R8,5\nRI20     EQU   *\n         TM    0(R7),X'F0'\n         BNO   RI30\n         LA    R7,1(R7)\n         BCT   R8,RI20\n         B     READIT\nRI30     EQU   *\n         TM    DS1DSORG+1,DS1ACBM      VSAM FILE?\n         BO    READIT                  IF SO, IGNORE IT\n         TM    DS1DSIND,DS1IND40       RACF PROTECTED?\n         BNO   READIT                  IF NOT, IGNORE IT\n*\n*  GENERATE CLIST COMMANDS FOR THE DATA SET.\n*\nNONVSAM  EQU   *\n         MVC   DLXCMD,=C'DLXAUTHC'     LOAD PRINT LINE FOR\n         MVC   RACFCMD,=C'ALD'           MODIFYING RACF PROFILE\n         MVC   0(L'DS1DSNAM,R5),DS1DSNAM\n         BAL   R2,NXTSPC               FIND NEXT SPACE\n         MVC   0(L'VOLPARM,R5),VOLPARM   AND LOAD VOLUME PARM\n         MVC   L'VOLPARM(L'VOL,R5),VOL\n         MVI   L'VOLPARM+L'VOL(R5),C')'\n         BAL   R2,NXTSPC               FIND NEXT SPACE\n         MVC   0(L'AVOLPARM,R5),AVOLPARM  AND LOAD ALTERNATE VOLUME\n         MVC   L'AVOLPARM(L'VOL,R5),VOL\n         MVC   L'AVOLPARM+L'VOL+1(L'ALTVOL,R5),ALTVOL\n         MVI   L'AVOLPARM+L'VOL+1+L'ALTVOL(R5),C')'\n         BAL   R3,PRINTIT              PRINT THE LINE\n         B     READIT                  GO BACK FOR MORE\n*\n*  CLOSE FILES AND TERMINATE PROGRAM.\n*\nCLOSEX   EQU   *                       ERROR EXIT\n         LR    R7,R15                  SAVE CONTENTS OF R15\n         CLOSE (VTOC,,PRINT),MF=(E,EX4) CLOSE THE FILES\n         LR    R15,R7                  RESTORE CONTENTS OF R15\n         B     RETURN\nCLOSE    EQU   *                       STANDARD EXIT\n         MVC   DLXCMD(L'LSTLINE),LSTLINE\n         BAL   R3,PRINTIT              OUTPUT LAST LINE OF CLIST\n         CLOSE (VTOC,,PRINT),MF=(E,EX4) CLOSE THE FILES\nRETURN   L     R13,4(R13)              RESTORE REGISTERS\n         RETURN (14,12),RC=(15)        AND END\n*\n***********************************************************************\n*                                                                     *\n*                      SUBROUTINES                                    *\n*                                                                     *\n***********************************************************************\n*\n*  SUBROUTINE TO WRITE THE OUTPUT LINE INTO THE CLIST DATA SET\n*\nPRINTIT  EQU   *\n         AP    LINE#,=P'100'           INCREMENT LINE NUMBER\n         UNPK  LINENO,LINE#            UNPACK LINE NUMBER\n         MVZ   LINENO+7(1),LINENO+6      & MOVE THE ZONE BYTE\n         BAL   R2,NXTSPC               FIND END OF LINE\n         LA    R2,LINE\n         SR    R5,R2                   CALCULATE LINE LENGTH\n         STH   R5,LINE                   AND STORE\n         MVC   LINE+2(2),=X'0000'\n         PUT   PRINT,LINE              PRINT THE LINE\n         MVI   LINE,X'40'              RESET THE LINE BUFFER\n         MVC   LINE+1(L'LINE-1),LINE     TO SPACES\n         LA    R5,RPARMS               RESET R5 TO PARM ADDRESS\n         BR    R3                      RETURN\n*\n*  SUBROUTINE TO POINT TO THE NEXT DATA POSITION IN THE OUTPUT LINE.\n*\nNXTSPC   EQU   *\n         LA    R5,1(R5)                INCREMENT POINTER\n         CLC   0(4,R5),=C'    '        CHECK FOR A SPACE\n         BNE   NXTSPC                  LOOP TIL SPACE FOUND\n         LA    R5,1(R5)                INCREMENT ONCE MORE\n         BR    R2                      RETURN\n*\n***********************************************************************\n*                                                                     *\n*                     CONSTANT DATA                                   *\n*                                                                     *\n***********************************************************************\n*\n*  REGISTER EQUATES\n*\nR0       EQU   00\nR1       EQU   01\nR2       EQU   02\nR3       EQU   03\nR4       EQU   04\nR5       EQU   05\nR6       EQU   06\nR7       EQU   07\nR8       EQU   08\nR9       EQU   09\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n*\n         LTORG\n*\n*    THE FOLLOWING DATA IS USED TO INIT PART OF THE GETMAIN'ED AREA\n*\nCDATA    DS    0F\nILINE#   DC    P'00000000'\nDCB1     DCB   DDNAME=VTOC,DSORG=PS,RECFM=U,KEYLEN=44,BLKSIZE=96,      X\n               MACRF=(R),EODAD=CLOSE\nDCB2     DCB   DDNAME=CLIST,DSORG=PS,RECFM=VB,LRECL=255,               X\n               MACRF=(PM)\nLIST1    RDJFCB (,),MF=L\nLIST2    OPEN   (,),MF=L\nLIST3    READ   DECB1,SF,MF=L\nLIST4    CLOSE  (,),MF=L\nMOVEL    EQU   *-CDATA\n*\n*  MISCELLANEOUS CONSTANTS\n*\nVOLPARM  DC    C'VOLUME('\nAVOLPARM DC    C'ALTVOL('\nFSTLINE  DC    C'PROC 0'\nSNDLINE  DC    C'CONTROL LIST NOFLUSH PROMPT MSG'\nLSTLINE  DC    C'END'\n*\n***********************************************************************\n*                                                                     *\n*                    DSECTS FOR GETMAIN'ED AREA                       *\n*                                                                     *\n***********************************************************************\nWORKAREA DSECT\nSAVEAREA DS    18F\n*\nLINE     DS    0CL255\n         DS    CL4\nLINENO   DS    CL8\nDLXCMD   DS    CL8\n         DS    CL1\nRACFCMD  DS    CL3\n         DS    CL1\nRPARMS   DS    CL230\n*\nPARMBUF  DS    CL20\nALTVOL   DS    CL6\nVOL      DS    CL6\nDSCB     DS    XL140\nJFCBA    DS    XL176\nEXLIST   DS    1F\n*\nDATA     DS    0F\nLINE#    DS    P'00000000'\nVTOC     DCB   DDNAME=VTOC,DSORG=PS,RECFM=U,KEYLEN=44,BLKSIZE=96,      X\n               MACRF=(R),EODAD=CLOSE\nPRINT    DCB   DDNAME=CLIST,DSORG=PS,RECFM=VB,LRECL=255,               X\n               MACRF=(PM)\nEX1      RDJFCB (,),MF=L\nEX2      OPEN   (,),MF=L\nEX3      READ   DECB,SF,MF=L\nEX4      CLOSE  (,),MF=L\n*\nLDATA    EQU   *-WORKAREA\n*\n*\n*\nDSCB1    DSECT\n         IECSDSL1 1\nJFCB     DSECT\n         IEFJFCBN ,\nDCBSECT  DSECT\n         DCBD  DSORG=PS,DEVD=DA\n         END   RACFALT\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RACFCLST": {"ttr": 1795, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         TITLE 'RACFCLST - GEN CLIST FOR RACF DEFINITIONS'\n***********************************************************************\n*                                                                     *\n*             MODULE NAME = RACFCLST                                  *\n*                                                                     *\n*             DESCRIPTIVE NAME = GENERATE CLIST TO REDEFINE RACF      *\n*                PROTECTION  FOR ALL DATA SETS ON A SPECIFIED         *\n*                VOLUME.                                              *\n*                                                                     *\n*             FUNCTION =                                              *\n*                CREATES CLIST WHICH WILL ALLOW A SYSTEM              *\n*                PROGRAMMER TO RESET THE RACF PROTECTION              *\n*                FOR ALL DATA SETS ON A VOLUME BACK TO THEIR          *\n*                CURRENT STATE.  THIS WILL BE ACCOMPLISHED            *\n*                BY REMOVING THE RACF PROTECTION FOR A                *\n*                DATA SET WITH THE 'DELDSD' COMMAND, PROTECTING       *\n*                IT WITH THE 'ADDSD' COMMAND, AND GIVING              *\n*                NECESSARY AUTHORITY WITH THE 'PERMIT' COMMAND.       *\n*                                                                     *\n*                OPERATION =                                          *\n*                   OPEN THE VTOC FOR THE SPECIFIED VOLUME            *\n*                   OPEN THE SPECIFIED OUTPUT FILE (FOR CLIST)        *\n*                   READ FORMAT 1 RECORDS OF VTOC FOR DATA SET NAME   *\n*                   WRITE LINE TO DELETE RACF PROTECTION ON DATA SET  *\n*                   IF RACF PROTECTED,                                *\n*                     GET RACF PARAMETERS FOR DATA SET                *\n*                     WRITE LINES TO RACF PROTECT (ADDSD & PERMIT)    *\n*                   IF DATA COMPONENT OF VSAM DATA SET,               *\n*                     REPEAT FOR THE VSAM CLUSTER                     *\n*                   CONTINUE READING VTOC TIL ALL DATA SETS PROCESSED *\n*                   CLOSE VTOC AND OUTPUT FILE                        *\n*                   EXIT                                              *\n*                                                                     *\n*              NOTES =                                                *\n*                                                                     *\n*                 REGISTER CONVENTIONS = STANDARD CONVENTIONS.        *\n*                    REGISTERS 0 TO 1  = WORK REGISTERS               *\n*                    REGISTERS 2 TO 4  = LINKAGE & WORK REGISTERS     *\n*                    REGISTERS 5 TO 9  = WORK REGISTERS               *\n*                    REGISTER  10      = ADDRESSABILITY TO DCB &      *\n*                                        RACF FIELDS                  *\n*                    REGISTER  11      = ADDRESSABILITY TO JFCB &     *\n*                                        DSCB                         *\n*                    REGISTER  12      = ADDRESSABILITY TO RACFCLST   *\n*                                        CSECT                        *\n*                    REGISTER  13      = SAVE AREA REGISTER AND       *\n*                                        ADDRESSABILITY TO GETMAINED  *\n*                                        WORK AREA                    *\n*                    REGISTERS 14,15   = WORK REGISTERS               *\n*                                                                     *\n*             MACROS =                                                *\n*                SAVE, GETMAIN, RDJFCB, OPEN, READ, CHECK,            *\n*                CLOSE, ICHEINTY, PUT                                 *\n*                                                                     *\n*             CHANGE ACTIVITY =                                       *\n*                10/21/83  WRITTEN.      BC.                          *\n*                                                                     *\n* SAMPLE JCL =                                                        *\n*                                                                     *\n*  ALL DATA SETS ON A VOLUME:                                         *\n*                                                                     *\n*   //JOBNAME JOB (GEE1,0104),'PROG NAME',CLASS=S,MSGCLASS=A,         *\n*   //        MSGLEVEL=(2,0),USER=SYSPGM,PASSWORD=????????            *\n*   //STEP1 EXEC  PGM=RACFCLST                                        *\n*   //VTOC  DD UNIT=3350,VOL=SER=DLX170,DISP=OLD                      *\n*   //CLIST DD DSN=T99999.TEST.CLIST,VOL=SER=DLXTSO,UNIT=3380,        *\n*   //         DISP=(NEW,CATLG),SPACE=(TRK,(10,1)),                   *\n*   //         DCB=(RECFM=VB,LRECL=255,BLKSIZE=6233)                  *\n*                                                                     *\n*  ALL VSAM DATA SETS ON A VOLUME:                                    *\n*                                                                     *\n*   //JOBNAME JOB (GEE1,0104),'PROG NAME',CLASS=S,MSGCLASS=A,         *\n*   //        MSGLEVEL=(2,0),USER=SYSPGM,PASSWORD=????????            *\n*   //STEP1 EXEC  PGM=RACFCLST,PARM='VSAM'                            *\n*   //VTOC  DD UNIT=3350,VOL=SER=DLX170,DISP=OLD                      *\n*   //CLIST DD DSN=T99999.TEST.CLIST,VOL=SER=DLXTSO,UNIT=3380,        *\n*   //         DISP=(NEW,CATLG),SPACE=(TRK,(10,1)),                   *\n*   //         DCB=(RECFM=VB,LRECL=255,BLKSIZE=6233)                  *\n*                                                                     *\n*  BY DATA SET GROUP:                                                 *\n*                                                                     *\n*   //JOBNAME JOB (GEE1,0104),'PROG NAME',CLASS=S,MSGCLASS=A,         *\n*   //        MSGLEVEL=(2,0),USER=SYSPGM,PASSWORD=????????            *\n*   //STEP1 EXEC  PGM=RACFCLST                                        *\n*   //VTOC  DD UNIT=3350,VOL=SER=DLX170,DISP=OLD                      *\n*   //CLIST DD DSN=T99999.TEST.CLIST,VOL=SER=DLXTSO,UNIT=3380,        *\n*   //         DISP=(NEW,CATLG),SPACE=(TRK,(10,1)),                   *\n*   //         DCB=(RECFM=VB,LRECL=255,BLKSIZE=6233)                  *\n*   //SYSIN DD *                                                      *\n*       DSG=T99999                                                    *\n*       DSG=SYSP                                                      *\n*                                                                     *\n*  BY DATA SET NAME:                                                  *\n*                                                                     *\n*   //JOBNAME JOB (GEE1,0104),'PROG NAME',CLASS=S,MSGCLASS=A,         *\n*   //        MSGLEVEL=(2,0),USER=SYSPGM,PASSWORD=????????            *\n*   //STEP1 EXEC  PGM=RACFCLST                                        *\n*   //CLIST DD DSN=T99999.TEST.CLIST,VOL=SER=DLXTSO,UNIT=3380,        *\n*   //         DISP=(NEW,CATLG),SPACE=(TRK,(10,1)),                   *\n*   //         DCB=(RECFM=VB,LRECL=255,BLKSIZE=6233)                  *\n*   //SYSIN DD *                                                      *\n*       DSN=T99999.CMDS.CLIST                                         *\n*       DSN=T99999.TEST.DATA,VOL=DLXTSO                               *\n*                                                                     *\n*  *** NOTE ***                                                       *\n*                                                                     *\n*   1. 'DSG=' AND 'DSN=' MAY BE COMBINED IN THE SAME JOB.             *\n*   2. FOR 'DSN=', 'VOL=' MUST BE SPECIFIED FOR UNCATALOGED           *\n*        DATA SETS.                                                   *\n*   3. SYSIN DATA CAN START IN ANY COLUMN.                            *\n*                                                                     *\n***********************************************************************\n*\n         PRINT NOGEN\nRACFCLST CSECT\n         SAVE  (14,12)                 SAVE REGISTERS\n         LR    R12,R15\n         USING RACFCLST,R12            ESTABLISH ADDRESSABILITY\n         LR    R2,R1                   PRESERVE PTR TO PARMS\n         GETMAIN R,LV=LDATA            GET DYNAMIC WORK AREA\n         LR    R10,R1                  PRESERVE PTR TO WORK AREA\n         ST    R13,4(R10)              STORE ADDR OF PREVIOUS SA\n         ST    R10,8(,R13)             STORE ADDR OF CURRENT SA\n         LR    R13,R10                 LOAD ADDR OF CURRENT SA\n         USING WORKAREA,R13            ESTABLISH ADDRESSABILITY\n*\n*  GET PARMS TO DETERMINE IF THIS SHOULD BE DONE FOR VSAM ONLY\n*\nGETPARM  EQU   *\n         L     R5,0(R2)                GET PARM ADDRESS\n         LH    R3,0(R5)                SAVE PARM LENGTH\n         LTR   R3,R3                   ANY PARM DATA?\n         BZ    GP40                    IF NOT, BRANCH\n         LA    R5,2(R5)                SKIP PARM LENGTH FIELD\n         LA    R4,PARMBUF              SET POINTER INTO PARM BUFFER\n         MVI   PARMBUF,X'40'           CLEAR PARM BUFFER\n         MVC   PARMBUF+1(L'PARMBUF-1),PARMBUF\n         MVI   VSAMONLY,C'N'           INIT VSAM ONLY FLAG\nGP10     EQU   *\n         CLI   0(R5),C','              DELIMITING COMMA?\n         BE    GP20                    IF SO, BRANCH\n         MVC   0(1,R4),0(R5)           STORE PARM CHARACTER\n         LA    R4,1(R4)                INCREMENT PARM BUFFER POINTER\n         LA    R5,1(R5)                GO TO NEXT PARM CHARACTER\n         BCT   R3,GP10                 LOOP BACK TIL DONE\nGP20     EQU   *\n         CLC   PARMBUF(4),=C'VSAM'     CHECK FOR VSAM ONLY\n         BNE   GP30                    IF NOT, IGNORE IT\n         MVI   VSAMONLY,C'Y'           SET VSAM ONLY FLAG\nGP30     EQU   *\n         LA    R4,PARMBUF              RESET POINTER INTO PARM BUFFER\n         MVI   PARMBUF,X'40'           CLEAR PARM BUFFER\n         MVC   PARMBUF+1(L'PARMBUF-1),PARMBUF\n         LTR   R3,R3                   ANY MORE PARMS?\n         BZ    GP40                    IF NOT, EXIT\n         LA    R5,1(R5)                IF SO, SKIP COMMA\n         B     GP10                    AND LOOP BACK\nGP40     EQU   *\n*\n*  CHECK TO SEE WHAT DD NAMES ARE PRESENT\n*\nCHKDD    EQU   *\n         SLR   R3,R3                   CLEAR R3\n         L     R2,16                   POINT TO CVT\n         L     R2,0(R2)                GET ADDRESS OF TCB ADDR WORDS\n         L     R2,4(R2)                GET ADDR OF CURRENT TCB\n         L     R2,12(R2)               GET ADDRESS OF THIS TCB'S TIOT\n         LA    R2,24(R2)               POINT TO START OF DD ENTRIES\n         MVI   SYSINFLG,C'N'           INIT SYSIN FLAG\n         MVI   VTOCFLG,C'N'            INIT VTOC FLAG\nCD10     EQU   *\n         IC    R3,0(R2)                GET LENGTH OF ENTRY\n         LTR   R3,R3                   ENTRY PRESENT?\n         BZ    CD40                    IF NOT, BRANCH\n         CLC   4(8,R2),=CL8'SYSIN'     IS IT SYSIN?\n         BNE   CD20                    IF NOT, BRANCH\n         MVI   SYSINFLG,C'Y'           IF SO, SET SYSIN FLAG\n         B     CD30\nCD20     EQU   *\n         CLC   4(8,R2),=CL8'VTOC'      IS IT VTOC?\n         BNE   CD30                    IF NOT, BRANCH\n         MVI   VTOCFLG,C'Y'            IF SO, SET VTOC FLAG\nCD30     EQU   *\n         AR    R2,R3                   GO TO NEXT DD ENTRY\n         B     CD10                    LOOP BACK\nCD40     EQU   *\n*\n*  INITIALIZE THE WORK AREA.  OPEN THE VTOC AND SYSIN IF PRESENT.\n*    OPEN THE CLIST OUTPUT FILE.  WRITE THE FIRST 2 LINES OF THE\n*    CLIST INTO THE OUTPUT FILE.\n*\nINIT     EQU   *\n         LA    R6,DATA                 SET UP REGISTERS FOR\n         LA    R7,MOVEL                  LONG MOVE\n         LA    R8,CDATA\n         LA    R9,MOVEL\n         MVCL  R6,R8                   LOAD INITIAL DATA INTO WORKAREA\n         LA    R6,DSNAME               SET UP CAMLST PARAMETERS\n         ST    R6,LOCLIST+4              ADDR OF DATA SET NAME\n         ST    R6,OPTLIST+4              ADDR OF DATA SET NAME\n         LA    R6,LOCWORK\n         ST    R6,LOCLIST+12             ADDR OF WORK BUFFER\n         LA    R6,VOL\n         ST    R6,OPTLIST+8              ADDR OF VOLUME SERIAL\n         LA    R6,DSCB+44\n         ST    R6,OPTLIST+12             ADDR OF DSCB BUFFER\n         LA    R6,DSGBUF               INIT DSG POINTER\n         ST    R6,DSGPTR                 FOR DSG BUFFER\n         MVI   DSGBUF,X'00'            ZERO OUT DSG BUFFER\n         MVC   DSGBUF+1(L'DSGBUF-1),DSGBUF\n         CLI   VTOCFLG,C'Y'            DD EXIST FOR VTOC?\n         BNE   IN10                    IF NOT, BRANCH\n         LA    R10,VTOC                GET ADDRESS OF DCB1\n         USING IHADCB,R10              ADDRESSIBILITY TO DCB\n         LA    R11,JFCBA               GET ADDRESS OF BUFFER\n         ST    R11,EXLIST              STORE ADDRESS IN EXIT LIST\n         MVI   EXLIST,X'87'            SET END OF LIST & JFCB BYTE\n         LA    R6,EXLIST               GET ADDRESS OF EXIT LIST\n         ST    R6,DCBEXLST             STORE IN DCB\n         DROP  R10\n         RDJFCB (VTOC,),MF=(E,EX1)     READ JOB FILE CONTROL BLOCK\n         USING INFMJFCB,R11            ESTABLISH ADDRESSABILITY\n         LTR   R15,R15                 CHECK RETURN CODE\n         BNZ   RETURN                  IF NOT SUCCESSFUL, EXIT\n         MVI   JFCBDSNM,X'04'          CHANGE DATASET NAME TO\n         MVC   JFCBDSNM+1(43),JFCBDSNM   44 X'04'S\n         OI    JFCBTSDM,JFCNWRIT       SET FLAG NOT TO WRITE BACK\n         MVC   SAVEVOL,JFCBVOLS        SAVE VOLSER\n         DROP  R11\n         OPEN  (VTOC,INPUT),TYPE=J,MF=(E,EX2) OPEN THE VTOC\n         LTR   R15,R15\n         BNZ   CLOSEX\nIN10     EQU   *\n         CLI   SYSINFLG,C'Y'           DOES SYSIN EXIST?\n         BNE   IN20                    IF NOT, BRANCH\n         OPEN  (SYSIN,INPUT),MF=(E,EX2)  OPEN SYSIN\n         LTR   R15,R15\n         BNZ   CLOSEX\nIN20     EQU   *\n         OPEN  (PRINT,OUTPUT),MF=(E,EX2) OPEN OUTPUT FILE\n         LTR   R15,R15\n         BNZ   CLOSEX\n         MVI   LINE,X'40'              INITIALIZE LINE\n         MVC   LINE+1(L'LINE-1),LINE     TO ALL SPACES\n         LA    R5,RPARMS               SET R5 TO PARM ADDRESS\n         MVC   DLXCMD(L'FSTLINE),FSTLINE\n         BAL   R3,PRINTIT              OUTPUT FIRST LINE OF CLIST\n         MVC   DLXCMD(L'SNDLINE),SNDLINE\n         BAL   R3,PRINTIT              OUTPUT SECOND LINE OF CLIST\n         CLI   SYSINFLG,C'Y'           SYSIN EXIST?\n         BNE   READIT                  IF NOT, SKIP TO READ VTOC\n*\n*  IF SYSIN DATA EXISTS, READ IT AND ANALYZE THE SPECIFIED PARAMETERS.\n*    IF DSN'S ARE GIVEN, GO AHEAD AND PROCESS THOSE RIGHT AWAY.\n*\nREADSY   EQU   *\n         MVI   PARM,C' '               INIT PARM\n         MVC   PARM+1(L'PARM-1),PARM\n         LA    R6,PARM                 GET ADDRESS FOR PARAMETER BUFFER\n         MVI   VOL,C' '                INIT VOLUME SERIAL\n         MVC   VOL+1(L'VOL-1),VOL\n         MVI   DSNFLG,C'N'             INIT DATA SET NAME FLAG\nRS10     EQU   *\n         GET   SYSIN,SYSINBUF          READ A RECORD\n         LA    R7,SYSINBUF             GET STARTING ADDRESS\n         LA    R8,80                   GET RECORD LENGTH\nRS20     EQU   *\n         CLI   0(R7),C' '              LOOK FOR THE FIRST NON-BLANK\n         BNE   RS30                    IF NON-BLANK, BRANCH\n         LA    R7,1(R7)                INCREMENT POINTER\n         BCT   R8,RS20                 AND LOOP UP TO 80 TIMES\n         B     INVALID                 IF BLANK RECORD, REPORT INVALID\nRS30     EQU   *\n         CLI   0(R7),C','              END OF PARM?\n         BE    ANLPARM\n         CLI   0(R7),C' '\n         BE    ANLPARM\n         MVC   0(1,R6),0(R7)           STORE CHARACTER\n         LA    R6,1(R6)                INCREMENT POINTER\n         LA    R7,1(R7)                INCREMENT POINTER\n         BCT   R8,RS30\n         B     INVALID\nANLPARM  EQU   *\n         LA    R9,PARM+4               ANALYZE PARM\n         SR    R9,R6                   CALCULATE LENGTH\n         LPR   R9,R9                   NEGATE\n         LTR   R9,R9                   ANYTHING THERE?\n         BZ    AP30                    IF NOT, IGNORE IT\n         CLC   PARM(4),=C'VOL='        VOLUME PARAMETER?\n         BNE   AP10                    IF NOT, BRANCH\n         MVC   VOL,PARM+4              STORE VOLUME\n         B     AP30                    GO BACK FOR MORE\nAP10     EQU   *\n         CLC   PARM(4),=C'DSN='        DATA SET NAME?\n         BE    AP20                    IF SO, BRANCH\n         CLC   PARM(4),=C'DSG='        DATA SET GROUP?\n         BNE   INVALID                 IF NOT, BRANCH\n         L     R4,DSGPTR               GET POINTER INTO GROUP BUFFER\n         STH   R9,0(R4)                STORE GROUP NAME LENGTH\n         BCTR  R9,0                    DECREMENT LENGTH\n         EX    R9,MOVEDSG              STORE GROUP NAME\n         LA    R9,3(R9)                INCREMENT POINTER\n         A     R9,DSGPTR                 INTO GROUP NAME BUFFER\n         ST    R9,DSGPTR               AND STORE FOR NEXT TIME AROUND\n         MVI   DSGFLG,C'Y'             SET FLAG\n         B     AP30                    LOOP BACK TO READ ANOTHER\nAP20     EQU   *\n         MVI   DSNAME,C' '             SPACE OUT DATA SET NAME BUF\n         MVC   DSNAME+1(L'DSNAME-1),DSNAME\n         LA    R4,DSNAME               GET ADDR OF DATA SET NAME BUF\n         BCTR  R9,0                    DECREMENT LENGTH\n         EX    R9,MOVEDSN              STORE DATA SET NAME\n         MVI   DSNFLG,C'Y'             SET FLAG\nAP30     EQU   *\n         CLI   0(R7),C','              MORE PARMS?\n         BNE   PROCDSN                 IF NOT, CONTINUE\n         MVI   PARM,C' '               CLEAR PARM AREA\n         MVC   PARM+1(L'PARM-1),PARM\n         LA    R6,PARM\n         LA    R7,1(R7)\n         B     RS30\n*\nPROCDSN  EQU   *\n         CLI   DSNFLG,C'Y'             DATA SET NAME?\n         BNE   READSY                  IF NOT, DON'T TO ANYTHING NOW\n         CLI   VOL,C' '                DOES VOLUME EXIST?\n         BNE   PD10                    IF SO, BRANCH\n         LOCATE LOCLIST                IF NOT, FIGURE OUT VOLUME\n         LTR   15,15\n         BNZ   CLOSEX\n         MVC   VOL,LOCWORK+6           GET VOLUME SERIAL #\nPD10     EQU   *\n         OBTAIN OPTLIST                READ DSCB\n         LTR   15,15\n         BNZ   CLOSEX\n         MVC   DSCB(L'DSNAME),DSNAME   LOAD DATA SET NAME\n         USING IECSDSL1,R11            ESTABLISH ADDRESSABILITY\n         LA    R11,DSCB                LOAD DSCB ADDRESS\n         B     PROCDS                  GO AHEAD & PROCESS DATA SET\n*\nINVALID  EQU   *\n         MVC   DLXCMD(L'INVLINE),INVLINE\n         BAL   R3,PRINTIT              NOTIFY OF INVALID SYSIN DATA\n         B     READSY\n*\nENDSYSIN EQU   *\n         CLI   DSGFLG,C'Y'             GROUPS PRESENT?\n         BNE   CLOSE                   IF NOT, THAT'S IT\n         MVI   SYSINFLG,C'N'           TURN OFF SYSIN FLAG\n*\n*  IF NO SYSIN DATA OR IF DSG'S SPECIFIED IN SYSIN, READ THE VTOC\n*    FORMAT-1 RECORDS.  IF NO SYSIN DATA, PROCESS ALL DATA SETS\n*    ON VOLUME WITH THE EXCEPTION OF A FEW (SUCH AS THE VTOC INDEX,\n*    CATALOG, CATALOG INDEX, TEMPORARY DATA SETS, ETC.)\n*\nREADIT   EQU   *\n         MVC   VOL,SAVEVOL\nRI10     EQU   *\n         READ  DECB,SF,VTOC,DSCB,'S',MF=E  READ A VTOC RECORD\n         CHECK DECB                    WAIT TIL DONE\n         USING IECSDSL1,R11            ESTABLISH ADDRESSABILITY\n         LA    R11,DSCB                LOAD DSCB ADDRESS\n         CLI   DS1FMTID,C'1'           FORMAT 1 RECORD?\n         BNE   RI10                    IF NOT, GO BACK FOR ANOTHER\n         CLI   DSGFLG,C'Y'             GROUP NAMES PRESENT?\n         BE    CHKNAME                 IF SO, CHECK DATA SET NAME\n         CLC   DS1DSNAM(11),=C'SYS1.VTOCIX'\n         BE    RI10\n         CLC   DS1DSNAM(9),=C'SYS1.VVDS'\n         BE    RI10\n         CLC   DS1DSNAM(7),=C'CATALOG'            IGNORE CERTAIN\n         BE    RI10                                DATA SETS\n         CLC   DS1DSNAM(8),=C'CATINDEX'\n         BE    RI10\n         CLC   DS1DSNAM(8),=C'FDRABR.V'\n         BE    RI10\n         CLC   DS1DSNAM(3),=C'SYS'\n         BNE   PROCDS\n         LA    R7,DS1DSNAM+3\n         LA    R8,5\nRI20     EQU   *\n         TM    0(R7),X'F0'\n         BNO   PROCDS\n         LA    R7,1(R7)\n         BCT   R8,RI20\n         B     RI10\n*\n*  IF DSG'S SPECIFIED IN SYSIN, COMPARE DATA SET NAME AGAINST\n*    ALL DESIRED GROUPS.  IF NO MATCH, DON'T PROCESS THAT DATA SET.\n*\nCHKNAME  EQU   *\n         LA    R6,DSGBUF               GET ADDRESS OF GROUP NAME BUF\nCN10     EQU   *\n         LH    R7,0(R6)                GET LENGTH OF NAME\n         LTR   R7,R7                   ANYTHING THERE?\n         BZ    RI10                    IF NOT, GO BACK FOR ANOTHER\n         BCTR  R7,0                    DECREMENT LENGTH\n         EX    R7,COMPDSG              COMPARE WITH DATA SET NAME\n         BE    PROCDS                  IF MATCH, BRANCH TO PROCESS\n         LA    R7,3(R7)                INCREMENT POINTER\n         AR    R6,R7                     INTO GROUP NAME BUFFER\n         B     CN10                    AND LOOP\n*\n*  GENERATE CLIST COMMANDS FOR THE DATA SET.\n*\nPROCDS   EQU   *\n         TM    DS1DSORG+1,DS1ACBM      VSAM FILE?\n         BO    VSAM                    IF SO, BRANCH TO VSAM SECTION\n*\n*  GENERATE OUTPUT RECORDS FOR NON-VSAM FILES.\n*\nNONVSAM  EQU   *\n         CLI   VSAMONLY,C'Y'           IS THIS FOR VSAM ONLY?\n         BE    NO20                    IF SO, SKIP IT\n         BAL   R4,DDRACF               DELETE RACF PROTECTION\n         TM    DS1DSIND,DS1IND40       IS FILE RACF PROTECTED?\n         BO    NO10                    IF SO, GO FIGURE OUT RACF STUFF\n         B     READNXT                 IF NOT, THAT'S ALL FOR THAT REC\nNO10     EQU   *\n         BAL   R4,GTRACF               GET RACF DATA\n         LTR   R15,R15\n         BNZ   READNXT\n         BAL   R4,ADRACF               ADD RACF PROTECTION\nNO20     EQU   *\n         B     READNXT                 GO BACK FOR ANOTHER RECORD\n*\n*  GENERATE OUTPUT RECORDS FOR VSAM FILES.\n*\nVSAM     EQU   *\n         BAL   R4,DDRACF               DELETE RACF PROTECTION\n         BAL   R4,GTRACF               DOES IT NEED RACF PROTECTION?\n         LTR   R15,R15                 CHECK RETURN CODE\n         BNZ   VS10                    IF NO RACF, BRANCH\n         BAL   R4,ADRACF               ADD RACF PROTECTION\nVS10     EQU   *\n         LA    R7,DS1DSNAM             GET ADDRESS OF DATA SET NAME\n         LA    R8,L'DS1DSNAM           SET LOOP FOR MAX OF 44\nVS20     EQU   *\n         CLI   0(R7),C' '              LOOK FOR END OF NAME\n         BE    VS30                    IF FOUND, BRANCH\n         LA    R7,1(R7)                IF NOT, INCREMENT ADDRESS\n         BCT   R8,VS20                 AND LOOP\nVS30     EQU   *\n         S     R7,=F'5'                GO BACK 5 CHARACTERS\n         CLC   0(5,R7),=C'.DATA'       IS THIS THE DATA COMPONENT?\n         BNE   VS40                    IF NOT, BRANCH\n         MVC   0(5,R7),=C'     '       IF SO, CLEAR OUT FOR CLUSTER\n         B     VSAM                    AND LOOP BACK\nVS40     EQU   *\n         B     READNXT                 LOOP BACK FOR ANOTHER DATA SET\n*\nREADNXT  EQU   *\n         CLI   SYSINFLG,C'Y'           PROCESSING SYSIN DATA?\n         BNE   RI10                    IF NOT, GO BACK TO READING VTOC\n         B     READSY                  IF SO, GO BACK TO READING SYSIN\n*\n*  CLOSE FILES AND TERMINATE PROGRAM.\n*\nCLOSEX   EQU   *                       ERROR EXIT\n         LR    R7,R15                  SAVE CONTENTS OF R15\n         CLOSE (VTOC,,PRINT,,SYSIN),MF=(E,EX4) CLOSE THE FILES\n         LR    R15,R7                  RESTORE CONTENTS OF R15\n         B     RETURN\nCLOSE    EQU   *                       STANDARD EXIT\n         MVC   DLXCMD(L'LSTLINE),LSTLINE\n         BAL   R3,PRINTIT              OUTPUT LAST LINE OF CLIST\n         CLOSE (VTOC,,PRINT,,SYSIN),MF=(E,EX4) CLOSE THE FILES\nRETURN   L     R13,4(R13)              RESTORE REGISTERS\n         RETURN (14,12),RC=(15)        AND END\n*\n***********************************************************************\n*                                                                     *\n*                      SUBROUTINES                                    *\n*                                                                     *\n***********************************************************************\n*\n*  SUBROUTINE TO GENERATE OUTPUT LINE FOR REMOVING RACF PROTECTION.\n*\nDDRACF   EQU   *\n         MVC   DLXCMD,=C'DLXAUTHC'     LOAD PRINT LINE FOR\n         MVC   RACFCMD,=C'DD'            REMOVING RACF PROTECTION\n         MVC   0(L'DS1DSNAM,R5),DS1DSNAM\n         LNR   R7,R5                   SAVE POINTER\n         BAL   R2,NXTSPC               FIND NEXT SPACE\n         AR    R7,R5                   CALCULATE LENGTH OF\n         BCTR  R7,R0                     DATASET NAME\n         ST    R7,DSNLEN               AND STORE IT FOR LATER USE\n         TM    DS1DSORG+1,DS1ACBM      VSAM FILE?\n         BO    DD10                    IF SO, SKIP VOLUME\n         MVC   0(L'VOLPARM,R5),VOLPARM\n         MVC   L'VOLPARM(L'VOL,R5),VOL\n         MVI   L'VOLPARM+L'VOL(R5),C')'\nDD10     EQU   *\n         BAL   R3,PRINTIT              PRINT THE LINE\n         BR    R4\n*\n*  SUBROUTINE TO GET RACF INFORMATION FOR SPECIFIED DATA SET.\n*\nGTRACF   EQU   *\n         MVC   RACFDSN,DS1DSNAM             LOAD DATASET NAME\n         MVC   RACFDSNL,DSNLEN+3            LOAD LENGTH OF DS NAME\n         MVC   RACFWORK(4),RACFLENG         LOAD LENGTH OF WORK AREA\n         ICHEINTY LOCATE,TYPE='DS',ENTRY=RACFDSNL,VOLUME=VOL,          X\n               ACTIONS=(ACT1,ACT2,ACT3,ACT4,ACT5,ACT6),                X\n               WKAREA=RACFWORK,OPTIONS=(ACTION),MF=(E,EX5)\n         BR    R4\n*\n*  SUBROUTINE TO GENERATE OUTPUT LINES TO RACF PROTECT DATA SET.\n*\nADRACF   EQU   *\n         LA    R10,RACFWORK\n         USING RACFLDS,R10                  ADDRESSABILITY\n         MVC   DLXCMD,=C'DLXAUTHC'          LOAD PRINT LINE FOR\n         MVC   RACFCMD,=C'AD'               DEFINE THE DS TO RACF\n         MVC   0(L'DS1DSNAM,R5),DS1DSNAM    GET DATASET NAME\n         BAL   R2,NXTSPC\n         TM    DS1DSORG+1,DS1ACBM           VSAM FILE?\n         BO    AD30                         IF SO, SKIP VOLUME & UNIT\n         MVC   0(L'VOLPARM,R5),VOLPARM      GET VOLUME PARAMETER\n         MVC   L'VOLPARM(L'VOL,R5),VOL\n         MVI   L'VOLPARM+L'VOL(R5),C')'\n         BAL   R2,NXTSPC\n         MVC   0(L'UNITPARM,R5),UNITPARM    GET UNIT PARAMETER\n         CLI   DEVTYPX,X'FF'                UNIT AVAILABLE?\n         BE    AD10                         IF NOT, BRANCH AROUND\n         MVC   L'UNITPARM(L'DEVTYPX,R5),DEVTYPX\n         B     AD20\nAD10     EQU   *\n         MVC   L'UNITPARM(L'DEFUNIT,R5),DEFUNIT\nAD20     EQU   *\n         BAL   R2,NXTSPC\n         BCTR  R5,R0\n         MVI   0(R5),C')'\n         BAL   R2,NXTSPC\nAD30     EQU   *\n         MVC   0(L'OWNPARM,R5),OWNPARM      GET OWNER PARAMETER\n         MVC   L'OWNPARM(L'AUTHOR,R5),AUTHOR\n         BAL   R2,NXTSPC\n         BCTR  R5,R0\n         MVI   0(R5),C')'\n         BAL   R2,NXTSPC\n         MVC   0(L'UACCPARM,R5),UACCPARM    GET UNIVERSAL ACCESS CODE\n         MVC   ACCFLG,UNIVACS\n         BAL   R3,GETACC\n         MVC   L'UACCPARM(L'ACCESS,R5),ACCESS\n         BAL   R2,NXTSPC\n         BAL   R3,PRINTIT                   PRINT THE LINE\n         LA    R7,USERS                     GET POINTER TO USER IDS\n         MVC   USERNO(2),=H'0'\n         MVC   USERNO+2(2),ACLCNT           CALC POINTER TO USER ACS\n         CLC   USERNO(4),=F'0'              IF NO PERMITS NEEDED,\n         BE    LOOPEND                        BRANCH OUT\n         L     R9,USERNO\n         LA    R8,0\n         M     R8,=F'8'\n         LA    R9,2(R9)\n         AR    R9,R7\n         L     R8,USERNO\nLOOP     EQU   *\n         MVC   DLXCMD,=C'DLXAUTHC'          LOAD THE PRINT LINE\n         MVC   RACFCMD,=C'PE'                 FOR PERMITS\n         MVC   0(L'DS1DSNAM,R5),DS1DSNAM    LOAD DATA SET NAME\n         BAL   R2,NXTSPC\n         TM    DS1DSORG+1,DS1ACBM           VSAM FILE?\n         BO    LP10                         IF SO, SKIP VOLUME\n         MVC   0(L'VOLPARM,R5),VOLPARM      GET VOLUME PARAMETER\n         MVC   L'VOLPARM(L'VOL,R5),VOL\n         MVI   L'VOLPARM+L'VOL(R5),C')'\n         BAL   R2,NXTSPC\nLP10     EQU   *\n         MVC   0(L'IDPARM,R5),IDPARM        LOAD ID PARAMETER\n         MVC   L'IDPARM(8,R5),0(R7)\n         LA    R7,8(R7)                     MOVE POINTER\n         BAL   R2,NXTSPC\n         BCTR  R5,R0\n         MVI   0(R5),C')'\n         BAL   R2,NXTSPC\n         MVC   0(L'ACSPARM,R5),ACSPARM      LOAD ACCESS PARAMETER\n         MVC   ACCFLG,0(R9)                 GET ACCESS\n         LA    R9,1(R9)                     MOVE POINTER\n         BAL   R3,GETACC\n         MVC   L'ACSPARM(8,R5),ACCESS\n         BAL   R3,PRINTIT\n         BCT   R8,LOOP                      LOOP THRU USER IDS\nLOOPEND  EQU   *\n         DROP  R10\n         BR    R4\n*\n*  SUBROUTINE TO TRANSLATE THE RACF ACCESS CODE BYTE.\n*\nGETACC   EQU   *\n         MVC   ACCESS,=C'NONE)   '          DEFAULT TO 'NONE'\n         TM    ACCFLG,X'10'                 CHECK FOR 'READ'\n         BNO   GA10\n         MVC   ACCESS,=C'READ)   '\n         B     GA40\nGA10     EQU   *\n         TM    ACCFLG,X'20'                 CHECK FOR 'UPDATE'\n         BNO   GA20\n         MVC   ACCESS,=C'UPDATE) '\n         B     GA40\nGA20     EQU   *\n         TM    ACCFLG,X'80'                 CHECK FOR 'ALTER'\n         BNO   GA30\n         MVC   ACCESS,=C'ALTER)  '\n         B     GA40\nGA30     EQU   *\n         TM    ACCFLG,X'40'                 CHECK FOR 'CONTROL'\n         BNO   GA40\n         MVC   ACCESS,=C'CONTROL)'\nGA40     EQU   *\n         BR    R3\n*\n*  SUBROUTINE TO WRITE THE OUTPUT LINE INTO THE CLIST DATA SET\n*\nPRINTIT  EQU   *\n         AP    LINE#,=P'100'           INCREMENT LINE NUMBER\n         UNPK  LINENO,LINE#            UNPACK LINE NUMBER\n         MVZ   LINENO+7(1),LINENO+6      & MOVE THE ZONE BYTE\n         BAL   R2,NXTSPC               FIND END OF LINE\n         LA    R2,LINE\n         SR    R5,R2                   CALCULATE LINE LENGTH\n         STH   R5,LINE                   AND STORE\n         MVC   LINE+2(2),=X'0000'\n         PUT   PRINT,LINE              PRINT THE LINE\n         MVI   LINE,X'40'              RESET THE LINE BUFFER\n         MVC   LINE+1(L'LINE-1),LINE     TO SPACES\n         LA    R5,RPARMS               RESET R5 TO PARM ADDRESS\n         BR    R3                      RETURN\n*\n*  SUBROUTINE TO POINT TO THE NEXT DATA POSITION IN THE OUTPUT LINE.\n*\nNXTSPC   EQU   *\n         LA    R5,1(R5)                INCREMENT POINTER\n         CLC   0(4,R5),=C'    '        CHECK FOR A SPACE\n         BNE   NXTSPC                  LOOP TIL SPACE FOUND\n         LA    R5,1(R5)                INCREMENT ONCE MORE\n         BR    R2                      RETURN\n*\n***********************************************************************\n*                                                                     *\n*                     CONSTANT DATA                                   *\n*                                                                     *\n***********************************************************************\n*\n*  REGISTER EQUATES\n*\nR0       EQU   00\nR1       EQU   01\nR2       EQU   02\nR3       EQU   03\nR4       EQU   04\nR5       EQU   05\nR6       EQU   06\nR7       EQU   07\nR8       EQU   08\nR9       EQU   09\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n*\n         LTORG\n*\n*    THE FOLLOWING DATA IS USED TO INIT PART OF THE GETMAIN'ED AREA\n*\nCDATA    DS    0F\nILINE#   DC    P'00000000'\nDCB1     DCB   DDNAME=VTOC,DSORG=PS,RECFM=U,KEYLEN=44,BLKSIZE=96,      X\n               MACRF=(R),EODAD=CLOSE\nDCB2     DCB   DDNAME=CLIST,DSORG=PS,RECFM=VB,LRECL=255,               X\n               MACRF=(PM)\nDCB3     DCB   DDNAME=SYSIN,DSORG=PS,LRECL=80,MACRF=(GM),              X\n               RECFM=FB,EODAD=ENDSYSIN\nLIST1    RDJFCB (,),MF=L\nLIST2    OPEN   (,),MF=L\nLIST3    READ   DECB1,SF,MF=L\nLIST4    CLOSE  (,),MF=L\nLIST5    ICHEINTY LOCATE,TYPE='DS',                                    X\n               ACTIONS=(ACT1,ACT2,ACT3,ACT4,ACT5,ACT6),                X\n               OPTIONS=(ACTION),MF=L\nLIST6    CAMLST NAME,*,,*\nLIST7    CAMLST SEARCH,*,*,*\nINST1    MVC   2(0,R4),PARM+4\nINST2    MVC   0(0,R4),PARM+4\nINST3    CLC   2(0,R6),DS1DSNAM\nMOVEL    EQU   *-CDATA\n*\n*    THE FOLLOWING FIELDS WILL BE RETRIEVED FROM THE RACF DATA SET\n*\nACT1     ICHEACTN FIELD=AUTHOR\nACT2     ICHEACTN FIELD=UNIVACS\nACT3     ICHEACTN FIELD=DEVTYPX\nACT4     ICHEACTN FIELD=ACLCNT\nACT5     ICHEACTN FIELD=USERID\nACT6     ICHEACTN FIELD=USERACS\n*\n*\n*  MISCELLANEOUS CONSTANTS\n*\nVOLPARM  DC    C'VOLUME('\nUNITPARM DC    C'UNIT('\nOWNPARM  DC    C'OWNER('\nUACCPARM DC    C'UACC('\nIDPARM   DC    C'ID('\nACSPARM  DC    C'ACCESS('\nDEFUNIT  DC    C'SYSALLDA'\nFSTLINE  DC    C'PROC 0'\nSNDLINE  DC    C'CONTROL LIST NOFLUSH PROMPT MSG'\nLSTLINE  DC    C'END'\nINVLINE  DC    C'/*  ** CHECK SYSIN FOR INVALID DATA **  */'\nRACFLENG DC    F'1024'\n*\n***********************************************************************\n*                                                                     *\n*                    DSECTS FOR GETMAIN'ED AREA                       *\n*                                                                     *\n***********************************************************************\nWORKAREA DSECT\nSAVEAREA DS    18F\n*\nLINE     DS    0CL255\n         DS    CL4\nLINENO   DS    CL8\nDLXCMD   DS    CL8\n         DS    CL1\nRACFCMD  DS    CL2\n         DS    CL1\nRPARMS   DS    CL231\n*\nVSAMONLY DS    CL1\nSYSINFLG DS    CL1\nVTOCFLG  DS    CL1\nPARMBUF  DS    CL20\nPARM     DS    CL80\nDSNAME   DS    CL44\nDSGFLG   DS    CL1\nDSNFLG   DS    CL1\nSYSINBUF DS    CL80\nSAVEVOL  DS    CL6\nVOL      DS    CL6\nDSGBUF   DS    XL250\nDSCB     DS    XL140\nJFCBA    DS    XL176\nRACFWORK DS    XL1028\nRACFDSNL DS    XL1\nRACFDSN  DS    CL44\nACCFLG   DS    XL1\nACCESS   DS    CL8\nDSNLEN   DS    1F\nEXLIST   DS    1F\nUSERNO   DS    1F\nDSGPTR   DS    1F\n         DS    0D\nLOCWORK  DS    XL265\n*\nDATA     DS    0F\nLINE#    DS    P'00000000'\nVTOC     DCB   DDNAME=VTOC,DSORG=PS,RECFM=U,KEYLEN=44,BLKSIZE=96,      X\n               MACRF=(R),EODAD=CLOSE\nPRINT    DCB   DDNAME=CLIST,DSORG=PS,RECFM=VB,LRECL=255,               X\n               MACRF=(PM)\nSYSIN    DCB   DDNAME=SYSIN,DSORG=PS,LRECL=80,MACRF=(GM),              X\n               RECFM=FB,EODAD=ENDSYSIN\nEX1      RDJFCB (,),MF=L\nEX2      OPEN   (,),MF=L\nEX3      READ   DECB,SF,MF=L\nEX4      CLOSE  (,),MF=L\nEX5      ICHEINTY LOCATE,TYPE='DS',                                    X\n               ACTIONS=(ACT1,ACT2,ACT3,ACT4,ACT5,ACT6),                X\n               OPTIONS=(ACTION),MF=L\nLOCLIST  DS     XL16\nOPTLIST  DS     XL16\nMOVEDSG  MVC   2(0,R4),PARM+4\nMOVEDSN  MVC   0(0,R4),PARM+4\nCOMPDSG  CLC   2(0,R6),DS1DSNAM\n*\nLDATA    EQU   *-WORKAREA\n*\n*\nRACFLDS  DSECT\n         DS    CL28\n         DS    CL2\nAUTHOR   DS    CL8\n         DS    CL2\nUNIVACS  DS    CL1\n         DS    CL2\nDEVTYPX  DS    CL8\n         DS    CL2\nACLCNT   DS    CL2\n         DS    CL2\nUSERS    DS    CL8\n         DS    CL959\n*\nDSCB1    DSECT\n         IECSDSL1 1\nJFCB     DSECT\n         IEFJFCBN ,\nDCBSECT  DSECT\n         DCBD  DSORG=PS,DEVD=DA\n         END   RACFCLST\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT416/FILE416.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT416", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}