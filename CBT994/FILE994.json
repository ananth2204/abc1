{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220013727000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 411502, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 8, "INMDSNAM": "CBT.V500.FILE994.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 411502, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 411502, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE994.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x08\\n'", "DS1TRBAL": "b'\\x90<'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xd0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xd0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\n\\x96\\x00\\x0c\\n\\x97\\x00\\x05\\x00\\t'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04c\\x006\\x01 \\x03O\\x01 \\x03O\\x08C\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf9\\xf9@@@'", "ispf": {"version": "04.99", "flags": 0, "createdate": "2020-02-03T00:00:00", "modifydate": "2020-02-03T08:43:36", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-499"}, "text": "REGULAR CBT TAPE - VERSION 499    FILE:  994\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT499.FILE994\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 13 MEMBERS COUNTED; CUMULATIVE SIZE IS 3,836 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   02/03/20    08:43:36    UTC-5:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "@FILE994": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04c\\x00)\\x01 \\x03O\\x01 \\x03O\\x08C\\x00c\\x00c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf9\\xf9@@@'", "ispf": {"version": "04.99", "flags": 0, "createdate": "2020-02-03T00:00:00", "modifydate": "2020-02-03T08:43:29", "lines": 99, "newlines": 99, "modlines": 0, "user": "CBT-499"}, "text": "//***FILE 994 is from Sam Golob (indirectly by way of Jeff Broido   *   FILE 994\n//*           and Bill Godfrey), and contains two programs to dump  *   FILE 994\n//*           the contents of a load module in hex, so that you     *   FILE 994\n//*           can see its contents.                                 *   FILE 994\n//*                                                                 *   FILE 994\n//*           This will help you \"see\" all the data within a load   *   FILE 994\n//*           module.                                               *   FILE 994\n//*                                                                 *   FILE 994\n//*           The dump is in an ISPF-like hex format, with ruler.   *   FILE 994\n//*                             --------- --- ------  ---- -----    *   FILE 994\n//*           email:   sbgolob@cbttape.org                          *   FILE 994\n//*                                                                 *   FILE 994\n//*           Important Note:                                       *   FILE 994\n//*           --------- ----                                        *   FILE 994\n//*           If you invoke LISTMOD or LISTMODD without parameters, *   FILE 994\n//*           then you will dump the ENTIRE MODULE from the         *   FILE 994\n//*           beginning to the end.  The header information         *   FILE 994\n//*           (see below) will help you locate the entry point      *   FILE 994\n//*           of the module displayed, within the dump of the       *   FILE 994\n//*           entire load module.                                   *   FILE 994\n//*                                                                 *   FILE 994\n//*           If you invoke LISTMOD or LISTMODD with the parameter  *   FILE 994\n//*           \"ENTRY\", then the display will only go from the       *   FILE 994\n//*           entry point until the physical end of the module.     *   FILE 994\n//*                                                                 *   FILE 994\n//*           Two programs which are included:                      *   FILE 994\n//*                                                                 *   FILE 994\n//*           LISTMOD, which dumps  64 characters of the load       *   FILE 994\n//*           module per line, and counts the displacements in      *   FILE 994\n//*           hexadecimal numbers.                                  *   FILE 994\n//*                                                                 *   FILE 994\n//*           LISTMODD, which dumps 100 characters of the load      *   FILE 994\n//*           module per line, and counts the displacements in      *   FILE 994\n//*           decimal numbers.  (LISTMOD with DECIMAL display)      *   FILE 994\n//*                                                                 *   FILE 994\n//*           Enough information is included in the headers         *   FILE 994\n//*           of the program outputs, to help you find the          *   FILE 994\n//*           information you want, in the load module.             *   FILE 994\n//*           as follows:                                           *   FILE 994\n//*                                                                 *   FILE 994\n//*    Sample heading information from a LOADED module:             *   FILE 994\n//*    (same heading for either program)                            *   FILE 994\n//*                                                                 *   FILE 994\n//* Loaded Program Name:  IEBCOPY                                   *   FILE 994\n//* --------------------------------------------------------------  *   FILE 994\n//* Module has been LOADED.       CDE Address:  009A9090            *   FILE 994\n//* Length of loaded module Hex:  00025CB0    Decimal:      154800  *   FILE 994\n//* Length after entry address :  00020CB0    Decimal:      134320  *   FILE 994\n//* Displacement of entry point:  00005000    Decimal:       20480  *   FILE 994\n//*                                                                 *   FILE 994\n//*    Sample heading information from a LPA module:                *   FILE 994\n//*                                                                 *   FILE 994\n//* Loaded Program Name:  IEFAB4A0                                  *   FILE 994\n//* ----------------------------------------------------------------*   FILE 994\n//* Module is from LPA.  LPDE Address: 00C742D0   Alias of: IEFW21SD*   FILE 994\n//* Length of loaded module Hex:  000DD450    Decimal:      906320  *   FILE 994\n//* Length after entry address :  00070D08    Decimal:      462088  *   FILE 994\n//* Displacement of entry point:  0006C748    Decimal:      444232  *   FILE 994\n//*                                                                 *   FILE 994\n//*           Output is in PUTLINE format, so it can be captured    *   FILE 994\n//*           and displayed on a full screen.                       *   FILE 994\n//*                                                                 *   FILE 994\n//*           Since the outputs are often very large, and need to   *   FILE 994\n//*           be captured in their entirety so the whole display    *   FILE 994\n//*           is visible and scrollable, therefore we have included *   FILE 994\n//*           Mark Zelden's TSOE, TSOV, TSOB, and TSOR REXX execs   *   FILE 994\n//*           here, to make the display easier, doing the outtrap   *   FILE 994\n//*           automatically.                                        *   FILE 994\n//*                                                                 *   FILE 994\n//*           For example: TSO TSOV LISTMOD  pgmname  (hex measure) *   FILE 994\n//*                                                                 *   FILE 994\n//*                        TSO TSOV LISTMODD pgmname  (dec measure) *   FILE 994\n//*                                                                 *   FILE 994\n//*           Or:                                                   *   FILE 994\n//*                                                                 *   FILE 994\n//*               TSO TSOV LISTMOD  pgmname ENTRY  (hex measure)    *   FILE 994\n//*                                                                 *   FILE 994\n//*               TSO TSOV LISTMODD pgmname ENTRY  (dec measure)    *   FILE 994\n//*                                                                 *   FILE 994\n//*               TSO TSOV LISTHEAD pgmname ENTRY                   *   FILE 994\n//*                                                                 *   FILE 994\n//*       Description of the programs:                              *   FILE 994\n//*                                                                 *   FILE 994\n//*           LISTMOD  - Displays the load module in 64-byte lines. *   FILE 994\n//*                      Displacements from the beginning are       *   FILE 994\n//*                      marked in hex.  75-byte wide display.      *   FILE 994\n//*                                                                 *   FILE 994\n//*           LISTMODD - Displays the load module in 100-byte lines *   FILE 994\n//*                      with the display being 112-bytes wide.     *   FILE 994\n//*                      Displacements from the beginning are       *   FILE 994\n//*                      marked in decimal.  Multiples of 100.      *   FILE 994\n//*                                                                 *   FILE 994\n//*           LISTHEAD - Program originally from Jeff Broido,       *   FILE 994\n//*                      which displays standard load module        *   FILE 994\n//*                      headers if they exist, and also the        *   FILE 994\n//*                      first 300 bytes of the load module,        *   FILE 994\n//*                      either at its beginning, or at its         *   FILE 994\n//*                      entry point.                               *   FILE 994\n//*                                                                 *   FILE 994\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LISTHEA$": {"ttr": 521, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x10\\x00%\\x01\\x055O\\x01 \\x03O\\x08B\\x00\\x1d\\x00\\x1d\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.16", "flags": 0, "createdate": "2005-12-20T00:00:00", "modifydate": "2020-02-03T08:42:25", "lines": 29, "newlines": 29, "modlines": 0, "user": "SBGOLOB"}, "text": "//SBGOLOBU JOB (CCMVS),ASMLINK,\n// NOTIFY=&SYSUID,\n// CLASS=A,MSGCLASS=X,COND=(1,LT)\n//*\n//*     ASM LINKEDIT FROM SOURCE ASM\n//*\n//ASMH EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,NORLD,NOXREF)\n//SYSLIB   DD DISP=SHR,DSN=SYS1.MACLIB\n//         DD DISP=SHR,DSN=SYS1.MODGEN\n//         DD DISP=SHR,DSN=SBGOLOB.CBT499.FILE994\n//SYSIN    DD DISP=SHR,DSN=SBGOLOB.CBT499.FILE994(LISTHEAD)\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,9),DISP=(,PASS),DCB=BLKSIZE=3200,\n//            DSN=&&TEMP\n//*\n//LKED   EXEC  PGM=HEWL,\n//       PARM='NCAL,MAP,LIST,LET,NOREUS,NORENT'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//SYSLMOD  DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//OBJECT   DD  DISP=(OLD,DELETE),DSN=&&TEMP\n//SYSLIN   DD  *\n INCLUDE OBJECT\n SETCODE AC(0)\n SETSSI  CB499994\n ENTRY   LISTHEAD\n NAME    LISTHEAD(R)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "LISTHEAD": {"ttr": 523, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01P\\x00\\x14\\x01\\x19$\\x9f\\x01 \\x03O\\x089\\x04\\xf3\\x04\\x95\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.80", "flags": 0, "createdate": "2019-09-06T00:00:00", "modifydate": "2020-02-03T08:39:14", "lines": 1267, "newlines": 1173, "modlines": 0, "user": "SBGOLOB"}, "text": "LISTHEAD TITLE '- TSO command to list load module eye-catchers.'\n         SPACE 1\n* ------------------------------------------------------------------- *\n***********************************************************************\n*                                                                     *\n*     LISTHEAD - TSO command to list the eye-catcher, if any, in      *\n*           the entry point CSECT of a load module in the normal      *\n*           search path.                                              *\n*                                                                     *\n*           Modified to list more non-standard eye catchers. (SG)     *\n*           Modified to give a 3-line hex display. (SG) - 7/19        *\n*           Modified to access the entry point or the load point,     *\n*               using the keyword ENTRY or by omitting it.            *\n*                                                                     *\n*     Register usage:                                                 *\n*           R5 - Base.                                                *\n*           R6 - Work.                                                *\n*           R7 - Work.                                                *\n*           R8 - Work.                                                *\n*           R9 - Work, Parse PDEs.                                    *\n*          R10 - CPPL pointer.                                        *\n*          R12 - Base.                                                *\n*                                                                     *\n*                               Jeffrey R. Broido                     *\n*                               25 April 2001                         *\n*                                                                     *\n*                               Modified by S.Golob  -  4/10          *\n*                               Modified by Updater  -  7/14          *\n*                               Modified by S.Golob  - 12/16          *\n*                               Modified by S.Golob  -  7/19          *\n*                               Modified by S.Golob  -  8/19          *\n*                               Modified by S.Golob  -  9/19          *\n*                                                                     *\n*     Change History (of sorts):                                      *\n*                                                                     *\n*        The original purpose of this program seems to have been,     *\n*        to display standard IBM headers in their load modules.       *\n*        Traditionally, an IBM-written load module would begin        *\n*        with an unconditional branch instruction X'47F0' that        *\n*        would branch over a standard-looking eyecatcher which        *\n*        told you the name of the module, and its release or PTF      *\n*        level.  These headers seem to be what the author of          *\n*        this program wanted to display.  ONLY THOSE HEADERS and      *\n*        no others.                                                   *\n*                                                                     *\n*        But things have changed in the IBM world, and the load       *\n*        modules which IBM produces, have fully reflected these       *\n*        changes.                                                     *\n*                                                                     *\n*        There are now other instructions which do unconditional      *\n*        branches, besides the BC instruction (whose unconditional    *\n*        format is X'47F0').  There are JUMP instructions and LARL    *\n*        instructions, and there are also BAKR and PR combinations.   *\n*        IBM uses all of these, and therefore, this program must      *\n*        change to reflect all of this new stuff from IBM.            *\n*                                                                     *\n*        The program works (currently) by issuing a LOAD macro        *\n*        against desired load module, and it searches the first       *\n*        few bytes of the loaded module, to see what is there.        *\n*                                                                     *\n*        If there are branch or jump instructions, then the program   *\n*        displays what was branched or jumped over.                   *\n*                                                                     *\n*        For diagnosis purposes, if you need to investigate near      *\n*        the beginning of any module entry point, the program will    *\n*        display the first 300 bytes at the load module entry         *\n*        point, in 3-line hexadecimal representation.                 *\n*                                                                     *\n*        If a load module contains multiple modules, each with its    *\n*        own header, these are not displayed.  Only the entry point   *\n*        header is displayed, or the header at the beginning of the   *\n*        module is displayed, if the ENTRY keyword was not used.      *\n*                                                                     *\n*        Sometimes a program is coded with comments at the beginning  *\n*        and the entry point, off the beginning, points to a BAKR     *\n*        instruction, or something similar, with the (non-executable) *\n*        comments at the beginning.  The LOAD macro does not return   *\n*        the address of these comments, and at the present time       *\n*        therefore, they cannot be displayed.  If the entry point     *\n*        is a BAKR instruction, the program was changed to say so.    *\n*        Hope this helps a bit more than before.  (SBG - June 2014)   *\n*                                                                     *\n*        Updated by Updater (July 20, 2014):                          *\n*        Process now adjusted to load the entire module, even if the  *\n*        entry point is not at the beginning.  This takes care of     *\n*        \"almost normal\" modules from SYS1.VTAMLIB and such, with     *\n*        the entry point just AFTER the eyecatcher.  The command      *\n*        previously would not therefore show such an eyecatcher.      *\n*        So the command was modified to find the address at the       *\n*        beginning of the module, even if the entry point officially  *\n*        was later.  If you want to display the entry point alone,    *\n*        then use the ENTRY keyword after the module name:            *\n*                                                                     *\n*                 example:    LISTHEAD modname ENTRY                  *\n*                                                                     *\n*        Please note that the HEX display will show all hex values    *\n*        in \"printable\" format, so you don't need any other tools     *\n*        to see the first 300 bytes of the load modules, displayed    *\n*        in a 3-line hexadecimal display.                             *\n*                                                                     *\n*        For some modules, such as IEBCOPY, you have to use the       *\n*        ENTRY parameter to get a realistic eyecatcher.  You'll       *\n*        have to try both ways with some modules, to see which        *\n*        way shows the beginning of the module more realistically.    *\n*                                                                     *\n*        If you want to see a hex display of the entire module, or    *\n*        from the entry point to the end of the module, use the       *\n*        LISTMOD program, which is a derivative of this program.      *\n*        (CBT File 423 or 994).                                       *\n*                                                                     *\n*        Updated by Sam Golob (December 12, 2016):           *DEC-2016*\n*        Updated by Sam Golob again (June 2, 2019)                    *\n*           (Made 3-line hex display instead of raw data)             *\n*        Updated by Sam Golob again (September 2019)                  *\n*                                                                     *\n*        Added a few extra keywords to limit the display:             *\n*                                                                     *\n*         NOHEX   - Leaves out the hex display of the first 300       *\n*                   bytes of the module.                              *\n*         NOTITLE - Leaves out the line telling you which module      *\n*                   got loaded.                                       *\n*                                                                     *\n*        Executing with NOHEX and NOTITLE produces the result that    *\n*        this program used to produce, before it was modified.        *\n*                                                                     *\n*        Accounted for possible NOOP instructions at the beginning    *\n*        of the program, before the branch over the header.           *\n*                                                                     *\n*        Fixed bug in EPUTL to GETMAIN SP=0 and FREEMAIN SP=0         *\n*                                                                     *\n*     CHANGES:  2020/02/03 - SBG                                      *\n*               Changed ruler to go from 0 to 99 instead of           *\n*               from 1 to 100.  It had been one byte off.             *\n*                                                                     *\n***********************************************************************\n         MACRO\n&LABEL   APUT  &MSG,                    @MESSAGE TEXT                  &\n               &LEN,                    @LENGTH OF MESSAGE             &\n               &RSA=,                   OPTIONAL 2 WORD SAVE AREA      &\n               &EPA=                    EPUTL EPA\n.*\n.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*\n.*  --> E@PUT\n.*\n.*  THIS MACRO SETS UP A PARAMETERS AND INVOKES THE EPUTL ROUTINE.\n.*\n.*\n.*  ARGUMENTS: -----------------------------------------------------\n.*\n.*      &MSG : ADDRESS OF MESSAGE TEXT OR A LITERAL\n.*\n.*      &LEN : LENGTH OF MESSAGE TEXT (DEFAULT IS L'&MSG)\n.*\n.*      &RSA :(OPTIONAL) 1 WORD SAVE AREA TO PRESERVE R14 FOR TPUT\n.*            COMPATIBILITY.\n.*\n.*      &EPA :(OPTIONAL) EPA FOR EPUTL ROUTINE\n.*\n.*\n.*   EXAMPLES: -----------------------------------------------------\n.*\n.*      1) APUT  'LITERAL'\n.*\n.*      2) APUT  (R3),80\n.*\n.*      3) APUT  LABEL\n.*\n.*      4) APUT  LABEL,40\n.*\n.*\n.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*\n.*\n.*  LOCAL SET SYMBOLS\n.*\n         LCLC  &SMA                     MESSAGE ADDRESS (REG)\n         LCLC  &SML                     MESSAGE LENGTH (REG)\n         LCLC  &SEP                     EPA (REGISTER)\n.*\n         LCLC  &L1,&L2,&L3              LOCAL LABELS\n.*\n&L1      SETC  'EP'.'&SYSNDX'.'L1'      LOCAL LABELS\n&L2      SETC  'EP'.'&SYSNDX'.'L2'      LOCAL LABELS\n&L3      SETC  'EP'.'&SYSNDX'.'L3'      LOCAL LABELS\n.*\n.*\n.*  MESSAGE ADDRESS\n.*\n         AIF   (T'&LABEL EQ 'O').A0500                      *HMD 11/86*\n.*                                                          *HMD 11/86*\n&LABEL   DS    0H                                           *HMD 11/86*\n.*                                                          *HMD 11/86*\n.A0500   ANOP                                               *HMD 11/86*\n         AIF   ('&MSG' NE '').A2000\n         MNOTE 8,'''&MSG='' MISSING / REQUIRED'\n         MEXIT\n.*\n.A2000   ANOP\n         AIF   ('&MSG'(1,1) NE '(').A2400\n&SMA     SETC  '&MSG'(2,K'&MSG-2)\n         LR    R1,&SMA                  @MESSAGE TEXT\n         AGO   .A2600\n.*\n.A2400   ANOP\n         AIF   ('&MSG'(1,1) NE '''').A2500\n         B     &L3                      BRANCH AROUND MESSAGE\n&L2      DC    C&MSG\n&L3      DS    0H\n         LA    R1,&L2                   @MESSAGE\n         AGO   .A2600\n.*\n.A2500   ANOP\n         LA    R1,&MSG                  @MESSAGE TEXT\n.A2600   ANOP\n.*\n.*  MESSAGE LENGTH\n.*\n         AIF   ('&LEN' NE '').A3000\n         AIF   ('&MSG'(1,1) NE '''').A2800\n         LA    R0,L'&L2                 MESSAGE LENGTH\n         AGO   .A3600\n.*\n.A2800   ANOP\n         AIF   ('&MSG'(1,1) EQ '(').A2900\n         LA    R0,L'&MSG                MESSAGE LENGTH\n         AGO   .A3600\n.*\n.A2900   ANOP\n         MNOTE 8,'''LEN'' MISSING / REQUIRED'\n         MEXIT\n.*\n.A3000   ANOP\n         AIF   ('&LEN'(1,1) NE '(').A3400\n&SML     SETC  '&LEN'(2,K'&LEN-2)\n         LR    R0,&SML                  MESSAGE LENGTH\n         AGO   .A3600\n.*\n.A3400   ANOP\n         LA    R0,&LEN                  MESSAGE LENGTH\n.A3600   ANOP\n.*\n.*  RSA\n.*\n         AIF   ('&RSA' EQ '').A4900\n         ST    R14,&RSA                 SAVE REGS 14\n.A4900   ANOP\n.*\n.*  ENTRY POINT\n.*\n         AIF   ('&EPA' NE '').A5000\n         L     R15,=V(EPUTL)            EPA\n         AGO   .A5600\n.*\n.A5000   AIF   ('&EPA'(1,1) NE '(').A5400\n&SEP     SETC  '&EPA'(2,K'&EPA-2)\n         LR    R15,&SEP                 EPA\n         AGO   .A5600\n.*\n.A5400   ANOP\n         L     R15,&EPA                 EPA\n.*\n.A5600   ANOP\n.*\n.*  CALL LINKAGE\n.*\n.ACALL   BALR  R14,R15                  CALL PUTLINE ROUTINE\n.*\n         AIF   ('&RSA' EQ '').A6900\n         L     R14,&RSA                 RESTORE R14\n.A6900   ANOP\n.*\n.AMEND   MEND\n* ------------------------------------------------------------------- *\n         MACRO                         Display hex numbers\n&NAME    HEX   &TO,&LEN,&FROM\n&NAME    DS    0H\n         STM   R15,R1,HEXSAVE          Save work registers.\n         LA    R1,&FROM                From location\n         LA    R0,&LEN                 Length to display\n         LA    R15,&TO                 Where to display\n         BAL   R4,HEX                  Do it.\n         LM    R15,R1,HEXSAVE          Restore work registers.\n         MEND\n* ------------------------------------------------------------------- *\nLISTHEAD AMODE 31                  Display load module headers.\nLISTHEAD RMODE ANY\nLISTHEAD CSECT\n         SPACE 1\n         SPACE 1\n         YREGS\n         USING LISTHEAD,R15        (ESTABLISH TEMPORARY BASE).\n         B     BEGIN               SKIP OVER HEADER.\nHEAD0    DC    AL1(HEADL)          EXCLUSIVE LENGTH OF HEADER.\nHEAD     DC    C'LISTHEAD - &SYSDATE - &SYSTIME  '\nHEADL    EQU   *-HEAD\n         DROP  R15                 (DROP TEMPORARY BASE).\nBEGIN    STM   R14,R12,12(R13)     SAVE CALLER'S REGISTERS\n         LR    R12,R15             COPY BASE.\n         USING LISTHEAD,R12,R5     (TELL ASSEMBLER).\n         LA    R5,4095(,R12)\n         LA    R5,1(,R5)\n         LR    R14,R13             COPY CALLER'S SAVE AREA POINTER.\n         LA    R13,SAVE            POINT TO MY SAVE AREA.\n         ST    R14,SAVE+4          CHAIN ...\n         ST    R13,8(,R14)         ... SAVE AREAS.\n         SPACE 1\n         MVI   LINE-1,X'40'\n         MVC   LINE,LINE-1\n         MVI   BLANKS-1,X'40'      FILL THE BLANKS FIELD\n         MVC   BLANKS,BLANKS-1       WITH BLANKS\n         MVC   MEMBER,BLANKS       Initialize member name with blanks.\n         LR    R10,R1              PRESERVE CPPL POINTER.\n         XC    FLAG3,FLAG3\n         USING CPPL,R10            (TELL ASSEMBLER)\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*        Initialize the Parse Parameter List and call TSO Parse.      *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         MVC   PPLUPT,CPPLUPT      COPY UPT ADDRESS.\n         MVC   PPLECT,CPPLECT      COPY ECT ADDRESS.\n         MVC   PPLCBUF,CPPLCBUF    COPY COMMAND BUFFER ADDRESS.\n         SPACE 1\n         LA    R1,PPL              POINT TO THE PPL.\n         XC    ECB,ECB             CLEAR ECB.\n         CALLTSSR EP=IKJPARS       PARSE INPUT.\n         ST    R15,SAVPARCD        SAVE RETURN CODE.\n         L     R9,ANS              POINT TO PDES.\n         USING PDL,R9              TELL ASSEMBLER.\n         LH    R1,PDLLM+4          LOAD LENGTH OF LOAD MODULE NAME.\n         BCTR  R1,*-*              DECREMENT LENGTH.\n         L     R15,PDLLM           POINT TO RETURNED MEMBER NAME.\n         EX    R1,MVMEM            COPY MEMBER NAME FROM PDL\n*      ( MVC   MEMBER(*-*),0(R15)  )\n         MVC   ENTRYOP,ENTRYKW     COPY PDE'S\n         MVC   NOHEXOP,NOHEXKW                               *DEC-2016*\n         MVC   NOTITOP,NOTITKW                               *DEC-2016*\n         MVC   HEXOP,HEXKW\n         MVC   TITOP,TITKW\n*                                  DON'T DO IKJRLSA\nGODISPLY DS    0H\n         MVI   LINE-1,X'40'        INITIALIZE DISPLAY AREA\n         L     R15,SAVPARCD        RETURN CODE FROM IKJPARS\n         LTR   R15,R15             INVALID PARAMETER ?\n         BNZ   HELPMSG             GO ISSUE HELP MSG AND EXIT.\n         DROP  R9\n         CLI   NOTITOP+1,1         NOTITLE?\n         BE    NOTIT1              YES, SKIP DISPLAY OF TITLE.\n         MVC   LINE,LINE-1\n         MVC   LINE(22),=C'Loaded Program Name:  '\n         MVC   LINE+22(8),MEMBER\n         CLI   ENTRYOP+1,1\n         BNE   PUTTIT01\n         MVC   LINE+42(13),=C'(Entry Point)'\n         B     PUTTIT02\nPUTTIT01 DS    0H\n         MVC   LINE+42(12),=C'(Load Point)'\nPUTTIT02 DS    0H\n         APUT  LINE,60\nNOTIT1   DS    0H                  Print a line of dashes\n         CLI   NOHEXOP+1,1         If NOHEX keyword\n         BE    LPA0                Then don't print dashes\n         MVC   LINE,LINE-1\n         MVC   LINE(65),DASHES\n         APUT  LINE,65\nNOTIT2   DS    0H\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*        Fetch the user-specified load module.                        *\n*                                                                     *\n***********************************************************************\n* ------------------------------------------------------------------- *\n*    We first ask if the module is from LPA, and if not, then we      *\n*    LOAD it.                                                         *\n* ------------------------------------------------------------------- *\n*    LOGIC OF THE PROGRAM WAS CHANGED TO DO A STANDARD \"LOAD\" FOR     *\n*    THE MODULE REQUESTED, BUT TO AFTERWARDS, ALSO CALCULATE THE      *\n*    MODULE ENTRY POINT IN THE DIFFERENT WAYS POSSIBLE, AND TO SAVE   *\n*    ALL THE RESULTS.  AFTERWARDS, DEPENDING ON WHETHER THE \"ENTRY\"   *\n*    PARAMETER WAS CODED, THE RESULTS ARE DISPLAYED ACCORDINGLY.      *\n* ------------------------------------------------------------------- *\nLPA0     DS    0H\n         LM    R0,R1,MEMBER       Load member name for IEAVVMSR\n         STM   R7,R8,LPAREGS      Save registers\n         L     R3,16              CVT\n         L     R15,352(,R3)       CVTLPDSR\n         BALR  R14,R15            CALL IEAVVMSR\n         B     LPAINFO            MODULE IS IN LPA, GET LPDE.\n         B     LOAD0              NOT IN LPA, TRY LOADING IT.\nLPAINFO  DS    0H\n         OI    FLAG2,X'01'        FLAG THE MODULE AS AN LPA MODULE.\n         LM    R7,R8,LPAREGS      RESTORE REGISTERS\n         LR    R6,R0              SAVE LPDE ADDRESS\n         ST    R6,LPDEADDR        And store it for reporting\n         L     R9,16(,R6)         GET ENTRY POINT ADDRESS\n         N     R9,=X'7FFFFFFF'    Get rid of high bit.\n         ST    R9,SAVER9B         SAVE MODULE ENTRY POINT\n         TM    X'1C'(R6),X'04'    IS THIS A MINOR LPDE (ALIAS)?\n         BZ    MAJLPDE            NO. PROCESS AS A MAJOR.\n         OI    FLAG2,X'02'        Mark this one as an alias.\n         MVC   MAJNAME(8),X'20'(R6)  Copy the major name for report.\n         L     R6,X'14'(,R6)      YES. GET ADDRESS OF MAJOR LPDE.\nMAJLPDE  DS    0H\n         L     R9,X'24'(,R6)      GET MODULE LOAD POINT.\n         N     R9,=X'7FFFFFFF'    Remove the 31-bit indicator\n         ST    R9,ADRSTART        Start of the full data of the module\n         ST    R9,SAVER9A         Save it in another place\n         ST    R9,SAVER9C         SAVE THE LOAD POINT.\n         L     R9,X'20'(,R6)      GET THE SIZE OF THE LOAD MODULE.\n         ST    R9,LOADLEN         SAVE THE ENTIRE SIZE\n         MVC   LOADWHOL,LOADLEN   COPY WHOLE SIZE\n         L     R2,SAVER9B         GET THE ENTRY POINT\n         L     R3,SAVER9C         SUBTRACT THE LOAD POINT\n         SR    R2,R3              GET THE DISPLACEMENT\n         BNP   ENTRYPM1           GO TO SAME CALC AS WITH LOAD\n         ST    R2,STORDIFF        SAVE THE DISPLACEMENT\n         B     ENTRYPM0           GO TO THE SAME CALC AS WITH LOAD\n* ------------------------------------------------------------------- *\n         SPACE 1\nLOAD0    DS    0H\n         LOAD  EPLOC=MEMBER,ERRET=LOAD1  FETCH LOAD MODULE TO LIST.\n*    Put in a display of x number of bytes at the load point, here.\nLOAD1    LTR   R15,R15             WAS LOAD SUCCESSFUL?\n         BZ    LOAD2               B IF YES; CONTINUE.\n*              SAY: CANNOT LOAD MEMBER.\n         MVC   LINE,LINE-1\n         MVC   LINE(MSG002L),MSG002\n         APUT  LINE,MSG002L\n         LA    R15,8               SET CC = 8.\n         ST    R15,SAVER15A        SAVE THE RETURN CODE\n         B     EXIT                EXIT.\nLOAD2    DS    0H\n         LR    R9,R0               POINT TO LOAD MODULE TO BE LISTED.\n         N     R9,=X'7FFFFFFF'     Get rid of high bit for calculations\n         ST    R9,ADRSTART         Start of the full data of the module\n         ST    R9,SAVER9A          Save load module data address\n         ST    R9,SAVER9B          Save it again in another place\n         NC    SAVER9B(4),=A(X'7FFFFFFF')  Maybe not necessary\n         N     R1,=A(X'00FFFFFF')  ISOLATE LENGTH IN DWORDS  *JUL-2014*\n         ST    R3,SAVER3B          Save R3\n         LR    R3,R1               Get length in doublewords\n         SLL   R3,3                Convert to bytes\n         ST    R3,SAVER3A          SAVE ORIGINAL LENGTH\n         L     R3,SAVER3B          Restore R3\n         SLL   R1,3                COMPUTE LENGTH IN BYTES   *JUL-2014*\n         ST    R1,LOADLEN          SAVE MAX DISPLAY LENGTH   *JUL-2014*\n         MVC   LOADWHOL,LOADLEN    Save it again\n* NOTE: IF THE 'ENTRY' KEYWORD IS SPECIFIED, AND THE         *JUL-2014*\n* ENTRY POINT IS NEAR THE END OF THE MODULE, THERE MAY BE    *JUL-2014*\n* FEWER BYTES THAN THE LOADLEN VALUE FROM THE ENTRY POINT    *JUL-2014*\n* TO THE END OF THE MODULE. AS A RESULT, THE DISPLAY OF      *JUL-2014*\n* LOADLEN BYTES MIGHT INCLUDE THE CONTENTS OF MEMORY BEYOND  *JUL-2014*\n* THE END OF THE MODULE.                                     *JUL-2014*\n*        CLI   ENTRYOP+1,1         IF ENTRY OR EP KEYWORD    *JUL-2014*\n*        BE    KEEPR9              SKIP THE NEW CODE         *JUL-2014*\n* IF THE LAST CDE IN JOB PACK AREA QUEUE IS FOR A MODULE     *JUL-2014*\n* THAT CONTAINS THE ENTRY POINT ADDRESS IN R9, USE THE       *JUL-2014*\n* ADDRESS OF THE MODULE INSTEAD OF THE ENTRY POINT.          *JUL-2014*\n* NOTE: COULD ALSO USE LOADPT= ON THE LOAD MACRO, BUT        *JUL-2014*\n* MVS 3.8 SYSTEMS DON'T HAVE LOADPT=.                        *JUL-2014*\n         N     R9,=A(X'7FFFFFFF')                            *JUL-2014*\n         L     R14,540             PSATOLD -> CURRENT TCB    *JUL-2014*\n         L     R14,TCBJSTCB-TCB(,R14) POINT TO JOB STEP TCB  *JUL-2014*\n         L     R14,TCBJPQ-TCB(,R14) PNT TO LAST CDE IN JPAQ  *JUL-2014*\n* ------------------------------------------------------------------- *\n*              The correct CDE might not be the last one,             *\n*             so chain back until you've got a name match.            *\n* ------------------------------------------------------------------- *\nCDELOOP  DS    0H                  Check if CDE matches member name\n         CLC   MEMBER(8),8(R14)    Is this the correct CDE? (match)\n         BE    CDEEND              Yes, then process it.\n         CLC   FULLZERO,0(R14)     Back at the beginning of the chain\n         BE    CDEBAD                without a match? Then error.\n         L     R14,0(,R14)         No match. Go back one previous CDE.\n         B     CDELOOP             Keep trying till match or first CDE\n*                                    without a match.\nCDEBAD   DS    0H\n         MVC   LINE,LINE-1         Error message if beginning of CDE\n         MVC   LINE(MSG003L),MSG003  was reached without a name match.\n         APUT  LINE,MSG003L\n         B     EXIT12              Code 12 for this one.\nCDEEND   DS    0H\n         ST    R14,CDEADDR         Store address of CDE found.\n         TM    CDATTR-CDENTRY(R14),CDMIN TEST FOR MINOR CDE  *JUL-2014*\n         BZ    MAJCDE              BRANCH IF MAJOR CDE       *JUL-2014*\n         L     R14,CDXLMJP-CDENTRY(,R14) POINT TO MAJOR CDE  *JUL-2014*\nMAJCDE   L     R14,CDXLMJP-CDENTRY(,R14) POINT TO EXTENT     *JUL-2014*\n         L     R0,XTLMSBAD-XTLST(,R14) ADDRESS OF MODULE     *JUL-2014*\n         ST    R0,SAVER9C\n         CR    R9,R0                                         *JUL-2014*\n         BL    KEEPR9                                        *JUL-2014*\n         L     R0,XTLMSBLA-XTLST(,R14) LENGTH OF MODULE      *JUL-2014*\n         N     R0,=A(X'7FFFFFFF')                            *JUL-2014*\n         ST    R0,SAVER1B\n         A     R0,XTLMSBAD-XTLST(,R14) ADDRESS OF MODULE     *JUL-2014*\n         ST    R0,SAVER9D\n         CR    R9,R0                                         *JUL-2014*\n         BNL   KEEPR9                                        *JUL-2014*\n         L     R0,XTLMSBAD-XTLST(,R14) ADDRESS OF MODULE     *JUL-2014*\n         LR    R9,R0                                         *JUL-2014*\n         ST    R9,SAVER9E\n* ------------------------------------------------------------------- *\n*            COME HERE FOR BOTH LPA AND LOADED MODULES                *\n* ------------------------------------------------------------------- *\nENTRYPM  DS    0H                  Check if entry point is displaced.\n         L     R2,SAVER9B          Get entry point of module\n         L     R3,SAVER9C          Get beginning addr of module\n         SR    R2,R3               Calculate difference in length\n         BNP   ENTRYPM1            Do a LOAD if number is not reliable\n         ST    R2,STORDIFF         Save the entry point displacement.\n*\nENTRYPM0 DS    0H\n         LTR   R2,R2               Is then entry point displacement 0?\n         BZ    NODIFF              Then do the whole module.\n*\nENTRYPM1 DS    0H                  It is different, then calculate.\n         L     R1,LOADWHOL         Entire length from LOAD macro\n         MVC   SAVER3A,LOADWHOL    Save it.\n         S     R1,STORDIFF         Subtract offset of entry point\n         ST    R1,LOADSMAL         Preserve reduced load length\n         MVC   SAVER3B,LOADSMAL    Save short length for later\n         B     YESDIFF             Yes, entry point diff from load pt\nKEEPR9   EQU   *                                             *JUL-2014*\n*\nNODIFF   DS    0H                  Go here if entry pt is load point\n         MVC   LOADSMAL,LOADWHOL   Size is from beginning to end\n         MVC   SAVER3B,LOADSMAL    Save size from entry point to end\n         L     R1,LOADWHOL         Load R1 with size\n         OI    FLAG1,X'01'         Flag load point equal entry point\n         L     R9,ADRSTART         Load R9 with data address\n*\nYESDIFF  DS    0H\n         TM    FLAG1,X'01'         Load point different from entry pt?\n         BZ    ENTRYDIF            No. Skip this section.\n         L     R1,LOADWHOL         Start R1 with whole size.\n         ST    R1,LOADLEN          And store it in LOADLEN.\n         L     R9,ADRSTART         Load R9 with data address\n* ------------------------------------------------------------------- *\nENTRYDIF DS    0H                  Display of Diagnostic Data\n         ST    R9,SAVER9A          SAVE THE PROGRAM DATA\n         CLI   NOTITOP+1,1         NOTITLE coded?\n         BE    KEEPR9A             Yes. Then skip this display.\n         MVC   LINE,LINE-1\n         MVC   LINE(28),=C'Length  of loaded module:     '\n         HEX   LINE+28,4,SAVER3A\n         MVC   LINE+41(11),=C'Load point:'\n         HEX   LINE+54,4,SAVER9C\n         STM   R14,R1,SAVE14T1\n         APUT  LINE,65\n         LM    R14,R1,SAVE14T1\n         MVC   LINE,LINE-1\n         MVC   LINE(25),=C'Entry Point Displacement:'\n         HEX   LINE+28,4,STORDIFF\n         MVC   LINE+40(12),=C'Entry point:'\n         HEX   LINE+54,4,SAVER9B\n         STM   R14,R1,SAVE14T1\n         APUT  LINE,65\n         LM    R14,R1,SAVE14T1\nKEEPR9A  DS    0H\n*\n         ST    R0,LADRSAVE\n         CLI   NOHEXOP+1,1         IF NOHEX KEYWORD          *DEC-2016*\n         BE    NODASH1             THEN DON'T PRINT HEX TITLE\n         MVC   LINE,LINE-1         PRINT THE HEX DISPLAY TITLE\n         MVC   LINE(65),=C'First 300 bytes of Loaded Storage (load modux\n               le e.p. + 300 bytes):'\n         APUT  LINE,70\n         MVC   LINE,LINE-1\n         MVC   LINE(65),DASHES\n         APUT  LINE,65\nNODASH1  DS    0H                                            *DEC-2016*\n* ------------------------------------------------------------------- *\n*              PREPARE FOR HEX DISPLAY OF ALL LINES                   *\n* ------------------------------------------------------------------- *\nENTRYPRM DS    0H                  Process the ENTRY keyword here.\n         CLI   ENTRYOP+1,1         Entry keyword not there?\n         BNE   BIGMOD              Go treat whole module.\n         L     R9,SAVER9B          Data address at entry point\n         ST    R9,SAVER9A          Store address away for display.\n         L     R1,LOADSMAL         Load reduced size, e.p. to end.\n         ST    R1,LOADLEN          Store that length for display\n         B     SMALLMOD            Don't display the whole module.\nBIGMOD   DS    0H\n         L     R9,SAVER9C          Address of beginning of the data.\n         ST    R9,SAVER9A          Store address away for display.\n         L     R1,LOADWHOL         Load the full size of the module.\n         ST    R1,LOADLEN          Store that length for display\n*        MVC   LOADLEN,LOADWHOL\n*              IF THE MODULE SIZE < 64 THEN DON'T SHOW 64\nSMALLMOD DS    0H\n         ST    R9,SAVER9A          Save pointer to the data.\n         CLI   NOHEXOP+1,1         If NOHEX keyword\n         BE    JUST1               Then skip all the hex printing.\n* ------------------------------------------------------------------- *\n*              PREPARE FOR HEX DISPLAY OF ONE LINE                    *\n* ------------------------------------------------------------------- *\n         L     R9,SAVER9A          Reload address of the data\n*              IF THE MODULE SIZE < 100 THEN DON'T SHOW 100\n         L     R1,LOADLEN          Get module length in bytes\n         CH    R1,=H'100'          Less than 100?\n         BNH   *+8                 Yes, skip limit to 100.\n         LH    R1,=H'100'          No. Just print 100 at a time\n         BCTR  R1,0                One less for execute.\n         ST    R1,SAVER1A          Save the length - 1\n         BAL   R7,PRTXLINE         Print these 100 bytes in hex\n* ------------------------------------------------------------------- *\n*                       DISPLAY SECOND LINE                           *\n* ------------------------------------------------------------------- *\n         L     R9,SAVER9A          Reload address of the data\n         LA    R9,100(,R9)         Skip 100 bytes from current\n         L     R1,LOADLEN          Get module length in bytes\n         S     R1,=F'100'          Subtract 100\n         BNP   JUST1               Finished? Stop the process.\n         CH    R1,=H'100'          Less than 100 bytes left?\n         BNH   *+8                 Yes. Use the current value\n         LH    R1,=H'100'          No. Limit the print to 100 bytes.\n         BCTR  R1,0                One less for execute.\n         ST    R1,SAVER1A          Save the length - 1\n         BAL   R7,PRTXLINE         Print these 100 bytes in hex\n* ------------------------------------------------------------------- *\n*                        DISPLAY THIRD LINE                           *\n* ------------------------------------------------------------------- *\n         L     R9,SAVER9A          Reload address of the data\n         LA    R9,200(,R9)         Skip 200 bytes from current\n         L     R1,LOADLEN          Get module length in bytes\n         S     R1,=F'200'          Subtract 200\n         BNP   JUST1               Finished? Stop the process.\n         CH    R1,=H'100'          Less than 100 bytes left?\n         BNH   *+8                 Yes. Use the current value\n         LH    R1,=H'100'          No. Limit the print to 100 bytes.\n         BCTR  R1,0                One less for execute.\n         ST    R1,SAVER1A          Save the length - 1\n         BAL   R7,PRTXLINE         Print these 100 bytes in hex\n* ------------------------------------------------------------------- *\n*                      END OF HEX DISPLAY                             *\n* ------------------------------------------------------------------- *\n*      NOW CHECK TO SEE IF THERE IS SOME KIND OF STANDARD HEADER      *\n* ------------------------------------------------------------------- *\nJUST1    EQU   *                   CHECK FOR INITIAL INSTRUCTIONS\n         L     R9,SAVER9A          Point to the data to check it.\n* ------------------------------------------------------------------- *\n*        ARE THERE LEADING NOOPS OR NULL BRANCHES OF ANY KIND?        *\n* ------------------------------------------------------------------- *\n         LA    R6,0                INITIALIZE R6 FOR LIMITING DISPLAY\nSKIPLOOP DS    0H                  SKIP ANY NOOP INSTRUCTIONS\n         MVC   WORKINST(8),0(R9)   MOVE 8 BYTES TO WORK AREA\n         CLC   =X'A704',WORKINST   IS THIS A JUMP NOOP?\n         BNE   TRYMOR01            NO. NEXT TRY.\n         LA    R9,4(,R9)           ADVANCE 4 BYTES\n         LA    R6,4(,R6)           SUBTRACT 4 BYTES PAST HEADER\n         B     SKIPLOOP            TRY IF MORE NOOPS\nTRYMOR01 DS    0H                  IS THIS A BRANCH NOOP?\n         MVC   WORKINST(8),0(R9)   RELOAD WORK AREA\n         NC    WORKINST(2),=X'FFF0'  IGNORE INDEX REGISTER\n         CLC   =X'4700',WORKINST   CHECK IF BRANCH NOP TO ANYWHERE\n         BNE   TRYMOR02            NO. NEXT TRY.\n         MVC   WORKINST(8),0(R9)   YES. RELOAD WORK AREA\n         LA    R9,4(,R9)           ADVANCE 4 BYTES\n         LA    R6,4(,R6)           SUBTRACT 4 BYTES PAST HEADER\n         B     SKIPLOOP            TRY IF MORE NOOPS.\nTRYMOR02 DS    0H                  IS THIS A BR NOOP?\n         MVC   WORKINST(8),0(R9)   RELOAD WORK AREA\n         NC    WORKINST(2),=X'FFF0'  IGNORE DESTINATION REGISTER\n         CLC   =X'0700',WORKINST   IS IT A NOPR?\n         BNE   TRYMORE             NO. NEXT TRY.\n         LA    R9,2(,R9)           ADVANCE 2 BYTES\n         LA    R6,2(,R6)           SUBTRACT 2 BYTES PAST HEADER\n         B     SKIPLOOP            TRY IF MORE NOOPS.\nTRYMORE  DS    0H\n*\n*    CHECK FIRST FOR LARL AT THE BEGINNING OF THE MODULE..........  SBG\n*    CHECK ALSO FOR BRANCH AND SAVE AT THE BEGINNING..............  SBG\n*\n         CLC   =X'0D',0(R9)        IS BEGINNING OF MODULE BAS?\n         BNE   TRYLARL             NO. TRY LARL.\n         LA    R9,2(,R9)           BUMP PAST BAS.\n         LA    R6,2(,R6)\n         B     TRYNORML            CHECK IF NORMAL LABEL IS THERE.\nTRYLARL  DS    0H\n         CLC   =X'C0300000',0(R9)  LARL?                            SBG\n         BNE   TRYNORML            NO. REGULAR PROCESSING.          SBG\n         LA    R9,6(,R9)           BUMP PAST STUFF.                 SBG\n         LA    R6,6(,R6)\nTRYNORML DS    0H\n         CLC   =X'47F0',0(R9)      POSSIBLY STANDARD HEADER?\n         BE    LOAD3               B IF YES; CONTINUE.\n         CLC   =X'05F047F0',0(R9)  POSSIBLY STANDARD HEADER?\n         BNE   TRYNORMZ            NO. TRY NEW JUMP INSTRUCTION.    SBG\n         LA    R9,2(,R9)           YES. BUMP LOAD MODULE ORIGIN.\n         LA    R6,2(,R6)\n         B     LOAD3               CONTINUE.\nTRYNORMZ DS    0H\n         CLC   =X'47FF',0(R9)      POSSIBLY STANDARD HEADER?\n         BE    LOAD3               B IF YES; CONTINUE.\n         CLC   =X'05F047FF',0(R9)  POSSIBLY STANDARD HEADER?\n         BNE   TRYA7               NO. TRY NEW JUMP INSTRUCTION.    SBG\n         LA    R9,2(,R9)           YES. BUMP LOAD MODULE ORIGIN.\n         LA    R6,2(,R6)\n         B     LOAD3               CONTINUE.\nTRYA7    DS    0H\n         CLC   =X'A7F4',0(R9)      IS IT BRC UNCONDITIONAL?\n         BNE   TRYSTMF             B IF NOT.  ERROR.\n         MVC   WORKHALF(2),2(R9)   GET NUMBER OF HALFWORDS\n         L     R8,WORKFULL         LOAD REGISTER WITH THEM\n         SLL   R8,1                MULTIPLY BY 2 TO GET BYTES\n         B     BRANCHA7            CONTINUE PROCESSING NORMALLY\nTRYSTMF  DS    0H                  TRY STORE MULTIPLE FIRST\n         MVC   WORK08(8),0(R9)     X'90ECD00C05B047F0'\n         NI    WORK08+5,X'0F'      NULLIFY BASE REG FOR COMPARE\n         CLC   =X'90ECD00C050047F0',WORK08     Example: AMDPRFMT\n         BNE   TRYLR\n         LA    R9,6(,R9)           Get to the 47F0.\n         LA    R6,6(,R6)           Eliminate stuff at beginning.\n         OI    FLAG3,X'01'         Kludge flag for this header.\n         B     TRYNORML            Look at regular 47F0 from here.\nTRYLR    DS    0H                  TRY STORE MULTIPLE FIRST\n         MVC   WORK08(8),0(R9)     X'90ECD00C18xf47F0'\n         NI    WORK08+5,X'0F'      NULLIFY BASE REG FOR COMPARE\n         CLC   =X'90ECD00C180F47F0',WORK08     Example: IEBGENER\n         BNE   NONSTD\n         LA    R9,6(,R9)           Get to the 47F0.\n         LA    R6,6(,R6)           Eliminate stuff at beginning.\n         OI    FLAG3,X'01'         Kludge flag for this header.\n         B     TRYNORML            Look at regular 47F0 from here.\nNONSTD   DS    0H\n*                         SAY: LOAD MODULE HAS NON-STANDARD HEADER.\n         CLI   NOTITOP+1,1         Displaying titles?\n         BE    NOSTDASH            No. Skip dashes to be more readable\n         MVC   LINE,LINE-1\n         MVC   LINE(65),DASHES\n         APUT  LINE,65\nNOSTDASH DS    0H                  Display 'non-std header' message.\n         MVC   LINE,LINE-1\n         MVC   LINE(MSG001L),MSG001\n         APUT  LINE,MSG001L\n         LA    R15,4               SET CC = 4.\n         ST    R15,SAVER15A        SAVE THE RETURN CODE\n         B     EXIT                EXIT.\nLOADA7   DS    0H\nLOAD3    DS    0H\n*        B     LOAD5         TEST TEST TEST\n*        SR    R8,R8               CLEAR INSERT REGISTER AND ...\n*        ICM   R8,B'0001',3(R9)    ... LOAD HEADER LENGTH.\n*        BZ    LOAD4               B IF BYTE LENGTH IS ZERO.\nLOAD5    DS    0H\n* --->\n         MVC   WORKHALF(2),2(R9)   PUT FULL Fhhh VALUE IN WORKAREA\n         NI    WORKHALF,X'0F'      GET RID OF REGISTER, LEAVING NUMBER\nLOAD5A   DS    0H\n*\n*        MVC   LINE,LINE-1\n*        HEX   LINE,2,WORKHALF\n*        APUT  LINE,10\n*\n         L     R8,WORKFULL         LOAD R8 BACK WITH NUMBER\n         TM    FLAG3,X'01'\n         BZ    BRANCHA7\n         LA    R8,6(,R8)           KLUDGE\nBRANCHA7 DS    0H\n         SR    R8,R6               SPACE TAKEN BY LEADING NULL BRANCHES\n         C     R8,=F'200'          BIGGER THAN 200?\n         BNH   LOADHALF            NO, JUST LOAD NUMBER ITSELF\n         L     R8,=F'200'          YES, LOAD 200 TO LIMIT SIZE TO MOVE\nLOADHALF DS    0H\n         ST    R8,SAVER8A\n*        MVC   LINE,LINE-1\n*        HEX   LINE,4,SAVER8A\n*        APUT  LINE,10\n* --->\nHEADOUT  DS    0H                  Now display the load module header.\n         L     R8,SAVER8A\n         S     R8,=F'5'\n         BNP   EXIT0\n         STC   R8,MOVEIC\n         CLI   NOTITOP+1,1         If we don't display titles,\n         BE    NOTIT3              Then skip this title for the header.\n         MVC   LINE,LINE-1\n         MVC   LINE(65),DASHES\n         APUT  LINE,65\n         MVC   LINE,LINE-1\n         CLI   ENTRYOP+1,1  Differentiate between load pt and entry pt\n         BNE   LOADPT01\n         MVC   LINE(36),=C'Load Module Header at Entry Point:  '\n         B     LOADPT02\nLOADPT01 DS    0H\n         MVC   LINE(36),=C'Load Module Header at Load Point:   '\nLOADPT02 DS    0H\n         APUT  LINE,40\nNOTIT3   DS    0H                  Now display the header itself.\n         MVC   LINE,LINE-1\n         EX    R8,MVHEAD           MOVE HEADER TO LINE.\n         STM   R14,R1,SAVE14T1\n         APUT  LINE,200            Put the data out.\n         LM    R14,R1,SAVE14T1\n         LA    R15,0\n         ST    R15,SAVER15A        SAVE THE RETURN CODE\n         B     EXIT0               EXIT WITH CC = 0.\nEXIT12   LA    R15,12\n         ST    R15,SAVER15A        SAVE THE RETURN CODE\n         B     EXIT\nEXIT0    SR    R15,R15             SET CC = 0.\n         ST    R15,SAVER15A        SAVE THE RETURN CODE\nEXIT     DS    0H\n         TM    FLAG2,X'01'\n         BO    WASLPA\n         DELETE EP=MEMBER\nWASLPA   DS    0H\n         L     R13,SAVE+4          POINT TO CALLER'S SAVE AREA.\n         L     R15,SAVER15A        GET THE RETURN CODE\n         ST    R15,16(,R13)\n         LM    R0,R12,20(R13)      RELOAD MOST OF CALLER'S REGISTERS.\n         L     R14,12(,R13)        RELOAD RETURN ADDRESS.\n         BR    R14                 RETURN TO CALLER.\n* ------------------------------------------------------------------- *\n*                          HEX DISPLAY                                *\n* ------------------------------------------------------------------- *\nPRTXLINE DS    0H                Print 3 lines in ISPF HEX format\n         ST    R7,SAVER7A            Plus a fourth ruler line.\n         MVC   LINE,LINE-1\n         L     R1,SAVER1A\n         B     *+10\n         MVC   LINE(0),0(R9)       MOVE DATA TO PRINT LINE\n         EX    R1,*-6\n         L     R1,SAVER1A          RELOAD THE LENGTH\n         B     *+10\nTRHEXL0  TR    LINE(*-*),TRTBL0    MAKE A PRINTABLE LINE\n         EX    R1,TRHEXL0\n         APUT  LINE,100\n         MVC   LINE,LINE-1\n         L     R1,SAVER1A          RELOAD THE LENGTH\n         B     *+10\n         MVC   LINE(0),0(R9)       MOVE DATA TO PRINT LINE\n         EX    R1,*-6\n         B     *+10\nTRHEXL1  TR    LINE(*-*),TRTBL1    HIGH NIBBLE IN HEX DISPLAY\n         EX    R1,TRHEXL1\n         APUT  LINE,100\n         MVC   LINE,LINE-1         RELOAD THE LENGTH\n         L     R1,SAVER1A\n         B     *+10\n         MVC   LINE(0),0(R9)       MOVE DATA TO PRINT LINE\n         EX    R1,*-6\n         B     *+10\nTRHEXL2  TR    LINE(*-*),TRTBL2    LOW NIBBLE IN HEX DISPLAY\n         EX    R1,TRHEXL2\n         APUT  LINE,100\n         MVC   LINE,LINE-1\n         L     R1,SAVER1A          RELOAD LENGTH\n*                                  APUT DESTROYS R1.\n         B     *+10\n         MVC   LINE(0),RULERL      MOVE DATA TO PRINT LINE\n         EX    R1,*-6\n         APUT  LINE,100\n         L     R7,SAVER7A\n         BR    R7\n* ------------------------------------------------------------------- *\nHELPMSG  DS    0H\n         STM   R14,R1,SAVE14T1\n         MVC   LINE,LINE-1\n         MVC   LINE(37),=C'-------------------------------------'\n         APUT  LINE,37\n         MVC   LINE,LINE-1\n         MVC   LINE(37),=C'Syntax: LISTHEAD modname (parameters)'\n         APUT  LINE,37\n         MVC   LINE,LINE-1\n         MVC   LINE(10),BLANKS\n         APUT  LINE,10\n         MVC   LINE,LINE-1\n         MVC   LINE(37),=C'Parameters:  ENTRY, NOTITLE, NOHEX   '\n         APUT  LINE,37\n         MVC   LINE,LINE-1\n         MVC   LINE(37),=C'-------------------------------------'\n         APUT  LINE,37\n         LM    R14,R1,SAVE14T1\n         LA    R15,4               Make return code 4.\n         B     EXIT\n* ------------------------------------------------------------------- *\n         TITLE '- Static data area.'\nSAVE     DS    9D                  SAVE AREA.\nCVDWORK  DS    D                   CVD work area\nLADRSAVE DS    D\nLOADLEN  DS    F                                             *JUL-2014*\nLPAREGS  DS    2F\nLOADWHOL DS    F                   Entire size of load module\nLOADSMAL DS    F                   Distance from entry point to end.\nSTORDIFF DS    F                   Displacement of entry point.\nENTRYOP  DS    F                                             *JUL-2014*\nNOHEXOP  DS    F                                             *DEC-2016*\nNOTITOP  DS    F                                             *DEC-2016*\nHEXOP    DS    F                                             *DEC-2016*\nTITOP    DS    F                                             *DEC-2016*\nSAVE14T1 DS    4F\nADRENTRY DS    F\nADRSTART DS    F\nLPDEADDR DS    F\nCDEADDR  DS    F\nSAVPARCD DS    F\nSAVER1A  DS    F\nSAVER1B  DS    F\nSAVER1L  DS    F                   HOLDS DECREMENTED LENGTH OF MODULE\nSAVER1P  DS    F                   HOLDS LENGTH OF PRINTED LINE - 1\nSAVER3A  DS    F\nSAVER3B  DS    F\nSAVER3C  DS    F\nSAVER6A  DS    F\nSAVER7A  DS    F\nSAVER8A  DS    F\nSAVER9A  DS    F\nSAVER9B  DS    F\nSAVER9C  DS    F\nSAVER9D  DS    F\nSAVER9E  DS    F\nSAVER10A DS    F\nSAVER15A DS    F\nDISPR8A  DS    F\nWORK08   DS    CL8\nMAJNAME  DS    CL8\nFLAG1    DS    X                   X'01' if entry point at beginning\nFLAG2    DS    X                   X'01' if LPA module\nFLAG3    DS    X                   X'01' if need to kludge header size\nMASK10   DC    XL10'40202020202020202120'\nWORKINST DS    2F                   COPY OF INSTRUCTION\nMOVEIC   DC    X'00'\nDASHES   DS    0CL65\nDASHEZ   DC    65C'-'\n         DS    CL1\nBLANKS   DS    CL65' '\nFULLZERO DC    F'0'\n         SPACE 1\n*IOPL     DS    0A                  IOPL FOR PUTLINE.\n*IOPLUPT  DS    A                   POINTER TO USER PROFILE TABLE.\n*IOPLECT  DS    A                   POINTER TO ENVIRONMENT CONTROL TAB.\n*IOPLECB  DC    A(ECB)              POINTER TO ECB.\n*IOPLIOPB DC    A(PTPB)             POINTER TO PTPB.\n         SPACE 1\n         SPACE 1\n*PTPB     PUTLINE MF=L PUTLINE PARM. BLOCK.\n         SPACE 1\nMVMEM    MVC   MEMBER(*-*),0(R15)  *** EXECUTED ***\nMVHEAD   MVC   LINE(*-*),4(R9)     *** EXECUTED ***\nRULERL   DC    C'0----+----1----+----2----+----3----+----4----+----5---x\n               -+----6----+----7----+----8----+----9----+----'\n         DS    CL1\nLINE     DS    CL200\n         SPACE 1\n         LTORG\nWORKFULL DS    0F\n         DC    H'0'\nWORKHALF DC    H'0'\n         TITLE '- MESSAGES.'\nMSG001   DC    C'Load module has non-standard header.'\nMSG001L  EQU   *-MSG001\n         SPACE 1\nMSG002   DC    C'Cannot load '\nMEMBER   DC    CL8' '              NAME OF MEMBER TO BE EXAMINED.\n         DC    C' from any library in normal search path.'\nMSG002L  EQU   *-MSG002\nMSG003   DC    C'Beginning of CDE chain reached without a name match.'\nMSG003L  EQU   *-MSG003\n         TITLE '- Parse parameters.'\nPPL      DS    0A                  PARSE PARM LIST.\nPPLUPT   DS    A                   POINT TO UPT.\nPPLECT   DS    A                   POINT TO ECT.\nPPLECB   DC    A(ECB)              POINT TO ECB.\nPPLPCL   DC    A(PCL)              POINT TO PCL.\nPPLANS   DC    A(ANS)              POINT TO ANSWER PLACE.\nPPLCBUF  DS    A                   POINT TO COMMAND BUFFER.\nPPLWA    DC    A(0)                NO WORK AREA.\n         SPACE 1\nANS      DS    A                   ANSWER PLACE.\nECB      DC    A(0)                COMMAND PROCESSOR ECB.\nPCL      IKJPARM DSECT=PDL         PARSE PCL CSECT.\nPDLLM    IKJIDENT 'Load Module',FIRST=ALPHA,OTHER=ALPHANUM,            +\n               PROMPT='Load Module+',MAXLNTH=8,                        +\n               HELP=('Name of load module to be listed.')\nENTRYKW  IKJKEYWD ,\n         IKJNAME 'ENTRY'\nNOHEXKW  IKJKEYWD ,\n         IKJNAME 'NOHEX'\nNOTITKW  IKJKEYWD ,\n         IKJNAME 'NOTITLE'\nHEXKW    IKJKEYWD ,\n         IKJNAME 'HEX  '\nTITKW    IKJKEYWD ,\n         IKJNAME 'TITLE'\n         IKJENDP\nHEX      DS    0H\n         ST    R4,SAVER4A\n         MVC   1(1,R15),0(R1)        Move byte\n         UNPK  0(3,R15),1(2,R15)     Unpack\n         TR    0(2,R15),HEXTAB-240\n         LA    R15,2(,R15)           Increment output pointer\n         LA    R1,1(,R1)             Increment input pointer\n         BCT   R0,HEX                Decrement length, then loop\n         MVI   0(R15),C' '           Blank the trailing byte\n         L     R4,SAVER4A\n         BR    R4                    Return to caller\nHEXTAB   DC    C'0123456789ABCDEF'   Translate table\nSAVER4A  DS    F\nHEXSAVE  DS    3F                    Register save for HEX macro\n         DS    CL1\nTRTBL0   DS    0D\n         DC    XL16'40404040404040404040404040404040'\n         DC    XL16'40404040404040404040404040404040'\n         DC    XL16'40404040404040404040404040404040'\n         DC    XL16'40404040404040404040404040404040'\n         DC    XL16'404040404040404040404A4B4C4D4E4F'\n         DC    XL16'504040404040404040405A5B5C5D5E5F'\n         DC    XL16'606140404040404040406A6B6C6D6E6F'\n         DC    XL16'404040404040404040407A7B7C7D7E7F'\n         DC    XL16'40818283848586878889404040404040'\n         DC    XL16'40919293949596979899404040404040'\n         DC    XL16'4040A2A3A4A5A6A7A8A9404040404040'\n         DC    XL16'40404040404040404040404040404040'\n         DC    XL16'C0C1C2C3C4C5C6C7C8C9404040404040'\n         DC    XL16'D0D1D2D3D4D5D6D7D8D9404040404040'\n         DC    XL16'E040E2E3E4E5E6E7E8E9404040404040'\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9404040404040'\nTRTBL1   DS    0D\n         DC    XL16'F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0'\n         DC    XL16'F1F1F1F1F1F1F1F1F1F1F1F1F1F1F1F1'\n         DC    XL16'F2F2F2F2F2F2F2F2F2F2F2F2F2F2F2F2'\n         DC    XL16'F3F3F3F3F3F3F3F3F3F3F3F3F3F3F3F3'\n         DC    XL16'F4F4F4F4F4F4F4F4F4F4F4F4F4F4F4F4'\n         DC    XL16'F5F5F5F5F5F5F5F5F5F5F5F5F5F5F5F5'\n         DC    XL16'F6F6F6F6F6F6F6F6F6F6F6F6F6F6F6F6'\n         DC    XL16'F7F7F7F7F7F7F7F7F7F7F7F7F7F7F7F7'\n         DC    XL16'F8F8F8F8F8F8F8F8F8F8F8F8F8F8F8F8'\n         DC    XL16'F9F9F9F9F9F9F9F9F9F9F9F9F9F9F9F9'\n         DC    XL16'C1C1C1C1C1C1C1C1C1C1C1C1C1C1C1C1'\n         DC    XL16'C2C2C2C2C2C2C2C2C2C2C2C2C2C2C2C2'\n         DC    XL16'C3C3C3C3C3C3C3C3C3C3C3C3C3C3C3C3'\n         DC    XL16'C4C4C4C4C4C4C4C4C4C4C4C4C4C4C4C4'\n         DC    XL16'C5C5C5C5C5C5C5C5C5C5C5C5C5C5C5C5'\n         DC    XL16'C6C6C6C6C6C6C6C6C6C6C6C6C6C6C6C6'\nTRTBL2   DS    0D\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\n         TITLE '- Mapping DSECTs.'\n         PRINT GEN\n         IKJCPPL                   MAP COMMAND PROCESSOR PARM LIST.\n         CVT   DSECT=YES\n         IKJTCB                                              *JUL-2014*\n         IHACDE                                              *JUL-2014*\n         IHAXTLST                                            *JUL-2014*\n         END   LISTHEAD\nEPUTL    TITLE 'PUTLINE FOR FEWER THAN 83 ARGUMENTS IN THE KEY OF C MAJ&\n               OR'\nEPUTL    CSECT                                              *HMD 10/85*\n         LCLB  &XA                                          *HMD 10/85*\n&XA      SETB  1                  SET TO ZERO ON NON/XA     *HMD 10/85*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*  MODULE NAME  . . . . EPUTL\n*\n*  ALIASES  . . . . . . NONE\n*\n*  DATE WRITTEN . . . . 06/85\n*  UPDATED      . . . . 04/88                                  HD APR88\n*  CLEANED A BIT  . . . 08/17\n*\n*  AUTHOR . . . . . . . JIM ELSWORTH\n*  UPDATER  . . . . . . HOWARD M. DEAN                         HD APR88\n*\n*  ENVIRONMENT  . . . . TSO COMMAND PROCESSOR\n*\n*  PURPOSE:\n*    ALLOW AN EASY INTERFACE TO PUTLINE ROUTINE\n*\n*\n*  DESCRIPTION:\n*    BUILDS PUTLINE PARAMETER LIST BASED ON INPUT ARGUMENTS.\n*    ISSUES SINGLE LINE PUTLINE.\n*\n*\n*  ATTRIBUTES:\n*    REENTRANT\n*\n*  FEATURES:\n*    WILL RUN UNDER BATCH TMP SINCE PUTLINE USED INSTEAD OF TPUT.\n*\n*  CALLED MODULES:\n*    PUTLINE\n*\n*  ASSUMPTIONS:\n*    CALLED BY A TSO-CP THAT IS OBSERVING STANDARD LINKAGE\n*\n*  ABENDS:\n*    POSSIBLE 0CX IF BAD ARGUMENTS\n*\n*  CAVEATS:\n*    UNPREDICTABLE RESULTS IF FIRST PROGRAM RUNNING UNDER THIS TCB\n*    DID NOT SAVE (14,12) BEFORE R1 WAS MODIFIED.\n*\n*\n*  INPUT ARGUMENTS:\n*    1)  R1 : ADDRESS OF MESSAGE TEXT\n*    2)  R0 : LENGTH OF MESSAGE TEXT\n*    3) R13 : STANDARD OS SAVE AREA\n*    4) R14 : RETURN ADDRESS\n*    5) R15 : ENTRY ADDRESS\n*\n*               ( CONTINUED ... )\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*\n*  OUTPUT ARGUMENT: RETURN CODE FROM PUTLINE OR\n*\nRCBA     EQU   100                 BAD MESSAGE ADDRESS\nRCBL     EQU   104                 MESSAGE LENGTH <1 OR >MAXMSG\n*\nMAXMSG   EQU   255                 MAXIMUM MESSAGE LENGTH\n*\n*\n*  REGISTERS USED:\n*\nR0       EQU   0                   MESSAGE LENGTH AT ENTRY\nR1       EQU   1                   MESSAGE ADDRESS AT ENTRY\nR2       EQU   2                   WORK\nR3       EQU   3                   WORK\nRMA      EQU   4                   @MESSAGE TEXT\nRML      EQU   5                   MESSAGE LENGTH\nRUPT     EQU   6                   @UPT (USER PROFILE TABLE)\nRECT     EQU   7                   @ECT\nR12      EQU   12                  CSECT BASE\nR13      EQU   13                  @SAVE AREA AND DYNAMIC WORK AREA\nR14      EQU   14                  WORK/LINKAGE\nR15      EQU   15                  WORK/LINKAGE\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         EJECT\n         IKJCPPL\n         EJECT\n         IKJTCB   LIST=YES                                  *HMD 10/85*\n         EJECT                                              *HMD 10/85*\n         CVT      DSECT=YES,LIST=YES                        *HMD 10/85*\n         EJECT\n         IHAPSA   LIST=YES                                     HD APR88\n         EJECT                                                 HD APR88\nPUTLDS   DSECT\n         DS    18F                      OS SAVE AREA\nPUTAAA   EQU   *\nPUTECB   DS    F                        ECB\nPUTIOPL  DS    4F                       IOPLADS\nPUTBLOK  PUTLINE MF=L\nPUTLEN   DS    H                        LENGTH\nPUTZZZ   DS    H                        RESERVED\nPUTMSG   DS    (MAXMSG)C                MESSAGE TEXT AREA\n         DS    0D\nPUTSIZE  EQU   *-PUTLDS                 SIZE OF PUTLINE PARMS\n         EJECT\n***********************************************************************\n*  SET UP LINKAGE\n***********************************************************************\n         SPACE 1\nEPUTL    CSECT\n         AIF  (NOT &XA).X001                                *HMD 10/85*\nEPUTL    AMODE 31\n.X001    ANOP                                               *HMD 10/85*\n         STM   R14,R12,12(R13)    SAVE CALLERS REGS\n         LR    R12,R15            COPY EPA\n         USING EPUTL,R12          ADDRESSABILITY\n         AIF   (NOT &XA).X002                               *HMD 10/85*\n         GETMAIN RU,              LV=LENGTH                            &\n               LV=PUTSIZE,        STANDARD OS SA PLUS ANY EXTRA        &\n               LOC=RES,SP=0       RELATIVE TO 16MB LINE\n         AGO   .X003                                        *HMD 10/85*\n.X002    ANOP                                               *HMD 10/85*\n         GETMAIN RU,              LV=LENGTH                            &\n               LV=PUTSIZE         STANDARD OS SA PLUS ANY EXTRA\n.X003    ANOP                                               *HMD 10/85*\n         ST    R1,8(,R13)         OUR SAVE AREA POINTER\n         ST    R13,4(,R1)         POINTER TO CALLER'S SAVE AREA\n         LR    R13,R1             @OUR SAVE AREA\n         USING PUTLDS,R13         MAP SA AND WORK AREA\n         L     R14,4(,R13)        POINT TO CALLER'S RSA\n         LM    R0,R1,20(R14)      RESTORE REGS CHANGED BY GETMAIN\n         SPACE 2\n***********************************************************************\n*  UNLOAD ARGUMENTS AND VALIDATE WHERE POSSIBLE\n***********************************************************************\n         SPACE 1\n         LA    R15,RCBA                 RC IF BAD ADDRESS\n         LTR   RMA,R1                   MESSAGE ADDRESS\n         BNP   RETURN                   GOOD ASSUMPTION\n         LA    R15,RCBL                 RC IF BAD LENGTH\n         LTR   RML,R0                   POSITIVE?\n         BNP   RETURN                   -NO\n         C     RML,=A(MAXMSG)           MORE THAN MAX?\n         BH    RETURN                   -YES\n         SPACE 2\n***********************************************************************\n*  BUILD PARAMETER LIST\n***********************************************************************\n         SPACE 1\n         LA    R15,4(,RML)              MESSAGE LENGTH\n         STH   R15,PUTLEN               PLUS HEADER\n         XC    PUTZZZ,PUTZZZ            CLEAR 2ND HWORD OF RDW\n         BCTR  RML,0                    REDUCE FOR MOVE\n         EX    RML,PUTMOVE\n         EJECT\n***********************************************************************\n*  DIG UP ADDRESS OF UPT AND ECT\n***********************************************************************\n         SPACE 1\n         L     R2,PSATOLD-PSA           @TCB                   HD APR88\n         L     R2,TCBFSA-TCB(,R2)       @1ST PROBLEM PGM SAVE AREA\n         L     R2,24(,R2)               REG1 THAT WAS PASSED TO CP\n         USING CPPL,R2                  MAP CPPL\n         L     RUPT,CPPLUPT             @UPT\n         L     RECT,CPPLECT             @ECT\n         SPACE 2\n***********************************************************************\n*  ISSUE PUTLINE CALL\n***********************************************************************\n         SPACE 1\n         XC    PUTECB,PUTECB            CLEAR ECB\n         XC    PUTBLOK(12),PUTBLOK      CLEAR PARM BLOCK       HD APR88\n         PUTLINE PARM=PUTBLOK,          PARAMETER BLOCK                &\n               UPT=(RUPT),              @UPT                           &\n               ECT=(RECT),              @ECT                           &\n               ECB=PUTECB,              @ECB                           &\n               OUTPUT=(PUTLEN,TERM,SINGLE,DATA),                       &\n               MF=(E,PUTIOPL)\n         EJECT\n***********************************************************************\n*  RETURN TO CALLER\n***********************************************************************\n         SPACE 1\nRETURN   EQU   *\n         LR    R2,R13                   @OUR SAVE AREA\n         LR    R3,R15                   SAVE RETURN CODE\n         L     R13,4(,R13)              @CALLER'S SAVE AREA\n         FREEMAIN RU,LV=PUTSIZE,A=(R2),SP=0\n         LR    R15,R3                   RESTORE RC\n         RETURN (14,12),RC=(15)         RESTORE CALLER'S REGS\n         SPACE 5\n***********************************************************************\n*  CONSTANTS AND NON-REENTRANT WORK AREAS\n***********************************************************************\n         SPACE 1\nPUTMOVE  MVC   PUTMSG(*-*),0(RMA)       MOVE MESSAGE TO BUFFER\n         SPACE 2\n         LTORG\n         SPACE 2\n         END   EPUTL\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LISTMDD$": {"ttr": 1030, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x11\\x00F\\x01\\x055O\\x01\\x19\"O\\x12\\x15\\x00\\x1d\\x00\\x1d\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.17", "flags": 0, "createdate": "2005-12-20T00:00:00", "modifydate": "2019-08-12T12:15:46", "lines": 29, "newlines": 29, "modlines": 0, "user": "SBGOLOB"}, "text": "//SBGOLOBU JOB (CCMVS),ASMLINK,\n// NOTIFY=&SYSUID,\n// CLASS=A,MSGCLASS=X,COND=(1,LT)\n//*\n//*     ASSEMBLE AND LINKEDIT LISTMODD\n//*\n//ASMH EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,NORLD,NOXREF)\n//SYSLIB   DD DISP=SHR,DSN=SYS1.MACLIB\n//         DD DISP=SHR,DSN=SYS1.MODGEN\n//         DD DISP=SHR,DSN=SBGOLOB.CBT498.FILE994\n//SYSIN    DD DISP=SHR,DSN=SBGOLOB.CBT498.FILE994(LISTMODD)\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,9),DISP=(,PASS),DCB=BLKSIZE=3200,\n//            DSN=&&TEMP\n//*\n//LKED   EXEC  PGM=HEWL,\n//       PARM='NCAL,MAP,LIST,LET,NOREUS,NORENT'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//SYSLMOD  DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//OBJECT   DD  DISP=(OLD,DELETE),DSN=&&TEMP\n//SYSLIN   DD  *\n INCLUDE OBJECT\n SETCODE AC(0)\n SETSSI  CB498994\n ENTRY   LISTMODD\n NAME    LISTMODD(R)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "LISTMOD": {"ttr": 1032, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01c\\x00W\\x01\\x14 \\x1f\\x01 \\x03O\\x08\\x15\\x04^\\x02\\xcc\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.99", "flags": 0, "createdate": "2014-07-20T00:00:00", "modifydate": "2020-02-03T08:15:57", "lines": 1118, "newlines": 716, "modlines": 0, "user": "SBGOLOB"}, "text": "LISTMOD  TITLE '- TSO command to list load module in hex format'\n         SPACE 1\n* ------------------------------------------------------------------- *\n***********************************************************************\n*                                                                     *\n*     LISTMOD - TSO command to list an entire module in ISPF-like     *\n*               hexadecimal format.  Width of the display is 75       *\n*               bytes wide.                                           *\n*                                                                     *\n*               Displacements of data are marked in hexadecimal.      *\n*                                                                     *\n*               Using the ENTRY parameter, the display goes from      *\n*               the entry point until the physical end of the module. *\n*               Otherwise, the display includes the entire module     *\n*               from beginning to end.                                *\n*                                                                     *\n*     Register usage:                                                 *\n*           R5 - Base.                                                *\n*           R6 - Work.                                                *\n*           R7 - Work.                                                *\n*           R8 - Work.                                                *\n*           R9 - Work, Parse PDEs.                                    *\n*          R10 - CPPL pointer.                                        *\n*          R12 - Base.                                                *\n*                                                                     *\n*     Ideas in the program were developed by Jeffrey Broido and       *\n*     Bill Godfrey.  The program was adapted for dumping load         *\n*     modules, by Sam Golob.                                          *\n*                                                                     *\n*     Partial description of the program:  Display the bytes of       *\n*     a load module in ISPF-like 3-line hexadecimal format, with      *\n*     ruler to help measure and locate particular bytes.              *\n*                                                                     *\n*     The program works (currently) by first testing if the module    *\n*     is in the Link Pack Area (LPA).  If so, then the LPDE is        *\n*     looked up, to obtain the relevant information.  If the program  *\n*     is not in LPA, then a LOAD macro is issued to obtain the        *\n*     information.                                                    *\n*                                                                     *\n*     The program either displays the entire load module, or,         *\n*     using the ENTRY parameter, it starts with the entry point,      *\n*     and it dumps the contents of the rest of the load module,       *\n*     in 3-line hex format with ruler, to see what is there.          *\n*                                                                     *\n*     All the bytes of the program are displayed, if there is no      *\n*     parameter.  If the ENTRY parameter is used, then all the        *\n*     bytes from the entry point to the end of the module, are        *\n*     displayed.                                                      *\n*                                                                     *\n*              example:    LISTMOD modname ENTRY                      *\n*                                                                     *\n*     Please note that the HEX display will show all hex values       *\n*     in \"printable\" format, so you don't need any other tools        *\n*     to see the contents of the load modules, displayed in a         *\n*     3-line hexadecimal display with added ruler.                    *\n*                                                                     *\n*     For some modules, such as IEBCOPY, you have to use the          *\n*     ENTRY parameter to see a realistic eyecatcher.  But since       *\n*     (with IEBCOPY and with many other load modules) the entry       *\n*     point is in the middle of the load module, LISTMOD will         *\n*     then (using the ENTRY keyword) only list the bytes from         *\n*     the entry point location until the end of the module.           *\n*                                                                     *\n*     CHANGES:  2020/02/03 - SBG                                      *\n*               Changed ruler to go from X'00' to X'3F'.              *\n*               It had been one byte off.                             *\n*                                                                     *\n***********************************************************************\n         MACRO\n&LABEL   APUT  &MSG,                    @MESSAGE TEXT                  &\n               &LEN,                    @LENGTH OF MESSAGE             &\n               &RSA=,                   OPTIONAL 2 WORD SAVE AREA      &\n               &EPA=                    EPUTL EPA\n.*\n.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*\n.*  --> E@PUT\n.*\n.*  THIS MACRO SETS UP A PARAMETERS AND INVOKES THE EPUTL ROUTINE.\n.*\n.*\n.*  ARGUMENTS: -----------------------------------------------------\n.*\n.*      &MSG : ADDRESS OF MESSAGE TEXT OR A LITERAL\n.*\n.*      &LEN : LENGTH OF MESSAGE TEXT (DEFAULT IS L'&MSG)\n.*\n.*      &RSA :(OPTIONAL) 1 WORD SAVE AREA TO PRESERVE R14 FOR TPUT\n.*            COMPATIBILITY.\n.*\n.*      &EPA :(OPTIONAL) EPA FOR EPUTL ROUTINE\n.*\n.*\n.*   EXAMPLES: -----------------------------------------------------\n.*\n.*      1) APUT  'LITERAL'\n.*\n.*      2) APUT  (R3),80\n.*\n.*      3) APUT  LABEL\n.*\n.*      4) APUT  LABEL,40\n.*\n.*\n.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*\n.*\n.*  LOCAL SET SYMBOLS\n.*\n         LCLC  &SMA                     MESSAGE ADDRESS (REG)\n         LCLC  &SML                     MESSAGE LENGTH (REG)\n         LCLC  &SEP                     EPA (REGISTER)\n.*\n         LCLC  &L1,&L2,&L3              LOCAL LABELS\n.*\n&L1      SETC  'EP'.'&SYSNDX'.'L1'      LOCAL LABELS\n&L2      SETC  'EP'.'&SYSNDX'.'L2'      LOCAL LABELS\n&L3      SETC  'EP'.'&SYSNDX'.'L3'      LOCAL LABELS\n.*\n.*\n.*  MESSAGE ADDRESS\n.*\n         AIF   (T'&LABEL EQ 'O').A0500                      *HMD 11/86*\n.*                                                          *HMD 11/86*\n&LABEL   DS    0H                                           *HMD 11/86*\n.*                                                          *HMD 11/86*\n.A0500   ANOP                                               *HMD 11/86*\n         AIF   ('&MSG' NE '').A2000\n         MNOTE 8,'''&MSG='' MISSING / REQUIRED'\n         MEXIT\n.*\n.A2000   ANOP\n         AIF   ('&MSG'(1,1) NE '(').A2400\n&SMA     SETC  '&MSG'(2,K'&MSG-2)\n         LR    R1,&SMA                  @MESSAGE TEXT\n         AGO   .A2600\n.*\n.A2400   ANOP\n         AIF   ('&MSG'(1,1) NE '''').A2500\n         B     &L3                      BRANCH AROUND MESSAGE\n&L2      DC    C&MSG\n&L3      DS    0H\n         LA    R1,&L2                   @MESSAGE\n         AGO   .A2600\n.*\n.A2500   ANOP\n         LA    R1,&MSG                  @MESSAGE TEXT\n.A2600   ANOP\n.*\n.*  MESSAGE LENGTH\n.*\n         AIF   ('&LEN' NE '').A3000\n         AIF   ('&MSG'(1,1) NE '''').A2800\n         LA    R0,L'&L2                 MESSAGE LENGTH\n         AGO   .A3600\n.*\n.A2800   ANOP\n         AIF   ('&MSG'(1,1) EQ '(').A2900\n         LA    R0,L'&MSG                MESSAGE LENGTH\n         AGO   .A3600\n.*\n.A2900   ANOP\n         MNOTE 8,'''LEN'' MISSING / REQUIRED'\n         MEXIT\n.*\n.A3000   ANOP\n         AIF   ('&LEN'(1,1) NE '(').A3400\n&SML     SETC  '&LEN'(2,K'&LEN-2)\n         LR    R0,&SML                  MESSAGE LENGTH\n         AGO   .A3600\n.*\n.A3400   ANOP\n         LA    R0,&LEN                  MESSAGE LENGTH\n.A3600   ANOP\n.*\n.*  RSA\n.*\n         AIF   ('&RSA' EQ '').A4900\n         ST    R14,&RSA                 SAVE REGS 14\n.A4900   ANOP\n.*\n.*  ENTRY POINT\n.*\n         AIF   ('&EPA' NE '').A5000\n         L     R15,=V(EPUTL)            EPA\n         AGO   .A5600\n.*\n.A5000   AIF   ('&EPA'(1,1) NE '(').A5400\n&SEP     SETC  '&EPA'(2,K'&EPA-2)\n         LR    R15,&SEP                 EPA\n         AGO   .A5600\n.*\n.A5400   ANOP\n         L     R15,&EPA                 EPA\n.*\n.A5600   ANOP\n.*\n.*  CALL LINKAGE\n.*\n.ACALL   BALR  R14,R15                  CALL PUTLINE ROUTINE\n.*\n         AIF   ('&RSA' EQ '').A6900\n         L     R14,&RSA                 RESTORE R14\n.A6900   ANOP\n.*\n.AMEND   MEND\n* ------------------------------------------------------------------- *\n*      PRODUCE A \"DISPLAY REPRESENTATION\" OF HEXADECIMAL NUMBERS      *\n* ------------------------------------------------------------------- *\n         MACRO\n&NAME    HEX   &TO,&LEN,&FROM\n&NAME    DS    0H\n         STM   R15,R1,HEXSAVE\n         LA    R1,&FROM\n         LA    R0,&LEN\n         LA    R15,&TO\n         BAL   R4,HEX\n         LM    R15,R1,HEXSAVE\n         MEND\n* ------------------------------------------------------------------- *\n*                   BEGINNING OF THE PROGRAM                          *\n* ------------------------------------------------------------------- *\nLISTMOD AMODE 31\nLISTMOD RMODE ANY\nLISTMOD CSECT\n         SPACE 1\n         SPACE 1\n         YREGS\n         USING LISTMOD,R15         (ESTABLISH TEMPORARY BASE).\n         B     BEGIN               SKIP OVER HEADER.\nHEAD0    DC    AL1(HEADL)          EXCLUSIVE LENGTH OF HEADER.\nHEAD     DC    C'LISTMOD - &SYSDATE - &SYSTIME  '\nHEADL    EQU   *-HEAD\n         DROP  R15                 (DROP TEMPORARY BASE).\nBEGIN    STM   R14,R12,12(R13)     SAVE CALLER'S REGISTERS\n         LR    R12,R15             COPY BASE.\n         USING LISTMOD,R12,R5      SET UP BASE REGISTERS.\n         LA    R5,4095(,R12)\n         LA    R5,1(,R5)\n         LR    R14,R13             COPY CALLER'S SAVE AREA POINTER.\n         LA    R13,SAVE            POINT TO MY SAVE AREA.\n         ST    R14,SAVE+4          CHAIN ...\n         ST    R13,8(,R14)         ... SAVE AREAS.\n         SPACE 1\n         MVI   LINE-1,X'40'\n         MVC   LINE,LINE-1\n         MVI   BLANKS-1,X'40'      FILL THE BLANKS FIELD\n         MVC   BLANKS,BLANKS-1       WITH BLANKS\n         MVC   MEMBER,BLANKS       Initialize member name with blanks.\n         LR    R10,R1              PRESERVE CPPL POINTER.\n         MVC   MAJNAME,BLANKS\n         USING CPPL,R10            (TELL ASSEMBLER)\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*        Initialize the Parse Parameter List and call TSO Parse.      *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         MVC   PPLUPT,CPPLUPT      COPY UPT ADDRESS.\n         MVC   PPLECT,CPPLECT      COPY ECT ADDRESS.\n         MVC   PPLCBUF,CPPLCBUF    COPY COMMAND BUFFER ADDRESS.\n         SPACE 1\n         LA    R1,PPL              POINT TO THE PPL.\n         XC    ECB,ECB             CLEAR ECB.\n         CALLTSSR EP=IKJPARS       PARSE INPUT.\n         LTR   R15,R15             Check return code from IKJPARS\n         BNZ   HELPMSG             Not zero, Help message and end.\n         L     R9,ANS              POINT TO PDES.\n         USING PDL,R9              TELL ASSEMBLER.\n         LH    R1,PDLLM+4          LOAD LENGTH OF LOAD MODULE NAME.\n         BCTR  R1,*-*              DECREMENT LENGTH.\n         L     R15,PDLLM           POINT TO RETURNED MEMBER NAME.\n         EX    R1,MVMEM            COPY MEMBER NAME FROM PDL\n*      ( MVC   MEMBER(*-*),0(R15)  )\n         MVC   ENTRYOP,ENTRYKW\n         MVC   NOHEXOP,NOHEXKW                               *DEC-2016*\n         MVC   HEXOP,HEXKW\n*        MVC   NOTITOP,NOTITKW                               *DEC-2016*\n         MVI   FLAG1,X'00'             Initialize flag.\n         MVC   STORDIFF,=X'00000000'   Assume the entry point at 0.\nFREEPDES IKJRLSA ANS               FREE THE PDES.\n*        CLI   NOTITOP+1,0                                   *DEC-2016*\n*        BNE   NOTIT2                                        *DEC-2016*\n         MVC   LINE,LINE-1\n         MVC   LINE(22),=C'Loaded Program Name:  '\n         MVC   LINE+22(8),MEMBER\n         APUT  LINE,40\nNOTIT1   DS    0H                                            *DEC-2016*\n*        CLI   NOHEXOP+1,0         IF NOHEX KEYWORD          *DEC-2016*\n*        BNE   LPA0\n         MVC   LINE,LINE-1\n         MVC   LINE(65),DASHES\n         APUT  LINE,65\nNOTIT2   DS    0H                                            *DEC-2016*\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*              FETCH THE USER-SPECIFIED LOAD MODULE.                  *\n*                                                                     *\n***********************************************************************\n* ------------------------------------------------------------------- *\n*    LOGIC OF THE PROGRAM WAS CHANGED TO DO A STANDARD \"LOAD\" FOR     *\n*    THE MODULE REQUESTED, BUT TO AFTERWARDS, ALSO CALCULATE THE      *\n*    MODULE ENTRY POINT IN THE DIFFERENT WAYS POSSIBLE, AND TO SAVE   *\n*    ALL THE RESULTS.  AFTERWARDS, DEPENDING ON WHETHER THE \"ENTRY\"   *\n*    PARAMETER WAS CODED, THE RESULTS ARE DISPLAYED ACCORDINGLY.      *\n* ------------------------------------------------------------------- *\n*    We first ask if the module is from LPA, and if not, then we      *\n*    LOAD it.                                                         *\n* ------------------------------------------------------------------- *\nLPA0     DS    0H\n         LM    R0,R1,MEMBER       Load member name for IEAVVMSR\n         STM   R7,R8,LPAREGS      Save registers\n         L     R3,16              CVT\n         L     R15,352(,R3)       CVTLPDSR\n         BALR  R14,R15            CALL IEAVVMSR\n         B     LPAINFO            MODULE IS IN LPA, GET LPDE.\n         B     LOAD0              NOT IN LPA, TRY LOADING IT.\nLPAINFO  DS    0H\n         OI    FLAG2,X'01'        FLAG THE MODULE AS AN LPA MODULE.\n         LM    R7,R8,LPAREGS      RESTORE REGISTERS\n         LR    R6,R0              SAVE LPDE ADDRESS\n         ST    R6,LPDEADDR        And store it for reporting\n         L     R9,16(,R6)         GET ENTRY POINT ADDRESS\n         N     R9,=X'7FFFFFFF'    Get rid of high bit.\n         ST    R9,SAVER9B         SAVE MODULE ENTRY POINT\n         TM    X'1C'(R6),X'04'    IS THIS A MINOR LPDE (ALIAS)?\n         BZ    MAJLPDE            NO. PROCESS AS A MAJOR.\n         OI    FLAG2,X'02'        Mark this one as an alias.\n         MVC   MAJNAME(8),X'20'(R6)  Copy the major name for report.\n         L     R6,X'14'(,R6)      YES. GET ADDRESS OF MAJOR LPDE.\nMAJLPDE  DS    0H\n         L     R9,X'24'(,R6)      GET MODULE LOAD POINT.\n         N     R9,=X'7FFFFFFF'    Remove the 31-bit indicator\n         ST    R9,ADRSTART        Start of the full data of the module\n         ST    R9,SAVER9A         Save it in another place\n         ST    R9,SAVER9C         SAVE THE LOAD POINT.\n         L     R9,X'20'(,R6)      GET THE SIZE OF THE LOAD MODULE.\n         ST    R9,LOADLEN         SAVE THE ENTIRE SIZE\n         MVC   LOADWHOL,LOADLEN   COPY WHOLE SIZE\n         L     R2,SAVER9B         GET THE ENTRY POINT\n         L     R3,SAVER9C         SUBTRACT THE LOAD POINT\n         SR    R2,R3              GET THE DISPLACEMENT\n         BNP   ENTRYPM1           GO TO SAME CALC AS WITH LOAD\n         ST    R2,STORDIFF        SAVE THE DISPLACEMENT\n         B     ENTRYPM0           GO TO THE SAME CALC AS WITH LOAD\n* ------------------------------------------------------------------- *\nLOAD0    DS    0H                 NOT IN LPA. LOAD THE MODULE.\n         LM    R7,R8,LPAREGS      RESTORE REGISTERS\n         LOAD  EPLOC=MEMBER,ERRET=LOAD1  FETCH LOAD MODULE TO LIST.\n*    Put in a display of x number of bytes at the load point, here.\nLOAD1    LTR   R15,R15             WAS LOAD SUCCESSFUL?\n         BZ    LOAD2               B IF YES; CONTINUE.\n*              SAY: CANNOT LOAD MEMBER.\n         MVC   LINE,LINE-1\n         MVC   LINE(MSG002L),MSG002\n         APUT  LINE,MSG002L\n         LA    R15,8               SET CC = 8.\n         B     EXIT                EXIT.\nLOAD2    DS    0H\n         LR    R9,R0               POINT TO LOAD MODULE TO BE LISTED.\n         N     R9,=X'7FFFFFFF'     Get rid of high bit for calculations\n         ST    R9,ADRSTART         Start of the full data of the module\n         ST    R9,SAVER9A          Save it in another place\n         ST    R9,SAVER9B          Save it again in another place\n         NC    SAVER9B(4),=A(X'7FFFFFFF')  Maybe not necessary\n         N     R1,=A(X'00FFFFFF')  ISOLATE LENGTH IN DWORDS  *JUL-2014*\n         ST    R3,SAVER3B          Save R3 to restore later\n         LR    R3,R1               Get length in doublewords\n         SLL   R3,3                Convert to bytes (multiply by 8)\n         ST    R3,SAVER3A          Save length in bytes\n         L     R3,SAVER3B          Restore original R3\n         SLL   R1,3                Do the same for R1        *JUL-2014*\n         ST    R1,LOADLEN          And save the max display length\n         MVC   LOADWHOL,LOADLEN    Save it again\n* ------------------------------------------------------------------- *\n* NOTE: IF THE 'ENTRY' KEYWORD IS SPECIFIED, AND THE         *JUL-2014*\n* ENTRY POINT IS NEAR THE END OF THE MODULE, THERE MAY BE    *JUL-2014*\n* FEWER BYTES THAN THE LOADLEN VALUE FROM THE ENTRY POINT    *JUL-2014*\n* TO THE END OF THE MODULE. AS A RESULT, THE DISPLAY OF      *JUL-2014*\n* LOADLEN BYTES MIGHT INCLUDE THE CONTENTS OF MEMORY BEYOND  *JUL-2014*\n* THE END OF THE MODULE.                                     *JUL-2014*\n* IF THE LAST CDE IN JOB PACK AREA QUEUE IS FOR A MODULE     *JUL-2014*\n* THAT CONTAINS THE ENTRY POINT ADDRESS IN R9, USE THE       *JUL-2014*\n* ADDRESS OF THE MODULE INSTEAD OF THE ENTRY POINT.          *JUL-2014*\n* NOTE: COULD ALSO USE LOADPT= ON THE LOAD MACRO, BUT        *JUL-2014*\n* MVS 3.8 SYSTEMS DON'T HAVE LOADPT=.                        *JUL-2014*\n* ------------------------------------------------------------------- *\n*       CALCULATE THE ENTRY POINT ADDRESS OF THE LOAD MODULE          *\n*              THIS CODE IS NOW, ALWAYS EXECUTED.                     *\n* ------------------------------------------------------------------- *\n         N     R9,=A(X'7FFFFFFF')                            *JUL-2014*\n         L     R14,540             PSATOLD -> CURRENT TCB    *JUL-2014*\n         L     R14,TCBJSTCB-TCB(,R14) POINT TO JOB STEP TCB  *JUL-2014*\n         L     R14,TCBJPQ-TCB(,R14) PNT TO LAST CDE IN JPAQ  *JUL-2014*\n* ------------------------------------------------------------------- *\n*              The correct CDE might not be the last one,             *\n*             so chain back until you've got a name match.            *\n* ------------------------------------------------------------------- *\nCDELOOP  DS    0H                  Check if CDE matches member name\n         CLC   MEMBER(8),8(R14)    Is this the correct CDE? (match)\n         BE    CDEEND              Yes, then process it.\n         CLC   FULLZERO,0(R14)     Back at the beginning of the chain\n         BE    CDEBAD                without a match? Then error.\n         L     R14,0(,R14)         No match. Go back one previous CDE.\n         B     CDELOOP             Keep trying till match or first CDE\n*                                    without a match.\nCDEBAD   DS    0H\n         MVC   LINE,LINE-1         Error message if beginning of CDE\n         MVC   LINE(MSG003L),MSG003  was reached without a name match.\n         APUT  LINE,MSG003L\n         B     EXIT12              Code 12 for this one.\nCDEEND   DS    0H\n         ST    R14,CDEADDR         Store address of CDE found.\n         TM    CDATTR-CDENTRY(R14),CDMIN TEST FOR MINOR CDE  *JUL-2014*\n         BZ    MAJCDE              BRANCH IF MAJOR CDE       *JUL-2014*\n         L     R14,CDXLMJP-CDENTRY(,R14) POINT TO MAJOR CDE  *JUL-2014*\n         OI    FLAG2,X'20'        Mark as CDE of an alias.\n         MVC   MAJNAME(8),X'8'(R14)     REAL NAME OF MODULE\nMAJCDE   L     R14,CDXLMJP-CDENTRY(,R14) POINT TO EXTENT     *JUL-2014*\n         L     R0,XTLMSBAD-XTLST(,R14) ADDRESS OF MODULE     *JUL-2014*\n         ST    R0,SAVER9C\n         CR    R9,R0                                         *JUL-2014*\n         BL    KEEPR9                                        *JUL-2014*\n         L     R0,XTLMSBLA-XTLST(,R14) LENGTH OF MODULE      *JUL-2014*\n         N     R0,=A(X'7FFFFFFF')                            *JUL-2014*\n         ST    R0,SAVER1B\n         A     R0,XTLMSBAD-XTLST(,R14) ADDRESS OF MODULE     *JUL-2014*\n         ST    R0,SAVER9D\n         CR    R9,R0                                         *JUL-2014*\n         BNL   KEEPR9                                        *JUL-2014*\n         L     R0,XTLMSBAD-XTLST(,R14) ADDRESS OF MODULE     *JUL-2014*\n         LR    R9,R0                                         *JUL-2014*\n         ST    R9,SAVER9E\n* ------------------------------------------------------------------- *\n*            COME HERE FOR BOTH LPA AND LOADED MODULES                *\n* ------------------------------------------------------------------- *\nENTRYPM  DS    0H                  Check if entry point is displaced.\n         L     R2,SAVER9B          Get entry point of module\n         L     R3,SAVER9C          Get beginning addr of module\n         SR    R2,R3               Calculate difference in length\n         BNP   ENTRYPM1            Number is not reliable\n         ST    R2,STORDIFF         Save the entry point displacement.\nENTRYPM0 DS    0H\n         LTR   R2,R2               Is it zero?\n         BZ    NODIFF              Then do the whole module.\nENTRYPM1 DS    0H\n         L     R1,LOADWHOL         Load length from LOAD macro\n         MVC   SAVER3A,LOADWHOL\n         S     R1,STORDIFF         Subtract offset of entry point\n         ST    R1,LOADSMAL         Preserve reduced load length\n         MVC   SAVER3B,LOADSMAL    Save short length for later\n         B     YESDIFF             Yes, entry point diff from load pt\nKEEPR9   DS    0H\n*\nNODIFF   DS    0H                  Go here if entry pt is load point\n         MVC   LOADSMAL,LOADWHOL   Size is from beginning to end\n         MVC   SAVER3B,LOADSMAL    Save size from entry point to end\n         L     R1,LOADWHOL         Load R1 with size\n         OI    FLAG1,X'01'         Flag load point equal entry point\n         L     R9,ADRSTART         Load R9 with data address\n*\nYESDIFF  DS    0H\n         TM    FLAG1,X'01'         Load point different from entry pt?\n         BZ    ENTRYDIF            No. Skip this section.\n         L     R1,LOADWHOL         Start R1 with whole size.\n         ST    R1,LOADLEN          And store it in LOADLEN.\n         L     R9,ADRSTART         Load R9 with data address\n* ------------------------------------------------------------------- *\nENTRYDIF DS    0H                  Display of Diagnostic Data\n         ST    R9,SAVER9A          SAVE THE PROGRAM DATA\n*        CLI   NOTITOP+1,0\n*        BNE   KEEPR9A\n         TM    FLAG2,X'20'\n         BO    NOTLPA00\n         TM    FLAG2,X'01'\n         BO    MARKLPA\nNOTLPA00 DS    0H\n         MVC   LINE,LINE-1\n         MVC   LINE(23),=C'Module has been LOADED.'\n         MVC   LINE+24(13),=C'CDE Address: '\n         HEX   LINE+37,4,CDEADDR\n         TM    FLAG2,X'20'\n         BZ    MARKCDEA\n         MVC   LINE+47(10),=C'Alias of: '\n         MVC   LINE+57(8),MAJNAME\nMARKCDEA DS    0H\n         STM   R14,R1,SAVE14T1\n         APUT  LINE,75\n         LM    R14,R1,SAVE14T1\n         B     MOREDSPL\nMARKLPA  DS    0H\n         MVC   LINE,LINE-1\n         MVC   LINE(23),=C'Module is from LPA.    '\n         MVC   LINE+21(14),=C'LPDE Address: '\n         HEX   LINE+35,4,LPDEADDR\n         TM    FLAG2,X'02'\n         BZ    MARKLPAA\n         MVC   LINE+46(10),=C'Alias of: '\n         MVC   LINE+56(8),MAJNAME\nMARKLPAA DS    0H\n         STM   R14,R1,SAVE14T1\n         APUT  LINE,65\n         LM    R14,R1,SAVE14T1\nMOREDSPL DS    0H\n         MVC   LINE,LINE-1\n         HEX   LINE+30,4,SAVER3A\n         MVC   LINE(30),=C'Length of loaded module Hex:  '\n         L     R3,SAVER3A\n         CVD   R3,CVDWORK          Convert to Decimal\n         MVC   LINE+42(9),=C'Decimal: '\n         MVC   LINE+52(10),MASK10\n         ED    LINE+52(10),CVDWORK+3\n         STM   R14,R1,SAVE14T1\n         APUT  LINE,75\n         LM    R14,R1,SAVE14T1\n         MVC   LINE,LINE-1\n         HEX   LINE+30,4,LOADSMAL\n         MVC   LINE(30),=C'Length after entry address :  '\n         L     R3,LOADSMAL\n         CVD   R3,CVDWORK          Convert to Decimal\n         MVC   LINE+42(9),=C'Decimal: '\n         MVC   LINE+52(10),MASK10\n         ED    LINE+52(10),CVDWORK+3\n         STM   R14,R1,SAVE14T1\n         APUT  LINE,75\n         LM    R14,R1,SAVE14T1\n         MVC   LINE,LINE-1\n         HEX   LINE+30,4,STORDIFF\n         MVC   LINE(30),=C'Displacement of entry point:  '\n         L     R3,STORDIFF\n         CVD   R3,CVDWORK          Convert to Decimal\n         MVC   LINE+42(9),=C'Decimal: '\n         MVC   LINE+52(10),MASK10\n         ED    LINE+52(10),CVDWORK+3\n         STM   R14,R1,SAVE14T1\n         APUT  LINE,75\n         LM    R14,R1,SAVE14T1\n         MVC   LINE,LINE-1             Test diagnostics display.\n         HEX   LINE,4,SAVER9A\n         HEX   LINE+10,4,SAVER9B\n         HEX   LINE+20,4,SAVER9C\n         HEX   LINE+30,4,SAVER9D\n         HEX   LINE+40,4,SAVER9E\n         HEX   LINE+50,4,LOADSMAL\n         HEX   LINE+60,4,LOADWHOL\n         HEX   LINE+70,4,STORDIFF\n         HEX   LINE+80,4,ADRSTART\n         HEX   LINE+90,4,SAVER1B\n         HEX   LINE+100,1,FLAG1\n*        STM   R14,R1,SAVE14T1\n*        APUT  LINE,105\n*        LM    R14,R1,SAVE14T1\nKEEPR9A  DS    0H\n*\n         CLI   NOHEXOP+1,0                                   *DEC-2016*\n         BNE   JUST1                                         *DEC-2016*\n         MVC   LINE,LINE-1         Print a line of dashes\n         MVC   LINE(65),DASHES\n         APUT  LINE,65\nNODASH1  DS    0H                                            *DEC-2016*\n* ------------------------------------------------------------------- *\n*              PREPARE FOR HEX DISPLAY OF ALL LINES                   *\n* ------------------------------------------------------------------- *\nENTRYPRM DS    0H                  Process the ENTRY keyword here.\n         CLI   ENTRYOP+1,0         Entry keyword not there?\n         BE    BIGMOD              Go treat whole module.\n         L     R9,SAVER9B          Data address at entry point\n         L     R1,LOADSMAL         Load reduced size, e.p. to end.\n         B     SMALLMOD            Don't display the whole module.\nBIGMOD   DS    0H\n         L     R9,SAVER9C          Address of beginning of the data.\n         L     R1,LOADWHOL         Load the full size of the module.\n*              IF THE MODULE SIZE < 64 THEN DON'T SHOW 64\nSMALLMOD DS    0H\n         LR    R10,R1              Save length for calculation\n         ST    R1,SAVER1L          Store it for printing\nLATENTRY DS    0H\n         ST    R10,SAVER10A        Store it for safety\n* ------------------------------------------------------------------- *\n*            Calculate how many lines we will need to print.          *\n* ------------------------------------------------------------------- *\n         SRDA  R10,32(0)           Set up divide\n         D     R10,=F'64'          Divide by 64 decimal\n         LTR   R10,R10             Even division?\n         BZ    NOREMNDR            Yes. Don't compensate for remainder\n         LA    R11,1(,R11)         Add 1 to compensate for remainder\n*                                    and print a partial line.\nNOREMNDR DS    0H\n         XR    R8,R8               Initialize byte counter\n* ------------------------------------------------------------------- *\n*                     Print All The Lines                             *\n* ------------------------------------------------------------------- *\nPRNTLOOP DS    0H\n*   R1 has quantity SAVER1L in it here.\n         C     R1,=F'64'           Less than 64?\n         BNH   *+8                 Yes, skip limit to 64.\n         L     R1,=F'64'           No. Just print 64 at a time\n         BCTR  R1,0                One less for execute.\n         STM   R14,R1,SAVE14T1     Protect registers used by APUT\n         MVC   LINE,LINE-1\n         ST    R1,SAVER1A\n         APUT  LINE,4,SAVER1A\n         LM    R14,R1,SAVE14T1\n*   R1 has quantity SAVER1P in it here.\n         ST    R1,SAVER1P          Save the length - 1\n         STM   R14,R1,SAVE14T1     Protect registers used by PRTXLINE\n         L     R1,SAVER1P          Save the length - 1\n         BAL   R7,PRTXLINE         Print these 64 bytes in hex\n         LM    R14,R1,SAVE14T1\n*   DISPLAY LATER LINES\n         LA    R9,64(,R9)          Skip 64 bytes from current\n         L     R1,SAVER1L          Reload remaining data length\n         S     R1,=F'64'           Subtract 64\n         BNP   JUST1               Finished? Stop the process.\n         ST    R1,SAVER1L          Decremented length\n         BCT   R11,PRNTLOOP\n* ------------------------------------------------------------------- *\n*                      END OF HEX DISPLAY                             *\n* ------------------------------------------------------------------- *\nJUST1    DS    0H                  CHECK FOR INITIAL INSTRUCTIONS\n         CLI   NOHEXOP+1,0\n         BE    NODASH01\n         MVC   LINE,LINE-1\n         MVC   LINE(65),DASHES\n         APUT  LINE,65\nNODASH01 DS    0H\n         TM    FLAG2,X'01'\n         BO    WASLPA\n         DELETE EPLOC=MEMBER\nWASLPA   DS    0H\n*\nEXIT0    SR    R15,R15             SET CC = 0.\n         ST    R15,SAVER15A        SAVE THE RETURN CODE\nEXIT     L     R13,SAVE+4          POINT TO CALLER'S SAVE AREA.\n         LM    R0,R12,20(R13)      RELOAD MOST OF CALLER'S REGISTERS.\n         L     R14,12(,R13)        RELOAD RETURN ADDRESS.\n         BR    R14                 RETURN TO CALLER.\nEXIT12   LA    R15,12\n         ST    R15,SAVER15A        SAVE THE RETURN CODE\n         B     EXIT\n* ------------------------------------------------------------------- *\n*                     HEX DISPLAY SUBROUTINE                          *\n* ------------------------------------------------------------------- *\nPRTXLINE DS    0H                  4-line hex printout routine.\n         ST    R7,SAVER7A\n         ST    R8,SAVER8A\n         CVD   R8,CVDWORK          The line number of bytes so far\n         MVC   LINE,LINE-1\n         L     R1,SAVER1P          Length of line to print\n         B     *+10\n         MVC   LINE(0),0(R9)       MOVE DATA TO PRINT LINE\n         EX    R1,*-6\n         L     R1,SAVER1P          RELOAD THE LENGTH\n         B     *+10\nTRHEXL0  TR    LINE(*-*),TRTBL0    Make the line of printables\n         EX    R1,TRHEXL0\n         HEX   LINE+67,4,SAVER8A       Print counter after 1st line\n         APUT  LINE,80             Print the line of printables\n         MVC   LINE,LINE-1\n         L     R1,SAVER1P          Reload the length of the line\n         B     *+10\n         MVC   LINE(0),0(R9)       MOVE DATA TO PRINT LINE\n         EX    R1,*-6\n         B     *+10\nTRHEXL1  TR    LINE(*-*),TRTBL1    HIGH NIBBLE IN HEX DISPLAY\n         EX    R1,TRHEXL1\n         APUT  LINE,64\n         MVC   LINE,LINE-1\n         L     R1,SAVER1P          Reload the length of the line\n         B     *+10\n         MVC   LINE(0),0(R9)       MOVE DATA TO PRINT LINE\n         EX    R1,*-6\n         B     *+10\nTRHEXL2  TR    LINE(*-*),TRTBL2    LOW NIBBLE IN HEX DISPLAY\n         EX    R1,TRHEXL2\n         APUT  LINE,64\n         MVC   LINE,LINE-1\n         L     R1,SAVER1P          Reload the length of the line\n*                                  since APUT destroys R1.\n         B     *+10\n         MVC   LINE(0),RULERL      Print the ruler line\n         EX    R1,*-6\n         APUT  LINE,64\n         LA    R8,64(,R8)          Increment counter (x 64)\n         L     R7,SAVER7A\n         BR    R7\n* ------------------------------------------------------------------- *\nHELPMSG  DS    0H\n         STM   R14,R1,SAVE14T1\n         APUT  '-------------------------------------------------',49\n         APUT  'Correct usage of LISTMOD is as follows:  ',41\n         APUT  '   ',3\n         APUT  '  LISTMOD modname (optional parameters)  ',41\n         APUT  '   ',3\n         APUT  'Parameters are:  NOHEX and ENTRY      ',39\n         APUT  '   ',3\n         APUT  'Required is the name of the module to load.',43\n         APUT  '   ',3\n         APUT  'Leaving out parameters produces the hex display',47\n         APUT  '  from the beginning of the module.  ENTRY starts',49\n         APUT  '  the display from the entry point of the module.',49\n         APUT  '   ',3\n         APUT  '  NOHEX prints the header information only.      ',49\n         APUT  '-------------------------------------------------',49\n         STM   R14,R1,SAVE14T1\n         B     EXIT\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\n         TITLE '- Static data area.'\n* ------------------------------------------------------------------- *\nSAVE     DS    9D                  SAVE AREA.\nCVDWORK  DS    D                   CVD work area\nLOADLEN  DS    F\nLPAREGS  DS    2F\nLOADWHOL DS    F                   Entire size of load module\nLOADSMAL DS    F                   Distance from entry point to end.\nSTORDIFF DS    F                   Displacement of entry point.\nENTRYOP  DS    F\nNOHEXOP  DS    F\nNOTITOP  DS    F\nHEXOP    DS    F\nTITOP    DS    F\nSAVE14T1 DS    4F\nADRENTRY DS    F\nADRSTART DS    F\nLPDEADDR DS    F\nCDEADDR  DS    F\nSAVER1A  DS    F\nSAVER1B  DS    F\nSAVER1L  DS    F                   HOLDS DECREMENTED LENGTH OF MODULE\nSAVER1P  DS    F                   HOLDS LENGTH OF PRINTED LINE - 1\nSAVER3A  DS    F\nSAVER3B  DS    F\nSAVER3C  DS    F\nSAVER7A  DS    F\nSAVER8A  DS    F\nSAVER9A  DS    F\nSAVER9B  DS    F\nSAVER9C  DS    F\nSAVER9D  DS    F\nSAVER9E  DS    F\nSAVER10A DS    F\nSAVER15A DS    F\nMAJNAME  DS    CL8\nFLAG1    DS    X                   X'01' if entry point at beginning\nFLAG2    DS    X                   X'01' if LPA module\nMASK10   DC    XL10'40202020202020202120'\nDASHES   DS    0CL65\nDASHEZ   DC    65C'-'\n         SPACE 1\n*IOPL     DS    0A                 IOPL FOR PUTLINE.\n*IOPLUPT  DS    A                  POINTER TO USER PROFILE TABLE.\n*IOPLECT  DS    A                  POINTER TO ENVIRONMENT CONTROL TAB.\n*IOPLECB  DC    A(ECB)             POINTER TO ECB.\n*IOPLIOPB DC    A(PTPB)            POINTER TO PTPB.\n         SPACE 1\n         SPACE 1\n*PTPB     PUTLINE MF=L PUTLINE PARM. BLOCK.\n         SPACE 1\nMVMEM    MVC   MEMBER(*-*),0(R15)  *** EXECUTED ***\n*VHEAD   MVC   0(*-*,R5),4(R9)     *** EXECUTED ***\nMVHEAD   MVC   LINE(*-*),4(R9)     *** EXECUTED ***\nTRT      TRT   0(*-*,R7),TRTAB     *** EXECUTED ***\nBLANKS   DC    CL65' '\nFULLZERO DC    F'0'\nRULERL   DC    C'0---+---+---+---1---+---+---+---2---+---+---+---3---+-x\n               --+---+---'\n         SPACE 1\nTRTAB    DC    256X'01'            TRT TABLE TO DETECT ...\n         ORG   TRTAB+C'a'          ... NON-DISPLAY CHARACTERS.\n         DC    9X'00'\n         ORG   TRTAB+C'j'\n         DC    9X'00'\n         ORG   TRTAB+C's'\n         DC    8X'00'\n         ORG   TRTAB+C'A'\n         DC    9X'00'\n         ORG   TRTAB+C'J'\n         DC    9X'00'\n         ORG   TRTAB+C'S'\n         DC    8X'00'\n         ORG   TRTAB+C'0'\n         DC    10X'00'\n         ORG   TRTAB+X'4A'\n         DC    7X'00'\n         ORG   TRTAB+C'!'\n         DC    8X'00'\n         ORG   TRTAB+X'6A'\n         DC    6X'00'\n         ORG   TRTAB+C':'\n         DC    6X'00'\n         ORG   TRTAB+X'AF'\n         DC    18X'00'\n         ORG   TRTAB+C'\\'\n         DC    2X'00'\n         ORG   TRTAB+C' '\n         DC    X'00'\n         ORG   ,\n         SPACE 1\n         LTORG\nWORKFULL DS    0F\n         DC    H'0'\nWORKHALF DC    H'0'\n         TITLE '- MESSAGES.'\nMSG001   DC    C'Load module has non-standard header.'\nMSG001L  EQU   *-MSG001\n         SPACE 1\nMSG002   DC    C'Cannot load '\nMEMBER   DC    CL8' '              NAME OF MEMBER TO BE EXAMINED.\n         DC    C' from any library in normal search path.'\nMSG002L  EQU   *-MSG002\nMSG003   DC    C'Beginning of CDE chain reached without a name match.'\nMSG003L  EQU   *-MSG003\n         TITLE '- Parse parameters.'\nPPL      DS    0A                  PARSE PARM LIST.\nPPLUPT   DS    A                   POINT TO UPT.\nPPLECT   DS    A                   POINT TO ECT.\nPPLECB   DC    A(ECB)              POINT TO ECB.\nPPLPCL   DC    A(PCL)              POINT TO PCL.\nPPLANS   DC    A(ANS)              POINT TO ANSWER PLACE.\nPPLCBUF  DS    A                   POINT TO COMMAND BUFFER.\nPPLWA    DC    A(0)                NO WORK AREA.\n         SPACE 1\nANS      DS    A                   ANSWER PLACE.\nECB      DC    A(0)                COMMAND PROCESSOR ECB.\nPCL      IKJPARM DSECT=PDL         PARSE PCL CSECT.\nPDLLM    IKJIDENT 'Load Module',FIRST=ALPHA,OTHER=ALPHANUM,            +\n               PROMPT='Load Module+',MAXLNTH=8,                        +\n               HELP=('Name of load module to be listed.')\nENTRYKW  IKJKEYWD ,\n         IKJNAME 'ENTRY'\nNOHEXKW  IKJKEYWD ,\n         IKJNAME 'NOHEX'\nHEXKW    IKJKEYWD ,\n         IKJNAME 'HEX'\n*NOTITKW IKJKEYWD ,\n*        IKJNAME 'NOTITLE'\n         IKJENDP\nHEX      DS    0H\n         ST    R4,SAVER4A\n         MVC   1(1,R15),0(R1)        Move byte\n         UNPK  0(3,R15),1(2,R15)     Unpack\n         TR    0(2,R15),HEXTAB-240\n         LA    R15,2(,R15)           Increment output pointer\n         LA    R1,1(,R1)             Increment input pointer\n         BCT   R0,HEX                Decrement length, then loop\n         MVI   0(R15),C' '           Blank the trailing byte\n         L     R4,SAVER4A\n         BR    R4                    Return to caller\nHEXTAB   DC    C'0123456789ABCDEF'   Translate table\nSAVER4A  DS    F\nHEXSAVE  DS    3F                    Register save for HEX macro\n         DS    CL1\nLINE     DS    CL200\nTRTBL0   DS    0D\n         DC    XL16'40404040404040404040404040404040'\n         DC    XL16'40404040404040404040404040404040'\n         DC    XL16'40404040404040404040404040404040'\n         DC    XL16'40404040404040404040404040404040'\n         DC    XL16'404040404040404040404A4B4C4D4E4F'\n         DC    XL16'504040404040404040405A5B5C5D5E5F'\n         DC    XL16'606140404040404040406A6B6C6D6E6F'\n         DC    XL16'404040404040404040407A7B7C7D7E7F'\n         DC    XL16'40818283848586878889404040404040'\n         DC    XL16'40919293949596979899404040404040'\n         DC    XL16'4040A2A3A4A5A6A7A8A9404040404040'\n         DC    XL16'40404040404040404040404040404040'\n         DC    XL16'C0C1C2C3C4C5C6C7C8C9404040404040'\n         DC    XL16'D0D1D2D3D4D5D6D7D8D9404040404040'\n         DC    XL16'E040E2E3E4E5E6E7E8E9404040404040'\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9404040404040'\nTRTBL1   DS    0D\n         DC    XL16'F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0'\n         DC    XL16'F1F1F1F1F1F1F1F1F1F1F1F1F1F1F1F1'\n         DC    XL16'F2F2F2F2F2F2F2F2F2F2F2F2F2F2F2F2'\n         DC    XL16'F3F3F3F3F3F3F3F3F3F3F3F3F3F3F3F3'\n         DC    XL16'F4F4F4F4F4F4F4F4F4F4F4F4F4F4F4F4'\n         DC    XL16'F5F5F5F5F5F5F5F5F5F5F5F5F5F5F5F5'\n         DC    XL16'F6F6F6F6F6F6F6F6F6F6F6F6F6F6F6F6'\n         DC    XL16'F7F7F7F7F7F7F7F7F7F7F7F7F7F7F7F7'\n         DC    XL16'F8F8F8F8F8F8F8F8F8F8F8F8F8F8F8F8'\n         DC    XL16'F9F9F9F9F9F9F9F9F9F9F9F9F9F9F9F9'\n         DC    XL16'C1C1C1C1C1C1C1C1C1C1C1C1C1C1C1C1'\n         DC    XL16'C2C2C2C2C2C2C2C2C2C2C2C2C2C2C2C2'\n         DC    XL16'C3C3C3C3C3C3C3C3C3C3C3C3C3C3C3C3'\n         DC    XL16'C4C4C4C4C4C4C4C4C4C4C4C4C4C4C4C4'\n         DC    XL16'C5C5C5C5C5C5C5C5C5C5C5C5C5C5C5C5'\n         DC    XL16'C6C6C6C6C6C6C6C6C6C6C6C6C6C6C6C6'\nTRTBL2   DS    0D\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\n         TITLE '- Mapping DSECTs.'\n         PRINT GEN\n         IKJCPPL                   MAP COMMAND PROCESSOR PARM LIST.\n         CVT   DSECT=YES\n         IKJTCB                                              *JUL-2014*\n         IHACDE                                              *JUL-2014*\n         IHAXTLST                                            *JUL-2014*\n         END   LISTMOD\nEPUTL    TITLE 'PUTLINE FOR FEWER THAN 83 ARGUMENTS IN THE KEY OF C MAJ&\n               OR'\nEPUTL    CSECT                                              *HMD 10/85*\n         LCLB  &XA                                          *HMD 10/85*\n&XA      SETB  1                  SET TO ZERO ON NON/XA     *HMD 10/85*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*  MODULE NAME  . . . . EPUTL\n*\n*  ALIASES  . . . . . . NONE\n*\n*  DATE WRITTEN . . . . 06/85\n*  UPDATED      . . . . 04/88                                  HD APR88\n*  CLEANED A BIT  . . . 08/17\n*\n*  AUTHOR . . . . . . . JIM ELSWORTH\n*  UPDATER  . . . . . . HOWARD M. DEAN                         HD APR88\n*\n*  ENVIRONMENT  . . . . TSO COMMAND PROCESSOR\n*\n*  PURPOSE:\n*    ALLOW AN EASY INTERFACE TO PUTLINE ROUTINE\n*\n*\n*  DESCRIPTION:\n*    BUILDS PUTLINE PARAMETER LIST BASED ON INPUT ARGUMENTS.\n*    ISSUES SINGLE LINE PUTLINE.\n*\n*\n*  ATTRIBUTES:\n*    REENTRANT\n*\n*  FEATURES:\n*    WILL RUN UNDER BATCH TMP SINCE PUTLINE USED INSTEAD OF TPUT.\n*\n*  CALLED MODULES:\n*    PUTLINE\n*\n*  ASSUMPTIONS:\n*    CALLED BY A TSO-CP THAT IS OBSERVING STANDARD LINKAGE\n*\n*  ABENDS:\n*    POSSIBLE 0CX IF BAD ARGUMENTS\n*\n*  CAVEATS:\n*    UNPREDICTABLE RESULTS IF FIRST PROGRAM RUNNING UNDER THIS TCB\n*    DID NOT SAVE (14,12) BEFORE R1 WAS MODIFIED.\n*\n*\n*  INPUT ARGUMENTS:\n*    1)  R1 : ADDRESS OF MESSAGE TEXT\n*    2)  R0 : LENGTH OF MESSAGE TEXT\n*    3) R13 : STANDARD OS SAVE AREA\n*    4) R14 : RETURN ADDRESS\n*    5) R15 : ENTRY ADDRESS\n*\n*               ( CONTINUED ... )\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*\n*  OUTPUT ARGUMENT: RETURN CODE FROM PUTLINE OR\n*\nRCBA     EQU   100                 BAD MESSAGE ADDRESS\nRCBL     EQU   104                 MESSAGE LENGTH <1 OR >MAXMSG\n*\nMAXMSG   EQU   255                 MAXIMUM MESSAGE LENGTH\n*\n*\n*  REGISTERS USED:\n*\nR0       EQU   0                   MESSAGE LENGTH AT ENTRY\nR1       EQU   1                   MESSAGE ADDRESS AT ENTRY\nR2       EQU   2                   WORK\nR3       EQU   3                   WORK\nRMA      EQU   4                   @MESSAGE TEXT\nRML      EQU   5                   MESSAGE LENGTH\nRUPT     EQU   6                   @UPT (USER PROFILE TABLE)\nRECT     EQU   7                   @ECT\nR12      EQU   12                  CSECT BASE\nR13      EQU   13                  @SAVE AREA AND DYNAMIC WORK AREA\nR14      EQU   14                  WORK/LINKAGE\nR15      EQU   15                  WORK/LINKAGE\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         EJECT\n         IKJCPPL\n         EJECT\n         IKJTCB   LIST=YES                                  *HMD 10/85*\n         EJECT                                              *HMD 10/85*\n         CVT      DSECT=YES,LIST=YES                        *HMD 10/85*\n         EJECT\n         IHAPSA   LIST=YES                                     HD APR88\n         EJECT                                                 HD APR88\nPUTLDS   DSECT\n         DS    18F                      OS SAVE AREA\nPUTAAA   EQU   *\nPUTECB   DS    F                        ECB\nPUTIOPL  DS    4F                       IOPLADS\nPUTBLOK  PUTLINE MF=L\nPUTLEN   DS    H                        LENGTH\nPUTZZZ   DS    H                        RESERVED\nPUTMSG   DS    (MAXMSG)C                MESSAGE TEXT AREA\n         DS    0D\nPUTSIZE  EQU   *-PUTLDS                 SIZE OF PUTLINE PARMS\n         EJECT\n***********************************************************************\n*  SET UP LINKAGE\n***********************************************************************\n         SPACE 1\nEPUTL    CSECT\n         AIF  (NOT &XA).X001                                *HMD 10/85*\nEPUTL    AMODE 31\n.X001    ANOP                                               *HMD 10/85*\n         STM   R14,R12,12(R13)    SAVE CALLERS REGS\n         LR    R12,R15            COPY EPA\n         USING EPUTL,R12          ADDRESSABILITY\n         AIF   (NOT &XA).X002                               *HMD 10/85*\n         GETMAIN RU,              LV=LENGTH                            &\n               LV=PUTSIZE,        STANDARD OS SA PLUS ANY EXTRA        &\n               LOC=RES,SP=0       RELATIVE TO 16MB LINE\n         AGO   .X003                                        *HMD 10/85*\n.X002    ANOP                                               *HMD 10/85*\n         GETMAIN RU,              LV=LENGTH                            &\n               LV=PUTSIZE         STANDARD OS SA PLUS ANY EXTRA\n.X003    ANOP                                               *HMD 10/85*\n         ST    R1,8(,R13)         OUR SAVE AREA POINTER\n         ST    R13,4(,R1)         POINTER TO CALLER'S SAVE AREA\n         LR    R13,R1             @OUR SAVE AREA\n         USING PUTLDS,R13         MAP SA AND WORK AREA\n         L     R14,4(,R13)        POINT TO CALLER'S RSA\n         LM    R0,R1,20(R14)      RESTORE REGS CHANGED BY GETMAIN\n         SPACE 2\n***********************************************************************\n*  UNLOAD ARGUMENTS AND VALIDATE WHERE POSSIBLE\n***********************************************************************\n         SPACE 1\n         LA    R15,RCBA                 RC IF BAD ADDRESS\n         LTR   RMA,R1                   MESSAGE ADDRESS\n         BNP   RETURN                   GOOD ASSUMPTION\n         LA    R15,RCBL                 RC IF BAD LENGTH\n         LTR   RML,R0                   POSITIVE?\n         BNP   RETURN                   -NO\n         C     RML,=A(MAXMSG)           MORE THAN MAX?\n         BH    RETURN                   -YES\n         SPACE 2\n***********************************************************************\n*  BUILD PARAMETER LIST\n***********************************************************************\n         SPACE 1\n         LA    R15,4(,RML)              MESSAGE LENGTH\n         STH   R15,PUTLEN               PLUS HEADER\n         XC    PUTZZZ,PUTZZZ            CLEAR 2ND HWORD OF RDW\n         BCTR  RML,0                    REDUCE FOR MOVE\n         EX    RML,PUTMOVE\n         EJECT\n***********************************************************************\n*  DIG UP ADDRESS OF UPT AND ECT\n***********************************************************************\n         SPACE 1\n         L     R2,PSATOLD-PSA           @TCB                   HD APR88\n         L     R2,TCBFSA-TCB(,R2)       @1ST PROBLEM PGM SAVE AREA\n         L     R2,24(,R2)               REG1 THAT WAS PASSED TO CP\n         USING CPPL,R2                  MAP CPPL\n         L     RUPT,CPPLUPT             @UPT\n         L     RECT,CPPLECT             @ECT\n         SPACE 2\n***********************************************************************\n*  ISSUE PUTLINE CALL\n***********************************************************************\n         SPACE 1\n         XC    PUTECB,PUTECB            CLEAR ECB\n         XC    PUTBLOK(12),PUTBLOK      CLEAR PARM BLOCK       HD APR88\n         PUTLINE PARM=PUTBLOK,          PARAMETER BLOCK                &\n               UPT=(RUPT),              @UPT                           &\n               ECT=(RECT),              @ECT                           &\n               ECB=PUTECB,              @ECB                           &\n               OUTPUT=(PUTLEN,TERM,SINGLE,DATA),                       &\n               MF=(E,PUTIOPL)\n         EJECT\n***********************************************************************\n*  RETURN TO CALLER\n***********************************************************************\n         SPACE 1\nRETURN   EQU   *\n         LR    R2,R13                   @OUR SAVE AREA\n         LR    R3,R15                   SAVE RETURN CODE\n         L     R13,4(,R13)              @CALLER'S SAVE AREA\n         FREEMAIN RU,LV=PUTSIZE,A=(R2),SP=0\n         LR    R15,R3                   RESTORE RC\n         RETURN (14,12),RC=(15)         RESTORE CALLER'S REGS\n         SPACE 5\n***********************************************************************\n*  CONSTANTS AND NON-REENTRANT WORK AREAS\n***********************************************************************\n         SPACE 1\nPUTMOVE  MVC   PUTMSG(*-*),0(RMA)       MOVE MESSAGE TO BUFFER\n         SPACE 2\n         LTORG\n         SPACE 2\n         END   EPUTL\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LISTMOD$": {"ttr": 1540, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x12\\x00T\\x01\\x055O\\x01\\x19\"O\\x12\\x15\\x00\\x1d\\x00\\x1d\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.18", "flags": 0, "createdate": "2005-12-20T00:00:00", "modifydate": "2019-08-12T12:15:54", "lines": 29, "newlines": 29, "modlines": 0, "user": "SBGOLOB"}, "text": "//SBGOLOBU JOB (CCMVS),ASMLINK,\n// NOTIFY=&SYSUID,\n// CLASS=A,MSGCLASS=X,COND=(1,LT)\n//*\n//*     ASSEMBLE AND LINKEDIT LISTMOD\n//*\n//ASMH EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,NORLD,NOXREF)\n//SYSLIB   DD DISP=SHR,DSN=SYS1.MACLIB\n//         DD DISP=SHR,DSN=SYS1.MODGEN\n//         DD DISP=SHR,DSN=SBGOLOB.CBT498.FILE994\n//SYSIN    DD DISP=SHR,DSN=SBGOLOB.CBT498.FILE994(LISTMOD)\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,9),DISP=(,PASS),DCB=BLKSIZE=3200,\n//            DSN=&&TEMP\n//*\n//LKED   EXEC  PGM=HEWL,\n//       PARM='NCAL,MAP,LIST,LET,NOREUS,NORENT'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//SYSLMOD  DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//OBJECT   DD  DISP=(OLD,DELETE),DSN=&&TEMP\n//SYSLIN   DD  *\n INCLUDE OBJECT\n SETCODE AC(0)\n SETSSI  CB498994\n ENTRY   LISTMOD\n NAME    LISTMOD(R)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "LISTMOD#": {"ttr": 1542, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x008\\x01\\x19\"O\\x01\\x19\"O\\x15\\x18\\x00\\x13\\x00\\x13\\x00\\x00\\xe3\\xe2\\xd6\\xc2\\xc1\\xe3@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2019-08-12T00:00:00", "modifydate": "2019-08-12T15:18:38", "lines": 19, "newlines": 19, "modlines": 0, "user": "TSOBAT"}, "text": "//SBGOLOBT  JOB (ACCT#),S-GOLOB,\n// NOTIFY=&SYSUID,\n// CLASS=B,MSGCLASS=X\n//* --------------------------------------------------------------- *//\n//*  EXAMPLE OF RUNNING LISTMOD AGAINST A LARGE MODULE TO CAPTURE   *//\n//*  THE DATA FOR EXAMINATION.  TSO-IN-BATCH.                       *//\n//* --------------------------------------------------------------- *//\n//TSOBATCH EXEC PGM=IKJEFT01\n//STEPLIB  DD DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//SYSTSPRT DD DISP=(NEW,CATLG,DELETE),DSN=SBGOLOB.LISTMOD.IEFW21SD,\n//         UNIT=SYSALLDA,VOL=SER=WORKS3,\n//         DCB=(RECFM=FB,LRECL=80,BLKSIZE=27920),\n//         SPACE=(CYL,(3,9),RLSE)\n//SYSTSIN DD *\nLISTMOD IEFW21SD\n/*\n//\nLISTMOD IEFAB4A0 ENTRY\nLISTMOD IEFW21SD ENTRY\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "LISTMODD": {"ttr": 1544, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01c\\x00\\x17\\x01\\x14 \\x1f\\x01 \\x03O\\x08\\x15\\x04`\\x02\\xcc\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.99", "flags": 0, "createdate": "2014-07-20T00:00:00", "modifydate": "2020-02-03T08:15:17", "lines": 1120, "newlines": 716, "modlines": 0, "user": "SBGOLOB"}, "text": "LISTMODD TITLE '- TSO command to list load module in hex format'\n         SPACE 1\n* ------------------------------------------------------------------- *\n***********************************************************************\n*                                                                     *\n*     LISTMODD - TSO command to list an entire module in ISPF-like    *\n*               hexadecimal format.  Width of the display is          *\n*               112 bytes wide, so that a wide screen is preferable.  *\n*                                                                     *\n*               Displacements of data are marked in decimal.          *\n*                                                                     *\n*               Using the ENTRY parameter, the display goes from      *\n*               the entry point until the physical end of the module. *\n*               Otherwise, the display includes the entire module     *\n*               from beginning to end.                                *\n*                                                                     *\n*     Register usage:                                                 *\n*           R5 - Base.                                                *\n*           R6 - Work.                                                *\n*           R7 - Work.                                                *\n*           R8 - Work.                                                *\n*           R9 - Work, Parse PDEs.                                    *\n*          R10 - CPPL pointer.                                        *\n*          R12 - Base.                                                *\n*                                                                     *\n*     Ideas in the program were developed by Jeffrey Broido and       *\n*     Bill Godfrey.  The program was adapted for dumping load         *\n*     modules, by Sam Golob.                                          *\n*                                                                     *\n*     Partial description of the program:  Display the bytes of       *\n*     a load module in ISPF-like 3-line hexadecimal format, with      *\n*     ruler to help measure and locate particular bytes.              *\n*                                                                     *\n*     The program works (currently) by first testing if the module    *\n*     is in the Link Pack Area (LPA).  If so, then the LPDE is        *\n*     looked up, to obtain the relevant information.  If the program  *\n*     is not in LPA, then a LOAD macro is issued to obtain the        *\n*     information.                                                    *\n*                                                                     *\n*     The program either displays the entire load module, or,         *\n*     using the ENTRY parameter, it starts with the entry point,      *\n*     and it dumps the contents of the rest of the load module,       *\n*     in 3-line hex format with ruler, to see what is there.          *\n*                                                                     *\n*     All the bytes of the program are displayed, if there is no      *\n*     parameter.  If the ENTRY parameter is used, then all the        *\n*     bytes from the entry point to the end of the module, are        *\n*     displayed.                                                      *\n*                                                                     *\n*              example:    LISTMODD modname ENTRY                     *\n*                                                                     *\n*     Please note that the HEX display will show all hex values       *\n*     in \"printable\" format, so you don't need any other tools        *\n*     to see the contents of the load modules, displayed in a         *\n*     3-line hexadecimal display with added ruler.                    *\n*                                                                     *\n*     For some modules, such as IEBCOPY, you have to use the          *\n*     ENTRY parameter to see a realistic eyecatcher.  But since       *\n*     (with IEBCOPY and with many other load modules) the entry       *\n*     point is in the middle of the load module, LISTMODD will        *\n*     then (using the ENTRY keyword) only list the bytes from         *\n*     the entry point location until the end of the module.           *\n*                                                                     *\n*     CHANGES:  2020/02/03 - SBG                                      *\n*               Changed ruler to go from 0 to 99 instead of           *\n*               from 1 to 100.  It had been one byte off.             *\n*                                                                     *\n***********************************************************************\n         MACRO\n&LABEL   APUT  &MSG,                    @MESSAGE TEXT                  &\n               &LEN,                    @LENGTH OF MESSAGE             &\n               &RSA=,                   OPTIONAL 2 WORD SAVE AREA      &\n               &EPA=                    EPUTL EPA\n.*\n.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*\n.*  --> E@PUT\n.*\n.*  THIS MACRO SETS UP A PARAMETERS AND INVOKES THE EPUTL ROUTINE.\n.*\n.*\n.*  ARGUMENTS: -----------------------------------------------------\n.*\n.*      &MSG : ADDRESS OF MESSAGE TEXT OR A LITERAL\n.*\n.*      &LEN : LENGTH OF MESSAGE TEXT (DEFAULT IS L'&MSG)\n.*\n.*      &RSA :(OPTIONAL) 1 WORD SAVE AREA TO PRESERVE R14 FOR TPUT\n.*            COMPATIBILITY.\n.*\n.*      &EPA :(OPTIONAL) EPA FOR EPUTL ROUTINE\n.*\n.*\n.*   EXAMPLES: -----------------------------------------------------\n.*\n.*      1) APUT  'LITERAL'\n.*\n.*      2) APUT  (R3),80\n.*\n.*      3) APUT  LABEL\n.*\n.*      4) APUT  LABEL,40\n.*\n.*\n.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*\n.*\n.*  LOCAL SET SYMBOLS\n.*\n         LCLC  &SMA                     MESSAGE ADDRESS (REG)\n         LCLC  &SML                     MESSAGE LENGTH (REG)\n         LCLC  &SEP                     EPA (REGISTER)\n.*\n         LCLC  &L1,&L2,&L3              LOCAL LABELS\n.*\n&L1      SETC  'EP'.'&SYSNDX'.'L1'      LOCAL LABELS\n&L2      SETC  'EP'.'&SYSNDX'.'L2'      LOCAL LABELS\n&L3      SETC  'EP'.'&SYSNDX'.'L3'      LOCAL LABELS\n.*\n.*\n.*  MESSAGE ADDRESS\n.*\n         AIF   (T'&LABEL EQ 'O').A0500                      *HMD 11/86*\n.*                                                          *HMD 11/86*\n&LABEL   DS    0H                                           *HMD 11/86*\n.*                                                          *HMD 11/86*\n.A0500   ANOP                                               *HMD 11/86*\n         AIF   ('&MSG' NE '').A2000\n         MNOTE 8,'''&MSG='' MISSING / REQUIRED'\n         MEXIT\n.*\n.A2000   ANOP\n         AIF   ('&MSG'(1,1) NE '(').A2400\n&SMA     SETC  '&MSG'(2,K'&MSG-2)\n         LR    R1,&SMA                  @MESSAGE TEXT\n         AGO   .A2600\n.*\n.A2400   ANOP\n         AIF   ('&MSG'(1,1) NE '''').A2500\n         B     &L3                      BRANCH AROUND MESSAGE\n&L2      DC    C&MSG\n&L3      DS    0H\n         LA    R1,&L2                   @MESSAGE\n         AGO   .A2600\n.*\n.A2500   ANOP\n         LA    R1,&MSG                  @MESSAGE TEXT\n.A2600   ANOP\n.*\n.*  MESSAGE LENGTH\n.*\n         AIF   ('&LEN' NE '').A3000\n         AIF   ('&MSG'(1,1) NE '''').A2800\n         LA    R0,L'&L2                 MESSAGE LENGTH\n         AGO   .A3600\n.*\n.A2800   ANOP\n         AIF   ('&MSG'(1,1) EQ '(').A2900\n         LA    R0,L'&MSG                MESSAGE LENGTH\n         AGO   .A3600\n.*\n.A2900   ANOP\n         MNOTE 8,'''LEN'' MISSING / REQUIRED'\n         MEXIT\n.*\n.A3000   ANOP\n         AIF   ('&LEN'(1,1) NE '(').A3400\n&SML     SETC  '&LEN'(2,K'&LEN-2)\n         LR    R0,&SML                  MESSAGE LENGTH\n         AGO   .A3600\n.*\n.A3400   ANOP\n         LA    R0,&LEN                  MESSAGE LENGTH\n.A3600   ANOP\n.*\n.*  RSA\n.*\n         AIF   ('&RSA' EQ '').A4900\n         ST    R14,&RSA                 SAVE REGS 14\n.A4900   ANOP\n.*\n.*  ENTRY POINT\n.*\n         AIF   ('&EPA' NE '').A5000\n         L     R15,=V(EPUTL)            EPA\n         AGO   .A5600\n.*\n.A5000   AIF   ('&EPA'(1,1) NE '(').A5400\n&SEP     SETC  '&EPA'(2,K'&EPA-2)\n         LR    R15,&SEP                 EPA\n         AGO   .A5600\n.*\n.A5400   ANOP\n         L     R15,&EPA                 EPA\n.*\n.A5600   ANOP\n.*\n.*  CALL LINKAGE\n.*\n.ACALL   BALR  R14,R15                  CALL PUTLINE ROUTINE\n.*\n         AIF   ('&RSA' EQ '').A6900\n         L     R14,&RSA                 RESTORE R14\n.A6900   ANOP\n.*\n.AMEND   MEND\n* ------------------------------------------------------------------- *\n*      PRODUCE A \"DISPLAY REPRESENTATION\" OF HEXADECIMAL NUMBERS      *\n* ------------------------------------------------------------------- *\n         MACRO\n&NAME    HEX   &TO,&LEN,&FROM\n&NAME    DS    0H\n         STM   R15,R1,HEXSAVE\n         LA    R1,&FROM\n         LA    R0,&LEN\n         LA    R15,&TO\n         BAL   R4,HEX\n         LM    R15,R1,HEXSAVE\n         MEND\n* ------------------------------------------------------------------- *\n*                   BEGINNING OF THE PROGRAM                          *\n* ------------------------------------------------------------------- *\nLISTMODD AMODE 31\nLISTMODD RMODE ANY\nLISTMODD CSECT\n         SPACE 1\n         SPACE 1\n         YREGS\n         USING LISTMODD,R15        (ESTABLISH TEMPORARY BASE).\n         B     BEGIN               SKIP OVER HEADER.\nHEAD0    DC    AL1(HEADL)          EXCLUSIVE LENGTH OF HEADER.\nHEAD     DC    C'LISTMODD - &SYSDATE - &SYSTIME  '\nHEADL    EQU   *-HEAD\n         DROP  R15                 (DROP TEMPORARY BASE).\nBEGIN    STM   R14,R12,12(R13)     SAVE CALLER'S REGISTERS\n         LR    R12,R15             COPY BASE.\n         USING LISTMODD,R12,R5     SET UP BASE REGISTERS.\n         LA    R5,4095(,R12)\n         LA    R5,1(,R5)\n         LR    R14,R13             COPY CALLER'S SAVE AREA POINTER.\n         LA    R13,SAVE            POINT TO MY SAVE AREA.\n         ST    R14,SAVE+4          CHAIN ...\n         ST    R13,8(,R14)         ... SAVE AREAS.\n         SPACE 1\n         MVI   LINE-1,X'40'\n         MVC   LINE,LINE-1\n         MVI   BLANKS-1,X'40'      FILL THE BLANKS FIELD\n         MVC   BLANKS,BLANKS-1       WITH BLANKS\n         MVC   MEMBER,BLANKS       Initialize member name with blanks.\n         LR    R10,R1              PRESERVE CPPL POINTER.\n         MVC   MAJNAME,BLANKS\n         USING CPPL,R10            (TELL ASSEMBLER)\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*        Initialize the Parse Parameter List and call TSO Parse.      *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         MVC   PPLUPT,CPPLUPT      COPY UPT ADDRESS.\n         MVC   PPLECT,CPPLECT      COPY ECT ADDRESS.\n         MVC   PPLCBUF,CPPLCBUF    COPY COMMAND BUFFER ADDRESS.\n         SPACE 1\n         LA    R1,PPL              POINT TO THE PPL.\n         XC    ECB,ECB             CLEAR ECB.\n         CALLTSSR EP=IKJPARS       PARSE INPUT.\n         LTR   R15,R15             Check return code from IKJPARS\n         BNZ   HELPMSG             Not zero, Help message and end.\n         L     R9,ANS              POINT TO PDES.\n         USING PDL,R9              TELL ASSEMBLER.\n         LH    R1,PDLLM+4          LOAD LENGTH OF LOAD MODULE NAME.\n         BCTR  R1,*-*              DECREMENT LENGTH.\n         L     R15,PDLLM           POINT TO RETURNED MEMBER NAME.\n         EX    R1,MVMEM            COPY MEMBER NAME FROM PDL\n*      ( MVC   MEMBER(*-*),0(R15)  )\n         MVC   ENTRYOP,ENTRYKW\n         MVC   NOHEXOP,NOHEXKW                               *DEC-2016*\n         MVC   HEXOP,HEXKW\n*        MVC   NOTITOP,NOTITKW                               *DEC-2016*\n         MVI   FLAG1,X'00'             Initialize flag.\n         MVC   STORDIFF,=X'00000000'   Assume the entry point at 0.\nFREEPDES IKJRLSA ANS               FREE THE PDES.\n*        CLI   NOTITOP+1,0                                   *DEC-2016*\n*        BNE   NOTIT2                                        *DEC-2016*\n         MVC   LINE,LINE-1\n         MVC   LINE(22),=C'Loaded Program Name:  '\n         MVC   LINE+22(8),MEMBER\n         APUT  LINE,40\nNOTIT1   DS    0H                                            *DEC-2016*\n*        CLI   NOHEXOP+1,0         IF NOHEX KEYWORD          *DEC-2016*\n*        BNE   LPA0\n         MVC   LINE,LINE-1\n         MVC   LINE(65),DASHES\n         APUT  LINE,65\nNOTIT2   DS    0H                                            *DEC-2016*\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*              FETCH THE USER-SPECIFIED LOAD MODULE.                  *\n*                                                                     *\n***********************************************************************\n* ------------------------------------------------------------------- *\n*    LOGIC OF THE PROGRAM WAS CHANGED TO DO A STANDARD \"LOAD\" FOR     *\n*    THE MODULE REQUESTED, BUT TO AFTERWARDS, ALSO CALCULATE THE      *\n*    MODULE ENTRY POINT IN THE DIFFERENT WAYS POSSIBLE, AND TO SAVE   *\n*    ALL THE RESULTS.  AFTERWARDS, DEPENDING ON WHETHER THE \"ENTRY\"   *\n*    PARAMETER WAS CODED, THE RESULTS ARE DISPLAYED ACCORDINGLY.      *\n* ------------------------------------------------------------------- *\n*    We first ask if the module is from LPA, and if not, then we      *\n*    LOAD it.                                                         *\n* ------------------------------------------------------------------- *\nLPA0     DS    0H\n         LM    R0,R1,MEMBER       Load member name for IEAVVMSR\n         STM   R7,R8,LPAREGS      Save registers\n         L     R3,16              CVT\n         L     R15,352(,R3)       CVTLPDSR\n         BALR  R14,R15            CALL IEAVVMSR\n         B     LPAINFO            MODULE IS IN LPA, GET LPDE.\n         B     LOAD0              NOT IN LPA, TRY LOADING IT.\nLPAINFO  DS    0H\n         OI    FLAG2,X'01'        FLAG THE MODULE AS AN LPA MODULE.\n         LM    R7,R8,LPAREGS      RESTORE REGISTERS\n         LR    R6,R0              SAVE LPDE ADDRESS\n         ST    R6,LPDEADDR        And store it for reporting\n         L     R9,16(,R6)         GET ENTRY POINT ADDRESS\n         N     R9,=X'7FFFFFFF'    Get rid of high bit.\n         ST    R9,SAVER9B         SAVE MODULE ENTRY POINT\n         TM    X'1C'(R6),X'04'    IS THIS A MINOR LPDE (ALIAS)?\n         BZ    MAJLPDE            NO. PROCESS AS A MAJOR.\n         OI    FLAG2,X'02'        Mark this one as an alias.\n         MVC   MAJNAME(8),X'20'(R6)  Copy the major name for report.\n         L     R6,X'14'(,R6)      YES. GET ADDRESS OF MAJOR LPDE.\nMAJLPDE  DS    0H\n         L     R9,X'24'(,R6)      GET MODULE LOAD POINT.\n         N     R9,=X'7FFFFFFF'    Remove the 31-bit indicator\n         ST    R9,ADRSTART        Start of the full data of the module\n         ST    R9,SAVER9A         Save it in another place\n         ST    R9,SAVER9C         SAVE THE LOAD POINT.\n         L     R9,X'20'(,R6)      GET THE SIZE OF THE LOAD MODULE.\n         ST    R9,LOADLEN         SAVE THE ENTIRE SIZE\n         MVC   LOADWHOL,LOADLEN   COPY WHOLE SIZE\n         L     R2,SAVER9B         GET THE ENTRY POINT\n         L     R3,SAVER9C         SUBTRACT THE LOAD POINT\n         SR    R2,R3              GET THE DISPLACEMENT\n         BNP   ENTRYPM1           GO TO SAME CALC AS WITH LOAD\n         ST    R2,STORDIFF        SAVE THE DISPLACEMENT\n         B     ENTRYPM0           GO TO THE SAME CALC AS WITH LOAD\n* ------------------------------------------------------------------- *\nLOAD0    DS    0H                 NOT IN LPA. LOAD THE MODULE.\n         LM    R7,R8,LPAREGS      RESTORE REGISTERS\n         LOAD  EPLOC=MEMBER,ERRET=LOAD1  FETCH LOAD MODULE TO LIST.\n*    Put in a display of x number of bytes at the load point, here.\nLOAD1    LTR   R15,R15             WAS LOAD SUCCESSFUL?\n         BZ    LOAD2               B IF YES; CONTINUE.\n*              SAY: CANNOT LOAD MEMBER.\n         MVC   LINE,LINE-1\n         MVC   LINE(MSG002L),MSG002\n         APUT  LINE,MSG002L\n         LA    R15,8               SET CC = 8.\n         B     EXIT                EXIT.\nLOAD2    DS    0H\n         LR    R9,R0               POINT TO LOAD MODULE TO BE LISTED.\n         N     R9,=X'7FFFFFFF'     Get rid of high bit for calculations\n         ST    R9,ADRSTART         Start of the full data of the module\n         ST    R9,SAVER9A          Save it in another place\n         ST    R9,SAVER9B          Save it again in another place\n         NC    SAVER9B(4),=A(X'7FFFFFFF')  Maybe not necessary\n         N     R1,=A(X'00FFFFFF')  ISOLATE LENGTH IN DWORDS  *JUL-2014*\n         ST    R3,SAVER3B          Save R3 to restore later\n         LR    R3,R1               Get length in doublewords\n         SLL   R3,3                Convert to bytes (multiply by 8)\n         ST    R3,SAVER3A          Save length in bytes\n         L     R3,SAVER3B          Restore original R3\n         SLL   R1,3                Do the same for R1        *JUL-2014*\n         ST    R1,LOADLEN          And save the max display length\n         MVC   LOADWHOL,LOADLEN    Save it again\n* ------------------------------------------------------------------- *\n* NOTE: IF THE 'ENTRY' KEYWORD IS SPECIFIED, AND THE         *JUL-2014*\n* ENTRY POINT IS NEAR THE END OF THE MODULE, THERE MAY BE    *JUL-2014*\n* FEWER BYTES THAN THE LOADLEN VALUE FROM THE ENTRY POINT    *JUL-2014*\n* TO THE END OF THE MODULE. AS A RESULT, THE DISPLAY OF      *JUL-2014*\n* LOADLEN BYTES MIGHT INCLUDE THE CONTENTS OF MEMORY BEYOND  *JUL-2014*\n* THE END OF THE MODULE.                                     *JUL-2014*\n* IF THE LAST CDE IN JOB PACK AREA QUEUE IS FOR A MODULE     *JUL-2014*\n* THAT CONTAINS THE ENTRY POINT ADDRESS IN R9, USE THE       *JUL-2014*\n* ADDRESS OF THE MODULE INSTEAD OF THE ENTRY POINT.          *JUL-2014*\n* NOTE: COULD ALSO USE LOADPT= ON THE LOAD MACRO, BUT        *JUL-2014*\n* MVS 3.8 SYSTEMS DON'T HAVE LOADPT=.                        *JUL-2014*\n* ------------------------------------------------------------------- *\n*       CALCULATE THE ENTRY POINT ADDRESS OF THE LOAD MODULE          *\n*              THIS CODE IS NOW, ALWAYS EXECUTED.                     *\n* ------------------------------------------------------------------- *\n         N     R9,=A(X'7FFFFFFF')                            *JUL-2014*\n         L     R14,540             PSATOLD -> CURRENT TCB    *JUL-2014*\n         L     R14,TCBJSTCB-TCB(,R14) POINT TO JOB STEP TCB  *JUL-2014*\n         L     R14,TCBJPQ-TCB(,R14) PNT TO LAST CDE IN JPAQ  *JUL-2014*\n* ------------------------------------------------------------------- *\n*              The correct CDE might not be the last one,             *\n*             so chain back until you've got a name match.            *\n* ------------------------------------------------------------------- *\nCDELOOP  DS    0H                  Check if CDE matches member name\n         CLC   MEMBER(8),8(R14)    Is this the correct CDE? (match)\n         BE    CDEEND              Yes, then process it.\n         CLC   FULLZERO,0(R14)     Back at the beginning of the chain\n         BE    CDEBAD                without a match? Then error.\n         L     R14,0(,R14)         No match. Go back one previous CDE.\n         B     CDELOOP             Keep trying till match or first CDE\n*                                    without a match.\nCDEBAD   DS    0H\n         MVC   LINE,LINE-1         Error message if beginning of CDE\n         MVC   LINE(MSG003L),MSG003  was reached without a name match.\n         APUT  LINE,MSG003L\n         B     EXIT12              Code 12 for this one.\nCDEEND   DS    0H\n         ST    R14,CDEADDR\n         TM    CDATTR-CDENTRY(R14),CDMIN TEST FOR MINOR CDE  *JUL-2014*\n         BZ    MAJCDE              BRANCH IF MAJOR CDE       *JUL-2014*\n         L     R14,CDXLMJP-CDENTRY(,R14) POINT TO MAJOR CDE  *JUL-2014*\n         OI    FLAG2,X'20'        Mark as CDE of an alias.\n         MVC   MAJNAME(8),X'8'(R14)     REAL NAME OF MODULE\nMAJCDE   L     R14,CDXLMJP-CDENTRY(,R14) POINT TO EXTENT     *JUL-2014*\n         L     R0,XTLMSBAD-XTLST(,R14) ADDRESS OF MODULE     *JUL-2014*\n         ST    R0,SAVER9C\n         CR    R9,R0                                         *JUL-2014*\n         BL    KEEPR9                                        *JUL-2014*\n         L     R0,XTLMSBLA-XTLST(,R14) LENGTH OF MODULE      *JUL-2014*\n         N     R0,=A(X'7FFFFFFF')                            *JUL-2014*\n         ST    R0,SAVER1B\n         A     R0,XTLMSBAD-XTLST(,R14) ADDRESS OF MODULE     *JUL-2014*\n         ST    R0,SAVER9D\n         CR    R9,R0                                         *JUL-2014*\n         BNL   KEEPR9                                        *JUL-2014*\n         L     R0,XTLMSBAD-XTLST(,R14) ADDRESS OF MODULE     *JUL-2014*\n         LR    R9,R0                                         *JUL-2014*\n         ST    R9,SAVER9E\n* ------------------------------------------------------------------- *\n*            COME HERE FOR BOTH LPA AND LOADED MODULES                *\n* ------------------------------------------------------------------- *\nENTRYPM  DS    0H                  Check if entry point is displaced.\n         L     R2,SAVER9B          Get entry point of module\n         L     R3,SAVER9C          Get beginning addr of module\n         SR    R2,R3               Calculate difference in length\n         BNP   ENTRYPM1            Number is not reliable\n         ST    R2,STORDIFF         Save the entry point displacement.\nENTRYPM0 DS    0H\n         LTR   R2,R2               Is it zero?\n         BZ    NODIFF              Then do the whole module.\nENTRYPM1 DS    0H\n         L     R1,LOADWHOL         Load length from LOAD macro\n         MVC   SAVER3A,LOADWHOL\n         S     R1,STORDIFF         Subtract offset of entry point\n         ST    R1,LOADSMAL         Preserve reduced load length\n         MVC   SAVER3B,LOADSMAL    Save short length for later\n         B     YESDIFF             Yes, entry point diff from load pt\nKEEPR9   DS    0H\n*\nNODIFF   DS    0H                  Go here if entry pt is load point\n         MVC   LOADSMAL,LOADWHOL   Size is from beginning to end\n         MVC   SAVER3B,LOADSMAL    Save size from entry point to end\n         L     R1,LOADWHOL         Load R1 with size\n         OI    FLAG1,X'01'         Flag load point equal entry point\n         L     R9,ADRSTART         Load R9 with data address\n*\nYESDIFF  DS    0H\n         TM    FLAG1,X'01'         Load point different from entry pt?\n         BZ    ENTRYDIF            No. Skip this section.\n         L     R1,LOADWHOL         Start R1 with whole size.\n         ST    R1,LOADLEN          And store it in LOADLEN.\n         L     R9,ADRSTART         Load R9 with data address\n* ------------------------------------------------------------------- *\nENTRYDIF DS    0H                  Display of Diagnostic Data\n         ST    R9,SAVER9A          SAVE THE PROGRAM DATA\n*        CLI   NOTITOP+1,0\n*        BNE   KEEPR9A\n         TM    FLAG2,X'20'\n         BO    NOTLPA00\n         TM    FLAG2,X'01'\n         BO    MARKLPA\nNOTLPA00 DS    0H\n         MVC   LINE,LINE-1\n         MVC   LINE(23),=C'Module has been LOADED.'\n         MVC   LINE+24(13),=C'CDE Address: '\n         HEX   LINE+37,4,CDEADDR\n         TM    FLAG2,X'20'\n         BZ    MARKCDEA\n         MVC   LINE+47(10),=C'Alias of: '\n         MVC   LINE+57(8),MAJNAME\nMARKCDEA DS    0H\n         STM   R14,R1,SAVE14T1\n         APUT  LINE,75\n         LM    R14,R1,SAVE14T1\n         B     MOREDSPL\nMARKLPA  DS    0H\n         MVC   LINE,LINE-1\n         MVC   LINE(23),=C'Module is from LPA.    '\n         MVC   LINE+21(14),=C'LPDE Address: '\n         HEX   LINE+35,4,LPDEADDR\n         TM    FLAG2,X'02'\n         BZ    MARKLPAA\n         MVC   LINE+46(10),=C'Alias of: '\n         MVC   LINE+56(8),MAJNAME\nMARKLPAA DS    0H\n         STM   R14,R1,SAVE14T1\n         APUT  LINE,65\n         LM    R14,R1,SAVE14T1\nMOREDSPL DS    0H\n         MVC   LINE,LINE-1\n         HEX   LINE+30,4,SAVER3A\n         MVC   LINE(30),=C'Length of loaded module Hex:  '\n         L     R3,SAVER3A\n         CVD   R3,CVDWORK          Convert to Decimal\n         MVC   LINE+42(9),=C'Decimal: '\n         MVC   LINE+52(10),MASK10\n         ED    LINE+52(10),CVDWORK+3\n         STM   R14,R1,SAVE14T1\n         APUT  LINE,75\n         LM    R14,R1,SAVE14T1\n         MVC   LINE,LINE-1\n         HEX   LINE+30,4,LOADSMAL\n         MVC   LINE(30),=C'Length after entry address :  '\n         L     R3,LOADSMAL\n         CVD   R3,CVDWORK          Convert to Decimal\n         MVC   LINE+42(9),=C'Decimal: '\n         MVC   LINE+52(10),MASK10\n         ED    LINE+52(10),CVDWORK+3\n         STM   R14,R1,SAVE14T1\n         APUT  LINE,75\n         LM    R14,R1,SAVE14T1\n         MVC   LINE,LINE-1\n         HEX   LINE+30,4,STORDIFF\n         MVC   LINE(30),=C'Displacement of entry point:  '\n         L     R3,STORDIFF\n         CVD   R3,CVDWORK          Convert to Decimal\n         MVC   LINE+42(9),=C'Decimal: '\n         MVC   LINE+52(10),MASK10\n         ED    LINE+52(10),CVDWORK+3\n         STM   R14,R1,SAVE14T1\n         APUT  LINE,75\n         LM    R14,R1,SAVE14T1\n         MVC   LINE,LINE-1             Test diagnostics display.\n         HEX   LINE,4,SAVER9A\n         HEX   LINE+10,4,SAVER9B\n         HEX   LINE+20,4,SAVER9C\n         HEX   LINE+30,4,SAVER9D\n         HEX   LINE+40,4,SAVER9E\n         HEX   LINE+50,4,LOADSMAL\n         HEX   LINE+60,4,LOADWHOL\n         HEX   LINE+70,4,STORDIFF\n         HEX   LINE+80,4,ADRSTART\n         HEX   LINE+90,4,SAVER1B\n         HEX   LINE+100,1,FLAG1\n*        STM   R14,R1,SAVE14T1\n*        APUT  LINE,105\n*        LM    R14,R1,SAVE14T1\nKEEPR9A  DS    0H\n*\n         CLI   NOHEXOP+1,0                                   *DEC-2016*\n         BNE   JUST1                                         *DEC-2016*\n         MVC   LINE,LINE-1         Print a line of dashes\n         MVC   LINE(65),DASHES\n         APUT  LINE,65\nNODASH1  DS    0H                                            *DEC-2016*\n* ------------------------------------------------------------------- *\n*              PREPARE FOR HEX DISPLAY OF ALL LINES                   *\n* ------------------------------------------------------------------- *\nENTRYPRM DS    0H                  Process the ENTRY keyword here.\n         CLI   ENTRYOP+1,0         Entry keyword not there?\n         BE    BIGMOD              Go treat whole module.\n         L     R9,SAVER9B          Data address at entry point\n         L     R1,LOADSMAL         Load reduced size, e.p. to end.\n         B     SMALLMOD            Don't display the whole module.\nBIGMOD   DS    0H\n         L     R9,SAVER9C          Address of beginning of the data.\n         L     R1,LOADWHOL         Load the full size of the module.\n*              IF THE MODULE SIZE < 100 THEN DON'T SHOW 100\nSMALLMOD DS    0H\n         LR    R10,R1              Save length for calculation\n         ST    R1,SAVER1L          Store it for printing\nLATENTRY DS    0H\n         ST    R10,SAVER10A        Store it for safety\n* ------------------------------------------------------------------- *\n*            Calculate how many lines we will need to print.          *\n* ------------------------------------------------------------------- *\n         SRDA  R10,32(0)           Set up divide\n         D     R10,=F'100'         Divide by 100 decimal\n         LTR   R10,R10             Even division?\n         BZ    NOREMNDR            Yes. Don't compensate for remainder\n         LA    R11,1(,R11)         Add 1 to compensate for remainder\n*                                    and print a partial line.\nNOREMNDR DS    0H\n         XR    R8,R8               Initialize byte counter\n* ------------------------------------------------------------------- *\n*                     Print All The Lines                             *\n* ------------------------------------------------------------------- *\nPRNTLOOP DS    0H\n*   R1 has quantity SAVER1L in it here.\n         C     R1,=F'100'          Less than 100?\n         BNH   *+8                 Yes, skip limit to 100.\n         L     R1,=F'100'          No. Just print 100 at a time\n         BCTR  R1,0                One less for execute.\n         STM   R14,R1,SAVE14T1     Protect registers used by APUT\n         MVC   LINE,LINE-1\n         ST    R1,SAVER1A\n         APUT  LINE,4,SAVER1A\n         LM    R14,R1,SAVE14T1\n*   R1 has quantity SAVER1P in it here.\n         ST    R1,SAVER1P          Save the length - 1\n         STM   R14,R1,SAVE14T1     Protect registers used by PRTXLINE\n         L     R1,SAVER1P          Save the length - 1\n         BAL   R7,PRTXLINE         Print these 100 bytes in hex\n         LM    R14,R1,SAVE14T1\n*   DISPLAY LATER LINES\n         LA    R9,100(,R9)         Skip 100 bytes from current\n         L     R1,SAVER1L          Reload remaining data length\n         S     R1,=F'100'          Subtract 100\n         BNP   JUST1               Finished? Stop the process.\n         ST    R1,SAVER1L          Decremented length\n         BCT   R11,PRNTLOOP\n* ------------------------------------------------------------------- *\n*                      END OF HEX DISPLAY                             *\n* ------------------------------------------------------------------- *\nJUST1    DS    0H                  CHECK FOR INITIAL INSTRUCTIONS\n         CLI   NOHEXOP+1,0\n         BE    NODASH01\n         MVC   LINE,LINE-1\n         MVC   LINE(65),DASHES\n         APUT  LINE,65\nNODASH01 DS    0H\n         TM    FLAG2,X'01'\n         BO    WASLPA\n         DELETE EPLOC=MEMBER\nWASLPA   DS    0H\n*\nEXIT0    SR    R15,R15             SET CC = 0.\n         ST    R15,SAVER15A        SAVE THE RETURN CODE\nEXIT     L     R13,SAVE+4          POINT TO CALLER'S SAVE AREA.\n         LM    R0,R12,20(R13)      RELOAD MOST OF CALLER'S REGISTERS.\n         L     R14,12(,R13)        RELOAD RETURN ADDRESS.\n         BR    R14                 RETURN TO CALLER.\nEXIT12   LA    R15,12\n         ST    R15,SAVER15A        SAVE THE RETURN CODE\n         B     EXIT\n* ------------------------------------------------------------------- *\n*                     HEX DISPLAY SUBROUTINE                          *\n* ------------------------------------------------------------------- *\nPRTXLINE DS    0H                  4-line hex printout routine.\n         ST    R7,SAVER7A\n         ST    R8,SAVER8A\n         CVD   R8,CVDWORK          The line number of bytes so far\n         MVC   LINE,LINE-1\n         L     R1,SAVER1P          Length of line to print\n         B     *+10\n         MVC   LINE(0),0(R9)       MOVE DATA TO PRINT LINE\n         EX    R1,*-6\n         L     R1,SAVER1P          RELOAD THE LENGTH\n         B     *+10\nTRHEXL0  TR    LINE(*-*),TRTBL0    Make the line of printables\n         EX    R1,TRHEXL0\n         MVC   LINE+100(10),MASK10     Print counter after 1st line\n         MVC   LINE+110(2),=C'00'      Show it in hundreds\n         ED    LINE+100(10),CVDWORK+3  Plug the number in\n         APUT  LINE,112            Print the line of printables\n         MVC   LINE,LINE-1\n         L     R1,SAVER1P          Reload the length of the line\n         B     *+10\n         MVC   LINE(0),0(R9)       MOVE DATA TO PRINT LINE\n         EX    R1,*-6\n         B     *+10\nTRHEXL1  TR    LINE(*-*),TRTBL1    HIGH NIBBLE IN HEX DISPLAY\n         EX    R1,TRHEXL1\n         APUT  LINE,100\n         MVC   LINE,LINE-1\n         L     R1,SAVER1P          Reload the length of the line\n         B     *+10\n         MVC   LINE(0),0(R9)       MOVE DATA TO PRINT LINE\n         EX    R1,*-6\n         B     *+10\nTRHEXL2  TR    LINE(*-*),TRTBL2    LOW NIBBLE IN HEX DISPLAY\n         EX    R1,TRHEXL2\n         APUT  LINE,100\n         MVC   LINE,LINE-1\n         L     R1,SAVER1P          Reload the length of the line\n*                                  since APUT destroys R1.\n         B     *+10\n         MVC   LINE(0),RULERL      Print the ruler line\n         EX    R1,*-6\n         APUT  LINE,100\n         LA    R8,1(,R8)           Increment counter (x 100)\n         L     R7,SAVER7A\n         BR    R7\n* ------------------------------------------------------------------- *\nHELPMSG  DS    0H\n         STM   R14,R1,SAVE14T1\n         APUT  '-------------------------------------------------',49\n         APUT  'Correct usage of LISTMODD is as follows:  ',42\n         APUT  '   ',3\n         APUT  '  LISTMODD modname (optional parameters)  ',42\n         APUT  '   ',3\n         APUT  'Parameters are:  NOHEX and ENTRY      ',39\n         APUT  '   ',3\n         APUT  'Required is the name of the module to load.',43\n         APUT  '   ',3\n         APUT  'Leaving out parameters produces the hex display',47\n         APUT  '  from the beginning of the module.  ENTRY starts',49\n         APUT  '  the display from the entry point of the module.',49\n         APUT  '   ',3\n         APUT  '  NOHEX prints the header information only.      ',49\n         APUT  '-------------------------------------------------',49\n         STM   R14,R1,SAVE14T1\n         B     EXIT\n* ------------------------------------------------------------------- *\n* ------------------------------------------------------------------- *\n         TITLE '- Static data area.'\n* ------------------------------------------------------------------- *\nSAVE     DS    9D                  SAVE AREA.\nCVDWORK  DS    D                   CVD work area\nLOADLEN  DS    F\nLPAREGS  DS    2F\nLOADWHOL DS    F                   Entire size of load module\nLOADSMAL DS    F                   Distance from entry point to end.\nSTORDIFF DS    F                   Displacement of entry point.\nENTRYOP  DS    F\nNOHEXOP  DS    F\nNOTITOP  DS    F\nHEXOP    DS    F\nTITOP    DS    F\nSAVE14T1 DS    4F\nADRENTRY DS    F\nADRSTART DS    F\nLPDEADDR DS    F\nCDEADDR  DS    F\nSAVER1A  DS    F\nSAVER1B  DS    F\nSAVER1L  DS    F                   HOLDS DECREMENTED LENGTH OF MODULE\nSAVER1P  DS    F                   HOLDS LENGTH OF PRINTED LINE - 1\nSAVER3A  DS    F\nSAVER3B  DS    F\nSAVER3C  DS    F\nSAVER7A  DS    F\nSAVER8A  DS    F\nSAVER9A  DS    F\nSAVER9B  DS    F\nSAVER9C  DS    F\nSAVER9D  DS    F\nSAVER9E  DS    F\nSAVER10A DS    F\nSAVER15A DS    F\nMAJNAME  DS    CL8\nFLAG1    DS    X                   X'01' if entry point at beginning\nFLAG2    DS    X                   X'01' if LPA module\nMASK10   DC    XL10'40202020202020202120'\nDASHES   DS    0CL65\nDASHEZ   DC    65C'-'\n         SPACE 1\n*IOPL     DS    0A                 IOPL FOR PUTLINE.\n*IOPLUPT  DS    A                  POINTER TO USER PROFILE TABLE.\n*IOPLECT  DS    A                  POINTER TO ENVIRONMENT CONTROL TAB.\n*IOPLECB  DC    A(ECB)             POINTER TO ECB.\n*IOPLIOPB DC    A(PTPB)            POINTER TO PTPB.\n         SPACE 1\n         SPACE 1\n*PTPB     PUTLINE MF=L PUTLINE PARM. BLOCK.\n         SPACE 1\nMVMEM    MVC   MEMBER(*-*),0(R15)  *** EXECUTED ***\n*VHEAD   MVC   0(*-*,R5),4(R9)     *** EXECUTED ***\nMVHEAD   MVC   LINE(*-*),4(R9)     *** EXECUTED ***\nTRT      TRT   0(*-*,R7),TRTAB     *** EXECUTED ***\nBLANKS   DC    CL65' '\nFULLZERO DC    F'0'\nRULERL   DC    C'0----+----1----+----2----+----3----+----4----+----5---x\n               -+----6----+----7----+----8----+----9----+----'\n         SPACE 1\nTRTAB    DC    256X'01'            TRT TABLE TO DETECT ...\n         ORG   TRTAB+C'a'          ... NON-DISPLAY CHARACTERS.\n         DC    9X'00'\n         ORG   TRTAB+C'j'\n         DC    9X'00'\n         ORG   TRTAB+C's'\n         DC    8X'00'\n         ORG   TRTAB+C'A'\n         DC    9X'00'\n         ORG   TRTAB+C'J'\n         DC    9X'00'\n         ORG   TRTAB+C'S'\n         DC    8X'00'\n         ORG   TRTAB+C'0'\n         DC    10X'00'\n         ORG   TRTAB+X'4A'\n         DC    7X'00'\n         ORG   TRTAB+C'!'\n         DC    8X'00'\n         ORG   TRTAB+X'6A'\n         DC    6X'00'\n         ORG   TRTAB+C':'\n         DC    6X'00'\n         ORG   TRTAB+X'AF'\n         DC    18X'00'\n         ORG   TRTAB+C'\\'\n         DC    2X'00'\n         ORG   TRTAB+C' '\n         DC    X'00'\n         ORG   ,\n         SPACE 1\n         LTORG\nWORKFULL DS    0F\n         DC    H'0'\nWORKHALF DC    H'0'\n         TITLE '- MESSAGES.'\nMSG001   DC    C'Load module has non-standard header.'\nMSG001L  EQU   *-MSG001\n         SPACE 1\nMSG002   DC    C'Cannot load '\nMEMBER   DC    CL8' '              NAME OF MEMBER TO BE EXAMINED.\n         DC    C' from any library in normal search path.'\nMSG002L  EQU   *-MSG002\nMSG003   DC    C'Beginning of CDE chain reached without a name match.'\nMSG003L  EQU   *-MSG003\n         TITLE '- Parse parameters.'\nPPL      DS    0A                  PARSE PARM LIST.\nPPLUPT   DS    A                   POINT TO UPT.\nPPLECT   DS    A                   POINT TO ECT.\nPPLECB   DC    A(ECB)              POINT TO ECB.\nPPLPCL   DC    A(PCL)              POINT TO PCL.\nPPLANS   DC    A(ANS)              POINT TO ANSWER PLACE.\nPPLCBUF  DS    A                   POINT TO COMMAND BUFFER.\nPPLWA    DC    A(0)                NO WORK AREA.\n         SPACE 1\nANS      DS    A                   ANSWER PLACE.\nECB      DC    A(0)                COMMAND PROCESSOR ECB.\nPCL      IKJPARM DSECT=PDL         PARSE PCL CSECT.\nPDLLM    IKJIDENT 'Load Module',FIRST=ALPHA,OTHER=ALPHANUM,            +\n               PROMPT='Load Module+',MAXLNTH=8,                        +\n               HELP=('Name of load module to be listed.')\nENTRYKW  IKJKEYWD ,\n         IKJNAME 'ENTRY'\nNOHEXKW  IKJKEYWD ,\n         IKJNAME 'NOHEX'\nHEXKW    IKJKEYWD ,\n         IKJNAME 'HEX'\n*NOTITKW IKJKEYWD ,\n*        IKJNAME 'NOTITLE'\n         IKJENDP\nHEX      DS    0H\n         ST    R4,SAVER4A\n         MVC   1(1,R15),0(R1)        Move byte\n         UNPK  0(3,R15),1(2,R15)     Unpack\n         TR    0(2,R15),HEXTAB-240\n         LA    R15,2(,R15)           Increment output pointer\n         LA    R1,1(,R1)             Increment input pointer\n         BCT   R0,HEX                Decrement length, then loop\n         MVI   0(R15),C' '           Blank the trailing byte\n         L     R4,SAVER4A\n         BR    R4                    Return to caller\nHEXTAB   DC    C'0123456789ABCDEF'   Translate table\nSAVER4A  DS    F\nHEXSAVE  DS    3F                    Register save for HEX macro\n         DS    CL1\nLINE     DS    CL200\nTRTBL0   DS    0D\n         DC    XL16'40404040404040404040404040404040'\n         DC    XL16'40404040404040404040404040404040'\n         DC    XL16'40404040404040404040404040404040'\n         DC    XL16'40404040404040404040404040404040'\n         DC    XL16'404040404040404040404A4B4C4D4E4F'\n         DC    XL16'504040404040404040405A5B5C5D5E5F'\n         DC    XL16'606140404040404040406A6B6C6D6E6F'\n         DC    XL16'404040404040404040407A7B7C7D7E7F'\n         DC    XL16'40818283848586878889404040404040'\n         DC    XL16'40919293949596979899404040404040'\n         DC    XL16'4040A2A3A4A5A6A7A8A9404040404040'\n         DC    XL16'40404040404040404040404040404040'\n         DC    XL16'C0C1C2C3C4C5C6C7C8C9404040404040'\n         DC    XL16'D0D1D2D3D4D5D6D7D8D9404040404040'\n         DC    XL16'E040E2E3E4E5E6E7E8E9404040404040'\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9404040404040'\nTRTBL1   DS    0D\n         DC    XL16'F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0'\n         DC    XL16'F1F1F1F1F1F1F1F1F1F1F1F1F1F1F1F1'\n         DC    XL16'F2F2F2F2F2F2F2F2F2F2F2F2F2F2F2F2'\n         DC    XL16'F3F3F3F3F3F3F3F3F3F3F3F3F3F3F3F3'\n         DC    XL16'F4F4F4F4F4F4F4F4F4F4F4F4F4F4F4F4'\n         DC    XL16'F5F5F5F5F5F5F5F5F5F5F5F5F5F5F5F5'\n         DC    XL16'F6F6F6F6F6F6F6F6F6F6F6F6F6F6F6F6'\n         DC    XL16'F7F7F7F7F7F7F7F7F7F7F7F7F7F7F7F7'\n         DC    XL16'F8F8F8F8F8F8F8F8F8F8F8F8F8F8F8F8'\n         DC    XL16'F9F9F9F9F9F9F9F9F9F9F9F9F9F9F9F9'\n         DC    XL16'C1C1C1C1C1C1C1C1C1C1C1C1C1C1C1C1'\n         DC    XL16'C2C2C2C2C2C2C2C2C2C2C2C2C2C2C2C2'\n         DC    XL16'C3C3C3C3C3C3C3C3C3C3C3C3C3C3C3C3'\n         DC    XL16'C4C4C4C4C4C4C4C4C4C4C4C4C4C4C4C4'\n         DC    XL16'C5C5C5C5C5C5C5C5C5C5C5C5C5C5C5C5'\n         DC    XL16'C6C6C6C6C6C6C6C6C6C6C6C6C6C6C6C6'\nTRTBL2   DS    0D\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\n         TITLE '- Mapping DSECTs.'\n         PRINT GEN\n         IKJCPPL                   MAP COMMAND PROCESSOR PARM LIST.\n         CVT   DSECT=YES\n         IKJTCB                                              *JUL-2014*\n         IHACDE                                              *JUL-2014*\n         IHAXTLST                                            *JUL-2014*\n         END   LISTMODD\nEPUTL    TITLE 'PUTLINE FOR FEWER THAN 83 ARGUMENTS IN THE KEY OF C MAJ&\n               OR'\nEPUTL    CSECT                                              *HMD 10/85*\n         LCLB  &XA                                          *HMD 10/85*\n&XA      SETB  1                  SET TO ZERO ON NON/XA     *HMD 10/85*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*  MODULE NAME  . . . . EPUTL\n*\n*  ALIASES  . . . . . . NONE\n*\n*  DATE WRITTEN . . . . 06/85\n*  UPDATED      . . . . 04/88                                  HD APR88\n*  CLEANED A BIT  . . . 08/17\n*\n*  AUTHOR . . . . . . . JIM ELSWORTH\n*  UPDATER  . . . . . . HOWARD M. DEAN                         HD APR88\n*\n*  ENVIRONMENT  . . . . TSO COMMAND PROCESSOR\n*\n*  PURPOSE:\n*    ALLOW AN EASY INTERFACE TO PUTLINE ROUTINE\n*\n*\n*  DESCRIPTION:\n*    BUILDS PUTLINE PARAMETER LIST BASED ON INPUT ARGUMENTS.\n*    ISSUES SINGLE LINE PUTLINE.\n*\n*\n*  ATTRIBUTES:\n*    REENTRANT\n*\n*  FEATURES:\n*    WILL RUN UNDER BATCH TMP SINCE PUTLINE USED INSTEAD OF TPUT.\n*\n*  CALLED MODULES:\n*    PUTLINE\n*\n*  ASSUMPTIONS:\n*    CALLED BY A TSO-CP THAT IS OBSERVING STANDARD LINKAGE\n*\n*  ABENDS:\n*    POSSIBLE 0CX IF BAD ARGUMENTS\n*\n*  CAVEATS:\n*    UNPREDICTABLE RESULTS IF FIRST PROGRAM RUNNING UNDER THIS TCB\n*    DID NOT SAVE (14,12) BEFORE R1 WAS MODIFIED.\n*\n*\n*  INPUT ARGUMENTS:\n*    1)  R1 : ADDRESS OF MESSAGE TEXT\n*    2)  R0 : LENGTH OF MESSAGE TEXT\n*    3) R13 : STANDARD OS SAVE AREA\n*    4) R14 : RETURN ADDRESS\n*    5) R15 : ENTRY ADDRESS\n*\n*               ( CONTINUED ... )\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*\n*  OUTPUT ARGUMENT: RETURN CODE FROM PUTLINE OR\n*\nRCBA     EQU   100                 BAD MESSAGE ADDRESS\nRCBL     EQU   104                 MESSAGE LENGTH <1 OR >MAXMSG\n*\nMAXMSG   EQU   255                 MAXIMUM MESSAGE LENGTH\n*\n*\n*  REGISTERS USED:\n*\nR0       EQU   0                   MESSAGE LENGTH AT ENTRY\nR1       EQU   1                   MESSAGE ADDRESS AT ENTRY\nR2       EQU   2                   WORK\nR3       EQU   3                   WORK\nRMA      EQU   4                   @MESSAGE TEXT\nRML      EQU   5                   MESSAGE LENGTH\nRUPT     EQU   6                   @UPT (USER PROFILE TABLE)\nRECT     EQU   7                   @ECT\nR12      EQU   12                  CSECT BASE\nR13      EQU   13                  @SAVE AREA AND DYNAMIC WORK AREA\nR14      EQU   14                  WORK/LINKAGE\nR15      EQU   15                  WORK/LINKAGE\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         EJECT\n         IKJCPPL\n         EJECT\n         IKJTCB   LIST=YES                                  *HMD 10/85*\n         EJECT                                              *HMD 10/85*\n         CVT      DSECT=YES,LIST=YES                        *HMD 10/85*\n         EJECT\n         IHAPSA   LIST=YES                                     HD APR88\n         EJECT                                                 HD APR88\nPUTLDS   DSECT\n         DS    18F                      OS SAVE AREA\nPUTAAA   EQU   *\nPUTECB   DS    F                        ECB\nPUTIOPL  DS    4F                       IOPLADS\nPUTBLOK  PUTLINE MF=L\nPUTLEN   DS    H                        LENGTH\nPUTZZZ   DS    H                        RESERVED\nPUTMSG   DS    (MAXMSG)C                MESSAGE TEXT AREA\n         DS    0D\nPUTSIZE  EQU   *-PUTLDS                 SIZE OF PUTLINE PARMS\n         EJECT\n***********************************************************************\n*  SET UP LINKAGE\n***********************************************************************\n         SPACE 1\nEPUTL    CSECT\n         AIF  (NOT &XA).X001                                *HMD 10/85*\nEPUTL    AMODE 31\n.X001    ANOP                                               *HMD 10/85*\n         STM   R14,R12,12(R13)    SAVE CALLERS REGS\n         LR    R12,R15            COPY EPA\n         USING EPUTL,R12          ADDRESSABILITY\n         AIF   (NOT &XA).X002                               *HMD 10/85*\n         GETMAIN RU,              LV=LENGTH                            &\n               LV=PUTSIZE,        STANDARD OS SA PLUS ANY EXTRA        &\n               LOC=RES,SP=0       RELATIVE TO 16MB LINE\n         AGO   .X003                                        *HMD 10/85*\n.X002    ANOP                                               *HMD 10/85*\n         GETMAIN RU,              LV=LENGTH                            &\n               LV=PUTSIZE         STANDARD OS SA PLUS ANY EXTRA\n.X003    ANOP                                               *HMD 10/85*\n         ST    R1,8(,R13)         OUR SAVE AREA POINTER\n         ST    R13,4(,R1)         POINTER TO CALLER'S SAVE AREA\n         LR    R13,R1             @OUR SAVE AREA\n         USING PUTLDS,R13         MAP SA AND WORK AREA\n         L     R14,4(,R13)        POINT TO CALLER'S RSA\n         LM    R0,R1,20(R14)      RESTORE REGS CHANGED BY GETMAIN\n         SPACE 2\n***********************************************************************\n*  UNLOAD ARGUMENTS AND VALIDATE WHERE POSSIBLE\n***********************************************************************\n         SPACE 1\n         LA    R15,RCBA                 RC IF BAD ADDRESS\n         LTR   RMA,R1                   MESSAGE ADDRESS\n         BNP   RETURN                   GOOD ASSUMPTION\n         LA    R15,RCBL                 RC IF BAD LENGTH\n         LTR   RML,R0                   POSITIVE?\n         BNP   RETURN                   -NO\n         C     RML,=A(MAXMSG)           MORE THAN MAX?\n         BH    RETURN                   -YES\n         SPACE 2\n***********************************************************************\n*  BUILD PARAMETER LIST\n***********************************************************************\n         SPACE 1\n         LA    R15,4(,RML)              MESSAGE LENGTH\n         STH   R15,PUTLEN               PLUS HEADER\n         XC    PUTZZZ,PUTZZZ            CLEAR 2ND HWORD OF RDW\n         BCTR  RML,0                    REDUCE FOR MOVE\n         EX    RML,PUTMOVE\n         EJECT\n***********************************************************************\n*  DIG UP ADDRESS OF UPT AND ECT\n***********************************************************************\n         SPACE 1\n         L     R2,PSATOLD-PSA           @TCB                   HD APR88\n         L     R2,TCBFSA-TCB(,R2)       @1ST PROBLEM PGM SAVE AREA\n         L     R2,24(,R2)               REG1 THAT WAS PASSED TO CP\n         USING CPPL,R2                  MAP CPPL\n         L     RUPT,CPPLUPT             @UPT\n         L     RECT,CPPLECT             @ECT\n         SPACE 2\n***********************************************************************\n*  ISSUE PUTLINE CALL\n***********************************************************************\n         SPACE 1\n         XC    PUTECB,PUTECB            CLEAR ECB\n         XC    PUTBLOK(12),PUTBLOK      CLEAR PARM BLOCK       HD APR88\n         PUTLINE PARM=PUTBLOK,          PARAMETER BLOCK                &\n               UPT=(RUPT),              @UPT                           &\n               ECT=(RECT),              @ECT                           &\n               ECB=PUTECB,              @ECB                           &\n               OUTPUT=(PUTLEN,TERM,SINGLE,DATA),                       &\n               MF=(E,PUTIOPL)\n         EJECT\n***********************************************************************\n*  RETURN TO CALLER\n***********************************************************************\n         SPACE 1\nRETURN   EQU   *\n         LR    R2,R13                   @OUR SAVE AREA\n         LR    R3,R15                   SAVE RETURN CODE\n         L     R13,4(,R13)              @CALLER'S SAVE AREA\n         FREEMAIN RU,LV=PUTSIZE,A=(R2),SP=0\n         LR    R15,R3                   RESTORE RC\n         RETURN (14,12),RC=(15)         RESTORE CALLER'S REGS\n         SPACE 5\n***********************************************************************\n*  CONSTANTS AND NON-REENTRANT WORK AREAS\n***********************************************************************\n         SPACE 1\nPUTMOVE  MVC   PUTMSG(*-*),0(RMA)       MOVE MESSAGE TO BUFFER\n         SPACE 2\n         LTORG\n         SPACE 2\n         END   EPUTL\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TSOB": {"ttr": 2051, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x00\\x992/\\x01\\x08'\\x7f\\x13\\x10\\x00\\x1a\\x00\\x1a\\x00\\x00\\xd4\\xe9\\xc5\\xd3\\xc4\\xc5\\xd5@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-11-18T00:00:00", "modifydate": "2008-10-03T13:10:00", "lines": 26, "newlines": 26, "modlines": 0, "user": "MZELDEN"}, "text": "/* REXX */\n/*                           */\n/* AUTHOR: MARK ZELDEN       */\n/*                           */\n/* TRACE ?I */\nparse arg TSOCMD\naddress ISPEXEC \"CONTROL ERRORS RETURN\"\naddress TSO\nddnm = 'DD'||random(1,99999)    /* choose random ddname  */\njunk = msg(off)\n\"ALLOC FILE(\"||ddnm||\") UNIT(VIO) NEW TRACKS SPACE(90,90) DELETE\",\n\" REUSE LRECL(172) RECFM(F B) BLKSIZE(8944)\"\njunk = msg(on)\n/*                                    */\n/*  issue tso commnd and trap output  */\n/*                                    */\njunk=outtrap(LINE.)\nTSOCMD\njunk=outtrap('off')\n/*                                    */\n\"EXECIO\" line.0  \"DISKW\" ddnm \"(STEM LINE. FINIS\"\naddress ISPEXEC \"LMINIT DATAID(TEMP) DDNAME(\"||ddnm||\")\"\naddress ISPEXEC \"BROWSE DATAID(\"||temp\")\"\naddress ISPEXEC \"LMFREE DATAID(\"||temp\")\"\njunk = msg(off)\n\"FREE FI(\"||ddnm||\")\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TSOE": {"ttr": 2053, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x00\\x992/\\x01\\x08'\\x7f\\x13\\x10\\x00\\x1a\\x00\\x1a\\x00\\x00\\xd4\\xe9\\xc5\\xd3\\xc4\\xc5\\xd5@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-11-18T00:00:00", "modifydate": "2008-10-03T13:10:00", "lines": 26, "newlines": 26, "modlines": 0, "user": "MZELDEN"}, "text": "/* REXX */\n/*                           */\n/* AUTHOR: MARK ZELDEN       */\n/*                           */\n/* TRACE ?I */\nparse arg TSOCMD\naddress ISPEXEC \"CONTROL ERRORS RETURN\"\naddress TSO\nddnm = 'DD'||random(1,99999)    /* choose random ddname  */\njunk = msg(off)\n\"ALLOC FILE(\"||ddnm||\") UNIT(VIO) NEW TRACKS SPACE(90,90) DELETE\",\n\" REUSE LRECL(172) RECFM(F B) BLKSIZE(8944)\"\njunk = msg(on)\n/*                                    */\n/*  issue tso commnd and trap output  */\n/*                                    */\njunk=outtrap(LINE.)\nTSOCMD\njunk=outtrap('off')\n/*                                    */\n\"EXECIO\" line.0  \"DISKW\" ddnm \"(STEM LINE. FINIS\"\naddress ISPEXEC \"LMINIT DATAID(TEMP) DDNAME(\"||ddnm||\")\"\naddress ISPEXEC \"EDIT   DATAID(\"||temp\")\"\naddress ISPEXEC \"LMFREE DATAID(\"||temp\")\"\njunk = msg(off)\n\"FREE FI(\"||ddnm||\")\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TSOR": {"ttr": 2055, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x01\\x07\\x11\\x7f\\x01\\x08'\\x7f\\x13\\x10\\x00\\x1f\\x00\\x1f\\x00\\x00\\xd4\\xe9\\xc5\\xd3\\xc4\\xc5\\xd5@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "2007-04-27T00:00:00", "modifydate": "2008-10-03T13:10:00", "lines": 31, "newlines": 31, "modlines": 0, "user": "MZELDEN"}, "text": "/* REXX */\n/*                           */\n/* AUTHOR: MARK ZELDEN       */\n/*                           */\n/**************************************************/\n/* NOTE:  Use of this EXEC requires the REVIEW    */\n/*        command from CBT file 134 or 135.       */\n/**************************************************/\n/* REVIEW command output.  This has an advantage  */\n/* over TSOE/TSOB/TSOV in that it works under     */\n/* native TSO (TSO READY) without ISPF.           */\n/**************************************************/\n/* TRACE ?I */\nparse arg TSOCMD\naddress TSO\nddnm = 'DD'||random(1,99999)    /* choose random ddname  */\njunk = msg(off)\n\"ALLOC FILE(\"||ddnm||\") UNIT(SYSALLDA) NEW TRACKS SPACE(9,9) DELETE\",\n\" REUSE LRECL(172) RECFM(F B) BLKSIZE(8944)\"\njunk = msg(on)\n/*                                    */\n/*  issue tso commnd and trap output  */\n/*                                    */\njunk=outtrap(LINE.)\nTSOCMD\njunk=outtrap('off')\n/*                                    */\n\"EXECIO\" line.0  \"DISKW\" ddnm \"(STEM LINE. FINIS\"\naddress TSO     \"REVIEW       \"||ddnm||\"    FILE\"\njunk = msg(off)\n\"FREE FI(\"||ddnm||\")\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TSOV": {"ttr": 2057, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x01\\x07\\x11\\x7f\\x01\\x08'\\x7f\\x13\\x10\\x00\\x1f\\x00\\x1f\\x00\\x00\\xd4\\xe9\\xc5\\xd3\\xc4\\xc5\\xd5@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "2007-04-27T00:00:00", "modifydate": "2008-10-03T13:10:00", "lines": 31, "newlines": 31, "modlines": 0, "user": "MZELDEN"}, "text": "/* REXX */\n/*                           */\n/* AUTHOR: MARK ZELDEN       */\n/*                           */\n/****************************************************/\n/* There is really no advantage to using TSOV over  */\n/* TSOE since a temporary data set is used, but     */\n/* to complete the TSO* set of EXECs - here it is.  */\n/****************************************************/\n/* TRACE ?I */\nparse arg TSOCMD\naddress ISPEXEC \"CONTROL ERRORS RETURN\"\naddress TSO\nddnm = 'DD'||random(1,99999)    /* choose random ddname  */\njunk = msg(off)\n\"ALLOC FILE(\"||ddnm||\") UNIT(VIO) NEW TRACKS SPACE(90,90) DELETE\",\n\" REUSE LRECL(172) RECFM(F B) BLKSIZE(8944)\"\njunk = msg(on)\n/*                                    */\n/*  issue tso commnd and trap output  */\n/*                                    */\njunk=outtrap(LINE.)\nTSOCMD\njunk=outtrap('off')\n/*                                    */\n\"EXECIO\" line.0  \"DISKW\" ddnm \"(STEM LINE. FINIS\"\naddress ISPEXEC \"LMINIT DATAID(TEMP) DDNAME(\"||ddnm||\")\"\naddress ISPEXEC \"VIEW   DATAID(\"||temp\")\"\naddress ISPEXEC \"LMFREE DATAID(\"||temp\")\"\njunk = msg(off)\n\"FREE FI(\"||ddnm||\")\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT994/FILE994.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT994", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}