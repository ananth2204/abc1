{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220011523000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 823004, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 255, "INMBLKSZ": 8000, "INMRECFM": "VB", "INMDIR": 14, "INMDSNAM": "CBT.V500.FILE221.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 823004, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 823004, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE221.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 8000, "DS1LRECL": 255, "DS1RECFM": "VB", "DS1KEYL": 0, "DS1OPTCD": 32, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x0e\\n'", "DS1TRBAL": "b'^\\xf6'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "b'P\\xf4\\xfd\\xd0\\x00\\x00\\x01\\x96\\x00\\x00\\x01\\x96\\x00\\x0e\\x00\\x0f'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 3593, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04[\\x00X\\x01\\x153\\x7f\\x01\\x153\\x7f\\x13Y\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf9\\xf1@@@'", "ispf": {"version": "04.91", "flags": 0, "createdate": "2015-12-03T00:00:00", "modifydate": "2015-12-03T13:59:58", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-491"}, "text": "REGULAR CBT TAPE - VERSION 491    FILE:  221\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT491.FILE221\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      VB    255   8000    PO\n\n   PDS117I 50 MEMBERS COUNTED; CUMULATIVE SIZE IS 9,949 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   12/03/15    13:59:58    UTC-5:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$$DOC01": {"ttr": 526, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x02\\x00\\x08\\x00\\x94'\\x9f\\x00\\x94(\\x0f\\x11Q\\x00\\x12\\x00\\x08\\x00\\x00\\xe2\\xc2\\xc7\\xc3\\xe2\\xc3@@@@\"", "ispf": {"version": "01.02", "flags": 0, "createdate": "1994-10-06T00:00:00", "modifydate": "1994-10-07T11:51:08", "lines": 18, "newlines": 8, "modlines": 0, "user": "SBGCSC"}, "text": "This file (221) goes together with File 220 from Lee Conyers.\n\nThis file (221) contains REXX execs to perform many EDP auditing\n\"snooping\" functions.  This material will be useful for systems\nprogrammers as well.  The material was tested on an MVS/XA 2.2.3\nsystem.  Some of it also runs on MVS/ESA 4.3, but not all of it.\n\nIf you can fix any of this material for higher versions of the MVS\noperating system, please submit your material to Sam Golob, at his\naddress as listed on File 001 of this tape.\n\n      Lee Conyers\n      U.S. Department of Transportation\n      700 4th Street SW\n      Room 7404, M-35\n      Washington, DC  20590\n      (202) 366-1126\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$$DOC02": {"ttr": 3333, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x03\\x01\\x14\\x04\\x9f\\x01\\x14\\x05\\x0f\\x00\\x18\\x00&\\x00%\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2014-02-18T00:00:00", "modifydate": "2014-02-19T00:18:03", "lines": 38, "newlines": 37, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject:  RE: CBT contribution\nFrom:     \"Cieri, Anthony\" <ACieri@seic.com>\nDate:     2/18/2014 4:39 PM\nTo:       Sam Golob <sbgolob@cbttape.org>\n\nHi Sam,\n\nSorry that it took a while, but I have finally documented my\nupdates and changes to CBT file221. The execs in file 221 work in\nconjunction with programs and SAS code in file 220. This was a\nnice little history lesson in the evolution from MVS XA 2.2 to\nz/OS V1.13.\n\nI have added two members ($$MODS and $$WORKDS) to the PDS that,\nhopefully describe the change that I made in order to get these\nexecs to run under z/OS 1.13. I started by updating only those\nthat were necessary to run the associated SAS jobs in file 220.\nAs of this email, I have updated most , but NOT all of them.\n\nPlease find the modified PDS attached to this email in TSO IDTF\n(XMIT) format!!!\n\nPlease let me know if you have any questions or require any\nadditional documentation.\n\nThanks\nTony\n\nAnthony J.Cieri\nSEI Investments\n1 Freedom Valley Drive\nOaks, PA 19456\n\n(P) 610.676.4088\n(F) 484.676.4088\nEmail: acieri@seic.com\n       Anthony.Cieri4@gmail.com\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$MODS": {"ttr": 3331, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x14\\x00\\x02\\x01\\x14\\x02?\\x01\\x14\\x05O\\x00T\\x00e\\x00\\x0e\\x00\\x00\\xe2\\xc3\\xd5\\xe2\\xf0\\xf3\\xe3@@@'", "ispf": {"version": "01.20", "flags": 0, "createdate": "2014-01-23T00:00:00", "modifydate": "2014-02-23T00:54:02", "lines": 101, "newlines": 14, "modlines": 0, "user": "SCNS03T"}, "text": "   I have reworked most of the  IO* execs so that they run under z/OS.\nThe most recent version of z/OS that I have tested is z/OS V1.13. I have\nupdated these so that yopu can run the SAS code provided in file 220 to\nproduce the desired reports.\n\nCorrections for the following errors:\n\n\nAll IO* routines\n  \"See member $$WORKDS for more details\"\n\nIOAPFP\n Error\n  16 +++ @cvtauthl = D2X(C2D(@cvtauthl))             /* binary to hex */\n  IRX0040I Error running IOAPFP, line 16: Incorrect call to routine\n Fix\n  Add support for Dynamic APF table format.\n\nIOPCAUTH\n Error\n  Did NOT produce any output because the format of the report changed!\n Fix\n  Modify exec to find values in the correct rows.\n\nLISTAPFT\n Error\n  16 +++ @cvtauthl = D2X(C2D(@cvtauthl))             /* binary to hex */\n  IRX0040I Error running IOAPFP, line 16: Incorrect call to routine\n Fix\n  Add support for Dynamic APF table format.\n\nLISTCATS\n Error\n  Did NOT provide volser for non-Master catalogues.\n Fix\n  Corrected control block offsets for non-Master catalog volsers.\n\nLISTCONS\n Error\n  Did NOT provide UCB addr for 4-character UCBs.\n Fix\n  Added support for 4 chracter UCB addressses and console names.\n\nLISTPART\n Error\n  Did NOT provide the page dataset names. Only supported 3 character\n  device addresses.\n Fix\n  Modified the exec to correctly determine the 32 bit PART address and\n  to support 4 charater device addresses.\n\nLISTSMF\n Error\n  59 +++  capty = C2D(rdscapty)\n  IRX0040I Error running LISTSMF, line 59: Incorrect call to routine\n Fix\n  Fixed a problem with the length of the SMF selectivity Table and some\n  control bloack offsets.\n\nVSDATA\n Error\n  21 +++ @cvtauthl = D2X(C2D(@cvtauthl))             /* binary to hex */\n  IRX0040I Error running IOAPFP, line 16: Incorrect call to routine\n Fix\n  Increase numeric digits setting.\n\n\nAdditional members:\n\n\nLISTAPF2\n\n A version of the LISTAPFT command with a different output format.\n\nLISTPAR2\n\n A version of the LISTPART command that provides output in a format\n similar to the D ASM command. (Page D/S name on the right side)\n\n\nAdditional notes:\n\n  The command to clear the screen has many different names in various\nshops. If you have a \"CLEAR\" command to clear a TSO screen then you DO\nNOT need the one provided here. If you don't, there is assembly source\ncode and JCL to build one graciously provided by Sam Golob, courtesy\nof Gerhard Postpischil.  The member names are CLEAR and CLEAR$.\n\n  The LISTDASD and LISTTAPE execs will only \"find\" those devices that\nare defined on 3-character UCBs.\n  If you need support for 4-character UCB devices, I suggest using Sam\nGolob's UCBDASD and UCBTAPE commands which can be found on FILE 731.\n\n\nStill Need work:\n\n  The above listed execs are the only ones that I have updated. The was\nbasically the execs that were needed to produce the WORK datasets that\nthe SAS code if FILE 220 needs to produce reports.\n\nThe reset of the collections still needs work to function completely!!!\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$WORKDS": {"ttr": 2055, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00C\\x01\\x14\\x02O\\x01\\x14\\x04\\x9f\"S\\x00!\\x00 \\x00\\x00\\xe2\\xc3\\xd5\\xe2\\xf0\\xf3@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2014-01-24T00:00:00", "modifydate": "2014-02-18T22:53:43", "lines": 33, "newlines": 32, "modlines": 0, "user": "SCNS03"}, "text": "\nThere are (9) IOxxxx execs in CBT File221. These execs all write to\ndatasets on DASD. In their original form, the fully qualified dataset\nname was \"hard-coded\" in the exec amd they were allocated with a\ndisposition of OLD.\n\nI have modified these routines to ALLOCate the work datasets using\nthe Userid (SYSVAR(sysuid)) of the person that invokes the exec. The\nexecs currently expect these datasets to exist, so I suggest pre-\nallocating them using the DCB atributes listed below. Please choose\na suitable BLKSIZE for the DASD type(s) where they will reside!\n\n                                         Dsorg  Recfm    Lrecl\n  sysuid.APFLIST.DATA.WORK                 PS    FB        80\n  sysuid.APFPGMS.DATA.WORK                 PS    FB       200\n  sysuid.ESRS.DATA.WORK                    PS    FB       120\n  sysuid.LLTLIST.DATA.WORK                 PS    FB        80\n  sysuid.LLTPGMS.DATA.WORK                 PS    FB       200\n  sysuid.LPALIST.DATA.WORK                 PS    FB        80\n  sysuid.LPAPGMS.DATA.WORK                 PS    FB       200\n  sysuid.LPAQMODS.DATA.WORK                PS    FB       200\n  sysuid.NUCMAP.DATA.WORK                  PS    FB       120\n  sysuid.PCAUTH.DATA.WORK                  PS    VBA      125\n  sysuid.PLPAMODS.DATA.WORK                PS    FB       200\n  sysuid.SVCS.DATA.WORK                    PS    FB       200\n\nOnce the WORK datasets are allocated, the execs can be executed\nrepetitively and they will reuse the datasets.\n\nNOTE:\nBe careful NOT to allocate an insufficient LRECL. This will NOT\nlikely generate an error, however, it will cause data truncation\nand that will cause problem running the SAS programs in File 220.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "#NUCLKUP": {"ttr": 3339, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00R\\x00\\x94\\x08\\x8f\\x00\\x94\\x08\\x8f\\x10\\x00\\x00%\\x00%\\x00\\x00\\xc3\\xd6\\xd5\\xe8\\xc5\\xd9\\xe2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-03-29T00:00:00", "modifydate": "1994-03-29T10:00:52", "lines": 37, "newlines": 37, "modlines": 0, "user": "CONYERS"}, "text": "/*REXX*/\n/*****************************************************************/\n/*#NUCLKUP: REXX external procedure to scan nucleus map.         */\n/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */\n/*****************************************************************/\n/* MVS DATA AREAS:                                               */\n/*                CVT - Communications Vector Table (@'10'x)     */\n/*              NUCMP - Nucleus Map Table (16 bytes by n rows)   */\n/*****************************************************************/\nArg target\nNumeric Digits 10\n@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */\n@cvt = D2X(C2D(@cvt))                    /* binary to hex             */\n@cvtnucmp = STORAGE(D2X(X2D(@cvt)+1200),4)   /* get CVTNUCMP address  */\n@cvtnucmp = D2X(C2D(@cvtnucmp))                /* binary to hex       */\nnucmapid  = STORAGE(@cvtnucmp,8)           /* nucmap eyecatcher entry */\nnucmeot   = C2D(STORAGE(D2X(X2D(@cvtnucmp)+8),4))  /* table end addrs */\nnucmlen   = C2D(STORAGE(D2X(X2D(@cvtnucmp)+13),3)) /* nucm tbl length */\n@nucmentry= X2D(@cvtnucmp)+16          /* address of 1st nucmap entry */\nepaddr = 'FFFFFFFF'                  /* initialize with invalid value */\nIf nucmapid \\= 'NUCMAP  ' Then Do\n   Say 'Error: Nucleus map table eyecatcher not found'\n   Exit\n   End\ni = 0   /* target = 'IGCERROR' */\nDo While @nucmentry <= nucmeot                  /* loop thru storage  */\n   i = i + 1\n   epname   = STORAGE(D2X(@nucmentry),8)      /* get entry point name */\n   If epname = target Then Do\n      epaddr = C2X(STORAGE(D2X(@nucmentry+8),4))    /* get ep address */\n      epflag = STORAGE(D2X(@nucmentry+12),1)     /* get raw flag byte */\n      eplen  = C2X(STORAGE(D2X(@nucmentry+13),3))    /* get ep length */\n      Leave\n      End\n   @nucmentry = @nucmentry + 16                 /* bump to next entry */\nEnd\nReturn epaddr\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CLEAR": {"ttr": 3087, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'P\\x06\\x00\\x00\\x01\\x05\\x03O\\x01\\x14\\x05/\\x13X\\x00Y\\x00*\\x00;\\xc7\\xc5\\xd9\\xc8\\xc1\\xd9\\xc4@@@'", "ispf": {"version": "80.06", "flags": 0, "createdate": "2005-02-03T00:00:00", "modifydate": "2014-02-21T13:58:00", "lines": 89, "newlines": 42, "modlines": 59, "user": "GERHARD"}, "text": "CLR70    TITLE 'C L E A R  ***  CLEAR SCREEN ON TSO/VTAM CRT'\n         PUNCH ' ENTRY CLEAR   '                                GP05033\n         PUNCH '  ORDER CLEAR(P) '     NEAT DUMPS\n         PRINT GEN\n***********************************************************************\n*                                                                     *\n*        CLEAR - TSO CLEAR SCREEN COMMAND                             *\n*              RENT,REFR,REUS                                         *\n*                                                                     *\n*        RECOMMENDED ALIAS OF CLR3270 FOR COMPATIBILITY               *\n*                                                                     *\n*---------------------------------------------------------------------*\n*                                                                     *\n*        WRITTEN FROM A SUGGESTION IN TECHNICAL SUPPORT MAGAZINE,     *\n*        VOL. 4, NUMBER 15 (DEC. 1990), PAGE 10                       *\n*                                                                     *\n***********************************************************************\nCLEAR    CSECT\n         USING SAVE,R13\nA@0002   B     B@0002-*(,R15)\n         DC    AL1(L'N@0002)\nN@0002   DC    C'CLEAR - &SYSDATE - &SYSTIME'\n\nB@0002   STM   R14,R12,SAVE14\n         LR    R12,R15\n         LR    R11,R1\n         USING A@0002,R12\n         LA    R14,SAVEND-SAVE\n         LR    0,R14                   LOAD LENGTH\n         BAL   1,*+4                   INDICATE GETMAIN\n         SVC   10                      ISSUE GETMAIN SVC\n         ST    R14,SAVESPLN-SAVE(R1)\n         ST    R1,SAVEFWD\n         ST    R13,SAVE13-SAVE(R1)\n         LR    R13,R1\nSAVE     DSECT\nSAVESPLN DS    F\nSAVE13   DS    F\nSAVEFWD  DS    A\nSAVE14   DS    A\nSAVE15   DS    A\nSAVE0    DS    A\nSAVE1    DS    A\nSAVE2    DS    A\nSAVE3    DS    A\nSAVE4    DS    A\nSAVE5    DS    A\nSAVE6    DS    A\nSAVE7    DS    A\nSAVE8    DS    A\nSAVE9    DS    A\nSAVE10   DS    A\nSAVE11   DS    A\nSAVE12   DS    A\nSAVEFWK  EQU   *\nCLEAR    CSECT\n         YREGS\n*        GTSIZE ,            CHECK FOR A CRT\n         GTSIZE\n         CH    R0,=H'1'      MORE THAN ONE LINE ?\n         BNH   GETOUT        NO\n         STFSMODE ON,INITIAL=YES\n         BXH   R15,R15,NOTVTAM\n         STLINENO LINE=1,MODE=ON\n         STFSMODE OFF\n         B     GETOUT\nNOTVTAM  TPUT  SCRNCLR,SCRNCLRL,NOEDIT\nGETOUT   L     R0,SAVESPLN-SAVESPLN(,R13)\n         LR    R1,R13\n         L     R13,SAVE13-SAVESPLN(,R13)\n         SVC   10\n         LM    R14,R12,SAVE14-SAVESPLN(R13)\n         MVI   SAVE14-SAVESPLN(R13),X'FF'\n         XR    R15,R15\n         BR    R14\n         SPACE 1\nSCRNCLR  DC    C'C'\n         DC    X'11'                    SET BUFFER ADDRESS\n         DC    C'  '\n         DC    C' '\n         DC    X'3C'                    REPEAT TO ADDRESS\n         DC    C'  '\n         DC    C' '\n         DC    X'13'                    INSERT CURSOR\nSCRNCLRL EQU   *-SCRNCLR\n         SPACE 1\nSAVE     DSECT ,             SAVE/WORK AREA\nSAVEND   EQU   *\n         END   ,\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CLEAR$": {"ttr": 3089, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x994/\\x01\\x14\\x05/\\x13#\\x00\\x1d\\x00\\x1d\\x00\\x00\\xc9\\xc2\\xd4\\xe4\\xe2\\xc5\\xd9@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1999-12-08T00:00:00", "modifydate": "2014-02-21T13:23:00", "lines": 29, "newlines": 29, "modlines": 0, "user": "IBMUSER"}, "text": "//SBGOLOBU JOB (CCMVS),ASMLINK,\n// NOTIFY=&SYSUID,\n// CLASS=A,MSGCLASS=X,COND=(1,LT)\n//*\n//*     ASM LINKEDIT FROM SOURCE ASM\n//*\n//ASMH EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,NORLD,NOXREF)\n//SYSLIB   DD DISP=SHR,DSN=SYS1.MACLIB\n//         DD DISP=SHR,DSN=SYS1.MODGEN\n//         DD DISP=SHR,DSN=CBT.CBT487.FILE861.PDS\n//SYSIN    DD DISP=SHR,DSN=SBGOLOB.B.ASM(CLEAR)\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),DCB=BLKSIZE=3200,\n//            DSN=&&TEMP\n//*\n//LKED   EXEC  PGM=HEWL,\n//       PARM='NCAL,MAP,LIST,LET,RENT,REUS,REFR'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//SYSLMOD  DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//OBJECT   DD  DISP=(OLD,DELETE),DSN=&&TEMP\n//SYSLIN   DD  *\n INCLUDE OBJECT\n SETCODE AC(0)\n SETSSI  CB488221\n NAME    CLEAR1(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "IOAPFP": {"ttr": 528, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x13\\x00\\x00\\x00\\x94\\x08\\x8f\\x01\\x14\\x02?\\x16E\\x01\\x15\\x00\\xea\\x00\\x00\\xe2\\xc3\\xd5\\xe2\\xf0\\xf3@@@@'", "ispf": {"version": "01.19", "flags": 0, "createdate": "1994-03-29T00:00:00", "modifydate": "2014-01-23T16:45:00", "lines": 277, "newlines": 234, "modlines": 0, "user": "SCNS03"}, "text": "/*REXX*/\n/*****************************************************************/\n/*  IOAPFP: REXX program to create APF programs database.        */\n/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */\n/*****************************************************************/\n/* MVS DATA AREAS:                                               */\n/*                CVT - Communications Vector Table (@'10'x)     */\n/*             APFTAB - Undocumented in MVS DATA AREAS book.     */\n/*                                                               */\n/*                                                               */\n/*                                                               */\n/*****************************************************************/\nnumeric digits 30\ncvt = c2d(storage(10,4))                       /* point to cvt        */\n@cvt = D2X(cvt)                                /* binary to hex       */\necvt = c2d(storage(d2x(cvt+140),4))            /* point to cvtecvt    */\n@ecvt = STORAGE(D2X(X2D(@cvt)+140),4)          /* get CVTAUTHL addres */\n@ecvt = D2X(C2D(@ecvt))                        /* binary to hex       */\n@cvtauthl = STORAGE(D2X(X2D(@cvt)+484),4)      /* get CVTAUTHL addres */\n@cvtauthl = D2X(C2D(@cvtauthl))                /* binary to hex       */\n/*                                        */\nif X2D(@cvtauthl) <> c2d('7ffff001'x) then      /*dynamic list ?   @@ */\ndo          /* Static format  */\napfcount  = C2D(STORAGE(D2X(X2D(@cvtauthl)+1),1)) /* APF libraries    */\napfllen   = C2D(STORAGE(D2X(X2D(@cvtauthl)+2),1)) /* length 1st entry */\n@apfentry = X2D(@cvtauthl)+3          /* address of 1st APF entry     */\nSay 'The CVT  is located at '@cvt '('X2D(@cvt)')'\nlpadsn = 'NO'                /* SYS1.LPALIB is APF during NIP and not */\nlpares = '  '                 /* normally in the APF table.  If it is */\n                                 /* then must test for sysres volume. */\nDo i = 1 to apfcount                            /* loop thru storage  */\n   apflib.i = STORAGE(D2X(@apfentry),apfllen)   /* get the APF entry  */\n   @apfentry = @apfentry + apfllen + 1          /* bump to next entry */\n   apfllen = C2D(STORAGE(D2X(@apfentry-1),1))      /* length of next  */\n   If i = 1 Then resvol = SUBSTR(apflib.i,1,6)       /* retain resvol */\n   If SUBSTR(apflib.i,7) = 'SYS1.LPALIB' Then Do  /* check for LPALIB */\n      lpadsn = 'YES' ; lpares = 'NO'\n      If SUBSTR(apflib.i,1,6) = resvol Then lpares = 'YES'\n      End\n   vol.i = SUBSTR(apflib.i,1,6)\n   dsn.i = SUBSTR(apflib.i,7,44)\nEnd\nEnd         /* Static format  */\nElse        /* Dynamc format  */\n  do\n    Say 'The eCVT is located at '@ecvt '('X2D(@ecvt)')'\n    ecvtcsvt = c2d(storage(d2x(ecvt+228),4))   /* point to ecvtcsvt   */\n    apfa = c2d(storage(d2x(ecvtcsvt+12),4))    /* addr start of list  */\n    apht = c2d(storage(d2x(apfa+8),4))         /* addr 1st entry      */\n    last = c2d(storage(d2x(apfa+12),4))        /* addr last entry     */\n    apf. = ''\n    i = 0\n    do forever\n      dsn.i = storage(d2x(apht+24),44)         /* apf dataset name    */\n      if substr(dsn.i,1,1) \u00ac= '00'x then       /* 00 = deleted        */\n        do\n          apfesms = storage(d2x(apht+4),1)     /* sms flag            */\n          if  bitand(apfesms,'80'x)  = '80'x then vol.i = '*SMS* '\n          else vol.i = storage(d2x(apht+68),6)      /* apf volser     */\n          i = i + 1\n        end\n      if apht = last then leave\n      else apht = c2d(storage(d2x(apht+8),4))  /* addr next entry     */\n    end\n    apfcount = i - 1\n  end       /* Dynamic format */               /* set maximum lines   */\nSay ' '\nSay 'The CVTAUTHL field points to '@cvtauthl '('X2D(@cvtauthl)')'\nSay 'The APF table contains 'apfcount 'entries, as follows:'\n/***************************************************************/\n/* The in-storage APF table has been fetched, now print it     */\n/***************************************************************/\nSay 'VOLSER --------------DATA SET NAME-----------------'\nSay ' '\nDo i = 1 To apfcount                            /* print the list     */\n   Say vol.i' 'dsn.i' 'i\n/* Say SUBSTR(apflib.i,1,6) SUBSTR(apflib.i,7,44,' ') i */\nEnd\n/***************************************************************/\n/* Save the APF table to a data set                            */\n/***************************************************************/\nAddress TSO\ndsn1 = '.APFLIST.DATA.WORK'\ndsn1 = sysvar(sysuid) || dsn1\n\"ALLOC F(APFLIST) DA('\"dsn1\"') OLD RELEASE\"\nIf RC \\= 0 Then Do\n   Say 'IOAPFP failed on 'dsn1' error: 'RC\n   Exit\n   End\nNewstack\nDo i = apfcount To 1 By -1                      /* write the list */\n   Push ' 'SUBSTR(vol.i,1,6) SUBSTR(dsn.i,1,44,' ') i\nEnd\nPush ' APFCOUNT: 'RIGHT(apfcount,4,0)'   Date: 'DATE()'   Time: 'TIME()\nQueue\n'EXECIO * DISKW APFLIST ( FINIS'\nDelstack\nSay ' '\nSay 'Saved APF table to DASD'\nSay 'DSN: 'dsn1\nSay 'Return Code: 'RC\n\"FREE F(APFLIST)\"\nSay ' '\n/***************************************************************/\n/* Now process the directory blocks of each APF library        */\n/*   and save the member data to a data set.  Note that        */\n/*   when we dynamically allocate each PDS, we are defining    */\n/*   DCB parameters to enable reading the directory blocks.    */\n/***************************************************************/\ndsn2 = '.APFPGMS.DATA.WORK'\ndsn2 = sysvar(sysuid) || dsn2\n\"ALLOC F(APFPGMS) DA('\"dsn2\"') OLD RELEASE\"\nIf RC \\= 0 Then Do\n   Say 'IOAPFP failed on 'dsn2' error: 'RC\n   Exit\n   End\n/***************************************************************/\n/*   Add SYS1.LPALIB on sysres if not in APF list.             */\n/***************************************************************/\nIf lpadsn = 'NO' | (lpadsn = 'YES' & lpares \\= 'YES') Then Do\n   Say '*** SYS1.LPALIB on sysres appended to list for programs analysis.'\n   Say '         Reason:  lpadsn='lpadsn'  lpares='lpares\n   Say '    Explanation:  SYS1.LPALIB on the sysres volume is APF'\n   Say '                    authorized by MVS design during IPL.  It'\n   Say '                    is added to the APF list for authorized'\n   Say '                    programs analysis if not already contained'\n   Say '                    in the APF table.  If a SYS1.LPALIB is on'\n   Say '                    the APF table, a check is made for its'\n   Say '                    volser.  If not the sysres volume, it is'\n   Say '                    added to the APF list accordingly for the'\n   Say '                    authorized programs analysis.'\n   Say ' '\n   apfcount = apfcount + 1\n/* apflib.apfcount = resvol'SYS1.LPALIB'  */\n   vol.apfcount = resvol\n   dsn.apfcount = 'SYS1.LPALIB'\n   End\ntotpgms = 0\nSay 'Beginning APF library contents analysis'\nSay '===> note any TSO allocation error messages for skipped libraries'\nSay ' '\nDo i = 1 To apfcount                            /* cycle the list */\n/* dsn = STRIP(SUBSTR(apflib.i,7,44)) */\n/* vol = STRIP(SUBSTR(apflib.i,1,6))  */\n   dsn = STRIP(dsn.i)\n   vol = STRIP(vol.i)\n   say 'DSN='dsn\n   say 'VOL='vol\nSay ' '\n   Say RIGHT(i,3,0)'  Processing 'dsn' on 'vol'  Mark: 'DATE() TIME()\nsay \"ALLOC F(PDS) DA('\"dsn\"') VOL(\"vol\") SHR DSORG(PS) RECFM(F) LRECL(256) BLKSIZE(256) UNIT(SYSALLDA)\"\n   \"ALLOC F(PDS) DA('\"dsn\"') VOL(\"vol\") SHR DSORG(PS) RECFM(F) LRECL(256) BLKSIZE(256) UNIT(SYSALLDA)\"\n   RC1 = RC\n   'EXECIO * DISKR PDS ( FINIS STEM line.'\n   RC2 = RC\n   \"FREE F(PDS)\"\n   Say '       *** ALLOC RC: 'RC1'  EXECIO RC: 'RC2\n   If RC2 = 0 Then Do\n      Say '       *** Directory blocks read: 'line.0\n      Newstack\n      last = 0  /* flags when no more members indicator is detected */\n      memcount = 0\n      Do j = 1 To line.0\n         blocklen = X2D(C2X(SUBSTR(line.j,1,2))) /* Not proud of this logic, */\n         If blocklen = 0 or last = 1 Then Leave /* but seems to work --vlc  */\n         ix = 3                          /* Initialize DIRBLOCK parse index */\n         Do While ix < blocklen & last \\= 1          /* parse this DIRBLOCK */\n            pds2ftb1 = '00'x                         /* initialize apf not  */\n            pds2mnm  = '        '                    /* initialize alias of */\n            pds2name = SUBSTR(line.j,ix,8) ; ix = ix + 8    /* main section */\n            pds2ttrp = SUBSTR(line.j,ix,3) ; ix = ix + 3\n            pds2indc = SUBSTR(line.j,ix,1) ; ix = ix + 1\n            udl = 0                           /* calculate user data length */\n            If BITAND(pds2indc,'01'x) = '01'x Then udl = 1\n            If BITAND(pds2indc,'02'x) = '02'x Then udl = udl + 2\n            If BITAND(pds2indc,'04'x) = '04'x Then udl = udl + 4\n            If BITAND(pds2indc,'08'x) = '08'x Then udl = udl + 8\n            If BITAND(pds2indc,'10'x) = '10'x Then udl = udl + 16\n            udl = udl * 2                 /* finish calc halfwords to bytes */\n            If udl >= 22 & last \\= 1 Then Do   /* only process likely stuff */\n               ix = ix + 8             /* adjust index to skip misc 8 bytes */\n               pds2atr1 = SUBSTR(line.j,ix,1) ; ix = ix + 1\n               pds2atr2 = SUBSTR(line.j,ix,1) ; ix = ix + 1\n               pds2stor = SUBSTR(line.j,ix,3) ; ix = ix + 3\n               ix = ix + 2             /* adjust index to skip misc 2 bytes */\n               pds2epa  = SUBSTR(line.j,ix,3) ; ix = ix + 3\n               pds2ftb1 = SUBSTR(line.j,ix,1) ; ix = ix + 1\n               ix = ix + 2             /* adjust index to skip misc 2 bytes */\n                                                            /* scatter sect */\n               If BITAND(pds2atr1,'04'x) = '04'x Then Do\n                  pds2scat = SUBSTR(line.j,ix+33,8)\n                  ix = ix + 8\n                  End\n                                                              /* alias sect */\n               If BITAND(pds2indc,'80'x) = '80'x Then Do\n                  If udl >= 32 Then Do\n                     pds2epm  = SUBSTR(line.j,ix,3) ; ix = ix + 3\n                     pds2mnm  = SUBSTR(line.j,ix,8) ; ix = ix + 8\n                     End\n                  Else Do\n                     Say '*** WARNING - Missing major for alias 'pds2name' DBLK:'i\n                     pds2epm = '000000'x\n                     pds2mnm = '????????'\n                     End\n                  End\n                                                             /* ssi section */\n               If BITAND(pds2ftb1,'10'x) = '10'x Then Do\n                  If (ix-1)//2 \\= 0 Then ix = ix + 1    /* halfword alignmt */\n                  pdsssiwd = SUBSTR(line.j,ix,4) ; ix = ix + 4\n                  End\n                                                             /* apf section */\n               If BITAND(pds2ftb1,'08'x) \\= '08'x Then pdsapfac = ' '/* none*/\n               Else Do                                         /* maybe apf */\n                  pdsapfct = SUBSTR(line.j,ix,1)\n                  If pdsapfct = '01'x Then Do                /* NORMAL path */\n                     ix = ix + 1\n                     pdsapfac = SUBSTR(line.j,ix,1)\n                     ix = ix + 1\n                     If pdsapfac \\= '00'x & pdsapfac \\= '01'x Then Do\n                        Say '*** WARNING - Invalid AC for 'pds2name' DBLK:'i\n                        nop\n                        End\n                     End\n                  If pdsapfct \\= '01'x & (BITAND(pds2indc,'80'x)='80'x) Then Do\n                     pdsapfac=' '\n                     ix = ix - 8\n                     Say '*** WARNING - Compacted alias logic for 'pds2name' DBLK:'i\n                     End\n                  End\n               End\n            Else Do                              /* too short udl, leave it */\n               ix = ix + udl\n               If pds2name = 'FFFFFFFFFFFFFFFF'x Then Do\n                  last = 1\n                  Leave\n                  End\n               Say '*** WARNING - too short udl for 'pds2name' DBLK:'i\n               pds2atr1 = '00'x\n               pds2atr2 = '00'x\n               pds2stor = '000000'x\n               pds2mnm  = '        '\n               pdsapfac = ' '\n               End\n            If (ix-1)//2 \\= 0 Then ix = ix + 1          /* halfword alignmt */\n            If pds2name = 'FFFFFFFFFFFFFFFF'x Then Do\n               last = 1\n               Leave\n               End\n            If pds2name \\= '0000000000000000'x Then Do\n               memcount = memcount + 1\n               Push ' 'LEFT(dsn,44,' ')' 'LEFT(vol,6,' '),\n                    ' 'pds2name' TTR:'C2X(pds2ttrp),\n                    ' INDC:'C2X(pds2indc)' ATRBs:'C2X(pds2atr1),\n                    C2X(pds2atr2)' SIZE:'C2X(pds2stor),\n                    ' MAJ:'pds2mnm' AC:'C2X(pdsapfac),\n                    ' DBLK:'RIGHT(i,4,0)' UDL:'RIGHT(udl,2,0),\n                    ' IX:'RIGHT(ix,3,0)\n               End\n         End                                         /* DIRBLOCK parse done */\n      End\n      Say '       *** Directory blocks processed: 'j-1'  Members: 'memcount\n      Queue\n      'EXECIO * DISKW APFPGMS (      '\n      Delstack\n      totpgms = totpgms + memcount\n   End\nEnd\nNewstack\nQueue\n'EXECIO * DISKW APFPGMS ( FINIS'\nDelstack\nSay ' '\nSay 'Saved 'totpgms' APF program descriptor records to DASD'\nSay 'DSN: 'dsn2\nSay 'Return Code: 'RC\n\"FREE F(APFPGMS)\"\nExit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "IOESRT": {"ttr": 2305, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x003\\x00\\x94\\x08\\x8f\\x01\\x14\\x05\\x0f\"V\\x00\\xd3\\x00\\xd3\\x00\\x00\\xe2\\xc3\\xd5\\xe2\\xf0\\xf3@@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "1994-03-29T00:00:00", "modifydate": "2014-02-19T22:56:33", "lines": 211, "newlines": 211, "modlines": 0, "user": "SCNS03"}, "text": "/*REXX*/\n/*****************************************************************/\n/*  IOESRT: REXX program to create router SVC database.          */\n/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */\n/*****************************************************************/\n/* MVS DATA AREAS:                                               */\n/*                CVT - Communications Vector Table (@'10'x)     */\n/*               SCVT - Supervisor Call Vector Table             */\n/*                                                               */\n/*                                                               */\n/*****************************************************************/\n/*--------------virtual storage map definition section----------------*/\nNumeric Digits 10           /* required to handle decimal conversions */\n@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */\n@cvt = D2X(C2D(@cvt))                    /* binary to hex             */\n@cvtreal  = STORAGE(D2X(X2D(@cvt)+284),4)    /* get CVTREAL address   */\n@cvtreal  = D2X(C2D(@cvtreal))                 /* binary to hex       */\n@cvtshrvm = STORAGE(D2X(X2D(@cvt)+416),4)    /* get CVTSHRVM address  */\n@cvtshrvm = D2X(C2D(@cvtshrvm))                /* binary to hex       */\n@cvtgda   = STORAGE(D2X(X2D(@cvt)+560),4)    /* get CVTGDA address    */\n@cvtgda   = D2X(C2D(@cvtgda))                  /* binary to hex       */\n@gdacsa   = D2X(X2D(@cvtgda)+108)            /* locate GDACSAstarts   */\n@gdacsa   = D2X(C2D(STORAGE(@gdacsa,4)))       /*  get GDACSA         */\n@gdacsasz = D2X(X2D(@cvtgda)+112)            /* locate GDACSASiZe     */\n@gdacsasz = D2X(C2D(STORAGE(@gdacsasz,4)))     /*  get GDACSASiZe     */\n@gdaecsa  = D2X(X2D(@cvtgda)+124)            /* locate GDAECSAstarts  */\n@gdaecsa  = D2X(C2D(STORAGE(@gdaecsa,4)))      /*  get GDAECSA        */\n@gdaecsas = D2X(X2D(@cvtgda)+128)            /* locate GDAECSASize    */\n@gdaecsas = D2X(C2D(STORAGE(@gdaecsas,4)))     /*  get GDAECSAS       */\n@cvtsmext = STORAGE(D2X(X2D(@cvt)+1196),4)   /* get CVTSMEXT address  */\n@cvtsmext = D2X(C2D(@cvtsmext))                /* binary to hex       */\n@cvtmlpas = D2X(X2D(@cvtsmext)+8)            /* locate CVTMLPAStarts  */\n@cvtmlpas = D2X(C2D(STORAGE(@cvtmlpas,4)))     /*  get CVTMLPAS       */\n@cvtmlpae = D2X(X2D(@cvtsmext)+12)           /* locate CVTMLPAEnds    */\n@cvtmlpae = D2X(C2D(STORAGE(@cvtmlpae,4)))     /*  get CVTMLPAE       */\n@cvtflpas = D2X(X2D(@cvtsmext)+16)           /* locate CVTFLPAStarts  */\n@cvtflpas = D2X(C2D(STORAGE(@cvtflpas,4)))     /*  get CVTFLPAS       */\n@cvtflpae = D2X(X2D(@cvtsmext)+20)           /* locate CVTFLPAEnds    */\n@cvtflpae = D2X(C2D(STORAGE(@cvtflpae,4)))     /*  get CVTFLPAE       */\n@cvtplpas = D2X(X2D(@cvtsmext)+24)           /* locate CVTPLPAStarts  */\n@cvtplpas = D2X(C2D(STORAGE(@cvtplpas,4)))     /*  get CVTPLPAS       */\n@cvtplpae = D2X(X2D(@cvtsmext)+28)           /* locate CVTPLPAEnds    */\n@cvtplpae = D2X(C2D(STORAGE(@cvtplpae,4)))     /*  get CVTPLPAE       */\n@cvtrwns  = D2X(X2D(@cvtsmext)+32)           /* locate CVTRWNStarts   */\n@cvtrwns  = D2X(C2D(STORAGE(@cvtrwns,4)))      /*  get CVTRWNS        */\n@cvtrwne  = D2X(X2D(@cvtsmext)+36)           /* locate CVTRWNEnds     */\n@cvtrwne  = D2X(C2D(STORAGE(@cvtrwne,4)))      /*  get CVTRWNE        */\n@cvtrons  = D2X(X2D(@cvtsmext)+40)           /* locate CVTRONStarts   */\n@cvtrons  = D2X(C2D(STORAGE(@cvtrons,4)))      /*  get CVTRONS        */\n@cvtrone  = D2X(X2D(@cvtsmext)+44)           /* locate CVTRONEnds     */\n@cvtrone  = D2X(C2D(STORAGE(@cvtrone,4)))      /*  get CVTRONE        */\n@cvterwns = D2X(X2D(@cvtsmext)+48)           /* locate CVTERWNStarts  */\n@cvterwns = D2X(C2D(STORAGE(@cvterwns,4)))     /*  get CVTERWNS       */\n@cvterwne = D2X(X2D(@cvtsmext)+52)           /* locate CVTERWNEnds    */\n@cvterwne = D2X(C2D(STORAGE(@cvterwne,4)))     /*  get CVTRRWNE       */\n@cvteplps = D2X(X2D(@cvtsmext)+56)           /* locate CVTEPLPStarts  */\n@cvteplps = D2X(C2D(STORAGE(@cvteplps,4)))     /*  get CVTEPLPS       */\n@cvteplpe = D2X(X2D(@cvtsmext)+60)           /* locate CVTEPLPEnds    */\n@cvteplpe = D2X(C2D(STORAGE(@cvteplpe,4)))     /*  get CVTRPLPE       */\n@cvteflps = D2X(X2D(@cvtsmext)+64)           /* locate CVTEFLPStarts  */\n@cvteflps = D2X(C2D(STORAGE(@cvteflps,4)))     /*  get CVTEFLPS       */\n@cvteflpe = D2X(X2D(@cvtsmext)+68)           /* locate CVTEFLPEnds    */\n@cvteflpe = D2X(C2D(STORAGE(@cvteflpe,4)))     /*  get CVTRFLPE       */\n@cvtemlps = D2X(X2D(@cvtsmext)+72)           /* locate CVTEMLPStarts  */\n@cvtemlps = D2X(C2D(STORAGE(@cvtemlps,4)))     /*  get CVTEMLPS       */\n@cvtemlpe = D2X(X2D(@cvtsmext)+76)           /* locate CVTEMLPEnds    */\n@cvtemlpe = D2X(C2D(STORAGE(@cvtemlpe,4)))     /*  get CVTRMLPE       */\n        /*------simplify variable names & make addresses decimal------*/\n@csa1g  = @gdacsa    ; @csa2g = D2X(X2D(@gdacsasz)+X2D(@gdacsa)-1)/* g*/\n   csa1 = X2D(@csa1g) ; csa2 = X2D(@csa2g)                    /* csa  */\n@mlpa1  = @cvtmlpas  ; @mlpa2 = @cvtmlpae                     /* mlpa */\n   mlpa1 = X2D(@mlpa1) ; mlpa2 = X2D(@mlpa2)\n@flpa1  = @cvtflpas  ; @flpa2 = @cvtflpae                     /* flpa */\n   flpa1 = X2D(@flpa1) ; flpa2 = X2D(@flpa2)\n@plpa1  = @cvtplpas  ; @plpa2 = @cvtplpae                     /* plpa */\n   plpa1 = X2D(@plpa1) ; plpa2 = X2D(@plpa2)\n@sqa1   = D2X(X2D(@cvtplpae)+1) ; @sqa2 = D2X(X2D(@cvtrwns)-1)/* sqa  */\n   sqa1 = X2D(@sqa1) ; sqa2 = X2D(@sqa2)\n@nuc1   = @cvtrwns   ; @nuc2  = @cvterwne                     /* nuc  */\n   nuc1 = X2D(@nuc1) ; nuc2 = X2D(@nuc2)\n@esqa1  = D2X(X2D(@nuc2)+1) ; @esqa2 = D2X(X2D(@cvteplps)-1)  /* esqa */\n  esqa1 = X2D(@esqa1) ; esqa2 = X2D(@esqa2)\n@eplpa1 = @cvteplps  ; @eplpa2 = @cvteplpe                    /* eplpa*/\n eplpa1 = X2D(@eplpa1) ; eplpa2 = X2D(@eplpa2)\n@eflpa1 = @cvteflps  ; @eflpa2 = @cvteflpe                    /* eflpa*/\n eflpa1 = X2D(@eflpa1) ; eflpa2 = X2D(@eflpa2)\n@emlpa1 = @cvtemlps  ; @emlpa2 = @cvtemlpe                    /* emlpa*/\n emlpa1 = X2D(@emlpa1) ; emlpa2 = X2D(@emlpa2)\n@ecsa1g = @gdaecsa   ; @ecsa2g= D2X(X2D(@gdaecsas)+X2D(@gdaecsa)-1)/*g*/\n  ecsa1 = X2D(@ecsa1g) ; ecsa2 = X2D(@ecsa2g)\n@eprivs = X2D(@ecsa2g)+1                               /* ext private */\n@eprive = 2147483647                         /* fixed by architecture */\n epriv1 = @eprivs ; epriv2 = @eprive\n@psas   = 0 ; @psae = 4095                       /* psa fixed by arch */\n   psa1 = @psas ; psa2 = @psae\n@prive  = X2D(@csa1g)-1 ; @privs = X2D(@psae)+1            /* private */\n  priv1 = @privs ; priv2 = @prive\n              /*------------------------------------------------------*/\n             /* Usage Notes: Hex character compares are incompatible */\n            /*    for storage residency determination.  Thus, entry */\n           /*     point addresses must be converted to decimal and */\n          /*      VS boundary addresses must be converted to de-  */\n         /*       cimal for correct compare operations.          */\n        /*------------------------------------------------------*/\n/*----------end of virtual storage map definition section-------------*/\n@cvtabend = STORAGE(D2X(X2D(@cvt)+200),4)    /* get CVTABEND address  */\n@cvtabend = D2X(C2D(@cvtabend))                /* binary to hex       */\n@scvtsvct = D2X(X2D(@cvtabend)+132)          /* SCVT addressibility   */\n@scvtsvct = STORAGE(@scvtsvct,4)                  /* SVCT table       */\n@scvtsvct = D2X(C2D(@scvtsvct))                /* binary to hex       */\nAddress TSO ; \"CLEAR\"\nSay 'CVT:'@cvt' CVTABEND:'@cvtabend' SCVTSVCT:'@scvtsvct' 'DATE() TIME()\nSay ' '\ndsn = 'MVS.ESR.ESRTABLE'\nNewstack\nactive = 0 ; inactive = 0 ; esrsvc = 0\nmodule = 'IGXERROR' ; Call \"#NUCLKUP\" module ; igxerror = Result\nd = Date() ; t = Time()\nDo i = 0 to 255                                 /* loop thru storage  */\n   bytes = STORAGE(D2X(X2D(@scvtsvct)+(i*8)),8)\n   bytes = C2X(bytes)\n   svcep  = SUBSTR(bytes,1,8)\n   svctp2 = SUBSTR(bytes,10,1)\n   If svctp2 = '4'            /* EP address is an ESR table */\n      Then Do\n         esrid = STORAGE(svcep,4)                 /* table eyecatcher */\n         esrct = C2X(STORAGE(D2X(X2D(svcep)+4),4))       /* esr count */\n         Say 'SVC 'i' is 'esrid'.  Table at 'svcep', Slots 'X2D(esrct)' ('esrct')'\n         Say ' '\n         esrsvc = 0\n         Do j = 0 to X2D(esrct)                   /* process this ESR */\n            bytes = STORAGE(D2X(X2D(svcep)+(j*8)+8),8)\n   addr = SUBSTR(bytes,1,4)       /* sloppy code to grap EP in binary */\n   bytes = C2X(bytes)          /* legacy code before learning bit ops */\n            esrep  = SUBSTR(bytes,1,8)\n                                        /* determine storage location */\n   addr = BITAND(addr,'7FFFFFFF'x)        /* shave off amode bit (32) */\n   addr = C2D(addr)                      /* make numeric for compares */\n   sloc = 'ERROR'                       /* determine module residency */\n   If (addr >= csa1   & addr <= csa2  ) Then sloc = 'CSA  '\n      Else If (addr >= mlpa1  & addr <= mlpa2 ) Then sloc = 'MLPA '\n      Else If (addr >= flpa1  & addr <= flpa2 ) Then sloc = 'FLPA '\n      Else If (addr >= plpa1  & addr <= plpa2 ) Then sloc = 'PLPA '\n      Else If (addr >= sqa1   & addr <= sqa2  ) Then sloc = 'SQA  '\n      Else If (addr >= nuc1   & addr <= nuc2  ) Then sloc = 'NUC  '\n      Else If (addr >= esqa1  & addr <= esqa2 ) Then sloc = 'ESQA '\n      Else If (addr >= eplpa1 & addr <= eplpa2) Then sloc = 'EPLPA'\n      Else If (addr >= eflpa1 & addr <= eflpa2) Then sloc = 'EFLPA'\n      Else If (addr >= emlpa1 & addr <= emlpa2) Then sloc = 'EMLPA'\n      Else If (addr >= ecsa1  & addr <= ecsa2 ) Then sloc = 'ECSA '\n      Else If (addr >= epriv1 & addr <= epriv2) Then sloc = 'EPRIV'\n      Else If (addr >= priv1  & addr <= priv2 ) Then sloc = 'PRIV '\n      Else If (addr >= psa1   & addr <= psa2  ) Then sloc = 'PSA  '\n            esrtp2 = SUBSTR(bytes,10,1)\n            esrmisc = '   '\n            If esrtp2 = '8'\n               Then esrmisc = 'APF'\n            inactflag = 0\n            If igxerror = Right(D2X(addr),8,0) /* normalize address */\n               Then inactflag = 1\n               Else Do\n                       active = active + 1\n                       esrsvc = esrsvc + 1\n                    End\n            esrtp1 = SUBSTR(bytes,9,1)\n               Select\n                  When esrtp1 = '0'\n                     Then esrtype = 'TYPE 1  '\n                  When esrtp1 = '8'\n                     Then esrtype = 'TYPE 2  '\n                  When esrtp1 = 'C'\n                     Then esrtype = 'TYPE 3/4'\n                  When esrtp1 = '2'\n                     Then esrtype = 'TYPE 6  '\n               Otherwise\n                          esrtype = 'TYPE ?  '\n               End\n            If inactflag = 0\n               Then Push ' 'LEFT(dsn,44,' '),\n                         'ESR'RIGHT(j,3,0) '('RIGHT(D2X(j),2,0)')',\n                         'SVC'RIGHT(i,3,0) '('RIGHT(D2X(i),2,0)')',\n                          esrtype esrep sloc esrmisc d t\n         End\n         Say '     Total ESR SVCs this table 'esrsvc\n         Say ' '\n      End\nEnd\nSay 'This system contains 'active' ESR SVCs'\nSay ' '\nSay '  (IGXERROR nucleus address = 'igxerror')'\nSay ' '\nSay 'ESRTABLE processing complete ' Time()\nSay ' '\n/***************************************************************/\n/* Now save the stack to our ESR data set                      */\n/***************************************************************/\ndsn2 = sysvar(sysuid) || '.ESRS.DATA.WORK'\n\"ALLOC F(ESRS) DA('\"dsn2\"') MOD RELEASE\"\nIf RC \\= 0 Then Do\n   Say 'IOESRT failed on 'dsn2' error: 'RC\n   Exit\n   End\nQueue\n'EXECIO * DISKW ESRS ( FINIS'\nDelstack\nSay ' '\nSay 'Saved 'active' ESR SVC descriptor records to DASD'\nSay 'DSN: 'dsn2\nSay 'Return Code: 'RC\n\"FREE F(ESRS)\"\nExit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "IOLLTP": {"ttr": 2308, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x007\\x01\\x13(\\x0f\\x01\\x14\\x05\\x0f\"V\\x00\\xd7\\x00\\xd7\\x00\\x00\\xe2\\xc3\\xd5\\xe2\\xf0\\xf3@@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "2013-10-07T00:00:00", "modifydate": "2014-02-19T22:56:37", "lines": 215, "newlines": 215, "modlines": 0, "user": "SCNS03"}, "text": "/*REXX*/\n/*****************************************************************/\n/*  IOLLTP: REXX program to create LLT programs database.        */\n/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */\n/*****************************************************************/\n/*                CVT - Communications Vector Table (@'10'x)     */\n/*                LLT - Linklist Lookaside Table                 */\n/*               DCB3 - Data Control Block (BDAM)                */\n/*                DEB - IOS Data Extent Block                    */\n/*                                                               */\n/*****************************************************************/\n@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */\n@cvt = D2X(C2D(@cvt))                    /* binary to hex             */\n@cvtlink  = STORAGE(D2X(X2D(@cvt)+8),4)      /* get CVTLINK address   */\n@cvtlink  = D2X(C2D(@cvtlink))                 /* binary to hex       */\n@dcbdebad = STORAGE(D2X(X2D(@cvtlink)+44),4)    /* LINKLIB DCB to DEB */\n@dcbdebad = D2X(C2D(@dcbdebad))                 /* convert to hex     */\ndebflgs1  = STORAGE(D2X(X2D(@dcbdebad)+14),1)     /* LINKLIB DEBflags */\n   debapfin = 'LNKLST'\n   If BITAND(debflgs1,'02'x)\\='02'x Then debapfin = 'APFTAB'\n@cvtllta  = STORAGE(D2X(X2D(@cvt)+1244),4)   /* get CVTLLTA address   */\n@cvtllta  = D2X(C2D(@cvtllta))                 /* binary to hex       */\nlltcount  = C2D(STORAGE(D2X(X2D(@cvtllta)+7),1))  /* LLT libraries    */\nlltllen   = C2D(STORAGE(D2X(X2D(@cvtllta)+8),1))  /* length 1st entry */\n@lltentry = X2D(@cvtllta)+9           /* address of 1st LLT entry     */\nAddress TSO ; \"CLEAR\"\nSay 'CVT:'@cvt' CVTLLTA:'@cvtllta' DCB:'@cvtlink,\n    'DEB:'@dcbdebad' FLGS1:'C2X(debflgs1)' LNKAUTH='debapfin\nSay ' '\nSay 'LLT scan on 'DATE()' started: 'TIME()\nSay ' '\nDo i = 1 to lltcount                            /* loop thru storage  */\n   lltlib.i = STORAGE(D2X(@lltentry),lltllen)   /* get the LLT entry  */\n   @lltentry = @lltentry + 45                   /* bump to next entry */\n   lltllen = C2D(STORAGE(D2X(@lltentry-1),1))   /* length of next  */\nEnd\nSay '--------------DATA SET NAME-----------------'\nSay ' '\nDo i = 1 to lltcount                            /* print the list     */\n   Say SUBSTR(lltlib.i,1,44,' ') i\nEnd\nSay ' '\nSay 'LLT scan completed: 'TIME()\n/***************************************************************/\n/* Save the LINKLIST table to a data set                       */\n/***************************************************************/\nAddress TSO\ndsn1 = sysvar(sysuid) || '.LLTLIST.DATA.WORK'\n\"ALLOC F(LLTLIST) DA('\"dsn1\"') OLD RELEASE\"\nIf RC \\= 0 Then Do\n   Say 'IOLLTP failed on 'dsn1' error: 'RC\n   Exit\n   End\nNewstack\nDo i = lltcount To 1 By -1                      /* write the list */\n   Push ' 'SUBSTR(lltlib.i,1,44,' ') i\nEnd\nPush ' LLTCOUNT: 'RIGHT(lltcount,4,0)'   Date: 'DATE()'   Time: 'TIME()\nPush 'CVT:'@cvt' CVTLLTA:'@cvtllta' DCB:'@cvtlink,\n    'DEB:'@dcbdebad' FLGS1:'C2X(debflgs1)' LNKAUTH='debapfin\nQueue\n'EXECIO * DISKW LLTLIST ( FINIS'\nDelstack\nSay ' '\nSay 'Saved LINKLIST table to DASD'\nSay 'DSN: 'dsn1\nSay 'Return Code: 'RC\n\"FREE F(LLTLIST)\"\nSay ' '\n/***************************************************************/\n/* Now process the directory blocks of each LLT library        */\n/*   and save the member data to a data set.  Note that        */\n/*   when we dynamically allocate each PDS, we are defining    */\n/*   DCB parameters to enable reading the directory blocks.    */\n/***************************************************************/\ndsn2 = sysvar(sysuid) || '.LLTPGMS.DATA.WORK'\n\"ALLOC F(LLTPGMS) DA('\"dsn2\"') OLD RELEASE\"\nIf RC \\= 0 Then Do\n   Say 'IOLLTP failed on 'dsn2' error: 'RC\n   Exit\n   End\ntotpgms = 0\nSay 'Beginning LINKLIST library contents analysis'\nSay '===> note any TSO allocation error messages for skipped libraries'\nSay ' '\nDo i = 1 To lltcount                                /* cycle the list */\n   dsn = STRIP(SUBSTR(lltlib.i,1,44))\nSay ' '\n   Say RIGHT(i,3,0)'  Processing 'dsn'   Mark: 'DATE() TIME()\n   \"ALLOC F(PDS) DA('\"dsn\"') SHR DSORG(PS) RECFM(F) LRECL(256) BLKSIZE(256)\"\n   RC1 = RC\n   'EXECIO * DISKR PDS ( FINIS STEM line.'\n   RC2 = RC\n   \"FREE F(PDS)\"\n   Say '       *** ALLOC RC: 'RC1'  EXECIO RC: 'RC2\n   If RC2 = 0 Then Do\n      Say '       *** Directory blocks read: 'line.0\n      Newstack\n      last = 0  /* flags when no more members indicator is detected */\n      memcount = 0\n      Do j = 1 To line.0\n         blocklen = X2D(C2X(SUBSTR(line.j,1,2))) /* Not proud of this logic, */\n         If blocklen = 0 or last = 1 Then Leave /* but seems to work --vlc  */\n         ix = 3                          /* Initialize DIRBLOCK parse index */\n         Do While ix < blocklen & last \\= 1          /* parse this DIRBLOCK */\n            pds2ftb1 = '00'x                         /* initialize apf not  */\n            pds2mnm  = '        '                    /* initialize alias of */\n            pds2name = SUBSTR(line.j,ix,8) ; ix = ix + 8    /* main section */\n            pds2ttrp = SUBSTR(line.j,ix,3) ; ix = ix + 3\n            pds2indc = SUBSTR(line.j,ix,1) ; ix = ix + 1\n            udl = 0                           /* calculate user data length */\n            If BITAND(pds2indc,'01'x) = '01'x Then udl = 1\n            If BITAND(pds2indc,'02'x) = '02'x Then udl = udl + 2\n            If BITAND(pds2indc,'04'x) = '04'x Then udl = udl + 4\n            If BITAND(pds2indc,'08'x) = '08'x Then udl = udl + 8\n            If BITAND(pds2indc,'10'x) = '10'x Then udl = udl + 16\n            udl = udl * 2                 /* finish calc halfwords to bytes */\n            If udl >= 22 & last \\= 1 Then Do   /* only process likely stuff */\n               ix = ix + 8             /* adjust index to skip misc 8 bytes */\n               pds2atr1 = SUBSTR(line.j,ix,1) ; ix = ix + 1\n               pds2atr2 = SUBSTR(line.j,ix,1) ; ix = ix + 1\n               pds2stor = SUBSTR(line.j,ix,3) ; ix = ix + 3\n               ix = ix + 2             /* adjust index to skip misc 2 bytes */\n               pds2epa  = SUBSTR(line.j,ix,3) ; ix = ix + 3\n               pds2ftb1 = SUBSTR(line.j,ix,1) ; ix = ix + 1\n               ix = ix + 2             /* adjust index to skip misc 2 bytes */\n                                                            /* scatter sect */\n               If BITAND(pds2atr1,'04'x) = '04'x Then Do\n                  pds2scat = SUBSTR(line.j,ix+33,8)\n                  ix = ix + 8\n                  End\n                                                              /* alias sect */\n               If BITAND(pds2indc,'80'x) = '80'x Then Do\n                  If udl >= 32 Then Do\n                     pds2epm  = SUBSTR(line.j,ix,3) ; ix = ix + 3\n                     pds2mnm  = SUBSTR(line.j,ix,8) ; ix = ix + 8\n                     End\n                  Else Do\n                     Say '*** WARNING - Missing major for alias 'pds2name' DBLK:'i\n                     pds2epm = '000000'x\n                     pds2mnm = '????????'\n                     End\n                  End\n                                                             /* ssi section */\n               If BITAND(pds2ftb1,'10'x) = '10'x Then Do\n                  If (ix-1)//2 \\= 0 Then ix = ix + 1    /* halfword alignmt */\n                  pdsssiwd = SUBSTR(line.j,ix,4) ; ix = ix + 4\n                  End\n                                                             /* apf section */\n               If BITAND(pds2ftb1,'08'x) \\= '08'x Then pdsapfac = ' '/* none*/\n               Else Do                                         /* maybe apf */\n                  pdsapfct = SUBSTR(line.j,ix,1)\n                  If pdsapfct = '01'x Then Do                /* NORMAL path */\n                     ix = ix + 1\n                     pdsapfac = SUBSTR(line.j,ix,1)\n                     ix = ix + 1\n                     If pdsapfac \\= '00'x & pdsapfac \\= '01'x Then Do\n                        Say '*** WARNING - Invalid AC for 'pds2name' DBLK:'i\n                        nop\n                        End\n                     End\n                  If pdsapfct \\= '01'x & (BITAND(pds2indc,'80'x)='80'x) Then Do\n                     pdsapfac=' '\n                     ix = ix - 8\n                     Say '*** WARNING - Compacted alias logic for 'pds2name' DBLK:'i\n                     End\n                  End\n               End\n            Else Do                              /* too short udl, leave it */\n               ix = ix + udl\n               If pds2name = 'FFFFFFFFFFFFFFFF'x Then Do\n                  last = 1\n                  Leave\n                  End\n               Say '*** WARNING - too short udl for 'pds2name' DBLK:'i\n               pds2atr1 = '00'x\n               pds2atr2 = '00'x\n               pds2stor = '000000'x\n               pds2mnm  = '        '\n               pdsapfac = ' '\n               End\n            If (ix-1)//2 \\= 0 Then ix = ix + 1          /* halfword alignmt */\n            If pds2name = 'FFFFFFFFFFFFFFFF'x Then Do\n               last = 1\n               Leave\n               End\n            If pds2name \\= '0000000000000000'x Then Do\n               memcount = memcount + 1\n               Push ' 'LEFT(dsn,44,' ')' 'RIGHT(i,3,0),\n                    ' 'pds2name' TTR:'C2X(pds2ttrp),\n                    ' INDC:'C2X(pds2indc)' ATRBs:'C2X(pds2atr1),\n                    C2X(pds2atr2)' SIZE:'C2X(pds2stor),\n                    ' MAJ:'pds2mnm' AC:'C2X(pdsapfac),\n                    ' DBLK:'RIGHT(i,4,0)' UDL:'RIGHT(udl,2,0),\n                    ' IX:'RIGHT(ix,3,0)\n               End\n         End                                         /* DIRBLOCK parse done */\n      End\n      Say '       *** Directory blocks processed: 'j-1'  Members: 'memcount\n      Queue\n      'EXECIO * DISKW LLTPGMS (      '\n      Delstack\n      totpgms = totpgms + memcount\n   End\nEnd\nNewstack\nQueue\n'EXECIO * DISKW LLTPGMS ( FINIS'\nDelstack\nSay ' '\nSay 'Saved 'totpgms' LINKLIST program descriptor records to DASD'\nSay 'DSN: 'dsn2\nSay 'Return Code: 'RC\n\"FREE F(LLTPGMS)\"\nExit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "IOLPAP": {"ttr": 531, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x94\\x08\\x8f\\x01\\x130_\\x16\\x18\\x00\\xcd\\x00\\xcd\\x00\\x00\\xe2\\xc3\\xd5\\xe2\\xf0\\xf3@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1994-03-29T00:00:00", "modifydate": "2013-11-01T16:18:00", "lines": 205, "newlines": 205, "modlines": 0, "user": "SCNS03"}, "text": "/*REXX*/\n/*****************************************************************/\n/*  IOLPAP: REXX program to create LPAT programs database.       */\n/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */\n/*****************************************************************/\n/*                CVT - Communications Vector Table (@'10'x)     */\n/*               LPAT - Link Pack Area (libraries) Table         */\n/*                                                               */\n/*****************************************************************/\n@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */\n@cvt = D2X(C2D(@cvt))                    /* binary to hex             */\n@cvtsmext = STORAGE(D2X(X2D(@cvt)+1196),4)   /* get CVTSMEXT address  */\n@cvtsmext = D2X(C2D(@cvtsmext))                /* binary to hex       */\n@cvteplps = D2X(X2D(@cvtsmext)+56)           /* get CVTEPLPS address  */\n@cvteplps = STORAGE(@cvteplps,4)             /* get LPAT address      */\n@cvteplps = D2X(C2D(@cvteplps))                /* binary to hex       */\nlpatcount = C2D(STORAGE(D2X(X2D(@cvteplps)+4),4)) /* LPAT entries     */\nlpatlen   = C2D(STORAGE(D2X(X2D(@cvteplps)+8),1)) /* length 1st entry */\n@lpatentry= X2D(@cvteplps)+9          /* address of 1st LPAT entry    */\nSay 'CVT:'@cvt  'CVTSMEXT:'@cvtsmext'  CVTEPLPS:'@cvteplps,\n    '  'DATE() TIME()\nSay ' '\nSay 'The LPAT table contains 'lpatcount 'entries, as follows:'\nSay ' '\nDo i = 1 to lpatcount                           /* loop thru storage  */\n   lpatlib.i = STORAGE(D2X(@lpatentry),lpatlen) /* get the LPAT entry */\n   @lpatentry = @lpatentry + 45                 /* bump to next entry */\n   lpatlen = C2D(STORAGE(D2X(@lpatentry-1),1))  /* length of next     */\nEnd\nSay '--------------DATA SET NAME-----------------'\nSay ' '\nDo i = 1 to lpatcount                           /* print the list     */\n   Say SUBSTR(lpatlib.i,1,44,' ') i\nEnd\n/***************************************************************/\n/* Save the LINK PACK AREA table list to a data set            */\n/***************************************************************/\nAddress TSO\ndsn1 = sysvar(sysuid) || '.LPALIST.DATA.WORK'\n\"ALLOC F(LPALIST) DA('\"dsn1\"') OLD RELEASE\"\nIf RC \\= 0 Then Do\n   Say 'IOLPAP failed on 'dsn1' error: 'RC\n   Exit\n   End\nNewstack\nDo i = lpatcount To 1 By -1                        /* write the list */\n   Push ' 'SUBSTR(lpatlib.i,1,44,' ') i\nEnd\nPush ' LPACOUNT: 'RIGHT(lpatcount,4,0)'   Date: 'DATE()'  Time: 'TIME()\nPush 'CVT:'@cvt' CVTSMEXT:'@cvtsmext' CVTEPLPS:'@cvteplps\nQueue\n'EXECIO * DISKW LPALIST ( FINIS'\nDelstack\nSay ' '\nSay 'Saved LINKLIST table to DASD'\nSay 'DSN: 'dsn1\nSay 'Return Code: 'RC\n\"FREE F(LPALIST)\"\nSay ' '\n/***************************************************************/\n/* Now process the directory blocks of each LPA library        */\n/*   and save the member data to a data set.  Note that        */\n/*   when we dynamically allocate each PDS, we are defining    */\n/*   DCB parameters to enable reading the directory blocks.    */\n/***************************************************************/\ndsn2 = sysvar(sysuid) || '.LPAPGMS.DATA.WORK'\n\"ALLOC F(LPAPGMS) DA('\"dsn2\"') OLD RELEASE\"\nIf RC \\= 0 Then Do\n   Say 'IOLPAP failed on 'dsn2' error: 'RC\n   Exit\n   End\ntotpgms = 0\nSay 'Beginning LINK PACK AREA library contents analysis'\nSay '===> note any TSO allocation error messages for skipped libraries'\nSay ' '\nDo i = 1 To lpatcount                               /* cycle the list */\n   dsn = STRIP(SUBSTR(lpatlib.i,1,44))\nSay ' '\n   Say RIGHT(i,3,0)'  Processing 'dsn'   Mark: 'DATE() TIME()\n   \"ALLOC F(PDS) DA('\"dsn\"') SHR DSORG(PS) RECFM(F) LRECL(256) BLKSIZE(256)\"\n   RC1 = RC\n   'EXECIO * DISKR PDS ( FINIS STEM line.'\n   RC2 = RC\n   \"FREE F(PDS)\"\n   Say '       *** ALLOC RC: 'RC1'  EXECIO RC: 'RC2\n   If RC2 = 0 Then Do\n      Say '       *** Directory blocks read: 'line.0\n      Newstack\n      last = 0  /* flags when no more members indicator is detected */\n      memcount = 0\n      Do j = 1 To line.0\n         blocklen = X2D(C2X(SUBSTR(line.j,1,2))) /* Not proud of this logic, */\n         If blocklen = 0 or last = 1 Then Leave /* but seems to work --vlc  */\n         ix = 3                          /* Initialize DIRBLOCK parse index */\n         Do While ix < blocklen & last \\= 1          /* parse this DIRBLOCK */\n            pds2ftb1 = '00'x                         /* initialize apf not  */\n            pds2mnm  = '        '                    /* initialize alias of */\n            pds2name = SUBSTR(line.j,ix,8) ; ix = ix + 8    /* main section */\n            pds2ttrp = SUBSTR(line.j,ix,3) ; ix = ix + 3\n            pds2indc = SUBSTR(line.j,ix,1) ; ix = ix + 1\n            udl = 0                           /* calculate user data length */\n            If BITAND(pds2indc,'01'x) = '01'x Then udl = 1\n            If BITAND(pds2indc,'02'x) = '02'x Then udl = udl + 2\n            If BITAND(pds2indc,'04'x) = '04'x Then udl = udl + 4\n            If BITAND(pds2indc,'08'x) = '08'x Then udl = udl + 8\n            If BITAND(pds2indc,'10'x) = '10'x Then udl = udl + 16\n            udl = udl * 2                 /* finish calc halfwords to bytes */\n            If udl >= 22 & last \\= 1 Then Do   /* only process likely stuff */\n               ix = ix + 8             /* adjust index to skip misc 8 bytes */\n               pds2atr1 = SUBSTR(line.j,ix,1) ; ix = ix + 1\n               pds2atr2 = SUBSTR(line.j,ix,1) ; ix = ix + 1\n               pds2stor = SUBSTR(line.j,ix,3) ; ix = ix + 3\n               ix = ix + 2             /* adjust index to skip misc 2 bytes */\n               pds2epa  = SUBSTR(line.j,ix,3) ; ix = ix + 3\n               pds2ftb1 = SUBSTR(line.j,ix,1) ; ix = ix + 1\n               ix = ix + 2             /* adjust index to skip misc 2 bytes */\n                                                            /* scatter sect */\n               If BITAND(pds2atr1,'04'x) = '04'x Then Do\n                  pds2scat = SUBSTR(line.j,ix+33,8)\n                  ix = ix + 8\n                  End\n                                                              /* alias sect */\n               If BITAND(pds2indc,'80'x) = '80'x Then Do\n                  If udl >= 32 Then Do\n                     pds2epm  = SUBSTR(line.j,ix,3) ; ix = ix + 3\n                     pds2mnm  = SUBSTR(line.j,ix,8) ; ix = ix + 8\n                     End\n                  Else Do\n                     Say '*** WARNING - Missing major for alias 'pds2name' DBLK:'i\n                     pds2epm = '000000'x\n                     pds2mnm = '????????'\n                     End\n                  End\n                                                             /* ssi section */\n               If BITAND(pds2ftb1,'10'x) = '10'x Then Do\n                  If (ix-1)//2 \\= 0 Then ix = ix + 1    /* halfword alignmt */\n                  pdsssiwd = SUBSTR(line.j,ix,4) ; ix = ix + 4\n                  End\n                                                             /* apf section */\n               If BITAND(pds2ftb1,'08'x) \\= '08'x Then pdsapfac = ' '/* none*/\n               Else Do                                         /* maybe apf */\n                  pdsapfct = SUBSTR(line.j,ix,1)\n                  If pdsapfct = '01'x Then Do                /* NORMAL path */\n                     ix = ix + 1\n                     pdsapfac = SUBSTR(line.j,ix,1)\n                     ix = ix + 1\n                     If pdsapfac \\= '00'x & pdsapfac \\= '01'x Then Do\n                        Say '*** WARNING - Invalid AC for 'pds2name' DBLK:'i\n                        nop\n                        End\n                     End\n                  If pdsapfct \\= '01'x & (BITAND(pds2indc,'80'x)='80'x) Then Do\n                     pdsapfac=' '\n                     ix = ix - 8\n                     Say '*** WARNING - Compacted alias logic for 'pds2name' DBLK:'i\n                     End\n                  End\n               End\n            Else Do                              /* too short udl, leave it */\n               ix = ix + udl\n               If pds2name = 'FFFFFFFFFFFFFFFF'x Then Do\n                  last = 1\n                  Leave\n                  End\n               Say '*** WARNING - too short udl for 'pds2name' DBLK:'i\n               pds2atr1 = '00'x\n               pds2atr2 = '00'x\n               pds2stor = '000000'x\n               pds2mnm  = '        '\n               pdsapfac = ' '\n               End\n            If (ix-1)//2 \\= 0 Then ix = ix + 1          /* halfword alignmt */\n            If pds2name = 'FFFFFFFFFFFFFFFF'x Then Do\n               last = 1\n               Leave\n               End\n            If pds2name \\= '0000000000000000'x Then Do\n               memcount = memcount + 1\n               Push ' 'LEFT(dsn,44,' ')' 'RIGHT(i,3,0),\n                    ' 'pds2name' TTR:'C2X(pds2ttrp),\n                    ' INDC:'C2X(pds2indc)' ATRBs:'C2X(pds2atr1),\n                    C2X(pds2atr2)' SIZE:'C2X(pds2stor),\n                    ' MAJ:'pds2mnm' AC:'C2X(pdsapfac),\n                    ' DBLK:'RIGHT(i,4,0)' UDL:'RIGHT(udl,2,0),\n                    ' IX:'RIGHT(ix,3,0)\n               End\n         End                                         /* DIRBLOCK parse done */\n      End\n      Say '       *** Directory blocks processed: 'j-1'  Members: 'memcount\n      Queue\n      'EXECIO * DISKW LPAPGMS (      '\n      Delstack\n      totpgms = totpgms + memcount\n   End\nEnd\nNewstack\nQueue\n'EXECIO * DISKW LPAPGMS ( FINIS'\nDelstack\nSay ' '\nSay 'Saved 'totpgms' PLPA program descriptor records to DASD'\nSay 'DSN: 'dsn2\nSay 'Return Code: 'RC\n\"FREE F(LPAPGMS)\"\nExit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "IOLPAQ": {"ttr": 2311, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00@\\x00\\x94\\x08\\x8f\\x01\\x14\\x05\\x0f\"V\\x00\\xb6\\x00\\xb6\\x00\\x00\\xe2\\xc3\\xd5\\xe2\\xf0\\xf3@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1994-03-29T00:00:00", "modifydate": "2014-02-19T22:56:40", "lines": 182, "newlines": 182, "modlines": 0, "user": "SCNS03"}, "text": "/*REXX*/\n/*****************************************************************/\n/*  IOLPAQ: REXX program to create LPAQ programs database.       */\n/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */\n/*****************************************************************/\n/* MVS DATA AREAS:                                               */\n/*                CVT - Communications Vector Table (@'10'x)     */\n/*                GDA - Global Data Area                         */\n/*               LPAQ - Link Pack Area Queue                     */\n/*                CDE - Contents Directory Entry                 */\n/*                                                               */\n/*****************************************************************/\n/*--------------virtual storage map definition section----------------*/\nNumeric Digits 10           /* required to handle decimal conversions */\n@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */\n@cvt = D2X(C2D(@cvt))                    /* binary to hex             */\n@cvtreal  = STORAGE(D2X(X2D(@cvt)+284),4)    /* get CVTREAL address   */\n@cvtreal  = D2X(C2D(@cvtreal))                 /* binary to hex       */\n@cvtshrvm = STORAGE(D2X(X2D(@cvt)+416),4)    /* get CVTSHRVM address  */\n@cvtshrvm = D2X(C2D(@cvtshrvm))                /* binary to hex       */\n@cvtgda   = STORAGE(D2X(X2D(@cvt)+560),4)    /* get CVTGDA address    */\n@cvtgda   = D2X(C2D(@cvtgda))                  /* binary to hex       */\n@gdacsa   = D2X(X2D(@cvtgda)+108)            /* locate GDACSAstarts   */\n@gdacsa   = D2X(C2D(STORAGE(@gdacsa,4)))       /*  get GDACSA         */\n@gdacsasz = D2X(X2D(@cvtgda)+112)            /* locate GDACSASiZe     */\n@gdacsasz = D2X(C2D(STORAGE(@gdacsasz,4)))     /*  get GDACSASiZe     */\n@gdaecsa  = D2X(X2D(@cvtgda)+124)            /* locate GDAECSAstarts  */\n@gdaecsa  = D2X(C2D(STORAGE(@gdaecsa,4)))      /*  get GDAECSA        */\n@gdaecsas = D2X(X2D(@cvtgda)+128)            /* locate GDAECSASize    */\n@gdaecsas = D2X(C2D(STORAGE(@gdaecsas,4)))     /*  get GDAECSAS       */\n@cvtsmext = STORAGE(D2X(X2D(@cvt)+1196),4)   /* get CVTSMEXT address  */\n@cvtsmext = D2X(C2D(@cvtsmext))                /* binary to hex       */\n@cvtmlpas = D2X(X2D(@cvtsmext)+8)            /* locate CVTMLPAStarts  */\n@cvtmlpas = D2X(C2D(STORAGE(@cvtmlpas,4)))     /*  get CVTMLPAS       */\n@cvtmlpae = D2X(X2D(@cvtsmext)+12)           /* locate CVTMLPAEnds    */\n@cvtmlpae = D2X(C2D(STORAGE(@cvtmlpae,4)))     /*  get CVTMLPAE       */\n@cvtflpas = D2X(X2D(@cvtsmext)+16)           /* locate CVTFLPAStarts  */\n@cvtflpas = D2X(C2D(STORAGE(@cvtflpas,4)))     /*  get CVTFLPAS       */\n@cvtflpae = D2X(X2D(@cvtsmext)+20)           /* locate CVTFLPAEnds    */\n@cvtflpae = D2X(C2D(STORAGE(@cvtflpae,4)))     /*  get CVTFLPAE       */\n@cvtplpas = D2X(X2D(@cvtsmext)+24)           /* locate CVTPLPAStarts  */\n@cvtplpas = D2X(C2D(STORAGE(@cvtplpas,4)))     /*  get CVTPLPAS       */\n@cvtplpae = D2X(X2D(@cvtsmext)+28)           /* locate CVTPLPAEnds    */\n@cvtplpae = D2X(C2D(STORAGE(@cvtplpae,4)))     /*  get CVTPLPAE       */\n@cvtrwns  = D2X(X2D(@cvtsmext)+32)           /* locate CVTRWNStarts   */\n@cvtrwns  = D2X(C2D(STORAGE(@cvtrwns,4)))      /*  get CVTRWNS        */\n@cvtrwne  = D2X(X2D(@cvtsmext)+36)           /* locate CVTRWNEnds     */\n@cvtrwne  = D2X(C2D(STORAGE(@cvtrwne,4)))      /*  get CVTRWNE        */\n@cvtrons  = D2X(X2D(@cvtsmext)+40)           /* locate CVTRONStarts   */\n@cvtrons  = D2X(C2D(STORAGE(@cvtrons,4)))      /*  get CVTRONS        */\n@cvtrone  = D2X(X2D(@cvtsmext)+44)           /* locate CVTRONEnds     */\n@cvtrone  = D2X(C2D(STORAGE(@cvtrone,4)))      /*  get CVTRONE        */\n@cvterwns = D2X(X2D(@cvtsmext)+48)           /* locate CVTERWNStarts  */\n@cvterwns = D2X(C2D(STORAGE(@cvterwns,4)))     /*  get CVTERWNS       */\n@cvterwne = D2X(X2D(@cvtsmext)+52)           /* locate CVTERWNEnds    */\n@cvterwne = D2X(C2D(STORAGE(@cvterwne,4)))     /*  get CVTRRWNE       */\n@cvteplps = D2X(X2D(@cvtsmext)+56)           /* locate CVTEPLPStarts  */\n@cvteplps = D2X(C2D(STORAGE(@cvteplps,4)))     /*  get CVTEPLPS       */\n@cvteplpe = D2X(X2D(@cvtsmext)+60)           /* locate CVTEPLPEnds    */\n@cvteplpe = D2X(C2D(STORAGE(@cvteplpe,4)))     /*  get CVTRPLPE       */\n@cvteflps = D2X(X2D(@cvtsmext)+64)           /* locate CVTEFLPStarts  */\n@cvteflps = D2X(C2D(STORAGE(@cvteflps,4)))     /*  get CVTEFLPS       */\n@cvteflpe = D2X(X2D(@cvtsmext)+68)           /* locate CVTEFLPEnds    */\n@cvteflpe = D2X(C2D(STORAGE(@cvteflpe,4)))     /*  get CVTRFLPE       */\n@cvtemlps = D2X(X2D(@cvtsmext)+72)           /* locate CVTEMLPStarts  */\n@cvtemlps = D2X(C2D(STORAGE(@cvtemlps,4)))     /*  get CVTEMLPS       */\n@cvtemlpe = D2X(X2D(@cvtsmext)+76)           /* locate CVTEMLPEnds    */\n@cvtemlpe = D2X(C2D(STORAGE(@cvtemlpe,4)))     /*  get CVTRMLPE       */\n        /*------simplify variable names & make addresses decimal------*/\n@csa1g  = @gdacsa    ; @csa2g = D2X(X2D(@gdacsasz)+X2D(@gdacsa)-1)/* g*/\n   csa1 = X2D(@csa1g) ; csa2 = X2D(@csa2g)                    /* csa  */\n@mlpa1  = @cvtmlpas  ; @mlpa2 = @cvtmlpae                     /* mlpa */\n   mlpa1 = X2D(@mlpa1) ; mlpa2 = X2D(@mlpa2)\n@flpa1  = @cvtflpas  ; @flpa2 = @cvtflpae                     /* flpa */\n   flpa1 = X2D(@flpa1) ; flpa2 = X2D(@flpa2)\n@plpa1  = @cvtplpas  ; @plpa2 = @cvtplpae                     /* plpa */\n   plpa1 = X2D(@plpa1) ; plpa2 = X2D(@plpa2)\n@sqa1   = D2X(X2D(@cvtplpae)+1) ; @sqa2 = D2X(X2D(@cvtrwns)-1)/* sqa  */\n   sqa1 = X2D(@sqa1) ; sqa2 = X2D(@sqa2)\n@nuc1   = @cvtrwns   ; @nuc2  = @cvterwne                     /* nuc  */\n   nuc1 = X2D(@nuc1) ; nuc2 = X2D(@nuc2)\n@esqa1  = D2X(X2D(@nuc2)+1) ; @esqa2 = D2X(X2D(@cvteplps)-1)  /* esqa */\n  esqa1 = X2D(@esqa1) ; esqa2 = X2D(@esqa2)\n@eplpa1 = @cvteplps  ; @eplpa2 = @cvteplpe                    /* eplpa*/\n eplpa1 = X2D(@eplpa1) ; eplpa2 = X2D(@eplpa2)\n@eflpa1 = @cvteflps  ; @eflpa2 = @cvteflpe                    /* eflpa*/\n eflpa1 = X2D(@eflpa1) ; eflpa2 = X2D(@eflpa2)\n@emlpa1 = @cvtemlps  ; @emlpa2 = @cvtemlpe                    /* emlpa*/\n emlpa1 = X2D(@emlpa1) ; emlpa2 = X2D(@emlpa2)\n@ecsa1g = @gdaecsa   ; @ecsa2g= D2X(X2D(@gdaecsas)+X2D(@gdaecsa)-1)/*g*/\n  ecsa1 = X2D(@ecsa1g) ; ecsa2 = X2D(@ecsa2g)\n@eprivs = X2D(@ecsa2g)+1                               /* ext private */\n@eprive = 2147483647                         /* fixed by architecture */\n epriv1 = @eprivs ; epriv2 = @eprive\n@psas   = 0 ; @psae = 4095                       /* psa fixed by arch */\n   psa1 = @psas ; psa2 = @psae\n@prive  = X2D(@csa1g)-1 ; @privs = X2D(@psae)+1            /* private */\n  priv1 = @privs ; priv2 = @prive\n              /*------------------------------------------------------*/\n             /* Usage Notes: Hex character compares are incompatible */\n            /*    for storage residency determination.  Thus, entry */\n           /*     point addresses must be converted to decimal and */\n          /*      VS boundary addresses must be converted to de-  */\n         /*       cimal for correct compare operations.          */\n        /*------------------------------------------------------*/\n/*----------end of virtual storage map definition section-------------*/\n@cvtqlpaq = STORAGE(D2X(X2D(@cvt)+188),4)    /* get CVTqlpaq address  */\n@cvtqlpaq = D2X(C2D(@cvtqlpaq))                /* binary to hex       */\n@lpaqptr  = STORAGE(@cvtqlpaq,4)             /* get pointer to LPAQ   */\n@lpaqptr  = D2X(C2D(@lpaqptr))                 /* binary to hex       */\nAddress TSO ; \"CLEAR\"\nSay 'CVT:'@cvt' CVTQLPAQ:'@cvtqlpaq' LPAQPTR:'@lpaqptr' 'DATE() TIME()\n@cdechn = @lpaqptr\nSay ' '\ndsn = 'MVS.LPAQ.CDECHAIN'           /* assign a pseudo data set name */\ni = 0 ; d = Date() ; t = Time()\nNewstack\nDo While @cdechn \\= '00000000'\n   i = i + 1\n   cde = STORAGE(@cdechn,32)                          /* get the cde */\n   cdname = SUBSTR(cde,9,8)\n   cdentpt= SUBSTR(cde,17,4)\n                                        /* determine storage location */\n   addr = BITAND(cdentpt,'7FFFFFFF'x)     /* shave off amode bit (32) */\n   addr = C2D(addr)                      /* make numeric for compares */\n   sloc = 'ERROR'                       /* determine module residency */\n   If (addr >= csa1   & addr <= csa2  ) Then sloc = 'CSA  '\n      Else If (addr >= mlpa1  & addr <= mlpa2 ) Then sloc = 'MLPA '\n      Else If (addr >= flpa1  & addr <= flpa2 ) Then sloc = 'FLPA '\n      Else If (addr >= plpa1  & addr <= plpa2 ) Then sloc = 'PLPA '\n      Else If (addr >= sqa1   & addr <= sqa2  ) Then sloc = 'SQA  '\n      Else If (addr >= nuc1   & addr <= nuc2  ) Then sloc = 'NUC  '\n      Else If (addr >= esqa1  & addr <= esqa2 ) Then sloc = 'ESQA '\n      Else If (addr >= eplpa1 & addr <= eplpa2) Then sloc = 'EPLPA'\n      Else If (addr >= eflpa1 & addr <= eflpa2) Then sloc = 'EFLPA'\n      Else If (addr >= emlpa1 & addr <= emlpa2) Then sloc = 'EMLPA'\n      Else If (addr >= ecsa1  & addr <= ecsa2 ) Then sloc = 'ECSA '\n      Else If (addr >= epriv1 & addr <= epriv2) Then sloc = 'EPRIV'\n      Else If (addr >= priv1  & addr <= priv2 ) Then sloc = 'PRIV '\n      Else If (addr >= psa1   & addr <= psa2  ) Then sloc = 'PSA  '\n   cdxlmjp= C2X(SUBSTR(cde,21,4))\n   cduse  = C2D(SUBSTR(cde,25,2))\n   cdattr =     SUBSTR(cde,29,1)  /* do NOT convert raw byte */\n   alias = 0 ; If (BITAND(cdattr,'04'x)='04'x) Then alias = 1\n   cdattr2 = SUBSTR(cde,30,1)       /* do NOT convert raw byte */\n   auth = 0 ; If (BITAND(cdattr2,'01'x)='01'x) Then auth = 1\n   cdemjp  = '         '\n   cdemjnm = '        '\n   If alias = 1 Then Do\n                        cdemjp  = ' Alias of'\n                        cdemjnm = STORAGE(D2X(X2D(cdxlmjp)+8),8)\n                     End\n   Push ' 'LEFT(dsn,44,' ')' 'RIGHT(i,4,0),\n       cdname ,\n       C2X(cdentpt) ,\n       sloc ,\n       'USE:'RIGHT(cduse,5,0) ,\n        'AC:'auth ,\n        cdemjp cdemjnm d t\n   @cdechn = C2X(LEFT(cde,4))                 /* get next cde address */\nEnd\nSay ' '\nSay 'End of LPA Queue scan ' Time()\nSay ' '\n/***************************************************************/\n/* Now save the stack to our LPAQMODS data set                 */\n/***************************************************************/\ndsn2 = sysvar(sysuid) || '.LPAQMODS.DATA.WORK'\n\"ALLOC F(LPAQMODS) DA('\"dsn2\"') OLD RELEASE\"\nIf RC \\= 0 Then Do\n   Say 'IOLPAQ failed on 'dsn2' error: 'RC\n   Exit\n   End\nQueue\n'EXECIO * DISKW LPAQMODS ( FINIS'\nDelstack\nSay ' '\nSay 'Saved 'i' LPAQ program descriptor records to DASD'\nSay 'DSN: 'dsn2\nSay 'Return Code: 'RC\n\"FREE F(LPAQMODS)\"\nExit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "IONUCM": {"ttr": 3083, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x11\\x00\\x94\\x08\\x8f\\x01\\x14\\x05\\x0f#\\x00\\x00P\\x00P\\x00\\x00\\xe2\\xc3\\xd5\\xe2\\xf0\\xf3@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1994-03-29T00:00:00", "modifydate": "2014-02-19T23:00:11", "lines": 80, "newlines": 80, "modlines": 0, "user": "SCNS03"}, "text": "/*REXX*/\n/*****************************************************************/\n/*  IONUCM: REXX program to create nucleus map data set.         */\n/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */\n/*****************************************************************/\n/* MVS DATA AREAS:                                               */\n/*                CVT - Communications Vector Table (@'10'x)     */\n/*              NUCMP - Nucleus Map Table (16 bytes by n rows)   */\n/*                                                               */\n/*****************************************************************/\nNumeric Digits 10\n@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */\n@cvt = D2X(C2D(@cvt))                    /* binary to hex             */\n@cvtnucmp = STORAGE(D2X(X2D(@cvt)+1200),4)   /* get CVTNUCMP address  */\n@cvtnucmp = D2X(C2D(@cvtnucmp))                /* binary to hex       */\nnucmapid  = STORAGE(@cvtnucmp,8)           /* nucmap eyecatcher entry */\nnucmeot   = C2D(STORAGE(D2X(X2D(@cvtnucmp)+8),4))  /* table end addrs */\nnucmlen   = C2D(STORAGE(D2X(X2D(@cvtnucmp)+13),3)) /* nucm tbl length */\n@nucmentry= X2D(@cvtnucmp)+16          /* address of 1st nucmap entry */\nAddress TSO ; 'CLEAR'\nSay 'CVT:'@cvt  'CVTNUCMP:'@cvtnucmp'  NUCMLEN:'nucmlen' bytes',\n    '  'DATE() TIME()\nSay ' '\nIf nucmapid \\= 'NUCMAP  ' Then Do\n   Say 'Error: Nucleus map table eyecatcher not found'\n   Exit\n   End\ni = 0 ; d = DATE() ; t = TIME()\nDo While @nucmentry <= nucmeot                  /* loop thru storage  */\n   i = i + 1\n   epname.i = STORAGE(D2X(@nucmentry),8)      /* get entry point name */\n   epaddr.i = C2X(STORAGE(D2X(@nucmentry+8),4))     /* get ep address */\n   epflag.i = STORAGE(D2X(@nucmentry+12),1)      /* get raw flag byte */\n   eplen.i  = C2X(STORAGE(D2X(@nucmentry+13),3))     /* get ep length */\n   @nucmentry = @nucmentry + 16                 /* bump to next entry */\nEnd\nentries = i\n/*--------------------------------------------------------------*/\n/* epflag byte structure:                                       */\n/*                                                              */\n/*           XXXX XXXX --> epflag byte                          */\n/*           |||| ||||                                          */\n/*           |||| ||++---- AMODE 00/01=24, 10=31, 11=ANY        */\n/*           |||| |+------ RMODE 0=24, 1=ANY                    */\n/*           |||| +------- RSECT 1=yes                          */\n/*           |||+--------- CSECT 1=yes                          */\n/*           +++---------- unused                               */\n/*--------------------------------------------------------------*/\nNewstack\nDo i = 1 to entries                             /* print the list     */\n   csect = '  N  ' ; rsect = '  N  ' ; rmode = '  24 ' ; amode = '  24 '\n   If BITAND(epflag.i,'10'x)='10'x Then csect = '  Y  ' /* is a csect */\n   If BITAND(epflag.i,'08'x)='08'x Then rsect = '  Y  ' /* read only  */\n   If BITAND(epflag.i,'04'x)='04'x Then rmode = ' Any ' /* residency  */\n   If BITAND(epflag.i,'02'x)='02'x Then amode = '  31 ' /* addressing */\n   If BITAND(epflag.i,'03'x)='03'x Then amode = ' Any ' /* addressing */\n   Push ' NUCM'Right(i,4,0) epname.i epaddr.i csect,\n                  rsect rmode amode eplen.i d t\nEnd\nSay ' '\nSay 'End of Nucleus Map Table scan ' TIME()\nSay ' '\n/***************************************************************/\n/* Now save the stack to our NUCMAP data set                   */\n/***************************************************************/\ndsn2 = sysvar(sysuid) || '.NUCMAP.DATA.WORK'\n\"ALLOC F(NUCMAP) DA('\"dsn2\"') OLD RELEASE\"\nIf RC \\= 0 Then Do\n   Say 'IONUCM failed on 'dsn2' error: 'RC\n   Exit\n   End\nQueue\n'EXECIO * DISKW NUCMAP ( FINIS'\nDelstack\nSay ' '\nSay 'Saved 'entries' NUCMAP program descriptor records to DASD'\nSay 'DSN: 'dsn2\nSay 'Return Code: 'RC\n\"FREE F(NUCMAP)\"\nExit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "IOPCAUTH": {"ttr": 2314, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0e\\x00C\\x00\\x94\\x08\\x8f\\x01\\x14\\x05\\x0f\"V\\x00\\xfb\\x00\\xfb\\x00\\x00\\xe2\\xc3\\xd5\\xe2\\xf0\\xf3@@@@'", "ispf": {"version": "01.14", "flags": 0, "createdate": "1994-03-29T00:00:00", "modifydate": "2014-02-19T22:56:43", "lines": 251, "newlines": 251, "modlines": 0, "user": "SCNS03"}, "text": "/*REXX*/\n/*****************************************************************/\n/*IOPCAUTH: REXX program to obtain PC table from PCAUTH addspc.  */\n/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */\n/*****************************************************************/\n/* MVS DATA AREAS:                                               */\n/*                CVT - Communications Vector Table (@'10'x)     */\n/*               ASVT - Address Space Vector Table               */\n/*               ASCB - Address Space Control Block              */\n/*               OUCB - SRM User Control Block                   */\n/*              Other - calls assembler SNAP macro for PCDATA    */\n/*                                                               */\n/*****************************************************************/\n/*                                                               */\n/*****************************************************************/\n/*  First, get address space names (ASN) to associate with the   */\n/*  EXEC ASID field in the PCAUTH table.                         */\n/*****************************************************************/\n@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */\n@cvt = D2X(C2D(@cvt))                    /* binary to dec to hex      */\n@cvtasvt  = STORAGE(D2X(X2D(@cvt)+556),4)    /* get CVTASVT address   */\n@cvtasvt  = D2X(C2D(@cvtasvt))                 /* binary to dec to hex*/\nAddress TSO ; \"CLEAR\"\nSay 'CVT: '@cvt 'CVTASVT: '@cvtasvt' ===> Scan on 'DATE()'.  Started: 'TIME()\n@asvt = @cvtasvt\nasvtmaxu = STORAGE(D2X(X2D(@asvt)+516),4) /* get maxuser (table size) */\nDo i = 1 to C2D(asvtmaxu)                  /* initialize name buckets */\n   asn.i = 'Unknown '\nEnd\nasn.0 = '*Caller*'   /* if exec asid in pcauth is zero */\nj = 0 ; k = 0 ; tablend = 524 + (4 * (C2D(asvtmaxu)-1))\nDo i = 524 to tablend By 4                      /* loop thru the ASVT */\n   j = j + 1                            /* count asvt slots processed */\n   @ascb = STORAGE(D2X(X2D(@asvt)+i),4)        /* get address of ASCB */\n   If BITAND(LEFT(@ascb,1),'80'x)\\='80'x Then Do   /* bit off, in use */\n      k = k + 1                                /* count active adrspc */\n      ascbasid = STORAGE(D2X(C2D(@ascb)+36),2)            /* get ASID */\n      x = C2D(ascbasid)    /* convert for indexing */\n      @ascboucb = STORAGE(D2X(C2D(@ascb)+144),4)  /* get OUCB address */\n      @ascbjbni = STORAGE(D2X(C2D(@ascb)+172),4)  /* get JOBN address */\n      jbni = '        ' ; @ascbjbni = D2X(C2D(@ascbjbni))\n      If @ascbjbni \\= 0 Then jbni = STORAGE(@ascbjbni,8)\n      @ascbjbns = STORAGE(D2X(C2D(@ascb)+176),4)  /* get STCN address */\n      jbns = '        ' ; @ascbjbns = D2X(C2D(@ascbjbns))\n      If @ascbjbns \\= 0 Then jbns = STORAGE(@ascbjbns,8)\n      oucbsubn = STORAGE(D2X(C2D(@ascboucb)+176),4)    /* subsys name */\n      oucbtrxn = STORAGE(D2X(C2D(@ascboucb)+200),8)    /* transn name */\n      oucbusrd = STORAGE(D2X(C2D(@ascboucb)+208),8)         /* userid */\n      /* BATCH JOBS */\n      If oucbsubn = 'JES2' & jbns = 'INIT    ' & jbni = oucbtrxn Then Do\n         asn.x = oucbtrxn\n         nop\n         End\n      /* TSO USERS  */\n      If oucbsubn = 'TSO ' Then Do\n         If oucbusrd = '        ' Then asn.x = '????????' /* missing lid */\n                                  Else asn.x = oucbusrd\n         nop\n         End\n      /* STARTED TASKS */\n      If oucbsubn = 'STC ' & oucbtrxn \\= 'INIT    ' & jbns \\= 'INIT    ' Then Do\n         asn.x = oucbtrxn\n         nop\n         End\n      End\nEnd\nSay ' '\nSay 'SNAP SDATA=(PCDATA) macro called ' Date() Time()\nSay ' '\ndsn = sysvar(sysuid) || '.PCAUTH.DATA.WORK'\n\"ALLOC F(SNAPRINT) DA('\"dsn\"') OLD RELEASE\"\npgm = 'SCSP.LOAD(SNAPPC)'\n\"CALL '\"PGM\"'\"\nIf RC \\= 0 Then Do\n   Say '  *** SNAP program failed on error: 'RC\n   Exit\n   End\nSay 'Processing SNAP macro output     ' Date() Time()\nSay ' '\n\"ALLOC F(SNAPRINT) DA('\"dsn\"') SHR\"\nNewstack\n'EXECIO * DISKR SNAPRINT ( FINIS'\nIf RC \\= 0 Then Do\n   Say '  *** SNAP process failed on error: 'RC\n   Exit\n   End\n\"FREE F(SNAPRINT)\"\nQueue '*EOF*'\ni = 0 ; j = 0 ; d = Date() ; t = Time()\nDo while i < 2000\n  i = i + 1\n  Pull line\n  If LEFT(line,5) = '*EOF*'  Then Leave\n  /* Say line */             /* uncomment say to see SNAP output */\n  x = SUBSTR(line,13,4)      /*@extract & test AUTH KEY MASK */\n  y = SUBSTR(line,25,8)      /*@extract & test ENTRY ADDRESS */\n  z = SUBSTR(line,42,8)      /*@extract & test LATENT PARMS  */\n  /* Simple validity test for a PC INFORMATION line from SNAP output */\n  If DATATYPE(x,'X')=1 & DATATYPE(y,'X')=1 & DATATYPE(z,'X')=1 Then Do\n     j     = j + 1               /* INCREMENT PC ENTRY COUNTER */\n     pc.j  = SUBSTR(line,5,6)    /*@PC NUM        */\n     akm.j = x                   /* AUTH KEY MASK */\n     ex.j  = SUBSTR(line,19,4)   /*@EXEC ASID     */\n     ea.j  = y                   /* ENTRY ADDRESS */\n     es.j  = SUBSTR(line,37,1)   /*@EXEC STATE    */\n     lp.j  = z                   /* LATENT PARMS  */\n     ekm.j = SUBSTR(line,62,4)   /*@EXEC KEY MASK */\n     End\nEnd\nDelstack\nSay 'Processing statistics:'\nSay '                        REPORT OUTPUT  'RIGHT(i-1,4)' lines.'\nSay '                        PC INFORMATION 'RIGHT(j,4)' lines.'\nSay ' '\nSay 'PC INFORMATION analysis completed ' Time()\n/*-----------------------------------------------------------------*/\n/*  Now get virtual storage map to classify pcauth entry address   */\n/*-----------------------------------------------------------------*/\n/*--------------virtual storage map definition section----------------*/\nNumeric Digits 10           /* required to handle decimal conversions */\n@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */\n@cvt = D2X(C2D(@cvt))                    /* binary to hex             */\n@cvtreal  = STORAGE(D2X(X2D(@cvt)+284),4)    /* get CVTREAL address   */\n@cvtreal  = D2X(C2D(@cvtreal))                 /* binary to hex       */\n@cvtshrvm = STORAGE(D2X(X2D(@cvt)+416),4)    /* get CVTSHRVM address  */\n@cvtshrvm = D2X(C2D(@cvtshrvm))                /* binary to hex       */\n@cvtgda   = STORAGE(D2X(X2D(@cvt)+560),4)    /* get CVTGDA address    */\n@cvtgda   = D2X(C2D(@cvtgda))                  /* binary to hex       */\n@gdacsa   = D2X(X2D(@cvtgda)+108)            /* locate GDACSAstarts   */\n@gdacsa   = D2X(C2D(STORAGE(@gdacsa,4)))       /*  get GDACSA         */\n@gdacsasz = D2X(X2D(@cvtgda)+112)            /* locate GDACSASiZe     */\n@gdacsasz = D2X(C2D(STORAGE(@gdacsasz,4)))     /*  get GDACSASiZe     */\n@gdaecsa  = D2X(X2D(@cvtgda)+124)            /* locate GDAECSAstarts  */\n@gdaecsa  = D2X(C2D(STORAGE(@gdaecsa,4)))      /*  get GDAECSA        */\n@gdaecsas = D2X(X2D(@cvtgda)+128)            /* locate GDAECSASize    */\n@gdaecsas = D2X(C2D(STORAGE(@gdaecsas,4)))     /*  get GDAECSAS       */\n@cvtsmext = STORAGE(D2X(X2D(@cvt)+1196),4)   /* get CVTSMEXT address  */\n@cvtsmext = D2X(C2D(@cvtsmext))                /* binary to hex       */\n@cvtmlpas = D2X(X2D(@cvtsmext)+8)            /* locate CVTMLPAStarts  */\n@cvtmlpas = D2X(C2D(STORAGE(@cvtmlpas,4)))     /*  get CVTMLPAS       */\n@cvtmlpae = D2X(X2D(@cvtsmext)+12)           /* locate CVTMLPAEnds    */\n@cvtmlpae = D2X(C2D(STORAGE(@cvtmlpae,4)))     /*  get CVTMLPAE       */\n@cvtflpas = D2X(X2D(@cvtsmext)+16)           /* locate CVTFLPAStarts  */\n@cvtflpas = D2X(C2D(STORAGE(@cvtflpas,4)))     /*  get CVTFLPAS       */\n@cvtflpae = D2X(X2D(@cvtsmext)+20)           /* locate CVTFLPAEnds    */\n@cvtflpae = D2X(C2D(STORAGE(@cvtflpae,4)))     /*  get CVTFLPAE       */\n@cvtplpas = D2X(X2D(@cvtsmext)+24)           /* locate CVTPLPAStarts  */\n@cvtplpas = D2X(C2D(STORAGE(@cvtplpas,4)))     /*  get CVTPLPAS       */\n@cvtplpae = D2X(X2D(@cvtsmext)+28)           /* locate CVTPLPAEnds    */\n@cvtplpae = D2X(C2D(STORAGE(@cvtplpae,4)))     /*  get CVTPLPAE       */\n@cvtrwns  = D2X(X2D(@cvtsmext)+32)           /* locate CVTRWNStarts   */\n@cvtrwns  = D2X(C2D(STORAGE(@cvtrwns,4)))      /*  get CVTRWNS        */\n@cvtrwne  = D2X(X2D(@cvtsmext)+36)           /* locate CVTRWNEnds     */\n@cvtrwne  = D2X(C2D(STORAGE(@cvtrwne,4)))      /*  get CVTRWNE        */\n@cvtrons  = D2X(X2D(@cvtsmext)+40)           /* locate CVTRONStarts   */\n@cvtrons  = D2X(C2D(STORAGE(@cvtrons,4)))      /*  get CVTRONS        */\n@cvtrone  = D2X(X2D(@cvtsmext)+44)           /* locate CVTRONEnds     */\n@cvtrone  = D2X(C2D(STORAGE(@cvtrone,4)))      /*  get CVTRONE        */\n@cvterwns = D2X(X2D(@cvtsmext)+48)           /* locate CVTERWNStarts  */\n@cvterwns = D2X(C2D(STORAGE(@cvterwns,4)))     /*  get CVTERWNS       */\n@cvterwne = D2X(X2D(@cvtsmext)+52)           /* locate CVTERWNEnds    */\n@cvterwne = D2X(C2D(STORAGE(@cvterwne,4)))     /*  get CVTRRWNE       */\n@cvteplps = D2X(X2D(@cvtsmext)+56)           /* locate CVTEPLPStarts  */\n@cvteplps = D2X(C2D(STORAGE(@cvteplps,4)))     /*  get CVTEPLPS       */\n@cvteplpe = D2X(X2D(@cvtsmext)+60)           /* locate CVTEPLPEnds    */\n@cvteplpe = D2X(C2D(STORAGE(@cvteplpe,4)))     /*  get CVTRPLPE       */\n@cvteflps = D2X(X2D(@cvtsmext)+64)           /* locate CVTEFLPStarts  */\n@cvteflps = D2X(C2D(STORAGE(@cvteflps,4)))     /*  get CVTEFLPS       */\n@cvteflpe = D2X(X2D(@cvtsmext)+68)           /* locate CVTEFLPEnds    */\n@cvteflpe = D2X(C2D(STORAGE(@cvteflpe,4)))     /*  get CVTRFLPE       */\n@cvtemlps = D2X(X2D(@cvtsmext)+72)           /* locate CVTEMLPStarts  */\n@cvtemlps = D2X(C2D(STORAGE(@cvtemlps,4)))     /*  get CVTEMLPS       */\n@cvtemlpe = D2X(X2D(@cvtsmext)+76)           /* locate CVTEMLPEnds    */\n@cvtemlpe = D2X(C2D(STORAGE(@cvtemlpe,4)))     /*  get CVTRMLPE       */\n        /*------simplify variable names & make addresses decimal------*/\n@csa1g  = @gdacsa    ; @csa2g = D2X(X2D(@gdacsasz)+X2D(@gdacsa)-1)/* g*/\n   csa1 = X2D(@csa1g) ; csa2 = X2D(@csa2g)                    /* csa  */\n@mlpa1  = @cvtmlpas  ; @mlpa2 = @cvtmlpae                     /* mlpa */\n   mlpa1 = X2D(@mlpa1) ; mlpa2 = X2D(@mlpa2)\n@flpa1  = @cvtflpas  ; @flpa2 = @cvtflpae                     /* flpa */\n   flpa1 = X2D(@flpa1) ; flpa2 = X2D(@flpa2)\n@plpa1  = @cvtplpas  ; @plpa2 = @cvtplpae                     /* plpa */\n   plpa1 = X2D(@plpa1) ; plpa2 = X2D(@plpa2)\n@sqa1   = D2X(X2D(@cvtplpae)+1) ; @sqa2 = D2X(X2D(@cvtrwns)-1)/* sqa  */\n   sqa1 = X2D(@sqa1) ; sqa2 = X2D(@sqa2)\n@nuc1   = @cvtrwns   ; @nuc2  = @cvterwne                     /* nuc  */\n   nuc1 = X2D(@nuc1) ; nuc2 = X2D(@nuc2)\n@esqa1  = D2X(X2D(@nuc2)+1) ; @esqa2 = D2X(X2D(@cvteplps)-1)  /* esqa */\n  esqa1 = X2D(@esqa1) ; esqa2 = X2D(@esqa2)\n@eplpa1 = @cvteplps  ; @eplpa2 = @cvteplpe                    /* eplpa*/\n eplpa1 = X2D(@eplpa1) ; eplpa2 = X2D(@eplpa2)\n@eflpa1 = @cvteflps  ; @eflpa2 = @cvteflpe                    /* eflpa*/\n eflpa1 = X2D(@eflpa1) ; eflpa2 = X2D(@eflpa2)\n@emlpa1 = @cvtemlps  ; @emlpa2 = @cvtemlpe                    /* emlpa*/\n emlpa1 = X2D(@emlpa1) ; emlpa2 = X2D(@emlpa2)\n@ecsa1g = @gdaecsa   ; @ecsa2g= D2X(X2D(@gdaecsas)+X2D(@gdaecsa)-1)/*g*/\n  ecsa1 = X2D(@ecsa1g) ; ecsa2 = X2D(@ecsa2g)\n@eprivs = X2D(@ecsa2g)+1                               /* ext private */\n@eprive = 2147483647                         /* fixed by architecture */\n epriv1 = @eprivs ; epriv2 = @eprive\n@psas   = 0 ; @psae = 4095                       /* psa fixed by arch */\n   psa1 = @psas ; psa2 = @psae\n@prive  = X2D(@csa1g)-1 ; @privs = X2D(@psae)+1            /* private */\n  priv1 = @privs ; priv2 = @prive\n              /*------------------------------------------------------*/\n             /* Usage Notes: Hex character compares are incompatible */\n            /*    for storage residency determination.  Thus, entry */\n           /*     point addresses must be converted to decimal and */\n          /*      VS boundary addresses must be converted to de-  */\n         /*       cimal for correct compare operations.          */\n        /*------------------------------------------------------*/\n/*----------end of virtual storage map definition section-------------*/\n/*-----------------------------------------------------------------*/\n/*  Now reload a new stack with the parse output STEM'd from above */\n/*-----------------------------------------------------------------*/\nNewstack\ndsn2 = 'MVS.PCAUTH.PCTABLE'      /* assign a pseudo data set name  */\nDo i = j to 1 By -1              /* reverse stack unload on execio */\n                                        /* determine storage location */\n  k = X2D(ex.i) ; asname = asn.k    /* map address space name */\n/*addr = BITAND(X2C(ea.i),'7FFFFFFF'x)      shave off amode bit (32) */\n  addr = ea.i ; If LEFT(addr,1)='8' Then addr = SUBSTR(addr,2,7)\n  addr = X2D(addr)                      /* make numeric for compares */\n  sloc = 'ERROR'                       /* determine module residency */\n  If (addr >= csa1   & addr <= csa2  ) Then sloc = 'CSA  '\n     Else If (addr >= mlpa1  & addr <= mlpa2 ) Then sloc = 'MLPA '\n     Else If (addr >= flpa1  & addr <= flpa2 ) Then sloc = 'FLPA '\n     Else If (addr >= plpa1  & addr <= plpa2 ) Then sloc = 'PLPA '\n     Else If (addr >= sqa1   & addr <= sqa2  ) Then sloc = 'SQA  '\n     Else If (addr >= nuc1   & addr <= nuc2  ) Then sloc = 'NUC  '\n     Else If (addr >= esqa1  & addr <= esqa2 ) Then sloc = 'ESQA '\n     Else If (addr >= eplpa1 & addr <= eplpa2) Then sloc = 'EPLPA'\n     Else If (addr >= eflpa1 & addr <= eflpa2) Then sloc = 'EFLPA'\n     Else If (addr >= emlpa1 & addr <= emlpa2) Then sloc = 'EMLPA'\n     Else If (addr >= ecsa1  & addr <= ecsa2 ) Then sloc = 'ECSA '\n     Else If (addr >= epriv1 & addr <= epriv2) Then sloc = 'EPRIV'\n     Else If (addr >= priv1  & addr <= priv2 ) Then sloc = 'PRIV '\n     Else If (addr >= psa1   & addr <= psa2  ) Then sloc = 'PSA  '\n  Push ' 'LEFT(dsn2,44,' '),\n        pc.i akm.i ex.i asname ea.i sloc es.i ekm.i d t\nEnd\nQueue\n\"ALLOC F(SNAPRINT) DA('\"dsn\"') OLD RELEASE\"\n'EXECIO * DISKW SNAPRINT ( FINIS'\n\"FREE F(SNAPRINT)\"\nDelstack\nSay ' '\nSay 'Saved 'j' PC instruction descriptor records to DASD'\nSay 'DSN: 'dsn\nSay 'Return Code: 'RC\nExit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "IOPLPA": {"ttr": 2561, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00E\\x00\\x94\\x08\\x8f\\x01\\x14\\x05\\x0f\"V\\x00\\xb3\\x00\\xb3\\x00\\x00\\xe2\\xc3\\xd5\\xe2\\xf0\\xf3@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1994-03-29T00:00:00", "modifydate": "2014-02-19T22:56:45", "lines": 179, "newlines": 179, "modlines": 0, "user": "SCNS03"}, "text": "/*REXX*/\n/*****************************************************************/\n/*  IOPLPA: REXX program to copy PLPA directory to a dataset.    */\n/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */\n/*****************************************************************/\n/* MVS DATA AREAS:                                               */\n/*                CVT - Communications Vector Table (@'10'x)     */\n/*                GDA - Global Data Area                         */\n/*               LPDE - Link Pack Directory Entry                */\n/*                                                               */\n/*****************************************************************/\n/*--------------virtual storage map definition section----------------*/\nNumeric Digits 10           /* required to handle decimal conversions */\n@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */\n@cvt = D2X(C2D(@cvt))                    /* binary to hex             */\n@cvtreal  = STORAGE(D2X(X2D(@cvt)+284),4)    /* get CVTREAL address   */\n@cvtreal  = D2X(C2D(@cvtreal))                 /* binary to hex       */\n@cvtshrvm = STORAGE(D2X(X2D(@cvt)+416),4)    /* get CVTSHRVM address  */\n@cvtshrvm = D2X(C2D(@cvtshrvm))                /* binary to hex       */\n@cvtgda   = STORAGE(D2X(X2D(@cvt)+560),4)    /* get CVTGDA address    */\n@cvtgda   = D2X(C2D(@cvtgda))                  /* binary to hex       */\n@gdacsa   = D2X(X2D(@cvtgda)+108)            /* locate GDACSAstarts   */\n@gdacsa   = D2X(C2D(STORAGE(@gdacsa,4)))       /*  get GDACSA         */\n@gdacsasz = D2X(X2D(@cvtgda)+112)            /* locate GDACSASiZe     */\n@gdacsasz = D2X(C2D(STORAGE(@gdacsasz,4)))     /*  get GDACSASiZe     */\n@gdaecsa  = D2X(X2D(@cvtgda)+124)            /* locate GDAECSAstarts  */\n@gdaecsa  = D2X(C2D(STORAGE(@gdaecsa,4)))      /*  get GDAECSA        */\n@gdaecsas = D2X(X2D(@cvtgda)+128)            /* locate GDAECSASize    */\n@gdaecsas = D2X(C2D(STORAGE(@gdaecsas,4)))     /*  get GDAECSAS       */\n@cvtsmext = STORAGE(D2X(X2D(@cvt)+1196),4)   /* get CVTSMEXT address  */\n@cvtsmext = D2X(C2D(@cvtsmext))                /* binary to hex       */\n@cvtmlpas = D2X(X2D(@cvtsmext)+8)            /* locate CVTMLPAStarts  */\n@cvtmlpas = D2X(C2D(STORAGE(@cvtmlpas,4)))     /*  get CVTMLPAS       */\n@cvtmlpae = D2X(X2D(@cvtsmext)+12)           /* locate CVTMLPAEnds    */\n@cvtmlpae = D2X(C2D(STORAGE(@cvtmlpae,4)))     /*  get CVTMLPAE       */\n@cvtflpas = D2X(X2D(@cvtsmext)+16)           /* locate CVTFLPAStarts  */\n@cvtflpas = D2X(C2D(STORAGE(@cvtflpas,4)))     /*  get CVTFLPAS       */\n@cvtflpae = D2X(X2D(@cvtsmext)+20)           /* locate CVTFLPAEnds    */\n@cvtflpae = D2X(C2D(STORAGE(@cvtflpae,4)))     /*  get CVTFLPAE       */\n@cvtplpas = D2X(X2D(@cvtsmext)+24)           /* locate CVTPLPAStarts  */\n@cvtplpas = D2X(C2D(STORAGE(@cvtplpas,4)))     /*  get CVTPLPAS       */\n@cvtplpae = D2X(X2D(@cvtsmext)+28)           /* locate CVTPLPAEnds    */\n@cvtplpae = D2X(C2D(STORAGE(@cvtplpae,4)))     /*  get CVTPLPAE       */\n@cvtrwns  = D2X(X2D(@cvtsmext)+32)           /* locate CVTRWNStarts   */\n@cvtrwns  = D2X(C2D(STORAGE(@cvtrwns,4)))      /*  get CVTRWNS        */\n@cvtrwne  = D2X(X2D(@cvtsmext)+36)           /* locate CVTRWNEnds     */\n@cvtrwne  = D2X(C2D(STORAGE(@cvtrwne,4)))      /*  get CVTRWNE        */\n@cvtrons  = D2X(X2D(@cvtsmext)+40)           /* locate CVTRONStarts   */\n@cvtrons  = D2X(C2D(STORAGE(@cvtrons,4)))      /*  get CVTRONS        */\n@cvtrone  = D2X(X2D(@cvtsmext)+44)           /* locate CVTRONEnds     */\n@cvtrone  = D2X(C2D(STORAGE(@cvtrone,4)))      /*  get CVTRONE        */\n@cvterwns = D2X(X2D(@cvtsmext)+48)           /* locate CVTERWNStarts  */\n@cvterwns = D2X(C2D(STORAGE(@cvterwns,4)))     /*  get CVTERWNS       */\n@cvterwne = D2X(X2D(@cvtsmext)+52)           /* locate CVTERWNEnds    */\n@cvterwne = D2X(C2D(STORAGE(@cvterwne,4)))     /*  get CVTRRWNE       */\n@cvteplps = D2X(X2D(@cvtsmext)+56)           /* locate CVTEPLPStarts  */\n@cvteplps = D2X(C2D(STORAGE(@cvteplps,4)))     /*  get CVTEPLPS       */\n@cvteplpe = D2X(X2D(@cvtsmext)+60)           /* locate CVTEPLPEnds    */\n@cvteplpe = D2X(C2D(STORAGE(@cvteplpe,4)))     /*  get CVTRPLPE       */\n@cvteflps = D2X(X2D(@cvtsmext)+64)           /* locate CVTEFLPStarts  */\n@cvteflps = D2X(C2D(STORAGE(@cvteflps,4)))     /*  get CVTEFLPS       */\n@cvteflpe = D2X(X2D(@cvtsmext)+68)           /* locate CVTEFLPEnds    */\n@cvteflpe = D2X(C2D(STORAGE(@cvteflpe,4)))     /*  get CVTRFLPE       */\n@cvtemlps = D2X(X2D(@cvtsmext)+72)           /* locate CVTEMLPStarts  */\n@cvtemlps = D2X(C2D(STORAGE(@cvtemlps,4)))     /*  get CVTEMLPS       */\n@cvtemlpe = D2X(X2D(@cvtsmext)+76)           /* locate CVTEMLPEnds    */\n@cvtemlpe = D2X(C2D(STORAGE(@cvtemlpe,4)))     /*  get CVTRMLPE       */\n        /*------simplify variable names & make addresses decimal------*/\n@csa1g  = @gdacsa    ; @csa2g = D2X(X2D(@gdacsasz)+X2D(@gdacsa)-1)/* g*/\n   csa1 = X2D(@csa1g) ; csa2 = X2D(@csa2g)                    /* csa  */\n@mlpa1  = @cvtmlpas  ; @mlpa2 = @cvtmlpae                     /* mlpa */\n   mlpa1 = X2D(@mlpa1) ; mlpa2 = X2D(@mlpa2)\n@flpa1  = @cvtflpas  ; @flpa2 = @cvtflpae                     /* flpa */\n   flpa1 = X2D(@flpa1) ; flpa2 = X2D(@flpa2)\n@plpa1  = @cvtplpas  ; @plpa2 = @cvtplpae                     /* plpa */\n   plpa1 = X2D(@plpa1) ; plpa2 = X2D(@plpa2)\n@sqa1   = D2X(X2D(@cvtplpae)+1) ; @sqa2 = D2X(X2D(@cvtrwns)-1)/* sqa  */\n   sqa1 = X2D(@sqa1) ; sqa2 = X2D(@sqa2)\n@nuc1   = @cvtrwns   ; @nuc2  = @cvterwne                     /* nuc  */\n   nuc1 = X2D(@nuc1) ; nuc2 = X2D(@nuc2)\n@esqa1  = D2X(X2D(@nuc2)+1) ; @esqa2 = D2X(X2D(@cvteplps)-1)  /* esqa */\n  esqa1 = X2D(@esqa1) ; esqa2 = X2D(@esqa2)\n@eplpa1 = @cvteplps  ; @eplpa2 = @cvteplpe                    /* eplpa*/\n eplpa1 = X2D(@eplpa1) ; eplpa2 = X2D(@eplpa2)\n@eflpa1 = @cvteflps  ; @eflpa2 = @cvteflpe                    /* eflpa*/\n eflpa1 = X2D(@eflpa1) ; eflpa2 = X2D(@eflpa2)\n@emlpa1 = @cvtemlps  ; @emlpa2 = @cvtemlpe                    /* emlpa*/\n emlpa1 = X2D(@emlpa1) ; emlpa2 = X2D(@emlpa2)\n@ecsa1g = @gdaecsa   ; @ecsa2g= D2X(X2D(@gdaecsas)+X2D(@gdaecsa)-1)/*g*/\n  ecsa1 = X2D(@ecsa1g) ; ecsa2 = X2D(@ecsa2g)\n@eprivs = X2D(@ecsa2g)+1                               /* ext private */\n@eprive = 2147483647                         /* fixed by architecture */\n epriv1 = @eprivs ; epriv2 = @eprive\n@psas   = 0 ; @psae = 4095                       /* psa fixed by arch */\n   psa1 = @psas ; psa2 = @psae\n@prive  = X2D(@csa1g)-1 ; @privs = X2D(@psae)+1            /* private */\n  priv1 = @privs ; priv2 = @prive\n              /*------------------------------------------------------*/\n             /* Usage Notes: Hex character compares are incompatible */\n            /*    for storage residency determination.  Thus, entry */\n           /*     point addresses must be converted to decimal and */\n          /*      VS boundary addresses must be converted to de-  */\n         /*       cimal for correct compare operations.          */\n        /*------------------------------------------------------*/\n/*----------end of virtual storage map definition section-------------*/\n@cvtlpdir = STORAGE(D2X(X2D(@cvt)+361),3)    /* get CVTLPDIR address  */\n@cvtlpdir = D2X(C2D(@cvtlpdir))                /* binary to hex       */\nAddress TSO ; \"CLEAR\"\nSay 'CVT:'@cvt' CVTLPDIR:'@cvtlpdir'  'DATE() TIME()\n@lpdechn = @cvtlpdir\nSay ' '\ndsn = 'MVS.PLPA.DIRTABLE'            /* assign a pseudo data set name */\nNewstack\ni = 0 ; eot = '00000000000000000000000000000000'\nd = Date() ; t = Time()\nDo While i < 10000                                 /* arbitrary limit */\n   lpde = STORAGE(@lpdechn,40)                        /* get the lpde */\n   If C2X(SUBSTR(lpde,1,16))=eot Then Leave           /* end of table */\n   i = i + 1\n   module = SUBSTR(lpde,9,8)\n   entry  = SUBSTR(lpde,17,4)\n                                        /* determine storage location */\n   addr = BITAND(entry,'7FFFFFFF'x)       /* shave off amode bit (32) */\n   addr = C2D(addr)                      /* make numeric for compares */\n   sloc = 'ERROR'                       /* determine module residency */\n   If (addr >= csa1   & addr <= csa2  ) Then sloc = 'CSA  '\n      Else If (addr >= mlpa1  & addr <= mlpa2 ) Then sloc = 'MLPA '\n      Else If (addr >= flpa1  & addr <= flpa2 ) Then sloc = 'FLPA '\n      Else If (addr >= plpa1  & addr <= plpa2 ) Then sloc = 'PLPA '\n      Else If (addr >= sqa1   & addr <= sqa2  ) Then sloc = 'SQA  '\n      Else If (addr >= nuc1   & addr <= nuc2  ) Then sloc = 'NUC  '\n      Else If (addr >= esqa1  & addr <= esqa2 ) Then sloc = 'ESQA '\n      Else If (addr >= eplpa1 & addr <= eplpa2) Then sloc = 'EPLPA'\n      Else If (addr >= eflpa1 & addr <= eflpa2) Then sloc = 'EFLPA'\n      Else If (addr >= emlpa1 & addr <= emlpa2) Then sloc = 'EMLPA'\n      Else If (addr >= ecsa1  & addr <= ecsa2 ) Then sloc = 'ECSA '\n      Else If (addr >= epriv1 & addr <= epriv2) Then sloc = 'EPRIV'\n      Else If (addr >= priv1  & addr <= priv2 ) Then sloc = 'PRIV '\n      Else If (addr >= psa1   & addr <= psa2  ) Then sloc = 'PSA  '\n   size   = C2X(SUBSTR(lpde,33,4))\n   att2   =     SUBSTR(lpde,30,1)\n   auth = 0 ; If (BITAND(att2,'01'x)='01'x) Then auth = 1\n   lpdemjp  = '         '\n   lpdemjnm = '        '\n   If C2D(SUBSTR(lpde,21,4)) \\= 0 Then\n      Do\n         lpdemjp  = ' Alias of'\n         lpdemjnm = SUBSTR(lpde,33,8)\n             size = '        '\n      End\n   Push ' 'LEFT(dsn,44,' ') 'PLPA'RIGHT(i,4,0) ,\n       module ,\n       C2X(entry) ,\n       sloc ,\n       'SIZE:'RIGHT(size,8,0) ,\n       'AC:'auth ,\n       lpdemjp lpdemjnm d t\n   @lpdechn = D2X(X2D(@lpdechn)+40)         /* address of next LPDE */\nEnd\nSay ' '\nSay 'LPDE table scan completed 'Time()\n/***************************************************************/\n/* Now save the stack to our PLPAMODS data set                 */\n/***************************************************************/\ndsn2 = sysvar(sysuid) || '.PLPAMODS.DATA.WORK'\n\"ALLOC F(PLPAMODS) DA('\"dsn2\"') OLD RELEASE\"\nIf RC \\= 0 Then Do\n   Say 'IOPLPA failed on 'dsn2' error: 'RC\n   Exit\n   End\nQueue\n'EXECIO * DISKW PLPAMODS ( FINIS'\nDelstack\nSay ' '\nSay 'Saved 'i' PLPA program descriptor records to DASD'\nSay 'DSN: 'dsn2\nSay 'Return Code: 'RC\n\"FREE F(PLPAMODS)\"\nExit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "IOSVCT": {"ttr": 2564, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00G\\x00\\x94\\x08\\x8f\\x01\\x14\\x05\\x0f\"V\\x00\\xcd\\x00\\xcd\\x00\\x00\\xe2\\xc3\\xd5\\xe2\\xf0\\xf3@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1994-03-29T00:00:00", "modifydate": "2014-02-19T22:56:47", "lines": 205, "newlines": 205, "modlines": 0, "user": "SCNS03"}, "text": "/*REXX*/\n/*****************************************************************/\n/*  IOSVCT: REXX program to create standard SVC database.        */\n/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */\n/*****************************************************************/\n/* MVS DATA AREAS:                                               */\n/*                CVT - Communications Vector Table (@'10'x)     */\n/*               SCVT - Supervisor Call Vector Table             */\n/*               SVCT - SVC Table                                */\n/*                                                               */\n/*                                                               */\n/*****************************************************************/\n/*--------------virtual storage map definition section----------------*/\nNumeric Digits 10           /* required to handle decimal conversions */\n@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */\n@cvt = D2X(C2D(@cvt))                    /* binary to hex             */\n@cvtreal  = STORAGE(D2X(X2D(@cvt)+284),4)    /* get CVTREAL address   */\n@cvtreal  = D2X(C2D(@cvtreal))                 /* binary to hex       */\n@cvtshrvm = STORAGE(D2X(X2D(@cvt)+416),4)    /* get CVTSHRVM address  */\n@cvtshrvm = D2X(C2D(@cvtshrvm))                /* binary to hex       */\n@cvtgda   = STORAGE(D2X(X2D(@cvt)+560),4)    /* get CVTGDA address    */\n@cvtgda   = D2X(C2D(@cvtgda))                  /* binary to hex       */\n@gdacsa   = D2X(X2D(@cvtgda)+108)            /* locate GDACSAstarts   */\n@gdacsa   = D2X(C2D(STORAGE(@gdacsa,4)))       /*  get GDACSA         */\n@gdacsasz = D2X(X2D(@cvtgda)+112)            /* locate GDACSASiZe     */\n@gdacsasz = D2X(C2D(STORAGE(@gdacsasz,4)))     /*  get GDACSASiZe     */\n@gdaecsa  = D2X(X2D(@cvtgda)+124)            /* locate GDAECSAstarts  */\n@gdaecsa  = D2X(C2D(STORAGE(@gdaecsa,4)))      /*  get GDAECSA        */\n@gdaecsas = D2X(X2D(@cvtgda)+128)            /* locate GDAECSASize    */\n@gdaecsas = D2X(C2D(STORAGE(@gdaecsas,4)))     /*  get GDAECSAS       */\n@cvtsmext = STORAGE(D2X(X2D(@cvt)+1196),4)   /* get CVTSMEXT address  */\n@cvtsmext = D2X(C2D(@cvtsmext))                /* binary to hex       */\n@cvtmlpas = D2X(X2D(@cvtsmext)+8)            /* locate CVTMLPAStarts  */\n@cvtmlpas = D2X(C2D(STORAGE(@cvtmlpas,4)))     /*  get CVTMLPAS       */\n@cvtmlpae = D2X(X2D(@cvtsmext)+12)           /* locate CVTMLPAEnds    */\n@cvtmlpae = D2X(C2D(STORAGE(@cvtmlpae,4)))     /*  get CVTMLPAE       */\n@cvtflpas = D2X(X2D(@cvtsmext)+16)           /* locate CVTFLPAStarts  */\n@cvtflpas = D2X(C2D(STORAGE(@cvtflpas,4)))     /*  get CVTFLPAS       */\n@cvtflpae = D2X(X2D(@cvtsmext)+20)           /* locate CVTFLPAEnds    */\n@cvtflpae = D2X(C2D(STORAGE(@cvtflpae,4)))     /*  get CVTFLPAE       */\n@cvtplpas = D2X(X2D(@cvtsmext)+24)           /* locate CVTPLPAStarts  */\n@cvtplpas = D2X(C2D(STORAGE(@cvtplpas,4)))     /*  get CVTPLPAS       */\n@cvtplpae = D2X(X2D(@cvtsmext)+28)           /* locate CVTPLPAEnds    */\n@cvtplpae = D2X(C2D(STORAGE(@cvtplpae,4)))     /*  get CVTPLPAE       */\n@cvtrwns  = D2X(X2D(@cvtsmext)+32)           /* locate CVTRWNStarts   */\n@cvtrwns  = D2X(C2D(STORAGE(@cvtrwns,4)))      /*  get CVTRWNS        */\n@cvtrwne  = D2X(X2D(@cvtsmext)+36)           /* locate CVTRWNEnds     */\n@cvtrwne  = D2X(C2D(STORAGE(@cvtrwne,4)))      /*  get CVTRWNE        */\n@cvtrons  = D2X(X2D(@cvtsmext)+40)           /* locate CVTRONStarts   */\n@cvtrons  = D2X(C2D(STORAGE(@cvtrons,4)))      /*  get CVTRONS        */\n@cvtrone  = D2X(X2D(@cvtsmext)+44)           /* locate CVTRONEnds     */\n@cvtrone  = D2X(C2D(STORAGE(@cvtrone,4)))      /*  get CVTRONE        */\n@cvterwns = D2X(X2D(@cvtsmext)+48)           /* locate CVTERWNStarts  */\n@cvterwns = D2X(C2D(STORAGE(@cvterwns,4)))     /*  get CVTERWNS       */\n@cvterwne = D2X(X2D(@cvtsmext)+52)           /* locate CVTERWNEnds    */\n@cvterwne = D2X(C2D(STORAGE(@cvterwne,4)))     /*  get CVTRRWNE       */\n@cvteplps = D2X(X2D(@cvtsmext)+56)           /* locate CVTEPLPStarts  */\n@cvteplps = D2X(C2D(STORAGE(@cvteplps,4)))     /*  get CVTEPLPS       */\n@cvteplpe = D2X(X2D(@cvtsmext)+60)           /* locate CVTEPLPEnds    */\n@cvteplpe = D2X(C2D(STORAGE(@cvteplpe,4)))     /*  get CVTRPLPE       */\n@cvteflps = D2X(X2D(@cvtsmext)+64)           /* locate CVTEFLPStarts  */\n@cvteflps = D2X(C2D(STORAGE(@cvteflps,4)))     /*  get CVTEFLPS       */\n@cvteflpe = D2X(X2D(@cvtsmext)+68)           /* locate CVTEFLPEnds    */\n@cvteflpe = D2X(C2D(STORAGE(@cvteflpe,4)))     /*  get CVTRFLPE       */\n@cvtemlps = D2X(X2D(@cvtsmext)+72)           /* locate CVTEMLPStarts  */\n@cvtemlps = D2X(C2D(STORAGE(@cvtemlps,4)))     /*  get CVTEMLPS       */\n@cvtemlpe = D2X(X2D(@cvtsmext)+76)           /* locate CVTEMLPEnds    */\n@cvtemlpe = D2X(C2D(STORAGE(@cvtemlpe,4)))     /*  get CVTRMLPE       */\n        /*------simplify variable names & make addresses decimal------*/\n@csa1g  = @gdacsa    ; @csa2g = D2X(X2D(@gdacsasz)+X2D(@gdacsa)-1)/* g*/\n   csa1 = X2D(@csa1g) ; csa2 = X2D(@csa2g)                    /* csa  */\n@mlpa1  = @cvtmlpas  ; @mlpa2 = @cvtmlpae                     /* mlpa */\n   mlpa1 = X2D(@mlpa1) ; mlpa2 = X2D(@mlpa2)\n@flpa1  = @cvtflpas  ; @flpa2 = @cvtflpae                     /* flpa */\n   flpa1 = X2D(@flpa1) ; flpa2 = X2D(@flpa2)\n@plpa1  = @cvtplpas  ; @plpa2 = @cvtplpae                     /* plpa */\n   plpa1 = X2D(@plpa1) ; plpa2 = X2D(@plpa2)\n@sqa1   = D2X(X2D(@cvtplpae)+1) ; @sqa2 = D2X(X2D(@cvtrwns)-1)/* sqa  */\n   sqa1 = X2D(@sqa1) ; sqa2 = X2D(@sqa2)\n@nuc1   = @cvtrwns   ; @nuc2  = @cvterwne                     /* nuc  */\n   nuc1 = X2D(@nuc1) ; nuc2 = X2D(@nuc2)\n@esqa1  = D2X(X2D(@nuc2)+1) ; @esqa2 = D2X(X2D(@cvteplps)-1)  /* esqa */\n  esqa1 = X2D(@esqa1) ; esqa2 = X2D(@esqa2)\n@eplpa1 = @cvteplps  ; @eplpa2 = @cvteplpe                    /* eplpa*/\n eplpa1 = X2D(@eplpa1) ; eplpa2 = X2D(@eplpa2)\n@eflpa1 = @cvteflps  ; @eflpa2 = @cvteflpe                    /* eflpa*/\n eflpa1 = X2D(@eflpa1) ; eflpa2 = X2D(@eflpa2)\n@emlpa1 = @cvtemlps  ; @emlpa2 = @cvtemlpe                    /* emlpa*/\n emlpa1 = X2D(@emlpa1) ; emlpa2 = X2D(@emlpa2)\n@ecsa1g = @gdaecsa   ; @ecsa2g= D2X(X2D(@gdaecsas)+X2D(@gdaecsa)-1)/*g*/\n  ecsa1 = X2D(@ecsa1g) ; ecsa2 = X2D(@ecsa2g)\n@eprivs = X2D(@ecsa2g)+1                               /* ext private */\n@eprive = 2147483647                         /* fixed by architecture */\n epriv1 = @eprivs ; epriv2 = @eprive\n@psas   = 0 ; @psae = 4095                       /* psa fixed by arch */\n   psa1 = @psas ; psa2 = @psae\n@prive  = X2D(@csa1g)-1 ; @privs = X2D(@psae)+1            /* private */\n  priv1 = @privs ; priv2 = @prive\n              /*------------------------------------------------------*/\n             /* Usage Notes: Hex character compares are incompatible */\n            /*    for storage residency determination.  Thus, entry */\n           /*     point addresses must be converted to decimal and */\n          /*      VS boundary addresses must be converted to de-  */\n         /*       cimal for correct compare operations.          */\n        /*------------------------------------------------------*/\n/*----------end of virtual storage map definition section-------------*/\n@cvtabend = STORAGE(D2X(X2D(@cvt)+200),4)    /* get CVTABEND address  */\n@cvtabend = D2X(C2D(@cvtabend))                /* binary to hex       */\n@scvtsvct = D2X(X2D(@cvtabend)+132)          /* SCVT addressibility   */\n@scvtsvct = STORAGE(@scvtsvct,4)                  /* SVCT table       */\n@scvtsvct = D2X(C2D(@scvtsvct))                /* binary to hex       */\nAddress TSO ; \"CLEAR\"\nSay 'CVT:'@cvt' CVTABEND:'@cvtabend' SCVTSVCT:'@scvtsvct DATE() TIME()\nSay ' '\ndsn = 'MVS.SVC.SVCTABLE'             /* assign a pseudo data set name */\nNewstack\nactive = 0 ; inactive = 0 ; svcapf = 0 ; svcesr = 0\nmodule = 'IGCERROR' ; Call \"#NUCLKUP\" module ; igcerror = Result\nd = Date() ; t = Time()\nDo i = 0 to 255                                 /* loop thru storage  */\n   bytes = STORAGE(D2X(X2D(@scvtsvct)+(i*8)),8)\n   addr = SUBSTR(bytes,1,4)       /* sloppy code to grab EP in binary */\n   bytes = C2X(bytes)          /* legacy code before learning bit ops */\n   svcep  = SUBSTR(bytes,1,8)\n                                        /* determine storage location */\n   addr = BITAND(addr,'7FFFFFFF'x)        /* shave off amode bit (32) */\n   addr = C2D(addr)                      /* make numeric for compares */\n   sloc = 'ERROR'                       /* determine module residency */\n   If (addr >= csa1   & addr <= csa2  ) Then sloc = 'CSA  '\n      Else If (addr >= mlpa1  & addr <= mlpa2 ) Then sloc = 'MLPA '\n      Else If (addr >= flpa1  & addr <= flpa2 ) Then sloc = 'FLPA '\n      Else If (addr >= plpa1  & addr <= plpa2 ) Then sloc = 'PLPA '\n      Else If (addr >= sqa1   & addr <= sqa2  ) Then sloc = 'SQA  '\n      Else If (addr >= nuc1   & addr <= nuc2  ) Then sloc = 'NUC  '\n      Else If (addr >= esqa1  & addr <= esqa2 ) Then sloc = 'ESQA '\n      Else If (addr >= eplpa1 & addr <= eplpa2) Then sloc = 'EPLPA'\n      Else If (addr >= eflpa1 & addr <= eflpa2) Then sloc = 'EFLPA'\n      Else If (addr >= emlpa1 & addr <= emlpa2) Then sloc = 'EMLPA'\n      Else If (addr >= ecsa1  & addr <= ecsa2 ) Then sloc = 'ECSA '\n      Else If (addr >= epriv1 & addr <= epriv2) Then sloc = 'EPRIV'\n      Else If (addr >= priv1  & addr <= priv2 ) Then sloc = 'PRIV '\n      Else If (addr >= psa1   & addr <= psa2  ) Then sloc = 'PSA  '\n      inactflag = 0\n      If igcerror = Right(D2X(addr),8,0)  /* normalize for match */\n         Then Do\n            inactive = inactive + 1\n            inactflag = 1\n         End\n         Else active = active + 1\n   svctp1 = SUBSTR(bytes,9,1)\n      Select\n         When svctp1 = '0'\n            Then svctype = 'TYPE 1  '\n         When svctp1 = '8'\n            Then svctype = 'TYPE 2  '\n         When svctp1 = 'C'\n            Then svctype = 'TYPE 3/4'\n         When svctp1 = '2'\n            Then svctype = 'TYPE 6  '\n      Otherwise\n                 svctype = 'TYPE ?  '\n      End\n   svctp2 = SUBSTR(bytes,10,1)\n      svcmisc = '   '\n      If svctp2 = '8'\n         Then Do\n            svcmisc = 'APF'\n            svcapf = svcapf + 1\n         End\n      If svctp2 = '4'\n         Then Do\n            svcmisc = 'ESR'\n            svcesr = svcesr + 1\n         End\n   If inactflag = 0\n      Then Push ' 'LEFT(dsn,44,' '),\n                'SVC'RIGHT(i,3,0) '('RIGHT(D2X(i),2,0)')',\n                svctype svcep sloc svcmisc d t\nEnd\nSay ' '\nSay 'There are 'active 'active standard SVCs on this system.'\nSay 'Among the active SVCs, 'svcapf 'are APF restricted.'\nSay 'There are 'svcesr 'active ESR router SVCs present.'\nSay 'The SVCTABLE contains 'inactive 'inactive slots (IGCERROR).'\nSay '    (IGCERROR nucleus address = 'igcerror')'\nSay ' '\nSay 'SVCTABLE processing complete ' Time()\n/***************************************************************/\n/* Now save the stack to our SVC data set                      */\n/***************************************************************/\ndsn2 = sysvar(sysuid) || '.SVCS.DATA.WORK'\n\"ALLOC F(SVCS) DA('\"dsn2\"') OLD RELEASE\"\nIf RC \\= 0 Then Do\n   Say 'IOSVCT failed on 'dsn2' error: 'RC\n   Exit\n   End\nQueue\n'EXECIO * DISKW SVCS ( FINIS'\nDelstack\nSay ' '\nSay 'Saved 'active' SVC program descriptor records to DASD'\nSay 'DSN: 'dsn2\nSay 'Return Code: 'RC\n\"FREE F(SVCS)\"\nExit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LISTADSP": {"ttr": 2567, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x19\\x00P\\x00\\x94\\x08\\x8f\\x01\\x14\\x05\\x0f\"V\\x00W\\x00W\\x00\\x00\\xe2\\xc3\\xd5\\xe2\\xf0\\xf3@@@@'", "ispf": {"version": "01.25", "flags": 0, "createdate": "1994-03-29T00:00:00", "modifydate": "2014-02-19T22:56:50", "lines": 87, "newlines": 87, "modlines": 0, "user": "SCNS03"}, "text": "/* REXX */\n/*****************************************************************/\n/*LISTADSP: REXX program to display all address space names.     */\n/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */\n/*****************************************************************/\n/* MVS DATA AREAS:                                               */\n/*                CVT - Communications Vector Table (@'10'x)     */\n/*               ASVT - Address Space Vector Table               */\n/*               ASCB - Address Space Control Block              */\n/*               OUCB - SRM User Control Block                   */\n/*                                                               */\n/*****************************************************************/\n@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */\n@cvt = D2X(C2D(@cvt))                    /* binary to dec to hex      */\n@cvtasvt  = STORAGE(D2X(X2D(@cvt)+556),4)    /* get CVTASVT address   */\n@cvtasvt  = D2X(C2D(@cvtasvt))                 /* binary to dec to hex*/\nAddress TSO ; \"CLEAR\"\nSay 'CVT: '@cvt 'CVTASVT: '@cvtasvt' ===> Scan on 'DATE()'.  Started: 'TIME()\n@asvt = @cvtasvt\nasvtmaxu = STORAGE(D2X(X2D(@asvt)+516),4) /* get maxuser (table size) */\nDo i = 1 to C2D(asvtmaxu)                  /* initialize name buckets */\n   bat.i = ''\n   tso.i = ''\n   stc.i = ''\nEnd\nj = 0 ; k = 0 ; tablend = 524 + (4 * (C2D(asvtmaxu)-1))\nb = 0 ; t = 0 ; s = 0 ; inits = 0      /* address space type counters */\nDo i = 524 to tablend By 4                      /* loop thru the ASVT */\n   j = j + 1                            /* count asvt slots processed */\n   @ascb = STORAGE(D2X(X2D(@asvt)+i),4)        /* get address of ASCB */\n   If BITAND(LEFT(@ascb,1),'80'x)\\='80'x Then Do   /* bit off, in use */\n      k = k + 1                                /* count active adrspc */\n      ascbasid = STORAGE(D2X(C2D(@ascb)+36),2)            /* get ASID */\n      @ascboucb = STORAGE(D2X(C2D(@ascb)+144),4)  /* get OUCB address */\n      @ascbjbni = STORAGE(D2X(C2D(@ascb)+172),4)  /* get JOBN address */\n      jbni = '        ' ; @ascbjbni = D2X(C2D(@ascbjbni))\n      If @ascbjbni \\= 0 Then jbni = STORAGE(@ascbjbni,8)\n      @ascbjbns = STORAGE(D2X(C2D(@ascb)+176),4)  /* get STCN address */\n      jbns = '        ' ; @ascbjbns = D2X(C2D(@ascbjbns))\n      If @ascbjbns \\= 0 Then jbns = STORAGE(@ascbjbns,8)\n      oucbsubn = STORAGE(D2X(C2D(@ascboucb)+176),4)    /* subsys name */\n      oucbtrxn = STORAGE(D2X(C2D(@ascboucb)+200),8)    /* transn name */\n      oucbusrd = STORAGE(D2X(C2D(@ascboucb)+208),8)         /* userid */\n      /* BATCH JOBS */\n      If oucbsubn = 'STC ' & jbns = 'INIT    ' Then inits = inits + 1\n      If oucbsubn = 'JES2' & jbns = 'INIT    ' & jbni = oucbtrxn Then Do\n         inits = inits + 1\n         b = b + 1\n         bat.b = oucbtrxn\n         End\n      /* TSO USERS  */\n      If oucbsubn = 'TSO ' Then Do\n         t = t + 1\n         If oucbusrd = '        ' Then tso.t = '????????' /* missing lid */\n                                  Else tso.t = oucbusrd\n         End\n      /* STARTED TASKS */\n      If oucbsubn = 'STC ' & oucbtrxn \\= 'INIT    ' & jbns \\= 'INIT    ' Then Do\n         s = s + 1\n         stc.s = oucbtrxn\n         End\n      End\nEnd\nSay ' '\nSay RIGHT(inits,4,' ')' Initiators defined.  'RIGHT(b,3,' ')' Batch jobs active:'\nIf b > 0 Then Do i = 1 To b By 8\n   c1=i ; c2=i+1 ; c3=i+2 ; c4=i+3 ; c5=i+4 ; c6=i+5 ; c7=i+6 ; c8=i+7\n   Say '     'bat.c1' 'bat.c2' 'bat.c3' 'bat.c4,\n              bat.c5' 'bat.c6' 'bat.c7' 'bat.c8\n   End\nSay ' '\nSay RIGHT(t,4,' ')' TSO sessions:'\nIf t > 0 Then Do i = 1 To t By 8\n   c1=i ; c2=i+1 ; c3=i+2 ; c4=i+3 ; c5=i+4 ; c6=i+5 ; c7=i+6 ; c8=i+7\n   Say '     'tso.c1' 'tso.c2' 'tso.c3' 'tso.c4,\n              tso.c5' 'tso.c6' 'tso.c7' 'tso.c8\n   End\nSay ' '\nSay RIGHT(s,4,' ')' Started tasks:'\nIf s > 0 Then Do i = 1 To s By 8\n   c1=i ; c2=i+1 ; c3=i+2 ; c4=i+3 ; c5=i+4 ; c6=i+5 ; c7=i+6 ; c8=i+7\n   Say '     'stc.c1' 'stc.c2' 'stc.c3' 'stc.c4,\n              stc.c5' 'stc.c6' 'stc.c7' 'stc.c8\n   End\nSay ' '\nSay RIGHT(k,4,' ')' slots in use out of a total 'j' scanned.  Completed: 'TIME()\nExit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LISTAPFT": {"ttr": 769, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x13\\x00\\x00\\x01\\x130\\x9f\\x01\\x130\\x9f\\x13\\t\\x00A\\x00M\\x00\\x00\\xe2\\xc3\\xd5\\xe2\\xf0\\xf3\\xe3@@@'", "ispf": {"version": "01.19", "flags": 0, "createdate": "2013-11-05T00:00:00", "modifydate": "2013-11-05T13:09:00", "lines": 65, "newlines": 77, "modlines": 0, "user": "SCNS03T"}, "text": "/*REXX*/\n/*****************************************************************/\n/*LISTAPFT: REXX program to display APF table from CSTOR.        */\n/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */\n/*****************************************************************/\n/* MVS DATA AREAS:                                               */\n/*                CVT - Communications Vector Table (@'10'x)     */\n/*             APFTAB - Undocumented in MVS DATA AREAS book.     */\n/*                                                               */\n/*                                                               */\n/*                                                               */\n/*****************************************************************/\nnumeric digits 30\ncvt = c2d(storage(10,4))                       /* point to cvt        */\n@cvt = D2X(cvt)                                /* binary to hex       */\necvt = c2d(storage(d2x(cvt+140),4))            /* point to cvtecvt    */\n@ecvt = STORAGE(D2X(X2D(@cvt)+140),4)          /* get CVTAUTHL addres */\n@ecvt = D2X(C2D(@ecvt))                        /* binary to hex       */\n@cvtauthl = STORAGE(D2X(X2D(@cvt)+484),4)      /* get CVTAUTHL addres */\n@cvtauthl = D2X(C2D(@cvtauthl))                /* binary to hex       */\nif X2D(@cvtauthl) <> c2d('7ffff001'x) then      /*dynamic list ?   @@ */\ndo          /* Static format  */\nSay 'The CVT  is located at '@cvt '('X2D(@cvt)')'\napfcount  = C2D(STORAGE(D2X(X2D(@cvtauthl)+1),1)) /* APF libraries    */\napfllen   = C2D(STORAGE(D2X(X2D(@cvtauthl)+2),1)) /* length 1st entry */\n@apfentry = X2D(@cvtauthl)+3          /* address of 1st APF entry     */\nDo i = 1 to apfcount                            /* loop thru storage  */\n   apflib.i = STORAGE(D2X(@apfentry),apfllen)   /* get the APF entry  */\n   @apfentry = @apfentry + apfllen + 1          /* bump to next entry */\n   apfllen = C2D(STORAGE(D2X(@apfentry-1),1))   /* length of next     */\n   apfvol.i  = substr(apflib.i,1,6)                /* apf vol         */\n   apfdsn.i  = substr(apflib.i,7,44)               /* apf dsn         */\nEnd\nEnd         /* Static format  */\nElse        /* Dynamic format */\n  do\n    Say 'The eCVT is located at '@ecvt '('X2D(@ecvt)')'\n    ecvtcsvt = c2d(storage(d2x(ecvt+228),4))   /* point to ecvtcsvt   */\n    apfa = c2d(storage(d2x(ecvtcsvt+12),4))    /* addr start of list  */\n    apht = c2d(storage(d2x(apfa+8),4))         /* addr 1st entry      */\n    last = c2d(storage(d2x(apfa+12),4))        /* addr last entry     */\n    apf. = ''\n    i = 0\n    do forever\n      apfdsn.i = storage(d2x(apht+24),44)      /* apf dataset name    */\n      if substr(apfdsn.i,1,1) \u00ac= '00'x then    /* 00 = deleted        */\n        do\n          apfesms = storage(d2x(apht+4),1)     /* sms flag            */\n          if  bitand(apfesms,'80'x)  = '80'x then apfvol.i = '*SMS* '\n          else apfvol.i = storage(d2x(apht+68),6)   /* apf volser     */\n          i = i + 1\n        end\n      if apht = last then leave\n      else apht = c2d(storage(d2x(apht+8),4))  /* addr next entry     */\n    end\n    apfcount = i - 1\n  end       /* Dynamic format */               /* set maximum lines   */\nSay 'The CVTAUTHL field points to '@cvtauthl '('X2D(@cvtauthl)')'\nSay 'The APF table contains 'apfcount 'entries, as follows:'\nSay 'VOLSER --------------DATA SET NAME-----------------'\nSay ' '\ndo i = 1 to apfcount                       /* for each line       */\n  say apfvol.i' 'left(apfdsn.i,45) i       /* build output line   */\nend\nExit\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LISTAPF2": {"ttr": 771, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x13\\x00\\x00\\x01\\x130_\\x01\\x130\\x9f\\x122\\x00M\\x00(\\x00\\x00\\xe2\\xc3\\xd5\\xe2\\xf0\\xf3\\xe3@@@'", "ispf": {"version": "01.19", "flags": 0, "createdate": "2013-11-01T00:00:00", "modifydate": "2013-11-05T12:32:00", "lines": 77, "newlines": 40, "modlines": 0, "user": "SCNS03T"}, "text": "/*REXX*/\n/*****************************************************************/\n/*LISTAPFT: REXX program to display APF table from CSTOR.        */\n/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */\n/*****************************************************************/\n/* MVS DATA AREAS:                                               */\n/*                CVT - Communications Vector Table (@'10'x)     */\n/*             APFTAB - Undocumented in MVS DATA AREAS book.     */\n/*                                                               */\n/*                                                               */\n/*                                                               */\n/*****************************************************************/\nnumeric digits 30\n@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */\n@cvt = D2X(C2D(@cvt))                          /* binary to hex       */\n\ncvt = c2d(storage(10,4))                       /* point to cvt        */\necvt = c2d(storage(d2x(cvt+140),4))            /* point to cvtecvt    */\n@ecvt = STORAGE(D2X(X2D(@cvt)+140),4)          /* get CVTAUTHL addres */\n@ecvt = D2X(C2D(@ecvt))                        /* binary to hex       */\n\n@cvtauthl = STORAGE(D2X(X2D(@cvt)+484),4)      /* get CVTAUTHL addres */\n@cvtauthl = D2X(C2D(@cvtauthl))                /* binary to hex       */\nsay '@cvtauthl= '@cvtauthl\nsay 'compare1= 'c2d('7ffff001'x)\nSay 'The CVT  is located at '@cvt '('X2D(@cvt)')'\nSay 'The eCVT is located at '@ecvt '('X2D(@ecvt)')'\nSay 'The CVTAUTHL field points to '@cvtauthl '('X2D(@cvtauthl)')'\nif X2D(@cvtauthl) <> c2d('7ffff001'x) then      /*dynamic list ?   @@ */\ndo          /* Static format  */\nsay 'Static Format'\napfcount  = C2D(STORAGE(D2X(X2D(@cvtauthl)+1),1)) /* APF libraries    */\napfllen   = C2D(STORAGE(D2X(X2D(@cvtauthl)+2),1)) /* length 1st entry */\n@apfentry = X2D(@cvtauthl)+3          /* address of 1st APF entry     */\nSay 'The APF table contains 'apfcount 'entries, as follows:'\nSay ' '\nDo i = 1 to apfcount                            /* loop thru storage  */\n   apflib.i = STORAGE(D2X(@apfentry),apfllen)   /* get the APF entry  */\n   @apfentry = @apfentry + apfllen + 1          /* bump to next entry */\n   apfllen = C2D(STORAGE(D2X(@apfentry-1),1))   /* length of next  */\nEnd\nSay 'VOLSER --------------DATA SET NAME-----------------'\nSay ' '\nDo i = 1 to apfcount                            /* print the list     */\n   Say SUBSTR(apflib.i,1,6) SUBSTR(apflib.i,7,44,' ') i\nEnd\nEnd         /* Static format  */\nElse        /* Dynamic format */\n  do\n    say 'Dynamic Format'\n    ecvtcsvt = c2d(storage(d2x(ecvt+228),4))   /* point to ecvtcsvt   */\n    apfa = c2d(storage(d2x(ecvtcsvt+12),4))    /* addr start of list  */\n    apht = c2d(storage(d2x(apfa+8),4))         /* addr 1st entry      */\n    last = c2d(storage(d2x(apfa+12),4))        /* addr last entry     */\n    apf. = ''\n    inc = 0\n    do forever\n      apfdsn = storage(d2x(apht+24),44)        /* apf dataset name    */\n      if substr(apfdsn,1,1) \u00ac= '00'x then      /* 00 = deleted        */\n        do\n          apfesms = storage(d2x(apht+4),1)     /* sms flag            */\n          if  bitand(apfesms,'80'x)  = '80'x then apfvol = '*SMS* '\n          else apfvol = storage(d2x(apht+68),6)   /* apf volser       */\n          line.inc =left(apfdsn,45)||apfvol\n          inc = inc + 1\n        end\n      if apht = last then leave\n      else apht = c2d(storage(d2x(apht+8),4))  /* addr next entry     */\n    end\n    apfcount = inc - 1\n    Say 'The APF table contains 'apfcount 'entries, as follows:'\n\n  do inc = 1 to apfcount                       /* for each line       */\n    say ' 'line.inc                            /* build output line   */\n  end\n  end       /* Dynamic format */               /* set maximum lines   */\nExit\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LISTCATS": {"ttr": 2569, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\r\\x00S\\x01\\x14\\x02O\\x01\\x14\\x05\\x0f\"V\\x006\\x00-\\x00\\x00\\xe2\\xc3\\xd5\\xe2\\xf0\\xf3@@@@'", "ispf": {"version": "01.13", "flags": 0, "createdate": "2014-01-24T00:00:00", "modifydate": "2014-02-19T22:56:53", "lines": 54, "newlines": 45, "modlines": 0, "user": "SCNS03"}, "text": "/*REXX*/\n/*****************************************************************/\n/*LISTCATS: REXX program to display all open catalogs.           */\n/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */\n/*****************************************************************/\n/* MVS DATA AREAS:                                               */\n/*                CVT - Communications Vector Table (@'10'x)     */\n/*              AMCBS - Access Method Control Block Structure    */\n/*              CAXWA - Calaog Auxiliary Work Area               */\n/*                UCB - Device Unit Control Block                */\n/*                                                               */\n/*****************************************************************/\n@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */\n@cvt = D2X(C2D(@cvt))                         /* binary to dec to hex */\n@cvtcbsp  = STORAGE(D2X(X2D(@cvt)+256),4)      /* get CVTCBSP address */\n@cvtcbsp  = D2X(C2D(@cvtcbsp))                /* binary to dec to hex */\n@cbscaxcn = STORAGE(D2X(X2D(@cvtcbsp)+20),4)  /* get CBSCAXCN address */\n@cbscaxcn = D2X(C2D(@cbscaxcn))               /* binary to dec to hex */\n@cbsacb   = STORAGE(D2X(X2D(@cvtcbsp)+8),4)     /* get CBSACB address */\n@cbsacb   = D2X(C2D(@cbsacb))                 /* binary to dec to hex */\nAddress TSO ; \"CLEAR\"\nSay 'CVT: '@cvt' CVTCBSP: '@cvtcbsp' ===> CAXWA chain trace started: 'TIME()\n   Say 'CBSCAXCN: '@cbscaxcn' CBSACB:'@cbsacb\nSay ' '\ni = 0 ; endofcax = 0 ; @caxchn = @cbscaxcn\nDo While endofcax = 0 & i < 500\n   i = i + 1\n   @caxacb = STORAGE(D2X(X2D(@caxchn)+24),4)   /* catalog acb address */\n   @caxacb = D2X(C2D(@caxacb))                /* binary to dec to hex */\n   If @caxacb = @cbsacb Then\n    Do\n     cattype = 'Master'\n     @caxucb = STORAGE(D2X(X2D(@caxchn)+28),4) /* catalog ucb address */\n    End\n   Else\n    Do\n    cattype = 'User  '\n    @caxucb = STORAGE(D2X(X2D(@caxchn)+188),4) /* catalog ucb address */\n    End\n   @caxucb = D2X(C2D(@caxucb))                /* binary to dec to hex */\n/* Say 'CAXUCB: '@caxucb' CAXACB:'@caxacb */\n   caxvol  = STORAGE(D2X(X2D(@caxucb)+28),6)        /* catalog volser */\n   caxcnam = STORAGE(D2X(X2D(@caxchn)+52),44)          /* catalog dsn */\n   caxflg3 = STORAGE(D2X(X2D(@caxchn)+10),1)             /* cax flags */\n   catorg = 'CVOL' ; If BITAND(caxflg3,'20'x)='20'x Then catorg = 'ICF '\n   @caxnext = STORAGE(D2X(X2D(@caxchn)+4),4)    /* next caxwa address */\n   @caxnext = C2X(@caxnext)                   /* binary to dec to hex */\n   If @caxnext = 0 Then endofcax = 1            /* end of chain value */\n   Say RIGHT(i,2,' ') cattype catorg caxvol caxcnam\n   @caxchn = @caxnext\nEnd\nSay ' '\nSay 'Last CAXWA after 'i' blocks scanned.  Completed: 'TIME()\nExit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LISTCONS": {"ttr": 2571, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00T\\x00\\x94\\x08\\x8f\\x01\\x14\\x05\\x0f\"V\\x00h\\x00_\\x00\\x00\\xe2\\xc3\\xd5\\xe2\\xf0\\xf3@@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "1994-03-29T00:00:00", "modifydate": "2014-02-19T22:56:54", "lines": 104, "newlines": 95, "modlines": 0, "user": "SCNS03"}, "text": "/*REXX*/\n/*****************************************************************/\n/* LISTCONS: REXX program to display system consoles and status. */\n/*     Note: Developed and tested on an MVS/SP 2.2.3 system.     */\n/*****************************************************************/\n/* MVS DATA AREAS:                                               */\n/*                CVT - Communications Vector Table (@'10'x)     */\n/*                UCM - Unit Control Module                      */\n/*                UCB - IOS Unit Control Block                   */\n/*****************************************************************/\nAddress TSO ; \"CLEAR\" ; Numeric Digits 10\n@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */\n@cvt = D2X(C2D(@cvt))                                /* binary to hex */\n@cvtcucb  = STORAGE(D2X(X2D(@cvt)+100),4)      /* get CVTCUCB address */\n@cvtcucb  = D2X(C2D(@cvtcucb))                       /* binary to hex */\n@ucmvea   = STORAGE(D2X(X2D(@cvtcucb)+72),4)    /* get UCMVEA address */\n@ucme     = D2X(C2D(@ucmvea))                        /* binary to hex */\nucmvez    = STORAGE(D2X(X2D(@cvtcucb)+76),4)            /* get UCMVEZ */\nucmelen   = C2D(ucmvez)                              /* binary to dec */\n@ucmvel   = STORAGE(D2X(X2D(@cvtcucb)+80),4)    /* get UCMVEL address */\n@ucmelast = D2X(C2D(@ucmvel))                        /* binary to hex */\nSay 'CVT:'@cvt'  CVTCUCB:'@cvtcucb'  UCMVEA:'@ucme'  'DATE() TIME()\nSay ' '\nSay '    Console  '\nSay 'ID  UCB    Name     Status    Message Routing'\nSay '--  ----   -------- ------    ----------------------------------------'\nSay ' '\nbit0='80'x ; bit1='40'x ; bit2='20'x ; bit3='10'x\nbit4='08'x ; bit5='04'x ; bit6='02'x ; bit7='01'x\nDo While @ucme \\= @ucmelast             /* loop through the ucme list */\n   @ucmucb   = STORAGE(D2X(X2D(@ucme)+12),4)    /* get UCMUCB address */\n   @ucmucb   = D2X(C2D(@ucmucb))                     /* binary to hex */\n   ucbname   = STORAGE(D2X(X2D(@ucmucb)+13),3)         /* get UCBNAME */\n     ucbchan   = STORAGE(D2X(X2D(@ucmucb)+4),2)        /* get UCBCHAN */\n     ucbchan   =  D2X(C2D(ucbchan))\n   if substr(ucbname,1,3) ='UCB' then ucbname = ucbchan\n   ucmatr    = STORAGE(D2X(X2D(@ucme)+25),1)            /* get UCMATR */\n   ucmid     = STORAGE(D2X(X2D(@ucme)+26),1)             /* get UCMID */\n   ucmid     = C2D(ucmid)                            /* binary to dec */\n\n      @ucmfextp = STORAGE(D2X(X2D(@ucme)+72),4)  /* get UCMFEXTP addr */\n      @ucmfextp = D2X(C2D(@ucmfextp))                /* binary to hex */\n      ucmefcnm  = STORAGE(D2X(X2D(@ucmfextp)+52),8)    /* get UCMEFCNM*/\n\n   active    = '' ; routing = '' ; line2 = ''\n   If BITAND(ucmatr,'10'x) = '10'x Then Do /* process active consoles */\n      active = '*Active* '\n      ucmefrc   = STORAGE(D2X(X2D(@ucmfextp)+24),16)   /* get UCMEFRC */\n      /*-------------------process route code data--------------------*/\n      Do i = 1 to 16\n         byte = SUBSTR(ucmefrc,i,1)\n         k = (i-1) * 8\n         If BITAND(byte,bit0)=bit0 Then routing = routing k+1\n         If BITAND(byte,bit1)=bit1 Then routing = routing k+2\n         If BITAND(byte,bit2)=bit2 Then routing = routing k+3\n         If BITAND(byte,bit3)=bit3 Then routing = routing k+4\n         If BITAND(byte,bit4)=bit4 Then routing = routing k+5\n         If BITAND(byte,bit5)=bit5 Then routing = routing k+6\n         If BITAND(byte,bit6)=bit6 Then routing = routing k+7\n         If BITAND(byte,bit7)=bit7 Then routing = routing k+8\n      End\n      i = 0 ; k = 0 ; f = '' ; j = 0 ; jj = 0\n      Do While routing \\= ''\n         i = i + 1\n         PARSE VAR routing type.i routing\n      End\n      If i > 2 Then\n         Do k = 1 to i-2\n            j = k + 1 ; jj = k + 2\n            If type.k = type.j - 1 & type.j = type.jj -1 Then f.k = '*'\n                                                         Else f.k = ' '\n         End\n      routing = 'Codes('\n      Do k = 1 to i\n         If f.k \\= '*' Then Do\n                               routing = routing''type.k\n                               If k \\= i Then routing = routing','\n                                         Else routing = routing')'\n                            End\n                       Else Do\n                              routing = routing''type.k':'\n                              Do While f.k = '*' ; k=k+1 ; End\n                            End\n      End\n      line2 = ''\n      If LENGTH(routing) >50 Then\n         Do\n            Do i = 70 to 1 By -1\n               If SUBSTR(routing,i,1) = ',' Then Leave\n            End\n            line2 = SUBSTR(routing,i+1,60)\n            routing = LEFT(routing,i)\n         End\n      /*--------------------end of route code data--------------------*/\n      End\n/* Say RIGHT(ucmid,2)' ('ucbname')  'active routing */\n/* Say RIGHT(ucmid,2)' ('ucbname') ' ucmefcnm active routing */\n Say RIGHT(ucmid,2)' ('RIGHT(ucbname,4)') ' ucmefcnm active routing\n   If line2 \\= '' Then Say   '                         'line2\n   @ucme = D2X(X2D(@ucme)+ucmelen)               /* bump to next ucme */\nEnd\nSay ' '\nSay 'Unit Control Module device table scan completed 'TIME()\nExit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LISTDASD": {"ttr": 3585, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0c\\x002\\x01\\x15\\x02_\\x01\\x15\\x02\\x8f\\x15\\x08\\x00~\\x00\\x82\\x00\\x00\\xc1\\xc3\\xc9\\xc5\\xd9\\xc9@@@@'", "ispf": {"version": "01.12", "flags": 0, "createdate": "2015-01-25T00:00:00", "modifydate": "2015-01-28T15:08:32", "lines": 126, "newlines": 130, "modlines": 0, "user": "ACIERI"}, "text": "        /*REXX*/\n        /*****************************************************************/\n        /*LISTDASD: REXX program to display all online DASD devices.     */\n        /*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */\n        /*****************************************************************/\n        /* MVS DATA AREAS:                                               */\n        /*                CVT - Communications Vector Table (@'10'x)     */\n        /*                UCB - Device Unit Control Block                */\n        /*                DCE - Device Class Extension                   */\n        /*                VIP - VTOC Information Block                   */\n        /* @ z/OS V2.2 the ULUT has been moved into 64 bit storage.      */\n        /*****************************************************************/\n        Address TSO ; \"CLEAR\" ; Numeric Digits 20    /* 20 can handle 64 bits */\n        @cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */\n        @cvt = D2X(C2D(@cvt))                    /* binary to dec to hex      */\n        @cvtucba  = STORAGE(D2X(X2D(@cvt)+1252),4)   /* get CVTUCBA address   */\n        @cvtucba  = D2X(C2D(@cvtucba))                 /* binary to dec to hex*/\n        @cvtixav  = STORAGE(D2X(X2D(@cvt)+124),4)      /* get CVTIXAVL addres */\n        @cvtixav  = D2X(C2D(@cvtixav))                       /* binary to hex */\n        @iovtadr  = STORAGE(D2X(X2D(@cvtixav)+208),4)  /* get IOVT address    */\n        @iovtadr  = D2X(C2D(@iovtadr))                       /* binary to hex */\n        @ulutadr  = STORAGE(D2X(X2D(@iovtadr)+8),4)    /* get IOVT address    */\n        @ulutadr  = D2X(C2D(@ulutadr))                       /* binary to hex */\n        if @ulutadr = 0 then                            /* zOS V2.2 or higher */\n          do\n           Say 'zOS:'MVSVAR(SYSOPSYS)' Ulut is in 64 bit storage'\n           @ulutadr  = STORAGE(D2X(X2D(@iovtadr)+440),8)  /* get IOVT address */\n           @ulutadr  = D2X(C2D(@ulutadr))                    /* binary to hex */\n          end\n        ulu      = STORAGE(@ulutadr,64)             /* get 64 byte ulu header */\n        uluname  = SUBSTR(ulu,1,4)                         /* ulut eyecatcher */\n        ulutype  = SUBSTR(ulu,5,1)                         /* ulut Type 1 or 2*/\n        If ulutype = '01'x Then off = 0                    /* ULUT Type 1     */\n        If ulutype = '02'x Then off = 8                    /* ULUT Type 2     */\n        If ulutype = '03'x Then                            /* ULUT Type 3     */\n         Do\n           ulufirst = SUBSTR(ulu,17,8)          /* addr of 1st ULU element(64)*/\n           uluucbno = SUBSTR(ulu,29,4)          /* # of ucb's this I/O config */\n           off = 12\n         End\n        Else\n         Do                                     /* Ulut type 1 or 2           */\n           ulufirst = SUBSTR(ulu,13+off,4)      /* address of 1st ULU element */\n           uluucbno = SUBSTR(ulu,17+off,4)      /* # of ucb's this I/O config */\n         End\n         uluttape = SUBSTR(ulu,21+off,4)        /* # of TAPE UCBs in I/O cfg  */\n         ulutcomm = SUBSTR(ulu,25+off,4)        /* # of COMM UCBs in I/O cfg  */\n         ulutdasd = SUBSTR(ulu,29+off,4)        /* # of DASD UCBs in I/O cfg  */\n         @uluchn  = C2X(ulufirst)\n        Say 'CVT: '@cvt' CVTUCBA: '@cvtucba' ===> DASD chain trace started: 'TIME()\n        Say '            CVTIXAV:'@cvtixav' IOVT:'@iovtadr' ULUT: '@ulutadr\n        Say ' '\n        Say '     This I/O configuration has 'C2D(ulutdasd)' DASD UCBs defined!'\n        Say ' '\n        i = 0 ; J = 0 ; pri = 0 ; pub = 0 ; sto = 0 ; smsv = 0\n        Do i = 1 to C2D(uluucbno)               /* scan the ULUT for ALL DASD */\n            uluelmnt = STORAGE(@uluchn,12)       /* get 12 byte ULUT element */\n            uluucbad = SUBSTR(uluelmnt,9,4)     /* 1st ucb this device class */\n            uluucbad = C2X(uluucbad) ; @ucbchn = uluucbad\n           ucb     = STORAGE(@ucbchn,24)    /* get 24 byte ucb common segment */\n           ucbfl5  = SUBSTR(ucb,2,1)                  /* get flags5 bitstring */\n           ucbid   = SUBSTR(ucb,3,1)                 /* get the 'FF'x id byte */\n           ucbstat = SUBSTR(ucb,4,1)              /* status byte '80'x online */\n           ucbchan = SUBSTR(ucb,5,2)                /* channel address in hex */\n           ucbnxucb= SUBSTR(ucb,9,4)                   /* pointer to next ucb */\n           ucbtbyt3= SUBSTR(ucb,19,1)                 /* device '20'x is DASD */\n           ucbtbyt4= SUBSTR(ucb,20,1)           /* contains device type codes */\n           If (BITAND(ucbstat,'80'x)='80'x & BITAND(ucbtbyt3,'20'x)='20'x) Then Do\n              j = j + 1; device = ' Unknown'\n              ioaddr = C2X(ucbchan)\n              If BITAND(ucbfl5,'20'x)\\='20'x Then sms = 'Not SMS'\n                                             Else Do\n                                                  sms = 'SMS    '\n                                                  smsv = smsv + 1\n                                                  End\n              If BITAND(ucbtbyt4,'04'x)='04'x Then device = '9340   '\n              If BITAND(ucbtbyt4,'06'x)='06'x Then device = '2305-1 '\n              If BITAND(ucbtbyt4,'07'x)='07'x Then device = '2305-2 '\n              If BITAND(ucbtbyt4,'08'x)='08'x Then device = '2314   '\n              If BITAND(ucbtbyt4,'09'x)='09'x Then device = '3330   '\n              If BITAND(ucbtbyt4,'0D'x)='0D'x Then device = '3330-11'\n              If BITAND(ucbtbyt4,'0A'x)='0A'x Then device = '3340   '\n              If BITAND(ucbtbyt4,'0B'x)='0B'x Then device = '3350   '\n              If BITAND(ucbtbyt4,'0C'x)='0C'x Then device = '3375   '\n              If BITAND(ucbtbyt4,'85'x)='85'x Then device = '6421   ' /*facom*/\n              If BITAND(ucbtbyt4,'0E'x)='0E'x Then device = '3380   '\n              If BITAND(ucbtbyt4,'0F'x)='0F'x Then device = '3390   '\n              @ucbx   = SUBSTR(ucb,21,4)          /* address of ucb extension */\n              @ucbx   = D2X(C2D(@ucbx))               /* binary to dec to hex */\n              @dce    = STORAGE(D2X(X2D(@ucbx)+24),4)       /* address of DCE */\n              @dce    = D2X(C2D(@dce))                /* binary to dec to hex */\n              @vib    = STORAGE(D2X(X2D(@dce)+4),4)         /* address of VIB */\n              @vib    = D2X(C2D(@vib))                /* binary to dec to hex */\n              vibflags= STORAGE(D2X(X2D(@vib)+6),1)    /* VTOC info flag byte */\n              If BITAND(vibflags,'80'x)='80'x Then vtocix = 'VTOCIX'\n                                              Else vtocix = '      '\n              @vvds   = STORAGE(D2X(X2D(@dce)+8),4)  /* address of VVDS block */\n              If C2D(@vvds) = 0 Then vvds = '    '\n                                Else vvds = 'VVDS'\n              @ucbchn=D2X(X2D(@ucbchn)+24)            /* bump to DASD segment */\n              ucbdasd = STORAGE(@ucbchn,24)       /* get 24 byte DASD segment */\n              ucbvoli = SUBSTR(ucbdasd,5,6)              /* volser if mounted */\n              ucbstab = SUBSTR(ucbdasd,11,1)         /* mount attribute codes */\n              mount = 'Unknown '\n              If BITAND(ucbstab,'10'x)='10'x Then Do\n                 mount = 'Private'\n                 pri = pri + 1\n                 End\n              If BITAND(ucbstab,'08'x)='08'x Then Do\n                 mount = 'Public '\n                 pub = pub + 1\n                 End\n              If BITAND(ucbstab,'04'x)='04'x Then Do\n                 mount = 'Storage'\n                 sto = sto + 1\n                 End\n              Say RIGHT(j,4,' ') ucbvoli RIGHT(ioaddr,4) STRIP(device),\n                  mount vtocix vvds sms\n           End\n           @uluchn  = D2X(x2d(@uluchn)+12)\n        End\n        Say ' '\n        Say 'Summary ===>  Private: 'pri'  Storage: 'sto'  Public: 'pub'  SMS: 'smsv\n        Say ' '\n        Say 'Last UCB after 'i' blocks scanned.  Completed: 'TIME()\n        Exit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LISTDCQ": {"ttr": 3341, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x08\\x00\\x13\\x01\\x15\\x02_\\x01\\x15\\x02\\x8f\\x15\\x00\\x00\\x89\\x00\\x8a\\x00\\x00\\xc1\\xc3\\xc9\\xc5\\xd9\\xc9@@@@'", "ispf": {"version": "01.08", "flags": 0, "createdate": "2015-01-25T00:00:00", "modifydate": "2015-01-28T15:00:13", "lines": 137, "newlines": 138, "modlines": 0, "user": "ACIERI"}, "text": "        /*REXX*/\n        /*****************************************************************/\n        /* LISTDCQ: REXX program to display the device class queue.      */\n        /*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */\n        /*****************************************************************/\n        /* MVS DATA AREAS:                                               */\n        /*                CVT - Communications Vector Table (@'10'x)     */\n        /*                DCQ - Device Class Queue                       */\n        /*                UCB - Device Unit Control Block                */\n        /*                                                               */\n        /*               ULUT - UCB Look Up table                        */\n        /* UCB count, 1st UCB addr, # Act and Inact now derived from ULUT*/\n        /* @ z/OS V2.2 the ULUT has been moved into 64 bit storage.      */\n        /*****************************************************************/\n        Address TSO ; \"CLEAR\" ; Numeric Digits 20    /* 20 can handle 64 bits */\n        @cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */\n        @cvt = D2X(C2D(@cvt))                                /* binary to hex */\n        @cvtdcqa  = STORAGE(D2X(X2D(@cvt)+1248),4)     /* get CVTDCQA address */\n        @cvtdcqa  = D2X(C2D(@cvtdcqa))                       /* binary to hex */\n        @cvtixav  = STORAGE(D2X(X2D(@cvt)+124),4)      /* get CVTIXAVL addres */\n        @cvtixav  = D2X(C2D(@cvtixav))                       /* binary to hex */\n        @iovtadr  = STORAGE(D2X(X2D(@cvtixav)+208),4)  /* get IOVT address    */\n        @iovtadr  = D2X(C2D(@iovtadr))                       /* binary to hex */\n        @ulutadr  = STORAGE(D2X(X2D(@iovtadr)+8),4)       /* get ULUT address */\n        @ulutadr  = D2X(C2D(@ulutadr))                       /* binary to hex */\n        if @ulutadr = 0 then                            /* zOS V2.2 or higher */\n          do\n           Say 'zOS:'MVSVAR(SYSOPSYS)' Ulut is in 64 bit storage'\n           @ulutadr  = STORAGE(D2X(X2D(@iovtadr)+440),8)  /* get IOVT address */\n           @ulutadr  = D2X(C2D(@ulutadr))                    /* binary to hex */\n          end\n        Say 'CVT:'@cvt' CVTDCQA:'@cvtdcqa' ==> Device Class Queue 'DATE() TIME()\n        Say '           CVTIXAV:'@cvtixav' IOVT:'@iovtadr' ULUT: '@ulutadr\n        Say ' '\n        dcq      = STORAGE(@cvtdcqa,20)             /* get 20 byte DCQ header */\n        dcqname  = SUBSTR(dcq,1,4)                          /* dcq eyecatcher */\n        dcqlngth = SUBSTR(dcq,5,2)                /* length of each dcq entry */\n        dcqcount = SUBSTR(dcq,7,2)                      /* number of elements */\n        dcqfirst = SUBSTR(dcq,9,4)              /* address of 1st dcq element */\n        dcqdstct = SUBSTR(dcq,13,4)    /* entries in device class stats table */\n        dcqucbno = SUBSTR(dcq,17,4) /* number of ucb's this I/O configuration */\n        @dcqchn  = C2X(dcqfirst) ; i = 0\n        ulu      = STORAGE(@ulutadr,64)             /* get 56 byte ulu header */\n        uluname  = SUBSTR(ulu,1,4)                         /* ulut eyecatcher */\n        ulutype  = SUBSTR(ulu,5,1)\n        If ulutype = '01'x Then off = 0                    /* ULUT Type 1     */\n        If ulutype = '02'x Then off = 8                    /* ULUT Type 2     */\n        If ulutype = '03'x Then                            /* ULUT Type 3     */\n         Do\n           ulufirst = SUBSTR(ulu,17,8)          /* addr of 1st ULU element(64)*/\n           uluucbno = SUBSTR(ulu,29,4)          /* # of ucb's this I/O config */\n           off = 12\n         End\n        Else\n         Do                                     /* Ulut type 1 or 2           */\n           ulufirst = SUBSTR(ulu,13+off,4)      /* address of 1st ULU element */\n           uluucbno = SUBSTR(ulu,17+off,4)      /* # of ucb's this I/O config */\n         End\n         uluttape = SUBSTR(ulu,21+off,4)        /* # of TAPE UCBs in I/O cfg  */\n         ulutcomm = SUBSTR(ulu,25+off,4)        /* # of COMM UCBs in I/O cfg  */\n         ulutdasd = SUBSTR(ulu,29+off,4)        /* # of DASD UCBs in I/O cfg  */\n         ulutdisp = SUBSTR(ulu,33+off,4)        /* # of DISP UCBs in I/O cfg  */\n         uluturec = SUBSTR(ulu,37+off,4)        /* # of UREC UCBs in I/O cfg  */\n         ulutchar = SUBSTR(ulu,41+off,4)        /* # of CHAR UCBs in I/O cfg  */\n         ulutctca = SUBSTR(ulu,45+off,4)        /* # of CTCA UCBs in I/O cfg  */\n        @uluchn  = C2X(ulufirst)\n        Say ' This I/O configuration has defined - DCQ UCBs: 'C2D(dcqucbno)\n        Say '                                     ULUT Type: 'C2D(ulutype)\n        Say '                                     ULUT UCBs: 'C2D(uluucbno)\n        Say '                                         DCQEs: 'C2D(dcqcount)\n        Say '                                       1stDCQE: '@dcqchn\n        Say '                                       1stULUT: 'D2X(C2D(ulufirst))\n        Say ' '\n        Say '      Name____  ID_   UCBs   1stUCB__   Active   Inactive  ID=UCB'\n        Say ' '\n        Do i = 1 to C2D(dcqcount)          /* scan the DCQ for all dev classes*/\n           dcqelmnt = STORAGE(@dcqchn,28)          /* get 28 byte DCQ element */\n           dcqchain = SUBSTR(dcqelmnt,1,4)      /* get next element's address */\n           @dcqchn  = D2X(C2D(dcqchain))\n           dcqdevc.i = SUBSTR(dcqelmnt,5,1)    /* device class, i.e. UCBTBYT3 */\n           dcqucbct = SUBSTR(dcqelmnt,7,2)     /* ucb's for this device class */\n           dcqucbct = C2D(dcqucbct)\n           dcqucbad = SUBSTR(dcqelmnt,9,4)       /* 1st ucb this device class */\n           dcqucba.i = C2X(dcqucbad)             /* first UCB address in DCQ  */\n           dcqdevn.i = SUBSTR(dcqelmnt,13,8)             /* device class name */\n           act.i = 0 ; inact.i = 0 ; chk.i = 0        /* Initialize counters  */\n           uluucbc.i = 0 ; ok.i ='ERROR'              /* Initialize counters  */\n        End                                                /* END oF DCQ scan */\n         Do j = 1 to C2D(uluucbno)              /* scan the ULUT for ALL UCBs */\n             uluelmnt = STORAGE(@uluchn,12)       /* get 12 byte ULUT element */\n             uluucbad = SUBSTR(uluelmnt,9,4)     /* 1st ucb this device class */\n             uluucbad = C2X(uluucbad) ; @ucbchn = uluucbad\n              ucb     = STORAGE(@ucbchn,24) /* get 24 byte ucb common segment */\n              ucbstat = SUBSTR(ucb,4,1)           /* status byte '80'x online */\n              ucbnxucb= SUBSTR(ucb,9,4)                /* pointer to next ucb */\n              ucbtbyt3= SUBSTR(ucb,19,1)           /* device ID like dcqdevcl */\n           Do k = 1 to C2D(dcqcount)           /* loop through all dev classes*/\n              If ucbtbyt3 = dcqdevc.k Then\n                Do\n                  chk.k = chk.k + 1\n                  If BITAND(ucbstat,'80'x)='80'x Then act.k = act.k + 1\n                                             Else inact.k = inact.k + 1\n                  If chk.k = 1 Then uluucba.k = uluucbad  /* 1st UCB from ULUT*/\n                  uluucbc.k = uluucbc.k + 1\n                End\n           end                                 /* End  through all dev classes*/\n           @uluchn  = D2X(x2d(@uluchn)+12)\n         End                                               /* End of ULUT scan*/\n        Say ' '\n           Do l = 1 to C2D(dcqcount)                     /*  Print output     */\n           Select\n             When dcqdevn.l = 'TAPE' Then\n               If uluucbc.l = X2D(C2X(uluttape)) then ok.l = '*okay*'\n             When dcqdevn.l = 'COMM' Then\n               If uluucbc.l = X2D(C2X(ulutcomm)) then ok.l = '*okay*'\n             When dcqdevn.l = 'DASD' Then\n               If uluucbc.l = X2D(C2X(ulutdasd)) then ok.l = '*okay*'\n             When dcqdevn.l = 'DISP' Then\n               If uluucbc.l = X2D(C2X(ulutdisp)) then ok.l = '*okay*'\n             When dcqdevn.l = 'UREC' Then\n               If uluucbc.l = X2D(C2X(uluturec)) then ok.l = '*okay*'\n             When dcqdevn.l = 'CHAR' Then\n               If uluucbc.l = X2D(C2X(ulutchar)) then ok.l = '*okay*'\n             Otherwise\n               If uluucbc.l = X2D(C2X(ulutctca)) then ok.l = '*okay*'\n           End\n           If uluucbc.l = 0 Then Do\n              uluucba.l = '        '\n              act.l    = '    ' ; inact.l  = '    ' ; ok.l     = '      '\n           End\n           Say RIGHT(l,3)'   'dcqdevn.l'  'C2X(dcqdevc.l)'x',\n               '  'RIGHT(uluucbc.l,4)'   'uluucba.l,\n               '   'RIGHT(act.l,4)'      'RIGHT(inact.l,4)'    'ok.l\n           end                                           /* End  Print output */\n        Say ' '\n        Say 'Device Class Queue scan completed 'TIME()\n        Exit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LISTDCQO": {"ttr": 3329, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x08\\x8f\\x00\\x94\\x08\\x8f\\x10\\x00\\x00F\\x00F\\x00\\x00\\xd5\\xd6\\xe3`\\xe9\\xd6\\xe2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-03-29T00:00:00", "modifydate": "1994-03-29T10:00:00", "lines": 70, "newlines": 70, "modlines": 0, "user": "NOT-ZOS"}, "text": "/*REXX*/\n/*****************************************************************/\n/* LISTDCQ: REXX program to display the device class queue.      */\n/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */\n/*****************************************************************/\n/* MVS DATA AREAS:                                               */\n/*                CVT - Communications Vector Table (@'10'x)     */\n/*                DCQ - Device Class Queue                       */\n/*                UCB - Device Unit Control Block                */\n/*                                                               */\n/*                                                               */\n/*****************************************************************/\nAddress TSO ; \"CLEAR\" ; Numeric Digits 10\n@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */\n@cvt = D2X(C2D(@cvt))                                /* binary to hex */\n@cvtdcqa  = STORAGE(D2X(X2D(@cvt)+1248),4)     /* get CVTDCQA address */\n@cvtdcqa  = D2X(C2D(@cvtdcqa))                       /* binary to hex */\nSay 'CVT:'@cvt' CVTDCQA:'@cvtdcqa' ==> Device Class Queue 'DATE() TIME()\nSay ' '\ndcq      = STORAGE(@cvtdcqa,20)             /* get 20 byte DCQ header */\ndcqname  = SUBSTR(dcq,1,4)                          /* dcq eyecatcher */\ndcqlngth = SUBSTR(dcq,5,2)                /* length of each dcq entry */\ndcqcount = SUBSTR(dcq,7,2)                      /* number of elements */\ndcqfirst = SUBSTR(dcq,9,4)              /* address of 1st dcq element */\ndcqdstct = SUBSTR(dcq,13,4)    /* entries in device class stats table */\ndcqucbno = SUBSTR(dcq,17,4) /* number of ucb's this I/O configuration */\n@dcqchn  = C2X(dcqfirst) ; i = 0\nSay ' This I/O configuration has defined -     UCBs: 'C2D(dcqucbno)\nSay '                                         DCQEs: 'C2D(dcqcount)\nSay '                                       1stDCQE: '@dcqchn\nSay ' '\nSay '      Name____  ID_   UCBs   1stUCB__   Active   Inactive  ID=UCB'\nSay ' '\nDo While @dcqchn \\= 0 & i < 10000\n   i = i + 1\n   dcqelmnt = STORAGE(@dcqchn,28)          /* get 28 byte DCQ element */\n   dcqchain = SUBSTR(dcqelmnt,1,4)      /* get next element's address */\n   @dcqchn  = D2X(C2D(dcqchain))\n   dcqdevcl = SUBSTR(dcqelmnt,5,1)     /* device class, i.e. UCBTBYT3 */\n   dcqucbct = SUBSTR(dcqelmnt,7,2)     /* ucb's for this device class */\n   dcqucbct = C2D(dcqucbct)\n   dcqucbad = SUBSTR(dcqelmnt,9,4)       /* 1st ucb this device class */\n   dcqucbad = C2X(dcqucbad) ; @ucbchn = dcqucbad\n   active = 0 ; inactive = 0 ; check = 0\n   Do j = 1 to dcqucbct           /* scan ucb chain this device class */\n      If @ucbchn = 0 Then Leave\n      ucb     = STORAGE(@ucbchn,24) /* get 24 byte ucb common segment */\n      ucbstat = SUBSTR(ucb,4,1)           /* status byte '80'x online */\n      ucbnxucb= SUBSTR(ucb,9,4)                /* pointer to next ucb */\n      ucbtbyt3= SUBSTR(ucb,19,1)           /* device ID like dcqdevcl */\n      If BITAND(ucbstat,'80'x)='80'x Then active = active + 1\n                                     Else inactive = inactive + 1\n      If BITAND(ucbtbyt3,dcqdevcl)=dcqdevcl Then check = check + 1\n      @ucbchn = C2X(ucbnxucb)\n   End\n   ok = 'ERROR ' ; If check = dcqucbct Then ok = '*okay*'\n   dcqdevnm = SUBSTR(dcqelmnt,13,8)              /* device class name */\n   If dcqucbad = '00000000' & dcqucbct = 0 Then Do\n      dcqucbad = '        '\n      active   = '    '\n      inactive = '    '\n      ok       = '      '\n   End\n   Say RIGHT(i,3)'   'dcqdevnm'  'C2X(dcqdevcl)'x',\n       '  'RIGHT(dcqucbct,4)'   'dcqucbad,\n       '   'RIGHT(active,4)'      'RIGHT(inactive,4)'    'ok\nEnd\nSay ' '\nSay 'Device Class Queue scan completed 'TIME()\nExit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LISTENV": {"ttr": 3590, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x16\\x01\\x153o\\x01\\x153\\x7f\\x13R\\x00\\xcc\\x00\\xcc\\x00\\x00\\xc1\\xc3\\xc9\\xc5\\xd9\\xc9@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2015-12-02T00:00:00", "modifydate": "2015-12-03T13:52:16", "lines": 204, "newlines": 204, "modlines": 0, "user": "ACIERI"}, "text": "/*REXX*/\n/*****************************************************************/\n/* LISTENV: REXX program to display system environment data.     */\n/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */\n/*****************************************************************/\n/* MVS DATA AREAS:                                               */\n/*                CVT - Communications Vector Table (@'10'x)     */\n/*              JESCT - JES Control Table                        */\n/*             PCCAVT - Phys. Config. Comm. Area Vector Table    */\n/*               PCCA - Physical Config. Communications Area     */\n/*               TSVT - TSO Vector Table                         */\n/*               MQCT - HSM CVT                                  */\n/*                RCE - RSM Control and Enumeration Area         */\n/*                PSA - Prefixed Saved Area (CVT & PSAATCVT)     */\n/*              ASMVT - ASM Vector Table                         */\n/*                DCQ - Device Class Queue                       */\n/*                UCB - Device Unit Control Block                */\n/*****************************************************************/\nAddress TSO ; \"CLEAR\" ; Numeric Digits 20\n@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */\n@cvt = D2X(C2D(@cvt))                                /* binary to hex */\n@cvtprodn = D2X(X2D(@cvt)-40)                 /* get CVTPRODN address */\nmvssplvl  = STORAGE(@cvtprodn,8)                      /* get SP level */\n@cvtprodi = D2X(X2D(@cvt)-32)                 /* get CVTPRODI address */\nmvsfmid   = STORAGE(@cvtprodi,8)                          /* get FMID */\n@cvtmdl   = D2X(X2D(@cvt)-6)                    /* get CVTMDL address */\ncpumodel  = STORAGE(@cvtmdl,2)                           /* get MODEL */\ncpumodel  = C2X(cpumodel)\n@cvtsysad = STORAGE(D2X(X2D(@cvt)+48),4)      /* get CVTSYSAD address */\n@cvtsysad = D2X(C2D(@cvtsysad))                      /* binary to hex */\nsysresucb = STORAGE(@cvtsysad,48)                          /* get UCB */\nucbchan   = SUBSTR(sysresucb,4,3)            /* correct for 4 char ucb*/\nucbchan   = SUBSTR(C2X(ucbchan),3)           /* Correct for 4 char UCB*/\nucbvoli   = SUBSTR(sysresucb,29,6)\n@cvttvt   = STORAGE(D2X(X2D(@cvt)+156),4)       /* get CVTTVT address */\n@cvttvt   = D2X(C2D(@cvttvt))                        /* binary to hex */\ntsvtlver  = STORAGE(D2X(X2D(@cvttvt)+100),1)          /* get TSVTLVER */\ntsvtlrel  = STORAGE(D2X(X2D(@cvttvt)+101),2)          /* get TSVTLREL */\ntsvtlmod  = STORAGE(D2X(X2D(@cvttvt)+103),1)          /* get TSVTLMOD */\n  tsoe = tsvtlver'.'tsvtlrel'.'tsvtlmod\n@cvtmz00  = STORAGE(D2X(X2D(@cvt)+164),4)              /* get CVTMZ00 */\n@cvtmz00  = D2X(C2D(@cvtmz00))                       /* binary to hex */\n  eovm  = ((X2D(@cvtmz00)+1)/1048576)'M'\n@cvtjesct = STORAGE(D2X(X2D(@cvt)+296),4)     /* get CVTJESCT address */\n@cvtjesct = D2X(C2D(@cvtjesct))                      /* binary to hex */\n  jes     = STORAGE(D2X(X2D(@cvtjesct)+28),4)         /* get JES name */\n@cvteorm  = STORAGE(D2X(X2D(@cvt)+312),4)      /* get CVTEORM address */\n@cvteorm  = D2X(C2D(@cvteorm))                       /* binary to hex */\n  cstor = ((X2D(@cvteorm)+1)/1048576)'M'             /* convert to MB */\n@cvtext2  = STORAGE(D2X(X2D(@cvt)+328),4)      /* get CVTEXT2 address */\n@cvtext2  = D2X(C2D(@cvtext2))                       /* binary to hex */\ncvtnucls  = STORAGE(D2X(X2D(@cvtext2)+4),1)   /* get selected nucleus */\n@cvtasmvt = STORAGE(D2X(X2D(@cvt)+704),4)     /* get CVTASMVT address */\n@cvtasmvt = D2X(C2D(@cvtasmvt))                      /* binary to hex */\nasmflag2  = STORAGE(D2X(X2D(@cvtasmvt)+1),1)\n  clpa = '(NO CLPA)'\n  If BITAND(asmflag2,'08'x) \\= '08'x Then clpa = '(CLPA)'\n@cvtpccat = STORAGE(D2X(X2D(@cvt)+764),4)     /* get CVTPCCAT address */\n@cvtpccat = D2X(C2D(@cvtpccat))                      /* binary to hex */\n@cvtrlstg = STORAGE(D2X(X2D(@cvt)+856),4)       /* get CVTRLSTG bytes */\n@cvtrlstg = C2D(@cvtrlstg)                           /* binary to dec */\n  cstorol = ((@cvtrlstg)/1024)'M'                    /* convert to MB */\n@cvthsm   = STORAGE(D2X(X2D(@cvt)+988),4)       /* get CVTHSM address */\n@cvthsm   = D2X(C2D(@cvthsm))                        /* binary to hex */\nmqctver   = STORAGE(D2X(X2D(@cvthsm)+48),2)            /* get MQCTVER */\nmqctrel   = STORAGE(D2X(X2D(@cvthsm)+50),1)            /* get MQCTREL */\nmqctmod   = STORAGE(D2X(X2D(@cvthsm)+51),1)            /* get MQCTMOD */\n  hsm  = mqctver'.'mqctrel'.'mqctmod\n@cvtdfa   = STORAGE(D2X(X2D(@cvt)+1216),4)      /* get CVTDFA address */\n@cvtdfa   = D2X(C2D(@cvtdfa))                        /* binary to hex */\ndfadata   = STORAGE(@cvtdfa,4)                  /* get DFP level data */\ndfadata   = C2X(dfadata)\ndfaver    = SUBSTR(dfadata,5,1)                    /* get DFP version */\ndfarel    = SUBSTR(dfadata,6,1)                    /* get DFP release */\ndfamod    = SUBSTR(dfadata,7,1)                    /* get DFP mod lvl */\n  dfp  = dfaver'.'dfarel'.'dfamod\n@cvtrcep  = STORAGE(D2X(X2D(@cvt)+1168),4)     /* get CVTRCEP address */\n@cvtrcep  = D2X(C2D(@cvtrcep))                       /* binary to hex */\nrceespl   = STORAGE(D2X(X2D(@cvtrcep)+160),4)  /* get RCEESPL frames  */\n  estor = ((C2D(rceespl)*4096)/1048576)'M'           /* convert to MB */\n@psaatcvt = STORAGE(408,4)             /* get VTAM ATCVT from PSAAOLD */\n@psaatcvt = D2X(C2D(@psaatcvt))                      /* binary to hex */\natcvtdata = STORAGE(@psaatcvt,4)               /* get VTAM level data */\natcvtdata = C2X(atcvtdata)\natcvtver  = SUBSTR(atcvtdata,6,1)                 /* get VTAM version */\natcvtrel  = SUBSTR(atcvtdata,8,1)                 /* get VTAM release */\n  vtam = atcvtver'.'atcvtrel\nSay 'CVT:'@cvt'   SYSTEM ENVIRONMENT DATA on 'DATE() TIME()\nSay ' '\nSay '   Software -   MVS: 'mvssplvl' ('STRIP(mvsfmid)')    JES: 'jes\nSay '                DFP: 'dfp'               TSO/E: 'tsoe\nSay '               VTAM: 'vtam'                   HSM:'hsm\nSay '                IPL: 'ucbvoli' @ 'ucbchan'     Nucleus: 'cvtnucls,\n    '  'clpa\nSay ' '\nSay '  Processor - Model: 'cpumodel\nSay '              CSTOR: 'cstor'   ('cstorol' on-line)    ESTOR: 'estor\nSay '              VSTOR: 'eovm'  (Highest virtual address '@cvtmz00'/',\n    X2D(@cvtmz00)')'\nDo i = 0 to 15                                 /* loop thru CPU table */\n   @pcca = STORAGE(D2X(X2D(@cvtpccat)+(i*4)),4)\n   @pcca = C2X(@pcca)\n   If @pcca \\= 0 Then Do\n      Say '                CPU: 'RIGHT(i,2,0),\n          '    ('STORAGE(D2X(X2D(@pcca)+4),8)')'\n      End\n   End\n@cvtdcqa  = STORAGE(D2X(X2D(@cvt)+1248),4)     /* get CVTDCQA address */\n@cvtdcqa  = D2X(C2D(@cvtdcqa))                       /* binary to hex */\n@cvtixav  = STORAGE(D2X(X2D(@cvt)+124),4)      /* get CVTIXAVL addres */\n@cvtixav  = D2X(C2D(@cvtixav))                       /* binary to hex */\n@iovtadr  = STORAGE(D2X(X2D(@cvtixav)+208),4)  /* get IOVT address    */\n@iovtadr  = D2X(C2D(@iovtadr))                       /* binary to hex */\n@ulutadr  = STORAGE(D2X(X2D(@iovtadr)+8),4)    /* get IOVT address    */\n@ulutadr  = D2X(C2D(@ulutadr))                       /* binary to hex */\nif @ulutadr = 0 then                            /* zOS V2.2 or higher */\n  do\n   Say ''\n   @ulutadr  = STORAGE(D2X(X2D(@iovtadr)+440),8)  /* get IOVT address */\n   @ulutadr  = D2X(C2D(@ulutadr))                    /* binary to hex */\n   Say 'zOS:'MVSVAR(SYSOPSYS)' Ulut is in 64 bit storage @ '@ulutadr\n  end\nulu      = STORAGE(@ulutadr,64)             /* get 56 byte ulu header */\nuluname  = SUBSTR(ulu,1,4)                         /* ulut eyecatcher */\nulutype  = SUBSTR(ulu,5,1)                         /* ulut Type 1 or 2*/\nIf ulutype = '01'x Then off = 0                    /* ULUT Type 1     */\n                   Else off = 8                    /* ULUT Type 2     */\nIf ulutype = '03'x Then                            /* ULUT Type 3     */\n Do\n   ulufirst = SUBSTR(ulu,17,8)          /* addr of 1st ULU element(64)*/\n   uluucbno = SUBSTR(ulu,29,4)          /* # of ucb's this I/O config */\n   off = 12\n End\nElse\n Do                                     /* Ulut type 1 or 2           */\n   ulufirst = SUBSTR(ulu,13+off,4)      /* address of 1st ULU element */\n   uluucbno = SUBSTR(ulu,17+off,4)      /* # of ucb's this I/O config */\n End\n uluttape = SUBSTR(ulu,21+off,4)        /* # of TAPE UCBs in I/O cfg  */\n ulutcomm = SUBSTR(ulu,25+off,4)        /* # of COMM UCBs in I/O cfg  */\n ulutdasd = SUBSTR(ulu,29+off,4)        /* # of DASD UCBs in I/O cfg  */\n ulutdisp = SUBSTR(ulu,33+off,4)        /* # of DISP UCBs in I/O cfg  */\n uluturec = SUBSTR(ulu,37+off,4)        /* # of UREC UCBs in I/O cfg  */\n ulutchar = SUBSTR(ulu,41+off,4)        /* # of CHAR UCBs in I/O cfg  */\n ulutctca = SUBSTR(ulu,45+off,4)        /* # of CTCA UCBs in I/O cfg  */\n@uluchn  = C2X(ulufirst)\ndcq      = STORAGE(@cvtdcqa,20)             /* get 20 byte DCQ header */\ndcqcount = SUBSTR(dcq,7,2)                      /* number of elements */\ndcqfirst = SUBSTR(dcq,9,4)              /* address of 1st dcq element */\n@dcqchn  = C2X(dcqfirst) ; i = 0\nSay ' '\nSay '        I/O - Device    Class   UCBs  Active  ID=UCB'\nSay '              --------  ------  ----  ------  ------'\nDo i = 1 to C2D(dcqcount)          /* scan the DCQ for all dev classes*/\n   dcqelmnt = STORAGE(@dcqchn,28)          /* get 28 byte DCQ element */\n   dcqchain = SUBSTR(dcqelmnt,1,4)      /* get next element's address */\n   @dcqchn  = D2X(C2D(dcqchain))\n   dcqdevc.i = SUBSTR(dcqelmnt,5,1)    /* device class, i.e. UCBTBYT3 */\n   dcqdevn.i = SUBSTR(dcqelmnt,13,8)             /* device class name */\n   act.i = 0 ; uluucbc.i = 0 ; ok.i ='ERROR'  /* Initialize counters  */\nEnd\n Do j = 1 to C2D(uluucbno)              /* scan the ULUT for ALL UCBs */\n     uluelmnt = STORAGE(@uluchn,12)       /* get 12 byte ULUT element */\n     uluucbad = SUBSTR(uluelmnt,9,4)     /* 1st ucb this device class */\n     uluucbad = C2X(uluucbad) ; @ucbchn = uluucbad\n      ucb     = STORAGE(@ucbchn,24) /* get 24 byte ucb common segment */\n      ucbstat = SUBSTR(ucb,4,1)           /* status byte '80'x online */\n      ucbnxucb= SUBSTR(ucb,9,4)                /* pointer to next ucb */\n      ucbtbyt3= SUBSTR(ucb,19,1)           /* device ID like dcqdevcl */\n   Do k = 1 to C2D(dcqcount)           /* loop through all dev classes*/\n      If ucbtbyt3 = dcqdevc.k Then\n        Do\n          If BITAND(ucbstat,'80'x)='80'x Then act.k = act.k + 1\n          uluucbc.k = uluucbc.k + 1\n        End\n   end                                 /* End  through all dev classes*/\n   @uluchn  = D2X(x2d(@uluchn)+12)\n End                                               /* End of ULUT scan*/\n    Do l = 1 to C2D(dcqcount)                     /*  Print output    */\n    Select\n      When dcqdevn.l = 'TAPE' Then\n        If uluucbc.l = X2D(C2X(uluttape)) then ok.l = '*okay*'\n      When dcqdevn.l = 'COMM' Then\n        If uluucbc.l = X2D(C2X(ulutcomm)) then ok.l = '*okay*'\n      When dcqdevn.l = 'DASD' Then\n        If uluucbc.l = X2D(C2X(ulutdasd)) then ok.l = '*okay*'\n      When dcqdevn.l = 'DISP' Then\n        If uluucbc.l = X2D(C2X(ulutdisp)) then ok.l = '*okay*'\n      When dcqdevn.l = 'UREC' Then\n        If uluucbc.l = X2D(C2X(uluturec)) then ok.l = '*okay*'\n      When dcqdevn.l = 'CHAR' Then\n        If uluucbc.l = X2D(C2X(ulutchar)) then ok.l = '*okay*'\n      Otherwise\n        If uluucbc.l = X2D(C2X(ulutctca)) then ok.l = '*okay*'\n    End\n    If uluucbc.l = 0 Then Do\n       uluucba.l = '        '\n       act.l    = '    ' ; ok.l     = '      '\n    End\n   Say '              'dcqdevn.l'   'C2X(dcqdevc.l)'x',\n       '   'RIGHT(uluucbc.l,4),\n       '   'RIGHT(act.l,4)'  'ok.l\n    end                                          /* End  Print output */\nExit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LISTENVO": {"ttr": 2573, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x01\\x00\\x94\\x08\\x8f\\x01\\x14\\x05\\x0f\"W\\x00\\x92\\x00\\x92\\x00\\x00\\xe2\\xc3\\xd5\\xe2\\xf0\\xf3@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1994-03-29T00:00:00", "modifydate": "2014-02-19T22:57:01", "lines": 146, "newlines": 146, "modlines": 0, "user": "SCNS03"}, "text": "/*REXX*/\n/*****************************************************************/\n/* LISTENV: REXX program to display system environment data.     */\n/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */\n/*****************************************************************/\n/* MVS DATA AREAS:                                               */\n/*                CVT - Communications Vector Table (@'10'x)     */\n/*              JESCT - JES Control Table                        */\n/*             PCCAVT - Phys. Config. Comm. Area Vector Table    */\n/*               PCCA - Physical Config. Communications Area     */\n/*               TSVT - TSO Vector Table                         */\n/*               MQCT - HSM CVT                                  */\n/*                RCE - RSM Control and Enumeration Area         */\n/*                PSA - Prefixed Saved Area (CVT & PSAATCVT)     */\n/*              ASMVT - ASM Vector Table                         */\n/*                DCQ - Device Class Queue                       */\n/*                UCB - Device Unit Control Block                */\n/*****************************************************************/\nAddress TSO ; \"CLEAR\" ; Numeric Digits 10\n@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */\n@cvt = D2X(C2D(@cvt))                                /* binary to hex */\n@cvtprodn = D2X(X2D(@cvt)-40)                 /* get CVTPRODN address */\nmvssplvl  = STORAGE(@cvtprodn,8)                      /* get SP level */\n@cvtprodi = D2X(X2D(@cvt)-32)                 /* get CVTPRODI address */\nmvsfmid   = STORAGE(@cvtprodi,8)                          /* get FMID */\n@cvtmdl   = D2X(X2D(@cvt)-6)                    /* get CVTMDL address */\ncpumodel  = STORAGE(@cvtmdl,2)                           /* get MODEL */\ncpumodel  = C2X(cpumodel)\n@cvtsysad = STORAGE(D2X(X2D(@cvt)+48),4)      /* get CVTSYSAD address */\n@cvtsysad = D2X(C2D(@cvtsysad))                      /* binary to hex */\nsysresucb = STORAGE(@cvtsysad,48)                          /* get UCB */\nucbchan   = SUBSTR(sysresucb,5,2)\nucbchan   = SUBSTR(C2X(ucbchan),2)\nucbvoli   = SUBSTR(sysresucb,29,6)\n@cvttvt   = STORAGE(D2X(X2D(@cvt)+156),4)       /* get CVTTVT address */\n@cvttvt   = D2X(C2D(@cvttvt))                        /* binary to hex */\ntsvtlver  = STORAGE(D2X(X2D(@cvttvt)+100),1)          /* get TSVTLVER */\ntsvtlrel  = STORAGE(D2X(X2D(@cvttvt)+101),2)          /* get TSVTLREL */\ntsvtlmod  = STORAGE(D2X(X2D(@cvttvt)+103),1)          /* get TSVTLMOD */\n  tsoe = tsvtlver'.'tsvtlrel'.'tsvtlmod\n@cvtmz00  = STORAGE(D2X(X2D(@cvt)+164),4)              /* get CVTMZ00 */\n@cvtmz00  = D2X(C2D(@cvtmz00))                       /* binary to hex */\n  eovm  = ((X2D(@cvtmz00)+1)/1048576)'M'\n@cvtjesct = STORAGE(D2X(X2D(@cvt)+296),4)     /* get CVTJESCT address */\n@cvtjesct = D2X(C2D(@cvtjesct))                      /* binary to hex */\n  jes     = STORAGE(D2X(X2D(@cvtjesct)+28),4)         /* get JES name */\n@cvteorm  = STORAGE(D2X(X2D(@cvt)+312),4)      /* get CVTEORM address */\n@cvteorm  = D2X(C2D(@cvteorm))                       /* binary to hex */\n  cstor = ((X2D(@cvteorm)+1)/1048576)'M'             /* convert to MB */\n@cvtext2  = STORAGE(D2X(X2D(@cvt)+328),4)      /* get CVTEXT2 address */\n@cvtext2  = D2X(C2D(@cvtext2))                       /* binary to hex */\ncvtnucls  = STORAGE(D2X(X2D(@cvtext2)+4),1)   /* get selected nucleus */\n@cvtasmvt = STORAGE(D2X(X2D(@cvt)+704),4)     /* get CVTASMVT address */\n@cvtasmvt = D2X(C2D(@cvtasmvt))                      /* binary to hex */\nasmflag2  = STORAGE(D2X(X2D(@cvtasmvt)+1),1)\n  clpa = '(NO CLPA)'\n  If BITAND(asmflag2,'08'x) \\= '08'x Then clpa = '(CLPA)'\n@cvtpccat = STORAGE(D2X(X2D(@cvt)+764),4)     /* get CVTPCCAT address */\n@cvtpccat = D2X(C2D(@cvtpccat))                      /* binary to hex */\n@cvtrlstg = STORAGE(D2X(X2D(@cvt)+856),4)       /* get CVTRLSTG bytes */\n@cvtrlstg = C2D(@cvtrlstg)                           /* binary to dec */\n  cstorol = ((@cvtrlstg)/1024)'M'                    /* convert to MB */\n@cvthsm   = STORAGE(D2X(X2D(@cvt)+988),4)       /* get CVTHSM address */\n@cvthsm   = D2X(C2D(@cvthsm))                        /* binary to hex */\nmqctver   = STORAGE(D2X(X2D(@cvthsm)+48),2)            /* get MQCTVER */\nmqctrel   = STORAGE(D2X(X2D(@cvthsm)+50),1)            /* get MQCTREL */\nmqctmod   = STORAGE(D2X(X2D(@cvthsm)+51),1)            /* get MQCTMOD */\n  hsm  = mqctver'.'mqctrel'.'mqctmod\n@cvtdfa   = STORAGE(D2X(X2D(@cvt)+1216),4)      /* get CVTDFA address */\n@cvtdfa   = D2X(C2D(@cvtdfa))                        /* binary to hex */\ndfadata   = STORAGE(@cvtdfa,4)                  /* get DFP level data */\ndfadata   = C2X(dfadata)\ndfaver    = SUBSTR(dfadata,5,1)                    /* get DFP version */\ndfarel    = SUBSTR(dfadata,6,1)                    /* get DFP release */\ndfamod    = SUBSTR(dfadata,7,1)                    /* get DFP mod lvl */\n  dfp  = dfaver'.'dfarel'.'dfamod\n@cvtrcep  = STORAGE(D2X(X2D(@cvt)+1168),4)     /* get CVTRCEP address */\n@cvtrcep  = D2X(C2D(@cvtrcep))                       /* binary to hex */\nrceespl   = STORAGE(D2X(X2D(@cvtrcep)+160),4)  /* get RCEESPL frames  */\n  estor = ((C2D(rceespl)*4096)/1048576)'M'           /* convert to MB */\n@psaatcvt = STORAGE(408,4)             /* get VTAM ATCVT from PSAAOLD */\n@psaatcvt = D2X(C2D(@psaatcvt))                      /* binary to hex */\natcvtdata = STORAGE(@psaatcvt,4)               /* get VTAM level data */\natcvtdata = C2X(atcvtdata)\natcvtver  = SUBSTR(atcvtdata,6,1)                 /* get VTAM version */\natcvtrel  = SUBSTR(atcvtdata,8,1)                 /* get VTAM release */\n  vtam = atcvtver'.'atcvtrel\nSay 'CVT:'@cvt'   SYSTEM ENVIRONMENT DATA on 'DATE() TIME()\nSay ' '\nSay '   Software -   MVS: 'mvssplvl' ('STRIP(mvsfmid)')    JES: 'jes\nSay '                DFP: 'dfp'               TSO/E: 'tsoe\nSay '               VTAM: 'vtam'                   HSM:'hsm\nSay '                IPL: 'ucbvoli' @ 'ucbchan'      Nucleus: 'cvtnucls'  'clpa\nSay ' '\nSay '  Processor - Model: 'cpumodel\nSay '              CSTOR: 'cstor'   ('cstorol' on-line)    ESTOR: 'estor\nSay '              VSTOR: 'eovm'  (Highest virtual address '@cvtmz00'/'X2D(@cvtmz00)')'\nDo i = 0 to 15                                 /* loop thru CPU table */\n   @pcca = STORAGE(D2X(X2D(@cvtpccat)+(i*4)),4)\n   @pcca = C2X(@pcca)\n   If @pcca \\= 0 Then Do\n      Say '                CPU: 'RIGHT(i,2,0),\n          '    ('STORAGE(D2X(X2D(@pcca)+4),8)')'\n      End\n   End\n@cvtdcqa  = STORAGE(D2X(X2D(@cvt)+1248),4)     /* get CVTDCQA address */\n@cvtdcqa  = D2X(C2D(@cvtdcqa))                       /* binary to hex */\ndcq      = STORAGE(@cvtdcqa,20)             /* get 20 byte DCQ header */\ndcqcount = SUBSTR(dcq,7,2)                      /* number of elements */\ndcqfirst = SUBSTR(dcq,9,4)              /* address of 1st dcq element */\n@dcqchn  = C2X(dcqfirst) ; i = 0\nSay ' '\nSay '        I/O - Device     UCBs  Active  ID=UCB'\nSay '              --------   ----  ------  ------'\nDo While @dcqchn \\= 0 & i < 100\n   i = i + 1\n   dcqelmnt = STORAGE(@dcqchn,28)          /* get 28 byte DCQ element */\n   dcqchain = SUBSTR(dcqelmnt,1,4)      /* get next element's address */\n   @dcqchn  = D2X(C2D(dcqchain))\n   dcqdevcl = SUBSTR(dcqelmnt,5,1)     /* device class, i.e. UCBTBYT3 */\n   dcqucbct = SUBSTR(dcqelmnt,7,2)     /* ucb's for this device class */\n   dcqucbct = C2D(dcqucbct)\n   dcqucbad = SUBSTR(dcqelmnt,9,4)       /* 1st ucb this device class */\n   dcqucbad = C2X(dcqucbad) ; @ucbchn = dcqucbad\n   active = 0 ; check = 0\n   Do j = 1 to dcqucbct           /* scan ucb chain this device class */\n      If @ucbchn = 0 Then Leave\n      ucb     = STORAGE(@ucbchn,24) /* get 24 byte ucb common segment */\n      ucbstat = SUBSTR(ucb,4,1)           /* status byte '80'x online */\n      ucbnxucb= SUBSTR(ucb,9,4)                /* pointer to next ucb */\n      ucbtbyt3= SUBSTR(ucb,19,1)           /* device ID like dcqdevcl */\n      If BITAND(ucbstat,'80'x)='80'x Then active = active + 1\n      If BITAND(ucbtbyt3,dcqdevcl)=dcqdevcl Then check = check + 1\n      @ucbchn = C2X(ucbnxucb)\n   End\n   ok = 'ERROR ' ; If check = dcqucbct Then ok = '*okay*'\n   dcqdevnm = SUBSTR(dcqelmnt,13,8)              /* device class name */\n   If dcqucbad = '00000000' & dcqucbct = 0 Then Do\n      active   = '    '\n      ok       = '      '\n   End\n   Say '              'dcqdevnm,\n       '  'RIGHT(dcqucbct,4),\n       '  'RIGHT(active,4)'   'ok\nEnd\nExit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LISTESRT": {"ttr": 2817, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x03\\x00\\x94\\x08\\x8f\\x01\\x14\\x05\\x0f\"W\\x00\\xc2\\x00\\xc2\\x00\\x00\\xe2\\xc3\\xd5\\xe2\\xf0\\xf3@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1994-03-29T00:00:00", "modifydate": "2014-02-19T22:57:03", "lines": 194, "newlines": 194, "modlines": 0, "user": "SCNS03"}, "text": "/*REXX*/\n/*****************************************************************/\n/*LISTESRT: REXX program to display all router SVCs.             */\n/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */\n/*****************************************************************/\n/* MVS DATA AREAS:                                               */\n/*                CVT - Communications Vector Table (@'10'x)     */\n/*               SCVT - Supervisor Call Vector Table             */\n/*                                                               */\n/*                                                               */\n/*****************************************************************/\n/*--------------virtual storage map definition section----------------*/\nNumeric Digits 10           /* required to handle decimal conversions */\n@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */\n@cvt = D2X(C2D(@cvt))                    /* binary to hex             */\n@cvtreal  = STORAGE(D2X(X2D(@cvt)+284),4)    /* get CVTREAL address   */\n@cvtreal  = D2X(C2D(@cvtreal))                 /* binary to hex       */\n@cvtshrvm = STORAGE(D2X(X2D(@cvt)+416),4)    /* get CVTSHRVM address  */\n@cvtshrvm = D2X(C2D(@cvtshrvm))                /* binary to hex       */\n@cvtgda   = STORAGE(D2X(X2D(@cvt)+560),4)    /* get CVTGDA address    */\n@cvtgda   = D2X(C2D(@cvtgda))                  /* binary to hex       */\n@gdacsa   = D2X(X2D(@cvtgda)+108)            /* locate GDACSAstarts   */\n@gdacsa   = D2X(C2D(STORAGE(@gdacsa,4)))       /*  get GDACSA         */\n@gdacsasz = D2X(X2D(@cvtgda)+112)            /* locate GDACSASiZe     */\n@gdacsasz = D2X(C2D(STORAGE(@gdacsasz,4)))     /*  get GDACSASiZe     */\n@gdaecsa  = D2X(X2D(@cvtgda)+124)            /* locate GDAECSAstarts  */\n@gdaecsa  = D2X(C2D(STORAGE(@gdaecsa,4)))      /*  get GDAECSA        */\n@gdaecsas = D2X(X2D(@cvtgda)+128)            /* locate GDAECSASize    */\n@gdaecsas = D2X(C2D(STORAGE(@gdaecsas,4)))     /*  get GDAECSAS       */\n@cvtsmext = STORAGE(D2X(X2D(@cvt)+1196),4)   /* get CVTSMEXT address  */\n@cvtsmext = D2X(C2D(@cvtsmext))                /* binary to hex       */\n@cvtmlpas = D2X(X2D(@cvtsmext)+8)            /* locate CVTMLPAStarts  */\n@cvtmlpas = D2X(C2D(STORAGE(@cvtmlpas,4)))     /*  get CVTMLPAS       */\n@cvtmlpae = D2X(X2D(@cvtsmext)+12)           /* locate CVTMLPAEnds    */\n@cvtmlpae = D2X(C2D(STORAGE(@cvtmlpae,4)))     /*  get CVTMLPAE       */\n@cvtflpas = D2X(X2D(@cvtsmext)+16)           /* locate CVTFLPAStarts  */\n@cvtflpas = D2X(C2D(STORAGE(@cvtflpas,4)))     /*  get CVTFLPAS       */\n@cvtflpae = D2X(X2D(@cvtsmext)+20)           /* locate CVTFLPAEnds    */\n@cvtflpae = D2X(C2D(STORAGE(@cvtflpae,4)))     /*  get CVTFLPAE       */\n@cvtplpas = D2X(X2D(@cvtsmext)+24)           /* locate CVTPLPAStarts  */\n@cvtplpas = D2X(C2D(STORAGE(@cvtplpas,4)))     /*  get CVTPLPAS       */\n@cvtplpae = D2X(X2D(@cvtsmext)+28)           /* locate CVTPLPAEnds    */\n@cvtplpae = D2X(C2D(STORAGE(@cvtplpae,4)))     /*  get CVTPLPAE       */\n@cvtrwns  = D2X(X2D(@cvtsmext)+32)           /* locate CVTRWNStarts   */\n@cvtrwns  = D2X(C2D(STORAGE(@cvtrwns,4)))      /*  get CVTRWNS        */\n@cvtrwne  = D2X(X2D(@cvtsmext)+36)           /* locate CVTRWNEnds     */\n@cvtrwne  = D2X(C2D(STORAGE(@cvtrwne,4)))      /*  get CVTRWNE        */\n@cvtrons  = D2X(X2D(@cvtsmext)+40)           /* locate CVTRONStarts   */\n@cvtrons  = D2X(C2D(STORAGE(@cvtrons,4)))      /*  get CVTRONS        */\n@cvtrone  = D2X(X2D(@cvtsmext)+44)           /* locate CVTRONEnds     */\n@cvtrone  = D2X(C2D(STORAGE(@cvtrone,4)))      /*  get CVTRONE        */\n@cvterwns = D2X(X2D(@cvtsmext)+48)           /* locate CVTERWNStarts  */\n@cvterwns = D2X(C2D(STORAGE(@cvterwns,4)))     /*  get CVTERWNS       */\n@cvterwne = D2X(X2D(@cvtsmext)+52)           /* locate CVTERWNEnds    */\n@cvterwne = D2X(C2D(STORAGE(@cvterwne,4)))     /*  get CVTRRWNE       */\n@cvteplps = D2X(X2D(@cvtsmext)+56)           /* locate CVTEPLPStarts  */\n@cvteplps = D2X(C2D(STORAGE(@cvteplps,4)))     /*  get CVTEPLPS       */\n@cvteplpe = D2X(X2D(@cvtsmext)+60)           /* locate CVTEPLPEnds    */\n@cvteplpe = D2X(C2D(STORAGE(@cvteplpe,4)))     /*  get CVTRPLPE       */\n@cvteflps = D2X(X2D(@cvtsmext)+64)           /* locate CVTEFLPStarts  */\n@cvteflps = D2X(C2D(STORAGE(@cvteflps,4)))     /*  get CVTEFLPS       */\n@cvteflpe = D2X(X2D(@cvtsmext)+68)           /* locate CVTEFLPEnds    */\n@cvteflpe = D2X(C2D(STORAGE(@cvteflpe,4)))     /*  get CVTRFLPE       */\n@cvtemlps = D2X(X2D(@cvtsmext)+72)           /* locate CVTEMLPStarts  */\n@cvtemlps = D2X(C2D(STORAGE(@cvtemlps,4)))     /*  get CVTEMLPS       */\n@cvtemlpe = D2X(X2D(@cvtsmext)+76)           /* locate CVTEMLPEnds    */\n@cvtemlpe = D2X(C2D(STORAGE(@cvtemlpe,4)))     /*  get CVTRMLPE       */\n        /*------simplify variable names & make addresses decimal------*/\n@csa1g  = @gdacsa    ; @csa2g = D2X(X2D(@gdacsasz)+X2D(@gdacsa)-1)/* g*/\n   csa1 = X2D(@csa1g) ; csa2 = X2D(@csa2g)                    /* csa  */\n@mlpa1  = @cvtmlpas  ; @mlpa2 = @cvtmlpae                     /* mlpa */\n   mlpa1 = X2D(@mlpa1) ; mlpa2 = X2D(@mlpa2)\n@flpa1  = @cvtflpas  ; @flpa2 = @cvtflpae                     /* flpa */\n   flpa1 = X2D(@flpa1) ; flpa2 = X2D(@flpa2)\n@plpa1  = @cvtplpas  ; @plpa2 = @cvtplpae                     /* plpa */\n   plpa1 = X2D(@plpa1) ; plpa2 = X2D(@plpa2)\n@sqa1   = D2X(X2D(@cvtplpae)+1) ; @sqa2 = D2X(X2D(@cvtrwns)-1)/* sqa  */\n   sqa1 = X2D(@sqa1) ; sqa2 = X2D(@sqa2)\n@nuc1   = @cvtrwns   ; @nuc2  = @cvterwne                     /* nuc  */\n   nuc1 = X2D(@nuc1) ; nuc2 = X2D(@nuc2)\n@esqa1  = D2X(X2D(@nuc2)+1) ; @esqa2 = D2X(X2D(@cvteplps)-1)  /* esqa */\n  esqa1 = X2D(@esqa1) ; esqa2 = X2D(@esqa2)\n@eplpa1 = @cvteplps  ; @eplpa2 = @cvteplpe                    /* eplpa*/\n eplpa1 = X2D(@eplpa1) ; eplpa2 = X2D(@eplpa2)\n@eflpa1 = @cvteflps  ; @eflpa2 = @cvteflpe                    /* eflpa*/\n eflpa1 = X2D(@eflpa1) ; eflpa2 = X2D(@eflpa2)\n@emlpa1 = @cvtemlps  ; @emlpa2 = @cvtemlpe                    /* emlpa*/\n emlpa1 = X2D(@emlpa1) ; emlpa2 = X2D(@emlpa2)\n@ecsa1g = @gdaecsa   ; @ecsa2g= D2X(X2D(@gdaecsas)+X2D(@gdaecsa)-1)/*g*/\n  ecsa1 = X2D(@ecsa1g) ; ecsa2 = X2D(@ecsa2g)\n@eprivs = X2D(@ecsa2g)+1                               /* ext private */\n@eprive = 2147483647                         /* fixed by architecture */\n epriv1 = @eprivs ; epriv2 = @eprive\n@psas   = 0 ; @psae = 4095                       /* psa fixed by arch */\n   psa1 = @psas ; psa2 = @psae\n@prive  = X2D(@csa1g)-1 ; @privs = X2D(@psae)+1            /* private */\n  priv1 = @privs ; priv2 = @prive\n              /*------------------------------------------------------*/\n             /* Usage Notes: Hex character compares are incompatible */\n            /*    for storage residency determination.  Thus, entry */\n           /*     point addresses must be converted to decimal and */\n          /*      VS boundary addresses must be converted to de-  */\n         /*       cimal for correct compare operations.          */\n        /*------------------------------------------------------*/\n/*----------end of virtual storage map definition section-------------*/\n@cvtabend = STORAGE(D2X(X2D(@cvt)+200),4)    /* get CVTABEND address  */\n@cvtabend = D2X(C2D(@cvtabend))                /* binary to hex       */\n@scvtsvct = D2X(X2D(@cvtabend)+132)          /* SCVT addressibility   */\n@scvtsvct = STORAGE(@scvtsvct,4)                  /* SVCT table       */\n@scvtsvct = D2X(C2D(@scvtsvct))                /* binary to hex       */\nAddress TSO ; \"CLEAR\"\nSay 'CVT:'@cvt' CVTABEND:'@cvtabend' SCVTSVCT:'@scvtsvct' 'DATE() TIME()\nSay ' '\nSay 'Active ESR SVCs follow:'\nSay ' '\nactive = 0 ; inactive = 0 ; esrsvc = 0\nmodule = 'IGXERROR' ; Call \"#NUCLKUP\" module ; igxerror = Result\nDo i = 0 to 255                                 /* loop thru storage  */\n   bytes = STORAGE(D2X(X2D(@scvtsvct)+(i*8)),8)\n   bytes = C2X(bytes)\n   svcep  = SUBSTR(bytes,1,8)\n   svctp2 = SUBSTR(bytes,10,1)\n   If svctp2 = '4'            /* EP address is an ESR table */\n      Then Do\n         esrid = STORAGE(svcep,4)                 /* table eyecatcher */\n         esrct = C2X(STORAGE(D2X(X2D(svcep)+4),4))       /* esr count */\n         Say 'SVC 'i' is 'esrid'.  Table at 'svcep', Slots 'X2D(esrct)' ('esrct')'\n         Say ' '\n         esrsvc = 0\n         Do j = 0 to X2D(esrct)                   /* process this ESR */\n            bytes = STORAGE(D2X(X2D(svcep)+(j*8)+8),8)\n   addr = SUBSTR(bytes,1,4)       /* sloppy code to grap EP in binary */\n   bytes = C2X(bytes)          /* legacy code before learning bit ops */\n            esrep  = SUBSTR(bytes,1,8)\n                                        /* determine storage location */\n   addr = BITAND(addr,'7FFFFFFF'x)        /* shave off amode bit (32) */\n   addr = C2D(addr)                      /* make numeric for compares */\n   sloc = 'ERROR'                       /* determine module residency */\n   If (addr >= csa1   & addr <= csa2  ) Then sloc = 'CSA  '\n      Else If (addr >= mlpa1  & addr <= mlpa2 ) Then sloc = 'MLPA '\n      Else If (addr >= flpa1  & addr <= flpa2 ) Then sloc = 'FLPA '\n      Else If (addr >= plpa1  & addr <= plpa2 ) Then sloc = 'PLPA '\n      Else If (addr >= sqa1   & addr <= sqa2  ) Then sloc = 'SQA  '\n      Else If (addr >= nuc1   & addr <= nuc2  ) Then sloc = 'NUC  '\n      Else If (addr >= esqa1  & addr <= esqa2 ) Then sloc = 'ESQA '\n      Else If (addr >= eplpa1 & addr <= eplpa2) Then sloc = 'EPLPA'\n      Else If (addr >= eflpa1 & addr <= eflpa2) Then sloc = 'EFLPA'\n      Else If (addr >= emlpa1 & addr <= emlpa2) Then sloc = 'EMLPA'\n      Else If (addr >= ecsa1  & addr <= ecsa2 ) Then sloc = 'ECSA '\n      Else If (addr >= epriv1 & addr <= epriv2) Then sloc = 'EPRIV'\n      Else If (addr >= priv1  & addr <= priv2 ) Then sloc = 'PRIV '\n      Else If (addr >= psa1   & addr <= psa2  ) Then sloc = 'PSA  '\n            esrtp2 = SUBSTR(bytes,10,1)\n            esrmisc = '   '\n            If esrtp2 = '8'\n               Then esrmisc = 'APF'\n            inactflag = 0\n            If igxerror = Right(D2X(addr),8,0) /* normalize address */\n               Then inactflag = 1\n               Else Do\n                       active = active + 1\n                       esrsvc = esrsvc + 1\n                    End\n            esrtp1 = SUBSTR(bytes,9,1)\n               Select\n                  When esrtp1 = '0'\n                     Then esrtype = 'TYPE 1  '\n                  When esrtp1 = '8'\n                     Then esrtype = 'TYPE 2  '\n                  When esrtp1 = 'C'\n                     Then esrtype = 'TYPE 3/4'\n                  When esrtp1 = '2'\n                     Then esrtype = 'TYPE 6  '\n               Otherwise\n                          esrtype = 'TYPE ?  '\n               End\n            If inactflag = 0\n               Then Say  '   ESR 'RIGHT(j,3,0) '('RIGHT(D2X(j),2,0)')',\n                          esrtype esrep sloc esrmisc\n         End\n         Say ' '\n         Say '     Total ESR SVCs this table 'esrsvc\n         Say ' '\n         Say ' '\n      End\nEnd\nSay ' '\nSay 'This system contains 'active' ESR SVCs'\nSay ' '\nSay '  (IGXERROR nucleus address = 'igxerror')'\nSay ' '\nSay 'ESRTABLE processing complete ' TIME()\nSay ' '\nExit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LISTLLT": {"ttr": 2820, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x06\\x00\\x94\\x08\\x8f\\x01\\x14\\x05\\x0f\"W\\x00-\\x00-\\x00\\x00\\xe2\\xc3\\xd5\\xe2\\xf0\\xf3@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1994-03-29T00:00:00", "modifydate": "2014-02-19T22:57:06", "lines": 45, "newlines": 45, "modlines": 0, "user": "SCNS03"}, "text": "/*REXX*/\n/*****************************************************************/\n/* LISTLLT: REXX program to display Linklist Lookaside Table.    */\n/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */\n/*****************************************************************/\n/* MVS DATA AREAS:                                               */\n/*                CVT - Communications Vector Table (@'10'x)     */\n/*                LLT - Linklist Lookaside Table                 */\n/*               DCB3 - Data Control Block (BDAM)                */\n/*                DEB - IOS Data Extent Block                    */\n/*                                                               */\n/*****************************************************************/\n@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */\n@cvt = D2X(C2D(@cvt))                    /* binary to hex             */\n@cvtlink  = STORAGE(D2X(X2D(@cvt)+8),4)      /* get CVTLINK address   */\n@cvtlink  = D2X(C2D(@cvtlink))                 /* binary to hex       */\n@dcbdebad = STORAGE(D2X(X2D(@cvtlink)+44),4)    /* LINKLIB DCB to DEB */\n@dcbdebad = D2X(C2D(@dcbdebad))                 /* convert to hex     */\ndebflgs1  = STORAGE(D2X(X2D(@dcbdebad)+14),1)     /* LINKLIB DEBflags */\n   debapfin = 'LNKLST'\n   If BITAND(debflgs1,'02'x)\\='02'x Then debapfin = 'APFTAB'\n@cvtllta  = STORAGE(D2X(X2D(@cvt)+1244),4)   /* get CVTLLTA address   */\n@cvtllta  = D2X(C2D(@cvtllta))                 /* binary to hex       */\nlltcount  = C2D(STORAGE(D2X(X2D(@cvtllta)+7),1))  /* LLT libraries    */\nlltllen   = C2D(STORAGE(D2X(X2D(@cvtllta)+8),1))  /* length 1st entry */\n@lltentry = X2D(@cvtllta)+9           /* address of 1st LLT entry     */\nAddress TSO ; \"CLEAR\"\nSay 'CVT:'@cvt' CVTLLTA:'@cvtllta' DCB:'@cvtlink,\n    'DEB:'@dcbdebad' FLGS1:'C2X(debflgs1)' LNKAUTH='debapfin\nSay ' '\nSay 'LLT scan on 'DATE()' started: 'TIME()\nSay ' '\nDo i = 1 to lltcount                            /* loop thru storage  */\n   lltlib.i = STORAGE(D2X(@lltentry),lltllen)   /* get the LLT entry  */\n   @lltentry = @lltentry + 45                   /* bump to next entry */\n   lltllen = C2D(STORAGE(D2X(@lltentry-1),1))   /* length of next  */\nEnd\nSay '--------------DATA SET NAME-----------------'\nSay ' '\nDo i = 1 to lltcount                            /* print the list     */\n   Say SUBSTR(lltlib.i,1,44,' ') i\nEnd\nSay ' '\nSay 'LLT scan completed: 'TIME()\nExit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LISTLPAQ": {"ttr": 2057, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x008\\x00\\x94\\x08\\x8f\\x01\\x14\\x05\\x0f\"@\\x00\\xa2\\x00\\xa2\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1994-03-29T00:00:00", "modifydate": "2014-02-19T22:40:38", "lines": 162, "newlines": 162, "modlines": 0, "user": "SBGOLOB"}, "text": "/*REXX*/\n/*****************************************************************/\n/*LISTLPAQ: REXX program to display LPA Queue (MVS job pack).    */\n/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */\n/*****************************************************************/\n/* MVS DATA AREAS:                                               */\n/*                CVT - Communications Vector Table (@'10'x)     */\n/*                GDA - Global Data Area                         */\n/*               LPAQ - Link Pack Area Queue                     */\n/*                CDE - Contents Directory Entry                 */\n/*                                                               */\n/*****************************************************************/\n/*--------------virtual storage map definition section----------------*/\nNumeric Digits 10           /* required to handle decimal conversions */\n@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */\n@cvt = D2X(C2D(@cvt))                    /* binary to hex             */\n@cvtreal  = STORAGE(D2X(X2D(@cvt)+284),4)    /* get CVTREAL address   */\n@cvtreal  = D2X(C2D(@cvtreal))                 /* binary to hex       */\n@cvtshrvm = STORAGE(D2X(X2D(@cvt)+416),4)    /* get CVTSHRVM address  */\n@cvtshrvm = D2X(C2D(@cvtshrvm))                /* binary to hex       */\n@cvtgda   = STORAGE(D2X(X2D(@cvt)+560),4)    /* get CVTGDA address    */\n@cvtgda   = D2X(C2D(@cvtgda))                  /* binary to hex       */\n@gdacsa   = D2X(X2D(@cvtgda)+108)            /* locate GDACSAstarts   */\n@gdacsa   = D2X(C2D(STORAGE(@gdacsa,4)))       /*  get GDACSA         */\n@gdacsasz = D2X(X2D(@cvtgda)+112)            /* locate GDACSASiZe     */\n@gdacsasz = D2X(C2D(STORAGE(@gdacsasz,4)))     /*  get GDACSASiZe     */\n@gdaecsa  = D2X(X2D(@cvtgda)+124)            /* locate GDAECSAstarts  */\n@gdaecsa  = D2X(C2D(STORAGE(@gdaecsa,4)))      /*  get GDAECSA        */\n@gdaecsas = D2X(X2D(@cvtgda)+128)            /* locate GDAECSASize    */\n@gdaecsas = D2X(C2D(STORAGE(@gdaecsas,4)))     /*  get GDAECSAS       */\n@cvtsmext = STORAGE(D2X(X2D(@cvt)+1196),4)   /* get CVTSMEXT address  */\n@cvtsmext = D2X(C2D(@cvtsmext))                /* binary to hex       */\n@cvtmlpas = D2X(X2D(@cvtsmext)+8)            /* locate CVTMLPAStarts  */\n@cvtmlpas = D2X(C2D(STORAGE(@cvtmlpas,4)))     /*  get CVTMLPAS       */\n@cvtmlpae = D2X(X2D(@cvtsmext)+12)           /* locate CVTMLPAEnds    */\n@cvtmlpae = D2X(C2D(STORAGE(@cvtmlpae,4)))     /*  get CVTMLPAE       */\n@cvtflpas = D2X(X2D(@cvtsmext)+16)           /* locate CVTFLPAStarts  */\n@cvtflpas = D2X(C2D(STORAGE(@cvtflpas,4)))     /*  get CVTFLPAS       */\n@cvtflpae = D2X(X2D(@cvtsmext)+20)           /* locate CVTFLPAEnds    */\n@cvtflpae = D2X(C2D(STORAGE(@cvtflpae,4)))     /*  get CVTFLPAE       */\n@cvtplpas = D2X(X2D(@cvtsmext)+24)           /* locate CVTPLPAStarts  */\n@cvtplpas = D2X(C2D(STORAGE(@cvtplpas,4)))     /*  get CVTPLPAS       */\n@cvtplpae = D2X(X2D(@cvtsmext)+28)           /* locate CVTPLPAEnds    */\n@cvtplpae = D2X(C2D(STORAGE(@cvtplpae,4)))     /*  get CVTPLPAE       */\n@cvtrwns  = D2X(X2D(@cvtsmext)+32)           /* locate CVTRWNStarts   */\n@cvtrwns  = D2X(C2D(STORAGE(@cvtrwns,4)))      /*  get CVTRWNS        */\n@cvtrwne  = D2X(X2D(@cvtsmext)+36)           /* locate CVTRWNEnds     */\n@cvtrwne  = D2X(C2D(STORAGE(@cvtrwne,4)))      /*  get CVTRWNE        */\n@cvtrons  = D2X(X2D(@cvtsmext)+40)           /* locate CVTRONStarts   */\n@cvtrons  = D2X(C2D(STORAGE(@cvtrons,4)))      /*  get CVTRONS        */\n@cvtrone  = D2X(X2D(@cvtsmext)+44)           /* locate CVTRONEnds     */\n@cvtrone  = D2X(C2D(STORAGE(@cvtrone,4)))      /*  get CVTRONE        */\n@cvterwns = D2X(X2D(@cvtsmext)+48)           /* locate CVTERWNStarts  */\n@cvterwns = D2X(C2D(STORAGE(@cvterwns,4)))     /*  get CVTERWNS       */\n@cvterwne = D2X(X2D(@cvtsmext)+52)           /* locate CVTERWNEnds    */\n@cvterwne = D2X(C2D(STORAGE(@cvterwne,4)))     /*  get CVTRRWNE       */\n@cvteplps = D2X(X2D(@cvtsmext)+56)           /* locate CVTEPLPStarts  */\n@cvteplps = D2X(C2D(STORAGE(@cvteplps,4)))     /*  get CVTEPLPS       */\n@cvteplpe = D2X(X2D(@cvtsmext)+60)           /* locate CVTEPLPEnds    */\n@cvteplpe = D2X(C2D(STORAGE(@cvteplpe,4)))     /*  get CVTRPLPE       */\n@cvteflps = D2X(X2D(@cvtsmext)+64)           /* locate CVTEFLPStarts  */\n@cvteflps = D2X(C2D(STORAGE(@cvteflps,4)))     /*  get CVTEFLPS       */\n@cvteflpe = D2X(X2D(@cvtsmext)+68)           /* locate CVTEFLPEnds    */\n@cvteflpe = D2X(C2D(STORAGE(@cvteflpe,4)))     /*  get CVTRFLPE       */\n@cvtemlps = D2X(X2D(@cvtsmext)+72)           /* locate CVTEMLPStarts  */\n@cvtemlps = D2X(C2D(STORAGE(@cvtemlps,4)))     /*  get CVTEMLPS       */\n@cvtemlpe = D2X(X2D(@cvtsmext)+76)           /* locate CVTEMLPEnds    */\n@cvtemlpe = D2X(C2D(STORAGE(@cvtemlpe,4)))     /*  get CVTRMLPE       */\n        /*------simplify variable names & make addresses decimal------*/\n@csa1g  = @gdacsa    ; @csa2g = D2X(X2D(@gdacsasz)+X2D(@gdacsa)-1)/* g*/\n   csa1 = X2D(@csa1g) ; csa2 = X2D(@csa2g)                    /* csa  */\n@mlpa1  = @cvtmlpas  ; @mlpa2 = @cvtmlpae                     /* mlpa */\n   mlpa1 = X2D(@mlpa1) ; mlpa2 = X2D(@mlpa2)\n@flpa1  = @cvtflpas  ; @flpa2 = @cvtflpae                     /* flpa */\n   flpa1 = X2D(@flpa1) ; flpa2 = X2D(@flpa2)\n@plpa1  = @cvtplpas  ; @plpa2 = @cvtplpae                     /* plpa */\n   plpa1 = X2D(@plpa1) ; plpa2 = X2D(@plpa2)\n@sqa1   = D2X(X2D(@cvtplpae)+1) ; @sqa2 = D2X(X2D(@cvtrwns)-1)/* sqa  */\n   sqa1 = X2D(@sqa1) ; sqa2 = X2D(@sqa2)\n@nuc1   = @cvtrwns   ; @nuc2  = @cvterwne                     /* nuc  */\n   nuc1 = X2D(@nuc1) ; nuc2 = X2D(@nuc2)\n@esqa1  = D2X(X2D(@nuc2)+1) ; @esqa2 = D2X(X2D(@cvteplps)-1)  /* esqa */\n  esqa1 = X2D(@esqa1) ; esqa2 = X2D(@esqa2)\n@eplpa1 = @cvteplps  ; @eplpa2 = @cvteplpe                    /* eplpa*/\n eplpa1 = X2D(@eplpa1) ; eplpa2 = X2D(@eplpa2)\n@eflpa1 = @cvteflps  ; @eflpa2 = @cvteflpe                    /* eflpa*/\n eflpa1 = X2D(@eflpa1) ; eflpa2 = X2D(@eflpa2)\n@emlpa1 = @cvtemlps  ; @emlpa2 = @cvtemlpe                    /* emlpa*/\n emlpa1 = X2D(@emlpa1) ; emlpa2 = X2D(@emlpa2)\n@ecsa1g = @gdaecsa   ; @ecsa2g= D2X(X2D(@gdaecsas)+X2D(@gdaecsa)-1)/*g*/\n  ecsa1 = X2D(@ecsa1g) ; ecsa2 = X2D(@ecsa2g)\n@eprivs = X2D(@ecsa2g)+1                               /* ext private */\n@eprive = 2147483647                         /* fixed by architecture */\n epriv1 = @eprivs ; epriv2 = @eprive\n@psas   = 0 ; @psae = 4095                       /* psa fixed by arch */\n   psa1 = @psas ; psa2 = @psae\n@prive  = X2D(@csa1g)-1 ; @privs = X2D(@psae)+1            /* private */\n  priv1 = @privs ; priv2 = @prive\n              /*------------------------------------------------------*/\n             /* Usage Notes: Hex character compares are incompatible */\n            /*    for storage residency determination.  Thus, entry */\n           /*     point addresses must be converted to decimal and */\n          /*      VS boundary addresses must be converted to de-  */\n         /*       cimal for correct compare operations.          */\n        /*------------------------------------------------------*/\n/*----------end of virtual storage map definition section-------------*/\n@cvtqlpaq = STORAGE(D2X(X2D(@cvt)+188),4)    /* get CVTqlpaq address  */\n@cvtqlpaq = D2X(C2D(@cvtqlpaq))                /* binary to hex       */\n@lpaqptr  = STORAGE(@cvtqlpaq,4)             /* get pointer to LPAQ   */\n@lpaqptr  = D2X(C2D(@lpaqptr))                 /* binary to hex       */\nAddress TSO ; \"CLEAR\"\nSay 'CVT:'@cvt' CVTQLPAQ:'@cvtqlpaq' LPAQPTR:'@lpaqptr' 'DATE() TIME()\n@cdechn = @lpaqptr\nSay ' '\ni = 0\nDo While @cdechn \\= '00000000'\n   i = i + 1\n   cde = STORAGE(@cdechn,32)                          /* get the cde */\n   cdname = SUBSTR(cde,9,8)\n   cdentpt= SUBSTR(cde,17,4)\n                                        /* determine storage location */\n   addr = BITAND(cdentpt,'7FFFFFFF'x)     /* shave off amode bit (32) */\n   addr = C2D(addr)                      /* make numeric for compares */\n   sloc = 'ERROR'                       /* determine module residency */\n   If (addr >= csa1   & addr <= csa2  ) Then sloc = 'CSA  '\n      Else If (addr >= mlpa1  & addr <= mlpa2 ) Then sloc = 'MLPA '\n      Else If (addr >= flpa1  & addr <= flpa2 ) Then sloc = 'FLPA '\n      Else If (addr >= plpa1  & addr <= plpa2 ) Then sloc = 'PLPA '\n      Else If (addr >= sqa1   & addr <= sqa2  ) Then sloc = 'SQA  '\n      Else If (addr >= nuc1   & addr <= nuc2  ) Then sloc = 'NUC  '\n      Else If (addr >= esqa1  & addr <= esqa2 ) Then sloc = 'ESQA '\n      Else If (addr >= eplpa1 & addr <= eplpa2) Then sloc = 'EPLPA'\n      Else If (addr >= eflpa1 & addr <= eflpa2) Then sloc = 'EFLPA'\n      Else If (addr >= emlpa1 & addr <= emlpa2) Then sloc = 'EMLPA'\n      Else If (addr >= ecsa1  & addr <= ecsa2 ) Then sloc = 'ECSA '\n      Else If (addr >= epriv1 & addr <= epriv2) Then sloc = 'EPRIV'\n      Else If (addr >= priv1  & addr <= priv2 ) Then sloc = 'PRIV '\n      Else If (addr >= psa1   & addr <= psa2  ) Then sloc = 'PSA  '\n   cdxlmjp= C2X(SUBSTR(cde,21,4))\n   cduse  = C2D(SUBSTR(cde,25,2))\n   cdattr =     SUBSTR(cde,29,1)  /* do NOT convert raw byte */\n   alias = 0 ; If (BITAND(cdattr,'04'x)='04'x) Then alias = 1\n   cdattr2=     SUBSTR(cde,30,1)  /* do NOT convert raw byte */\n   auth = 0 ; If (BITAND(cdattr2,'01'x)='01'x) Then auth = 1\n   cdemjp  = '         '\n   cdemjnm = '        '\n   If alias = 1 Then Do\n                        cdemjp  = ' Alias of'\n                        cdemjnm = STORAGE(D2X(X2D(cdxlmjp)+8),8)\n                     End\n   Say 'LPAQ'RIGHT(i,4,0),\n       cdname ,\n       C2X(cdentpt) ,\n       sloc ,\n       'USE:'RIGHT(cduse,5,0) ,\n        'AC:'auth ,\n        cdemjp cdemjnm\n   @cdechn = C2X(LEFT(cde,4))                 /* get next cde address */\nEnd\nSay ' '\nSay 'End of LPA Queue scan ' TIME()\nExit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LISTLPAT": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\t\\x00\\x94\\x08\\x8f\\x00\\x94\\x08\\x8f\\x10\\x00\\x00&\\x00&\\x00\\x00\\xc3\\xd6\\xd5\\xe8\\xc5\\xd9\\xe2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-03-29T00:00:00", "modifydate": "1994-03-29T10:00:09", "lines": 38, "newlines": 38, "modlines": 0, "user": "CONYERS"}, "text": "/*REXX*/\n/*****************************************************************/\n/*LISTLPAT: REXX program to display LPA libraries.               */\n/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */\n/*****************************************************************/\n/* MVS DATA AREAS:                                               */\n/*                CVT - Communications Vector Table (@'10'x)     */\n/*               LPAT - Link Pack Area (libraries) Table         */\n/*                                                               */\n/*                                                               */\n/*                                                               */\n/*****************************************************************/\n@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */\n@cvt = D2X(C2D(@cvt))                    /* binary to hex             */\n@cvtsmext = STORAGE(D2X(X2D(@cvt)+1196),4)   /* get CVTSMEXT address  */\n@cvtsmext = D2X(C2D(@cvtsmext))                /* binary to hex       */\n@cvteplps = D2X(X2D(@cvtsmext)+56)           /* get CVTEPLPS address  */\n@cvteplps = STORAGE(@cvteplps,4)             /* get LPAT address      */\n@cvteplps = D2X(C2D(@cvteplps))                /* binary to hex       */\nlpatcount = C2D(STORAGE(D2X(X2D(@cvteplps)+4),4)) /* LPAT entries     */\nlpatlen   = C2D(STORAGE(D2X(X2D(@cvteplps)+8),1)) /* length 1st entry */\n@lpatentry= X2D(@cvteplps)+9          /* address of 1st LPAT entry    */\nSay 'CVT:'@cvt  'CVTSMEXT:'@cvtsmext'  CVTEPLPS:'@cvteplps,\n    '  'DATE() TIME()\nSay ' '\nSay 'The LPAT table contains 'lpatcount 'entries, as follows:'\nSay ' '\nDo i = 1 to lpatcount                           /* loop thru storage  */\n   lpatlib.i = STORAGE(D2X(@lpatentry),lpatlen) /* get the LLT entry  */\n   @lpatentry = @lpatentry + 45                 /* bump to next entry */\n   lpatlen = C2D(STORAGE(D2X(@lpatentry-1),1))  /* length of next     */\nEnd\nSay '--------------DATA SET NAME-----------------'\nSay ' '\nDo i = 1 to lpatcount                           /* print the list     */\n   Say SUBSTR(lpatlib.i,1,44,' ') i\nEnd\nExit\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LISTNUCM": {"ttr": 3081, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x001\\x00\\x94\\x08\\x8f\\x01\\x14\\x05\\x0f\"Y\\x00>\\x00>\\x00\\x00\\xe2\\xc3\\xd5\\xe2\\xf0\\xf3@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1994-03-29T00:00:00", "modifydate": "2014-02-19T22:59:31", "lines": 62, "newlines": 62, "modlines": 0, "user": "SCNS03"}, "text": "/*REXX*/\n/*****************************************************************/\n/*LISTNUCM: REXX program to display the nucleus map.             */\n/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */\n/*****************************************************************/\n/* MVS DATA AREAS:                                               */\n/*                CVT - Communications Vector Table (@'10'x)     */\n/*              NUCMP - Nucleus Map Table (16 bytes by n rows)   */\n/*                                                               */\n/*****************************************************************/\nNumeric Digits 10\n@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */\n@cvt = D2X(C2D(@cvt))                    /* binary to hex             */\n@cvtnucmp = STORAGE(D2X(X2D(@cvt)+1200),4)   /* get CVTNUCMP address  */\n@cvtnucmp = D2X(C2D(@cvtnucmp))                /* binary to hex       */\nnucmapid  = STORAGE(@cvtnucmp,8)           /* nucmap eyecatcher entry */\nnucmeot   = C2D(STORAGE(D2X(X2D(@cvtnucmp)+8),4))  /* table end addrs */\nnucmlen   = C2D(STORAGE(D2X(X2D(@cvtnucmp)+13),3)) /* nucm tbl length */\n@nucmentry= X2D(@cvtnucmp)+16          /* address of 1st nucmap entry */\nAddress TSO ; 'CLEAR'\nSay 'CVT:'@cvt  'CVTNUCMP:'@cvtnucmp'  NUCMLEN:'nucmlen' bytes',\n    '  'DATE() TIME()\nSay ' '\nIf nucmapid \\= 'NUCMAP  ' Then Do\n   Say 'Error: Nucleus map table eyecatcher not found'\n   Exit\n   End\ni = 0\nSay 'The Nucleus Map table follows:'\nSay ' '\nDo While @nucmentry <= nucmeot                  /* loop thru storage  */\n   i = i + 1\n   epname.i = STORAGE(D2X(@nucmentry),8)      /* get entry point name */\n   epaddr.i = C2X(STORAGE(D2X(@nucmentry+8),4))     /* get ep address */\n   epflag.i = STORAGE(D2X(@nucmentry+12),1)      /* get raw flag byte */\n   eplen.i  = C2X(STORAGE(D2X(@nucmentry+13),3))     /* get ep length */\n   @nucmentry = @nucmentry + 16                 /* bump to next entry */\nEnd\nentries = i\n/*--------------------------------------------------------------*/\n/* epflag byte structure:                                       */\n/*                                                              */\n/*           XXXX XXXX --> epflag byte                          */\n/*           |||| ||||                                          */\n/*           |||| ||++---- AMODE 00/01=24, 10=31, 11=ANY        */\n/*           |||| |+------ RMODE 0=24, 1=ANY                    */\n/*           |||| +------- RSECT 1=yes                          */\n/*           |||+--------- CSECT 1=yes                          */\n/*           +++---------- unused                               */\n/*--------------------------------------------------------------*/\nSay 'Entry --Name-- -EPaddr- CSECT RSECT RMODE AMODE Length'\nSay ' '\nDo i = 1 to entries                             /* print the list     */\n   csect = '     ' ; rsect = '     ' ; rmode = '  24 ' ; amode = '  24 '\n   If BITAND(epflag.i,'10'x)='10'x Then csect = '  Y  '\n   If BITAND(epflag.i,'08'x)='08'x Then rsect = '  Y  ' /* read only  */\n   If BITAND(epflag.i,'04'x)='04'x Then rmode = ' Any ' /* residency  */\n   If BITAND(epflag.i,'02'x)='02'x Then amode = '  31 ' /* addressing */\n   If BITAND(epflag.i,'03'x)='03'x Then amode = ' Any ' /* addressing */\n   Say ' 'Right(i,4,0) epname.i epaddr.i csect rsect rmode amode eplen.i\nEnd\nExit\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LISTPART": {"ttr": 2822, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\n\\x00\\x07\\x01\\x14\\x02\\x9f\\x01\\x14\\x05\\x0f\"W\\x00B\\x00C\\x00\\x00\\xe2\\xc3\\xd5\\xe2\\xf0\\xf3@@@@'", "ispf": {"version": "01.10", "flags": 0, "createdate": "2014-01-29T00:00:00", "modifydate": "2014-02-19T22:57:07", "lines": 66, "newlines": 67, "modlines": 0, "user": "SCNS03"}, "text": "/*REXX*/\n/*****************************************************************/\n/*LISTPART: REXX program to show ASM paging data set status.     */\n/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */\n/*****************************************************************/\n/* MVS DATA AREAS:                                               */\n/*                CVT - Communications Vector Table (@'10'x)     */\n/*              ASMVT - ASM Vector Table                         */\n/*               PART - ASM Paging Activity Reference Table      */\n/*                                                               */\n/*****************************************************************/\n@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */\n@cvt = D2X(C2D(@cvt))                         /* binary to dec to hex */\n@cvtasmvt = STORAGE(D2X(X2D(@cvt)+704),4)     /* get CVTASMVT address */\n@asmvt    = RIGHT(C2X(@cvtasmvt),7)                   /* trim address */\n@asmpart  = STORAGE(D2X(X2D(@asmvt)+8),4)         /* get PART address */\n@part     = RIGHT(C2X(@asmpart),7)                    /* trim address */\npartsize  = STORAGE(D2X(X2D(@part)+4),4)      /* get number of PART's */\npartsize  = C2D(partsize)                            /* binary to dec */\n@partdsnl = STORAGE(D2X(X2D(@part)+24),4)     /* get dsn list address */\n@partdsnl = C2X(@partdsnl)                            /* need 32 bits */\npartlcnt  = STORAGE(D2X(X2D(@part)+32),2)     /* get number of locals */\npartlcnt  = C2D(partlcnt)                            /* binary to dec */\n@partplpa = STORAGE(D2X(X2D(@part)+48),4)      /* get plpa part entry */\n@partplpa = RIGHT(C2X(@partplpa),7)                   /* trim address */\n@partloca = STORAGE(D2X(X2D(@part)+52),4)      /* get 1st local entry */\n@partloca = RIGHT(C2X(@partloca),7)                   /* trim address */\n@partlsta = STORAGE(D2X(X2D(@part)+56),4)      /* get last locl entry */\n@partlsta = RIGHT(C2X(@partlsta),7)                   /* trim address */\n@partents  = STORAGE(D2X(X2D(@part)+80),4)      /* get 1st part entry */\n@partents = RIGHT(C2X(@partents),7)                   /* trim address */\nAddress TSO ; \"CLEAR\"\nSay 'CVT:'@cvt' CVTASMVT:'@asmvt ' ASMPART:'@part'   'TIME() DATE()\nSay ' '\nSay 'The PART table starts at '@partplpa' and contains 'partsize' entries.'\nSay ' '\np = 0 ; i = 0 ; @partix = @partplpa ; @dsnl = @partdsnl\nDo p = 1 To partsize                           /* scan the PART table */\n   pareflg1 = STORAGE(D2X(X2D(@partix)+9),1)         /* get flag byte */\n   If BITAND(pareflg1,'80'x) \\= '80'x Then Do  /* process in use only */\n      i = i + 1                              /* count active pageds's */\n      pagedsn  = STORAGE(@dsnl,44)         /* pickup the dsn from csa */\n      paretype = STORAGE(D2X(X2D(@partix)+8),1)      /* get type byte */\n      ptype = '??????'\n      If BITAND(paretype,'80'x) = '80'x Then ptype = 'PLPA  '\n      If BITAND(paretype,'40'x) = '40'x Then ptype = 'Common'\n      If BITAND(paretype,'20'x) = '20'x Then ptype = 'Duplex'\n      If BITAND(paretype,'10'x) = '10'x Then ptype = 'Local '\n      pareszsl = STORAGE(D2X(X2D(@partix)+16),4) /* get size in slots */\n      pareszsl = C2D(pareszsl)\n      pareslta = STORAGE(D2X(X2D(@partix)+20),4)   /* slots available */\n      pareslta = C2D(pareslta) ; used = pareszsl - pareslta\n      pctused  = TRUNC((used*100)/pareszsl,0)\n      pctused  ='('RIGHT(pctused,3)'%)'\n      @pareucbp = STORAGE(D2X(X2D(@partix)+44),4)  /* get UCB address */\n      pioaddr  = STORAGE(D2X(C2D(@pareucbp)+4),2)  /* channel address */\n      pioaddr  = RIGHT(C2X(pioaddr),4)             /* 4-character UCB */\n      pvolser  = STORAGE(D2X(C2D(@pareucbp)+28),6)     /* dasd volser */\n      Say RIGHT(i,2) pagedsn ptype RIGHT(pareszsl,5) pctused pvolser pioaddr\n   End\n   @partix = D2X(X2D(@partix)+96)          /* bump to next PART entry */\n   @dsnl   = D2X(X2D(@dsnl)+44)             /* bump to next DSN entry */\nEnd\nSay ' '\nSay 'Paging activity table analysis completed: 'TIME()\nExit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LISTPAR2": {"ttr": 2824, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0b\\x00\\t\\x00\\x94\\x08\\x8f\\x01\\x14\\x05\\x0f\"W\\x00F\\x00B\\x00\\x00\\xe2\\xc3\\xd5\\xe2\\xf0\\xf3@@@@'", "ispf": {"version": "01.11", "flags": 0, "createdate": "1994-03-29T00:00:00", "modifydate": "2014-02-19T22:57:09", "lines": 70, "newlines": 66, "modlines": 0, "user": "SCNS03"}, "text": "/*REXX*/\n/*****************************************************************/\n/*LISTPART: REXX program to show ASM paging data set status.     */\n/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */\n/*****************************************************************/\n/* MVS DATA AREAS:                                               */\n/*                CVT - Communications Vector Table (@'10'x)     */\n/*              ASMVT - ASM Vector Table                         */\n/*               PART - ASM Paging Activity Reference Table      */\n/*                                                               */\n/*****************************************************************/\n@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */\n@cvt = D2X(C2D(@cvt))                         /* binary to dec to hex */\n@cvtasmvt = STORAGE(D2X(X2D(@cvt)+704),4)     /* get CVTASMVT address */\n@asmvt    = RIGHT(C2X(@cvtasmvt),7)                   /* trim address */\n@asmpart  = STORAGE(D2X(X2D(@asmvt)+8),4)         /* get PART address */\n@part     = RIGHT(C2X(@asmpart),7)                    /* trim address */\npartsize  = STORAGE(D2X(X2D(@part)+4),4)      /* get number of PART's */\npartsize  = C2D(partsize)                            /* binary to dec */\nparteuse  = STORAGE(D2X(X2D(@part)+8),2)      /* get # of PARTs in use*/\nparteuse  = C2D(parteuse)                            /* binary to dec */\n@partdsnl = STORAGE(D2X(X2D(@part)+24),4)     /* get dsn list address */\n@partdsnl = C2X(@partdsnl)                            /* need 32 bits */\npartlcnt  = STORAGE(D2X(X2D(@part)+32),2)     /* get number of locals */\npartlcnt  = C2D(partlcnt)                            /* binary to dec */\n@partplpa = STORAGE(D2X(X2D(@part)+48),4)      /* get plpa part entry */\n@partplpa = RIGHT(C2X(@partplpa),7)                   /* trim address */\n@partloca = STORAGE(D2X(X2D(@part)+52),4)      /* get 1st local entry */\n@partloca = RIGHT(C2X(@partloca),7)                   /* trim address */\n@partlsta = STORAGE(D2X(X2D(@part)+56),4)      /* get last locl entry */\n@partlsta = RIGHT(C2X(@partlsta),7)                   /* trim address */\n@partents  = STORAGE(D2X(X2D(@part)+80),4)      /* get 1st part entry */\n@partents = RIGHT(C2X(@partents),7)                   /* trim address */\nAddress TSO ; \"CLEAR\"\nSay 'CVT:'@cvt' CVTASMVT:'@asmvt ' ASMPART:'@part'   'TIME() DATE()\nSay ' '\nSay 'The PART table starts at '@partplpa' and contains 'partsize' entries,'parteuse' are in use.'\nSay ' '\nSay ' # Type   Full   Stat  VolSer Addr DataSet Name'\nSay ' '\np = 0 ; i = 0 ; @partix = @partplpa ; @dsnl = @partdsnl\nDo p = 1 To partsize                           /* scan the PART table */\n   pareflg1 = STORAGE(D2X(X2D(@partix)+9),1)         /* get flag byte */\n   If BITAND(pareflg1,'80'x) \\= '80'x Then Do  /* process in use only */\n      i = i + 1                              /* count active pageds's */\n      pagedsn  = STORAGE(@dsnl,44)         /* pickup the dsn from csa */\n      paretype = STORAGE(D2X(X2D(@partix)+8),1)      /* get type byte */\n      ptype = '??????'\n      If BITAND(paretype,'80'x) = '80'x Then ptype = 'PLPA  '\n      If BITAND(paretype,'40'x) = '40'x Then ptype = 'Common'\n      If BITAND(paretype,'20'x) = '20'x Then ptype = 'Duplex'\n      If BITAND(paretype,'10'x) = '10'x Then ptype = 'Local '\n      pareszsl = STORAGE(D2X(X2D(@partix)+16),4) /* get size in slots */\n      pareszsl = C2D(pareszsl)\n      pareslta = STORAGE(D2X(X2D(@partix)+20),4)   /* slots available */\n      pareslta = C2D(pareslta) ; used = pareszsl - pareslta\n      pctused  = TRUNC((used*100)/pareszsl,0)\n      pctused  ='('RIGHT(pctused,3)'%)'\n      @pareucbp = STORAGE(D2X(X2D(@partix)+44),4)  /* get UCB address */\n      pioaddr  = STORAGE(D2X(C2D(@pareucbp)+4),2)  /* channel address */\n      pioaddr  = RIGHT(C2X(pioaddr),4)             /* 4 character UCB */\n      pvolser  = STORAGE(D2X(C2D(@pareucbp)+28),6)     /* dasd volser */\n      Say RIGHT(i,2) ptype RIGHT(pareszsl,5) pctused pvolser pioaddr pagedsn\n   End\n   @partix = D2X(X2D(@partix)+96)          /* bump to next PART entry */\n   @dsnl   = D2X(X2D(@dsnl)+44)             /* bump to next DSN entry */\nEnd\nSay ' '\nSay 'Paging activity table analysis completed: 'TIME()\nExit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LISTPDSD": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00T\\x00\\x94\\x08\\x8f\\x00\\x94\\x08\\x8f\\x10\\x00\\x008\\x008\\x00\\x00\\xc3\\xd6\\xd5\\xe8\\xc5\\xd9\\xe2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-03-29T00:00:00", "modifydate": "1994-03-29T10:00:54", "lines": 56, "newlines": 56, "modlines": 0, "user": "CONYERS"}, "text": "/*REXX*/\n/*****************************************************************/\n/*LISTPDSD: REXX program to display PDS directory records.       */\n/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */\n/*****************************************************************/\n/* MVS DATA AREAS:                                               */\n/*                 -none-                                        */\n/*                                                               */\n/*                                                               */\n/*                                                               */\n/*                                                               */\n/*****************************************************************/\nAddress TSO\ndsn = 'SYS1.SORTLIB'                    /* Fake out DCB of PO */\n\"ALLOC F(PDS) DA('\"dsn\"') SHR DSORG(PS) LRECL(256) BLKSIZE(256) RECFM(F)\"\nNewstack\n'EXECIO * DISKR PDS ( FINIS'\nQueue '*EOF*'\ni = 0\nDo While i < 10\n   i = i + 1\n   Pull line\n   If LEFT(line,5) = '*EOF*' Then Leave\n   dirblock = C2X(line)\n   blocklen = X2D(C2X(SUBSTR(line,1,2)))\n   If blocklen = 0 Then Leave\n   Say 'DIRBLOCK No. 'i'  RC = 'RC,\n       ' DIRBLOCK Length = 'LENGTH(line)'  DIRDATA length = 'blocklen\n   Say ' '\n   Say 'Data: 'SUBSTR(dirblock,001,60)' *'SUBSTR(line,001,30)'*'\n   Say '      'SUBSTR(dirblock,061,60)' *'SUBSTR(line,031,30)'*'\n   Say '      'SUBSTR(dirblock,121,60)' *'SUBSTR(line,061,30)'*'\n   Say '      'SUBSTR(dirblock,181,60)' *'SUBSTR(line,091,30)'*'\n   Say '      'SUBSTR(dirblock,241,60)' *'SUBSTR(line,121,30)'*'\n   Say '      'SUBSTR(dirblock,301,60)' *'SUBSTR(line,151,30)'*'\n   Say '      'SUBSTR(dirblock,361,60)' *'SUBSTR(line,181,30)'*'\n   Say '      'SUBSTR(dirblock,421,60)' *'SUBSTR(line,211,30)'*'\n   Say '      'SUBSTR(dirblock,481,32),\n       '                          ',\n       ' *'SUBSTR(line,241,16),\n       '             *'\n   Say ' '\n   Say 'Linear block dump follows:'\n   Say ' '\n   y = 0\n   Do y = 1 to 256\n      Say '   DIRBLOCK byte 'RIGHT(y,3,0),\n          ' Char:'SUBSTR(line,y,1),\n          ' Hex:'C2X(SUBSTR(line,y,1)),\n          ' Dec:'C2D(SUBSTR(line,y,1))\n   End\n   Say ' '\nEnd\nDelstack\n\"FREE F(PDS)\"\nExit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LISTPDSM": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x10\\x00\\x94\\x08\\x8f\\x00\\x94\\x08\\x8f\\x10\\x00\\x00}\\x00}\\x00\\x00\\xc3\\xd6\\xd5\\xe8\\xc5\\xd9\\xe2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-03-29T00:00:00", "modifydate": "1994-03-29T10:00:10", "lines": 125, "newlines": 125, "modlines": 0, "user": "CONYERS"}, "text": "/*REXX*/\n/*****************************************************************/\n/*LISTPDSM: REXX program to display all PDS member information.  */\n/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */\n/*****************************************************************/\n/* MVS DATA AREAS:                                               */\n/*                PDS - Partitioned Data Set (entry)             */\n/*                                                               */\n/*                                                               */\n/*                                                               */\n/*                                                               */\n/*****************************************************************/\nAddress TSO\ndsn = 'SYS2.LINKLIB'                    /* Fake out DCB of PO */\n\"ALLOC F(PDS) DA('\"dsn\"') SHR DSORG(PS) LRECL(256) BLKSIZE(256) RECFM(F)\"\nNewstack\n'EXECIO * DISKR PDS ( FINIS'\nQueue '*EOF*'\ni = 0\nlast = 0     /* flags when the no more members indicator is detected */\nmemcount = 0\nSay 'Date: 'DATE()' PDS: 'dsn\nDo While i < 1000 & last \\= 1  /* had to pick some limit */\n   i = i + 1\n   Pull line\n   If LEFT(line,5) = '*EOF*' Then Leave\n   blocklen = X2D(C2X(SUBSTR(line,1,2)))  /* Not proud of this logic, */\n   If blocklen = 0 or last = 1 Then Leave /* but seems to work --vlc  */\n   ix = 3                          /* Initialize DIRBLOCK parse index */\n   Do While ix < blocklen & last \\= 1          /* parse this DIRBLOCK */\n      pds2ftb1 = '00'x                         /* initialize apf not  */\n      pds2mnm  = '        '                    /* initialize alias of */\n      pds2name = SUBSTR(line,ix,8)  ; ix = ix + 8     /* main section */\n      pds2ttrp = SUBSTR(line,ix,3)  ; ix = ix + 3\n      pds2indc = SUBSTR(line,ix,1)  ; ix = ix + 1\n      udl = 0                           /* calculate user data length */\n      If BITAND(pds2indc,'01'x) = '01'x Then udl = 1\n      If BITAND(pds2indc,'02'x) = '02'x Then udl = udl + 2\n      If BITAND(pds2indc,'04'x) = '04'x Then udl = udl + 4\n      If BITAND(pds2indc,'08'x) = '08'x Then udl = udl + 8\n      If BITAND(pds2indc,'10'x) = '10'x Then udl = udl + 16\n      udl = udl * 2                 /* finish calc halfwords to bytes */\n      If udl >= 22 Then Do               /* only process likely stuff */\n         ix = ix + 8             /* adjust index to skip misc 8 bytes */\n         pds2atr1 = SUBSTR(line,ix,1) ; ix = ix + 1\n         pds2atr2 = SUBSTR(line,ix,1) ; ix = ix + 1\n         pds2stor = SUBSTR(line,ix,3) ; ix = ix + 3\n         ix = ix + 2             /* adjust index to skip misc 2 bytes */\n         pds2epa  = SUBSTR(line,ix,3) ; ix = ix + 3\n         pds2ftb1 = SUBSTR(line,ix,1) ; ix = ix + 1\n         ix = ix + 2             /* adjust index to skip misc 2 bytes */\n                                                      /* scatter sect */\n         If BITAND(pds2atr1,'04'x) = '04'x Then Do\n            pds2scat = SUBSTR(line,ix+33,8)\n            ix = ix + 8\n            End\n                                                        /* alias sect */\n         If BITAND(pds2indc,'80'x) = '80'x Then Do\n            If udl >= 32 Then Do\n               pds2epm  = SUBSTR(line,ix,3) ; ix = ix + 3\n               pds2mnm  = SUBSTR(line,ix,8) ; ix = ix + 8\n               End\n            Else Do\n               Say '*** WARNING - Missing major for alias 'pds2name' DBLK:'i\n               pds2epm = '000000'x\n               pds2mnm = '????????'\n               End\n            End\n                                                       /* ssi section */\n         If BITAND(pds2ftb1,'10'x) = '10'x Then Do\n            If (ix-1)//2 \\= 0 Then ix = ix + 1    /* halfword alignmt */\n            pdsssiwd = SUBSTR(line,ix,4) ; ix = ix + 4\n            End\n                                                       /* apf section */\n         If BITAND(pds2ftb1,'08'x) \\= '08'x Then pdsapfac = ' '/* none*/\n         Else Do                                         /* maybe apf */\n            pdsapfct = SUBSTR(line,ix,1)\n            If pdsapfct = '01'x Then Do                /* NORMAL path */\n               ix = ix + 1\n               pdsapfac = SUBSTR(line,ix,1)\n               ix = ix + 1\n               If pdsapfac \\= '00'x & pdsapfac \\= '01'x Then Do\n                  Say '*** WARNING - Invalid AC for 'pds2name' DBLK:'i\n                  nop\n                  End\n               End\n            If pdsapfct \\= '01'x & (BITAND(pds2indc,'80'x)='80'x) Then Do\n               pdsapfac=' '\n               ix = ix - 8\n               Say '*** WARNING - Compacted alias logic for 'pds2name' DBLK:'i\n               End\n            End\n         End\n      Else Do                              /* too short udl, leave it */\n         ix = ix + udl\n         If pds2name = 'FFFFFFFFFFFFFFFF'x Then Do\n            last = 1\n            Leave\n            End\n         Say '*** WARNING - too short udl for 'pds2name' DBLK:'i\n         pds2atr1 = '00'x\n         pds2atr2 = '00'x\n         pds2stor = '000000'x\n         pds2mnm  = '        '\n         pdsapfac = ' '\n         End\n      If (ix-1)//2 \\= 0 Then ix = ix + 1          /* halfword alignmt */\n      If pds2name = 'FFFFFFFFFFFFFFFF'x Then Do\n         last = 1\n         Leave\n         End\n      If pds2name \\= '0000000000000000'x Then Do\n         memcount = memcount + 1\n         Say RIGHT(memcount,4,0) pds2name' TTR:'C2X(pds2ttrp),\n             ' INDC:'C2X(pds2indc)' ATRBs:'C2X(pds2atr1),\n             C2X(pds2atr2)' SIZE:'C2X(pds2stor),\n             ' MAJ:'pds2mnm' AC:'C2X(pdsapfac),\n             ' DBLK:'RIGHT(i,4,0)' UDL:'RIGHT(udl,2,0),\n             ' IX:'RIGHT(ix,3,0)\n         End\n   End                                         /* DIRBLOCK parse done */\nEnd\nDelstack\n\"FREE F(PDS)\"\nExit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LISTPLPA": {"ttr": 2826, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x11\\x00\\x94\\x08\\x8f\\x01\\x14\\x05\\x0f\"W\\x00\\x9f\\x00\\x9f\\x00\\x00\\xe2\\xc3\\xd5\\xe2\\xf0\\xf3@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1994-03-29T00:00:00", "modifydate": "2014-02-19T22:57:11", "lines": 159, "newlines": 159, "modlines": 0, "user": "SCNS03"}, "text": "/*REXX*/\n/*****************************************************************/\n/*LISTPLPA: REXX program to display PLPA directory table.        */\n/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */\n/*****************************************************************/\n/* MVS DATA AREAS:                                               */\n/*                CVT - Communications Vector Table (@'10'x)     */\n/*                GDA - Global Data Area                         */\n/*               LPDE - Link Pack Directory Entry                */\n/*                                                               */\n/*****************************************************************/\n/*--------------virtual storage map definition section----------------*/\nNumeric Digits 10           /* required to handle decimal conversions */\n@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */\n@cvt = D2X(C2D(@cvt))                    /* binary to hex             */\n@cvtreal  = STORAGE(D2X(X2D(@cvt)+284),4)    /* get CVTREAL address   */\n@cvtreal  = D2X(C2D(@cvtreal))                 /* binary to hex       */\n@cvtshrvm = STORAGE(D2X(X2D(@cvt)+416),4)    /* get CVTSHRVM address  */\n@cvtshrvm = D2X(C2D(@cvtshrvm))                /* binary to hex       */\n@cvtgda   = STORAGE(D2X(X2D(@cvt)+560),4)    /* get CVTGDA address    */\n@cvtgda   = D2X(C2D(@cvtgda))                  /* binary to hex       */\n@gdacsa   = D2X(X2D(@cvtgda)+108)            /* locate GDACSAstarts   */\n@gdacsa   = D2X(C2D(STORAGE(@gdacsa,4)))       /*  get GDACSA         */\n@gdacsasz = D2X(X2D(@cvtgda)+112)            /* locate GDACSASiZe     */\n@gdacsasz = D2X(C2D(STORAGE(@gdacsasz,4)))     /*  get GDACSASiZe     */\n@gdaecsa  = D2X(X2D(@cvtgda)+124)            /* locate GDAECSAstarts  */\n@gdaecsa  = D2X(C2D(STORAGE(@gdaecsa,4)))      /*  get GDAECSA        */\n@gdaecsas = D2X(X2D(@cvtgda)+128)            /* locate GDAECSASize    */\n@gdaecsas = D2X(C2D(STORAGE(@gdaecsas,4)))     /*  get GDAECSAS       */\n@cvtsmext = STORAGE(D2X(X2D(@cvt)+1196),4)   /* get CVTSMEXT address  */\n@cvtsmext = D2X(C2D(@cvtsmext))                /* binary to hex       */\n@cvtmlpas = D2X(X2D(@cvtsmext)+8)            /* locate CVTMLPAStarts  */\n@cvtmlpas = D2X(C2D(STORAGE(@cvtmlpas,4)))     /*  get CVTMLPAS       */\n@cvtmlpae = D2X(X2D(@cvtsmext)+12)           /* locate CVTMLPAEnds    */\n@cvtmlpae = D2X(C2D(STORAGE(@cvtmlpae,4)))     /*  get CVTMLPAE       */\n@cvtflpas = D2X(X2D(@cvtsmext)+16)           /* locate CVTFLPAStarts  */\n@cvtflpas = D2X(C2D(STORAGE(@cvtflpas,4)))     /*  get CVTFLPAS       */\n@cvtflpae = D2X(X2D(@cvtsmext)+20)           /* locate CVTFLPAEnds    */\n@cvtflpae = D2X(C2D(STORAGE(@cvtflpae,4)))     /*  get CVTFLPAE       */\n@cvtplpas = D2X(X2D(@cvtsmext)+24)           /* locate CVTPLPAStarts  */\n@cvtplpas = D2X(C2D(STORAGE(@cvtplpas,4)))     /*  get CVTPLPAS       */\n@cvtplpae = D2X(X2D(@cvtsmext)+28)           /* locate CVTPLPAEnds    */\n@cvtplpae = D2X(C2D(STORAGE(@cvtplpae,4)))     /*  get CVTPLPAE       */\n@cvtrwns  = D2X(X2D(@cvtsmext)+32)           /* locate CVTRWNStarts   */\n@cvtrwns  = D2X(C2D(STORAGE(@cvtrwns,4)))      /*  get CVTRWNS        */\n@cvtrwne  = D2X(X2D(@cvtsmext)+36)           /* locate CVTRWNEnds     */\n@cvtrwne  = D2X(C2D(STORAGE(@cvtrwne,4)))      /*  get CVTRWNE        */\n@cvtrons  = D2X(X2D(@cvtsmext)+40)           /* locate CVTRONStarts   */\n@cvtrons  = D2X(C2D(STORAGE(@cvtrons,4)))      /*  get CVTRONS        */\n@cvtrone  = D2X(X2D(@cvtsmext)+44)           /* locate CVTRONEnds     */\n@cvtrone  = D2X(C2D(STORAGE(@cvtrone,4)))      /*  get CVTRONE        */\n@cvterwns = D2X(X2D(@cvtsmext)+48)           /* locate CVTERWNStarts  */\n@cvterwns = D2X(C2D(STORAGE(@cvterwns,4)))     /*  get CVTERWNS       */\n@cvterwne = D2X(X2D(@cvtsmext)+52)           /* locate CVTERWNEnds    */\n@cvterwne = D2X(C2D(STORAGE(@cvterwne,4)))     /*  get CVTRRWNE       */\n@cvteplps = D2X(X2D(@cvtsmext)+56)           /* locate CVTEPLPStarts  */\n@cvteplps = D2X(C2D(STORAGE(@cvteplps,4)))     /*  get CVTEPLPS       */\n@cvteplpe = D2X(X2D(@cvtsmext)+60)           /* locate CVTEPLPEnds    */\n@cvteplpe = D2X(C2D(STORAGE(@cvteplpe,4)))     /*  get CVTRPLPE       */\n@cvteflps = D2X(X2D(@cvtsmext)+64)           /* locate CVTEFLPStarts  */\n@cvteflps = D2X(C2D(STORAGE(@cvteflps,4)))     /*  get CVTEFLPS       */\n@cvteflpe = D2X(X2D(@cvtsmext)+68)           /* locate CVTEFLPEnds    */\n@cvteflpe = D2X(C2D(STORAGE(@cvteflpe,4)))     /*  get CVTRFLPE       */\n@cvtemlps = D2X(X2D(@cvtsmext)+72)           /* locate CVTEMLPStarts  */\n@cvtemlps = D2X(C2D(STORAGE(@cvtemlps,4)))     /*  get CVTEMLPS       */\n@cvtemlpe = D2X(X2D(@cvtsmext)+76)           /* locate CVTEMLPEnds    */\n@cvtemlpe = D2X(C2D(STORAGE(@cvtemlpe,4)))     /*  get CVTRMLPE       */\n        /*------simplify variable names & make addresses decimal------*/\n@csa1g  = @gdacsa    ; @csa2g = D2X(X2D(@gdacsasz)+X2D(@gdacsa)-1)/* g*/\n   csa1 = X2D(@csa1g) ; csa2 = X2D(@csa2g)                    /* csa  */\n@mlpa1  = @cvtmlpas  ; @mlpa2 = @cvtmlpae                     /* mlpa */\n   mlpa1 = X2D(@mlpa1) ; mlpa2 = X2D(@mlpa2)\n@flpa1  = @cvtflpas  ; @flpa2 = @cvtflpae                     /* flpa */\n   flpa1 = X2D(@flpa1) ; flpa2 = X2D(@flpa2)\n@plpa1  = @cvtplpas  ; @plpa2 = @cvtplpae                     /* plpa */\n   plpa1 = X2D(@plpa1) ; plpa2 = X2D(@plpa2)\n@sqa1   = D2X(X2D(@cvtplpae)+1) ; @sqa2 = D2X(X2D(@cvtrwns)-1)/* sqa  */\n   sqa1 = X2D(@sqa1) ; sqa2 = X2D(@sqa2)\n@nuc1   = @cvtrwns   ; @nuc2  = @cvterwne                     /* nuc  */\n   nuc1 = X2D(@nuc1) ; nuc2 = X2D(@nuc2)\n@esqa1  = D2X(X2D(@nuc2)+1) ; @esqa2 = D2X(X2D(@cvteplps)-1)  /* esqa */\n  esqa1 = X2D(@esqa1) ; esqa2 = X2D(@esqa2)\n@eplpa1 = @cvteplps  ; @eplpa2 = @cvteplpe                    /* eplpa*/\n eplpa1 = X2D(@eplpa1) ; eplpa2 = X2D(@eplpa2)\n@eflpa1 = @cvteflps  ; @eflpa2 = @cvteflpe                    /* eflpa*/\n eflpa1 = X2D(@eflpa1) ; eflpa2 = X2D(@eflpa2)\n@emlpa1 = @cvtemlps  ; @emlpa2 = @cvtemlpe                    /* emlpa*/\n emlpa1 = X2D(@emlpa1) ; emlpa2 = X2D(@emlpa2)\n@ecsa1g = @gdaecsa   ; @ecsa2g= D2X(X2D(@gdaecsas)+X2D(@gdaecsa)-1)/*g*/\n  ecsa1 = X2D(@ecsa1g) ; ecsa2 = X2D(@ecsa2g)\n@eprivs = X2D(@ecsa2g)+1                               /* ext private */\n@eprive = 2147483647                         /* fixed by architecture */\n epriv1 = @eprivs ; epriv2 = @eprive\n@psas   = 0 ; @psae = 4095                       /* psa fixed by arch */\n   psa1 = @psas ; psa2 = @psae\n@prive  = X2D(@csa1g)-1 ; @privs = X2D(@psae)+1            /* private */\n  priv1 = @privs ; priv2 = @prive\n              /*------------------------------------------------------*/\n             /* Usage Notes: Hex character compares are incompatible */\n            /*    for storage residency determination.  Thus, entry */\n           /*     point addresses must be converted to decimal and */\n          /*      VS boundary addresses must be converted to de-  */\n         /*       cimal for correct compare operations.          */\n        /*------------------------------------------------------*/\n/*----------end of virtual storage map definition section-------------*/\n@cvtlpdir = STORAGE(D2X(X2D(@cvt)+361),3)    /* get CVTLPDIR address  */\n@cvtlpdir = D2X(C2D(@cvtlpdir))                /* binary to hex       */\nAddress TSO ; \"CLEAR\"\nSay 'CVT:'@cvt' CVTLPDIR:'@cvtlpdir'  'DATE() TIME()\n@lpdechn = @cvtlpdir\nSay ' '\ni = 0 ; eot = '00000000000000000000000000000000'\nDo While i < 10000                                 /* arbitrary limit */\n   lpde = STORAGE(@lpdechn,40)                        /* get the lpde */\n   If C2X(SUBSTR(lpde,1,16))=eot Then Leave           /* end of table */\n   i = i + 1\n   module = SUBSTR(lpde,9,8)\n   entry  = SUBSTR(lpde,17,4)\n                                        /* determine storage location */\n   addr = BITAND(entry,'7FFFFFFF'x)       /* shave off amode bit (32) */\n   addr = C2D(addr)                      /* make numeric for compares */\n   sloc = 'ERROR'                       /* determine module residency */\n   If (addr >= csa1   & addr <= csa2  ) Then sloc = 'CSA  '\n      Else If (addr >= mlpa1  & addr <= mlpa2 ) Then sloc = 'MLPA '\n      Else If (addr >= flpa1  & addr <= flpa2 ) Then sloc = 'FLPA '\n      Else If (addr >= plpa1  & addr <= plpa2 ) Then sloc = 'PLPA '\n      Else If (addr >= sqa1   & addr <= sqa2  ) Then sloc = 'SQA  '\n      Else If (addr >= nuc1   & addr <= nuc2  ) Then sloc = 'NUC  '\n      Else If (addr >= esqa1  & addr <= esqa2 ) Then sloc = 'ESQA '\n      Else If (addr >= eplpa1 & addr <= eplpa2) Then sloc = 'EPLPA'\n      Else If (addr >= eflpa1 & addr <= eflpa2) Then sloc = 'EFLPA'\n      Else If (addr >= emlpa1 & addr <= emlpa2) Then sloc = 'EMLPA'\n      Else If (addr >= ecsa1  & addr <= ecsa2 ) Then sloc = 'ECSA '\n      Else If (addr >= epriv1 & addr <= epriv2) Then sloc = 'EPRIV'\n      Else If (addr >= priv1  & addr <= priv2 ) Then sloc = 'PRIV '\n      Else If (addr >= psa1   & addr <= psa2  ) Then sloc = 'PSA  '\n   size   = C2X(SUBSTR(lpde,33,4))\n   att2   =     SUBSTR(lpde,30,1)\n   auth = 0 ; If (BITAND(att2,'01'x)='01'x) Then auth = 1\n   lpdemjp  = '         '\n   lpdemjnm = '        '\n   If C2D(SUBSTR(lpde,21,4)) \\= 0 Then\n      Do\n         lpdemjp  = ' Alias of'\n         lpdemjnm = SUBSTR(lpde,33,8)\n             size = '        '\n      End\n   Say 'PLPA'RIGHT(i,4,0) ,\n       module ,\n       C2X(entry) ,\n       sloc ,\n       'SIZE:'RIGHT(size,8,0) ,\n       'AC:'auth ,\n       lpdemjp lpdemjnm\n   @lpdechn = D2X(X2D(@lpdechn)+40)         /* address of next LPDE */\nEnd\nSay ' '\nSay 'LPDE table scan completed 'TIME()\nExit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LISTSART": {"ttr": 3085, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x07\\x00'\\x00\\x94\\x08\\x8f\\x01\\x14\\x05\\x0f#\\x05\\x006\\x006\\x00\\x00\\xe2\\xc3\\xd5\\xe2\\xf0\\xf3@@@@\"", "ispf": {"version": "01.07", "flags": 0, "createdate": "1994-03-29T00:00:00", "modifydate": "2014-02-19T23:05:27", "lines": 54, "newlines": 54, "modlines": 0, "user": "SCNS03"}, "text": "/*REXX*/\n/*****************************************************************/\n/*LISTSART: REXX program to show ASM swapping data set status.   */\n/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */\n/*****************************************************************/\n/* MVS DATA AREAS:                                               */\n/*                CVT - Communications Vector Table (@'10'x)     */\n/*              ASMVT - ASM Vector Table                         */\n/*               SART - ASM Swapping Activity Reference Table    */\n/*                                                               */\n/*****************************************************************/\n@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */\n@cvt = D2X(C2D(@cvt))                         /* binary to dec to hex */\n@cvtasmvt = STORAGE(D2X(X2D(@cvt)+704),4)     /* get CVTASMVT address */\n@asmvt    = RIGHT(C2X(@cvtasmvt),7)                   /* trim address */\n@asmsart  = STORAGE(D2X(X2D(@asmvt)+4),4)         /* get SART address */\n@sart     = RIGHT(C2X(@asmsart),7)                    /* trim address */\nsartsize  = STORAGE(D2X(X2D(@sart)+4),4)      /* get number of SART's */\nsartsize  = C2D(sartsize)                            /* binary to dec */\n@sardsnl  = STORAGE(D2X(X2D(@sart)+24),4)     /* get dsn list address */\n@sardsnl  = RIGHT(C2X(@sardsnl),7)                    /* trim address */\n@sarfrsta = STORAGE(D2X(X2D(@sart)+60),4)       /* get 1st sart entry */\n@sarfrsta = RIGHT(C2X(@sarfrsta),7)                   /* trim address */\nAddress TSO ; \"CLEAR\"\nSay 'CVT:'@cvt' CVTASMVT:'@asmvt ' ASMSART:'@sart'   'TIME() DATE()\nSay ' '\nSay 'The SART table starts at '@sarfrsta' and contains 'sartsize' entries.'\nSay ' '\ns = 0 ; i = 0 ; @sartix = @sarfrsta ; @dsnl = @sardsnl\nDo s = 1 To sartsize                           /* scan the SART table */\n   sreflg = STORAGE(D2X(X2D(@sartix)+9),1)           /* get flag byte */\n   If BITAND(sarflg,'80'x) \\= '80'x Then Do    /* process in use only */\n      i = i + 1                              /* count active swapds's */\n      swapdsn  = STORAGE(@dsnl,44)         /* pickup the dsn from csa */\n      sretotsl = STORAGE(D2X(X2D(@sartix)+16),4) /* get size in slots */\n      sretotsl = C2D(sretotsl)\n      sreavlsl = STORAGE(D2X(X2D(@sartix)+20),4)   /* slots available */\n      sreavlsl = C2D(sreavlsl) ; used = sretotsl - sreavlsl\n      If sretotsl > 0 Then pctused = TRUNC((used*100)/sretotsl,0)\n                      Else pctused = 0\n      pctused  ='('RIGHT(pctused,3)'%)'\n      @sreucb  = STORAGE(D2X(X2D(@sartix)+44),4)   /* get UCB address */\n      sioaddr  = STORAGE(D2X(C2D(@sreucb)+4),2)    /* channel address */\n      sioaddr  = RIGHT(C2X(sioaddr),3)\n      svolser  = STORAGE(D2X(C2D(@sreucb)+28),6)       /* dasd volser */\n      If sretotsl > 0 Then Say RIGHT(i,2) swapdsn RIGHT(sretotsl,5),\n                               pctused svolser sioaddr\n   End\n   @sartix = D2X(X2D(@sartix)+80)          /* bump to next SART entry */\n   @dsnl   = D2X(X2D(@dsnl)+44)             /* bump to next DSN entry */\nEnd\nSay ' '\nSay 'Swapping activity table analysis completed: 'TIME()\nExit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LISTSFT": {"ttr": 3335, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01&\\x00B\\x00\\x94\\x08\\x8f\\x01\\x14\\x05_\\x02E\\x01u\\x00{\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.38", "flags": 0, "createdate": "1994-03-29T00:00:00", "modifydate": "2014-02-24T02:45:42", "lines": 373, "newlines": 123, "modlines": 0, "user": "SBGOLOB"}, "text": "/*REXX*/\n/*****************************************************************/\n/* LISTSFT: REXX program to display the PC system function table.*/\n/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */\n/*****************************************************************/\n/* MVS DATA AREAS:                                               */\n/*                CVT - Communications Vector Table (@'10'x)     */\n/*                SFT - System Function Table                    */\n/*****************************************************************/\n/* Added entries to accommodate IEAVXSFM from z/OS 1.13  (SBG)   */\n/* See MVS Diagnosis Reference for a list of PC LX/EX Services.  */\n/* (I think many of them are not anchored in the SFT, but are    */\n/*  anchored somewhere else in the system.)                      */\n/*****************************************************************/\n@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */\n@cvt = D2X(C2D(@cvt))                    /* binary to hex             */\n@cvtxsft  = STORAGE(D2X(X2D(@cvt)+772),4)    /* get CVTXSFT address   */\n@cvtxsft  = D2X(C2D(@cvtxsft))                 /* binary to hex       */\n/* Address TSO ; \"CLEAR\"  */\nSay 'CVT:'@cvt'  CVTXSFT:'@cvtxsft'   'DATE() TIME()\nSay ' '\nSay '    PC Number          Service Description'\nSay '    ----------------   ----------------------------------------'\n@start = @cvtxsft ; i = 0\nsftentry = STORAGE(@start,4)\nDo While sftentry \\= 'FFFFFFFF'x                       /* process SFT */\n   i = i + 1\n   linkageix = SUBSTR(sftentry,2,2) ; linkageix = C2X(linkageix)\n     entryix = SUBSTR(sftentry,4,1) ;   entryix = C2X(entryix)\n   Select\n      When sftentry = '00000000'x Then\n         service = 'Linkage Index Reserve                    (IEAVXLRE)'\n      When sftentry = '00000001'x Then\n         service = 'Linkage Index Free                       (IEAVXLFR)'\n      When sftentry = '00000002'x Then\n         service = 'Entry Table Create                       (IEAVXECR)'\n      When sftentry = '00000003'x Then\n         service = 'Entry Table Destroy                      (IEAVXEDE)'\n      When sftentry = '00000004'x Then\n         service = 'Entry Table Connect                      (IEAVXECO)'\n      When sftentry = '00000005'x Then\n         service = 'Entry Table Disconnect                   (IEAVXEDI)'\n      When sftentry = '00000006'x Then\n         service = 'Authorization Index Reserve              (IEAVXRFE)'\n      When sftentry = '00000007'x Then\n         service = 'Authorization Index Free                 (IEAVXRFE)'\n      When sftentry = '00000008'x Then\n         service = 'Authorization Index Extract              (IEAVXRFE)'\n      When sftentry = '00000009'x Then\n         service = 'Authorization Index Set                  (IEAVXSET)'\n      When sftentry = '0000000A'x Then\n         service = 'Authorization Table Set                  (IEAVXSET)'\n      When sftentry = '0000000B'x Then\n         service = 'PC/Auth Resource Manager                 (IEAVXPAM)'\n      When sftentry = '0000000C'x Then\n         service = 'For use by IBM code only                 (IEAVXREX)'\n      When sftentry = '0000000D'x Then\n         service = 'ALESERV ADD/ADDPASN services             (IEAVXALA)'\n      When sftentry = '0000000E'x Then\n         service = 'ALESERV DELETE service                   (IEAVXALD)'\n      When sftentry = '0000000F'x Then\n         service = 'ALESERV EXTRACT/EXTRACTH services        (IEAVXALE)'\n      When sftentry = '00000010'x Then\n         service = 'ALESERV SEARCH service                   (IEAVXALS)'\n      When sftentry = '00000011'x Then\n         service = 'DualPool router                          (        )'\n      When sftentry = '00000100'x Then\n         service = 'ENQ/DEQ/RESERVE                          (ISGGQWBI)'\n      When sftentry = '00000101'x Then\n         service = 'ENQ/DEQ/RESERVE Redrive                  (ISGGQWBI)'\n      When sftentry = '00000102'x Then\n         service = 'ENQ/DEQ/RESERVE Resource Term Mgr        (ISGGTRM1)'\n      When sftentry = '00000103'x Then\n         service = 'Global Resource Serialization Dump       (ISGDGCB0)'\n      When sftentry = '00000104'x Then\n         service = 'Global Resource Serialization Qscan      (ISGQSCAN)'\n      When sftentry = '00000105'x Then\n         service = 'Global Resource Serialization Stor Mgmt  (ISGSMI  )'\n      When sftentry = '00000106'x Then\n         service = 'Global Resource Serialization Qscan      (ISGQSCAN)'\n      When sftentry = '00000107'x Then\n         service = 'DEQUEUE Fast Path                        (ISGLNQDQ)'\n      When sftentry = '00000108'x Then\n         service = 'ENQUEUE Fast Path                        (ISGLNQDQ)'\n      When sftentry = '00000109'x Then\n         service = 'Global Resource Serialization ESTAE      (ISGGEST0)'\n      When sftentry = '0000010C'x Then\n         service = 'GRS Latch internal processing            (ISGLRLQE)'\n      When sftentry = '0000010D'x Then\n         service = 'GRS Latch CREATE service                 (ISGLCRTS)'\n      When sftentry = '0000010E'x Then\n         service = 'GRS Latch internal processing            (ISGLRTR )'\n      When sftentry = '0000010F'x Then\n         service = 'GRS Latch PURGE service                  (ISGLPRGS)'\n      When sftentry = '0000011A'x Then\n         service = 'ISGENQ Service                           (ISGGRT  )'\n      When sftentry = '0000011B'x Then\n         service = 'ISGQUERY Service                         (ISGQPC  )'\n      When sftentry = '0000011C'x Then\n         service = 'ISGADMIN Service                         (ISGGADMN)'\n      When sftentry = '0000011D'x Then\n         service = 'Non-cross memory ENQ svce redrives to GRS(ISGGRT  )'\n      When sftentry = '0000011E'x Then\n         service = 'Non-cross memory DEQ svce redrives to GRS(ISGGRT  )'\n      When sftentry = '00000200'x Then\n         service = 'Display Allocation Tables Manager        (IEFHB410)'\n      When sftentry = '00000201'x Then\n         service = 'DALT Dynamic Activate Config change      (IEFHB420)'\n      When sftentry = '00000202'x Then\n         service = 'Allocation Component Trace Record        (IEFCTRCD)'\n      When sftentry = '00000203'x Then\n         service = 'ATS Tape sharing Operations              (IEFHB4IG)'\n      When sftentry = '00000204'x Then\n         service = 'Allocation Dev Mgmt (offl,online,unload) (IEFHBPDF)'\n      When sftentry = '00000300'x Then\n         service = 'VSM CPOOL Build Service                  (IGVCPBDP)'\n      When sftentry = '00000301'x Then\n         service = 'VSM CPOOL Expansion Interface            (IGVCPEXP)'\n      When sftentry = '00000302'x Then\n         service = 'VSM CPOOL Delete Service                 (IGVCPDLP)'\n      When sftentry = '00000303'x Then\n         service = 'VSMLIST Service                          (IGVLISTP)'\n      When sftentry = '00000304'x Then\n         service = 'VSMLOC Service                           (IGVLOCP )'\n      When sftentry = '00000305'x Then\n         service = 'CPUTIMER Service                         (IEAVRT04)'\n      When sftentry = '00000306'x Then\n         service = 'Virtual Fetch CSVVFORK Service           (CSVVFORK)'\n      When sftentry = '00000307'x Then\n         service = 'Data in Virtural                         (ITVCCTL )'\n      When sftentry = '00000308'x Then\n         service = 'Symptom Records                          (ASRSERVP)'\n      When sftentry = '00000309'x Then\n         service = 'LSEXPAND Service                         (IEAVLSEX)'\n      When sftentry = '0000030A'x Then\n         service = 'LOCASCB STOKEN= Service                  (IEAVESTA)'\n      When sftentry = '0000030B'x Then\n         service = 'Storage obtain                           (IGVVSTOR)'\n      When sftentry = '0000030C'x Then\n         service = 'RTM dynamic storage manager              (IEAVTR2C)'\n      When sftentry = '0000030D'x Then\n         service = 'WAIT LINKAGE=SYSTEM service              (IEAVEWTP)'\n      When sftentry = '0000030E'x Then\n         service = 'POST LINKAGE=SYSTEM service              (IEAVEPTP)'\n      When sftentry = '0000030F'x Then\n         service = 'PC-ESTAE service                         (IEAVESTI)'\n      When sftentry = '00000310'x Then\n         service = 'ASCRE/ASDES/ASEXT services               (ASEMAIN )'\n      When sftentry = '00000311'x Then\n         service = 'Storage release                          (IGVVSTOR)'\n      When sftentry = '00000312'x Then\n         service = 'TCBTOKEN service                         (IEAVTTKN)'\n      When sftentry = '00000313'x Then\n         service = 'TESTART service                          (IEAVXTAR)'\n      When sftentry = '00000314'x Then\n         service = 'CSVQUERY service                         (CSVQYSRV)'\n      When sftentry = '00000315'x Then\n         service = 'For use by IBM code only                 (ITVCF   )'\n      When sftentry = '00000316'x Then\n         service = 'TIMEUSED service                         (IEATTUSD)'\n      When sftentry = '00000317'x Then\n         service = 'SRB SUSPEND with token                   (IEAVSRBS)'\n      When sftentry = '00000318'x Then\n         service = 'SRB RESUME with token                    (IEAVSRBR)'\n      When sftentry = '00000319'x Then\n         service = 'SRB PURGE with token                     (IEAVSRBP)'\n      When sftentry = '0000031A'x Then\n         service = 'LLACOPY service                          (CSVLLCPY)'\n      When sftentry = '0000031B'x Then\n         service = 'RCFSTAT service                          (IEEUSTAT)'\n      When sftentry = '0000031C'x Then\n         service = 'RCFCONF service                          (IEEULCFG)'\n      When sftentry = '0000031D'x Then\n         service = 'AFFINITY service                         (IEAVEAFN)'\n      When sftentry = '0000031E'x Then\n         service = 'SDOM connect service                     (COFMCONN)'\n      When sftentry = '0000031F'x Then\n         service = 'SDOM disconnect service                  (COFMDISC)'\n      When sftentry = '00000320'x Then\n         service = 'CTRACEWR - Write service                 (ITTTWRIT)'\n      When sftentry = '00000321'x Then\n         service = 'PC TIME service                          (IEATTIME)'\n      When sftentry = '00000322'x Then\n         service = 'UCB Service Authorized                   (IOSVUPCR)'\n      When sftentry = '00000323'x Then\n         service = 'UCB Service Unauthorized                 (IOSVUPCR)'\n      When sftentry = '00000324'x Then\n         service = 'Configuration Change Manager             (IOSVCCMI)'\n      When sftentry = '00000325'x Then\n         service = 'Unit Verification Services               (IEFEISO1)'\n      When sftentry = '00000326'x Then\n         service = 'Name token services                      (IEANTCRS)'\n      When sftentry = '00000327'x Then\n         service = 'Name token services                      (IEANTDLS)'\n      When sftentry = '00000328'x Then\n         service = 'CONVTOD service                          (IEATCNVT)'\n      When sftentry = '00000329'x Then\n         service = 'Dynamic APF service                      (CSVQUERY)'\n      When sftentry = '0000032A'x Then\n         service = 'APPC service routine                     (ATBMIPTE)'\n      When sftentry = '0000032B'x Then\n         service = 'Dynamic Exit Support                     (CSVEXPR )'\n      When sftentry = '0000032C'x Then\n         service = 'CSRL16T service                          (CSRL16JP)'\n      When sftentry = '0000032D'x Then\n         service = 'SCHEDIRB service                         (IEAVEIRB)'\n      When sftentry = '0000032E'x Then\n         service = 'IOS Support                              (IOSVCOPR)'\n      When sftentry = '0000032F'x Then\n         service = 'HCD System/390 microprocessr cluster sup (CBDMSHSD)'\n      When sftentry = '00000330'x Then\n         service = 'TESTART CADS ALET Service                (IEAVXTRI)'\n      When sftentry = '00000331'x Then\n         service = 'SCHEDSRB                                 (IEAVSCHD)'\n      When sftentry = '00000333'x Then\n         service = 'HCD Sysplex Services (HSS) interface rtn (CBDMSHSS)'\n      When sftentry = '00000334'x Then\n         service = 'Captured UCB Services                    (IOSVCAPU)'\n      When sftentry = '00000335'x Then\n         service = 'Allocation DD Service                    (IEFDIS01)'\n      When sftentry = '00000336'x Then\n         service = 'ETR Information                          (IEATETRI)'\n      When sftentry = '00000337'x Then\n         service = 'LOGGER Router                            (IXGL2RTE)'\n      When sftentry = '00000338'x Then\n         service = 'RTM Linkage Stack Query                  (IEAVTLSQ)'\n      When sftentry = '00000339'x Then\n         service = 'LOGGER Router                            (IXGL2RTI)'\n      When sftentry = '0000033A'x Then\n         service = 'IOS Support                              (IOSVCDRP)'\n      When sftentry = '0000033B'x Then\n         service = 'Dynamic Linklist                         (CSVDLPR )'\n      When sftentry = '0000033C'x Then\n         service = 'Authorized Command Exit Manager          (IEAVEAEM)'\n      When sftentry = '0000033D'x Then\n         service = 'Logical Parmlib Service                  (IEFPIS01)'\n      When sftentry = '0000033E'x Then\n         service = 'Context Services Router                  (CTXROUTE)'\n      When sftentry = '0000033F'x Then\n         service = 'Product Enable/Disable                   (IFAEDPCT)'\n      When sftentry = '00000340'x Then\n         service = 'Dynamic LPA                              (CSVLPPR )'\n      When sftentry = '00000342'x Then\n         service = 'Enhanced PURGEDQ                         (IEAVPDQX)'\n      When sftentry = '00000343'x Then\n         service = 'IEAMQRY                                  (IEAVQRY )'\n      When sftentry = '00000344'x Then\n         service = 'Context Services Router                  (CTXROUTE)'\n      When sftentry = '00000345'x Then\n         service = 'IEAFP                                    (IEAVEFPR)'\n      When sftentry = '00000346'x Then\n         service = 'IEARR Service                            (IEAVSTA1)'\n      When sftentry = '00000347'x Then\n         service = 'IEARR Service                            (IEAVSTA1)'\n      When sftentry = '00000348'x Then\n         service = 'CSRSI Service                            (CSRSIPR )'\n      When sftentry = '00000349'x Then\n         service = 'RRS Set Environment                      (ATRUMSEN)'\n      When sftentry = '0000034A'x Then\n         service = 'RRS Retrieve Environment                 (ATRUMREN)'\n      When sftentry = '0000034B'x Then\n         service = 'Client License Services                  (ILMPRPCT)'\n      When sftentry = '0000034C'x Then\n         service = 'LE Services                              (CELSPCTK)'\n      When sftentry = '0000034D'x Then\n         service = 'LE Services                              (CELSPCTK)'\n      When sftentry = '0000034E'x Then\n         service = 'Create Name/Token Pair                   (IEAN4CRS)'\n      When sftentry = '0000034F'x Then\n         service = 'Delete Name/Token Pair                   (IEAN4DLS)'\n      When sftentry = '00000350'x Then\n         service = 'IPCS Storage Access                      (BLS1ACTV)'\n      When sftentry = '00000351'x Then\n         service = 'ILMQUERY                                 (ILMPQRY )'\n      When sftentry = '00000352'x Then\n         service = 'RRS Router                               (ATRBMIPC)'\n      When sftentry = '00000353'x Then\n         service = 'Unicode Services                         (CUNMZPC )'\n      When sftentry = '00000354'x Then\n         service = 'Supervisor Internal Processing           (IEAVIFAP)'\n      When sftentry = '00000355'x Then\n         service = 'VSAM Record Management                   (IDA0DBUG)'\n      When sftentry = '00000356'x Then\n         service = 'CTRACE                                   (ITTTWRTX)'\n      When sftentry = '00000357'x Then\n         service = 'IEAARR Service                           (IEAVTR4A)'\n      When sftentry = '00000358'x Then\n         service = 'EAV DEVMAN Service Routine               (DMODA002)'\n      When sftentry = '00000359'x Then\n         service = 'IEAARR Service                           (IEAVTR4A)'\n      When sftentry = '0000035A'x Then\n         service = 'CSV internal processing                  (CSVGETRP)'\n      When sftentry = '0000035B'x Then\n         service = 'Autoconfiguration Service Routine        (IOSVDACI)'\n      When sftentry = '0000035C'x Then\n         service = 'HISUSER Service Routine                  (HISNUSER)'\n      When sftentry = '0000035D'x Then\n         service = 'IEATXDC Service Routine                  (IEAVETX0)'\n      When sftentry = '0000035E'x Then\n         service = 'JCL Symbol Retrieve service routine      (IEFSJSR1)'\n      When sftentry = '00000400'x Then\n         service = 'WTO Service                              (IEAVH600)'\n      When sftentry = '00000500'x Then\n         service = 'System Trace Control Block Verification  (IEAVETCV)'\n      When sftentry = '00000501'x Then\n         service = 'System Trace Environment Alteration      (IEAVETEA)'\n      When sftentry = '00000502'x Then\n         service = 'System Trace Processor Alteration        (IEAVETPA)'\n      When sftentry = '00000503'x Then\n         service = 'System Trace Processor Snapshot          (IEAVETPS)'\n      When sftentry = '00000504'x Then\n         service = 'System Trace Processor Verification      (IEAVETPV)'\n      When sftentry = '00000505'x Then\n         service = 'System Trace Table Snapshot Data Extract (IEAVETSD)'\n      When sftentry = '00000506'x Then\n         service = 'System Trace Table Snapshot              (IEAVETSN)'\n      When sftentry = '00000507'x Then\n         service = 'System Trace Suspend, Resume, PSTART     (IEAVETSP)'\n      When sftentry = '00000508'x Then\n         service = 'System Trace Table Snapshot Filter       (IEAVETTF)'\n      When sftentry = '00000600'x Then\n         service = 'Virtual Fetch CSVVFSCH Service           (CSVVFSCH)'\n      When sftentry = '00000700'x Then\n         service = 'SMF Buffering Routine                    (IFAPCWTR)'\n      When sftentry = '00000800'x Then\n         service = 'Lnklst Lookaside (LLA)                   (CSVLLS01)'\n      When sftentry = '00000900'x Then\n         service = 'Data Space PC Service                    (RSM     )'\n      When sftentry = '00000A00'x Then\n         service = 'Virtual Lookaside Facility               (VLF     )'\n      When sftentry = '00000B00'x Then\n         service = 'XCF                                      (XCF     )'\n      When sftentry = '00000C00'x Then\n         service = 'Reserved for DFP use                     (DFP     )'\n      When sftentry = '00000D00'x Then\n         service = 'MVS/APPC Scheduler                       (APPC    )'\n      When sftentry = '00000E00'x Then\n         service = 'LLACOPY Service                          (ContSupr)'\n      When sftentry = '00000F00'x Then\n         service = 'SDOM services                            (SDOM    )'\n      When sftentry = '00001000'x Then\n         service = 'MVS Message Service                      (MVSMsgSr)'\n      When sftentry = '00001100'x Then\n         service = 'MVS/APPC scheduler                       (APPC    )'\n      When sftentry = '00001300'x Then\n         service = 'z/OS UNIX System Services space sw serv  (BXPJCSS )'\n      When sftentry = '00001301'x Then\n         service = 'z/OS UNIX System Services nonsp-sw serv  (BXPJCPC )'\n      When sftentry = '00001302'x Then\n         service = 'z/OS UNIX System Services authsp-sw serv (BXPJCPC )'\n      When sftentry = '00001303'x Then\n         service = 'z/OS UNIX System Services space sw callbl(BXPJCSS )'\n      When sftentry = '00001400'x Then\n         service = 'Reserved                                 (        )'\n      When sftentry = '00001504'x Then\n         service = 'System Logger                            (Logger  )'\n      When sftentry = '00001600'x Then\n         service = 'BOSS                                     (BOSS    )'\n      When sftentry = '00001700'x Then\n         service = 'IOS Space Switching Service              (IOSVIOSW)'\n      When sftentry = '00001800'x Then\n         service = 'BCPii services                           (        )'\n      When sftentry = '00001900'x Then\n         service = 'HIS Services                             (HISSSERV)'\n      Otherwise\n         service = '*** Unknown Program Call Function ***'\n      End\n   Say RIGHT(i,3,' ')'  LX: 'linkageix'  EX: 'entryix'   'service\n   sftentry = STORAGE(D2X(X2D(@start)+(i*4)),4) /* bump to next entry */\nEnd\nSay ' '\nSay 'System Function Table scan completed 'TIME()\nExit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LISTSMAP": {"ttr": 773, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x01\\x130\\x9f\\x01\\x14\\x04\\x9f\\x15R\\x00\\x90\\x00\\x8f\\x00\\x00\\xe2\\xc3\\xd5\\xe2\\xf0\\xf3@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2013-11-05T00:00:00", "modifydate": "2014-02-18T15:52:00", "lines": 144, "newlines": 143, "modlines": 0, "user": "SCNS03"}, "text": "/*REXX*/\n/*****************************************************************/\n/*LISTSMAP: REXX program to display key virtual storage points.  */\n/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */\n/*****************************************************************/\n/* MVS DATA AREAS:                                               */\n/*                CVT - Communications Vector Table (@'10'x)     */\n/*                GDA - Global Data Area                         */\n/*                                                               */\n/*                                                               */\n/*                                                               */\n/*****************************************************************/\nnumeric digits 30\n@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */\n@cvt = D2X(C2D(@cvt))                    /* binary to hex             */\n@cvtmz00  = STORAGE(D2X(X2D(@cvt)+164),4)    /* get CVTMZ00 bitstring */\n@cvtreal  = STORAGE(D2X(X2D(@cvt)+284),4)    /* get CVTREAL address   */\n@cvtreal  = D2X(C2D(@cvtreal))                 /* binary to hex       */\n@cvteorm  = STORAGE(D2X(X2D(@cvt)+312),4)    /* get CVTEORM address   */\n@cvteorm  = D2X(C2D(@cvteorm))                 /* binary to hex       */\n@cvtshrvm = STORAGE(D2X(X2D(@cvt)+416),4)    /* get CVTSHRVM address  */\n@cvtshrvm = D2X(C2D(@cvtshrvm))                /* binary to hex       */\n@cvtgda   = STORAGE(D2X(X2D(@cvt)+560),4)    /* get CVTGDA address    */\n@cvtgda   = D2X(C2D(@cvtgda))                  /* binary to hex       */\n@gdacsa   = D2X(X2D(@cvtgda)+108)            /* locate GDACSAstarts   */\n@gdacsa   = D2X(C2D(STORAGE(@gdacsa,4)))       /*  get GDACSA         */\n@gdacsasz = D2X(X2D(@cvtgda)+112)            /* locate GDACSASiZe     */\n@gdacsasz = D2X(C2D(STORAGE(@gdacsasz,4)))     /*  get GDACSASiZe     */\n@gdaecsa  = D2X(X2D(@cvtgda)+124)            /* locate GDAECSAstarts  */\n@gdaecsa  = D2X(C2D(STORAGE(@gdaecsa,4)))      /*  get GDAECSA        */\n@gdaecsas = D2X(X2D(@cvtgda)+128)            /* locate GDAECSASize    */\n@gdaecsas = D2X(C2D(STORAGE(@gdaecsas,4)))     /*  get GDAECSAS       */\n@cvtsmext = STORAGE(D2X(X2D(@cvt)+1196),4)   /* get CVTSMEXT address  */\n@cvtsmext = D2X(C2D(@cvtsmext))                /* binary to hex       */\n@cvtmlpas = D2X(X2D(@cvtsmext)+8)            /* locate CVTMLPAStarts  */\n@cvtmlpas = D2X(C2D(STORAGE(@cvtmlpas,4)))     /*  get CVTMLPAS       */\n@cvtmlpae = D2X(X2D(@cvtsmext)+12)           /* locate CVTMLPAEnds    */\n@cvtmlpae = D2X(C2D(STORAGE(@cvtmlpae,4)))     /*  get CVTMLPAE       */\n@cvtflpas = D2X(X2D(@cvtsmext)+16)           /* locate CVTFLPAStarts  */\n@cvtflpas = D2X(C2D(STORAGE(@cvtflpas,4)))     /*  get CVTFLPAS       */\n@cvtflpae = D2X(X2D(@cvtsmext)+20)           /* locate CVTFLPAEnds    */\n@cvtflpae = D2X(C2D(STORAGE(@cvtflpae,4)))     /*  get CVTFLPAE       */\n@cvtplpas = D2X(X2D(@cvtsmext)+24)           /* locate CVTPLPAStarts  */\n@cvtplpas = D2X(C2D(STORAGE(@cvtplpas,4)))     /*  get CVTPLPAS       */\n@cvtplpae = D2X(X2D(@cvtsmext)+28)           /* locate CVTPLPAEnds    */\n@cvtplpae = D2X(C2D(STORAGE(@cvtplpae,4)))     /*  get CVTPLPAE       */\n@cvtrwns  = D2X(X2D(@cvtsmext)+32)           /* locate CVTRWNStarts   */\n@cvtrwns  = D2X(C2D(STORAGE(@cvtrwns,4)))      /*  get CVTRWNS        */\n@cvtrwne  = D2X(X2D(@cvtsmext)+36)           /* locate CVTRWNEnds     */\n@cvtrwne  = D2X(C2D(STORAGE(@cvtrwne,4)))      /*  get CVTRWNE        */\n@cvtrons  = D2X(X2D(@cvtsmext)+40)           /* locate CVTRONStarts   */\n@cvtrons  = D2X(C2D(STORAGE(@cvtrons,4)))      /*  get CVTRONS        */\n@cvtrone  = D2X(X2D(@cvtsmext)+44)           /* locate CVTRONEnds     */\n@cvtrone  = D2X(C2D(STORAGE(@cvtrone,4)))      /*  get CVTRONE        */\n@cvterwns = D2X(X2D(@cvtsmext)+48)           /* locate CVTERWNStarts  */\n@cvterwns = D2X(C2D(STORAGE(@cvterwns,4)))     /*  get CVTERWNS       */\n@cvterwne = D2X(X2D(@cvtsmext)+52)           /* locate CVTERWNEnds    */\n@cvterwne = D2X(C2D(STORAGE(@cvterwne,4)))     /*  get CVTRRWNE       */\n@cvteplps = D2X(X2D(@cvtsmext)+56)           /* locate CVTEPLPStarts  */\n@cvteplps = D2X(C2D(STORAGE(@cvteplps,4)))     /*  get CVTEPLPS       */\n@cvteplpe = D2X(X2D(@cvtsmext)+60)           /* locate CVTEPLPEnds    */\n@cvteplpe = D2X(C2D(STORAGE(@cvteplpe,4)))     /*  get CVTRPLPE       */\n@cvteflps = D2X(X2D(@cvtsmext)+64)           /* locate CVTEFLPStarts  */\n@cvteflps = D2X(C2D(STORAGE(@cvteflps,4)))     /*  get CVTEFLPS       */\n@cvteflpe = D2X(X2D(@cvtsmext)+68)           /* locate CVTEFLPEnds    */\n@cvteflpe = D2X(C2D(STORAGE(@cvteflpe,4)))     /*  get CVTRFLPE       */\n@cvtemlps = D2X(X2D(@cvtsmext)+72)           /* locate CVTEMLPStarts  */\n@cvtemlps = D2X(C2D(STORAGE(@cvtemlps,4)))     /*  get CVTEMLPS       */\n@cvtemlpe = D2X(X2D(@cvtsmext)+76)           /* locate CVTEMLPEnds    */\n@cvtemlpe = D2X(C2D(STORAGE(@cvtemlpe,4)))     /*  get CVTRMLPE       */\nSay 'The CVT  is located at '@cvt '('X2D(@cvt)')'\nSay 'The CVTMZ00  field contains 'C2X(@cvtmz00) /*'('X2D(@cvtmz00)')'*/\nSay 'The CVTSEORM field contains '@cvteorm '('X2D(@cvteorm)')'\nSay 'The CVTREAL  field contains   '@cvtreal     '('X2D(@cvtreal)')'\nSay 'The CVTSHRVM field contains  '@cvtshrvm  '('X2D(@cvtshrvm)')'\nSay 'The CVTGDA   field contains  '@cvtgda    '('X2D(@cvtgda)')'\nSay 'The GDACSA   field contains  '@gdacsa    '('X2D(@gdacsa)')'\nSay 'The GDACSASZ field contains  '@gdacsasz  '('X2D(@gdacsasz)')'\nSay 'The GDAECSA  field contains  '@gdaecsa   '('X2D(@gdaecsa)')'\nSay 'The GDAECSAS field contains  '@gdaecsas  '('X2D(@gdaecsas)')'\nSay 'The CVTMLPAS field contains  '@cvtmlpas  '('X2D(@cvtmlpas)')'\nSay 'The CVTMLPAE field contains  '@cvtmlpae  '('X2D(@cvtmlpae)')'\nSay 'The CVTFLPAS field contains  '@cvtflpas  '('X2D(@cvtflpas)')'\nSay 'The CVTFLPAE field contains  '@cvtflpae  '('X2D(@cvtflpae)')'\nSay 'The CVTPLPAS field contains  '@cvtplpas  '('X2D(@cvtplpas)')'\nSay 'The CVTPLPAE field contains  '@cvtplpae  '('X2D(@cvtplpae)')'\nSay 'The CVTRWNS  field contains  '@cvtrwns   '('X2D(@cvtrwns)')'\nSay 'The CVTRWNE  field contains  '@cvtrwne   '('X2D(@cvtrwne)')'\nSay 'The CVTRONS  field contains  '@cvtrons   '('X2D(@cvtrons)')'\nSay 'The CVTRONE  field contains '@cvtrone   '('X2D(@cvtrone)')'\nSay 'The CVTERWNS field contains '@cvterwns  '('X2D(@cvterwns)')'\nSay 'The CVTERWNE field contains '@cvterwne  '('X2D(@cvterwne)')'\nSay 'The CVTEPLPS field contains '@cvteplps  '('X2D(@cvteplps)')'\nSay 'The CVTEPLPE field contains '@cvteplpe  '('X2D(@cvteplpe)')'\nSay 'The CVTEFLPS field contains '@cvteflps  '('X2D(@cvteflps)')'\nSay 'The CVTEFLPE field contains '@cvteflpe  '('X2D(@cvteflpe)')'\nSay 'The CVTEMLPS field contains '@cvtemlps  '('X2D(@cvtemlps)')'\nSay 'The CVTEMLPE field contains '@cvtemlpe  '('X2D(@cvtemlpe)')'\nSay ' '\nSay ' '\nSay ' '\n/*  simplify variable names & calculate some boundaries   */\n@csa1   = @cvtshrvm  ;\n/*sa1   = @cvtshrvm  ; @csa2  = D2X(X2D(@cvtmlpas)-1)         @@ csa  */\n@csa1g  = @gdacsa    ; @csa2g = D2X(X2D(@gdacsasz)+X2D(@gdacsa)-1)/* g*/\n@mlpa1  = @cvtmlpas  ; @mlpa2 = @cvtmlpae                     /* mlpa */\n@flpa1  = @cvtflpas  ; @flpa2 = @cvtflpae                     /* flpa */\n@plpa1  = @cvtplpas  ; @plpa2 = @cvtplpae                     /* plpa */\n@sqa1   = D2X(X2D(@cvtplpae)+1) ; @sqa2 = D2X(X2D(@cvtrwns)-1)/* sqa  */\n@nuc1   = @cvtrwns   ; @nuc2  = @cvterwne                     /* nuc  */\n@esqa1  = D2X(X2D(@nuc2)+1) ; @esqa2 = D2X(X2D(@cvteplps)-1)  /* esqa */\n@eplpa1 = @cvteplps  ; @eplpa2 = @cvteplpe                    /* eplpa*/\n@eflpa1 = @cvteflps  ; @eflpa2 = @cvteflpe                    /* eflpa*/\n@emlpa1 = @cvtemlps  ; @emlpa2 = @cvtemlpe                    /* emlpa*/\n@ecsa1g = @gdaecsa   ; @ecsa2g= D2X(X2D(@gdaecsas)+X2D(@gdaecsa)-1)/*g*/\n/*csas    = (X2D(@csa2)-X2D(@csa1)+1)/1024     @@ size of csa   KB    */\ncsasg   =  X2D(@gdacsasz)/1024               /* size of csag  KB    */\nmlpas   = (X2D(@mlpa2)-X2D(@mlpa1)+1)/1024   /* size of mlpa  KB    */\nflpas   = (X2D(@flpa2)-X2D(@flpa1)+1)/1024   /* size of flpa  KB    */\nplpas   = (X2D(@plpa2)-X2D(@plpa1)+1)/1024   /* size of plpa  KB    */\nsqas    = (X2D(@sqa2)-X2D(@sqa1)+1)/1024     /* size of sqa   KB    */\nnucs    = (X2D(@nuc2)-X2D(@nuc1)+1)/1024     /* size of nuc   KB    */\nesqas   = (X2D(@esqa2)-X2D(@esqa1)+1)/1024   /* size of esqa  KB    */\neplpas  = (X2D(@eplpa2)-X2D(@eplpa1)+1)/1024 /* size of eplpa KB    */\neflpas  = (X2D(@eflpa2)-X2D(@eflpa1)+1)/1024 /* size of eflpa KB    */\nemlpas  = (X2D(@emlpa2)-X2D(@emlpa1)+1)/1024 /* size of emlpa KB    */\necsasg  =  X2D(@gdaecsas)/1024               /* size of ecsag KB    */\nSay 'Key storage addresses for system routine residency analysis:'\nSay ' '\nSay 'STORAGE AREA NAME               SIZE(K)      ADDRESS RANGE'\nSay ' '\nSay 'Common Service Area (CSA)       'RIGHT(csas,5)  '     'RIGHT(@csa1,8,0)'-'RIGHT(@csa2,8,0)\nSay 'Common Service Area (CSA/GDA)   'RIGHT(csasg,5)  '     'RIGHT(@csa1g,8,0)'-'RIGHT(@csa2g,8,0)\nSay 'Modified Link Pack Area (MLPA)  'RIGHT(mlpas,5) '     'RIGHT(@mlpa1,8,0)'-'RIGHT(@mlpa2,8,0)\nSay 'Fixed Link Pack Area (FLPA)     'RIGHT(flpas,5) '     'RIGHT(@flpa1,8,0)'-'RIGHT(@flpa2,8,0)\nSay 'Pageable Link Pack Area (PLPA)  'RIGHT(plpas,5) '     'RIGHT(@plpa1,8,0)'-'RIGHT(@flpa2,8,0)\nSay 'System Queue Area (SQA)         'RIGHT(sqas,5)  '     'RIGHT(@sqa1,8,0)'-'RIGHT(@sqa2,8,0)\nSay 'MVS Nucleus (NUC)               'RIGHT(nucs,5)  '     'RIGHT(@nuc1,8,0)'-'RIGHT(@nuc2,8,0)\nSay 'Extended SQA                    'RIGHT(esqas,5) '     'RIGHT(@esqa1,8,0)'-'RIGHT(@esqa2,8,0)\nSay 'Extended PLPA                   'RIGHT(eplpas,5) '     'RIGHT(@eplpa1,8,0)'-'RIGHT(@eplpa2,8,0)\nSay 'Extended FLPA                   'RIGHT(eflpas,5) '     'RIGHT(@eflpa1,8,0)'-'RIGHT(@eflpa2,8,0)\nSay 'Extended MLPA                   'Right(emlpas,5) '     'RIGHT(@emlpa1,8,0)'-'RIGHT(@emlpa2,8,0)\nSay 'Extended CSA/GDA                'Right(ecsasg,5) '     'RIGHT(@ecsa1g,8,0)'-'RIGHT(@ecsa2g,8,0)\nExit\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LISTSMF": {"ttr": 2829, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x16\\x01\\x130_\\x01\\x14\\x05\\x0f\"W\\x00\\x8f\\x00\\x8f\\x00\\x00\\xe2\\xc3\\xd5\\xe2\\xf0\\xf3@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2013-11-01T00:00:00", "modifydate": "2014-02-19T22:57:16", "lines": 143, "newlines": 143, "modlines": 0, "user": "SCNS03"}, "text": "/*REXX*/\n/*****************************************************************/\n/* LISTSMF: REXX program to show SMF information.                */\n/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */\n/*****************************************************************/\n/* MVS DATA AREAS:                                               */\n/*                CVT - Communications Vector Table (@'10'x)     */\n/*               SMCA - SMF Control Area                         */\n/*                RDS - SMF Recording Data Set                   */\n/*               SSTP - SMF Selectivity Table                    */\n/*                                                               */\n/* AJC 12/01/05  Fix problem with length of Selectivity Table.   */\n/*****************************************************************/\n@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */\n@cvt = D2X(C2D(@cvt))                         /* binary to dec to hex */\n@cvtsmca  = STORAGE(D2X(X2D(@cvt)+196),4)      /* get CVTSMCA address */\n@smca     = C2X(@cvtsmca) ; @cvtsmca = RIGHT(@smca,7)    /* trim addr */\nsmcasid   = STORAGE(D2X(X2D(@cvtsmca)+016),4)  /* get system id field */\nsmcadsct  = STORAGE(D2X(X2D(@cvtsmca)+116),4)       /* get # rec lost */\nsmcadsct = C2D(smcadsct)                             /* binary to dec */\nsmcasjwt  = STORAGE(D2X(X2D(@cvtsmca)+144),4)       /* get system jwt */\nsmcaprmt  = STORAGE(D2X(X2D(@cvtsmca)+208),1) /* get smf prompt flags */\n@smcafrds = STORAGE(D2X(X2D(@cvtsmca)+244),4)  /* get 1st RDA address */\n@smcafrds = C2X(@smcafrds)                           /* binary to hex */\n@smcalrds = STORAGE(D2X(X2D(@cvtsmca)+248),4) /* get last RDA address */\n@smcalrds = C2X(@smcalrds)                           /* binary to hex */\n@smcasstp = STORAGE(D2X(X2D(@cvtsmca)+328),4)     /* get SSTP address */\n@smcasstp = C2X(@smcasstp)                           /* binary to hex */\nsmcaitme  = STORAGE(D2X(X2D(@cvtsmca)+336),4)         /* get IPL time */\nipltime = C2D(smcaitme) ; iplhh = ipltime%360000         /* get hours */\niplmm = ipltime//360000 ; iplmm = iplmm%6000           /* get minutes */\niplt = RIGHT(iplhh,2,0)':'RIGHT(iplmm,2,0)            /* format HH:MM */\nsmcaidte  = STORAGE(D2X(X2D(@cvtsmca)+340),4)         /* get IPL date */\nsmcansst = STORAGE(D2X(X2D(@cvtsmca)+348),2)              /* get NSST */\nsmcansst = C2D(smcansst)                             /* binary to dec */\nsmcalsst = STORAGE(D2X(X2D(@cvtsmca)+350),2)              /* get LSST */\nsmcalsst = C2D(smcalsst)                             /* binary to dec */\ni = 0 ; endofrds = 0 ; j = 0 ; k = 0\nprompt = 'NOPROMPT' ; @rds = @smcafrds ; @sstp = @smcasstp\nIf BITAND(smcaprmt,'80'x) = '80'x Then prompt = 'PROMPT(IPLR)'\nIf BITAND(smcaprmt,'40'x) = '40'x Then prompt = 'PROMPT(LIST)'\nipld = C2X(smcaidte) ; ipld = SUBSTR(ipld,3,5)\nipldays = SUBSTR(ipld,3,3) ; days = DATE(D) - ipldays\nIf days < 0 Then days = days + 365     /* crossed into new year */\nIf days = 0 Then iplday = '(Today)'\nIf days = 1 Then iplday = '(Yesterday)'\nIf days > 1 Then iplday = '('days' days ago)'\nAddress TSO ; \"CLEAR\"\nSay 'CVT:'@cvt' SMCA:'@smca 'RDS:'@rds'   'TIME() DATE()\nSay ' '\nSay 'SMFID:'smcasid'  JWT:'smcasjwt'  'prompt'  IPL:'ipld' 'iplday' at 'iplt\nSay ' '\nDo While endofrds = 0 & i < 37         /* Trace the RDS chain */\n   i = i + 1                                  /* count all RDSs found */\n   @rdsnext= STORAGE(D2X(X2D(@rds)+4),4)          /* next RDS address */\n   @rdsnext=C2X(@rdsnext)                               /* bin to hex */\n   rdsflg1 = STORAGE(D2X(X2D(@rds)+12),1)              /* get RDSFLG1 */\n   dump = '' ; active = '      '\n   If BITAND(rdsflg1,'08'x) = '08'x Then dump = 'Dump Requested'\n   If BITAND(rdsflg1,'04'x) \\= '04'x Then active = 'Active'\n   rdsname = STORAGE(D2X(X2D(@rds)+16),16)       /* AJCget RDS DSName */\n   rdsvol  = STORAGE(D2X(X2D(@rds)+60),6)        /* ajcget RDS volser */\n   rdscapty= STORAGE(D2X(X2D(@rds)+76),4)   /* get RDS size in blocks */\n   rdsnxtbk= STORAGE(D2X(X2D(@rds)+80),4)       /* get RDS next block */\n   capty = C2D(rdscapty) ; nxtbk = C2D(rdsnxtbk) ; used = nxtbk - 1\n   pctused=TRUNC((used*100)/capty,1) ; pctused=RIGHT(pctused,5)'%'\n   Say RIGHT(i,2,' ') rdsname rdsvol RIGHT(capty,6),\n       RIGHT(used,6)' ('pctused') 'dump active\n   @rds = @rdsnext ; If @rds = @smcalrds Then endofrds = 1\nEnd\nIf smcadsct \u00ac= '0' Then\n   do\n     Say ' '\n     Say 'Number of SMF records lost = 'smcadsct\n   end\nSay ' '\nSay 'SMF selectivity tables defined: 'smcansst'    SST length: 'smcalsst\nSay ' '\nbit0='80'x ; bit1='40'x ; bit2='20'x ; bit3='10'x\nbit4='08'x ; bit5='04'x ; bit6='02'x ; bit7='01'x\nDo kk = 1 To smcansst\n   sst    = STORAGE(@sstp,smcalsst)                  /* get sst block */\n   sstn   = SUBSTR(sst,1,4)                      /* get subsysname id */\n   If sstn = '00000000'x Then sstn = 'Null'\n   rectbl = SUBSTR(sst,17,32)           /* get record type bit string */\n   rectypes = ''\n   Do i = 0 to 31\n      byte = SUBSTR(rectbl,i+1,1)\n      k = i * 8\n      If BITAND(byte,bit0)=bit0 Then rectypes = rectypes k\n      If BITAND(byte,bit1)=bit1 Then rectypes = rectypes k+1\n      If BITAND(byte,bit2)=bit2 Then rectypes = rectypes k+2\n      If BITAND(byte,bit3)=bit3 Then rectypes = rectypes k+3\n      If BITAND(byte,bit4)=bit4 Then rectypes = rectypes k+4\n      If BITAND(byte,bit5)=bit5 Then rectypes = rectypes k+5\n      If BITAND(byte,bit6)=bit6 Then rectypes = rectypes k+6\n      If BITAND(byte,bit7)=bit7 Then rectypes = rectypes k+7\n   End\n   i = 0 ; k = 0 ; f = '' ; j = 0 ; jj = 0\n   Do While rectypes \\= ''\n      i = i + 1\n      PARSE VAR rectypes type.i rectypes\n   End\n   If i > 2 Then\n         Do k = 1 to i-2\n            j = k + 1 ; jj = k + 2\n            If type.k = type.j - 1 & type.j = type.jj -1 Then f.k = '*'\n                                                         Else f.k = ' '\n         End\n   rectypes = 'TYPE('\n   Do k = 1 to i\n      If f.k \\= '*' Then Do\n                            rectypes = rectypes''type.k\n                            If k \\= i Then rectypes = rectypes','\n                                      Else rectypes = rectypes')'\n                         End\n                    Else Do\n                           rectypes = rectypes''type.k':'\n                           Do While f.k = '*' ; k=k+1 ; End\n                         End\n   End\n   If RIGHT(rectypes,1) = ':' Then  /* compensate for single type */\n      Do\n         rectypes = LEFT(rectypes,LENGTH(rectypes)-1)')'\n         nop\n      End\n   line2 = ''\n   If LENGTH(rectypes) >70 Then\n      Do\n         Do i = 70 to 1 By -1\n            If SUBSTR(rectypes,i,1) = ',' Then Leave\n         End\n         line2 = SUBSTR(rectypes,i+1,smcalsst)\n         rectypes = LEFT(rectypes,i)\n      End\n   If sstn = 'Null' Then rectypes = ''\n   Say RIGHT(kk,2,' ') sstn rectypes\n   If line2 \\= '' Then Say '             'line2\n   @sstp  = D2X(X2D(@sstp)+smcalsst)              /* bump to next sst */\nEnd\nSay ' '\nSay 'SMF analysis completed: 'TIME()\nExit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LISTSSN": {"ttr": 2831, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x17\\x00\\x94\\x08\\x8f\\x01\\x14\\x05\\x0f\"W\\x00B\\x00B\\x00\\x00\\xe2\\xc3\\xd5\\xe2\\xf0\\xf3@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1994-03-29T00:00:00", "modifydate": "2014-02-19T22:57:17", "lines": 66, "newlines": 66, "modlines": 0, "user": "SCNS03"}, "text": "/*REXX*/\n/*****************************************************************/\n/* LISTSSN: REXX program to show all MVS subsystems.             */\n/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */\n/*****************************************************************/\n/* MVS DATA AREAS:                                               */\n/*                CVT - Communications Vector Table (@'10'x)     */\n/*              JESCT - JES Communications Table                 */\n/*              SSCVT - Subsystem Communications Vector Table    */\n/*               SSVT - Subsystem vector Table                   */\n/*                                                               */\n/*****************************************************************/\n@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */\n@cvt = D2X(C2D(@cvt))                         /* binary to dec to hex */\n@cvtjesct = STORAGE(D2X(X2D(@cvt)+296),4)     /* get CVTJESCT address */\n@cvtjesct = D2X(C2D(@cvtjesct))               /* binary to dec to hex */\n@jesct    = STORAGE(D2X(X2D(@cvtjesct)+24),4)    /* get JESCT address */\n@jesct    = D2X(C2D(@jesct))                  /* binary to dec to hex */\nAddress TSO ; \"CLEAR\"\nSay 'CVT:'@cvt' JESCT:'@jesct' SSCVT chain trace started: 'TIME() DATE()\nSay ' '\ni = 0 ; endofchn = 0 ; j = 0 ; @ssct = @jesct ; e = 0\nina = 0 ; inacsnam = '' ; inaline1 = ''\nSay '    Snam Fnum  Sysevents Monitored'\nSay '    ---- ----  ------------------------------------------------------------'\nDo While endofchn = 0 & i < 50\n   i = i + 1                                 /* count all SSCTs found */\n   @scta   = STORAGE(D2X(X2D(@ssct)+4),4)    /* get next SSCT address */\n   @scta   = D2X(C2D(@scta))                     /* bin to dec to hex */\n   snam    = STORAGE(D2X(X2D(@ssct)+8),4)     /* get subsystem's name */\n   @ssvt   = STORAGE(D2X(X2D(@ssct)+16),4)        /* get SSVT address */\n   @ssvt   = D2X(C2D(@ssvt))                     /* bin to dec to hex */\n   If @ssvt = 0 Then Do           /* make note of inactive subsystems */\n      ina = ina + 1\n      inacsnam = inacsnam snam           /* build primary output line */\n      If LENGTH(inacsnam) >= 70 Then Do   /* logic for 2 output lines */\n         inaline1 = inacsnam\n         inacsnam = ''\n         End\n      End\n   If @ssvt \\= 0 Then Do             /* detail only active subsystems */\n      j = j + 1                                  /* count active ones */\n      sysevents = ''                    /* SYSEVENTS output code line */\n      fnum = STORAGE(D2X(X2D(@ssvt)+2),2)      /* number of functions */\n      fnum = C2D(fnum)\n      fmat = STORAGE(D2X(X2D(@ssvt)+4),256)   /* function code matrix */\n      Do e = 1 to 256          /* scan fmat, load sysevents code line */\n         If C2D(SUBSTR(fmat,e,1)) \\= 0 Then sysevents = sysevents e\n      End\n      Say RIGHT(j,3,' ') snam'  'RIGHT(fnum,2,0)'  'sysevents\n      End\n   @ssct = @scta\n   If @ssct = 0 Then endofchn = 1    /* zero address ends chain */\nEnd\nIf ina > 0 Then Do\n   Say ' '\n   Say RIGHT(ina,3,' ') 'Subsystems defined, no SSVT built:'\n   If LENGTH(inaline1) \\= 0 Then Do\n      Say '     'inaline1\n      If LENGTH(inacsnam) \\= 0 Then Say '     'inacsnam\n      End\n      Else Say '     'inacsnam\n   End\nSay '---'\nSay RIGHT(i,3,' ')' SSCVT blocks scanned.  Completed: 'TIME()\nExit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LISTSVCJ": {"ttr": 522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00R\\x00\\x94\\x08\\x8f\\x00\\x94\\x08\\x8f\\x10\\x00\\x00/\\x00/\\x00\\x00\\xc3\\xd6\\xd5\\xe8\\xc5\\xd9\\xe2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-03-29T00:00:00", "modifydate": "1994-03-29T10:00:52", "lines": 47, "newlines": 47, "modlines": 0, "user": "CONYERS"}, "text": "/*REXX*/\n/*****************************************************************/\n/*LISTSVCJ: REXX program to display SVC update journal.          */\n/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */\n/*****************************************************************/\n/* MVS DATA AREAS:                                               */\n/*                CVT - Communications Vector Table (@'10'x)     */\n/*               SCVT - Supervisor Call Vector Table             */\n/*               SVCR - SVC Recording Table                      */\n/*                                                               */\n/*                                                               */\n/*****************************************************************/\n@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */\n@cvt = D2X(C2D(@cvt))                    /* binary to hex             */\n@cvtabend = STORAGE(D2X(X2D(@cvt)+200),4)    /* get CVTABEND address  */\n@cvtabend = D2X(C2D(@cvtabend))                /* binary to hex       */\n@scvtsvcr = D2X(X2D(@cvtabend)+136)          /* SCVT addressibility   */\n@scvtsvcr = STORAGE(@scvtsvcr,4)                  /* SVCR table       */\n@scvtsvcr = D2X(C2D(@scvtsvcr))                /* binary to hex       */\nSay ' '\nSay ' '\nSay 'The CVT  is located at '@cvt '('X2D(@cvt)')'\nSay 'The CVTABEND field points to '@cvtabend '('X2D(@cvtabend)')'\nSay 'The SCVTSVCR field points to '@scvtsvcr '('X2D(@scvtsvcr)')'\nSay ' '\nSay 'The SVC Update Journal table is at '@scvtsvcr '('X2D(@scvtsvcr)')'\nSay ' '\nhits = 0\nDo i = 0 to 255                                 /* loop thru storage  */\n   bytes = STORAGE(D2X(X2D(@scvtsvcr)+(i*24)),24)\n   bytes = C2X(bytes)\n   If SUBSTR(bytes,1,16) \\= '0000000000000000'\n      Then Do\n         hits = hits + 1\n         Say ' '\n         Say '  SVC 'RIGHT(i,3,0) 'updated.  Old SVCTABLE entry: 'SUBSTR(bytes,1,16)\n         Say '           Updating pgm return address: 'SUBSTR(bytes,17,8)\n         Say '                    New SVC EP address: 'SUBSTR(bytes,26,8)\n         Say '                         Times updated: 'X2D(SUBSTR(bytes,41,4))\n         If SUBSTR(bytes,35,5) = '00000'\n            Then Say '                   Date of last update: unknown'\n            Else Say '                   Date of last update: 'SUBSTR(bytes,35,5)\n      End\nEnd\nSay ' '\nSay 'SVCTABLE entries showing updates in the journal = 'hits\nExit\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LISTSVCT": {"ttr": 3073, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x19\\x00\\x94\\x08\\x8f\\x01\\x14\\x05\\x0f\"W\\x00\\xbb\\x00\\xbb\\x00\\x00\\xe2\\xc3\\xd5\\xe2\\xf0\\xf3@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1994-03-29T00:00:00", "modifydate": "2014-02-19T22:57:19", "lines": 187, "newlines": 187, "modlines": 0, "user": "SCNS03"}, "text": "/*REXX*/\n/*****************************************************************/\n/*LISTSVCT: REXX program to display SVC table from CSTOR.        */\n/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */\n/*****************************************************************/\n/* MVS DATA AREAS:                                               */\n/*                CVT - Communications Vector Table (@'10'x)     */\n/*               SCVT - Supervisor Call Vector Table             */\n/*               SVCT - SVC Table                                */\n/*                                                               */\n/*                                                               */\n/*****************************************************************/\n/*--------------virtual storage map definition section----------------*/\nNumeric Digits 10           /* required to handle decimal conversions */\n@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */\n@cvt = D2X(C2D(@cvt))                    /* binary to hex             */\n@cvtreal  = STORAGE(D2X(X2D(@cvt)+284),4)    /* get CVTREAL address   */\n@cvtreal  = D2X(C2D(@cvtreal))                 /* binary to hex       */\n@cvtshrvm = STORAGE(D2X(X2D(@cvt)+416),4)    /* get CVTSHRVM address  */\n@cvtshrvm = D2X(C2D(@cvtshrvm))                /* binary to hex       */\n@cvtgda   = STORAGE(D2X(X2D(@cvt)+560),4)    /* get CVTGDA address    */\n@cvtgda   = D2X(C2D(@cvtgda))                  /* binary to hex       */\n@gdacsa   = D2X(X2D(@cvtgda)+108)            /* locate GDACSAstarts   */\n@gdacsa   = D2X(C2D(STORAGE(@gdacsa,4)))       /*  get GDACSA         */\n@gdacsasz = D2X(X2D(@cvtgda)+112)            /* locate GDACSASiZe     */\n@gdacsasz = D2X(C2D(STORAGE(@gdacsasz,4)))     /*  get GDACSASiZe     */\n@gdaecsa  = D2X(X2D(@cvtgda)+124)            /* locate GDAECSAstarts  */\n@gdaecsa  = D2X(C2D(STORAGE(@gdaecsa,4)))      /*  get GDAECSA        */\n@gdaecsas = D2X(X2D(@cvtgda)+128)            /* locate GDAECSASize    */\n@gdaecsas = D2X(C2D(STORAGE(@gdaecsas,4)))     /*  get GDAECSAS       */\n@cvtsmext = STORAGE(D2X(X2D(@cvt)+1196),4)   /* get CVTSMEXT address  */\n@cvtsmext = D2X(C2D(@cvtsmext))                /* binary to hex       */\n@cvtmlpas = D2X(X2D(@cvtsmext)+8)            /* locate CVTMLPAStarts  */\n@cvtmlpas = D2X(C2D(STORAGE(@cvtmlpas,4)))     /*  get CVTMLPAS       */\n@cvtmlpae = D2X(X2D(@cvtsmext)+12)           /* locate CVTMLPAEnds    */\n@cvtmlpae = D2X(C2D(STORAGE(@cvtmlpae,4)))     /*  get CVTMLPAE       */\n@cvtflpas = D2X(X2D(@cvtsmext)+16)           /* locate CVTFLPAStarts  */\n@cvtflpas = D2X(C2D(STORAGE(@cvtflpas,4)))     /*  get CVTFLPAS       */\n@cvtflpae = D2X(X2D(@cvtsmext)+20)           /* locate CVTFLPAEnds    */\n@cvtflpae = D2X(C2D(STORAGE(@cvtflpae,4)))     /*  get CVTFLPAE       */\n@cvtplpas = D2X(X2D(@cvtsmext)+24)           /* locate CVTPLPAStarts  */\n@cvtplpas = D2X(C2D(STORAGE(@cvtplpas,4)))     /*  get CVTPLPAS       */\n@cvtplpae = D2X(X2D(@cvtsmext)+28)           /* locate CVTPLPAEnds    */\n@cvtplpae = D2X(C2D(STORAGE(@cvtplpae,4)))     /*  get CVTPLPAE       */\n@cvtrwns  = D2X(X2D(@cvtsmext)+32)           /* locate CVTRWNStarts   */\n@cvtrwns  = D2X(C2D(STORAGE(@cvtrwns,4)))      /*  get CVTRWNS        */\n@cvtrwne  = D2X(X2D(@cvtsmext)+36)           /* locate CVTRWNEnds     */\n@cvtrwne  = D2X(C2D(STORAGE(@cvtrwne,4)))      /*  get CVTRWNE        */\n@cvtrons  = D2X(X2D(@cvtsmext)+40)           /* locate CVTRONStarts   */\n@cvtrons  = D2X(C2D(STORAGE(@cvtrons,4)))      /*  get CVTRONS        */\n@cvtrone  = D2X(X2D(@cvtsmext)+44)           /* locate CVTRONEnds     */\n@cvtrone  = D2X(C2D(STORAGE(@cvtrone,4)))      /*  get CVTRONE        */\n@cvterwns = D2X(X2D(@cvtsmext)+48)           /* locate CVTERWNStarts  */\n@cvterwns = D2X(C2D(STORAGE(@cvterwns,4)))     /*  get CVTERWNS       */\n@cvterwne = D2X(X2D(@cvtsmext)+52)           /* locate CVTERWNEnds    */\n@cvterwne = D2X(C2D(STORAGE(@cvterwne,4)))     /*  get CVTRRWNE       */\n@cvteplps = D2X(X2D(@cvtsmext)+56)           /* locate CVTEPLPStarts  */\n@cvteplps = D2X(C2D(STORAGE(@cvteplps,4)))     /*  get CVTEPLPS       */\n@cvteplpe = D2X(X2D(@cvtsmext)+60)           /* locate CVTEPLPEnds    */\n@cvteplpe = D2X(C2D(STORAGE(@cvteplpe,4)))     /*  get CVTRPLPE       */\n@cvteflps = D2X(X2D(@cvtsmext)+64)           /* locate CVTEFLPStarts  */\n@cvteflps = D2X(C2D(STORAGE(@cvteflps,4)))     /*  get CVTEFLPS       */\n@cvteflpe = D2X(X2D(@cvtsmext)+68)           /* locate CVTEFLPEnds    */\n@cvteflpe = D2X(C2D(STORAGE(@cvteflpe,4)))     /*  get CVTRFLPE       */\n@cvtemlps = D2X(X2D(@cvtsmext)+72)           /* locate CVTEMLPStarts  */\n@cvtemlps = D2X(C2D(STORAGE(@cvtemlps,4)))     /*  get CVTEMLPS       */\n@cvtemlpe = D2X(X2D(@cvtsmext)+76)           /* locate CVTEMLPEnds    */\n@cvtemlpe = D2X(C2D(STORAGE(@cvtemlpe,4)))     /*  get CVTRMLPE       */\n        /*------simplify variable names & make addresses decimal------*/\n@csa1g  = @gdacsa    ; @csa2g = D2X(X2D(@gdacsasz)+X2D(@gdacsa)-1)/* g*/\n   csa1 = X2D(@csa1g) ; csa2 = X2D(@csa2g)                    /* csa  */\n@mlpa1  = @cvtmlpas  ; @mlpa2 = @cvtmlpae                     /* mlpa */\n   mlpa1 = X2D(@mlpa1) ; mlpa2 = X2D(@mlpa2)\n@flpa1  = @cvtflpas  ; @flpa2 = @cvtflpae                     /* flpa */\n   flpa1 = X2D(@flpa1) ; flpa2 = X2D(@flpa2)\n@plpa1  = @cvtplpas  ; @plpa2 = @cvtplpae                     /* plpa */\n   plpa1 = X2D(@plpa1) ; plpa2 = X2D(@plpa2)\n@sqa1   = D2X(X2D(@cvtplpae)+1) ; @sqa2 = D2X(X2D(@cvtrwns)-1)/* sqa  */\n   sqa1 = X2D(@sqa1) ; sqa2 = X2D(@sqa2)\n@nuc1   = @cvtrwns   ; @nuc2  = @cvterwne                     /* nuc  */\n   nuc1 = X2D(@nuc1) ; nuc2 = X2D(@nuc2)\n@esqa1  = D2X(X2D(@nuc2)+1) ; @esqa2 = D2X(X2D(@cvteplps)-1)  /* esqa */\n  esqa1 = X2D(@esqa1) ; esqa2 = X2D(@esqa2)\n@eplpa1 = @cvteplps  ; @eplpa2 = @cvteplpe                    /* eplpa*/\n eplpa1 = X2D(@eplpa1) ; eplpa2 = X2D(@eplpa2)\n@eflpa1 = @cvteflps  ; @eflpa2 = @cvteflpe                    /* eflpa*/\n eflpa1 = X2D(@eflpa1) ; eflpa2 = X2D(@eflpa2)\n@emlpa1 = @cvtemlps  ; @emlpa2 = @cvtemlpe                    /* emlpa*/\n emlpa1 = X2D(@emlpa1) ; emlpa2 = X2D(@emlpa2)\n@ecsa1g = @gdaecsa   ; @ecsa2g= D2X(X2D(@gdaecsas)+X2D(@gdaecsa)-1)/*g*/\n  ecsa1 = X2D(@ecsa1g) ; ecsa2 = X2D(@ecsa2g)\n@eprivs = X2D(@ecsa2g)+1                               /* ext private */\n@eprive = 2147483647                         /* fixed by architecture */\n epriv1 = @eprivs ; epriv2 = @eprive\n@psas   = 0 ; @psae = 4095                       /* psa fixed by arch */\n   psa1 = @psas ; psa2 = @psae\n@prive  = X2D(@csa1g)-1 ; @privs = X2D(@psae)+1            /* private */\n  priv1 = @privs ; priv2 = @prive\n              /*------------------------------------------------------*/\n             /* Usage Notes: Hex character compares are incompatible */\n            /*    for storage residency determination.  Thus, entry */\n           /*     point addresses must be converted to decimal and */\n          /*      VS boundary addresses must be converted to de-  */\n         /*       cimal for correct compare operations.          */\n        /*------------------------------------------------------*/\n/*----------end of virtual storage map definition section-------------*/\n@cvtabend = STORAGE(D2X(X2D(@cvt)+200),4)    /* get CVTABEND address  */\n@cvtabend = D2X(C2D(@cvtabend))                /* binary to hex       */\n@scvtsvct = D2X(X2D(@cvtabend)+132)          /* SCVT addressibility   */\n@scvtsvct = STORAGE(@scvtsvct,4)                  /* SVCT table       */\n@scvtsvct = D2X(C2D(@scvtsvct))                /* binary to hex       */\nAddress TSO ; \"CLEAR\"\nSay 'CVT:'@cvt' CVTABEND:'@cvtabend' SCVTSVCT:'@scvtsvct DATE() TIME()\nSay ' '\nSay 'Active SVCs follow:'\nSay ' '\nactive = 0 ; inactive = 0 ; svcapf = 0 ; svcesr = 0\nnucepn = 'IGCERROR' ; Call \"#NUCLKUP\" nucepn ; igcerror = Result\nDo i = 0 to 255                                 /* loop thru storage  */\n   bytes = STORAGE(D2X(X2D(@scvtsvct)+(i*8)),8)\n   addr = SUBSTR(bytes,1,4)       /* sloppy code to grab EP in binary */\n   bytes = C2X(bytes)          /* legacy code before learning bit ops */\n   svcep  = SUBSTR(bytes,1,8)\n                                        /* determine storage location */\n   addr = BITAND(addr,'7FFFFFFF'x)        /* shave off amode bit (32) */\n   addr = C2D(addr)                      /* make numeric for compares */\n   sloc = 'ERROR'                       /* determine module residency */\n   If (addr >= csa1   & addr <= csa2  ) Then sloc = 'CSA  '\n      Else If (addr >= mlpa1  & addr <= mlpa2 ) Then sloc = 'MLPA '\n      Else If (addr >= flpa1  & addr <= flpa2 ) Then sloc = 'FLPA '\n      Else If (addr >= plpa1  & addr <= plpa2 ) Then sloc = 'PLPA '\n      Else If (addr >= sqa1   & addr <= sqa2  ) Then sloc = 'SQA  '\n      Else If (addr >= nuc1   & addr <= nuc2  ) Then sloc = 'NUC  '\n      Else If (addr >= esqa1  & addr <= esqa2 ) Then sloc = 'ESQA '\n      Else If (addr >= eplpa1 & addr <= eplpa2) Then sloc = 'EPLPA'\n      Else If (addr >= eflpa1 & addr <= eflpa2) Then sloc = 'EFLPA'\n      Else If (addr >= emlpa1 & addr <= emlpa2) Then sloc = 'EMLPA'\n      Else If (addr >= ecsa1  & addr <= ecsa2 ) Then sloc = 'ECSA '\n      Else If (addr >= epriv1 & addr <= epriv2) Then sloc = 'EPRIV'\n      Else If (addr >= priv1  & addr <= priv2 ) Then sloc = 'PRIV '\n      Else If (addr >= psa1   & addr <= psa2  ) Then sloc = 'PSA  '\n      inactflag = 0\n      If igcerror = Right(D2X(addr),8,0)  /* normalize for match */\n         Then Do\n            inactive = inactive + 1\n            inactflag = 1\n         End\n         Else active = active + 1\n   svctp1 = SUBSTR(bytes,9,1)\n      Select\n         When svctp1 = '0'\n            Then svctype = 'TYPE 1  '\n         When svctp1 = '8'\n            Then svctype = 'TYPE 2  '\n         When svctp1 = 'C'\n            Then svctype = 'TYPE 3/4'\n         When svctp1 = '2'\n            Then svctype = 'TYPE 6  '\n      Otherwise\n                 svctype = 'TYPE ?  '\n      End\n   svctp2 = SUBSTR(bytes,10,1)\n      svcmisc = '   '\n      If svctp2 = '8'\n         Then Do\n            svcmisc = 'APF'\n            svcapf = svcapf + 1\n         End\n      If svctp2 = '4'\n         Then Do\n            svcmisc = 'ESR'\n            svcesr = svcesr + 1\n         End\n   If inactflag = 0\n      Then Say 'SVC 'RIGHT(i,3,0) '('RIGHT(D2X(i),2,0)')',\n               svctype svcep sloc svcmisc\nEnd\nSay ' '\nSay 'SVCTABLE processing complete ' TIME()\nSay ' '\nSay 'There are 'active 'active standard SVCs on this system.'\nSay 'Among the active SVCs, 'svcapf 'are APF restricted.'\nSay 'There are 'svcesr 'active ESR router SVCs present.'\nSay 'The SVCTABLE contains 'inactive 'inactive slots (IGCERROR).'\nSay '    (IGCERROR nucleus address = 'igcerror')'\nSay ' '\nExit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LISTTAPE": {"ttr": 3588, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0e\\x00\\x05\\x01\\x15\\x02_\\x01\\x15\\x02\\x8f\\x15\\x10\\x00V\\x00V\\x00\\x00\\xc1\\xc3\\xc9\\xc5\\xd9\\xc9@@@@'", "ispf": {"version": "01.14", "flags": 0, "createdate": "2015-01-25T00:00:00", "modifydate": "2015-01-28T15:10:05", "lines": 86, "newlines": 86, "modlines": 0, "user": "ACIERI"}, "text": "        /*REXX*/\n        /*****************************************************************/\n        /*LISTTAPE: REXX program to display all online TAPE devices.     */\n        /*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */\n        /*****************************************************************/\n        /* MVS DATA AREAS:                                               */\n        /*                CVT - Communications Vector Table (@'10'x)     */\n        /*                UCB - Device Unit Control Block                */\n        /*                                                               */\n        /* @ z/OS V2.2 the ULUT has been moved into 64 bit storage.      */\n        /*                                                               */\n        /*****************************************************************/\n        Address TSO ; \"CLEAR\" ; Numeric Digits 20    /* 20 can handle 64 bits */\n        @cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */\n        @cvt = D2X(C2D(@cvt))                    /* binary to dec to hex      */\n        @cvtucba  = STORAGE(D2X(X2D(@cvt)+1252),4)   /* get CVTUCBA address   */\n        @cvtucba  = D2X(C2D(@cvtucba))                 /* binary to dec to hex*/\n        @cvtixav  = STORAGE(D2X(X2D(@cvt)+124),4)      /* get CVTIXAVL addres */\n        @cvtixav  = D2X(C2D(@cvtixav))                       /* binary to hex */\n        @iovtadr  = STORAGE(D2X(X2D(@cvtixav)+208),4)  /* get IOVT address    */\n        @iovtadr  = D2X(C2D(@iovtadr))                       /* binary to hex */\n        @ulutadr  = STORAGE(D2X(X2D(@iovtadr)+8),4)    /* get IOVT address    */\n        @ulutadr  = D2X(C2D(@ulutadr))                       /* binary to hex */\n        if @ulutadr = 0 then                            /* zOS V2.2 or higher */\n          do                                            /* or V2.1/V1.13 w/PTF*/\n           Say 'zOS:'MVSVAR(SYSOPSYS)' Ulut is in 64 bit storage'\n           @ulutadr  = STORAGE(D2X(X2D(@iovtadr)+440),8)  /* get IOVT address */\n           @ulutadr  = D2X(C2D(@ulutadr))                    /* binary to hex */\n          end\n        ulu      = STORAGE(@ulutadr,64)             /* get 64 byte ulu header */\n        uluname  = SUBSTR(ulu,1,4)                         /* ulut eyecatcher */\n        ulutype  = SUBSTR(ulu,5,1)\n        If ulutype = '01'x Then off = 0                    /* ULUT Type 1     */\n        If ulutype = '02'x Then off = 8                    /* ULUT Type 2     */\n        If ulutype = '03'x Then                            /* ULUT Type 3     */\n         Do\n           ulufirst = SUBSTR(ulu,17,8)          /* addr of 1st ULU element(64)*/\n           uluucbno = SUBSTR(ulu,29,4)          /* # of ucb's this I/O config */\n           off = 12\n         End\n        Else\n         Do                                     /* Ulut type 1 or 2           */\n           ulufirst = SUBSTR(ulu,13+off,4)      /* address of 1st ULU element */\n           uluucbno = SUBSTR(ulu,17+off,4)      /* # of ucb's this I/O config */\n         End\n         uluttape = SUBSTR(ulu,21+off,4)        /* # of TAPE UCBs in I/O cfg  */\n         ulutcomm = SUBSTR(ulu,25+off,4)        /* # of COMM UCBs in I/O cfg  */\n         ulutdasd = SUBSTR(ulu,29+off,4)        /* # of DASD UCBs in I/O cfg  */\n         @uluchn  = C2X(ulufirst)\n        Say 'CVT: '@cvt' CVTUCBA: '@cvtucba' ===> TAPE UCB scan started: 'TIME()\n        Say '            CVTIXAV:'@cvtixav' IOVT:'@iovtadr' ULUT: '@ulutadr\n        Say '                                        ULUT Type: 'C2D(ulutype)\n        Say ' '\n        Say '     This I/O configuration has 'C2D(uluttape)' TAPE UCBs defined!'\n        Say ' '\n        @ucbchn = @cvtucba\n        i = 0 ; j = 0\n        Do i = 1 to C2D(uluucbno)               /* scan the ULUT for ALL DASD */\n            uluelmnt = STORAGE(@uluchn,12)       /* get 12 byte ULUT element */\n            uluucbad = SUBSTR(uluelmnt,9,4)     /* 1st ucb this device class */\n            uluucbad = C2X(uluucbad) ; @ucbchn = uluucbad\n           ucb     = STORAGE(@ucbchn,24)    /* get 24 byte ucb common segment */\n           ucbid   = SUBSTR(ucb,3,1)                 /* get the 'FF'x id byte */\n           ucbstat = SUBSTR(ucb,4,1)              /* status byte '80'x online */\n           ucbchan = SUBSTR(ucb,5,2)                /* channel address in hex */\n           ucbnxucb= SUBSTR(ucb,9,4)                   /* pointer to next ucb */\n           ucbtbyt3= SUBSTR(ucb,19,1)                 /* device '80'x is TAPE */\n           ucbtbyt4= SUBSTR(ucb,20,1)           /* contains device type codes */\n           If (BITAND(ucbstat,'80'x)='80'x & BITAND(ucbtbyt3,'80'x)='80'x) Then Do\n              j = j + 1; device = 'Unknown'\n              ioaddr = C2X(ucbchan)\n              If BITAND(ucbtbyt4,'80'x)='80'x Then device = '3480   '\n              If BITAND(ucbtbyt4,'01'x)='01'x Then device = '2400   '\n              If BITAND(ucbtbyt4,'03'x)='03'x Then device = '3420   '\n              If BITAND(ucbtbyt4,'81'x)='81'x Then device = '3490E  '\n              @ucbchn=D2X(X2D(@ucbchn)+24)            /* bump to TAPE segment */\n              ucbtape = STORAGE(@ucbchn,24)       /* get 24 byte TAPE segment */\n              ucbfser = SUBSTR(ucbtape,5,6)              /* volser if mounted */\n              If C2X(ucbfser) = '000000000000' Then ucbfser = '-idle-'\n              Say RIGHT(j,3,' ') RIGHT(ioaddr,3) STRIP(device) ucbfser\n           End\n           @uluchn  = D2X(x2d(@uluchn)+12)\n        End\n        Say ' '\n        Say 'Last UCB after 'i' blocks scanned.  Completed: 'TIME()\n        Exit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LISTVMAP": {"ttr": 3076, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\n\\x00\"\\x01\\x130\\x9f\\x01\\x14\\x05\\x0f\"W\\x00\\x8d\\x00\\x85\\x00\\x00\\xe2\\xc3\\xd5\\xe2\\xf0\\xf3\\xe3@@@'", "ispf": {"version": "01.10", "flags": 0, "createdate": "2013-11-05T00:00:00", "modifydate": "2014-02-19T22:57:22", "lines": 141, "newlines": 133, "modlines": 0, "user": "SCNS03T"}, "text": "/*REXX*/\n/*****************************************************************/\n/*LISTSMAP: REXX program to display key virtual storage points.  */\n/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */\n/*****************************************************************/\n/* MVS DATA AREAS:                                               */\n/*                CVT - Communications Vector Table (@'10'x)     */\n/*                GDA - Global Data Area                         */\n/*                                                               */\n/*****************************************************************/\nnumeric digits 30\n@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */\n@cvt = D2X(C2D(@cvt))                    /* binary to hex             */\n@cvtmz00  = STORAGE(D2X(X2D(@cvt)+164),4)    /* get CVTMZ00 bitstring */\n@cvtmz00  = C2X(@cvtmz00)                    /* character to hex      */\n@cvtreal  = STORAGE(D2X(X2D(@cvt)+284),4)    /* get CVTREAL address   */\n@cvtreal  = D2X(C2D(@cvtreal))                 /* binary to hex       */\n@cvteorm  = STORAGE(D2X(X2D(@cvt)+312),4)    /* get CVTEORM address   */\n@cvteorm  = D2X(C2D(@cvteorm))                 /* binary to hex       */\nAddress TSO ; \"CLEAR\"\nSay 'CVT:'@cvt'      Virtual Storage Map: 'DATE() TIME()\nSay ' '\n@cvtshrvm = STORAGE(D2X(X2D(@cvt)+416),4)    /* get CVTSHRVM address  */\n@cvtshrvm = D2X(C2D(@cvtshrvm))                /* binary to hex       */\n@cvtgda   = STORAGE(D2X(X2D(@cvt)+560),4)    /* get CVTGDA address    */\n@cvtgda   = D2X(C2D(@cvtgda))                  /* binary to hex       */\n@gdacsa   = D2X(X2D(@cvtgda)+108)            /* locate GDACSAstarts   */\n@gdacsa   = D2X(C2D(STORAGE(@gdacsa,4)))       /*  get GDACSA         */\n@gdacsasz = D2X(X2D(@cvtgda)+112)            /* locate GDACSASiZe     */\n@gdacsasz = D2X(C2D(STORAGE(@gdacsasz,4)))     /*  get GDACSASiZe     */\n@gdaecsa  = D2X(X2D(@cvtgda)+124)            /* locate GDAECSAstarts  */\n@gdaecsa  = D2X(C2D(STORAGE(@gdaecsa,4)))      /*  get GDAECSA        */\n@gdaecsas = D2X(X2D(@cvtgda)+128)            /* locate GDAECSASize    */\n@gdaecsas = D2X(C2D(STORAGE(@gdaecsas,4)))     /*  get GDAECSAS       */\n@cvtsmext = STORAGE(D2X(X2D(@cvt)+1196),4)   /* get CVTSMEXT address  */\n@cvtsmext = D2X(C2D(@cvtsmext))                /* binary to hex       */\n@cvtmlpas = D2X(X2D(@cvtsmext)+8)            /* locate CVTMLPAStarts  */\n@cvtmlpas = D2X(C2D(STORAGE(@cvtmlpas,4)))     /*  get CVTMLPAS       */\n@cvtmlpae = D2X(X2D(@cvtsmext)+12)           /* locate CVTMLPAEnds    */\n@cvtmlpae = D2X(C2D(STORAGE(@cvtmlpae,4)))     /*  get CVTMLPAE       */\n@cvtflpas = D2X(X2D(@cvtsmext)+16)           /* locate CVTFLPAStarts  */\n@cvtflpas = D2X(C2D(STORAGE(@cvtflpas,4)))     /*  get CVTFLPAS       */\n@cvtflpae = D2X(X2D(@cvtsmext)+20)           /* locate CVTFLPAEnds    */\n@cvtflpae = D2X(C2D(STORAGE(@cvtflpae,4)))     /*  get CVTFLPAE       */\n@cvtplpas = D2X(X2D(@cvtsmext)+24)           /* locate CVTPLPAStarts  */\n@cvtplpas = D2X(C2D(STORAGE(@cvtplpas,4)))     /*  get CVTPLPAS       */\n@cvtplpae = D2X(X2D(@cvtsmext)+28)           /* locate CVTPLPAEnds    */\n@cvtplpae = D2X(C2D(STORAGE(@cvtplpae,4)))     /*  get CVTPLPAE       */\n@cvtrwns  = D2X(X2D(@cvtsmext)+32)           /* locate CVTRWNStarts   */\n@cvtrwns  = D2X(C2D(STORAGE(@cvtrwns,4)))      /*  get CVTRWNS        */\n@cvtrwne  = D2X(X2D(@cvtsmext)+36)           /* locate CVTRWNEnds     */\n@cvtrwne  = D2X(C2D(STORAGE(@cvtrwne,4)))      /*  get CVTRWNE        */\n@cvtrons  = D2X(X2D(@cvtsmext)+40)           /* locate CVTRONStarts   */\n@cvtrons  = D2X(C2D(STORAGE(@cvtrons,4)))      /*  get CVTRONS        */\n@cvtrone  = D2X(X2D(@cvtsmext)+44)           /* locate CVTRONEnds     */\n@cvtrone  = D2X(C2D(STORAGE(@cvtrone,4)))      /*  get CVTRONE        */\n@cvterwns = D2X(X2D(@cvtsmext)+48)           /* locate CVTERWNStarts  */\n@cvterwns = D2X(C2D(STORAGE(@cvterwns,4)))     /*  get CVTERWNS       */\n@cvterwne = D2X(X2D(@cvtsmext)+52)           /* locate CVTERWNEnds    */\n@cvterwne = D2X(C2D(STORAGE(@cvterwne,4)))     /*  get CVTRRWNE       */\n@cvteplps = D2X(X2D(@cvtsmext)+56)           /* locate CVTEPLPStarts  */\n@cvteplps = D2X(C2D(STORAGE(@cvteplps,4)))     /*  get CVTEPLPS       */\n@cvteplpe = D2X(X2D(@cvtsmext)+60)           /* locate CVTEPLPEnds    */\n@cvteplpe = D2X(C2D(STORAGE(@cvteplpe,4)))     /*  get CVTRPLPE       */\n@cvteflps = D2X(X2D(@cvtsmext)+64)           /* locate CVTEFLPStarts  */\n@cvteflps = D2X(C2D(STORAGE(@cvteflps,4)))     /*  get CVTEFLPS       */\n@cvteflpe = D2X(X2D(@cvtsmext)+68)           /* locate CVTEFLPEnds    */\n@cvteflpe = D2X(C2D(STORAGE(@cvteflpe,4)))     /*  get CVTRFLPE       */\n@cvtemlps = D2X(X2D(@cvtsmext)+72)           /* locate CVTEMLPStarts  */\n@cvtemlps = D2X(C2D(STORAGE(@cvtemlps,4)))     /*  get CVTEMLPS       */\n@cvtemlpe = D2X(X2D(@cvtsmext)+76)           /* locate CVTEMLPEnds    */\n@cvtemlpe = D2X(C2D(STORAGE(@cvtemlpe,4)))     /*  get CVTRMLPE       */\n/*  simplify variable names & calculate some boundaries   */\n/*\n@csa1   = @cvtshrvm  ; @csa2  = D2X(X2D(@cvtmlpas)-1)         /* csa  */\n */\n@csa1g  = @gdacsa    ; @csa2g = D2X(X2D(@gdacsasz)+X2D(@gdacsa)-1)/* g*/\n@mlpa1  = @cvtmlpas  ; @mlpa2 = @cvtmlpae                     /* mlpa */\n@flpa1  = @cvtflpas  ; @flpa2 = @cvtflpae                     /* flpa */\n@plpa1  = @cvtplpas  ; @plpa2 = @cvtplpae                     /* plpa */\n@sqa1   = D2X(X2D(@cvtplpae)+1) ; @sqa2 = D2X(X2D(@cvtrwns)-1)/* sqa  */\n@nuc1   = @cvtrwns   ; @nuc2  = @cvterwne                     /* nuc  */\n@esqa1  = D2X(X2D(@nuc2)+1) ; @esqa2 = D2X(X2D(@cvteplps)-1)  /* esqa */\n@eplpa1 = @cvteplps  ; @eplpa2 = @cvteplpe                    /* eplpa*/\n@eflpa1 = @cvteflps  ; @eflpa2 = @cvteflpe                    /* eflpa*/\n@emlpa1 = @cvtemlps  ; @emlpa2 = @cvtemlpe                    /* emlpa*/\n@ecsa1g = @gdaecsa   ; @ecsa2g= D2X(X2D(@gdaecsas)+X2D(@gdaecsa)-1)/*g*/\n/*\ncsas    = (X2D(@csa2)-X2D(@csa1)+1)/1024     /* size of csa   KB    */\n */\ncsasg   =  X2D(@gdacsasz)/1024               /* size of csag  KB    */\nmlpas   = (X2D(@mlpa2)-X2D(@mlpa1)+1)/1024   /* size of mlpa  KB    */\nflpas   = (X2D(@flpa2)-X2D(@flpa1)+1)/1024   /* size of flpa  KB    */\nplpas   = (X2D(@plpa2)-X2D(@plpa1)+1)/1024   /* size of plpa  KB    */\nsqas    = (X2D(@sqa2)-X2D(@sqa1)+1)/1024     /* size of sqa   KB    */\nnucs    = (X2D(@nuc2)-X2D(@nuc1)+1)/1024     /* size of nuc   KB    */\nesqas   = (X2D(@esqa2)-X2D(@esqa1)+1)/1024   /* size of esqa  KB    */\neplpas  = (X2D(@eplpa2)-X2D(@eplpa1)+1)/1024 /* size of eplpa KB    */\neflpas  = (X2D(@eflpa2)-X2D(@eflpa1)+1)/1024 /* size of eflpa KB    */\nemlpas  = (X2D(@emlpa2)-X2D(@emlpa1)+1)/1024 /* size of emlpa KB    */\necsasg  =  X2D(@gdaecsas)/1024               /* size of ecsag KB    */\n@eprivs = D2X(X2D(@ecsa2g)+1)                        /* ext private */\n@eprive = 21\nepriv   = (@eprive-X2D(@eprivs)+1)/1048576 /* size of epriv MB    */\n@psas   = D2X(0) ; psa = 4 ; @psae = D2X(4095) /* psa fixed by arch */\n/*\n@prive  = D2X(X2D(@csa1)-1) ; @privs = D2X(X2D(@psae)+1) /* private */\npriv    = (X2D(@prive)-X2D(@privs)+1)/1024   /* size of ALL private */\n@privsas= @privs ; privsa = 16                  /* sa fixed by arch */\n@privsae= D2X(X2D(@privsas)+((privsa*1024)-1)) /* calc private part */\n@privvrs= D2X(X2D(@privsae)+1)  /* adj priv start above system area */\n@privvre= D2X(X2D(@cvtreal)-1)                   /* calc end of V=R */\nprivvr  = (X2D(@privvre)-X2D(@privvrs)+1)/1024       /* size of V=R */\n */\n@privvvs= @privvrs              /* adj priv start above system area */\n@privvve= @prive                               /* assign end of V=V */\n/*\nprivvv  = (X2D(@privvve)-X2D(@privvvs)+1)/1024       /* size of V=V */\n */\nSay '    ------- COMPONENT -------   -SIZE-  --ADDRESS RANGE--'\nSay ' '\nSay '    EPrivate                    'Right(epriv,5)'M  'RIGHT(@eprivs,8,0)'-'RIGHT(@cvtmz00,8,0)\nSay '    ECSA                        'Right(ecsasg,5)'K  'RIGHT(@ecsa1g,8,0)'-'RIGHT(@ecsa2g,8,0)\nSay '    EMLPA                       'Right(emlpas,5)'K  'RIGHT(@emlpa1,8,0)'-'RIGHT(@emlpa2,8,0)\nSay '    EFLPA                       'RIGHT(eflpas,5)'K  'RIGHT(@eflpa1,8,0)'-'RIGHT(@eflpa2,8,0)\nSay '    EPLPA                       'RIGHT(eplpas,5)'K  'RIGHT(@eplpa1,8,0)'-'RIGHT(@eplpa2,8,0)\nSay '    ESQA                        'RIGHT(esqas,5)'K  'RIGHT(@esqa1,8,0)'-'RIGHT(@esqa2,8,0)\nSay '    MVS NUCLEUS                 'RIGHT(nucs,5)'K  'RIGHT(@nuc1,8,0)'-'RIGHT(@nuc2,8,0)\nSay '    SQA                         'RIGHT(sqas,5)'K  'RIGHT(@sqa1,8,0)'-'RIGHT(@sqa2,8,0)\nSay '    PLPA                        'RIGHT(plpas,5)'K  'RIGHT(@plpa1,8,0)'-'RIGHT(@plpa2,8,0)\nSay '    FLPA                        'RIGHT(flpas,5)'K  'RIGHT(@flpa1,8,0)'-'RIGHT(@flpa2,8,0)\nSay '    MLPA                        'RIGHT(mlpas,5)'K  'RIGHT(@mlpa1,8,0)'-'RIGHT(@mlpa2,8,0)\nSay '  * CSA                         'RIGHT(csasg,5)'K  'RIGHT(@csa1g,8,0)'-'RIGHT(@csa2g,8,0)\nSay '    Private (V=V)               'RIGHT(privvv,5)'K  'RIGHT(@privvvs,8,0)'-'RIGHT(@privvve,8,0)\nSay '            (V=R)               'RIGHT(privvr,5)'K  'RIGHT(@privvrs,8,0)'-'RIGHT(@privvre,8,0)\nSay '            (System)            'RIGHT(privsa,5)'K  'RIGHT(@privsas,8,0)'-'RIGHT(@privsae,8,0)\nSay '    PSA                         'RIGHT(psa,5)'K  'RIGHT(@psas,8,0)'-'RIGHT(@psae,8,0)\nSay ' '\ncsatol2 = csasg//1024 ; csatol1 = 1024 - csatol2\nSay '  * CSA Segment Tolerance ===> Upper:'csatol1'K  Lower:'csatol2'K'\nExit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "NOT@OR": {"ttr": 524, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x12\\x00\\x94\\x08\\x8f\\x00\\x94\\x08\\x8f\\x10\\x00\\x00\\x02\\x00\\x02\\x00\\x00\\xc3\\xd6\\xd5\\xe8\\xc5\\xd9\\xe2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-03-29T00:00:00", "modifydate": "1994-03-29T10:00:12", "lines": 2, "newlines": 2, "modlines": 0, "user": "CONYERS"}, "text": "  \u00ac  IBM EBCDIC 'not' character is '5F'x                                al\n  |  IBM EBCDIC 'or'  character is '4F'x                                al\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "OLDSTUFF": {"ttr": 778, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x1b\\x00P\\x01\\x14\\x04\\x9f\\x01\\x14\\x04\\x9f#R\\x11&\\x11\\x13\\x00\\x00\\xe7\\xc1`\\xf2K\\xf2@@@@'", "ispf": {"version": "02.27", "flags": 0, "createdate": "2014-02-18T00:00:00", "modifydate": "2014-02-18T23:52:50", "lines": 4390, "newlines": 4371, "modlines": 0, "user": "XA-2.2"}, "text": "./ ADD LIST=ALL,NAME=$$$$$$$$\nThis member was created using the UNUPDTE program from CBT File 093.\nThe UNUPDTE program was necessary because this file is RECFM=VB\nand LRECL=255.  Use the PDSLOAD program from File 093 to create a PDS\nfrom this member, or else, edit the piece that you want, and copy\nit out to a separate pds member.\n\nSample JCL:\n\n//SBGOLOBA  JOB (ACCT#),S-GOLOB,\n// NOTIFY=&SYSUID,\n// CLASS=B,MSGCLASS=X\n//*                                            Source <= CBT FILE 093\n//LOAD EXEC PGM=PDSLOAD                        Load   <= CBT FILE 035\n//STEPLIB  DD DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//SYSPRINT DD SYSOUT=*\n//SYSUT1  DD  DISP=SHR,DSN=SBGOLOB.CBT488.FILE221(OLDSTUFF)\n//SYSUT2  DD  DISP=SHR,DSN=SBGOLOB.FILE221.OLDSTUFF   <= VB-255\n\n./ ADD LIST=ALL,NAME=$$$DOC01\nThis file (221) goes together with File 220 from Lee Conyers.\n\nThis file (221) contains REXX execs to perform many EDP auditing\n\"snooping\" functions.  This material will be useful for systems\nprogrammers as well.  The material was tested on an MVS/XA 2.2.3\nsystem.  Some of it also runs on MVS/ESA 4.3, but not all of it.\n\nIf you can fix any of this material for higher versions of the MVS\noperating system, please submit your material to Sam Golob, at his\naddress as listed on File 001 of this tape.\n\n      Lee Conyers\n      U.S. Department of Transportation\n      700 4th Street SW\n      Room 7404, M-35\n      Washington, DC  20590\n      (202) 366-1126\n\n./ ADD LIST=ALL,NAME=#NUCLKUP\n/*REXX*/\n/*****************************************************************/\n/*#NUCLKUP: REXX external procedure to scan nucleus map.         */\n/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */\n/*****************************************************************/\n/* MVS DATA AREAS:                                               */\n/*                CVT - Communications Vector Table (@'10'x)     */\n/*              NUCMP - Nucleus Map Table (16 bytes by n rows)   */\n/*****************************************************************/\nArg target\nNumeric Digits 10\n@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */\n@cvt = D2X(C2D(@cvt))                    /* binary to hex             */\n@cvtnucmp = STORAGE(D2X(X2D(@cvt)+1200),4)   /* get CVTNUCMP address  */\n@cvtnucmp = D2X(C2D(@cvtnucmp))                /* binary to hex       */\nnucmapid  = STORAGE(@cvtnucmp,8)           /* nucmap eyecatcher entry */\nnucmeot   = C2D(STORAGE(D2X(X2D(@cvtnucmp)+8),4))  /* table end addrs */\nnucmlen   = C2D(STORAGE(D2X(X2D(@cvtnucmp)+13),3)) /* nucm tbl length */\n@nucmentry= X2D(@cvtnucmp)+16          /* address of 1st nucmap entry */\nepaddr = 'FFFFFFFF'                  /* initialize with invalid value */\nIf nucmapid \\= 'NUCMAP  ' Then Do\n   Say 'Error: Nucleus map table eyecatcher not found'\n   Exit\n   End\ni = 0   /* target = 'IGCERROR' */\nDo While @nucmentry <= nucmeot                  /* loop thru storage  */\n   i = i + 1\n   epname   = STORAGE(D2X(@nucmentry),8)      /* get entry point name */\n   If epname = target Then Do\n      epaddr = C2X(STORAGE(D2X(@nucmentry+8),4))    /* get ep address */\n      epflag = STORAGE(D2X(@nucmentry+12),1)     /* get raw flag byte */\n      eplen  = C2X(STORAGE(D2X(@nucmentry+13),3))    /* get ep length */\n      Leave\n      End\n   @nucmentry = @nucmentry + 16                 /* bump to next entry */\nEnd\nReturn epaddr\n./ ADD LIST=ALL,NAME=IOAPFP\n/*REXX*/\n/*****************************************************************/\n/*  IOAPFP: REXX program to create APF programs database.        */\n/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */\n/*****************************************************************/\n/* MVS DATA AREAS:                                               */\n/*                CVT - Communications Vector Table (@'10'x)     */\n/*             APFTAB - Undocumented in MVS DATA AREAS book.     */\n/*                                                               */\n/*                                                               */\n/*                                                               */\n/*****************************************************************/\n@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */\n@cvt = D2X(C2D(@cvt))                    /* binary to hex             */\n@cvtauthl = STORAGE(D2X(X2D(@cvt)+484),4)   /* get CVTAUTHL address   */\n@cvtauthl = D2X(C2D(@cvtauthl))                /* binary to hex       */\napfcount  = C2D(STORAGE(D2X(X2D(@cvtauthl)+1),1)) /* APF libraries    */\napfllen   = C2D(STORAGE(D2X(X2D(@cvtauthl)+2),1)) /* length 1st entry */\n@apfentry = X2D(@cvtauthl)+3          /* address of 1st APF entry     */\nSay 'The CVT  is located at '@cvt '('X2D(@cvt)')'\nSay 'The CVTAUTHL field points to '@cvtauthl '('X2D(@cvtauthl)')'\nSay 'The APF table contains 'apfcount 'entries, as follows:'\nSay ' '\nlpadsn = 'NO'                /* SYS1.LPALIB is APF during NIP and not */\nlpares = '  '                 /* normally in the APF table.  If it is */\n                                 /* then must test for sysres volume. */\nDo i = 1 to apfcount                            /* loop thru storage  */\n   apflib.i = STORAGE(D2X(@apfentry),apfllen)   /* get the APF entry  */\n   @apfentry = @apfentry + apfllen + 1          /* bump to next entry */\n   apfllen = C2D(STORAGE(D2X(@apfentry-1),1))      /* length of next  */\n   If i = 1 Then resvol = SUBSTR(apflib.i,1,6)       /* retain resvol */\n   If SUBSTR(apflib.i,7) = 'SYS1.LPALIB' Then Do  /* check for LPALIB */\n      lpadsn = 'YES' ; lpares = 'NO'\n      If SUBSTR(apflib.i,1,6) = resvol Then lpares = 'YES'\n      End\nEnd\n/***************************************************************/\n/* The in-storage APF table has been fetched, now print it     */\n/***************************************************************/\nSay 'VOLSER --------------DATA SET NAME-----------------'\nSay ' '\nDo i = 1 To apfcount                            /* print the list     */\n   Say SUBSTR(apflib.i,1,6) SUBSTR(apflib.i,7,44,' ') i\nEnd\n/***************************************************************/\n/* Save the APF table to a data set                            */\n/***************************************************************/\nAddress TSO\ndsn1 = 'MS01.CONYERS.APFLIST.DATA.WORK'\n\"ALLOC F(APFLIST) DA('\"dsn1\"') OLD RELEASE\"\nIf RC \\= 0 Then Do\n   Say 'IOAPFP failed on 'dsn1' error: 'RC\n   Exit\n   End\nNewstack\nDo i = apfcount To 1 By -1                      /* write the list */\n   Push ' 'SUBSTR(apflib.i,1,6) SUBSTR(apflib.i,7,44,' ') i\nEnd\nPush ' APFCOUNT: 'RIGHT(apfcount,4,0)'   Date: 'DATE()'   Time: 'TIME()\nQueue\n'EXECIO * DISKW APFLIST ( FINIS'\nDelstack\nSay ' '\nSay 'Saved APF table to DASD'\nSay 'DSN: 'dsn1\nSay 'Return Code: 'RC\n\"FREE F(APFLIST)\"\nSay ' '\n/***************************************************************/\n/* Now process the directory blocks of each APF library        */\n/*   and save the member data to a data set.  Note that        */\n/*   when we dynamically allocate each PDS, we are defining    */\n/*   DCB parameters to enable reading the directory blocks.    */\n/***************************************************************/\ndsn2 = 'MS01.CONYERS.APFPGMS.DATA.WORK'\n\"ALLOC F(APFPGMS) DA('\"dsn2\"') OLD RELEASE\"\nIf RC \\= 0 Then Do\n   Say 'IOAPFP failed on 'dsn2' error: 'RC\n   Exit\n   End\n/***************************************************************/\n/*   Add SYS1.LPALIB on sysres if not in APF list.             */\n/***************************************************************/\nIf lpadsn = 'NO' | (lpadsn = 'YES' & lpares \\= 'YES') Then Do\n   Say '*** SYS1.LPALIB on sysres appended to list for programs analysis.'\n   Say '         Reason:  lpadsn='lpadsn'  lpares='lpares\n   Say '    Explanation:  SYS1.LPALIB on the sysres volume is APF'\n   Say '                    authorized by MVS design during IPL.  It'\n   Say '                    is added to the APF list for authorized'\n   Say '                    programs analysis if not already contained'\n   Say '                    in the APF table.  If a SYS1.LPALIB is on'\n   Say '                    the APF table, a check is made for its'\n   Say '                    volser.  If not the sysres volume, it is'\n   Say '                    added to the APF list accordingly for the'\n   Say '                    authorized programs analysis.'\n   Say ' '\n   apfcount = apfcount + 1\n   apflib.apfcount = resvol'SYS1.LPALIB'\n   End\ntotpgms = 0\nSay 'Beginning APF library contents analysis'\nSay '===> note any TSO allocation error messages for skipped libraries'\nSay ' '\nDo i = 1 To apfcount                            /* cycle the list */\n   dsn = STRIP(SUBSTR(apflib.i,7,44))\n   vol = STRIP(SUBSTR(apflib.i,1,6))\nSay ' '\n   Say RIGHT(i,3,0)'  Processing 'dsn' on 'vol'  Mark: 'DATE() TIME()\n   \"ALLOC F(PDS) DA('\"dsn\"') VOL(\"vol\") SHR DSORG(PS) RECFM(F) LRECL(256) BLKSIZE(256)\"\n   RC1 = RC\n   'EXECIO * DISKR PDS ( FINIS STEM line.'\n   RC2 = RC\n   \"FREE F(PDS)\"\n   Say '       *** ALLOC RC: 'RC1'  EXECIO RC: 'RC2\n   If RC2 = 0 Then Do\n      Say '       *** Directory blocks read: 'line.0\n      Newstack\n      last = 0  /* flags when no more members indicator is detected */\n      memcount = 0\n      Do j = 1 To line.0\n         blocklen = X2D(C2X(SUBSTR(line.j,1,2))) /* Not proud of this logic, */\n         If blocklen = 0 or last = 1 Then Leave /* but seems to work --vlc  */\n         ix = 3                          /* Initialize DIRBLOCK parse index */\n         Do While ix < blocklen & last \\= 1          /* parse this DIRBLOCK */\n            pds2ftb1 = '00'x                         /* initialize apf not  */\n            pds2mnm  = '        '                    /* initialize alias of */\n            pds2name = SUBSTR(line.j,ix,8) ; ix = ix + 8    /* main section */\n            pds2ttrp = SUBSTR(line.j,ix,3) ; ix = ix + 3\n            pds2indc = SUBSTR(line.j,ix,1) ; ix = ix + 1\n            udl = 0                           /* calculate user data length */\n            If BITAND(pds2indc,'01'x) = '01'x Then udl = 1\n            If BITAND(pds2indc,'02'x) = '02'x Then udl = udl + 2\n            If BITAND(pds2indc,'04'x) = '04'x Then udl = udl + 4\n            If BITAND(pds2indc,'08'x) = '08'x Then udl = udl + 8\n            If BITAND(pds2indc,'10'x) = '10'x Then udl = udl + 16\n            udl = udl * 2                 /* finish calc halfwords to bytes */\n            If udl >= 22 & last \\= 1 Then Do   /* only process likely stuff */\n               ix = ix + 8             /* adjust index to skip misc 8 bytes */\n               pds2atr1 = SUBSTR(line.j,ix,1) ; ix = ix + 1\n               pds2atr2 = SUBSTR(line.j,ix,1) ; ix = ix + 1\n               pds2stor = SUBSTR(line.j,ix,3) ; ix = ix + 3\n               ix = ix + 2             /* adjust index to skip misc 2 bytes */\n               pds2epa  = SUBSTR(line.j,ix,3) ; ix = ix + 3\n               pds2ftb1 = SUBSTR(line.j,ix,1) ; ix = ix + 1\n               ix = ix + 2             /* adjust index to skip misc 2 bytes */\n                                                            /* scatter sect */\n               If BITAND(pds2atr1,'04'x) = '04'x Then Do\n                  pds2scat = SUBSTR(line.j,ix+33,8)\n                  ix = ix + 8\n                  End\n                                                              /* alias sect */\n               If BITAND(pds2indc,'80'x) = '80'x Then Do\n                  If udl >= 32 Then Do\n                     pds2epm  = SUBSTR(line.j,ix,3) ; ix = ix + 3\n                     pds2mnm  = SUBSTR(line.j,ix,8) ; ix = ix + 8\n                     End\n                  Else Do\n                     Say '*** WARNING - Missing major for alias 'pds2name' DBLK:'i\n                     pds2epm = '000000'x\n                     pds2mnm = '????????'\n                     End\n                  End\n                                                             /* ssi section */\n               If BITAND(pds2ftb1,'10'x) = '10'x Then Do\n                  If (ix-1)//2 \\= 0 Then ix = ix + 1    /* halfword alignmt */\n                  pdsssiwd = SUBSTR(line.j,ix,4) ; ix = ix + 4\n                  End\n                                                             /* apf section */\n               If BITAND(pds2ftb1,'08'x) \\= '08'x Then pdsapfac = ' '/* none*/\n               Else Do                                         /* maybe apf */\n                  pdsapfct = SUBSTR(line.j,ix,1)\n                  If pdsapfct = '01'x Then Do                /* NORMAL path */\n                     ix = ix + 1\n                     pdsapfac = SUBSTR(line.j,ix,1)\n                     ix = ix + 1\n                     If pdsapfac \\= '00'x & pdsapfac \\= '01'x Then Do\n                        Say '*** WARNING - Invalid AC for 'pds2name' DBLK:'i\n                        nop\n                        End\n                     End\n                  If pdsapfct \\= '01'x & (BITAND(pds2indc,'80'x)='80'x) Then Do\n                     pdsapfac=' '\n                     ix = ix - 8\n                     Say '*** WARNING - Compacted alias logic for 'pds2name' DBLK:'i\n                     End\n                  End\n               End\n            Else Do                              /* too short udl, leave it */\n               ix = ix + udl\n               If pds2name = 'FFFFFFFFFFFFFFFF'x Then Do\n                  last = 1\n                  Leave\n                  End\n               Say '*** WARNING - too short udl for 'pds2name' DBLK:'i\n               pds2atr1 = '00'x\n               pds2atr2 = '00'x\n               pds2stor = '000000'x\n               pds2mnm  = '        '\n               pdsapfac = ' '\n               End\n            If (ix-1)//2 \\= 0 Then ix = ix + 1          /* halfword alignmt */\n            If pds2name = 'FFFFFFFFFFFFFFFF'x Then Do\n               last = 1\n               Leave\n               End\n            If pds2name \\= '0000000000000000'x Then Do\n               memcount = memcount + 1\n               Push ' 'LEFT(dsn,44,' ')' 'LEFT(vol,6,' '),\n                    ' 'pds2name' TTR:'C2X(pds2ttrp),\n                    ' INDC:'C2X(pds2indc)' ATRBs:'C2X(pds2atr1),\n                    C2X(pds2atr2)' SIZE:'C2X(pds2stor),\n                    ' MAJ:'pds2mnm' AC:'C2X(pdsapfac),\n                    ' DBLK:'RIGHT(i,4,0)' UDL:'RIGHT(udl,2,0),\n                    ' IX:'RIGHT(ix,3,0)\n               End\n         End                                         /* DIRBLOCK parse done */\n      End\n      Say '       *** Directory blocks processed: 'j-1'  Members: 'memcount\n      Queue\n      'EXECIO * DISKW APFPGMS (      '\n      Delstack\n      totpgms = totpgms + memcount\n   End\nEnd\nNewstack\nQueue\n'EXECIO * DISKW APFPGMS ( FINIS'\nDelstack\nSay ' '\nSay 'Saved 'totpgms' APF program descriptor records to DASD'\nSay 'DSN: 'dsn2\nSay 'Return Code: 'RC\n\"FREE F(APFPGMS)\"\nExit\n./ ADD LIST=ALL,NAME=IOESRT\n/*REXX*/\n/*****************************************************************/\n/*  IOESRT: REXX program to create router SVC database.          */\n/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */\n/*****************************************************************/\n/* MVS DATA AREAS:                                               */\n/*                CVT - Communications Vector Table (@'10'x)     */\n/*               SCVT - Supervisor Call Vector Table             */\n/*                                                               */\n/*                                                               */\n/*****************************************************************/\n/*--------------virtual storage map definition section----------------*/\nNumeric Digits 10           /* required to handle decimal conversions */\n@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */\n@cvt = D2X(C2D(@cvt))                    /* binary to hex             */\n@cvtreal  = STORAGE(D2X(X2D(@cvt)+284),4)    /* get CVTREAL address   */\n@cvtreal  = D2X(C2D(@cvtreal))                 /* binary to hex       */\n@cvtshrvm = STORAGE(D2X(X2D(@cvt)+416),4)    /* get CVTSHRVM address  */\n@cvtshrvm = D2X(C2D(@cvtshrvm))                /* binary to hex       */\n@cvtgda   = STORAGE(D2X(X2D(@cvt)+560),4)    /* get CVTGDA address    */\n@cvtgda   = D2X(C2D(@cvtgda))                  /* binary to hex       */\n@gdacsa   = D2X(X2D(@cvtgda)+108)            /* locate GDACSAstarts   */\n@gdacsa   = D2X(C2D(STORAGE(@gdacsa,4)))       /*  get GDACSA         */\n@gdacsasz = D2X(X2D(@cvtgda)+112)            /* locate GDACSASiZe     */\n@gdacsasz = D2X(C2D(STORAGE(@gdacsasz,4)))     /*  get GDACSASiZe     */\n@gdaecsa  = D2X(X2D(@cvtgda)+124)            /* locate GDAECSAstarts  */\n@gdaecsa  = D2X(C2D(STORAGE(@gdaecsa,4)))      /*  get GDAECSA        */\n@gdaecsas = D2X(X2D(@cvtgda)+128)            /* locate GDAECSASize    */\n@gdaecsas = D2X(C2D(STORAGE(@gdaecsas,4)))     /*  get GDAECSAS       */\n@cvtsmext = STORAGE(D2X(X2D(@cvt)+1196),4)   /* get CVTSMEXT address  */\n@cvtsmext = D2X(C2D(@cvtsmext))                /* binary to hex       */\n@cvtmlpas = D2X(X2D(@cvtsmext)+8)            /* locate CVTMLPAStarts  */\n@cvtmlpas = D2X(C2D(STORAGE(@cvtmlpas,4)))     /*  get CVTMLPAS       */\n@cvtmlpae = D2X(X2D(@cvtsmext)+12)           /* locate CVTMLPAEnds    */\n@cvtmlpae = D2X(C2D(STORAGE(@cvtmlpae,4)))     /*  get CVTMLPAE       */\n@cvtflpas = D2X(X2D(@cvtsmext)+16)           /* locate CVTFLPAStarts  */\n@cvtflpas = D2X(C2D(STORAGE(@cvtflpas,4)))     /*  get CVTFLPAS       */\n@cvtflpae = D2X(X2D(@cvtsmext)+20)           /* locate CVTFLPAEnds    */\n@cvtflpae = D2X(C2D(STORAGE(@cvtflpae,4)))     /*  get CVTFLPAE       */\n@cvtplpas = D2X(X2D(@cvtsmext)+24)           /* locate CVTPLPAStarts  */\n@cvtplpas = D2X(C2D(STORAGE(@cvtplpas,4)))     /*  get CVTPLPAS       */\n@cvtplpae = D2X(X2D(@cvtsmext)+28)           /* locate CVTPLPAEnds    */\n@cvtplpae = D2X(C2D(STORAGE(@cvtplpae,4)))     /*  get CVTPLPAE       */\n@cvtrwns  = D2X(X2D(@cvtsmext)+32)           /* locate CVTRWNStarts   */\n@cvtrwns  = D2X(C2D(STORAGE(@cvtrwns,4)))      /*  get CVTRWNS        */\n@cvtrwne  = D2X(X2D(@cvtsmext)+36)           /* locate CVTRWNEnds     */\n@cvtrwne  = D2X(C2D(STORAGE(@cvtrwne,4)))      /*  get CVTRWNE        */\n@cvtrons  = D2X(X2D(@cvtsmext)+40)           /* locate CVTRONStarts   */\n@cvtrons  = D2X(C2D(STORAGE(@cvtrons,4)))      /*  get CVTRONS        */\n@cvtrone  = D2X(X2D(@cvtsmext)+44)           /* locate CVTRONEnds     */\n@cvtrone  = D2X(C2D(STORAGE(@cvtrone,4)))      /*  get CVTRONE        */\n@cvterwns = D2X(X2D(@cvtsmext)+48)           /* locate CVTERWNStarts  */\n@cvterwns = D2X(C2D(STORAGE(@cvterwns,4)))     /*  get CVTERWNS       */\n@cvterwne = D2X(X2D(@cvtsmext)+52)           /* locate CVTERWNEnds    */\n@cvterwne = D2X(C2D(STORAGE(@cvterwne,4)))     /*  get CVTRRWNE       */\n@cvteplps = D2X(X2D(@cvtsmext)+56)           /* locate CVTEPLPStarts  */\n@cvteplps = D2X(C2D(STORAGE(@cvteplps,4)))     /*  get CVTEPLPS       */\n@cvteplpe = D2X(X2D(@cvtsmext)+60)           /* locate CVTEPLPEnds    */\n@cvteplpe = D2X(C2D(STORAGE(@cvteplpe,4)))     /*  get CVTRPLPE       */\n@cvteflps = D2X(X2D(@cvtsmext)+64)           /* locate CVTEFLPStarts  */\n@cvteflps = D2X(C2D(STORAGE(@cvteflps,4)))     /*  get CVTEFLPS       */\n@cvteflpe = D2X(X2D(@cvtsmext)+68)           /* locate CVTEFLPEnds    */\n@cvteflpe = D2X(C2D(STORAGE(@cvteflpe,4)))     /*  get CVTRFLPE       */\n@cvtemlps = D2X(X2D(@cvtsmext)+72)           /* locate CVTEMLPStarts  */\n@cvtemlps = D2X(C2D(STORAGE(@cvtemlps,4)))     /*  get CVTEMLPS       */\n@cvtemlpe = D2X(X2D(@cvtsmext)+76)           /* locate CVTEMLPEnds    */\n@cvtemlpe = D2X(C2D(STORAGE(@cvtemlpe,4)))     /*  get CVTRMLPE       */\n        /*------simplify variable names & make addresses decimal------*/\n@csa1g  = @gdacsa    ; @csa2g = D2X(X2D(@gdacsasz)+X2D(@gdacsa)-1)/* g*/\n   csa1 = X2D(@csa1g) ; csa2 = X2D(@csa2g)                    /* csa  */\n@mlpa1  = @cvtmlpas  ; @mlpa2 = @cvtmlpae                     /* mlpa */\n   mlpa1 = X2D(@mlpa1) ; mlpa2 = X2D(@mlpa2)\n@flpa1  = @cvtflpas  ; @flpa2 = @cvtflpae                     /* flpa */\n   flpa1 = X2D(@flpa1) ; flpa2 = X2D(@flpa2)\n@plpa1  = @cvtplpas  ; @plpa2 = @cvtplpae                     /* plpa */\n   plpa1 = X2D(@plpa1) ; plpa2 = X2D(@plpa2)\n@sqa1   = D2X(X2D(@cvtplpae)+1) ; @sqa2 = D2X(X2D(@cvtrwns)-1)/* sqa  */\n   sqa1 = X2D(@sqa1) ; sqa2 = X2D(@sqa2)\n@nuc1   = @cvtrwns   ; @nuc2  = @cvterwne                     /* nuc  */\n   nuc1 = X2D(@nuc1) ; nuc2 = X2D(@nuc2)\n@esqa1  = D2X(X2D(@nuc2)+1) ; @esqa2 = D2X(X2D(@cvteplps)-1)  /* esqa */\n  esqa1 = X2D(@esqa1) ; esqa2 = X2D(@esqa2)\n@eplpa1 = @cvteplps  ; @eplpa2 = @cvteplpe                    /* eplpa*/\n eplpa1 = X2D(@eplpa1) ; eplpa2 = X2D(@eplpa2)\n@eflpa1 = @cvteflps  ; @eflpa2 = @cvteflpe                    /* eflpa*/\n eflpa1 = X2D(@eflpa1) ; eflpa2 = X2D(@eflpa2)\n@emlpa1 = @cvtemlps  ; @emlpa2 = @cvtemlpe                    /* emlpa*/\n emlpa1 = X2D(@emlpa1) ; emlpa2 = X2D(@emlpa2)\n@ecsa1g = @gdaecsa   ; @ecsa2g= D2X(X2D(@gdaecsas)+X2D(@gdaecsa)-1)/*g*/\n  ecsa1 = X2D(@ecsa1g) ; ecsa2 = X2D(@ecsa2g)\n@eprivs = X2D(@ecsa2g)+1                               /* ext private */\n@eprive = 2147483647                         /* fixed by architecture */\n epriv1 = @eprivs ; epriv2 = @eprive\n@psas   = 0 ; @psae = 4095                       /* psa fixed by arch */\n   psa1 = @psas ; psa2 = @psae\n@prive  = X2D(@csa1g)-1 ; @privs = X2D(@psae)+1            /* private */\n  priv1 = @privs ; priv2 = @prive\n              /*------------------------------------------------------*/\n             /* Usage Notes: Hex character compares are incompatible */\n            /*    for storage residency determination.  Thus, entry */\n           /*     point addresses must be converted to decimal and */\n          /*      VS boundary addresses must be converted to de-  */\n         /*       cimal for correct compare operations.          */\n        /*------------------------------------------------------*/\n/*----------end of virtual storage map definition section-------------*/\n@cvtabend = STORAGE(D2X(X2D(@cvt)+200),4)    /* get CVTABEND address  */\n@cvtabend = D2X(C2D(@cvtabend))                /* binary to hex       */\n@scvtsvct = D2X(X2D(@cvtabend)+132)          /* SCVT addressibility   */\n@scvtsvct = STORAGE(@scvtsvct,4)                  /* SVCT table       */\n@scvtsvct = D2X(C2D(@scvtsvct))                /* binary to hex       */\nAddress TSO ; \"CLEAR\"\nSay 'CVT:'@cvt' CVTABEND:'@cvtabend' SCVTSVCT:'@scvtsvct' 'DATE() TIME()\nSay ' '\ndsn = 'MVS.ESR.ESRTABLE'\nNewstack\nactive = 0 ; inactive = 0 ; esrsvc = 0\nmodule = 'IGXERROR' ; Call \"#NUCLKUP\" module ; igxerror = Result\nd = Date() ; t = Time()\nDo i = 0 to 255                                 /* loop thru storage  */\n   bytes = STORAGE(D2X(X2D(@scvtsvct)+(i*8)),8)\n   bytes = C2X(bytes)\n   svcep  = SUBSTR(bytes,1,8)\n   svctp2 = SUBSTR(bytes,10,1)\n   If svctp2 = '4'            /* EP address is an ESR table */\n      Then Do\n         esrid = STORAGE(svcep,4)                 /* table eyecatcher */\n         esrct = C2X(STORAGE(D2X(X2D(svcep)+4),4))       /* esr count */\n         Say 'SVC 'i' is 'esrid'.  Table at 'svcep', Slots 'X2D(esrct)' ('esrct')'\n         Say ' '\n         esrsvc = 0\n         Do j = 0 to X2D(esrct)                   /* process this ESR */\n            bytes = STORAGE(D2X(X2D(svcep)+(j*8)+8),8)\n   addr = SUBSTR(bytes,1,4)       /* sloppy code to grap EP in binary */\n   bytes = C2X(bytes)          /* legacy code before learning bit ops */\n            esrep  = SUBSTR(bytes,1,8)\n                                        /* determine storage location */\n   addr = BITAND(addr,'7FFFFFFF'x)        /* shave off amode bit (32) */\n   addr = C2D(addr)                      /* make numeric for compares */\n   sloc = 'ERROR'                       /* determine module residency */\n   If (addr >= csa1   & addr <= csa2  ) Then sloc = 'CSA  '\n      Else If (addr >= mlpa1  & addr <= mlpa2 ) Then sloc = 'MLPA '\n      Else If (addr >= flpa1  & addr <= flpa2 ) Then sloc = 'FLPA '\n      Else If (addr >= plpa1  & addr <= plpa2 ) Then sloc = 'PLPA '\n      Else If (addr >= sqa1   & addr <= sqa2  ) Then sloc = 'SQA  '\n      Else If (addr >= nuc1   & addr <= nuc2  ) Then sloc = 'NUC  '\n      Else If (addr >= esqa1  & addr <= esqa2 ) Then sloc = 'ESQA '\n      Else If (addr >= eplpa1 & addr <= eplpa2) Then sloc = 'EPLPA'\n      Else If (addr >= eflpa1 & addr <= eflpa2) Then sloc = 'EFLPA'\n      Else If (addr >= emlpa1 & addr <= emlpa2) Then sloc = 'EMLPA'\n      Else If (addr >= ecsa1  & addr <= ecsa2 ) Then sloc = 'ECSA '\n      Else If (addr >= epriv1 & addr <= epriv2) Then sloc = 'EPRIV'\n      Else If (addr >= priv1  & addr <= priv2 ) Then sloc = 'PRIV '\n      Else If (addr >= psa1   & addr <= psa2  ) Then sloc = 'PSA  '\n            esrtp2 = SUBSTR(bytes,10,1)\n            esrmisc = '   '\n            If esrtp2 = '8'\n               Then esrmisc = 'APF'\n            inactflag = 0\n            If igxerror = Right(D2X(addr),8,0) /* normalize address */\n               Then inactflag = 1\n               Else Do\n                       active = active + 1\n                       esrsvc = esrsvc + 1\n                    End\n            esrtp1 = SUBSTR(bytes,9,1)\n               Select\n                  When esrtp1 = '0'\n                     Then esrtype = 'TYPE 1  '\n                  When esrtp1 = '8'\n                     Then esrtype = 'TYPE 2  '\n                  When esrtp1 = 'C'\n                     Then esrtype = 'TYPE 3/4'\n                  When esrtp1 = '2'\n                     Then esrtype = 'TYPE 6  '\n               Otherwise\n                          esrtype = 'TYPE ?  '\n               End\n            If inactflag = 0\n               Then Push ' 'LEFT(dsn,44,' '),\n                         'ESR'RIGHT(j,3,0) '('RIGHT(D2X(j),2,0)')',\n                         'SVC'RIGHT(i,3,0) '('RIGHT(D2X(i),2,0)')',\n                          esrtype esrep sloc esrmisc d t\n         End\n         Say '     Total ESR SVCs this table 'esrsvc\n         Say ' '\n      End\nEnd\nSay 'This system contains 'active' ESR SVCs'\nSay ' '\nSay '  (IGXERROR nucleus address = 'igxerror')'\nSay ' '\nSay 'ESRTABLE processing complete ' Time()\nSay ' '\n/***************************************************************/\n/* Now save the stack to our ESR data set                      */\n/***************************************************************/\ndsn2 = 'MS01.CONYERS.ESRS.DATA.WORK'\n\"ALLOC F(ESRS) DA('\"dsn2\"') OLD RELEASE\"\nIf RC \\= 0 Then Do\n   Say 'IOESRT failed on 'dsn2' error: 'RC\n   Exit\n   End\nQueue\n'EXECIO * DISKW ESRS ( FINIS'\nDelstack\nSay ' '\nSay 'Saved 'active' ESR SVC descriptor records to DASD'\nSay 'DSN: 'dsn2\nSay 'Return Code: 'RC\n\"FREE F(ESRS)\"\nExit\n./ ADD LIST=ALL,NAME=IOLLTP\n/*REXX*/\n/*****************************************************************/\n/*  IOLLTP: REXX program to create LLT programs database.        */\n/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */\n/*****************************************************************/\n/*                CVT - Communications Vector Table (@'10'x)     */\n/*                LLT - Linklist Lookaside Table                 */\n/*               DCB3 - Data Control Block (BDAM)                */\n/*                DEB - IOS Data Extent Block                    */\n/*                                                               */\n/*****************************************************************/\n@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */\n@cvt = D2X(C2D(@cvt))                    /* binary to hex             */\n@cvtlink  = STORAGE(D2X(X2D(@cvt)+8),4)      /* get CVTLINK address   */\n@cvtlink  = D2X(C2D(@cvtlink))                 /* binary to hex       */\n@dcbdebad = STORAGE(D2X(X2D(@cvtlink)+44),4)    /* LINKLIB DCB to DEB */\n@dcbdebad = D2X(C2D(@dcbdebad))                 /* convert to hex     */\ndebflgs1  = STORAGE(D2X(X2D(@dcbdebad)+14),1)     /* LINKLIB DEBflags */\n   debapfin = 'LNKLST'\n   If BITAND(debflgs1,'02'x)\\='02'x Then debapfin = 'APFTAB'\n@cvtllta  = STORAGE(D2X(X2D(@cvt)+1244),4)   /* get CVTLLTA address   */\n@cvtllta  = D2X(C2D(@cvtllta))                 /* binary to hex       */\nlltcount  = C2D(STORAGE(D2X(X2D(@cvtllta)+7),1))  /* LLT libraries    */\nlltllen   = C2D(STORAGE(D2X(X2D(@cvtllta)+8),1))  /* length 1st entry */\n@lltentry = X2D(@cvtllta)+9           /* address of 1st LLT entry     */\nAddress TSO ; \"CLEAR\"\nSay 'CVT:'@cvt' CVTLLTA:'@cvtllta' DCB:'@cvtlink,\n    'DEB:'@dcbdebad' FLGS1:'C2X(debflgs1)' LNKAUTH='debapfin\nSay ' '\nSay 'LLT scan on 'DATE()' started: 'TIME()\nSay ' '\nDo i = 1 to lltcount                            /* loop thru storage  */\n   lltlib.i = STORAGE(D2X(@lltentry),lltllen)   /* get the LLT entry  */\n   @lltentry = @lltentry + 45                   /* bump to next entry */\n   lltllen = C2D(STORAGE(D2X(@lltentry-1),1))   /* length of next  */\nEnd\nSay '--------------DATA SET NAME-----------------'\nSay ' '\nDo i = 1 to lltcount                            /* print the list     */\n   Say SUBSTR(lltlib.i,1,44,' ') i\nEnd\nSay ' '\nSay 'LLT scan completed: 'TIME()\n/***************************************************************/\n/* Save the LINKLIST table to a data set                       */\n/***************************************************************/\nAddress TSO\ndsn1 = 'MS01.CONYERS.LLTLIST.DATA.WORK'\n\"ALLOC F(LLTLIST) DA('\"dsn1\"') OLD RELEASE\"\nIf RC \\= 0 Then Do\n   Say 'IOLLTP failed on 'dsn1' error: 'RC\n   Exit\n   End\nNewstack\nDo i = lltcount To 1 By -1                      /* write the list */\n   Push ' 'SUBSTR(lltlib.i,1,44,' ') i\nEnd\nPush ' LLTCOUNT: 'RIGHT(lltcount,4,0)'   Date: 'DATE()'   Time: 'TIME()\nPush 'CVT:'@cvt' CVTLLTA:'@cvtllta' DCB:'@cvtlink,\n    'DEB:'@dcbdebad' FLGS1:'C2X(debflgs1)' LNKAUTH='debapfin\nQueue\n'EXECIO * DISKW LLTLIST ( FINIS'\nDelstack\nSay ' '\nSay 'Saved LINKLIST table to DASD'\nSay 'DSN: 'dsn1\nSay 'Return Code: 'RC\n\"FREE F(LLTLIST)\"\nSay ' '\n/***************************************************************/\n/* Now process the directory blocks of each LLT library        */\n/*   and save the member data to a data set.  Note that        */\n/*   when we dynamically allocate each PDS, we are defining    */\n/*   DCB parameters to enable reading the directory blocks.    */\n/***************************************************************/\ndsn2 = 'MS01.CONYERS.LLTPGMS.DATA.WORK'\n\"ALLOC F(LLTPGMS) DA('\"dsn2\"') OLD RELEASE\"\nIf RC \\= 0 Then Do\n   Say 'IOLLTP failed on 'dsn2' error: 'RC\n   Exit\n   End\ntotpgms = 0\nSay 'Beginning LINKLIST library contents analysis'\nSay '===> note any TSO allocation error messages for skipped libraries'\nSay ' '\nDo i = 1 To lltcount                                /* cycle the list */\n   dsn = STRIP(SUBSTR(lltlib.i,1,44))\nSay ' '\n   Say RIGHT(i,3,0)'  Processing 'dsn'   Mark: 'DATE() TIME()\n   \"ALLOC F(PDS) DA('\"dsn\"') SHR DSORG(PS) RECFM(F) LRECL(256) BLKSIZE(256)\"\n   RC1 = RC\n   'EXECIO * DISKR PDS ( FINIS STEM line.'\n   RC2 = RC\n   \"FREE F(PDS)\"\n   Say '       *** ALLOC RC: 'RC1'  EXECIO RC: 'RC2\n   If RC2 = 0 Then Do\n      Say '       *** Directory blocks read: 'line.0\n      Newstack\n      last = 0  /* flags when no more members indicator is detected */\n      memcount = 0\n      Do j = 1 To line.0\n         blocklen = X2D(C2X(SUBSTR(line.j,1,2))) /* Not proud of this logic, */\n         If blocklen = 0 or last = 1 Then Leave /* but seems to work --vlc  */\n         ix = 3                          /* Initialize DIRBLOCK parse index */\n         Do While ix < blocklen & last \\= 1          /* parse this DIRBLOCK */\n            pds2ftb1 = '00'x                         /* initialize apf not  */\n            pds2mnm  = '        '                    /* initialize alias of */\n            pds2name = SUBSTR(line.j,ix,8) ; ix = ix + 8    /* main section */\n            pds2ttrp = SUBSTR(line.j,ix,3) ; ix = ix + 3\n            pds2indc = SUBSTR(line.j,ix,1) ; ix = ix + 1\n            udl = 0                           /* calculate user data length */\n            If BITAND(pds2indc,'01'x) = '01'x Then udl = 1\n            If BITAND(pds2indc,'02'x) = '02'x Then udl = udl + 2\n            If BITAND(pds2indc,'04'x) = '04'x Then udl = udl + 4\n            If BITAND(pds2indc,'08'x) = '08'x Then udl = udl + 8\n            If BITAND(pds2indc,'10'x) = '10'x Then udl = udl + 16\n            udl = udl * 2                 /* finish calc halfwords to bytes */\n            If udl >= 22 & last \\= 1 Then Do   /* only process likely stuff */\n               ix = ix + 8             /* adjust index to skip misc 8 bytes */\n               pds2atr1 = SUBSTR(line.j,ix,1) ; ix = ix + 1\n               pds2atr2 = SUBSTR(line.j,ix,1) ; ix = ix + 1\n               pds2stor = SUBSTR(line.j,ix,3) ; ix = ix + 3\n               ix = ix + 2             /* adjust index to skip misc 2 bytes */\n               pds2epa  = SUBSTR(line.j,ix,3) ; ix = ix + 3\n               pds2ftb1 = SUBSTR(line.j,ix,1) ; ix = ix + 1\n               ix = ix + 2             /* adjust index to skip misc 2 bytes */\n                                                            /* scatter sect */\n               If BITAND(pds2atr1,'04'x) = '04'x Then Do\n                  pds2scat = SUBSTR(line.j,ix+33,8)\n                  ix = ix + 8\n                  End\n                                                              /* alias sect */\n               If BITAND(pds2indc,'80'x) = '80'x Then Do\n                  If udl >= 32 Then Do\n                     pds2epm  = SUBSTR(line.j,ix,3) ; ix = ix + 3\n                     pds2mnm  = SUBSTR(line.j,ix,8) ; ix = ix + 8\n                     End\n                  Else Do\n                     Say '*** WARNING - Missing major for alias 'pds2name' DBLK:'i\n                     pds2epm = '000000'x\n                     pds2mnm = '????????'\n                     End\n                  End\n                                                             /* ssi section */\n               If BITAND(pds2ftb1,'10'x) = '10'x Then Do\n                  If (ix-1)//2 \\= 0 Then ix = ix + 1    /* halfword alignmt */\n                  pdsssiwd = SUBSTR(line.j,ix,4) ; ix = ix + 4\n                  End\n                                                             /* apf section */\n               If BITAND(pds2ftb1,'08'x) \\= '08'x Then pdsapfac = ' '/* none*/\n               Else Do                                         /* maybe apf */\n                  pdsapfct = SUBSTR(line.j,ix,1)\n                  If pdsapfct = '01'x Then Do                /* NORMAL path */\n                     ix = ix + 1\n                     pdsapfac = SUBSTR(line.j,ix,1)\n                     ix = ix + 1\n                     If pdsapfac \\= '00'x & pdsapfac \\= '01'x Then Do\n                        Say '*** WARNING - Invalid AC for 'pds2name' DBLK:'i\n                        nop\n                        End\n                     End\n                  If pdsapfct \\= '01'x & (BITAND(pds2indc,'80'x)='80'x) Then Do\n                     pdsapfac=' '\n                     ix = ix - 8\n                     Say '*** WARNING - Compacted alias logic for 'pds2name' DBLK:'i\n                     End\n                  End\n               End\n            Else Do                              /* too short udl, leave it */\n               ix = ix + udl\n               If pds2name = 'FFFFFFFFFFFFFFFF'x Then Do\n                  last = 1\n                  Leave\n                  End\n               Say '*** WARNING - too short udl for 'pds2name' DBLK:'i\n               pds2atr1 = '00'x\n               pds2atr2 = '00'x\n               pds2stor = '000000'x\n               pds2mnm  = '        '\n               pdsapfac = ' '\n               End\n            If (ix-1)//2 \\= 0 Then ix = ix + 1          /* halfword alignmt */\n            If pds2name = 'FFFFFFFFFFFFFFFF'x Then Do\n               last = 1\n               Leave\n               End\n            If pds2name \\= '0000000000000000'x Then Do\n               memcount = memcount + 1\n               Push ' 'LEFT(dsn,44,' ')' 'RIGHT(i,3,0),\n                    ' 'pds2name' TTR:'C2X(pds2ttrp),\n                    ' INDC:'C2X(pds2indc)' ATRBs:'C2X(pds2atr1),\n                    C2X(pds2atr2)' SIZE:'C2X(pds2stor),\n                    ' MAJ:'pds2mnm' AC:'C2X(pdsapfac),\n                    ' DBLK:'RIGHT(i,4,0)' UDL:'RIGHT(udl,2,0),\n                    ' IX:'RIGHT(ix,3,0)\n               End\n         End                                         /* DIRBLOCK parse done */\n      End\n      Say '       *** Directory blocks processed: 'j-1'  Members: 'memcount\n      Queue\n      'EXECIO * DISKW LLTPGMS (      '\n      Delstack\n      totpgms = totpgms + memcount\n   End\nEnd\nNewstack\nQueue\n'EXECIO * DISKW LLTPGMS ( FINIS'\nDelstack\nSay ' '\nSay 'Saved 'totpgms' LINKLIST program descriptor records to DASD'\nSay 'DSN: 'dsn2\nSay 'Return Code: 'RC\n\"FREE F(LLTPGMS)\"\nExit\n./ ADD LIST=ALL,NAME=IOLPAP\n/*REXX*/\n/*****************************************************************/\n/*  IOLPAP: REXX program to create LPAT programs database.       */\n/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */\n/*****************************************************************/\n/*                CVT - Communications Vector Table (@'10'x)     */\n/*               LPAT - Link Pack Area (libraries) Table         */\n/*                                                               */\n/*****************************************************************/\n@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */\n@cvt = D2X(C2D(@cvt))                    /* binary to hex             */\n@cvtsmext = STORAGE(D2X(X2D(@cvt)+1196),4)   /* get CVTSMEXT address  */\n@cvtsmext = D2X(C2D(@cvtsmext))                /* binary to hex       */\n@cvteplps = D2X(X2D(@cvtsmext)+56)           /* get CVTEPLPS address  */\n@cvteplps = STORAGE(@cvteplps,4)             /* get LPAT address      */\n@cvteplps = D2X(C2D(@cvteplps))                /* binary to hex       */\nlpatcount = C2D(STORAGE(D2X(X2D(@cvteplps)+4),4)) /* LPAT entries     */\nlpatlen   = C2D(STORAGE(D2X(X2D(@cvteplps)+8),1)) /* length 1st entry */\n@lpatentry= X2D(@cvteplps)+9          /* address of 1st LPAT entry    */\nSay 'CVT:'@cvt  'CVTSMEXT:'@cvtsmext'  CVTEPLPS:'@cvteplps,\n    '  'DATE() TIME()\nSay ' '\nSay 'The LPAT table contains 'lpatcount 'entries, as follows:'\nSay ' '\nDo i = 1 to lpatcount                           /* loop thru storage  */\n   lpatlib.i = STORAGE(D2X(@lpatentry),lpatlen) /* get the LPAT entry */\n   @lpatentry = @lpatentry + 45                 /* bump to next entry */\n   lpatlen = C2D(STORAGE(D2X(@lpatentry-1),1))  /* length of next     */\nEnd\nSay '--------------DATA SET NAME-----------------'\nSay ' '\nDo i = 1 to lpatcount                           /* print the list     */\n   Say SUBSTR(lpatlib.i,1,44,' ') i\nEnd\n/***************************************************************/\n/* Save the LINK PACK AREA table list to a data set            */\n/***************************************************************/\nAddress TSO\ndsn1 = 'MS01.CONYERS.LPALIST.DATA.WORK'\n\"ALLOC F(LPALIST) DA('\"dsn1\"') OLD RELEASE\"\nIf RC \\= 0 Then Do\n   Say 'IOLPAP failed on 'dsn1' error: 'RC\n   Exit\n   End\nNewstack\nDo i = lpatcount To 1 By -1                        /* write the list */\n   Push ' 'SUBSTR(lpatlib.i,1,44,' ') i\nEnd\nPush ' LPACOUNT: 'RIGHT(lpatcount,4,0)'   Date: 'DATE()'  Time: 'TIME()\nPush 'CVT:'@cvt' CVTSMEXT:'@cvtsmext' CVTEPLPS:'@cvteplps\nQueue\n'EXECIO * DISKW LPALIST ( FINIS'\nDelstack\nSay ' '\nSay 'Saved LINKLIST table to DASD'\nSay 'DSN: 'dsn1\nSay 'Return Code: 'RC\n\"FREE F(LPALIST)\"\nSay ' '\n/***************************************************************/\n/* Now process the directory blocks of each LPA library        */\n/*   and save the member data to a data set.  Note that        */\n/*   when we dynamically allocate each PDS, we are defining    */\n/*   DCB parameters to enable reading the directory blocks.    */\n/***************************************************************/\ndsn2 = 'MS01.CONYERS.LPAPGMS.DATA.WORK'\n\"ALLOC F(LPAPGMS) DA('\"dsn2\"') OLD RELEASE\"\nIf RC \\= 0 Then Do\n   Say 'IOLPAP failed on 'dsn2' error: 'RC\n   Exit\n   End\ntotpgms = 0\nSay 'Beginning LINK PACK AREA library contents analysis'\nSay '===> note any TSO allocation error messages for skipped libraries'\nSay ' '\nDo i = 1 To lpatcount                               /* cycle the list */\n   dsn = STRIP(SUBSTR(lpatlib.i,1,44))\nSay ' '\n   Say RIGHT(i,3,0)'  Processing 'dsn'   Mark: 'DATE() TIME()\n   \"ALLOC F(PDS) DA('\"dsn\"') SHR DSORG(PS) RECFM(F) LRECL(256) BLKSIZE(256)\"\n   RC1 = RC\n   'EXECIO * DISKR PDS ( FINIS STEM line.'\n   RC2 = RC\n   \"FREE F(PDS)\"\n   Say '       *** ALLOC RC: 'RC1'  EXECIO RC: 'RC2\n   If RC2 = 0 Then Do\n      Say '       *** Directory blocks read: 'line.0\n      Newstack\n      last = 0  /* flags when no more members indicator is detected */\n      memcount = 0\n      Do j = 1 To line.0\n         blocklen = X2D(C2X(SUBSTR(line.j,1,2))) /* Not proud of this logic, */\n         If blocklen = 0 or last = 1 Then Leave /* but seems to work --vlc  */\n         ix = 3                          /* Initialize DIRBLOCK parse index */\n         Do While ix < blocklen & last \\= 1          /* parse this DIRBLOCK */\n            pds2ftb1 = '00'x                         /* initialize apf not  */\n            pds2mnm  = '        '                    /* initialize alias of */\n            pds2name = SUBSTR(line.j,ix,8) ; ix = ix + 8    /* main section */\n            pds2ttrp = SUBSTR(line.j,ix,3) ; ix = ix + 3\n            pds2indc = SUBSTR(line.j,ix,1) ; ix = ix + 1\n            udl = 0                           /* calculate user data length */\n            If BITAND(pds2indc,'01'x) = '01'x Then udl = 1\n            If BITAND(pds2indc,'02'x) = '02'x Then udl = udl + 2\n            If BITAND(pds2indc,'04'x) = '04'x Then udl = udl + 4\n            If BITAND(pds2indc,'08'x) = '08'x Then udl = udl + 8\n            If BITAND(pds2indc,'10'x) = '10'x Then udl = udl + 16\n            udl = udl * 2                 /* finish calc halfwords to bytes */\n            If udl >= 22 & last \\= 1 Then Do   /* only process likely stuff */\n               ix = ix + 8             /* adjust index to skip misc 8 bytes */\n               pds2atr1 = SUBSTR(line.j,ix,1) ; ix = ix + 1\n               pds2atr2 = SUBSTR(line.j,ix,1) ; ix = ix + 1\n               pds2stor = SUBSTR(line.j,ix,3) ; ix = ix + 3\n               ix = ix + 2             /* adjust index to skip misc 2 bytes */\n               pds2epa  = SUBSTR(line.j,ix,3) ; ix = ix + 3\n               pds2ftb1 = SUBSTR(line.j,ix,1) ; ix = ix + 1\n               ix = ix + 2             /* adjust index to skip misc 2 bytes */\n                                                            /* scatter sect */\n               If BITAND(pds2atr1,'04'x) = '04'x Then Do\n                  pds2scat = SUBSTR(line.j,ix+33,8)\n                  ix = ix + 8\n                  End\n                                                              /* alias sect */\n               If BITAND(pds2indc,'80'x) = '80'x Then Do\n                  If udl >= 32 Then Do\n                     pds2epm  = SUBSTR(line.j,ix,3) ; ix = ix + 3\n                     pds2mnm  = SUBSTR(line.j,ix,8) ; ix = ix + 8\n                     End\n                  Else Do\n                     Say '*** WARNING - Missing major for alias 'pds2name' DBLK:'i\n                     pds2epm = '000000'x\n                     pds2mnm = '????????'\n                     End\n                  End\n                                                             /* ssi section */\n               If BITAND(pds2ftb1,'10'x) = '10'x Then Do\n                  If (ix-1)//2 \\= 0 Then ix = ix + 1    /* halfword alignmt */\n                  pdsssiwd = SUBSTR(line.j,ix,4) ; ix = ix + 4\n                  End\n                                                             /* apf section */\n               If BITAND(pds2ftb1,'08'x) \\= '08'x Then pdsapfac = ' '/* none*/\n               Else Do                                         /* maybe apf */\n                  pdsapfct = SUBSTR(line.j,ix,1)\n                  If pdsapfct = '01'x Then Do                /* NORMAL path */\n                     ix = ix + 1\n                     pdsapfac = SUBSTR(line.j,ix,1)\n                     ix = ix + 1\n                     If pdsapfac \\= '00'x & pdsapfac \\= '01'x Then Do\n                        Say '*** WARNING - Invalid AC for 'pds2name' DBLK:'i\n                        nop\n                        End\n                     End\n                  If pdsapfct \\= '01'x & (BITAND(pds2indc,'80'x)='80'x) Then Do\n                     pdsapfac=' '\n                     ix = ix - 8\n                     Say '*** WARNING - Compacted alias logic for 'pds2name' DBLK:'i\n                     End\n                  End\n               End\n            Else Do                              /* too short udl, leave it */\n               ix = ix + udl\n               If pds2name = 'FFFFFFFFFFFFFFFF'x Then Do\n                  last = 1\n                  Leave\n                  End\n               Say '*** WARNING - too short udl for 'pds2name' DBLK:'i\n               pds2atr1 = '00'x\n               pds2atr2 = '00'x\n               pds2stor = '000000'x\n               pds2mnm  = '        '\n               pdsapfac = ' '\n               End\n            If (ix-1)//2 \\= 0 Then ix = ix + 1          /* halfword alignmt */\n            If pds2name = 'FFFFFFFFFFFFFFFF'x Then Do\n               last = 1\n               Leave\n               End\n            If pds2name \\= '0000000000000000'x Then Do\n               memcount = memcount + 1\n               Push ' 'LEFT(dsn,44,' ')' 'RIGHT(i,3,0),\n                    ' 'pds2name' TTR:'C2X(pds2ttrp),\n                    ' INDC:'C2X(pds2indc)' ATRBs:'C2X(pds2atr1),\n                    C2X(pds2atr2)' SIZE:'C2X(pds2stor),\n                    ' MAJ:'pds2mnm' AC:'C2X(pdsapfac),\n                    ' DBLK:'RIGHT(i,4,0)' UDL:'RIGHT(udl,2,0),\n                    ' IX:'RIGHT(ix,3,0)\n               End\n         End                                         /* DIRBLOCK parse done */\n      End\n      Say '       *** Directory blocks processed: 'j-1'  Members: 'memcount\n      Queue\n      'EXECIO * DISKW LPAPGMS (      '\n      Delstack\n      totpgms = totpgms + memcount\n   End\nEnd\nNewstack\nQueue\n'EXECIO * DISKW LPAPGMS ( FINIS'\nDelstack\nSay ' '\nSay 'Saved 'totpgms' PLPA program descriptor records to DASD'\nSay 'DSN: 'dsn2\nSay 'Return Code: 'RC\n\"FREE F(LPAPGMS)\"\nExit\n./ ADD LIST=ALL,NAME=IOLPAQ\n/*REXX*/\n/*****************************************************************/\n/*  IOLPAQ: REXX program to create LPAQ programs database.       */\n/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */\n/*****************************************************************/\n/* MVS DATA AREAS:                                               */\n/*                CVT - Communications Vector Table (@'10'x)     */\n/*                GDA - Global Data Area                         */\n/*               LPAQ - Link Pack Area Queue                     */\n/*                CDE - Contents Directory Entry                 */\n/*                                                               */\n/*****************************************************************/\n/*--------------virtual storage map definition section----------------*/\nNumeric Digits 10           /* required to handle decimal conversions */\n@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */\n@cvt = D2X(C2D(@cvt))                    /* binary to hex             */\n@cvtreal  = STORAGE(D2X(X2D(@cvt)+284),4)    /* get CVTREAL address   */\n@cvtreal  = D2X(C2D(@cvtreal))                 /* binary to hex       */\n@cvtshrvm = STORAGE(D2X(X2D(@cvt)+416),4)    /* get CVTSHRVM address  */\n@cvtshrvm = D2X(C2D(@cvtshrvm))                /* binary to hex       */\n@cvtgda   = STORAGE(D2X(X2D(@cvt)+560),4)    /* get CVTGDA address    */\n@cvtgda   = D2X(C2D(@cvtgda))                  /* binary to hex       */\n@gdacsa   = D2X(X2D(@cvtgda)+108)            /* locate GDACSAstarts   */\n@gdacsa   = D2X(C2D(STORAGE(@gdacsa,4)))       /*  get GDACSA         */\n@gdacsasz = D2X(X2D(@cvtgda)+112)            /* locate GDACSASiZe     */\n@gdacsasz = D2X(C2D(STORAGE(@gdacsasz,4)))     /*  get GDACSASiZe     */\n@gdaecsa  = D2X(X2D(@cvtgda)+124)            /* locate GDAECSAstarts  */\n@gdaecsa  = D2X(C2D(STORAGE(@gdaecsa,4)))      /*  get GDAECSA        */\n@gdaecsas = D2X(X2D(@cvtgda)+128)            /* locate GDAECSASize    */\n@gdaecsas = D2X(C2D(STORAGE(@gdaecsas,4)))     /*  get GDAECSAS       */\n@cvtsmext = STORAGE(D2X(X2D(@cvt)+1196),4)   /* get CVTSMEXT address  */\n@cvtsmext = D2X(C2D(@cvtsmext))                /* binary to hex       */\n@cvtmlpas = D2X(X2D(@cvtsmext)+8)            /* locate CVTMLPAStarts  */\n@cvtmlpas = D2X(C2D(STORAGE(@cvtmlpas,4)))     /*  get CVTMLPAS       */\n@cvtmlpae = D2X(X2D(@cvtsmext)+12)           /* locate CVTMLPAEnds    */\n@cvtmlpae = D2X(C2D(STORAGE(@cvtmlpae,4)))     /*  get CVTMLPAE       */\n@cvtflpas = D2X(X2D(@cvtsmext)+16)           /* locate CVTFLPAStarts  */\n@cvtflpas = D2X(C2D(STORAGE(@cvtflpas,4)))     /*  get CVTFLPAS       */\n@cvtflpae = D2X(X2D(@cvtsmext)+20)           /* locate CVTFLPAEnds    */\n@cvtflpae = D2X(C2D(STORAGE(@cvtflpae,4)))     /*  get CVTFLPAE       */\n@cvtplpas = D2X(X2D(@cvtsmext)+24)           /* locate CVTPLPAStarts  */\n@cvtplpas = D2X(C2D(STORAGE(@cvtplpas,4)))     /*  get CVTPLPAS       */\n@cvtplpae = D2X(X2D(@cvtsmext)+28)           /* locate CVTPLPAEnds    */\n@cvtplpae = D2X(C2D(STORAGE(@cvtplpae,4)))     /*  get CVTPLPAE       */\n@cvtrwns  = D2X(X2D(@cvtsmext)+32)           /* locate CVTRWNStarts   */\n@cvtrwns  = D2X(C2D(STORAGE(@cvtrwns,4)))      /*  get CVTRWNS        */\n@cvtrwne  = D2X(X2D(@cvtsmext)+36)           /* locate CVTRWNEnds     */\n@cvtrwne  = D2X(C2D(STORAGE(@cvtrwne,4)))      /*  get CVTRWNE        */\n@cvtrons  = D2X(X2D(@cvtsmext)+40)           /* locate CVTRONStarts   */\n@cvtrons  = D2X(C2D(STORAGE(@cvtrons,4)))      /*  get CVTRONS        */\n@cvtrone  = D2X(X2D(@cvtsmext)+44)           /* locate CVTRONEnds     */\n@cvtrone  = D2X(C2D(STORAGE(@cvtrone,4)))      /*  get CVTRONE        */\n@cvterwns = D2X(X2D(@cvtsmext)+48)           /* locate CVTERWNStarts  */\n@cvterwns = D2X(C2D(STORAGE(@cvterwns,4)))     /*  get CVTERWNS       */\n@cvterwne = D2X(X2D(@cvtsmext)+52)           /* locate CVTERWNEnds    */\n@cvterwne = D2X(C2D(STORAGE(@cvterwne,4)))     /*  get CVTRRWNE       */\n@cvteplps = D2X(X2D(@cvtsmext)+56)           /* locate CVTEPLPStarts  */\n@cvteplps = D2X(C2D(STORAGE(@cvteplps,4)))     /*  get CVTEPLPS       */\n@cvteplpe = D2X(X2D(@cvtsmext)+60)           /* locate CVTEPLPEnds    */\n@cvteplpe = D2X(C2D(STORAGE(@cvteplpe,4)))     /*  get CVTRPLPE       */\n@cvteflps = D2X(X2D(@cvtsmext)+64)           /* locate CVTEFLPStarts  */\n@cvteflps = D2X(C2D(STORAGE(@cvteflps,4)))     /*  get CVTEFLPS       */\n@cvteflpe = D2X(X2D(@cvtsmext)+68)           /* locate CVTEFLPEnds    */\n@cvteflpe = D2X(C2D(STORAGE(@cvteflpe,4)))     /*  get CVTRFLPE       */\n@cvtemlps = D2X(X2D(@cvtsmext)+72)           /* locate CVTEMLPStarts  */\n@cvtemlps = D2X(C2D(STORAGE(@cvtemlps,4)))     /*  get CVTEMLPS       */\n@cvtemlpe = D2X(X2D(@cvtsmext)+76)           /* locate CVTEMLPEnds    */\n@cvtemlpe = D2X(C2D(STORAGE(@cvtemlpe,4)))     /*  get CVTRMLPE       */\n        /*------simplify variable names & make addresses decimal------*/\n@csa1g  = @gdacsa    ; @csa2g = D2X(X2D(@gdacsasz)+X2D(@gdacsa)-1)/* g*/\n   csa1 = X2D(@csa1g) ; csa2 = X2D(@csa2g)                    /* csa  */\n@mlpa1  = @cvtmlpas  ; @mlpa2 = @cvtmlpae                     /* mlpa */\n   mlpa1 = X2D(@mlpa1) ; mlpa2 = X2D(@mlpa2)\n@flpa1  = @cvtflpas  ; @flpa2 = @cvtflpae                     /* flpa */\n   flpa1 = X2D(@flpa1) ; flpa2 = X2D(@flpa2)\n@plpa1  = @cvtplpas  ; @plpa2 = @cvtplpae                     /* plpa */\n   plpa1 = X2D(@plpa1) ; plpa2 = X2D(@plpa2)\n@sqa1   = D2X(X2D(@cvtplpae)+1) ; @sqa2 = D2X(X2D(@cvtrwns)-1)/* sqa  */\n   sqa1 = X2D(@sqa1) ; sqa2 = X2D(@sqa2)\n@nuc1   = @cvtrwns   ; @nuc2  = @cvterwne                     /* nuc  */\n   nuc1 = X2D(@nuc1) ; nuc2 = X2D(@nuc2)\n@esqa1  = D2X(X2D(@nuc2)+1) ; @esqa2 = D2X(X2D(@cvteplps)-1)  /* esqa */\n  esqa1 = X2D(@esqa1) ; esqa2 = X2D(@esqa2)\n@eplpa1 = @cvteplps  ; @eplpa2 = @cvteplpe                    /* eplpa*/\n eplpa1 = X2D(@eplpa1) ; eplpa2 = X2D(@eplpa2)\n@eflpa1 = @cvteflps  ; @eflpa2 = @cvteflpe                    /* eflpa*/\n eflpa1 = X2D(@eflpa1) ; eflpa2 = X2D(@eflpa2)\n@emlpa1 = @cvtemlps  ; @emlpa2 = @cvtemlpe                    /* emlpa*/\n emlpa1 = X2D(@emlpa1) ; emlpa2 = X2D(@emlpa2)\n@ecsa1g = @gdaecsa   ; @ecsa2g= D2X(X2D(@gdaecsas)+X2D(@gdaecsa)-1)/*g*/\n  ecsa1 = X2D(@ecsa1g) ; ecsa2 = X2D(@ecsa2g)\n@eprivs = X2D(@ecsa2g)+1                               /* ext private */\n@eprive = 2147483647                         /* fixed by architecture */\n epriv1 = @eprivs ; epriv2 = @eprive\n@psas   = 0 ; @psae = 4095                       /* psa fixed by arch */\n   psa1 = @psas ; psa2 = @psae\n@prive  = X2D(@csa1g)-1 ; @privs = X2D(@psae)+1            /* private */\n  priv1 = @privs ; priv2 = @prive\n              /*------------------------------------------------------*/\n             /* Usage Notes: Hex character compares are incompatible */\n            /*    for storage residency determination.  Thus, entry */\n           /*     point addresses must be converted to decimal and */\n          /*      VS boundary addresses must be converted to de-  */\n         /*       cimal for correct compare operations.          */\n        /*------------------------------------------------------*/\n/*----------end of virtual storage map definition section-------------*/\n@cvtqlpaq = STORAGE(D2X(X2D(@cvt)+188),4)    /* get CVTqlpaq address  */\n@cvtqlpaq = D2X(C2D(@cvtqlpaq))                /* binary to hex       */\n@lpaqptr  = STORAGE(@cvtqlpaq,4)             /* get pointer to LPAQ   */\n@lpaqptr  = D2X(C2D(@lpaqptr))                 /* binary to hex       */\nAddress TSO ; \"CLEAR\"\nSay 'CVT:'@cvt' CVTQLPAQ:'@cvtqlpaq' LPAQPTR:'@lpaqptr' 'DATE() TIME()\n@cdechn = @lpaqptr\nSay ' '\ndsn = 'MVS.LPAQ.CDECHAIN'           /* assign a pseudo data set name */\ni = 0 ; d = Date() ; t = Time()\nNewstack\nDo While @cdechn \\= '00000000'\n   i = i + 1\n   cde = STORAGE(@cdechn,32)                          /* get the cde */\n   cdname = SUBSTR(cde,9,8)\n   cdentpt= SUBSTR(cde,17,4)\n                                        /* determine storage location */\n   addr = BITAND(cdentpt,'7FFFFFFF'x)     /* shave off amode bit (32) */\n   addr = C2D(addr)                      /* make numeric for compares */\n   sloc = 'ERROR'                       /* determine module residency */\n   If (addr >= csa1   & addr <= csa2  ) Then sloc = 'CSA  '\n      Else If (addr >= mlpa1  & addr <= mlpa2 ) Then sloc = 'MLPA '\n      Else If (addr >= flpa1  & addr <= flpa2 ) Then sloc = 'FLPA '\n      Else If (addr >= plpa1  & addr <= plpa2 ) Then sloc = 'PLPA '\n      Else If (addr >= sqa1   & addr <= sqa2  ) Then sloc = 'SQA  '\n      Else If (addr >= nuc1   & addr <= nuc2  ) Then sloc = 'NUC  '\n      Else If (addr >= esqa1  & addr <= esqa2 ) Then sloc = 'ESQA '\n      Else If (addr >= eplpa1 & addr <= eplpa2) Then sloc = 'EPLPA'\n      Else If (addr >= eflpa1 & addr <= eflpa2) Then sloc = 'EFLPA'\n      Else If (addr >= emlpa1 & addr <= emlpa2) Then sloc = 'EMLPA'\n      Else If (addr >= ecsa1  & addr <= ecsa2 ) Then sloc = 'ECSA '\n      Else If (addr >= epriv1 & addr <= epriv2) Then sloc = 'EPRIV'\n      Else If (addr >= priv1  & addr <= priv2 ) Then sloc = 'PRIV '\n      Else If (addr >= psa1   & addr <= psa2  ) Then sloc = 'PSA  '\n   cdxlmjp= C2X(SUBSTR(cde,21,4))\n   cduse  = C2D(SUBSTR(cde,25,2))\n   cdattr =     SUBSTR(cde,29,1)  /* do NOT convert raw byte */\n   alias = 0 ; If (BITAND(cdattr,'04'x)='04'x) Then alias = 1\n   cdattr2 = SUBSTR(cde,30,1)       /* do NOT convert raw byte */\n   auth = 0 ; If (BITAND(cdattr2,'01'x)='01'x) Then auth = 1\n   cdemjp  = '         '\n   cdemjnm = '        '\n   If alias = 1 Then Do\n                        cdemjp  = ' Alias of'\n                        cdemjnm = STORAGE(D2X(X2D(cdxlmjp)+8),8)\n                     End\n   Push ' 'LEFT(dsn,44,' ')' 'RIGHT(i,4,0),\n       cdname ,\n       C2X(cdentpt) ,\n       sloc ,\n       'USE:'RIGHT(cduse,5,0) ,\n        'AC:'auth ,\n        cdemjp cdemjnm d t\n   @cdechn = C2X(LEFT(cde,4))                 /* get next cde address */\nEnd\nSay ' '\nSay 'End of LPA Queue scan ' Time()\nSay ' '\n/***************************************************************/\n/* Now save the stack to our LPAQMODS data set                 */\n/***************************************************************/\ndsn2 = 'MS01.CONYERS.LPAQMODS.DATA.WORK'\n\"ALLOC F(LPAQMODS) DA('\"dsn2\"') OLD RELEASE\"\nIf RC \\= 0 Then Do\n   Say 'IOLPAQ failed on 'dsn2' error: 'RC\n   Exit\n   End\nQueue\n'EXECIO * DISKW LPAQMODS ( FINIS'\nDelstack\nSay ' '\nSay 'Saved 'i' LPAQ program descriptor records to DASD'\nSay 'DSN: 'dsn2\nSay 'Return Code: 'RC\n\"FREE F(LPAQMODS)\"\nExit\n./ ADD LIST=ALL,NAME=IONUCM\n/*REXX*/\n/*****************************************************************/\n/*  IONUCM: REXX program to create nucleus map data set.         */\n/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */\n/*****************************************************************/\n/* MVS DATA AREAS:                                               */\n/*                CVT - Communications Vector Table (@'10'x)     */\n/*              NUCMP - Nucleus Map Table (16 bytes by n rows)   */\n/*                                                               */\n/*****************************************************************/\nNumeric Digits 10\n@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */\n@cvt = D2X(C2D(@cvt))                    /* binary to hex             */\n@cvtnucmp = STORAGE(D2X(X2D(@cvt)+1200),4)   /* get CVTNUCMP address  */\n@cvtnucmp = D2X(C2D(@cvtnucmp))                /* binary to hex       */\nnucmapid  = STORAGE(@cvtnucmp,8)           /* nucmap eyecatcher entry */\nnucmeot   = C2D(STORAGE(D2X(X2D(@cvtnucmp)+8),4))  /* table end addrs */\nnucmlen   = C2D(STORAGE(D2X(X2D(@cvtnucmp)+13),3)) /* nucm tbl length */\n@nucmentry= X2D(@cvtnucmp)+16          /* address of 1st nucmap entry */\nAddress TSO ; 'CLEAR'\nSay 'CVT:'@cvt  'CVTNUCMP:'@cvtnucmp'  NUCMLEN:'nucmlen' bytes',\n    '  'DATE() TIME()\nSay ' '\nIf nucmapid \\= 'NUCMAP  ' Then Do\n   Say 'Error: Nucleus map table eyecatcher not found'\n   Exit\n   End\ni = 0 ; d = DATE() ; t = TIME()\nDo While @nucmentry <= nucmeot                  /* loop thru storage  */\n   i = i + 1\n   epname.i = STORAGE(D2X(@nucmentry),8)      /* get entry point name */\n   epaddr.i = C2X(STORAGE(D2X(@nucmentry+8),4))     /* get ep address */\n   epflag.i = STORAGE(D2X(@nucmentry+12),1)      /* get raw flag byte */\n   eplen.i  = C2X(STORAGE(D2X(@nucmentry+13),3))     /* get ep length */\n   @nucmentry = @nucmentry + 16                 /* bump to next entry */\nEnd\nentries = i\n/*--------------------------------------------------------------*/\n/* epflag byte structure:                                       */\n/*                                                              */\n/*           XXXX XXXX --> epflag byte                          */\n/*           |||| ||||                                          */\n/*           |||| ||++---- AMODE 00/01=24, 10=31, 11=ANY        */\n/*           |||| |+------ RMODE 0=24, 1=ANY                    */\n/*           |||| +------- RSECT 1=yes                          */\n/*           |||+--------- CSECT 1=yes                          */\n/*           +++---------- unused                               */\n/*--------------------------------------------------------------*/\nNewstack\nDo i = 1 to entries                             /* print the list     */\n   csect = '  N  ' ; rsect = '  N  ' ; rmode = '  24 ' ; amode = '  24 '\n   If BITAND(epflag.i,'10'x)='10'x Then csect = '  Y  ' /* is a csect */\n   If BITAND(epflag.i,'08'x)='08'x Then rsect = '  Y  ' /* read only  */\n   If BITAND(epflag.i,'04'x)='04'x Then rmode = ' Any ' /* residency  */\n   If BITAND(epflag.i,'02'x)='02'x Then amode = '  31 ' /* addressing */\n   If BITAND(epflag.i,'03'x)='03'x Then amode = ' Any ' /* addressing */\n   Push ' NUCM'Right(i,4,0) epname.i epaddr.i csect,\n                  rsect rmode amode eplen.i d t\nEnd\nSay ' '\nSay 'End of Nucleus Map Table scan ' TIME()\nSay ' '\n/***************************************************************/\n/* Now save the stack to our NUCMAP data set                   */\n/***************************************************************/\ndsn2 = 'MS01.CONYERS.NUCMAP.DATA.WORK'\n\"ALLOC F(NUCMAP) DA('\"dsn2\"') OLD RELEASE\"\nIf RC \\= 0 Then Do\n   Say 'IONUCM failed on 'dsn2' error: 'RC\n   Exit\n   End\nQueue\n'EXECIO * DISKW NUCMAP ( FINIS'\nDelstack\nSay ' '\nSay 'Saved 'entries' NUCMAP program descriptor records to DASD'\nSay 'DSN: 'dsn2\nSay 'Return Code: 'RC\n\"FREE F(NUCMAP)\"\nExit\n./ ADD LIST=ALL,NAME=IOPCAUTH\n/*REXX*/\n/*****************************************************************/\n/*IOPCAUTH: REXX program to obtain PC table from PCAUTH addspc.  */\n/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */\n/*****************************************************************/\n/* MVS DATA AREAS:                                               */\n/*                CVT - Communications Vector Table (@'10'x)     */\n/*               ASVT - Address Space Vector Table               */\n/*               ASCB - Address Space Control Block              */\n/*               OUCB - SRM User Control Block                   */\n/*              Other - calls assembler SNAP macro for PCDATA    */\n/*                                                               */\n/*****************************************************************/\n/*                                                               */\n/*****************************************************************/\n/*  First, get address space names (ASN) to associate with the   */\n/*  EXEC ASID field in the PCAUTH table.                         */\n/*****************************************************************/\n@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */\n@cvt = D2X(C2D(@cvt))                    /* binary to dec to hex      */\n@cvtasvt  = STORAGE(D2X(X2D(@cvt)+556),4)    /* get CVTASVT address   */\n@cvtasvt  = D2X(C2D(@cvtasvt))                 /* binary to dec to hex*/\nAddress TSO ; \"CLEAR\"\nSay 'CVT: '@cvt 'CVTASVT: '@cvtasvt' ===> Scan on 'DATE()'.  Started: 'TIME()\n@asvt = @cvtasvt\nasvtmaxu = STORAGE(D2X(X2D(@asvt)+516),4) /* get maxuser (table size) */\nDo i = 1 to C2D(asvtmaxu)                  /* initialize name buckets */\n   asn.i = 'Unknown '\nEnd\nasn.0 = '*Caller*'   /* if exec asid in pcauth is zero */\nj = 0 ; k = 0 ; tablend = 524 + (4 * (C2D(asvtmaxu)-1))\nDo i = 524 to tablend By 4                      /* loop thru the ASVT */\n   j = j + 1                            /* count asvt slots processed */\n   @ascb = STORAGE(D2X(X2D(@asvt)+i),4)        /* get address of ASCB */\n   If BITAND(LEFT(@ascb,1),'80'x)\\='80'x Then Do   /* bit off, in use */\n      k = k + 1                                /* count active adrspc */\n      ascbasid = STORAGE(D2X(C2D(@ascb)+36),2)            /* get ASID */\n      x = C2D(ascbasid)    /* convert for indexing */\n      @ascboucb = STORAGE(D2X(C2D(@ascb)+144),4)  /* get OUCB address */\n      @ascbjbni = STORAGE(D2X(C2D(@ascb)+172),4)  /* get JOBN address */\n      jbni = '        ' ; @ascbjbni = D2X(C2D(@ascbjbni))\n      If @ascbjbni \\= 0 Then jbni = STORAGE(@ascbjbni,8)\n      @ascbjbns = STORAGE(D2X(C2D(@ascb)+176),4)  /* get STCN address */\n      jbns = '        ' ; @ascbjbns = D2X(C2D(@ascbjbns))\n      If @ascbjbns \\= 0 Then jbns = STORAGE(@ascbjbns,8)\n      oucbsubn = STORAGE(D2X(C2D(@ascboucb)+176),4)    /* subsys name */\n      oucbtrxn = STORAGE(D2X(C2D(@ascboucb)+200),8)    /* transn name */\n      oucbusrd = STORAGE(D2X(C2D(@ascboucb)+208),8)         /* userid */\n      /* BATCH JOBS */\n      If oucbsubn = 'JES2' & jbns = 'INIT    ' & jbni = oucbtrxn Then Do\n         asn.x = oucbtrxn\n         nop\n         End\n      /* TSO USERS  */\n      If oucbsubn = 'TSO ' Then Do\n         If oucbusrd = '        ' Then asn.x = '????????' /* missing lid */\n                                  Else asn.x = oucbusrd\n         nop\n         End\n      /* STARTED TASKS */\n      If oucbsubn = 'STC ' & oucbtrxn \\= 'INIT    ' & jbns \\= 'INIT    ' Then Do\n         asn.x = oucbtrxn\n         nop\n         End\n      End\nEnd\nSay ' '\nSay 'SNAP SDATA=(PCDATA) macro called ' Date() Time()\nSay ' '\ndsn = 'MS01.CONYERS.PCAUTH.DATA.WORK'\n\"ALLOC F(SNAPRINT) DA('\"dsn\"') OLD RELEASE\"\npgm = 'MS01.CONYERS.LOAD(SNAPPC)'\n\"CALL '\"PGM\"'\"\nIf RC \\= 0 Then Do\n   Say '  *** SNAP program failed on error: 'RC\n   Exit\n   End\nSay 'Processing SNAP macro output     ' Date() Time()\nSay ' '\n\"ALLOC F(SNAPRINT) DA('\"dsn\"') SHR\"\nNewstack\n'EXECIO * DISKR SNAPRINT ( FINIS'\nIf RC \\= 0 Then Do\n   Say '  *** SNAP process failed on error: 'RC\n   Exit\n   End\n\"FREE F(SNAPRINT)\"\nQueue '*EOF*'\ni = 0 ; j = 0 ; d = Date() ; t = Time()\nDo while i < 2000\n  i = i + 1\n  Pull line\n  If LEFT(line,5) = '*EOF*' Then Leave\n  /* Say line */             /* uncomment say to see SNAP output */\n  x = SUBSTR(line,17,4)      /* extract & test AUTH KEY MASK */\n  y = SUBSTR(line,38,8)      /* extract & test ENTRY ADDRESS */\n  z = SUBSTR(line,59,8)      /* extract & test LATENT PARMS  */\n  /* Simple validity test for a PC INFORMATION line from SNAP output */\n  If DATATYPE(x,'X')=1 & DATATYPE(y,'X')=1 & DATATYPE(z,'X')=1 Then Do\n     j     = j + 1               /* INCREMENT PC ENTRY COUNTER */\n     pc.j  = SUBSTR(line,4,6)    /* PC NUM        */\n     akm.j = x                   /* AUTH KEY MASK */\n     ex.j  = SUBSTR(line,29,4)   /* EXEC ASID     */\n     ea.j  = y                   /* ENTRY ADDRESS */\n     es.j  = SUBSTR(line,51,1)   /* EXEC STATE    */\n     lp.j  = z                   /* LATENT PARMS  */\n     ekm.j = SUBSTR(line,73,4)   /* EXEC KEY MASK */\n     End\nEnd\nDelstack\nSay 'Processing statistics:'\nSay '                        REPORT OUTPUT  'RIGHT(i-1,4)' lines.'\nSay '                        PC INFORMATION 'RIGHT(j,4)' lines.'\nSay ' '\nSay 'PC INFORMATION analysis completed ' Time()\n/*-----------------------------------------------------------------*/\n/*  Now get virtual storage map to classify pcauth entry address   */\n/*-----------------------------------------------------------------*/\n/*--------------virtual storage map definition section----------------*/\nNumeric Digits 10           /* required to handle decimal conversions */\n@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */\n@cvt = D2X(C2D(@cvt))                    /* binary to hex             */\n@cvtreal  = STORAGE(D2X(X2D(@cvt)+284),4)    /* get CVTREAL address   */\n@cvtreal  = D2X(C2D(@cvtreal))                 /* binary to hex       */\n@cvtshrvm = STORAGE(D2X(X2D(@cvt)+416),4)    /* get CVTSHRVM address  */\n@cvtshrvm = D2X(C2D(@cvtshrvm))                /* binary to hex       */\n@cvtgda   = STORAGE(D2X(X2D(@cvt)+560),4)    /* get CVTGDA address    */\n@cvtgda   = D2X(C2D(@cvtgda))                  /* binary to hex       */\n@gdacsa   = D2X(X2D(@cvtgda)+108)            /* locate GDACSAstarts   */\n@gdacsa   = D2X(C2D(STORAGE(@gdacsa,4)))       /*  get GDACSA         */\n@gdacsasz = D2X(X2D(@cvtgda)+112)            /* locate GDACSASiZe     */\n@gdacsasz = D2X(C2D(STORAGE(@gdacsasz,4)))     /*  get GDACSASiZe     */\n@gdaecsa  = D2X(X2D(@cvtgda)+124)            /* locate GDAECSAstarts  */\n@gdaecsa  = D2X(C2D(STORAGE(@gdaecsa,4)))      /*  get GDAECSA        */\n@gdaecsas = D2X(X2D(@cvtgda)+128)            /* locate GDAECSASize    */\n@gdaecsas = D2X(C2D(STORAGE(@gdaecsas,4)))     /*  get GDAECSAS       */\n@cvtsmext = STORAGE(D2X(X2D(@cvt)+1196),4)   /* get CVTSMEXT address  */\n@cvtsmext = D2X(C2D(@cvtsmext))                /* binary to hex       */\n@cvtmlpas = D2X(X2D(@cvtsmext)+8)            /* locate CVTMLPAStarts  */\n@cvtmlpas = D2X(C2D(STORAGE(@cvtmlpas,4)))     /*  get CVTMLPAS       */\n@cvtmlpae = D2X(X2D(@cvtsmext)+12)           /* locate CVTMLPAEnds    */\n@cvtmlpae = D2X(C2D(STORAGE(@cvtmlpae,4)))     /*  get CVTMLPAE       */\n@cvtflpas = D2X(X2D(@cvtsmext)+16)           /* locate CVTFLPAStarts  */\n@cvtflpas = D2X(C2D(STORAGE(@cvtflpas,4)))     /*  get CVTFLPAS       */\n@cvtflpae = D2X(X2D(@cvtsmext)+20)           /* locate CVTFLPAEnds    */\n@cvtflpae = D2X(C2D(STORAGE(@cvtflpae,4)))     /*  get CVTFLPAE       */\n@cvtplpas = D2X(X2D(@cvtsmext)+24)           /* locate CVTPLPAStarts  */\n@cvtplpas = D2X(C2D(STORAGE(@cvtplpas,4)))     /*  get CVTPLPAS       */\n@cvtplpae = D2X(X2D(@cvtsmext)+28)           /* locate CVTPLPAEnds    */\n@cvtplpae = D2X(C2D(STORAGE(@cvtplpae,4)))     /*  get CVTPLPAE       */\n@cvtrwns  = D2X(X2D(@cvtsmext)+32)           /* locate CVTRWNStarts   */\n@cvtrwns  = D2X(C2D(STORAGE(@cvtrwns,4)))      /*  get CVTRWNS        */\n@cvtrwne  = D2X(X2D(@cvtsmext)+36)           /* locate CVTRWNEnds     */\n@cvtrwne  = D2X(C2D(STORAGE(@cvtrwne,4)))      /*  get CVTRWNE        */\n@cvtrons  = D2X(X2D(@cvtsmext)+40)           /* locate CVTRONStarts   */\n@cvtrons  = D2X(C2D(STORAGE(@cvtrons,4)))      /*  get CVTRONS        */\n@cvtrone  = D2X(X2D(@cvtsmext)+44)           /* locate CVTRONEnds     */\n@cvtrone  = D2X(C2D(STORAGE(@cvtrone,4)))      /*  get CVTRONE        */\n@cvterwns = D2X(X2D(@cvtsmext)+48)           /* locate CVTERWNStarts  */\n@cvterwns = D2X(C2D(STORAGE(@cvterwns,4)))     /*  get CVTERWNS       */\n@cvterwne = D2X(X2D(@cvtsmext)+52)           /* locate CVTERWNEnds    */\n@cvterwne = D2X(C2D(STORAGE(@cvterwne,4)))     /*  get CVTRRWNE       */\n@cvteplps = D2X(X2D(@cvtsmext)+56)           /* locate CVTEPLPStarts  */\n@cvteplps = D2X(C2D(STORAGE(@cvteplps,4)))     /*  get CVTEPLPS       */\n@cvteplpe = D2X(X2D(@cvtsmext)+60)           /* locate CVTEPLPEnds    */\n@cvteplpe = D2X(C2D(STORAGE(@cvteplpe,4)))     /*  get CVTRPLPE       */\n@cvteflps = D2X(X2D(@cvtsmext)+64)           /* locate CVTEFLPStarts  */\n@cvteflps = D2X(C2D(STORAGE(@cvteflps,4)))     /*  get CVTEFLPS       */\n@cvteflpe = D2X(X2D(@cvtsmext)+68)           /* locate CVTEFLPEnds    */\n@cvteflpe = D2X(C2D(STORAGE(@cvteflpe,4)))     /*  get CVTRFLPE       */\n@cvtemlps = D2X(X2D(@cvtsmext)+72)           /* locate CVTEMLPStarts  */\n@cvtemlps = D2X(C2D(STORAGE(@cvtemlps,4)))     /*  get CVTEMLPS       */\n@cvtemlpe = D2X(X2D(@cvtsmext)+76)           /* locate CVTEMLPEnds    */\n@cvtemlpe = D2X(C2D(STORAGE(@cvtemlpe,4)))     /*  get CVTRMLPE       */\n        /*------simplify variable names & make addresses decimal------*/\n@csa1g  = @gdacsa    ; @csa2g = D2X(X2D(@gdacsasz)+X2D(@gdacsa)-1)/* g*/\n   csa1 = X2D(@csa1g) ; csa2 = X2D(@csa2g)                    /* csa  */\n@mlpa1  = @cvtmlpas  ; @mlpa2 = @cvtmlpae                     /* mlpa */\n   mlpa1 = X2D(@mlpa1) ; mlpa2 = X2D(@mlpa2)\n@flpa1  = @cvtflpas  ; @flpa2 = @cvtflpae                     /* flpa */\n   flpa1 = X2D(@flpa1) ; flpa2 = X2D(@flpa2)\n@plpa1  = @cvtplpas  ; @plpa2 = @cvtplpae                     /* plpa */\n   plpa1 = X2D(@plpa1) ; plpa2 = X2D(@plpa2)\n@sqa1   = D2X(X2D(@cvtplpae)+1) ; @sqa2 = D2X(X2D(@cvtrwns)-1)/* sqa  */\n   sqa1 = X2D(@sqa1) ; sqa2 = X2D(@sqa2)\n@nuc1   = @cvtrwns   ; @nuc2  = @cvterwne                     /* nuc  */\n   nuc1 = X2D(@nuc1) ; nuc2 = X2D(@nuc2)\n@esqa1  = D2X(X2D(@nuc2)+1) ; @esqa2 = D2X(X2D(@cvteplps)-1)  /* esqa */\n  esqa1 = X2D(@esqa1) ; esqa2 = X2D(@esqa2)\n@eplpa1 = @cvteplps  ; @eplpa2 = @cvteplpe                    /* eplpa*/\n eplpa1 = X2D(@eplpa1) ; eplpa2 = X2D(@eplpa2)\n@eflpa1 = @cvteflps  ; @eflpa2 = @cvteflpe                    /* eflpa*/\n eflpa1 = X2D(@eflpa1) ; eflpa2 = X2D(@eflpa2)\n@emlpa1 = @cvtemlps  ; @emlpa2 = @cvtemlpe                    /* emlpa*/\n emlpa1 = X2D(@emlpa1) ; emlpa2 = X2D(@emlpa2)\n@ecsa1g = @gdaecsa   ; @ecsa2g= D2X(X2D(@gdaecsas)+X2D(@gdaecsa)-1)/*g*/\n  ecsa1 = X2D(@ecsa1g) ; ecsa2 = X2D(@ecsa2g)\n@eprivs = X2D(@ecsa2g)+1                               /* ext private */\n@eprive = 2147483647                         /* fixed by architecture */\n epriv1 = @eprivs ; epriv2 = @eprive\n@psas   = 0 ; @psae = 4095                       /* psa fixed by arch */\n   psa1 = @psas ; psa2 = @psae\n@prive  = X2D(@csa1g)-1 ; @privs = X2D(@psae)+1            /* private */\n  priv1 = @privs ; priv2 = @prive\n              /*------------------------------------------------------*/\n             /* Usage Notes: Hex character compares are incompatible */\n            /*    for storage residency determination.  Thus, entry */\n           /*     point addresses must be converted to decimal and */\n          /*      VS boundary addresses must be converted to de-  */\n         /*       cimal for correct compare operations.          */\n        /*------------------------------------------------------*/\n/*----------end of virtual storage map definition section-------------*/\n/*-----------------------------------------------------------------*/\n/*  Now reload a new stack with the parse output STEM'd from above */\n/*-----------------------------------------------------------------*/\nNewstack\ndsn2 = 'MVS.PCAUTH.PCTABLE'      /* assign a pseudo data set name  */\nDo i = j to 1 By -1              /* reverse stack unload on execio */\n                                        /* determine storage location */\n  k = X2D(ex.i) ; asname = asn.k    /* map address space name */\n/*addr = BITAND(X2C(ea.i),'7FFFFFFF'x)      shave off amode bit (32) */\n  addr = ea.i ; If LEFT(addr,1)='8' Then addr = SUBSTR(addr,2,7)\n  addr = X2D(addr)                      /* make numeric for compares */\n  sloc = 'ERROR'                       /* determine module residency */\n  If (addr >= csa1   & addr <= csa2  ) Then sloc = 'CSA  '\n     Else If (addr >= mlpa1  & addr <= mlpa2 ) Then sloc = 'MLPA '\n     Else If (addr >= flpa1  & addr <= flpa2 ) Then sloc = 'FLPA '\n     Else If (addr >= plpa1  & addr <= plpa2 ) Then sloc = 'PLPA '\n     Else If (addr >= sqa1   & addr <= sqa2  ) Then sloc = 'SQA  '\n     Else If (addr >= nuc1   & addr <= nuc2  ) Then sloc = 'NUC  '\n     Else If (addr >= esqa1  & addr <= esqa2 ) Then sloc = 'ESQA '\n     Else If (addr >= eplpa1 & addr <= eplpa2) Then sloc = 'EPLPA'\n     Else If (addr >= eflpa1 & addr <= eflpa2) Then sloc = 'EFLPA'\n     Else If (addr >= emlpa1 & addr <= emlpa2) Then sloc = 'EMLPA'\n     Else If (addr >= ecsa1  & addr <= ecsa2 ) Then sloc = 'ECSA '\n     Else If (addr >= epriv1 & addr <= epriv2) Then sloc = 'EPRIV'\n     Else If (addr >= priv1  & addr <= priv2 ) Then sloc = 'PRIV '\n     Else If (addr >= psa1   & addr <= psa2  ) Then sloc = 'PSA  '\n  Push ' 'LEFT(dsn2,44,' '),\n        pc.i akm.i ex.i asname ea.i sloc es.i ekm.i d t\nEnd\nQueue\n\"ALLOC F(SNAPRINT) DA('\"dsn\"') OLD RELEASE\"\n'EXECIO * DISKW SNAPRINT ( FINIS'\n\"FREE F(SNAPRINT)\"\nDelstack\nSay ' '\nSay 'Saved 'j' PC instruction descriptor records to DASD'\nSay 'DSN: 'dsn\nSay 'Return Code: 'RC\nExit\n./ ADD LIST=ALL,NAME=IOPLPA\n/*REXX*/\n/*****************************************************************/\n/*  IOPLPA: REXX program to copy PLPA directory to a dataset.    */\n/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */\n/*****************************************************************/\n/* MVS DATA AREAS:                                               */\n/*                CVT - Communications Vector Table (@'10'x)     */\n/*                GDA - Global Data Area                         */\n/*               LPDE - Link Pack Directory Entry                */\n/*                                                               */\n/*****************************************************************/\n/*--------------virtual storage map definition section----------------*/\nNumeric Digits 10           /* required to handle decimal conversions */\n@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */\n@cvt = D2X(C2D(@cvt))                    /* binary to hex             */\n@cvtreal  = STORAGE(D2X(X2D(@cvt)+284),4)    /* get CVTREAL address   */\n@cvtreal  = D2X(C2D(@cvtreal))                 /* binary to hex       */\n@cvtshrvm = STORAGE(D2X(X2D(@cvt)+416),4)    /* get CVTSHRVM address  */\n@cvtshrvm = D2X(C2D(@cvtshrvm))                /* binary to hex       */\n@cvtgda   = STORAGE(D2X(X2D(@cvt)+560),4)    /* get CVTGDA address    */\n@cvtgda   = D2X(C2D(@cvtgda))                  /* binary to hex       */\n@gdacsa   = D2X(X2D(@cvtgda)+108)            /* locate GDACSAstarts   */\n@gdacsa   = D2X(C2D(STORAGE(@gdacsa,4)))       /*  get GDACSA         */\n@gdacsasz = D2X(X2D(@cvtgda)+112)            /* locate GDACSASiZe     */\n@gdacsasz = D2X(C2D(STORAGE(@gdacsasz,4)))     /*  get GDACSASiZe     */\n@gdaecsa  = D2X(X2D(@cvtgda)+124)            /* locate GDAECSAstarts  */\n@gdaecsa  = D2X(C2D(STORAGE(@gdaecsa,4)))      /*  get GDAECSA        */\n@gdaecsas = D2X(X2D(@cvtgda)+128)            /* locate GDAECSASize    */\n@gdaecsas = D2X(C2D(STORAGE(@gdaecsas,4)))     /*  get GDAECSAS       */\n@cvtsmext = STORAGE(D2X(X2D(@cvt)+1196),4)   /* get CVTSMEXT address  */\n@cvtsmext = D2X(C2D(@cvtsmext))                /* binary to hex       */\n@cvtmlpas = D2X(X2D(@cvtsmext)+8)            /* locate CVTMLPAStarts  */\n@cvtmlpas = D2X(C2D(STORAGE(@cvtmlpas,4)))     /*  get CVTMLPAS       */\n@cvtmlpae = D2X(X2D(@cvtsmext)+12)           /* locate CVTMLPAEnds    */\n@cvtmlpae = D2X(C2D(STORAGE(@cvtmlpae,4)))     /*  get CVTMLPAE       */\n@cvtflpas = D2X(X2D(@cvtsmext)+16)           /* locate CVTFLPAStarts  */\n@cvtflpas = D2X(C2D(STORAGE(@cvtflpas,4)))     /*  get CVTFLPAS       */\n@cvtflpae = D2X(X2D(@cvtsmext)+20)           /* locate CVTFLPAEnds    */\n@cvtflpae = D2X(C2D(STORAGE(@cvtflpae,4)))     /*  get CVTFLPAE       */\n@cvtplpas = D2X(X2D(@cvtsmext)+24)           /* locate CVTPLPAStarts  */\n@cvtplpas = D2X(C2D(STORAGE(@cvtplpas,4)))     /*  get CVTPLPAS       */\n@cvtplpae = D2X(X2D(@cvtsmext)+28)           /* locate CVTPLPAEnds    */\n@cvtplpae = D2X(C2D(STORAGE(@cvtplpae,4)))     /*  get CVTPLPAE       */\n@cvtrwns  = D2X(X2D(@cvtsmext)+32)           /* locate CVTRWNStarts   */\n@cvtrwns  = D2X(C2D(STORAGE(@cvtrwns,4)))      /*  get CVTRWNS        */\n@cvtrwne  = D2X(X2D(@cvtsmext)+36)           /* locate CVTRWNEnds     */\n@cvtrwne  = D2X(C2D(STORAGE(@cvtrwne,4)))      /*  get CVTRWNE        */\n@cvtrons  = D2X(X2D(@cvtsmext)+40)           /* locate CVTRONStarts   */\n@cvtrons  = D2X(C2D(STORAGE(@cvtrons,4)))      /*  get CVTRONS        */\n@cvtrone  = D2X(X2D(@cvtsmext)+44)           /* locate CVTRONEnds     */\n@cvtrone  = D2X(C2D(STORAGE(@cvtrone,4)))      /*  get CVTRONE        */\n@cvterwns = D2X(X2D(@cvtsmext)+48)           /* locate CVTERWNStarts  */\n@cvterwns = D2X(C2D(STORAGE(@cvterwns,4)))     /*  get CVTERWNS       */\n@cvterwne = D2X(X2D(@cvtsmext)+52)           /* locate CVTERWNEnds    */\n@cvterwne = D2X(C2D(STORAGE(@cvterwne,4)))     /*  get CVTRRWNE       */\n@cvteplps = D2X(X2D(@cvtsmext)+56)           /* locate CVTEPLPStarts  */\n@cvteplps = D2X(C2D(STORAGE(@cvteplps,4)))     /*  get CVTEPLPS       */\n@cvteplpe = D2X(X2D(@cvtsmext)+60)           /* locate CVTEPLPEnds    */\n@cvteplpe = D2X(C2D(STORAGE(@cvteplpe,4)))     /*  get CVTRPLPE       */\n@cvteflps = D2X(X2D(@cvtsmext)+64)           /* locate CVTEFLPStarts  */\n@cvteflps = D2X(C2D(STORAGE(@cvteflps,4)))     /*  get CVTEFLPS       */\n@cvteflpe = D2X(X2D(@cvtsmext)+68)           /* locate CVTEFLPEnds    */\n@cvteflpe = D2X(C2D(STORAGE(@cvteflpe,4)))     /*  get CVTRFLPE       */\n@cvtemlps = D2X(X2D(@cvtsmext)+72)           /* locate CVTEMLPStarts  */\n@cvtemlps = D2X(C2D(STORAGE(@cvtemlps,4)))     /*  get CVTEMLPS       */\n@cvtemlpe = D2X(X2D(@cvtsmext)+76)           /* locate CVTEMLPEnds    */\n@cvtemlpe = D2X(C2D(STORAGE(@cvtemlpe,4)))     /*  get CVTRMLPE       */\n        /*------simplify variable names & make addresses decimal------*/\n@csa1g  = @gdacsa    ; @csa2g = D2X(X2D(@gdacsasz)+X2D(@gdacsa)-1)/* g*/\n   csa1 = X2D(@csa1g) ; csa2 = X2D(@csa2g)                    /* csa  */\n@mlpa1  = @cvtmlpas  ; @mlpa2 = @cvtmlpae                     /* mlpa */\n   mlpa1 = X2D(@mlpa1) ; mlpa2 = X2D(@mlpa2)\n@flpa1  = @cvtflpas  ; @flpa2 = @cvtflpae                     /* flpa */\n   flpa1 = X2D(@flpa1) ; flpa2 = X2D(@flpa2)\n@plpa1  = @cvtplpas  ; @plpa2 = @cvtplpae                     /* plpa */\n   plpa1 = X2D(@plpa1) ; plpa2 = X2D(@plpa2)\n@sqa1   = D2X(X2D(@cvtplpae)+1) ; @sqa2 = D2X(X2D(@cvtrwns)-1)/* sqa  */\n   sqa1 = X2D(@sqa1) ; sqa2 = X2D(@sqa2)\n@nuc1   = @cvtrwns   ; @nuc2  = @cvterwne                     /* nuc  */\n   nuc1 = X2D(@nuc1) ; nuc2 = X2D(@nuc2)\n@esqa1  = D2X(X2D(@nuc2)+1) ; @esqa2 = D2X(X2D(@cvteplps)-1)  /* esqa */\n  esqa1 = X2D(@esqa1) ; esqa2 = X2D(@esqa2)\n@eplpa1 = @cvteplps  ; @eplpa2 = @cvteplpe                    /* eplpa*/\n eplpa1 = X2D(@eplpa1) ; eplpa2 = X2D(@eplpa2)\n@eflpa1 = @cvteflps  ; @eflpa2 = @cvteflpe                    /* eflpa*/\n eflpa1 = X2D(@eflpa1) ; eflpa2 = X2D(@eflpa2)\n@emlpa1 = @cvtemlps  ; @emlpa2 = @cvtemlpe                    /* emlpa*/\n emlpa1 = X2D(@emlpa1) ; emlpa2 = X2D(@emlpa2)\n@ecsa1g = @gdaecsa   ; @ecsa2g= D2X(X2D(@gdaecsas)+X2D(@gdaecsa)-1)/*g*/\n  ecsa1 = X2D(@ecsa1g) ; ecsa2 = X2D(@ecsa2g)\n@eprivs = X2D(@ecsa2g)+1                               /* ext private */\n@eprive = 2147483647                         /* fixed by architecture */\n epriv1 = @eprivs ; epriv2 = @eprive\n@psas   = 0 ; @psae = 4095                       /* psa fixed by arch */\n   psa1 = @psas ; psa2 = @psae\n@prive  = X2D(@csa1g)-1 ; @privs = X2D(@psae)+1            /* private */\n  priv1 = @privs ; priv2 = @prive\n              /*------------------------------------------------------*/\n             /* Usage Notes: Hex character compares are incompatible */\n            /*    for storage residency determination.  Thus, entry */\n           /*     point addresses must be converted to decimal and */\n          /*      VS boundary addresses must be converted to de-  */\n         /*       cimal for correct compare operations.          */\n        /*------------------------------------------------------*/\n/*----------end of virtual storage map definition section-------------*/\n@cvtlpdir = STORAGE(D2X(X2D(@cvt)+361),3)    /* get CVTLPDIR address  */\n@cvtlpdir = D2X(C2D(@cvtlpdir))                /* binary to hex       */\nAddress TSO ; \"CLEAR\"\nSay 'CVT:'@cvt' CVTLPDIR:'@cvtlpdir'  'DATE() TIME()\n@lpdechn = @cvtlpdir\nSay ' '\ndsn = 'MVS.PLPA.DIRTABLE'            /* assign a pseudo data set name */\nNewstack\ni = 0 ; eot = '00000000000000000000000000000000'\nd = Date() ; t = Time()\nDo While i < 10000                                 /* arbitrary limit */\n   lpde = STORAGE(@lpdechn,40)                        /* get the lpde */\n   If C2X(SUBSTR(lpde,1,16))=eot Then Leave           /* end of table */\n   i = i + 1\n   module = SUBSTR(lpde,9,8)\n   entry  = SUBSTR(lpde,17,4)\n                                        /* determine storage location */\n   addr = BITAND(entry,'7FFFFFFF'x)       /* shave off amode bit (32) */\n   addr = C2D(addr)                      /* make numeric for compares */\n   sloc = 'ERROR'                       /* determine module residency */\n   If (addr >= csa1   & addr <= csa2  ) Then sloc = 'CSA  '\n      Else If (addr >= mlpa1  & addr <= mlpa2 ) Then sloc = 'MLPA '\n      Else If (addr >= flpa1  & addr <= flpa2 ) Then sloc = 'FLPA '\n      Else If (addr >= plpa1  & addr <= plpa2 ) Then sloc = 'PLPA '\n      Else If (addr >= sqa1   & addr <= sqa2  ) Then sloc = 'SQA  '\n      Else If (addr >= nuc1   & addr <= nuc2  ) Then sloc = 'NUC  '\n      Else If (addr >= esqa1  & addr <= esqa2 ) Then sloc = 'ESQA '\n      Else If (addr >= eplpa1 & addr <= eplpa2) Then sloc = 'EPLPA'\n      Else If (addr >= eflpa1 & addr <= eflpa2) Then sloc = 'EFLPA'\n      Else If (addr >= emlpa1 & addr <= emlpa2) Then sloc = 'EMLPA'\n      Else If (addr >= ecsa1  & addr <= ecsa2 ) Then sloc = 'ECSA '\n      Else If (addr >= epriv1 & addr <= epriv2) Then sloc = 'EPRIV'\n      Else If (addr >= priv1  & addr <= priv2 ) Then sloc = 'PRIV '\n      Else If (addr >= psa1   & addr <= psa2  ) Then sloc = 'PSA  '\n   size   = C2X(SUBSTR(lpde,33,4))\n   att2   =     SUBSTR(lpde,30,1)\n   auth = 0 ; If (BITAND(att2,'01'x)='01'x) Then auth = 1\n   lpdemjp  = '         '\n   lpdemjnm = '        '\n   If C2D(SUBSTR(lpde,21,4)) \\= 0 Then\n      Do\n         lpdemjp  = ' Alias of'\n         lpdemjnm = SUBSTR(lpde,33,8)\n             size = '        '\n      End\n   Push ' 'LEFT(dsn,44,' ') 'PLPA'RIGHT(i,4,0) ,\n       module ,\n       C2X(entry) ,\n       sloc ,\n       'SIZE:'RIGHT(size,8,0) ,\n       'AC:'auth ,\n       lpdemjp lpdemjnm d t\n   @lpdechn = D2X(X2D(@lpdechn)+40)         /* address of next LPDE */\nEnd\nSay ' '\nSay 'LPDE table scan completed 'Time()\n/***************************************************************/\n/* Now save the stack to our PLPAMODS data set                 */\n/***************************************************************/\ndsn2 = 'MS01.CONYERS.PLPAMODS.DATA.WORK'\n\"ALLOC F(PLPAMODS) DA('\"dsn2\"') OLD RELEASE\"\nIf RC \\= 0 Then Do\n   Say 'IOPLPA failed on 'dsn2' error: 'RC\n   Exit\n   End\nQueue\n'EXECIO * DISKW PLPAMODS ( FINIS'\nDelstack\nSay ' '\nSay 'Saved 'i' PLPA program descriptor records to DASD'\nSay 'DSN: 'dsn2\nSay 'Return Code: 'RC\n\"FREE F(PLPAMODS)\"\nExit\n./ ADD LIST=ALL,NAME=IOSVCT\n/*REXX*/\n/*****************************************************************/\n/*  IOSVCT: REXX program to create standard SVC database.        */\n/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */\n/*****************************************************************/\n/* MVS DATA AREAS:                                               */\n/*                CVT - Communications Vector Table (@'10'x)     */\n/*               SCVT - Supervisor Call Vector Table             */\n/*               SVCT - SVC Table                                */\n/*                                                               */\n/*                                                               */\n/*****************************************************************/\n/*--------------virtual storage map definition section----------------*/\nNumeric Digits 10           /* required to handle decimal conversions */\n@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */\n@cvt = D2X(C2D(@cvt))                    /* binary to hex             */\n@cvtreal  = STORAGE(D2X(X2D(@cvt)+284),4)    /* get CVTREAL address   */\n@cvtreal  = D2X(C2D(@cvtreal))                 /* binary to hex       */\n@cvtshrvm = STORAGE(D2X(X2D(@cvt)+416),4)    /* get CVTSHRVM address  */\n@cvtshrvm = D2X(C2D(@cvtshrvm))                /* binary to hex       */\n@cvtgda   = STORAGE(D2X(X2D(@cvt)+560),4)    /* get CVTGDA address    */\n@cvtgda   = D2X(C2D(@cvtgda))                  /* binary to hex       */\n@gdacsa   = D2X(X2D(@cvtgda)+108)            /* locate GDACSAstarts   */\n@gdacsa   = D2X(C2D(STORAGE(@gdacsa,4)))       /*  get GDACSA         */\n@gdacsasz = D2X(X2D(@cvtgda)+112)            /* locate GDACSASiZe     */\n@gdacsasz = D2X(C2D(STORAGE(@gdacsasz,4)))     /*  get GDACSASiZe     */\n@gdaecsa  = D2X(X2D(@cvtgda)+124)            /* locate GDAECSAstarts  */\n@gdaecsa  = D2X(C2D(STORAGE(@gdaecsa,4)))      /*  get GDAECSA        */\n@gdaecsas = D2X(X2D(@cvtgda)+128)            /* locate GDAECSASize    */\n@gdaecsas = D2X(C2D(STORAGE(@gdaecsas,4)))     /*  get GDAECSAS       */\n@cvtsmext = STORAGE(D2X(X2D(@cvt)+1196),4)   /* get CVTSMEXT address  */\n@cvtsmext = D2X(C2D(@cvtsmext))                /* binary to hex       */\n@cvtmlpas = D2X(X2D(@cvtsmext)+8)            /* locate CVTMLPAStarts  */\n@cvtmlpas = D2X(C2D(STORAGE(@cvtmlpas,4)))     /*  get CVTMLPAS       */\n@cvtmlpae = D2X(X2D(@cvtsmext)+12)           /* locate CVTMLPAEnds    */\n@cvtmlpae = D2X(C2D(STORAGE(@cvtmlpae,4)))     /*  get CVTMLPAE       */\n@cvtflpas = D2X(X2D(@cvtsmext)+16)           /* locate CVTFLPAStarts  */\n@cvtflpas = D2X(C2D(STORAGE(@cvtflpas,4)))     /*  get CVTFLPAS       */\n@cvtflpae = D2X(X2D(@cvtsmext)+20)           /* locate CVTFLPAEnds    */\n@cvtflpae = D2X(C2D(STORAGE(@cvtflpae,4)))     /*  get CVTFLPAE       */\n@cvtplpas = D2X(X2D(@cvtsmext)+24)           /* locate CVTPLPAStarts  */\n@cvtplpas = D2X(C2D(STORAGE(@cvtplpas,4)))     /*  get CVTPLPAS       */\n@cvtplpae = D2X(X2D(@cvtsmext)+28)           /* locate CVTPLPAEnds    */\n@cvtplpae = D2X(C2D(STORAGE(@cvtplpae,4)))     /*  get CVTPLPAE       */\n@cvtrwns  = D2X(X2D(@cvtsmext)+32)           /* locate CVTRWNStarts   */\n@cvtrwns  = D2X(C2D(STORAGE(@cvtrwns,4)))      /*  get CVTRWNS        */\n@cvtrwne  = D2X(X2D(@cvtsmext)+36)           /* locate CVTRWNEnds     */\n@cvtrwne  = D2X(C2D(STORAGE(@cvtrwne,4)))      /*  get CVTRWNE        */\n@cvtrons  = D2X(X2D(@cvtsmext)+40)           /* locate CVTRONStarts   */\n@cvtrons  = D2X(C2D(STORAGE(@cvtrons,4)))      /*  get CVTRONS        */\n@cvtrone  = D2X(X2D(@cvtsmext)+44)           /* locate CVTRONEnds     */\n@cvtrone  = D2X(C2D(STORAGE(@cvtrone,4)))      /*  get CVTRONE        */\n@cvterwns = D2X(X2D(@cvtsmext)+48)           /* locate CVTERWNStarts  */\n@cvterwns = D2X(C2D(STORAGE(@cvterwns,4)))     /*  get CVTERWNS       */\n@cvterwne = D2X(X2D(@cvtsmext)+52)           /* locate CVTERWNEnds    */\n@cvterwne = D2X(C2D(STORAGE(@cvterwne,4)))     /*  get CVTRRWNE       */\n@cvteplps = D2X(X2D(@cvtsmext)+56)           /* locate CVTEPLPStarts  */\n@cvteplps = D2X(C2D(STORAGE(@cvteplps,4)))     /*  get CVTEPLPS       */\n@cvteplpe = D2X(X2D(@cvtsmext)+60)           /* locate CVTEPLPEnds    */\n@cvteplpe = D2X(C2D(STORAGE(@cvteplpe,4)))     /*  get CVTRPLPE       */\n@cvteflps = D2X(X2D(@cvtsmext)+64)           /* locate CVTEFLPStarts  */\n@cvteflps = D2X(C2D(STORAGE(@cvteflps,4)))     /*  get CVTEFLPS       */\n@cvteflpe = D2X(X2D(@cvtsmext)+68)           /* locate CVTEFLPEnds    */\n@cvteflpe = D2X(C2D(STORAGE(@cvteflpe,4)))     /*  get CVTRFLPE       */\n@cvtemlps = D2X(X2D(@cvtsmext)+72)           /* locate CVTEMLPStarts  */\n@cvtemlps = D2X(C2D(STORAGE(@cvtemlps,4)))     /*  get CVTEMLPS       */\n@cvtemlpe = D2X(X2D(@cvtsmext)+76)           /* locate CVTEMLPEnds    */\n@cvtemlpe = D2X(C2D(STORAGE(@cvtemlpe,4)))     /*  get CVTRMLPE       */\n        /*------simplify variable names & make addresses decimal------*/\n@csa1g  = @gdacsa    ; @csa2g = D2X(X2D(@gdacsasz)+X2D(@gdacsa)-1)/* g*/\n   csa1 = X2D(@csa1g) ; csa2 = X2D(@csa2g)                    /* csa  */\n@mlpa1  = @cvtmlpas  ; @mlpa2 = @cvtmlpae                     /* mlpa */\n   mlpa1 = X2D(@mlpa1) ; mlpa2 = X2D(@mlpa2)\n@flpa1  = @cvtflpas  ; @flpa2 = @cvtflpae                     /* flpa */\n   flpa1 = X2D(@flpa1) ; flpa2 = X2D(@flpa2)\n@plpa1  = @cvtplpas  ; @plpa2 = @cvtplpae                     /* plpa */\n   plpa1 = X2D(@plpa1) ; plpa2 = X2D(@plpa2)\n@sqa1   = D2X(X2D(@cvtplpae)+1) ; @sqa2 = D2X(X2D(@cvtrwns)-1)/* sqa  */\n   sqa1 = X2D(@sqa1) ; sqa2 = X2D(@sqa2)\n@nuc1   = @cvtrwns   ; @nuc2  = @cvterwne                     /* nuc  */\n   nuc1 = X2D(@nuc1) ; nuc2 = X2D(@nuc2)\n@esqa1  = D2X(X2D(@nuc2)+1) ; @esqa2 = D2X(X2D(@cvteplps)-1)  /* esqa */\n  esqa1 = X2D(@esqa1) ; esqa2 = X2D(@esqa2)\n@eplpa1 = @cvteplps  ; @eplpa2 = @cvteplpe                    /* eplpa*/\n eplpa1 = X2D(@eplpa1) ; eplpa2 = X2D(@eplpa2)\n@eflpa1 = @cvteflps  ; @eflpa2 = @cvteflpe                    /* eflpa*/\n eflpa1 = X2D(@eflpa1) ; eflpa2 = X2D(@eflpa2)\n@emlpa1 = @cvtemlps  ; @emlpa2 = @cvtemlpe                    /* emlpa*/\n emlpa1 = X2D(@emlpa1) ; emlpa2 = X2D(@emlpa2)\n@ecsa1g = @gdaecsa   ; @ecsa2g= D2X(X2D(@gdaecsas)+X2D(@gdaecsa)-1)/*g*/\n  ecsa1 = X2D(@ecsa1g) ; ecsa2 = X2D(@ecsa2g)\n@eprivs = X2D(@ecsa2g)+1                               /* ext private */\n@eprive = 2147483647                         /* fixed by architecture */\n epriv1 = @eprivs ; epriv2 = @eprive\n@psas   = 0 ; @psae = 4095                       /* psa fixed by arch */\n   psa1 = @psas ; psa2 = @psae\n@prive  = X2D(@csa1g)-1 ; @privs = X2D(@psae)+1            /* private */\n  priv1 = @privs ; priv2 = @prive\n              /*------------------------------------------------------*/\n             /* Usage Notes: Hex character compares are incompatible */\n            /*    for storage residency determination.  Thus, entry */\n           /*     point addresses must be converted to decimal and */\n          /*      VS boundary addresses must be converted to de-  */\n         /*       cimal for correct compare operations.          */\n        /*------------------------------------------------------*/\n/*----------end of virtual storage map definition section-------------*/\n@cvtabend = STORAGE(D2X(X2D(@cvt)+200),4)    /* get CVTABEND address  */\n@cvtabend = D2X(C2D(@cvtabend))                /* binary to hex       */\n@scvtsvct = D2X(X2D(@cvtabend)+132)          /* SCVT addressibility   */\n@scvtsvct = STORAGE(@scvtsvct,4)                  /* SVCT table       */\n@scvtsvct = D2X(C2D(@scvtsvct))                /* binary to hex       */\nAddress TSO ; \"CLEAR\"\nSay 'CVT:'@cvt' CVTABEND:'@cvtabend' SCVTSVCT:'@scvtsvct DATE() TIME()\nSay ' '\ndsn = 'MVS.SVC.SVCTABLE'             /* assign a pseudo data set name */\nNewstack\nactive = 0 ; inactive = 0 ; svcapf = 0 ; svcesr = 0\nmodule = 'IGCERROR' ; Call \"#NUCLKUP\" module ; igcerror = Result\nd = Date() ; t = Time()\nDo i = 0 to 255                                 /* loop thru storage  */\n   bytes = STORAGE(D2X(X2D(@scvtsvct)+(i*8)),8)\n   addr = SUBSTR(bytes,1,4)       /* sloppy code to grab EP in binary */\n   bytes = C2X(bytes)          /* legacy code before learning bit ops */\n   svcep  = SUBSTR(bytes,1,8)\n                                        /* determine storage location */\n   addr = BITAND(addr,'7FFFFFFF'x)        /* shave off amode bit (32) */\n   addr = C2D(addr)                      /* make numeric for compares */\n   sloc = 'ERROR'                       /* determine module residency */\n   If (addr >= csa1   & addr <= csa2  ) Then sloc = 'CSA  '\n      Else If (addr >= mlpa1  & addr <= mlpa2 ) Then sloc = 'MLPA '\n      Else If (addr >= flpa1  & addr <= flpa2 ) Then sloc = 'FLPA '\n      Else If (addr >= plpa1  & addr <= plpa2 ) Then sloc = 'PLPA '\n      Else If (addr >= sqa1   & addr <= sqa2  ) Then sloc = 'SQA  '\n      Else If (addr >= nuc1   & addr <= nuc2  ) Then sloc = 'NUC  '\n      Else If (addr >= esqa1  & addr <= esqa2 ) Then sloc = 'ESQA '\n      Else If (addr >= eplpa1 & addr <= eplpa2) Then sloc = 'EPLPA'\n      Else If (addr >= eflpa1 & addr <= eflpa2) Then sloc = 'EFLPA'\n      Else If (addr >= emlpa1 & addr <= emlpa2) Then sloc = 'EMLPA'\n      Else If (addr >= ecsa1  & addr <= ecsa2 ) Then sloc = 'ECSA '\n      Else If (addr >= epriv1 & addr <= epriv2) Then sloc = 'EPRIV'\n      Else If (addr >= priv1  & addr <= priv2 ) Then sloc = 'PRIV '\n      Else If (addr >= psa1   & addr <= psa2  ) Then sloc = 'PSA  '\n      inactflag = 0\n      If igcerror = Right(D2X(addr),8,0)  /* normalize for match */\n         Then Do\n            inactive = inactive + 1\n            inactflag = 1\n         End\n         Else active = active + 1\n   svctp1 = SUBSTR(bytes,9,1)\n      Select\n         When svctp1 = '0'\n            Then svctype = 'TYPE 1  '\n         When svctp1 = '8'\n            Then svctype = 'TYPE 2  '\n         When svctp1 = 'C'\n            Then svctype = 'TYPE 3/4'\n         When svctp1 = '2'\n            Then svctype = 'TYPE 6  '\n      Otherwise\n                 svctype = 'TYPE ?  '\n      End\n   svctp2 = SUBSTR(bytes,10,1)\n      svcmisc = '   '\n      If svctp2 = '8'\n         Then Do\n            svcmisc = 'APF'\n            svcapf = svcapf + 1\n         End\n      If svctp2 = '4'\n         Then Do\n            svcmisc = 'ESR'\n            svcesr = svcesr + 1\n         End\n   If inactflag = 0\n      Then Push ' 'LEFT(dsn,44,' '),\n                'SVC'RIGHT(i,3,0) '('RIGHT(D2X(i),2,0)')',\n                svctype svcep sloc svcmisc d t\nEnd\nSay ' '\nSay 'There are 'active 'active standard SVCs on this system.'\nSay 'Among the active SVCs, 'svcapf 'are APF restricted.'\nSay 'There are 'svcesr 'active ESR router SVCs present.'\nSay 'The SVCTABLE contains 'inactive 'inactive slots (IGCERROR).'\nSay '    (IGCERROR nucleus address = 'igcerror')'\nSay ' '\nSay 'SVCTABLE processing complete ' Time()\n/***************************************************************/\n/* Now save the stack to our SVC data set                      */\n/***************************************************************/\ndsn2 = 'MS01.CONYERS.SVCS.DATA.WORK'\n\"ALLOC F(SVCS) DA('\"dsn2\"') OLD RELEASE\"\nIf RC \\= 0 Then Do\n   Say 'IOSVCT failed on 'dsn2' error: 'RC\n   Exit\n   End\nQueue\n'EXECIO * DISKW SVCS ( FINIS'\nDelstack\nSay ' '\nSay 'Saved 'active' SVC program descriptor records to DASD'\nSay 'DSN: 'dsn2\nSay 'Return Code: 'RC\n\"FREE F(SVCS)\"\nExit\n./ ADD LIST=ALL,NAME=LISTADSP\n/* REXX */\n/*****************************************************************/\n/*LISTADSP: REXX program to display all address space names.     */\n/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */\n/*****************************************************************/\n/* MVS DATA AREAS:                                               */\n/*                CVT - Communications Vector Table (@'10'x)     */\n/*               ASVT - Address Space Vector Table               */\n/*               ASCB - Address Space Control Block              */\n/*               OUCB - SRM User Control Block                   */\n/*                                                               */\n/*****************************************************************/\n@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */\n@cvt = D2X(C2D(@cvt))                    /* binary to dec to hex      */\n@cvtasvt  = STORAGE(D2X(X2D(@cvt)+556),4)    /* get CVTASVT address   */\n@cvtasvt  = D2X(C2D(@cvtasvt))                 /* binary to dec to hex*/\nAddress TSO ; \"CLEAR\"\nSay 'CVT: '@cvt 'CVTASVT: '@cvtasvt' ===> Scan on 'DATE()'.  Started: 'TIME()\n@asvt = @cvtasvt\nasvtmaxu = STORAGE(D2X(X2D(@asvt)+516),4) /* get maxuser (table size) */\nDo i = 1 to C2D(asvtmaxu)                  /* initialize name buckets */\n   bat.i = ''\n   tso.i = ''\n   stc.i = ''\nEnd\nj = 0 ; k = 0 ; tablend = 524 + (4 * (C2D(asvtmaxu)-1))\nb = 0 ; t = 0 ; s = 0 ; inits = 0      /* address space type counters */\nDo i = 524 to tablend By 4                      /* loop thru the ASVT */\n   j = j + 1                            /* count asvt slots processed */\n   @ascb = STORAGE(D2X(X2D(@asvt)+i),4)        /* get address of ASCB */\n   If BITAND(LEFT(@ascb,1),'80'x)\\='80'x Then Do   /* bit off, in use */\n      k = k + 1                                /* count active adrspc */\n      ascbasid = STORAGE(D2X(C2D(@ascb)+36),2)            /* get ASID */\n      @ascboucb = STORAGE(D2X(C2D(@ascb)+144),4)  /* get OUCB address */\n      @ascbjbni = STORAGE(D2X(C2D(@ascb)+172),4)  /* get JOBN address */\n      jbni = '        ' ; @ascbjbni = D2X(C2D(@ascbjbni))\n      If @ascbjbni \\= 0 Then jbni = STORAGE(@ascbjbni,8)\n      @ascbjbns = STORAGE(D2X(C2D(@ascb)+176),4)  /* get STCN address */\n      jbns = '        ' ; @ascbjbns = D2X(C2D(@ascbjbns))\n      If @ascbjbns \\= 0 Then jbns = STORAGE(@ascbjbns,8)\n      oucbsubn = STORAGE(D2X(C2D(@ascboucb)+176),4)    /* subsys name */\n      oucbtrxn = STORAGE(D2X(C2D(@ascboucb)+200),8)    /* transn name */\n      oucbusrd = STORAGE(D2X(C2D(@ascboucb)+208),8)         /* userid */\n      /* BATCH JOBS */\n      If oucbsubn = 'STC ' & jbns = 'INIT    ' Then inits = inits + 1\n      If oucbsubn = 'JES2' & jbns = 'INIT    ' & jbni = oucbtrxn Then Do\n         inits = inits + 1\n         b = b + 1\n         bat.b = oucbtrxn\n         End\n      /* TSO USERS  */\n      If oucbsubn = 'TSO ' Then Do\n         t = t + 1\n         If oucbusrd = '        ' Then tso.t = '????????' /* missing lid */\n                                  Else tso.t = oucbusrd\n         End\n      /* STARTED TASKS */\n      If oucbsubn = 'STC ' & oucbtrxn \\= 'INIT    ' & jbns \\= 'INIT    ' Then Do\n         s = s + 1\n         stc.s = oucbtrxn\n         End\n      End\nEnd\nSay ' '\nSay RIGHT(inits,4,' ')' Initiators defined.  'RIGHT(b,3,' ')' Batch jobs active:'\nIf b > 0 Then Do i = 1 To b By 8\n   c1=i ; c2=i+1 ; c3=i+2 ; c4=i+3 ; c5=i+4 ; c6=i+5 ; c7=i+6 ; c8=i+7\n   Say '     'bat.c1' 'bat.c2' 'bat.c3' 'bat.c4,\n              bat.c5' 'bat.c6' 'bat.c7' 'bat.c8\n   End\nSay ' '\nSay RIGHT(t,4,' ')' TSO sessions:'\nIf t > 0 Then Do i = 1 To t By 8\n   c1=i ; c2=i+1 ; c3=i+2 ; c4=i+3 ; c5=i+4 ; c6=i+5 ; c7=i+6 ; c8=i+7\n   Say '     'tso.c1' 'tso.c2' 'tso.c3' 'tso.c4,\n              tso.c5' 'tso.c6' 'tso.c7' 'tso.c8\n   End\nSay ' '\nSay RIGHT(s,4,' ')' Started tasks:'\nIf s > 0 Then Do i = 1 To s By 8\n   c1=i ; c2=i+1 ; c3=i+2 ; c4=i+3 ; c5=i+4 ; c6=i+5 ; c7=i+6 ; c8=i+7\n   Say '     'stc.c1' 'stc.c2' 'stc.c3' 'stc.c4,\n              stc.c5' 'stc.c6' 'stc.c7' 'stc.c8\n   End\nSay ' '\nSay RIGHT(k,4,' ')' slots in use out of a total 'j' scanned.  Completed: 'TIME()\nExit\n./ ADD LIST=ALL,NAME=LISTAPFT\n/*REXX*/\n/*****************************************************************/\n/*LISTAPFT: REXX program to display APF table from CSTOR.        */\n/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */\n/*****************************************************************/\n/* MVS DATA AREAS:                                               */\n/*                CVT - Communications Vector Table (@'10'x)     */\n/*             APFTAB - Undocumented in MVS DATA AREAS book.     */\n/*                                                               */\n/*                                                               */\n/*                                                               */\n/*****************************************************************/\n@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */\n@cvt = D2X(C2D(@cvt))                    /* binary to hex             */\n@cvtauthl = STORAGE(D2X(X2D(@cvt)+484),4)   /* get CVTAUTHL address   */\n@cvtauthl = D2X(C2D(@cvtauthl))                /* binary to hex       */\napfcount  = C2D(STORAGE(D2X(X2D(@cvtauthl)+1),1)) /* APF libraries    */\napfllen   = C2D(STORAGE(D2X(X2D(@cvtauthl)+2),1)) /* length 1st entry */\n@apfentry = X2D(@cvtauthl)+3          /* address of 1st APF entry     */\nSay 'The CVT  is located at '@cvt '('X2D(@cvt)')'\nSay 'The CVTAUTHL field points to '@cvtauthl '('X2D(@cvtauthl)')'\nSay 'The APF table contains 'apfcount 'entries, as follows:'\nSay ' '\nDo i = 1 to apfcount                            /* loop thru storage  */\n   apflib.i = STORAGE(D2X(@apfentry),apfllen)   /* get the APF entry  */\n   @apfentry = @apfentry + apfllen + 1          /* bump to next entry */\n   apfllen = C2D(STORAGE(D2X(@apfentry-1),1))   /* length of next  */\nEnd\nSay 'VOLSER --------------DATA SET NAME-----------------'\nSay ' '\nDo i = 1 to apfcount                            /* print the list     */\n   Say SUBSTR(apflib.i,1,6) SUBSTR(apflib.i,7,44,' ') i\nEnd\nExit\n./ ADD LIST=ALL,NAME=LISTCATS\n/*REXX*/\n/*****************************************************************/\n/*LISTCATS: REXX program to display all open catalogs.           */\n/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */\n/*****************************************************************/\n/* MVS DATA AREAS:                                               */\n/*                CVT - Communications Vector Table (@'10'x)     */\n/*              AMCBS - Access Method Control Block Structure    */\n/*              CAXWA - Calaog Auxiliary Work Area               */\n/*                UCB - Device Unit Control Block                */\n/*                                                               */\n/*****************************************************************/\n@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */\n@cvt = D2X(C2D(@cvt))                         /* binary to dec to hex */\n@cvtcbsp  = STORAGE(D2X(X2D(@cvt)+256),4)      /* get CVTCBSP address */\n@cvtcbsp  = D2X(C2D(@cvtcbsp))                /* binary to dec to hex */\n@cbscaxcn = STORAGE(D2X(X2D(@cvtcbsp)+20),4)  /* get CBSCAXCN address */\n@cbscaxcn = D2X(C2D(@cbscaxcn))               /* binary to dec to hex */\n@cbsacb   = STORAGE(D2X(X2D(@cvtcbsp)+8),4)     /* get CBSACB address */\n@cbsacb   = D2X(C2D(@cbsacb))                 /* binary to dec to hex */\nAddress TSO ; \"CLEAR\"\nSay 'CVT: '@cvt' CVTCBSP: '@cvtcbsp' ===> CAXWA chain trace started: 'TIME()\nSay ' '\ni = 0 ; endofcax = 0 ; @caxchn = @cbscaxcn\nDo While endofcax = 0 & i < 500\n   i = i + 1\n   @caxacb = STORAGE(D2X(X2D(@caxchn)+24),4)   /* catalog acb address */\n   @caxacb = D2X(C2D(@caxacb))                /* binary to dec to hex */\n   cattype = 'User  ' ; If @caxacb = @cbsacb Then cattype = 'Master'\n   @caxucb = STORAGE(D2X(X2D(@caxchn)+28),4)   /* catalog ucb address */\n   @caxucb = D2X(C2D(@caxucb))                /* binary to dec to hex */\n   caxvol  = STORAGE(D2X(X2D(@caxucb)+28),6)        /* catalog volser */\n   caxcnam = STORAGE(D2X(X2D(@caxchn)+52),44)          /* catalog dsn */\n   caxflg3 = STORAGE(D2X(X2D(@caxchn)+10),1)             /* cax flags */\n   catorg = 'CVOL' ; If BITAND(caxflg3,'20'x)='20'x Then catorg = 'ICF '\n   @caxnext = STORAGE(D2X(X2D(@caxchn)+4),4)    /* next caxwa address */\n   @caxnext = C2X(@caxnext)                   /* binary to dec to hex */\n   If @caxnext = 0 Then endofcax = 1            /* end of chain value */\n   Say RIGHT(i,2,' ') cattype catorg caxvol caxcnam\n   @caxchn = @caxnext\nEnd\nSay ' '\nSay 'Last CAXWA after 'i' blocks scanned.  Completed: 'TIME()\nExit\n./ ADD LIST=ALL,NAME=LISTCONS\n/*REXX*/\n/*****************************************************************/\n/* LISTCONS: REXX program to display system consoles and status. */\n/*     Note: Developed and tested on an MVS/SP 2.2.3 system.     */\n/*****************************************************************/\n/* MVS DATA AREAS:                                               */\n/*                CVT - Communications Vector Table (@'10'x)     */\n/*                UCM - Unit Control Module                      */\n/*                UCB - IOS Unit Control Block                   */\n/*****************************************************************/\nAddress TSO ; \"CLEAR\" ; Numeric Digits 10\n@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */\n@cvt = D2X(C2D(@cvt))                                /* binary to hex */\n@cvtcucb  = STORAGE(D2X(X2D(@cvt)+100),4)      /* get CVTCUCB address */\n@cvtcucb  = D2X(C2D(@cvtcucb))                       /* binary to hex */\n@ucmvea   = STORAGE(D2X(X2D(@cvtcucb)+72),4)    /* get UCMVEA address */\n@ucme     = D2X(C2D(@ucmvea))                        /* binary to hex */\nucmvez    = STORAGE(D2X(X2D(@cvtcucb)+76),4)            /* get UCMVEZ */\nucmelen   = C2D(ucmvez)                              /* binary to dec */\n@ucmvel   = STORAGE(D2X(X2D(@cvtcucb)+80),4)    /* get UCMVEL address */\n@ucmelast = D2X(C2D(@ucmvel))                        /* binary to hex */\nSay 'CVT:'@cvt'  CVTCUCB:'@cvtcucb'  UCMVEA:'@ucme'  'DATE() TIME()\nSay ' '\nSay 'Consoles  Status    Message Routing'\nSay '--------  --------  ------------------------------------------------------'\nSay ' '\nbit0='80'x ; bit1='40'x ; bit2='20'x ; bit3='10'x\nbit4='08'x ; bit5='04'x ; bit6='02'x ; bit7='01'x\nDo While @ucme <= @ucmelast             /* loop through the ucme list */\n   @ucmucb   = STORAGE(D2X(X2D(@ucme)+12),4)    /* get UCMUCB address */\n   @ucmucb   = D2X(C2D(@ucmucb))                     /* binary to hex */\n   ucbname   = STORAGE(D2X(X2D(@ucmucb)+13),3)         /* get UCBNAME */\n   ucmatr    = STORAGE(D2X(X2D(@ucme)+25),1)            /* get UCMATR */\n   ucmid     = STORAGE(D2X(X2D(@ucme)+26),1)             /* get UCMID */\n   ucmid     = C2D(ucmid)                            /* binary to dec */\n   active    = '' ; routing = ''\n   If BITAND(ucmatr,'10'x) = '10'x Then Do /* process active consoles */\n      active = '*Active* '\n      @ucmfextp = STORAGE(D2X(X2D(@ucme)+72),4)  /* get UCMFEXTP addr */\n      @ucmfextp = D2X(C2D(@ucmfextp))                /* binary to hex */\n      ucmefrc   = STORAGE(D2X(X2D(@ucmfextp)+24),16)   /* get UCMEFRC */\n      /*-------------------process route code data--------------------*/\n      Do i = 1 to 16\n         byte = SUBSTR(ucmefrc,i,1)\n         k = (i-1) * 8\n         If BITAND(byte,bit0)=bit0 Then routing = routing k+1\n         If BITAND(byte,bit1)=bit1 Then routing = routing k+2\n         If BITAND(byte,bit2)=bit2 Then routing = routing k+3\n         If BITAND(byte,bit3)=bit3 Then routing = routing k+4\n         If BITAND(byte,bit4)=bit4 Then routing = routing k+5\n         If BITAND(byte,bit5)=bit5 Then routing = routing k+6\n         If BITAND(byte,bit6)=bit6 Then routing = routing k+7\n         If BITAND(byte,bit7)=bit7 Then routing = routing k+8\n      End\n      i = 0 ; k = 0 ; f = '' ; j = 0 ; jj = 0\n      Do While routing \\= ''\n         i = i + 1\n         PARSE VAR routing type.i routing\n      End\n      If i > 2 Then\n         Do k = 1 to i-2\n            j = k + 1 ; jj = k + 2\n            If type.k = type.j - 1 & type.j = type.jj -1 Then f.k = '*'\n                                                         Else f.k = ' '\n         End\n      routing = 'Codes('\n      Do k = 1 to i\n         If f.k \\= '*' Then Do\n                               routing = routing''type.k\n                               If k \\= i Then routing = routing','\n                                         Else routing = routing')'\n                            End\n                       Else Do\n                              routing = routing''type.k':'\n                              Do While f.k = '*' ; k=k+1 ; End\n                            End\n      End\n      line2 = ''\n      If LENGTH(routing) >50 Then\n         Do\n            Do i = 70 to 1 By -1\n               If SUBSTR(routing,i,1) = ',' Then Leave\n            End\n            line2 = SUBSTR(routing,i+1,60)\n            routing = LEFT(routing,i)\n         End\n      /*--------------------end of route code data--------------------*/\n      End\n   Say RIGHT(ucmid,2)' ('ucbname')  'active routing\n   If line2 \\= '' Then Say   '                         'line2\n   @ucme = D2X(X2D(@ucme)+ucmelen)               /* bump to next ucme */\nEnd\nSay ' '\nSay 'Unit Control Module device table scan completed 'TIME()\nExit\n./ ADD LIST=ALL,NAME=LISTDASD\n/*REXX*/\n/*****************************************************************/\n/*LISTDASD: REXX program to display all online DASD devices.     */\n/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */\n/*****************************************************************/\n/* MVS DATA AREAS:                                               */\n/*                CVT - Communications Vector Table (@'10'x)     */\n/*                UCB - Device Unit Control Block                */\n/*                DCE - Device Class Extension                   */\n/*                VIP - VTOC Information Block                   */\n/*                                                               */\n/*****************************************************************/\n@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */\n@cvt = D2X(C2D(@cvt))                    /* binary to dec to hex      */\n@cvtucba  = STORAGE(D2X(X2D(@cvt)+1252),4)   /* get CVTUCBA address   */\n@cvtucba  = D2X(C2D(@cvtucba))                 /* binary to dec to hex*/\nAddress TSO\n\"CLEAR\"\nSay 'CVT: '@cvt' CVTUCBA: '@cvtucba' ===> DASD chain trace started: 'TIME()\nSay ' '\ni = 0 ; endofucb = 0 ; j = 0 ; @ucbchn = @cvtucba\npri = 0 ; pub = 0 ; sto = 0 ; smsv = 0\nDo While endofucb = 0 & i < 10000\n   i = i + 1\n   ucb     = STORAGE(@ucbchn,24)    /* get 24 byte ucb common segment */\n   ucbfl5  = SUBSTR(ucb,2,1)                  /* get flags5 bitstring */\n   ucbid   = SUBSTR(ucb,3,1)                 /* get the 'FF'x id byte */\n   ucbstat = SUBSTR(ucb,4,1)              /* status byte '80'x online */\n   ucbchan = SUBSTR(ucb,5,2)                /* channel address in hex */\n   ucbnxucb= SUBSTR(ucb,9,4)                   /* pointer to next ucb */\n   ucbtbyt3= SUBSTR(ucb,19,1)                 /* device '20'x is DASD */\n   ucbtbyt4= SUBSTR(ucb,20,1)           /* contains device type codes */\n   If (BITAND(ucbstat,'80'x)='80'x & BITAND(ucbtbyt3,'20'x)='20'x) Then Do\n      j = j + 1; device = ' Unknown'\n      ioaddr = C2X(ucbchan)\n      If BITAND(ucbfl5,'20'x)\\='20'x Then sms = 'Not SMS'\n                                     Else Do\n                                          sms = 'SMS    '\n                                          smsv = smsv + 1\n                                          End\n      If BITAND(ucbtbyt4,'04'x)='04'x Then device = '9340   '\n      If BITAND(ucbtbyt4,'06'x)='06'x Then device = '2305-1 '\n      If BITAND(ucbtbyt4,'07'x)='07'x Then device = '2305-2 '\n      If BITAND(ucbtbyt4,'08'x)='08'x Then device = '2314   '\n      If BITAND(ucbtbyt4,'09'x)='09'x Then device = '3330   '\n      If BITAND(ucbtbyt4,'0D'x)='0D'x Then device = '3330-11'\n      If BITAND(ucbtbyt4,'0A'x)='0A'x Then device = '3340   '\n      If BITAND(ucbtbyt4,'0B'x)='0B'x Then device = '3350   '\n      If BITAND(ucbtbyt4,'0C'x)='0C'x Then device = '3375   '\n      If BITAND(ucbtbyt4,'85'x)='85'x Then device = '6421   ' /*facom*/\n      If BITAND(ucbtbyt4,'0E'x)='0E'x Then device = '3380   '\n      If BITAND(ucbtbyt4,'0F'x)='0F'x Then device = '3390   '\n      @ucbx   = SUBSTR(ucb,21,4)          /* address of ucb extension */\n      @ucbx   = D2X(C2D(@ucbx))               /* binary to dec to hex */\n      @dce    = STORAGE(D2X(X2D(@ucbx)+24),4)       /* address of DCE */\n      @dce    = D2X(C2D(@dce))                /* binary to dec to hex */\n      @vib    = STORAGE(D2X(X2D(@dce)+4),4)         /* address of VIB */\n      @vib    = D2X(C2D(@vib))                /* binary to dec to hex */\n      vibflags= STORAGE(D2X(X2D(@vib)+6),1)    /* VTOC info flag byte */\n      If BITAND(vibflags,'80'x)='80'x Then vtocix = 'VTOCIX'\n                                      Else vtocix = '      '\n      @vvds   = STORAGE(D2X(X2D(@dce)+8),4)  /* address of VVDS block */\n      If C2D(@vvds) = 0 Then vvds = '    '\n                        Else vvds = 'VVDS'\n      @ucbchn=D2X(X2D(@ucbchn)+24)            /* bump to DASD segment */\n      ucbdasd = STORAGE(@ucbchn,24)       /* get 24 byte DASD segment */\n      ucbvoli = SUBSTR(ucbdasd,5,6)              /* volser if mounted */\n      ucbstab = SUBSTR(ucbdasd,11,1)         /* mount attribute codes */\n      mount = 'Unknown '\n      If BITAND(ucbstab,'10'x)='10'x Then Do\n         mount = 'Private'\n         pri = pri + 1\n         End\n      If BITAND(ucbstab,'08'x)='08'x Then Do\n         mount = 'Public '\n         pub = pub + 1\n         End\n      If BITAND(ucbstab,'04'x)='04'x Then Do\n         mount = 'Storage'\n         sto = sto + 1\n         End\n      Say RIGHT(j,3,' ') ucbvoli RIGHT(ioaddr,3) STRIP(device),\n          mount vtocix vvds sms\n   End\n   @ucbchn = D2X(C2D(ucbnxucb))\n   If @ucbchn = 0 Then endofucb = 1    /* zero address ends chain */\nEnd\nSay ' '\nSay 'Summary ===>  Private: 'pri'  Storage: 'sto'  Public: 'pub'  SMS: 'smsv\nSay ' '\nSay 'Last UCB after 'i' blocks scanned.  Completed: 'TIME()\nExit\n./ ADD LIST=ALL,NAME=LISTDCQ\n/*REXX*/\n/*****************************************************************/\n/* LISTDCQ: REXX program to display the device class queue.      */\n/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */\n/*****************************************************************/\n/* MVS DATA AREAS:                                               */\n/*                CVT - Communications Vector Table (@'10'x)     */\n/*                DCQ - Device Class Queue                       */\n/*                UCB - Device Unit Control Block                */\n/*                                                               */\n/*                                                               */\n/*****************************************************************/\nAddress TSO ; \"CLEAR\" ; Numeric Digits 10\n@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */\n@cvt = D2X(C2D(@cvt))                                /* binary to hex */\n@cvtdcqa  = STORAGE(D2X(X2D(@cvt)+1248),4)     /* get CVTDCQA address */\n@cvtdcqa  = D2X(C2D(@cvtdcqa))                       /* binary to hex */\nSay 'CVT:'@cvt' CVTDCQA:'@cvtdcqa' ==> Device Class Queue 'DATE() TIME()\nSay ' '\ndcq      = STORAGE(@cvtdcqa,20)             /* get 20 byte DCQ header */\ndcqname  = SUBSTR(dcq,1,4)                          /* dcq eyecatcher */\ndcqlngth = SUBSTR(dcq,5,2)                /* length of each dcq entry */\ndcqcount = SUBSTR(dcq,7,2)                      /* number of elements */\ndcqfirst = SUBSTR(dcq,9,4)              /* address of 1st dcq element */\ndcqdstct = SUBSTR(dcq,13,4)    /* entries in device class stats table */\ndcqucbno = SUBSTR(dcq,17,4) /* number of ucb's this I/O configuration */\n@dcqchn  = C2X(dcqfirst) ; i = 0\nSay ' This I/O configuration has defined -     UCBs: 'C2D(dcqucbno)\nSay '                                         DCQEs: 'C2D(dcqcount)\nSay '                                       1stDCQE: '@dcqchn\nSay ' '\nSay '      Name____  ID_   UCBs   1stUCB__   Active   Inactive  ID=UCB'\nSay ' '\nDo While @dcqchn \\= 0 & i < 10000\n   i = i + 1\n   dcqelmnt = STORAGE(@dcqchn,28)          /* get 28 byte DCQ element */\n   dcqchain = SUBSTR(dcqelmnt,1,4)      /* get next element's address */\n   @dcqchn  = D2X(C2D(dcqchain))\n   dcqdevcl = SUBSTR(dcqelmnt,5,1)     /* device class, i.e. UCBTBYT3 */\n   dcqucbct = SUBSTR(dcqelmnt,7,2)     /* ucb's for this device class */\n   dcqucbct = C2D(dcqucbct)\n   dcqucbad = SUBSTR(dcqelmnt,9,4)       /* 1st ucb this device class */\n   dcqucbad = C2X(dcqucbad) ; @ucbchn = dcqucbad\n   active = 0 ; inactive = 0 ; check = 0\n   Do j = 1 to dcqucbct           /* scan ucb chain this device class */\n      If @ucbchn = 0 Then Leave\n      ucb     = STORAGE(@ucbchn,24) /* get 24 byte ucb common segment */\n      ucbstat = SUBSTR(ucb,4,1)           /* status byte '80'x online */\n      ucbnxucb= SUBSTR(ucb,9,4)                /* pointer to next ucb */\n      ucbtbyt3= SUBSTR(ucb,19,1)           /* device ID like dcqdevcl */\n      If BITAND(ucbstat,'80'x)='80'x Then active = active + 1\n                                     Else inactive = inactive + 1\n      If BITAND(ucbtbyt3,dcqdevcl)=dcqdevcl Then check = check + 1\n      @ucbchn = C2X(ucbnxucb)\n   End\n   ok = 'ERROR ' ; If check = dcqucbct Then ok = '*okay*'\n   dcqdevnm = SUBSTR(dcqelmnt,13,8)              /* device class name */\n   If dcqucbad = '00000000' & dcqucbct = 0 Then Do\n      dcqucbad = '        '\n      active   = '    '\n      inactive = '    '\n      ok       = '      '\n   End\n   Say RIGHT(i,3)'   'dcqdevnm'  'C2X(dcqdevcl)'x',\n       '  'RIGHT(dcqucbct,4)'   'dcqucbad,\n       '   'RIGHT(active,4)'      'RIGHT(inactive,4)'    'ok\nEnd\nSay ' '\nSay 'Device Class Queue scan completed 'TIME()\nExit\n./ ADD LIST=ALL,NAME=LISTENV\n/*REXX*/\n/*****************************************************************/\n/* LISTENV: REXX program to display system environment data.     */\n/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */\n/*****************************************************************/\n/* MVS DATA AREAS:                                               */\n/*                CVT - Communications Vector Table (@'10'x)     */\n/*              JESCT - JES Control Table                        */\n/*             PCCAVT - Phys. Config. Comm. Area Vector Table    */\n/*               PCCA - Physical Config. Communications Area     */\n/*               TSVT - TSO Vector Table                         */\n/*               MQCT - HSM CVT                                  */\n/*                RCE - RSM Control and Enumeration Area         */\n/*                PSA - Prefixed Saved Area (CVT & PSAATCVT)     */\n/*              ASMVT - ASM Vector Table                         */\n/*                DCQ - Device Class Queue                       */\n/*                UCB - Device Unit Control Block                */\n/*****************************************************************/\nAddress TSO ; \"CLEAR\" ; Numeric Digits 10\n@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */\n@cvt = D2X(C2D(@cvt))                                /* binary to hex */\n@cvtprodn = D2X(X2D(@cvt)-40)                 /* get CVTPRODN address */\nmvssplvl  = STORAGE(@cvtprodn,8)                      /* get SP level */\n@cvtprodi = D2X(X2D(@cvt)-32)                 /* get CVTPRODI address */\nmvsfmid   = STORAGE(@cvtprodi,8)                          /* get FMID */\n@cvtmdl   = D2X(X2D(@cvt)-6)                    /* get CVTMDL address */\ncpumodel  = STORAGE(@cvtmdl,2)                           /* get MODEL */\ncpumodel  = C2X(cpumodel)\n@cvtsysad = STORAGE(D2X(X2D(@cvt)+48),4)      /* get CVTSYSAD address */\n@cvtsysad = D2X(C2D(@cvtsysad))                      /* binary to hex */\nsysresucb = STORAGE(@cvtsysad,48)                          /* get UCB */\nucbchan   = SUBSTR(sysresucb,5,2)\nucbchan   = SUBSTR(C2X(ucbchan),2)\nucbvoli   = SUBSTR(sysresucb,29,6)\n@cvttvt   = STORAGE(D2X(X2D(@cvt)+156),4)       /* get CVTTVT address */\n@cvttvt   = D2X(C2D(@cvttvt))                        /* binary to hex */\ntsvtlver  = STORAGE(D2X(X2D(@cvttvt)+100),1)          /* get TSVTLVER */\ntsvtlrel  = STORAGE(D2X(X2D(@cvttvt)+101),2)          /* get TSVTLREL */\ntsvtlmod  = STORAGE(D2X(X2D(@cvttvt)+103),1)          /* get TSVTLMOD */\n  tsoe = tsvtlver'.'tsvtlrel'.'tsvtlmod\n@cvtmz00  = STORAGE(D2X(X2D(@cvt)+164),4)              /* get CVTMZ00 */\n@cvtmz00  = D2X(C2D(@cvtmz00))                       /* binary to hex */\n  eovm  = ((X2D(@cvtmz00)+1)/1048576)'M'\n@cvtjesct = STORAGE(D2X(X2D(@cvt)+296),4)     /* get CVTJESCT address */\n@cvtjesct = D2X(C2D(@cvtjesct))                      /* binary to hex */\n  jes     = STORAGE(D2X(X2D(@cvtjesct)+28),4)         /* get JES name */\n@cvteorm  = STORAGE(D2X(X2D(@cvt)+312),4)      /* get CVTEORM address */\n@cvteorm  = D2X(C2D(@cvteorm))                       /* binary to hex */\n  cstor = ((X2D(@cvteorm)+1)/1048576)'M'             /* convert to MB */\n@cvtext2  = STORAGE(D2X(X2D(@cvt)+328),4)      /* get CVTEXT2 address */\n@cvtext2  = D2X(C2D(@cvtext2))                       /* binary to hex */\ncvtnucls  = STORAGE(D2X(X2D(@cvtext2)+4),1)   /* get selected nucleus */\n@cvtasmvt = STORAGE(D2X(X2D(@cvt)+704),4)     /* get CVTASMVT address */\n@cvtasmvt = D2X(C2D(@cvtasmvt))                      /* binary to hex */\nasmflag2  = STORAGE(D2X(X2D(@cvtasmvt)+1),1)\n  clpa = '(NO CLPA)'\n  If BITAND(asmflag2,'08'x) \\= '08'x Then clpa = '(CLPA)'\n@cvtpccat = STORAGE(D2X(X2D(@cvt)+764),4)     /* get CVTPCCAT address */\n@cvtpccat = D2X(C2D(@cvtpccat))                      /* binary to hex */\n@cvtrlstg = STORAGE(D2X(X2D(@cvt)+856),4)       /* get CVTRLSTG bytes */\n@cvtrlstg = C2D(@cvtrlstg)                           /* binary to dec */\n  cstorol = ((@cvtrlstg)/1024)'M'                    /* convert to MB */\n@cvthsm   = STORAGE(D2X(X2D(@cvt)+988),4)       /* get CVTHSM address */\n@cvthsm   = D2X(C2D(@cvthsm))                        /* binary to hex */\nmqctver   = STORAGE(D2X(X2D(@cvthsm)+48),2)            /* get MQCTVER */\nmqctrel   = STORAGE(D2X(X2D(@cvthsm)+50),1)            /* get MQCTREL */\nmqctmod   = STORAGE(D2X(X2D(@cvthsm)+51),1)            /* get MQCTMOD */\n  hsm  = mqctver'.'mqctrel'.'mqctmod\n@cvtdfa   = STORAGE(D2X(X2D(@cvt)+1216),4)      /* get CVTDFA address */\n@cvtdfa   = D2X(C2D(@cvtdfa))                        /* binary to hex */\ndfadata   = STORAGE(@cvtdfa,4)                  /* get DFP level data */\ndfadata   = C2X(dfadata)\ndfaver    = SUBSTR(dfadata,5,1)                    /* get DFP version */\ndfarel    = SUBSTR(dfadata,6,1)                    /* get DFP release */\ndfamod    = SUBSTR(dfadata,7,1)                    /* get DFP mod lvl */\n  dfp  = dfaver'.'dfarel'.'dfamod\n@cvtrcep  = STORAGE(D2X(X2D(@cvt)+1168),4)     /* get CVTRCEP address */\n@cvtrcep  = D2X(C2D(@cvtrcep))                       /* binary to hex */\nrceespl   = STORAGE(D2X(X2D(@cvtrcep)+160),4)  /* get RCEESPL frames  */\n  estor = ((C2D(rceespl)*4096)/1048576)'M'           /* convert to MB */\n@psaatcvt = STORAGE(408,4)             /* get VTAM ATCVT from PSAAOLD */\n@psaatcvt = D2X(C2D(@psaatcvt))                      /* binary to hex */\natcvtdata = STORAGE(@psaatcvt,4)               /* get VTAM level data */\natcvtdata = C2X(atcvtdata)\natcvtver  = SUBSTR(atcvtdata,6,1)                 /* get VTAM version */\natcvtrel  = SUBSTR(atcvtdata,8,1)                 /* get VTAM release */\n  vtam = atcvtver'.'atcvtrel\nSay 'CVT:'@cvt'   SYSTEM ENVIRONMENT DATA on 'DATE() TIME()\nSay ' '\nSay '   Software -   MVS: 'mvssplvl' ('STRIP(mvsfmid)')    JES: 'jes\nSay '                DFP: 'dfp'               TSO/E: 'tsoe\nSay '               VTAM: 'vtam'                   HSM:'hsm\nSay '                IPL: 'ucbvoli' @ 'ucbchan'      Nucleus: 'cvtnucls'  'clpa\nSay ' '\nSay '  Processor - Model: 'cpumodel\nSay '              CSTOR: 'cstor'   ('cstorol' on-line)    ESTOR: 'estor\nSay '              VSTOR: 'eovm'  (Highest virtual address '@cvtmz00'/'X2D(@cvtmz00)')'\nDo i = 0 to 15                                 /* loop thru CPU table */\n   @pcca = STORAGE(D2X(X2D(@cvtpccat)+(i*4)),4)\n   @pcca = C2X(@pcca)\n   If @pcca \\= 0 Then Do\n      Say '                CPU: 'RIGHT(i,2,0),\n          '    ('STORAGE(D2X(X2D(@pcca)+4),8)')'\n      End\n   End\n@cvtdcqa  = STORAGE(D2X(X2D(@cvt)+1248),4)     /* get CVTDCQA address */\n@cvtdcqa  = D2X(C2D(@cvtdcqa))                       /* binary to hex */\ndcq      = STORAGE(@cvtdcqa,20)             /* get 20 byte DCQ header */\ndcqcount = SUBSTR(dcq,7,2)                      /* number of elements */\ndcqfirst = SUBSTR(dcq,9,4)              /* address of 1st dcq element */\n@dcqchn  = C2X(dcqfirst) ; i = 0\nSay ' '\nSay '        I/O - Device     UCBs  Active  ID=UCB'\nSay '              --------   ----  ------  ------'\nDo While @dcqchn \\= 0 & i < 100\n   i = i + 1\n   dcqelmnt = STORAGE(@dcqchn,28)          /* get 28 byte DCQ element */\n   dcqchain = SUBSTR(dcqelmnt,1,4)      /* get next element's address */\n   @dcqchn  = D2X(C2D(dcqchain))\n   dcqdevcl = SUBSTR(dcqelmnt,5,1)     /* device class, i.e. UCBTBYT3 */\n   dcqucbct = SUBSTR(dcqelmnt,7,2)     /* ucb's for this device class */\n   dcqucbct = C2D(dcqucbct)\n   dcqucbad = SUBSTR(dcqelmnt,9,4)       /* 1st ucb this device class */\n   dcqucbad = C2X(dcqucbad) ; @ucbchn = dcqucbad\n   active = 0 ; check = 0\n   Do j = 1 to dcqucbct           /* scan ucb chain this device class */\n      If @ucbchn = 0 Then Leave\n      ucb     = STORAGE(@ucbchn,24) /* get 24 byte ucb common segment */\n      ucbstat = SUBSTR(ucb,4,1)           /* status byte '80'x online */\n      ucbnxucb= SUBSTR(ucb,9,4)                /* pointer to next ucb */\n      ucbtbyt3= SUBSTR(ucb,19,1)           /* device ID like dcqdevcl */\n      If BITAND(ucbstat,'80'x)='80'x Then active = active + 1\n      If BITAND(ucbtbyt3,dcqdevcl)=dcqdevcl Then check = check + 1\n      @ucbchn = C2X(ucbnxucb)\n   End\n   ok = 'ERROR ' ; If check = dcqucbct Then ok = '*okay*'\n   dcqdevnm = SUBSTR(dcqelmnt,13,8)              /* device class name */\n   If dcqucbad = '00000000' & dcqucbct = 0 Then Do\n      active   = '    '\n      ok       = '      '\n   End\n   Say '              'dcqdevnm,\n       '  'RIGHT(dcqucbct,4),\n       '  'RIGHT(active,4)'   'ok\nEnd\nExit\n./ ADD LIST=ALL,NAME=LISTESRT\n/*REXX*/\n/*****************************************************************/\n/*LISTESRT: REXX program to display all router SVCs.             */\n/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */\n/*****************************************************************/\n/* MVS DATA AREAS:                                               */\n/*                CVT - Communications Vector Table (@'10'x)     */\n/*               SCVT - Supervisor Call Vector Table             */\n/*                                                               */\n/*                                                               */\n/*****************************************************************/\n/*--------------virtual storage map definition section----------------*/\nNumeric Digits 10           /* required to handle decimal conversions */\n@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */\n@cvt = D2X(C2D(@cvt))                    /* binary to hex             */\n@cvtreal  = STORAGE(D2X(X2D(@cvt)+284),4)    /* get CVTREAL address   */\n@cvtreal  = D2X(C2D(@cvtreal))                 /* binary to hex       */\n@cvtshrvm = STORAGE(D2X(X2D(@cvt)+416),4)    /* get CVTSHRVM address  */\n@cvtshrvm = D2X(C2D(@cvtshrvm))                /* binary to hex       */\n@cvtgda   = STORAGE(D2X(X2D(@cvt)+560),4)    /* get CVTGDA address    */\n@cvtgda   = D2X(C2D(@cvtgda))                  /* binary to hex       */\n@gdacsa   = D2X(X2D(@cvtgda)+108)            /* locate GDACSAstarts   */\n@gdacsa   = D2X(C2D(STORAGE(@gdacsa,4)))       /*  get GDACSA         */\n@gdacsasz = D2X(X2D(@cvtgda)+112)            /* locate GDACSASiZe     */\n@gdacsasz = D2X(C2D(STORAGE(@gdacsasz,4)))     /*  get GDACSASiZe     */\n@gdaecsa  = D2X(X2D(@cvtgda)+124)            /* locate GDAECSAstarts  */\n@gdaecsa  = D2X(C2D(STORAGE(@gdaecsa,4)))      /*  get GDAECSA        */\n@gdaecsas = D2X(X2D(@cvtgda)+128)            /* locate GDAECSASize    */\n@gdaecsas = D2X(C2D(STORAGE(@gdaecsas,4)))     /*  get GDAECSAS       */\n@cvtsmext = STORAGE(D2X(X2D(@cvt)+1196),4)   /* get CVTSMEXT address  */\n@cvtsmext = D2X(C2D(@cvtsmext))                /* binary to hex       */\n@cvtmlpas = D2X(X2D(@cvtsmext)+8)            /* locate CVTMLPAStarts  */\n@cvtmlpas = D2X(C2D(STORAGE(@cvtmlpas,4)))     /*  get CVTMLPAS       */\n@cvtmlpae = D2X(X2D(@cvtsmext)+12)           /* locate CVTMLPAEnds    */\n@cvtmlpae = D2X(C2D(STORAGE(@cvtmlpae,4)))     /*  get CVTMLPAE       */\n@cvtflpas = D2X(X2D(@cvtsmext)+16)           /* locate CVTFLPAStarts  */\n@cvtflpas = D2X(C2D(STORAGE(@cvtflpas,4)))     /*  get CVTFLPAS       */\n@cvtflpae = D2X(X2D(@cvtsmext)+20)           /* locate CVTFLPAEnds    */\n@cvtflpae = D2X(C2D(STORAGE(@cvtflpae,4)))     /*  get CVTFLPAE       */\n@cvtplpas = D2X(X2D(@cvtsmext)+24)           /* locate CVTPLPAStarts  */\n@cvtplpas = D2X(C2D(STORAGE(@cvtplpas,4)))     /*  get CVTPLPAS       */\n@cvtplpae = D2X(X2D(@cvtsmext)+28)           /* locate CVTPLPAEnds    */\n@cvtplpae = D2X(C2D(STORAGE(@cvtplpae,4)))     /*  get CVTPLPAE       */\n@cvtrwns  = D2X(X2D(@cvtsmext)+32)           /* locate CVTRWNStarts   */\n@cvtrwns  = D2X(C2D(STORAGE(@cvtrwns,4)))      /*  get CVTRWNS        */\n@cvtrwne  = D2X(X2D(@cvtsmext)+36)           /* locate CVTRWNEnds     */\n@cvtrwne  = D2X(C2D(STORAGE(@cvtrwne,4)))      /*  get CVTRWNE        */\n@cvtrons  = D2X(X2D(@cvtsmext)+40)           /* locate CVTRONStarts   */\n@cvtrons  = D2X(C2D(STORAGE(@cvtrons,4)))      /*  get CVTRONS        */\n@cvtrone  = D2X(X2D(@cvtsmext)+44)           /* locate CVTRONEnds     */\n@cvtrone  = D2X(C2D(STORAGE(@cvtrone,4)))      /*  get CVTRONE        */\n@cvterwns = D2X(X2D(@cvtsmext)+48)           /* locate CVTERWNStarts  */\n@cvterwns = D2X(C2D(STORAGE(@cvterwns,4)))     /*  get CVTERWNS       */\n@cvterwne = D2X(X2D(@cvtsmext)+52)           /* locate CVTERWNEnds    */\n@cvterwne = D2X(C2D(STORAGE(@cvterwne,4)))     /*  get CVTRRWNE       */\n@cvteplps = D2X(X2D(@cvtsmext)+56)           /* locate CVTEPLPStarts  */\n@cvteplps = D2X(C2D(STORAGE(@cvteplps,4)))     /*  get CVTEPLPS       */\n@cvteplpe = D2X(X2D(@cvtsmext)+60)           /* locate CVTEPLPEnds    */\n@cvteplpe = D2X(C2D(STORAGE(@cvteplpe,4)))     /*  get CVTRPLPE       */\n@cvteflps = D2X(X2D(@cvtsmext)+64)           /* locate CVTEFLPStarts  */\n@cvteflps = D2X(C2D(STORAGE(@cvteflps,4)))     /*  get CVTEFLPS       */\n@cvteflpe = D2X(X2D(@cvtsmext)+68)           /* locate CVTEFLPEnds    */\n@cvteflpe = D2X(C2D(STORAGE(@cvteflpe,4)))     /*  get CVTRFLPE       */\n@cvtemlps = D2X(X2D(@cvtsmext)+72)           /* locate CVTEMLPStarts  */\n@cvtemlps = D2X(C2D(STORAGE(@cvtemlps,4)))     /*  get CVTEMLPS       */\n@cvtemlpe = D2X(X2D(@cvtsmext)+76)           /* locate CVTEMLPEnds    */\n@cvtemlpe = D2X(C2D(STORAGE(@cvtemlpe,4)))     /*  get CVTRMLPE       */\n        /*------simplify variable names & make addresses decimal------*/\n@csa1g  = @gdacsa    ; @csa2g = D2X(X2D(@gdacsasz)+X2D(@gdacsa)-1)/* g*/\n   csa1 = X2D(@csa1g) ; csa2 = X2D(@csa2g)                    /* csa  */\n@mlpa1  = @cvtmlpas  ; @mlpa2 = @cvtmlpae                     /* mlpa */\n   mlpa1 = X2D(@mlpa1) ; mlpa2 = X2D(@mlpa2)\n@flpa1  = @cvtflpas  ; @flpa2 = @cvtflpae                     /* flpa */\n   flpa1 = X2D(@flpa1) ; flpa2 = X2D(@flpa2)\n@plpa1  = @cvtplpas  ; @plpa2 = @cvtplpae                     /* plpa */\n   plpa1 = X2D(@plpa1) ; plpa2 = X2D(@plpa2)\n@sqa1   = D2X(X2D(@cvtplpae)+1) ; @sqa2 = D2X(X2D(@cvtrwns)-1)/* sqa  */\n   sqa1 = X2D(@sqa1) ; sqa2 = X2D(@sqa2)\n@nuc1   = @cvtrwns   ; @nuc2  = @cvterwne                     /* nuc  */\n   nuc1 = X2D(@nuc1) ; nuc2 = X2D(@nuc2)\n@esqa1  = D2X(X2D(@nuc2)+1) ; @esqa2 = D2X(X2D(@cvteplps)-1)  /* esqa */\n  esqa1 = X2D(@esqa1) ; esqa2 = X2D(@esqa2)\n@eplpa1 = @cvteplps  ; @eplpa2 = @cvteplpe                    /* eplpa*/\n eplpa1 = X2D(@eplpa1) ; eplpa2 = X2D(@eplpa2)\n@eflpa1 = @cvteflps  ; @eflpa2 = @cvteflpe                    /* eflpa*/\n eflpa1 = X2D(@eflpa1) ; eflpa2 = X2D(@eflpa2)\n@emlpa1 = @cvtemlps  ; @emlpa2 = @cvtemlpe                    /* emlpa*/\n emlpa1 = X2D(@emlpa1) ; emlpa2 = X2D(@emlpa2)\n@ecsa1g = @gdaecsa   ; @ecsa2g= D2X(X2D(@gdaecsas)+X2D(@gdaecsa)-1)/*g*/\n  ecsa1 = X2D(@ecsa1g) ; ecsa2 = X2D(@ecsa2g)\n@eprivs = X2D(@ecsa2g)+1                               /* ext private */\n@eprive = 2147483647                         /* fixed by architecture */\n epriv1 = @eprivs ; epriv2 = @eprive\n@psas   = 0 ; @psae = 4095                       /* psa fixed by arch */\n   psa1 = @psas ; psa2 = @psae\n@prive  = X2D(@csa1g)-1 ; @privs = X2D(@psae)+1            /* private */\n  priv1 = @privs ; priv2 = @prive\n              /*------------------------------------------------------*/\n             /* Usage Notes: Hex character compares are incompatible */\n            /*    for storage residency determination.  Thus, entry */\n           /*     point addresses must be converted to decimal and */\n          /*      VS boundary addresses must be converted to de-  */\n         /*       cimal for correct compare operations.          */\n        /*------------------------------------------------------*/\n/*----------end of virtual storage map definition section-------------*/\n@cvtabend = STORAGE(D2X(X2D(@cvt)+200),4)    /* get CVTABEND address  */\n@cvtabend = D2X(C2D(@cvtabend))                /* binary to hex       */\n@scvtsvct = D2X(X2D(@cvtabend)+132)          /* SCVT addressibility   */\n@scvtsvct = STORAGE(@scvtsvct,4)                  /* SVCT table       */\n@scvtsvct = D2X(C2D(@scvtsvct))                /* binary to hex       */\nAddress TSO ; \"CLEAR\"\nSay 'CVT:'@cvt' CVTABEND:'@cvtabend' SCVTSVCT:'@scvtsvct' 'DATE() TIME()\nSay ' '\nSay 'Active ESR SVCs follow:'\nSay ' '\nactive = 0 ; inactive = 0 ; esrsvc = 0\nmodule = 'IGXERROR' ; Call \"#NUCLKUP\" module ; igxerror = Result\nDo i = 0 to 255                                 /* loop thru storage  */\n   bytes = STORAGE(D2X(X2D(@scvtsvct)+(i*8)),8)\n   bytes = C2X(bytes)\n   svcep  = SUBSTR(bytes,1,8)\n   svctp2 = SUBSTR(bytes,10,1)\n   If svctp2 = '4'            /* EP address is an ESR table */\n      Then Do\n         esrid = STORAGE(svcep,4)                 /* table eyecatcher */\n         esrct = C2X(STORAGE(D2X(X2D(svcep)+4),4))       /* esr count */\n         Say 'SVC 'i' is 'esrid'.  Table at 'svcep', Slots 'X2D(esrct)' ('esrct')'\n         Say ' '\n         esrsvc = 0\n         Do j = 0 to X2D(esrct)                   /* process this ESR */\n            bytes = STORAGE(D2X(X2D(svcep)+(j*8)+8),8)\n   addr = SUBSTR(bytes,1,4)       /* sloppy code to grap EP in binary */\n   bytes = C2X(bytes)          /* legacy code before learning bit ops */\n            esrep  = SUBSTR(bytes,1,8)\n                                        /* determine storage location */\n   addr = BITAND(addr,'7FFFFFFF'x)        /* shave off amode bit (32) */\n   addr = C2D(addr)                      /* make numeric for compares */\n   sloc = 'ERROR'                       /* determine module residency */\n   If (addr >= csa1   & addr <= csa2  ) Then sloc = 'CSA  '\n      Else If (addr >= mlpa1  & addr <= mlpa2 ) Then sloc = 'MLPA '\n      Else If (addr >= flpa1  & addr <= flpa2 ) Then sloc = 'FLPA '\n      Else If (addr >= plpa1  & addr <= plpa2 ) Then sloc = 'PLPA '\n      Else If (addr >= sqa1   & addr <= sqa2  ) Then sloc = 'SQA  '\n      Else If (addr >= nuc1   & addr <= nuc2  ) Then sloc = 'NUC  '\n      Else If (addr >= esqa1  & addr <= esqa2 ) Then sloc = 'ESQA '\n      Else If (addr >= eplpa1 & addr <= eplpa2) Then sloc = 'EPLPA'\n      Else If (addr >= eflpa1 & addr <= eflpa2) Then sloc = 'EFLPA'\n      Else If (addr >= emlpa1 & addr <= emlpa2) Then sloc = 'EMLPA'\n      Else If (addr >= ecsa1  & addr <= ecsa2 ) Then sloc = 'ECSA '\n      Else If (addr >= epriv1 & addr <= epriv2) Then sloc = 'EPRIV'\n      Else If (addr >= priv1  & addr <= priv2 ) Then sloc = 'PRIV '\n      Else If (addr >= psa1   & addr <= psa2  ) Then sloc = 'PSA  '\n            esrtp2 = SUBSTR(bytes,10,1)\n            esrmisc = '   '\n            If esrtp2 = '8'\n               Then esrmisc = 'APF'\n            inactflag = 0\n            If igxerror = Right(D2X(addr),8,0) /* normalize address */\n               Then inactflag = 1\n               Else Do\n                       active = active + 1\n                       esrsvc = esrsvc + 1\n                    End\n            esrtp1 = SUBSTR(bytes,9,1)\n               Select\n                  When esrtp1 = '0'\n                     Then esrtype = 'TYPE 1  '\n                  When esrtp1 = '8'\n                     Then esrtype = 'TYPE 2  '\n                  When esrtp1 = 'C'\n                     Then esrtype = 'TYPE 3/4'\n                  When esrtp1 = '2'\n                     Then esrtype = 'TYPE 6  '\n               Otherwise\n                          esrtype = 'TYPE ?  '\n               End\n            If inactflag = 0\n               Then Say  '   ESR 'RIGHT(j,3,0) '('RIGHT(D2X(j),2,0)')',\n                          esrtype esrep sloc esrmisc\n         End\n         Say ' '\n         Say '     Total ESR SVCs this table 'esrsvc\n         Say ' '\n         Say ' '\n      End\nEnd\nSay ' '\nSay 'This system contains 'active' ESR SVCs'\nSay ' '\nSay '  (IGXERROR nucleus address = 'igxerror')'\nSay ' '\nSay 'ESRTABLE processing complete ' TIME()\nSay ' '\nExit\n./ ADD LIST=ALL,NAME=LISTLLT\n/*REXX*/\n/*****************************************************************/\n/* LISTLLT: REXX program to display Linklist Lookaside Table.    */\n/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */\n/*****************************************************************/\n/* MVS DATA AREAS:                                               */\n/*                CVT - Communications Vector Table (@'10'x)     */\n/*                LLT - Linklist Lookaside Table                 */\n/*               DCB3 - Data Control Block (BDAM)                */\n/*                DEB - IOS Data Extent Block                    */\n/*                                                               */\n/*****************************************************************/\n@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */\n@cvt = D2X(C2D(@cvt))                    /* binary to hex             */\n@cvtlink  = STORAGE(D2X(X2D(@cvt)+8),4)      /* get CVTLINK address   */\n@cvtlink  = D2X(C2D(@cvtlink))                 /* binary to hex       */\n@dcbdebad = STORAGE(D2X(X2D(@cvtlink)+44),4)    /* LINKLIB DCB to DEB */\n@dcbdebad = D2X(C2D(@dcbdebad))                 /* convert to hex     */\ndebflgs1  = STORAGE(D2X(X2D(@dcbdebad)+14),1)     /* LINKLIB DEBflags */\n   debapfin = 'LNKLST'\n   If BITAND(debflgs1,'02'x)\\='02'x Then debapfin = 'APFTAB'\n@cvtllta  = STORAGE(D2X(X2D(@cvt)+1244),4)   /* get CVTLLTA address   */\n@cvtllta  = D2X(C2D(@cvtllta))                 /* binary to hex       */\nlltcount  = C2D(STORAGE(D2X(X2D(@cvtllta)+7),1))  /* LLT libraries    */\nlltllen   = C2D(STORAGE(D2X(X2D(@cvtllta)+8),1))  /* length 1st entry */\n@lltentry = X2D(@cvtllta)+9           /* address of 1st LLT entry     */\nAddress TSO ; \"CLEAR\"\nSay 'CVT:'@cvt' CVTLLTA:'@cvtllta' DCB:'@cvtlink,\n    'DEB:'@dcbdebad' FLGS1:'C2X(debflgs1)' LNKAUTH='debapfin\nSay ' '\nSay 'LLT scan on 'DATE()' started: 'TIME()\nSay ' '\nDo i = 1 to lltcount                            /* loop thru storage  */\n   lltlib.i = STORAGE(D2X(@lltentry),lltllen)   /* get the LLT entry  */\n   @lltentry = @lltentry + 45                   /* bump to next entry */\n   lltllen = C2D(STORAGE(D2X(@lltentry-1),1))   /* length of next  */\nEnd\nSay '--------------DATA SET NAME-----------------'\nSay ' '\nDo i = 1 to lltcount                            /* print the list     */\n   Say SUBSTR(lltlib.i,1,44,' ') i\nEnd\nSay ' '\nSay 'LLT scan completed: 'TIME()\nExit\n./ ADD LIST=ALL,NAME=LISTLPAQ\n/*REXX*/\n/*****************************************************************/\n/*LISTLPAQ: REXX program to display LPA Queue (MVS job pack).    */\n/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */\n/*****************************************************************/\n/* MVS DATA AREAS:                                               */\n/*                CVT - Communications Vector Table (@'10'x)     */\n/*                GDA - Global Data Area                         */\n/*               LPAQ - Link Pack Area Queue                     */\n/*                CDE - Contents Directory Entry                 */\n/*                                                               */\n/*****************************************************************/\n/*--------------virtual storage map definition section----------------*/\nNumeric Digits 10           /* required to handle decimal conversions */\n@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */\n@cvt = D2X(C2D(@cvt))                    /* binary to hex             */\n@cvtreal  = STORAGE(D2X(X2D(@cvt)+284),4)    /* get CVTREAL address   */\n@cvtreal  = D2X(C2D(@cvtreal))                 /* binary to hex       */\n@cvtshrvm = STORAGE(D2X(X2D(@cvt)+416),4)    /* get CVTSHRVM address  */\n@cvtshrvm = D2X(C2D(@cvtshrvm))                /* binary to hex       */\n@cvtgda   = STORAGE(D2X(X2D(@cvt)+560),4)    /* get CVTGDA address    */\n@cvtgda   = D2X(C2D(@cvtgda))                  /* binary to hex       */\n@gdacsa   = D2X(X2D(@cvtgda)+108)            /* locate GDACSAstarts   */\n@gdacsa   = D2X(C2D(STORAGE(@gdacsa,4)))       /*  get GDACSA         */\n@gdacsasz = D2X(X2D(@cvtgda)+112)            /* locate GDACSASiZe     */\n@gdacsasz = D2X(C2D(STORAGE(@gdacsasz,4)))     /*  get GDACSASiZe     */\n@gdaecsa  = D2X(X2D(@cvtgda)+124)            /* locate GDAECSAstarts  */\n@gdaecsa  = D2X(C2D(STORAGE(@gdaecsa,4)))      /*  get GDAECSA        */\n@gdaecsas = D2X(X2D(@cvtgda)+128)            /* locate GDAECSASize    */\n@gdaecsas = D2X(C2D(STORAGE(@gdaecsas,4)))     /*  get GDAECSAS       */\n@cvtsmext = STORAGE(D2X(X2D(@cvt)+1196),4)   /* get CVTSMEXT address  */\n@cvtsmext = D2X(C2D(@cvtsmext))                /* binary to hex       */\n@cvtmlpas = D2X(X2D(@cvtsmext)+8)            /* locate CVTMLPAStarts  */\n@cvtmlpas = D2X(C2D(STORAGE(@cvtmlpas,4)))     /*  get CVTMLPAS       */\n@cvtmlpae = D2X(X2D(@cvtsmext)+12)           /* locate CVTMLPAEnds    */\n@cvtmlpae = D2X(C2D(STORAGE(@cvtmlpae,4)))     /*  get CVTMLPAE       */\n@cvtflpas = D2X(X2D(@cvtsmext)+16)           /* locate CVTFLPAStarts  */\n@cvtflpas = D2X(C2D(STORAGE(@cvtflpas,4)))     /*  get CVTFLPAS       */\n@cvtflpae = D2X(X2D(@cvtsmext)+20)           /* locate CVTFLPAEnds    */\n@cvtflpae = D2X(C2D(STORAGE(@cvtflpae,4)))     /*  get CVTFLPAE       */\n@cvtplpas = D2X(X2D(@cvtsmext)+24)           /* locate CVTPLPAStarts  */\n@cvtplpas = D2X(C2D(STORAGE(@cvtplpas,4)))     /*  get CVTPLPAS       */\n@cvtplpae = D2X(X2D(@cvtsmext)+28)           /* locate CVTPLPAEnds    */\n@cvtplpae = D2X(C2D(STORAGE(@cvtplpae,4)))     /*  get CVTPLPAE       */\n@cvtrwns  = D2X(X2D(@cvtsmext)+32)           /* locate CVTRWNStarts   */\n@cvtrwns  = D2X(C2D(STORAGE(@cvtrwns,4)))      /*  get CVTRWNS        */\n@cvtrwne  = D2X(X2D(@cvtsmext)+36)           /* locate CVTRWNEnds     */\n@cvtrwne  = D2X(C2D(STORAGE(@cvtrwne,4)))      /*  get CVTRWNE        */\n@cvtrons  = D2X(X2D(@cvtsmext)+40)           /* locate CVTRONStarts   */\n@cvtrons  = D2X(C2D(STORAGE(@cvtrons,4)))      /*  get CVTRONS        */\n@cvtrone  = D2X(X2D(@cvtsmext)+44)           /* locate CVTRONEnds     */\n@cvtrone  = D2X(C2D(STORAGE(@cvtrone,4)))      /*  get CVTRONE        */\n@cvterwns = D2X(X2D(@cvtsmext)+48)           /* locate CVTERWNStarts  */\n@cvterwns = D2X(C2D(STORAGE(@cvterwns,4)))     /*  get CVTERWNS       */\n@cvterwne = D2X(X2D(@cvtsmext)+52)           /* locate CVTERWNEnds    */\n@cvterwne = D2X(C2D(STORAGE(@cvterwne,4)))     /*  get CVTRRWNE       */\n@cvteplps = D2X(X2D(@cvtsmext)+56)           /* locate CVTEPLPStarts  */\n@cvteplps = D2X(C2D(STORAGE(@cvteplps,4)))     /*  get CVTEPLPS       */\n@cvteplpe = D2X(X2D(@cvtsmext)+60)           /* locate CVTEPLPEnds    */\n@cvteplpe = D2X(C2D(STORAGE(@cvteplpe,4)))     /*  get CVTRPLPE       */\n@cvteflps = D2X(X2D(@cvtsmext)+64)           /* locate CVTEFLPStarts  */\n@cvteflps = D2X(C2D(STORAGE(@cvteflps,4)))     /*  get CVTEFLPS       */\n@cvteflpe = D2X(X2D(@cvtsmext)+68)           /* locate CVTEFLPEnds    */\n@cvteflpe = D2X(C2D(STORAGE(@cvteflpe,4)))     /*  get CVTRFLPE       */\n@cvtemlps = D2X(X2D(@cvtsmext)+72)           /* locate CVTEMLPStarts  */\n@cvtemlps = D2X(C2D(STORAGE(@cvtemlps,4)))     /*  get CVTEMLPS       */\n@cvtemlpe = D2X(X2D(@cvtsmext)+76)           /* locate CVTEMLPEnds    */\n@cvtemlpe = D2X(C2D(STORAGE(@cvtemlpe,4)))     /*  get CVTRMLPE       */\n        /*------simplify variable names & make addresses decimal------*/\n@csa1g  = @gdacsa    ; @csa2g = D2X(X2D(@gdacsasz)+X2D(@gdacsa)-1)/* g*/\n   csa1 = X2D(@csa1g) ; csa2 = X2D(@csa2g)                    /* csa  */\n@mlpa1  = @cvtmlpas  ; @mlpa2 = @cvtmlpae                     /* mlpa */\n   mlpa1 = X2D(@mlpa1) ; mlpa2 = X2D(@mlpa2)\n@flpa1  = @cvtflpas  ; @flpa2 = @cvtflpae                     /* flpa */\n   flpa1 = X2D(@flpa1) ; flpa2 = X2D(@flpa2)\n@plpa1  = @cvtplpas  ; @plpa2 = @cvtplpae                     /* plpa */\n   plpa1 = X2D(@plpa1) ; plpa2 = X2D(@plpa2)\n@sqa1   = D2X(X2D(@cvtplpae)+1) ; @sqa2 = D2X(X2D(@cvtrwns)-1)/* sqa  */\n   sqa1 = X2D(@sqa1) ; sqa2 = X2D(@sqa2)\n@nuc1   = @cvtrwns   ; @nuc2  = @cvterwne                     /* nuc  */\n   nuc1 = X2D(@nuc1) ; nuc2 = X2D(@nuc2)\n@esqa1  = D2X(X2D(@nuc2)+1) ; @esqa2 = D2X(X2D(@cvteplps)-1)  /* esqa */\n  esqa1 = X2D(@esqa1) ; esqa2 = X2D(@esqa2)\n@eplpa1 = @cvteplps  ; @eplpa2 = @cvteplpe                    /* eplpa*/\n eplpa1 = X2D(@eplpa1) ; eplpa2 = X2D(@eplpa2)\n@eflpa1 = @cvteflps  ; @eflpa2 = @cvteflpe                    /* eflpa*/\n eflpa1 = X2D(@eflpa1) ; eflpa2 = X2D(@eflpa2)\n@emlpa1 = @cvtemlps  ; @emlpa2 = @cvtemlpe                    /* emlpa*/\n emlpa1 = X2D(@emlpa1) ; emlpa2 = X2D(@emlpa2)\n@ecsa1g = @gdaecsa   ; @ecsa2g= D2X(X2D(@gdaecsas)+X2D(@gdaecsa)-1)/*g*/\n  ecsa1 = X2D(@ecsa1g) ; ecsa2 = X2D(@ecsa2g)\n@eprivs = X2D(@ecsa2g)+1                               /* ext private */\n@eprive = 2147483647                         /* fixed by architecture */\n epriv1 = @eprivs ; epriv2 = @eprive\n@psas   = 0 ; @psae = 4095                       /* psa fixed by arch */\n   psa1 = @psas ; psa2 = @psae\n@prive  = X2D(@csa1g)-1 ; @privs = X2D(@psae)+1            /* private */\n  priv1 = @privs ; priv2 = @prive\n              /*------------------------------------------------------*/\n             /* Usage Notes: Hex character compares are incompatible */\n            /*    for storage residency determination.  Thus, entry */\n           /*     point addresses must be converted to decimal and */\n          /*      VS boundary addresses must be converted to de-  */\n         /*       cimal for correct compare operations.          */\n        /*------------------------------------------------------*/\n/*----------end of virtual storage map definition section-------------*/\n@cvtqlpaq = STORAGE(D2X(X2D(@cvt)+188),4)    /* get CVTqlpaq address  */\n@cvtqlpaq = D2X(C2D(@cvtqlpaq))                /* binary to hex       */\n@lpaqptr  = STORAGE(@cvtqlpaq,4)             /* get pointer to LPAQ   */\n@lpaqptr  = D2X(C2D(@lpaqptr))                 /* binary to hex       */\nAddress TSO ; \"CLEAR\"\nSay 'CVT:'@cvt' CVTQLPAQ:'@cvtqlpaq' LPAQPTR:'@lpaqptr' 'DATE() TIME()\n@cdechn = @lpaqptr\nSay ' '\ni = 0\nDo While @cdechn \\= '00000000'\n   i = i + 1\n   cde = STORAGE(@cdechn,32)                          /* get the cde */\n   cdname = SUBSTR(cde,9,8)\n   cdentpt= SUBSTR(cde,17,4)\n                                        /* determine storage location */\n   addr = BITAND(cdentpt,'7FFFFFFF'x)     /* shave off amode bit (32) */\n   addr = C2D(addr)                      /* make numeric for compares */\n   sloc = 'ERROR'                       /* determine module residency */\n   If (addr >= csa1   & addr <= csa2  ) Then sloc = 'CSA  '\n      Else If (addr >= mlpa1  & addr <= mlpa2 ) Then sloc = 'MLPA '\n      Else If (addr >= flpa1  & addr <= flpa2 ) Then sloc = 'FLPA '\n      Else If (addr >= plpa1  & addr <= plpa2 ) Then sloc = 'PLPA '\n      Else If (addr >= sqa1   & addr <= sqa2  ) Then sloc = 'SQA  '\n      Else If (addr >= nuc1   & addr <= nuc2  ) Then sloc = 'NUC  '\n      Else If (addr >= esqa1  & addr <= esqa2 ) Then sloc = 'ESQA '\n      Else If (addr >= eplpa1 & addr <= eplpa2) Then sloc = 'EPLPA'\n      Else If (addr >= eflpa1 & addr <= eflpa2) Then sloc = 'EFLPA'\n      Else If (addr >= emlpa1 & addr <= emlpa2) Then sloc = 'EMLPA'\n      Else If (addr >= ecsa1  & addr <= ecsa2 ) Then sloc = 'ECSA '\n      Else If (addr >= epriv1 & addr <= epriv2) Then sloc = 'EPRIV'\n      Else If (addr >= priv1  & addr <= priv2 ) Then sloc = 'PRIV '\n      Else If (addr >= psa1   & addr <= psa2  ) Then sloc = 'PSA  '\n   cdxlmjp= C2X(SUBSTR(cde,21,4))\n   cduse  = C2D(SUBSTR(cde,25,2))\n   cdattr =     SUBSTR(cde,29,1)  /* do NOT convert raw byte */\n   alias = 0 ; If (BITAND(cdattr,'04'x)='04'x) Then alias = 1\n   cdattr2=     SUBSTR(cde,30,1)  /* do NOT convert raw byte */\n   auth = 0 ; If (BITAND(cdattr2,'01'x)='01'x) Then auth = 1\n   cdemjp  = '         '\n   cdemjnm = '        '\n   If alias = 1 Then Do\n                        cdemjp  = ' Alias of'\n                        cdemjnm = STORAGE(D2X(X2D(cdxlmjp)+8),8)\n                     End\n   Say 'LPAQ'RIGHT(i,4,0),\n       cdname ,\n       C2X(cdentpt) ,\n       sloc ,\n       'USE:'RIGHT(cduse,5,0) ,\n        'AC:'auth ,\n        cdemjp cdemjnm\n   @cdechn = C2X(LEFT(cde,4))                 /* get next cde address */\nEnd\nSay ' '\nSay 'End of LPA Queue scan ' TIME()\nExit\n./ ADD LIST=ALL,NAME=LISTLPAT\n/*REXX*/\n/*****************************************************************/\n/*LISTLPAT: REXX program to display LPA libraries.               */\n/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */\n/*****************************************************************/\n/* MVS DATA AREAS:                                               */\n/*                CVT - Communications Vector Table (@'10'x)     */\n/*               LPAT - Link Pack Area (libraries) Table         */\n/*                                                               */\n/*                                                               */\n/*                                                               */\n/*****************************************************************/\n@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */\n@cvt = D2X(C2D(@cvt))                    /* binary to hex             */\n@cvtsmext = STORAGE(D2X(X2D(@cvt)+1196),4)   /* get CVTSMEXT address  */\n@cvtsmext = D2X(C2D(@cvtsmext))                /* binary to hex       */\n@cvteplps = D2X(X2D(@cvtsmext)+56)           /* get CVTEPLPS address  */\n@cvteplps = STORAGE(@cvteplps,4)             /* get LPAT address      */\n@cvteplps = D2X(C2D(@cvteplps))                /* binary to hex       */\nlpatcount = C2D(STORAGE(D2X(X2D(@cvteplps)+4),4)) /* LPAT entries     */\nlpatlen   = C2D(STORAGE(D2X(X2D(@cvteplps)+8),1)) /* length 1st entry */\n@lpatentry= X2D(@cvteplps)+9          /* address of 1st LPAT entry    */\nSay 'CVT:'@cvt  'CVTSMEXT:'@cvtsmext'  CVTEPLPS:'@cvteplps,\n    '  'DATE() TIME()\nSay ' '\nSay 'The LPAT table contains 'lpatcount 'entries, as follows:'\nSay ' '\nDo i = 1 to lpatcount                           /* loop thru storage  */\n   lpatlib.i = STORAGE(D2X(@lpatentry),lpatlen) /* get the LLT entry  */\n   @lpatentry = @lpatentry + 45                 /* bump to next entry */\n   lpatlen = C2D(STORAGE(D2X(@lpatentry-1),1))  /* length of next     */\nEnd\nSay '--------------DATA SET NAME-----------------'\nSay ' '\nDo i = 1 to lpatcount                           /* print the list     */\n   Say SUBSTR(lpatlib.i,1,44,' ') i\nEnd\nExit\n./ ADD LIST=ALL,NAME=LISTNUCM\n/*REXX*/\n/*****************************************************************/\n/*LISTNUCM: REXX program to display the nucleus map.             */\n/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */\n/*****************************************************************/\n/* MVS DATA AREAS:                                               */\n/*                CVT - Communications Vector Table (@'10'x)     */\n/*              NUCMP - Nucleus Map Table (16 bytes by n rows)   */\n/*                                                               */\n/*****************************************************************/\nNumeric Digits 10\n@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */\n@cvt = D2X(C2D(@cvt))                    /* binary to hex             */\n@cvtnucmp = STORAGE(D2X(X2D(@cvt)+1200),4)   /* get CVTNUCMP address  */\n@cvtnucmp = D2X(C2D(@cvtnucmp))                /* binary to hex       */\nnucmapid  = STORAGE(@cvtnucmp,8)           /* nucmap eyecatcher entry */\nnucmeot   = C2D(STORAGE(D2X(X2D(@cvtnucmp)+8),4))  /* table end addrs */\nnucmlen   = C2D(STORAGE(D2X(X2D(@cvtnucmp)+13),3)) /* nucm tbl length */\n@nucmentry= X2D(@cvtnucmp)+16          /* address of 1st nucmap entry */\nAddress TSO ; 'CLEAR'\nSay 'CVT:'@cvt  'CVTNUCMP:'@cvtnucmp'  NUCMLEN:'nucmlen' bytes',\n    '  'DATE() TIME()\nSay ' '\nIf nucmapid \\= 'NUCMAP  ' Then Do\n   Say 'Error: Nucleus map table eyecatcher not found'\n   Exit\n   End\ni = 0\nSay 'The Nucleus Map table follows:'\nSay ' '\nDo While @nucmentry <= nucmeot                  /* loop thru storage  */\n   i = i + 1\n   epname.i = STORAGE(D2X(@nucmentry),8)      /* get entry point name */\n   epaddr.i = C2X(STORAGE(D2X(@nucmentry+8),4))     /* get ep address */\n   epflag.i = STORAGE(D2X(@nucmentry+12),1)      /* get raw flag byte */\n   eplen.i  = C2X(STORAGE(D2X(@nucmentry+13),3))     /* get ep length */\n   @nucmentry = @nucmentry + 16                 /* bump to next entry */\nEnd\nentries = i\n/*--------------------------------------------------------------*/\n/* epflag byte structure:                                       */\n/*                                                              */\n/*           XXXX XXXX --> epflag byte                          */\n/*           |||| ||||                                          */\n/*           |||| ||++---- AMODE 00/01=24, 10=31, 11=ANY        */\n/*           |||| |+------ RMODE 0=24, 1=ANY                    */\n/*           |||| +------- RSECT 1=yes                          */\n/*           |||+--------- CSECT 1=yes                          */\n/*           +++---------- unused                               */\n/*--------------------------------------------------------------*/\nSay 'Entry --Name-- -EPaddr- CSECT RSECT RMODE AMODE Length'\nSay ' '\nDo i = 1 to entries                             /* print the list     */\n   csect = '     ' ; rsect = '     ' ; rmode = '  24 ' ; amode = '  24 '\n   If BITAND(epflag.i,'10'x)='10'x Then csect = '  Y  '\n   If BITAND(epflag.i,'08'x)='08'x Then rsect = '  Y  ' /* read only  */\n   If BITAND(epflag.i,'04'x)='04'x Then rmode = ' Any ' /* residency  */\n   If BITAND(epflag.i,'02'x)='02'x Then amode = '  31 ' /* addressing */\n   If BITAND(epflag.i,'03'x)='03'x Then amode = ' Any ' /* addressing */\n   Say ' 'Right(i,4,0) epname.i epaddr.i csect rsect rmode amode eplen.i\nEnd\nExit\n./ ADD LIST=ALL,NAME=LISTPART\n/*REXX*/\n/*****************************************************************/\n/*LISTPART: REXX program to show ASM paging data set status.     */\n/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */\n/*****************************************************************/\n/* MVS DATA AREAS:                                               */\n/*                CVT - Communications Vector Table (@'10'x)     */\n/*              ASMVT - ASM Vector Table                         */\n/*               PART - ASM Paging Activity Reference Table      */\n/*                                                               */\n/*****************************************************************/\n@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */\n@cvt = D2X(C2D(@cvt))                         /* binary to dec to hex */\n@cvtasmvt = STORAGE(D2X(X2D(@cvt)+704),4)     /* get CVTASMVT address */\n@asmvt    = RIGHT(C2X(@cvtasmvt),7)                   /* trim address */\n@asmpart  = STORAGE(D2X(X2D(@asmvt)+8),4)         /* get PART address */\n@part     = RIGHT(C2X(@asmpart),7)                    /* trim address */\npartsize  = STORAGE(D2X(X2D(@part)+4),4)      /* get number of PART's */\npartsize  = C2D(partsize)                            /* binary to dec */\n@partdsnl = STORAGE(D2X(X2D(@part)+24),4)     /* get dsn list address */\n@partdsnl = RIGHT(C2X(@partdsnl),7)                   /* trim address */\npartlcnt  = STORAGE(D2X(X2D(@part)+32),2)     /* get number of locals */\npartlcnt  = C2D(partlcnt)                            /* binary to dec */\n@partplpa = STORAGE(D2X(X2D(@part)+48),4)      /* get plpa part entry */\n@partplpa = RIGHT(C2X(@partplpa),7)                   /* trim address */\n@partloca = STORAGE(D2X(X2D(@part)+52),4)      /* get 1st local entry */\n@partloca = RIGHT(C2X(@partloca),7)                   /* trim address */\n@partlsta = STORAGE(D2X(X2D(@part)+56),4)      /* get last locl entry */\n@partlsta = RIGHT(C2X(@partlsta),7)                   /* trim address */\n@partents  = STORAGE(D2X(X2D(@part)+80),4)      /* get 1st part entry */\n@partents = RIGHT(C2X(@partents),7)                   /* trim address */\nAddress TSO ; \"CLEAR\"\nSay 'CVT:'@cvt' CVTASMVT:'@asmvt ' ASMPART:'@part'   'TIME() DATE()\nSay ' '\nSay 'The PART table starts at '@partplpa' and contains 'partsize' entries.'\nSay ' '\np = 0 ; i = 0 ; @partix = @partplpa ; @dsnl = @partdsnl\nDo p = 1 To partsize                           /* scan the PART table */\n   pareflg1 = STORAGE(D2X(X2D(@partix)+9),1)         /* get flag byte */\n   If BITAND(pareflg1,'80'x) \\= '80'x Then Do  /* process in use only */\n      i = i + 1                              /* count active pageds's */\n      pagedsn  = STORAGE(@dsnl,44)         /* pickup the dsn from csa */\n      paretype = STORAGE(D2X(X2D(@partix)+8),1)      /* get type byte */\n      ptype = '??????'\n      If BITAND(paretype,'80'x) = '80'x Then ptype = 'PLPA  '\n      If BITAND(paretype,'40'x) = '40'x Then ptype = 'Common'\n      If BITAND(paretype,'20'x) = '20'x Then ptype = 'Duplex'\n      If BITAND(paretype,'10'x) = '10'x Then ptype = 'Local '\n      pareszsl = STORAGE(D2X(X2D(@partix)+16),4) /* get size in slots */\n      pareszsl = C2D(pareszsl)\n      pareslta = STORAGE(D2X(X2D(@partix)+20),4)   /* slots available */\n      pareslta = C2D(pareslta) ; used = pareszsl - pareslta\n      pctused  = TRUNC((used*100)/pareszsl,0)\n      pctused  ='('RIGHT(pctused,3)'%)'\n      @pareucbp = STORAGE(D2X(X2D(@partix)+44),4)  /* get UCB address */\n      pioaddr  = STORAGE(D2X(C2D(@pareucbp)+4),2)  /* channel address */\n      pioaddr  = RIGHT(C2X(pioaddr),3)\n      pvolser  = STORAGE(D2X(C2D(@pareucbp)+28),6)     /* dasd volser */\n      Say RIGHT(i,2) pagedsn ptype RIGHT(pareszsl,5) pctused pvolser pioaddr\n   End\n   @partix = D2X(X2D(@partix)+96)          /* bump to next PART entry */\n   @dsnl   = D2X(X2D(@dsnl)+44)             /* bump to next DSN entry */\nEnd\nSay ' '\nSay 'Paging activity table analysis completed: 'TIME()\nExit\n./ ADD LIST=ALL,NAME=LISTPDSD\n/*REXX*/\n/*****************************************************************/\n/*LISTPDSD: REXX program to display PDS directory records.       */\n/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */\n/*****************************************************************/\n/* MVS DATA AREAS:                                               */\n/*                 -none-                                        */\n/*                                                               */\n/*                                                               */\n/*                                                               */\n/*                                                               */\n/*****************************************************************/\nAddress TSO\ndsn = 'SYS1.SORTLIB'                    /* Fake out DCB of PO */\n\"ALLOC F(PDS) DA('\"dsn\"') SHR DSORG(PS) LRECL(256) BLKSIZE(256) RECFM(F)\"\nNewstack\n'EXECIO * DISKR PDS ( FINIS'\nQueue '*EOF*'\ni = 0\nDo While i < 10\n   i = i + 1\n   Pull line\n   If LEFT(line,5) = '*EOF*' Then Leave\n   dirblock = C2X(line)\n   blocklen = X2D(C2X(SUBSTR(line,1,2)))\n   If blocklen = 0 Then Leave\n   Say 'DIRBLOCK No. 'i'  RC = 'RC,\n       ' DIRBLOCK Length = 'LENGTH(line)'  DIRDATA length = 'blocklen\n   Say ' '\n   Say 'Data: 'SUBSTR(dirblock,001,60)' *'SUBSTR(line,001,30)'*'\n   Say '      'SUBSTR(dirblock,061,60)' *'SUBSTR(line,031,30)'*'\n   Say '      'SUBSTR(dirblock,121,60)' *'SUBSTR(line,061,30)'*'\n   Say '      'SUBSTR(dirblock,181,60)' *'SUBSTR(line,091,30)'*'\n   Say '      'SUBSTR(dirblock,241,60)' *'SUBSTR(line,121,30)'*'\n   Say '      'SUBSTR(dirblock,301,60)' *'SUBSTR(line,151,30)'*'\n   Say '      'SUBSTR(dirblock,361,60)' *'SUBSTR(line,181,30)'*'\n   Say '      'SUBSTR(dirblock,421,60)' *'SUBSTR(line,211,30)'*'\n   Say '      'SUBSTR(dirblock,481,32),\n       '                          ',\n       ' *'SUBSTR(line,241,16),\n       '             *'\n   Say ' '\n   Say 'Linear block dump follows:'\n   Say ' '\n   y = 0\n   Do y = 1 to 256\n      Say '   DIRBLOCK byte 'RIGHT(y,3,0),\n          ' Char:'SUBSTR(line,y,1),\n          ' Hex:'C2X(SUBSTR(line,y,1)),\n          ' Dec:'C2D(SUBSTR(line,y,1))\n   End\n   Say ' '\nEnd\nDelstack\n\"FREE F(PDS)\"\nExit\n./ ADD LIST=ALL,NAME=LISTPDSM\n/*REXX*/\n/*****************************************************************/\n/*LISTPDSM: REXX program to display all PDS member information.  */\n/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */\n/*****************************************************************/\n/* MVS DATA AREAS:                                               */\n/*                PDS - Partitioned Data Set (entry)             */\n/*                                                               */\n/*                                                               */\n/*                                                               */\n/*                                                               */\n/*****************************************************************/\nAddress TSO\ndsn = 'SYS2.LINKLIB'                    /* Fake out DCB of PO */\n\"ALLOC F(PDS) DA('\"dsn\"') SHR DSORG(PS) LRECL(256) BLKSIZE(256) RECFM(F)\"\nNewstack\n'EXECIO * DISKR PDS ( FINIS'\nQueue '*EOF*'\ni = 0\nlast = 0     /* flags when the no more members indicator is detected */\nmemcount = 0\nSay 'Date: 'DATE()' PDS: 'dsn\nDo While i < 1000 & last \\= 1  /* had to pick some limit */\n   i = i + 1\n   Pull line\n   If LEFT(line,5) = '*EOF*' Then Leave\n   blocklen = X2D(C2X(SUBSTR(line,1,2)))  /* Not proud of this logic, */\n   If blocklen = 0 or last = 1 Then Leave /* but seems to work --vlc  */\n   ix = 3                          /* Initialize DIRBLOCK parse index */\n   Do While ix < blocklen & last \\= 1          /* parse this DIRBLOCK */\n      pds2ftb1 = '00'x                         /* initialize apf not  */\n      pds2mnm  = '        '                    /* initialize alias of */\n      pds2name = SUBSTR(line,ix,8)  ; ix = ix + 8     /* main section */\n      pds2ttrp = SUBSTR(line,ix,3)  ; ix = ix + 3\n      pds2indc = SUBSTR(line,ix,1)  ; ix = ix + 1\n      udl = 0                           /* calculate user data length */\n      If BITAND(pds2indc,'01'x) = '01'x Then udl = 1\n      If BITAND(pds2indc,'02'x) = '02'x Then udl = udl + 2\n      If BITAND(pds2indc,'04'x) = '04'x Then udl = udl + 4\n      If BITAND(pds2indc,'08'x) = '08'x Then udl = udl + 8\n      If BITAND(pds2indc,'10'x) = '10'x Then udl = udl + 16\n      udl = udl * 2                 /* finish calc halfwords to bytes */\n      If udl >= 22 Then Do               /* only process likely stuff */\n         ix = ix + 8             /* adjust index to skip misc 8 bytes */\n         pds2atr1 = SUBSTR(line,ix,1) ; ix = ix + 1\n         pds2atr2 = SUBSTR(line,ix,1) ; ix = ix + 1\n         pds2stor = SUBSTR(line,ix,3) ; ix = ix + 3\n         ix = ix + 2             /* adjust index to skip misc 2 bytes */\n         pds2epa  = SUBSTR(line,ix,3) ; ix = ix + 3\n         pds2ftb1 = SUBSTR(line,ix,1) ; ix = ix + 1\n         ix = ix + 2             /* adjust index to skip misc 2 bytes */\n                                                      /* scatter sect */\n         If BITAND(pds2atr1,'04'x) = '04'x Then Do\n            pds2scat = SUBSTR(line,ix+33,8)\n            ix = ix + 8\n            End\n                                                        /* alias sect */\n         If BITAND(pds2indc,'80'x) = '80'x Then Do\n            If udl >= 32 Then Do\n               pds2epm  = SUBSTR(line,ix,3) ; ix = ix + 3\n               pds2mnm  = SUBSTR(line,ix,8) ; ix = ix + 8\n               End\n            Else Do\n               Say '*** WARNING - Missing major for alias 'pds2name' DBLK:'i\n               pds2epm = '000000'x\n               pds2mnm = '????????'\n               End\n            End\n                                                       /* ssi section */\n         If BITAND(pds2ftb1,'10'x) = '10'x Then Do\n            If (ix-1)//2 \\= 0 Then ix = ix + 1    /* halfword alignmt */\n            pdsssiwd = SUBSTR(line,ix,4) ; ix = ix + 4\n            End\n                                                       /* apf section */\n         If BITAND(pds2ftb1,'08'x) \\= '08'x Then pdsapfac = ' '/* none*/\n         Else Do                                         /* maybe apf */\n            pdsapfct = SUBSTR(line,ix,1)\n            If pdsapfct = '01'x Then Do                /* NORMAL path */\n               ix = ix + 1\n               pdsapfac = SUBSTR(line,ix,1)\n               ix = ix + 1\n               If pdsapfac \\= '00'x & pdsapfac \\= '01'x Then Do\n                  Say '*** WARNING - Invalid AC for 'pds2name' DBLK:'i\n                  nop\n                  End\n               End\n            If pdsapfct \\= '01'x & (BITAND(pds2indc,'80'x)='80'x) Then Do\n               pdsapfac=' '\n               ix = ix - 8\n               Say '*** WARNING - Compacted alias logic for 'pds2name' DBLK:'i\n               End\n            End\n         End\n      Else Do                              /* too short udl, leave it */\n         ix = ix + udl\n         If pds2name = 'FFFFFFFFFFFFFFFF'x Then Do\n            last = 1\n            Leave\n            End\n         Say '*** WARNING - too short udl for 'pds2name' DBLK:'i\n         pds2atr1 = '00'x\n         pds2atr2 = '00'x\n         pds2stor = '000000'x\n         pds2mnm  = '        '\n         pdsapfac = ' '\n         End\n      If (ix-1)//2 \\= 0 Then ix = ix + 1          /* halfword alignmt */\n      If pds2name = 'FFFFFFFFFFFFFFFF'x Then Do\n         last = 1\n         Leave\n         End\n      If pds2name \\= '0000000000000000'x Then Do\n         memcount = memcount + 1\n         Say RIGHT(memcount,4,0) pds2name' TTR:'C2X(pds2ttrp),\n             ' INDC:'C2X(pds2indc)' ATRBs:'C2X(pds2atr1),\n             C2X(pds2atr2)' SIZE:'C2X(pds2stor),\n             ' MAJ:'pds2mnm' AC:'C2X(pdsapfac),\n             ' DBLK:'RIGHT(i,4,0)' UDL:'RIGHT(udl,2,0),\n             ' IX:'RIGHT(ix,3,0)\n         End\n   End                                         /* DIRBLOCK parse done */\nEnd\nDelstack\n\"FREE F(PDS)\"\nExit\n./ ADD LIST=ALL,NAME=LISTPLPA\n/*REXX*/\n/*****************************************************************/\n/*LISTPLPA: REXX program to display PLPA directory table.        */\n/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */\n/*****************************************************************/\n/* MVS DATA AREAS:                                               */\n/*                CVT - Communications Vector Table (@'10'x)     */\n/*                GDA - Global Data Area                         */\n/*               LPDE - Link Pack Directory Entry                */\n/*                                                               */\n/*****************************************************************/\n/*--------------virtual storage map definition section----------------*/\nNumeric Digits 10           /* required to handle decimal conversions */\n@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */\n@cvt = D2X(C2D(@cvt))                    /* binary to hex             */\n@cvtreal  = STORAGE(D2X(X2D(@cvt)+284),4)    /* get CVTREAL address   */\n@cvtreal  = D2X(C2D(@cvtreal))                 /* binary to hex       */\n@cvtshrvm = STORAGE(D2X(X2D(@cvt)+416),4)    /* get CVTSHRVM address  */\n@cvtshrvm = D2X(C2D(@cvtshrvm))                /* binary to hex       */\n@cvtgda   = STORAGE(D2X(X2D(@cvt)+560),4)    /* get CVTGDA address    */\n@cvtgda   = D2X(C2D(@cvtgda))                  /* binary to hex       */\n@gdacsa   = D2X(X2D(@cvtgda)+108)            /* locate GDACSAstarts   */\n@gdacsa   = D2X(C2D(STORAGE(@gdacsa,4)))       /*  get GDACSA         */\n@gdacsasz = D2X(X2D(@cvtgda)+112)            /* locate GDACSASiZe     */\n@gdacsasz = D2X(C2D(STORAGE(@gdacsasz,4)))     /*  get GDACSASiZe     */\n@gdaecsa  = D2X(X2D(@cvtgda)+124)            /* locate GDAECSAstarts  */\n@gdaecsa  = D2X(C2D(STORAGE(@gdaecsa,4)))      /*  get GDAECSA        */\n@gdaecsas = D2X(X2D(@cvtgda)+128)            /* locate GDAECSASize    */\n@gdaecsas = D2X(C2D(STORAGE(@gdaecsas,4)))     /*  get GDAECSAS       */\n@cvtsmext = STORAGE(D2X(X2D(@cvt)+1196),4)   /* get CVTSMEXT address  */\n@cvtsmext = D2X(C2D(@cvtsmext))                /* binary to hex       */\n@cvtmlpas = D2X(X2D(@cvtsmext)+8)            /* locate CVTMLPAStarts  */\n@cvtmlpas = D2X(C2D(STORAGE(@cvtmlpas,4)))     /*  get CVTMLPAS       */\n@cvtmlpae = D2X(X2D(@cvtsmext)+12)           /* locate CVTMLPAEnds    */\n@cvtmlpae = D2X(C2D(STORAGE(@cvtmlpae,4)))     /*  get CVTMLPAE       */\n@cvtflpas = D2X(X2D(@cvtsmext)+16)           /* locate CVTFLPAStarts  */\n@cvtflpas = D2X(C2D(STORAGE(@cvtflpas,4)))     /*  get CVTFLPAS       */\n@cvtflpae = D2X(X2D(@cvtsmext)+20)           /* locate CVTFLPAEnds    */\n@cvtflpae = D2X(C2D(STORAGE(@cvtflpae,4)))     /*  get CVTFLPAE       */\n@cvtplpas = D2X(X2D(@cvtsmext)+24)           /* locate CVTPLPAStarts  */\n@cvtplpas = D2X(C2D(STORAGE(@cvtplpas,4)))     /*  get CVTPLPAS       */\n@cvtplpae = D2X(X2D(@cvtsmext)+28)           /* locate CVTPLPAEnds    */\n@cvtplpae = D2X(C2D(STORAGE(@cvtplpae,4)))     /*  get CVTPLPAE       */\n@cvtrwns  = D2X(X2D(@cvtsmext)+32)           /* locate CVTRWNStarts   */\n@cvtrwns  = D2X(C2D(STORAGE(@cvtrwns,4)))      /*  get CVTRWNS        */\n@cvtrwne  = D2X(X2D(@cvtsmext)+36)           /* locate CVTRWNEnds     */\n@cvtrwne  = D2X(C2D(STORAGE(@cvtrwne,4)))      /*  get CVTRWNE        */\n@cvtrons  = D2X(X2D(@cvtsmext)+40)           /* locate CVTRONStarts   */\n@cvtrons  = D2X(C2D(STORAGE(@cvtrons,4)))      /*  get CVTRONS        */\n@cvtrone  = D2X(X2D(@cvtsmext)+44)           /* locate CVTRONEnds     */\n@cvtrone  = D2X(C2D(STORAGE(@cvtrone,4)))      /*  get CVTRONE        */\n@cvterwns = D2X(X2D(@cvtsmext)+48)           /* locate CVTERWNStarts  */\n@cvterwns = D2X(C2D(STORAGE(@cvterwns,4)))     /*  get CVTERWNS       */\n@cvterwne = D2X(X2D(@cvtsmext)+52)           /* locate CVTERWNEnds    */\n@cvterwne = D2X(C2D(STORAGE(@cvterwne,4)))     /*  get CVTRRWNE       */\n@cvteplps = D2X(X2D(@cvtsmext)+56)           /* locate CVTEPLPStarts  */\n@cvteplps = D2X(C2D(STORAGE(@cvteplps,4)))     /*  get CVTEPLPS       */\n@cvteplpe = D2X(X2D(@cvtsmext)+60)           /* locate CVTEPLPEnds    */\n@cvteplpe = D2X(C2D(STORAGE(@cvteplpe,4)))     /*  get CVTRPLPE       */\n@cvteflps = D2X(X2D(@cvtsmext)+64)           /* locate CVTEFLPStarts  */\n@cvteflps = D2X(C2D(STORAGE(@cvteflps,4)))     /*  get CVTEFLPS       */\n@cvteflpe = D2X(X2D(@cvtsmext)+68)           /* locate CVTEFLPEnds    */\n@cvteflpe = D2X(C2D(STORAGE(@cvteflpe,4)))     /*  get CVTRFLPE       */\n@cvtemlps = D2X(X2D(@cvtsmext)+72)           /* locate CVTEMLPStarts  */\n@cvtemlps = D2X(C2D(STORAGE(@cvtemlps,4)))     /*  get CVTEMLPS       */\n@cvtemlpe = D2X(X2D(@cvtsmext)+76)           /* locate CVTEMLPEnds    */\n@cvtemlpe = D2X(C2D(STORAGE(@cvtemlpe,4)))     /*  get CVTRMLPE       */\n        /*------simplify variable names & make addresses decimal------*/\n@csa1g  = @gdacsa    ; @csa2g = D2X(X2D(@gdacsasz)+X2D(@gdacsa)-1)/* g*/\n   csa1 = X2D(@csa1g) ; csa2 = X2D(@csa2g)                    /* csa  */\n@mlpa1  = @cvtmlpas  ; @mlpa2 = @cvtmlpae                     /* mlpa */\n   mlpa1 = X2D(@mlpa1) ; mlpa2 = X2D(@mlpa2)\n@flpa1  = @cvtflpas  ; @flpa2 = @cvtflpae                     /* flpa */\n   flpa1 = X2D(@flpa1) ; flpa2 = X2D(@flpa2)\n@plpa1  = @cvtplpas  ; @plpa2 = @cvtplpae                     /* plpa */\n   plpa1 = X2D(@plpa1) ; plpa2 = X2D(@plpa2)\n@sqa1   = D2X(X2D(@cvtplpae)+1) ; @sqa2 = D2X(X2D(@cvtrwns)-1)/* sqa  */\n   sqa1 = X2D(@sqa1) ; sqa2 = X2D(@sqa2)\n@nuc1   = @cvtrwns   ; @nuc2  = @cvterwne                     /* nuc  */\n   nuc1 = X2D(@nuc1) ; nuc2 = X2D(@nuc2)\n@esqa1  = D2X(X2D(@nuc2)+1) ; @esqa2 = D2X(X2D(@cvteplps)-1)  /* esqa */\n  esqa1 = X2D(@esqa1) ; esqa2 = X2D(@esqa2)\n@eplpa1 = @cvteplps  ; @eplpa2 = @cvteplpe                    /* eplpa*/\n eplpa1 = X2D(@eplpa1) ; eplpa2 = X2D(@eplpa2)\n@eflpa1 = @cvteflps  ; @eflpa2 = @cvteflpe                    /* eflpa*/\n eflpa1 = X2D(@eflpa1) ; eflpa2 = X2D(@eflpa2)\n@emlpa1 = @cvtemlps  ; @emlpa2 = @cvtemlpe                    /* emlpa*/\n emlpa1 = X2D(@emlpa1) ; emlpa2 = X2D(@emlpa2)\n@ecsa1g = @gdaecsa   ; @ecsa2g= D2X(X2D(@gdaecsas)+X2D(@gdaecsa)-1)/*g*/\n  ecsa1 = X2D(@ecsa1g) ; ecsa2 = X2D(@ecsa2g)\n@eprivs = X2D(@ecsa2g)+1                               /* ext private */\n@eprive = 2147483647                         /* fixed by architecture */\n epriv1 = @eprivs ; epriv2 = @eprive\n@psas   = 0 ; @psae = 4095                       /* psa fixed by arch */\n   psa1 = @psas ; psa2 = @psae\n@prive  = X2D(@csa1g)-1 ; @privs = X2D(@psae)+1            /* private */\n  priv1 = @privs ; priv2 = @prive\n              /*------------------------------------------------------*/\n             /* Usage Notes: Hex character compares are incompatible */\n            /*    for storage residency determination.  Thus, entry */\n           /*     point addresses must be converted to decimal and */\n          /*      VS boundary addresses must be converted to de-  */\n         /*       cimal for correct compare operations.          */\n        /*------------------------------------------------------*/\n/*----------end of virtual storage map definition section-------------*/\n@cvtlpdir = STORAGE(D2X(X2D(@cvt)+361),3)    /* get CVTLPDIR address  */\n@cvtlpdir = D2X(C2D(@cvtlpdir))                /* binary to hex       */\nAddress TSO ; \"CLEAR\"\nSay 'CVT:'@cvt' CVTLPDIR:'@cvtlpdir'  'DATE() TIME()\n@lpdechn = @cvtlpdir\nSay ' '\ni = 0 ; eot = '00000000000000000000000000000000'\nDo While i < 10000                                 /* arbitrary limit */\n   lpde = STORAGE(@lpdechn,40)                        /* get the lpde */\n   If C2X(SUBSTR(lpde,1,16))=eot Then Leave           /* end of table */\n   i = i + 1\n   module = SUBSTR(lpde,9,8)\n   entry  = SUBSTR(lpde,17,4)\n                                        /* determine storage location */\n   addr = BITAND(entry,'7FFFFFFF'x)       /* shave off amode bit (32) */\n   addr = C2D(addr)                      /* make numeric for compares */\n   sloc = 'ERROR'                       /* determine module residency */\n   If (addr >= csa1   & addr <= csa2  ) Then sloc = 'CSA  '\n      Else If (addr >= mlpa1  & addr <= mlpa2 ) Then sloc = 'MLPA '\n      Else If (addr >= flpa1  & addr <= flpa2 ) Then sloc = 'FLPA '\n      Else If (addr >= plpa1  & addr <= plpa2 ) Then sloc = 'PLPA '\n      Else If (addr >= sqa1   & addr <= sqa2  ) Then sloc = 'SQA  '\n      Else If (addr >= nuc1   & addr <= nuc2  ) Then sloc = 'NUC  '\n      Else If (addr >= esqa1  & addr <= esqa2 ) Then sloc = 'ESQA '\n      Else If (addr >= eplpa1 & addr <= eplpa2) Then sloc = 'EPLPA'\n      Else If (addr >= eflpa1 & addr <= eflpa2) Then sloc = 'EFLPA'\n      Else If (addr >= emlpa1 & addr <= emlpa2) Then sloc = 'EMLPA'\n      Else If (addr >= ecsa1  & addr <= ecsa2 ) Then sloc = 'ECSA '\n      Else If (addr >= epriv1 & addr <= epriv2) Then sloc = 'EPRIV'\n      Else If (addr >= priv1  & addr <= priv2 ) Then sloc = 'PRIV '\n      Else If (addr >= psa1   & addr <= psa2  ) Then sloc = 'PSA  '\n   size   = C2X(SUBSTR(lpde,33,4))\n   att2   =     SUBSTR(lpde,30,1)\n   auth = 0 ; If (BITAND(att2,'01'x)='01'x) Then auth = 1\n   lpdemjp  = '         '\n   lpdemjnm = '        '\n   If C2D(SUBSTR(lpde,21,4)) \\= 0 Then\n      Do\n         lpdemjp  = ' Alias of'\n         lpdemjnm = SUBSTR(lpde,33,8)\n             size = '        '\n      End\n   Say 'PLPA'RIGHT(i,4,0) ,\n       module ,\n       C2X(entry) ,\n       sloc ,\n       'SIZE:'RIGHT(size,8,0) ,\n       'AC:'auth ,\n       lpdemjp lpdemjnm\n   @lpdechn = D2X(X2D(@lpdechn)+40)         /* address of next LPDE */\nEnd\nSay ' '\nSay 'LPDE table scan completed 'TIME()\nExit\n./ ADD LIST=ALL,NAME=LISTSART\n/*REXX*/\n/*****************************************************************/\n/*LISTSART: REXX program to show ASM swapping data set status.   */\n/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */\n/*****************************************************************/\n/* MVS DATA AREAS:                                               */\n/*                CVT - Communications Vector Table (@'10'x)     */\n/*              ASMVT - ASM Vector Table                         */\n/*               SART - ASM Swapping Activity Reference Table    */\n/*                                                               */\n/*****************************************************************/\n@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */\n@cvt = D2X(C2D(@cvt))                         /* binary to dec to hex */\n@cvtasmvt = STORAGE(D2X(X2D(@cvt)+704),4)     /* get CVTASMVT address */\n@asmvt    = RIGHT(C2X(@cvtasmvt),7)                   /* trim address */\n@asmsart  = STORAGE(D2X(X2D(@asmvt)+4),4)         /* get SART address */\n@sart     = RIGHT(C2X(@asmsart),7)                    /* trim address */\nsartsize  = STORAGE(D2X(X2D(@sart)+4),4)      /* get number of SART's */\nsartsize  = C2D(sartsize)                            /* binary to dec */\n@sardsnl  = STORAGE(D2X(X2D(@sart)+24),4)     /* get dsn list address */\n@sardsnl  = RIGHT(C2X(@sardsnl),7)                    /* trim address */\n@sarfrsta = STORAGE(D2X(X2D(@sart)+60),4)       /* get 1st sart entry */\n@sarfrsta = RIGHT(C2X(@sarfrsta),7)                   /* trim address */\nAddress TSO ; \"CLEAR\"\nSay 'CVT:'@cvt' CVTASMVT:'@asmvt ' ASMSART:'@sart'   'TIME() DATE()\nSay ' '\nSay 'The SART table starts at '@sarfrsta' and contains 'sartsize' entries.'\nSay ' '\ns = 0 ; i = 0 ; @sartix = @sarfrsta ; @dsnl = @sardsnl\nDo s = 1 To sartsize                           /* scan the SART table */\n   sreflg = STORAGE(D2X(X2D(@sartix)+9),1)           /* get flag byte */\n   If BITAND(sarflg,'80'x) \\= '80'x Then Do    /* process in use only */\n      i = i + 1                              /* count active swapds's */\n      swapdsn  = STORAGE(@dsnl,44)         /* pickup the dsn from csa */\n      sretotsl = STORAGE(D2X(X2D(@sartix)+16),4) /* get size in slots */\n      sretotsl = C2D(sretotsl)\n      sreavlsl = STORAGE(D2X(X2D(@sartix)+20),4)   /* slots available */\n      sreavlsl = C2D(sreavlsl) ; used = sretotsl - sreavlsl\n      If sretotsl > 0 Then pctused = TRUNC((used*100)/sretotsl,0)\n                      Else pctused = 0\n      pctused  ='('RIGHT(pctused,3)'%)'\n      @sreucb  = STORAGE(D2X(X2D(@sartix)+44),4)   /* get UCB address */\n      sioaddr  = STORAGE(D2X(C2D(@sreucb)+4),2)    /* channel address */\n      sioaddr  = RIGHT(C2X(sioaddr),3)\n      svolser  = STORAGE(D2X(C2D(@sreucb)+28),6)       /* dasd volser */\n      If sretotsl > 0 Then Say RIGHT(i,2) swapdsn RIGHT(sretotsl,5),\n                               pctused svolser sioaddr\n   End\n   @sartix = D2X(X2D(@sartix)+80)          /* bump to next SART entry */\n   @dsnl   = D2X(X2D(@dsnl)+44)             /* bump to next DSN entry */\nEnd\nSay ' '\nSay 'Swapping activity table analysis completed: 'TIME()\nExit\n./ ADD LIST=ALL,NAME=LISTSFT\n/*REXX*/\n/*****************************************************************/\n/* LISTSFT: REXX program to display the PC system function table.*/\n/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */\n/*****************************************************************/\n/* MVS DATA AREAS:                                               */\n/*                CVT - Communications Vector Table (@'10'x)     */\n/*                SFT - System Function Table                    */\n/*                                                               */\n/*****************************************************************/\n@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */\n@cvt = D2X(C2D(@cvt))                    /* binary to hex             */\n@cvtxsft  = STORAGE(D2X(X2D(@cvt)+772),4)    /* get CVTXSFT address   */\n@cvtxsft  = D2X(C2D(@cvtxsft))                 /* binary to hex       */\nAddress TSO ; \"CLEAR\"\nSay 'CVT:'@cvt'  CVTXSFT:'@cvtxsft'   'DATE() TIME()\nSay ' '\nSay '    PC Number          Service Description'\nSay '    ----------------   ----------------------------------------'\n@start = @cvtxsft ; i = 0\nsftentry = STORAGE(@start,4)\nDo While sftentry \\= 'FFFFFFFF'x                       /* process SFT */\n   i = i + 1\n   linkageix = SUBSTR(sftentry,2,2) ; linkageix = C2X(linkageix)\n     entryix = SUBSTR(sftentry,4,1) ;   entryix = C2X(entryix)\n   Select\n      When sftentry = '00000000'x Then\n         service = 'Linkage Index Reserve                    (IEAVXLRE)'\n      When sftentry = '00000001'x Then\n         service = 'Linkage Index Free                       (IEAVXLFR)'\n      When sftentry = '00000002'x Then\n         service = 'Entry Table Create                       (IEAVXECR)'\n      When sftentry = '00000003'x Then\n         service = 'Entry Table Destroy                      (IEAVXEDE)'\n      When sftentry = '00000004'x Then\n         service = 'Entry Table Connect                      (IEAVXECO)'\n      When sftentry = '00000005'x Then\n         service = 'Entry Table Disconnect                   (IEAVXEDI)'\n      When sftentry = '00000006'x Then\n         service = 'Authorization Index Reserve              (IEAVXRFE)'\n      When sftentry = '00000007'x Then\n         service = 'Authorization Index Free                 (IEAVXRFE)'\n      When sftentry = '00000008'x Then\n         service = 'Authorization Index Extract              (IEAVXRFE)'\n      When sftentry = '00000009'x Then\n         service = 'Authorization Index Set                  (IEAVXSET)'\n      When sftentry = '0000000A'x Then\n         service = 'Authorization Table Set                  (IEAVXSET)'\n      When sftentry = '0000000B'x Then\n         service = 'PC/Auth Resource Manager                 (IEAVXPAM)'\n      When sftentry = '00000100'x Then\n         service = 'ENQ/DEQ/RESERVE                          (ISGGQWBI)'\n      When sftentry = '00000101'x Then\n         service = 'ENQ/DEQ/RESERVE Redrive                  (ISGGQWBI)'\n      When sftentry = '00000102'x Then\n         service = 'ENQ/DEQ/RESERVE Resource Term Mgr        (ISGGTRMI)'\n      When sftentry = '00000103'x Then\n         service = 'Global Resource Serialization Dump       (ISGDGCB0)'\n      When sftentry = '00000104'x Then\n         service = 'Global Resource Serialization Qscan      (ISGQSCAN)'\n      When sftentry = '00000105'x Then\n         service = 'Global Resource Serialization Stor Mgmt  (ISGSMI  )'\n      When sftentry = '00000200'x Then\n         service = 'Display Allocation Tables Manager        (IEFHB410)'\n      When sftentry = '00000300'x Then\n         service = 'VSM CPOOL Build Service                  (IGVCPBDP)'\n      When sftentry = '00000301'x Then\n         service = 'VSM CPOOL Expansion Interface            (IGVCPEXP)'\n      When sftentry = '00000302'x Then\n         service = 'VSM CPOOL Delete Service                 (IGVCPDLP)'\n      When sftentry = '00000303'x Then\n         service = 'VSMLIST Service                          (IGVLISTP)'\n      When sftentry = '00000304'x Then\n         service = 'VSMLOC Service                           (IGVLOCP )'\n      When sftentry = '00000305'x Then\n         service = 'CPUTIMER Service                         (IEAVRT04)'\n      When sftentry = '00000400'x Then\n         service = 'WTO Service                              (IEAVH600)'\n      When sftentry = '00000106'x Then\n         service = 'Global Resource Serialization Qscan      (ISGQSCAN)'\n      When sftentry = '00000107'x Then\n         service = 'DEQUEUE Fast Path                        (ISGLNQDQ)'\n      When sftentry = '00000108'x Then\n         service = 'ENQUEUE Fast Path                        (ISGLNQDQ)'\n      When sftentry = '00000109'x Then\n         service = 'Global Resource Serialization ESTAE      (ISGGEST0)'\n      When sftentry = '0000010A'x Then\n         service = 'FRR for ENQ/DEQ/RESERVE Mainline         (ISGGFRR0)'\n      When sftentry = '00000500'x Then\n         service = 'System Trace Control Block Verification  (IEAVETCV)'\n      When sftentry = '00000501'x Then\n         service = 'System Trace Environment Alteration      (IEAVETEA)'\n      When sftentry = '00000502'x Then\n         service = 'System Trace Processor Alteration        (IEAVETPA)'\n      When sftentry = '00000503'x Then\n         service = 'System Trace Processor Snapshot          (IEAVETPS)'\n      When sftentry = '00000504'x Then\n         service = 'System Trace Processor Verification      (IEAVETPV)'\n      When sftentry = '00000505'x Then\n         service = 'System Trace Table Snapshot Data Extract (IEAVETSD)'\n      When sftentry = '00000506'x Then\n         service = 'System Trace Table Snapshot              (IEAVETSN)'\n      When sftentry = '00000507'x Then\n         service = 'System Trace Suspend, Resume, PSTART     (IEAVETSP)'\n      When sftentry = '00000508'x Then\n         service = 'System Trace Table Snapshot Filter       (IEAVETTF)'\n      When sftentry = '00000306'x Then\n         service = 'Virtual Fetch CSVVFORK Service           (CSVVFORK)'\n      When sftentry = '00000600'x Then\n         service = 'Virtual Fetch CSVVFSCH Service           (CSVVFSCH)'\n      When sftentry = '00000700'x Then\n         service = 'SMF Buffering Routine                    (IFAPCWTR)'\n      When sftentry = '00000800'x Then\n         service = 'Lnklst Lookaside (LLA)                   (CSVLLS01)'\n      Otherwise\n         service = '*** Unknown Program Call Function ***'\n      End\n   Say RIGHT(i,2,' ')'  LX: 'linkageix'  EX: 'entryix'   'service\n   sftentry = STORAGE(D2X(X2D(@start)+(i*4)),4) /* bump to next entry */\nEnd\nSay ' '\nSay 'System Function Table scan completed 'TIME()\nExit\n./ ADD LIST=ALL,NAME=LISTSMAP\n/*REXX*/\n/*****************************************************************/\n/*LISTSMAP: REXX program to display key virtual storage points.  */\n/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */\n/*****************************************************************/\n/* MVS DATA AREAS:                                               */\n/*                CVT - Communications Vector Table (@'10'x)     */\n/*                GDA - Global Data Area                         */\n/*                                                               */\n/*                                                               */\n/*                                                               */\n/*****************************************************************/\n@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */\n@cvt = D2X(C2D(@cvt))                    /* binary to hex             */\n@cvtmz00  = STORAGE(D2X(X2D(@cvt)+164),4)    /* get CVTMZ00 bitstring */\n@cvtreal  = STORAGE(D2X(X2D(@cvt)+284),4)    /* get CVTREAL address   */\n@cvtreal  = D2X(C2D(@cvtreal))                 /* binary to hex       */\n@cvteorm  = STORAGE(D2X(X2D(@cvt)+312),4)    /* get CVTEORM address   */\n@cvteorm  = D2X(C2D(@cvteorm))                 /* binary to hex       */\n@cvtshrvm = STORAGE(D2X(X2D(@cvt)+416),4)    /* get CVTSHRVM address  */\n@cvtshrvm = D2X(C2D(@cvtshrvm))                /* binary to hex       */\n@cvtgda   = STORAGE(D2X(X2D(@cvt)+560),4)    /* get CVTGDA address    */\n@cvtgda   = D2X(C2D(@cvtgda))                  /* binary to hex       */\n@gdacsa   = D2X(X2D(@cvtgda)+108)            /* locate GDACSAstarts   */\n@gdacsa   = D2X(C2D(STORAGE(@gdacsa,4)))       /*  get GDACSA         */\n@gdacsasz = D2X(X2D(@cvtgda)+112)            /* locate GDACSASiZe     */\n@gdacsasz = D2X(C2D(STORAGE(@gdacsasz,4)))     /*  get GDACSASiZe     */\n@gdaecsa  = D2X(X2D(@cvtgda)+124)            /* locate GDAECSAstarts  */\n@gdaecsa  = D2X(C2D(STORAGE(@gdaecsa,4)))      /*  get GDAECSA        */\n@gdaecsas = D2X(X2D(@cvtgda)+128)            /* locate GDAECSASize    */\n@gdaecsas = D2X(C2D(STORAGE(@gdaecsas,4)))     /*  get GDAECSAS       */\n@cvtsmext = STORAGE(D2X(X2D(@cvt)+1196),4)   /* get CVTSMEXT address  */\n@cvtsmext = D2X(C2D(@cvtsmext))                /* binary to hex       */\n@cvtmlpas = D2X(X2D(@cvtsmext)+8)            /* locate CVTMLPAStarts  */\n@cvtmlpas = D2X(C2D(STORAGE(@cvtmlpas,4)))     /*  get CVTMLPAS       */\n@cvtmlpae = D2X(X2D(@cvtsmext)+12)           /* locate CVTMLPAEnds    */\n@cvtmlpae = D2X(C2D(STORAGE(@cvtmlpae,4)))     /*  get CVTMLPAE       */\n@cvtflpas = D2X(X2D(@cvtsmext)+16)           /* locate CVTFLPAStarts  */\n@cvtflpas = D2X(C2D(STORAGE(@cvtflpas,4)))     /*  get CVTFLPAS       */\n@cvtflpae = D2X(X2D(@cvtsmext)+20)           /* locate CVTFLPAEnds    */\n@cvtflpae = D2X(C2D(STORAGE(@cvtflpae,4)))     /*  get CVTFLPAE       */\n@cvtplpas = D2X(X2D(@cvtsmext)+24)           /* locate CVTPLPAStarts  */\n@cvtplpas = D2X(C2D(STORAGE(@cvtplpas,4)))     /*  get CVTPLPAS       */\n@cvtplpae = D2X(X2D(@cvtsmext)+28)           /* locate CVTPLPAEnds    */\n@cvtplpae = D2X(C2D(STORAGE(@cvtplpae,4)))     /*  get CVTPLPAE       */\n@cvtrwns  = D2X(X2D(@cvtsmext)+32)           /* locate CVTRWNStarts   */\n@cvtrwns  = D2X(C2D(STORAGE(@cvtrwns,4)))      /*  get CVTRWNS        */\n@cvtrwne  = D2X(X2D(@cvtsmext)+36)           /* locate CVTRWNEnds     */\n@cvtrwne  = D2X(C2D(STORAGE(@cvtrwne,4)))      /*  get CVTRWNE        */\n@cvtrons  = D2X(X2D(@cvtsmext)+40)           /* locate CVTRONStarts   */\n@cvtrons  = D2X(C2D(STORAGE(@cvtrons,4)))      /*  get CVTRONS        */\n@cvtrone  = D2X(X2D(@cvtsmext)+44)           /* locate CVTRONEnds     */\n@cvtrone  = D2X(C2D(STORAGE(@cvtrone,4)))      /*  get CVTRONE        */\n@cvterwns = D2X(X2D(@cvtsmext)+48)           /* locate CVTERWNStarts  */\n@cvterwns = D2X(C2D(STORAGE(@cvterwns,4)))     /*  get CVTERWNS       */\n@cvterwne = D2X(X2D(@cvtsmext)+52)           /* locate CVTERWNEnds    */\n@cvterwne = D2X(C2D(STORAGE(@cvterwne,4)))     /*  get CVTRRWNE       */\n@cvteplps = D2X(X2D(@cvtsmext)+56)           /* locate CVTEPLPStarts  */\n@cvteplps = D2X(C2D(STORAGE(@cvteplps,4)))     /*  get CVTEPLPS       */\n@cvteplpe = D2X(X2D(@cvtsmext)+60)           /* locate CVTEPLPEnds    */\n@cvteplpe = D2X(C2D(STORAGE(@cvteplpe,4)))     /*  get CVTRPLPE       */\n@cvteflps = D2X(X2D(@cvtsmext)+64)           /* locate CVTEFLPStarts  */\n@cvteflps = D2X(C2D(STORAGE(@cvteflps,4)))     /*  get CVTEFLPS       */\n@cvteflpe = D2X(X2D(@cvtsmext)+68)           /* locate CVTEFLPEnds    */\n@cvteflpe = D2X(C2D(STORAGE(@cvteflpe,4)))     /*  get CVTRFLPE       */\n@cvtemlps = D2X(X2D(@cvtsmext)+72)           /* locate CVTEMLPStarts  */\n@cvtemlps = D2X(C2D(STORAGE(@cvtemlps,4)))     /*  get CVTEMLPS       */\n@cvtemlpe = D2X(X2D(@cvtsmext)+76)           /* locate CVTEMLPEnds    */\n@cvtemlpe = D2X(C2D(STORAGE(@cvtemlpe,4)))     /*  get CVTRMLPE       */\nSay 'The CVT  is located at '@cvt '('X2D(@cvt)')'\nSay 'The CVTMZ00  field contains 'C2X(@cvtmz00) /*'('X2D(@cvtmz00)')'*/\nSay 'The CVTSEORM field contains '@cvteorm '('X2D(@cvteorm)')'\nSay 'The CVTREAL  field contains   '@cvtreal     '('X2D(@cvtreal)')'\nSay 'The CVTSHRVM field contains  '@cvtshrvm  '('X2D(@cvtshrvm)')'\nSay 'The CVTGDA   field contains  '@cvtgda    '('X2D(@cvtgda)')'\nSay 'The GDACSA   field contains  '@gdacsa    '('X2D(@gdacsa)')'\nSay 'The GDACSASZ field contains  '@gdacsasz  '('X2D(@gdacsasz)')'\nSay 'The GDAECSA  field contains  '@gdaecsa   '('X2D(@gdaecsa)')'\nSay 'The GDAECSAS field contains  '@gdaecsas  '('X2D(@gdaecsas)')'\nSay 'The CVTMLPAS field contains  '@cvtmlpas  '('X2D(@cvtmlpas)')'\nSay 'The CVTMLPAE field contains  '@cvtmlpae  '('X2D(@cvtmlpae)')'\nSay 'The CVTFLPAS field contains  '@cvtflpas  '('X2D(@cvtflpas)')'\nSay 'The CVTFLPAE field contains  '@cvtflpae  '('X2D(@cvtflpae)')'\nSay 'The CVTPLPAS field contains  '@cvtplpas  '('X2D(@cvtplpas)')'\nSay 'The CVTPLPAE field contains  '@cvtplpae  '('X2D(@cvtplpae)')'\nSay 'The CVTRWNS  field contains  '@cvtrwns   '('X2D(@cvtrwns)')'\nSay 'The CVTRWNE  field contains  '@cvtrwne   '('X2D(@cvtrwne)')'\nSay 'The CVTRONS  field contains  '@cvtrons   '('X2D(@cvtrons)')'\nSay 'The CVTRONE  field contains '@cvtrone   '('X2D(@cvtrone)')'\nSay 'The CVTERWNS field contains '@cvterwns  '('X2D(@cvterwns)')'\nSay 'The CVTERWNE field contains '@cvterwne  '('X2D(@cvterwne)')'\nSay 'The CVTEPLPS field contains '@cvteplps  '('X2D(@cvteplps)')'\nSay 'The CVTEPLPE field contains '@cvteplpe  '('X2D(@cvteplpe)')'\nSay 'The CVTEFLPS field contains '@cvteflps  '('X2D(@cvteflps)')'\nSay 'The CVTEFLPE field contains '@cvteflpe  '('X2D(@cvteflpe)')'\nSay 'The CVTEMLPS field contains '@cvtemlps  '('X2D(@cvtemlps)')'\nSay 'The CVTEMLPE field contains '@cvtemlpe  '('X2D(@cvtemlpe)')'\nSay ' '\nSay ' '\nSay ' '\n/*  simplify variable names & calculate some boundaries   */\n@csa1   = @cvtshrvm  ; @csa2  = D2X(X2D(@cvtmlpas)-1)         /* csa  */\n@csa1g  = @gdacsa    ; @csa2g = D2X(X2D(@gdacsasz)+X2D(@gdacsa)-1)/* g*/\n@mlpa1  = @cvtmlpas  ; @mlpa2 = @cvtmlpae                     /* mlpa */\n@flpa1  = @cvtflpas  ; @flpa2 = @cvtflpae                     /* flpa */\n@plpa1  = @cvtplpas  ; @plpa2 = @cvtplpae                     /* plpa */\n@sqa1   = D2X(X2D(@cvtplpae)+1) ; @sqa2 = D2X(X2D(@cvtrwns)-1)/* sqa  */\n@nuc1   = @cvtrwns   ; @nuc2  = @cvterwne                     /* nuc  */\n@esqa1  = D2X(X2D(@nuc2)+1) ; @esqa2 = D2X(X2D(@cvteplps)-1)  /* esqa */\n@eplpa1 = @cvteplps  ; @eplpa2 = @cvteplpe                    /* eplpa*/\n@eflpa1 = @cvteflps  ; @eflpa2 = @cvteflpe                    /* eflpa*/\n@emlpa1 = @cvtemlps  ; @emlpa2 = @cvtemlpe                    /* emlpa*/\n@ecsa1g = @gdaecsa   ; @ecsa2g= D2X(X2D(@gdaecsas)+X2D(@gdaecsa)-1)/*g*/\ncsas    = (X2D(@csa2)-X2D(@csa1)+1)/1024     /* size of csa   KB    */\ncsasg   =  X2D(@gdacsasz)/1024               /* size of csag  KB    */\nmlpas   = (X2D(@mlpa2)-X2D(@mlpa1)+1)/1024   /* size of mlpa  KB    */\nflpas   = (X2D(@flpa2)-X2D(@flpa1)+1)/1024   /* size of flpa  KB    */\nplpas   = (X2D(@plpa2)-X2D(@plpa1)+1)/1024   /* size of plpa  KB    */\nsqas    = (X2D(@sqa2)-X2D(@sqa1)+1)/1024     /* size of sqa   KB    */\nnucs    = (X2D(@nuc2)-X2D(@nuc1)+1)/1024     /* size of nuc   KB    */\nesqas   = (X2D(@esqa2)-X2D(@esqa1)+1)/1024   /* size of esqa  KB    */\neplpas  = (X2D(@eplpa2)-X2D(@eplpa1)+1)/1024 /* size of eplpa KB    */\neflpas  = (X2D(@eflpa2)-X2D(@eflpa1)+1)/1024 /* size of eflpa KB    */\nemlpas  = (X2D(@emlpa2)-X2D(@emlpa1)+1)/1024 /* size of emlpa KB    */\necsasg  =  X2D(@gdaecsas)/1024               /* size of ecsag KB    */\nSay 'Key storage addresses for system routine residency analysis:'\nSay ' '\nSay 'STORAGE AREA NAME               SIZE(K)      ADDRESS RANGE'\nSay ' '\nSay 'Common Service Area (CSA)       'RIGHT(csas,5)  '     'RIGHT(@csa1,8,0)'-'RIGHT(@csa2,8,0)\nSay 'Common Service Area (CSA/GDA)   'RIGHT(csasg,5)  '     'RIGHT(@csa1g,8,0)'-'RIGHT(@csa2g,8,0)\nSay 'Modified Link Pack Area (MLPA)  'RIGHT(mlpas,5) '     'RIGHT(@mlpa1,8,0)'-'RIGHT(@mlpa2,8,0)\nSay 'Fixed Link Pack Area (FLPA)     'RIGHT(flpas,5) '     'RIGHT(@flpa1,8,0)'-'RIGHT(@flpa2,8,0)\nSay 'Pageable Link Pack Area (PLPA)  'RIGHT(plpas,5) '     'RIGHT(@plpa1,8,0)'-'RIGHT(@flpa2,8,0)\nSay 'System Queue Area (SQA)         'RIGHT(sqas,5)  '     'RIGHT(@sqa1,8,0)'-'RIGHT(@sqa2,8,0)\nSay 'MVS Nucleus (NUC)               'RIGHT(nucs,5)  '     'RIGHT(@nuc1,8,0)'-'RIGHT(@nuc2,8,0)\nSay 'Extended SQA                    'RIGHT(esqas,5) '     'RIGHT(@esqa1,8,0)'-'RIGHT(@esqa2,8,0)\nSay 'Extended PLPA                   'RIGHT(eplpas,5) '     'RIGHT(@eplpa1,8,0)'-'RIGHT(@eplpa2,8,0)\nSay 'Extended FLPA                   'RIGHT(eflpas,5) '     'RIGHT(@eflpa1,8,0)'-'RIGHT(@eflpa2,8,0)\nSay 'Extended MLPA                   'Right(emlpas,5) '     'RIGHT(@emlpa1,8,0)'-'RIGHT(@emlpa2,8,0)\nSay 'Extended CSA/GDA                'Right(ecsasg,5) '     'RIGHT(@ecsa1g,8,0)'-'RIGHT(@ecsa2g,8,0)\nExit\n./ ADD LIST=ALL,NAME=LISTSMF\n/*REXX*/\n/*****************************************************************/\n/* LISTSMF: REXX program to show SMF information.                */\n/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */\n/*****************************************************************/\n/* MVS DATA AREAS:                                               */\n/*                CVT - Communications Vector Table (@'10'x)     */\n/*               SMCA - SMF Control Area                         */\n/*                RDS - SMF Recording Data Set                   */\n/*               SSTP - SMF Selectivity Table                    */\n/*****************************************************************/\n@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */\n@cvt = D2X(C2D(@cvt))                         /* binary to dec to hex */\n@cvtsmca  = STORAGE(D2X(X2D(@cvt)+196),4)      /* get CVTSMCA address */\n@smca     = C2X(@cvtsmca) ; @cvtsmca = RIGHT(@smca,7)    /* trim addr */\nsmcasid   = STORAGE(D2X(X2D(@cvtsmca)+016),4)  /* get system id field */\nsmcasjwt  = STORAGE(D2X(X2D(@cvtsmca)+144),4)       /* get system jwt */\nsmcaprmt  = STORAGE(D2X(X2D(@cvtsmca)+208),1) /* get smf prompt flags */\n@smcafrds = STORAGE(D2X(X2D(@cvtsmca)+244),4)  /* get 1st RDA address */\n@smcafrds = C2X(@smcafrds)                           /* binary to hex */\n@smcalrds = STORAGE(D2X(X2D(@cvtsmca)+248),4) /* get last RDA address */\n@smcalrds = C2X(@smcalrds)                           /* binary to hex */\n@smcasstp = STORAGE(D2X(X2D(@cvtsmca)+328),4)     /* get SSTP address */\n@smcasstp = C2X(@smcasstp)                           /* binary to hex */\nsmcaitme  = STORAGE(D2X(X2D(@cvtsmca)+336),4)         /* get IPL time */\nipltime = C2D(smcaitme) ; iplhh = ipltime%360000         /* get hours */\niplmm = ipltime//360000 ; iplmm = iplmm%6000           /* get minutes */\niplt = RIGHT(iplhh,2,0)':'RIGHT(iplmm,2,0)            /* format HH:MM */\nsmcaidte  = STORAGE(D2X(X2D(@cvtsmca)+340),4)         /* get IPL date */\nsmcansst = STORAGE(D2X(X2D(@cvtsmca)+348),2)              /* get NSST */\nsmcansst = C2D(smcansst)                             /* binary to dec */\ni = 0 ; endofrds = 0 ; j = 0 ; k = 0\nprompt = 'NOPROMPT' ; @rds = @smcafrds ; @sstp = @smcasstp\nIf BITAND(smcaprmt,'80'x) = '80'x Then prompt = 'PROMPT(IPLR)'\nIf BITAND(smcaprmt,'40'x) = '40'x Then prompt = 'PROMPT(LIST)'\nipld = C2X(smcaidte) ; ipld = SUBSTR(ipld,3,5)\nipldays = SUBSTR(ipld,3,3) ; days = DATE(D) - ipldays\nIf days < 0 Then days = days + 365     /* crossed into new year */\nIf days = 0 Then iplday = '(Today)'\nIf days = 1 Then iplday = '(Yesterday)'\nIf days > 1 Then iplday = '('days' days ago)'\nAddress TSO ; \"CLEAR\"\nSay 'CVT:'@cvt' SMCA:'@smca 'RDS:'@rds'   'TIME() DATE()\nSay ' '\nSay 'SMFID:'smcasid'  JWT:'smcasjwt'  'prompt'  IPL:'ipld' 'iplday' at 'iplt\nSay ' '\nDo While endofrds = 0 & i < 37         /* Trace the RDS chain */\n   i = i + 1                                  /* count all RDSs found */\n   @rdsnext= STORAGE(D2X(X2D(@rds)+4),4)          /* next RDS address */\n   @rdsnext=C2X(@rdsnext)                               /* bin to hex */\n   rdsflg1 = STORAGE(D2X(X2D(@rds)+12),1)              /* get RDSFLG1 */\n   dump = '' ; active = '      '\n   If BITAND(rdsflg1,'08'x) = '08'x Then dump = 'Dump Requested'\n   If BITAND(rdsflg1,'04'x) \\= '04'x Then active = 'Active'\n   rdsname = STORAGE(D2X(X2D(@rds)+16),10)          /* get RDS DSName */\n   rdsvol  = STORAGE(D2X(X2D(@rds)+26),6)           /* get RDS volser */\n   rdscapty= STORAGE(D2X(X2D(@rds)+40),4)   /* get RDS size in blocks */\n   rdsnxtbk= STORAGE(D2X(X2D(@rds)+44),4)       /* get RDS next block */\n   capty = C2D(rdscapty) ; nxtbk = C2D(rdsnxtbk) ; used = nxtbk - 1\n   pctused=TRUNC((used*100)/capty,1) ; pctused=RIGHT(pctused,5)'%'\n   Say RIGHT(i,2,' ') rdsname rdsvol RIGHT(capty,6),\n       RIGHT(used,6)' ('pctused') 'dump active\n   @rds = @rdsnext ; If @rds = @smcalrds Then endofrds = 1\nEnd\nSay ' '\nSay 'SMF selectivity tables defined: 'smcansst\nSay ' '\nbit0='80'x ; bit1='40'x ; bit2='20'x ; bit3='10'x\nbit4='08'x ; bit5='04'x ; bit6='02'x ; bit7='01'x\nDo kk = 1 To smcansst\n   sst    = STORAGE(@sstp,60)                        /* get sst block */\n   sstn   = SUBSTR(sst,1,4)                      /* get subsysname id */\n   If sstn = '00000000'x Then sstn = 'Null'\n   rectbl = SUBSTR(sst,17,32)           /* get record type bit string */\n   rectypes = ''\n   Do i = 0 to 31\n      byte = SUBSTR(rectbl,i+1,1)\n      k = i * 8\n      If BITAND(byte,bit0)=bit0 Then rectypes = rectypes k\n      If BITAND(byte,bit1)=bit1 Then rectypes = rectypes k+1\n      If BITAND(byte,bit2)=bit2 Then rectypes = rectypes k+2\n      If BITAND(byte,bit3)=bit3 Then rectypes = rectypes k+3\n      If BITAND(byte,bit4)=bit4 Then rectypes = rectypes k+4\n      If BITAND(byte,bit5)=bit5 Then rectypes = rectypes k+5\n      If BITAND(byte,bit6)=bit6 Then rectypes = rectypes k+6\n      If BITAND(byte,bit7)=bit7 Then rectypes = rectypes k+7\n   End\n   i = 0 ; k = 0 ; f = '' ; j = 0 ; jj = 0\n   Do While rectypes \\= ''\n      i = i + 1\n      PARSE VAR rectypes type.i rectypes\n   End\n   If i > 2 Then\n         Do k = 1 to i-2\n            j = k + 1 ; jj = k + 2\n            If type.k = type.j - 1 & type.j = type.jj -1 Then f.k = '*'\n                                                         Else f.k = ' '\n         End\n   rectypes = 'TYPE('\n   Do k = 1 to i\n      If f.k \\= '*' Then Do\n                            rectypes = rectypes''type.k\n                            If k \\= i Then rectypes = rectypes','\n                                      Else rectypes = rectypes')'\n                         End\n                    Else Do\n                           rectypes = rectypes''type.k':'\n                           Do While f.k = '*' ; k=k+1 ; End\n                         End\n   End\n   If RIGHT(rectypes,1) = ':' Then  /* compensate for single type */\n      Do\n         rectypes = LEFT(rectypes,LENGTH(rectypes)-1)')'\n         nop\n      End\n   line2 = ''\n   If LENGTH(rectypes) >70 Then\n      Do\n         Do i = 70 to 1 By -1\n            If SUBSTR(rectypes,i,1) = ',' Then Leave\n         End\n         line2 = SUBSTR(rectypes,i+1,60)\n         rectypes = LEFT(rectypes,i)\n      End\n   If sstn = 'Null' Then rectypes = ''\n   Say RIGHT(kk,2,' ') sstn rectypes\n   If line2 \\= '' Then Say '             'line2\n   @sstp  = D2X(X2D(@sstp)+60)                    /* bump to next sst */\nEnd\nSay ' '\nSay 'SMF analysis completed: 'TIME()\nExit\n./ ADD LIST=ALL,NAME=LISTSSN\n/*REXX*/\n/*****************************************************************/\n/* LISTSSN: REXX program to show all MVS subsystems.             */\n/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */\n/*****************************************************************/\n/* MVS DATA AREAS:                                               */\n/*                CVT - Communications Vector Table (@'10'x)     */\n/*              JESCT - JES Communications Table                 */\n/*              SSCVT - Subsystem Communications Vector Table    */\n/*               SSVT - Subsystem vector Table                   */\n/*                                                               */\n/*****************************************************************/\n@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */\n@cvt = D2X(C2D(@cvt))                         /* binary to dec to hex */\n@cvtjesct = STORAGE(D2X(X2D(@cvt)+296),4)     /* get CVTJESCT address */\n@cvtjesct = D2X(C2D(@cvtjesct))               /* binary to dec to hex */\n@jesct    = STORAGE(D2X(X2D(@cvtjesct)+24),4)    /* get JESCT address */\n@jesct    = D2X(C2D(@jesct))                  /* binary to dec to hex */\nAddress TSO ; \"CLEAR\"\nSay 'CVT:'@cvt' JESCT:'@jesct' SSCVT chain trace started: 'TIME() DATE()\nSay ' '\ni = 0 ; endofchn = 0 ; j = 0 ; @ssct = @jesct ; e = 0\nina = 0 ; inacsnam = '' ; inaline1 = ''\nSay '    Snam Fnum  Sysevents Monitored'\nSay '    ---- ----  ------------------------------------------------------------'\nDo While endofchn = 0 & i < 50\n   i = i + 1                                 /* count all SSCTs found */\n   @scta   = STORAGE(D2X(X2D(@ssct)+4),4)    /* get next SSCT address */\n   @scta   = D2X(C2D(@scta))                     /* bin to dec to hex */\n   snam    = STORAGE(D2X(X2D(@ssct)+8),4)     /* get subsystem's name */\n   @ssvt   = STORAGE(D2X(X2D(@ssct)+16),4)        /* get SSVT address */\n   @ssvt   = D2X(C2D(@ssvt))                     /* bin to dec to hex */\n   If @ssvt = 0 Then Do           /* make note of inactive subsystems */\n      ina = ina + 1\n      inacsnam = inacsnam snam           /* build primary output line */\n      If LENGTH(inacsnam) >= 70 Then Do   /* logic for 2 output lines */\n         inaline1 = inacsnam\n         inacsnam = ''\n         End\n      End\n   If @ssvt \\= 0 Then Do             /* detail only active subsystems */\n      j = j + 1                                  /* count active ones */\n      sysevents = ''                    /* SYSEVENTS output code line */\n      fnum = STORAGE(D2X(X2D(@ssvt)+2),2)      /* number of functions */\n      fnum = C2D(fnum)\n      fmat = STORAGE(D2X(X2D(@ssvt)+4),256)   /* function code matrix */\n      Do e = 1 to 256          /* scan fmat, load sysevents code line */\n         If C2D(SUBSTR(fmat,e,1)) \\= 0 Then sysevents = sysevents e\n      End\n      Say RIGHT(j,3,' ') snam'  'RIGHT(fnum,2,0)'  'sysevents\n      End\n   @ssct = @scta\n   If @ssct = 0 Then endofchn = 1    /* zero address ends chain */\nEnd\nIf ina > 0 Then Do\n   Say ' '\n   Say RIGHT(ina,3,' ') 'Subsystems defined, no SSVT built:'\n   If LENGTH(inaline1) \\= 0 Then Do\n      Say '     'inaline1\n      If LENGTH(inacsnam) \\= 0 Then Say '     'inacsnam\n      End\n      Else Say '     'inacsnam\n   End\nSay '---'\nSay RIGHT(i,3,' ')' SSCVT blocks scanned.  Completed: 'TIME()\nExit\n./ ADD LIST=ALL,NAME=LISTSVCJ\n/*REXX*/\n/*****************************************************************/\n/*LISTSVCJ: REXX program to display SVC update journal.          */\n/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */\n/*****************************************************************/\n/* MVS DATA AREAS:                                               */\n/*                CVT - Communications Vector Table (@'10'x)     */\n/*               SCVT - Supervisor Call Vector Table             */\n/*               SVCR - SVC Recording Table                      */\n/*                                                               */\n/*                                                               */\n/*****************************************************************/\n@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */\n@cvt = D2X(C2D(@cvt))                    /* binary to hex             */\n@cvtabend = STORAGE(D2X(X2D(@cvt)+200),4)    /* get CVTABEND address  */\n@cvtabend = D2X(C2D(@cvtabend))                /* binary to hex       */\n@scvtsvcr = D2X(X2D(@cvtabend)+136)          /* SCVT addressibility   */\n@scvtsvcr = STORAGE(@scvtsvcr,4)                  /* SVCR table       */\n@scvtsvcr = D2X(C2D(@scvtsvcr))                /* binary to hex       */\nSay ' '\nSay ' '\nSay 'The CVT  is located at '@cvt '('X2D(@cvt)')'\nSay 'The CVTABEND field points to '@cvtabend '('X2D(@cvtabend)')'\nSay 'The SCVTSVCR field points to '@scvtsvcr '('X2D(@scvtsvcr)')'\nSay ' '\nSay 'The SVC Update Journal table is at '@scvtsvcr '('X2D(@scvtsvcr)')'\nSay ' '\nhits = 0\nDo i = 0 to 255                                 /* loop thru storage  */\n   bytes = STORAGE(D2X(X2D(@scvtsvcr)+(i*24)),24)\n   bytes = C2X(bytes)\n   If SUBSTR(bytes,1,16) \\= '0000000000000000'\n      Then Do\n         hits = hits + 1\n         Say ' '\n         Say '  SVC 'RIGHT(i,3,0) 'updated.  Old SVCTABLE entry: 'SUBSTR(bytes,1,16)\n         Say '           Updating pgm return address: 'SUBSTR(bytes,17,8)\n         Say '                    New SVC EP address: 'SUBSTR(bytes,26,8)\n         Say '                         Times updated: 'X2D(SUBSTR(bytes,41,4))\n         If SUBSTR(bytes,35,5) = '00000'\n            Then Say '                   Date of last update: unknown'\n            Else Say '                   Date of last update: 'SUBSTR(bytes,35,5)\n      End\nEnd\nSay ' '\nSay 'SVCTABLE entries showing updates in the journal = 'hits\nExit\n./ ADD LIST=ALL,NAME=LISTSVCT\n/*REXX*/\n/*****************************************************************/\n/*LISTSVCT: REXX program to display SVC table from CSTOR.        */\n/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */\n/*****************************************************************/\n/* MVS DATA AREAS:                                               */\n/*                CVT - Communications Vector Table (@'10'x)     */\n/*               SCVT - Supervisor Call Vector Table             */\n/*               SVCT - SVC Table                                */\n/*                                                               */\n/*                                                               */\n/*****************************************************************/\n/*--------------virtual storage map definition section----------------*/\nNumeric Digits 10           /* required to handle decimal conversions */\n@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */\n@cvt = D2X(C2D(@cvt))                    /* binary to hex             */\n@cvtreal  = STORAGE(D2X(X2D(@cvt)+284),4)    /* get CVTREAL address   */\n@cvtreal  = D2X(C2D(@cvtreal))                 /* binary to hex       */\n@cvtshrvm = STORAGE(D2X(X2D(@cvt)+416),4)    /* get CVTSHRVM address  */\n@cvtshrvm = D2X(C2D(@cvtshrvm))                /* binary to hex       */\n@cvtgda   = STORAGE(D2X(X2D(@cvt)+560),4)    /* get CVTGDA address    */\n@cvtgda   = D2X(C2D(@cvtgda))                  /* binary to hex       */\n@gdacsa   = D2X(X2D(@cvtgda)+108)            /* locate GDACSAstarts   */\n@gdacsa   = D2X(C2D(STORAGE(@gdacsa,4)))       /*  get GDACSA         */\n@gdacsasz = D2X(X2D(@cvtgda)+112)            /* locate GDACSASiZe     */\n@gdacsasz = D2X(C2D(STORAGE(@gdacsasz,4)))     /*  get GDACSASiZe     */\n@gdaecsa  = D2X(X2D(@cvtgda)+124)            /* locate GDAECSAstarts  */\n@gdaecsa  = D2X(C2D(STORAGE(@gdaecsa,4)))      /*  get GDAECSA        */\n@gdaecsas = D2X(X2D(@cvtgda)+128)            /* locate GDAECSASize    */\n@gdaecsas = D2X(C2D(STORAGE(@gdaecsas,4)))     /*  get GDAECSAS       */\n@cvtsmext = STORAGE(D2X(X2D(@cvt)+1196),4)   /* get CVTSMEXT address  */\n@cvtsmext = D2X(C2D(@cvtsmext))                /* binary to hex       */\n@cvtmlpas = D2X(X2D(@cvtsmext)+8)            /* locate CVTMLPAStarts  */\n@cvtmlpas = D2X(C2D(STORAGE(@cvtmlpas,4)))     /*  get CVTMLPAS       */\n@cvtmlpae = D2X(X2D(@cvtsmext)+12)           /* locate CVTMLPAEnds    */\n@cvtmlpae = D2X(C2D(STORAGE(@cvtmlpae,4)))     /*  get CVTMLPAE       */\n@cvtflpas = D2X(X2D(@cvtsmext)+16)           /* locate CVTFLPAStarts  */\n@cvtflpas = D2X(C2D(STORAGE(@cvtflpas,4)))     /*  get CVTFLPAS       */\n@cvtflpae = D2X(X2D(@cvtsmext)+20)           /* locate CVTFLPAEnds    */\n@cvtflpae = D2X(C2D(STORAGE(@cvtflpae,4)))     /*  get CVTFLPAE       */\n@cvtplpas = D2X(X2D(@cvtsmext)+24)           /* locate CVTPLPAStarts  */\n@cvtplpas = D2X(C2D(STORAGE(@cvtplpas,4)))     /*  get CVTPLPAS       */\n@cvtplpae = D2X(X2D(@cvtsmext)+28)           /* locate CVTPLPAEnds    */\n@cvtplpae = D2X(C2D(STORAGE(@cvtplpae,4)))     /*  get CVTPLPAE       */\n@cvtrwns  = D2X(X2D(@cvtsmext)+32)           /* locate CVTRWNStarts   */\n@cvtrwns  = D2X(C2D(STORAGE(@cvtrwns,4)))      /*  get CVTRWNS        */\n@cvtrwne  = D2X(X2D(@cvtsmext)+36)           /* locate CVTRWNEnds     */\n@cvtrwne  = D2X(C2D(STORAGE(@cvtrwne,4)))      /*  get CVTRWNE        */\n@cvtrons  = D2X(X2D(@cvtsmext)+40)           /* locate CVTRONStarts   */\n@cvtrons  = D2X(C2D(STORAGE(@cvtrons,4)))      /*  get CVTRONS        */\n@cvtrone  = D2X(X2D(@cvtsmext)+44)           /* locate CVTRONEnds     */\n@cvtrone  = D2X(C2D(STORAGE(@cvtrone,4)))      /*  get CVTRONE        */\n@cvterwns = D2X(X2D(@cvtsmext)+48)           /* locate CVTERWNStarts  */\n@cvterwns = D2X(C2D(STORAGE(@cvterwns,4)))     /*  get CVTERWNS       */\n@cvterwne = D2X(X2D(@cvtsmext)+52)           /* locate CVTERWNEnds    */\n@cvterwne = D2X(C2D(STORAGE(@cvterwne,4)))     /*  get CVTRRWNE       */\n@cvteplps = D2X(X2D(@cvtsmext)+56)           /* locate CVTEPLPStarts  */\n@cvteplps = D2X(C2D(STORAGE(@cvteplps,4)))     /*  get CVTEPLPS       */\n@cvteplpe = D2X(X2D(@cvtsmext)+60)           /* locate CVTEPLPEnds    */\n@cvteplpe = D2X(C2D(STORAGE(@cvteplpe,4)))     /*  get CVTRPLPE       */\n@cvteflps = D2X(X2D(@cvtsmext)+64)           /* locate CVTEFLPStarts  */\n@cvteflps = D2X(C2D(STORAGE(@cvteflps,4)))     /*  get CVTEFLPS       */\n@cvteflpe = D2X(X2D(@cvtsmext)+68)           /* locate CVTEFLPEnds    */\n@cvteflpe = D2X(C2D(STORAGE(@cvteflpe,4)))     /*  get CVTRFLPE       */\n@cvtemlps = D2X(X2D(@cvtsmext)+72)           /* locate CVTEMLPStarts  */\n@cvtemlps = D2X(C2D(STORAGE(@cvtemlps,4)))     /*  get CVTEMLPS       */\n@cvtemlpe = D2X(X2D(@cvtsmext)+76)           /* locate CVTEMLPEnds    */\n@cvtemlpe = D2X(C2D(STORAGE(@cvtemlpe,4)))     /*  get CVTRMLPE       */\n        /*------simplify variable names & make addresses decimal------*/\n@csa1g  = @gdacsa    ; @csa2g = D2X(X2D(@gdacsasz)+X2D(@gdacsa)-1)/* g*/\n   csa1 = X2D(@csa1g) ; csa2 = X2D(@csa2g)                    /* csa  */\n@mlpa1  = @cvtmlpas  ; @mlpa2 = @cvtmlpae                     /* mlpa */\n   mlpa1 = X2D(@mlpa1) ; mlpa2 = X2D(@mlpa2)\n@flpa1  = @cvtflpas  ; @flpa2 = @cvtflpae                     /* flpa */\n   flpa1 = X2D(@flpa1) ; flpa2 = X2D(@flpa2)\n@plpa1  = @cvtplpas  ; @plpa2 = @cvtplpae                     /* plpa */\n   plpa1 = X2D(@plpa1) ; plpa2 = X2D(@plpa2)\n@sqa1   = D2X(X2D(@cvtplpae)+1) ; @sqa2 = D2X(X2D(@cvtrwns)-1)/* sqa  */\n   sqa1 = X2D(@sqa1) ; sqa2 = X2D(@sqa2)\n@nuc1   = @cvtrwns   ; @nuc2  = @cvterwne                     /* nuc  */\n   nuc1 = X2D(@nuc1) ; nuc2 = X2D(@nuc2)\n@esqa1  = D2X(X2D(@nuc2)+1) ; @esqa2 = D2X(X2D(@cvteplps)-1)  /* esqa */\n  esqa1 = X2D(@esqa1) ; esqa2 = X2D(@esqa2)\n@eplpa1 = @cvteplps  ; @eplpa2 = @cvteplpe                    /* eplpa*/\n eplpa1 = X2D(@eplpa1) ; eplpa2 = X2D(@eplpa2)\n@eflpa1 = @cvteflps  ; @eflpa2 = @cvteflpe                    /* eflpa*/\n eflpa1 = X2D(@eflpa1) ; eflpa2 = X2D(@eflpa2)\n@emlpa1 = @cvtemlps  ; @emlpa2 = @cvtemlpe                    /* emlpa*/\n emlpa1 = X2D(@emlpa1) ; emlpa2 = X2D(@emlpa2)\n@ecsa1g = @gdaecsa   ; @ecsa2g= D2X(X2D(@gdaecsas)+X2D(@gdaecsa)-1)/*g*/\n  ecsa1 = X2D(@ecsa1g) ; ecsa2 = X2D(@ecsa2g)\n@eprivs = X2D(@ecsa2g)+1                               /* ext private */\n@eprive = 2147483647                         /* fixed by architecture */\n epriv1 = @eprivs ; epriv2 = @eprive\n@psas   = 0 ; @psae = 4095                       /* psa fixed by arch */\n   psa1 = @psas ; psa2 = @psae\n@prive  = X2D(@csa1g)-1 ; @privs = X2D(@psae)+1            /* private */\n  priv1 = @privs ; priv2 = @prive\n              /*------------------------------------------------------*/\n             /* Usage Notes: Hex character compares are incompatible */\n            /*    for storage residency determination.  Thus, entry */\n           /*     point addresses must be converted to decimal and */\n          /*      VS boundary addresses must be converted to de-  */\n         /*       cimal for correct compare operations.          */\n        /*------------------------------------------------------*/\n/*----------end of virtual storage map definition section-------------*/\n@cvtabend = STORAGE(D2X(X2D(@cvt)+200),4)    /* get CVTABEND address  */\n@cvtabend = D2X(C2D(@cvtabend))                /* binary to hex       */\n@scvtsvct = D2X(X2D(@cvtabend)+132)          /* SCVT addressibility   */\n@scvtsvct = STORAGE(@scvtsvct,4)                  /* SVCT table       */\n@scvtsvct = D2X(C2D(@scvtsvct))                /* binary to hex       */\nAddress TSO ; \"CLEAR\"\nSay 'CVT:'@cvt' CVTABEND:'@cvtabend' SCVTSVCT:'@scvtsvct DATE() TIME()\nSay ' '\nSay 'Active SVCs follow:'\nSay ' '\nactive = 0 ; inactive = 0 ; svcapf = 0 ; svcesr = 0\nnucepn = 'IGCERROR' ; Call \"#NUCLKUP\" nucepn ; igcerror = Result\nDo i = 0 to 255                                 /* loop thru storage  */\n   bytes = STORAGE(D2X(X2D(@scvtsvct)+(i*8)),8)\n   addr = SUBSTR(bytes,1,4)       /* sloppy code to grab EP in binary */\n   bytes = C2X(bytes)          /* legacy code before learning bit ops */\n   svcep  = SUBSTR(bytes,1,8)\n                                        /* determine storage location */\n   addr = BITAND(addr,'7FFFFFFF'x)        /* shave off amode bit (32) */\n   addr = C2D(addr)                      /* make numeric for compares */\n   sloc = 'ERROR'                       /* determine module residency */\n   If (addr >= csa1   & addr <= csa2  ) Then sloc = 'CSA  '\n      Else If (addr >= mlpa1  & addr <= mlpa2 ) Then sloc = 'MLPA '\n      Else If (addr >= flpa1  & addr <= flpa2 ) Then sloc = 'FLPA '\n      Else If (addr >= plpa1  & addr <= plpa2 ) Then sloc = 'PLPA '\n      Else If (addr >= sqa1   & addr <= sqa2  ) Then sloc = 'SQA  '\n      Else If (addr >= nuc1   & addr <= nuc2  ) Then sloc = 'NUC  '\n      Else If (addr >= esqa1  & addr <= esqa2 ) Then sloc = 'ESQA '\n      Else If (addr >= eplpa1 & addr <= eplpa2) Then sloc = 'EPLPA'\n      Else If (addr >= eflpa1 & addr <= eflpa2) Then sloc = 'EFLPA'\n      Else If (addr >= emlpa1 & addr <= emlpa2) Then sloc = 'EMLPA'\n      Else If (addr >= ecsa1  & addr <= ecsa2 ) Then sloc = 'ECSA '\n      Else If (addr >= epriv1 & addr <= epriv2) Then sloc = 'EPRIV'\n      Else If (addr >= priv1  & addr <= priv2 ) Then sloc = 'PRIV '\n      Else If (addr >= psa1   & addr <= psa2  ) Then sloc = 'PSA  '\n      inactflag = 0\n      If igcerror = Right(D2X(addr),8,0)  /* normalize for match */\n         Then Do\n            inactive = inactive + 1\n            inactflag = 1\n         End\n         Else active = active + 1\n   svctp1 = SUBSTR(bytes,9,1)\n      Select\n         When svctp1 = '0'\n            Then svctype = 'TYPE 1  '\n         When svctp1 = '8'\n            Then svctype = 'TYPE 2  '\n         When svctp1 = 'C'\n            Then svctype = 'TYPE 3/4'\n         When svctp1 = '2'\n            Then svctype = 'TYPE 6  '\n      Otherwise\n                 svctype = 'TYPE ?  '\n      End\n   svctp2 = SUBSTR(bytes,10,1)\n      svcmisc = '   '\n      If svctp2 = '8'\n         Then Do\n            svcmisc = 'APF'\n            svcapf = svcapf + 1\n         End\n      If svctp2 = '4'\n         Then Do\n            svcmisc = 'ESR'\n            svcesr = svcesr + 1\n         End\n   If inactflag = 0\n      Then Say 'SVC 'RIGHT(i,3,0) '('RIGHT(D2X(i),2,0)')',\n               svctype svcep sloc svcmisc\nEnd\nSay ' '\nSay 'SVCTABLE processing complete ' TIME()\nSay ' '\nSay 'There are 'active 'active standard SVCs on this system.'\nSay 'Among the active SVCs, 'svcapf 'are APF restricted.'\nSay 'There are 'svcesr 'active ESR router SVCs present.'\nSay 'The SVCTABLE contains 'inactive 'inactive slots (IGCERROR).'\nSay '    (IGCERROR nucleus address = 'igcerror')'\nSay ' '\nExit\n./ ADD LIST=ALL,NAME=LISTTAPE\n/*REXX*/\n/*****************************************************************/\n/*LISTTAPE: REXX program to display all online TAPE devices.     */\n/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */\n/*****************************************************************/\n/* MVS DATA AREAS:                                               */\n/*                CVT - Communications Vector Table (@'10'x)     */\n/*                UCB - Device Unit Control Block                */\n/*                                                               */\n/*                                                               */\n/*                                                               */\n/*****************************************************************/\n@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */\n@cvt = D2X(C2D(@cvt))                    /* binary to dec to hex      */\n@cvtucba  = STORAGE(D2X(X2D(@cvt)+1252),4)   /* get CVTUCBA address   */\n@cvtucba  = D2X(C2D(@cvtucba))                 /* binary to dec to hex*/\nAddress TSO ; \"CLEAR\"\nSay 'CVT: '@cvt' CVTUCBA: '@cvtucba' ===> TAPE UCB scan started: 'TIME()\nSay ' '\n@ucbchn = @cvtucba\ni = 0 ; endofucb = 0 ; j = 0\nDo While endofucb = 0 & i < 10000\n   i = i + 1\n   ucb     = STORAGE(@ucbchn,24)    /* get 24 byte ucb common segment */\n   ucbid   = SUBSTR(ucb,3,1)                 /* get the 'FF'x id byte */\n   ucbstat = SUBSTR(ucb,4,1)              /* status byte '80'x online */\n   ucbchan = SUBSTR(ucb,5,2)                /* channel address in hex */\n   ucbnxucb= SUBSTR(ucb,9,4)                   /* pointer to next ucb */\n   ucbtbyt3= SUBSTR(ucb,19,1)                 /* device '80'x is TAPE */\n   ucbtbyt4= SUBSTR(ucb,20,1)           /* contains device type codes */\n   If (BITAND(ucbstat,'80'x)='80'x & BITAND(ucbtbyt3,'80'x)='80'x) Then Do\n      j = j + 1; device = 'Unknown'\n      ioaddr = C2X(ucbchan)\n      If BITAND(ucbtbyt4,'80'x)='80'x Then device = '3480   '\n      If BITAND(ucbtbyt4,'01'x)='01'x Then device = '2400   '\n      If BITAND(ucbtbyt4,'03'x)='03'x Then device = '3420   '\n      If BITAND(ucbtbyt4,'81'x)='81'x Then device = '3490E  '\n      @ucbchn=D2X(X2D(@ucbchn)+24)            /* bump to TAPE segment */\n      ucbtape = STORAGE(@ucbchn,24)       /* get 24 byte TAPE segment */\n      ucbfser = SUBSTR(ucbtape,5,6)              /* volser if mounted */\n      If C2X(ucbfser) = '000000000000' Then ucbfser = '-idle-'\n      Say RIGHT(j,3,' ') RIGHT(ioaddr,3) STRIP(device) ucbfser\n   End\n   @ucbchn = D2X(C2D(ucbnxucb))\n   If @ucbchn = 0 Then endofucb = 1    /* zero address ends chain */\nEnd\nSay ' '\nSay 'Last UCB after 'i' blocks scanned.  Completed: 'TIME()\nExit\n./ ADD LIST=ALL,NAME=LISTVMAP\n/*REXX*/\n/*****************************************************************/\n/*LISTSMAP: REXX program to display key virtual storage points.  */\n/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */\n/*****************************************************************/\n/* MVS DATA AREAS:                                               */\n/*                CVT - Communications Vector Table (@'10'x)     */\n/*                GDA - Global Data Area                         */\n/*                                                               */\n/*****************************************************************/\n@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */\n@cvt = D2X(C2D(@cvt))                    /* binary to hex             */\n@cvtmz00  = STORAGE(D2X(X2D(@cvt)+164),4)    /* get CVTMZ00 bitstring */\n@cvtmz00  = C2X(@cvtmz00)                    /* character to hex      */\n@cvtreal  = STORAGE(D2X(X2D(@cvt)+284),4)    /* get CVTREAL address   */\n@cvtreal  = D2X(C2D(@cvtreal))                 /* binary to hex       */\n@cvteorm  = STORAGE(D2X(X2D(@cvt)+312),4)    /* get CVTEORM address   */\n@cvteorm  = D2X(C2D(@cvteorm))                 /* binary to hex       */\nAddress TSO ; \"CLEAR\"\nSay 'CVT:'@cvt'      Virtual Storage Map: 'DATE() TIME()\nSay ' '\n@cvtshrvm = STORAGE(D2X(X2D(@cvt)+416),4)    /* get CVTSHRVM address  */\n@cvtshrvm = D2X(C2D(@cvtshrvm))                /* binary to hex       */\n@cvtgda   = STORAGE(D2X(X2D(@cvt)+560),4)    /* get CVTGDA address    */\n@cvtgda   = D2X(C2D(@cvtgda))                  /* binary to hex       */\n@gdacsa   = D2X(X2D(@cvtgda)+108)            /* locate GDACSAstarts   */\n@gdacsa   = D2X(C2D(STORAGE(@gdacsa,4)))       /*  get GDACSA         */\n@gdacsasz = D2X(X2D(@cvtgda)+112)            /* locate GDACSASiZe     */\n@gdacsasz = D2X(C2D(STORAGE(@gdacsasz,4)))     /*  get GDACSASiZe     */\n@gdaecsa  = D2X(X2D(@cvtgda)+124)            /* locate GDAECSAstarts  */\n@gdaecsa  = D2X(C2D(STORAGE(@gdaecsa,4)))      /*  get GDAECSA        */\n@gdaecsas = D2X(X2D(@cvtgda)+128)            /* locate GDAECSASize    */\n@gdaecsas = D2X(C2D(STORAGE(@gdaecsas,4)))     /*  get GDAECSAS       */\n@cvtsmext = STORAGE(D2X(X2D(@cvt)+1196),4)   /* get CVTSMEXT address  */\n@cvtsmext = D2X(C2D(@cvtsmext))                /* binary to hex       */\n@cvtmlpas = D2X(X2D(@cvtsmext)+8)            /* locate CVTMLPAStarts  */\n@cvtmlpas = D2X(C2D(STORAGE(@cvtmlpas,4)))     /*  get CVTMLPAS       */\n@cvtmlpae = D2X(X2D(@cvtsmext)+12)           /* locate CVTMLPAEnds    */\n@cvtmlpae = D2X(C2D(STORAGE(@cvtmlpae,4)))     /*  get CVTMLPAE       */\n@cvtflpas = D2X(X2D(@cvtsmext)+16)           /* locate CVTFLPAStarts  */\n@cvtflpas = D2X(C2D(STORAGE(@cvtflpas,4)))     /*  get CVTFLPAS       */\n@cvtflpae = D2X(X2D(@cvtsmext)+20)           /* locate CVTFLPAEnds    */\n@cvtflpae = D2X(C2D(STORAGE(@cvtflpae,4)))     /*  get CVTFLPAE       */\n@cvtplpas = D2X(X2D(@cvtsmext)+24)           /* locate CVTPLPAStarts  */\n@cvtplpas = D2X(C2D(STORAGE(@cvtplpas,4)))     /*  get CVTPLPAS       */\n@cvtplpae = D2X(X2D(@cvtsmext)+28)           /* locate CVTPLPAEnds    */\n@cvtplpae = D2X(C2D(STORAGE(@cvtplpae,4)))     /*  get CVTPLPAE       */\n@cvtrwns  = D2X(X2D(@cvtsmext)+32)           /* locate CVTRWNStarts   */\n@cvtrwns  = D2X(C2D(STORAGE(@cvtrwns,4)))      /*  get CVTRWNS        */\n@cvtrwne  = D2X(X2D(@cvtsmext)+36)           /* locate CVTRWNEnds     */\n@cvtrwne  = D2X(C2D(STORAGE(@cvtrwne,4)))      /*  get CVTRWNE        */\n@cvtrons  = D2X(X2D(@cvtsmext)+40)           /* locate CVTRONStarts   */\n@cvtrons  = D2X(C2D(STORAGE(@cvtrons,4)))      /*  get CVTRONS        */\n@cvtrone  = D2X(X2D(@cvtsmext)+44)           /* locate CVTRONEnds     */\n@cvtrone  = D2X(C2D(STORAGE(@cvtrone,4)))      /*  get CVTRONE        */\n@cvterwns = D2X(X2D(@cvtsmext)+48)           /* locate CVTERWNStarts  */\n@cvterwns = D2X(C2D(STORAGE(@cvterwns,4)))     /*  get CVTERWNS       */\n@cvterwne = D2X(X2D(@cvtsmext)+52)           /* locate CVTERWNEnds    */\n@cvterwne = D2X(C2D(STORAGE(@cvterwne,4)))     /*  get CVTRRWNE       */\n@cvteplps = D2X(X2D(@cvtsmext)+56)           /* locate CVTEPLPStarts  */\n@cvteplps = D2X(C2D(STORAGE(@cvteplps,4)))     /*  get CVTEPLPS       */\n@cvteplpe = D2X(X2D(@cvtsmext)+60)           /* locate CVTEPLPEnds    */\n@cvteplpe = D2X(C2D(STORAGE(@cvteplpe,4)))     /*  get CVTRPLPE       */\n@cvteflps = D2X(X2D(@cvtsmext)+64)           /* locate CVTEFLPStarts  */\n@cvteflps = D2X(C2D(STORAGE(@cvteflps,4)))     /*  get CVTEFLPS       */\n@cvteflpe = D2X(X2D(@cvtsmext)+68)           /* locate CVTEFLPEnds    */\n@cvteflpe = D2X(C2D(STORAGE(@cvteflpe,4)))     /*  get CVTRFLPE       */\n@cvtemlps = D2X(X2D(@cvtsmext)+72)           /* locate CVTEMLPStarts  */\n@cvtemlps = D2X(C2D(STORAGE(@cvtemlps,4)))     /*  get CVTEMLPS       */\n@cvtemlpe = D2X(X2D(@cvtsmext)+76)           /* locate CVTEMLPEnds    */\n@cvtemlpe = D2X(C2D(STORAGE(@cvtemlpe,4)))     /*  get CVTRMLPE       */\n/*  simplify variable names & calculate some boundaries   */\n@csa1   = @cvtshrvm  ; @csa2  = D2X(X2D(@cvtmlpas)-1)         /* csa  */\n@csa1g  = @gdacsa    ; @csa2g = D2X(X2D(@gdacsasz)+X2D(@gdacsa)-1)/* g*/\n@mlpa1  = @cvtmlpas  ; @mlpa2 = @cvtmlpae                     /* mlpa */\n@flpa1  = @cvtflpas  ; @flpa2 = @cvtflpae                     /* flpa */\n@plpa1  = @cvtplpas  ; @plpa2 = @cvtplpae                     /* plpa */\n@sqa1   = D2X(X2D(@cvtplpae)+1) ; @sqa2 = D2X(X2D(@cvtrwns)-1)/* sqa  */\n@nuc1   = @cvtrwns   ; @nuc2  = @cvterwne                     /* nuc  */\n@esqa1  = D2X(X2D(@nuc2)+1) ; @esqa2 = D2X(X2D(@cvteplps)-1)  /* esqa */\n@eplpa1 = @cvteplps  ; @eplpa2 = @cvteplpe                    /* eplpa*/\n@eflpa1 = @cvteflps  ; @eflpa2 = @cvteflpe                    /* eflpa*/\n@emlpa1 = @cvtemlps  ; @emlpa2 = @cvtemlpe                    /* emlpa*/\n@ecsa1g = @gdaecsa   ; @ecsa2g= D2X(X2D(@gdaecsas)+X2D(@gdaecsa)-1)/*g*/\ncsas    = (X2D(@csa2)-X2D(@csa1)+1)/1024     /* size of csa   KB    */\ncsasg   =  X2D(@gdacsasz)/1024               /* size of csag  KB    */\nmlpas   = (X2D(@mlpa2)-X2D(@mlpa1)+1)/1024   /* size of mlpa  KB    */\nflpas   = (X2D(@flpa2)-X2D(@flpa1)+1)/1024   /* size of flpa  KB    */\nplpas   = (X2D(@plpa2)-X2D(@plpa1)+1)/1024   /* size of plpa  KB    */\nsqas    = (X2D(@sqa2)-X2D(@sqa1)+1)/1024     /* size of sqa   KB    */\nnucs    = (X2D(@nuc2)-X2D(@nuc1)+1)/1024     /* size of nuc   KB    */\nesqas   = (X2D(@esqa2)-X2D(@esqa1)+1)/1024   /* size of esqa  KB    */\neplpas  = (X2D(@eplpa2)-X2D(@eplpa1)+1)/1024 /* size of eplpa KB    */\neflpas  = (X2D(@eflpa2)-X2D(@eflpa1)+1)/1024 /* size of eflpa KB    */\nemlpas  = (X2D(@emlpa2)-X2D(@emlpa1)+1)/1024 /* size of emlpa KB    */\necsasg  =  X2D(@gdaecsas)/1024               /* size of ecsag KB    */\n@eprivs = D2X(X2D(@ecsa2g)+1)                        /* ext private */\n@eprive = 21\nepriv   = (@eprive-X2D(@eprivs)+1)/1048576 /* size of epriv MB    */\n@psas   = D2X(0) ; psa = 4 ; @psae = D2X(4095) /* psa fixed by arch */\n@prive  = D2X(X2D(@csa1)-1) ; @privs = D2X(X2D(@psae)+1) /* private */\npriv    = (X2D(@prive)-X2D(@privs)+1)/1024   /* size of ALL private */\n@privsas= @privs ; privsa = 16                  /* sa fixed by arch */\n@privsae= D2X(X2D(@privsas)+((privsa*1024)-1)) /* calc private part */\n@privvrs= D2X(X2D(@privsae)+1)  /* adj priv start above system area */\n@privvre= D2X(X2D(@cvtreal)-1)                   /* calc end of V=R */\nprivvr  = (X2D(@privvre)-X2D(@privvrs)+1)/1024       /* size of V=R */\n@privvvs= @privvrs              /* adj priv start above system area */\n@privvve= @prive                               /* assign end of V=V */\nprivvv  = (X2D(@privvve)-X2D(@privvvs)+1)/1024       /* size of V=V */\nSay '    ------- COMPONENT -------   -SIZE-  --ADDRESS RANGE--'\nSay ' '\nSay '    EPrivate                    'Right(epriv,5)'M  'RIGHT(@eprivs,8,0)'-'RIGHT(@cvtmz00,8,0)\nSay '    ECSA                        'Right(ecsasg,5)'K  'RIGHT(@ecsa1g,8,0)'-'RIGHT(@ecsa2g,8,0)\nSay '    EMLPA                       'Right(emlpas,5)'K  'RIGHT(@emlpa1,8,0)'-'RIGHT(@emlpa2,8,0)\nSay '    EFLPA                       'RIGHT(eflpas,5)'K  'RIGHT(@eflpa1,8,0)'-'RIGHT(@eflpa2,8,0)\nSay '    EPLPA                       'RIGHT(eplpas,5)'K  'RIGHT(@eplpa1,8,0)'-'RIGHT(@eplpa2,8,0)\nSay '    ESQA                        'RIGHT(esqas,5)'K  'RIGHT(@esqa1,8,0)'-'RIGHT(@esqa2,8,0)\nSay '    MVS NUCLEUS                 'RIGHT(nucs,5)'K  'RIGHT(@nuc1,8,0)'-'RIGHT(@nuc2,8,0)\nSay '    SQA                         'RIGHT(sqas,5)'K  'RIGHT(@sqa1,8,0)'-'RIGHT(@sqa2,8,0)\nSay '    PLPA                        'RIGHT(plpas,5)'K  'RIGHT(@plpa1,8,0)'-'RIGHT(@plpa2,8,0)\nSay '    FLPA                        'RIGHT(flpas,5)'K  'RIGHT(@flpa1,8,0)'-'RIGHT(@flpa2,8,0)\nSay '    MLPA                        'RIGHT(mlpas,5)'K  'RIGHT(@mlpa1,8,0)'-'RIGHT(@mlpa2,8,0)\nSay '  * CSA                         'RIGHT(csasg,5)'K  'RIGHT(@csa1g,8,0)'-'RIGHT(@csa2g,8,0)\nSay '    Private (V=V)               'RIGHT(privvv,5)'K  'RIGHT(@privvvs,8,0)'-'RIGHT(@privvve,8,0)\nSay '            (V=R)               'RIGHT(privvr,5)'K  'RIGHT(@privvrs,8,0)'-'RIGHT(@privvre,8,0)\nSay '            (System)            'RIGHT(privsa,5)'K  'RIGHT(@privsas,8,0)'-'RIGHT(@privsae,8,0)\nSay '    PSA                         'RIGHT(psa,5)'K  'RIGHT(@psas,8,0)'-'RIGHT(@psae,8,0)\nSay ' '\ncsatol2 = csasg//1024 ; csatol1 = 1024 - csatol2\nSay '  * CSA Segment Tolerance ===> Upper:'csatol1'K  Lower:'csatol2'K'\nExit\n./ ADD LIST=ALL,NAME=NOT@OR\n  \u00ac  IBM EBCDIC 'not' character is '5F'x                                al\n  |  IBM EBCDIC 'or'  character is '4F'x                                al\n./ ADD LIST=ALL,NAME=SDUMP\n/*REXX*/\n/**********************************************************************/\n/*    PROCEDURE NAME:  SDUMP - formatted storage dump.                */\n/*                                                                    */\n/*            ARG(1):  HEXADECIMAL ADDRESS - DUMP starting location   */\n/*            ARG(2):  DECIMAL LENGTH      - Bytes to dump            */\n/*                                                                    */\n/*    NOTES:  Produces a formatted storage dump for 80 column screens.*/\n/*            The length is rounded to a 16 byte boundary.            */\n/*            The TSO/E STORAGE function is used to access memory.    */\n/**********************************************************************/\nArg @start bytes\nNumeric Digits 10               /* for high end addresses in ESA */\nIf DATATYPE(@start,'X') \\= 1 Then Do\n   Say 'Starting address '@start' is not in hexadecimal form.'\n   Return\n   End\nIf bytes = '' Then bytes  =  256\nIf DATATYPE(bytes,'N') \\= 1 Then Do\n   Say 'Specified bytes 'bytes' is not in decimal form.'\n   Return\n   End\nblocks16=bytes%16 ; If blocks16\\=(bytes/16) Then blocks16=blocks16+1\nAddress TSO ; \"CLEAR\"\nSay 'Storage dump beginning at '@start' for 'blocks16*16' bytes.'\nSay ' '\nSay '  ADDRESS  OFFSET            HEXADECIMAL DATA                CHARACTER'\nSay ' --------  ------  ------------------------------------  :----------------:'\nDo i = 0 to blocks16-1\n   offset = i*16\n   @address = D2X(X2D(@start)+offset)\n   nbytes = STORAGE(@address,16)\n   nbytes = C2X(nbytes)\n   Say ' 'RIGHT(@address,8,0)'  'RIGHT(D2X(offset),6,0)' ',\n           SUBSTR(nbytes,1,8)' 'SUBSTR(nbytes,9,8)' ',\n           SUBSTR(nbytes,17,8)' 'SUBSTR(nbytes,25,8)' ',\n           ':'X2C(nbytes)':'\nEnd\nReturn\n./ ADD LIST=ALL,NAME=VSDATA1\n/*REXX*/\n/*****************************************************************/\n/* VSDATA1: REXX program to display some virtual storage.        */\n/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */\n/*****************************************************************/\n/* MVS DATA AREAS:                                               */\n/*                CVT - Communications Vector Table (@'10'x)     */\n/*                                                               */\n/*                                                               */\n/*                                                               */\n/*                                                               */\n/*****************************************************************/\n@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */\n@cvt = D2X(C2D(@cvt))                    /* binary to hex             */\n@tcb = STORAGE(21C,4)                 /* get TCB address from PSAAOLD */\n@tcb = D2X(C2D(@tcb))                    /* binary to hex             */\n@tcbjscb  = STORAGE(D2X(X2D(@tcb)+180),4)   /* get JSCB address       */\n@jscb = D2X(C2D(@tcbjscb))                     /* binary to hex       */\n@jscbopts = STORAGE(D2X(X2D(@jscb)+236),1)   /* get JSCBOPTS data     */\n@cvtauthl = STORAGE(D2X(X2D(@cvt)+484),4)   /* get CVTAUTHL address   */\n@cvtauthl = D2X(C2D(@cvtauthl))                /* binary to hex       */\n@cvtllta  = STORAGE(D2X(X2D(@cvt)+1244),4)  /* get CVTLLTA address    */\n@cvtllta  = D2X(C2D(@cvtllta))                 /* binary to hex       */\n@cvtsmext = STORAGE(D2X(X2D(@cvt)+1196),4)   /* get CVTSMEXT address  */\n@cvtsmext = D2X(C2D(@cvtsmext))                /* binary to hex       */\n@cvteplps = D2X(X2D(@cvtsmext)+56)           /* get CVTEPLPS address  */\n@cvteplps = STORAGE(@cvteplps,4)             /* get LPAT address      */\n@cvteplps = D2X(C2D(@cvteplps))                /* binary to hex       */\nSay 'The CVT  is located at '@cvt '('X2D(@cvt)')'\nSay 'The TCB  is located at '@tcb '('X2D(@tcb)')'\nSay 'The JSCB is located at '@jscb '('X2D(@jscb)')'\nSay 'The JSCBOPTS byte is 'C2X(@jscbopts) '('C2D(@jscbopts)')' @jscbopts\nSay ' '\nSay 'The CVTAUTHL field points to '@cvtauthl '('X2D(@cvtauthl)')'\nSay '    some storage follows'\nDo i = 0 to 10                                  /* loop thru storage  */\n   byte = STORAGE(D2X(X2D(@cvtauthl)+i),1)\n   Say '    Table byte 'i 'is 'C2X(byte) C2D(byte) byte\nEnd\nSay '    ----+----1----+----2----+----3----+----4----+----5'\nDo i = 0 to 10                                  /* loop thru storage  */\n  Say '===>'STORAGE(D2X(X2D(@cvtauthl)+(i*50)),50)  'block 'i+1\nEnd\nSay ' '\nSay 'The CVTLLTA  field points to '@cvtllta '('X2D(@cvtllta)')'\nSay '    some storage follows'\nDo i = 0 to 10                                  /* loop thru storage  */\n   byte = STORAGE(D2X(X2D(@cvtllta)+i),1)\n   Say '    Table byte 'i 'is 'C2X(byte) C2D(byte) byte\nEnd\nSay '    ----+----1----+----2----+----3----+----4----+----5'\nDo i = 0 to 10                                  /* loop thru storage  */\n  Say '===>'STORAGE(D2X(X2D(@cvtllta)+(i*50)),50)   'block 'i+1\nEnd\nSay 'The CVTSMEXT field points to '@cvtsmext '('X2D(@cvtsmext)')'\nSay 'The CVTEPLPS field points to '@cvteplps '('X2D(@cvteplps)')'\nSay '    some storage follows'\nDo i = 0 to 10                                  /* loop thru storage  */\n   byte = STORAGE(D2X(X2D(@cvteplps)+i),1)\n   Say '    Table byte 'i 'is 'C2X(byte) C2D(byte) byte\nEnd\nSay '    ----+----1----+----2----+----3----+----4----+----5'\nDo i = 0 to 10                                  /* loop thru storage  */\n  Say '===>'STORAGE(D2X(X2D(@cvteplps)+(i*50)),50)   'block 'i+1\nEnd\nSay ' '\nExit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SDUMP": {"ttr": 3079, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00$\\x00\\x94\\x08\\x8f\\x01\\x14\\x05\\x0f\"W\\x00\\'\\x00\\'\\x00\\x00\\xe2\\xc3\\xd5\\xe2\\xf0\\xf3@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1994-03-29T00:00:00", "modifydate": "2014-02-19T22:57:24", "lines": 39, "newlines": 39, "modlines": 0, "user": "SCNS03"}, "text": "/*REXX*/\n/**********************************************************************/\n/*    PROCEDURE NAME:  SDUMP - formatted storage dump.                */\n/*                                                                    */\n/*            ARG(1):  HEXADECIMAL ADDRESS - DUMP starting location   */\n/*            ARG(2):  DECIMAL LENGTH      - Bytes to dump            */\n/*                                                                    */\n/*    NOTES:  Produces a formatted storage dump for 80 column screens.*/\n/*            The length is rounded to a 16 byte boundary.            */\n/*            The TSO/E STORAGE function is used to access memory.    */\n/**********************************************************************/\nArg @start bytes\nNumeric Digits 10               /* for high end addresses in ESA */\nIf DATATYPE(@start,'X') \\= 1 Then Do\n   Say 'Starting address '@start' is not in hexadecimal form.'\n   Return\n   End\nIf bytes = '' Then bytes  =  256\nIf DATATYPE(bytes,'N') \\= 1 Then Do\n   Say 'Specified bytes 'bytes' is not in decimal form.'\n   Return\n   End\nblocks16=bytes%16 ; If blocks16\\=(bytes/16) Then blocks16=blocks16+1\nAddress TSO ; \"CLEAR\"\nSay 'Storage dump beginning at '@start' for 'blocks16*16' bytes.'\nSay ' '\nSay '  ADDRESS  OFFSET            HEXADECIMAL DATA                CHARACTER'\nSay ' --------  ------  ------------------------------------  :----------------:'\nDo i = 0 to blocks16-1\n   offset = i*16\n   @address = D2X(X2D(@start)+offset)\n   nbytes = STORAGE(@address,16)\n   nbytes = C2X(nbytes)\n   Say ' 'RIGHT(@address,8,0)'  'RIGHT(D2X(offset),6,0)' ',\n           SUBSTR(nbytes,1,8)' 'SUBSTR(nbytes,9,8)' ',\n           SUBSTR(nbytes,17,8)' 'SUBSTR(nbytes,25,8)' ',\n           ':'X2C(nbytes)':'\nEnd\nReturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "VSDATA1": {"ttr": 776, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x130\\x9f\\x01\\x130\\x9f\\x15\\x15\\x00D\\x00D\\x00\\x00\\xe2\\xc3\\xd5\\xe2\\xf0\\xf3\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2013-11-05T00:00:00", "modifydate": "2013-11-05T15:15:00", "lines": 68, "newlines": 68, "modlines": 0, "user": "SCNS03T"}, "text": "/*REXX*/\n/*****************************************************************/\n/* VSDATA1: REXX program to display some virtual storage.        */\n/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */\n/*****************************************************************/\n/* MVS DATA AREAS:                                               */\n/*                CVT - Communications Vector Table (@'10'x)     */\n/*                                                               */\n/*                                                               */\n/*                                                               */\n/*                                                               */\n/*****************************************************************/\nnumeric digits 20\n@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */\n@cvt = D2X(C2D(@cvt))                    /* binary to hex             */\n@tcb = STORAGE(21C,4)                 /* get TCB address from PSAAOLD */\n@tcb = D2X(C2D(@tcb))                    /* binary to hex             */\n@tcbjscb  = STORAGE(D2X(X2D(@tcb)+180),4)   /* get JSCB address       */\n@jscb = D2X(C2D(@tcbjscb))                     /* binary to hex       */\n@jscbopts = STORAGE(D2X(X2D(@jscb)+236),1)   /* get JSCBOPTS data     */\n@cvtauthl = STORAGE(D2X(X2D(@cvt)+484),4)   /* get CVTAUTHL address   */\n@cvtauthl = D2X(C2D(@cvtauthl))                /* binary to hex       */\n@cvtllta  = STORAGE(D2X(X2D(@cvt)+1244),4)  /* get CVTLLTA address    */\n@cvtllta  = D2X(C2D(@cvtllta))                 /* binary to hex       */\n@cvtsmext = STORAGE(D2X(X2D(@cvt)+1196),4)   /* get CVTSMEXT address  */\n@cvtsmext = D2X(C2D(@cvtsmext))                /* binary to hex       */\n@cvteplps = D2X(X2D(@cvtsmext)+56)           /* get CVTEPLPS address  */\n@cvteplps = STORAGE(@cvteplps,4)             /* get LPAT address      */\n@cvteplps = D2X(C2D(@cvteplps))                /* binary to hex       */\nSay 'The CVT  is located at '@cvt '('X2D(@cvt)')'\nSay 'The TCB  is located at '@tcb '('X2D(@tcb)')'\nSay 'The JSCB is located at '@jscb '('X2D(@jscb)')'\nSay 'The JSCBOPTS byte is 'C2X(@jscbopts) '('C2D(@jscbopts)')' @jscbopts\nSay ' '\nSay 'The CVTAUTHL field points to '@cvtauthl '('X2D(@cvtauthl)')'\nSay '    some storage follows'\nDo i = 0 to 10                                  /* loop thru storage  */\n   byte = STORAGE(D2X(X2D(@cvtauthl)+i),1)\n   Say '    Table byte 'i 'is 'C2X(byte) C2D(byte) byte\nEnd\nSay '    ----+----1----+----2----+----3----+----4----+----5'\nDo i = 0 to 10                                  /* loop thru storage  */\n  Say '===>'STORAGE(D2X(X2D(@cvtauthl)+(i*50)),50)  'block 'i+1\nEnd\nSay ' '\nSay 'The CVTLLTA  field points to '@cvtllta '('X2D(@cvtllta)')'\nSay '    some storage follows'\nDo i = 0 to 10                                  /* loop thru storage  */\n   byte = STORAGE(D2X(X2D(@cvtllta)+i),1)\n   Say '    Table byte 'i 'is 'C2X(byte) C2D(byte) byte\nEnd\nSay '    ----+----1----+----2----+----3----+----4----+----5'\nDo i = 0 to 10                                  /* loop thru storage  */\n  Say '===>'STORAGE(D2X(X2D(@cvtllta)+(i*50)),50)   'block 'i+1\nEnd\nSay 'The CVTSMEXT field points to '@cvtsmext '('X2D(@cvtsmext)')'\nSay 'The CVTEPLPS field points to '@cvteplps '('X2D(@cvteplps)')'\nSay '    some storage follows'\nDo i = 0 to 10                                  /* loop thru storage  */\n   byte = STORAGE(D2X(X2D(@cvteplps)+i),1)\n   Say '    Table byte 'i 'is 'C2X(byte) C2D(byte) byte\nEnd\nSay '    ----+----1----+----2----+----3----+----4----+----5'\nDo i = 0 to 10                                  /* loop thru storage  */\n  Say '===>'STORAGE(D2X(X2D(@cvteplps)+(i*50)),50)   'block 'i+1\nEnd\nSay ' '\nExit\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT221/FILE221.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT221", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}