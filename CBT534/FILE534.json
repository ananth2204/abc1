{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012304000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 5525884, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 14, "INMDSNAM": "CBT.V500.FILE534.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 5525884, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 5525884, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE534.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00U\\x12'", "DS1TRBAL": "b'\\x15b'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x03\\xf2\\x00\\x01\\x03\\xf7\\x00\\x0b\\x00V'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$$$DOC": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x18\\x00\\x00\\x01\\x06\\x11\\x1f\\x01\\x06\\x11\\x1f\\x00\\x00\\x00\\xc6\\x00\\xc6\\x00\\x00\\xe2\\xd7\\xc1\\xc3\\xc5@@@@@'", "ispf": {"version": "02.24", "flags": 0, "createdate": "2006-04-21T00:00:00", "modifydate": "2006-04-21T00:00:00", "lines": 198, "newlines": 198, "modlines": 0, "user": "SPACE"}, "text": "\n  Paul Dion    pdion@canada.com\n\n\n   This is (yet) another version of the ubiquitous SPACE command\nthat displays DASD volume usage statistics. It can:\n   - cope with DASD devices RESERVEd on other systems without\n     hanging\n   - run as a TSO command or batch program\n   - use EDIF or BRIF to display results\n   - resolve system symbolics (including substringing)\n   - create machine-readable output (UCB, DCE, LSPACE data, F4DSCB)\n   - select devices based on UCB address, Volser, Esoteric, Mount\n     Attribute, and/or SMS Storage Group\n   - sort results by any of the displayed fields\n\n   The data presented by the command are:\n   - UCB address\n   - Volser\n   - Device Type\n   - Use Attribute\n   - Free Trks, Cyls, %\n   - Largest Trks, Cyls\n   - Fragmentation Index\n   - VTOC Trks, free DSCBs, % free\n   - VTOC Index status\n   - Indexed VTOC Status\n   - Volume Capacity\n   - SMS Storage Group\n   - SMS Volume Status\n   - CHPIDs\n\n\n   This version of the SPACE command seems to be able to cope with\nDASD RESERVEd on another system. This is a non-issue for those instal-\nlations that have IBM APAR OW48527 installed, which allows the invoker\nof LSPACE to specify a time-out value (in seconds). For those\ninstallations that do not have the APAR installed, the matter becomes\nsomewhat complicated.\n\n   If LSPACE (SVC 78) is issued against a UCB that is RESERVEd on\nanother system, it will wait until the RESERVE is released. For\nlong-term RESERVEs, this becomes quite annoying. LSPACE gets 'hung'\nbecause:\n   - LSPACE creates an ESTAE with PURGE=NONE\n   - LSPACE degenerates into CVAF\n   - CVAF creates an ESTAE with PURGE=QUIESCE\n   - CVAF tries to touch the device, and waits\n   - If the Address Space is cancelled, an attempt to QUIESCE the I/O\n     is made, so that the 1st ESTAE (CVAFs) can be invoked. The I/O\n     cannot be QUIESCEd while the RESERVE is outstanding, so everything\n     comes to a halt.\n\n   This program tries to cope with this by establishing an ESTAE that\nwill ignore volumes that are being processed when an error occurs. It\nthen issues a STIMERM SET with an exit, issues LSPACE, and issues a\nSTIMERM CANCEL after the LSPACE has completed. If the STIMERM pops\n(because LSPACE is not completing), the STIMERM exit creates an ESTAE\nwith PURGE=HALT. This ESTAE is now 1st on the ESTAE chain, and will be\ninvoked before the ESTAEs of CVAF and LSPACE. The STIMERM exit next\nABENDs with a U522, kicking off the ESTAEs. The I/O is HALTed, and the\nESTAE set up by the STIMERM exit is given control. This ESTAE merely\npercolates to the next ESTAE in line (CVAFs), which can now run\nbecause the I/O has been HALTed. All the other ESTAEs do whatever it is\nthat they do, and we eventually end up back at our ESTAE that goes on\nto process the next volume.\n\n   While LSPACE is trying to touch a RESERVEd device, but before the\nSTIMERM exit kicks in, it is almost certain that SRM/WLM will come\naround and decide that the Address Space should be swapped out. Before\nswapping us out, the various TCBs within the A/S are made non-dispatch-\nable, and an attempt made to QUIESCE the I/O. Again, the I/O cannot be\nQUIESCEd until the RESERVE goes away. Meanwhile, the STIMERM pops, but\nthe exit (which would get us out of this mess) cannot be dispatched,\nsince all our TCBs are non-dispatchable.\n\n   We address this situation by making outselves non-swappable while we\nare issuing LSPACEs. This, of course, means that we have to be APF-\nauthorized to issue SYSEVENT DONTSWAP and OKSWAP (Note that this is the\nonly reason that we have to be APFed - all the code runs in Problem\nState and Key 8).\n\n   If we are running as a TSO command, because we are APFed, we cannot\nuse ISPF Dialog Manager facilities. If you want to allow the use of\nISPF facilities (tables, panels, EDIF, BRIF), the following strategy can\nbe used to install the command:\n   - Link-edit as APF-authorized, in a TSO STEPLIBed or LNKLSTed library\n   - Name the program in the AUTHTSF section *only* in the IKJTSOxx\n     member of SYS1.PARMLIB\nIf this is done, the command can make use of ISPF DM services, because:\n   - The command is invoked without APF\n   - IKJEFTSR is used to re-invoke itself, but APFed this time, to\n     retrieve the DASD information\n   - The non-APFed instance can then use ISPF DM services.\n\n\nCommand Keywords:\n----------------\n\n  UCB(Unit-mask)       specifies the selection criterion based on UCB Address.\n  XUCB(Unit-mask)      specifies the exclusion criterion based on UCB Address.\n  VOLUME(Volser)       specifies the selection criterion based on volser.\n  XVOLUME(Volser)      specifies the exclusion criterion based on volser.\n  NAME(Unit-Name)      specifies the selection criterion based on generic\n                       or esoteric Unit name.\n  ATTRIBUTE(STORAGE/STG/PRIVATE/PVT/PUBLIC/SMS)\n                       specifies the selection criterion based on mount\n                       attribute. Only one of the keywords can be specified.\n  STORGRP(SMS-Storage-Group-Name)\n                       specifies the selection criterion based on the SMS\n                       Storage Group name.\n  SORT(id)             specifies the order in which the selected DASD volumes\n                       are displayed:\n                        id: VOL     - Volser\n                            UCB     - UCB Name (Device Address)\n                            DEVT    - Device Type\n                            ATTR    - Mount Attribute\n                            FREET   - Total Free Tracks\n                            FREEC   - Total Free Cylinders\n                            FREEP   - % Volume Free\n                            FREEE   - # Free Extents\n                            LARGET  - Largest Free Tracks\n                            LARGEC  - Largest Free Cylinders\n                            FRAG    - Fragmentation Index\n                            VFREED  - Free DSCBs in VTOC\n                            VFREEP  - % VTOC Free\n                            VTRK    - Tracks allocated to the VTOC\n                            VIX     - VTOC Index Status\n                            VOLSIZE - Volume Capacity\n                            STORGRP - SMS Storage Group\n                            SMSSTAT - SMS Volume Status\n                            CHIPDS  - 1st CHPID\n                       By default, the display is unsorted, and will\n                       normally appear in ascending order of UCB.\n  ASCENDING/DESCENDING specifies the SORT order. Significant only if\n                       SORT() is specified. Default is ASCENDING\n  MAXTASKS(#)          specifies the maximum number of sub-tasks (1-16  ) to\n                       be ATTACHed to retrieve volume information.\n  OUTFILE(ddname)      specifies the DDNAME of an output file to which\n                       volume information will be written, in addition\n                       to SYSPRINT.\n  OUTDATA(DISPLAY/CB/ALL) specifies the type of data to be written to\n                       the OUTFILE DDNAME:\n                        DISPLAY writes SYSPRINT data to OUTFILE\n                        CB      writes copies of the UCB, DCE, LSPACE,\n                                and F4DSCB to OUTFILE\n                        ALL     writes both CB and DISPLAY (default).\n  NOHEADINGS/NOHDG     suppresses headings (and page breaks).\n  NODETAILS            suppresses detail (DASD volume) lines.\n  NOTOTALS             suppresses totals line.\n  NOECHO               suppresses the display of the input command.\n  NOLSPACE             specifies that no volume space information is required.\n                       Fields displayed are: UCB, Volser, DevType, Attr, SMS\n                       data, and CHPIDs.\n  STATISTICS/STATS     displays internal processing statistics.\n  ISPF(S/E/B/N)        displays results using ISPF DM services, if available.\n                        S(pace) uses customized SPACE displays\n                        E(dif) uses ISPF Edit services\n                        B(rif) uses ISPF Browse services.\n                        N(one) uses TSO line-by-line (PUTLINE) output.\n  LINESIZE(nnn)        specifies the length of the output data in\n                       non-ISPF mode. Defaults to line length (as\n                       returned by GTSIZE).\n  MAXLWAIT(nnn)        specifies the number of seconds to wait for\n                       LSPACE to complete. Defaults are set by\n                       Assembly variables during installation.\n\nSample Output:\n-------------\n\n   2001/02/26 10:02:50          DASD Free Space Report\n                         ----------- Volume Free ------------ ----- VTOC -----\n                                             Nbr   - Largest-   Free    %\n VOLSER UCB DevType   St   Trks  Cyls    % Xtnts   Trks  Cyls  Trks DSCBs Free\n DK270E 270E 3390-3  Pvt 49,995 3,333 99.7     1 49,995 3,333    75 3,747 99.9\n DK270F 270F 3390-3  Pvt 49,995 3,333 99.7     1 49,995 3,333    75 3,747 99.9\n DK**** ****       2     99,990 6,666 99.7     2 49,995 3,333   150 7,494 99.9\n\n The following fields are also displayed under ISPF, when\n  running in batch, or if the terminal line size is wide enough to\n  accomodate them:\n   - Fragmentation Index\n   - Indexed VTOC Status\n   - Volume Capacity\n   - SMS Storage Group\n   - SMS Volume Status\n   - CHPIDs\n\n\nMembers of this dataset:\n     $$$$$DOC  - This member\n     $INSTALL  - Installation documentation (such as it is)\n     IKJTSO00  - Sample SYS1.PARMLIB(IKJTSOxx) fragment\n     ISR@PRIM  - Sample ISPF primary menu fragment\n     JCL1      - Sample JCL to assemble/link (with APAR OW48527)\n     JCL2      - Sample JCL to assemble/link (without APAR OW48527)\n     SPACE     - Assembler source\n     SSCSPC**  - ISPF Panels\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$$$#DATE": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04_\\x00\\x05\\x01\\x17\\t/\\x01\\x17\\t/\\x19$\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf9\\xf5@@@'", "ispf": {"version": "04.95", "flags": 0, "createdate": "2017-04-02T00:00:00", "modifydate": "2017-04-02T19:24:05", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-495"}, "text": "REGULAR CBT TAPE - VERSION 495    FILE:  534\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT495.FILE534\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 48 MEMBERS COUNTED; CUMULATIVE SIZE IS 52,192 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   04/02/17    19:24:05    UTC-4:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$NOTE01": {"ttr": 522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00X\\x01\\x152\\x0f\\x01\\x152\\x0f\\x14\\x17\\x00#\\x00#\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2015-11-16T00:00:00", "modifydate": "2015-11-16T14:17:58", "lines": 35, "newlines": 35, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject:  Update/Improvement for file #534 SPACE\nFrom:     \"Mahler, Ralf\" <Ralf.Mahler@rewe-group.com>\nDate:     11/16/2015 8:24 AM\nTo:       \"sbgolob@cbttape.org\" <sbgolob@cbttape.org>\n\nHello!\n\nI've attached an update of the assembler source  space\", which is\nincluded in:\n\nFile # 534 SPACE command from Paul Dion\n\nWe are using this tool very often, it's very useful and fast, but\nit had some lack of use for extended address volumes.\n\nThe volsize shown was incorrect (to small, max. 51.1G). Now,\nusing the right field for EAVs, the volsize is correct.\n\nThere are only 3 or 4 new lines and some additional change\ncomment lines. So, I didn't want to repack the complete file 534.\n\nYou may find the updates searching  MAHLER\".\n\nBest regards,\nRalf Mahler\nSystem-Betrieb. Basis Systeme (TIBB)\nREWE Systems GmbH\nHumboldtstra\u00dfe 140   144 ? 51149 K\u00f6ln/Cologne ? Germany\n\nTelefon   : +49 221 149 2108\nTelefax   : +49 221 149 97 2108\nMobil       : +49 151 5512 7667\nE-Mail     : ralf.mahler@rewe-systems.com\nInternet   : www.rewe-systems.com\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$NOTE02": {"ttr": 524, "alias": false, "halfwords": 40, "notes": 0, "parms": "b'\\x01\\x01 D\\x01\\x17\\x08\\x9f\\x01\\x17\\t/\\x19#\\x00T\\x00Z\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2\\x00\\x00\\x00\\x00T\\x00\\x00\\x00Z\\x00\\x00\\x00\\x00'", "ispf": {"version": "01.01", "flags": 32, "createdate": "2017-03-30T00:00:00", "modifydate": "2017-04-02T19:23:44", "lines": 84, "newlines": 90, "modlines": 0, "user": "SBGOLOB\u0000"}, "text": "Subject:  CBT tape SPACE update\nFrom:     EWP\nDate:     3/30/2017 3:08 PM\nTo:       Sam Golob <sbgolob@cbttape.org>\n\nSam,\n\nThanks for the response.\n\nThe changes are so small, please forgive me for sending them via\nscreenshot. It is simpler for me and should not violate company\npolicy about redistributing fully functioning code. I hope it is\neasier for you to deal with the changes this way too, rather than\nhaving to detach, file transfer, etc. If not, I apologize. One\nfinal justification: this way, you make the changes to the\nexisting code base and have the comfort of knowing exactly what\nis in it.\n\nThere are 2 changes to the SPACE package.\n\n1. Panel SSCSPC02\n\nThe error with the original is that the cursor selection that\nresolved a number like 21.3G doesn't work correctly for screens\nwider than 80 bytes, including plain old MOD 5. The problem stems\nfrom the use of the ISPF dialog variables ZSCREENW and ZSCREENC.\nZSCREENW is the physical width of the screen, 132 in a MOD 5.\nZSCREENC is the position of the cursor within the logical screen.\nBecause there is no WIDTH and EXPAND in the BODY statement, ISPF\nputs an 80-wide pillarbox centered in the physical screen. The\ndynamic area then sees only this 80-wide logical area, and\nreports the cursor position relative to that 80 wide dimension.\nThus the calculation is off and either gives the value for the\nwrong field, or no field.\n\nThe simplest solution is to make the panel expand to the full\nscreen dimension by adding  WIDTH(&ZSCREENW) EXPAND(\\\\)   to the\nBODY statement and then adding \\ \\to each BODY detail line, as\nseen below. Forgive the color coding. That's the best it can do\nthanks to the ` char.\n\n\n\nI use a custom PCOMM WS file that specifies 101 lines by 160\ncolumns. Here are before and after screen shots when I cursor\nselect the 21.3G on line 6 .\n\nBefore:\n\n\nAfter:\n\n\n\n\n2. Program SPACE\n\nThe error with the original (which probably only occurs in some\nshops, like ours) is that the SMS fields always have N/A, as seen\nabove. The problem stems from code in member SPACE that looks for\nthe SYSNAME in an undocumented SMS control block, IGCBCD. In our\nsystem, the SYSPLEX name is what appears, and it differs from any\nSYSNAME. SPACE then takes a quick exit from the SMS logic and\nshows N/A for both the SMS status and storage group. Since the\ncomments mention the logic was taken from SHOWZOS, I downloaded\nit and ran it. It showed our SYSPLEX name was the only entry in\nthe IGDBCD.\n\nWhen I looked at the SHOWZOS source, it used the same logic as\nSPACE except that if the SYSNAME was not found, it just used the\nfirst entry. So I made SPACE do the same thing and it fixed the\nproblem. My changes are marked with 'EWP'.\n\nAfter both fixes were applied, the display was correct. Changes\nare highlighted.\n\nIf you feel these are worthwhile fixes, please feel free to\nincorporate them in the next release. They are merely fix\nsuggestions and I make no ownership claims whatsoever.\n\nBest regards,\n\nEWP\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$$VER210": {"ttr": 527, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x01\\x011/\\x01\\x04&o\\tG\\x00(\\x00%\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2001-11-08T00:00:00", "modifydate": "2004-09-22T09:47:00", "lines": 40, "newlines": 37, "modlines": 0, "user": "SBGOLOB"}, "text": "Important Note:  The SPACE command assembles cleanly on MACLIBs up\n     to and including OS/390 Release 2.9.  At the Release 2.10\n     level, because of a change in macro IOSDPATH in SYS1.MACLIB ,\n     there are a couple of assembly errors, which are addressed by\n     APAR OW46838, as follows:\n\n  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n   We now have a new version of the SPACE command.... (SG 09/22/04)\n     This is Version 2.21, which should work through z/OS 1.5.\n  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\nSubject: TSO SPACE Command - OW46838\nDate: 7 Nov 2001 12:21:44 -0800\nFrom: pdion@canada.com\nTo: sbgolob@att.net\n\nHi Sam,\n  Man, I wish people would keep their software up-to-date!\n   The IBM APAR OW46838 addresses the IOSDPATH issue:\n\n  ERROR DESCRIPTION:\n  The following messages were issued when assembling\n  macro IOSDPATH:\n   ASMA144E Begin-to-continue columns not blank - MACRO - IOSDPATH\n   ASMA435I Record 130 in SYS1.MACLIB(IOSDPATH) on volume: OS39AR\n   ASMA057E Undefined operation code - IOSDP/Vary\n   ASMA435I Record 186 in SYS1.MACLIB(IOSDPATH) on volume: OS39AR\n\n\n  LOCAL FIX:\n  Edit the following lines in IOSDPATH (located in SYS1.MACLIB):\n   $P5=PXD1562 ,HBB7703,000330,PDPS:  Update Copyright Information\n  The above line continues in to column 72, erase the 'n' in\n  'Information'\n  indicates that path is offline due to a        07375000\n  The above line needs a continuation character in column 72.\n\n  As far as I can tell, there is no PTF.\n     Paul\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$INSTALL": {"ttr": 529, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x18\\x00\\x00\\x01\\x06\\x11\\x1f\\x01\\x06\\x11\\x1f\\x00\\x00\\x00\\xe8\\x00\\xe5\\x00\\x00\\xe2\\xd7\\xc1\\xc3\\xc5@@@@@'", "ispf": {"version": "02.24", "flags": 0, "createdate": "2006-04-21T00:00:00", "modifydate": "2006-04-21T00:00:00", "lines": 232, "newlines": 229, "modlines": 0, "user": "SPACE"}, "text": "Introdction:\n-----------\n   This TSO command/program consists of the following members:\n     SPACE     - Assembler source\n     SSCSPC**  - ISPF panels\n\n   In a nutshell, installation consists of assembling the source into\na load library. If you wish to make customized ISPF invocation and\ndisplay panels available, panels SSCSPC** should also be copied to a\nlibrary in the ISPPLIB concatenation (or that is LIBDEFed to ISPPLIB).\n   Further steps are required if you do *not* have the PTFs associated\nwith IBM APAR OW48527 installed on all systems where this program may\nexecute. Specifically, they are:\n- the load module *must* be link-edited with AC(1), into an APF auth\n  library,\n- Further, if this program is to be made available as a TSO command\n  and should be able to use ISPF Dialog Manager services, the command\n  must:\n  - be located in a LNKLSTed or TSO STEPLIBed library,\n  - be named in the AUTHTSF section of SYS1.PARMLIB(IKJTSOxx)\n\n   There are a number of Assembly variables that should be reviewed\nbefore assembling the program.\n\nAssembly Variables:\n------------------\n   Several assembly variables can be changed to customize this program\nfor your installation. These variables are all defined and initialized\nat the beginning of the source code. The variables are:\n\n- &PGMNAME\n  This variable defines the name of the program. It is used:\n  - to name the CSECT of the program,\n  - as the prefix of the various messages issued by the program\n  - as the command name when preparing to invoke IKJSCAN in batch\n  - in the statistics line to identify the program\n  - in the 'dataset name' in EDIF and BRIF displays\n  This variable defaults to 'SPACE', but can be changed to any valid\n  program name.\n  If this variable is changed, it is probably reasonable, but not\n  required, that the name of the load module in JCL1 or JCL2 also\n  be changed.\n\n- &VERSION\n  This variable defines the current version of the program. It is used:\n  - in the statistics line to identify the program\n  The version number specified by this variable is used as part of\n  the change documentation(?) maintained in the source of the program,\n  and so should probably not be changed.\n\n- &PNLNAME\n  This variable defines the name of the ISPF panel that will be used to\n  display the output of the command when using the customized display.\n  It is used:\n  - in the invocation of the ISPF Service DISPLAY\n  If the value of this variable is changed, the name of the member\n  containing a copy of panel SSCSPC02 in the ISPPLIB concatenation\n  must also be changed.\n\n- &SORT_Prompt_Popup_Panel\n  This variable defines the name of the ISPF panel used to prompt the\n  user when a SORT command is entered with no or invalid operands when\n  the results are displayed via ISPF(B) or ISPF(S).\n  If the value of this variable is changed, the name of the member\n  containing a copy of panel SSCSPC03 in the ISPPLIB concatenation\n  must also be changed.\n\n- &ISPF_by_Default\n  This variable indicates that ISPF Dialog Manager services, if\n  available, should be used to display the results of this program.\n  If this variable is set to 0, or ISPF DM services are not available,\n  the results of this command will be displayed in TSO line-by-line\n  mode (using PUTLINE). The effect of this variable can be over-\n  ridden during execution using the ISPF keyword.\n  If the value of this variable is changed, you may want to update the\n  TSO HELP data, specified as comments within the source of the program,\n  and the batch help messages starting at label C_ErrMsgs\n\n- &ISPF_Default_Type\n  This variable defines the type of ISPF display to be presented,\n  if appropriate (that is, if the variable &ISPF_by_Default is set to\n  1 and the ISPF keyword was not specified on invocation, or if the\n  ISPF keyword was specified without any operand). The valid types:\n  - SPACE   : a customized panel, named by &PNLNAME\n  - EDIF    : ISPF Edit services\n  - BRIF    : ISPF Browse services\n  - NONE    : No ISPF services, TSO line-by-line\n  If the value of this variable is changed, you may want to update the\n  TSO HELP data, specified as comments within the source of the program,\n  and the batch help messages starting at label C_ErrMsgs\n  If the value is changed to something other than the 4 values above,\n  TSO line-by-line output will be used.\n\n- &Fore_LSPACE_Wait\n  This variable defines the default number of seconds in which LSPACE\n  must complete when running in the foreground (TSO). If LSPACE\n  has not completed within this time, the LSPACE request is terminated,\n  and no usage information is returned.\n  A value of 0 indicates no limit, and LSPACE will use the least of:\n    - the MIH time for the device, and\n    - the LSPACE internal default of 240 seconds.\n  This default can be overridden by the MAXLWAIT keyword.\n\n- &Back_LSPACE_Wait\n  This variable defines the default number of seconds in which LSPACE\n  must complete when running in the background (Batch or STC).\n  If LSPACE has not completed within this time, the LSPACE request is\n  terminated, and no usage information is returned.\n  A value of 0 indicates no limit, and LSPACE will use the least of:\n    - the MIH time for the device, and\n    - the LSPACE internal default of 240 seconds.\n  This default can be overridden by the MAXLWAIT keyword.\n\n- &Default_SubTask_Count\n  This variable defines the default number of subtasks to be created\n  to retrieve the DASD usage data (via LSPACE). If this value is 0,\n  the number of subtasks created will be the least of:\n  - the number of volumes against which LSPACE is to be issued, or\n  - double the number of (non-ZIIP/ZAAP) engines assigned to the\n    executing system, plus 1\n  This default can be overridden by the MAXTASKS keyword.\n\n- &Max_SubTask_Count\n  This variable defines the maximum number of subtasks to be created\n  to retrieve the DASD usage data (via LSPACE).\n  This variable is used to limit the value of the MAXTASKS keyword.\n\nInstallation:\n-----------\nThere are 2 JCL members supplied:\n - JCL1 - Assemble and link non-APFed, for those installations with\n          APAR OW48527 installed\n - JCL2 - Assemble and link APFed, for those installations without\n          APAR OW48527 installed\n\n   Select the appropriate JCL member, and edit it to provide a valid\nJOB card, and to change the SYSLMOD library as appropriate. Note that\nif you are using JCL2, the SYSLMOD library must be in the LNKLST, or in\nthe TSO STEPLIB concatenation; this is a requirement of IKJEFTSR.\nThe SYSLMOD library must also be APF-Authorized.\n\nWhichever JCL member you use, remember to change the member name\non the SYSLMOD statement if you changed the name of the program, above.\n\n   If you use JCL2 (the APFed version), you must update member IKJTSOxx\nin SYS1.PARMLIB if you wish to make ISPF displays available. The member\nname used in the Link-edit SYSLMOD statement must be present in the\nAUTHTSF section, and must not be present in the AUTHCMD section. The\nTSO command 'PARMLIB UPDATE(xx)' can be used to bring the update into\neffect.\n\n   If you wish to make the panels available, copy members SSCSPC**\nto a library available to ISPF (in the ISPPLIB concatenation).\nAgain, if you updated the Assembly variable &PNLNAME, above,\nrename the panel(s). SSCSPC02 is used to display the results of the\ncommand, while SSCSPC01 generates the command to invoke SPACE. You may\nwish to make an entry from a generally available panel to SSCSPC01 -\nthere is an example in member SPF@PRIM. SSCSPC03 is the SORT pop-up\npanel, and all the other SSCSPC** panels are help panels.\n\n   If you want to make HELP information available, there is an exam-\nple of a TSO HELP member included as comments in member SPACE. Extract\nthis from member SPACE, and remove leading and trailing '*'. If you\nchanged the name of the program (Assembly variable &PGMNAME, above),\nyou may want to update the message portion of the TSO HELP, since the\nmessages are generated with the prefix &PGMNAME. Once you are happy with\nthe HELP member, save it in a library in the SYSHELP concatenation, with\na member name the same as the SYSLMOD member name from the Link-edit.\n\n\nTroubleshooting.\n---------------\n\n If you get Assembly errors in the IOSDPATH macro, you may want to\nto take a look at IBM APAR OW46838, which talks about errors in the\nmacro, and a Local Fix to repair them.\n\nSPACE02I Insufficient APF authorization\n         The SPACE command requires APF authorization, but is cur-\n         rently not authorized even when invoked via IKJEFTSR.\n         Possible reasons:\n         - SPACE not present in the AUTHTSF section of\n           SYS1.PARMLIB(IKJTSOxx)\n         - SPACE not Linked with AC(1)\n         - SPACE not Linked into an APFed library\n         - IKJEFTSR failed with RC=14, Reason=18 or 34\n\nSPACE03I ISPF DM Services unavailable xx-yy\n         This message is issued when the SPACE command could not\n         use ISPF Dialog Management Services to display the\n         results of the command in ISPF format. Either the required\n         ISPF modules were unavailable, or the environment is such\n         that ISPF Dialog Management Services are not functional.\n         In the message, xx indicates which ISPF service is\n         unavailable, and yy is the return code from that service.\n         The codes are generated and documented(?) in block G0010\n         in the assembler source.\n         Possible Causes:\n         - SPACE present in the AUTHCMD section of\n           SYS1.PARMLIB(IKJTSOxx)\n\nSPACE06I Program not found in STEPLIB/LNKLST\n         This command requires that the processing program reside\n         in the current STEPLIB or system LNKLST concatenation,\n         but the program cannot be located. This is a requirement\n         of the TSO Service Routine IKJEFTSR.\n         This corresponds to IKJEFTSR failure RC=14, Reason=28\n\nSPACE07I IKJEFTSR error xx-yy\n         The TSO/E Service Routine IKJEFTSR could not complete\n         successfully. xx is the Return Code, and yy the Reason\n         Code.\n\nSPACE09I Incompatible versions of SPACE found\n         The TSO/E Service Routine IKJEFTSR invoked a different\n         version of SPACE (from LNKLST/STEPLIB) than was\n         originally invoked (from ISPLLIB?).\n         Various other ABENDs may be caused by this situation as well.\n\n  If the device types for DASD volumes show up as blanks, you might\ncheck that CSECT IECDDEVT in SYS1.NUCLEUS(IECDINIT) exists, and that\nit is still in the format expected (see comments after label D0260 in\nthe source). We use NUCLKUP to get the address of this CSECT. Note that\nCSECT IECDDEVT is undocumented by IBM.\n\n  If you have set ISPF_by_Default to 1, ISPF_Default_Type to something\nother than NONE, and do not enter the ISPF keyword on the command\ninvocation, no error messages are produced if ISPF DM services are not\navailable. To cause error messages to be produced, specify the ISPF\nkeyword at command invocation - if ISPF DM services are unavailable,\nyou should get msg SPACE03I, indicating the cause of the error.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "@FILE534": {"ttr": 772, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04_\\x00W\\x01\\x17\\t/\\x01\\x17\\t/\\x19#\\x00/\\x00/\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf9\\xf5@@@'", "ispf": {"version": "04.95", "flags": 0, "createdate": "2017-04-02T00:00:00", "modifydate": "2017-04-02T19:23:57", "lines": 47, "newlines": 47, "modlines": 0, "user": "CBT-495"}, "text": "//***FILE 534 contains the SPACE TSO command from Paul Dion.  This  *   FILE 534\n//*           is a very full-featured LSPACE type command which     *   FILE 534\n//*           tells you how much free space is on your disk packs.  *   FILE 534\n//*                                                                 *   FILE 534\n//*      Paul Dion    pdion@canada.com                              *   FILE 534\n//*                                                                 *   FILE 534\n//*      Fixed for EAV volumes by Ralf Mahler.                      *   FILE 534\n//*                   Ralf.Mahler@rewe-group.com                    *   FILE 534\n//*                                                                 *   FILE 534\n//*      Fixed for large TSO screens and SMS by EWP.                *   FILE 534\n//*                                                                 *   FILE 534\n//*       This is (yet) another version of the ubiquitous SPACE     *   FILE 534\n//*       command that displays DASD volume usage statistics.       *   FILE 534\n//*       It can:                                                   *   FILE 534\n//*                                                                 *   FILE 534\n//*       - cope with DASD devices RESERVEd on other systems        *   FILE 534\n//*         without hanging                                         *   FILE 534\n//*       - run as a TSO command or batch program                   *   FILE 534\n//*       - use EDIF or BRIF to display results                     *   FILE 534\n//*       - create machine-readable output (UCB, DCE, LSPACE        *   FILE 534\n//*         data, F4DSCB)                                           *   FILE 534\n//*       - select devices based on UCB address, Volser,            *   FILE 534\n//*         Esoteric or Mount Attribute                             *   FILE 534\n//*       - sort results by any of the displayed fields             *   FILE 534\n//*                                                                 *   FILE 534\n//*       The data presented by the command are:                    *   FILE 534\n//*       - UCB address                                             *   FILE 534\n//*       - Volser                                                  *   FILE 534\n//*       - Device Type                                             *   FILE 534\n//*       - Use Attribute                                           *   FILE 534\n//*       - Free Trks, Cyls, %                                      *   FILE 534\n//*       - Largest Trks, Cyls                                      *   FILE 534\n//*       - VTOC Trks, free DSCBs, % free                           *   FILE 534\n//*       - VTOC Index status                                       *   FILE 534\n//*       - Fragmentation Index                                     *   FILE 534\n//*       - SMS Storage Class                                       *   FILE 534\n//*       - SMS Volume Status                                       *   FILE 534\n//*       - CHPIDs                                                  *   FILE 534\n//*                                                                 *   FILE 534\n//*         This version of the SPACE command seems to be able      *   FILE 534\n//*      to cope with DASD RESERVEd on another system.  This is a   *   FILE 534\n//*      non-issue for those installations that have IBM APAR       *   FILE 534\n//*      OW48527 installed, which allows the invoker of LSPACE      *   FILE 534\n//*      to specify a time-out value (in seconds).  For those       *   FILE 534\n//*      installations that do not have the APAR installed, the     *   FILE 534\n//*      matter becomes somewhat complicated.                       *   FILE 534\n//*                                                                 *   FILE 534\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "IKJTSO00": {"ttr": 774, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x0e\\x00\\x00\\x01\\x01\\x05\\x7f\\x01\\x01\\x05\\x7f\\x00\\x00\\x00\\x1b\\x00\\x1b\\x00\\x00\\xe2\\xd7\\xc1\\xc3\\xc5@@@@@'", "ispf": {"version": "02.14", "flags": 0, "createdate": "2001-02-26T00:00:00", "modifydate": "2001-02-26T00:00:00", "lines": 27, "newlines": 27, "modlines": 0, "user": "SPACE"}, "text": "   .\n   .\n   .\n   .\n   .\n   .\n   .\n\nAUTHTSF NAMES(   /* PROGRAMS TO BE AUTHORIZED WHEN  */      +\n                 /* WHEN CALLED THROUGH THE TSO     */      +\n                 /* SERVICE FACILITY.               */      +\n   .\n   .\n   .\n   SPACE                     /*                     */      +\n   .\n   .\n   .\n             )\n\n   .\n   .\n   .\n   .\n   .\n   .\n   .\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ISR@PRIM": {"ttr": 776, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x0e\\x00\\x00\\x01\\x01\\x05\\x7f\\x01\\x01\\x05\\x7f\\x00\\x00\\x00\\x08\\x00\\x08\\x00\\x00\\xe2\\xd7\\xc1\\xc3\\xc5@@@@@'", "ispf": {"version": "02.14", "flags": 0, "createdate": "2001-02-26T00:00:00", "modifydate": "2001-02-26T00:00:00", "lines": 8, "newlines": 8, "modlines": 0, "user": "SPACE"}, "text": "&ZSEL = TRANS (TRUNC (&ZCMD,'.')\n   .      .      .        .       .\n   .      .      .        .       .\n   .      .      .        .       .\n   .      .      .        .       .\n SPACE,'PANEL(SSCSPC01) SCRNAME(SPACE)'\n   .      .      .        .       .\n   .      .      .        .       .\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "JCL1": {"ttr": 778, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x15\\x00\\x00\\x01\\x02\\x07\\x0f\\x01\\x03(\\x0f\\x00\\x00\\x00\\x17\\x00\\x17\\x00\\x00\\xe2\\xd7\\xc1\\xc3\\xc5@@@@@'", "ispf": {"version": "02.21", "flags": 0, "createdate": "2002-03-11T00:00:00", "modifydate": "2003-10-07T00:00:00", "lines": 23, "newlines": 23, "modlines": 0, "user": "SPACE"}, "text": "//SPACE    JOB ....\n//*\n//STEP1   EXEC PGM=ASMA90,\n//             PARM='NODECK,OBJECT,XREF(SHORT,UNREFS),NOALIGN',\n//             REGION=6M\n//SYSLIB    DD DISP=SHR,DSN=SYS1.MACLIB\n//          DD DISP=SHR,DSN=SYS1.MODGEN\n//SYSPRINT  DD SYSOUT=*\n//SYSUT1    DD UNIT=SYSALLDA,\n//             SPACE=(4096,(120,120),,,ROUND)\n//SYSLIN    DD UNIT=SYSALLDA,DISP=(,PASS,DELETE),\n//             DSN=&&OBJ,SPACE=(3040,(40,40),,,ROUND),\n//             DCB=(RECFM=FB,LRECL=0080,BLKSIZE=0)\n//SYSIN     DD DISP=SHR,DSN=hlq.SPACE.PDS(SPACE)  <=== Update !!!\n//*\n//STEP2   EXEC PGM=HEWL,\n//             PARM='MAP,LET,LIST=SUMMARY,NCAL,RENT,REUS,REFR',\n//             COND=(0,LT),\n//             REGION=4M\n//SYSPRINT DD  SYSOUT=*\n//SYSLIN   DD  DISP=(OLD,DELETE,DELETE),DSN=&&OBJ\n//SYSLMOD   DD DISP=SHR,DSN=load.library(SPACE)  <=== Update !!!\n//\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "JCL2": {"ttr": 780, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x15\\x00\\x00\\x01\\x02\\x07\\x0f\\x01\\x03(\\x0f\\x00\\x00\\x00\\x17\\x00\\x17\\x00\\x00\\xe2\\xd7\\xc1\\xc3\\xc5@@@@@'", "ispf": {"version": "02.21", "flags": 0, "createdate": "2002-03-11T00:00:00", "modifydate": "2003-10-07T00:00:00", "lines": 23, "newlines": 23, "modlines": 0, "user": "SPACE"}, "text": "//SPACE    JOB ....\n//*\n//STEP1   EXEC PGM=ASMA90,\n//             PARM='NODECK,OBJECT,XREF(SHORT,UNREFS),NOALIGN',\n//             REGION=6M\n//SYSLIB    DD DISP=SHR,DSN=SYS1.MACLIB\n//          DD DISP=SHR,DSN=SYS1.MODGEN\n//SYSPRINT  DD SYSOUT=*\n//SYSUT1    DD UNIT=SYSALLDA,\n//             SPACE=(4096,(120,120),,,ROUND)\n//SYSLIN    DD UNIT=SYSALLDA,DISP=(,PASS,DELETE),\n//             DSN=&&OBJ,SPACE=(3040,(40,40),,,ROUND),\n//             DCB=(RECFM=FB,LRECL=0080,BLKSIZE=0)\n//SYSIN     DD DISP=SHR,DSN=hlq.SPACE.PDS(SPACE)  <=== Update !!!\n//*\n//STEP2   EXEC PGM=HEWL,\n//             PARM='MAP,LET,LIST=SUMMARY,NCAL,RENT,REUS,REFR,AC(1)',\n//             COND=(0,LT),\n//             REGION=4M\n//SYSPRINT DD  SYSOUT=*\n//SYSLIN   DD  DISP=(OLD,DELETE,DELETE),DSN=&&OBJ\n//SYSLMOD   DD DISP=SHR,DSN=apf.lnklst.library(SPACE)  <=== Update !!!\n//\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SPACE": {"ttr": 782, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x1a\\x00E\\x01\\x152\\x0f\\x01\\x17\\t/\\x10%@{@u\\x00\\x00\\xc2\\xc9\\xc7\\xe2\\xc3\\xd9\\xd5@@@'", "ispf": {"version": "02.26", "flags": 0, "createdate": "2015-11-16T00:00:00", "modifydate": "2017-04-02T10:25:45", "lines": 16507, "newlines": 16501, "modlines": 0, "user": "BIGSCRN"}, "text": "*PROCESS       XREF(SHORT,UNREFS)\n*PROCESS       NODXREF\n*PROCESS       NORXREF\n*PROCESS       NOALIGN\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*   Assembler Variables                                               *\n*  These variables define various names, processing defaults, etc.,   *\n*  and should be reviewed before assembling.                          *\n*                                                                     *\n*  &PGMNAME                                                           *\n*      Used in the Assembler listing, message IDs, etc                *\n*  &VERSION                                                           *\n*      Used in Title, Statistics line                                 *\n*                                                                     *\n*  &PNLNAME                                                           *\n*      Name of panel used in ISPF display, mode ISPF(S)               *\n*  &SORT_Prompt_Popup_Panel                                           *\n*      Name of the panel used to pronpt, if required, for options for *\n*      the SORT command, under ISPF(S) or ISPF(B)                     *\n*  &OUTPUT_Prompt_Popup_Panel                                         *\n*      Name of the panel used to pronpt, if required, for options for *\n*      the OUTPUT command, under ISPF(S) or ISPF(B)                   *\n*                                                                     *\n*  &ISPF_by_Default                                                   *\n*      Use ISPF for on-line displays                                  *\n*  &ISPF_Default_Type                                                 *\n*      Default type of ISPF display                                   *\n*                                                                     *\n*  &Fore_LSPACE_Wait                                                  *\n*      Maximum seconds to wait for LSPACE to complete when running in *\n*      the foreground (TSO)                                           *\n*  &Back_LSPACE_Wait                                                  *\n*      Maximum seconds to wait for LSPACE to complete when running in *\n*      the background (Batch and STC)                                 *\n*                                                                     *\n*  &Default_SubTask_Count                                             *\n*      Default  number of subtasks to dispatch to issue LSPACEs. If 0,*\n*      defaults to (number of engines * 2) + 1.                       *\n*  &Max_SubTask_Count                                                 *\n*      Maximum  number of subtasks to dispatch to issue LSPACEs. If 0,*\n*      defaults to 16.                                                *\n*                                                                     *\n*---------------------------------------------------------------------*\n         LCLC  &PGMNAME              Program Name\n&PGMNAME SETC  'SPACE'\n         LCLC  &VERSION              Program Version\n&VERSION SETC  'V2.26'\n\n         LCLC  &PNLNAME              Panel Name for ISPF(S)\n&PNLNAME SETC  'SSCSPC02'\n\n         LCLC  &SORT_Prompt_Popup_Panel Name for SORT pop-up prompt\n&SORT_Prompt_Popup_Panel SETC 'SSCSPC03'\n\n         LCLC  &OUTPUT_Prompt_Popup_Panel  Name for OUTPUT pop-up prmt\n&OUTPUT_Prompt_Popup_Panel SETC 'SSCSPC04'\n\n         LCLB  &ISPF_by_Default      Use ISPF if available?\n&ISPF_by_Default SETB 1               Yes, if available\n*&ISPF_by_Default SETB 0               No, TSO line-by-line as default\n\n         LCLC  &ISPF_Default_Type    Default ISPF display type\n&ISPF_Default_Type SETC 'SPACE'       Customized SPACE panel\n*&ISPF_Default_Type SETC 'EDIF'        Edit\n*&ISPF_Default_Type SETC 'BRIF'        Browse\n*&ISPF_Default_Type SETC 'NONE'        None, TSO line-by-line\n\n         LCLA  &Fore_LSPACE_Wait     LSPACE Wait time in foreground\n&Fore_LSPACE_Wait SETA 5              5 seconds\n\n         LCLA  &Back_LSPACE_Wait     LSPACE Wait time in background\n&Back_LSPACE_Wait SETA 0              LSPACE/MIH default\n\n         LCLA  &Default_SubTask_Count Number of Subtasks to dispatch\n&Default_SubTask_Count SETA 0          2 * Nbr engines + 1\n\n         LCLA  &Max_SubTask_Count     Maximum Subtasks to dispatch\n&Max_SubTask_Count     SETA 16         Compatibility with prev versions\n\n\n*---------------------------------------------------------------------*\n*  Do some trivial validation on the Assembly Variables               *\n*---------------------------------------------------------------------*\n         AIF   (&Default_SubTask_Count GE 0).VAL_010\n         MNOTE 4,'Value of &&Default_SubTask_Count negative - using Dyn+\n               amic SubTask count'\n&Default_SubTask_Count SETA 0\n.VAL_010 ANOP\n         AIF   (&Max_SubTask_Count GE 0).VAL_020\n         MNOTE 4,'Value of &&Max_SubTask_Count negative - using default+\n                value of 16'\n&Max_SubTask_Count     SETA 16\n.VAL_020 ANOP\n         AIF   (&Max_SubTask_Count GE &Default_SubTask_Count).VAL_030\n         MNOTE 4,'&&Max_SubTask_Count less than &&Default_SubTask_Count+\n                 - using max of &Default_SubTask_Count'\n&Max_SubTask_Count     SETA &Default_SubTask_Count\n.VAL_030 ANOP\n         AIF   (&Fore_LSPACE_Wait GE 0).VAL_040\n         MNOTE 4,'&&Fore_LSPACE_Wait is negative - setting to 5 sec.'\n&Fore_LSPACE_Wait      SETA 5\n.VAL_040 ANOP\n         AIF   (&Back_LSPACE_Wait GE 0).VAL_050\n         MNOTE 4,'&&Back_LSPACE_Wait is negative - setting to 0'\n&Back_LSPACE_Wait      SETA 0\n.VAL_050 ANOP\n\n\n&PGMNAME TITLE 'Display DASD Free Space'\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Program   : SPACE                                                  *\n*                                                                     *\n*  Abstract  : This program will display the free space on DASD       *\n*              volumes, as selected by the user. This program can     *\n*              run as a batch job or TSO command, using ISPF Dialogue *\n*              Manager facilities, if appropriate.                    *\n*                                                                     *\n*  Inputs    :                                                        *\n*      Parameters :If Batch, N/A                                      *\n*                  If TSO Command, R1 = A(CPPL) (see comments below   *\n*                                                for operands)        *\n*      Files      :If Batch, SYSIN = Control cards                    *\n*      Other      :If TSO Cmd, Command Buffer                         *\n*                                                                     *\n*  Outputs:                                                           *\n*      Returncodes:                                                   *\n*      Messages   :xxxxx                                              *\n*      Files      :If Batch, SYSPRINT = output Messages               *\n*      Other      :None                                               *\n*                                                                     *\n*  Program     Reentrant, problem key and state, standard linkage,    *\n*  Attributes: APF-authorized(maybe), AMODE(31), RMODE(ANY)           *\n*                                                                     *\n*  Implement-:  Unless you have the PTFs for IBM APAR OW48527 APPLYed *\n*  ation        on the system(s) on which this program is running,    *\n*               this program must be be APF Authorized.               *\n*               It is recommended that it also be installed as a TSO  *\n*               command, taking advantage of ISPF Dialog Manager      *\n*               Services, if available. To do this, it must:          *\n*                 - reside in a TSO STEPLIB or LNKLST library         *\n*                 - be named in the AUTHTSF (but *not* the AUTHCMD)   *\n*                   section of SYS1.PARMLIB(IKJTSOxx).                *\n*               Note that all code runs in Problem State and Key; APF *\n*                    authorization is required to issue SYSEVENTs.    *\n*                    See below for further information.               *\n*                                                                     *\n*  Special   :  This program was written to be run either as a program*\n*  Notes       or a TSO command; if as a TSO command, it will use     *\n*              ISPF Dialog Manager services, if available.            *\n*               If this program runs on a system which does *not*     *\n*              have the PTFs for IBM APAR OW48527 installed, it       *\n*              needs to be APF authorized (it uses SYSEVENT DONTSWAP *\n*              and OKSWAP while retrieving DASD info - there is an    *\n*              explanation below, for those of you who have way too   *\n*              much time on your hands). Unfortunately, ISPF DM       *\n*              Services are not available to Authorized TSO Commands. *\n*              The following strategy (?) is used:                    *\n*               - The command is invoked as non-authorized (even      *\n*                 though the load module is LINKed AC(1), because     *\n*                 it is not named in AUTHCMD)                         *\n*               - IKJEFTSR is used to re-invoke itself to perform     *\n*                 the authorized bits (this time it is authorized     *\n*                 because it is named in AUTHTSF)                     *\n*               - The original (unauthorized) command then uses       *\n*                 ISPF DM Services to display the results.            *\n*                                                                     *\n*               When running in Batch, TSO PARSE is used to scan      *\n*              the control cards (from SYSIN), so the syntax of the   *\n*              batch control cards is the same as the TSO Command     *\n*              syntax.                                                *\n*                                                                     *\n*               The following comments apply only when running on     *\n*              systems that do *not* have the PTFs for IBM APAR       *\n*              OW48527 installed:                                     *\n*               This program issues LSPACE macros to retrieve usage   *\n*              data for a volume. If LSPACE is issued against a DASD  *\n*              volume that is RESERVEd on another system, it will     *\n*              hang until the RESERVE is released. This gets          *\n*              particularly annoying when being run from TSO.         *\n*               The program gets hung because:                        *\n*                - LSPACE creates an ESTAE with PURGE=NONE            *\n*                - LSPACE invokes CVAF                                *\n*                - CVAF creates an ESTAE with PURGE=QUIESCE           *\n*                - CVAF tries to touch the device, and hangs because  *\n*                  of a RESERVE                                       *\n*                - A CANCEL is issued for the Address Space           *\n*                - When the 1st ESTAE (CVAFs) gets scheduled, an      *\n*                  attempt is made to QUIESCE the I/O, which never    *\n*                  happens, so we hang.                               *\n*              (Thanks to the IBM ETR folks for their help in figuring*\n*               out what was going on).                               *\n*                                                                     *\n*              To try to circumvent this situation, we issue STIMERMs *\n*              with an exit before issuing LSPACEs. If the exit is    *\n*              invoked, an ESTAE with PURGE=HALT is extablished, and  *\n*              an ABEND U522 issued within the STIMERM exit.          *\n*              The ESTAE from the STIMERM exit is invoked first, so   *\n*              the I/O is PURGEd, and the ESTAE percolates to the     *\n*              CVAF and LSPACE ESTAEs, which can now run because the  *\n*              I/O has been PURGEd.                                   *\n*              So far so good, no APF-authorization required, but ... *\n*              while the LSPACE is trying to get to a RESERVEd device,*\n*              but before the STIMERM pops, SRM/WM may kick in        *\n*              and decide that we should be swapped out. If (s)he     *\n*              does this. the TCBs will be made non-dispatchable,     *\n*              and an attempt will be made to quiesce the I/O.        *\n*              The I/O cannot, in fact, be quiesced, so we end up     *\n*              with a non-dispatchable Address Space waiting for an   *\n*              'unquiescable' I/O to be quiesced. When the STIMERM    *\n*              pops, the exit (which would get us out of this mess)   *\n*              cannot run because we are non-dispatchable.            *\n*              All this is a long way of saying that we have to be    *\n*              APF authorized, so we can issue SYSEVENT DONTSWAP      *\n*              while the LSPACE tasks are running, so that the        *\n*              STIMERM Exit can be dispatched to ESTAE and ABEND.     *\n*                                                                     *\n*              Note that APAR OW48527 addresses this problem by       *\n*              allowing the invoker of LSPACE to specify a time-out,  *\n*              defaulting to 5 seconds. This program determines if    *\n*              the appropriate PTFs have been APPLYed to the active   *\n*              system by checking the LSPACE SVC for literals that    *\n*              are present only when the PTFs have been installed.    *\n*                                                                     *\n*                                                                     *\n*  Coding    : All data areas in Dynamic Storage have names starting  *\n*   Notes       with '@'. One area of Dynamic Storage is acquired     *\n*               during initialization, and is used as a LIFO stack    *\n*               for dynamic storage.                                  *\n*                                                                     *\n*              The names of the Routines follow the pattern:          *\n*                 xnnnnn                                              *\n*               where x    is an alphabetic character, and            *\n*                     n    is a numeric character.                    *\n*                                                                     *\n*              Data in dynamic storage that are globally accessible   *\n*               have names of the form:                               *\n*                @_anyname                                            *\n*              Data associated with a routine typically have names:   *\n*                 x_anyname or @x_anyname                             *\n*               where 'x' is the alphabetic character associated      *\n*                         with the routine                            *\n*              Addressability to globally-accessible dynamic data is  *\n*               via R12; local dynamic data is addressable via R13.   *\n*                                                                     *\n*              Each routine establishes it's own base register,       *\n*               typically R11, for local, read-only variables. Note   *\n*               that there is no base register for the code, except   *\n*               where required  around macros, etc., when R2 is used, *\n*               so be careful if you use R2 for other purposes.       *\n*                                                                     *\n*                                                                     *\n*  Change                                                             *\n*  History   : 1990/06/11 SDDA030 - V1.0                              *\n*                                 - New                               *\n*              1996/03/13 SDDA030 - V1.1                              *\n*                                   Added 4-digit UCB capability      *\n*                                   (D00010)                          *\n*              1997/05/16 SDDA030 - V1.2                              *\n*                                 - Corrected IKJPARS PCL to accept   *\n*                                   4-digit UCBs (C00010)             *\n*                                 - Made Y2K compliant (!)            *\n*                                 - ATTACH subtasks to issue LSPACE   *\n*                                   (D00010, H00010)                  *\n*              1998/09/17 SDDA030 - V2.0                              *\n*                                 - Removed APF checks, and used      *\n*                                   UCBSCAN with DCEAREA operand to   *\n*                                   get DCE info (D00010).            *\n*                                 - Corrected communications between  *\n*                                   mother and daughter TCBs (D07000, *\n*                                   H00010).                          *\n*              1998/09/22 SDDA030 - V2.1                              *\n*                                 - Added Statistics display          *\n*                                 - Runs RMODE(ANY), moving SYSIN and *\n*                                   SYSPRINT I/O routines to 24-bit   *\n*                                   storage. Also move STLINENO       *\n*                                   routine to 24-bit storage.        *\n*              1998/11/13 SDDA030 - V2.2                              *\n*                                 - Used IKJPARS to parse operands in *\n*                                   batch.                            *\n*              1998/11/23 SDDA030 - V2.3                              *\n*                                 - Updated STIMERM exit to POST SPACE*\n*                                   only if subtask is in SVC 78      *\n*                                   (LSPACE).                         *\n*              1999/01/14 SDDA030 - V2.4                              *\n*                                 - Made check for ISPF, TSO command  *\n*                                   or CALL/PGM= checks more consis-  *\n*                                   tent across Batch/TSO environs.   *\n*              1999/03/03 SDDA030 - V2.5                              *\n*                                 - Added version-release variable    *\n*                                   and a new statistics line to      *\n*                                   display it.                       *\n*              1999/05/27 SDDA030 - V2.6                              *\n*                                 - Used LIFO Stack for our dynamic   *\n*                                   areas.                            *\n*                                 - Moved SYSIN and SYSPRINT routines *\n*                                   back into mainline code (rather   *\n*                                   than moving them below-the-line). *\n*              1999/07/30 SDDA030 - V2.7                              *\n*                                 - Added code to cope with SYSIN     *\n*                                   allocated to the terminal (31-bit *\n*                                   SAM is not supported).            *\n*                                 - Added CPU Time to the statistics. *\n*                                 - Added TSO HELP comments.          *\n*              1999/08/20 SDDA030 - V2.8                              *\n*                                 - Fixed up and documented the       *\n*                                   STACK macro.                      *\n*                                 - Added internal stack statistics.  *\n*                                 - Added Wait Time to the statistics.*\n*                                 - Added Routine W00010 to manage    *\n*                                   VolTbl                            *\n*              1999/09/01 SDDA030 - V2.9                              *\n*                                 - Changed method of obtaining totals*\n*                                   to avoid CDS instruction.         *\n*              1999/09/30 SDDA030 - V2.10                             *\n*                                 - Changed default display order to  *\n*                                   ascending order of unit address.  *\n*                                 - Flagged volumes initialized as SMS*\n*                                   (in the VTOC), but not SMS managed*\n*                                   (in the UCB).                     *\n*                                 - Reset Stack statistics for each   *\n*                                   iteration.                        *\n*                                 - Added 'ISPF' keyword to display   *\n*                                   data via ISPF table and panel if  *\n*                                   ISPF services are available.      *\n*                                 - Removed ISPF initialization stuff;*\n*                                   now invoked as a CMD with the     *\n*                                   ISPF keyword.                     *\n*                                 - Moved most of TSO Cmd init. code  *\n*                                   from C00010 to G00010.            *\n*                                 - Honoured NOHEADINGS, NODETAILS and*\n*                                   NOTOTALS when outputting to ISPF. *\n*                                 - Added # vols to Totals line (in   *\n*                                   DevType field).                   *\n*                                 - Made the generation of headings   *\n*                                   more consistent across environ-   *\n*                                   ments.                            *\n*                                 - Added keyword descriptions when   *\n*                                   Parse fails in batch.             *\n*              2000/01/19 SDDA030 - V2.11                             *\n*                                 - Added SORT keywords for all fields*\n*                                 - Added ASCENDING/DESCENDING kwds.  *\n*                                 - Added capability of writing output*\n*                                   to an file:                       *\n*                                    OUTFILE(ddname)                  *\n*                                    OUTDATA(ALL/CB/DISPLAY)          *\n*                                 - Saved control block data in       *\n*                                   the volume table.                 *\n*                                 - Added 24-bit Stack for DCBs,      *\n*                                   STLINENO, etc.                    *\n*                                 - Added &PGMNAME variable, using it *\n*                                   for CSECT name, literals, etc.    *\n*              2000/05/23 SDDA030 - V2.12                             *\n*                                 - Used IOSCDR to test if we can get *\n*                                   out to our DASD before issuing    *\n*                                   LSPACE. Note that this requires   *\n*                                   that we be APF-authorized or have *\n*                                   RACF access to IOSCDR - see       *\n*                                   'Special Notes', above.           *\n*                                 - Added checks to see if we can     *\n*                                   issue IOSCDR.                     *\n*                                 - Removed STIMERM-related stuff,    *\n*                                   since we can't DETACH once LSPACE *\n*                                   has been issued.                  *\n*                                 - Added message if we can't issue   *\n*                                   IOSCDR to check RESERVEs.         *\n*                                 - Added messages when ISPF DM is not*\n*                                   available and the user requested  *\n*                                   ISPF output.                      *\n*                                 - Added msgids to error messages.   *\n*                                 - Added )M info to TSO Help.        *\n*                                 - Removed WTOs from Stack overflows.*\n*                                 - Re-organized internal code:       *\n*                                   - broke out ISPF output handling  *\n*                                   - re-labeled and re-sequenced     *\n*                                     labels.                         *\n*                                 - Left stats line updates as late as*\n*                                   possible (V00010).                *\n*              2001/02/01 SDDA030 - V2.13                             *\n*                                 - Removed IOSCDR stuff added in     *\n*                                   V2.12; instead, ESTAE PURGE=HALT  *\n*                                   and ABEND in the STIMERM exit.    *\n*                                 - Made ourselves non-swappable while*\n*                                   daughter tasks are running.       *\n*                                 - Added IKJEFTSR to re-invoke our-  *\n*                                   selves APFed.                     *\n*                                 - Added message if not APFed.       *\n*                                 - Added IKJEFTSR failure msg.       *\n*                                 - Set RC=4 if no units found.       *\n*                                 - Added MULT to TBADD.              *\n*                                 - Added non-swappable time to stats.*\n*              2001/02/26 SDDA030 - V2.14                             *\n*                                 - Added EDIF/BRIF support.          *\n*                                 - Allowed &PGMNAME as 1st word      *\n*                                   in batch control cards.           *\n*                                 - Populated Stats lines only once.  *\n*                                 - Added &PNLNAME for panel name.    *\n*                                 - Used (GTSIZE-1) as line size for  *\n*                                   TSO line-by-line output.          *\n*                                 - Added VTOCIX, Frag Indx, SMS      *\n*                                   StorGrp and CHPID info.           *\n*                                 - Moved formatting and totalling    *\n*                                   routines back into mainline, to   *\n*                                   reduce non-swap time.             *\n*                                 - Forced ISPF(B) if panel for       *\n*                                   ISPF(S) not available.            *\n*                                 - Added execution environment stats *\n*                                   lines.                            *\n*                                 - Added conditional assembly stuff  *\n*                                   for APAR OW48527.                 *\n*                                 - Used SYS1.NUCLEUS(IECDINIT), CSECT*\n*                                   IECDDEVT to get device type.      *\n*                                 - Added check to ensure IKJEFTSR    *\n*                                   invokes the same code as was orig-*\n*                                   inally invoked.                   *\n*                                 - Added SMS volume status and ass-  *\n*                                   ociated sort field (SMSSTAT).     *\n*                                 - Added 'N/A' in SMS fields for     *\n*                                   non-SMSed volumes (so REXX words  *\n*                                   are consistent).                  *\n*                                 - Added keyword NOLSPACE, for when  *\n*                                   you only need UCBs and Volsers (ie*\n*                                   at IPL to vary devices OFFLINE    *\n*                                   based on volser).                 *\n*              2001/11/12 SDDA030 - V2.15                             *\n*                                 - Added lists of volsers, UCBs in   *\n*                                   selection parms.                  *\n*                                 - Added XVOL, XUCB for excluding    *\n*                                   lists of volsers, units.          *\n*                                 - Corrected STIMERM time bug (micro,*\n*                                   not milli, stupid!)               *\n*                                 - Used the ratio of SubTasks to LPs *\n*                                   as a factor in calculating STIMER *\n*                                   times for LSPACE.                 *\n*                                 - Checked Assembler version when    *\n*                                   generating our assembly time      *\n*                                   stamp.                            *\n*                                 - Retrieved all devices via EDTINFO *\n*                                   when selecting by esoteric.       *\n*              2002/02/12 SDDA030 - V2.16                             *\n*                                 - Used Dynamic displays (rather than*\n*                                   TBDISPL) for ISPF(S)              *\n*                                 - Added LEFT/RIGHT processing for   *\n*                                   ISPF(S)                           *\n*                                 - Removed implicit SORT in ISPF(S); *\n*                                   added SORT cmd to ISPF(S)         *\n*                                 - Added sort prompt pop-up panel in *\n*                                   ISPF(B) and ISPF(S).              *\n*                                 - Added 'Line x of y' in ISPF(S).   *\n*                                 - Added 'Top of Data' and 'Bottom   *\n*                                   of Data' to ISPF(S).              *\n*                                 - Distributed with &ISPF_by_Default *\n*                                   set to 1 (Yes).                   *\n*              2002/03/11 SDDA030 - V2.17                             *\n*                                 - Added STORGRP as a selection      *\n*                                   criterion (as suggested by Ian    *\n*                                   Hobbs).                           *\n*                                 - Added bytes of free space/volume. *\n*                                 - Moved Frag Index, and added check *\n*                                   for max of 999.                   *\n*                                 - Changed RDJFCBs to SWAREQs.       *\n*                                 - Added SSREQ to SMS for volumes in *\n*                                   a STORGRP.                        *\n*                                 - Removed sort-by-column facility,  *\n*                                   and added numeric sort fields, so,*\n*                                   for instance, 1.1G sorts higher   *\n*                                   than 1.1K.                        *\n*                                 - Generated LSPACE error messages   *\n*                                   internally, instead of asking     *\n*                                   LSPACE to do it.                  *\n*                                 - Scaled numbers by 1000 instead of *\n*                                   1024.                             *\n*                                 - BASR to, rather than ATTACH,      *\n*                                   H00010 if we only have 1 subtask. *\n*                                 - Added indicators for CHPIDs not   *\n*                                   phys or log available.            *\n*                                 - Calculated total Free % based on  *\n*                                   bytes rather than tracks          *\n*                                 - Changed internal STACK macro to   *\n*                                   SSCSTACK, so it doesn't conflict  *\n*                                   with IBM's STACK in ATSOMAC.      *\n*              2002/06/11 SDDA030 - V2.18                             *\n*                                 - Moved detail line formatting back *\n*                                   into subtask.                     *\n*                                 - Subtask statistics populated by   *\n*                                   subtask itself.                   *\n*                                 - Total line populated by last      *\n*                                   subtask to end.                   *\n*                                 - Added 'CS collisions' to subtask  *\n*                                   statistics.                       *\n*                                 - If running with OW48527, don't    *\n*                                   WAIT for subtasks to finish; start*\n*                                   outputting lines as soon as       *\n*                                   possible.                         *\n*              2002/08/08 SDDA030 - V2.19                             *\n*                                 - Dynamically determined the status *\n*                                   of APAR OW48527 by checking       *\n*                                   IGC0007H (LSPACE) for the literal *\n*                                   'I/O TIMEOUT'                     *\n*                                 - Removed &OW48527 conditional      *\n*                                   assembly stuff                    *\n*                                 - Converted Branches to Jumps,      *\n*                                   BASRs to BRAS, etc.               *\n*                                 - Removed 'CS collisions' from      *\n*                                   subtask stats, since they always  *\n*                                   seemed to be 0.                   *\n*                                 - Corrected bug when selecting by   *\n*                                   multiple STORGRPs.                *\n*                                 - If we fail APF checks, POST all   *\n*                                   lines in VolTbl as complete.      *\n*                                 - Corrected S0C4 when selecting by  *\n*                                   Unit and no DASD UCBs found (and  *\n*                                   thus no VolTbl created).          *\n*                                 - Corrected bug where the SMS       *\n*                                   Anomaly msg was not being put out *\n*                                   in ISPF modes.                    *\n*                                 - WAITed for up to 2.5 seconds for  *\n*                                   any subtasks to finish before     *\n*                                   terminating.                      *\n*              2003/01/16 SDDA030 - V2.20                             *\n*                                 - Corrected bug in eliminating stats*\n*                                   lines after finding out we aren't *\n*                                   APF'd (E80010).                   *\n*                                 - Corrected bug when finding TIOT   *\n*                                   entry for the OUTFILE DDName.     *\n*                                 - Used consistent registers to      *\n*                                   address VolTbl_Ent throughout.    *\n*              2003/10/07 SDDA030 - V2.21                             *\n*                                 - Fixed S0C4 when adjusting UCB pat-*\n*                                   terns after no UCBs found when    *\n*                                   selecting by UCB.                 *\n*                                 - Added line commands in ISPF(S)    *\n*                                   and ISPF(B) modes:                *\n*                                   . ISPF(x) to switch display modes *\n*                                 - Removed @_No_UCBs_Found flag;     *\n*                                   check nbr vols in table instead.  *\n*                                 - Added Vol Capacity field in the   *\n*                                   display, after VTOC stuff.        *\n*                                 - Allowed system symbols and sub-   *\n*                                   stringing in command line (ran the*\n*                                   command line through ASASYMBM).   *\n*                                 - Returned correct SMS status (ins- *\n*                                   tead of status of 1st vol in      *\n*                                   STORGRP).                         *\n*                                 - Used ATTACHX instead of ATTACH.   *\n*                                 - Added S00010 to WAIT for and      *\n*                                   DETACH subtask TCBs - avoids SA03 *\n*                                   abends.                           *\n*                                 - If we read from SYSIN, send output*\n*                                   to SYSPRINT, even if ISPF is      *\n*                                   available.                        *\n*                                 - Treated SYSPRINT (almost) like    *\n*                                   an OUTFILE - DCB characteristics  *\n*                                   now honoured.                     *\n*              2004/10/15 SDDA030 - V2.22                             *\n*                                 - Fixed bug when returning SMS      *\n*                                   status (Thanks Angel Luis Domin-  *\n*                                   guez).                            *\n*                                 - Added SYSSTATE ARCHLVL=1          *\n*              2005/01/20 SDDA030 - V2.23                             *\n*                                 - Used CSRSI to retrieve info in-   *\n*                                   stead of crawling through control *\n*                                   blocks.                           *\n*              2006/04/21 SDDA030 - V2.24                             *\n*                                 - Added check for z/OS.e in stats.  *\n*                                 - Use TRKCALC to get generally acc- *\n*                                   epted value for Tracksize, instead*\n*                                   of using DS4DEVTK.                *\n*                                 - Rounded displayed values.         *\n*                                 - Display actual value of field in  *\n*                                   SMSG area when in ISPF(S) and the *\n*                                   cursor is on a numeric field and  *\n*                                   ENTER is hit.                     *\n*                                 - IDENTIFY H00010 with a unique name*\n*                                   so we can run multiple copies     *\n*                                   simultaneously.                   *\n*                                 - Added LINESIZE keyword.           *\n*                                 - Standardized internal calling     *\n*                                   sequence so that A(@_Dynam),      *\n*                                   A(31-bit Stack Pointer) and       *\n*                                   A(24-bit Stack Pointer) are always*\n*                                   the 1st 3 parms.                  *\n*                                 - Added name and version to title.  *\n*                                 - Added max LSPACE Wait time        *\n*                                   defaults and MAXLWAIT keyword.    *\n*                                 - Dynamically calculated nbr        *\n*                                   subtasks = 2*engines + 1          *\n*                                 - Added default and max Subtask     *\n*                                   counts Assembly variables - thanks*\n*                                   to MJ Cleary for the suggestion.  *\n*                                 - Added display of installation     *\n*                                   defaults to stats lines.          *\n*                                 - Flagged emulated devices with     *\n*                                   '*E*' following device type.      *\n*                                 - Saved registers on the Linkage    *\n*                                   Stack when we don't know who the  *\n*                                   caller is (and thus the size of   *\n*                                   the save area in R13).            *\n*                                 - Used conditional STORAGE OBTAINs  *\n*                                   when expanding VolTbl.            *\n*                                 - Used separate 24-bit stack for    *\n*                                   OUTFILE stuff (DCBs, etc).        *\n*              2015/11/13 MAHLER  - V2.25                             *\n*                                   Calculation of Volsize corrected  *\n*                                   for EAV.                          *\n*              2017/03/30 EWP     - V2.26                             *\n*                                 - Fix missing SMS info when SYSNAME *\n*                                   not in IGDBCD. Use 1st entry like *\n*                                   SHOWZOS does.                     *\n*                                                                     *\n*              ____/__/__ _______                                     *\n*                                                                     *\n*                                                                     *\n*  To Do     : Handle CVAF Abends (S18B).                             *\n*                                                                     *\n*---------------------------------------------------------------------*\n         TITLE 'TSO HELP'\n*---------------------------------------------------------------------*\n*                                                                     *\n*)F Function -                                                        *\n*  The SPACE command displays DASD volume usage statistics, based on  *\n*  user-specified characteristics.                                    *\n*                                                                     *\n*)X Syntax -                                                          *\n*         SPACE UNIT/UCB('Unit-mask')                                 *\n*               VOLUME('Volume-mask')                                 *\n*               NAME('Esoteric-name')                                 *\n*               ATTRIBUTE(STORAGE|STG|PRIVATE|PVT|PUBLIC|SMS)         *\n*               STORGRP('SMS-Storage-Group-Name')                     *\n*               XUNIT/XUCB('Unit-mask')                               *\n*               XVOLUME('Volume-mask')                                *\n*               SORT(id)                                              *\n*               ASCENDING/DESCENDING                                  *\n*               MAXTASKS('#Subtasks')                                 *\n*               OUTFILE(ddname)                                       *\n*               OUTDATA(Display|CB|All)                               *\n*               NOHEADINGS/NOHDG                                      *\n*               NODETAILS                                             *\n*               NOTOTALS                                              *\n*               NOECHO                                                *\n*               STATISTICS|STATS                                      *\n*               ISPF(Space|Edif|Brif|None)                            *\n*               NOLSPACE                                              *\n*               LINESIZE                                              *\n*               MAXLWAIT(secs)                                        *\n*                                                                     *\n*  Required - None                                                    *\n*  Default  - UNIT(*) VOLUME(*)                                       *\n*  Alias    - None                                                    *\n*  Notes    -                                                         *\n*                                                                     *\n*)M Messages -                                                        *\n*                                                                     *\n*))SPACE01I No Devices/Volumes match selection criteria               *\n*           This message is issued when no online DASD devices were   *\n*           found that satisfied the selection criteria defined.      *\n*                                                                     *\n*))SPACE02I Insufficient APF authorization                            *\n*           The SPACE command requires APF authorization, but is cur- *\n*           rently not authorized.                                    *\n*                                                                     *\n*))SPACE03I ISPF DM Services unavailable xx-yy                        *\n*           This message is issued when the SPACE command could not   *\n*           use ISPF Dialogue Management Services to display the      *\n*           results of the command in ISPF format. Either the required*\n*           ISPF modules were unavailable, or the environment is such *\n*           that ISPF Dialogue Management Services are not functional.*\n*           In the message, xx indicates which ISPF service is        *\n*           unavailable, and yy is the return code from that service. *\n*                                                                     *\n*))SPACE04I Forcing non-ISPF output                                   *\n*           This message is issued when the user has requested that   *\n*           the command output be displayed using ISPF Dialogue       *\n*           Management Services, but these services are unavailable.  *\n*           The command output is displayed using TSO line-by-line    *\n*           facilities (PUTLINE).                                     *\n*                                                                     *\n*))SPACE05I CSVQUERY unavailable on this system xxxxx                 *\n*           The CSVQUERY function was attempted to verify that APAR   *\n*           OW48527 had been APPLYed to this system, but CSVQUERY is  *\n*           not available. 'xxxxx' is the Operating System level on   *\n*           which this program is executing.                          *\n*                                                                     *\n*))SPACE06I Program not found in STEPLIB/LNKLST                       *\n*           This command requires that the processing program reside  *\n*           in the current STEPLIB or system LNKLST concatenation,    *\n*           but the program cannot be located.                        *\n*                                                                     *\n*))SPACE07I IKJEFTSR error xx-yy                                      *\n*           The TSO/E Service Routine IKJEFTSR could not complete     *\n*           successfully. xx is the Return Code, and yy the reason    *\n*           code.                                                     *\n*                                                                     *\n*))SPACE08I LSPACE failed for at least 1 volume                       *\n*           The data presented in the table is incomplete because     *\n*           information for at least 1 DASD volume was unavailable.   *\n*                                                                     *\n*))SPACE09I Incompatible versions of SPACE found                      *\n*           The TSO/E Service Routine IKJEFTSR invoked a different    *\n*           version of SPACE (from LNKLST/STEPLIB) than was           *\n*           originally invoked (from ISPLLIB?).                       *\n*                                                                     *\n*))SPACE10I Insufficient storage: nnn volumes omitted                 *\n*           Not enough (above-the-line) storage was available to      *\n*           save the information for all selected DASD volumes. nnn   *\n*           indicates how many volumes were not processed.            *\n*                                                                     *\n*))SPACE11I Internal error - unknown invocation type                  *\n*           The program could not determine how it was invoked. This  *\n*           is most likely to occur when it is being reinvoked via    *\n*           IKJEFTSR, but the parameters passed are unrecognized.     *\n*                                                                     *\n*))SPACE12I OUTFILE DDname xxxxxxxx not useable - ignored.            *\n*           This message is issued when the user has requested that   *\n*           the volume usage data be written to a file, by specifying *\n*           OUTFILE(xxxxxxxx) on the command line. DDName xxxxxxxx    *\n*           could not be OPENed for output.                           *\n*                                                                     *\n*)O Operands -                                                        *\n*))UNIT('Unit-mask') or                                               *\n*   UCB('Unit-mask')    specifies the selection criterion based on    *\n*                       UCB address. Wildcard characters can be used: *\n*                        '*' - all remaining characters               *\n*                        '?' - any single character                   *\n*                        '%' - any single character                   *\n*                       Default is '*'.                               *\n*                       If 'Unit-mask' is less than 4 characters, it  *\n*                       is right-filled with asterisks.               *\n*                       If no UCBs match the 'Unit-mask', and an ast- *\n*                       erisk is the last character in 'Unit-mask',   *\n*                       the trailing asterisk is dropped, a '0'       *\n*                       inserted in the 1st position of 'Unit-mask',  *\n*                       and the UCB scan repeated. This process is    *\n*                       repeated until UCBs are found, or there are no*\n*                       more trailing asterisks in 'Unit-mask'.       *\n*                       Note that a DASD volume must satisfy *all*    *\n*                       criteria specified (UNIT, XUNIT, VOL, XVOL,   *\n*                       NAME, ATTRIBUTE, and/or STORGRP) to be sel-   *\n*                       ected.                                        *\n*                                                                     *\n*))XUNIT('Unit-mask') or                                              *\n*   XUCB('Unit-mask')   specifies the exclusion criterion based on    *\n*                       UCB address.                                  *\n*                                                                     *\n*))VOLUME('Volume-mask')                                              *\n*                       specifies the selection criterion based on    *\n*                       volume serial number. Wildcard characters can *\n*                       be used:                                      *\n*                        '*' - all remaining characters               *\n*                        '?' - any single character                   *\n*                        '%' - any single character                   *\n*                       Default is '*'.                               *\n*                       If 'Volume-mask' is less than 6 characters,   *\n*                       it is right-filled with asterisks             *\n*                       Note that a DASD volume must satisfy *all*    *\n*                       criteria specified (UNIT, XUNIT, VOL, XVOL,   *\n*                       NAME, ATTRIBUTE, and/or STORGRP) to be sel-   *\n*                       ected.                                        *\n*                                                                     *\n*))XVOLUME('Volume-mask')                                             *\n*                       specifies the exclusion criterion based on    *\n*                       volume serial number.                         *\n*                                                                     *\n*))NAME('Esoteric-Name')                                              *\n*                       specifies the selection criterion based on    *\n*                       generic or esoteric name.                     *\n*                       Default is that selection is not based on     *\n*                       generic/esoteric name.                        *\n*                       Note that a DASD volume must satisfy *all*    *\n*                       criteria specified (UNIT, XUNIT, VOL, XVOL,   *\n*                       NAME, ATTRIBUTE, and/or STORGRP) to be sel-   *\n*                       ected.                                        *\n*                                                                     *\n*))ATTRIBUTE(STORAGE|STG|PRIVATE|PVT|PUBLIC|SMS)                      *\n*                       specifies the selection criterion based on    *\n*                       mount attribute. Only one of the options      *\n*                       above can be specified.                       *\n*                       Default is that selection is not based on     *\n*                       mount attribute.                              *\n*                       Note that a DASD volume must satisfy *all*    *\n*                       criteria specified (UNIT, XUNIT, VOL, XVOL,   *\n*                       NAME, ATTRIBUTE, and/or STORGRP) to be sel-   *\n*                       ected.                                        *\n*                                                                     *\n*))STORGRP('SMS-Storage_Group_Name') or                               *\n*       SG('SMS-Storage_Group_Name')                                  *\n*                       specifies the selection criterion based on    *\n*                       SMS Storage Group. Wildcard characters can be *\n*                       used:                                         *\n*                        '*' - all remaining characters               *\n*                        '?' - any single character                   *\n*                        '%' - any single character                   *\n*                       Default is that selection is not based on     *\n*                       SMS Storage Group Names.                      *\n*                       Note that a DASD volume must satisfy *all*    *\n*                       criteria specified (UNIT, XUNIT, VOL, XVOL,   *\n*                       NAME, ATTRIBUTE, and/or STORGRP) to be sel-   *\n*                       ected.                                        *\n*                                                                     *\n*))SORT(id)             specifies the order in which the selected     *\n*                       DASD volumes are displayed:                   *\n*                        id: VOL     - Volser                         *\n*                            UCB     - UCB Name (Device Address)      *\n*                            DEVT    - Device Type                    *\n*                            ATTR    - Mount Attribute                *\n*                            FREET   - Free Tracks on Volume          *\n*                            FREEC   - Free Cylinders on volume       *\n*                            FREEP   - % Volume free                  *\n*                            FREEB   - # Bytes on Volume free         *\n*                            FREEE   - # Free Extents on volume       *\n*                            LARGET  - Largest Free Tracks            *\n*                            LARGEC  - Largest Free Cylinders         *\n*                            VFREED  - VTOC Free DSCBs                *\n*                            VFREEP  - % VTOC Free                    *\n*                            VTRK    - Tracks allocated to VTOC       *\n*                            VIX     - VTOC Index Status              *\n*                            VOLSIZE - Volume Capacity (Bytes)        *\n*                            FRAG    - Fragmentation Index            *\n*                            STORGRP - SMS Storage Group              *\n*                            SMSSTAT - SMS Volume Status              *\n*                            CHPIDS  - CHPIDs                         *\n*                       By default, the display is unsorted, and will *\n*                       normally appear in ascending order of UCB.    *\n*                                                                     *\n*))ASCENDING|DESCENDING specifies the sort order. Significant only    *\n*                       when a SORT id is specified.                  *\n*                       Default is ASCENDING.                         *\n*                                                                     *\n*))MAXTASKS('#Subtasks') specifies the maximum number of sub-tasks to *\n*                       be ATTACHed to retrieve volume information.   *\n*                       If specified, '#Subtasks' must be numeric.    *\n*                       A maximum of 16 subtasks can be ATTACHed.     *\n*                       Default is (number-of-active-CPUs + 1).       *\n*                                                                     *\n*))OUTFILE('ddname')    specifies that the output is to be written to *\n*                       the dataset allocated to 'ddname'. This output*\n*                       is generated in addition to the normal output.*\n*                       Default is no additional output is generated. *\n*                                                                     *\n*))OUTDATA(Display|CB|All) specifies the content of the data written  *\n*                       to the 'ddname' specified in OUTFILE, above.  *\n*                        DISPLAY writes an image of the max display   *\n*                                output (235 bytes)                   *\n*                        CB      writes machine-readable copies of the*\n*                                following control blocks, as returned*\n*                                by the appropriate MVS services:     *\n*                                  UCB Copy        (48 bytes)         *\n*                                  DCE Copy        (48 bytes)         *\n*                                  LSPACE Data     (36 bytes)         *\n*                                  F4 DSCB         (96 bytes)         *\n*                        ALL     writes both CB and DISPLAY, in that  *\n*                                order (228 bytes of CB and 235 bytes *\n*                                of DISPLAY)                          *\n*                       Default is ALL.                               *\n*                                                                     *\n*))NOHEADINGS|NOHDG     specifies that headings (and page breaks) are *\n*                       to be suppressed.                             *\n*                                                                     *\n*))NODETAILS            specifies that detail lines (one per selected *\n*                       DASD volume) are to be suppressed.            *\n*                                                                     *\n*))NOTOTALS             specifies that total lines are to be          *\n*                       suppressed.                                   *\n*                                                                     *\n*))NOECHO               specifies that the command line is not to be  *\n*                       listed in Batch.                              *\n*                                                                     *\n*))STATISTICS|STATS     specifies that internal version and exec-     *\n*                       ution statistics are to be produced.          *\n*                                                                     *\n*))ISPF(Space|Edif|Brif|None)                                         *\n*                       specifies the ISPF services to be used to     *\n*                       present output:                               *\n*                       Space causes the output to be displayed using *\n*                             a customized panel. This is the default *\n*                             if ISPF is specified.                   *\n*                       Edif  invokes ISPF Edit to present the        *\n*                             output                                  *\n*                       Brif  invokes ISPF Browse to present the      *\n*                             output                                  *\n*                       None  uses TSO line-by-line output (PUTLINE)  *\n*                             to present the output.                  *\n*))NOLSPACE             specifies that no VTOC information is to be   *\n*                       gathered - displays only UCB, Volser, DevType,*\n*                       Attr, SMS Info, CHPIDs, Remote Copy Data.     *\n*))LINESIZE(nnn)        specifies the maximum length of the line to be*\n*                       displayed (in TSO line-by-line). Default is   *\n*                       the value returned by the GTSIZE service minus*\n*                       1. As well as a number, the literal 'MAX' can *\n*                       be specified, indicating that all available   *\n*                       data will be displayed.                       *\n*))MAXLWAIT(nnn)        specifies the maximum number of seconds that  *\n*                       each LSPACE will be allowed to complete; after*\n*                       this number of seconds, the LSPACE will be    *\n*                       terminated with an I/O TIMEOUT message. 0     *\n*                       signifies no maximum.                         *\n*                                                                     *\n*---------------------------------------------------------------------*\n         TITLE 'Assembly Variables'\n         LCLC  &ASMDT,&ASMTM         Assembly Date/Time\n&ASMDT   SETC  '&SYSDATC'(1,4).'-'.'&SYSDATC'(5,2).'-'.'&SYSDATC'(7,2)\n&ASMTM   SETC  '&SYSTIME'\n\n         TITLE 'Register Equates'\n         YREGS\n         TITLE '''IEABRC'''\n         COPY  IEABRC\n         TITLE '''SSCSTACK'' Macro'\n         MACRO\n&NAME    SSCSTACK &TYPE,              INIT, PUSH, POP, or TERM         +\n               &LOC=,                 ABOVE/BELOW (TYPE=INIT)          +\n               &LEN=,                 Length required (TYPE=INIT/PUSH) +\n               &STACK=,               Stack origin                     +\n               &ADDR=,                Storage address                  +\n               &OVERFLOW=,            Overflow action (TYPE=PUSH)      +\n               &WTOMSG=               Overflow WTO (If OVERFLOW=WTO)\n         PUSH  PRINT\n         PRINT NOGEN\n.*\n.*-------------------------------------------------------------------*.\n.*                                                                   *.\n.*           S S C S T A C K   M a c r o                             *.\n.*                                                                   *.\n.*  Function: The SSCSTACK macro manages a LIFO stack that can be    *.\n.*            used to relieve the overhead of GETMAIN/FREEMAIN where *.\n.*            appropriate.                                           *.\n.*                                                                   *.\n.*            There are 4 flavours of the SSCSTACK invocation:       *.\n.*              SSCSTACK INIT,...     GETMAIN Stack storage          *.\n.*              SSCSTACK PUSH,...     Reserve storage on the Stack   *.\n.*              SSCSTACK POP,...      Release storage on the Stack   *.\n.*              SSCSTACK TERM,...     FREEMAIN Stack storage         *.\n.*                                                                   *.\n.*            Stack storage *must* be PUSHed and POPped in LIFO      *.\n.*            sequence - no checking is done within the macro to     *.\n.*            ensure this is the case.                               *.\n.*                                                                   *.\n.*  Operation: The usage of the SSCSTACK macro is typically:         *.\n.*              SSCSTACK INIT,...                                    *.\n.*                                                                   *.\n.*              SSCSTACK PUSH,...                                    *.\n.*              SSCSTACK POP,...                                     *.\n.*              SSCSTACK PUSH,...                                    *.\n.*              SSCSTACK POP,...                                     *.\n.*                .    .                                             *.\n.*                .    .                                             *.\n.*                                                                   *.\n.*              SSCSTACK TERM,...                                    *.\n.*                                                                   *.\n.*             When the Stack is initially GETMAINed (SSCSTACK INIT),*.\n.*             the length and Next Available Byte (NAB) are init-    *.\n.*             ialized in the Stack Header. On subsequent SSCSTACK   *.\n.*             PUSH requests, the NAB is incremented by the length   *.\n.*             requested. SSCSTACK POP requests merely update the NAB*.\n.*             with the address passed. SSCSTACK TERM FREEMAINs the  *.\n.*             Stack.                                                *.\n.*             If a SSCSTACK PUSH request would cause a stack over-  *.\n.*             flow, the default processing GETMAINs an area and     *.\n.*             returns the address of this area. The SSCSTACK POP    *.\n.*             request for this area FREEMAINs the storage.          *.\n.*             Default overflow processing can be overridden or      *.\n.*             supplemented on the SSCSTACK PUSH: instead of GETMAIN-*.\n.*             ing additional storage, the SSCSTACK PUSH request can *.\n.*             return a return code, or Abend. Additionally, a WTO   *.\n.*             can be issued with any of the overflow options.       *.\n.*                                                                   *.\n.*             SSCSTACK INIT,                                        *.\n.*                   LEN=Length                                      *.\n.*                   <,LOC=ANY|BELOW>                                *.\n.*                   <,STACK=Stack-pointer>                          *.\n.*                                                                   *.\n.*             SSCSTACK PUSH,                                        *.\n.*                   LEN=Length,                                     *.\n.*                   STACK=Stack-pointer                             *.\n.*                   <,ADDR=Address-pointer>                         *.\n.*                   <,OVERFLOW=Action|WTO|(Action,WTO)>             *.\n.*                   <,WTOMSG=WTO-message>                           *.\n.*                                                                   *.\n.*             SSCSTACK POP,                                         *.\n.*                   ADDR=Address=pointer,                           *.\n.*                   STACK=Stack-pointer                             *.\n.*                                                                   *.\n.*             SSCSTACK TERM,                                        *.\n.*                   STACK=Stack-pointer                             *.\n.*                                                                   *.\n.*-------------------------------------------------------------------*.\n.*\n         LCLC  &LENREG,&STKREG,&ADDREG,&LOCTN\n         AIF   ('&TYPE(1)' EQ 'PUSH').PUSH010\n         AIF   ('&TYPE(1)' EQ 'POP').POP010\n         AIF   ('&TYPE(1)' EQ 'INIT').INIT010\n         AIF   ('&TYPE(1)' EQ 'TERM').TERM010\n         MNOTE 8,'TYPE must be INIT, PUSH, POP, or TERM'\n         AGO   .MEND\n.*\n.INIT010 ANOP\n         AIF   ('&LEN' EQ '').INITE01\n         AIF   ('&LEN'(1,1) NE '(').INIT020\n&LENREG  SETC  '&LEN(1)'\n         AIF   ('&LENREG' NE  '1').INIT030\n         MNOTE 8,'LEN= register must be 0 or 2-15'\n         AGO   .MEND\n         AGO   .INIT030\n.INIT020 ANOP\n&LENREG  SETC  'R0'\n         LHI   &LENREG,&LEN Length of Stack\n.INIT030 ANOP\n&LOCTN   SETC  '&LOC'\n         AIF   ('&LOC' NE '').INIT040\n&LOCTN   SETC  '31'\n.INIT040 ANOP\n         LHI   R1,StackHdr_Length       Length of header\n         AR    &LENREG,R1               Bump length\n         BASR  R2,0\n         USING (*,INI&SYSNDX.A-1),R2\n         STORAGE OBTAIN,                Go get our storage             +\n               LENGTH=(&LENREG),         this long                     +\n               LOC=&LOCTN                wherever we were told\nINI&SYSNDX.A DS 0H\n         DROP  R2\n         XC    0(StackHdr_Length,R1),0(R1)  Clear header\n         ST    R0,StackHdr_StackLen-StackHdr(0,R1) Save length\n         LA    R0,StackHdr_Length(0,R1) A(Current top of stack)\n         ST    R0,StackHdr_NAB-StackHdr(0,R1) Save A(Next Avail Byte)\n         ST    R0,StackHdr_HWM-StackHdr(0,R1) Save High-Water Mark\n         AIF   ('&STACK' EQ '').INIT060\n         AIF   ('&STACK'(1,1) EQ '(').INIT050\n         ST    R1,&STACK                Save Stack origin\n         AGO   .INIT060\n.INIT050 ANOP\n         LR    &STACK(1),R1             Load return register\n         AGO   .INIT060\n.INIT060 ANOP\n         AIF   (D'Stack).MEND\nStack               DSECT\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*   This is a LIFO stack that can be used (where appropriate) to    *\n*  avoid the overhead of repeated GETMAINs/FREEMAINs. Storage       *\n*  within the Stack *must* be used in LIFO sequence.                *\n*                                                                   *\n*-------------------------------------------------------------------*\n\nStackHdr            EQU   *           Start of Header\nStackHdr_StackLen   DS    FL4          Length of Stack\nStackHdr_NAB        DS    AL4          A(Next Available Byte in Stack)\nStackHdr_Reg_Save   DS    4FL4         Register save area\nStackHdr_HWM        DS    AL4          Max NAB value (High-water mark)\nStackHdr_Overflows  DS    FL4          Nbr SSCSTACK PUSH overflows\nStackHdr_Overflow_HWM DS  FL4          Max Overflow amount\nStackHdr_GETMAIN    DS    FL4          Nbr SSCSTACK PUSH ---> GETMAIN\n                    DS    0D           Dblwd alignment\nStackHdr_Length     EQU   *-StackHdr  Length of Header\n\n&SYSECT  &SYSSTYP\n         AGO   .MEND\n.INITE01 ANOP\n         MNOTE 8,'LEN must be specified for SSCSTACK INIT'\n         AGO   .MEND\n.*\n.PUSH010 ANOP\n         LCLA  &INDEX,&COUNT\n         LCLB  &GETMAIN,&WTO,&ABEND,&RC\n         LCLB  &EXCLOP\n         LCLC  &TESTOVFL\n         AIF   ('&OVERFLOW' EQ '').PUSH090\n&INDEX   SETA  0\n&COUNT   SETA  N'&OVERFLOW\n         AIF   (&COUNT GT 0).PUSH020\n&TESTOVFL SETC '&OVERFLOW'\n         AGO   .PUSH030\n.PUSH020 ANOP\n&INDEX   SETA  &INDEX+1\n         AIF   (&INDEX GT &COUNT).PUSH080\n&TESTOVFL SETC '&OVERFLOW(&INDEX)'\n.PUSH030 ANOP\n         AIF   ('&TESTOVFL' NE 'GETMAIN').PUSH040\n         AIF   (&EXCLOP).PUSHE03\n&GETMAIN SETB  1\n&EXCLOP  SETB  1\n         AGO   .PUSH020\n.PUSH040 ANOP\n         AIF   ('&TESTOVFL' NE 'ABEND').PUSH050\n         AIF   (&EXCLOP).PUSHE03\n&ABEND   SETB  1\n&EXCLOP  SETB  1\n         AGO   .PUSH020\n.PUSH050 ANOP\n         AIF   ('&TESTOVFL' NE 'RC').PUSH060\n         AIF   (&EXCLOP).PUSHE03\n&RC      SETB  1\n&EXCLOP  SETB  1\n         AGO   .PUSH020\n.PUSH060 ANOP\n         AIF   ('&TESTOVFL' NE 'WTO').PUSH070\n&WTO     SETB  1\n         AGO   .PUSH020\n.PUSH070 ANOP\n         MNOTE 4,'Unrecognized OVERFLOW operand - &TESTOVFL - GETMAIN s+\n               bstituted.'\n&GETMAIN SETB  1\n         AGO   .PUSH020\n.PUSH080 ANOP\n         AIF   (&EXCLOP).PUSH100\n.PUSH090 ANOP\n&GETMAIN SETB  1\n         AGO   .PUSH100\n.PUSH100 ANOP\n         AIF   ('&STACK' EQ '').PUSHE02\n         AIF   ('&STACK'(1,1) NE '(').PUSH110\n&STKREG  SETC  '&STACK(1)'\n         AGO   .PUSH120\n.PUSH110 ANOP\n&STKREG  SETC  'R15'\n         L     &STKREG,&STACK           A(Stack Origin)\n.PUSH120 ANOP\n         AIF   ('&LEN' EQ '').PUSHE01\n         AIF   ('&LEN'(1,1) NE '(').PUSH130\n&LENREG  SETC  '&LEN(1)'\n         AIF   ('&LENREG' EQ '0').PUSH150\n         AIF   ('&LENREG' EQ 'R0').PUSH150\n         AGO   .PUSH140\n.PUSH130 ANOP\n&LENREG  SETC  'R0'\n.PUSH140 ANOP\n         LHI   &LENREG,&LEN\n.PUSH150 ANOP\n         AHI   &LENREG,7                Ensure a\n         SRL   &LENREG,3                 doubleword\n         SLL   &LENREG,3                 multiple\n         L     R1,StackHdr_NAB-StackHdr(0,&STKREG) A(Next Avail Byte)\n         AR    R1,&LENREG               Bump by length requested\n         SLR   R1,&STKREG               Get Stack used\n         C     R1,StackHdr_StackLen-StacKHdr(0,&STKREG) Too much?\n         JNL   PSH&SYSNDX.E             Yes, Overflow\n         ALR   R1,&STKREG               No, offset to address\n         ST    R1,StackHdr_NAB-StackHdr(0,&STKREG) A(Next Avail Byte)\n         C     R1,StackHdr_HWM-StackHdr(0,&STKREG) Highest?\n         JNH   PSH&SYSNDX.C             No, skip\n         ST    R1,StackHdr_HWM-StackHdr(0,&STKREG) Yes, update HWM\nPSH&SYSNDX.C DS 0H\n         SLR   R1,&LENREG               A(Start of storage area)\n         AIF   ('&LENREG' EQ '0').PUSH155\n         AIF   ('&LENREG' EQ 'R0').PUSH155\n         LR    R0,&LENREG               Length of storage\n.PUSH155 ANOP\n         J     PSH&SYSNDX.M             and skip\nPSH&SYSNDX.E DS 0H\n         ST    R0,StackHdr_Reg_Save-StackHdr(&STKREG)\n         L     R0,StackHdr_Overflows-StackHdr(0,&STKREG) Get count\n         AHI   R0,1                       Bump it\n         ST    R0,StackHdr_Overflows-StackHdr(0,&STKREG) Save it\n         L     R0,StackHdr_Reg_Save-StackHdr(&STKREG)\n         AIF   (NOT &WTO).PUSH220\n         LCLC  &WTOLIT\n         AIF   (K'&WTOMSG LT 3).PUSH160\n&WTOLIT  SETC  '&WTOMSG'(2,K'&WTOMSG-2)\n         AGO   .PUSH170\n.PUSH160 ANOP\n&WTOLIT  SETC  'Stack001 - Stack Overflow'\n.PUSH170 ANOP\n         ST    R1,StackHdr_Reg_Save-StackHdr(&STKREG)  Save R1\n         ST    &LENREG,StackHdr_Reg_Save+4-StackHdr(&STKREG)  Save Len\n         AIF   ('&STKREG' EQ '1').PUSH180,                             +\n               ('&STKREG' EQ 'R1').PUSH180,                            +\n               ('&STKREG' EQ '14').PUSH180,                            +\n               ('&STKREG' EQ 'R14').PUSH180,                           +\n               ('&STKREG' EQ '15').PUSH180,                            +\n               ('&STKREG' EQ 'R15').PUSH180\n         AGO   .PUSH190\n.PUSH180 ANOP\n         ST    R2,StackHdr_Reg_Save+8-StackHdr(&STKREG)  Save R2\n         LR    R2,&STKREG                 Save A(Stack)\n.PUSH190 ANOP\n         WTO   '&WTOLIT',ROUTCDE=11\n         AIF   ('&STKREG' EQ '1').PUSH200,                             +\n               ('&STKREG' EQ 'R1').PUSH200,                            +\n               ('&STKREG' EQ '14').PUSH200,                            +\n               ('&STKREG' EQ 'R14').PUSH200,                           +\n               ('&STKREG' EQ '15').PUSH200,                            +\n               ('&STKREG' EQ 'R15').PUSH200\n         AGO   .PUSH210\n.PUSH200 ANOP\n         LR    &STKREG,R2                 Restore A(Stack)\n         L     R2,StackHdr_Reg_Save+8-StackHdr(&STKREG)  Restore R2\n.PUSH210 ANOP\n         L     R1,StackHdr_Reg_Save-StackHdr(&STKREG)  Restore\n         L     &LENREG,StackHdr_Reg_Save+4-StackHdr(&STKREG)  Rest Len\n.PUSH220 ANOP\n         AIF   (NOT &RC).PUSH230\n         LA    R0,0                     Clear Length register\n         LA    R1,0                     Clear pointer\n         LA    R15,8                    Set return code\n         J     PSH&SYSNDX.O             and skip\n         AGO   .PUSH250\n.PUSH230 ANOP\n         AIF   (NOT &ABEND).PUSH240\n         DC    H'0'                     ABEND\n         AGO   .PUSH250\n.PUSH240 ANOP\n         C     R1,StackHdr_Overflow_HWM-StackHdr(0,&STKREG) Highest?\n         JNH   PSH&SYSNDX.G             No, skip\n         ST    R1,StackHdr_Overflow_HWM-StackHdr(0,&STKREG) Yes, update\nPSH&SYSNDX.G DS 0H\n         L     R1,StackHdr_GETMAIN-StackHdr(0,&STKREG) Get count\n         AHI   R1,1                     Bump it\n         ST    R1,StackHdr_GETMAIN-StackHdr(0,&STKREG) Save it\n         AHI   &LENREG,8                Bump length by 8\n         LR    R15,&STKREG              Get stack address\n         SLL   R15,1                    Clear high-order bit\n         SRL   R15,25                   Clear 24-bit address\n         LTR   R15,R15                  Above-the-line?\n         JZ    PSH&SYSNDX.I             No, skip\n         BASR  R2,0\n         USING (*,PSH&SYSNDX.H-1),R2\n         STORAGE OBTAIN,                Go get our storage             +\n               LENGTH=(&LENREG),         this long                     +\n               LOC=31                    above-the-line\nPSH&SYSNDX.H DS 0H\n         DROP  R2\n         J     PSH&SYSNDX.K             and skip\nPSH&SYSNDX.I DS 0H\n         BASR  R2,0\n         USING (*,PSH&SYSNDX.J-1),R2\n         STORAGE OBTAIN,                Go get our storage             +\n               LENGTH=(&LENREG),         this long                     +\n               LOC=24                    below-the-line\nPSH&SYSNDX.J DS 0H\n         DROP  R2\nPSH&SYSNDX.K DS 0H\n         ST    R0,0(0,R1)               Save length\n         AHI   R1,8                     Bump over our header\n         AHI   R0,-8                    Adjust length\n.PUSH250 ANOP\nPSH&SYSNDX.M DS 0H\n         LA    R15,0                    Clear return register\n         AIF   (NOT &RC).PUSH260\nPSH&SYSNDX.O DS 0H\n.PUSH260  ANOP\n         AIF   ('&ADDR' EQ '').MEND\n         AIF   ('&ADDR'(1,1) NE '(').PUSH270\n         LR    &ADDR(1),R1             Load return register\n         AGO   .MEND\n.PUSH270 ANOP\n         ST    R1,&ADDR                 Save Storage pointer\n         AGO   .MEND\n.PUSHE01 ANOP\n         MNOTE 8,'LEN must be specified for SSCSTACK PUSH'\n         AGO   .MEND\n.PUSHE02 ANOP\n         MNOTE 8,'STACK must be specified for SSCSTACK PUSH'\n         AGO   .MEND\n.PUSHE03 ANOP\n         MNOTE 8,'Mutually exclusive OVERFLOW= operands.'\n         AGO   .MEND\n.*\n.POP010  ANOP\n         AIF   ('&ADDR' EQ '').POPE01\n         AIF   ('&ADDR'(1,1) NE '(').POP020\n&ADDREG  SETC  '&ADDR(1)'\n         AGO   .POP030\n.POP020  ANOP\n&ADDREG  SETC  'R0'\n         L     &ADDREG,&ADDR\n.POP030  ANOP\n         AIF   ('&STACK' EQ '').POPE02\n         AIF   ('&STACK'(1,1) NE '(').POP040\n&STKREG  SETC  '&STACK(1)'\n         AGO   .POP050\n.POP040  ANOP\n&STKREG  SETC  'R15'\n         L     &STKREG,&STACK           A(Stack Origin)\n.POP050  ANOP\n         CR    &ADDREG,&STKREG          Part of our stack?\n         JL    POP&SYSNDX.C             No, skip\n         C     &ADDREG,StackHdr_NAB-StackHdr(0,&STKREG)  Really?\n         JNL   POP&SYSNDX.C             No, skip\n         ST    &ADDREG,StackHdr_NAB-StackHdr(0,&STKREG)\n         J     POP&SYSNDX.E             and exit\nPOP&SYSNDX.C DS 0H\n         AHI   &ADDREG,-8               Back up to our header\n         L     R0,0(0,&ADDREG)          Get length of GETMAINed stg\n         BASR  R2,0\n         USING (*,POP&SYSNDX.D-1),R2\n         STORAGE RELEASE,               Free our storage               +\n               ADDR=(&ADDREG),           starting here                 +\n               LENGTH=(0)                for this long\nPOP&SYSNDX.D DS 0H\n         DROP  R2\nPOP&SYSNDX.E DS 0H\n         AGO   .MEND\n.POPE01  ANOP\n         MNOTE 8,'ADDR must be specified for SSCSTACK POP'\n         AGO   .MEND\n.POPE02  ANOP\n         MNOTE 8,'STACK must be specified for SSCSTACK POP'\n         AGO   .MEND\n.*\n.TERM010 ANOP\n         AIF   ('&STACK' EQ '').TERME02\n         AIF   ('&STACK'(1,1) NE '(').TERM020\n         AIF   ('&STACK(1)' EQ '1').TERM030,                           +\n               ('&STACK(1)' EQ 'R1').TERM030\n         LR    R1,&STACK(1)             Stack origin\n         AGO   .TERM030\n.TERM020 ANOP\n         L     R1,&STACK                A(Stack Origin)\n.TERM030 ANOP\n         L     R0,StackHdr_StackLen-StackHdr(0,R1) Length\n         BASR  R2,0\n         USING (*,TRM&SYSNDX.A-1),R2\n         STORAGE RELEASE,               Free our storage               +\n               ADDR=(1),                 starting here                 +\n               LENGTH=(0)                for this long\nTRM&SYSNDX.A DS 0H\n         DROP  R2\n         AGO   .MEND\n.TERME02 ANOP\n         MNOTE 8,'STACK must be specified for SSCSTACK TERM'\n         AGO   .MEND\n.*\n.MEND    ANOP\n         POP   PRINT\n         MEND\n         TITLE 'IBM Data Areas'\n         PUSH  PRINT\n         PRINT NOGEN\n         IKJCPPL\nCPPL_Length EQU *-CPPL\n\n         IKJCSPL\nCSPL_Length EQU *-CSPL\n\n         IKJCSOA\nCSOA_Length EQU *-CSOA\n\n         IKJPPL\nPPL_Length EQU *-PPL\n\n         IKJIOPL\nIOPL_Length EQU *-IOPL\n\n         IKJUPT\n         IKJTSVT\n         IKJEFLWA\n         IKJPSCB\n         IEFJFCBN\n         DCBD  DSORG=PS\n         IHADCBE\n         IHAPSA\n         CVT   DSECT=YES\n         IHAASVT\n         IHAASCB\n         IHAASXB\n         IHAECVT\n         IHAPCCA\n         IOSDSHID\n         IKJTCB\n         IHARB\n         IHACDE\n         IEZJSCB\n         IEFJSSIB\n         IHASDWA\n         IEFUCBOB PREFIX=YES\n         IOSDPATH\n         IECDDCE\n         IECSDSL1 (4)\n         IEFJESCT\n         IEFJSSOB\n         IEFSSSA\n         IGDVLD\n         IEFTIOT1\n         IEFZB505 LOCEPAX=YES\n         ASASYMBP\n         CSRSIIDF\n\nLSPACE_Parm LSPACE MF=D\nLSPACE_Parm_Length EQU *-LSPACE_Parm\n\nLSPACE_Data LSPACE MF=(D,DATA)\nLSPACE_Data_Length EQU *-LSPACE_Data\n\n         POP   PRINT\n         TITLE 'Local DSECTs'\n*-------------------------------------------------------------------*\n*   This DSECT describes the table in which we maintain DASD        *\n*  volume information. The table is OBTAINed in 31-bit storage      *\n*  the first time it is required, and expands as required to        *\n*  contain the entries required. Note that the table never shrinks. *\n*                                                                   *\n*   Each entry contains the volume information as it will be sent   *\n*  to the user (as well as some internal info). in addition to      *\n*  1 entry per volume, the Headings, Totals and Statistics lines,   *\n*  if requested, occupy table entries.                              *\n*-------------------------------------------------------------------*\n\nVolTbl                    DSECT\n\nVolTbl_Hdr                EQU   *     Info Table Header\nVolTbl_Hdr_TbLen          DS    FL4    Length of table\nVolTbl_Hdr_Count          DS    FL4    Number of used entries\nVolTbl_Hdr_Vols_Eligible  DS    FL4    Nbr Volume entries eligible\nVolTbl_Hdr_Vols_Total     DS    FL4    Nbr Volume entries in table\nVolTbl_Hdr_Vols_Proc      DS    FL4    Nbr Volume entries complete\nVolTbl_Hdr_Total_Off      DS    FL4    Offset of Totals Line\nVolTbl_Hdr_SMS_Off        DS    FL4    Offset of SMS Anomaly line\nVolTbl_Hdr_SubT_Off       DS    FL4    Offset of SubTask Stats Hdg(s)\nVolTbl_Hdr_STIMERM_Adj    DS    FL4    Used by H00010 for STIMERM\n                          DS    0D\nVolTbl_Hdr_LSPACE_Avg     DS    DL8    Used by H00010 for STIMERM\n                          DS    0F     Alignment\nVolTbl_Hdr_ECB            DS    FL4    ECB POSTed when table complete\n                          DS    X      Flag Byte\nVolTbl_Hdr_OW48527        EQU   *-1,X'80' 1... .... APAR OW48527 on\nVolTbl_Hdr_MaxLWait       DS    HL2    Max LSPACE Wait time (secs)\n                          DS    0D     Alignment\nVolTbl_Hdr_Length         EQU   *-VolTbl_Hdr  Length of header\n\nVolTbl_Ent_Start          EQU   *     Info Table Entry\nVolTbl_Ent_ECB            DS    FL4    ECB POSTed when entry complete\n                          DS    X         Status Flag\nVolTbl_Ent_Processed      EQU   *-1,X'80' 1... .... This entry done\nVolTbl_Ent_LSPACE_Fail    EQU   *-1,X'40' .1.. .... LSPACE failed\nVolTbl_Ent_U522           EQU   *-1,X'20' ..1. .... MAXLWAIT(our ESTAE)\n                          DS    X         Entry Descriptor Flag\nVolTbl_Ent_Heading_Line1  EQU   *-1,X'80' 1... .... 1st Heading Line\nVolTbl_Ent_Heading_Line   EQU   *-1,X'40' .1.. .... Other Heading Line\nVolTbl_Ent_Detail_Line    EQU   *-1,X'20' ..1. .... Detail Line\nVolTbl_Ent_Total_Line     EQU   *-1,X'10' ...1 .... Total Line\nVolTbl_Ent_Stats_Line     EQU   *-1,X'08' .... 1... Stats Line\nVolTbl_Ent_SMS_Line       EQU   *-1,X'04' .... .1.. SMS Anomaly Msg\n                          DS    X         Statistics Line Status\nVolTbl_Ent_Stats_CPUTime  EQU   *-1,X'80' 1... .... CPU Time Stats Line\nVolTbl_Ent_Stats_31Stack  EQU   *-1,X'40' .1.. .... 31Bit Stack Stats\nVolTbl_Ent_Stats_24Stack  EQU   *-1,X'20' ..1. .... 24Bit Stack Stats\nVolTbl_Ent_Stats_Done     EQU   *-1,X'01' .... ...1 Stats line filled\n\nVolTbl_Ent_Sort_Start     DS    0D      Start of Sort fields\nVolTbl_Ent_Sort_FreeTrk   DS    DL8      Free Tracks\nVolTbl_Ent_Sort_FreeCyl   DS    DL8      Free Cylinders\nVolTbl_Ent_Sort_FreeBytes DS    DL8      Free Bytes\nVolTbl_Ent_Sort_FreePct   DS    DL8      Free Pct (xx.x)\nVolTbl_Ent_Sort_FreeExt   DS    DL8      Free Extents\nVolTbl_Ent_Sort_LargTrk   DS    DL8      Largest Free Tracks\nVolTbl_Ent_Sort_LargCyl   DS    DL8      Largest Free Cylinders\nVolTbl_Ent_Sort_VTOCTrk   DS    DL8      Tracks in the VTOC\nVolTbl_Ent_Sort_FreeDSCB  DS    DL8      Free DSCBs\nVolTbl_Ent_Sort_VTOCFree  DS    DL8      VTOC % Free\nVolTbl_Ent_Sort_VolSize   DS    DL8      Bytes/Volume\nVolTbl_Ent_Sort_DSCBs     DS    DL8      DSCBs\nVolTbl_Ent_Sort_FragIndex DS    DL8      Frag Index\nVolTbl_Ent_Sort_End       EQU   *       End of Sort fields\n                          ORG   VolTbl_Ent_Sort_Start\nVolTbl_Ent_Sort_Fields    DS    XL(VolTbl_Ent_Sort_End-VolTbl_Ent_Sort_+\n               Start)\n\nVolTbl_Ent_Totals         ORG   VolTbl_Ent_Sort_Start\nVolTbl_Ent_Total_FreeTracks   DS    DL8   Free Tracks\nVolTbl_Ent_Total_FreeCyls     DS    DL8   Free Cylinders\nVolTbl_Ent_Total_FreeBytes    DS    DL8   Free Bytes\nVolTbl_Ent_Total_FreePct      DS    DL8   Free % (xx.x)\nVolTbl_Ent_Total_Extents      DS    DL8   Free Extents\nVolTbl_Ent_Largest_FreeTracks DS    DL8   Largest Free Tracks\nVolTbl_Ent_Largest_FreeCyls   DS    DL8   Largest Free Cyls\nVolTbl_Ent_Total_VTOCTrk      DS    DL8   Total tracks in the VTOCs\nVolTbl_Ent_Total_FreeDSCBs    DS    DL8   Total free DSCBs\nVolTbl_Ent_Total_VTOCFree     DS    DL8   VTOC % Free\nVolTbl_Ent_Total_VolSize      DS    DL8   Total Bytes\nVolTbl_Ent_Total_DSCBs        DS    DL8   Total DSCBs\nVolTbl_Ent_Total_FragIndex    DS    DL8   Total of Frag Indices\nVolTbl_Ent_Total_Vols_OK      DS    FL4   Vols with valid LSPACE data\n                              ORG   ,\n\n                          DS    0F      Align\nVolTbl_Ent_CB_Start       EQU   *        Start of Control Blocks\nVolTbl_Ent_UCBCopy        DS    XL48      UCB Copy\nVolTbl_Ent_DCECopy        DS    XL48        DCE Copy\nVolTbl_Ent_LSPACE_Data    DS    CL(LSPACE_Data_Length) LSPACE\nVolTbl_Ent_DSCB           DS    CL(DS4END-IECSDSL4) Area for F4 DSCB\nVolTbl_Ent_CB_End         EQU   *          End of Control Blocks\n                          ORG   VolTbl_Ent_CB_Start\nVolTbl_Ent_CB_Fields      DS    XL(VolTbl_Ent_CB_End-VolTbl_Ent_CB_Star+\n               t)\n                          ORG   ,\n\nVolTbl_Ent_Display_Start  EQU   *      Start of Display fields\nVolTbl_Ent_Volser         DS    CL6     VOLSER\n                          DS    C\nVolTbl_Ent_DevAddr        DS    CL4     Device Address\n                          DS    CL2\nVolTbl_Ent_DevType        DS    CL8     Device Type\n                          DS    C\nVolTbl_Ent_Attrib         DS    CL3     Mount Status\nVolTbl_Ent_VTOC_SMS       DS    CL1     '*' if VTOC=SMS, UCB^=SMS\n                          DS    C\nVolTbl_Ent_ErrMsg         DS    0CL80   Error message\nVolTbl_Ent_FreeSpace_Info EQU   *       --- Free Space Info Start\nVolTbl_Ent_FreeTrk        DS    CL6         Nbr Free Tracks\n                          DS    C\nVolTbl_Ent_FreeCyl        DS    CL5         Nbr Free Cylinders\n                          DS    CL2\nVolTbl_Ent_FreePct        DS    CL4         % of volume free\n                          DS    C\nVolTbl_Ent_FreeBytes      DS    CL6         Bytes free on the volume\n                          DS    C\nVolTbl_Ent_FreeExt        DS    CL5         Nbr Free Extents\n                          DS    CL2         Largest Free Extents\nVolTbl_Ent_LargTrk        DS    CL6         Largest Free Tracks\n                          DS    C\nVolTbl_Ent_LargCyl        DS    CL5         Largest Free Cylinders\nVolTbl_Ent_FreeSpace_Info_End EQU *     --- Free Space Info End\n                          DS    C\nVolTbl_Ent_Frag_Indx      DS    CL5         Fragmentation Index\n                          DS    CL2\nVolTbl_Ent_VTOC_Info      EQU   *       --- VTOC Info Start\nVolTbl_Ent_VTOCTrk        DS    CL5         VTOC Tracks\n                          DS    C\nVolTbl_Ent_FreeDSCB       DS    CL5         Free DSCBs in VTOC\n                          DS    C\nVolTbl_Ent_VTOCFree       DS    CL4         % DSCBs free\n                          DS    C\nVolTbl_Ent_VTOCIX         DS    CL2         VTOC Index Status\nVolTbl_Ent_VTOC_Info_End  EQU   *       --- VTOC Info End\n                          DS    C           Volume Size\nVolTbl_Ent_VolSize        DS    CL6         Device capacity (in bytes)\n                          DS    C\nVolTbl_Ent_SMS_Info       EQU   *       --- SMS Info Start\nVolTbl_Ent_SMS_StorGrp    DS    CL8         SMS Storage Group\n                          DS    C\nVolTbl_Ent_SMS_Status     DS    CL12        SMS Volume Status\nVolTbl_Ent_SMS_Info_End   EQU   *       --- SMS Info End\n                          DS    C\nVolTbl_Ent_CHPID_Info     EQU   *       --- CHPID Info Start\nVolTbl_Ent_CHPIDs         DS    CL(8*4)     8 CHPIDs @ 4 bytes each\nVolTbl_Ent_CHPID_Info_End EQU   *       --- CHPID Info End\nVolTbl_Ent_Display_End    EQU   *       End of Display area\nVolTbl_Ent_Display_Len    EQU   *-VolTbl_Ent_Display_Start\n                          ORG   VolTbl_Ent_Display_Start\nVolTbl_Ent_Display        DS    CL(VolTbl_Ent_Display_Len)\n                          ORG   ,\n                          DS    0D      Alignment\nVolTbl_Ent_Len            EQU   *-VolTbl_Ent_Start Entry Length\n                          ORG   VolTbl_Ent_Start\nVolTbl_Ent                DS    CL(VolTbl_Ent_Len)\n                          ORG   ,\n\n*-------------------------------------------------------------------*\n*   This DSECT describes the area of storage used to manage the     *\n*  subtasks ATTACHed to retrieve the volume information.            *\n*-------------------------------------------------------------------*\nSubTask_Area              DSECT       Data for each subtask\n\nSubTask_Area_Hdr          EQU   *\nSubTask_Area_Hdr_Len      DS    FL4    SubPool, Length\nSubTask_Area_Hdr_Count    DS    FL4    Nbr entries following\n                          DS    0D\nSubTask_Area_Hdr_Length   EQU   *-SubTask_Area  Length of Header\n\nSubTask_Area_Ent          EQU   *      1 Entry per subtask\nSubTask_Area_Ent_ECB      DS    FL4     ECB POSTed at Subtask end\nSubTask_Area_Ent_TCB      DS    AL4     A(SubTask TCB - ATTACHX)\nSubTask_Area_Ent_Parms    DS    5AL4    Parms for subtask\n                          DS    0D      Alignment\nSubTask_Area_Ent_Length   EQU   *-SubTask_Area_Ent\n\n*-------------------------------------------------------------------*\n*   This DSECT describes the area of storage used to save the lists *\n*  of UCBs that should be included (UCB) or excluded (XUCB).        *\n*   This storage, if required, is acquired by the routine that      *\n*  PARSEs the parameters (C00010).                                  *\n*-------------------------------------------------------------------*\nUCB_List                  DSECT\n\nUCB_List_Hdr              EQU   *     Start of header\nUCB_List_Hdr_Len          DS    FL4    Length of table\nUCB_List_Hdr_Count        DS    FL4    Number of entries\nUCB_List_Hdr_Length       EQU   *-UCB_List_Hdr  Header length\nUCB_List_Ent              EQU   *     Start of entry\nUCB_List_Ent_UCB_Len      DS    XL1    Len of UCB entered\nUCB_List_Ent_UCB          DS    CL4    UCB, with wildcards = X'FF'\nUCB_List_Ent_Mask         DS    CL4    Wildcard mask, wildcards = X'FF'\n*                                                         other = X'00'\nUCB_List_Ent_Length       EQU   *-UCB_List_Ent   Length of an entry\n\n*-------------------------------------------------------------------*\n*   This DSECT describes the area of storage used to save the lists *\n*  of Volsers that should be included (VOL) or excluded (XVOL).     *\n*   This storage, if required, is acquired by the routine that      *\n*  PARSEs the parameters (C00010).                                  *\n*-------------------------------------------------------------------*\nVol_List                  DSECT\n\nVol_List_Hdr              EQU   *      Start of header\nVol_List_Hdr_Len          DS    FL4     Length of table\nVol_List_Hdr_Count        DS    FL4     Number of entries\nVol_List_Hdr_Length       EQU   *-Vol_List_Hdr  Header length\nVol_List_Ent              EQU   *      Start of entry\nVol_List_Ent_Vol          DS    CL6     Vol, with wildcards=X'FF'\nVol_List_Ent_Mask         DS    CL6     Wildcard mask, wildcards=X'FF'\n*                                                          other=X'00'\nVol_List_Ent_Length       EQU   *-Vol_List_Ent   Length of an entry\n\n*-------------------------------------------------------------------*\n*   This DSECT describes the area of storage used to save the list  *\n*  of SMS Storage Groups entered as a selection criterion.          *\n*   This storage, if required, is acquired by the routine that      *\n*  PARSEs the parameters (C00010).                                  *\n*-------------------------------------------------------------------*\nSTORGRP_List              DSECT\n\nSTORGRP_List_Hdr          EQU   *      Start of header\nSTORGRP_List_Hdr_Len      DS    FL4     Length of table\nSTORGRP_List_Hdr_Count    DS  FL4       Number of entries\nSTORGRP_List_Hdr_Length   EQU *-STORGRP_List_Hdr Header length\nSTORGRP_List_Ent          EQU   *      Start of entry\nSTORGRP_List_Ent_STORGRP  DS    CL(L'VLDSTGRP) Name, wildcards=x'FF'\nSTORGRP_List_Ent_Mask     DS    CL(L'VLDSTGRP) Mask, wildcards=x'FF'\n*                                                 other = X'00'\nSTORGRP_List_Ent_Length   EQU   *-STORGRP_List_Ent Length of an entry\n         TITLE 'Global Dynamic Storage'\n\n*-------------------------------------------------------------------*\n*   This DSECT describes dynamic storage addressable by all rout-   *\n*  ines in this program.                                            *\n*-------------------------------------------------------------------*\n@_Dynam                   DSECT\n\n@_31Bit_Stack_Ptr         DS    AL4    A(General Stack)\n@_31Bit_Stack_Length      EQU   16384-StackHdr_Length 16K Stack\n\n@_24Bit_Stack_Ptr         DS    AL4    A(24-bit Stack)\n@_24Bit_Stack_Length      EQU 2048-StackHdr_Length 2K Stack\n\n@_VolTbl_Ptr              DS    AL4    A(Table of space info)\n\n                          DS    X      Environment flag\n@_Batch_Environ           EQU   *-1,X'80' 1... .... Batch run\n@_TSO_Command             EQU   *-1,X'40' .1.. .... TSO command\n@_OW48527                 EQU   *-1,X'20' ..1. .... OW48527 installed\n@_IKJEFTSR                EQU   *-1,X'10' ...1 .... IKJEFTSR Invoked\n@_CHAP_Done               EQU   *-1,X'08' .... 1... Prty lowered\n\n                          DS    X      Output Options Flags\n@_No_Headings             EQU   *-1,X'80' 1... .... No hdgs\n@_No_Details              EQU   *-1,X'40' .1.. .... No detail\n@_No_Totals               EQU   *-1,X'20' ..1. .... No totals\n@_Statistics              EQU   *-1,X'10' ...1 .... Internal Stats\n@_ISPF_SPACE              EQU   *-1,X'08' .... 1... ISPF tbl and pnl\n@_ISPF_EDIF               EQU   *-1,X'04' .... .1.. ISPF EDIF\n@_ISPF_BRIF               EQU   *-1,X'02' .... ..1. ISPF BRIF\n@_ISPF_Explicit           EQU   *-1,X'01' .... ...1 ISPF Kwd specified\n\n                          DS    X      More Output Options Flags\n@_No_LSPACE               EQU   *-1,X'80' 1... .... Don't issue LSPACE\n@_ReDisplay               EQU   *-1,X'40' .1.. .... Redisplay required\n@_OutData_DISPLAY         EQU   *-1,X'04' .... .1.. OUTDATA(DISPLAY)\n@_OutData_CB              EQU   *-1,X'02' .... ..1. OUTDATA(CB)\n@_OutData_ALL             EQU   *-1,X'01' .... ...1 OUTDATA(ALL)\n\n                          DS    X      Error Flags\n@_VolTbl_GETMAIN_Err      EQU   *-1,X'80' 1... .... Not enough storage\n@_No_APF                  EQU   *-1,X'20' ..1. .... No APF auth\n@_IKJEFTSR_Err            EQU   *-1,X'10' ...1 .... Error in IKJEFTSR\n@_SYSCLOCK_Err            EQU   *-1,X'08' .... 1... SYSCLOCK Mismatch\n@_Incompatible_OS         EQU   *-1,X'04' .... .1.. Incompatible OS\n@_Internal_Err            EQU   *-1,X'02' .... ..1. Unknown parm\n@_LSPACE_Failed           EQU   *-1,X'01' .... ...1 VolTbl Incomplete\n\n@_CPU_Time_Init           DS    DL8    CPU Time at start of pgm\n@_CPU_Time_Used           DS    DL8    Accumulated CPU Time\n\n@_IKJEFTSR_RC             DS    FL4    IKJEFTSR Return code area\n@_IKJEFTSR_Reas           DS    FL4    IKJEFTSR Reason code area\n\n@_IKJEFTSR_TimeStamp_Ptr  DS    AL4    A(TimeStamp for IKJEFTSR)\n@_NSwap_Time              DS    DL8    Non-swappable time\n\n@_Sort_Field              DS    CL8    Sort Field\n@_Sort_Direction          DS    CL1    Sort Direction (A/D)\n\n@_LineSize                DS    HL2    Line Size from command line\n\n@_MaxLWait                DS    HL2    Max LSPACE Wait time (seconds)\n\n@_MaxTasks                DS    HL2    Max LSPACE sub-tasks on cmdline\n@_SubTask_Count           DS    FL4    Nbr subtasks to ATTACH\n@_SubTask_Area_Ptr        DS    AL4    A(SubTask Area)\n@_LP_Count                DS    FL4    Nbr active LPs\n\n@_OutFile_DDname          DS    CL8    DDName of current OUTFILE\n@_OutFile_24Bit_Stack_Ptr DS    AL4    A(24-bit Stack for OutFile DCBs)\n@_OutFile_Chain_Ptr       DS    AL4    A(Start of Output DCB chain)\n@_OutFile_PUT_Code        DS    AL4    A(24-bit PUT code)\n\n*  ------  Selection Criteria  ------\n@_Vol_List_Ptr            DS    AL4     A(List of VOLSER Masks)\n@_XVol_List_Ptr           DS    AL4     A(List of XVOLSER Masks)\n@_UCB_List_Ptr            DS    AL4     A(List of UCB Masks)\n@_XUCB_List_Ptr           DS    AL4     A(List of XUCB Masks)\n@_STORGRP_List_Ptr        DS    AL4     A(List of StorGrps)\n@_UNITNM                  DS    CL8     Unit Name\n                          DS    X       Mount Attribute\n@_ATTRPvt                 EQU   *-1,X'80' 1... .... Private\n@_ATTRPub                 EQU   *-1,X'40' .1.. .... Public\n@_ATTRStg                 EQU   *-1,X'20' ..1. .... Storage\n@_ATTRSMS                 EQU   *-1,X'10' ...1 .... SMS\n\n*-----------------------------  Start of TSO Cmd specific data  -----*\n                          DS    0D                                   *\n@_CPPL_Ptr                DS    AL4     A(Cmd Proc Parm List)        *\n                          DS    X       Flag byte                    *\n@_TSO_Processed           EQU   *-1,X'80' 1... .... Cmd processed    *\n@_ISPLINK                 DS    AL4     A(ISPLINK)                   *\n*-----------------------------  End of TSO Cmd specific data  -------*\n\n*-----------------------------  Start of Batch specific data  -------*\n                          DS    0D                                   *\n@_SYSIN_DCB_Ptr           DS    AL4     A(SYSIN DCB)                 *\n@_Page_Count              DS    HL2     Page Count                   *\n@_Line_Count              DS    HL2     Line Count                   *\n@_Bat_CPPL_Ptr            DS    AL4     A(CPPL in Batch)             *\n                          DS    0F      Alignment                    *\n@_Bat_CPPL                DS    CL(CPPL_Length)  CPPL in Batch       *\n                          DS    0F      Alignment                    *\n@_SYSIN_DCBE              DS    CL(C_SYSIN_DCBE_Length) SYSIN DCBE   *\n*-----------------------------  End of Batch specific data  ---------*\n                          ORG   ,\n*=====================================================================*\n                          DS    0D\n@_Dynam_Length            EQU   *-@_Dynam  Length of Global storage\n\n         TITLE 'Main Program Block'\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Routine   : A00010                                                 *\n*                                                                     *\n*  Abstract  : Main program loop - invoke other routines to perform   *\n*              real work                                              *\n*                                                                     *\n*  Inputs    : As received on invocation                              *\n*  Outputs   : R15: 0 - OK                                            *\n*                   4 - Error encountered                             *\n*                                                                     *\n*  Notes     :                                                        *\n*                                                                     *\n*  History:    1990/06/11 SDDA030 - New                               *\n*              1999/05/27 SDDA030 - V2.6                              *\n*                                 - Used LIFO Stack for our dynamic   *\n*                                   areas.                            *\n*              1999/09/30 SDDA030 - V2.10                             *\n*                                 - Reset Stack statistics for each   *\n*                                   iteration.                        *\n*              2000/01/19 SDDA030 - V2.11                             *\n*                                 - Added 24-bit Stack                *\n*              2001/02/01 SDDA030 - V2.13                             *\n*                                 - Added check for re-invocation by  *\n*                                   IKJEFTSR                          *\n*              2006/04/21 SDDA030 - V2.24                             *\n*                                 - Used standardized calling sequence*\n*              ____/__/__ _______                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n*        PRINT NOGEN\n\n&PGMNAME CSECT\n&PGMNAME AMODE 31\n&PGMNAME RMODE ANY\n\n         SYSSTATE ARCHLVL=1\n\n         J     A00010                   Skip eyecatcher\n         DC    C'&PGMNAME &VERSION  &ASMDT &ASMTM'\n\nA00010   DS    0H\n         BAKR  R14,0                    Save callers registers\n         LARL  R11,A_Literals           Point to our literals\n         USING (A_Literals,A_Literals_End),R11 Tell the assembler\n\n*-------------------------------------------------------------------*\n*    Make sure we're in 31-bit mode                                 *\n*-------------------------------------------------------------------*\n         TAM   ,                        Check AMODE\n         JM    A00020                   AMODE 31, OK\n         SAM31 ,                        Get into 31-bit mode\n\nA00020   DS    0H\n*-------------------------------------------------------------------*\n*    Get some storage for our LIFO stack ...                        *\n*-------------------------------------------------------------------*\n         LHI   R0,@_31Bit_Stack_Length  Length of storage we need\n         SSCSTACK INIT,                 Go get our storage             +\n               LEN=(R0),                 this long                     +\n               LOC=31                    above-the-line\n\n         LR    R3,R1                    Save its address\n\n*-------------------------------------------------------------------*\n*    ... and get some room on it for the globally addressable       *\n*     variables ...                                                 *\n*-------------------------------------------------------------------*\n         SSCSTACK PUSH,                 Get Stack area                 +\n               LEN=@_Dynam_Length,       this long                     +\n               STACK=(R3)                using this stack\n\n         LR    R12,R1                   Point to our storage\n\n         USING @_Dynam,R12              Assign a base\n\n         LA    R0,@_Dynam               A(Our storage)\n         LHI   R1,@_Dynam_Length        Its length\n         LA    R14,0                    Clear source address\n         LA    R15,0                     and length\n         MVCL  R0,R14                   Clear our storage\n\n         ST    R3,@_31Bit_Stack_Ptr     Save A(Stack)\n\n*-------------------------------------------------------------------*\n*    ... and finally get an area on it for our local storage        *\n*-------------------------------------------------------------------*\n         SSCSTACK PUSH,                 Get Stack area                 +\n               LEN=@A_Dynam_Length,      this long                     +\n               STACK=@_31Bit_Stack_Ptr    using this stack\n\n         LR    R3,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LHI   R1,@A_Dynam_Length        Its length\n         LA    R14,0                    Clear source address\n         LA    R15,0                     and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R3                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*    Set up save area, and restore the important registers          *\n*   that we have destroyed                                          *\n*-------------------------------------------------------------------*\n         LR    R13,R1                   Load dynam base\n         USING @A_Dynam,R13             Tell the assembler\n         MVC   4(4,R13),=C'F1SA'        Init save area\n\n         EREG  R0,R3                    Restore callers registers\n\n*--------------------------------------------------------------------*\n*   Initialize our standard parmlist                                 *\n*--------------------------------------------------------------------*\n         LA    R15,@_Dynam              A(Dynamic area)\n         ST    R15,@A_Parms_Std         Save it\n         LA    R15,@_31Bit_Stack_Ptr    A(31-bit Stack Pointer)\n         ST    R15,@A_Parms_Std+4       Save it\n         LA    R15,@_24Bit_Stack_Ptr    A(24-bit Stack Pointer)\n         ST    R15,@A_Parms_Std+8       Save it\n\n         ST    R1,@A_Original_R1        Save R1 on entry\n\n*--------------------------------------------------------------------*\n*   Initialize                                                       *\n*--------------------------------------------------------------------*\n         LA    R15,@A_Original_R1       A(Original R1)\n         ST    R15,@A_Parms_B00010      Save it\n\n         LA    R1,@A_Parms              A(Parmlist)\n         BRAS  R14,B00010               Go do initialization\n\n         ST    R15,@A_Max_RC            Save the return code\n         LTR   R15,R15                  Did it work?\n         JNZ   A00130                   No, skip\n\n*--------------------------------------------------------------------*\n*   If we are being re-invoked by IKJEFTSR ...                       *\n*--------------------------------------------------------------------*\n         TM    @_IKJEFTSR,L'@_IKJEFTSR  IKJEFTSR invocation?\n         JNO   A00100\n\n*--------------------------------------------------------------------*\n*   ... we want to invoke E00010 with the original @_Dynam.          *\n*  Therefore, we save the current @_Dynam address and load up the    *\n*  one passed to us (the original) ...                               *\n*--------------------------------------------------------------------*\n         L     R12,@A_Original_R1       Point to the @_Dynam\n         L     R12,2(0,R12)              to the one passed to us\n\n*--------------------------------------------------------------------*\n*   ... turn on the @_IKJEFTSR flag (since it is not on in this      *\n*  version of @_Dynam) ...                                           *\n*--------------------------------------------------------------------*\n         OI    @_IKJEFTSR,L'@_IKJEFTSR  On the flag\n\n*--------------------------------------------------------------------*\n*   ... invoke E00010 to populate the table ...                      *\n*--------------------------------------------------------------------*\n         LA    R1,@A_Parms              A(Parm list)\n         BRAS  R14,E00010               Go populate table\n\n*--------------------------------------------------------------------*\n*   ... turn off the @_IKJEFTSR flag, and re-point to our @_Dynam    *\n*--------------------------------------------------------------------*\n         NI    @_IKJEFTSR,X'FF'-L'@_IKJEFTSR  Off the flag\n         LR    R12,R3                  Reset @_Dynam base\n\n*--------------------------------------------------------------------*\n*   ... and exit                                                     *\n*--------------------------------------------------------------------*\n         LA    R15,0                   Clear return code\n         ST    R15,@A_Max_RC           Save it\n         J     A90010                  and exit\n\nA00100   DS    0H\n*--------------------------------------------------------------------*\n*   And now loop: Get Input                                          *\n*                 Get Space Info                                     *\n*                 Display Results                                    *\n*--------------------------------------------------------------------*\n\n*--------------------------------------------------------------------*\n*   Reset the CPU Time used so far, in case we have to produce       *\n*    stats ...                                                       *\n*--------------------------------------------------------------------*\n         TIMEUSED STORADR=@_CPU_Time_Init,  Reset CPU Time Used        +\n               LINKAGE=SYSTEM,           as recommended by IBM         +\n               CPU=MIC                   get it in microseconds\n         XC    @_CPU_Time_Used,@_CPU_Time_Used  Clear accum CPU Time\n\n*--------------------------------------------------------------------*\n*   ... and the Stack statistics ...                                 *\n*--------------------------------------------------------------------*\n         L     R15,@_31Bit_Stack_Ptr    Point to the stack\n         LA    R0,0                     Clear work register\n         ST    R0,StackHdr_HWM-StackHdr(R15) Clear high-water mark\n         ST    R0,StackHdr_GETMAIN-StackHdr(R15) Clear converted PUSHs\n         ST    R0,StackHdr_Overflow_HWM-StackHdr(R15) and GETMAIN HWM\n\n*--------------------------------------------------------------------*\n*   ... WAIT for our subtasks to complete ...                        *\n*--------------------------------------------------------------------*\n         LA    R1,@A_Parms              A(ParmList)\n         BRAS  R14,S00010               WAIT for our subtasks\n\n*--------------------------------------------------------------------*\n*   ... and then go and get some input                               *\n*--------------------------------------------------------------------*\n         LA    R1,@A_Parms              A(ParmList)\n         BRAS  R14,C00010               Go get processing parms\n         LTR   R15,R15                  EOF?\n         JNZ   A90010                   Yes, exit\n\n*--------------------------------------------------------------------*\n*   We have something, so go scan the UCBs ...                       *\n*--------------------------------------------------------------------*\n         LA    R1,@A_Parms              A(Parm list)\n         BRAS  R14,D00010               Go get eligible UCBs\n\n         LTR   R15,R15                  Any?\n         JZ    A00120                   Yes, skip\n         C     R15,@A_Max_RC            No, biggest RC so far?\n         JNH   A00130                   No, skip\n         ST    R15,@A_Max_RC            Yes, save it\n         J     A00130                   and skip\n\nA00120   DS    0H\n*--------------------------------------------------------------------*\n*   ... and get the info about them                                  *\n*--------------------------------------------------------------------*\n         LA    R1,@A_Parms              A(Parm list)\n         BRAS  R14,E00010               Go populate table\n\nA00130   DS    0H\n*--------------------------------------------------------------------*\n*   Output the info ...                                              *\n*--------------------------------------------------------------------*\n         LA    R1,@A_Parms              A(Parm list)\n         BRAS  R14,F00010               Output the results\n         C     R15,@A_Max_RC            Biggest RC so far?\n         JNH   A00140                   No, skip\n         ST    R15,@A_Max_RC            Yes, save it\n\nA00140   DS    0H\n*--------------------------------------------------------------------*\n*   ... and do it all again                                          *\n*--------------------------------------------------------------------*\n         L     R15,@A_Max_RC            Get max return code\n         CHI   R15,4                    Too big?\n         JNH   A00100                   No, get more input\n\nA90010   DS    0H\n*-------------------------------------------------------------------*\n*    Perform our Termination routines ...                           *\n*-------------------------------------------------------------------*\n         LA    R1,@A_Parms              A(Parm list)\n         BRAS  R14,Z00010               Clean up\n\n*-------------------------------------------------------------------*\n*    ... delete our 24-bit stack ...                                *\n*-------------------------------------------------------------------*\n         ICM   R1,B'1111',@_24Bit_Stack_Ptr A(Stack below-the-line)\n         JZ    A90020                   None, skip\n         SSCSTACK TERM,                 Free the stack area            +\n               STACK=(1)                 this one\n\nA90020   DS    0H\n*-------------------------------------------------------------------*\n*    ... save our max return code, and free up our local data ...   *\n*-------------------------------------------------------------------*\n         L     R4,@A_Max_RC             Save return code\n\n         LA    R1,@A_Dynam              A(Local storage)\n\n         SSCSTACK POP,                  Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=@_31Bit_Stack_Ptr   on this stack\n\n*-------------------------------------------------------------------*\n*    ... then the global data area ...                              *\n*-------------------------------------------------------------------*\n         LA    R1,@_Dynam               A(Global storage)\n         L     R3,@_31Bit_Stack_Ptr     Rescue Stack pointer\n\n         SSCSTACK POP,                  Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=(R3)                on this stack\n\n*-------------------------------------------------------------------*\n*    ... and finally, the stack itself.                             *\n*-------------------------------------------------------------------*\n         SSCSTACK TERM,                 Free the stack                 +\n               STACK=(R3)                starting here\n\n*-------------------------------------------------------------------*\n*    Restore the callers registers, and exit.                       *\n*-------------------------------------------------------------------*\n         LR    R15,R4                   Restore return code\n         PR    ,                        and return to caller\n\nA_Literals      DS    0H\n\n         LTORG\n\nA_Literals_End  DS    0H\n\n@A_Dynam                  DSECT         Dynamic storage for A00010\n                          DS    18F      Save area\n@A_Original_R1            DS    FL4      R1 on entry\n@A_Max_RC                 DS    FL4      Highest return code\n@A_Parms                  DS    0F       Parms for Called modules\n@A_Parms_Std              DS    3AL4      Standard 3 parms\n@A_Parms_Extra            EQU   *         More parms\n@A_Parms_B00010           DS    AL4         for B00010\n                          ORG   ,\n                          DS    0D       Alignment\n@A_Dynam_Length           EQU   *-@A_Dynam  Length\n\n&PGMNAME CSECT\n\n         DROP  ,\n         TITLE 'B00010: Initialization'\n\n         PUSH  USING\n\nB00010   DS    0H\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Routine   : B00010                                                 *\n*                                                                     *\n*  Abstract  : Perform one-time initialization functions based on     *\n*              environment.                                           *\n*                                                                     *\n*  Inputs    : R1 : ---> A(@_Dynam)                                   *\n*                        A(31-bit Stack Pointer)                      *\n*                        A(24-bit Stack Pointer)                      *\n*                        A(Original R1 on program invocation)         *\n*  Outputs   : R15: 0 - OK                                            *\n*                   4 - Error encountered                             *\n*                                                                     *\n*  Notes     :                                                        *\n*                                                                     *\n*  History:    1990/06/11 SDDA030 - New                               *\n*              1998/09/22 SDDA030 - V2.1                              *\n*                                 - Copied STLINENO or SYSPRINT/SYSIN *\n*                                   I/O routines to 24-bit storage.   *\n*              1998/11/13 SDDA030 - V2.2                              *\n*                                 - Set up TSO environment (IKJTSOEV) *\n*                                   in batch.                         *\n*              1999/01/14 SDDA030 - V2.4                              *\n*                                 - Rationalized ISPF/TSO cmd/CALL    *\n*                                   checks                            *\n*              1999/05/27 SDDA030 - V2.6                              *\n*                                 - Used LIFO Stack for our dynamic   *\n*                                   areas.                            *\n*                                 - Removed copy of SYSIN/SYSPRINT    *\n*                                   routines to 24-bit storage.       *\n*              1999/07/30 SDDA030 - V2.7                              *\n*                                 - Moved SYSIN initialization to     *\n*                                   C00010                            *\n*              1999/09/30 SDDA030 - V2.10                             *\n*                                 - Removed ISPF initialization.      *\n*                                 - Created @_Hdr0-3.                 *\n*              2000/01/19 SDDA030 - V2.11                             *\n*                                 - OPENed SYSPRINT if batch          *\n*              2001/02/01 SDDA030 - V2.13                             *\n*                                 - Added check for parms passed for  *\n*                                   IKJEFTSR invocation.              *\n*              2001/02/26 SDDA030 - V2.14                             *\n*                                 - Moved heading initialization to   *\n*                                   C00010.                           *\n*              2002/08/08 SDDA030 - V2.19                             *\n*                                 - Checked IGC0007H (LSPACE) for     *\n*                                   APAR OW48527                      *\n*              2006/04/21 SDDA030 - V2.24                             *\n*                                   Used standardised calling sequence*\n*              ____/__/__ xxxxxxx - Vx.xx                             *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         STM   R14,R12,12(R13)          Save callers registers\n         LARL  R11,B_Literals           Point to our literals\n         USING (B_Literals,B_Literals_End),R11 Tell the assembler\n\n         L     R12,0(0,R1)              A(@_Dynam)\n         USING @_Dynam,R12              Tell the assembler\n\n*-------------------------------------------------------------------*\n*    Get an area on the stack for our local storage                 *\n*-------------------------------------------------------------------*\n         L     R2,4(0,R1)               A(31-bit stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         SSCSTACK PUSH,                 Get Stack area                 +\n               LEN=@B_Dynam_Length,      this long                     +\n               STACK=(R2)                using this stack\n\n         LR    R3,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LHI   R1,@B_Dynam_Length        Its length\n         LA    R14,0                    Clear source address\n         LA    R15,0                     and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R3                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*-------------------------------------------------------------------*\n         ST    R13,4(0,R1)              Chain\n         ST    R1,8(0,R13)               saveareas\n         LR    R13,R1                   Load dynam base\n         USING @B_Dynam,R13             Assign a base\n\n         L     R15,@B_Dynam+4           Get A(HSA)\n         LM    R0,R3,20(R15)            Restore callers registers\n\n         L     R15,4(0,R1)              A(31-bit Stack Pointer)\n         ST    R15,@B_31Bit_Stack_Ptr_Ptr Save it\n         L     R15,8(0,R1)              A(24-bit Stack Pointer)\n         ST    R15,@B_24Bit_Stack_Ptr_Ptr Save it\n\n*---------------------------------------------------------------------*\n*    Clear our various flags, and save the original R1                *\n*---------------------------------------------------------------------*\n         NI    @_TSO_Command,X'FF'-L'@_TSO_Command Off TSO flag\n         NI    @_Batch_Environ,X'FF'-L'@_Batch_Environ Off Batch flag\n         L     R15,12(0,R1)             A(Original R1)\n         L     R15,0(0,R15)             Get it\n         ST    R15,@B_Original_R1       Save it\n\n*---------------------------------------------------------------------*\n*   Determine the environment under which we were invoked:            *\n*     TSO Command: R1 --> CPPL                                        *\n*     IKJEFTSR Reinvocation:                                          *\n*        R1 ---> A(Parm1): HL2'4',A(Original @_Dynam)                 *\n*                A(Parm2): HL2'?',CL?(Copy of start of @_Dynam)       *\n*     Batch: Anything else                                            *\n*---------------------------------------------------------------------*\n         ICM   R1,B'1111',@B_Original_R1 Restore original R1\n         JZ    B03000                   Nothing, not a TSO cmd\n         L     R14,PSATNEW-PSA(0)       Yes, get A(our TCB)\n         L     R14,TCBJSCB-TCB(R14)     Get A(Our JSCB)\n         SLL   R14,8                    Clean\n         SRL   R14,8                      it\n         ICM   R14,B'1111',JSCBPSCB-IEZJSCB(R14) Get A(PSCB)\n         JZ    B03000                   None, not TSO\n         C     R14,CPPLPSCB-CPPL(R1)    Are we passed a CPPL?\n         JE    B02000                   Yes, go process\n\n*---------------------------------------------------------------------*\n*   We were passed a parm, but it is not the CPPL; check out the      *\n*  parms to see if we are being re-invoked by IKJEFTSR:               *\n*                                                                     *\n*     R1 ---> ---> H'4',A(@_Dynam)                                    *\n*             ---> H'16',1st 16 bytes of @_Dynam                      *\n*---------------------------------------------------------------------*\n         TM    0(R1),X'80'              Only 1 parm?\n         JO    B03000                   Yes, not IKJEFTSR, assume batch\n         TM    4(R1),X'80'              No, 2nd parm the last?\n         JNO   B80010                   No, error\n\n         L     R15,0(0,R1)              Get A(1st parm)\n         LH    R14,0(0,R15)             Get its length\n         CHI   R14,4                    Is it the right length?\n         JNE   B80010                   No, not IKJEFTSR\n         L     R0,2(0,R15)              Maybe, load A(Original @_Dynam)\n\n         L     R14,4(0,R1)              Get A(2nd Parm)\n         LH    R15,0(0,R14)             Get its length\n         LA    R14,2(0,R14)             Point to it\n         LR    R1,R15                   Length to check\n         CLCL  R0,R14                   Is this really @_Dynam?\n         JNE   B80010                   No, error\n\n         OI    @_IKJEFTSR,L'@_IKJEFTSR  Yes, set our flag\n         LA    R15,0                    Clear the return code\n         J     B90010                   and exit\n\nB02000   DS    0H\n*---------------------------------------------------------------------*\n*   TSO Command Initialization - save A(CPPL) ...                     *\n*---------------------------------------------------------------------*\n         OI    @_TSO_Command,L'@_TSO_Command    Set TSO flag\n\n         L     R1,@B_Original_R1        Get original R1 - A(CPPL)\n         ST    R1,@_CPPL_Ptr            Save A(CPPL)\n\n*---------------------------------------------------------------------*\n*   ... clear our flag ...                                            *\n*---------------------------------------------------------------------*\n         NI    @_TSO_Processed,X'FF'-L'@_TSO_Processed\n\n*---------------------------------------------------------------------*\n*   ... and go check the status of OW48527                            *\n*---------------------------------------------------------------------*\n         J     B04000                   go do it\n\nB03000   DS    0H\n*---------------------------------------------------------------------*\n*   Batch Job Initialization - initialize page and line counts ...    *\n*---------------------------------------------------------------------*\n         OI    @_Batch_Environ,L'@_Batch_Environ Set Batch flag\n\n         LA    R15,0                    Clear work register\n         STH   R15,@_Page_Count         Clear page count\n\n*---------------------------------------------------------------------*\n*   ... and set up the TSO environment by invoking IKJTSOEV, saving   *\n*  the address of the CPPL we get back.                               *\n*---------------------------------------------------------------------*\n         LA    R1,@B_Link_Parms         A(Parameter list)\n         LA    R15,@B_Link_Parms+20     Point past them\n         LHI   R14,4                    4 parameters\n\nB03010   DS    0H\n         ST    R15,0(0,R1)              Save Parm ptr\n         AHI   R15,4                    Bump pointer\n         AHI   R1,4                     Bump parm pointer\n         BRCT  R14,B03010               and do it again\n         LA    R15,@_Bat_CPPL_Ptr       A(Command Buffer pointer)\n         ST    R15,@B_Link_Parms+16     Save it\n         OI    @B_Link_Parms+16,X'80'   Flag as last\n\n         MVC   @B_LINKX,B_LINKX         Move Link L-Form\n         LARL  R2,B03020                Error return here\n         LINKX EP=IKJTSOEV,             Establish TSO environment      +\n               ERRET=(2),                go here if LINK error         +\n               MF=(E,@B_Link_Parms),     using these parms             +\n               SF=(E,@B_LINKX)           keep ourselves re-entrant\n         ICM   R14,B'1111',@_Bat_CPPL_Ptr Get A(CPPL returned)\n         JNZ   B04000                   OK, check OW48527\n\nB03020   DS    0H\n*---------------------------------------------------------------------*\n*   If we didn't get a CPPL address back from IKJTSOEV, but we are    *\n*  running in a TSO address space, build our own copy of a CPPL that  *\n*  we can use to build the PPL                                        *\n*---------------------------------------------------------------------*\n         CHI   R15,24                   No, TSO env present?\n         JH    B03810                   No, something else, error\n\n         L     R14,PSATOLD-PSA(0)       Get A(our TCB)\n         L     R14,TCBJSCB-TCB(R14)     Get A(Our JSCB)\n         SLL   R14,8                    Clean\n         SRL   R14,8                      it\n         ICM   R14,B'1111',JSCBPSCB-IEZJSCB(R14) Get A(PSCB)\n         JZ    B03810                   None, can't use TSO\n         ST    R14,@_Bat_CPPL+CPPLPSCB-CPPL Save A(PSCB)\n\n         L     R15,PSCBUPT-PSCB(R14)    A(UPT)\n         ST    R15,@_Bat_CPPL+CPPLUPT-CPPL Save A(UPT)\n\n         L     R14,PSAAOLD-PSA(0)       Get A(our ASCB)\n         L     R14,ASCBASXB-ASCB(R14)   A(Our ASXB)\n         L     R14,ASXBLWA-ASXB(R14)    A(LWA)\n         L     R15,LWAPECT-LWA(R14)     A(ECT)\n         ST    R15,@_Bat_CPPL+CPPLECT-CPPL Save A(ECT)\n         LA    R15,@_Bat_CPPL           A(Our pseudo CPPL)\n         ST    R15,@_Bat_CPPL_Ptr       Save it\n\n         J     B04000                   Check status of OW48527\n\nB03810   DS    0H\n         LA    R15,4                    Error creating TSO environment\n         J     B90010                   exit\n\nB04000   DS    0H\n*-------------------------------------------------------------------*\n*    Everything is OK so far, so we want to check the status of     *\n*   APAR OW48527, which added a time-out to the LSPACE SVC (we will *\n*   do things differently if the APAR is installed). We check the   *\n*   module IGC0007H (LSPACE) for the literal 'I/O TIMEOUT', part    *\n*   of a new error message that came in with OW48527.               *\n*-------------------------------------------------------------------*\n         MVC   @B_CSVQUERY,B_CSVQUERY   Move L-Form\n         CSVQUERY INEPNAME=B_IGC0007H,  EP Name                        +\n               OUTLOADPT=@B_IGC0007H_Ptr,  return load point           +\n               OUTLENGTH=@B_IGC0007H_Len,  and length                  +\n               PLISTVER=MAX,               max parm list               +\n               MF=(E,@B_CSVQUERY)          staying reentrant\n         LTR   R15,R15                  How did we do?\n         JZ    B04010C                  OK, skip\n         CHI   R15,20                   Incompatible OS?\n         JE    B80020                   Yes, skip\n         J     B04910                   No, assume no OW48527\nB04010C  DS    0H\n\n         ICM   R14,B'1111',@B_IGC0007H_Len OK, get the length\n         JZ    B04910                   Nothing, skip\n         ICM   R15,B'1111',@B_IGC0007H_Ptr Get the address\n         JZ    B04910                   None, exit\n\n         LHI   R1,L'B_OW48527_Lit-1     EX length of literal\n         SLR   R14,R1                   Adjust the length to check\n\nB04020   DS    0H\n         EX    R1,B_Check_OW48527       Check for literal\n         JE    B04030                   Found it, skip\n         AHI   R15,1                    Not it, bump pointer\n         BRCT  R14,B04020               and check again\n         J     B04910                   Not found, exit\n\nB04030   DS    0H\n         OI    @_OW48527,L'@_OW48527    Indicate OW48527 present\n\nB04910   DS    0H\n         LA    R15,0                    Clear return code\n         J     B90010                   and exit\n\nB80010   DS    0H\n*-------------------------------------------------------------------*\n*    Unknown Parm, exit with error                                  *\n*-------------------------------------------------------------------*\n\n         OI    @_Internal_Err,L'@_Internal_Err Set our flag\n         LA    R15,8                    Set error return code\n         J     B90010                   and exit\n\nB80020   DS    0H\n*-------------------------------------------------------------------*\n*    Incompatible OS, set flag and return code                      *\n*-------------------------------------------------------------------*\n         OI    @_Incompatible_OS,L'@_Incompatible_OS Set our flag\n         LA    R15,8                    and return code\n         J     B90010                   and exit\n\nB90010   DS    0H\n*-------------------------------------------------------------------*\n*    Free up our local storage ...                                  *\n*-------------------------------------------------------------------*\n         LR    R3,R15                 Save return code\n\n         LA    R1,@B_Dynam              A(Local storage)\n         L     R2,@B_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n\n         L     R13,4(0,R13)             Rescue A(HSA)\n\n         SSCSTACK POP,                  Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=(2)                 on this stack\n\n         LR    R15,R3                   Restore return code\n\n*-------------------------------------------------------------------*\n*    ... and return to caller                                       *\n*-------------------------------------------------------------------*\n         L     R14,12(0,R13)            Restore return address\n         LM    R0,R12,20(R13)           Restore other registers\n         BSM   0,R14                    and return\n\nB_Literals            DS    0H\n\nB_Check_OW48527 CLC  B_OW48527_Lit,0(R15)  Check for OW48527 literal\n\n         PUSH  PRINT\n         PRINT NOGEN\n\nB_IGC0007H      DC    CL8'IGC0007H'   LSPACE SVC name\nB_OW48527_Lit   DC    C'I/O TIMEOUT'  Literal indicating OW48527\n\nB_LINKX  LINKX EP=IKJTSOEV,                                            +\n               SF=L\nB_LINKX_Length EQU *-B_LINKX\n\n         CSVQUERY PLISTVER=MAX,                                        +\n               MF=(L,B_CSVQUERY)\nB_CSVQUERY_Length EQU *-B_CSVQUERY\n\n\n         POP   PRINT\n\n\n         LTORG\nB_Literals_End            DS    0H\n\n@B_Dynam                  DSECT         Dynamic area for B00000\n                          DS    18F      O/S Style save area\n@B_31Bit_Stack_Ptr_Ptr    DS    AL4      A(31-bit Stack Ptr)\n@B_24Bit_Stack_Ptr_Ptr    DS    AL4      A(24-bit Stack Ptr)\n@B_Original_R1            DS    AL4      Value of R1 at program entry\n@B_Macros                 DS    0F       Macro area\n@B_LINKX                  DS    CL(B_LINKX_Length)  L-Form of LINKX\n@B_Link_Parms             DS    5AL4     Parms for Link\n                          DS    4AL4     Dummy parms\n                          ORG   @B_Macros\n@B_CSVQUERY               DS    CL(B_CSVQUERY_Length) L-Form CSVQUERY\n@B_IGC0007H_Ptr           DS    AL4      A(IGC0007H)\n@B_IGC0007H_Len           DS    AL4      Length of IGC0007H\n                          ORG   ,\n                          DS    0D       Alignment\n@B_Dynam_Length           EQU   *-@B_Dynam  Length of storage required\n\n&PGMNAME CSECT\n\n         DROP  ,\n         POP   USING\n         TITLE 'C00010: Get Input Data'\n\n         PUSH  USING\n\nC00010   DS    0H\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Routine   : C00010                                                 *\n*                                                                     *\n*  Abstract  : Get selection criteria for extracting UCB info         *\n*                                                                     *\n*  Inputs    : R1 : ---> A(@_Dynam)                                   *\n*                        A(31-bit Stack Pointer)                      *\n*                        A(24-bit Stack Pointer)                      *\n*  Outputs   : R15: 0 - OK                                            *\n*                   4 - EOF, 'END' etc.                               *\n*                                                                     *\n*  Operation : For a batch job,                                       *\n*               Read SYSIN                                            *\n*               Build a pseudo command buffer                         *\n*              Parse command buffer                                   *\n*                                                                     *\n*  Notes     :                                                        *\n*                                                                     *\n*  History:    1990/06/11 SDDA030 - New                               *\n*              1998/09/22 SDDA030 - V2.1                              *\n*                                 - Calculated default number of      *\n*                                   subtasks as the number of CPUs    *\n*                                   plus 1.                           *\n*                                 - Added U, UCB as aliaii for UNIT   *\n*                                   and V as an alias for VOL in      *\n*                                   Batch processing.                 *\n*                                 - Added STATS and MAXTASK keyword   *\n*                                   support.                          *\n*              1998/11/13 SDDA030 - V2.2                              *\n*                                 - Used IKJPARS to parse batch ctl   *\n*                                   cards.                            *\n*              1999/05/27 SDDA030 - V2.6                              *\n*                                 - Used LIFO Stack for our dynamic   *\n*                                   areas.                            *\n*                                 - Get SYSIN DCB storage and OPEN as *\n*                                   required.                         *\n*                                 - CLOSE and free SYSIN DCB at EOF.  *\n*              1999/07/30 SDDA030 - V2.7                              *\n*                                 - Use 24-bit EOD routine when 31-bit*\n*                                   SAM not supported for SYSIN.      *\n*              1999/09/30 SDDA030 - V2.10                             *\n*                                 - Removed ISPF stuff.               *\n*                                 - Set @_Line_Count to generate Hdr0 *\n*                                   only before echo of cmd line.     *\n*                                 - Display keyword descriptions in   *\n*                                   batch when invalid input found.   *\n*              2000/01/19 SDDA030 - V2.11                             *\n*                                 - PARSE keywords OUTFILE, OUTDATA.  *\n*              2001/02/26 SDDA030 - V2.14                             *\n*                                 - Added ISPF subfields S, E, and B. *\n*                                 - Allowed 'SPACE' as the 1st word   *\n*                                   in batch control cards.           *\n*                                 - Moved heading initialization from *\n*                                   B00010.                           *\n*                                 - Added SORT Subfields for VIX,     *\n*                                   FRAG, STORGRP, CHPIDS.            *\n*              2001/11/12 SDDA030 - V2.15                             *\n*                                   Added lists of UCBs, Volsers.     *\n*                                   Added XUCB, XVOL.                 *\n*              2002/03/11 SDDA030 - V2.17                             *\n*                                   Added STORGRP as a selection      *\n*                                   criterion.                        *\n*              2003/10/07 SDDA030 - V2.21                             *\n*                                   Used ASASYMBM to resolve symbols  *\n*                                   within VOL and XVOL.              *\n*                                   Stripped leading spaces from SYSIN*\n*                                   before checking for command name. *\n*              2006/04/21 SDDA030 - V2.24                             *\n*                                 - Calculated default number of      *\n*                                   subtasks as 2 * number of CPUs    *\n*                                   plus 1.                           *\n*                                   Used standardised calling sequence*\n*                                                                     *\n*              ____/__/__ _______                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         STM   R14,R12,12(R13)          Save callers registers\n         LARL  R11,C_Literals           Point to our literals\n         USING (C_Literals,C_Literals_End),R11 Tell the assembler\n\n         L     R12,0(0,R1)              A(@_Dynam)\n         USING @_Dynam,R12              Tell the assembler\n\n*-------------------------------------------------------------------*\n*    Get an area on the stack for our local storage                 *\n*-------------------------------------------------------------------*\n         L     R2,4(0,R1)               A(31-bit stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         SSCSTACK PUSH,                 Get Stack area                 +\n               LEN=@C_Dynam_Length,      this long                     +\n               STACK=(R2)                using this stack\n\n         LR    R3,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LHI   R1,@C_Dynam_Length        Its length\n         LA    R14,0                    Clear source address\n         LA    R15,0                     and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R3                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*-------------------------------------------------------------------*\n         ST    R13,4(0,R1)              Chain\n         ST    R1,8(0,R13)               saveareas\n         LR    R13,R1                   Load dynam base\n         USING @C_Dynam,R13             Assign a base\n         L     R15,@C_Dynam+4           Get A(HSA)\n         LM    R0,R3,20(R15)            Restore callers registers\n\n         L     R15,4(0,R1)              A(31-bit Stack Pointer)\n         ST    R15,@C_31Bit_Stack_Ptr_Ptr Save it\n         L     R15,8(0,R1)              A(24-bit Stack Pointer)\n         ST    R15,@C_24Bit_Stack_Ptr_Ptr Save it\n\n*---------------------------------------------------------------------*\n*   Free any selection lists we may have ...                          *\n*---------------------------------------------------------------------*\n         ICM   R1,B'1111',@_UCB_List_Ptr A(List of UCB Masks)\n         JZ    C00020                   None, skip\n         L     R0,UCB_List_Hdr_Len-UCB_List_Hdr(R1) Length\n         BASR  R2,0\n         USING (*,C00010_End-1),R2\n         STORAGE RELEASE,               Free the storage               +\n               ADDR=(1),                 starting here                 +\n               LENGTH=(0)                for this long\nC00010_End DS  0H\n         DROP  R2\n         XC    @_UCB_List_Ptr,@_UCB_List_Ptr Clear A(UCB List)\n\nC00020   DS    0H\n         ICM   R1,B'1111',@_XUCB_List_Ptr A(List of XUCB Masks)\n         JZ    C00030                   None, skip\n         L     R0,UCB_List_Hdr_Len-UCB_List_Hdr(R1) Length\n         BASR  R2,0\n         USING (*,C00020_End-1),R2\n         STORAGE RELEASE,               Free the storage               +\n               ADDR=(1),                 starting here                 +\n               LENGTH=(0)                for this long\nC00020_End DS  0H\n         DROP  R2\n         XC    @_XUCB_List_Ptr,@_XUCB_List_Ptr Clear A(XUCB List)\n\nC00030   DS    0H\n         ICM   R1,B'1111',@_Vol_List_Ptr A(List of Vol Masks)\n         JZ    C00040                   None, skip\n         L     R0,Vol_List_Hdr_Len-Vol_List_Hdr(R1) Length\n         BASR  R2,0\n         USING (*,C00030_End-1),R2\n         STORAGE RELEASE,               Free the storage               +\n               ADDR=(1),                 starting here                 +\n               LENGTH=(0)                for this long\nC00030_End DS  0H\n         DROP  R2\n         XC    @_Vol_List_Ptr,@_Vol_List_Ptr Clear A(Vol List)\n\nC00040   DS    0H\n         ICM   R1,B'1111',@_XVol_List_Ptr A(List of XVol Masks)\n         JZ    C00050                   None, skip\n         L     R0,Vol_List_Hdr_Len-Vol_List_Hdr(R1) Length\n         BASR  R2,0\n         USING (*,C00040_End-1),R2\n         STORAGE RELEASE,               Free the storage               +\n               ADDR=(1),                 starting here                 +\n               LENGTH=(0)                for this long\nC00040_End DS  0H\n         DROP  R2\n         XC    @_XVOL_List_Ptr,@_XVOL_List_Ptr Clear A(XVol List)\n\nC00050   DS    0H\n         ICM   R1,B'1111',@_STORGRP_List_Ptr A(List of STORGRP Masks)\n         JZ    C00060                   None, skip\n         L     R0,STORGRP_List_Hdr_Len-STORGRP_List_Hdr(R1) Length\n         BASR  R2,0\n         USING (*,C00050_End-1),R2\n         STORAGE RELEASE,               Free the storage               +\n               ADDR=(1),                 starting here                 +\n               LENGTH=(0)                for this long\nC00050_End DS  0H\n         DROP  R2\n         XC    @_STORGRP_List_Ptr,@_STORGRP_List_Ptr Clear A(List)\n\nC00060   DS    0H\n*---------------------------------------------------------------------*\n*   ... and set all our selection criteria so that all volumes will   *\n*  be selected.                                                       *\n*---------------------------------------------------------------------*\n         MVI   @_UNITNM,C' '            Assume all\n         MVC   @_UNITNM+1(L'@_UNITNM-1),@_UNITNM Unitnames\n         NI    @_ATTRPvt,X'FF'-L'@_ATTRPvt Off Mnt Attr flag\n         NI    @_ATTRPub,X'FF'-L'@_ATTRPub Off Mnt Attr flag\n         NI    @_ATTRStg,X'FF'-L'@_ATTRStg Off Mnt Attr flag\n         NI    @_ATTRSMS,X'FF'-L'@_ATTRSMS Off Mnt Attr flag\n\n*---------------------------------------------------------------------*\n*   Set all our output-related flags to their default (off) state     *\n*---------------------------------------------------------------------*\n         NI    @_No_Headings,X'FF'-L'@_No_Headings Off flag\n         NI    @_No_Details,X'FF'-L'@_No_Details   Off flag\n         NI    @_No_Totals,X'FF'-L'@_No_Totals     Off flag\n         NI    @_Statistics,X'FF'-L'@_Statistics   Off flag\n         NI    @_ISPF_SPACE,X'FF'-L'@_ISPF_SPACE Off flag\n         NI    @_ISPF_EDIF,X'FF'-L'@_ISPF_EDIF     Off flag\n         NI    @_ISPF_BRIF,X'FF'-L'@_ISPF_BRIF     Off flag\n         NI    @_ISPF_Explicit,X'FF'-L'@_ISPF_Explicit Off flag\n         NI    @_No_LSPACE,X'FF'-L'@_No_LSPACE     Off flag\n\n*---------------------------------------------------------------------*\n*   Set MaxTasks to default                                           *\n*---------------------------------------------------------------------*\n         AIF   (&Default_SubTask_Count LT 1).Def_SubTask_Count_010\n         LHI   R15,&Default_SubTask_Count Default nbr subtasks\n         AGO   .Def_SubTask_Count_020\n.Def_SubTask_Count_010 ANOP\n         SLR   R15,R15                   Use dynamic subtask count\n.Def_SubTask_Count_020 ANOP\n         STH   R15,@_MaxTasks            Set it\n\n*---------------------------------------------------------------------*\n*   Clear out Sort field name, and default to Ascending sort          *\n*---------------------------------------------------------------------*\n         MVC   @_Sort_Field,=CL8' '\n         MVI   @_Sort_Direction,C'A'\n\n*---------------------------------------------------------------------*\n*   Reset our internal flags                                          *\n*---------------------------------------------------------------------*\n         NI    @C_UNIT_Flag,X'FF'-L'@C_UNIT_Flag\n         NI    @C_XUNIT_Flag,X'FF'-L'@C_XUNIT_Flag\n         NI    @C_VOL_Flag,X'FF'-L'@C_VOL_Flag\n         NI    @C_XVOL_Flag,X'FF'-L'@C_XVOL_Flag\n\n*---------------------------------------------------------------------*\n*   Reset OUTFILE and OUTDATA fields                                  *\n*---------------------------------------------------------------------*\n         MVC   @_OutFile_DDName,=CL8' '\n         NI    @_OutData_DISPLAY,X'FF'-L'@_OutData_DISPLAY\n         NI    @_OutData_CB,X'FF'-L'@_OutData_CB\n         NI    @_OutData_ALL,X'FF'-L'@_OutData_ALL\n\n*-------------------------------------------------------------------*\n*    Initialize @_MaxLWait to the maximum number of seconds to      *\n*   wait for each LSPACE; we determine whether or not we are a      *\n*   foreground user (TSO) to decide on the initialization value.    *\n*-------------------------------------------------------------------*\n         L     R15,PSAAOLD-PSA          A(Our ASCB)\n         ICM   R0,B'1111',ASCBTSB-ASCB(R15) Get A(TSB)\n         JZ    C00060C                  Not a foreground user, skip\n         LHI   R15,&Fore_LSPACE_Wait    Foreground WAIT time\n         J     C00060E                  and skip\nC00060C  DS    0H\n         LHI   R15,&Back_LSPACE_Wait    Background WAIT time\n         J     C00060E                  and skip\nC00060E  DS    0H\n         STH   R15,@_MaxLWait           Update MaxLWait\n\n*---------------------------------------------------------------------*\n*   Free the VolTbl, if it exists                                     *\n*---------------------------------------------------------------------*\n         NI    @_VolTbl_GETMAIN_Err,X'FF'-L'@_VolTbl_GETMAIN_Err\n\n         ICM   R1,B'1111',@_VolTbl_Ptr A(Info Table)\n         JZ    C00070                  None, skip\n         L     R0,VolTbl_Hdr_TbLen-VolTbl(R1) Get its length\n         BASR  R2,0\n         USING (*,C00060_End-1),R2\n         STORAGE RELEASE,               Free the table                 +\n               ADDR=(1),                 starting here                 +\n               LENGTH=(0)                for this long\nC00060_End DS  0H\n         DROP  R2\n         LA    R15,0                    Clear work register\n         ST    R15,@_VolTbl_Ptr         and clear VolTbl pointer\n\nC00070   DS    0H\n*--------------------------------------------------------------------*\n*   Initialize our standard parmlist                                 *\n*--------------------------------------------------------------------*\n         LA    R15,@_Dynam              A(Dynamic area)\n         ST    R15,@C_Parms_Std         Save it\n         L     R15,@C_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)\n         ST    R15,@C_Parms_Std+4       Save it\n         L     R15,@C_24Bit_Stack_Ptr_Ptr A(24-bit Stack Pointer)\n         ST    R15,@C_Parms_Std+8       Save it\n\n*---------------------------------------------------------------------*\n*      Check what kind of processing we have to do                    *\n*---------------------------------------------------------------------*\n         TM    @_TSO_Command,L'@_TSO_Command Is this a TSO command?\n         JNO   C00080                   No, skip\n         TM    @_TSO_Processed,L'@_TSO_Processed Yes, already done?\n         JO    C00780                   Yes, EOF\n         OI    @_TSO_Processed,L'@_TSO_Processed No, end next time\n         L     R1,@_CPPL_Ptr            Get A(CPPL)\n         J     C00160                   and skip\n\nC00080   DS    0H\n*---------------------------------------------------------------------*\n*   This is batch - go read a record from SYSIN, and build a          *\n*   pseudo command buffer that we can pass to IKJPARS                 *\n*---------------------------------------------------------------------*\n         LHI   R15,4095                 Key count to produce\n         STH   R15,@_Line_Count          Hdg0\n\n         ICM   R1,B'1111',@_SYSIN_DCB_Ptr A(SYSIN DCB)\n         JNZ   C00100                   Already here, skip\n\n*---------------------------------------------------------------------*\n*   SYSIN has not been OPENed - get some storage, and OPEN it         *\n*---------------------------------------------------------------------*\n         LHI   R0,C_SYSIN_DCB_Length+C00760_24_Length+7 DCB, 24-bit EOD\n         SRL   R0,3                     DBLWD\n         SLL   R0,3                      multiple\n\n         BASR  R2,0\n         USING (*,C00080_End-1),R2\n         STORAGE OBTAIN,                Get some storage               +\n               LENGTH=(0),               this long                     +\n               LOC=24                    below the line\nC00080_End DS  0H\n         DROP  R2\n\n         SLL   R1,8                     Clean the\n         SRL   R1,8                      address\n         ST    R1,@_SYSIN_DCB_Ptr       Save A(SYSIN DCB)\n\n         L     R3,@_SYSIN_DCB_Ptr       A(DCB)\n         MVC   0(C_SYSIN_DCB_Length,R3),C_SYSIN_DCB\n         MVC   @_SYSIN_DCBE,C_SYSIN_DCBE Move SYSIN DCBE\n         LA    R15,@_SYSIN_DCBE       Point to it\n         ST    R15,DCBDCBE-IHADCB(R3) Update address in DCB\n         MVC   @C_OPEN,C_OPEN           Move OPEN parms\n         OPEN  ((3),INPUT),MODE=31,MF=(E,@C_OPEN)\n\n         TM    @_SYSIN_DCBE+DCBEFLG1-DCBE,DCBEMD31 31-bit SAM OK?\n         JO    C00090                 Yes, skip\n\n*---------------------------------------------------------------------*\n*   31-bit SAM is not supported for SYSIN. This typically happens     *\n*  when it is allocated to the terminal in a TSO session (the I/O     *\n*  seems to be OK, but the EOD handling gets in trouble). So ...      *\n*---------------------------------------------------------------------*\n\n*---------------------------------------------------------------------*\n*  ... close the current DCB ...                                      *\n*---------------------------------------------------------------------*\n         MVC   @C_CLOSE,C_CLOSE       Move close parms\n         L     R3,@_SYSIN_DCB_Ptr     Point to the DCB\n         CLOSE ((3)),MODE=31,MF=(E,@C_CLOSE)  and close it\n\n*---------------------------------------------------------------------*\n*  ... move a normal DCB (without the DCBE) to the 24-bit area ...    *\n*---------------------------------------------------------------------*\n         MVC   0(C_SYSIN24_DCB_Length,R3),C_SYSIN24_DCB Move 24-bit DCB\n\n*---------------------------------------------------------------------*\n*  ... move the 24-bit EOD after it ...                               *\n*---------------------------------------------------------------------*\n         LA    R15,C_SYSIN24_DCB_Length(0,R3) Point past DCB\n         LARL  R14,C00760_24_Start        A(24-bit EOD Routine)\n         MVC   0(C00760_24_Length,R15),0(R14) Move 24-bit EOD\n\n*---------------------------------------------------------------------*\n*  ... and update DCBEODAD to point to the 24-bit EOD routine.        *\n*---------------------------------------------------------------------*\n         O     R15,DCBEODAD-IHADCB(R3)    Set up\n         ST    R15,DCBEODAD-IHADCB(R3)     EODAD\n\n*---------------------------------------------------------------------*\n*  Finally, re-OPEN SYSIN.                                            *\n*---------------------------------------------------------------------*\n         MVC   @C_OPEN,C_OPEN           Move OPEN parms\n         L     R3,@_SYSIN_DCB_Ptr       POINT TO THE DCB\n         OPEN  ((3),INPUT),MODE=31,MF=(E,@C_OPEN) AND OPEN IT\n\nC00090   DS    0H\n         L     R1,@_SYSIN_DCB_Ptr       Restore A(DCB)\n\nC00100   DS    0H\n*---------------------------------------------------------------------*\n*  Read SYSIN, if we can ...                                          *\n*---------------------------------------------------------------------*\n         TM    DCBOFLGS-IHADCB(R1),DCBOFOPN Is it open?\n         JNO   C00760                   No, EOF\n\n         GET   (1)                      Go get it\n\n         ST    R1,@C_SYSIN_Rec_Ptr      and save record address\n\n*---------------------------------------------------------------------*\n*  ... ignoring comments and blank lines ...                          *\n*---------------------------------------------------------------------*\n         L     R15,@C_SYSIN_Rec_Ptr     A(SYSIN record)\n         CLI   0(R15),C'*'              Comment?\n         JE    C00080                   Yes, ignore it\n         CLI   0(R15),C' '              No, blank record?\n         JNE   C00110\n         CLC   1(71,R15),0(R15)\n         JE    C00080                   Blank record, ignore it\n\nC00110   DS    0H\n*---------------------------------------------------------------------*\n*  ... and trim leading and trailing spaces.                          *\n*---------------------------------------------------------------------*\n         AHI   R15,71                   A(Last char)\nC00120   DS    0H\n         CLI   0(R15),C' '              Trailing blank?\n         JNE   C00130                   No, skip\n         BRCT  R15,C00120               Yes, check previous\n\nC00130   DS    0H\n         L     R14,@C_SYSIN_Rec_Ptr     A(Start of input)\n         SLR   R15,R14                  Length of record - 1\n         AHI   R15,1                    Actual length\n\nC00130C  DS    0H\n         CLI   0(R14),C' '              Leading space?\n         JNE   C00130E                  No, OK\n         AHI   R14,1                    Yup, point past it\n         BRCT  R15,C00130C              and check again\n         J     C00080                   Blank record(?), ignore it\n\nC00130E  DS    0H\n*---------------------------------------------------------------------*\n*   If the control card starts with our name (the name that a TSO     *\n*  user would use), skip over it.                                     *\n*---------------------------------------------------------------------*\n         LHI   R0,L'C_PgmName           Length of our name\n         CR    R15,R0                   Should we check for our name?\n         JL    C00150                   No, skip\n         CLC   C_PgmName,0(R14)         Yes, our name first?\n         JNE   C00150                   No, OK\n         CR    R15,R0                   Is that all there is?\n         JE    C00140                   Yes, skip\n         CLI   L'C_PgmName(R14),C' '    Yes, ending with a space?\n         JNE   C00150                   No, skip\n         LHI   R0,L'C_PgmName+1         Length of our name and a space\nC00140   DS    0H\n         AR    R14,R0                   Point past our name\n         SR    R15,R0                   and adjust length\nC00150   DS    0H\n         LA    R0,@C_CBUF_Data+L'C_PgmName+1 A(Target area)\n         LR    R1,R15                   Length\n         MVCL  R0,R14                   Move data to cmd buffer\n         LA    R15,@C_CBUF              A(Start of command buffer\n         SR    R0,R15                   Get the length\n         STH   R0,@C_CBUF_Len           Save it\n\n         MVC   @C_CBUF_Data(L'C_PgmName),C_PgmName  Simulate command\n         MVI   @C_CBUF_Data+L'C_PgmName,C' ' Separator\n         LHI   R15,L'C_PgmName+1         Offset to parms\n         STH   R15,@C_CBUF_Off          Update it\n\n         L     R1,@_Bat_CPPL_Ptr        A(Our CPPL)\n         LA    R15,@C_CBUF              A(our command buffer)\n         ST    R15,CPPLCBUF-CPPL(R1)    Update A(Command buffer)\n\nC00160   DS    0H\n*---------------------------------------------------------------------*\n*   Resolve any symbolic variables in the command buffer. Note that   *\n*   we do this before invoking IKJPARS because IKJPARS will get upset *\n*   with substring'ed symbolic variables (which it thinks are lists). *\n*---------------------------------------------------------------------*\n         L     R15,CPPLCBUF-CPPL(R1)    A(Command Buffer)\n         LH    R14,@C_CBUF_Len-@C_CBUF(R15) Get length\n         AR    R14,R15                  Point past end\n         AHI   R15,L'@C_CBUF_Len+L'@C_CBUF_Off Point to start of cmd\n         LA    R0,C'&&'                 Char to search for\nC00160E  DS    0H\n         SRST  R14,R15                  Do we have an amper?\n         JH    C00160Z                  No amper, skip\n         JO    C00160E                  Keep checking\n\n         ST    R1,@C_CPPL_Ptr           Save A(CPPL)\n\n         XC    @C_SYMBP,@C_SYMBP        Clear ASASUMBP area\n         L     R15,CPPLCBUF-CPPL(R1)    A(Command buffer)\n         LH    R14,@C_CBUF_Len-@C_CBUF(R15) Get Cmd buff length\n         AHI   R14,-L'@C_CBUF_Len-L'@C_CBUF_Off minus CBUF fields\n         ST    R14,@C_SYMBP+SYMBPPATTERNLENGTH-SYMBP Save length\n         AHI   R15,L'@C_CBUF_Len+L'@C_CBUF_Off Point to start\n         ST    R15,@C_SYMBP+SYMBPPATTERN@-SYMBP Save A(Command Buff)\n         LA    R15,@C_CBUF1_Data        A(Target Area)\n         ST    R15,@C_SYMBP+SYMBPTARGET@-SYMBP Save A(Target)\n         LA    R15,L'@C_CBUF1_Data      Target Length)\n         ST    R15,@C_SYMBP_Target_Len  Initialize it\n         LA    R15,@C_SYMBP_Target_Len  A(Target Len field)\n         ST    R15,@C_SYMBP+SYMBPTARGETLENGTH@-SYMBP Save A(Length)\n         LA    R15,@C_SYMBP_RC          A(Return code area)\n         ST    R15,@C_SYMBP+SYMBPRETURNCODE@-SYMBP Save A(Return code)\n\n         MVC   @C_LINKX,C_LINKX         Move LINKX Macro\n         LARL  R2,C00160Z               LINK error return address\n         LINKX EP=ASASYMBM,             LINK to ASASYMBM               +\n               ERRET=(2),                go here if LINK error         +\n               MF=(E,@C_SYMBP),          using these parms             +\n               SF=(E,@C_LINKX)           staying re-entrant\n\n         L     R1,@C_CPPL_Ptr           Restore A(CPPL)\n         ICM   R15,B'1111',@C_SYMBP_RC  Get return code\n         JNZ   C00160Z                  Use original Cmd Buffer\n         L     R15,@C_SYMBP_Target_Len  Get new length\n         AHI   R15,L'@C_CBUF_Len+L'@C_CBUF_Off Adjust it\n         STH   R15,@C_CBUF1_Len         Update new cmd buff len\n         L     R15,CPPLCBUF-CPPL(R1)    A(original CBUF)\n         LH    R15,@C_CBUF_Off-@C_CBUF(R15) Original offset\n         STH   R15,@C_CBUF1_Off         Update it\n         LA    R15,@C_CBUF1             Point to our new CBUF\n         ST    R15,CPPLCBUF-CPPL(R1)    and update CPPL\n\nC00160Z  DS    0H\n*---------------------------------------------------------------------*\n*   Invoke IKJPARS to parse our Command Buffer (either the real one   *\n*   or the one we built). Note that if we not running as a TSO        *\n*   command, we turn off prompting during IKJPARS (otherwise, a user  *\n*   at a TSO terminal who CALLed us could get prompted for unknown    *\n*   parms, which is inconsistent).                                    *\n*---------------------------------------------------------------------*\n         MVC   @C_PPL+PPLUPT-PPL(L'PPLUPT),CPPLUPT-CPPL(R1)\n         MVC   @C_PPL+PPLECT-PPL(L'PPLECT),CPPLECT-CPPL(R1)\n         LA    R15,@C_PECB              A(Parse ECB)\n         ST    R15,@C_PPL+PPLECB-PPL    Save it\n         LA    R15,@C_PANS              A(Parse Answer area)\n         ST    R15,@C_PPL+PPLANS-PPL    Save it\n         MVC   @C_PPL+PPLCBUF-PPL(L'PPLCBUF),CPPLCBUF-CPPL(R1)\n         L     R15,=AL4(C_PCL)          A(Parse Control List)\n         ST    R15,@C_PPL+PPLPCL-PPL    Save it\n         LA    R15,0                    Clear work register\n         ST    R15,@C_PPL+PPLUWA-PPL    No User Work Area\n         ST    R15,@C_PECB              Clear ECB\n         ST    R15,@C_PANS               and Answer area\n\n         TM    @_TSO_Command,L'@_TSO_Command Is this a TSO command?\n         JO    C00170                   Yes, skip\n         L     R15,@C_PPL+PPLUPT-PPL    Get A(UPT)\n         MVC   @C_UPTSWS,UPTSWS-UPT(R15) Save current SWS\n         NI    UPTSWS-UPT(R15),X'FF'-UPTNPRM Off Prompt flag\n\nC00170   DS    0H\n         LA    R1,@C_PPL                A(PPL)\n         CALLTSSR EP=IKJPARS            Parse the command line\n\n         TM    @_TSO_Command,L'@_TSO_Command Is this a TSO command?\n         JO    C00180                   Yes, skip\n         L     R14,@C_PPL+PPLUPT-PPL    Get A(UPT)\n         OC    UPTSWS-UPT(L'UPTSWS,R14),@C_UPTSWS Restore UPTSWS\nC00180   DS    0H\n         LTR   R15,R15                  Did PARSE work?\n         JNZ   C00730                   No, skip\n         L     R1,@C_PANS               Yes, get A(PDL)\n\n*---------------------------------------------------------------------*\n*   Process UNIT/XUNIT keyword                                        *\n*---------------------------------------------------------------------*\n         TM    @C_UNIT_Flag,L'@C_UNIT_Flag Have we processed UNIT?\n         JO    C00180E                  Yes, skip\n         OI    @C_UNIT_Flag,L'@C_UNIT_Flag No, we have now\n\n         TM    C_01SFP+6-IKJPARMD(R1),X'80' Was UNIT entered?\n         JZ    C00180E                  No, skip\n         AHI   R1,C_01SFP-IKJPARMD      Yes, point to PDE\n         J     C00180I                  start processing\nC00180E  DS    0H\n         TM    @C_XUNIT_Flag,L'@C_XUNIT_Flag Have we processed XUNIT?\n         JO    C00240                   Yes, skip\n         OI    @C_XUNIT_Flag,L'@C_XUNIT_Flag No, we have now\n\n         TM    C_02SFP+6-IKJPARMD(R1),X'80' Was XUNIT entered?\n         JZ    C00240                   No, skip\n         AHI   R1,C_02SFP-IKJPARMD      Yes, point to PDE\nC00180I  DS    0H\n         LA    R0,0                     Clear unit count\nC00190   DS    0H\n         AHI   R0,1                     Bump unit count\n         ICM   R1,B'0111',9(R1)         A(Next PDE)\n         JNZ   C00190                   Found one, keep checking\n\n         LR    R4,R0                    Save count\n         MHI   R0,UCB_List_Ent_Length   Times len of 1 entry\n         AHI   R0,UCB_List_Hdr_Length     + length of header\n         BASR  R2,0\n         USING (*,C00190_End-1),R2\n         STORAGE OBTAIN,                Go get some storage            +\n               LENGTH=(0),               this long,                    +\n               LOC=31                    above-the-line\nC00190_End DS  0H\n         DROP  R2\n         ST    R0,UCB_List_Hdr_Len-UCB_List(R1) Save Subpool, length\n         ST    R4,UCB_List_Hdr_Count-UCB_List(R1) Save nbr entries\n         LA    R4,UCB_List_Ent-UCB_List(R1) A(1st entry)\n         TM    @C_XUNIT_Flag,L'@C_XUNIT_Flag Is this XUNIT?\n         JO    C00190E                  Yes, skip\n         ST    R1,@_UCB_List_Ptr        Save it\n         L     R1,@C_PANS               Restore A(PDL)\n         LA    R3,C_01SFP-IKJPARMD(R1)  Point to 1st UNIT PDE\n         J     C00200                   and skip\nC00190E  DS    0H\n         ST    R1,@_XUCB_List_Ptr       Save it\n         L     R1,@C_PANS               Restore A(PDL)\n         LA    R3,C_02SFP-IKJPARMD(R1) Point to 1st XUNIT PDE\n         J     C00200                   and skip\nC00200   DS    0H\n         MVC   UCB_List_Ent_UCB-UCB_List_Ent(L'UCB_List_Ent_UCB,R4),=(L+\n               'UCB_List_Ent_UCB)C'*'   Initialize field\n         L     R15,0(0,R3)              A(UNIT field)\n         LH    R14,4(0,R3)              Get its length\n         STC   R14,UCB_List_Ent_UCB_Len-UCB_List_Ent(R4) Save it\n         AHI   R4,UCB_List_Ent_UCB-UCB_List_Ent  Point to UCB Area\n         AHI   R14,-1                   Get EX length\n         EX    R14,C2EX1                Move UCB\n         AHI   R4,-(UCB_List_Ent_UCB-UCB_List_Ent) Back to entry\n         MVC   UCB_List_Ent_Mask-UCB_List_Ent(L'UCB_List_Ent_Mask,R4),U+\n               CB_List_Ent_UCB-UCB_List_Ent(R4)\n         TR    UCB_List_Ent_UCB-UCB_List_Ent(L'UCB_List_Ent_UCB,R4),C_T+\n               rTbl                     Xlate (Wildcards = X'FF'\n         TR    UCB_List_Ent_Mask-UCB_List_Ent(L'UCB_List_Ent_Mask,R4),C+\n               _TrTbl1                  Xlate (Wildcards = X'FF')\n*                                              Non-Wildcards = X'00')\n         AHI   R4,UCB_List_Ent_Length   A(Next entry)\n         ICM   R3,B'0111',9(R3)         A(Next PDE)\n         JNZ   C00200                   Got one, save it\n         J     C00180E                  Process next UNIT-type keywd\n\nC00240   DS    0H\n*---------------------------------------------------------------------*\n*   Process VOLUME/XVOLUME keyword                                    *\n*---------------------------------------------------------------------*\n         TM    @C_VOL_Flag,L'@C_VOL_Flag Have we processed VOL?\n         JO    C00240E                  Yes, skip\n         OI    @C_VOL_Flag,L'@C_Vol_Flag No, we have now\n\n         TM    C_03SFP+6-IKJPARMD(R1),X'80' Was VOL entered?\n         JZ    C00240E                  No, skip\n         AHI   R1,C_03SFP-IKJPARMD      Yes, point to PDE\n         J     C00240I                  start processing\nC00240E  DS    0H\n         TM    @C_XVOL_Flag,L'@C_XVOL_Flag Have we processed XVOL?\n         JO    C00300                   Yes, skip\n         OI    @C_XVOL_Flag,L'@C_XVol_Flag No, we have now\n\n         TM    C_04SFP+6-IKJPARMD(R1),X'80' Was XVOL entered?\n         JZ    C00300                   No, skip\n         AHI   R1,C_04SFP-IKJPARMD      Yes, point to PDE\nC00240I  DS    0H\n         LA    R0,0                     Clear unit count\nC00250   DS    0H\n         AHI   R0,1                     Bump vol count\n         ICM   R1,B'0111',9(R1)         A(Next PDE)\n         JNZ   C00250                   Found one, keep checking\n\n         LR    R4,R0                    Save count\n         MHI   R0,Vol_List_Ent_Length   Times length of 1 entry\n         AHI   R0,Vol_List_Hdr_Length     + length of header\n         BASR  R2,0\n         USING (*,C00250_End-1),R2\n         STORAGE OBTAIN,                Go get some storage            +\n               LENGTH=(0),               this long,                    +\n               LOC=31                    above-the-line\nC00250_End DS  0H\n         DROP  R2\n         ST    R0,Vol_List_Hdr_Len-Vol_List(R1) Save Subpool, length\n         ST    R4,Vol_List_Hdr_Count-Vol_List(R1) Save nbr entries\n         LA    R4,Vol_List_Ent-Vol_List(R1) A(1st entry)\n         TM    @C_XVOL_Flag,L'@C_XVOL_Flag Are we doing XVOL?\n         JO    C00250E                  Yes, skip\n         ST    R1,@_VOL_List_Ptr        Save it\n         L     R1,@C_PANS               Restore A(PDL)\n         LA    R3,C_03SFP-IKJPARMD(R1)  Point to 1st VOL PDE\n         J     C00260                   and skip\nC00250E  DS    0H\n         ST    R1,@_XVOL_List_Ptr       Save it\n         L     R1,@C_PANS               Restore A(PDL)\n         LA    R3,C_04SFP-IKJPARMD(R1)  Point to 1st XVOL PDE\n         J     C00260                   and skip\nC00260   DS    0H\n         MVC   Vol_List_Ent_Vol-Vol_List_Ent(L'Vol_List_Ent_Vol,R4),=(L+\n               'Vol_List_Ent_Vol)C'*'   Initialize field\n         L     R15,0(0,R3)              A(Vol field)\n         LH    R14,4(0,R3)              Get its length\n         AHI   R14,-1                   Get EX length\n         EX    R14,C2EX1                Move Vol\n         MVC   Vol_List_Ent_Mask-Vol_List_Ent(L'Vol_List_Ent_Mask,R4),V+\n               ol_List_Ent_Vol-Vol_List_Ent(R4)\n         TR    Vol_List_Ent_Vol-Vol_List_Ent(L'Vol_List_Ent_Vol,R4),C_T+\n               rTbl                     Xlate (Wildcards = X'FF'\n         TR    Vol_List_Ent_Mask-Vol_List_Ent(L'Vol_List_Ent_Mask,R4),C+\n               _TrTbl1                  Xlate (Wildcards = X'FF')\n*                                              Non-Wildcards = X'00')\n         AHI   R4,Vol_List_Ent_Length   A(Next entry)\n         ICM   R3,B'0111',9(R3)         A(Next PDE)\n         JNZ   C00260                   Got one, save it\n         J     C00240                   Process next VOL-type keyword\n\nC00300   DS    0H\n*---------------------------------------------------------------------*\n*   Process NAME keyword                                              *\n*---------------------------------------------------------------------*\n         TM    C_05SFP+6-IKJPARMD(R1),X'80' Was Name entered?\n         JZ    C00310                   No, skip\n         L     R15,C_05SFP-IKJPARMD(R1)  Yes, point to it\n         LH    R14,C_05SFP+4-IKJPARMD(R1) Get its length\n         AHI   R14,-1                   Get EX length\n         EX    R14,C2EX3                Move Unitname\n\nC00310   DS    0H\n*---------------------------------------------------------------------*\n*   Process ATTRIBUTE keyword                                         *\n*---------------------------------------------------------------------*\n         LH    R15,C_06SFP-IKJPARMD(R1) Get Kwd nbr for ATTR\n         LTR   R15,R15                  Anything?\n         JZ    C00380                   None, skip\n         L     R14,=AL4(C_PCL)          Yes, A(Parse Control List)\n         AH    R14,C_06SF-C_PCL(R14)    A(IKJSUBF entry)\n         AH    R14,2(0,R14)             A(1st IKJNAME entry)\nC00320   DS    0H\n         TM    0(R14),X'60'             Is this an IKJNAME PCE?\n         JNO   C00380                   No, must have reached the end\n         CHI   R15,1                    Is this our entry?\n         JE    C00330                   Yes, check it out\n         AH    R14,2(0,R14)             No, bump to next PCE\n         BRCT  R15,C00320               and check it out\n         J     C00380                   Unknown, ignore it\nC00330   DS    0H\n         CLC   =C'STORAGE',5(R14)       STG?\n         JE    C00340                   Yes, skip\n         CLC   =C'PRIVATE',5(R14)       No, PRIVATE?\n         JE    C00350                   Yes, skip\n         CLC   =C'PUBLIC',5(R14)        No, PUBLIC?\n         JE    C00360                   Yes, skip\n         CLC   =C'SMS',5(R14)           No, SMS?\n         JE    C00370                   Yes, skip\n         J     C00380                   Unknown, ignore it\nC00340   DS    0H\n         OI    @_ATTRStg,L'@_ATTRStg    Set flag\n         J     C00380\nC00350   DS    0H\n         OI    @_ATTRPvt,L'@_ATTRPvt    Set flag\n         J     C00380\nC00360   DS    0H\n         OI    @_ATTRPub,L'@_ATTRPub    Set flag\n         J     C00380\nC00370   DS    0H\n         OI    @_ATTRSMS,L'@_ATTRSMS    Set flag\n         J     C00380\n\nC00380   DS    0H\n*---------------------------------------------------------------------*\n*   Process STORGRP keyword                                           *\n*---------------------------------------------------------------------*\n         TM    C_07SFP+6-IKJPARMD(R1),X'80' Was STORGRP entered?\n         JZ    C00430                   No, skip\n         LA    R0,0                     Yes, clear STORGRP count\n         AHI   R1,C_07SFP-IKJPARMD      and point to PDE\nC00390   DS    0H\n         AHI   R0,1                     Bump STORGRP count\n         ICM   R1,B'0111',9(R1)         A(Next PDE)\n         JNZ   C00390                   Found one, keep checking\n\n         LR    R4,R0                    Save count\n         MHI   R0,STORGRP_List_Ent_Length Times length of 1 entry\n         AHI   R0,STORGRP_List_Hdr_Length  + length of header\n         BASR  R2,0\n         USING (*,C00390_End-1),R2\n         STORAGE OBTAIN,                Go get some storage            +\n               LENGTH=(0),               this long,                    +\n               LOC=31                    above-the-line\nC00390_End DS  0H\n         DROP  R2\n         ST    R1,@_STORGRP_List_Ptr    Save it\n         ST    R0,STORGRP_List_Hdr_Len-STORGRP_List(R1) Save Subp, len\n         ST    R4,STORGRP_List_Hdr_Count-STORGRP_List(R1) Save nbr ents\n         LA    R4,STORGRP_List_Ent-STORGRP_List(R1) A(1st entry)\n         L     R1,@C_PANS               Restore A(PDL)\n         LA    R3,C_07SFP-IKJPARMD(R1) and point to 1st STORGRP PDE\nC00400   DS    0H\n         L     R15,0(0,R3)              A(StorGrp)\n         AH    R15,4(0,R3)              A(Byte past end)\n         AHI   R15,-1                   Point to last byte\n         CLI   0(R15),C'*'              Trailing asterisk?\n         JNE   C00410                   No, skip\n         MVI   STORGRP_List_Ent_STORGRP-STORGRP_List_Ent(R4),C'*'\n         J     C00420\nC00410   DS    0H\n         MVI   STORGRP_List_Ent_STORGRP-STORGRP_List_Ent(R4),X'00'\n         J     C00420\nC00420   DS    0H\n         MVC   STORGRP_List_Ent_STORGRP+1-STORGRP_List_Ent(L'STORGRP_Li+\n               st_Ent_STORGRP-1,R4),STORGRP_List_Ent_STORGRP-STORGRP_Li+\n               st_Ent(R4)\n         L     R15,0(0,R3)              A(StorGrp)\n         LH    R14,4(0,R3)              Get its length\n         AHI   R14,-1                   Get EX length\n         EX    R14,C2EX1                Move StorGrp\n         MVC   STORGRP_List_Ent_Mask-STORGRP_List_Ent(L'STORGRP_List_En+\n               t_Mask,R4),STORGRP_List_Ent_STORGRP-STORGRP_List_Ent(R4)\n         TR    STORGRP_List_Ent_STORGRP-STORGRP_List_Ent(L'STORGRP_List+\n               _Ent_STORGRP,R4),C_TrTbl Xlate Wildcards = X'FF'\n         TR    STORGRP_List_Ent_Mask-STORGRP_List_Ent(L'STORGRP_List_En+\n               t_Mask,R4),C_TrTbl1      Xlate (Wildcards = X'FF'\n*                                              Non-Wildcards = X'00')\n         AHI   R4,STORGRP_List_Ent_Length A(Next entry)\n         ICM   R3,B'0111',9(R3)         A(Next PDE)\n         JNZ   C00400                   Got one, save it\n\nC00430   DS    0H\n*---------------------------------------------------------------------*\n*   Process SORT keyword                                              *\n*---------------------------------------------------------------------*\n         LH    R15,C_09SFP-IKJPARMD(R1) Get Kwd nbr for Sort Field\n         LTR   R15,R15                  Anything?\n         JZ    C00480                   None, skip\n         L     R14,=AL4(C_PCL)          Yes, A(Parse Control List)\n         AH    R14,C_09SF-C_PCL(R14)    A(IKJSUBF entry)\n         AH    R14,2(0,R14)             A(1st IKJNAME entry)\nC00440   DS    0H\n         TM    0(R14),X'60'             Is this an IKJNAME PCE?\n         JNO   C00480                   No, must have reached the end\n         CHI   R15,1                    Is this our entry?\n         JE    C00450                   Yes, check it out\n         AH    R14,2(0,R14)             No, bump to next PCE\n         BRCT  R15,C00440               and check it out\n         J     C00480                   Unknown, ignore it\nC00450   DS    0H\n         IC    R15,4(0,R14)             Get EX length of Keyword\n         EX    R15,C_Save_Sort_Field    Save sort field name\n\n*---------------------------------------------------------------------*\n*   Process DESCENDING keyword                                        *\n*---------------------------------------------------------------------*\n         CLI   C_10K+1-IKJPARMD(R1),2 DESCENDING entered?\n         JNE   C00480                   No, skip\n         MVI   @_Sort_Direction,C'D'    Yes, say so\n\nC00480   DS    0H\n*---------------------------------------------------------------------*\n*   Process MAXTASKS keyword                                          *\n*---------------------------------------------------------------------*\n         TM    C_11SFP+6-IKJPARMD(R1),X'80' Was Maxtasks entered?\n         JZ    C00490                   No, skip\n         L     R15,C_11SFP-IKJPARMD(R1) Yes, point to it\n         L     R15,0(0,R15)             Get the value\n         AIF   (&Max_SubTask_Count LT 1).Max_SubTask_Count_010\n         CHI   R15,&Max_SubTask_Count   Is it > max?\n         JNH   C00480C                  No, OK\n         LHI   R15,&Max_SubTask_Count   Yes, use max\nC00480C  DS    0H\n.Max_SubTask_Count_010 ANOP\n         LTR   R15,R15                  Is it too small?\n         JNP   C00490                   Yes, ignore it\n         STH   R15,@_MaxTasks           Save it\n\nC00490   DS    0H\n*---------------------------------------------------------------------*\n*   Process OUTFILE keyword                                           *\n*---------------------------------------------------------------------*\n         TM    C_20SFP+6-IKJPARMD(R1),X'80' Was OUTFILE entered?\n         JZ    C00550                   No, skip\n         L     R15,C_20SFP-IKJPARMD(R1) Yes, point to it\n         LH    R14,C_20SFP+4-IKJPARMD(R1) Get its length\n         AHI   R14,-1                   Get EX length\n         EX    R14,C2EX4                Move DDName\n\n*---------------------------------------------------------------------*\n*   Process OUTDATA keyword                                           *\n*---------------------------------------------------------------------*\n         LH    R15,C_21SFP-IKJPARMD(R1) Get Kwd nbr for OUTDATA\n         LTR   R15,R15                  Anything?\n         JZ    C00550                   None, skip\n         L     R14,=AL4(C_PCL)          Yes, A(Parse Control List)\n         AH    R14,C_21SF-C_PCL(R14)    A(IKJSUBF entry)\n         AH    R14,2(0,R14)             A(1st IKJNAME entry)\nC00500   DS    0H\n         TM    0(R14),X'60'             Is this an IKJNAME PCE?\n         JNO   C00550                   No, must have reached the end\n         CHI   R15,1                    Is this our entry?\n         JE    C00510                   Yes, check it out\n         AH    R14,2(0,R14)             No, bump to next PCE\n         BRCT  R15,C00500               and check it out\n         J     C00550                   Unknown, ignore it\nC00510   DS    0H\n         CLC   =C'DISPLAY',5(R14)       DISPLAY?\n         JE    C00520                   Yes, skip\n         CLC   =C'CB',5(R14)            No, CB?\n         JE    C00530                   Yes, skip\n         CLC   =C'ALL',5(R14)           No, ALL?\n         JE    C00540                   Yes, skip\n         J     C00550                   Unknown, ignore it\nC00520   DS    0H\n         OI    @_OutData_DISPLAY,L'@_OutData_DISPLAY   Set flag\n         J     C00550\nC00530   DS    0H\n         OI    @_OutData_CB,L'@_OutData_CB   Set flag\n         J     C00550\nC00540   DS    0H\n         OI    @_OutData_ALL,L'@_OutData_ALL   Set flag\n         J     C00550\n\nC00550   DS    0H\n*---------------------------------------------------------------------*\n*   Process NOHEADINGS keyword                                        *\n*---------------------------------------------------------------------*\n         CLI   C_13K+1-IKJPARMD(R1),0   Was NOHEADINGS entered?\n         JE    C00560                   No, skip\n         OI    @_No_Headings,L'@_No_Headings Yes, set flag\n\nC00560   DS    0H\n*---------------------------------------------------------------------*\n*   Process NODETAILS keyword                                         *\n*---------------------------------------------------------------------*\n         CLI   C_14K+1-IKJPARMD(R1),0   Was NODETAILS entered?\n         JE    C00570                   No, skip\n         OI    @_No_Details,L'@_No_Details Yes, set our flag\n\nC00570   DS    0H\n*---------------------------------------------------------------------*\n*   Process NOTOTALS keyword                                          *\n*---------------------------------------------------------------------*\n         CLI   C_15K+1-IKJPARMD(R1),0   Was NOTOTALS entered?\n         JE    C00580                   No, skip\n         OI    @_No_Totals,L'@_No_Totals Yes, set our flag\n\nC00580   DS    0H\n*---------------------------------------------------------------------*\n*   Process STATISTICS keyword                                        *\n*---------------------------------------------------------------------*\n         CLI   C_17K+1-IKJPARMD(R1),0     Was STATISTICS entered?\n         JE    C00590                   No, skip\n         OI    @_Statistics,L'@_Statistics Yes, set our flag\n\nC00590   DS    0H\n*---------------------------------------------------------------------*\n*   Process ISPF keyword                                              *\n*---------------------------------------------------------------------*\n         LH    R15,C_12SFP-IKJPARMD(R1) Get Kwd nbr for ISPF\n         LTR   R15,R15                  Anything?\n         JZ    C00650                   No, skip\n         OI    @_ISPF_Explicit,L'@_ISPF_Explicit Yes, set our flag\n         L     R14,=AL4(C_PCL)          A(Parse Control List)\n         AH    R14,C_12SF-C_PCL(R14)    A(IKJSUBF entry)\n         AH    R14,2(0,R14)             A(1st IKJNAME entry)\nC00600   DS    0H\n         TM    0(R14),X'60'             Is this an IKJNAME PCE?\n         JNO   C00650                   No, must have reached the end\n         CHI   R15,1                    Is this our entry?\n         JE    C00610                   Yes, check it out\n         AH    R14,2(0,R14)             No, bump to next PCE\n         BRCT  R15,C00600               and check it out\n         J     C00650                   Unknown, ignore it\nC00610   DS    0H\n         CLC   =C'EDIF',5(R14)          No, EDIF?\n         JE    C00630                   Yes, skip\n         CLC   =C'BRIF',5(R14)          No, BRIF?\n         JE    C00640                   Yes, skip\n         CLC   =C'SPACE',5(R14)         Table display?\n         JE    C00620                   Yes, skip\n         CLC   =C'NONE',5(R14)          No ISPF?\n         JNE   C00650                   No, ignore it\n         J     C00650                   Unknown, ignore it\nC00620   DS    0H\n         OI    @_ISPF_SPACE,L'@_ISPF_SPACE Yes, set our flag\n         J     C00650\nC00630   DS    0H\n         OI    @_ISPF_EDIF,L'@_ISPF_EDIF EDIF output\n         J     C00650\nC00640   DS    0H\n         OI    @_ISPF_BRIF,L'@_ISPF_BRIF BRIF output\n         J     C00650\n\nC00650   DS    0H\n*---------------------------------------------------------------------*\n*   Check the NOECHO keyword                                          *\n*---------------------------------------------------------------------*\n         CLI   C_16K+1-IKJPARMD(R1),0   Was NOECHO entered?\n         JE    C00660                   No, skip\n         OI    @C_NoEcho,L'@C_NoEcho    Yes, set our flag\n\nC00660   DS    0H\n*---------------------------------------------------------------------*\n*   Process NOLSPACE keyword                                          *\n*---------------------------------------------------------------------*\n         CLI   C_18K+1-IKJPARMD(R1),0   Was NOLSPACE entered?\n         JE    C00665                   No, skip\n         OI    @_No_LSPACE,L'@_No_LSPACE Yes, set flag\n\nC00665   DS    0H\n*---------------------------------------------------------------------*\n*   Process LINESIZE Keyword                                          *\n*---------------------------------------------------------------------*\n         TM    C_22SFP+6-IKJPARMD(R1),X'80' Was LINESIZE entered?\n         JZ    C00665I                  No, skip\n         L     R15,C_22SFP-IKJPARMD(R1) Yes, point to it\n         LH    R14,C_22SFP+4-IKJPARMD(R1) Get its length\n         CHI   R14,3                    Could it be max?\n         JNE   C00665E                  No, skip\n         CLC   =C'MAX',0(R15)           Yes, is it?\n         JNE   C00665E                  No, skip\n         LHI   R0,-1                    Yes, flag it\n         J     C00665G                  and skip\nC00665E  DS    0H\n         CLI   0(R15),C'0'              Numeric?\n         JL    C00665I                  No, ignore it\n         CLI   0(R15),C'9'              Maybe, check again\n         JH    C00665I                  Not numeric, ignore it\n         AHI   R15,1                    Bump pointer\n         BRCT  R14,C00665E              and continue\n\n         L     R15,C_22SFP-IKJPARMD(R1) Point to number\n         LH    R14,C_22SFP+4-IKJPARMD(R1) Get its length\n         AHI   R14,-1                   Get EX length\n         EX    R14,C2EX5                Pack line length\n         CVB   R0,@C_DBLWD              Binarize it\nC00665G  DS    0H\n         STH   R0,@_LineSize            Save it\nC00665I  DS    0H\n\nC00667   DS    0H\n*---------------------------------------------------------------------*\n*   Process MAXLWAIT Keyword                                          *\n*---------------------------------------------------------------------*\n         TM    C_23SFP+6-IKJPARMD(R1),X'80' Was MAXLWAIT entered?\n         JZ    C00667I                  No, skip\n         L     R15,C_23SFP-IKJPARMD(R1) Yes, point to it\n         LH    R14,C_23SFP+4-IKJPARMD(R1) Get its length\n         AHI   R14,-1                   Get EX length\n         EX    R14,C2EX5                Pack line length\n         CVB   R0,@C_DBLWD              Binarize it\n         STH   R0,@_MaxLWait            Save it\nC00667I  DS    0H\n\nC00670   DS    0H\n*---------------------------------------------------------------------*\n*   We have finished with the command buffer, so free up the          *\n*  storage used by IKJPARS                                            *\n*---------------------------------------------------------------------*\n         IKJRLSA @C_PANS                Free IKJPARS storage\n\n         AIF   (NOT &ISPF_by_Default).ISPF_by_Default_010\n*---------------------------------------------------------------------*\n*   We want ISPF displays by default; if the ISPF keyword was         *\n*  not specified, set up our flags as if it were.                     *\n*---------------------------------------------------------------------*\n         TM    @_ISPF_Explicit,L'@_ISPF_Explicit ISPF Keyword there?\n         JO    C00700                   Yes, don't do anything\n\n         AIF   ('&ISPF_Default_Type' EQ '').ISPF_Default_Type_005\n         CLC   =C'SPACE',=C'&ISPF_Default_Type' Default of SPACE?\n         JNE   C00680                   No, skip\n         OI    @_ISPF_SPACE,L'@_ISPF_SPACE Yes, set our flag\n         J     C00700                   and skip\nC00680   DS    0H\n         CLC   =C'EDIF',=C'&ISPF_Default_Type' Default of EDIF?\n         JNE   C00690                   No, skip\n         OI    @_ISPF_EDIF,L'@_ISPF_EDIF Yes, set our flag\n         J     C00700                   and skip\nC00690   DS    0H\n         CLC   =C'BRIF',=C'&ISPF_Default_Type' Default of BRIF?\n         JNE   C00700                   No, unknown\n         OI    @_ISPF_BRIF,L'@_ISPF_BRIF Yes, set our flag\n         J     C00700                   and skip\n.ISPF_Default_Type_005 ANOP\n\nC00700   DS    0H\n.ISPF_by_Default_010 ANOP\n*---------------------------------------------------------------------*\n*   If we are producing headings, put them in the table               *\n*---------------------------------------------------------------------*\n         TM    @_No_Headings,L'@_No_Headings Do we want headings?\n         JO    C00710                   No, skip\n\n         LA    R1,@C_Parms              A(Parm list)\n         BRAS  R14,W00010               Get A(Free entry in VolTbl)\n         LTR   R15,R15                  Did it work?\n         JNZ   C00710                   No, skip headings\n\n         LR    R9,R1                    Get A(Free entry)\n         USING VolTbl_Ent,R9\n\n         OI    VolTbl_Ent_Heading_Line1,L'VolTbl_Ent_Heading_Line1\n         LA    R14,C_Hdg0               A(Heading line)\n         LHI   R15,C_Hdg0_Len           Length of heading\n         O     R15,=XL4'40000000'       Pad char of blank\n         LA    R0,VolTbl_Ent_Display    A(Target)\n         LHI   R1,VolTbl_Ent_Display_Len Length of target\n         MVCL  R0,R14                   Move heading\n         OI    VolTbl_Ent_Processed,L'VolTbl_Ent_Processed Mark as done\n         OI    VolTbl_Ent_ECB,X'40'     POST as complete\n\n         MVC   @C_Time,C_Time           Move L-Form of macro\n         TIME  DEC,                     Get time                       +\n               @C_TIMEArea,              and return it here            +\n               LINKAGE=SYSTEM,           don't use the SVC             +\n               DATETYPE=YYYYMMDD,        format of returned data       +\n               MF=(E,@C_TIME)            addr of macro list\n         L     R0,@C_TIMEArea           Get the time\n         SRL   R0,4                     Shift out hundredths\n         ST    R0,@C_TimeArea           Save it\n         OI    @C_TimeArea+3,X'0F'      OR in a sign\n         MVC   VolTbl_Ent_Display+11(10),=X'402120207A20207A2020'\n         ED    VolTbl_Ent_Display+11(10),@C_TimeArea Edit time\n         L     R15,@C_TimeArea+8        Get Date (yyyymmdd)\n         LA    R14,0                    Clear work register\n         SLDL  R14,4                    Make room for sign\n         STM   R14,R15,@C_TimeArea      Save it\n         OI    @C_TimeArea+7,X'0F'      OR in a sign\n         MVC   VolTbl_Ent_Display(12),=X'402120202020612020612020'\n         ED    VolTbl_Ent_Display(12),@C_TimeArea+3 Edit date\n\n         LA    R1,@C_Parms              A(Parm list)\n         BRAS  R14,W00010               Get A(Free entry in VolTbl)\n         LTR   R15,R15                  Did it work?\n         JNZ   C00710                   No, skip headings\n\n         LR    R9,R1                    Get A(Free entry)\n\n         OI    VolTbl_Ent_Heading_Line,L'VolTbl_Ent_Heading_Line Flag\n         LA    R14,C_Hdg1               A(Heading line)\n         LHI   R15,C_Hdg1_Len           Length of heading\n         O     R15,=XL4'40000000'       Pad char of blank\n         LA    R0,VolTbl_Ent_Display    A(Target)\n         LHI   R1,VolTbl_Ent_Display_Len Length of target\n         MVCL  R0,R14                   Move heading\n         OI    VolTbl_Ent_Processed,L'VolTbl_Ent_Processed Mark as done\n         OI    VolTbl_Ent_ECB,X'40'     POST as complete\n\n         LA    R1,@C_Parms              A(Parm list)\n         BRAS  R14,W00010               Get A(Free entry in VolTbl)\n         LTR   R15,R15                  Did it work?\n         JNZ   C00710                   No, skip headings\n\n         LR    R9,R1                    Get A(Free entry)\n\n         OI    VolTbl_Ent_Heading_Line,L'VolTbl_Ent_Heading_Line Flag\n         LA    R14,C_Hdg2               A(Heading line)\n         LHI   R15,C_Hdg2_Len           Length of heading\n         O     R15,=XL4'40000000'       Pad char of blank\n         LA    R0,VolTbl_Ent_Display    A(Target)\n         LHI   R1,VolTbl_Ent_Display_Len Length of target\n         MVCL  R0,R14                   Move heading\n         OI    VolTbl_Ent_Processed,L'VolTbl_Ent_Processed Mark as done\n         OI    VolTbl_Ent_ECB,X'40'     POST as complete\n\n         LA    R1,@C_Parms              A(Parm list)\n         BRAS  R14,W00010               Get A(Free entry in VolTbl)\n         LTR   R15,R15                  Did it work?\n         JNZ   C00710                   No, skip headings\n\n         LR    R9,R1                    Get A(Free entry)\n\n         OI    VolTbl_Ent_Heading_Line,L'VolTbl_Ent_Heading_Line Flag\n         LA    R14,C_Hdg3               A(Heading line)\n         LHI   R15,C_Hdg3_Len           Length of heading\n         O     R15,=XL4'40000000'       Pad char of blank\n         LA    R0,VolTbl_Ent_Display    A(Target)\n         LHI   R1,VolTbl_Ent_Display_Len Length of target\n         MVCL  R0,R14                   Move heading\n         OI    VolTbl_Ent_Processed,L'VolTbl_Ent_Processed Mark as done\n         OI    VolTbl_Ent_ECB,X'40'     POST as complete\n\nC00710   DS    0H\n*---------------------------------------------------------------------*\n*   If we are running in Batch, and NOECHO was not specified, go      *\n*  print an image of the input record                                 *\n*---------------------------------------------------------------------*\n         TM    @_TSO_Command,L'@_TSO_Command Is this a TSO command?\n         JO    C00720                   Yes, skip\n\n         TM    @C_NoEcho,L'@C_NoEcho    Was NOECHO specified?\n         JNE   C00720                   Yes, skip\n\n         L     R15,@C_SYSIN_Rec_Ptr     A(Our data area)\n         ST    R15,@C_Parms_Y00010      Save it\n         L     R15,@_SYSIN_DCB_Ptr      Point to the DCB\n         LH    R15,DCBLRECL-IHADCB(R15) Get length\n         ST    R15,@C_Parms_Y00010+4    Save it\n\n         LA    R1,@C_Parms              A(Parm list)\n         BRAS  R14,Y00010               Output it to SYSPRINT\n\nC00720   DS    0H\n         LA    R15,0                    Clear return code\n         J     C90010                   and exit\n\nC00730   DS    0H\n         TM    @_TSO_Command,L'@_TSO_Command Is this a TSO command?\n         JZ    C00740                   No, skip\n         LA    R15,4                    PARSE failure\n         J     C90010                    and exit\n\nC00740   DS    0H\n         L     R15,@C_SYSIN_Rec_Ptr     A(Our data area)\n         ST    R15,@C_Parms_Y00010      Save it\n         L     R15,@_SYSIN_DCB_Ptr      Point to the DCB\n         LH    R15,DCBLRECL-IHADCB(R15) Get length\n         ST    R15,@C_Parms_Y00010+4    Save it\n\n         LA    R1,@C_Parms              A(Parm list)\n         BRAS  R14,Y00010               Output to SYSPRINT\n\n         LHI   R15,L'VolTbl_Ent_ErrMsg  Length of 1 message\n         ST    R15,@C_Parms_Y00010+4    Save it for Y00010\n         LA    R4,C_ErrMsgs             Point to 1st err msg\n         LHI   R3,C_ErrMsg_Count        Get the number of messages\nC00750   DS    0H\n         ST    R4,@C_Parms_Y00010       Save A(Error message)\n         LA    R1,@C_Parms              A(Parm list)\n         BRAS  R14,Y00010               Output to SYSPRINT\n         AHI   R4,L'VolTbl_Ent_ErrMsg   A(Next message)\n         BRCT  R3,C00750                and issue it\n\n         J     C00080                   Get another input record\n\n\n*-------------------------------------------------------------------*\n*    The following is the EOD exit when 31-bit SAM is not supported *\n*   for SYSIN. This code is moved to 24-bit storage, and is invoked *\n*   by SYSIN EOD. All it does is branch to our 'real' EOD routine,  *\n*   in 31-bit mode.                                                 *\n*-------------------------------------------------------------------*\n         PUSH  USING                  Save current USINGs\n         DROP  ,                      No USINGs now\n\nC00760_24_Start DS 0H                Start of 24-bit EOD Routine\n         BASR  R15,0                  Load up our base\n         USING *,R15                  Tell the Assembler\n         L     R15,C00760_24_EOD      Get real EODAD\n         BSM   0,R15                  and go do it (in 31-bit mode)\nC00760_24_EOD DC AL4(X'80000000'+C00760) Real EODAD\nC00760_24_Length EQU *-C00760_24_Start Length of 24-bit EOD Routine\n\n         DROP  R15                    Free up our base reg\n         POP   USING                  Restore USING environment\n\n\nC00760   DS    0H\n         TM    @_TSO_Command,L'@_TSO_Command Is this a TSO command?\n         JO    C00780                   Yes, skip\n         ICM   R1,B'1111',@_SYSIN_DCB_Ptr A(SYSIN DCB)\n         JZ    C00780                   None, skip\n         TM    DCBOFLGS-IHADCB(R1),DCBOFOPN Is it open?\n         JNO   C00770                   No, skip\n         MVC   @C_CLOSE,C_CLOSE         Yes, move CLOSE parms\n         LR    R3,R1                    Set up DCB pointer\n         CLOSE ((3)),MODE=31,MF=(E,@C_CLOSE)  and close it\nC00770   DS    0H\n         LHI   R0,C_SYSIN_DCB_Length+C00760_24_Length+7 DCB, 24-bit EOD\n         SRL   R0,3                     DBLWD\n         SLL   R0,3                      multiple\n\n         L     R1,@_SYSIN_DCB_Ptr       A(SYSIN DCB area)\n\n         BASR  R2,0\n         USING (*,C00770_End-1),R2\n         STORAGE RELEASE,               Free the DCB storage           +\n               ADDR=(1),                 starting here                 +\n               LENGTH=(0)                this long\nC00770_End DS  0H\n         DROP  R2\n\n         LA    R15,0                    Clear work register\n         ST    R15,@_SYSIN_DCB_Ptr      No more DCB area\nC00780   DS    0H\n         LA    R15,4                    Set return code\n         J     C90010                    and exit\n\n\nC90010   DS    0H\n*-------------------------------------------------------------------*\n*    Free up our local storage ...                                  *\n*-------------------------------------------------------------------*\n         LR    R3,R15                 Save return code\n\n         LA    R1,@C_Dynam              A(Local storage)\n         L     R2,@C_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         L     R13,4(0,R13)             Rescue A(HSA)\n\n         SSCSTACK POP,                  Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=(R2)                on this stack\n\n         LR    R15,R3                   Restore return code\n\n*-------------------------------------------------------------------*\n*    ... and return to caller                                       *\n*-------------------------------------------------------------------*\n         L     R14,12(0,R13)            Restore return address\n         LM    R0,R12,20(R13)           Restore other registers\n         BSM   0,R14                    and return\n\nC_Literals  DS  0H\n\nC2EX1    MVC   0(0,R4),0(R15)           Move UCB/Volser\nC2EX3    MVC   @_UNITNM(0),0(R15)       Move Unit Name\nC2EX4    MVC   @_OutFile_DDName(0),0(R15) Move OUTFILE DDName\nC2EX5    PACK  @C_DBLWD,0(0,R15)        Pack a number\nC_Save_Sort_Field  MVC   @_Sort_Field(0),5(R14)\n\nC_PgmName  DC  C'&PGMNAME'      Simulated command name\n\n         PUSH  PRINT\n         PRINT NOGEN\n\nC_Time   TIME  LINKAGE=SYSTEM,MF=L\nC_Time_Length EQU *-C_Time\n\nC_OPEN    OPEN  (0,INPUT),MODE=31,MF=L\nC_OPEN_Length EQU *-C_OPEN\n\nC_CLOSE   CLOSE (0),MODE=31,MF=L\nC_CLOSE_Length EQU *-C_CLOSE\n\nC_LINKX   LINKX SF=L\nC_LINKX_Length EQU *-C_LINKX\n         POP   PRINT\n\nC_TrTbl  DC    256AL1(*-C_TrTbl)\n         ORG   C_TrTbl+C'?'\n         DC    X'FF'\n         ORG   C_TrTbl+C'%'\n         DC    X'FF'\n         ORG   C_TrTbl+C'*'\n         DC    X'FF'\n         ORG\n\nC_TrTbl1 DC    256X'00'\n         ORG   C_TrTbl1+C'?'\n         DC    X'FF'\n         ORG   C_TrTbl1+C'%'\n         DC    X'FF'\n         ORG   C_TrTbl1+C'*'\n         DC    X'FF'\n         ORG\n\n         LTORG\n\n         PUSH  PRINT\n         PRINT NOGEN\nC_SYSIN_DCB DCB   DDNAME=SYSIN,DSORG=PS,MACRF=GL,LRECL=80,             +\n               DCBE=C_SYSIN_DCBE\n         DS    0D\nC_SYSIN_DCB_Length EQU *-C_SYSIN_DCB\n\nC_SYSIN_DCBE DCBE RMODE31=BUFF,EODAD=C00760\n         DS    0D\nC_SYSIN_DCBE_Length EQU *-C_SYSIN_DCBE\n\nC_SYSIN24_DCB DCB   DDNAME=SYSIN,DSORG=PS,MACRF=GL,LRECL=80,           +\n               EODAD=0\n         DS    0D\nC_SYSIN24_DCB_Length EQU *-C_SYSIN24_DCB\n         POP   PRINT\n\nC_Hdg0   EQU   *\n         DC    C' yyyy/mm/dd hh:mm:ss   &PGMNAME &VERSION DASD Free Spa+\n               ce Report'\nC_Hdg0_Len EQU *-C_Hdg0\n\nC_Hdg1   EQU   *\n         DC    CL(VolTbl_Ent_FreeSpace_Info-VolTbl_Ent_Display_Start)' +\n               '\nC_Hdg1_1 DC    (VolTbl_Ent_FreeSpace_Info_End-VolTbl_Ent_FreeSpace_Info+\n               )C'-'\n         ORG   C_Hdg1_1+((*-C_Hdg1_1-13)/2)\n         DC    C' Volume Free '\n         ORG   ,\n         DC    CL(VolTbl_Ent_VTOC_Info-VolTbl_Ent_FreeSpace_Info_End)' +\n               '\nC_Hdg1_2 DC    (VolTbl_Ent_VTOC_Info_End-VolTbl_Ent_VTOC_Info)C'-'\n         ORG   C_Hdg1_2+((*-C_Hdg1_2-6)/2)\n         DC    C' VTOC '\n         ORG   ,\n         DC    CL(VolTbl_Ent_SMS_Info-VolTbl_Ent_VTOC_Info_End)' '\nC_Hdg1_3 DC    (VolTbl_Ent_SMS_Info_End-VolTbl_Ent_SMS_Info)C'-'\n         ORG   C_Hdg1_3+((*-C_Hdg1_3-5)/2)\n         DC    C' SMS '\n         ORG   ,\n         DC    CL(VolTbl_Ent_CHPID_Info-VolTbl_Ent_SMS_Info_End)' '\nC_Hdg1_4 DC    (VolTbl_Ent_CHPID_Info_End-VolTbl_Ent_CHPID_Info)C'-'\n         ORG   C_Hdg1_4+((*-C_Hdg1_4-8)/2)\n         DC    C' CHPIDs '\n         ORG   ,\nC_Hdg1_Len EQU *-C_Hdg1\n\nC_Hdg2   EQU   *\n         DC    C'                                                    '\n         DC    C'   Nbr   - Largest -  Frag         Free    % IX'\n         DC    C'   Vol  Storage                                     '\n         DC    C'                '\nC_Hdg2_Len EQU *-C_Hdg2\n\nC_Hdg3   EQU   *\n         DC    C'VOLSER  UCB  DevType   St    Trks  Cyls     %  Bytes'\n         DC    C' Xtnts    Trks  Cyls Index   Trks DSCBs Free St'\n         DC    C'  Size  Group    Status                             '\n         DC    C'                '\nC_Hdg3_Len EQU *-C_Hdg3\n\nC_ErrMsgs EQU  *\n\n         DC    CL(L'VolTbl_Ent_ErrMsg)'*** Unrecognized input - ignored+\n                ***'\n         DC    CL(L'VolTbl_Ent_ErrMsg)' '\n         DC    CL(L'VolTbl_Ent_ErrMsg)'Valid Keywords:'\n         DC    CL(L'VolTbl_Ent_ErrMsg)' UCB(Unit-mask)     specifies th+\n               e selection criterion based on UCB Address.'\n         DC    CL(L'VolTbl_Ent_ErrMsg)' XUCB(Unit-mask)    specifies th+\n               e exclusion criterion based on UCB Address.'\n         DC    CL(L'VolTbl_Ent_ErrMsg)' VOLUME(Volser)     specifies th+\n               e selection criterion based on volser.'\n         DC    CL(L'VolTbl_Ent_ErrMsg)' XVOLUME(Volser)    specifies th+\n               e exclusion criterion based on volser.'\n         DC    CL(L'VolTbl_Ent_ErrMsg)' NAME(Unit-Name)    specifies th+\n               e selection criterion based on generic'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                  or esoteric Un+\n               it name.'\n         DC    CL(L'VolTbl_Ent_ErrMsg)' ATTRIBUTE(STORAGE/STG/PRIVATE/P+\n               VT/PUBLIC/SMS)'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                  specifies the +\n               selection criterion based on mount'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                  attribute. Onl+\n               y one of the keywords can be specified.'\n         DC    CL(L'VolTbl_Ent_ErrMsg)' STORGRP(SMS-Storage_Group_Name)+\n               '\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                  specifies the +\n               selection criterion based on SMS'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                  Storage Group.+\n               '\n         DC    CL(L'VolTbl_Ent_ErrMsg)' SORT(id)         specifies the +\n               order in which the selected DASD volumes'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                  are displayed:+\n               '\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                   id: VOL     -+\n                Volser'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                       UCB     -+\n                UCB Name (Device Address)'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                       DEVT    -+\n                Device Type'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                       ATTR    -+\n                Mount Attribute'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                       FREET   -+\n                Total Free Tracks'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                       FREEC   -+\n                Total Free Cylinders'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                       FREEP   -+\n                % Volume Free'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                       FREEB   -+\n                Total Free Bytes'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                       FREEE   -+\n                # Free Extents'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                       LARGET  -+\n                Largest Free Tracks'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                       LARGEC  -+\n                Largest Free Cylinders'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                       VFREED  -+\n                Free DSCBs in VTOC'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                       VFREEP  -+\n                % VTOC Free'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                       VTRK    -+\n                Tracks allocated to the VTOC'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                       VIX     -+\n                VTOC Index Status'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                       FRAG    -+\n                Fragmentation Index'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                       VOLSIZE -+\n                Volume Capacity'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                       STORGRP -+\n                SMS Storage Group'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                       SMSSTAT -+\n                SMS Volume Status'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                       CHIPDS  -+\n                1st CHPID'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                  By default, th+\n               e display is unsorted, and will'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                  normally appea+\n               r in ascending order of UCB.'\n         DC    CL(L'VolTbl_Ent_ErrMsg)' ASCENDING/DESCENDING specifies +\n               the SORT order. Significant only if'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                  SORT() is spec+\n               ified. Default is ASCENDING'\n         DC    CL(L'VolTbl_Ent_ErrMsg)' MAXTASKS(#)        specifies th+\n               e maximum number of sub-tasks (1-16) to'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                  be ATTACHed to+\n                retrieve volume information.'\n         DC    CL(L'VolTbl_Ent_ErrMsg)' OUTFILE(ddname)  specifies the +\n               DDNAME of an output file to which'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                  volume informa+\n               tion will be written, in addition'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                  to SYSPRINT.'\n         DC    CL(L'VolTbl_Ent_ErrMsg)' OUTDATA(DISPLAY/CB/ALL) specifi+\n               es the type of data to be written to'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                  the OUTFILE DD+\n               NAME:'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                   DISPLAY write+\n               s SYSPRINT data to OUTFILE'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                   CB      wtite+\n               s copies of the UCB, DCE, LSPACE,'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                           and F+\n               4DSCB to OUTFILE'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                   ALL     write+\n               s both CB and DISPLAY (default).'\n         DC    CL(L'VolTbl_Ent_ErrMsg)' NOHEADINGS/NOHDG suppresses hea+\n               dings (and page breaks).'\n         DC    CL(L'VolTbl_Ent_ErrMsg)' NODETAILS        suppresses det+\n               ail (DASD volume) lines.'\n         DC    CL(L'VolTbl_Ent_ErrMsg)' NOTOTALS         suppresses tot+\n               als line.'\n         DC    CL(L'VolTbl_Ent_ErrMsg)' NOECHO           suppresses the+\n                display of the input command.'\n         DC    CL(L'VolTbl_Ent_ErrMsg)' STATISTICS/STATS displays inter+\n               nal processing statistics.'\n         DC    CL(L'VolTbl_Ent_ErrMsg)' ISPF(S/E/B/N)    displays resul+\n               ts using ISPF DM services, if available.'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                   S(pace) uses +\n               customized &PGMNAME displays'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                   E(dif) uses I+\n               SPF Edit services'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                   B(rif) uses I+\n               SPF Browse services.'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                   N(one) uses T+\n               SO line-by-line (PUTLINE) output.'\n         DC    CL(L'VolTbl_Ent_ErrMsg)' NOLSPACE         specifies that+\n                no volume space information is required.'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                  Fields display+\n               ed are: UCB, Volser, DevType, Attr, SMS'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                  data, and CHPI+\n               Ds.'\n         DC    CL(L'VolTbl_Ent_ErrMsg)' LINESIZE(nnn)    specifies the +\n               maximum line length to be displayed'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                  in TSO line-by+\n               line output.'\n         DC    CL(L'VolTbl_Ent_ErrMsg)' MAXLWAIT(nnnn)   specifies the +\n               maximum number of seconds in which'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                  each LSPACE in+\n               vocation must complete. 0 signifies'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                  no limit.'\n\nC_ErrMsg_Count EQU   (*-C_ErrMsgs)/L'VolTbl_Ent_ErrMsg\n\n         PUSH  PRINT\n         PRINT NOGEN\n\nC_PCL    RMODE ANY\nC_PCL    AMODE 31\nC_PCL    IKJPARM\n\nC_01K    IKJKEYWD\n         IKJNAME 'UNIT',                                               +\n               ALIAS='UCB',                                            +\n               SUBFLD=C_01SF\n\nC_02K    IKJKEYWD\n         IKJNAME 'XUNIT',                                              +\n               ALIAS='XUCB',                                           +\n               SUBFLD=C_02SF\n\nC_03K    IKJKEYWD\n         IKJNAME 'VOLUME',                                             +\n               SUBFLD=C_03SF\n\nC_04K    IKJKEYWD\n         IKJNAME 'XVOLUME',                                            +\n               SUBFLD=C_04SF\n\nC_05K    IKJKEYWD\n         IKJNAME 'NAME',                                               +\n               SUBFLD=C_05SF\n\nC_06K    IKJKEYWD\n         IKJNAME 'ATTRIBUTE',                                          +\n               SUBFLD=C_06SF\n\nC_07K    IKJKEYWD\n         IKJNAME 'STORGRP',                                            +\n               ALIAS='SG',                                             +\n               SUBFLD=C_07SF\n\nC_09K    IKJKEYWD\n         IKJNAME 'SORT',                                               +\n               SUBFLD=C_09SF\n\nC_10K    IKJKEYWD\n         IKJNAME 'ASCENDING'\n         IKJNAME 'DESCENDING'\n\nC_11K    IKJKEYWD\n         IKJNAME 'MAXTASKS',                                           +\n               SUBFLD=C_11SF\n\nC_12K    IKJKEYWD\n         IKJNAME 'ISPF',                                               +\n               SUBFLD=C_12SF\n\nC_13K    IKJKEYWD\n         IKJNAME 'NOHEADINGS',                                         +\n               ALIAS='NOHDG'\n\nC_14K    IKJKEYWD\n         IKJNAME 'NODETAILS'\n\nC_15K    IKJKEYWD\n         IKJNAME 'NOTOTALS'\n\nC_16K    IKJKEYWD\n         IKJNAME 'NOECHO'\n\nC_17K    IKJKEYWD\n         IKJNAME 'STATISTICS',                                         +\n               ALIAS='STATS'\n\nC_18K    IKJKEYWD\n         IKJNAME 'NOLSPACE'\n\nC_20K    IKJKEYWD\n         IKJNAME 'OUTFILE',                                            +\n               ALIAS=('OFILE','OUTDDNAME'),                            +\n               SUBFLD=C_20SF\n\nC_21K    IKJKEYWD\n         IKJNAME 'OUTDATA',                                            +\n               SUBFLD=C_21SF\n\nC_22K    IKJKEYWD\n         IKJNAME 'LINESIZE',                                           +\n               SUBFLD=C_22SF\n\nC_23K    IKJKEYWD\n         IKJNAME 'MAXLWAIT',                                           +\n               SUBFLD=C_23SF\n\n\n\nC_01SF   IKJSUBF\nC_01SFP  IKJIDENT 'UCB Mask(s) to be selected',                        +\n               LIST,                                                   +\n               MAXLNTH=4,                                              +\n               FIRST=ANY,                                              +\n               OTHER=ANY\n\nC_02SF IKJSUBF\nC_02SFP   IKJIDENT 'UCB Mask(s) to be excluded',                       +\n               LIST,                                                   +\n               MAXLNTH=4,                                              +\n               FIRST=ANY,                                              +\n               OTHER=ANY\n\nC_03SF   IKJSUBF\nC_03SFP  IKJIDENT 'Volser mask(s) to be selected',                     +\n               LIST,                                                   +\n               MAXLNTH=6,                                              +\n               FIRST=ANY,                                              +\n               OTHER=ANY\n\nC_04SF    IKJSUBF\nC_04SFP   IKJIDENT 'Volser mask(s) to be excluded',                    +\n               LIST,                                                   +\n               MAXLNTH=6,                                              +\n               FIRST=ANY,                                              +\n               OTHER=ANY\n\nC_05SF   IKJSUBF\nC_05SFP  IKJIDENT 'Unit Name to be selected',                          +\n               MAXLNTH=8,                                              +\n               FIRST=ANY,                                              +\n               OTHER=ANY\n\nC_06SF   IKJSUBF\nC_06SFP  IKJKEYWD\n         IKJNAME 'STORAGE',                                            +\n               ALIAS='STG'\n         IKJNAME 'PRIVATE',                                            +\n               ALIAS='PVT'\n         IKJNAME 'PUBLIC'\n         IKJNAME 'SMS'\n\nC_07SF    IKJSUBF\nC_07SFP   IKJIDENT 'SMS Storage Group Name(s)',                        +\n               LIST,                                                   +\n               MAXLNTH=30,                                             +\n               FIRST=ANY,                                              +\n               OTHER=ANY\n\nC_09SF   IKJSUBF\nC_09SFP  IKJKEYWD\n         IKJNAME 'VOL'\n         IKJNAME 'UCB'\n         IKJNAME 'DEVT'\n         IKJNAME 'ATTR'\n         IKJNAME 'FREET'\n         IKJNAME 'FREEC'\n         IKJNAME 'FREEP'\n         IKJNAME 'FREEB'\n         IKJNAME 'FREEE'\n         IKJNAME 'LARGET'\n         IKJNAME 'LARGEC'\n         IKJNAME 'VFREED'\n         IKJNAME 'VFREEP'\n         IKJNAME 'VTRK'\n         IKJNAME 'VIX'\n         IKJNAME 'FRAG'\n         IKJNAME 'VOLSIZE'\n         IKJNAME 'STORGRP'\n         IKJNAME 'SMSSTAT'\n         IKJNAME 'CHPIDS'\n\nC_11SF   IKJSUBF\nC_11SFP  IKJIDENT 'Maximum number of Sub-Tasks',                       +\n               MAXLNTH=2,                                              +\n               INTEG\n\nC_12SF IKJSUBF\n         AIF   ('&ISPF_Default_Type' EQ '').ISPF_Default_Type_010\nC_12SFP  IKJKEYWD DEFAULT='&ISPF_Default_Type'\n         AGO   .ISPF_Default_Type_020\n.ISPF_Default_Type_010 ANOP\nC_12SFP  IKJKEYWD\n.ISPF_Default_Type_020 ANOP\n         IKJNAME 'EDIF'\n         IKJNAME 'BRIF'\n         IKJNAME 'SPACE'\n         IKJNAME 'NONE'\n\n\nC_20SF   IKJSUBF\nC_20SFP  IKJIDENT 'DDNAME of output file',                             +\n               MAXLNTH=8,                                              +\n               FIRST=ALPHA,                                            +\n               OTHER=ANY\n\nC_21SF IKJSUBF\nC_21SFP  IKJKEYWD DEFAULT='ALL'\n         IKJNAME 'DISPLAY'\n         IKJNAME 'CB'\n         IKJNAME 'ALL'\n\nC_22SF   IKJSUBF\nC_22SFP  IKJIDENT 'Max length of data to be displayed',                +\n               MAXLNTH=3,                                              +\n               FIRST=ANY,                                              +\n               OTHER=ANY\n\nC_23SF   IKJSUBF\nC_23SFP  IKJIDENT 'Nbr seconds for LSPACE completion',                 +\n               MAXLNTH=4,                                              +\n               FIRST=NUMERIC,                                          +\n               OTHER=NUMERIC\n\n         IKJENDP\n\n         POP   PRINT\n\nC_Literals_End  DS  0H\n\n\n@C_Dynam                  DSECT       Dynamic area for C00000\n                          DS    18F    O/S Style save area\n@C_31Bit_Stack_Ptr_Ptr    DS    AL4    A(31-bit Stack Ptr)\n@C_24Bit_Stack_Ptr_Ptr    DS    AL4    A(24-bit Stack Ptr)\n@C_DBLWD                  DS    D      Workarea\n@C_PPL                    DS    CL(PPL_Length) PPL area\n@C_PECB                   DS    F      ECB for PARSE\n@C_PANS                   DS    A      PARSE answer area\n@C_SYSIN_Rec_Ptr          DS    AL4    SYSIN Record Pointer\n@C_CPPL_Ptr               DS    AL4    A(CPPL)\n@C_CBUF                   EQU   *      Batch Command buffer\n@C_CBUF_Len               DS    HL2     Length\n@C_CBUF_Off               DS    HL2     Offset to operands\n@C_CBUF_Data              DS    CL255   Data\n@C_CBUF1                  EQU   *      Cbuf after ASASYMBM\n@C_CBUF1_Len              DS    HL2     Length\n@C_CBUF1_Off              DS    HL2     Offset to operands\n@C_CBUF1_Data             DS    CL255   Data\n                          DS    X      Flag byte\n@C_NoEcho                 EQU   *-1,X'80' 1... .... NOECHO specified\n@C_UNIT_Flag              EQU   *-1,X'40' .1.. .... UNIT processed\n@C_XUNIT_Flag             EQU   *-1,X'20' ..1. .... XUNIT processed\n@C_VOL_Flag               EQU   *-1,X'10' ...1 .... VOL processed\n@C_XVOL_Flag              EQU   *-1,X'08' .... 1... XVOL processed\n@C_UPTSWS                 DS    XL(L'UPTSWS) UPTSWS Save\n\n                          DS    0F\n@C_Macros                 EQU   *\n@C_OPEN                   DS    CL(C_OPEN_Length)  OPEN parms\n                          ORG   @C_Macros\n@C_CLOSE                  DS    CL(C_CLOSE_Length) Close Parms\n                          ORG   @C_Macros\n@C_Time                   DS    CL(C_Time_Length)  L-Form of Time\n                          DS    0D                 Alignment\n@C_TimeArea               DS    CL16               Return area for Time\n                          ORG   @C_Macros\n@C_LINKX                  DS    CL(C_LINKX_Length) LINKX Macro\n@C_SYMBP                  DS    CL(SYMBP_LEN)      ASASYMBM Parm area\n@C_SYMBP_Target_Len       DS    FL4             ASASYMBM Target Length\n@C_SYMBP_RC               DS    FL4             ASASYMBM Return code\n                          ORG   ,\n@C_Parms                  DS    0F     Parms for called rtns\n@C_Parms_Std              DS    3AL4    Standard 3 parms\n@C_Parms_Extra            EQU   *       Extra parms\n@C_Parms_Y00010           DS    2AL4       for Y00010\n                          ORG   ,\n                          DS    0D     Alignment\n@C_Dynam_Length           EQU   *-@C_Dynam  Length of storage\n\n&PGMNAME CSECT\n\n         DROP  ,\n         POP   USING\n\n         TITLE 'D00010: Get Eligible UCBs'\n\n         PUSH  USING\n\nD00010   DS    0H\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Routine   : D00010                                                 *\n*                                                                     *\n*  Abstract  : Populate Volume Table with eligible UCBs.              *\n*                                                                     *\n*  Inputs    : R1 : ---> A(@_Dynam)                                   *\n*                        A(31-bit Stack Pointer)                      *\n*                        A(24-bit Stack Pointer)                      *\n*  Outputs   : R15: 0 - OK, @_VolTbl_Ptr contains A(Volume Table)     *\n*                   4 - No UCBs found/Insufficient Storage            *\n*                                                                     *\n*  Notes     : @_VOL_List_Ptr contains A(Volume masks)                *\n*              @_XVOL_List_Ptr contains A(Xolume masks)               *\n*              @_UCB_List_Ptr contains A(UCB masks)                   *\n*              @_XUCB_List_Ptr contains A(XUCB masks)                 *\n*              @_UNITNM contains the Esoteric Unit Name               *\n*              @_ATTR??? contains the Mount Attribute flags           *\n*              @_STORGRP_List_Ptr contains A(StorGrp masks)           *\n*                                                                     *\n*  History:    1990/06/11 SDDA030 - New                               *\n*              1994/05/24 SDDA030 - Used SSCUCBS to get list of UCBs  *\n*                                 - Added creation of dummy total line*\n*              1996/03/13 SDDA030 - Used UCBCHAN rather than UCBNAME  *\n*                                   to get readable device address    *\n*                                   (VolTbl_Ent_DevAddr)              *\n*                                 - Use our own UCB look-up routines  *\n*                                   rather than SSCUCBS               *\n*              1998/09/17 SDDA030 - V2.0                              *\n*                                 - Removed APF checks, and undoc-    *\n*                                   umented UCB search method.        *\n*                                 - Use UCBSCAN with DCEAREA to get   *\n*                                   DCE info.                         *\n*              1998/09/22 SDDA030 - V2.1                              *\n*                                 - Made sure there was always room   *\n*                                   in the Volume Table for the Totals*\n*                                   Line, if required.                *\n*                                 - Added '%' as a single-character   *\n*                                   wild-card match (like '?') in     *\n*                                   UCB and Volser.                   *\n*                                 - Added repetitive search if select-*\n*                                   ing by UCB address when the user  *\n*                                   entered a potential 3-byte UCB    *\n*                                   address mask, and we found no UCBs*\n*                                   because we were using it as a     *\n*                                   4-byte UCB address mask.          *\n*                                 - Added DEVN to UCBSCAN             *\n*                                 - Invoke UCBSCAN with VOLSER= if    *\n*                                   we are checking for a specific    *\n*                                   Volser                            *\n*                                 - Broke out Subtask Management code *\n*                                   into a separate routine (E00010). *\n*              1999/08/20 SDDA030 - V2.8                              *\n*                                 - Used Routine W00010 to manage     *\n*                                   VolTbl entries.                   *\n*              2001/02/26 SDDA030 - V2.14                             *\n*                                 - Added SMS Storage Group and CHPID *\n*                                   info.                             *\n*                                 - Used only DCEOBRDT to determine   *\n*                                   Device Type.                      *\n*                                 - Added 'N/A' in SMS fields for     *\n*                                   non-SMS volumes.                  *\n*              2001/11/12 SDDA030 - V2.15                             *\n*                                 - Added XUCB, XVOL processing       *\n*                                 - Added RANGE=ALL, DYNAMIC=YES,     *\n*                                   LOC=ANY to EDTINFO                *\n*              2002/03/11 SDDA030 - V2.17                             *\n*                                 - Added STORGRP selection logic     *\n*                                 - Moved SMS IEFSSREQ stuff to T00010*\n*                                 - Added indicators for CHPIDs not   *\n*                                   phys or log available.            *\n*              2002/06/11 SDDA030 - V2.18                             *\n*                                 - Formatted as much of total line as*\n*                                   possible.                         *\n*                                 - 'POST' entries as complete if we  *\n*                                   will not be LSPACEing.            *\n*              2002/08/08 SDDA030 - V2.19                             *\n*                                 - Merged code from U0010 into this  *\n*                                   section                           *\n*                                 - Corrected increment when stepping *\n*                                   through @_STORGRP_List            *\n*              2003/10/07 SDDA030 - V2.21                             *\n*                                 - Fixed S0C4 when adjusting UCB pat-*\n*                                   terns when no UCBs found when sel-*\n*                                   ecting by UCB.                    *\n*                                 - Limited re-searching based on len *\n*                                   of entered UCB mask(s)            *\n*              2005/01/20 SDDA030 - V2.23                             *\n*                                 - Used CSRSI, if possible, to get   *\n*                                   CPU info.                         *\n*              2006/04/21 SDDA030 - V2.24                             *\n*                                 - Added .e display                  *\n*                                 - Init CHPIDs to '--'               *\n*                                 - Used standardised calling sequence*\n*                                 - Coped with insufficient storage   *\n*                                   for the volume table.             *\n*                                 - Used UCBTBYT4 to find device type *\n*                                   for emulated devices.             *\n*              ____/__/__ _______ -                                   *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         STM   R14,R12,12(R13)          Save callers registers\n         LARL  R11,D_Literals           Point to our literals\n         USING (D_Literals,D_Literals_End),R11 Tell the assembler\n\n         L     R12,0(0,R1)              A(@_Dynam)\n         USING @_Dynam,R12              Tell the assembler\n\n*-------------------------------------------------------------------*\n*    Get an area on the stack for our local storage                 *\n*-------------------------------------------------------------------*\n         L     R2,4(0,R1)               A(31-bit stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         SSCSTACK PUSH,                 Get stack area                 +\n               LEN=@D_Dynam_Length,      this long                     +\n               STACK=(R2)                using this stack\n\n         LR    R3,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LHI   R1,@D_Dynam_Length        Its length\n         LA    R14,0                    Clear source address\n         LA    R15,0                     and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R3                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*-------------------------------------------------------------------*\n         ST    R13,4(0,R1)              Chain\n         ST    R1,8(0,R13)               saveareas\n         LR    R13,R1                   Load dynam base\n         USING @D_Dynam,R13             Assign a base\n         L     R15,@D_Dynam+4           Get A(HSA)\n         LM    R0,R3,20(R15)            Restore callers registers\n\n         L     R15,4(0,R1)              A(31-bit Stack)\n         ST    R15,@D_31Bit_Stack_Ptr_Ptr Save it\n         L     R15,8(0,R1)              A(24-bit Stack)\n         ST    R15,@D_24Bit_Stack_Ptr_Ptr Save it\n\nD00020   DS    0H\n*-------------------------------------------------------------------*\n*    Reset our flags and counters                                   *\n*-------------------------------------------------------------------*\n         NI    @D_Eligible_UCB_Found,X'FF'-L'@D_Eligible_UCB_Found\n         NI    @D_CHPID_Unavail,X'FF'-L'@D_CHPID_Unavail CHPIDs OK\n         LA    R15,0                    Clear\n         ST    R15,@D_Volume_Count       nbr vols found\n\n*--------------------------------------------------------------------*\n*   Initialize our standard parmlist                                 *\n*--------------------------------------------------------------------*\n         LA    R15,@_Dynam              A(Dynamic area)\n         ST    R15,@D_Parms_Std         Save it\n         L     R15,@D_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)\n         ST    R15,@D_Parms_Std+4       Save it\n         L     R15,@D_24Bit_Stack_Ptr_Ptr A(24-bit Stack Pointer)\n         ST    R15,@D_Parms_Std+8       Save it\n\n*---------------------------------------------------------------------*\n*     If we are selecting by name, go get UCBs associated with the    *\n*    name                                                             *\n*---------------------------------------------------------------------*\n         LA    R15,0                    Clear\n         ST    R15,@D_UNITA              A(Unit Table)\n\n         CLI   @_UNITNM,C' '            Selecting by unit name?\n         JE    D00030                   No, skip\n         LHI   R0,128                   Yes, get table\n         SLL   R0,8                      size of 32K\n         BASR  R2,0\n         USING (*,D00020_End-1),R2\n         STORAGE OBTAIN,                Go get storage                 +\n               LENGTH=(0),               this long                     +\n               LOC=31                    above-the-line\nD00020_End DS  0H\n         DROP  R2\n         ST    R1,@D_UNITA              Save it\n         ST    R0,0(0,R1)               Save table length\n         LA    R15,0                    Clear nbr entries\n         ST    R15,4(0,R1)              Update table\n         MVI   @D_IOCT,0                Clear IOCP Token field\n         MVC   @D_IOCT+1(L'@D_IOCT-1),@D_IOCT\n         EDTINFO RTNDEVN,               Get UCB numbers                +\n               UNITNAME=@_UNITNM,        for this esoteric             +\n               DEVNLIST=@D_UNITA,        save them here                +\n               DYNAMIC=YES,              get dynamic devices           +\n               RANGE=ALL,                3- and 4-digit UCBs           +\n               LOC=ANY,                  no matter where they live     +\n               IOCTOKEN=@D_IOCT,         use dummy IOC Token           +\n               MF=(E,@D_EDTINFO)         staying reentrant\n         LTR   R15,R15                  Did it work?\n         JNZ   D00490                   No, exit\n\nD00030   DS    0H\n*---------------------------------------------------------------------*\n*   We now go and get UCBs (in fact, we get UCB copys), and the       *\n*  associated Device Class Extensions (DCEs) using UCBSCAN.           *\n*  First, however, we have to get the I/O Config token.               *\n*---------------------------------------------------------------------*\n         IOCINFO IOCTOKEN=@D_IOCT,      Get I/O Config token           +\n               MF=(E,@D_IOCINFO)\n\nD00040   DS    0H\n*---------------------------------------------------------------------*\n*   Initialize the UCBSCAN workarea ...                               *\n*---------------------------------------------------------------------*\n         XC    @D_UCBSCAN_WorkArea,@D_UCBSCAN_WorkArea Clear workarea\n\n*---------------------------------------------------------------------*\n*   If we have been invoked for a single Volser (ie, one with no      *\n*  wildcards), we invoke UCBSCAN with the VOLSER parameter, and set   *\n*  a flag indicating that we want to be invoked once only             *\n*---------------------------------------------------------------------*\n         NI    @D_Single_Volser,X'FF'-L'@D_Single_Volser Off our flag\n         ICM   R1,B'1111',@_Vol_List_Ptr A(Volser list)\n         JZ    D00050                   None, skip\n         L     R0,Vol_List_Hdr_Count-Vol_List_Hdr(R1) Get count\n         CHI   R0,1                     A single volser?\n         JNE   D00050                   No, skip\n         CLI   Vol_List_Ent_Mask-Vol_List_Hdr(R1),X'00' With\n         JNE   D00050                    no wildcards?\n         CLC   Vol_List_Ent_Mask+1-Vol_List_Hdr(L'Vol_List_Ent_Mask-1,R+\n               1),Vol_List_Ent_Mask-Vol_List_Hdr(R1)\n         JNE   D00050                   Wildcards, skip\n\n         OI    @D_Single_Volser,L'@D_Single_Volser Only 1 Volser\n         LA    R3,Vol_List_Ent_Vol-Vol_List_Hdr(R1) Point to it\n\n         LHI   R15,L'@D_DCE             Length of DCE area\n         STH   R15,@D_DCE_Length        Save it\n\n         UCBSCAN COPY,                  Get a copy of a UCB            +\n               UCBAREA=@D_UCB,           here                          +\n               DCEAREA=@D_DCE,           copy DCE as well              +\n               DCELEN=@D_DCE_Length,     copy this much                +\n               DYNAMIC=YES,              include HCD devices           +\n               NONBASE=NO,               only 1 UCB per device         +\n               DEVCLASS=DASD,            this device type only         +\n               RANGE=ALL,                3- and 4-byte UCB addresses   +\n               VOLSER=(3),               find this volume              +\n               IOCTOKEN=@D_IOCT,         This I/O Config               +\n               WORKAREA=@D_UCBSCAN_WorkArea, use this workarea         +\n               MF=(E,@D_UCBSCAN)         and stay re-entrant\n\n         LTR   R15,R15                  Did we get one?\n         JZ    D00060                   Yes, skip\n         CHI   R15,12                   No, I/O config changed?\n         JE    D00020                   Yes, start again\n         J     D00490                   End of UCBs, skip\n\nD00050   DS    0H\n*---------------------------------------------------------------------*\n*     Get the next UCB                                                *\n*---------------------------------------------------------------------*\n         LHI   R15,L'@D_DCE             Length of DCE area\n         STH   R15,@D_DCE_Length        Save it\n\n         UCBSCAN COPY,                  Get a copy of a UCB            +\n               UCBAREA=@D_UCB,           here                          +\n               DCEAREA=@D_DCE,           copy DCE as well              +\n               DCELEN=@D_DCE_Length,     copy this much                +\n               DYNAMIC=YES,              include HCD devices           +\n               NONBASE=NO,               only 1 UCB per device         +\n               DEVCLASS=DASD,            this device type only         +\n               RANGE=ALL,                3- and 4-byte UCB addresses   +\n               IOCTOKEN=@D_IOCT,         This I/O Config               +\n               WORKAREA=@D_UCBSCAN_WorkArea, use this workarea         +\n               MF=(E,@D_UCBSCAN)         and stay re-entrant\n\n         LTR   R15,R15                  Did we get one?\n         JZ    D00060                   Yes, skip\n         LA    R0,12                    No, RC if I/O config changed\n         CR    R0,R15                   Is that what happened?\n         JE    D00020                   Yes, start again\n         J     D00490                   No, end of UCBs, skip\n\nD00060   DS    0H\n         NI    @D_SMS_Ptrs_OK,X'FF'-L'@D_SMS_Ptrs_OK No SMS data yet\n\n*---------------------------------------------------------------------*\n*     We have a UCB address, so check it out. First, it must be       *\n*    ONLINE ...                                                       *\n*---------------------------------------------------------------------*\n         TM    @D_UCB+UCBSTAT-UCBOB,UCBONLI Online?\n         JNO   D00480                   No, go get next UCB\n\n*---------------------------------------------------------------------*\n*     ... and then match our UNIT address, if applicable ...          *\n*---------------------------------------------------------------------*\n         MVO   @D_DBLWD+5(3),@D_UCB+UCBCHAN-UCBOB(L'UCBCHAN)\n         OI    @D_DBLWD+7,X'0F'         Add a sign\n         UNPK  @D_DBLWD(5),@D_DBLWD+5(3) Unpack it\n         TR    @D_DBLWD+1(4),D_TRTAB     Make it readable\n         MVC   @D_UCBNAME,@D_DBLWD+1    Save it\n\n         ICM   R1,B'1111',@_UCB_List_Ptr A(UCB List)\n         JZ    D00080                   None, skip\n         L     R3,UCB_List_Hdr_Count-UCB_List_Hdr(R1) Get nbr entries\n         AHI   R1,UCB_List_Ent-UCB_List   and point to 1st\nD00070   DS    0H\n         MVC   @D_DBLWD(L'@D_UCBName),@D_UCBName Move UCB to temp area\n         OC    @D_DBLWD(L'@D_UCBName),UCB_List_Ent_Mask-UCB_List_Ent(R1+\n               )                        Wildcard positions = x'FF'\n         CLC   @D_DBLWD(L'@D_UCBName),UCB_List_Ent_UCB-UCB_List_Ent(R1)\n         JE    D00080                   We want it, skip\n         AHI   R1,UCB_List_Ent_Length   Bump to next entry\n         BRCT  R3,D00070                and try again\n         J     D00480                   Not here, skip this UCB\nD00080   DS    0H\n         OI    @D_Eligible_UCB_Found,L'@D_Eligible_UCB_Found\n         ICM   R1,B'1111',@_XUCB_List_Ptr A(XUCB List)\n         JZ    D00100                   None, skip\n         L     R3,UCB_List_Hdr_Count-UCB_List_Hdr(R1) Get nbr entries\n         AHI   R1,UCB_List_Ent-UCB_List     and point to 1st\nD00090   DS    0H\n         MVC   @D_DBLWD(L'@D_UCBName),@D_UCBName Move UCB to temp area\n         OC    @D_DBLWD(L'@D_UCBName),UCB_List_Ent_Mask-UCB_List_Ent(R1+\n               )                        Wildcard positions = x'FF'\n         CLC   @D_DBLWD(L'@D_UCBName),UCB_List_Ent_UCB-UCB_List_Ent(R1)\n         JE    D00480                   Exclude it, skip\n         AHI   R1,UCB_List_Ent_Length   Bump to next entry\n         BRCT  R3,D00090                and try again\n\nD00100   DS    0H\n*---------------------------------------------------------------------*\n*     ... and our VOLSER criteria, if applicable ...                  *\n*---------------------------------------------------------------------*\n         ICM   R1,B'1111',@_VOL_List_Ptr A(VOL List)\n         JZ    D00130                   None, skip\n         L     R3,Vol_List_Hdr_Count-Vol_List_Hdr(R1) Get nbr entries\n         AHI   R1,Vol_List_Ent-Vol_List     and point to 1st\nD00120   DS    0H\n         MVC   @D_DBLWD(L'UCBVOLI),@D_UCB+UCBVOLI-UCBOB Move Volser\n         OC    @D_DBLWD(L'UCBVOLI),Vol_List_Ent_Mask-Vol_List_Ent(R1)\n         CLC   @D_DBLWD(L'UCBVOLI),Vol_List_Ent_Vol-Vol_List_Ent(R1)\n         JE    D00130                   We want it, skip\n         AHI   R1,Vol_List_Ent_Length   Bump to next entry\n         BRCT  R3,D00120                and try again\n         J     D00480                   Not here, skip this UCB\nD00130   DS    0H\n         ICM   R1,B'1111',@_XVOL_List_Ptr A(XVOL List)\n         JZ    D00150                   None, skip\n         L     R3,Vol_List_Hdr_Count-Vol_List_Hdr(R1) Get nbr entries\n         AHI   R1,Vol_List_Ent-Vol_List     and point to 1st\nD00140   DS    0H\n         MVC   @D_DBLWD(L'UCBVOLI),@D_UCB+UCBVOLI-UCBOB Move Volser\n         OC    @D_DBLWD(L'UCBVOLI),Vol_List_Ent_Mask-Vol_List_Ent(R1)\n         CLC   @D_DBLWD(L'UCBVOLI),Vol_List_Ent_Vol-Vol_List_Ent(R1)\n         JE    D00480                   Exclude it, skip\n         AHI   R1,Vol_List_Ent_Length   Bump to next entry\n         BRCT  R3,D00140                and try again\n\nD00150   DS    0H\n*---------------------------------------------------------------------*\n*     ... our esoteric name criteria, if applicable ...               *\n*---------------------------------------------------------------------*\n         ICM   R14,B'1111',@D_UNITA     Get A(Unit Table)\n         JZ    D00170                   None, skip\n         ICM   R15,B'1111',4(R14)       Get nbr devices\n         JZ    D00480                   None, skip this UCB\n         AHI   R14,8                    Yes, point to first\n\nD00160   DS    0H\n         CLC   @D_DBLWD+1(4),0(R14)     Is this us?\n         JE    D00170                   Yes, use it\n         AHI   R14,4                    No, point to next in Unit Tbl\n         BRCT  R15,D00160               and check it\n         J     D00480                   Skip this UCB\n\nD00170   DS    0H\n*---------------------------------------------------------------------*\n*     ... and our Mount Attributes, if applicable ...                 *\n*---------------------------------------------------------------------*\n         TM    @_ATTRSMS,L'@_ATTRSMS    Selecting SMS vols?\n         JZ    D00180                   No, skip\n         TM    @D_UCB+UCBFL5-UCBOB,UCBSMS SMS?\n         JZ    D00480                   No, skip\n         J     D00210                   OK, use this vol\nD00180   DS    0H\n         TM    @_ATTRPvt,L'@_ATTRPvt    Selecting PRIVATE vols?\n         JZ    D00190                   No, skip\n         TM    @D_UCB+UCBSTAB-UCBOB,UCBBPRV PRIVATE?\n         JZ    D00480                   No, skip\n         TM    @D_UCB+UCBFL5-UCBOB,UCBSMS SMS?\n         JO    D00480                   Yes, skip\n         J     D00210                   OK, use this vol\nD00190   DS    0H\n         TM    @_ATTRPub,L'@_ATTRPub    Selecting PUBLIC vols?\n         JZ    D00200                   No, skip\n         TM    @D_UCB+UCBSTAB-UCBOB,UCBBPUB PUBLIC?\n         JZ    D00480                   No, skip\n         TM    @D_UCB+UCBFL5-UCBOB,UCBSMS SMS?\n         JO    D00480                   Yes, skip\n         J     D00210                   OK, use this vol\nD00200   DS    0H\n         TM    @_ATTRStg,L'@_ATTRStg    Selecting STORAGE vols?\n         JZ    D00210                   No, use this vol\n         TM    @D_UCB+UCBSTAB-UCBOB,UCBBSTR Storage?\n         JZ    D00480                   No, skip this vol\n         TM    @D_UCB+UCBFL5-UCBOB,UCBSMS SMS?\n         JO    D00480                   Yes, skip\n\nD00210   DS    0H\n*---------------------------------------------------------------------*\n*     ... and our STORGRP criteria, if applicable.                    *\n*---------------------------------------------------------------------*\n         ICM   R1,B'1111',@_STORGRP_List_Ptr A(STORGRP List)\n         JZ    D00240                   None, STORGRP not a criterion\n\n         TM    @D_UCB+UCBFL5-UCBOB,UCBSMS SMS?\n         JZ    D00480                   No, skip this volume\n\n         TM    @D_SMS_Unavail,L'@D_SMS_Unavail Is SMS there?\n         JO    D00480                  No, skip\n\n         LA    R15,@D_UCB+UCBVOLI-UCBOB A(Volser)\n         ST    R15,@D_Parms_T00010     Save it\n         LA    R15,@D_VLD_Anchor       A(VLD Anchor)\n         ST    R15,@D_Parms_T00010+4   Save it\n\n         LA    R1,@D_Parms             A(Parm list)\n         BRAS  R14,T00010              Go get Storgrp, status\n\n         STM   R0,R1,@D_SMS_Ptrs       Save the results\n         CHI   R15,4                   How did it go?\n         JL    D00220                  OK, skip\n         JE    D00480                  STORGRP not found, skip this vol\n         OI    @D_SMS_Unavail,L'@D_SMS_Unavail No SMS, set flag\n         J     D00480                  and skip this vol\n\nD00220   DS    0H\n         OI    @D_SMS_Ptrs_OK,L'@D_SMS_Ptrs_OK  We have SMS data\n\n         L     R15,@D_SMS_Ptrs+4        A(STORGRP Len, STORGRP)\n         L     R1,@_STORGRP_List_Ptr    A(STORGRP criterion)\n         L     R3,STORGRP_List_Hdr_Count-STORGRP_List_Hdr(R1) Get nbr\n         AHI   R1,STORGRP_List_Ent-STORGRP_List     and point to 1st\nD00230   DS    0H\n         MVC   @D_SMS_Temp_StorGrp,2(R15) Move STORGRP\n         OC    @D_SMS_Temp_StorGrp,STORGRP_List_Ent_Mask-STORGRP_List_E+\n               nt(R1)                   Reset wildcards\n         CLC   @D_SMS_Temp_StorGrp,STORGRP_List_Ent_STORGRP-STORGRP_Lis+\n               t_Ent(R1)                Our Storage group?\n         JE    D00240                   We want it, skip\n         AHI   R1,STORGRP_List_Ent_Length Bump to next entry\n         BRCT  R3,D00230                and try again\n         J     D00480                   Not here, skip this UCB\n\nD00240   DS    0H\n*---------------------------------------------------------------------*\n*     This seems to be a volume in which we are interested. Bump the  *\n*    count of volumes eligible to be included in the table ...        *\n*---------------------------------------------------------------------*\n         L     R15,@D_Volume_Count      Get current count\n         AHI   R15,1                    Bump it\n         ST    R15,@D_Volume_Count      Save it\n\n*---------------------------------------------------------------------*\n*     ... get a pointer to the next free entry in our table, ...      *\n*---------------------------------------------------------------------*\n         LA    R1,@D_Parms              A(Parm list)\n         BRAS  R14,W00010               Get A(Next entry in VolTbl)\n         LTR   R15,R15                  Did we get one?\n         JNZ   D00480                   No, don't update it then\n\n*---------------------------------------------------------------------*\n*     ... bump the count of vol entries in the table ...              *\n*---------------------------------------------------------------------*\n         ICM   R15,B'1111',@_VolTbl_Ptr A(VolTbl)\n         JZ    D00480                   Nothing, skip\n         L     R0,VolTbl_Hdr_Vols_Total-VolTbl_Hdr(R15) Get curr count\n         AHI   R0,1                     Bump it\n         ST    R0,VolTbl_Hdr_Vols_Total-VolTbl_Hdr(R15) Save it\n\n*---------------------------------------------------------------------*\n*     ... add this UCB to our table, and format some info about it.   *\n*---------------------------------------------------------------------*\n         LR    R9,R1                    Get A(Free entry)\n         USING VolTbl_Ent,R9\n\n         OI    VolTbl_Ent_Detail_Line,L'VolTbl_Ent_Detail_Line\n         MVC   VolTbl_Ent_UCBCopy,@D_UCB Move UCB Copy\n         MVC   VolTbl_Ent_DCECopy,@D_DCE Move DCE Copy\n\n*---------------------------------------------------------------------*\n*     If we will be displaying detail lines, format what we           *\n*    currently have available                                         *\n*---------------------------------------------------------------------*\n         TM    @_No_Details,L'@_No_Details Producing detail lines?\n         JO    D00470                    No, skip the formatting stuff\n\n         MVC   VolTbl_Ent_DevAddr,@D_UCBNAME Readable device address\n         MVC   VolTbl_Ent_DevType,=CL8' ' Clear device type\n\n*---------------------------------------------------------------------*\n*   Format the device type and model, using SYS1.$UCLEUS(IECDI$IT@, *\n*    CSECT IECDDE)T.                                                  *\n*     This is an undocumented CSECT, but its format seems to be:      *\n*      DS    XL1        DCEOBRDT/UCBTBYT4                             *\n*        DS    XL1        ??                                          *\n*        DS    CL8        Device Type in EBCDIC                       *\n*                                                                     *\n*    There are generic device entries (i.e 3380, 3390@, where the 1st *\n*    byte matches UCBTBYT4, and specific entries (i.e. 3380K. 33909@  *\n*    where the 1st byte matches DCEOBRDT. We try to identify emulated *\n*    devices by finding entries matching both UCBTBYT4 and DCEOBRDT;  *\n*    if the non-blank portion of the UCBTBYT4 entry does not match the*\n*    DCEOBRDT entry, we assume we have an emulated device, and use    *\n*    the UCBTBYT4 device type, suffixed with \"*E*\".                   *\n*                                                                     *\n*     If we use the DCEOBRDT entry, we format it, if required, by     *\n*    inserting, if required, a dash(-@ after the 4th character if     *\n*    there is at least 1 trailing blank.                              * *\n*---------------------------------------------------------------------*\n         ICM   R1,B'1111',@D_IECDDEVT_Ptr A(IECDDEVT)?\n         JZ    D00240C                   Not yet, skip\n\n*---------------------------------------------------------------------*\n*    If this device is the same as the previous one in the table,     *\n*    merely copy the device type                                      *\n*---------------------------------------------------------------------*\n         LA    R15,VolTbl_Ent            A(Our entry)\n         AHI   R15,-VolTbl_Ent_Len       A(Previous entry)\n         CLC   VolTbl_Ent_UCBCopy+UCBTBYT4-UCBOB(L'UCBTBYT4),VolTbl_Ent+\n               _UCBCopy+UCBTBYT4-UCBOB-VolTbl_Ent(R15)\n         JNE   D00250                    Not same, check IECDDEVT\n         CLC   VolTbl_Ent_DCECopy+DCEOBRDT-DCE(L'DCEOBRDT),VolTbl_Ent_D+\n               CECopy+DCEOBRDT-DCE-VolTbl_Ent(R15)\n         JNE   D00250                    Not same, check IECDDEVT\n         MVC   VolTbl_Ent_DevType,VolTbl_Ent_DevType-VolTbl_Ent(R15)\n         J     D00280                    and skip\nD00240C  DS    0H\n         NUCLKUP BYNAME,                 Not yet, look it up           +\n               NAME='IECDDEVT',           this CSECT                   +\n               ADDR=(0)                   return address here\n         LTR   R15,R15                   Did we get it?\n         JZ    D00240E                   Yes, OK\n         LA    R0,1                      No, set invalid address\nD00240E  DS    0H\n         ST    R0,@D_IECDDEVT_Ptr        Yes, save the address\n         LR    R1,R0                     and load up\nD00250   DS    0H\n         TM    @D_IECDDEVT_Ptr+3,X'01'   Is it a valid address?\n         JO    D00280                    No, skip device type\n         SLR   R14,R14                   Clear A(UCBTBYT4 entry)\n         SLR   R15,R15                   Clear A(DCEOBRDT entry)\nD00250A  DS    0H\n         CLI   0(R1),X'00'               End of table?\n         JE    D00280                    Yes, no device type\n         LTR   R14,R14                   Found UCBTBYT4 already?\n         JNZ   D00250C                   Yes, skip\n         CLC   0(L'UCBTBYT4,R1),VolTbl_Ent_UCBCopy+UCBTBYT4-UCBOB Us?\n         JNE   D00250C                   No, skip\n         LA    R14,2(0,R1)               Yes, save the address\n         J     D00250E                   and skip\nD00250C  DS    0H\n         LTR   R15,R15                   Found DCEOBRDT entry?\n         JNZ   D00250E                   Yes, skip\n         CLC   0(L'DCEOBRDT,R1),VolTbl_Ent_DCECopy+DCEOBRDT-DCE Us?\n         JNE   D00250E                   No, skip\n         LA    R15,2(0,R1)               Yes, save the address\nD00250E  DS    0H\n         LTR   R14,R14                   Found UCBTBYT4 entry?\n         JZ    D00250G                   No, keep checking\n         LTR   R15,R15                   Yes, got DCEOBRDT entry too?\n         JNZ   D00260                    Yes, all done\nD00250G  DS    0H\n         AHI   R1,10                     A(Next entry)\n         J     D00250A                   and check it out\nD00260   DS    0H\n         LA    R1,7(0,R14)               A(End of UCBTBYT4 entry\nD00260C  DS    0H\n         CLI   0(R1),C' '                End of device type?\n         JNE   D00260E                   Yes, skip\n         AHI   R1,-1                     No, back up a byte\n         J     D00260C                   and keep checking\nD00260E  DS    0H\n         SR    R1,R14                    EX length of compare\n         EX    R1,D_CLC                  Compare entries\n         JE    D00260G                   Equal, use DCEOBRDT\n         MVC   VolTbl_Ent_DevType,0(R14) Move UCBTBYT4 device type\n         CLC   VolTbl_Ent_DevType+L'VolTbl_Ent_DevType-3(3),=CL8' '\n         JNE   D00280                    No room for flag, skip\n         LA    R1,VolTbl_Ent_DevType(R1) Point to last char\n         MVC   1(3,R1),=C'*E*'           Say it's emulated\n         J     D00280                    and skip\n\nD00260G  DS    0H\n         MVC   VolTbl_Ent_DevType,0(R15) Move DCEOBRDT device type\n         CLI   VolTbl_Ent_DevType+4,C' ' 4-char dev type?\n         JE    D00280                    Yes, all done\n         CLI   VolTbl_Ent_DevType+4,C'-' Already formatted?\n         JE    D00280                    Yes, all done\n         CLI   VolTbl_Ent_DevType+L'VolTbl_Ent_DevType-1,C' ' Trail sp?\n         JNE   D00280                    No, skip formatting\n         MVC   VolTbl_Ent_DevType+5(L'VolTbl_Ent_DevType-5),4(R15)\n*                                        Make room for a dash\n         MVI   VolTbl_Ent_DevType+4,C'-' and insert it\n\n\nD00280   DS    0H\n*---------------------------------------------------------------------*\n*     Format the Volser, and the Mount attribute ...                  *\n*---------------------------------------------------------------------*\n         MVC   VolTbl_Ent_Volser,VolTbl_Ent_UCBCOPY+UCBVOLI-UCBOB\n\n         TM    VolTbl_Ent_UCBCOPY+UCBFL5-UCBOB,UCBSMS SMS?\n         JZ    D00290                    Not SMS, skip\n         MVC   VolTbl_Ent_Attrib,=C'SMS' Say so\n         J     D00320                    and skip\n\nD00290   DS    0H\n         TM    VolTbl_Ent_UCBCOPY+UCBSTAB-UCBOB,UCBBPRV Private?\n         JZ    D00300                    No, skip\n         MVC   VolTbl_Ent_Attrib,=C'Pvt' Yes, say so\n         J     D00320                    and skip\nD00300   DS    0H\n         TM    VolTbl_Ent_UCBCopy+UCBSTAB-UCBOB,UCBBPUB Public?\n         JZ    D00310                    No, skip\n         MVC   VolTbl_Ent_Attrib,=C'Pub' Yes, say so\n         J     D00320                    and skip\nD00310   DS    0H\n         MVC   VolTbl_Ent_Attrib,=C'Stg' Indicate Storage\nD00320   DS    0H\n*---------------------------------------------------------------------*\n*     Get the CHPIDs for this device using UCBINFO PATHINFO ...       *\n*---------------------------------------------------------------------*\n         LA    R1,VolTbl_Ent_CHPIDs     A(Output area)\n         LHI   R15,8                    Max nbr we can use\nD00320C  DS    0H\n         MVC   0(2,R1),=C'--'           Init CHPID value\n         AHI   R1,4                     Bump pointer\n         BRCT  R15,D00320C              and do them all\n\n         UCBINFO PATHINFO,              Get path info                  +\n               DEVN=VolTbl_Ent_UCBCOPY+UCBCHAN-UCBOB, for this device  +\n               PATHAREA=@D_UCBINFO_Data, in here                       +\n               MF=(E,@D_UCBINFO)        staying re-entrant\n\n         LTR   R15,R15                  Anything good happen?\n         JNZ   D00370                   No, skip\n\n*---------------------------------------------------------------------*\n*     ... and format them, flagging those that are unavailable        *\n*---------------------------------------------------------------------*\n         LA    R15,@D_UCBINFO_Data      Address of PATHINFO data\n         L     R14,@D_UCBINFO_Data+PATH#CHPIDS-PATH Nbr CHPIDS\n         CHI   R14,8                    Too many?\n         JNH   D00330                   No, OK\n         LHI   R14,8                    Yes, only use 1st 8\nD00330   DS    0H\n         LA    R15,@D_UCBINFO_Data+PATHCHPIDARRAY-PATH A(1st CHP entry)\n         LA    R1,VolTbl_Ent_CHPIDs     A(Output area)\nD00340   DS    0H\n         LH    R0,PATHCHPID-PATHCHPIDARRAY(R15) Get CHPID\n         SLL   R0,4                     Make room for sign\n         ST    R0,@D_DBLWD+4            Save it\n         OI    @D_DBLWD+7,X'0F'         Add a sign\n         UNPK  @D_DBLWD(3),@D_DBLWD+6(2) Unpack it\n         TR    @D_DBLWD+1(2),D_TRTAB     Make it readable\n         MVC   0(2,R1),@D_DBLWD+1       Move CHPID\n         TM    PATHBITS-PATHCHPIDARRAY(R15),PATHPAM  Physically avail?\n         JO    D00350                   Yes, skip\n         MVI   2(R1),C'$'               No, mark it\n         OI    @D_CHPID_Unavail,L'@D_CHPID_Unavail and set our flag\n         J     D00360                   Skip\nD00350   DS    0H\n         TM    PATHBITS-PATHCHPIDARRAY(R15),PATHLPM  Logically avail?\n         JO    D00360                   Yes, skip\n         MVI   2(R1),C'-'               No, mark it\n         OI    @D_CHPID_Unavail,L'@D_CHPID_Unavail and set our flag\n         J     D00360                   Skip\nD00360   DS    0H\n         AHI   R1,4                     Bump pointer\n         AHI   R15,L'PATHCHPIDARRAY     Point to next CHPID\n         BRCT  R14,D00340               and try again\n\nD00370   DS    0H\n*---------------------------------------------------------------------*\n*     If this is an SMS UCB, set up the Storage Group Name and SMS    *\n*    status.                                                          *\n*---------------------------------------------------------------------*\n         TM    VolTbl_Ent_UCBCopy+UCBFL5-UCBOB,UCBSMS SMS?\n         JNO   D00460                  No, skip\n\n         TM    @D_SMS_Ptrs_OK,L'@D_SMS_Ptrs_OK Do we already have it?\n         JO    D00380                  Yes, skip\n\n         TM    @D_SMS_Unavail,L'@D_SMS_Unavail Is SMS there?\n         JO    D00460                  No, skip\n\n         LA    R15,VolTbl_Ent_Volser   A(Volser)\n         ST    R15,@D_Parms_T00010     Save it\n         LA    R15,@D_VLD_Anchor       A(VLD Anchor)\n         ST    R15,@D_Parms_T00010+4   Save it\n\n         LA    R1,@D_Parms              A(Parm list)\n         BRAS  R14,T00010              Go get Storgrp, status\n\n         STM   R0,R1,@D_SMS_Ptrs       Save the results\n         CHI   R15,4                   How did it go?\n         JL    D00380                  OK, skip\n         JE    D00460                  STORGRP not found, skip this vol\n         OI    @D_SMS_Unavail,L'@D_SMS_Unavail No SMS, set flag\n         J     D00460                  and skip this vol\n\nD00380   DS    0H\n         L     R15,@D_SMS_Ptrs+4             A(STORGRP Len, name)\n         LH    R14,0(0,R15)                  Get len of STORGRP\n         LHI   R0,L'VolTbl_Ent_SMS_StorGrp   Len of output field\n         CR    R14,R0                        Too big?\n         JNH   D00390                        No, OK\n         LR    R14,R0                        Yes, reset it\nD00390   DS    0H\n         AHI   R14,-1                        EX Length\n         AHI   R15,2                         A(STORGRP)\n         LA    R1,VolTbl_Ent_SMS_StorGrp     A(Target field)\n         EX    R14,D_MVC\n\n         ICM   R15,B'1111',@D_SMS_Ptrs       A(SMS Status)\n         JZ    D00450                        None, we don't know\n\n         CLI   0(R15),VLD0                   Any status?\n         JNE   D00400                        No, skip\n         MVC   VolTbl_Ent_SMS_Status,=CL(L'VolTbl_Ent_SMS_Status)'None'\n         J     D00470                        and skip\nD00400   DS    0H\n         CLI   0(R15),VLDENBL                Enabled?\n         JNE   D00410                        No, skip\n         MVC   VolTbl_Ent_SMS_Status,=CL(L'VolTbl_Ent_SMS_Status)'Enabl+\n               ed'\n         J     D00470                        and skip\nD00410   DS    0H\n         CLI   0(R15),VLDQUI                 Quiesced/All?\n         JNE   D00420                        No, skip\n         MVC   VolTbl_Ent_SMS_Status,=CL(L'VolTbl_Ent_SMS_Status)'Quies+\n               ced/All'\n         J     D00470                        and skip\nD00420   DS    0H\n         CLI   0(R15),VLDQUIN                Quiesced/New?\n         JNE   D00430                        No, skip\n         MVC   VolTbl_Ent_SMS_Status,=CL(L'VolTbl_Ent_SMS_Status)'Quies+\n               ced/New'\n         J     D00470                        and skip\nD00430   DS    0H\n         CLI   0(R15),VLDDIS                 Disabled/All?\n         JNE   D00440                        No, skip\n         MVC   VolTbl_Ent_SMS_Status,=CL(L'VolTbl_Ent_SMS_Status)'Disab+\n               led/All'\n         J     D00470                        and skip\nD00440   DS    0H\n         CLI   0(R15),VLDDISN                Disabled/New?\n         JNE   D00450                        No, skip\n         MVC   VolTbl_Ent_SMS_Status,=CL(L'VolTbl_Ent_SMS_Status)'Disab+\n               led/New'\n         J     D00470                        and skip\nD00450   DS    0H\n         MVC   VolTbl_Ent_SMS_Status,=CL(L'VolTbl_Ent_SMS_Status)'Unkno+\n               wn'\n         J     D00470                        and skip\nD00460   DS    0H\n         MVC   VolTbl_Ent_SMS_StorGrp(3),=C'N/A' Move literal\n         MVC   VolTbl_Ent_SMS_Status(3),=C'N/A' and again\n         J     D00470                        and skip\n\nD00470   DS    0H\n*---------------------------------------------------------------------*\n*     If we are not going to be doing LSPACEs, mark this entry as     *\n*    complete ...                                                     *\n*---------------------------------------------------------------------*\n         TM    @_No_LSPACE,L'@_No_LSPACE     Doing LSPACE?\n         JNO   D00480                        Yes, skip\n         OI    VolTbl_Ent_Processed,L'VolTbl_Ent_Processed\n         OI    VolTbl_Ent_ECB,X'40'          'POST' as complete\n\nD00480   DS    0H\n*---------------------------------------------------------------------*\n*     ... and go get the next UCB, unless we are doing a single       *\n*    volser                                                           *\n*---------------------------------------------------------------------*\n         TM    @D_Single_Volser,L'@D_Single_Volser  Specific volser?\n         JO    D00490                   Yes, no need to keep checking\n         J     D00050                   No, do next UCB\n\nD00490   DS    0H\n*---------------------------------------------------------------------*\n*     Check to see if we found any UCBs                               *\n*---------------------------------------------------------------------*\n         ICM   R0,B'1111',@D_Volume_Count Any UCBs?\n         JNZ   D00540                   Yes, skip\n\n*---------------------------------------------------------------------*\n*   We couldn't find any UCBs - if we are selecting by UCB number,    *\n*  the user may have assumed a 3-byte UCB address, and we have been   *\n*  looking for 4-byte addresses. If this is the case, we add a '0'    *\n*  in front of the UCB address, and do all this again. We limit the   *\n*  re-iterations based on the entered UCB mask(s) - for example, we   *\n*  will reiterate for UCB(x??), but not for UCB(x???).                *\n*                                                                     *\n*   We assume (big mistake!) that the user has been consistent in     *\n*  specifying 3-digit UCBs in both UCB and XUCB - when we adjust an   *\n*  entry in UCB_List, if there is a subset of it in XUCB_List, we     *\n*  adjust it too.                                                     *\n*---------------------------------------------------------------------*\n         TM    @D_Eligible_UCB_Found,L'@D_Eligible_UCB_Found Any UCBs?\n         JO    D00540                   Yes, skip\n         ICM   R1,B'1111',@_UCB_List_Ptr A(UCB selection list)\n         JZ    D00540                   None, skip\n         NI    @D_UCB_Addr_Updated,X'FF'-L'@D_UCB_Addr_Updated\n\n         ICM   R3,B'1111',UCB_List_Hdr_Count-UCB_List_Hdr(R1)  Nbr UCBs\n         JZ    D00540                   None, skip\n         AHI   R1,UCB_List_Ent-UCB_List  Point to 1st\nD00500   DS    0H\n         CLI   UCB_List_Ent_UCB+L'UCB_List_Ent_UCB-1-UCB_List_Ent(R1),X+\n               'FF'                     Trailing wildcard?\n         JNE   D00530                   No, skip\n         CLI   UCB_List_Ent_UCB_Len-UCB_List_Ent(R1),L'@D_UCBNAME Adj?\n         JNL   D00530                   No, skip\n         LA    R0,0                     Yes, clear work reg\n         IC    R0,UCB_List_Ent_UCB_Len-UCB_List_Ent(R1) Entered len\n         AHI   R0,1                     Bump it\n         STC   R0,UCB_List_Ent_UCB_Len-UCB_List_Ent(R1) Entered len\n         L     R0,UCB_List_Ent_UCB-UCB_List_Ent(R1) Get the UCB\n         ST    R0,@D_DBLWD              Save it\n         SRL   R0,8                     Shift over 1 byte\n         ST    R0,UCB_List_Ent_UCB-UCB_List_Ent(R1) Save it\n         MVI   UCB_List_Ent_UCB-UCB_List_Ent(R1),C'0'  Leading 0\n         L     R0,UCB_List_Ent_Mask-UCB_List_Ent(R1) Get wildcard mask\n         SRL   R0,8                     Shift it right too\n         ST    R0,UCB_List_Ent_Mask-UCB_List_Ent(R1) Save it as well\n         OI    @D_UCB_Addr_Updated,L'@D_UCB_Addr_Updated UCB changed\n         ICM   R4,B'1111',@_XUCB_List_Ptr A(Excluded UCBs)\n         JZ    D00530                   None, skip\n\n         L     R5,UCB_List_Hdr_Count-UCB_List_Hdr(R4)  Count of UCBs\n         AHI   R4,UCB_List_Ent-UCB_List  Point to 1st\nD00510   DS    0H\n         CLI   UCB_List_Ent_UCB+L'UCB_List_Ent_UCB-1-UCB_List_Ent(R4),X+\n               'FF'                     Trailing wildcard?\n         JNE   D00520                   No, skip\n         CLI   UCB_List_Ent_UCB_Len-UCB_List_Ent(R4),L'@D_UCBNAME Adj?\n         JNL   D00520                   No, skip\n         LA    R0,0                     Yes, clear work reg\n         IC    R0,UCB_List_Ent_UCB_Len-UCB_List_Ent(R4) Entered len\n         AHI   R0,1                     Bump it\n         STC   R0,UCB_List_Ent_UCB_Len-UCB_List_Ent(R4) Entered len\n         L     R0,UCB_List_Ent_UCB-UCB_List_Ent(R4) Yes, get UCB\n         ST    R0,@D_DBLWD+4            Save it\n         OC    @D_DBLWD+4(L'UCB_List_Ent_UCB),UCB_List_Ent_Mask-UCB_Lis+\n               t_Ent(R1)                Reset wildcard characters\n         CLC   @D_DBLWD(L'UCB_List_Ent_UCB),@D_DBLWD+4  Subset of Incl?\n         JNE   D00520                   No, skip\n         SRL   R0,8                     Shift over 1 byte\n         ST    R0,UCB_List_Ent_UCB-UCB_List_Ent(R4) Save it\n         MVI   UCB_List_Ent_UCB-UCB_List_Ent(R4),C'0'  Leading 0\n         L     R0,UCB_List_Ent_Mask-UCB_List_Ent(R4) Get wildcard mask\n         SRL   R0,8                     Shift it right too\n         ST    R0,UCB_List_Ent_Mask-UCB_List_Ent(R4) Save it as well\n\nD00520   DS    0H\n         AHI   R4,UCB_List_Ent_Length   Bump to next entry\n         BRCT  R5,D00510                and process it\n\nD00530   DS    0H\n         AHI   R1,UCB_List_Ent_Length   Bump to next entry\n         BRCT  R3,D00500                and process it\n\n         TM    @D_UCB_Addr_Updated,L'@D_UCB_Addr_Updated Any changes?\n         JO    D00040                   Yes, try again\n\nD00540   DS    0H\n*---------------------------------------------------------------------*\n*     We have finished all our UCBs; update the total eligible vol    *\n*    count, and, if no entries, flag it as complete ...               *\n*---------------------------------------------------------------------*\n         ICM   R15,B'1111',@_VolTbl_Ptr A(VolTbl)\n         JZ    D00800                   Nothing, skip\n         L     R0,@D_Volume_Count       Total eligible volumes\n         ST    R0,VolTbl_Hdr_Vols_Eligible-VolTbl_Hdr(R15)\n\n         ICM   R0,B'1111',VolTbl_Hdr_Vols_Total-VolTbl_Hdr(R15) Any?\n         JZ    D00790                   No, POST table as complete\n\n*---------------------------------------------------------------------*\n*     ... and, if we are doing totals, create and populate (as much   *\n*    as we can) the Totals line ...                                   *\n*---------------------------------------------------------------------*\n         TM    @_No_Totals,L'@_No_Totals Doing Totals?\n         JO    D00590                   No, skip\n\n         LA    R1,@D_Parms              A(Parm list)\n         BRAS  R14,W00010               A(Next free entry)\n         LTR   R15,R15                  Did we get one?\n         JNZ   D00590                   No, skip\n         LR    R9,R1                    Yes, point to it\n\n         L     R15,@_VolTbl_Ptr          A(VolTbl)\n         SR    R1,R15                    Offset of Totals Line\n         ST    R1,VolTbl_Hdr_Total_Off-VolTbl_Hdr(R15) Save it\n\n         OI    VolTbl_Ent_Total_Line,L'VolTbl_Ent_Total_Line\n         L     R15,@_VolTbl_Ptr          A(VolTbl)\n         L     R0,VolTbl_Hdr_Vols_Total-VolTbl_Hdr(R15) Nbr vols\n         CVD   R0,@D_DBLWD               Pack it\n         MVC   VolTbl_Ent_DevType(7),=X'4020206B202120' Move mask\n         ED    VolTbl_Ent_DevType(7),@D_DBLWD+5 Edit in count\n\n         ICM   R1,B'1111',@_XVol_List_Ptr Excluding by vol?\n         JNZ   D00550                   Yes, leave volser blank\n         ICM   R1,B'1111',@_Vol_List_Ptr No, selecting by vol?\n         JZ    D00550                   No, set vol to asterisks\n         CLC   =FL4'1',4(R1)            Yes, a single volser?\n         JNE   D00550                   No, leave volser blank\n         MVC   VolTbl_Ent_Volser,8(R1)  Yes, move volser mask\n         TR    VolTbl_Ent_Volser,D_TrTbl and Xlate X'FF' to '*'\n         J     D00550                   and skip\n\nD00550   DS    0H\n         ICM   R1,B'1111',@_XUCB_List_Ptr Excluding by UCB?\n         JNZ   D00560                   Yes, leave UCB blank\n         ICM   R1,B'1111',@_UCB_List_Ptr No, selecting by UCB?\n         JZ    D00560                   No, set UCB to asterisks\n         L     R0,UCB_List_Hdr_Count-UCB_List_Hdr(R1)  Get Nbr masks\n         C     R0,=FL4'1'               A single UCB?\n         JNE   D00560                   No, leave UCB blank\n         AHI   R1,UCB_List_Ent-UCB_List Yes, point to it\n         MVC   VolTbl_Ent_DevAddr,UCB_List_Ent_UCB-UCB_List_Ent(R1)\n         TR    VolTbl_Ent_DevAddr,D_TrTbl and Xlate X'FF' to '*'\n         J     D00560                   and skip\n\nD00560   DS    0H\n         MVC   VolTbl_Ent_Attrib,=CL8' ' No attributes\n\n         ICM   R1,B'1111',@_STORGRP_List_Ptr Selecting by StorGrp?\n         JZ    D00570                   No, skip\n         CLC   =FL4'1',4(R1)            Yes, a single STORGRP?\n         JNE   D00570                   No, leave blank\n         MVC   VolTbl_Ent_SMS_StorGrp,8(R1) Yes, move mask\n         TR    VolTbl_Ent_SMS_StorGrp,D_TrTbl and Xlate X'FF' to '*'\n         J     D00570                   and skip\n\nD00570   DS    0H\n*---------------------------------------------------------------------*\n*     If a CHPID was not physically or logically available, put out   *\n*    a message in the CHPID area of the totals line.                  *\n*---------------------------------------------------------------------*\n         TM    @D_CHPID_Unavail,L'@D_CHPID_Unavail  CHPIDs OK?\n         JNO   D00580                   Yes, OK\n         MVC   VolTbl_Ent_CHPIDs(L'D_CHPID_Msg),D_CHPID_Msg No, msg\n\nD00580   DS    0H\n*---------------------------------------------------------------------*\n*     If we will not be doing LSPACEs, mark the Totals line as        *\n*    complete                                                         *\n*---------------------------------------------------------------------*\n         TM    @_No_LSPACE,L'@_No_LSPACE Doing LSPACEs?\n         JNO   D00590                   Yes, OK\n         OI    VolTbl_Ent_Processed,L'VolTbl_Ent_Processed\n         OI    VolTbl_Ent_ECB,X'40'     and POST as complete\n\nD00590   DS    0H\n*---------------------------------------------------------------------*\n*     If we will be doing LSPACEs, get a line for the SMS Anomaly     *\n*    message                                                          *\n*---------------------------------------------------------------------*\n         TM    @_No_LSPACE,L'@_No_LSPACE  Doing LSPACE?\n         JO    D00600                   No, skip\n\n         LA    R1,@D_Parms              A(Parm list)\n         BRAS  R14,W00010               A(Next entry in VolTbl)\n         LTR   R15,R15                  Did we get one?\n         JNZ   D00600                   No, skip\n         LR    R9,R1                    Yes, point to it\n\n         L     R15,@_VolTbl_Ptr          A(VolTbl)\n         SR    R1,R15                    Offset of SMS Anomaly Line\n         ST    R1,VolTbl_Hdr_SMS_Off-VolTbl_Hdr(R15) Clear offset\n\n         OI    VolTbl_Ent_Detail_Line,L'VolTbl_Ent_Detail_Line\n         OI    VolTbl_Ent_SMS_Line,L'VolTbl_Ent_SMS_Line SMS Anomaly\n\nD00600   DS    0H\n*---------------------------------------------------------------------*\n*     Get processor-related data                                      *\n*---------------------------------------------------------------------*\n         XC    @_LP_Count,@_LP_Count    Make sure LP Count is 0\n         MVI   @D_CSRSI_Manuf,C' '      Clear Manufacturer ID\n         MVC   @D_CSRSI_Manuf+1(L'@D_CSRSI_Manuf-1),@D_CSRSI_Manuf\n         MVC   @D_CSRSI_Type,@D_CSRSI_Manuf Clear Type\n         MVC   @D_CSRSI_Model,@D_CSRSI_Manuf Clear Model\n         MVC   @D_CSRSI_Serial,@D_CSRSI_Manuf Clear Serial\n\n         L     R15,CVTPTR               A(CVT)\n         TM    CVTDCB-CVT(R15),CVTOSEXT Is OSLVL OK?\n         JZ    D00600Z                  No, crawl through control blks\n         TM    CVTOSLV4-CVT(R15),CVTCSRSI Yes, can we use CSRSI?\n         JZ    D00600Z                  No, use control blocks\n\n*---------------------------------------------------------------------*\n*     We will be using CSRSI to get the processor-related data - go   *\n*    build the parm list ...                                          *\n*---------------------------------------------------------------------*\n         L     R0,=AL4(SIV1V2V3_LEN)    Length of return data\n\n         BASR  R2,0\n         USING (*,D00600_End-1),R2\n         STORAGE OBTAIN,                Go get some storage            +\n               LENGTH=(0)                this long\nD00600_End DS  0H\n         ST    R1,@D_CSRSI_Parm+8       Save A(Info area)\n         LA    R15,=AL4(CSRSI_REQUEST_V1CPC_MACHINE+CSRSI_REQUEST_V2CPC+\n               _LPAR+CSRSI_REQUEST_V3CPC_VM) All data requested\n         ST    R15,@D_CSRSI_Parm        Save request code\n         LA    R15,=AL4(SIV1V2V3_Len)   A(Length of Info area)\n         ST    R15,@D_CSRSI_Parm+4      Save length in parm list\n         LA    R15,@D_DBLWD             A(Return code area)\n         ST    R15,@D_DBLWD+4           Save it\n         LA    R15,@D_DBLWD+4           A(Return code area pointer)\n         ST    R15,@D_CSRSI_Parm+12     Save in parm list\n\n*---------------------------------------------------------------------*\n*     ... and issue CSRSI                                             *\n*---------------------------------------------------------------------*\n         BASR  R2,0\n         USING (*,D00600A_End-1),R2\n         LOAD  EP=CSRSI                 Go get machine info module\nD00600A_End DS  0H\n         LTR   R15,R15                  Did it work\n         JNZ   D00600X                  No, skip\n         LR    R15,R0                   Yes, save EP\n         LA    R1,@D_CSRSI_Parm         A(Parmlist)\n         BASR  R14,R15                  Go do it\n         DELETE EP=CSRSI                Don't need CSRSI anymore\n         L     R15,@D_DBLWD             Get CSRSI return code\n         CHI   R15,CSRSI_STSINOTAVAILABLE Did we get anything?\n         JH    D00600X                  No, skip\n\n*---------------------------------------------------------------------*\n*     We seem to have some valid data back from CSRSI, so save the    *\n*    bits we need.                                                    *\n*---------------------------------------------------------------------*\n         L     R15,@D_CSRSI_Parm+8      A(CSRSI Data)\n         TM    SI00VALIDITYFLAGS-SI00(R15),SI00VALIDSI11V1 V1 valid?\n         JZ    D00600C                  No, skip\n         A     R15,=AL4(SI00_LEN)       Yes, bump to V1 Data area\n         MVC   @D_CSRSI_Manuf,SI11V1CPCMANUFACTURER-SI11V1(R15)\n         MVC   @D_CSRSI_Type,SI11V1CPCTYPE-SI11V1(R15)\n         MVC   @D_CSRSI_Model,SI11V1CPCMODEL-SI11V1(R15)\n         MVC   @D_CSRSI_Serial,SI11V1CPCSEQUENCECODE+L'SI11V1CPCSEQUENC+\n               ECODE-L'@D_CSRSI_Serial-SI11V1(R15)\nD00600C  DS    0H\n         L     R15,@D_CSRSI_Parm+8      A(CSRSI Data)\n         TM    SI00VALIDITYFLAGS-SI00(R15),SI00VALIDSI22V3 VM valid?\n         JZ    D00600E                  No, skip\n         A     R15,=AL4(SIV1V2_LEN)     Yes, bump to VM Data area\n         LA    R0,0                     Clear work reg\n         IC    R0,SI22V3DBCOUNTFIELD-SI22V3(0,R15) Nbr V3 Desc Blks\n         SLL   R0,28                    Clean\n         SRL   R0,28                     it\n         AHI   R0,-1                    Relative to 0\n         MH    R0,=AL2(SI22V3DB_LEN)    Offset of last\n         LA    R15,SI22V3DBS-SI22V3(0,R15) Point to first\n         ALR   R15,R0                   and then to last\n         LH    R0,SI22V3DBCONFIGUREDLCPUCOUNT-SI22V3DB(R15) LCPUs\n         ST    R0,@_LP_Count            Save it\n         J     D00600X                  and skip\nD00600E  DS    0H\n         L     R15,@D_CSRSI_Parm+8      A(CSRSI Data)\n         TM    SI00VALIDITYFLAGS-SI00(R15),SI00VALIDSI22V2 LPAR valid?\n         JZ    D00600G                  No, skip\n         A     R15,=AL4(SIV1_LEN)       Yes, bump to LPAR Data area\n         LH    R0,SI22V2CONFIGUREDLCPUCOUNT-SI22V2(R15) LCPUs\n         ST    R0,@_LP_Count            Save it\n         J     D00600X                  and skip\nD00600G  DS    0H\n         L     R15,@D_CSRSI_Parm+8      A(CSRSI Data)\n         TM    SI00VALIDITYFLAGS-SI00(R15),SI00VALIDSI22V1 Mach OK?\n         JZ    D00600X                  No, skip\n         A     R15,=AL4(SI00_LEN+SI11V1_LEN) Bump to CPC Data area\n         LH    R0,SI22V1CONFIGUREDCPUCOUNT-SI22V1(R15) CPUs\n         ST    R0,@_LP_Count            Save it\n         J     D00600X                  and skip\n\nD00600X  DS    0H\n         L     R0,=AL4(SIV1V2V3_LEN)    Length of return data\n         L     R1,@D_CSRSI_Parm+8       A(Start)\n\n         BASR  R2,0\n         USING (*,D00600X_End-1),R2\n         STORAGE RELEASE,               Free CSRSI storage             +\n               ADDR=(1),                 starting here                 +\n               LENGTH=(0)                for this long\nD00600X_End DS  0H\n\n         LA    R15,0                    Clear work reg\n         ST    R15,@D_CSRSI_Parm+4      Clear storage length\n         ST    R15,@D_CSRSI_Parm+8         and address\n\nD00600Z  DS    0H\n*---------------------------------------------------------------------*\n*     We will be crawling through control blocks to get the processor *\n*    related info. Get the CPU-type data (Type, model, etc.)          *\n*---------------------------------------------------------------------*\n         CLI   @D_CSRSI_Manuf,C' '       Do we have CPU Data?\n         JNE   D00608                    Yes, skip\n         L     R15,CVTPTR                No, A(CVT)\n         L     R15,CVTHID-CVT(R15)       A(Host ID Table)\n         TM    CPCND_FLAGS-SHID(R15),CPCND_INVAL OK?\n         JO    D00602                    No, skip type info\n         MVC   @D_CSRSI_Manuf(L'CPCND_MAN),CPCND_MAN-SHID(R15)\n         MVC   @D_CSRSI_Type(L'CPCND_TYPE),CPCND_TYPE-SHID(R15)\n         MVC   @D_CSRSI_Model(L'CPCND_MODEL),CPCND_MODEL-SHID(R15)\nD00602   DS    0H\n         L     R15,CVTPTR                A(CVT)\n         L     R15,CVTPCCAT-CVT(R15)     A(PCCA Table)\n         LHI   R14,16                    Max of 16 CPUs\nD00604   DS    0H\n         ICM   R0,B'1111',0(R15)         Get A(PCCA) for this CPU\n         JNZ   D00606                    CPU Active, skip\n         AHI   R15,4                     No, point to next\n         BRCT  R14,D00604                and check again\n         J     D00608                    None(?), ignore it\nD00606   DS    0H\n         LR    R15,R0                    Point to PCCA\n         MVC   @D_CSRSI_Serial,PCCACPID+4-PCCA(R15)  Serial number\n\nD00608   DS    0H\n*---------------------------------------------------------------------*\n*     Go get the number of CPUs, if required                          *\n*---------------------------------------------------------------------*\n         ICM   R1,B'1111',@_LP_Count    Do we have an LP count?\n         JNZ   D00625                   Yes, skip\n         L     R15,CVTPTR               A(CVT)\n         L     R15,CVTLCCAT-CVT(R15)    A(LCCAVT)\n         LHI   R14,16                   Max number of CPUs\n         LA    R1,0                     Count of CPUs\nD00610   DS    0H\n         ICM   R0,B'1111',0(R15)        Get A(LCCA) for this CPU\n         JZ    D00620                   None, skip\n         AHI   R1,1                     OK, bump CPU count\nD00620   DS    0H\n         AHI   R15,4                    Bump to next LCCA pointer\n         BRCT  R14,D00610               and check it out\n         ST    R1,@_LP_Count            Save it\n\nD00625   DS    0H\n*---------------------------------------------------------------------*\n*     ... and initialize @_SubTask_Count to either MAXTASKS or        *\n*      MIN(Volumes, (2*#_Logical_Processors)+1)                       *\n*---------------------------------------------------------------------*\n         LH    R0,@_MaxTasks            Get MaxTasks specification\n         LTR   R0,R0                    Any?\n         JP    D00630                   Yes, skip\n         LR    R0,R1                    No, use #LPs\n         SLL   R0,1                      doubled\n         AHI   R0,1                      + 1\nD00630   DS    0H\n         AIF   (&Max_SubTask_Count LT 1).Max_SubTask_Count_020\n         CHI   R0,&Max_SubTask_Count    Is it > max?\n         JNH   D00630C                  No, OK\n         LHI   R0,&Max_SubTask_Count    Yes, use max\nD00630C  DS    0H\n.Max_SubTask_Count_020 ANOP\n         ST    R0,@_SubTask_Count       and update it\n\n         LA    R0,0                     Clear UCB count\n         ICM   R9,B'1111',@_VolTbl_Ptr A(Table of Volumes)\n         JZ    D00650                   None, skip\n         ICM   R10,B'1111',VolTbl_Hdr_Count-VolTbl_Hdr(R9) Get count\n         JZ    D00650                   None, skip\n         AHI   R9,VolTbl_Ent-VolTbl     Point to 1st entry\nD00640   DS    0H\n         TM    VolTbl_Ent_Detail_Line,L'VolTbl_Ent_Detail_Line UCB?\n         JNO   D00640C                  Not Detail line, skip\n         TM    VolTbl_Ent_SMS_Line,L'VolTbl_Ent_SMS_Line SMS Anomaly?\n         JO    D00640C                  Not really a UCB, skip\n         AHI   R0,1                     Bump UCB count\nD00640C  DS    0H\n         AHI   R9,VolTbl_Ent_Len        A(Next entry)\n         BRCT  R10,D00640               and check again\n\nD00650   DS    0H\n*---------------------------------------------------------------------*\n*     Use the lesser of UCB count and @_SubTask_Count for our         *\n*    number of subtasks                                               *\n*---------------------------------------------------------------------*\n         C     R0,@_SubTask_Count       Check against nbr subtasks\n         JNL   D00660                   OK, skip\n         ST    R0,@_SubTask_Count       Too few UCBs, use UCB count\n\nD00660   DS    0H\n*---------------------------------------------------------------------*\n*     If we will be doing Statistics, ...                             *\n*---------------------------------------------------------------------*\n         TM    @_Statistics,L'@_Statistics Doing stats?\n         JNO   D00780                    No, skip\n\n*---------------------------------------------------------------------*\n*    ... move the non-execution-related stats lines ...               *\n*---------------------------------------------------------------------*\n         LA    R2,D_Stats_Line_Ptrs      A(Start of line pointers)\n         SLR   R3,R3                     Clear count\nD00660C  DS    0H\n         LA    R1,@D_Parms               A(Parm list)\n         BRAS  R14,W00010                Get A(Next entry)\n         LTR   R15,R15                   Did we get one?\n         JNZ   D00780                    No, skip\n         LR    R9,R1                     Yes, point to it\n         L     R15,0(0,R2)               A(Stats line)\n         LH    R14,0(0,R15)              Get length of stats line\n         AHI   R14,-1                    EX len\n         EX    R14,D_MVC1                Move it\n\n         OI    VolTbl_Ent_Stats_Line,L'VolTbl_Ent_Stats_Line\n         OI    VolTbl_Ent_Processed,L'VolTbl_Ent_Processed Mark as done\n         OI    VolTbl_Ent_Stats_Done,L'VolTbl_Ent_Stats_Done Done\n         OI    VolTbl_Ent_ECB,X'40'      POST as done\n\n         AHI   R3,1                      Bump count\n         CHI   R3,3                      1st execution line?\n         JNE   D00680E                   No, skip\n\n\n         MVC   @D_TIME,D_TIME           Move L-Form of macro\n         TIME  DEC,                     Get time                       +\n               @D_Time_Area,             and return it here            +\n               LINKAGE=SYSTEM,           don't use the SVC             +\n               DATETYPE=YYYYMMDD,        format of returned data       +\n               MF=(E,@D_TIME)            addr of macro list\n         L     R0,@D_Time_Area          Get the time\n         SRL   R0,12                    Shift out seconds and 100s\n         ST    R0,@D_Time_Area          Save it\n         OI    @D_Time_Area+3,X'0F'     OR in a sign\n         MVC   @D_WkArea(7),=X'402120204B2020' Time mask\n         ED    @D_WkArea(7),@D_Time_Area+1 Make it readable\n         MVC   VolTbl_Ent_Display+D_Stats_Line3_Time-D_Stats_Line3(L'D_+\n               Stats_Line3_Time),@D_WkArea+2\n         L     R15,@D_Time_Area+8       Get Date (yyyymmdd)\n         LA    R14,0                    Clear work register\n         SLDL  R14,4                    Make room for sign\n         STM   R14,R15,@D_Time_Area     Save it\n         OI    @D_Time_Area+7,X'0F'     OR in a sign\n         MVC   @D_WkArea(12),=X'402120202020602020602020'  Date mask\n         ED    @D_WkArea(12),@D_Time_Area+3 Make it readable\n         MVC   VolTbl_Ent_Display+D_Stats_Line3_Date-D_Stats_Line3(L'D_+\n               Stats_Line3_Date),@D_WkArea+2\n\n         L     R14,CVTPTR               A(CVT)\n         L     R15,CVTECVT-CVT(0,R14)   A(EVCT)\n         MVC   VolTbl_Ent_Display+D_Stats_Line3_SysVer-D_Stats_Line3(L'+\n               ECVTPNAM),ECVTPNAM-ECVT(R15)\n         LA    R1,VolTbl_Ent_Display+D_Stats_Line3_SysVer+L'ECVTPNAM-1-+\n               D_Stats_Line3           A(Last char)\n         LA    R0,VolTbl_Ent_Display+D_Stats_Line3_SYSVer-D_Stats_Line3\nD00670   DS    0H\n         CLI   0(R1),C' '               Last significant character\n         JNE   D00680                   Yes, skip\n         S     R1,=FL4'1'               No, back up a byte\n         CR    R1,R0                    Too far?\n         JH    D00670                   No, check again\nD00680   DS    0H\n         AIF   (NOT D'CVTZOSE).D00680_010\n         TM    CVTOSLV5-CVT(R14),CVTZOSE z/OS.e?\n         JZ    D00680C                  No, skip\n         MVC   1(2,R1),=C'.e'           Yes, say so\n         LA    R1,2(0,R1)               and bump pointer\nD00680C  DS    0H\n.D00680_010 ANOP\n         MVC   2(L'ECVTPVER,R1),ECVTPVER-ECVT(R15)  Version\n         MVI   2+L'ECVTPVER(R1),C'.'    Separator\n         MVC   2+L'ECVTPVER+1(L'ECVTPREL,R1),ECVTPREL-ECVT(R15) Rel\n         MVI   2+L'ECVTPVER+1+L'ECVTPREL(R1),C'.'    Separator\n         MVC   2+L'ECVTPVER+1+L'ECVTPREL+1(L'ECVTPMOD,R1),ECVTPMOD-ECVT+\n               (R15)\n\nD00680E  DS    0H\n         CHI   R3,4                      2nd execution stats line?\n         JNE   D00750C                   No, skip\n\n         L     R15,CVTPTR                A(CVT)\n         MVC   VolTbl_Ent_Display+D_Stats_Line4_SNAME-D_Stats_Line4(L'C+\n               VTSNAME),CVTSNAME-CVT(R15)\n         LA    R1,VolTbl_Ent_Display+D_Stats_Line4_SNAME+L'CVTSNAME-1-D+\n               _Stats_Line4              A(Last char)\nD00690   DS    0H\n         CLI   0(R1),C' '                Trailing Blank?\n         JNE   D00700                    No, skip\n         S     R1,=FL4'1'                Yes, back up a byte\n         J     D00690                    and try again\nD00700   DS    0H\n         MVI   2(R1),C'('                Open paren\n         AHI   R1,3                      Point to next byte\n         MVC   0(L'@D_CSRSI_Manuf,R1),@D_CSRSI_Manuf Move manufacturer\n         LA    R1,L'@D_CSRSI_Manuf-1(0,R1) A(Last character)\nD00702   DS    0H\n         CLI   0(R1),C' '                Trailing blank?\n         JNE   D00704                    No, OK\n         BRCT  R1,D00702                 Yes, back up a byte\nD00704   DS    0H\n         MVI   1(R1),C' '                Move separator\n         MVC   2(L'@D_CSRSI_Type,R1),@D_CSRSI_Type\n         MVI   2+L'@D_CSRSI_Type(R1),C'-' Separator\n         MVC   2+L'@D_CSRSI_Type+1(L'@D_CSRSI_Model,R1),@D_CSRSI_Model\n         LA    R1,2+L'@D_CSRSI_Type+L'@D_CSRSI_Model(0,R1)\nD00706   DS    0H\n         CLI   0(R1),C' '                Trailing blank?\n         JNE   D00708                    No, OK\n         BRCT  R1,D00706                 Yes, back up and check again\nD00708   DS    0H\n         MVC   1(8,R1),=C', CPUID '      Literal\n         MVC   9(L'@D_CSRSI_Serial,R1),@D_CSRSI_Serial\n         MVI   9+L'@D_CSRSI_Serial(R1),C')'  Trailing paren\n         LA    R1,10+L'@D_CSRSI_Serial(0,R1) A(Next byte)\n\nD00740   DS    0H\n         MVC   0(5,R1),=C' with'         Start of literal\n         AHI   R1,5                      A(Next byte)\n         TM    @_OW48527,L'@_OW48527     APAR OW48527 on?\n         JO    D00750                    Yes, skip\n         MVC   0(3,R1),=C'out'           No, say so\n         AHI   R1,3                      A(Next byte)\nD00750   DS    0H\n         MVC   0(9,R1),=C' OW48527.'     Finish it off\n\nD00750C  DS    0H\n         CHI   R3,D_Stats_Line_Count     Any more to do?\n         JNL   D00750E                   No, skip\n         AHI   R2,4                      Yes, bump to next pointer\n         J     D00660C                   and go do it\n\nD00750E  DS    0H\n*-------------------------------------------------------------------*\n*    ... 2 more for the Stack statistics ...                        *\n*-------------------------------------------------------------------*\n         LA    R1,@D_Parms               A(Parm list)\n         BRAS  R14,W00010                Get A(Next entry)\n         LTR   R15,R15                   Did we get one?\n         JNZ   D00780                    No, skip\n         LR    R9,R1                     Yes, point to it\n\n         OI    VolTbl_Ent_Stats_Line,L'VolTbl_Ent_Stats_Line\n         OI    VolTbl_Ent_Stats_31Stack,L'VolTbl_Ent_Stats_31Stack\n\n         LA    R1,@D_Parms               A(Parm list)\n         BRAS  R14,W00010                Get A(Next entry)\n         LTR   R15,R15                   Did we get one?\n         JNZ   D00780                    No, skip\n         LR    R9,R1                     Yes, point to it\n\n         OI    VolTbl_Ent_Stats_Line,L'VolTbl_Ent_Stats_Line\n         OI    VolTbl_Ent_Stats_24Stack,L'VolTbl_Ent_Stats_24Stack\n\n*-------------------------------------------------------------------*\n*    ... and 1 more for the CPU time.                               *\n*-------------------------------------------------------------------*\n         LA    R1,@D_Parms               A(Parm list)\n         BRAS  R14,W00010                Get A(Next entry)\n         LTR   R15,R15                   Did we get one?\n         JNZ   D00780                    No, skip\n         LR    R9,R1                     Yes, point to it\n\n         OI    VolTbl_Ent_Stats_Line,L'VolTbl_Ent_Stats_Line\n         OI    VolTbl_Ent_Stats_CPUTime,L'VolTbl_Ent_Stats_CPUTime\n\n*---------------------------------------------------------------------*\n*   If we are doing LSPACEs, get enough lines for the subtask         *\n*  heading(s) and stats lines                                         *\n*---------------------------------------------------------------------*\n         TM    @_No_LSPACE,L'@_No_LSPACE Doing LSPACEs?\n         JO    D00780                   No, skip subtask stuff\n\n         L     R8,@_SubTask_Count       Get nbr subtasks\n         AHI   R8,H_SubTask_Hdg_Count   Plus nbr heading lines\n         SR    R3,R3                    Clear offset\n\nD00760   DS    0H\n         LA    R1,@D_Parms               A(Parm list)\n         BRAS  R14,W00010                Get A(Next entry)\n         LTR   R15,R15                   Did we get one?\n         JNZ   D00780                    No, skip\n         OI    VolTbl_Ent_Stats_Line-VolTbl_Ent(R1),L'VolTbl_Ent_Stats_+\n               Line\n         LTR   R3,R3                     Have we saved the offset?\n         JNZ   D00770                    Yes, skip\n         L     R15,@_VolTbl_Ptr          A(VolTbl)\n         LR    R3,R1                     A(1st heading line)\n         SR    R3,R15                    Offset of SubTask heading\n         ST    R3,VolTbl_Hdr_SubT_Off-VolTbl_Hdr(R15) Save it\nD00770   DS    0H\n\n         BRCT  R8,D00760                 And do it again\n\nD00780   DS    0H\n*---------------------------------------------------------------------*\n*     If we will not be doing LSPACEs ...                             *\n*---------------------------------------------------------------------*\n         TM    @_No_LSPACE,L'@_No_LSPACE  Doing LSPACE?\n         JNO   D00800                   Yes, skip\n\nD00790   DS    0H\n*---------------------------------------------------------------------*\n*     ... all volumes have been processed, and the table is complete. *\n*---------------------------------------------------------------------*\n         ICM   R15,B'1111',@_VolTbl_Ptr No, A(VolTbl)\n         JZ    D00800                   None, skip\n         L     R0,VolTbl_Hdr_Vols_Total-VolTbl_Hdr(R15)\n         ST    R0,VolTbl_Hdr_Vols_Proc-VolTbl_Hdr(R15)\n         OI    VolTbl_Hdr_ECB-VolTbl_Hdr(R15),X'40' POST table complete\n\nD00800   DS    0H\n*---------------------------------------------------------------------*\n*     Free up the esoteric table, if there is one ...                 *\n*---------------------------------------------------------------------*\n         ICM   R1,B'1111',@D_UNITA      A(Unit Table)\n         JZ    D00810                   None, skip\n         L     R0,0(0,R1)               Get its length\n\n         BASR  R2,0\n         USING (*,D00800_End-1),R2\n         STORAGE RELEASE,               Free the old table             +\n               ADDR=(1),                 starting here                 +\n               LENGTH=(0)                for this long\nD00800_End DS  0H\n         DROP  R2\n\n         LA    R15,0                    Clear work register\n         ST    R15,@D_UNITA             and clear A(Unit table)\n\nD00810   DS    0H\n*---------------------------------------------------------------------*\n*     ... and the VLDs, if there are any.                             *\n*---------------------------------------------------------------------*\n         LA    R15,0                   Clear work reg\n         ST    R15,@D_Parms_T00010     No volser\n         LA    R15,@D_VLD_Anchor       A(Anchor)\n         ST    R15,@D_Parms_T00010+4   No volser\n         LA    R1,@D_Parms              A(Parm list)\n         BRAS  R14,T00010               Go free VLDs\n\n*---------------------------------------------------------------------*\n*     If we have found any UCBs, exit with a return code of 0         *\n*---------------------------------------------------------------------*\n         ICM   R15,B'1111',@_VolTbl_Ptr Any VolTbl?\n         JZ    D80010                   No, exit with error\n         ICM   R15,B'1111',VolTbl_Hdr_Vols_Total-VolTbl_Hdr(R15) Vols?\n         JZ    D80010                   No, exit with error\n         LA    R15,0                    Clear return code\n         J     D90010                   and exit\n\nD80010   DS    0H\n*---------------------------------------------------------------------*\n*   We couldnt find any UCBs - set the return code and exit           *\n*---------------------------------------------------------------------*\n         LA    R15,4                    No UCBs returned\n         J     D90010                   and exit\n\nD90010   DS    0H\n*---------------------------------------------------------------------*\n*    Free up our local storage ...                                    *\n*---------------------------------------------------------------------*\n         LR    R3,R15                   Save return code\n\n         LA    R1,@D_Dynam              A(Local storage)\n         L     R2,@D_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         L     R13,4(0,R13)             Rescue A(HSA)\n\n         SSCSTACK POP,                  Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=(R2)                on this stack\n\n         LR    R15,R3                   Restore return code\n\n*-------------------------------------------------------------------*\n*    ... and return to caller                                       *\n*-------------------------------------------------------------------*\n         L     R14,12(0,R13)            Restore return address\n         LM    R0,R12,20(R13)           Restore other registers\n         BSM   0,R14                    and return\n\nD_Literals  DS  0H\n\nD_MVC    MVC   0(0,R1),0(R15)           Move STORGRP\nD_MVC1   MVC   VolTbl_Ent_Display(0),2(R15)  Move Stats line\n\nD_CLC    CLC   0(0,R14),0(R15)          UCBTBYT4 vs DCEOBRDT\n\nD_TrTbl  DC    256AL1(*-D_TrTbl)\n         ORG   D_TrTbl+X'FF'\n         DC    C'*'\n         ORG   ,\n\nD_TRTAB  EQU   *-X'F0'\n         DC    C'0123456789ABCDEF'\n\nD_TIME   TIME  LINKAGE=SYSTEM,          Get the time                   +\n               MF=L                      keep ourselves reentrant\nD_TIME_Length  EQU *-D_TIME\n\n\nD_CHPID_Msg  DC CL(L'VolTbl_Ent_CHPIDs)' $:Phys unavail, -:Log unavail'\n\nD_Stats_Line_Ptrs     EQU   *\n                      DC    AL4(D_Stats_Line1-2)\n                      DC    AL4(D_Stats_Line2-2)\n                      DC    AL4(D_Stats_Line3-2)\n                      DC    AL4(D_Stats_Line4-2)\n                      DC    AL4(D_Stats_Line5-2)\n                      DC    AL4(D_Stats_Line6-2)\n                      DC    AL4(D_Stats_Line7-2)\n                      DC    AL4(D_Stats_Line8-2)\n                      DC    AL4(D_Stats_Line9-2)\n                      DC    AL4(D_Stats_Line10-2)\n                      DC    AL4(D_Stats_Line11-2)\nD_Stats_Line_Count    EQU   (*-D_Stats_Line_Ptrs)/4\n\n                      DC    AL2(D_Stats_Line1_End-D_Stats_Line1)\nD_Stats_Line1         EQU   *\n                      DC    C'&PGMNAME '\n                      DC    C'&VERSION'\n                      DC    C' '\nD_Stats_Line1_Data    EQU   *\n                      DC    C'assembled on '\n                      DC    C'&ASMDT'\n                      DC    C' at '\n                      DC    C'&ASMTM'\n                      DC    C' under '\n                      DC    C'&SYSTEM_ID'\nD_Stats_Line1_End     EQU   *\n\n                      DC    AL2(D_Stats_Line2_End-D_Stats_Line2)\nD_Stats_Line2         EQU   *\n                      DC    CL(D_Stats_Line1_Data-D_Stats_Line1)' '\n                      DC    C'with '\n                      DC    C'&SYSASM'\n                      DC    C' '\n                      DC    C'&SYSVER'\n                      DC    C'.'\nD_Stats_Line2_End     EQU   *\n\n                      DC    AL2(D_Stats_Line3_End-D_Stats_Line3)\nD_Stats_Line3         EQU   *\n                      DC    CL(D_Stats_Line1_Data-D_Stats_Line1)' '\n                      DC    C'executing on '\nD_Stats_Line3_Date    DC    CL10' '\n                      DC    C' at '\nD_Stats_Line3_Time    DC    CL5' '\n                      DC    C' under '\nD_Stats_Line3_SysVer  DC    CL(L'ECVTPNAM+2+1+L'ECVTPVER+1+L'ECVTPREL+1+\n               +L'ECVTPMOD)' '\nD_Stats_Line3_End     EQU   *\n\n                      DC    AL2(D_Stats_Line4_End-D_Stats_Line4)\nD_Stats_Line4         EQU   *\n                      DC    CL(D_Stats_Line1_Data-D_Stats_Line1)' '\n                      DC    C'on '\nD_Stats_Line4_SNAME   DC    CL(L'CVTSNAME)' '\n                      DC    C' '\n                      DC    CL(12+L'CPCND_MAN+L'CPCND_TYPE+L'CPCND_MODE+\n               L)' '\nD_Stats_Line4_End     EQU   *\n\n                      DC    AL2(D_Stats_Line5_End-D_Stats_Line5)\nD_Stats_Line5         EQU   *\n                      DC    CL(D_Stats_Line1_Data-D_Stats_Line1)' '\n                      DC    C'Installation Defaults'\nD_Stats_Line5_End     EQU   *\n\n                      DC    AL2(D_Stats_Line6_End-D_Stats_Line6)\nD_Stats_Line6         EQU   *\n                      DC    CL(D_Stats_Line1_Data-D_Stats_Line1)' '\n                      DC    C' ISPF Output by default      : '\n         AIF   (&ISPF_by_Default).D_Stats_Line6_010\n                      DC    C'N'\n         AGO   .D_Stats_Line6_020\n.D_Stats_Line6_010  ANOP\n                      DC    C'Y'\n.D_Stats_Line6_020  ANOP\nD_Stats_Line6_End     EQU   *\n\n                      DC    AL2(D_Stats_Line7_End-D_Stats_Line7)\nD_Stats_Line7         EQU   *\n                      DC    CL(D_Stats_Line1_Data-D_Stats_Line1)' '\n                      DC    C' ISPF Output type            : '\n                      DC    C'&ISPF_Default_Type'\nD_Stats_Line7_End     EQU   *\n\n                      DC    AL2(D_Stats_Line8_End-D_Stats_Line8)\nD_Stats_Line8         EQU   *\n                      DC    CL(D_Stats_Line1_Data-D_Stats_Line1)' '\n                      DC    C' Max LSPACE Wait (Foreground): '\n         AIF   (&Fore_LSPACE_Wait EQ 0).D_Stats_Line8_010\n                      DC    C'&Fore_LSPACE_Wait'\n                      DC    C' secs.'\n         AGO   .D_Stats_Line8_020\n.D_Stats_Line8_010  ANOP\n                      DC    C'None'\n.D_Stats_Line8_020  ANOP\nD_Stats_Line8_End     EQU   *\n\n                      DC    AL2(D_Stats_Line9_End-D_Stats_Line9)\nD_Stats_Line9         EQU   *\n                      DC    CL(D_Stats_Line1_Data-D_Stats_Line1)' '\n                      DC    C' Max LSPACE Wait (Background): '\n         AIF   (&Back_LSPACE_Wait EQ 0).D_Stats_Line9_010\n                      DC    C'&Back_LSPACE_Wait'\n                      DC    C' secs.'\n         AGO   .D_Stats_Line9_020\n.D_Stats_Line9_010  ANOP\n                      DC    C'None'\n.D_Stats_Line9_020  ANOP\nD_Stats_Line9_End     EQU   *\n\n                      DC    AL2(D_Stats_Line10_End-D_Stats_Line10)\nD_Stats_Line10        EQU   *\n                      DC    CL(D_Stats_Line1_Data-D_Stats_Line1)' '\n                      DC    C' Default number of SubTasks  : '\n         AIF   (&Default_SubTask_Count EQ 0).D_Stats_Line10_010\n                      DC    C'&Default_SubTask_Count'\n         AGO   .D_Stats_Line10_020\n.D_Stats_Line10_010 ANOP\n                      DC    C'Dynamic'\n.D_Stats_Line10_020 ANOP\nD_Stats_Line10_End    EQU   *\n\n                      DC    AL2(D_Stats_Line11_End-D_Stats_Line11)\nD_Stats_Line11        EQU   *\n                      DC    CL(D_Stats_Line1_Data-D_Stats_Line1)' '\n                      DC    C' Maximum number of SubTasks  : '\n         AIF   (&Max_SubTask_Count EQ 0).D_Stats_Line11_010\n                      DC    C'&Max_SubTask_Count'\n         AGO   .D_Stats_Line11_020\n.D_Stats_Line11_010 ANOP\n                      DC    C'None'\n.D_Stats_Line11_020 ANOP\nD_Stats_Line11_End    EQU   *\n\n\n         LTORG\n\nD_Literals_End  DS  0H\n\n@D_Dynam                  DSECT       Dynamic area for D00000\n                          DS    18F    O/S Style save area\n@D_31Bit_Stack_Ptr_Ptr    DS    AL4    A(31-bit Stack Ptr)\n@D_24Bit_Stack_Ptr_Ptr    DS    AL4    A(24-bit Stack Ptr)\n@D_DBLWD                  DS    D      Doubleword work area\n@D_WkArea                 DS    CL12   EDit Word Area\n@D_UCBNAME                DS    CL4    UCB name\n@D_UNITA                  DS    AL4    A(UCB Table from EDTINFO\n@D_Volume_Count           DS    FL4    Nbr vols in the table\n@D_IECDDEVT_Ptr           DS    AL4    A(SYS1.NUCLEUS(IECDDEVT))\n@D_VLD_Anchor             DS    DL8    A(Start of SMS SG VLDs)\n@D_SMS_Ptrs               DS    2AL4   A(STORGRP, SMS Status)\n@D_R00010_Word            DS    FL4    A word for R00010\n                          DS    X      Flag byte\n@D_Eligible_UCB_Found     EQU   *-1,X'80' 1... .... At least 1 UCB\n@D_UCB_Addr_Updated       EQU   *-1,X'40' .1.. .... 4 --> 3 byte addr\n@D_Single_Volser          EQU   *-1,X'20' ..1. .... Specific Volser\n@D_SMS_Unavail            EQU   *-1,X'10' ...1 .... SMS not available\n@D_SMS_Ptrs_OK            EQU   *-1,X'08' .... 1... SMS data valid\n@D_CHPID_Unavail          EQU   *-1,X'04' .... .1.. CHP unavail\n                          DS    0F     Alignment\n@D_IOCT                   DS    CL48   IOC Token area for UCBSCAN\n\n                          DS    0F      Alignment\n@D_UCBSCAN_WorkArea       DS    CL100   UCBSCAN Work Area\n                          ORG   @D_UCBSCAN_WorkArea\n@D_CSRSI_Manuf            DS    CL(L'SI11V1CPCMANUFACTURER)\n@D_CSRSI_Type             DS    CL(L'SI11V1CPCTYPE)\n@D_CSRSI_Model            DS    CL(L'SI11V1CPCMODEL)\n@D_CSRSI_Serial           DS    CL4\n                          ORG   ,\n\n@D_Macro                  DS    0D     Macros\n                          EDTINFO MF=(L,@D_EDTINFO) EDTINFO L-Form\n                          ORG   @D_Macro\n                          IOCINFO MF=(L,@D_IOCINFO) IOCINFO L-Form\n                          ORG   @D_Macro\n                          UCBINFO MF=(L,@D_UCBINFO)\n@D_UCBINFO_Data           DS    XL256\n                          ORG   @D_Macro\n                          UCBSCAN MF=(L,@D_UCBSCAN) UCBSCAN L-Form\n                          DS    0F     Alignment\n@D_UCB                    DS    XL48   UCB Copy from UCBSCAN\n                          DS    0F     Alignment\n@D_DCE_Length             DS    XL2    DCE Area length\n@D_DCE                    DS    XL48   DCE Copy from UCBSCAN\n                          ORG   @D_Macro\n@D_SMS_Temp_StorGrp       DS    CL(L'VLDSTGRP)\n                          ORG   @D_Macro\n@D_TIME                   DS    CL(D_TIME_Length)   TIME Macro area\n                          DS    0D\n@D_Time_Area              DS    XL16   Data returned by TIME\n                          ORG   @D_Macro\n                          DS    0F\n@D_CSRSI_Parm             DS    4FL4   Parms for CSRSI\n                          ORG   ,      End of Macros\n\n@D_Parms                  DS    0F     Parms for called rtns\n@D_Parms_Std              DS    3AL4    Standard 3 parms\n@D_Parms_Extra            EQU   *       Extra parms\n@D_Parms_R00010           DS    5AL4       for R00010\n                          ORG   @D_Parms_Extra\n@D_Parms_T00010           DS    2AL4       for T00010\n                          ORG   ,\n                          DS    0D          Alignment\n@D_Dynam_Length           EQU   *-@D_Dynam Length of storage\n\n&PGMNAME CSECT\n\n         DROP  ,\n         POP   USING\n         TITLE 'E00010: Manage LSPACE SubTasks'\n         PUSH  USING\n\nE00010   DS    0H\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Routine   : E00010                                                 *\n*                                                                     *\n*  Abstract  : ATTACH and DETACH LSPACE Subtasks (H00010)             *\n*                                                                     *\n*  Inputs    : R1 : ---> A(@_Dynam)                                   *\n*                        A(31-bit Stack Pointer)                      *\n*                        A(24-bit Stack Pointer)                      *\n*  Outputs   : R15: 0 - OK                                            *\n*                   4 - No valid LSPACE data retrieved                *\n*                                                                     *\n*  Notes     :                                                        *\n*                                                                     *\n*  History:    1990/06/11 SDDA030 - New                               *\n*              1997/05/16 SDDA030 - ATTACHed subtasks to issue LSPACE *\n*                                   so that we don't wait forever for *\n*                                   devices that are constantly busy. *\n*              1998/09/17 SDDA030 - V2.0                              *\n*                                 - Corrected logic error where some  *\n*                                   STIMERMs were not being CANCELled *\n*                                 - Used Compare-and-Swap in pseudo-  *\n*                                   POST processing, rather than      *\n*                                   blindly ORing POST bit if no WAIT *\n*                                   was present (E00390).             *\n*                                 - Moved STIMERMs from this routine  *\n*                                   To H00010.                        *\n*                                 - Pass A(Volume Table) to H00010    *\n*                                   rather than individual entries    *\n*                                   within the table.                 *\n*              1999/03/03 SDDA030 - V2.5                              *\n*                                 - Added Version and Assembly info   *\n*                                   to statistics display             *\n*              1999/05/27 SDDA030 - V2.6                              *\n*                                 - Used LIFO Stack for our dynamic   *\n*                                   areas.                            *\n*              1999/07/30 SDDA030 - V2.7                              *\n*                                 - Added SubTask CPU time to         *\n*                                   statistics display                *\n*              1999/08/20 SDDA030 - V2.8                              *\n*                                 - Added SubTask Wait time to        *\n*                                   statistics display                *\n*              1999/09/01 SDDA030 - V2.9                              *\n*                                 - Passed totals fields as part of   *\n*                                   SubTask_Area, and totalled them   *\n*                                   after all subtasks complete.      *\n*              1999/09/30 SDDA030 - V2.10                             *\n*                                 - Inserted total volume count in the*\n*                                   Totals line                       *\n*              2000/01/19 SDDA030 - V2.11                             *\n*                                 - Created stats line for 24-bit     *\n*                                   stack.                            *\n*                                 - Reserved space for the Stack stats*\n*                                   lines, but deferred filling in    *\n*                                   values until they get output, in  *\n*                                   F00010.                           *\n*              2000/05/23 SDDA030 - V2.12                             *\n*                                 - Removed code that worried about   *\n*                                   subtasks that timed out.          *\n*                                 - Trimmed parm list passed to H00010*\n*                                 - Updated Stats lines to remove     *\n*                                   WAIT time data, and replace with  *\n*                                   APF authorization msg.            *\n*              2001/02/01 SDDA030 - V2.13                             *\n*                                 - Reset Parm list passed to H00010  *\n*                                 - Re-added WAIT stuff to stats line.*\n*                                 - Added IKJEFTSR re-invocation if   *\n*                                   we are not APFd.                  *\n*                                 - Moved CPU used stuff to V00010.   *\n*                                 - Made ourselves non-swappable while*\n*                                   daughter tasks active.            *\n*              2001/02/26 SDDA030 - V2.14                             *\n*                                 - Added VTOCIX and Frag Index info. *\n*                                 - Added call to U0010 to format     *\n*                                   detail and total lines.           *\n*                                 - Issue WAIT for @_MaxTasks ECBs,   *\n*                                   rather than for 1 ECB.            *\n*                                 - Acquired H00010 work area from the*\n*                                   stack.                            *\n*              2001/11/12 SDDA030 - V2.15                             *\n*                                   Passed STIMERM Wait time factor   *\n*                                   (based on #SubTasks/#LPs) to      *\n*                                   H00010.                           *\n*                                 - Checked Assembler version when    *\n*                                   generating our assembly time      *\n*                                   stamp.                            *\n*              2002/03/11 SDDA030 - V2.17                             *\n*                                 - If we will be using only 1 subtask*\n*                                   BASR rather than ATTACH           *\n*                                 - Used E_Stats_Line2 to verify that *\n*                                   IKJEFTSR invoked the same version *\n*                                   as was originally invoked.        *\n*              2002/06/11 SDDA030 - V2.18                             *\n*                                 - If OW48527 installed, don't WAIT  *\n*                                   for subtasks to terminate         *\n*                                 - Moved various fields passed to    *\n*                                   subtasks into VolTbl              *\n*              2002/08/08 SDDA030 - V2.19                             *\n*                                 - If we can't dispatch subtasks,    *\n*                                   POST entries and table as done.   *\n*              2003/01/16 SDDA030 - V2.20                             *\n*                                 - Correct bug when eliminating sub- *\n*                                   task stats if we aren't APF'd.    *\n*              2003/10/07 SDDA030 - V2.21                             *\n*                                 - Always ATTACH with ECB=, DETACH   *\n*                                   done in S00010.                   *\n*                                 - BRAS instead of ATTACHX H00010 if *\n*                                   only 1 vol, instead of only 1     *\n*                                   subtask.                          *\n*              2006/04/21 SDDA030 - V2.24                             *\n*                                 - IDENTIFY H00010 with a unique name*\n*                                   (based on TCB address) so we can  *\n*                                   run multiple copies simultaneously*\n*                                 - Used standardized calling sequence*\n*              ____/__/__ _______ -                                   *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         STM   R14,R12,12(R13)          Save callers registers\n         LARL  R11,E_Literals           Point to our literals\n         USING (E_Literals,E_Literals_End),R11 Tell the assembler\n\n         L     R12,0(0,R1)              A(@_Dynam)\n         USING @_Dynam,R12              Tell the assembler\n\n*-------------------------------------------------------------------*\n*    Get an area on the stack for our local storage                 *\n*-------------------------------------------------------------------*\n         L     R2,4(0,R1)               A(31-bit stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         SSCSTACK PUSH,                 Get stack area                 +\n               LEN=@E_Dynam_Length,      this long                     +\n               STACK=(R2)                using this stack\n\n         LR    R3,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LHI   R1,@E_Dynam_Length        Its length\n         LA    R14,0                    Clear source address\n         LA    R15,0                     and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R3                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*-------------------------------------------------------------------*\n         ST    R13,4(0,R1)              Chain\n         ST    R1,8(0,R13)               saveareas\n         LR    R13,R1                   Load dynam base\n         USING @E_Dynam,R13             Assign a base\n         L     R15,@E_Dynam+4           Get A(HSA)\n         LM    R0,R3,20(R15)            Restore callers registers\n\n         L     R15,4(0,R1)              A(31-bit Stack Pointer)\n         ST    R15,@E_31Bit_Stack_Ptr_Ptr Save it\n         L     R15,8(0,R1)              A(24-bit Stack Pointer)\n         ST    R15,@E_24Bit_Stack_Ptr_Ptr Save it\n\n*--------------------------------------------------------------------*\n*   Initialize our standard parmlist                                 *\n*--------------------------------------------------------------------*\n         LA    R15,@_Dynam              A(Dynamic area)\n         ST    R15,@E_Parms_Std         Save it\n         L     R15,@E_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)\n         ST    R15,@E_Parms_Std+4       Save it\n         L     R15,@E_24Bit_Stack_Ptr_Ptr A(24-bit Stack Pointer)\n         ST    R15,@E_Parms_Std+8       Save it\n\n*---------------------------------------------------------------------*\n*     Check that, in fact, we have something to do.                   *\n*---------------------------------------------------------------------*\n         ICM   R15,B'1111',@_VolTbl_Ptr A(VolTbl)\n         JZ    E80010                   None, exit with error\n         ICM   R15,B'1111',VolTbl_Hdr_Vols_Total-VolTbl_Hdr(R15)\n         JZ    E80010                   No volumes, exit with error\n         TM    @_No_LSPACE,L'@_No_LSPACE Yes, should we issue LSPACEs?\n         JO    E00230                   No, all done\n\n         TM    @_OW48527,L'@_OW48527    Yes, is OW48527 present?\n         JO    E00100                   Yes, OK\n\n*---------------------------------------------------------------------*\n*     We must be APF-Authorized to do our stuff. If we aren't, we     *\n*    re-invoke ourselves via IKJEFTSR (unless we are currently        *\n*    running as an IKJEFTSR invocation).                              *\n*---------------------------------------------------------------------*\n         TESTAUTH FCTN=1                Check APF Authorization\n         LTR   R15,R15                  Are we?\n         JNZ   E00020                   No, skip\n         TM    @_IKJEFTSR,L'@_IKJEFTSR  Yes, IKJEFTSR'd?\n         JZ    E00100                   No, OK\n\n*---------------------------------------------------------------------*\n*     We are APF'd and invoked under IKJEFTSR. Check to make sure     *\n*    that the code we are executing (under IKJEFTSR, which LOADs from *\n*    STEPLIB/LNKLST) is the same as was originally invoked as a       *\n*    command (possibly from ISPLLIB), using the time of assembly.     *\n*---------------------------------------------------------------------*\n         ICM   R15,B'1111',@_IKJEFTSR_TimeStamp_Ptr A(Callers timestmp)\n         JZ    E00010C                  Nothing, error\n         CLC   E_IKJEFTSR_TimeStamp(E_IKJEFTSR_TimeStamp_Length),0(R15)\n         JE    E00100                   Same as ours, OK\nE00010C  DS    0H\n         OI    @_SYSCLOCK_Err,L'@_SYSCLOCK_Err No, flag as an error\n         OI    @_LSPACE_Failed,L'@_LSPACE_Failed VolTbl Incomplete\n         J     E80010                   and go produce stats\n\nE00020   DS    0H\n         TM    @_IKJEFTSR,L'@_IKJEFTSR  Are we running from IKJEFTSR?\n         JZ    E00030                   No, skip\n         OI    @_No_APF,L'@_No_APF      Yes, still not authorized\n         OI    @_LSPACE_Failed,L'@_LSPACE_Failed VolTbl incomplete\n         J     E80010                   and go produce totals and stats\n\nE00030   DS    0H\n*---------------------------------------------------------------------*\n*     We are not APF'd, and not running as a result of IKJEFTSR, so   *\n*    re-invoke ourselves via IKJEFTSR.                                *\n*---------------------------------------------------------------------*\n\n*---------------------------------------------------------------------*\n*     Initialize our flags for IKJEFTSR                               *\n*---------------------------------------------------------------------*\n         LA    R15,E_IKJEFTSR_Flags     Point to our flags\n         ST    R15,@E_IKJEFTSR_Parms    Save it\n\n*---------------------------------------------------------------------*\n*     Use the program name as found from the PRB.                     *\n*---------------------------------------------------------------------*\n         L     R14,PSATNEW-PSA(0)       Get A(our TCB)\n         SLL   R14,8                    Clean\n         SRL   R14,8                      it\n         L     R15,TCBRBP-TCB(R14)      A(RB)\nE00050   DS    0H\n         L     R0,RBLINK-RBBASIC(R15)   A(Previous RB)\n         SLL   R0,8                     Clean\n         SRL   R0,8                       it\n         CR    R0,R14                   Last RB (RBLINK = A(TCB))?\n         JE    E00060                   Yes, skip\n         LR    R15,R0                   No, point to previous RB\n         J     E00050                   and keep trying\nE00060   DS    0H\n         LA    R14,0                    Get pointer to\n         ICM   R14,B'0111',RBCDE1-RBBASIC(R15)  our CDE\n         MVC   @E_IKJEFTSR_PgmName,CDNAME-CDENTRY(R14)  Move pgm name\n         LA    R15,@E_IKJEFTSR_PgmName  A(Program name)\n         ST    R15,@E_IKJEFTSR_Parms+4  Save it\n\n*---------------------------------------------------------------------*\n*     Length of the program name                                      *\n*---------------------------------------------------------------------*\n         LA    R15,@E_IKJEFTSR_PgmName+L'@E_IKJEFTSR_PgmName-1\nE00070   DS    0H\n         CLI   0(R15),C' '              Trailing blank?\n         JNE   E00080                   No, skip\n         BRCT  R15,E00070               Yes, keep checking\nE00080   DS    0H\n         LA    R14,@E_IKJEFTSR_PgmName-1 Calculate length\n         SR    R15,R14                   of program name\n         ST    R15,@E_IKJEFTSR_PgmName_Length  Save it\n         LA    R15,@E_IKJEFTSR_PgmName_Length A(Length)\n         ST    R15,@E_IKJEFTSR_Parms+8   Save it\n\n*---------------------------------------------------------------------*\n*     Pointers to the Return Code, Reason Code and ABEND Code areas.  *\n*---------------------------------------------------------------------*\n         LA    R15,@_IKJEFTSR_RC        A(Return Code Area)\n         ST    R15,@E_IKJEFTSR_Parms+12  Save it\n\n         LA    R15,@_IKJEFTSR_Reas      A(Reason Code Area)\n         ST    R15,@E_IKJEFTSR_Parms+16  Save it\n\n         LA    R15,@E_IKJEFTSR_ABEND     A(ABEND Code Area)\n         ST    R15,@E_IKJEFTSR_Parms+20  Save it\n\n*---------------------------------------------------------------------*\n*     Pointers to the parms we will be passing to ourselves           *\n*---------------------------------------------------------------------*\n         LA    R15,@E_IKJEFTSR_Pgm_Parm_Ptrs A(Parms for the Pgm)\n         ST    R15,@E_IKJEFTSR_Parms+24  Save it\n         OI    @E_IKJEFTSR_Parms+24,X'80' Flag as last parm\n\n         LA    R15,@E_IKJEFTSR_Pgm_Parm1 A(Pgm Parm 1) - A(@_Dynam)\n         ST    R15,@E_IKJEFTSR_Pgm_Parm_Ptrs Save it\n\n*---------------------------------------------------------------------*\n*     Point to our timestamp, which contains the assembly date,       *\n*    time and version. This will be used by the version of SPACE      *\n*    invoked by IKJEFTSR to ensure that the same code is running.     *\n*---------------------------------------------------------------------*\n         LA    R15,E_IKJEFTSR_TimeStamp A(Interesting assembly stats)\n         ST    R15,@_IKJEFTSR_TimeStamp_Ptr Save it\n\n*---------------------------------------------------------------------*\n*     And finally the parms themselves:                               *\n*       HL2'4',AL4(@_Dynam)                                           *\n*       HL2'16',1st 16 bytes of @_Dynam                               *\n*---------------------------------------------------------------------*\n         LHI   R15,4                    Length of an address\n         STH   R15,@E_IKJEFTSR_Pgm_Parm1 Save it\n         LA    R15,@_Dynam              A(Dynamic area)\n         ST    R15,@E_IKJEFTSR_Pgm_Parm1+2 Save it\n\n         LA    R15,@E_IKJEFTSR_Pgm_Parm2 A(Pgm Parm 1) - A(@_Dynam)\n         ST    R15,@E_IKJEFTSR_Pgm_Parm_Ptrs+4 Save it\n         OI    @E_IKJEFTSR_Pgm_Parm_Ptrs+4,X'80'  Last one\n\n         LA    R15,L'@E_IKJEFTSR_Pgm_Parm2-2 Length of data\n         STH   R15,@E_IKJEFTSR_Pgm_Parm2 Save it\n         MVC   @E_IKJEFTSR_Pgm_Parm2+2(L'@E_IKJEFTSR_Pgm_Parm2-2),@_Dyn+\n               am\n\n*---------------------------------------------------------------------*\n*     Re-invoke ourselves via IKJEFTSR so that we are (hopefully)     *\n*    APF-authorized.                                                  *\n*---------------------------------------------------------------------*\n         LA    R1,@E_IKJEFTSR_Parms     A(IKJEFTSR Parm List)\n         L     R15,CVTPTR               A(CVT)\n         L     R15,CVTTVT-CVT(R15)      A(TSVT)\n         L     R15,TSVTASF-TSVT(R15)    A(IKJEFTSR)\n         BASR  R14,R15                  Go do it\n\n*---------------------------------------------------------------------*\n*     Save the return code from IKJEFTSR, so if something went wrong, *\n*    we can tell somebody.                                            *\n*---------------------------------------------------------------------*\n         ST    R15,@_IKJEFTSR_RC        Save Return Code\n         CHI   R15,4                    How did it go?\n         JNH   E00090                   OK, skip\n         OI    @_IKJEFTSR_Err,L'@_IKJEFTSR_Err  Flag an error\n         OI    @_LSPACE_Failed,L'@_LSPACE_Failed VolTbl not filled in\n         J     E80010                   and clean up VolTbl\nE00090   DS    0H\n\n         LA    R15,0                    Clear return code\n         J     E90010                   and exit\n\nE00100   DS    0H\n*---------------------------------------------------------------------*\n*     OK, now we can start the real work,                             *\n*                                                                     *\n*     Set up to ATTACH the tasks to actually issue the LSPACE.        *\n*    We do this so that if one subtask gets hung up on a RESERVEd     *\n*    device, the other subtasks can still retrieve LSPACE info.       *\n*                                                                     *\n*     First, IDENTIFY the routine (H00010) we will ATTACH ...         *\n*---------------------------------------------------------------------*\n         L     R15,@_VolTbl_Ptr        A(Volume Table)\n         L     R15,VolTbl_Hdr_Count-VolTbl(R15) Get number of volumes\n         CHI   R15,1                   Doing more than 1?\n         JNH   E00160                  No, no need to IDENTIFY\n         L     R0,PSATNEW-PSA(0)       Yes, get A(our TCB)\n         SLL   R0,4                    Make room for 'sign'\n         ST    R0,@E_DBLWD+4           Save it\n         OI    @E_DBLWD+7,X'0F'        Pack it\n         UNPK  @E_H00010_IDENTIFY_ID+1(7),@E_DBLWD+4(4) Unpack it\n         LA    R15,E_Hex_TrTab         A(Translate Table)\n         AHI   R15,-240                adjust it\n         TR    @E_H00010_IDENTIFY_ID+1(7),0(R15) Make it readable\n         MVI   @E_H00010_IDENTIFY_ID,C'H' Init 1st char\n         LARL  R1,H00010               A(Our routine)\n         IDENTIFY EPLOC=@E_H00010_IDENTIFY_ID, and let MVS know        +\n               ENTRY=(1)                about it\n\nE00160   DS    0H\n*---------------------------------------------------------------------*\n*    Initialize our timer total, and the number of completed subtasks.*\n*    These are used to 'heuristically' set the timer values for the   *\n*    STIMERMs used in H00010 ...                                      *\n*---------------------------------------------------------------------*\n         LA    R0,0                    Clear work register\n         ICM   R15,B'1111',@_VolTbl_Ptr A(VolTbl)\n         JZ    E80010                  Nothing, exit quick smart\n         ST    R0,VolTbl_Hdr_LSPACE_Avg-VolTbl_Hdr(R15)\n         ST    R0,VolTbl_Hdr_LSPACE_Avg+4-VolTbl_Hdr(R15)\n\n*---------------------------------------------------------------------*\n*    Calculate the STIMERM Adjustment factor, based on the ratio of   *\n*    SubTasks to Logical Processors - this is used to try to prevent  *\n*    false RESERVEd messages when dispatching a lot of subtasks on    *\n*    a few LPs (we should really take processor speed and weights     *\n*    into account as well, but we don't know how).                    *\n*                                                                     *\n*    We arbitrarily calculate it as:                                  *\n*     ((#Subtasks/#LPs)/4)                                            *\n*---------------------------------------------------------------------*\n         L     R15,@_SubTask_Count      Get MaxTasks\n         LA    R14,0                    Clear other part of dividend\n         D     R14,@_LP_Count           Get ratio of Subtasks to LPs\n         SRL   R15,2                    divided by 4\n         LTR   R15,R15                  Anything?\n         JNZ   E00170                   Yes, OK\n         LHI   R15,1                    No, default to 1\nE00170   DS    0H\n         L     R14,@_VolTbl_Ptr         A(VolTbl)\n         ST    R15,VolTbl_Hdr_STIMERM_Adj-VolTbl_Hdr(R14) Save it\n\n*---------------------------------------------------------------------*\n*     Initialize the fields related to LSPACE timeouts                *\n*---------------------------------------------------------------------*\n         OI    VolTbl_Hdr_OW48527-VolTbl_Hdr(R14),L'VolTbl_Hdr_OW48527\n         MVC   VolTbl_Hdr_MaxLWait-VolTbl_Hdr(L'VolTbl_Hdr_MaxLWait,R14+\n               ),@_MaxLWait\n\n*---------------------------------------------------------------------*\n*     Lower our dispatching priority, so that we can ATTACH our       *\n*    subtasks with our original (higher) priority (most of the elap-  *\n*    sed time in the subtasks is spent WAITing for LSPACE).           *\n*---------------------------------------------------------------------*\n         TM    @_CHAP_Done,L'@_CHAP_Done Have we already CHAPped?\n         JO    E00170A                  Yes, skip\n         CHAP  -1,'S'                   No, do it now\n         OI    @_CHAP_Done,L'@_CHAP_Done and set our flag\n\nE00170A  DS    0H\n*---------------------------------------------------------------------*\n*     ... and get some storage for our ATTACHed tasks, as described   *\n*    in the SubTask_Area DSECT.                                       *\n*---------------------------------------------------------------------*\n         L     R0,@_SubTask_Count       Number of SubTasks\n         MHI   R0,SubTask_Area_Ent_Length * length per sub-task\n         AHI   R0,SubTask_Area_Hdr_Length + header length\n\n         BASR  R2,0\n         USING (*,E00170C_End-1),R2\n         STORAGE OBTAIN,                Go get some storage            +\n               LENGTH=(0)                this long\nE00170C_End DS  0H\n         DROP  R2\n\n         ST    R1,@_SubTask_Area_Ptr    Save its address\n         ST    R0,SubTask_Area_Hdr_Len-SubTask_Area(R1)  Save length\n         L     R0,@_SubTask_Count       Number of SubTasks\n         ST    R0,SubTask_Area_Hdr_Count-SubTask_Area(R1) Save #\n\n         TM    @_OW48527,L'@_OW48527    Yes, is OW48527 present?\n         JO    E00170E                  Yes, OK\n\n*---------------------------------------------------------------------*\n*    Set ourselves non-swappable - if we are swappable, and we get    *\n*   hung up on a RESERVEd volume, SRM will try to swap us out. To do  *\n*   do, (s)he must terminate our I/O, and while (s)he is trying to do *\n*   this, any asychronous processing (such as STIMERM Exits) will be  *\n*   suppressed. In our case, it is the STIMERM Exit that will allow   *\n*   the I/O to be terminated, so we have to run non-swappable.        *\n*                                                                     *\n*    Note that we issue STAX DEFER before we do this (STAX in a       *\n*   non-TSO environment seems to be benign).                          *\n*---------------------------------------------------------------------*\n         MVC   @E_TIME,E_TIME           MOVE Time macro\n         TIME  STCK,                    Get the current time           +\n               @E_Time_Area,             return it here                +\n               LINKAGE=SYSTEM,           as recommended by IBM         +\n               MF=(E,@E_TIME)            staying re-entrant\n         MVC   @E_NSwap_Start,@E_Time_Area  Save DONTSWAP TOD\n\n         MVC   @E_STAX,E_STAX           Move STAX Macro\n         STAX  DEFER=YES,               Defer Attentions               +\n               MF=(E,@E_STAX)            staying re-entrant\n\n         SYSEVENT DONTSWAP              Make ourselves non-swappable\n\nE00170E  DS    0H\n*---------------------------------------------------------------------*\n*     Point to our ECBLIST area ...                                   *\n*---------------------------------------------------------------------*\n         L     R10,@_SubTask_Area_Ptr   A(SubTask_Area)\n         AHI   R10,SubTask_Area_Hdr_Length Point past header\n         L     R8,@_SubTask_Count       Get number we have to do\n\n*---------------------------------------------------------------------*\n*    ... initialize the area for each sub-task ...                    *\n*---------------------------------------------------------------------*\nE00180   DS    0H\n         XC    0(SubTask_Area_Ent_Length,R10),0(R10)  Clear entry\n\n*---------------------------------------------------------------------*\n*    ... set up the parm list for the subtask ...                     *\n*---------------------------------------------------------------------*\n         LA    R15,@_Dynam              A(Dynamic area)\n         ST    R15,SubTask_Area_Ent_Parms-SubTask_Area_Ent(R10)\n         L     R15,@E_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)\n         ST    R15,SubTask_Area_Ent_Parms+4-SubTask_Area_Ent(R10)\n         L     R15,@E_24Bit_Stack_Ptr_Ptr A(24-bit Stack Pointer)\n         ST    R15,SubTask_Area_Ent_Parms+8-SubTask_Area_Ent(R10)\n         L     R15,@_VolTbl_Ptr          A(VolTbl)\n         ST    R15,SubTask_Area_Ent_Parms+12-SubTask_Area_Ent(R10)\n\n         LA    R1,SubTask_Area_Ent_Parms-SubTask_Area_Ent(R10)\n\n*---------------------------------------------------------------------*\n*    ... and ATTACH (or BASR, if we are doing only 1 volume).         *\n*---------------------------------------------------------------------*\n         L     R15,@_VolTbl_Ptr         A(Volume Table)\n         L     R15,VolTbl_Hdr_Count-VolTbl(R15) Get number of volumes\n         CHI   R15,1                    Doing more than 1?\n         JH    E00190                   Yes, use ATTACH\n         BRAS  R14,H00010               No, just go do it\n         OI    SubTask_Area_Ent_ECB-SubTask_Area_Ent(R10),X'40' Done\n         LA    R1,0                     Clear 'TCB pointer'\n         J     E00200                   and skip\n\nE00190   DS    0H\n         MVC   @E_ATTACHX,E_ATTACHX     Move ATTACH parms\n         BASR  R2,0\n         USING (*,E00190_End-1),R2\n         ATTACHX EPLOC=@E_H00010_IDENTIFY_ID,  ATTACH H00010           +\n               ECB=(10),                 POST this ECB when complete   +\n               SZERO=YES,                Share SubPool 0               +\n               ASYNCH=YES,               Allow subtask asynch exits    +\n               DPMOD=1,                  Run at a higher priority      +\n               MF=(E,(1)),               Parmlist area                 +\n               SF=(E,@E_ATTACHX)         keep ourselves reentrant\nE00190_End DS  0H\n         DROP  R2\n\nE00200   DS    0H\n         ST    R1,SubTask_Area_Ent_TCB-SubTask_Area_Ent(R10) A(TCB)\n\n         AHI   R10,SubTask_Area_Ent_Length  A(next sub-task area)\n         BRCT  R8,E00180                and continue\n\n         TM    @_OW48527,L'@_OW48527    Yes, is OW48527 present?\n         JO    E00230                   Yes, all done\n\n*---------------------------------------------------------------------*\n*    WAIT for our H00010 instances to complete                        *\n*---------------------------------------------------------------------*\n         L     R0,@_SubTask_Count       Nbr ECBs to WAIT for\n         CHI   R0,1                     More than 1?\n         JNH   E00210                   No, we BASRed, not ATTACHed\n         LA    R1,@E_Parms              A(Parms)\n         BRAS  R14,S00010               Wait for our subtasks\n\nE00210   DS    0H\n*---------------------------------------------------------------------*\n*     We are done - make ourselves swappable again ...                *\n*---------------------------------------------------------------------*\n         SYSEVENT OKSWAP                We can be swapped out now\n\n         MVC   @E_STAX,E_STAX           Move STAX Macro\n         STAX  DEFER=NO,                Allow Attentions               +\n               MF=(E,@E_STAX)            staying re-entrant\n\n*---------------------------------------------------------------------*\n*     ... calculate the time we were non-swappable ...                *\n*---------------------------------------------------------------------*\n         MVC   @E_TIME,E_TIME           MOVE Time macro\n         TIME  STCK,                    Get the current time           +\n               @E_Time_Area,             return it here                +\n               LINKAGE=SYSTEM,           as recommended by IBM         +\n               MF=(E,@E_TIME)            staying re-entrant\n         LM    R14,R15,@E_Time_Area     Get current time\n         SL    R15,@E_NSwap_Start+4     Calculate\n         JNM   E00220                   No borrow, skip\n         SL    R14,=FL4'1'              Borrow, reduce\nE00220   DS    0H\n         SL    R14,@E_NSwap_Start       Calculate\n         STM   R14,R15,@_NSwap_Time     Save Non-Swap time\n\n*---------------------------------------------------------------------*\n*     ... and exit.                                                   *\n*---------------------------------------------------------------------*\n         J     E00230                   and skip\n\nE00230   DS    0H\n*---------------------------------------------------------------------*\n*     Clear the return code, and exit                                 *\n*---------------------------------------------------------------------*\n         LA    R15,0                    Clear return code\n         J     E90010                   and exit\n\nE80010   DS    0H\n*---------------------------------------------------------------------*\n*   We cannot, or should not, issue LSPACEs, so we will POST all the  *\n*  appropriate lines as complete ...                                  *\n*---------------------------------------------------------------------*\n         ICM   R9,B'1111',@_VolTbl_Ptr  A(Table of Volumes)\n         JZ    E80016                   Nothing, skip\n         ICM   R10,B'1111',VolTbl_Hdr_Count-VolTbl_Hdr(R9) Get count\n         JZ    E80016                   None, skip\n         AHI   R9,VolTbl_Ent-VolTbl     Point to 1st entry\nE80012   DS    0H\n         TM    VolTbl_Ent_Stats_31Stack-VolTbl_Ent(R9),L'VolTbl_Ent_Sta+\n               ts_31Stack\n         JO    E80014                   Stack Stats line, skip it\n         TM    VolTbl_Ent_Stats_24Stack-VolTbl_Ent(R9),L'VolTbl_Ent_Sta+\n               ts_24Stack\n         JO    E80014                   Stack Stats line, skip it\n         TM    VolTbl_Ent_Stats_CPUTime-VolTbl_Ent(R9),L'VolTbl_Ent_Sta+\n               ts_CPUTime\n         JO    E80014                   CPU Stats, skip it\n\n         L     R0,VolTbl_Ent_ECB-VolTbl_Ent(R9) Current ECB\n         TM    VolTbl_Ent_ECB-VolTbl_Ent(R9),X'80' Anyone WAITing?\n         JO    E80013                   Yes, we need to POST\n         L     R1,=XL4'40000000'        No, POST code of 0\n         CS    R0,R1,VolTbl_Ent_ECB-VolTbl_Ent(R9) Pseudo-POST it\n         JZ    E80014                   OK, skip the real POST\nE80013   DS    0H\n         POST  VolTbl_Ent_ECB-VolTbl_Ent(R9),0 POST line as complete\n\nE80014   DS    0H\n         AHI   R9,VolTbl_Ent_Len        A(Next entry)\n         BRCT  R10,E80012               and check again\n\n*---------------------------------------------------------------------*\n*   ... and if there are any Subtask Stats lines, get rid of them ... *\n*---------------------------------------------------------------------*\n         L     R15,@_VolTbl_Ptr         A(Volume table)\n         ICM   R1,B'1111',VolTbl_Hdr_SubT_Off-VolTbl_Hdr(R15)\n         JZ    E80016                   No SubTask stats, skip\n         AHI   R1,-VolTbl_Hdr_Length    Nbr lines\n         LA    R0,0                      excluding\n         D     R0,=AL4(VolTbl_Ent_Len)   Subtask Stats\n         ST    R1,VolTbl_Hdr_Count-VolTbl_Hdr(15) Update nbr lines\n         LA    R1,0                      and clear offset\n         ST    R1,VolTbl_Hdr_SubT_Off-VolTbl_Hdr(R15)\n\nE80016   DS    0H\n*---------------------------------------------------------------------*\n*   ... POST the table as complete ...                                *\n*---------------------------------------------------------------------*\n         ICM   R15,B'1111',@_VolTbl_Ptr A(Table of Volumes)\n         JZ    E80018                   None, skip\n         L     R0,VolTbl_Hdr_ECB-VolTbl_Hdr(R15) Current ECB\n         TM    VolTbl_Hdr_ECB-VolTbl_Hdr(R15),X'80' Anyone WAITing?\n         JO    E80017                   Yes, we need to POST\n         L     R1,=XL4'40000000'        No, POST code of 0\n         CS    R0,R1,VolTbl_Hdr_ECB-VolTbl_Hdr(R15) Pseudo-POST it\n         JZ    E80018                   OK, skip the real POST\nE80017   DS    0H\n         POST  VolTbl_Hdr_ECB-VolTbl_Hdr(R15),0 POST table as complete\n\nE80018   DS    0H\n*---------------------------------------------------------------------*\n*   ... and exit with a return code of 4.                             *\n*---------------------------------------------------------------------*\n         LA    R15,4                    Nothing good happened\n         J     E90010                   and exit\n\nE90010   DS    0H\n         LR    R3,R15                 Save return code\n\n*-------------------------------------------------------------------*\n*    DELETE H00010 (which we IDENTIFYed earlier)                    *\n*-------------------------------------------------------------------*\n         CLI   @E_H00010_IDENTIFY_ID,C'H'    Did we IDENTIFY?\n         JNO   E90020                 No, skip\n         DELETE EPLOC=@E_H00010_IDENTIFY_ID  Yes, Un-IDENTIFY\n         XC    @E_H00010_IDENTIFY_ID,@E_H00010_IDENTIFY_ID\n\nE90020   DS    0H\n*-------------------------------------------------------------------*\n*    If we are running under IKJEFTSR, update @_CPU_Time_Used       *\n*   with the time we spent (because we are running under a          *\n*   separate TCB).                                                  *\n*-------------------------------------------------------------------*\n         TM    @_OW48527,L'@_OW48527  OW48527 installed?\n         JO    E90040                 Yes, skip\n\n         TM    @_IKJEFTSR,L'@_IKJEFTSR Running because of IKJEFTSR?\n         JNO   E90040                  No, skip\n\n         TIMEUSED STORADR=@E_DBLWD,     Get CPU time used              +\n               LINKAGE=SYSTEM,           as recommended by IBM         +\n               CPU=MIC                   get it in microseconds\n         LM    R14,R15,@_CPU_Time_Used  Get current CPU Time used\n         AL    R15,@E_DBLWD+4           Bump it\n         BRC   12,E90030                No Carry, OK\n         AL    R14,=FL4'1'              Carry, bump\nE90030   DS    0H\n         AL    R14,@E_DBLWD             Bump high-order word\n         STM   R14,R15,@_CPU_Time_Used  Save CPU Time\n\nE90040   DS    0H\n*-------------------------------------------------------------------*\n*    Free up our local storage ...                                  *\n*-------------------------------------------------------------------*\n         LA    R1,@E_Dynam              A(Local storage)\n         L     R2,@E_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         L     R13,4(0,R13)             Rescue A(HSA)\n\n         SSCSTACK POP,                  Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=(R2)                on this stack\n\n*-------------------------------------------------------------------*\n*    ... and return to caller                                       *\n*-------------------------------------------------------------------*\n         LR    R15,R3                   Restore return code\n\n         L     R14,12(0,R13)            Restore return address\n         LM    R0,R12,20(R13)           Restore other registers\n         BSM   0,R14                    and return\n\nE_Literals            DS   0H\n\nE_IKJEFTSR_Flags      EQU  *            Flag bytes for IKJEFTSR\n                      DC   X'00'         Must be 0\n                      DC   X'00'         Invoke in isolated environ\n                      DC   X'01'         Dump if abend\n                      DC   X'02'         Invoking a program\n\nE_IKJEFTSR_TimeStamp  EQU  *\n                      DC   C'&PGMNAME'\n                      DC   C'&VERSION'\n                      DC   C'&SYSDATC'\n                      DC   C'&SYSTIME'\nE_IKJEFTSR_TimeStamp_Length EQU *-E_IKJEFTSR_TimeStamp\n\n\nE_TIME                TIME  LINKAGE=SYSTEM, Get the time               +\n               MF=L                      keep ourselves reentrant\nE_TIME_Length         EQU *-E_TIME\n\nE_ATTACHX             ATTACHX EP=0,     ATTACH something               +\n               ECB=0,                    POST this ECB when complete   +\n               SZERO=YES,                Share SubPool 0               +\n               ASYNCH=YES,               Allow subtask asynch exits    +\n               DPMOD=5,                  Run at a higher priority      +\n               SF=L                      keep ourselves reentrant\nE_ATTACHX_Length      EQU  *-E_ATTACHX\n\nE_STAX                STAX DEFER=YES, Suspend Attention Interrupts     +\n               MF=L                      keep ourselves reentrant\nE_STAX_Length         EQU  *-E_STAX\n\nE_Hex_TrTab           DC   C'0123456789ABCDEF'\n\n                      LTORG\n\nE_Literals_End        DS    0H\n\n\n@E_Dynam                  DSECT        Dynamic area for E00000\n                          DS    18F     O/S Style save area\n@E_31Bit_Stack_Ptr_Ptr    DS    AL4     A(31-bit Stack Ptr)\n@E_24Bit_Stack_Ptr_Ptr    DS    AL4     A(24-bit Stack Ptr)\n@E_DBLWD                  DS    D       Work area\n\n@E_NSwap_Start            DS    DL8     STCK at DONTSWAP\n\n@E_H00010_IDENTIFY_ID     DS    CL8     IDENTIFY Name\n\n@E_Macro                  DS    0D      Macros\n@E_TIME                   DS    CL(E_TIME_Length) TIME Macro area\n                          DS    0D\n@E_Time_Area              DS    XL16     Data returned by TIME\n@E_WkArea                 DS    CL10     EDit Word Area\n                          ORG   @E_Macro\n@E_ATTACHX                DS    CL(E_ATTACHX_Length) ATTACHX Macro area\n                          ORG   @E_Macro\n@E_STAX                   DS    CL(E_STAX_Length)  STAX Macro area\n                          ORG   @E_Macro\n@E_IKJEFTSR_Parms         DS    7AL4     Parm List for IKJEFTSR\n@E_IKJEFTSR_PgmName       DS    CL8      Program name\n@E_IKJEFTSR_PgmName_Length DS   FL4      Program name length\n@E_IKJEFTSR_ABEND         DS    FL4      Abend code area\n@E_IKJEFTSR_Pgm_Parm_Ptrs DS    2AL4     Pgm parm pointers\n\n@E_IKJEFTSR_Pgm_Parm1     DS    CL6      Len + A(@_Dynam)\n@E_IKJEFTSR_Pgm_Parm2     DS    CL18     Len + 16 bytes of @_Dynam\n                          ORG   ,       End of Macros\n\n@E_Parms                  DS    0F      Parms for called rtns\n@E_Parms_Std              DS    3AL4     Standard 3 parms\n                          ORG   ,\n                          DS    0D       Alignment\n@E_Dynam_Length           EQU   *-@E_Dynam      Length of storage\n\n&PGMNAME CSECT\n\n         DROP  ,\n         POP   USING\n         TITLE 'F00010: Output Results'\n\n         PUSH  USING\n\nF00010   DS    0H\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Routine   : F00010                                                 *\n*                                                                     *\n*  Abstract  : Display results of LSPACE stuff                        *\n*                                                                     *\n*  Inputs    : R1 : ---> A(@_Dynam)                                   *\n*                        A(31-bit Stack Pointer)                      *\n*                        A(24-bit Stack Pointer)                      *\n*  Outputs   : R15: 0                                                 *\n*                                                                     *\n*  Notes     : Uses the Info Table built by D00010, and               *\n*               whose address is in @_VolTbl_Ptr                      *\n*              For ISPF output,                                       *\n*                Invoke ISPF processor (G00010)                       *\n*              For a TSO Cmd,                                         *\n*               PUTLINE for each unit                                 *\n*              For a Batch job,                                       *\n*               Write to SYSPRINT for each unit                       *\n*                                                                     *\n*  History:    1990/06/11 SDDA030 - New                               *\n*              1999/05/27 SDDA030 - V2.6                              *\n*                                 - Used LIFO Stack for our dynamic   *\n*                                   areas.                            *\n*              1999/09/30 SDDA030 - V2.10                             *\n*                                 - Changed default sort order from   *\n*                                   descending volser to none.        *\n*                                 - Do STLINENO stuff and build       *\n*                                   PUTLINE CBs here instead of C00010*\n*                                 - Removed generation of Hdr1-3 in   *\n*                                   batch - now done in Y00010.       *\n*              2000/01/19 SDDA030 - V2.11                             *\n*                                 - Added SORT() keywords to F_TBLOFF.*\n*                                 - Passed sort parms to I00010 as    *\n*                                   pointers.                         *\n*                                 - Passed sort direction to I00010.  *\n*                                   Used 24-bit stack for STLINENO.   *\n*                                 - Filled in values in Stack Stats   *\n*                                   lines.                            *\n*              2000/05/23 SDDA030 - V2.12                             *\n*                                 - Added messages for:               *\n*                                    - IOSCDR unavailable             *\n*                                    - ISPF services unavailable      *\n*                                 - Split out ISPF output handling to *\n*                                   G00010.                           *\n*                                 - Invoked V00010 to update stats    *\n*                                   lines.                            *\n*              2001/02/01 SDDA030 - V2.13                             *\n*                                 - Removed IOSCDR message            *\n*                                 - Added messages for LNKLST and     *\n*                                   IJEFTSR errors.                   *\n*              2001/02/26 SDDA030 - V2.14                             *\n*                                 - Checked Terminal Line Size when   *\n*                                   doing PUTLINEs.                   *\n*              2002/06/11 SDDA030 - V2.18                             *\n*                                 - WAIT for VolTbl_Ent to be populated\n*                                   before outputting                 *\n*              2006/04/21 SDDA030 - V2.24                             *\n*                                 - Used standardized calling sequence*\n*                                 - Added 'Internal Error' and        *\n*                                   'Incompatible OS' messages.       *\n*                                 - Added 'Insufficient Storage' msg  *\n*              ____/__/__ _______                                     *\n*                                                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         STM   R14,R12,12(R13)          Save callers registers\n         LARL  R11,F_Literals           Point to our literals\n         USING (F_Literals,F_Literals_End),R11 Tell the assembler\n\n         L     R12,0(0,R1)              A(@_Dynam)\n         USING @_Dynam,R12              Tell the assembler\n\n*-------------------------------------------------------------------*\n*    Get an area on the stack for our local storage                 *\n*-------------------------------------------------------------------*\n         L     R2,4(0,R1)               A(31-bit stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         SSCSTACK PUSH,                 Get stack area                 +\n               LEN=@F_Dynam_Length,      this long                     +\n               STACK=(R2)                using this stack\n\n         LR    R3,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LHI   R1,@F_Dynam_Length        Its length\n         LA    R14,0                    Clear source address\n         LA    R15,0                     and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R3                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*-------------------------------------------------------------------*\n         ST    R13,4(0,R1)              Chain\n         ST    R1,8(0,R13)               saveareas\n         LR    R13,R1                   Load dynam base\n         USING @F_Dynam,R13             Assign a base\n         L     R15,@F_Dynam+4           Get A(HSA)\n         LM    R0,R3,20(R15)            Restore callers registers\n\n         L     R15,4(0,R1)              A(31-bit Stack Pointer)\n         ST    R15,@F_31Bit_Stack_Ptr_Ptr Save it\n         L     R15,8(0,R1)              A(24-bit Stack Pointer)\n         ST    R15,@F_24Bit_Stack_Ptr_Ptr Save it\n\n*--------------------------------------------------------------------*\n*   Initialize our standard parmlist                                 *\n*--------------------------------------------------------------------*\n         LA    R15,@_Dynam              A(Dynamic area)\n         ST    R15,@F_Parms_Std         Save it\n         L     R15,@F_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)\n         ST    R15,@F_Parms_Std+4       Save it\n         L     R15,@F_24Bit_Stack_Ptr_Ptr A(24-bit Stack Pointer)\n         ST    R15,@F_Parms_Std+8       Save it\n\n*---------------------------------------------------------------------*\n*   If everything worked OK, but we are suppressing all the output,   *\n*  we are done.                                                       *\n*---------------------------------------------------------------------*\n         ICM   R15,B'1111',@_VolTbl_Ptr A(VolTbl)\n         JZ    F00020                   None, skip\n         ICM   R15,B'1111',VolTbl_Hdr_Vols_Total-VolTbl_Hdr(R15)\n         JZ    F00020                   No volumes, skip\n         TM    @_LSPACE_Failed,L'@_LSPACE_Failed LSPACE problem?\n         JO    F00020                   Yes, skip\n         TM    @_VolTbl_GETMAIN_Err,L'@_VolTbl_GETMAIN_Err GETMAIN err?\n         JO    F00020                   Yes, skip\n\n         TM    @_No_Headings,L'@_No_Headings  Suppressing headings?\n         JNO   F00020                   No, skip\n         TM    @_No_Details,L'@_No_Details Suppressing detail?\n         JNO   F00020                   No, skip\n         TM    @_No_Totals,L'@_No_Totals  Suppressing Totals?\n         JNO   F00020                   No, skip\n         TM    @_Statistics,L'@_Statistics Producing Statistics?\n         JO    F00020                   Yes, skip\n\n         LA    R15,0                    Clear return code\n         J     F90010                   and exit\n\nF00020   DS    0H\n*---------------------------------------------------------------------*\n*   If there is anything to display ...                               *\n*---------------------------------------------------------------------*\n         ICM   R15,B'1111',@_VolTbl_Ptr A(VolTbl)\n         JZ    F00030                   None, skip the sort\n         ICM   R15,B'1111',VolTbl_Hdr_Vols_Total-VolTbl_Hdr(R15)\n         JZ    F00030                   No volumes, skip sort\n\n*---------------------------------------------------------------------*\n*   ... sort it, if required.                                         *\n*---------------------------------------------------------------------*\n         CLI   @_Sort_Field,C' '        Any sort?\n         JE    F00030                   No, skip\n\n         LA    R15,@_Sort_Field         A(Sort Field)\n         ST    R15,@F_Parms_I00010      Save it\n         LA    R15,@_Sort_Direction     A(Sort direction)\n         ST    R15,@F_Parms_I00010+4    Save it\n\n         LA    R1,@F_Parms              A(Parms)\n         BRAS  R14,I00010               Go sort the table\n\nF00030   DS    0H\n*---------------------------------------------------------------------*\n*   Set up any applicable error messages                              *\n*---------------------------------------------------------------------*\n         MVI   @F_ErrMsgL,C' '          Clear msg area\n         MVC   @F_ErrMsgL+1(L'@F_ErrMsgL-1),@F_ErrMsgL\n         MVC   @F_ErrMsgS,@F_ErrMsgL    Short message too\n\n         TM    @_OW48527,L'@_OW48527    APAR OW48527 installed?\n         JO    F00060                   Yes, skip IKJEFTSR stuff\n\n         TM    @_No_APF,L'@_No_APF      Are we APF'ed?\n         JNO   F00040                   Yes, skip\n*---------------------------------------------------------------------*\n*     - Insufficient APF                                              *\n*       not APFed even when invoked by IKJEFTSR, or IKJEFTSR failed   *\n*       with RC=14, Reas=18 or 34                                     *\n*---------------------------------------------------------------------*\n         MVC   @F_ErrMsgL(L'F_EMsg02),F_EMsg02 Move APF msg\n         J     F00165                   and skip\nF00040   DS    0H\n         TM    @_IKJEFTSR_Err,L'@_IKJEFTSR_Err IKJEFTSR error?\n         JNO   F00050                   No, skip\n         L     R15,@_IKJEFTSR_RC        Yes, get IKJEFTSR RC\n         CHI   R15,20                   RC = 20?\n         JNE   F00045                   No, generic IKJEFTSR error\n         L     R15,@_IKJEFTSR_Reas      Yes, get reason code\n         CHI   R15,40                   Program not found?\n         JNE   F00045                   No, generic IKJEFTSR msg\n*---------------------------------------------------------------------*\n*     - Not in LNKLST/STEPLIB concatenation                           *\n*       IKJEFTSR couldn't find the module (RC=14,Reas=28)             *\n*---------------------------------------------------------------------*\n         MVC   @F_ErrMsgL(L'F_EMsg06),F_EMsg06 Move LNKLST msg\n         J     F00165                   and skip\nF00045   DS    0H\n*---------------------------------------------------------------------*\n*     - Unknown IKJEFTSR Error xx-yy                                  *\n*       Something else from IKJEFTSR xx: return code, yy:reason       *\n*---------------------------------------------------------------------*\n         MVC   @F_ErrMsgL(L'F_EMsg07),F_EMsg07 Move message\n         L     R15,@_IKJEFTSR_RC        Get ISPF failure return code\n         SLL   R15,4                    Make room for the sign\n         STH   R15,@F_DBLWD             Save it\n         OI    @F_DBLWD+1,X'0F'         Make it packed\n         UNPK  @F_DBLWD+2(3),@F_DBLWD(2) Unpack it\n         MVC   @F_ErrMsgL+F_EMsg07_RC-F_EMsg07(2),@F_DBLWD+3\n         TR    @F_ErrMsgL+F_EMsg07_RC-F_EMsg07(2),F_Hex_TrTab\n\n         L     R15,@_IKJEFTSR_Reas      Get ISPF failure reason code\n         SLL   R15,4                    Make room for the sign\n         STH   R15,@F_DBLWD             Save it\n         OI    @F_DBLWD+1,X'0F'         Make it packed\n         UNPK  @F_DBLWD+2(3),@F_DBLWD(2) Unpack it\n         MVC   @F_ErrMsgL+F_EMsg07_Reas-F_EMsg07(2),@F_DBLWD+3\n         TR    @F_ErrMsgL+F_EMsg07_Reas-F_EMsg07(2),F_Hex_TrTab\n         J     F00165                   And skip\nF00050   DS    0H\n         TM    @_SYSCLOCK_Err,L'@_SYSCLOCK_Err Code mismatch?\n         JNO   F00060                   No, skip\n*---------------------------------------------------------------------*\n*     - TimeStamp mismatch                                            *\n*       IKJEFTSR invoked a different version of the code - could be   *\n*       caused by this pgm being in ISPLLIB                           *\n*---------------------------------------------------------------------*\n         MVC   @F_ErrMsgL(L'F_EMsg09),F_EMsg09\n         J     F00165                   and skip\nF00060   DS    0H\n         TM    @_Internal_Err,L'@_Internal_Err Internal error?\n         JNO   F00070                   No, skip\n*---------------------------------------------------------------------*\n*     - Unrecognized parm (probably on re-invocation via IKJEFTSR)    *\n*---------------------------------------------------------------------*\n         MVC   @F_ErrMsgL(L'F_EMsg11),F_EMsg11\n         J     F00165                   and skip\nF00070   DS    0H\n         TM    @_Incompatible_OS,L'@_Incompatible_OS Incompatible?\n         JNO   F00110                   No, skip\n*---------------------------------------------------------------------*\n*     - CSVQUERY function unavailable                                 *\n*---------------------------------------------------------------------*\n         MVC   @F_ErrMsgL(L'F_EMsg05),F_EMsg05\n         L     R14,CVTPTR               A(CVT)\n         L     R15,CVTECVT-CVT(0,R14)   A(EVCT)\n         MVC   @F_ErrMsgL+L'F_EMsg05(L'ECVTPNAM),ECVTPNAM-ECVT(R15)\n         LA    R1,@F_ErrMsgL+L'F_EMsg05+L'ECVTPNAM-1\n         LA    R0,@F_ErrMsgL+L'F_EMsg05\nF00080   DS    0H\n         CLI   0(R1),C' '               Last significant character\n         JNE   F00090                   Yes, skip\n         S     R1,=FL4'1'               No, back up a byte\n         CR    R1,R0                    Too far?\n         JH    F00080                   No, check again\nF00090   DS    0H\n         TM    CVTOSLV5-CVT(R14),CVTZOSE z/OS.e?\n         JZ    F00100                   No, skip\n         MVC   1(2,R1),=C'.e'           Yes, say so\n         LA    R1,2(0,R1)               and bump pointer\nF00100   DS    0H\n         MVC   2(L'ECVTPVER,R1),ECVTPVER-ECVT(R15)  Version\n         MVI   2+L'ECVTPVER(R1),C'.'    Separator\n         MVC   2+L'ECVTPVER+1(L'ECVTPREL,R1),ECVTPREL-ECVT(R15) Rel\n         MVI   2+L'ECVTPVER+1+L'ECVTPREL(R1),C'.'    Separator\n         MVC   2+L'ECVTPVER+1+L'ECVTPREL+1(L'ECVTPMOD,R1),ECVTPMOD-ECVT+\n               (R15)\n         J     F00165                   And skip\nF00110   DS    0H\n         TM    @_VolTbl_GETMAIN_Err,L'@_VolTbl_GETMAIN_Err GETMAIN?\n         JNO   F00150                   No, skip\n*---------------------------------------------------------------------*\n*     - Insufficient Storage                                          *\n*---------------------------------------------------------------------*\n         MVC   @F_ErrMsgL(L'F_EMsg10),F_EMsg10\n         ICM   R15,B'1111',@_VolTbl_Ptr  A(VolTbl)\n         JZ    F00165                   None, skip\n         L     R0,VolTbl_Hdr_Vols_Eligible-VolTbl_Hdr(R15)\n         S     R0,VolTbl_Hdr_Vols_Total-VolTbl_Hdr(R15)\n         JP    F00120                   Some omitted, skip\n         MVC   @F_ErrMsgL+L'F_EMsg10+1(41),=C'Some totals/statistics li+\n               nes may be missing'\n         J     F00165                   all done\nF00120   DS    0H\n         CVD   R0,@F_DBLWD              Pack missing vols\n         MVC   @F_ErrMsgL+L'F_EMsg10(10),=X'40206B2020206B202120'\n         LA    R1,@F_ErrMsgL+L'F_EMsg10+9 Prime pointer\n         LR    R14,R1                  Save it\n         EDMK  @F_ErrMsgL+L'F_EMsg10(10),@F_DBLWD+4\n         LA    R15,@F_ErrMsgL+L'F_EMsg10+1 Left adjust start\n         CR    R1,R15                   Do we need to adjust?\n         JNH   F00140                   No, skip\n         SR    R14,R1                   Yes, EX len of number\n         EX    R14,F_EX1                Left adjust it\n         AR    R15,R14                  A(Last char)\nF00140   DS    0H\n         MVC   1(16,R15),=C' volumes omitted'\n         J     F00165                   and skip\nF00150   DS    0H\n         ICM   R15,B'1111',@_VolTbl_Ptr A(VolTbl)\n         JZ    F00160                   None, skip\n         ICM   R15,B'1111',VolTbl_Hdr_Vols_Total-VolTbl_Hdr(R15)\n         JNZ   F00170                   Got some data, skip\nF00160   DS    0H\n*---------------------------------------------------------------------*\n*     - VolTbl empty                                                  *\n*---------------------------------------------------------------------*\n         MVC   @F_ErrMsgS(4),=C'None'   No data\n         MVC   @F_ErrMsgL(L'F_EMsg01),F_EMsg01 Move No data msg\n         J     F00170                   and skip\n\nF00165   DS    0H\n         MVC   @F_ErrMsgS(10),=C'Incomplete' Flag table as incomplete\n\nF00170   DS    0H\n         NI    @_ReDisplay,X'FF'-L'@_ReDisplay  Off redisplay flag\n\n*---------------------------------------------------------------------*\n*      If output is via ISPF, go do it                                *\n*---------------------------------------------------------------------*\n         TM    @_Batch_Environ,L'@_Batch_Environ Are we Batch?\n         JO    F00190                   Yes, skip\n\n         TM    @_ISPF_SPACE,L'@_ISPF_SPACE ISPF Output requested?\n         JO    F00180                   Yes, skip\n         TM    @_ISPF_EDIF,L'@_ISPF_EDIF ISPF Output requested?\n         JO    F00180                   Yes, skip\n         TM    @_ISPF_BRIF,L'@_ISPF_BRIF ISPF Output requested?\n         JZ    F00190                   No, skip\n\nF00180   DS    0H\n         LA    R15,@F_ErrMsgS           A(Short error msg)\n         ST    R15,@F_Parms_G00010      Save it\n         LA    R15,@F_ErrMsgL           A(Long error msg)\n         ST    R15,@F_Parms_G00010+4    Save it\n\n         LA    R1,@F_Parms              A(Parms)\n         BRAS  R14,G00010               Go do ISPF stuff\n\n         TM    @_ReDisplay,L'@_ReDisplay Do we need to display again?\n         JO    F00170                   Yes, go do it\n         LTR   R15,R15                  No, did it work?\n         JZ    F90010                   Yes, exit quick smart\n         STH   R15,@F_G00010_RC         No, save return code\n         STH   R0,@F_G00010_Reas         and reason code\n\nF00190   DS    0H\n*---------------------------------------------------------------------*\n*      Perform initialization stuff for our environment               *\n*---------------------------------------------------------------------*\n         TM    @_TSO_Command,L'@_TSO_Command Is this a TSO command?\n         JZ    F00240                   No, skip\n\n*---------------------------------------------------------------------*\n*   TSO Command Processing - Clear the screen, and build our          *\n*  PUTLINE control blocks                                             *\n*---------------------------------------------------------------------*\n         L     R15,@F_24Bit_Stack_Ptr_Ptr A(24-bit Stack pointer)\n         ICM   R0,B'1111',0(R15)        A(24-bit stack)\n         JNZ   F00200                   OK, skip\n\n         LHI   R0,@_24Bit_Stack_Length  Length of storage we need\n         SSCSTACK INIT,                 Go get our storage             +\n               LEN=(R0),                 this long                     +\n               LOC=24                    below the line\n\n         L     R15,@F_24Bit_Stack_Ptr_Ptr A(24-bit Stack Pointer)\n         ST    R1,0(0,R15)              Update it\n\nF00200   DS    0H\n         L     R2,@F_24Bit_Stack_Ptr_Ptr A(24_bit Stack Pointer)\n         L     R2,0(0,R2)               A(24-bit Stack)\n         SSCSTACK PUSH,                 Get stack area                 +\n               LEN=F00230_End-F00230,    this long                     +\n               STACK=(R2)                using this stack\n\n         LR    R3,R1                    Save the address\n\n         LR    R1,R0                    Amount of storage we got\n         LR    R0,R3                    Point to it\n         LARL  R14,F00230                RMODE24 stuff)\n         LHI   R15,F00230_End-F00230    Length of STLINENO stuff\n         MVCL  R0,R14                   Move it\n\n         LR    R15,R3                   Point to the RMODE 24 stuff\n         BASR  R14,R15                  Go do it\n\n         L     R2,@F_24Bit_Stack_Ptr_Ptr A(24_bit Stack Pointer)\n         L     R2,0(0,R2)               A(24-bit Stack)\n         SSCSTACK POP,                  Free the stack area            +\n               ADDR=(R3),                starting here                 +\n               STACK=(R2)                on this stack\n\n*-------------------------------------------------------------------*\n*    ... and build the PUTLINE control blocks.                      *\n*-------------------------------------------------------------------*\n         L     R1,@_CPPL_Ptr            A(CPPL)\n         MVC   @F_IOPL+IOPLUPT-IOPL(L'IOPLUPT),CPPLUPT-CPPL(R1)\n         MVC   @F_IOPL+IOPLECT-IOPL(L'IOPLECT),CPPLECT-CPPL(R1)\n         LA    R15,@F_IOECB             A(Our ECB)\n         ST    R15,@F_IOPL+IOPLECB-IOPL Save it\n         LA    R15,@F_PLPB              A(PUTLINE Parm block)\n         ST    R15,@F_IOPL+IOPLIOPB-IOPL Save it\n         MVC   @F_PLPB,F_PLPB           Move PUTLINE Parm Block\n         LA    R15,@F_OLD               A(OLD)\n         ST    R15,@F_PLPB+4            Save in PLPB\n         LA    R15,0                    Clear work reg\n         ST    R15,@F_PLPB+8            Clear A(Format line)\n\n         LH    R1,@_LineSize            Get linesize from command line\n         LTR   R1,R1                    Anything?\n         JNZ   F00210                   Yup, skip\n         GTSIZE  ,                      Get terminal line size\n         AHI   R1,-1                     minus 1 byte\nF00210   DS    0H\n         LHI   R15,VolTbl_Ent_Display_Len Max len of data\n         LTR   R1,R1                    LINESIZE(MAX)?\n         JM    F00220                   Yes, use it\n         CR    R15,R1                   Can we display all the data?\n         JNH   F00220                   Yes, OK\n         LR    R15,R1                   No, display as much as we can\nF00220   DS    0H\n         AHI   R15,@F_VolTbl_Ent_Copy-@F_OLD Add len of OLD\n         STH   R15,@F_OLDLN             Save it\n         LA    R15,0                    Clear\n         STH   R15,@F_OLDOF              offset\n         J     F00270                   and skip\n\n*---------------------------------------------------------------------*\n*   This code fragment issues STLINENO. This code is moved to 24-bit  *\n*    storage, because the STLINENO SVC must be issued in AMODE 24.    *\n*---------------------------------------------------------------------*\n         PUSH  USING                    Save the USING environment\n         DROP  ,                        Free all current USINGs\n\nF00230   DS    0H\n         USING *,R15                    Assign temp base\n         STM   R0,R15,F00230_Save       Save callers registers\n         LR    R11,R15                  Load 'perm' base reg\n         DROP  R15                      Free temp\n         USING F00230,R11               Tell assembler about R11\n\n         STLINENO LINE=1                Clear the screen\n\n         LM    R0,R15,F00230_Save       Restore callers registers\n         BSM   0,R14                    And exit\n\n\nF00230_Save   DS   18F                  Save area\n              DS   0D                   Alignment\n\n         DROP  R11                      Free up base reg\n\nF00230_End   EQU        *               End of STLINENO Code\n\n         POP   USING                   Restore USING environment\n\nF00240   DS    0H\n*---------------------------------------------------------------------*\n*   Batch Job Processing                                              *\n*---------------------------------------------------------------------*\n         LHI   R0,4095                  Get count for Hdg0\n         LH    R15,@_Line_Count         Get current line count\n         CR    R15,R0                   Did C00010 start a new page?\n         JE    F00250                   No, we had better\n         LHI   R15,4094                 Yes, only Hdg1-3\n         J     F00260                   and skip\nF00250   DS    0H\n         LHI   R15,4090                 New page, Hdg0-3\nF00260   DS    0H\n         STH   R15,@_Line_Count         Save updated line count\n\n         J     F00270                   and skip\n\nF00270   DS    0H\n*---------------------------------------------------------------------*\n*   If we are here because ISPF output was requested, but we          *\n*  couldn't access ISPF DM services, say so now.                      *\n*---------------------------------------------------------------------*\n         TM    @_ISPF_SPACE,L'@_ISPF_SPACE ISPF Output requested?\n         JO    F00280                   Yes, skip\n         TM    @_ISPF_EDIF,L'@_ISPF_EDIF ISPF Output requested?\n         JO    F00280                   Yes, skip\n         TM    @_ISPF_BRIF,L'@_ISPF_BRIF ISPF Output requested?\n         JZ    F00300                   No, skip\n\nF00280   DS    0H\n         NI    @_ISPF_SPACE,X'FF'-L'@_ISPF_SPACE Not any more\n         NI    @_ISPF_EDIF,X'FF'-L'@_ISPF_EDIF Not any more\n         NI    @_ISPF_BRIF,X'FF'-L'@_ISPF_BRIF Not any more\n\n         TM    @_ISPF_Explicit,L'@_ISPF_Explicit ISPF specified?\n         JZ    F00300                   No, skip message\n\n         LA    R14,F_EMsg03             A(Source)\n         LHI   R15,L'F_EMsg03           Source Length\n         O     R15,=XL4'40000000'       Pad char of blank\n         LA    R0,@F_VolTbl_Ent_Copy    A(Target)\n         LHI   R1,@F_VolTbl_Ent_Copy_Len Target length\n         MVCL  R0,R14                   Move message\n         LH    R15,@F_G00010_RC         Get ISPF failure return code\n         SLL   R15,4                    Make room for the sign\n         STH   R15,@F_DBLWD             Save it\n         OI    @F_DBLWD+1,X'0F'         Make it packed\n         UNPK  @F_DBLWD+2(3),@F_DBLWD(2) Unpack it\n         MVC   @F_VolTbl_Ent_Copy+F_EMsg03_RC-F_EMsg03(2),@F_DBLWD+3\n         TR    @F_VolTbl_Ent_Copy+F_EMsg03_RC-F_EMsg03(2),F_Hex_TrTab\n\n         LH    R15,@F_G00010_Reas       Get ISPF failure reason code\n         SLL   R15,4                    Make room for the sign\n         STH   R15,@F_DBLWD             Save it\n         OI    @F_DBLWD+1,X'0F'         Make it packed\n         UNPK  @F_DBLWD+2(3),@F_DBLWD(2) Unpack it\n         MVC   @F_VolTbl_Ent_Copy+F_EMsg03_Reas-F_EMsg03(2),@F_DBLWD+3\n         TR    @F_VolTbl_Ent_Copy+F_EMsg03_Reas-F_EMsg03(2),F_Hex_TrTab\n\n         TM    @_TSO_Command,L'@_TSO_Command Is this a TSO command?\n         JZ    F00290                   No, skip\n\n         PUTLINE MF=(E,@F_IOPL)         Write it\n\n         LA    R14,F_EMsg04             A(Source)\n         LHI   R15,L'F_EMsg04           Source Length\n         O     R15,=XL4'40000000'       Pad char of blank\n         LA    R0,@F_VolTbl_Ent_Copy    A(Target)\n         LHI   R1,@F_VolTbl_Ent_Copy_Len Target length\n         MVCL  R0,R14                   Move message\n         PUTLINE MF=(E,@F_IOPL)         Write it\n         J     F00300                   and skip\n\nF00290   DS    0H\n         LA    R15,@F_VolTbl_Ent_Copy   A(Message)\n         ST    R15,@F_Parms_Y00010      Save it\n         LHI   R15,L'F_EMsg03           Length of message\n         ST    R15,@F_Parms_Y00010+4    Save it\n\n         LA    R1,@F_Parms              A(Parms)\n         BRAS  R14,Y00010               Output to SYSPRINT\n\n         LA    R15,F_EMsg04             A(Message)\n         ST    R15,@F_Parms_Y00010      Save it\n         LHI   R15,L'F_EMsg04           Length of message\n         ST    R15,@F_Parms_Y00010+4    Save it\n\n         LA    R1,@F_Parms              A(Parms)\n         BRAS  R14,Y00010               Output to SYSPRINT\n         J     F00300                   and skip\n\nF00300   DS    0H\n*---------------------------------------------------------------------*\n*   If we have an error message, put it out now                       *\n*---------------------------------------------------------------------*\n         CLI   @F_ErrMsgL,C' '          Anything?\n         JE    F00320                   Nope, skip\n\n         TM    @_TSO_Command,L'@_TSO_Command Is this a TSO command?\n         JNO   F00310                   No, skip\n\n         LA    R14,@F_ErrMsgL           A(Source)\n         LHI   R15,L'@F_ErrMsgL         Source Length\n         O     R15,=XL4'40000000'       Pad char of blank\n         LA    R0,@F_VolTbl_Ent_Copy    A(Target)\n         LHI   R1,@F_VolTbl_Ent_Copy_Len Target length\n         MVCL  R0,R14                   Move message\n         PUTLINE MF=(E,@F_IOPL)         Write it\n         J     F00320                   and skip\nF00310   DS    0H\n         LA    R15,@F_ErrMsgL           A(Message)\n         ST    R15,@F_Parms_Y00010      Save it\n         LHI   R15,L'@F_ErrMsgL         Len of data\n         ST    R15,@F_Parms_Y00010+4    Save it\n\n         LA    R1,@F_Parms              A(Parms)\n         BRAS  R14,Y00010               Output to SYSPRINT\n         J     F00320                   and skip\n\nF00320   DS    0H\n*---------------------------------------------------------------------*\n*   Common processing                                                 *\n*---------------------------------------------------------------------*\n         ICM   R15,B'1111',@_VolTbl_Ptr A(VolTbl)\n         JZ    F80010                   None, exit with error\n         ICM   R15,B'1111',VolTbl_Hdr_Vols_Total-VolTbl_Hdr(R15)\n         JZ    F80010                   No volumes, exit with error\n\n         TM    @_No_Headings,L'@_No_Headings  Headings wanted?\n         JO    F00400                   No, skip\n\n         TM    @_TSO_Command,L'@_TSO_Command Is this a TSO command?\n         JZ    F00400                   No, skip\n\n*---------------------------------------------------------------------*\n*   TSO Command processing for Headings                               *\n*---------------------------------------------------------------------*\n         ICM   R9,B'1111',@_VolTbl_Ptr  A(Volume Table)\n         JZ    F00400                   No vol tbl, skip headings\n         ICM   R10,B'1111',VolTbl_Hdr_Count-VolTbl_Hdr(R9) Get count\n         JZ    F00400                   None,skip headings\n         AHI   R9,VolTbl_Ent-VolTbl_Hdr Yes, point to first\n         USING VolTbl_Ent,R9            Assign a base\nF00370   DS    0H\n         TM    VolTbl_Ent_Heading_Line1,L'VolTbl_Ent_Heading_Line1\n         JO    F00380                   Yes, skip\n         TM    VolTbl_Ent_Heading_Line,L'VolTbl_Ent_Heading_Line\n         JZ    F00400                   End of headings, skip\nF00380   DS    0H\n         TM    VolTbl_Ent_ECB,X'40'     Has the line been populated?\n         JO    F00390                   Yes, skip\n         WAIT  ECB=VolTbl_Ent_ECB       Not yet, wait for it\nF00390   DS    0H\n         LA    R14,VolTbl_Ent_Display   A(Source)\n         LHI   R15,VolTbl_Ent_Display_Len Source Length\n         O     R15,=XL4'40000000'       Pad char of blank\n         LA    R0,@F_VolTbl_Ent_Copy    A(Target)\n         LHI   R1,@F_VolTbl_Ent_Copy_Len Target length\n         MVCL  R0,R14                   Move message\n         PUTLINE MF=(E,@F_IOPL)         Write it\n\n         AHI   R9,VolTbl_Ent_Len        Bump table pointer\n         BRCT  R10,F00370               and do next\n\n         DROP  R9                       Free our base\n\nF00400   DS    0H\n*---------------------------------------------------------------------*\n*   Common processing for VolTbl Entry                                *\n*---------------------------------------------------------------------*\n         ICM   R9,B'1111',@_VolTbl_Ptr  A(Volume Table)\n         JZ    F90010                   Nothing, exit\n         ICM   R10,B'1111',VolTbl_Hdr_Count-VolTbl_Hdr(R9) nbr ents\n         JZ    F90010                   Nothing, exit\n         AHI   R9,VolTbl_Ent-VolTbl     Point to first entry\n         USING VolTbl_Ent,R9            and assign a base\n\nF00410   DS    0H\n*--------------------------------------------------------------------*\n*     If this is a heading line, skip it                             *\n*--------------------------------------------------------------------*\n         TM    VolTbl_Ent_Heading_Line1,L'VolTbl_Ent_Heading_Line1\n         JO    F00470                   Yes, skip\n         TM    VolTbl_Ent_Heading_Line,L'VolTbl_Ent_Heading_Line\n         JO    F00470                   a heading, skip it\n\n*--------------------------------------------------------------------*\n*     If this is a line we want ...                                  *\n*--------------------------------------------------------------------*\n         TM    VolTbl_Ent_Detail_Line,L'VolTbl_Ent_Detail_Line\n         JNO   F00420                   No, skip\n         TM    @_No_Details,L'@_No_Details Do we want details?\n         JNO   F00440                   Yes, go process it\n         J     F00470                   No, ignore it\n\nF00420   DS    0H\n         TM    VolTbl_Ent_Total_Line,L'VolTbl_Ent_Total_Line Total?\n         JNO   F00430                   No, skip\n         TM    @_No_Totals,L'@_No_Totals Do we want totals?\n         JNO   F00440                   Yes, go process it\n         J     F00470                   No, ignore it\n\nF00430   DS    0H\n*--------------------------------------------------------------------*\n*     If this is a Statistics line, fill it in ...                   *\n*--------------------------------------------------------------------*\n         TM    VolTbl_Ent_Stats_Line,L'VolTbl_Ent_Stats_Line\n         JNO   F00440                   No, go display it\n\n         LA    R15,VolTbl_Ent           Point to the Volume Tbl entry\n         ST    R15,@F_Parms_V00010      Save it\n         LA    R1,@F_Parms              A(Parms)\n         BRAS  R14,V00010               Go process stats\n\nF00440   DS    0H\n         TM    VolTbl_Ent_ECB,X'40'     Has the line been populated?\n         JO    F00450                   Yes, skip\n         WAIT  ECB=VolTbl_Ent_ECB       Not yet, WAIT for it\n\nF00450   DS    0H\n*--------------------------------------------------------------------*\n*     ... and output this line, either via PUTLINE ...               *\n*--------------------------------------------------------------------*\n         TM    @_TSO_Command,L'@_TSO_Command Is this a TSO command?\n         JZ    F00460                   No, skip\n\n         LA    R14,VolTbl_Ent_Display   A(Source)\n         LHI   R15,VolTbl_Ent_Display_Len Source Length\n         O     R15,=XL4'40000000'       Pad char of blank\n         LA    R0,@F_VolTbl_Ent_Copy    A(Target)\n         LHI   R1,@F_VolTbl_Ent_Copy_Len Target length\n         MVCL  R0,R14                   Move message\n         PUTLINE MF=(E,@F_IOPL)         Write it\n         J     F00470                   and skip\n\nF00460   DS    0H\n*--------------------------------------------------------------------*\n*     ... or to SYSPRINT                                             *\n*--------------------------------------------------------------------*\n         LA    R15,VolTbl_Ent_Display   Data area\n         ST    R15,@F_Parms_Y00010      Save it\n         LHI   R15,VolTbl_Ent_Display_Len Len of data\n         ST    R15,@F_Parms_Y00010+4    Save it\n\n         LA    R1,@F_Parms              A(Parms)\n         BRAS  R14,Y00010               Go print it\n         J     F00470                   and skip\n\nF00470   DS    0H\n*--------------------------------------------------------------------*\n*     Point to next VolTbl Entry, and continue                       *\n*--------------------------------------------------------------------*\n         AHI   R9,VolTbl_Ent_Len        A(Next entry)\n         BRCT  R10,F00410               and continue\n         DROP  R9\n\nF00480   DS    0H\n*--------------------------------------------------------------------*\n*   We've finished displaying the table, so write it to OutFile, if  *\n*    required.                                                       *\n*--------------------------------------------------------------------*\n         SLR   R15,R15                  Clear return code\n         CLI   @_OutFile_DDName,C' '    Any output file?\n         JE    F00600                   No, just exit\n\n         LA    R15,@_OutFile_DDName     Yes, point to it\n         ST    R15,@F_Parms_X00010      Save it\n         TM    @_OutData_DISPLAY,L'@_OutData_DISPLAY\n         JNO   F00500                   No, skip\n         LA    R15,@_OutData_DISPLAY    Yes, point to it\n         J     F00520                   and skip\nF00500   DS    0H\n         TM    @_OutData_CB,L'@_OutData_CB\n         JNO   F00510                   No, skip\n         LA    R15,@_OutData_CB         Yes, point to it\n         J     F00520                   and skip\nF00510   DS    0H\n         LA    R15,@_OutData_ALL        All output\nF00520   DS    0H\n         ST    R15,@F_Parms_X00010+4    Save A(OutData Flag)\n         LA    R1,@F_Parms              A(Parm list)\n         BRAS  R14,X00010               Output to file, if necessary\n         LTR   R15,R15                  Did it work?\n         JZ    F00600                   Yes, exit\n\n*--------------------------------------------------------------------*\n*     OutFile processing failed - build our error message ...        *\n*--------------------------------------------------------------------*\n         MVI   @F_ErrMsgL,C' '          Clear msg area\n         MVC   @F_ErrMsgL+1(L'@F_ErrMsgL-1),@F_ErrMsgL\n         MVC   @F_ErrMsgL(L'F_Emsg12),F_EMsg12  Move msg start\n         MVC   @F_ErrMsgL+L'F_EMsg12+1(L'@_OutFile_DDName),@_OutFile_DD+\n               Name\n         LA    R15,@F_ErrMsgL+L'F_EMsg12+1+L'@_OutFile_DDName-1\nF00530   DS    0H\n         CLI   0(R15),C' '              End of DDName?\n         JNE   F00540                   yes, skip\n         BCT   R15,F00530               No, back up and try again\nF00540   DS    0H\n         MVC   2(21,R15),=C'not useable - ignored'\n\n*--------------------------------------------------------------------*\n*     ... and let the user know ...                                  *\n*--------------------------------------------------------------------*\n         TM    @_Batch_Environ,L'@_Batch_Environ Are we Batch?\n         JO    F00570                   Yes, skip\n         TM    @_ISPF_SPACE,L'@_ISPF_SPACE ISPF Output requested?\n         JO    F00550                   Yes, skip\n         TM    @_ISPF_EDIF,L'@_ISPF_EDIF ISPF Output requested?\n         JO    F00550                   Yes, skip\n         TM    @_ISPF_BRIF,L'@_ISPF_BRIF ISPF Output requested?\n         JZ    F00570                   No, skip\n\nF00550   DS    0H\n*--------------------------------------------------------------------*\n*     ... via ISPF ...                                               *\n*--------------------------------------------------------------------*\n         MVC   @F_LINKX,F_LINKX         Move LINK L-Form\n\n         LA    R15,=CL8'VDEFINE'        ISPF Function\n         ST    R15,@F_ISPF_Parms        Save it\n         LA    R15,=CL8'CHAR'           Character variables\n         ST    R15,@F_ISPF_Parms+12     Save it\n\n         LA    R15,=CL8'ZEDSMSG'        Variable name\n         ST    R15,@F_ISPF_Parms+4      Save it\n         LA    R15,=C'OutFile Error'    Short message\n         ST    R15,@F_ISPF_Parms+8      Save it\n         LA    R15,=AL4(13)             Length of message\n         ST    R15,@F_ISPF_Parms+16     Save it\n         OI    @F_ISPF_Parms+16,X'80'   Flag end of list\n\n         LARL  R2,F00560                A(Error return address)\n         LINKX EP=ISPLINK,              Link to ISPF Interface         +\n               ERRET=(2),                error here                    +\n               MF=(E,@F_ISPF_Parms),     passing these parms           +\n               SF=(E,@F_LINKX)           staying re-entrant\n\n         LA    R15,=CL8'ZEDLMSG'        Variable name\n         ST    R15,@F_ISPF_Parms+4      Save it\n         LA    R15,@F_ErrMsgL           Long message\n         ST    R15,@F_ISPF_Parms+8      Save it\n         LA    R15,=AL4(L'@F_ErrMsgL)   Length of message\n         ST    R15,@F_ISPF_Parms+16     Save it\n         OI    @F_ISPF_Parms+16,X'80'   Flag end of list\n         LINKX EP=ISPLINK,              Link to ISPF Interface         +\n               ERRET=(2),                error here                    +\n               MF=(E,@F_ISPF_Parms),     passing these parms           +\n               SF=(E,@F_LINKX)           staying re-entrant\n\n         LA    R15,=CL8'SETMSG'         Yes, ISPF Function\n         ST    R15,@F_ISPF_Parms        Save it\n         LA    R15,=CL8'ISRZ001'        A(Message ID)\n         ST    R15,@F_ISPF_Parms+4      Save it\n         OI    @F_ISPF_Parms+4,X'80'    Mark end of list\n         LINKX EP=ISPLINK,              Link to ISPF Interface         +\n               ERRET=(2),                error here                    +\n               MF=(E,@F_ISPF_Parms),     passing these parms           +\n               SF=(E,@F_LINKX)           staying re-entrant\n         J     F00590                   and exit with error\n\nF00560   DS    0H\n         LA    R1,@F_ErrMsgL            A(Error Message)\n         LA    R0,L'@F_ErrMsgL          Length\n         TPUT  (1),(0)                  All else failed\n         J     F00590                   and exit with error\n\nF00570   DS    0H\n*--------------------------------------------------------------------*\n*     ... or PUTLINE ...                                             *\n*--------------------------------------------------------------------*\n         TM    @_TSO_Command,L'@_TSO_Command Is this a TSO command?\n         JZ    F00580                   No, skip\n\n         LA    R14,@F_ErrMsgL           A(Source)\n         LHI   R15,L'@F_ErrMsgL         Length\n         O     R15,=XL4'40000000'       Pad char of blank\n         LA    R0,@F_VolTbl_Ent_Copy    A(Target)\n         LHI   R1,@F_VolTbl_Ent_Copy_Len Target length\n         MVCL  R0,R14                   Move message\n         PUTLINE MF=(E,@F_IOPL)         Write it\n         J     F00590                   and skip\n\nF00580   DS    0H\n*--------------------------------------------------------------------*\n*     ... or to SYSPRINT                                             *\n*--------------------------------------------------------------------*\n         LA    R15,@F_ErrMsgL           A(Error Msg)\n         ST    R15,@F_Parms_Y00010      Save it\n         LA    R15,L'@F_ErrMsgL         Length\n         ST    R15,@F_Parms_Y00010+4    Save it\n\n         LA    R1,@F_Parms              A(Parms)\n         BRAS  R14,Y00010               Go print it\n         J     F00590                   and exit with error\n\nF00590   DS    0H\n*--------------------------------------------------------------------*\n*     Set the return code, and exit                                  *\n*--------------------------------------------------------------------*\n         LA    R15,4                    OutFile processing failed\n         J     F00600                   and exit\n\nF00600   DS    0H\n*--------------------------------------------------------------------*\n*     All done processing the VolTbl Entries - exit                  *\n*--------------------------------------------------------------------*\n         J     F90010                   exit quick smart\n\n\nF80010   DS    0H\n*--------------------------------------------------------------------*\n*     Nothing to display                                             *\n*--------------------------------------------------------------------*\n         LA    R15,4                    Set return code\n         J     F90010                   and exit\n\nF90010   DS    0H\n*-------------------------------------------------------------------*\n*    Free up our local storage ...                                  *\n*-------------------------------------------------------------------*\n         LR    R3,R15                 Save return code\n\n         LA    R1,@F_Dynam              A(Local storage)\n         L     R2,@F_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         L     R13,4(0,R13)             Rescue A(HSA)\n\n         SSCSTACK POP,                  Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=(R2)                on this stack\n\n         LR    R15,R3                   Restore return code\n\n*-------------------------------------------------------------------*\n*    ... and return to caller                                       *\n*-------------------------------------------------------------------*\n         L     R14,12(0,R13)            Restore return address\n         LM    R0,R12,20(R13)           Restore other registers\n         BSM   0,R14                    and return\n\nF_Literals  DS  0H\n\nF_PLPB   PUTLINE OUTPUT=(0,TERM,SINGLE,DATA),                          +\n               TERMPUT=(EDIT,WAIT,NOHOLD,NOBREAK),                     +\n               MF=L\nF_PLPB_Length EQU *-F_PLPB\n\nF_LINKX  LINKX EP=ISPLINK,            ISPF services                    +\n               SF=L                    List form only\nF_LINKX_Length EQU   *-F_LINKX\n\nF_EMsg01 DC    C'&PGMNAME.01I No Devices/Volumes match selection criter+\n               ia'\nF_EMsg02 DC    C'&PGMNAME.02I Insufficient APF authorization'\nF_EMsg03 DC    C'&PGMNAME.03I ISPF DM Services unavailable xx-yy'\nF_EMsg03_RC    EQU F_EMsg03+L'F_EMsg03-5,2\nF_EMsg03_Reas  EQU F_EMsg03+L'F_EMsg03-2,2\nF_EMsg04 DC    C'&PGMNAME.04I Forcing non-ISPF output'\nF_EMsg05 DC    C'&PGMNAME.05I CSVQUERY unavailable on this system '\nF_EMsg06 DC    C'&PGMNAME.06I Program not found in STEPLIB/LNKLST'\nF_EMsg07 DC    C'&PGMNAME.07I IKJEFTSR Error xx-yy'\nF_EMsg07_RC    EQU   F_EMsg07+L'F_EMsg07-5,2\nF_EMsg07_Reas  EQU   F_EMsg07+L'F_EMsg07-2,2\nF_EMsg08 DC    C'&PGMNAME.08I LSPACE failed for at least 1 volume'\nF_EMsg09 DC    C'&PGMNAME.09I Incompatible version'\nF_EMsg10 DC    C'&PGMNAME.10I Insufficient storage:'\nF_EMsg11 DC    C'&PGMNAME.11I Internal Error - Unknown invocation type'\nF_EMsg12 DC    C'&PGMNAME.12I OutFile DDName'\n\nF_EX1    MVC   0(0,R15),0(R1)\n\nF_Hex_TrTab           EQU   *-240\n                      DC    C'0123456789ABCDEF'\n\n         LTORG\n\nF_Literals_End  DS  0H\n\n\n@F_Dynam                  DSECT        Dynamic area for F00000\n                          DS    18F     O/S Style save area\n@F_31Bit_Stack_Ptr_Ptr    DS    AL4     A(31-bit Stack Ptr)\n@F_24Bit_Stack_Ptr_Ptr    DS    AL4     A(24-bit Stack Ptr)\n@F_DBLWD                  DS    D       Work area\n\n@F_G00010_RC              DS    HL2     G00010 Return Code\n@F_G00010_Reas            DS    HL2     G00010 Reason Code\n\n@F_Parms                  DS    0F      Parms for called rtns\n@F_Parms_Std              DS    3AL4     Standard 3 parms\n@F_Parms_Extra            EQU   *        Extra parms\n@F_Parms_G00010           DS    2AL4        for G00010\n                          ORG   @F_Parms_Extra\n@F_Parms_I00010           DS    2AL4        for I00010\n                          ORG   @F_Parms_Extra\n@F_Parms_V00010           DS    AL4         for V00010\n                          ORG   @F_Parms_Extra\n@F_Parms_X00010           DS    2AL4        for X00010\n                          ORG   @F_Parms_Extra\n@F_Parms_Y00010           DS    2AL4        for Y00010\n                          ORG   @F_Parms_Extra\n@F_ISPF_Parms             DS    5AL4   ISPF Parm List\n@F_LINKX                  DS    CL(F_LINKX_Length)\n                          ORG   ,\n                          DS    0F      Alignment\n@F_IOPL                   DS    CL(IOPL_Length)  IOPL block\n                          DS    0F      Alignment\n@F_PLPB                   DS    CL(F_PLPB_Length) PUTLINE Parm Blk\n@F_IOECB                  DS    F       ECB for PUTLINE\n@F_OLD                    EQU   *       OLD for PUTLINE\n@F_OLDLN                  DS    HL2      Length\n@F_OLDOF                  DS    HL2      Offset\n@F_VolTbl_Ent_Copy        DS    2CL((VolTbl_Ent_Display_Len/2)+1)\n@F_VolTbl_Ent_Copy_Len    EQU   *-@F_VolTbl_Ent_Copy\n@F_ErrMsgS                DS    CL24\n@F_ErrMsgL                DS    CL(L'VolTbl_Ent_ErrMsg)\n                          DS    0D          Alignment\n@F_Dynam_Length           EQU   *-@F_Dynam  Length of storage\n\n&PGMNAME CSECT\n\n         DROP  ,\n         POP   USING\n         TITLE 'G00010: Output Results using ISPF'\n\n         PUSH  USING\n\nG00010   DS    0H\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Routine   : G00010                                                 *\n*                                                                     *\n*  Abstract  : Display results of LSPACE stuff via ISPF               *\n*                                                                     *\n*  Inputs    : R1 : ---> A(@_Dynam)                                   *\n*                        A(31-bit Stack Pointer)                      *\n*                        A(24-bit Stack Pointer)                      *\n*                        A(ISPF Short Message)                        *\n*                        A(ISPF Long Message)                         *\n*  Outputs   : R15: 00 - all OK                                       *\n*                   04 - ISPQRY Failed,       R0: RC from ISPQRY      *\n*                   08 - ISPLINK LOAD failed, R0: RC from LOAD        *\n*                                                                     *\n*  Notes     :                                                        *\n*                                                                     *\n*  History:    2000/05/23 SDDA030 - V2.12                             *\n*                                 - New, code was originally in       *\n*                                   F00010.                           *\n*                                 - Added MULT to TBADD.              *\n*                                 - If we are APF-auth turn off       *\n*                                   JSCBAUTH before trying to use DM, *\n*                                   and ATTACH a task to reset it     *\n*                                   when we are done.                 *\n*              2001/02/01 SDDA030 - V2.13                             *\n*                                 - Removed IOSCDR message pointer.   *\n*                                 - Removed JSCBAUTH stuff.           *\n*                                 - Added 'Incomplete' ISPF msg.      *\n*              2001/02/26 SDDA030 - V2.14                             *\n*                                 - Added BRIF/EDIF support.          *\n*                                 - Used BRIF if ISPF(S) wanted, but  *\n*                                   panel not available.              *\n*              2002/02/12 SDDA030 - V2.16                             *\n*                                 - Moved ISPF(S) code to K00010      *\n*              2003/10/07 SDDA030 - V2.21                             *\n*                                 - Added code to allow switching     *\n*                                   between display modes.            *\n*              2006/04/21 SDDA030 - V2.24                             *\n*                                 - Used standardised calling sequence*\n*              ____/__/__ _______                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         STM   R14,R12,12(R13)          Save callers registers\n         LARL  R11,G_Literals           Point to our literals\n         USING (G_Literals,G_Literals_End),R11 Tell the assembler\n\n         L     R12,0(0,R1)              A(@_Dynam)\n         USING @_Dynam,R12              Tell the assembler\n\n*-------------------------------------------------------------------*\n*    Get an area on the stack for our local storage                 *\n*-------------------------------------------------------------------*\n         L     R2,4(0,R1)               A(31-bit stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         SSCSTACK PUSH,                 Get stack area                 +\n               LEN=@G_Dynam_Length,      this long                     +\n               STACK=(R2)                using this stack\n\n         LR    R3,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LHI   R1,@G_Dynam_Length        Its length\n         LA    R14,0                    Clear source address\n         LA    R15,0                     and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R3                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*-------------------------------------------------------------------*\n         ST    R13,4(0,R1)              Chain\n         ST    R1,8(0,R13)               saveareas\n         LR    R13,R1                   Load dynam base\n         USING @G_Dynam,R13             Assign a base\n         L     R15,@G_Dynam+4           Get A(HSA)\n         LM    R0,R3,20(R15)            Restore callers registers\n\n         L     R15,4(0,R1)              A(31-bit Stack Pointer)\n         ST    R15,@G_31Bit_Stack_Ptr_Ptr Save it\n         L     R15,8(0,R1)              A(24-bit Stack Pointer)\n         ST    R15,@G_24Bit_Stack_Ptr_Ptr Save it\n\n*--------------------------------------------------------------------*\n*   Initialize our standard parmlist                                 *\n*--------------------------------------------------------------------*\n         LA    R15,@_Dynam              A(Dynamic area)\n         ST    R15,@G_Parms_Std         Save it\n         L     R15,@G_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)\n         ST    R15,@G_Parms_Std+4       Save it\n         L     R15,@G_24Bit_Stack_Ptr_Ptr A(24-bit Stack Pointer)\n         ST    R15,@G_Parms_Std+8       Save it\n\n*---------------------------------------------------------------------*\n*      If we can use ISPF, LOAD ISPLINK                               *\n*---------------------------------------------------------------------*\n         LA    R1,0                     Clear parm reg\n         LINK  EP=ISPQRY                Check ISPF services\n         LTR   R15,R15                  Are they available?\n         JNZ   G80010                   No, use line-by-line\nG00020   DS    0H\n         BASR  R2,0\n         USING (*,G00020_End-1),R2\n         LOAD  EP=ISPLINK               Get A(ISPF Interface)\nG00020_End DS  0H\n         DROP  R2\n         LTR   R15,R15                  Is it there?\n         JNZ   G80020                   No, skip\n         ST    R0,@_ISPLINK             Yes, save EPA\n\n*---------------------------------------------------------------------*\n*      ISPF seems to be available - save our display environment and  *\n*     ask ISPF to return errors to us.                                *\n*---------------------------------------------------------------------*\n         LA    R15,=CL8'CONTROL'        CONTROL\n         ST    R15,@G_ISPF_Parms\n         LA    R15,=CL8'DISPLAY'        DISPLAY\n         ST    R15,@G_ISPF_Parms+4\n         LA    R15,=CL8'SAVE'           SAVE\n         ST    R15,@G_ISPF_Parms+8\n         OI    @G_ISPF_Parms+8,X'80'    Flag end of list\n         LA    R1,@G_ISPF_Parms         A(Parmlist)\n         L     R15,@_ISPLINK            A(ISPF Interface)\n         BASR  R14,R15                  Go do it\n\n         LA    R15,=CL8'CONTROL'        CONTROL\n         ST    R15,@G_ISPF_Parms\n         LA    R15,=CL8'ERRORS'         ERRORS\n         ST    R15,@G_ISPF_Parms+4\n         LA    R15,=CL8'RETURN'         RETURN\n         ST    R15,@G_ISPF_Parms+8\n         OI    @G_ISPF_Parms+8,X'80'    Flag end of list\n         LA    R1,@G_ISPF_Parms         A(Parmlist)\n         L     R15,@_ISPLINK            A(ISPF Interface)\n         BASR  R14,R15                  Go do it\n\n*---------------------------------------------------------------------*\n*      Clear our flags                                                *\n*---------------------------------------------------------------------*\n         NI    @G_SETMSG_Issued,X'FF'-L'@G_SETMSG_Issued Clear flg\n\n*---------------------------------------------------------------------*\n*      If there is an error message, SETMSG it ...                    *\n*---------------------------------------------------------------------*\n         L     R15,@G_Dynam+4           A(HSA)\n         L     R15,24(0,R15)            Get original R1\n         ICM   R14,B'1111',12(R15)      A(Short Error message)\n         JZ    G00030                   Nothing, skip\n         CLI   0(R14),C' '              Message blank?\n         JE    G00030                   Yes, no message\n\n         LA    R15,=CL8'VDEFINE'        ISPF Function\n         ST    R15,@G_ISPF_Parms        Save it\n         LA    R15,=CL8'CHAR'           Character variables\n         ST    R15,@G_ISPF_Parms+12     Save it\n\n         LA    R15,=CL8'ZEDSMSG'        Variable name\n         ST    R15,@G_ISPF_Parms+4      Save it\n         ST    R14,@G_ISPF_Parms+8      Save A(short message)\n         LA    R15,=FL4'24'             Max len of SMSG\n         ST    R15,@G_ISPF_Parms+16     Save it\n         OI    @G_ISPF_Parms+16,X'80'   Flag end of list\n         LA    R1,@G_ISPF_Parms         A(Parmlist)\n         L     R15,@_ISPLINK            A(ISPF Interface)\n         BASR  R14,R15                  Go do it\n\n         LA    R15,=CL8'ZEDLMSG'        Variable name\n         ST    R15,@G_ISPF_Parms+4      Save it\n         L     R15,@G_Dynam+4           A(HSA)\n         L     R15,24(0,R15)            Get original R1\n         L     R15,16(0,R15)            A(Long message)\n         ST    R15,@G_ISPF_Parms+8      Save it\n         LA    R15,=AL4(L'VolTbl_Ent_ErrMsg) Length of Long Msg\n         ST    R15,@G_ISPF_Parms+16     Save it\n         OI    @G_ISPF_Parms+16,X'80'   Flag end of list\n         LA    R1,@G_ISPF_Parms         A(Parmlist)\n         L     R15,@_ISPLINK            A(ISPF Interface)\n         BASR  R14,R15                  Go do it\n\n         LA    R15,=CL8'SETMSG'         Yes, ISPF Function\n         ST    R15,@G_ISPF_Parms        Save it\n         LA    R15,=CL8'ISRZ001'        A(Message ID)\n         ST    R15,@G_ISPF_Parms+4      Save it\n         OI    @G_ISPF_Parms+4,X'80'    Mark end of list\n         LA    R1,@G_ISPF_Parms         Point to ISPF parms\n         L     R15,@_ISPLINK            A(Interface routine)\n         BASR  R14,R15                  Go do it\n\n         OI    @G_SETMSG_Issued,L'@G_SETMSG_Issued  We've done a SETMSG\n\nG00030   DS    0H\n*---------------------------------------------------------------------*\n*      If there is anything to do ...                                 *\n*---------------------------------------------------------------------*\n         SLR   R15,R15                  Clear return code\n         ICM   R1,B'1111',@_VolTbl_Ptr A(VolTbl)\n         JZ    G90010                   None, all done\n         ICM   R1,B'1111',VolTbl_Hdr_Vols_Total-VolTbl_Hdr(R1)\n         JZ    G90010                   None, all done\n\n*---------------------------------------------------------------------*\n*      If we will be invoking BRIF, put out the message indicating    *\n*     that the SORT command is available.                             *\n*---------------------------------------------------------------------*\n         TM    @_ISPF_BRIF,L'@_ISPF_BRIF Do we want BRIF?\n         JNO   G00060                   No, skip\n         TM    @G_SETMSG_Issued,L'@G_SETMSG_Issued Already a msg?\n         JO    G00060\n\n         LA    R15,=CL8'VDEFINE'        ISPF Function\n         ST    R15,@G_ISPF_Parms        Save it\n         LA    R15,=CL8'CHAR'           Character variables\n         ST    R15,@G_ISPF_Parms+12     Save it\n\n         LA    R15,=CL8'ZEDSMSG'        Variable name\n         ST    R15,@G_ISPF_Parms+4      Save it\n         LA    R15,G_Sort_SMsg          SORT Cmd available\n         ST    R15,@G_ISPF_Parms+8      Save it\n         LA    R15,=AL4(L'G_Sort_SMsg)  Length of message\n         ST    R15,@G_ISPF_Parms+16     Save it\n         OI    @G_ISPF_Parms+16,X'80'   Flag end of list\n         LA    R1,@G_ISPF_Parms         A(Parmlist)\n         L     R15,@_ISPLINK            A(ISPF Interface)\n         BASR  R14,R15                  Go do it\n\n         LA    R15,=CL8'ZEDLMSG'        Variable name\n         ST    R15,@G_ISPF_Parms+4      Save it\n         LA    R15,G_Sort_LMsg          Long message\n         ST    R15,@G_ISPF_Parms+8      Save it\n         LA    R15,=AL4(L'G_Sort_LMsg)  Length of message\n         ST    R15,@G_ISPF_Parms+16     Save it\n         OI    @G_ISPF_Parms+16,X'80'   Flag end of list\n         LA    R1,@G_ISPF_Parms         A(Parmlist)\n         L     R15,@_ISPLINK            A(ISPF Interface)\n         BASR  R14,R15                  Go do it\n\n         LA    R15,=CL8'SETMSG'         Yes, ISPF Function\n         ST    R15,@G_ISPF_Parms        Save it\n         LA    R15,=CL8'ISRZ000'        A(Message ID)\n         ST    R15,@G_ISPF_Parms+4      Save it\n         OI    @G_ISPF_Parms+4,X'80'    Mark end of list\n         LA    R1,@G_ISPF_Parms         Point to ISPF parms\n         L     R15,@_ISPLINK            A(Interface routine)\n         BASR  R14,R15                  Go do it\n\nG00060   DS    0H\n         TM    @_ISPF_BRIF,L'@_ISPF_BRIF Do we want BRIF?\n         JO    G00070                   Yes, skip\n         TM    @_ISPF_EDIF,L'@_ISPF_EDIF No, how about EDIF?\n         JO    G00070                   Yes, skip\n\n*---------------------------------------------------------------------*\n*      Invoke our standard ISPF SPACE display; if it fails, we will   *\n*     force BRIF.                                                     *\n*---------------------------------------------------------------------*\n         LA    R1,@G_Parms              A(Parms)\n         BRAS  R14,K00010               Go display ISPF(S)\n         TM    @_ReDisplay,L'@_ReDisplay Do it again?\n         JO    G00080                   Yes, exit quick smart\n         LTR   R15,R15                  No, how did it go?\n         JZ    G00080                   OK, skip\n\n*---------------------------------------------------------------------*\n*      We will use BRIF - set our flag, and let the user know         *\n*---------------------------------------------------------------------*\n         OI    @_ISPF_BRIF,L'@_ISPF_BRIF No, force BRIF\n         NI    @_ISPF_SPACE,X'FF'-L'@_ISPF_SPACE\n\n         TM    @G_SETMSG_Issued,L'@G_SETMSG_Issued  Already SETMSG'd?\n         JO    G00070                   Yes, don't clobber it\n\n         LA    R15,=CL8'VDEFINE'        ISPF Function\n         ST    R15,@G_ISPF_Parms        Save it\n         LA    R15,=CL8'CHAR'           Character variables\n         ST    R15,@G_ISPF_Parms+12     Save it\n\n         LA    R15,=CL8'ZEDSMSG'        Variable name\n         ST    R15,@G_ISPF_Parms+4      Save it\n         LA    R15,G_BRIF_SMsg          A(Short Message)\n         ST    R15,@G_ISPF_Parms+8      Save it\n         LA    R15,=AL4(L'G_BRIF_SMsg)  Length of variable\n         ST    R15,@G_ISPF_Parms+16     Save it\n         OI    @G_ISPF_Parms+16,X'80'   Flag end of list\n         LA    R1,@G_ISPF_Parms         A(Parmlist)\n         L     R15,@_ISPLINK            A(ISPF Interface)\n         BASR  R14,R15                  Go do it\n\n         LA    R15,=CL8'ZEDLMSG'        Variable name\n         ST    R15,@G_ISPF_Parms+4      Save it\n         LA    R15,G_BRIF_LMsg          A(Long message)\n         ST    R15,@G_ISPF_Parms+8      Save it\n         LA    R15,=AL4(L'G_BRIF_LMsg)  Length of message\n         ST    R15,@G_ISPF_Parms+16     Save it\n         OI    @G_ISPF_Parms+16,X'80'   Flag end of list\n         LA    R1,@G_ISPF_Parms         A(Parmlist)\n         L     R15,@_ISPLINK            A(ISPF Interface)\n         BASR  R14,R15                  Go do it\n\n         LA    R15,=CL8'SETMSG'         Yes, ISPF Function\n         ST    R15,@G_ISPF_Parms        Save it\n         LA    R15,=CL8'ISRZ001'        A(Message ID)\n         ST    R15,@G_ISPF_Parms+4      Save it\n         OI    @G_ISPF_Parms+4,X'80'    Mark end of list\n         LA    R1,@G_ISPF_Parms         Point to ISPF parms\n         L     R15,@_ISPLINK            A(Interface routine)\n         BASR  R14,R15                  Go do it\n\n         OI    @G_SETMSG_Issued,L'@G_SETMSG_Issued  We've done a SETMSG\n\n         J     G00070                   and go do it\n\nG00070   DS    0H\n         LA    R1,@G_Parms              A(Parms)\n         BRAS  R14,J00010               Go EDIF/BRIF\n\n         LA    R15,0                    Clear return code\n         LA    R0,0                     and reason code\n         J     G90010\n\nG00080   DS    0H\n*--------------------------------------------------------------------*\n*     END or RETURN from DISPLAY: Clear return codes and exit.       *\n*--------------------------------------------------------------------*\n         LA    R0,0                     Clear reason code\n         LA    R15,0                     and return code\n         J     G90010                   exit\n\n\nG80010   DS    0H\n*-------------------------------------------------------------------*\n*    Error - ISPQRY failed                                          *\n*-------------------------------------------------------------------*\n         LR    R0,R15                 Set reason code (RC from ISPQRY)\n         LA    R15,4                  Set return code\n         J     G90010                 and exit\n\nG80020   DS    0H\n*-------------------------------------------------------------------*\n*    Error - LOAD for ISPLINK failed                                *\n*-------------------------------------------------------------------*\n         LR    R0,R15                 Set reason code (RC from LOAD)\n         LA    R15,8                  Set return code\n         J     G90010                 and exit\n\n\nG90010   DS    0H\n*---------------------------------------------------------------------*\n*   Clean up and return to caller                                     *\n*---------------------------------------------------------------------*\n         LR    R3,R15                 Save return code\n         LR    R4,R0                   and reason code\n\n*---------------------------------------------------------------------*\n*   If we successfully LOADed ISPLINK ...                             *\n*---------------------------------------------------------------------*\n         ICM   R1,B'1111',@_ISPLINK     Get A(ISPF Interface)\n         JZ    G90030                   None, skip\n\n*---------------------------------------------------------------------*\n*   ... VDELETE any ISPF variables we created ...                     *\n*---------------------------------------------------------------------*\n         LA    R15,=CL8'VDELETE'        Yes, A(ISPF Function)\n         ST    R15,@G_ISPF_Parms        Save it\n         LA    R15,=CL8'*'              A(Variable names)\n         ST    R15,@G_ISPF_Parms+4      Save it\n         OI    @G_ISPF_Parms+4,X'80'    Flag end of list\n         LA    R1,@G_ISPF_Parms         Point to ISPF parms\n         L     R15,@_ISPLINK            A(ISPF Interface)\n         BASR  R14,R15                  Go do it\n\n*---------------------------------------------------------------------*\n*   ... restore the ISPF Display environment ...                      *\n*---------------------------------------------------------------------*\n         LA    R15,=CL8'CONTROL'        ISPF Function\n         ST    R15,@G_ISPF_Parms        Save it\n         LA    R15,=CL8'DISPLAY'        Character variables\n         ST    R15,@G_ISPF_Parms+4      Save it\n         LA    R15,=CL8'RESTORE'        Character variables\n         ST    R15,@G_ISPF_Parms+8      Save it\n         OI    @G_ISPF_Parms+8,X'80'    Flag end of list\n         LA    R1,@G_ISPF_Parms         A(Parmlist)\n         L     R15,@_ISPLINK            A(ISPF Interface)\n         BASR  R14,R15                  Go do it\n\n*---------------------------------------------------------------------*\n*   ... and DELETE ISPLINK                                            *\n*---------------------------------------------------------------------*\n         DELETE EP=ISPLINK              Delete it\n         LA    R15,0                    and clear\n         ST    R15,@_ISPLINK             the pointer\n\nG90030   DS    0H\n*-------------------------------------------------------------------*\n*    Free up our local storage ...                                  *\n*-------------------------------------------------------------------*\n         LA    R1,@G_Dynam              A(Local storage)\n         L     R2,@G_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         L     R13,4(0,R13)             Rescue A(HSA)\n\n         SSCSTACK POP,                  Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=(R2)                on this stack\n\n*-------------------------------------------------------------------*\n*    ... and return to caller                                       *\n*-------------------------------------------------------------------*\n         LR    R15,R3                   Restore return code\n         LR    R0,R4                    Restore reason code\n         L     R14,12(0,R13)            Restore return address\n         LM    R1,R12,24(R13)           Restore other registers\n         BSM   0,R14                    and return\n\nG_Literals  DS   0H\n\nG_Sort_SMsg DC C'SORT Cmd avail'\nG_Sort_LMsg DC C'''SORT'' can be used to sort the table'\n\nG_BRIF_SMsg DC C'BRIF substituted'\nG_BRIF_LMsg DC C'Panel &PNLNAME not found'\n\n         LTORG\n\nG_Literals_End  DS   0H\n\n\n@G_Dynam                  DSECT        Dynamic area for G00000\n                          DS    18F     O/S Style save area\n@G_31Bit_Stack_Ptr_Ptr    DS    AL4     A(31-bit Stack Ptr)\n@G_24Bit_Stack_Ptr_Ptr    DS    AL4     A(24-bit Stack Ptr)\n@G_DBLWD                  DS    D       Work area\n@G_ISPF_Parms             DS    10FL4   ISPF Parm list\n                          DS    X       Flag Byte\n@G_SETMSG_Issued          EQU   *-1,X'80' 1... .... SETMSG issued\n\n@G_Parms                  DS    0F      Parms for called rtns\n@G_Parms_Std              DS    3AL4     Standard 3 parms\n@G_Parms_Extra            EQU   *        Extra parms\n                          ORG   ,\n                          DS    0D      Alignment\n@G_Dynam_Length           EQU   *-@G_Dynam Length of storage\n\n&PGMNAME CSECT\n\n         DROP  ,\n         POP   USING\n\n         TITLE 'H00010: Issue LSPACE for device'\n\n         PUSH  USING\n\nH00010   DS    0H\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Routine   : H00010                                                 *\n*                                                                     *\n*  Abstract  : Issue LSPACE and save selected F4 DSCB data            *\n*                                                                     *\n*  Inputs    : R1 : ---> A(@_Dynam)                                   *\n*                        A(31-bit Stack Pointer)                      *\n*                        A(24-bit Stack Pointer)                      *\n*                        A(Volume Table)                              *\n*  Outputs   : VolTbl updated                                         *\n*                                                                     *\n*  Operation : Initialize                                             *\n*                Do while unprocessed entries in Volume Table         *\n*                  Flag entry as processed                            *\n*                  Issue STIMER                                       *\n*                  Issue LSPACE for device described by VolTbl_Ent    *\n*                  Cancel STIMER                                      *\n*                  Format detail line                                 *\n*                  Update Totals                                      *\n*                  If last volume,                                    *\n*                    Format Totals line, if present                   *\n*                  EndIf                                              *\n*                EndDo                                                *\n*              Update Stats Line, if present                          *\n*              Terminate                                              *\n*                                                                     *\n*  History   : 1997/05/16 SDDA030 - New                               *\n*              1998/09/17 SDDA030 - V2.0                              *\n*                                 - Used Compare-and-Swap in pseudo-  *\n*                                   POST processing, rather than      *\n*                                   blindly ORing POST bit if no WAIT *\n*                                   was present.                      *\n*              1998/09/22 SDDA030 - V2.1                              *\n*                                 - Added ESTAE to trap ABENDs and    *\n*                                   POST SPACE with a code of 8.      *\n*                                 - Moved STIMERM from D00010 to this *\n*                                   routine.                          *\n*              1998/11/13 SDDA030 - V2.2                              *\n*                                 - This routine now goes through the *\n*                                   Volume Table, rather than WAITing *\n*                                   for SPACE to POST it with the     *\n*                                   address of an entry to process.   *\n*                                   ESTAE merely restarts the search  *\n*                                   through the table, rather than    *\n*                                   POSTing the ECB (there seems to be*\n*                                   no point in re-ATTACHing after an *\n*                                   ESTAE).                           *\n*              1999/09/01 SDDA030 - V2.9                              *\n*                                 - Do not use CDS instruction to up- *\n*                                   date totals fields, as they are   *\n*                                   now in the subtask area.          *\n*              2000/01/19 SDDA030 - V2.11                             *\n*                                 - Used areas within the VolTbl      *\n*                                   entry to hold control blocks from *\n*                                   LSPACE.                           *\n*                                 - Removed SMS anomaly check (now    *\n*                                   in E00010).                       *\n*              2000/05/23 SDDA030 - V2.12                             *\n*                                 - Removed STIMERM-related stuff     *\n*                                   Added IOSCDR to check if we can   *\n*                                   get out to the DASD device before *\n*                                   issuing LSPACE.                   *\n*              2001/02/01 SDDA030 - V2.13                             *\n*                                 - Undid stuff from V2.12            *\n*                                 - Replaced POST with ESTAE and      *\n*                                   ABEND in STIMERM exit (H06000).   *\n*                                 - Mimimum STIMERM WAIT time = 1 sec.*\n*                                 - Used micro-secs and MICVL instead *\n*                                   of Timer Units.                   *\n*              2001/02/26 SDDA030 - V2.14                             *\n*                                 - Removed detail and total line     *\n*                                   formatting.                       *\n*                                 - Used work area passed by E00010   *\n*                                   rather than GETMAIN.              *\n*              2001/11/12 SDDA030 - V2.15                             *\n*                                 - Corrected bug in calculating      *\n*                                   STIMERM times - all our times are *\n*                                   now maintained in usec.           *\n*                                 - Used STIMERM Wait time factor in  *\n*                                   calculating wait time.            *\n*              2002/03/11 SDDA030 - V2.17                             *\n*                                 - Generated LSPACE error messages   *\n*                                   internally, instead of asking     *\n*                                   LSPACE to do it.                  *\n*              2002/06/11 SDDA030 - V2.18                             *\n*                                 - Formatted detail and total lines  *\n*                                   in this routine.                  *\n*                                 - Filled in SubTask Statistics Line.*\n*              2006/04/21 SDDA030 - V2.24                             *\n*                                 - Rounded numbers in the display    *\n*                                   area where appropriate.           *\n*                                 - Used TRKCALC to get track size,   *\n*                                   rather than use DS4DEVTK. For     *\n*                                   example, for 3390s:               *\n*                                     DS4DEVTK = 58786                *\n*                                     TRKCALC  = 56664                *\n*                                 - Used standardized calling sequence*\n*                                 - Saved callers registers on the    *\n*                                   Linkage Stack                     *\n*                                 - Used STIMERM around LSPACE if     *\n*                                   MaxLWait specified                *\n*                                                                     *\n*  Notes     : This routine differs from the others in this program   *\n*              in that it is ATTACHed.                                *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n\n*---------------------------------------------------------------------*\n*     Save caller's registers, get dynamic storage, etc. etc.         *\n*---------------------------------------------------------------------*\n         BAKR  R14,0                    Save callers registers\n         LARL  R11,H_Literals           Point to our literals\n         USING (H_Literals,H_Literals_End),R11 Tell the assembler\n\n         L     R12,0(0,R1)              A(@_Dynam)\n         USING @_Dynam,R12              Tell the assembler\n\n*-------------------------------------------------------------------*\n*    Get some storage for our LIFO stack ...                        *\n*-------------------------------------------------------------------*\n         LHI   R0,@_31Bit_Stack_Length  Length of storage we need\n         SSCSTACK INIT,                 Go get our storage             +\n               LEN=(R0),                 this long                     +\n               LOC=31                    above-the-line\n\n         LR    R4,R1                    Save its address\n\n*-------------------------------------------------------------------*\n*    ... and get an area on it for our local storage                *\n*-------------------------------------------------------------------*\n         SSCSTACK PUSH,                 Get Stack area                 +\n               LEN=@H_Dynam_Length,      this long                     +\n               STACK=(R4)                 using this stack\n\n         LR    R3,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LHI   R1,@H_Dynam_Length        Its length\n         LA    R14,0                    Clear source address\n         LA    R15,0                     and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R3                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*-------------------------------------------------------------------*\n         LR    R13,R1                   Load dynam base\n         USING @H_Dynam,R13             Assign a base\n         MVC   4(4,R13),=C'F1SA'        Init save area\n         ST    R4,@H_31Bit_Stack_Ptr    Save A(Stack)\n\n         EREG  R0,R4                    Restore callers registers\n\n*---------------------------------------------------------------------*\n*     Save our parm addresses ...                                     *\n*---------------------------------------------------------------------*\n         ICM   R15,B'1111',12(R1)       A(Volume Table)\n         JZ    H90010                   Nothing, all done\n         ST    R15,@H_VolTbl_Ptr        Save it\n         LA    R14,VolTbl_Hdr_LSPACE_Avg-VolTbl_Hdr(R15)\n         ST    R14,@H_LSPACE_Avg_Ptr    Save it\n         LA    R14,VolTbl_Hdr_STIMERM_Adj-VolTbl_Hdr(R15)\n         ST    R14,@H_STIMERM_Adj_Ptr   Save it\n\n*---------------------------------------------------------------------*\n*     ... set up the addresses of the lines we need ...               *\n*---------------------------------------------------------------------*\n         L     R15,@H_VolTbl_Ptr        A(VolTbl)\n         ICM   R0,B'1111',VolTbl_Hdr_Total_Off-VolTbl_Hdr(R15) Totals\n         JZ    H00020                   None, skip\n         AR    R0,R15                   Convert offset to address\n         ST    R0,@H_Totals_Line_Ptr    Save it\nH00020   DS    0H\n         ICM   R0,B'1111',VolTbl_Hdr_SMS_Off-VolTbl_Hdr(R15) SMS msg\n         JZ    H00030                   None, skip\n         AR    R0,R15                   Convert offset to address\n         ST    R0,@H_SMS_Anomaly_Ptr    Save it\nH00030   DS    0H\n         ICM   R0,B'1111',VolTbl_Hdr_SubT_Off-VolTbl_Hdr(R15) SubTask\n         JZ    H00040                   None, skip\n         AR    R0,R15                   Convert offset to address\n         ST    R0,@H_Stats_Line_Ptr     Save it\n\nH00040   DS    0H\n*---------------------------------------------------------------------*\n*     ... and set our flag, indicating the presence of OW48527, and   *\n*     the maximum LSPACE Wait time                                    *\n*---------------------------------------------------------------------*\n        L     R15,@H_VolTbl_Ptr         A(VolTbl)\n        TM    VolTbl_Hdr_OW48527-VolTbl_Hdr(R15),L'VolTbl_Hdr_OW48527\n        JNO   H00040C                   Not installed, skip\n        OI    @H_OW48527,L'@H_OW48527   OK, set our flag\nH00040C DS    0H\n        MVC   @H_MaxLWait,VolTbl_Hdr_MaxLWait-VolTbl_Hdr(R15)\n\n*--------------------------------------------------------------------*\n*   Initialize our standard parmlist                                 *\n*--------------------------------------------------------------------*\n         LA    R15,@_Dynam              A(Dynamic area)\n         ST    R15,@H_Parms_Std         Save it\n         LA    R15,@H_31Bit_Stack_Ptr   A(31-bit Stack Pointer)\n         ST    R15,@H_Parms_Std+4       Save it\n         LA    R15,@H_24Bit_Stack_Ptr   A(24-bit Stack Pointer)\n         ST    R15,@H_Parms_Std+8       Save it\n\n*---------------------------------------------------------------------*\n*     Set up our ESTAE parms                                          *\n*---------------------------------------------------------------------*\n         MVC   @H_ESTAE_RMask,=X'FFFF'  Restore all registers\n\n*---------------------------------------------------------------------*\n*     Find an unprocessed entry in the Volume Table                   *\n*---------------------------------------------------------------------*\n         ICM   R9,B'1111',@H_VolTbl_Ptr Point to the Volume Table\n         JZ    H90010                   None, exit\n         ICM   R10,B'1111',VolTbl_Hdr_Count-VolTbl_Hdr(R9) Nbr entries\n         JZ    H90010                   None, exit\n         AHI   R9,VolTbl_Ent-VolTbl     Yes, point to the first\n\n         USING VolTbl_Ent,R9            Assign a base\n\nH00050   DS    0H\n*---------------------------------------------------------------------*\n*     Establish an ESTAE, if required                                 *\n*---------------------------------------------------------------------*\n         STM   R0,R15,@H_ESTAE_Regs     Save our registers for retry\n         MVC   @H_ESTAE_Retry,=AL4(H00380) Set retry address\n\n         TM    @H_ESTAE_Issued,L'@H_ESTAE_Issued Do we have an ESTAE?\n         JO    H00060                   Yes, skip\n\n         MVC   @H_ESTAE,H_ESTAE         Move L-Form\n         L     R3,=AL4(H07000)          A(Exit\n         ESTAEX (3),                    Establish ESTAE Exit           +\n               CT,                       create it                     +\n               PARAM=@H_Dynam,           passing this parm             +\n               MF=(E,@H_ESTAE)           keeping ourselves reentrant\n         LTR   R15,R15                  Did it work?\n         JNZ   H00060                   No, skip\n         OI    @H_ESTAE_Issued,L'@H_ESTAE_Issued Yes, set our flag\n\nH00060   DS    0H\n*---------------------------------------------------------------------*\n*     If this entry has not been processed ...                        *\n*---------------------------------------------------------------------*\n         XC    @H_Current_VolTbl_Ent,@H_Current_VolTbl_Ent\n\n         TM    VolTbl_Ent_Detail_Line,L'VolTbl_Ent_Detail_Line\n         JNO   H00410                   No, skip this entry\n         TM    VolTbl_Ent_SMS_Line,L'VolTbl_Ent_SMS_Line SMS Anomaly?\n         JO    H00410                   Yes, dont use it\n         XC    @H_Current_VolTbl_Ent,@H_Current_VolTbl_Ent\n\n         TM    VolTbl_Ent_Processed,L'VolTbl_Ent_Processed\n         JNZ   H00410                   Yes, try next\n\n*---------------------------------------------------------------------*\n*     ... Compare-and-Swap the flag byte, ...                         *\n*---------------------------------------------------------------------*\n         L     R1,VolTbl_Ent_Processed  No, get the Flag byte\n         LA    R0,L'VolTbl_Ent_Processed Set up the\n         SLL   R0,24                     flag turned\n         OR    R0,R1                     on\n         CS    R1,R0,VolTbl_Ent_Processed and update it\n         JNZ   H00410                   Somebody else here, skip\n\n*---------------------------------------------------------------------*\n*     ... bump our counters ...                                       *\n*---------------------------------------------------------------------*\n         L     R14,@H_Total_Vols_Proc   Get nbr vols we processed\n         AHI   R14,1                    Bump it\n         ST    R14,@H_Total_Vols_Proc   and save it\n\n*---------------------------------------------------------------------*\n*     Calculate the time we will WAIT for LSPACE to complete, if      *\n*     MaxLWait has not been specified.                                *\n*     We arbitrarily wait for (8 * Avg of all previously completed    *\n*    LSPACEs * Adjustment Factor), rounded up to the next second.     *\n*                                                                     *\n*     If we are running with OW48527, this time is passed to LSPACE;  *\n*    otherwise, we set up a STIMERM to pop after this time.           *\n*---------------------------------------------------------------------*\n         LH    R15,@H_MaxLWait          Get MaxLWait\n         CHI   R15,0                    Was it specified?\n         JNE   H00080                   Yes, use it\n         L     R15,@H_LSPACE_Avg_Ptr    A(Avg Wait for LSPACE in usec)\n         ICM   R15,B'1111',0(R15)       Get it\n         JNZ   H00070                   Something there, skip\n         L     R15,=FL4'250000'         Nothing, default to .25 sec\nH00070   DS    0H\n         LA    R14,0                    Clear R14\n         SLDL  R14,3                    Multiply by 8\n         L     R1,@H_STIMERM_Adj_Ptr    A(Adjustment factor)\n         M     R14,0(0,R1)              Adjust it\n         D     R14,=FL4'1000000'        Convert to seconds\n         AHI   R15,1                    Bump it\n         CHI   R15,5                    More than 5 seconds?\n         JNH   H00080                   No, OK\n         LHI   R15,5                    Yes, max of 5 secs\nH00080   DS    0H\n         ST    R15,@H_LSPACE_Wait_Max   Save it\n\n*---------------------------------------------------------------------*\n*   If we are running without APAR OW48527, or MaxLWait was specified,*\n*   update our ESTAE Retry routine address and registers ...          *\n*---------------------------------------------------------------------*\n         TM    @H_OW48527,L'@H_OW48527  Is the APAR on\n         JNO   H00090                   No, skip\n         LH    R0,@H_MaxLWait           Get MaxLWait\n         CHI   R0,0                     Was it specified?\n         JE    H00100                   No, skip\n\nH00090   DS    0H\n         ST    R9,@H_Current_VolTbl_Ent Save A(VolTbl_Ent) for ESTAE\n         STM   R0,R15,@H_ESTAE_Regs     Save our registers for retry\n         MVC   @H_ESTAE_Retry,=AL4(H00120) Set retry address\n\n*---------------------------------------------------------------------*\n*     ... and establish a timer, so we don't wait forever for LSPACE  *\n*---------------------------------------------------------------------*\n         LA    R15,@H_Dynam             A(Dynamic storage)\n         ST    R15,@H_STIMERM_Exit_Parms Save it for the exit routine\n         LA    R15,@H_STIMERM_Exit_Parms Point to parm area\n         ST    R15,@H_STIMERM_Exit_Parms_Ptr  Save the address\n         LA    R3,@H_STIMERM_Exit_Parms_Ptr Point to parm area addr\n         L     R4,=AL4(H06000)          A(Exit)\n\n         L     R15,@H_LSPACE_Wait_Max   Get nbr secs to wait\n         MHI   R15,100                  in BINTVL\n         ST    R15,@H_DBLWD             Save it\n\n         MVC   @H_STIMERM_Set,H_STIMERM_Set Move L-Form of macro\n         STIMERM SET,                   Set a timer                    +\n               ID=@H_STIMERM_ID,         save the ID here              +\n               BINTVL=@H_DBLWD,          for this long                 +\n               EXIT=(4),                 invoke this when we pop       +\n               PARM=(3),                 with this parm                +\n               WAIT=NO,                  Dont wait                     +\n               MF=(E,@H_STIMERM_Set)     keep ourselves reentrant\n\nH00100   DS    0H\n*---------------------------------------------------------------------*\n*     Set up our areas that will be used by LSPACE                    *\n*---------------------------------------------------------------------*\n         XC    VolTbl_Ent_LSPACE_Data,VolTbl_Ent_LSPACE_Data\n         XC    VolTbl_Ent_DSCB,VolTbl_Ent_DSCB Clear DSCB area\n         NI    VolTbl_Ent_LSPACE_Fail,X'FF'-L'VolTbl_Ent_LSPACE_Fail\n\n*---------------------------------------------------------------------*\n*     Save the current TOD (ie, when LSPACE started)                  *\n*---------------------------------------------------------------------*\n         MVC   @H_TIME,H_TIME           MOVE Time macro\n         TIME  STCK,                    Get the current time           +\n               @H_LSPACE_Start,          return it here                +\n               LINKAGE=SYSTEM,           as recommended by IBM         +\n               MF=(E,@H_TIME)            staying re-entrant\n\n*---------------------------------------------------------------------*\n*     Set up the LSPACE parms, including LSPAXTIM if we are both      *\n*    assembling and running on systems with OW48527                   *\n*---------------------------------------------------------------------*\n         MVC   @H_LSPACE,H_LSPACE       Move LSPACE parms\n         AIF   (NOT D'LSPAXTIM).OW48527_200\n         TM    @H_OW48527,L'@H_OW48527  Are we running with OW48527?\n         JNO   H00110                   No, skip\n         L     R15,@H_LSPACE_Wait_Max   Get Wait Time\n         ICM   R0,B'1111',@H_STIMERM_ID Did we set up a STIMER?\n         JNZ   H00110                   Yes, use LSPACE default\n         STC   R15,@H_LSPACE+LSPAXTIM-LSPACE_Parm Update wait limit\nH00110   DS    0H\n.OW48527_200 ANOP\n\n*---------------------------------------------------------------------*\n*     Get the volume info using LSPACE                                *\n*---------------------------------------------------------------------*\n         LA     R3,VolTbl_Ent_UCBCopy   A(Our UCB)\n         LSPACE UCB=(3),                Get free space                 +\n               DATA=VolTbl_Ent_LSPACE_Data, save return info here      +\n               F4DSCB=VolTbl_Ent_DSCB,   Return F4 DSCB too            +\n               MF=(E,@H_LSPACE)          Parm area here\n\nH00120   DS    0H\n*---------------------------------------------------------------------*\n*     Cancel our STIMERM, if there is one ...                         *\n*---------------------------------------------------------------------*\n         ICM   R15,B'1111',@H_STIMERM_ID  Did we establish a timer?\n         JZ    H00130                   No, skip\n\n         MVC   @H_STIMERM_Can,H_STIMERM_Cancel Move L-Form macro\n         STIMERM CANCEL,                Cancel our timer               +\n               ID=@H_STIMERM_ID,         with this Id                  +\n               MF=(E,@H_STIMERM_Can)     keep ourselves reentrant\n         XC    @H_STIMERM_ID,@H_STIMERM_ID Clear STIMERM ID\n\n*---------------------------------------------------------------------*\n*     ... and update our ESTAE retry routine pointer, now that LSPACE *\n*    is done                                                          *\n*---------------------------------------------------------------------*\n         STM   R0,R15,@H_ESTAE_Regs     Save our registers for retry\n         MVC   @H_ESTAE_Retry,=AL4(H00380) Set retry address\n\nH00130   DS    0H\n*---------------------------------------------------------------------*\n*     Save the current TOD, and calculate the amount of time we have  *\n*    been waiting for LSPACE ...                                      *\n*---------------------------------------------------------------------*\n         MVC   @H_TIME,H_TIME           MOVE Time macro\n         TIME  STCK,                    Get the current time           +\n               @H_TIME_Area,             return it here                +\n               LINKAGE=SYSTEM,           as recommended by IBM         +\n               MF=(E,@H_TIME)            staying re-entrant\n\n         LM    R14,R15,@H_Time_Area     Get current time\n         SL    R15,@H_LSPACE_Start+4    Calculate\n         JNM   H00140                   No borrow, skip\n         SL    R14,=FL4'1'              Borrow, reduce\nH00140   DS    0H\n         SL    R14,@H_LSPACE_Start      Calculate WAIT time\n         SRDL  R14,12                   in usec\n         STM   R14,R15,@H_LSPACE_Wait   Save it\n\n*---------------------------------------------------------------------*\n*     ... and add it to the appropriate total (Successful or          *\n*    Unsuccessful LSPACE WAIT time)                                   *\n*---------------------------------------------------------------------*\n         LA    R3,@H_Total_LSPACE_Wait_OK     Assume all worked\n         CLI   @H_LSPACE+LSPAERCD-LSPACE_Parm,X'00' Did LSPACE Work?\n         JE    H00150                   Yes, skip\n         LA    R3,@H_Total_LSPACE_Wait_Bad  No, A(unsuccess total)\n\nH00150   DS    0H\n         LM    R0,R1,0(R3)              Get total (in usec)\n         ALR   R1,R15                   Add the wait time\n         BRC   12,H00160                No carry, skip\n         AL    R0,=FL4'1'               Carry, bump\nH00160   DS    0H\n         ALR   R0,R14                   Bump Wait totals\n         STM   R0,R1,0(R3)              Save Wait Time totals\n\n*---------------------------------------------------------------------*\n*     If LSPACE failed ...                                            *\n*---------------------------------------------------------------------*\n         CLI   @H_LSPACE+LSPAERCD-LSPACE_Parm,X'00' Did LSPACE Work?\n         JE    H00220                   Yes, skip\n\n*---------------------------------------------------------------------*\n*     ... flag the VolTbl_Ent, and generate an appropriate message (we*\n*    generate our own messages, because we would have to re-invoke    *\n*    LSPACE to get LSPACE to do it, and the conditions that caused it *\n*    to fail initially may have changed or disappeared by the time we *\n*    issue LSPACE again) ...                                          *\n*---------------------------------------------------------------------*\n         OI    VolTbl_Ent_LSPACE_Fail,L'VolTbl_Ent_LSPACE_Fail\n         CLC   =X'14850000',@H_LSPACE+LSPAERCD-LSPACE_Parm ESTAE?\n         JNE   H00170                   No, skip\n         TM    VolTbl_Ent_U522,L'VolTbl_Ent_U522 Because of us?\n         JNO   H00170                   No, skip\n         MVC   VolTbl_Ent_ErrMsg(L'H_MsgU522A),H_MsgU522A Say so\n         LH    R0,@H_MaxLWait           Get MaxLWait\n         CVD   R0,@H_DBLWD              Pack it\n         MVC   @H_DBLWD(4),=X'40202120' Move mask\n         LA    R1,@H_DBLWD+3            Set up start marker\n         EDMK  @H_DBLWD(4),@H_DBLWD+6   Edit it\n         LA    R14,@H_DBLWD+3           Last possible character\n         SR    R14,R1                   Length of result\n         LR    R15,R1                   A(Source)\n         AHI   R15,-3                   Adjust it\n         LA    R1,VolTbl_Ent_ErrMsg+L'H_MsgU522A A(Target)\n         EX    R14,H_MVC                Move MaxLWait\n         LA    R1,1(R1,R14)             Point last it\n         MVC   0(L'H_MsgU522B,R1),H_MsgU522B Move remainder\n         J     H00210                   and skip\nH00170   DS    0H\n         L     R15,=AL4(H_LSPACE_Msgs)  A(Message Table)\n         LA    R14,0                    Clear work register\nH00180   DS    0H\n         CLC   0(1,R15),@H_LSPACE+LSPAERCD-LSPACE_Parm  Our RC?\n         JNE   H00190                   No, skip\n         CLI   1(R15),X'00'             Yes, should we check SubFunc?\n         JE    H00200                   No, use this message\n         CLC   1(1,R15),@H_LSPACE+LSPASFID-LSPACE_Parm  Yes, our SF?\n         JE    H00200                   Yes, skip\nH00190   DS    0H\n         CLC   0(2,R15),=X'0000'        No, last entry?\n         JE    H00200                   Yes, we'd better use it\n         IC    R14,2(0,R15)             No, get len of message\n         LA    R15,3(R14,R15)           Point to next entry\n         J     H00180                   and check it out\n\nH00200   DS    0H\n         IC    R14,2(0,R15)             Length of the message\n         AHI   R14,-1                   EX Len\n         LA    R1,VolTbl_Ent_ErrMsg     A(Target)\n         EX    R14,H_MVC                Move the message\n         LA    R14,1(R1,R14)            Point past it\n         MVC   0(29,R14),=C', DADSM/CVAF Diagnostic Info:'\n         MVO   @H_DBLWD(5),@H_LSPACE+LSPAERCD-LSPACE_Parm(4)\n         OI    @H_DBLWD+4,X'0F'         'Pack' it\n         UNPK  29(9,R14),@H_DBLWD(5)    Unpack it\n         MVI   29(R14),C' '             Move separator\n         LA    R15,H_TrTbl              Point to translate table\n         AHI   R15,-240                 Adjust pointer\n         TR    30(8,R14),0(R15)         Make it readable\nH00210   DS    0H\n         J     H00380                   Go process next volume\n\nH00220   DS    0H\n*---------------------------------------------------------------------*\n*     LSPACE worked, so re-calculate the average time used by LSPACE  *\n*---------------------------------------------------------------------*\n         L     R3,@H_LSPACE_Avg_Ptr     A(Timer area)\nH00230   DS    0H\n         LM    R0,R1,0(R3)              Get Avg ms, nbr LSPACEs done\n         LR    R15,R0                   Get Avg micro-secs\n         MR    R14,R1                   Calculate total micro-secs\n         AL    R15,@H_LSPACE_Wait+4     Add the ones we used\n         BRC   12,H00240                No carry, skip\n         AL    R14,=FL4'1'              Carry, bump\nH00240   DS    0H\n         AL    R14,@H_LSPACE_Wait       Bump total WAIT time\n         LR    R4,R1                    Get total LSPACEs completed\n         AHI   R4,1                     Bump because we just finished\n         DR    R14,R4                   Re-calculate average\n         LR    R14,R15                  Set up new values for\n         LR    R15,R4                    Avg, # completed LSPACEs\n         CDS   R0,R14,0(R3)             Update them\n         JNE   H00230                   Collision, try again\n\n*---------------------------------------------------------------------*\n*     If the previous volume we processed wasn't on the same device   *\n*    type as this one, use TRKCALC to get the track size              *\n*---------------------------------------------------------------------*\n         CLC   @H_UCBTBYT4,VolTbl_Ent_UCBCopy+UCBTBYT4-UCBOB Same?\n         JE    H00270                   Yes, skip\n         MVC   @H_UCBTBYT4,VolTbl_Ent_UCBCopy+UCBTBYT4-UCBOB No\n         TRKCALC FUNCTN=TRKBAL,         Track balance                  +\n               TYPE=@H_UCBTBYT4,         A(Type)                       +\n               LOC=ANY,                  which is above the line       +\n               R=1,                      an empty track                +\n               K=0,                      no keys                       +\n               DD=VolTbl_Ent_DSCB+DS4DEVTK-IECSDSL4,  max size         +\n               REMOVE=NO,                Use an empty track            +\n               MAXSIZE=YES,              Return max we can use         +\n               REGSAVE=YES,              Save registers                +\n               MF=(E,@H_TRKCALC)         staying re-entrant\n         CHI   R15,12                    How did it go?\n         JNL   H00250                    Not good, set default\n         LTR   R0,R0                     Did we get a size back?\n         JNZ   H00260                    Yes, OK\nH00250   DS    0H\n         LH    R0,VolTbl_Ent_DSCB+DS4DEVTK-IECSDSL4 No, use default\n         XC    @H_UCBTBYT4,@H_UCBTBYT4\nH00260   DS    0H\n         ST    R0,@H_BytesPerTrack       Save bytes per track\nH00270   DS    0H\n\n*---------------------------------------------------------------------*\n*     Format the LSPACE info about this volume, and update our        *\n*    totals ...                                                       *\n*---------------------------------------------------------------------*\n         L     R15,@H_Total_Vols_OK     Get total valid volumes\n         AHI   R15,1                    Bump it\n         ST    R15,@H_Total_Vols_OK     Save it\n\n*     Tracks in the VTOC\n\n         LH    R0,VolTbl_Ent_DSCB+DS4DEVSZ+2-IECSDSL4 Get Trks/Cyl\n         LA    R1,0                     Clear register\n         ICM   R1,B'0011',VolTbl_Ent_DSCB+DS4VTOCE+6-IECSDSL4 Ending CC\n         LA    R15,0                    Clear register\n         ICM   R15,B'0011',VolTbl_Ent_DSCB+DS4VTOCE+2-IECSDSL4\n         SR    R1,R15                   End CC minus start CC\n         MR    R0,R0                          Get nbr tracks\n         AH    R1,VolTbl_Ent_DSCB+DS4VTOCE+8-IECSDSL4 Add ending HH\n         SH    R1,VolTbl_Ent_DSCB+DS4VTOCE+4-IECSDSL4 Less starting HH\n         AHI   R1,1                     Bump it\n         CDFBR R0,R1                    Convert to floating point\n         LA    R1,VolTbl_Ent_VTOCTrk    Point to output field\n         LHI   R0,L'VolTbl_Ent_VTOCTrk  Length of output field\n         BRAS  R14,H03000               Put in table\n\n         STD   R0,VolTbl_Ent_Sort_VTOCTrk Save it\n         ADB   R0,@H_Total_VTOCTrk      Bump total\n         STD   R0,@H_Total_VTOCTrk       and save it\n\n*     Total DSCBS in the VTOC\n\n         LA    R0,0                     Clear work reg\n         IC    R0,VolTbl_Ent_DSCB+DS4DEVDT-IECSDSL4 DSCBS/Trk\n         CDFBR R0,R0                    Convert to floating point\n         MDB   R0,VolTbl_Ent_Sort_VTOCTrk Nbr tracks in the VTOC\n\n         STD   R0,@H_TotDSCB            Save it\n         ADB   R0,@H_Total_DSCBs        Bump total\n         STD   R0,@H_Total_DSCBs        and save it\n\n*     Free DSCBs in the VTOC\n\n         L     R1,VolTbl_Ent_LSPACE_Data+LSPDF0S-LSPACE_Data Free DSCBs\n         CDFBR R0,R1                    Convert to floating point\n         LA    R1,VolTbl_Ent_FreeDSCB   Point to output field\n         LHI   R0,L'VolTbl_Ent_FreeDSCB Length of output field\n         BRAS  R14,H03000               Put in table\n\n         STD   R0,VolTbl_Ent_Sort_FreeDSCB Save for sorting\n         ADB   R0,@H_Total_FreeDSCBs    Bump total\n         STD   R0,@H_Total_FreeDSCBs    and save it\n\n*     % Free DSCBs in the VTOC\n\n         L     R1,VolTbl_Ent_LSPACE_Data+LSPDF0S-LSPACE_Data Free DSCBs\n         CDFBR R0,R1                    Convert to floating point\n         MDB   R0,=DBL8'1000'           100.0%\n         DDB   R0,@H_TotDSCB            Calc % free DSCBs\n         LA    R1,VolTbl_Ent_VTOCFree   Point to target field\n         LHI   R0,L'VolTbl_Ent_VTOCFree Length of output field\n         BRAS  R14,H03000               Put in table\n\n         DDB   R0,=DBL8'10'             back to xx.x%\n         STD   R0,VolTbl_Ent_Sort_VTOCFree Save it\n\n*     Total bytes on the volume\n\n         LA    R0,0                     Clear register\n         ICM   R0,B'0011',VolTbl_Ent_DSCB+DS4DEVSZ+2-IECSDSL4 Trks/Cyl\n         CDFBR R0,R0                    Convert to floating point\n         LA    R0,0                     Clear register\n         ICM   R0,B'0011',VolTbl_Ent_DSCB+DS4DEVSZ-IECSDSL4 Cyls/Device\n*        Begin Inserts Mahler, 13.NOV.2015 in order to support EAV\n         CLFI  R0,DS4EAV                R0=DS4EAV (X'0000FFFE')?\n         BNE   H00275                   Non EAV-Volume, New Label|\n         L     R0,VolTbl_Ent_DSCB+DS4DCYL-IECSDSL4 Cyls/Device (EAV)\n*        End   Inserts Mahler, 13.NOV.2015 in order to support EAV\nH00275   CDFBR R2,R0                    Convert to floating point\n         MDBR  R0,R2                    Get Trks/Device\n         LA    R0,0                     Clear work register\n         L     R0,@H_BytesPerTrack      Bytes/Trk\n         CDFBR R2,R0                    Convert to floating point\n         MDBR  R0,R2                    Bytes/Device\n         STD   R0,VolTbl_Ent_Sort_VolSize Save for sorting\n         STD   R0,@H_VolSize            Save it\n         LA    R1,VolTbl_Ent_VolSize    Point to output field\n         LHI   R0,L'VolTbl_Ent_VolSize  Length of output field\n         BRAS  R14,H03000               Put in table\n\n         ADB   R0,@H_Total_VolSize      Bump total\n         STD   R0,@H_Total_VolSize      and save it\n\n*     Nbr Free Extents on the volume\n\n         L     R1,VolTbl_Ent_LSPACE_Data+LSPDNEXT-LSPACE_Data Free ext\n         CDFBR R0,R1                    Convert to floating point\n         LA    R1,VolTbl_Ent_FreeExt    Point to output field\n         LHI   R0,L'VolTbl_Ent_FreeExt  Length of output field\n         BRAS  R14,H03000               Put in table\n\n         STD   R0,VolTbl_Ent_Sort_FreeExt Save for sorting\n         ADB   R0,@H_Total_Extents      Bump total\n         STD   R0,@H_Total_Extents      and save it\n\n*     Free Tracks on the volume\n\n         L     R0,VolTbl_Ent_LSPACE_Data+LSPDTCYL-LSPACE_Data Free Cyls\n         CDFBR R0,R0                    Convert to floating point\n         LH    R0,VolTbl_Ent_DSCB+DS4DEVSZ+2-IECSDSL4 Trks/Cyl\n         CDFBR R2,R0                    Convert to floating point\n         MDBR  R0,R2                    Get nbr free trks (in cyls)\n         L     R0,VolTbl_Ent_LSPACE_Data+LSPDTTRK-LSPACE_Data Free trks\n         CDFBR R2,R0                    Convert to floating point\n         ADBR  R0,R2                    Bump nbr trks\n         STD   R0,VolTbl_Ent_Sort_FreeTrk Save for sorting\n         LA    R1,VolTbl_Ent_FreeTrk    Point to output field\n         LHI   R0,L'VolTbl_Ent_FreeTrk  Length of output field\n         BRAS  R14,H03000               Put in table\n\n         ADB   R0,@H_Total_FreeTracks   Bump total\n         STD   R0,@H_Total_FreeTracks   and save it\n\n*     Free Bytes on the volume\n\n         LD    R0,VolTbl_Ent_Sort_FreeTrk Get nbr free tracks\n         LA    R0,0                     Clear work register\n         L     R0,@H_BytesPerTrack      Bytes/Trk\n         CDFBR R2,R0                    Convert to Floating point\n         MDBR  R0,R2                    Nbr free bytes\n         STD   R0,VolTbl_Ent_Sort_FreeBytes Save for sorting\n         LA    R1,VolTbl_Ent_FreeBytes  Point to output field\n         LHI   R0,L'VolTbl_Ent_FreeBytes Length of output field\n         BRAS  R14,H03000               Put in table\n\n         ADB   R0,@H_Total_FreeBytes    Bump totals\n         STD   R0,@H_Total_FreeBytes    and save it\n\n*     % Free space on the volume\n\n         LD    R0,VolTbl_Ent_Sort_FreeBytes Free Bytes on the volume\n         MDB   R0,=DBL8'1000'           Set up for % calc (100.0%)\n         DDB   R0,@H_VolSize            Divide by Bytes/Device\n         LA    R1,VolTbl_Ent_FreePct    Point to output field\n         LHI   R0,L'VolTbl_Ent_FreePct  Length of output field\n         BRAS  R14,H03000               Put in table\n\n         DDB   R0,=DBL8'10'             Convert to xx.x%\n         STD   R0,VolTbl_Ent_Sort_FreePct Save it\n\n*     Free Cylinders on the volume\n\n         L     R1,VolTbl_Ent_LSPACE_Data+LSPDTCYL-LSPACE_Data Free Cyls\n         CDFBR R0,R1                    Convert to floating point\n         LA    R1,VolTbl_Ent_FreeCyl    Point to output field\n         LHI   R0,L'VolTbl_Ent_FreeCyl  Length of output field\n         BRAS  R14,H03000               Put in table\n\n         STD   R0,VolTbl_Ent_Sort_FreeCyl Save for sorting\n         ADB   R0,@H_Total_FreeCyls     Bump totals\n         STD   R0,@H_Total_FreeCyls     and save it\n\n*     Largest extent (in tracks) on the volume\n\n         L     R0,VolTbl_Ent_LSPACE_Data+LSPDLCYL-LSPACE_Data Larg Cyls\n         CDFBR R0,R0                    Convert to FP\n         LH    R0,VolTbl_Ent_DSCB+DS4DEVSZ+2-IECSDSL4 Trks/Cyl\n         CDFBR R2,R0                    Convert to FP\n         MDBR  R0,R2                    Get nbr trks\n         L     R0,VolTbl_Ent_LSPACE_Data+LSPDLTRK-LSPACE_Data Get trks\n         CDFBR R2,R0                    Convert to FP\n         ADBR  R0,R2                    Add to total\n         STD   R0,VolTbl_Ent_Sort_LargTrk Save for sorting\n         LA    R1,VolTbl_Ent_LargTrk    Point to output field\n         LHI   R0,L'VolTbl_Ent_LargTrk  Length of output field\n         BRAS  R14,H03000               Put in table\n\n         CDB   R0,@H_Largest_FreeTracks Biggest so far?\n         JNH   H00280                   No, skip\n         STD   R0,@H_Largest_FreeTracks Yes, save it\n\nH00280   DS    0H\n\n*     Largest extent (in cylinders) on the volume\n\n         L     R0,VolTbl_Ent_LSPACE_Data+LSPDLCYL-LSPACE_Data Larg Cyls\n         CDFBR R0,R0                    Convert to floating point\n         LA    R1,VolTbl_Ent_LargCyl    Point to output field\n         LHI   R0,L'VolTbl_Ent_LargCyl  Length of output field\n         BRAS  R14,H03000               Put in table\n\n         STD   R0,VolTbl_Ent_Sort_LargCyl Save for sorting\n         CDB   R0,@H_Largest_FreeCyls   Largest so far?\n         JNH   H00290                   No, skip\n         STD   R0,@H_Largest_FreeCyls   Yes, save it\n\nH00290   DS    0H\n*---------------------------------------------------------------------*\n*     VTOC IX Status: A - Active                                      *\n*                     E - Exists, but not active                      *\n*                     N - Does not exist                              *\n*---------------------------------------------------------------------*\n         TM    VolTbl_Ent_LSPACE_Data+LSPDSTAT-LSPACE_Data,LSPDIXAC\n         JO    H00300                   Yes, skip\n         TM    VolTbl_Ent_LSPACE_Data+LSPDSTAT-LSPACE_Data,LSPDIXDS IX?\n         JO    H00310                   Yes, skip\n         MVI   VolTbl_Ent_VTOCIX+1,C'N' No, No IX VTOC\n         J     H00320                   and skip\nH00300   DS    0H\n         MVI   VolTbl_Ent_VTOCIX+1,C'A' IX VTOC active\n         J     H00320                   and skip\nH00310   DS    0H\n         MVI   VolTbl_Ent_VTOCIX+1,C'Y' IX VTOC exists\n         J     H00320                   and skip\n\nH00320   DS    0H\n*---------------------------------------------------------------------*\n*     Fragmentation Index                                             *\n*---------------------------------------------------------------------*\n         L     R0,VolTbl_Ent_LSPACE_Data+LSPDFRAG-LSPACE_Data Frag Indx\n         CHI   R0,999                   Too big?\n         JNH   H00330                   No, OK\n         LHI   R0,999                   Yes, set to max\nH00330   DS    0H\n         CDFBR R0,R0                    Convert to floating point\n         LHI   R0,L'VolTbl_Ent_Frag_Indx Len of target field\n         LA    R1,VolTbl_Ent_Frag_Indx  Point to it\n         BRAS  R14,H03000               Go format it\n\n         ADB   R0,@H_Total_FragIndex    Bump totals\n         STD   R0,@H_Total_FragIndex    and save it\n\n*---------------------------------------------------------------------*\n*     SMS Anomaly                                                     *\n*---------------------------------------------------------------------*\n         CLI   VolTbl_Ent_DSCB+DS4SMSFG-IECSDSL4,DS4NTSMS SMS in VTOC?\n         JE    H00340                   No, skip\n         TM    VolTbl_Ent_UCBCOPY+UCBFL5-UCBOB,UCBSMS Yes, UCB SMS too?\n         JO    H00370                   Yes, OK\n         J     H00350                   No, set message\nH00340   DS    0H\n         TM    VolTbl_Ent_UCBCOPY+UCBFL5-UCBOB,UCBSMS NO, UCB = SMS?\n         JZ    H00370                   No, OK\nH00350   DS    0H\n         MVI   VolTbl_Ent_VTOC_SMS,C'*' No, flag it\n         ICM   R14,B'1111',@H_SMS_Anomaly_Ptr  Yes, A(SMS Anomaly line)\n         JZ    H00370                   None, skip\n         TM    VolTbl_Ent_ECB-VolTbl_Ent(R14),X'40' Already done?\n         JO    H00370                   Yes, skip\n         LA    R0,VolTbl_Ent_VTOC_SMS-VolTbl_Ent(0,R14) A(Target)\n         LHI   R1,VolTbl_Ent_Display_End-VolTbl_Ent_VTOC_SMS Target Len\n         LA    R14,H_SMS_Anomaly_Msg    A(Source)\n         LA    R15,L'H_SMS_Anomaly_Msg  Source length\n         O     R15,=XL4'40000000'       Fill with blanks\n         MVCL  R0,R14                   Move message\n\n         L     R15,@H_SMS_Anomaly_Ptr   A(SMS Anomaly line)\n         L     R0,VolTbl_Ent_ECB-VolTbl_Ent(R15) Current ECB\n         TM    VolTbl_Ent_ECB-VolTbl_Ent(R15),X'80' Anyone WAITing?\n         JO    H00360                   Yes, we need to POST\n         L     R1,=XL4'40000000'        No, POST code of 0\n         CS    R0,R1,VolTbl_Ent_ECB-VolTbl_Ent(R15) Pseudo-POST it\n         JZ    H00370                   OK, skip the real POST\nH00360   DS    0H\n         POST  VolTbl_Ent_ECB-VolTbl_Ent(R15),0 POST line as complete\nH00370   DS    0H\n\nH00380   DS    0H\n*---------------------------------------------------------------------*\n*     POST this entry as complete ...                                 *\n*---------------------------------------------------------------------*\n         L     R14,VolTbl_Ent_ECB       Current contents of our ECB\n         TM    VolTbl_Ent_ECB,X'80'     Anyone WAITing?\n         JO    H00390                   Yes, we need to POST\n         L     R15,=XL4'40000000'       No, POST code of 0\n         CS    R14,R15,VolTbl_Ent_ECB   Pseudo-POST it\n         JZ    H00400                   OK, skip the real POST\nH00390   DS    0H\n         POST  VolTbl_Ent_ECB,0         Flag as complete\nH00400   DS    0H\n\nH00410   DS    0H\n*---------------------------------------------------------------------*\n*     ... and see if we can find another volume to do.                *\n*---------------------------------------------------------------------*\n         AHI   R9,VolTbl_Ent_Len        Point to next VolTbl_Ent\n         BRCT  R10,H00050               and check it out\n\n*---------------------------------------------------------------------*\n*     We are done - update the totals, if required ...                *\n*---------------------------------------------------------------------*\n         ICM   R9,B'1111',@H_Totals_Line_Ptr   A(Totals Line)\n         JZ    H00560                   None, skip\n\nH00420   DS    0H\n         L     R0,VolTbl_Ent_Total_Vols_OK Curr count\n         LR    R1,R0                    Save it\n         A     R1,@H_Total_Vols_OK      Bump it\n         CS    R0,R1,VolTbl_Ent_Total_Vols_OK Update it\n         JNZ   H00420                   Collision, try again\n\n         LD    R0,@H_Total_VTOCTrk      Amount we did\nH00430   DS    0H\n         LM    R0,R1,VolTbl_Ent_Total_VTOCTrk Orig Val\n         STM   R0,R1,@H_DBLWD           Save original value\n         LD    R2,@H_DBLWD              Load up FP register\n         ADBR  R2,R0                    Bump it\n         STD   R2,@H_DBLWD              Save updated total\n         LM    R2,R3,@H_DBLWD           Get new totals\n         CDS   R0,R2,VolTbl_Ent_Total_VTOCTrk Update it\n         JNZ   H00430                   Collision, try again\n\n         LD    R0,@H_Total_DSCBs        Get amount we did\nH00440   DS    0H\n         LM    R0,R1,VolTbl_Ent_Total_DSCBs\n         STM   R0,R1,@H_DBLWD           Save original value\n         LD    R2,@H_DBLWD              Load up FP register\n         ADBR  R2,R0                    Bump it\n         STD   R2,@H_DBLWD              Save updated total\n         LM    R2,R3,@H_DBLWD           Get old, new totals\n         CDS   R0,R2,VolTbl_Ent_Total_DSCBs Update it\n         JNZ   H00440                   Collision, try again\n\n         LD    R0,@H_Total_FreeDSCBs    Get amount we did\nH00450   DS    0H\n         LM    R0,R1,VolTbl_Ent_Total_FreeDSCBs\n         STM   R0,R1,@H_DBLWD           Save original value\n         LD    R2,@H_DBLWD              Load up FP register\n         ADBR  R2,R0                    Bump it\n         STD   R2,@H_DBLWD              Save updated total\n         LM    R2,R3,@H_DBLWD           Get old, new totals\n         CDS   R0,R2,VolTbl_Ent_Total_FreeDSCBs Update\n         JNZ   H00450                   Collision, try again\n\n         LD    R0,@H_Total_VolSize      Get amount we did\nH00460   DS    0H\n         LM    R0,R1,VolTbl_Ent_Total_VolSize\n         STM   R0,R1,@H_DBLWD           Save original value\n         LD    R2,@H_DBLWD              Load up FP register\n         ADBR  R2,R0                    Bump it\n         STD   R2,@H_DBLWD              Save updated total\n         LM    R2,R3,@H_DBLWD           Get old, new totals\n         CDS   R0,R2,VolTbl_Ent_Total_VolSize Update it\n         JNZ   H00460                   Collision, try again\n\n         LD    R0,@H_Total_Extents      Get amount we did\nH00470   DS    0H\n         LM    R0,R1,VolTbl_Ent_Total_Extents\n         STM   R0,R1,@H_DBLWD           Save original value\n         LD    R2,@H_DBLWD              Load up FP register\n         ADBR  R2,R0                    Bump it\n         STD   R2,@H_DBLWD              Save updated total\n         LM    R2,R3,@H_DBLWD           Get old, new totals\n         CDS   R0,R2,VolTbl_Ent_Total_Extents Update it\n         JNZ   H00470                   Collision, try again\n\n         LD    R0,@H_Total_FreeTracks   Get amount we did\nH00480   DS    0H\n         LM    R0,R1,VolTbl_Ent_Total_FreeTracks\n         STM   R0,R1,@H_DBLWD           Save original value\n         LD    R2,@H_DBLWD              Load up FP register\n         ADBR  R2,R0                    Bump it\n         STD   R2,@H_DBLWD              Save updated total\n         LM    R2,R3,@H_DBLWD           Get old, new totals\n         CDS   R0,R2,VolTbl_Ent_Total_FreeTracks Update\n         JNZ   H00480                   Collision, try again\n\n         LD    R0,@H_Total_FreeBytes    Get amount we did\nH00490   DS    0H\n         LM    R0,R1,VolTbl_Ent_Total_FreeBytes\n         STM   R0,R1,@H_DBLWD           Save original value\n         LD    R2,@H_DBLWD              Load up FP register\n         ADBR  R2,R0                    Bump it\n         STD   R2,@H_DBLWD              Save updated total\n         LM    R2,R3,@H_DBLWD           Get old, new totals\n         CDS   R0,R2,VolTbl_Ent_Total_FreeBytes Update\n         JNZ   H00490                   Collision, try again\n\n         LD    R0,@H_Total_FreeCyls     Get amount we did\nH00500   DS    0H\n         LM    R0,R1,VolTbl_Ent_Total_FreeCyls\n         STM   R0,R1,@H_DBLWD           Save original value\n         LD    R2,@H_DBLWD              Load up FP register\n         ADBR  R2,R0                    Bump it\n         STD   R2,@H_DBLWD              Save updated total\n         LM    R2,R3,@H_DBLWD           Get old, new totals\n         CDS   R0,R2,VolTbl_Ent_Total_FreeCyls Update\n         JNZ   H00500                   Collision, try again\n\n         LD    R0,@H_Largest_FreeTracks Get the biggest we did\nH00510   DS    0H\n         LM    R0,R1,VolTbl_Ent_Largest_FreeTracks\n         STM   R0,R1,@H_DBLWD           Save original value\n         LD    R2,@H_DBLWD              Load up FP register\n         CDBR  R0,R2                    Biggest so far?\n         JNH   H00520                   No, skip\n         STD   R0,@H_DBLWD              Yes, save new largest\n         LM    R2,R3,@H_DBLWD           Get old, new values\n         CDS   R0,R2,VolTbl_Ent_Largest_FreeTracks\n         JNZ   H00510                   Collision, try again\n\nH00520   DS    0H\n\n         LD    R0,@H_Largest_FreeCyls   Get the largest we did\nH00530   DS    0H\n         LM    R0,R1,VolTbl_Ent_Largest_FreeCyls\n         STM   R0,R1,@H_DBLWD           Save original value\n         LD    R2,@H_DBLWD              Load up FP register\n         CDBR  R0,R2                    Biggest so far?\n         JNH   H00540                   No, skip\n         STD   R0,@H_DBLWD              Yes, save new largest\n         LM    R2,R3,@H_DBLWD           Get old, new values\n         CDS   R0,R2,VolTbl_Ent_Largest_FreeCyls\n         JNZ   H00530                   Collision, try again\n\nH00540   DS    0H\n\n         LD    R0,@H_Total_FragIndex    Yes, bump totals\nH00550   DS    0H\n         LM    R0,R1,VolTbl_Ent_Total_FragIndex\n         STM   R0,R1,@H_DBLWD           Save original value\n         LD    R2,@H_DBLWD              Load up FP register\n         ADBR  R2,R0                    Bump it\n         STD   R2,@H_DBLWD              Save updated total\n         LM    R2,R3,@H_DBLWD           Get old, new totals\n         CDS   R0,R2,VolTbl_Ent_Total_FragIndex Update\n         JNZ   H00550                   Collision, try again\n\nH00560   DS    0H\n*---------------------------------------------------------------------*\n*     ... and then the total number of volumes we did                 *\n*---------------------------------------------------------------------*\n         L     R15,@H_VolTbl_Ptr        A(Volume Table)\n         L     R0,VolTbl_Hdr_Vols_Proc-VolTbl_Hdr(R15) Get current\n         LR    R1,R0                    Save it\n         A     R1,@H_Total_Vols_Proc    Bump it\n         CS    R0,R1,VolTbl_Hdr_Vols_Proc-VolTbl_Hdr(R15) Update it\n         JNZ   H00560                   Collision, try again\n\n*---------------------------------------------------------------------*\n*     If this completes the table, fill in the totals, if required    *\n*---------------------------------------------------------------------*\n         C     R1,VolTbl_Hdr_Vols_Total-VolTbl_Hdr(R15) All done?\n         JL    H00610                   No, skip\n         OI    @H_VolTbl_Complete,L'@H_VolTbl_Complete Yes, flag it\n\n         ICM   R9,B'1111',@H_Totals_Line_Ptr A(Totals line)\n         JZ    H00590                   None, all done\n\n         LD    R0,VolTbl_Ent_Total_VolSize Get Total bytes\n         LTDBR R0,R0                    Any?\n         JZ    H00570                   No, we're done with the totals\n\n         LD    R0,VolTbl_Ent_Total_FreeTracks Total free tracks\n         LA    R1,VolTbl_Ent_FreeTrk    Point to output field\n         LHI   R0,L'VolTbl_Ent_FreeTrk  Length of output field\n         BRAS  R14,H03000               Put in table\n\n         LD    R0,VolTbl_Ent_Total_FreeCyls Total Free Cyls\n         LA    R1,VolTbl_Ent_FreeCyl    Point to output field\n         LHI   R0,L'VolTbl_Ent_FreeCyl  Length of output field\n         BRAS  R14,H03000               Put in table\n\n         LD    R0,VolTbl_Ent_Total_FreeBytes Total Free Bytes\n         DDB   R0,VolTbl_Ent_Total_Volsize divided by total bytes\n         MDB   R0,=DBL8'1000'           Set up as a % (100.0)\n         LA    R1,VolTbl_Ent_FreePct    Point to output field\n         LHI   R0,L'VolTbl_Ent_FreePct  Length of output field\n         BRAS  R14,H03000               Put in table\n         DDB   R0,=DBL8'10'             back to xx.x\n         STD   R0,VolTbl_Ent_Total_FreePct Save it\n\n         LD    R0,VolTbl_Ent_Total_FreeBytes Total Free Bytes\n         LA    R1,VolTbl_Ent_FreeBytes  Point to output field\n         LHI   R0,L'VolTbl_Ent_FreeBytes Length of output field\n         BRAS  R14,H03000               Put in table\n\n         LD    R0,VolTbl_Ent_Total_Extents Total Extents\n         LA    R1,VolTbl_Ent_FreeExt    Point to output field\n         LHI   R0,L'VolTbl_Ent_FreeExt  Length of output field\n         BRAS  R14,H03000               Put in table\n\n         LD    R0,VolTbl_Ent_Largest_FreeCyls Largest Free Cyls\n         LA    R1,VolTbl_Ent_LargCyl    Point to output field\n         LHI   R0,L'VolTbl_Ent_LargCyl  Length of output field\n         BRAS  R14,H03000               Put in table\n\n         LD    R0,VolTbl_Ent_Largest_FreeTracks Largest Free Tracks\n         LA    R1,VolTbl_Ent_LargTrk    Point to output field\n         LHI   R0,L'VolTbl_Ent_LargTrk  Length of output field\n         BRAS  R14,H03000               Put in table\n\n         LD    R0,VolTbl_Ent_Total_VTOCTrk Total VTOC tracks\n         LA    R1,VolTbl_Ent_VTOCTrk    Point to output field\n         LHI   R0,L'VolTbl_Ent_VTOCTrk  Length of output field\n         BRAS  R14,H03000               Put in table\n\n         LD    R0,VolTbl_Ent_Total_FreeDSCBs Total Free DSCBs\n         LA    R1,VolTbl_Ent_FreeDSCB   Point to output field\n         LHI   R0,L'VolTbl_Ent_FreeDSCB Length of output field\n         BRAS  R14,H03000               Put in table\n\n         LD    R0,VolTbl_Ent_Total_FreeDSCBs Get Total Free DSCBs\n         DDB   R0,VolTbl_Ent_Total_DSCBs Get percent free\n         MDB   R0,=DBL8'1000'           * 100.0\n         LA    R1,VolTbl_Ent_VTOCFree   Point to output field\n         LHI   R0,L'VolTbl_Ent_VTOCFree Length of output field\n         BRAS  R14,H03000               Put in table\n         MDB   R0,=DBL8'10'             back to xx.x\n         STD   R0,VolTbl_Ent_Total_VTOCFree Save it\n\n         LD    R0,VolTbl_Ent_Total_VolSize Get Total Bytes\n         LA    R1,VolTbl_Ent_VolSize    Point to output field\n         LHI   R0,L'VolTbl_Ent_VolSize  Length of output field\n         BRAS  R14,H03000               Put in table\n\n         L     R0,VolTbl_Ent_Total_Vols_OK Number of volumes with data\n         CDFBR R2,R0                    Convert to floating point\n         LD    R0,VolTbl_Ent_Total_FragIndex Get Total Frag Index\n         DDBR  R0,R2                    Get avg frag index\n         LA    R1,VolTbl_Ent_Frag_Indx  Point to output field\n         LHI   R0,L'VolTbl_Ent_Frag_Indx Length of output field\n         BRAS  R14,H03000               Put in table\n\nH00570   DS    0H\n*---------------------------------------------------------------------*\n*     ... POST it as complete ...                                     *\n*---------------------------------------------------------------------*\n         L     R14,VolTbl_Ent_ECB       Current contents of our ECB\n         TM    VolTbl_Ent_ECB,X'80'     Anyone WAITing?\n         JO    H00580                   Yes, we need to POST\n         L     R15,=XL4'40000000'       No, POST code of 0\n         CS    R14,R15,VolTbl_Ent_ECB   Pseudo-POST it\n         JZ    H00590                   OK, skip the real POST\nH00580   DS    0H\n         POST  VolTbl_Ent_ECB,0         Flag as complete\n\nH00590   DS    0H\n*---------------------------------------------------------------------*\n*     ... if the SMS anomaly line has not been completed (because     *\n*    there was no SMS anomaly), flag it as complete now               *\n*---------------------------------------------------------------------*\n         ICM   R9,B'1111',@H_SMS_Anomaly_Ptr A(SMS Anomaly line)\n         JZ    H00610                   None, skip\n         TM    VolTbl_Ent_ECB,X'40'     Already POSTed?\n         JO    H00610                   Yes, skip\n         L     R14,VolTbl_Ent_ECB       Current contents of our ECB\n         TM    VolTbl_Ent_ECB,X'80'     Anyone WAITing?\n         JO    H00600                   Yes, we need to POST\n         L     R15,=XL4'40000000'       No, POST code of 0\n         CS    R14,R15,VolTbl_Ent_ECB   Pseudo-POST it\n         JZ    H00610                   OK, skip the real POST\nH00600   DS    0H\n         POST  VolTbl_Ent_ECB,0         Flag as complete\n\nH00610   DS    0H\n*---------------------------------------------------------------------*\n*     Fill in our Stats line, if present                              *\n*---------------------------------------------------------------------*\n         ICM   R9,B'1111',@H_Stats_Line_Ptr A(1st Stats Heading line)\n         JZ    H00730                   None, skip\n\n*---------------------------------------------------------------------*\n*     If the headings haven't yet been filled in (i.e., we are the    *\n*    first ones here), fill them in ...                               *\n*---------------------------------------------------------------------*\n         LA    R2,H_SubTask_Hdgs        A(Start of headings)\n         LA    R4,H_SubTask_Hdg_Lens    A(Lengths of heading lines)\n         LHI   R5,H_SubTask_Hdg_Count   Get nbr heading lines\nH00620   DS    0H\n         TM    VolTbl_Ent_Processed,L'VolTbl_Ent_Processed Done?\n         JNZ   H00650                   Yes, try next\n\n         L     R1,VolTbl_Ent_Processed  No, get the Flag byte\n         LA    R0,L'VolTbl_Ent_Processed Set up the\n         SLL   R0,24                     flag turned\n         OR    R0,R1                     on\n         CS    R1,R0,VolTbl_Ent_Processed and update it\n         JNE   H00650                   Somebody else here, skip it\n\n         LH    R3,0(0,R4)               Len of heading line\n         O     R3,=XL4'40000000'        Pad char of blank\n         LA    R0,VolTbl_Ent_Display    A(Target)\n         LHI   R1,L'VolTbl_Ent_Display  Length of target\n         MVCL  R0,R2                    Move heading\n         OI    VolTbl_Ent_Stats_Done,l'VolTbl_Ent_Stats_Done Done\n\n         L     R0,VolTbl_Ent_ECB        Current contents of our ECB\n         TM    VolTbl_Ent_ECB,X'80'     Anyone WAITing?\n         JO    H00630                   Yes, we need to POST\n         L     R1,=XL4'40000000'        No, POST code of 0\n         CS    R0,R1,VolTbl_Ent_ECB     Pseudo-POST it\n         JZ    H00640                   OK, skip the real POST\nH00630   DS    0H\n         POST  VolTbl_Ent_ECB,0         POST line as complete\nH00640   DS    0H\n\nH00650   DS    0H\n         AHI   R9,VolTbl_Ent_Len        Bump entry pointer\n         AHI   R4,2                     Bump lengths pointer\n         BRCT  R5,H00620                and try again\n\n*---------------------------------------------------------------------*\n*     Headings all done, find an unused entry for our subtask stats   *\n*    At this point, R9 points to the line after the subtask hdgs.     *\n*---------------------------------------------------------------------*\n         L     R14,@H_VolTbl_Ptr        A(VolTbl)\n         AHI   R14,VolTbl_Ent-VolTbl_Hdr  A(1st entry)\n         LR    R15,R9                   A(Our entry\n         SR    R15,R14                  Offset of our line\n         LA    R14,0                    Clear R14\n         LHI   R0,VolTbl_Ent_Len        Length of 1 entry\n         DR    R14,R0                   Get our entry num\n         S     R15,=FL4'1'              Relative to 0\n         JM    H00730                   Negative, skip it\n         L     R10,@H_VolTbl_Ptr        A(VolTbl) again\n         L     R10,VolTbl_Hdr_Count-VolTbl_Hdr(0,R10) Nbr entries\n         SR    R10,R15                  Nbr entries remaining\n         JNP   H00730                   None, skip it\n         LR    R3,R10                   Init SubTask Nbr\nH00660   DS    0H\n         TM    VolTbl_Ent_Processed,L'VolTbl_Ent_Processed Done?\n         JNZ   H00670                   Yes, try next\n\n         L     R1,VolTbl_Ent_Processed  No, get the Flag byte\n         LA    R0,L'VolTbl_Ent_Processed Set up the\n         SLL   R0,24                     flag turned\n         OR    R0,R1                     on\n         CS    R1,R0,VolTbl_Ent_Processed and update it\n         JE    H00680                   OK, skip\nH00670   DS    0H\n         AHI   R9,VolTbl_Ent_Len        Bump entry pointer\n         BRCT  R10,H00660               and try again\n         J     H00730                   None, skip it\nH00680   DS    0H\n*---------------------------------------------------------------------*\n*     Output our subtask stats.  Note that if we did all the volumes, *\n*   we were BASR'd to, rather than ATTACHed. In this case, we do      *\n*   not put out the 1st and 3rd fields (SubTask Nbr and CPU Time).    *\n*---------------------------------------------------------------------*\n         L     R14,=AL4(H_SubTask_Line) A(Stats line skeleton)\n         LHI   R15,H_SubTask_Line_Len   Len of skeleton\n         O     R15,=XL4'40000000'       Pad char of blank\n         LA    R0,VolTbl_Ent_Display    A(Target)\n         LA    R1,VolTbl_Ent_Display_Len Length of target\n         MVCL  R0,R14                   Move skeleton\n\n         L     R15,@H_Total_Vols_Proc   Total volumes\n         CVD   R15,@H_DBLWD             Pack it\n         ED    VolTbl_Ent_Display+H_SubTask_Line_TotVol-H_SubTask_Line(+\n               L'H_SubTask_Line_TotVol),@H_DBLWD+5\n\n         L     R0,@H_Total_Vols_Proc    Number of volumes we did\n         L     R15,@H_VolTbl_Ptr        A(Volume Table)\n         C     R0,VolTbl_Hdr_Vols_Total-VolTbl_Hdr(R15) All us?\n         JL    H00690                   No, others here too\n         MVC   VolTbl_Ent_Display+H_SubTask_Line_Nbr+1-H_SubTask_Line(L+\n               'H_SubTask_Line_Nbr-1),VolTbl_Ent_Display+H_SubTask_Line+\n               _Nbr-H_SubTask_Line      Clear ED mask\n         MVC   VolTbl_Ent_Display+H_SubTask_Line_Nbr+L'H_SubTask_Line_N+\n               br-3-H_SubTask_Line(3),=C'N/A'\n         MVC   VolTbl_Ent_Display+H_SubTask_Line_CPU+1-H_SubTask_Line(L+\n               'H_SubTask_Line_CPU-1),VolTbl_Ent_Display+H_SubTask_Line+\n               _CPU-H_SubTask_Line      Clear ED mask\n         MVC   VolTbl_Ent_Display+H_SubTask_Line_CPU+L'H_SubTask_Line_C+\n               PU-3-H_SubTask_Line(3),=C'N/A'\n         J     H00700                   and skip\n\nH00690   DS    0H\n         SR    R3,R10                   SubTask nbr\n         AHI   R3,1                     Relative to 1\n         CVD   R3,@H_DBLWD              Pack it\n         ED    VolTbl_Ent_Display+H_SubTask_Line_Nbr-H_SubTask_Line(L'H+\n               _SubTask_Line_Nbr),@H_DBLWD+6\n\n         TIMEUSED STORADR=@H_DBLWD,     Get CPU time used              +\n               LINKAGE=SYSTEM,           as recommended by IBM         +\n               CPU=MIC                   get it in microseconds\n         LM    R14,R15,@H_DBLWD         Get microseconds\n         D     R14,=FL4'1000'           Convert to milliseconds\n         CVD   R15,@H_DBLWD             Pack it\n         ED    VolTbl_Ent_Display+H_SubTask_Line_CPU-H_SubTask_Line(L'H+\n               _SubTask_Line_CPU),@H_DBLWD+5\n\nH00700   DS    0H\n         L     R15,@H_Total_Vols_OK     Volumes where LSPACE worked\n         CVD   R15,@H_DBLWD             Pack it\n         ED    VolTbl_Ent_Display+H_SubTask_Line_Vol_OK-H_SubTask_Line(+\n               L'H_SubTask_Line_Vol_OK),@H_DBLWD+5\n\n         LM    R14,R15,@H_Total_LSPACE_Wait_OK Good LSPACE time (usec)\n         D     R14,=FL4'1000'           Convert to milliseconds\n         CVD   R15,@H_DBLWD             Pack it\n         ED    VolTbl_Ent_Display+H_SubTask_Line_Wait_OK-H_SubTask_Line+\n               (L'H_SubTask_Line_Wait_OK),@H_DBLWD+5\n\n         L     R15,@H_Total_Vols_Proc   Total volumes\n         S     R15,@H_Total_Vols_OK      minus ones where LSPACE OK\n         CVD   R15,@H_DBLWD             Pack it\n         ED    VolTbl_Ent_Display+H_SubTask_Line_Vol_Bad-H_SubTask_Line+\n               (L'H_SubTask_Line_Vol_Bad),@H_DBLWD+5\n\n         LM    R14,R15,@H_Total_LSPACE_Wait_Bad Fail LSPACE time (usec)\n         D     R14,=FL4'1000'           Convert to milliseconds\n         CVD   R15,@H_DBLWD             Pack it\n         ED    VolTbl_Ent_Display+H_SubTask_Line_Wait_Bad-H_SubTask_Lin+\n               e(L'H_SubTask_Line_Wait_Bad),@H_DBLWD+5\n\n\n         OI    VolTbl_Ent_Stats_Done,L'VolTbl_Ent_Stats_Done Done\n\n         L     R0,VolTbl_Ent_ECB        Current contents of our ECB\n         TM    VolTbl_Ent_ECB,X'80'     Anyone WAITing?\n         JO    H00710                   Yes, we need to POST\n         L     R1,=XL4'40000000'        No, POST code of 0\n         CS    R0,R1,VolTbl_Ent_ECB     Pseudo-POST it\n         JZ    H00720                   OK, skip the real POST\nH00710   DS    0H\n         POST  VolTbl_Ent_ECB,0         POST line as complete\nH00720   DS    0H\n\n\nH00730   DS    0H\n*---------------------------------------------------------------------*\n*     If we are the last ones here (i.e., we finished VolTbl),        *\n*    flag the table as complete                                       *\n*---------------------------------------------------------------------*\n         TM    @H_VolTbl_Complete,L'@H_VolTbl_Complete All done?\n         JNO   H00750                   No, skip\n\n         L     R10,@H_VolTbl_Ptr        A(VolTbl)\n         L     R14,VolTbl_Hdr_ECB-VolTbl_Hdr(R10) Contents of our ECB\n         TM    VolTbl_Hdr_ECB-VolTbl_Hdr(R10),X'80' Anyone WAITing?\n         JO    H00740                   Yes, we need to POST\n         L     R15,=XL4'40000000'       No, POST code of 0\n         CS    R14,R15,VolTbl_Hdr_ECB-VolTbl_Hdr(R10) Pseudo-POST it\n         JZ    H00750                   OK, skip the real POST\nH00740   DS    0H\n         POST  VolTbl_Hdr_ECB-VolTbl_Hdr(R10),0 Flag as complete\nH00750   DS    0H\n\n         J     H90010                   All done, exit\n\n\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n\nH03000   DS    0H\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*   Format and scale a long binary FP number                          *\n*                                                                     *\n*   On Entry, FP0     = Long FP value                                 *\n*             GPR 0   = Length of Target Field                        *\n*             GPR 1   = A(Target field)                               *\n*                                                                     *\n*   On Exit,  N/A                                                     *\n*                                                                     *\n*   Notes: This routine should only be used for output fields with    *\n*          lengths if 4, 5, or 6.                                     *\n*          Output fields of length = 4 are assumed to be percents.    *\n*          Values destined for output fields with lengths of 5 or 6   *\n*          will be scaled, if necessary. All scaled values will have  *\n*          a single decimal point.                                    *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         STM   R14,R12,12(R13)          Save callers registers\n         LDR   R6,R0                    Save FP R0\n\n         LA    R15,0                    Clear scale indicator\n         CHI   R0,5                     Check output length\n         JL    H03040                   a %, skip scaling\n         JH    H03010                   6-char field, skip\n         LD    R2,=DBL8'10000'          Max value + 1\n         J     H03020\nH03010   DS    0H\n         LD    R2,=DBL8'100000'         Max value + 1\nH03020   DS    0H\n         CDBR  R0,R2                    Do we have to scale?\n         JNH   H03040                   No, skip\n         LTR   R15,R15                  Have we scaled already?\n         JNZ   H03030                   Yes, skip\n         DDB   R2,=DBL8'100'            No, max val +1\nH03030   DS    0H\n         DDB   R0,=DBL8'1000'           Divide by 1000\n         AHI   R15,1                    Bump scaling factor\n         J     H03020                   and check again\n\nH03040   DS    0H\n         LTR   R15,R15                  Did we have to scale it?\n         JZ    H03050                   No, skip\n         MVC   @H_MaskArea,=X'40202021204B2040' Yes, move mask\n         LA    R15,H_Scale-1(R15)       Get scaling factor\n         MVC   @H_Scale,0(R15)          Save it\n         MDB   R0,=DBL8'10'             Add a decimal point\n         J     H03070                   and skip\nH03050   DS    0H\n         CHI   R0,5                     Is this a percent?\n         JNL   H03060                   No, skip\n         MVC   @H_MaskArea,=X'4040202021204B20' Yes, move mask\n         CDB   R0,=DBL8'999.4'          Will we round up to 100%?\n         JNH   H03070                   No, OK\n         LD    R0,=DBL8'999.4'          Yes, set to 99.9%\n         J     H03070                   and skip\nH03060   DS    0H\n         MVC   @H_MaskArea,=X'404020206B202120' Move mask\nH03070   DS    0H\n         CFDBR R15,B'0100',R0           Convert and round\n         CVD   R15,@H_DBLWD             Pack it\n         ED    @H_MaskArea,@H_DBLWD+5   Edit in the number\n         CLI   @H_MaskArea+L'@H_MaskArea-1,C' ' Did we scale?\n         JNE   H03080                   No, skip\n         MVC   @H_MaskArea+L'@H_MaskArea-1(1),@H_Scale Yes, move factor\nH03080   DS    0H\n         LA    R15,@H_MaskArea+L'@H_MaskArea Point to\n         SR    R15,R0                     start of our data\n         MVC   @H_MaskArea,0(R15)       Left align in mask area\n         LR    R15,R0                   Get length again\n         AHI   R15,-1                   EX length\n         L     R1,24(0,R13)             A(Target field)\n         EX    R15,H_MVC1               Move to output field\nH03090   DS    0H\n\n         LM    R14,R12,12(R13)          Restore registers\n         LDR   R0,R6                    Restore FP R0\n\n         BR    R14                      and exit\n\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n\n\n\nH06000   DS    0H\n\n*---------------------------------------------------------------------*\n*     Our timer has expired - verify that we are in the middle of     *\n*    LSPACE by checking that the PRB at the end of the RB chain has   *\n*    issued an SVC 78 (LSPACE).                                       *\n*     If SVC78 is active, or has not yet been issued,                 *\n*        Establish an ESTAE with PURGE=HALT                           *\n*        ABEND X'0522'                                                *\n*     Else                                                            *\n*        disappear quietly (we have popped after LSPACE completed, but*\n*                           before the STIMERM was cancelled)         *\n*---------------------------------------------------------------------*\n         PUSH  USING                    Save our USING environment\n         DROP  ,\n\n         USING *,R15                    Assign temp base\n         STM   14,12,12(13)             Save callers registers\n         LR    R11,R15                  Load permanent base reg\n         DROP  R15                      Free up temp base\n         USING H06000,R11               Assign permanent base\n         L     R1,4(0,R1)               Get A(Parms passed)\n         L     R10,0(0,R1)              Get A(Dynamic storage)\n         USING @H_Dynam,R10             Assign a base\n\n*        STM   R14,R1,@H6_Debug_Save    Save our registers\n*        WTO   '&PGMNAME - STIMERM Exit popping'\n*        LM    R14,R1,@H6_Debug_Save    Restore our registers\n\n*---------------------------------------------------------------------*\n*   We will be checking the RB chain, to verify that we are, indeed,  *\n*  in LSPACE. If the ground should shift under us while we are doing  *\n*  this, we may get an S0C4, or some such, and the CVAF ESTAE (with   *\n*  PURGE=NONE) will be scheduled, and we will hang. We therefore      *\n*  establish our PURGE=HALT ESTAE here.                               *\n*---------------------------------------------------------------------*\n*        STM   R14,R1,@H6_Debug_Save    Save our registers\n*        WTO   '&PGMNAME - STIMERM Exit - establishing ESTAE'\n*        LM    R14,R1,@H6_Debug_Save    Restore our registers\n\n         MVC   @H6_ESTAE,H6_ESTAE       Move L-Form\n         ESTAEX H06800,                 Establish ESTAE Exit           +\n               CT,                       create it                     +\n               PURGE=HALT,               terminating IO                +\n               MF=(E,@H6_ESTAE)          keeping ourselves reentrant\n\n*---------------------------------------------------------------------*\n*   Chase down the RB chain for the last RB ...                       *\n*---------------------------------------------------------------------*\n         L     R14,PSATNEW-PSA(0)       Get A(our TCB)\n         SLL   R14,8                    Clean\n         SRL   R14,8                      it\n         L     R15,TCBRBP-TCB(R14)      A(RB)\nH06010   DS    0H\n         L     R0,RBLINK-RBBASIC(R15)   A(Previous RB)\n         SLL   R0,8                     Clean\n         SRL   R0,8                       it\n         CR    R0,R14                   Last RB (RBLINK = A(TCB))?\n         JE    H06020                   Yes, skip\n         LR    R15,R0                   No, point to previous RB\n         J     H06010                   and keep trying\nH06020   DS    0H\n\n*---------------------------------------------------------------------*\n*   ... and see if it is running SVC 78 (LSPACE)                      *\n*---------------------------------------------------------------------*\n         AHI   R15,-(RBPRFXND-RBPREFIX)   Back up to RB prefix\n         CLC   =X'004E',RBINTCOD-RBPREFIX(R15) SVC 78?\n         JE    H06030                   Yes, try to terminate\n\n*        STM   R14,R1,@H6_Debug_Save    Save our registers\n*        WTO   '&PGMNAME - STIMERM Exit - not in LSPACE'\n*        LM    R14,R1,@H6_Debug_Save    Restore our registers\n\n         ESTAEX 0                       No, delete our ESTAE\n\n         RETURN (14,12),,RC=0           and return\n\nH06030   DS    0H\n\n*---------------------------------------------------------------------*\n*   LSPACE is active, and, we assume, hung up. We have already set    *\n*  up our ESTAE with PURGE=HALT, which, on an ABEND, will get control *\n*  first, after the I/O is HALTed. This ESTAE merely percolates, so   *\n*  that the CVAF and LSPACE ESTAEs can do their tricks, and we will   *\n*  eventually end up in our ESTAE, which continues processing as if   *\n*  LSPACE had failed.                                                 *\n*---------------------------------------------------------------------*\n*        STM   R14,R1,@H6_Debug_Save    Save our registers\n*        WTO   '&PGMNAME - STIMERM Exit - ABENDing U0522'\n*        LM    R14,R1,@H6_Debug_Save    Restore our registers\n\n         ICM   R9,B'1111',@H_Current_VolTbl_Ent A(VolTbl Entry)\n         JZ    H06040                   None, skup\n         OI    VolTbl_Ent_U522-VolTbl_Ent(R9),L'VolTbl_Ent_U522\nH06040   DS    0H\n         ABEND X'0522'                  and abend with U522 (get it?)\n\nH06800   DS    0H\n\n*---------------------------------------------------------------------*\n*   This is the Exit for the ESTAE established in the STIMERM exit.   *\n*  This exit does nothing, merely returning to RTM with percolate.    *\n*  It is only here because we need the first ESTAE on the queue to    *\n*  have PURGE=HALT, so the I/O to the RESERVEd volume can be          *\n*  terminated.                                                        *\n*---------------------------------------------------------------------*\n         LA    R15,0                    Percolate\n         BSM   0,R14                     on return\n\nH6_ESTAE ESTAEX 1,                      Establish ESTAE Exit           +\n               CT,                       create it                     +\n               PURGE=HALT,               PURGEing I/O                  +\n               MF=L                      keeping ourselves reentrant\nH6_ESTAE_Length EQU *-H6_ESTAE\n\n         DROP  R11,R10                  Free up temp bases\n\n         POP   USING                    Restore USING environment\n\n*********************   Start of the ESTAE   **************************\n*                                                                     *\n*                                                                     *\n         SPACE ,\nH07000   DS    0H\n         PUSH  USING                    Save the USING environment\n         DROP  ,                        Drop all current USINGs\n         SPACE ,\n*---------------------------------------------------------------------*\n*   This is the ESTAE routine. All this does is:                      *\n*    Format an abend message                                          *\n*    Invoke the retry routine                                         *\n*                                                                     *\n*   Note that we run with our own set of USINGs here.                 *\n*---------------------------------------------------------------------*\n         USING *,R15                    Assign temporary base\n         CHI   R0,12                    Is there an SDWA?\n         JE    H07010                   No, skip\n\n*---------------------------------------------------------------------*\n*   We have an SDWA, so load the appropriate registers:               *\n*      R11 --> SDWA                                                   *\n*      R1  =   Abend Code                                             *\n*      R3  --> Parmarea                                               *\n*---------------------------------------------------------------------*\n         STM   R14,R11,12(R13)          Yes, save our registers\n         LR    R11,R1                   Point to the SDWA\n         L     R1,SDWAABCC-SDWA(R11)    Get the Abend code\n         L     R3,SDWAPARM-SDWA(R11)    Point to our parm address\n         L     R3,0(0,R3)               Point to our parms\n         J     H07020                   and skip\nH07010   DS    0H\n\n*---------------------------------------------------------------------*\n*   We don't have an SDWA, so clear R11 (the SDWA address)            *\n*---------------------------------------------------------------------*\n         LA    R11,0                    Clear A(SDWA)\n\nH07020   DS    0H\n*---------------------------------------------------------------------*\n*   Load up the base for our storage, and tell the assembler.         *\n*   At this point,                                                    *\n*    R1  contains the ABEND code                                      *\n*    R3  contains the address of @H_Dynam                             *\n*    R11 contains the address of the SDWA, or 0                       *\n*---------------------------------------------------------------------*\n         LR    R12,R15                  Load a base register\n         DROP  R15                      Free up temp base\n         USING H07000,R12               Tell the assembler about R11\n         USING @H_Dynam,R3              Assign a base for our parms\n\n*---------------------------------------------------------------------*\n*   Format our ABEND message                                          *\n*---------------------------------------------------------------------*\n         ST    R1,@H_DBLWD              Save completion code\n         ICM   R9,B'1111',@H_Current_VolTbl_Ent A(VolTbl_Ent)\n         JZ    H07050                   None, skip\n         USING VolTbl_Ent,R9            Assign a base\n         OI    VolTbl_Ent_LSPACE_Fail,L'VolTbl_Ent_LSPACE_Fail No data\n         CLC   =X'0522',@H_DBLWD+2      Is this U522 (STIMER pop)?\n         J     H07050                   Yes, exit\n\n         MVC   VolTbl_Ent_ErrMsg,=CL(L'VolTbl_Ent_ErrMsg)'**SubTask ABE+\n               ND xxxx'\n         MVI   VolTbl_Ent_ErrMsg+16,C'S' Assume system abend\n         L     R15,@H_DBLWD             Get ABEND code\n         SLL   R15,8                    Clear high-order byte and\n         SRL   R15,20                    User Abend code\n         LTR   R15,R15                  Is it a system Abend?\n         JNZ   H07040                   Yes, skip\n         MVI   VolTbl_Ent_ErrMsg+16,C'U' No, User abend\n         L     R15,@H_DBLWD             Get Abend code\n         SLL   R15,20                   Clear System\n         SRL   R15,20                     Abend code\nH07040   DS    0H\n         SLL   R15,4                    Make room for 'sign'\n         STH   R15,@H_DBLWD+6           Save it\n         OI    @H_DBLWD+7,X'0F'         Make it packed\n         UNPK  VolTbl_Ent_ErrMsg+17(3),@H_DBLWD+6(2) Unpack abend code\n         LA    R15,H_TrTbl              Point to translate table\n         S     R15,=FL4'240'            Adjust pointer\n         TR    VolTbl_Ent_ErrMsg+17(3),0(R15) Make it readable\n         DROP  R9                       Free up base\n\nH07050   DS    0H\n*---------------------------------------------------------------------*\n*   We will be retrying, so we will no longer have an ESTAE. Turn off *\n*  our flag, so that the retry routine will re-establish it ...       *\n*---------------------------------------------------------------------*\n         NI    @H_ESTAE_Issued,X'FF'-L'@H_ESTAE_Issued No ESTAE now\n\n*---------------------------------------------------------------------*\n*   ... and retry, either with an SDWA ...                            *\n*---------------------------------------------------------------------*\n         LTR   R11,R11                  Is there an SDWA?\n         JZ    H07060                   No, skip SDWA retry\n         SPACE ,\n         L     R4,@H_ESTAE_Retry        Yes, A(Retry routine)\n         LA    R5,@H_ESTAE_RMask        A(Register mask)\n         SETRP WKAREA=(11),             Set retry parms using this SDWA+\n               RC=4,                     Retry                         +\n               RETADDR=(4),              using this retry routine      +\n               RETREGS=YES,              and our registers             +\n               RUB=(5),                  which live here               +\n               FRESDWA=YES,              and get rid of the SDWA       +\n               REGS=(14,12)              Return to RTM\n\nH07060   DS    0H\n*---------------------------------------------------------------------*\n*   ... or without                                                    *\n*---------------------------------------------------------------------*\n         L     R0,@H_ESTAE_Retry         A(Retry routine)\n         LM    R1,R13,@H_ESTAE_Regs+4    Restore regs\n         LA    R15,4                     Retry\n         BR    R14                       go do it\n\n\n         DROP  ,                        Drop everything\n         POP   USING                    Restore USING environment\n\n*                                                                     *\n*                                                                     *\n**********************   End of the ESTAE   ***************************\n\n\nH90010   DS    0H\n*---------------------------------------------------------------------*\n*     We have finished doing our work                                 *\n*     First, delete our ESTAE if required ...                         *\n*---------------------------------------------------------------------*\n         TM    @H_ESTAE_Issued,L'@H_ESTAE_Issued ESTAE?\n         JZ    H90020                   No, skip\n         ESTAEX 0                       Yes, delete it\n         NI    @H_ESTAE_Issued,X'FF'-L'@H_ESTAE_Issued No ESTAE now\n\nH90020   DS    0H\n*---------------------------------------------------------------------*\n*    ... free up the 24-bit stack, if appropriate ...                 *\n*---------------------------------------------------------------------*\n         ICM   R1,B'1111',@H_24Bit_Stack_Ptr A(24-bit storage)\n         JZ    H90030                   None, skip\n         SSCSTACK TERM,                 Get rid of the stack           +\n               STACK=(1)                 starting here\n\nH90030   DS    0H\n*---------------------------------------------------------------------*\n*    ... then our locat 31-bit storage                                *\n*---------------------------------------------------------------------*\n         LA    R1,@H_Dynam              A(Local storage)\n         L     R3,@H_31Bit_Stack_Ptr    A(31-bit Stack)\n\n         SSCSTACK POP,                  Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=(R3)                on this stack\n\n*-------------------------------------------------------------------*\n*    ... and the stack itself ...                                   *\n*-------------------------------------------------------------------*\n         SSCSTACK TERM,                 Free the stack                 +\n               STACK=(R3)                starting here\n\n*---------------------------------------------------------------------*\n*    ... and exit.                                                    *\n*---------------------------------------------------------------------*\n         LA    R15,0                    Clear return code\n         PR    ,                        and return to caller\n\n\nH_Literals  DS  0H\n\nH_MVC    MVC   0(0,R1),3(R15) Move LSPACE error msg\n\n         PUSH  PRINT\n         PRINT NOGEN\n\nH_LSPACE LSPACE MF=L\nH_LSPACE_Length EQU *-H_LSPACE\n\nH_ESTAE  ESTAEX 1,                      Establish ESTAE Exit           +\n               CT,                       create it                     +\n               PARAM=0,                  passing this parm             +\n               MF=L                      keeping ourselves reentrant\nH_ESTAE_Length EQU *-H_ESTAE\n\nH_STIMERM_Set STIMERM SET,              Set a timer                    +\n               MF=L                      keep ourselves reentrant\nH_STIMERM_Set_Length EQU   *-H_STIMERM_Set\n\nH_STIMERM_Cancel STIMERM CANCEL,        Cancel our timer               +\n               MF=L                      keep ourselves reentrant\nH_STIMERM_Cancel_Length EQU   *-H_STIMERM_Cancel\n\nH_TIME   TIME  LINKAGE=SYSTEM,          Get the time                   +\n               MF=L                      keep ourselves reentrant\nH_TIME_Length  EQU *-H_TIME\n\nH_SMS_Anomaly_Msg     DC C'* indicates SMS status in UCB and VTOC are i+\n               nconsistent'\n         POP   PRINT\n\nH_TrTbl DC          C'0123456789ABCDEF'\n\nH_MVC1   MVC   0(0,R1),@H_MaskArea      Move readable results\n\nH_Scale  EQU   *\n         DC    C'K'             Kilo (/10**3)\n         DC    C'M'             Mega (/10**6)\n         DC    C'G'             Giga (/10**9)\n         DC    C'T'             Tera (/10**12)\n         DC    C'P'             Peta (/10**15)\n         DC    C'E'             Eta  (/10**18)\n         DC    C'Z'             Zetta (/10**21)\n         DC    C'Y'             Yotta (/10**24)\n         DC    C'?'             Hope we never get here\n\n         LTORG\n\nH_SubTask_Hdgs        EQU   *\nH_SubTask_Hdg1        DC    C' Subtask Statistics:'\nH_SubTask_Hdg2        DC    C'  SubTask    Volume         CPU       --L+\n               SPACE OK--       -LSPACE Bad--'\nH_SubTask_Hdg3        DC    C'   Number     Count        Time        Co+\n               unt   Wait        Count   Wait'\n\nH_SubTask_Hdg_Lens    DC    AL2(L'H_SubTask_Hdg1)\n                      DC    AL2(L'H_SubTask_Hdg2)\n                      DC    AL2(L'H_SubTask_Hdg3)\nH_SubTask_Hdg_Count   EQU   (*-H_SubTask_Hdg_Lens)/2\n\n\nH_SubTask_Line        EQU   *\n                      DC    C'     '\nH_SubTask_Line_Nbr    DC    X'40202120'\n                      DC    C'   '\nH_SubTask_Line_TotVol DC    X'4020206B202120'\n                      DC    C'     '\nH_SubTask_Line_CPU    DC    X'4021204B202020'\n                      DC    C'      '\nH_SubTask_Line_Vol_OK DC    X'4020206B202120'\nH_SubTask_Line_Wait_OK DC   X'4021204B202020'\n                      DC    C'      '\nH_SubTask_Line_Vol_Bad DC   X'4020206B202120'\nH_SubTask_Line_Wait_Bad DC  X'4021204B202020'\nH_SubTask_Line_Len    EQU   *-H_SubTask_Line\n\nH_LSPACE_Msgs EQU *\n           DC    XL2'0407'\n           DC    AL1(L'H_Msg0407)\nH_Msg0407  DC    C'LSPACE-I/O TIMEOUT ERROR'\n           DC    XL2'0400'\n           DC    AL1(L'H_Msg0400)\nH_Msg0400  DC    C'LSPACE-PERMANENT I/O ERROR'\n           DC    XL2'0800'\n           DC    AL1(L'H_Msg0800)\nH_Msg0800  DC    C'LSPACE-NON_STANDARD OS VOLUME'\n           DC    XL2'0C01'\n           DC    AL1(L'H_Msg0C01)\nH_Msg0C01  DC    C'LSPACE-UCBVTOC IS ZERO'\n           DC    XL2'0C02'\n           DC    AL1(L'H_Msg0C02)\nH_Msg0C02  DC    C'LSPACE-UCB NOT READY'\n           DC    XL2'1485'\n           DC    AL1(L'H_Msg1485)\nH_Msg1485  DC    C'&PGMNAME - LSPACE ESTAE invoked'\n           DC    XL2'0000'\n           DC    AL1(L'H_Msg0000)\nH_Msg0000  DC    C'&PGMNAME - Unknown LSPACE error'\n\nH_MsgU522A DC    C'&PGMNAME - MaxLWait ('\nH_MsgU522B DC    C' secs) exceeded.'\n\nH_Literals_End  DS  0H\n\n@H_Dynam                  DSECT Dynamic storage for H00010\n                          DS    18F     O/S Save area\n@H_31Bit_Stack_Ptr        DS    AL4     A(Local 31-bit Stack)\n@H_24Bit_Stack_Ptr        DS    AL4     A(Local 24-bit Stack)\n@H_VolTbl_Ptr             DS    AL4     A(VolTbl)\n@H_LSPACE_Avg_Ptr         DS    AL4     A(Avg LSPACE Wait microsecs)\n@H_STIMERM_Adj_Ptr        DS    AL4     A(STIMERM Adjustment Factor)\n@H_Totals_Line_Ptr        DS    AL4     A(Totals Line)\n@H_Stats_Line_Ptr         DS    AL4     A(1st SubTask Title line)\n@H_SMS_Anomaly_Ptr        DS    AL4     A(SMS Anomaly Line)\n@H_MaxLWait               DS    HL2     Max LSPACE Wait time\n\n@H_Current_VolTbl_Ent     DS    AL4     A(Current VolTbl_Ent)\n\n@H_UCBTBYT4               DS    XL(L'UCBTBYT4)  UCB Type for TRKCALC\n@H_BytesPerTrack          DS    FL4     Bytes/trk, from TRKCALC\n\n@H_STIMERM_ID             DS    AL4     STIMERM Id\n@H_STIMERM_Exit_Parms_Ptr DS    AL4     A(Parms for STIMERM Exit)\n@H_STIMERM_Exit_Parms     DS    2AL4    Parms for STIMERM Exit\n                          DS    0D      Alignment\n@H_LSPACE_Wait_Max        DS    FL4     Max LSPACE Wait Time (sec)\n@H_LSPACE_Start           DS    DL8     TOD of LSPACE start\n                          ORG   @H_LSPACE_Start\n@H_LSPACE_Wait            DS    DL8     Actual LSPACE Wait time (usec)\n                          ORG   ,\n\n@H_DBLWD                  DS    D          Doubleword work area\n@H_Total_VTOCTrk          DS    DBL8\n@H_Total_DSCBs            DS    DBL8\n@H_Total_FreeDSCBs        DS    DBL8\n@H_Total_VolSize          DS    DBL8\n@H_Total_Extents          DS    DBL8\n@H_Total_FreeTracks       DS    DBL8\n@H_Total_FreeBytes        DS    DBL8\n@H_Total_FreeCyls         DS    DBL8\n@H_Total_FragIndex        DS    DBL8\n@H_Largest_FreeTracks     DS    DBL8\n@H_Largest_FreeCyls       DS    DBL8\n@H_WaitTime_Total         DS    D       Total Wait Time (in usec)\n@H_Total_Vols_Proc        DS    FL4     Nbr volumes processed\n@H_Total_Vols_OK          DS    FL4     Nbr volumes processed OK\n@H_Total_LSPACE_Wait_OK   DS    DL8     Total good LSPACE Wait (usec)\n@H_Total_LSPACE_Wait_Bad  DS    DL8     Total bad LSPACE Wait (usec)\n                          DS    0F      Alignment\n@H_ESTAE_RMask            DS    HL2     ESTAE Register Mask\n@H_ESTAE_Regs             DS    16FL4   Registers for ESTAE Retry\n@H_ESTAE_Retry            DS    AL4     A(ESTAE Retry routine)\n                          DS    X       Flag Byte\n@H_ESTAE_Issued           EQU   *-1,X'80' 1... .... ESTAE established\n@H_VolTbl_Complete        EQU   *-1,X'40' .1.. .... All VolTbl_Ents OK\n@H_OW48527                EQU   *-1,X'20' ..1. .... APAR OW48527 on\n                          ORG   ,\n\n                          DS    0F      Alignment\n@H_LSPACE                 DS    CL(H_LSPACE_Length) LSPACE Macro\n\n@H_VolSize                DS    DBL8    Volume Bytes (Used in %Free)\n@H_TotDSCB                DS    DBL8    Volume Total DSCBs\n@H_MaskArea               DS    CL8     ED Mask area\n@H_Scale                  DS    C       Scaling factor\n\n@H_Macro                  DS    0F      Alignment\n@H_ESTAE                  DS    CL(H_ESTAE_Length)  ESTAE Macro area\n                          ORG   @H_Macro\n@H6_ESTAE                 DS    CL(H6_ESTAE_Length) STIMERM Exit ESTAE\n@H6_Debug_Save            DS    4FL4    Save registers around WTOs\n                          ORG   @H_Macro\n@H_STIMERM_Set            DS    CL(H_STIMERM_Set_Length)  STIMERM\n                          ORG   @H_Macro\n@H_STIMERM_Can            DS    CL(H_STIMERM_Cancel_Length)  STIMERM\n                          ORG   @H_Macro\n@H_TIME                   DS    CL(H_TIME_Length) TIME Macro area\n                          DS    0D\n@H_TIME_Area              DS    XL16    Data returned by TIME\n                          ORG   @H_Macro\n@H_TRKCALC                TRKCALC MF=L  Track balance calcs\n                          ORG   ,\n\n@H_Parms                  DS    0F      Parms for called rtns\n@H_Parms_Std              DS    3AL4     Standard 3 parms\n@H_Parms_Extra            EQU   *        Extra parms\n                          ORG   ,\n\n                          DS    0D      Alignment\n@H_Dynam_Length           EQU   *-@H_Dynam Length of Sub-Task Dynamic\n\n&PGMNAME CSECT\n\n         DROP  ,\n\n         POP   USING                    Restore USING environment\n         TITLE 'I00010: Sort Table'\n\n         PUSH  USING\n\nI00010   DS    0H\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Subroutine: I00010                                                 *\n*                                                                     *\n*  Abstract  : Sort data in VolTbl depending on the parameters        *\n*              passed.                                                *\n*                                                                     *\n*  Inputs    : R1 : ---> A(@_Dynam)                                   *\n*                        A(31-bit Stack Pointer)                      *\n*                        A(24-bit Stack Pointer)                      *\n*                        A(8-byte name of sort field)                 *\n*                        A(1-byte containing sort direction (A/D))    *\n*  Outputs   : R15: 0                                                 *\n*                                                                     *\n*  Notes     : N/A                                                    *\n*                                                                     *\n*  History:    1990/06/11 SDDA030 - New                               *\n*              1998/09/22 SDDA030 - V2.1                              *\n*                                 - Excluded Stats lines from being   *\n*                                   sorted                            *\n*              1999/05/27 SDDA030 - V2.6                              *\n*                                 - Used LIFO Stack for our dynamic   *\n*                                   areas.                            *\n*              2000/01/19 SDDA030 - V2.11                             *\n*                                 - Received parms as pointers.       *\n*                                 - Able to sort Ascending or Descend-*\n*                                   ing.                              *\n*              2000/05/23 SDDA030 - V2.12                             *\n*                                 - Moved table of offsets from F00010*\n*                                   to here.                          *\n*              2002/03/11 SDDA030 - V2.17                             *\n*                                 - Added FREEB to table of offsets.  *\n*                                 - Pointed numeric fields to the     *\n*                                   appropriate sort fields in VolTbl.*\n*                                 - Removed sort by column nbr.       *\n*              2003/10/07 SDDA030 - V2.21                             *\n*                                 - Added VOLSIZE to table of offsets.*\n*              2006/04/21 SDDA030 - V2.24                             *\n*                                 - Used standardised calling sequence*\n*                                 - Fixed bug causing unending WAIT   *\n*                                   when STATS and SORT specified     *\n*                                 - WAIT for all detail lines to be   *\n*                                   populated before sorting (doh!)   *\n*              ____/__/__ _______                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         STM   R14,R12,12(R13)          Save callers registers\n         LARL  R11,I_Literals           Point to our literals\n         USING (I_Literals,I_Literals_End),R11 Tell the assembler\n\n         L     R12,0(0,R1)              A(@_Dynam)\n         USING @_Dynam,R12              Tell the assembler\n\n*-------------------------------------------------------------------*\n*    Get an area on the stack for our local storage                 *\n*-------------------------------------------------------------------*\n         L     R2,4(0,R1)               A(31-bit stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         SSCSTACK PUSH,                 Get stack area                 +\n               LEN=@I_Dynam_Length,      this long                     +\n               STACK=(R2)                using this stack\n\n         LR    R3,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LHI   R1,@I_Dynam_Length        Its length\n         LA    R14,0                    Clear source address\n         LA    R15,0                     and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R3                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*-------------------------------------------------------------------*\n         ST    R13,4(0,R1)              Chain\n         ST    R1,8(0,R13)               saveareas\n         LR    R13,R1                   Load dynam base\n         USING @I_Dynam,R13             Assign a base\n         L     R15,@I_Dynam+4           Get A(HSA)\n         LM    R0,R3,20(R15)            Restore callers registers\n\n         L     R15,4(0,R1)              A(31-bit Stack Pointer)\n         ST    R15,@I_31Bit_Stack_Ptr_Ptr Save it\n         L     R15,8(0,R1)              A(24-bit Stack Pointer)\n         ST    R15,@I_24Bit_Stack_Ptr_Ptr Save it\n\n\n         ICM   R9,B'1111',@_VolTbl_Ptr  A(Volume table)\n         JZ    I00100                   None, don't sort it\n         L     R10,VolTbl_Hdr_Count-VolTbl_Hdr(R9) Get nbr entries\n         CHI   R10,1                    More than 1\n         JNH   I00100                   No, skip sort\n\n         L     R14,12(0,R1)             Get A(Name of sort field)\n         LA    R15,I_TBLOFF             and A(Table of offsets)\nI00020   DS    0H\n         CLI   0(R15),C' '              End of table?\n         JE    I80010                   Yes, error (sort fld not found)\n         CLC   0(8,R14),0(R15)          Name, is it ours?\n         JE    I00030                   Yes, skip\n\n         AHI   R15,12                   No, point to next entry\n         J     I00020                   and try again\nI00030   DS    0H\n         LH    R14,8(0,R15)             Offset of sort field\n         LH    R15,10(0,R15)            Length of sort field\n\n         L     R1,@I_Dynam+4            Get A(HSA)\n         L     R1,24(0,R1)              Get original R1\n         L     R1,16(0,R1)              A(Sort direction)\n         CLI   0(R1),C'D'               Descending sort?\n         JE    I00040                   Yes, skip\n         LHI   R3,13                    No, use BNH for ascending sort\n         J     I00050                   and skip\nI00040   DS    0H\n         LHI   R3,11                    Use BNL for descending sort\nI00050   DS    0H\n         SLL   R3,4                     Put mask in high nibble\n\n         TM    VolTbl_Hdr_ECB-VolTbl_Hdr(R9),X'40' All details done?\n         JO    I00050C                  Yes, skip\n         WAIT  ECB=VolTbl_Hdr_ECB-VolTbl_Hdr(R9) No, wait for it\nI00050C  DS    0H\n\n         AHI   R9,VolTbl_Ent-VolTbl     Point to first entry\n         AHI   R10,-1                   Adjust Loop count\nI00060   DS    0H\n         TM    VolTbl_Ent_Detail_Line-VolTbl_Ent(R9),L'VolTbl_Ent_Detai+\n               l_Line\n         JNO   I00060C                  No, skip it\n         TM    VolTbl_Ent_SMS_Line-VolTbl_Ent(R9),L'VolTbl_Ent_SMS_Line\n         JNO   I00070                   True Detail line, skip\nI00060C  DS    0H\n         AHI   R9,VolTbl_Ent_Len        No, A(Next entry)\n         BRCT  R10,I00060               and check again\n         J     I00100                   Nothing, skip sort\n\nI00070   DS    0H\n         LR    R4,R9                    Get A(entry)\n         LR    R5,R10                   Get inner loop count\n         LA    R6,VolTbl_Ent_Len(0,R4)  A(Next entry)\nI00080   DS    0H\n         TM    VolTbl_Ent_Detail_Line-VolTbl_Ent(R6),L'VolTbl_Ent_Detai+\n               l_Line\n         JNO   I00090                   Skip non-detail line\n         TM    VolTbl_Ent_SMS_Line-VolTbl_Ent(R6),L'VolTbl_Ent_SMS_Line\n         JO    I00090                   Skip SMS Anomaly msg\n\n         LA    R7,0(R4,R14)             Point to\n         LA    R8,0(R6,R14)              sort fields\n         EX    R15,I0EX1                Compare entries\n         EX    R3,I0EX2                 Branch if in sequence\n\n         STM   R14,R1,@I_TempSave       Save MVCL registers\n         LA    R0,@I_WK1                A(Temporary area)\n         LHI   R1,L'@I_WK1              Its length\n         LR    R14,R4                   A(Entry out of sequence)\n         LHI   R15,VolTbl_Ent_Len       Its length\n         MVCL  R0,R14                   Save entry\n         LR    R0,R4                    A(Entry to be switched)\n         LHI   R1,VolTbl_Ent_Len        Its length\n         LR    R14,R6                   A(Entry out of sequence)\n         LHI   R15,VolTbl_Ent_Len       Its length\n         MVCL  R0,R14                   Save entry\n         LR    R0,R6                    A(Entry to be switched)\n         LHI   R1,VolTbl_Ent_Len        Its length\n         LA    R14,@I_WK1               A(Temporary area)\n         LHI   R15,L'@I_WK1             Its length\n         MVCL  R0,R14                   Save entry\n         LM    R14,R1,@I_TempSave       Restore MVCL registers\n\nI00090   DS    0H\n         AHI   R6,VolTbl_Ent_Len        A(next entry)\n         BRCT  R5,I00080                Sort all entries\n         AHI   R9,VolTbl_Ent_Len        Reset start entry nbr\n         BRCT  R10,I00060                And do it all again\n\nI00100   DS    0H\n         LA    R15,0                    Clear return code\n         J     I90010                   and exit\n\nI80010   DS    0H\n*-------------------------------------------------------------------*\n*    Sort field not found                                           *\n*-------------------------------------------------------------------*\n         LA    R15,4                    Sort failed\n         J     I90010                   and exit\n\nI90010   DS    0H\n*-------------------------------------------------------------------*\n*    Free up our local storage ...                                  *\n*-------------------------------------------------------------------*\n         LR    R3,R15                   Save return code\n\n         LA    R1,@I_Dynam              A(Local storage)\n         L     R2,@I_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         L     R13,4(0,R13)             Rescue A(HSA)\n\n         SSCSTACK POP,                  Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=(R2)                on this stack\n\n         LR    R15,R3                   Restore return code\n\n*-------------------------------------------------------------------*\n*    ... and return to caller                                       *\n*-------------------------------------------------------------------*\n         L     R14,12(0,R13)            Restore return address\n         LM    R0,R12,20(R13)           Restore other registers\n         BSM   0,R14                    and return\n\nI_Literals  DS  0H\n\nI0EX1    CLC   0(0,R7),0(R8)            Compare entries\nI0EX2    JNOP  I00090                   Set to BNH/BNL for A/D sort\n\n\n         LTORG\n\nI_TBLOFF EQU   *\n         DC    CL8'VOL'\n         DC    AL2(VolTbl_Ent_Volser-VolTbl_Ent) Start of VOL\n         DC    AL2(L'VolTbl_Ent_Volser)         Len of VOL\n\n         DC    CL8'UCB'\n         DC    AL2(VolTbl_Ent_UCBCopy+UCBCHAN-UCBOB-VolTbl_Ent) UCB\n         DC    AL2(L'UCBCHAN)                   Length of UCB\n\n         DC    CL8'DEVT'\n         DC    AL2(VolTbl_Ent_DevType-VolTbl_Ent) Start of Device Type\n         DC    AL2(L'VolTbl_Ent_DevType)        Len of Device type\n\n         DC    CL8'ATTR'\n         DC    AL2(VolTbl_Ent_Attrib-VolTbl_Ent) Start of Mnt Attr\n         DC    AL2(L'VolTbl_Ent_Attrib)         Len of Mnt Attr\n\n         DC    CL8'FREET'\n         DC    AL2(VolTbl_Ent_Sort_FreeTrk-VolTbl_Ent) Free Trk\n         DC    AL2(L'VolTbl_Ent_Sort_FreeTrk)   Len of Free Trks\n\n         DC    CL8'FREEC'\n         DC    AL2(VolTbl_Ent_Sort_FreeCyl-VolTbl_Ent) Free Cyl\n         DC    AL2(L'VolTbl_Ent_Sort_FreeCyl)   Len of Free Cyl\n\n         DC    CL8'FREEP'\n         DC    AL2(VolTbl_Ent_FreePct-VolTbl_Ent) Free % of Vol\n         DC    AL2(L'VolTbl_Ent_FreePct)        Len of Free % of Vol\n\n         DC    CL8'FREEB'\n         DC    AL2(VolTbl_Ent_Sort_FreeBytes-VolTbl_Ent) Free Bytes\n         DC    AL2(L'VolTbl_Ent_Sort_FreeBytes)   Len of Free Bytes\n\n         DC    CL8'FREEE'\n         DC    AL2(VolTbl_Ent_Sort_FreeExt-VolTbl_Ent) Nbr Extents\n         DC    AL2(L'VolTbl_Ent_Sort_FreeExt)   Len of nbr Extents\n\n         DC    CL8'LARGET'\n         DC    AL2(VolTbl_Ent_Sort_LargTrk-VolTbl_Ent) Larg Trk\n         DC    AL2(L'VolTbl_Ent_Sort_LargTrk)   Len of Larg Trks\n\n         DC    CL8'LARGEC'\n         DC    AL2(VolTbl_Ent_Sort_LargCyl-VolTbl_Ent) Larg Cyl\n         DC    AL2(L'VolTbl_Ent_Sort_LargCyl)   Len of Larg Cyl\n\n         DC    CL8'VTRK'\n         DC    AL2(VolTbl_Ent_Sort_VTOCTrk-VolTbl_Ent) VTOC Trk\n         DC    AL2(L'VolTbl_Ent_Sort_VTOCTrk)   Len of VTOC Trks\n\n         DC    CL8'VFREED'\n         DC    AL2(VolTbl_Ent_Sort_FreeDSCB-VolTbl_Ent) Free DSCBs\n         DC    AL2(L'VolTbl_Ent_Sort_FreeDSCB)  Len of Free DSCBs\n\n         DC    CL8'VFREEP'\n         DC    AL2(VolTbl_Ent_VTOCFree-VolTbl_Ent) Start of Free %\n         DC    AL2(L'VolTbl_Ent_VTOCFree)       Len of Free %\n\n         DC    CL8'VIX'\n         DC    AL2(VolTbl_Ent_VTOCIX-VolTbl_Ent) Start of VTOC IX Stat\n         DC    AL2(L'VolTbl_Ent_VTOCIX)         Len of VTOC IS Stat\n\n         DC    CL8'FRAG'\n         DC    AL2(VolTbl_Ent_Frag_Indx-VolTbl_Ent) Frag Index\n         DC    AL2(L'VolTbl_Ent_Frag_Indx)      Len of Frag Index\n\n         DC    CL8'VOLSIZE'\n         DC    AL2(VolTbl_Ent_Sort_VolSize-VolTbl_Ent) Volume size\n         DC    AL2(L'VolTbl_Ent_Sort_VolSize)   Len of volume size\n\n         DC    CL8'STORGRP'\n         DC    AL2(VolTbl_Ent_SMS_StorGrp-VolTbl_Ent) Stor Group\n         DC    AL2(L'VolTbl_Ent_SMS_StorGrp)    Len of Stor Group\n\n         DC    CL8'SMSSTAT'\n         DC    AL2(VolTbl_Ent_SMS_Status-VolTbl_Ent) SMS Status\n         DC    AL2(L'VolTbl_Ent_SMS_Status)    Len of SMS Status\n\n         DC    CL8'CHPIDS'\n         DC    AL2(VolTbl_Ent_CHPIDs-VolTbl_Ent) Start of CHPIDs\n         DC    AL2(L'VolTbl_Ent_CHPIDs)         Len of CHPIDs\n\n         DC    CL8' '\n         DC    HL2'-1'                         End of table\n         DC    AL2(0)\n\nI_Literals_End  DS  0H\n\n\n@I_Dynam                  DSECT        Dynamic area for I00000\n                          DS    18F     O/S Style save area\n@I_31Bit_Stack_Ptr_Ptr    DS    AL4     A(31-bit Stack Ptr)\n@I_24Bit_Stack_Ptr_Ptr    DS    AL4     A(24-bit Stack Ptr)\n@I_TempSave               DS    4FL4    Temporary save area (for MVCLs)\n@I_WK1                    DS    CL(VolTbl_Ent_Len) Work area\n                          DS    0D         Alignment\n@I_Dynam_Length           EQU   *-@I_Dynam  Length of storage\n\n&PGMNAME CSECT\n\n         DROP  ,\n         POP   USING\n         TITLE 'J00010: EDIF/BRIF'\n\n         PUSH  USING\n\nJ00010   DS    0H\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Subroutine: J00010                                                 *\n*                                                                     *\n*  Abstract  : EDIF/BRIF invocation and associated service routines.  *\n*                                                                     *\n*  Inputs    : R1 : ---> A(@_Dynam)                                   *\n*                        A(31-bit Stack Pointer)                      *\n*                        A(24-bit Stack Pointer)                      *\n*  Outputs   : R15 = 0                                                *\n*                                                                     *\n*  Notes     : N/A                                                    *\n*                                                                     *\n*  History:    2001/02/26 SDDA030 - V2.14                             *\n*                                 - New                               *\n*              2002/02/12 SDDA030 - V2.16                             *\n*                                 - Added pop-up panel to BRIF when   *\n*                                   SORT command entered with no or   *\n*                                   invalid operands.                 *\n*              2002/06/11 SDDA030 - V2.18                             *\n*                                   WAIT for VolTbl_Ent to be populated\n*                                   before outputting                 *\n*              2004/10/15 SDDA030 - V2.22                             *\n*                                 - Resequenced labels                *\n*              2006/04/21 SDDA030 - V2.24                             *\n*                                 - Used standardised calling sequence*\n*              ____/__/__ _______                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         STM   R14,R12,12(R13)          Save callers registers\n         LARL  R11,J_Literals           Point to our literals\n         USING (J_Literals,J_Literals_End),R11 Tell the assembler\n\n         L     R12,0(0,R1)              A(@_Dynam)\n         USING @_Dynam,R12              Tell the assembler\n\n*-------------------------------------------------------------------*\n*    Get an area on the stack for our local storage                 *\n*-------------------------------------------------------------------*\n         L     R2,4(0,R1)               A(31-bit stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         SSCSTACK PUSH,                 Get stack area                 +\n               LEN=@J_Dynam_Length,      this long                     +\n               STACK=(R2)                using this stack\n\n         LR    R3,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LHI   R1,@J_Dynam_Length        Its length\n         LA    R14,0                    Clear source address\n         LA    R15,0                     and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R3                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*-------------------------------------------------------------------*\n         ST    R13,4(0,R1)              Chain\n         ST    R1,8(0,R13)               saveareas\n         LR    R13,R1                   Load dynam base\n         USING @J_Dynam,R13             Assign a base\n         L     R15,@J_Dynam+4           Get A(HSA)\n         LM    R0,R3,20(R15)            Restore callers registers\n\n         L     R15,4(0,R1)              A(31-bit Stack Pointer)\n         ST    R15,@J_31Bit_Stack_Ptr_Ptr Save it\n         L     R15,8(0,R1)              A(24-bit Stack Pointer)\n         ST    R15,@J_24Bit_Stack_Ptr_Ptr Save it\n\n*-------------------------------------------------------------------*\n*    Set up our record length for EDIF/BRIF                         *\n*-------------------------------------------------------------------*\n         LHI   R15,VolTbl_Ent_Display_Len Max len to display\n         ST    R15,@J_ISPF_LRECL        Save it\n\n*-------------------------------------------------------------------*\n*    Set up the parms to be passed to the EDIF/BRIF routines        *\n*-------------------------------------------------------------------*\n         LA    R15,@_Dynam              A(Dynamic storage)\n         ST    R15,@J_ISPF_Rtn_Parms    Save the address\n         L     R15,@J_31Bit_Stack_Ptr_Ptr A(31-bit Stack Ptr)\n         ST    R15,@J_ISPF_Rtn_Parms+4  Save the address\n         L     R15,@J_24Bit_Stack_Ptr_Ptr A(24-bit Stack Ptr)\n         ST    R15,@J_ISPF_Rtn_Parms+8  Save the address\n         LA    R15,@J_EDIF_Prev_Rec_Nbr A(EDIF Record Number field)\n         ST    R15,@J_ISPF_Rtn_Parms+12 Save the address\n         LA    R15,@J_ISPF_Rtn_Parms    A(Parms)\n         ST    R15,@J_ISPF_Rtn_Parms_Ptr Save the address\n\n*-------------------------------------------------------------------*\n*    Set up EDIF Parms ...                                          *\n*-------------------------------------------------------------------*\n         TM    @_ISPF_EDIF,L'@_ISPF_EDIF  Do we want EDIF?\n         JZ    J00020                   No, go do BRIF\n\n         LA    R15,=CL8'EDIF'           A(EDIF)\n         ST    R15,@J_ISPF_Parms        Save it\n         LA    R15,J_Data_Name          A(Data-name)\n         ST    R15,@J_ISPF_Parms+4      Save it\n         LA    R15,=CL8'TEXT'           A(Profile name)\n         ST    R15,@J_ISPF_Parms+8      Save it\n         LA    R15,=C'F '               A(record-format)\n         ST    R15,@J_ISPF_Parms+12     Save it\n         LA    R15,@J_ISPF_LRECL        A(record length)\n         ST    R15,@J_ISPF_Parms+16     Save it\n         LA    R15,=AL4(JA0010)         A(Read Routine)\n         ST    R15,@J_ISPF_Parms+20     Save it\n         LA    R15,=AL4(JB0010)         A(Write Routine)\n         ST    R15,@J_ISPF_Parms+24     Save it\n         LA    R15,=AL4(0)              No Cmd Routine\n         ST    R15,@J_ISPF_Parms+28     Save it\n         LA    R15,@J_ISPF_Rtn_Parms_Ptr Point to routine parmlist ptr\n         ST    R15,@J_ISPF_Parms+32     Save it\n         OI    @J_ISPF_Parms+32,X'80'   Flag as last parm\n\n         XC    @J_EDIF_Prev_Rec_Nbr,@J_EDIF_Prev_Rec_Nbr\n\n         J     J00040                   Go invoke EDIF\n\nJ00020   DS    0H\n*-------------------------------------------------------------------*\n*    ... or BRIF parms ...                                          *\n*-------------------------------------------------------------------*\n         LA    R15,=CL8'BRIF'           A(BRIF)\n         ST    R15,@J_ISPF_Parms        Save it\n         LA    R15,J_Data_Name          A(Data-name)\n         ST    R15,@J_ISPF_Parms+4      Save it\n         LA    R15,=C'F '               A(record-format)\n         ST    R15,@J_ISPF_Parms+8      Save it\n         LA    R15,@J_ISPF_LRECL        A(record length)\n         ST    R15,@J_ISPF_Parms+12     Save it\n         LA    R15,=AL4(JA0010)         A(Read Routine)\n         ST    R15,@J_ISPF_Parms+16     Save it\n         LA    R15,=AL4(JC0010)         A(Cmd Routine)\n         ST    R15,@J_ISPF_Parms+20     Save it\n         LA    R15,@J_ISPF_Rtn_Parms_Ptr Point to routine parmlist ptr\n         ST    R15,@J_ISPF_Parms+24     Save it\n         OI    @J_ISPF_Parms+24,X'80'   Flag as last parm\n\n         J     J00040                   Go invoke BRIF\n\nJ00040   DS    0H\n*-------------------------------------------------------------------*\n*    ... and invoke EDIF or BRIF                                    *\n*-------------------------------------------------------------------*\n         LA    R1,@J_ISPF_Parms         A(ISPF Parms)\n         L     R15,@_ISPLINK            A(ISPF routine)\n         BASR  R14,R15                  Invoke EDIF or BRIF\n\n         LA    R15,0                    Clear return code\n         LA    R0,0                     and reason code\n         J     J90010                   and exit\n\n\nJ90010   DS    0H\n*-------------------------------------------------------------------*\n*    Free up our local storage ...                                  *\n*-------------------------------------------------------------------*\n         LA    R1,@J_Dynam              A(Local storage)\n         L     R2,@J_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         L     R13,4(0,R13)             Rescue A(HSA)\n\n         SSCSTACK POP,                  Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=(R2)                on this stack\n\n*-------------------------------------------------------------------*\n*    ... and return to caller                                       *\n*-------------------------------------------------------------------*\n         L     R14,12(0,R13)            Restore return address\n         LA    R15,0                    Clear return code\n         LM    R0,R12,20(R13)           Restore other registers\n         BSM   0,R14                    and return\n\n\nJ_Literals  DS  0H\nJ_Data_Name EQU *\n            DC C'&PGMNAME'\n            DC X'00'\n            DC C'&VERSION'\n            DC C' '\n\n         LTORG\n\nJ_Literals_End  DS  0H\n\n\n@J_Dynam                  DSECT        Dynamic area for J00000\n                          DS    18F     O/S Style save area\n@J_31Bit_Stack_Ptr_Ptr    DS    AL4     A(31-bit Stack Ptr)\n@J_24Bit_Stack_Ptr_Ptr    DS    AL4     A(24-bit Stack Ptr)\n@J_DBLWD                  DS    D       Work area\n@J_ISPF_LRECL             DS    XL4     Record length for EDIF/BRIF\n@J_EDIF_Prev_Rec_Nbr      DS    FL4     Last rec nbr passed to EDIF\n@J_ISPF_Parms             DS    9AL4    Parms for EDIF/BRIF\n@J_ISPF_Rtn_Parms_Ptr     DS    AL4     A(Parms for EDIF/BRIF Routines)\n@J_ISPF_Rtn_Parms         DS    4AL4    Parms for EDIF/BRIF Routines\n                          DS    0D      Alignment\n@J_Dynam_Length           EQU   *-@J_Dynam  Length of storage\n\n&PGMNAME CSECT\n\n         DROP  ,\n         POP   USING\n\n\n\nJA0010   DS    0H\n\n         PUSH  USING                    Save USING environment\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    EDIF/BRIF Read Routine                                         *\n*     Input: R1 ---> A(Record pointer)                              *\n*                    A(Length of record read)                       *\n*                    A(Request Code)                                *\n*                    A(Parms Ptr): A(Parms): A(@_Dynam)             *\n*                                            A(31-bit Stack Ptr)    *\n*                                            A(24-bit Stack Ptr)    *\n*                                            A(EDIF Rec Nbr fld)    *\n*                                                                   *\n*     Output: R15:  0 - Record returned                             *\n*                   8 - EOF                                         *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         BAKR  R14,0                    Save callers registers\n         LARL  R11,JA_Literals          Point to our literals\n         USING (JA_Literals,JA_Literals_End),R11 Tell the assembler\n\n         L     R12,12(0,R1)             Get A(Parmlist pointer)\n         L     R12,0(0,R12)             Get A(Parmlist)\n         L     R12,0(0,R12)             Get A(@_Dynam)\n         USING @_Dynam,R12              Assign a base\n\n*-------------------------------------------------------------------*\n*    Get an area on the stack for our local storage                 *\n*-------------------------------------------------------------------*\n         L     R2,12(0,R1)              Get A(Parmlist pointer)\n         L     R2,0(0,R2)               Get A(Parmlist)\n         L     R2,4(0,R2)               Get A(31-bit Stack Ptr)\n         L     R2,0(0,R2)               Get A(31-bit Stack)\n         SSCSTACK PUSH,                 Get stack area                 +\n               LEN=@JA_Dynam_Length,     this long                     +\n               STACK=(R2)                using this stack\n\n         LR    R3,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LHI   R1,@JA_Dynam_Length      Its length\n         LA    R14,0                    Clear source address\n         LA    R15,0                     and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R3                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*-------------------------------------------------------------------*\n         LR    R13,R1                   Load dynam base\n         USING @JA_Dynam,R13            Assign a base\n         MVC   4(4,R13),=C'F1SA'        Init save area\n\n         EREG  R0,R3                    Restore callers registers\n\n         L     R14,12(0,R1)             A(Parmlist Ptr)\n         L     R14,0(0,R14)             A(Parmlist)\n         L     R15,4(0,R14)             A(31-bit Stack Ptr)\n         ST    R15,@JA_31Bit_Stack_Ptr_Ptr Save it\n         L     R15,8(0,R14)             A(24-bit Stack Ptr)\n         ST    R15,@JA_24Bit_Stack_Ptr_Ptr Save it\n\n*-------------------------------------------------------------------*\n*    Get the record number requested (BRIF), or retrieve it from    *\n*   our variable (EDIF)                                             *\n*-------------------------------------------------------------------*\n         L     R3,8(0,R1)               Get A(record number)\n         L     R3,0(0,R3)               Get record number\n         TM    @_ISPF_BRIF,L'@_ISPF_BRIF Is this BRIF?\n         JO    JA0020                   Yes, skip\n         L     R15,12(0,R1)             No, A(Parms Ptr)\n         L     R15,0(0,R15)             A(Parms)\n         L     R15,12(0,R15)            A(Prev EDIF Record number)\n         L     R3,0(0,R15)              Prev EDIF Record number\n         AHI   R3,1                     Bump it\n         ST    R3,0(0,R15)              and save it\n\nJA0020   DS    0H\n*-------------------------------------------------------------------*\n*    Run through the table, looking for our record                  *\n*-------------------------------------------------------------------*\n         L     R9,@_VolTbl_Ptr          A(Volume Table)\n         L     R10,VolTbl_Hdr_Count-VolTbl_Hdr(R9) Nbr entries\n         AHI   R9,VolTbl_Ent-VolTbl     and point to first\n         USING VolTbl_Ent,R9            Assign a base\n         LA    R4,0                     Clear record count\nJA0030   DS    0H\n         TM    VolTbl_Ent_Heading_Line,L'VolTbl_Ent_Heading_Line A Hdg?\n         JNO   JA0040                   No, skip\n         TM    @_No_Headings,L'@_No_Headings Yes, do we want them?\n         JO    JA0090                   No, skip it\n         J     JA0070                   Yes, check it out\nJA0040   DS    0H\n         TM    VolTbl_Ent_Detail_Line,L'VolTbl_Ent_Detail_Line\n         JNO   JA0050                   No, skip\n         TM    @_No_Details,L'@_No_Details Yes, do we want them?\n         JO    JA0090                   No, skip it\n         J     JA0070                   Yes, check it out\nJA0050   DS    0H\n         TM    VolTbl_Ent_Total_Line,L'VolTbl_Ent_Total_Line\n         JNO   JA0060                   No, skip\n         TM    @_No_Totals,L'@_No_Totals Yes, do we want them?\n         JO    JA0090                   No, skip it\n         J     JA0070                   Yes, check it out\nJA0060   DS    0H\n         TM    @_Statistics,L'@_Statistics Do we want stats?\n         JNO   JA0090                   No, skip it\nJA0070   DS    0H\n         LA    R8,VolTbl_Ent            Save A(Entry)\n         AHI   R4,1                     Bump record count\n         CR    R4,R3                    Is this ours?\n         JL    JA0090                   No, skip it\n         TM    @_Statistics,L'@_Statistics Yes, Stats line?\n         JNO   JA0080                   No, skip\n         STM   R0,R1,@JA_Temp_Save      Yes, save our registers\n\n         LA    R15,@_Dynam              A(Dynamic area)\n         ST    R15,@JA_Parms_Std        Save it\n         L     R15,@JA_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)\n         ST    R15,@JA_Parms_Std+4      Save it\n         L     R15,@JA_24Bit_Stack_Ptr_Ptr A(24-bit Stack Pointer)\n         ST    R15,@JA_Parms_Std+8      Save it\n         LA    R15,VolTbl_Ent           A(Table entry)\n         ST    R15,@JA_Parms_V00010     Save it\n\n         LA    R1,@JA_Parms             Point to the parmlist\n         BRAS  R14,V00010               Process stats line\n         LM    R0,R1,@JA_Temp_Save      Restore our registers\nJA0080   DS    0H\n         TM    VolTbl_Ent_ECB,X'40'     Entry populated?\n         JO    JA0100                   Yes, OK\n         STM   R0,R1,@JA_Temp_Save      Yes, save our registers\n         WAIT  ECB=VolTbl_Ent_ECB       No, WAIT for it\n         LM    R0,R1,@JA_Temp_Save      Restore our registers\n         J     JA0100                   and skip\nJA0090   DS    0H\n         AHI   R9,VolTbl_Ent_Len        A(Next entry)\n         BRCT  R10,JA0030\n\n*-------------------------------------------------------------------*\n*    We have reached the end of the table before finding our        *\n*   record - set the EOF return code, and, if this is BRIF, the     *\n*   pointer to the last valid record, and the record number.        *\n*-------------------------------------------------------------------*\n         LA    R15,8                  EOF\n         TM    @_ISPF_EDIF,L'@_ISPF_EDIF Is this EDIF?\n         JO    JA0110                 Yes, exit\n\n         LR    R9,R8                   A(Last valid entry)\n         L     R14,8(0,R1)            A(Record count)\n         ST    R4,0(0,R14)            update it for BRIF\n         LA    R15,8                  EOF\n         J     JA0110                 and skip\n\nJA0100   DS    0H\n         LA    R15,0                    found our record\n         J     JA0110                   and skip\n\nJA0110   DS    0H\n*-------------------------------------------------------------------*\n*    ... and update the record pointer (R9).                        *\n*-------------------------------------------------------------------*\n         AHI   R9,VolTbl_Ent_Display-VolTbl_Ent   Readable bits\n\n         L     R14,0(0,R1)            A(Record pointer)\n         ST    R9,0(0,R14)            update it\n         J     JA9010                 and exit\n\nJA9010   DS    0H\n*-------------------------------------------------------------------*\n*    Free up our local storage ...                                  *\n*-------------------------------------------------------------------*\n         LR    R3,R15                 Save return code\n\n         LA    R1,@JA_Dynam             A(Local storage)\n         L     R2,@JA_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n\n         SSCSTACK POP,                  Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=(R2)                on this stack\n\n         LR    R15,R3                   Restore return code\n\n*-------------------------------------------------------------------*\n*    ... and return to caller                                       *\n*-------------------------------------------------------------------*\n         PR    ,                        and return\n\nJA_Literals  DS  0H\n\n         LTORG\n\nJA_Literals_End  DS  0H\n\n\n@JA_Dynam                 DSECT\n                          DS    18F     O/S style save area\n@JA_31Bit_Stack_Ptr_Ptr   DS    AL4     A(31-bit Stack Ptr)\n@JA_24Bit_Stack_Ptr_Ptr   DS    AL4     A(24-bit Stack Ptr)\n@JA_Temp_Save             DS    2FL4    Save area around V00010 call\n\n@JA_Parms                 DS    0F      Parms for called rtns\n@JA_Parms_Std             DS    3AL4     Standard 3 parms\n@JA_Parms_Extra           EQU   *        Extra parms\n@JA_Parms_V00010          DS    AL4         for V00010\n                          ORG   ,\n                          DS    0D\n@JA_Dynam_Length          EQU   *-@JA_Dynam\n\n\n&PGMNAME CSECT\n         DROP  ,                        Free base registers\n         POP   USING\n\n\nJB0010   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    EDIF Write Routine                                             *\n*     Input: R1 ---> A(Record pointer)                              *\n*                    A(Length of record read)                       *\n*                    A(Change Flags)                                *\n*                    A(Request Code)                                *\n*                    A(Parms Ptr): A(Parms): A(@_Dynam)             *\n*                                            A(31-bit Stack Ptr)    *\n*                                            A(24-bit Stack Ptr)    *\n*                                            A(A word for our use)  *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         PUSH  USING                    Save USING environment\n         DROP  ,                        Free base registers\n\n         BAKR  R14,0                    Save callers registers\n         LARL  R11,JB_Literals          Point to our literals\n         USING (JB_Literals,JB_Literals_End),R11 Tell the assembler\n\n         L     R12,16(0,R1)             Get A(ParmList Ptr)\n         L     R12,0(0,R12)             Get A(ParmList)\n         L     R12,0(0,R12)             Get A(@_Dynam)\n         USING @_Dynam,R12              Assign a base\n\n*-------------------------------------------------------------------*\n*    Get an area on the stack for our local storage                 *\n*-------------------------------------------------------------------*\n         L     R2,16(0,R1)              Get A(Parmlist Ptr)\n         L     R2,0(0,R2)               Get A(Parmlist)\n         L     R2,4(0,R2)               Get A(31-bit Stack Ptr)\n         L     R2,0(0,R2)               Get A(31-bit Stack)\n         SSCSTACK PUSH,                 Get stack area                 +\n               LEN=@JB_Dynam_Length,     this long                     +\n               STACK=(R2)                using this stack\n\n         LR    R3,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LHI   R1,@JB_Dynam_Length      Its length\n         LA    R14,0                    Clear source address\n         LA    R15,0                     and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R3                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*    Set up our save area, and restore the important registers      *\n*   that we have destroyed                                          *\n*-------------------------------------------------------------------*\n         LR    R13,R1                   Load dynam base\n         USING @JB_Dynam,R13            Assign a base\n         MVC   4(4,R13),=C'F1SA'        Init save area\n\n         EREG  R0,R3                    Restore callers registers\n\n         L     R14,16(0,R1)             A(Parmlist Ptr)\n         L     R14,0(0,R14)             A(Parmlist)\n         L     R15,4(0,R14)             A(31-bit Stack)\n         ST    R15,@JB_31Bit_Stack_Ptr_Ptr Save it\n         L     R15,8(0,R14)             A(24-bit Stack)\n         ST    R15,@JB_24Bit_Stack_Ptr_Ptr Save it\n\n*-------------------------------------------------------------------*\n*    If this is the last (or only) write request, set an ISPF       *\n*    message to say the data wasn't saved ...                       *\n*-------------------------------------------------------------------*\n         L     R15,12(0,R1)             A(Request code)\n         L     R15,0(0,R15)             Get it\n         CHI   R15,2                    Last write request?\n         JE    JB0020                   Yes, issue message\n         CHI   R15,3                    Maybe, Last (and only)?\n         JE    JB0020                   Yes, skip\n\n         LA    R15,0                    No, clear return code\n         J     JB9010                   and exit\n\nJB0020   DS    0H\n         LA    R15,=CL8'VDEFINE'        ISPF Function\n         ST    R15,@JB_ISPF_Parms       Save it\n         LA    R15,=CL8'CHAR'           Character variables\n         ST    R15,@JB_ISPF_Parms+12 Save it\n\n         LA    R15,=CL8'ZEDSMSG'        Variable name\n         ST    R15,@JB_ISPF_Parms+4     Save it\n         LA    R15,JB_NoSave_SMsg       Short message\n         ST    R15,@JB_ISPF_Parms+8     Save it\n         LA    R15,=AL4(L'JB_NoSave_SMsg)     Length of message\n         ST    R15,@JB_ISPF_Parms+16 Save it\n         OI    @JB_ISPF_Parms+16,X'80' Flag end of list\n         LA    R1,@JB_ISPF_Parms        A(Parmlist)\n         L     R15,@_ISPLINK            A(ISPF Interface)\n         BASR  R14,R15                  Go do it\n\n         LA    R15,=CL8'ZEDLMSG'        Variable name\n         ST    R15,@JB_ISPF_Parms+4     Save it\n         LA    R15,JB_NoSave_LMsg       Short message\n         ST    R15,@JB_ISPF_Parms+8     Save it\n         LA    R15,=AL4(L'JB_NoSave_LMsg)     Length of message\n         ST    R15,@JB_ISPF_Parms+16 Save it\n         OI    @JB_ISPF_Parms+16,X'80' Flag end of list\n         LA    R1,@JB_ISPF_Parms        A(Parmlist)\n         L     R15,@_ISPLINK            A(ISPF Interface)\n         BASR  R14,R15                  Go do it\n\n         LA    R15,=CL8'SETMSG'         Yes, ISPF Function\n         ST    R15,@JB_ISPF_Parms       Save it\n         LA    R15,=CL8'ISRZ001'        A(Message ID)\n         ST    R15,@JB_ISPF_Parms+4     Save it\n         OI    @JB_ISPF_Parms+4,X'80' Mark end of list\n         LA    R1,@JB_ISPF_Parms        Point to ISPF parms\n         L     R15,@_ISPLINK            A(Interface routine)\n         BASR  R14,R15                  Go do it\n\n*-------------------------------------------------------------------*\n*    ... and exit                                                   *\n*-------------------------------------------------------------------*\n\n         LA    R15,0                    Clear return code\n         J     JB9010                   and exit\n\nJB9010   DS    0H\n*-------------------------------------------------------------------*\n*    Free up our local storage ...                                  *\n*-------------------------------------------------------------------*\n         LR    R3,R15                 Save return code\n\n         LA    R1,@JB_Dynam             A(Local storage)\n         L     R2,@JB_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         L     R13,4(0,R13)             Rescue A(HSA)\n\n         SSCSTACK POP,                  Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=(R2)                on this stack\n\n         LR    R15,R3                   Restore return code\n\n*-------------------------------------------------------------------*\n*    ... and return to caller                                       *\n*-------------------------------------------------------------------*\n         PR    ,                        and return\n\n\nJB_Literals  DS  0H\n\nJB_NoSave_SMsg     DC   C'SAVE disabled'\nJB_NoSave_LMsg     DC   C'Use CREATE or REPLACE to save the data'\n\n         LTORG\n\nJB_Literals_End  DS  0H\n\n\n@JB_Dynam                 DSECT\n                          DS    18F     O/S style save area\n@JB_31Bit_Stack_Ptr_Ptr   DS    AL4     A(31-bit Stack Ptr)\n@JB_24Bit_Stack_Ptr_Ptr   DS    AL4     A(24-bit Stack Ptr)\n@JB_ISPF_Parms            DS    5AL4    Parm list for ISPF\n                          DS    0D\n@JB_Dynam_Length          EQU   *-@JB_Dynam\n\n\n&PGMNAME CSECT\n         DROP  ,                        Free base registers\n         POP   USING\n\n\nJC0010   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    BRIF Command Routine                                           *\n*     Input: R1 ---> A(Function Code)                               *\n*                    A(Parms Ptr): A(Parms): A(@_Dynam)             *\n*                                            A(31-bit Stack Ptr)    *\n*                                            A(24-bit Stack Ptr)    *\n*                                            A(A word for our use)  *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         PUSH  USING                    Save USING environment\n         DROP  ,                        Free base registers\n\n         BAKR  R14,0                    Save callers registers\n         LARL  R11,JC_Literals          Point to our literals\n         USING (JC_Literals,JC_Literals_End),R11 Tell the assembler\n\n         L     R12,4(0,R1)              Get A(Parmlist Ptr)\n         L     R12,0(0,R12)             Get A(ParmList)\n         L     R12,0(0,R12)             Get A(@_Dynam)\n         USING @_Dynam,R12              Assign a base\n\n*-------------------------------------------------------------------*\n*    Get an area on the stack for our local storage                 *\n*-------------------------------------------------------------------*\n         L     R2,4(0,R1)               Get A(Parmlist Ptr)\n         L     R2,0(0,R2)               Get A(Parmlist)\n         L     R2,4(0,R2)               Get A(31-bit Stack Ptr)\n         L     R2,0(0,R2)               Get A(31-bit Stack)\n         SSCSTACK PUSH,                 Get stack area                 +\n               LEN=@JC_Dynam_Length,     this long                     +\n               STACK=(R2)                using this stack\n\n         LR    R3,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LHI   R1,@JC_Dynam_Length      Its length\n         LA    R14,0                    Clear source address\n         LA    R15,0                     and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R3                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*    Set up our save area, and restore the important registers      *\n*   that we have destroyed                                          *\n*-------------------------------------------------------------------*\n         LR    R13,R1                   Load dynam base\n         USING @JC_Dynam,R13            Assign a base\n         MVC   4(4,R13),=C'F1SA'        Init save area\n\n         EREG  R0,R3                    Restore callers registers\n\n         L     R14,4(0,R1)              A(Parmlist Ptr)\n         L     R14,0(0,R14)             A(Parmlist)\n         L     R15,4(0,R14)             A(31-bit Stack)\n         ST    R15,@JC_31Bit_Stack_Ptr_Ptr Save it\n         L     R15,8(0,R14)             A(24-bit Stack)\n         ST    R15,@JC_24Bit_Stack_Ptr_Ptr Save it\n\n*-------------------------------------------------------------------*\n*    Check out the function code from BRIF ...                      *\n*-------------------------------------------------------------------*\n         L     R15,0(0,R1)              Get A(Function code)\n         L     R15,0(0,R15)             Get it\n         CHI   R15,20                   Unknown command?\n         JNE   JC0030                   No, let recursive browse work\n\n*-------------------------------------------------------------------*\n*    ... and go check it out                                        *\n*-------------------------------------------------------------------*\n         LA    R15,@_Dynam              A(Dynamic area)\n         ST    R15,@JC_Parms_Std        Save it\n         L     R15,@JC_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)\n         ST    R15,@JC_Parms_Std+4      Save it\n         L     R15,@JC_24Bit_Stack_Ptr_Ptr A(24-bit Stack Pointer)\n         ST    R15,@JC_Parms_Std+8      Save it\n\n         LA    R1,@JC_Parms             Point to the parmlist\n         BRAS  R14,L00010               Process command\n\n         TM    @_ReDisplay,L'@_ReDisplay Display mode change?\n         JO    JC0020                   Yes, set rc and exit\n         LTR   R15,R15                  Did we process the command?\n         JNZ   JC0030                   No, skip\n         LA    R15,0                    Yes, normal completion\n         J     JC9010                   and exit\n\nJC0020   DS    0H\n         LA    R15,=CL8'VDEFINE'        ISPF Function\n         ST    R15,@JC_ISPF_Parms       Save it\n         LA    R15,=CL8'ZCMD'           Variable name\n         ST    R15,@JC_ISPF_Parms+4     Save it\n         LA    R15,JC_Blanks            A(blank string)\n         ST    R15,@JC_ISPF_Parms+8     Save it\n         LA    R15,=CL8'CHAR'           Character variables\n         ST    R15,@JC_ISPF_Parms+12    Save it\n         LA    R15,=AL4(L'JC_Blanks)    Length of blank string\n         ST    R15,@JC_ISPF_Parms+16    Save it\n         OI    @JC_ISPF_Parms+16,X'80'  Flag end of list\n         LA    R1,@JC_ISPF_Parms        A(Parmlist)\n         L     R15,@_ISPLINK            A(ISPF Interface)\n         BASR  R14,R15                  Go do it\n\n         LA    R15,=CL8'VPUT'           ISPF Function\n         ST    R15,@JC_ISPF_Parms       Save it\n         LA    R15,=CL8'ZCMD'           A(Variable name)\n         ST    R15,@JC_ISPF_Parms+4     Save it\n         LA    R15,=CL8'ASIS'           A(Variable name)\n         ST    R15,@JC_ISPF_Parms+8     Save it\n         OI    @JC_ISPF_Parms+8,X'80'   Flag end of list\n         LA    R1,@JC_ISPF_Parms        A(Parmlist)\n         L     R15,@_ISPLINK            A(ISPF Interface)\n         BASR  R14,R15                  Go do it\n\n         LHI   R15,20                   Re-display requested, exit\n         J     JC9010                   and exit\n\nJC0030   DS    0H\n         LHI   R15,4                    Unknown command, let BRIF do it\n         J     JC9010                   and exit\n\nJC9010   DS    0H\n*-------------------------------------------------------------------*\n*    Free up our local storage ...                                  *\n*-------------------------------------------------------------------*\n         LR    R3,R15                 Save return code\n\n         LA    R1,@JC_Dynam             A(Local storage)\n         L     R2,@JC_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n\n         SSCSTACK POP,                  Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=(R2)                on this stack\n\n         LR    R15,R3                   Restore return code\n\n*-------------------------------------------------------------------*\n*    ... and return to caller                                       *\n*-------------------------------------------------------------------*\n         PR    ,                        and return\n\nJC_Literals  DS  0H\n\nJC_Blanks    DC  C' '\n\n         LTORG\n\nJC_Literals_End  DS  0H\n\n\n@JC_Dynam                 DSECT\n                          DS    18F     O/S style save area\n@JC_31Bit_Stack_Ptr_Ptr   DS    AL4     A(31-bit Stack Ptr)\n@JC_24Bit_Stack_Ptr_Ptr   DS    AL4     A(24-bit Stack Ptr)\n@JC_ISPF_Parms            DS    5AL4    ISPF parms\n\n@JC_Parms                 DS    0F      Parms for called rtns\n@JC_Parms_Std             DS    3AL4     Standard 3 parms\n@JC_Parms_Extra           EQU   *        Extra parms\n                          ORG   ,\n\n                          DS    0D\n@JC_Dynam_Length          EQU   *-@JC_Dynam\n\n&PGMNAME CSECT\n         DROP  ,                        Free base registers\n         POP   USING\n         TITLE 'K00010: ISPF(S) Display'\n\n         PUSH  USING\n\nK00010   DS    0H\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Routine   : K00010                                                 *\n*                                                                     *\n*  Abstract  : Display the results via the ISPF SPACE Panel           *\n*                                                                     *\n*  Inputs    : R1 : ---> A(@_Dynam)                                   *\n*                        A(31-bit Stack Pointer)                      *\n*                        A(24-bit Stack Pointer)                      *\n*  Outputs   : R15: 0: OK                                             *\n*                   4: Panel not found                                *\n*                                                                     *\n*  Notes     :                                                        *\n*                                                                     *\n*  History:    2002/02/12 SDDA030 - V2.16                             *\n*                                 - New (originally part of G00010)   *\n*                                 - Used Dynamic displays (rather than*\n*                                   TBDISPL) for ISPF(S).             *\n*                                 - Added LEFT/RIGHT processing for   *\n*                                   ISPF(S).                          *\n*                                 - Added sort prompt pop-up panel in *\n*                                   ISPF(B).                          *\n*              2002/06/11 SDDA030 - V2.18                             *\n*                                   WAIT for VolTbl_Ent to be populated\n*                                   before outputting                 *\n*              2004/10/15 SDDA030 - V2.22                             *\n*                                 - Resequenced labels                *\n*              2006/04/21 SDDA030 - V2.24                             *\n*                                 - Added code to display number when *\n*                                   cursor on numeric fld, and ENTER. *\n*                                 - Used standardised calling sequence*\n*                                 - Changed 'Line x of y' to 'Line x'.*\n*              ____/__/__ _______                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         STM   R14,R12,12(R13)          Save callers registers\n         LARL  R11,K_Literals           Point to our literals\n         USING (K_Literals,K_Literals_End),R11 Tell the assembler\n\n         L     R12,0(0,R1)              A(@_Dynam)\n         USING @_Dynam,R12              Tell the assembler\n\n*-------------------------------------------------------------------*\n*    Get an area on the stack for our local storage                 *\n*-------------------------------------------------------------------*\n         L     R2,4(0,R1)               A(31-bit stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         SSCSTACK PUSH,                 Get stack area                 +\n               LEN=@K_Dynam_Length,      this long                     +\n               STACK=(R2)                using this stack\n\n         LR    R3,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LHI   R1,@K_Dynam_Length        Its length\n         LA    R14,0                    Clear source address\n         LA    R15,0                     and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R3                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*-------------------------------------------------------------------*\n         ST    R13,4(0,R1)              Chain\n         ST    R1,8(0,R13)               saveareas\n         LR    R13,R1                   Load dynam base\n         USING @K_Dynam,R13             Assign a base\n         L     R15,@K_Dynam+4           Get A(HSA)\n         LM    R0,R3,20(R15)            Restore callers registers\n\n         L     R15,4(0,R1)              A(31-bit Stack Pointer)\n         ST    R15,@K_31Bit_Stack_Ptr_Ptr Save it\n         L     R15,8(0,R1)              A(24-bit Stack Pointer)\n         ST    R15,@K_24Bit_Stack_Ptr_Ptr Save it\n\n*--------------------------------------------------------------------*\n*   Initialize our standard parmlist                                 *\n*--------------------------------------------------------------------*\n         LA    R15,@_Dynam              A(Dynamic area)\n         ST    R15,@K_Parms_Std         Save it\n         L     R15,@K_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)\n         ST    R15,@K_Parms_Std+4       Save it\n         L     R15,@K_24Bit_Stack_Ptr_Ptr A(24-bit Stack Pointer)\n         ST    R15,@K_Parms_Std+8       Save it\n\n*-------------------------------------------------------------------*\n*    Check to see that our panel exists, and that it has an         *\n*   appropriate Dynamic area in it.                                 *\n*-------------------------------------------------------------------*\n         LA    R15,=CL8'VDEFINE'        ISPF Function\n         ST    R15,@K_ISPF_Parms        Save it\n         LA    R15,K_ISPF_PQUERY_Names  A(Variable names)\n         ST    R15,@K_ISPF_Parms+4      Save it\n         LA    R15,@K_ISPF_PQUERY_Values A(Variable storage)\n         ST    R15,@K_ISPF_Parms+8      Save it\n         LA    R15,K_ISPF_PQUERY_Types  A(Variable types)\n         ST    R15,@K_ISPF_Parms+12     Save it\n         LA    R15,K_ISPF_PQUERY_Lens   A(Variable lengths)\n         ST    R15,@K_ISPF_Parms+16     Save it\n         LA    R15,=CL8'LIST'           Variable types\n         ST    R15,@K_ISPF_Parms+20     Save it\n         OI    @K_ISPF_Parms+20,X'80'   Flag last parm\n         LA    R1,@K_ISPF_Parms         A(ISPF Parms)\n         L     R15,@_ISPLINK            A(ISPF routine)\n         BASR  R14,R15                  Go check out panel\n\n         LA    R15,=CL8'PQUERY'         ISPF Function\n         ST    R15,@K_ISPF_Parms        Save it\n         LA    R15,=CL8'&PNLNAME'       A(Panel name)\n         ST    R15,@K_ISPF_Parms+4      Save it\n         LA    R15,=CL8'DATA    '       A(Area name)\n         ST    R15,@K_ISPF_Parms+8      Save it\n         LA    R15,K_SPCDYNTY           A(Area Type variable name)\n         ST    R15,@K_ISPF_Parms+12     Save it\n         LA    R15,K_SPCDYNWI           A(Width variable name)\n         ST    R15,@K_ISPF_Parms+16     Save it\n         LA    R15,K_SPCDYNDE           A(Depth variable name)\n         ST    R15,@K_ISPF_Parms+20     Save it\n         LA    R15,K_SPCDYNRO           A(Starting Row Number name)\n         ST    R15,@K_ISPF_Parms+24     Save it\n         LA    R15,K_SPCDYNCO           A(Starting Column number name)\n         ST    R15,@K_ISPF_Parms+28     Save it\n         OI    @K_ISPF_Parms+28,X'80'   Flag last parm\n         LA    R1,@K_ISPF_Parms         A(ISPF Parms)\n         L     R15,@_ISPLINK            A(ISPF routine)\n         BASR  R14,R15                  Go check out panel\n         LTR   R15,R15                  All OK?\n         JNZ   K80010                   No, error and exit\n\n         CLC   =CL8'DYNAMIC',@K_ISPF_SPCDYNTN_Value  Dynamic?\n         JNE   K80010                   No, error and exit\n         ICM   R15,B'1111',@K_ISPF_SPCDYNWI_Value  Width OK?\n         JZ    K80010                   No, error and exit\n         ST    R15,@K_ISPF_Dyn_Area_Width Yes, save it\n         ICM   R15,B'1111',@K_ISPF_SPCDYNDE_Value  Depth OK?\n         JZ    K80010                   No, error and exit\n         ST    R15,@K_ISPF_Dyn_Area_Depth Yes, save it\n         ICM   R15,B'1111',@K_ISPF_SPCDYNRO_Value  Starting Row OK?\n         JZ    K80010                   No, error and exit\n         AHI   R15,-1                   Yes, relative to 0\n         ST    R15,@K_ISPF_Dyn_Area_Row and save it\n         ICM   R15,B'1111',@K_ISPF_SPCDYNCO_Value  Starting column OK?\n         JZ    K80010                   No, error and exit\n         AHI   R15,-1                   Yes, relative to 0\n         ST    R15,@K_ISPF_Dyn_Area_Column and save it\n\n*---------------------------------------------------------------------*\n*     The panel seems OK, get some storage for the Dynamic Area ...   *\n*---------------------------------------------------------------------*\n         L     R1,@K_ISPF_Dyn_Area_Width Get area width\n         M     R0,@K_ISPF_Dyn_Area_Depth Get total length\n\n         ST    R1,@K_ISPF_Dyn_Area_Len  Save it\n         LR    R0,R1                    in proper register\n\n         L     R2,@K_31Bit_Stack_Ptr_Ptr A(31-bit stack Ptr)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         SSCSTACK PUSH,                 Get stack area                 +\n               LEN=(0),                  this long                     +\n               STACK=(R2)                using this stack\n\n         ST    R1,@K_ISPF_Dyn_Area_Ptr  Save A(Our storage)\n\n*---------------------------------------------------------------------*\n*     ... define it to ISPF ...                                       *\n*---------------------------------------------------------------------*\n         LA    R15,=CL8'VDEFINE'        ISPF Function\n         ST    R15,@K_ISPF_Parms        Save it\n         LA    R15,=CL8'DATA'           Variable name\n         ST    R15,@K_ISPF_Parms+4      Save it\n         L     R15,@K_ISPF_Dyn_Area_Ptr Point to it\n         ST    R15,@K_ISPF_Parms+8      Save it\n         LA    R15,=CL8'CHAR'           Character data\n         ST    R15,@K_ISPF_Parms+12     Save it\n         L     R15,@K_ISPF_Dyn_Area_Len Length of diaplay area\n         ST    R15,@K_ISPF_Parms+20     Save it\n         LA    R15,@K_ISPF_Parms+20     Point to it\n         ST    R15,@K_ISPF_Parms+16     Save it\n         OI    @K_ISPF_Parms+16,X'80'   Flag end of list\n         LA    R1,@K_ISPF_Parms         A(Parmlist)\n         L     R15,@_ISPLINK            A(ISPF Interface)\n         BASR  R14,R15                  Go do it\n\n*---------------------------------------------------------------------*\n*     ... and init some variables.                                    *\n*---------------------------------------------------------------------*\n         LA    R15,VolTbl_Ent_DevType-VolTbl_Ent_Display Set our\n         ST    R15,@K_VolTbl_Ent_Offset  offset\n\n         LA    R15,0                    Current top of display\n         ST    R15,@K_VolTbl_Ent_Display_Line Save it\n\n         LHI   R15,VolTbl_Ent_Display_Len Get max display len\n         S     R15,@K_ISPF_Dyn_Area_Width  Max offset within display\n         A     R15,=AL4(VolTbl_Ent_DevType-VolTbl_Ent_Display)\n         ST    R15,@K_VolTbl_Ent_Offset_Max Save it\n\n         L     R15,@_VolTbl_Ptr         A(Volume Table)\n         L     R15,VolTbl_Hdr_Count-VolTbl_Hdr(R15) Get nbr entries\n         ST    R15,@K_VolTbl_Ent_Display_Line_Max Save it\n\n         LA    R15,0                    Number of heading lines\n         ST    R15,@K_ISPF_Dyn_Area_Hdg_Lines and save it\n         ST    R15,@K_VolTbl_Hdg_Lines  here too\n\n         MVC   @K_VolTbl_Ent_Display_Line_Prev,=FL4'-1' Force the area\n         MVC   @K_VolTbl_Ent_Offset_Prev,=FL4'-1'  to be populated\n\n*---------------------------------------------------------------------*\n*     Set the EX length of each line of data to be copied to the      *\n*    dynamic area                                                     *\n*---------------------------------------------------------------------*\n         L     R15,@K_ISPF_Dyn_Area_Width Get area width\n         S     R15,=AL4(VolTbl_Ent_DevType-VolTbl_Ent_Display) Len\n         AHI   R15,-1                   EX length of data\n         ST    R15,@K_VolTbl_Ent_MVC_Len Save it\n\n*---------------------------------------------------------------------*\n*   Produce Heading 0, if required ...                                *\n*---------------------------------------------------------------------*\n         TM    @_No_Headings,L'@_No_Headings  Headings wanted?\n         JO    K00050                   No, skip\n\n         LA    R15,=CL8'VDEFINE'        ISPF Function\n         ST    R15,@K_ISPF_Parms        Save it\n         LA    R15,=CL8'HDG0'           Point to variable name\n         ST    R15,@K_ISPF_Parms+4      Save it\n         L     R15,@_VolTbl_Ptr         A(Volume Table)\n         LA    R15,VolTbl_Ent-VolTbl(R15) Point to first heading\n         LA    R15,VolTbl_Ent_Display-VolTbl_Ent(R15) Readable data\n         ST    R15,@K_ISPF_Parms+8      Save it\n         LA    R15,=CL8'CHAR'           Character variables\n         ST    R15,@K_ISPF_Parms+12     Save it\n         LHI   R15,VolTbl_Ent_Display_Len Get max display len\n         ST    R15,@K_DBLWD             Save it\n         LA    R15,@K_DBLWD             A(record length)\n         ST    R15,@K_ISPF_Parms+16     Save it\n         OI    @K_ISPF_Parms+16,X'80'   Flag end of list\n         LA    R1,@K_ISPF_Parms         A(Parmlist)\n         L     R15,@_ISPLINK            A(ISPF Interface)\n         BASR  R14,R15                  Go do it\n\n*---------------------------------------------------------------------*\n*   ... and count the number of heading lines in the table.           *\n*---------------------------------------------------------------------*\n         LA    R14,0                    Nbr hdg lines in VolTbl\n         LA    R15,0                    Nbr hdg lines in ISPF area\n\n         L     R9,@_VolTbl_Ptr          A(Volume Table)\n         L     R10,VolTbl_Hdr_Count-VolTbl_Hdr(R9) Get nbr entries\n         AHI   R9,VolTbl_Ent-VolTbl     Point to first entry\n         USING VolTbl_Ent,R9            and assign a base\nK00020   DS    0H\n         TM    VolTbl_Ent_Heading_Line1,L'VolTbl_Ent_Heading_Line1\n         JO    K00030                   Yes, skip\n         TM    VolTbl_Ent_Heading_Line,L'VolTbl_Ent_Heading_Line\n         JNO   K00040                   Not a hdg line, all done\n         AHI   R15,1                    Bump hdgs in ISPF area\nK00030   DS    0H\n         AHI   R14,1                    Bump hdgs in VolTbl\n\n         AHI   R9,VolTbl_Ent_Len        A(Next entry)\n         BRCT  R10,K00020               and continue\n\n         DROP  R9                       Free VolTbl_Ent base\nK00040   DS    0H\n         C     R15,@K_ISPF_Dyn_Area_Depth Is Dyn Area deep enough?\n         JNL   K80010                   No, use BRIF instead\n\n         ST    R15,@K_ISPF_Dyn_Area_Hdg_Lines Save it\n         ST    R14,@K_VolTbl_Hdg_Lines  Save nbr hdgs in VolTbl\n\n         L     R15,@K_VolTbl_Ent_Display_Line_Max Get max display line\n         S     R15,@K_ISPF_Dyn_Area_Hdg_Lines Adjust for heading lines\n         ST    R15,@K_VolTbl_Ent_Display_Line_Max Save it\n\nK00050   DS    0H\n*---------------------------------------------------------------------*\n*    VDEFINE FLIN, used in the 'Line x' display                       *\n*---------------------------------------------------------------------*\n         LA    R15,=CL8'VDEFINE'        ISPF Function\n         ST    R15,@K_ISPF_Parms        Save it\n         LA    R15,=CL8'FLIN'           Variable name (Curr line nbr)\n         ST    R15,@K_ISPF_Parms+4      Save it\n         LA    R15,@K_FLIN              Point to it\n         ST    R15,@K_ISPF_Parms+8      Save it\n         LA    R15,=CL8'CHAR'           Character data\n         ST    R15,@K_ISPF_Parms+12     Save it\n         LA    R15,L'@K_FLIN            Length of variable\n         ST    R15,@K_ISPF_Parms+20     Save it\n         LA    R15,@K_ISPF_Parms+20     Point to it\n         ST    R15,@K_ISPF_Parms+16     Save it\n         OI    @K_ISPF_Parms+16,X'80'   Flag end of list\n         LA    R1,@K_ISPF_Parms         A(Parmlist)\n         L     R15,@_ISPLINK            A(ISPF Interface)\n         BASR  R14,R15                  Go do it\n\nK00060   DS    0H\n*---------------------------------------------------------------------*\n*         Populate the table.                                         *\n*                                                                     *\n*     Verify that the display line and offset are within our limits.  *\n*    Note that @K_VolTbl_Ent_Display_Line is relative to the 1st      *\n*    non-heading line in VolTbl.                                      *\n*    If they aren't, adjust them.                                     *\n*---------------------------------------------------------------------*\n         ICM   R15,B'1111',@K_VolTbl_Ent_Display_Line Get line nbr\n         JNM   K00070                       0 or greater, OK\n         LA    R15,0                        Fix it\nK00070   DS    0H\n         C     R15,@K_VolTbl_Ent_Display_Line_Max Too big?\n         JNH   K00080                       No, OK\n         L     R15,@K_VolTbl_Ent_Display_Line_Max Yes, reset it\nK00080   DS    0H\n         ST    R15,@K_VolTbl_Ent_Display_Line Save it\n\n         L     R15,@K_VolTbl_Ent_Offset     Get offset\n         C     R15,=AL4(VolTbl_Ent_DevType-VolTbl_Ent_Display) small?\n         JNL   K00090                       No, OK\n         L     R15,=AL4(VolTbl_Ent_DevType-VolTbl_Ent_Display)\nK00090   DS    0H\n         C     R15,@K_VolTbl_Ent_Offset_Max Too big?\n         JNH   K00100                   No, OK\n         L     R15,@K_VolTbl_Ent_Offset_Max Yes, reset it\nK00100   DS    0H\n         ST    R15,@K_VolTbl_Ent_Offset Save it\n\n*---------------------------------------------------------------------*\n*     If the display line and the offset have not changed, we can     *\n*    just redisplay                                                   *\n*---------------------------------------------------------------------*\n         CLC   @K_VolTbl_Ent_Display_Line_Prev,@K_VolTbl_Ent_Display_Li+\n               ne\n         JNE   K00110                   Display line changed\n         CLC   @K_VolTbl_Ent_Offset_Prev,@K_VolTbl_Ent_Offset\n         JE    K00260                   Nothing changed, skip\n\nK00110   DS    0H\n*---------------------------------------------------------------------*\n*     If we need to re-generate the headings (because of a LEFT/RIGHT *\n*    scroll), do it now                                               *\n*---------------------------------------------------------------------*\n         TM    @_No_Headings,L'@_No_Headings  Are we doing headings?\n         JO    K00140                   No, skip\n         L     R15,@K_VolTbl_Ent_Offset Yes, get offset\n         C     R15,@K_VolTbl_Ent_Offset_Prev Same as last time?\n         JE    K00140                   Yes, skip\n\n         L     R3,@K_ISPF_Dyn_Area_Ptr  A(data for dynamic area)\n\n         L     R9,@_VolTbl_Ptr          A(Volume Table)\n         L     R10,VolTbl_Hdr_Count-VolTbl_Hdr(R9) Get nbr entries\n         AHI   R9,VolTbl_Ent-VolTbl     Point to first entry\n         USING VolTbl_Ent,R9            and assign a base\n\nK00120   DS    0H\n         TM    VolTbl_Ent_Heading_Line1,L'VolTbl_Ent_Heading_Line1\n         JO    K00130                   Heading 0, skip\n         TM    VolTbl_Ent_Heading_Line,L'VolTbl_Ent_Heading_Line\n         JZ    K00140                   Not a heading line, skip\n\n         MVC   0(VolTbl_Ent_DevType-VolTbl_Ent_Display,R3),VolTbl_Ent_D+\n               isplay\n         LA    R1,VolTbl_Ent_DevType-VolTbl_Ent_Display(0,R3)\n         LA    R15,VolTbl_Ent_Display   A(Start of source)\n         A     R15,@K_VolTbl_Ent_Offset A(Start of our data)\n         L     R14,@K_VolTbl_Ent_MVC_Len EX len of data to be moved\n         EX    R14,K_MVC                Move the data\n         A     R3,@K_ISPF_Dyn_Area_Width A(Next output area pointer)\n\nK00130   DS    0H\n         AHI   R9,VolTbl_Ent_Len        A(Next entry)\n         BRCT  R10,K00120               and continue\n\nK00140   DS    0H\n*--------------------------------------------------------------------*\n*     Calculate the address of the 1st line of data in the dynamic   *\n*    area                                                            *\n*--------------------------------------------------------------------*\n         L     R15,@K_ISPF_Dyn_Area_Hdg_Lines Nbr heading lines\n         M     R14,@K_ISPF_Dyn_Area_Width times length of line\n         A     R15,@K_ISPF_Dyn_Area_Ptr Point to  it\n         LR    R3,R15                   with the proper register\n\n*--------------------------------------------------------------------*\n*     If we are at the top of the table, insert our 'Top of Data'    *\n*    line.                                                           *\n*--------------------------------------------------------------------*\n         ICM   R15,B'1111',@K_VolTbl_Ent_Display_Line Curr display line\n         JNZ   K00150                   Not at top, skip\n\n         MVI   0(R3),C'*'               A line of asterisks\n         LR    R15,R3                   Point to it\n         LA    R1,1(0,R3)               A(Target area\n         L     R14,@K_ISPF_Dyn_Area_Width Get width\n         AHI   R14,2                    EX Length\n         EX    R14,K_MVC                All asterisks\n\n         L     R14,@K_ISPF_Dyn_Area_Width Get width\n         LA    R15,13                   Length of literal\n         SR    R14,R15                  Center our\n         SRL   R14,1                     message\n         LA    R1,0(R3,R14)             Point to start\n         S     R1,=FL4'1'                of output area\n         LA    R14,13                   Length of literal\n         AHI   R14,-1                   EX length\n         LA    R15,=CL13' Top of data ' A(Literal)\n         EX    R14,K_MVC                Move top of data text\n\n         A     R3,@K_ISPF_Dyn_Area_Width Bump output pointer\n         L     R15,@K_ISPF_Dyn_Area_Ptr Calculate\n         A     R15,@K_ISPF_Dyn_Area_Len  Dyn area max\n         CR    R3,R15                   Filled it up?\n         JNL   K00260                  Yes, go display\n\nK00150   DS    0H\n*--------------------------------------------------------------------*\n*     Point to the 1st VolTbl_Ent line to be output ...              *\n*--------------------------------------------------------------------*\n         ICM   R4,B'1111',@K_VolTbl_Ent_Display_Line Get line number\n         L     R5,=FL4'-1'              Clear entry counter\n\n         L     R15,@K_VolTbl_Hdg_Lines   Nbr hdg lines in VolTbl\n         MHI   R15,VolTbl_Ent_Len        * length of 1 entry\n\n         L     R9,@_VolTbl_Ptr          A(Volume Table)\n         L     R10,VolTbl_Hdr_Count-VolTbl_Hdr(R9) Get nbr entries\n         AHI   R9,VolTbl_Ent-VolTbl     Point to first entry\n         AR    R9,R15                   Point to our entry\n         S     R10,@K_VolTbl_Hdg_Lines  Nbr lines left in table\n         JNP   K00250                   None, skip\n\nK00170   DS    0H\n*--------------------------------------------------------------------*\n*     Find the entry (we count in R5) that corresponds to the        *\n*    entry we want (in R4)                                           *\n*--------------------------------------------------------------------*\n         TM    VolTbl_Ent_Detail_Line,L'VolTbl_Ent_Detail_Line Detail?\n         JNO   K00180                   No, skip\n         TM    @_No_Details,L'@_No_Details Yes, do we want it?\n         JO    K00240                   No, skip it\n         J     K00200                   Yes, process it\nK00180   DS    0H\n\n         TM    VolTbl_Ent_Total_Line,L'VolTbl_Ent_Total_Line Detail?\n         JNO   K00190                   No, skip\n         TM    @_No_Totals,L'@_No_Totals Yes, do we want it?\n         JO    K00240                   No, skip it\n         J     K00200                   Yes, process it\nK00190   DS    0H\n         TM    @_Statistics,L'@_Statistics Do we want stats?\n         JNO   K00240                   No, skip it\n\n         LA    R15,VolTbl_Ent           A(Table entry)\n         ST    R15,@K_Parms_V00010      Save it\n\n         LA    R1,@K_Parms              A(Parm list)\n         BRAS  R14,V00010               Go process stats line\nK00200   DS    0H\n         AHI   R5,1                     Bump counter\n         CR    R4,R5                    Ours?\n         JH    K00240                   Not yet, skip\n         TM    VolTbl_Ent_ECB,X'40'     Is it populated?\n         JO    K00210                   Yes, OK\n         WAIT  ECB=VolTbl_Ent_ECB       No, WAIT for it\n\nK00210 DS     0H\n*--------------------------------------------------------------------*\n*     Move the VolTbl_Ent data to the dynamic display area.          *\n*--------------------------------------------------------------------*\n         TM    VolTbl_Ent_Stats_Line,L'VolTbl_Ent_Stats_Line Stats?\n         JNO   K00220                   No, OK\n\n         LR    R1,R3                    A(Target area)\n         LA    R15,VolTbl_Ent_Display   A(Source)\n         S     R15,=AL4(VolTbl_Ent_DevType-VolTbl_Ent_Display)\n         A     R15,@K_VolTbl_Ent_Offset Plus offset\n         L     R14,@K_ISPF_Dyn_Area_Width Get length to move\n         AHI   R14,-1                   EX length\n         EX    R14,K_MVC                Move the data\n         J     K00230                   and skip\n\nK00220   DS    0H\n         MVC   0(VolTbl_Ent_DevType-VolTbl_Ent_Display,R3),VolTbl_Ent_D+\n               isplay\n         LA    R1,VolTbl_Ent_DevType-VolTbl_Ent_Display(0,R3) A(Target)\n         LA    R15,VolTbl_Ent_Display   A(Start of source)\n         A     R15,@K_VolTbl_Ent_Offset A(Start of our data)\n         L     R14,@K_VolTbl_Ent_MVC_Len EX len of data to be moved\n         EX    R14,K_MVC                Move the data\n\nK00230   DS    0H\n*--------------------------------------------------------------------*\n*     Bump the output pointer, and, if there is still room, ...      *\n*--------------------------------------------------------------------*\n         A     R3,@K_ISPF_Dyn_Area_Width Bump output pointer\n         L     R15,@K_ISPF_Dyn_Area_Ptr Calculate\n         A     R15,@K_ISPF_Dyn_Area_Len  Dyn area max\n         CR    R3,R15                   Filled it up?\n         JNL   K00260                  Yes, go display\n\nK00240   DS    0H\n*--------------------------------------------------------------------*\n*     ... process the next entry                                     *\n*--------------------------------------------------------------------*\n         AHI   R9,VolTbl_Ent_Len        A(Next entry)\n         BRCT  R10,K00170               and continue\n\nK00250   DS    0H\n*--------------------------------------------------------------------*\n*     Add our 'Bottom of data' line.                                 *\n*--------------------------------------------------------------------*\n         MVI   0(R3),C'*'               A line of asterisks\n         LR    R15,R3                   Point to it\n         LA    R1,1(0,R3)               A(Target area\n         L     R14,@K_ISPF_Dyn_Area_Width Get width\n         AHI   R14,-2                   EX len\n         EX    R14,K_MVC                All asterisks\n\n         L     R14,@K_ISPF_Dyn_Area_Width Get width\n         LA    R15,16                   Length of literal\n         SR    R14,R15                  Center our\n         SRL   R14,1                     message\n         LA    R1,0(R3,R14)             Point to start\n         S     R1,=FL4'1'                of output area\n         LA    R14,16                   Length of literal\n         AHI   R14,-1                   EX length\n         LA    R15,=CL16' Bottom of data ' A(Literal)\n         EX    R14,K_MVC                Move bottom of data text\n\n*--------------------------------------------------------------------*\n*     And clear out the rest of the display area                     *\n*--------------------------------------------------------------------*\n         A     R3,@K_ISPF_Dyn_Area_Width Bump output pointer\n         L     R15,@K_ISPF_Dyn_Area_Ptr Calculate\n         A     R15,@K_ISPF_Dyn_Area_Len  Dyn area max\n         CR    R3,R15                   Filled it up?\n         JNL   K00260                  Yes, go display\n\n         LR    R0,R3                    No, A(Start of area to clear)\n         LR    R1,R15                   Calculate length\n         SR    R1,R0                     to clear\n         LA    R14,0                    No sending address\n         LA    R15,C' '                 Pad character\n         SLL   R15,24                    of blank\n         MVCL  R0,R14                   Clear remainder if dynamic area\n\nK00260   DS    0H\n*--------------------------------------------------------------------*\n*     Save the current start line and offset ...                     *\n*--------------------------------------------------------------------*\n         MVC   @K_VolTbl_Ent_Display_Line_Prev,@K_VolTbl_Ent_Display_Li+\n               ne\n         MVC   @K_VolTbl_Ent_Offset_Prev,@K_VolTbl_Ent_Offset\n\n*--------------------------------------------------------------------*\n*     ... fill in the variable containing the 1st line number ...    *\n*--------------------------------------------------------------------*\n         L     R15,@K_VolTbl_Ent_Display_Line Get FLIN\n         AHI   R15,1                    Relative to 1\n         CVD   R15,@K_DBLWD             Pack it\n         MVC   @K_FLIN-1(L'@K_FLIN+1),=X'402020202120'  Move mask\n         ED    @K_FLIN-1(L'@K_FLIN+1),@K_DBLWD+5\n\n*--------------------------------------------------------------------*\n*     ... and display our panel                                      *\n*--------------------------------------------------------------------*\n         LA    R15,=CL8'DISPLAY'        ISPF Function\n         ST    R15,@K_ISPF_Parms        Save it\n         LA    R15,=CL8'&PNLNAME'       A(Panel name)\n         ST    R15,@K_ISPF_Parms+4      Save it\n         OI    @K_ISPF_Parms+4,X'80'    Flag last parm\n         LA    R1,@K_ISPF_Parms         A(ISPF Parms)\n         L     R15,@_ISPLINK            A(ISPF routine)\n         BASR  R14,R15                  Go display table\n         CHI   R15,8                    END or RETURN?\n         JNL   K00720                   Yes, just get out\n\n*--------------------------------------------------------------------*\n*     If the user entered CANCEL, we are done.                       *\n*--------------------------------------------------------------------*\n         LA    R15,=CL8'VCOPY'          ISPF Function\n         ST    R15,@K_ISPF_Parms        Save it\n         LA    R15,=CL8'ZCMD'           Variable we want\n         ST    R15,@K_ISPF_Parms+4      Save it\n         LA    R15,@K_ISPF_VCOPY_Lens   A(Length Address)\n         ST    R15,@K_ISPF_Parms+8      Save it\n         LA    R15,@K_ISPF_VCOPY_Ptrs   A(Variable)\n         ST    R15,@K_ISPF_Parms+12     Save it\n         OI    @K_ISPF_Parms+12,X'80'   Flag last parm\n         LA    R1,@K_ISPF_Parms         A(ISPF Parms)\n         L     R15,@_ISPLINK            A(ISPF routine)\n         BASR  R14,R15                  Go get the variable\n\n         LTR   R15,R15                  Did we get it?\n         JNZ   K00300                   No, skip check for CANCEL\n\n         ICM   R14,B'1111',@K_ISPF_VCOPY_Var_Len Get ZCMD length\n         JZ    K00300                   Nothing, skip\n         CHI   R14,3                    Could it be CANcel?\n         JL    K00270                   No, skip\n         CHI   R14,6                    Maybe, check again\n         JH    K00270                   Not CANCEL, skip\n         ICM   R15,B'1111',@K_ISPF_VCOPY_Var_Ptr A(ZCMD)\n         JZ    K00300                   Nothing, skip\n         LA    R1,@K_DBLWD              A(Work area)\n         AHI   R14,-1                   EX Len\n         EX    R14,K_MVC                Move to work area\n         OC    @K_DBLWD,=CL8' '         Uppercase it\n         EX    R14,K_CLC1               Check it out\n         JE    K00720                   CANCEL, just exit\n\nK00270   DS    0H\n*--------------------------------------------------------------------*\n*     Check out what happened. First check the command for something *\n*    we recognize ...                                                *\n*--------------------------------------------------------------------*\n         LA    R1,@K_Parms              A(Parm list)\n         BRAS  R14,L00010               Check out command\n\n         TM    @_ReDisplay,L'@_ReDisplay Change display mode?\n         JO    K00280                   Yes, skip\n         LTR   R15,R15                  No, did it work?\n         JNZ   K00700                   No, unknown command\n         J     K00290                   Unknown command, skip\n\nK00280   DS    0H\n         LA    R15,=CL8'VDEFINE'        ISPF Function\n         ST    R15,@K_ISPF_Parms        Save it\n         LA    R15,=CL8'ZCMD'           Variable name\n         ST    R15,@K_ISPF_Parms+4      Save it\n         LA    R15,K_Blanks             A(blank string)\n         ST    R15,@K_ISPF_Parms+8      Save it\n         LA    R15,=CL8'CHAR'           Character variables\n         ST    R15,@K_ISPF_Parms+12     Save it\n         LA    R15,=AL4(L'K_Blanks)     Length of blank string\n         ST    R15,@K_ISPF_Parms+16     Save it\n         OI    @K_ISPF_Parms+16,X'80'   Flag end of list\n         LA    R1,@K_ISPF_Parms         A(Parmlist)\n         L     R15,@_ISPLINK            A(ISPF Interface)\n         BASR  R14,R15                  Go do it\n\n         LA    R15,=CL8'VPUT'           ISPF Function\n         ST    R15,@K_ISPF_Parms        Save it\n         LA    R15,=CL8'ZCMD'           A(Variable name)\n         ST    R15,@K_ISPF_Parms+4      Save it\n         LA    R15,=CL8'ASIS'           A(Variable name)\n         ST    R15,@K_ISPF_Parms+8      Save it\n         OI    @K_ISPF_Parms+8,X'80'    Flag end of list\n         LA    R1,@K_ISPF_Parms         A(Parmlist)\n         L     R15,@_ISPLINK            A(ISPF Interface)\n         BASR  R14,R15                  Go do it\n\n         LHI   R15,20                   Change display mode, set rc\n         J     K90010                   and exit\n\nK00290   DS    0H\n*--------------------------------------------------------------------*\n*     We have processed the command, so clear ZCMD ...               *\n*--------------------------------------------------------------------*\n         LA    R15,=CL8'VREPLACE'       ISPF Function\n         ST    R15,@K_ISPF_Parms        Save it\n         LA    R15,=CL8'ZCMD'           Variable name\n         ST    R15,@K_ISPF_Parms+4      Save it\n         LA    R15,=AL4(0)              Length of variable\n         ST    R15,@K_ISPF_Parms+8      Save it\n         LA    R15,0                    Null value\n         ST    R15,@K_ISPF_Parms+12     Save it\n         OI    @K_ISPF_Parms+12,X'80'   Flag end of list\n         LA    R1,@K_ISPF_Parms         A(Parmlist)\n         L     R15,@_ISPLINK            A(ISPF Interface)\n         BASR  R14,R15                  Go do it\n\n*--------------------------------------------------------------------*\n*     ... and force a refresh of the table display area.             *\n*--------------------------------------------------------------------*\n         MVC   @K_VolTbl_Ent_Display_Line_Prev,=FL4'-1' Force tbl refr\n\nK00300   DS    0H\n*--------------------------------------------------------------------*\n*     Check for scroll request:                                      *\n*       ZVERB    = UP, DOWN, LEFT, or RIGHT                          *\n*       ZSCROLLN = scroll amount                                     *\n*       ZSCROLLA = PAGE, CSR, MAX, etc.                              *\n*--------------------------------------------------------------------*\n         LA    R15,=CL8'VCOPY'          ISPF Function\n         ST    R15,@K_ISPF_Parms        Save it\n         LA    R15,K_ISPF_VCOPY_Scroll_Names   A(Variable Names)\n         ST    R15,@K_ISPF_Parms+4      Save it\n         LA    R15,@K_ISPF_VCOPY_Scroll_Lens   A(Lengths)\n         ST    R15,@K_ISPF_Parms+8      Save it\n         LA    R15,@K_ISPF_VCOPY_Scroll_Ptrs   A(Addresses)\n         ST    R15,@K_ISPF_Parms+12     Save it\n         OI    @K_ISPF_Parms+12,X'80'   Flag last parm\n         LA    R1,@K_ISPF_Parms         A(ISPF Parms)\n         L     R15,@_ISPLINK            A(ISPF routine)\n         BASR  R14,R15                  Go get variables\n\n         CHI   R15,8                    Did we get any?\n         JH    K00710                   No, just re-display\n\n         NI    @K_Scroll_UP,X'FF'-L'@K_Scroll_UP  Off our flag\n         NI    @K_Scroll_DOWN,X'FF'-L'@K_Scroll_DOWN  Off our flag\n         NI    @K_Scroll_LEFT,X'FF'-L'@K_Scroll_LEFT  Off our flag\n         NI    @K_Scroll_RIGHT,X'FF'-L'@K_Scroll_RIGHT  Off our flag\n         NI    @K_Scroll_MAX,X'FF'-L'@K_Scroll_MAX  Off our flag\n\n         ICM   R14,B'1111',@K_ISPF_VCOPY_ZVERB_Len Len of ZVERB\n         JZ    K00500                   Nothing, go check expand\n         ICM   R15,B'1111',@K_ISPF_VCOPY_ZVERB_Ptr A(ZVERB)\n         JZ    K00500                   Nothing, check expand\n\n         CHI   R14,2                    Could it be UP?\n         JNE   K00310                   No, skip\n         CLC   =C'UP',0(R15)            Could be, is it?\n         JNE   K00710                   No, ignore it\n         OI    @K_Scroll_UP,L'@K_Scroll_UP  Yes, say so\n         J     K00340                   and check ZSCROLLN\nK00310   DS    0H\n\n         CHI   R14,4                    Could it be DOWN or LEFT?\n         JNE   K00330                   No, skip\n         CLC   =C'DOWN',0(R15)          Could be, is it DOWN?\n         JNE   K00320                   No, go check LEFT\n         OI    @K_Scroll_DOWN,L'@K_Scroll_DOWN  Yes, say so\n         J     K00340                   and check ZSCROLLN\nK00320   DS    0H\n         CLC   =C'LEFT',0(R15)          Is it LEFT?\n         JNE   K00710                   No, ignore it\n         OI    @K_Scroll_LEFT,L'@K_Scroll_LEFT  Yes, say so\n         J     K00340                   and check ZSCROLLN\nK00330   DS    0H\n         CHI   R14,5                    Could it be RIGHT?\n         JNE   K00710                   No, ignore it\n         CLC   =C'RIGHT',0(R15)         Could be, is it?\n         JNE   K00710                   No, ignore it\n         OI    @K_Scroll_RIGHT,L'@K_Scroll_RIGHT  Yes, say so\n         J     K00340                   and check ZSCROLLN\n\nK00340   DS    0H\n*--------------------------------------------------------------------*\n*     We have a scroll command, check ZSCROLLA for MAX               *\n*--------------------------------------------------------------------*\n         ICM   R14,B'1111',@K_ISPF_VCOPY_ZSCROLLA_Len Len of ZSCROLLA\n         JZ    K00350                   Nothing, check ZSCROLLN\n         CHI   R14,3                    Could it be MAX?\n         JNE   K00350                   No, check ZSCROLLN\n         ICM   R1,B'1111',@K_ISPF_VCOPY_ZSCROLLA_Ptr A(ZSCROLLA)\n         JZ    K00350                   Nothing, check ZSCROLLN\n         CLC   =C'MAX',0(R1)            Is it MAX?\n         JNE   K00350                   No, skip\n         OI    @K_Scroll_MAX,L'@K_Scroll_MAX Yes, set our flag\n\nK00350   DS    0H\n*--------------------------------------------------------------------*\n*     Set a flag if the user entered an explicit scroll amount       *\n*    (eg, DOWN 16). We can determine this if ZSCROLLN = ZSCROLLA     *\n*--------------------------------------------------------------------*\n         NI    @K_Scroll_Explicit,X'FF'-L'@K_Scroll_Explicit\n         ICM   R15,B'1111',@K_ISPF_VCOPY_ZSCROLLN_Len ZSCROLLN Length\n         JZ    K00360                   Nothing, skip\n         C     R15,@K_ISPF_VCOPY_ZSCROLLA_Len Same as ZSCROLLA?\n         JNE   K00360                   No, skip\n         ICM   R14,B'1111',@K_ISPF_VCOPY_ZSCROLLN_Ptr Yes, A(ZSCROLLN)\n         JZ    K00360                   Nothing, skip\n         ICM   R1,B'1111',@K_ISPF_VCOPY_ZSCROLLA_Ptr A(ZSCROLLA)\n         JZ    K00360                   Nothing, skip\n         AHI   R15,-1                   EX length\n         EX    R15,K_CLC                Same value?\n         JNE   K00360                   No, skip\n         OI    @K_Scroll_Explicit,L'@K_Scroll_Explicit Yes, set flag\n\nK00360   DS    0H\n*--------------------------------------------------------------------*\n*     Get ZSCROLLN (defaulting to 0 )                                *\n*--------------------------------------------------------------------*\n         LA    R15,0                    Set our default\n\n         ICM   R14,B'1111',@K_ISPF_VCOPY_ZSCROLLN_Len Len of ZSCROLLN\n         JZ    K00370                   Nothing, just re-display\n         ICM   R1,B'1111',@K_ISPF_VCOPY_ZSCROLLN_Ptr A(ZSCROLLN)\n         JZ    K00370                   Nothing, ignore it\n         AHI   R14,-1                   EX len\n         EX    R14,K_PACK               Pack it\n         CVB   R15,@K_DBLWD             Binarize it\n\nK00370   DS    0H\n         TM    @K_Scroll_RIGHT,L'@K_Scroll_RIGHT  Horizontal?\n         JO    K00430                   Yes, skip\n         TM    @K_Scroll_LEFT,L'@K_Scroll_LEFT No, check again\n         JO    K00460                   Yes, skip\n         TM    @K_Scroll_DOWN,L'@K_Scroll_DOWN No, scroll DOWN?\n         JO    K00390                   Yes, skip\n\n*--------------------------------------------------------------------*\n*     Scroll UP                                                      *\n*--------------------------------------------------------------------*\n         TM    @K_Scroll_MAX,L'@K_Scroll_MAX  UP MAX?\n         JO    K00380                   Yes, set to top\n         L     R14,@K_VolTbl_Ent_Display_Line Get current line number\n         SR    R14,R15                  Back up the scroll amount\n         TM    @K_Scroll_Explicit,L'@K_Scroll_Explicit Explicit nbr?\n         JO    K00420                   Yes, all done\n*        A     R14,@K_ISPF_Dyn_Area_Hdg_Lines No, adjust for headings\n         J     K00420                   and skip\nK00380   DS    0H\n         LA    R14,0                    UP MAX, reset line number\n         J     K00420                   and skip\n\nK00390   DS    0H\n*--------------------------------------------------------------------*\n*     Scroll DOWN                                                    *\n*--------------------------------------------------------------------*\n         TM    @K_Scroll_MAX,L'@K_Scroll_MAX  DOWN MAX?\n         JO    K00400                   Yes, skip\n         ICM   R14,B'1111',@K_VolTbl_Ent_Display_Line No, curr line nbr\n         JP    K00390C                  OK, skip\n         AHI   R14,-1                   Account for Top of Data line\nK00390C  DS    0H\n         AR    R14,R15                  Line number\n         TM    @K_Scroll_Explicit,L'@K_Scroll_Explicit Explicit nbr?\n         JO    K00420                   Yes, all done\n         S     R14,@K_ISPF_Dyn_Area_Hdg_Lines No, adjust for headings\n         J     K00420                   and skip\n\nK00400   DS    0H\n*--------------------------------------------------------------------*\n*     Scroll DOWN MAX - get the last visible line, and use it        *\n*    instead of @K_ISPF_Dyn_Area_Depth                               *\n*--------------------------------------------------------------------*\n         LA    R15,=CL8'VCOPY'          ISPF Function\n         ST    R15,@K_ISPF_Parms        Save it\n         LA    R15,=CL8'SSCSPCLV'       A(Variable Names)\n         ST    R15,@K_ISPF_Parms+4      Save it\n         LA    R15,@K_ISPF_VCOPY_Lens   A(Lengths)\n         ST    R15,@K_ISPF_Parms+8      Save it\n         LA    R15,@K_ISPF_VCOPY_Ptrs   A(Addresses)\n         ST    R15,@K_ISPF_Parms+12     Save it\n         OI    @K_ISPF_Parms+12,X'80'   Flag last parm\n         LA    R1,@K_ISPF_Parms         A(ISPF Parms)\n         L     R15,@_ISPLINK            A(ISPF routine)\n         BASR  R14,R15                  Go display table\n\n         L     R0,@K_ISPF_Dyn_Area_Depth Init our depth\n         LTR   R15,R15                  Did it work?\n         JNZ   K00410                   No, skip\n\n         ICM   R14,B'1111',@K_ISPF_VCOPY_Var_Len Len of SSCSPCLV\n         JZ    K00410                   Nothing, skip\n         ICM   R1,B'1111',@K_ISPF_VCOPY_Var_Ptr A(SSCSPCLV)\n         JZ    K00410                   Nothing, ignore it\n         AHI   R14,-1                   EX len\n         EX    R14,K_PACK               Pack it\n         CVB   R0,@K_DBLWD              Binarize it\nK00410   DS    0H\n         L     R14,@K_VolTbl_Ent_Display_Line_Max Get max display line\n         SR    R14,R0                   Back up a screen\n         A     R14,@K_ISPF_Dyn_Area_Hdg_Lines Adjust for heading lines\n         AHI   R14,1                    Make Bottom of Data visible\n         J     K00420                   and skip\n\nK00420   DS    0H\n*--------------------------------------------------------------------*\n*     Vertical Scroll, save updated line number, and skip            *\n*--------------------------------------------------------------------*\n         ST    R14,@K_VolTbl_Ent_Display_Line Save new line number\n         J     K00710                   Go re-display\n\nK00430   DS    0H\n*--------------------------------------------------------------------*\n*     Scroll RIGHT                                                   *\n*--------------------------------------------------------------------*\n         TM    @K_Scroll_Max,L'@K_Scroll_Max  RIGHT MAX?\n         JNO   K00440                   No, skip\n         L     R14,@K_VolTbl_Ent_Offset_Max Yes, get max offset\n         J     K00490                   and skip\nK00440   DS    0H\n         TM    @K_Scroll_Explicit,L'@K_Scroll_Explicit Explicit nbr?\n         JO    K00450                   Yes, skip\n         S     R15,=AL4(VolTbl_Ent_DevType-VolTbl_Ent_Display) Adj scrl\n         JP    K00450                   OK, skip\n         L     R15,@K_ISPF_Dyn_Area_Width cursor in non-scroll area,\n         S     R15,=AL4(VolTbl_Ent_DevType-VolTbl_Ent_Display) Width\nK00450   DS    0H\n         L     R14,@K_VolTbl_Ent_Offset Get current offset\n         AR    R14,R15                  Adjust offset\n         J     K00490                   and skip\n\nK00460   DS    0H\n*--------------------------------------------------------------------*\n*     Scroll LEFT                                                    *\n*--------------------------------------------------------------------*\n         TM    @K_Scroll_Max,L'@K_Scroll_Max  LEFT MAX?\n         JO    K00480                   Yes, skip\n\n         TM    @K_Scroll_Explicit,L'@K_Scroll_Explicit Explicit nbr?\n         JO    K00470                   Yes, skip\n         L     R0,@K_ISPF_Dyn_Area_Width Get width of\n         S     R0,=AL4(VolTbl_Ent_DevType-VolTbl_Ent_Display) scrl area\n         CR    R15,R0                   Too far left?\n         JNH   K00470                   No, OK\n         LR    R15,R0                   Yes, set to 1 screens worth\nK00470   DS    0H\n         L     R14,@K_VolTbl_Ent_Offset Get current offset\n         SR    R14,R15                  Adjust it\n         J     K00490                   and skip\nK00480   DS    0H\n         L     R14,=AL4(VolTbl_Ent_DevType-VolTbl_Ent_Display) Set min\n\nK00490   DS    0H\n*--------------------------------------------------------------------*\n*     Horizontal scroll - save new offset                            *\n*--------------------------------------------------------------------*\n         ST    R14,@K_VolTbl_Ent_Offset Yes, save new offset\n         J     K00710                   and redisplay\n\nK00500   DS    0H\n*--------------------------------------------------------------------*\n*     Not a scroll command -  see if the cursor is in the DATA       *\n*    field, and on a numeric field. If so, the value of the field is *\n*    displayed. This will allow the user to see the actual values    *\n*    for fields we have scaled to fit in our display.                *\n*                                                                    *\n*    Get ZSCREENW (screen width)                                     *\n*        ZSCREENC (cursor position ((row# * ZSCREENW) + col#)))      *\n*--------------------------------------------------------------------*\n         LA    R15,=CL8'VCOPY'          ISPF Function\n         ST    R15,@K_ISPF_Parms        Save it\n         LA    R15,K_ISPF_VCOPY_Cursor_Names   A(Variable Names)\n         ST    R15,@K_ISPF_Parms+4      Save it\n         LA    R15,@K_ISPF_VCOPY_Cursor_Lens   A(Lengths)\n         ST    R15,@K_ISPF_Parms+8      Save it\n         LA    R15,@K_ISPF_VCOPY_Cursor_Ptrs   A(Addresses)\n         ST    R15,@K_ISPF_Parms+12     Save it\n         OI    @K_ISPF_Parms+12,X'80'   Flag last parm\n         LA    R1,@K_ISPF_Parms         A(ISPF Parms)\n         L     R15,@_ISPLINK            A(ISPF routine)\n         BASR  R14,R15                  Go get variables\n\n         LTR   R15,R15                  Did we?\n         JNZ   K00710                   No, just re-display\n\n*--------------------------------------------------------------------*\n*     Get the cursor row and column (on the screen) ...              *\n*--------------------------------------------------------------------*\n         ICM   R15,B'1111',@K_ISPF_ZSCREENC_Len Get ZSCREENC length\n         JNP   K00710                   Nothing, just re-display\n         AHI   R15,-1                   EX length\n         ICM   R1,B'1111',@K_ISPF_ZSCREENC_Ptr Get A(ZSCREENC)\n         JZ    K00710                   Nothing, just re-display\n         EX    R15,K_PACK               PACK it\n         CVB   R15,@K_DBLWD             Cursor position in screen\n\n         ICM   R14,B'1111',@K_ISPF_ZSCREENW_Len Get ZSCREENW length\n         JZ    K00710                   Nothing, just re-display\n         ICM   R1,B'1111',@K_ISPF_ZSCREENW_Ptr Get A(ZSCREENW)\n         JZ    K00710                   Nothing, just re-display\n         AHI   R14,-1                   EX length\n         EX    R14,K_PACK               PACK it\n         CVB   R1,@K_DBLWD              Screen width\n\n         LA    R14,0                    Clear high-order register\n         DR    R14,R1                   R14: Col, R15: Row\n\n*--------------------------------------------------------------------*\n*     ... and see if it is within the DATA field                     *\n*--------------------------------------------------------------------*\n         S     R15,@K_ISPF_Dyn_Area_Row  Relative row in DATA\n         JM    K00710                   Before start of DATA, exit\n         C     R15,@K_ISPF_Dyn_Area_Depth Really within DATA?\n         JNL   K00710                   No, just redisplay\n\n         S     R14,@K_ISPF_Dyn_Area_Column Relative column of DATA\n         JM    K00710                   To the left of DATA, exit\n         C     R0,@K_ISPF_Dyn_Area_Width Really within DATA?\n         JNL   K00710                   No, just redisplay\n\n         S     R15,@K_ISPF_Dyn_Area_Hdg_Lines minus heading lines\n         JM    K00710                   Cursor on a heading line\n         ICM   R4,B'1111',@K_VolTbl_Ent_Display_Line Get line number\n         JNZ   K00510                   Not 0, OK\n         AHI   R15,-1                   Adjust for 'Top of Data'\n         JM    K00710                   Cursor on 'Top of Data'\nK00510   DS    0H\n         AR    R4,R15                   R4 = Cursor row\n         L     R5,=FL4'-1'              Clear entry counter\n\n         L     R9,@_VolTbl_Ptr          A(Volume Table)\n         L     R10,VolTbl_Hdr_Count-VolTbl_Hdr(R9) Get nbr entries\n         AHI   R9,VolTbl_Ent-VolTbl     Point to first entry\n\nK00520   DS    0H\n*--------------------------------------------------------------------*\n*     Find the entry (we count in R5) that corresponds to the        *\n*    entry we want (in R4)                                           *\n*--------------------------------------------------------------------*\n         TM    VolTbl_Ent_Detail_Line,L'VolTbl_Ent_Detail_Line Detail?\n         JNO   K00530                   No, skip\n         TM    @_No_Details,L'@_No_Details Yes, do we want it?\n         JO    K00550                   No, skip it\n         J     K00540                   Yes, count it\nK00530   DS    0H\n         TM    VolTbl_Ent_Total_Line,L'VolTbl_Ent_Total_Line Total?\n         JNO   K00550                   No, skip it\n         TM    @_No_Totals,L'@_No_Totals Yes, do we want it?\n         JO    K00550                   No, skip it\nK00540   DS    0H\n         AHI   R5,1                     Bump counter\n         CR    R4,R5                    Ours?\n         JNH   K00560                   Yup, skip\nK00550   DS    0H\n         AHI   R9,VolTbl_Ent_Len        A(Next entry)\n         BRCT  R10,K00520               and continue\n         J     K00710                   Not on a row, ignore it\n\nK00560   DS    0H\n         TM    VolTbl_Ent_SMS_Line,L'VolTbl_Ent_SMS_Line Anomaly msg?\n         JO    K00710                   Yes, ignore it\n\n         TM    VolTbl_Ent_LSPACE_Fail,L'VolTbl_Ent_LSPACE_Fail Data?\n         JO    K00710                   No, ignore it\n\n*--------------------------------------------------------------------*\n*     It looks like the cursor is on a line in our table - see if    *\n*    it is also within a numeric field                               *\n*--------------------------------------------------------------------*\n         C     R14,=AL4(VolTbl_Ent_DevType-VolTbl_Ent_Display)\n         JL    K00710                   Cursor in line prefix\n\n         A     R14,@K_VolTbl_Ent_Offset  Get offset within VolTbl_Ent\n         S     R14,=AL4(VolTbl_Ent_DevType-VolTbl_Ent_Display)\n         LA    R15,K_Expand_Tbl         A(Table of offsets)\nK00570   DS    0H\n         CH    R14,0(0,R15)             Our field?\n         JL    K00580                   No, skip\n         CH    R14,2(0,R15)             Maybe, is it?\n         JNH   K00590                   Yes, skip\nK00580   DS    0H\n         AHI   R15,K_Expand_Ent_Len     Bump our pointer\n         CLC   =HL2'0',0(R15)           End of table?\n         JNE   K00570                   No, keep checking\n         J     K00710                   Yes, just redisplay\nK00590   DS    0H\n         LH    R14,4(0,R15)             Offset of FP field\n         LD    R2,VolTbl_Ent(R14)       Get floating point value\n*--------------------------------------------------------------------*\n*     If this is a percent (length of output area = 4), and thus the *\n*    only type of field with fractions) ...                          *\n*--------------------------------------------------------------------*\n         LH    R0,2(0,R15)              A(End of output field) + 1\n         SH    R0,0(0,R15)              Less A(Start of output field)\n         CHI   R0,4                     Is this a percent?\n         JNE   K00630                   No, skip\n\n*--------------------------------------------------------------------*\n*     ... format it                                                  *\n*--------------------------------------------------------------------*\n         MDB   R2,=DBL8'10000000000000' 13-digit fraction\n         CGDBR R0,B'0101',R2            Convert to fixed, round to 0\n         CVDG  R0,@K_QuadWord           Pack it\n         MVC   @K_Expand_Number(17),=X'4021204B202020202020202020202020+\n               20'                      Move mask\n         LA    R1,@K_Expand_Number+2    A(Start of significance)\n         EDMK  @K_Expand_Number(17),@K_QuadWord+8 Unpack it\n         ST    R1,@K_Expand_NumStart    Save A(Start of number)\n         LA    R1,@K_Expand_Number+16   A(last possible 0\nK00600   DS    0H\n         CLI   0(R1),C'0'               Trailing 0?\n         JNE   K00610                   No, found the end\n         BRCT  R1,K00600                Yes, check prev byte\nK00610   DS    0H\n         CLI   0(R1),C'.'               Back to the decimal point?\n         JNE   K00620                   No, OK\n         AHI   R1,2                     Yes, set to 2 decimal places\nK00620   DS    0H\n         ST    R1,@K_Expand_NumEnd      Save A(end of number)\n         J     K00670                   and skip\n\nK00630   DS    0H\n*--------------------------------------------------------------------*\n*     Not a percent, we don't have to worry about decimal points.    *\n*    Format it in 2 groups of 15 decimal digits (max for ED/UNPK),   *\n*    unintuitively doing the rightmost group first.                  *\n*--------------------------------------------------------------------*\n         CGDBR R0,B'0101',R2            Convert to fixed, round to 0\n         CVDG  R0,@K_QuadWord           Pack it\n         LA    R15,@K_Expand_Number+L'@K_Expand_Number A(End of output)\nK00640   DS    0H\n         AHI   R15,-20                  Move mask\n         MVC   0(20,R15),=X'402020206B2020206B2020206B2020206B202120'\n         LG    R0,@K_QuadWord           Get high dblwd\n         LTGR  R0,R0                    Anything in it?\n         JZ    K00650                   No, OK\n         MVI   1(R15),X'21'             Yes, turn on significance\nK00650   DS    0H\n         LA    R1,19(0,R15)             Init A(1st significant field)\n         EDMK  0(20,R15),@K_QuadWord+8  Edit in data\n         LG    R0,@K_QuadWord           Get high dblwd\n         LTGR  R0,R0                    Anything in it?\n         JZ    K00660                   No, all done\n         SLLG  R0,R0,4                  Yes, make room for sign\n         STG   R0,@K_QuadWord+8         Save it\n         OI    @K_Quadword+15,X'0F'     Set sign\n         SLG   R0,R0                    and clear\n         STG   R0,@K_QuadWord             high dblwd\n         MVI   0(R15),C','              Move separator\n         CLI   1(R15),C' '              Significant 0 missed?\n         JNE   K00640                   No, OK\n         MVI   1(R15),C'0'              Yes, set it\n         J     K00640                   Go process it\nK00660   DS    0H\n         ST    R1,@K_Expand_NumStart    Save start of significance\n         LA    R1,@K_Expand_Number+L'@K_Expand_Number-1 A(End)\n         ST    R1,@K_Expand_NumEnd      Save it\n\nK00670   DS    0H\n*--------------------------------------------------------------------*\n*     Set up the SMSG ...                                            *\n*--------------------------------------------------------------------*\n         MVI   @K_Expand_ZEDSMSG,C' '\n         MVC   @K_Expand_ZEDSMSG+1(L'@K_Expand_ZEDSMSG-1),@K_Expand_ZED+\n               SMSG\n         L     R1,@K_Expand_NumStart    A(Start of number)\n         L     R15,@K_Expand_NumEnd     A(End)\n         SR    R15,R1                   Get EX length of number\n         CHI   R15,L'@K_Expand_ZEDSMSG  Too long for SMSG?\n         JL    K00680                   No, OK\n         LA    R1,=C'>>>>>>>>'          Yes, Indicate number too big\n         LA    R15,7                    EX Length\nK00680   DS    0H\n         LA    R14,@K_Expand_ZEDSMSG    A(SMSG)\n         EX    R15,K_K00680_MVC         MVC   0(0,R14),0(R1)\n         LA    R0,1(0,R15)              Real length\n         ST    R0,@K_Expand_ZEDSMSG_Len Save it\n\n*--------------------------------------------------------------------*\n*     ... and LMSG                                                   *\n*--------------------------------------------------------------------*\n         MVC   @K_Expand_ZEDLMSG(L'K_Expand_ZEDLMSG_Pfx),K_Expand_ZEDLM+\n               SG_Pfx\n         LA    R14,@K_Expand_ZEDLMSG+L'K_Expand_ZEDLMSG_Pfx\n         L     R1,@K_Expand_NumStart    A(Source)\n         L     R15,@K_Expand_NumEnd     Calculate\n         SR    R15,R1                    length\n         EX    R15,K_K00680_MVC         MVC   0(0,R14),0(R1)\n         AHI   R15,L'K_Expand_ZEDLMSG_Pfx+1 Len of LMSG\n         ST    R15,@K_Expand_ZEDLMSG_Len Save it\n\n*--------------------------------------------------------------------*\n*     Tell ISPF about the messages, and re-display                   *\n*--------------------------------------------------------------------*\n         LA    R15,=CL8'VDEFINE'        ISPF Function\n         ST    R15,@K_ISPF_Parms        Save it\n         LA    R15,=CL8'CHAR'           Character variables\n         ST    R15,@K_ISPF_Parms+12     Save it\n\n         LA    R15,=CL8'ZEDSMSG'        Variable name\n         ST    R15,@K_ISPF_Parms+4      Save it\n         LA    R15,@K_Expand_ZEDSMSG    A(Short Message)\n         ST    R15,@K_ISPF_Parms+8      Save it\n         LA    R15,@K_Expand_ZEDSMSG_Len Length of message\n         ST    R15,@K_ISPF_Parms+16     Save it\n         OI    @K_ISPF_Parms+16,X'80'   Flag end of list\n         LA    R1,@K_ISPF_Parms         A(Parmlist)\n         L     R15,@_ISPLINK            A(ISPF Interface)\n         BASR  R14,R15                  Go do it\n\n         LA    R15,=CL8'ZEDLMSG'        Variable name\n         ST    R15,@K_ISPF_Parms+4      Save it\n         LA    R15,@K_Expand_ZEDLMSG    A(Long message)\n         ST    R15,@K_ISPF_Parms+8      Save it\n         LA    R15,@K_Expand_ZEDLMSG_Len Length of message\n         ST    R15,@K_ISPF_Parms+16     Save it\n         OI    @K_ISPF_Parms+16,X'80'   Flag end of list\n         LA    R1,@K_ISPF_Parms         A(Parmlist)\n         L     R15,@_ISPLINK            A(ISPF Interface)\n         BASR  R14,R15                  Go do it\n\n         LA    R15,=CL8'SETMSG'         Yes, ISPF Function\n         ST    R15,@K_ISPF_Parms        Save it\n         LA    R15,=CL8'ISRZ001'        A(Message ID)\n         ST    R15,@K_ISPF_Parms+4      Save it\n         OI    @K_ISPF_Parms+4,X'80'    Mark end of list\n         LA    R1,@K_ISPF_Parms         Point to ISPF parms\n         L     R15,@_ISPLINK            A(Interface routine)\n         BASR  R14,R15                  Go do it\n\n         J     K00710                   And redisplay\n\nK00700   DS    0H\n*--------------------------------------------------------------------*\n*     Unrecognized ZCMD - Issue messages ...                         *\n*--------------------------------------------------------------------*\n         LA    R15,=CL8'VDEFINE'        ISPF Function\n         ST    R15,@K_ISPF_Parms        Save it\n         LA    R15,=CL8'CHAR'           Character variables\n         ST    R15,@K_ISPF_Parms+12     Save it\n\n         LA    R15,=CL8'ZEDSMSG'        Variable name\n         ST    R15,@K_ISPF_Parms+4      Save it\n         LA    R15,K_Bad_ZCMD_SMsg      A(Short Message)\n         ST    R15,@K_ISPF_Parms+8      Save it\n         LA    R15,=AL4(L'K_Bad_ZCMD_SMsg) Length of variable\n         ST    R15,@K_ISPF_Parms+16     Save it\n         OI    @K_ISPF_Parms+16,X'80'   Flag end of list\n         LA    R1,@K_ISPF_Parms         A(Parmlist)\n         L     R15,@_ISPLINK            A(ISPF Interface)\n         BASR  R14,R15                  Go do it\n\n         LA    R15,=CL8'ZEDLMSG'        Variable name\n         ST    R15,@K_ISPF_Parms+4      Save it\n         LA    R15,K_Bad_ZCMD_LMsg      A(Long message)\n         ST    R15,@K_ISPF_Parms+8      Save it\n         LA    R15,=AL4(L'K_Bad_ZCMD_LMsg) Length of message\n         ST    R15,@K_ISPF_Parms+16     Save it\n         OI    @K_ISPF_Parms+16,X'80'   Flag end of list\n         LA    R1,@K_ISPF_Parms         A(Parmlist)\n         L     R15,@_ISPLINK            A(ISPF Interface)\n         BASR  R14,R15                  Go do it\n\n         LA    R15,=CL8'SETMSG'         Yes, ISPF Function\n         ST    R15,@K_ISPF_Parms        Save it\n         LA    R15,=CL8'ISRZ001'        A(Message ID)\n         ST    R15,@K_ISPF_Parms+4      Save it\n         OI    @K_ISPF_Parms+4,X'80'    Mark end of list\n         LA    R1,@K_ISPF_Parms         Point to ISPF parms\n         L     R15,@_ISPLINK            A(Interface routine)\n         BASR  R14,R15                  Go do it\n\n         J     K00710                   And redisplay\n\nK00710   DS    0H\n*--------------------------------------------------------------------*\n*     ... and re-display the table.                                  *\n*--------------------------------------------------------------------*\n         J     K00060                   and start again\n\nK00720   DS    0H\n*--------------------------------------------------------------------*\n*     All done, clear our return code, and exit                      *\n*--------------------------------------------------------------------*\n         LA    R15,0                    Clear the return code\n         J     K90010                   and exit\n\n\nK80010   DS    0H\n*--------------------------------------------------------------------*\n*     Panel not found, set return code, and exit                     *\n*--------------------------------------------------------------------*\n         LA    R15,4                    Set return code\n         J     K90010                   and exit\n\nK90010   DS    0H\n*---------------------------------------------------------------------*\n*   Free up our Dynamic area storage                                  *\n*---------------------------------------------------------------------*\n         LR    R3,R15                 Save return code\n\n         ICM   R1,B'1111',@K_ISPF_Dyn_Area_Ptr\n         JZ    K90020                   None, skip\n         L     R2,@K_31Bit_Stack_Ptr_Ptr A(31-bit stack Ptr)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         SSCSTACK POP,                  Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=(R2)                on this stack\nK90020   DS    0H\n*-------------------------------------------------------------------*\n*    Free up our local storage ...                                  *\n*-------------------------------------------------------------------*\n         LA    R1,@K_Dynam              A(Local storage)\n         L     R2,@K_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         L     R13,4(0,R13)             Rescue A(HSA)\n\n         SSCSTACK POP,                  Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=(R2)                on this stack\n\n         LR    R15,R3                   Restore return code\n\n*-------------------------------------------------------------------*\n*    ... and return to caller                                       *\n*-------------------------------------------------------------------*\n         L     R14,12(0,R13)            Restore return address\n         LM    R0,R12,20(R13)           Restore other registers\n         BSM   0,R14                    and return\n\nK_Literals  DS  0H\n\nK_MVC    MVC   0(0,R1),0(R15)           Move data to dynamic area\nK_PACK   PACK  @K_DBLWD,0(0,R1)         Pack it\nK_CLC    CLC   0(0,R1),0(R14)           Compare ZSCROLLN and ZSCROLLA\nK_CLC1   CLC   @K_DBLWD(0),=C'CANCEL'   Check ZCMD for CANCEL\nK_BLANKS DC    C' '\n\nK_Bad_ZCMD_SMsg DC C'Invalid Command'\nK_Bad_ZCMD_LMsg DC C'Valid commands are: SORT, UP, DOWN, LEFT, RIGHT, E+\n               ND, RETURN, and CANCEL'\n\nK_ISPF_PQUERY_Names DC C'('            PQUERY Variable Names\nK_SPCDYNTY          DC CL8'SPCDYNTY',CL1' ' Type of Dyn area\nK_SPCDYNWI          DC CL8'SPCDYNWI',CL1' ' Width\nK_SPCDYNDE          DC CL8'SPCDYNDE',CL1' ' Depth\nK_SPCDYNRO          DC CL8'SSCDYNRO',CL1' ' Starting Row\nK_SPCDYNCO          DC CL8'SSCDYNCO',CL1' ' Starting Column\n                    DC C')'\nK_ISPF_PQUERY_Types DC CL8'CHAR'       Type of Dynamic area\n                    DC CL8'FIXED'      Width\n                    DC CL8'FIXED'      Depth\n                    DC CL8'FIXED'      Starting Row\n                    DC CL8'FIXED'      Starting Column\nK_ISPF_PQUERY_Lens  DC FL4'8'          Length of Type\n                    DC FL4'4'          Length of Width\n                    DC FL4'4'          Length of Depth\n                    DC FL4'4'          Length of Starting Row\n                    DC FL4'4'          Length of Starting Column\n\nK_ISPF_VCOPY_Scroll_Names DC C'(ZVERB,ZSCROLLN,ZSCROLLA)'\nK_ISPF_VCOPY_Cursor_Names DC C'(ZSCREENW ZSCREENC)'\n\nK_K00680_MVC           MVC   0(0,R14),0(R1)\n\nK_Expand_Tbl           EQU   *\nK_Expand_Ent           EQU   *\n                       DC    AL2(VolTbl_Ent_FreeTrk-VolTbl_Ent_Display)\n                       DC    AL2(VolTbl_Ent_FreeTrk+L'VolTbl_Ent_FreeTr+\n               k-VolTbl_Ent_Display)\n                       DC    AL2(VolTbl_Ent_Sort_FreeTrk-VolTbl_Ent)\nK_Expand_Ent_Len       EQU   *-K_Expand_Ent\n                       DC    AL2(VolTbl_Ent_FreeCyl-VolTbl_Ent_Display)\n                       DC    AL2(VolTbl_Ent_FreeCyl+L'VolTbl_Ent_FreeCy+\n               l-VolTbl_Ent_Display)\n                       DC    AL2(VolTbl_Ent_Sort_FreeCyl-VolTbl_Ent)\n\n                       DC    AL2(VolTbl_Ent_FreeBytes-VolTbl_Ent_Displa+\n               y)\n                       DC    AL2(VolTbl_Ent_FreeBytes+L'VolTbl_Ent_Free+\n               Bytes-VolTbl_Ent_Display)\n                       DC    AL2(VolTbl_Ent_Sort_FreeBytes-VolTbl_Ent)\n\n                       DC    AL2(VolTbl_Ent_FreePct-VolTbl_Ent_Display)\n                       DC    AL2(VolTbl_Ent_FreePct+L'VolTbl_Ent_FreePc+\n               t-VolTbl_Ent_Display)\n                       DC    AL2(VolTbl_Ent_Sort_FreePct-VolTbl_Ent)\n\n                       DC    AL2(VolTbl_Ent_FreeExt-VolTbl_Ent_Display)\n                       DC    AL2(VolTbl_Ent_FreeExt+L'VolTbl_Ent_FreeEx+\n               t-VolTbl_Ent_Display)\n                       DC    AL2(VolTbl_Ent_Sort_FreeExt-VolTbl_Ent)\n\n                       DC    AL2(VolTbl_Ent_LargTrk-VolTbl_Ent_Display)\n                       DC    AL2(VolTbl_Ent_LargTrk+L'VolTbl_Ent_LargTr+\n               k-VolTbl_Ent_Display)\n                       DC    AL2(VolTbl_Ent_Sort_LargTrk-VolTbl_Ent)\n\n                       DC    AL2(VolTbl_Ent_LargCyl-VolTbl_Ent_Display)\n                       DC    AL2(VolTbl_Ent_LargCyl+L'VolTbl_Ent_LargCy+\n               l-VolTbl_Ent_Display)\n                       DC    AL2(VolTbl_Ent_Sort_LargCyl-VolTbl_Ent)\n\n                       DC    AL2(VolTbl_Ent_VTOCTrk-VolTbl_Ent_Display)\n                       DC    AL2(VolTbl_Ent_VTOCTrk+L'VolTbl_Ent_VTOCTr+\n               k-VolTbl_Ent_Display)\n                       DC    AL2(VolTbl_Ent_Sort_VTOCTrk-VolTbl_Ent)\n\n                       DC    AL2(VolTbl_Ent_FreeDSCB-VolTbl_Ent_Display+\n               )\n                       DC    AL2(VolTbl_Ent_FreeDSCB+L'VolTbl_Ent_FreeD+\n               SCB-VolTbl_Ent_Display)\n                       DC    AL2(VolTbl_Ent_Sort_FreeDSCB-VolTbl_Ent)\n\n                       DC    AL2(VolTbl_Ent_VTOCFree-VolTbl_Ent_Display+\n               )\n                       DC    AL2(VolTbl_Ent_VTOCFree+L'VolTbl_Ent_VTOCF+\n               ree-VolTbl_Ent_Display)\n                       DC    AL2(VolTbl_Ent_Sort_VTOCFree-VolTbl_Ent)\n\n                       DC    AL2(VolTbl_Ent_VolSize-VolTbl_Ent_Display)\n                       DC    AL2(VolTbl_Ent_VolSize+L'VolTbl_Ent_VolSiz+\n               e-VolTbl_Ent_Display)\n                       DC    AL2(VolTbl_Ent_Sort_VolSize-VolTbl_Ent)\n\n                       DC    AL2(0)\n                       DC    AL2(0)\n                       DC    AL2(0)\n\nK_Expand_ZEDLMSG_Pfx   DC    C'The unrounded, unscaled value is '\n\n         LTORG\n\nK_Literals_End  DS  0H\n\n\n@K_Dynam                  DSECT        Dynamic area for K\n                          DS    18F     O/S style save area\n@K_31Bit_Stack_Ptr_Ptr    DS    AL4     A(31-bit Stack Ptr)\n@K_24Bit_Stack_Ptr_Ptr    DS    AL4     A(24-bit Stack Ptr)\n@K_DBLWD                  DS    D       Work area\n@K_QuadWord               DS    PL16    Work area\n@K_ISPF_Parms             DS    8AL4    ISPF Parm list\n\n@K_ISPF_Dyn_Area_Width    DS    FL4     Panel Dynam Area Width\n@K_ISPF_Dyn_Area_Depth    DS    FL4     Panel Dynam Area Depth\n@K_ISPF_Dyn_Area_Row      DS    FL4     Panel Dynam Area Start Row\n@K_ISPF_Dyn_Area_Column   DS    FL4     Panel Dynam Area Start Column\n@K_ISPF_Dyn_Area_Ptr      DS    AL4     A(Storage for dynamic area)\n@K_ISPF_Dyn_Area_Len      DS    FL4     Length of dynamic area\n\n                          DS    C\n@K_FLIN                   DS    CL5     Line x\n\n@K_VolTbl_Ent_MVC_Len     DS    FL4     EX len of MVC from VolTbl_Ent\n\n@K_VolTbl_Ent_Display_Line DS   FL4     Current top of display\n@K_VolTbl_Ent_Offset      DS    FL4     Offset for LEFT/RIGHT\n@K_VolTbl_Ent_Display_Line_Max DS FL4   Max value of display line\n@K_VolTbl_Ent_Offset_Max  DS    FL4     Max Offset for LEFT/RIGHT\n@K_VolTbl_Ent_Display_Line_Prev DS FL4  Previous top of display\n@K_VolTbl_Ent_Offset_Prev DS    FL4     Previous Offset for LEFT/RIGHT\n@K_ISPF_Dyn_Area_Hdg_Lines DS   FL4     Nbr of hdg lines in display\n@K_VolTbl_Hdg_Lines       DS    FL4     Nbr of hdg lines in VolTbl\n\n                          DS    X       Flag byte\n@K_Scroll_MAX             EQU   *-1,X'80' 1... .... Scroll MAX\n@K_Scroll_Explicit        EQU   *-1,X'40' .1.. .... Explicit Scroll amt\n@K_Scroll_UP              EQU   *-1,X'08' .... 1... Scroll UP\n@K_Scroll_DOWN            EQU   *-1,X'04' .... .1.. Scroll DOWN\n@K_Scroll_LEFT            EQU   *-1,X'02' .... ..1. Scroll LEFT\n@K_Scroll_RIGHT           EQU   *-1,X'01' .... ...1 Scroll RIGHT\n\n\n@K_Expand_Number          DS    XL40\n@K_Expand_NumStart        DS    AL4\n@K_Expand_NumEnd          DS    AL4\n\n@K_Expand_ZEDSMSG         DS    CL24\n@K_Expand_ZEDSMSG_Len     DS    FL4     Length\n@K_Expand_ZEDLMSG         DS    CL(L'K_Expand_ZEDLMSG_Pfx+L'@K_Expand_N+\n               umber)\n@K_Expand_ZEDLMSG_Len     DS    FL4     Length\n\n@K_ISPF_VCOPY_Ptrs        DS    0F      Pointer to var from VCOPY\n@K_ISPF_VCOPY_Var_Ptr     DS    AL4     A(VCOPYed variable)\n                          ORG   @K_ISPF_VCOPY_Ptrs\n@K_ISPF_VCOPY_Scroll_Ptrs DS    0F      Pointers to vars from VCOPY\n@K_ISPF_VCOPY_ZVERB_Ptr   DS    AL4      A(ZVERB)\n@K_ISPF_VCOPY_ZSCROLLN_Ptr DS   AL4      A(ZSCROLLN)\n@K_ISPF_VCOPY_ZSCROLLA_Ptr DS   AL4      A(ZSCROLLA)\n                          ORG   @K_ISPF_VCOPY_Ptrs\n@K_ISPF_PQUERY_Values     DS    0F     Value areas for PQUERY vars\n@K_ISPF_SPCDYNTN_Value    DS    CL8     Type of area\n@K_ISPF_SPCDYNWI_Value    DS    FL4     Area width\n@K_ISPF_SPCDYNDE_Value    DS    FL4     Area depth\n@K_ISPF_SPCDYNRO_Value    DS    FL4     Starting Row\n@K_ISPF_SPCDYNCO_Value    DS    FL4     Starting Column\n                          ORG   @K_ISPF_VCOPY_Ptrs\n@K_ISPF_VCOPY_Cursor_Ptrs DS    0F      Pointers to vars from VCOPY\n@K_ISPF_ZSCREENW_Ptr      DS    AL4      A(ZSCREENW)\n@K_ISPF_ZSCREENC_Ptr      DS    AL4      A(ZSCREENC)\n                          ORG ,\n\n@K_ISPF_VCOPY_Lens        DS    0F      Length of var from VCOPY\n@K_ISPF_VCOPY_Var_Len     DS    AL4     Len of VCOPYed variable\n                          ORG   @K_ISPF_VCOPY_Lens\n@K_ISPF_VCOPY_Scroll_Lens DS    0F      Lengths of vars from VCOPY\n@K_ISPF_VCOPY_ZVERB_Len   DS    FL4      ZVERB Length\n@K_ISPF_VCOPY_ZSCROLLN_Len DS   FL4      ZSCROLLN Length\n@K_ISPF_VCOPY_ZSCROLLA_Len DS   FL4      ZSCROLLA Length\n                          ORG   @K_ISPF_VCOPY_Lens\n@K_ISPF_VCOPY_Cursor_Lens DS    0F      Lengths of vars from VCOPY\n@K_ISPF_ZSCREENW_Len      DS    FL4      ZSCREENW Length\n@K_ISPF_ZSCREENC_Len      DS    FL4      ZSCREENC Length\n                          ORG   ,\n\n@K_Parms                  DS    0F      Parms for called rtns\n@K_Parms_Std              DS    3AL4     Standard 3 parms\n@K_Parms_Extra            EQU   *        Extra parms\n@K_Parms_V00010           DS    AL4        for V00010\n                          ORG   ,\n\n                          DS    0D\n@K_Dynam_Length           EQU   *-@K_Dynam\n\n&PGMNAME CSECT\n         DROP  ,                        Free base registers\n         POP   USING\n         TITLE 'L00010: Identify line command under ISPF'\n\n         PUSH  USING\n\nL00010   DS    0H\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Routine   : L00010                                                 *\n*                                                                     *\n*  Abstract  : Process primary command entered in ISPF (S)pace or     *\n*              (B)rowse mode.                                         *\n*                                                                     *\n*  Inputs    : R1 : ---> A(@_Dynam)                                   *\n*                        A(31-bit Stack Pointer)                      *\n*                        A(24-bit Stack Pointer)                      *\n*  Outputs   : R15: 0: Command processed OK                           *\n*                   4: Display mode change requested                  *\n*                   8: Unrecognized command                           *\n*                                                                     *\n*  Notes     :                                                        *\n*                                                                     *\n*  History:    2002/02/12 SDDA030 - V2.16                             *\n*                                   New                               *\n*              2003/10/07 SDDA030 - V2.21                             *\n*                                   Added line commands:              *\n*                                    - ISPF(x) to change display mode *\n*                                    - OUTPUT to write table to a file*\n*                                                                     *\n*              ____/__/__ _______                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         STM   R14,R12,12(R13)          Save callers registers\n         LARL  R11,L_Literals           Point to our literals\n         USING (L_Literals,L_Literals_End),R11 Tell the assembler\n\n         L     R12,0(0,R1)              A(@_Dynam)\n         USING @_Dynam,R12              Tell the assembler\n\n*-------------------------------------------------------------------*\n*    Get an area on the stack for our local storage                 *\n*-------------------------------------------------------------------*\n         L     R2,4(0,R1)               A(31-bit stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         SSCSTACK PUSH,                 Get stack area                 +\n               LEN=@L_Dynam_Length,      this long                     +\n               STACK=(R2)                using this stack\n\n         LR    R3,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LHI   R1,@L_Dynam_Length        Its length\n         LA    R14,0                    Clear source address\n         LA    R15,0                     and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R3                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*-------------------------------------------------------------------*\n         ST    R13,4(0,R1)              Chain\n         ST    R1,8(0,R13)               saveareas\n         LR    R13,R1                   Load dynam base\n         USING @L_Dynam,R13             Assign a base\n         L     R15,@L_Dynam+4           Get A(HSA)\n         LM    R0,R3,20(R15)            Restore callers registers\n\n         L     R15,4(0,R1)              A(31-bit Stack Pointer)\n         ST    R15,@L_31Bit_Stack_Ptr_Ptr Save it\n         L     R15,8(0,R1)              A(24-bit Stack Pointer)\n         ST    R15,@L_24Bit_Stack_Ptr_Ptr Save it\n\n*-------------------------------------------------------------------*\n*    Get ZCMD                                                       *\n*-------------------------------------------------------------------*\n         LA    R15,=CL8'VCOPY'          ISPF Function\n         ST    R15,@L_ISPF_Parms        Save it\n         LA    R15,=CL8'ZCMD'           Variable we want\n         ST    R15,@L_ISPF_Parms+4      Save it\n         LA    R15,@L_ZCMD_Length       A(Length Address)\n         ST    R15,@L_ISPF_Parms+8      Save it\n         LA    R15,@L_ZCMD_Ptr          A(Variable name)\n         ST    R15,@L_ISPF_Parms+12     Save it\n         OI    @L_ISPF_Parms+12,X'80'   Flag last parm\n         LA    R1,@L_ISPF_Parms         A(ISPF Parms)\n         L     R15,@_ISPLINK            A(ISPF routine)\n         BASR  R14,R15                  Go get the variable\n\n         LTR   R15,R15                  Did we get it?\n         JNZ   L00140                   No, pretend all is OK\n\n*-------------------------------------------------------------------*\n*    See if we recognize the command. First, uppercase it ...       *\n*-------------------------------------------------------------------*\n         ICM   R14,B'1111',@L_ZCMD_Length Get len of ZCMD\n         JZ    L00140                   Nothing, all done\n         ICM   R15,B'1111',@L_ZCMD_Ptr  OK, point to ZCMD\n         JZ    L00140                   Nothing (huh?), exit\n         MVI   @L_Prim_Cmd,C' '         Clear\n         MVC   @L_Prim_Cmd+1(L'@L_Prim_Cmd-1),@L_Prim_Cmd command area\n         AHI   R14,-1                   EX length\n         EX    R14,L_OC                 Uppercase it\n         AHI   R14,1                    Restore real length\n\n*-------------------------------------------------------------------*\n*    ... and search our table for the command                       *\n*-------------------------------------------------------------------*\n         LR    R0,R14                   Set up length register\n         LR    R1,R15                   and pointer register\n\n         LA    R15,0                    Clear length register\n         LA    R14,L_Command_Table      A(Commands we know about)\nL00020   DS    0H\n         ICM   R2,B'1111',0(R14)        A(Processing routine)\n         JZ    L00160                   End-of-table, unknown command\n         IC    R15,4(0,R14)             Get cmd len from table\n         CR    R0,R15                   Could it be ours?\n         JNH   L00030                   No, try next\n         EX    R15,L_CLC                Could be, is it?\n         JNE   L00030                   No, try next table entry\n         LA    R2,1(0,R15)              Maybe, get real length of cmd\n         CR    R0,R2                    Is that all there is?\n         JNH   L00040                   Yes, found our entry\n         AR    R2,R1                    No, point to last char of cmd\n         CLI   0(R2),C' '               Followed by a space?\n         JE    L00040                   Yes, this is our command\nL00030   DS    0H\n         LA    R14,6(R14,R15)           A(Next entry)\n         J     L00020                   and check it out\n\nL00040   DS    0H\n*-------------------------------------------------------------------*\n*    We have found our command entry, so now we set up the          *\n*   registers for the processing routine:                           *\n*        R1 = A(1st non-blank after the command)                    *\n*        R0 = length of data remaining in ZCMD                      *\n*-------------------------------------------------------------------*\n         AR    R0,R1                    A(char past end of ZCMD)\n         AR    R1,R15                   A(last char of command)\nL00050   DS    0H\n         AHI   R1,1                     A(next char)\n         CR    R1,R0                    Gone too far?\n         JNL   L00060                   Yep, skip\n         CLI   0(R1),C' '               No, a space?\n         JE    L00050                   Yes, keep going\nL00060   DS    0H\n         SR    R0,R1                    Length of data remaining\n\n*-------------------------------------------------------------------*\n*    Go process our command                                         *\n*-------------------------------------------------------------------*\n         LA    R15,@_Dynam              A(Dynamic area)\n         ST    R15,@L_Rtn_Parms         Save it\n         L     R15,@L_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)\n         ST    R15,@L_Rtn_Parms+4       Save it\n         L     R15,@L_24Bit_Stack_Ptr_Ptr A(24-bit Stack Pointer)\n         ST    R15,@L_Rtn_Parms+8       Save it\n         ST    R1,@L_Rtn_Parms+12       Save A(Command)\n         ST    R0,@L_Rtn_Parms+16       Save Len of Command\n\n         LA    R1,@L_Rtn_Parms          A(Parm list)\n         L     R15,0(0,R14)             A(processing routine)\n         BASR  R14,R15                  go do it\n\n         J     L00140                   and skip\n\nL00140   DS    0H\n         LA    R15,0                    Clear return code\n         J     L90010                   and exit\n\nL00160   DS    0H\n         LA    R15,8                    Unrecognized command\n         J     L90010                   and exit\n\n\nL90010   DS    0H\n*-------------------------------------------------------------------*\n*    Free up our local storage ...                                  *\n*-------------------------------------------------------------------*\n         LR    R3,R15                   Save return code\n\n         LA    R1,@L_Dynam              A(Local storage)\n         L     R2,@L_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         L     R13,4(0,R13)             Rescue A(HSA)\n\n         SSCSTACK POP,                  Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=(R2)                on this stack\n\n         LR    R15,R3                   Restore return code\n\n*-------------------------------------------------------------------*\n*    ... and return to caller                                       *\n*-------------------------------------------------------------------*\n         L     R14,12(0,R13)            Restore return address\n         LM    R0,R12,20(R13)           Restore regs other than R15\n         BSM   0,R14                    and return\n\nL_Literals  DS  0H\n\nL_Command_Table EQU  *\nL_Cmd_Proc  DC  AL4(LA0010)             Command processor\nL_Cmd_Len   DC  AL1(3)                  Command length (EX len)\nL_Cmd       DC  C'SORT'                 Command Name\n\n            DC  AL4(LB0010A)\n            DC  AL1(6)\n            DC  C'ISPF(S)'\n\n            DC  AL4(LB0010B)\n            DC  AL1(6)\n            DC  C'ISPF(E)'\n\n            DC  AL4(LB0010C)\n            DC  AL1(6)\n            DC  C'ISPF(B)'\n\n            DC  AL4(LB0010D)\n            DC  AL1(6)\n            DC  C'ISPF(N)'\n\n            DC  AL4(LC0010)\n            DC  AL1(5)\n            DC  C'OUTPUT'\n\n            DC  AL4(0)                  End-of-Table marker\n\nL_OC     OC    @L_Prim_Cmd(0),0(R15)    Uppercase command\nL_CLC    CLC   @L_Prim_Cmd(0),5(R14)    Check for command in table\n\n         LTORG\n\nL_Literals_End  DS  0H\n\n\n@L_Dynam                  DSECT\n                          DS    18F    O/S style save area\n@L_31Bit_Stack_Ptr_Ptr    DS    AL4    A(31-bit Stack Ptr)\n@L_24Bit_Stack_Ptr_Ptr    DS    AL4    A(24-bit Stack Ptr)\n@L_Prim_Cmd               DS    CL80   Copy of line command\n@L_ZCMD_Ptr               DS    AL4    A(ZCMD)\n@L_ZCMD_Length            DS    FL4    Length of ZCMD\n@L_ISPF_Parms             DS    5AL4   ISPF Parm List\n@L_Rtn_Parms              DS    5AL4   Cmd processing routine parms\n                          DS    0D\n@L_Dynam_Length           EQU   *-@L_Dynam\n\n\n&PGMNAME CSECT\n\n         DROP  ,\n         POP   USING\n\n         TITLE 'LA0010: Process SORT Primary Command'\n\n         PUSH  USING\n\nLA0010   DS    0H\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Routine   : LA0010                                                 *\n*                                                                     *\n*  Abstract  : Process SORT primary command                           *\n*                                                                     *\n*  Inputs    : R1 : ---> A(@_Dynam)                                   *\n*                        A(31-bit Stack Pointer)                      *\n*                        A(24-bit Stack Pointer)                      *\n*                        A(operands of the SORT command)              *\n*                        Length of operands                           *\n*  Outputs   : R15: 0                                                 *\n*                                                                     *\n*  Notes     :                                                        *\n*                                                                     *\n*  History:    2002/02/12 SDDA030 - V2.16                             *\n*                                   New                               *\n*              2003/10/07 SDDA030 - V2.21                             *\n*                                   New, originally in L0010          *\n*              2006/04/21 SDDA030 - V2.24                             *\n*                                   Used standardised calling sequence*\n*                                                                     *\n*              ____/__/__ _______                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         STM   R14,R12,12(R13)          Save callers registers\n         LARL  R11,LA_Literals          Point to our literals\n         USING (LA_Literals,LA_Literals_End),R11 Tell the assembler\n\n         L     R12,0(0,R1)              A(@_Dynam)\n         USING @_Dynam,R12              Tell the assembler\n\n*-------------------------------------------------------------------*\n*    Get an area on the stack for our local storage                 *\n*-------------------------------------------------------------------*\n         L     R2,4(0,R1)               A(31-bit stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         SSCSTACK PUSH,                 Get stack area                 +\n               LEN=@LA_Dynam_Length,     this long                     +\n               STACK=(R2)                using this stack\n\n         LR    R3,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LHI   R1,@LA_Dynam_Length       Its length\n         LA    R14,0                    Clear source address\n         LA    R15,0                     and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R3                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*-------------------------------------------------------------------*\n         ST    R13,4(0,R1)              Chain\n         ST    R1,8(0,R13)               saveareas\n         LR    R13,R1                   Load dynam base\n         USING @LA_Dynam,R13            Assign a base\n         L     R15,@LA_Dynam+4          Get A(HSA)\n         LM    R0,R3,20(R15)            Restore callers registers\n\n         L     R15,4(0,R1)              A(31-bit Stack Pointer)\n         ST    R15,@LA_31Bit_Stack_Ptr_Ptr Save it\n         L     R15,8(0,R1)              A(24-bit Stack Pointer)\n         ST    R15,@LA_24Bit_Stack_Ptr_Ptr Save it\n\n*---------------------------------------------------------------------*\n*   Initialize our flags, and get the operand length and addr         *\n*---------------------------------------------------------------------*\n         NI    @LA_Cmd_Prompted,X'FF'-L'@LA_Cmd_Prompted\n\n         L     R0,16(0,R1)              Get operand length\n         L     R1,12(0,R1)              Get A(Operands)\n\nLA0020   DS    0H\n*---------------------------------------------------------------------*\n*   Initialize our sort fields ...                                    *\n*---------------------------------------------------------------------*\n         MVC   @LA_I00010_Sort_Field,=CL8' ' Clear sort field\n         MVI   @LA_I00010_Sort_Dir,C' ' and direction\n\n*---------------------------------------------------------------------*\n*   Check to see what we have as operands                             *\n*---------------------------------------------------------------------*\n         LTR   R14,R0                   Get the length\n         JZ    LA0100                   No operands, skip\n         LR    R15,R1                   OK, point to it (them)\n\nLA0050   DS    0H\n         CLI   0(R15),C' '              End of field?\n         JE    LA0060                   Yes, skip\n         AHI   R15,1                    Bump input pointer\n         BRCT  R14,LA0050               and check out next\nLA0060   DS    0H\n         LR    R3,R15                   A(Byte past end-of-field)\n         SR    R3,R1                    Length of field\n         JNP   LA0100                   Nothing, skip\n         C     R3,=AL4(L'@LA_I00010_Sort_Field) Too long?\n         JNH   LA0070                   No, skip\n         L     R3,=AL4(L'@LA_I00010_Sort_Field) Yes, use max length\nLA0070   DS    0H\n         AHI   R3,-1                    EX length\n         EX    R3,LA_OC                 Save it\n\n*-------------------------------------------------------------------*\n*    Extract the sort direction                                     *\n*-------------------------------------------------------------------*\n         LTR   R14,R14                  Anything left?\n         JZ    LA0100                   No, all done\nLA0080   DS    0H\n         CLI   0(R15),C' '              Leading space?\n         JNE   LA0090                   No, skip\n         AHI   R15,1                    Yes, bump pointer\n         BRCT  R14,LA0080               and check next\n         J     LA0100                   All done, skip\nLA0090   DS    0H\n         OC    @LA_I00010_Sort_Dir,0(R15) Save Sort direction\n\nLA0100   DS    0H\n*-------------------------------------------------------------------*\n*    If we don't have a sort field, and we have prompted, just      *\n*   exit without sorting                                            *\n*-------------------------------------------------------------------*\n         CLI   @LA_I00010_Sort_Field,C' ' Any sort field?\n         JNE   LA0110                   Yes, go sort\n         TM    @LA_Cmd_Prompted,L'@LA_Cmd_Prompted Did we prompt?\n         JZ    LA0120                   No, go prompt now\n         J     LA9010                   Yes, exit\n\nLA0110   DS    0H\n*-------------------------------------------------------------------*\n*    Invoke the sort routine                                        *\n*-------------------------------------------------------------------*\n         LA    R15,@_Dynam              A(Dynamic area)\n         ST    R15,@LA_Parms_Std        Save it\n         L     R15,@LA_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)\n         ST    R15,@LA_Parms_Std+4      Save it\n         L     R15,@LA_24Bit_Stack_Ptr_Ptr A(24-bit Stack Pointer)\n         ST    R15,@LA_Parms_Std+8      Save it\n         LA    R15,@LA_I00010_Sort_Field A(Offset)\n         ST    R15,@LA_Parms_I00010     Save it\n         LA    R15,@LA_I00010_Sort_Dir  A(Sort Direction)\n         ST    R15,@LA_Parms_I00010+4   Save it\n\n         LA    R1,@LA_Parms             A(Parms)\n         BRAS  R14,I00010               Go sort\n\n         LTR   R15,R15                  Did it work?\n         JZ    LA9010                   Yes, exit\n\nLA0120   DS    0H\n*-------------------------------------------------------------------*\n*    SORT was entered with no operands, or the sort failed (because *\n*   of an invalid sort field) - if we can, pop up a panel prompting *\n*   for the sort field and direction.                               *\n*-------------------------------------------------------------------*\n         CLI   LA_Prompt_Panel,C' '     Any prompt panel?\n         JE    LA0130                   No, just get out\n\n         LA    R15,=CL8'PQUERY'         ISPF Function\n         ST    R15,@LA_ISPF_Parms       Save it\n         LA    R15,LA_Prompt_Panel      A(Panel name)\n         ST    R15,@LA_ISPF_Parms+4     Save it\n         LA    R15,LA_Prompt_Panel      A(Dummy area name)\n         ST    R15,@LA_ISPF_Parms+8     Save it\n         LA    R15,@LA_ISPF_Parms+16    A(Return area)\n         ST    R15,@LA_ISPF_Parms+12    Save it\n         OI    @LA_ISPF_Parms+12,X'80'  Flag last parm\n         LA    R1,@LA_ISPF_Parms        A(ISPF Parms)\n         L     R15,@_ISPLINK            A(ISPF routine)\n         BASR  R14,R15                  Go check out panel\n         CHI   R15,8                    Was the panel found?\n         JH    LA0130                   No, just exit\n\n         LA    R15,=CL8'ADDPOP'         ISPF Function\n         ST    R15,@LA_ISPF_Parms       Save it\n         OI    @LA_ISPF_Parms,X'80'     Flag last parm\n         LA    R1,@LA_ISPF_Parms        A(ISPF Parms)\n         L     R15,@_ISPLINK            A(ISPF routine)\n         BASR  R14,R15                  Set pop-up environment\n\n         LA    R15,=CL8'DISPLAY'        ISPF Function\n         ST    R15,@LA_ISPF_Parms       Save it\n         LA    R15,LA_Prompt_Panel      A(Panel name)\n         ST    R15,@LA_ISPF_Parms+4     Save it\n         OI    @LA_ISPF_Parms+4,X'80'   Flag last parm\n         LA    R1,@LA_ISPF_Parms        A(ISPF Parms)\n         L     R15,@_ISPLINK            A(ISPF routine)\n         BASR  R14,R15                  Display pop-up prompt\n         LR    R3,R15                   Save our return code\n\n         LA    R15,=CL8'REMPOP'         ISPF Function\n         ST    R15,@LA_ISPF_Parms       Save it\n         OI    @LA_ISPF_Parms,X'80'     Flag last parm\n         LA    R1,@LA_ISPF_Parms        A(ISPF Parms)\n         L     R15,@_ISPLINK            A(ISPF routine)\n         BASR  R14,R15                  Reset pop-up environment\n\n         CHI   R3,8                     How did we do?\n         JH    LA0130                   Not good, skip\n         JE    LA0140                   END, RETURN, etc.\n\n         OI    @LA_Cmd_Prompted,L'@LA_Cmd_Prompted We have prompted\n\n         LA    R15,=CL8'VCOPY'          ISPF Function\n         ST    R15,@LA_ISPF_Parms       Save it\n         LA    R15,=CL8'ZCMD'           Variable we want\n         ST    R15,@LA_ISPF_Parms+4     Save it\n         LA    R15,@LA_ISPF_VCOPY_Lens  A(Length Address)\n         ST    R15,@LA_ISPF_Parms+8     Save it\n         LA    R15,@LA_ISPF_VCOPY_Ptrs  A(Variable)\n         ST    R15,@LA_ISPF_Parms+12    Save it\n         OI    @LA_ISPF_Parms+12,X'80'  Flag last parm\n         LA    R1,@LA_ISPF_Parms        A(ISPF Parms)\n         L     R15,@_ISPLINK            A(ISPF routine)\n         BASR  R14,R15                  Go get the variable\n\n         LTR   R15,R15                  Did we get it?\n         JNZ   LA0130                   No, exit\n\n*-------------------------------------------------------------------*\n*    The popup seemed to work; if the 1st word is SORT, point past  *\n*   it                                                              *\n*-------------------------------------------------------------------*\n         ICM   R0,B'1111',@LA_ISPF_VCOPY_Lens Get ZCMD length\n         JZ    LA0130                   Nothing, skip\n         ICM   R1,B'1111',@LA_ISPF_VCOPY_Ptrs A(ZCMD)\n         JZ    LA0130                   Nothing, skip\n\n         CHI   R0,5                     Room enough for 'SORT '?\n         JNH   LA0128                   No, skip\n         CLC   =C'SORT ',0(R1)          Yes, is it?\n         JNE   LA0128                   No, skip\n         AR    R0,R1                    Yes, point past end of string\n         AHI   R1,5                     and point past 'SORT '\nLA0122   DS    0H\n         CLI   0(R1),C' '               Start of operand?\n         JNE   LA0124                   Yes, skip\n         AHI   R1,1                     No, bump pointer\n         CR    R1,R0                    Any string left?\n         JL    LA0122                   Yes, keep checking\nLA0124   DS    0H\n         SR    R0,R1                    Set up new length\nLA0128   DS    0H\n\n         J     LA0020                   and start again\n\nLA0130   DS    0H\n*-------------------------------------------------------------------*\n*    The sort failed, and we are not prompting, so set the ISPF     *\n*   messages                                                        *\n*-------------------------------------------------------------------*\n         LA    R15,=CL8'VDEFINE'        ISPF Function\n         ST    R15,@LA_ISPF_Parms       Save it\n         LA    R15,=CL8'CHAR'           Character variables\n         ST    R15,@LA_ISPF_Parms+12 Save it\n\n         LA    R15,=CL8'ZEDSMSG'        Variable name\n         ST    R15,@LA_ISPF_Parms+4     Save it\n         LA    R15,LA_Sort_Fail_SMsg    Short message\n         ST    R15,@LA_ISPF_Parms+8     Save it\n         LA    R15,=AL4(L'LA_Sort_Fail_SMsg) Length of message\n         ST    R15,@LA_ISPF_Parms+16 Save it\n         OI    @LA_ISPF_Parms+16,X'80' Flag end of list\n         LA    R1,@LA_ISPF_Parms        A(Parmlist)\n         L     R15,@_ISPLINK            A(ISPF Interface)\n         BASR  R14,R15                  Go do it\n\n         LA    R15,=CL8'ZEDLMSG'        Variable name\n         ST    R15,@LA_ISPF_Parms+4     Save it\n         LA    R15,LA_Sort_Fail_LMsg    Long message\n         ST    R15,@LA_ISPF_Parms+8     Save it\n         LA    R15,=AL4(L'LA_Sort_Fail_LMsg) Length of message\n         ST    R15,@LA_ISPF_Parms+16 Save it\n         OI    @LA_ISPF_Parms+16,X'80' Flag end of list\n         LA    R1,@LA_ISPF_Parms        A(Parmlist)\n         L     R15,@_ISPLINK            A(ISPF Interface)\n         BASR  R14,R15                  Go do it\n\n         LA    R15,=CL8'SETMSG'         Yes, ISPF Function\n         ST    R15,@LA_ISPF_Parms       Save it\n         LA    R15,=CL8'ISRZ001'        A(Message ID)\n         ST    R15,@LA_ISPF_Parms+4     Save it\n         OI    @LA_ISPF_Parms+4,X'80' Mark end of list\n         LA    R1,@LA_ISPF_Parms        Point to ISPF parms\n         L     R15,@_ISPLINK            A(Interface routine)\n         BASR  R14,R15                  Go do it\n\n         J     LA0150                   and exit with error\n\nLA0140   DS    0H\n         LA    R15,0                    Clear return code\n         J     LA9010                   and exit\n\nLA0150   DS    0H\n         LA    R15,4                    No Sort done\n         J     LA9010                   and exit\n\nLA0160   DS    0H\n         LA    R15,8                    ZCMD other than SORT\n         J     LA9010                   and exit\n\n\nLA9010   DS    0H\n*-------------------------------------------------------------------*\n*    Free up our local storage ...                                  *\n*-------------------------------------------------------------------*\n         LR    R3,R15                   Save return code\n\n         LA    R1,@LA_Dynam             A(Local storage)\n         L     R2,@LA_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         L     R13,4(0,R13)             Rescue A(HSA)\n\n         SSCSTACK POP,                  Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=(R2)                on this stack\n\n         LR    R15,R3                   Restore return code\n\n*-------------------------------------------------------------------*\n*    ... and return to caller                                       *\n*-------------------------------------------------------------------*\n         L     R14,12(0,R13)            Restore return address\n         LM    R0,R12,20(R13)           Restore regs other than R15\n         BSM   0,R14                    and return\n\nLA_Literals DS  0H\n\nLA_OC    OC    @LA_I00010_Sort_Field(0),0(R1) Move Sort Field Name\n\nLA_Sort_Fail_SMsg     DC  C'Sort failed'\nLA_Sort_Fail_LMsg     DC  C'Invalid SORT field'\n\nLA_Prompt_Panel DC   CL8'&SORT_Prompt_Popup_Panel'\n\n         LTORG\n\nLA_Literals_End DS  0H\n\n\n@LA_Dynam                 DSECT\n                          DS    18F     O/S style save area\n@LA_31Bit_Stack_Ptr_Ptr   DS    AL4     A(31-bit Stack Ptr)\n@LA_24Bit_Stack_Ptr_Ptr   DS    AL4     A(24-bit Stack Ptr)\n@LA_DBLWD                 DS    D       Work area\n                          DS    X       Flag Byte\n@LA_Cmd_Prompted          EQU   *-1,X'80' 1... .... SORT from prompt\n                          DS    0F      Alignment\n@LA_Macros                EQU   *\n@LA_ISPF_Parms            DS    5AL4    ISPF Parm List\n@LA_ISPF_VCOPY_Lens       DS    AL4     ZCMD Length pointer\n@LA_ISPF_VCOPY_Ptrs       DS    AL4     ZCMD Data Ptr\n@LA_ZCMD_Ptr              DS    AL4     A(ZCMD)\n@LA_ZCMD_Length           DS    FL4     Length of ZCMD\n                          ORG   @LA_Macros\n@LA_I00010_Sort_Field     DS    CL8     Sort Field Name/Offset\n@LA_I00010_Sort_Dir       DS    C       Sort Direction\n                          ORG   ,\n\n@LA_Parms                 DS    0F      Parms for called rtns\n@LA_Parms_Std             DS    3AL4     Standard 3 parms\n@LA_Parms_Extra           EQU   *         Extra parms\n@LA_Parms_I00010          DS    2AL4         for I00010\n                          ORG   ,\n                          DS    0D\n@LA_Dynam_Length          EQU   *-@LA_Dynam\n\n\n&PGMNAME CSECT\n\n         DROP  ,\n         POP   USING\n\n         TITLE 'LB0010: Process ISPF(x) line command'\n\n         PUSH  USING\n\nLB0010   DS    0H\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Routine   : LB0010                                                 *\n*                                                                     *\n*  Abstract  : Change display type to ISPF(x) - SPACE display         *\n*                                                                     *\n*  Inputs    : R1 : ---> A(@_Dynam)                                   *\n*                        A(31-bit Stack Pointer)                      *\n*                        A(24-bit Stack Pointer)                      *\n*                        A(operands of the command)                   *\n*                        Length of operands                           *\n*  Outputs   : R15: 4                                                 *\n*                                                                     *\n*  Notes     :                                                        *\n*                                                                     *\n*  History:    2003/10/07 SDDA030 - V2.16                             *\n*                                   New                               *\n*              2006/04/21 SDDA030 - V2.24                             *\n*                                   Used standardised calling sequence*\n*                                                                     *\n*              ____/__/__ _______                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n\nLB0010A  DS    0H\n         STM   R14,R12,12(R13)          Save callers registers\n         LA    R4,0                     R4=0: ISPF(S)\n         J     LB0020\nLB0010B  DS    0H\n         STM   R14,R12,12(R13)          Save callers registers\n         LHI   R4,4                     R4=4: ISPF(E)\n         J     LB0020\nLB0010C  DS    0H\n         STM   R14,R12,12(R13)          Save callers registers\n         LHI   R4,8                     R4=8: ISPF(B)\n         J     LB0020\nLB0010D  DS    0H\n         STM   R14,R12,12(R13)          Save callers registers\n         LHI   R4,12                    R4=12: ISPF(N)\n         J     LB0020\nLB0020   DS    0H\n         LARL  R11,LB_Literals          Point to our literals\n         USING (LB_Literals,LB_Literals_End),R11 Tell the assembler\n\n         L     R12,0(0,R1)              A(@_Dynam)\n         USING @_Dynam,R12              Tell the assembler\n\n*-------------------------------------------------------------------*\n*    Get an area on the stack for our local storage                 *\n*-------------------------------------------------------------------*\n         L     R2,4(0,R1)               A(31-bit stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         SSCSTACK PUSH,                 Get stack area                 +\n               LEN=@LB_Dynam_Length,     this long                     +\n               STACK=(R2)                using this stack\n\n         LR    R3,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LHI   R1,@LB_Dynam_Length       Its length\n         LA    R14,0                    Clear source address\n         LA    R15,0                     and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R3                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*-------------------------------------------------------------------*\n         ST    R13,4(0,R1)              Chain\n         ST    R1,8(0,R13)               saveareas\n         LR    R13,R1                   Load dynam base\n         USING @LB_Dynam,R13            Assign a base\n         L     R15,@LB_Dynam+4          Get A(HSA)\n         LM    R0,R3,20(R15)            Restore callers registers\n\n         L     R15,4(0,R1)              A(31-bit Stack Pointer)\n         ST    R15,@LB_31Bit_Stack_Ptr_Ptr Save it\n         L     R15,8(0,R1)              A(24-bit Stack Pointer)\n         ST    R15,@LB_24Bit_Stack_Ptr_Ptr Save it\n\n*---------------------------------------------------------------------*\n*   Go process the command, based on the contents of R4               *\n*---------------------------------------------------------------------*\n\nLB0030   DS    0H\n*---------------------------------------------------------------------*\n*   ISPF(S) requested - if not already active, reset flags            *\n*---------------------------------------------------------------------*\n         LTR   R4,R4                    R4 = 0 (ISPF(S)?)\n         JNZ   LB0040                   No, skip\n         TM    @_ISPF_SPACE,L'@_ISPF_SPACE Already active?\n         JO    LB8010                   Yes, error\n         NI    @_ISPF_BRIF,X'FF'-L'@_ISPF_BRIF    No, reset\n         NI    @_ISPF_EDIF,X'FF'-L'@_ISPF_EDIF     ISPF\n         OI    @_ISPF_SPACE,L'@_ISPF_SPACE           flags\n         J     LB0070                   and skip\n\nLB0040   DS    0H\n*---------------------------------------------------------------------*\n*   ISPF(E) requested - if not already active, reset flags            *\n*---------------------------------------------------------------------*\n         CHI   R4,4                     R4 = 4 (ISPF(E)?)\n         JNE   LB0050                   No, skip\n         TM    @_ISPF_EDIF,L'@_ISPF_EDIF Already in EDIF?\n         JO    LB8010                   Yes, error\n         NI    @_ISPF_SPACE,X'FF'-L'@_ISPF_SPACE  No, reset\n         NI    @_ISPF_BRIF,X'FF'-L'@_ISPF_BRIF     ISPF\n         OI    @_ISPF_EDIF,L'@_ISPF_EDIF            flags\n         J     LB0070                   and skip\n\nLB0050   DS    0H\n*---------------------------------------------------------------------*\n*   ISPF(B) requested - if not already active, reset flags            *\n*---------------------------------------------------------------------*\n         CHI   R4,8                     R4 = 8 (ISPF(B)?)\n         JNE   LB0060                   No, skip\n         TM    @_ISPF_BRIF,L'@_ISPF_BRIF Already in BRIF?\n         JO    LB8010                   Yes, error\n         NI    @_ISPF_SPACE,X'FF'-L'@_ISPF_SPACE  No, reset\n         NI    @_ISPF_EDIF,X'FF'-L'@_ISPF_EDIF     ISPF\n         OI    @_ISPF_BRIF,L'@_ISPF_BRIF            flags\n         J     LB0070                   and skip\n\nLB0060   DS    0H\n*---------------------------------------------------------------------*\n*   ISPF(N) requested - reset all the ISPF flags                      *\n*---------------------------------------------------------------------*\n         CHI   R4,12                    R4 = 12 (ISPF(N)?)\n         JNE   LB0080                   No, ignore it\n         NI    @_ISPF_SPACE,X'FF'-L'@_ISPF_SPACE\n         NI    @_ISPF_EDIF,X'FF'-L'@_ISPF_EDIF\n         NI    @_ISPF_BRIF,X'FF'-L'@_ISPF_BRIF\n         NI    @_ISPF_Explicit,X'FF'-L'@_ISPF_Explicit\n         J     LB0070                   and skip\n\nLB0070   DS    0H\n*---------------------------------------------------------------------*\n*   Turn on the re-display requested flag ...                         *\n*---------------------------------------------------------------------*\n         OI    @_ReDisplay,L'@_ReDisplay Say we need a redisplay\n\nLB0080   DS    0H\n*---------------------------------------------------------------------*\n*   ... and exit                                                      *\n*---------------------------------------------------------------------*\n         LA    R15,0                    Clear return code\n         J     LB9010                   and exit\n\nLB8010   DS    0H\n*-------------------------------------------------------------------*\n*    The requested display mode is already active - define ISPF     *\n*   messages, and exit                                              *\n*-------------------------------------------------------------------*\n         LA    R15,=CL8'VDEFINE'        ISPF Function\n         ST    R15,@LB_ISPF_Parms       Save it\n         LA    R15,=CL8'CHAR'           Character variables\n         ST    R15,@LB_ISPF_Parms+12 Save it\n\n         LA    R15,=CL8'ZEDSMSG'        Variable name\n         ST    R15,@LB_ISPF_Parms+4     Save it\n         LA    R15,LB_Curr_Act_SMsg     Short message\n         ST    R15,@LB_ISPF_Parms+8     Save it\n         LA    R15,=AL4(L'LB_Curr_Act_SMsg) Length of message\n         ST    R15,@LB_ISPF_Parms+16 Save it\n         OI    @LB_ISPF_Parms+16,X'80' Flag end of list\n         LA    R1,@LB_ISPF_Parms        A(Parmlist)\n         L     R15,@_ISPLINK            A(ISPF Interface)\n         BASR  R14,R15                  Go do it\n\n         LA    R15,=CL8'ZEDLMSG'        Variable name\n         ST    R15,@LB_ISPF_Parms+4     Save it\n         LA    R15,LB_Curr_Act_LMsg     Long message\n         ST    R15,@LB_ISPF_Parms+8     Save it\n         LA    R15,=AL4(L'LB_Curr_Act_LMsg) Length of message\n         ST    R15,@LB_ISPF_Parms+16 Save it\n         OI    @LB_ISPF_Parms+16,X'80' Flag end of list\n         LA    R1,@LB_ISPF_Parms        A(Parmlist)\n         L     R15,@_ISPLINK            A(ISPF Interface)\n         BASR  R14,R15                  Go do it\n\n         LA    R15,=CL8'SETMSG'         Yes, ISPF Function\n         ST    R15,@LB_ISPF_Parms       Save it\n         LA    R15,=CL8'ISRZ001'        A(Message ID)\n         ST    R15,@LB_ISPF_Parms+4     Save it\n         OI    @LB_ISPF_Parms+4,X'80' Mark end of list\n         LA    R1,@LB_ISPF_Parms        Point to ISPF parms\n         L     R15,@_ISPLINK            A(Interface routine)\n         BASR  R14,R15                  Go do it\n\n         LA    R15,0                    Clear return code\n         J     LB9010                   and exit\n\nLB9010   DS    0H\n*-------------------------------------------------------------------*\n*    Free up our local storage ...                                  *\n*-------------------------------------------------------------------*\n         LR    R3,R15                   Save return code\n\n         LA    R1,@LB_Dynam             A(Local storage)\n         L     R2,@LB_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         L     R13,4(0,R13)             Rescue A(HSA)\n\n         SSCSTACK POP,                  Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=(R2)                on this stack\n\n         LR    R15,R3                   Restore return code\n\n*-------------------------------------------------------------------*\n*    ... and return to caller                                       *\n*-------------------------------------------------------------------*\n         L     R14,12(0,R13)            Restore return address\n         LM    R0,R12,20(R13)           Restore regs other than R15\n         BSM   0,R14                    and return\n\nLB_Literals DS  0H\n\nLB_Curr_Act_SMsg     DC  C'Currently active'\nLB_Curr_Act_LMsg     DC  C'Requested display mode already active'\n\n         LTORG\n\nLB_Literals_End DS  0H\n\n\n@LB_Dynam                 DSECT\n                          DS    18F     O/S style save area\n@LB_31Bit_Stack_Ptr_Ptr   DS    AL4     A(31-bit Stack Ptr)\n@LB_24Bit_Stack_Ptr_Ptr   DS    AL4     A(24-bit Stack Ptr)\n@LB_ISPF_Parms            DS    5AL4    ISPF Parm List\n                          DS    0D\n@LB_Dynam_Length          EQU   *-@LB_Dynam\n\n\n&PGMNAME CSECT\n\n         DROP  ,\n         POP   USING\n\n         TITLE 'LC0010: Process OUTPUT Primary Command'\n\n         PUSH  USING\n\nLC0010   DS    0H\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Routine   : LC0010                                                 *\n*                                                                     *\n*  Abstract  : Process OUTPUT primary command                         *\n*                                                                     *\n*  Inputs    : R1 : ---> A(@_Dynam)                                   *\n*                        A(31-bit Stack Pointer)                      *\n*                        A(24-bit Stack Pointer)                      *\n*                        A(line command operands)                     *\n*                        Length of operands                           *\n*  Outputs   : R15: 0                                                 *\n*                                                                     *\n*  Notes     :                                                        *\n*                                                                     *\n*  History:    2003/10/07 SDDA030 - V2.21                             *\n*                                   New                               *\n*              2006/04/21 SDDA030 - V2.24                             *\n*                                   Used standardised calling sequence*\n*                                                                     *\n*              ____/__/__ _______                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         STM   R14,R12,12(R13)          Save callers registers\n         LARL  R11,LC_Literals          Point to our literals\n         USING (LC_Literals,LC_Literals_End),R11 Tell the assembler\n\n         L     R12,0(0,R1)              A(@_Dynam)\n         USING @_Dynam,R12              Tell the assembler\n\n*-------------------------------------------------------------------*\n*    Get an area on the stack for our local storage                 *\n*-------------------------------------------------------------------*\n         L     R2,4(0,R1)               A(31-bit stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         SSCSTACK PUSH,                 Get stack area                 +\n               LEN=@LC_Dynam_Length,     this long                     +\n               STACK=(R2)                using this stack\n\n         LR    R3,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LHI   R1,@LC_Dynam_Length       Its length\n         LA    R14,0                    Clear source address\n         LA    R15,0                     and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R3                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*-------------------------------------------------------------------*\n         ST    R13,4(0,R1)              Chain\n         ST    R1,8(0,R13)               saveareas\n         LR    R13,R1                   Load dynam base\n         USING @LC_Dynam,R13            Assign a base\n         L     R15,@LC_Dynam+4          Get A(HSA)\n         LM    R0,R3,20(R15)            Restore callers registers\n\n         L     R15,4(0,R1)              A(31-bit Stack Pointer)\n         ST    R15,@LC_31Bit_Stack_Ptr_Ptr Save it\n         L     R15,8(0,R1)              A(24-bit Stack Pointer)\n         ST    R15,@LC_24Bit_Stack_Ptr_Ptr Save it\n\n\n*-------------------------------------------------------------------*\n*    This option is not yet supported                               *\n*-------------------------------------------------------------------*\n         LA    R15,=CL8'VDEFINE'        ISPF Function\n         ST    R15,@LC_ISPF_Parms       Save it\n         LA    R15,=CL8'CHAR'           Character variables\n         ST    R15,@LC_ISPF_Parms+12 Save it\n\n         LA    R15,=CL8'ZEDSMSG'        Variable name\n         ST    R15,@LC_ISPF_Parms+4     Save it\n         LA    R15,LC_Unsupport_SMsg    Short message\n         ST    R15,@LC_ISPF_Parms+8     Save it\n         LA    R15,=AL4(L'LC_Unsupport_SMsg) Length of message\n         ST    R15,@LC_ISPF_Parms+16 Save it\n         OI    @LC_ISPF_Parms+16,X'80' Flag end of list\n         LA    R1,@LC_ISPF_Parms        A(Parmlist)\n         L     R15,@_ISPLINK            A(ISPF Interface)\n         BASR  R14,R15                  Go do it\n\n         LA    R15,=CL8'ZEDLMSG'        Variable name\n         ST    R15,@LC_ISPF_Parms+4     Save it\n         LA    R15,LC_Unsupport_LMsg    Long message\n         ST    R15,@LC_ISPF_Parms+8     Save it\n         LA    R15,=AL4(L'LC_Unsupport_LMsg) Length of message\n         ST    R15,@LC_ISPF_Parms+16 Save it\n         OI    @LC_ISPF_Parms+16,X'80' Flag end of list\n         LA    R1,@LC_ISPF_Parms        A(Parmlist)\n         L     R15,@_ISPLINK            A(ISPF Interface)\n         BASR  R14,R15                  Go do it\n\n         LA    R15,=CL8'SETMSG'         Yes, ISPF Function\n         ST    R15,@LC_ISPF_Parms       Save it\n         LA    R15,=CL8'ISRZ001'        A(Message ID)\n         ST    R15,@LC_ISPF_Parms+4     Save it\n         OI    @LC_ISPF_Parms+4,X'80' Mark end of list\n         LA    R1,@LC_ISPF_Parms        Point to ISPF parms\n         L     R15,@_ISPLINK            A(Interface routine)\n         BASR  R14,R15                  Go do it\n\n         LA    R15,0                    Clear return code\n         J     LC9010                   and exit\n\n\nLC9010   DS    0H\n*-------------------------------------------------------------------*\n*    Free up our local storage ...                                  *\n*-------------------------------------------------------------------*\n         LR    R3,R15                   Save return code\n\n         LA    R1,@LC_Dynam             A(Local storage)\n         L     R2,@LC_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         L     R13,4(0,R13)             Rescue A(HSA)\n\n         SSCSTACK POP,                  Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=(R2)                on this stack\n\n         LR    R15,R3                   Restore return code\n\n*-------------------------------------------------------------------*\n*    ... and return to caller                                       *\n*-------------------------------------------------------------------*\n         L     R14,12(0,R13)            Restore return address\n         LM    R0,R12,20(R13)           Restore regs other than R15\n         BSM   0,R14                    and return\n\nLC_Literals DS  0H\n\nLC_Unsupport_SMsg     DC   C'Unsupported'\nLC_Unsupport_LMsg     DC   C'This command is not yet implemented'\n\n\n         LTORG\n\nLC_Literals_End DS  0H\n\n\n@LC_Dynam                 DSECT\n                          DS    18F    O/S style save area\n@LC_31Bit_Stack_Ptr_Ptr   DS    AL4    A(31-bit Stack Ptr)\n@LC_24Bit_Stack_Ptr_Ptr   DS    AL4    A(24-bit Stack Ptr)\n                          DS    0F     Alignment\n@LC_ISPF_Parms            DS    5AL4   ISPF Parm List\n@LC_ISPF_VCOPY_Lens       DS    FL4    ZCMD Length\n@LC_ISPF_VCOPY_Ptrs       DS    AL4    ZCMD Address\n@LC_ZCMD_Ptr              DS    AL4    A(ZCMD)\n@LC_ZCMD_Length           DS    FL4    Length of ZCMD\n                          DS    0D\n@LC_Dynam_Length          EQU   *-@LC_Dynam\n\n\n&PGMNAME CSECT\n\n         DROP  ,\n         POP   USING\n         TITLE 'S00010: WAIT for subtasks to complete'\n\n         PUSH  USING\n\nS00010   DS    0H\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Routine   : S00010                                                 *\n*                                                                     *\n*  Abstract  : WAIT for subtasks to complete, DETACH them, and free   *\n*              SubTask_Area                                           *\n*                                                                     *\n*  Inputs    : R1 : ---> A(@_Dynam)                                   *\n*                        A(31-bit Stack Pointer)                      *\n*                        A(24-bit Stack Pointer)                      *\n*  Outputs   : R15: 0:                                                *\n*                                                                     *\n*  Notes     :                                                        *\n*                                                                     *\n*  History:    2003/10/07 SDDA030 - V2.21                             *\n*                                   New.                              *\n*              2006/04/21 SDDA030 - V2.24                             *\n*                                   Used standardised calling sequence*\n*              ____/__/__ _______                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         STM   R14,R12,12(R13)          Save callers registers\n         LARL  R11,S_Literals           Point to our literals\n         USING (S_Literals,S_Literals_End),R11 Tell the assembler\n\n         L     R12,0(0,R1)              A(@_Dynam)\n         USING @_Dynam,R12              Tell the assembler\n\n*-------------------------------------------------------------------*\n*    Get an area on the stack for our local storage                 *\n*-------------------------------------------------------------------*\n         L     R2,4(0,R1)               A(31-bit stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         SSCSTACK PUSH,                 Get stack area                 +\n               LEN=@S_Dynam_Length,      this long                     +\n               STACK=(R2)                using this stack\n\n         LR    R3,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LHI   R1,@S_Dynam_Length        Its length\n         LA    R14,0                    Clear source address\n         LA    R15,0                     and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R3                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*-------------------------------------------------------------------*\n         ST    R13,4(0,R1)              Chain\n         ST    R1,8(0,R13)               saveareas\n         LR    R13,R1                   Load dynam base\n         USING @S_Dynam,R13             Assign a base\n         L     R15,@S_Dynam+4           Get A(HSA)\n         LM    R0,R3,20(R15)            Restore callers registers\n\n         L     R15,4(0,R1)              A(31-bit Stack Pointer)\n         ST    R15,@S_31Bit_Stack_Ptr_Ptr Save it\n         L     R15,8(0,R1)              A(24-bit Stack Pointer)\n         ST    R15,@S_24Bit_Stack_Ptr_Ptr Save it\n\n*-------------------------------------------------------------------*\n*    If there is a Subtask_Area ...                                 *\n*-------------------------------------------------------------------*\n         ICM   R1,B'1111',@_SubTask_Area_Ptr Get A(SubTask Area)\n         JZ    S00100                  None, exit quick smart\n         ICM   R0,B'1111',SubTask_Area_Hdr_Count-SubTask_Area_Hdr(R1)\n         JZ    S00100                  None, go free it\n\n*-------------------------------------------------------------------*\n*    ... get an area for our ECB list                               *\n*-------------------------------------------------------------------*\n         MHI   R0,4                     (# ents * len of ECB ptr)\n\n         L     R2,@S_31Bit_Stack_Ptr_Ptr A(31-bit stack Ptr)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         SSCSTACK PUSH,                 Get stack area                 +\n               LEN=(0),                  this long                     +\n               STACK=(R2)                using this stack\n\n         ST    R1,@S_ECBLIST_Ptr       Save it\n\nS00020   DS    0H\n*-------------------------------------------------------------------*\n*    Build our ECBLIST, containing a pointer to each ECB that has   *\n*   not yet been POSTed. If the ECB has been POSTed, DETACH the TCB,*\n*   unless we have already done so.                                 *\n*-------------------------------------------------------------------*\n         ICM   R15,B'1111',@_SubTask_Area_Ptr A(SubTask Area)\n         JZ    S00100                  None, all done\n         ICM   R14,B'1111',SubTask_Area_Hdr_Count-SubTask_Area_Hdr(R15)\n         JZ    S00100                  None, exit\n         AHI   R15,SubTask_Area_Hdr_Length A(1st SubTask Entry)\n         ICM   R1,B'1111',@S_ECBLIST_Ptr A(Our ECBLIST)\n         JZ    S00100                  None, all done\nS00030   DS    0H\n         TM    SubTask_Area_Ent_ECB-SubTask_Area_Ent(R15),X'40' POSTed?\n         JO    S00040                  Yes, go DETACH TCB\n         ST    R15,0(0,R1)             No, Add to ECBLIST\n         AHI   R1,4                    Bump ECBLIST Ptr\n         J     S00050                  and skip\nS00040   DS    0H\n         ICM   R0,B'1111',SubTask_Area_Ent_TCB-SubTask_Area_Ent(R15)\n         JZ    S00050                  No TCB, skip\n         STM   R14,R1,@S_RSave         Save our registers\n         LA    R1,SubTask_Area_Ent_TCB-SubTask_Area_Ent(R15)\n         DETACH (1),                    Yes, DETACH it                 +\n               STAE=NO                   without invoking ESTAE Rtn\n         LM    R14,R1,@S_RSave         Restore our registers\n         LA    R0,0                    Clear TCB pointer\n         ST    R0,SubTask_Area_Ent_TCB-SubTask_Area_Ent(R15)\nS00050   DS    0H\n         AHI   R15,SubTask_Area_Ent_Length A(Stuff for next TCB)\n         BRCT  R14,S00030              and check it out\n\n*-------------------------------------------------------------------*\n*    If there are any ECBs not yet POSTed ...                       *\n*-------------------------------------------------------------------*\n         L     R0,@S_ECBLIST_Ptr       A(ECBLIST)\n         CR    R0,R1                   Anything in it?\n         JE    S00100                  No, we're all done\n\n*-------------------------------------------------------------------*\n*    ... WAIT for them to complete ...                              *\n*-------------------------------------------------------------------*\n         AHI   R1,-4                   Yes, back up to A(last ECB)\n         OI    0(R1),X'80'             Flag it as last\n         SLR   R1,R0                   Calculate nbr\n         SRL   R1,2                     of ECBS in\n         AHI   R1,1                     list\n         LR    R0,R1                   In proper register\n         L     R1,@S_ECBLIST_Ptr       A(ECB list)\n         WAIT  (R0),ECBLIST=(R1)       Wait for our subtasks\n\n*-------------------------------------------------------------------*\n*    ... and do it all again                                        *\n*-------------------------------------------------------------------*\n         J     S00020                  and do it all again\n\nS00100   DS    0H\n*-------------------------------------------------------------------*\n*    We're all done here, so free up the ECBLIST, if required ...   *\n*-------------------------------------------------------------------*\n         ICM   R1,B'1111',@S_ECBLIST_Ptr A(ECBLIST)\n         JZ    S00110                  None, skip\n\n         L     R2,@S_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         SSCSTACK POP,                  Free the ECBLIST               +\n               ADDR=(R1),                starting here                 +\n               STACK=(R2)                on this stack\n\nS00110   DS    0H\n*-------------------------------------------------------------------*\n*    ... and the SubTask_Area, if required ...                      *\n*-------------------------------------------------------------------*\n         ICM   R1,B'1111',@_SubTask_Area_Ptr A(SubTask Area)\n         JZ    S00120                  Nothing, skip\n         L     R0,SubTask_Area_Hdr_Len-SubTask_Area_Hdr(0,R1) Length\n\n         BASR  R2,0\n         USING (*,S00120_End-1),R2\n         STORAGE RELEASE,               Free the SubTask Area          +\n               ADDR=(1),                 starting here                 +\n               LENGTH=(0)                for this long\nS00120_End DS  0H\n         DROP  R2\n\n         LA    R0,0                     Clear work reg\n         ST    R0,@_SubTask_Area_Ptr    No more SubTask Area\n\nS00120   DS    0H\n*-------------------------------------------------------------------*\n*    ... and exit.                                                  *\n*-------------------------------------------------------------------*\n         LA    R15,0                    Clear return code\n         J     S90010                   and exit\n\nS90010   DS    0H\n*-------------------------------------------------------------------*\n*    Free up our local storage ...                                  *\n*-------------------------------------------------------------------*\n         LR    R3,R15                   Save return code\n\n         LA    R1,@S_Dynam              A(Local storage)\n         L     R2,@S_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         L     R13,4(0,R13)             Rescue A(HSA)\n\n         SSCSTACK POP,                  Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=(R2)                on this stack\n\n         LR    R15,R3                   Restore return code\n\n*-------------------------------------------------------------------*\n*    ... and return to caller                                       *\n*-------------------------------------------------------------------*\n         L     R14,12(0,R13)            Restore return address\n         LM    R0,R12,20(R13)           Restore callers regs\n         BSM   0,R14                    and return\n\nS_Literals  DS  0H\n\n         LTORG\n\nS_Literals_End  DS  0H\n\n\n@S_Dynam                  DSECT\n@S_SaveArea               DS    18F    O/S style save area\n@S_31Bit_Stack_Ptr_Ptr    DS    AL4    A(31-bit Stack Ptr)\n@S_24Bit_Stack_Ptr_Ptr    DS    AL4    A(24-bit Stack Ptr)\n\n@S_ECBLIST_Ptr            DS    AL4    A(ECBLIST)\n@S_RSave                  DS    4FL4   Temp reg save area\n\n                          DS    0D\n@S_Dynam_Length           EQU   *-@S_Dynam\n\n\n&PGMNAME CSECT\n\n         DROP  ,\n         POP   USING\n         TITLE 'T00010: Return SMS Storgrp'\n\n         PUSH  USING\n\nT00010   DS    0H\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Routine   : T00010                                                 *\n*                                                                     *\n*  Abstract  : Return pointers to the STORGRP name and SMS Status     *\n*              for a volser                                           *\n*                                                                     *\n*  Inputs    : R1 : ---> A(@_Dynam)                                   *\n*                        A(31-bit Stack Pointer)                      *\n*                        A(24-bit Stack Pointer)                      *\n*                        A(Volser)                                    *\n*                        A(VLD Anchor)                                *\n*  Outputs   : R15: 0: STORGRP found                                  *\n*                   4: STORGRP not found (??)                         *\n*                   8: SMS not active                                 *\n*              R0    : A(SMS Status)                                  *\n*              R1    : A(STORGRP Len, Name)                           *\n*                                                                     *\n*  Notes     : To try to reduce the number of times we have to call   *\n*              SMS, whenever we ask SMS about the StorGrp for a       *\n*              volume, we also ask for all the volsers in that        *\n*              StorGrp. We chain these VLDs (Volume Definitions), and *\n*              search them for the volser before asking SMS for the   *\n*              StorGrp.                                               *\n*              If A(Volser) is 0, all in-storage VLDs, chained off    *\n*              VLD Anchor, are freed.                                 *\n*              The IEFSSREQs to SMS are modelled on those found in    *\n*              SHOWMVS (Thanks Gilbert/Roland).                       *\n*              We clobber the VLDPID field and the next 2 bytes with: *\n*               0-3 A(Next VLD)                                       *\n*               4-7 Length of VLD                                     *\n*               8-9 SMS System number                                 *\n*                                                                     *\n*  History:    2002/03/11 SDDA030 - V2.17                             *\n*                                 - New                               *\n*              2003/10/07 SDDA030 - V2.21                             *\n*                                 - Corrected bug getting correct SMS *\n*                                   status (we make an additional     *\n*                                   call to SMS to get the system-ids)*\n*              2004/10/15 SDDA030 - V2.22                             *\n*                                 - Corrected bug where we overlayed  *\n*                                   the SMS System number with the    *\n*                                   length of the VLD.                *\n*                                 - Resequenced labels                *\n*              2006/04/21 SDDA030 - V2.24                             *\n*                                 - Used standardised calling sequence*\n*              ____/__/__ _______                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         STM   R14,R12,12(R13)          Save callers registers\n         LARL  R11,T_Literals           Point to our literals\n         USING (T_Literals,T_Literals_End),R11 Tell the assembler\n\n         L     R12,0(0,R1)              A(@_Dynam)\n         USING @_Dynam,R12              Tell the assembler\n\n*-------------------------------------------------------------------*\n*    Get an area on the stack for our local storage                 *\n*-------------------------------------------------------------------*\n         L     R2,4(0,R1)               A(31-bit stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         SSCSTACK PUSH,                 Get stack area                 +\n               LEN=@T_Dynam_Length,      this long                     +\n               STACK=(R2)                using this stack\n\n         LR    R3,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LHI   R1,@T_Dynam_Length        Its length\n         LA    R14,0                    Clear source address\n         LA    R15,0                     and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R3                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*-------------------------------------------------------------------*\n         ST    R13,4(0,R1)              Chain\n         ST    R1,8(0,R13)               saveareas\n         LR    R13,R1                   Load dynam base\n         USING @T_Dynam,R13             Assign a base\n         L     R15,@T_Dynam+4           Get A(HSA)\n         LM    R0,R3,20(R15)            Restore callers registers\n\n         L     R15,4(0,R1)              A(31-bit Stack Pointer)\n         ST    R15,@T_31Bit_Stack_Ptr_Ptr Save it\n         L     R15,8(0,R1)              A(24-bit Stack Pointer)\n         ST    R15,@T_24Bit_Stack_Ptr_Ptr Save it\n\n*-------------------------------------------------------------------*\n*    If we have a volser ...                                        *\n*-------------------------------------------------------------------*\n         ICM   R3,B'1111',12(R1)       Get A(Volser)\n         JZ    T00130                  None, free VLDs\n\n*-------------------------------------------------------------------*\n*    ... check the existing VLDs for the volser                     *\n*-------------------------------------------------------------------*\n         L     R1,16(0,R1)             A(VLD Chain Anchor)\n         AHI   R1,-(VLDPID-VLD)        Pretend we are a VLD Ptr\n         NI    @T_Volser_in_VLD,X'FF'-L'@T_Volser_in_VLD Off flag\n         LHI   R15,-1                  We have no\n         STH   R15,@T_SMS_SYSNum        no SMS System nbr\n         J     T00050                  and run chain\nT00020   DS    0H\n         ICM   R14,B'1111',VLDPCNT-VLD(R1) Number vols\n         JNP   T00050                  None, try next VLD\n         LA    R15,VLDEF-VLD(0,R1)     OK, point to 1st\nT00030   DS    0H\n         CLC   =HL2'6',VLDVSLEN-VLDEF(R15)  Right length for a volser?\n         JNE   T00040                  No, skip this entry\n         CLC   VLDVSER-VLDEF(L'VLDVSER,R15),0(R3)\n         JE    T00110                  Found our volser, skip\nT00040   DS    0H\n         A     R15,VLDPLEN-VLD(0,R1)   A(Next VLD)\n         BRCT  R14,T00030              and check it out\n         TM    @T_Volser_in_VLD,L'@T_Volser_in_VLD Should it be here?\n         JNO   T00050                  Not necessarily, OK\n         DC    H'0'                    It should be, ABEND\nT00050   DS    0H\n         ICM   R15,B'1111',VLDPID-VLD(R1) A(Next VLD)\n         JZ    T00060                  None, skip\n         LR    R1,R15                  Load up proper register\n         MVC   @T_SMS_SYSNum,VLDPID+8-VLD(R1) Save SMS Sys 'number'\n         J     T00020                  and check it out\n\nT00060   DS    0H\n*-------------------------------------------------------------------*\n*    We couldn't find the volser in our in-storage VLDs (meaning    *\n*   that this is the 1st volser we have come across in this         *\n*   STORGRP), so go get the STORGRP name from SMS.                  *\n*-------------------------------------------------------------------*\n         ST    R1,@T_Last_VLD_Ptr      Save A(Last VLD)\n         LH    R15,@T_SMS_SYSNum       Get SMS system 'number'\n         CHI   R15,-1                  Do we have one?\n         JNE   T00100                  Yes, OK\n\n*-------------------------------------------------------------------*\n*    This is the 1st VLD we are getting - before we do so, get the  *\n*   base configuration data (we have to know our system 'number' to *\n*   get the correct SMS status for the volumes).                    *\n*-------------------------------------------------------------------*\n         L     R15,CVTPTR              Point to CVT\n         L     R15,CVTJESCT-CVTMAP(,R15) JES Communication Table\n         L     R15,JESCTEXT-JESCT(,R15)  JESCT Extension\n         ICM   R15,B'1111',JESSMSIB-JESPEXT(R15) SMS SSIB\n         JZ    T00100                  SMS unavailable, skip\n\n         XC    @T_SMS_SSOB,@T_SMS_SSOB Clear the SSOB\n         MVI   @T_SMS_SSOB+SSOBLEN+1-SSOB,SSOBHSIZ Set length\n         MVC   @T_SMS_SSOB+SSOBID-SSOB(L'SSOBID),=C'SSOB' ID it\n         MVI   @T_SMS_SSOB+SSOBFUNC+1-SSOB,SSOBSSMS Function\n         L     R15,CVTPTR              Point to CVT\n         L     R15,CVTJESCT-CVTMAP(,R15) JES Communication Table\n         L     R15,JESCTEXT-JESCT(,R15)  JESCT Extension\n         L     R15,JESSMSIB-JESPEXT(R15) SMS SSIB\n         ST    R15,@T_SMS_SSOB+SSOBSSIB-SSOB Save it\n\n         LA    R15,@T_SMS_SSSA         SSSA Work Area\n         ST    R15,@T_SMS_SSOB+SSOBINDV-SSOB Update SSOB\n\n         XC    @T_SMS_SSSA,@T_SMS_SSSA Clear SSSA\n         LHI   R15,L'@T_SMS_SSSA       Get its length\n         STH   R15,@T_SMS_SSSA+SSSALEN-IEFSSSA Update SSSA\n         MVC   @T_SMS_SSSA+SSSAID-IEFSSSA(L'SSSAID),=C'SSSA' ID it\n         MVI   @T_SMS_SSSA+SSSAVER+1-IEFSSSA,SSOBSSVR Version\n         MVI   @T_SMS_SSSA+SSSASFN+1-IEFSSSA,SSSAACTV Sub-Function\n         MVI   @T_SMS_SSSA+SSSAIFLG-IEFSSSA,SSSANAUT Non-APF\n\n         MVI   @T_SMS_SSSA+SSSA1TYP-IEFSSSA,SSSA1CON Return Config\n\n         LHI   R15,L'@T_SMS_BCD                Len of Config Data\n         ST    R15,@T_SMS_SSSA+SSSA1LEN-IEFSSSA Save it\n         LA    R15,@T_SMS_BCD                  A(Config Data)\n         ST    R15,@T_SMS_SSSA+SSSA1PTR-IEFSSSA Save the address\n\n         LA    R15,@T_SMS_SSOB         A(SSOB)\n         ST    R15,@T_SMS_SSOB_Ptr     Save the address\n         LA    R1,@T_SMS_SSOB_Ptr      Point to the address\n\n         IEFSSREQ                      Call SMS\n\n         LTR   R15,R15                 SMS active?\n         JNZ   T00100                  No, exit quick smart\n\n         ICM   R15,B'1111',@T_SMS_SSOB+SSOBRETN-SSOB Check RC\n         JNZ   T00100                  Not good, skip SMS stuff\n\n*-------------------------------------------------------------------*\n*    We now have an IGDBCD, which is not documented or distributed  *\n*   by IBM. From SHOWMVS, we know that this data will contain our   *\n*   system ID (assuming, of course, we're SMSd). Rather than define *\n*   our own DSECT for this area, we search it for our system-id; if *\n*   we find it, we save our system 'number'.                        *\n*-------------------------------------------------------------------*\n         L     R1,CVTPTR                A(CVT)\n         LA    R1,CVTSNAME-CVT(R1)      A(Our System name)\n         LA    R15,@T_SMS_BCD           Point to config data\n         LHI   R14,L'@T_SMS_BCD-(L'CVTSNAME-1) Len of config data\nT00070   DS    0H\n         CLC   0(L'CVTSNAME,R1),0(R15)  Found our system?\n         JE    T00080                   Yes, skip\n         LA    R15,1(0,R15)             Not yet, bump pointer\n         BRCT  R14,T00070               and keep checking\n         XR    R1,R1                    Sysname NF. Use 0, like SHOWZOS\n         J     T00099                   Found SYSPLEX name instead\n*        J     T80010                   Not good, exit with error\nT00080   DS    0H\n         LA    R14,@T_SMS_BCD           A(Start of area)\n         LR    R0,R15                   Save A(Our name)\nT00090   DS    0H\n         AHI   R15,-L'CVTSNAME          Back up to prev system\n         CR    R15,R14                  Too far?\n         JL    T80010                   Yes, we're lost\n         TRT   0(L'CVTSNAME,R15),T_TRT  A valid sysname?\n         JZ    T00090                   Yes, check prev\n\n         AHI   R0,-L'CVTSNAME           Offset of last good name\n         SR    R0,R15                   offset to our sysname\n         SRDL  R0,32                    into correct register\n         LA    R15,L'CVTSNAME           Len of 1 system name\n         DR    R0,R15                   Calc system 'number'\nT00099   DS    0H\n         STH   R1,@T_SMS_SYSNum         Save it\nT00100   DS    0H\n         L     R15,CVTPTR              Point to CVT\n         L     R15,CVTJESCT-CVTMAP(,R15) JES Communication Table\n         L     R15,JESCTEXT-JESCT(,R15)  JESCT Extension\n         ICM   R15,B'1111',JESSMSIB-JESPEXT(R15) SMS SSIB\n         JZ    T80010                  SMS unavailable, skip\n\n         XC    @T_SMS_SSOB,@T_SMS_SSOB Clear the SSOB\n         MVI   @T_SMS_SSOB+SSOBLEN+1-SSOB,SSOBHSIZ Set length\n         MVC   @T_SMS_SSOB+SSOBID-SSOB(L'SSOBID),=C'SSOB' ID it\n         MVI   @T_SMS_SSOB+SSOBFUNC+1-SSOB,SSOBSSMS Function\n         L     R15,CVTPTR              Point to CVT\n         L     R15,CVTJESCT-CVTMAP(,R15) JES Communication Table\n         L     R15,JESCTEXT-JESCT(,R15)  JESCT Extension\n         L     R15,JESSMSIB-JESPEXT(R15) SMS SSIB\n         ST    R15,@T_SMS_SSOB+SSOBSSIB-SSOB Save it\n\n         LA    R15,@T_SMS_SSSA         SSSA Work Area\n         ST    R15,@T_SMS_SSOB+SSOBINDV-SSOB Update SSOB\n\n         XC    @T_SMS_SSSA,@T_SMS_SSSA Clear SSSA\n         LHI   R15,L'@T_SMS_SSSA       Get its length\n         STH   R15,@T_SMS_SSSA+SSSALEN-IEFSSSA Update SSSA\n         MVC   @T_SMS_SSSA+SSSAID-IEFSSSA(L'SSSAID),=C'SSSA' ID it\n         MVI   @T_SMS_SSSA+SSSAVER+1-IEFSSSA,SSOBSSVR Version\n         MVI   @T_SMS_SSSA+SSSASFN+1-IEFSSSA,SSSAACTV Sub-Function\n         MVI   @T_SMS_SSSA+SSSAIFLG-IEFSSSA,SSSANAUT Non-APF\n\n         MVI   @T_SMS_SSSA+SSSA1TYP-IEFSSSA,SSSA1VOL Return VLD\n         MVI   @T_SMS_SSSA+SSSA1CNT+3-IEFSSSA,1   1 construct\n         MVI   @T_SMS_SSSA+SSSA1NML+1-IEFSSSA,L'UCBVOLI  Volser Len\n         MVC   @T_SMS_SSSA+SSSA1NAM-IEFSSSA(L'UCBVOLI),0(R3)\n\n         LHI   R15,L'@T_SMS_VLD                Len of VLD\n         ST    R15,@T_SMS_SSSA+SSSA1LEN-IEFSSSA Save it\n         LA    R15,@T_SMS_VLD                  Point VLD\n         ST    R15,@T_SMS_SSSA+SSSA1PTR-IEFSSSA Save the address\n\n         LA    R15,@T_SMS_SSOB         A(SSOB)\n         ST    R15,@T_SMS_SSOB_Ptr     Save the address\n         LA    R1,@T_SMS_SSOB_Ptr      Point to the address\n\n         IEFSSREQ                      Call SMS\n\n         LTR   R15,R15                 SMS active?\n         JNZ   T80010                  No, exit quick smart\n\n         ICM   R15,B'1111',@T_SMS_SSOB+SSOBRETN-SSOB Check RC\n         JNZ   T80020                  Not good, skip SMS stuff\n\n*-------------------------------------------------------------------*\n*    We have the SMS Storgrp for this volser, so now make another   *\n*   request to SMS for all volsers in this STORGRP.                 *\n*-------------------------------------------------------------------*\n         XC    @T_SMS_SSOB,@T_SMS_SSOB Clear the SSOB\n         MVI   @T_SMS_SSOB+SSOBLEN+1-SSOB,SSOBHSIZ Set length\n         MVC   @T_SMS_SSOB+SSOBID-SSOB(L'SSOBID),=C'SSOB' ID it\n         MVI   @T_SMS_SSOB+SSOBFUNC+1-SSOB,SSOBSSMS Function\n         L     R15,CVTPTR              Point to CVT\n         L     R15,CVTJESCT-CVTMAP(,R15) JES Communication Table\n         L     R15,JESCTEXT-JESCT(,R15)  JESCT Extension\n         L     R15,JESSMSIB-JESPEXT(R15) SMS SSIB\n         ST    R15,@T_SMS_SSOB+SSOBSSIB-SSOB Save it\n\n         LA    R15,@T_SMS_SSSA         SSSA Work Area\n         ST    R15,@T_SMS_SSOB+SSOBINDV-SSOB Update SSOB\n\n         XC    @T_SMS_SSSA,@T_SMS_SSSA Clear SSSA\n         LHI   R15,L'@T_SMS_SSSA       Get its length\n         STH   R15,@T_SMS_SSSA+SSSALEN-IEFSSSA Update SSSA\n         MVC   @T_SMS_SSSA+SSSAID-IEFSSSA(L'SSSAID),=C'SSSA' ID it\n         MVI   @T_SMS_SSSA+SSSAVER+1-IEFSSSA,SSOBSSVR Version\n         MVI   @T_SMS_SSSA+SSSASFN+1-IEFSSSA,SSSAACTV Sub-Function\n         MVI   @T_SMS_SSSA+SSSAIFLG-IEFSSSA,SSSANAUT Non-APF\n\n         MVI   @T_SMS_SSSA+SSSA1TYP-IEFSSSA,SSSA1SGV Return VLDs\n         MVI   @T_SMS_SSSA+SSSA1CNT+3-IEFSSSA,1   1 construct\n         MVC   @T_SMS_SSSA+SSSA1NML-IEFSSSA(L'SSSA1NML),@T_SMS_VLD+VLDS+\n               GLEN-VLD               Len of StorGrp Name\n         MVC   @T_SMS_SSSA+SSSA1NAM-IEFSSSA(L'SSSA1NAM),@T_SMS_VLD+VLDS+\n               TGRP-VLD               StorGrp Name\n\n         LA    R15,@T_SMS_SSOB         A(SSOB)\n         ST    R15,@T_SMS_SSOB_Ptr     Save the address\n         LA    R1,@T_SMS_SSOB_Ptr      Point to the address\n\n         IEFSSREQ                      Call SMS\n\n         LTR   R15,R15                 SMS active?\n         JNZ   T80010                  No, exit quick smart\n\n         ICM   R15,B'1111',@T_SMS_SSOB+SSOBRETN-SSOB Check RC\n         JNZ   T80020                  Not good, skip SMS stuff\n\n*-------------------------------------------------------------------*\n*    Chain the new VLD to the others (note that we use the ID field *\n*   (VLDPID) for this) ...                                          *\n*-------------------------------------------------------------------*\n         ICM   R1,B'1111',@T_SMS_SSSA+SSSA1PTR-IEFSSSA A(Returned VLD)\n         JZ    T80020                  Nothing, not good\n         L     R15,@T_Last_VLD_Ptr     OK, A(Last VLD)\n         ST    R1,VLDPID-VLD(0,R15)    Chain this one\n\n*-------------------------------------------------------------------*\n*    ... set up our fields in the new VLD ...                       *\n*-------------------------------------------------------------------*\n         LA    R15,0                   Clear forward pointer ...\n         ST    R15,VLDPID-VLD(0,R1)     ... in the VLD\n         L     R15,@T_SMS_SSSA+SSSA1LEN-IEFSSSA Len of VLD\n         ST    R15,VLDPID+4-VLD(R1)    Save length (for FREEMAIN)\n         MVC   VLDPID+8-VLD(L'@T_SMS_SYSNum,R1),@T_SMS_SYSNum\n\n*-------------------------------------------------------------------*\n*    ... and go check it out.                                       *\n*-------------------------------------------------------------------*\n         OI    @T_Volser_in_VLD,L'@T_Volser_in_VLD It should be here\n         J     T00020                  And check it out\n\nT00110   DS    0H\n*-------------------------------------------------------------------*\n*    We have found our volser in the VLD, set up our return         *\n*   pointers, and exit. At this point, R15 points to the VLDEF      *\n*   for our volume.                                                 *\n*-------------------------------------------------------------------*\n         LA    R0,0                          Assume no SMS Status\n         LH    R1,@T_SMS_SYSNum              Get SMS System 'number'\n         LTR   R1,R1                         Any?\n         JM    T00120                        No, unknown SMS Status\n         MHI   R1,L'VLDSSTAT                 r1 = Offset within status\n         LR    R0,R15                        A(Volume array)\n         A     R0,VLDSYSOF-VLDEF(R15)        A(Status fields)\n         AR    R0,R1                         A(Status on our system)\n\nT00120   DS    0H\n         LA    R1,VLDSGLEN-VLDEF(R15)        A(Storage group length)\n\n         LA    R15,0                         Clear return code\n         J     T90010                        and exit\n\nT00130   DS    0H\n*-------------------------------------------------------------------*\n*    We have been passed a Volser pointer of 0 - by convention,     *\n*   this is a request that we free any VLDs that have been gotten   *\n*   for us                                                          *\n*-------------------------------------------------------------------*\n         ICM   R4,B'1111',16(R1)        VLD Chain Anchor\n         JZ    T00150                   Nothing, OK\nT00140   DS    0H\n         LR    R1,R4                    A(Storage to free)\n         L     R0,VLDPID+4-VLD(0,R1)    Length to free\n         L     R4,VLDPID-VLD(0,R4)      Rescue forward pointer\n         BASR  R2,0\n         USING (*,T00140_End-1),R2\n         STORAGE RELEASE,               Free the old table             +\n               ADDR=(1),                 starting here                 +\n               LENGTH=(0)                for this long\nT00140_End DS  0H\n         DROP  R2\n\n         LTR   R4,R4                    Is there another one?\n         JNZ   T00140                   Yes, go free it\n\nT00150   DS    0H\n         LA    R0,0                     No SMS Status\n         LA    R1,0                     No STORGRP\n         LA    R15,0                    All OK\n         J     T90010                   and exit\n\nT80010   DS    0H\n*-------------------------------------------------------------------*\n*    SMS unavailable, set RC and exit                               *\n*-------------------------------------------------------------------*\n         LA    R1,0                     No SMS StorGrp\n         LA    R0,0                      or status\n         LA    R15,8                    SMS not available\n         J     T90010                   and exit\n\nT80020   DS    0H\n*-------------------------------------------------------------------*\n*    SSOBRETN not 0 on return from SSREQ                            *\n*-------------------------------------------------------------------*\n         LA    R1,0                     No SMS StorGrp\n         LA    R0,0                      or status\n         LA    R15,4                    STORGRP not found\n         J     T90010                   and exit\n\nT90010   DS    0H\n*-------------------------------------------------------------------*\n*    Free up our local storage ...                                  *\n*-------------------------------------------------------------------*\n         L     R14,4(0,R13)             A(HSA)\n         STM   R15,R1,16(R14)           Save rc, A(status), A(STORGRP)\n\n         LA    R1,@T_Dynam              A(Local storage)\n         L     R2,@T_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         L     R13,4(0,R13)             Rescue A(HSA)\n\n         SSCSTACK POP,                  Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=(R2)                on this stack\n\n\n*-------------------------------------------------------------------*\n*    ... and return to caller (note that we updated the callers     *\n*   savearea:   +16: Return Code       R15                          *\n*               +20: A(SMS Status)     R0                           *\n*               +24: A(SMS STORGRP)    R1                           *\n*-------------------------------------------------------------------*\n         LM    R14,R12,12(R13)          Restore callers regs\n         BSM   0,R14                    and return\n\nT_Literals  DS  0H\n\nT_TRT    DC    256XL1'FF'\n         ORG   T_TRT+C' '\n         DC    X'00'\n         ORG   T_TRT+C'$'\n         DC    X'00'\n         ORG   T_TRT+C'#'\n         DC    X'00'\n         ORG   T_TRT+C'@'\n         DC    X'00'\n         ORG   T_TRT+C'A'\n         DC    9XL1'00'\n         ORG   T_TRT+C'J'\n         DC    9XL1'00'\n         ORG   T_TRT+C'S'\n         DC    8XL1'00'\n         ORG   T_TRT+C'0'\n         DC    10XL1'00'\n         ORG\n\n         LTORG\n\nT_Literals_End  DS  0H\n\n\n@T_Dynam                  DSECT\n                          DS    18F    O/S style save area\n@T_31Bit_Stack_Ptr_Ptr    DS    AL4    A(31-bit Stack Ptr)\n@T_24Bit_Stack_Ptr_Ptr    DS    AL4    A(24-bit Stack Ptr)\n\n@T_Last_VLD_Ptr           DS    AL4    A(Last VLD)\n@T_SMS_SSOB_Ptr           DS    AL4    A(SSOB)\n@T_SMS_SYSNum             DS    HL2    SMS System Number\n@T_SMS_SSOB               DS    XL(SSOBHSIZ) SSOB\n@T_SMS_SSSA               DS    XL(SSSALN+SSSA1LN)  SSSA (HDR)\n                          DS    X      Flag Byte\n@T_Volser_in_VLD          EQU   *-1,X'80' 1... .... VLD has Volser\n                          DS    0D\n@T_SMS_VLD                DS    XL((VLDEND-VLD)+(VLDEND2-VLDSYSDT))\n                          ORG   @T_SMS_VLD\n@T_SMS_BCD                DS    XL6144  SMS Config Data\n                          ORG   ,\n\n                          DS    0D\n@T_Dynam_Length           EQU   *-@T_Dynam\n\n\n&PGMNAME CSECT\n\n         DROP  ,\n         POP   USING\n         TITLE 'U00010: Write to output file'\n\n         PUSH  USING\n\nU00010   DS    0H\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Subroutine: U00010                                                 *\n*                                                                     *\n*  Abstract  : This subroutine manages output DCBs, and writes data   *\n*              to them.                                               *\n*                                                                     *\n*  Inputs    : R1 : ---> A(@_Dynam)                                   *\n*                        A(31-bit Stack Pointer)                      *\n*                        A(24-bit Stack Pointer)                      *\n*                        A(DDName)                                    *\n*                        A(Data)                                      *\n*                        A(Length of Data)                            *\n*                        A(ASA Ctl Char) or 0                         *\n*  Outputs   : R15: 0 = OK                                            *\n*                   8 = Error (DCB not OPEN, etc.)                    *\n*                                                                     *\n*  Operation : If A(DDNAME) = 0                                       *\n*                CLOSE all OPEN DCBs                                  *\n*                Free DCB storage                                     *\n*              Else                                                   *\n*                Find DCB for DDName                                  *\n*                If DCB not found                                     *\n*                  If any data to write                               *\n*                    Create and OPEN DCB                              *\n*                  EndIf                                              *\n*                EndIf                                                *\n*                If DCB OPEN                                          *\n*                  If no data to write                                *\n*                    CLOSE DCB                                        *\n*                  Else                                               *\n*                    Write Data                                       *\n*                  EndIf                                              *\n*                EndIf                                                *\n*              EndIf                                                  *\n*              Return to caller                                       *\n*                                                                     *\n*  Notes     : Once an OUTFILE is OPEN, it will remain OPEN until     *\n*               the SPACE program terminates, to cope with the fol-   *\n*               lowing batch scenario:                                *\n*                  SPACE .... OUTFILE(X)                              *\n*                  SPACE .... OUTFILE(Y)                              *\n*                  SPACE .... OUTFILE(X)                              *\n*                                                                     *\n*  History:    2003/10/07 SDDA030 - V2.21                             *\n*                                   New.                              *\n*                                   This code was extracted from X0010*\n*                                   and generalized, so it could be   *\n*                                   used for all output files, includ-*\n*                                   ing SYSPRINT.                     *\n*              2006/04/21 SDDA030 - V2.24                             *\n*                                 - Used standardised calling sequence*\n*                                 - Used separate 24-bit stack for    *\n*                                   DCBs, PUT code, etc.              *\n*              ____/__/__ ______                                      *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         STM   R14,R12,12(R13)          Save callers registers\n         LARL  R11,U_Literals           Point to our literals\n         USING (U_Literals,U_Literals_End),R11 Tell the assembler\n\n         L     R12,0(0,R1)              A(@_Dynam)\n         USING @_Dynam,R12              Tell the assembler\n\n*-------------------------------------------------------------------*\n*    Get an area on the stack for our local storage                 *\n*-------------------------------------------------------------------*\n         L     R2,4(0,R1)               A(31-bit stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         SSCSTACK PUSH,                 Get stack area                 +\n               LEN=@U_Dynam_Length,      this long                     +\n               STACK=(R2)                using this stack\n\n         LR    R3,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LHI   R1,@U_Dynam_Length        Its length\n         LA    R14,0                    Clear source address\n         LA    R15,0                     and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R3                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*-------------------------------------------------------------------*\n         ST    R13,4(0,R1)              Chain\n         ST    R1,8(0,R13)               saveareas\n         LR    R13,R1                   Load dynam base\n         USING @U_Dynam,R13             Assign a base\n         L     R15,@U_Dynam+4           Get A(HSA)\n         LM    R0,R3,20(R15)            Restore callers registers\n\n         L     R15,4(0,R1)              A(31-bit Stack Pointer)\n         ST    R15,@U_31Bit_Stack_Ptr_Ptr Save it\n         L     R15,8(0,R1)              A(24-bit Stack Pointer)\n         ST    R15,@U_24Bit_Stack_Ptr_Ptr Save it\n\n*-------------------------------------------------------------------*\n*    Save our parms                                                 *\n*-------------------------------------------------------------------*\n        L     R15,12(0,R1)              A(DDName)\n        ST    R15,@U_DDName_Ptr         OK, save it\n\n        L     R15,16(0,R1)              A(Data)\n        ST    R15,@U_Data_Ptr           Save it\n\n        L     R15,20(0,R1)              A(Data Length)\n        ST    R15,@U_Data_Len_Ptr       Save it\n\n        TM    20(R1),X'80'              Was that the last parm?\n        BO    U00020                    Yes, skip\n        L     R15,24(R1)                A(ASA Character) or 0\n        ST    R15,@U_ASA_Char_Ptr       Save it\n\nU00020  DS    0H\n*-------------------------------------------------------------------*\n*    By convention, if the address of the DDName is 0, we CLOSE all *\n*   OPEN DCBs, and free up their storage.                           *\n*-------------------------------------------------------------------*\n        ICM   R15,B'1111',@U_DDName_Ptr A(DDName)\n        JNZ   U00100                    Something there, OK\n\n*-------------------------------------------------------------------*\n*    CLOSE the DCBs ...                                             *\n*-------------------------------------------------------------------*\n         ICM   R3,B'1111',@_OutFile_Chain_Ptr  A(First OUTFile DCB)\n         JZ    U00050                   None, exit\nU00030   DS    0H\n         LA    R15,4+L'@_OutFile_DDName(0,R3) A(DCB)\n         TM    DCBOFLGS-IHADCB(R15),DCBOFOPN Is it OPEN?\n         JNO   U00040                   No, skip CLOSE\n         MVC   @U_CLOSE,U_CLOSE         Yes, Move CLOSE Parms\n         CLOSE ((15)),MODE=31,MF=(E,@U_CLOSE) and CLOSE it\nU00040   DS    0H\n         ICM   R3,B'1111',0(R3)         A(next DCB)\n         JNZ   U00030                   Got one, close it too\n\nU00050   DS    0H\n*-------------------------------------------------------------------*\n*    ... free the stack ...                                         *\n*-------------------------------------------------------------------*\n         ICM   R1,B'1111',@_OutFile_24Bit_Stack_Ptr A(DCB Stack)\n         JZ    U00080                   None, skip\n         SSCSTACK TERM,                 Free the stack area            +\n               STACK=(1)                 this one\n\nU00080   DS    0H\n         LA    R15,0                    Clear\n         ST    R15,@_OutFile_PUT_Code    Code pointer\n         ST    R15,@_OutFile_Chain_Ptr   and DCB pointer\n\n*-------------------------------------------------------------------*\n*    ... and exit.                                                  *\n*-------------------------------------------------------------------*\n         LA    R15,0                    All done, clear return code\n         J     U90010                    and exit\n\nU00100   DS    0H\n*-------------------------------------------------------------------*\n*    ... search the chain of OUTFIL DCBs to see if we can find our  *\n*   DDName                                                          *\n*-------------------------------------------------------------------*\n         LA    R15,@_OutFile_Chain_Ptr  A(Ptr to start of chain)\n         L     R14,@U_DDName_Ptr        A(Our DDName)\n         J     U00120                   and start running it\nU00110   DS    0H\n         CLC   0(L'@_OutFile_DDName,R14),4(R15)  Yes, is it ours?\n         JNE   U00120                   No, skip\n         AHI   R15,4+L'@_OutFile_DDName Yes, point to the DCB\n         ST    R15,@U_DCB_Ptr           Save it\n         J     U00280                   and use it\nU00120   DS    0H\n         LR    R3,R15                   Save A(this DCB area)\n         ICM   R15,B'1111',0(R3)        Point to next\n         JNZ   U00110                   Got one, check it out\n\n*-------------------------------------------------------------------*\n*    If we have anything to do ...                                  *\n*-------------------------------------------------------------------*\n         ICM   R15,B'1111',@U_Data_Ptr  Any data?\n         JZ    U00390                   No, exit quick smart\n         ICM   R15,B'1111',@U_Data_Len_Ptr Yes, any length pointer?\n         JZ    U00390                   No, get out\n         ICM   R15,B'1111',0(R15)       Yes, length = 0?\n         JZ    U00390                   Yes, exit now\n\n*-------------------------------------------------------------------*\n*    Our DDName is not found, so get an area on the 24-bit Stack    *\n*   for our DCB area ...                                            *\n*    The format of this area:                                       *\n*       0- 3: Forward pointer                                       *\n*       4-11: DDName                                                *\n*      12-n : DCB                                                   *\n*                                                                   *\n*    First, however, we move our 24-bit PUT code, if required. PUT  *\n*   runs 24-bit because QSAM has trouble using 31-bit PUT for       *\n*   DDNames allocated to the terminal - rather than check, we       *\n*   blindly run PUT in 24-bit mode all the time.                    *\n*-------------------------------------------------------------------*\n         ICM   R0,B'1111',@_OutFile_24Bit_Stack_Ptr A(DCB Stack)\n         JNZ   U00130                   OK, skip\n\n         L     R0,=AL4(@_24Bit_Stack_Length) Length of storage we need\n         SSCSTACK INIT,                 Go get our storage             +\n               LEN=(R0),                 this long                     +\n               LOC=24                    below the line\n\n         ST    R1,@_OutFile_24Bit_Stack_Ptr Update A(DCB Stack)\n\nU00130   DS    0H\n         ICM   R15,B'1111',@_OutFile_PUT_Code  A(24-bit PUT code)\n         JNZ   U00140                  OK, skip\n\n         LA    R0,U00400_End-U00400    Length of storage we need\n         L     R2,@_OutFile_24Bit_Stack_Ptr A(DCB Stack)\n         SSCSTACK PUSH,                 Get stack area                 +\n               LEN=(R0),                 this long                     +\n               STACK=(R2)                using this stack\n\n         ST    R1,@_OutFile_PUT_Code   Save A(Storage)\n         LR    R0,R1                   Set Target address\n         LHI   R1,U00400_End-U00400    Set Target length\n         BASR  R14,0                   Set Source\n         AHI   R14,U00400-*              address\n         LR    R15,R1                  and Source length\n         MVCL  R0,R14                  Move PUT code\n\nU00140   DS    0H\n         LHI   R0,4+L'@_OutFile_DDName+U_OUTFILE_DCB_Length\n         L     R2,@_OutFile_24Bit_Stack_Ptr A(DCB Stack)\n         SSCSTACK PUSH,                 Get stack area                 +\n               LEN=(R0),                 this long                     +\n               STACK=(R2)                using this stack\n\n*-------------------------------------------------------------------*\n*    ... chain it to the previous DCB area (pointed to by R3) ...   *\n*-------------------------------------------------------------------*\n         ST    R1,0(0,R3)               Chain it\n\n*-------------------------------------------------------------------*\n*    ... and initialize it.                                         *\n*-------------------------------------------------------------------*\n         XC    0(4,R1),0(R1)          Clear Ptr to next DCB area\n         L     R15,@U_DDName_Ptr      A(DDName)\n         MVC   4(L'@_OutFile_DDName,R1),0(R15)  Set DDName\n         LA    R15,4+L'@_OutFile_DDName(0,R1) Point to DCB\n         MVC   0(U_OUTFILE_DCB_Length,R15),U_OUTFILE_DCB Move DCB\n         MVC   DCBDDNAM-IHADCB(L'DCBDDNAM,R15),4(R1)  Move DDName\n         ST    R15,@U_DCB_Ptr         Save A(DCB)\n\n*-------------------------------------------------------------------*\n*    Get the JFCB. First, find the TIOT entry ...                   *\n*-------------------------------------------------------------------*\n         L     R15,CVTPTR(0,0)          A(CVT)\n         L     R15,CVTTCBP-CVT(R15)     A(Current TCB pointer)\n         L     R15,0(0,R15)             A(Current TCB)\n         L     R15,TCBTIO-TCB(R15)      A(TIOT)\n         L     R14,@U_DDName_Ptr        A(DDName)\n         AHI   R15,TIOENTRY-TIOT1       A(1st entry in TIOT)\nU00150   DS    0H\n         CLI   TIOELNGH-TIOENTRY(R15),0 Last Entry?\n         JE    U80010                   Yes, DDName not found\n         CLC   TIOEDDNM-TIOENTRY(L'TIOEDDNM,R15),0(R14) Ours?\n         JE    U00160                   Found our entry, skip\n         LA    R0,0                     Clear work reg\n         IC    R0,TIOELNGH-TIOENTRY(R15) Get entry length\n         AR    R15,R0                   Point to next entry\n         J     U00150                   and check it out\n\nU00160   DS    0H\n*-------------------------------------------------------------------*\n*    ... and then get the JFCB address from the SWA                 *\n*-------------------------------------------------------------------*\n         XC    @U_SWAEPAX,@U_SWAEPAX    Clear SWAEPA\n         MVC   @U_SWAEPAX+SWVA-ZB505(L'SWVA),TIOEJFCB-TIOENTRY(R15)\n         LA    R15,@U_SWAEPAX           A(EPA)\n         ST    R15,@U_EPA_Ptr           Save the address\n         MVC   @U_SWAREQ,U_SWAREQ       Move L-Form of macro\n         SWAREQ FCODE=RL,               Read Locate                    +\n               EPA=@U_EPA_Ptr,           using the EPA at this addr    +\n               UNAUTH=YES,               not being authoriZED          +\n               MF=(E,@U_SWAREQ)          keep ourselves re-entrant\n         LTR   R15,R15                  Check return code\n         JNZ   U80010                   Not good, skip\n\n         L     R4,@U_SWAEPAX+SWBLKPTR-ZB505 Get A(JFCB)\n         L     R3,@U_DCB_Ptr            Get A(DCB)\n\n*-------------------------------------------------------------------*\n*    If this is a new dataset ...                                   *\n*-------------------------------------------------------------------*\n         TM    JFCBTSDM-INFMJFCB(R4),JFCSDS SubSystem Dataset?\n         JO    U00170                 Yes, treat it as NEW\n         CLI   JFCBIND2-INFMJFCB(R4),0 Any DISP specified?\n         JE    U00170                 No, treat it as NEW\n         TM    JFCBIND2-INFMJFCB(R4),JFCNEW Yes, DISP=NEW?\n         JNO   U00270                 No, use existing DCB stuff\n\nU00170   DS    0H\n*-------------------------------------------------------------------*\n*    ... set up RECFM, LRECL and BLKSIZE if they were not           *\n*   specified. First, set RECFM to FB if it has not been specified. *\n*-------------------------------------------------------------------*\n         IC    R15,JFCRECFM-INFMJFCB(0,R4) Get RECFM from JFCB\n         LTR   R15,R15                Anything?\n         JNZ   U00180                 Yes, OK\n         LA    R15,DCBRECF+DCBRECBR   No, default to FB\n\n         TM    JFCBTSDM-INFMJFCB(R4),JFCSDS SubSystem Dataset?\n         JNO   U00180                 No, OK\n         LA    R15,DCBRECCA(0,R15)    Yes, add ASA character\nU00180   DS    0H\n         STC   R15,DCBRECFM-IHADCB(R3) Set RECFM in DCB\n\n*-------------------------------------------------------------------*\n*    Get the LRECL and BLKSIZE from the JFCB ...                    *\n*-------------------------------------------------------------------*\n         LH    R15,JFCLRECL-INFMJFCB(R4) Get JFCB LRECL\n         LH    R14,JFCBLKSI-INFMJFCB(R4) Get JFCB BLKSIZE\n\n*-------------------------------------------------------------------*\n*    ... and, if the LRECL hasn't been specified, set it to the     *\n*   length of the data to be written (unless this is SYSPRINT, when *\n*   the LRECL is set to VolTbl_Ent_Display_Len, to maintain compat- *\n*   ibility with previous versions).                                *\n*-------------------------------------------------------------------*\n         LTR   R15,R15                 Any LRECL?\n         JNZ   U00210                  Yes, OK\n\n         L     R15,@U_Data_Len_Ptr     A(Length of data to be written)\n         L     R15,0(0,R15)            Get it\n         TM    DCBRECFM-IHADCB(R3),DCBRECCC Carriage control?\n         JZ    U00200                  No, skip\n         AHI   R15,1                   Yes, bump for CC\nU00200   DS    0H\n         TM    DCBRECFM-IHADCB(R3),DCBRECU RECFM = U?\n         JO    U00210                  Yes, not RECFM=V\n         TM    DCBRECFM-IHADCB(R3),DCBRECV RECFM = V?\n         JZ    U00210                  No, skip\n         AHI   R15,4                   Yes, bump for RDW\n\nU00210   DS    0H\n*-------------------------------------------------------------------*\n*    If no BLKSIZE specified for RECFM=U, make BLKSIZE = LRECL      *\n*-------------------------------------------------------------------*\n         LTR   R14,R14                 Any BLKSIZE in the JFCB?\n         JNZ   U00220                  Yes, skip\n         TM    DCBRECFM-IHADCB(R3),DCBRECU RECFM = U?\n         JNO   U00220                  No, use SDB\n         LR    R14,R15                 Yes, BLKSIZE = LRECL\n\nU00220   DS    0H\n*-------------------------------------------------------------------*\n*    Check LRECL vs BLKSIZE, and adjust them to fit                 *\n*     RECFM=U: LRECL = 0                                            *\n*     RECFM=V: BLKSIZE = (n * LRECL) + 4                            *\n*     RECFM=F: BLKSIZE = n * LRECL                                  *\n*-------------------------------------------------------------------*\n         TM    DCBRECFM-IHADCB(R3),DCBRECU RECFM = U?\n         JNO   U00230                  No, skip\n         LA    R15,0                   Yes, clear LRECL\n         J     U00260                  and skip\nU00230   DS    0H\n         TM    DCBRECFM-IHADCB(R3),DCBRECV RECFM = V?\n         JNO   U00240                  No, skip\n         LTR   R14,R14                 Yes, BLKSIZE=0 (SDB)?\n         JZ    U00260                  Yes, OK\n         TM    DCBRECFM-IHADCB(R3),DCBRECSB Spanned rec?\n         JO    U00260                  Yes, OK\n         LR    R1,R14                  No, get BLKSIZE\n         LA    R0,0                    Clear high-order word\n         DR    R0,R15                  BLKSIZE/LRECL\n         C     R0,=FL4'4'              Remainder of 4 (BDW)?\n         JNL   U00260                  Yes, OK\n         LR    R15,R14                 No, LRECL = ...\n         S     R15,=FL4'4'                BLKSIZE - 4\n         J     U00260                  and skip\nU00240   DS    0H\n         LTR   R14,R14                 Fixed, BLKSIZE=0 (SDB)?\n         JZ    U00260                  Yes, OK\n         CR    R14,R15                 No, BLKSIZE > LRECL?\n         JNL   U00250                  Yes, OK\n         LR    R14,R15                 No, BLKSIZE = LRECL\n         J     U00260                  and skip\nU00250   DS    0H\n         LR    R1,R14                  Get BLKSIZE\n         LA    R0,0                    Clear high-order word\n         DR    R0,R15                  BLKSIZE/LRECL\n         SR    R14,R0                  Adjust BLKSIZE by remainder\n         J     U00260                  and skip\nU00260   DS    0H\n         STH   R15,DCBLRECL-IHADCB(R3) Update DCB LRECL\n         STH   R14,DCBBLKSI-IHADCB(R3) Update DCB BLKSIZE\n\nU00270   DS    0H\n*-------------------------------------------------------------------*\n*    Open the DCB, and exit quick smart if it doesn't               *\n*-------------------------------------------------------------------*\n         L     R3,@U_DCB_Ptr           Point to our DCB\n\n         MVC   @U_OPEN,U_OPEN             Move OPEN parms\n         OPEN  ((3),OUTPUT),MODE=31,MF=(E,@U_OPEN) And OPEN it\n\n         TM    DCBOFLGS-IHADCB(R3),DCBOFOPN Is it OPEN?\n         JNO   U80010                  No, exit with error\n\nU00280   DS    0H\n*-------------------------------------------------------------------*\n*    We have our DCB - if it is OPEN ...                            *\n*-------------------------------------------------------------------*\n         LA    R15,0                   Clear return code\n         L     R3,@U_DCB_Ptr           Get A(DCB)\n         TM    DCBOFLGS-IHADCB(R3),DCBOFOPN Is it OPEN?\n         JNO   U90010                  No, skip\n\n*-------------------------------------------------------------------*\n*    ... if we have nothing to do, CLOSE the DCB. Otherwise ...     *\n*-------------------------------------------------------------------*\n         ICM   R15,B'1111',@U_Data_Ptr  Any data?\n         JZ    U00290                   No, close DCB\n         ICM   R15,B'1111',@U_Data_Len_Ptr Yes, any length pointer?\n         JZ    U00290                   No, close DCB\n         ICM   R15,B'1111',0(R15)       Yes, length = 0?\n         JNZ   U00300                   NO, OK\nU00290   DS    0H\n         MVC   @U_CLOSE,U_CLOSE         Move CLOSE Parms\n         CLOSE ((3)),MODE=31,MF=(E,@U_CLOSE) and CLOSE our DCB\n         J     U00390                   and exit\n\nU00300   DS    0H\n*-------------------------------------------------------------------*\n*    ... get an area to hold the data we will write. It's length    *\n*   is:                                                             *\n*    RECFM=U:                                                       *\n*       Length of data to be written                                *\n*      +1 if the DCB has a Print Ctl Char & A(ASA Char) \\= 0        *\n*    Otherwise:                                                     *\n*       DCBLRECL                                                    *\n*-------------------------------------------------------------------*\n         LH    R0,DCBLRECL-IHADCB(R3)  Get LRECL\n\n         TM    DCBRECFM-IHADCB(R3),DCBRECU RECFM = U?\n         JNO   U00310                  No, skip\n         L     R15,@U_Data_Len_Ptr     A(Len of data to be written)\n         L     R0,0(0,R15)             Get it\n         TM    DCBRECFM-IHADCB(R3),DCBRECCC CC?\n         JZ    U00310                  No, skip\n         ICM   R15,B'1111',@U_ASA_Char_Ptr Yes, do we have one?\n         JZ    U00310                  No, too bad\n         AHI   R0,1                    Yes, bump length\nU00310   DS    0H\n\n         ST    R0,@U_OutRec_Len        Save length\n         L     R2,@_OutFile_24Bit_Stack_Ptr A(DCB Stack)\n         SSCSTACK PUSH,                 Get stack area                 +\n               LEN=(R0),                 this long                     +\n               STACK=(R2)                using this stack\n\n         ST    R1,@U_OutRec_Ptr        Save A(Data area)\n\n*-------------------------------------------------------------------*\n*    ... move the data passed to us to our output area ...          *\n*-------------------------------------------------------------------*\n         L     R14,@U_OutRec_Ptr        A(Output Record)\n         TM    DCBRECFM-IHADCB(R3),DCBRECU RECFM=U?\n         JO    U00320                  Yes, its not RECFM=V\n         TM    DCBRECFM-IHADCB(R3),DCBRECV RECFM=V?\n         JNO   U00320                  No, skip\n         LA    R14,4(0,R14)            Yes, bump for RDW\nU00320   DS    0H\n         TM    DCBRECFM-IHADCB(R3),DCBRECCC CC?\n         JZ    U00330                  No, skip\n         ICM   R15,B'1111',@U_ASA_Char_Ptr Do we have one?\n         JZ    U00330                  No, skip\n         MVC   0(1,R14),0(R15)         Yes, move it\n         TM    DCBRECFM-IHADCB(R3),DCBRECCM Machine CC?\n         JZ    U00265                  No, skip\n         TR    0(1,R14),U_ASA_to_Mach  Yes, translate it\nU00265   DS    0H\n         LA    R14,1(0,R14)            and bump output pointer\nU00330   DS    0H\n         LR    R0,R14                  A(Output)\n         L     R1,@U_OutRec_Ptr        Calculate\n         A     R1,@U_OutRec_Len         length of output\n         SR    R1,R0                    data left\n         L     R14,@U_Data_Ptr         A(Data to be copied)\n         L     R15,@U_Data_Len_Ptr     A(Length)\n         L     R15,0(0,R15)            Get its length\n         O     R15,=XL4'40000000'      Pad character of blank\n         MVCL  R0,R14                  Move it\n\n         S     R14,@U_OutRec_Ptr       Length of output record\n\n*-------------------------------------------------------------------*\n*    ... if this is a RECFM=U file, update DCBBLKSI, after saving   *\n*   it. Otherwise ...                                               *\n*-------------------------------------------------------------------*\n         TM    DCBRECFM-IHADCB(R3),DCBRECU  RECFM=U?\n         JNO   U00350                  No, skip\n         LH    R0,DCBBLKSI-IHADCB(R3)  Yes, get max record len\n         STH   R0,@U_BLKSIZE           and save it\n         CR    R14,R0                  Are we trying to write too much?\n         JNH   U00340                  No, OK\n         LR    R14,R0                  Yes, write what we can\nU00340   DS    0H\n         STH   R14,DCBBLKSI-IHADCB(R3) Update it with current length\n         J     U00370                  and skip\n\nU00350   DS    0H\n*-------------------------------------------------------------------*\n*    ... if this is a RECFM=V file, update the RDW                  *\n*-------------------------------------------------------------------*\n         TM    DCBRECFM-IHADCB(R3),DCBRECV RECFM=V?\n         JNO   U00370                  No, OK\n         LH    R0,DCBLRECL-IHADCB(R3)  Yes, get LRECL\n         CR    R14,R0                  Are we trying to write too much?\n         JNH   U00360                  No, OK\n         LR    R14,R0                  Yes, write what we can\nU00360   DS    0H\n         L     R15,@U_OutRec_Ptr       Get A(Output record)\n         SLL   R14,16                  Length in high-order byte\n         ST    R14,0(0,R15)            Update RDW\n         J     U00370                  and skip\n\nU00370   DS    0H\n*-------------------------------------------------------------------*\n*    Write our data ...                                             *\n*-------------------------------------------------------------------*\n         L     R1,@U_DCB_Ptr           Point to our DCB\n         L     R0,@U_OutRec_Ptr        Point to data to be written\n         L     R15,@_OutFile_PUT_Code  Point to our code\n         BASR  R14,R15                 Go issue PUT\n\n*-------------------------------------------------------------------*\n*    ... and restore DCBBLKSI, if this is RECFM=U                   *\n*-------------------------------------------------------------------*\n         L     R1,@U_DCB_Ptr           Point to our DCB\n         TM    DCBRECFM-IHADCB(R1),DCBRECU  RECFM=U?\n         JNO   U00380                  No, skip\n         LH    R0,@U_BLKSIZE           Yes, get saved BLKSIZE\n         STH   R0,DCBBLKSI-IHADCB(R1)  and restore the DCB\n\nU00380   DS    0H\n*-------------------------------------------------------------------*\n*    Free the storage we got for our record ...                     *\n*-------------------------------------------------------------------*\n         ICM   R1,B'1111',@U_OutRec_Ptr A(Output record data area)\n         JZ    U00390                   Nothing, skip\n         L     R2,@_OutFile_24Bit_Stack_Ptr A(DCB Stack)\n         SSCSTACK POP,                  Free the record area           +\n               ADDR=(R1),                starting here                 +\n               STACK=(R2)                on this stack\n\nU00390   DS    0H\n*-------------------------------------------------------------------*\n*    ... clear the return code, and exit.                           *\n*-------------------------------------------------------------------*\n         LA    R15,0                   Clear return code\n         J     U90010                  and exit\n\n*-------------------------------------------------------------------*\n*    The following code is moved to storage below-the-line, and     *\n*   is executed via a BASR, so it runs AMODE24. This is required if *\n*   the DCB to which we are writing happens to be allocated to      *\n*   the TSO terminal.                                               *\n*                                                                   *\n*   Note that R14-R3 are updated by this routine.                   *\n*-------------------------------------------------------------------*\n\n\nU00400   DS    0H\n         PUSH  USING                   Save USING environment\n         DROP  ,                       Free them all\n         USING *,R15                   Assign a base\n         LR    R3,R14                  Save return address\n         PUT   (1),(0)                 Write record (MACRF=PM)\n         LA    R14,X'80'               Set up\n         SLL   R14,24                   31-bit\n         OR    R14,R3                   return address\n         BSM   0,R14                   Back to caller in AMODE31\n         DROP  R15                     Free our base\n         POP   USING                   Restore USING environment\nU00400_End EQU *\n\n\nU80010   DS    0H\n*-------------------------------------------------------------------*\n*    We couldn't OPEN the DCB, so exit with a return code           *\n*-------------------------------------------------------------------*\n         LA    R15,4                   RC = 4\n         J     U90010                  and exit\n\nU90010   DS    0H\n*-------------------------------------------------------------------*\n*    Free up our local storage ...                                  *\n*-------------------------------------------------------------------*\n         LR    R3,R15                   Save Return Code\n\n         LA    R1,@U_Dynam              A(Local storage)\n         L     R2,@U_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)\n         L     R2,0(0,R2)         Point to it\n         L     R13,4(0,R13)             Rescue A(HSA)\n\n         SSCSTACK POP,                  Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=(R2)                on this stack\n\n         LR    R15,R3                   Restore Return Code\n\n*-------------------------------------------------------------------*\n*    ... and return to caller                                       *\n*-------------------------------------------------------------------*\n         L     R14,12(0,R13)            Restore return address\n         LM    R0,R12,20(R13)           Restore other registers\n         BSM   0,R14                    and return\n\nU_Literals  DS  0H\n\nU_ASA_to_Mach DC  256X'09'               Default - space 1 line\n              ORG U_ASA_to_Mach+C'0'     Space 2 lines\n              DC  X'11'\n              ORG U_ASA_to_Mach+C'-'     Space 3 lines\n              DC  X'19'\n              ORG U_ASA_to_Mach+C'+'     Suppress spacing\n              DC  X'01'\n              ORG U_ASA_to_Mach+C'1'     Skip to Channel 1\n              DC  X'89'\n              ORG\n\n         LTORG\n\n         PUSH  PRINT\n         PRINT NOGEN\n\nU_OUTFILE_DCB DCB DDNAME=OUTFILE,MACRF=PM,DSORG=PS\nU_OUTFILE_DCB_Length EQU *-U_OUTFILE_DCB Length of OUTFILE DCB\n\nU_SWAREQ SWAREQ MF=L                    Read Locate\nU_SWAREQ_Length EQU *-U_SWAREQ          Length of SWAREQ Macro\n\nU_OPEN   OPEN  (0,INPUT),MODE=31,MF=L\nU_OPEN_Length EQU  *-U_OPEN\n\nU_CLOSE  CLOSE (0),MODE=31,MF=L\nU_CLOSE_Length EQU  *-U_CLOSE\n\n         POP PRINT\n\nU_Literals_End  DS  0H\n\n\n@U_Dynam                  DSECT       Dynamic area for U0000\n                          DS    18F    O/S Style save area\n@U_31Bit_Stack_Ptr_Ptr    DS    AL4    A(31-bit Stack Ptr)\n@U_24Bit_Stack_Ptr_Ptr    DS    AL4    A(24-bit Stack Ptr)\n\n@U_DDName_Ptr             DS    AL4    A(DDName)\n@U_Data_Ptr               DS    AL4    A(Data to be written)\n@U_Data_Len_Ptr           DS    AL4    A(Length of data to be written)\n@U_ASA_Char_Ptr           DS    AL4    A(ASA CC) or 0\n\n@U_DCB_Ptr                DS    AL4    A(Current DCB)\n@U_BLKSIZE                DS    HL2    BLKSIZE for RECFM=U DCB\n\n@U_OutRec_Ptr             DS    AL4    A(Buffer for PUT)\n@U_OutRec_Len             DS    FL4    A(Length of above buffer)\n\n@U_Macros                 DS    0F\n@U_OPEN                   DS    CL(U_OPEN_Length)\n                          ORG   @U_Macros\n@U_CLOSE                  DS    CL(U_CLOSE_Length)\n                          ORG   @U_Macros\n@U_EPA_Ptr                DS    AL4    A(EPA for SWAREQ)\n@U_SWAREQ                 DS    CL(U_SWAREQ_Length)\n                          DS    0F\n@U_SWAEPAX                DS    CL(L'SWAEPAX)\n                          ORG   ,\n                          DS    0D     Alignment\n@U_Dynam_Length           EQU   *-@U_Dynam Length of storage\n\n&PGMNAME CSECT\n\n         DROP  ,\n         POP   USING\n         TITLE 'V00010: Set up Statistics output lines'\n\n         PUSH  USING\n\nV00010   DS    0H\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Subroutine: V00010                                                 *\n*                                                                     *\n*  Abstract  : Populate statistics lines in the Volume Table.         *\n*                                                                     *\n*  Inputs    : R1 : ---> A(@_Dynam)                                   *\n*                        A(31-bit Stack Pointer)                      *\n*                        A(24-bit Stack Pointer)                      *\n*                        A(VolTbl_Ent)                                *\n*  Outputs   : R15: 0: OK                                             *\n*                                                                     *\n*  Notes     : N/A                                                    *\n*                                                                     *\n*  History:    2000/05/23 SDDA030 - V2.12                             *\n*                                 - New                               *\n*              2001/02/01 SDDA030 - V2.13                             *\n*                                 - Populated Main task CPU time      *\n*                                   stats line.                       *\n*              2001/02/26 SDDA030 - V2.14                             *\n*                                 - Checked and flagged               *\n*                                   VolTbl_Ent_Stats_Done so the stats*\n*                                   lines are populated once only.    *\n*              2002/06/11 SDDA030 - V2.18                             *\n*                                   WAIT for VolTbl to be populated   *\n*                                   before updating.                  *\n*              2006/04/21 SDDA030 - V2.24                             *\n*                                   Used standardised calling sequence*\n*              ____/__/__ _______                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         STM   R14,R12,12(R13)          Save callers registers\n         LARL  R11,V_Literals           Point to our literals\n         USING (V_Literals,V_Literals_End),R11 Tell the assembler\n\n         L     R12,0(0,R1)              A(@_Dynam)\n         USING @_Dynam,R12              Tell the assembler\n\n*-------------------------------------------------------------------*\n*    Get an area on the stack for our local storage                 *\n*-------------------------------------------------------------------*\n         L     R2,4(0,R1)               A(31-bit stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         SSCSTACK PUSH,                 Get stack area                 +\n               LEN=@V_Dynam_Length,      this long                     +\n               STACK=(R2)                using this stack\n\n         LR    R3,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LHI   R1,@V_Dynam_Length        Its length\n         LA    R14,0                    Clear source address\n         LA    R15,0                     and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R3                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*-------------------------------------------------------------------*\n         ST    R13,4(0,R1)              Chain\n         ST    R1,8(0,R13)               saveareas\n         LR    R13,R1                   Load dynam base\n         USING @V_Dynam,R13             Assign a base\n         L     R15,@V_Dynam+4           Get A(HSA)\n         LM    R0,R3,20(R15)            Restore callers registers\n\n         L     R15,4(0,R1)              A(31-bit Stack Pointer)\n         ST    R15,@V_31Bit_Stack_Ptr_Ptr Save it\n         L     R15,8(0,R1)              A(24-bit Stack Pointer)\n         ST    R15,@V_24Bit_Stack_Ptr_Ptr Save it\n\n*---------------------------------------------------------------------*\n*   Load the base register for VolTbl_Ent                             *\n*---------------------------------------------------------------------*\n         L     R9,12(0,R1)             Point to VolTbl_Ent\n         USING VolTbl_Ent,R9           Tell the Assembler\n\n*---------------------------------------------------------------------*\n*   If this is a Stack Statistics line ...                            *\n*---------------------------------------------------------------------*\n         TM    VolTbl_Ent_Stats_31Stack,L'VolTbl_Ent_Stats_31Stack\n         JZ    V00020                   Not 31-bit Stack stats, skip\n         TM    VolTbl_Ent_Stats_Done,L'VolTbl_Ent_Stats_Done Done?\n         JO    V00060                   Yes, skip\n         L     R8,@V_31Bit_Stack_Ptr_Ptr Get 31-bit stack pointer\n         L     R8,0(0,R8)               and point to the stack\n         J     V00030                   and skip\nV00020   DS    0H\n         TM    VolTbl_Ent_Stats_24Stack,L'VolTbl_Ent_Stats_24Stack\n         JZ    V00080                   Not 24-bit Stack stats, skip\n         TM    VolTbl_Ent_Stats_Done,L'VolTbl_Ent_Stats_Done Done?\n         JO    V00060                   Yes, skip\n         L     R8,@V_24Bit_Stack_Ptr_Ptr No, get 24-bit stack pointer\n         L     R8,0(0,R8)               and point to it\nV00030   DS    0H\n         L     R15,@_VolTbl_Ptr         A(VolTbl)\n         TM    VolTbl_Hdr_ECB-VolTbl_Hdr(R15),X'40' Table populated\n         JO    V00030C                  Yes, OK\n         WAIT  ECB=VolTbl_Hdr_ECB-VolTbl_Hdr(R15) No, WAIT for it\nV00030C  DS    0H\n         LA    R14,V_Stats_Line4        A(Source)\n         LHI   R15,V_Stats_Line4_Len    Length of source\n         O     R15,=XL4'40000000'       Pad char of blank\n         LA    R0,VolTbl_Ent_Display    A(Target)\n         LHI   R1,VolTbl_Ent_Display_Len Length of target\n         MVCL  R0,R14                   Move Stats Line4\n         TM    VolTbl_Ent_Stats_31Stack,L'VolTbl_Ent_Stats_31Stack\n         JNO   V00040                   Not 31-bit stack, skip\n         MVC   VolTbl_Ent_Display+V_Stats_Line4_Stack-V_Stats_Line4(L'V+\n               _Stats_Line4_Stack),=C'31'\n         J     V00050\nV00040   DS    0H\n         TM    VolTbl_Ent_Stats_24Stack,L'VolTbl_Ent_Stats_24Stack\n         JNO   V00050                   Not 24-bit stack, skip\n         MVC   VolTbl_Ent_Display+V_Stats_Line4_Stack-V_Stats_Line4(L'V+\n               _Stats_Line4_Stack),=C'24'\n         J     V00050\nV00050   DS    0H\n\n         LTR   R0,R8                     Any Stack?\n         JZ    V00050C                   No, default of 0\n         L     R0,StackHdr_StackLen-StackHdr(R8) Get stack length\nV00050C  DS    0H\n         CVD   R0,@V_DBLWD               Pack it\n         ED    VolTbl_Ent_Display+V_Stats_Line4_Size-V_Stats_Line4(L'V_+\n               Stats_Line4_Size),@V_DBLWD+5\n\n         LTR   R0,R8                     Any Stack?\n         JZ    V00050E                   No, default of 0\n         L     R0,StackHdr_HWM-StackHdr(R8) Get high-water mark\n         SR    R0,R8                     as a length\nV00050E  DS    0H\n         CVD   R0,@V_DBLWD               Pack it\n         ED    VolTbl_Ent_Display+V_Stats_Line4_HWM-V_Stats_Line4(L'V_S+\n               tats_Line4_HWM),@V_DBLWD+5\n\n         LTR   R0,R8                     Any Stack?\n         JZ    V00050G                   No, default of 0\n         L     R0,StackHdr_GETMAIN-StackHdr(R8) Get converted PUSHs\nV00050G  DS    0H\n         CVD   R0,@V_DBLWD               Pack it\n         ED    VolTbl_Ent_Display+V_Stats_Line4_GETMAIN-V_Stats_Line4(L+\n               'V_Stats_Line4_GETMAIN),@V_DBLWD+5\n\n         LTR   R0,R8                     Any Stack?\n         JZ    V00050I                   No, default of 0\n         L     R0,StackHdr_Overflow_HWM-StackHdr(R8) GETMAIN HWM\nV00050I  DS    0H\n         CVD   R0,@V_DBLWD               Pack it\n         ED    VolTbl_Ent_Display+V_Stats_Line4_GHWM-V_Stats_Line4(L'V_+\n               Stats_Line4_GHWM),@V_DBLWD+5\n\n         OI    VolTbl_Ent_Stats_Done,L'VolTbl_Ent_Stats_Done Done now\n\n         L     R0,VolTbl_Ent_ECB        Current contents of our ECB\n         TM    VolTbl_Ent_ECB,X'80'     Anyone WAITing?\n         JO    V00050K                  Yes, we need to POST\n         L     R1,=XL4'40000000'        No, POST code of 0\n         CS    R0,R1,VolTbl_Ent_ECB     Pseudo-POST it\n         JZ    V00060                   OK, skip the real POST\nV00050K  DS    0H\n         POST  VolTbl_Ent_ECB,0         POST line as complete\n\nV00060   DS    0H\n         LA    R15,0                    Clear return code\n         J     V90010                   and exit\n\nV00080   DS    0H\n*---------------------------------------------------------------------*\n*   If this is a CPU Stats Line ...                                   *\n*---------------------------------------------------------------------*\n         TM    VolTbl_Ent_Stats_CPUTime,L'VolTbl_Ent_Stats_CPUTime\n         JZ    V01999                   Not CPU Time, skip\n         TM    VolTbl_Ent_Stats_Done,L'VolTbl_Ent_Stats_Done Done?\n         JO    V00110                   Yes, skip\n         L     R15,@_VolTbl_Ptr         A(VolTbl)\n         TM    VolTbl_Hdr_ECB-VolTbl_Hdr(R15),X'40' Table populated\n         JO    V00080C                  Yes, OK\n         WAIT  ECB=VolTbl_Hdr_ECB-VolTbl_Hdr(R15) No, WAIT for it\nV00080C  DS    0H\n         LA    R14,V_Stats_Line5        A(Source)\n         LHI   R15,V_Stats_Line5_Len    Length of source\n         O     R15,=XL4'40000000'       Pad char of blank\n         LA    R0,VolTbl_Ent_Display    A(Target)\n         LHI   R1,VolTbl_Ent_Display_Len Length of target\n         MVCL  R0,R14                   Move Stats Line5\n         TIMEUSED STORADR=@V_DBLWD,     Get CPU time used              +\n               LINKAGE=SYSTEM,           as recommended by IBM         +\n               CPU=MIC                   get it in microseconds\n         LM    R14,R15,@V_DBLWD         Get current TCB time\n         LM    R0,R1,@_CPU_Time_Init    Get TCB Time used previously\n         SLR   R15,R1                   Subtract\n         JNM   V00090                   No overflow, OK\n         SL    R14,=FL4'1'              Borrow, adjust\nV00090   DS    0H\n         SLR   R14,R0                   Adjust this one too\n\n         AL    R15,@_CPU_Time_Used+4    Bump Accum CPU Time\n         BRC   12,V00100                No Carry, OK\n         AL    R14,=FL4'1'              Carry, bump it\nV00100   DS    0H\n         AL    R14,@_CPU_Time_Used      Bump Accum CPU Time\n         D     R14,=FL4'1000'           To seconds (3 decimals)\n         CVD   R15,@V_DBLWD              Pack it\n         ED    VolTbl_Ent_Display+V_Stats_Line5_CPUTime-V_Stats_Line5(L+\n               'V_Stats_Line5_CPUTime),@V_DBLWD+5\n\n         TM    @_OW48527,L'@_OW48527     Is OW48527 on?\n         JO    V00100B                   Yes, never went NONSWAP\n\n         LA    R1,VolTbl_Ent_Display+V_Stats_Line5_CPUTime+L'V_Stats_Li+\n               ne5_CPUTime-V_Stats_Line5 A(End of line)\n         MVC   0(29,R1),=C', Non-Swappable Elapsed Time:'\n         MVC   29(7,R1),=X'4021204B202020' Move mask\n         LM    R14,R15,@_NSwap_Time      Get Non-swappable time\n         SRDL  R14,12                    Convert to usec\n         D     R14,=FL4'1000'            Convert to millisecs\n         CVD   R15,@V_DBLWD              Pack it\n         ED    29(7,R1),@V_DBLWD+5       Edit into message\n\nV00100B  DS    0H\n         OI    VolTbl_Ent_Stats_Done,L'VolTbl_Ent_Stats_Done Done now\n\n         L     R0,VolTbl_Ent_ECB        Current contents of our ECB\n         TM    VolTbl_Ent_ECB,X'80'     Anyone WAITing?\n         JO    V00100C                  Yes, we need to POST\n         L     R1,=XL4'40000000'        No, POST code of 0\n         CS    R0,R1,VolTbl_Ent_ECB     Pseudo-POST it\n         JZ    V00110                   OK, skip the real POST\nV00100C  DS    0H\n         POST  VolTbl_Ent_ECB,0         POST line as complete\n\nV00110   DS    0H\n         LA    R15,0                    Clear return code\n         J     V90010                   and exit\n\nV01999   DS    0H\n*---------------------------------------------------------------------*\n*   Unknown Stats Line, exit                                          *\n*---------------------------------------------------------------------*\n         LA    R15,0                    Clear return code\n         J     V90010                   and exit\n\n\nV90010   DS    0H\n*-------------------------------------------------------------------*\n*    Free up our local storage ...                                  *\n*-------------------------------------------------------------------*\n         LR    R3,R15                   Save return code\n\n         LA    R1,@V_Dynam              A(Local storage)\n         L     R2,@V_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         L     R13,4(0,R13)             Rescue A(HSA)\n\n         SSCSTACK POP,                  Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=(R2)                on this stack\n\n         LR    R15,R3                   Restore return code\n\n*-------------------------------------------------------------------*\n*    ... and return to caller                                       *\n*-------------------------------------------------------------------*\n         L     R14,12(0,R13)            Restore return address\n         LM    R0,R12,20(R13)           Restore other registers\n         BSM   0,R14                    and return\n\nV_Literals  DS  0H\n\n\nV_Stats_Line4         EQU   *\n                      DC    C' '\nV_Stats_Line4_Stack   DC    C'31'\n                      DC    C'-Bit Stack: Size:'\nV_Stats_Line4_Size    DC    X'402020202120'\n                      DC    C', HWM:'\nV_Stats_Line4_HWM     DC    X'402020202120'\n                      DC    C', GETMAINs:'\nV_Stats_Line4_GETMAIN DC    X'402020202120'\n                      DC    C', GETMAIN HWM:'\nV_Stats_Line4_GHWM    DC    X'402020202120'\nV_Stats_Line4_Len     EQU   *-V_Stats_Line4\n\nV_Stats_Line5         EQU   *\n                      DC    C' '\n                      DC    C'Main Task CPU Time:'\nV_Stats_Line5_CPUTime DC    X'4021204B202020'\nV_Stats_Line5_Len     EQU   *-V_Stats_Line5\n\n         LTORG\n\nV_Literals_End  DS  0H\n\n\n@V_Dynam                  DSECT        Dynamic area for V00000\n                          DS    18F     O/S Style save area\n@V_31Bit_Stack_Ptr_Ptr    DS    AL4     A(31-bit Stack Ptr)\n@V_24Bit_Stack_Ptr_Ptr    DS    AL4     A(24-bit Stack Ptr)\n@V_DBLWD                  DS    D       Work area\n                          DS    0D      Alignment\n@V_Dynam_Length           EQU   *-@V_Dynam Length of storage\n\n&PGMNAME CSECT\n\n         DROP  ,\n         POP   USING\n         TITLE 'W00010: Point to next free VolTbl entry'\n\n         PUSH  USING\n\nW00010   DS    0H\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Subroutine: W00010                                                 *\n*                                                                     *\n*  Abstract  : Return a pointer to the next free entry in VolTbl. If  *\n*              all entries are used, a larger VolTbl is GETMAINed, and*\n*              the current table copied to the new                    *\n*                                                                     *\n*  Inputs    : R1 : ---> A(@_Dynam)                                   *\n*                        A(31-bit Stack Pointer)                      *\n*                        A(24-bit Stack Pointer)                      *\n*  Outputs   : R1 : A(Free entry) or 0 if storage unavailable         *\n*                                                                     *\n*  Notes     : N/A                                                    *\n*                                                                     *\n*  History:    1999/08/20 SDDA030 - V2.8                              *\n*                                 - New                               *\n*              2006/04/21 SDDA030 - V2.24                             *\n*                                 - Used conditional STORAGE OBTAINs  *\n*                                   when expanding VolTbl             *\n*              ____/__/__ _______                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         STM   R14,R12,12(R13)          Save callers registers\n         LARL  R11,W_Literals           Point to our literals\n         USING (W_Literals,W_Literals_End),R11 Tell the assembler\n\n         L     R12,0(0,R1)              A(@_Dynam)\n         USING @_Dynam,R12              Tell the assembler\n\n*-------------------------------------------------------------------*\n*    Get an area on the stack for our local storage                 *\n*-------------------------------------------------------------------*\n         L     R2,4(0,R1)               A(31-bit stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         SSCSTACK PUSH,                 Get stack area                 +\n               LEN=@W_Dynam_Length,      this long                     +\n               STACK=(R2)                using this stack\n\n         LR    R3,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LHI   R1,@W_Dynam_Length        Its length\n         LA    R14,0                    Clear source address\n         LA    R15,0                     and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R3                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*-------------------------------------------------------------------*\n         ST    R13,4(0,R1)              Chain\n         ST    R1,8(0,R13)               saveareas\n         LR    R13,R1                   Load dynam base\n         USING @W_Dynam,R13             Assign a base\n         L     R15,@W_Dynam+4           Get A(HSA)\n         LM    R0,R3,20(R15)            Restore callers registers\n\n         L     R15,4(0,R1)              A(31-bit Stack Pointer)\n         ST    R15,@W_31Bit_Stack_Ptr_Ptr Save it\n         L     R15,8(0,R1)              A(24-bit Stack Pointer)\n         ST    R15,@W_24Bit_Stack_Ptr_Ptr Save it\n\nW00020   DS    0H\n*---------------------------------------------------------------------*\n*   Point to the next free entry                                      *\n*---------------------------------------------------------------------*\n         LA    R14,0                    Clear used length\n         LA    R15,0                    Clear table length\n         ICM   R1,B'1111',@_VolTbl_Ptr  A(Current table)\n         JZ    W00030                   None, skip\n         LHI   R14,VolTbl_Ent_Len       Yes, Length of 1 entry\n         L     R15,VolTbl_Hdr_Count-VolTbl_Hdr(R1) Current entries used\n         MR    R14,R14                  Get current length used\n         LR    R14,R15                  Save it\n         L     R15,VolTbl_Hdr_TbLen-VolTbl(R1) Get len of table\n         AR    R15,R1                   Point to end of table\nW00030   DS    0H\n         LA    R1,VolTbl_Ent-VolTbl(R1,R14) Point to next (free) entry\n         SR    R15,R1                   Get length remaining\n         LHI   R0,VolTbl_Ent_Len        Length of 1 entry\n         CR    R15,R0                   Do we have room to add?\n         JNL   W00060                   Yes, skip\n\n*---------------------------------------------------------------------*\n*   We have to get a new table, so get the current number of entries  *\n*---------------------------------------------------------------------*\n         TM    @_VolTbl_GETMAIN_Err,L'@_VolTbl_GETMAIN_Err\n         JO    W80010                   Yes, just exit with error\n\n         LHI   R15,99                   Initial nbr entries (1st time)\n         ICM   R1,B'1111',@_VolTbl_Ptr  A(Table)\n         JZ    W00040                   None, skip\n         L     R15,VolTbl_Hdr_Count-VolTbl_Hdr(R1) Yes, get nbr ents\n\nW00040   DS    0H\n*---------------------------------------------------------------------*\n*   Calculate the Min (1 more entry) and Max (double the number of    *\n*    entries) lengths of the new table ...                            *\n*---------------------------------------------------------------------*\n         LA    R0,1(0,R15)              Min of 1 more entry\n         LHI   R1,VolTbl_Ent_Len        Length of 1 entry\n         MR    R0,R0                    Get new length of entries\n         LA    R4,VolTbl_Ent-VolTbl(R1) Add length of header\n         AHI   R4,7                     Make sure its\n         SRL   R4,3                      a doubleword\n         SLL   R4,3                      multiple\n\n         LR    R0,R15                   Max len of double\n         SLL   R0,1                      the number of entries\n         LHI   R1,VolTbl_Ent_Len        Length of 1 entry\n         MR    R0,R0                    Get new length of entries\n         LA    R5,VolTbl_Ent-VolTbl(R1) Add length of header\n         AHI   R5,7                     Make sure its\n         SRL   R5,3                      a doubleword\n         SLL   R5,3                      multiple\n\n*---------------------------------------------------------------------*\n*   ... and go get storage for it                                     *\n*---------------------------------------------------------------------*\n         BASR  R2,0\n         USING (*,W00040_End-1),R2\n         STORAGE OBTAIN,                Go get a table                 +\n               LENGTH=((4),(5)),         this long                     +\n               LOC=31,                   above-the-line                +\n               COND=YES,                 let us know what happens      +\n               ADDR=(3)                  return address here\nW00040_End DS  0H\n         DROP  R2\n\n         LTR   R15,R15                  Did we get the storage?\n         JNZ   W80010                   No, oh dear\n\n*---------------------------------------------------------------------*\n*   Copy the old table to the new.                                    *\n*---------------------------------------------------------------------*\n         LR    R4,R0                    Save new table length\n         LR    R1,R0                    New table length\n         LR    R0,R3                    Point to the new table\n         LA    R15,0                    Clear old table length\n         ICM   R14,B'1111',@_VolTbl_Ptr A(Old table)\n         JZ    W00050                   None, skip\n         L     R15,VolTbl_Hdr_TbLen-VolTbl(R14) Yes, get current length\nW00050   DS    0H\n         MVCL  R0,R14                   Move old to new\n         ST    R4,VolTbl_Hdr_TbLen-VolTbl(R3) Update table length\n         L     R1,@_VolTbl_Ptr          A(Old table)\n         ST    R3,@_VolTbl_Ptr          Update with A(New table)\n         LTR   R1,R1                    Is there an old table?\n         JZ    W00020                   No, start again\n\n*---------------------------------------------------------------------*\n*   Free up the old table                                             *\n*---------------------------------------------------------------------*\n         L     R0,VolTbl_Hdr_TbLen-VolTbl(R1) Get its length\n         BASR  R2,0\n         USING (*,W00050_End-1),R2\n         STORAGE RELEASE,               Free the old table             +\n               ADDR=(1),                 starting here                 +\n               LENGTH=(0)                for this long\nW00050_End DS  0H\n         DROP  R2\n         J     W00020                   Start again\n\nW00060   DS    0H\n*---------------------------------------------------------------------*\n*   We have an new entry: bump nbr entries used ...                   *\n*---------------------------------------------------------------------*\n         L     R15,@_VolTbl_Ptr         A(Volume Table)\n         L     R14,VolTbl_Hdr_Count-VolTbl_Hdr(R15) Get # used entries\n         AHI   R14,1                    Bump it\n         ST    R14,VolTbl_Hdr_Count-VolTbl_Hdr(R15) Save it\n\n*---------------------------------------------------------------------*\n*   ... and initialize the entry.                                     *\n*---------------------------------------------------------------------*\n         LR    R2,R1                    Save Entry address\n\n         LR    R0,R2                    A(Target)\n         LHI   R1,VolTbl_Ent_Len        Length of entry\n         LA    R14,0                    A(Source)\n         LA    R15,0                    Length of source\n         MVCL  R0,R14                   Set table entry to X'00'\n\n         LA    R0,VolTbl_Ent_Display-VolTbl_Ent(R2) A(Display area)\n         LHI   R1,VolTbl_Ent_Display_Len Length of display area\n         LA    R14,0                    A(Source)\n         L     R15,=XL4'40000000'       Source len = 0, pad = blank\n         MVCL  R0,R14                   Set display area to blanks\n\n         LR    R1,R2                    A(Table entry)\n         SLR   R15,R15                  Clear return code\n         J     W90010                   and exit\n\nW80010   DS    0H\n*-------------------------------------------------------------------*\n*    STORAGE OBTAIN error: set a flag so we don't try to get more,  *\n*                          set return code, and exit                *\n*-------------------------------------------------------------------*\n         OI    @_VolTbl_GETMAIN_Err,L'@_VolTbl_GETMAIN_Err\n         SLR   R1,R1                    Clear A(New entry)\n         LA    R15,8                    Set return code\n         J     W90010                   and exit\n\nW90010   DS    0H\n*-------------------------------------------------------------------*\n*    Free up our local storage ...                                  *\n*-------------------------------------------------------------------*\n         LR    R3,R1                    Save A(Free entry)\n         LR    R4,R15                   Save return code\n\n         LA    R1,@W_Dynam              A(Local storage)\n         L     R2,@W_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         L     R13,4(0,R13)             Rescue A(HSA)\n\n         SSCSTACK POP,                  Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=(R2)                on this stack\n\n         LR    R1,R3                    Restore A(Free entry)\n         LR    R15,R4                   Restore return code\n\n*-------------------------------------------------------------------*\n*    ... and return to caller                                       *\n*-------------------------------------------------------------------*\n         L     R14,12(0,R13)            Restore return address\n         L     R0,20(0,R13)             Restore R0\n         LM    R2,R12,28(R13)           Restore other registers\n         BSM   0,R14                    and return\n\nW_Literals  DS  0H\n\n         LTORG\n\nW_Literals_End  DS  0H\n\n\n@W_Dynam                  DSECT       Dynamic area for W00000\n@W_Save                   DS    18F    O/S Style save area\n@W_31Bit_Stack_Ptr_Ptr    DS    AL4    A(31-bit Stack Ptr)\n@W_24Bit_Stack_Ptr_Ptr    DS    AL4    A(24-bit Stack Ptr)\n                          DS    0D     Alignment\n@W_Dynam_Length           EQU   *-@W_Dynam Length of storage\n\n&PGMNAME CSECT\n\n         DROP  ,\n         POP   USING\n         TITLE 'X00010: Write data to OUTFIL'\n\n         PUSH  USING\n\nX00010   DS    0H\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Subroutine: X00010                                                 *\n*                                                                     *\n*  Abstract  : This subroutine goes through the VolTbl, writing       *\n*              detail lines to the DDName passed.                     *\n*                                                                     *\n*  Inputs    : R1 : ---> A(@_Dynam)                                   *\n*                        A(31-bit Stack Pointer)                      *\n*                        A(24-bit Stack Pointer)                      *\n*                        A(DDName)                                    *\n*                        A(OutData flag)                              *\n*  Outputs   : R15: 0 = OK                                            *\n*                   8 = Error (DCB not OPEN, etc.)                    *\n*                                                                     *\n*  Operation : Set up parms for U00010                                *\n*              Do for each Detail line in VolTbl                      *\n*                Invoke U00010                                        *\n*              EndDo                                                  *\n*              Return to caller                                       *\n*                                                                     *\n*  History:    2000/01/19 SDDA030 - V2.11                             *\n*                                   New                               *\n*              2000/05/23 SDDA030 - V2.12                             *\n*                                   Added check for OUTFILE(SYSPRINT) *\n*                                   Checked BLKSIZE=0                 *\n*              2001/02/26 SDDA030 - V2.14                             *\n*                                   Output all detail entries from    *\n*                                   VolTbl instead of one at a time.  *\n*              2002/03/11 SDDA030 - V2.17                             *\n*                                   Converted RDJFCB to SWAREQ.       *\n*                                   Updated logic for LRECL, BLKSIZE. *\n*                                   Improved efficiency.              *\n*                                   Preserved BLKSIZE for RECFM=U.    *\n*              2002/06/11 SDDA030 - V2.18                             *\n*                                   WAIT for VolTbl_Ent to be populated\n*                                   before outputting                 *\n*              2003/10/07 SDDA030 - V2.21                             *\n*                                   Accept DDName, OutData flag as    *\n*                                   parms.                            *\n*                                   Remove check for SYSPRINT.        *\n*                                   Moved OPEN/CLOSE, I/O to U00010.  *\n*              2006/04/21 SDDA030 - V2.24                             *\n*                                   Used standardised calling sequence*\n*              ____/__/__ ______                                      *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         STM   R14,R12,12(R13)          Save callers registers\n         LARL  R11,X_Literals           Point to our literals\n         USING (X_Literals,X_Literals_End),R11 Tell the assembler\n\n         L     R12,0(0,R1)              A(@_Dynam)\n         USING @_Dynam,R12              Tell the assembler\n\n*-------------------------------------------------------------------*\n*    Get an area on the stack for our local storage                 *\n*-------------------------------------------------------------------*\n         L     R2,4(0,R1)               A(31-bit stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         SSCSTACK PUSH,                 Get stack area                 +\n               LEN=@X_Dynam_Length,      this long                     +\n               STACK=(R2)                using this stack\n\n         LR    R3,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LHI   R1,@X_Dynam_Length        Its length\n         LA    R14,0                    Clear source address\n         LA    R15,0                     and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R3                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*-------------------------------------------------------------------*\n         ST    R13,4(0,R1)              Chain\n         ST    R1,8(0,R13)               saveareas\n         LR    R13,R1                   Load dynam base\n         USING @X_Dynam,R13             Assign a base\n         L     R15,@X_Dynam+4           Get A(HSA)\n         LM    R0,R3,20(R15)            Restore callers registers\n\n         L     R15,4(0,R1)              A(31-bit Stack Pointer)\n         ST    R15,@X_31Bit_Stack_Ptr_Ptr Save it\n         L     R15,8(0,R1)              A(24-bit Stack Pointer)\n         ST    R15,@X_24Bit_Stack_Ptr_Ptr Save it\n\n*--------------------------------------------------------------------*\n*   Initialize our standard parmlist                                 *\n*--------------------------------------------------------------------*\n         LA    R15,@_Dynam              A(Dynamic area)\n         ST    R15,@X_Parms_Std         Save it\n         L     R15,@X_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)\n         ST    R15,@X_Parms_Std+4       Save it\n         L     R15,@X_24Bit_Stack_Ptr_Ptr A(24-bit Stack Pointer)\n         ST    R15,@X_Parms_Std+8       Save it\n\n*-------------------------------------------------------------------*\n*    Build our parm list for U00010                                 *\n*-------------------------------------------------------------------*\n        ICM   R15,B'1111',12(R1)        A(DDName)\n        JZ    X00350                    None, exit quietly\n        ST    R15,@X_Parms_U00010       OK, save it\n\n*-------------------------------------------------------------------*\n*    Get the length and offset of the data we will be writing       *\n*-------------------------------------------------------------------*\n         ICM   R1,B'1111',16(R1)         A(OutData flag)\n         TM    0(R1),L'@_OutData_DISPLAY  Display only?\n         JNO   X00260                  No, skip\n         LA    R14,VolTbl_Ent_Display-VolTbl_Ent Yes, Offset of start\n         LHI   R15,VolTbl_Ent_Display_Len and get length\n         J     X00280                  skip\nX00260   DS    0H\n         TM    0(R1),L'@_OutData_CB    Control Blocks only?\n         JNO   X00270                  No, skip\n         LA    R14,VolTbl_Ent_CB_Start-VolTbl_Ent Yes, Offset of start\n         LHI   R15,VolTbl_Ent_CB_End-VolTbl_Ent_CB_Start and length\n         J     X00280                  and skip\nX00270   DS    0H\n         LA    R14,VolTbl_Ent_CB_Start-VolTbl_Ent ALL, Offset of CB)\n         LHI   R15,VolTbl_Ent_Display_End-VolTbl_Ent_CB_Start Length\nX00280   DS    0H\n         ST    R14,@X_Source_Offset    Save Offset\n         ST    R15,@X_Source_Len       Save Length\n         LA    R15,@X_Source_Len       A(Length)\n         ST    R15,@X_Parms_U00010+8   Save for U00010\n\n         OI    @X_Parms_U00010+8,X'80'   Flag as last\n\n*-------------------------------------------------------------------*\n*    Go through VolTbl ...                                          *\n*-------------------------------------------------------------------*\n         ICM   R9,B'1111',@_VolTbl_Ptr A(Volume Table)\n         JZ    X00350                  None, exit quietly\n         ICM   R10,B'1111',VolTbl_Hdr_Count-VolTbl(R9) Get nbr vols\n         JZ    X00350                  None, we're done\n         LA    R9,VolTbl_Ent-VolTbl(R9) A(1st entry)\n\n         Using VolTbl_Ent,R9           Tell the assembler\n\nX00330   DS    0H\n*-------------------------------------------------------------------*\n*    If this is a detail line, write it out                         *\n*-------------------------------------------------------------------*\n         TM    VolTbl_Ent_Detail_Line,L'VolTbl_Ent_Detail_Line Detail?\n         JNO   X00340                  No, skip it\n         TM    VolTbl_Ent_SMS_Line,L'VolTbl_Ent_SMS_Line SMS Anomaly?\n         JO    X00340                  Yes, skip it\n\n         TM    VolTbl_Ent_ECB,X'40'    Yes, is it populated?\n         JO    X00330C                 Yes, OK\n         WAIT  ECB=VolTbl_Ent_ECB      No, WAIT 'till it is\nX00330C  DS    0H\n         LA    R15,VolTbl_Ent          A(Entry)\n         A     R15,@X_Source_Offset    Point to our data\n         ST    R15,@X_Parms_U00010+4   Save it\n\n         LA    R1,@X_Parms             A(Parm list)\n         BRAS  R14,U00010              Output it\n\nX00340   DS    0H\n*-------------------------------------------------------------------*\n*    And process the next entry                                     *\n*-------------------------------------------------------------------*\n         AHI   R9,VolTbl_Ent_Len       A(Next VolTbl entry)\n         BRCT  R10,X00330              and do the next\n\nX00350   DS    0H\n*-------------------------------------------------------------------*\n*    Clear the return code, and exit.                               *\n*-------------------------------------------------------------------*\n         LA    R15,0                   Clear return code\n         J     X90010                  and exit\n\nX90010   DS    0H\n*-------------------------------------------------------------------*\n*    Free up our local storage ...                                  *\n*-------------------------------------------------------------------*\n         LR    R3,R15                   Save Return Code\n\n         LA    R1,@X_Dynam              A(Local storage)\n         L     R2,@X_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         L     R13,4(0,R13)             Rescue A(HSA)\n\n         SSCSTACK POP,                  Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=(R2)                on this stack\n\n         LR    R15,R3                   Restore Return Code\n\n*-------------------------------------------------------------------*\n*    ... and return to caller                                       *\n*-------------------------------------------------------------------*\n         L     R14,12(0,R13)            Restore return address\n         LM    R0,R12,20(R13)           Restore other registers\n         BSM   0,R14                    and return\n\nX_Literals  DS  0H\n\n         LTORG\n\nX_Literals_End  DS  0H\n\n\n@X_Dynam                  DSECT       Dynamic area for 10000\n                          DS    18F    O/S Style save area\n@X_31Bit_Stack_Ptr_Ptr    DS    AL4    A(31-bit Stack Ptr)\n@X_24Bit_Stack_Ptr_Ptr    DS    AL4    A(24-bit Stack Ptr)\n\n@X_Source_Offset          DS    FL4    Offset (in VolTbl_Ent)\n@X_Source_Len             DS    FL4    Length of data\n\n@X_Parms                  DS    0F     Parms for called rtns\n@X_Parms_Std              DS    3AL4    Standard 3 parms\n@X_Parms_Extra            EQU   *       Extra parms\n@X_Parms_U00010           DS    4AL4       for U00010\n                          ORG   ,\n\n                          DS    0D     Alignment\n@X_Dynam_Length           EQU   *-@X_Dynam Length of storage\n\n&PGMNAME CSECT\n\n         DROP  ,\n         POP   USING\n         TITLE 'Y00010: SYSPRINT I/O Routine'\n\n         PUSH  USING\n\nY00010   DS    0H\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Subroutine: Y00010                                                 *\n*                                                                     *\n*  Abstract  : This subroutine manages messages destined for SYSPRINT.*\n*                                                                     *\n*  Inputs    : R1 : ---> A(@_Dynam)                                   *\n*                        A(31-bit Stack Pointer)                      *\n*                        A(24-bit Stack Pointer)                      *\n*                        A(Data to be written) or 0                   *\n*                        Length of data to be written                 *\n*  Outputs   : R15: 0 = OK                                            *\n*                   8 = Error (SYSPRINT not OPEN, etc.)               *\n*                                                                     *\n*  Notes     :                                                        *\n*                                                                     *\n*  History:    1998/10/01 SDDA030 - New                               *\n*              1999/05/27 SDDA030 - V2.6                              *\n*                                 - Moved back into mainline code.    *\n*                                 - Used LIFO Stack for our dynamic   *\n*                                   areas.                            *\n*              1999/09/30 SDDA030 - V2.10                             *\n*                                 - Used @_Line_Count values to gen-  *\n*                                   erate Hdr0-3.                     *\n*              2001/02/26 SDDA030 - V2.14                             *\n*                                 - Headings now in table.            *\n*                                 - Only write DCBLRECLs worth of     *\n*                                   data to SYSPRINT.                 *\n*              2003/10/07 SDDA030 - V2.21                             *\n*                                 - Moved OPEN/CLOSE, I/O to U00010.  *\n*                                 - Trimmed trailing spaces.          *\n*              2006/04/21 SDDA030 - V2.24                             *\n*                                 - Used standardised calling sequence*\n*                                 - Checked length to be written      *\n*                                   against LINESIZE()                *\n*              ____/__/__ ______                                      *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         STM   R14,R12,12(R13)          Save callers registers\n         LARL  R11,Y_Literals           Point to our literals\n         USING (Y_Literals,Y_Literals_End),R11 Tell the assembler\n\n         L     R12,0(0,R1)              A(@_Dynam)\n         USING @_Dynam,R12              Tell the assembler\n\n*-------------------------------------------------------------------*\n*    Get an area on the stack for our local storage                 *\n*-------------------------------------------------------------------*\n         L     R2,4(0,R1)               A(31-bit stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         SSCSTACK PUSH,                 Get stack area                 +\n               LEN=@Y_Dynam_Length,      this long                     +\n               STACK=(R2)                using this stack\n\n         LR    R3,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LHI   R1,@Y_Dynam_Length        Its length\n         LA    R14,0                    Clear source address\n         LA    R15,0                     and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R3                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*-------------------------------------------------------------------*\n         ST    R13,4(0,R1)              Chain\n         ST    R1,8(0,R13)               saveareas\n         LR    R13,R1                   Load dynam base\n         USING @Y_Dynam,R13             Assign a base\n         L     R15,@Y_Dynam+4           Get A(HSA)\n         LM    R0,R3,20(R15)            Restore callers registers\n\n         L     R15,4(0,R1)              A(31-bit Stack Pointer)\n         ST    R15,@Y_31Bit_Stack_Ptr_Ptr Save it\n         L     R15,8(0,R1)              A(24-bit Stack Pointer)\n         ST    R15,@Y_24Bit_Stack_Ptr_Ptr Save it\n\n*--------------------------------------------------------------------*\n*   Initialize our standard parmlist                                 *\n*--------------------------------------------------------------------*\n         LA    R15,@_Dynam              A(Dynamic area)\n         ST    R15,@Y_Parms_Std         Save it\n         L     R15,@Y_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)\n         ST    R15,@Y_Parms_Std+4       Save it\n         L     R15,@Y_24Bit_Stack_Ptr_Ptr A(24-bit Stack Pointer)\n         ST    R15,@Y_Parms_Std+8       Save it\n\n*-------------------------------------------------------------------*\n*    If we have nothing to do, just exit.                           *\n*-------------------------------------------------------------------*\n         ICM   R15,B'1111',12(R1)       A(Data to be printed)\n         JZ    Y00130                   Nothing, just exit\n         ICM   R0,B'1111',16(R1)        Len of data\n         JZ    Y00130                   Nothing, just exit\n         LR    R1,R15                   A(Date in proper register)\n         ST    R15,@Y_Passed_Data_Ptr   Save A(Data)\n         ST    R0,@Y_Passed_Data_Len    and length\n\n         LA    R15,Y_SYSPRINT           A(DDNAme)\n         ST    R15,@Y_Parms_U00010      Save it for U00010\n         LA    R15,@Y_Data_Len          Point to length\n         ST    R15,@Y_Parms_U00010+8    Update Parms\n         LA    R15,@Y_ASA_Char          A(Our ASA character)\n         ST    R15,@Y_Parms_U00010+12   Save it\n\n*---------------------------------------------------------------------*\n*       Set our max len to LINESIZE(), if applicable                  *\n*---------------------------------------------------------------------*\n         LHI   R15,VolTbl_Ent_Display_Len Max len of data\nY00020   DS    0H\n         LH    R1,@_LineSize            Get linesize from command line\n         LTR   R1,R1                    Anything?\n         JNP   Y00040                   LINESIZE(MAX) or none, skip\n         CR    R15,R1                   Can we display all the data?\n         JNH   Y00040                   Yes, OK\n         LR    R15,R1                   No, display as much as we can\nY00040   DS    0H\n         STH   R15,@Y_LineSize          Save it\n\n*---------------------------------------------------------------------*\n*       Print headings, if required. By convention, the line count    *\n*      determines what headings to print:                             *\n*        =4095: Hdg1 only                                             *\n*        =4094: Hdg2-4 only                                           *\n*        >60  : Hdg1-4                                                *\n*---------------------------------------------------------------------*\n         MVI   @Y_ASA_Char,C' '         Assume single space\n\n         LH    R15,@_Line_Count         Get current line count\n         CHI   R15,60                   Over a page?\n         JNH   Y00090                   No, skip\n         TM    @_No_Headings,L'@_No_Headings Yes, do we want headings?\n         JO    Y00090                   No, skip\n         ICM   R9,B'1111',@_VolTbl_Ptr  Yes, get A(VolTbl)\n         JZ    Y00090                   None, no headings\n\n*-------------------------------------------------------------------*\n*    We are about to print headings - set up the length field ...   *\n*-------------------------------------------------------------------*\n         LH    R0,@Y_LineSize          Length of source data\n         ST    R0,@Y_Data_Len           Save it\n         L     R10,VolTbl_Hdr_Count-VolTbl_Hdr(R9) Yes, get count\n         AHI   R9,VolTbl_Ent-VolTbl     and point to first entry\n         USING VolTbl_Ent,R9            Assign a base\n\n         LH    R15,@_Line_Count         Get line count\n         CHI   R15,4094                 Hdg2-4 only?\n         JE    Y00070                   Yes, skip Hdg0\n\n*-------------------------------------------------------------------*\n*    ... Hdg0 ...                                                   *\n*-------------------------------------------------------------------*\n         CHI   R10,1                    Check VolTbl_Ent count\n         JL    Y00090                   No heading, skip\n         TM    VolTbl_Ent_Heading_Line1,L'VolTbl_Ent_Heading_Line1 Hdg1\n         JNO   Y00060                   No, skip\n         MVI   @Y_ASA_Char,C'1'         Yes, start a new page\n         LA    R15,VolTbl_Ent_Display   Point to Heading 1\n         ST    R15,@Y_Parms_U00010+4    Update Parms\n         AHI   R15,VolTbl_Ent_Display_Len-8 A(Page Literal)\nY00050   DS    0H\n         MVC   0(4,R15),=C'Page'        Move page lit\n         LH    R0,@_Page_Count          Get Page count\n         AHI   R0,1                     Bump it\n         STH   R0,@_Page_Count          Save it\n         CVD   R0,@Y_DBLWD              Pack it\n         MVC   4(4,R15),=X'40202120'    Move mask\n         ED    4(4,R15),@Y_DBLWD+6      Edit page count\n         OI    7(R15),X'F0'             Make it readable\n         LA    R1,@Y_Parms              A(Parm list)\n         BRAS  R14,U00010               Output Hdg1\n\n         MVI   @Y_ASA_Char,C'0'         skip a line\n         LH    R15,@_Line_Count         Get line count\n         CHI   R15,4094                 Hdg0 only?\n         JNH   Y00070                   No, all headings\n         LHI   R15,1                    Yes, initialize line count\n         J     Y00090                   and skip\n\nY00060   DS    0H\n*-------------------------------------------------------------------*\n*    ... Hdg1-Hdg3 ...                                              *\n*-------------------------------------------------------------------*\n         TM    VolTbl_Ent_Heading_Line,L'VolTbl_Ent_Heading_Line Hdg?\n         JNO   Y00080                   No, end of headings\n         LA    R14,VolTbl_Ent_Display   A(Source data)\n         ST    R14,@Y_Parms_U00010+4    Save it for U00010\n         LA    R1,@Y_Parms              A(Parm list)\n         BRAS  R14,U00010               Output it\n         MVI   @Y_ASA_Char,C' '         single space\nY00070   DS    0H\n         AHI   R9,VolTbl_Ent_Len        A(Next entry\n         BRCT  R10,Y00060               and do next one\nY00080   DS    0H\n         LHI   R15,5                    Re-init line count\n\n         DROP  R9                       No more VolTbl_Ent base\n\nY00090   DS    0H\n*---------------------------------------------------------------------*\n*       ... and then write the data passed to us.                     *\n*---------------------------------------------------------------------*\n         AHI   R15,1                    Bump line count\n         STH   R15,@_Line_Count         Save line count\n         L     R0,@Y_Passed_Data_Len    Get length of data\n         CH    R0,@Y_LineSize           Too long?\n         JNH   Y00100                   No, OK\n         LH    R0,@Y_LineSize           Yes, reset it\nY00100   DS    0H\n         L     R1,@Y_Passed_Data_Ptr    A(Data)\n         LR    R15,R1                   Point past\n         AR    R15,R0                    last character\nY00110   DS    0H\n         S     R15,=FL4'1'              Back up a byte\n         CR    R15,R1                   Too far?\n         JNH   Y00120                   Yes, skip\n         CLI   0(R15),C' '              Trailing space?\n         JE    Y00110                   Yes, back up and try again\nY00120   DS    0H\n         SLR   R15,R1                   Length of\n         AHI   R15,1                     data1\n         ST    R15,@Y_Data_Len          Save length\n         ST    R1,@Y_Parms_U00010+4     Save A(Data)\n         LA    R1,@Y_Parms              A(Parm list)\n         BRAS  R14,U00010               Output it\n\nY00130   DS    0H\n*---------------------------------------------------------------------*\n*       Exit with a return code of 0                                  *\n*---------------------------------------------------------------------*\n         LA    R15,0                    Clear return code\n         J     Y90010                   and exit\n\n\nY90010   DS    0H\n*-------------------------------------------------------------------*\n*    Free up our local storage ...                                  *\n*-------------------------------------------------------------------*\n         LR    R3,R15                   Save return code\n\n         LA    R1,@Y_Dynam              A(Local storage)\n         L     R2,@Y_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         L     R13,4(0,R13)             Rescue A(HSA)\n\n         SSCSTACK POP,                  Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=(R2)                on this stack\n\n         LR    R15,R3                   Restore return code\n\n*-------------------------------------------------------------------*\n*    ... and return to caller                                       *\n*-------------------------------------------------------------------*\n         L     R14,12(0,R13)            Restore return address\n         LM    R0,R12,20(R13)           Restore other registers\n         BSM   0,R14                    and return\n\nY_Literals  DS  0H\n\nY_SYSPRINT  DC  CL8'SYSPRINT'\n\n         LTORG\n\nY_Literals_End  DS  0H\n\n\n@Y_Dynam                  DSECT       Dynamic area for Y00000\n                          DS    18F    O/S Style save area\n@Y_31Bit_Stack_Ptr_Ptr    DS    AL4    A(31-bit Stack Ptr)\n@Y_24Bit_Stack_Ptr_Ptr    DS    AL4    A(24-bit Stack Ptr)\n@Y_DBLWD                  DS    D      Work area\n@Y_LineSize               DS    HL2    Max line size\n@Y_Passed_Data_Ptr        DS    AL4    A(Data passed to us)\n@Y_Passed_Data_Len        DS    FL4    Len of data passed to us\n@Y_Data_Len               DS    FL4    Length of data\n@Y_ASA_Char               DS    X      Carriage control character\n\n@Y_Parms                  DS    0F     Parms for called rtns\n@Y_Parms_Std              DS    3AL4    Standard 3 parms\n@Y_Parms_Extra            EQU   *       Extra parms\n@Y_Parms_U00010           DS    4AL4        for U00010\n                          ORG   ,\n                          DS    0D     Alignment\n@Y_Dynam_Length           EQU   *-@Y_Dynam Length of storage\n\n&PGMNAME CSECT\n\n         DROP  ,\n         POP   USING\n         TITLE 'Z00010: Termination'\n\n         PUSH  USING\n\nZ00010   DS    0H\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Subroutine: Z00010                                                 *\n*                                                                     *\n*  Abstract  : Perform one-time termination processes based on        *\n*              environment.                                           *\n*                                                                     *\n*  Inputs    : R1 : ---> A(@_Dynam)                                   *\n*                        A(31-bit Stack Pointer)                      *\n*                        A(24-bit Stack Pointer)                      *\n*  Outputs   : R15: 0                                                 *\n*                                                                     *\n*  Notes     :                                                        *\n*                                                                     *\n*  History:    1990/06/11 SDDA030 - New                               *\n*              1998/09/21 SDDA030 - Added CLOSEs for SYSIN and        *\n*                                   SYSPRINT in batch mode            *\n*              1998/10/01 SDDA030 - Free up 24-bit storage            *\n*              1999/05/27 SDDA030 - V2.6                              *\n*                                 - Used LIFO Stack for our dynamic   *\n*                                   areas.                            *\n*                                 - Remove CLOSE and STORAGE RELEASE  *\n*              2002/03/11 SDDA030 - V2.17                             *\n*                                 - Freed up the STORGRP selection    *\n*                                   list                              *\n*              2006/04/21 SDDA030 - V2.24                             *\n*                                 - Used standardised calling sequence*\n*              ____/__/__ _______                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         STM   R14,R12,12(R13)          Save callers registers\n         LARL  R11,Z_Literals           Point to our literals\n         USING (Z_Literals,Z_Literals_End),R11 Tell the assembler\n\n         L     R12,0(0,R1)              A(@_Dynam)\n         USING @_Dynam,R12              Tell the assembler\n\n*-------------------------------------------------------------------*\n*    Get an area on the stack for our local storage                 *\n*-------------------------------------------------------------------*\n         L     R2,4(0,R1)               A(31-bit stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         SSCSTACK PUSH,                 Get stack area                 +\n               LEN=@Z_Dynam_Length,      this long                     +\n               STACK=(R2)                using this stack\n\n         LR    R3,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LHI   R1,@Z_Dynam_Length        Its length\n         LA    R14,0                    Clear source address\n         LA    R15,0                     and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R3                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*-------------------------------------------------------------------*\n         ST    R13,4(0,R1)              Chain\n         ST    R1,8(0,R13)               saveareas\n         LR    R13,R1                   Load dynam base\n         USING @Z_Dynam,R13             Assign a base\n         L     R15,@Z_Dynam+4           Get A(HSA)\n         LM    R0,R3,20(R15)            Restore callers registers\n\n         L     R15,4(0,R1)              A(31-bit Stack Pointer)\n         ST    R15,@Z_31Bit_Stack_Ptr_Ptr Save it\n         L     R15,8(0,R1)              A(24-bit Stack Pointer)\n         ST    R15,@Z_24Bit_Stack_Ptr_Ptr Save it\n\n*--------------------------------------------------------------------*\n*   Initialize our standard parmlist                                 *\n*--------------------------------------------------------------------*\n         LA    R15,@_Dynam              A(Dynamic area)\n         ST    R15,@Z_Parms_Std         Save it\n         L     R15,@Z_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)\n         ST    R15,@Z_Parms_Std+4       Save it\n         L     R15,@Z_24Bit_Stack_Ptr_Ptr A(24-bit Stack Pointer)\n         ST    R15,@Z_Parms_Std+8       Save it\n\n*---------------------------------------------------------------------*\n*   Reset our priority, if we changed it                              *\n*---------------------------------------------------------------------*\n         TM    @_CHAP_Done,L'@_CHAP_Done Did we lower our priority?\n         JZ    Z00010I                  No, skip\n         CHAP  1,'S'                    Yes, reset it\n         NI    @_CHAP_Done,X'FF'-L'@_CHAP_Done and reset flag\n\nZ00010I  DS    0H\n*---------------------------------------------------------------------*\n*   Free up the Volume Table, if there is one                         *\n*---------------------------------------------------------------------*\n         ICM   R1,B'1111',@_VolTbl_Ptr A(Info Table)\n         JZ    Z00020                  None, skip\n         L     R0,VolTbl_Hdr_TbLen-VolTbl(R1) Get its length\n         BASR  R2,0\n         USING (*,Z00010_End-1),R2\n         STORAGE RELEASE,               Free the table                 +\n               ADDR=(1),                 starting here                 +\n               LENGTH=(0)                for this long\nZ00010_End DS  0H\n         DROP  R2\n         LA    R15,0                    Clear work register\n         ST    R15,@_VolTbl_Ptr         and clear VolTbl pointer\n\nZ00020   DS    0H\n*---------------------------------------------------------------------*\n*   CLOSE and free any output DCBs                                    *\n*---------------------------------------------------------------------*\n         LA    R15,0                    Clear pointer\n         ST    R15,@Z_Parms_U00010      No DDName\n         ST    R15,@Z_Parms_U00010+4    No data pointer\n         ST    R15,@Z_Parms_U00010+8    No length either\n         ST    R15,@Z_Parms_U00010+12   No ASA CC\n\n         LA    R1,@Z_Parms              A(Parms)\n         BRAS  R14,U00010               Close and free DCBs\n\nZ00030   DS    0H\n*---------------------------------------------------------------------*\n*   Free up the UCB and Volume selection tables                       *\n*---------------------------------------------------------------------*\n         ICM   R1,B'1111',@_UCB_List_Ptr A(List of UCB Masks)\n         JZ    Z00040                   None, skip\n         L     R0,UCB_List_Hdr_Len-UCB_List_Hdr(R1)  Length\n         BASR  R2,0\n         USING (*,Z00030_End-1),R2\n         STORAGE RELEASE,               Free the storage               +\n               ADDR=(1),                 starting here                 +\n               LENGTH=(0)                for this long\nZ00030_End DS  0H\n         DROP  R2\n         XC    @_UCB_List_Ptr,@_UCB_List_Ptr Clear A(UCB List)\n\nZ00040   DS    0H\n         ICM   R1,B'1111',@_XUCB_List_Ptr A(List of XUCB Masks)\n         JZ    Z00050                   None, skip\n         L     R0,UCB_List_Hdr_Len-UCB_List_Hdr(R1)  Length\n         BASR  R2,0\n         USING (*,Z00040_End-1),R2\n         STORAGE RELEASE,               Free the storage               +\n               ADDR=(1),                 starting here                 +\n               LENGTH=(0)                for this long\nZ00040_End DS  0H\n         DROP  R2\n         XC    @_XUCB_List_Ptr,@_XUCB_List_Ptr Clear A(XUCB List)\n\nZ00050   DS    0H\n         ICM   R1,B'1111',@_Vol_List_Ptr A(List of Vol Masks)\n         JZ    Z00060                   None, skip\n         L     R0,Vol_List_Hdr_Len-Vol_List_Hdr(R1)  Length\n         BASR  R2,0\n         USING (*,Z00050_End-1),R2\n         STORAGE RELEASE,               Free the storage               +\n               ADDR=(1),                 starting here                 +\n               LENGTH=(0)                for this long\nZ00050_End DS  0H\n         DROP  R2\n         XC    @_VOL_List_Ptr,@_VOL_List_Ptr Clear A(Vol List)\n\nZ00060   DS    0H\n         ICM   R1,B'1111',@_XVol_List_Ptr A(List of XVol Masks)\n         JZ    Z00070                   None, skip\n         L     R0,Vol_List_Hdr_Len-Vol_List_Hdr(R1)  Length\n         BASR  R2,0\n         USING (*,Z00060_End-1),R2\n         STORAGE RELEASE,               Free the storage               +\n               ADDR=(1),                 starting here                 +\n               LENGTH=(0)                for this long\nZ00060_End DS  0H\n         DROP  R2\n         XC    @_XVOL_List_Ptr,@_XVOL_List_Ptr Clear A(XVol List)\n\nZ00070   DS    0H\n         ICM   R1,B'1111',@_STORGRP_List_Ptr A(List of STORGRP Masks)\n         JZ    Z00070C                  None, skip\n         L     R0,STORGRP_List_Hdr_Len-STORGRP_List_Hdr(R1) Length\n         BASR  R2,0\n         USING (*,Z00070_End-1),R2\n         STORAGE RELEASE,               Free the storage               +\n               ADDR=(1),                 starting here                 +\n               LENGTH=(0)                for this long\nZ00070_End DS  0H\n         DROP  R2\n         XC    @_STORGRP_List_Ptr,@_STORGRP_List_Ptr Clear A(List)\n\nZ00070C  DS    0H\n         TM    @_TSO_Command,L'@_TSO_Command TSO Command?\n         JZ    Z00080                   No, skip\n\n*---------------------------------------------------------------------*\n*       TSO Command Processing                                        *\n*---------------------------------------------------------------------*\n         LA    R15,0                    Clear return code\n         J     Z90010                   and exit\n\nZ00080   DS    0H\n*---------------------------------------------------------------------*\n*       Batch Job Processing                                          *\n*---------------------------------------------------------------------*\n         TM    @_Batch_Environ,L'@_Batch_Environ Is this batch?\n         JZ    Z90010                   No, exit (??)\n\n         LA    R15,0                    Clear return code\n         J     Z90010                   and exit\n\nZ90010   DS    0H\n*-------------------------------------------------------------------*\n*    Free up our local storage ...                                  *\n*-------------------------------------------------------------------*\n         LR    R3,R15                 Save return code\n\n         LA    R1,@Z_Dynam              A(Local storage)\n         L     R2,@Z_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         L     R13,4(0,R13)             Rescue A(HSA)\n\n         SSCSTACK POP,                  Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=(R2)                on this stack\n\n         LR    R15,R3                   Restore return code\n\n*-------------------------------------------------------------------*\n*    ... and return to caller                                       *\n*-------------------------------------------------------------------*\n         L     R14,12(0,R13)            Restore return address\n         LM    R0,R12,20(R13)           Restore other registers\n         BSM   0,R14                    and return\n\n\nZ_Literals DS   0H\n\n         LTORG\n\nZ_Literals_End DS   0H\n\n\n@Z_Dynam                  DSECT       Dynamic area for Z00000\n                          DS    18F    O/S Style save area\n@Z_31Bit_Stack_Ptr_Ptr    DS    AL4    A(31-bit Stack Ptr)\n@Z_24Bit_Stack_Ptr_Ptr    DS    AL4    A(24-bit Stack Ptr)\n\n\n@Z_Parms                  DS    0F    Parms for called rtns\n@Z_Parms_Std              DS    3AL4   Standard 3 parms\n@Z_Parms_Extra            EQU   *      Extra parms\n@Z_Parms_U00010           DS    4AL4      for U00010\n                          ORG   ,\n\n                          DS    0D    Alignment\n@Z_Dynam_Length           EQU   *-@Z_Dynam Length of storage\n\n&PGMNAME CSECT\n\n         DROP  ,\n         POP   USING\n\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SPACE01": {"ttr": 7433, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x18\\x00\\x00\\x01\\x06\\x11\\x1f\\x01\\x06\\x11\\x1f\\x00\\x00@m@m\\x00\\x00\\xd5\\xd6`\\xc5\\xc1\\xe5@@@@'", "ispf": {"version": "02.24", "flags": 0, "createdate": "2006-04-21T00:00:00", "modifydate": "2006-04-21T00:00:00", "lines": 16493, "newlines": 16493, "modlines": 0, "user": "NO-EAV"}, "text": "*PROCESS       XREF(SHORT,UNREFS)\n*PROCESS       NODXREF\n*PROCESS       NORXREF\n*PROCESS       NOALIGN\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*   Assembler Variables                                               *\n*  These variables define various names, processing defaults, etc.,   *\n*  and should be reviewed before assembling.                          *\n*                                                                     *\n*  &PGMNAME                                                           *\n*      Used in the Assembler listing, message IDs, etc                *\n*  &VERSION                                                           *\n*      Used in Title, Statistics line                                 *\n*                                                                     *\n*  &PNLNAME                                                           *\n*      Name of panel used in ISPF display, mode ISPF(S)               *\n*  &SORT_Prompt_Popup_Panel                                           *\n*      Name of the panel used to pronpt, if required, for options for *\n*      the SORT command, under ISPF(S) or ISPF(B)                     *\n*  &OUTPUT_Prompt_Popup_Panel                                         *\n*      Name of the panel used to pronpt, if required, for options for *\n*      the OUTPUT command, under ISPF(S) or ISPF(B)                   *\n*                                                                     *\n*  &ISPF_by_Default                                                   *\n*      Use ISPF for on-line displays                                  *\n*  &ISPF_Default_Type                                                 *\n*      Default type of ISPF display                                   *\n*                                                                     *\n*  &Fore_LSPACE_Wait                                                  *\n*      Maximum seconds to wait for LSPACE to complete when running in *\n*      the foreground (TSO)                                           *\n*  &Back_LSPACE_Wait                                                  *\n*      Maximum seconds to wait for LSPACE to complete when running in *\n*      the background (Batch and STC)                                 *\n*                                                                     *\n*  &Default_SubTask_Count                                             *\n*      Default  number of subtasks to dispatch to issue LSPACEs. If 0,*\n*      defaults to (number of engines * 2) + 1.                       *\n*  &Max_SubTask_Count                                                 *\n*      Maximum  number of subtasks to dispatch to issue LSPACEs. If 0,*\n*      defaults to 16.                                                *\n*                                                                     *\n*---------------------------------------------------------------------*\n         LCLC  &PGMNAME              Program Name\n&PGMNAME SETC  'SPACE'\n         LCLC  &VERSION              Program Version\n&VERSION SETC  'V2.24'\n\n         LCLC  &PNLNAME              Panel Name for ISPF(S)\n&PNLNAME SETC  'SSCSPC02'\n\n         LCLC  &SORT_Prompt_Popup_Panel Name for SORT pop-up prompt\n&SORT_Prompt_Popup_Panel SETC 'SSCSPC03'\n\n         LCLC  &OUTPUT_Prompt_Popup_Panel  Name for OUTPUT pop-up prmt\n&OUTPUT_Prompt_Popup_Panel SETC 'SSCSPC04'\n\n         LCLB  &ISPF_by_Default      Use ISPF if available?\n&ISPF_by_Default SETB 1               Yes, if available\n*&ISPF_by_Default SETB 0               No, TSO line-by-line as default\n\n         LCLC  &ISPF_Default_Type    Default ISPF display type\n&ISPF_Default_Type SETC 'SPACE'       Customized SPACE panel\n*&ISPF_Default_Type SETC 'EDIF'        Edit\n*&ISPF_Default_Type SETC 'BRIF'        Browse\n*&ISPF_Default_Type SETC 'NONE'        None, TSO line-by-line\n\n         LCLA  &Fore_LSPACE_Wait     LSPACE Wait time in foreground\n&Fore_LSPACE_Wait SETA 5              5 seconds\n\n         LCLA  &Back_LSPACE_Wait     LSPACE Wait time in background\n&Back_LSPACE_Wait SETA 0              LSPACE/MIH default\n\n         LCLA  &Default_SubTask_Count Number of Subtasks to dispatch\n&Default_SubTask_Count SETA 0          2 * Nbr engines + 1\n\n         LCLA  &Max_SubTask_Count     Maximum Subtasks to dispatch\n&Max_SubTask_Count     SETA 16         Compatibility with prev versions\n\n\n*---------------------------------------------------------------------*\n*  Do some trivial validation on the Assembly Variables               *\n*---------------------------------------------------------------------*\n         AIF   (&Default_SubTask_Count GE 0).VAL_010\n         MNOTE 4,'Value of &&Default_SubTask_Count negative - using Dyn+\n               amic SubTask count'\n&Default_SubTask_Count SETA 0\n.VAL_010 ANOP\n         AIF   (&Max_SubTask_Count GE 0).VAL_020\n         MNOTE 4,'Value of &&Max_SubTask_Count negative - using default+\n                value of 16'\n&Max_SubTask_Count     SETA 16\n.VAL_020 ANOP\n         AIF   (&Max_SubTask_Count GE &Default_SubTask_Count).VAL_030\n         MNOTE 4,'&&Max_SubTask_Count less than &&Default_SubTask_Count+\n                 - using max of &Default_SubTask_Count'\n&Max_SubTask_Count     SETA &Default_SubTask_Count\n.VAL_030 ANOP\n         AIF   (&Fore_LSPACE_Wait GE 0).VAL_040\n         MNOTE 4,'&&Fore_LSPACE_Wait is negative - setting to 5 sec.'\n&Fore_LSPACE_Wait      SETA 5\n.VAL_040 ANOP\n         AIF   (&Back_LSPACE_Wait GE 0).VAL_050\n         MNOTE 4,'&&Back_LSPACE_Wait is negative - setting to 0'\n&Back_LSPACE_Wait      SETA 0\n.VAL_050 ANOP\n\n\n&PGMNAME TITLE 'Display DASD Free Space'\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Program   : SPACE                                                  *\n*                                                                     *\n*  Abstract  : This program will display the free space on DASD       *\n*              volumes, as selected by the user. This program can     *\n*              run as a batch job or TSO command, using ISPF Dialogue *\n*              Manager facilities, if appropriate.                    *\n*                                                                     *\n*  Inputs    :                                                        *\n*      Parameters :If Batch, N/A                                      *\n*                  If TSO Command, R1 = A(CPPL) (see comments below   *\n*                                                for operands)        *\n*      Files      :If Batch, SYSIN = Control cards                    *\n*      Other      :If TSO Cmd, Command Buffer                         *\n*                                                                     *\n*  Outputs:                                                           *\n*      Returncodes:                                                   *\n*      Messages   :xxxxx                                              *\n*      Files      :If Batch, SYSPRINT = output Messages               *\n*      Other      :None                                               *\n*                                                                     *\n*  Program     Reentrant, problem key and state, standard linkage,    *\n*  Attributes: APF-authorized(maybe), AMODE(31), RMODE(ANY)           *\n*                                                                     *\n*  Implement-:  Unless you have the PTFs for IBM APAR OW48527 APPLYed *\n*  ation        on the system(s) on which this program is running,    *\n*               this program must be be APF Authorized.               *\n*               It is recommended that it also be installed as a TSO  *\n*               command, taking advantage of ISPF Dialog Manager      *\n*               Services, if available. To do this, it must:          *\n*                 - reside in a TSO STEPLIB or LNKLST library         *\n*                 - be named in the AUTHTSF (but *not* the AUTHCMD)   *\n*                   section of SYS1.PARMLIB(IKJTSOxx).                *\n*               Note that all code runs in Problem State and Key; APF *\n*                    authorization is required to issue SYSEVENTs.    *\n*                    See below for further information.               *\n*                                                                     *\n*  Special   :  This program was written to be run either as a program*\n*  Notes       or a TSO command; if as a TSO command, it will use     *\n*              ISPF Dialog Manager services, if available.            *\n*               If this program runs on a system which does *not*     *\n*              have the PTFs for IBM APAR OW48527 installed, it       *\n*              needs to be APF authorized (it uses SYSEVENT DONTSWAP *\n*              and OKSWAP while retrieving DASD info - there is an    *\n*              explanation below, for those of you who have way too   *\n*              much time on your hands). Unfortunately, ISPF DM       *\n*              Services are not available to Authorized TSO Commands. *\n*              The following strategy (?) is used:                    *\n*               - The command is invoked as non-authorized (even      *\n*                 though the load module is LINKed AC(1), because     *\n*                 it is not named in AUTHCMD)                         *\n*               - IKJEFTSR is used to re-invoke itself to perform     *\n*                 the authorized bits (this time it is authorized     *\n*                 because it is named in AUTHTSF)                     *\n*               - The original (unauthorized) command then uses       *\n*                 ISPF DM Services to display the results.            *\n*                                                                     *\n*               When running in Batch, TSO PARSE is used to scan      *\n*              the control cards (from SYSIN), so the syntax of the   *\n*              batch control cards is the same as the TSO Command     *\n*              syntax.                                                *\n*                                                                     *\n*               The following comments apply only when running on     *\n*              systems that do *not* have the PTFs for IBM APAR       *\n*              OW48527 installed:                                     *\n*               This program issues LSPACE macros to retrieve usage   *\n*              data for a volume. If LSPACE is issued against a DASD  *\n*              volume that is RESERVEd on another system, it will     *\n*              hang until the RESERVE is released. This gets          *\n*              particularly annoying when being run from TSO.         *\n*               The program gets hung because:                        *\n*                - LSPACE creates an ESTAE with PURGE=NONE            *\n*                - LSPACE invokes CVAF                                *\n*                - CVAF creates an ESTAE with PURGE=QUIESCE           *\n*                - CVAF tries to touch the device, and hangs because  *\n*                  of a RESERVE                                       *\n*                - A CANCEL is issued for the Address Space           *\n*                - When the 1st ESTAE (CVAFs) gets scheduled, an      *\n*                  attempt is made to QUIESCE the I/O, which never    *\n*                  happens, so we hang.                               *\n*              (Thanks to the IBM ETR folks for their help in figuring*\n*               out what was going on).                               *\n*                                                                     *\n*              To try to circumvent this situation, we issue STIMERMs *\n*              with an exit before issuing LSPACEs. If the exit is    *\n*              invoked, an ESTAE with PURGE=HALT is extablished, and  *\n*              an ABEND U522 issued within the STIMERM exit.          *\n*              The ESTAE from the STIMERM exit is invoked first, so   *\n*              the I/O is PURGEd, and the ESTAE percolates to the     *\n*              CVAF and LSPACE ESTAEs, which can now run because the  *\n*              I/O has been PURGEd.                                   *\n*              So far so good, no APF-authorization required, but ... *\n*              while the LSPACE is trying to get to a RESERVEd device,*\n*              but before the STIMERM pops, SRM/WM may kick in        *\n*              and decide that we should be swapped out. If (s)he     *\n*              does this. the TCBs will be made non-dispatchable,     *\n*              and an attempt will be made to quiesce the I/O.        *\n*              The I/O cannot, in fact, be quiesced, so we end up     *\n*              with a non-dispatchable Address Space waiting for an   *\n*              'unquiescable' I/O to be quiesced. When the STIMERM    *\n*              pops, the exit (which would get us out of this mess)   *\n*              cannot run because we are non-dispatchable.            *\n*              All this is a long way of saying that we have to be    *\n*              APF authorized, so we can issue SYSEVENT DONTSWAP      *\n*              while the LSPACE tasks are running, so that the        *\n*              STIMERM Exit can be dispatched to ESTAE and ABEND.     *\n*                                                                     *\n*              Note that APAR OW48527 addresses this problem by       *\n*              allowing the invoker of LSPACE to specify a time-out,  *\n*              defaulting to 5 seconds. This program determines if    *\n*              the appropriate PTFs have been APPLYed to the active   *\n*              system by checking the LSPACE SVC for literals that    *\n*              are present only when the PTFs have been installed.    *\n*                                                                     *\n*                                                                     *\n*  Coding    : All data areas in Dynamic Storage have names starting  *\n*   Notes       with '@'. One area of Dynamic Storage is acquired     *\n*               during initialization, and is used as a LIFO stack    *\n*               for dynamic storage.                                  *\n*                                                                     *\n*              The names of the Routines follow the pattern:          *\n*                 xnnnnn                                              *\n*               where x    is an alphabetic character, and            *\n*                     n    is a numeric character.                    *\n*                                                                     *\n*              Data in dynamic storage that are globally accessible   *\n*               have names of the form:                               *\n*                @_anyname                                            *\n*              Data associated with a routine typically have names:   *\n*                 x_anyname or @x_anyname                             *\n*               where 'x' is the alphabetic character associated      *\n*                         with the routine                            *\n*              Addressability to globally-accessible dynamic data is  *\n*               via R12; local dynamic data is addressable via R13.   *\n*                                                                     *\n*              Each routine establishes it's own base register,       *\n*               typically R11, for local, read-only variables. Note   *\n*               that there is no base register for the code, except   *\n*               where required  around macros, etc., when R2 is used, *\n*               so be careful if you use R2 for other purposes.       *\n*                                                                     *\n*                                                                     *\n*  Change                                                             *\n*  History   : 1990/06/11 SDDA030 - V1.0                              *\n*                                 - New                               *\n*              1996/03/13 SDDA030 - V1.1                              *\n*                                   Added 4-digit UCB capability      *\n*                                   (D00010)                          *\n*              1997/05/16 SDDA030 - V1.2                              *\n*                                 - Corrected IKJPARS PCL to accept   *\n*                                   4-digit UCBs (C00010)             *\n*                                 - Made Y2K compliant (!)            *\n*                                 - ATTACH subtasks to issue LSPACE   *\n*                                   (D00010, H00010)                  *\n*              1998/09/17 SDDA030 - V2.0                              *\n*                                 - Removed APF checks, and used      *\n*                                   UCBSCAN with DCEAREA operand to   *\n*                                   get DCE info (D00010).            *\n*                                 - Corrected communications between  *\n*                                   mother and daughter TCBs (D07000, *\n*                                   H00010).                          *\n*              1998/09/22 SDDA030 - V2.1                              *\n*                                 - Added Statistics display          *\n*                                 - Runs RMODE(ANY), moving SYSIN and *\n*                                   SYSPRINT I/O routines to 24-bit   *\n*                                   storage. Also move STLINENO       *\n*                                   routine to 24-bit storage.        *\n*              1998/11/13 SDDA030 - V2.2                              *\n*                                 - Used IKJPARS to parse operands in *\n*                                   batch.                            *\n*              1998/11/23 SDDA030 - V2.3                              *\n*                                 - Updated STIMERM exit to POST SPACE*\n*                                   only if subtask is in SVC 78      *\n*                                   (LSPACE).                         *\n*              1999/01/14 SDDA030 - V2.4                              *\n*                                 - Made check for ISPF, TSO command  *\n*                                   or CALL/PGM= checks more consis-  *\n*                                   tent across Batch/TSO environs.   *\n*              1999/03/03 SDDA030 - V2.5                              *\n*                                 - Added version-release variable    *\n*                                   and a new statistics line to      *\n*                                   display it.                       *\n*              1999/05/27 SDDA030 - V2.6                              *\n*                                 - Used LIFO Stack for our dynamic   *\n*                                   areas.                            *\n*                                 - Moved SYSIN and SYSPRINT routines *\n*                                   back into mainline code (rather   *\n*                                   than moving them below-the-line). *\n*              1999/07/30 SDDA030 - V2.7                              *\n*                                 - Added code to cope with SYSIN     *\n*                                   allocated to the terminal (31-bit *\n*                                   SAM is not supported).            *\n*                                 - Added CPU Time to the statistics. *\n*                                 - Added TSO HELP comments.          *\n*              1999/08/20 SDDA030 - V2.8                              *\n*                                 - Fixed up and documented the       *\n*                                   STACK macro.                      *\n*                                 - Added internal stack statistics.  *\n*                                 - Added Wait Time to the statistics.*\n*                                 - Added Routine W00010 to manage    *\n*                                   VolTbl                            *\n*              1999/09/01 SDDA030 - V2.9                              *\n*                                 - Changed method of obtaining totals*\n*                                   to avoid CDS instruction.         *\n*              1999/09/30 SDDA030 - V2.10                             *\n*                                 - Changed default display order to  *\n*                                   ascending order of unit address.  *\n*                                 - Flagged volumes initialized as SMS*\n*                                   (in the VTOC), but not SMS managed*\n*                                   (in the UCB).                     *\n*                                 - Reset Stack statistics for each   *\n*                                   iteration.                        *\n*                                 - Added 'ISPF' keyword to display   *\n*                                   data via ISPF table and panel if  *\n*                                   ISPF services are available.      *\n*                                 - Removed ISPF initialization stuff;*\n*                                   now invoked as a CMD with the     *\n*                                   ISPF keyword.                     *\n*                                 - Moved most of TSO Cmd init. code  *\n*                                   from C00010 to G00010.            *\n*                                 - Honoured NOHEADINGS, NODETAILS and*\n*                                   NOTOTALS when outputting to ISPF. *\n*                                 - Added # vols to Totals line (in   *\n*                                   DevType field).                   *\n*                                 - Made the generation of headings   *\n*                                   more consistent across environ-   *\n*                                   ments.                            *\n*                                 - Added keyword descriptions when   *\n*                                   Parse fails in batch.             *\n*              2000/01/19 SDDA030 - V2.11                             *\n*                                 - Added SORT keywords for all fields*\n*                                 - Added ASCENDING/DESCENDING kwds.  *\n*                                 - Added capability of writing output*\n*                                   to an file:                       *\n*                                    OUTFILE(ddname)                  *\n*                                    OUTDATA(ALL/CB/DISPLAY)          *\n*                                 - Saved control block data in       *\n*                                   the volume table.                 *\n*                                 - Added 24-bit Stack for DCBs,      *\n*                                   STLINENO, etc.                    *\n*                                 - Added &PGMNAME variable, using it *\n*                                   for CSECT name, literals, etc.    *\n*              2000/05/23 SDDA030 - V2.12                             *\n*                                 - Used IOSCDR to test if we can get *\n*                                   out to our DASD before issuing    *\n*                                   LSPACE. Note that this requires   *\n*                                   that we be APF-authorized or have *\n*                                   RACF access to IOSCDR - see       *\n*                                   'Special Notes', above.           *\n*                                 - Added checks to see if we can     *\n*                                   issue IOSCDR.                     *\n*                                 - Removed STIMERM-related stuff,    *\n*                                   since we can't DETACH once LSPACE *\n*                                   has been issued.                  *\n*                                 - Added message if we can't issue   *\n*                                   IOSCDR to check RESERVEs.         *\n*                                 - Added messages when ISPF DM is not*\n*                                   available and the user requested  *\n*                                   ISPF output.                      *\n*                                 - Added msgids to error messages.   *\n*                                 - Added )M info to TSO Help.        *\n*                                 - Removed WTOs from Stack overflows.*\n*                                 - Re-organized internal code:       *\n*                                   - broke out ISPF output handling  *\n*                                   - re-labeled and re-sequenced     *\n*                                     labels.                         *\n*                                 - Left stats line updates as late as*\n*                                   possible (V00010).                *\n*              2001/02/01 SDDA030 - V2.13                             *\n*                                 - Removed IOSCDR stuff added in     *\n*                                   V2.12; instead, ESTAE PURGE=HALT  *\n*                                   and ABEND in the STIMERM exit.    *\n*                                 - Made ourselves non-swappable while*\n*                                   daughter tasks are running.       *\n*                                 - Added IKJEFTSR to re-invoke our-  *\n*                                   selves APFed.                     *\n*                                 - Added message if not APFed.       *\n*                                 - Added IKJEFTSR failure msg.       *\n*                                 - Set RC=4 if no units found.       *\n*                                 - Added MULT to TBADD.              *\n*                                 - Added non-swappable time to stats.*\n*              2001/02/26 SDDA030 - V2.14                             *\n*                                 - Added EDIF/BRIF support.          *\n*                                 - Allowed &PGMNAME as 1st word      *\n*                                   in batch control cards.           *\n*                                 - Populated Stats lines only once.  *\n*                                 - Added &PNLNAME for panel name.    *\n*                                 - Used (GTSIZE-1) as line size for  *\n*                                   TSO line-by-line output.          *\n*                                 - Added VTOCIX, Frag Indx, SMS      *\n*                                   StorGrp and CHPID info.           *\n*                                 - Moved formatting and totalling    *\n*                                   routines back into mainline, to   *\n*                                   reduce non-swap time.             *\n*                                 - Forced ISPF(B) if panel for       *\n*                                   ISPF(S) not available.            *\n*                                 - Added execution environment stats *\n*                                   lines.                            *\n*                                 - Added conditional assembly stuff  *\n*                                   for APAR OW48527.                 *\n*                                 - Used SYS1.NUCLEUS(IECDINIT), CSECT*\n*                                   IECDDEVT to get device type.      *\n*                                 - Added check to ensure IKJEFTSR    *\n*                                   invokes the same code as was orig-*\n*                                   inally invoked.                   *\n*                                 - Added SMS volume status and ass-  *\n*                                   ociated sort field (SMSSTAT).     *\n*                                 - Added 'N/A' in SMS fields for     *\n*                                   non-SMSed volumes (so REXX words  *\n*                                   are consistent).                  *\n*                                 - Added keyword NOLSPACE, for when  *\n*                                   you only need UCBs and Volsers (ie*\n*                                   at IPL to vary devices OFFLINE    *\n*                                   based on volser).                 *\n*              2001/11/12 SDDA030 - V2.15                             *\n*                                 - Added lists of volsers, UCBs in   *\n*                                   selection parms.                  *\n*                                 - Added XVOL, XUCB for excluding    *\n*                                   lists of volsers, units.          *\n*                                 - Corrected STIMERM time bug (micro,*\n*                                   not milli, stupid!)               *\n*                                 - Used the ratio of SubTasks to LPs *\n*                                   as a factor in calculating STIMER *\n*                                   times for LSPACE.                 *\n*                                 - Checked Assembler version when    *\n*                                   generating our assembly time      *\n*                                   stamp.                            *\n*                                 - Retrieved all devices via EDTINFO *\n*                                   when selecting by esoteric.       *\n*              2002/02/12 SDDA030 - V2.16                             *\n*                                 - Used Dynamic displays (rather than*\n*                                   TBDISPL) for ISPF(S)              *\n*                                 - Added LEFT/RIGHT processing for   *\n*                                   ISPF(S)                           *\n*                                 - Removed implicit SORT in ISPF(S); *\n*                                   added SORT cmd to ISPF(S)         *\n*                                 - Added sort prompt pop-up panel in *\n*                                   ISPF(B) and ISPF(S).              *\n*                                 - Added 'Line x of y' in ISPF(S).   *\n*                                 - Added 'Top of Data' and 'Bottom   *\n*                                   of Data' to ISPF(S).              *\n*                                 - Distributed with &ISPF_by_Default *\n*                                   set to 1 (Yes).                   *\n*              2002/03/11 SDDA030 - V2.17                             *\n*                                 - Added STORGRP as a selection      *\n*                                   criterion (as suggested by Ian    *\n*                                   Hobbs).                           *\n*                                 - Added bytes of free space/volume. *\n*                                 - Moved Frag Index, and added check *\n*                                   for max of 999.                   *\n*                                 - Changed RDJFCBs to SWAREQs.       *\n*                                 - Added SSREQ to SMS for volumes in *\n*                                   a STORGRP.                        *\n*                                 - Removed sort-by-column facility,  *\n*                                   and added numeric sort fields, so,*\n*                                   for instance, 1.1G sorts higher   *\n*                                   than 1.1K.                        *\n*                                 - Generated LSPACE error messages   *\n*                                   internally, instead of asking     *\n*                                   LSPACE to do it.                  *\n*                                 - Scaled numbers by 1000 instead of *\n*                                   1024.                             *\n*                                 - BASR to, rather than ATTACH,      *\n*                                   H00010 if we only have 1 subtask. *\n*                                 - Added indicators for CHPIDs not   *\n*                                   phys or log available.            *\n*                                 - Calculated total Free % based on  *\n*                                   bytes rather than tracks          *\n*                                 - Changed internal STACK macro to   *\n*                                   SSCSTACK, so it doesn't conflict  *\n*                                   with IBM's STACK in ATSOMAC.      *\n*              2002/06/11 SDDA030 - V2.18                             *\n*                                 - Moved detail line formatting back *\n*                                   into subtask.                     *\n*                                 - Subtask statistics populated by   *\n*                                   subtask itself.                   *\n*                                 - Total line populated by last      *\n*                                   subtask to end.                   *\n*                                 - Added 'CS collisions' to subtask  *\n*                                   statistics.                       *\n*                                 - If running with OW48527, don't    *\n*                                   WAIT for subtasks to finish; start*\n*                                   outputting lines as soon as       *\n*                                   possible.                         *\n*              2002/08/08 SDDA030 - V2.19                             *\n*                                 - Dynamically determined the status *\n*                                   of APAR OW48527 by checking       *\n*                                   IGC0007H (LSPACE) for the literal *\n*                                   'I/O TIMEOUT'                     *\n*                                 - Removed &OW48527 conditional      *\n*                                   assembly stuff                    *\n*                                 - Converted Branches to Jumps,      *\n*                                   BASRs to BRAS, etc.               *\n*                                 - Removed 'CS collisions' from      *\n*                                   subtask stats, since they always  *\n*                                   seemed to be 0.                   *\n*                                 - Corrected bug when selecting by   *\n*                                   multiple STORGRPs.                *\n*                                 - If we fail APF checks, POST all   *\n*                                   lines in VolTbl as complete.      *\n*                                 - Corrected S0C4 when selecting by  *\n*                                   Unit and no DASD UCBs found (and  *\n*                                   thus no VolTbl created).          *\n*                                 - Corrected bug where the SMS       *\n*                                   Anomaly msg was not being put out *\n*                                   in ISPF modes.                    *\n*                                 - WAITed for up to 2.5 seconds for  *\n*                                   any subtasks to finish before     *\n*                                   terminating.                      *\n*              2003/01/16 SDDA030 - V2.20                             *\n*                                 - Corrected bug in eliminating stats*\n*                                   lines after finding out we aren't *\n*                                   APF'd (E80010).                   *\n*                                 - Corrected bug when finding TIOT   *\n*                                   entry for the OUTFILE DDName.     *\n*                                 - Used consistent registers to      *\n*                                   address VolTbl_Ent throughout.    *\n*              2003/10/07 SDDA030 - V2.21                             *\n*                                 - Fixed S0C4 when adjusting UCB pat-*\n*                                   terns after no UCBs found when    *\n*                                   selecting by UCB.                 *\n*                                 - Added line commands in ISPF(S)    *\n*                                   and ISPF(B) modes:                *\n*                                   . ISPF(x) to switch display modes *\n*                                 - Removed @_No_UCBs_Found flag;     *\n*                                   check nbr vols in table instead.  *\n*                                 - Added Vol Capacity field in the   *\n*                                   display, after VTOC stuff.        *\n*                                 - Allowed system symbols and sub-   *\n*                                   stringing in command line (ran the*\n*                                   command line through ASASYMBM).   *\n*                                 - Returned correct SMS status (ins- *\n*                                   tead of status of 1st vol in      *\n*                                   STORGRP).                         *\n*                                 - Used ATTACHX instead of ATTACH.   *\n*                                 - Added S00010 to WAIT for and      *\n*                                   DETACH subtask TCBs - avoids SA03 *\n*                                   abends.                           *\n*                                 - If we read from SYSIN, send output*\n*                                   to SYSPRINT, even if ISPF is      *\n*                                   available.                        *\n*                                 - Treated SYSPRINT (almost) like    *\n*                                   an OUTFILE - DCB characteristics  *\n*                                   now honoured.                     *\n*              2004/10/15 SDDA030 - V2.22                             *\n*                                 - Fixed bug when returning SMS      *\n*                                   status (Thanks Angel Luis Domin-  *\n*                                   guez).                            *\n*                                 - Added SYSSTATE ARCHLVL=1          *\n*              2005/01/20 SDDA030 - V2.23                             *\n*                                 - Used CSRSI to retrieve info in-   *\n*                                   stead of crawling through control *\n*                                   blocks.                           *\n*              2006/04/21 SDDA030 - V2.24                             *\n*                                 - Added check for z/OS.e in stats.  *\n*                                 - Use TRKCALC to get generally acc- *\n*                                   epted value for Tracksize, instead*\n*                                   of using DS4DEVTK.                *\n*                                 - Rounded displayed values.         *\n*                                 - Display actual value of field in  *\n*                                   SMSG area when in ISPF(S) and the *\n*                                   cursor is on a numeric field and  *\n*                                   ENTER is hit.                     *\n*                                 - IDENTIFY H00010 with a unique name*\n*                                   so we can run multiple copies     *\n*                                   simultaneously.                   *\n*                                 - Added LINESIZE keyword.           *\n*                                 - Standardized internal calling     *\n*                                   sequence so that A(@_Dynam),      *\n*                                   A(31-bit Stack Pointer) and       *\n*                                   A(24-bit Stack Pointer) are always*\n*                                   the 1st 3 parms.                  *\n*                                 - Added name and version to title.  *\n*                                 - Added max LSPACE Wait time        *\n*                                   defaults and MAXLWAIT keyword.    *\n*                                 - Dynamically calculated nbr        *\n*                                   subtasks = 2*engines + 1          *\n*                                 - Added default and max Subtask     *\n*                                   counts Assembly variables - thanks*\n*                                   to MJ Cleary for the suggestion.  *\n*                                 - Added display of installation     *\n*                                   defaults to stats lines.          *\n*                                 - Flagged emulated devices with     *\n*                                   '*E*' following device type.      *\n*                                 - Saved registers on the Linkage    *\n*                                   Stack when we don't know who the  *\n*                                   caller is (and thus the size of   *\n*                                   the save area in R13).            *\n*                                 - Used conditional STORAGE OBTAINs  *\n*                                   when expanding VolTbl.            *\n*                                 - Used separate 24-bit stack for    *\n*                                   OUTFILE stuff (DCBs, etc).        *\n*                                                                     *\n*              ____/__/__ _______                                     *\n*                                                                     *\n*                                                                     *\n*  To Do     : Handle CVAF Abends (S18B).                             *\n*                                                                     *\n*---------------------------------------------------------------------*\n         TITLE 'TSO HELP'\n*---------------------------------------------------------------------*\n*                                                                     *\n*)F Function -                                                        *\n*  The SPACE command displays DASD volume usage statistics, based on  *\n*  user-specified characteristics.                                    *\n*                                                                     *\n*)X Syntax -                                                          *\n*         SPACE UNIT/UCB('Unit-mask')                                 *\n*               VOLUME('Volume-mask')                                 *\n*               NAME('Esoteric-name')                                 *\n*               ATTRIBUTE(STORAGE|STG|PRIVATE|PVT|PUBLIC|SMS)         *\n*               STORGRP('SMS-Storage-Group-Name')                     *\n*               XUNIT/XUCB('Unit-mask')                               *\n*               XVOLUME('Volume-mask')                                *\n*               SORT(id)                                              *\n*               ASCENDING/DESCENDING                                  *\n*               MAXTASKS('#Subtasks')                                 *\n*               OUTFILE(ddname)                                       *\n*               OUTDATA(Display|CB|All)                               *\n*               NOHEADINGS/NOHDG                                      *\n*               NODETAILS                                             *\n*               NOTOTALS                                              *\n*               NOECHO                                                *\n*               STATISTICS|STATS                                      *\n*               ISPF(Space|Edif|Brif|None)                            *\n*               NOLSPACE                                              *\n*               LINESIZE                                              *\n*               MAXLWAIT(secs)                                        *\n*                                                                     *\n*  Required - None                                                    *\n*  Default  - UNIT(*) VOLUME(*)                                       *\n*  Alias    - None                                                    *\n*  Notes    -                                                         *\n*                                                                     *\n*)M Messages -                                                        *\n*                                                                     *\n*))SPACE01I No Devices/Volumes match selection criteria               *\n*           This message is issued when no online DASD devices were   *\n*           found that satisfied the selection criteria defined.      *\n*                                                                     *\n*))SPACE02I Insufficient APF authorization                            *\n*           The SPACE command requires APF authorization, but is cur- *\n*           rently not authorized.                                    *\n*                                                                     *\n*))SPACE03I ISPF DM Services unavailable xx-yy                        *\n*           This message is issued when the SPACE command could not   *\n*           use ISPF Dialogue Management Services to display the      *\n*           results of the command in ISPF format. Either the required*\n*           ISPF modules were unavailable, or the environment is such *\n*           that ISPF Dialogue Management Services are not functional.*\n*           In the message, xx indicates which ISPF service is        *\n*           unavailable, and yy is the return code from that service. *\n*                                                                     *\n*))SPACE04I Forcing non-ISPF output                                   *\n*           This message is issued when the user has requested that   *\n*           the command output be displayed using ISPF Dialogue       *\n*           Management Services, but these services are unavailable.  *\n*           The command output is displayed using TSO line-by-line    *\n*           facilities (PUTLINE).                                     *\n*                                                                     *\n*))SPACE05I CSVQUERY unavailable on this system xxxxx                 *\n*           The CSVQUERY function was attempted to verify that APAR   *\n*           OW48527 had been APPLYed to this system, but CSVQUERY is  *\n*           not available. 'xxxxx' is the Operating System level on   *\n*           which this program is executing.                          *\n*                                                                     *\n*))SPACE06I Program not found in STEPLIB/LNKLST                       *\n*           This command requires that the processing program reside  *\n*           in the current STEPLIB or system LNKLST concatenation,    *\n*           but the program cannot be located.                        *\n*                                                                     *\n*))SPACE07I IKJEFTSR error xx-yy                                      *\n*           The TSO/E Service Routine IKJEFTSR could not complete     *\n*           successfully. xx is the Return Code, and yy the reason    *\n*           code.                                                     *\n*                                                                     *\n*))SPACE08I LSPACE failed for at least 1 volume                       *\n*           The data presented in the table is incomplete because     *\n*           information for at least 1 DASD volume was unavailable.   *\n*                                                                     *\n*))SPACE09I Incompatible versions of SPACE found                      *\n*           The TSO/E Service Routine IKJEFTSR invoked a different    *\n*           version of SPACE (from LNKLST/STEPLIB) than was           *\n*           originally invoked (from ISPLLIB?).                       *\n*                                                                     *\n*))SPACE10I Insufficient storage: nnn volumes omitted                 *\n*           Not enough (above-the-line) storage was available to      *\n*           save the information for all selected DASD volumes. nnn   *\n*           indicates how many volumes were not processed.            *\n*                                                                     *\n*))SPACE11I Internal error - unknown invocation type                  *\n*           The program could not determine how it was invoked. This  *\n*           is most likely to occur when it is being reinvoked via    *\n*           IKJEFTSR, but the parameters passed are unrecognized.     *\n*                                                                     *\n*))SPACE12I OUTFILE DDname xxxxxxxx not useable - ignored.            *\n*           This message is issued when the user has requested that   *\n*           the volume usage data be written to a file, by specifying *\n*           OUTFILE(xxxxxxxx) on the command line. DDName xxxxxxxx    *\n*           could not be OPENed for output.                           *\n*                                                                     *\n*)O Operands -                                                        *\n*))UNIT('Unit-mask') or                                               *\n*   UCB('Unit-mask')    specifies the selection criterion based on    *\n*                       UCB address. Wildcard characters can be used: *\n*                        '*' - all remaining characters               *\n*                        '?' - any single character                   *\n*                        '%' - any single character                   *\n*                       Default is '*'.                               *\n*                       If 'Unit-mask' is less than 4 characters, it  *\n*                       is right-filled with asterisks.               *\n*                       If no UCBs match the 'Unit-mask', and an ast- *\n*                       erisk is the last character in 'Unit-mask',   *\n*                       the trailing asterisk is dropped, a '0'       *\n*                       inserted in the 1st position of 'Unit-mask',  *\n*                       and the UCB scan repeated. This process is    *\n*                       repeated until UCBs are found, or there are no*\n*                       more trailing asterisks in 'Unit-mask'.       *\n*                       Note that a DASD volume must satisfy *all*    *\n*                       criteria specified (UNIT, XUNIT, VOL, XVOL,   *\n*                       NAME, ATTRIBUTE, and/or STORGRP) to be sel-   *\n*                       ected.                                        *\n*                                                                     *\n*))XUNIT('Unit-mask') or                                              *\n*   XUCB('Unit-mask')   specifies the exclusion criterion based on    *\n*                       UCB address.                                  *\n*                                                                     *\n*))VOLUME('Volume-mask')                                              *\n*                       specifies the selection criterion based on    *\n*                       volume serial number. Wildcard characters can *\n*                       be used:                                      *\n*                        '*' - all remaining characters               *\n*                        '?' - any single character                   *\n*                        '%' - any single character                   *\n*                       Default is '*'.                               *\n*                       If 'Volume-mask' is less than 6 characters,   *\n*                       it is right-filled with asterisks             *\n*                       Note that a DASD volume must satisfy *all*    *\n*                       criteria specified (UNIT, XUNIT, VOL, XVOL,   *\n*                       NAME, ATTRIBUTE, and/or STORGRP) to be sel-   *\n*                       ected.                                        *\n*                                                                     *\n*))XVOLUME('Volume-mask')                                             *\n*                       specifies the exclusion criterion based on    *\n*                       volume serial number.                         *\n*                                                                     *\n*))NAME('Esoteric-Name')                                              *\n*                       specifies the selection criterion based on    *\n*                       generic or esoteric name.                     *\n*                       Default is that selection is not based on     *\n*                       generic/esoteric name.                        *\n*                       Note that a DASD volume must satisfy *all*    *\n*                       criteria specified (UNIT, XUNIT, VOL, XVOL,   *\n*                       NAME, ATTRIBUTE, and/or STORGRP) to be sel-   *\n*                       ected.                                        *\n*                                                                     *\n*))ATTRIBUTE(STORAGE|STG|PRIVATE|PVT|PUBLIC|SMS)                      *\n*                       specifies the selection criterion based on    *\n*                       mount attribute. Only one of the options      *\n*                       above can be specified.                       *\n*                       Default is that selection is not based on     *\n*                       mount attribute.                              *\n*                       Note that a DASD volume must satisfy *all*    *\n*                       criteria specified (UNIT, XUNIT, VOL, XVOL,   *\n*                       NAME, ATTRIBUTE, and/or STORGRP) to be sel-   *\n*                       ected.                                        *\n*                                                                     *\n*))STORGRP('SMS-Storage_Group_Name') or                               *\n*       SG('SMS-Storage_Group_Name')                                  *\n*                       specifies the selection criterion based on    *\n*                       SMS Storage Group. Wildcard characters can be *\n*                       used:                                         *\n*                        '*' - all remaining characters               *\n*                        '?' - any single character                   *\n*                        '%' - any single character                   *\n*                       Default is that selection is not based on     *\n*                       SMS Storage Group Names.                      *\n*                       Note that a DASD volume must satisfy *all*    *\n*                       criteria specified (UNIT, XUNIT, VOL, XVOL,   *\n*                       NAME, ATTRIBUTE, and/or STORGRP) to be sel-   *\n*                       ected.                                        *\n*                                                                     *\n*))SORT(id)             specifies the order in which the selected     *\n*                       DASD volumes are displayed:                   *\n*                        id: VOL     - Volser                         *\n*                            UCB     - UCB Name (Device Address)      *\n*                            DEVT    - Device Type                    *\n*                            ATTR    - Mount Attribute                *\n*                            FREET   - Free Tracks on Volume          *\n*                            FREEC   - Free Cylinders on volume       *\n*                            FREEP   - % Volume free                  *\n*                            FREEB   - # Bytes on Volume free         *\n*                            FREEE   - # Free Extents on volume       *\n*                            LARGET  - Largest Free Tracks            *\n*                            LARGEC  - Largest Free Cylinders         *\n*                            VFREED  - VTOC Free DSCBs                *\n*                            VFREEP  - % VTOC Free                    *\n*                            VTRK    - Tracks allocated to VTOC       *\n*                            VIX     - VTOC Index Status              *\n*                            VOLSIZE - Volume Capacity (Bytes)        *\n*                            FRAG    - Fragmentation Index            *\n*                            STORGRP - SMS Storage Group              *\n*                            SMSSTAT - SMS Volume Status              *\n*                            CHPIDS  - CHPIDs                         *\n*                       By default, the display is unsorted, and will *\n*                       normally appear in ascending order of UCB.    *\n*                                                                     *\n*))ASCENDING|DESCENDING specifies the sort order. Significant only    *\n*                       when a SORT id is specified.                  *\n*                       Default is ASCENDING.                         *\n*                                                                     *\n*))MAXTASKS('#Subtasks') specifies the maximum number of sub-tasks to *\n*                       be ATTACHed to retrieve volume information.   *\n*                       If specified, '#Subtasks' must be numeric.    *\n*                       A maximum of 16 subtasks can be ATTACHed.     *\n*                       Default is (number-of-active-CPUs + 1).       *\n*                                                                     *\n*))OUTFILE('ddname')    specifies that the output is to be written to *\n*                       the dataset allocated to 'ddname'. This output*\n*                       is generated in addition to the normal output.*\n*                       Default is no additional output is generated. *\n*                                                                     *\n*))OUTDATA(Display|CB|All) specifies the content of the data written  *\n*                       to the 'ddname' specified in OUTFILE, above.  *\n*                        DISPLAY writes an image of the max display   *\n*                                output (235 bytes)                   *\n*                        CB      writes machine-readable copies of the*\n*                                following control blocks, as returned*\n*                                by the appropriate MVS services:     *\n*                                  UCB Copy        (48 bytes)         *\n*                                  DCE Copy        (48 bytes)         *\n*                                  LSPACE Data     (36 bytes)         *\n*                                  F4 DSCB         (96 bytes)         *\n*                        ALL     writes both CB and DISPLAY, in that  *\n*                                order (228 bytes of CB and 235 bytes *\n*                                of DISPLAY)                          *\n*                       Default is ALL.                               *\n*                                                                     *\n*))NOHEADINGS|NOHDG     specifies that headings (and page breaks) are *\n*                       to be suppressed.                             *\n*                                                                     *\n*))NODETAILS            specifies that detail lines (one per selected *\n*                       DASD volume) are to be suppressed.            *\n*                                                                     *\n*))NOTOTALS             specifies that total lines are to be          *\n*                       suppressed.                                   *\n*                                                                     *\n*))NOECHO               specifies that the command line is not to be  *\n*                       listed in Batch.                              *\n*                                                                     *\n*))STATISTICS|STATS     specifies that internal version and exec-     *\n*                       ution statistics are to be produced.          *\n*                                                                     *\n*))ISPF(Space|Edif|Brif|None)                                         *\n*                       specifies the ISPF services to be used to     *\n*                       present output:                               *\n*                       Space causes the output to be displayed using *\n*                             a customized panel. This is the default *\n*                             if ISPF is specified.                   *\n*                       Edif  invokes ISPF Edit to present the        *\n*                             output                                  *\n*                       Brif  invokes ISPF Browse to present the      *\n*                             output                                  *\n*                       None  uses TSO line-by-line output (PUTLINE)  *\n*                             to present the output.                  *\n*))NOLSPACE             specifies that no VTOC information is to be   *\n*                       gathered - displays only UCB, Volser, DevType,*\n*                       Attr, SMS Info, CHPIDs, Remote Copy Data.     *\n*))LINESIZE(nnn)        specifies the maximum length of the line to be*\n*                       displayed (in TSO line-by-line). Default is   *\n*                       the value returned by the GTSIZE service minus*\n*                       1. As well as a number, the literal 'MAX' can *\n*                       be specified, indicating that all available   *\n*                       data will be displayed.                       *\n*))MAXLWAIT(nnn)        specifies the maximum number of seconds that  *\n*                       each LSPACE will be allowed to complete; after*\n*                       this number of seconds, the LSPACE will be    *\n*                       terminated with an I/O TIMEOUT message. 0     *\n*                       signifies no maximum.                         *\n*                                                                     *\n*---------------------------------------------------------------------*\n         TITLE 'Assembly Variables'\n         LCLC  &ASMDT,&ASMTM         Assembly Date/Time\n&ASMDT   SETC  '&SYSDATC'(1,4).'-'.'&SYSDATC'(5,2).'-'.'&SYSDATC'(7,2)\n&ASMTM   SETC  '&SYSTIME'\n\n         TITLE 'Register Equates'\n         YREGS\n         TITLE '''IEABRC'''\n         COPY  IEABRC\n         TITLE '''SSCSTACK'' Macro'\n         MACRO\n&NAME    SSCSTACK &TYPE,              INIT, PUSH, POP, or TERM         +\n               &LOC=,                 ABOVE/BELOW (TYPE=INIT)          +\n               &LEN=,                 Length required (TYPE=INIT/PUSH) +\n               &STACK=,               Stack origin                     +\n               &ADDR=,                Storage address                  +\n               &OVERFLOW=,            Overflow action (TYPE=PUSH)      +\n               &WTOMSG=               Overflow WTO (If OVERFLOW=WTO)\n         PUSH  PRINT\n         PRINT NOGEN\n.*\n.*-------------------------------------------------------------------*.\n.*                                                                   *.\n.*           S S C S T A C K   M a c r o                             *.\n.*                                                                   *.\n.*  Function: The SSCSTACK macro manages a LIFO stack that can be    *.\n.*            used to relieve the overhead of GETMAIN/FREEMAIN where *.\n.*            appropriate.                                           *.\n.*                                                                   *.\n.*            There are 4 flavours of the SSCSTACK invocation:       *.\n.*              SSCSTACK INIT,...     GETMAIN Stack storage          *.\n.*              SSCSTACK PUSH,...     Reserve storage on the Stack   *.\n.*              SSCSTACK POP,...      Release storage on the Stack   *.\n.*              SSCSTACK TERM,...     FREEMAIN Stack storage         *.\n.*                                                                   *.\n.*            Stack storage *must* be PUSHed and POPped in LIFO      *.\n.*            sequence - no checking is done within the macro to     *.\n.*            ensure this is the case.                               *.\n.*                                                                   *.\n.*  Operation: The usage of the SSCSTACK macro is typically:         *.\n.*              SSCSTACK INIT,...                                    *.\n.*                                                                   *.\n.*              SSCSTACK PUSH,...                                    *.\n.*              SSCSTACK POP,...                                     *.\n.*              SSCSTACK PUSH,...                                    *.\n.*              SSCSTACK POP,...                                     *.\n.*                .    .                                             *.\n.*                .    .                                             *.\n.*                                                                   *.\n.*              SSCSTACK TERM,...                                    *.\n.*                                                                   *.\n.*             When the Stack is initially GETMAINed (SSCSTACK INIT),*.\n.*             the length and Next Available Byte (NAB) are init-    *.\n.*             ialized in the Stack Header. On subsequent SSCSTACK   *.\n.*             PUSH requests, the NAB is incremented by the length   *.\n.*             requested. SSCSTACK POP requests merely update the NAB*.\n.*             with the address passed. SSCSTACK TERM FREEMAINs the  *.\n.*             Stack.                                                *.\n.*             If a SSCSTACK PUSH request would cause a stack over-  *.\n.*             flow, the default processing GETMAINs an area and     *.\n.*             returns the address of this area. The SSCSTACK POP    *.\n.*             request for this area FREEMAINs the storage.          *.\n.*             Default overflow processing can be overridden or      *.\n.*             supplemented on the SSCSTACK PUSH: instead of GETMAIN-*.\n.*             ing additional storage, the SSCSTACK PUSH request can *.\n.*             return a return code, or Abend. Additionally, a WTO   *.\n.*             can be issued with any of the overflow options.       *.\n.*                                                                   *.\n.*             SSCSTACK INIT,                                        *.\n.*                   LEN=Length                                      *.\n.*                   <,LOC=ANY|BELOW>                                *.\n.*                   <,STACK=Stack-pointer>                          *.\n.*                                                                   *.\n.*             SSCSTACK PUSH,                                        *.\n.*                   LEN=Length,                                     *.\n.*                   STACK=Stack-pointer                             *.\n.*                   <,ADDR=Address-pointer>                         *.\n.*                   <,OVERFLOW=Action|WTO|(Action,WTO)>             *.\n.*                   <,WTOMSG=WTO-message>                           *.\n.*                                                                   *.\n.*             SSCSTACK POP,                                         *.\n.*                   ADDR=Address=pointer,                           *.\n.*                   STACK=Stack-pointer                             *.\n.*                                                                   *.\n.*             SSCSTACK TERM,                                        *.\n.*                   STACK=Stack-pointer                             *.\n.*                                                                   *.\n.*-------------------------------------------------------------------*.\n.*\n         LCLC  &LENREG,&STKREG,&ADDREG,&LOCTN\n         AIF   ('&TYPE(1)' EQ 'PUSH').PUSH010\n         AIF   ('&TYPE(1)' EQ 'POP').POP010\n         AIF   ('&TYPE(1)' EQ 'INIT').INIT010\n         AIF   ('&TYPE(1)' EQ 'TERM').TERM010\n         MNOTE 8,'TYPE must be INIT, PUSH, POP, or TERM'\n         AGO   .MEND\n.*\n.INIT010 ANOP\n         AIF   ('&LEN' EQ '').INITE01\n         AIF   ('&LEN'(1,1) NE '(').INIT020\n&LENREG  SETC  '&LEN(1)'\n         AIF   ('&LENREG' NE  '1').INIT030\n         MNOTE 8,'LEN= register must be 0 or 2-15'\n         AGO   .MEND\n         AGO   .INIT030\n.INIT020 ANOP\n&LENREG  SETC  'R0'\n         LHI   &LENREG,&LEN Length of Stack\n.INIT030 ANOP\n&LOCTN   SETC  '&LOC'\n         AIF   ('&LOC' NE '').INIT040\n&LOCTN   SETC  '31'\n.INIT040 ANOP\n         LHI   R1,StackHdr_Length       Length of header\n         AR    &LENREG,R1               Bump length\n         BASR  R2,0\n         USING (*,INI&SYSNDX.A-1),R2\n         STORAGE OBTAIN,                Go get our storage             +\n               LENGTH=(&LENREG),         this long                     +\n               LOC=&LOCTN                wherever we were told\nINI&SYSNDX.A DS 0H\n         DROP  R2\n         XC    0(StackHdr_Length,R1),0(R1)  Clear header\n         ST    R0,StackHdr_StackLen-StackHdr(0,R1) Save length\n         LA    R0,StackHdr_Length(0,R1) A(Current top of stack)\n         ST    R0,StackHdr_NAB-StackHdr(0,R1) Save A(Next Avail Byte)\n         ST    R0,StackHdr_HWM-StackHdr(0,R1) Save High-Water Mark\n         AIF   ('&STACK' EQ '').INIT060\n         AIF   ('&STACK'(1,1) EQ '(').INIT050\n         ST    R1,&STACK                Save Stack origin\n         AGO   .INIT060\n.INIT050 ANOP\n         LR    &STACK(1),R1             Load return register\n         AGO   .INIT060\n.INIT060 ANOP\n         AIF   (D'Stack).MEND\nStack               DSECT\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*   This is a LIFO stack that can be used (where appropriate) to    *\n*  avoid the overhead of repeated GETMAINs/FREEMAINs. Storage       *\n*  within the Stack *must* be used in LIFO sequence.                *\n*                                                                   *\n*-------------------------------------------------------------------*\n\nStackHdr            EQU   *           Start of Header\nStackHdr_StackLen   DS    FL4          Length of Stack\nStackHdr_NAB        DS    AL4          A(Next Available Byte in Stack)\nStackHdr_Reg_Save   DS    4FL4         Register save area\nStackHdr_HWM        DS    AL4          Max NAB value (High-water mark)\nStackHdr_Overflows  DS    FL4          Nbr SSCSTACK PUSH overflows\nStackHdr_Overflow_HWM DS  FL4          Max Overflow amount\nStackHdr_GETMAIN    DS    FL4          Nbr SSCSTACK PUSH ---> GETMAIN\n                    DS    0D           Dblwd alignment\nStackHdr_Length     EQU   *-StackHdr  Length of Header\n\n&SYSECT  &SYSSTYP\n         AGO   .MEND\n.INITE01 ANOP\n         MNOTE 8,'LEN must be specified for SSCSTACK INIT'\n         AGO   .MEND\n.*\n.PUSH010 ANOP\n         LCLA  &INDEX,&COUNT\n         LCLB  &GETMAIN,&WTO,&ABEND,&RC\n         LCLB  &EXCLOP\n         LCLC  &TESTOVFL\n         AIF   ('&OVERFLOW' EQ '').PUSH090\n&INDEX   SETA  0\n&COUNT   SETA  N'&OVERFLOW\n         AIF   (&COUNT GT 0).PUSH020\n&TESTOVFL SETC '&OVERFLOW'\n         AGO   .PUSH030\n.PUSH020 ANOP\n&INDEX   SETA  &INDEX+1\n         AIF   (&INDEX GT &COUNT).PUSH080\n&TESTOVFL SETC '&OVERFLOW(&INDEX)'\n.PUSH030 ANOP\n         AIF   ('&TESTOVFL' NE 'GETMAIN').PUSH040\n         AIF   (&EXCLOP).PUSHE03\n&GETMAIN SETB  1\n&EXCLOP  SETB  1\n         AGO   .PUSH020\n.PUSH040 ANOP\n         AIF   ('&TESTOVFL' NE 'ABEND').PUSH050\n         AIF   (&EXCLOP).PUSHE03\n&ABEND   SETB  1\n&EXCLOP  SETB  1\n         AGO   .PUSH020\n.PUSH050 ANOP\n         AIF   ('&TESTOVFL' NE 'RC').PUSH060\n         AIF   (&EXCLOP).PUSHE03\n&RC      SETB  1\n&EXCLOP  SETB  1\n         AGO   .PUSH020\n.PUSH060 ANOP\n         AIF   ('&TESTOVFL' NE 'WTO').PUSH070\n&WTO     SETB  1\n         AGO   .PUSH020\n.PUSH070 ANOP\n         MNOTE 4,'Unrecognized OVERFLOW operand - &TESTOVFL - GETMAIN s+\n               bstituted.'\n&GETMAIN SETB  1\n         AGO   .PUSH020\n.PUSH080 ANOP\n         AIF   (&EXCLOP).PUSH100\n.PUSH090 ANOP\n&GETMAIN SETB  1\n         AGO   .PUSH100\n.PUSH100 ANOP\n         AIF   ('&STACK' EQ '').PUSHE02\n         AIF   ('&STACK'(1,1) NE '(').PUSH110\n&STKREG  SETC  '&STACK(1)'\n         AGO   .PUSH120\n.PUSH110 ANOP\n&STKREG  SETC  'R15'\n         L     &STKREG,&STACK           A(Stack Origin)\n.PUSH120 ANOP\n         AIF   ('&LEN' EQ '').PUSHE01\n         AIF   ('&LEN'(1,1) NE '(').PUSH130\n&LENREG  SETC  '&LEN(1)'\n         AIF   ('&LENREG' EQ '0').PUSH150\n         AIF   ('&LENREG' EQ 'R0').PUSH150\n         AGO   .PUSH140\n.PUSH130 ANOP\n&LENREG  SETC  'R0'\n.PUSH140 ANOP\n         LHI   &LENREG,&LEN\n.PUSH150 ANOP\n         AHI   &LENREG,7                Ensure a\n         SRL   &LENREG,3                 doubleword\n         SLL   &LENREG,3                 multiple\n         L     R1,StackHdr_NAB-StackHdr(0,&STKREG) A(Next Avail Byte)\n         AR    R1,&LENREG               Bump by length requested\n         SLR   R1,&STKREG               Get Stack used\n         C     R1,StackHdr_StackLen-StacKHdr(0,&STKREG) Too much?\n         JNL   PSH&SYSNDX.E             Yes, Overflow\n         ALR   R1,&STKREG               No, offset to address\n         ST    R1,StackHdr_NAB-StackHdr(0,&STKREG) A(Next Avail Byte)\n         C     R1,StackHdr_HWM-StackHdr(0,&STKREG) Highest?\n         JNH   PSH&SYSNDX.C             No, skip\n         ST    R1,StackHdr_HWM-StackHdr(0,&STKREG) Yes, update HWM\nPSH&SYSNDX.C DS 0H\n         SLR   R1,&LENREG               A(Start of storage area)\n         AIF   ('&LENREG' EQ '0').PUSH155\n         AIF   ('&LENREG' EQ 'R0').PUSH155\n         LR    R0,&LENREG               Length of storage\n.PUSH155 ANOP\n         J     PSH&SYSNDX.M             and skip\nPSH&SYSNDX.E DS 0H\n         ST    R0,StackHdr_Reg_Save-StackHdr(&STKREG)\n         L     R0,StackHdr_Overflows-StackHdr(0,&STKREG) Get count\n         AHI   R0,1                       Bump it\n         ST    R0,StackHdr_Overflows-StackHdr(0,&STKREG) Save it\n         L     R0,StackHdr_Reg_Save-StackHdr(&STKREG)\n         AIF   (NOT &WTO).PUSH220\n         LCLC  &WTOLIT\n         AIF   (K'&WTOMSG LT 3).PUSH160\n&WTOLIT  SETC  '&WTOMSG'(2,K'&WTOMSG-2)\n         AGO   .PUSH170\n.PUSH160 ANOP\n&WTOLIT  SETC  'Stack001 - Stack Overflow'\n.PUSH170 ANOP\n         ST    R1,StackHdr_Reg_Save-StackHdr(&STKREG)  Save R1\n         ST    &LENREG,StackHdr_Reg_Save+4-StackHdr(&STKREG)  Save Len\n         AIF   ('&STKREG' EQ '1').PUSH180,                             +\n               ('&STKREG' EQ 'R1').PUSH180,                            +\n               ('&STKREG' EQ '14').PUSH180,                            +\n               ('&STKREG' EQ 'R14').PUSH180,                           +\n               ('&STKREG' EQ '15').PUSH180,                            +\n               ('&STKREG' EQ 'R15').PUSH180\n         AGO   .PUSH190\n.PUSH180 ANOP\n         ST    R2,StackHdr_Reg_Save+8-StackHdr(&STKREG)  Save R2\n         LR    R2,&STKREG                 Save A(Stack)\n.PUSH190 ANOP\n         WTO   '&WTOLIT',ROUTCDE=11\n         AIF   ('&STKREG' EQ '1').PUSH200,                             +\n               ('&STKREG' EQ 'R1').PUSH200,                            +\n               ('&STKREG' EQ '14').PUSH200,                            +\n               ('&STKREG' EQ 'R14').PUSH200,                           +\n               ('&STKREG' EQ '15').PUSH200,                            +\n               ('&STKREG' EQ 'R15').PUSH200\n         AGO   .PUSH210\n.PUSH200 ANOP\n         LR    &STKREG,R2                 Restore A(Stack)\n         L     R2,StackHdr_Reg_Save+8-StackHdr(&STKREG)  Restore R2\n.PUSH210 ANOP\n         L     R1,StackHdr_Reg_Save-StackHdr(&STKREG)  Restore\n         L     &LENREG,StackHdr_Reg_Save+4-StackHdr(&STKREG)  Rest Len\n.PUSH220 ANOP\n         AIF   (NOT &RC).PUSH230\n         LA    R0,0                     Clear Length register\n         LA    R1,0                     Clear pointer\n         LA    R15,8                    Set return code\n         J     PSH&SYSNDX.O             and skip\n         AGO   .PUSH250\n.PUSH230 ANOP\n         AIF   (NOT &ABEND).PUSH240\n         DC    H'0'                     ABEND\n         AGO   .PUSH250\n.PUSH240 ANOP\n         C     R1,StackHdr_Overflow_HWM-StackHdr(0,&STKREG) Highest?\n         JNH   PSH&SYSNDX.G             No, skip\n         ST    R1,StackHdr_Overflow_HWM-StackHdr(0,&STKREG) Yes, update\nPSH&SYSNDX.G DS 0H\n         L     R1,StackHdr_GETMAIN-StackHdr(0,&STKREG) Get count\n         AHI   R1,1                     Bump it\n         ST    R1,StackHdr_GETMAIN-StackHdr(0,&STKREG) Save it\n         AHI   &LENREG,8                Bump length by 8\n         LR    R15,&STKREG              Get stack address\n         SLL   R15,1                    Clear high-order bit\n         SRL   R15,25                   Clear 24-bit address\n         LTR   R15,R15                  Above-the-line?\n         JZ    PSH&SYSNDX.I             No, skip\n         BASR  R2,0\n         USING (*,PSH&SYSNDX.H-1),R2\n         STORAGE OBTAIN,                Go get our storage             +\n               LENGTH=(&LENREG),         this long                     +\n               LOC=31                    above-the-line\nPSH&SYSNDX.H DS 0H\n         DROP  R2\n         J     PSH&SYSNDX.K             and skip\nPSH&SYSNDX.I DS 0H\n         BASR  R2,0\n         USING (*,PSH&SYSNDX.J-1),R2\n         STORAGE OBTAIN,                Go get our storage             +\n               LENGTH=(&LENREG),         this long                     +\n               LOC=24                    below-the-line\nPSH&SYSNDX.J DS 0H\n         DROP  R2\nPSH&SYSNDX.K DS 0H\n         ST    R0,0(0,R1)               Save length\n         AHI   R1,8                     Bump over our header\n         AHI   R0,-8                    Adjust length\n.PUSH250 ANOP\nPSH&SYSNDX.M DS 0H\n         LA    R15,0                    Clear return register\n         AIF   (NOT &RC).PUSH260\nPSH&SYSNDX.O DS 0H\n.PUSH260  ANOP\n         AIF   ('&ADDR' EQ '').MEND\n         AIF   ('&ADDR'(1,1) NE '(').PUSH270\n         LR    &ADDR(1),R1             Load return register\n         AGO   .MEND\n.PUSH270 ANOP\n         ST    R1,&ADDR                 Save Storage pointer\n         AGO   .MEND\n.PUSHE01 ANOP\n         MNOTE 8,'LEN must be specified for SSCSTACK PUSH'\n         AGO   .MEND\n.PUSHE02 ANOP\n         MNOTE 8,'STACK must be specified for SSCSTACK PUSH'\n         AGO   .MEND\n.PUSHE03 ANOP\n         MNOTE 8,'Mutually exclusive OVERFLOW= operands.'\n         AGO   .MEND\n.*\n.POP010  ANOP\n         AIF   ('&ADDR' EQ '').POPE01\n         AIF   ('&ADDR'(1,1) NE '(').POP020\n&ADDREG  SETC  '&ADDR(1)'\n         AGO   .POP030\n.POP020  ANOP\n&ADDREG  SETC  'R0'\n         L     &ADDREG,&ADDR\n.POP030  ANOP\n         AIF   ('&STACK' EQ '').POPE02\n         AIF   ('&STACK'(1,1) NE '(').POP040\n&STKREG  SETC  '&STACK(1)'\n         AGO   .POP050\n.POP040  ANOP\n&STKREG  SETC  'R15'\n         L     &STKREG,&STACK           A(Stack Origin)\n.POP050  ANOP\n         CR    &ADDREG,&STKREG          Part of our stack?\n         JL    POP&SYSNDX.C             No, skip\n         C     &ADDREG,StackHdr_NAB-StackHdr(0,&STKREG)  Really?\n         JNL   POP&SYSNDX.C             No, skip\n         ST    &ADDREG,StackHdr_NAB-StackHdr(0,&STKREG)\n         J     POP&SYSNDX.E             and exit\nPOP&SYSNDX.C DS 0H\n         AHI   &ADDREG,-8               Back up to our header\n         L     R0,0(0,&ADDREG)          Get length of GETMAINed stg\n         BASR  R2,0\n         USING (*,POP&SYSNDX.D-1),R2\n         STORAGE RELEASE,               Free our storage               +\n               ADDR=(&ADDREG),           starting here                 +\n               LENGTH=(0)                for this long\nPOP&SYSNDX.D DS 0H\n         DROP  R2\nPOP&SYSNDX.E DS 0H\n         AGO   .MEND\n.POPE01  ANOP\n         MNOTE 8,'ADDR must be specified for SSCSTACK POP'\n         AGO   .MEND\n.POPE02  ANOP\n         MNOTE 8,'STACK must be specified for SSCSTACK POP'\n         AGO   .MEND\n.*\n.TERM010 ANOP\n         AIF   ('&STACK' EQ '').TERME02\n         AIF   ('&STACK'(1,1) NE '(').TERM020\n         AIF   ('&STACK(1)' EQ '1').TERM030,                           +\n               ('&STACK(1)' EQ 'R1').TERM030\n         LR    R1,&STACK(1)             Stack origin\n         AGO   .TERM030\n.TERM020 ANOP\n         L     R1,&STACK                A(Stack Origin)\n.TERM030 ANOP\n         L     R0,StackHdr_StackLen-StackHdr(0,R1) Length\n         BASR  R2,0\n         USING (*,TRM&SYSNDX.A-1),R2\n         STORAGE RELEASE,               Free our storage               +\n               ADDR=(1),                 starting here                 +\n               LENGTH=(0)                for this long\nTRM&SYSNDX.A DS 0H\n         DROP  R2\n         AGO   .MEND\n.TERME02 ANOP\n         MNOTE 8,'STACK must be specified for SSCSTACK TERM'\n         AGO   .MEND\n.*\n.MEND    ANOP\n         POP   PRINT\n         MEND\n         TITLE 'IBM Data Areas'\n         PUSH  PRINT\n         PRINT NOGEN\n         IKJCPPL\nCPPL_Length EQU *-CPPL\n\n         IKJCSPL\nCSPL_Length EQU *-CSPL\n\n         IKJCSOA\nCSOA_Length EQU *-CSOA\n\n         IKJPPL\nPPL_Length EQU *-PPL\n\n         IKJIOPL\nIOPL_Length EQU *-IOPL\n\n         IKJUPT\n         IKJTSVT\n         IKJEFLWA\n         IKJPSCB\n         IEFJFCBN\n         DCBD  DSORG=PS\n         IHADCBE\n         IHAPSA\n         CVT   DSECT=YES\n         IHAASVT\n         IHAASCB\n         IHAASXB\n         IHAECVT\n         IHAPCCA\n         IOSDSHID\n         IKJTCB\n         IHARB\n         IHACDE\n         IEZJSCB\n         IEFJSSIB\n         IHASDWA\n         IEFUCBOB PREFIX=YES\n         IOSDPATH\n         IECDDCE\n         IECSDSL1 (4)\n         IEFJESCT\n         IEFJSSOB\n         IEFSSSA\n         IGDVLD\n         IEFTIOT1\n         IEFZB505 LOCEPAX=YES\n         ASASYMBP\n         CSRSIIDF\n\nLSPACE_Parm LSPACE MF=D\nLSPACE_Parm_Length EQU *-LSPACE_Parm\n\nLSPACE_Data LSPACE MF=(D,DATA)\nLSPACE_Data_Length EQU *-LSPACE_Data\n\n         POP   PRINT\n         TITLE 'Local DSECTs'\n*-------------------------------------------------------------------*\n*   This DSECT describes the table in which we maintain DASD        *\n*  volume information. The table is OBTAINed in 31-bit storage      *\n*  the first time it is required, and expands as required to        *\n*  contain the entries required. Note that the table never shrinks. *\n*                                                                   *\n*   Each entry contains the volume information as it will be sent   *\n*  to the user (as well as some internal info). in addition to      *\n*  1 entry per volume, the Headings, Totals and Statistics lines,   *\n*  if requested, occupy table entries.                              *\n*-------------------------------------------------------------------*\n\nVolTbl                    DSECT\n\nVolTbl_Hdr                EQU   *     Info Table Header\nVolTbl_Hdr_TbLen          DS    FL4    Length of table\nVolTbl_Hdr_Count          DS    FL4    Number of used entries\nVolTbl_Hdr_Vols_Eligible  DS    FL4    Nbr Volume entries eligible\nVolTbl_Hdr_Vols_Total     DS    FL4    Nbr Volume entries in table\nVolTbl_Hdr_Vols_Proc      DS    FL4    Nbr Volume entries complete\nVolTbl_Hdr_Total_Off      DS    FL4    Offset of Totals Line\nVolTbl_Hdr_SMS_Off        DS    FL4    Offset of SMS Anomaly line\nVolTbl_Hdr_SubT_Off       DS    FL4    Offset of SubTask Stats Hdg(s)\nVolTbl_Hdr_STIMERM_Adj    DS    FL4    Used by H00010 for STIMERM\n                          DS    0D\nVolTbl_Hdr_LSPACE_Avg     DS    DL8    Used by H00010 for STIMERM\n                          DS    0F     Alignment\nVolTbl_Hdr_ECB            DS    FL4    ECB POSTed when table complete\n                          DS    X      Flag Byte\nVolTbl_Hdr_OW48527        EQU   *-1,X'80' 1... .... APAR OW48527 on\nVolTbl_Hdr_MaxLWait       DS    HL2    Max LSPACE Wait time (secs)\n                          DS    0D     Alignment\nVolTbl_Hdr_Length         EQU   *-VolTbl_Hdr  Length of header\n\nVolTbl_Ent_Start          EQU   *     Info Table Entry\nVolTbl_Ent_ECB            DS    FL4    ECB POSTed when entry complete\n                          DS    X         Status Flag\nVolTbl_Ent_Processed      EQU   *-1,X'80' 1... .... This entry done\nVolTbl_Ent_LSPACE_Fail    EQU   *-1,X'40' .1.. .... LSPACE failed\nVolTbl_Ent_U522           EQU   *-1,X'20' ..1. .... MAXLWAIT(our ESTAE)\n                          DS    X         Entry Descriptor Flag\nVolTbl_Ent_Heading_Line1  EQU   *-1,X'80' 1... .... 1st Heading Line\nVolTbl_Ent_Heading_Line   EQU   *-1,X'40' .1.. .... Other Heading Line\nVolTbl_Ent_Detail_Line    EQU   *-1,X'20' ..1. .... Detail Line\nVolTbl_Ent_Total_Line     EQU   *-1,X'10' ...1 .... Total Line\nVolTbl_Ent_Stats_Line     EQU   *-1,X'08' .... 1... Stats Line\nVolTbl_Ent_SMS_Line       EQU   *-1,X'04' .... .1.. SMS Anomaly Msg\n                          DS    X         Statistics Line Status\nVolTbl_Ent_Stats_CPUTime  EQU   *-1,X'80' 1... .... CPU Time Stats Line\nVolTbl_Ent_Stats_31Stack  EQU   *-1,X'40' .1.. .... 31Bit Stack Stats\nVolTbl_Ent_Stats_24Stack  EQU   *-1,X'20' ..1. .... 24Bit Stack Stats\nVolTbl_Ent_Stats_Done     EQU   *-1,X'01' .... ...1 Stats line filled\n\nVolTbl_Ent_Sort_Start     DS    0D      Start of Sort fields\nVolTbl_Ent_Sort_FreeTrk   DS    DL8      Free Tracks\nVolTbl_Ent_Sort_FreeCyl   DS    DL8      Free Cylinders\nVolTbl_Ent_Sort_FreeBytes DS    DL8      Free Bytes\nVolTbl_Ent_Sort_FreePct   DS    DL8      Free Pct (xx.x)\nVolTbl_Ent_Sort_FreeExt   DS    DL8      Free Extents\nVolTbl_Ent_Sort_LargTrk   DS    DL8      Largest Free Tracks\nVolTbl_Ent_Sort_LargCyl   DS    DL8      Largest Free Cylinders\nVolTbl_Ent_Sort_VTOCTrk   DS    DL8      Tracks in the VTOC\nVolTbl_Ent_Sort_FreeDSCB  DS    DL8      Free DSCBs\nVolTbl_Ent_Sort_VTOCFree  DS    DL8      VTOC % Free\nVolTbl_Ent_Sort_VolSize   DS    DL8      Bytes/Volume\nVolTbl_Ent_Sort_DSCBs     DS    DL8      DSCBs\nVolTbl_Ent_Sort_FragIndex DS    DL8      Frag Index\nVolTbl_Ent_Sort_End       EQU   *       End of Sort fields\n                          ORG   VolTbl_Ent_Sort_Start\nVolTbl_Ent_Sort_Fields    DS    XL(VolTbl_Ent_Sort_End-VolTbl_Ent_Sort_+\n               Start)\n\nVolTbl_Ent_Totals         ORG   VolTbl_Ent_Sort_Start\nVolTbl_Ent_Total_FreeTracks   DS    DL8   Free Tracks\nVolTbl_Ent_Total_FreeCyls     DS    DL8   Free Cylinders\nVolTbl_Ent_Total_FreeBytes    DS    DL8   Free Bytes\nVolTbl_Ent_Total_FreePct      DS    DL8   Free % (xx.x)\nVolTbl_Ent_Total_Extents      DS    DL8   Free Extents\nVolTbl_Ent_Largest_FreeTracks DS    DL8   Largest Free Tracks\nVolTbl_Ent_Largest_FreeCyls   DS    DL8   Largest Free Cyls\nVolTbl_Ent_Total_VTOCTrk      DS    DL8   Total tracks in the VTOCs\nVolTbl_Ent_Total_FreeDSCBs    DS    DL8   Total free DSCBs\nVolTbl_Ent_Total_VTOCFree     DS    DL8   VTOC % Free\nVolTbl_Ent_Total_VolSize      DS    DL8   Total Bytes\nVolTbl_Ent_Total_DSCBs        DS    DL8   Total DSCBs\nVolTbl_Ent_Total_FragIndex    DS    DL8   Total of Frag Indices\nVolTbl_Ent_Total_Vols_OK      DS    FL4   Vols with valid LSPACE data\n                              ORG   ,\n\n                          DS    0F      Align\nVolTbl_Ent_CB_Start       EQU   *        Start of Control Blocks\nVolTbl_Ent_UCBCopy        DS    XL48      UCB Copy\nVolTbl_Ent_DCECopy        DS    XL48        DCE Copy\nVolTbl_Ent_LSPACE_Data    DS    CL(LSPACE_Data_Length) LSPACE\nVolTbl_Ent_DSCB           DS    CL(DS4END-IECSDSL4) Area for F4 DSCB\nVolTbl_Ent_CB_End         EQU   *          End of Control Blocks\n                          ORG   VolTbl_Ent_CB_Start\nVolTbl_Ent_CB_Fields      DS    XL(VolTbl_Ent_CB_End-VolTbl_Ent_CB_Star+\n               t)\n                          ORG   ,\n\nVolTbl_Ent_Display_Start  EQU   *      Start of Display fields\nVolTbl_Ent_Volser         DS    CL6     VOLSER\n                          DS    C\nVolTbl_Ent_DevAddr        DS    CL4     Device Address\n                          DS    CL2\nVolTbl_Ent_DevType        DS    CL8     Device Type\n                          DS    C\nVolTbl_Ent_Attrib         DS    CL3     Mount Status\nVolTbl_Ent_VTOC_SMS       DS    CL1     '*' if VTOC=SMS, UCB\u00ac=SMS\n                          DS    C\nVolTbl_Ent_ErrMsg         DS    0CL80   Error message\nVolTbl_Ent_FreeSpace_Info EQU   *       --- Free Space Info Start\nVolTbl_Ent_FreeTrk        DS    CL6         Nbr Free Tracks\n                          DS    C\nVolTbl_Ent_FreeCyl        DS    CL5         Nbr Free Cylinders\n                          DS    CL2\nVolTbl_Ent_FreePct        DS    CL4         % of volume free\n                          DS    C\nVolTbl_Ent_FreeBytes      DS    CL6         Bytes free on the volume\n                          DS    C\nVolTbl_Ent_FreeExt        DS    CL5         Nbr Free Extents\n                          DS    CL2         Largest Free Extents\nVolTbl_Ent_LargTrk        DS    CL6         Largest Free Tracks\n                          DS    C\nVolTbl_Ent_LargCyl        DS    CL5         Largest Free Cylinders\nVolTbl_Ent_FreeSpace_Info_End EQU *     --- Free Space Info End\n                          DS    C\nVolTbl_Ent_Frag_Indx      DS    CL5         Fragmentation Index\n                          DS    CL2\nVolTbl_Ent_VTOC_Info      EQU   *       --- VTOC Info Start\nVolTbl_Ent_VTOCTrk        DS    CL5         VTOC Tracks\n                          DS    C\nVolTbl_Ent_FreeDSCB       DS    CL5         Free DSCBs in VTOC\n                          DS    C\nVolTbl_Ent_VTOCFree       DS    CL4         % DSCBs free\n                          DS    C\nVolTbl_Ent_VTOCIX         DS    CL2         VTOC Index Status\nVolTbl_Ent_VTOC_Info_End  EQU   *       --- VTOC Info End\n                          DS    C           Volume Size\nVolTbl_Ent_VolSize        DS    CL6         Device capacity (in bytes)\n                          DS    C\nVolTbl_Ent_SMS_Info       EQU   *       --- SMS Info Start\nVolTbl_Ent_SMS_StorGrp    DS    CL8         SMS Storage Group\n                          DS    C\nVolTbl_Ent_SMS_Status     DS    CL12        SMS Volume Status\nVolTbl_Ent_SMS_Info_End   EQU   *       --- SMS Info End\n                          DS    C\nVolTbl_Ent_CHPID_Info     EQU   *       --- CHPID Info Start\nVolTbl_Ent_CHPIDs         DS    CL(8*4)     8 CHPIDs @ 4 bytes each\nVolTbl_Ent_CHPID_Info_End EQU   *       --- CHPID Info End\nVolTbl_Ent_Display_End    EQU   *       End of Display area\nVolTbl_Ent_Display_Len    EQU   *-VolTbl_Ent_Display_Start\n                          ORG   VolTbl_Ent_Display_Start\nVolTbl_Ent_Display        DS    CL(VolTbl_Ent_Display_Len)\n                          ORG   ,\n                          DS    0D      Alignment\nVolTbl_Ent_Len            EQU   *-VolTbl_Ent_Start Entry Length\n                          ORG   VolTbl_Ent_Start\nVolTbl_Ent                DS    CL(VolTbl_Ent_Len)\n                          ORG   ,\n\n*-------------------------------------------------------------------*\n*   This DSECT describes the area of storage used to manage the     *\n*  subtasks ATTACHed to retrieve the volume information.            *\n*-------------------------------------------------------------------*\nSubTask_Area              DSECT       Data for each subtask\n\nSubTask_Area_Hdr          EQU   *\nSubTask_Area_Hdr_Len      DS    FL4    SubPool, Length\nSubTask_Area_Hdr_Count    DS    FL4    Nbr entries following\n                          DS    0D\nSubTask_Area_Hdr_Length   EQU   *-SubTask_Area  Length of Header\n\nSubTask_Area_Ent          EQU   *      1 Entry per subtask\nSubTask_Area_Ent_ECB      DS    FL4     ECB POSTed at Subtask end\nSubTask_Area_Ent_TCB      DS    AL4     A(SubTask TCB - ATTACHX)\nSubTask_Area_Ent_Parms    DS    5AL4    Parms for subtask\n                          DS    0D      Alignment\nSubTask_Area_Ent_Length   EQU   *-SubTask_Area_Ent\n\n*-------------------------------------------------------------------*\n*   This DSECT describes the area of storage used to save the lists *\n*  of UCBs that should be included (UCB) or excluded (XUCB).        *\n*   This storage, if required, is acquired by the routine that      *\n*  PARSEs the parameters (C00010).                                  *\n*-------------------------------------------------------------------*\nUCB_List                  DSECT\n\nUCB_List_Hdr              EQU   *     Start of header\nUCB_List_Hdr_Len          DS    FL4    Length of table\nUCB_List_Hdr_Count        DS    FL4    Number of entries\nUCB_List_Hdr_Length       EQU   *-UCB_List_Hdr  Header length\nUCB_List_Ent              EQU   *     Start of entry\nUCB_List_Ent_UCB_Len      DS    XL1    Len of UCB entered\nUCB_List_Ent_UCB          DS    CL4    UCB, with wildcards = X'FF'\nUCB_List_Ent_Mask         DS    CL4    Wildcard mask, wildcards = X'FF'\n*                                                         other = X'00'\nUCB_List_Ent_Length       EQU   *-UCB_List_Ent   Length of an entry\n\n*-------------------------------------------------------------------*\n*   This DSECT describes the area of storage used to save the lists *\n*  of Volsers that should be included (VOL) or excluded (XVOL).     *\n*   This storage, if required, is acquired by the routine that      *\n*  PARSEs the parameters (C00010).                                  *\n*-------------------------------------------------------------------*\nVol_List                  DSECT\n\nVol_List_Hdr              EQU   *      Start of header\nVol_List_Hdr_Len          DS    FL4     Length of table\nVol_List_Hdr_Count        DS    FL4     Number of entries\nVol_List_Hdr_Length       EQU   *-Vol_List_Hdr  Header length\nVol_List_Ent              EQU   *      Start of entry\nVol_List_Ent_Vol          DS    CL6     Vol, with wildcards=X'FF'\nVol_List_Ent_Mask         DS    CL6     Wildcard mask, wildcards=X'FF'\n*                                                          other=X'00'\nVol_List_Ent_Length       EQU   *-Vol_List_Ent   Length of an entry\n\n*-------------------------------------------------------------------*\n*   This DSECT describes the area of storage used to save the list  *\n*  of SMS Storage Groups entered as a selection criterion.          *\n*   This storage, if required, is acquired by the routine that      *\n*  PARSEs the parameters (C00010).                                  *\n*-------------------------------------------------------------------*\nSTORGRP_List              DSECT\n\nSTORGRP_List_Hdr          EQU   *      Start of header\nSTORGRP_List_Hdr_Len      DS    FL4     Length of table\nSTORGRP_List_Hdr_Count    DS  FL4       Number of entries\nSTORGRP_List_Hdr_Length   EQU *-STORGRP_List_Hdr Header length\nSTORGRP_List_Ent          EQU   *      Start of entry\nSTORGRP_List_Ent_STORGRP  DS    CL(L'VLDSTGRP) Name, wildcards=x'FF'\nSTORGRP_List_Ent_Mask     DS    CL(L'VLDSTGRP) Mask, wildcards=x'FF'\n*                                                 other = X'00'\nSTORGRP_List_Ent_Length   EQU   *-STORGRP_List_Ent Length of an entry\n         TITLE 'Global Dynamic Storage'\n\n*-------------------------------------------------------------------*\n*   This DSECT describes dynamic storage addressable by all rout-   *\n*  ines in this program.                                            *\n*-------------------------------------------------------------------*\n@_Dynam                   DSECT\n\n@_31Bit_Stack_Ptr         DS    AL4    A(General Stack)\n@_31Bit_Stack_Length      EQU   16384-StackHdr_Length 16K Stack\n\n@_24Bit_Stack_Ptr         DS    AL4    A(24-bit Stack)\n@_24Bit_Stack_Length      EQU 2048-StackHdr_Length 2K Stack\n\n@_VolTbl_Ptr              DS    AL4    A(Table of space info)\n\n                          DS    X      Environment flag\n@_Batch_Environ           EQU   *-1,X'80' 1... .... Batch run\n@_TSO_Command             EQU   *-1,X'40' .1.. .... TSO command\n@_OW48527                 EQU   *-1,X'20' ..1. .... OW48527 installed\n@_IKJEFTSR                EQU   *-1,X'10' ...1 .... IKJEFTSR Invoked\n@_CHAP_Done               EQU   *-1,X'08' .... 1... Prty lowered\n\n                          DS    X      Output Options Flags\n@_No_Headings             EQU   *-1,X'80' 1... .... No hdgs\n@_No_Details              EQU   *-1,X'40' .1.. .... No detail\n@_No_Totals               EQU   *-1,X'20' ..1. .... No totals\n@_Statistics              EQU   *-1,X'10' ...1 .... Internal Stats\n@_ISPF_SPACE              EQU   *-1,X'08' .... 1... ISPF tbl and pnl\n@_ISPF_EDIF               EQU   *-1,X'04' .... .1.. ISPF EDIF\n@_ISPF_BRIF               EQU   *-1,X'02' .... ..1. ISPF BRIF\n@_ISPF_Explicit           EQU   *-1,X'01' .... ...1 ISPF Kwd specified\n\n                          DS    X      More Output Options Flags\n@_No_LSPACE               EQU   *-1,X'80' 1... .... Don't issue LSPACE\n@_ReDisplay               EQU   *-1,X'40' .1.. .... Redisplay required\n@_OutData_DISPLAY         EQU   *-1,X'04' .... .1.. OUTDATA(DISPLAY)\n@_OutData_CB              EQU   *-1,X'02' .... ..1. OUTDATA(CB)\n@_OutData_ALL             EQU   *-1,X'01' .... ...1 OUTDATA(ALL)\n\n                          DS    X      Error Flags\n@_VolTbl_GETMAIN_Err      EQU   *-1,X'80' 1... .... Not enough storage\n@_No_APF                  EQU   *-1,X'20' ..1. .... No APF auth\n@_IKJEFTSR_Err            EQU   *-1,X'10' ...1 .... Error in IKJEFTSR\n@_SYSCLOCK_Err            EQU   *-1,X'08' .... 1... SYSCLOCK Mismatch\n@_Incompatible_OS         EQU   *-1,X'04' .... .1.. Incompatible OS\n@_Internal_Err            EQU   *-1,X'02' .... ..1. Unknown parm\n@_LSPACE_Failed           EQU   *-1,X'01' .... ...1 VolTbl Incomplete\n\n@_CPU_Time_Init           DS    DL8    CPU Time at start of pgm\n@_CPU_Time_Used           DS    DL8    Accumulated CPU Time\n\n@_IKJEFTSR_RC             DS    FL4    IKJEFTSR Return code area\n@_IKJEFTSR_Reas           DS    FL4    IKJEFTSR Reason code area\n\n@_IKJEFTSR_TimeStamp_Ptr  DS    AL4    A(TimeStamp for IKJEFTSR)\n@_NSwap_Time              DS    DL8    Non-swappable time\n\n@_Sort_Field              DS    CL8    Sort Field\n@_Sort_Direction          DS    CL1    Sort Direction (A/D)\n\n@_LineSize                DS    HL2    Line Size from command line\n\n@_MaxLWait                DS    HL2    Max LSPACE Wait time (seconds)\n\n@_MaxTasks                DS    HL2    Max LSPACE sub-tasks on cmdline\n@_SubTask_Count           DS    FL4    Nbr subtasks to ATTACH\n@_SubTask_Area_Ptr        DS    AL4    A(SubTask Area)\n@_LP_Count                DS    FL4    Nbr active LPs\n\n@_OutFile_DDname          DS    CL8    DDName of current OUTFILE\n@_OutFile_24Bit_Stack_Ptr DS    AL4    A(24-bit Stack for OutFile DCBs)\n@_OutFile_Chain_Ptr       DS    AL4    A(Start of Output DCB chain)\n@_OutFile_PUT_Code        DS    AL4    A(24-bit PUT code)\n\n*  ------  Selection Criteria  ------\n@_Vol_List_Ptr            DS    AL4     A(List of VOLSER Masks)\n@_XVol_List_Ptr           DS    AL4     A(List of XVOLSER Masks)\n@_UCB_List_Ptr            DS    AL4     A(List of UCB Masks)\n@_XUCB_List_Ptr           DS    AL4     A(List of XUCB Masks)\n@_STORGRP_List_Ptr        DS    AL4     A(List of StorGrps)\n@_UNITNM                  DS    CL8     Unit Name\n                          DS    X       Mount Attribute\n@_ATTRPvt                 EQU   *-1,X'80' 1... .... Private\n@_ATTRPub                 EQU   *-1,X'40' .1.. .... Public\n@_ATTRStg                 EQU   *-1,X'20' ..1. .... Storage\n@_ATTRSMS                 EQU   *-1,X'10' ...1 .... SMS\n\n*-----------------------------  Start of TSO Cmd specific data  -----*\n                          DS    0D                                   *\n@_CPPL_Ptr                DS    AL4     A(Cmd Proc Parm List)        *\n                          DS    X       Flag byte                    *\n@_TSO_Processed           EQU   *-1,X'80' 1... .... Cmd processed    *\n@_ISPLINK                 DS    AL4     A(ISPLINK)                   *\n*-----------------------------  End of TSO Cmd specific data  -------*\n\n*-----------------------------  Start of Batch specific data  -------*\n                          DS    0D                                   *\n@_SYSIN_DCB_Ptr           DS    AL4     A(SYSIN DCB)                 *\n@_Page_Count              DS    HL2     Page Count                   *\n@_Line_Count              DS    HL2     Line Count                   *\n@_Bat_CPPL_Ptr            DS    AL4     A(CPPL in Batch)             *\n                          DS    0F      Alignment                    *\n@_Bat_CPPL                DS    CL(CPPL_Length)  CPPL in Batch       *\n                          DS    0F      Alignment                    *\n@_SYSIN_DCBE              DS    CL(C_SYSIN_DCBE_Length) SYSIN DCBE   *\n*-----------------------------  End of Batch specific data  ---------*\n                          ORG   ,\n*=====================================================================*\n                          DS    0D\n@_Dynam_Length            EQU   *-@_Dynam  Length of Global storage\n\n         TITLE 'Main Program Block'\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Routine   : A00010                                                 *\n*                                                                     *\n*  Abstract  : Main program loop - invoke other routines to perform   *\n*              real work                                              *\n*                                                                     *\n*  Inputs    : As received on invocation                              *\n*  Outputs   : R15: 0 - OK                                            *\n*                   4 - Error encountered                             *\n*                                                                     *\n*  Notes     :                                                        *\n*                                                                     *\n*  History:    1990/06/11 SDDA030 - New                               *\n*              1999/05/27 SDDA030 - V2.6                              *\n*                                 - Used LIFO Stack for our dynamic   *\n*                                   areas.                            *\n*              1999/09/30 SDDA030 - V2.10                             *\n*                                 - Reset Stack statistics for each   *\n*                                   iteration.                        *\n*              2000/01/19 SDDA030 - V2.11                             *\n*                                 - Added 24-bit Stack                *\n*              2001/02/01 SDDA030 - V2.13                             *\n*                                 - Added check for re-invocation by  *\n*                                   IKJEFTSR                          *\n*              2006/04/21 SDDA030 - V2.24                             *\n*                                 - Used standardized calling sequence*\n*              ____/__/__ _______                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n*        PRINT NOGEN\n\n&PGMNAME CSECT\n&PGMNAME AMODE 31\n&PGMNAME RMODE ANY\n\n         SYSSTATE ARCHLVL=1\n\n         J     A00010                   Skip eyecatcher\n         DC    C'&PGMNAME &VERSION  &ASMDT &ASMTM'\n\nA00010   DS    0H\n         BAKR  R14,0                    Save callers registers\n         LARL  R11,A_Literals           Point to our literals\n         USING (A_Literals,A_Literals_End),R11 Tell the assembler\n\n*-------------------------------------------------------------------*\n*    Make sure we're in 31-bit mode                                 *\n*-------------------------------------------------------------------*\n         TAM   ,                        Check AMODE\n         JM    A00020                   AMODE 31, OK\n         SAM31 ,                        Get into 31-bit mode\n\nA00020   DS    0H\n*-------------------------------------------------------------------*\n*    Get some storage for our LIFO stack ...                        *\n*-------------------------------------------------------------------*\n         LHI   R0,@_31Bit_Stack_Length  Length of storage we need\n         SSCSTACK INIT,                 Go get our storage             +\n               LEN=(R0),                 this long                     +\n               LOC=31                    above-the-line\n\n         LR    R3,R1                    Save its address\n\n*-------------------------------------------------------------------*\n*    ... and get some room on it for the globally addressable       *\n*     variables ...                                                 *\n*-------------------------------------------------------------------*\n         SSCSTACK PUSH,                 Get Stack area                 +\n               LEN=@_Dynam_Length,       this long                     +\n               STACK=(R3)                using this stack\n\n         LR    R12,R1                   Point to our storage\n\n         USING @_Dynam,R12              Assign a base\n\n         LA    R0,@_Dynam               A(Our storage)\n         LHI   R1,@_Dynam_Length        Its length\n         LA    R14,0                    Clear source address\n         LA    R15,0                     and length\n         MVCL  R0,R14                   Clear our storage\n\n         ST    R3,@_31Bit_Stack_Ptr     Save A(Stack)\n\n*-------------------------------------------------------------------*\n*    ... and finally get an area on it for our local storage        *\n*-------------------------------------------------------------------*\n         SSCSTACK PUSH,                 Get Stack area                 +\n               LEN=@A_Dynam_Length,      this long                     +\n               STACK=@_31Bit_Stack_Ptr    using this stack\n\n         LR    R3,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LHI   R1,@A_Dynam_Length        Its length\n         LA    R14,0                    Clear source address\n         LA    R15,0                     and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R3                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*    Set up save area, and restore the important registers          *\n*   that we have destroyed                                          *\n*-------------------------------------------------------------------*\n         LR    R13,R1                   Load dynam base\n         USING @A_Dynam,R13             Tell the assembler\n         MVC   4(4,R13),=C'F1SA'        Init save area\n\n         EREG  R0,R3                    Restore callers registers\n\n*--------------------------------------------------------------------*\n*   Initialize our standard parmlist                                 *\n*--------------------------------------------------------------------*\n         LA    R15,@_Dynam              A(Dynamic area)\n         ST    R15,@A_Parms_Std         Save it\n         LA    R15,@_31Bit_Stack_Ptr    A(31-bit Stack Pointer)\n         ST    R15,@A_Parms_Std+4       Save it\n         LA    R15,@_24Bit_Stack_Ptr    A(24-bit Stack Pointer)\n         ST    R15,@A_Parms_Std+8       Save it\n\n         ST    R1,@A_Original_R1        Save R1 on entry\n\n*--------------------------------------------------------------------*\n*   Initialize                                                       *\n*--------------------------------------------------------------------*\n         LA    R15,@A_Original_R1       A(Original R1)\n         ST    R15,@A_Parms_B00010      Save it\n\n         LA    R1,@A_Parms              A(Parmlist)\n         BRAS  R14,B00010               Go do initialization\n\n         ST    R15,@A_Max_RC            Save the return code\n         LTR   R15,R15                  Did it work?\n         JNZ   A00130                   No, skip\n\n*--------------------------------------------------------------------*\n*   If we are being re-invoked by IKJEFTSR ...                       *\n*--------------------------------------------------------------------*\n         TM    @_IKJEFTSR,L'@_IKJEFTSR  IKJEFTSR invocation?\n         JNO   A00100\n\n*--------------------------------------------------------------------*\n*   ... we want to invoke E00010 with the original @_Dynam.          *\n*  Therefore, we save the current @_Dynam address and load up the    *\n*  one passed to us (the original) ...                               *\n*--------------------------------------------------------------------*\n         L     R12,@A_Original_R1       Point to the @_Dynam\n         L     R12,2(0,R12)              to the one passed to us\n\n*--------------------------------------------------------------------*\n*   ... turn on the @_IKJEFTSR flag (since it is not on in this      *\n*  version of @_Dynam) ...                                           *\n*--------------------------------------------------------------------*\n         OI    @_IKJEFTSR,L'@_IKJEFTSR  On the flag\n\n*--------------------------------------------------------------------*\n*   ... invoke E00010 to populate the table ...                      *\n*--------------------------------------------------------------------*\n         LA    R1,@A_Parms              A(Parm list)\n         BRAS  R14,E00010               Go populate table\n\n*--------------------------------------------------------------------*\n*   ... turn off the @_IKJEFTSR flag, and re-point to our @_Dynam    *\n*--------------------------------------------------------------------*\n         NI    @_IKJEFTSR,X'FF'-L'@_IKJEFTSR  Off the flag\n         LR    R12,R3                  Reset @_Dynam base\n\n*--------------------------------------------------------------------*\n*   ... and exit                                                     *\n*--------------------------------------------------------------------*\n         LA    R15,0                   Clear return code\n         ST    R15,@A_Max_RC           Save it\n         J     A90010                  and exit\n\nA00100   DS    0H\n*--------------------------------------------------------------------*\n*   And now loop: Get Input                                          *\n*                 Get Space Info                                     *\n*                 Display Results                                    *\n*--------------------------------------------------------------------*\n\n*--------------------------------------------------------------------*\n*   Reset the CPU Time used so far, in case we have to produce       *\n*    stats ...                                                       *\n*--------------------------------------------------------------------*\n         TIMEUSED STORADR=@_CPU_Time_Init,  Reset CPU Time Used        +\n               LINKAGE=SYSTEM,           as recommended by IBM         +\n               CPU=MIC                   get it in microseconds\n         XC    @_CPU_Time_Used,@_CPU_Time_Used  Clear accum CPU Time\n\n*--------------------------------------------------------------------*\n*   ... and the Stack statistics ...                                 *\n*--------------------------------------------------------------------*\n         L     R15,@_31Bit_Stack_Ptr    Point to the stack\n         LA    R0,0                     Clear work register\n         ST    R0,StackHdr_HWM-StackHdr(R15) Clear high-water mark\n         ST    R0,StackHdr_GETMAIN-StackHdr(R15) Clear converted PUSHs\n         ST    R0,StackHdr_Overflow_HWM-StackHdr(R15) and GETMAIN HWM\n\n*--------------------------------------------------------------------*\n*   ... WAIT for our subtasks to complete ...                        *\n*--------------------------------------------------------------------*\n         LA    R1,@A_Parms              A(ParmList)\n         BRAS  R14,S00010               WAIT for our subtasks\n\n*--------------------------------------------------------------------*\n*   ... and then go and get some input                               *\n*--------------------------------------------------------------------*\n         LA    R1,@A_Parms              A(ParmList)\n         BRAS  R14,C00010               Go get processing parms\n         LTR   R15,R15                  EOF?\n         JNZ   A90010                   Yes, exit\n\n*--------------------------------------------------------------------*\n*   We have something, so go scan the UCBs ...                       *\n*--------------------------------------------------------------------*\n         LA    R1,@A_Parms              A(Parm list)\n         BRAS  R14,D00010               Go get eligible UCBs\n\n         LTR   R15,R15                  Any?\n         JZ    A00120                   Yes, skip\n         C     R15,@A_Max_RC            No, biggest RC so far?\n         JNH   A00130                   No, skip\n         ST    R15,@A_Max_RC            Yes, save it\n         J     A00130                   and skip\n\nA00120   DS    0H\n*--------------------------------------------------------------------*\n*   ... and get the info about them                                  *\n*--------------------------------------------------------------------*\n         LA    R1,@A_Parms              A(Parm list)\n         BRAS  R14,E00010               Go populate table\n\nA00130   DS    0H\n*--------------------------------------------------------------------*\n*   Output the info ...                                              *\n*--------------------------------------------------------------------*\n         LA    R1,@A_Parms              A(Parm list)\n         BRAS  R14,F00010               Output the results\n         C     R15,@A_Max_RC            Biggest RC so far?\n         JNH   A00140                   No, skip\n         ST    R15,@A_Max_RC            Yes, save it\n\nA00140   DS    0H\n*--------------------------------------------------------------------*\n*   ... and do it all again                                          *\n*--------------------------------------------------------------------*\n         L     R15,@A_Max_RC            Get max return code\n         CHI   R15,4                    Too big?\n         JNH   A00100                   No, get more input\n\nA90010   DS    0H\n*-------------------------------------------------------------------*\n*    Perform our Termination routines ...                           *\n*-------------------------------------------------------------------*\n         LA    R1,@A_Parms              A(Parm list)\n         BRAS  R14,Z00010               Clean up\n\n*-------------------------------------------------------------------*\n*    ... delete our 24-bit stack ...                                *\n*-------------------------------------------------------------------*\n         ICM   R1,B'1111',@_24Bit_Stack_Ptr A(Stack below-the-line)\n         JZ    A90020                   None, skip\n         SSCSTACK TERM,                 Free the stack area            +\n               STACK=(1)                 this one\n\nA90020   DS    0H\n*-------------------------------------------------------------------*\n*    ... save our max return code, and free up our local data ...   *\n*-------------------------------------------------------------------*\n         L     R4,@A_Max_RC             Save return code\n\n         LA    R1,@A_Dynam              A(Local storage)\n\n         SSCSTACK POP,                  Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=@_31Bit_Stack_Ptr   on this stack\n\n*-------------------------------------------------------------------*\n*    ... then the global data area ...                              *\n*-------------------------------------------------------------------*\n         LA    R1,@_Dynam               A(Global storage)\n         L     R3,@_31Bit_Stack_Ptr     Rescue Stack pointer\n\n         SSCSTACK POP,                  Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=(R3)                on this stack\n\n*-------------------------------------------------------------------*\n*    ... and finally, the stack itself.                             *\n*-------------------------------------------------------------------*\n         SSCSTACK TERM,                 Free the stack                 +\n               STACK=(R3)                starting here\n\n*-------------------------------------------------------------------*\n*    Restore the callers registers, and exit.                       *\n*-------------------------------------------------------------------*\n         LR    R15,R4                   Restore return code\n         PR    ,                        and return to caller\n\nA_Literals      DS    0H\n\n         LTORG\n\nA_Literals_End  DS    0H\n\n@A_Dynam                  DSECT         Dynamic storage for A00010\n                          DS    18F      Save area\n@A_Original_R1            DS    FL4      R1 on entry\n@A_Max_RC                 DS    FL4      Highest return code\n@A_Parms                  DS    0F       Parms for Called modules\n@A_Parms_Std              DS    3AL4      Standard 3 parms\n@A_Parms_Extra            EQU   *         More parms\n@A_Parms_B00010           DS    AL4         for B00010\n                          ORG   ,\n                          DS    0D       Alignment\n@A_Dynam_Length           EQU   *-@A_Dynam  Length\n\n&PGMNAME CSECT\n\n         DROP  ,\n         TITLE 'B00010: Initialization'\n\n         PUSH  USING\n\nB00010   DS    0H\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Routine   : B00010                                                 *\n*                                                                     *\n*  Abstract  : Perform one-time initialization functions based on     *\n*              environment.                                           *\n*                                                                     *\n*  Inputs    : R1 : ---> A(@_Dynam)                                   *\n*                        A(31-bit Stack Pointer)                      *\n*                        A(24-bit Stack Pointer)                      *\n*                        A(Original R1 on program invocation)         *\n*  Outputs   : R15: 0 - OK                                            *\n*                   4 - Error encountered                             *\n*                                                                     *\n*  Notes     :                                                        *\n*                                                                     *\n*  History:    1990/06/11 SDDA030 - New                               *\n*              1998/09/22 SDDA030 - V2.1                              *\n*                                 - Copied STLINENO or SYSPRINT/SYSIN *\n*                                   I/O routines to 24-bit storage.   *\n*              1998/11/13 SDDA030 - V2.2                              *\n*                                 - Set up TSO environment (IKJTSOEV) *\n*                                   in batch.                         *\n*              1999/01/14 SDDA030 - V2.4                              *\n*                                 - Rationalized ISPF/TSO cmd/CALL    *\n*                                   checks                            *\n*              1999/05/27 SDDA030 - V2.6                              *\n*                                 - Used LIFO Stack for our dynamic   *\n*                                   areas.                            *\n*                                 - Removed copy of SYSIN/SYSPRINT    *\n*                                   routines to 24-bit storage.       *\n*              1999/07/30 SDDA030 - V2.7                              *\n*                                 - Moved SYSIN initialization to     *\n*                                   C00010                            *\n*              1999/09/30 SDDA030 - V2.10                             *\n*                                 - Removed ISPF initialization.      *\n*                                 - Created @_Hdr0-3.                 *\n*              2000/01/19 SDDA030 - V2.11                             *\n*                                 - OPENed SYSPRINT if batch          *\n*              2001/02/01 SDDA030 - V2.13                             *\n*                                 - Added check for parms passed for  *\n*                                   IKJEFTSR invocation.              *\n*              2001/02/26 SDDA030 - V2.14                             *\n*                                 - Moved heading initialization to   *\n*                                   C00010.                           *\n*              2002/08/08 SDDA030 - V2.19                             *\n*                                 - Checked IGC0007H (LSPACE) for     *\n*                                   APAR OW48527                      *\n*              2006/04/21 SDDA030 - V2.24                             *\n*                                   Used standardised calling sequence*\n*              ____/__/__ xxxxxxx - Vx.xx                             *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         STM   R14,R12,12(R13)          Save callers registers\n         LARL  R11,B_Literals           Point to our literals\n         USING (B_Literals,B_Literals_End),R11 Tell the assembler\n\n         L     R12,0(0,R1)              A(@_Dynam)\n         USING @_Dynam,R12              Tell the assembler\n\n*-------------------------------------------------------------------*\n*    Get an area on the stack for our local storage                 *\n*-------------------------------------------------------------------*\n         L     R2,4(0,R1)               A(31-bit stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         SSCSTACK PUSH,                 Get Stack area                 +\n               LEN=@B_Dynam_Length,      this long                     +\n               STACK=(R2)                using this stack\n\n         LR    R3,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LHI   R1,@B_Dynam_Length        Its length\n         LA    R14,0                    Clear source address\n         LA    R15,0                     and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R3                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*-------------------------------------------------------------------*\n         ST    R13,4(0,R1)              Chain\n         ST    R1,8(0,R13)               saveareas\n         LR    R13,R1                   Load dynam base\n         USING @B_Dynam,R13             Assign a base\n\n         L     R15,@B_Dynam+4           Get A(HSA)\n         LM    R0,R3,20(R15)            Restore callers registers\n\n         L     R15,4(0,R1)              A(31-bit Stack Pointer)\n         ST    R15,@B_31Bit_Stack_Ptr_Ptr Save it\n         L     R15,8(0,R1)              A(24-bit Stack Pointer)\n         ST    R15,@B_24Bit_Stack_Ptr_Ptr Save it\n\n*---------------------------------------------------------------------*\n*    Clear our various flags, and save the original R1                *\n*---------------------------------------------------------------------*\n         NI    @_TSO_Command,X'FF'-L'@_TSO_Command Off TSO flag\n         NI    @_Batch_Environ,X'FF'-L'@_Batch_Environ Off Batch flag\n         L     R15,12(0,R1)             A(Original R1)\n         L     R15,0(0,R15)             Get it\n         ST    R15,@B_Original_R1       Save it\n\n*---------------------------------------------------------------------*\n*   Determine the environment under which we were invoked:            *\n*     TSO Command: R1 --> CPPL                                        *\n*     IKJEFTSR Reinvocation:                                          *\n*        R1 ---> A(Parm1): HL2'4',A(Original @_Dynam)                 *\n*                A(Parm2): HL2'?',CL?(Copy of start of @_Dynam)       *\n*     Batch: Anything else                                            *\n*---------------------------------------------------------------------*\n         ICM   R1,B'1111',@B_Original_R1 Restore original R1\n         JZ    B03000                   Nothing, not a TSO cmd\n         L     R14,PSATNEW-PSA(0)       Yes, get A(our TCB)\n         L     R14,TCBJSCB-TCB(R14)     Get A(Our JSCB)\n         SLL   R14,8                    Clean\n         SRL   R14,8                      it\n         ICM   R14,B'1111',JSCBPSCB-IEZJSCB(R14) Get A(PSCB)\n         JZ    B03000                   None, not TSO\n         C     R14,CPPLPSCB-CPPL(R1)    Are we passed a CPPL?\n         JE    B02000                   Yes, go process\n\n*---------------------------------------------------------------------*\n*   We were passed a parm, but it is not the CPPL; check out the      *\n*  parms to see if we are being re-invoked by IKJEFTSR:               *\n*                                                                     *\n*     R1 ---> ---> H'4',A(@_Dynam)                                    *\n*             ---> H'16',1st 16 bytes of @_Dynam                      *\n*---------------------------------------------------------------------*\n         TM    0(R1),X'80'              Only 1 parm?\n         JO    B03000                   Yes, not IKJEFTSR, assume batch\n         TM    4(R1),X'80'              No, 2nd parm the last?\n         JNO   B80010                   No, error\n\n         L     R15,0(0,R1)              Get A(1st parm)\n         LH    R14,0(0,R15)             Get its length\n         CHI   R14,4                    Is it the right length?\n         JNE   B80010                   No, not IKJEFTSR\n         L     R0,2(0,R15)              Maybe, load A(Original @_Dynam)\n\n         L     R14,4(0,R1)              Get A(2nd Parm)\n         LH    R15,0(0,R14)             Get its length\n         LA    R14,2(0,R14)             Point to it\n         LR    R1,R15                   Length to check\n         CLCL  R0,R14                   Is this really @_Dynam?\n         JNE   B80010                   No, error\n\n         OI    @_IKJEFTSR,L'@_IKJEFTSR  Yes, set our flag\n         LA    R15,0                    Clear the return code\n         J     B90010                   and exit\n\nB02000   DS    0H\n*---------------------------------------------------------------------*\n*   TSO Command Initialization - save A(CPPL) ...                     *\n*---------------------------------------------------------------------*\n         OI    @_TSO_Command,L'@_TSO_Command    Set TSO flag\n\n         L     R1,@B_Original_R1        Get original R1 - A(CPPL)\n         ST    R1,@_CPPL_Ptr            Save A(CPPL)\n\n*---------------------------------------------------------------------*\n*   ... clear our flag ...                                            *\n*---------------------------------------------------------------------*\n         NI    @_TSO_Processed,X'FF'-L'@_TSO_Processed\n\n*---------------------------------------------------------------------*\n*   ... and go check the status of OW48527                            *\n*---------------------------------------------------------------------*\n         J     B04000                   go do it\n\nB03000   DS    0H\n*---------------------------------------------------------------------*\n*   Batch Job Initialization - initialize page and line counts ...    *\n*---------------------------------------------------------------------*\n         OI    @_Batch_Environ,L'@_Batch_Environ Set Batch flag\n\n         LA    R15,0                    Clear work register\n         STH   R15,@_Page_Count         Clear page count\n\n*---------------------------------------------------------------------*\n*   ... and set up the TSO environment by invoking IKJTSOEV, saving   *\n*  the address of the CPPL we get back.                               *\n*---------------------------------------------------------------------*\n         LA    R1,@B_Link_Parms         A(Parameter list)\n         LA    R15,@B_Link_Parms+20     Point past them\n         LHI   R14,4                    4 parameters\n\nB03010   DS    0H\n         ST    R15,0(0,R1)              Save Parm ptr\n         AHI   R15,4                    Bump pointer\n         AHI   R1,4                     Bump parm pointer\n         BRCT  R14,B03010               and do it again\n         LA    R15,@_Bat_CPPL_Ptr       A(Command Buffer pointer)\n         ST    R15,@B_Link_Parms+16     Save it\n         OI    @B_Link_Parms+16,X'80'   Flag as last\n\n         MVC   @B_LINKX,B_LINKX         Move Link L-Form\n         LARL  R2,B03020                Error return here\n         LINKX EP=IKJTSOEV,             Establish TSO environment      +\n               ERRET=(2),                go here if LINK error         +\n               MF=(E,@B_Link_Parms),     using these parms             +\n               SF=(E,@B_LINKX)           keep ourselves re-entrant\n         ICM   R14,B'1111',@_Bat_CPPL_Ptr Get A(CPPL returned)\n         JNZ   B04000                   OK, check OW48527\n\nB03020   DS    0H\n*---------------------------------------------------------------------*\n*   If we didn't get a CPPL address back from IKJTSOEV, but we are    *\n*  running in a TSO address space, build our own copy of a CPPL that  *\n*  we can use to build the PPL                                        *\n*---------------------------------------------------------------------*\n         CHI   R15,24                   No, TSO env present?\n         JH    B03810                   No, something else, error\n\n         L     R14,PSATOLD-PSA(0)       Get A(our TCB)\n         L     R14,TCBJSCB-TCB(R14)     Get A(Our JSCB)\n         SLL   R14,8                    Clean\n         SRL   R14,8                      it\n         ICM   R14,B'1111',JSCBPSCB-IEZJSCB(R14) Get A(PSCB)\n         JZ    B03810                   None, can't use TSO\n         ST    R14,@_Bat_CPPL+CPPLPSCB-CPPL Save A(PSCB)\n\n         L     R15,PSCBUPT-PSCB(R14)    A(UPT)\n         ST    R15,@_Bat_CPPL+CPPLUPT-CPPL Save A(UPT)\n\n         L     R14,PSAAOLD-PSA(0)       Get A(our ASCB)\n         L     R14,ASCBASXB-ASCB(R14)   A(Our ASXB)\n         L     R14,ASXBLWA-ASXB(R14)    A(LWA)\n         L     R15,LWAPECT-LWA(R14)     A(ECT)\n         ST    R15,@_Bat_CPPL+CPPLECT-CPPL Save A(ECT)\n         LA    R15,@_Bat_CPPL           A(Our pseudo CPPL)\n         ST    R15,@_Bat_CPPL_Ptr       Save it\n\n         J     B04000                   Check status of OW48527\n\nB03810   DS    0H\n         LA    R15,4                    Error creating TSO environment\n         J     B90010                   exit\n\nB04000   DS    0H\n*-------------------------------------------------------------------*\n*    Everything is OK so far, so we want to check the status of     *\n*   APAR OW48527, which added a time-out to the LSPACE SVC (we will *\n*   do things differently if the APAR is installed). We check the   *\n*   module IGC0007H (LSPACE) for the literal 'I/O TIMEOUT', part    *\n*   of a new error message that came in with OW48527.               *\n*-------------------------------------------------------------------*\n         MVC   @B_CSVQUERY,B_CSVQUERY   Move L-Form\n         CSVQUERY INEPNAME=B_IGC0007H,  EP Name                        +\n               OUTLOADPT=@B_IGC0007H_Ptr,  return load point           +\n               OUTLENGTH=@B_IGC0007H_Len,  and length                  +\n               PLISTVER=MAX,               max parm list               +\n               MF=(E,@B_CSVQUERY)          staying reentrant\n         LTR   R15,R15                  How did we do?\n         JZ    B04010C                  OK, skip\n         CHI   R15,20                   Incompatible OS?\n         JE    B80020                   Yes, skip\n         J     B04910                   No, assume no OW48527\nB04010C  DS    0H\n\n         ICM   R14,B'1111',@B_IGC0007H_Len OK, get the length\n         JZ    B04910                   Nothing, skip\n         ICM   R15,B'1111',@B_IGC0007H_Ptr Get the address\n         JZ    B04910                   None, exit\n\n         LHI   R1,L'B_OW48527_Lit-1     EX length of literal\n         SLR   R14,R1                   Adjust the length to check\n\nB04020   DS    0H\n         EX    R1,B_Check_OW48527       Check for literal\n         JE    B04030                   Found it, skip\n         AHI   R15,1                    Not it, bump pointer\n         BRCT  R14,B04020               and check again\n         J     B04910                   Not found, exit\n\nB04030   DS    0H\n         OI    @_OW48527,L'@_OW48527    Indicate OW48527 present\n\nB04910   DS    0H\n         LA    R15,0                    Clear return code\n         J     B90010                   and exit\n\nB80010   DS    0H\n*-------------------------------------------------------------------*\n*    Unknown Parm, exit with error                                  *\n*-------------------------------------------------------------------*\n\n         OI    @_Internal_Err,L'@_Internal_Err Set our flag\n         LA    R15,8                    Set error return code\n         J     B90010                   and exit\n\nB80020   DS    0H\n*-------------------------------------------------------------------*\n*    Incompatible OS, set flag and return code                      *\n*-------------------------------------------------------------------*\n         OI    @_Incompatible_OS,L'@_Incompatible_OS Set our flag\n         LA    R15,8                    and return code\n         J     B90010                   and exit\n\nB90010   DS    0H\n*-------------------------------------------------------------------*\n*    Free up our local storage ...                                  *\n*-------------------------------------------------------------------*\n         LR    R3,R15                 Save return code\n\n         LA    R1,@B_Dynam              A(Local storage)\n         L     R2,@B_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n\n         L     R13,4(0,R13)             Rescue A(HSA)\n\n         SSCSTACK POP,                  Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=(2)                 on this stack\n\n         LR    R15,R3                   Restore return code\n\n*-------------------------------------------------------------------*\n*    ... and return to caller                                       *\n*-------------------------------------------------------------------*\n         L     R14,12(0,R13)            Restore return address\n         LM    R0,R12,20(R13)           Restore other registers\n         BSM   0,R14                    and return\n\nB_Literals            DS    0H\n\nB_Check_OW48527 CLC  B_OW48527_Lit,0(R15)  Check for OW48527 literal\n\n         PUSH  PRINT\n         PRINT NOGEN\n\nB_IGC0007H      DC    CL8'IGC0007H'   LSPACE SVC name\nB_OW48527_Lit   DC    C'I/O TIMEOUT'  Literal indicating OW48527\n\nB_LINKX  LINKX EP=IKJTSOEV,                                            +\n               SF=L\nB_LINKX_Length EQU *-B_LINKX\n\n         CSVQUERY PLISTVER=MAX,                                        +\n               MF=(L,B_CSVQUERY)\nB_CSVQUERY_Length EQU *-B_CSVQUERY\n\n\n         POP   PRINT\n\n\n         LTORG\nB_Literals_End            DS    0H\n\n@B_Dynam                  DSECT         Dynamic area for B00000\n                          DS    18F      O/S Style save area\n@B_31Bit_Stack_Ptr_Ptr    DS    AL4      A(31-bit Stack Ptr)\n@B_24Bit_Stack_Ptr_Ptr    DS    AL4      A(24-bit Stack Ptr)\n@B_Original_R1            DS    AL4      Value of R1 at program entry\n@B_Macros                 DS    0F       Macro area\n@B_LINKX                  DS    CL(B_LINKX_Length)  L-Form of LINKX\n@B_Link_Parms             DS    5AL4     Parms for Link\n                          DS    4AL4     Dummy parms\n                          ORG   @B_Macros\n@B_CSVQUERY               DS    CL(B_CSVQUERY_Length) L-Form CSVQUERY\n@B_IGC0007H_Ptr           DS    AL4      A(IGC0007H)\n@B_IGC0007H_Len           DS    AL4      Length of IGC0007H\n                          ORG   ,\n                          DS    0D       Alignment\n@B_Dynam_Length           EQU   *-@B_Dynam  Length of storage required\n\n&PGMNAME CSECT\n\n         DROP  ,\n         POP   USING\n         TITLE 'C00010: Get Input Data'\n\n         PUSH  USING\n\nC00010   DS    0H\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Routine   : C00010                                                 *\n*                                                                     *\n*  Abstract  : Get selection criteria for extracting UCB info         *\n*                                                                     *\n*  Inputs    : R1 : ---> A(@_Dynam)                                   *\n*                        A(31-bit Stack Pointer)                      *\n*                        A(24-bit Stack Pointer)                      *\n*  Outputs   : R15: 0 - OK                                            *\n*                   4 - EOF, 'END' etc.                               *\n*                                                                     *\n*  Operation : For a batch job,                                       *\n*               Read SYSIN                                            *\n*               Build a pseudo command buffer                         *\n*              Parse command buffer                                   *\n*                                                                     *\n*  Notes     :                                                        *\n*                                                                     *\n*  History:    1990/06/11 SDDA030 - New                               *\n*              1998/09/22 SDDA030 - V2.1                              *\n*                                 - Calculated default number of      *\n*                                   subtasks as the number of CPUs    *\n*                                   plus 1.                           *\n*                                 - Added U, UCB as aliaii for UNIT   *\n*                                   and V as an alias for VOL in      *\n*                                   Batch processing.                 *\n*                                 - Added STATS and MAXTASK keyword   *\n*                                   support.                          *\n*              1998/11/13 SDDA030 - V2.2                              *\n*                                 - Used IKJPARS to parse batch ctl   *\n*                                   cards.                            *\n*              1999/05/27 SDDA030 - V2.6                              *\n*                                 - Used LIFO Stack for our dynamic   *\n*                                   areas.                            *\n*                                 - Get SYSIN DCB storage and OPEN as *\n*                                   required.                         *\n*                                 - CLOSE and free SYSIN DCB at EOF.  *\n*              1999/07/30 SDDA030 - V2.7                              *\n*                                 - Use 24-bit EOD routine when 31-bit*\n*                                   SAM not supported for SYSIN.      *\n*              1999/09/30 SDDA030 - V2.10                             *\n*                                 - Removed ISPF stuff.               *\n*                                 - Set @_Line_Count to generate Hdr0 *\n*                                   only before echo of cmd line.     *\n*                                 - Display keyword descriptions in   *\n*                                   batch when invalid input found.   *\n*              2000/01/19 SDDA030 - V2.11                             *\n*                                 - PARSE keywords OUTFILE, OUTDATA.  *\n*              2001/02/26 SDDA030 - V2.14                             *\n*                                 - Added ISPF subfields S, E, and B. *\n*                                 - Allowed 'SPACE' as the 1st word   *\n*                                   in batch control cards.           *\n*                                 - Moved heading initialization from *\n*                                   B00010.                           *\n*                                 - Added SORT Subfields for VIX,     *\n*                                   FRAG, STORGRP, CHPIDS.            *\n*              2001/11/12 SDDA030 - V2.15                             *\n*                                   Added lists of UCBs, Volsers.     *\n*                                   Added XUCB, XVOL.                 *\n*              2002/03/11 SDDA030 - V2.17                             *\n*                                   Added STORGRP as a selection      *\n*                                   criterion.                        *\n*              2003/10/07 SDDA030 - V2.21                             *\n*                                   Used ASASYMBM to resolve symbols  *\n*                                   within VOL and XVOL.              *\n*                                   Stripped leading spaces from SYSIN*\n*                                   before checking for command name. *\n*              2006/04/21 SDDA030 - V2.24                             *\n*                                 - Calculated default number of      *\n*                                   subtasks as 2 * number of CPUs    *\n*                                   plus 1.                           *\n*                                   Used standardised calling sequence*\n*                                                                     *\n*              ____/__/__ _______                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         STM   R14,R12,12(R13)          Save callers registers\n         LARL  R11,C_Literals           Point to our literals\n         USING (C_Literals,C_Literals_End),R11 Tell the assembler\n\n         L     R12,0(0,R1)              A(@_Dynam)\n         USING @_Dynam,R12              Tell the assembler\n\n*-------------------------------------------------------------------*\n*    Get an area on the stack for our local storage                 *\n*-------------------------------------------------------------------*\n         L     R2,4(0,R1)               A(31-bit stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         SSCSTACK PUSH,                 Get Stack area                 +\n               LEN=@C_Dynam_Length,      this long                     +\n               STACK=(R2)                using this stack\n\n         LR    R3,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LHI   R1,@C_Dynam_Length        Its length\n         LA    R14,0                    Clear source address\n         LA    R15,0                     and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R3                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*-------------------------------------------------------------------*\n         ST    R13,4(0,R1)              Chain\n         ST    R1,8(0,R13)               saveareas\n         LR    R13,R1                   Load dynam base\n         USING @C_Dynam,R13             Assign a base\n         L     R15,@C_Dynam+4           Get A(HSA)\n         LM    R0,R3,20(R15)            Restore callers registers\n\n         L     R15,4(0,R1)              A(31-bit Stack Pointer)\n         ST    R15,@C_31Bit_Stack_Ptr_Ptr Save it\n         L     R15,8(0,R1)              A(24-bit Stack Pointer)\n         ST    R15,@C_24Bit_Stack_Ptr_Ptr Save it\n\n*---------------------------------------------------------------------*\n*   Free any selection lists we may have ...                          *\n*---------------------------------------------------------------------*\n         ICM   R1,B'1111',@_UCB_List_Ptr A(List of UCB Masks)\n         JZ    C00020                   None, skip\n         L     R0,UCB_List_Hdr_Len-UCB_List_Hdr(R1) Length\n         BASR  R2,0\n         USING (*,C00010_End-1),R2\n         STORAGE RELEASE,               Free the storage               +\n               ADDR=(1),                 starting here                 +\n               LENGTH=(0)                for this long\nC00010_End DS  0H\n         DROP  R2\n         XC    @_UCB_List_Ptr,@_UCB_List_Ptr Clear A(UCB List)\n\nC00020   DS    0H\n         ICM   R1,B'1111',@_XUCB_List_Ptr A(List of XUCB Masks)\n         JZ    C00030                   None, skip\n         L     R0,UCB_List_Hdr_Len-UCB_List_Hdr(R1) Length\n         BASR  R2,0\n         USING (*,C00020_End-1),R2\n         STORAGE RELEASE,               Free the storage               +\n               ADDR=(1),                 starting here                 +\n               LENGTH=(0)                for this long\nC00020_End DS  0H\n         DROP  R2\n         XC    @_XUCB_List_Ptr,@_XUCB_List_Ptr Clear A(XUCB List)\n\nC00030   DS    0H\n         ICM   R1,B'1111',@_Vol_List_Ptr A(List of Vol Masks)\n         JZ    C00040                   None, skip\n         L     R0,Vol_List_Hdr_Len-Vol_List_Hdr(R1) Length\n         BASR  R2,0\n         USING (*,C00030_End-1),R2\n         STORAGE RELEASE,               Free the storage               +\n               ADDR=(1),                 starting here                 +\n               LENGTH=(0)                for this long\nC00030_End DS  0H\n         DROP  R2\n         XC    @_Vol_List_Ptr,@_Vol_List_Ptr Clear A(Vol List)\n\nC00040   DS    0H\n         ICM   R1,B'1111',@_XVol_List_Ptr A(List of XVol Masks)\n         JZ    C00050                   None, skip\n         L     R0,Vol_List_Hdr_Len-Vol_List_Hdr(R1) Length\n         BASR  R2,0\n         USING (*,C00040_End-1),R2\n         STORAGE RELEASE,               Free the storage               +\n               ADDR=(1),                 starting here                 +\n               LENGTH=(0)                for this long\nC00040_End DS  0H\n         DROP  R2\n         XC    @_XVOL_List_Ptr,@_XVOL_List_Ptr Clear A(XVol List)\n\nC00050   DS    0H\n         ICM   R1,B'1111',@_STORGRP_List_Ptr A(List of STORGRP Masks)\n         JZ    C00060                   None, skip\n         L     R0,STORGRP_List_Hdr_Len-STORGRP_List_Hdr(R1) Length\n         BASR  R2,0\n         USING (*,C00050_End-1),R2\n         STORAGE RELEASE,               Free the storage               +\n               ADDR=(1),                 starting here                 +\n               LENGTH=(0)                for this long\nC00050_End DS  0H\n         DROP  R2\n         XC    @_STORGRP_List_Ptr,@_STORGRP_List_Ptr Clear A(List)\n\nC00060   DS    0H\n*---------------------------------------------------------------------*\n*   ... and set all our selection criteria so that all volumes will   *\n*  be selected.                                                       *\n*---------------------------------------------------------------------*\n         MVI   @_UNITNM,C' '            Assume all\n         MVC   @_UNITNM+1(L'@_UNITNM-1),@_UNITNM Unitnames\n         NI    @_ATTRPvt,X'FF'-L'@_ATTRPvt Off Mnt Attr flag\n         NI    @_ATTRPub,X'FF'-L'@_ATTRPub Off Mnt Attr flag\n         NI    @_ATTRStg,X'FF'-L'@_ATTRStg Off Mnt Attr flag\n         NI    @_ATTRSMS,X'FF'-L'@_ATTRSMS Off Mnt Attr flag\n\n*---------------------------------------------------------------------*\n*   Set all our output-related flags to their default (off) state     *\n*---------------------------------------------------------------------*\n         NI    @_No_Headings,X'FF'-L'@_No_Headings Off flag\n         NI    @_No_Details,X'FF'-L'@_No_Details   Off flag\n         NI    @_No_Totals,X'FF'-L'@_No_Totals     Off flag\n         NI    @_Statistics,X'FF'-L'@_Statistics   Off flag\n         NI    @_ISPF_SPACE,X'FF'-L'@_ISPF_SPACE Off flag\n         NI    @_ISPF_EDIF,X'FF'-L'@_ISPF_EDIF     Off flag\n         NI    @_ISPF_BRIF,X'FF'-L'@_ISPF_BRIF     Off flag\n         NI    @_ISPF_Explicit,X'FF'-L'@_ISPF_Explicit Off flag\n         NI    @_No_LSPACE,X'FF'-L'@_No_LSPACE     Off flag\n\n*---------------------------------------------------------------------*\n*   Set MaxTasks to default                                           *\n*---------------------------------------------------------------------*\n         AIF   (&Default_SubTask_Count LT 1).Def_SubTask_Count_010\n         LHI   R15,&Default_SubTask_Count Default nbr subtasks\n         AGO   .Def_SubTask_Count_020\n.Def_SubTask_Count_010 ANOP\n         SLR   R15,R15                   Use dynamic subtask count\n.Def_SubTask_Count_020 ANOP\n         STH   R15,@_MaxTasks            Set it\n\n*---------------------------------------------------------------------*\n*   Clear out Sort field name, and default to Ascending sort          *\n*---------------------------------------------------------------------*\n         MVC   @_Sort_Field,=CL8' '\n         MVI   @_Sort_Direction,C'A'\n\n*---------------------------------------------------------------------*\n*   Reset our internal flags                                          *\n*---------------------------------------------------------------------*\n         NI    @C_UNIT_Flag,X'FF'-L'@C_UNIT_Flag\n         NI    @C_XUNIT_Flag,X'FF'-L'@C_XUNIT_Flag\n         NI    @C_VOL_Flag,X'FF'-L'@C_VOL_Flag\n         NI    @C_XVOL_Flag,X'FF'-L'@C_XVOL_Flag\n\n*---------------------------------------------------------------------*\n*   Reset OUTFILE and OUTDATA fields                                  *\n*---------------------------------------------------------------------*\n         MVC   @_OutFile_DDName,=CL8' '\n         NI    @_OutData_DISPLAY,X'FF'-L'@_OutData_DISPLAY\n         NI    @_OutData_CB,X'FF'-L'@_OutData_CB\n         NI    @_OutData_ALL,X'FF'-L'@_OutData_ALL\n\n*-------------------------------------------------------------------*\n*    Initialize @_MaxLWait to the maximum number of seconds to      *\n*   wait for each LSPACE; we determine whether or not we are a      *\n*   foreground user (TSO) to decide on the initialization value.    *\n*-------------------------------------------------------------------*\n         L     R15,PSAAOLD-PSA          A(Our ASCB)\n         ICM   R0,B'1111',ASCBTSB-ASCB(R15) Get A(TSB)\n         JZ    C00060C                  Not a foreground user, skip\n         LHI   R15,&Fore_LSPACE_Wait    Foreground WAIT time\n         J     C00060E                  and skip\nC00060C  DS    0H\n         LHI   R15,&Back_LSPACE_Wait    Background WAIT time\n         J     C00060E                  and skip\nC00060E  DS    0H\n         STH   R15,@_MaxLWait           Update MaxLWait\n\n*---------------------------------------------------------------------*\n*   Free the VolTbl, if it exists                                     *\n*---------------------------------------------------------------------*\n         NI    @_VolTbl_GETMAIN_Err,X'FF'-L'@_VolTbl_GETMAIN_Err\n\n         ICM   R1,B'1111',@_VolTbl_Ptr A(Info Table)\n         JZ    C00070                  None, skip\n         L     R0,VolTbl_Hdr_TbLen-VolTbl(R1) Get its length\n         BASR  R2,0\n         USING (*,C00060_End-1),R2\n         STORAGE RELEASE,               Free the table                 +\n               ADDR=(1),                 starting here                 +\n               LENGTH=(0)                for this long\nC00060_End DS  0H\n         DROP  R2\n         LA    R15,0                    Clear work register\n         ST    R15,@_VolTbl_Ptr         and clear VolTbl pointer\n\nC00070   DS    0H\n*--------------------------------------------------------------------*\n*   Initialize our standard parmlist                                 *\n*--------------------------------------------------------------------*\n         LA    R15,@_Dynam              A(Dynamic area)\n         ST    R15,@C_Parms_Std         Save it\n         L     R15,@C_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)\n         ST    R15,@C_Parms_Std+4       Save it\n         L     R15,@C_24Bit_Stack_Ptr_Ptr A(24-bit Stack Pointer)\n         ST    R15,@C_Parms_Std+8       Save it\n\n*---------------------------------------------------------------------*\n*      Check what kind of processing we have to do                    *\n*---------------------------------------------------------------------*\n         TM    @_TSO_Command,L'@_TSO_Command Is this a TSO command?\n         JNO   C00080                   No, skip\n         TM    @_TSO_Processed,L'@_TSO_Processed Yes, already done?\n         JO    C00780                   Yes, EOF\n         OI    @_TSO_Processed,L'@_TSO_Processed No, end next time\n         L     R1,@_CPPL_Ptr            Get A(CPPL)\n         J     C00160                   and skip\n\nC00080   DS    0H\n*---------------------------------------------------------------------*\n*   This is batch - go read a record from SYSIN, and build a          *\n*   pseudo command buffer that we can pass to IKJPARS                 *\n*---------------------------------------------------------------------*\n         LHI   R15,4095                 Key count to produce\n         STH   R15,@_Line_Count          Hdg0\n\n         ICM   R1,B'1111',@_SYSIN_DCB_Ptr A(SYSIN DCB)\n         JNZ   C00100                   Already here, skip\n\n*---------------------------------------------------------------------*\n*   SYSIN has not been OPENed - get some storage, and OPEN it         *\n*---------------------------------------------------------------------*\n         LHI   R0,C_SYSIN_DCB_Length+C00760_24_Length+7 DCB, 24-bit EOD\n         SRL   R0,3                     DBLWD\n         SLL   R0,3                      multiple\n\n         BASR  R2,0\n         USING (*,C00080_End-1),R2\n         STORAGE OBTAIN,                Get some storage               +\n               LENGTH=(0),               this long                     +\n               LOC=24                    below the line\nC00080_End DS  0H\n         DROP  R2\n\n         SLL   R1,8                     Clean the\n         SRL   R1,8                      address\n         ST    R1,@_SYSIN_DCB_Ptr       Save A(SYSIN DCB)\n\n         L     R3,@_SYSIN_DCB_Ptr       A(DCB)\n         MVC   0(C_SYSIN_DCB_Length,R3),C_SYSIN_DCB\n         MVC   @_SYSIN_DCBE,C_SYSIN_DCBE Move SYSIN DCBE\n         LA    R15,@_SYSIN_DCBE       Point to it\n         ST    R15,DCBDCBE-IHADCB(R3) Update address in DCB\n         MVC   @C_OPEN,C_OPEN           Move OPEN parms\n         OPEN  ((3),INPUT),MODE=31,MF=(E,@C_OPEN)\n\n         TM    @_SYSIN_DCBE+DCBEFLG1-DCBE,DCBEMD31 31-bit SAM OK?\n         JO    C00090                 Yes, skip\n\n*---------------------------------------------------------------------*\n*   31-bit SAM is not supported for SYSIN. This typically happens     *\n*  when it is allocated to the terminal in a TSO session (the I/O     *\n*  seems to be OK, but the EOD handling gets in trouble). So ...      *\n*---------------------------------------------------------------------*\n\n*---------------------------------------------------------------------*\n*  ... close the current DCB ...                                      *\n*---------------------------------------------------------------------*\n         MVC   @C_CLOSE,C_CLOSE       Move close parms\n         L     R3,@_SYSIN_DCB_Ptr     Point to the DCB\n         CLOSE ((3)),MODE=31,MF=(E,@C_CLOSE)  and close it\n\n*---------------------------------------------------------------------*\n*  ... move a normal DCB (without the DCBE) to the 24-bit area ...    *\n*---------------------------------------------------------------------*\n         MVC   0(C_SYSIN24_DCB_Length,R3),C_SYSIN24_DCB Move 24-bit DCB\n\n*---------------------------------------------------------------------*\n*  ... move the 24-bit EOD after it ...                               *\n*---------------------------------------------------------------------*\n         LA    R15,C_SYSIN24_DCB_Length(0,R3) Point past DCB\n         LARL  R14,C00760_24_Start        A(24-bit EOD Routine)\n         MVC   0(C00760_24_Length,R15),0(R14) Move 24-bit EOD\n\n*---------------------------------------------------------------------*\n*  ... and update DCBEODAD to point to the 24-bit EOD routine.        *\n*---------------------------------------------------------------------*\n         O     R15,DCBEODAD-IHADCB(R3)    Set up\n         ST    R15,DCBEODAD-IHADCB(R3)     EODAD\n\n*---------------------------------------------------------------------*\n*  Finally, re-OPEN SYSIN.                                            *\n*---------------------------------------------------------------------*\n         MVC   @C_OPEN,C_OPEN           Move OPEN parms\n         L     R3,@_SYSIN_DCB_Ptr       POINT TO THE DCB\n         OPEN  ((3),INPUT),MODE=31,MF=(E,@C_OPEN) AND OPEN IT\n\nC00090   DS    0H\n         L     R1,@_SYSIN_DCB_Ptr       Restore A(DCB)\n\nC00100   DS    0H\n*---------------------------------------------------------------------*\n*  Read SYSIN, if we can ...                                          *\n*---------------------------------------------------------------------*\n         TM    DCBOFLGS-IHADCB(R1),DCBOFOPN Is it open?\n         JNO   C00760                   No, EOF\n\n         GET   (1)                      Go get it\n\n         ST    R1,@C_SYSIN_Rec_Ptr      and save record address\n\n*---------------------------------------------------------------------*\n*  ... ignoring comments and blank lines ...                          *\n*---------------------------------------------------------------------*\n         L     R15,@C_SYSIN_Rec_Ptr     A(SYSIN record)\n         CLI   0(R15),C'*'              Comment?\n         JE    C00080                   Yes, ignore it\n         CLI   0(R15),C' '              No, blank record?\n         JNE   C00110\n         CLC   1(71,R15),0(R15)\n         JE    C00080                   Blank record, ignore it\n\nC00110   DS    0H\n*---------------------------------------------------------------------*\n*  ... and trim leading and trailing spaces.                          *\n*---------------------------------------------------------------------*\n         AHI   R15,71                   A(Last char)\nC00120   DS    0H\n         CLI   0(R15),C' '              Trailing blank?\n         JNE   C00130                   No, skip\n         BRCT  R15,C00120               Yes, check previous\n\nC00130   DS    0H\n         L     R14,@C_SYSIN_Rec_Ptr     A(Start of input)\n         SLR   R15,R14                  Length of record - 1\n         AHI   R15,1                    Actual length\n\nC00130C  DS    0H\n         CLI   0(R14),C' '              Leading space?\n         JNE   C00130E                  No, OK\n         AHI   R14,1                    Yup, point past it\n         BRCT  R15,C00130C              and check again\n         J     C00080                   Blank record(?), ignore it\n\nC00130E  DS    0H\n*---------------------------------------------------------------------*\n*   If the control card starts with our name (the name that a TSO     *\n*  user would use), skip over it.                                     *\n*---------------------------------------------------------------------*\n         LHI   R0,L'C_PgmName           Length of our name\n         CR    R15,R0                   Should we check for our name?\n         JL    C00150                   No, skip\n         CLC   C_PgmName,0(R14)         Yes, our name first?\n         JNE   C00150                   No, OK\n         CR    R15,R0                   Is that all there is?\n         JE    C00140                   Yes, skip\n         CLI   L'C_PgmName(R14),C' '    Yes, ending with a space?\n         JNE   C00150                   No, skip\n         LHI   R0,L'C_PgmName+1         Length of our name and a space\nC00140   DS    0H\n         AR    R14,R0                   Point past our name\n         SR    R15,R0                   and adjust length\nC00150   DS    0H\n         LA    R0,@C_CBUF_Data+L'C_PgmName+1 A(Target area)\n         LR    R1,R15                   Length\n         MVCL  R0,R14                   Move data to cmd buffer\n         LA    R15,@C_CBUF              A(Start of command buffer\n         SR    R0,R15                   Get the length\n         STH   R0,@C_CBUF_Len           Save it\n\n         MVC   @C_CBUF_Data(L'C_PgmName),C_PgmName  Simulate command\n         MVI   @C_CBUF_Data+L'C_PgmName,C' ' Separator\n         LHI   R15,L'C_PgmName+1         Offset to parms\n         STH   R15,@C_CBUF_Off          Update it\n\n         L     R1,@_Bat_CPPL_Ptr        A(Our CPPL)\n         LA    R15,@C_CBUF              A(our command buffer)\n         ST    R15,CPPLCBUF-CPPL(R1)    Update A(Command buffer)\n\nC00160   DS    0H\n*---------------------------------------------------------------------*\n*   Resolve any symbolic variables in the command buffer. Note that   *\n*   we do this before invoking IKJPARS because IKJPARS will get upset *\n*   with substring'ed symbolic variables (which it thinks are lists). *\n*---------------------------------------------------------------------*\n         L     R15,CPPLCBUF-CPPL(R1)    A(Command Buffer)\n         LH    R14,@C_CBUF_Len-@C_CBUF(R15) Get length\n         AR    R14,R15                  Point past end\n         AHI   R15,L'@C_CBUF_Len+L'@C_CBUF_Off Point to start of cmd\n         LA    R0,C'&&'                 Char to search for\nC00160E  DS    0H\n         SRST  R14,R15                  Do we have an amper?\n         JH    C00160Z                  No amper, skip\n         JO    C00160E                  Keep checking\n\n         ST    R1,@C_CPPL_Ptr           Save A(CPPL)\n\n         XC    @C_SYMBP,@C_SYMBP        Clear ASASUMBP area\n         L     R15,CPPLCBUF-CPPL(R1)    A(Command buffer)\n         LH    R14,@C_CBUF_Len-@C_CBUF(R15) Get Cmd buff length\n         AHI   R14,-L'@C_CBUF_Len-L'@C_CBUF_Off minus CBUF fields\n         ST    R14,@C_SYMBP+SYMBPPATTERNLENGTH-SYMBP Save length\n         AHI   R15,L'@C_CBUF_Len+L'@C_CBUF_Off Point to start\n         ST    R15,@C_SYMBP+SYMBPPATTERN@-SYMBP Save A(Command Buff)\n         LA    R15,@C_CBUF1_Data        A(Target Area)\n         ST    R15,@C_SYMBP+SYMBPTARGET@-SYMBP Save A(Target)\n         LA    R15,L'@C_CBUF1_Data      Target Length)\n         ST    R15,@C_SYMBP_Target_Len  Initialize it\n         LA    R15,@C_SYMBP_Target_Len  A(Target Len field)\n         ST    R15,@C_SYMBP+SYMBPTARGETLENGTH@-SYMBP Save A(Length)\n         LA    R15,@C_SYMBP_RC          A(Return code area)\n         ST    R15,@C_SYMBP+SYMBPRETURNCODE@-SYMBP Save A(Return code)\n\n         MVC   @C_LINKX,C_LINKX         Move LINKX Macro\n         LARL  R2,C00160Z               LINK error return address\n         LINKX EP=ASASYMBM,             LINK to ASASYMBM               +\n               ERRET=(2),                go here if LINK error         +\n               MF=(E,@C_SYMBP),          using these parms             +\n               SF=(E,@C_LINKX)           staying re-entrant\n\n         L     R1,@C_CPPL_Ptr           Restore A(CPPL)\n         ICM   R15,B'1111',@C_SYMBP_RC  Get return code\n         JNZ   C00160Z                  Use original Cmd Buffer\n         L     R15,@C_SYMBP_Target_Len  Get new length\n         AHI   R15,L'@C_CBUF_Len+L'@C_CBUF_Off Adjust it\n         STH   R15,@C_CBUF1_Len         Update new cmd buff len\n         L     R15,CPPLCBUF-CPPL(R1)    A(original CBUF)\n         LH    R15,@C_CBUF_Off-@C_CBUF(R15) Original offset\n         STH   R15,@C_CBUF1_Off         Update it\n         LA    R15,@C_CBUF1             Point to our new CBUF\n         ST    R15,CPPLCBUF-CPPL(R1)    and update CPPL\n\nC00160Z  DS    0H\n*---------------------------------------------------------------------*\n*   Invoke IKJPARS to parse our Command Buffer (either the real one   *\n*   or the one we built). Note that if we not running as a TSO        *\n*   command, we turn off prompting during IKJPARS (otherwise, a user  *\n*   at a TSO terminal who CALLed us could get prompted for unknown    *\n*   parms, which is inconsistent).                                    *\n*---------------------------------------------------------------------*\n         MVC   @C_PPL+PPLUPT-PPL(L'PPLUPT),CPPLUPT-CPPL(R1)\n         MVC   @C_PPL+PPLECT-PPL(L'PPLECT),CPPLECT-CPPL(R1)\n         LA    R15,@C_PECB              A(Parse ECB)\n         ST    R15,@C_PPL+PPLECB-PPL    Save it\n         LA    R15,@C_PANS              A(Parse Answer area)\n         ST    R15,@C_PPL+PPLANS-PPL    Save it\n         MVC   @C_PPL+PPLCBUF-PPL(L'PPLCBUF),CPPLCBUF-CPPL(R1)\n         L     R15,=AL4(C_PCL)          A(Parse Control List)\n         ST    R15,@C_PPL+PPLPCL-PPL    Save it\n         LA    R15,0                    Clear work register\n         ST    R15,@C_PPL+PPLUWA-PPL    No User Work Area\n         ST    R15,@C_PECB              Clear ECB\n         ST    R15,@C_PANS               and Answer area\n\n         TM    @_TSO_Command,L'@_TSO_Command Is this a TSO command?\n         JO    C00170                   Yes, skip\n         L     R15,@C_PPL+PPLUPT-PPL    Get A(UPT)\n         MVC   @C_UPTSWS,UPTSWS-UPT(R15) Save current SWS\n         NI    UPTSWS-UPT(R15),X'FF'-UPTNPRM Off Prompt flag\n\nC00170   DS    0H\n         LA    R1,@C_PPL                A(PPL)\n         CALLTSSR EP=IKJPARS            Parse the command line\n\n         TM    @_TSO_Command,L'@_TSO_Command Is this a TSO command?\n         JO    C00180                   Yes, skip\n         L     R14,@C_PPL+PPLUPT-PPL    Get A(UPT)\n         OC    UPTSWS-UPT(L'UPTSWS,R14),@C_UPTSWS Restore UPTSWS\nC00180   DS    0H\n         LTR   R15,R15                  Did PARSE work?\n         JNZ   C00730                   No, skip\n         L     R1,@C_PANS               Yes, get A(PDL)\n\n*---------------------------------------------------------------------*\n*   Process UNIT/XUNIT keyword                                        *\n*---------------------------------------------------------------------*\n         TM    @C_UNIT_Flag,L'@C_UNIT_Flag Have we processed UNIT?\n         JO    C00180E                  Yes, skip\n         OI    @C_UNIT_Flag,L'@C_UNIT_Flag No, we have now\n\n         TM    C_01SFP+6-IKJPARMD(R1),X'80' Was UNIT entered?\n         JZ    C00180E                  No, skip\n         AHI   R1,C_01SFP-IKJPARMD      Yes, point to PDE\n         J     C00180I                  start processing\nC00180E  DS    0H\n         TM    @C_XUNIT_Flag,L'@C_XUNIT_Flag Have we processed XUNIT?\n         JO    C00240                   Yes, skip\n         OI    @C_XUNIT_Flag,L'@C_XUNIT_Flag No, we have now\n\n         TM    C_02SFP+6-IKJPARMD(R1),X'80' Was XUNIT entered?\n         JZ    C00240                   No, skip\n         AHI   R1,C_02SFP-IKJPARMD      Yes, point to PDE\nC00180I  DS    0H\n         LA    R0,0                     Clear unit count\nC00190   DS    0H\n         AHI   R0,1                     Bump unit count\n         ICM   R1,B'0111',9(R1)         A(Next PDE)\n         JNZ   C00190                   Found one, keep checking\n\n         LR    R4,R0                    Save count\n         MHI   R0,UCB_List_Ent_Length   Times len of 1 entry\n         AHI   R0,UCB_List_Hdr_Length     + length of header\n         BASR  R2,0\n         USING (*,C00190_End-1),R2\n         STORAGE OBTAIN,                Go get some storage            +\n               LENGTH=(0),               this long,                    +\n               LOC=31                    above-the-line\nC00190_End DS  0H\n         DROP  R2\n         ST    R0,UCB_List_Hdr_Len-UCB_List(R1) Save Subpool, length\n         ST    R4,UCB_List_Hdr_Count-UCB_List(R1) Save nbr entries\n         LA    R4,UCB_List_Ent-UCB_List(R1) A(1st entry)\n         TM    @C_XUNIT_Flag,L'@C_XUNIT_Flag Is this XUNIT?\n         JO    C00190E                  Yes, skip\n         ST    R1,@_UCB_List_Ptr        Save it\n         L     R1,@C_PANS               Restore A(PDL)\n         LA    R3,C_01SFP-IKJPARMD(R1)  Point to 1st UNIT PDE\n         J     C00200                   and skip\nC00190E  DS    0H\n         ST    R1,@_XUCB_List_Ptr       Save it\n         L     R1,@C_PANS               Restore A(PDL)\n         LA    R3,C_02SFP-IKJPARMD(R1) Point to 1st XUNIT PDE\n         J     C00200                   and skip\nC00200   DS    0H\n         MVC   UCB_List_Ent_UCB-UCB_List_Ent(L'UCB_List_Ent_UCB,R4),=(L+\n               'UCB_List_Ent_UCB)C'*'   Initialize field\n         L     R15,0(0,R3)              A(UNIT field)\n         LH    R14,4(0,R3)              Get its length\n         STC   R14,UCB_List_Ent_UCB_Len-UCB_List_Ent(R4) Save it\n         AHI   R4,UCB_List_Ent_UCB-UCB_List_Ent  Point to UCB Area\n         AHI   R14,-1                   Get EX length\n         EX    R14,C2EX1                Move UCB\n         AHI   R4,-(UCB_List_Ent_UCB-UCB_List_Ent) Back to entry\n         MVC   UCB_List_Ent_Mask-UCB_List_Ent(L'UCB_List_Ent_Mask,R4),U+\n               CB_List_Ent_UCB-UCB_List_Ent(R4)\n         TR    UCB_List_Ent_UCB-UCB_List_Ent(L'UCB_List_Ent_UCB,R4),C_T+\n               rTbl                     Xlate (Wildcards = X'FF'\n         TR    UCB_List_Ent_Mask-UCB_List_Ent(L'UCB_List_Ent_Mask,R4),C+\n               _TrTbl1                  Xlate (Wildcards = X'FF')\n*                                              Non-Wildcards = X'00')\n         AHI   R4,UCB_List_Ent_Length   A(Next entry)\n         ICM   R3,B'0111',9(R3)         A(Next PDE)\n         JNZ   C00200                   Got one, save it\n         J     C00180E                  Process next UNIT-type keywd\n\nC00240   DS    0H\n*---------------------------------------------------------------------*\n*   Process VOLUME/XVOLUME keyword                                    *\n*---------------------------------------------------------------------*\n         TM    @C_VOL_Flag,L'@C_VOL_Flag Have we processed VOL?\n         JO    C00240E                  Yes, skip\n         OI    @C_VOL_Flag,L'@C_Vol_Flag No, we have now\n\n         TM    C_03SFP+6-IKJPARMD(R1),X'80' Was VOL entered?\n         JZ    C00240E                  No, skip\n         AHI   R1,C_03SFP-IKJPARMD      Yes, point to PDE\n         J     C00240I                  start processing\nC00240E  DS    0H\n         TM    @C_XVOL_Flag,L'@C_XVOL_Flag Have we processed XVOL?\n         JO    C00300                   Yes, skip\n         OI    @C_XVOL_Flag,L'@C_XVol_Flag No, we have now\n\n         TM    C_04SFP+6-IKJPARMD(R1),X'80' Was XVOL entered?\n         JZ    C00300                   No, skip\n         AHI   R1,C_04SFP-IKJPARMD      Yes, point to PDE\nC00240I  DS    0H\n         LA    R0,0                     Clear unit count\nC00250   DS    0H\n         AHI   R0,1                     Bump vol count\n         ICM   R1,B'0111',9(R1)         A(Next PDE)\n         JNZ   C00250                   Found one, keep checking\n\n         LR    R4,R0                    Save count\n         MHI   R0,Vol_List_Ent_Length   Times length of 1 entry\n         AHI   R0,Vol_List_Hdr_Length     + length of header\n         BASR  R2,0\n         USING (*,C00250_End-1),R2\n         STORAGE OBTAIN,                Go get some storage            +\n               LENGTH=(0),               this long,                    +\n               LOC=31                    above-the-line\nC00250_End DS  0H\n         DROP  R2\n         ST    R0,Vol_List_Hdr_Len-Vol_List(R1) Save Subpool, length\n         ST    R4,Vol_List_Hdr_Count-Vol_List(R1) Save nbr entries\n         LA    R4,Vol_List_Ent-Vol_List(R1) A(1st entry)\n         TM    @C_XVOL_Flag,L'@C_XVOL_Flag Are we doing XVOL?\n         JO    C00250E                  Yes, skip\n         ST    R1,@_VOL_List_Ptr        Save it\n         L     R1,@C_PANS               Restore A(PDL)\n         LA    R3,C_03SFP-IKJPARMD(R1)  Point to 1st VOL PDE\n         J     C00260                   and skip\nC00250E  DS    0H\n         ST    R1,@_XVOL_List_Ptr       Save it\n         L     R1,@C_PANS               Restore A(PDL)\n         LA    R3,C_04SFP-IKJPARMD(R1)  Point to 1st XVOL PDE\n         J     C00260                   and skip\nC00260   DS    0H\n         MVC   Vol_List_Ent_Vol-Vol_List_Ent(L'Vol_List_Ent_Vol,R4),=(L+\n               'Vol_List_Ent_Vol)C'*'   Initialize field\n         L     R15,0(0,R3)              A(Vol field)\n         LH    R14,4(0,R3)              Get its length\n         AHI   R14,-1                   Get EX length\n         EX    R14,C2EX1                Move Vol\n         MVC   Vol_List_Ent_Mask-Vol_List_Ent(L'Vol_List_Ent_Mask,R4),V+\n               ol_List_Ent_Vol-Vol_List_Ent(R4)\n         TR    Vol_List_Ent_Vol-Vol_List_Ent(L'Vol_List_Ent_Vol,R4),C_T+\n               rTbl                     Xlate (Wildcards = X'FF'\n         TR    Vol_List_Ent_Mask-Vol_List_Ent(L'Vol_List_Ent_Mask,R4),C+\n               _TrTbl1                  Xlate (Wildcards = X'FF')\n*                                              Non-Wildcards = X'00')\n         AHI   R4,Vol_List_Ent_Length   A(Next entry)\n         ICM   R3,B'0111',9(R3)         A(Next PDE)\n         JNZ   C00260                   Got one, save it\n         J     C00240                   Process next VOL-type keyword\n\nC00300   DS    0H\n*---------------------------------------------------------------------*\n*   Process NAME keyword                                              *\n*---------------------------------------------------------------------*\n         TM    C_05SFP+6-IKJPARMD(R1),X'80' Was Name entered?\n         JZ    C00310                   No, skip\n         L     R15,C_05SFP-IKJPARMD(R1)  Yes, point to it\n         LH    R14,C_05SFP+4-IKJPARMD(R1) Get its length\n         AHI   R14,-1                   Get EX length\n         EX    R14,C2EX3                Move Unitname\n\nC00310   DS    0H\n*---------------------------------------------------------------------*\n*   Process ATTRIBUTE keyword                                         *\n*---------------------------------------------------------------------*\n         LH    R15,C_06SFP-IKJPARMD(R1) Get Kwd nbr for ATTR\n         LTR   R15,R15                  Anything?\n         JZ    C00380                   None, skip\n         L     R14,=AL4(C_PCL)          Yes, A(Parse Control List)\n         AH    R14,C_06SF-C_PCL(R14)    A(IKJSUBF entry)\n         AH    R14,2(0,R14)             A(1st IKJNAME entry)\nC00320   DS    0H\n         TM    0(R14),X'60'             Is this an IKJNAME PCE?\n         JNO   C00380                   No, must have reached the end\n         CHI   R15,1                    Is this our entry?\n         JE    C00330                   Yes, check it out\n         AH    R14,2(0,R14)             No, bump to next PCE\n         BRCT  R15,C00320               and check it out\n         J     C00380                   Unknown, ignore it\nC00330   DS    0H\n         CLC   =C'STORAGE',5(R14)       STG?\n         JE    C00340                   Yes, skip\n         CLC   =C'PRIVATE',5(R14)       No, PRIVATE?\n         JE    C00350                   Yes, skip\n         CLC   =C'PUBLIC',5(R14)        No, PUBLIC?\n         JE    C00360                   Yes, skip\n         CLC   =C'SMS',5(R14)           No, SMS?\n         JE    C00370                   Yes, skip\n         J     C00380                   Unknown, ignore it\nC00340   DS    0H\n         OI    @_ATTRStg,L'@_ATTRStg    Set flag\n         J     C00380\nC00350   DS    0H\n         OI    @_ATTRPvt,L'@_ATTRPvt    Set flag\n         J     C00380\nC00360   DS    0H\n         OI    @_ATTRPub,L'@_ATTRPub    Set flag\n         J     C00380\nC00370   DS    0H\n         OI    @_ATTRSMS,L'@_ATTRSMS    Set flag\n         J     C00380\n\nC00380   DS    0H\n*---------------------------------------------------------------------*\n*   Process STORGRP keyword                                           *\n*---------------------------------------------------------------------*\n         TM    C_07SFP+6-IKJPARMD(R1),X'80' Was STORGRP entered?\n         JZ    C00430                   No, skip\n         LA    R0,0                     Yes, clear STORGRP count\n         AHI   R1,C_07SFP-IKJPARMD      and point to PDE\nC00390   DS    0H\n         AHI   R0,1                     Bump STORGRP count\n         ICM   R1,B'0111',9(R1)         A(Next PDE)\n         JNZ   C00390                   Found one, keep checking\n\n         LR    R4,R0                    Save count\n         MHI   R0,STORGRP_List_Ent_Length Times length of 1 entry\n         AHI   R0,STORGRP_List_Hdr_Length  + length of header\n         BASR  R2,0\n         USING (*,C00390_End-1),R2\n         STORAGE OBTAIN,                Go get some storage            +\n               LENGTH=(0),               this long,                    +\n               LOC=31                    above-the-line\nC00390_End DS  0H\n         DROP  R2\n         ST    R1,@_STORGRP_List_Ptr    Save it\n         ST    R0,STORGRP_List_Hdr_Len-STORGRP_List(R1) Save Subp, len\n         ST    R4,STORGRP_List_Hdr_Count-STORGRP_List(R1) Save nbr ents\n         LA    R4,STORGRP_List_Ent-STORGRP_List(R1) A(1st entry)\n         L     R1,@C_PANS               Restore A(PDL)\n         LA    R3,C_07SFP-IKJPARMD(R1) and point to 1st STORGRP PDE\nC00400   DS    0H\n         L     R15,0(0,R3)              A(StorGrp)\n         AH    R15,4(0,R3)              A(Byte past end)\n         AHI   R15,-1                   Point to last byte\n         CLI   0(R15),C'*'              Trailing asterisk?\n         JNE   C00410                   No, skip\n         MVI   STORGRP_List_Ent_STORGRP-STORGRP_List_Ent(R4),C'*'\n         J     C00420\nC00410   DS    0H\n         MVI   STORGRP_List_Ent_STORGRP-STORGRP_List_Ent(R4),X'00'\n         J     C00420\nC00420   DS    0H\n         MVC   STORGRP_List_Ent_STORGRP+1-STORGRP_List_Ent(L'STORGRP_Li+\n               st_Ent_STORGRP-1,R4),STORGRP_List_Ent_STORGRP-STORGRP_Li+\n               st_Ent(R4)\n         L     R15,0(0,R3)              A(StorGrp)\n         LH    R14,4(0,R3)              Get its length\n         AHI   R14,-1                   Get EX length\n         EX    R14,C2EX1                Move StorGrp\n         MVC   STORGRP_List_Ent_Mask-STORGRP_List_Ent(L'STORGRP_List_En+\n               t_Mask,R4),STORGRP_List_Ent_STORGRP-STORGRP_List_Ent(R4)\n         TR    STORGRP_List_Ent_STORGRP-STORGRP_List_Ent(L'STORGRP_List+\n               _Ent_STORGRP,R4),C_TrTbl Xlate Wildcards = X'FF'\n         TR    STORGRP_List_Ent_Mask-STORGRP_List_Ent(L'STORGRP_List_En+\n               t_Mask,R4),C_TrTbl1      Xlate (Wildcards = X'FF'\n*                                              Non-Wildcards = X'00')\n         AHI   R4,STORGRP_List_Ent_Length A(Next entry)\n         ICM   R3,B'0111',9(R3)         A(Next PDE)\n         JNZ   C00400                   Got one, save it\n\nC00430   DS    0H\n*---------------------------------------------------------------------*\n*   Process SORT keyword                                              *\n*---------------------------------------------------------------------*\n         LH    R15,C_09SFP-IKJPARMD(R1) Get Kwd nbr for Sort Field\n         LTR   R15,R15                  Anything?\n         JZ    C00480                   None, skip\n         L     R14,=AL4(C_PCL)          Yes, A(Parse Control List)\n         AH    R14,C_09SF-C_PCL(R14)    A(IKJSUBF entry)\n         AH    R14,2(0,R14)             A(1st IKJNAME entry)\nC00440   DS    0H\n         TM    0(R14),X'60'             Is this an IKJNAME PCE?\n         JNO   C00480                   No, must have reached the end\n         CHI   R15,1                    Is this our entry?\n         JE    C00450                   Yes, check it out\n         AH    R14,2(0,R14)             No, bump to next PCE\n         BRCT  R15,C00440               and check it out\n         J     C00480                   Unknown, ignore it\nC00450   DS    0H\n         IC    R15,4(0,R14)             Get EX length of Keyword\n         EX    R15,C_Save_Sort_Field    Save sort field name\n\n*---------------------------------------------------------------------*\n*   Process DESCENDING keyword                                        *\n*---------------------------------------------------------------------*\n         CLI   C_10K+1-IKJPARMD(R1),2 DESCENDING entered?\n         JNE   C00480                   No, skip\n         MVI   @_Sort_Direction,C'D'    Yes, say so\n\nC00480   DS    0H\n*---------------------------------------------------------------------*\n*   Process MAXTASKS keyword                                          *\n*---------------------------------------------------------------------*\n         TM    C_11SFP+6-IKJPARMD(R1),X'80' Was Maxtasks entered?\n         JZ    C00490                   No, skip\n         L     R15,C_11SFP-IKJPARMD(R1) Yes, point to it\n         L     R15,0(0,R15)             Get the value\n         AIF   (&Max_SubTask_Count LT 1).Max_SubTask_Count_010\n         CHI   R15,&Max_SubTask_Count   Is it > max?\n         JNH   C00480C                  No, OK\n         LHI   R15,&Max_SubTask_Count   Yes, use max\nC00480C  DS    0H\n.Max_SubTask_Count_010 ANOP\n         LTR   R15,R15                  Is it too small?\n         JNP   C00490                   Yes, ignore it\n         STH   R15,@_MaxTasks           Save it\n\nC00490   DS    0H\n*---------------------------------------------------------------------*\n*   Process OUTFILE keyword                                           *\n*---------------------------------------------------------------------*\n         TM    C_20SFP+6-IKJPARMD(R1),X'80' Was OUTFILE entered?\n         JZ    C00550                   No, skip\n         L     R15,C_20SFP-IKJPARMD(R1) Yes, point to it\n         LH    R14,C_20SFP+4-IKJPARMD(R1) Get its length\n         AHI   R14,-1                   Get EX length\n         EX    R14,C2EX4                Move DDName\n\n*---------------------------------------------------------------------*\n*   Process OUTDATA keyword                                           *\n*---------------------------------------------------------------------*\n         LH    R15,C_21SFP-IKJPARMD(R1) Get Kwd nbr for OUTDATA\n         LTR   R15,R15                  Anything?\n         JZ    C00550                   None, skip\n         L     R14,=AL4(C_PCL)          Yes, A(Parse Control List)\n         AH    R14,C_21SF-C_PCL(R14)    A(IKJSUBF entry)\n         AH    R14,2(0,R14)             A(1st IKJNAME entry)\nC00500   DS    0H\n         TM    0(R14),X'60'             Is this an IKJNAME PCE?\n         JNO   C00550                   No, must have reached the end\n         CHI   R15,1                    Is this our entry?\n         JE    C00510                   Yes, check it out\n         AH    R14,2(0,R14)             No, bump to next PCE\n         BRCT  R15,C00500               and check it out\n         J     C00550                   Unknown, ignore it\nC00510   DS    0H\n         CLC   =C'DISPLAY',5(R14)       DISPLAY?\n         JE    C00520                   Yes, skip\n         CLC   =C'CB',5(R14)            No, CB?\n         JE    C00530                   Yes, skip\n         CLC   =C'ALL',5(R14)           No, ALL?\n         JE    C00540                   Yes, skip\n         J     C00550                   Unknown, ignore it\nC00520   DS    0H\n         OI    @_OutData_DISPLAY,L'@_OutData_DISPLAY   Set flag\n         J     C00550\nC00530   DS    0H\n         OI    @_OutData_CB,L'@_OutData_CB   Set flag\n         J     C00550\nC00540   DS    0H\n         OI    @_OutData_ALL,L'@_OutData_ALL   Set flag\n         J     C00550\n\nC00550   DS    0H\n*---------------------------------------------------------------------*\n*   Process NOHEADINGS keyword                                        *\n*---------------------------------------------------------------------*\n         CLI   C_13K+1-IKJPARMD(R1),0   Was NOHEADINGS entered?\n         JE    C00560                   No, skip\n         OI    @_No_Headings,L'@_No_Headings Yes, set flag\n\nC00560   DS    0H\n*---------------------------------------------------------------------*\n*   Process NODETAILS keyword                                         *\n*---------------------------------------------------------------------*\n         CLI   C_14K+1-IKJPARMD(R1),0   Was NODETAILS entered?\n         JE    C00570                   No, skip\n         OI    @_No_Details,L'@_No_Details Yes, set our flag\n\nC00570   DS    0H\n*---------------------------------------------------------------------*\n*   Process NOTOTALS keyword                                          *\n*---------------------------------------------------------------------*\n         CLI   C_15K+1-IKJPARMD(R1),0   Was NOTOTALS entered?\n         JE    C00580                   No, skip\n         OI    @_No_Totals,L'@_No_Totals Yes, set our flag\n\nC00580   DS    0H\n*---------------------------------------------------------------------*\n*   Process STATISTICS keyword                                        *\n*---------------------------------------------------------------------*\n         CLI   C_17K+1-IKJPARMD(R1),0     Was STATISTICS entered?\n         JE    C00590                   No, skip\n         OI    @_Statistics,L'@_Statistics Yes, set our flag\n\nC00590   DS    0H\n*---------------------------------------------------------------------*\n*   Process ISPF keyword                                              *\n*---------------------------------------------------------------------*\n         LH    R15,C_12SFP-IKJPARMD(R1) Get Kwd nbr for ISPF\n         LTR   R15,R15                  Anything?\n         JZ    C00650                   No, skip\n         OI    @_ISPF_Explicit,L'@_ISPF_Explicit Yes, set our flag\n         L     R14,=AL4(C_PCL)          A(Parse Control List)\n         AH    R14,C_12SF-C_PCL(R14)    A(IKJSUBF entry)\n         AH    R14,2(0,R14)             A(1st IKJNAME entry)\nC00600   DS    0H\n         TM    0(R14),X'60'             Is this an IKJNAME PCE?\n         JNO   C00650                   No, must have reached the end\n         CHI   R15,1                    Is this our entry?\n         JE    C00610                   Yes, check it out\n         AH    R14,2(0,R14)             No, bump to next PCE\n         BRCT  R15,C00600               and check it out\n         J     C00650                   Unknown, ignore it\nC00610   DS    0H\n         CLC   =C'EDIF',5(R14)          No, EDIF?\n         JE    C00630                   Yes, skip\n         CLC   =C'BRIF',5(R14)          No, BRIF?\n         JE    C00640                   Yes, skip\n         CLC   =C'SPACE',5(R14)         Table display?\n         JE    C00620                   Yes, skip\n         CLC   =C'NONE',5(R14)          No ISPF?\n         JNE   C00650                   No, ignore it\n         J     C00650                   Unknown, ignore it\nC00620   DS    0H\n         OI    @_ISPF_SPACE,L'@_ISPF_SPACE Yes, set our flag\n         J     C00650\nC00630   DS    0H\n         OI    @_ISPF_EDIF,L'@_ISPF_EDIF EDIF output\n         J     C00650\nC00640   DS    0H\n         OI    @_ISPF_BRIF,L'@_ISPF_BRIF BRIF output\n         J     C00650\n\nC00650   DS    0H\n*---------------------------------------------------------------------*\n*   Check the NOECHO keyword                                          *\n*---------------------------------------------------------------------*\n         CLI   C_16K+1-IKJPARMD(R1),0   Was NOECHO entered?\n         JE    C00660                   No, skip\n         OI    @C_NoEcho,L'@C_NoEcho    Yes, set our flag\n\nC00660   DS    0H\n*---------------------------------------------------------------------*\n*   Process NOLSPACE keyword                                          *\n*---------------------------------------------------------------------*\n         CLI   C_18K+1-IKJPARMD(R1),0   Was NOLSPACE entered?\n         JE    C00665                   No, skip\n         OI    @_No_LSPACE,L'@_No_LSPACE Yes, set flag\n\nC00665   DS    0H\n*---------------------------------------------------------------------*\n*   Process LINESIZE Keyword                                          *\n*---------------------------------------------------------------------*\n         TM    C_22SFP+6-IKJPARMD(R1),X'80' Was LINESIZE entered?\n         JZ    C00665I                  No, skip\n         L     R15,C_22SFP-IKJPARMD(R1) Yes, point to it\n         LH    R14,C_22SFP+4-IKJPARMD(R1) Get its length\n         CHI   R14,3                    Could it be max?\n         JNE   C00665E                  No, skip\n         CLC   =C'MAX',0(R15)           Yes, is it?\n         JNE   C00665E                  No, skip\n         LHI   R0,-1                    Yes, flag it\n         J     C00665G                  and skip\nC00665E  DS    0H\n         CLI   0(R15),C'0'              Numeric?\n         JL    C00665I                  No, ignore it\n         CLI   0(R15),C'9'              Maybe, check again\n         JH    C00665I                  Not numeric, ignore it\n         AHI   R15,1                    Bump pointer\n         BRCT  R14,C00665E              and continue\n\n         L     R15,C_22SFP-IKJPARMD(R1) Point to number\n         LH    R14,C_22SFP+4-IKJPARMD(R1) Get its length\n         AHI   R14,-1                   Get EX length\n         EX    R14,C2EX5                Pack line length\n         CVB   R0,@C_DBLWD              Binarize it\nC00665G  DS    0H\n         STH   R0,@_LineSize            Save it\nC00665I  DS    0H\n\nC00667   DS    0H\n*---------------------------------------------------------------------*\n*   Process MAXLWAIT Keyword                                          *\n*---------------------------------------------------------------------*\n         TM    C_23SFP+6-IKJPARMD(R1),X'80' Was MAXLWAIT entered?\n         JZ    C00667I                  No, skip\n         L     R15,C_23SFP-IKJPARMD(R1) Yes, point to it\n         LH    R14,C_23SFP+4-IKJPARMD(R1) Get its length\n         AHI   R14,-1                   Get EX length\n         EX    R14,C2EX5                Pack line length\n         CVB   R0,@C_DBLWD              Binarize it\n         STH   R0,@_MaxLWait            Save it\nC00667I  DS    0H\n\nC00670   DS    0H\n*---------------------------------------------------------------------*\n*   We have finished with the command buffer, so free up the          *\n*  storage used by IKJPARS                                            *\n*---------------------------------------------------------------------*\n         IKJRLSA @C_PANS                Free IKJPARS storage\n\n         AIF   (NOT &ISPF_by_Default).ISPF_by_Default_010\n*---------------------------------------------------------------------*\n*   We want ISPF displays by default; if the ISPF keyword was         *\n*  not specified, set up our flags as if it were.                     *\n*---------------------------------------------------------------------*\n         TM    @_ISPF_Explicit,L'@_ISPF_Explicit ISPF Keyword there?\n         JO    C00700                   Yes, don't do anything\n\n         AIF   ('&ISPF_Default_Type' EQ '').ISPF_Default_Type_005\n         CLC   =C'SPACE',=C'&ISPF_Default_Type' Default of SPACE?\n         JNE   C00680                   No, skip\n         OI    @_ISPF_SPACE,L'@_ISPF_SPACE Yes, set our flag\n         J     C00700                   and skip\nC00680   DS    0H\n         CLC   =C'EDIF',=C'&ISPF_Default_Type' Default of EDIF?\n         JNE   C00690                   No, skip\n         OI    @_ISPF_EDIF,L'@_ISPF_EDIF Yes, set our flag\n         J     C00700                   and skip\nC00690   DS    0H\n         CLC   =C'BRIF',=C'&ISPF_Default_Type' Default of BRIF?\n         JNE   C00700                   No, unknown\n         OI    @_ISPF_BRIF,L'@_ISPF_BRIF Yes, set our flag\n         J     C00700                   and skip\n.ISPF_Default_Type_005 ANOP\n\nC00700   DS    0H\n.ISPF_by_Default_010 ANOP\n*---------------------------------------------------------------------*\n*   If we are producing headings, put them in the table               *\n*---------------------------------------------------------------------*\n         TM    @_No_Headings,L'@_No_Headings Do we want headings?\n         JO    C00710                   No, skip\n\n         LA    R1,@C_Parms              A(Parm list)\n         BRAS  R14,W00010               Get A(Free entry in VolTbl)\n         LTR   R15,R15                  Did it work?\n         JNZ   C00710                   No, skip headings\n\n         LR    R9,R1                    Get A(Free entry)\n         USING VolTbl_Ent,R9\n\n         OI    VolTbl_Ent_Heading_Line1,L'VolTbl_Ent_Heading_Line1\n         LA    R14,C_Hdg0               A(Heading line)\n         LHI   R15,C_Hdg0_Len           Length of heading\n         O     R15,=XL4'40000000'       Pad char of blank\n         LA    R0,VolTbl_Ent_Display    A(Target)\n         LHI   R1,VolTbl_Ent_Display_Len Length of target\n         MVCL  R0,R14                   Move heading\n         OI    VolTbl_Ent_Processed,L'VolTbl_Ent_Processed Mark as done\n         OI    VolTbl_Ent_ECB,X'40'     POST as complete\n\n         MVC   @C_Time,C_Time           Move L-Form of macro\n         TIME  DEC,                     Get time                       +\n               @C_TIMEArea,              and return it here            +\n               LINKAGE=SYSTEM,           don't use the SVC             +\n               DATETYPE=YYYYMMDD,        format of returned data       +\n               MF=(E,@C_TIME)            addr of macro list\n         L     R0,@C_TIMEArea           Get the time\n         SRL   R0,4                     Shift out hundredths\n         ST    R0,@C_TimeArea           Save it\n         OI    @C_TimeArea+3,X'0F'      OR in a sign\n         MVC   VolTbl_Ent_Display+11(10),=X'402120207A20207A2020'\n         ED    VolTbl_Ent_Display+11(10),@C_TimeArea Edit time\n         L     R15,@C_TimeArea+8        Get Date (yyyymmdd)\n         LA    R14,0                    Clear work register\n         SLDL  R14,4                    Make room for sign\n         STM   R14,R15,@C_TimeArea      Save it\n         OI    @C_TimeArea+7,X'0F'      OR in a sign\n         MVC   VolTbl_Ent_Display(12),=X'402120202020612020612020'\n         ED    VolTbl_Ent_Display(12),@C_TimeArea+3 Edit date\n\n         LA    R1,@C_Parms              A(Parm list)\n         BRAS  R14,W00010               Get A(Free entry in VolTbl)\n         LTR   R15,R15                  Did it work?\n         JNZ   C00710                   No, skip headings\n\n         LR    R9,R1                    Get A(Free entry)\n\n         OI    VolTbl_Ent_Heading_Line,L'VolTbl_Ent_Heading_Line Flag\n         LA    R14,C_Hdg1               A(Heading line)\n         LHI   R15,C_Hdg1_Len           Length of heading\n         O     R15,=XL4'40000000'       Pad char of blank\n         LA    R0,VolTbl_Ent_Display    A(Target)\n         LHI   R1,VolTbl_Ent_Display_Len Length of target\n         MVCL  R0,R14                   Move heading\n         OI    VolTbl_Ent_Processed,L'VolTbl_Ent_Processed Mark as done\n         OI    VolTbl_Ent_ECB,X'40'     POST as complete\n\n         LA    R1,@C_Parms              A(Parm list)\n         BRAS  R14,W00010               Get A(Free entry in VolTbl)\n         LTR   R15,R15                  Did it work?\n         JNZ   C00710                   No, skip headings\n\n         LR    R9,R1                    Get A(Free entry)\n\n         OI    VolTbl_Ent_Heading_Line,L'VolTbl_Ent_Heading_Line Flag\n         LA    R14,C_Hdg2               A(Heading line)\n         LHI   R15,C_Hdg2_Len           Length of heading\n         O     R15,=XL4'40000000'       Pad char of blank\n         LA    R0,VolTbl_Ent_Display    A(Target)\n         LHI   R1,VolTbl_Ent_Display_Len Length of target\n         MVCL  R0,R14                   Move heading\n         OI    VolTbl_Ent_Processed,L'VolTbl_Ent_Processed Mark as done\n         OI    VolTbl_Ent_ECB,X'40'     POST as complete\n\n         LA    R1,@C_Parms              A(Parm list)\n         BRAS  R14,W00010               Get A(Free entry in VolTbl)\n         LTR   R15,R15                  Did it work?\n         JNZ   C00710                   No, skip headings\n\n         LR    R9,R1                    Get A(Free entry)\n\n         OI    VolTbl_Ent_Heading_Line,L'VolTbl_Ent_Heading_Line Flag\n         LA    R14,C_Hdg3               A(Heading line)\n         LHI   R15,C_Hdg3_Len           Length of heading\n         O     R15,=XL4'40000000'       Pad char of blank\n         LA    R0,VolTbl_Ent_Display    A(Target)\n         LHI   R1,VolTbl_Ent_Display_Len Length of target\n         MVCL  R0,R14                   Move heading\n         OI    VolTbl_Ent_Processed,L'VolTbl_Ent_Processed Mark as done\n         OI    VolTbl_Ent_ECB,X'40'     POST as complete\n\nC00710   DS    0H\n*---------------------------------------------------------------------*\n*   If we are running in Batch, and NOECHO was not specified, go      *\n*  print an image of the input record                                 *\n*---------------------------------------------------------------------*\n         TM    @_TSO_Command,L'@_TSO_Command Is this a TSO command?\n         JO    C00720                   Yes, skip\n\n         TM    @C_NoEcho,L'@C_NoEcho    Was NOECHO specified?\n         JNE   C00720                   Yes, skip\n\n         L     R15,@C_SYSIN_Rec_Ptr     A(Our data area)\n         ST    R15,@C_Parms_Y00010      Save it\n         L     R15,@_SYSIN_DCB_Ptr      Point to the DCB\n         LH    R15,DCBLRECL-IHADCB(R15) Get length\n         ST    R15,@C_Parms_Y00010+4    Save it\n\n         LA    R1,@C_Parms              A(Parm list)\n         BRAS  R14,Y00010               Output it to SYSPRINT\n\nC00720   DS    0H\n         LA    R15,0                    Clear return code\n         J     C90010                   and exit\n\nC00730   DS    0H\n         TM    @_TSO_Command,L'@_TSO_Command Is this a TSO command?\n         JZ    C00740                   No, skip\n         LA    R15,4                    PARSE failure\n         J     C90010                    and exit\n\nC00740   DS    0H\n         L     R15,@C_SYSIN_Rec_Ptr     A(Our data area)\n         ST    R15,@C_Parms_Y00010      Save it\n         L     R15,@_SYSIN_DCB_Ptr      Point to the DCB\n         LH    R15,DCBLRECL-IHADCB(R15) Get length\n         ST    R15,@C_Parms_Y00010+4    Save it\n\n         LA    R1,@C_Parms              A(Parm list)\n         BRAS  R14,Y00010               Output to SYSPRINT\n\n         LHI   R15,L'VolTbl_Ent_ErrMsg  Length of 1 message\n         ST    R15,@C_Parms_Y00010+4    Save it for Y00010\n         LA    R4,C_ErrMsgs             Point to 1st err msg\n         LHI   R3,C_ErrMsg_Count        Get the number of messages\nC00750   DS    0H\n         ST    R4,@C_Parms_Y00010       Save A(Error message)\n         LA    R1,@C_Parms              A(Parm list)\n         BRAS  R14,Y00010               Output to SYSPRINT\n         AHI   R4,L'VolTbl_Ent_ErrMsg   A(Next message)\n         BRCT  R3,C00750                and issue it\n\n         J     C00080                   Get another input record\n\n\n*-------------------------------------------------------------------*\n*    The following is the EOD exit when 31-bit SAM is not supported *\n*   for SYSIN. This code is moved to 24-bit storage, and is invoked *\n*   by SYSIN EOD. All it does is branch to our 'real' EOD routine,  *\n*   in 31-bit mode.                                                 *\n*-------------------------------------------------------------------*\n         PUSH  USING                  Save current USINGs\n         DROP  ,                      No USINGs now\n\nC00760_24_Start DS 0H                Start of 24-bit EOD Routine\n         BASR  R15,0                  Load up our base\n         USING *,R15                  Tell the Assembler\n         L     R15,C00760_24_EOD      Get real EODAD\n         BSM   0,R15                  and go do it (in 31-bit mode)\nC00760_24_EOD DC AL4(X'80000000'+C00760) Real EODAD\nC00760_24_Length EQU *-C00760_24_Start Length of 24-bit EOD Routine\n\n         DROP  R15                    Free up our base reg\n         POP   USING                  Restore USING environment\n\n\nC00760   DS    0H\n         TM    @_TSO_Command,L'@_TSO_Command Is this a TSO command?\n         JO    C00780                   Yes, skip\n         ICM   R1,B'1111',@_SYSIN_DCB_Ptr A(SYSIN DCB)\n         JZ    C00780                   None, skip\n         TM    DCBOFLGS-IHADCB(R1),DCBOFOPN Is it open?\n         JNO   C00770                   No, skip\n         MVC   @C_CLOSE,C_CLOSE         Yes, move CLOSE parms\n         LR    R3,R1                    Set up DCB pointer\n         CLOSE ((3)),MODE=31,MF=(E,@C_CLOSE)  and close it\nC00770   DS    0H\n         LHI   R0,C_SYSIN_DCB_Length+C00760_24_Length+7 DCB, 24-bit EOD\n         SRL   R0,3                     DBLWD\n         SLL   R0,3                      multiple\n\n         L     R1,@_SYSIN_DCB_Ptr       A(SYSIN DCB area)\n\n         BASR  R2,0\n         USING (*,C00770_End-1),R2\n         STORAGE RELEASE,               Free the DCB storage           +\n               ADDR=(1),                 starting here                 +\n               LENGTH=(0)                this long\nC00770_End DS  0H\n         DROP  R2\n\n         LA    R15,0                    Clear work register\n         ST    R15,@_SYSIN_DCB_Ptr      No more DCB area\nC00780   DS    0H\n         LA    R15,4                    Set return code\n         J     C90010                    and exit\n\n\nC90010   DS    0H\n*-------------------------------------------------------------------*\n*    Free up our local storage ...                                  *\n*-------------------------------------------------------------------*\n         LR    R3,R15                 Save return code\n\n         LA    R1,@C_Dynam              A(Local storage)\n         L     R2,@C_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         L     R13,4(0,R13)             Rescue A(HSA)\n\n         SSCSTACK POP,                  Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=(R2)                on this stack\n\n         LR    R15,R3                   Restore return code\n\n*-------------------------------------------------------------------*\n*    ... and return to caller                                       *\n*-------------------------------------------------------------------*\n         L     R14,12(0,R13)            Restore return address\n         LM    R0,R12,20(R13)           Restore other registers\n         BSM   0,R14                    and return\n\nC_Literals  DS  0H\n\nC2EX1    MVC   0(0,R4),0(R15)           Move UCB/Volser\nC2EX3    MVC   @_UNITNM(0),0(R15)       Move Unit Name\nC2EX4    MVC   @_OutFile_DDName(0),0(R15) Move OUTFILE DDName\nC2EX5    PACK  @C_DBLWD,0(0,R15)        Pack a number\nC_Save_Sort_Field  MVC   @_Sort_Field(0),5(R14)\n\nC_PgmName  DC  C'&PGMNAME'      Simulated command name\n\n         PUSH  PRINT\n         PRINT NOGEN\n\nC_Time   TIME  LINKAGE=SYSTEM,MF=L\nC_Time_Length EQU *-C_Time\n\nC_OPEN    OPEN  (0,INPUT),MODE=31,MF=L\nC_OPEN_Length EQU *-C_OPEN\n\nC_CLOSE   CLOSE (0),MODE=31,MF=L\nC_CLOSE_Length EQU *-C_CLOSE\n\nC_LINKX   LINKX SF=L\nC_LINKX_Length EQU *-C_LINKX\n         POP   PRINT\n\nC_TrTbl  DC    256AL1(*-C_TrTbl)\n         ORG   C_TrTbl+C'?'\n         DC    X'FF'\n         ORG   C_TrTbl+C'%'\n         DC    X'FF'\n         ORG   C_TrTbl+C'*'\n         DC    X'FF'\n         ORG\n\nC_TrTbl1 DC    256X'00'\n         ORG   C_TrTbl1+C'?'\n         DC    X'FF'\n         ORG   C_TrTbl1+C'%'\n         DC    X'FF'\n         ORG   C_TrTbl1+C'*'\n         DC    X'FF'\n         ORG\n\n         LTORG\n\n         PUSH  PRINT\n         PRINT NOGEN\nC_SYSIN_DCB DCB   DDNAME=SYSIN,DSORG=PS,MACRF=GL,LRECL=80,             +\n               DCBE=C_SYSIN_DCBE\n         DS    0D\nC_SYSIN_DCB_Length EQU *-C_SYSIN_DCB\n\nC_SYSIN_DCBE DCBE RMODE31=BUFF,EODAD=C00760\n         DS    0D\nC_SYSIN_DCBE_Length EQU *-C_SYSIN_DCBE\n\nC_SYSIN24_DCB DCB   DDNAME=SYSIN,DSORG=PS,MACRF=GL,LRECL=80,           +\n               EODAD=0\n         DS    0D\nC_SYSIN24_DCB_Length EQU *-C_SYSIN24_DCB\n         POP   PRINT\n\nC_Hdg0   EQU   *\n         DC    C' yyyy/mm/dd hh:mm:ss   &PGMNAME &VERSION DASD Free Spa+\n               ce Report'\nC_Hdg0_Len EQU *-C_Hdg0\n\nC_Hdg1   EQU   *\n         DC    CL(VolTbl_Ent_FreeSpace_Info-VolTbl_Ent_Display_Start)' +\n               '\nC_Hdg1_1 DC    (VolTbl_Ent_FreeSpace_Info_End-VolTbl_Ent_FreeSpace_Info+\n               )C'-'\n         ORG   C_Hdg1_1+((*-C_Hdg1_1-13)/2)\n         DC    C' Volume Free '\n         ORG   ,\n         DC    CL(VolTbl_Ent_VTOC_Info-VolTbl_Ent_FreeSpace_Info_End)' +\n               '\nC_Hdg1_2 DC    (VolTbl_Ent_VTOC_Info_End-VolTbl_Ent_VTOC_Info)C'-'\n         ORG   C_Hdg1_2+((*-C_Hdg1_2-6)/2)\n         DC    C' VTOC '\n         ORG   ,\n         DC    CL(VolTbl_Ent_SMS_Info-VolTbl_Ent_VTOC_Info_End)' '\nC_Hdg1_3 DC    (VolTbl_Ent_SMS_Info_End-VolTbl_Ent_SMS_Info)C'-'\n         ORG   C_Hdg1_3+((*-C_Hdg1_3-5)/2)\n         DC    C' SMS '\n         ORG   ,\n         DC    CL(VolTbl_Ent_CHPID_Info-VolTbl_Ent_SMS_Info_End)' '\nC_Hdg1_4 DC    (VolTbl_Ent_CHPID_Info_End-VolTbl_Ent_CHPID_Info)C'-'\n         ORG   C_Hdg1_4+((*-C_Hdg1_4-8)/2)\n         DC    C' CHPIDs '\n         ORG   ,\nC_Hdg1_Len EQU *-C_Hdg1\n\nC_Hdg2   EQU   *\n         DC    C'                                                    '\n         DC    C'   Nbr   - Largest -  Frag         Free    % IX'\n         DC    C'   Vol  Storage                                     '\n         DC    C'                '\nC_Hdg2_Len EQU *-C_Hdg2\n\nC_Hdg3   EQU   *\n         DC    C'VOLSER  UCB  DevType   St    Trks  Cyls     %  Bytes'\n         DC    C' Xtnts    Trks  Cyls Index   Trks DSCBs Free St'\n         DC    C'  Size  Group    Status                             '\n         DC    C'                '\nC_Hdg3_Len EQU *-C_Hdg3\n\nC_ErrMsgs EQU  *\n\n         DC    CL(L'VolTbl_Ent_ErrMsg)'*** Unrecognized input - ignored+\n                ***'\n         DC    CL(L'VolTbl_Ent_ErrMsg)' '\n         DC    CL(L'VolTbl_Ent_ErrMsg)'Valid Keywords:'\n         DC    CL(L'VolTbl_Ent_ErrMsg)' UCB(Unit-mask)     specifies th+\n               e selection criterion based on UCB Address.'\n         DC    CL(L'VolTbl_Ent_ErrMsg)' XUCB(Unit-mask)    specifies th+\n               e exclusion criterion based on UCB Address.'\n         DC    CL(L'VolTbl_Ent_ErrMsg)' VOLUME(Volser)     specifies th+\n               e selection criterion based on volser.'\n         DC    CL(L'VolTbl_Ent_ErrMsg)' XVOLUME(Volser)    specifies th+\n               e exclusion criterion based on volser.'\n         DC    CL(L'VolTbl_Ent_ErrMsg)' NAME(Unit-Name)    specifies th+\n               e selection criterion based on generic'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                  or esoteric Un+\n               it name.'\n         DC    CL(L'VolTbl_Ent_ErrMsg)' ATTRIBUTE(STORAGE/STG/PRIVATE/P+\n               VT/PUBLIC/SMS)'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                  specifies the +\n               selection criterion based on mount'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                  attribute. Onl+\n               y one of the keywords can be specified.'\n         DC    CL(L'VolTbl_Ent_ErrMsg)' STORGRP(SMS-Storage_Group_Name)+\n               '\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                  specifies the +\n               selection criterion based on SMS'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                  Storage Group.+\n               '\n         DC    CL(L'VolTbl_Ent_ErrMsg)' SORT(id)         specifies the +\n               order in which the selected DASD volumes'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                  are displayed:+\n               '\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                   id: VOL     -+\n                Volser'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                       UCB     -+\n                UCB Name (Device Address)'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                       DEVT    -+\n                Device Type'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                       ATTR    -+\n                Mount Attribute'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                       FREET   -+\n                Total Free Tracks'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                       FREEC   -+\n                Total Free Cylinders'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                       FREEP   -+\n                % Volume Free'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                       FREEB   -+\n                Total Free Bytes'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                       FREEE   -+\n                # Free Extents'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                       LARGET  -+\n                Largest Free Tracks'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                       LARGEC  -+\n                Largest Free Cylinders'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                       VFREED  -+\n                Free DSCBs in VTOC'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                       VFREEP  -+\n                % VTOC Free'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                       VTRK    -+\n                Tracks allocated to the VTOC'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                       VIX     -+\n                VTOC Index Status'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                       FRAG    -+\n                Fragmentation Index'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                       VOLSIZE -+\n                Volume Capacity'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                       STORGRP -+\n                SMS Storage Group'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                       SMSSTAT -+\n                SMS Volume Status'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                       CHIPDS  -+\n                1st CHPID'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                  By default, th+\n               e display is unsorted, and will'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                  normally appea+\n               r in ascending order of UCB.'\n         DC    CL(L'VolTbl_Ent_ErrMsg)' ASCENDING/DESCENDING specifies +\n               the SORT order. Significant only if'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                  SORT() is spec+\n               ified. Default is ASCENDING'\n         DC    CL(L'VolTbl_Ent_ErrMsg)' MAXTASKS(#)        specifies th+\n               e maximum number of sub-tasks (1-16) to'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                  be ATTACHed to+\n                retrieve volume information.'\n         DC    CL(L'VolTbl_Ent_ErrMsg)' OUTFILE(ddname)  specifies the +\n               DDNAME of an output file to which'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                  volume informa+\n               tion will be written, in addition'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                  to SYSPRINT.'\n         DC    CL(L'VolTbl_Ent_ErrMsg)' OUTDATA(DISPLAY/CB/ALL) specifi+\n               es the type of data to be written to'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                  the OUTFILE DD+\n               NAME:'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                   DISPLAY write+\n               s SYSPRINT data to OUTFILE'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                   CB      wtite+\n               s copies of the UCB, DCE, LSPACE,'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                           and F+\n               4DSCB to OUTFILE'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                   ALL     write+\n               s both CB and DISPLAY (default).'\n         DC    CL(L'VolTbl_Ent_ErrMsg)' NOHEADINGS/NOHDG suppresses hea+\n               dings (and page breaks).'\n         DC    CL(L'VolTbl_Ent_ErrMsg)' NODETAILS        suppresses det+\n               ail (DASD volume) lines.'\n         DC    CL(L'VolTbl_Ent_ErrMsg)' NOTOTALS         suppresses tot+\n               als line.'\n         DC    CL(L'VolTbl_Ent_ErrMsg)' NOECHO           suppresses the+\n                display of the input command.'\n         DC    CL(L'VolTbl_Ent_ErrMsg)' STATISTICS/STATS displays inter+\n               nal processing statistics.'\n         DC    CL(L'VolTbl_Ent_ErrMsg)' ISPF(S/E/B/N)    displays resul+\n               ts using ISPF DM services, if available.'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                   S(pace) uses +\n               customized &PGMNAME displays'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                   E(dif) uses I+\n               SPF Edit services'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                   B(rif) uses I+\n               SPF Browse services.'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                   N(one) uses T+\n               SO line-by-line (PUTLINE) output.'\n         DC    CL(L'VolTbl_Ent_ErrMsg)' NOLSPACE         specifies that+\n                no volume space information is required.'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                  Fields display+\n               ed are: UCB, Volser, DevType, Attr, SMS'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                  data, and CHPI+\n               Ds.'\n         DC    CL(L'VolTbl_Ent_ErrMsg)' LINESIZE(nnn)    specifies the +\n               maximum line length to be displayed'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                  in TSO line-by+\n               line output.'\n         DC    CL(L'VolTbl_Ent_ErrMsg)' MAXLWAIT(nnnn)   specifies the +\n               maximum number of seconds in which'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                  each LSPACE in+\n               vocation must complete. 0 signifies'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                  no limit.'\n\nC_ErrMsg_Count EQU   (*-C_ErrMsgs)/L'VolTbl_Ent_ErrMsg\n\n         PUSH  PRINT\n         PRINT NOGEN\n\nC_PCL    RMODE ANY\nC_PCL    AMODE 31\nC_PCL    IKJPARM\n\nC_01K    IKJKEYWD\n         IKJNAME 'UNIT',                                               +\n               ALIAS='UCB',                                            +\n               SUBFLD=C_01SF\n\nC_02K    IKJKEYWD\n         IKJNAME 'XUNIT',                                              +\n               ALIAS='XUCB',                                           +\n               SUBFLD=C_02SF\n\nC_03K    IKJKEYWD\n         IKJNAME 'VOLUME',                                             +\n               SUBFLD=C_03SF\n\nC_04K    IKJKEYWD\n         IKJNAME 'XVOLUME',                                            +\n               SUBFLD=C_04SF\n\nC_05K    IKJKEYWD\n         IKJNAME 'NAME',                                               +\n               SUBFLD=C_05SF\n\nC_06K    IKJKEYWD\n         IKJNAME 'ATTRIBUTE',                                          +\n               SUBFLD=C_06SF\n\nC_07K    IKJKEYWD\n         IKJNAME 'STORGRP',                                            +\n               ALIAS='SG',                                             +\n               SUBFLD=C_07SF\n\nC_09K    IKJKEYWD\n         IKJNAME 'SORT',                                               +\n               SUBFLD=C_09SF\n\nC_10K    IKJKEYWD\n         IKJNAME 'ASCENDING'\n         IKJNAME 'DESCENDING'\n\nC_11K    IKJKEYWD\n         IKJNAME 'MAXTASKS',                                           +\n               SUBFLD=C_11SF\n\nC_12K    IKJKEYWD\n         IKJNAME 'ISPF',                                               +\n               SUBFLD=C_12SF\n\nC_13K    IKJKEYWD\n         IKJNAME 'NOHEADINGS',                                         +\n               ALIAS='NOHDG'\n\nC_14K    IKJKEYWD\n         IKJNAME 'NODETAILS'\n\nC_15K    IKJKEYWD\n         IKJNAME 'NOTOTALS'\n\nC_16K    IKJKEYWD\n         IKJNAME 'NOECHO'\n\nC_17K    IKJKEYWD\n         IKJNAME 'STATISTICS',                                         +\n               ALIAS='STATS'\n\nC_18K    IKJKEYWD\n         IKJNAME 'NOLSPACE'\n\nC_20K    IKJKEYWD\n         IKJNAME 'OUTFILE',                                            +\n               ALIAS=('OFILE','OUTDDNAME'),                            +\n               SUBFLD=C_20SF\n\nC_21K    IKJKEYWD\n         IKJNAME 'OUTDATA',                                            +\n               SUBFLD=C_21SF\n\nC_22K    IKJKEYWD\n         IKJNAME 'LINESIZE',                                           +\n               SUBFLD=C_22SF\n\nC_23K    IKJKEYWD\n         IKJNAME 'MAXLWAIT',                                           +\n               SUBFLD=C_23SF\n\n\n\nC_01SF   IKJSUBF\nC_01SFP  IKJIDENT 'UCB Mask(s) to be selected',                        +\n               LIST,                                                   +\n               MAXLNTH=4,                                              +\n               FIRST=ANY,                                              +\n               OTHER=ANY\n\nC_02SF IKJSUBF\nC_02SFP   IKJIDENT 'UCB Mask(s) to be excluded',                       +\n               LIST,                                                   +\n               MAXLNTH=4,                                              +\n               FIRST=ANY,                                              +\n               OTHER=ANY\n\nC_03SF   IKJSUBF\nC_03SFP  IKJIDENT 'Volser mask(s) to be selected',                     +\n               LIST,                                                   +\n               MAXLNTH=6,                                              +\n               FIRST=ANY,                                              +\n               OTHER=ANY\n\nC_04SF    IKJSUBF\nC_04SFP   IKJIDENT 'Volser mask(s) to be excluded',                    +\n               LIST,                                                   +\n               MAXLNTH=6,                                              +\n               FIRST=ANY,                                              +\n               OTHER=ANY\n\nC_05SF   IKJSUBF\nC_05SFP  IKJIDENT 'Unit Name to be selected',                          +\n               MAXLNTH=8,                                              +\n               FIRST=ANY,                                              +\n               OTHER=ANY\n\nC_06SF   IKJSUBF\nC_06SFP  IKJKEYWD\n         IKJNAME 'STORAGE',                                            +\n               ALIAS='STG'\n         IKJNAME 'PRIVATE',                                            +\n               ALIAS='PVT'\n         IKJNAME 'PUBLIC'\n         IKJNAME 'SMS'\n\nC_07SF    IKJSUBF\nC_07SFP   IKJIDENT 'SMS Storage Group Name(s)',                        +\n               LIST,                                                   +\n               MAXLNTH=30,                                             +\n               FIRST=ANY,                                              +\n               OTHER=ANY\n\nC_09SF   IKJSUBF\nC_09SFP  IKJKEYWD\n         IKJNAME 'VOL'\n         IKJNAME 'UCB'\n         IKJNAME 'DEVT'\n         IKJNAME 'ATTR'\n         IKJNAME 'FREET'\n         IKJNAME 'FREEC'\n         IKJNAME 'FREEP'\n         IKJNAME 'FREEB'\n         IKJNAME 'FREEE'\n         IKJNAME 'LARGET'\n         IKJNAME 'LARGEC'\n         IKJNAME 'VFREED'\n         IKJNAME 'VFREEP'\n         IKJNAME 'VTRK'\n         IKJNAME 'VIX'\n         IKJNAME 'FRAG'\n         IKJNAME 'VOLSIZE'\n         IKJNAME 'STORGRP'\n         IKJNAME 'SMSSTAT'\n         IKJNAME 'CHPIDS'\n\nC_11SF   IKJSUBF\nC_11SFP  IKJIDENT 'Maximum number of Sub-Tasks',                       +\n               MAXLNTH=2,                                              +\n               INTEG\n\nC_12SF IKJSUBF\n         AIF   ('&ISPF_Default_Type' EQ '').ISPF_Default_Type_010\nC_12SFP  IKJKEYWD DEFAULT='&ISPF_Default_Type'\n         AGO   .ISPF_Default_Type_020\n.ISPF_Default_Type_010 ANOP\nC_12SFP  IKJKEYWD\n.ISPF_Default_Type_020 ANOP\n         IKJNAME 'EDIF'\n         IKJNAME 'BRIF'\n         IKJNAME 'SPACE'\n         IKJNAME 'NONE'\n\n\nC_20SF   IKJSUBF\nC_20SFP  IKJIDENT 'DDNAME of output file',                             +\n               MAXLNTH=8,                                              +\n               FIRST=ALPHA,                                            +\n               OTHER=ANY\n\nC_21SF IKJSUBF\nC_21SFP  IKJKEYWD DEFAULT='ALL'\n         IKJNAME 'DISPLAY'\n         IKJNAME 'CB'\n         IKJNAME 'ALL'\n\nC_22SF   IKJSUBF\nC_22SFP  IKJIDENT 'Max length of data to be displayed',                +\n               MAXLNTH=3,                                              +\n               FIRST=ANY,                                              +\n               OTHER=ANY\n\nC_23SF   IKJSUBF\nC_23SFP  IKJIDENT 'Nbr seconds for LSPACE completion',                 +\n               MAXLNTH=4,                                              +\n               FIRST=NUMERIC,                                          +\n               OTHER=NUMERIC\n\n         IKJENDP\n\n         POP   PRINT\n\nC_Literals_End  DS  0H\n\n\n@C_Dynam                  DSECT       Dynamic area for C00000\n                          DS    18F    O/S Style save area\n@C_31Bit_Stack_Ptr_Ptr    DS    AL4    A(31-bit Stack Ptr)\n@C_24Bit_Stack_Ptr_Ptr    DS    AL4    A(24-bit Stack Ptr)\n@C_DBLWD                  DS    D      Workarea\n@C_PPL                    DS    CL(PPL_Length) PPL area\n@C_PECB                   DS    F      ECB for PARSE\n@C_PANS                   DS    A      PARSE answer area\n@C_SYSIN_Rec_Ptr          DS    AL4    SYSIN Record Pointer\n@C_CPPL_Ptr               DS    AL4    A(CPPL)\n@C_CBUF                   EQU   *      Batch Command buffer\n@C_CBUF_Len               DS    HL2     Length\n@C_CBUF_Off               DS    HL2     Offset to operands\n@C_CBUF_Data              DS    CL255   Data\n@C_CBUF1                  EQU   *      Cbuf after ASASYMBM\n@C_CBUF1_Len              DS    HL2     Length\n@C_CBUF1_Off              DS    HL2     Offset to operands\n@C_CBUF1_Data             DS    CL255   Data\n                          DS    X      Flag byte\n@C_NoEcho                 EQU   *-1,X'80' 1... .... NOECHO specified\n@C_UNIT_Flag              EQU   *-1,X'40' .1.. .... UNIT processed\n@C_XUNIT_Flag             EQU   *-1,X'20' ..1. .... XUNIT processed\n@C_VOL_Flag               EQU   *-1,X'10' ...1 .... VOL processed\n@C_XVOL_Flag              EQU   *-1,X'08' .... 1... XVOL processed\n@C_UPTSWS                 DS    XL(L'UPTSWS) UPTSWS Save\n\n                          DS    0F\n@C_Macros                 EQU   *\n@C_OPEN                   DS    CL(C_OPEN_Length)  OPEN parms\n                          ORG   @C_Macros\n@C_CLOSE                  DS    CL(C_CLOSE_Length) Close Parms\n                          ORG   @C_Macros\n@C_Time                   DS    CL(C_Time_Length)  L-Form of Time\n                          DS    0D                 Alignment\n@C_TimeArea               DS    CL16               Return area for Time\n                          ORG   @C_Macros\n@C_LINKX                  DS    CL(C_LINKX_Length) LINKX Macro\n@C_SYMBP                  DS    CL(SYMBP_LEN)      ASASYMBM Parm area\n@C_SYMBP_Target_Len       DS    FL4             ASASYMBM Target Length\n@C_SYMBP_RC               DS    FL4             ASASYMBM Return code\n                          ORG   ,\n@C_Parms                  DS    0F     Parms for called rtns\n@C_Parms_Std              DS    3AL4    Standard 3 parms\n@C_Parms_Extra            EQU   *       Extra parms\n@C_Parms_Y00010           DS    2AL4       for Y00010\n                          ORG   ,\n                          DS    0D     Alignment\n@C_Dynam_Length           EQU   *-@C_Dynam  Length of storage\n\n&PGMNAME CSECT\n\n         DROP  ,\n         POP   USING\n\n         TITLE 'D00010: Get Eligible UCBs'\n\n         PUSH  USING\n\nD00010   DS    0H\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Routine   : D00010                                                 *\n*                                                                     *\n*  Abstract  : Populate Volume Table with eligible UCBs.              *\n*                                                                     *\n*  Inputs    : R1 : ---> A(@_Dynam)                                   *\n*                        A(31-bit Stack Pointer)                      *\n*                        A(24-bit Stack Pointer)                      *\n*  Outputs   : R15: 0 - OK, @_VolTbl_Ptr contains A(Volume Table)     *\n*                   4 - No UCBs found/Insufficient Storage            *\n*                                                                     *\n*  Notes     : @_VOL_List_Ptr contains A(Volume masks)                *\n*              @_XVOL_List_Ptr contains A(Xolume masks)               *\n*              @_UCB_List_Ptr contains A(UCB masks)                   *\n*              @_XUCB_List_Ptr contains A(XUCB masks)                 *\n*              @_UNITNM contains the Esoteric Unit Name               *\n*              @_ATTR??? contains the Mount Attribute flags           *\n*              @_STORGRP_List_Ptr contains A(StorGrp masks)           *\n*                                                                     *\n*  History:    1990/06/11 SDDA030 - New                               *\n*              1994/05/24 SDDA030 - Used SSCUCBS to get list of UCBs  *\n*                                 - Added creation of dummy total line*\n*              1996/03/13 SDDA030 - Used UCBCHAN rather than UCBNAME  *\n*                                   to get readable device address    *\n*                                   (VolTbl_Ent_DevAddr)              *\n*                                 - Use our own UCB look-up routines  *\n*                                   rather than SSCUCBS               *\n*              1998/09/17 SDDA030 - V2.0                              *\n*                                 - Removed APF checks, and undoc-    *\n*                                   umented UCB search method.        *\n*                                 - Use UCBSCAN with DCEAREA to get   *\n*                                   DCE info.                         *\n*              1998/09/22 SDDA030 - V2.1                              *\n*                                 - Made sure there was always room   *\n*                                   in the Volume Table for the Totals*\n*                                   Line, if required.                *\n*                                 - Added '%' as a single-character   *\n*                                   wild-card match (like '?') in     *\n*                                   UCB and Volser.                   *\n*                                 - Added repetitive search if select-*\n*                                   ing by UCB address when the user  *\n*                                   entered a potential 3-byte UCB    *\n*                                   address mask, and we found no UCBs*\n*                                   because we were using it as a     *\n*                                   4-byte UCB address mask.          *\n*                                 - Added DEVN to UCBSCAN             *\n*                                 - Invoke UCBSCAN with VOLSER= if    *\n*                                   we are checking for a specific    *\n*                                   Volser                            *\n*                                 - Broke out Subtask Management code *\n*                                   into a separate routine (E00010). *\n*              1999/08/20 SDDA030 - V2.8                              *\n*                                 - Used Routine W00010 to manage     *\n*                                   VolTbl entries.                   *\n*              2001/02/26 SDDA030 - V2.14                             *\n*                                 - Added SMS Storage Group and CHPID *\n*                                   info.                             *\n*                                 - Used only DCEOBRDT to determine   *\n*                                   Device Type.                      *\n*                                 - Added 'N/A' in SMS fields for     *\n*                                   non-SMS volumes.                  *\n*              2001/11/12 SDDA030 - V2.15                             *\n*                                 - Added XUCB, XVOL processing       *\n*                                 - Added RANGE=ALL, DYNAMIC=YES,     *\n*                                   LOC=ANY to EDTINFO                *\n*              2002/03/11 SDDA030 - V2.17                             *\n*                                 - Added STORGRP selection logic     *\n*                                 - Moved SMS IEFSSREQ stuff to T00010*\n*                                 - Added indicators for CHPIDs not   *\n*                                   phys or log available.            *\n*              2002/06/11 SDDA030 - V2.18                             *\n*                                 - Formatted as much of total line as*\n*                                   possible.                         *\n*                                 - 'POST' entries as complete if we  *\n*                                   will not be LSPACEing.            *\n*              2002/08/08 SDDA030 - V2.19                             *\n*                                 - Merged code from U0010 into this  *\n*                                   section                           *\n*                                 - Corrected increment when stepping *\n*                                   through @_STORGRP_List            *\n*              2003/10/07 SDDA030 - V2.21                             *\n*                                 - Fixed S0C4 when adjusting UCB pat-*\n*                                   terns when no UCBs found when sel-*\n*                                   ecting by UCB.                    *\n*                                 - Limited re-searching based on len *\n*                                   of entered UCB mask(s)            *\n*              2005/01/20 SDDA030 - V2.23                             *\n*                                 - Used CSRSI, if possible, to get   *\n*                                   CPU info.                         *\n*              2006/04/21 SDDA030 - V2.24                             *\n*                                 - Added .e display                  *\n*                                 - Init CHPIDs to '--'               *\n*                                 - Used standardised calling sequence*\n*                                 - Coped with insufficient storage   *\n*                                   for the volume table.             *\n*                                 - Used UCBTBYT4 to find device type *\n*                                   for emulated devices.             *\n*              ____/__/__ _______ -                                   *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         STM   R14,R12,12(R13)          Save callers registers\n         LARL  R11,D_Literals           Point to our literals\n         USING (D_Literals,D_Literals_End),R11 Tell the assembler\n\n         L     R12,0(0,R1)              A(@_Dynam)\n         USING @_Dynam,R12              Tell the assembler\n\n*-------------------------------------------------------------------*\n*    Get an area on the stack for our local storage                 *\n*-------------------------------------------------------------------*\n         L     R2,4(0,R1)               A(31-bit stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         SSCSTACK PUSH,                 Get stack area                 +\n               LEN=@D_Dynam_Length,      this long                     +\n               STACK=(R2)                using this stack\n\n         LR    R3,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LHI   R1,@D_Dynam_Length        Its length\n         LA    R14,0                    Clear source address\n         LA    R15,0                     and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R3                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*-------------------------------------------------------------------*\n         ST    R13,4(0,R1)              Chain\n         ST    R1,8(0,R13)               saveareas\n         LR    R13,R1                   Load dynam base\n         USING @D_Dynam,R13             Assign a base\n         L     R15,@D_Dynam+4           Get A(HSA)\n         LM    R0,R3,20(R15)            Restore callers registers\n\n         L     R15,4(0,R1)              A(31-bit Stack)\n         ST    R15,@D_31Bit_Stack_Ptr_Ptr Save it\n         L     R15,8(0,R1)              A(24-bit Stack)\n         ST    R15,@D_24Bit_Stack_Ptr_Ptr Save it\n\nD00020   DS    0H\n*-------------------------------------------------------------------*\n*    Reset our flags and counters                                   *\n*-------------------------------------------------------------------*\n         NI    @D_Eligible_UCB_Found,X'FF'-L'@D_Eligible_UCB_Found\n         NI    @D_CHPID_Unavail,X'FF'-L'@D_CHPID_Unavail CHPIDs OK\n         LA    R15,0                    Clear\n         ST    R15,@D_Volume_Count       nbr vols found\n\n*--------------------------------------------------------------------*\n*   Initialize our standard parmlist                                 *\n*--------------------------------------------------------------------*\n         LA    R15,@_Dynam              A(Dynamic area)\n         ST    R15,@D_Parms_Std         Save it\n         L     R15,@D_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)\n         ST    R15,@D_Parms_Std+4       Save it\n         L     R15,@D_24Bit_Stack_Ptr_Ptr A(24-bit Stack Pointer)\n         ST    R15,@D_Parms_Std+8       Save it\n\n*---------------------------------------------------------------------*\n*     If we are selecting by name, go get UCBs associated with the    *\n*    name                                                             *\n*---------------------------------------------------------------------*\n         LA    R15,0                    Clear\n         ST    R15,@D_UNITA              A(Unit Table)\n\n         CLI   @_UNITNM,C' '            Selecting by unit name?\n         JE    D00030                   No, skip\n         LHI   R0,128                   Yes, get table\n         SLL   R0,8                      size of 32K\n         BASR  R2,0\n         USING (*,D00020_End-1),R2\n         STORAGE OBTAIN,                Go get storage                 +\n               LENGTH=(0),               this long                     +\n               LOC=31                    above-the-line\nD00020_End DS  0H\n         DROP  R2\n         ST    R1,@D_UNITA              Save it\n         ST    R0,0(0,R1)               Save table length\n         LA    R15,0                    Clear nbr entries\n         ST    R15,4(0,R1)              Update table\n         MVI   @D_IOCT,0                Clear IOCP Token field\n         MVC   @D_IOCT+1(L'@D_IOCT-1),@D_IOCT\n         EDTINFO RTNDEVN,               Get UCB numbers                +\n               UNITNAME=@_UNITNM,        for this esoteric             +\n               DEVNLIST=@D_UNITA,        save them here                +\n               DYNAMIC=YES,              get dynamic devices           +\n               RANGE=ALL,                3- and 4-digit UCBs           +\n               LOC=ANY,                  no matter where they live     +\n               IOCTOKEN=@D_IOCT,         use dummy IOC Token           +\n               MF=(E,@D_EDTINFO)         staying reentrant\n         LTR   R15,R15                  Did it work?\n         JNZ   D00490                   No, exit\n\nD00030   DS    0H\n*---------------------------------------------------------------------*\n*   We now go and get UCBs (in fact, we get UCB copys), and the       *\n*  associated Device Class Extensions (DCEs) using UCBSCAN.           *\n*  First, however, we have to get the I/O Config token.               *\n*---------------------------------------------------------------------*\n         IOCINFO IOCTOKEN=@D_IOCT,      Get I/O Config token           +\n               MF=(E,@D_IOCINFO)\n\nD00040   DS    0H\n*---------------------------------------------------------------------*\n*   Initialize the UCBSCAN workarea ...                               *\n*---------------------------------------------------------------------*\n         XC    @D_UCBSCAN_WorkArea,@D_UCBSCAN_WorkArea Clear workarea\n\n*---------------------------------------------------------------------*\n*   If we have been invoked for a single Volser (ie, one with no      *\n*  wildcards), we invoke UCBSCAN with the VOLSER parameter, and set   *\n*  a flag indicating that we want to be invoked once only             *\n*---------------------------------------------------------------------*\n         NI    @D_Single_Volser,X'FF'-L'@D_Single_Volser Off our flag\n         ICM   R1,B'1111',@_Vol_List_Ptr A(Volser list)\n         JZ    D00050                   None, skip\n         L     R0,Vol_List_Hdr_Count-Vol_List_Hdr(R1) Get count\n         CHI   R0,1                     A single volser?\n         JNE   D00050                   No, skip\n         CLI   Vol_List_Ent_Mask-Vol_List_Hdr(R1),X'00' With\n         JNE   D00050                    no wildcards?\n         CLC   Vol_List_Ent_Mask+1-Vol_List_Hdr(L'Vol_List_Ent_Mask-1,R+\n               1),Vol_List_Ent_Mask-Vol_List_Hdr(R1)\n         JNE   D00050                   Wildcards, skip\n\n         OI    @D_Single_Volser,L'@D_Single_Volser Only 1 Volser\n         LA    R3,Vol_List_Ent_Vol-Vol_List_Hdr(R1) Point to it\n\n         LHI   R15,L'@D_DCE             Length of DCE area\n         STH   R15,@D_DCE_Length        Save it\n\n         UCBSCAN COPY,                  Get a copy of a UCB            +\n               UCBAREA=@D_UCB,           here                          +\n               DCEAREA=@D_DCE,           copy DCE as well              +\n               DCELEN=@D_DCE_Length,     copy this much                +\n               DYNAMIC=YES,              include HCD devices           +\n               NONBASE=NO,               only 1 UCB per device         +\n               DEVCLASS=DASD,            this device type only         +\n               RANGE=ALL,                3- and 4-byte UCB addresses   +\n               VOLSER=(3),               find this volume              +\n               IOCTOKEN=@D_IOCT,         This I/O Config               +\n               WORKAREA=@D_UCBSCAN_WorkArea, use this workarea         +\n               MF=(E,@D_UCBSCAN)         and stay re-entrant\n\n         LTR   R15,R15                  Did we get one?\n         JZ    D00060                   Yes, skip\n         CHI   R15,12                   No, I/O config changed?\n         JE    D00020                   Yes, start again\n         J     D00490                   End of UCBs, skip\n\nD00050   DS    0H\n*---------------------------------------------------------------------*\n*     Get the next UCB                                                *\n*---------------------------------------------------------------------*\n         LHI   R15,L'@D_DCE             Length of DCE area\n         STH   R15,@D_DCE_Length        Save it\n\n         UCBSCAN COPY,                  Get a copy of a UCB            +\n               UCBAREA=@D_UCB,           here                          +\n               DCEAREA=@D_DCE,           copy DCE as well              +\n               DCELEN=@D_DCE_Length,     copy this much                +\n               DYNAMIC=YES,              include HCD devices           +\n               NONBASE=NO,               only 1 UCB per device         +\n               DEVCLASS=DASD,            this device type only         +\n               RANGE=ALL,                3- and 4-byte UCB addresses   +\n               IOCTOKEN=@D_IOCT,         This I/O Config               +\n               WORKAREA=@D_UCBSCAN_WorkArea, use this workarea         +\n               MF=(E,@D_UCBSCAN)         and stay re-entrant\n\n         LTR   R15,R15                  Did we get one?\n         JZ    D00060                   Yes, skip\n         LA    R0,12                    No, RC if I/O config changed\n         CR    R0,R15                   Is that what happened?\n         JE    D00020                   Yes, start again\n         J     D00490                   No, end of UCBs, skip\n\nD00060   DS    0H\n         NI    @D_SMS_Ptrs_OK,X'FF'-L'@D_SMS_Ptrs_OK No SMS data yet\n\n*---------------------------------------------------------------------*\n*     We have a UCB address, so check it out. First, it must be       *\n*    ONLINE ...                                                       *\n*---------------------------------------------------------------------*\n         TM    @D_UCB+UCBSTAT-UCBOB,UCBONLI Online?\n         JNO   D00480                   No, go get next UCB\n\n*---------------------------------------------------------------------*\n*     ... and then match our UNIT address, if applicable ...          *\n*---------------------------------------------------------------------*\n         MVO   @D_DBLWD+5(3),@D_UCB+UCBCHAN-UCBOB(L'UCBCHAN)\n         OI    @D_DBLWD+7,X'0F'         Add a sign\n         UNPK  @D_DBLWD(5),@D_DBLWD+5(3) Unpack it\n         TR    @D_DBLWD+1(4),D_TRTAB     Make it readable\n         MVC   @D_UCBNAME,@D_DBLWD+1    Save it\n\n         ICM   R1,B'1111',@_UCB_List_Ptr A(UCB List)\n         JZ    D00080                   None, skip\n         L     R3,UCB_List_Hdr_Count-UCB_List_Hdr(R1) Get nbr entries\n         AHI   R1,UCB_List_Ent-UCB_List   and point to 1st\nD00070   DS    0H\n         MVC   @D_DBLWD(L'@D_UCBName),@D_UCBName Move UCB to temp area\n         OC    @D_DBLWD(L'@D_UCBName),UCB_List_Ent_Mask-UCB_List_Ent(R1+\n               )                        Wildcard positions = x'FF'\n         CLC   @D_DBLWD(L'@D_UCBName),UCB_List_Ent_UCB-UCB_List_Ent(R1)\n         JE    D00080                   We want it, skip\n         AHI   R1,UCB_List_Ent_Length   Bump to next entry\n         BRCT  R3,D00070                and try again\n         J     D00480                   Not here, skip this UCB\nD00080   DS    0H\n         OI    @D_Eligible_UCB_Found,L'@D_Eligible_UCB_Found\n         ICM   R1,B'1111',@_XUCB_List_Ptr A(XUCB List)\n         JZ    D00100                   None, skip\n         L     R3,UCB_List_Hdr_Count-UCB_List_Hdr(R1) Get nbr entries\n         AHI   R1,UCB_List_Ent-UCB_List     and point to 1st\nD00090   DS    0H\n         MVC   @D_DBLWD(L'@D_UCBName),@D_UCBName Move UCB to temp area\n         OC    @D_DBLWD(L'@D_UCBName),UCB_List_Ent_Mask-UCB_List_Ent(R1+\n               )                        Wildcard positions = x'FF'\n         CLC   @D_DBLWD(L'@D_UCBName),UCB_List_Ent_UCB-UCB_List_Ent(R1)\n         JE    D00480                   Exclude it, skip\n         AHI   R1,UCB_List_Ent_Length   Bump to next entry\n         BRCT  R3,D00090                and try again\n\nD00100   DS    0H\n*---------------------------------------------------------------------*\n*     ... and our VOLSER criteria, if applicable ...                  *\n*---------------------------------------------------------------------*\n         ICM   R1,B'1111',@_VOL_List_Ptr A(VOL List)\n         JZ    D00130                   None, skip\n         L     R3,Vol_List_Hdr_Count-Vol_List_Hdr(R1) Get nbr entries\n         AHI   R1,Vol_List_Ent-Vol_List     and point to 1st\nD00120   DS    0H\n         MVC   @D_DBLWD(L'UCBVOLI),@D_UCB+UCBVOLI-UCBOB Move Volser\n         OC    @D_DBLWD(L'UCBVOLI),Vol_List_Ent_Mask-Vol_List_Ent(R1)\n         CLC   @D_DBLWD(L'UCBVOLI),Vol_List_Ent_Vol-Vol_List_Ent(R1)\n         JE    D00130                   We want it, skip\n         AHI   R1,Vol_List_Ent_Length   Bump to next entry\n         BRCT  R3,D00120                and try again\n         J     D00480                   Not here, skip this UCB\nD00130   DS    0H\n         ICM   R1,B'1111',@_XVOL_List_Ptr A(XVOL List)\n         JZ    D00150                   None, skip\n         L     R3,Vol_List_Hdr_Count-Vol_List_Hdr(R1) Get nbr entries\n         AHI   R1,Vol_List_Ent-Vol_List     and point to 1st\nD00140   DS    0H\n         MVC   @D_DBLWD(L'UCBVOLI),@D_UCB+UCBVOLI-UCBOB Move Volser\n         OC    @D_DBLWD(L'UCBVOLI),Vol_List_Ent_Mask-Vol_List_Ent(R1)\n         CLC   @D_DBLWD(L'UCBVOLI),Vol_List_Ent_Vol-Vol_List_Ent(R1)\n         JE    D00480                   Exclude it, skip\n         AHI   R1,Vol_List_Ent_Length   Bump to next entry\n         BRCT  R3,D00140                and try again\n\nD00150   DS    0H\n*---------------------------------------------------------------------*\n*     ... our esoteric name criteria, if applicable ...               *\n*---------------------------------------------------------------------*\n         ICM   R14,B'1111',@D_UNITA     Get A(Unit Table)\n         JZ    D00170                   None, skip\n         ICM   R15,B'1111',4(R14)       Get nbr devices\n         JZ    D00480                   None, skip this UCB\n         AHI   R14,8                    Yes, point to first\n\nD00160   DS    0H\n         CLC   @D_DBLWD+1(4),0(R14)     Is this us?\n         JE    D00170                   Yes, use it\n         AHI   R14,4                    No, point to next in Unit Tbl\n         BRCT  R15,D00160               and check it\n         J     D00480                   Skip this UCB\n\nD00170   DS    0H\n*---------------------------------------------------------------------*\n*     ... and our Mount Attributes, if applicable ...                 *\n*---------------------------------------------------------------------*\n         TM    @_ATTRSMS,L'@_ATTRSMS    Selecting SMS vols?\n         JZ    D00180                   No, skip\n         TM    @D_UCB+UCBFL5-UCBOB,UCBSMS SMS?\n         JZ    D00480                   No, skip\n         J     D00210                   OK, use this vol\nD00180   DS    0H\n         TM    @_ATTRPvt,L'@_ATTRPvt    Selecting PRIVATE vols?\n         JZ    D00190                   No, skip\n         TM    @D_UCB+UCBSTAB-UCBOB,UCBBPRV PRIVATE?\n         JZ    D00480                   No, skip\n         TM    @D_UCB+UCBFL5-UCBOB,UCBSMS SMS?\n         JO    D00480                   Yes, skip\n         J     D00210                   OK, use this vol\nD00190   DS    0H\n         TM    @_ATTRPub,L'@_ATTRPub    Selecting PUBLIC vols?\n         JZ    D00200                   No, skip\n         TM    @D_UCB+UCBSTAB-UCBOB,UCBBPUB PUBLIC?\n         JZ    D00480                   No, skip\n         TM    @D_UCB+UCBFL5-UCBOB,UCBSMS SMS?\n         JO    D00480                   Yes, skip\n         J     D00210                   OK, use this vol\nD00200   DS    0H\n         TM    @_ATTRStg,L'@_ATTRStg    Selecting STORAGE vols?\n         JZ    D00210                   No, use this vol\n         TM    @D_UCB+UCBSTAB-UCBOB,UCBBSTR Storage?\n         JZ    D00480                   No, skip this vol\n         TM    @D_UCB+UCBFL5-UCBOB,UCBSMS SMS?\n         JO    D00480                   Yes, skip\n\nD00210   DS    0H\n*---------------------------------------------------------------------*\n*     ... and our STORGRP criteria, if applicable.                    *\n*---------------------------------------------------------------------*\n         ICM   R1,B'1111',@_STORGRP_List_Ptr A(STORGRP List)\n         JZ    D00240                   None, STORGRP not a criterion\n\n         TM    @D_UCB+UCBFL5-UCBOB,UCBSMS SMS?\n         JZ    D00480                   No, skip this volume\n\n         TM    @D_SMS_Unavail,L'@D_SMS_Unavail Is SMS there?\n         JO    D00480                  No, skip\n\n         LA    R15,@D_UCB+UCBVOLI-UCBOB A(Volser)\n         ST    R15,@D_Parms_T00010     Save it\n         LA    R15,@D_VLD_Anchor       A(VLD Anchor)\n         ST    R15,@D_Parms_T00010+4   Save it\n\n         LA    R1,@D_Parms             A(Parm list)\n         BRAS  R14,T00010              Go get Storgrp, status\n\n         STM   R0,R1,@D_SMS_Ptrs       Save the results\n         CHI   R15,4                   How did it go?\n         JL    D00220                  OK, skip\n         JE    D00480                  STORGRP not found, skip this vol\n         OI    @D_SMS_Unavail,L'@D_SMS_Unavail No SMS, set flag\n         J     D00480                  and skip this vol\n\nD00220   DS    0H\n         OI    @D_SMS_Ptrs_OK,L'@D_SMS_Ptrs_OK  We have SMS data\n\n         L     R15,@D_SMS_Ptrs+4        A(STORGRP Len, STORGRP)\n         L     R1,@_STORGRP_List_Ptr    A(STORGRP criterion)\n         L     R3,STORGRP_List_Hdr_Count-STORGRP_List_Hdr(R1) Get nbr\n         AHI   R1,STORGRP_List_Ent-STORGRP_List     and point to 1st\nD00230   DS    0H\n         MVC   @D_SMS_Temp_StorGrp,2(R15) Move STORGRP\n         OC    @D_SMS_Temp_StorGrp,STORGRP_List_Ent_Mask-STORGRP_List_E+\n               nt(R1)                   Reset wildcards\n         CLC   @D_SMS_Temp_StorGrp,STORGRP_List_Ent_STORGRP-STORGRP_Lis+\n               t_Ent(R1)                Our Storage group?\n         JE    D00240                   We want it, skip\n         AHI   R1,STORGRP_List_Ent_Length Bump to next entry\n         BRCT  R3,D00230                and try again\n         J     D00480                   Not here, skip this UCB\n\nD00240   DS    0H\n*---------------------------------------------------------------------*\n*     This seems to be a volume in which we are interested. Bump the  *\n*    count of volumes eligible to be included in the table ...        *\n*---------------------------------------------------------------------*\n         L     R15,@D_Volume_Count      Get current count\n         AHI   R15,1                    Bump it\n         ST    R15,@D_Volume_Count      Save it\n\n*---------------------------------------------------------------------*\n*     ... get a pointer to the next free entry in our table, ...      *\n*---------------------------------------------------------------------*\n         LA    R1,@D_Parms              A(Parm list)\n         BRAS  R14,W00010               Get A(Next entry in VolTbl)\n         LTR   R15,R15                  Did we get one?\n         JNZ   D00480                   No, don't update it then\n\n*---------------------------------------------------------------------*\n*     ... bump the count of vol entries in the table ...              *\n*---------------------------------------------------------------------*\n         ICM   R15,B'1111',@_VolTbl_Ptr A(VolTbl)\n         JZ    D00480                   Nothing, skip\n         L     R0,VolTbl_Hdr_Vols_Total-VolTbl_Hdr(R15) Get curr count\n         AHI   R0,1                     Bump it\n         ST    R0,VolTbl_Hdr_Vols_Total-VolTbl_Hdr(R15) Save it\n\n*---------------------------------------------------------------------*\n*     ... add this UCB to our table, and format some info about it.   *\n*---------------------------------------------------------------------*\n         LR    R9,R1                    Get A(Free entry)\n         USING VolTbl_Ent,R9\n\n         OI    VolTbl_Ent_Detail_Line,L'VolTbl_Ent_Detail_Line\n         MVC   VolTbl_Ent_UCBCopy,@D_UCB Move UCB Copy\n         MVC   VolTbl_Ent_DCECopy,@D_DCE Move DCE Copy\n\n*---------------------------------------------------------------------*\n*     If we will be displaying detail lines, format what we           *\n*    currently have available                                         *\n*---------------------------------------------------------------------*\n         TM    @_No_Details,L'@_No_Details Producing detail lines?\n         JO    D00470                    No, skip the formatting stuff\n\n         MVC   VolTbl_Ent_DevAddr,@D_UCBNAME Readable device address\n         MVC   VolTbl_Ent_DevType,=CL8' ' Clear device type\n\n*---------------------------------------------------------------------*\n*   Format the device type and model, using SYS1.$UCLEUS(IECDI$IT@, *\n*    CSECT IECDDE)T.                                                  *\n*     This is an undocumented CSECT, but its format seems to be:      *\n*      DS    XL1        DCEOBRDT/UCBTBYT4                             *\n*        DS    XL1        ??                                          *\n*        DS    CL8        Device Type in EBCDIC                       *\n*                                                                     *\n*    There are generic device entries (i.e 3380, 3390@, where the 1st *\n*    byte matches UCBTBYT4, and specific entries (i.e. 3380K. 33909@  *\n*    where the 1st byte matches DCEOBRDT. We try to identify emulated *\n*    devices by finding entries matching both UCBTBYT4 and DCEOBRDT;  *\n*    if the non-blank portion of the UCBTBYT4 entry does not match the*\n*    DCEOBRDT entry, we assume we have an emulated device, and use    *\n*    the UCBTBYT4 device type, suffixed with \"*E*\".                   *\n*                                                                     *\n*     If we use the DCEOBRDT entry, we format it, if required, by     *\n*    inserting, if required, a dash(-@ after the 4th character if     *\n*    there is at least 1 trailing blank.                              * *\n*---------------------------------------------------------------------*\n         ICM   R1,B'1111',@D_IECDDEVT_Ptr A(IECDDEVT)?\n         JZ    D00240C                   Not yet, skip\n\n*---------------------------------------------------------------------*\n*    If this device is the same as the previous one in the table,     *\n*    merely copy the device type                                      *\n*---------------------------------------------------------------------*\n         LA    R15,VolTbl_Ent            A(Our entry)\n         AHI   R15,-VolTbl_Ent_Len       A(Previous entry)\n         CLC   VolTbl_Ent_UCBCopy+UCBTBYT4-UCBOB(L'UCBTBYT4),VolTbl_Ent+\n               _UCBCopy+UCBTBYT4-UCBOB-VolTbl_Ent(R15)\n         JNE   D00250                    Not same, check IECDDEVT\n         CLC   VolTbl_Ent_DCECopy+DCEOBRDT-DCE(L'DCEOBRDT),VolTbl_Ent_D+\n               CECopy+DCEOBRDT-DCE-VolTbl_Ent(R15)\n         JNE   D00250                    Not same, check IECDDEVT\n         MVC   VolTbl_Ent_DevType,VolTbl_Ent_DevType-VolTbl_Ent(R15)\n         J     D00280                    and skip\nD00240C  DS    0H\n         NUCLKUP BYNAME,                 Not yet, look it up           +\n               NAME='IECDDEVT',           this CSECT                   +\n               ADDR=(0)                   return address here\n         LTR   R15,R15                   Did we get it?\n         JZ    D00240E                   Yes, OK\n         LA    R0,1                      No, set invalid address\nD00240E  DS    0H\n         ST    R0,@D_IECDDEVT_Ptr        Yes, save the address\n         LR    R1,R0                     and load up\nD00250   DS    0H\n         TM    @D_IECDDEVT_Ptr+3,X'01'   Is it a valid address?\n         JO    D00280                    No, skip device type\n         SLR   R14,R14                   Clear A(UCBTBYT4 entry)\n         SLR   R15,R15                   Clear A(DCEOBRDT entry)\nD00250A  DS    0H\n         CLI   0(R1),X'00'               End of table?\n         JE    D00280                    Yes, no device type\n         LTR   R14,R14                   Found UCBTBYT4 already?\n         JNZ   D00250C                   Yes, skip\n         CLC   0(L'UCBTBYT4,R1),VolTbl_Ent_UCBCopy+UCBTBYT4-UCBOB Us?\n         JNE   D00250C                   No, skip\n         LA    R14,2(0,R1)               Yes, save the address\n         J     D00250E                   and skip\nD00250C  DS    0H\n         LTR   R15,R15                   Found DCEOBRDT entry?\n         JNZ   D00250E                   Yes, skip\n         CLC   0(L'DCEOBRDT,R1),VolTbl_Ent_DCECopy+DCEOBRDT-DCE Us?\n         JNE   D00250E                   No, skip\n         LA    R15,2(0,R1)               Yes, save the address\nD00250E  DS    0H\n         LTR   R14,R14                   Found UCBTBYT4 entry?\n         JZ    D00250G                   No, keep checking\n         LTR   R15,R15                   Yes, got DCEOBRDT entry too?\n         JNZ   D00260                    Yes, all done\nD00250G  DS    0H\n         AHI   R1,10                     A(Next entry)\n         J     D00250A                   and check it out\nD00260   DS    0H\n         LA    R1,7(0,R14)               A(End of UCBTBYT4 entry\nD00260C  DS    0H\n         CLI   0(R1),C' '                End of device type?\n         JNE   D00260E                   Yes, skip\n         AHI   R1,-1                     No, back up a byte\n         J     D00260C                   and keep checking\nD00260E  DS    0H\n         SR    R1,R14                    EX length of compare\n         EX    R1,D_CLC                  Compare entries\n         JE    D00260G                   Equal, use DCEOBRDT\n         MVC   VolTbl_Ent_DevType,0(R14) Move UCBTBYT4 device type\n         CLC   VolTbl_Ent_DevType+L'VolTbl_Ent_DevType-3(3),=CL8' '\n         JNE   D00280                    No room for flag, skip\n         LA    R1,VolTbl_Ent_DevType(R1) Point to last char\n         MVC   1(3,R1),=C'*E*'           Say it's emulated\n         J     D00280                    and skip\n\nD00260G  DS    0H\n         MVC   VolTbl_Ent_DevType,0(R15) Move DCEOBRDT device type\n         CLI   VolTbl_Ent_DevType+4,C' ' 4-char dev type?\n         JE    D00280                    Yes, all done\n         CLI   VolTbl_Ent_DevType+4,C'-' Already formatted?\n         JE    D00280                    Yes, all done\n         CLI   VolTbl_Ent_DevType+L'VolTbl_Ent_DevType-1,C' ' Trail sp?\n         JNE   D00280                    No, skip formatting\n         MVC   VolTbl_Ent_DevType+5(L'VolTbl_Ent_DevType-5),4(R15)\n*                                        Make room for a dash\n         MVI   VolTbl_Ent_DevType+4,C'-' and insert it\n\n\nD00280   DS    0H\n*---------------------------------------------------------------------*\n*     Format the Volser, and the Mount attribute ...                  *\n*---------------------------------------------------------------------*\n         MVC   VolTbl_Ent_Volser,VolTbl_Ent_UCBCOPY+UCBVOLI-UCBOB\n\n         TM    VolTbl_Ent_UCBCOPY+UCBFL5-UCBOB,UCBSMS SMS?\n         JZ    D00290                    Not SMS, skip\n         MVC   VolTbl_Ent_Attrib,=C'SMS' Say so\n         J     D00320                    and skip\n\nD00290   DS    0H\n         TM    VolTbl_Ent_UCBCOPY+UCBSTAB-UCBOB,UCBBPRV Private?\n         JZ    D00300                    No, skip\n         MVC   VolTbl_Ent_Attrib,=C'Pvt' Yes, say so\n         J     D00320                    and skip\nD00300   DS    0H\n         TM    VolTbl_Ent_UCBCopy+UCBSTAB-UCBOB,UCBBPUB Public?\n         JZ    D00310                    No, skip\n         MVC   VolTbl_Ent_Attrib,=C'Pub' Yes, say so\n         J     D00320                    and skip\nD00310   DS    0H\n         MVC   VolTbl_Ent_Attrib,=C'Stg' Indicate Storage\nD00320   DS    0H\n*---------------------------------------------------------------------*\n*     Get the CHPIDs for this device using UCBINFO PATHINFO ...       *\n*---------------------------------------------------------------------*\n         LA    R1,VolTbl_Ent_CHPIDs     A(Output area)\n         LHI   R15,8                    Max nbr we can use\nD00320C  DS    0H\n         MVC   0(2,R1),=C'--'           Init CHPID value\n         AHI   R1,4                     Bump pointer\n         BRCT  R15,D00320C              and do them all\n\n         UCBINFO PATHINFO,              Get path info                  +\n               DEVN=VolTbl_Ent_UCBCOPY+UCBCHAN-UCBOB, for this device  +\n               PATHAREA=@D_UCBINFO_Data, in here                       +\n               MF=(E,@D_UCBINFO)        staying re-entrant\n\n         LTR   R15,R15                  Anything good happen?\n         JNZ   D00370                   No, skip\n\n*---------------------------------------------------------------------*\n*     ... and format them, flagging those that are unavailable        *\n*---------------------------------------------------------------------*\n         LA    R15,@D_UCBINFO_Data      Address of PATHINFO data\n         L     R14,@D_UCBINFO_Data+PATH#CHPIDS-PATH Nbr CHPIDS\n         CHI   R14,8                    Too many?\n         JNH   D00330                   No, OK\n         LHI   R14,8                    Yes, only use 1st 8\nD00330   DS    0H\n         LA    R15,@D_UCBINFO_Data+PATHCHPIDARRAY-PATH A(1st CHP entry)\n         LA    R1,VolTbl_Ent_CHPIDs     A(Output area)\nD00340   DS    0H\n         LH    R0,PATHCHPID-PATHCHPIDARRAY(R15) Get CHPID\n         SLL   R0,4                     Make room for sign\n         ST    R0,@D_DBLWD+4            Save it\n         OI    @D_DBLWD+7,X'0F'         Add a sign\n         UNPK  @D_DBLWD(3),@D_DBLWD+6(2) Unpack it\n         TR    @D_DBLWD+1(2),D_TRTAB     Make it readable\n         MVC   0(2,R1),@D_DBLWD+1       Move CHPID\n         TM    PATHBITS-PATHCHPIDARRAY(R15),PATHPAM  Physically avail?\n         JO    D00350                   Yes, skip\n         MVI   2(R1),C'$'               No, mark it\n         OI    @D_CHPID_Unavail,L'@D_CHPID_Unavail and set our flag\n         J     D00360                   Skip\nD00350   DS    0H\n         TM    PATHBITS-PATHCHPIDARRAY(R15),PATHLPM  Logically avail?\n         JO    D00360                   Yes, skip\n         MVI   2(R1),C'-'               No, mark it\n         OI    @D_CHPID_Unavail,L'@D_CHPID_Unavail and set our flag\n         J     D00360                   Skip\nD00360   DS    0H\n         AHI   R1,4                     Bump pointer\n         AHI   R15,L'PATHCHPIDARRAY     Point to next CHPID\n         BRCT  R14,D00340               and try again\n\nD00370   DS    0H\n*---------------------------------------------------------------------*\n*     If this is an SMS UCB, set up the Storage Group Name and SMS    *\n*    status.                                                          *\n*---------------------------------------------------------------------*\n         TM    VolTbl_Ent_UCBCopy+UCBFL5-UCBOB,UCBSMS SMS?\n         JNO   D00460                  No, skip\n\n         TM    @D_SMS_Ptrs_OK,L'@D_SMS_Ptrs_OK Do we already have it?\n         JO    D00380                  Yes, skip\n\n         TM    @D_SMS_Unavail,L'@D_SMS_Unavail Is SMS there?\n         JO    D00460                  No, skip\n\n         LA    R15,VolTbl_Ent_Volser   A(Volser)\n         ST    R15,@D_Parms_T00010     Save it\n         LA    R15,@D_VLD_Anchor       A(VLD Anchor)\n         ST    R15,@D_Parms_T00010+4   Save it\n\n         LA    R1,@D_Parms              A(Parm list)\n         BRAS  R14,T00010              Go get Storgrp, status\n\n         STM   R0,R1,@D_SMS_Ptrs       Save the results\n         CHI   R15,4                   How did it go?\n         JL    D00380                  OK, skip\n         JE    D00460                  STORGRP not found, skip this vol\n         OI    @D_SMS_Unavail,L'@D_SMS_Unavail No SMS, set flag\n         J     D00460                  and skip this vol\n\nD00380   DS    0H\n         L     R15,@D_SMS_Ptrs+4             A(STORGRP Len, name)\n         LH    R14,0(0,R15)                  Get len of STORGRP\n         LHI   R0,L'VolTbl_Ent_SMS_StorGrp   Len of output field\n         CR    R14,R0                        Too big?\n         JNH   D00390                        No, OK\n         LR    R14,R0                        Yes, reset it\nD00390   DS    0H\n         AHI   R14,-1                        EX Length\n         AHI   R15,2                         A(STORGRP)\n         LA    R1,VolTbl_Ent_SMS_StorGrp     A(Target field)\n         EX    R14,D_MVC\n\n         ICM   R15,B'1111',@D_SMS_Ptrs       A(SMS Status)\n         JZ    D00450                        None, we don't know\n\n         CLI   0(R15),VLD0                   Any status?\n         JNE   D00400                        No, skip\n         MVC   VolTbl_Ent_SMS_Status,=CL(L'VolTbl_Ent_SMS_Status)'None'\n         J     D00470                        and skip\nD00400   DS    0H\n         CLI   0(R15),VLDENBL                Enabled?\n         JNE   D00410                        No, skip\n         MVC   VolTbl_Ent_SMS_Status,=CL(L'VolTbl_Ent_SMS_Status)'Enabl+\n               ed'\n         J     D00470                        and skip\nD00410   DS    0H\n         CLI   0(R15),VLDQUI                 Quiesced/All?\n         JNE   D00420                        No, skip\n         MVC   VolTbl_Ent_SMS_Status,=CL(L'VolTbl_Ent_SMS_Status)'Quies+\n               ced/All'\n         J     D00470                        and skip\nD00420   DS    0H\n         CLI   0(R15),VLDQUIN                Quiesced/New?\n         JNE   D00430                        No, skip\n         MVC   VolTbl_Ent_SMS_Status,=CL(L'VolTbl_Ent_SMS_Status)'Quies+\n               ced/New'\n         J     D00470                        and skip\nD00430   DS    0H\n         CLI   0(R15),VLDDIS                 Disabled/All?\n         JNE   D00440                        No, skip\n         MVC   VolTbl_Ent_SMS_Status,=CL(L'VolTbl_Ent_SMS_Status)'Disab+\n               led/All'\n         J     D00470                        and skip\nD00440   DS    0H\n         CLI   0(R15),VLDDISN                Disabled/New?\n         JNE   D00450                        No, skip\n         MVC   VolTbl_Ent_SMS_Status,=CL(L'VolTbl_Ent_SMS_Status)'Disab+\n               led/New'\n         J     D00470                        and skip\nD00450   DS    0H\n         MVC   VolTbl_Ent_SMS_Status,=CL(L'VolTbl_Ent_SMS_Status)'Unkno+\n               wn'\n         J     D00470                        and skip\nD00460   DS    0H\n         MVC   VolTbl_Ent_SMS_StorGrp(3),=C'N/A' Move literal\n         MVC   VolTbl_Ent_SMS_Status(3),=C'N/A' and again\n         J     D00470                        and skip\n\nD00470   DS    0H\n*---------------------------------------------------------------------*\n*     If we are not going to be doing LSPACEs, mark this entry as     *\n*    complete ...                                                     *\n*---------------------------------------------------------------------*\n         TM    @_No_LSPACE,L'@_No_LSPACE     Doing LSPACE?\n         JNO   D00480                        Yes, skip\n         OI    VolTbl_Ent_Processed,L'VolTbl_Ent_Processed\n         OI    VolTbl_Ent_ECB,X'40'          'POST' as complete\n\nD00480   DS    0H\n*---------------------------------------------------------------------*\n*     ... and go get the next UCB, unless we are doing a single       *\n*    volser                                                           *\n*---------------------------------------------------------------------*\n         TM    @D_Single_Volser,L'@D_Single_Volser  Specific volser?\n         JO    D00490                   Yes, no need to keep checking\n         J     D00050                   No, do next UCB\n\nD00490   DS    0H\n*---------------------------------------------------------------------*\n*     Check to see if we found any UCBs                               *\n*---------------------------------------------------------------------*\n         ICM   R0,B'1111',@D_Volume_Count Any UCBs?\n         JNZ   D00540                   Yes, skip\n\n*---------------------------------------------------------------------*\n*   We couldn't find any UCBs - if we are selecting by UCB number,    *\n*  the user may have assumed a 3-byte UCB address, and we have been   *\n*  looking for 4-byte addresses. If this is the case, we add a '0'    *\n*  in front of the UCB address, and do all this again. We limit the   *\n*  re-iterations based on the entered UCB mask(s) - for example, we   *\n*  will reiterate for UCB(x??), but not for UCB(x???).                *\n*                                                                     *\n*   We assume (big mistake!) that the user has been consistent in     *\n*  specifying 3-digit UCBs in both UCB and XUCB - when we adjust an   *\n*  entry in UCB_List, if there is a subset of it in XUCB_List, we     *\n*  adjust it too.                                                     *\n*---------------------------------------------------------------------*\n         TM    @D_Eligible_UCB_Found,L'@D_Eligible_UCB_Found Any UCBs?\n         JO    D00540                   Yes, skip\n         ICM   R1,B'1111',@_UCB_List_Ptr A(UCB selection list)\n         JZ    D00540                   None, skip\n         NI    @D_UCB_Addr_Updated,X'FF'-L'@D_UCB_Addr_Updated\n\n         ICM   R3,B'1111',UCB_List_Hdr_Count-UCB_List_Hdr(R1)  Nbr UCBs\n         JZ    D00540                   None, skip\n         AHI   R1,UCB_List_Ent-UCB_List  Point to 1st\nD00500   DS    0H\n         CLI   UCB_List_Ent_UCB+L'UCB_List_Ent_UCB-1-UCB_List_Ent(R1),X+\n               'FF'                     Trailing wildcard?\n         JNE   D00530                   No, skip\n         CLI   UCB_List_Ent_UCB_Len-UCB_List_Ent(R1),L'@D_UCBNAME Adj?\n         JNL   D00530                   No, skip\n         LA    R0,0                     Yes, clear work reg\n         IC    R0,UCB_List_Ent_UCB_Len-UCB_List_Ent(R1) Entered len\n         AHI   R0,1                     Bump it\n         STC   R0,UCB_List_Ent_UCB_Len-UCB_List_Ent(R1) Entered len\n         L     R0,UCB_List_Ent_UCB-UCB_List_Ent(R1) Get the UCB\n         ST    R0,@D_DBLWD              Save it\n         SRL   R0,8                     Shift over 1 byte\n         ST    R0,UCB_List_Ent_UCB-UCB_List_Ent(R1) Save it\n         MVI   UCB_List_Ent_UCB-UCB_List_Ent(R1),C'0'  Leading 0\n         L     R0,UCB_List_Ent_Mask-UCB_List_Ent(R1) Get wildcard mask\n         SRL   R0,8                     Shift it right too\n         ST    R0,UCB_List_Ent_Mask-UCB_List_Ent(R1) Save it as well\n         OI    @D_UCB_Addr_Updated,L'@D_UCB_Addr_Updated UCB changed\n         ICM   R4,B'1111',@_XUCB_List_Ptr A(Excluded UCBs)\n         JZ    D00530                   None, skip\n\n         L     R5,UCB_List_Hdr_Count-UCB_List_Hdr(R4)  Count of UCBs\n         AHI   R4,UCB_List_Ent-UCB_List  Point to 1st\nD00510   DS    0H\n         CLI   UCB_List_Ent_UCB+L'UCB_List_Ent_UCB-1-UCB_List_Ent(R4),X+\n               'FF'                     Trailing wildcard?\n         JNE   D00520                   No, skip\n         CLI   UCB_List_Ent_UCB_Len-UCB_List_Ent(R4),L'@D_UCBNAME Adj?\n         JNL   D00520                   No, skip\n         LA    R0,0                     Yes, clear work reg\n         IC    R0,UCB_List_Ent_UCB_Len-UCB_List_Ent(R4) Entered len\n         AHI   R0,1                     Bump it\n         STC   R0,UCB_List_Ent_UCB_Len-UCB_List_Ent(R4) Entered len\n         L     R0,UCB_List_Ent_UCB-UCB_List_Ent(R4) Yes, get UCB\n         ST    R0,@D_DBLWD+4            Save it\n         OC    @D_DBLWD+4(L'UCB_List_Ent_UCB),UCB_List_Ent_Mask-UCB_Lis+\n               t_Ent(R1)                Reset wildcard characters\n         CLC   @D_DBLWD(L'UCB_List_Ent_UCB),@D_DBLWD+4  Subset of Incl?\n         JNE   D00520                   No, skip\n         SRL   R0,8                     Shift over 1 byte\n         ST    R0,UCB_List_Ent_UCB-UCB_List_Ent(R4) Save it\n         MVI   UCB_List_Ent_UCB-UCB_List_Ent(R4),C'0'  Leading 0\n         L     R0,UCB_List_Ent_Mask-UCB_List_Ent(R4) Get wildcard mask\n         SRL   R0,8                     Shift it right too\n         ST    R0,UCB_List_Ent_Mask-UCB_List_Ent(R4) Save it as well\n\nD00520   DS    0H\n         AHI   R4,UCB_List_Ent_Length   Bump to next entry\n         BRCT  R5,D00510                and process it\n\nD00530   DS    0H\n         AHI   R1,UCB_List_Ent_Length   Bump to next entry\n         BRCT  R3,D00500                and process it\n\n         TM    @D_UCB_Addr_Updated,L'@D_UCB_Addr_Updated Any changes?\n         JO    D00040                   Yes, try again\n\nD00540   DS    0H\n*---------------------------------------------------------------------*\n*     We have finished all our UCBs; update the total eligible vol    *\n*    count, and, if no entries, flag it as complete ...               *\n*---------------------------------------------------------------------*\n         ICM   R15,B'1111',@_VolTbl_Ptr A(VolTbl)\n         JZ    D00800                   Nothing, skip\n         L     R0,@D_Volume_Count       Total eligible volumes\n         ST    R0,VolTbl_Hdr_Vols_Eligible-VolTbl_Hdr(R15)\n\n         ICM   R0,B'1111',VolTbl_Hdr_Vols_Total-VolTbl_Hdr(R15) Any?\n         JZ    D00790                   No, POST table as complete\n\n*---------------------------------------------------------------------*\n*     ... and, if we are doing totals, create and populate (as much   *\n*    as we can) the Totals line ...                                   *\n*---------------------------------------------------------------------*\n         TM    @_No_Totals,L'@_No_Totals Doing Totals?\n         JO    D00590                   No, skip\n\n         LA    R1,@D_Parms              A(Parm list)\n         BRAS  R14,W00010               A(Next free entry)\n         LTR   R15,R15                  Did we get one?\n         JNZ   D00590                   No, skip\n         LR    R9,R1                    Yes, point to it\n\n         L     R15,@_VolTbl_Ptr          A(VolTbl)\n         SR    R1,R15                    Offset of Totals Line\n         ST    R1,VolTbl_Hdr_Total_Off-VolTbl_Hdr(R15) Save it\n\n         OI    VolTbl_Ent_Total_Line,L'VolTbl_Ent_Total_Line\n         L     R15,@_VolTbl_Ptr          A(VolTbl)\n         L     R0,VolTbl_Hdr_Vols_Total-VolTbl_Hdr(R15) Nbr vols\n         CVD   R0,@D_DBLWD               Pack it\n         MVC   VolTbl_Ent_DevType(7),=X'4020206B202120' Move mask\n         ED    VolTbl_Ent_DevType(7),@D_DBLWD+5 Edit in count\n\n         ICM   R1,B'1111',@_XVol_List_Ptr Excluding by vol?\n         JNZ   D00550                   Yes, leave volser blank\n         ICM   R1,B'1111',@_Vol_List_Ptr No, selecting by vol?\n         JZ    D00550                   No, set vol to asterisks\n         CLC   =FL4'1',4(R1)            Yes, a single volser?\n         JNE   D00550                   No, leave volser blank\n         MVC   VolTbl_Ent_Volser,8(R1)  Yes, move volser mask\n         TR    VolTbl_Ent_Volser,D_TrTbl and Xlate X'FF' to '*'\n         J     D00550                   and skip\n\nD00550   DS    0H\n         ICM   R1,B'1111',@_XUCB_List_Ptr Excluding by UCB?\n         JNZ   D00560                   Yes, leave UCB blank\n         ICM   R1,B'1111',@_UCB_List_Ptr No, selecting by UCB?\n         JZ    D00560                   No, set UCB to asterisks\n         L     R0,UCB_List_Hdr_Count-UCB_List_Hdr(R1)  Get Nbr masks\n         C     R0,=FL4'1'               A single UCB?\n         JNE   D00560                   No, leave UCB blank\n         AHI   R1,UCB_List_Ent-UCB_List Yes, point to it\n         MVC   VolTbl_Ent_DevAddr,UCB_List_Ent_UCB-UCB_List_Ent(R1)\n         TR    VolTbl_Ent_DevAddr,D_TrTbl and Xlate X'FF' to '*'\n         J     D00560                   and skip\n\nD00560   DS    0H\n         MVC   VolTbl_Ent_Attrib,=CL8' ' No attributes\n\n         ICM   R1,B'1111',@_STORGRP_List_Ptr Selecting by StorGrp?\n         JZ    D00570                   No, skip\n         CLC   =FL4'1',4(R1)            Yes, a single STORGRP?\n         JNE   D00570                   No, leave blank\n         MVC   VolTbl_Ent_SMS_StorGrp,8(R1) Yes, move mask\n         TR    VolTbl_Ent_SMS_StorGrp,D_TrTbl and Xlate X'FF' to '*'\n         J     D00570                   and skip\n\nD00570   DS    0H\n*---------------------------------------------------------------------*\n*     If a CHPID was not physically or logically available, put out   *\n*    a message in the CHPID area of the totals line.                  *\n*---------------------------------------------------------------------*\n         TM    @D_CHPID_Unavail,L'@D_CHPID_Unavail  CHPIDs OK?\n         JNO   D00580                   Yes, OK\n         MVC   VolTbl_Ent_CHPIDs(L'D_CHPID_Msg),D_CHPID_Msg No, msg\n\nD00580   DS    0H\n*---------------------------------------------------------------------*\n*     If we will not be doing LSPACEs, mark the Totals line as        *\n*    complete                                                         *\n*---------------------------------------------------------------------*\n         TM    @_No_LSPACE,L'@_No_LSPACE Doing LSPACEs?\n         JNO   D00590                   Yes, OK\n         OI    VolTbl_Ent_Processed,L'VolTbl_Ent_Processed\n         OI    VolTbl_Ent_ECB,X'40'     and POST as complete\n\nD00590   DS    0H\n*---------------------------------------------------------------------*\n*     If we will be doing LSPACEs, get a line for the SMS Anomaly     *\n*    message                                                          *\n*---------------------------------------------------------------------*\n         TM    @_No_LSPACE,L'@_No_LSPACE  Doing LSPACE?\n         JO    D00600                   No, skip\n\n         LA    R1,@D_Parms              A(Parm list)\n         BRAS  R14,W00010               A(Next entry in VolTbl)\n         LTR   R15,R15                  Did we get one?\n         JNZ   D00600                   No, skip\n         LR    R9,R1                    Yes, point to it\n\n         L     R15,@_VolTbl_Ptr          A(VolTbl)\n         SR    R1,R15                    Offset of SMS Anomaly Line\n         ST    R1,VolTbl_Hdr_SMS_Off-VolTbl_Hdr(R15) Clear offset\n\n         OI    VolTbl_Ent_Detail_Line,L'VolTbl_Ent_Detail_Line\n         OI    VolTbl_Ent_SMS_Line,L'VolTbl_Ent_SMS_Line SMS Anomaly\n\nD00600   DS    0H\n*---------------------------------------------------------------------*\n*     Get processor-related data                                      *\n*---------------------------------------------------------------------*\n         XC    @_LP_Count,@_LP_Count    Make sure LP Count is 0\n         MVI   @D_CSRSI_Manuf,C' '      Clear Manufacturer ID\n         MVC   @D_CSRSI_Manuf+1(L'@D_CSRSI_Manuf-1),@D_CSRSI_Manuf\n         MVC   @D_CSRSI_Type,@D_CSRSI_Manuf Clear Type\n         MVC   @D_CSRSI_Model,@D_CSRSI_Manuf Clear Model\n         MVC   @D_CSRSI_Serial,@D_CSRSI_Manuf Clear Serial\n\n         L     R15,CVTPTR               A(CVT)\n         TM    CVTDCB-CVT(R15),CVTOSEXT Is OSLVL OK?\n         JZ    D00600Z                  No, crawl through control blks\n         TM    CVTOSLV4-CVT(R15),CVTCSRSI Yes, can we use CSRSI?\n         JZ    D00600Z                  No, use control blocks\n\n*---------------------------------------------------------------------*\n*     We will be using CSRSI to get the processor-related data - go   *\n*    build the parm list ...                                          *\n*---------------------------------------------------------------------*\n         L     R0,=AL4(SIV1V2V3_LEN)    Length of return data\n\n         BASR  R2,0\n         USING (*,D00600_End-1),R2\n         STORAGE OBTAIN,                Go get some storage            +\n               LENGTH=(0)                this long\nD00600_End DS  0H\n         ST    R1,@D_CSRSI_Parm+8       Save A(Info area)\n         LA    R15,=AL4(CSRSI_REQUEST_V1CPC_MACHINE+CSRSI_REQUEST_V2CPC+\n               _LPAR+CSRSI_REQUEST_V3CPC_VM) All data requested\n         ST    R15,@D_CSRSI_Parm        Save request code\n         LA    R15,=AL4(SIV1V2V3_Len)   A(Length of Info area)\n         ST    R15,@D_CSRSI_Parm+4      Save length in parm list\n         LA    R15,@D_DBLWD             A(Return code area)\n         ST    R15,@D_DBLWD+4           Save it\n         LA    R15,@D_DBLWD+4           A(Return code area pointer)\n         ST    R15,@D_CSRSI_Parm+12     Save in parm list\n\n*---------------------------------------------------------------------*\n*     ... and issue CSRSI                                             *\n*---------------------------------------------------------------------*\n         BASR  R2,0\n         USING (*,D00600A_End-1),R2\n         LOAD  EP=CSRSI                 Go get machine info module\nD00600A_End DS  0H\n         LTR   R15,R15                  Did it work\n         JNZ   D00600X                  No, skip\n         LR    R15,R0                   Yes, save EP\n         LA    R1,@D_CSRSI_Parm         A(Parmlist)\n         BASR  R14,R15                  Go do it\n         DELETE EP=CSRSI                Don't need CSRSI anymore\n         L     R15,@D_DBLWD             Get CSRSI return code\n         CHI   R15,CSRSI_STSINOTAVAILABLE Did we get anything?\n         JH    D00600X                  No, skip\n\n*---------------------------------------------------------------------*\n*     We seem to have some valid data back from CSRSI, so save the    *\n*    bits we need.                                                    *\n*---------------------------------------------------------------------*\n         L     R15,@D_CSRSI_Parm+8      A(CSRSI Data)\n         TM    SI00VALIDITYFLAGS-SI00(R15),SI00VALIDSI11V1 V1 valid?\n         JZ    D00600C                  No, skip\n         A     R15,=AL4(SI00_LEN)       Yes, bump to V1 Data area\n         MVC   @D_CSRSI_Manuf,SI11V1CPCMANUFACTURER-SI11V1(R15)\n         MVC   @D_CSRSI_Type,SI11V1CPCTYPE-SI11V1(R15)\n         MVC   @D_CSRSI_Model,SI11V1CPCMODEL-SI11V1(R15)\n         MVC   @D_CSRSI_Serial,SI11V1CPCSEQUENCECODE+L'SI11V1CPCSEQUENC+\n               ECODE-L'@D_CSRSI_Serial-SI11V1(R15)\nD00600C  DS    0H\n         L     R15,@D_CSRSI_Parm+8      A(CSRSI Data)\n         TM    SI00VALIDITYFLAGS-SI00(R15),SI00VALIDSI22V3 VM valid?\n         JZ    D00600E                  No, skip\n         A     R15,=AL4(SIV1V2_LEN)     Yes, bump to VM Data area\n         LA    R0,0                     Clear work reg\n         IC    R0,SI22V3DBCOUNTFIELD-SI22V3(0,R15) Nbr V3 Desc Blks\n         SLL   R0,28                    Clean\n         SRL   R0,28                     it\n         AHI   R0,-1                    Relative to 0\n         MH    R0,=AL2(SI22V3DB_LEN)    Offset of last\n         LA    R15,SI22V3DBS-SI22V3(0,R15) Point to first\n         ALR   R15,R0                   and then to last\n         LH    R0,SI22V3DBCONFIGUREDLCPUCOUNT-SI22V3DB(R15) LCPUs\n         ST    R0,@_LP_Count            Save it\n         J     D00600X                  and skip\nD00600E  DS    0H\n         L     R15,@D_CSRSI_Parm+8      A(CSRSI Data)\n         TM    SI00VALIDITYFLAGS-SI00(R15),SI00VALIDSI22V2 LPAR valid?\n         JZ    D00600G                  No, skip\n         A     R15,=AL4(SIV1_LEN)       Yes, bump to LPAR Data area\n         LH    R0,SI22V2CONFIGUREDLCPUCOUNT-SI22V2(R15) LCPUs\n         ST    R0,@_LP_Count            Save it\n         J     D00600X                  and skip\nD00600G  DS    0H\n         L     R15,@D_CSRSI_Parm+8      A(CSRSI Data)\n         TM    SI00VALIDITYFLAGS-SI00(R15),SI00VALIDSI22V1 Mach OK?\n         JZ    D00600X                  No, skip\n         A     R15,=AL4(SI00_LEN+SI11V1_LEN) Bump to CPC Data area\n         LH    R0,SI22V1CONFIGUREDCPUCOUNT-SI22V1(R15) CPUs\n         ST    R0,@_LP_Count            Save it\n         J     D00600X                  and skip\n\nD00600X  DS    0H\n         L     R0,=AL4(SIV1V2V3_LEN)    Length of return data\n         L     R1,@D_CSRSI_Parm+8       A(Start)\n\n         BASR  R2,0\n         USING (*,D00600X_End-1),R2\n         STORAGE RELEASE,               Free CSRSI storage             +\n               ADDR=(1),                 starting here                 +\n               LENGTH=(0)                for this long\nD00600X_End DS  0H\n\n         LA    R15,0                    Clear work reg\n         ST    R15,@D_CSRSI_Parm+4      Clear storage length\n         ST    R15,@D_CSRSI_Parm+8         and address\n\nD00600Z  DS    0H\n*---------------------------------------------------------------------*\n*     We will be crawling through control blocks to get the processor *\n*    related info. Get the CPU-type data (Type, model, etc.)          *\n*---------------------------------------------------------------------*\n         CLI   @D_CSRSI_Manuf,C' '       Do we have CPU Data?\n         JNE   D00608                    Yes, skip\n         L     R15,CVTPTR                No, A(CVT)\n         L     R15,CVTHID-CVT(R15)       A(Host ID Table)\n         TM    CPCND_FLAGS-SHID(R15),CPCND_INVAL OK?\n         JO    D00602                    No, skip type info\n         MVC   @D_CSRSI_Manuf(L'CPCND_MAN),CPCND_MAN-SHID(R15)\n         MVC   @D_CSRSI_Type(L'CPCND_TYPE),CPCND_TYPE-SHID(R15)\n         MVC   @D_CSRSI_Model(L'CPCND_MODEL),CPCND_MODEL-SHID(R15)\nD00602   DS    0H\n         L     R15,CVTPTR                A(CVT)\n         L     R15,CVTPCCAT-CVT(R15)     A(PCCA Table)\n         LHI   R14,16                    Max of 16 CPUs\nD00604   DS    0H\n         ICM   R0,B'1111',0(R15)         Get A(PCCA) for this CPU\n         JNZ   D00606                    CPU Active, skip\n         AHI   R15,4                     No, point to next\n         BRCT  R14,D00604                and check again\n         J     D00608                    None(?), ignore it\nD00606   DS    0H\n         LR    R15,R0                    Point to PCCA\n         MVC   @D_CSRSI_Serial,PCCACPID+4-PCCA(R15)  Serial number\n\nD00608   DS    0H\n*---------------------------------------------------------------------*\n*     Go get the number of CPUs, if required                          *\n*---------------------------------------------------------------------*\n         ICM   R1,B'1111',@_LP_Count    Do we have an LP count?\n         JNZ   D00625                   Yes, skip\n         L     R15,CVTPTR               A(CVT)\n         L     R15,CVTLCCAT-CVT(R15)    A(LCCAVT)\n         LHI   R14,16                   Max number of CPUs\n         LA    R1,0                     Count of CPUs\nD00610   DS    0H\n         ICM   R0,B'1111',0(R15)        Get A(LCCA) for this CPU\n         JZ    D00620                   None, skip\n         AHI   R1,1                     OK, bump CPU count\nD00620   DS    0H\n         AHI   R15,4                    Bump to next LCCA pointer\n         BRCT  R14,D00610               and check it out\n         ST    R1,@_LP_Count            Save it\n\nD00625   DS    0H\n*---------------------------------------------------------------------*\n*     ... and initialize @_SubTask_Count to either MAXTASKS or        *\n*      MIN(Volumes, (2*#_Logical_Processors)+1)                       *\n*---------------------------------------------------------------------*\n         LH    R0,@_MaxTasks            Get MaxTasks specification\n         LTR   R0,R0                    Any?\n         JP    D00630                   Yes, skip\n         LR    R0,R1                    No, use #LPs\n         SLL   R0,1                      doubled\n         AHI   R0,1                      + 1\nD00630   DS    0H\n         AIF   (&Max_SubTask_Count LT 1).Max_SubTask_Count_020\n         CHI   R0,&Max_SubTask_Count    Is it > max?\n         JNH   D00630C                  No, OK\n         LHI   R0,&Max_SubTask_Count    Yes, use max\nD00630C  DS    0H\n.Max_SubTask_Count_020 ANOP\n         ST    R0,@_SubTask_Count       and update it\n\n         LA    R0,0                     Clear UCB count\n         ICM   R9,B'1111',@_VolTbl_Ptr A(Table of Volumes)\n         JZ    D00650                   None, skip\n         ICM   R10,B'1111',VolTbl_Hdr_Count-VolTbl_Hdr(R9) Get count\n         JZ    D00650                   None, skip\n         AHI   R9,VolTbl_Ent-VolTbl     Point to 1st entry\nD00640   DS    0H\n         TM    VolTbl_Ent_Detail_Line,L'VolTbl_Ent_Detail_Line UCB?\n         JNO   D00640C                  Not Detail line, skip\n         TM    VolTbl_Ent_SMS_Line,L'VolTbl_Ent_SMS_Line SMS Anomaly?\n         JO    D00640C                  Not really a UCB, skip\n         AHI   R0,1                     Bump UCB count\nD00640C  DS    0H\n         AHI   R9,VolTbl_Ent_Len        A(Next entry)\n         BRCT  R10,D00640               and check again\n\nD00650   DS    0H\n*---------------------------------------------------------------------*\n*     Use the lesser of UCB count and @_SubTask_Count for our         *\n*    number of subtasks                                               *\n*---------------------------------------------------------------------*\n         C     R0,@_SubTask_Count       Check against nbr subtasks\n         JNL   D00660                   OK, skip\n         ST    R0,@_SubTask_Count       Too few UCBs, use UCB count\n\nD00660   DS    0H\n*---------------------------------------------------------------------*\n*     If we will be doing Statistics, ...                             *\n*---------------------------------------------------------------------*\n         TM    @_Statistics,L'@_Statistics Doing stats?\n         JNO   D00780                    No, skip\n\n*---------------------------------------------------------------------*\n*    ... move the non-execution-related stats lines ...               *\n*---------------------------------------------------------------------*\n         LA    R2,D_Stats_Line_Ptrs      A(Start of line pointers)\n         SLR   R3,R3                     Clear count\nD00660C  DS    0H\n         LA    R1,@D_Parms               A(Parm list)\n         BRAS  R14,W00010                Get A(Next entry)\n         LTR   R15,R15                   Did we get one?\n         JNZ   D00780                    No, skip\n         LR    R9,R1                     Yes, point to it\n         L     R15,0(0,R2)               A(Stats line)\n         LH    R14,0(0,R15)              Get length of stats line\n         AHI   R14,-1                    EX len\n         EX    R14,D_MVC1                Move it\n\n         OI    VolTbl_Ent_Stats_Line,L'VolTbl_Ent_Stats_Line\n         OI    VolTbl_Ent_Processed,L'VolTbl_Ent_Processed Mark as done\n         OI    VolTbl_Ent_Stats_Done,L'VolTbl_Ent_Stats_Done Done\n         OI    VolTbl_Ent_ECB,X'40'      POST as done\n\n         AHI   R3,1                      Bump count\n         CHI   R3,3                      1st execution line?\n         JNE   D00680E                   No, skip\n\n\n         MVC   @D_TIME,D_TIME           Move L-Form of macro\n         TIME  DEC,                     Get time                       +\n               @D_Time_Area,             and return it here            +\n               LINKAGE=SYSTEM,           don't use the SVC             +\n               DATETYPE=YYYYMMDD,        format of returned data       +\n               MF=(E,@D_TIME)            addr of macro list\n         L     R0,@D_Time_Area          Get the time\n         SRL   R0,12                    Shift out seconds and 100s\n         ST    R0,@D_Time_Area          Save it\n         OI    @D_Time_Area+3,X'0F'     OR in a sign\n         MVC   @D_WkArea(7),=X'402120204B2020' Time mask\n         ED    @D_WkArea(7),@D_Time_Area+1 Make it readable\n         MVC   VolTbl_Ent_Display+D_Stats_Line3_Time-D_Stats_Line3(L'D_+\n               Stats_Line3_Time),@D_WkArea+2\n         L     R15,@D_Time_Area+8       Get Date (yyyymmdd)\n         LA    R14,0                    Clear work register\n         SLDL  R14,4                    Make room for sign\n         STM   R14,R15,@D_Time_Area     Save it\n         OI    @D_Time_Area+7,X'0F'     OR in a sign\n         MVC   @D_WkArea(12),=X'402120202020602020602020'  Date mask\n         ED    @D_WkArea(12),@D_Time_Area+3 Make it readable\n         MVC   VolTbl_Ent_Display+D_Stats_Line3_Date-D_Stats_Line3(L'D_+\n               Stats_Line3_Date),@D_WkArea+2\n\n         L     R14,CVTPTR               A(CVT)\n         L     R15,CVTECVT-CVT(0,R14)   A(EVCT)\n         MVC   VolTbl_Ent_Display+D_Stats_Line3_SysVer-D_Stats_Line3(L'+\n               ECVTPNAM),ECVTPNAM-ECVT(R15)\n         LA    R1,VolTbl_Ent_Display+D_Stats_Line3_SysVer+L'ECVTPNAM-1-+\n               D_Stats_Line3           A(Last char)\n         LA    R0,VolTbl_Ent_Display+D_Stats_Line3_SYSVer-D_Stats_Line3\nD00670   DS    0H\n         CLI   0(R1),C' '               Last significant character\n         JNE   D00680                   Yes, skip\n         S     R1,=FL4'1'               No, back up a byte\n         CR    R1,R0                    Too far?\n         JH    D00670                   No, check again\nD00680   DS    0H\n         AIF   (NOT D'CVTZOSE).D00680_010\n         TM    CVTOSLV5-CVT(R14),CVTZOSE z/OS.e?\n         JZ    D00680C                  No, skip\n         MVC   1(2,R1),=C'.e'           Yes, say so\n         LA    R1,2(0,R1)               and bump pointer\nD00680C  DS    0H\n.D00680_010 ANOP\n         MVC   2(L'ECVTPVER,R1),ECVTPVER-ECVT(R15)  Version\n         MVI   2+L'ECVTPVER(R1),C'.'    Separator\n         MVC   2+L'ECVTPVER+1(L'ECVTPREL,R1),ECVTPREL-ECVT(R15) Rel\n         MVI   2+L'ECVTPVER+1+L'ECVTPREL(R1),C'.'    Separator\n         MVC   2+L'ECVTPVER+1+L'ECVTPREL+1(L'ECVTPMOD,R1),ECVTPMOD-ECVT+\n               (R15)\n\nD00680E  DS    0H\n         CHI   R3,4                      2nd execution stats line?\n         JNE   D00750C                   No, skip\n\n         L     R15,CVTPTR                A(CVT)\n         MVC   VolTbl_Ent_Display+D_Stats_Line4_SNAME-D_Stats_Line4(L'C+\n               VTSNAME),CVTSNAME-CVT(R15)\n         LA    R1,VolTbl_Ent_Display+D_Stats_Line4_SNAME+L'CVTSNAME-1-D+\n               _Stats_Line4              A(Last char)\nD00690   DS    0H\n         CLI   0(R1),C' '                Trailing Blank?\n         JNE   D00700                    No, skip\n         S     R1,=FL4'1'                Yes, back up a byte\n         J     D00690                    and try again\nD00700   DS    0H\n         MVI   2(R1),C'('                Open paren\n         AHI   R1,3                      Point to next byte\n         MVC   0(L'@D_CSRSI_Manuf,R1),@D_CSRSI_Manuf Move manufacturer\n         LA    R1,L'@D_CSRSI_Manuf-1(0,R1) A(Last character)\nD00702   DS    0H\n         CLI   0(R1),C' '                Trailing blank?\n         JNE   D00704                    No, OK\n         BRCT  R1,D00702                 Yes, back up a byte\nD00704   DS    0H\n         MVI   1(R1),C' '                Move separator\n         MVC   2(L'@D_CSRSI_Type,R1),@D_CSRSI_Type\n         MVI   2+L'@D_CSRSI_Type(R1),C'-' Separator\n         MVC   2+L'@D_CSRSI_Type+1(L'@D_CSRSI_Model,R1),@D_CSRSI_Model\n         LA    R1,2+L'@D_CSRSI_Type+L'@D_CSRSI_Model(0,R1)\nD00706   DS    0H\n         CLI   0(R1),C' '                Trailing blank?\n         JNE   D00708                    No, OK\n         BRCT  R1,D00706                 Yes, back up and check again\nD00708   DS    0H\n         MVC   1(8,R1),=C', CPUID '      Literal\n         MVC   9(L'@D_CSRSI_Serial,R1),@D_CSRSI_Serial\n         MVI   9+L'@D_CSRSI_Serial(R1),C')'  Trailing paren\n         LA    R1,10+L'@D_CSRSI_Serial(0,R1) A(Next byte)\n\nD00740   DS    0H\n         MVC   0(5,R1),=C' with'         Start of literal\n         AHI   R1,5                      A(Next byte)\n         TM    @_OW48527,L'@_OW48527     APAR OW48527 on?\n         JO    D00750                    Yes, skip\n         MVC   0(3,R1),=C'out'           No, say so\n         AHI   R1,3                      A(Next byte)\nD00750   DS    0H\n         MVC   0(9,R1),=C' OW48527.'     Finish it off\n\nD00750C  DS    0H\n         CHI   R3,D_Stats_Line_Count     Any more to do?\n         JNL   D00750E                   No, skip\n         AHI   R2,4                      Yes, bump to next pointer\n         J     D00660C                   and go do it\n\nD00750E  DS    0H\n*-------------------------------------------------------------------*\n*    ... 2 more for the Stack statistics ...                        *\n*-------------------------------------------------------------------*\n         LA    R1,@D_Parms               A(Parm list)\n         BRAS  R14,W00010                Get A(Next entry)\n         LTR   R15,R15                   Did we get one?\n         JNZ   D00780                    No, skip\n         LR    R9,R1                     Yes, point to it\n\n         OI    VolTbl_Ent_Stats_Line,L'VolTbl_Ent_Stats_Line\n         OI    VolTbl_Ent_Stats_31Stack,L'VolTbl_Ent_Stats_31Stack\n\n         LA    R1,@D_Parms               A(Parm list)\n         BRAS  R14,W00010                Get A(Next entry)\n         LTR   R15,R15                   Did we get one?\n         JNZ   D00780                    No, skip\n         LR    R9,R1                     Yes, point to it\n\n         OI    VolTbl_Ent_Stats_Line,L'VolTbl_Ent_Stats_Line\n         OI    VolTbl_Ent_Stats_24Stack,L'VolTbl_Ent_Stats_24Stack\n\n*-------------------------------------------------------------------*\n*    ... and 1 more for the CPU time.                               *\n*-------------------------------------------------------------------*\n         LA    R1,@D_Parms               A(Parm list)\n         BRAS  R14,W00010                Get A(Next entry)\n         LTR   R15,R15                   Did we get one?\n         JNZ   D00780                    No, skip\n         LR    R9,R1                     Yes, point to it\n\n         OI    VolTbl_Ent_Stats_Line,L'VolTbl_Ent_Stats_Line\n         OI    VolTbl_Ent_Stats_CPUTime,L'VolTbl_Ent_Stats_CPUTime\n\n*---------------------------------------------------------------------*\n*   If we are doing LSPACEs, get enough lines for the subtask         *\n*  heading(s) and stats lines                                         *\n*---------------------------------------------------------------------*\n         TM    @_No_LSPACE,L'@_No_LSPACE Doing LSPACEs?\n         JO    D00780                   No, skip subtask stuff\n\n         L     R8,@_SubTask_Count       Get nbr subtasks\n         AHI   R8,H_SubTask_Hdg_Count   Plus nbr heading lines\n         SR    R3,R3                    Clear offset\n\nD00760   DS    0H\n         LA    R1,@D_Parms               A(Parm list)\n         BRAS  R14,W00010                Get A(Next entry)\n         LTR   R15,R15                   Did we get one?\n         JNZ   D00780                    No, skip\n         OI    VolTbl_Ent_Stats_Line-VolTbl_Ent(R1),L'VolTbl_Ent_Stats_+\n               Line\n         LTR   R3,R3                     Have we saved the offset?\n         JNZ   D00770                    Yes, skip\n         L     R15,@_VolTbl_Ptr          A(VolTbl)\n         LR    R3,R1                     A(1st heading line)\n         SR    R3,R15                    Offset of SubTask heading\n         ST    R3,VolTbl_Hdr_SubT_Off-VolTbl_Hdr(R15) Save it\nD00770   DS    0H\n\n         BRCT  R8,D00760                 And do it again\n\nD00780   DS    0H\n*---------------------------------------------------------------------*\n*     If we will not be doing LSPACEs ...                             *\n*---------------------------------------------------------------------*\n         TM    @_No_LSPACE,L'@_No_LSPACE  Doing LSPACE?\n         JNO   D00800                   Yes, skip\n\nD00790   DS    0H\n*---------------------------------------------------------------------*\n*     ... all volumes have been processed, and the table is complete. *\n*---------------------------------------------------------------------*\n         ICM   R15,B'1111',@_VolTbl_Ptr No, A(VolTbl)\n         JZ    D00800                   None, skip\n         L     R0,VolTbl_Hdr_Vols_Total-VolTbl_Hdr(R15)\n         ST    R0,VolTbl_Hdr_Vols_Proc-VolTbl_Hdr(R15)\n         OI    VolTbl_Hdr_ECB-VolTbl_Hdr(R15),X'40' POST table complete\n\nD00800   DS    0H\n*---------------------------------------------------------------------*\n*     Free up the esoteric table, if there is one ...                 *\n*---------------------------------------------------------------------*\n         ICM   R1,B'1111',@D_UNITA      A(Unit Table)\n         JZ    D00810                   None, skip\n         L     R0,0(0,R1)               Get its length\n\n         BASR  R2,0\n         USING (*,D00800_End-1),R2\n         STORAGE RELEASE,               Free the old table             +\n               ADDR=(1),                 starting here                 +\n               LENGTH=(0)                for this long\nD00800_End DS  0H\n         DROP  R2\n\n         LA    R15,0                    Clear work register\n         ST    R15,@D_UNITA             and clear A(Unit table)\n\nD00810   DS    0H\n*---------------------------------------------------------------------*\n*     ... and the VLDs, if there are any.                             *\n*---------------------------------------------------------------------*\n         LA    R15,0                   Clear work reg\n         ST    R15,@D_Parms_T00010     No volser\n         LA    R15,@D_VLD_Anchor       A(Anchor)\n         ST    R15,@D_Parms_T00010+4   No volser\n         LA    R1,@D_Parms              A(Parm list)\n         BRAS  R14,T00010               Go free VLDs\n\n*---------------------------------------------------------------------*\n*     If we have found any UCBs, exit with a return code of 0         *\n*---------------------------------------------------------------------*\n         ICM   R15,B'1111',@_VolTbl_Ptr Any VolTbl?\n         JZ    D80010                   No, exit with error\n         ICM   R15,B'1111',VolTbl_Hdr_Vols_Total-VolTbl_Hdr(R15) Vols?\n         JZ    D80010                   No, exit with error\n         LA    R15,0                    Clear return code\n         J     D90010                   and exit\n\nD80010   DS    0H\n*---------------------------------------------------------------------*\n*   We couldnt find any UCBs - set the return code and exit           *\n*---------------------------------------------------------------------*\n         LA    R15,4                    No UCBs returned\n         J     D90010                   and exit\n\nD90010   DS    0H\n*---------------------------------------------------------------------*\n*    Free up our local storage ...                                    *\n*---------------------------------------------------------------------*\n         LR    R3,R15                   Save return code\n\n         LA    R1,@D_Dynam              A(Local storage)\n         L     R2,@D_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         L     R13,4(0,R13)             Rescue A(HSA)\n\n         SSCSTACK POP,                  Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=(R2)                on this stack\n\n         LR    R15,R3                   Restore return code\n\n*-------------------------------------------------------------------*\n*    ... and return to caller                                       *\n*-------------------------------------------------------------------*\n         L     R14,12(0,R13)            Restore return address\n         LM    R0,R12,20(R13)           Restore other registers\n         BSM   0,R14                    and return\n\nD_Literals  DS  0H\n\nD_MVC    MVC   0(0,R1),0(R15)           Move STORGRP\nD_MVC1   MVC   VolTbl_Ent_Display(0),2(R15)  Move Stats line\n\nD_CLC    CLC   0(0,R14),0(R15)          UCBTBYT4 vs DCEOBRDT\n\nD_TrTbl  DC    256AL1(*-D_TrTbl)\n         ORG   D_TrTbl+X'FF'\n         DC    C'*'\n         ORG   ,\n\nD_TRTAB  EQU   *-X'F0'\n         DC    C'0123456789ABCDEF'\n\nD_TIME   TIME  LINKAGE=SYSTEM,          Get the time                   +\n               MF=L                      keep ourselves reentrant\nD_TIME_Length  EQU *-D_TIME\n\n\nD_CHPID_Msg  DC CL(L'VolTbl_Ent_CHPIDs)' $:Phys unavail, -:Log unavail'\n\nD_Stats_Line_Ptrs     EQU   *\n                      DC    AL4(D_Stats_Line1-2)\n                      DC    AL4(D_Stats_Line2-2)\n                      DC    AL4(D_Stats_Line3-2)\n                      DC    AL4(D_Stats_Line4-2)\n                      DC    AL4(D_Stats_Line5-2)\n                      DC    AL4(D_Stats_Line6-2)\n                      DC    AL4(D_Stats_Line7-2)\n                      DC    AL4(D_Stats_Line8-2)\n                      DC    AL4(D_Stats_Line9-2)\n                      DC    AL4(D_Stats_Line10-2)\n                      DC    AL4(D_Stats_Line11-2)\nD_Stats_Line_Count    EQU   (*-D_Stats_Line_Ptrs)/4\n\n                      DC    AL2(D_Stats_Line1_End-D_Stats_Line1)\nD_Stats_Line1         EQU   *\n                      DC    C'&PGMNAME '\n                      DC    C'&VERSION'\n                      DC    C' '\nD_Stats_Line1_Data    EQU   *\n                      DC    C'assembled on '\n                      DC    C'&ASMDT'\n                      DC    C' at '\n                      DC    C'&ASMTM'\n                      DC    C' under '\n                      DC    C'&SYSTEM_ID'\nD_Stats_Line1_End     EQU   *\n\n                      DC    AL2(D_Stats_Line2_End-D_Stats_Line2)\nD_Stats_Line2         EQU   *\n                      DC    CL(D_Stats_Line1_Data-D_Stats_Line1)' '\n                      DC    C'with '\n                      DC    C'&SYSASM'\n                      DC    C' '\n                      DC    C'&SYSVER'\n                      DC    C'.'\nD_Stats_Line2_End     EQU   *\n\n                      DC    AL2(D_Stats_Line3_End-D_Stats_Line3)\nD_Stats_Line3         EQU   *\n                      DC    CL(D_Stats_Line1_Data-D_Stats_Line1)' '\n                      DC    C'executing on '\nD_Stats_Line3_Date    DC    CL10' '\n                      DC    C' at '\nD_Stats_Line3_Time    DC    CL5' '\n                      DC    C' under '\nD_Stats_Line3_SysVer  DC    CL(L'ECVTPNAM+2+1+L'ECVTPVER+1+L'ECVTPREL+1+\n               +L'ECVTPMOD)' '\nD_Stats_Line3_End     EQU   *\n\n                      DC    AL2(D_Stats_Line4_End-D_Stats_Line4)\nD_Stats_Line4         EQU   *\n                      DC    CL(D_Stats_Line1_Data-D_Stats_Line1)' '\n                      DC    C'on '\nD_Stats_Line4_SNAME   DC    CL(L'CVTSNAME)' '\n                      DC    C' '\n                      DC    CL(12+L'CPCND_MAN+L'CPCND_TYPE+L'CPCND_MODE+\n               L)' '\nD_Stats_Line4_End     EQU   *\n\n                      DC    AL2(D_Stats_Line5_End-D_Stats_Line5)\nD_Stats_Line5         EQU   *\n                      DC    CL(D_Stats_Line1_Data-D_Stats_Line1)' '\n                      DC    C'Installation Defaults'\nD_Stats_Line5_End     EQU   *\n\n                      DC    AL2(D_Stats_Line6_End-D_Stats_Line6)\nD_Stats_Line6         EQU   *\n                      DC    CL(D_Stats_Line1_Data-D_Stats_Line1)' '\n                      DC    C' ISPF Output by default      : '\n         AIF   (&ISPF_by_Default).D_Stats_Line6_010\n                      DC    C'N'\n         AGO   .D_Stats_Line6_020\n.D_Stats_Line6_010  ANOP\n                      DC    C'Y'\n.D_Stats_Line6_020  ANOP\nD_Stats_Line6_End     EQU   *\n\n                      DC    AL2(D_Stats_Line7_End-D_Stats_Line7)\nD_Stats_Line7         EQU   *\n                      DC    CL(D_Stats_Line1_Data-D_Stats_Line1)' '\n                      DC    C' ISPF Output type            : '\n                      DC    C'&ISPF_Default_Type'\nD_Stats_Line7_End     EQU   *\n\n                      DC    AL2(D_Stats_Line8_End-D_Stats_Line8)\nD_Stats_Line8         EQU   *\n                      DC    CL(D_Stats_Line1_Data-D_Stats_Line1)' '\n                      DC    C' Max LSPACE Wait (Foreground): '\n         AIF   (&Fore_LSPACE_Wait EQ 0).D_Stats_Line8_010\n                      DC    C'&Fore_LSPACE_Wait'\n                      DC    C' secs.'\n         AGO   .D_Stats_Line8_020\n.D_Stats_Line8_010  ANOP\n                      DC    C'None'\n.D_Stats_Line8_020  ANOP\nD_Stats_Line8_End     EQU   *\n\n                      DC    AL2(D_Stats_Line9_End-D_Stats_Line9)\nD_Stats_Line9         EQU   *\n                      DC    CL(D_Stats_Line1_Data-D_Stats_Line1)' '\n                      DC    C' Max LSPACE Wait (Background): '\n         AIF   (&Back_LSPACE_Wait EQ 0).D_Stats_Line9_010\n                      DC    C'&Back_LSPACE_Wait'\n                      DC    C' secs.'\n         AGO   .D_Stats_Line9_020\n.D_Stats_Line9_010  ANOP\n                      DC    C'None'\n.D_Stats_Line9_020  ANOP\nD_Stats_Line9_End     EQU   *\n\n                      DC    AL2(D_Stats_Line10_End-D_Stats_Line10)\nD_Stats_Line10        EQU   *\n                      DC    CL(D_Stats_Line1_Data-D_Stats_Line1)' '\n                      DC    C' Default number of SubTasks  : '\n         AIF   (&Default_SubTask_Count EQ 0).D_Stats_Line10_010\n                      DC    C'&Default_SubTask_Count'\n         AGO   .D_Stats_Line10_020\n.D_Stats_Line10_010 ANOP\n                      DC    C'Dynamic'\n.D_Stats_Line10_020 ANOP\nD_Stats_Line10_End    EQU   *\n\n                      DC    AL2(D_Stats_Line11_End-D_Stats_Line11)\nD_Stats_Line11        EQU   *\n                      DC    CL(D_Stats_Line1_Data-D_Stats_Line1)' '\n                      DC    C' Maximum number of SubTasks  : '\n         AIF   (&Max_SubTask_Count EQ 0).D_Stats_Line11_010\n                      DC    C'&Max_SubTask_Count'\n         AGO   .D_Stats_Line11_020\n.D_Stats_Line11_010 ANOP\n                      DC    C'None'\n.D_Stats_Line11_020 ANOP\nD_Stats_Line11_End    EQU   *\n\n\n         LTORG\n\nD_Literals_End  DS  0H\n\n@D_Dynam                  DSECT       Dynamic area for D00000\n                          DS    18F    O/S Style save area\n@D_31Bit_Stack_Ptr_Ptr    DS    AL4    A(31-bit Stack Ptr)\n@D_24Bit_Stack_Ptr_Ptr    DS    AL4    A(24-bit Stack Ptr)\n@D_DBLWD                  DS    D      Doubleword work area\n@D_WkArea                 DS    CL12   EDit Word Area\n@D_UCBNAME                DS    CL4    UCB name\n@D_UNITA                  DS    AL4    A(UCB Table from EDTINFO\n@D_Volume_Count           DS    FL4    Nbr vols in the table\n@D_IECDDEVT_Ptr           DS    AL4    A(SYS1.NUCLEUS(IECDDEVT))\n@D_VLD_Anchor             DS    DL8    A(Start of SMS SG VLDs)\n@D_SMS_Ptrs               DS    2AL4   A(STORGRP, SMS Status)\n@D_R00010_Word            DS    FL4    A word for R00010\n                          DS    X      Flag byte\n@D_Eligible_UCB_Found     EQU   *-1,X'80' 1... .... At least 1 UCB\n@D_UCB_Addr_Updated       EQU   *-1,X'40' .1.. .... 4 --> 3 byte addr\n@D_Single_Volser          EQU   *-1,X'20' ..1. .... Specific Volser\n@D_SMS_Unavail            EQU   *-1,X'10' ...1 .... SMS not available\n@D_SMS_Ptrs_OK            EQU   *-1,X'08' .... 1... SMS data valid\n@D_CHPID_Unavail          EQU   *-1,X'04' .... .1.. CHP unavail\n                          DS    0F     Alignment\n@D_IOCT                   DS    CL48   IOC Token area for UCBSCAN\n\n                          DS    0F      Alignment\n@D_UCBSCAN_WorkArea       DS    CL100   UCBSCAN Work Area\n                          ORG   @D_UCBSCAN_WorkArea\n@D_CSRSI_Manuf            DS    CL(L'SI11V1CPCMANUFACTURER)\n@D_CSRSI_Type             DS    CL(L'SI11V1CPCTYPE)\n@D_CSRSI_Model            DS    CL(L'SI11V1CPCMODEL)\n@D_CSRSI_Serial           DS    CL4\n                          ORG   ,\n\n@D_Macro                  DS    0D     Macros\n                          EDTINFO MF=(L,@D_EDTINFO) EDTINFO L-Form\n                          ORG   @D_Macro\n                          IOCINFO MF=(L,@D_IOCINFO) IOCINFO L-Form\n                          ORG   @D_Macro\n                          UCBINFO MF=(L,@D_UCBINFO)\n@D_UCBINFO_Data           DS    XL256\n                          ORG   @D_Macro\n                          UCBSCAN MF=(L,@D_UCBSCAN) UCBSCAN L-Form\n                          DS    0F     Alignment\n@D_UCB                    DS    XL48   UCB Copy from UCBSCAN\n                          DS    0F     Alignment\n@D_DCE_Length             DS    XL2    DCE Area length\n@D_DCE                    DS    XL48   DCE Copy from UCBSCAN\n                          ORG   @D_Macro\n@D_SMS_Temp_StorGrp       DS    CL(L'VLDSTGRP)\n                          ORG   @D_Macro\n@D_TIME                   DS    CL(D_TIME_Length)   TIME Macro area\n                          DS    0D\n@D_Time_Area              DS    XL16   Data returned by TIME\n                          ORG   @D_Macro\n                          DS    0F\n@D_CSRSI_Parm             DS    4FL4   Parms for CSRSI\n                          ORG   ,      End of Macros\n\n@D_Parms                  DS    0F     Parms for called rtns\n@D_Parms_Std              DS    3AL4    Standard 3 parms\n@D_Parms_Extra            EQU   *       Extra parms\n@D_Parms_R00010           DS    5AL4       for R00010\n                          ORG   @D_Parms_Extra\n@D_Parms_T00010           DS    2AL4       for T00010\n                          ORG   ,\n                          DS    0D          Alignment\n@D_Dynam_Length           EQU   *-@D_Dynam Length of storage\n\n&PGMNAME CSECT\n\n         DROP  ,\n         POP   USING\n         TITLE 'E00010: Manage LSPACE SubTasks'\n         PUSH  USING\n\nE00010   DS    0H\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Routine   : E00010                                                 *\n*                                                                     *\n*  Abstract  : ATTACH and DETACH LSPACE Subtasks (H00010)             *\n*                                                                     *\n*  Inputs    : R1 : ---> A(@_Dynam)                                   *\n*                        A(31-bit Stack Pointer)                      *\n*                        A(24-bit Stack Pointer)                      *\n*  Outputs   : R15: 0 - OK                                            *\n*                   4 - No valid LSPACE data retrieved                *\n*                                                                     *\n*  Notes     :                                                        *\n*                                                                     *\n*  History:    1990/06/11 SDDA030 - New                               *\n*              1997/05/16 SDDA030 - ATTACHed subtasks to issue LSPACE *\n*                                   so that we don't wait forever for *\n*                                   devices that are constantly busy. *\n*              1998/09/17 SDDA030 - V2.0                              *\n*                                 - Corrected logic error where some  *\n*                                   STIMERMs were not being CANCELled *\n*                                 - Used Compare-and-Swap in pseudo-  *\n*                                   POST processing, rather than      *\n*                                   blindly ORing POST bit if no WAIT *\n*                                   was present (E00390).             *\n*                                 - Moved STIMERMs from this routine  *\n*                                   To H00010.                        *\n*                                 - Pass A(Volume Table) to H00010    *\n*                                   rather than individual entries    *\n*                                   within the table.                 *\n*              1999/03/03 SDDA030 - V2.5                              *\n*                                 - Added Version and Assembly info   *\n*                                   to statistics display             *\n*              1999/05/27 SDDA030 - V2.6                              *\n*                                 - Used LIFO Stack for our dynamic   *\n*                                   areas.                            *\n*              1999/07/30 SDDA030 - V2.7                              *\n*                                 - Added SubTask CPU time to         *\n*                                   statistics display                *\n*              1999/08/20 SDDA030 - V2.8                              *\n*                                 - Added SubTask Wait time to        *\n*                                   statistics display                *\n*              1999/09/01 SDDA030 - V2.9                              *\n*                                 - Passed totals fields as part of   *\n*                                   SubTask_Area, and totalled them   *\n*                                   after all subtasks complete.      *\n*              1999/09/30 SDDA030 - V2.10                             *\n*                                 - Inserted total volume count in the*\n*                                   Totals line                       *\n*              2000/01/19 SDDA030 - V2.11                             *\n*                                 - Created stats line for 24-bit     *\n*                                   stack.                            *\n*                                 - Reserved space for the Stack stats*\n*                                   lines, but deferred filling in    *\n*                                   values until they get output, in  *\n*                                   F00010.                           *\n*              2000/05/23 SDDA030 - V2.12                             *\n*                                 - Removed code that worried about   *\n*                                   subtasks that timed out.          *\n*                                 - Trimmed parm list passed to H00010*\n*                                 - Updated Stats lines to remove     *\n*                                   WAIT time data, and replace with  *\n*                                   APF authorization msg.            *\n*              2001/02/01 SDDA030 - V2.13                             *\n*                                 - Reset Parm list passed to H00010  *\n*                                 - Re-added WAIT stuff to stats line.*\n*                                 - Added IKJEFTSR re-invocation if   *\n*                                   we are not APFd.                  *\n*                                 - Moved CPU used stuff to V00010.   *\n*                                 - Made ourselves non-swappable while*\n*                                   daughter tasks active.            *\n*              2001/02/26 SDDA030 - V2.14                             *\n*                                 - Added VTOCIX and Frag Index info. *\n*                                 - Added call to U0010 to format     *\n*                                   detail and total lines.           *\n*                                 - Issue WAIT for @_MaxTasks ECBs,   *\n*                                   rather than for 1 ECB.            *\n*                                 - Acquired H00010 work area from the*\n*                                   stack.                            *\n*              2001/11/12 SDDA030 - V2.15                             *\n*                                   Passed STIMERM Wait time factor   *\n*                                   (based on #SubTasks/#LPs) to      *\n*                                   H00010.                           *\n*                                 - Checked Assembler version when    *\n*                                   generating our assembly time      *\n*                                   stamp.                            *\n*              2002/03/11 SDDA030 - V2.17                             *\n*                                 - If we will be using only 1 subtask*\n*                                   BASR rather than ATTACH           *\n*                                 - Used E_Stats_Line2 to verify that *\n*                                   IKJEFTSR invoked the same version *\n*                                   as was originally invoked.        *\n*              2002/06/11 SDDA030 - V2.18                             *\n*                                 - If OW48527 installed, don't WAIT  *\n*                                   for subtasks to terminate         *\n*                                 - Moved various fields passed to    *\n*                                   subtasks into VolTbl              *\n*              2002/08/08 SDDA030 - V2.19                             *\n*                                 - If we can't dispatch subtasks,    *\n*                                   POST entries and table as done.   *\n*              2003/01/16 SDDA030 - V2.20                             *\n*                                 - Correct bug when eliminating sub- *\n*                                   task stats if we aren't APF'd.    *\n*              2003/10/07 SDDA030 - V2.21                             *\n*                                 - Always ATTACH with ECB=, DETACH   *\n*                                   done in S00010.                   *\n*                                 - BRAS instead of ATTACHX H00010 if *\n*                                   only 1 vol, instead of only 1     *\n*                                   subtask.                          *\n*              2006/04/21 SDDA030 - V2.24                             *\n*                                 - IDENTIFY H00010 with a unique name*\n*                                   (based on TCB address) so we can  *\n*                                   run multiple copies simultaneously*\n*                                 - Used standardized calling sequence*\n*              ____/__/__ _______ -                                   *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         STM   R14,R12,12(R13)          Save callers registers\n         LARL  R11,E_Literals           Point to our literals\n         USING (E_Literals,E_Literals_End),R11 Tell the assembler\n\n         L     R12,0(0,R1)              A(@_Dynam)\n         USING @_Dynam,R12              Tell the assembler\n\n*-------------------------------------------------------------------*\n*    Get an area on the stack for our local storage                 *\n*-------------------------------------------------------------------*\n         L     R2,4(0,R1)               A(31-bit stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         SSCSTACK PUSH,                 Get stack area                 +\n               LEN=@E_Dynam_Length,      this long                     +\n               STACK=(R2)                using this stack\n\n         LR    R3,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LHI   R1,@E_Dynam_Length        Its length\n         LA    R14,0                    Clear source address\n         LA    R15,0                     and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R3                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*-------------------------------------------------------------------*\n         ST    R13,4(0,R1)              Chain\n         ST    R1,8(0,R13)               saveareas\n         LR    R13,R1                   Load dynam base\n         USING @E_Dynam,R13             Assign a base\n         L     R15,@E_Dynam+4           Get A(HSA)\n         LM    R0,R3,20(R15)            Restore callers registers\n\n         L     R15,4(0,R1)              A(31-bit Stack Pointer)\n         ST    R15,@E_31Bit_Stack_Ptr_Ptr Save it\n         L     R15,8(0,R1)              A(24-bit Stack Pointer)\n         ST    R15,@E_24Bit_Stack_Ptr_Ptr Save it\n\n*--------------------------------------------------------------------*\n*   Initialize our standard parmlist                                 *\n*--------------------------------------------------------------------*\n         LA    R15,@_Dynam              A(Dynamic area)\n         ST    R15,@E_Parms_Std         Save it\n         L     R15,@E_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)\n         ST    R15,@E_Parms_Std+4       Save it\n         L     R15,@E_24Bit_Stack_Ptr_Ptr A(24-bit Stack Pointer)\n         ST    R15,@E_Parms_Std+8       Save it\n\n*---------------------------------------------------------------------*\n*     Check that, in fact, we have something to do.                   *\n*---------------------------------------------------------------------*\n         ICM   R15,B'1111',@_VolTbl_Ptr A(VolTbl)\n         JZ    E80010                   None, exit with error\n         ICM   R15,B'1111',VolTbl_Hdr_Vols_Total-VolTbl_Hdr(R15)\n         JZ    E80010                   No volumes, exit with error\n         TM    @_No_LSPACE,L'@_No_LSPACE Yes, should we issue LSPACEs?\n         JO    E00230                   No, all done\n\n         TM    @_OW48527,L'@_OW48527    Yes, is OW48527 present?\n         JO    E00100                   Yes, OK\n\n*---------------------------------------------------------------------*\n*     We must be APF-Authorized to do our stuff. If we aren't, we     *\n*    re-invoke ourselves via IKJEFTSR (unless we are currently        *\n*    running as an IKJEFTSR invocation).                              *\n*---------------------------------------------------------------------*\n         TESTAUTH FCTN=1                Check APF Authorization\n         LTR   R15,R15                  Are we?\n         JNZ   E00020                   No, skip\n         TM    @_IKJEFTSR,L'@_IKJEFTSR  Yes, IKJEFTSR'd?\n         JZ    E00100                   No, OK\n\n*---------------------------------------------------------------------*\n*     We are APF'd and invoked under IKJEFTSR. Check to make sure     *\n*    that the code we are executing (under IKJEFTSR, which LOADs from *\n*    STEPLIB/LNKLST) is the same as was originally invoked as a       *\n*    command (possibly from ISPLLIB), using the time of assembly.     *\n*---------------------------------------------------------------------*\n         ICM   R15,B'1111',@_IKJEFTSR_TimeStamp_Ptr A(Callers timestmp)\n         JZ    E00010C                  Nothing, error\n         CLC   E_IKJEFTSR_TimeStamp(E_IKJEFTSR_TimeStamp_Length),0(R15)\n         JE    E00100                   Same as ours, OK\nE00010C  DS    0H\n         OI    @_SYSCLOCK_Err,L'@_SYSCLOCK_Err No, flag as an error\n         OI    @_LSPACE_Failed,L'@_LSPACE_Failed VolTbl Incomplete\n         J     E80010                   and go produce stats\n\nE00020   DS    0H\n         TM    @_IKJEFTSR,L'@_IKJEFTSR  Are we running from IKJEFTSR?\n         JZ    E00030                   No, skip\n         OI    @_No_APF,L'@_No_APF      Yes, still not authorized\n         OI    @_LSPACE_Failed,L'@_LSPACE_Failed VolTbl incomplete\n         J     E80010                   and go produce totals and stats\n\nE00030   DS    0H\n*---------------------------------------------------------------------*\n*     We are not APF'd, and not running as a result of IKJEFTSR, so   *\n*    re-invoke ourselves via IKJEFTSR.                                *\n*---------------------------------------------------------------------*\n\n*---------------------------------------------------------------------*\n*     Initialize our flags for IKJEFTSR                               *\n*---------------------------------------------------------------------*\n         LA    R15,E_IKJEFTSR_Flags     Point to our flags\n         ST    R15,@E_IKJEFTSR_Parms    Save it\n\n*---------------------------------------------------------------------*\n*     Use the program name as found from the PRB.                     *\n*---------------------------------------------------------------------*\n         L     R14,PSATNEW-PSA(0)       Get A(our TCB)\n         SLL   R14,8                    Clean\n         SRL   R14,8                      it\n         L     R15,TCBRBP-TCB(R14)      A(RB)\nE00050   DS    0H\n         L     R0,RBLINK-RBBASIC(R15)   A(Previous RB)\n         SLL   R0,8                     Clean\n         SRL   R0,8                       it\n         CR    R0,R14                   Last RB (RBLINK = A(TCB))?\n         JE    E00060                   Yes, skip\n         LR    R15,R0                   No, point to previous RB\n         J     E00050                   and keep trying\nE00060   DS    0H\n         LA    R14,0                    Get pointer to\n         ICM   R14,B'0111',RBCDE1-RBBASIC(R15)  our CDE\n         MVC   @E_IKJEFTSR_PgmName,CDNAME-CDENTRY(R14)  Move pgm name\n         LA    R15,@E_IKJEFTSR_PgmName  A(Program name)\n         ST    R15,@E_IKJEFTSR_Parms+4  Save it\n\n*---------------------------------------------------------------------*\n*     Length of the program name                                      *\n*---------------------------------------------------------------------*\n         LA    R15,@E_IKJEFTSR_PgmName+L'@E_IKJEFTSR_PgmName-1\nE00070   DS    0H\n         CLI   0(R15),C' '              Trailing blank?\n         JNE   E00080                   No, skip\n         BRCT  R15,E00070               Yes, keep checking\nE00080   DS    0H\n         LA    R14,@E_IKJEFTSR_PgmName-1 Calculate length\n         SR    R15,R14                   of program name\n         ST    R15,@E_IKJEFTSR_PgmName_Length  Save it\n         LA    R15,@E_IKJEFTSR_PgmName_Length A(Length)\n         ST    R15,@E_IKJEFTSR_Parms+8   Save it\n\n*---------------------------------------------------------------------*\n*     Pointers to the Return Code, Reason Code and ABEND Code areas.  *\n*---------------------------------------------------------------------*\n         LA    R15,@_IKJEFTSR_RC        A(Return Code Area)\n         ST    R15,@E_IKJEFTSR_Parms+12  Save it\n\n         LA    R15,@_IKJEFTSR_Reas      A(Reason Code Area)\n         ST    R15,@E_IKJEFTSR_Parms+16  Save it\n\n         LA    R15,@E_IKJEFTSR_ABEND     A(ABEND Code Area)\n         ST    R15,@E_IKJEFTSR_Parms+20  Save it\n\n*---------------------------------------------------------------------*\n*     Pointers to the parms we will be passing to ourselves           *\n*---------------------------------------------------------------------*\n         LA    R15,@E_IKJEFTSR_Pgm_Parm_Ptrs A(Parms for the Pgm)\n         ST    R15,@E_IKJEFTSR_Parms+24  Save it\n         OI    @E_IKJEFTSR_Parms+24,X'80' Flag as last parm\n\n         LA    R15,@E_IKJEFTSR_Pgm_Parm1 A(Pgm Parm 1) - A(@_Dynam)\n         ST    R15,@E_IKJEFTSR_Pgm_Parm_Ptrs Save it\n\n*---------------------------------------------------------------------*\n*     Point to our timestamp, which contains the assembly date,       *\n*    time and version. This will be used by the version of SPACE      *\n*    invoked by IKJEFTSR to ensure that the same code is running.     *\n*---------------------------------------------------------------------*\n         LA    R15,E_IKJEFTSR_TimeStamp A(Interesting assembly stats)\n         ST    R15,@_IKJEFTSR_TimeStamp_Ptr Save it\n\n*---------------------------------------------------------------------*\n*     And finally the parms themselves:                               *\n*       HL2'4',AL4(@_Dynam)                                           *\n*       HL2'16',1st 16 bytes of @_Dynam                               *\n*---------------------------------------------------------------------*\n         LHI   R15,4                    Length of an address\n         STH   R15,@E_IKJEFTSR_Pgm_Parm1 Save it\n         LA    R15,@_Dynam              A(Dynamic area)\n         ST    R15,@E_IKJEFTSR_Pgm_Parm1+2 Save it\n\n         LA    R15,@E_IKJEFTSR_Pgm_Parm2 A(Pgm Parm 1) - A(@_Dynam)\n         ST    R15,@E_IKJEFTSR_Pgm_Parm_Ptrs+4 Save it\n         OI    @E_IKJEFTSR_Pgm_Parm_Ptrs+4,X'80'  Last one\n\n         LA    R15,L'@E_IKJEFTSR_Pgm_Parm2-2 Length of data\n         STH   R15,@E_IKJEFTSR_Pgm_Parm2 Save it\n         MVC   @E_IKJEFTSR_Pgm_Parm2+2(L'@E_IKJEFTSR_Pgm_Parm2-2),@_Dyn+\n               am\n\n*---------------------------------------------------------------------*\n*     Re-invoke ourselves via IKJEFTSR so that we are (hopefully)     *\n*    APF-authorized.                                                  *\n*---------------------------------------------------------------------*\n         LA    R1,@E_IKJEFTSR_Parms     A(IKJEFTSR Parm List)\n         L     R15,CVTPTR               A(CVT)\n         L     R15,CVTTVT-CVT(R15)      A(TSVT)\n         L     R15,TSVTASF-TSVT(R15)    A(IKJEFTSR)\n         BASR  R14,R15                  Go do it\n\n*---------------------------------------------------------------------*\n*     Save the return code from IKJEFTSR, so if something went wrong, *\n*    we can tell somebody.                                            *\n*---------------------------------------------------------------------*\n         ST    R15,@_IKJEFTSR_RC        Save Return Code\n         CHI   R15,4                    How did it go?\n         JNH   E00090                   OK, skip\n         OI    @_IKJEFTSR_Err,L'@_IKJEFTSR_Err  Flag an error\n         OI    @_LSPACE_Failed,L'@_LSPACE_Failed VolTbl not filled in\n         J     E80010                   and clean up VolTbl\nE00090   DS    0H\n\n         LA    R15,0                    Clear return code\n         J     E90010                   and exit\n\nE00100   DS    0H\n*---------------------------------------------------------------------*\n*     OK, now we can start the real work,                             *\n*                                                                     *\n*     Set up to ATTACH the tasks to actually issue the LSPACE.        *\n*    We do this so that if one subtask gets hung up on a RESERVEd     *\n*    device, the other subtasks can still retrieve LSPACE info.       *\n*                                                                     *\n*     First, IDENTIFY the routine (H00010) we will ATTACH ...         *\n*---------------------------------------------------------------------*\n         L     R15,@_VolTbl_Ptr        A(Volume Table)\n         L     R15,VolTbl_Hdr_Count-VolTbl(R15) Get number of volumes\n         CHI   R15,1                   Doing more than 1?\n         JNH   E00160                  No, no need to IDENTIFY\n         L     R0,PSATNEW-PSA(0)       Yes, get A(our TCB)\n         SLL   R0,4                    Make room for 'sign'\n         ST    R0,@E_DBLWD+4           Save it\n         OI    @E_DBLWD+7,X'0F'        Pack it\n         UNPK  @E_H00010_IDENTIFY_ID+1(7),@E_DBLWD+4(4) Unpack it\n         LA    R15,E_Hex_TrTab         A(Translate Table)\n         AHI   R15,-240                adjust it\n         TR    @E_H00010_IDENTIFY_ID+1(7),0(R15) Make it readable\n         MVI   @E_H00010_IDENTIFY_ID,C'H' Init 1st char\n         LARL  R1,H00010               A(Our routine)\n         IDENTIFY EPLOC=@E_H00010_IDENTIFY_ID, and let MVS know        +\n               ENTRY=(1)                about it\n\nE00160   DS    0H\n*---------------------------------------------------------------------*\n*    Initialize our timer total, and the number of completed subtasks.*\n*    These are used to 'heuristically' set the timer values for the   *\n*    STIMERMs used in H00010 ...                                      *\n*---------------------------------------------------------------------*\n         LA    R0,0                    Clear work register\n         ICM   R15,B'1111',@_VolTbl_Ptr A(VolTbl)\n         JZ    E80010                  Nothing, exit quick smart\n         ST    R0,VolTbl_Hdr_LSPACE_Avg-VolTbl_Hdr(R15)\n         ST    R0,VolTbl_Hdr_LSPACE_Avg+4-VolTbl_Hdr(R15)\n\n*---------------------------------------------------------------------*\n*    Calculate the STIMERM Adjustment factor, based on the ratio of   *\n*    SubTasks to Logical Processors - this is used to try to prevent  *\n*    false RESERVEd messages when dispatching a lot of subtasks on    *\n*    a few LPs (we should really take processor speed and weights     *\n*    into account as well, but we don't know how).                    *\n*                                                                     *\n*    We arbitrarily calculate it as:                                  *\n*     ((#Subtasks/#LPs)/4)                                            *\n*---------------------------------------------------------------------*\n         L     R15,@_SubTask_Count      Get MaxTasks\n         LA    R14,0                    Clear other part of dividend\n         D     R14,@_LP_Count           Get ratio of Subtasks to LPs\n         SRL   R15,2                    divided by 4\n         LTR   R15,R15                  Anything?\n         JNZ   E00170                   Yes, OK\n         LHI   R15,1                    No, default to 1\nE00170   DS    0H\n         L     R14,@_VolTbl_Ptr         A(VolTbl)\n         ST    R15,VolTbl_Hdr_STIMERM_Adj-VolTbl_Hdr(R14) Save it\n\n*---------------------------------------------------------------------*\n*     Initialize the fields related to LSPACE timeouts                *\n*---------------------------------------------------------------------*\n         OI    VolTbl_Hdr_OW48527-VolTbl_Hdr(R14),L'VolTbl_Hdr_OW48527\n         MVC   VolTbl_Hdr_MaxLWait-VolTbl_Hdr(L'VolTbl_Hdr_MaxLWait,R14+\n               ),@_MaxLWait\n\n*---------------------------------------------------------------------*\n*     Lower our dispatching priority, so that we can ATTACH our       *\n*    subtasks with our original (higher) priority (most of the elap-  *\n*    sed time in the subtasks is spent WAITing for LSPACE).           *\n*---------------------------------------------------------------------*\n         TM    @_CHAP_Done,L'@_CHAP_Done Have we already CHAPped?\n         JO    E00170A                  Yes, skip\n         CHAP  -1,'S'                   No, do it now\n         OI    @_CHAP_Done,L'@_CHAP_Done and set our flag\n\nE00170A  DS    0H\n*---------------------------------------------------------------------*\n*     ... and get some storage for our ATTACHed tasks, as described   *\n*    in the SubTask_Area DSECT.                                       *\n*---------------------------------------------------------------------*\n         L     R0,@_SubTask_Count       Number of SubTasks\n         MHI   R0,SubTask_Area_Ent_Length * length per sub-task\n         AHI   R0,SubTask_Area_Hdr_Length + header length\n\n         BASR  R2,0\n         USING (*,E00170C_End-1),R2\n         STORAGE OBTAIN,                Go get some storage            +\n               LENGTH=(0)                this long\nE00170C_End DS  0H\n         DROP  R2\n\n         ST    R1,@_SubTask_Area_Ptr    Save its address\n         ST    R0,SubTask_Area_Hdr_Len-SubTask_Area(R1)  Save length\n         L     R0,@_SubTask_Count       Number of SubTasks\n         ST    R0,SubTask_Area_Hdr_Count-SubTask_Area(R1) Save #\n\n         TM    @_OW48527,L'@_OW48527    Yes, is OW48527 present?\n         JO    E00170E                  Yes, OK\n\n*---------------------------------------------------------------------*\n*    Set ourselves non-swappable - if we are swappable, and we get    *\n*   hung up on a RESERVEd volume, SRM will try to swap us out. To do  *\n*   do, (s)he must terminate our I/O, and while (s)he is trying to do *\n*   this, any asychronous processing (such as STIMERM Exits) will be  *\n*   suppressed. In our case, it is the STIMERM Exit that will allow   *\n*   the I/O to be terminated, so we have to run non-swappable.        *\n*                                                                     *\n*    Note that we issue STAX DEFER before we do this (STAX in a       *\n*   non-TSO environment seems to be benign).                          *\n*---------------------------------------------------------------------*\n         MVC   @E_TIME,E_TIME           MOVE Time macro\n         TIME  STCK,                    Get the current time           +\n               @E_Time_Area,             return it here                +\n               LINKAGE=SYSTEM,           as recommended by IBM         +\n               MF=(E,@E_TIME)            staying re-entrant\n         MVC   @E_NSwap_Start,@E_Time_Area  Save DONTSWAP TOD\n\n         MVC   @E_STAX,E_STAX           Move STAX Macro\n         STAX  DEFER=YES,               Defer Attentions               +\n               MF=(E,@E_STAX)            staying re-entrant\n\n         SYSEVENT DONTSWAP              Make ourselves non-swappable\n\nE00170E  DS    0H\n*---------------------------------------------------------------------*\n*     Point to our ECBLIST area ...                                   *\n*---------------------------------------------------------------------*\n         L     R10,@_SubTask_Area_Ptr   A(SubTask_Area)\n         AHI   R10,SubTask_Area_Hdr_Length Point past header\n         L     R8,@_SubTask_Count       Get number we have to do\n\n*---------------------------------------------------------------------*\n*    ... initialize the area for each sub-task ...                    *\n*---------------------------------------------------------------------*\nE00180   DS    0H\n         XC    0(SubTask_Area_Ent_Length,R10),0(R10)  Clear entry\n\n*---------------------------------------------------------------------*\n*    ... set up the parm list for the subtask ...                     *\n*---------------------------------------------------------------------*\n         LA    R15,@_Dynam              A(Dynamic area)\n         ST    R15,SubTask_Area_Ent_Parms-SubTask_Area_Ent(R10)\n         L     R15,@E_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)\n         ST    R15,SubTask_Area_Ent_Parms+4-SubTask_Area_Ent(R10)\n         L     R15,@E_24Bit_Stack_Ptr_Ptr A(24-bit Stack Pointer)\n         ST    R15,SubTask_Area_Ent_Parms+8-SubTask_Area_Ent(R10)\n         L     R15,@_VolTbl_Ptr          A(VolTbl)\n         ST    R15,SubTask_Area_Ent_Parms+12-SubTask_Area_Ent(R10)\n\n         LA    R1,SubTask_Area_Ent_Parms-SubTask_Area_Ent(R10)\n\n*---------------------------------------------------------------------*\n*    ... and ATTACH (or BASR, if we are doing only 1 volume).         *\n*---------------------------------------------------------------------*\n         L     R15,@_VolTbl_Ptr         A(Volume Table)\n         L     R15,VolTbl_Hdr_Count-VolTbl(R15) Get number of volumes\n         CHI   R15,1                    Doing more than 1?\n         JH    E00190                   Yes, use ATTACH\n         BRAS  R14,H00010               No, just go do it\n         OI    SubTask_Area_Ent_ECB-SubTask_Area_Ent(R10),X'40' Done\n         LA    R1,0                     Clear 'TCB pointer'\n         J     E00200                   and skip\n\nE00190   DS    0H\n         MVC   @E_ATTACHX,E_ATTACHX     Move ATTACH parms\n         BASR  R2,0\n         USING (*,E00190_End-1),R2\n         ATTACHX EPLOC=@E_H00010_IDENTIFY_ID,  ATTACH H00010           +\n               ECB=(10),                 POST this ECB when complete   +\n               SZERO=YES,                Share SubPool 0               +\n               ASYNCH=YES,               Allow subtask asynch exits    +\n               DPMOD=1,                  Run at a higher priority      +\n               MF=(E,(1)),               Parmlist area                 +\n               SF=(E,@E_ATTACHX)         keep ourselves reentrant\nE00190_End DS  0H\n         DROP  R2\n\nE00200   DS    0H\n         ST    R1,SubTask_Area_Ent_TCB-SubTask_Area_Ent(R10) A(TCB)\n\n         AHI   R10,SubTask_Area_Ent_Length  A(next sub-task area)\n         BRCT  R8,E00180                and continue\n\n         TM    @_OW48527,L'@_OW48527    Yes, is OW48527 present?\n         JO    E00230                   Yes, all done\n\n*---------------------------------------------------------------------*\n*    WAIT for our H00010 instances to complete                        *\n*---------------------------------------------------------------------*\n         L     R0,@_SubTask_Count       Nbr ECBs to WAIT for\n         CHI   R0,1                     More than 1?\n         JNH   E00210                   No, we BASRed, not ATTACHed\n         LA    R1,@E_Parms              A(Parms)\n         BRAS  R14,S00010               Wait for our subtasks\n\nE00210   DS    0H\n*---------------------------------------------------------------------*\n*     We are done - make ourselves swappable again ...                *\n*---------------------------------------------------------------------*\n         SYSEVENT OKSWAP                We can be swapped out now\n\n         MVC   @E_STAX,E_STAX           Move STAX Macro\n         STAX  DEFER=NO,                Allow Attentions               +\n               MF=(E,@E_STAX)            staying re-entrant\n\n*---------------------------------------------------------------------*\n*     ... calculate the time we were non-swappable ...                *\n*---------------------------------------------------------------------*\n         MVC   @E_TIME,E_TIME           MOVE Time macro\n         TIME  STCK,                    Get the current time           +\n               @E_Time_Area,             return it here                +\n               LINKAGE=SYSTEM,           as recommended by IBM         +\n               MF=(E,@E_TIME)            staying re-entrant\n         LM    R14,R15,@E_Time_Area     Get current time\n         SL    R15,@E_NSwap_Start+4     Calculate\n         JNM   E00220                   No borrow, skip\n         SL    R14,=FL4'1'              Borrow, reduce\nE00220   DS    0H\n         SL    R14,@E_NSwap_Start       Calculate\n         STM   R14,R15,@_NSwap_Time     Save Non-Swap time\n\n*---------------------------------------------------------------------*\n*     ... and exit.                                                   *\n*---------------------------------------------------------------------*\n         J     E00230                   and skip\n\nE00230   DS    0H\n*---------------------------------------------------------------------*\n*     Clear the return code, and exit                                 *\n*---------------------------------------------------------------------*\n         LA    R15,0                    Clear return code\n         J     E90010                   and exit\n\nE80010   DS    0H\n*---------------------------------------------------------------------*\n*   We cannot, or should not, issue LSPACEs, so we will POST all the  *\n*  appropriate lines as complete ...                                  *\n*---------------------------------------------------------------------*\n         ICM   R9,B'1111',@_VolTbl_Ptr  A(Table of Volumes)\n         JZ    E80016                   Nothing, skip\n         ICM   R10,B'1111',VolTbl_Hdr_Count-VolTbl_Hdr(R9) Get count\n         JZ    E80016                   None, skip\n         AHI   R9,VolTbl_Ent-VolTbl     Point to 1st entry\nE80012   DS    0H\n         TM    VolTbl_Ent_Stats_31Stack-VolTbl_Ent(R9),L'VolTbl_Ent_Sta+\n               ts_31Stack\n         JO    E80014                   Stack Stats line, skip it\n         TM    VolTbl_Ent_Stats_24Stack-VolTbl_Ent(R9),L'VolTbl_Ent_Sta+\n               ts_24Stack\n         JO    E80014                   Stack Stats line, skip it\n         TM    VolTbl_Ent_Stats_CPUTime-VolTbl_Ent(R9),L'VolTbl_Ent_Sta+\n               ts_CPUTime\n         JO    E80014                   CPU Stats, skip it\n\n         L     R0,VolTbl_Ent_ECB-VolTbl_Ent(R9) Current ECB\n         TM    VolTbl_Ent_ECB-VolTbl_Ent(R9),X'80' Anyone WAITing?\n         JO    E80013                   Yes, we need to POST\n         L     R1,=XL4'40000000'        No, POST code of 0\n         CS    R0,R1,VolTbl_Ent_ECB-VolTbl_Ent(R9) Pseudo-POST it\n         JZ    E80014                   OK, skip the real POST\nE80013   DS    0H\n         POST  VolTbl_Ent_ECB-VolTbl_Ent(R9),0 POST line as complete\n\nE80014   DS    0H\n         AHI   R9,VolTbl_Ent_Len        A(Next entry)\n         BRCT  R10,E80012               and check again\n\n*---------------------------------------------------------------------*\n*   ... and if there are any Subtask Stats lines, get rid of them ... *\n*---------------------------------------------------------------------*\n         L     R15,@_VolTbl_Ptr         A(Volume table)\n         ICM   R1,B'1111',VolTbl_Hdr_SubT_Off-VolTbl_Hdr(R15)\n         JZ    E80016                   No SubTask stats, skip\n         AHI   R1,-VolTbl_Hdr_Length    Nbr lines\n         LA    R0,0                      excluding\n         D     R0,=AL4(VolTbl_Ent_Len)   Subtask Stats\n         ST    R1,VolTbl_Hdr_Count-VolTbl_Hdr(15) Update nbr lines\n         LA    R1,0                      and clear offset\n         ST    R1,VolTbl_Hdr_SubT_Off-VolTbl_Hdr(R15)\n\nE80016   DS    0H\n*---------------------------------------------------------------------*\n*   ... POST the table as complete ...                                *\n*---------------------------------------------------------------------*\n         ICM   R15,B'1111',@_VolTbl_Ptr A(Table of Volumes)\n         JZ    E80018                   None, skip\n         L     R0,VolTbl_Hdr_ECB-VolTbl_Hdr(R15) Current ECB\n         TM    VolTbl_Hdr_ECB-VolTbl_Hdr(R15),X'80' Anyone WAITing?\n         JO    E80017                   Yes, we need to POST\n         L     R1,=XL4'40000000'        No, POST code of 0\n         CS    R0,R1,VolTbl_Hdr_ECB-VolTbl_Hdr(R15) Pseudo-POST it\n         JZ    E80018                   OK, skip the real POST\nE80017   DS    0H\n         POST  VolTbl_Hdr_ECB-VolTbl_Hdr(R15),0 POST table as complete\n\nE80018   DS    0H\n*---------------------------------------------------------------------*\n*   ... and exit with a return code of 4.                             *\n*---------------------------------------------------------------------*\n         LA    R15,4                    Nothing good happened\n         J     E90010                   and exit\n\nE90010   DS    0H\n         LR    R3,R15                 Save return code\n\n*-------------------------------------------------------------------*\n*    DELETE H00010 (which we IDENTIFYed earlier)                    *\n*-------------------------------------------------------------------*\n         CLI   @E_H00010_IDENTIFY_ID,C'H'    Did we IDENTIFY?\n         JNO   E90020                 No, skip\n         DELETE EPLOC=@E_H00010_IDENTIFY_ID  Yes, Un-IDENTIFY\n         XC    @E_H00010_IDENTIFY_ID,@E_H00010_IDENTIFY_ID\n\nE90020   DS    0H\n*-------------------------------------------------------------------*\n*    If we are running under IKJEFTSR, update @_CPU_Time_Used       *\n*   with the time we spent (because we are running under a          *\n*   separate TCB).                                                  *\n*-------------------------------------------------------------------*\n         TM    @_OW48527,L'@_OW48527  OW48527 installed?\n         JO    E90040                 Yes, skip\n\n         TM    @_IKJEFTSR,L'@_IKJEFTSR Running because of IKJEFTSR?\n         JNO   E90040                  No, skip\n\n         TIMEUSED STORADR=@E_DBLWD,     Get CPU time used              +\n               LINKAGE=SYSTEM,           as recommended by IBM         +\n               CPU=MIC                   get it in microseconds\n         LM    R14,R15,@_CPU_Time_Used  Get current CPU Time used\n         AL    R15,@E_DBLWD+4           Bump it\n         BRC   12,E90030                No Carry, OK\n         AL    R14,=FL4'1'              Carry, bump\nE90030   DS    0H\n         AL    R14,@E_DBLWD             Bump high-order word\n         STM   R14,R15,@_CPU_Time_Used  Save CPU Time\n\nE90040   DS    0H\n*-------------------------------------------------------------------*\n*    Free up our local storage ...                                  *\n*-------------------------------------------------------------------*\n         LA    R1,@E_Dynam              A(Local storage)\n         L     R2,@E_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         L     R13,4(0,R13)             Rescue A(HSA)\n\n         SSCSTACK POP,                  Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=(R2)                on this stack\n\n*-------------------------------------------------------------------*\n*    ... and return to caller                                       *\n*-------------------------------------------------------------------*\n         LR    R15,R3                   Restore return code\n\n         L     R14,12(0,R13)            Restore return address\n         LM    R0,R12,20(R13)           Restore other registers\n         BSM   0,R14                    and return\n\nE_Literals            DS   0H\n\nE_IKJEFTSR_Flags      EQU  *            Flag bytes for IKJEFTSR\n                      DC   X'00'         Must be 0\n                      DC   X'00'         Invoke in isolated environ\n                      DC   X'01'         Dump if abend\n                      DC   X'02'         Invoking a program\n\nE_IKJEFTSR_TimeStamp  EQU  *\n                      DC   C'&PGMNAME'\n                      DC   C'&VERSION'\n                      DC   C'&SYSDATC'\n                      DC   C'&SYSTIME'\nE_IKJEFTSR_TimeStamp_Length EQU *-E_IKJEFTSR_TimeStamp\n\n\nE_TIME                TIME  LINKAGE=SYSTEM, Get the time               +\n               MF=L                      keep ourselves reentrant\nE_TIME_Length         EQU *-E_TIME\n\nE_ATTACHX             ATTACHX EP=0,     ATTACH something               +\n               ECB=0,                    POST this ECB when complete   +\n               SZERO=YES,                Share SubPool 0               +\n               ASYNCH=YES,               Allow subtask asynch exits    +\n               DPMOD=5,                  Run at a higher priority      +\n               SF=L                      keep ourselves reentrant\nE_ATTACHX_Length      EQU  *-E_ATTACHX\n\nE_STAX                STAX DEFER=YES, Suspend Attention Interrupts     +\n               MF=L                      keep ourselves reentrant\nE_STAX_Length         EQU  *-E_STAX\n\nE_Hex_TrTab           DC   C'0123456789ABCDEF'\n\n                      LTORG\n\nE_Literals_End        DS    0H\n\n\n@E_Dynam                  DSECT        Dynamic area for E00000\n                          DS    18F     O/S Style save area\n@E_31Bit_Stack_Ptr_Ptr    DS    AL4     A(31-bit Stack Ptr)\n@E_24Bit_Stack_Ptr_Ptr    DS    AL4     A(24-bit Stack Ptr)\n@E_DBLWD                  DS    D       Work area\n\n@E_NSwap_Start            DS    DL8     STCK at DONTSWAP\n\n@E_H00010_IDENTIFY_ID     DS    CL8     IDENTIFY Name\n\n@E_Macro                  DS    0D      Macros\n@E_TIME                   DS    CL(E_TIME_Length) TIME Macro area\n                          DS    0D\n@E_Time_Area              DS    XL16     Data returned by TIME\n@E_WkArea                 DS    CL10     EDit Word Area\n                          ORG   @E_Macro\n@E_ATTACHX                DS    CL(E_ATTACHX_Length) ATTACHX Macro area\n                          ORG   @E_Macro\n@E_STAX                   DS    CL(E_STAX_Length)  STAX Macro area\n                          ORG   @E_Macro\n@E_IKJEFTSR_Parms         DS    7AL4     Parm List for IKJEFTSR\n@E_IKJEFTSR_PgmName       DS    CL8      Program name\n@E_IKJEFTSR_PgmName_Length DS   FL4      Program name length\n@E_IKJEFTSR_ABEND         DS    FL4      Abend code area\n@E_IKJEFTSR_Pgm_Parm_Ptrs DS    2AL4     Pgm parm pointers\n\n@E_IKJEFTSR_Pgm_Parm1     DS    CL6      Len + A(@_Dynam)\n@E_IKJEFTSR_Pgm_Parm2     DS    CL18     Len + 16 bytes of @_Dynam\n                          ORG   ,       End of Macros\n\n@E_Parms                  DS    0F      Parms for called rtns\n@E_Parms_Std              DS    3AL4     Standard 3 parms\n                          ORG   ,\n                          DS    0D       Alignment\n@E_Dynam_Length           EQU   *-@E_Dynam      Length of storage\n\n&PGMNAME CSECT\n\n         DROP  ,\n         POP   USING\n         TITLE 'F00010: Output Results'\n\n         PUSH  USING\n\nF00010   DS    0H\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Routine   : F00010                                                 *\n*                                                                     *\n*  Abstract  : Display results of LSPACE stuff                        *\n*                                                                     *\n*  Inputs    : R1 : ---> A(@_Dynam)                                   *\n*                        A(31-bit Stack Pointer)                      *\n*                        A(24-bit Stack Pointer)                      *\n*  Outputs   : R15: 0                                                 *\n*                                                                     *\n*  Notes     : Uses the Info Table built by D00010, and               *\n*               whose address is in @_VolTbl_Ptr                      *\n*              For ISPF output,                                       *\n*                Invoke ISPF processor (G00010)                       *\n*              For a TSO Cmd,                                         *\n*               PUTLINE for each unit                                 *\n*              For a Batch job,                                       *\n*               Write to SYSPRINT for each unit                       *\n*                                                                     *\n*  History:    1990/06/11 SDDA030 - New                               *\n*              1999/05/27 SDDA030 - V2.6                              *\n*                                 - Used LIFO Stack for our dynamic   *\n*                                   areas.                            *\n*              1999/09/30 SDDA030 - V2.10                             *\n*                                 - Changed default sort order from   *\n*                                   descending volser to none.        *\n*                                 - Do STLINENO stuff and build       *\n*                                   PUTLINE CBs here instead of C00010*\n*                                 - Removed generation of Hdr1-3 in   *\n*                                   batch - now done in Y00010.       *\n*              2000/01/19 SDDA030 - V2.11                             *\n*                                 - Added SORT() keywords to F_TBLOFF.*\n*                                 - Passed sort parms to I00010 as    *\n*                                   pointers.                         *\n*                                 - Passed sort direction to I00010.  *\n*                                   Used 24-bit stack for STLINENO.   *\n*                                 - Filled in values in Stack Stats   *\n*                                   lines.                            *\n*              2000/05/23 SDDA030 - V2.12                             *\n*                                 - Added messages for:               *\n*                                    - IOSCDR unavailable             *\n*                                    - ISPF services unavailable      *\n*                                 - Split out ISPF output handling to *\n*                                   G00010.                           *\n*                                 - Invoked V00010 to update stats    *\n*                                   lines.                            *\n*              2001/02/01 SDDA030 - V2.13                             *\n*                                 - Removed IOSCDR message            *\n*                                 - Added messages for LNKLST and     *\n*                                   IJEFTSR errors.                   *\n*              2001/02/26 SDDA030 - V2.14                             *\n*                                 - Checked Terminal Line Size when   *\n*                                   doing PUTLINEs.                   *\n*              2002/06/11 SDDA030 - V2.18                             *\n*                                 - WAIT for VolTbl_Ent to be populated\n*                                   before outputting                 *\n*              2006/04/21 SDDA030 - V2.24                             *\n*                                 - Used standardized calling sequence*\n*                                 - Added 'Internal Error' and        *\n*                                   'Incompatible OS' messages.       *\n*                                 - Added 'Insufficient Storage' msg  *\n*              ____/__/__ _______                                     *\n*                                                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         STM   R14,R12,12(R13)          Save callers registers\n         LARL  R11,F_Literals           Point to our literals\n         USING (F_Literals,F_Literals_End),R11 Tell the assembler\n\n         L     R12,0(0,R1)              A(@_Dynam)\n         USING @_Dynam,R12              Tell the assembler\n\n*-------------------------------------------------------------------*\n*    Get an area on the stack for our local storage                 *\n*-------------------------------------------------------------------*\n         L     R2,4(0,R1)               A(31-bit stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         SSCSTACK PUSH,                 Get stack area                 +\n               LEN=@F_Dynam_Length,      this long                     +\n               STACK=(R2)                using this stack\n\n         LR    R3,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LHI   R1,@F_Dynam_Length        Its length\n         LA    R14,0                    Clear source address\n         LA    R15,0                     and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R3                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*-------------------------------------------------------------------*\n         ST    R13,4(0,R1)              Chain\n         ST    R1,8(0,R13)               saveareas\n         LR    R13,R1                   Load dynam base\n         USING @F_Dynam,R13             Assign a base\n         L     R15,@F_Dynam+4           Get A(HSA)\n         LM    R0,R3,20(R15)            Restore callers registers\n\n         L     R15,4(0,R1)              A(31-bit Stack Pointer)\n         ST    R15,@F_31Bit_Stack_Ptr_Ptr Save it\n         L     R15,8(0,R1)              A(24-bit Stack Pointer)\n         ST    R15,@F_24Bit_Stack_Ptr_Ptr Save it\n\n*--------------------------------------------------------------------*\n*   Initialize our standard parmlist                                 *\n*--------------------------------------------------------------------*\n         LA    R15,@_Dynam              A(Dynamic area)\n         ST    R15,@F_Parms_Std         Save it\n         L     R15,@F_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)\n         ST    R15,@F_Parms_Std+4       Save it\n         L     R15,@F_24Bit_Stack_Ptr_Ptr A(24-bit Stack Pointer)\n         ST    R15,@F_Parms_Std+8       Save it\n\n*---------------------------------------------------------------------*\n*   If everything worked OK, but we are suppressing all the output,   *\n*  we are done.                                                       *\n*---------------------------------------------------------------------*\n         ICM   R15,B'1111',@_VolTbl_Ptr A(VolTbl)\n         JZ    F00020                   None, skip\n         ICM   R15,B'1111',VolTbl_Hdr_Vols_Total-VolTbl_Hdr(R15)\n         JZ    F00020                   No volumes, skip\n         TM    @_LSPACE_Failed,L'@_LSPACE_Failed LSPACE problem?\n         JO    F00020                   Yes, skip\n         TM    @_VolTbl_GETMAIN_Err,L'@_VolTbl_GETMAIN_Err GETMAIN err?\n         JO    F00020                   Yes, skip\n\n         TM    @_No_Headings,L'@_No_Headings  Suppressing headings?\n         JNO   F00020                   No, skip\n         TM    @_No_Details,L'@_No_Details Suppressing detail?\n         JNO   F00020                   No, skip\n         TM    @_No_Totals,L'@_No_Totals  Suppressing Totals?\n         JNO   F00020                   No, skip\n         TM    @_Statistics,L'@_Statistics Producing Statistics?\n         JO    F00020                   Yes, skip\n\n         LA    R15,0                    Clear return code\n         J     F90010                   and exit\n\nF00020   DS    0H\n*---------------------------------------------------------------------*\n*   If there is anything to display ...                               *\n*---------------------------------------------------------------------*\n         ICM   R15,B'1111',@_VolTbl_Ptr A(VolTbl)\n         JZ    F00030                   None, skip the sort\n         ICM   R15,B'1111',VolTbl_Hdr_Vols_Total-VolTbl_Hdr(R15)\n         JZ    F00030                   No volumes, skip sort\n\n*---------------------------------------------------------------------*\n*   ... sort it, if required.                                         *\n*---------------------------------------------------------------------*\n         CLI   @_Sort_Field,C' '        Any sort?\n         JE    F00030                   No, skip\n\n         LA    R15,@_Sort_Field         A(Sort Field)\n         ST    R15,@F_Parms_I00010      Save it\n         LA    R15,@_Sort_Direction     A(Sort direction)\n         ST    R15,@F_Parms_I00010+4    Save it\n\n         LA    R1,@F_Parms              A(Parms)\n         BRAS  R14,I00010               Go sort the table\n\nF00030   DS    0H\n*---------------------------------------------------------------------*\n*   Set up any applicable error messages                              *\n*---------------------------------------------------------------------*\n         MVI   @F_ErrMsgL,C' '          Clear msg area\n         MVC   @F_ErrMsgL+1(L'@F_ErrMsgL-1),@F_ErrMsgL\n         MVC   @F_ErrMsgS,@F_ErrMsgL    Short message too\n\n         TM    @_OW48527,L'@_OW48527    APAR OW48527 installed?\n         JO    F00060                   Yes, skip IKJEFTSR stuff\n\n         TM    @_No_APF,L'@_No_APF      Are we APF'ed?\n         JNO   F00040                   Yes, skip\n*---------------------------------------------------------------------*\n*     - Insufficient APF                                              *\n*       not APFed even when invoked by IKJEFTSR, or IKJEFTSR failed   *\n*       with RC=14, Reas=18 or 34                                     *\n*---------------------------------------------------------------------*\n         MVC   @F_ErrMsgL(L'F_EMsg02),F_EMsg02 Move APF msg\n         J     F00165                   and skip\nF00040   DS    0H\n         TM    @_IKJEFTSR_Err,L'@_IKJEFTSR_Err IKJEFTSR error?\n         JNO   F00050                   No, skip\n         L     R15,@_IKJEFTSR_RC        Yes, get IKJEFTSR RC\n         CHI   R15,20                   RC = 20?\n         JNE   F00045                   No, generic IKJEFTSR error\n         L     R15,@_IKJEFTSR_Reas      Yes, get reason code\n         CHI   R15,40                   Program not found?\n         JNE   F00045                   No, generic IKJEFTSR msg\n*---------------------------------------------------------------------*\n*     - Not in LNKLST/STEPLIB concatenation                           *\n*       IKJEFTSR couldn't find the module (RC=14,Reas=28)             *\n*---------------------------------------------------------------------*\n         MVC   @F_ErrMsgL(L'F_EMsg06),F_EMsg06 Move LNKLST msg\n         J     F00165                   and skip\nF00045   DS    0H\n*---------------------------------------------------------------------*\n*     - Unknown IKJEFTSR Error xx-yy                                  *\n*       Something else from IKJEFTSR xx: return code, yy:reason       *\n*---------------------------------------------------------------------*\n         MVC   @F_ErrMsgL(L'F_EMsg07),F_EMsg07 Move message\n         L     R15,@_IKJEFTSR_RC        Get ISPF failure return code\n         SLL   R15,4                    Make room for the sign\n         STH   R15,@F_DBLWD             Save it\n         OI    @F_DBLWD+1,X'0F'         Make it packed\n         UNPK  @F_DBLWD+2(3),@F_DBLWD(2) Unpack it\n         MVC   @F_ErrMsgL+F_EMsg07_RC-F_EMsg07(2),@F_DBLWD+3\n         TR    @F_ErrMsgL+F_EMsg07_RC-F_EMsg07(2),F_Hex_TrTab\n\n         L     R15,@_IKJEFTSR_Reas      Get ISPF failure reason code\n         SLL   R15,4                    Make room for the sign\n         STH   R15,@F_DBLWD             Save it\n         OI    @F_DBLWD+1,X'0F'         Make it packed\n         UNPK  @F_DBLWD+2(3),@F_DBLWD(2) Unpack it\n         MVC   @F_ErrMsgL+F_EMsg07_Reas-F_EMsg07(2),@F_DBLWD+3\n         TR    @F_ErrMsgL+F_EMsg07_Reas-F_EMsg07(2),F_Hex_TrTab\n         J     F00165                   And skip\nF00050   DS    0H\n         TM    @_SYSCLOCK_Err,L'@_SYSCLOCK_Err Code mismatch?\n         JNO   F00060                   No, skip\n*---------------------------------------------------------------------*\n*     - TimeStamp mismatch                                            *\n*       IKJEFTSR invoked a different version of the code - could be   *\n*       caused by this pgm being in ISPLLIB                           *\n*---------------------------------------------------------------------*\n         MVC   @F_ErrMsgL(L'F_EMsg09),F_EMsg09\n         J     F00165                   and skip\nF00060   DS    0H\n         TM    @_Internal_Err,L'@_Internal_Err Internal error?\n         JNO   F00070                   No, skip\n*---------------------------------------------------------------------*\n*     - Unrecognized parm (probably on re-invocation via IKJEFTSR)    *\n*---------------------------------------------------------------------*\n         MVC   @F_ErrMsgL(L'F_EMsg11),F_EMsg11\n         J     F00165                   and skip\nF00070   DS    0H\n         TM    @_Incompatible_OS,L'@_Incompatible_OS Incompatible?\n         JNO   F00110                   No, skip\n*---------------------------------------------------------------------*\n*     - CSVQUERY function unavailable                                 *\n*---------------------------------------------------------------------*\n         MVC   @F_ErrMsgL(L'F_EMsg05),F_EMsg05\n         L     R14,CVTPTR               A(CVT)\n         L     R15,CVTECVT-CVT(0,R14)   A(EVCT)\n         MVC   @F_ErrMsgL+L'F_EMsg05(L'ECVTPNAM),ECVTPNAM-ECVT(R15)\n         LA    R1,@F_ErrMsgL+L'F_EMsg05+L'ECVTPNAM-1\n         LA    R0,@F_ErrMsgL+L'F_EMsg05\nF00080   DS    0H\n         CLI   0(R1),C' '               Last significant character\n         JNE   F00090                   Yes, skip\n         S     R1,=FL4'1'               No, back up a byte\n         CR    R1,R0                    Too far?\n         JH    F00080                   No, check again\nF00090   DS    0H\n         TM    CVTOSLV5-CVT(R14),CVTZOSE z/OS.e?\n         JZ    F00100                   No, skip\n         MVC   1(2,R1),=C'.e'           Yes, say so\n         LA    R1,2(0,R1)               and bump pointer\nF00100   DS    0H\n         MVC   2(L'ECVTPVER,R1),ECVTPVER-ECVT(R15)  Version\n         MVI   2+L'ECVTPVER(R1),C'.'    Separator\n         MVC   2+L'ECVTPVER+1(L'ECVTPREL,R1),ECVTPREL-ECVT(R15) Rel\n         MVI   2+L'ECVTPVER+1+L'ECVTPREL(R1),C'.'    Separator\n         MVC   2+L'ECVTPVER+1+L'ECVTPREL+1(L'ECVTPMOD,R1),ECVTPMOD-ECVT+\n               (R15)\n         J     F00165                   And skip\nF00110   DS    0H\n         TM    @_VolTbl_GETMAIN_Err,L'@_VolTbl_GETMAIN_Err GETMAIN?\n         JNO   F00150                   No, skip\n*---------------------------------------------------------------------*\n*     - Insufficient Storage                                          *\n*---------------------------------------------------------------------*\n         MVC   @F_ErrMsgL(L'F_EMsg10),F_EMsg10\n         ICM   R15,B'1111',@_VolTbl_Ptr  A(VolTbl)\n         JZ    F00165                   None, skip\n         L     R0,VolTbl_Hdr_Vols_Eligible-VolTbl_Hdr(R15)\n         S     R0,VolTbl_Hdr_Vols_Total-VolTbl_Hdr(R15)\n         JP    F00120                   Some omitted, skip\n         MVC   @F_ErrMsgL+L'F_EMsg10+1(41),=C'Some totals/statistics li+\n               nes may be missing'\n         J     F00165                   all done\nF00120   DS    0H\n         CVD   R0,@F_DBLWD              Pack missing vols\n         MVC   @F_ErrMsgL+L'F_EMsg10(10),=X'40206B2020206B202120'\n         LA    R1,@F_ErrMsgL+L'F_EMsg10+9 Prime pointer\n         LR    R14,R1                  Save it\n         EDMK  @F_ErrMsgL+L'F_EMsg10(10),@F_DBLWD+4\n         LA    R15,@F_ErrMsgL+L'F_EMsg10+1 Left adjust start\n         CR    R1,R15                   Do we need to adjust?\n         JNH   F00140                   No, skip\n         SR    R14,R1                   Yes, EX len of number\n         EX    R14,F_EX1                Left adjust it\n         AR    R15,R14                  A(Last char)\nF00140   DS    0H\n         MVC   1(16,R15),=C' volumes omitted'\n         J     F00165                   and skip\nF00150   DS    0H\n         ICM   R15,B'1111',@_VolTbl_Ptr A(VolTbl)\n         JZ    F00160                   None, skip\n         ICM   R15,B'1111',VolTbl_Hdr_Vols_Total-VolTbl_Hdr(R15)\n         JNZ   F00170                   Got some data, skip\nF00160   DS    0H\n*---------------------------------------------------------------------*\n*     - VolTbl empty                                                  *\n*---------------------------------------------------------------------*\n         MVC   @F_ErrMsgS(4),=C'None'   No data\n         MVC   @F_ErrMsgL(L'F_EMsg01),F_EMsg01 Move No data msg\n         J     F00170                   and skip\n\nF00165   DS    0H\n         MVC   @F_ErrMsgS(10),=C'Incomplete' Flag table as incomplete\n\nF00170   DS    0H\n         NI    @_ReDisplay,X'FF'-L'@_ReDisplay  Off redisplay flag\n\n*---------------------------------------------------------------------*\n*      If output is via ISPF, go do it                                *\n*---------------------------------------------------------------------*\n         TM    @_Batch_Environ,L'@_Batch_Environ Are we Batch?\n         JO    F00190                   Yes, skip\n\n         TM    @_ISPF_SPACE,L'@_ISPF_SPACE ISPF Output requested?\n         JO    F00180                   Yes, skip\n         TM    @_ISPF_EDIF,L'@_ISPF_EDIF ISPF Output requested?\n         JO    F00180                   Yes, skip\n         TM    @_ISPF_BRIF,L'@_ISPF_BRIF ISPF Output requested?\n         JZ    F00190                   No, skip\n\nF00180   DS    0H\n         LA    R15,@F_ErrMsgS           A(Short error msg)\n         ST    R15,@F_Parms_G00010      Save it\n         LA    R15,@F_ErrMsgL           A(Long error msg)\n         ST    R15,@F_Parms_G00010+4    Save it\n\n         LA    R1,@F_Parms              A(Parms)\n         BRAS  R14,G00010               Go do ISPF stuff\n\n         TM    @_ReDisplay,L'@_ReDisplay Do we need to display again?\n         JO    F00170                   Yes, go do it\n         LTR   R15,R15                  No, did it work?\n         JZ    F90010                   Yes, exit quick smart\n         STH   R15,@F_G00010_RC         No, save return code\n         STH   R0,@F_G00010_Reas         and reason code\n\nF00190   DS    0H\n*---------------------------------------------------------------------*\n*      Perform initialization stuff for our environment               *\n*---------------------------------------------------------------------*\n         TM    @_TSO_Command,L'@_TSO_Command Is this a TSO command?\n         JZ    F00240                   No, skip\n\n*---------------------------------------------------------------------*\n*   TSO Command Processing - Clear the screen, and build our          *\n*  PUTLINE control blocks                                             *\n*---------------------------------------------------------------------*\n         L     R15,@F_24Bit_Stack_Ptr_Ptr A(24-bit Stack pointer)\n         ICM   R0,B'1111',0(R15)        A(24-bit stack)\n         JNZ   F00200                   OK, skip\n\n         LHI   R0,@_24Bit_Stack_Length  Length of storage we need\n         SSCSTACK INIT,                 Go get our storage             +\n               LEN=(R0),                 this long                     +\n               LOC=24                    below the line\n\n         L     R15,@F_24Bit_Stack_Ptr_Ptr A(24-bit Stack Pointer)\n         ST    R1,0(0,R15)              Update it\n\nF00200   DS    0H\n         L     R2,@F_24Bit_Stack_Ptr_Ptr A(24_bit Stack Pointer)\n         L     R2,0(0,R2)               A(24-bit Stack)\n         SSCSTACK PUSH,                 Get stack area                 +\n               LEN=F00230_End-F00230,    this long                     +\n               STACK=(R2)                using this stack\n\n         LR    R3,R1                    Save the address\n\n         LR    R1,R0                    Amount of storage we got\n         LR    R0,R3                    Point to it\n         LARL  R14,F00230                RMODE24 stuff)\n         LHI   R15,F00230_End-F00230    Length of STLINENO stuff\n         MVCL  R0,R14                   Move it\n\n         LR    R15,R3                   Point to the RMODE 24 stuff\n         BASR  R14,R15                  Go do it\n\n         L     R2,@F_24Bit_Stack_Ptr_Ptr A(24_bit Stack Pointer)\n         L     R2,0(0,R2)               A(24-bit Stack)\n         SSCSTACK POP,                  Free the stack area            +\n               ADDR=(R3),                starting here                 +\n               STACK=(R2)                on this stack\n\n*-------------------------------------------------------------------*\n*    ... and build the PUTLINE control blocks.                      *\n*-------------------------------------------------------------------*\n         L     R1,@_CPPL_Ptr            A(CPPL)\n         MVC   @F_IOPL+IOPLUPT-IOPL(L'IOPLUPT),CPPLUPT-CPPL(R1)\n         MVC   @F_IOPL+IOPLECT-IOPL(L'IOPLECT),CPPLECT-CPPL(R1)\n         LA    R15,@F_IOECB             A(Our ECB)\n         ST    R15,@F_IOPL+IOPLECB-IOPL Save it\n         LA    R15,@F_PLPB              A(PUTLINE Parm block)\n         ST    R15,@F_IOPL+IOPLIOPB-IOPL Save it\n         MVC   @F_PLPB,F_PLPB           Move PUTLINE Parm Block\n         LA    R15,@F_OLD               A(OLD)\n         ST    R15,@F_PLPB+4            Save in PLPB\n         LA    R15,0                    Clear work reg\n         ST    R15,@F_PLPB+8            Clear A(Format line)\n\n         LH    R1,@_LineSize            Get linesize from command line\n         LTR   R1,R1                    Anything?\n         JNZ   F00210                   Yup, skip\n         GTSIZE  ,                      Get terminal line size\n         AHI   R1,-1                     minus 1 byte\nF00210   DS    0H\n         LHI   R15,VolTbl_Ent_Display_Len Max len of data\n         LTR   R1,R1                    LINESIZE(MAX)?\n         JM    F00220                   Yes, use it\n         CR    R15,R1                   Can we display all the data?\n         JNH   F00220                   Yes, OK\n         LR    R15,R1                   No, display as much as we can\nF00220   DS    0H\n         AHI   R15,@F_VolTbl_Ent_Copy-@F_OLD Add len of OLD\n         STH   R15,@F_OLDLN             Save it\n         LA    R15,0                    Clear\n         STH   R15,@F_OLDOF              offset\n         J     F00270                   and skip\n\n*---------------------------------------------------------------------*\n*   This code fragment issues STLINENO. This code is moved to 24-bit  *\n*    storage, because the STLINENO SVC must be issued in AMODE 24.    *\n*---------------------------------------------------------------------*\n         PUSH  USING                    Save the USING environment\n         DROP  ,                        Free all current USINGs\n\nF00230   DS    0H\n         USING *,R15                    Assign temp base\n         STM   R0,R15,F00230_Save       Save callers registers\n         LR    R11,R15                  Load 'perm' base reg\n         DROP  R15                      Free temp\n         USING F00230,R11               Tell assembler about R11\n\n         STLINENO LINE=1                Clear the screen\n\n         LM    R0,R15,F00230_Save       Restore callers registers\n         BSM   0,R14                    And exit\n\n\nF00230_Save   DS   18F                  Save area\n              DS   0D                   Alignment\n\n         DROP  R11                      Free up base reg\n\nF00230_End   EQU        *               End of STLINENO Code\n\n         POP   USING                   Restore USING environment\n\nF00240   DS    0H\n*---------------------------------------------------------------------*\n*   Batch Job Processing                                              *\n*---------------------------------------------------------------------*\n         LHI   R0,4095                  Get count for Hdg0\n         LH    R15,@_Line_Count         Get current line count\n         CR    R15,R0                   Did C00010 start a new page?\n         JE    F00250                   No, we had better\n         LHI   R15,4094                 Yes, only Hdg1-3\n         J     F00260                   and skip\nF00250   DS    0H\n         LHI   R15,4090                 New page, Hdg0-3\nF00260   DS    0H\n         STH   R15,@_Line_Count         Save updated line count\n\n         J     F00270                   and skip\n\nF00270   DS    0H\n*---------------------------------------------------------------------*\n*   If we are here because ISPF output was requested, but we          *\n*  couldn't access ISPF DM services, say so now.                      *\n*---------------------------------------------------------------------*\n         TM    @_ISPF_SPACE,L'@_ISPF_SPACE ISPF Output requested?\n         JO    F00280                   Yes, skip\n         TM    @_ISPF_EDIF,L'@_ISPF_EDIF ISPF Output requested?\n         JO    F00280                   Yes, skip\n         TM    @_ISPF_BRIF,L'@_ISPF_BRIF ISPF Output requested?\n         JZ    F00300                   No, skip\n\nF00280   DS    0H\n         NI    @_ISPF_SPACE,X'FF'-L'@_ISPF_SPACE Not any more\n         NI    @_ISPF_EDIF,X'FF'-L'@_ISPF_EDIF Not any more\n         NI    @_ISPF_BRIF,X'FF'-L'@_ISPF_BRIF Not any more\n\n         TM    @_ISPF_Explicit,L'@_ISPF_Explicit ISPF specified?\n         JZ    F00300                   No, skip message\n\n         LA    R14,F_EMsg03             A(Source)\n         LHI   R15,L'F_EMsg03           Source Length\n         O     R15,=XL4'40000000'       Pad char of blank\n         LA    R0,@F_VolTbl_Ent_Copy    A(Target)\n         LHI   R1,@F_VolTbl_Ent_Copy_Len Target length\n         MVCL  R0,R14                   Move message\n         LH    R15,@F_G00010_RC         Get ISPF failure return code\n         SLL   R15,4                    Make room for the sign\n         STH   R15,@F_DBLWD             Save it\n         OI    @F_DBLWD+1,X'0F'         Make it packed\n         UNPK  @F_DBLWD+2(3),@F_DBLWD(2) Unpack it\n         MVC   @F_VolTbl_Ent_Copy+F_EMsg03_RC-F_EMsg03(2),@F_DBLWD+3\n         TR    @F_VolTbl_Ent_Copy+F_EMsg03_RC-F_EMsg03(2),F_Hex_TrTab\n\n         LH    R15,@F_G00010_Reas       Get ISPF failure reason code\n         SLL   R15,4                    Make room for the sign\n         STH   R15,@F_DBLWD             Save it\n         OI    @F_DBLWD+1,X'0F'         Make it packed\n         UNPK  @F_DBLWD+2(3),@F_DBLWD(2) Unpack it\n         MVC   @F_VolTbl_Ent_Copy+F_EMsg03_Reas-F_EMsg03(2),@F_DBLWD+3\n         TR    @F_VolTbl_Ent_Copy+F_EMsg03_Reas-F_EMsg03(2),F_Hex_TrTab\n\n         TM    @_TSO_Command,L'@_TSO_Command Is this a TSO command?\n         JZ    F00290                   No, skip\n\n         PUTLINE MF=(E,@F_IOPL)         Write it\n\n         LA    R14,F_EMsg04             A(Source)\n         LHI   R15,L'F_EMsg04           Source Length\n         O     R15,=XL4'40000000'       Pad char of blank\n         LA    R0,@F_VolTbl_Ent_Copy    A(Target)\n         LHI   R1,@F_VolTbl_Ent_Copy_Len Target length\n         MVCL  R0,R14                   Move message\n         PUTLINE MF=(E,@F_IOPL)         Write it\n         J     F00300                   and skip\n\nF00290   DS    0H\n         LA    R15,@F_VolTbl_Ent_Copy   A(Message)\n         ST    R15,@F_Parms_Y00010      Save it\n         LHI   R15,L'F_EMsg03           Length of message\n         ST    R15,@F_Parms_Y00010+4    Save it\n\n         LA    R1,@F_Parms              A(Parms)\n         BRAS  R14,Y00010               Output to SYSPRINT\n\n         LA    R15,F_EMsg04             A(Message)\n         ST    R15,@F_Parms_Y00010      Save it\n         LHI   R15,L'F_EMsg04           Length of message\n         ST    R15,@F_Parms_Y00010+4    Save it\n\n         LA    R1,@F_Parms              A(Parms)\n         BRAS  R14,Y00010               Output to SYSPRINT\n         J     F00300                   and skip\n\nF00300   DS    0H\n*---------------------------------------------------------------------*\n*   If we have an error message, put it out now                       *\n*---------------------------------------------------------------------*\n         CLI   @F_ErrMsgL,C' '          Anything?\n         JE    F00320                   Nope, skip\n\n         TM    @_TSO_Command,L'@_TSO_Command Is this a TSO command?\n         JNO   F00310                   No, skip\n\n         LA    R14,@F_ErrMsgL           A(Source)\n         LHI   R15,L'@F_ErrMsgL         Source Length\n         O     R15,=XL4'40000000'       Pad char of blank\n         LA    R0,@F_VolTbl_Ent_Copy    A(Target)\n         LHI   R1,@F_VolTbl_Ent_Copy_Len Target length\n         MVCL  R0,R14                   Move message\n         PUTLINE MF=(E,@F_IOPL)         Write it\n         J     F00320                   and skip\nF00310   DS    0H\n         LA    R15,@F_ErrMsgL           A(Message)\n         ST    R15,@F_Parms_Y00010      Save it\n         LHI   R15,L'@F_ErrMsgL         Len of data\n         ST    R15,@F_Parms_Y00010+4    Save it\n\n         LA    R1,@F_Parms              A(Parms)\n         BRAS  R14,Y00010               Output to SYSPRINT\n         J     F00320                   and skip\n\nF00320   DS    0H\n*---------------------------------------------------------------------*\n*   Common processing                                                 *\n*---------------------------------------------------------------------*\n         ICM   R15,B'1111',@_VolTbl_Ptr A(VolTbl)\n         JZ    F80010                   None, exit with error\n         ICM   R15,B'1111',VolTbl_Hdr_Vols_Total-VolTbl_Hdr(R15)\n         JZ    F80010                   No volumes, exit with error\n\n         TM    @_No_Headings,L'@_No_Headings  Headings wanted?\n         JO    F00400                   No, skip\n\n         TM    @_TSO_Command,L'@_TSO_Command Is this a TSO command?\n         JZ    F00400                   No, skip\n\n*---------------------------------------------------------------------*\n*   TSO Command processing for Headings                               *\n*---------------------------------------------------------------------*\n         ICM   R9,B'1111',@_VolTbl_Ptr  A(Volume Table)\n         JZ    F00400                   No vol tbl, skip headings\n         ICM   R10,B'1111',VolTbl_Hdr_Count-VolTbl_Hdr(R9) Get count\n         JZ    F00400                   None,skip headings\n         AHI   R9,VolTbl_Ent-VolTbl_Hdr Yes, point to first\n         USING VolTbl_Ent,R9            Assign a base\nF00370   DS    0H\n         TM    VolTbl_Ent_Heading_Line1,L'VolTbl_Ent_Heading_Line1\n         JO    F00380                   Yes, skip\n         TM    VolTbl_Ent_Heading_Line,L'VolTbl_Ent_Heading_Line\n         JZ    F00400                   End of headings, skip\nF00380   DS    0H\n         TM    VolTbl_Ent_ECB,X'40'     Has the line been populated?\n         JO    F00390                   Yes, skip\n         WAIT  ECB=VolTbl_Ent_ECB       Not yet, wait for it\nF00390   DS    0H\n         LA    R14,VolTbl_Ent_Display   A(Source)\n         LHI   R15,VolTbl_Ent_Display_Len Source Length\n         O     R15,=XL4'40000000'       Pad char of blank\n         LA    R0,@F_VolTbl_Ent_Copy    A(Target)\n         LHI   R1,@F_VolTbl_Ent_Copy_Len Target length\n         MVCL  R0,R14                   Move message\n         PUTLINE MF=(E,@F_IOPL)         Write it\n\n         AHI   R9,VolTbl_Ent_Len        Bump table pointer\n         BRCT  R10,F00370               and do next\n\n         DROP  R9                       Free our base\n\nF00400   DS    0H\n*---------------------------------------------------------------------*\n*   Common processing for VolTbl Entry                                *\n*---------------------------------------------------------------------*\n         ICM   R9,B'1111',@_VolTbl_Ptr  A(Volume Table)\n         JZ    F90010                   Nothing, exit\n         ICM   R10,B'1111',VolTbl_Hdr_Count-VolTbl_Hdr(R9) nbr ents\n         JZ    F90010                   Nothing, exit\n         AHI   R9,VolTbl_Ent-VolTbl     Point to first entry\n         USING VolTbl_Ent,R9            and assign a base\n\nF00410   DS    0H\n*--------------------------------------------------------------------*\n*     If this is a heading line, skip it                             *\n*--------------------------------------------------------------------*\n         TM    VolTbl_Ent_Heading_Line1,L'VolTbl_Ent_Heading_Line1\n         JO    F00470                   Yes, skip\n         TM    VolTbl_Ent_Heading_Line,L'VolTbl_Ent_Heading_Line\n         JO    F00470                   a heading, skip it\n\n*--------------------------------------------------------------------*\n*     If this is a line we want ...                                  *\n*--------------------------------------------------------------------*\n         TM    VolTbl_Ent_Detail_Line,L'VolTbl_Ent_Detail_Line\n         JNO   F00420                   No, skip\n         TM    @_No_Details,L'@_No_Details Do we want details?\n         JNO   F00440                   Yes, go process it\n         J     F00470                   No, ignore it\n\nF00420   DS    0H\n         TM    VolTbl_Ent_Total_Line,L'VolTbl_Ent_Total_Line Total?\n         JNO   F00430                   No, skip\n         TM    @_No_Totals,L'@_No_Totals Do we want totals?\n         JNO   F00440                   Yes, go process it\n         J     F00470                   No, ignore it\n\nF00430   DS    0H\n*--------------------------------------------------------------------*\n*     If this is a Statistics line, fill it in ...                   *\n*--------------------------------------------------------------------*\n         TM    VolTbl_Ent_Stats_Line,L'VolTbl_Ent_Stats_Line\n         JNO   F00440                   No, go display it\n\n         LA    R15,VolTbl_Ent           Point to the Volume Tbl entry\n         ST    R15,@F_Parms_V00010      Save it\n         LA    R1,@F_Parms              A(Parms)\n         BRAS  R14,V00010               Go process stats\n\nF00440   DS    0H\n         TM    VolTbl_Ent_ECB,X'40'     Has the line been populated?\n         JO    F00450                   Yes, skip\n         WAIT  ECB=VolTbl_Ent_ECB       Not yet, WAIT for it\n\nF00450   DS    0H\n*--------------------------------------------------------------------*\n*     ... and output this line, either via PUTLINE ...               *\n*--------------------------------------------------------------------*\n         TM    @_TSO_Command,L'@_TSO_Command Is this a TSO command?\n         JZ    F00460                   No, skip\n\n         LA    R14,VolTbl_Ent_Display   A(Source)\n         LHI   R15,VolTbl_Ent_Display_Len Source Length\n         O     R15,=XL4'40000000'       Pad char of blank\n         LA    R0,@F_VolTbl_Ent_Copy    A(Target)\n         LHI   R1,@F_VolTbl_Ent_Copy_Len Target length\n         MVCL  R0,R14                   Move message\n         PUTLINE MF=(E,@F_IOPL)         Write it\n         J     F00470                   and skip\n\nF00460   DS    0H\n*--------------------------------------------------------------------*\n*     ... or to SYSPRINT                                             *\n*--------------------------------------------------------------------*\n         LA    R15,VolTbl_Ent_Display   Data area\n         ST    R15,@F_Parms_Y00010      Save it\n         LHI   R15,VolTbl_Ent_Display_Len Len of data\n         ST    R15,@F_Parms_Y00010+4    Save it\n\n         LA    R1,@F_Parms              A(Parms)\n         BRAS  R14,Y00010               Go print it\n         J     F00470                   and skip\n\nF00470   DS    0H\n*--------------------------------------------------------------------*\n*     Point to next VolTbl Entry, and continue                       *\n*--------------------------------------------------------------------*\n         AHI   R9,VolTbl_Ent_Len        A(Next entry)\n         BRCT  R10,F00410               and continue\n         DROP  R9\n\nF00480   DS    0H\n*--------------------------------------------------------------------*\n*   We've finished displaying the table, so write it to OutFile, if  *\n*    required.                                                       *\n*--------------------------------------------------------------------*\n         SLR   R15,R15                  Clear return code\n         CLI   @_OutFile_DDName,C' '    Any output file?\n         JE    F00600                   No, just exit\n\n         LA    R15,@_OutFile_DDName     Yes, point to it\n         ST    R15,@F_Parms_X00010      Save it\n         TM    @_OutData_DISPLAY,L'@_OutData_DISPLAY\n         JNO   F00500                   No, skip\n         LA    R15,@_OutData_DISPLAY    Yes, point to it\n         J     F00520                   and skip\nF00500   DS    0H\n         TM    @_OutData_CB,L'@_OutData_CB\n         JNO   F00510                   No, skip\n         LA    R15,@_OutData_CB         Yes, point to it\n         J     F00520                   and skip\nF00510   DS    0H\n         LA    R15,@_OutData_ALL        All output\nF00520   DS    0H\n         ST    R15,@F_Parms_X00010+4    Save A(OutData Flag)\n         LA    R1,@F_Parms              A(Parm list)\n         BRAS  R14,X00010               Output to file, if necessary\n         LTR   R15,R15                  Did it work?\n         JZ    F00600                   Yes, exit\n\n*--------------------------------------------------------------------*\n*     OutFile processing failed - build our error message ...        *\n*--------------------------------------------------------------------*\n         MVI   @F_ErrMsgL,C' '          Clear msg area\n         MVC   @F_ErrMsgL+1(L'@F_ErrMsgL-1),@F_ErrMsgL\n         MVC   @F_ErrMsgL(L'F_Emsg12),F_EMsg12  Move msg start\n         MVC   @F_ErrMsgL+L'F_EMsg12+1(L'@_OutFile_DDName),@_OutFile_DD+\n               Name\n         LA    R15,@F_ErrMsgL+L'F_EMsg12+1+L'@_OutFile_DDName-1\nF00530   DS    0H\n         CLI   0(R15),C' '              End of DDName?\n         JNE   F00540                   yes, skip\n         BCT   R15,F00530               No, back up and try again\nF00540   DS    0H\n         MVC   2(21,R15),=C'not useable - ignored'\n\n*--------------------------------------------------------------------*\n*     ... and let the user know ...                                  *\n*--------------------------------------------------------------------*\n         TM    @_Batch_Environ,L'@_Batch_Environ Are we Batch?\n         JO    F00570                   Yes, skip\n         TM    @_ISPF_SPACE,L'@_ISPF_SPACE ISPF Output requested?\n         JO    F00550                   Yes, skip\n         TM    @_ISPF_EDIF,L'@_ISPF_EDIF ISPF Output requested?\n         JO    F00550                   Yes, skip\n         TM    @_ISPF_BRIF,L'@_ISPF_BRIF ISPF Output requested?\n         JZ    F00570                   No, skip\n\nF00550   DS    0H\n*--------------------------------------------------------------------*\n*     ... via ISPF ...                                               *\n*--------------------------------------------------------------------*\n         MVC   @F_LINKX,F_LINKX         Move LINK L-Form\n\n         LA    R15,=CL8'VDEFINE'        ISPF Function\n         ST    R15,@F_ISPF_Parms        Save it\n         LA    R15,=CL8'CHAR'           Character variables\n         ST    R15,@F_ISPF_Parms+12     Save it\n\n         LA    R15,=CL8'ZEDSMSG'        Variable name\n         ST    R15,@F_ISPF_Parms+4      Save it\n         LA    R15,=C'OutFile Error'    Short message\n         ST    R15,@F_ISPF_Parms+8      Save it\n         LA    R15,=AL4(13)             Length of message\n         ST    R15,@F_ISPF_Parms+16     Save it\n         OI    @F_ISPF_Parms+16,X'80'   Flag end of list\n\n         LARL  R2,F00560                A(Error return address)\n         LINKX EP=ISPLINK,              Link to ISPF Interface         +\n               ERRET=(2),                error here                    +\n               MF=(E,@F_ISPF_Parms),     passing these parms           +\n               SF=(E,@F_LINKX)           staying re-entrant\n\n         LA    R15,=CL8'ZEDLMSG'        Variable name\n         ST    R15,@F_ISPF_Parms+4      Save it\n         LA    R15,@F_ErrMsgL           Long message\n         ST    R15,@F_ISPF_Parms+8      Save it\n         LA    R15,=AL4(L'@F_ErrMsgL)   Length of message\n         ST    R15,@F_ISPF_Parms+16     Save it\n         OI    @F_ISPF_Parms+16,X'80'   Flag end of list\n         LINKX EP=ISPLINK,              Link to ISPF Interface         +\n               ERRET=(2),                error here                    +\n               MF=(E,@F_ISPF_Parms),     passing these parms           +\n               SF=(E,@F_LINKX)           staying re-entrant\n\n         LA    R15,=CL8'SETMSG'         Yes, ISPF Function\n         ST    R15,@F_ISPF_Parms        Save it\n         LA    R15,=CL8'ISRZ001'        A(Message ID)\n         ST    R15,@F_ISPF_Parms+4      Save it\n         OI    @F_ISPF_Parms+4,X'80'    Mark end of list\n         LINKX EP=ISPLINK,              Link to ISPF Interface         +\n               ERRET=(2),                error here                    +\n               MF=(E,@F_ISPF_Parms),     passing these parms           +\n               SF=(E,@F_LINKX)           staying re-entrant\n         J     F00590                   and exit with error\n\nF00560   DS    0H\n         LA    R1,@F_ErrMsgL            A(Error Message)\n         LA    R0,L'@F_ErrMsgL          Length\n         TPUT  (1),(0)                  All else failed\n         J     F00590                   and exit with error\n\nF00570   DS    0H\n*--------------------------------------------------------------------*\n*     ... or PUTLINE ...                                             *\n*--------------------------------------------------------------------*\n         TM    @_TSO_Command,L'@_TSO_Command Is this a TSO command?\n         JZ    F00580                   No, skip\n\n         LA    R14,@F_ErrMsgL           A(Source)\n         LHI   R15,L'@F_ErrMsgL         Length\n         O     R15,=XL4'40000000'       Pad char of blank\n         LA    R0,@F_VolTbl_Ent_Copy    A(Target)\n         LHI   R1,@F_VolTbl_Ent_Copy_Len Target length\n         MVCL  R0,R14                   Move message\n         PUTLINE MF=(E,@F_IOPL)         Write it\n         J     F00590                   and skip\n\nF00580   DS    0H\n*--------------------------------------------------------------------*\n*     ... or to SYSPRINT                                             *\n*--------------------------------------------------------------------*\n         LA    R15,@F_ErrMsgL           A(Error Msg)\n         ST    R15,@F_Parms_Y00010      Save it\n         LA    R15,L'@F_ErrMsgL         Length\n         ST    R15,@F_Parms_Y00010+4    Save it\n\n         LA    R1,@F_Parms              A(Parms)\n         BRAS  R14,Y00010               Go print it\n         J     F00590                   and exit with error\n\nF00590   DS    0H\n*--------------------------------------------------------------------*\n*     Set the return code, and exit                                  *\n*--------------------------------------------------------------------*\n         LA    R15,4                    OutFile processing failed\n         J     F00600                   and exit\n\nF00600   DS    0H\n*--------------------------------------------------------------------*\n*     All done processing the VolTbl Entries - exit                  *\n*--------------------------------------------------------------------*\n         J     F90010                   exit quick smart\n\n\nF80010   DS    0H\n*--------------------------------------------------------------------*\n*     Nothing to display                                             *\n*--------------------------------------------------------------------*\n         LA    R15,4                    Set return code\n         J     F90010                   and exit\n\nF90010   DS    0H\n*-------------------------------------------------------------------*\n*    Free up our local storage ...                                  *\n*-------------------------------------------------------------------*\n         LR    R3,R15                 Save return code\n\n         LA    R1,@F_Dynam              A(Local storage)\n         L     R2,@F_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         L     R13,4(0,R13)             Rescue A(HSA)\n\n         SSCSTACK POP,                  Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=(R2)                on this stack\n\n         LR    R15,R3                   Restore return code\n\n*-------------------------------------------------------------------*\n*    ... and return to caller                                       *\n*-------------------------------------------------------------------*\n         L     R14,12(0,R13)            Restore return address\n         LM    R0,R12,20(R13)           Restore other registers\n         BSM   0,R14                    and return\n\nF_Literals  DS  0H\n\nF_PLPB   PUTLINE OUTPUT=(0,TERM,SINGLE,DATA),                          +\n               TERMPUT=(EDIT,WAIT,NOHOLD,NOBREAK),                     +\n               MF=L\nF_PLPB_Length EQU *-F_PLPB\n\nF_LINKX  LINKX EP=ISPLINK,            ISPF services                    +\n               SF=L                    List form only\nF_LINKX_Length EQU   *-F_LINKX\n\nF_EMsg01 DC    C'&PGMNAME.01I No Devices/Volumes match selection criter+\n               ia'\nF_EMsg02 DC    C'&PGMNAME.02I Insufficient APF authorization'\nF_EMsg03 DC    C'&PGMNAME.03I ISPF DM Services unavailable xx-yy'\nF_EMsg03_RC    EQU F_EMsg03+L'F_EMsg03-5,2\nF_EMsg03_Reas  EQU F_EMsg03+L'F_EMsg03-2,2\nF_EMsg04 DC    C'&PGMNAME.04I Forcing non-ISPF output'\nF_EMsg05 DC    C'&PGMNAME.05I CSVQUERY unavailable on this system '\nF_EMsg06 DC    C'&PGMNAME.06I Program not found in STEPLIB/LNKLST'\nF_EMsg07 DC    C'&PGMNAME.07I IKJEFTSR Error xx-yy'\nF_EMsg07_RC    EQU   F_EMsg07+L'F_EMsg07-5,2\nF_EMsg07_Reas  EQU   F_EMsg07+L'F_EMsg07-2,2\nF_EMsg08 DC    C'&PGMNAME.08I LSPACE failed for at least 1 volume'\nF_EMsg09 DC    C'&PGMNAME.09I Incompatible version'\nF_EMsg10 DC    C'&PGMNAME.10I Insufficient storage:'\nF_EMsg11 DC    C'&PGMNAME.11I Internal Error - Unknown invocation type'\nF_EMsg12 DC    C'&PGMNAME.12I OutFile DDName'\n\nF_EX1    MVC   0(0,R15),0(R1)\n\nF_Hex_TrTab           EQU   *-240\n                      DC    C'0123456789ABCDEF'\n\n         LTORG\n\nF_Literals_End  DS  0H\n\n\n@F_Dynam                  DSECT        Dynamic area for F00000\n                          DS    18F     O/S Style save area\n@F_31Bit_Stack_Ptr_Ptr    DS    AL4     A(31-bit Stack Ptr)\n@F_24Bit_Stack_Ptr_Ptr    DS    AL4     A(24-bit Stack Ptr)\n@F_DBLWD                  DS    D       Work area\n\n@F_G00010_RC              DS    HL2     G00010 Return Code\n@F_G00010_Reas            DS    HL2     G00010 Reason Code\n\n@F_Parms                  DS    0F      Parms for called rtns\n@F_Parms_Std              DS    3AL4     Standard 3 parms\n@F_Parms_Extra            EQU   *        Extra parms\n@F_Parms_G00010           DS    2AL4        for G00010\n                          ORG   @F_Parms_Extra\n@F_Parms_I00010           DS    2AL4        for I00010\n                          ORG   @F_Parms_Extra\n@F_Parms_V00010           DS    AL4         for V00010\n                          ORG   @F_Parms_Extra\n@F_Parms_X00010           DS    2AL4        for X00010\n                          ORG   @F_Parms_Extra\n@F_Parms_Y00010           DS    2AL4        for Y00010\n                          ORG   @F_Parms_Extra\n@F_ISPF_Parms             DS    5AL4   ISPF Parm List\n@F_LINKX                  DS    CL(F_LINKX_Length)\n                          ORG   ,\n                          DS    0F      Alignment\n@F_IOPL                   DS    CL(IOPL_Length)  IOPL block\n                          DS    0F      Alignment\n@F_PLPB                   DS    CL(F_PLPB_Length) PUTLINE Parm Blk\n@F_IOECB                  DS    F       ECB for PUTLINE\n@F_OLD                    EQU   *       OLD for PUTLINE\n@F_OLDLN                  DS    HL2      Length\n@F_OLDOF                  DS    HL2      Offset\n@F_VolTbl_Ent_Copy        DS    2CL((VolTbl_Ent_Display_Len/2)+1)\n@F_VolTbl_Ent_Copy_Len    EQU   *-@F_VolTbl_Ent_Copy\n@F_ErrMsgS                DS    CL24\n@F_ErrMsgL                DS    CL(L'VolTbl_Ent_ErrMsg)\n                          DS    0D          Alignment\n@F_Dynam_Length           EQU   *-@F_Dynam  Length of storage\n\n&PGMNAME CSECT\n\n         DROP  ,\n         POP   USING\n         TITLE 'G00010: Output Results using ISPF'\n\n         PUSH  USING\n\nG00010   DS    0H\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Routine   : G00010                                                 *\n*                                                                     *\n*  Abstract  : Display results of LSPACE stuff via ISPF               *\n*                                                                     *\n*  Inputs    : R1 : ---> A(@_Dynam)                                   *\n*                        A(31-bit Stack Pointer)                      *\n*                        A(24-bit Stack Pointer)                      *\n*                        A(ISPF Short Message)                        *\n*                        A(ISPF Long Message)                         *\n*  Outputs   : R15: 00 - all OK                                       *\n*                   04 - ISPQRY Failed,       R0: RC from ISPQRY      *\n*                   08 - ISPLINK LOAD failed, R0: RC from LOAD        *\n*                                                                     *\n*  Notes     :                                                        *\n*                                                                     *\n*  History:    2000/05/23 SDDA030 - V2.12                             *\n*                                 - New, code was originally in       *\n*                                   F00010.                           *\n*                                 - Added MULT to TBADD.              *\n*                                 - If we are APF-auth turn off       *\n*                                   JSCBAUTH before trying to use DM, *\n*                                   and ATTACH a task to reset it     *\n*                                   when we are done.                 *\n*              2001/02/01 SDDA030 - V2.13                             *\n*                                 - Removed IOSCDR message pointer.   *\n*                                 - Removed JSCBAUTH stuff.           *\n*                                 - Added 'Incomplete' ISPF msg.      *\n*              2001/02/26 SDDA030 - V2.14                             *\n*                                 - Added BRIF/EDIF support.          *\n*                                 - Used BRIF if ISPF(S) wanted, but  *\n*                                   panel not available.              *\n*              2002/02/12 SDDA030 - V2.16                             *\n*                                 - Moved ISPF(S) code to K00010      *\n*              2003/10/07 SDDA030 - V2.21                             *\n*                                 - Added code to allow switching     *\n*                                   between display modes.            *\n*              2006/04/21 SDDA030 - V2.24                             *\n*                                 - Used standardised calling sequence*\n*              ____/__/__ _______                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         STM   R14,R12,12(R13)          Save callers registers\n         LARL  R11,G_Literals           Point to our literals\n         USING (G_Literals,G_Literals_End),R11 Tell the assembler\n\n         L     R12,0(0,R1)              A(@_Dynam)\n         USING @_Dynam,R12              Tell the assembler\n\n*-------------------------------------------------------------------*\n*    Get an area on the stack for our local storage                 *\n*-------------------------------------------------------------------*\n         L     R2,4(0,R1)               A(31-bit stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         SSCSTACK PUSH,                 Get stack area                 +\n               LEN=@G_Dynam_Length,      this long                     +\n               STACK=(R2)                using this stack\n\n         LR    R3,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LHI   R1,@G_Dynam_Length        Its length\n         LA    R14,0                    Clear source address\n         LA    R15,0                     and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R3                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*-------------------------------------------------------------------*\n         ST    R13,4(0,R1)              Chain\n         ST    R1,8(0,R13)               saveareas\n         LR    R13,R1                   Load dynam base\n         USING @G_Dynam,R13             Assign a base\n         L     R15,@G_Dynam+4           Get A(HSA)\n         LM    R0,R3,20(R15)            Restore callers registers\n\n         L     R15,4(0,R1)              A(31-bit Stack Pointer)\n         ST    R15,@G_31Bit_Stack_Ptr_Ptr Save it\n         L     R15,8(0,R1)              A(24-bit Stack Pointer)\n         ST    R15,@G_24Bit_Stack_Ptr_Ptr Save it\n\n*--------------------------------------------------------------------*\n*   Initialize our standard parmlist                                 *\n*--------------------------------------------------------------------*\n         LA    R15,@_Dynam              A(Dynamic area)\n         ST    R15,@G_Parms_Std         Save it\n         L     R15,@G_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)\n         ST    R15,@G_Parms_Std+4       Save it\n         L     R15,@G_24Bit_Stack_Ptr_Ptr A(24-bit Stack Pointer)\n         ST    R15,@G_Parms_Std+8       Save it\n\n*---------------------------------------------------------------------*\n*      If we can use ISPF, LOAD ISPLINK                               *\n*---------------------------------------------------------------------*\n         LA    R1,0                     Clear parm reg\n         LINK  EP=ISPQRY                Check ISPF services\n         LTR   R15,R15                  Are they available?\n         JNZ   G80010                   No, use line-by-line\nG00020   DS    0H\n         BASR  R2,0\n         USING (*,G00020_End-1),R2\n         LOAD  EP=ISPLINK               Get A(ISPF Interface)\nG00020_End DS  0H\n         DROP  R2\n         LTR   R15,R15                  Is it there?\n         JNZ   G80020                   No, skip\n         ST    R0,@_ISPLINK             Yes, save EPA\n\n*---------------------------------------------------------------------*\n*      ISPF seems to be available - save our display environment and  *\n*     ask ISPF to return errors to us.                                *\n*---------------------------------------------------------------------*\n         LA    R15,=CL8'CONTROL'        CONTROL\n         ST    R15,@G_ISPF_Parms\n         LA    R15,=CL8'DISPLAY'        DISPLAY\n         ST    R15,@G_ISPF_Parms+4\n         LA    R15,=CL8'SAVE'           SAVE\n         ST    R15,@G_ISPF_Parms+8\n         OI    @G_ISPF_Parms+8,X'80'    Flag end of list\n         LA    R1,@G_ISPF_Parms         A(Parmlist)\n         L     R15,@_ISPLINK            A(ISPF Interface)\n         BASR  R14,R15                  Go do it\n\n         LA    R15,=CL8'CONTROL'        CONTROL\n         ST    R15,@G_ISPF_Parms\n         LA    R15,=CL8'ERRORS'         ERRORS\n         ST    R15,@G_ISPF_Parms+4\n         LA    R15,=CL8'RETURN'         RETURN\n         ST    R15,@G_ISPF_Parms+8\n         OI    @G_ISPF_Parms+8,X'80'    Flag end of list\n         LA    R1,@G_ISPF_Parms         A(Parmlist)\n         L     R15,@_ISPLINK            A(ISPF Interface)\n         BASR  R14,R15                  Go do it\n\n*---------------------------------------------------------------------*\n*      Clear our flags                                                *\n*---------------------------------------------------------------------*\n         NI    @G_SETMSG_Issued,X'FF'-L'@G_SETMSG_Issued Clear flg\n\n*---------------------------------------------------------------------*\n*      If there is an error message, SETMSG it ...                    *\n*---------------------------------------------------------------------*\n         L     R15,@G_Dynam+4           A(HSA)\n         L     R15,24(0,R15)            Get original R1\n         ICM   R14,B'1111',12(R15)      A(Short Error message)\n         JZ    G00030                   Nothing, skip\n         CLI   0(R14),C' '              Message blank?\n         JE    G00030                   Yes, no message\n\n         LA    R15,=CL8'VDEFINE'        ISPF Function\n         ST    R15,@G_ISPF_Parms        Save it\n         LA    R15,=CL8'CHAR'           Character variables\n         ST    R15,@G_ISPF_Parms+12     Save it\n\n         LA    R15,=CL8'ZEDSMSG'        Variable name\n         ST    R15,@G_ISPF_Parms+4      Save it\n         ST    R14,@G_ISPF_Parms+8      Save A(short message)\n         LA    R15,=FL4'24'             Max len of SMSG\n         ST    R15,@G_ISPF_Parms+16     Save it\n         OI    @G_ISPF_Parms+16,X'80'   Flag end of list\n         LA    R1,@G_ISPF_Parms         A(Parmlist)\n         L     R15,@_ISPLINK            A(ISPF Interface)\n         BASR  R14,R15                  Go do it\n\n         LA    R15,=CL8'ZEDLMSG'        Variable name\n         ST    R15,@G_ISPF_Parms+4      Save it\n         L     R15,@G_Dynam+4           A(HSA)\n         L     R15,24(0,R15)            Get original R1\n         L     R15,16(0,R15)            A(Long message)\n         ST    R15,@G_ISPF_Parms+8      Save it\n         LA    R15,=AL4(L'VolTbl_Ent_ErrMsg) Length of Long Msg\n         ST    R15,@G_ISPF_Parms+16     Save it\n         OI    @G_ISPF_Parms+16,X'80'   Flag end of list\n         LA    R1,@G_ISPF_Parms         A(Parmlist)\n         L     R15,@_ISPLINK            A(ISPF Interface)\n         BASR  R14,R15                  Go do it\n\n         LA    R15,=CL8'SETMSG'         Yes, ISPF Function\n         ST    R15,@G_ISPF_Parms        Save it\n         LA    R15,=CL8'ISRZ001'        A(Message ID)\n         ST    R15,@G_ISPF_Parms+4      Save it\n         OI    @G_ISPF_Parms+4,X'80'    Mark end of list\n         LA    R1,@G_ISPF_Parms         Point to ISPF parms\n         L     R15,@_ISPLINK            A(Interface routine)\n         BASR  R14,R15                  Go do it\n\n         OI    @G_SETMSG_Issued,L'@G_SETMSG_Issued  We've done a SETMSG\n\nG00030   DS    0H\n*---------------------------------------------------------------------*\n*      If there is anything to do ...                                 *\n*---------------------------------------------------------------------*\n         SLR   R15,R15                  Clear return code\n         ICM   R1,B'1111',@_VolTbl_Ptr A(VolTbl)\n         JZ    G90010                   None, all done\n         ICM   R1,B'1111',VolTbl_Hdr_Vols_Total-VolTbl_Hdr(R1)\n         JZ    G90010                   None, all done\n\n*---------------------------------------------------------------------*\n*      If we will be invoking BRIF, put out the message indicating    *\n*     that the SORT command is available.                             *\n*---------------------------------------------------------------------*\n         TM    @_ISPF_BRIF,L'@_ISPF_BRIF Do we want BRIF?\n         JNO   G00060                   No, skip\n         TM    @G_SETMSG_Issued,L'@G_SETMSG_Issued Already a msg?\n         JO    G00060\n\n         LA    R15,=CL8'VDEFINE'        ISPF Function\n         ST    R15,@G_ISPF_Parms        Save it\n         LA    R15,=CL8'CHAR'           Character variables\n         ST    R15,@G_ISPF_Parms+12     Save it\n\n         LA    R15,=CL8'ZEDSMSG'        Variable name\n         ST    R15,@G_ISPF_Parms+4      Save it\n         LA    R15,G_Sort_SMsg          SORT Cmd available\n         ST    R15,@G_ISPF_Parms+8      Save it\n         LA    R15,=AL4(L'G_Sort_SMsg)  Length of message\n         ST    R15,@G_ISPF_Parms+16     Save it\n         OI    @G_ISPF_Parms+16,X'80'   Flag end of list\n         LA    R1,@G_ISPF_Parms         A(Parmlist)\n         L     R15,@_ISPLINK            A(ISPF Interface)\n         BASR  R14,R15                  Go do it\n\n         LA    R15,=CL8'ZEDLMSG'        Variable name\n         ST    R15,@G_ISPF_Parms+4      Save it\n         LA    R15,G_Sort_LMsg          Long message\n         ST    R15,@G_ISPF_Parms+8      Save it\n         LA    R15,=AL4(L'G_Sort_LMsg)  Length of message\n         ST    R15,@G_ISPF_Parms+16     Save it\n         OI    @G_ISPF_Parms+16,X'80'   Flag end of list\n         LA    R1,@G_ISPF_Parms         A(Parmlist)\n         L     R15,@_ISPLINK            A(ISPF Interface)\n         BASR  R14,R15                  Go do it\n\n         LA    R15,=CL8'SETMSG'         Yes, ISPF Function\n         ST    R15,@G_ISPF_Parms        Save it\n         LA    R15,=CL8'ISRZ000'        A(Message ID)\n         ST    R15,@G_ISPF_Parms+4      Save it\n         OI    @G_ISPF_Parms+4,X'80'    Mark end of list\n         LA    R1,@G_ISPF_Parms         Point to ISPF parms\n         L     R15,@_ISPLINK            A(Interface routine)\n         BASR  R14,R15                  Go do it\n\nG00060   DS    0H\n         TM    @_ISPF_BRIF,L'@_ISPF_BRIF Do we want BRIF?\n         JO    G00070                   Yes, skip\n         TM    @_ISPF_EDIF,L'@_ISPF_EDIF No, how about EDIF?\n         JO    G00070                   Yes, skip\n\n*---------------------------------------------------------------------*\n*      Invoke our standard ISPF SPACE display; if it fails, we will   *\n*     force BRIF.                                                     *\n*---------------------------------------------------------------------*\n         LA    R1,@G_Parms              A(Parms)\n         BRAS  R14,K00010               Go display ISPF(S)\n         TM    @_ReDisplay,L'@_ReDisplay Do it again?\n         JO    G00080                   Yes, exit quick smart\n         LTR   R15,R15                  No, how did it go?\n         JZ    G00080                   OK, skip\n\n*---------------------------------------------------------------------*\n*      We will use BRIF - set our flag, and let the user know         *\n*---------------------------------------------------------------------*\n         OI    @_ISPF_BRIF,L'@_ISPF_BRIF No, force BRIF\n         NI    @_ISPF_SPACE,X'FF'-L'@_ISPF_SPACE\n\n         TM    @G_SETMSG_Issued,L'@G_SETMSG_Issued  Already SETMSG'd?\n         JO    G00070                   Yes, don't clobber it\n\n         LA    R15,=CL8'VDEFINE'        ISPF Function\n         ST    R15,@G_ISPF_Parms        Save it\n         LA    R15,=CL8'CHAR'           Character variables\n         ST    R15,@G_ISPF_Parms+12     Save it\n\n         LA    R15,=CL8'ZEDSMSG'        Variable name\n         ST    R15,@G_ISPF_Parms+4      Save it\n         LA    R15,G_BRIF_SMsg          A(Short Message)\n         ST    R15,@G_ISPF_Parms+8      Save it\n         LA    R15,=AL4(L'G_BRIF_SMsg)  Length of variable\n         ST    R15,@G_ISPF_Parms+16     Save it\n         OI    @G_ISPF_Parms+16,X'80'   Flag end of list\n         LA    R1,@G_ISPF_Parms         A(Parmlist)\n         L     R15,@_ISPLINK            A(ISPF Interface)\n         BASR  R14,R15                  Go do it\n\n         LA    R15,=CL8'ZEDLMSG'        Variable name\n         ST    R15,@G_ISPF_Parms+4      Save it\n         LA    R15,G_BRIF_LMsg          A(Long message)\n         ST    R15,@G_ISPF_Parms+8      Save it\n         LA    R15,=AL4(L'G_BRIF_LMsg)  Length of message\n         ST    R15,@G_ISPF_Parms+16     Save it\n         OI    @G_ISPF_Parms+16,X'80'   Flag end of list\n         LA    R1,@G_ISPF_Parms         A(Parmlist)\n         L     R15,@_ISPLINK            A(ISPF Interface)\n         BASR  R14,R15                  Go do it\n\n         LA    R15,=CL8'SETMSG'         Yes, ISPF Function\n         ST    R15,@G_ISPF_Parms        Save it\n         LA    R15,=CL8'ISRZ001'        A(Message ID)\n         ST    R15,@G_ISPF_Parms+4      Save it\n         OI    @G_ISPF_Parms+4,X'80'    Mark end of list\n         LA    R1,@G_ISPF_Parms         Point to ISPF parms\n         L     R15,@_ISPLINK            A(Interface routine)\n         BASR  R14,R15                  Go do it\n\n         OI    @G_SETMSG_Issued,L'@G_SETMSG_Issued  We've done a SETMSG\n\n         J     G00070                   and go do it\n\nG00070   DS    0H\n         LA    R1,@G_Parms              A(Parms)\n         BRAS  R14,J00010               Go EDIF/BRIF\n\n         LA    R15,0                    Clear return code\n         LA    R0,0                     and reason code\n         J     G90010\n\nG00080   DS    0H\n*--------------------------------------------------------------------*\n*     END or RETURN from DISPLAY: Clear return codes and exit.       *\n*--------------------------------------------------------------------*\n         LA    R0,0                     Clear reason code\n         LA    R15,0                     and return code\n         J     G90010                   exit\n\n\nG80010   DS    0H\n*-------------------------------------------------------------------*\n*    Error - ISPQRY failed                                          *\n*-------------------------------------------------------------------*\n         LR    R0,R15                 Set reason code (RC from ISPQRY)\n         LA    R15,4                  Set return code\n         J     G90010                 and exit\n\nG80020   DS    0H\n*-------------------------------------------------------------------*\n*    Error - LOAD for ISPLINK failed                                *\n*-------------------------------------------------------------------*\n         LR    R0,R15                 Set reason code (RC from LOAD)\n         LA    R15,8                  Set return code\n         J     G90010                 and exit\n\n\nG90010   DS    0H\n*---------------------------------------------------------------------*\n*   Clean up and return to caller                                     *\n*---------------------------------------------------------------------*\n         LR    R3,R15                 Save return code\n         LR    R4,R0                   and reason code\n\n*---------------------------------------------------------------------*\n*   If we successfully LOADed ISPLINK ...                             *\n*---------------------------------------------------------------------*\n         ICM   R1,B'1111',@_ISPLINK     Get A(ISPF Interface)\n         JZ    G90030                   None, skip\n\n*---------------------------------------------------------------------*\n*   ... VDELETE any ISPF variables we created ...                     *\n*---------------------------------------------------------------------*\n         LA    R15,=CL8'VDELETE'        Yes, A(ISPF Function)\n         ST    R15,@G_ISPF_Parms        Save it\n         LA    R15,=CL8'*'              A(Variable names)\n         ST    R15,@G_ISPF_Parms+4      Save it\n         OI    @G_ISPF_Parms+4,X'80'    Flag end of list\n         LA    R1,@G_ISPF_Parms         Point to ISPF parms\n         L     R15,@_ISPLINK            A(ISPF Interface)\n         BASR  R14,R15                  Go do it\n\n*---------------------------------------------------------------------*\n*   ... restore the ISPF Display environment ...                      *\n*---------------------------------------------------------------------*\n         LA    R15,=CL8'CONTROL'        ISPF Function\n         ST    R15,@G_ISPF_Parms        Save it\n         LA    R15,=CL8'DISPLAY'        Character variables\n         ST    R15,@G_ISPF_Parms+4      Save it\n         LA    R15,=CL8'RESTORE'        Character variables\n         ST    R15,@G_ISPF_Parms+8      Save it\n         OI    @G_ISPF_Parms+8,X'80'    Flag end of list\n         LA    R1,@G_ISPF_Parms         A(Parmlist)\n         L     R15,@_ISPLINK            A(ISPF Interface)\n         BASR  R14,R15                  Go do it\n\n*---------------------------------------------------------------------*\n*   ... and DELETE ISPLINK                                            *\n*---------------------------------------------------------------------*\n         DELETE EP=ISPLINK              Delete it\n         LA    R15,0                    and clear\n         ST    R15,@_ISPLINK             the pointer\n\nG90030   DS    0H\n*-------------------------------------------------------------------*\n*    Free up our local storage ...                                  *\n*-------------------------------------------------------------------*\n         LA    R1,@G_Dynam              A(Local storage)\n         L     R2,@G_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         L     R13,4(0,R13)             Rescue A(HSA)\n\n         SSCSTACK POP,                  Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=(R2)                on this stack\n\n*-------------------------------------------------------------------*\n*    ... and return to caller                                       *\n*-------------------------------------------------------------------*\n         LR    R15,R3                   Restore return code\n         LR    R0,R4                    Restore reason code\n         L     R14,12(0,R13)            Restore return address\n         LM    R1,R12,24(R13)           Restore other registers\n         BSM   0,R14                    and return\n\nG_Literals  DS   0H\n\nG_Sort_SMsg DC C'SORT Cmd avail'\nG_Sort_LMsg DC C'''SORT'' can be used to sort the table'\n\nG_BRIF_SMsg DC C'BRIF substituted'\nG_BRIF_LMsg DC C'Panel &PNLNAME not found'\n\n         LTORG\n\nG_Literals_End  DS   0H\n\n\n@G_Dynam                  DSECT        Dynamic area for G00000\n                          DS    18F     O/S Style save area\n@G_31Bit_Stack_Ptr_Ptr    DS    AL4     A(31-bit Stack Ptr)\n@G_24Bit_Stack_Ptr_Ptr    DS    AL4     A(24-bit Stack Ptr)\n@G_DBLWD                  DS    D       Work area\n@G_ISPF_Parms             DS    10FL4   ISPF Parm list\n                          DS    X       Flag Byte\n@G_SETMSG_Issued          EQU   *-1,X'80' 1... .... SETMSG issued\n\n@G_Parms                  DS    0F      Parms for called rtns\n@G_Parms_Std              DS    3AL4     Standard 3 parms\n@G_Parms_Extra            EQU   *        Extra parms\n                          ORG   ,\n                          DS    0D      Alignment\n@G_Dynam_Length           EQU   *-@G_Dynam Length of storage\n\n&PGMNAME CSECT\n\n         DROP  ,\n         POP   USING\n\n         TITLE 'H00010: Issue LSPACE for device'\n\n         PUSH  USING\n\nH00010   DS    0H\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Routine   : H00010                                                 *\n*                                                                     *\n*  Abstract  : Issue LSPACE and save selected F4 DSCB data            *\n*                                                                     *\n*  Inputs    : R1 : ---> A(@_Dynam)                                   *\n*                        A(31-bit Stack Pointer)                      *\n*                        A(24-bit Stack Pointer)                      *\n*                        A(Volume Table)                              *\n*  Outputs   : VolTbl updated                                         *\n*                                                                     *\n*  Operation : Initialize                                             *\n*                Do while unprocessed entries in Volume Table         *\n*                  Flag entry as processed                            *\n*                  Issue STIMER                                       *\n*                  Issue LSPACE for device described by VolTbl_Ent    *\n*                  Cancel STIMER                                      *\n*                  Format detail line                                 *\n*                  Update Totals                                      *\n*                  If last volume,                                    *\n*                    Format Totals line, if present                   *\n*                  EndIf                                              *\n*                EndDo                                                *\n*              Update Stats Line, if present                          *\n*              Terminate                                              *\n*                                                                     *\n*  History   : 1997/05/16 SDDA030 - New                               *\n*              1998/09/17 SDDA030 - V2.0                              *\n*                                 - Used Compare-and-Swap in pseudo-  *\n*                                   POST processing, rather than      *\n*                                   blindly ORing POST bit if no WAIT *\n*                                   was present.                      *\n*              1998/09/22 SDDA030 - V2.1                              *\n*                                 - Added ESTAE to trap ABENDs and    *\n*                                   POST SPACE with a code of 8.      *\n*                                 - Moved STIMERM from D00010 to this *\n*                                   routine.                          *\n*              1998/11/13 SDDA030 - V2.2                              *\n*                                 - This routine now goes through the *\n*                                   Volume Table, rather than WAITing *\n*                                   for SPACE to POST it with the     *\n*                                   address of an entry to process.   *\n*                                   ESTAE merely restarts the search  *\n*                                   through the table, rather than    *\n*                                   POSTing the ECB (there seems to be*\n*                                   no point in re-ATTACHing after an *\n*                                   ESTAE).                           *\n*              1999/09/01 SDDA030 - V2.9                              *\n*                                 - Do not use CDS instruction to up- *\n*                                   date totals fields, as they are   *\n*                                   now in the subtask area.          *\n*              2000/01/19 SDDA030 - V2.11                             *\n*                                 - Used areas within the VolTbl      *\n*                                   entry to hold control blocks from *\n*                                   LSPACE.                           *\n*                                 - Removed SMS anomaly check (now    *\n*                                   in E00010).                       *\n*              2000/05/23 SDDA030 - V2.12                             *\n*                                 - Removed STIMERM-related stuff     *\n*                                   Added IOSCDR to check if we can   *\n*                                   get out to the DASD device before *\n*                                   issuing LSPACE.                   *\n*              2001/02/01 SDDA030 - V2.13                             *\n*                                 - Undid stuff from V2.12            *\n*                                 - Replaced POST with ESTAE and      *\n*                                   ABEND in STIMERM exit (H06000).   *\n*                                 - Mimimum STIMERM WAIT time = 1 sec.*\n*                                 - Used micro-secs and MICVL instead *\n*                                   of Timer Units.                   *\n*              2001/02/26 SDDA030 - V2.14                             *\n*                                 - Removed detail and total line     *\n*                                   formatting.                       *\n*                                 - Used work area passed by E00010   *\n*                                   rather than GETMAIN.              *\n*              2001/11/12 SDDA030 - V2.15                             *\n*                                 - Corrected bug in calculating      *\n*                                   STIMERM times - all our times are *\n*                                   now maintained in usec.           *\n*                                 - Used STIMERM Wait time factor in  *\n*                                   calculating wait time.            *\n*              2002/03/11 SDDA030 - V2.17                             *\n*                                 - Generated LSPACE error messages   *\n*                                   internally, instead of asking     *\n*                                   LSPACE to do it.                  *\n*              2002/06/11 SDDA030 - V2.18                             *\n*                                 - Formatted detail and total lines  *\n*                                   in this routine.                  *\n*                                 - Filled in SubTask Statistics Line.*\n*              2006/04/21 SDDA030 - V2.24                             *\n*                                 - Rounded numbers in the display    *\n*                                   area where appropriate.           *\n*                                 - Used TRKCALC to get track size,   *\n*                                   rather than use DS4DEVTK. For     *\n*                                   example, for 3390s:               *\n*                                     DS4DEVTK = 58786                *\n*                                     TRKCALC  = 56664                *\n*                                 - Used standardized calling sequence*\n*                                 - Saved callers registers on the    *\n*                                   Linkage Stack                     *\n*                                 - Used STIMERM around LSPACE if     *\n*                                   MaxLWait specified                *\n*                                                                     *\n*  Notes     : This routine differs from the others in this program   *\n*              in that it is ATTACHed.                                *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n\n*---------------------------------------------------------------------*\n*     Save caller's registers, get dynamic storage, etc. etc.         *\n*---------------------------------------------------------------------*\n         BAKR  R14,0                    Save callers registers\n         LARL  R11,H_Literals           Point to our literals\n         USING (H_Literals,H_Literals_End),R11 Tell the assembler\n\n         L     R12,0(0,R1)              A(@_Dynam)\n         USING @_Dynam,R12              Tell the assembler\n\n*-------------------------------------------------------------------*\n*    Get some storage for our LIFO stack ...                        *\n*-------------------------------------------------------------------*\n         LHI   R0,@_31Bit_Stack_Length  Length of storage we need\n         SSCSTACK INIT,                 Go get our storage             +\n               LEN=(R0),                 this long                     +\n               LOC=31                    above-the-line\n\n         LR    R4,R1                    Save its address\n\n*-------------------------------------------------------------------*\n*    ... and get an area on it for our local storage                *\n*-------------------------------------------------------------------*\n         SSCSTACK PUSH,                 Get Stack area                 +\n               LEN=@H_Dynam_Length,      this long                     +\n               STACK=(R4)                 using this stack\n\n         LR    R3,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LHI   R1,@H_Dynam_Length        Its length\n         LA    R14,0                    Clear source address\n         LA    R15,0                     and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R3                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*-------------------------------------------------------------------*\n         LR    R13,R1                   Load dynam base\n         USING @H_Dynam,R13             Assign a base\n         MVC   4(4,R13),=C'F1SA'        Init save area\n         ST    R4,@H_31Bit_Stack_Ptr    Save A(Stack)\n\n         EREG  R0,R4                    Restore callers registers\n\n*---------------------------------------------------------------------*\n*     Save our parm addresses ...                                     *\n*---------------------------------------------------------------------*\n         ICM   R15,B'1111',12(R1)       A(Volume Table)\n         JZ    H90010                   Nothing, all done\n         ST    R15,@H_VolTbl_Ptr        Save it\n         LA    R14,VolTbl_Hdr_LSPACE_Avg-VolTbl_Hdr(R15)\n         ST    R14,@H_LSPACE_Avg_Ptr    Save it\n         LA    R14,VolTbl_Hdr_STIMERM_Adj-VolTbl_Hdr(R15)\n         ST    R14,@H_STIMERM_Adj_Ptr   Save it\n\n*---------------------------------------------------------------------*\n*     ... set up the addresses of the lines we need ...               *\n*---------------------------------------------------------------------*\n         L     R15,@H_VolTbl_Ptr        A(VolTbl)\n         ICM   R0,B'1111',VolTbl_Hdr_Total_Off-VolTbl_Hdr(R15) Totals\n         JZ    H00020                   None, skip\n         AR    R0,R15                   Convert offset to address\n         ST    R0,@H_Totals_Line_Ptr    Save it\nH00020   DS    0H\n         ICM   R0,B'1111',VolTbl_Hdr_SMS_Off-VolTbl_Hdr(R15) SMS msg\n         JZ    H00030                   None, skip\n         AR    R0,R15                   Convert offset to address\n         ST    R0,@H_SMS_Anomaly_Ptr    Save it\nH00030   DS    0H\n         ICM   R0,B'1111',VolTbl_Hdr_SubT_Off-VolTbl_Hdr(R15) SubTask\n         JZ    H00040                   None, skip\n         AR    R0,R15                   Convert offset to address\n         ST    R0,@H_Stats_Line_Ptr     Save it\n\nH00040   DS    0H\n*---------------------------------------------------------------------*\n*     ... and set our flag, indicating the presence of OW48527, and   *\n*     the maximum LSPACE Wait time                                    *\n*---------------------------------------------------------------------*\n        L     R15,@H_VolTbl_Ptr         A(VolTbl)\n        TM    VolTbl_Hdr_OW48527-VolTbl_Hdr(R15),L'VolTbl_Hdr_OW48527\n        JNO   H00040C                   Not installed, skip\n        OI    @H_OW48527,L'@H_OW48527   OK, set our flag\nH00040C DS    0H\n        MVC   @H_MaxLWait,VolTbl_Hdr_MaxLWait-VolTbl_Hdr(R15)\n\n*--------------------------------------------------------------------*\n*   Initialize our standard parmlist                                 *\n*--------------------------------------------------------------------*\n         LA    R15,@_Dynam              A(Dynamic area)\n         ST    R15,@H_Parms_Std         Save it\n         LA    R15,@H_31Bit_Stack_Ptr   A(31-bit Stack Pointer)\n         ST    R15,@H_Parms_Std+4       Save it\n         LA    R15,@H_24Bit_Stack_Ptr   A(24-bit Stack Pointer)\n         ST    R15,@H_Parms_Std+8       Save it\n\n*---------------------------------------------------------------------*\n*     Set up our ESTAE parms                                          *\n*---------------------------------------------------------------------*\n         MVC   @H_ESTAE_RMask,=X'FFFF'  Restore all registers\n\n*---------------------------------------------------------------------*\n*     Find an unprocessed entry in the Volume Table                   *\n*---------------------------------------------------------------------*\n         ICM   R9,B'1111',@H_VolTbl_Ptr Point to the Volume Table\n         JZ    H90010                   None, exit\n         ICM   R10,B'1111',VolTbl_Hdr_Count-VolTbl_Hdr(R9) Nbr entries\n         JZ    H90010                   None, exit\n         AHI   R9,VolTbl_Ent-VolTbl     Yes, point to the first\n\n         USING VolTbl_Ent,R9            Assign a base\n\nH00050   DS    0H\n*---------------------------------------------------------------------*\n*     Establish an ESTAE, if required                                 *\n*---------------------------------------------------------------------*\n         STM   R0,R15,@H_ESTAE_Regs     Save our registers for retry\n         MVC   @H_ESTAE_Retry,=AL4(H00380) Set retry address\n\n         TM    @H_ESTAE_Issued,L'@H_ESTAE_Issued Do we have an ESTAE?\n         JO    H00060                   Yes, skip\n\n         MVC   @H_ESTAE,H_ESTAE         Move L-Form\n         L     R3,=AL4(H07000)          A(Exit\n         ESTAEX (3),                    Establish ESTAE Exit           +\n               CT,                       create it                     +\n               PARAM=@H_Dynam,           passing this parm             +\n               MF=(E,@H_ESTAE)           keeping ourselves reentrant\n         LTR   R15,R15                  Did it work?\n         JNZ   H00060                   No, skip\n         OI    @H_ESTAE_Issued,L'@H_ESTAE_Issued Yes, set our flag\n\nH00060   DS    0H\n*---------------------------------------------------------------------*\n*     If this entry has not been processed ...                        *\n*---------------------------------------------------------------------*\n         XC    @H_Current_VolTbl_Ent,@H_Current_VolTbl_Ent\n\n         TM    VolTbl_Ent_Detail_Line,L'VolTbl_Ent_Detail_Line\n         JNO   H00410                   No, skip this entry\n         TM    VolTbl_Ent_SMS_Line,L'VolTbl_Ent_SMS_Line SMS Anomaly?\n         JO    H00410                   Yes, dont use it\n         XC    @H_Current_VolTbl_Ent,@H_Current_VolTbl_Ent\n\n         TM    VolTbl_Ent_Processed,L'VolTbl_Ent_Processed\n         JNZ   H00410                   Yes, try next\n\n*---------------------------------------------------------------------*\n*     ... Compare-and-Swap the flag byte, ...                         *\n*---------------------------------------------------------------------*\n         L     R1,VolTbl_Ent_Processed  No, get the Flag byte\n         LA    R0,L'VolTbl_Ent_Processed Set up the\n         SLL   R0,24                     flag turned\n         OR    R0,R1                     on\n         CS    R1,R0,VolTbl_Ent_Processed and update it\n         JNZ   H00410                   Somebody else here, skip\n\n*---------------------------------------------------------------------*\n*     ... bump our counters ...                                       *\n*---------------------------------------------------------------------*\n         L     R14,@H_Total_Vols_Proc   Get nbr vols we processed\n         AHI   R14,1                    Bump it\n         ST    R14,@H_Total_Vols_Proc   and save it\n\n*---------------------------------------------------------------------*\n*     Calculate the time we will WAIT for LSPACE to complete, if      *\n*     MaxLWait has not been specified.                                *\n*     We arbitrarily wait for (8 * Avg of all previously completed    *\n*    LSPACEs * Adjustment Factor), rounded up to the next second.     *\n*                                                                     *\n*     If we are running with OW48527, this time is passed to LSPACE;  *\n*    otherwise, we set up a STIMERM to pop after this time.           *\n*---------------------------------------------------------------------*\n         LH    R15,@H_MaxLWait          Get MaxLWait\n         CHI   R15,0                    Was it specified?\n         JNE   H00080                   Yes, use it\n         L     R15,@H_LSPACE_Avg_Ptr    A(Avg Wait for LSPACE in usec)\n         ICM   R15,B'1111',0(R15)       Get it\n         JNZ   H00070                   Something there, skip\n         L     R15,=FL4'250000'         Nothing, default to .25 sec\nH00070   DS    0H\n         LA    R14,0                    Clear R14\n         SLDL  R14,3                    Multiply by 8\n         L     R1,@H_STIMERM_Adj_Ptr    A(Adjustment factor)\n         M     R14,0(0,R1)              Adjust it\n         D     R14,=FL4'1000000'        Convert to seconds\n         AHI   R15,1                    Bump it\n         CHI   R15,5                    More than 5 seconds?\n         JNH   H00080                   No, OK\n         LHI   R15,5                    Yes, max of 5 secs\nH00080   DS    0H\n         ST    R15,@H_LSPACE_Wait_Max   Save it\n\n*---------------------------------------------------------------------*\n*   If we are running without APAR OW48527, or MaxLWait was specified,*\n*   update our ESTAE Retry routine address and registers ...          *\n*---------------------------------------------------------------------*\n         TM    @H_OW48527,L'@H_OW48527  Is the APAR on\n         JNO   H00090                   No, skip\n         LH    R0,@H_MaxLWait           Get MaxLWait\n         CHI   R0,0                     Was it specified?\n         JE    H00100                   No, skip\n\nH00090   DS    0H\n         ST    R9,@H_Current_VolTbl_Ent Save A(VolTbl_Ent) for ESTAE\n         STM   R0,R15,@H_ESTAE_Regs     Save our registers for retry\n         MVC   @H_ESTAE_Retry,=AL4(H00120) Set retry address\n\n*---------------------------------------------------------------------*\n*     ... and establish a timer, so we don't wait forever for LSPACE  *\n*---------------------------------------------------------------------*\n         LA    R15,@H_Dynam             A(Dynamic storage)\n         ST    R15,@H_STIMERM_Exit_Parms Save it for the exit routine\n         LA    R15,@H_STIMERM_Exit_Parms Point to parm area\n         ST    R15,@H_STIMERM_Exit_Parms_Ptr  Save the address\n         LA    R3,@H_STIMERM_Exit_Parms_Ptr Point to parm area addr\n         L     R4,=AL4(H06000)          A(Exit)\n\n         L     R15,@H_LSPACE_Wait_Max   Get nbr secs to wait\n         MHI   R15,100                  in BINTVL\n         ST    R15,@H_DBLWD             Save it\n\n         MVC   @H_STIMERM_Set,H_STIMERM_Set Move L-Form of macro\n         STIMERM SET,                   Set a timer                    +\n               ID=@H_STIMERM_ID,         save the ID here              +\n               BINTVL=@H_DBLWD,          for this long                 +\n               EXIT=(4),                 invoke this when we pop       +\n               PARM=(3),                 with this parm                +\n               WAIT=NO,                  Dont wait                     +\n               MF=(E,@H_STIMERM_Set)     keep ourselves reentrant\n\nH00100   DS    0H\n*---------------------------------------------------------------------*\n*     Set up our areas that will be used by LSPACE                    *\n*---------------------------------------------------------------------*\n         XC    VolTbl_Ent_LSPACE_Data,VolTbl_Ent_LSPACE_Data\n         XC    VolTbl_Ent_DSCB,VolTbl_Ent_DSCB Clear DSCB area\n         NI    VolTbl_Ent_LSPACE_Fail,X'FF'-L'VolTbl_Ent_LSPACE_Fail\n\n*---------------------------------------------------------------------*\n*     Save the current TOD (ie, when LSPACE started)                  *\n*---------------------------------------------------------------------*\n         MVC   @H_TIME,H_TIME           MOVE Time macro\n         TIME  STCK,                    Get the current time           +\n               @H_LSPACE_Start,          return it here                +\n               LINKAGE=SYSTEM,           as recommended by IBM         +\n               MF=(E,@H_TIME)            staying re-entrant\n\n*---------------------------------------------------------------------*\n*     Set up the LSPACE parms, including LSPAXTIM if we are both      *\n*    assembling and running on systems with OW48527                   *\n*---------------------------------------------------------------------*\n         MVC   @H_LSPACE,H_LSPACE       Move LSPACE parms\n         AIF   (NOT D'LSPAXTIM).OW48527_200\n         TM    @H_OW48527,L'@H_OW48527  Are we running with OW48527?\n         JNO   H00110                   No, skip\n         L     R15,@H_LSPACE_Wait_Max   Get Wait Time\n         ICM   R0,B'1111',@H_STIMERM_ID Did we set up a STIMER?\n         JNZ   H00110                   Yes, use LSPACE default\n         STC   R15,@H_LSPACE+LSPAXTIM-LSPACE_Parm Update wait limit\nH00110   DS    0H\n.OW48527_200 ANOP\n\n*---------------------------------------------------------------------*\n*     Get the volume info using LSPACE                                *\n*---------------------------------------------------------------------*\n         LA     R3,VolTbl_Ent_UCBCopy   A(Our UCB)\n         LSPACE UCB=(3),                Get free space                 +\n               DATA=VolTbl_Ent_LSPACE_Data, save return info here      +\n               F4DSCB=VolTbl_Ent_DSCB,   Return F4 DSCB too            +\n               MF=(E,@H_LSPACE)          Parm area here\n\nH00120   DS    0H\n*---------------------------------------------------------------------*\n*     Cancel our STIMERM, if there is one ...                         *\n*---------------------------------------------------------------------*\n         ICM   R15,B'1111',@H_STIMERM_ID  Did we establish a timer?\n         JZ    H00130                   No, skip\n\n         MVC   @H_STIMERM_Can,H_STIMERM_Cancel Move L-Form macro\n         STIMERM CANCEL,                Cancel our timer               +\n               ID=@H_STIMERM_ID,         with this Id                  +\n               MF=(E,@H_STIMERM_Can)     keep ourselves reentrant\n         XC    @H_STIMERM_ID,@H_STIMERM_ID Clear STIMERM ID\n\n*---------------------------------------------------------------------*\n*     ... and update our ESTAE retry routine pointer, now that LSPACE *\n*    is done                                                          *\n*---------------------------------------------------------------------*\n         STM   R0,R15,@H_ESTAE_Regs     Save our registers for retry\n         MVC   @H_ESTAE_Retry,=AL4(H00380) Set retry address\n\nH00130   DS    0H\n*---------------------------------------------------------------------*\n*     Save the current TOD, and calculate the amount of time we have  *\n*    been waiting for LSPACE ...                                      *\n*---------------------------------------------------------------------*\n         MVC   @H_TIME,H_TIME           MOVE Time macro\n         TIME  STCK,                    Get the current time           +\n               @H_TIME_Area,             return it here                +\n               LINKAGE=SYSTEM,           as recommended by IBM         +\n               MF=(E,@H_TIME)            staying re-entrant\n\n         LM    R14,R15,@H_Time_Area     Get current time\n         SL    R15,@H_LSPACE_Start+4    Calculate\n         JNM   H00140                   No borrow, skip\n         SL    R14,=FL4'1'              Borrow, reduce\nH00140   DS    0H\n         SL    R14,@H_LSPACE_Start      Calculate WAIT time\n         SRDL  R14,12                   in usec\n         STM   R14,R15,@H_LSPACE_Wait   Save it\n\n*---------------------------------------------------------------------*\n*     ... and add it to the appropriate total (Successful or          *\n*    Unsuccessful LSPACE WAIT time)                                   *\n*---------------------------------------------------------------------*\n         LA    R3,@H_Total_LSPACE_Wait_OK     Assume all worked\n         CLI   @H_LSPACE+LSPAERCD-LSPACE_Parm,X'00' Did LSPACE Work?\n         JE    H00150                   Yes, skip\n         LA    R3,@H_Total_LSPACE_Wait_Bad  No, A(unsuccess total)\n\nH00150   DS    0H\n         LM    R0,R1,0(R3)              Get total (in usec)\n         ALR   R1,R15                   Add the wait time\n         BRC   12,H00160                No carry, skip\n         AL    R0,=FL4'1'               Carry, bump\nH00160   DS    0H\n         ALR   R0,R14                   Bump Wait totals\n         STM   R0,R1,0(R3)              Save Wait Time totals\n\n*---------------------------------------------------------------------*\n*     If LSPACE failed ...                                            *\n*---------------------------------------------------------------------*\n         CLI   @H_LSPACE+LSPAERCD-LSPACE_Parm,X'00' Did LSPACE Work?\n         JE    H00220                   Yes, skip\n\n*---------------------------------------------------------------------*\n*     ... flag the VolTbl_Ent, and generate an appropriate message (we*\n*    generate our own messages, because we would have to re-invoke    *\n*    LSPACE to get LSPACE to do it, and the conditions that caused it *\n*    to fail initially may have changed or disappeared by the time we *\n*    issue LSPACE again) ...                                          *\n*---------------------------------------------------------------------*\n         OI    VolTbl_Ent_LSPACE_Fail,L'VolTbl_Ent_LSPACE_Fail\n         CLC   =X'14850000',@H_LSPACE+LSPAERCD-LSPACE_Parm ESTAE?\n         JNE   H00170                   No, skip\n         TM    VolTbl_Ent_U522,L'VolTbl_Ent_U522 Because of us?\n         JNO   H00170                   No, skip\n         MVC   VolTbl_Ent_ErrMsg(L'H_MsgU522A),H_MsgU522A Say so\n         LH    R0,@H_MaxLWait           Get MaxLWait\n         CVD   R0,@H_DBLWD              Pack it\n         MVC   @H_DBLWD(4),=X'40202120' Move mask\n         LA    R1,@H_DBLWD+3            Set up start marker\n         EDMK  @H_DBLWD(4),@H_DBLWD+6   Edit it\n         LA    R14,@H_DBLWD+3           Last possible character\n         SR    R14,R1                   Length of result\n         LR    R15,R1                   A(Source)\n         AHI   R15,-3                   Adjust it\n         LA    R1,VolTbl_Ent_ErrMsg+L'H_MsgU522A A(Target)\n         EX    R14,H_MVC                Move MaxLWait\n         LA    R1,1(R1,R14)             Point last it\n         MVC   0(L'H_MsgU522B,R1),H_MsgU522B Move remainder\n         J     H00210                   and skip\nH00170   DS    0H\n         L     R15,=AL4(H_LSPACE_Msgs)  A(Message Table)\n         LA    R14,0                    Clear work register\nH00180   DS    0H\n         CLC   0(1,R15),@H_LSPACE+LSPAERCD-LSPACE_Parm  Our RC?\n         JNE   H00190                   No, skip\n         CLI   1(R15),X'00'             Yes, should we check SubFunc?\n         JE    H00200                   No, use this message\n         CLC   1(1,R15),@H_LSPACE+LSPASFID-LSPACE_Parm  Yes, our SF?\n         JE    H00200                   Yes, skip\nH00190   DS    0H\n         CLC   0(2,R15),=X'0000'        No, last entry?\n         JE    H00200                   Yes, we'd better use it\n         IC    R14,2(0,R15)             No, get len of message\n         LA    R15,3(R14,R15)           Point to next entry\n         J     H00180                   and check it out\n\nH00200   DS    0H\n         IC    R14,2(0,R15)             Length of the message\n         AHI   R14,-1                   EX Len\n         LA    R1,VolTbl_Ent_ErrMsg     A(Target)\n         EX    R14,H_MVC                Move the message\n         LA    R14,1(R1,R14)            Point past it\n         MVC   0(29,R14),=C', DADSM/CVAF Diagnostic Info:'\n         MVO   @H_DBLWD(5),@H_LSPACE+LSPAERCD-LSPACE_Parm(4)\n         OI    @H_DBLWD+4,X'0F'         'Pack' it\n         UNPK  29(9,R14),@H_DBLWD(5)    Unpack it\n         MVI   29(R14),C' '             Move separator\n         LA    R15,H_TrTbl              Point to translate table\n         AHI   R15,-240                 Adjust pointer\n         TR    30(8,R14),0(R15)         Make it readable\nH00210   DS    0H\n         J     H00380                   Go process next volume\n\nH00220   DS    0H\n*---------------------------------------------------------------------*\n*     LSPACE worked, so re-calculate the average time used by LSPACE  *\n*---------------------------------------------------------------------*\n         L     R3,@H_LSPACE_Avg_Ptr     A(Timer area)\nH00230   DS    0H\n         LM    R0,R1,0(R3)              Get Avg ms, nbr LSPACEs done\n         LR    R15,R0                   Get Avg micro-secs\n         MR    R14,R1                   Calculate total micro-secs\n         AL    R15,@H_LSPACE_Wait+4     Add the ones we used\n         BRC   12,H00240                No carry, skip\n         AL    R14,=FL4'1'              Carry, bump\nH00240   DS    0H\n         AL    R14,@H_LSPACE_Wait       Bump total WAIT time\n         LR    R4,R1                    Get total LSPACEs completed\n         AHI   R4,1                     Bump because we just finished\n         DR    R14,R4                   Re-calculate average\n         LR    R14,R15                  Set up new values for\n         LR    R15,R4                    Avg, # completed LSPACEs\n         CDS   R0,R14,0(R3)             Update them\n         JNE   H00230                   Collision, try again\n\n*---------------------------------------------------------------------*\n*     If the previous volume we processed wasn't on the same device   *\n*    type as this one, use TRKCALC to get the track size              *\n*---------------------------------------------------------------------*\n         CLC   @H_UCBTBYT4,VolTbl_Ent_UCBCopy+UCBTBYT4-UCBOB Same?\n         JE    H00270                   Yes, skip\n         MVC   @H_UCBTBYT4,VolTbl_Ent_UCBCopy+UCBTBYT4-UCBOB No\n         TRKCALC FUNCTN=TRKBAL,         Track balance                  +\n               TYPE=@H_UCBTBYT4,         A(Type)                       +\n               LOC=ANY,                  which is above the line       +\n               R=1,                      an empty track                +\n               K=0,                      no keys                       +\n               DD=VolTbl_Ent_DSCB+DS4DEVTK-IECSDSL4,  max size         +\n               REMOVE=NO,                Use an empty track            +\n               MAXSIZE=YES,              Return max we can use         +\n               REGSAVE=YES,              Save registers                +\n               MF=(E,@H_TRKCALC)         staying re-entrant\n         CHI   R15,12                    How did it go?\n         JNL   H00250                    Not good, set default\n         LTR   R0,R0                     Did we get a size back?\n         JNZ   H00260                    Yes, OK\nH00250   DS    0H\n         LH    R0,VolTbl_Ent_DSCB+DS4DEVTK-IECSDSL4 No, use default\n         XC    @H_UCBTBYT4,@H_UCBTBYT4\nH00260   DS    0H\n         ST    R0,@H_BytesPerTrack       Save bytes per track\nH00270   DS    0H\n\n*---------------------------------------------------------------------*\n*     Format the LSPACE info about this volume, and update our        *\n*    totals ...                                                       *\n*---------------------------------------------------------------------*\n         L     R15,@H_Total_Vols_OK     Get total valid volumes\n         AHI   R15,1                    Bump it\n         ST    R15,@H_Total_Vols_OK     Save it\n\n*     Tracks in the VTOC\n\n         LH    R0,VolTbl_Ent_DSCB+DS4DEVSZ+2-IECSDSL4 Get Trks/Cyl\n         LA    R1,0                     Clear register\n         ICM   R1,B'0011',VolTbl_Ent_DSCB+DS4VTOCE+6-IECSDSL4 Ending CC\n         LA    R15,0                    Clear register\n         ICM   R15,B'0011',VolTbl_Ent_DSCB+DS4VTOCE+2-IECSDSL4\n         SR    R1,R15                   End CC minus start CC\n         MR    R0,R0                          Get nbr tracks\n         AH    R1,VolTbl_Ent_DSCB+DS4VTOCE+8-IECSDSL4 Add ending HH\n         SH    R1,VolTbl_Ent_DSCB+DS4VTOCE+4-IECSDSL4 Less starting HH\n         AHI   R1,1                     Bump it\n         CDFBR R0,R1                    Convert to floating point\n         LA    R1,VolTbl_Ent_VTOCTrk    Point to output field\n         LHI   R0,L'VolTbl_Ent_VTOCTrk  Length of output field\n         BRAS  R14,H03000               Put in table\n\n         STD   R0,VolTbl_Ent_Sort_VTOCTrk Save it\n         ADB   R0,@H_Total_VTOCTrk      Bump total\n         STD   R0,@H_Total_VTOCTrk       and save it\n\n*     Total DSCBS in the VTOC\n\n         LA    R0,0                     Clear work reg\n         IC    R0,VolTbl_Ent_DSCB+DS4DEVDT-IECSDSL4 DSCBS/Trk\n         CDFBR R0,R0                    Convert to floating point\n         MDB   R0,VolTbl_Ent_Sort_VTOCTrk Nbr tracks in the VTOC\n\n         STD   R0,@H_TotDSCB            Save it\n         ADB   R0,@H_Total_DSCBs        Bump total\n         STD   R0,@H_Total_DSCBs        and save it\n\n*     Free DSCBs in the VTOC\n\n         L     R1,VolTbl_Ent_LSPACE_Data+LSPDF0S-LSPACE_Data Free DSCBs\n         CDFBR R0,R1                    Convert to floating point\n         LA    R1,VolTbl_Ent_FreeDSCB   Point to output field\n         LHI   R0,L'VolTbl_Ent_FreeDSCB Length of output field\n         BRAS  R14,H03000               Put in table\n\n         STD   R0,VolTbl_Ent_Sort_FreeDSCB Save for sorting\n         ADB   R0,@H_Total_FreeDSCBs    Bump total\n         STD   R0,@H_Total_FreeDSCBs    and save it\n\n*     % Free DSCBs in the VTOC\n\n         L     R1,VolTbl_Ent_LSPACE_Data+LSPDF0S-LSPACE_Data Free DSCBs\n         CDFBR R0,R1                    Convert to floating point\n         MDB   R0,=DBL8'1000'           100.0%\n         DDB   R0,@H_TotDSCB            Calc % free DSCBs\n         LA    R1,VolTbl_Ent_VTOCFree   Point to target field\n         LHI   R0,L'VolTbl_Ent_VTOCFree Length of output field\n         BRAS  R14,H03000               Put in table\n\n         DDB   R0,=DBL8'10'             back to xx.x%\n         STD   R0,VolTbl_Ent_Sort_VTOCFree Save it\n\n*     Total bytes on the volume\n\n         LA    R0,0                     Clear register\n         ICM   R0,B'0011',VolTbl_Ent_DSCB+DS4DEVSZ+2-IECSDSL4 Trks/Cyl\n         CDFBR R0,R0                    Convert to floating point\n         LA    R0,0                     Clear register\n         ICM   R0,B'0011',VolTbl_Ent_DSCB+DS4DEVSZ-IECSDSL4 Cyls/Device\n         CDFBR R2,R0                    Convert to floating point\n         MDBR  R0,R2                    Get Trks/Device\n         LA    R0,0                     Clear work register\n         L     R0,@H_BytesPerTrack      Bytes/Trk\n         CDFBR R2,R0                    Convert to floating point\n         MDBR  R0,R2                    Bytes/Device\n         STD   R0,VolTbl_Ent_Sort_VolSize Save for sorting\n         STD   R0,@H_VolSize            Save it\n         LA    R1,VolTbl_Ent_VolSize    Point to output field\n         LHI   R0,L'VolTbl_Ent_VolSize  Length of output field\n         BRAS  R14,H03000               Put in table\n\n         ADB   R0,@H_Total_VolSize      Bump total\n         STD   R0,@H_Total_VolSize      and save it\n\n*     Nbr Free Extents on the volume\n\n         L     R1,VolTbl_Ent_LSPACE_Data+LSPDNEXT-LSPACE_Data Free ext\n         CDFBR R0,R1                    Convert to floating point\n         LA    R1,VolTbl_Ent_FreeExt    Point to output field\n         LHI   R0,L'VolTbl_Ent_FreeExt  Length of output field\n         BRAS  R14,H03000               Put in table\n\n         STD   R0,VolTbl_Ent_Sort_FreeExt Save for sorting\n         ADB   R0,@H_Total_Extents      Bump total\n         STD   R0,@H_Total_Extents      and save it\n\n*     Free Tracks on the volume\n\n         L     R0,VolTbl_Ent_LSPACE_Data+LSPDTCYL-LSPACE_Data Free Cyls\n         CDFBR R0,R0                    Convert to floating point\n         LH    R0,VolTbl_Ent_DSCB+DS4DEVSZ+2-IECSDSL4 Trks/Cyl\n         CDFBR R2,R0                    Convert to floating point\n         MDBR  R0,R2                    Get nbr free trks (in cyls)\n         L     R0,VolTbl_Ent_LSPACE_Data+LSPDTTRK-LSPACE_Data Free trks\n         CDFBR R2,R0                    Convert to floating point\n         ADBR  R0,R2                    Bump nbr trks\n         STD   R0,VolTbl_Ent_Sort_FreeTrk Save for sorting\n         LA    R1,VolTbl_Ent_FreeTrk    Point to output field\n         LHI   R0,L'VolTbl_Ent_FreeTrk  Length of output field\n         BRAS  R14,H03000               Put in table\n\n         ADB   R0,@H_Total_FreeTracks   Bump total\n         STD   R0,@H_Total_FreeTracks   and save it\n\n*     Free Bytes on the volume\n\n         LD    R0,VolTbl_Ent_Sort_FreeTrk Get nbr free tracks\n         LA    R0,0                     Clear work register\n         L     R0,@H_BytesPerTrack      Bytes/Trk\n         CDFBR R2,R0                    Convert to Floating point\n         MDBR  R0,R2                    Nbr free bytes\n         STD   R0,VolTbl_Ent_Sort_FreeBytes Save for sorting\n         LA    R1,VolTbl_Ent_FreeBytes  Point to output field\n         LHI   R0,L'VolTbl_Ent_FreeBytes Length of output field\n         BRAS  R14,H03000               Put in table\n\n         ADB   R0,@H_Total_FreeBytes    Bump totals\n         STD   R0,@H_Total_FreeBytes    and save it\n\n*     % Free space on the volume\n\n         LD    R0,VolTbl_Ent_Sort_FreeBytes Free Bytes on the volume\n         MDB   R0,=DBL8'1000'           Set up for % calc (100.0%)\n         DDB   R0,@H_VolSize            Divide by Bytes/Device\n         LA    R1,VolTbl_Ent_FreePct    Point to output field\n         LHI   R0,L'VolTbl_Ent_FreePct  Length of output field\n         BRAS  R14,H03000               Put in table\n\n         DDB   R0,=DBL8'10'             Convert to xx.x%\n         STD   R0,VolTbl_Ent_Sort_FreePct Save it\n\n*     Free Cylinders on the volume\n\n         L     R1,VolTbl_Ent_LSPACE_Data+LSPDTCYL-LSPACE_Data Free Cyls\n         CDFBR R0,R1                    Convert to floating point\n         LA    R1,VolTbl_Ent_FreeCyl    Point to output field\n         LHI   R0,L'VolTbl_Ent_FreeCyl  Length of output field\n         BRAS  R14,H03000               Put in table\n\n         STD   R0,VolTbl_Ent_Sort_FreeCyl Save for sorting\n         ADB   R0,@H_Total_FreeCyls     Bump totals\n         STD   R0,@H_Total_FreeCyls     and save it\n\n*     Largest extent (in tracks) on the volume\n\n         L     R0,VolTbl_Ent_LSPACE_Data+LSPDLCYL-LSPACE_Data Larg Cyls\n         CDFBR R0,R0                    Convert to FP\n         LH    R0,VolTbl_Ent_DSCB+DS4DEVSZ+2-IECSDSL4 Trks/Cyl\n         CDFBR R2,R0                    Convert to FP\n         MDBR  R0,R2                    Get nbr trks\n         L     R0,VolTbl_Ent_LSPACE_Data+LSPDLTRK-LSPACE_Data Get trks\n         CDFBR R2,R0                    Convert to FP\n         ADBR  R0,R2                    Add to total\n         STD   R0,VolTbl_Ent_Sort_LargTrk Save for sorting\n         LA    R1,VolTbl_Ent_LargTrk    Point to output field\n         LHI   R0,L'VolTbl_Ent_LargTrk  Length of output field\n         BRAS  R14,H03000               Put in table\n\n         CDB   R0,@H_Largest_FreeTracks Biggest so far?\n         JNH   H00280                   No, skip\n         STD   R0,@H_Largest_FreeTracks Yes, save it\n\nH00280   DS    0H\n\n*     Largest extent (in cylinders) on the volume\n\n         L     R0,VolTbl_Ent_LSPACE_Data+LSPDLCYL-LSPACE_Data Larg Cyls\n         CDFBR R0,R0                    Convert to floating point\n         LA    R1,VolTbl_Ent_LargCyl    Point to output field\n         LHI   R0,L'VolTbl_Ent_LargCyl  Length of output field\n         BRAS  R14,H03000               Put in table\n\n         STD   R0,VolTbl_Ent_Sort_LargCyl Save for sorting\n         CDB   R0,@H_Largest_FreeCyls   Largest so far?\n         JNH   H00290                   No, skip\n         STD   R0,@H_Largest_FreeCyls   Yes, save it\n\nH00290   DS    0H\n*---------------------------------------------------------------------*\n*     VTOC IX Status: A - Active                                      *\n*                     E - Exists, but not active                      *\n*                     N - Does not exist                              *\n*---------------------------------------------------------------------*\n         TM    VolTbl_Ent_LSPACE_Data+LSPDSTAT-LSPACE_Data,LSPDIXAC\n         JO    H00300                   Yes, skip\n         TM    VolTbl_Ent_LSPACE_Data+LSPDSTAT-LSPACE_Data,LSPDIXDS IX?\n         JO    H00310                   Yes, skip\n         MVI   VolTbl_Ent_VTOCIX+1,C'N' No, No IX VTOC\n         J     H00320                   and skip\nH00300   DS    0H\n         MVI   VolTbl_Ent_VTOCIX+1,C'A' IX VTOC active\n         J     H00320                   and skip\nH00310   DS    0H\n         MVI   VolTbl_Ent_VTOCIX+1,C'Y' IX VTOC exists\n         J     H00320                   and skip\n\nH00320   DS    0H\n*---------------------------------------------------------------------*\n*     Fragmentation Index                                             *\n*---------------------------------------------------------------------*\n         L     R0,VolTbl_Ent_LSPACE_Data+LSPDFRAG-LSPACE_Data Frag Indx\n         CHI   R0,999                   Too big?\n         JNH   H00330                   No, OK\n         LHI   R0,999                   Yes, set to max\nH00330   DS    0H\n         CDFBR R0,R0                    Convert to floating point\n         LHI   R0,L'VolTbl_Ent_Frag_Indx Len of target field\n         LA    R1,VolTbl_Ent_Frag_Indx  Point to it\n         BRAS  R14,H03000               Go format it\n\n         ADB   R0,@H_Total_FragIndex    Bump totals\n         STD   R0,@H_Total_FragIndex    and save it\n\n*---------------------------------------------------------------------*\n*     SMS Anomaly                                                     *\n*---------------------------------------------------------------------*\n         CLI   VolTbl_Ent_DSCB+DS4SMSFG-IECSDSL4,DS4NTSMS SMS in VTOC?\n         JE    H00340                   No, skip\n         TM    VolTbl_Ent_UCBCOPY+UCBFL5-UCBOB,UCBSMS Yes, UCB SMS too?\n         JO    H00370                   Yes, OK\n         J     H00350                   No, set message\nH00340   DS    0H\n         TM    VolTbl_Ent_UCBCOPY+UCBFL5-UCBOB,UCBSMS NO, UCB = SMS?\n         JZ    H00370                   No, OK\nH00350   DS    0H\n         MVI   VolTbl_Ent_VTOC_SMS,C'*' No, flag it\n         ICM   R14,B'1111',@H_SMS_Anomaly_Ptr  Yes, A(SMS Anomaly line)\n         JZ    H00370                   None, skip\n         TM    VolTbl_Ent_ECB-VolTbl_Ent(R14),X'40' Already done?\n         JO    H00370                   Yes, skip\n         LA    R0,VolTbl_Ent_VTOC_SMS-VolTbl_Ent(0,R14) A(Target)\n         LHI   R1,VolTbl_Ent_Display_End-VolTbl_Ent_VTOC_SMS Target Len\n         LA    R14,H_SMS_Anomaly_Msg    A(Source)\n         LA    R15,L'H_SMS_Anomaly_Msg  Source length\n         O     R15,=XL4'40000000'       Fill with blanks\n         MVCL  R0,R14                   Move message\n\n         L     R15,@H_SMS_Anomaly_Ptr   A(SMS Anomaly line)\n         L     R0,VolTbl_Ent_ECB-VolTbl_Ent(R15) Current ECB\n         TM    VolTbl_Ent_ECB-VolTbl_Ent(R15),X'80' Anyone WAITing?\n         JO    H00360                   Yes, we need to POST\n         L     R1,=XL4'40000000'        No, POST code of 0\n         CS    R0,R1,VolTbl_Ent_ECB-VolTbl_Ent(R15) Pseudo-POST it\n         JZ    H00370                   OK, skip the real POST\nH00360   DS    0H\n         POST  VolTbl_Ent_ECB-VolTbl_Ent(R15),0 POST line as complete\nH00370   DS    0H\n\nH00380   DS    0H\n*---------------------------------------------------------------------*\n*     POST this entry as complete ...                                 *\n*---------------------------------------------------------------------*\n         L     R14,VolTbl_Ent_ECB       Current contents of our ECB\n         TM    VolTbl_Ent_ECB,X'80'     Anyone WAITing?\n         JO    H00390                   Yes, we need to POST\n         L     R15,=XL4'40000000'       No, POST code of 0\n         CS    R14,R15,VolTbl_Ent_ECB   Pseudo-POST it\n         JZ    H00400                   OK, skip the real POST\nH00390   DS    0H\n         POST  VolTbl_Ent_ECB,0         Flag as complete\nH00400   DS    0H\n\nH00410   DS    0H\n*---------------------------------------------------------------------*\n*     ... and see if we can find another volume to do.                *\n*---------------------------------------------------------------------*\n         AHI   R9,VolTbl_Ent_Len        Point to next VolTbl_Ent\n         BRCT  R10,H00050               and check it out\n\n*---------------------------------------------------------------------*\n*     We are done - update the totals, if required ...                *\n*---------------------------------------------------------------------*\n         ICM   R9,B'1111',@H_Totals_Line_Ptr   A(Totals Line)\n         JZ    H00560                   None, skip\n\nH00420   DS    0H\n         L     R0,VolTbl_Ent_Total_Vols_OK Curr count\n         LR    R1,R0                    Save it\n         A     R1,@H_Total_Vols_OK      Bump it\n         CS    R0,R1,VolTbl_Ent_Total_Vols_OK Update it\n         JNZ   H00420                   Collision, try again\n\n         LD    R0,@H_Total_VTOCTrk      Amount we did\nH00430   DS    0H\n         LM    R0,R1,VolTbl_Ent_Total_VTOCTrk Orig Val\n         STM   R0,R1,@H_DBLWD           Save original value\n         LD    R2,@H_DBLWD              Load up FP register\n         ADBR  R2,R0                    Bump it\n         STD   R2,@H_DBLWD              Save updated total\n         LM    R2,R3,@H_DBLWD           Get new totals\n         CDS   R0,R2,VolTbl_Ent_Total_VTOCTrk Update it\n         JNZ   H00430                   Collision, try again\n\n         LD    R0,@H_Total_DSCBs        Get amount we did\nH00440   DS    0H\n         LM    R0,R1,VolTbl_Ent_Total_DSCBs\n         STM   R0,R1,@H_DBLWD           Save original value\n         LD    R2,@H_DBLWD              Load up FP register\n         ADBR  R2,R0                    Bump it\n         STD   R2,@H_DBLWD              Save updated total\n         LM    R2,R3,@H_DBLWD           Get old, new totals\n         CDS   R0,R2,VolTbl_Ent_Total_DSCBs Update it\n         JNZ   H00440                   Collision, try again\n\n         LD    R0,@H_Total_FreeDSCBs    Get amount we did\nH00450   DS    0H\n         LM    R0,R1,VolTbl_Ent_Total_FreeDSCBs\n         STM   R0,R1,@H_DBLWD           Save original value\n         LD    R2,@H_DBLWD              Load up FP register\n         ADBR  R2,R0                    Bump it\n         STD   R2,@H_DBLWD              Save updated total\n         LM    R2,R3,@H_DBLWD           Get old, new totals\n         CDS   R0,R2,VolTbl_Ent_Total_FreeDSCBs Update\n         JNZ   H00450                   Collision, try again\n\n         LD    R0,@H_Total_VolSize      Get amount we did\nH00460   DS    0H\n         LM    R0,R1,VolTbl_Ent_Total_VolSize\n         STM   R0,R1,@H_DBLWD           Save original value\n         LD    R2,@H_DBLWD              Load up FP register\n         ADBR  R2,R0                    Bump it\n         STD   R2,@H_DBLWD              Save updated total\n         LM    R2,R3,@H_DBLWD           Get old, new totals\n         CDS   R0,R2,VolTbl_Ent_Total_VolSize Update it\n         JNZ   H00460                   Collision, try again\n\n         LD    R0,@H_Total_Extents      Get amount we did\nH00470   DS    0H\n         LM    R0,R1,VolTbl_Ent_Total_Extents\n         STM   R0,R1,@H_DBLWD           Save original value\n         LD    R2,@H_DBLWD              Load up FP register\n         ADBR  R2,R0                    Bump it\n         STD   R2,@H_DBLWD              Save updated total\n         LM    R2,R3,@H_DBLWD           Get old, new totals\n         CDS   R0,R2,VolTbl_Ent_Total_Extents Update it\n         JNZ   H00470                   Collision, try again\n\n         LD    R0,@H_Total_FreeTracks   Get amount we did\nH00480   DS    0H\n         LM    R0,R1,VolTbl_Ent_Total_FreeTracks\n         STM   R0,R1,@H_DBLWD           Save original value\n         LD    R2,@H_DBLWD              Load up FP register\n         ADBR  R2,R0                    Bump it\n         STD   R2,@H_DBLWD              Save updated total\n         LM    R2,R3,@H_DBLWD           Get old, new totals\n         CDS   R0,R2,VolTbl_Ent_Total_FreeTracks Update\n         JNZ   H00480                   Collision, try again\n\n         LD    R0,@H_Total_FreeBytes    Get amount we did\nH00490   DS    0H\n         LM    R0,R1,VolTbl_Ent_Total_FreeBytes\n         STM   R0,R1,@H_DBLWD           Save original value\n         LD    R2,@H_DBLWD              Load up FP register\n         ADBR  R2,R0                    Bump it\n         STD   R2,@H_DBLWD              Save updated total\n         LM    R2,R3,@H_DBLWD           Get old, new totals\n         CDS   R0,R2,VolTbl_Ent_Total_FreeBytes Update\n         JNZ   H00490                   Collision, try again\n\n         LD    R0,@H_Total_FreeCyls     Get amount we did\nH00500   DS    0H\n         LM    R0,R1,VolTbl_Ent_Total_FreeCyls\n         STM   R0,R1,@H_DBLWD           Save original value\n         LD    R2,@H_DBLWD              Load up FP register\n         ADBR  R2,R0                    Bump it\n         STD   R2,@H_DBLWD              Save updated total\n         LM    R2,R3,@H_DBLWD           Get old, new totals\n         CDS   R0,R2,VolTbl_Ent_Total_FreeCyls Update\n         JNZ   H00500                   Collision, try again\n\n         LD    R0,@H_Largest_FreeTracks Get the biggest we did\nH00510   DS    0H\n         LM    R0,R1,VolTbl_Ent_Largest_FreeTracks\n         STM   R0,R1,@H_DBLWD           Save original value\n         LD    R2,@H_DBLWD              Load up FP register\n         CDBR  R0,R2                    Biggest so far?\n         JNH   H00520                   No, skip\n         STD   R0,@H_DBLWD              Yes, save new largest\n         LM    R2,R3,@H_DBLWD           Get old, new values\n         CDS   R0,R2,VolTbl_Ent_Largest_FreeTracks\n         JNZ   H00510                   Collision, try again\n\nH00520   DS    0H\n\n         LD    R0,@H_Largest_FreeCyls   Get the largest we did\nH00530   DS    0H\n         LM    R0,R1,VolTbl_Ent_Largest_FreeCyls\n         STM   R0,R1,@H_DBLWD           Save original value\n         LD    R2,@H_DBLWD              Load up FP register\n         CDBR  R0,R2                    Biggest so far?\n         JNH   H00540                   No, skip\n         STD   R0,@H_DBLWD              Yes, save new largest\n         LM    R2,R3,@H_DBLWD           Get old, new values\n         CDS   R0,R2,VolTbl_Ent_Largest_FreeCyls\n         JNZ   H00530                   Collision, try again\n\nH00540   DS    0H\n\n         LD    R0,@H_Total_FragIndex    Yes, bump totals\nH00550   DS    0H\n         LM    R0,R1,VolTbl_Ent_Total_FragIndex\n         STM   R0,R1,@H_DBLWD           Save original value\n         LD    R2,@H_DBLWD              Load up FP register\n         ADBR  R2,R0                    Bump it\n         STD   R2,@H_DBLWD              Save updated total\n         LM    R2,R3,@H_DBLWD           Get old, new totals\n         CDS   R0,R2,VolTbl_Ent_Total_FragIndex Update\n         JNZ   H00550                   Collision, try again\n\nH00560   DS    0H\n*---------------------------------------------------------------------*\n*     ... and then the total number of volumes we did                 *\n*---------------------------------------------------------------------*\n         L     R15,@H_VolTbl_Ptr        A(Volume Table)\n         L     R0,VolTbl_Hdr_Vols_Proc-VolTbl_Hdr(R15) Get current\n         LR    R1,R0                    Save it\n         A     R1,@H_Total_Vols_Proc    Bump it\n         CS    R0,R1,VolTbl_Hdr_Vols_Proc-VolTbl_Hdr(R15) Update it\n         JNZ   H00560                   Collision, try again\n\n*---------------------------------------------------------------------*\n*     If this completes the table, fill in the totals, if required    *\n*---------------------------------------------------------------------*\n         C     R1,VolTbl_Hdr_Vols_Total-VolTbl_Hdr(R15) All done?\n         JL    H00610                   No, skip\n         OI    @H_VolTbl_Complete,L'@H_VolTbl_Complete Yes, flag it\n\n         ICM   R9,B'1111',@H_Totals_Line_Ptr A(Totals line)\n         JZ    H00590                   None, all done\n\n         LD    R0,VolTbl_Ent_Total_VolSize Get Total bytes\n         LTDBR R0,R0                    Any?\n         JZ    H00570                   No, we're done with the totals\n\n         LD    R0,VolTbl_Ent_Total_FreeTracks Total free tracks\n         LA    R1,VolTbl_Ent_FreeTrk    Point to output field\n         LHI   R0,L'VolTbl_Ent_FreeTrk  Length of output field\n         BRAS  R14,H03000               Put in table\n\n         LD    R0,VolTbl_Ent_Total_FreeCyls Total Free Cyls\n         LA    R1,VolTbl_Ent_FreeCyl    Point to output field\n         LHI   R0,L'VolTbl_Ent_FreeCyl  Length of output field\n         BRAS  R14,H03000               Put in table\n\n         LD    R0,VolTbl_Ent_Total_FreeBytes Total Free Bytes\n         DDB   R0,VolTbl_Ent_Total_Volsize divided by total bytes\n         MDB   R0,=DBL8'1000'           Set up as a % (100.0)\n         LA    R1,VolTbl_Ent_FreePct    Point to output field\n         LHI   R0,L'VolTbl_Ent_FreePct  Length of output field\n         BRAS  R14,H03000               Put in table\n         DDB   R0,=DBL8'10'             back to xx.x\n         STD   R0,VolTbl_Ent_Total_FreePct Save it\n\n         LD    R0,VolTbl_Ent_Total_FreeBytes Total Free Bytes\n         LA    R1,VolTbl_Ent_FreeBytes  Point to output field\n         LHI   R0,L'VolTbl_Ent_FreeBytes Length of output field\n         BRAS  R14,H03000               Put in table\n\n         LD    R0,VolTbl_Ent_Total_Extents Total Extents\n         LA    R1,VolTbl_Ent_FreeExt    Point to output field\n         LHI   R0,L'VolTbl_Ent_FreeExt  Length of output field\n         BRAS  R14,H03000               Put in table\n\n         LD    R0,VolTbl_Ent_Largest_FreeCyls Largest Free Cyls\n         LA    R1,VolTbl_Ent_LargCyl    Point to output field\n         LHI   R0,L'VolTbl_Ent_LargCyl  Length of output field\n         BRAS  R14,H03000               Put in table\n\n         LD    R0,VolTbl_Ent_Largest_FreeTracks Largest Free Tracks\n         LA    R1,VolTbl_Ent_LargTrk    Point to output field\n         LHI   R0,L'VolTbl_Ent_LargTrk  Length of output field\n         BRAS  R14,H03000               Put in table\n\n         LD    R0,VolTbl_Ent_Total_VTOCTrk Total VTOC tracks\n         LA    R1,VolTbl_Ent_VTOCTrk    Point to output field\n         LHI   R0,L'VolTbl_Ent_VTOCTrk  Length of output field\n         BRAS  R14,H03000               Put in table\n\n         LD    R0,VolTbl_Ent_Total_FreeDSCBs Total Free DSCBs\n         LA    R1,VolTbl_Ent_FreeDSCB   Point to output field\n         LHI   R0,L'VolTbl_Ent_FreeDSCB Length of output field\n         BRAS  R14,H03000               Put in table\n\n         LD    R0,VolTbl_Ent_Total_FreeDSCBs Get Total Free DSCBs\n         DDB   R0,VolTbl_Ent_Total_DSCBs Get percent free\n         MDB   R0,=DBL8'1000'           * 100.0\n         LA    R1,VolTbl_Ent_VTOCFree   Point to output field\n         LHI   R0,L'VolTbl_Ent_VTOCFree Length of output field\n         BRAS  R14,H03000               Put in table\n         MDB   R0,=DBL8'10'             back to xx.x\n         STD   R0,VolTbl_Ent_Total_VTOCFree Save it\n\n         LD    R0,VolTbl_Ent_Total_VolSize Get Total Bytes\n         LA    R1,VolTbl_Ent_VolSize    Point to output field\n         LHI   R0,L'VolTbl_Ent_VolSize  Length of output field\n         BRAS  R14,H03000               Put in table\n\n         L     R0,VolTbl_Ent_Total_Vols_OK Number of volumes with data\n         CDFBR R2,R0                    Convert to floating point\n         LD    R0,VolTbl_Ent_Total_FragIndex Get Total Frag Index\n         DDBR  R0,R2                    Get avg frag index\n         LA    R1,VolTbl_Ent_Frag_Indx  Point to output field\n         LHI   R0,L'VolTbl_Ent_Frag_Indx Length of output field\n         BRAS  R14,H03000               Put in table\n\nH00570   DS    0H\n*---------------------------------------------------------------------*\n*     ... POST it as complete ...                                     *\n*---------------------------------------------------------------------*\n         L     R14,VolTbl_Ent_ECB       Current contents of our ECB\n         TM    VolTbl_Ent_ECB,X'80'     Anyone WAITing?\n         JO    H00580                   Yes, we need to POST\n         L     R15,=XL4'40000000'       No, POST code of 0\n         CS    R14,R15,VolTbl_Ent_ECB   Pseudo-POST it\n         JZ    H00590                   OK, skip the real POST\nH00580   DS    0H\n         POST  VolTbl_Ent_ECB,0         Flag as complete\n\nH00590   DS    0H\n*---------------------------------------------------------------------*\n*     ... if the SMS anomaly line has not been completed (because     *\n*    there was no SMS anomaly), flag it as complete now               *\n*---------------------------------------------------------------------*\n         ICM   R9,B'1111',@H_SMS_Anomaly_Ptr A(SMS Anomaly line)\n         JZ    H00610                   None, skip\n         TM    VolTbl_Ent_ECB,X'40'     Already POSTed?\n         JO    H00610                   Yes, skip\n         L     R14,VolTbl_Ent_ECB       Current contents of our ECB\n         TM    VolTbl_Ent_ECB,X'80'     Anyone WAITing?\n         JO    H00600                   Yes, we need to POST\n         L     R15,=XL4'40000000'       No, POST code of 0\n         CS    R14,R15,VolTbl_Ent_ECB   Pseudo-POST it\n         JZ    H00610                   OK, skip the real POST\nH00600   DS    0H\n         POST  VolTbl_Ent_ECB,0         Flag as complete\n\nH00610   DS    0H\n*---------------------------------------------------------------------*\n*     Fill in our Stats line, if present                              *\n*---------------------------------------------------------------------*\n         ICM   R9,B'1111',@H_Stats_Line_Ptr A(1st Stats Heading line)\n         JZ    H00730                   None, skip\n\n*---------------------------------------------------------------------*\n*     If the headings haven't yet been filled in (i.e., we are the    *\n*    first ones here), fill them in ...                               *\n*---------------------------------------------------------------------*\n         LA    R2,H_SubTask_Hdgs        A(Start of headings)\n         LA    R4,H_SubTask_Hdg_Lens    A(Lengths of heading lines)\n         LHI   R5,H_SubTask_Hdg_Count   Get nbr heading lines\nH00620   DS    0H\n         TM    VolTbl_Ent_Processed,L'VolTbl_Ent_Processed Done?\n         JNZ   H00650                   Yes, try next\n\n         L     R1,VolTbl_Ent_Processed  No, get the Flag byte\n         LA    R0,L'VolTbl_Ent_Processed Set up the\n         SLL   R0,24                     flag turned\n         OR    R0,R1                     on\n         CS    R1,R0,VolTbl_Ent_Processed and update it\n         JNE   H00650                   Somebody else here, skip it\n\n         LH    R3,0(0,R4)               Len of heading line\n         O     R3,=XL4'40000000'        Pad char of blank\n         LA    R0,VolTbl_Ent_Display    A(Target)\n         LHI   R1,L'VolTbl_Ent_Display  Length of target\n         MVCL  R0,R2                    Move heading\n         OI    VolTbl_Ent_Stats_Done,l'VolTbl_Ent_Stats_Done Done\n\n         L     R0,VolTbl_Ent_ECB        Current contents of our ECB\n         TM    VolTbl_Ent_ECB,X'80'     Anyone WAITing?\n         JO    H00630                   Yes, we need to POST\n         L     R1,=XL4'40000000'        No, POST code of 0\n         CS    R0,R1,VolTbl_Ent_ECB     Pseudo-POST it\n         JZ    H00640                   OK, skip the real POST\nH00630   DS    0H\n         POST  VolTbl_Ent_ECB,0         POST line as complete\nH00640   DS    0H\n\nH00650   DS    0H\n         AHI   R9,VolTbl_Ent_Len        Bump entry pointer\n         AHI   R4,2                     Bump lengths pointer\n         BRCT  R5,H00620                and try again\n\n*---------------------------------------------------------------------*\n*     Headings all done, find an unused entry for our subtask stats   *\n*    At this point, R9 points to the line after the subtask hdgs.     *\n*---------------------------------------------------------------------*\n         L     R14,@H_VolTbl_Ptr        A(VolTbl)\n         AHI   R14,VolTbl_Ent-VolTbl_Hdr  A(1st entry)\n         LR    R15,R9                   A(Our entry\n         SR    R15,R14                  Offset of our line\n         LA    R14,0                    Clear R14\n         LHI   R0,VolTbl_Ent_Len        Length of 1 entry\n         DR    R14,R0                   Get our entry num\n         S     R15,=FL4'1'              Relative to 0\n         JM    H00730                   Negative, skip it\n         L     R10,@H_VolTbl_Ptr        A(VolTbl) again\n         L     R10,VolTbl_Hdr_Count-VolTbl_Hdr(0,R10) Nbr entries\n         SR    R10,R15                  Nbr entries remaining\n         JNP   H00730                   None, skip it\n         LR    R3,R10                   Init SubTask Nbr\nH00660   DS    0H\n         TM    VolTbl_Ent_Processed,L'VolTbl_Ent_Processed Done?\n         JNZ   H00670                   Yes, try next\n\n         L     R1,VolTbl_Ent_Processed  No, get the Flag byte\n         LA    R0,L'VolTbl_Ent_Processed Set up the\n         SLL   R0,24                     flag turned\n         OR    R0,R1                     on\n         CS    R1,R0,VolTbl_Ent_Processed and update it\n         JE    H00680                   OK, skip\nH00670   DS    0H\n         AHI   R9,VolTbl_Ent_Len        Bump entry pointer\n         BRCT  R10,H00660               and try again\n         J     H00730                   None, skip it\nH00680   DS    0H\n*---------------------------------------------------------------------*\n*     Output our subtask stats.  Note that if we did all the volumes, *\n*   we were BASR'd to, rather than ATTACHed. In this case, we do      *\n*   not put out the 1st and 3rd fields (SubTask Nbr and CPU Time).    *\n*---------------------------------------------------------------------*\n         L     R14,=AL4(H_SubTask_Line) A(Stats line skeleton)\n         LHI   R15,H_SubTask_Line_Len   Len of skeleton\n         O     R15,=XL4'40000000'       Pad char of blank\n         LA    R0,VolTbl_Ent_Display    A(Target)\n         LA    R1,VolTbl_Ent_Display_Len Length of target\n         MVCL  R0,R14                   Move skeleton\n\n         L     R15,@H_Total_Vols_Proc   Total volumes\n         CVD   R15,@H_DBLWD             Pack it\n         ED    VolTbl_Ent_Display+H_SubTask_Line_TotVol-H_SubTask_Line(+\n               L'H_SubTask_Line_TotVol),@H_DBLWD+5\n\n         L     R0,@H_Total_Vols_Proc    Number of volumes we did\n         L     R15,@H_VolTbl_Ptr        A(Volume Table)\n         C     R0,VolTbl_Hdr_Vols_Total-VolTbl_Hdr(R15) All us?\n         JL    H00690                   No, others here too\n         MVC   VolTbl_Ent_Display+H_SubTask_Line_Nbr+1-H_SubTask_Line(L+\n               'H_SubTask_Line_Nbr-1),VolTbl_Ent_Display+H_SubTask_Line+\n               _Nbr-H_SubTask_Line      Clear ED mask\n         MVC   VolTbl_Ent_Display+H_SubTask_Line_Nbr+L'H_SubTask_Line_N+\n               br-3-H_SubTask_Line(3),=C'N/A'\n         MVC   VolTbl_Ent_Display+H_SubTask_Line_CPU+1-H_SubTask_Line(L+\n               'H_SubTask_Line_CPU-1),VolTbl_Ent_Display+H_SubTask_Line+\n               _CPU-H_SubTask_Line      Clear ED mask\n         MVC   VolTbl_Ent_Display+H_SubTask_Line_CPU+L'H_SubTask_Line_C+\n               PU-3-H_SubTask_Line(3),=C'N/A'\n         J     H00700                   and skip\n\nH00690   DS    0H\n         SR    R3,R10                   SubTask nbr\n         AHI   R3,1                     Relative to 1\n         CVD   R3,@H_DBLWD              Pack it\n         ED    VolTbl_Ent_Display+H_SubTask_Line_Nbr-H_SubTask_Line(L'H+\n               _SubTask_Line_Nbr),@H_DBLWD+6\n\n         TIMEUSED STORADR=@H_DBLWD,     Get CPU time used              +\n               LINKAGE=SYSTEM,           as recommended by IBM         +\n               CPU=MIC                   get it in microseconds\n         LM    R14,R15,@H_DBLWD         Get microseconds\n         D     R14,=FL4'1000'           Convert to milliseconds\n         CVD   R15,@H_DBLWD             Pack it\n         ED    VolTbl_Ent_Display+H_SubTask_Line_CPU-H_SubTask_Line(L'H+\n               _SubTask_Line_CPU),@H_DBLWD+5\n\nH00700   DS    0H\n         L     R15,@H_Total_Vols_OK     Volumes where LSPACE worked\n         CVD   R15,@H_DBLWD             Pack it\n         ED    VolTbl_Ent_Display+H_SubTask_Line_Vol_OK-H_SubTask_Line(+\n               L'H_SubTask_Line_Vol_OK),@H_DBLWD+5\n\n         LM    R14,R15,@H_Total_LSPACE_Wait_OK Good LSPACE time (usec)\n         D     R14,=FL4'1000'           Convert to milliseconds\n         CVD   R15,@H_DBLWD             Pack it\n         ED    VolTbl_Ent_Display+H_SubTask_Line_Wait_OK-H_SubTask_Line+\n               (L'H_SubTask_Line_Wait_OK),@H_DBLWD+5\n\n         L     R15,@H_Total_Vols_Proc   Total volumes\n         S     R15,@H_Total_Vols_OK      minus ones where LSPACE OK\n         CVD   R15,@H_DBLWD             Pack it\n         ED    VolTbl_Ent_Display+H_SubTask_Line_Vol_Bad-H_SubTask_Line+\n               (L'H_SubTask_Line_Vol_Bad),@H_DBLWD+5\n\n         LM    R14,R15,@H_Total_LSPACE_Wait_Bad Fail LSPACE time (usec)\n         D     R14,=FL4'1000'           Convert to milliseconds\n         CVD   R15,@H_DBLWD             Pack it\n         ED    VolTbl_Ent_Display+H_SubTask_Line_Wait_Bad-H_SubTask_Lin+\n               e(L'H_SubTask_Line_Wait_Bad),@H_DBLWD+5\n\n\n         OI    VolTbl_Ent_Stats_Done,L'VolTbl_Ent_Stats_Done Done\n\n         L     R0,VolTbl_Ent_ECB        Current contents of our ECB\n         TM    VolTbl_Ent_ECB,X'80'     Anyone WAITing?\n         JO    H00710                   Yes, we need to POST\n         L     R1,=XL4'40000000'        No, POST code of 0\n         CS    R0,R1,VolTbl_Ent_ECB     Pseudo-POST it\n         JZ    H00720                   OK, skip the real POST\nH00710   DS    0H\n         POST  VolTbl_Ent_ECB,0         POST line as complete\nH00720   DS    0H\n\n\nH00730   DS    0H\n*---------------------------------------------------------------------*\n*     If we are the last ones here (i.e., we finished VolTbl),        *\n*    flag the table as complete                                       *\n*---------------------------------------------------------------------*\n         TM    @H_VolTbl_Complete,L'@H_VolTbl_Complete All done?\n         JNO   H00750                   No, skip\n\n         L     R10,@H_VolTbl_Ptr        A(VolTbl)\n         L     R14,VolTbl_Hdr_ECB-VolTbl_Hdr(R10) Contents of our ECB\n         TM    VolTbl_Hdr_ECB-VolTbl_Hdr(R10),X'80' Anyone WAITing?\n         JO    H00740                   Yes, we need to POST\n         L     R15,=XL4'40000000'       No, POST code of 0\n         CS    R14,R15,VolTbl_Hdr_ECB-VolTbl_Hdr(R10) Pseudo-POST it\n         JZ    H00750                   OK, skip the real POST\nH00740   DS    0H\n         POST  VolTbl_Hdr_ECB-VolTbl_Hdr(R10),0 Flag as complete\nH00750   DS    0H\n\n         J     H90010                   All done, exit\n\n\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n\nH03000   DS    0H\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*   Format and scale a long binary FP number                          *\n*                                                                     *\n*   On Entry, FP0     = Long FP value                                 *\n*             GPR 0   = Length of Target Field                        *\n*             GPR 1   = A(Target field)                               *\n*                                                                     *\n*   On Exit,  N/A                                                     *\n*                                                                     *\n*   Notes: This routine should only be used for output fields with    *\n*          lengths if 4, 5, or 6.                                     *\n*          Output fields of length = 4 are assumed to be percents.    *\n*          Values destined for output fields with lengths of 5 or 6   *\n*          will be scaled, if necessary. All scaled values will have  *\n*          a single decimal point.                                    *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         STM   R14,R12,12(R13)          Save callers registers\n         LDR   R6,R0                    Save FP R0\n\n         LA    R15,0                    Clear scale indicator\n         CHI   R0,5                     Check output length\n         JL    H03040                   a %, skip scaling\n         JH    H03010                   6-char field, skip\n         LD    R2,=DBL8'10000'          Max value + 1\n         J     H03020\nH03010   DS    0H\n         LD    R2,=DBL8'100000'         Max value + 1\nH03020   DS    0H\n         CDBR  R0,R2                    Do we have to scale?\n         JNH   H03040                   No, skip\n         LTR   R15,R15                  Have we scaled already?\n         JNZ   H03030                   Yes, skip\n         DDB   R2,=DBL8'100'            No, max val +1\nH03030   DS    0H\n         DDB   R0,=DBL8'1000'           Divide by 1000\n         AHI   R15,1                    Bump scaling factor\n         J     H03020                   and check again\n\nH03040   DS    0H\n         LTR   R15,R15                  Did we have to scale it?\n         JZ    H03050                   No, skip\n         MVC   @H_MaskArea,=X'40202021204B2040' Yes, move mask\n         LA    R15,H_Scale-1(R15)       Get scaling factor\n         MVC   @H_Scale,0(R15)          Save it\n         MDB   R0,=DBL8'10'             Add a decimal point\n         J     H03070                   and skip\nH03050   DS    0H\n         CHI   R0,5                     Is this a percent?\n         JNL   H03060                   No, skip\n         MVC   @H_MaskArea,=X'4040202021204B20' Yes, move mask\n         CDB   R0,=DBL8'999.4'          Will we round up to 100%?\n         JNH   H03070                   No, OK\n         LD    R0,=DBL8'999.4'          Yes, set to 99.9%\n         J     H03070                   and skip\nH03060   DS    0H\n         MVC   @H_MaskArea,=X'404020206B202120' Move mask\nH03070   DS    0H\n         CFDBR R15,B'0100',R0           Convert and round\n         CVD   R15,@H_DBLWD             Pack it\n         ED    @H_MaskArea,@H_DBLWD+5   Edit in the number\n         CLI   @H_MaskArea+L'@H_MaskArea-1,C' ' Did we scale?\n         JNE   H03080                   No, skip\n         MVC   @H_MaskArea+L'@H_MaskArea-1(1),@H_Scale Yes, move factor\nH03080   DS    0H\n         LA    R15,@H_MaskArea+L'@H_MaskArea Point to\n         SR    R15,R0                     start of our data\n         MVC   @H_MaskArea,0(R15)       Left align in mask area\n         LR    R15,R0                   Get length again\n         AHI   R15,-1                   EX length\n         L     R1,24(0,R13)             A(Target field)\n         EX    R15,H_MVC1               Move to output field\nH03090   DS    0H\n\n         LM    R14,R12,12(R13)          Restore registers\n         LDR   R0,R6                    Restore FP R0\n\n         BR    R14                      and exit\n\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n\n\n\nH06000   DS    0H\n\n*---------------------------------------------------------------------*\n*     Our timer has expired - verify that we are in the middle of     *\n*    LSPACE by checking that the PRB at the end of the RB chain has   *\n*    issued an SVC 78 (LSPACE).                                       *\n*     If SVC78 is active, or has not yet been issued,                 *\n*        Establish an ESTAE with PURGE=HALT                           *\n*        ABEND X'0522'                                                *\n*     Else                                                            *\n*        disappear quietly (we have popped after LSPACE completed, but*\n*                           before the STIMERM was cancelled)         *\n*---------------------------------------------------------------------*\n         PUSH  USING                    Save our USING environment\n         DROP  ,\n\n         USING *,R15                    Assign temp base\n         STM   14,12,12(13)             Save callers registers\n         LR    R11,R15                  Load permanent base reg\n         DROP  R15                      Free up temp base\n         USING H06000,R11               Assign permanent base\n         L     R1,4(0,R1)               Get A(Parms passed)\n         L     R10,0(0,R1)              Get A(Dynamic storage)\n         USING @H_Dynam,R10             Assign a base\n\n*        STM   R14,R1,@H6_Debug_Save    Save our registers\n*        WTO   '&PGMNAME - STIMERM Exit popping'\n*        LM    R14,R1,@H6_Debug_Save    Restore our registers\n\n*---------------------------------------------------------------------*\n*   We will be checking the RB chain, to verify that we are, indeed,  *\n*  in LSPACE. If the ground should shift under us while we are doing  *\n*  this, we may get an S0C4, or some such, and the CVAF ESTAE (with   *\n*  PURGE=NONE) will be scheduled, and we will hang. We therefore      *\n*  establish our PURGE=HALT ESTAE here.                               *\n*---------------------------------------------------------------------*\n*        STM   R14,R1,@H6_Debug_Save    Save our registers\n*        WTO   '&PGMNAME - STIMERM Exit - establishing ESTAE'\n*        LM    R14,R1,@H6_Debug_Save    Restore our registers\n\n         MVC   @H6_ESTAE,H6_ESTAE       Move L-Form\n         ESTAEX H06800,                 Establish ESTAE Exit           +\n               CT,                       create it                     +\n               PURGE=HALT,               terminating IO                +\n               MF=(E,@H6_ESTAE)          keeping ourselves reentrant\n\n*---------------------------------------------------------------------*\n*   Chase down the RB chain for the last RB ...                       *\n*---------------------------------------------------------------------*\n         L     R14,PSATNEW-PSA(0)       Get A(our TCB)\n         SLL   R14,8                    Clean\n         SRL   R14,8                      it\n         L     R15,TCBRBP-TCB(R14)      A(RB)\nH06010   DS    0H\n         L     R0,RBLINK-RBBASIC(R15)   A(Previous RB)\n         SLL   R0,8                     Clean\n         SRL   R0,8                       it\n         CR    R0,R14                   Last RB (RBLINK = A(TCB))?\n         JE    H06020                   Yes, skip\n         LR    R15,R0                   No, point to previous RB\n         J     H06010                   and keep trying\nH06020   DS    0H\n\n*---------------------------------------------------------------------*\n*   ... and see if it is running SVC 78 (LSPACE)                      *\n*---------------------------------------------------------------------*\n         AHI   R15,-(RBPRFXND-RBPREFIX)   Back up to RB prefix\n         CLC   =X'004E',RBINTCOD-RBPREFIX(R15) SVC 78?\n         JE    H06030                   Yes, try to terminate\n\n*        STM   R14,R1,@H6_Debug_Save    Save our registers\n*        WTO   '&PGMNAME - STIMERM Exit - not in LSPACE'\n*        LM    R14,R1,@H6_Debug_Save    Restore our registers\n\n         ESTAEX 0                       No, delete our ESTAE\n\n         RETURN (14,12),,RC=0           and return\n\nH06030   DS    0H\n\n*---------------------------------------------------------------------*\n*   LSPACE is active, and, we assume, hung up. We have already set    *\n*  up our ESTAE with PURGE=HALT, which, on an ABEND, will get control *\n*  first, after the I/O is HALTed. This ESTAE merely percolates, so   *\n*  that the CVAF and LSPACE ESTAEs can do their tricks, and we will   *\n*  eventually end up in our ESTAE, which continues processing as if   *\n*  LSPACE had failed.                                                 *\n*---------------------------------------------------------------------*\n*        STM   R14,R1,@H6_Debug_Save    Save our registers\n*        WTO   '&PGMNAME - STIMERM Exit - ABENDing U0522'\n*        LM    R14,R1,@H6_Debug_Save    Restore our registers\n\n         ICM   R9,B'1111',@H_Current_VolTbl_Ent A(VolTbl Entry)\n         JZ    H06040                   None, skup\n         OI    VolTbl_Ent_U522-VolTbl_Ent(R9),L'VolTbl_Ent_U522\nH06040   DS    0H\n         ABEND X'0522'                  and abend with U522 (get it?)\n\nH06800   DS    0H\n\n*---------------------------------------------------------------------*\n*   This is the Exit for the ESTAE established in the STIMERM exit.   *\n*  This exit does nothing, merely returning to RTM with percolate.    *\n*  It is only here because we need the first ESTAE on the queue to    *\n*  have PURGE=HALT, so the I/O to the RESERVEd volume can be          *\n*  terminated.                                                        *\n*---------------------------------------------------------------------*\n         LA    R15,0                    Percolate\n         BSM   0,R14                     on return\n\nH6_ESTAE ESTAEX 1,                      Establish ESTAE Exit           +\n               CT,                       create it                     +\n               PURGE=HALT,               PURGEing I/O                  +\n               MF=L                      keeping ourselves reentrant\nH6_ESTAE_Length EQU *-H6_ESTAE\n\n         DROP  R11,R10                  Free up temp bases\n\n         POP   USING                    Restore USING environment\n\n*********************   Start of the ESTAE   **************************\n*                                                                     *\n*                                                                     *\n         SPACE ,\nH07000   DS    0H\n         PUSH  USING                    Save the USING environment\n         DROP  ,                        Drop all current USINGs\n         SPACE ,\n*---------------------------------------------------------------------*\n*   This is the ESTAE routine. All this does is:                      *\n*    Format an abend message                                          *\n*    Invoke the retry routine                                         *\n*                                                                     *\n*   Note that we run with our own set of USINGs here.                 *\n*---------------------------------------------------------------------*\n         USING *,R15                    Assign temporary base\n         CHI   R0,12                    Is there an SDWA?\n         JE    H07010                   No, skip\n\n*---------------------------------------------------------------------*\n*   We have an SDWA, so load the appropriate registers:               *\n*      R11 --> SDWA                                                   *\n*      R1  =   Abend Code                                             *\n*      R3  --> Parmarea                                               *\n*---------------------------------------------------------------------*\n         STM   R14,R11,12(R13)          Yes, save our registers\n         LR    R11,R1                   Point to the SDWA\n         L     R1,SDWAABCC-SDWA(R11)    Get the Abend code\n         L     R3,SDWAPARM-SDWA(R11)    Point to our parm address\n         L     R3,0(0,R3)               Point to our parms\n         J     H07020                   and skip\nH07010   DS    0H\n\n*---------------------------------------------------------------------*\n*   We don't have an SDWA, so clear R11 (the SDWA address)            *\n*---------------------------------------------------------------------*\n         LA    R11,0                    Clear A(SDWA)\n\nH07020   DS    0H\n*---------------------------------------------------------------------*\n*   Load up the base for our storage, and tell the assembler.         *\n*   At this point,                                                    *\n*    R1  contains the ABEND code                                      *\n*    R3  contains the address of @H_Dynam                             *\n*    R11 contains the address of the SDWA, or 0                       *\n*---------------------------------------------------------------------*\n         LR    R12,R15                  Load a base register\n         DROP  R15                      Free up temp base\n         USING H07000,R12               Tell the assembler about R11\n         USING @H_Dynam,R3              Assign a base for our parms\n\n*---------------------------------------------------------------------*\n*   Format our ABEND message                                          *\n*---------------------------------------------------------------------*\n         ST    R1,@H_DBLWD              Save completion code\n         ICM   R9,B'1111',@H_Current_VolTbl_Ent A(VolTbl_Ent)\n         JZ    H07050                   None, skip\n         USING VolTbl_Ent,R9            Assign a base\n         OI    VolTbl_Ent_LSPACE_Fail,L'VolTbl_Ent_LSPACE_Fail No data\n         CLC   =X'0522',@H_DBLWD+2      Is this U522 (STIMER pop)?\n         J     H07050                   Yes, exit\n\n         MVC   VolTbl_Ent_ErrMsg,=CL(L'VolTbl_Ent_ErrMsg)'**SubTask ABE+\n               ND xxxx'\n         MVI   VolTbl_Ent_ErrMsg+16,C'S' Assume system abend\n         L     R15,@H_DBLWD             Get ABEND code\n         SLL   R15,8                    Clear high-order byte and\n         SRL   R15,20                    User Abend code\n         LTR   R15,R15                  Is it a system Abend?\n         JNZ   H07040                   Yes, skip\n         MVI   VolTbl_Ent_ErrMsg+16,C'U' No, User abend\n         L     R15,@H_DBLWD             Get Abend code\n         SLL   R15,20                   Clear System\n         SRL   R15,20                     Abend code\nH07040   DS    0H\n         SLL   R15,4                    Make room for 'sign'\n         STH   R15,@H_DBLWD+6           Save it\n         OI    @H_DBLWD+7,X'0F'         Make it packed\n         UNPK  VolTbl_Ent_ErrMsg+17(3),@H_DBLWD+6(2) Unpack abend code\n         LA    R15,H_TrTbl              Point to translate table\n         S     R15,=FL4'240'            Adjust pointer\n         TR    VolTbl_Ent_ErrMsg+17(3),0(R15) Make it readable\n         DROP  R9                       Free up base\n\nH07050   DS    0H\n*---------------------------------------------------------------------*\n*   We will be retrying, so we will no longer have an ESTAE. Turn off *\n*  our flag, so that the retry routine will re-establish it ...       *\n*---------------------------------------------------------------------*\n         NI    @H_ESTAE_Issued,X'FF'-L'@H_ESTAE_Issued No ESTAE now\n\n*---------------------------------------------------------------------*\n*   ... and retry, either with an SDWA ...                            *\n*---------------------------------------------------------------------*\n         LTR   R11,R11                  Is there an SDWA?\n         JZ    H07060                   No, skip SDWA retry\n         SPACE ,\n         L     R4,@H_ESTAE_Retry        Yes, A(Retry routine)\n         LA    R5,@H_ESTAE_RMask        A(Register mask)\n         SETRP WKAREA=(11),             Set retry parms using this SDWA+\n               RC=4,                     Retry                         +\n               RETADDR=(4),              using this retry routine      +\n               RETREGS=YES,              and our registers             +\n               RUB=(5),                  which live here               +\n               FRESDWA=YES,              and get rid of the SDWA       +\n               REGS=(14,12)              Return to RTM\n\nH07060   DS    0H\n*---------------------------------------------------------------------*\n*   ... or without                                                    *\n*---------------------------------------------------------------------*\n         L     R0,@H_ESTAE_Retry         A(Retry routine)\n         LM    R1,R13,@H_ESTAE_Regs+4    Restore regs\n         LA    R15,4                     Retry\n         BR    R14                       go do it\n\n\n         DROP  ,                        Drop everything\n         POP   USING                    Restore USING environment\n\n*                                                                     *\n*                                                                     *\n**********************   End of the ESTAE   ***************************\n\n\nH90010   DS    0H\n*---------------------------------------------------------------------*\n*     We have finished doing our work                                 *\n*     First, delete our ESTAE if required ...                         *\n*---------------------------------------------------------------------*\n         TM    @H_ESTAE_Issued,L'@H_ESTAE_Issued ESTAE?\n         JZ    H90020                   No, skip\n         ESTAEX 0                       Yes, delete it\n         NI    @H_ESTAE_Issued,X'FF'-L'@H_ESTAE_Issued No ESTAE now\n\nH90020   DS    0H\n*---------------------------------------------------------------------*\n*    ... free up the 24-bit stack, if appropriate ...                 *\n*---------------------------------------------------------------------*\n         ICM   R1,B'1111',@H_24Bit_Stack_Ptr A(24-bit storage)\n         JZ    H90030                   None, skip\n         SSCSTACK TERM,                 Get rid of the stack           +\n               STACK=(1)                 starting here\n\nH90030   DS    0H\n*---------------------------------------------------------------------*\n*    ... then our locat 31-bit storage                                *\n*---------------------------------------------------------------------*\n         LA    R1,@H_Dynam              A(Local storage)\n         L     R3,@H_31Bit_Stack_Ptr    A(31-bit Stack)\n\n         SSCSTACK POP,                  Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=(R3)                on this stack\n\n*-------------------------------------------------------------------*\n*    ... and the stack itself ...                                   *\n*-------------------------------------------------------------------*\n         SSCSTACK TERM,                 Free the stack                 +\n               STACK=(R3)                starting here\n\n*---------------------------------------------------------------------*\n*    ... and exit.                                                    *\n*---------------------------------------------------------------------*\n         LA    R15,0                    Clear return code\n         PR    ,                        and return to caller\n\n\nH_Literals  DS  0H\n\nH_MVC    MVC   0(0,R1),3(R15) Move LSPACE error msg\n\n         PUSH  PRINT\n         PRINT NOGEN\n\nH_LSPACE LSPACE MF=L\nH_LSPACE_Length EQU *-H_LSPACE\n\nH_ESTAE  ESTAEX 1,                      Establish ESTAE Exit           +\n               CT,                       create it                     +\n               PARAM=0,                  passing this parm             +\n               MF=L                      keeping ourselves reentrant\nH_ESTAE_Length EQU *-H_ESTAE\n\nH_STIMERM_Set STIMERM SET,              Set a timer                    +\n               MF=L                      keep ourselves reentrant\nH_STIMERM_Set_Length EQU   *-H_STIMERM_Set\n\nH_STIMERM_Cancel STIMERM CANCEL,        Cancel our timer               +\n               MF=L                      keep ourselves reentrant\nH_STIMERM_Cancel_Length EQU   *-H_STIMERM_Cancel\n\nH_TIME   TIME  LINKAGE=SYSTEM,          Get the time                   +\n               MF=L                      keep ourselves reentrant\nH_TIME_Length  EQU *-H_TIME\n\nH_SMS_Anomaly_Msg     DC C'* indicates SMS status in UCB and VTOC are i+\n               nconsistent'\n         POP   PRINT\n\nH_TrTbl DC          C'0123456789ABCDEF'\n\nH_MVC1   MVC   0(0,R1),@H_MaskArea      Move readable results\n\nH_Scale  EQU   *\n         DC    C'K'             Kilo (/10**3)\n         DC    C'M'             Mega (/10**6)\n         DC    C'G'             Giga (/10**9)\n         DC    C'T'             Tera (/10**12)\n         DC    C'P'             Peta (/10**15)\n         DC    C'E'             Eta  (/10**18)\n         DC    C'Z'             Zetta (/10**21)\n         DC    C'Y'             Yotta (/10**24)\n         DC    C'?'             Hope we never get here\n\n         LTORG\n\nH_SubTask_Hdgs        EQU   *\nH_SubTask_Hdg1        DC    C' Subtask Statistics:'\nH_SubTask_Hdg2        DC    C'  SubTask    Volume         CPU       --L+\n               SPACE OK--       -LSPACE Bad--'\nH_SubTask_Hdg3        DC    C'   Number     Count        Time        Co+\n               unt   Wait        Count   Wait'\n\nH_SubTask_Hdg_Lens    DC    AL2(L'H_SubTask_Hdg1)\n                      DC    AL2(L'H_SubTask_Hdg2)\n                      DC    AL2(L'H_SubTask_Hdg3)\nH_SubTask_Hdg_Count   EQU   (*-H_SubTask_Hdg_Lens)/2\n\n\nH_SubTask_Line        EQU   *\n                      DC    C'     '\nH_SubTask_Line_Nbr    DC    X'40202120'\n                      DC    C'   '\nH_SubTask_Line_TotVol DC    X'4020206B202120'\n                      DC    C'     '\nH_SubTask_Line_CPU    DC    X'4021204B202020'\n                      DC    C'      '\nH_SubTask_Line_Vol_OK DC    X'4020206B202120'\nH_SubTask_Line_Wait_OK DC   X'4021204B202020'\n                      DC    C'      '\nH_SubTask_Line_Vol_Bad DC   X'4020206B202120'\nH_SubTask_Line_Wait_Bad DC  X'4021204B202020'\nH_SubTask_Line_Len    EQU   *-H_SubTask_Line\n\nH_LSPACE_Msgs EQU *\n           DC    XL2'0407'\n           DC    AL1(L'H_Msg0407)\nH_Msg0407  DC    C'LSPACE-I/O TIMEOUT ERROR'\n           DC    XL2'0400'\n           DC    AL1(L'H_Msg0400)\nH_Msg0400  DC    C'LSPACE-PERMANENT I/O ERROR'\n           DC    XL2'0800'\n           DC    AL1(L'H_Msg0800)\nH_Msg0800  DC    C'LSPACE-NON_STANDARD OS VOLUME'\n           DC    XL2'0C01'\n           DC    AL1(L'H_Msg0C01)\nH_Msg0C01  DC    C'LSPACE-UCBVTOC IS ZERO'\n           DC    XL2'0C02'\n           DC    AL1(L'H_Msg0C02)\nH_Msg0C02  DC    C'LSPACE-UCB NOT READY'\n           DC    XL2'1485'\n           DC    AL1(L'H_Msg1485)\nH_Msg1485  DC    C'&PGMNAME - LSPACE ESTAE invoked'\n           DC    XL2'0000'\n           DC    AL1(L'H_Msg0000)\nH_Msg0000  DC    C'&PGMNAME - Unknown LSPACE error'\n\nH_MsgU522A DC    C'&PGMNAME - MaxLWait ('\nH_MsgU522B DC    C' secs) exceeded.'\n\nH_Literals_End  DS  0H\n\n@H_Dynam                  DSECT Dynamic storage for H00010\n                          DS    18F     O/S Save area\n@H_31Bit_Stack_Ptr        DS    AL4     A(Local 31-bit Stack)\n@H_24Bit_Stack_Ptr        DS    AL4     A(Local 24-bit Stack)\n@H_VolTbl_Ptr             DS    AL4     A(VolTbl)\n@H_LSPACE_Avg_Ptr         DS    AL4     A(Avg LSPACE Wait microsecs)\n@H_STIMERM_Adj_Ptr        DS    AL4     A(STIMERM Adjustment Factor)\n@H_Totals_Line_Ptr        DS    AL4     A(Totals Line)\n@H_Stats_Line_Ptr         DS    AL4     A(1st SubTask Title line)\n@H_SMS_Anomaly_Ptr        DS    AL4     A(SMS Anomaly Line)\n@H_MaxLWait               DS    HL2     Max LSPACE Wait time\n\n@H_Current_VolTbl_Ent     DS    AL4     A(Current VolTbl_Ent)\n\n@H_UCBTBYT4               DS    XL(L'UCBTBYT4)  UCB Type for TRKCALC\n@H_BytesPerTrack          DS    FL4     Bytes/trk, from TRKCALC\n\n@H_STIMERM_ID             DS    AL4     STIMERM Id\n@H_STIMERM_Exit_Parms_Ptr DS    AL4     A(Parms for STIMERM Exit)\n@H_STIMERM_Exit_Parms     DS    2AL4    Parms for STIMERM Exit\n                          DS    0D      Alignment\n@H_LSPACE_Wait_Max        DS    FL4     Max LSPACE Wait Time (sec)\n@H_LSPACE_Start           DS    DL8     TOD of LSPACE start\n                          ORG   @H_LSPACE_Start\n@H_LSPACE_Wait            DS    DL8     Actual LSPACE Wait time (usec)\n                          ORG   ,\n\n@H_DBLWD                  DS    D          Doubleword work area\n@H_Total_VTOCTrk          DS    DBL8\n@H_Total_DSCBs            DS    DBL8\n@H_Total_FreeDSCBs        DS    DBL8\n@H_Total_VolSize          DS    DBL8\n@H_Total_Extents          DS    DBL8\n@H_Total_FreeTracks       DS    DBL8\n@H_Total_FreeBytes        DS    DBL8\n@H_Total_FreeCyls         DS    DBL8\n@H_Total_FragIndex        DS    DBL8\n@H_Largest_FreeTracks     DS    DBL8\n@H_Largest_FreeCyls       DS    DBL8\n@H_WaitTime_Total         DS    D       Total Wait Time (in usec)\n@H_Total_Vols_Proc        DS    FL4     Nbr volumes processed\n@H_Total_Vols_OK          DS    FL4     Nbr volumes processed OK\n@H_Total_LSPACE_Wait_OK   DS    DL8     Total good LSPACE Wait (usec)\n@H_Total_LSPACE_Wait_Bad  DS    DL8     Total bad LSPACE Wait (usec)\n                          DS    0F      Alignment\n@H_ESTAE_RMask            DS    HL2     ESTAE Register Mask\n@H_ESTAE_Regs             DS    16FL4   Registers for ESTAE Retry\n@H_ESTAE_Retry            DS    AL4     A(ESTAE Retry routine)\n                          DS    X       Flag Byte\n@H_ESTAE_Issued           EQU   *-1,X'80' 1... .... ESTAE established\n@H_VolTbl_Complete        EQU   *-1,X'40' .1.. .... All VolTbl_Ents OK\n@H_OW48527                EQU   *-1,X'20' ..1. .... APAR OW48527 on\n                          ORG   ,\n\n                          DS    0F      Alignment\n@H_LSPACE                 DS    CL(H_LSPACE_Length) LSPACE Macro\n\n@H_VolSize                DS    DBL8    Volume Bytes (Used in %Free)\n@H_TotDSCB                DS    DBL8    Volume Total DSCBs\n@H_MaskArea               DS    CL8     ED Mask area\n@H_Scale                  DS    C       Scaling factor\n\n@H_Macro                  DS    0F      Alignment\n@H_ESTAE                  DS    CL(H_ESTAE_Length)  ESTAE Macro area\n                          ORG   @H_Macro\n@H6_ESTAE                 DS    CL(H6_ESTAE_Length) STIMERM Exit ESTAE\n@H6_Debug_Save            DS    4FL4    Save registers around WTOs\n                          ORG   @H_Macro\n@H_STIMERM_Set            DS    CL(H_STIMERM_Set_Length)  STIMERM\n                          ORG   @H_Macro\n@H_STIMERM_Can            DS    CL(H_STIMERM_Cancel_Length)  STIMERM\n                          ORG   @H_Macro\n@H_TIME                   DS    CL(H_TIME_Length) TIME Macro area\n                          DS    0D\n@H_TIME_Area              DS    XL16    Data returned by TIME\n                          ORG   @H_Macro\n@H_TRKCALC                TRKCALC MF=L  Track balance calcs\n                          ORG   ,\n\n@H_Parms                  DS    0F      Parms for called rtns\n@H_Parms_Std              DS    3AL4     Standard 3 parms\n@H_Parms_Extra            EQU   *        Extra parms\n                          ORG   ,\n\n                          DS    0D      Alignment\n@H_Dynam_Length           EQU   *-@H_Dynam Length of Sub-Task Dynamic\n\n&PGMNAME CSECT\n\n         DROP  ,\n\n         POP   USING                    Restore USING environment\n         TITLE 'I00010: Sort Table'\n\n         PUSH  USING\n\nI00010   DS    0H\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Subroutine: I00010                                                 *\n*                                                                     *\n*  Abstract  : Sort data in VolTbl depending on the parameters        *\n*              passed.                                                *\n*                                                                     *\n*  Inputs    : R1 : ---> A(@_Dynam)                                   *\n*                        A(31-bit Stack Pointer)                      *\n*                        A(24-bit Stack Pointer)                      *\n*                        A(8-byte name of sort field)                 *\n*                        A(1-byte containing sort direction (A/D))    *\n*  Outputs   : R15: 0                                                 *\n*                                                                     *\n*  Notes     : N/A                                                    *\n*                                                                     *\n*  History:    1990/06/11 SDDA030 - New                               *\n*              1998/09/22 SDDA030 - V2.1                              *\n*                                 - Excluded Stats lines from being   *\n*                                   sorted                            *\n*              1999/05/27 SDDA030 - V2.6                              *\n*                                 - Used LIFO Stack for our dynamic   *\n*                                   areas.                            *\n*              2000/01/19 SDDA030 - V2.11                             *\n*                                 - Received parms as pointers.       *\n*                                 - Able to sort Ascending or Descend-*\n*                                   ing.                              *\n*              2000/05/23 SDDA030 - V2.12                             *\n*                                 - Moved table of offsets from F00010*\n*                                   to here.                          *\n*              2002/03/11 SDDA030 - V2.17                             *\n*                                 - Added FREEB to table of offsets.  *\n*                                 - Pointed numeric fields to the     *\n*                                   appropriate sort fields in VolTbl.*\n*                                 - Removed sort by column nbr.       *\n*              2003/10/07 SDDA030 - V2.21                             *\n*                                 - Added VOLSIZE to table of offsets.*\n*              2006/04/21 SDDA030 - V2.24                             *\n*                                 - Used standardised calling sequence*\n*                                 - Fixed bug causing unending WAIT   *\n*                                   when STATS and SORT specified     *\n*                                 - WAIT for all detail lines to be   *\n*                                   populated before sorting (doh!)   *\n*              ____/__/__ _______                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         STM   R14,R12,12(R13)          Save callers registers\n         LARL  R11,I_Literals           Point to our literals\n         USING (I_Literals,I_Literals_End),R11 Tell the assembler\n\n         L     R12,0(0,R1)              A(@_Dynam)\n         USING @_Dynam,R12              Tell the assembler\n\n*-------------------------------------------------------------------*\n*    Get an area on the stack for our local storage                 *\n*-------------------------------------------------------------------*\n         L     R2,4(0,R1)               A(31-bit stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         SSCSTACK PUSH,                 Get stack area                 +\n               LEN=@I_Dynam_Length,      this long                     +\n               STACK=(R2)                using this stack\n\n         LR    R3,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LHI   R1,@I_Dynam_Length        Its length\n         LA    R14,0                    Clear source address\n         LA    R15,0                     and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R3                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*-------------------------------------------------------------------*\n         ST    R13,4(0,R1)              Chain\n         ST    R1,8(0,R13)               saveareas\n         LR    R13,R1                   Load dynam base\n         USING @I_Dynam,R13             Assign a base\n         L     R15,@I_Dynam+4           Get A(HSA)\n         LM    R0,R3,20(R15)            Restore callers registers\n\n         L     R15,4(0,R1)              A(31-bit Stack Pointer)\n         ST    R15,@I_31Bit_Stack_Ptr_Ptr Save it\n         L     R15,8(0,R1)              A(24-bit Stack Pointer)\n         ST    R15,@I_24Bit_Stack_Ptr_Ptr Save it\n\n\n         ICM   R9,B'1111',@_VolTbl_Ptr  A(Volume table)\n         JZ    I00100                   None, don't sort it\n         L     R10,VolTbl_Hdr_Count-VolTbl_Hdr(R9) Get nbr entries\n         CHI   R10,1                    More than 1\n         JNH   I00100                   No, skip sort\n\n         L     R14,12(0,R1)             Get A(Name of sort field)\n         LA    R15,I_TBLOFF             and A(Table of offsets)\nI00020   DS    0H\n         CLI   0(R15),C' '              End of table?\n         JE    I80010                   Yes, error (sort fld not found)\n         CLC   0(8,R14),0(R15)          Name, is it ours?\n         JE    I00030                   Yes, skip\n\n         AHI   R15,12                   No, point to next entry\n         J     I00020                   and try again\nI00030   DS    0H\n         LH    R14,8(0,R15)             Offset of sort field\n         LH    R15,10(0,R15)            Length of sort field\n\n         L     R1,@I_Dynam+4            Get A(HSA)\n         L     R1,24(0,R1)              Get original R1\n         L     R1,16(0,R1)              A(Sort direction)\n         CLI   0(R1),C'D'               Descending sort?\n         JE    I00040                   Yes, skip\n         LHI   R3,13                    No, use BNH for ascending sort\n         J     I00050                   and skip\nI00040   DS    0H\n         LHI   R3,11                    Use BNL for descending sort\nI00050   DS    0H\n         SLL   R3,4                     Put mask in high nibble\n\n         TM    VolTbl_Hdr_ECB-VolTbl_Hdr(R9),X'40' All details done?\n         JO    I00050C                  Yes, skip\n         WAIT  ECB=VolTbl_Hdr_ECB-VolTbl_Hdr(R9) No, wait for it\nI00050C  DS    0H\n\n         AHI   R9,VolTbl_Ent-VolTbl     Point to first entry\n         AHI   R10,-1                   Adjust Loop count\nI00060   DS    0H\n         TM    VolTbl_Ent_Detail_Line-VolTbl_Ent(R9),L'VolTbl_Ent_Detai+\n               l_Line\n         JNO   I00060C                  No, skip it\n         TM    VolTbl_Ent_SMS_Line-VolTbl_Ent(R9),L'VolTbl_Ent_SMS_Line\n         JNO   I00070                   True Detail line, skip\nI00060C  DS    0H\n         AHI   R9,VolTbl_Ent_Len        No, A(Next entry)\n         BRCT  R10,I00060               and check again\n         J     I00100                   Nothing, skip sort\n\nI00070   DS    0H\n         LR    R4,R9                    Get A(entry)\n         LR    R5,R10                   Get inner loop count\n         LA    R6,VolTbl_Ent_Len(0,R4)  A(Next entry)\nI00080   DS    0H\n         TM    VolTbl_Ent_Detail_Line-VolTbl_Ent(R6),L'VolTbl_Ent_Detai+\n               l_Line\n         JNO   I00090                   Skip non-detail line\n         TM    VolTbl_Ent_SMS_Line-VolTbl_Ent(R6),L'VolTbl_Ent_SMS_Line\n         JO    I00090                   Skip SMS Anomaly msg\n\n         LA    R7,0(R4,R14)             Point to\n         LA    R8,0(R6,R14)              sort fields\n         EX    R15,I0EX1                Compare entries\n         EX    R3,I0EX2                 Branch if in sequence\n\n         STM   R14,R1,@I_TempSave       Save MVCL registers\n         LA    R0,@I_WK1                A(Temporary area)\n         LHI   R1,L'@I_WK1              Its length\n         LR    R14,R4                   A(Entry out of sequence)\n         LHI   R15,VolTbl_Ent_Len       Its length\n         MVCL  R0,R14                   Save entry\n         LR    R0,R4                    A(Entry to be switched)\n         LHI   R1,VolTbl_Ent_Len        Its length\n         LR    R14,R6                   A(Entry out of sequence)\n         LHI   R15,VolTbl_Ent_Len       Its length\n         MVCL  R0,R14                   Save entry\n         LR    R0,R6                    A(Entry to be switched)\n         LHI   R1,VolTbl_Ent_Len        Its length\n         LA    R14,@I_WK1               A(Temporary area)\n         LHI   R15,L'@I_WK1             Its length\n         MVCL  R0,R14                   Save entry\n         LM    R14,R1,@I_TempSave       Restore MVCL registers\n\nI00090   DS    0H\n         AHI   R6,VolTbl_Ent_Len        A(next entry)\n         BRCT  R5,I00080                Sort all entries\n         AHI   R9,VolTbl_Ent_Len        Reset start entry nbr\n         BRCT  R10,I00060                And do it all again\n\nI00100   DS    0H\n         LA    R15,0                    Clear return code\n         J     I90010                   and exit\n\nI80010   DS    0H\n*-------------------------------------------------------------------*\n*    Sort field not found                                           *\n*-------------------------------------------------------------------*\n         LA    R15,4                    Sort failed\n         J     I90010                   and exit\n\nI90010   DS    0H\n*-------------------------------------------------------------------*\n*    Free up our local storage ...                                  *\n*-------------------------------------------------------------------*\n         LR    R3,R15                   Save return code\n\n         LA    R1,@I_Dynam              A(Local storage)\n         L     R2,@I_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         L     R13,4(0,R13)             Rescue A(HSA)\n\n         SSCSTACK POP,                  Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=(R2)                on this stack\n\n         LR    R15,R3                   Restore return code\n\n*-------------------------------------------------------------------*\n*    ... and return to caller                                       *\n*-------------------------------------------------------------------*\n         L     R14,12(0,R13)            Restore return address\n         LM    R0,R12,20(R13)           Restore other registers\n         BSM   0,R14                    and return\n\nI_Literals  DS  0H\n\nI0EX1    CLC   0(0,R7),0(R8)            Compare entries\nI0EX2    JNOP  I00090                   Set to BNH/BNL for A/D sort\n\n\n         LTORG\n\nI_TBLOFF EQU   *\n         DC    CL8'VOL'\n         DC    AL2(VolTbl_Ent_Volser-VolTbl_Ent) Start of VOL\n         DC    AL2(L'VolTbl_Ent_Volser)         Len of VOL\n\n         DC    CL8'UCB'\n         DC    AL2(VolTbl_Ent_UCBCopy+UCBCHAN-UCBOB-VolTbl_Ent) UCB\n         DC    AL2(L'UCBCHAN)                   Length of UCB\n\n         DC    CL8'DEVT'\n         DC    AL2(VolTbl_Ent_DevType-VolTbl_Ent) Start of Device Type\n         DC    AL2(L'VolTbl_Ent_DevType)        Len of Device type\n\n         DC    CL8'ATTR'\n         DC    AL2(VolTbl_Ent_Attrib-VolTbl_Ent) Start of Mnt Attr\n         DC    AL2(L'VolTbl_Ent_Attrib)         Len of Mnt Attr\n\n         DC    CL8'FREET'\n         DC    AL2(VolTbl_Ent_Sort_FreeTrk-VolTbl_Ent) Free Trk\n         DC    AL2(L'VolTbl_Ent_Sort_FreeTrk)   Len of Free Trks\n\n         DC    CL8'FREEC'\n         DC    AL2(VolTbl_Ent_Sort_FreeCyl-VolTbl_Ent) Free Cyl\n         DC    AL2(L'VolTbl_Ent_Sort_FreeCyl)   Len of Free Cyl\n\n         DC    CL8'FREEP'\n         DC    AL2(VolTbl_Ent_FreePct-VolTbl_Ent) Free % of Vol\n         DC    AL2(L'VolTbl_Ent_FreePct)        Len of Free % of Vol\n\n         DC    CL8'FREEB'\n         DC    AL2(VolTbl_Ent_Sort_FreeBytes-VolTbl_Ent) Free Bytes\n         DC    AL2(L'VolTbl_Ent_Sort_FreeBytes)   Len of Free Bytes\n\n         DC    CL8'FREEE'\n         DC    AL2(VolTbl_Ent_Sort_FreeExt-VolTbl_Ent) Nbr Extents\n         DC    AL2(L'VolTbl_Ent_Sort_FreeExt)   Len of nbr Extents\n\n         DC    CL8'LARGET'\n         DC    AL2(VolTbl_Ent_Sort_LargTrk-VolTbl_Ent) Larg Trk\n         DC    AL2(L'VolTbl_Ent_Sort_LargTrk)   Len of Larg Trks\n\n         DC    CL8'LARGEC'\n         DC    AL2(VolTbl_Ent_Sort_LargCyl-VolTbl_Ent) Larg Cyl\n         DC    AL2(L'VolTbl_Ent_Sort_LargCyl)   Len of Larg Cyl\n\n         DC    CL8'VTRK'\n         DC    AL2(VolTbl_Ent_Sort_VTOCTrk-VolTbl_Ent) VTOC Trk\n         DC    AL2(L'VolTbl_Ent_Sort_VTOCTrk)   Len of VTOC Trks\n\n         DC    CL8'VFREED'\n         DC    AL2(VolTbl_Ent_Sort_FreeDSCB-VolTbl_Ent) Free DSCBs\n         DC    AL2(L'VolTbl_Ent_Sort_FreeDSCB)  Len of Free DSCBs\n\n         DC    CL8'VFREEP'\n         DC    AL2(VolTbl_Ent_VTOCFree-VolTbl_Ent) Start of Free %\n         DC    AL2(L'VolTbl_Ent_VTOCFree)       Len of Free %\n\n         DC    CL8'VIX'\n         DC    AL2(VolTbl_Ent_VTOCIX-VolTbl_Ent) Start of VTOC IX Stat\n         DC    AL2(L'VolTbl_Ent_VTOCIX)         Len of VTOC IS Stat\n\n         DC    CL8'FRAG'\n         DC    AL2(VolTbl_Ent_Frag_Indx-VolTbl_Ent) Frag Index\n         DC    AL2(L'VolTbl_Ent_Frag_Indx)      Len of Frag Index\n\n         DC    CL8'VOLSIZE'\n         DC    AL2(VolTbl_Ent_Sort_VolSize-VolTbl_Ent) Volume size\n         DC    AL2(L'VolTbl_Ent_Sort_VolSize)   Len of volume size\n\n         DC    CL8'STORGRP'\n         DC    AL2(VolTbl_Ent_SMS_StorGrp-VolTbl_Ent) Stor Group\n         DC    AL2(L'VolTbl_Ent_SMS_StorGrp)    Len of Stor Group\n\n         DC    CL8'SMSSTAT'\n         DC    AL2(VolTbl_Ent_SMS_Status-VolTbl_Ent) SMS Status\n         DC    AL2(L'VolTbl_Ent_SMS_Status)    Len of SMS Status\n\n         DC    CL8'CHPIDS'\n         DC    AL2(VolTbl_Ent_CHPIDs-VolTbl_Ent) Start of CHPIDs\n         DC    AL2(L'VolTbl_Ent_CHPIDs)         Len of CHPIDs\n\n         DC    CL8' '\n         DC    HL2'-1'                         End of table\n         DC    AL2(0)\n\nI_Literals_End  DS  0H\n\n\n@I_Dynam                  DSECT        Dynamic area for I00000\n                          DS    18F     O/S Style save area\n@I_31Bit_Stack_Ptr_Ptr    DS    AL4     A(31-bit Stack Ptr)\n@I_24Bit_Stack_Ptr_Ptr    DS    AL4     A(24-bit Stack Ptr)\n@I_TempSave               DS    4FL4    Temporary save area (for MVCLs)\n@I_WK1                    DS    CL(VolTbl_Ent_Len) Work area\n                          DS    0D         Alignment\n@I_Dynam_Length           EQU   *-@I_Dynam  Length of storage\n\n&PGMNAME CSECT\n\n         DROP  ,\n         POP   USING\n         TITLE 'J00010: EDIF/BRIF'\n\n         PUSH  USING\n\nJ00010   DS    0H\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Subroutine: J00010                                                 *\n*                                                                     *\n*  Abstract  : EDIF/BRIF invocation and associated service routines.  *\n*                                                                     *\n*  Inputs    : R1 : ---> A(@_Dynam)                                   *\n*                        A(31-bit Stack Pointer)                      *\n*                        A(24-bit Stack Pointer)                      *\n*  Outputs   : R15 = 0                                                *\n*                                                                     *\n*  Notes     : N/A                                                    *\n*                                                                     *\n*  History:    2001/02/26 SDDA030 - V2.14                             *\n*                                 - New                               *\n*              2002/02/12 SDDA030 - V2.16                             *\n*                                 - Added pop-up panel to BRIF when   *\n*                                   SORT command entered with no or   *\n*                                   invalid operands.                 *\n*              2002/06/11 SDDA030 - V2.18                             *\n*                                   WAIT for VolTbl_Ent to be populated\n*                                   before outputting                 *\n*              2004/10/15 SDDA030 - V2.22                             *\n*                                 - Resequenced labels                *\n*              2006/04/21 SDDA030 - V2.24                             *\n*                                 - Used standardised calling sequence*\n*              ____/__/__ _______                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         STM   R14,R12,12(R13)          Save callers registers\n         LARL  R11,J_Literals           Point to our literals\n         USING (J_Literals,J_Literals_End),R11 Tell the assembler\n\n         L     R12,0(0,R1)              A(@_Dynam)\n         USING @_Dynam,R12              Tell the assembler\n\n*-------------------------------------------------------------------*\n*    Get an area on the stack for our local storage                 *\n*-------------------------------------------------------------------*\n         L     R2,4(0,R1)               A(31-bit stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         SSCSTACK PUSH,                 Get stack area                 +\n               LEN=@J_Dynam_Length,      this long                     +\n               STACK=(R2)                using this stack\n\n         LR    R3,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LHI   R1,@J_Dynam_Length        Its length\n         LA    R14,0                    Clear source address\n         LA    R15,0                     and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R3                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*-------------------------------------------------------------------*\n         ST    R13,4(0,R1)              Chain\n         ST    R1,8(0,R13)               saveareas\n         LR    R13,R1                   Load dynam base\n         USING @J_Dynam,R13             Assign a base\n         L     R15,@J_Dynam+4           Get A(HSA)\n         LM    R0,R3,20(R15)            Restore callers registers\n\n         L     R15,4(0,R1)              A(31-bit Stack Pointer)\n         ST    R15,@J_31Bit_Stack_Ptr_Ptr Save it\n         L     R15,8(0,R1)              A(24-bit Stack Pointer)\n         ST    R15,@J_24Bit_Stack_Ptr_Ptr Save it\n\n*-------------------------------------------------------------------*\n*    Set up our record length for EDIF/BRIF                         *\n*-------------------------------------------------------------------*\n         LHI   R15,VolTbl_Ent_Display_Len Max len to display\n         ST    R15,@J_ISPF_LRECL        Save it\n\n*-------------------------------------------------------------------*\n*    Set up the parms to be passed to the EDIF/BRIF routines        *\n*-------------------------------------------------------------------*\n         LA    R15,@_Dynam              A(Dynamic storage)\n         ST    R15,@J_ISPF_Rtn_Parms    Save the address\n         L     R15,@J_31Bit_Stack_Ptr_Ptr A(31-bit Stack Ptr)\n         ST    R15,@J_ISPF_Rtn_Parms+4  Save the address\n         L     R15,@J_24Bit_Stack_Ptr_Ptr A(24-bit Stack Ptr)\n         ST    R15,@J_ISPF_Rtn_Parms+8  Save the address\n         LA    R15,@J_EDIF_Prev_Rec_Nbr A(EDIF Record Number field)\n         ST    R15,@J_ISPF_Rtn_Parms+12 Save the address\n         LA    R15,@J_ISPF_Rtn_Parms    A(Parms)\n         ST    R15,@J_ISPF_Rtn_Parms_Ptr Save the address\n\n*-------------------------------------------------------------------*\n*    Set up EDIF Parms ...                                          *\n*-------------------------------------------------------------------*\n         TM    @_ISPF_EDIF,L'@_ISPF_EDIF  Do we want EDIF?\n         JZ    J00020                   No, go do BRIF\n\n         LA    R15,=CL8'EDIF'           A(EDIF)\n         ST    R15,@J_ISPF_Parms        Save it\n         LA    R15,J_Data_Name          A(Data-name)\n         ST    R15,@J_ISPF_Parms+4      Save it\n         LA    R15,=CL8'TEXT'           A(Profile name)\n         ST    R15,@J_ISPF_Parms+8      Save it\n         LA    R15,=C'F '               A(record-format)\n         ST    R15,@J_ISPF_Parms+12     Save it\n         LA    R15,@J_ISPF_LRECL        A(record length)\n         ST    R15,@J_ISPF_Parms+16     Save it\n         LA    R15,=AL4(JA0010)         A(Read Routine)\n         ST    R15,@J_ISPF_Parms+20     Save it\n         LA    R15,=AL4(JB0010)         A(Write Routine)\n         ST    R15,@J_ISPF_Parms+24     Save it\n         LA    R15,=AL4(0)              No Cmd Routine\n         ST    R15,@J_ISPF_Parms+28     Save it\n         LA    R15,@J_ISPF_Rtn_Parms_Ptr Point to routine parmlist ptr\n         ST    R15,@J_ISPF_Parms+32     Save it\n         OI    @J_ISPF_Parms+32,X'80'   Flag as last parm\n\n         XC    @J_EDIF_Prev_Rec_Nbr,@J_EDIF_Prev_Rec_Nbr\n\n         J     J00040                   Go invoke EDIF\n\nJ00020   DS    0H\n*-------------------------------------------------------------------*\n*    ... or BRIF parms ...                                          *\n*-------------------------------------------------------------------*\n         LA    R15,=CL8'BRIF'           A(BRIF)\n         ST    R15,@J_ISPF_Parms        Save it\n         LA    R15,J_Data_Name          A(Data-name)\n         ST    R15,@J_ISPF_Parms+4      Save it\n         LA    R15,=C'F '               A(record-format)\n         ST    R15,@J_ISPF_Parms+8      Save it\n         LA    R15,@J_ISPF_LRECL        A(record length)\n         ST    R15,@J_ISPF_Parms+12     Save it\n         LA    R15,=AL4(JA0010)         A(Read Routine)\n         ST    R15,@J_ISPF_Parms+16     Save it\n         LA    R15,=AL4(JC0010)         A(Cmd Routine)\n         ST    R15,@J_ISPF_Parms+20     Save it\n         LA    R15,@J_ISPF_Rtn_Parms_Ptr Point to routine parmlist ptr\n         ST    R15,@J_ISPF_Parms+24     Save it\n         OI    @J_ISPF_Parms+24,X'80'   Flag as last parm\n\n         J     J00040                   Go invoke BRIF\n\nJ00040   DS    0H\n*-------------------------------------------------------------------*\n*    ... and invoke EDIF or BRIF                                    *\n*-------------------------------------------------------------------*\n         LA    R1,@J_ISPF_Parms         A(ISPF Parms)\n         L     R15,@_ISPLINK            A(ISPF routine)\n         BASR  R14,R15                  Invoke EDIF or BRIF\n\n         LA    R15,0                    Clear return code\n         LA    R0,0                     and reason code\n         J     J90010                   and exit\n\n\nJ90010   DS    0H\n*-------------------------------------------------------------------*\n*    Free up our local storage ...                                  *\n*-------------------------------------------------------------------*\n         LA    R1,@J_Dynam              A(Local storage)\n         L     R2,@J_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         L     R13,4(0,R13)             Rescue A(HSA)\n\n         SSCSTACK POP,                  Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=(R2)                on this stack\n\n*-------------------------------------------------------------------*\n*    ... and return to caller                                       *\n*-------------------------------------------------------------------*\n         L     R14,12(0,R13)            Restore return address\n         LA    R15,0                    Clear return code\n         LM    R0,R12,20(R13)           Restore other registers\n         BSM   0,R14                    and return\n\n\nJ_Literals  DS  0H\nJ_Data_Name EQU *\n            DC C'&PGMNAME'\n            DC X'00'\n            DC C'&VERSION'\n            DC C' '\n\n         LTORG\n\nJ_Literals_End  DS  0H\n\n\n@J_Dynam                  DSECT        Dynamic area for J00000\n                          DS    18F     O/S Style save area\n@J_31Bit_Stack_Ptr_Ptr    DS    AL4     A(31-bit Stack Ptr)\n@J_24Bit_Stack_Ptr_Ptr    DS    AL4     A(24-bit Stack Ptr)\n@J_DBLWD                  DS    D       Work area\n@J_ISPF_LRECL             DS    XL4     Record length for EDIF/BRIF\n@J_EDIF_Prev_Rec_Nbr      DS    FL4     Last rec nbr passed to EDIF\n@J_ISPF_Parms             DS    9AL4    Parms for EDIF/BRIF\n@J_ISPF_Rtn_Parms_Ptr     DS    AL4     A(Parms for EDIF/BRIF Routines)\n@J_ISPF_Rtn_Parms         DS    4AL4    Parms for EDIF/BRIF Routines\n                          DS    0D      Alignment\n@J_Dynam_Length           EQU   *-@J_Dynam  Length of storage\n\n&PGMNAME CSECT\n\n         DROP  ,\n         POP   USING\n\n\n\nJA0010   DS    0H\n\n         PUSH  USING                    Save USING environment\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    EDIF/BRIF Read Routine                                         *\n*     Input: R1 ---> A(Record pointer)                              *\n*                    A(Length of record read)                       *\n*                    A(Request Code)                                *\n*                    A(Parms Ptr): A(Parms): A(@_Dynam)             *\n*                                            A(31-bit Stack Ptr)    *\n*                                            A(24-bit Stack Ptr)    *\n*                                            A(EDIF Rec Nbr fld)    *\n*                                                                   *\n*     Output: R15:  0 - Record returned                             *\n*                   8 - EOF                                         *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         BAKR  R14,0                    Save callers registers\n         LARL  R11,JA_Literals          Point to our literals\n         USING (JA_Literals,JA_Literals_End),R11 Tell the assembler\n\n         L     R12,12(0,R1)             Get A(Parmlist pointer)\n         L     R12,0(0,R12)             Get A(Parmlist)\n         L     R12,0(0,R12)             Get A(@_Dynam)\n         USING @_Dynam,R12              Assign a base\n\n*-------------------------------------------------------------------*\n*    Get an area on the stack for our local storage                 *\n*-------------------------------------------------------------------*\n         L     R2,12(0,R1)              Get A(Parmlist pointer)\n         L     R2,0(0,R2)               Get A(Parmlist)\n         L     R2,4(0,R2)               Get A(31-bit Stack Ptr)\n         L     R2,0(0,R2)               Get A(31-bit Stack)\n         SSCSTACK PUSH,                 Get stack area                 +\n               LEN=@JA_Dynam_Length,     this long                     +\n               STACK=(R2)                using this stack\n\n         LR    R3,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LHI   R1,@JA_Dynam_Length      Its length\n         LA    R14,0                    Clear source address\n         LA    R15,0                     and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R3                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*-------------------------------------------------------------------*\n         LR    R13,R1                   Load dynam base\n         USING @JA_Dynam,R13            Assign a base\n         MVC   4(4,R13),=C'F1SA'        Init save area\n\n         EREG  R0,R3                    Restore callers registers\n\n         L     R14,12(0,R1)             A(Parmlist Ptr)\n         L     R14,0(0,R14)             A(Parmlist)\n         L     R15,4(0,R14)             A(31-bit Stack Ptr)\n         ST    R15,@JA_31Bit_Stack_Ptr_Ptr Save it\n         L     R15,8(0,R14)             A(24-bit Stack Ptr)\n         ST    R15,@JA_24Bit_Stack_Ptr_Ptr Save it\n\n*-------------------------------------------------------------------*\n*    Get the record number requested (BRIF), or retrieve it from    *\n*   our variable (EDIF)                                             *\n*-------------------------------------------------------------------*\n         L     R3,8(0,R1)               Get A(record number)\n         L     R3,0(0,R3)               Get record number\n         TM    @_ISPF_BRIF,L'@_ISPF_BRIF Is this BRIF?\n         JO    JA0020                   Yes, skip\n         L     R15,12(0,R1)             No, A(Parms Ptr)\n         L     R15,0(0,R15)             A(Parms)\n         L     R15,12(0,R15)            A(Prev EDIF Record number)\n         L     R3,0(0,R15)              Prev EDIF Record number\n         AHI   R3,1                     Bump it\n         ST    R3,0(0,R15)              and save it\n\nJA0020   DS    0H\n*-------------------------------------------------------------------*\n*    Run through the table, looking for our record                  *\n*-------------------------------------------------------------------*\n         L     R9,@_VolTbl_Ptr          A(Volume Table)\n         L     R10,VolTbl_Hdr_Count-VolTbl_Hdr(R9) Nbr entries\n         AHI   R9,VolTbl_Ent-VolTbl     and point to first\n         USING VolTbl_Ent,R9            Assign a base\n         LA    R4,0                     Clear record count\nJA0030   DS    0H\n         TM    VolTbl_Ent_Heading_Line,L'VolTbl_Ent_Heading_Line A Hdg?\n         JNO   JA0040                   No, skip\n         TM    @_No_Headings,L'@_No_Headings Yes, do we want them?\n         JO    JA0090                   No, skip it\n         J     JA0070                   Yes, check it out\nJA0040   DS    0H\n         TM    VolTbl_Ent_Detail_Line,L'VolTbl_Ent_Detail_Line\n         JNO   JA0050                   No, skip\n         TM    @_No_Details,L'@_No_Details Yes, do we want them?\n         JO    JA0090                   No, skip it\n         J     JA0070                   Yes, check it out\nJA0050   DS    0H\n         TM    VolTbl_Ent_Total_Line,L'VolTbl_Ent_Total_Line\n         JNO   JA0060                   No, skip\n         TM    @_No_Totals,L'@_No_Totals Yes, do we want them?\n         JO    JA0090                   No, skip it\n         J     JA0070                   Yes, check it out\nJA0060   DS    0H\n         TM    @_Statistics,L'@_Statistics Do we want stats?\n         JNO   JA0090                   No, skip it\nJA0070   DS    0H\n         LA    R8,VolTbl_Ent            Save A(Entry)\n         AHI   R4,1                     Bump record count\n         CR    R4,R3                    Is this ours?\n         JL    JA0090                   No, skip it\n         TM    @_Statistics,L'@_Statistics Yes, Stats line?\n         JNO   JA0080                   No, skip\n         STM   R0,R1,@JA_Temp_Save      Yes, save our registers\n\n         LA    R15,@_Dynam              A(Dynamic area)\n         ST    R15,@JA_Parms_Std        Save it\n         L     R15,@JA_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)\n         ST    R15,@JA_Parms_Std+4      Save it\n         L     R15,@JA_24Bit_Stack_Ptr_Ptr A(24-bit Stack Pointer)\n         ST    R15,@JA_Parms_Std+8      Save it\n         LA    R15,VolTbl_Ent           A(Table entry)\n         ST    R15,@JA_Parms_V00010     Save it\n\n         LA    R1,@JA_Parms             Point to the parmlist\n         BRAS  R14,V00010               Process stats line\n         LM    R0,R1,@JA_Temp_Save      Restore our registers\nJA0080   DS    0H\n         TM    VolTbl_Ent_ECB,X'40'     Entry populated?\n         JO    JA0100                   Yes, OK\n         STM   R0,R1,@JA_Temp_Save      Yes, save our registers\n         WAIT  ECB=VolTbl_Ent_ECB       No, WAIT for it\n         LM    R0,R1,@JA_Temp_Save      Restore our registers\n         J     JA0100                   and skip\nJA0090   DS    0H\n         AHI   R9,VolTbl_Ent_Len        A(Next entry)\n         BRCT  R10,JA0030\n\n*-------------------------------------------------------------------*\n*    We have reached the end of the table before finding our        *\n*   record - set the EOF return code, and, if this is BRIF, the     *\n*   pointer to the last valid record, and the record number.        *\n*-------------------------------------------------------------------*\n         LA    R15,8                  EOF\n         TM    @_ISPF_EDIF,L'@_ISPF_EDIF Is this EDIF?\n         JO    JA0110                 Yes, exit\n\n         LR    R9,R8                   A(Last valid entry)\n         L     R14,8(0,R1)            A(Record count)\n         ST    R4,0(0,R14)            update it for BRIF\n         LA    R15,8                  EOF\n         J     JA0110                 and skip\n\nJA0100   DS    0H\n         LA    R15,0                    found our record\n         J     JA0110                   and skip\n\nJA0110   DS    0H\n*-------------------------------------------------------------------*\n*    ... and update the record pointer (R9).                        *\n*-------------------------------------------------------------------*\n         AHI   R9,VolTbl_Ent_Display-VolTbl_Ent   Readable bits\n\n         L     R14,0(0,R1)            A(Record pointer)\n         ST    R9,0(0,R14)            update it\n         J     JA9010                 and exit\n\nJA9010   DS    0H\n*-------------------------------------------------------------------*\n*    Free up our local storage ...                                  *\n*-------------------------------------------------------------------*\n         LR    R3,R15                 Save return code\n\n         LA    R1,@JA_Dynam             A(Local storage)\n         L     R2,@JA_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n\n         SSCSTACK POP,                  Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=(R2)                on this stack\n\n         LR    R15,R3                   Restore return code\n\n*-------------------------------------------------------------------*\n*    ... and return to caller                                       *\n*-------------------------------------------------------------------*\n         PR    ,                        and return\n\nJA_Literals  DS  0H\n\n         LTORG\n\nJA_Literals_End  DS  0H\n\n\n@JA_Dynam                 DSECT\n                          DS    18F     O/S style save area\n@JA_31Bit_Stack_Ptr_Ptr   DS    AL4     A(31-bit Stack Ptr)\n@JA_24Bit_Stack_Ptr_Ptr   DS    AL4     A(24-bit Stack Ptr)\n@JA_Temp_Save             DS    2FL4    Save area around V00010 call\n\n@JA_Parms                 DS    0F      Parms for called rtns\n@JA_Parms_Std             DS    3AL4     Standard 3 parms\n@JA_Parms_Extra           EQU   *        Extra parms\n@JA_Parms_V00010          DS    AL4         for V00010\n                          ORG   ,\n                          DS    0D\n@JA_Dynam_Length          EQU   *-@JA_Dynam\n\n\n&PGMNAME CSECT\n         DROP  ,                        Free base registers\n         POP   USING\n\n\nJB0010   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    EDIF Write Routine                                             *\n*     Input: R1 ---> A(Record pointer)                              *\n*                    A(Length of record read)                       *\n*                    A(Change Flags)                                *\n*                    A(Request Code)                                *\n*                    A(Parms Ptr): A(Parms): A(@_Dynam)             *\n*                                            A(31-bit Stack Ptr)    *\n*                                            A(24-bit Stack Ptr)    *\n*                                            A(A word for our use)  *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         PUSH  USING                    Save USING environment\n         DROP  ,                        Free base registers\n\n         BAKR  R14,0                    Save callers registers\n         LARL  R11,JB_Literals          Point to our literals\n         USING (JB_Literals,JB_Literals_End),R11 Tell the assembler\n\n         L     R12,16(0,R1)             Get A(ParmList Ptr)\n         L     R12,0(0,R12)             Get A(ParmList)\n         L     R12,0(0,R12)             Get A(@_Dynam)\n         USING @_Dynam,R12              Assign a base\n\n*-------------------------------------------------------------------*\n*    Get an area on the stack for our local storage                 *\n*-------------------------------------------------------------------*\n         L     R2,16(0,R1)              Get A(Parmlist Ptr)\n         L     R2,0(0,R2)               Get A(Parmlist)\n         L     R2,4(0,R2)               Get A(31-bit Stack Ptr)\n         L     R2,0(0,R2)               Get A(31-bit Stack)\n         SSCSTACK PUSH,                 Get stack area                 +\n               LEN=@JB_Dynam_Length,     this long                     +\n               STACK=(R2)                using this stack\n\n         LR    R3,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LHI   R1,@JB_Dynam_Length      Its length\n         LA    R14,0                    Clear source address\n         LA    R15,0                     and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R3                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*    Set up our save area, and restore the important registers      *\n*   that we have destroyed                                          *\n*-------------------------------------------------------------------*\n         LR    R13,R1                   Load dynam base\n         USING @JB_Dynam,R13            Assign a base\n         MVC   4(4,R13),=C'F1SA'        Init save area\n\n         EREG  R0,R3                    Restore callers registers\n\n         L     R14,16(0,R1)             A(Parmlist Ptr)\n         L     R14,0(0,R14)             A(Parmlist)\n         L     R15,4(0,R14)             A(31-bit Stack)\n         ST    R15,@JB_31Bit_Stack_Ptr_Ptr Save it\n         L     R15,8(0,R14)             A(24-bit Stack)\n         ST    R15,@JB_24Bit_Stack_Ptr_Ptr Save it\n\n*-------------------------------------------------------------------*\n*    If this is the last (or only) write request, set an ISPF       *\n*    message to say the data wasn't saved ...                       *\n*-------------------------------------------------------------------*\n         L     R15,12(0,R1)             A(Request code)\n         L     R15,0(0,R15)             Get it\n         CHI   R15,2                    Last write request?\n         JE    JB0020                   Yes, issue message\n         CHI   R15,3                    Maybe, Last (and only)?\n         JE    JB0020                   Yes, skip\n\n         LA    R15,0                    No, clear return code\n         J     JB9010                   and exit\n\nJB0020   DS    0H\n         LA    R15,=CL8'VDEFINE'        ISPF Function\n         ST    R15,@JB_ISPF_Parms       Save it\n         LA    R15,=CL8'CHAR'           Character variables\n         ST    R15,@JB_ISPF_Parms+12 Save it\n\n         LA    R15,=CL8'ZEDSMSG'        Variable name\n         ST    R15,@JB_ISPF_Parms+4     Save it\n         LA    R15,JB_NoSave_SMsg       Short message\n         ST    R15,@JB_ISPF_Parms+8     Save it\n         LA    R15,=AL4(L'JB_NoSave_SMsg)     Length of message\n         ST    R15,@JB_ISPF_Parms+16 Save it\n         OI    @JB_ISPF_Parms+16,X'80' Flag end of list\n         LA    R1,@JB_ISPF_Parms        A(Parmlist)\n         L     R15,@_ISPLINK            A(ISPF Interface)\n         BASR  R14,R15                  Go do it\n\n         LA    R15,=CL8'ZEDLMSG'        Variable name\n         ST    R15,@JB_ISPF_Parms+4     Save it\n         LA    R15,JB_NoSave_LMsg       Short message\n         ST    R15,@JB_ISPF_Parms+8     Save it\n         LA    R15,=AL4(L'JB_NoSave_LMsg)     Length of message\n         ST    R15,@JB_ISPF_Parms+16 Save it\n         OI    @JB_ISPF_Parms+16,X'80' Flag end of list\n         LA    R1,@JB_ISPF_Parms        A(Parmlist)\n         L     R15,@_ISPLINK            A(ISPF Interface)\n         BASR  R14,R15                  Go do it\n\n         LA    R15,=CL8'SETMSG'         Yes, ISPF Function\n         ST    R15,@JB_ISPF_Parms       Save it\n         LA    R15,=CL8'ISRZ001'        A(Message ID)\n         ST    R15,@JB_ISPF_Parms+4     Save it\n         OI    @JB_ISPF_Parms+4,X'80' Mark end of list\n         LA    R1,@JB_ISPF_Parms        Point to ISPF parms\n         L     R15,@_ISPLINK            A(Interface routine)\n         BASR  R14,R15                  Go do it\n\n*-------------------------------------------------------------------*\n*    ... and exit                                                   *\n*-------------------------------------------------------------------*\n\n         LA    R15,0                    Clear return code\n         J     JB9010                   and exit\n\nJB9010   DS    0H\n*-------------------------------------------------------------------*\n*    Free up our local storage ...                                  *\n*-------------------------------------------------------------------*\n         LR    R3,R15                 Save return code\n\n         LA    R1,@JB_Dynam             A(Local storage)\n         L     R2,@JB_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         L     R13,4(0,R13)             Rescue A(HSA)\n\n         SSCSTACK POP,                  Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=(R2)                on this stack\n\n         LR    R15,R3                   Restore return code\n\n*-------------------------------------------------------------------*\n*    ... and return to caller                                       *\n*-------------------------------------------------------------------*\n         PR    ,                        and return\n\n\nJB_Literals  DS  0H\n\nJB_NoSave_SMsg     DC   C'SAVE disabled'\nJB_NoSave_LMsg     DC   C'Use CREATE or REPLACE to save the data'\n\n         LTORG\n\nJB_Literals_End  DS  0H\n\n\n@JB_Dynam                 DSECT\n                          DS    18F     O/S style save area\n@JB_31Bit_Stack_Ptr_Ptr   DS    AL4     A(31-bit Stack Ptr)\n@JB_24Bit_Stack_Ptr_Ptr   DS    AL4     A(24-bit Stack Ptr)\n@JB_ISPF_Parms            DS    5AL4    Parm list for ISPF\n                          DS    0D\n@JB_Dynam_Length          EQU   *-@JB_Dynam\n\n\n&PGMNAME CSECT\n         DROP  ,                        Free base registers\n         POP   USING\n\n\nJC0010   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    BRIF Command Routine                                           *\n*     Input: R1 ---> A(Function Code)                               *\n*                    A(Parms Ptr): A(Parms): A(@_Dynam)             *\n*                                            A(31-bit Stack Ptr)    *\n*                                            A(24-bit Stack Ptr)    *\n*                                            A(A word for our use)  *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         PUSH  USING                    Save USING environment\n         DROP  ,                        Free base registers\n\n         BAKR  R14,0                    Save callers registers\n         LARL  R11,JC_Literals          Point to our literals\n         USING (JC_Literals,JC_Literals_End),R11 Tell the assembler\n\n         L     R12,4(0,R1)              Get A(Parmlist Ptr)\n         L     R12,0(0,R12)             Get A(ParmList)\n         L     R12,0(0,R12)             Get A(@_Dynam)\n         USING @_Dynam,R12              Assign a base\n\n*-------------------------------------------------------------------*\n*    Get an area on the stack for our local storage                 *\n*-------------------------------------------------------------------*\n         L     R2,4(0,R1)               Get A(Parmlist Ptr)\n         L     R2,0(0,R2)               Get A(Parmlist)\n         L     R2,4(0,R2)               Get A(31-bit Stack Ptr)\n         L     R2,0(0,R2)               Get A(31-bit Stack)\n         SSCSTACK PUSH,                 Get stack area                 +\n               LEN=@JC_Dynam_Length,     this long                     +\n               STACK=(R2)                using this stack\n\n         LR    R3,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LHI   R1,@JC_Dynam_Length      Its length\n         LA    R14,0                    Clear source address\n         LA    R15,0                     and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R3                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*    Set up our save area, and restore the important registers      *\n*   that we have destroyed                                          *\n*-------------------------------------------------------------------*\n         LR    R13,R1                   Load dynam base\n         USING @JC_Dynam,R13            Assign a base\n         MVC   4(4,R13),=C'F1SA'        Init save area\n\n         EREG  R0,R3                    Restore callers registers\n\n         L     R14,4(0,R1)              A(Parmlist Ptr)\n         L     R14,0(0,R14)             A(Parmlist)\n         L     R15,4(0,R14)             A(31-bit Stack)\n         ST    R15,@JC_31Bit_Stack_Ptr_Ptr Save it\n         L     R15,8(0,R14)             A(24-bit Stack)\n         ST    R15,@JC_24Bit_Stack_Ptr_Ptr Save it\n\n*-------------------------------------------------------------------*\n*    Check out the function code from BRIF ...                      *\n*-------------------------------------------------------------------*\n         L     R15,0(0,R1)              Get A(Function code)\n         L     R15,0(0,R15)             Get it\n         CHI   R15,20                   Unknown command?\n         JNE   JC0030                   No, let recursive browse work\n\n*-------------------------------------------------------------------*\n*    ... and go check it out                                        *\n*-------------------------------------------------------------------*\n         LA    R15,@_Dynam              A(Dynamic area)\n         ST    R15,@JC_Parms_Std        Save it\n         L     R15,@JC_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)\n         ST    R15,@JC_Parms_Std+4      Save it\n         L     R15,@JC_24Bit_Stack_Ptr_Ptr A(24-bit Stack Pointer)\n         ST    R15,@JC_Parms_Std+8      Save it\n\n         LA    R1,@JC_Parms             Point to the parmlist\n         BRAS  R14,L00010               Process command\n\n         TM    @_ReDisplay,L'@_ReDisplay Display mode change?\n         JO    JC0020                   Yes, set rc and exit\n         LTR   R15,R15                  Did we process the command?\n         JNZ   JC0030                   No, skip\n         LA    R15,0                    Yes, normal completion\n         J     JC9010                   and exit\n\nJC0020   DS    0H\n         LA    R15,=CL8'VDEFINE'        ISPF Function\n         ST    R15,@JC_ISPF_Parms       Save it\n         LA    R15,=CL8'ZCMD'           Variable name\n         ST    R15,@JC_ISPF_Parms+4     Save it\n         LA    R15,JC_Blanks            A(blank string)\n         ST    R15,@JC_ISPF_Parms+8     Save it\n         LA    R15,=CL8'CHAR'           Character variables\n         ST    R15,@JC_ISPF_Parms+12    Save it\n         LA    R15,=AL4(L'JC_Blanks)    Length of blank string\n         ST    R15,@JC_ISPF_Parms+16    Save it\n         OI    @JC_ISPF_Parms+16,X'80'  Flag end of list\n         LA    R1,@JC_ISPF_Parms        A(Parmlist)\n         L     R15,@_ISPLINK            A(ISPF Interface)\n         BASR  R14,R15                  Go do it\n\n         LA    R15,=CL8'VPUT'           ISPF Function\n         ST    R15,@JC_ISPF_Parms       Save it\n         LA    R15,=CL8'ZCMD'           A(Variable name)\n         ST    R15,@JC_ISPF_Parms+4     Save it\n         LA    R15,=CL8'ASIS'           A(Variable name)\n         ST    R15,@JC_ISPF_Parms+8     Save it\n         OI    @JC_ISPF_Parms+8,X'80'   Flag end of list\n         LA    R1,@JC_ISPF_Parms        A(Parmlist)\n         L     R15,@_ISPLINK            A(ISPF Interface)\n         BASR  R14,R15                  Go do it\n\n         LHI   R15,20                   Re-display requested, exit\n         J     JC9010                   and exit\n\nJC0030   DS    0H\n         LHI   R15,4                    Unknown command, let BRIF do it\n         J     JC9010                   and exit\n\nJC9010   DS    0H\n*-------------------------------------------------------------------*\n*    Free up our local storage ...                                  *\n*-------------------------------------------------------------------*\n         LR    R3,R15                 Save return code\n\n         LA    R1,@JC_Dynam             A(Local storage)\n         L     R2,@JC_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n\n         SSCSTACK POP,                  Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=(R2)                on this stack\n\n         LR    R15,R3                   Restore return code\n\n*-------------------------------------------------------------------*\n*    ... and return to caller                                       *\n*-------------------------------------------------------------------*\n         PR    ,                        and return\n\nJC_Literals  DS  0H\n\nJC_Blanks    DC  C' '\n\n         LTORG\n\nJC_Literals_End  DS  0H\n\n\n@JC_Dynam                 DSECT\n                          DS    18F     O/S style save area\n@JC_31Bit_Stack_Ptr_Ptr   DS    AL4     A(31-bit Stack Ptr)\n@JC_24Bit_Stack_Ptr_Ptr   DS    AL4     A(24-bit Stack Ptr)\n@JC_ISPF_Parms            DS    5AL4    ISPF parms\n\n@JC_Parms                 DS    0F      Parms for called rtns\n@JC_Parms_Std             DS    3AL4     Standard 3 parms\n@JC_Parms_Extra           EQU   *        Extra parms\n                          ORG   ,\n\n                          DS    0D\n@JC_Dynam_Length          EQU   *-@JC_Dynam\n\n&PGMNAME CSECT\n         DROP  ,                        Free base registers\n         POP   USING\n         TITLE 'K00010: ISPF(S) Display'\n\n         PUSH  USING\n\nK00010   DS    0H\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Routine   : K00010                                                 *\n*                                                                     *\n*  Abstract  : Display the results via the ISPF SPACE Panel           *\n*                                                                     *\n*  Inputs    : R1 : ---> A(@_Dynam)                                   *\n*                        A(31-bit Stack Pointer)                      *\n*                        A(24-bit Stack Pointer)                      *\n*  Outputs   : R15: 0: OK                                             *\n*                   4: Panel not found                                *\n*                                                                     *\n*  Notes     :                                                        *\n*                                                                     *\n*  History:    2002/02/12 SDDA030 - V2.16                             *\n*                                 - New (originally part of G00010)   *\n*                                 - Used Dynamic displays (rather than*\n*                                   TBDISPL) for ISPF(S).             *\n*                                 - Added LEFT/RIGHT processing for   *\n*                                   ISPF(S).                          *\n*                                 - Added sort prompt pop-up panel in *\n*                                   ISPF(B).                          *\n*              2002/06/11 SDDA030 - V2.18                             *\n*                                   WAIT for VolTbl_Ent to be populated\n*                                   before outputting                 *\n*              2004/10/15 SDDA030 - V2.22                             *\n*                                 - Resequenced labels                *\n*              2006/04/21 SDDA030 - V2.24                             *\n*                                 - Added code to display number when *\n*                                   cursor on numeric fld, and ENTER. *\n*                                 - Used standardised calling sequence*\n*                                 - Changed 'Line x of y' to 'Line x'.*\n*              ____/__/__ _______                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         STM   R14,R12,12(R13)          Save callers registers\n         LARL  R11,K_Literals           Point to our literals\n         USING (K_Literals,K_Literals_End),R11 Tell the assembler\n\n         L     R12,0(0,R1)              A(@_Dynam)\n         USING @_Dynam,R12              Tell the assembler\n\n*-------------------------------------------------------------------*\n*    Get an area on the stack for our local storage                 *\n*-------------------------------------------------------------------*\n         L     R2,4(0,R1)               A(31-bit stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         SSCSTACK PUSH,                 Get stack area                 +\n               LEN=@K_Dynam_Length,      this long                     +\n               STACK=(R2)                using this stack\n\n         LR    R3,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LHI   R1,@K_Dynam_Length        Its length\n         LA    R14,0                    Clear source address\n         LA    R15,0                     and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R3                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*-------------------------------------------------------------------*\n         ST    R13,4(0,R1)              Chain\n         ST    R1,8(0,R13)               saveareas\n         LR    R13,R1                   Load dynam base\n         USING @K_Dynam,R13             Assign a base\n         L     R15,@K_Dynam+4           Get A(HSA)\n         LM    R0,R3,20(R15)            Restore callers registers\n\n         L     R15,4(0,R1)              A(31-bit Stack Pointer)\n         ST    R15,@K_31Bit_Stack_Ptr_Ptr Save it\n         L     R15,8(0,R1)              A(24-bit Stack Pointer)\n         ST    R15,@K_24Bit_Stack_Ptr_Ptr Save it\n\n*--------------------------------------------------------------------*\n*   Initialize our standard parmlist                                 *\n*--------------------------------------------------------------------*\n         LA    R15,@_Dynam              A(Dynamic area)\n         ST    R15,@K_Parms_Std         Save it\n         L     R15,@K_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)\n         ST    R15,@K_Parms_Std+4       Save it\n         L     R15,@K_24Bit_Stack_Ptr_Ptr A(24-bit Stack Pointer)\n         ST    R15,@K_Parms_Std+8       Save it\n\n*-------------------------------------------------------------------*\n*    Check to see that our panel exists, and that it has an         *\n*   appropriate Dynamic area in it.                                 *\n*-------------------------------------------------------------------*\n         LA    R15,=CL8'VDEFINE'        ISPF Function\n         ST    R15,@K_ISPF_Parms        Save it\n         LA    R15,K_ISPF_PQUERY_Names  A(Variable names)\n         ST    R15,@K_ISPF_Parms+4      Save it\n         LA    R15,@K_ISPF_PQUERY_Values A(Variable storage)\n         ST    R15,@K_ISPF_Parms+8      Save it\n         LA    R15,K_ISPF_PQUERY_Types  A(Variable types)\n         ST    R15,@K_ISPF_Parms+12     Save it\n         LA    R15,K_ISPF_PQUERY_Lens   A(Variable lengths)\n         ST    R15,@K_ISPF_Parms+16     Save it\n         LA    R15,=CL8'LIST'           Variable types\n         ST    R15,@K_ISPF_Parms+20     Save it\n         OI    @K_ISPF_Parms+20,X'80'   Flag last parm\n         LA    R1,@K_ISPF_Parms         A(ISPF Parms)\n         L     R15,@_ISPLINK            A(ISPF routine)\n         BASR  R14,R15                  Go check out panel\n\n         LA    R15,=CL8'PQUERY'         ISPF Function\n         ST    R15,@K_ISPF_Parms        Save it\n         LA    R15,=CL8'&PNLNAME'       A(Panel name)\n         ST    R15,@K_ISPF_Parms+4      Save it\n         LA    R15,=CL8'DATA    '       A(Area name)\n         ST    R15,@K_ISPF_Parms+8      Save it\n         LA    R15,K_SPCDYNTY           A(Area Type variable name)\n         ST    R15,@K_ISPF_Parms+12     Save it\n         LA    R15,K_SPCDYNWI           A(Width variable name)\n         ST    R15,@K_ISPF_Parms+16     Save it\n         LA    R15,K_SPCDYNDE           A(Depth variable name)\n         ST    R15,@K_ISPF_Parms+20     Save it\n         LA    R15,K_SPCDYNRO           A(Starting Row Number name)\n         ST    R15,@K_ISPF_Parms+24     Save it\n         LA    R15,K_SPCDYNCO           A(Starting Column number name)\n         ST    R15,@K_ISPF_Parms+28     Save it\n         OI    @K_ISPF_Parms+28,X'80'   Flag last parm\n         LA    R1,@K_ISPF_Parms         A(ISPF Parms)\n         L     R15,@_ISPLINK            A(ISPF routine)\n         BASR  R14,R15                  Go check out panel\n         LTR   R15,R15                  All OK?\n         JNZ   K80010                   No, error and exit\n\n         CLC   =CL8'DYNAMIC',@K_ISPF_SPCDYNTN_Value  Dynamic?\n         JNE   K80010                   No, error and exit\n         ICM   R15,B'1111',@K_ISPF_SPCDYNWI_Value  Width OK?\n         JZ    K80010                   No, error and exit\n         ST    R15,@K_ISPF_Dyn_Area_Width Yes, save it\n         ICM   R15,B'1111',@K_ISPF_SPCDYNDE_Value  Depth OK?\n         JZ    K80010                   No, error and exit\n         ST    R15,@K_ISPF_Dyn_Area_Depth Yes, save it\n         ICM   R15,B'1111',@K_ISPF_SPCDYNRO_Value  Starting Row OK?\n         JZ    K80010                   No, error and exit\n         AHI   R15,-1                   Yes, relative to 0\n         ST    R15,@K_ISPF_Dyn_Area_Row and save it\n         ICM   R15,B'1111',@K_ISPF_SPCDYNCO_Value  Starting column OK?\n         JZ    K80010                   No, error and exit\n         AHI   R15,-1                   Yes, relative to 0\n         ST    R15,@K_ISPF_Dyn_Area_Column and save it\n\n*---------------------------------------------------------------------*\n*     The panel seems OK, get some storage for the Dynamic Area ...   *\n*---------------------------------------------------------------------*\n         L     R1,@K_ISPF_Dyn_Area_Width Get area width\n         M     R0,@K_ISPF_Dyn_Area_Depth Get total length\n\n         ST    R1,@K_ISPF_Dyn_Area_Len  Save it\n         LR    R0,R1                    in proper register\n\n         L     R2,@K_31Bit_Stack_Ptr_Ptr A(31-bit stack Ptr)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         SSCSTACK PUSH,                 Get stack area                 +\n               LEN=(0),                  this long                     +\n               STACK=(R2)                using this stack\n\n         ST    R1,@K_ISPF_Dyn_Area_Ptr  Save A(Our storage)\n\n*---------------------------------------------------------------------*\n*     ... define it to ISPF ...                                       *\n*---------------------------------------------------------------------*\n         LA    R15,=CL8'VDEFINE'        ISPF Function\n         ST    R15,@K_ISPF_Parms        Save it\n         LA    R15,=CL8'DATA'           Variable name\n         ST    R15,@K_ISPF_Parms+4      Save it\n         L     R15,@K_ISPF_Dyn_Area_Ptr Point to it\n         ST    R15,@K_ISPF_Parms+8      Save it\n         LA    R15,=CL8'CHAR'           Character data\n         ST    R15,@K_ISPF_Parms+12     Save it\n         L     R15,@K_ISPF_Dyn_Area_Len Length of diaplay area\n         ST    R15,@K_ISPF_Parms+20     Save it\n         LA    R15,@K_ISPF_Parms+20     Point to it\n         ST    R15,@K_ISPF_Parms+16     Save it\n         OI    @K_ISPF_Parms+16,X'80'   Flag end of list\n         LA    R1,@K_ISPF_Parms         A(Parmlist)\n         L     R15,@_ISPLINK            A(ISPF Interface)\n         BASR  R14,R15                  Go do it\n\n*---------------------------------------------------------------------*\n*     ... and init some variables.                                    *\n*---------------------------------------------------------------------*\n         LA    R15,VolTbl_Ent_DevType-VolTbl_Ent_Display Set our\n         ST    R15,@K_VolTbl_Ent_Offset  offset\n\n         LA    R15,0                    Current top of display\n         ST    R15,@K_VolTbl_Ent_Display_Line Save it\n\n         LHI   R15,VolTbl_Ent_Display_Len Get max display len\n         S     R15,@K_ISPF_Dyn_Area_Width  Max offset within display\n         A     R15,=AL4(VolTbl_Ent_DevType-VolTbl_Ent_Display)\n         ST    R15,@K_VolTbl_Ent_Offset_Max Save it\n\n         L     R15,@_VolTbl_Ptr         A(Volume Table)\n         L     R15,VolTbl_Hdr_Count-VolTbl_Hdr(R15) Get nbr entries\n         ST    R15,@K_VolTbl_Ent_Display_Line_Max Save it\n\n         LA    R15,0                    Number of heading lines\n         ST    R15,@K_ISPF_Dyn_Area_Hdg_Lines and save it\n         ST    R15,@K_VolTbl_Hdg_Lines  here too\n\n         MVC   @K_VolTbl_Ent_Display_Line_Prev,=FL4'-1' Force the area\n         MVC   @K_VolTbl_Ent_Offset_Prev,=FL4'-1'  to be populated\n\n*---------------------------------------------------------------------*\n*     Set the EX length of each line of data to be copied to the      *\n*    dynamic area                                                     *\n*---------------------------------------------------------------------*\n         L     R15,@K_ISPF_Dyn_Area_Width Get area width\n         S     R15,=AL4(VolTbl_Ent_DevType-VolTbl_Ent_Display) Len\n         AHI   R15,-1                   EX length of data\n         ST    R15,@K_VolTbl_Ent_MVC_Len Save it\n\n*---------------------------------------------------------------------*\n*   Produce Heading 0, if required ...                                *\n*---------------------------------------------------------------------*\n         TM    @_No_Headings,L'@_No_Headings  Headings wanted?\n         JO    K00050                   No, skip\n\n         LA    R15,=CL8'VDEFINE'        ISPF Function\n         ST    R15,@K_ISPF_Parms        Save it\n         LA    R15,=CL8'HDG0'           Point to variable name\n         ST    R15,@K_ISPF_Parms+4      Save it\n         L     R15,@_VolTbl_Ptr         A(Volume Table)\n         LA    R15,VolTbl_Ent-VolTbl(R15) Point to first heading\n         LA    R15,VolTbl_Ent_Display-VolTbl_Ent(R15) Readable data\n         ST    R15,@K_ISPF_Parms+8      Save it\n         LA    R15,=CL8'CHAR'           Character variables\n         ST    R15,@K_ISPF_Parms+12     Save it\n         LHI   R15,VolTbl_Ent_Display_Len Get max display len\n         ST    R15,@K_DBLWD             Save it\n         LA    R15,@K_DBLWD             A(record length)\n         ST    R15,@K_ISPF_Parms+16     Save it\n         OI    @K_ISPF_Parms+16,X'80'   Flag end of list\n         LA    R1,@K_ISPF_Parms         A(Parmlist)\n         L     R15,@_ISPLINK            A(ISPF Interface)\n         BASR  R14,R15                  Go do it\n\n*---------------------------------------------------------------------*\n*   ... and count the number of heading lines in the table.           *\n*---------------------------------------------------------------------*\n         LA    R14,0                    Nbr hdg lines in VolTbl\n         LA    R15,0                    Nbr hdg lines in ISPF area\n\n         L     R9,@_VolTbl_Ptr          A(Volume Table)\n         L     R10,VolTbl_Hdr_Count-VolTbl_Hdr(R9) Get nbr entries\n         AHI   R9,VolTbl_Ent-VolTbl     Point to first entry\n         USING VolTbl_Ent,R9            and assign a base\nK00020   DS    0H\n         TM    VolTbl_Ent_Heading_Line1,L'VolTbl_Ent_Heading_Line1\n         JO    K00030                   Yes, skip\n         TM    VolTbl_Ent_Heading_Line,L'VolTbl_Ent_Heading_Line\n         JNO   K00040                   Not a hdg line, all done\n         AHI   R15,1                    Bump hdgs in ISPF area\nK00030   DS    0H\n         AHI   R14,1                    Bump hdgs in VolTbl\n\n         AHI   R9,VolTbl_Ent_Len        A(Next entry)\n         BRCT  R10,K00020               and continue\n\n         DROP  R9                       Free VolTbl_Ent base\nK00040   DS    0H\n         C     R15,@K_ISPF_Dyn_Area_Depth Is Dyn Area deep enough?\n         JNL   K80010                   No, use BRIF instead\n\n         ST    R15,@K_ISPF_Dyn_Area_Hdg_Lines Save it\n         ST    R14,@K_VolTbl_Hdg_Lines  Save nbr hdgs in VolTbl\n\n         L     R15,@K_VolTbl_Ent_Display_Line_Max Get max display line\n         S     R15,@K_ISPF_Dyn_Area_Hdg_Lines Adjust for heading lines\n         ST    R15,@K_VolTbl_Ent_Display_Line_Max Save it\n\nK00050   DS    0H\n*---------------------------------------------------------------------*\n*    VDEFINE FLIN, used in the 'Line x' display                       *\n*---------------------------------------------------------------------*\n         LA    R15,=CL8'VDEFINE'        ISPF Function\n         ST    R15,@K_ISPF_Parms        Save it\n         LA    R15,=CL8'FLIN'           Variable name (Curr line nbr)\n         ST    R15,@K_ISPF_Parms+4      Save it\n         LA    R15,@K_FLIN              Point to it\n         ST    R15,@K_ISPF_Parms+8      Save it\n         LA    R15,=CL8'CHAR'           Character data\n         ST    R15,@K_ISPF_Parms+12     Save it\n         LA    R15,L'@K_FLIN            Length of variable\n         ST    R15,@K_ISPF_Parms+20     Save it\n         LA    R15,@K_ISPF_Parms+20     Point to it\n         ST    R15,@K_ISPF_Parms+16     Save it\n         OI    @K_ISPF_Parms+16,X'80'   Flag end of list\n         LA    R1,@K_ISPF_Parms         A(Parmlist)\n         L     R15,@_ISPLINK            A(ISPF Interface)\n         BASR  R14,R15                  Go do it\n\nK00060   DS    0H\n*---------------------------------------------------------------------*\n*         Populate the table.                                         *\n*                                                                     *\n*     Verify that the display line and offset are within our limits.  *\n*    Note that @K_VolTbl_Ent_Display_Line is relative to the 1st      *\n*    non-heading line in VolTbl.                                      *\n*    If they aren't, adjust them.                                     *\n*---------------------------------------------------------------------*\n         ICM   R15,B'1111',@K_VolTbl_Ent_Display_Line Get line nbr\n         JNM   K00070                       0 or greater, OK\n         LA    R15,0                        Fix it\nK00070   DS    0H\n         C     R15,@K_VolTbl_Ent_Display_Line_Max Too big?\n         JNH   K00080                       No, OK\n         L     R15,@K_VolTbl_Ent_Display_Line_Max Yes, reset it\nK00080   DS    0H\n         ST    R15,@K_VolTbl_Ent_Display_Line Save it\n\n         L     R15,@K_VolTbl_Ent_Offset     Get offset\n         C     R15,=AL4(VolTbl_Ent_DevType-VolTbl_Ent_Display) small?\n         JNL   K00090                       No, OK\n         L     R15,=AL4(VolTbl_Ent_DevType-VolTbl_Ent_Display)\nK00090   DS    0H\n         C     R15,@K_VolTbl_Ent_Offset_Max Too big?\n         JNH   K00100                   No, OK\n         L     R15,@K_VolTbl_Ent_Offset_Max Yes, reset it\nK00100   DS    0H\n         ST    R15,@K_VolTbl_Ent_Offset Save it\n\n*---------------------------------------------------------------------*\n*     If the display line and the offset have not changed, we can     *\n*    just redisplay                                                   *\n*---------------------------------------------------------------------*\n         CLC   @K_VolTbl_Ent_Display_Line_Prev,@K_VolTbl_Ent_Display_Li+\n               ne\n         JNE   K00110                   Display line changed\n         CLC   @K_VolTbl_Ent_Offset_Prev,@K_VolTbl_Ent_Offset\n         JE    K00260                   Nothing changed, skip\n\nK00110   DS    0H\n*---------------------------------------------------------------------*\n*     If we need to re-generate the headings (because of a LEFT/RIGHT *\n*    scroll), do it now                                               *\n*---------------------------------------------------------------------*\n         TM    @_No_Headings,L'@_No_Headings  Are we doing headings?\n         JO    K00140                   No, skip\n         L     R15,@K_VolTbl_Ent_Offset Yes, get offset\n         C     R15,@K_VolTbl_Ent_Offset_Prev Same as last time?\n         JE    K00140                   Yes, skip\n\n         L     R3,@K_ISPF_Dyn_Area_Ptr  A(data for dynamic area)\n\n         L     R9,@_VolTbl_Ptr          A(Volume Table)\n         L     R10,VolTbl_Hdr_Count-VolTbl_Hdr(R9) Get nbr entries\n         AHI   R9,VolTbl_Ent-VolTbl     Point to first entry\n         USING VolTbl_Ent,R9            and assign a base\n\nK00120   DS    0H\n         TM    VolTbl_Ent_Heading_Line1,L'VolTbl_Ent_Heading_Line1\n         JO    K00130                   Heading 0, skip\n         TM    VolTbl_Ent_Heading_Line,L'VolTbl_Ent_Heading_Line\n         JZ    K00140                   Not a heading line, skip\n\n         MVC   0(VolTbl_Ent_DevType-VolTbl_Ent_Display,R3),VolTbl_Ent_D+\n               isplay\n         LA    R1,VolTbl_Ent_DevType-VolTbl_Ent_Display(0,R3)\n         LA    R15,VolTbl_Ent_Display   A(Start of source)\n         A     R15,@K_VolTbl_Ent_Offset A(Start of our data)\n         L     R14,@K_VolTbl_Ent_MVC_Len EX len of data to be moved\n         EX    R14,K_MVC                Move the data\n         A     R3,@K_ISPF_Dyn_Area_Width A(Next output area pointer)\n\nK00130   DS    0H\n         AHI   R9,VolTbl_Ent_Len        A(Next entry)\n         BRCT  R10,K00120               and continue\n\nK00140   DS    0H\n*--------------------------------------------------------------------*\n*     Calculate the address of the 1st line of data in the dynamic   *\n*    area                                                            *\n*--------------------------------------------------------------------*\n         L     R15,@K_ISPF_Dyn_Area_Hdg_Lines Nbr heading lines\n         M     R14,@K_ISPF_Dyn_Area_Width times length of line\n         A     R15,@K_ISPF_Dyn_Area_Ptr Point to  it\n         LR    R3,R15                   with the proper register\n\n*--------------------------------------------------------------------*\n*     If we are at the top of the table, insert our 'Top of Data'    *\n*    line.                                                           *\n*--------------------------------------------------------------------*\n         ICM   R15,B'1111',@K_VolTbl_Ent_Display_Line Curr display line\n         JNZ   K00150                   Not at top, skip\n\n         MVI   0(R3),C'*'               A line of asterisks\n         LR    R15,R3                   Point to it\n         LA    R1,1(0,R3)               A(Target area\n         L     R14,@K_ISPF_Dyn_Area_Width Get width\n         AHI   R14,2                    EX Length\n         EX    R14,K_MVC                All asterisks\n\n         L     R14,@K_ISPF_Dyn_Area_Width Get width\n         LA    R15,13                   Length of literal\n         SR    R14,R15                  Center our\n         SRL   R14,1                     message\n         LA    R1,0(R3,R14)             Point to start\n         S     R1,=FL4'1'                of output area\n         LA    R14,13                   Length of literal\n         AHI   R14,-1                   EX length\n         LA    R15,=CL13' Top of data ' A(Literal)\n         EX    R14,K_MVC                Move top of data text\n\n         A     R3,@K_ISPF_Dyn_Area_Width Bump output pointer\n         L     R15,@K_ISPF_Dyn_Area_Ptr Calculate\n         A     R15,@K_ISPF_Dyn_Area_Len  Dyn area max\n         CR    R3,R15                   Filled it up?\n         JNL   K00260                  Yes, go display\n\nK00150   DS    0H\n*--------------------------------------------------------------------*\n*     Point to the 1st VolTbl_Ent line to be output ...              *\n*--------------------------------------------------------------------*\n         ICM   R4,B'1111',@K_VolTbl_Ent_Display_Line Get line number\n         L     R5,=FL4'-1'              Clear entry counter\n\n         L     R15,@K_VolTbl_Hdg_Lines   Nbr hdg lines in VolTbl\n         MHI   R15,VolTbl_Ent_Len        * length of 1 entry\n\n         L     R9,@_VolTbl_Ptr          A(Volume Table)\n         L     R10,VolTbl_Hdr_Count-VolTbl_Hdr(R9) Get nbr entries\n         AHI   R9,VolTbl_Ent-VolTbl     Point to first entry\n         AR    R9,R15                   Point to our entry\n         S     R10,@K_VolTbl_Hdg_Lines  Nbr lines left in table\n         JNP   K00250                   None, skip\n\nK00170   DS    0H\n*--------------------------------------------------------------------*\n*     Find the entry (we count in R5) that corresponds to the        *\n*    entry we want (in R4)                                           *\n*--------------------------------------------------------------------*\n         TM    VolTbl_Ent_Detail_Line,L'VolTbl_Ent_Detail_Line Detail?\n         JNO   K00180                   No, skip\n         TM    @_No_Details,L'@_No_Details Yes, do we want it?\n         JO    K00240                   No, skip it\n         J     K00200                   Yes, process it\nK00180   DS    0H\n\n         TM    VolTbl_Ent_Total_Line,L'VolTbl_Ent_Total_Line Detail?\n         JNO   K00190                   No, skip\n         TM    @_No_Totals,L'@_No_Totals Yes, do we want it?\n         JO    K00240                   No, skip it\n         J     K00200                   Yes, process it\nK00190   DS    0H\n         TM    @_Statistics,L'@_Statistics Do we want stats?\n         JNO   K00240                   No, skip it\n\n         LA    R15,VolTbl_Ent           A(Table entry)\n         ST    R15,@K_Parms_V00010      Save it\n\n         LA    R1,@K_Parms              A(Parm list)\n         BRAS  R14,V00010               Go process stats line\nK00200   DS    0H\n         AHI   R5,1                     Bump counter\n         CR    R4,R5                    Ours?\n         JH    K00240                   Not yet, skip\n         TM    VolTbl_Ent_ECB,X'40'     Is it populated?\n         JO    K00210                   Yes, OK\n         WAIT  ECB=VolTbl_Ent_ECB       No, WAIT for it\n\nK00210 DS     0H\n*--------------------------------------------------------------------*\n*     Move the VolTbl_Ent data to the dynamic display area.          *\n*--------------------------------------------------------------------*\n         TM    VolTbl_Ent_Stats_Line,L'VolTbl_Ent_Stats_Line Stats?\n         JNO   K00220                   No, OK\n\n         LR    R1,R3                    A(Target area)\n         LA    R15,VolTbl_Ent_Display   A(Source)\n         S     R15,=AL4(VolTbl_Ent_DevType-VolTbl_Ent_Display)\n         A     R15,@K_VolTbl_Ent_Offset Plus offset\n         L     R14,@K_ISPF_Dyn_Area_Width Get length to move\n         AHI   R14,-1                   EX length\n         EX    R14,K_MVC                Move the data\n         J     K00230                   and skip\n\nK00220   DS    0H\n         MVC   0(VolTbl_Ent_DevType-VolTbl_Ent_Display,R3),VolTbl_Ent_D+\n               isplay\n         LA    R1,VolTbl_Ent_DevType-VolTbl_Ent_Display(0,R3) A(Target)\n         LA    R15,VolTbl_Ent_Display   A(Start of source)\n         A     R15,@K_VolTbl_Ent_Offset A(Start of our data)\n         L     R14,@K_VolTbl_Ent_MVC_Len EX len of data to be moved\n         EX    R14,K_MVC                Move the data\n\nK00230   DS    0H\n*--------------------------------------------------------------------*\n*     Bump the output pointer, and, if there is still room, ...      *\n*--------------------------------------------------------------------*\n         A     R3,@K_ISPF_Dyn_Area_Width Bump output pointer\n         L     R15,@K_ISPF_Dyn_Area_Ptr Calculate\n         A     R15,@K_ISPF_Dyn_Area_Len  Dyn area max\n         CR    R3,R15                   Filled it up?\n         JNL   K00260                  Yes, go display\n\nK00240   DS    0H\n*--------------------------------------------------------------------*\n*     ... process the next entry                                     *\n*--------------------------------------------------------------------*\n         AHI   R9,VolTbl_Ent_Len        A(Next entry)\n         BRCT  R10,K00170               and continue\n\nK00250   DS    0H\n*--------------------------------------------------------------------*\n*     Add our 'Bottom of data' line.                                 *\n*--------------------------------------------------------------------*\n         MVI   0(R3),C'*'               A line of asterisks\n         LR    R15,R3                   Point to it\n         LA    R1,1(0,R3)               A(Target area\n         L     R14,@K_ISPF_Dyn_Area_Width Get width\n         AHI   R14,-2                   EX len\n         EX    R14,K_MVC                All asterisks\n\n         L     R14,@K_ISPF_Dyn_Area_Width Get width\n         LA    R15,16                   Length of literal\n         SR    R14,R15                  Center our\n         SRL   R14,1                     message\n         LA    R1,0(R3,R14)             Point to start\n         S     R1,=FL4'1'                of output area\n         LA    R14,16                   Length of literal\n         AHI   R14,-1                   EX length\n         LA    R15,=CL16' Bottom of data ' A(Literal)\n         EX    R14,K_MVC                Move bottom of data text\n\n*--------------------------------------------------------------------*\n*     And clear out the rest of the display area                     *\n*--------------------------------------------------------------------*\n         A     R3,@K_ISPF_Dyn_Area_Width Bump output pointer\n         L     R15,@K_ISPF_Dyn_Area_Ptr Calculate\n         A     R15,@K_ISPF_Dyn_Area_Len  Dyn area max\n         CR    R3,R15                   Filled it up?\n         JNL   K00260                  Yes, go display\n\n         LR    R0,R3                    No, A(Start of area to clear)\n         LR    R1,R15                   Calculate length\n         SR    R1,R0                     to clear\n         LA    R14,0                    No sending address\n         LA    R15,C' '                 Pad character\n         SLL   R15,24                    of blank\n         MVCL  R0,R14                   Clear remainder if dynamic area\n\nK00260   DS    0H\n*--------------------------------------------------------------------*\n*     Save the current start line and offset ...                     *\n*--------------------------------------------------------------------*\n         MVC   @K_VolTbl_Ent_Display_Line_Prev,@K_VolTbl_Ent_Display_Li+\n               ne\n         MVC   @K_VolTbl_Ent_Offset_Prev,@K_VolTbl_Ent_Offset\n\n*--------------------------------------------------------------------*\n*     ... fill in the variable containing the 1st line number ...    *\n*--------------------------------------------------------------------*\n         L     R15,@K_VolTbl_Ent_Display_Line Get FLIN\n         AHI   R15,1                    Relative to 1\n         CVD   R15,@K_DBLWD             Pack it\n         MVC   @K_FLIN-1(L'@K_FLIN+1),=X'402020202120'  Move mask\n         ED    @K_FLIN-1(L'@K_FLIN+1),@K_DBLWD+5\n\n*--------------------------------------------------------------------*\n*     ... and display our panel                                      *\n*--------------------------------------------------------------------*\n         LA    R15,=CL8'DISPLAY'        ISPF Function\n         ST    R15,@K_ISPF_Parms        Save it\n         LA    R15,=CL8'&PNLNAME'       A(Panel name)\n         ST    R15,@K_ISPF_Parms+4      Save it\n         OI    @K_ISPF_Parms+4,X'80'    Flag last parm\n         LA    R1,@K_ISPF_Parms         A(ISPF Parms)\n         L     R15,@_ISPLINK            A(ISPF routine)\n         BASR  R14,R15                  Go display table\n         CHI   R15,8                    END or RETURN?\n         JNL   K00720                   Yes, just get out\n\n*--------------------------------------------------------------------*\n*     If the user entered CANCEL, we are done.                       *\n*--------------------------------------------------------------------*\n         LA    R15,=CL8'VCOPY'          ISPF Function\n         ST    R15,@K_ISPF_Parms        Save it\n         LA    R15,=CL8'ZCMD'           Variable we want\n         ST    R15,@K_ISPF_Parms+4      Save it\n         LA    R15,@K_ISPF_VCOPY_Lens   A(Length Address)\n         ST    R15,@K_ISPF_Parms+8      Save it\n         LA    R15,@K_ISPF_VCOPY_Ptrs   A(Variable)\n         ST    R15,@K_ISPF_Parms+12     Save it\n         OI    @K_ISPF_Parms+12,X'80'   Flag last parm\n         LA    R1,@K_ISPF_Parms         A(ISPF Parms)\n         L     R15,@_ISPLINK            A(ISPF routine)\n         BASR  R14,R15                  Go get the variable\n\n         LTR   R15,R15                  Did we get it?\n         JNZ   K00300                   No, skip check for CANCEL\n\n         ICM   R14,B'1111',@K_ISPF_VCOPY_Var_Len Get ZCMD length\n         JZ    K00300                   Nothing, skip\n         CHI   R14,3                    Could it be CANcel?\n         JL    K00270                   No, skip\n         CHI   R14,6                    Maybe, check again\n         JH    K00270                   Not CANCEL, skip\n         ICM   R15,B'1111',@K_ISPF_VCOPY_Var_Ptr A(ZCMD)\n         JZ    K00300                   Nothing, skip\n         LA    R1,@K_DBLWD              A(Work area)\n         AHI   R14,-1                   EX Len\n         EX    R14,K_MVC                Move to work area\n         OC    @K_DBLWD,=CL8' '         Uppercase it\n         EX    R14,K_CLC1               Check it out\n         JE    K00720                   CANCEL, just exit\n\nK00270   DS    0H\n*--------------------------------------------------------------------*\n*     Check out what happened. First check the command for something *\n*    we recognize ...                                                *\n*--------------------------------------------------------------------*\n         LA    R1,@K_Parms              A(Parm list)\n         BRAS  R14,L00010               Check out command\n\n         TM    @_ReDisplay,L'@_ReDisplay Change display mode?\n         JO    K00280                   Yes, skip\n         LTR   R15,R15                  No, did it work?\n         JNZ   K00700                   No, unknown command\n         J     K00290                   Unknown command, skip\n\nK00280   DS    0H\n         LA    R15,=CL8'VDEFINE'        ISPF Function\n         ST    R15,@K_ISPF_Parms        Save it\n         LA    R15,=CL8'ZCMD'           Variable name\n         ST    R15,@K_ISPF_Parms+4      Save it\n         LA    R15,K_Blanks             A(blank string)\n         ST    R15,@K_ISPF_Parms+8      Save it\n         LA    R15,=CL8'CHAR'           Character variables\n         ST    R15,@K_ISPF_Parms+12     Save it\n         LA    R15,=AL4(L'K_Blanks)     Length of blank string\n         ST    R15,@K_ISPF_Parms+16     Save it\n         OI    @K_ISPF_Parms+16,X'80'   Flag end of list\n         LA    R1,@K_ISPF_Parms         A(Parmlist)\n         L     R15,@_ISPLINK            A(ISPF Interface)\n         BASR  R14,R15                  Go do it\n\n         LA    R15,=CL8'VPUT'           ISPF Function\n         ST    R15,@K_ISPF_Parms        Save it\n         LA    R15,=CL8'ZCMD'           A(Variable name)\n         ST    R15,@K_ISPF_Parms+4      Save it\n         LA    R15,=CL8'ASIS'           A(Variable name)\n         ST    R15,@K_ISPF_Parms+8      Save it\n         OI    @K_ISPF_Parms+8,X'80'    Flag end of list\n         LA    R1,@K_ISPF_Parms         A(Parmlist)\n         L     R15,@_ISPLINK            A(ISPF Interface)\n         BASR  R14,R15                  Go do it\n\n         LHI   R15,20                   Change display mode, set rc\n         J     K90010                   and exit\n\nK00290   DS    0H\n*--------------------------------------------------------------------*\n*     We have processed the command, so clear ZCMD ...               *\n*--------------------------------------------------------------------*\n         LA    R15,=CL8'VREPLACE'       ISPF Function\n         ST    R15,@K_ISPF_Parms        Save it\n         LA    R15,=CL8'ZCMD'           Variable name\n         ST    R15,@K_ISPF_Parms+4      Save it\n         LA    R15,=AL4(0)              Length of variable\n         ST    R15,@K_ISPF_Parms+8      Save it\n         LA    R15,0                    Null value\n         ST    R15,@K_ISPF_Parms+12     Save it\n         OI    @K_ISPF_Parms+12,X'80'   Flag end of list\n         LA    R1,@K_ISPF_Parms         A(Parmlist)\n         L     R15,@_ISPLINK            A(ISPF Interface)\n         BASR  R14,R15                  Go do it\n\n*--------------------------------------------------------------------*\n*     ... and force a refresh of the table display area.             *\n*--------------------------------------------------------------------*\n         MVC   @K_VolTbl_Ent_Display_Line_Prev,=FL4'-1' Force tbl refr\n\nK00300   DS    0H\n*--------------------------------------------------------------------*\n*     Check for scroll request:                                      *\n*       ZVERB    = UP, DOWN, LEFT, or RIGHT                          *\n*       ZSCROLLN = scroll amount                                     *\n*       ZSCROLLA = PAGE, CSR, MAX, etc.                              *\n*--------------------------------------------------------------------*\n         LA    R15,=CL8'VCOPY'          ISPF Function\n         ST    R15,@K_ISPF_Parms        Save it\n         LA    R15,K_ISPF_VCOPY_Scroll_Names   A(Variable Names)\n         ST    R15,@K_ISPF_Parms+4      Save it\n         LA    R15,@K_ISPF_VCOPY_Scroll_Lens   A(Lengths)\n         ST    R15,@K_ISPF_Parms+8      Save it\n         LA    R15,@K_ISPF_VCOPY_Scroll_Ptrs   A(Addresses)\n         ST    R15,@K_ISPF_Parms+12     Save it\n         OI    @K_ISPF_Parms+12,X'80'   Flag last parm\n         LA    R1,@K_ISPF_Parms         A(ISPF Parms)\n         L     R15,@_ISPLINK            A(ISPF routine)\n         BASR  R14,R15                  Go get variables\n\n         CHI   R15,8                    Did we get any?\n         JH    K00710                   No, just re-display\n\n         NI    @K_Scroll_UP,X'FF'-L'@K_Scroll_UP  Off our flag\n         NI    @K_Scroll_DOWN,X'FF'-L'@K_Scroll_DOWN  Off our flag\n         NI    @K_Scroll_LEFT,X'FF'-L'@K_Scroll_LEFT  Off our flag\n         NI    @K_Scroll_RIGHT,X'FF'-L'@K_Scroll_RIGHT  Off our flag\n         NI    @K_Scroll_MAX,X'FF'-L'@K_Scroll_MAX  Off our flag\n\n         ICM   R14,B'1111',@K_ISPF_VCOPY_ZVERB_Len Len of ZVERB\n         JZ    K00500                   Nothing, go check expand\n         ICM   R15,B'1111',@K_ISPF_VCOPY_ZVERB_Ptr A(ZVERB)\n         JZ    K00500                   Nothing, check expand\n\n         CHI   R14,2                    Could it be UP?\n         JNE   K00310                   No, skip\n         CLC   =C'UP',0(R15)            Could be, is it?\n         JNE   K00710                   No, ignore it\n         OI    @K_Scroll_UP,L'@K_Scroll_UP  Yes, say so\n         J     K00340                   and check ZSCROLLN\nK00310   DS    0H\n\n         CHI   R14,4                    Could it be DOWN or LEFT?\n         JNE   K00330                   No, skip\n         CLC   =C'DOWN',0(R15)          Could be, is it DOWN?\n         JNE   K00320                   No, go check LEFT\n         OI    @K_Scroll_DOWN,L'@K_Scroll_DOWN  Yes, say so\n         J     K00340                   and check ZSCROLLN\nK00320   DS    0H\n         CLC   =C'LEFT',0(R15)          Is it LEFT?\n         JNE   K00710                   No, ignore it\n         OI    @K_Scroll_LEFT,L'@K_Scroll_LEFT  Yes, say so\n         J     K00340                   and check ZSCROLLN\nK00330   DS    0H\n         CHI   R14,5                    Could it be RIGHT?\n         JNE   K00710                   No, ignore it\n         CLC   =C'RIGHT',0(R15)         Could be, is it?\n         JNE   K00710                   No, ignore it\n         OI    @K_Scroll_RIGHT,L'@K_Scroll_RIGHT  Yes, say so\n         J     K00340                   and check ZSCROLLN\n\nK00340   DS    0H\n*--------------------------------------------------------------------*\n*     We have a scroll command, check ZSCROLLA for MAX               *\n*--------------------------------------------------------------------*\n         ICM   R14,B'1111',@K_ISPF_VCOPY_ZSCROLLA_Len Len of ZSCROLLA\n         JZ    K00350                   Nothing, check ZSCROLLN\n         CHI   R14,3                    Could it be MAX?\n         JNE   K00350                   No, check ZSCROLLN\n         ICM   R1,B'1111',@K_ISPF_VCOPY_ZSCROLLA_Ptr A(ZSCROLLA)\n         JZ    K00350                   Nothing, check ZSCROLLN\n         CLC   =C'MAX',0(R1)            Is it MAX?\n         JNE   K00350                   No, skip\n         OI    @K_Scroll_MAX,L'@K_Scroll_MAX Yes, set our flag\n\nK00350   DS    0H\n*--------------------------------------------------------------------*\n*     Set a flag if the user entered an explicit scroll amount       *\n*    (eg, DOWN 16). We can determine this if ZSCROLLN = ZSCROLLA     *\n*--------------------------------------------------------------------*\n         NI    @K_Scroll_Explicit,X'FF'-L'@K_Scroll_Explicit\n         ICM   R15,B'1111',@K_ISPF_VCOPY_ZSCROLLN_Len ZSCROLLN Length\n         JZ    K00360                   Nothing, skip\n         C     R15,@K_ISPF_VCOPY_ZSCROLLA_Len Same as ZSCROLLA?\n         JNE   K00360                   No, skip\n         ICM   R14,B'1111',@K_ISPF_VCOPY_ZSCROLLN_Ptr Yes, A(ZSCROLLN)\n         JZ    K00360                   Nothing, skip\n         ICM   R1,B'1111',@K_ISPF_VCOPY_ZSCROLLA_Ptr A(ZSCROLLA)\n         JZ    K00360                   Nothing, skip\n         AHI   R15,-1                   EX length\n         EX    R15,K_CLC                Same value?\n         JNE   K00360                   No, skip\n         OI    @K_Scroll_Explicit,L'@K_Scroll_Explicit Yes, set flag\n\nK00360   DS    0H\n*--------------------------------------------------------------------*\n*     Get ZSCROLLN (defaulting to 0 )                                *\n*--------------------------------------------------------------------*\n         LA    R15,0                    Set our default\n\n         ICM   R14,B'1111',@K_ISPF_VCOPY_ZSCROLLN_Len Len of ZSCROLLN\n         JZ    K00370                   Nothing, just re-display\n         ICM   R1,B'1111',@K_ISPF_VCOPY_ZSCROLLN_Ptr A(ZSCROLLN)\n         JZ    K00370                   Nothing, ignore it\n         AHI   R14,-1                   EX len\n         EX    R14,K_PACK               Pack it\n         CVB   R15,@K_DBLWD             Binarize it\n\nK00370   DS    0H\n         TM    @K_Scroll_RIGHT,L'@K_Scroll_RIGHT  Horizontal?\n         JO    K00430                   Yes, skip\n         TM    @K_Scroll_LEFT,L'@K_Scroll_LEFT No, check again\n         JO    K00460                   Yes, skip\n         TM    @K_Scroll_DOWN,L'@K_Scroll_DOWN No, scroll DOWN?\n         JO    K00390                   Yes, skip\n\n*--------------------------------------------------------------------*\n*     Scroll UP                                                      *\n*--------------------------------------------------------------------*\n         TM    @K_Scroll_MAX,L'@K_Scroll_MAX  UP MAX?\n         JO    K00380                   Yes, set to top\n         L     R14,@K_VolTbl_Ent_Display_Line Get current line number\n         SR    R14,R15                  Back up the scroll amount\n         TM    @K_Scroll_Explicit,L'@K_Scroll_Explicit Explicit nbr?\n         JO    K00420                   Yes, all done\n*        A     R14,@K_ISPF_Dyn_Area_Hdg_Lines No, adjust for headings\n         J     K00420                   and skip\nK00380   DS    0H\n         LA    R14,0                    UP MAX, reset line number\n         J     K00420                   and skip\n\nK00390   DS    0H\n*--------------------------------------------------------------------*\n*     Scroll DOWN                                                    *\n*--------------------------------------------------------------------*\n         TM    @K_Scroll_MAX,L'@K_Scroll_MAX  DOWN MAX?\n         JO    K00400                   Yes, skip\n         ICM   R14,B'1111',@K_VolTbl_Ent_Display_Line No, curr line nbr\n         JP    K00390C                  OK, skip\n         AHI   R14,-1                   Account for Top of Data line\nK00390C  DS    0H\n         AR    R14,R15                  Line number\n         TM    @K_Scroll_Explicit,L'@K_Scroll_Explicit Explicit nbr?\n         JO    K00420                   Yes, all done\n         S     R14,@K_ISPF_Dyn_Area_Hdg_Lines No, adjust for headings\n         J     K00420                   and skip\n\nK00400   DS    0H\n*--------------------------------------------------------------------*\n*     Scroll DOWN MAX - get the last visible line, and use it        *\n*    instead of @K_ISPF_Dyn_Area_Depth                               *\n*--------------------------------------------------------------------*\n         LA    R15,=CL8'VCOPY'          ISPF Function\n         ST    R15,@K_ISPF_Parms        Save it\n         LA    R15,=CL8'SSCSPCLV'       A(Variable Names)\n         ST    R15,@K_ISPF_Parms+4      Save it\n         LA    R15,@K_ISPF_VCOPY_Lens   A(Lengths)\n         ST    R15,@K_ISPF_Parms+8      Save it\n         LA    R15,@K_ISPF_VCOPY_Ptrs   A(Addresses)\n         ST    R15,@K_ISPF_Parms+12     Save it\n         OI    @K_ISPF_Parms+12,X'80'   Flag last parm\n         LA    R1,@K_ISPF_Parms         A(ISPF Parms)\n         L     R15,@_ISPLINK            A(ISPF routine)\n         BASR  R14,R15                  Go display table\n\n         L     R0,@K_ISPF_Dyn_Area_Depth Init our depth\n         LTR   R15,R15                  Did it work?\n         JNZ   K00410                   No, skip\n\n         ICM   R14,B'1111',@K_ISPF_VCOPY_Var_Len Len of SSCSPCLV\n         JZ    K00410                   Nothing, skip\n         ICM   R1,B'1111',@K_ISPF_VCOPY_Var_Ptr A(SSCSPCLV)\n         JZ    K00410                   Nothing, ignore it\n         AHI   R14,-1                   EX len\n         EX    R14,K_PACK               Pack it\n         CVB   R0,@K_DBLWD              Binarize it\nK00410   DS    0H\n         L     R14,@K_VolTbl_Ent_Display_Line_Max Get max display line\n         SR    R14,R0                   Back up a screen\n         A     R14,@K_ISPF_Dyn_Area_Hdg_Lines Adjust for heading lines\n         AHI   R14,1                    Make Bottom of Data visible\n         J     K00420                   and skip\n\nK00420   DS    0H\n*--------------------------------------------------------------------*\n*     Vertical Scroll, save updated line number, and skip            *\n*--------------------------------------------------------------------*\n         ST    R14,@K_VolTbl_Ent_Display_Line Save new line number\n         J     K00710                   Go re-display\n\nK00430   DS    0H\n*--------------------------------------------------------------------*\n*     Scroll RIGHT                                                   *\n*--------------------------------------------------------------------*\n         TM    @K_Scroll_Max,L'@K_Scroll_Max  RIGHT MAX?\n         JNO   K00440                   No, skip\n         L     R14,@K_VolTbl_Ent_Offset_Max Yes, get max offset\n         J     K00490                   and skip\nK00440   DS    0H\n         TM    @K_Scroll_Explicit,L'@K_Scroll_Explicit Explicit nbr?\n         JO    K00450                   Yes, skip\n         S     R15,=AL4(VolTbl_Ent_DevType-VolTbl_Ent_Display) Adj scrl\n         JP    K00450                   OK, skip\n         L     R15,@K_ISPF_Dyn_Area_Width cursor in non-scroll area,\n         S     R15,=AL4(VolTbl_Ent_DevType-VolTbl_Ent_Display) Width\nK00450   DS    0H\n         L     R14,@K_VolTbl_Ent_Offset Get current offset\n         AR    R14,R15                  Adjust offset\n         J     K00490                   and skip\n\nK00460   DS    0H\n*--------------------------------------------------------------------*\n*     Scroll LEFT                                                    *\n*--------------------------------------------------------------------*\n         TM    @K_Scroll_Max,L'@K_Scroll_Max  LEFT MAX?\n         JO    K00480                   Yes, skip\n\n         TM    @K_Scroll_Explicit,L'@K_Scroll_Explicit Explicit nbr?\n         JO    K00470                   Yes, skip\n         L     R0,@K_ISPF_Dyn_Area_Width Get width of\n         S     R0,=AL4(VolTbl_Ent_DevType-VolTbl_Ent_Display) scrl area\n         CR    R15,R0                   Too far left?\n         JNH   K00470                   No, OK\n         LR    R15,R0                   Yes, set to 1 screens worth\nK00470   DS    0H\n         L     R14,@K_VolTbl_Ent_Offset Get current offset\n         SR    R14,R15                  Adjust it\n         J     K00490                   and skip\nK00480   DS    0H\n         L     R14,=AL4(VolTbl_Ent_DevType-VolTbl_Ent_Display) Set min\n\nK00490   DS    0H\n*--------------------------------------------------------------------*\n*     Horizontal scroll - save new offset                            *\n*--------------------------------------------------------------------*\n         ST    R14,@K_VolTbl_Ent_Offset Yes, save new offset\n         J     K00710                   and redisplay\n\nK00500   DS    0H\n*--------------------------------------------------------------------*\n*     Not a scroll command -  see if the cursor is in the DATA       *\n*    field, and on a numeric field. If so, the value of the field is *\n*    displayed. This will allow the user to see the actual values    *\n*    for fields we have scaled to fit in our display.                *\n*                                                                    *\n*    Get ZSCREENW (screen width)                                     *\n*        ZSCREENC (cursor position ((row# * ZSCREENW) + col#)))      *\n*--------------------------------------------------------------------*\n         LA    R15,=CL8'VCOPY'          ISPF Function\n         ST    R15,@K_ISPF_Parms        Save it\n         LA    R15,K_ISPF_VCOPY_Cursor_Names   A(Variable Names)\n         ST    R15,@K_ISPF_Parms+4      Save it\n         LA    R15,@K_ISPF_VCOPY_Cursor_Lens   A(Lengths)\n         ST    R15,@K_ISPF_Parms+8      Save it\n         LA    R15,@K_ISPF_VCOPY_Cursor_Ptrs   A(Addresses)\n         ST    R15,@K_ISPF_Parms+12     Save it\n         OI    @K_ISPF_Parms+12,X'80'   Flag last parm\n         LA    R1,@K_ISPF_Parms         A(ISPF Parms)\n         L     R15,@_ISPLINK            A(ISPF routine)\n         BASR  R14,R15                  Go get variables\n\n         LTR   R15,R15                  Did we?\n         JNZ   K00710                   No, just re-display\n\n*--------------------------------------------------------------------*\n*     Get the cursor row and column (on the screen) ...              *\n*--------------------------------------------------------------------*\n         ICM   R15,B'1111',@K_ISPF_ZSCREENC_Len Get ZSCREENC length\n         JNP   K00710                   Nothing, just re-display\n         AHI   R15,-1                   EX length\n         ICM   R1,B'1111',@K_ISPF_ZSCREENC_Ptr Get A(ZSCREENC)\n         JZ    K00710                   Nothing, just re-display\n         EX    R15,K_PACK               PACK it\n         CVB   R15,@K_DBLWD             Cursor position in screen\n\n         ICM   R14,B'1111',@K_ISPF_ZSCREENW_Len Get ZSCREENW length\n         JZ    K00710                   Nothing, just re-display\n         ICM   R1,B'1111',@K_ISPF_ZSCREENW_Ptr Get A(ZSCREENW)\n         JZ    K00710                   Nothing, just re-display\n         AHI   R14,-1                   EX length\n         EX    R14,K_PACK               PACK it\n         CVB   R1,@K_DBLWD              Screen width\n\n         LA    R14,0                    Clear high-order register\n         DR    R14,R1                   R14: Col, R15: Row\n\n*--------------------------------------------------------------------*\n*     ... and see if it is within the DATA field                     *\n*--------------------------------------------------------------------*\n         S     R15,@K_ISPF_Dyn_Area_Row  Relative row in DATA\n         JM    K00710                   Before start of DATA, exit\n         C     R15,@K_ISPF_Dyn_Area_Depth Really within DATA?\n         JNL   K00710                   No, just redisplay\n\n         S     R14,@K_ISPF_Dyn_Area_Column Relative column of DATA\n         JM    K00710                   To the left of DATA, exit\n         C     R0,@K_ISPF_Dyn_Area_Width Really within DATA?\n         JNL   K00710                   No, just redisplay\n\n         S     R15,@K_ISPF_Dyn_Area_Hdg_Lines minus heading lines\n         JM    K00710                   Cursor on a heading line\n         ICM   R4,B'1111',@K_VolTbl_Ent_Display_Line Get line number\n         JNZ   K00510                   Not 0, OK\n         AHI   R15,-1                   Adjust for 'Top of Data'\n         JM    K00710                   Cursor on 'Top of Data'\nK00510   DS    0H\n         AR    R4,R15                   R4 = Cursor row\n         L     R5,=FL4'-1'              Clear entry counter\n\n         L     R9,@_VolTbl_Ptr          A(Volume Table)\n         L     R10,VolTbl_Hdr_Count-VolTbl_Hdr(R9) Get nbr entries\n         AHI   R9,VolTbl_Ent-VolTbl     Point to first entry\n\nK00520   DS    0H\n*--------------------------------------------------------------------*\n*     Find the entry (we count in R5) that corresponds to the        *\n*    entry we want (in R4)                                           *\n*--------------------------------------------------------------------*\n         TM    VolTbl_Ent_Detail_Line,L'VolTbl_Ent_Detail_Line Detail?\n         JNO   K00530                   No, skip\n         TM    @_No_Details,L'@_No_Details Yes, do we want it?\n         JO    K00550                   No, skip it\n         J     K00540                   Yes, count it\nK00530   DS    0H\n         TM    VolTbl_Ent_Total_Line,L'VolTbl_Ent_Total_Line Total?\n         JNO   K00550                   No, skip it\n         TM    @_No_Totals,L'@_No_Totals Yes, do we want it?\n         JO    K00550                   No, skip it\nK00540   DS    0H\n         AHI   R5,1                     Bump counter\n         CR    R4,R5                    Ours?\n         JNH   K00560                   Yup, skip\nK00550   DS    0H\n         AHI   R9,VolTbl_Ent_Len        A(Next entry)\n         BRCT  R10,K00520               and continue\n         J     K00710                   Not on a row, ignore it\n\nK00560   DS    0H\n         TM    VolTbl_Ent_SMS_Line,L'VolTbl_Ent_SMS_Line Anomaly msg?\n         JO    K00710                   Yes, ignore it\n\n         TM    VolTbl_Ent_LSPACE_Fail,L'VolTbl_Ent_LSPACE_Fail Data?\n         JO    K00710                   No, ignore it\n\n*--------------------------------------------------------------------*\n*     It looks like the cursor is on a line in our table - see if    *\n*    it is also within a numeric field                               *\n*--------------------------------------------------------------------*\n         C     R14,=AL4(VolTbl_Ent_DevType-VolTbl_Ent_Display)\n         JL    K00710                   Cursor in line prefix\n\n         A     R14,@K_VolTbl_Ent_Offset  Get offset within VolTbl_Ent\n         S     R14,=AL4(VolTbl_Ent_DevType-VolTbl_Ent_Display)\n         LA    R15,K_Expand_Tbl         A(Table of offsets)\nK00570   DS    0H\n         CH    R14,0(0,R15)             Our field?\n         JL    K00580                   No, skip\n         CH    R14,2(0,R15)             Maybe, is it?\n         JNH   K00590                   Yes, skip\nK00580   DS    0H\n         AHI   R15,K_Expand_Ent_Len     Bump our pointer\n         CLC   =HL2'0',0(R15)           End of table?\n         JNE   K00570                   No, keep checking\n         J     K00710                   Yes, just redisplay\nK00590   DS    0H\n         LH    R14,4(0,R15)             Offset of FP field\n         LD    R2,VolTbl_Ent(R14)       Get floating point value\n*--------------------------------------------------------------------*\n*     If this is a percent (length of output area = 4), and thus the *\n*    only type of field with fractions) ...                          *\n*--------------------------------------------------------------------*\n         LH    R0,2(0,R15)              A(End of output field) + 1\n         SH    R0,0(0,R15)              Less A(Start of output field)\n         CHI   R0,4                     Is this a percent?\n         JNE   K00630                   No, skip\n\n*--------------------------------------------------------------------*\n*     ... format it                                                  *\n*--------------------------------------------------------------------*\n         MDB   R2,=DBL8'10000000000000' 13-digit fraction\n         CGDBR R0,B'0101',R2            Convert to fixed, round to 0\n         CVDG  R0,@K_QuadWord           Pack it\n         MVC   @K_Expand_Number(17),=X'4021204B202020202020202020202020+\n               20'                      Move mask\n         LA    R1,@K_Expand_Number+2    A(Start of significance)\n         EDMK  @K_Expand_Number(17),@K_QuadWord+8 Unpack it\n         ST    R1,@K_Expand_NumStart    Save A(Start of number)\n         LA    R1,@K_Expand_Number+16   A(last possible 0\nK00600   DS    0H\n         CLI   0(R1),C'0'               Trailing 0?\n         JNE   K00610                   No, found the end\n         BRCT  R1,K00600                Yes, check prev byte\nK00610   DS    0H\n         CLI   0(R1),C'.'               Back to the decimal point?\n         JNE   K00620                   No, OK\n         AHI   R1,2                     Yes, set to 2 decimal places\nK00620   DS    0H\n         ST    R1,@K_Expand_NumEnd      Save A(end of number)\n         J     K00670                   and skip\n\nK00630   DS    0H\n*--------------------------------------------------------------------*\n*     Not a percent, we don't have to worry about decimal points.    *\n*    Format it in 2 groups of 15 decimal digits (max for ED/UNPK),   *\n*    unintuitively doing the rightmost group first.                  *\n*--------------------------------------------------------------------*\n         CGDBR R0,B'0101',R2            Convert to fixed, round to 0\n         CVDG  R0,@K_QuadWord           Pack it\n         LA    R15,@K_Expand_Number+L'@K_Expand_Number A(End of output)\nK00640   DS    0H\n         AHI   R15,-20                  Move mask\n         MVC   0(20,R15),=X'402020206B2020206B2020206B2020206B202120'\n         LG    R0,@K_QuadWord           Get high dblwd\n         LTGR  R0,R0                    Anything in it?\n         JZ    K00650                   No, OK\n         MVI   1(R15),X'21'             Yes, turn on significance\nK00650   DS    0H\n         LA    R1,19(0,R15)             Init A(1st significant field)\n         EDMK  0(20,R15),@K_QuadWord+8  Edit in data\n         LG    R0,@K_QuadWord           Get high dblwd\n         LTGR  R0,R0                    Anything in it?\n         JZ    K00660                   No, all done\n         SLLG  R0,R0,4                  Yes, make room for sign\n         STG   R0,@K_QuadWord+8         Save it\n         OI    @K_Quadword+15,X'0F'     Set sign\n         SLG   R0,R0                    and clear\n         STG   R0,@K_QuadWord             high dblwd\n         MVI   0(R15),C','              Move separator\n         CLI   1(R15),C' '              Significant 0 missed?\n         JNE   K00640                   No, OK\n         MVI   1(R15),C'0'              Yes, set it\n         J     K00640                   Go process it\nK00660   DS    0H\n         ST    R1,@K_Expand_NumStart    Save start of significance\n         LA    R1,@K_Expand_Number+L'@K_Expand_Number-1 A(End)\n         ST    R1,@K_Expand_NumEnd      Save it\n\nK00670   DS    0H\n*--------------------------------------------------------------------*\n*     Set up the SMSG ...                                            *\n*--------------------------------------------------------------------*\n         MVI   @K_Expand_ZEDSMSG,C' '\n         MVC   @K_Expand_ZEDSMSG+1(L'@K_Expand_ZEDSMSG-1),@K_Expand_ZED+\n               SMSG\n         L     R1,@K_Expand_NumStart    A(Start of number)\n         L     R15,@K_Expand_NumEnd     A(End)\n         SR    R15,R1                   Get EX length of number\n         CHI   R15,L'@K_Expand_ZEDSMSG  Too long for SMSG?\n         JL    K00680                   No, OK\n         LA    R1,=C'>>>>>>>>'          Yes, Indicate number too big\n         LA    R15,7                    EX Length\nK00680   DS    0H\n         LA    R14,@K_Expand_ZEDSMSG    A(SMSG)\n         EX    R15,K_K00680_MVC         MVC   0(0,R14),0(R1)\n         LA    R0,1(0,R15)              Real length\n         ST    R0,@K_Expand_ZEDSMSG_Len Save it\n\n*--------------------------------------------------------------------*\n*     ... and LMSG                                                   *\n*--------------------------------------------------------------------*\n         MVC   @K_Expand_ZEDLMSG(L'K_Expand_ZEDLMSG_Pfx),K_Expand_ZEDLM+\n               SG_Pfx\n         LA    R14,@K_Expand_ZEDLMSG+L'K_Expand_ZEDLMSG_Pfx\n         L     R1,@K_Expand_NumStart    A(Source)\n         L     R15,@K_Expand_NumEnd     Calculate\n         SR    R15,R1                    length\n         EX    R15,K_K00680_MVC         MVC   0(0,R14),0(R1)\n         AHI   R15,L'K_Expand_ZEDLMSG_Pfx+1 Len of LMSG\n         ST    R15,@K_Expand_ZEDLMSG_Len Save it\n\n*--------------------------------------------------------------------*\n*     Tell ISPF about the messages, and re-display                   *\n*--------------------------------------------------------------------*\n         LA    R15,=CL8'VDEFINE'        ISPF Function\n         ST    R15,@K_ISPF_Parms        Save it\n         LA    R15,=CL8'CHAR'           Character variables\n         ST    R15,@K_ISPF_Parms+12     Save it\n\n         LA    R15,=CL8'ZEDSMSG'        Variable name\n         ST    R15,@K_ISPF_Parms+4      Save it\n         LA    R15,@K_Expand_ZEDSMSG    A(Short Message)\n         ST    R15,@K_ISPF_Parms+8      Save it\n         LA    R15,@K_Expand_ZEDSMSG_Len Length of message\n         ST    R15,@K_ISPF_Parms+16     Save it\n         OI    @K_ISPF_Parms+16,X'80'   Flag end of list\n         LA    R1,@K_ISPF_Parms         A(Parmlist)\n         L     R15,@_ISPLINK            A(ISPF Interface)\n         BASR  R14,R15                  Go do it\n\n         LA    R15,=CL8'ZEDLMSG'        Variable name\n         ST    R15,@K_ISPF_Parms+4      Save it\n         LA    R15,@K_Expand_ZEDLMSG    A(Long message)\n         ST    R15,@K_ISPF_Parms+8      Save it\n         LA    R15,@K_Expand_ZEDLMSG_Len Length of message\n         ST    R15,@K_ISPF_Parms+16     Save it\n         OI    @K_ISPF_Parms+16,X'80'   Flag end of list\n         LA    R1,@K_ISPF_Parms         A(Parmlist)\n         L     R15,@_ISPLINK            A(ISPF Interface)\n         BASR  R14,R15                  Go do it\n\n         LA    R15,=CL8'SETMSG'         Yes, ISPF Function\n         ST    R15,@K_ISPF_Parms        Save it\n         LA    R15,=CL8'ISRZ001'        A(Message ID)\n         ST    R15,@K_ISPF_Parms+4      Save it\n         OI    @K_ISPF_Parms+4,X'80'    Mark end of list\n         LA    R1,@K_ISPF_Parms         Point to ISPF parms\n         L     R15,@_ISPLINK            A(Interface routine)\n         BASR  R14,R15                  Go do it\n\n         J     K00710                   And redisplay\n\nK00700   DS    0H\n*--------------------------------------------------------------------*\n*     Unrecognized ZCMD - Issue messages ...                         *\n*--------------------------------------------------------------------*\n         LA    R15,=CL8'VDEFINE'        ISPF Function\n         ST    R15,@K_ISPF_Parms        Save it\n         LA    R15,=CL8'CHAR'           Character variables\n         ST    R15,@K_ISPF_Parms+12     Save it\n\n         LA    R15,=CL8'ZEDSMSG'        Variable name\n         ST    R15,@K_ISPF_Parms+4      Save it\n         LA    R15,K_Bad_ZCMD_SMsg      A(Short Message)\n         ST    R15,@K_ISPF_Parms+8      Save it\n         LA    R15,=AL4(L'K_Bad_ZCMD_SMsg) Length of variable\n         ST    R15,@K_ISPF_Parms+16     Save it\n         OI    @K_ISPF_Parms+16,X'80'   Flag end of list\n         LA    R1,@K_ISPF_Parms         A(Parmlist)\n         L     R15,@_ISPLINK            A(ISPF Interface)\n         BASR  R14,R15                  Go do it\n\n         LA    R15,=CL8'ZEDLMSG'        Variable name\n         ST    R15,@K_ISPF_Parms+4      Save it\n         LA    R15,K_Bad_ZCMD_LMsg      A(Long message)\n         ST    R15,@K_ISPF_Parms+8      Save it\n         LA    R15,=AL4(L'K_Bad_ZCMD_LMsg) Length of message\n         ST    R15,@K_ISPF_Parms+16     Save it\n         OI    @K_ISPF_Parms+16,X'80'   Flag end of list\n         LA    R1,@K_ISPF_Parms         A(Parmlist)\n         L     R15,@_ISPLINK            A(ISPF Interface)\n         BASR  R14,R15                  Go do it\n\n         LA    R15,=CL8'SETMSG'         Yes, ISPF Function\n         ST    R15,@K_ISPF_Parms        Save it\n         LA    R15,=CL8'ISRZ001'        A(Message ID)\n         ST    R15,@K_ISPF_Parms+4      Save it\n         OI    @K_ISPF_Parms+4,X'80'    Mark end of list\n         LA    R1,@K_ISPF_Parms         Point to ISPF parms\n         L     R15,@_ISPLINK            A(Interface routine)\n         BASR  R14,R15                  Go do it\n\n         J     K00710                   And redisplay\n\nK00710   DS    0H\n*--------------------------------------------------------------------*\n*     ... and re-display the table.                                  *\n*--------------------------------------------------------------------*\n         J     K00060                   and start again\n\nK00720   DS    0H\n*--------------------------------------------------------------------*\n*     All done, clear our return code, and exit                      *\n*--------------------------------------------------------------------*\n         LA    R15,0                    Clear the return code\n         J     K90010                   and exit\n\n\nK80010   DS    0H\n*--------------------------------------------------------------------*\n*     Panel not found, set return code, and exit                     *\n*--------------------------------------------------------------------*\n         LA    R15,4                    Set return code\n         J     K90010                   and exit\n\nK90010   DS    0H\n*---------------------------------------------------------------------*\n*   Free up our Dynamic area storage                                  *\n*---------------------------------------------------------------------*\n         LR    R3,R15                 Save return code\n\n         ICM   R1,B'1111',@K_ISPF_Dyn_Area_Ptr\n         JZ    K90020                   None, skip\n         L     R2,@K_31Bit_Stack_Ptr_Ptr A(31-bit stack Ptr)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         SSCSTACK POP,                  Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=(R2)                on this stack\nK90020   DS    0H\n*-------------------------------------------------------------------*\n*    Free up our local storage ...                                  *\n*-------------------------------------------------------------------*\n         LA    R1,@K_Dynam              A(Local storage)\n         L     R2,@K_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         L     R13,4(0,R13)             Rescue A(HSA)\n\n         SSCSTACK POP,                  Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=(R2)                on this stack\n\n         LR    R15,R3                   Restore return code\n\n*-------------------------------------------------------------------*\n*    ... and return to caller                                       *\n*-------------------------------------------------------------------*\n         L     R14,12(0,R13)            Restore return address\n         LM    R0,R12,20(R13)           Restore other registers\n         BSM   0,R14                    and return\n\nK_Literals  DS  0H\n\nK_MVC    MVC   0(0,R1),0(R15)           Move data to dynamic area\nK_PACK   PACK  @K_DBLWD,0(0,R1)         Pack it\nK_CLC    CLC   0(0,R1),0(R14)           Compare ZSCROLLN and ZSCROLLA\nK_CLC1   CLC   @K_DBLWD(0),=C'CANCEL'   Check ZCMD for CANCEL\nK_BLANKS DC    C' '\n\nK_Bad_ZCMD_SMsg DC C'Invalid Command'\nK_Bad_ZCMD_LMsg DC C'Valid commands are: SORT, UP, DOWN, LEFT, RIGHT, E+\n               ND, RETURN, and CANCEL'\n\nK_ISPF_PQUERY_Names DC C'('            PQUERY Variable Names\nK_SPCDYNTY          DC CL8'SPCDYNTY',CL1' ' Type of Dyn area\nK_SPCDYNWI          DC CL8'SPCDYNWI',CL1' ' Width\nK_SPCDYNDE          DC CL8'SPCDYNDE',CL1' ' Depth\nK_SPCDYNRO          DC CL8'SSCDYNRO',CL1' ' Starting Row\nK_SPCDYNCO          DC CL8'SSCDYNCO',CL1' ' Starting Column\n                    DC C')'\nK_ISPF_PQUERY_Types DC CL8'CHAR'       Type of Dynamic area\n                    DC CL8'FIXED'      Width\n                    DC CL8'FIXED'      Depth\n                    DC CL8'FIXED'      Starting Row\n                    DC CL8'FIXED'      Starting Column\nK_ISPF_PQUERY_Lens  DC FL4'8'          Length of Type\n                    DC FL4'4'          Length of Width\n                    DC FL4'4'          Length of Depth\n                    DC FL4'4'          Length of Starting Row\n                    DC FL4'4'          Length of Starting Column\n\nK_ISPF_VCOPY_Scroll_Names DC C'(ZVERB,ZSCROLLN,ZSCROLLA)'\nK_ISPF_VCOPY_Cursor_Names DC C'(ZSCREENW ZSCREENC)'\n\nK_K00680_MVC           MVC   0(0,R14),0(R1)\n\nK_Expand_Tbl           EQU   *\nK_Expand_Ent           EQU   *\n                       DC    AL2(VolTbl_Ent_FreeTrk-VolTbl_Ent_Display)\n                       DC    AL2(VolTbl_Ent_FreeTrk+L'VolTbl_Ent_FreeTr+\n               k-VolTbl_Ent_Display)\n                       DC    AL2(VolTbl_Ent_Sort_FreeTrk-VolTbl_Ent)\nK_Expand_Ent_Len       EQU   *-K_Expand_Ent\n                       DC    AL2(VolTbl_Ent_FreeCyl-VolTbl_Ent_Display)\n                       DC    AL2(VolTbl_Ent_FreeCyl+L'VolTbl_Ent_FreeCy+\n               l-VolTbl_Ent_Display)\n                       DC    AL2(VolTbl_Ent_Sort_FreeCyl-VolTbl_Ent)\n\n                       DC    AL2(VolTbl_Ent_FreeBytes-VolTbl_Ent_Displa+\n               y)\n                       DC    AL2(VolTbl_Ent_FreeBytes+L'VolTbl_Ent_Free+\n               Bytes-VolTbl_Ent_Display)\n                       DC    AL2(VolTbl_Ent_Sort_FreeBytes-VolTbl_Ent)\n\n                       DC    AL2(VolTbl_Ent_FreePct-VolTbl_Ent_Display)\n                       DC    AL2(VolTbl_Ent_FreePct+L'VolTbl_Ent_FreePc+\n               t-VolTbl_Ent_Display)\n                       DC    AL2(VolTbl_Ent_Sort_FreePct-VolTbl_Ent)\n\n                       DC    AL2(VolTbl_Ent_FreeExt-VolTbl_Ent_Display)\n                       DC    AL2(VolTbl_Ent_FreeExt+L'VolTbl_Ent_FreeEx+\n               t-VolTbl_Ent_Display)\n                       DC    AL2(VolTbl_Ent_Sort_FreeExt-VolTbl_Ent)\n\n                       DC    AL2(VolTbl_Ent_LargTrk-VolTbl_Ent_Display)\n                       DC    AL2(VolTbl_Ent_LargTrk+L'VolTbl_Ent_LargTr+\n               k-VolTbl_Ent_Display)\n                       DC    AL2(VolTbl_Ent_Sort_LargTrk-VolTbl_Ent)\n\n                       DC    AL2(VolTbl_Ent_LargCyl-VolTbl_Ent_Display)\n                       DC    AL2(VolTbl_Ent_LargCyl+L'VolTbl_Ent_LargCy+\n               l-VolTbl_Ent_Display)\n                       DC    AL2(VolTbl_Ent_Sort_LargCyl-VolTbl_Ent)\n\n                       DC    AL2(VolTbl_Ent_VTOCTrk-VolTbl_Ent_Display)\n                       DC    AL2(VolTbl_Ent_VTOCTrk+L'VolTbl_Ent_VTOCTr+\n               k-VolTbl_Ent_Display)\n                       DC    AL2(VolTbl_Ent_Sort_VTOCTrk-VolTbl_Ent)\n\n                       DC    AL2(VolTbl_Ent_FreeDSCB-VolTbl_Ent_Display+\n               )\n                       DC    AL2(VolTbl_Ent_FreeDSCB+L'VolTbl_Ent_FreeD+\n               SCB-VolTbl_Ent_Display)\n                       DC    AL2(VolTbl_Ent_Sort_FreeDSCB-VolTbl_Ent)\n\n                       DC    AL2(VolTbl_Ent_VTOCFree-VolTbl_Ent_Display+\n               )\n                       DC    AL2(VolTbl_Ent_VTOCFree+L'VolTbl_Ent_VTOCF+\n               ree-VolTbl_Ent_Display)\n                       DC    AL2(VolTbl_Ent_Sort_VTOCFree-VolTbl_Ent)\n\n                       DC    AL2(VolTbl_Ent_VolSize-VolTbl_Ent_Display)\n                       DC    AL2(VolTbl_Ent_VolSize+L'VolTbl_Ent_VolSiz+\n               e-VolTbl_Ent_Display)\n                       DC    AL2(VolTbl_Ent_Sort_VolSize-VolTbl_Ent)\n\n                       DC    AL2(0)\n                       DC    AL2(0)\n                       DC    AL2(0)\n\nK_Expand_ZEDLMSG_Pfx   DC    C'The unrounded, unscaled value is '\n\n         LTORG\n\nK_Literals_End  DS  0H\n\n\n@K_Dynam                  DSECT        Dynamic area for K\n                          DS    18F     O/S style save area\n@K_31Bit_Stack_Ptr_Ptr    DS    AL4     A(31-bit Stack Ptr)\n@K_24Bit_Stack_Ptr_Ptr    DS    AL4     A(24-bit Stack Ptr)\n@K_DBLWD                  DS    D       Work area\n@K_QuadWord               DS    PL16    Work area\n@K_ISPF_Parms             DS    8AL4    ISPF Parm list\n\n@K_ISPF_Dyn_Area_Width    DS    FL4     Panel Dynam Area Width\n@K_ISPF_Dyn_Area_Depth    DS    FL4     Panel Dynam Area Depth\n@K_ISPF_Dyn_Area_Row      DS    FL4     Panel Dynam Area Start Row\n@K_ISPF_Dyn_Area_Column   DS    FL4     Panel Dynam Area Start Column\n@K_ISPF_Dyn_Area_Ptr      DS    AL4     A(Storage for dynamic area)\n@K_ISPF_Dyn_Area_Len      DS    FL4     Length of dynamic area\n\n                          DS    C\n@K_FLIN                   DS    CL5     Line x\n\n@K_VolTbl_Ent_MVC_Len     DS    FL4     EX len of MVC from VolTbl_Ent\n\n@K_VolTbl_Ent_Display_Line DS   FL4     Current top of display\n@K_VolTbl_Ent_Offset      DS    FL4     Offset for LEFT/RIGHT\n@K_VolTbl_Ent_Display_Line_Max DS FL4   Max value of display line\n@K_VolTbl_Ent_Offset_Max  DS    FL4     Max Offset for LEFT/RIGHT\n@K_VolTbl_Ent_Display_Line_Prev DS FL4  Previous top of display\n@K_VolTbl_Ent_Offset_Prev DS    FL4     Previous Offset for LEFT/RIGHT\n@K_ISPF_Dyn_Area_Hdg_Lines DS   FL4     Nbr of hdg lines in display\n@K_VolTbl_Hdg_Lines       DS    FL4     Nbr of hdg lines in VolTbl\n\n                          DS    X       Flag byte\n@K_Scroll_MAX             EQU   *-1,X'80' 1... .... Scroll MAX\n@K_Scroll_Explicit        EQU   *-1,X'40' .1.. .... Explicit Scroll amt\n@K_Scroll_UP              EQU   *-1,X'08' .... 1... Scroll UP\n@K_Scroll_DOWN            EQU   *-1,X'04' .... .1.. Scroll DOWN\n@K_Scroll_LEFT            EQU   *-1,X'02' .... ..1. Scroll LEFT\n@K_Scroll_RIGHT           EQU   *-1,X'01' .... ...1 Scroll RIGHT\n\n\n@K_Expand_Number          DS    XL40\n@K_Expand_NumStart        DS    AL4\n@K_Expand_NumEnd          DS    AL4\n\n@K_Expand_ZEDSMSG         DS    CL24\n@K_Expand_ZEDSMSG_Len     DS    FL4     Length\n@K_Expand_ZEDLMSG         DS    CL(L'K_Expand_ZEDLMSG_Pfx+L'@K_Expand_N+\n               umber)\n@K_Expand_ZEDLMSG_Len     DS    FL4     Length\n\n@K_ISPF_VCOPY_Ptrs        DS    0F      Pointer to var from VCOPY\n@K_ISPF_VCOPY_Var_Ptr     DS    AL4     A(VCOPYed variable)\n                          ORG   @K_ISPF_VCOPY_Ptrs\n@K_ISPF_VCOPY_Scroll_Ptrs DS    0F      Pointers to vars from VCOPY\n@K_ISPF_VCOPY_ZVERB_Ptr   DS    AL4      A(ZVERB)\n@K_ISPF_VCOPY_ZSCROLLN_Ptr DS   AL4      A(ZSCROLLN)\n@K_ISPF_VCOPY_ZSCROLLA_Ptr DS   AL4      A(ZSCROLLA)\n                          ORG   @K_ISPF_VCOPY_Ptrs\n@K_ISPF_PQUERY_Values     DS    0F     Value areas for PQUERY vars\n@K_ISPF_SPCDYNTN_Value    DS    CL8     Type of area\n@K_ISPF_SPCDYNWI_Value    DS    FL4     Area width\n@K_ISPF_SPCDYNDE_Value    DS    FL4     Area depth\n@K_ISPF_SPCDYNRO_Value    DS    FL4     Starting Row\n@K_ISPF_SPCDYNCO_Value    DS    FL4     Starting Column\n                          ORG   @K_ISPF_VCOPY_Ptrs\n@K_ISPF_VCOPY_Cursor_Ptrs DS    0F      Pointers to vars from VCOPY\n@K_ISPF_ZSCREENW_Ptr      DS    AL4      A(ZSCREENW)\n@K_ISPF_ZSCREENC_Ptr      DS    AL4      A(ZSCREENC)\n                          ORG ,\n\n@K_ISPF_VCOPY_Lens        DS    0F      Length of var from VCOPY\n@K_ISPF_VCOPY_Var_Len     DS    AL4     Len of VCOPYed variable\n                          ORG   @K_ISPF_VCOPY_Lens\n@K_ISPF_VCOPY_Scroll_Lens DS    0F      Lengths of vars from VCOPY\n@K_ISPF_VCOPY_ZVERB_Len   DS    FL4      ZVERB Length\n@K_ISPF_VCOPY_ZSCROLLN_Len DS   FL4      ZSCROLLN Length\n@K_ISPF_VCOPY_ZSCROLLA_Len DS   FL4      ZSCROLLA Length\n                          ORG   @K_ISPF_VCOPY_Lens\n@K_ISPF_VCOPY_Cursor_Lens DS    0F      Lengths of vars from VCOPY\n@K_ISPF_ZSCREENW_Len      DS    FL4      ZSCREENW Length\n@K_ISPF_ZSCREENC_Len      DS    FL4      ZSCREENC Length\n                          ORG   ,\n\n@K_Parms                  DS    0F      Parms for called rtns\n@K_Parms_Std              DS    3AL4     Standard 3 parms\n@K_Parms_Extra            EQU   *        Extra parms\n@K_Parms_V00010           DS    AL4        for V00010\n                          ORG   ,\n\n                          DS    0D\n@K_Dynam_Length           EQU   *-@K_Dynam\n\n&PGMNAME CSECT\n         DROP  ,                        Free base registers\n         POP   USING\n         TITLE 'L00010: Identify line command under ISPF'\n\n         PUSH  USING\n\nL00010   DS    0H\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Routine   : L00010                                                 *\n*                                                                     *\n*  Abstract  : Process primary command entered in ISPF (S)pace or     *\n*              (B)rowse mode.                                         *\n*                                                                     *\n*  Inputs    : R1 : ---> A(@_Dynam)                                   *\n*                        A(31-bit Stack Pointer)                      *\n*                        A(24-bit Stack Pointer)                      *\n*  Outputs   : R15: 0: Command processed OK                           *\n*                   4: Display mode change requested                  *\n*                   8: Unrecognized command                           *\n*                                                                     *\n*  Notes     :                                                        *\n*                                                                     *\n*  History:    2002/02/12 SDDA030 - V2.16                             *\n*                                   New                               *\n*              2003/10/07 SDDA030 - V2.21                             *\n*                                   Added line commands:              *\n*                                    - ISPF(x) to change display mode *\n*                                    - OUTPUT to write table to a file*\n*                                                                     *\n*              ____/__/__ _______                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         STM   R14,R12,12(R13)          Save callers registers\n         LARL  R11,L_Literals           Point to our literals\n         USING (L_Literals,L_Literals_End),R11 Tell the assembler\n\n         L     R12,0(0,R1)              A(@_Dynam)\n         USING @_Dynam,R12              Tell the assembler\n\n*-------------------------------------------------------------------*\n*    Get an area on the stack for our local storage                 *\n*-------------------------------------------------------------------*\n         L     R2,4(0,R1)               A(31-bit stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         SSCSTACK PUSH,                 Get stack area                 +\n               LEN=@L_Dynam_Length,      this long                     +\n               STACK=(R2)                using this stack\n\n         LR    R3,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LHI   R1,@L_Dynam_Length        Its length\n         LA    R14,0                    Clear source address\n         LA    R15,0                     and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R3                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*-------------------------------------------------------------------*\n         ST    R13,4(0,R1)              Chain\n         ST    R1,8(0,R13)               saveareas\n         LR    R13,R1                   Load dynam base\n         USING @L_Dynam,R13             Assign a base\n         L     R15,@L_Dynam+4           Get A(HSA)\n         LM    R0,R3,20(R15)            Restore callers registers\n\n         L     R15,4(0,R1)              A(31-bit Stack Pointer)\n         ST    R15,@L_31Bit_Stack_Ptr_Ptr Save it\n         L     R15,8(0,R1)              A(24-bit Stack Pointer)\n         ST    R15,@L_24Bit_Stack_Ptr_Ptr Save it\n\n*-------------------------------------------------------------------*\n*    Get ZCMD                                                       *\n*-------------------------------------------------------------------*\n         LA    R15,=CL8'VCOPY'          ISPF Function\n         ST    R15,@L_ISPF_Parms        Save it\n         LA    R15,=CL8'ZCMD'           Variable we want\n         ST    R15,@L_ISPF_Parms+4      Save it\n         LA    R15,@L_ZCMD_Length       A(Length Address)\n         ST    R15,@L_ISPF_Parms+8      Save it\n         LA    R15,@L_ZCMD_Ptr          A(Variable name)\n         ST    R15,@L_ISPF_Parms+12     Save it\n         OI    @L_ISPF_Parms+12,X'80'   Flag last parm\n         LA    R1,@L_ISPF_Parms         A(ISPF Parms)\n         L     R15,@_ISPLINK            A(ISPF routine)\n         BASR  R14,R15                  Go get the variable\n\n         LTR   R15,R15                  Did we get it?\n         JNZ   L00140                   No, pretend all is OK\n\n*-------------------------------------------------------------------*\n*    See if we recognize the command. First, uppercase it ...       *\n*-------------------------------------------------------------------*\n         ICM   R14,B'1111',@L_ZCMD_Length Get len of ZCMD\n         JZ    L00140                   Nothing, all done\n         ICM   R15,B'1111',@L_ZCMD_Ptr  OK, point to ZCMD\n         JZ    L00140                   Nothing (huh?), exit\n         MVI   @L_Prim_Cmd,C' '         Clear\n         MVC   @L_Prim_Cmd+1(L'@L_Prim_Cmd-1),@L_Prim_Cmd command area\n         AHI   R14,-1                   EX length\n         EX    R14,L_OC                 Uppercase it\n         AHI   R14,1                    Restore real length\n\n*-------------------------------------------------------------------*\n*    ... and search our table for the command                       *\n*-------------------------------------------------------------------*\n         LR    R0,R14                   Set up length register\n         LR    R1,R15                   and pointer register\n\n         LA    R15,0                    Clear length register\n         LA    R14,L_Command_Table      A(Commands we know about)\nL00020   DS    0H\n         ICM   R2,B'1111',0(R14)        A(Processing routine)\n         JZ    L00160                   End-of-table, unknown command\n         IC    R15,4(0,R14)             Get cmd len from table\n         CR    R0,R15                   Could it be ours?\n         JNH   L00030                   No, try next\n         EX    R15,L_CLC                Could be, is it?\n         JNE   L00030                   No, try next table entry\n         LA    R2,1(0,R15)              Maybe, get real length of cmd\n         CR    R0,R2                    Is that all there is?\n         JNH   L00040                   Yes, found our entry\n         AR    R2,R1                    No, point to last char of cmd\n         CLI   0(R2),C' '               Followed by a space?\n         JE    L00040                   Yes, this is our command\nL00030   DS    0H\n         LA    R14,6(R14,R15)           A(Next entry)\n         J     L00020                   and check it out\n\nL00040   DS    0H\n*-------------------------------------------------------------------*\n*    We have found our command entry, so now we set up the          *\n*   registers for the processing routine:                           *\n*        R1 = A(1st non-blank after the command)                    *\n*        R0 = length of data remaining in ZCMD                      *\n*-------------------------------------------------------------------*\n         AR    R0,R1                    A(char past end of ZCMD)\n         AR    R1,R15                   A(last char of command)\nL00050   DS    0H\n         AHI   R1,1                     A(next char)\n         CR    R1,R0                    Gone too far?\n         JNL   L00060                   Yep, skip\n         CLI   0(R1),C' '               No, a space?\n         JE    L00050                   Yes, keep going\nL00060   DS    0H\n         SR    R0,R1                    Length of data remaining\n\n*-------------------------------------------------------------------*\n*    Go process our command                                         *\n*-------------------------------------------------------------------*\n         LA    R15,@_Dynam              A(Dynamic area)\n         ST    R15,@L_Rtn_Parms         Save it\n         L     R15,@L_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)\n         ST    R15,@L_Rtn_Parms+4       Save it\n         L     R15,@L_24Bit_Stack_Ptr_Ptr A(24-bit Stack Pointer)\n         ST    R15,@L_Rtn_Parms+8       Save it\n         ST    R1,@L_Rtn_Parms+12       Save A(Command)\n         ST    R0,@L_Rtn_Parms+16       Save Len of Command\n\n         LA    R1,@L_Rtn_Parms          A(Parm list)\n         L     R15,0(0,R14)             A(processing routine)\n         BASR  R14,R15                  go do it\n\n         J     L00140                   and skip\n\nL00140   DS    0H\n         LA    R15,0                    Clear return code\n         J     L90010                   and exit\n\nL00160   DS    0H\n         LA    R15,8                    Unrecognized command\n         J     L90010                   and exit\n\n\nL90010   DS    0H\n*-------------------------------------------------------------------*\n*    Free up our local storage ...                                  *\n*-------------------------------------------------------------------*\n         LR    R3,R15                   Save return code\n\n         LA    R1,@L_Dynam              A(Local storage)\n         L     R2,@L_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         L     R13,4(0,R13)             Rescue A(HSA)\n\n         SSCSTACK POP,                  Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=(R2)                on this stack\n\n         LR    R15,R3                   Restore return code\n\n*-------------------------------------------------------------------*\n*    ... and return to caller                                       *\n*-------------------------------------------------------------------*\n         L     R14,12(0,R13)            Restore return address\n         LM    R0,R12,20(R13)           Restore regs other than R15\n         BSM   0,R14                    and return\n\nL_Literals  DS  0H\n\nL_Command_Table EQU  *\nL_Cmd_Proc  DC  AL4(LA0010)             Command processor\nL_Cmd_Len   DC  AL1(3)                  Command length (EX len)\nL_Cmd       DC  C'SORT'                 Command Name\n\n            DC  AL4(LB0010A)\n            DC  AL1(6)\n            DC  C'ISPF(S)'\n\n            DC  AL4(LB0010B)\n            DC  AL1(6)\n            DC  C'ISPF(E)'\n\n            DC  AL4(LB0010C)\n            DC  AL1(6)\n            DC  C'ISPF(B)'\n\n            DC  AL4(LB0010D)\n            DC  AL1(6)\n            DC  C'ISPF(N)'\n\n            DC  AL4(LC0010)\n            DC  AL1(5)\n            DC  C'OUTPUT'\n\n            DC  AL4(0)                  End-of-Table marker\n\nL_OC     OC    @L_Prim_Cmd(0),0(R15)    Uppercase command\nL_CLC    CLC   @L_Prim_Cmd(0),5(R14)    Check for command in table\n\n         LTORG\n\nL_Literals_End  DS  0H\n\n\n@L_Dynam                  DSECT\n                          DS    18F    O/S style save area\n@L_31Bit_Stack_Ptr_Ptr    DS    AL4    A(31-bit Stack Ptr)\n@L_24Bit_Stack_Ptr_Ptr    DS    AL4    A(24-bit Stack Ptr)\n@L_Prim_Cmd               DS    CL80   Copy of line command\n@L_ZCMD_Ptr               DS    AL4    A(ZCMD)\n@L_ZCMD_Length            DS    FL4    Length of ZCMD\n@L_ISPF_Parms             DS    5AL4   ISPF Parm List\n@L_Rtn_Parms              DS    5AL4   Cmd processing routine parms\n                          DS    0D\n@L_Dynam_Length           EQU   *-@L_Dynam\n\n\n&PGMNAME CSECT\n\n         DROP  ,\n         POP   USING\n\n         TITLE 'LA0010: Process SORT Primary Command'\n\n         PUSH  USING\n\nLA0010   DS    0H\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Routine   : LA0010                                                 *\n*                                                                     *\n*  Abstract  : Process SORT primary command                           *\n*                                                                     *\n*  Inputs    : R1 : ---> A(@_Dynam)                                   *\n*                        A(31-bit Stack Pointer)                      *\n*                        A(24-bit Stack Pointer)                      *\n*                        A(operands of the SORT command)              *\n*                        Length of operands                           *\n*  Outputs   : R15: 0                                                 *\n*                                                                     *\n*  Notes     :                                                        *\n*                                                                     *\n*  History:    2002/02/12 SDDA030 - V2.16                             *\n*                                   New                               *\n*              2003/10/07 SDDA030 - V2.21                             *\n*                                   New, originally in L0010          *\n*              2006/04/21 SDDA030 - V2.24                             *\n*                                   Used standardised calling sequence*\n*                                                                     *\n*              ____/__/__ _______                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         STM   R14,R12,12(R13)          Save callers registers\n         LARL  R11,LA_Literals          Point to our literals\n         USING (LA_Literals,LA_Literals_End),R11 Tell the assembler\n\n         L     R12,0(0,R1)              A(@_Dynam)\n         USING @_Dynam,R12              Tell the assembler\n\n*-------------------------------------------------------------------*\n*    Get an area on the stack for our local storage                 *\n*-------------------------------------------------------------------*\n         L     R2,4(0,R1)               A(31-bit stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         SSCSTACK PUSH,                 Get stack area                 +\n               LEN=@LA_Dynam_Length,     this long                     +\n               STACK=(R2)                using this stack\n\n         LR    R3,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LHI   R1,@LA_Dynam_Length       Its length\n         LA    R14,0                    Clear source address\n         LA    R15,0                     and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R3                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*-------------------------------------------------------------------*\n         ST    R13,4(0,R1)              Chain\n         ST    R1,8(0,R13)               saveareas\n         LR    R13,R1                   Load dynam base\n         USING @LA_Dynam,R13            Assign a base\n         L     R15,@LA_Dynam+4          Get A(HSA)\n         LM    R0,R3,20(R15)            Restore callers registers\n\n         L     R15,4(0,R1)              A(31-bit Stack Pointer)\n         ST    R15,@LA_31Bit_Stack_Ptr_Ptr Save it\n         L     R15,8(0,R1)              A(24-bit Stack Pointer)\n         ST    R15,@LA_24Bit_Stack_Ptr_Ptr Save it\n\n*---------------------------------------------------------------------*\n*   Initialize our flags, and get the operand length and addr         *\n*---------------------------------------------------------------------*\n         NI    @LA_Cmd_Prompted,X'FF'-L'@LA_Cmd_Prompted\n\n         L     R0,16(0,R1)              Get operand length\n         L     R1,12(0,R1)              Get A(Operands)\n\nLA0020   DS    0H\n*---------------------------------------------------------------------*\n*   Initialize our sort fields ...                                    *\n*---------------------------------------------------------------------*\n         MVC   @LA_I00010_Sort_Field,=CL8' ' Clear sort field\n         MVI   @LA_I00010_Sort_Dir,C' ' and direction\n\n*---------------------------------------------------------------------*\n*   Check to see what we have as operands                             *\n*---------------------------------------------------------------------*\n         LTR   R14,R0                   Get the length\n         JZ    LA0100                   No operands, skip\n         LR    R15,R1                   OK, point to it (them)\n\nLA0050   DS    0H\n         CLI   0(R15),C' '              End of field?\n         JE    LA0060                   Yes, skip\n         AHI   R15,1                    Bump input pointer\n         BRCT  R14,LA0050               and check out next\nLA0060   DS    0H\n         LR    R3,R15                   A(Byte past end-of-field)\n         SR    R3,R1                    Length of field\n         JNP   LA0100                   Nothing, skip\n         C     R3,=AL4(L'@LA_I00010_Sort_Field) Too long?\n         JNH   LA0070                   No, skip\n         L     R3,=AL4(L'@LA_I00010_Sort_Field) Yes, use max length\nLA0070   DS    0H\n         AHI   R3,-1                    EX length\n         EX    R3,LA_OC                 Save it\n\n*-------------------------------------------------------------------*\n*    Extract the sort direction                                     *\n*-------------------------------------------------------------------*\n         LTR   R14,R14                  Anything left?\n         JZ    LA0100                   No, all done\nLA0080   DS    0H\n         CLI   0(R15),C' '              Leading space?\n         JNE   LA0090                   No, skip\n         AHI   R15,1                    Yes, bump pointer\n         BRCT  R14,LA0080               and check next\n         J     LA0100                   All done, skip\nLA0090   DS    0H\n         OC    @LA_I00010_Sort_Dir,0(R15) Save Sort direction\n\nLA0100   DS    0H\n*-------------------------------------------------------------------*\n*    If we don't have a sort field, and we have prompted, just      *\n*   exit without sorting                                            *\n*-------------------------------------------------------------------*\n         CLI   @LA_I00010_Sort_Field,C' ' Any sort field?\n         JNE   LA0110                   Yes, go sort\n         TM    @LA_Cmd_Prompted,L'@LA_Cmd_Prompted Did we prompt?\n         JZ    LA0120                   No, go prompt now\n         J     LA9010                   Yes, exit\n\nLA0110   DS    0H\n*-------------------------------------------------------------------*\n*    Invoke the sort routine                                        *\n*-------------------------------------------------------------------*\n         LA    R15,@_Dynam              A(Dynamic area)\n         ST    R15,@LA_Parms_Std        Save it\n         L     R15,@LA_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)\n         ST    R15,@LA_Parms_Std+4      Save it\n         L     R15,@LA_24Bit_Stack_Ptr_Ptr A(24-bit Stack Pointer)\n         ST    R15,@LA_Parms_Std+8      Save it\n         LA    R15,@LA_I00010_Sort_Field A(Offset)\n         ST    R15,@LA_Parms_I00010     Save it\n         LA    R15,@LA_I00010_Sort_Dir  A(Sort Direction)\n         ST    R15,@LA_Parms_I00010+4   Save it\n\n         LA    R1,@LA_Parms             A(Parms)\n         BRAS  R14,I00010               Go sort\n\n         LTR   R15,R15                  Did it work?\n         JZ    LA9010                   Yes, exit\n\nLA0120   DS    0H\n*-------------------------------------------------------------------*\n*    SORT was entered with no operands, or the sort failed (because *\n*   of an invalid sort field) - if we can, pop up a panel prompting *\n*   for the sort field and direction.                               *\n*-------------------------------------------------------------------*\n         CLI   LA_Prompt_Panel,C' '     Any prompt panel?\n         JE    LA0130                   No, just get out\n\n         LA    R15,=CL8'PQUERY'         ISPF Function\n         ST    R15,@LA_ISPF_Parms       Save it\n         LA    R15,LA_Prompt_Panel      A(Panel name)\n         ST    R15,@LA_ISPF_Parms+4     Save it\n         LA    R15,LA_Prompt_Panel      A(Dummy area name)\n         ST    R15,@LA_ISPF_Parms+8     Save it\n         LA    R15,@LA_ISPF_Parms+16    A(Return area)\n         ST    R15,@LA_ISPF_Parms+12    Save it\n         OI    @LA_ISPF_Parms+12,X'80'  Flag last parm\n         LA    R1,@LA_ISPF_Parms        A(ISPF Parms)\n         L     R15,@_ISPLINK            A(ISPF routine)\n         BASR  R14,R15                  Go check out panel\n         CHI   R15,8                    Was the panel found?\n         JH    LA0130                   No, just exit\n\n         LA    R15,=CL8'ADDPOP'         ISPF Function\n         ST    R15,@LA_ISPF_Parms       Save it\n         OI    @LA_ISPF_Parms,X'80'     Flag last parm\n         LA    R1,@LA_ISPF_Parms        A(ISPF Parms)\n         L     R15,@_ISPLINK            A(ISPF routine)\n         BASR  R14,R15                  Set pop-up environment\n\n         LA    R15,=CL8'DISPLAY'        ISPF Function\n         ST    R15,@LA_ISPF_Parms       Save it\n         LA    R15,LA_Prompt_Panel      A(Panel name)\n         ST    R15,@LA_ISPF_Parms+4     Save it\n         OI    @LA_ISPF_Parms+4,X'80'   Flag last parm\n         LA    R1,@LA_ISPF_Parms        A(ISPF Parms)\n         L     R15,@_ISPLINK            A(ISPF routine)\n         BASR  R14,R15                  Display pop-up prompt\n         LR    R3,R15                   Save our return code\n\n         LA    R15,=CL8'REMPOP'         ISPF Function\n         ST    R15,@LA_ISPF_Parms       Save it\n         OI    @LA_ISPF_Parms,X'80'     Flag last parm\n         LA    R1,@LA_ISPF_Parms        A(ISPF Parms)\n         L     R15,@_ISPLINK            A(ISPF routine)\n         BASR  R14,R15                  Reset pop-up environment\n\n         CHI   R3,8                     How did we do?\n         JH    LA0130                   Not good, skip\n         JE    LA0140                   END, RETURN, etc.\n\n         OI    @LA_Cmd_Prompted,L'@LA_Cmd_Prompted We have prompted\n\n         LA    R15,=CL8'VCOPY'          ISPF Function\n         ST    R15,@LA_ISPF_Parms       Save it\n         LA    R15,=CL8'ZCMD'           Variable we want\n         ST    R15,@LA_ISPF_Parms+4     Save it\n         LA    R15,@LA_ISPF_VCOPY_Lens  A(Length Address)\n         ST    R15,@LA_ISPF_Parms+8     Save it\n         LA    R15,@LA_ISPF_VCOPY_Ptrs  A(Variable)\n         ST    R15,@LA_ISPF_Parms+12    Save it\n         OI    @LA_ISPF_Parms+12,X'80'  Flag last parm\n         LA    R1,@LA_ISPF_Parms        A(ISPF Parms)\n         L     R15,@_ISPLINK            A(ISPF routine)\n         BASR  R14,R15                  Go get the variable\n\n         LTR   R15,R15                  Did we get it?\n         JNZ   LA0130                   No, exit\n\n*-------------------------------------------------------------------*\n*    The popup seemed to work; if the 1st word is SORT, point past  *\n*   it                                                              *\n*-------------------------------------------------------------------*\n         ICM   R0,B'1111',@LA_ISPF_VCOPY_Lens Get ZCMD length\n         JZ    LA0130                   Nothing, skip\n         ICM   R1,B'1111',@LA_ISPF_VCOPY_Ptrs A(ZCMD)\n         JZ    LA0130                   Nothing, skip\n\n         CHI   R0,5                     Room enough for 'SORT '?\n         JNH   LA0128                   No, skip\n         CLC   =C'SORT ',0(R1)          Yes, is it?\n         JNE   LA0128                   No, skip\n         AR    R0,R1                    Yes, point past end of string\n         AHI   R1,5                     and point past 'SORT '\nLA0122   DS    0H\n         CLI   0(R1),C' '               Start of operand?\n         JNE   LA0124                   Yes, skip\n         AHI   R1,1                     No, bump pointer\n         CR    R1,R0                    Any string left?\n         JL    LA0122                   Yes, keep checking\nLA0124   DS    0H\n         SR    R0,R1                    Set up new length\nLA0128   DS    0H\n\n         J     LA0020                   and start again\n\nLA0130   DS    0H\n*-------------------------------------------------------------------*\n*    The sort failed, and we are not prompting, so set the ISPF     *\n*   messages                                                        *\n*-------------------------------------------------------------------*\n         LA    R15,=CL8'VDEFINE'        ISPF Function\n         ST    R15,@LA_ISPF_Parms       Save it\n         LA    R15,=CL8'CHAR'           Character variables\n         ST    R15,@LA_ISPF_Parms+12 Save it\n\n         LA    R15,=CL8'ZEDSMSG'        Variable name\n         ST    R15,@LA_ISPF_Parms+4     Save it\n         LA    R15,LA_Sort_Fail_SMsg    Short message\n         ST    R15,@LA_ISPF_Parms+8     Save it\n         LA    R15,=AL4(L'LA_Sort_Fail_SMsg) Length of message\n         ST    R15,@LA_ISPF_Parms+16 Save it\n         OI    @LA_ISPF_Parms+16,X'80' Flag end of list\n         LA    R1,@LA_ISPF_Parms        A(Parmlist)\n         L     R15,@_ISPLINK            A(ISPF Interface)\n         BASR  R14,R15                  Go do it\n\n         LA    R15,=CL8'ZEDLMSG'        Variable name\n         ST    R15,@LA_ISPF_Parms+4     Save it\n         LA    R15,LA_Sort_Fail_LMsg    Long message\n         ST    R15,@LA_ISPF_Parms+8     Save it\n         LA    R15,=AL4(L'LA_Sort_Fail_LMsg) Length of message\n         ST    R15,@LA_ISPF_Parms+16 Save it\n         OI    @LA_ISPF_Parms+16,X'80' Flag end of list\n         LA    R1,@LA_ISPF_Parms        A(Parmlist)\n         L     R15,@_ISPLINK            A(ISPF Interface)\n         BASR  R14,R15                  Go do it\n\n         LA    R15,=CL8'SETMSG'         Yes, ISPF Function\n         ST    R15,@LA_ISPF_Parms       Save it\n         LA    R15,=CL8'ISRZ001'        A(Message ID)\n         ST    R15,@LA_ISPF_Parms+4     Save it\n         OI    @LA_ISPF_Parms+4,X'80' Mark end of list\n         LA    R1,@LA_ISPF_Parms        Point to ISPF parms\n         L     R15,@_ISPLINK            A(Interface routine)\n         BASR  R14,R15                  Go do it\n\n         J     LA0150                   and exit with error\n\nLA0140   DS    0H\n         LA    R15,0                    Clear return code\n         J     LA9010                   and exit\n\nLA0150   DS    0H\n         LA    R15,4                    No Sort done\n         J     LA9010                   and exit\n\nLA0160   DS    0H\n         LA    R15,8                    ZCMD other than SORT\n         J     LA9010                   and exit\n\n\nLA9010   DS    0H\n*-------------------------------------------------------------------*\n*    Free up our local storage ...                                  *\n*-------------------------------------------------------------------*\n         LR    R3,R15                   Save return code\n\n         LA    R1,@LA_Dynam             A(Local storage)\n         L     R2,@LA_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         L     R13,4(0,R13)             Rescue A(HSA)\n\n         SSCSTACK POP,                  Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=(R2)                on this stack\n\n         LR    R15,R3                   Restore return code\n\n*-------------------------------------------------------------------*\n*    ... and return to caller                                       *\n*-------------------------------------------------------------------*\n         L     R14,12(0,R13)            Restore return address\n         LM    R0,R12,20(R13)           Restore regs other than R15\n         BSM   0,R14                    and return\n\nLA_Literals DS  0H\n\nLA_OC    OC    @LA_I00010_Sort_Field(0),0(R1) Move Sort Field Name\n\nLA_Sort_Fail_SMsg     DC  C'Sort failed'\nLA_Sort_Fail_LMsg     DC  C'Invalid SORT field'\n\nLA_Prompt_Panel DC   CL8'&SORT_Prompt_Popup_Panel'\n\n         LTORG\n\nLA_Literals_End DS  0H\n\n\n@LA_Dynam                 DSECT\n                          DS    18F     O/S style save area\n@LA_31Bit_Stack_Ptr_Ptr   DS    AL4     A(31-bit Stack Ptr)\n@LA_24Bit_Stack_Ptr_Ptr   DS    AL4     A(24-bit Stack Ptr)\n@LA_DBLWD                 DS    D       Work area\n                          DS    X       Flag Byte\n@LA_Cmd_Prompted          EQU   *-1,X'80' 1... .... SORT from prompt\n                          DS    0F      Alignment\n@LA_Macros                EQU   *\n@LA_ISPF_Parms            DS    5AL4    ISPF Parm List\n@LA_ISPF_VCOPY_Lens       DS    AL4     ZCMD Length pointer\n@LA_ISPF_VCOPY_Ptrs       DS    AL4     ZCMD Data Ptr\n@LA_ZCMD_Ptr              DS    AL4     A(ZCMD)\n@LA_ZCMD_Length           DS    FL4     Length of ZCMD\n                          ORG   @LA_Macros\n@LA_I00010_Sort_Field     DS    CL8     Sort Field Name/Offset\n@LA_I00010_Sort_Dir       DS    C       Sort Direction\n                          ORG   ,\n\n@LA_Parms                 DS    0F      Parms for called rtns\n@LA_Parms_Std             DS    3AL4     Standard 3 parms\n@LA_Parms_Extra           EQU   *         Extra parms\n@LA_Parms_I00010          DS    2AL4         for I00010\n                          ORG   ,\n                          DS    0D\n@LA_Dynam_Length          EQU   *-@LA_Dynam\n\n\n&PGMNAME CSECT\n\n         DROP  ,\n         POP   USING\n\n         TITLE 'LB0010: Process ISPF(x) line command'\n\n         PUSH  USING\n\nLB0010   DS    0H\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Routine   : LB0010                                                 *\n*                                                                     *\n*  Abstract  : Change display type to ISPF(x) - SPACE display         *\n*                                                                     *\n*  Inputs    : R1 : ---> A(@_Dynam)                                   *\n*                        A(31-bit Stack Pointer)                      *\n*                        A(24-bit Stack Pointer)                      *\n*                        A(operands of the command)                   *\n*                        Length of operands                           *\n*  Outputs   : R15: 4                                                 *\n*                                                                     *\n*  Notes     :                                                        *\n*                                                                     *\n*  History:    2003/10/07 SDDA030 - V2.16                             *\n*                                   New                               *\n*              2006/04/21 SDDA030 - V2.24                             *\n*                                   Used standardised calling sequence*\n*                                                                     *\n*              ____/__/__ _______                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n\nLB0010A  DS    0H\n         STM   R14,R12,12(R13)          Save callers registers\n         LA    R4,0                     R4=0: ISPF(S)\n         J     LB0020\nLB0010B  DS    0H\n         STM   R14,R12,12(R13)          Save callers registers\n         LHI   R4,4                     R4=4: ISPF(E)\n         J     LB0020\nLB0010C  DS    0H\n         STM   R14,R12,12(R13)          Save callers registers\n         LHI   R4,8                     R4=8: ISPF(B)\n         J     LB0020\nLB0010D  DS    0H\n         STM   R14,R12,12(R13)          Save callers registers\n         LHI   R4,12                    R4=12: ISPF(N)\n         J     LB0020\nLB0020   DS    0H\n         LARL  R11,LB_Literals          Point to our literals\n         USING (LB_Literals,LB_Literals_End),R11 Tell the assembler\n\n         L     R12,0(0,R1)              A(@_Dynam)\n         USING @_Dynam,R12              Tell the assembler\n\n*-------------------------------------------------------------------*\n*    Get an area on the stack for our local storage                 *\n*-------------------------------------------------------------------*\n         L     R2,4(0,R1)               A(31-bit stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         SSCSTACK PUSH,                 Get stack area                 +\n               LEN=@LB_Dynam_Length,     this long                     +\n               STACK=(R2)                using this stack\n\n         LR    R3,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LHI   R1,@LB_Dynam_Length       Its length\n         LA    R14,0                    Clear source address\n         LA    R15,0                     and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R3                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*-------------------------------------------------------------------*\n         ST    R13,4(0,R1)              Chain\n         ST    R1,8(0,R13)               saveareas\n         LR    R13,R1                   Load dynam base\n         USING @LB_Dynam,R13            Assign a base\n         L     R15,@LB_Dynam+4          Get A(HSA)\n         LM    R0,R3,20(R15)            Restore callers registers\n\n         L     R15,4(0,R1)              A(31-bit Stack Pointer)\n         ST    R15,@LB_31Bit_Stack_Ptr_Ptr Save it\n         L     R15,8(0,R1)              A(24-bit Stack Pointer)\n         ST    R15,@LB_24Bit_Stack_Ptr_Ptr Save it\n\n*---------------------------------------------------------------------*\n*   Go process the command, based on the contents of R4               *\n*---------------------------------------------------------------------*\n\nLB0030   DS    0H\n*---------------------------------------------------------------------*\n*   ISPF(S) requested - if not already active, reset flags            *\n*---------------------------------------------------------------------*\n         LTR   R4,R4                    R4 = 0 (ISPF(S)?)\n         JNZ   LB0040                   No, skip\n         TM    @_ISPF_SPACE,L'@_ISPF_SPACE Already active?\n         JO    LB8010                   Yes, error\n         NI    @_ISPF_BRIF,X'FF'-L'@_ISPF_BRIF    No, reset\n         NI    @_ISPF_EDIF,X'FF'-L'@_ISPF_EDIF     ISPF\n         OI    @_ISPF_SPACE,L'@_ISPF_SPACE           flags\n         J     LB0070                   and skip\n\nLB0040   DS    0H\n*---------------------------------------------------------------------*\n*   ISPF(E) requested - if not already active, reset flags            *\n*---------------------------------------------------------------------*\n         CHI   R4,4                     R4 = 4 (ISPF(E)?)\n         JNE   LB0050                   No, skip\n         TM    @_ISPF_EDIF,L'@_ISPF_EDIF Already in EDIF?\n         JO    LB8010                   Yes, error\n         NI    @_ISPF_SPACE,X'FF'-L'@_ISPF_SPACE  No, reset\n         NI    @_ISPF_BRIF,X'FF'-L'@_ISPF_BRIF     ISPF\n         OI    @_ISPF_EDIF,L'@_ISPF_EDIF            flags\n         J     LB0070                   and skip\n\nLB0050   DS    0H\n*---------------------------------------------------------------------*\n*   ISPF(B) requested - if not already active, reset flags            *\n*---------------------------------------------------------------------*\n         CHI   R4,8                     R4 = 8 (ISPF(B)?)\n         JNE   LB0060                   No, skip\n         TM    @_ISPF_BRIF,L'@_ISPF_BRIF Already in BRIF?\n         JO    LB8010                   Yes, error\n         NI    @_ISPF_SPACE,X'FF'-L'@_ISPF_SPACE  No, reset\n         NI    @_ISPF_EDIF,X'FF'-L'@_ISPF_EDIF     ISPF\n         OI    @_ISPF_BRIF,L'@_ISPF_BRIF            flags\n         J     LB0070                   and skip\n\nLB0060   DS    0H\n*---------------------------------------------------------------------*\n*   ISPF(N) requested - reset all the ISPF flags                      *\n*---------------------------------------------------------------------*\n         CHI   R4,12                    R4 = 12 (ISPF(N)?)\n         JNE   LB0080                   No, ignore it\n         NI    @_ISPF_SPACE,X'FF'-L'@_ISPF_SPACE\n         NI    @_ISPF_EDIF,X'FF'-L'@_ISPF_EDIF\n         NI    @_ISPF_BRIF,X'FF'-L'@_ISPF_BRIF\n         NI    @_ISPF_Explicit,X'FF'-L'@_ISPF_Explicit\n         J     LB0070                   and skip\n\nLB0070   DS    0H\n*---------------------------------------------------------------------*\n*   Turn on the re-display requested flag ...                         *\n*---------------------------------------------------------------------*\n         OI    @_ReDisplay,L'@_ReDisplay Say we need a redisplay\n\nLB0080   DS    0H\n*---------------------------------------------------------------------*\n*   ... and exit                                                      *\n*---------------------------------------------------------------------*\n         LA    R15,0                    Clear return code\n         J     LB9010                   and exit\n\nLB8010   DS    0H\n*-------------------------------------------------------------------*\n*    The requested display mode is already active - define ISPF     *\n*   messages, and exit                                              *\n*-------------------------------------------------------------------*\n         LA    R15,=CL8'VDEFINE'        ISPF Function\n         ST    R15,@LB_ISPF_Parms       Save it\n         LA    R15,=CL8'CHAR'           Character variables\n         ST    R15,@LB_ISPF_Parms+12 Save it\n\n         LA    R15,=CL8'ZEDSMSG'        Variable name\n         ST    R15,@LB_ISPF_Parms+4     Save it\n         LA    R15,LB_Curr_Act_SMsg     Short message\n         ST    R15,@LB_ISPF_Parms+8     Save it\n         LA    R15,=AL4(L'LB_Curr_Act_SMsg) Length of message\n         ST    R15,@LB_ISPF_Parms+16 Save it\n         OI    @LB_ISPF_Parms+16,X'80' Flag end of list\n         LA    R1,@LB_ISPF_Parms        A(Parmlist)\n         L     R15,@_ISPLINK            A(ISPF Interface)\n         BASR  R14,R15                  Go do it\n\n         LA    R15,=CL8'ZEDLMSG'        Variable name\n         ST    R15,@LB_ISPF_Parms+4     Save it\n         LA    R15,LB_Curr_Act_LMsg     Long message\n         ST    R15,@LB_ISPF_Parms+8     Save it\n         LA    R15,=AL4(L'LB_Curr_Act_LMsg) Length of message\n         ST    R15,@LB_ISPF_Parms+16 Save it\n         OI    @LB_ISPF_Parms+16,X'80' Flag end of list\n         LA    R1,@LB_ISPF_Parms        A(Parmlist)\n         L     R15,@_ISPLINK            A(ISPF Interface)\n         BASR  R14,R15                  Go do it\n\n         LA    R15,=CL8'SETMSG'         Yes, ISPF Function\n         ST    R15,@LB_ISPF_Parms       Save it\n         LA    R15,=CL8'ISRZ001'        A(Message ID)\n         ST    R15,@LB_ISPF_Parms+4     Save it\n         OI    @LB_ISPF_Parms+4,X'80' Mark end of list\n         LA    R1,@LB_ISPF_Parms        Point to ISPF parms\n         L     R15,@_ISPLINK            A(Interface routine)\n         BASR  R14,R15                  Go do it\n\n         LA    R15,0                    Clear return code\n         J     LB9010                   and exit\n\nLB9010   DS    0H\n*-------------------------------------------------------------------*\n*    Free up our local storage ...                                  *\n*-------------------------------------------------------------------*\n         LR    R3,R15                   Save return code\n\n         LA    R1,@LB_Dynam             A(Local storage)\n         L     R2,@LB_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         L     R13,4(0,R13)             Rescue A(HSA)\n\n         SSCSTACK POP,                  Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=(R2)                on this stack\n\n         LR    R15,R3                   Restore return code\n\n*-------------------------------------------------------------------*\n*    ... and return to caller                                       *\n*-------------------------------------------------------------------*\n         L     R14,12(0,R13)            Restore return address\n         LM    R0,R12,20(R13)           Restore regs other than R15\n         BSM   0,R14                    and return\n\nLB_Literals DS  0H\n\nLB_Curr_Act_SMsg     DC  C'Currently active'\nLB_Curr_Act_LMsg     DC  C'Requested display mode already active'\n\n         LTORG\n\nLB_Literals_End DS  0H\n\n\n@LB_Dynam                 DSECT\n                          DS    18F     O/S style save area\n@LB_31Bit_Stack_Ptr_Ptr   DS    AL4     A(31-bit Stack Ptr)\n@LB_24Bit_Stack_Ptr_Ptr   DS    AL4     A(24-bit Stack Ptr)\n@LB_ISPF_Parms            DS    5AL4    ISPF Parm List\n                          DS    0D\n@LB_Dynam_Length          EQU   *-@LB_Dynam\n\n\n&PGMNAME CSECT\n\n         DROP  ,\n         POP   USING\n\n         TITLE 'LC0010: Process OUTPUT Primary Command'\n\n         PUSH  USING\n\nLC0010   DS    0H\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Routine   : LC0010                                                 *\n*                                                                     *\n*  Abstract  : Process OUTPUT primary command                         *\n*                                                                     *\n*  Inputs    : R1 : ---> A(@_Dynam)                                   *\n*                        A(31-bit Stack Pointer)                      *\n*                        A(24-bit Stack Pointer)                      *\n*                        A(line command operands)                     *\n*                        Length of operands                           *\n*  Outputs   : R15: 0                                                 *\n*                                                                     *\n*  Notes     :                                                        *\n*                                                                     *\n*  History:    2003/10/07 SDDA030 - V2.21                             *\n*                                   New                               *\n*              2006/04/21 SDDA030 - V2.24                             *\n*                                   Used standardised calling sequence*\n*                                                                     *\n*              ____/__/__ _______                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         STM   R14,R12,12(R13)          Save callers registers\n         LARL  R11,LC_Literals          Point to our literals\n         USING (LC_Literals,LC_Literals_End),R11 Tell the assembler\n\n         L     R12,0(0,R1)              A(@_Dynam)\n         USING @_Dynam,R12              Tell the assembler\n\n*-------------------------------------------------------------------*\n*    Get an area on the stack for our local storage                 *\n*-------------------------------------------------------------------*\n         L     R2,4(0,R1)               A(31-bit stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         SSCSTACK PUSH,                 Get stack area                 +\n               LEN=@LC_Dynam_Length,     this long                     +\n               STACK=(R2)                using this stack\n\n         LR    R3,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LHI   R1,@LC_Dynam_Length       Its length\n         LA    R14,0                    Clear source address\n         LA    R15,0                     and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R3                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*-------------------------------------------------------------------*\n         ST    R13,4(0,R1)              Chain\n         ST    R1,8(0,R13)               saveareas\n         LR    R13,R1                   Load dynam base\n         USING @LC_Dynam,R13            Assign a base\n         L     R15,@LC_Dynam+4          Get A(HSA)\n         LM    R0,R3,20(R15)            Restore callers registers\n\n         L     R15,4(0,R1)              A(31-bit Stack Pointer)\n         ST    R15,@LC_31Bit_Stack_Ptr_Ptr Save it\n         L     R15,8(0,R1)              A(24-bit Stack Pointer)\n         ST    R15,@LC_24Bit_Stack_Ptr_Ptr Save it\n\n\n*-------------------------------------------------------------------*\n*    This option is not yet supported                               *\n*-------------------------------------------------------------------*\n         LA    R15,=CL8'VDEFINE'        ISPF Function\n         ST    R15,@LC_ISPF_Parms       Save it\n         LA    R15,=CL8'CHAR'           Character variables\n         ST    R15,@LC_ISPF_Parms+12 Save it\n\n         LA    R15,=CL8'ZEDSMSG'        Variable name\n         ST    R15,@LC_ISPF_Parms+4     Save it\n         LA    R15,LC_Unsupport_SMsg    Short message\n         ST    R15,@LC_ISPF_Parms+8     Save it\n         LA    R15,=AL4(L'LC_Unsupport_SMsg) Length of message\n         ST    R15,@LC_ISPF_Parms+16 Save it\n         OI    @LC_ISPF_Parms+16,X'80' Flag end of list\n         LA    R1,@LC_ISPF_Parms        A(Parmlist)\n         L     R15,@_ISPLINK            A(ISPF Interface)\n         BASR  R14,R15                  Go do it\n\n         LA    R15,=CL8'ZEDLMSG'        Variable name\n         ST    R15,@LC_ISPF_Parms+4     Save it\n         LA    R15,LC_Unsupport_LMsg    Long message\n         ST    R15,@LC_ISPF_Parms+8     Save it\n         LA    R15,=AL4(L'LC_Unsupport_LMsg) Length of message\n         ST    R15,@LC_ISPF_Parms+16 Save it\n         OI    @LC_ISPF_Parms+16,X'80' Flag end of list\n         LA    R1,@LC_ISPF_Parms        A(Parmlist)\n         L     R15,@_ISPLINK            A(ISPF Interface)\n         BASR  R14,R15                  Go do it\n\n         LA    R15,=CL8'SETMSG'         Yes, ISPF Function\n         ST    R15,@LC_ISPF_Parms       Save it\n         LA    R15,=CL8'ISRZ001'        A(Message ID)\n         ST    R15,@LC_ISPF_Parms+4     Save it\n         OI    @LC_ISPF_Parms+4,X'80' Mark end of list\n         LA    R1,@LC_ISPF_Parms        Point to ISPF parms\n         L     R15,@_ISPLINK            A(Interface routine)\n         BASR  R14,R15                  Go do it\n\n         LA    R15,0                    Clear return code\n         J     LC9010                   and exit\n\n\nLC9010   DS    0H\n*-------------------------------------------------------------------*\n*    Free up our local storage ...                                  *\n*-------------------------------------------------------------------*\n         LR    R3,R15                   Save return code\n\n         LA    R1,@LC_Dynam             A(Local storage)\n         L     R2,@LC_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         L     R13,4(0,R13)             Rescue A(HSA)\n\n         SSCSTACK POP,                  Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=(R2)                on this stack\n\n         LR    R15,R3                   Restore return code\n\n*-------------------------------------------------------------------*\n*    ... and return to caller                                       *\n*-------------------------------------------------------------------*\n         L     R14,12(0,R13)            Restore return address\n         LM    R0,R12,20(R13)           Restore regs other than R15\n         BSM   0,R14                    and return\n\nLC_Literals DS  0H\n\nLC_Unsupport_SMsg     DC   C'Unsupported'\nLC_Unsupport_LMsg     DC   C'This command is not yet implemented'\n\n\n         LTORG\n\nLC_Literals_End DS  0H\n\n\n@LC_Dynam                 DSECT\n                          DS    18F    O/S style save area\n@LC_31Bit_Stack_Ptr_Ptr   DS    AL4    A(31-bit Stack Ptr)\n@LC_24Bit_Stack_Ptr_Ptr   DS    AL4    A(24-bit Stack Ptr)\n                          DS    0F     Alignment\n@LC_ISPF_Parms            DS    5AL4   ISPF Parm List\n@LC_ISPF_VCOPY_Lens       DS    FL4    ZCMD Length\n@LC_ISPF_VCOPY_Ptrs       DS    AL4    ZCMD Address\n@LC_ZCMD_Ptr              DS    AL4    A(ZCMD)\n@LC_ZCMD_Length           DS    FL4    Length of ZCMD\n                          DS    0D\n@LC_Dynam_Length          EQU   *-@LC_Dynam\n\n\n&PGMNAME CSECT\n\n         DROP  ,\n         POP   USING\n         TITLE 'S00010: WAIT for subtasks to complete'\n\n         PUSH  USING\n\nS00010   DS    0H\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Routine   : S00010                                                 *\n*                                                                     *\n*  Abstract  : WAIT for subtasks to complete, DETACH them, and free   *\n*              SubTask_Area                                           *\n*                                                                     *\n*  Inputs    : R1 : ---> A(@_Dynam)                                   *\n*                        A(31-bit Stack Pointer)                      *\n*                        A(24-bit Stack Pointer)                      *\n*  Outputs   : R15: 0:                                                *\n*                                                                     *\n*  Notes     :                                                        *\n*                                                                     *\n*  History:    2003/10/07 SDDA030 - V2.21                             *\n*                                   New.                              *\n*              2006/04/21 SDDA030 - V2.24                             *\n*                                   Used standardised calling sequence*\n*              ____/__/__ _______                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         STM   R14,R12,12(R13)          Save callers registers\n         LARL  R11,S_Literals           Point to our literals\n         USING (S_Literals,S_Literals_End),R11 Tell the assembler\n\n         L     R12,0(0,R1)              A(@_Dynam)\n         USING @_Dynam,R12              Tell the assembler\n\n*-------------------------------------------------------------------*\n*    Get an area on the stack for our local storage                 *\n*-------------------------------------------------------------------*\n         L     R2,4(0,R1)               A(31-bit stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         SSCSTACK PUSH,                 Get stack area                 +\n               LEN=@S_Dynam_Length,      this long                     +\n               STACK=(R2)                using this stack\n\n         LR    R3,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LHI   R1,@S_Dynam_Length        Its length\n         LA    R14,0                    Clear source address\n         LA    R15,0                     and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R3                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*-------------------------------------------------------------------*\n         ST    R13,4(0,R1)              Chain\n         ST    R1,8(0,R13)               saveareas\n         LR    R13,R1                   Load dynam base\n         USING @S_Dynam,R13             Assign a base\n         L     R15,@S_Dynam+4           Get A(HSA)\n         LM    R0,R3,20(R15)            Restore callers registers\n\n         L     R15,4(0,R1)              A(31-bit Stack Pointer)\n         ST    R15,@S_31Bit_Stack_Ptr_Ptr Save it\n         L     R15,8(0,R1)              A(24-bit Stack Pointer)\n         ST    R15,@S_24Bit_Stack_Ptr_Ptr Save it\n\n*-------------------------------------------------------------------*\n*    If there is a Subtask_Area ...                                 *\n*-------------------------------------------------------------------*\n         ICM   R1,B'1111',@_SubTask_Area_Ptr Get A(SubTask Area)\n         JZ    S00100                  None, exit quick smart\n         ICM   R0,B'1111',SubTask_Area_Hdr_Count-SubTask_Area_Hdr(R1)\n         JZ    S00100                  None, go free it\n\n*-------------------------------------------------------------------*\n*    ... get an area for our ECB list                               *\n*-------------------------------------------------------------------*\n         MHI   R0,4                     (# ents * len of ECB ptr)\n\n         L     R2,@S_31Bit_Stack_Ptr_Ptr A(31-bit stack Ptr)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         SSCSTACK PUSH,                 Get stack area                 +\n               LEN=(0),                  this long                     +\n               STACK=(R2)                using this stack\n\n         ST    R1,@S_ECBLIST_Ptr       Save it\n\nS00020   DS    0H\n*-------------------------------------------------------------------*\n*    Build our ECBLIST, containing a pointer to each ECB that has   *\n*   not yet been POSTed. If the ECB has been POSTed, DETACH the TCB,*\n*   unless we have already done so.                                 *\n*-------------------------------------------------------------------*\n         ICM   R15,B'1111',@_SubTask_Area_Ptr A(SubTask Area)\n         JZ    S00100                  None, all done\n         ICM   R14,B'1111',SubTask_Area_Hdr_Count-SubTask_Area_Hdr(R15)\n         JZ    S00100                  None, exit\n         AHI   R15,SubTask_Area_Hdr_Length A(1st SubTask Entry)\n         ICM   R1,B'1111',@S_ECBLIST_Ptr A(Our ECBLIST)\n         JZ    S00100                  None, all done\nS00030   DS    0H\n         TM    SubTask_Area_Ent_ECB-SubTask_Area_Ent(R15),X'40' POSTed?\n         JO    S00040                  Yes, go DETACH TCB\n         ST    R15,0(0,R1)             No, Add to ECBLIST\n         AHI   R1,4                    Bump ECBLIST Ptr\n         J     S00050                  and skip\nS00040   DS    0H\n         ICM   R0,B'1111',SubTask_Area_Ent_TCB-SubTask_Area_Ent(R15)\n         JZ    S00050                  No TCB, skip\n         STM   R14,R1,@S_RSave         Save our registers\n         LA    R1,SubTask_Area_Ent_TCB-SubTask_Area_Ent(R15)\n         DETACH (1),                    Yes, DETACH it                 +\n               STAE=NO                   without invoking ESTAE Rtn\n         LM    R14,R1,@S_RSave         Restore our registers\n         LA    R0,0                    Clear TCB pointer\n         ST    R0,SubTask_Area_Ent_TCB-SubTask_Area_Ent(R15)\nS00050   DS    0H\n         AHI   R15,SubTask_Area_Ent_Length A(Stuff for next TCB)\n         BRCT  R14,S00030              and check it out\n\n*-------------------------------------------------------------------*\n*    If there are any ECBs not yet POSTed ...                       *\n*-------------------------------------------------------------------*\n         L     R0,@S_ECBLIST_Ptr       A(ECBLIST)\n         CR    R0,R1                   Anything in it?\n         JE    S00100                  No, we're all done\n\n*-------------------------------------------------------------------*\n*    ... WAIT for them to complete ...                              *\n*-------------------------------------------------------------------*\n         AHI   R1,-4                   Yes, back up to A(last ECB)\n         OI    0(R1),X'80'             Flag it as last\n         SLR   R1,R0                   Calculate nbr\n         SRL   R1,2                     of ECBS in\n         AHI   R1,1                     list\n         LR    R0,R1                   In proper register\n         L     R1,@S_ECBLIST_Ptr       A(ECB list)\n         WAIT  (R0),ECBLIST=(R1)       Wait for our subtasks\n\n*-------------------------------------------------------------------*\n*    ... and do it all again                                        *\n*-------------------------------------------------------------------*\n         J     S00020                  and do it all again\n\nS00100   DS    0H\n*-------------------------------------------------------------------*\n*    We're all done here, so free up the ECBLIST, if required ...   *\n*-------------------------------------------------------------------*\n         ICM   R1,B'1111',@S_ECBLIST_Ptr A(ECBLIST)\n         JZ    S00110                  None, skip\n\n         L     R2,@S_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         SSCSTACK POP,                  Free the ECBLIST               +\n               ADDR=(R1),                starting here                 +\n               STACK=(R2)                on this stack\n\nS00110   DS    0H\n*-------------------------------------------------------------------*\n*    ... and the SubTask_Area, if required ...                      *\n*-------------------------------------------------------------------*\n         ICM   R1,B'1111',@_SubTask_Area_Ptr A(SubTask Area)\n         JZ    S00120                  Nothing, skip\n         L     R0,SubTask_Area_Hdr_Len-SubTask_Area_Hdr(0,R1) Length\n\n         BASR  R2,0\n         USING (*,S00120_End-1),R2\n         STORAGE RELEASE,               Free the SubTask Area          +\n               ADDR=(1),                 starting here                 +\n               LENGTH=(0)                for this long\nS00120_End DS  0H\n         DROP  R2\n\n         LA    R0,0                     Clear work reg\n         ST    R0,@_SubTask_Area_Ptr    No more SubTask Area\n\nS00120   DS    0H\n*-------------------------------------------------------------------*\n*    ... and exit.                                                  *\n*-------------------------------------------------------------------*\n         LA    R15,0                    Clear return code\n         J     S90010                   and exit\n\nS90010   DS    0H\n*-------------------------------------------------------------------*\n*    Free up our local storage ...                                  *\n*-------------------------------------------------------------------*\n         LR    R3,R15                   Save return code\n\n         LA    R1,@S_Dynam              A(Local storage)\n         L     R2,@S_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         L     R13,4(0,R13)             Rescue A(HSA)\n\n         SSCSTACK POP,                  Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=(R2)                on this stack\n\n         LR    R15,R3                   Restore return code\n\n*-------------------------------------------------------------------*\n*    ... and return to caller                                       *\n*-------------------------------------------------------------------*\n         L     R14,12(0,R13)            Restore return address\n         LM    R0,R12,20(R13)           Restore callers regs\n         BSM   0,R14                    and return\n\nS_Literals  DS  0H\n\n         LTORG\n\nS_Literals_End  DS  0H\n\n\n@S_Dynam                  DSECT\n@S_SaveArea               DS    18F    O/S style save area\n@S_31Bit_Stack_Ptr_Ptr    DS    AL4    A(31-bit Stack Ptr)\n@S_24Bit_Stack_Ptr_Ptr    DS    AL4    A(24-bit Stack Ptr)\n\n@S_ECBLIST_Ptr            DS    AL4    A(ECBLIST)\n@S_RSave                  DS    4FL4   Temp reg save area\n\n                          DS    0D\n@S_Dynam_Length           EQU   *-@S_Dynam\n\n\n&PGMNAME CSECT\n\n         DROP  ,\n         POP   USING\n         TITLE 'T00010: Return SMS Storgrp'\n\n         PUSH  USING\n\nT00010   DS    0H\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Routine   : T00010                                                 *\n*                                                                     *\n*  Abstract  : Return pointers to the STORGRP name and SMS Status     *\n*              for a volser                                           *\n*                                                                     *\n*  Inputs    : R1 : ---> A(@_Dynam)                                   *\n*                        A(31-bit Stack Pointer)                      *\n*                        A(24-bit Stack Pointer)                      *\n*                        A(Volser)                                    *\n*                        A(VLD Anchor)                                *\n*  Outputs   : R15: 0: STORGRP found                                  *\n*                   4: STORGRP not found (??)                         *\n*                   8: SMS not active                                 *\n*              R0    : A(SMS Status)                                  *\n*              R1    : A(STORGRP Len, Name)                           *\n*                                                                     *\n*  Notes     : To try to reduce the number of times we have to call   *\n*              SMS, whenever we ask SMS about the StorGrp for a       *\n*              volume, we also ask for all the volsers in that        *\n*              StorGrp. We chain these VLDs (Volume Definitions), and *\n*              search them for the volser before asking SMS for the   *\n*              StorGrp.                                               *\n*              If A(Volser) is 0, all in-storage VLDs, chained off    *\n*              VLD Anchor, are freed.                                 *\n*              The IEFSSREQs to SMS are modelled on those found in    *\n*              SHOWMVS (Thanks Gilbert/Roland).                       *\n*              We clobber the VLDPID field and the next 2 bytes with: *\n*               0-3 A(Next VLD)                                       *\n*               4-7 Length of VLD                                     *\n*               8-9 SMS System number                                 *\n*                                                                     *\n*  History:    2002/03/11 SDDA030 - V2.17                             *\n*                                 - New                               *\n*              2003/10/07 SDDA030 - V2.21                             *\n*                                 - Corrected bug getting correct SMS *\n*                                   status (we make an additional     *\n*                                   call to SMS to get the system-ids)*\n*              2004/10/15 SDDA030 - V2.22                             *\n*                                 - Corrected bug where we overlayed  *\n*                                   the SMS System number with the    *\n*                                   length of the VLD.                *\n*                                 - Resequenced labels                *\n*              2006/04/21 SDDA030 - V2.24                             *\n*                                 - Used standardised calling sequence*\n*              ____/__/__ _______                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         STM   R14,R12,12(R13)          Save callers registers\n         LARL  R11,T_Literals           Point to our literals\n         USING (T_Literals,T_Literals_End),R11 Tell the assembler\n\n         L     R12,0(0,R1)              A(@_Dynam)\n         USING @_Dynam,R12              Tell the assembler\n\n*-------------------------------------------------------------------*\n*    Get an area on the stack for our local storage                 *\n*-------------------------------------------------------------------*\n         L     R2,4(0,R1)               A(31-bit stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         SSCSTACK PUSH,                 Get stack area                 +\n               LEN=@T_Dynam_Length,      this long                     +\n               STACK=(R2)                using this stack\n\n         LR    R3,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LHI   R1,@T_Dynam_Length        Its length\n         LA    R14,0                    Clear source address\n         LA    R15,0                     and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R3                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*-------------------------------------------------------------------*\n         ST    R13,4(0,R1)              Chain\n         ST    R1,8(0,R13)               saveareas\n         LR    R13,R1                   Load dynam base\n         USING @T_Dynam,R13             Assign a base\n         L     R15,@T_Dynam+4           Get A(HSA)\n         LM    R0,R3,20(R15)            Restore callers registers\n\n         L     R15,4(0,R1)              A(31-bit Stack Pointer)\n         ST    R15,@T_31Bit_Stack_Ptr_Ptr Save it\n         L     R15,8(0,R1)              A(24-bit Stack Pointer)\n         ST    R15,@T_24Bit_Stack_Ptr_Ptr Save it\n\n*-------------------------------------------------------------------*\n*    If we have a volser ...                                        *\n*-------------------------------------------------------------------*\n         ICM   R3,B'1111',12(R1)       Get A(Volser)\n         JZ    T00130                  None, free VLDs\n\n*-------------------------------------------------------------------*\n*    ... check the existing VLDs for the volser                     *\n*-------------------------------------------------------------------*\n         L     R1,16(0,R1)             A(VLD Chain Anchor)\n         AHI   R1,-(VLDPID-VLD)        Pretend we are a VLD Ptr\n         NI    @T_Volser_in_VLD,X'FF'-L'@T_Volser_in_VLD Off flag\n         LHI   R15,-1                  We have no\n         STH   R15,@T_SMS_SYSNum        no SMS System nbr\n         J     T00050                  and run chain\nT00020   DS    0H\n         ICM   R14,B'1111',VLDPCNT-VLD(R1) Number vols\n         JNP   T00050                  None, try next VLD\n         LA    R15,VLDEF-VLD(0,R1)     OK, point to 1st\nT00030   DS    0H\n         CLC   =HL2'6',VLDVSLEN-VLDEF(R15)  Right length for a volser?\n         JNE   T00040                  No, skip this entry\n         CLC   VLDVSER-VLDEF(L'VLDVSER,R15),0(R3)\n         JE    T00110                  Found our volser, skip\nT00040   DS    0H\n         A     R15,VLDPLEN-VLD(0,R1)   A(Next VLD)\n         BRCT  R14,T00030              and check it out\n         TM    @T_Volser_in_VLD,L'@T_Volser_in_VLD Should it be here?\n         JNO   T00050                  Not necessarily, OK\n         DC    H'0'                    It should be, ABEND\nT00050   DS    0H\n         ICM   R15,B'1111',VLDPID-VLD(R1) A(Next VLD)\n         JZ    T00060                  None, skip\n         LR    R1,R15                  Load up proper register\n         MVC   @T_SMS_SYSNum,VLDPID+8-VLD(R1) Save SMS Sys 'number'\n         J     T00020                  and check it out\n\nT00060   DS    0H\n*-------------------------------------------------------------------*\n*    We couldn't find the volser in our in-storage VLDs (meaning    *\n*   that this is the 1st volser we have come across in this         *\n*   STORGRP), so go get the STORGRP name from SMS.                  *\n*-------------------------------------------------------------------*\n         ST    R1,@T_Last_VLD_Ptr      Save A(Last VLD)\n         LH    R15,@T_SMS_SYSNum       Get SMS system 'number'\n         CHI   R15,-1                  Do we have one?\n         JNE   T00100                  Yes, OK\n\n*-------------------------------------------------------------------*\n*    This is the 1st VLD we are getting - before we do so, get the  *\n*   base configuration data (we have to know our system 'number' to *\n*   get the correct SMS status for the volumes).                    *\n*-------------------------------------------------------------------*\n         L     R15,CVTPTR              Point to CVT\n         L     R15,CVTJESCT-CVTMAP(,R15) JES Communication Table\n         L     R15,JESCTEXT-JESCT(,R15)  JESCT Extension\n         ICM   R15,B'1111',JESSMSIB-JESPEXT(R15) SMS SSIB\n         JZ    T00100                  SMS unavailable, skip\n\n         XC    @T_SMS_SSOB,@T_SMS_SSOB Clear the SSOB\n         MVI   @T_SMS_SSOB+SSOBLEN+1-SSOB,SSOBHSIZ Set length\n         MVC   @T_SMS_SSOB+SSOBID-SSOB(L'SSOBID),=C'SSOB' ID it\n         MVI   @T_SMS_SSOB+SSOBFUNC+1-SSOB,SSOBSSMS Function\n         L     R15,CVTPTR              Point to CVT\n         L     R15,CVTJESCT-CVTMAP(,R15) JES Communication Table\n         L     R15,JESCTEXT-JESCT(,R15)  JESCT Extension\n         L     R15,JESSMSIB-JESPEXT(R15) SMS SSIB\n         ST    R15,@T_SMS_SSOB+SSOBSSIB-SSOB Save it\n\n         LA    R15,@T_SMS_SSSA         SSSA Work Area\n         ST    R15,@T_SMS_SSOB+SSOBINDV-SSOB Update SSOB\n\n         XC    @T_SMS_SSSA,@T_SMS_SSSA Clear SSSA\n         LHI   R15,L'@T_SMS_SSSA       Get its length\n         STH   R15,@T_SMS_SSSA+SSSALEN-IEFSSSA Update SSSA\n         MVC   @T_SMS_SSSA+SSSAID-IEFSSSA(L'SSSAID),=C'SSSA' ID it\n         MVI   @T_SMS_SSSA+SSSAVER+1-IEFSSSA,SSOBSSVR Version\n         MVI   @T_SMS_SSSA+SSSASFN+1-IEFSSSA,SSSAACTV Sub-Function\n         MVI   @T_SMS_SSSA+SSSAIFLG-IEFSSSA,SSSANAUT Non-APF\n\n         MVI   @T_SMS_SSSA+SSSA1TYP-IEFSSSA,SSSA1CON Return Config\n\n         LHI   R15,L'@T_SMS_BCD                Len of Config Data\n         ST    R15,@T_SMS_SSSA+SSSA1LEN-IEFSSSA Save it\n         LA    R15,@T_SMS_BCD                  A(Config Data)\n         ST    R15,@T_SMS_SSSA+SSSA1PTR-IEFSSSA Save the address\n\n         LA    R15,@T_SMS_SSOB         A(SSOB)\n         ST    R15,@T_SMS_SSOB_Ptr     Save the address\n         LA    R1,@T_SMS_SSOB_Ptr      Point to the address\n\n         IEFSSREQ                      Call SMS\n\n         LTR   R15,R15                 SMS active?\n         JNZ   T00100                  No, exit quick smart\n\n         ICM   R15,B'1111',@T_SMS_SSOB+SSOBRETN-SSOB Check RC\n         JNZ   T00100                  Not good, skip SMS stuff\n\n*-------------------------------------------------------------------*\n*    We now have an IGDBCD, which is not documented or distributed  *\n*   by IBM. From SHOWMVS, we know that this data will contain our   *\n*   system ID (assuming, of course, we're SMSd). Rather than define *\n*   our own DSECT for this area, we search it for our system-id; if *\n*   we find it, we save our system 'number'.                        *\n*-------------------------------------------------------------------*\n         L     R1,CVTPTR                A(CVT)\n         LA    R1,CVTSNAME-CVT(R1)      A(Our System name)\n         LA    R15,@T_SMS_BCD           Point to config data\n         LHI   R14,L'@T_SMS_BCD-(L'CVTSNAME-1) Len of config data\nT00070   DS    0H\n         CLC   0(L'CVTSNAME,R1),0(R15)  Found our system?\n         JE    T00080                   Yes, skip\n         LA    R15,1(0,R15)             Not yet, bump pointer\n         BRCT  R14,T00070               and keep checking\n         J     T80010                   Not good, exit with error\nT00080   DS    0H\n         LA    R14,@T_SMS_BCD           A(Start of area)\n         LR    R0,R15                   Save A(Our name)\nT00090   DS    0H\n         AHI   R15,-L'CVTSNAME          Back up to prev system\n         CR    R15,R14                  Too far?\n         JL    T80010                   Yes, we're lost\n         TRT   0(L'CVTSNAME,R15),T_TRT  A valid sysname?\n         JZ    T00090                   Yes, check prev\n\n         AHI   R0,-L'CVTSNAME           Offset of last good name\n         SR    R0,R15                   offset to our sysname\n         SRDL  R0,32                    into correct register\n         LA    R15,L'CVTSNAME           Len of 1 system name\n         DR    R0,R15                   Calc system 'number'\n         STH   R1,@T_SMS_SYSNum         Save it\n\nT00100   DS    0H\n         L     R15,CVTPTR              Point to CVT\n         L     R15,CVTJESCT-CVTMAP(,R15) JES Communication Table\n         L     R15,JESCTEXT-JESCT(,R15)  JESCT Extension\n         ICM   R15,B'1111',JESSMSIB-JESPEXT(R15) SMS SSIB\n         JZ    T80010                  SMS unavailable, skip\n\n         XC    @T_SMS_SSOB,@T_SMS_SSOB Clear the SSOB\n         MVI   @T_SMS_SSOB+SSOBLEN+1-SSOB,SSOBHSIZ Set length\n         MVC   @T_SMS_SSOB+SSOBID-SSOB(L'SSOBID),=C'SSOB' ID it\n         MVI   @T_SMS_SSOB+SSOBFUNC+1-SSOB,SSOBSSMS Function\n         L     R15,CVTPTR              Point to CVT\n         L     R15,CVTJESCT-CVTMAP(,R15) JES Communication Table\n         L     R15,JESCTEXT-JESCT(,R15)  JESCT Extension\n         L     R15,JESSMSIB-JESPEXT(R15) SMS SSIB\n         ST    R15,@T_SMS_SSOB+SSOBSSIB-SSOB Save it\n\n         LA    R15,@T_SMS_SSSA         SSSA Work Area\n         ST    R15,@T_SMS_SSOB+SSOBINDV-SSOB Update SSOB\n\n         XC    @T_SMS_SSSA,@T_SMS_SSSA Clear SSSA\n         LHI   R15,L'@T_SMS_SSSA       Get its length\n         STH   R15,@T_SMS_SSSA+SSSALEN-IEFSSSA Update SSSA\n         MVC   @T_SMS_SSSA+SSSAID-IEFSSSA(L'SSSAID),=C'SSSA' ID it\n         MVI   @T_SMS_SSSA+SSSAVER+1-IEFSSSA,SSOBSSVR Version\n         MVI   @T_SMS_SSSA+SSSASFN+1-IEFSSSA,SSSAACTV Sub-Function\n         MVI   @T_SMS_SSSA+SSSAIFLG-IEFSSSA,SSSANAUT Non-APF\n\n         MVI   @T_SMS_SSSA+SSSA1TYP-IEFSSSA,SSSA1VOL Return VLD\n         MVI   @T_SMS_SSSA+SSSA1CNT+3-IEFSSSA,1   1 construct\n         MVI   @T_SMS_SSSA+SSSA1NML+1-IEFSSSA,L'UCBVOLI  Volser Len\n         MVC   @T_SMS_SSSA+SSSA1NAM-IEFSSSA(L'UCBVOLI),0(R3)\n\n         LHI   R15,L'@T_SMS_VLD                Len of VLD\n         ST    R15,@T_SMS_SSSA+SSSA1LEN-IEFSSSA Save it\n         LA    R15,@T_SMS_VLD                  Point VLD\n         ST    R15,@T_SMS_SSSA+SSSA1PTR-IEFSSSA Save the address\n\n         LA    R15,@T_SMS_SSOB         A(SSOB)\n         ST    R15,@T_SMS_SSOB_Ptr     Save the address\n         LA    R1,@T_SMS_SSOB_Ptr      Point to the address\n\n         IEFSSREQ                      Call SMS\n\n         LTR   R15,R15                 SMS active?\n         JNZ   T80010                  No, exit quick smart\n\n         ICM   R15,B'1111',@T_SMS_SSOB+SSOBRETN-SSOB Check RC\n         JNZ   T80020                  Not good, skip SMS stuff\n\n*-------------------------------------------------------------------*\n*    We have the SMS Storgrp for this volser, so now make another   *\n*   request to SMS for all volsers in this STORGRP.                 *\n*-------------------------------------------------------------------*\n         XC    @T_SMS_SSOB,@T_SMS_SSOB Clear the SSOB\n         MVI   @T_SMS_SSOB+SSOBLEN+1-SSOB,SSOBHSIZ Set length\n         MVC   @T_SMS_SSOB+SSOBID-SSOB(L'SSOBID),=C'SSOB' ID it\n         MVI   @T_SMS_SSOB+SSOBFUNC+1-SSOB,SSOBSSMS Function\n         L     R15,CVTPTR              Point to CVT\n         L     R15,CVTJESCT-CVTMAP(,R15) JES Communication Table\n         L     R15,JESCTEXT-JESCT(,R15)  JESCT Extension\n         L     R15,JESSMSIB-JESPEXT(R15) SMS SSIB\n         ST    R15,@T_SMS_SSOB+SSOBSSIB-SSOB Save it\n\n         LA    R15,@T_SMS_SSSA         SSSA Work Area\n         ST    R15,@T_SMS_SSOB+SSOBINDV-SSOB Update SSOB\n\n         XC    @T_SMS_SSSA,@T_SMS_SSSA Clear SSSA\n         LHI   R15,L'@T_SMS_SSSA       Get its length\n         STH   R15,@T_SMS_SSSA+SSSALEN-IEFSSSA Update SSSA\n         MVC   @T_SMS_SSSA+SSSAID-IEFSSSA(L'SSSAID),=C'SSSA' ID it\n         MVI   @T_SMS_SSSA+SSSAVER+1-IEFSSSA,SSOBSSVR Version\n         MVI   @T_SMS_SSSA+SSSASFN+1-IEFSSSA,SSSAACTV Sub-Function\n         MVI   @T_SMS_SSSA+SSSAIFLG-IEFSSSA,SSSANAUT Non-APF\n\n         MVI   @T_SMS_SSSA+SSSA1TYP-IEFSSSA,SSSA1SGV Return VLDs\n         MVI   @T_SMS_SSSA+SSSA1CNT+3-IEFSSSA,1   1 construct\n         MVC   @T_SMS_SSSA+SSSA1NML-IEFSSSA(L'SSSA1NML),@T_SMS_VLD+VLDS+\n               GLEN-VLD               Len of StorGrp Name\n         MVC   @T_SMS_SSSA+SSSA1NAM-IEFSSSA(L'SSSA1NAM),@T_SMS_VLD+VLDS+\n               TGRP-VLD               StorGrp Name\n\n         LA    R15,@T_SMS_SSOB         A(SSOB)\n         ST    R15,@T_SMS_SSOB_Ptr     Save the address\n         LA    R1,@T_SMS_SSOB_Ptr      Point to the address\n\n         IEFSSREQ                      Call SMS\n\n         LTR   R15,R15                 SMS active?\n         JNZ   T80010                  No, exit quick smart\n\n         ICM   R15,B'1111',@T_SMS_SSOB+SSOBRETN-SSOB Check RC\n         JNZ   T80020                  Not good, skip SMS stuff\n\n*-------------------------------------------------------------------*\n*    Chain the new VLD to the others (note that we use the ID field *\n*   (VLDPID) for this) ...                                          *\n*-------------------------------------------------------------------*\n         ICM   R1,B'1111',@T_SMS_SSSA+SSSA1PTR-IEFSSSA A(Returned VLD)\n         JZ    T80020                  Nothing, not good\n         L     R15,@T_Last_VLD_Ptr     OK, A(Last VLD)\n         ST    R1,VLDPID-VLD(0,R15)    Chain this one\n\n*-------------------------------------------------------------------*\n*    ... set up our fields in the new VLD ...                       *\n*-------------------------------------------------------------------*\n         LA    R15,0                   Clear forward pointer ...\n         ST    R15,VLDPID-VLD(0,R1)     ... in the VLD\n         L     R15,@T_SMS_SSSA+SSSA1LEN-IEFSSSA Len of VLD\n         ST    R15,VLDPID+4-VLD(R1)    Save length (for FREEMAIN)\n         MVC   VLDPID+8-VLD(L'@T_SMS_SYSNum,R1),@T_SMS_SYSNum\n\n*-------------------------------------------------------------------*\n*    ... and go check it out.                                       *\n*-------------------------------------------------------------------*\n         OI    @T_Volser_in_VLD,L'@T_Volser_in_VLD It should be here\n         J     T00020                  And check it out\n\nT00110   DS    0H\n*-------------------------------------------------------------------*\n*    We have found our volser in the VLD, set up our return         *\n*   pointers, and exit. At this point, R15 points to the VLDEF      *\n*   for our volume.                                                 *\n*-------------------------------------------------------------------*\n         LA    R0,0                          Assume no SMS Status\n         LH    R1,@T_SMS_SYSNum              Get SMS System 'number'\n         LTR   R1,R1                         Any?\n         JM    T00120                        No, unknown SMS Status\n         MHI   R1,L'VLDSSTAT                 r1 = Offset within status\n         LR    R0,R15                        A(Volume array)\n         A     R0,VLDSYSOF-VLDEF(R15)        A(Status fields)\n         AR    R0,R1                         A(Status on our system)\n\nT00120   DS    0H\n         LA    R1,VLDSGLEN-VLDEF(R15)        A(Storage group length)\n\n         LA    R15,0                         Clear return code\n         J     T90010                        and exit\n\nT00130   DS    0H\n*-------------------------------------------------------------------*\n*    We have been passed a Volser pointer of 0 - by convention,     *\n*   this is a request that we free any VLDs that have been gotten   *\n*   for us                                                          *\n*-------------------------------------------------------------------*\n         ICM   R4,B'1111',16(R1)        VLD Chain Anchor\n         JZ    T00150                   Nothing, OK\nT00140   DS    0H\n         LR    R1,R4                    A(Storage to free)\n         L     R0,VLDPID+4-VLD(0,R1)    Length to free\n         L     R4,VLDPID-VLD(0,R4)      Rescue forward pointer\n         BASR  R2,0\n         USING (*,T00140_End-1),R2\n         STORAGE RELEASE,               Free the old table             +\n               ADDR=(1),                 starting here                 +\n               LENGTH=(0)                for this long\nT00140_End DS  0H\n         DROP  R2\n\n         LTR   R4,R4                    Is there another one?\n         JNZ   T00140                   Yes, go free it\n\nT00150   DS    0H\n         LA    R0,0                     No SMS Status\n         LA    R1,0                     No STORGRP\n         LA    R15,0                    All OK\n         J     T90010                   and exit\n\nT80010   DS    0H\n*-------------------------------------------------------------------*\n*    SMS unavailable, set RC and exit                               *\n*-------------------------------------------------------------------*\n         LA    R1,0                     No SMS StorGrp\n         LA    R0,0                      or status\n         LA    R15,8                    SMS not available\n         J     T90010                   and exit\n\nT80020   DS    0H\n*-------------------------------------------------------------------*\n*    SSOBRETN not 0 on return from SSREQ                            *\n*-------------------------------------------------------------------*\n         LA    R1,0                     No SMS StorGrp\n         LA    R0,0                      or status\n         LA    R15,4                    STORGRP not found\n         J     T90010                   and exit\n\nT90010   DS    0H\n*-------------------------------------------------------------------*\n*    Free up our local storage ...                                  *\n*-------------------------------------------------------------------*\n         L     R14,4(0,R13)             A(HSA)\n         STM   R15,R1,16(R14)           Save rc, A(status), A(STORGRP)\n\n         LA    R1,@T_Dynam              A(Local storage)\n         L     R2,@T_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         L     R13,4(0,R13)             Rescue A(HSA)\n\n         SSCSTACK POP,                  Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=(R2)                on this stack\n\n\n*-------------------------------------------------------------------*\n*    ... and return to caller (note that we updated the callers     *\n*   savearea:   +16: Return Code       R15                          *\n*               +20: A(SMS Status)     R0                           *\n*               +24: A(SMS STORGRP)    R1                           *\n*-------------------------------------------------------------------*\n         LM    R14,R12,12(R13)          Restore callers regs\n         BSM   0,R14                    and return\n\nT_Literals  DS  0H\n\nT_TRT    DC    256XL1'FF'\n         ORG   T_TRT+C' '\n         DC    X'00'\n         ORG   T_TRT+C'$'\n         DC    X'00'\n         ORG   T_TRT+C'#'\n         DC    X'00'\n         ORG   T_TRT+C'@'\n         DC    X'00'\n         ORG   T_TRT+C'A'\n         DC    9XL1'00'\n         ORG   T_TRT+C'J'\n         DC    9XL1'00'\n         ORG   T_TRT+C'S'\n         DC    8XL1'00'\n         ORG   T_TRT+C'0'\n         DC    10XL1'00'\n         ORG\n\n         LTORG\n\nT_Literals_End  DS  0H\n\n\n@T_Dynam                  DSECT\n                          DS    18F    O/S style save area\n@T_31Bit_Stack_Ptr_Ptr    DS    AL4    A(31-bit Stack Ptr)\n@T_24Bit_Stack_Ptr_Ptr    DS    AL4    A(24-bit Stack Ptr)\n\n@T_Last_VLD_Ptr           DS    AL4    A(Last VLD)\n@T_SMS_SSOB_Ptr           DS    AL4    A(SSOB)\n@T_SMS_SYSNum             DS    HL2    SMS System Number\n@T_SMS_SSOB               DS    XL(SSOBHSIZ) SSOB\n@T_SMS_SSSA               DS    XL(SSSALN+SSSA1LN)  SSSA (HDR)\n                          DS    X      Flag Byte\n@T_Volser_in_VLD          EQU   *-1,X'80' 1... .... VLD has Volser\n                          DS    0D\n@T_SMS_VLD                DS    XL((VLDEND-VLD)+(VLDEND2-VLDSYSDT))\n                          ORG   @T_SMS_VLD\n@T_SMS_BCD                DS    XL6144  SMS Config Data\n                          ORG   ,\n\n                          DS    0D\n@T_Dynam_Length           EQU   *-@T_Dynam\n\n\n&PGMNAME CSECT\n\n         DROP  ,\n         POP   USING\n         TITLE 'U00010: Write to output file'\n\n         PUSH  USING\n\nU00010   DS    0H\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Subroutine: U00010                                                 *\n*                                                                     *\n*  Abstract  : This subroutine manages output DCBs, and writes data   *\n*              to them.                                               *\n*                                                                     *\n*  Inputs    : R1 : ---> A(@_Dynam)                                   *\n*                        A(31-bit Stack Pointer)                      *\n*                        A(24-bit Stack Pointer)                      *\n*                        A(DDName)                                    *\n*                        A(Data)                                      *\n*                        A(Length of Data)                            *\n*                        A(ASA Ctl Char) or 0                         *\n*  Outputs   : R15: 0 = OK                                            *\n*                   8 = Error (DCB not OPEN, etc.)                    *\n*                                                                     *\n*  Operation : If A(DDNAME) = 0                                       *\n*                CLOSE all OPEN DCBs                                  *\n*                Free DCB storage                                     *\n*              Else                                                   *\n*                Find DCB for DDName                                  *\n*                If DCB not found                                     *\n*                  If any data to write                               *\n*                    Create and OPEN DCB                              *\n*                  EndIf                                              *\n*                EndIf                                                *\n*                If DCB OPEN                                          *\n*                  If no data to write                                *\n*                    CLOSE DCB                                        *\n*                  Else                                               *\n*                    Write Data                                       *\n*                  EndIf                                              *\n*                EndIf                                                *\n*              EndIf                                                  *\n*              Return to caller                                       *\n*                                                                     *\n*  Notes     : Once an OUTFILE is OPEN, it will remain OPEN until     *\n*               the SPACE program terminates, to cope with the fol-   *\n*               lowing batch scenario:                                *\n*                  SPACE .... OUTFILE(X)                              *\n*                  SPACE .... OUTFILE(Y)                              *\n*                  SPACE .... OUTFILE(X)                              *\n*                                                                     *\n*  History:    2003/10/07 SDDA030 - V2.21                             *\n*                                   New.                              *\n*                                   This code was extracted from X0010*\n*                                   and generalized, so it could be   *\n*                                   used for all output files, includ-*\n*                                   ing SYSPRINT.                     *\n*              2006/04/21 SDDA030 - V2.24                             *\n*                                 - Used standardised calling sequence*\n*                                 - Used separate 24-bit stack for    *\n*                                   DCBs, PUT code, etc.              *\n*              ____/__/__ ______                                      *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         STM   R14,R12,12(R13)          Save callers registers\n         LARL  R11,U_Literals           Point to our literals\n         USING (U_Literals,U_Literals_End),R11 Tell the assembler\n\n         L     R12,0(0,R1)              A(@_Dynam)\n         USING @_Dynam,R12              Tell the assembler\n\n*-------------------------------------------------------------------*\n*    Get an area on the stack for our local storage                 *\n*-------------------------------------------------------------------*\n         L     R2,4(0,R1)               A(31-bit stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         SSCSTACK PUSH,                 Get stack area                 +\n               LEN=@U_Dynam_Length,      this long                     +\n               STACK=(R2)                using this stack\n\n         LR    R3,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LHI   R1,@U_Dynam_Length        Its length\n         LA    R14,0                    Clear source address\n         LA    R15,0                     and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R3                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*-------------------------------------------------------------------*\n         ST    R13,4(0,R1)              Chain\n         ST    R1,8(0,R13)               saveareas\n         LR    R13,R1                   Load dynam base\n         USING @U_Dynam,R13             Assign a base\n         L     R15,@U_Dynam+4           Get A(HSA)\n         LM    R0,R3,20(R15)            Restore callers registers\n\n         L     R15,4(0,R1)              A(31-bit Stack Pointer)\n         ST    R15,@U_31Bit_Stack_Ptr_Ptr Save it\n         L     R15,8(0,R1)              A(24-bit Stack Pointer)\n         ST    R15,@U_24Bit_Stack_Ptr_Ptr Save it\n\n*-------------------------------------------------------------------*\n*    Save our parms                                                 *\n*-------------------------------------------------------------------*\n        L     R15,12(0,R1)              A(DDName)\n        ST    R15,@U_DDName_Ptr         OK, save it\n\n        L     R15,16(0,R1)              A(Data)\n        ST    R15,@U_Data_Ptr           Save it\n\n        L     R15,20(0,R1)              A(Data Length)\n        ST    R15,@U_Data_Len_Ptr       Save it\n\n        TM    20(R1),X'80'              Was that the last parm?\n        BO    U00020                    Yes, skip\n        L     R15,24(R1)                A(ASA Character) or 0\n        ST    R15,@U_ASA_Char_Ptr       Save it\n\nU00020  DS    0H\n*-------------------------------------------------------------------*\n*    By convention, if the address of the DDName is 0, we CLOSE all *\n*   OPEN DCBs, and free up their storage.                           *\n*-------------------------------------------------------------------*\n        ICM   R15,B'1111',@U_DDName_Ptr A(DDName)\n        JNZ   U00100                    Something there, OK\n\n*-------------------------------------------------------------------*\n*    CLOSE the DCBs ...                                             *\n*-------------------------------------------------------------------*\n         ICM   R3,B'1111',@_OutFile_Chain_Ptr  A(First OUTFile DCB)\n         JZ    U00050                   None, exit\nU00030   DS    0H\n         LA    R15,4+L'@_OutFile_DDName(0,R3) A(DCB)\n         TM    DCBOFLGS-IHADCB(R15),DCBOFOPN Is it OPEN?\n         JNO   U00040                   No, skip CLOSE\n         MVC   @U_CLOSE,U_CLOSE         Yes, Move CLOSE Parms\n         CLOSE ((15)),MODE=31,MF=(E,@U_CLOSE) and CLOSE it\nU00040   DS    0H\n         ICM   R3,B'1111',0(R3)         A(next DCB)\n         JNZ   U00030                   Got one, close it too\n\nU00050   DS    0H\n*-------------------------------------------------------------------*\n*    ... free the stack ...                                         *\n*-------------------------------------------------------------------*\n         ICM   R1,B'1111',@_OutFile_24Bit_Stack_Ptr A(DCB Stack)\n         JZ    U00080                   None, skip\n         SSCSTACK TERM,                 Free the stack area            +\n               STACK=(1)                 this one\n\nU00080   DS    0H\n         LA    R15,0                    Clear\n         ST    R15,@_OutFile_PUT_Code    Code pointer\n         ST    R15,@_OutFile_Chain_Ptr   and DCB pointer\n\n*-------------------------------------------------------------------*\n*    ... and exit.                                                  *\n*-------------------------------------------------------------------*\n         LA    R15,0                    All done, clear return code\n         J     U90010                    and exit\n\nU00100   DS    0H\n*-------------------------------------------------------------------*\n*    ... search the chain of OUTFIL DCBs to see if we can find our  *\n*   DDName                                                          *\n*-------------------------------------------------------------------*\n         LA    R15,@_OutFile_Chain_Ptr  A(Ptr to start of chain)\n         L     R14,@U_DDName_Ptr        A(Our DDName)\n         J     U00120                   and start running it\nU00110   DS    0H\n         CLC   0(L'@_OutFile_DDName,R14),4(R15)  Yes, is it ours?\n         JNE   U00120                   No, skip\n         AHI   R15,4+L'@_OutFile_DDName Yes, point to the DCB\n         ST    R15,@U_DCB_Ptr           Save it\n         J     U00280                   and use it\nU00120   DS    0H\n         LR    R3,R15                   Save A(this DCB area)\n         ICM   R15,B'1111',0(R3)        Point to next\n         JNZ   U00110                   Got one, check it out\n\n*-------------------------------------------------------------------*\n*    If we have anything to do ...                                  *\n*-------------------------------------------------------------------*\n         ICM   R15,B'1111',@U_Data_Ptr  Any data?\n         JZ    U00390                   No, exit quick smart\n         ICM   R15,B'1111',@U_Data_Len_Ptr Yes, any length pointer?\n         JZ    U00390                   No, get out\n         ICM   R15,B'1111',0(R15)       Yes, length = 0?\n         JZ    U00390                   Yes, exit now\n\n*-------------------------------------------------------------------*\n*    Our DDName is not found, so get an area on the 24-bit Stack    *\n*   for our DCB area ...                                            *\n*    The format of this area:                                       *\n*       0- 3: Forward pointer                                       *\n*       4-11: DDName                                                *\n*      12-n : DCB                                                   *\n*                                                                   *\n*    First, however, we move our 24-bit PUT code, if required. PUT  *\n*   runs 24-bit because QSAM has trouble using 31-bit PUT for       *\n*   DDNames allocated to the terminal - rather than check, we       *\n*   blindly run PUT in 24-bit mode all the time.                    *\n*-------------------------------------------------------------------*\n         ICM   R0,B'1111',@_OutFile_24Bit_Stack_Ptr A(DCB Stack)\n         JNZ   U00130                   OK, skip\n\n         L     R0,=AL4(@_24Bit_Stack_Length) Length of storage we need\n         SSCSTACK INIT,                 Go get our storage             +\n               LEN=(R0),                 this long                     +\n               LOC=24                    below the line\n\n         ST    R1,@_OutFile_24Bit_Stack_Ptr Update A(DCB Stack)\n\nU00130   DS    0H\n         ICM   R15,B'1111',@_OutFile_PUT_Code  A(24-bit PUT code)\n         JNZ   U00140                  OK, skip\n\n         LA    R0,U00400_End-U00400    Length of storage we need\n         L     R2,@_OutFile_24Bit_Stack_Ptr A(DCB Stack)\n         SSCSTACK PUSH,                 Get stack area                 +\n               LEN=(R0),                 this long                     +\n               STACK=(R2)                using this stack\n\n         ST    R1,@_OutFile_PUT_Code   Save A(Storage)\n         LR    R0,R1                   Set Target address\n         LHI   R1,U00400_End-U00400    Set Target length\n         BASR  R14,0                   Set Source\n         AHI   R14,U00400-*              address\n         LR    R15,R1                  and Source length\n         MVCL  R0,R14                  Move PUT code\n\nU00140   DS    0H\n         LHI   R0,4+L'@_OutFile_DDName+U_OUTFILE_DCB_Length\n         L     R2,@_OutFile_24Bit_Stack_Ptr A(DCB Stack)\n         SSCSTACK PUSH,                 Get stack area                 +\n               LEN=(R0),                 this long                     +\n               STACK=(R2)                using this stack\n\n*-------------------------------------------------------------------*\n*    ... chain it to the previous DCB area (pointed to by R3) ...   *\n*-------------------------------------------------------------------*\n         ST    R1,0(0,R3)               Chain it\n\n*-------------------------------------------------------------------*\n*    ... and initialize it.                                         *\n*-------------------------------------------------------------------*\n         XC    0(4,R1),0(R1)          Clear Ptr to next DCB area\n         L     R15,@U_DDName_Ptr      A(DDName)\n         MVC   4(L'@_OutFile_DDName,R1),0(R15)  Set DDName\n         LA    R15,4+L'@_OutFile_DDName(0,R1) Point to DCB\n         MVC   0(U_OUTFILE_DCB_Length,R15),U_OUTFILE_DCB Move DCB\n         MVC   DCBDDNAM-IHADCB(L'DCBDDNAM,R15),4(R1)  Move DDName\n         ST    R15,@U_DCB_Ptr         Save A(DCB)\n\n*-------------------------------------------------------------------*\n*    Get the JFCB. First, find the TIOT entry ...                   *\n*-------------------------------------------------------------------*\n         L     R15,CVTPTR(0,0)          A(CVT)\n         L     R15,CVTTCBP-CVT(R15)     A(Current TCB pointer)\n         L     R15,0(0,R15)             A(Current TCB)\n         L     R15,TCBTIO-TCB(R15)      A(TIOT)\n         L     R14,@U_DDName_Ptr        A(DDName)\n         AHI   R15,TIOENTRY-TIOT1       A(1st entry in TIOT)\nU00150   DS    0H\n         CLI   TIOELNGH-TIOENTRY(R15),0 Last Entry?\n         JE    U80010                   Yes, DDName not found\n         CLC   TIOEDDNM-TIOENTRY(L'TIOEDDNM,R15),0(R14) Ours?\n         JE    U00160                   Found our entry, skip\n         LA    R0,0                     Clear work reg\n         IC    R0,TIOELNGH-TIOENTRY(R15) Get entry length\n         AR    R15,R0                   Point to next entry\n         J     U00150                   and check it out\n\nU00160   DS    0H\n*-------------------------------------------------------------------*\n*    ... and then get the JFCB address from the SWA                 *\n*-------------------------------------------------------------------*\n         XC    @U_SWAEPAX,@U_SWAEPAX    Clear SWAEPA\n         MVC   @U_SWAEPAX+SWVA-ZB505(L'SWVA),TIOEJFCB-TIOENTRY(R15)\n         LA    R15,@U_SWAEPAX           A(EPA)\n         ST    R15,@U_EPA_Ptr           Save the address\n         MVC   @U_SWAREQ,U_SWAREQ       Move L-Form of macro\n         SWAREQ FCODE=RL,               Read Locate                    +\n               EPA=@U_EPA_Ptr,           using the EPA at this addr    +\n               UNAUTH=YES,               not being authoriZED          +\n               MF=(E,@U_SWAREQ)          keep ourselves re-entrant\n         LTR   R15,R15                  Check return code\n         JNZ   U80010                   Not good, skip\n\n         L     R4,@U_SWAEPAX+SWBLKPTR-ZB505 Get A(JFCB)\n         L     R3,@U_DCB_Ptr            Get A(DCB)\n\n*-------------------------------------------------------------------*\n*    If this is a new dataset ...                                   *\n*-------------------------------------------------------------------*\n         TM    JFCBTSDM-INFMJFCB(R4),JFCSDS SubSystem Dataset?\n         JO    U00170                 Yes, treat it as NEW\n         CLI   JFCBIND2-INFMJFCB(R4),0 Any DISP specified?\n         JE    U00170                 No, treat it as NEW\n         TM    JFCBIND2-INFMJFCB(R4),JFCNEW Yes, DISP=NEW?\n         JNO   U00270                 No, use existing DCB stuff\n\nU00170   DS    0H\n*-------------------------------------------------------------------*\n*    ... set up RECFM, LRECL and BLKSIZE if they were not           *\n*   specified. First, set RECFM to FB if it has not been specified. *\n*-------------------------------------------------------------------*\n         IC    R15,JFCRECFM-INFMJFCB(0,R4) Get RECFM from JFCB\n         LTR   R15,R15                Anything?\n         JNZ   U00180                 Yes, OK\n         LA    R15,DCBRECF+DCBRECBR   No, default to FB\n\n         TM    JFCBTSDM-INFMJFCB(R4),JFCSDS SubSystem Dataset?\n         JNO   U00180                 No, OK\n         LA    R15,DCBRECCA(0,R15)    Yes, add ASA character\nU00180   DS    0H\n         STC   R15,DCBRECFM-IHADCB(R3) Set RECFM in DCB\n\n*-------------------------------------------------------------------*\n*    Get the LRECL and BLKSIZE from the JFCB ...                    *\n*-------------------------------------------------------------------*\n         LH    R15,JFCLRECL-INFMJFCB(R4) Get JFCB LRECL\n         LH    R14,JFCBLKSI-INFMJFCB(R4) Get JFCB BLKSIZE\n\n*-------------------------------------------------------------------*\n*    ... and, if the LRECL hasn't been specified, set it to the     *\n*   length of the data to be written (unless this is SYSPRINT, when *\n*   the LRECL is set to VolTbl_Ent_Display_Len, to maintain compat- *\n*   ibility with previous versions).                                *\n*-------------------------------------------------------------------*\n         LTR   R15,R15                 Any LRECL?\n         JNZ   U00210                  Yes, OK\n\n         L     R15,@U_Data_Len_Ptr     A(Length of data to be written)\n         L     R15,0(0,R15)            Get it\n         TM    DCBRECFM-IHADCB(R3),DCBRECCC Carriage control?\n         JZ    U00200                  No, skip\n         AHI   R15,1                   Yes, bump for CC\nU00200   DS    0H\n         TM    DCBRECFM-IHADCB(R3),DCBRECU RECFM = U?\n         JO    U00210                  Yes, not RECFM=V\n         TM    DCBRECFM-IHADCB(R3),DCBRECV RECFM = V?\n         JZ    U00210                  No, skip\n         AHI   R15,4                   Yes, bump for RDW\n\nU00210   DS    0H\n*-------------------------------------------------------------------*\n*    If no BLKSIZE specified for RECFM=U, make BLKSIZE = LRECL      *\n*-------------------------------------------------------------------*\n         LTR   R14,R14                 Any BLKSIZE in the JFCB?\n         JNZ   U00220                  Yes, skip\n         TM    DCBRECFM-IHADCB(R3),DCBRECU RECFM = U?\n         JNO   U00220                  No, use SDB\n         LR    R14,R15                 Yes, BLKSIZE = LRECL\n\nU00220   DS    0H\n*-------------------------------------------------------------------*\n*    Check LRECL vs BLKSIZE, and adjust them to fit                 *\n*     RECFM=U: LRECL = 0                                            *\n*     RECFM=V: BLKSIZE = (n * LRECL) + 4                            *\n*     RECFM=F: BLKSIZE = n * LRECL                                  *\n*-------------------------------------------------------------------*\n         TM    DCBRECFM-IHADCB(R3),DCBRECU RECFM = U?\n         JNO   U00230                  No, skip\n         LA    R15,0                   Yes, clear LRECL\n         J     U00260                  and skip\nU00230   DS    0H\n         TM    DCBRECFM-IHADCB(R3),DCBRECV RECFM = V?\n         JNO   U00240                  No, skip\n         LTR   R14,R14                 Yes, BLKSIZE=0 (SDB)?\n         JZ    U00260                  Yes, OK\n         TM    DCBRECFM-IHADCB(R3),DCBRECSB Spanned rec?\n         JO    U00260                  Yes, OK\n         LR    R1,R14                  No, get BLKSIZE\n         LA    R0,0                    Clear high-order word\n         DR    R0,R15                  BLKSIZE/LRECL\n         C     R0,=FL4'4'              Remainder of 4 (BDW)?\n         JNL   U00260                  Yes, OK\n         LR    R15,R14                 No, LRECL = ...\n         S     R15,=FL4'4'                BLKSIZE - 4\n         J     U00260                  and skip\nU00240   DS    0H\n         LTR   R14,R14                 Fixed, BLKSIZE=0 (SDB)?\n         JZ    U00260                  Yes, OK\n         CR    R14,R15                 No, BLKSIZE > LRECL?\n         JNL   U00250                  Yes, OK\n         LR    R14,R15                 No, BLKSIZE = LRECL\n         J     U00260                  and skip\nU00250   DS    0H\n         LR    R1,R14                  Get BLKSIZE\n         LA    R0,0                    Clear high-order word\n         DR    R0,R15                  BLKSIZE/LRECL\n         SR    R14,R0                  Adjust BLKSIZE by remainder\n         J     U00260                  and skip\nU00260   DS    0H\n         STH   R15,DCBLRECL-IHADCB(R3) Update DCB LRECL\n         STH   R14,DCBBLKSI-IHADCB(R3) Update DCB BLKSIZE\n\nU00270   DS    0H\n*-------------------------------------------------------------------*\n*    Open the DCB, and exit quick smart if it doesn't               *\n*-------------------------------------------------------------------*\n         L     R3,@U_DCB_Ptr           Point to our DCB\n\n         MVC   @U_OPEN,U_OPEN             Move OPEN parms\n         OPEN  ((3),OUTPUT),MODE=31,MF=(E,@U_OPEN) And OPEN it\n\n         TM    DCBOFLGS-IHADCB(R3),DCBOFOPN Is it OPEN?\n         JNO   U80010                  No, exit with error\n\nU00280   DS    0H\n*-------------------------------------------------------------------*\n*    We have our DCB - if it is OPEN ...                            *\n*-------------------------------------------------------------------*\n         LA    R15,0                   Clear return code\n         L     R3,@U_DCB_Ptr           Get A(DCB)\n         TM    DCBOFLGS-IHADCB(R3),DCBOFOPN Is it OPEN?\n         JNO   U90010                  No, skip\n\n*-------------------------------------------------------------------*\n*    ... if we have nothing to do, CLOSE the DCB. Otherwise ...     *\n*-------------------------------------------------------------------*\n         ICM   R15,B'1111',@U_Data_Ptr  Any data?\n         JZ    U00290                   No, close DCB\n         ICM   R15,B'1111',@U_Data_Len_Ptr Yes, any length pointer?\n         JZ    U00290                   No, close DCB\n         ICM   R15,B'1111',0(R15)       Yes, length = 0?\n         JNZ   U00300                   NO, OK\nU00290   DS    0H\n         MVC   @U_CLOSE,U_CLOSE         Move CLOSE Parms\n         CLOSE ((3)),MODE=31,MF=(E,@U_CLOSE) and CLOSE our DCB\n         J     U00390                   and exit\n\nU00300   DS    0H\n*-------------------------------------------------------------------*\n*    ... get an area to hold the data we will write. It's length    *\n*   is:                                                             *\n*    RECFM=U:                                                       *\n*       Length of data to be written                                *\n*      +1 if the DCB has a Print Ctl Char & A(ASA Char) \\= 0        *\n*    Otherwise:                                                     *\n*       DCBLRECL                                                    *\n*-------------------------------------------------------------------*\n         LH    R0,DCBLRECL-IHADCB(R3)  Get LRECL\n\n         TM    DCBRECFM-IHADCB(R3),DCBRECU RECFM = U?\n         JNO   U00310                  No, skip\n         L     R15,@U_Data_Len_Ptr     A(Len of data to be written)\n         L     R0,0(0,R15)             Get it\n         TM    DCBRECFM-IHADCB(R3),DCBRECCC CC?\n         JZ    U00310                  No, skip\n         ICM   R15,B'1111',@U_ASA_Char_Ptr Yes, do we have one?\n         JZ    U00310                  No, too bad\n         AHI   R0,1                    Yes, bump length\nU00310   DS    0H\n\n         ST    R0,@U_OutRec_Len        Save length\n         L     R2,@_OutFile_24Bit_Stack_Ptr A(DCB Stack)\n         SSCSTACK PUSH,                 Get stack area                 +\n               LEN=(R0),                 this long                     +\n               STACK=(R2)                using this stack\n\n         ST    R1,@U_OutRec_Ptr        Save A(Data area)\n\n*-------------------------------------------------------------------*\n*    ... move the data passed to us to our output area ...          *\n*-------------------------------------------------------------------*\n         L     R14,@U_OutRec_Ptr        A(Output Record)\n         TM    DCBRECFM-IHADCB(R3),DCBRECU RECFM=U?\n         JO    U00320                  Yes, its not RECFM=V\n         TM    DCBRECFM-IHADCB(R3),DCBRECV RECFM=V?\n         JNO   U00320                  No, skip\n         LA    R14,4(0,R14)            Yes, bump for RDW\nU00320   DS    0H\n         TM    DCBRECFM-IHADCB(R3),DCBRECCC CC?\n         JZ    U00330                  No, skip\n         ICM   R15,B'1111',@U_ASA_Char_Ptr Do we have one?\n         JZ    U00330                  No, skip\n         MVC   0(1,R14),0(R15)         Yes, move it\n         TM    DCBRECFM-IHADCB(R3),DCBRECCM Machine CC?\n         JZ    U00265                  No, skip\n         TR    0(1,R14),U_ASA_to_Mach  Yes, translate it\nU00265   DS    0H\n         LA    R14,1(0,R14)            and bump output pointer\nU00330   DS    0H\n         LR    R0,R14                  A(Output)\n         L     R1,@U_OutRec_Ptr        Calculate\n         A     R1,@U_OutRec_Len         length of output\n         SR    R1,R0                    data left\n         L     R14,@U_Data_Ptr         A(Data to be copied)\n         L     R15,@U_Data_Len_Ptr     A(Length)\n         L     R15,0(0,R15)            Get its length\n         O     R15,=XL4'40000000'      Pad character of blank\n         MVCL  R0,R14                  Move it\n\n         S     R14,@U_OutRec_Ptr       Length of output record\n\n*-------------------------------------------------------------------*\n*    ... if this is a RECFM=U file, update DCBBLKSI, after saving   *\n*   it. Otherwise ...                                               *\n*-------------------------------------------------------------------*\n         TM    DCBRECFM-IHADCB(R3),DCBRECU  RECFM=U?\n         JNO   U00350                  No, skip\n         LH    R0,DCBBLKSI-IHADCB(R3)  Yes, get max record len\n         STH   R0,@U_BLKSIZE           and save it\n         CR    R14,R0                  Are we trying to write too much?\n         JNH   U00340                  No, OK\n         LR    R14,R0                  Yes, write what we can\nU00340   DS    0H\n         STH   R14,DCBBLKSI-IHADCB(R3) Update it with current length\n         J     U00370                  and skip\n\nU00350   DS    0H\n*-------------------------------------------------------------------*\n*    ... if this is a RECFM=V file, update the RDW                  *\n*-------------------------------------------------------------------*\n         TM    DCBRECFM-IHADCB(R3),DCBRECV RECFM=V?\n         JNO   U00370                  No, OK\n         LH    R0,DCBLRECL-IHADCB(R3)  Yes, get LRECL\n         CR    R14,R0                  Are we trying to write too much?\n         JNH   U00360                  No, OK\n         LR    R14,R0                  Yes, write what we can\nU00360   DS    0H\n         L     R15,@U_OutRec_Ptr       Get A(Output record)\n         SLL   R14,16                  Length in high-order byte\n         ST    R14,0(0,R15)            Update RDW\n         J     U00370                  and skip\n\nU00370   DS    0H\n*-------------------------------------------------------------------*\n*    Write our data ...                                             *\n*-------------------------------------------------------------------*\n         L     R1,@U_DCB_Ptr           Point to our DCB\n         L     R0,@U_OutRec_Ptr        Point to data to be written\n         L     R15,@_OutFile_PUT_Code  Point to our code\n         BASR  R14,R15                 Go issue PUT\n\n*-------------------------------------------------------------------*\n*    ... and restore DCBBLKSI, if this is RECFM=U                   *\n*-------------------------------------------------------------------*\n         L     R1,@U_DCB_Ptr           Point to our DCB\n         TM    DCBRECFM-IHADCB(R1),DCBRECU  RECFM=U?\n         JNO   U00380                  No, skip\n         LH    R0,@U_BLKSIZE           Yes, get saved BLKSIZE\n         STH   R0,DCBBLKSI-IHADCB(R1)  and restore the DCB\n\nU00380   DS    0H\n*-------------------------------------------------------------------*\n*    Free the storage we got for our record ...                     *\n*-------------------------------------------------------------------*\n         ICM   R1,B'1111',@U_OutRec_Ptr A(Output record data area)\n         JZ    U00390                   Nothing, skip\n         L     R2,@_OutFile_24Bit_Stack_Ptr A(DCB Stack)\n         SSCSTACK POP,                  Free the record area           +\n               ADDR=(R1),                starting here                 +\n               STACK=(R2)                on this stack\n\nU00390   DS    0H\n*-------------------------------------------------------------------*\n*    ... clear the return code, and exit.                           *\n*-------------------------------------------------------------------*\n         LA    R15,0                   Clear return code\n         J     U90010                  and exit\n\n*-------------------------------------------------------------------*\n*    The following code is moved to storage below-the-line, and     *\n*   is executed via a BASR, so it runs AMODE24. This is required if *\n*   the DCB to which we are writing happens to be allocated to      *\n*   the TSO terminal.                                               *\n*                                                                   *\n*   Note that R14-R3 are updated by this routine.                   *\n*-------------------------------------------------------------------*\n\n\nU00400   DS    0H\n         PUSH  USING                   Save USING environment\n         DROP  ,                       Free them all\n         USING *,R15                   Assign a base\n         LR    R3,R14                  Save return address\n         PUT   (1),(0)                 Write record (MACRF=PM)\n         LA    R14,X'80'               Set up\n         SLL   R14,24                   31-bit\n         OR    R14,R3                   return address\n         BSM   0,R14                   Back to caller in AMODE31\n         DROP  R15                     Free our base\n         POP   USING                   Restore USING environment\nU00400_End EQU *\n\n\nU80010   DS    0H\n*-------------------------------------------------------------------*\n*    We couldn't OPEN the DCB, so exit with a return code           *\n*-------------------------------------------------------------------*\n         LA    R15,4                   RC = 4\n         J     U90010                  and exit\n\nU90010   DS    0H\n*-------------------------------------------------------------------*\n*    Free up our local storage ...                                  *\n*-------------------------------------------------------------------*\n         LR    R3,R15                   Save Return Code\n\n         LA    R1,@U_Dynam              A(Local storage)\n         L     R2,@U_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)\n         L     R2,0(0,R2)         Point to it\n         L     R13,4(0,R13)             Rescue A(HSA)\n\n         SSCSTACK POP,                  Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=(R2)                on this stack\n\n         LR    R15,R3                   Restore Return Code\n\n*-------------------------------------------------------------------*\n*    ... and return to caller                                       *\n*-------------------------------------------------------------------*\n         L     R14,12(0,R13)            Restore return address\n         LM    R0,R12,20(R13)           Restore other registers\n         BSM   0,R14                    and return\n\nU_Literals  DS  0H\n\nU_ASA_to_Mach DC  256X'09'               Default - space 1 line\n              ORG U_ASA_to_Mach+C'0'     Space 2 lines\n              DC  X'11'\n              ORG U_ASA_to_Mach+C'-'     Space 3 lines\n              DC  X'19'\n              ORG U_ASA_to_Mach+C'+'     Suppress spacing\n              DC  X'01'\n              ORG U_ASA_to_Mach+C'1'     Skip to Channel 1\n              DC  X'89'\n              ORG\n\n         LTORG\n\n         PUSH  PRINT\n         PRINT NOGEN\n\nU_OUTFILE_DCB DCB DDNAME=OUTFILE,MACRF=PM,DSORG=PS\nU_OUTFILE_DCB_Length EQU *-U_OUTFILE_DCB Length of OUTFILE DCB\n\nU_SWAREQ SWAREQ MF=L                    Read Locate\nU_SWAREQ_Length EQU *-U_SWAREQ          Length of SWAREQ Macro\n\nU_OPEN   OPEN  (0,INPUT),MODE=31,MF=L\nU_OPEN_Length EQU  *-U_OPEN\n\nU_CLOSE  CLOSE (0),MODE=31,MF=L\nU_CLOSE_Length EQU  *-U_CLOSE\n\n         POP PRINT\n\nU_Literals_End  DS  0H\n\n\n@U_Dynam                  DSECT       Dynamic area for U0000\n                          DS    18F    O/S Style save area\n@U_31Bit_Stack_Ptr_Ptr    DS    AL4    A(31-bit Stack Ptr)\n@U_24Bit_Stack_Ptr_Ptr    DS    AL4    A(24-bit Stack Ptr)\n\n@U_DDName_Ptr             DS    AL4    A(DDName)\n@U_Data_Ptr               DS    AL4    A(Data to be written)\n@U_Data_Len_Ptr           DS    AL4    A(Length of data to be written)\n@U_ASA_Char_Ptr           DS    AL4    A(ASA CC) or 0\n\n@U_DCB_Ptr                DS    AL4    A(Current DCB)\n@U_BLKSIZE                DS    HL2    BLKSIZE for RECFM=U DCB\n\n@U_OutRec_Ptr             DS    AL4    A(Buffer for PUT)\n@U_OutRec_Len             DS    FL4    A(Length of above buffer)\n\n@U_Macros                 DS    0F\n@U_OPEN                   DS    CL(U_OPEN_Length)\n                          ORG   @U_Macros\n@U_CLOSE                  DS    CL(U_CLOSE_Length)\n                          ORG   @U_Macros\n@U_EPA_Ptr                DS    AL4    A(EPA for SWAREQ)\n@U_SWAREQ                 DS    CL(U_SWAREQ_Length)\n                          DS    0F\n@U_SWAEPAX                DS    CL(L'SWAEPAX)\n                          ORG   ,\n                          DS    0D     Alignment\n@U_Dynam_Length           EQU   *-@U_Dynam Length of storage\n\n&PGMNAME CSECT\n\n         DROP  ,\n         POP   USING\n         TITLE 'V00010: Set up Statistics output lines'\n\n         PUSH  USING\n\nV00010   DS    0H\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Subroutine: V00010                                                 *\n*                                                                     *\n*  Abstract  : Populate statistics lines in the Volume Table.         *\n*                                                                     *\n*  Inputs    : R1 : ---> A(@_Dynam)                                   *\n*                        A(31-bit Stack Pointer)                      *\n*                        A(24-bit Stack Pointer)                      *\n*                        A(VolTbl_Ent)                                *\n*  Outputs   : R15: 0: OK                                             *\n*                                                                     *\n*  Notes     : N/A                                                    *\n*                                                                     *\n*  History:    2000/05/23 SDDA030 - V2.12                             *\n*                                 - New                               *\n*              2001/02/01 SDDA030 - V2.13                             *\n*                                 - Populated Main task CPU time      *\n*                                   stats line.                       *\n*              2001/02/26 SDDA030 - V2.14                             *\n*                                 - Checked and flagged               *\n*                                   VolTbl_Ent_Stats_Done so the stats*\n*                                   lines are populated once only.    *\n*              2002/06/11 SDDA030 - V2.18                             *\n*                                   WAIT for VolTbl to be populated   *\n*                                   before updating.                  *\n*              2006/04/21 SDDA030 - V2.24                             *\n*                                   Used standardised calling sequence*\n*              ____/__/__ _______                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         STM   R14,R12,12(R13)          Save callers registers\n         LARL  R11,V_Literals           Point to our literals\n         USING (V_Literals,V_Literals_End),R11 Tell the assembler\n\n         L     R12,0(0,R1)              A(@_Dynam)\n         USING @_Dynam,R12              Tell the assembler\n\n*-------------------------------------------------------------------*\n*    Get an area on the stack for our local storage                 *\n*-------------------------------------------------------------------*\n         L     R2,4(0,R1)               A(31-bit stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         SSCSTACK PUSH,                 Get stack area                 +\n               LEN=@V_Dynam_Length,      this long                     +\n               STACK=(R2)                using this stack\n\n         LR    R3,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LHI   R1,@V_Dynam_Length        Its length\n         LA    R14,0                    Clear source address\n         LA    R15,0                     and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R3                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*-------------------------------------------------------------------*\n         ST    R13,4(0,R1)              Chain\n         ST    R1,8(0,R13)               saveareas\n         LR    R13,R1                   Load dynam base\n         USING @V_Dynam,R13             Assign a base\n         L     R15,@V_Dynam+4           Get A(HSA)\n         LM    R0,R3,20(R15)            Restore callers registers\n\n         L     R15,4(0,R1)              A(31-bit Stack Pointer)\n         ST    R15,@V_31Bit_Stack_Ptr_Ptr Save it\n         L     R15,8(0,R1)              A(24-bit Stack Pointer)\n         ST    R15,@V_24Bit_Stack_Ptr_Ptr Save it\n\n*---------------------------------------------------------------------*\n*   Load the base register for VolTbl_Ent                             *\n*---------------------------------------------------------------------*\n         L     R9,12(0,R1)             Point to VolTbl_Ent\n         USING VolTbl_Ent,R9           Tell the Assembler\n\n*---------------------------------------------------------------------*\n*   If this is a Stack Statistics line ...                            *\n*---------------------------------------------------------------------*\n         TM    VolTbl_Ent_Stats_31Stack,L'VolTbl_Ent_Stats_31Stack\n         JZ    V00020                   Not 31-bit Stack stats, skip\n         TM    VolTbl_Ent_Stats_Done,L'VolTbl_Ent_Stats_Done Done?\n         JO    V00060                   Yes, skip\n         L     R8,@V_31Bit_Stack_Ptr_Ptr Get 31-bit stack pointer\n         L     R8,0(0,R8)               and point to the stack\n         J     V00030                   and skip\nV00020   DS    0H\n         TM    VolTbl_Ent_Stats_24Stack,L'VolTbl_Ent_Stats_24Stack\n         JZ    V00080                   Not 24-bit Stack stats, skip\n         TM    VolTbl_Ent_Stats_Done,L'VolTbl_Ent_Stats_Done Done?\n         JO    V00060                   Yes, skip\n         L     R8,@V_24Bit_Stack_Ptr_Ptr No, get 24-bit stack pointer\n         L     R8,0(0,R8)               and point to it\nV00030   DS    0H\n         L     R15,@_VolTbl_Ptr         A(VolTbl)\n         TM    VolTbl_Hdr_ECB-VolTbl_Hdr(R15),X'40' Table populated\n         JO    V00030C                  Yes, OK\n         WAIT  ECB=VolTbl_Hdr_ECB-VolTbl_Hdr(R15) No, WAIT for it\nV00030C  DS    0H\n         LA    R14,V_Stats_Line4        A(Source)\n         LHI   R15,V_Stats_Line4_Len    Length of source\n         O     R15,=XL4'40000000'       Pad char of blank\n         LA    R0,VolTbl_Ent_Display    A(Target)\n         LHI   R1,VolTbl_Ent_Display_Len Length of target\n         MVCL  R0,R14                   Move Stats Line4\n         TM    VolTbl_Ent_Stats_31Stack,L'VolTbl_Ent_Stats_31Stack\n         JNO   V00040                   Not 31-bit stack, skip\n         MVC   VolTbl_Ent_Display+V_Stats_Line4_Stack-V_Stats_Line4(L'V+\n               _Stats_Line4_Stack),=C'31'\n         J     V00050\nV00040   DS    0H\n         TM    VolTbl_Ent_Stats_24Stack,L'VolTbl_Ent_Stats_24Stack\n         JNO   V00050                   Not 24-bit stack, skip\n         MVC   VolTbl_Ent_Display+V_Stats_Line4_Stack-V_Stats_Line4(L'V+\n               _Stats_Line4_Stack),=C'24'\n         J     V00050\nV00050   DS    0H\n\n         LTR   R0,R8                     Any Stack?\n         JZ    V00050C                   No, default of 0\n         L     R0,StackHdr_StackLen-StackHdr(R8) Get stack length\nV00050C  DS    0H\n         CVD   R0,@V_DBLWD               Pack it\n         ED    VolTbl_Ent_Display+V_Stats_Line4_Size-V_Stats_Line4(L'V_+\n               Stats_Line4_Size),@V_DBLWD+5\n\n         LTR   R0,R8                     Any Stack?\n         JZ    V00050E                   No, default of 0\n         L     R0,StackHdr_HWM-StackHdr(R8) Get high-water mark\n         SR    R0,R8                     as a length\nV00050E  DS    0H\n         CVD   R0,@V_DBLWD               Pack it\n         ED    VolTbl_Ent_Display+V_Stats_Line4_HWM-V_Stats_Line4(L'V_S+\n               tats_Line4_HWM),@V_DBLWD+5\n\n         LTR   R0,R8                     Any Stack?\n         JZ    V00050G                   No, default of 0\n         L     R0,StackHdr_GETMAIN-StackHdr(R8) Get converted PUSHs\nV00050G  DS    0H\n         CVD   R0,@V_DBLWD               Pack it\n         ED    VolTbl_Ent_Display+V_Stats_Line4_GETMAIN-V_Stats_Line4(L+\n               'V_Stats_Line4_GETMAIN),@V_DBLWD+5\n\n         LTR   R0,R8                     Any Stack?\n         JZ    V00050I                   No, default of 0\n         L     R0,StackHdr_Overflow_HWM-StackHdr(R8) GETMAIN HWM\nV00050I  DS    0H\n         CVD   R0,@V_DBLWD               Pack it\n         ED    VolTbl_Ent_Display+V_Stats_Line4_GHWM-V_Stats_Line4(L'V_+\n               Stats_Line4_GHWM),@V_DBLWD+5\n\n         OI    VolTbl_Ent_Stats_Done,L'VolTbl_Ent_Stats_Done Done now\n\n         L     R0,VolTbl_Ent_ECB        Current contents of our ECB\n         TM    VolTbl_Ent_ECB,X'80'     Anyone WAITing?\n         JO    V00050K                  Yes, we need to POST\n         L     R1,=XL4'40000000'        No, POST code of 0\n         CS    R0,R1,VolTbl_Ent_ECB     Pseudo-POST it\n         JZ    V00060                   OK, skip the real POST\nV00050K  DS    0H\n         POST  VolTbl_Ent_ECB,0         POST line as complete\n\nV00060   DS    0H\n         LA    R15,0                    Clear return code\n         J     V90010                   and exit\n\nV00080   DS    0H\n*---------------------------------------------------------------------*\n*   If this is a CPU Stats Line ...                                   *\n*---------------------------------------------------------------------*\n         TM    VolTbl_Ent_Stats_CPUTime,L'VolTbl_Ent_Stats_CPUTime\n         JZ    V01999                   Not CPU Time, skip\n         TM    VolTbl_Ent_Stats_Done,L'VolTbl_Ent_Stats_Done Done?\n         JO    V00110                   Yes, skip\n         L     R15,@_VolTbl_Ptr         A(VolTbl)\n         TM    VolTbl_Hdr_ECB-VolTbl_Hdr(R15),X'40' Table populated\n         JO    V00080C                  Yes, OK\n         WAIT  ECB=VolTbl_Hdr_ECB-VolTbl_Hdr(R15) No, WAIT for it\nV00080C  DS    0H\n         LA    R14,V_Stats_Line5        A(Source)\n         LHI   R15,V_Stats_Line5_Len    Length of source\n         O     R15,=XL4'40000000'       Pad char of blank\n         LA    R0,VolTbl_Ent_Display    A(Target)\n         LHI   R1,VolTbl_Ent_Display_Len Length of target\n         MVCL  R0,R14                   Move Stats Line5\n         TIMEUSED STORADR=@V_DBLWD,     Get CPU time used              +\n               LINKAGE=SYSTEM,           as recommended by IBM         +\n               CPU=MIC                   get it in microseconds\n         LM    R14,R15,@V_DBLWD         Get current TCB time\n         LM    R0,R1,@_CPU_Time_Init    Get TCB Time used previously\n         SLR   R15,R1                   Subtract\n         JNM   V00090                   No overflow, OK\n         SL    R14,=FL4'1'              Borrow, adjust\nV00090   DS    0H\n         SLR   R14,R0                   Adjust this one too\n\n         AL    R15,@_CPU_Time_Used+4    Bump Accum CPU Time\n         BRC   12,V00100                No Carry, OK\n         AL    R14,=FL4'1'              Carry, bump it\nV00100   DS    0H\n         AL    R14,@_CPU_Time_Used      Bump Accum CPU Time\n         D     R14,=FL4'1000'           To seconds (3 decimals)\n         CVD   R15,@V_DBLWD              Pack it\n         ED    VolTbl_Ent_Display+V_Stats_Line5_CPUTime-V_Stats_Line5(L+\n               'V_Stats_Line5_CPUTime),@V_DBLWD+5\n\n         TM    @_OW48527,L'@_OW48527     Is OW48527 on?\n         JO    V00100B                   Yes, never went NONSWAP\n\n         LA    R1,VolTbl_Ent_Display+V_Stats_Line5_CPUTime+L'V_Stats_Li+\n               ne5_CPUTime-V_Stats_Line5 A(End of line)\n         MVC   0(29,R1),=C', Non-Swappable Elapsed Time:'\n         MVC   29(7,R1),=X'4021204B202020' Move mask\n         LM    R14,R15,@_NSwap_Time      Get Non-swappable time\n         SRDL  R14,12                    Convert to usec\n         D     R14,=FL4'1000'            Convert to millisecs\n         CVD   R15,@V_DBLWD              Pack it\n         ED    29(7,R1),@V_DBLWD+5       Edit into message\n\nV00100B  DS    0H\n         OI    VolTbl_Ent_Stats_Done,L'VolTbl_Ent_Stats_Done Done now\n\n         L     R0,VolTbl_Ent_ECB        Current contents of our ECB\n         TM    VolTbl_Ent_ECB,X'80'     Anyone WAITing?\n         JO    V00100C                  Yes, we need to POST\n         L     R1,=XL4'40000000'        No, POST code of 0\n         CS    R0,R1,VolTbl_Ent_ECB     Pseudo-POST it\n         JZ    V00110                   OK, skip the real POST\nV00100C  DS    0H\n         POST  VolTbl_Ent_ECB,0         POST line as complete\n\nV00110   DS    0H\n         LA    R15,0                    Clear return code\n         J     V90010                   and exit\n\nV01999   DS    0H\n*---------------------------------------------------------------------*\n*   Unknown Stats Line, exit                                          *\n*---------------------------------------------------------------------*\n         LA    R15,0                    Clear return code\n         J     V90010                   and exit\n\n\nV90010   DS    0H\n*-------------------------------------------------------------------*\n*    Free up our local storage ...                                  *\n*-------------------------------------------------------------------*\n         LR    R3,R15                   Save return code\n\n         LA    R1,@V_Dynam              A(Local storage)\n         L     R2,@V_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         L     R13,4(0,R13)             Rescue A(HSA)\n\n         SSCSTACK POP,                  Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=(R2)                on this stack\n\n         LR    R15,R3                   Restore return code\n\n*-------------------------------------------------------------------*\n*    ... and return to caller                                       *\n*-------------------------------------------------------------------*\n         L     R14,12(0,R13)            Restore return address\n         LM    R0,R12,20(R13)           Restore other registers\n         BSM   0,R14                    and return\n\nV_Literals  DS  0H\n\n\nV_Stats_Line4         EQU   *\n                      DC    C' '\nV_Stats_Line4_Stack   DC    C'31'\n                      DC    C'-Bit Stack: Size:'\nV_Stats_Line4_Size    DC    X'402020202120'\n                      DC    C', HWM:'\nV_Stats_Line4_HWM     DC    X'402020202120'\n                      DC    C', GETMAINs:'\nV_Stats_Line4_GETMAIN DC    X'402020202120'\n                      DC    C', GETMAIN HWM:'\nV_Stats_Line4_GHWM    DC    X'402020202120'\nV_Stats_Line4_Len     EQU   *-V_Stats_Line4\n\nV_Stats_Line5         EQU   *\n                      DC    C' '\n                      DC    C'Main Task CPU Time:'\nV_Stats_Line5_CPUTime DC    X'4021204B202020'\nV_Stats_Line5_Len     EQU   *-V_Stats_Line5\n\n         LTORG\n\nV_Literals_End  DS  0H\n\n\n@V_Dynam                  DSECT        Dynamic area for V00000\n                          DS    18F     O/S Style save area\n@V_31Bit_Stack_Ptr_Ptr    DS    AL4     A(31-bit Stack Ptr)\n@V_24Bit_Stack_Ptr_Ptr    DS    AL4     A(24-bit Stack Ptr)\n@V_DBLWD                  DS    D       Work area\n                          DS    0D      Alignment\n@V_Dynam_Length           EQU   *-@V_Dynam Length of storage\n\n&PGMNAME CSECT\n\n         DROP  ,\n         POP   USING\n         TITLE 'W00010: Point to next free VolTbl entry'\n\n         PUSH  USING\n\nW00010   DS    0H\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Subroutine: W00010                                                 *\n*                                                                     *\n*  Abstract  : Return a pointer to the next free entry in VolTbl. If  *\n*              all entries are used, a larger VolTbl is GETMAINed, and*\n*              the current table copied to the new                    *\n*                                                                     *\n*  Inputs    : R1 : ---> A(@_Dynam)                                   *\n*                        A(31-bit Stack Pointer)                      *\n*                        A(24-bit Stack Pointer)                      *\n*  Outputs   : R1 : A(Free entry) or 0 if storage unavailable         *\n*                                                                     *\n*  Notes     : N/A                                                    *\n*                                                                     *\n*  History:    1999/08/20 SDDA030 - V2.8                              *\n*                                 - New                               *\n*              2006/04/21 SDDA030 - V2.24                             *\n*                                 - Used conditional STORAGE OBTAINs  *\n*                                   when expanding VolTbl             *\n*              ____/__/__ _______                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         STM   R14,R12,12(R13)          Save callers registers\n         LARL  R11,W_Literals           Point to our literals\n         USING (W_Literals,W_Literals_End),R11 Tell the assembler\n\n         L     R12,0(0,R1)              A(@_Dynam)\n         USING @_Dynam,R12              Tell the assembler\n\n*-------------------------------------------------------------------*\n*    Get an area on the stack for our local storage                 *\n*-------------------------------------------------------------------*\n         L     R2,4(0,R1)               A(31-bit stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         SSCSTACK PUSH,                 Get stack area                 +\n               LEN=@W_Dynam_Length,      this long                     +\n               STACK=(R2)                using this stack\n\n         LR    R3,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LHI   R1,@W_Dynam_Length        Its length\n         LA    R14,0                    Clear source address\n         LA    R15,0                     and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R3                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*-------------------------------------------------------------------*\n         ST    R13,4(0,R1)              Chain\n         ST    R1,8(0,R13)               saveareas\n         LR    R13,R1                   Load dynam base\n         USING @W_Dynam,R13             Assign a base\n         L     R15,@W_Dynam+4           Get A(HSA)\n         LM    R0,R3,20(R15)            Restore callers registers\n\n         L     R15,4(0,R1)              A(31-bit Stack Pointer)\n         ST    R15,@W_31Bit_Stack_Ptr_Ptr Save it\n         L     R15,8(0,R1)              A(24-bit Stack Pointer)\n         ST    R15,@W_24Bit_Stack_Ptr_Ptr Save it\n\nW00020   DS    0H\n*---------------------------------------------------------------------*\n*   Point to the next free entry                                      *\n*---------------------------------------------------------------------*\n         LA    R14,0                    Clear used length\n         LA    R15,0                    Clear table length\n         ICM   R1,B'1111',@_VolTbl_Ptr  A(Current table)\n         JZ    W00030                   None, skip\n         LHI   R14,VolTbl_Ent_Len       Yes, Length of 1 entry\n         L     R15,VolTbl_Hdr_Count-VolTbl_Hdr(R1) Current entries used\n         MR    R14,R14                  Get current length used\n         LR    R14,R15                  Save it\n         L     R15,VolTbl_Hdr_TbLen-VolTbl(R1) Get len of table\n         AR    R15,R1                   Point to end of table\nW00030   DS    0H\n         LA    R1,VolTbl_Ent-VolTbl(R1,R14) Point to next (free) entry\n         SR    R15,R1                   Get length remaining\n         LHI   R0,VolTbl_Ent_Len        Length of 1 entry\n         CR    R15,R0                   Do we have room to add?\n         JNL   W00060                   Yes, skip\n\n*---------------------------------------------------------------------*\n*   We have to get a new table, so get the current number of entries  *\n*---------------------------------------------------------------------*\n         TM    @_VolTbl_GETMAIN_Err,L'@_VolTbl_GETMAIN_Err\n         JO    W80010                   Yes, just exit with error\n\n         LHI   R15,99                   Initial nbr entries (1st time)\n         ICM   R1,B'1111',@_VolTbl_Ptr  A(Table)\n         JZ    W00040                   None, skip\n         L     R15,VolTbl_Hdr_Count-VolTbl_Hdr(R1) Yes, get nbr ents\n\nW00040   DS    0H\n*---------------------------------------------------------------------*\n*   Calculate the Min (1 more entry) and Max (double the number of    *\n*    entries) lengths of the new table ...                            *\n*---------------------------------------------------------------------*\n         LA    R0,1(0,R15)              Min of 1 more entry\n         LHI   R1,VolTbl_Ent_Len        Length of 1 entry\n         MR    R0,R0                    Get new length of entries\n         LA    R4,VolTbl_Ent-VolTbl(R1) Add length of header\n         AHI   R4,7                     Make sure its\n         SRL   R4,3                      a doubleword\n         SLL   R4,3                      multiple\n\n         LR    R0,R15                   Max len of double\n         SLL   R0,1                      the number of entries\n         LHI   R1,VolTbl_Ent_Len        Length of 1 entry\n         MR    R0,R0                    Get new length of entries\n         LA    R5,VolTbl_Ent-VolTbl(R1) Add length of header\n         AHI   R5,7                     Make sure its\n         SRL   R5,3                      a doubleword\n         SLL   R5,3                      multiple\n\n*---------------------------------------------------------------------*\n*   ... and go get storage for it                                     *\n*---------------------------------------------------------------------*\n         BASR  R2,0\n         USING (*,W00040_End-1),R2\n         STORAGE OBTAIN,                Go get a table                 +\n               LENGTH=((4),(5)),         this long                     +\n               LOC=31,                   above-the-line                +\n               COND=YES,                 let us know what happens      +\n               ADDR=(3)                  return address here\nW00040_End DS  0H\n         DROP  R2\n\n         LTR   R15,R15                  Did we get the storage?\n         JNZ   W80010                   No, oh dear\n\n*---------------------------------------------------------------------*\n*   Copy the old table to the new.                                    *\n*---------------------------------------------------------------------*\n         LR    R4,R0                    Save new table length\n         LR    R1,R0                    New table length\n         LR    R0,R3                    Point to the new table\n         LA    R15,0                    Clear old table length\n         ICM   R14,B'1111',@_VolTbl_Ptr A(Old table)\n         JZ    W00050                   None, skip\n         L     R15,VolTbl_Hdr_TbLen-VolTbl(R14) Yes, get current length\nW00050   DS    0H\n         MVCL  R0,R14                   Move old to new\n         ST    R4,VolTbl_Hdr_TbLen-VolTbl(R3) Update table length\n         L     R1,@_VolTbl_Ptr          A(Old table)\n         ST    R3,@_VolTbl_Ptr          Update with A(New table)\n         LTR   R1,R1                    Is there an old table?\n         JZ    W00020                   No, start again\n\n*---------------------------------------------------------------------*\n*   Free up the old table                                             *\n*---------------------------------------------------------------------*\n         L     R0,VolTbl_Hdr_TbLen-VolTbl(R1) Get its length\n         BASR  R2,0\n         USING (*,W00050_End-1),R2\n         STORAGE RELEASE,               Free the old table             +\n               ADDR=(1),                 starting here                 +\n               LENGTH=(0)                for this long\nW00050_End DS  0H\n         DROP  R2\n         J     W00020                   Start again\n\nW00060   DS    0H\n*---------------------------------------------------------------------*\n*   We have an new entry: bump nbr entries used ...                   *\n*---------------------------------------------------------------------*\n         L     R15,@_VolTbl_Ptr         A(Volume Table)\n         L     R14,VolTbl_Hdr_Count-VolTbl_Hdr(R15) Get # used entries\n         AHI   R14,1                    Bump it\n         ST    R14,VolTbl_Hdr_Count-VolTbl_Hdr(R15) Save it\n\n*---------------------------------------------------------------------*\n*   ... and initialize the entry.                                     *\n*---------------------------------------------------------------------*\n         LR    R2,R1                    Save Entry address\n\n         LR    R0,R2                    A(Target)\n         LHI   R1,VolTbl_Ent_Len        Length of entry\n         LA    R14,0                    A(Source)\n         LA    R15,0                    Length of source\n         MVCL  R0,R14                   Set table entry to X'00'\n\n         LA    R0,VolTbl_Ent_Display-VolTbl_Ent(R2) A(Display area)\n         LHI   R1,VolTbl_Ent_Display_Len Length of display area\n         LA    R14,0                    A(Source)\n         L     R15,=XL4'40000000'       Source len = 0, pad = blank\n         MVCL  R0,R14                   Set display area to blanks\n\n         LR    R1,R2                    A(Table entry)\n         SLR   R15,R15                  Clear return code\n         J     W90010                   and exit\n\nW80010   DS    0H\n*-------------------------------------------------------------------*\n*    STORAGE OBTAIN error: set a flag so we don't try to get more,  *\n*                          set return code, and exit                *\n*-------------------------------------------------------------------*\n         OI    @_VolTbl_GETMAIN_Err,L'@_VolTbl_GETMAIN_Err\n         SLR   R1,R1                    Clear A(New entry)\n         LA    R15,8                    Set return code\n         J     W90010                   and exit\n\nW90010   DS    0H\n*-------------------------------------------------------------------*\n*    Free up our local storage ...                                  *\n*-------------------------------------------------------------------*\n         LR    R3,R1                    Save A(Free entry)\n         LR    R4,R15                   Save return code\n\n         LA    R1,@W_Dynam              A(Local storage)\n         L     R2,@W_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         L     R13,4(0,R13)             Rescue A(HSA)\n\n         SSCSTACK POP,                  Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=(R2)                on this stack\n\n         LR    R1,R3                    Restore A(Free entry)\n         LR    R15,R4                   Restore return code\n\n*-------------------------------------------------------------------*\n*    ... and return to caller                                       *\n*-------------------------------------------------------------------*\n         L     R14,12(0,R13)            Restore return address\n         L     R0,20(0,R13)             Restore R0\n         LM    R2,R12,28(R13)           Restore other registers\n         BSM   0,R14                    and return\n\nW_Literals  DS  0H\n\n         LTORG\n\nW_Literals_End  DS  0H\n\n\n@W_Dynam                  DSECT       Dynamic area for W00000\n@W_Save                   DS    18F    O/S Style save area\n@W_31Bit_Stack_Ptr_Ptr    DS    AL4    A(31-bit Stack Ptr)\n@W_24Bit_Stack_Ptr_Ptr    DS    AL4    A(24-bit Stack Ptr)\n                          DS    0D     Alignment\n@W_Dynam_Length           EQU   *-@W_Dynam Length of storage\n\n&PGMNAME CSECT\n\n         DROP  ,\n         POP   USING\n         TITLE 'X00010: Write data to OUTFIL'\n\n         PUSH  USING\n\nX00010   DS    0H\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Subroutine: X00010                                                 *\n*                                                                     *\n*  Abstract  : This subroutine goes through the VolTbl, writing       *\n*              detail lines to the DDName passed.                     *\n*                                                                     *\n*  Inputs    : R1 : ---> A(@_Dynam)                                   *\n*                        A(31-bit Stack Pointer)                      *\n*                        A(24-bit Stack Pointer)                      *\n*                        A(DDName)                                    *\n*                        A(OutData flag)                              *\n*  Outputs   : R15: 0 = OK                                            *\n*                   8 = Error (DCB not OPEN, etc.)                    *\n*                                                                     *\n*  Operation : Set up parms for U00010                                *\n*              Do for each Detail line in VolTbl                      *\n*                Invoke U00010                                        *\n*              EndDo                                                  *\n*              Return to caller                                       *\n*                                                                     *\n*  History:    2000/01/19 SDDA030 - V2.11                             *\n*                                   New                               *\n*              2000/05/23 SDDA030 - V2.12                             *\n*                                   Added check for OUTFILE(SYSPRINT) *\n*                                   Checked BLKSIZE=0                 *\n*              2001/02/26 SDDA030 - V2.14                             *\n*                                   Output all detail entries from    *\n*                                   VolTbl instead of one at a time.  *\n*              2002/03/11 SDDA030 - V2.17                             *\n*                                   Converted RDJFCB to SWAREQ.       *\n*                                   Updated logic for LRECL, BLKSIZE. *\n*                                   Improved efficiency.              *\n*                                   Preserved BLKSIZE for RECFM=U.    *\n*              2002/06/11 SDDA030 - V2.18                             *\n*                                   WAIT for VolTbl_Ent to be populated\n*                                   before outputting                 *\n*              2003/10/07 SDDA030 - V2.21                             *\n*                                   Accept DDName, OutData flag as    *\n*                                   parms.                            *\n*                                   Remove check for SYSPRINT.        *\n*                                   Moved OPEN/CLOSE, I/O to U00010.  *\n*              2006/04/21 SDDA030 - V2.24                             *\n*                                   Used standardised calling sequence*\n*              ____/__/__ ______                                      *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         STM   R14,R12,12(R13)          Save callers registers\n         LARL  R11,X_Literals           Point to our literals\n         USING (X_Literals,X_Literals_End),R11 Tell the assembler\n\n         L     R12,0(0,R1)              A(@_Dynam)\n         USING @_Dynam,R12              Tell the assembler\n\n*-------------------------------------------------------------------*\n*    Get an area on the stack for our local storage                 *\n*-------------------------------------------------------------------*\n         L     R2,4(0,R1)               A(31-bit stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         SSCSTACK PUSH,                 Get stack area                 +\n               LEN=@X_Dynam_Length,      this long                     +\n               STACK=(R2)                using this stack\n\n         LR    R3,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LHI   R1,@X_Dynam_Length        Its length\n         LA    R14,0                    Clear source address\n         LA    R15,0                     and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R3                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*-------------------------------------------------------------------*\n         ST    R13,4(0,R1)              Chain\n         ST    R1,8(0,R13)               saveareas\n         LR    R13,R1                   Load dynam base\n         USING @X_Dynam,R13             Assign a base\n         L     R15,@X_Dynam+4           Get A(HSA)\n         LM    R0,R3,20(R15)            Restore callers registers\n\n         L     R15,4(0,R1)              A(31-bit Stack Pointer)\n         ST    R15,@X_31Bit_Stack_Ptr_Ptr Save it\n         L     R15,8(0,R1)              A(24-bit Stack Pointer)\n         ST    R15,@X_24Bit_Stack_Ptr_Ptr Save it\n\n*--------------------------------------------------------------------*\n*   Initialize our standard parmlist                                 *\n*--------------------------------------------------------------------*\n         LA    R15,@_Dynam              A(Dynamic area)\n         ST    R15,@X_Parms_Std         Save it\n         L     R15,@X_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)\n         ST    R15,@X_Parms_Std+4       Save it\n         L     R15,@X_24Bit_Stack_Ptr_Ptr A(24-bit Stack Pointer)\n         ST    R15,@X_Parms_Std+8       Save it\n\n*-------------------------------------------------------------------*\n*    Build our parm list for U00010                                 *\n*-------------------------------------------------------------------*\n        ICM   R15,B'1111',12(R1)        A(DDName)\n        JZ    X00350                    None, exit quietly\n        ST    R15,@X_Parms_U00010       OK, save it\n\n*-------------------------------------------------------------------*\n*    Get the length and offset of the data we will be writing       *\n*-------------------------------------------------------------------*\n         ICM   R1,B'1111',16(R1)         A(OutData flag)\n         TM    0(R1),L'@_OutData_DISPLAY  Display only?\n         JNO   X00260                  No, skip\n         LA    R14,VolTbl_Ent_Display-VolTbl_Ent Yes, Offset of start\n         LHI   R15,VolTbl_Ent_Display_Len and get length\n         J     X00280                  skip\nX00260   DS    0H\n         TM    0(R1),L'@_OutData_CB    Control Blocks only?\n         JNO   X00270                  No, skip\n         LA    R14,VolTbl_Ent_CB_Start-VolTbl_Ent Yes, Offset of start\n         LHI   R15,VolTbl_Ent_CB_End-VolTbl_Ent_CB_Start and length\n         J     X00280                  and skip\nX00270   DS    0H\n         LA    R14,VolTbl_Ent_CB_Start-VolTbl_Ent ALL, Offset of CB)\n         LHI   R15,VolTbl_Ent_Display_End-VolTbl_Ent_CB_Start Length\nX00280   DS    0H\n         ST    R14,@X_Source_Offset    Save Offset\n         ST    R15,@X_Source_Len       Save Length\n         LA    R15,@X_Source_Len       A(Length)\n         ST    R15,@X_Parms_U00010+8   Save for U00010\n\n         OI    @X_Parms_U00010+8,X'80'   Flag as last\n\n*-------------------------------------------------------------------*\n*    Go through VolTbl ...                                          *\n*-------------------------------------------------------------------*\n         ICM   R9,B'1111',@_VolTbl_Ptr A(Volume Table)\n         JZ    X00350                  None, exit quietly\n         ICM   R10,B'1111',VolTbl_Hdr_Count-VolTbl(R9) Get nbr vols\n         JZ    X00350                  None, we're done\n         LA    R9,VolTbl_Ent-VolTbl(R9) A(1st entry)\n\n         Using VolTbl_Ent,R9           Tell the assembler\n\nX00330   DS    0H\n*-------------------------------------------------------------------*\n*    If this is a detail line, write it out                         *\n*-------------------------------------------------------------------*\n         TM    VolTbl_Ent_Detail_Line,L'VolTbl_Ent_Detail_Line Detail?\n         JNO   X00340                  No, skip it\n         TM    VolTbl_Ent_SMS_Line,L'VolTbl_Ent_SMS_Line SMS Anomaly?\n         JO    X00340                  Yes, skip it\n\n         TM    VolTbl_Ent_ECB,X'40'    Yes, is it populated?\n         JO    X00330C                 Yes, OK\n         WAIT  ECB=VolTbl_Ent_ECB      No, WAIT 'till it is\nX00330C  DS    0H\n         LA    R15,VolTbl_Ent          A(Entry)\n         A     R15,@X_Source_Offset    Point to our data\n         ST    R15,@X_Parms_U00010+4   Save it\n\n         LA    R1,@X_Parms             A(Parm list)\n         BRAS  R14,U00010              Output it\n\nX00340   DS    0H\n*-------------------------------------------------------------------*\n*    And process the next entry                                     *\n*-------------------------------------------------------------------*\n         AHI   R9,VolTbl_Ent_Len       A(Next VolTbl entry)\n         BRCT  R10,X00330              and do the next\n\nX00350   DS    0H\n*-------------------------------------------------------------------*\n*    Clear the return code, and exit.                               *\n*-------------------------------------------------------------------*\n         LA    R15,0                   Clear return code\n         J     X90010                  and exit\n\nX90010   DS    0H\n*-------------------------------------------------------------------*\n*    Free up our local storage ...                                  *\n*-------------------------------------------------------------------*\n         LR    R3,R15                   Save Return Code\n\n         LA    R1,@X_Dynam              A(Local storage)\n         L     R2,@X_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         L     R13,4(0,R13)             Rescue A(HSA)\n\n         SSCSTACK POP,                  Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=(R2)                on this stack\n\n         LR    R15,R3                   Restore Return Code\n\n*-------------------------------------------------------------------*\n*    ... and return to caller                                       *\n*-------------------------------------------------------------------*\n         L     R14,12(0,R13)            Restore return address\n         LM    R0,R12,20(R13)           Restore other registers\n         BSM   0,R14                    and return\n\nX_Literals  DS  0H\n\n         LTORG\n\nX_Literals_End  DS  0H\n\n\n@X_Dynam                  DSECT       Dynamic area for 10000\n                          DS    18F    O/S Style save area\n@X_31Bit_Stack_Ptr_Ptr    DS    AL4    A(31-bit Stack Ptr)\n@X_24Bit_Stack_Ptr_Ptr    DS    AL4    A(24-bit Stack Ptr)\n\n@X_Source_Offset          DS    FL4    Offset (in VolTbl_Ent)\n@X_Source_Len             DS    FL4    Length of data\n\n@X_Parms                  DS    0F     Parms for called rtns\n@X_Parms_Std              DS    3AL4    Standard 3 parms\n@X_Parms_Extra            EQU   *       Extra parms\n@X_Parms_U00010           DS    4AL4       for U00010\n                          ORG   ,\n\n                          DS    0D     Alignment\n@X_Dynam_Length           EQU   *-@X_Dynam Length of storage\n\n&PGMNAME CSECT\n\n         DROP  ,\n         POP   USING\n         TITLE 'Y00010: SYSPRINT I/O Routine'\n\n         PUSH  USING\n\nY00010   DS    0H\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Subroutine: Y00010                                                 *\n*                                                                     *\n*  Abstract  : This subroutine manages messages destined for SYSPRINT.*\n*                                                                     *\n*  Inputs    : R1 : ---> A(@_Dynam)                                   *\n*                        A(31-bit Stack Pointer)                      *\n*                        A(24-bit Stack Pointer)                      *\n*                        A(Data to be written) or 0                   *\n*                        Length of data to be written                 *\n*  Outputs   : R15: 0 = OK                                            *\n*                   8 = Error (SYSPRINT not OPEN, etc.)               *\n*                                                                     *\n*  Notes     :                                                        *\n*                                                                     *\n*  History:    1998/10/01 SDDA030 - New                               *\n*              1999/05/27 SDDA030 - V2.6                              *\n*                                 - Moved back into mainline code.    *\n*                                 - Used LIFO Stack for our dynamic   *\n*                                   areas.                            *\n*              1999/09/30 SDDA030 - V2.10                             *\n*                                 - Used @_Line_Count values to gen-  *\n*                                   erate Hdr0-3.                     *\n*              2001/02/26 SDDA030 - V2.14                             *\n*                                 - Headings now in table.            *\n*                                 - Only write DCBLRECLs worth of     *\n*                                   data to SYSPRINT.                 *\n*              2003/10/07 SDDA030 - V2.21                             *\n*                                 - Moved OPEN/CLOSE, I/O to U00010.  *\n*                                 - Trimmed trailing spaces.          *\n*              2006/04/21 SDDA030 - V2.24                             *\n*                                 - Used standardised calling sequence*\n*                                 - Checked length to be written      *\n*                                   against LINESIZE()                *\n*              ____/__/__ ______                                      *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         STM   R14,R12,12(R13)          Save callers registers\n         LARL  R11,Y_Literals           Point to our literals\n         USING (Y_Literals,Y_Literals_End),R11 Tell the assembler\n\n         L     R12,0(0,R1)              A(@_Dynam)\n         USING @_Dynam,R12              Tell the assembler\n\n*-------------------------------------------------------------------*\n*    Get an area on the stack for our local storage                 *\n*-------------------------------------------------------------------*\n         L     R2,4(0,R1)               A(31-bit stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         SSCSTACK PUSH,                 Get stack area                 +\n               LEN=@Y_Dynam_Length,      this long                     +\n               STACK=(R2)                using this stack\n\n         LR    R3,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LHI   R1,@Y_Dynam_Length        Its length\n         LA    R14,0                    Clear source address\n         LA    R15,0                     and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R3                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*-------------------------------------------------------------------*\n         ST    R13,4(0,R1)              Chain\n         ST    R1,8(0,R13)               saveareas\n         LR    R13,R1                   Load dynam base\n         USING @Y_Dynam,R13             Assign a base\n         L     R15,@Y_Dynam+4           Get A(HSA)\n         LM    R0,R3,20(R15)            Restore callers registers\n\n         L     R15,4(0,R1)              A(31-bit Stack Pointer)\n         ST    R15,@Y_31Bit_Stack_Ptr_Ptr Save it\n         L     R15,8(0,R1)              A(24-bit Stack Pointer)\n         ST    R15,@Y_24Bit_Stack_Ptr_Ptr Save it\n\n*--------------------------------------------------------------------*\n*   Initialize our standard parmlist                                 *\n*--------------------------------------------------------------------*\n         LA    R15,@_Dynam              A(Dynamic area)\n         ST    R15,@Y_Parms_Std         Save it\n         L     R15,@Y_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)\n         ST    R15,@Y_Parms_Std+4       Save it\n         L     R15,@Y_24Bit_Stack_Ptr_Ptr A(24-bit Stack Pointer)\n         ST    R15,@Y_Parms_Std+8       Save it\n\n*-------------------------------------------------------------------*\n*    If we have nothing to do, just exit.                           *\n*-------------------------------------------------------------------*\n         ICM   R15,B'1111',12(R1)       A(Data to be printed)\n         JZ    Y00130                   Nothing, just exit\n         ICM   R0,B'1111',16(R1)        Len of data\n         JZ    Y00130                   Nothing, just exit\n         LR    R1,R15                   A(Date in proper register)\n         ST    R15,@Y_Passed_Data_Ptr   Save A(Data)\n         ST    R0,@Y_Passed_Data_Len    and length\n\n         LA    R15,Y_SYSPRINT           A(DDNAme)\n         ST    R15,@Y_Parms_U00010      Save it for U00010\n         LA    R15,@Y_Data_Len          Point to length\n         ST    R15,@Y_Parms_U00010+8    Update Parms\n         LA    R15,@Y_ASA_Char          A(Our ASA character)\n         ST    R15,@Y_Parms_U00010+12   Save it\n\n*---------------------------------------------------------------------*\n*       Set our max len to LINESIZE(), if applicable                  *\n*---------------------------------------------------------------------*\n         LHI   R15,VolTbl_Ent_Display_Len Max len of data\nY00020   DS    0H\n         LH    R1,@_LineSize            Get linesize from command line\n         LTR   R1,R1                    Anything?\n         JNP   Y00040                   LINESIZE(MAX) or none, skip\n         CR    R15,R1                   Can we display all the data?\n         JNH   Y00040                   Yes, OK\n         LR    R15,R1                   No, display as much as we can\nY00040   DS    0H\n         STH   R15,@Y_LineSize          Save it\n\n*---------------------------------------------------------------------*\n*       Print headings, if required. By convention, the line count    *\n*      determines what headings to print:                             *\n*        =4095: Hdg1 only                                             *\n*        =4094: Hdg2-4 only                                           *\n*        >60  : Hdg1-4                                                *\n*---------------------------------------------------------------------*\n         MVI   @Y_ASA_Char,C' '         Assume single space\n\n         LH    R15,@_Line_Count         Get current line count\n         CHI   R15,60                   Over a page?\n         JNH   Y00090                   No, skip\n         TM    @_No_Headings,L'@_No_Headings Yes, do we want headings?\n         JO    Y00090                   No, skip\n         ICM   R9,B'1111',@_VolTbl_Ptr  Yes, get A(VolTbl)\n         JZ    Y00090                   None, no headings\n\n*-------------------------------------------------------------------*\n*    We are about to print headings - set up the length field ...   *\n*-------------------------------------------------------------------*\n         LH    R0,@Y_LineSize          Length of source data\n         ST    R0,@Y_Data_Len           Save it\n         L     R10,VolTbl_Hdr_Count-VolTbl_Hdr(R9) Yes, get count\n         AHI   R9,VolTbl_Ent-VolTbl     and point to first entry\n         USING VolTbl_Ent,R9            Assign a base\n\n         LH    R15,@_Line_Count         Get line count\n         CHI   R15,4094                 Hdg2-4 only?\n         JE    Y00070                   Yes, skip Hdg0\n\n*-------------------------------------------------------------------*\n*    ... Hdg0 ...                                                   *\n*-------------------------------------------------------------------*\n         CHI   R10,1                    Check VolTbl_Ent count\n         JL    Y00090                   No heading, skip\n         TM    VolTbl_Ent_Heading_Line1,L'VolTbl_Ent_Heading_Line1 Hdg1\n         JNO   Y00060                   No, skip\n         MVI   @Y_ASA_Char,C'1'         Yes, start a new page\n         LA    R15,VolTbl_Ent_Display   Point to Heading 1\n         ST    R15,@Y_Parms_U00010+4    Update Parms\n         AHI   R15,VolTbl_Ent_Display_Len-8 A(Page Literal)\nY00050   DS    0H\n         MVC   0(4,R15),=C'Page'        Move page lit\n         LH    R0,@_Page_Count          Get Page count\n         AHI   R0,1                     Bump it\n         STH   R0,@_Page_Count          Save it\n         CVD   R0,@Y_DBLWD              Pack it\n         MVC   4(4,R15),=X'40202120'    Move mask\n         ED    4(4,R15),@Y_DBLWD+6      Edit page count\n         OI    7(R15),X'F0'             Make it readable\n         LA    R1,@Y_Parms              A(Parm list)\n         BRAS  R14,U00010               Output Hdg1\n\n         MVI   @Y_ASA_Char,C'0'         skip a line\n         LH    R15,@_Line_Count         Get line count\n         CHI   R15,4094                 Hdg0 only?\n         JNH   Y00070                   No, all headings\n         LHI   R15,1                    Yes, initialize line count\n         J     Y00090                   and skip\n\nY00060   DS    0H\n*-------------------------------------------------------------------*\n*    ... Hdg1-Hdg3 ...                                              *\n*-------------------------------------------------------------------*\n         TM    VolTbl_Ent_Heading_Line,L'VolTbl_Ent_Heading_Line Hdg?\n         JNO   Y00080                   No, end of headings\n         LA    R14,VolTbl_Ent_Display   A(Source data)\n         ST    R14,@Y_Parms_U00010+4    Save it for U00010\n         LA    R1,@Y_Parms              A(Parm list)\n         BRAS  R14,U00010               Output it\n         MVI   @Y_ASA_Char,C' '         single space\nY00070   DS    0H\n         AHI   R9,VolTbl_Ent_Len        A(Next entry\n         BRCT  R10,Y00060               and do next one\nY00080   DS    0H\n         LHI   R15,5                    Re-init line count\n\n         DROP  R9                       No more VolTbl_Ent base\n\nY00090   DS    0H\n*---------------------------------------------------------------------*\n*       ... and then write the data passed to us.                     *\n*---------------------------------------------------------------------*\n         AHI   R15,1                    Bump line count\n         STH   R15,@_Line_Count         Save line count\n         L     R0,@Y_Passed_Data_Len    Get length of data\n         CH    R0,@Y_LineSize           Too long?\n         JNH   Y00100                   No, OK\n         LH    R0,@Y_LineSize           Yes, reset it\nY00100   DS    0H\n         L     R1,@Y_Passed_Data_Ptr    A(Data)\n         LR    R15,R1                   Point past\n         AR    R15,R0                    last character\nY00110   DS    0H\n         S     R15,=FL4'1'              Back up a byte\n         CR    R15,R1                   Too far?\n         JNH   Y00120                   Yes, skip\n         CLI   0(R15),C' '              Trailing space?\n         JE    Y00110                   Yes, back up and try again\nY00120   DS    0H\n         SLR   R15,R1                   Length of\n         AHI   R15,1                     data1\n         ST    R15,@Y_Data_Len          Save length\n         ST    R1,@Y_Parms_U00010+4     Save A(Data)\n         LA    R1,@Y_Parms              A(Parm list)\n         BRAS  R14,U00010               Output it\n\nY00130   DS    0H\n*---------------------------------------------------------------------*\n*       Exit with a return code of 0                                  *\n*---------------------------------------------------------------------*\n         LA    R15,0                    Clear return code\n         J     Y90010                   and exit\n\n\nY90010   DS    0H\n*-------------------------------------------------------------------*\n*    Free up our local storage ...                                  *\n*-------------------------------------------------------------------*\n         LR    R3,R15                   Save return code\n\n         LA    R1,@Y_Dynam              A(Local storage)\n         L     R2,@Y_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         L     R13,4(0,R13)             Rescue A(HSA)\n\n         SSCSTACK POP,                  Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=(R2)                on this stack\n\n         LR    R15,R3                   Restore return code\n\n*-------------------------------------------------------------------*\n*    ... and return to caller                                       *\n*-------------------------------------------------------------------*\n         L     R14,12(0,R13)            Restore return address\n         LM    R0,R12,20(R13)           Restore other registers\n         BSM   0,R14                    and return\n\nY_Literals  DS  0H\n\nY_SYSPRINT  DC  CL8'SYSPRINT'\n\n         LTORG\n\nY_Literals_End  DS  0H\n\n\n@Y_Dynam                  DSECT       Dynamic area for Y00000\n                          DS    18F    O/S Style save area\n@Y_31Bit_Stack_Ptr_Ptr    DS    AL4    A(31-bit Stack Ptr)\n@Y_24Bit_Stack_Ptr_Ptr    DS    AL4    A(24-bit Stack Ptr)\n@Y_DBLWD                  DS    D      Work area\n@Y_LineSize               DS    HL2    Max line size\n@Y_Passed_Data_Ptr        DS    AL4    A(Data passed to us)\n@Y_Passed_Data_Len        DS    FL4    Len of data passed to us\n@Y_Data_Len               DS    FL4    Length of data\n@Y_ASA_Char               DS    X      Carriage control character\n\n@Y_Parms                  DS    0F     Parms for called rtns\n@Y_Parms_Std              DS    3AL4    Standard 3 parms\n@Y_Parms_Extra            EQU   *       Extra parms\n@Y_Parms_U00010           DS    4AL4        for U00010\n                          ORG   ,\n                          DS    0D     Alignment\n@Y_Dynam_Length           EQU   *-@Y_Dynam Length of storage\n\n&PGMNAME CSECT\n\n         DROP  ,\n         POP   USING\n         TITLE 'Z00010: Termination'\n\n         PUSH  USING\n\nZ00010   DS    0H\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Subroutine: Z00010                                                 *\n*                                                                     *\n*  Abstract  : Perform one-time termination processes based on        *\n*              environment.                                           *\n*                                                                     *\n*  Inputs    : R1 : ---> A(@_Dynam)                                   *\n*                        A(31-bit Stack Pointer)                      *\n*                        A(24-bit Stack Pointer)                      *\n*  Outputs   : R15: 0                                                 *\n*                                                                     *\n*  Notes     :                                                        *\n*                                                                     *\n*  History:    1990/06/11 SDDA030 - New                               *\n*              1998/09/21 SDDA030 - Added CLOSEs for SYSIN and        *\n*                                   SYSPRINT in batch mode            *\n*              1998/10/01 SDDA030 - Free up 24-bit storage            *\n*              1999/05/27 SDDA030 - V2.6                              *\n*                                 - Used LIFO Stack for our dynamic   *\n*                                   areas.                            *\n*                                 - Remove CLOSE and STORAGE RELEASE  *\n*              2002/03/11 SDDA030 - V2.17                             *\n*                                 - Freed up the STORGRP selection    *\n*                                   list                              *\n*              2006/04/21 SDDA030 - V2.24                             *\n*                                 - Used standardised calling sequence*\n*              ____/__/__ _______                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         STM   R14,R12,12(R13)          Save callers registers\n         LARL  R11,Z_Literals           Point to our literals\n         USING (Z_Literals,Z_Literals_End),R11 Tell the assembler\n\n         L     R12,0(0,R1)              A(@_Dynam)\n         USING @_Dynam,R12              Tell the assembler\n\n*-------------------------------------------------------------------*\n*    Get an area on the stack for our local storage                 *\n*-------------------------------------------------------------------*\n         L     R2,4(0,R1)               A(31-bit stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         SSCSTACK PUSH,                 Get stack area                 +\n               LEN=@Z_Dynam_Length,      this long                     +\n               STACK=(R2)                using this stack\n\n         LR    R3,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LHI   R1,@Z_Dynam_Length        Its length\n         LA    R14,0                    Clear source address\n         LA    R15,0                     and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R3                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*-------------------------------------------------------------------*\n         ST    R13,4(0,R1)              Chain\n         ST    R1,8(0,R13)               saveareas\n         LR    R13,R1                   Load dynam base\n         USING @Z_Dynam,R13             Assign a base\n         L     R15,@Z_Dynam+4           Get A(HSA)\n         LM    R0,R3,20(R15)            Restore callers registers\n\n         L     R15,4(0,R1)              A(31-bit Stack Pointer)\n         ST    R15,@Z_31Bit_Stack_Ptr_Ptr Save it\n         L     R15,8(0,R1)              A(24-bit Stack Pointer)\n         ST    R15,@Z_24Bit_Stack_Ptr_Ptr Save it\n\n*--------------------------------------------------------------------*\n*   Initialize our standard parmlist                                 *\n*--------------------------------------------------------------------*\n         LA    R15,@_Dynam              A(Dynamic area)\n         ST    R15,@Z_Parms_Std         Save it\n         L     R15,@Z_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)\n         ST    R15,@Z_Parms_Std+4       Save it\n         L     R15,@Z_24Bit_Stack_Ptr_Ptr A(24-bit Stack Pointer)\n         ST    R15,@Z_Parms_Std+8       Save it\n\n*---------------------------------------------------------------------*\n*   Reset our priority, if we changed it                              *\n*---------------------------------------------------------------------*\n         TM    @_CHAP_Done,L'@_CHAP_Done Did we lower our priority?\n         JZ    Z00010I                  No, skip\n         CHAP  1,'S'                    Yes, reset it\n         NI    @_CHAP_Done,X'FF'-L'@_CHAP_Done and reset flag\n\nZ00010I  DS    0H\n*---------------------------------------------------------------------*\n*   Free up the Volume Table, if there is one                         *\n*---------------------------------------------------------------------*\n         ICM   R1,B'1111',@_VolTbl_Ptr A(Info Table)\n         JZ    Z00020                  None, skip\n         L     R0,VolTbl_Hdr_TbLen-VolTbl(R1) Get its length\n         BASR  R2,0\n         USING (*,Z00010_End-1),R2\n         STORAGE RELEASE,               Free the table                 +\n               ADDR=(1),                 starting here                 +\n               LENGTH=(0)                for this long\nZ00010_End DS  0H\n         DROP  R2\n         LA    R15,0                    Clear work register\n         ST    R15,@_VolTbl_Ptr         and clear VolTbl pointer\n\nZ00020   DS    0H\n*---------------------------------------------------------------------*\n*   CLOSE and free any output DCBs                                    *\n*---------------------------------------------------------------------*\n         LA    R15,0                    Clear pointer\n         ST    R15,@Z_Parms_U00010      No DDName\n         ST    R15,@Z_Parms_U00010+4    No data pointer\n         ST    R15,@Z_Parms_U00010+8    No length either\n         ST    R15,@Z_Parms_U00010+12   No ASA CC\n\n         LA    R1,@Z_Parms              A(Parms)\n         BRAS  R14,U00010               Close and free DCBs\n\nZ00030   DS    0H\n*---------------------------------------------------------------------*\n*   Free up the UCB and Volume selection tables                       *\n*---------------------------------------------------------------------*\n         ICM   R1,B'1111',@_UCB_List_Ptr A(List of UCB Masks)\n         JZ    Z00040                   None, skip\n         L     R0,UCB_List_Hdr_Len-UCB_List_Hdr(R1)  Length\n         BASR  R2,0\n         USING (*,Z00030_End-1),R2\n         STORAGE RELEASE,               Free the storage               +\n               ADDR=(1),                 starting here                 +\n               LENGTH=(0)                for this long\nZ00030_End DS  0H\n         DROP  R2\n         XC    @_UCB_List_Ptr,@_UCB_List_Ptr Clear A(UCB List)\n\nZ00040   DS    0H\n         ICM   R1,B'1111',@_XUCB_List_Ptr A(List of XUCB Masks)\n         JZ    Z00050                   None, skip\n         L     R0,UCB_List_Hdr_Len-UCB_List_Hdr(R1)  Length\n         BASR  R2,0\n         USING (*,Z00040_End-1),R2\n         STORAGE RELEASE,               Free the storage               +\n               ADDR=(1),                 starting here                 +\n               LENGTH=(0)                for this long\nZ00040_End DS  0H\n         DROP  R2\n         XC    @_XUCB_List_Ptr,@_XUCB_List_Ptr Clear A(XUCB List)\n\nZ00050   DS    0H\n         ICM   R1,B'1111',@_Vol_List_Ptr A(List of Vol Masks)\n         JZ    Z00060                   None, skip\n         L     R0,Vol_List_Hdr_Len-Vol_List_Hdr(R1)  Length\n         BASR  R2,0\n         USING (*,Z00050_End-1),R2\n         STORAGE RELEASE,               Free the storage               +\n               ADDR=(1),                 starting here                 +\n               LENGTH=(0)                for this long\nZ00050_End DS  0H\n         DROP  R2\n         XC    @_VOL_List_Ptr,@_VOL_List_Ptr Clear A(Vol List)\n\nZ00060   DS    0H\n         ICM   R1,B'1111',@_XVol_List_Ptr A(List of XVol Masks)\n         JZ    Z00070                   None, skip\n         L     R0,Vol_List_Hdr_Len-Vol_List_Hdr(R1)  Length\n         BASR  R2,0\n         USING (*,Z00060_End-1),R2\n         STORAGE RELEASE,               Free the storage               +\n               ADDR=(1),                 starting here                 +\n               LENGTH=(0)                for this long\nZ00060_End DS  0H\n         DROP  R2\n         XC    @_XVOL_List_Ptr,@_XVOL_List_Ptr Clear A(XVol List)\n\nZ00070   DS    0H\n         ICM   R1,B'1111',@_STORGRP_List_Ptr A(List of STORGRP Masks)\n         JZ    Z00070C                  None, skip\n         L     R0,STORGRP_List_Hdr_Len-STORGRP_List_Hdr(R1) Length\n         BASR  R2,0\n         USING (*,Z00070_End-1),R2\n         STORAGE RELEASE,               Free the storage               +\n               ADDR=(1),                 starting here                 +\n               LENGTH=(0)                for this long\nZ00070_End DS  0H\n         DROP  R2\n         XC    @_STORGRP_List_Ptr,@_STORGRP_List_Ptr Clear A(List)\n\nZ00070C  DS    0H\n         TM    @_TSO_Command,L'@_TSO_Command TSO Command?\n         JZ    Z00080                   No, skip\n\n*---------------------------------------------------------------------*\n*       TSO Command Processing                                        *\n*---------------------------------------------------------------------*\n         LA    R15,0                    Clear return code\n         J     Z90010                   and exit\n\nZ00080   DS    0H\n*---------------------------------------------------------------------*\n*       Batch Job Processing                                          *\n*---------------------------------------------------------------------*\n         TM    @_Batch_Environ,L'@_Batch_Environ Is this batch?\n         JZ    Z90010                   No, exit (??)\n\n         LA    R15,0                    Clear return code\n         J     Z90010                   and exit\n\nZ90010   DS    0H\n*-------------------------------------------------------------------*\n*    Free up our local storage ...                                  *\n*-------------------------------------------------------------------*\n         LR    R3,R15                 Save return code\n\n         LA    R1,@Z_Dynam              A(Local storage)\n         L     R2,@Z_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         L     R13,4(0,R13)             Rescue A(HSA)\n\n         SSCSTACK POP,                  Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=(R2)                on this stack\n\n         LR    R15,R3                   Restore return code\n\n*-------------------------------------------------------------------*\n*    ... and return to caller                                       *\n*-------------------------------------------------------------------*\n         L     R14,12(0,R13)            Restore return address\n         LM    R0,R12,20(R13)           Restore other registers\n         BSM   0,R14                    and return\n\n\nZ_Literals DS   0H\n\n         LTORG\n\nZ_Literals_End DS   0H\n\n\n@Z_Dynam                  DSECT       Dynamic area for Z00000\n                          DS    18F    O/S Style save area\n@Z_31Bit_Stack_Ptr_Ptr    DS    AL4    A(31-bit Stack Ptr)\n@Z_24Bit_Stack_Ptr_Ptr    DS    AL4    A(24-bit Stack Ptr)\n\n\n@Z_Parms                  DS    0F    Parms for called rtns\n@Z_Parms_Std              DS    3AL4   Standard 3 parms\n@Z_Parms_Extra            EQU   *      Extra parms\n@Z_Parms_U00010           DS    4AL4      for U00010\n                          ORG   ,\n\n                          DS    0D    Alignment\n@Z_Dynam_Length           EQU   *-@Z_Dynam Length of storage\n\n&PGMNAME CSECT\n\n         DROP  ,\n         POP   USING\n\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SPACE02": {"ttr": 14337, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x19\\x00\\x16\\x01\\x152\\x0f\\x01\\x152\\x0f\\x14\\x05@u@u\\x00\\x00\\xc5\\xc1\\xe5`\\xc6\\xc9\\xe7@@@'", "ispf": {"version": "02.25", "flags": 0, "createdate": "2015-11-16T00:00:00", "modifydate": "2015-11-16T14:05:16", "lines": 16501, "newlines": 16501, "modlines": 0, "user": "EAV-FIX"}, "text": "*PROCESS       XREF(SHORT,UNREFS)\n*PROCESS       NODXREF\n*PROCESS       NORXREF\n*PROCESS       NOALIGN\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*   Assembler Variables                                               *\n*  These variables define various names, processing defaults, etc.,   *\n*  and should be reviewed before assembling.                          *\n*                                                                     *\n*  &PGMNAME                                                           *\n*      Used in the Assembler listing, message IDs, etc                *\n*  &VERSION                                                           *\n*      Used in Title, Statistics line                                 *\n*                                                                     *\n*  &PNLNAME                                                           *\n*      Name of panel used in ISPF display, mode ISPF(S)               *\n*  &SORT_Prompt_Popup_Panel                                           *\n*      Name of the panel used to pronpt, if required, for options for *\n*      the SORT command, under ISPF(S) or ISPF(B)                     *\n*  &OUTPUT_Prompt_Popup_Panel                                         *\n*      Name of the panel used to pronpt, if required, for options for *\n*      the OUTPUT command, under ISPF(S) or ISPF(B)                   *\n*                                                                     *\n*  &ISPF_by_Default                                                   *\n*      Use ISPF for on-line displays                                  *\n*  &ISPF_Default_Type                                                 *\n*      Default type of ISPF display                                   *\n*                                                                     *\n*  &Fore_LSPACE_Wait                                                  *\n*      Maximum seconds to wait for LSPACE to complete when running in *\n*      the foreground (TSO)                                           *\n*  &Back_LSPACE_Wait                                                  *\n*      Maximum seconds to wait for LSPACE to complete when running in *\n*      the background (Batch and STC)                                 *\n*                                                                     *\n*  &Default_SubTask_Count                                             *\n*      Default  number of subtasks to dispatch to issue LSPACEs. If 0,*\n*      defaults to (number of engines * 2) + 1.                       *\n*  &Max_SubTask_Count                                                 *\n*      Maximum  number of subtasks to dispatch to issue LSPACEs. If 0,*\n*      defaults to 16.                                                *\n*                                                                     *\n*---------------------------------------------------------------------*\n         LCLC  &PGMNAME              Program Name\n&PGMNAME SETC  'SPACE'\n         LCLC  &VERSION              Program Version\n&VERSION SETC  'V2.25'\n\n         LCLC  &PNLNAME              Panel Name for ISPF(S)\n&PNLNAME SETC  'SSCSPC02'\n\n         LCLC  &SORT_Prompt_Popup_Panel Name for SORT pop-up prompt\n&SORT_Prompt_Popup_Panel SETC 'SSCSPC03'\n\n         LCLC  &OUTPUT_Prompt_Popup_Panel  Name for OUTPUT pop-up prmt\n&OUTPUT_Prompt_Popup_Panel SETC 'SSCSPC04'\n\n         LCLB  &ISPF_by_Default      Use ISPF if available?\n&ISPF_by_Default SETB 1               Yes, if available\n*&ISPF_by_Default SETB 0               No, TSO line-by-line as default\n\n         LCLC  &ISPF_Default_Type    Default ISPF display type\n&ISPF_Default_Type SETC 'SPACE'       Customized SPACE panel\n*&ISPF_Default_Type SETC 'EDIF'        Edit\n*&ISPF_Default_Type SETC 'BRIF'        Browse\n*&ISPF_Default_Type SETC 'NONE'        None, TSO line-by-line\n\n         LCLA  &Fore_LSPACE_Wait     LSPACE Wait time in foreground\n&Fore_LSPACE_Wait SETA 5              5 seconds\n\n         LCLA  &Back_LSPACE_Wait     LSPACE Wait time in background\n&Back_LSPACE_Wait SETA 0              LSPACE/MIH default\n\n         LCLA  &Default_SubTask_Count Number of Subtasks to dispatch\n&Default_SubTask_Count SETA 0          2 * Nbr engines + 1\n\n         LCLA  &Max_SubTask_Count     Maximum Subtasks to dispatch\n&Max_SubTask_Count     SETA 16         Compatibility with prev versions\n\n\n*---------------------------------------------------------------------*\n*  Do some trivial validation on the Assembly Variables               *\n*---------------------------------------------------------------------*\n         AIF   (&Default_SubTask_Count GE 0).VAL_010\n         MNOTE 4,'Value of &&Default_SubTask_Count negative - using Dyn+\n               amic SubTask count'\n&Default_SubTask_Count SETA 0\n.VAL_010 ANOP\n         AIF   (&Max_SubTask_Count GE 0).VAL_020\n         MNOTE 4,'Value of &&Max_SubTask_Count negative - using default+\n                value of 16'\n&Max_SubTask_Count     SETA 16\n.VAL_020 ANOP\n         AIF   (&Max_SubTask_Count GE &Default_SubTask_Count).VAL_030\n         MNOTE 4,'&&Max_SubTask_Count less than &&Default_SubTask_Count+\n                 - using max of &Default_SubTask_Count'\n&Max_SubTask_Count     SETA &Default_SubTask_Count\n.VAL_030 ANOP\n         AIF   (&Fore_LSPACE_Wait GE 0).VAL_040\n         MNOTE 4,'&&Fore_LSPACE_Wait is negative - setting to 5 sec.'\n&Fore_LSPACE_Wait      SETA 5\n.VAL_040 ANOP\n         AIF   (&Back_LSPACE_Wait GE 0).VAL_050\n         MNOTE 4,'&&Back_LSPACE_Wait is negative - setting to 0'\n&Back_LSPACE_Wait      SETA 0\n.VAL_050 ANOP\n\n\n&PGMNAME TITLE 'Display DASD Free Space'\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Program   : SPACE                                                  *\n*                                                                     *\n*  Abstract  : This program will display the free space on DASD       *\n*              volumes, as selected by the user. This program can     *\n*              run as a batch job or TSO command, using ISPF Dialogue *\n*              Manager facilities, if appropriate.                    *\n*                                                                     *\n*  Inputs    :                                                        *\n*      Parameters :If Batch, N/A                                      *\n*                  If TSO Command, R1 = A(CPPL) (see comments below   *\n*                                                for operands)        *\n*      Files      :If Batch, SYSIN = Control cards                    *\n*      Other      :If TSO Cmd, Command Buffer                         *\n*                                                                     *\n*  Outputs:                                                           *\n*      Returncodes:                                                   *\n*      Messages   :xxxxx                                              *\n*      Files      :If Batch, SYSPRINT = output Messages               *\n*      Other      :None                                               *\n*                                                                     *\n*  Program     Reentrant, problem key and state, standard linkage,    *\n*  Attributes: APF-authorized(maybe), AMODE(31), RMODE(ANY)           *\n*                                                                     *\n*  Implement-:  Unless you have the PTFs for IBM APAR OW48527 APPLYed *\n*  ation        on the system(s) on which this program is running,    *\n*               this program must be be APF Authorized.               *\n*               It is recommended that it also be installed as a TSO  *\n*               command, taking advantage of ISPF Dialog Manager      *\n*               Services, if available. To do this, it must:          *\n*                 - reside in a TSO STEPLIB or LNKLST library         *\n*                 - be named in the AUTHTSF (but *not* the AUTHCMD)   *\n*                   section of SYS1.PARMLIB(IKJTSOxx).                *\n*               Note that all code runs in Problem State and Key; APF *\n*                    authorization is required to issue SYSEVENTs.    *\n*                    See below for further information.               *\n*                                                                     *\n*  Special   :  This program was written to be run either as a program*\n*  Notes       or a TSO command; if as a TSO command, it will use     *\n*              ISPF Dialog Manager services, if available.            *\n*               If this program runs on a system which does *not*     *\n*              have the PTFs for IBM APAR OW48527 installed, it       *\n*              needs to be APF authorized (it uses SYSEVENT DONTSWAP *\n*              and OKSWAP while retrieving DASD info - there is an    *\n*              explanation below, for those of you who have way too   *\n*              much time on your hands). Unfortunately, ISPF DM       *\n*              Services are not available to Authorized TSO Commands. *\n*              The following strategy (?) is used:                    *\n*               - The command is invoked as non-authorized (even      *\n*                 though the load module is LINKed AC(1), because     *\n*                 it is not named in AUTHCMD)                         *\n*               - IKJEFTSR is used to re-invoke itself to perform     *\n*                 the authorized bits (this time it is authorized     *\n*                 because it is named in AUTHTSF)                     *\n*               - The original (unauthorized) command then uses       *\n*                 ISPF DM Services to display the results.            *\n*                                                                     *\n*               When running in Batch, TSO PARSE is used to scan      *\n*              the control cards (from SYSIN), so the syntax of the   *\n*              batch control cards is the same as the TSO Command     *\n*              syntax.                                                *\n*                                                                     *\n*               The following comments apply only when running on     *\n*              systems that do *not* have the PTFs for IBM APAR       *\n*              OW48527 installed:                                     *\n*               This program issues LSPACE macros to retrieve usage   *\n*              data for a volume. If LSPACE is issued against a DASD  *\n*              volume that is RESERVEd on another system, it will     *\n*              hang until the RESERVE is released. This gets          *\n*              particularly annoying when being run from TSO.         *\n*               The program gets hung because:                        *\n*                - LSPACE creates an ESTAE with PURGE=NONE            *\n*                - LSPACE invokes CVAF                                *\n*                - CVAF creates an ESTAE with PURGE=QUIESCE           *\n*                - CVAF tries to touch the device, and hangs because  *\n*                  of a RESERVE                                       *\n*                - A CANCEL is issued for the Address Space           *\n*                - When the 1st ESTAE (CVAFs) gets scheduled, an      *\n*                  attempt is made to QUIESCE the I/O, which never    *\n*                  happens, so we hang.                               *\n*              (Thanks to the IBM ETR folks for their help in figuring*\n*               out what was going on).                               *\n*                                                                     *\n*              To try to circumvent this situation, we issue STIMERMs *\n*              with an exit before issuing LSPACEs. If the exit is    *\n*              invoked, an ESTAE with PURGE=HALT is extablished, and  *\n*              an ABEND U522 issued within the STIMERM exit.          *\n*              The ESTAE from the STIMERM exit is invoked first, so   *\n*              the I/O is PURGEd, and the ESTAE percolates to the     *\n*              CVAF and LSPACE ESTAEs, which can now run because the  *\n*              I/O has been PURGEd.                                   *\n*              So far so good, no APF-authorization required, but ... *\n*              while the LSPACE is trying to get to a RESERVEd device,*\n*              but before the STIMERM pops, SRM/WM may kick in        *\n*              and decide that we should be swapped out. If (s)he     *\n*              does this. the TCBs will be made non-dispatchable,     *\n*              and an attempt will be made to quiesce the I/O.        *\n*              The I/O cannot, in fact, be quiesced, so we end up     *\n*              with a non-dispatchable Address Space waiting for an   *\n*              'unquiescable' I/O to be quiesced. When the STIMERM    *\n*              pops, the exit (which would get us out of this mess)   *\n*              cannot run because we are non-dispatchable.            *\n*              All this is a long way of saying that we have to be    *\n*              APF authorized, so we can issue SYSEVENT DONTSWAP      *\n*              while the LSPACE tasks are running, so that the        *\n*              STIMERM Exit can be dispatched to ESTAE and ABEND.     *\n*                                                                     *\n*              Note that APAR OW48527 addresses this problem by       *\n*              allowing the invoker of LSPACE to specify a time-out,  *\n*              defaulting to 5 seconds. This program determines if    *\n*              the appropriate PTFs have been APPLYed to the active   *\n*              system by checking the LSPACE SVC for literals that    *\n*              are present only when the PTFs have been installed.    *\n*                                                                     *\n*                                                                     *\n*  Coding    : All data areas in Dynamic Storage have names starting  *\n*   Notes       with '@'. One area of Dynamic Storage is acquired     *\n*               during initialization, and is used as a LIFO stack    *\n*               for dynamic storage.                                  *\n*                                                                     *\n*              The names of the Routines follow the pattern:          *\n*                 xnnnnn                                              *\n*               where x    is an alphabetic character, and            *\n*                     n    is a numeric character.                    *\n*                                                                     *\n*              Data in dynamic storage that are globally accessible   *\n*               have names of the form:                               *\n*                @_anyname                                            *\n*              Data associated with a routine typically have names:   *\n*                 x_anyname or @x_anyname                             *\n*               where 'x' is the alphabetic character associated      *\n*                         with the routine                            *\n*              Addressability to globally-accessible dynamic data is  *\n*               via R12; local dynamic data is addressable via R13.   *\n*                                                                     *\n*              Each routine establishes it's own base register,       *\n*               typically R11, for local, read-only variables. Note   *\n*               that there is no base register for the code, except   *\n*               where required  around macros, etc., when R2 is used, *\n*               so be careful if you use R2 for other purposes.       *\n*                                                                     *\n*                                                                     *\n*  Change                                                             *\n*  History   : 1990/06/11 SDDA030 - V1.0                              *\n*                                 - New                               *\n*              1996/03/13 SDDA030 - V1.1                              *\n*                                   Added 4-digit UCB capability      *\n*                                   (D00010)                          *\n*              1997/05/16 SDDA030 - V1.2                              *\n*                                 - Corrected IKJPARS PCL to accept   *\n*                                   4-digit UCBs (C00010)             *\n*                                 - Made Y2K compliant (!)            *\n*                                 - ATTACH subtasks to issue LSPACE   *\n*                                   (D00010, H00010)                  *\n*              1998/09/17 SDDA030 - V2.0                              *\n*                                 - Removed APF checks, and used      *\n*                                   UCBSCAN with DCEAREA operand to   *\n*                                   get DCE info (D00010).            *\n*                                 - Corrected communications between  *\n*                                   mother and daughter TCBs (D07000, *\n*                                   H00010).                          *\n*              1998/09/22 SDDA030 - V2.1                              *\n*                                 - Added Statistics display          *\n*                                 - Runs RMODE(ANY), moving SYSIN and *\n*                                   SYSPRINT I/O routines to 24-bit   *\n*                                   storage. Also move STLINENO       *\n*                                   routine to 24-bit storage.        *\n*              1998/11/13 SDDA030 - V2.2                              *\n*                                 - Used IKJPARS to parse operands in *\n*                                   batch.                            *\n*              1998/11/23 SDDA030 - V2.3                              *\n*                                 - Updated STIMERM exit to POST SPACE*\n*                                   only if subtask is in SVC 78      *\n*                                   (LSPACE).                         *\n*              1999/01/14 SDDA030 - V2.4                              *\n*                                 - Made check for ISPF, TSO command  *\n*                                   or CALL/PGM= checks more consis-  *\n*                                   tent across Batch/TSO environs.   *\n*              1999/03/03 SDDA030 - V2.5                              *\n*                                 - Added version-release variable    *\n*                                   and a new statistics line to      *\n*                                   display it.                       *\n*              1999/05/27 SDDA030 - V2.6                              *\n*                                 - Used LIFO Stack for our dynamic   *\n*                                   areas.                            *\n*                                 - Moved SYSIN and SYSPRINT routines *\n*                                   back into mainline code (rather   *\n*                                   than moving them below-the-line). *\n*              1999/07/30 SDDA030 - V2.7                              *\n*                                 - Added code to cope with SYSIN     *\n*                                   allocated to the terminal (31-bit *\n*                                   SAM is not supported).            *\n*                                 - Added CPU Time to the statistics. *\n*                                 - Added TSO HELP comments.          *\n*              1999/08/20 SDDA030 - V2.8                              *\n*                                 - Fixed up and documented the       *\n*                                   STACK macro.                      *\n*                                 - Added internal stack statistics.  *\n*                                 - Added Wait Time to the statistics.*\n*                                 - Added Routine W00010 to manage    *\n*                                   VolTbl                            *\n*              1999/09/01 SDDA030 - V2.9                              *\n*                                 - Changed method of obtaining totals*\n*                                   to avoid CDS instruction.         *\n*              1999/09/30 SDDA030 - V2.10                             *\n*                                 - Changed default display order to  *\n*                                   ascending order of unit address.  *\n*                                 - Flagged volumes initialized as SMS*\n*                                   (in the VTOC), but not SMS managed*\n*                                   (in the UCB).                     *\n*                                 - Reset Stack statistics for each   *\n*                                   iteration.                        *\n*                                 - Added 'ISPF' keyword to display   *\n*                                   data via ISPF table and panel if  *\n*                                   ISPF services are available.      *\n*                                 - Removed ISPF initialization stuff;*\n*                                   now invoked as a CMD with the     *\n*                                   ISPF keyword.                     *\n*                                 - Moved most of TSO Cmd init. code  *\n*                                   from C00010 to G00010.            *\n*                                 - Honoured NOHEADINGS, NODETAILS and*\n*                                   NOTOTALS when outputting to ISPF. *\n*                                 - Added # vols to Totals line (in   *\n*                                   DevType field).                   *\n*                                 - Made the generation of headings   *\n*                                   more consistent across environ-   *\n*                                   ments.                            *\n*                                 - Added keyword descriptions when   *\n*                                   Parse fails in batch.             *\n*              2000/01/19 SDDA030 - V2.11                             *\n*                                 - Added SORT keywords for all fields*\n*                                 - Added ASCENDING/DESCENDING kwds.  *\n*                                 - Added capability of writing output*\n*                                   to an file:                       *\n*                                    OUTFILE(ddname)                  *\n*                                    OUTDATA(ALL/CB/DISPLAY)          *\n*                                 - Saved control block data in       *\n*                                   the volume table.                 *\n*                                 - Added 24-bit Stack for DCBs,      *\n*                                   STLINENO, etc.                    *\n*                                 - Added &PGMNAME variable, using it *\n*                                   for CSECT name, literals, etc.    *\n*              2000/05/23 SDDA030 - V2.12                             *\n*                                 - Used IOSCDR to test if we can get *\n*                                   out to our DASD before issuing    *\n*                                   LSPACE. Note that this requires   *\n*                                   that we be APF-authorized or have *\n*                                   RACF access to IOSCDR - see       *\n*                                   'Special Notes', above.           *\n*                                 - Added checks to see if we can     *\n*                                   issue IOSCDR.                     *\n*                                 - Removed STIMERM-related stuff,    *\n*                                   since we can't DETACH once LSPACE *\n*                                   has been issued.                  *\n*                                 - Added message if we can't issue   *\n*                                   IOSCDR to check RESERVEs.         *\n*                                 - Added messages when ISPF DM is not*\n*                                   available and the user requested  *\n*                                   ISPF output.                      *\n*                                 - Added msgids to error messages.   *\n*                                 - Added )M info to TSO Help.        *\n*                                 - Removed WTOs from Stack overflows.*\n*                                 - Re-organized internal code:       *\n*                                   - broke out ISPF output handling  *\n*                                   - re-labeled and re-sequenced     *\n*                                     labels.                         *\n*                                 - Left stats line updates as late as*\n*                                   possible (V00010).                *\n*              2001/02/01 SDDA030 - V2.13                             *\n*                                 - Removed IOSCDR stuff added in     *\n*                                   V2.12; instead, ESTAE PURGE=HALT  *\n*                                   and ABEND in the STIMERM exit.    *\n*                                 - Made ourselves non-swappable while*\n*                                   daughter tasks are running.       *\n*                                 - Added IKJEFTSR to re-invoke our-  *\n*                                   selves APFed.                     *\n*                                 - Added message if not APFed.       *\n*                                 - Added IKJEFTSR failure msg.       *\n*                                 - Set RC=4 if no units found.       *\n*                                 - Added MULT to TBADD.              *\n*                                 - Added non-swappable time to stats.*\n*              2001/02/26 SDDA030 - V2.14                             *\n*                                 - Added EDIF/BRIF support.          *\n*                                 - Allowed &PGMNAME as 1st word      *\n*                                   in batch control cards.           *\n*                                 - Populated Stats lines only once.  *\n*                                 - Added &PNLNAME for panel name.    *\n*                                 - Used (GTSIZE-1) as line size for  *\n*                                   TSO line-by-line output.          *\n*                                 - Added VTOCIX, Frag Indx, SMS      *\n*                                   StorGrp and CHPID info.           *\n*                                 - Moved formatting and totalling    *\n*                                   routines back into mainline, to   *\n*                                   reduce non-swap time.             *\n*                                 - Forced ISPF(B) if panel for       *\n*                                   ISPF(S) not available.            *\n*                                 - Added execution environment stats *\n*                                   lines.                            *\n*                                 - Added conditional assembly stuff  *\n*                                   for APAR OW48527.                 *\n*                                 - Used SYS1.NUCLEUS(IECDINIT), CSECT*\n*                                   IECDDEVT to get device type.      *\n*                                 - Added check to ensure IKJEFTSR    *\n*                                   invokes the same code as was orig-*\n*                                   inally invoked.                   *\n*                                 - Added SMS volume status and ass-  *\n*                                   ociated sort field (SMSSTAT).     *\n*                                 - Added 'N/A' in SMS fields for     *\n*                                   non-SMSed volumes (so REXX words  *\n*                                   are consistent).                  *\n*                                 - Added keyword NOLSPACE, for when  *\n*                                   you only need UCBs and Volsers (ie*\n*                                   at IPL to vary devices OFFLINE    *\n*                                   based on volser).                 *\n*              2001/11/12 SDDA030 - V2.15                             *\n*                                 - Added lists of volsers, UCBs in   *\n*                                   selection parms.                  *\n*                                 - Added XVOL, XUCB for excluding    *\n*                                   lists of volsers, units.          *\n*                                 - Corrected STIMERM time bug (micro,*\n*                                   not milli, stupid!)               *\n*                                 - Used the ratio of SubTasks to LPs *\n*                                   as a factor in calculating STIMER *\n*                                   times for LSPACE.                 *\n*                                 - Checked Assembler version when    *\n*                                   generating our assembly time      *\n*                                   stamp.                            *\n*                                 - Retrieved all devices via EDTINFO *\n*                                   when selecting by esoteric.       *\n*              2002/02/12 SDDA030 - V2.16                             *\n*                                 - Used Dynamic displays (rather than*\n*                                   TBDISPL) for ISPF(S)              *\n*                                 - Added LEFT/RIGHT processing for   *\n*                                   ISPF(S)                           *\n*                                 - Removed implicit SORT in ISPF(S); *\n*                                   added SORT cmd to ISPF(S)         *\n*                                 - Added sort prompt pop-up panel in *\n*                                   ISPF(B) and ISPF(S).              *\n*                                 - Added 'Line x of y' in ISPF(S).   *\n*                                 - Added 'Top of Data' and 'Bottom   *\n*                                   of Data' to ISPF(S).              *\n*                                 - Distributed with &ISPF_by_Default *\n*                                   set to 1 (Yes).                   *\n*              2002/03/11 SDDA030 - V2.17                             *\n*                                 - Added STORGRP as a selection      *\n*                                   criterion (as suggested by Ian    *\n*                                   Hobbs).                           *\n*                                 - Added bytes of free space/volume. *\n*                                 - Moved Frag Index, and added check *\n*                                   for max of 999.                   *\n*                                 - Changed RDJFCBs to SWAREQs.       *\n*                                 - Added SSREQ to SMS for volumes in *\n*                                   a STORGRP.                        *\n*                                 - Removed sort-by-column facility,  *\n*                                   and added numeric sort fields, so,*\n*                                   for instance, 1.1G sorts higher   *\n*                                   than 1.1K.                        *\n*                                 - Generated LSPACE error messages   *\n*                                   internally, instead of asking     *\n*                                   LSPACE to do it.                  *\n*                                 - Scaled numbers by 1000 instead of *\n*                                   1024.                             *\n*                                 - BASR to, rather than ATTACH,      *\n*                                   H00010 if we only have 1 subtask. *\n*                                 - Added indicators for CHPIDs not   *\n*                                   phys or log available.            *\n*                                 - Calculated total Free % based on  *\n*                                   bytes rather than tracks          *\n*                                 - Changed internal STACK macro to   *\n*                                   SSCSTACK, so it doesn't conflict  *\n*                                   with IBM's STACK in ATSOMAC.      *\n*              2002/06/11 SDDA030 - V2.18                             *\n*                                 - Moved detail line formatting back *\n*                                   into subtask.                     *\n*                                 - Subtask statistics populated by   *\n*                                   subtask itself.                   *\n*                                 - Total line populated by last      *\n*                                   subtask to end.                   *\n*                                 - Added 'CS collisions' to subtask  *\n*                                   statistics.                       *\n*                                 - If running with OW48527, don't    *\n*                                   WAIT for subtasks to finish; start*\n*                                   outputting lines as soon as       *\n*                                   possible.                         *\n*              2002/08/08 SDDA030 - V2.19                             *\n*                                 - Dynamically determined the status *\n*                                   of APAR OW48527 by checking       *\n*                                   IGC0007H (LSPACE) for the literal *\n*                                   'I/O TIMEOUT'                     *\n*                                 - Removed &OW48527 conditional      *\n*                                   assembly stuff                    *\n*                                 - Converted Branches to Jumps,      *\n*                                   BASRs to BRAS, etc.               *\n*                                 - Removed 'CS collisions' from      *\n*                                   subtask stats, since they always  *\n*                                   seemed to be 0.                   *\n*                                 - Corrected bug when selecting by   *\n*                                   multiple STORGRPs.                *\n*                                 - If we fail APF checks, POST all   *\n*                                   lines in VolTbl as complete.      *\n*                                 - Corrected S0C4 when selecting by  *\n*                                   Unit and no DASD UCBs found (and  *\n*                                   thus no VolTbl created).          *\n*                                 - Corrected bug where the SMS       *\n*                                   Anomaly msg was not being put out *\n*                                   in ISPF modes.                    *\n*                                 - WAITed for up to 2.5 seconds for  *\n*                                   any subtasks to finish before     *\n*                                   terminating.                      *\n*              2003/01/16 SDDA030 - V2.20                             *\n*                                 - Corrected bug in eliminating stats*\n*                                   lines after finding out we aren't *\n*                                   APF'd (E80010).                   *\n*                                 - Corrected bug when finding TIOT   *\n*                                   entry for the OUTFILE DDName.     *\n*                                 - Used consistent registers to      *\n*                                   address VolTbl_Ent throughout.    *\n*              2003/10/07 SDDA030 - V2.21                             *\n*                                 - Fixed S0C4 when adjusting UCB pat-*\n*                                   terns after no UCBs found when    *\n*                                   selecting by UCB.                 *\n*                                 - Added line commands in ISPF(S)    *\n*                                   and ISPF(B) modes:                *\n*                                   . ISPF(x) to switch display modes *\n*                                 - Removed @_No_UCBs_Found flag;     *\n*                                   check nbr vols in table instead.  *\n*                                 - Added Vol Capacity field in the   *\n*                                   display, after VTOC stuff.        *\n*                                 - Allowed system symbols and sub-   *\n*                                   stringing in command line (ran the*\n*                                   command line through ASASYMBM).   *\n*                                 - Returned correct SMS status (ins- *\n*                                   tead of status of 1st vol in      *\n*                                   STORGRP).                         *\n*                                 - Used ATTACHX instead of ATTACH.   *\n*                                 - Added S00010 to WAIT for and      *\n*                                   DETACH subtask TCBs - avoids SA03 *\n*                                   abends.                           *\n*                                 - If we read from SYSIN, send output*\n*                                   to SYSPRINT, even if ISPF is      *\n*                                   available.                        *\n*                                 - Treated SYSPRINT (almost) like    *\n*                                   an OUTFILE - DCB characteristics  *\n*                                   now honoured.                     *\n*              2004/10/15 SDDA030 - V2.22                             *\n*                                 - Fixed bug when returning SMS      *\n*                                   status (Thanks Angel Luis Domin-  *\n*                                   guez).                            *\n*                                 - Added SYSSTATE ARCHLVL=1          *\n*              2005/01/20 SDDA030 - V2.23                             *\n*                                 - Used CSRSI to retrieve info in-   *\n*                                   stead of crawling through control *\n*                                   blocks.                           *\n*              2006/04/21 SDDA030 - V2.24                             *\n*                                 - Added check for z/OS.e in stats.  *\n*                                 - Use TRKCALC to get generally acc- *\n*                                   epted value for Tracksize, instead*\n*                                   of using DS4DEVTK.                *\n*                                 - Rounded displayed values.         *\n*                                 - Display actual value of field in  *\n*                                   SMSG area when in ISPF(S) and the *\n*                                   cursor is on a numeric field and  *\n*                                   ENTER is hit.                     *\n*                                 - IDENTIFY H00010 with a unique name*\n*                                   so we can run multiple copies     *\n*                                   simultaneously.                   *\n*                                 - Added LINESIZE keyword.           *\n*                                 - Standardized internal calling     *\n*                                   sequence so that A(@_Dynam),      *\n*                                   A(31-bit Stack Pointer) and       *\n*                                   A(24-bit Stack Pointer) are always*\n*                                   the 1st 3 parms.                  *\n*                                 - Added name and version to title.  *\n*                                 - Added max LSPACE Wait time        *\n*                                   defaults and MAXLWAIT keyword.    *\n*                                 - Dynamically calculated nbr        *\n*                                   subtasks = 2*engines + 1          *\n*                                 - Added default and max Subtask     *\n*                                   counts Assembly variables - thanks*\n*                                   to MJ Cleary for the suggestion.  *\n*                                 - Added display of installation     *\n*                                   defaults to stats lines.          *\n*                                 - Flagged emulated devices with     *\n*                                   '*E*' following device type.      *\n*                                 - Saved registers on the Linkage    *\n*                                   Stack when we don't know who the  *\n*                                   caller is (and thus the size of   *\n*                                   the save area in R13).            *\n*                                 - Used conditional STORAGE OBTAINs  *\n*                                   when expanding VolTbl.            *\n*                                 - Used separate 24-bit stack for    *\n*                                   OUTFILE stuff (DCBs, etc).        *\n*              2015/11/13 MAHLER  - V2.25                             *\n*                                   Calculation of Volsize corrected  *\n*                                   for EAV.                          *\n*                                                                     *\n*              ____/__/__ _______                                     *\n*                                                                     *\n*                                                                     *\n*  To Do     : Handle CVAF Abends (S18B).                             *\n*                                                                     *\n*---------------------------------------------------------------------*\n         TITLE 'TSO HELP'\n*---------------------------------------------------------------------*\n*                                                                     *\n*)F Function -                                                        *\n*  The SPACE command displays DASD volume usage statistics, based on  *\n*  user-specified characteristics.                                    *\n*                                                                     *\n*)X Syntax -                                                          *\n*         SPACE UNIT/UCB('Unit-mask')                                 *\n*               VOLUME('Volume-mask')                                 *\n*               NAME('Esoteric-name')                                 *\n*               ATTRIBUTE(STORAGE|STG|PRIVATE|PVT|PUBLIC|SMS)         *\n*               STORGRP('SMS-Storage-Group-Name')                     *\n*               XUNIT/XUCB('Unit-mask')                               *\n*               XVOLUME('Volume-mask')                                *\n*               SORT(id)                                              *\n*               ASCENDING/DESCENDING                                  *\n*               MAXTASKS('#Subtasks')                                 *\n*               OUTFILE(ddname)                                       *\n*               OUTDATA(Display|CB|All)                               *\n*               NOHEADINGS/NOHDG                                      *\n*               NODETAILS                                             *\n*               NOTOTALS                                              *\n*               NOECHO                                                *\n*               STATISTICS|STATS                                      *\n*               ISPF(Space|Edif|Brif|None)                            *\n*               NOLSPACE                                              *\n*               LINESIZE                                              *\n*               MAXLWAIT(secs)                                        *\n*                                                                     *\n*  Required - None                                                    *\n*  Default  - UNIT(*) VOLUME(*)                                       *\n*  Alias    - None                                                    *\n*  Notes    -                                                         *\n*                                                                     *\n*)M Messages -                                                        *\n*                                                                     *\n*))SPACE01I No Devices/Volumes match selection criteria               *\n*           This message is issued when no online DASD devices were   *\n*           found that satisfied the selection criteria defined.      *\n*                                                                     *\n*))SPACE02I Insufficient APF authorization                            *\n*           The SPACE command requires APF authorization, but is cur- *\n*           rently not authorized.                                    *\n*                                                                     *\n*))SPACE03I ISPF DM Services unavailable xx-yy                        *\n*           This message is issued when the SPACE command could not   *\n*           use ISPF Dialogue Management Services to display the      *\n*           results of the command in ISPF format. Either the required*\n*           ISPF modules were unavailable, or the environment is such *\n*           that ISPF Dialogue Management Services are not functional.*\n*           In the message, xx indicates which ISPF service is        *\n*           unavailable, and yy is the return code from that service. *\n*                                                                     *\n*))SPACE04I Forcing non-ISPF output                                   *\n*           This message is issued when the user has requested that   *\n*           the command output be displayed using ISPF Dialogue       *\n*           Management Services, but these services are unavailable.  *\n*           The command output is displayed using TSO line-by-line    *\n*           facilities (PUTLINE).                                     *\n*                                                                     *\n*))SPACE05I CSVQUERY unavailable on this system xxxxx                 *\n*           The CSVQUERY function was attempted to verify that APAR   *\n*           OW48527 had been APPLYed to this system, but CSVQUERY is  *\n*           not available. 'xxxxx' is the Operating System level on   *\n*           which this program is executing.                          *\n*                                                                     *\n*))SPACE06I Program not found in STEPLIB/LNKLST                       *\n*           This command requires that the processing program reside  *\n*           in the current STEPLIB or system LNKLST concatenation,    *\n*           but the program cannot be located.                        *\n*                                                                     *\n*))SPACE07I IKJEFTSR error xx-yy                                      *\n*           The TSO/E Service Routine IKJEFTSR could not complete     *\n*           successfully. xx is the Return Code, and yy the reason    *\n*           code.                                                     *\n*                                                                     *\n*))SPACE08I LSPACE failed for at least 1 volume                       *\n*           The data presented in the table is incomplete because     *\n*           information for at least 1 DASD volume was unavailable.   *\n*                                                                     *\n*))SPACE09I Incompatible versions of SPACE found                      *\n*           The TSO/E Service Routine IKJEFTSR invoked a different    *\n*           version of SPACE (from LNKLST/STEPLIB) than was           *\n*           originally invoked (from ISPLLIB?).                       *\n*                                                                     *\n*))SPACE10I Insufficient storage: nnn volumes omitted                 *\n*           Not enough (above-the-line) storage was available to      *\n*           save the information for all selected DASD volumes. nnn   *\n*           indicates how many volumes were not processed.            *\n*                                                                     *\n*))SPACE11I Internal error - unknown invocation type                  *\n*           The program could not determine how it was invoked. This  *\n*           is most likely to occur when it is being reinvoked via    *\n*           IKJEFTSR, but the parameters passed are unrecognized.     *\n*                                                                     *\n*))SPACE12I OUTFILE DDname xxxxxxxx not useable - ignored.            *\n*           This message is issued when the user has requested that   *\n*           the volume usage data be written to a file, by specifying *\n*           OUTFILE(xxxxxxxx) on the command line. DDName xxxxxxxx    *\n*           could not be OPENed for output.                           *\n*                                                                     *\n*)O Operands -                                                        *\n*))UNIT('Unit-mask') or                                               *\n*   UCB('Unit-mask')    specifies the selection criterion based on    *\n*                       UCB address. Wildcard characters can be used: *\n*                        '*' - all remaining characters               *\n*                        '?' - any single character                   *\n*                        '%' - any single character                   *\n*                       Default is '*'.                               *\n*                       If 'Unit-mask' is less than 4 characters, it  *\n*                       is right-filled with asterisks.               *\n*                       If no UCBs match the 'Unit-mask', and an ast- *\n*                       erisk is the last character in 'Unit-mask',   *\n*                       the trailing asterisk is dropped, a '0'       *\n*                       inserted in the 1st position of 'Unit-mask',  *\n*                       and the UCB scan repeated. This process is    *\n*                       repeated until UCBs are found, or there are no*\n*                       more trailing asterisks in 'Unit-mask'.       *\n*                       Note that a DASD volume must satisfy *all*    *\n*                       criteria specified (UNIT, XUNIT, VOL, XVOL,   *\n*                       NAME, ATTRIBUTE, and/or STORGRP) to be sel-   *\n*                       ected.                                        *\n*                                                                     *\n*))XUNIT('Unit-mask') or                                              *\n*   XUCB('Unit-mask')   specifies the exclusion criterion based on    *\n*                       UCB address.                                  *\n*                                                                     *\n*))VOLUME('Volume-mask')                                              *\n*                       specifies the selection criterion based on    *\n*                       volume serial number. Wildcard characters can *\n*                       be used:                                      *\n*                        '*' - all remaining characters               *\n*                        '?' - any single character                   *\n*                        '%' - any single character                   *\n*                       Default is '*'.                               *\n*                       If 'Volume-mask' is less than 6 characters,   *\n*                       it is right-filled with asterisks             *\n*                       Note that a DASD volume must satisfy *all*    *\n*                       criteria specified (UNIT, XUNIT, VOL, XVOL,   *\n*                       NAME, ATTRIBUTE, and/or STORGRP) to be sel-   *\n*                       ected.                                        *\n*                                                                     *\n*))XVOLUME('Volume-mask')                                             *\n*                       specifies the exclusion criterion based on    *\n*                       volume serial number.                         *\n*                                                                     *\n*))NAME('Esoteric-Name')                                              *\n*                       specifies the selection criterion based on    *\n*                       generic or esoteric name.                     *\n*                       Default is that selection is not based on     *\n*                       generic/esoteric name.                        *\n*                       Note that a DASD volume must satisfy *all*    *\n*                       criteria specified (UNIT, XUNIT, VOL, XVOL,   *\n*                       NAME, ATTRIBUTE, and/or STORGRP) to be sel-   *\n*                       ected.                                        *\n*                                                                     *\n*))ATTRIBUTE(STORAGE|STG|PRIVATE|PVT|PUBLIC|SMS)                      *\n*                       specifies the selection criterion based on    *\n*                       mount attribute. Only one of the options      *\n*                       above can be specified.                       *\n*                       Default is that selection is not based on     *\n*                       mount attribute.                              *\n*                       Note that a DASD volume must satisfy *all*    *\n*                       criteria specified (UNIT, XUNIT, VOL, XVOL,   *\n*                       NAME, ATTRIBUTE, and/or STORGRP) to be sel-   *\n*                       ected.                                        *\n*                                                                     *\n*))STORGRP('SMS-Storage_Group_Name') or                               *\n*       SG('SMS-Storage_Group_Name')                                  *\n*                       specifies the selection criterion based on    *\n*                       SMS Storage Group. Wildcard characters can be *\n*                       used:                                         *\n*                        '*' - all remaining characters               *\n*                        '?' - any single character                   *\n*                        '%' - any single character                   *\n*                       Default is that selection is not based on     *\n*                       SMS Storage Group Names.                      *\n*                       Note that a DASD volume must satisfy *all*    *\n*                       criteria specified (UNIT, XUNIT, VOL, XVOL,   *\n*                       NAME, ATTRIBUTE, and/or STORGRP) to be sel-   *\n*                       ected.                                        *\n*                                                                     *\n*))SORT(id)             specifies the order in which the selected     *\n*                       DASD volumes are displayed:                   *\n*                        id: VOL     - Volser                         *\n*                            UCB     - UCB Name (Device Address)      *\n*                            DEVT    - Device Type                    *\n*                            ATTR    - Mount Attribute                *\n*                            FREET   - Free Tracks on Volume          *\n*                            FREEC   - Free Cylinders on volume       *\n*                            FREEP   - % Volume free                  *\n*                            FREEB   - # Bytes on Volume free         *\n*                            FREEE   - # Free Extents on volume       *\n*                            LARGET  - Largest Free Tracks            *\n*                            LARGEC  - Largest Free Cylinders         *\n*                            VFREED  - VTOC Free DSCBs                *\n*                            VFREEP  - % VTOC Free                    *\n*                            VTRK    - Tracks allocated to VTOC       *\n*                            VIX     - VTOC Index Status              *\n*                            VOLSIZE - Volume Capacity (Bytes)        *\n*                            FRAG    - Fragmentation Index            *\n*                            STORGRP - SMS Storage Group              *\n*                            SMSSTAT - SMS Volume Status              *\n*                            CHPIDS  - CHPIDs                         *\n*                       By default, the display is unsorted, and will *\n*                       normally appear in ascending order of UCB.    *\n*                                                                     *\n*))ASCENDING|DESCENDING specifies the sort order. Significant only    *\n*                       when a SORT id is specified.                  *\n*                       Default is ASCENDING.                         *\n*                                                                     *\n*))MAXTASKS('#Subtasks') specifies the maximum number of sub-tasks to *\n*                       be ATTACHed to retrieve volume information.   *\n*                       If specified, '#Subtasks' must be numeric.    *\n*                       A maximum of 16 subtasks can be ATTACHed.     *\n*                       Default is (number-of-active-CPUs + 1).       *\n*                                                                     *\n*))OUTFILE('ddname')    specifies that the output is to be written to *\n*                       the dataset allocated to 'ddname'. This output*\n*                       is generated in addition to the normal output.*\n*                       Default is no additional output is generated. *\n*                                                                     *\n*))OUTDATA(Display|CB|All) specifies the content of the data written  *\n*                       to the 'ddname' specified in OUTFILE, above.  *\n*                        DISPLAY writes an image of the max display   *\n*                                output (235 bytes)                   *\n*                        CB      writes machine-readable copies of the*\n*                                following control blocks, as returned*\n*                                by the appropriate MVS services:     *\n*                                  UCB Copy        (48 bytes)         *\n*                                  DCE Copy        (48 bytes)         *\n*                                  LSPACE Data     (36 bytes)         *\n*                                  F4 DSCB         (96 bytes)         *\n*                        ALL     writes both CB and DISPLAY, in that  *\n*                                order (228 bytes of CB and 235 bytes *\n*                                of DISPLAY)                          *\n*                       Default is ALL.                               *\n*                                                                     *\n*))NOHEADINGS|NOHDG     specifies that headings (and page breaks) are *\n*                       to be suppressed.                             *\n*                                                                     *\n*))NODETAILS            specifies that detail lines (one per selected *\n*                       DASD volume) are to be suppressed.            *\n*                                                                     *\n*))NOTOTALS             specifies that total lines are to be          *\n*                       suppressed.                                   *\n*                                                                     *\n*))NOECHO               specifies that the command line is not to be  *\n*                       listed in Batch.                              *\n*                                                                     *\n*))STATISTICS|STATS     specifies that internal version and exec-     *\n*                       ution statistics are to be produced.          *\n*                                                                     *\n*))ISPF(Space|Edif|Brif|None)                                         *\n*                       specifies the ISPF services to be used to     *\n*                       present output:                               *\n*                       Space causes the output to be displayed using *\n*                             a customized panel. This is the default *\n*                             if ISPF is specified.                   *\n*                       Edif  invokes ISPF Edit to present the        *\n*                             output                                  *\n*                       Brif  invokes ISPF Browse to present the      *\n*                             output                                  *\n*                       None  uses TSO line-by-line output (PUTLINE)  *\n*                             to present the output.                  *\n*))NOLSPACE             specifies that no VTOC information is to be   *\n*                       gathered - displays only UCB, Volser, DevType,*\n*                       Attr, SMS Info, CHPIDs, Remote Copy Data.     *\n*))LINESIZE(nnn)        specifies the maximum length of the line to be*\n*                       displayed (in TSO line-by-line). Default is   *\n*                       the value returned by the GTSIZE service minus*\n*                       1. As well as a number, the literal 'MAX' can *\n*                       be specified, indicating that all available   *\n*                       data will be displayed.                       *\n*))MAXLWAIT(nnn)        specifies the maximum number of seconds that  *\n*                       each LSPACE will be allowed to complete; after*\n*                       this number of seconds, the LSPACE will be    *\n*                       terminated with an I/O TIMEOUT message. 0     *\n*                       signifies no maximum.                         *\n*                                                                     *\n*---------------------------------------------------------------------*\n         TITLE 'Assembly Variables'\n         LCLC  &ASMDT,&ASMTM         Assembly Date/Time\n&ASMDT   SETC  '&SYSDATC'(1,4).'-'.'&SYSDATC'(5,2).'-'.'&SYSDATC'(7,2)\n&ASMTM   SETC  '&SYSTIME'\n\n         TITLE 'Register Equates'\n         YREGS\n         TITLE '''IEABRC'''\n         COPY  IEABRC\n         TITLE '''SSCSTACK'' Macro'\n         MACRO\n&NAME    SSCSTACK &TYPE,              INIT, PUSH, POP, or TERM         +\n               &LOC=,                 ABOVE/BELOW (TYPE=INIT)          +\n               &LEN=,                 Length required (TYPE=INIT/PUSH) +\n               &STACK=,               Stack origin                     +\n               &ADDR=,                Storage address                  +\n               &OVERFLOW=,            Overflow action (TYPE=PUSH)      +\n               &WTOMSG=               Overflow WTO (If OVERFLOW=WTO)\n         PUSH  PRINT\n         PRINT NOGEN\n.*\n.*-------------------------------------------------------------------*.\n.*                                                                   *.\n.*           S S C S T A C K   M a c r o                             *.\n.*                                                                   *.\n.*  Function: The SSCSTACK macro manages a LIFO stack that can be    *.\n.*            used to relieve the overhead of GETMAIN/FREEMAIN where *.\n.*            appropriate.                                           *.\n.*                                                                   *.\n.*            There are 4 flavours of the SSCSTACK invocation:       *.\n.*              SSCSTACK INIT,...     GETMAIN Stack storage          *.\n.*              SSCSTACK PUSH,...     Reserve storage on the Stack   *.\n.*              SSCSTACK POP,...      Release storage on the Stack   *.\n.*              SSCSTACK TERM,...     FREEMAIN Stack storage         *.\n.*                                                                   *.\n.*            Stack storage *must* be PUSHed and POPped in LIFO      *.\n.*            sequence - no checking is done within the macro to     *.\n.*            ensure this is the case.                               *.\n.*                                                                   *.\n.*  Operation: The usage of the SSCSTACK macro is typically:         *.\n.*              SSCSTACK INIT,...                                    *.\n.*                                                                   *.\n.*              SSCSTACK PUSH,...                                    *.\n.*              SSCSTACK POP,...                                     *.\n.*              SSCSTACK PUSH,...                                    *.\n.*              SSCSTACK POP,...                                     *.\n.*                .    .                                             *.\n.*                .    .                                             *.\n.*                                                                   *.\n.*              SSCSTACK TERM,...                                    *.\n.*                                                                   *.\n.*             When the Stack is initially GETMAINed (SSCSTACK INIT),*.\n.*             the length and Next Available Byte (NAB) are init-    *.\n.*             ialized in the Stack Header. On subsequent SSCSTACK   *.\n.*             PUSH requests, the NAB is incremented by the length   *.\n.*             requested. SSCSTACK POP requests merely update the NAB*.\n.*             with the address passed. SSCSTACK TERM FREEMAINs the  *.\n.*             Stack.                                                *.\n.*             If a SSCSTACK PUSH request would cause a stack over-  *.\n.*             flow, the default processing GETMAINs an area and     *.\n.*             returns the address of this area. The SSCSTACK POP    *.\n.*             request for this area FREEMAINs the storage.          *.\n.*             Default overflow processing can be overridden or      *.\n.*             supplemented on the SSCSTACK PUSH: instead of GETMAIN-*.\n.*             ing additional storage, the SSCSTACK PUSH request can *.\n.*             return a return code, or Abend. Additionally, a WTO   *.\n.*             can be issued with any of the overflow options.       *.\n.*                                                                   *.\n.*             SSCSTACK INIT,                                        *.\n.*                   LEN=Length                                      *.\n.*                   <,LOC=ANY|BELOW>                                *.\n.*                   <,STACK=Stack-pointer>                          *.\n.*                                                                   *.\n.*             SSCSTACK PUSH,                                        *.\n.*                   LEN=Length,                                     *.\n.*                   STACK=Stack-pointer                             *.\n.*                   <,ADDR=Address-pointer>                         *.\n.*                   <,OVERFLOW=Action|WTO|(Action,WTO)>             *.\n.*                   <,WTOMSG=WTO-message>                           *.\n.*                                                                   *.\n.*             SSCSTACK POP,                                         *.\n.*                   ADDR=Address=pointer,                           *.\n.*                   STACK=Stack-pointer                             *.\n.*                                                                   *.\n.*             SSCSTACK TERM,                                        *.\n.*                   STACK=Stack-pointer                             *.\n.*                                                                   *.\n.*-------------------------------------------------------------------*.\n.*\n         LCLC  &LENREG,&STKREG,&ADDREG,&LOCTN\n         AIF   ('&TYPE(1)' EQ 'PUSH').PUSH010\n         AIF   ('&TYPE(1)' EQ 'POP').POP010\n         AIF   ('&TYPE(1)' EQ 'INIT').INIT010\n         AIF   ('&TYPE(1)' EQ 'TERM').TERM010\n         MNOTE 8,'TYPE must be INIT, PUSH, POP, or TERM'\n         AGO   .MEND\n.*\n.INIT010 ANOP\n         AIF   ('&LEN' EQ '').INITE01\n         AIF   ('&LEN'(1,1) NE '(').INIT020\n&LENREG  SETC  '&LEN(1)'\n         AIF   ('&LENREG' NE  '1').INIT030\n         MNOTE 8,'LEN= register must be 0 or 2-15'\n         AGO   .MEND\n         AGO   .INIT030\n.INIT020 ANOP\n&LENREG  SETC  'R0'\n         LHI   &LENREG,&LEN Length of Stack\n.INIT030 ANOP\n&LOCTN   SETC  '&LOC'\n         AIF   ('&LOC' NE '').INIT040\n&LOCTN   SETC  '31'\n.INIT040 ANOP\n         LHI   R1,StackHdr_Length       Length of header\n         AR    &LENREG,R1               Bump length\n         BASR  R2,0\n         USING (*,INI&SYSNDX.A-1),R2\n         STORAGE OBTAIN,                Go get our storage             +\n               LENGTH=(&LENREG),         this long                     +\n               LOC=&LOCTN                wherever we were told\nINI&SYSNDX.A DS 0H\n         DROP  R2\n         XC    0(StackHdr_Length,R1),0(R1)  Clear header\n         ST    R0,StackHdr_StackLen-StackHdr(0,R1) Save length\n         LA    R0,StackHdr_Length(0,R1) A(Current top of stack)\n         ST    R0,StackHdr_NAB-StackHdr(0,R1) Save A(Next Avail Byte)\n         ST    R0,StackHdr_HWM-StackHdr(0,R1) Save High-Water Mark\n         AIF   ('&STACK' EQ '').INIT060\n         AIF   ('&STACK'(1,1) EQ '(').INIT050\n         ST    R1,&STACK                Save Stack origin\n         AGO   .INIT060\n.INIT050 ANOP\n         LR    &STACK(1),R1             Load return register\n         AGO   .INIT060\n.INIT060 ANOP\n         AIF   (D'Stack).MEND\nStack               DSECT\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*   This is a LIFO stack that can be used (where appropriate) to    *\n*  avoid the overhead of repeated GETMAINs/FREEMAINs. Storage       *\n*  within the Stack *must* be used in LIFO sequence.                *\n*                                                                   *\n*-------------------------------------------------------------------*\n\nStackHdr            EQU   *           Start of Header\nStackHdr_StackLen   DS    FL4          Length of Stack\nStackHdr_NAB        DS    AL4          A(Next Available Byte in Stack)\nStackHdr_Reg_Save   DS    4FL4         Register save area\nStackHdr_HWM        DS    AL4          Max NAB value (High-water mark)\nStackHdr_Overflows  DS    FL4          Nbr SSCSTACK PUSH overflows\nStackHdr_Overflow_HWM DS  FL4          Max Overflow amount\nStackHdr_GETMAIN    DS    FL4          Nbr SSCSTACK PUSH ---> GETMAIN\n                    DS    0D           Dblwd alignment\nStackHdr_Length     EQU   *-StackHdr  Length of Header\n\n&SYSECT  &SYSSTYP\n         AGO   .MEND\n.INITE01 ANOP\n         MNOTE 8,'LEN must be specified for SSCSTACK INIT'\n         AGO   .MEND\n.*\n.PUSH010 ANOP\n         LCLA  &INDEX,&COUNT\n         LCLB  &GETMAIN,&WTO,&ABEND,&RC\n         LCLB  &EXCLOP\n         LCLC  &TESTOVFL\n         AIF   ('&OVERFLOW' EQ '').PUSH090\n&INDEX   SETA  0\n&COUNT   SETA  N'&OVERFLOW\n         AIF   (&COUNT GT 0).PUSH020\n&TESTOVFL SETC '&OVERFLOW'\n         AGO   .PUSH030\n.PUSH020 ANOP\n&INDEX   SETA  &INDEX+1\n         AIF   (&INDEX GT &COUNT).PUSH080\n&TESTOVFL SETC '&OVERFLOW(&INDEX)'\n.PUSH030 ANOP\n         AIF   ('&TESTOVFL' NE 'GETMAIN').PUSH040\n         AIF   (&EXCLOP).PUSHE03\n&GETMAIN SETB  1\n&EXCLOP  SETB  1\n         AGO   .PUSH020\n.PUSH040 ANOP\n         AIF   ('&TESTOVFL' NE 'ABEND').PUSH050\n         AIF   (&EXCLOP).PUSHE03\n&ABEND   SETB  1\n&EXCLOP  SETB  1\n         AGO   .PUSH020\n.PUSH050 ANOP\n         AIF   ('&TESTOVFL' NE 'RC').PUSH060\n         AIF   (&EXCLOP).PUSHE03\n&RC      SETB  1\n&EXCLOP  SETB  1\n         AGO   .PUSH020\n.PUSH060 ANOP\n         AIF   ('&TESTOVFL' NE 'WTO').PUSH070\n&WTO     SETB  1\n         AGO   .PUSH020\n.PUSH070 ANOP\n         MNOTE 4,'Unrecognized OVERFLOW operand - &TESTOVFL - GETMAIN s+\n               bstituted.'\n&GETMAIN SETB  1\n         AGO   .PUSH020\n.PUSH080 ANOP\n         AIF   (&EXCLOP).PUSH100\n.PUSH090 ANOP\n&GETMAIN SETB  1\n         AGO   .PUSH100\n.PUSH100 ANOP\n         AIF   ('&STACK' EQ '').PUSHE02\n         AIF   ('&STACK'(1,1) NE '(').PUSH110\n&STKREG  SETC  '&STACK(1)'\n         AGO   .PUSH120\n.PUSH110 ANOP\n&STKREG  SETC  'R15'\n         L     &STKREG,&STACK           A(Stack Origin)\n.PUSH120 ANOP\n         AIF   ('&LEN' EQ '').PUSHE01\n         AIF   ('&LEN'(1,1) NE '(').PUSH130\n&LENREG  SETC  '&LEN(1)'\n         AIF   ('&LENREG' EQ '0').PUSH150\n         AIF   ('&LENREG' EQ 'R0').PUSH150\n         AGO   .PUSH140\n.PUSH130 ANOP\n&LENREG  SETC  'R0'\n.PUSH140 ANOP\n         LHI   &LENREG,&LEN\n.PUSH150 ANOP\n         AHI   &LENREG,7                Ensure a\n         SRL   &LENREG,3                 doubleword\n         SLL   &LENREG,3                 multiple\n         L     R1,StackHdr_NAB-StackHdr(0,&STKREG) A(Next Avail Byte)\n         AR    R1,&LENREG               Bump by length requested\n         SLR   R1,&STKREG               Get Stack used\n         C     R1,StackHdr_StackLen-StacKHdr(0,&STKREG) Too much?\n         JNL   PSH&SYSNDX.E             Yes, Overflow\n         ALR   R1,&STKREG               No, offset to address\n         ST    R1,StackHdr_NAB-StackHdr(0,&STKREG) A(Next Avail Byte)\n         C     R1,StackHdr_HWM-StackHdr(0,&STKREG) Highest?\n         JNH   PSH&SYSNDX.C             No, skip\n         ST    R1,StackHdr_HWM-StackHdr(0,&STKREG) Yes, update HWM\nPSH&SYSNDX.C DS 0H\n         SLR   R1,&LENREG               A(Start of storage area)\n         AIF   ('&LENREG' EQ '0').PUSH155\n         AIF   ('&LENREG' EQ 'R0').PUSH155\n         LR    R0,&LENREG               Length of storage\n.PUSH155 ANOP\n         J     PSH&SYSNDX.M             and skip\nPSH&SYSNDX.E DS 0H\n         ST    R0,StackHdr_Reg_Save-StackHdr(&STKREG)\n         L     R0,StackHdr_Overflows-StackHdr(0,&STKREG) Get count\n         AHI   R0,1                       Bump it\n         ST    R0,StackHdr_Overflows-StackHdr(0,&STKREG) Save it\n         L     R0,StackHdr_Reg_Save-StackHdr(&STKREG)\n         AIF   (NOT &WTO).PUSH220\n         LCLC  &WTOLIT\n         AIF   (K'&WTOMSG LT 3).PUSH160\n&WTOLIT  SETC  '&WTOMSG'(2,K'&WTOMSG-2)\n         AGO   .PUSH170\n.PUSH160 ANOP\n&WTOLIT  SETC  'Stack001 - Stack Overflow'\n.PUSH170 ANOP\n         ST    R1,StackHdr_Reg_Save-StackHdr(&STKREG)  Save R1\n         ST    &LENREG,StackHdr_Reg_Save+4-StackHdr(&STKREG)  Save Len\n         AIF   ('&STKREG' EQ '1').PUSH180,                             +\n               ('&STKREG' EQ 'R1').PUSH180,                            +\n               ('&STKREG' EQ '14').PUSH180,                            +\n               ('&STKREG' EQ 'R14').PUSH180,                           +\n               ('&STKREG' EQ '15').PUSH180,                            +\n               ('&STKREG' EQ 'R15').PUSH180\n         AGO   .PUSH190\n.PUSH180 ANOP\n         ST    R2,StackHdr_Reg_Save+8-StackHdr(&STKREG)  Save R2\n         LR    R2,&STKREG                 Save A(Stack)\n.PUSH190 ANOP\n         WTO   '&WTOLIT',ROUTCDE=11\n         AIF   ('&STKREG' EQ '1').PUSH200,                             +\n               ('&STKREG' EQ 'R1').PUSH200,                            +\n               ('&STKREG' EQ '14').PUSH200,                            +\n               ('&STKREG' EQ 'R14').PUSH200,                           +\n               ('&STKREG' EQ '15').PUSH200,                            +\n               ('&STKREG' EQ 'R15').PUSH200\n         AGO   .PUSH210\n.PUSH200 ANOP\n         LR    &STKREG,R2                 Restore A(Stack)\n         L     R2,StackHdr_Reg_Save+8-StackHdr(&STKREG)  Restore R2\n.PUSH210 ANOP\n         L     R1,StackHdr_Reg_Save-StackHdr(&STKREG)  Restore\n         L     &LENREG,StackHdr_Reg_Save+4-StackHdr(&STKREG)  Rest Len\n.PUSH220 ANOP\n         AIF   (NOT &RC).PUSH230\n         LA    R0,0                     Clear Length register\n         LA    R1,0                     Clear pointer\n         LA    R15,8                    Set return code\n         J     PSH&SYSNDX.O             and skip\n         AGO   .PUSH250\n.PUSH230 ANOP\n         AIF   (NOT &ABEND).PUSH240\n         DC    H'0'                     ABEND\n         AGO   .PUSH250\n.PUSH240 ANOP\n         C     R1,StackHdr_Overflow_HWM-StackHdr(0,&STKREG) Highest?\n         JNH   PSH&SYSNDX.G             No, skip\n         ST    R1,StackHdr_Overflow_HWM-StackHdr(0,&STKREG) Yes, update\nPSH&SYSNDX.G DS 0H\n         L     R1,StackHdr_GETMAIN-StackHdr(0,&STKREG) Get count\n         AHI   R1,1                     Bump it\n         ST    R1,StackHdr_GETMAIN-StackHdr(0,&STKREG) Save it\n         AHI   &LENREG,8                Bump length by 8\n         LR    R15,&STKREG              Get stack address\n         SLL   R15,1                    Clear high-order bit\n         SRL   R15,25                   Clear 24-bit address\n         LTR   R15,R15                  Above-the-line?\n         JZ    PSH&SYSNDX.I             No, skip\n         BASR  R2,0\n         USING (*,PSH&SYSNDX.H-1),R2\n         STORAGE OBTAIN,                Go get our storage             +\n               LENGTH=(&LENREG),         this long                     +\n               LOC=31                    above-the-line\nPSH&SYSNDX.H DS 0H\n         DROP  R2\n         J     PSH&SYSNDX.K             and skip\nPSH&SYSNDX.I DS 0H\n         BASR  R2,0\n         USING (*,PSH&SYSNDX.J-1),R2\n         STORAGE OBTAIN,                Go get our storage             +\n               LENGTH=(&LENREG),         this long                     +\n               LOC=24                    below-the-line\nPSH&SYSNDX.J DS 0H\n         DROP  R2\nPSH&SYSNDX.K DS 0H\n         ST    R0,0(0,R1)               Save length\n         AHI   R1,8                     Bump over our header\n         AHI   R0,-8                    Adjust length\n.PUSH250 ANOP\nPSH&SYSNDX.M DS 0H\n         LA    R15,0                    Clear return register\n         AIF   (NOT &RC).PUSH260\nPSH&SYSNDX.O DS 0H\n.PUSH260  ANOP\n         AIF   ('&ADDR' EQ '').MEND\n         AIF   ('&ADDR'(1,1) NE '(').PUSH270\n         LR    &ADDR(1),R1             Load return register\n         AGO   .MEND\n.PUSH270 ANOP\n         ST    R1,&ADDR                 Save Storage pointer\n         AGO   .MEND\n.PUSHE01 ANOP\n         MNOTE 8,'LEN must be specified for SSCSTACK PUSH'\n         AGO   .MEND\n.PUSHE02 ANOP\n         MNOTE 8,'STACK must be specified for SSCSTACK PUSH'\n         AGO   .MEND\n.PUSHE03 ANOP\n         MNOTE 8,'Mutually exclusive OVERFLOW= operands.'\n         AGO   .MEND\n.*\n.POP010  ANOP\n         AIF   ('&ADDR' EQ '').POPE01\n         AIF   ('&ADDR'(1,1) NE '(').POP020\n&ADDREG  SETC  '&ADDR(1)'\n         AGO   .POP030\n.POP020  ANOP\n&ADDREG  SETC  'R0'\n         L     &ADDREG,&ADDR\n.POP030  ANOP\n         AIF   ('&STACK' EQ '').POPE02\n         AIF   ('&STACK'(1,1) NE '(').POP040\n&STKREG  SETC  '&STACK(1)'\n         AGO   .POP050\n.POP040  ANOP\n&STKREG  SETC  'R15'\n         L     &STKREG,&STACK           A(Stack Origin)\n.POP050  ANOP\n         CR    &ADDREG,&STKREG          Part of our stack?\n         JL    POP&SYSNDX.C             No, skip\n         C     &ADDREG,StackHdr_NAB-StackHdr(0,&STKREG)  Really?\n         JNL   POP&SYSNDX.C             No, skip\n         ST    &ADDREG,StackHdr_NAB-StackHdr(0,&STKREG)\n         J     POP&SYSNDX.E             and exit\nPOP&SYSNDX.C DS 0H\n         AHI   &ADDREG,-8               Back up to our header\n         L     R0,0(0,&ADDREG)          Get length of GETMAINed stg\n         BASR  R2,0\n         USING (*,POP&SYSNDX.D-1),R2\n         STORAGE RELEASE,               Free our storage               +\n               ADDR=(&ADDREG),           starting here                 +\n               LENGTH=(0)                for this long\nPOP&SYSNDX.D DS 0H\n         DROP  R2\nPOP&SYSNDX.E DS 0H\n         AGO   .MEND\n.POPE01  ANOP\n         MNOTE 8,'ADDR must be specified for SSCSTACK POP'\n         AGO   .MEND\n.POPE02  ANOP\n         MNOTE 8,'STACK must be specified for SSCSTACK POP'\n         AGO   .MEND\n.*\n.TERM010 ANOP\n         AIF   ('&STACK' EQ '').TERME02\n         AIF   ('&STACK'(1,1) NE '(').TERM020\n         AIF   ('&STACK(1)' EQ '1').TERM030,                           +\n               ('&STACK(1)' EQ 'R1').TERM030\n         LR    R1,&STACK(1)             Stack origin\n         AGO   .TERM030\n.TERM020 ANOP\n         L     R1,&STACK                A(Stack Origin)\n.TERM030 ANOP\n         L     R0,StackHdr_StackLen-StackHdr(0,R1) Length\n         BASR  R2,0\n         USING (*,TRM&SYSNDX.A-1),R2\n         STORAGE RELEASE,               Free our storage               +\n               ADDR=(1),                 starting here                 +\n               LENGTH=(0)                for this long\nTRM&SYSNDX.A DS 0H\n         DROP  R2\n         AGO   .MEND\n.TERME02 ANOP\n         MNOTE 8,'STACK must be specified for SSCSTACK TERM'\n         AGO   .MEND\n.*\n.MEND    ANOP\n         POP   PRINT\n         MEND\n         TITLE 'IBM Data Areas'\n         PUSH  PRINT\n         PRINT NOGEN\n         IKJCPPL\nCPPL_Length EQU *-CPPL\n\n         IKJCSPL\nCSPL_Length EQU *-CSPL\n\n         IKJCSOA\nCSOA_Length EQU *-CSOA\n\n         IKJPPL\nPPL_Length EQU *-PPL\n\n         IKJIOPL\nIOPL_Length EQU *-IOPL\n\n         IKJUPT\n         IKJTSVT\n         IKJEFLWA\n         IKJPSCB\n         IEFJFCBN\n         DCBD  DSORG=PS\n         IHADCBE\n         IHAPSA\n         CVT   DSECT=YES\n         IHAASVT\n         IHAASCB\n         IHAASXB\n         IHAECVT\n         IHAPCCA\n         IOSDSHID\n         IKJTCB\n         IHARB\n         IHACDE\n         IEZJSCB\n         IEFJSSIB\n         IHASDWA\n         IEFUCBOB PREFIX=YES\n         IOSDPATH\n         IECDDCE\n         IECSDSL1 (4)\n         IEFJESCT\n         IEFJSSOB\n         IEFSSSA\n         IGDVLD\n         IEFTIOT1\n         IEFZB505 LOCEPAX=YES\n         ASASYMBP\n         CSRSIIDF\n\nLSPACE_Parm LSPACE MF=D\nLSPACE_Parm_Length EQU *-LSPACE_Parm\n\nLSPACE_Data LSPACE MF=(D,DATA)\nLSPACE_Data_Length EQU *-LSPACE_Data\n\n         POP   PRINT\n         TITLE 'Local DSECTs'\n*-------------------------------------------------------------------*\n*   This DSECT describes the table in which we maintain DASD        *\n*  volume information. The table is OBTAINed in 31-bit storage      *\n*  the first time it is required, and expands as required to        *\n*  contain the entries required. Note that the table never shrinks. *\n*                                                                   *\n*   Each entry contains the volume information as it will be sent   *\n*  to the user (as well as some internal info). in addition to      *\n*  1 entry per volume, the Headings, Totals and Statistics lines,   *\n*  if requested, occupy table entries.                              *\n*-------------------------------------------------------------------*\n\nVolTbl                    DSECT\n\nVolTbl_Hdr                EQU   *     Info Table Header\nVolTbl_Hdr_TbLen          DS    FL4    Length of table\nVolTbl_Hdr_Count          DS    FL4    Number of used entries\nVolTbl_Hdr_Vols_Eligible  DS    FL4    Nbr Volume entries eligible\nVolTbl_Hdr_Vols_Total     DS    FL4    Nbr Volume entries in table\nVolTbl_Hdr_Vols_Proc      DS    FL4    Nbr Volume entries complete\nVolTbl_Hdr_Total_Off      DS    FL4    Offset of Totals Line\nVolTbl_Hdr_SMS_Off        DS    FL4    Offset of SMS Anomaly line\nVolTbl_Hdr_SubT_Off       DS    FL4    Offset of SubTask Stats Hdg(s)\nVolTbl_Hdr_STIMERM_Adj    DS    FL4    Used by H00010 for STIMERM\n                          DS    0D\nVolTbl_Hdr_LSPACE_Avg     DS    DL8    Used by H00010 for STIMERM\n                          DS    0F     Alignment\nVolTbl_Hdr_ECB            DS    FL4    ECB POSTed when table complete\n                          DS    X      Flag Byte\nVolTbl_Hdr_OW48527        EQU   *-1,X'80' 1... .... APAR OW48527 on\nVolTbl_Hdr_MaxLWait       DS    HL2    Max LSPACE Wait time (secs)\n                          DS    0D     Alignment\nVolTbl_Hdr_Length         EQU   *-VolTbl_Hdr  Length of header\n\nVolTbl_Ent_Start          EQU   *     Info Table Entry\nVolTbl_Ent_ECB            DS    FL4    ECB POSTed when entry complete\n                          DS    X         Status Flag\nVolTbl_Ent_Processed      EQU   *-1,X'80' 1... .... This entry done\nVolTbl_Ent_LSPACE_Fail    EQU   *-1,X'40' .1.. .... LSPACE failed\nVolTbl_Ent_U522           EQU   *-1,X'20' ..1. .... MAXLWAIT(our ESTAE)\n                          DS    X         Entry Descriptor Flag\nVolTbl_Ent_Heading_Line1  EQU   *-1,X'80' 1... .... 1st Heading Line\nVolTbl_Ent_Heading_Line   EQU   *-1,X'40' .1.. .... Other Heading Line\nVolTbl_Ent_Detail_Line    EQU   *-1,X'20' ..1. .... Detail Line\nVolTbl_Ent_Total_Line     EQU   *-1,X'10' ...1 .... Total Line\nVolTbl_Ent_Stats_Line     EQU   *-1,X'08' .... 1... Stats Line\nVolTbl_Ent_SMS_Line       EQU   *-1,X'04' .... .1.. SMS Anomaly Msg\n                          DS    X         Statistics Line Status\nVolTbl_Ent_Stats_CPUTime  EQU   *-1,X'80' 1... .... CPU Time Stats Line\nVolTbl_Ent_Stats_31Stack  EQU   *-1,X'40' .1.. .... 31Bit Stack Stats\nVolTbl_Ent_Stats_24Stack  EQU   *-1,X'20' ..1. .... 24Bit Stack Stats\nVolTbl_Ent_Stats_Done     EQU   *-1,X'01' .... ...1 Stats line filled\n\nVolTbl_Ent_Sort_Start     DS    0D      Start of Sort fields\nVolTbl_Ent_Sort_FreeTrk   DS    DL8      Free Tracks\nVolTbl_Ent_Sort_FreeCyl   DS    DL8      Free Cylinders\nVolTbl_Ent_Sort_FreeBytes DS    DL8      Free Bytes\nVolTbl_Ent_Sort_FreePct   DS    DL8      Free Pct (xx.x)\nVolTbl_Ent_Sort_FreeExt   DS    DL8      Free Extents\nVolTbl_Ent_Sort_LargTrk   DS    DL8      Largest Free Tracks\nVolTbl_Ent_Sort_LargCyl   DS    DL8      Largest Free Cylinders\nVolTbl_Ent_Sort_VTOCTrk   DS    DL8      Tracks in the VTOC\nVolTbl_Ent_Sort_FreeDSCB  DS    DL8      Free DSCBs\nVolTbl_Ent_Sort_VTOCFree  DS    DL8      VTOC % Free\nVolTbl_Ent_Sort_VolSize   DS    DL8      Bytes/Volume\nVolTbl_Ent_Sort_DSCBs     DS    DL8      DSCBs\nVolTbl_Ent_Sort_FragIndex DS    DL8      Frag Index\nVolTbl_Ent_Sort_End       EQU   *       End of Sort fields\n                          ORG   VolTbl_Ent_Sort_Start\nVolTbl_Ent_Sort_Fields    DS    XL(VolTbl_Ent_Sort_End-VolTbl_Ent_Sort_+\n               Start)\n\nVolTbl_Ent_Totals         ORG   VolTbl_Ent_Sort_Start\nVolTbl_Ent_Total_FreeTracks   DS    DL8   Free Tracks\nVolTbl_Ent_Total_FreeCyls     DS    DL8   Free Cylinders\nVolTbl_Ent_Total_FreeBytes    DS    DL8   Free Bytes\nVolTbl_Ent_Total_FreePct      DS    DL8   Free % (xx.x)\nVolTbl_Ent_Total_Extents      DS    DL8   Free Extents\nVolTbl_Ent_Largest_FreeTracks DS    DL8   Largest Free Tracks\nVolTbl_Ent_Largest_FreeCyls   DS    DL8   Largest Free Cyls\nVolTbl_Ent_Total_VTOCTrk      DS    DL8   Total tracks in the VTOCs\nVolTbl_Ent_Total_FreeDSCBs    DS    DL8   Total free DSCBs\nVolTbl_Ent_Total_VTOCFree     DS    DL8   VTOC % Free\nVolTbl_Ent_Total_VolSize      DS    DL8   Total Bytes\nVolTbl_Ent_Total_DSCBs        DS    DL8   Total DSCBs\nVolTbl_Ent_Total_FragIndex    DS    DL8   Total of Frag Indices\nVolTbl_Ent_Total_Vols_OK      DS    FL4   Vols with valid LSPACE data\n                              ORG   ,\n\n                          DS    0F      Align\nVolTbl_Ent_CB_Start       EQU   *        Start of Control Blocks\nVolTbl_Ent_UCBCopy        DS    XL48      UCB Copy\nVolTbl_Ent_DCECopy        DS    XL48        DCE Copy\nVolTbl_Ent_LSPACE_Data    DS    CL(LSPACE_Data_Length) LSPACE\nVolTbl_Ent_DSCB           DS    CL(DS4END-IECSDSL4) Area for F4 DSCB\nVolTbl_Ent_CB_End         EQU   *          End of Control Blocks\n                          ORG   VolTbl_Ent_CB_Start\nVolTbl_Ent_CB_Fields      DS    XL(VolTbl_Ent_CB_End-VolTbl_Ent_CB_Star+\n               t)\n                          ORG   ,\n\nVolTbl_Ent_Display_Start  EQU   *      Start of Display fields\nVolTbl_Ent_Volser         DS    CL6     VOLSER\n                          DS    C\nVolTbl_Ent_DevAddr        DS    CL4     Device Address\n                          DS    CL2\nVolTbl_Ent_DevType        DS    CL8     Device Type\n                          DS    C\nVolTbl_Ent_Attrib         DS    CL3     Mount Status\nVolTbl_Ent_VTOC_SMS       DS    CL1     '*' if VTOC=SMS, UCB^=SMS\n                          DS    C\nVolTbl_Ent_ErrMsg         DS    0CL80   Error message\nVolTbl_Ent_FreeSpace_Info EQU   *       --- Free Space Info Start\nVolTbl_Ent_FreeTrk        DS    CL6         Nbr Free Tracks\n                          DS    C\nVolTbl_Ent_FreeCyl        DS    CL5         Nbr Free Cylinders\n                          DS    CL2\nVolTbl_Ent_FreePct        DS    CL4         % of volume free\n                          DS    C\nVolTbl_Ent_FreeBytes      DS    CL6         Bytes free on the volume\n                          DS    C\nVolTbl_Ent_FreeExt        DS    CL5         Nbr Free Extents\n                          DS    CL2         Largest Free Extents\nVolTbl_Ent_LargTrk        DS    CL6         Largest Free Tracks\n                          DS    C\nVolTbl_Ent_LargCyl        DS    CL5         Largest Free Cylinders\nVolTbl_Ent_FreeSpace_Info_End EQU *     --- Free Space Info End\n                          DS    C\nVolTbl_Ent_Frag_Indx      DS    CL5         Fragmentation Index\n                          DS    CL2\nVolTbl_Ent_VTOC_Info      EQU   *       --- VTOC Info Start\nVolTbl_Ent_VTOCTrk        DS    CL5         VTOC Tracks\n                          DS    C\nVolTbl_Ent_FreeDSCB       DS    CL5         Free DSCBs in VTOC\n                          DS    C\nVolTbl_Ent_VTOCFree       DS    CL4         % DSCBs free\n                          DS    C\nVolTbl_Ent_VTOCIX         DS    CL2         VTOC Index Status\nVolTbl_Ent_VTOC_Info_End  EQU   *       --- VTOC Info End\n                          DS    C           Volume Size\nVolTbl_Ent_VolSize        DS    CL6         Device capacity (in bytes)\n                          DS    C\nVolTbl_Ent_SMS_Info       EQU   *       --- SMS Info Start\nVolTbl_Ent_SMS_StorGrp    DS    CL8         SMS Storage Group\n                          DS    C\nVolTbl_Ent_SMS_Status     DS    CL12        SMS Volume Status\nVolTbl_Ent_SMS_Info_End   EQU   *       --- SMS Info End\n                          DS    C\nVolTbl_Ent_CHPID_Info     EQU   *       --- CHPID Info Start\nVolTbl_Ent_CHPIDs         DS    CL(8*4)     8 CHPIDs @ 4 bytes each\nVolTbl_Ent_CHPID_Info_End EQU   *       --- CHPID Info End\nVolTbl_Ent_Display_End    EQU   *       End of Display area\nVolTbl_Ent_Display_Len    EQU   *-VolTbl_Ent_Display_Start\n                          ORG   VolTbl_Ent_Display_Start\nVolTbl_Ent_Display        DS    CL(VolTbl_Ent_Display_Len)\n                          ORG   ,\n                          DS    0D      Alignment\nVolTbl_Ent_Len            EQU   *-VolTbl_Ent_Start Entry Length\n                          ORG   VolTbl_Ent_Start\nVolTbl_Ent                DS    CL(VolTbl_Ent_Len)\n                          ORG   ,\n\n*-------------------------------------------------------------------*\n*   This DSECT describes the area of storage used to manage the     *\n*  subtasks ATTACHed to retrieve the volume information.            *\n*-------------------------------------------------------------------*\nSubTask_Area              DSECT       Data for each subtask\n\nSubTask_Area_Hdr          EQU   *\nSubTask_Area_Hdr_Len      DS    FL4    SubPool, Length\nSubTask_Area_Hdr_Count    DS    FL4    Nbr entries following\n                          DS    0D\nSubTask_Area_Hdr_Length   EQU   *-SubTask_Area  Length of Header\n\nSubTask_Area_Ent          EQU   *      1 Entry per subtask\nSubTask_Area_Ent_ECB      DS    FL4     ECB POSTed at Subtask end\nSubTask_Area_Ent_TCB      DS    AL4     A(SubTask TCB - ATTACHX)\nSubTask_Area_Ent_Parms    DS    5AL4    Parms for subtask\n                          DS    0D      Alignment\nSubTask_Area_Ent_Length   EQU   *-SubTask_Area_Ent\n\n*-------------------------------------------------------------------*\n*   This DSECT describes the area of storage used to save the lists *\n*  of UCBs that should be included (UCB) or excluded (XUCB).        *\n*   This storage, if required, is acquired by the routine that      *\n*  PARSEs the parameters (C00010).                                  *\n*-------------------------------------------------------------------*\nUCB_List                  DSECT\n\nUCB_List_Hdr              EQU   *     Start of header\nUCB_List_Hdr_Len          DS    FL4    Length of table\nUCB_List_Hdr_Count        DS    FL4    Number of entries\nUCB_List_Hdr_Length       EQU   *-UCB_List_Hdr  Header length\nUCB_List_Ent              EQU   *     Start of entry\nUCB_List_Ent_UCB_Len      DS    XL1    Len of UCB entered\nUCB_List_Ent_UCB          DS    CL4    UCB, with wildcards = X'FF'\nUCB_List_Ent_Mask         DS    CL4    Wildcard mask, wildcards = X'FF'\n*                                                         other = X'00'\nUCB_List_Ent_Length       EQU   *-UCB_List_Ent   Length of an entry\n\n*-------------------------------------------------------------------*\n*   This DSECT describes the area of storage used to save the lists *\n*  of Volsers that should be included (VOL) or excluded (XVOL).     *\n*   This storage, if required, is acquired by the routine that      *\n*  PARSEs the parameters (C00010).                                  *\n*-------------------------------------------------------------------*\nVol_List                  DSECT\n\nVol_List_Hdr              EQU   *      Start of header\nVol_List_Hdr_Len          DS    FL4     Length of table\nVol_List_Hdr_Count        DS    FL4     Number of entries\nVol_List_Hdr_Length       EQU   *-Vol_List_Hdr  Header length\nVol_List_Ent              EQU   *      Start of entry\nVol_List_Ent_Vol          DS    CL6     Vol, with wildcards=X'FF'\nVol_List_Ent_Mask         DS    CL6     Wildcard mask, wildcards=X'FF'\n*                                                          other=X'00'\nVol_List_Ent_Length       EQU   *-Vol_List_Ent   Length of an entry\n\n*-------------------------------------------------------------------*\n*   This DSECT describes the area of storage used to save the list  *\n*  of SMS Storage Groups entered as a selection criterion.          *\n*   This storage, if required, is acquired by the routine that      *\n*  PARSEs the parameters (C00010).                                  *\n*-------------------------------------------------------------------*\nSTORGRP_List              DSECT\n\nSTORGRP_List_Hdr          EQU   *      Start of header\nSTORGRP_List_Hdr_Len      DS    FL4     Length of table\nSTORGRP_List_Hdr_Count    DS  FL4       Number of entries\nSTORGRP_List_Hdr_Length   EQU *-STORGRP_List_Hdr Header length\nSTORGRP_List_Ent          EQU   *      Start of entry\nSTORGRP_List_Ent_STORGRP  DS    CL(L'VLDSTGRP) Name, wildcards=x'FF'\nSTORGRP_List_Ent_Mask     DS    CL(L'VLDSTGRP) Mask, wildcards=x'FF'\n*                                                 other = X'00'\nSTORGRP_List_Ent_Length   EQU   *-STORGRP_List_Ent Length of an entry\n         TITLE 'Global Dynamic Storage'\n\n*-------------------------------------------------------------------*\n*   This DSECT describes dynamic storage addressable by all rout-   *\n*  ines in this program.                                            *\n*-------------------------------------------------------------------*\n@_Dynam                   DSECT\n\n@_31Bit_Stack_Ptr         DS    AL4    A(General Stack)\n@_31Bit_Stack_Length      EQU   16384-StackHdr_Length 16K Stack\n\n@_24Bit_Stack_Ptr         DS    AL4    A(24-bit Stack)\n@_24Bit_Stack_Length      EQU 2048-StackHdr_Length 2K Stack\n\n@_VolTbl_Ptr              DS    AL4    A(Table of space info)\n\n                          DS    X      Environment flag\n@_Batch_Environ           EQU   *-1,X'80' 1... .... Batch run\n@_TSO_Command             EQU   *-1,X'40' .1.. .... TSO command\n@_OW48527                 EQU   *-1,X'20' ..1. .... OW48527 installed\n@_IKJEFTSR                EQU   *-1,X'10' ...1 .... IKJEFTSR Invoked\n@_CHAP_Done               EQU   *-1,X'08' .... 1... Prty lowered\n\n                          DS    X      Output Options Flags\n@_No_Headings             EQU   *-1,X'80' 1... .... No hdgs\n@_No_Details              EQU   *-1,X'40' .1.. .... No detail\n@_No_Totals               EQU   *-1,X'20' ..1. .... No totals\n@_Statistics              EQU   *-1,X'10' ...1 .... Internal Stats\n@_ISPF_SPACE              EQU   *-1,X'08' .... 1... ISPF tbl and pnl\n@_ISPF_EDIF               EQU   *-1,X'04' .... .1.. ISPF EDIF\n@_ISPF_BRIF               EQU   *-1,X'02' .... ..1. ISPF BRIF\n@_ISPF_Explicit           EQU   *-1,X'01' .... ...1 ISPF Kwd specified\n\n                          DS    X      More Output Options Flags\n@_No_LSPACE               EQU   *-1,X'80' 1... .... Don't issue LSPACE\n@_ReDisplay               EQU   *-1,X'40' .1.. .... Redisplay required\n@_OutData_DISPLAY         EQU   *-1,X'04' .... .1.. OUTDATA(DISPLAY)\n@_OutData_CB              EQU   *-1,X'02' .... ..1. OUTDATA(CB)\n@_OutData_ALL             EQU   *-1,X'01' .... ...1 OUTDATA(ALL)\n\n                          DS    X      Error Flags\n@_VolTbl_GETMAIN_Err      EQU   *-1,X'80' 1... .... Not enough storage\n@_No_APF                  EQU   *-1,X'20' ..1. .... No APF auth\n@_IKJEFTSR_Err            EQU   *-1,X'10' ...1 .... Error in IKJEFTSR\n@_SYSCLOCK_Err            EQU   *-1,X'08' .... 1... SYSCLOCK Mismatch\n@_Incompatible_OS         EQU   *-1,X'04' .... .1.. Incompatible OS\n@_Internal_Err            EQU   *-1,X'02' .... ..1. Unknown parm\n@_LSPACE_Failed           EQU   *-1,X'01' .... ...1 VolTbl Incomplete\n\n@_CPU_Time_Init           DS    DL8    CPU Time at start of pgm\n@_CPU_Time_Used           DS    DL8    Accumulated CPU Time\n\n@_IKJEFTSR_RC             DS    FL4    IKJEFTSR Return code area\n@_IKJEFTSR_Reas           DS    FL4    IKJEFTSR Reason code area\n\n@_IKJEFTSR_TimeStamp_Ptr  DS    AL4    A(TimeStamp for IKJEFTSR)\n@_NSwap_Time              DS    DL8    Non-swappable time\n\n@_Sort_Field              DS    CL8    Sort Field\n@_Sort_Direction          DS    CL1    Sort Direction (A/D)\n\n@_LineSize                DS    HL2    Line Size from command line\n\n@_MaxLWait                DS    HL2    Max LSPACE Wait time (seconds)\n\n@_MaxTasks                DS    HL2    Max LSPACE sub-tasks on cmdline\n@_SubTask_Count           DS    FL4    Nbr subtasks to ATTACH\n@_SubTask_Area_Ptr        DS    AL4    A(SubTask Area)\n@_LP_Count                DS    FL4    Nbr active LPs\n\n@_OutFile_DDname          DS    CL8    DDName of current OUTFILE\n@_OutFile_24Bit_Stack_Ptr DS    AL4    A(24-bit Stack for OutFile DCBs)\n@_OutFile_Chain_Ptr       DS    AL4    A(Start of Output DCB chain)\n@_OutFile_PUT_Code        DS    AL4    A(24-bit PUT code)\n\n*  ------  Selection Criteria  ------\n@_Vol_List_Ptr            DS    AL4     A(List of VOLSER Masks)\n@_XVol_List_Ptr           DS    AL4     A(List of XVOLSER Masks)\n@_UCB_List_Ptr            DS    AL4     A(List of UCB Masks)\n@_XUCB_List_Ptr           DS    AL4     A(List of XUCB Masks)\n@_STORGRP_List_Ptr        DS    AL4     A(List of StorGrps)\n@_UNITNM                  DS    CL8     Unit Name\n                          DS    X       Mount Attribute\n@_ATTRPvt                 EQU   *-1,X'80' 1... .... Private\n@_ATTRPub                 EQU   *-1,X'40' .1.. .... Public\n@_ATTRStg                 EQU   *-1,X'20' ..1. .... Storage\n@_ATTRSMS                 EQU   *-1,X'10' ...1 .... SMS\n\n*-----------------------------  Start of TSO Cmd specific data  -----*\n                          DS    0D                                   *\n@_CPPL_Ptr                DS    AL4     A(Cmd Proc Parm List)        *\n                          DS    X       Flag byte                    *\n@_TSO_Processed           EQU   *-1,X'80' 1... .... Cmd processed    *\n@_ISPLINK                 DS    AL4     A(ISPLINK)                   *\n*-----------------------------  End of TSO Cmd specific data  -------*\n\n*-----------------------------  Start of Batch specific data  -------*\n                          DS    0D                                   *\n@_SYSIN_DCB_Ptr           DS    AL4     A(SYSIN DCB)                 *\n@_Page_Count              DS    HL2     Page Count                   *\n@_Line_Count              DS    HL2     Line Count                   *\n@_Bat_CPPL_Ptr            DS    AL4     A(CPPL in Batch)             *\n                          DS    0F      Alignment                    *\n@_Bat_CPPL                DS    CL(CPPL_Length)  CPPL in Batch       *\n                          DS    0F      Alignment                    *\n@_SYSIN_DCBE              DS    CL(C_SYSIN_DCBE_Length) SYSIN DCBE   *\n*-----------------------------  End of Batch specific data  ---------*\n                          ORG   ,\n*=====================================================================*\n                          DS    0D\n@_Dynam_Length            EQU   *-@_Dynam  Length of Global storage\n\n         TITLE 'Main Program Block'\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Routine   : A00010                                                 *\n*                                                                     *\n*  Abstract  : Main program loop - invoke other routines to perform   *\n*              real work                                              *\n*                                                                     *\n*  Inputs    : As received on invocation                              *\n*  Outputs   : R15: 0 - OK                                            *\n*                   4 - Error encountered                             *\n*                                                                     *\n*  Notes     :                                                        *\n*                                                                     *\n*  History:    1990/06/11 SDDA030 - New                               *\n*              1999/05/27 SDDA030 - V2.6                              *\n*                                 - Used LIFO Stack for our dynamic   *\n*                                   areas.                            *\n*              1999/09/30 SDDA030 - V2.10                             *\n*                                 - Reset Stack statistics for each   *\n*                                   iteration.                        *\n*              2000/01/19 SDDA030 - V2.11                             *\n*                                 - Added 24-bit Stack                *\n*              2001/02/01 SDDA030 - V2.13                             *\n*                                 - Added check for re-invocation by  *\n*                                   IKJEFTSR                          *\n*              2006/04/21 SDDA030 - V2.24                             *\n*                                 - Used standardized calling sequence*\n*              ____/__/__ _______                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n*        PRINT NOGEN\n\n&PGMNAME CSECT\n&PGMNAME AMODE 31\n&PGMNAME RMODE ANY\n\n         SYSSTATE ARCHLVL=1\n\n         J     A00010                   Skip eyecatcher\n         DC    C'&PGMNAME &VERSION  &ASMDT &ASMTM'\n\nA00010   DS    0H\n         BAKR  R14,0                    Save callers registers\n         LARL  R11,A_Literals           Point to our literals\n         USING (A_Literals,A_Literals_End),R11 Tell the assembler\n\n*-------------------------------------------------------------------*\n*    Make sure we're in 31-bit mode                                 *\n*-------------------------------------------------------------------*\n         TAM   ,                        Check AMODE\n         JM    A00020                   AMODE 31, OK\n         SAM31 ,                        Get into 31-bit mode\n\nA00020   DS    0H\n*-------------------------------------------------------------------*\n*    Get some storage for our LIFO stack ...                        *\n*-------------------------------------------------------------------*\n         LHI   R0,@_31Bit_Stack_Length  Length of storage we need\n         SSCSTACK INIT,                 Go get our storage             +\n               LEN=(R0),                 this long                     +\n               LOC=31                    above-the-line\n\n         LR    R3,R1                    Save its address\n\n*-------------------------------------------------------------------*\n*    ... and get some room on it for the globally addressable       *\n*     variables ...                                                 *\n*-------------------------------------------------------------------*\n         SSCSTACK PUSH,                 Get Stack area                 +\n               LEN=@_Dynam_Length,       this long                     +\n               STACK=(R3)                using this stack\n\n         LR    R12,R1                   Point to our storage\n\n         USING @_Dynam,R12              Assign a base\n\n         LA    R0,@_Dynam               A(Our storage)\n         LHI   R1,@_Dynam_Length        Its length\n         LA    R14,0                    Clear source address\n         LA    R15,0                     and length\n         MVCL  R0,R14                   Clear our storage\n\n         ST    R3,@_31Bit_Stack_Ptr     Save A(Stack)\n\n*-------------------------------------------------------------------*\n*    ... and finally get an area on it for our local storage        *\n*-------------------------------------------------------------------*\n         SSCSTACK PUSH,                 Get Stack area                 +\n               LEN=@A_Dynam_Length,      this long                     +\n               STACK=@_31Bit_Stack_Ptr    using this stack\n\n         LR    R3,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LHI   R1,@A_Dynam_Length        Its length\n         LA    R14,0                    Clear source address\n         LA    R15,0                     and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R3                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*    Set up save area, and restore the important registers          *\n*   that we have destroyed                                          *\n*-------------------------------------------------------------------*\n         LR    R13,R1                   Load dynam base\n         USING @A_Dynam,R13             Tell the assembler\n         MVC   4(4,R13),=C'F1SA'        Init save area\n\n         EREG  R0,R3                    Restore callers registers\n\n*--------------------------------------------------------------------*\n*   Initialize our standard parmlist                                 *\n*--------------------------------------------------------------------*\n         LA    R15,@_Dynam              A(Dynamic area)\n         ST    R15,@A_Parms_Std         Save it\n         LA    R15,@_31Bit_Stack_Ptr    A(31-bit Stack Pointer)\n         ST    R15,@A_Parms_Std+4       Save it\n         LA    R15,@_24Bit_Stack_Ptr    A(24-bit Stack Pointer)\n         ST    R15,@A_Parms_Std+8       Save it\n\n         ST    R1,@A_Original_R1        Save R1 on entry\n\n*--------------------------------------------------------------------*\n*   Initialize                                                       *\n*--------------------------------------------------------------------*\n         LA    R15,@A_Original_R1       A(Original R1)\n         ST    R15,@A_Parms_B00010      Save it\n\n         LA    R1,@A_Parms              A(Parmlist)\n         BRAS  R14,B00010               Go do initialization\n\n         ST    R15,@A_Max_RC            Save the return code\n         LTR   R15,R15                  Did it work?\n         JNZ   A00130                   No, skip\n\n*--------------------------------------------------------------------*\n*   If we are being re-invoked by IKJEFTSR ...                       *\n*--------------------------------------------------------------------*\n         TM    @_IKJEFTSR,L'@_IKJEFTSR  IKJEFTSR invocation?\n         JNO   A00100\n\n*--------------------------------------------------------------------*\n*   ... we want to invoke E00010 with the original @_Dynam.          *\n*  Therefore, we save the current @_Dynam address and load up the    *\n*  one passed to us (the original) ...                               *\n*--------------------------------------------------------------------*\n         L     R12,@A_Original_R1       Point to the @_Dynam\n         L     R12,2(0,R12)              to the one passed to us\n\n*--------------------------------------------------------------------*\n*   ... turn on the @_IKJEFTSR flag (since it is not on in this      *\n*  version of @_Dynam) ...                                           *\n*--------------------------------------------------------------------*\n         OI    @_IKJEFTSR,L'@_IKJEFTSR  On the flag\n\n*--------------------------------------------------------------------*\n*   ... invoke E00010 to populate the table ...                      *\n*--------------------------------------------------------------------*\n         LA    R1,@A_Parms              A(Parm list)\n         BRAS  R14,E00010               Go populate table\n\n*--------------------------------------------------------------------*\n*   ... turn off the @_IKJEFTSR flag, and re-point to our @_Dynam    *\n*--------------------------------------------------------------------*\n         NI    @_IKJEFTSR,X'FF'-L'@_IKJEFTSR  Off the flag\n         LR    R12,R3                  Reset @_Dynam base\n\n*--------------------------------------------------------------------*\n*   ... and exit                                                     *\n*--------------------------------------------------------------------*\n         LA    R15,0                   Clear return code\n         ST    R15,@A_Max_RC           Save it\n         J     A90010                  and exit\n\nA00100   DS    0H\n*--------------------------------------------------------------------*\n*   And now loop: Get Input                                          *\n*                 Get Space Info                                     *\n*                 Display Results                                    *\n*--------------------------------------------------------------------*\n\n*--------------------------------------------------------------------*\n*   Reset the CPU Time used so far, in case we have to produce       *\n*    stats ...                                                       *\n*--------------------------------------------------------------------*\n         TIMEUSED STORADR=@_CPU_Time_Init,  Reset CPU Time Used        +\n               LINKAGE=SYSTEM,           as recommended by IBM         +\n               CPU=MIC                   get it in microseconds\n         XC    @_CPU_Time_Used,@_CPU_Time_Used  Clear accum CPU Time\n\n*--------------------------------------------------------------------*\n*   ... and the Stack statistics ...                                 *\n*--------------------------------------------------------------------*\n         L     R15,@_31Bit_Stack_Ptr    Point to the stack\n         LA    R0,0                     Clear work register\n         ST    R0,StackHdr_HWM-StackHdr(R15) Clear high-water mark\n         ST    R0,StackHdr_GETMAIN-StackHdr(R15) Clear converted PUSHs\n         ST    R0,StackHdr_Overflow_HWM-StackHdr(R15) and GETMAIN HWM\n\n*--------------------------------------------------------------------*\n*   ... WAIT for our subtasks to complete ...                        *\n*--------------------------------------------------------------------*\n         LA    R1,@A_Parms              A(ParmList)\n         BRAS  R14,S00010               WAIT for our subtasks\n\n*--------------------------------------------------------------------*\n*   ... and then go and get some input                               *\n*--------------------------------------------------------------------*\n         LA    R1,@A_Parms              A(ParmList)\n         BRAS  R14,C00010               Go get processing parms\n         LTR   R15,R15                  EOF?\n         JNZ   A90010                   Yes, exit\n\n*--------------------------------------------------------------------*\n*   We have something, so go scan the UCBs ...                       *\n*--------------------------------------------------------------------*\n         LA    R1,@A_Parms              A(Parm list)\n         BRAS  R14,D00010               Go get eligible UCBs\n\n         LTR   R15,R15                  Any?\n         JZ    A00120                   Yes, skip\n         C     R15,@A_Max_RC            No, biggest RC so far?\n         JNH   A00130                   No, skip\n         ST    R15,@A_Max_RC            Yes, save it\n         J     A00130                   and skip\n\nA00120   DS    0H\n*--------------------------------------------------------------------*\n*   ... and get the info about them                                  *\n*--------------------------------------------------------------------*\n         LA    R1,@A_Parms              A(Parm list)\n         BRAS  R14,E00010               Go populate table\n\nA00130   DS    0H\n*--------------------------------------------------------------------*\n*   Output the info ...                                              *\n*--------------------------------------------------------------------*\n         LA    R1,@A_Parms              A(Parm list)\n         BRAS  R14,F00010               Output the results\n         C     R15,@A_Max_RC            Biggest RC so far?\n         JNH   A00140                   No, skip\n         ST    R15,@A_Max_RC            Yes, save it\n\nA00140   DS    0H\n*--------------------------------------------------------------------*\n*   ... and do it all again                                          *\n*--------------------------------------------------------------------*\n         L     R15,@A_Max_RC            Get max return code\n         CHI   R15,4                    Too big?\n         JNH   A00100                   No, get more input\n\nA90010   DS    0H\n*-------------------------------------------------------------------*\n*    Perform our Termination routines ...                           *\n*-------------------------------------------------------------------*\n         LA    R1,@A_Parms              A(Parm list)\n         BRAS  R14,Z00010               Clean up\n\n*-------------------------------------------------------------------*\n*    ... delete our 24-bit stack ...                                *\n*-------------------------------------------------------------------*\n         ICM   R1,B'1111',@_24Bit_Stack_Ptr A(Stack below-the-line)\n         JZ    A90020                   None, skip\n         SSCSTACK TERM,                 Free the stack area            +\n               STACK=(1)                 this one\n\nA90020   DS    0H\n*-------------------------------------------------------------------*\n*    ... save our max return code, and free up our local data ...   *\n*-------------------------------------------------------------------*\n         L     R4,@A_Max_RC             Save return code\n\n         LA    R1,@A_Dynam              A(Local storage)\n\n         SSCSTACK POP,                  Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=@_31Bit_Stack_Ptr   on this stack\n\n*-------------------------------------------------------------------*\n*    ... then the global data area ...                              *\n*-------------------------------------------------------------------*\n         LA    R1,@_Dynam               A(Global storage)\n         L     R3,@_31Bit_Stack_Ptr     Rescue Stack pointer\n\n         SSCSTACK POP,                  Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=(R3)                on this stack\n\n*-------------------------------------------------------------------*\n*    ... and finally, the stack itself.                             *\n*-------------------------------------------------------------------*\n         SSCSTACK TERM,                 Free the stack                 +\n               STACK=(R3)                starting here\n\n*-------------------------------------------------------------------*\n*    Restore the callers registers, and exit.                       *\n*-------------------------------------------------------------------*\n         LR    R15,R4                   Restore return code\n         PR    ,                        and return to caller\n\nA_Literals      DS    0H\n\n         LTORG\n\nA_Literals_End  DS    0H\n\n@A_Dynam                  DSECT         Dynamic storage for A00010\n                          DS    18F      Save area\n@A_Original_R1            DS    FL4      R1 on entry\n@A_Max_RC                 DS    FL4      Highest return code\n@A_Parms                  DS    0F       Parms for Called modules\n@A_Parms_Std              DS    3AL4      Standard 3 parms\n@A_Parms_Extra            EQU   *         More parms\n@A_Parms_B00010           DS    AL4         for B00010\n                          ORG   ,\n                          DS    0D       Alignment\n@A_Dynam_Length           EQU   *-@A_Dynam  Length\n\n&PGMNAME CSECT\n\n         DROP  ,\n         TITLE 'B00010: Initialization'\n\n         PUSH  USING\n\nB00010   DS    0H\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Routine   : B00010                                                 *\n*                                                                     *\n*  Abstract  : Perform one-time initialization functions based on     *\n*              environment.                                           *\n*                                                                     *\n*  Inputs    : R1 : ---> A(@_Dynam)                                   *\n*                        A(31-bit Stack Pointer)                      *\n*                        A(24-bit Stack Pointer)                      *\n*                        A(Original R1 on program invocation)         *\n*  Outputs   : R15: 0 - OK                                            *\n*                   4 - Error encountered                             *\n*                                                                     *\n*  Notes     :                                                        *\n*                                                                     *\n*  History:    1990/06/11 SDDA030 - New                               *\n*              1998/09/22 SDDA030 - V2.1                              *\n*                                 - Copied STLINENO or SYSPRINT/SYSIN *\n*                                   I/O routines to 24-bit storage.   *\n*              1998/11/13 SDDA030 - V2.2                              *\n*                                 - Set up TSO environment (IKJTSOEV) *\n*                                   in batch.                         *\n*              1999/01/14 SDDA030 - V2.4                              *\n*                                 - Rationalized ISPF/TSO cmd/CALL    *\n*                                   checks                            *\n*              1999/05/27 SDDA030 - V2.6                              *\n*                                 - Used LIFO Stack for our dynamic   *\n*                                   areas.                            *\n*                                 - Removed copy of SYSIN/SYSPRINT    *\n*                                   routines to 24-bit storage.       *\n*              1999/07/30 SDDA030 - V2.7                              *\n*                                 - Moved SYSIN initialization to     *\n*                                   C00010                            *\n*              1999/09/30 SDDA030 - V2.10                             *\n*                                 - Removed ISPF initialization.      *\n*                                 - Created @_Hdr0-3.                 *\n*              2000/01/19 SDDA030 - V2.11                             *\n*                                 - OPENed SYSPRINT if batch          *\n*              2001/02/01 SDDA030 - V2.13                             *\n*                                 - Added check for parms passed for  *\n*                                   IKJEFTSR invocation.              *\n*              2001/02/26 SDDA030 - V2.14                             *\n*                                 - Moved heading initialization to   *\n*                                   C00010.                           *\n*              2002/08/08 SDDA030 - V2.19                             *\n*                                 - Checked IGC0007H (LSPACE) for     *\n*                                   APAR OW48527                      *\n*              2006/04/21 SDDA030 - V2.24                             *\n*                                   Used standardised calling sequence*\n*              ____/__/__ xxxxxxx - Vx.xx                             *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         STM   R14,R12,12(R13)          Save callers registers\n         LARL  R11,B_Literals           Point to our literals\n         USING (B_Literals,B_Literals_End),R11 Tell the assembler\n\n         L     R12,0(0,R1)              A(@_Dynam)\n         USING @_Dynam,R12              Tell the assembler\n\n*-------------------------------------------------------------------*\n*    Get an area on the stack for our local storage                 *\n*-------------------------------------------------------------------*\n         L     R2,4(0,R1)               A(31-bit stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         SSCSTACK PUSH,                 Get Stack area                 +\n               LEN=@B_Dynam_Length,      this long                     +\n               STACK=(R2)                using this stack\n\n         LR    R3,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LHI   R1,@B_Dynam_Length        Its length\n         LA    R14,0                    Clear source address\n         LA    R15,0                     and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R3                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*-------------------------------------------------------------------*\n         ST    R13,4(0,R1)              Chain\n         ST    R1,8(0,R13)               saveareas\n         LR    R13,R1                   Load dynam base\n         USING @B_Dynam,R13             Assign a base\n\n         L     R15,@B_Dynam+4           Get A(HSA)\n         LM    R0,R3,20(R15)            Restore callers registers\n\n         L     R15,4(0,R1)              A(31-bit Stack Pointer)\n         ST    R15,@B_31Bit_Stack_Ptr_Ptr Save it\n         L     R15,8(0,R1)              A(24-bit Stack Pointer)\n         ST    R15,@B_24Bit_Stack_Ptr_Ptr Save it\n\n*---------------------------------------------------------------------*\n*    Clear our various flags, and save the original R1                *\n*---------------------------------------------------------------------*\n         NI    @_TSO_Command,X'FF'-L'@_TSO_Command Off TSO flag\n         NI    @_Batch_Environ,X'FF'-L'@_Batch_Environ Off Batch flag\n         L     R15,12(0,R1)             A(Original R1)\n         L     R15,0(0,R15)             Get it\n         ST    R15,@B_Original_R1       Save it\n\n*---------------------------------------------------------------------*\n*   Determine the environment under which we were invoked:            *\n*     TSO Command: R1 --> CPPL                                        *\n*     IKJEFTSR Reinvocation:                                          *\n*        R1 ---> A(Parm1): HL2'4',A(Original @_Dynam)                 *\n*                A(Parm2): HL2'?',CL?(Copy of start of @_Dynam)       *\n*     Batch: Anything else                                            *\n*---------------------------------------------------------------------*\n         ICM   R1,B'1111',@B_Original_R1 Restore original R1\n         JZ    B03000                   Nothing, not a TSO cmd\n         L     R14,PSATNEW-PSA(0)       Yes, get A(our TCB)\n         L     R14,TCBJSCB-TCB(R14)     Get A(Our JSCB)\n         SLL   R14,8                    Clean\n         SRL   R14,8                      it\n         ICM   R14,B'1111',JSCBPSCB-IEZJSCB(R14) Get A(PSCB)\n         JZ    B03000                   None, not TSO\n         C     R14,CPPLPSCB-CPPL(R1)    Are we passed a CPPL?\n         JE    B02000                   Yes, go process\n\n*---------------------------------------------------------------------*\n*   We were passed a parm, but it is not the CPPL; check out the      *\n*  parms to see if we are being re-invoked by IKJEFTSR:               *\n*                                                                     *\n*     R1 ---> ---> H'4',A(@_Dynam)                                    *\n*             ---> H'16',1st 16 bytes of @_Dynam                      *\n*---------------------------------------------------------------------*\n         TM    0(R1),X'80'              Only 1 parm?\n         JO    B03000                   Yes, not IKJEFTSR, assume batch\n         TM    4(R1),X'80'              No, 2nd parm the last?\n         JNO   B80010                   No, error\n\n         L     R15,0(0,R1)              Get A(1st parm)\n         LH    R14,0(0,R15)             Get its length\n         CHI   R14,4                    Is it the right length?\n         JNE   B80010                   No, not IKJEFTSR\n         L     R0,2(0,R15)              Maybe, load A(Original @_Dynam)\n\n         L     R14,4(0,R1)              Get A(2nd Parm)\n         LH    R15,0(0,R14)             Get its length\n         LA    R14,2(0,R14)             Point to it\n         LR    R1,R15                   Length to check\n         CLCL  R0,R14                   Is this really @_Dynam?\n         JNE   B80010                   No, error\n\n         OI    @_IKJEFTSR,L'@_IKJEFTSR  Yes, set our flag\n         LA    R15,0                    Clear the return code\n         J     B90010                   and exit\n\nB02000   DS    0H\n*---------------------------------------------------------------------*\n*   TSO Command Initialization - save A(CPPL) ...                     *\n*---------------------------------------------------------------------*\n         OI    @_TSO_Command,L'@_TSO_Command    Set TSO flag\n\n         L     R1,@B_Original_R1        Get original R1 - A(CPPL)\n         ST    R1,@_CPPL_Ptr            Save A(CPPL)\n\n*---------------------------------------------------------------------*\n*   ... clear our flag ...                                            *\n*---------------------------------------------------------------------*\n         NI    @_TSO_Processed,X'FF'-L'@_TSO_Processed\n\n*---------------------------------------------------------------------*\n*   ... and go check the status of OW48527                            *\n*---------------------------------------------------------------------*\n         J     B04000                   go do it\n\nB03000   DS    0H\n*---------------------------------------------------------------------*\n*   Batch Job Initialization - initialize page and line counts ...    *\n*---------------------------------------------------------------------*\n         OI    @_Batch_Environ,L'@_Batch_Environ Set Batch flag\n\n         LA    R15,0                    Clear work register\n         STH   R15,@_Page_Count         Clear page count\n\n*---------------------------------------------------------------------*\n*   ... and set up the TSO environment by invoking IKJTSOEV, saving   *\n*  the address of the CPPL we get back.                               *\n*---------------------------------------------------------------------*\n         LA    R1,@B_Link_Parms         A(Parameter list)\n         LA    R15,@B_Link_Parms+20     Point past them\n         LHI   R14,4                    4 parameters\n\nB03010   DS    0H\n         ST    R15,0(0,R1)              Save Parm ptr\n         AHI   R15,4                    Bump pointer\n         AHI   R1,4                     Bump parm pointer\n         BRCT  R14,B03010               and do it again\n         LA    R15,@_Bat_CPPL_Ptr       A(Command Buffer pointer)\n         ST    R15,@B_Link_Parms+16     Save it\n         OI    @B_Link_Parms+16,X'80'   Flag as last\n\n         MVC   @B_LINKX,B_LINKX         Move Link L-Form\n         LARL  R2,B03020                Error return here\n         LINKX EP=IKJTSOEV,             Establish TSO environment      +\n               ERRET=(2),                go here if LINK error         +\n               MF=(E,@B_Link_Parms),     using these parms             +\n               SF=(E,@B_LINKX)           keep ourselves re-entrant\n         ICM   R14,B'1111',@_Bat_CPPL_Ptr Get A(CPPL returned)\n         JNZ   B04000                   OK, check OW48527\n\nB03020   DS    0H\n*---------------------------------------------------------------------*\n*   If we didn't get a CPPL address back from IKJTSOEV, but we are    *\n*  running in a TSO address space, build our own copy of a CPPL that  *\n*  we can use to build the PPL                                        *\n*---------------------------------------------------------------------*\n         CHI   R15,24                   No, TSO env present?\n         JH    B03810                   No, something else, error\n\n         L     R14,PSATOLD-PSA(0)       Get A(our TCB)\n         L     R14,TCBJSCB-TCB(R14)     Get A(Our JSCB)\n         SLL   R14,8                    Clean\n         SRL   R14,8                      it\n         ICM   R14,B'1111',JSCBPSCB-IEZJSCB(R14) Get A(PSCB)\n         JZ    B03810                   None, can't use TSO\n         ST    R14,@_Bat_CPPL+CPPLPSCB-CPPL Save A(PSCB)\n\n         L     R15,PSCBUPT-PSCB(R14)    A(UPT)\n         ST    R15,@_Bat_CPPL+CPPLUPT-CPPL Save A(UPT)\n\n         L     R14,PSAAOLD-PSA(0)       Get A(our ASCB)\n         L     R14,ASCBASXB-ASCB(R14)   A(Our ASXB)\n         L     R14,ASXBLWA-ASXB(R14)    A(LWA)\n         L     R15,LWAPECT-LWA(R14)     A(ECT)\n         ST    R15,@_Bat_CPPL+CPPLECT-CPPL Save A(ECT)\n         LA    R15,@_Bat_CPPL           A(Our pseudo CPPL)\n         ST    R15,@_Bat_CPPL_Ptr       Save it\n\n         J     B04000                   Check status of OW48527\n\nB03810   DS    0H\n         LA    R15,4                    Error creating TSO environment\n         J     B90010                   exit\n\nB04000   DS    0H\n*-------------------------------------------------------------------*\n*    Everything is OK so far, so we want to check the status of     *\n*   APAR OW48527, which added a time-out to the LSPACE SVC (we will *\n*   do things differently if the APAR is installed). We check the   *\n*   module IGC0007H (LSPACE) for the literal 'I/O TIMEOUT', part    *\n*   of a new error message that came in with OW48527.               *\n*-------------------------------------------------------------------*\n         MVC   @B_CSVQUERY,B_CSVQUERY   Move L-Form\n         CSVQUERY INEPNAME=B_IGC0007H,  EP Name                        +\n               OUTLOADPT=@B_IGC0007H_Ptr,  return load point           +\n               OUTLENGTH=@B_IGC0007H_Len,  and length                  +\n               PLISTVER=MAX,               max parm list               +\n               MF=(E,@B_CSVQUERY)          staying reentrant\n         LTR   R15,R15                  How did we do?\n         JZ    B04010C                  OK, skip\n         CHI   R15,20                   Incompatible OS?\n         JE    B80020                   Yes, skip\n         J     B04910                   No, assume no OW48527\nB04010C  DS    0H\n\n         ICM   R14,B'1111',@B_IGC0007H_Len OK, get the length\n         JZ    B04910                   Nothing, skip\n         ICM   R15,B'1111',@B_IGC0007H_Ptr Get the address\n         JZ    B04910                   None, exit\n\n         LHI   R1,L'B_OW48527_Lit-1     EX length of literal\n         SLR   R14,R1                   Adjust the length to check\n\nB04020   DS    0H\n         EX    R1,B_Check_OW48527       Check for literal\n         JE    B04030                   Found it, skip\n         AHI   R15,1                    Not it, bump pointer\n         BRCT  R14,B04020               and check again\n         J     B04910                   Not found, exit\n\nB04030   DS    0H\n         OI    @_OW48527,L'@_OW48527    Indicate OW48527 present\n\nB04910   DS    0H\n         LA    R15,0                    Clear return code\n         J     B90010                   and exit\n\nB80010   DS    0H\n*-------------------------------------------------------------------*\n*    Unknown Parm, exit with error                                  *\n*-------------------------------------------------------------------*\n\n         OI    @_Internal_Err,L'@_Internal_Err Set our flag\n         LA    R15,8                    Set error return code\n         J     B90010                   and exit\n\nB80020   DS    0H\n*-------------------------------------------------------------------*\n*    Incompatible OS, set flag and return code                      *\n*-------------------------------------------------------------------*\n         OI    @_Incompatible_OS,L'@_Incompatible_OS Set our flag\n         LA    R15,8                    and return code\n         J     B90010                   and exit\n\nB90010   DS    0H\n*-------------------------------------------------------------------*\n*    Free up our local storage ...                                  *\n*-------------------------------------------------------------------*\n         LR    R3,R15                 Save return code\n\n         LA    R1,@B_Dynam              A(Local storage)\n         L     R2,@B_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n\n         L     R13,4(0,R13)             Rescue A(HSA)\n\n         SSCSTACK POP,                  Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=(2)                 on this stack\n\n         LR    R15,R3                   Restore return code\n\n*-------------------------------------------------------------------*\n*    ... and return to caller                                       *\n*-------------------------------------------------------------------*\n         L     R14,12(0,R13)            Restore return address\n         LM    R0,R12,20(R13)           Restore other registers\n         BSM   0,R14                    and return\n\nB_Literals            DS    0H\n\nB_Check_OW48527 CLC  B_OW48527_Lit,0(R15)  Check for OW48527 literal\n\n         PUSH  PRINT\n         PRINT NOGEN\n\nB_IGC0007H      DC    CL8'IGC0007H'   LSPACE SVC name\nB_OW48527_Lit   DC    C'I/O TIMEOUT'  Literal indicating OW48527\n\nB_LINKX  LINKX EP=IKJTSOEV,                                            +\n               SF=L\nB_LINKX_Length EQU *-B_LINKX\n\n         CSVQUERY PLISTVER=MAX,                                        +\n               MF=(L,B_CSVQUERY)\nB_CSVQUERY_Length EQU *-B_CSVQUERY\n\n\n         POP   PRINT\n\n\n         LTORG\nB_Literals_End            DS    0H\n\n@B_Dynam                  DSECT         Dynamic area for B00000\n                          DS    18F      O/S Style save area\n@B_31Bit_Stack_Ptr_Ptr    DS    AL4      A(31-bit Stack Ptr)\n@B_24Bit_Stack_Ptr_Ptr    DS    AL4      A(24-bit Stack Ptr)\n@B_Original_R1            DS    AL4      Value of R1 at program entry\n@B_Macros                 DS    0F       Macro area\n@B_LINKX                  DS    CL(B_LINKX_Length)  L-Form of LINKX\n@B_Link_Parms             DS    5AL4     Parms for Link\n                          DS    4AL4     Dummy parms\n                          ORG   @B_Macros\n@B_CSVQUERY               DS    CL(B_CSVQUERY_Length) L-Form CSVQUERY\n@B_IGC0007H_Ptr           DS    AL4      A(IGC0007H)\n@B_IGC0007H_Len           DS    AL4      Length of IGC0007H\n                          ORG   ,\n                          DS    0D       Alignment\n@B_Dynam_Length           EQU   *-@B_Dynam  Length of storage required\n\n&PGMNAME CSECT\n\n         DROP  ,\n         POP   USING\n         TITLE 'C00010: Get Input Data'\n\n         PUSH  USING\n\nC00010   DS    0H\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Routine   : C00010                                                 *\n*                                                                     *\n*  Abstract  : Get selection criteria for extracting UCB info         *\n*                                                                     *\n*  Inputs    : R1 : ---> A(@_Dynam)                                   *\n*                        A(31-bit Stack Pointer)                      *\n*                        A(24-bit Stack Pointer)                      *\n*  Outputs   : R15: 0 - OK                                            *\n*                   4 - EOF, 'END' etc.                               *\n*                                                                     *\n*  Operation : For a batch job,                                       *\n*               Read SYSIN                                            *\n*               Build a pseudo command buffer                         *\n*              Parse command buffer                                   *\n*                                                                     *\n*  Notes     :                                                        *\n*                                                                     *\n*  History:    1990/06/11 SDDA030 - New                               *\n*              1998/09/22 SDDA030 - V2.1                              *\n*                                 - Calculated default number of      *\n*                                   subtasks as the number of CPUs    *\n*                                   plus 1.                           *\n*                                 - Added U, UCB as aliaii for UNIT   *\n*                                   and V as an alias for VOL in      *\n*                                   Batch processing.                 *\n*                                 - Added STATS and MAXTASK keyword   *\n*                                   support.                          *\n*              1998/11/13 SDDA030 - V2.2                              *\n*                                 - Used IKJPARS to parse batch ctl   *\n*                                   cards.                            *\n*              1999/05/27 SDDA030 - V2.6                              *\n*                                 - Used LIFO Stack for our dynamic   *\n*                                   areas.                            *\n*                                 - Get SYSIN DCB storage and OPEN as *\n*                                   required.                         *\n*                                 - CLOSE and free SYSIN DCB at EOF.  *\n*              1999/07/30 SDDA030 - V2.7                              *\n*                                 - Use 24-bit EOD routine when 31-bit*\n*                                   SAM not supported for SYSIN.      *\n*              1999/09/30 SDDA030 - V2.10                             *\n*                                 - Removed ISPF stuff.               *\n*                                 - Set @_Line_Count to generate Hdr0 *\n*                                   only before echo of cmd line.     *\n*                                 - Display keyword descriptions in   *\n*                                   batch when invalid input found.   *\n*              2000/01/19 SDDA030 - V2.11                             *\n*                                 - PARSE keywords OUTFILE, OUTDATA.  *\n*              2001/02/26 SDDA030 - V2.14                             *\n*                                 - Added ISPF subfields S, E, and B. *\n*                                 - Allowed 'SPACE' as the 1st word   *\n*                                   in batch control cards.           *\n*                                 - Moved heading initialization from *\n*                                   B00010.                           *\n*                                 - Added SORT Subfields for VIX,     *\n*                                   FRAG, STORGRP, CHPIDS.            *\n*              2001/11/12 SDDA030 - V2.15                             *\n*                                   Added lists of UCBs, Volsers.     *\n*                                   Added XUCB, XVOL.                 *\n*              2002/03/11 SDDA030 - V2.17                             *\n*                                   Added STORGRP as a selection      *\n*                                   criterion.                        *\n*              2003/10/07 SDDA030 - V2.21                             *\n*                                   Used ASASYMBM to resolve symbols  *\n*                                   within VOL and XVOL.              *\n*                                   Stripped leading spaces from SYSIN*\n*                                   before checking for command name. *\n*              2006/04/21 SDDA030 - V2.24                             *\n*                                 - Calculated default number of      *\n*                                   subtasks as 2 * number of CPUs    *\n*                                   plus 1.                           *\n*                                   Used standardised calling sequence*\n*                                                                     *\n*              ____/__/__ _______                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         STM   R14,R12,12(R13)          Save callers registers\n         LARL  R11,C_Literals           Point to our literals\n         USING (C_Literals,C_Literals_End),R11 Tell the assembler\n\n         L     R12,0(0,R1)              A(@_Dynam)\n         USING @_Dynam,R12              Tell the assembler\n\n*-------------------------------------------------------------------*\n*    Get an area on the stack for our local storage                 *\n*-------------------------------------------------------------------*\n         L     R2,4(0,R1)               A(31-bit stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         SSCSTACK PUSH,                 Get Stack area                 +\n               LEN=@C_Dynam_Length,      this long                     +\n               STACK=(R2)                using this stack\n\n         LR    R3,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LHI   R1,@C_Dynam_Length        Its length\n         LA    R14,0                    Clear source address\n         LA    R15,0                     and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R3                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*-------------------------------------------------------------------*\n         ST    R13,4(0,R1)              Chain\n         ST    R1,8(0,R13)               saveareas\n         LR    R13,R1                   Load dynam base\n         USING @C_Dynam,R13             Assign a base\n         L     R15,@C_Dynam+4           Get A(HSA)\n         LM    R0,R3,20(R15)            Restore callers registers\n\n         L     R15,4(0,R1)              A(31-bit Stack Pointer)\n         ST    R15,@C_31Bit_Stack_Ptr_Ptr Save it\n         L     R15,8(0,R1)              A(24-bit Stack Pointer)\n         ST    R15,@C_24Bit_Stack_Ptr_Ptr Save it\n\n*---------------------------------------------------------------------*\n*   Free any selection lists we may have ...                          *\n*---------------------------------------------------------------------*\n         ICM   R1,B'1111',@_UCB_List_Ptr A(List of UCB Masks)\n         JZ    C00020                   None, skip\n         L     R0,UCB_List_Hdr_Len-UCB_List_Hdr(R1) Length\n         BASR  R2,0\n         USING (*,C00010_End-1),R2\n         STORAGE RELEASE,               Free the storage               +\n               ADDR=(1),                 starting here                 +\n               LENGTH=(0)                for this long\nC00010_End DS  0H\n         DROP  R2\n         XC    @_UCB_List_Ptr,@_UCB_List_Ptr Clear A(UCB List)\n\nC00020   DS    0H\n         ICM   R1,B'1111',@_XUCB_List_Ptr A(List of XUCB Masks)\n         JZ    C00030                   None, skip\n         L     R0,UCB_List_Hdr_Len-UCB_List_Hdr(R1) Length\n         BASR  R2,0\n         USING (*,C00020_End-1),R2\n         STORAGE RELEASE,               Free the storage               +\n               ADDR=(1),                 starting here                 +\n               LENGTH=(0)                for this long\nC00020_End DS  0H\n         DROP  R2\n         XC    @_XUCB_List_Ptr,@_XUCB_List_Ptr Clear A(XUCB List)\n\nC00030   DS    0H\n         ICM   R1,B'1111',@_Vol_List_Ptr A(List of Vol Masks)\n         JZ    C00040                   None, skip\n         L     R0,Vol_List_Hdr_Len-Vol_List_Hdr(R1) Length\n         BASR  R2,0\n         USING (*,C00030_End-1),R2\n         STORAGE RELEASE,               Free the storage               +\n               ADDR=(1),                 starting here                 +\n               LENGTH=(0)                for this long\nC00030_End DS  0H\n         DROP  R2\n         XC    @_Vol_List_Ptr,@_Vol_List_Ptr Clear A(Vol List)\n\nC00040   DS    0H\n         ICM   R1,B'1111',@_XVol_List_Ptr A(List of XVol Masks)\n         JZ    C00050                   None, skip\n         L     R0,Vol_List_Hdr_Len-Vol_List_Hdr(R1) Length\n         BASR  R2,0\n         USING (*,C00040_End-1),R2\n         STORAGE RELEASE,               Free the storage               +\n               ADDR=(1),                 starting here                 +\n               LENGTH=(0)                for this long\nC00040_End DS  0H\n         DROP  R2\n         XC    @_XVOL_List_Ptr,@_XVOL_List_Ptr Clear A(XVol List)\n\nC00050   DS    0H\n         ICM   R1,B'1111',@_STORGRP_List_Ptr A(List of STORGRP Masks)\n         JZ    C00060                   None, skip\n         L     R0,STORGRP_List_Hdr_Len-STORGRP_List_Hdr(R1) Length\n         BASR  R2,0\n         USING (*,C00050_End-1),R2\n         STORAGE RELEASE,               Free the storage               +\n               ADDR=(1),                 starting here                 +\n               LENGTH=(0)                for this long\nC00050_End DS  0H\n         DROP  R2\n         XC    @_STORGRP_List_Ptr,@_STORGRP_List_Ptr Clear A(List)\n\nC00060   DS    0H\n*---------------------------------------------------------------------*\n*   ... and set all our selection criteria so that all volumes will   *\n*  be selected.                                                       *\n*---------------------------------------------------------------------*\n         MVI   @_UNITNM,C' '            Assume all\n         MVC   @_UNITNM+1(L'@_UNITNM-1),@_UNITNM Unitnames\n         NI    @_ATTRPvt,X'FF'-L'@_ATTRPvt Off Mnt Attr flag\n         NI    @_ATTRPub,X'FF'-L'@_ATTRPub Off Mnt Attr flag\n         NI    @_ATTRStg,X'FF'-L'@_ATTRStg Off Mnt Attr flag\n         NI    @_ATTRSMS,X'FF'-L'@_ATTRSMS Off Mnt Attr flag\n\n*---------------------------------------------------------------------*\n*   Set all our output-related flags to their default (off) state     *\n*---------------------------------------------------------------------*\n         NI    @_No_Headings,X'FF'-L'@_No_Headings Off flag\n         NI    @_No_Details,X'FF'-L'@_No_Details   Off flag\n         NI    @_No_Totals,X'FF'-L'@_No_Totals     Off flag\n         NI    @_Statistics,X'FF'-L'@_Statistics   Off flag\n         NI    @_ISPF_SPACE,X'FF'-L'@_ISPF_SPACE Off flag\n         NI    @_ISPF_EDIF,X'FF'-L'@_ISPF_EDIF     Off flag\n         NI    @_ISPF_BRIF,X'FF'-L'@_ISPF_BRIF     Off flag\n         NI    @_ISPF_Explicit,X'FF'-L'@_ISPF_Explicit Off flag\n         NI    @_No_LSPACE,X'FF'-L'@_No_LSPACE     Off flag\n\n*---------------------------------------------------------------------*\n*   Set MaxTasks to default                                           *\n*---------------------------------------------------------------------*\n         AIF   (&Default_SubTask_Count LT 1).Def_SubTask_Count_010\n         LHI   R15,&Default_SubTask_Count Default nbr subtasks\n         AGO   .Def_SubTask_Count_020\n.Def_SubTask_Count_010 ANOP\n         SLR   R15,R15                   Use dynamic subtask count\n.Def_SubTask_Count_020 ANOP\n         STH   R15,@_MaxTasks            Set it\n\n*---------------------------------------------------------------------*\n*   Clear out Sort field name, and default to Ascending sort          *\n*---------------------------------------------------------------------*\n         MVC   @_Sort_Field,=CL8' '\n         MVI   @_Sort_Direction,C'A'\n\n*---------------------------------------------------------------------*\n*   Reset our internal flags                                          *\n*---------------------------------------------------------------------*\n         NI    @C_UNIT_Flag,X'FF'-L'@C_UNIT_Flag\n         NI    @C_XUNIT_Flag,X'FF'-L'@C_XUNIT_Flag\n         NI    @C_VOL_Flag,X'FF'-L'@C_VOL_Flag\n         NI    @C_XVOL_Flag,X'FF'-L'@C_XVOL_Flag\n\n*---------------------------------------------------------------------*\n*   Reset OUTFILE and OUTDATA fields                                  *\n*---------------------------------------------------------------------*\n         MVC   @_OutFile_DDName,=CL8' '\n         NI    @_OutData_DISPLAY,X'FF'-L'@_OutData_DISPLAY\n         NI    @_OutData_CB,X'FF'-L'@_OutData_CB\n         NI    @_OutData_ALL,X'FF'-L'@_OutData_ALL\n\n*-------------------------------------------------------------------*\n*    Initialize @_MaxLWait to the maximum number of seconds to      *\n*   wait for each LSPACE; we determine whether or not we are a      *\n*   foreground user (TSO) to decide on the initialization value.    *\n*-------------------------------------------------------------------*\n         L     R15,PSAAOLD-PSA          A(Our ASCB)\n         ICM   R0,B'1111',ASCBTSB-ASCB(R15) Get A(TSB)\n         JZ    C00060C                  Not a foreground user, skip\n         LHI   R15,&Fore_LSPACE_Wait    Foreground WAIT time\n         J     C00060E                  and skip\nC00060C  DS    0H\n         LHI   R15,&Back_LSPACE_Wait    Background WAIT time\n         J     C00060E                  and skip\nC00060E  DS    0H\n         STH   R15,@_MaxLWait           Update MaxLWait\n\n*---------------------------------------------------------------------*\n*   Free the VolTbl, if it exists                                     *\n*---------------------------------------------------------------------*\n         NI    @_VolTbl_GETMAIN_Err,X'FF'-L'@_VolTbl_GETMAIN_Err\n\n         ICM   R1,B'1111',@_VolTbl_Ptr A(Info Table)\n         JZ    C00070                  None, skip\n         L     R0,VolTbl_Hdr_TbLen-VolTbl(R1) Get its length\n         BASR  R2,0\n         USING (*,C00060_End-1),R2\n         STORAGE RELEASE,               Free the table                 +\n               ADDR=(1),                 starting here                 +\n               LENGTH=(0)                for this long\nC00060_End DS  0H\n         DROP  R2\n         LA    R15,0                    Clear work register\n         ST    R15,@_VolTbl_Ptr         and clear VolTbl pointer\n\nC00070   DS    0H\n*--------------------------------------------------------------------*\n*   Initialize our standard parmlist                                 *\n*--------------------------------------------------------------------*\n         LA    R15,@_Dynam              A(Dynamic area)\n         ST    R15,@C_Parms_Std         Save it\n         L     R15,@C_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)\n         ST    R15,@C_Parms_Std+4       Save it\n         L     R15,@C_24Bit_Stack_Ptr_Ptr A(24-bit Stack Pointer)\n         ST    R15,@C_Parms_Std+8       Save it\n\n*---------------------------------------------------------------------*\n*      Check what kind of processing we have to do                    *\n*---------------------------------------------------------------------*\n         TM    @_TSO_Command,L'@_TSO_Command Is this a TSO command?\n         JNO   C00080                   No, skip\n         TM    @_TSO_Processed,L'@_TSO_Processed Yes, already done?\n         JO    C00780                   Yes, EOF\n         OI    @_TSO_Processed,L'@_TSO_Processed No, end next time\n         L     R1,@_CPPL_Ptr            Get A(CPPL)\n         J     C00160                   and skip\n\nC00080   DS    0H\n*---------------------------------------------------------------------*\n*   This is batch - go read a record from SYSIN, and build a          *\n*   pseudo command buffer that we can pass to IKJPARS                 *\n*---------------------------------------------------------------------*\n         LHI   R15,4095                 Key count to produce\n         STH   R15,@_Line_Count          Hdg0\n\n         ICM   R1,B'1111',@_SYSIN_DCB_Ptr A(SYSIN DCB)\n         JNZ   C00100                   Already here, skip\n\n*---------------------------------------------------------------------*\n*   SYSIN has not been OPENed - get some storage, and OPEN it         *\n*---------------------------------------------------------------------*\n         LHI   R0,C_SYSIN_DCB_Length+C00760_24_Length+7 DCB, 24-bit EOD\n         SRL   R0,3                     DBLWD\n         SLL   R0,3                      multiple\n\n         BASR  R2,0\n         USING (*,C00080_End-1),R2\n         STORAGE OBTAIN,                Get some storage               +\n               LENGTH=(0),               this long                     +\n               LOC=24                    below the line\nC00080_End DS  0H\n         DROP  R2\n\n         SLL   R1,8                     Clean the\n         SRL   R1,8                      address\n         ST    R1,@_SYSIN_DCB_Ptr       Save A(SYSIN DCB)\n\n         L     R3,@_SYSIN_DCB_Ptr       A(DCB)\n         MVC   0(C_SYSIN_DCB_Length,R3),C_SYSIN_DCB\n         MVC   @_SYSIN_DCBE,C_SYSIN_DCBE Move SYSIN DCBE\n         LA    R15,@_SYSIN_DCBE       Point to it\n         ST    R15,DCBDCBE-IHADCB(R3) Update address in DCB\n         MVC   @C_OPEN,C_OPEN           Move OPEN parms\n         OPEN  ((3),INPUT),MODE=31,MF=(E,@C_OPEN)\n\n         TM    @_SYSIN_DCBE+DCBEFLG1-DCBE,DCBEMD31 31-bit SAM OK?\n         JO    C00090                 Yes, skip\n\n*---------------------------------------------------------------------*\n*   31-bit SAM is not supported for SYSIN. This typically happens     *\n*  when it is allocated to the terminal in a TSO session (the I/O     *\n*  seems to be OK, but the EOD handling gets in trouble). So ...      *\n*---------------------------------------------------------------------*\n\n*---------------------------------------------------------------------*\n*  ... close the current DCB ...                                      *\n*---------------------------------------------------------------------*\n         MVC   @C_CLOSE,C_CLOSE       Move close parms\n         L     R3,@_SYSIN_DCB_Ptr     Point to the DCB\n         CLOSE ((3)),MODE=31,MF=(E,@C_CLOSE)  and close it\n\n*---------------------------------------------------------------------*\n*  ... move a normal DCB (without the DCBE) to the 24-bit area ...    *\n*---------------------------------------------------------------------*\n         MVC   0(C_SYSIN24_DCB_Length,R3),C_SYSIN24_DCB Move 24-bit DCB\n\n*---------------------------------------------------------------------*\n*  ... move the 24-bit EOD after it ...                               *\n*---------------------------------------------------------------------*\n         LA    R15,C_SYSIN24_DCB_Length(0,R3) Point past DCB\n         LARL  R14,C00760_24_Start        A(24-bit EOD Routine)\n         MVC   0(C00760_24_Length,R15),0(R14) Move 24-bit EOD\n\n*---------------------------------------------------------------------*\n*  ... and update DCBEODAD to point to the 24-bit EOD routine.        *\n*---------------------------------------------------------------------*\n         O     R15,DCBEODAD-IHADCB(R3)    Set up\n         ST    R15,DCBEODAD-IHADCB(R3)     EODAD\n\n*---------------------------------------------------------------------*\n*  Finally, re-OPEN SYSIN.                                            *\n*---------------------------------------------------------------------*\n         MVC   @C_OPEN,C_OPEN           Move OPEN parms\n         L     R3,@_SYSIN_DCB_Ptr       POINT TO THE DCB\n         OPEN  ((3),INPUT),MODE=31,MF=(E,@C_OPEN) AND OPEN IT\n\nC00090   DS    0H\n         L     R1,@_SYSIN_DCB_Ptr       Restore A(DCB)\n\nC00100   DS    0H\n*---------------------------------------------------------------------*\n*  Read SYSIN, if we can ...                                          *\n*---------------------------------------------------------------------*\n         TM    DCBOFLGS-IHADCB(R1),DCBOFOPN Is it open?\n         JNO   C00760                   No, EOF\n\n         GET   (1)                      Go get it\n\n         ST    R1,@C_SYSIN_Rec_Ptr      and save record address\n\n*---------------------------------------------------------------------*\n*  ... ignoring comments and blank lines ...                          *\n*---------------------------------------------------------------------*\n         L     R15,@C_SYSIN_Rec_Ptr     A(SYSIN record)\n         CLI   0(R15),C'*'              Comment?\n         JE    C00080                   Yes, ignore it\n         CLI   0(R15),C' '              No, blank record?\n         JNE   C00110\n         CLC   1(71,R15),0(R15)\n         JE    C00080                   Blank record, ignore it\n\nC00110   DS    0H\n*---------------------------------------------------------------------*\n*  ... and trim leading and trailing spaces.                          *\n*---------------------------------------------------------------------*\n         AHI   R15,71                   A(Last char)\nC00120   DS    0H\n         CLI   0(R15),C' '              Trailing blank?\n         JNE   C00130                   No, skip\n         BRCT  R15,C00120               Yes, check previous\n\nC00130   DS    0H\n         L     R14,@C_SYSIN_Rec_Ptr     A(Start of input)\n         SLR   R15,R14                  Length of record - 1\n         AHI   R15,1                    Actual length\n\nC00130C  DS    0H\n         CLI   0(R14),C' '              Leading space?\n         JNE   C00130E                  No, OK\n         AHI   R14,1                    Yup, point past it\n         BRCT  R15,C00130C              and check again\n         J     C00080                   Blank record(?), ignore it\n\nC00130E  DS    0H\n*---------------------------------------------------------------------*\n*   If the control card starts with our name (the name that a TSO     *\n*  user would use), skip over it.                                     *\n*---------------------------------------------------------------------*\n         LHI   R0,L'C_PgmName           Length of our name\n         CR    R15,R0                   Should we check for our name?\n         JL    C00150                   No, skip\n         CLC   C_PgmName,0(R14)         Yes, our name first?\n         JNE   C00150                   No, OK\n         CR    R15,R0                   Is that all there is?\n         JE    C00140                   Yes, skip\n         CLI   L'C_PgmName(R14),C' '    Yes, ending with a space?\n         JNE   C00150                   No, skip\n         LHI   R0,L'C_PgmName+1         Length of our name and a space\nC00140   DS    0H\n         AR    R14,R0                   Point past our name\n         SR    R15,R0                   and adjust length\nC00150   DS    0H\n         LA    R0,@C_CBUF_Data+L'C_PgmName+1 A(Target area)\n         LR    R1,R15                   Length\n         MVCL  R0,R14                   Move data to cmd buffer\n         LA    R15,@C_CBUF              A(Start of command buffer\n         SR    R0,R15                   Get the length\n         STH   R0,@C_CBUF_Len           Save it\n\n         MVC   @C_CBUF_Data(L'C_PgmName),C_PgmName  Simulate command\n         MVI   @C_CBUF_Data+L'C_PgmName,C' ' Separator\n         LHI   R15,L'C_PgmName+1         Offset to parms\n         STH   R15,@C_CBUF_Off          Update it\n\n         L     R1,@_Bat_CPPL_Ptr        A(Our CPPL)\n         LA    R15,@C_CBUF              A(our command buffer)\n         ST    R15,CPPLCBUF-CPPL(R1)    Update A(Command buffer)\n\nC00160   DS    0H\n*---------------------------------------------------------------------*\n*   Resolve any symbolic variables in the command buffer. Note that   *\n*   we do this before invoking IKJPARS because IKJPARS will get upset *\n*   with substring'ed symbolic variables (which it thinks are lists). *\n*---------------------------------------------------------------------*\n         L     R15,CPPLCBUF-CPPL(R1)    A(Command Buffer)\n         LH    R14,@C_CBUF_Len-@C_CBUF(R15) Get length\n         AR    R14,R15                  Point past end\n         AHI   R15,L'@C_CBUF_Len+L'@C_CBUF_Off Point to start of cmd\n         LA    R0,C'&&'                 Char to search for\nC00160E  DS    0H\n         SRST  R14,R15                  Do we have an amper?\n         JH    C00160Z                  No amper, skip\n         JO    C00160E                  Keep checking\n\n         ST    R1,@C_CPPL_Ptr           Save A(CPPL)\n\n         XC    @C_SYMBP,@C_SYMBP        Clear ASASUMBP area\n         L     R15,CPPLCBUF-CPPL(R1)    A(Command buffer)\n         LH    R14,@C_CBUF_Len-@C_CBUF(R15) Get Cmd buff length\n         AHI   R14,-L'@C_CBUF_Len-L'@C_CBUF_Off minus CBUF fields\n         ST    R14,@C_SYMBP+SYMBPPATTERNLENGTH-SYMBP Save length\n         AHI   R15,L'@C_CBUF_Len+L'@C_CBUF_Off Point to start\n         ST    R15,@C_SYMBP+SYMBPPATTERN@-SYMBP Save A(Command Buff)\n         LA    R15,@C_CBUF1_Data        A(Target Area)\n         ST    R15,@C_SYMBP+SYMBPTARGET@-SYMBP Save A(Target)\n         LA    R15,L'@C_CBUF1_Data      Target Length)\n         ST    R15,@C_SYMBP_Target_Len  Initialize it\n         LA    R15,@C_SYMBP_Target_Len  A(Target Len field)\n         ST    R15,@C_SYMBP+SYMBPTARGETLENGTH@-SYMBP Save A(Length)\n         LA    R15,@C_SYMBP_RC          A(Return code area)\n         ST    R15,@C_SYMBP+SYMBPRETURNCODE@-SYMBP Save A(Return code)\n\n         MVC   @C_LINKX,C_LINKX         Move LINKX Macro\n         LARL  R2,C00160Z               LINK error return address\n         LINKX EP=ASASYMBM,             LINK to ASASYMBM               +\n               ERRET=(2),                go here if LINK error         +\n               MF=(E,@C_SYMBP),          using these parms             +\n               SF=(E,@C_LINKX)           staying re-entrant\n\n         L     R1,@C_CPPL_Ptr           Restore A(CPPL)\n         ICM   R15,B'1111',@C_SYMBP_RC  Get return code\n         JNZ   C00160Z                  Use original Cmd Buffer\n         L     R15,@C_SYMBP_Target_Len  Get new length\n         AHI   R15,L'@C_CBUF_Len+L'@C_CBUF_Off Adjust it\n         STH   R15,@C_CBUF1_Len         Update new cmd buff len\n         L     R15,CPPLCBUF-CPPL(R1)    A(original CBUF)\n         LH    R15,@C_CBUF_Off-@C_CBUF(R15) Original offset\n         STH   R15,@C_CBUF1_Off         Update it\n         LA    R15,@C_CBUF1             Point to our new CBUF\n         ST    R15,CPPLCBUF-CPPL(R1)    and update CPPL\n\nC00160Z  DS    0H\n*---------------------------------------------------------------------*\n*   Invoke IKJPARS to parse our Command Buffer (either the real one   *\n*   or the one we built). Note that if we not running as a TSO        *\n*   command, we turn off prompting during IKJPARS (otherwise, a user  *\n*   at a TSO terminal who CALLed us could get prompted for unknown    *\n*   parms, which is inconsistent).                                    *\n*---------------------------------------------------------------------*\n         MVC   @C_PPL+PPLUPT-PPL(L'PPLUPT),CPPLUPT-CPPL(R1)\n         MVC   @C_PPL+PPLECT-PPL(L'PPLECT),CPPLECT-CPPL(R1)\n         LA    R15,@C_PECB              A(Parse ECB)\n         ST    R15,@C_PPL+PPLECB-PPL    Save it\n         LA    R15,@C_PANS              A(Parse Answer area)\n         ST    R15,@C_PPL+PPLANS-PPL    Save it\n         MVC   @C_PPL+PPLCBUF-PPL(L'PPLCBUF),CPPLCBUF-CPPL(R1)\n         L     R15,=AL4(C_PCL)          A(Parse Control List)\n         ST    R15,@C_PPL+PPLPCL-PPL    Save it\n         LA    R15,0                    Clear work register\n         ST    R15,@C_PPL+PPLUWA-PPL    No User Work Area\n         ST    R15,@C_PECB              Clear ECB\n         ST    R15,@C_PANS               and Answer area\n\n         TM    @_TSO_Command,L'@_TSO_Command Is this a TSO command?\n         JO    C00170                   Yes, skip\n         L     R15,@C_PPL+PPLUPT-PPL    Get A(UPT)\n         MVC   @C_UPTSWS,UPTSWS-UPT(R15) Save current SWS\n         NI    UPTSWS-UPT(R15),X'FF'-UPTNPRM Off Prompt flag\n\nC00170   DS    0H\n         LA    R1,@C_PPL                A(PPL)\n         CALLTSSR EP=IKJPARS            Parse the command line\n\n         TM    @_TSO_Command,L'@_TSO_Command Is this a TSO command?\n         JO    C00180                   Yes, skip\n         L     R14,@C_PPL+PPLUPT-PPL    Get A(UPT)\n         OC    UPTSWS-UPT(L'UPTSWS,R14),@C_UPTSWS Restore UPTSWS\nC00180   DS    0H\n         LTR   R15,R15                  Did PARSE work?\n         JNZ   C00730                   No, skip\n         L     R1,@C_PANS               Yes, get A(PDL)\n\n*---------------------------------------------------------------------*\n*   Process UNIT/XUNIT keyword                                        *\n*---------------------------------------------------------------------*\n         TM    @C_UNIT_Flag,L'@C_UNIT_Flag Have we processed UNIT?\n         JO    C00180E                  Yes, skip\n         OI    @C_UNIT_Flag,L'@C_UNIT_Flag No, we have now\n\n         TM    C_01SFP+6-IKJPARMD(R1),X'80' Was UNIT entered?\n         JZ    C00180E                  No, skip\n         AHI   R1,C_01SFP-IKJPARMD      Yes, point to PDE\n         J     C00180I                  start processing\nC00180E  DS    0H\n         TM    @C_XUNIT_Flag,L'@C_XUNIT_Flag Have we processed XUNIT?\n         JO    C00240                   Yes, skip\n         OI    @C_XUNIT_Flag,L'@C_XUNIT_Flag No, we have now\n\n         TM    C_02SFP+6-IKJPARMD(R1),X'80' Was XUNIT entered?\n         JZ    C00240                   No, skip\n         AHI   R1,C_02SFP-IKJPARMD      Yes, point to PDE\nC00180I  DS    0H\n         LA    R0,0                     Clear unit count\nC00190   DS    0H\n         AHI   R0,1                     Bump unit count\n         ICM   R1,B'0111',9(R1)         A(Next PDE)\n         JNZ   C00190                   Found one, keep checking\n\n         LR    R4,R0                    Save count\n         MHI   R0,UCB_List_Ent_Length   Times len of 1 entry\n         AHI   R0,UCB_List_Hdr_Length     + length of header\n         BASR  R2,0\n         USING (*,C00190_End-1),R2\n         STORAGE OBTAIN,                Go get some storage            +\n               LENGTH=(0),               this long,                    +\n               LOC=31                    above-the-line\nC00190_End DS  0H\n         DROP  R2\n         ST    R0,UCB_List_Hdr_Len-UCB_List(R1) Save Subpool, length\n         ST    R4,UCB_List_Hdr_Count-UCB_List(R1) Save nbr entries\n         LA    R4,UCB_List_Ent-UCB_List(R1) A(1st entry)\n         TM    @C_XUNIT_Flag,L'@C_XUNIT_Flag Is this XUNIT?\n         JO    C00190E                  Yes, skip\n         ST    R1,@_UCB_List_Ptr        Save it\n         L     R1,@C_PANS               Restore A(PDL)\n         LA    R3,C_01SFP-IKJPARMD(R1)  Point to 1st UNIT PDE\n         J     C00200                   and skip\nC00190E  DS    0H\n         ST    R1,@_XUCB_List_Ptr       Save it\n         L     R1,@C_PANS               Restore A(PDL)\n         LA    R3,C_02SFP-IKJPARMD(R1) Point to 1st XUNIT PDE\n         J     C00200                   and skip\nC00200   DS    0H\n         MVC   UCB_List_Ent_UCB-UCB_List_Ent(L'UCB_List_Ent_UCB,R4),=(L+\n               'UCB_List_Ent_UCB)C'*'   Initialize field\n         L     R15,0(0,R3)              A(UNIT field)\n         LH    R14,4(0,R3)              Get its length\n         STC   R14,UCB_List_Ent_UCB_Len-UCB_List_Ent(R4) Save it\n         AHI   R4,UCB_List_Ent_UCB-UCB_List_Ent  Point to UCB Area\n         AHI   R14,-1                   Get EX length\n         EX    R14,C2EX1                Move UCB\n         AHI   R4,-(UCB_List_Ent_UCB-UCB_List_Ent) Back to entry\n         MVC   UCB_List_Ent_Mask-UCB_List_Ent(L'UCB_List_Ent_Mask,R4),U+\n               CB_List_Ent_UCB-UCB_List_Ent(R4)\n         TR    UCB_List_Ent_UCB-UCB_List_Ent(L'UCB_List_Ent_UCB,R4),C_T+\n               rTbl                     Xlate (Wildcards = X'FF'\n         TR    UCB_List_Ent_Mask-UCB_List_Ent(L'UCB_List_Ent_Mask,R4),C+\n               _TrTbl1                  Xlate (Wildcards = X'FF')\n*                                              Non-Wildcards = X'00')\n         AHI   R4,UCB_List_Ent_Length   A(Next entry)\n         ICM   R3,B'0111',9(R3)         A(Next PDE)\n         JNZ   C00200                   Got one, save it\n         J     C00180E                  Process next UNIT-type keywd\n\nC00240   DS    0H\n*---------------------------------------------------------------------*\n*   Process VOLUME/XVOLUME keyword                                    *\n*---------------------------------------------------------------------*\n         TM    @C_VOL_Flag,L'@C_VOL_Flag Have we processed VOL?\n         JO    C00240E                  Yes, skip\n         OI    @C_VOL_Flag,L'@C_Vol_Flag No, we have now\n\n         TM    C_03SFP+6-IKJPARMD(R1),X'80' Was VOL entered?\n         JZ    C00240E                  No, skip\n         AHI   R1,C_03SFP-IKJPARMD      Yes, point to PDE\n         J     C00240I                  start processing\nC00240E  DS    0H\n         TM    @C_XVOL_Flag,L'@C_XVOL_Flag Have we processed XVOL?\n         JO    C00300                   Yes, skip\n         OI    @C_XVOL_Flag,L'@C_XVol_Flag No, we have now\n\n         TM    C_04SFP+6-IKJPARMD(R1),X'80' Was XVOL entered?\n         JZ    C00300                   No, skip\n         AHI   R1,C_04SFP-IKJPARMD      Yes, point to PDE\nC00240I  DS    0H\n         LA    R0,0                     Clear unit count\nC00250   DS    0H\n         AHI   R0,1                     Bump vol count\n         ICM   R1,B'0111',9(R1)         A(Next PDE)\n         JNZ   C00250                   Found one, keep checking\n\n         LR    R4,R0                    Save count\n         MHI   R0,Vol_List_Ent_Length   Times length of 1 entry\n         AHI   R0,Vol_List_Hdr_Length     + length of header\n         BASR  R2,0\n         USING (*,C00250_End-1),R2\n         STORAGE OBTAIN,                Go get some storage            +\n               LENGTH=(0),               this long,                    +\n               LOC=31                    above-the-line\nC00250_End DS  0H\n         DROP  R2\n         ST    R0,Vol_List_Hdr_Len-Vol_List(R1) Save Subpool, length\n         ST    R4,Vol_List_Hdr_Count-Vol_List(R1) Save nbr entries\n         LA    R4,Vol_List_Ent-Vol_List(R1) A(1st entry)\n         TM    @C_XVOL_Flag,L'@C_XVOL_Flag Are we doing XVOL?\n         JO    C00250E                  Yes, skip\n         ST    R1,@_VOL_List_Ptr        Save it\n         L     R1,@C_PANS               Restore A(PDL)\n         LA    R3,C_03SFP-IKJPARMD(R1)  Point to 1st VOL PDE\n         J     C00260                   and skip\nC00250E  DS    0H\n         ST    R1,@_XVOL_List_Ptr       Save it\n         L     R1,@C_PANS               Restore A(PDL)\n         LA    R3,C_04SFP-IKJPARMD(R1)  Point to 1st XVOL PDE\n         J     C00260                   and skip\nC00260   DS    0H\n         MVC   Vol_List_Ent_Vol-Vol_List_Ent(L'Vol_List_Ent_Vol,R4),=(L+\n               'Vol_List_Ent_Vol)C'*'   Initialize field\n         L     R15,0(0,R3)              A(Vol field)\n         LH    R14,4(0,R3)              Get its length\n         AHI   R14,-1                   Get EX length\n         EX    R14,C2EX1                Move Vol\n         MVC   Vol_List_Ent_Mask-Vol_List_Ent(L'Vol_List_Ent_Mask,R4),V+\n               ol_List_Ent_Vol-Vol_List_Ent(R4)\n         TR    Vol_List_Ent_Vol-Vol_List_Ent(L'Vol_List_Ent_Vol,R4),C_T+\n               rTbl                     Xlate (Wildcards = X'FF'\n         TR    Vol_List_Ent_Mask-Vol_List_Ent(L'Vol_List_Ent_Mask,R4),C+\n               _TrTbl1                  Xlate (Wildcards = X'FF')\n*                                              Non-Wildcards = X'00')\n         AHI   R4,Vol_List_Ent_Length   A(Next entry)\n         ICM   R3,B'0111',9(R3)         A(Next PDE)\n         JNZ   C00260                   Got one, save it\n         J     C00240                   Process next VOL-type keyword\n\nC00300   DS    0H\n*---------------------------------------------------------------------*\n*   Process NAME keyword                                              *\n*---------------------------------------------------------------------*\n         TM    C_05SFP+6-IKJPARMD(R1),X'80' Was Name entered?\n         JZ    C00310                   No, skip\n         L     R15,C_05SFP-IKJPARMD(R1)  Yes, point to it\n         LH    R14,C_05SFP+4-IKJPARMD(R1) Get its length\n         AHI   R14,-1                   Get EX length\n         EX    R14,C2EX3                Move Unitname\n\nC00310   DS    0H\n*---------------------------------------------------------------------*\n*   Process ATTRIBUTE keyword                                         *\n*---------------------------------------------------------------------*\n         LH    R15,C_06SFP-IKJPARMD(R1) Get Kwd nbr for ATTR\n         LTR   R15,R15                  Anything?\n         JZ    C00380                   None, skip\n         L     R14,=AL4(C_PCL)          Yes, A(Parse Control List)\n         AH    R14,C_06SF-C_PCL(R14)    A(IKJSUBF entry)\n         AH    R14,2(0,R14)             A(1st IKJNAME entry)\nC00320   DS    0H\n         TM    0(R14),X'60'             Is this an IKJNAME PCE?\n         JNO   C00380                   No, must have reached the end\n         CHI   R15,1                    Is this our entry?\n         JE    C00330                   Yes, check it out\n         AH    R14,2(0,R14)             No, bump to next PCE\n         BRCT  R15,C00320               and check it out\n         J     C00380                   Unknown, ignore it\nC00330   DS    0H\n         CLC   =C'STORAGE',5(R14)       STG?\n         JE    C00340                   Yes, skip\n         CLC   =C'PRIVATE',5(R14)       No, PRIVATE?\n         JE    C00350                   Yes, skip\n         CLC   =C'PUBLIC',5(R14)        No, PUBLIC?\n         JE    C00360                   Yes, skip\n         CLC   =C'SMS',5(R14)           No, SMS?\n         JE    C00370                   Yes, skip\n         J     C00380                   Unknown, ignore it\nC00340   DS    0H\n         OI    @_ATTRStg,L'@_ATTRStg    Set flag\n         J     C00380\nC00350   DS    0H\n         OI    @_ATTRPvt,L'@_ATTRPvt    Set flag\n         J     C00380\nC00360   DS    0H\n         OI    @_ATTRPub,L'@_ATTRPub    Set flag\n         J     C00380\nC00370   DS    0H\n         OI    @_ATTRSMS,L'@_ATTRSMS    Set flag\n         J     C00380\n\nC00380   DS    0H\n*---------------------------------------------------------------------*\n*   Process STORGRP keyword                                           *\n*---------------------------------------------------------------------*\n         TM    C_07SFP+6-IKJPARMD(R1),X'80' Was STORGRP entered?\n         JZ    C00430                   No, skip\n         LA    R0,0                     Yes, clear STORGRP count\n         AHI   R1,C_07SFP-IKJPARMD      and point to PDE\nC00390   DS    0H\n         AHI   R0,1                     Bump STORGRP count\n         ICM   R1,B'0111',9(R1)         A(Next PDE)\n         JNZ   C00390                   Found one, keep checking\n\n         LR    R4,R0                    Save count\n         MHI   R0,STORGRP_List_Ent_Length Times length of 1 entry\n         AHI   R0,STORGRP_List_Hdr_Length  + length of header\n         BASR  R2,0\n         USING (*,C00390_End-1),R2\n         STORAGE OBTAIN,                Go get some storage            +\n               LENGTH=(0),               this long,                    +\n               LOC=31                    above-the-line\nC00390_End DS  0H\n         DROP  R2\n         ST    R1,@_STORGRP_List_Ptr    Save it\n         ST    R0,STORGRP_List_Hdr_Len-STORGRP_List(R1) Save Subp, len\n         ST    R4,STORGRP_List_Hdr_Count-STORGRP_List(R1) Save nbr ents\n         LA    R4,STORGRP_List_Ent-STORGRP_List(R1) A(1st entry)\n         L     R1,@C_PANS               Restore A(PDL)\n         LA    R3,C_07SFP-IKJPARMD(R1) and point to 1st STORGRP PDE\nC00400   DS    0H\n         L     R15,0(0,R3)              A(StorGrp)\n         AH    R15,4(0,R3)              A(Byte past end)\n         AHI   R15,-1                   Point to last byte\n         CLI   0(R15),C'*'              Trailing asterisk?\n         JNE   C00410                   No, skip\n         MVI   STORGRP_List_Ent_STORGRP-STORGRP_List_Ent(R4),C'*'\n         J     C00420\nC00410   DS    0H\n         MVI   STORGRP_List_Ent_STORGRP-STORGRP_List_Ent(R4),X'00'\n         J     C00420\nC00420   DS    0H\n         MVC   STORGRP_List_Ent_STORGRP+1-STORGRP_List_Ent(L'STORGRP_Li+\n               st_Ent_STORGRP-1,R4),STORGRP_List_Ent_STORGRP-STORGRP_Li+\n               st_Ent(R4)\n         L     R15,0(0,R3)              A(StorGrp)\n         LH    R14,4(0,R3)              Get its length\n         AHI   R14,-1                   Get EX length\n         EX    R14,C2EX1                Move StorGrp\n         MVC   STORGRP_List_Ent_Mask-STORGRP_List_Ent(L'STORGRP_List_En+\n               t_Mask,R4),STORGRP_List_Ent_STORGRP-STORGRP_List_Ent(R4)\n         TR    STORGRP_List_Ent_STORGRP-STORGRP_List_Ent(L'STORGRP_List+\n               _Ent_STORGRP,R4),C_TrTbl Xlate Wildcards = X'FF'\n         TR    STORGRP_List_Ent_Mask-STORGRP_List_Ent(L'STORGRP_List_En+\n               t_Mask,R4),C_TrTbl1      Xlate (Wildcards = X'FF'\n*                                              Non-Wildcards = X'00')\n         AHI   R4,STORGRP_List_Ent_Length A(Next entry)\n         ICM   R3,B'0111',9(R3)         A(Next PDE)\n         JNZ   C00400                   Got one, save it\n\nC00430   DS    0H\n*---------------------------------------------------------------------*\n*   Process SORT keyword                                              *\n*---------------------------------------------------------------------*\n         LH    R15,C_09SFP-IKJPARMD(R1) Get Kwd nbr for Sort Field\n         LTR   R15,R15                  Anything?\n         JZ    C00480                   None, skip\n         L     R14,=AL4(C_PCL)          Yes, A(Parse Control List)\n         AH    R14,C_09SF-C_PCL(R14)    A(IKJSUBF entry)\n         AH    R14,2(0,R14)             A(1st IKJNAME entry)\nC00440   DS    0H\n         TM    0(R14),X'60'             Is this an IKJNAME PCE?\n         JNO   C00480                   No, must have reached the end\n         CHI   R15,1                    Is this our entry?\n         JE    C00450                   Yes, check it out\n         AH    R14,2(0,R14)             No, bump to next PCE\n         BRCT  R15,C00440               and check it out\n         J     C00480                   Unknown, ignore it\nC00450   DS    0H\n         IC    R15,4(0,R14)             Get EX length of Keyword\n         EX    R15,C_Save_Sort_Field    Save sort field name\n\n*---------------------------------------------------------------------*\n*   Process DESCENDING keyword                                        *\n*---------------------------------------------------------------------*\n         CLI   C_10K+1-IKJPARMD(R1),2 DESCENDING entered?\n         JNE   C00480                   No, skip\n         MVI   @_Sort_Direction,C'D'    Yes, say so\n\nC00480   DS    0H\n*---------------------------------------------------------------------*\n*   Process MAXTASKS keyword                                          *\n*---------------------------------------------------------------------*\n         TM    C_11SFP+6-IKJPARMD(R1),X'80' Was Maxtasks entered?\n         JZ    C00490                   No, skip\n         L     R15,C_11SFP-IKJPARMD(R1) Yes, point to it\n         L     R15,0(0,R15)             Get the value\n         AIF   (&Max_SubTask_Count LT 1).Max_SubTask_Count_010\n         CHI   R15,&Max_SubTask_Count   Is it > max?\n         JNH   C00480C                  No, OK\n         LHI   R15,&Max_SubTask_Count   Yes, use max\nC00480C  DS    0H\n.Max_SubTask_Count_010 ANOP\n         LTR   R15,R15                  Is it too small?\n         JNP   C00490                   Yes, ignore it\n         STH   R15,@_MaxTasks           Save it\n\nC00490   DS    0H\n*---------------------------------------------------------------------*\n*   Process OUTFILE keyword                                           *\n*---------------------------------------------------------------------*\n         TM    C_20SFP+6-IKJPARMD(R1),X'80' Was OUTFILE entered?\n         JZ    C00550                   No, skip\n         L     R15,C_20SFP-IKJPARMD(R1) Yes, point to it\n         LH    R14,C_20SFP+4-IKJPARMD(R1) Get its length\n         AHI   R14,-1                   Get EX length\n         EX    R14,C2EX4                Move DDName\n\n*---------------------------------------------------------------------*\n*   Process OUTDATA keyword                                           *\n*---------------------------------------------------------------------*\n         LH    R15,C_21SFP-IKJPARMD(R1) Get Kwd nbr for OUTDATA\n         LTR   R15,R15                  Anything?\n         JZ    C00550                   None, skip\n         L     R14,=AL4(C_PCL)          Yes, A(Parse Control List)\n         AH    R14,C_21SF-C_PCL(R14)    A(IKJSUBF entry)\n         AH    R14,2(0,R14)             A(1st IKJNAME entry)\nC00500   DS    0H\n         TM    0(R14),X'60'             Is this an IKJNAME PCE?\n         JNO   C00550                   No, must have reached the end\n         CHI   R15,1                    Is this our entry?\n         JE    C00510                   Yes, check it out\n         AH    R14,2(0,R14)             No, bump to next PCE\n         BRCT  R15,C00500               and check it out\n         J     C00550                   Unknown, ignore it\nC00510   DS    0H\n         CLC   =C'DISPLAY',5(R14)       DISPLAY?\n         JE    C00520                   Yes, skip\n         CLC   =C'CB',5(R14)            No, CB?\n         JE    C00530                   Yes, skip\n         CLC   =C'ALL',5(R14)           No, ALL?\n         JE    C00540                   Yes, skip\n         J     C00550                   Unknown, ignore it\nC00520   DS    0H\n         OI    @_OutData_DISPLAY,L'@_OutData_DISPLAY   Set flag\n         J     C00550\nC00530   DS    0H\n         OI    @_OutData_CB,L'@_OutData_CB   Set flag\n         J     C00550\nC00540   DS    0H\n         OI    @_OutData_ALL,L'@_OutData_ALL   Set flag\n         J     C00550\n\nC00550   DS    0H\n*---------------------------------------------------------------------*\n*   Process NOHEADINGS keyword                                        *\n*---------------------------------------------------------------------*\n         CLI   C_13K+1-IKJPARMD(R1),0   Was NOHEADINGS entered?\n         JE    C00560                   No, skip\n         OI    @_No_Headings,L'@_No_Headings Yes, set flag\n\nC00560   DS    0H\n*---------------------------------------------------------------------*\n*   Process NODETAILS keyword                                         *\n*---------------------------------------------------------------------*\n         CLI   C_14K+1-IKJPARMD(R1),0   Was NODETAILS entered?\n         JE    C00570                   No, skip\n         OI    @_No_Details,L'@_No_Details Yes, set our flag\n\nC00570   DS    0H\n*---------------------------------------------------------------------*\n*   Process NOTOTALS keyword                                          *\n*---------------------------------------------------------------------*\n         CLI   C_15K+1-IKJPARMD(R1),0   Was NOTOTALS entered?\n         JE    C00580                   No, skip\n         OI    @_No_Totals,L'@_No_Totals Yes, set our flag\n\nC00580   DS    0H\n*---------------------------------------------------------------------*\n*   Process STATISTICS keyword                                        *\n*---------------------------------------------------------------------*\n         CLI   C_17K+1-IKJPARMD(R1),0     Was STATISTICS entered?\n         JE    C00590                   No, skip\n         OI    @_Statistics,L'@_Statistics Yes, set our flag\n\nC00590   DS    0H\n*---------------------------------------------------------------------*\n*   Process ISPF keyword                                              *\n*---------------------------------------------------------------------*\n         LH    R15,C_12SFP-IKJPARMD(R1) Get Kwd nbr for ISPF\n         LTR   R15,R15                  Anything?\n         JZ    C00650                   No, skip\n         OI    @_ISPF_Explicit,L'@_ISPF_Explicit Yes, set our flag\n         L     R14,=AL4(C_PCL)          A(Parse Control List)\n         AH    R14,C_12SF-C_PCL(R14)    A(IKJSUBF entry)\n         AH    R14,2(0,R14)             A(1st IKJNAME entry)\nC00600   DS    0H\n         TM    0(R14),X'60'             Is this an IKJNAME PCE?\n         JNO   C00650                   No, must have reached the end\n         CHI   R15,1                    Is this our entry?\n         JE    C00610                   Yes, check it out\n         AH    R14,2(0,R14)             No, bump to next PCE\n         BRCT  R15,C00600               and check it out\n         J     C00650                   Unknown, ignore it\nC00610   DS    0H\n         CLC   =C'EDIF',5(R14)          No, EDIF?\n         JE    C00630                   Yes, skip\n         CLC   =C'BRIF',5(R14)          No, BRIF?\n         JE    C00640                   Yes, skip\n         CLC   =C'SPACE',5(R14)         Table display?\n         JE    C00620                   Yes, skip\n         CLC   =C'NONE',5(R14)          No ISPF?\n         JNE   C00650                   No, ignore it\n         J     C00650                   Unknown, ignore it\nC00620   DS    0H\n         OI    @_ISPF_SPACE,L'@_ISPF_SPACE Yes, set our flag\n         J     C00650\nC00630   DS    0H\n         OI    @_ISPF_EDIF,L'@_ISPF_EDIF EDIF output\n         J     C00650\nC00640   DS    0H\n         OI    @_ISPF_BRIF,L'@_ISPF_BRIF BRIF output\n         J     C00650\n\nC00650   DS    0H\n*---------------------------------------------------------------------*\n*   Check the NOECHO keyword                                          *\n*---------------------------------------------------------------------*\n         CLI   C_16K+1-IKJPARMD(R1),0   Was NOECHO entered?\n         JE    C00660                   No, skip\n         OI    @C_NoEcho,L'@C_NoEcho    Yes, set our flag\n\nC00660   DS    0H\n*---------------------------------------------------------------------*\n*   Process NOLSPACE keyword                                          *\n*---------------------------------------------------------------------*\n         CLI   C_18K+1-IKJPARMD(R1),0   Was NOLSPACE entered?\n         JE    C00665                   No, skip\n         OI    @_No_LSPACE,L'@_No_LSPACE Yes, set flag\n\nC00665   DS    0H\n*---------------------------------------------------------------------*\n*   Process LINESIZE Keyword                                          *\n*---------------------------------------------------------------------*\n         TM    C_22SFP+6-IKJPARMD(R1),X'80' Was LINESIZE entered?\n         JZ    C00665I                  No, skip\n         L     R15,C_22SFP-IKJPARMD(R1) Yes, point to it\n         LH    R14,C_22SFP+4-IKJPARMD(R1) Get its length\n         CHI   R14,3                    Could it be max?\n         JNE   C00665E                  No, skip\n         CLC   =C'MAX',0(R15)           Yes, is it?\n         JNE   C00665E                  No, skip\n         LHI   R0,-1                    Yes, flag it\n         J     C00665G                  and skip\nC00665E  DS    0H\n         CLI   0(R15),C'0'              Numeric?\n         JL    C00665I                  No, ignore it\n         CLI   0(R15),C'9'              Maybe, check again\n         JH    C00665I                  Not numeric, ignore it\n         AHI   R15,1                    Bump pointer\n         BRCT  R14,C00665E              and continue\n\n         L     R15,C_22SFP-IKJPARMD(R1) Point to number\n         LH    R14,C_22SFP+4-IKJPARMD(R1) Get its length\n         AHI   R14,-1                   Get EX length\n         EX    R14,C2EX5                Pack line length\n         CVB   R0,@C_DBLWD              Binarize it\nC00665G  DS    0H\n         STH   R0,@_LineSize            Save it\nC00665I  DS    0H\n\nC00667   DS    0H\n*---------------------------------------------------------------------*\n*   Process MAXLWAIT Keyword                                          *\n*---------------------------------------------------------------------*\n         TM    C_23SFP+6-IKJPARMD(R1),X'80' Was MAXLWAIT entered?\n         JZ    C00667I                  No, skip\n         L     R15,C_23SFP-IKJPARMD(R1) Yes, point to it\n         LH    R14,C_23SFP+4-IKJPARMD(R1) Get its length\n         AHI   R14,-1                   Get EX length\n         EX    R14,C2EX5                Pack line length\n         CVB   R0,@C_DBLWD              Binarize it\n         STH   R0,@_MaxLWait            Save it\nC00667I  DS    0H\n\nC00670   DS    0H\n*---------------------------------------------------------------------*\n*   We have finished with the command buffer, so free up the          *\n*  storage used by IKJPARS                                            *\n*---------------------------------------------------------------------*\n         IKJRLSA @C_PANS                Free IKJPARS storage\n\n         AIF   (NOT &ISPF_by_Default).ISPF_by_Default_010\n*---------------------------------------------------------------------*\n*   We want ISPF displays by default; if the ISPF keyword was         *\n*  not specified, set up our flags as if it were.                     *\n*---------------------------------------------------------------------*\n         TM    @_ISPF_Explicit,L'@_ISPF_Explicit ISPF Keyword there?\n         JO    C00700                   Yes, don't do anything\n\n         AIF   ('&ISPF_Default_Type' EQ '').ISPF_Default_Type_005\n         CLC   =C'SPACE',=C'&ISPF_Default_Type' Default of SPACE?\n         JNE   C00680                   No, skip\n         OI    @_ISPF_SPACE,L'@_ISPF_SPACE Yes, set our flag\n         J     C00700                   and skip\nC00680   DS    0H\n         CLC   =C'EDIF',=C'&ISPF_Default_Type' Default of EDIF?\n         JNE   C00690                   No, skip\n         OI    @_ISPF_EDIF,L'@_ISPF_EDIF Yes, set our flag\n         J     C00700                   and skip\nC00690   DS    0H\n         CLC   =C'BRIF',=C'&ISPF_Default_Type' Default of BRIF?\n         JNE   C00700                   No, unknown\n         OI    @_ISPF_BRIF,L'@_ISPF_BRIF Yes, set our flag\n         J     C00700                   and skip\n.ISPF_Default_Type_005 ANOP\n\nC00700   DS    0H\n.ISPF_by_Default_010 ANOP\n*---------------------------------------------------------------------*\n*   If we are producing headings, put them in the table               *\n*---------------------------------------------------------------------*\n         TM    @_No_Headings,L'@_No_Headings Do we want headings?\n         JO    C00710                   No, skip\n\n         LA    R1,@C_Parms              A(Parm list)\n         BRAS  R14,W00010               Get A(Free entry in VolTbl)\n         LTR   R15,R15                  Did it work?\n         JNZ   C00710                   No, skip headings\n\n         LR    R9,R1                    Get A(Free entry)\n         USING VolTbl_Ent,R9\n\n         OI    VolTbl_Ent_Heading_Line1,L'VolTbl_Ent_Heading_Line1\n         LA    R14,C_Hdg0               A(Heading line)\n         LHI   R15,C_Hdg0_Len           Length of heading\n         O     R15,=XL4'40000000'       Pad char of blank\n         LA    R0,VolTbl_Ent_Display    A(Target)\n         LHI   R1,VolTbl_Ent_Display_Len Length of target\n         MVCL  R0,R14                   Move heading\n         OI    VolTbl_Ent_Processed,L'VolTbl_Ent_Processed Mark as done\n         OI    VolTbl_Ent_ECB,X'40'     POST as complete\n\n         MVC   @C_Time,C_Time           Move L-Form of macro\n         TIME  DEC,                     Get time                       +\n               @C_TIMEArea,              and return it here            +\n               LINKAGE=SYSTEM,           don't use the SVC             +\n               DATETYPE=YYYYMMDD,        format of returned data       +\n               MF=(E,@C_TIME)            addr of macro list\n         L     R0,@C_TIMEArea           Get the time\n         SRL   R0,4                     Shift out hundredths\n         ST    R0,@C_TimeArea           Save it\n         OI    @C_TimeArea+3,X'0F'      OR in a sign\n         MVC   VolTbl_Ent_Display+11(10),=X'402120207A20207A2020'\n         ED    VolTbl_Ent_Display+11(10),@C_TimeArea Edit time\n         L     R15,@C_TimeArea+8        Get Date (yyyymmdd)\n         LA    R14,0                    Clear work register\n         SLDL  R14,4                    Make room for sign\n         STM   R14,R15,@C_TimeArea      Save it\n         OI    @C_TimeArea+7,X'0F'      OR in a sign\n         MVC   VolTbl_Ent_Display(12),=X'402120202020612020612020'\n         ED    VolTbl_Ent_Display(12),@C_TimeArea+3 Edit date\n\n         LA    R1,@C_Parms              A(Parm list)\n         BRAS  R14,W00010               Get A(Free entry in VolTbl)\n         LTR   R15,R15                  Did it work?\n         JNZ   C00710                   No, skip headings\n\n         LR    R9,R1                    Get A(Free entry)\n\n         OI    VolTbl_Ent_Heading_Line,L'VolTbl_Ent_Heading_Line Flag\n         LA    R14,C_Hdg1               A(Heading line)\n         LHI   R15,C_Hdg1_Len           Length of heading\n         O     R15,=XL4'40000000'       Pad char of blank\n         LA    R0,VolTbl_Ent_Display    A(Target)\n         LHI   R1,VolTbl_Ent_Display_Len Length of target\n         MVCL  R0,R14                   Move heading\n         OI    VolTbl_Ent_Processed,L'VolTbl_Ent_Processed Mark as done\n         OI    VolTbl_Ent_ECB,X'40'     POST as complete\n\n         LA    R1,@C_Parms              A(Parm list)\n         BRAS  R14,W00010               Get A(Free entry in VolTbl)\n         LTR   R15,R15                  Did it work?\n         JNZ   C00710                   No, skip headings\n\n         LR    R9,R1                    Get A(Free entry)\n\n         OI    VolTbl_Ent_Heading_Line,L'VolTbl_Ent_Heading_Line Flag\n         LA    R14,C_Hdg2               A(Heading line)\n         LHI   R15,C_Hdg2_Len           Length of heading\n         O     R15,=XL4'40000000'       Pad char of blank\n         LA    R0,VolTbl_Ent_Display    A(Target)\n         LHI   R1,VolTbl_Ent_Display_Len Length of target\n         MVCL  R0,R14                   Move heading\n         OI    VolTbl_Ent_Processed,L'VolTbl_Ent_Processed Mark as done\n         OI    VolTbl_Ent_ECB,X'40'     POST as complete\n\n         LA    R1,@C_Parms              A(Parm list)\n         BRAS  R14,W00010               Get A(Free entry in VolTbl)\n         LTR   R15,R15                  Did it work?\n         JNZ   C00710                   No, skip headings\n\n         LR    R9,R1                    Get A(Free entry)\n\n         OI    VolTbl_Ent_Heading_Line,L'VolTbl_Ent_Heading_Line Flag\n         LA    R14,C_Hdg3               A(Heading line)\n         LHI   R15,C_Hdg3_Len           Length of heading\n         O     R15,=XL4'40000000'       Pad char of blank\n         LA    R0,VolTbl_Ent_Display    A(Target)\n         LHI   R1,VolTbl_Ent_Display_Len Length of target\n         MVCL  R0,R14                   Move heading\n         OI    VolTbl_Ent_Processed,L'VolTbl_Ent_Processed Mark as done\n         OI    VolTbl_Ent_ECB,X'40'     POST as complete\n\nC00710   DS    0H\n*---------------------------------------------------------------------*\n*   If we are running in Batch, and NOECHO was not specified, go      *\n*  print an image of the input record                                 *\n*---------------------------------------------------------------------*\n         TM    @_TSO_Command,L'@_TSO_Command Is this a TSO command?\n         JO    C00720                   Yes, skip\n\n         TM    @C_NoEcho,L'@C_NoEcho    Was NOECHO specified?\n         JNE   C00720                   Yes, skip\n\n         L     R15,@C_SYSIN_Rec_Ptr     A(Our data area)\n         ST    R15,@C_Parms_Y00010      Save it\n         L     R15,@_SYSIN_DCB_Ptr      Point to the DCB\n         LH    R15,DCBLRECL-IHADCB(R15) Get length\n         ST    R15,@C_Parms_Y00010+4    Save it\n\n         LA    R1,@C_Parms              A(Parm list)\n         BRAS  R14,Y00010               Output it to SYSPRINT\n\nC00720   DS    0H\n         LA    R15,0                    Clear return code\n         J     C90010                   and exit\n\nC00730   DS    0H\n         TM    @_TSO_Command,L'@_TSO_Command Is this a TSO command?\n         JZ    C00740                   No, skip\n         LA    R15,4                    PARSE failure\n         J     C90010                    and exit\n\nC00740   DS    0H\n         L     R15,@C_SYSIN_Rec_Ptr     A(Our data area)\n         ST    R15,@C_Parms_Y00010      Save it\n         L     R15,@_SYSIN_DCB_Ptr      Point to the DCB\n         LH    R15,DCBLRECL-IHADCB(R15) Get length\n         ST    R15,@C_Parms_Y00010+4    Save it\n\n         LA    R1,@C_Parms              A(Parm list)\n         BRAS  R14,Y00010               Output to SYSPRINT\n\n         LHI   R15,L'VolTbl_Ent_ErrMsg  Length of 1 message\n         ST    R15,@C_Parms_Y00010+4    Save it for Y00010\n         LA    R4,C_ErrMsgs             Point to 1st err msg\n         LHI   R3,C_ErrMsg_Count        Get the number of messages\nC00750   DS    0H\n         ST    R4,@C_Parms_Y00010       Save A(Error message)\n         LA    R1,@C_Parms              A(Parm list)\n         BRAS  R14,Y00010               Output to SYSPRINT\n         AHI   R4,L'VolTbl_Ent_ErrMsg   A(Next message)\n         BRCT  R3,C00750                and issue it\n\n         J     C00080                   Get another input record\n\n\n*-------------------------------------------------------------------*\n*    The following is the EOD exit when 31-bit SAM is not supported *\n*   for SYSIN. This code is moved to 24-bit storage, and is invoked *\n*   by SYSIN EOD. All it does is branch to our 'real' EOD routine,  *\n*   in 31-bit mode.                                                 *\n*-------------------------------------------------------------------*\n         PUSH  USING                  Save current USINGs\n         DROP  ,                      No USINGs now\n\nC00760_24_Start DS 0H                Start of 24-bit EOD Routine\n         BASR  R15,0                  Load up our base\n         USING *,R15                  Tell the Assembler\n         L     R15,C00760_24_EOD      Get real EODAD\n         BSM   0,R15                  and go do it (in 31-bit mode)\nC00760_24_EOD DC AL4(X'80000000'+C00760) Real EODAD\nC00760_24_Length EQU *-C00760_24_Start Length of 24-bit EOD Routine\n\n         DROP  R15                    Free up our base reg\n         POP   USING                  Restore USING environment\n\n\nC00760   DS    0H\n         TM    @_TSO_Command,L'@_TSO_Command Is this a TSO command?\n         JO    C00780                   Yes, skip\n         ICM   R1,B'1111',@_SYSIN_DCB_Ptr A(SYSIN DCB)\n         JZ    C00780                   None, skip\n         TM    DCBOFLGS-IHADCB(R1),DCBOFOPN Is it open?\n         JNO   C00770                   No, skip\n         MVC   @C_CLOSE,C_CLOSE         Yes, move CLOSE parms\n         LR    R3,R1                    Set up DCB pointer\n         CLOSE ((3)),MODE=31,MF=(E,@C_CLOSE)  and close it\nC00770   DS    0H\n         LHI   R0,C_SYSIN_DCB_Length+C00760_24_Length+7 DCB, 24-bit EOD\n         SRL   R0,3                     DBLWD\n         SLL   R0,3                      multiple\n\n         L     R1,@_SYSIN_DCB_Ptr       A(SYSIN DCB area)\n\n         BASR  R2,0\n         USING (*,C00770_End-1),R2\n         STORAGE RELEASE,               Free the DCB storage           +\n               ADDR=(1),                 starting here                 +\n               LENGTH=(0)                this long\nC00770_End DS  0H\n         DROP  R2\n\n         LA    R15,0                    Clear work register\n         ST    R15,@_SYSIN_DCB_Ptr      No more DCB area\nC00780   DS    0H\n         LA    R15,4                    Set return code\n         J     C90010                    and exit\n\n\nC90010   DS    0H\n*-------------------------------------------------------------------*\n*    Free up our local storage ...                                  *\n*-------------------------------------------------------------------*\n         LR    R3,R15                 Save return code\n\n         LA    R1,@C_Dynam              A(Local storage)\n         L     R2,@C_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         L     R13,4(0,R13)             Rescue A(HSA)\n\n         SSCSTACK POP,                  Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=(R2)                on this stack\n\n         LR    R15,R3                   Restore return code\n\n*-------------------------------------------------------------------*\n*    ... and return to caller                                       *\n*-------------------------------------------------------------------*\n         L     R14,12(0,R13)            Restore return address\n         LM    R0,R12,20(R13)           Restore other registers\n         BSM   0,R14                    and return\n\nC_Literals  DS  0H\n\nC2EX1    MVC   0(0,R4),0(R15)           Move UCB/Volser\nC2EX3    MVC   @_UNITNM(0),0(R15)       Move Unit Name\nC2EX4    MVC   @_OutFile_DDName(0),0(R15) Move OUTFILE DDName\nC2EX5    PACK  @C_DBLWD,0(0,R15)        Pack a number\nC_Save_Sort_Field  MVC   @_Sort_Field(0),5(R14)\n\nC_PgmName  DC  C'&PGMNAME'      Simulated command name\n\n         PUSH  PRINT\n         PRINT NOGEN\n\nC_Time   TIME  LINKAGE=SYSTEM,MF=L\nC_Time_Length EQU *-C_Time\n\nC_OPEN    OPEN  (0,INPUT),MODE=31,MF=L\nC_OPEN_Length EQU *-C_OPEN\n\nC_CLOSE   CLOSE (0),MODE=31,MF=L\nC_CLOSE_Length EQU *-C_CLOSE\n\nC_LINKX   LINKX SF=L\nC_LINKX_Length EQU *-C_LINKX\n         POP   PRINT\n\nC_TrTbl  DC    256AL1(*-C_TrTbl)\n         ORG   C_TrTbl+C'?'\n         DC    X'FF'\n         ORG   C_TrTbl+C'%'\n         DC    X'FF'\n         ORG   C_TrTbl+C'*'\n         DC    X'FF'\n         ORG\n\nC_TrTbl1 DC    256X'00'\n         ORG   C_TrTbl1+C'?'\n         DC    X'FF'\n         ORG   C_TrTbl1+C'%'\n         DC    X'FF'\n         ORG   C_TrTbl1+C'*'\n         DC    X'FF'\n         ORG\n\n         LTORG\n\n         PUSH  PRINT\n         PRINT NOGEN\nC_SYSIN_DCB DCB   DDNAME=SYSIN,DSORG=PS,MACRF=GL,LRECL=80,             +\n               DCBE=C_SYSIN_DCBE\n         DS    0D\nC_SYSIN_DCB_Length EQU *-C_SYSIN_DCB\n\nC_SYSIN_DCBE DCBE RMODE31=BUFF,EODAD=C00760\n         DS    0D\nC_SYSIN_DCBE_Length EQU *-C_SYSIN_DCBE\n\nC_SYSIN24_DCB DCB   DDNAME=SYSIN,DSORG=PS,MACRF=GL,LRECL=80,           +\n               EODAD=0\n         DS    0D\nC_SYSIN24_DCB_Length EQU *-C_SYSIN24_DCB\n         POP   PRINT\n\nC_Hdg0   EQU   *\n         DC    C' yyyy/mm/dd hh:mm:ss   &PGMNAME &VERSION DASD Free Spa+\n               ce Report'\nC_Hdg0_Len EQU *-C_Hdg0\n\nC_Hdg1   EQU   *\n         DC    CL(VolTbl_Ent_FreeSpace_Info-VolTbl_Ent_Display_Start)' +\n               '\nC_Hdg1_1 DC    (VolTbl_Ent_FreeSpace_Info_End-VolTbl_Ent_FreeSpace_Info+\n               )C'-'\n         ORG   C_Hdg1_1+((*-C_Hdg1_1-13)/2)\n         DC    C' Volume Free '\n         ORG   ,\n         DC    CL(VolTbl_Ent_VTOC_Info-VolTbl_Ent_FreeSpace_Info_End)' +\n               '\nC_Hdg1_2 DC    (VolTbl_Ent_VTOC_Info_End-VolTbl_Ent_VTOC_Info)C'-'\n         ORG   C_Hdg1_2+((*-C_Hdg1_2-6)/2)\n         DC    C' VTOC '\n         ORG   ,\n         DC    CL(VolTbl_Ent_SMS_Info-VolTbl_Ent_VTOC_Info_End)' '\nC_Hdg1_3 DC    (VolTbl_Ent_SMS_Info_End-VolTbl_Ent_SMS_Info)C'-'\n         ORG   C_Hdg1_3+((*-C_Hdg1_3-5)/2)\n         DC    C' SMS '\n         ORG   ,\n         DC    CL(VolTbl_Ent_CHPID_Info-VolTbl_Ent_SMS_Info_End)' '\nC_Hdg1_4 DC    (VolTbl_Ent_CHPID_Info_End-VolTbl_Ent_CHPID_Info)C'-'\n         ORG   C_Hdg1_4+((*-C_Hdg1_4-8)/2)\n         DC    C' CHPIDs '\n         ORG   ,\nC_Hdg1_Len EQU *-C_Hdg1\n\nC_Hdg2   EQU   *\n         DC    C'                                                    '\n         DC    C'   Nbr   - Largest -  Frag         Free    % IX'\n         DC    C'   Vol  Storage                                     '\n         DC    C'                '\nC_Hdg2_Len EQU *-C_Hdg2\n\nC_Hdg3   EQU   *\n         DC    C'VOLSER  UCB  DevType   St    Trks  Cyls     %  Bytes'\n         DC    C' Xtnts    Trks  Cyls Index   Trks DSCBs Free St'\n         DC    C'  Size  Group    Status                             '\n         DC    C'                '\nC_Hdg3_Len EQU *-C_Hdg3\n\nC_ErrMsgs EQU  *\n\n         DC    CL(L'VolTbl_Ent_ErrMsg)'*** Unrecognized input - ignored+\n                ***'\n         DC    CL(L'VolTbl_Ent_ErrMsg)' '\n         DC    CL(L'VolTbl_Ent_ErrMsg)'Valid Keywords:'\n         DC    CL(L'VolTbl_Ent_ErrMsg)' UCB(Unit-mask)     specifies th+\n               e selection criterion based on UCB Address.'\n         DC    CL(L'VolTbl_Ent_ErrMsg)' XUCB(Unit-mask)    specifies th+\n               e exclusion criterion based on UCB Address.'\n         DC    CL(L'VolTbl_Ent_ErrMsg)' VOLUME(Volser)     specifies th+\n               e selection criterion based on volser.'\n         DC    CL(L'VolTbl_Ent_ErrMsg)' XVOLUME(Volser)    specifies th+\n               e exclusion criterion based on volser.'\n         DC    CL(L'VolTbl_Ent_ErrMsg)' NAME(Unit-Name)    specifies th+\n               e selection criterion based on generic'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                  or esoteric Un+\n               it name.'\n         DC    CL(L'VolTbl_Ent_ErrMsg)' ATTRIBUTE(STORAGE/STG/PRIVATE/P+\n               VT/PUBLIC/SMS)'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                  specifies the +\n               selection criterion based on mount'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                  attribute. Onl+\n               y one of the keywords can be specified.'\n         DC    CL(L'VolTbl_Ent_ErrMsg)' STORGRP(SMS-Storage_Group_Name)+\n               '\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                  specifies the +\n               selection criterion based on SMS'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                  Storage Group.+\n               '\n         DC    CL(L'VolTbl_Ent_ErrMsg)' SORT(id)         specifies the +\n               order in which the selected DASD volumes'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                  are displayed:+\n               '\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                   id: VOL     -+\n                Volser'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                       UCB     -+\n                UCB Name (Device Address)'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                       DEVT    -+\n                Device Type'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                       ATTR    -+\n                Mount Attribute'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                       FREET   -+\n                Total Free Tracks'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                       FREEC   -+\n                Total Free Cylinders'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                       FREEP   -+\n                % Volume Free'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                       FREEB   -+\n                Total Free Bytes'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                       FREEE   -+\n                # Free Extents'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                       LARGET  -+\n                Largest Free Tracks'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                       LARGEC  -+\n                Largest Free Cylinders'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                       VFREED  -+\n                Free DSCBs in VTOC'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                       VFREEP  -+\n                % VTOC Free'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                       VTRK    -+\n                Tracks allocated to the VTOC'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                       VIX     -+\n                VTOC Index Status'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                       FRAG    -+\n                Fragmentation Index'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                       VOLSIZE -+\n                Volume Capacity'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                       STORGRP -+\n                SMS Storage Group'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                       SMSSTAT -+\n                SMS Volume Status'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                       CHIPDS  -+\n                1st CHPID'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                  By default, th+\n               e display is unsorted, and will'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                  normally appea+\n               r in ascending order of UCB.'\n         DC    CL(L'VolTbl_Ent_ErrMsg)' ASCENDING/DESCENDING specifies +\n               the SORT order. Significant only if'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                  SORT() is spec+\n               ified. Default is ASCENDING'\n         DC    CL(L'VolTbl_Ent_ErrMsg)' MAXTASKS(#)        specifies th+\n               e maximum number of sub-tasks (1-16) to'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                  be ATTACHed to+\n                retrieve volume information.'\n         DC    CL(L'VolTbl_Ent_ErrMsg)' OUTFILE(ddname)  specifies the +\n               DDNAME of an output file to which'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                  volume informa+\n               tion will be written, in addition'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                  to SYSPRINT.'\n         DC    CL(L'VolTbl_Ent_ErrMsg)' OUTDATA(DISPLAY/CB/ALL) specifi+\n               es the type of data to be written to'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                  the OUTFILE DD+\n               NAME:'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                   DISPLAY write+\n               s SYSPRINT data to OUTFILE'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                   CB      wtite+\n               s copies of the UCB, DCE, LSPACE,'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                           and F+\n               4DSCB to OUTFILE'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                   ALL     write+\n               s both CB and DISPLAY (default).'\n         DC    CL(L'VolTbl_Ent_ErrMsg)' NOHEADINGS/NOHDG suppresses hea+\n               dings (and page breaks).'\n         DC    CL(L'VolTbl_Ent_ErrMsg)' NODETAILS        suppresses det+\n               ail (DASD volume) lines.'\n         DC    CL(L'VolTbl_Ent_ErrMsg)' NOTOTALS         suppresses tot+\n               als line.'\n         DC    CL(L'VolTbl_Ent_ErrMsg)' NOECHO           suppresses the+\n                display of the input command.'\n         DC    CL(L'VolTbl_Ent_ErrMsg)' STATISTICS/STATS displays inter+\n               nal processing statistics.'\n         DC    CL(L'VolTbl_Ent_ErrMsg)' ISPF(S/E/B/N)    displays resul+\n               ts using ISPF DM services, if available.'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                   S(pace) uses +\n               customized &PGMNAME displays'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                   E(dif) uses I+\n               SPF Edit services'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                   B(rif) uses I+\n               SPF Browse services.'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                   N(one) uses T+\n               SO line-by-line (PUTLINE) output.'\n         DC    CL(L'VolTbl_Ent_ErrMsg)' NOLSPACE         specifies that+\n                no volume space information is required.'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                  Fields display+\n               ed are: UCB, Volser, DevType, Attr, SMS'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                  data, and CHPI+\n               Ds.'\n         DC    CL(L'VolTbl_Ent_ErrMsg)' LINESIZE(nnn)    specifies the +\n               maximum line length to be displayed'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                  in TSO line-by+\n               line output.'\n         DC    CL(L'VolTbl_Ent_ErrMsg)' MAXLWAIT(nnnn)   specifies the +\n               maximum number of seconds in which'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                  each LSPACE in+\n               vocation must complete. 0 signifies'\n         DC    CL(L'VolTbl_Ent_ErrMsg)'                  no limit.'\n\nC_ErrMsg_Count EQU   (*-C_ErrMsgs)/L'VolTbl_Ent_ErrMsg\n\n         PUSH  PRINT\n         PRINT NOGEN\n\nC_PCL    RMODE ANY\nC_PCL    AMODE 31\nC_PCL    IKJPARM\n\nC_01K    IKJKEYWD\n         IKJNAME 'UNIT',                                               +\n               ALIAS='UCB',                                            +\n               SUBFLD=C_01SF\n\nC_02K    IKJKEYWD\n         IKJNAME 'XUNIT',                                              +\n               ALIAS='XUCB',                                           +\n               SUBFLD=C_02SF\n\nC_03K    IKJKEYWD\n         IKJNAME 'VOLUME',                                             +\n               SUBFLD=C_03SF\n\nC_04K    IKJKEYWD\n         IKJNAME 'XVOLUME',                                            +\n               SUBFLD=C_04SF\n\nC_05K    IKJKEYWD\n         IKJNAME 'NAME',                                               +\n               SUBFLD=C_05SF\n\nC_06K    IKJKEYWD\n         IKJNAME 'ATTRIBUTE',                                          +\n               SUBFLD=C_06SF\n\nC_07K    IKJKEYWD\n         IKJNAME 'STORGRP',                                            +\n               ALIAS='SG',                                             +\n               SUBFLD=C_07SF\n\nC_09K    IKJKEYWD\n         IKJNAME 'SORT',                                               +\n               SUBFLD=C_09SF\n\nC_10K    IKJKEYWD\n         IKJNAME 'ASCENDING'\n         IKJNAME 'DESCENDING'\n\nC_11K    IKJKEYWD\n         IKJNAME 'MAXTASKS',                                           +\n               SUBFLD=C_11SF\n\nC_12K    IKJKEYWD\n         IKJNAME 'ISPF',                                               +\n               SUBFLD=C_12SF\n\nC_13K    IKJKEYWD\n         IKJNAME 'NOHEADINGS',                                         +\n               ALIAS='NOHDG'\n\nC_14K    IKJKEYWD\n         IKJNAME 'NODETAILS'\n\nC_15K    IKJKEYWD\n         IKJNAME 'NOTOTALS'\n\nC_16K    IKJKEYWD\n         IKJNAME 'NOECHO'\n\nC_17K    IKJKEYWD\n         IKJNAME 'STATISTICS',                                         +\n               ALIAS='STATS'\n\nC_18K    IKJKEYWD\n         IKJNAME 'NOLSPACE'\n\nC_20K    IKJKEYWD\n         IKJNAME 'OUTFILE',                                            +\n               ALIAS=('OFILE','OUTDDNAME'),                            +\n               SUBFLD=C_20SF\n\nC_21K    IKJKEYWD\n         IKJNAME 'OUTDATA',                                            +\n               SUBFLD=C_21SF\n\nC_22K    IKJKEYWD\n         IKJNAME 'LINESIZE',                                           +\n               SUBFLD=C_22SF\n\nC_23K    IKJKEYWD\n         IKJNAME 'MAXLWAIT',                                           +\n               SUBFLD=C_23SF\n\n\n\nC_01SF   IKJSUBF\nC_01SFP  IKJIDENT 'UCB Mask(s) to be selected',                        +\n               LIST,                                                   +\n               MAXLNTH=4,                                              +\n               FIRST=ANY,                                              +\n               OTHER=ANY\n\nC_02SF IKJSUBF\nC_02SFP   IKJIDENT 'UCB Mask(s) to be excluded',                       +\n               LIST,                                                   +\n               MAXLNTH=4,                                              +\n               FIRST=ANY,                                              +\n               OTHER=ANY\n\nC_03SF   IKJSUBF\nC_03SFP  IKJIDENT 'Volser mask(s) to be selected',                     +\n               LIST,                                                   +\n               MAXLNTH=6,                                              +\n               FIRST=ANY,                                              +\n               OTHER=ANY\n\nC_04SF    IKJSUBF\nC_04SFP   IKJIDENT 'Volser mask(s) to be excluded',                    +\n               LIST,                                                   +\n               MAXLNTH=6,                                              +\n               FIRST=ANY,                                              +\n               OTHER=ANY\n\nC_05SF   IKJSUBF\nC_05SFP  IKJIDENT 'Unit Name to be selected',                          +\n               MAXLNTH=8,                                              +\n               FIRST=ANY,                                              +\n               OTHER=ANY\n\nC_06SF   IKJSUBF\nC_06SFP  IKJKEYWD\n         IKJNAME 'STORAGE',                                            +\n               ALIAS='STG'\n         IKJNAME 'PRIVATE',                                            +\n               ALIAS='PVT'\n         IKJNAME 'PUBLIC'\n         IKJNAME 'SMS'\n\nC_07SF    IKJSUBF\nC_07SFP   IKJIDENT 'SMS Storage Group Name(s)',                        +\n               LIST,                                                   +\n               MAXLNTH=30,                                             +\n               FIRST=ANY,                                              +\n               OTHER=ANY\n\nC_09SF   IKJSUBF\nC_09SFP  IKJKEYWD\n         IKJNAME 'VOL'\n         IKJNAME 'UCB'\n         IKJNAME 'DEVT'\n         IKJNAME 'ATTR'\n         IKJNAME 'FREET'\n         IKJNAME 'FREEC'\n         IKJNAME 'FREEP'\n         IKJNAME 'FREEB'\n         IKJNAME 'FREEE'\n         IKJNAME 'LARGET'\n         IKJNAME 'LARGEC'\n         IKJNAME 'VFREED'\n         IKJNAME 'VFREEP'\n         IKJNAME 'VTRK'\n         IKJNAME 'VIX'\n         IKJNAME 'FRAG'\n         IKJNAME 'VOLSIZE'\n         IKJNAME 'STORGRP'\n         IKJNAME 'SMSSTAT'\n         IKJNAME 'CHPIDS'\n\nC_11SF   IKJSUBF\nC_11SFP  IKJIDENT 'Maximum number of Sub-Tasks',                       +\n               MAXLNTH=2,                                              +\n               INTEG\n\nC_12SF IKJSUBF\n         AIF   ('&ISPF_Default_Type' EQ '').ISPF_Default_Type_010\nC_12SFP  IKJKEYWD DEFAULT='&ISPF_Default_Type'\n         AGO   .ISPF_Default_Type_020\n.ISPF_Default_Type_010 ANOP\nC_12SFP  IKJKEYWD\n.ISPF_Default_Type_020 ANOP\n         IKJNAME 'EDIF'\n         IKJNAME 'BRIF'\n         IKJNAME 'SPACE'\n         IKJNAME 'NONE'\n\n\nC_20SF   IKJSUBF\nC_20SFP  IKJIDENT 'DDNAME of output file',                             +\n               MAXLNTH=8,                                              +\n               FIRST=ALPHA,                                            +\n               OTHER=ANY\n\nC_21SF IKJSUBF\nC_21SFP  IKJKEYWD DEFAULT='ALL'\n         IKJNAME 'DISPLAY'\n         IKJNAME 'CB'\n         IKJNAME 'ALL'\n\nC_22SF   IKJSUBF\nC_22SFP  IKJIDENT 'Max length of data to be displayed',                +\n               MAXLNTH=3,                                              +\n               FIRST=ANY,                                              +\n               OTHER=ANY\n\nC_23SF   IKJSUBF\nC_23SFP  IKJIDENT 'Nbr seconds for LSPACE completion',                 +\n               MAXLNTH=4,                                              +\n               FIRST=NUMERIC,                                          +\n               OTHER=NUMERIC\n\n         IKJENDP\n\n         POP   PRINT\n\nC_Literals_End  DS  0H\n\n\n@C_Dynam                  DSECT       Dynamic area for C00000\n                          DS    18F    O/S Style save area\n@C_31Bit_Stack_Ptr_Ptr    DS    AL4    A(31-bit Stack Ptr)\n@C_24Bit_Stack_Ptr_Ptr    DS    AL4    A(24-bit Stack Ptr)\n@C_DBLWD                  DS    D      Workarea\n@C_PPL                    DS    CL(PPL_Length) PPL area\n@C_PECB                   DS    F      ECB for PARSE\n@C_PANS                   DS    A      PARSE answer area\n@C_SYSIN_Rec_Ptr          DS    AL4    SYSIN Record Pointer\n@C_CPPL_Ptr               DS    AL4    A(CPPL)\n@C_CBUF                   EQU   *      Batch Command buffer\n@C_CBUF_Len               DS    HL2     Length\n@C_CBUF_Off               DS    HL2     Offset to operands\n@C_CBUF_Data              DS    CL255   Data\n@C_CBUF1                  EQU   *      Cbuf after ASASYMBM\n@C_CBUF1_Len              DS    HL2     Length\n@C_CBUF1_Off              DS    HL2     Offset to operands\n@C_CBUF1_Data             DS    CL255   Data\n                          DS    X      Flag byte\n@C_NoEcho                 EQU   *-1,X'80' 1... .... NOECHO specified\n@C_UNIT_Flag              EQU   *-1,X'40' .1.. .... UNIT processed\n@C_XUNIT_Flag             EQU   *-1,X'20' ..1. .... XUNIT processed\n@C_VOL_Flag               EQU   *-1,X'10' ...1 .... VOL processed\n@C_XVOL_Flag              EQU   *-1,X'08' .... 1... XVOL processed\n@C_UPTSWS                 DS    XL(L'UPTSWS) UPTSWS Save\n\n                          DS    0F\n@C_Macros                 EQU   *\n@C_OPEN                   DS    CL(C_OPEN_Length)  OPEN parms\n                          ORG   @C_Macros\n@C_CLOSE                  DS    CL(C_CLOSE_Length) Close Parms\n                          ORG   @C_Macros\n@C_Time                   DS    CL(C_Time_Length)  L-Form of Time\n                          DS    0D                 Alignment\n@C_TimeArea               DS    CL16               Return area for Time\n                          ORG   @C_Macros\n@C_LINKX                  DS    CL(C_LINKX_Length) LINKX Macro\n@C_SYMBP                  DS    CL(SYMBP_LEN)      ASASYMBM Parm area\n@C_SYMBP_Target_Len       DS    FL4             ASASYMBM Target Length\n@C_SYMBP_RC               DS    FL4             ASASYMBM Return code\n                          ORG   ,\n@C_Parms                  DS    0F     Parms for called rtns\n@C_Parms_Std              DS    3AL4    Standard 3 parms\n@C_Parms_Extra            EQU   *       Extra parms\n@C_Parms_Y00010           DS    2AL4       for Y00010\n                          ORG   ,\n                          DS    0D     Alignment\n@C_Dynam_Length           EQU   *-@C_Dynam  Length of storage\n\n&PGMNAME CSECT\n\n         DROP  ,\n         POP   USING\n\n         TITLE 'D00010: Get Eligible UCBs'\n\n         PUSH  USING\n\nD00010   DS    0H\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Routine   : D00010                                                 *\n*                                                                     *\n*  Abstract  : Populate Volume Table with eligible UCBs.              *\n*                                                                     *\n*  Inputs    : R1 : ---> A(@_Dynam)                                   *\n*                        A(31-bit Stack Pointer)                      *\n*                        A(24-bit Stack Pointer)                      *\n*  Outputs   : R15: 0 - OK, @_VolTbl_Ptr contains A(Volume Table)     *\n*                   4 - No UCBs found/Insufficient Storage            *\n*                                                                     *\n*  Notes     : @_VOL_List_Ptr contains A(Volume masks)                *\n*              @_XVOL_List_Ptr contains A(Xolume masks)               *\n*              @_UCB_List_Ptr contains A(UCB masks)                   *\n*              @_XUCB_List_Ptr contains A(XUCB masks)                 *\n*              @_UNITNM contains the Esoteric Unit Name               *\n*              @_ATTR??? contains the Mount Attribute flags           *\n*              @_STORGRP_List_Ptr contains A(StorGrp masks)           *\n*                                                                     *\n*  History:    1990/06/11 SDDA030 - New                               *\n*              1994/05/24 SDDA030 - Used SSCUCBS to get list of UCBs  *\n*                                 - Added creation of dummy total line*\n*              1996/03/13 SDDA030 - Used UCBCHAN rather than UCBNAME  *\n*                                   to get readable device address    *\n*                                   (VolTbl_Ent_DevAddr)              *\n*                                 - Use our own UCB look-up routines  *\n*                                   rather than SSCUCBS               *\n*              1998/09/17 SDDA030 - V2.0                              *\n*                                 - Removed APF checks, and undoc-    *\n*                                   umented UCB search method.        *\n*                                 - Use UCBSCAN with DCEAREA to get   *\n*                                   DCE info.                         *\n*              1998/09/22 SDDA030 - V2.1                              *\n*                                 - Made sure there was always room   *\n*                                   in the Volume Table for the Totals*\n*                                   Line, if required.                *\n*                                 - Added '%' as a single-character   *\n*                                   wild-card match (like '?') in     *\n*                                   UCB and Volser.                   *\n*                                 - Added repetitive search if select-*\n*                                   ing by UCB address when the user  *\n*                                   entered a potential 3-byte UCB    *\n*                                   address mask, and we found no UCBs*\n*                                   because we were using it as a     *\n*                                   4-byte UCB address mask.          *\n*                                 - Added DEVN to UCBSCAN             *\n*                                 - Invoke UCBSCAN with VOLSER= if    *\n*                                   we are checking for a specific    *\n*                                   Volser                            *\n*                                 - Broke out Subtask Management code *\n*                                   into a separate routine (E00010). *\n*              1999/08/20 SDDA030 - V2.8                              *\n*                                 - Used Routine W00010 to manage     *\n*                                   VolTbl entries.                   *\n*              2001/02/26 SDDA030 - V2.14                             *\n*                                 - Added SMS Storage Group and CHPID *\n*                                   info.                             *\n*                                 - Used only DCEOBRDT to determine   *\n*                                   Device Type.                      *\n*                                 - Added 'N/A' in SMS fields for     *\n*                                   non-SMS volumes.                  *\n*              2001/11/12 SDDA030 - V2.15                             *\n*                                 - Added XUCB, XVOL processing       *\n*                                 - Added RANGE=ALL, DYNAMIC=YES,     *\n*                                   LOC=ANY to EDTINFO                *\n*              2002/03/11 SDDA030 - V2.17                             *\n*                                 - Added STORGRP selection logic     *\n*                                 - Moved SMS IEFSSREQ stuff to T00010*\n*                                 - Added indicators for CHPIDs not   *\n*                                   phys or log available.            *\n*              2002/06/11 SDDA030 - V2.18                             *\n*                                 - Formatted as much of total line as*\n*                                   possible.                         *\n*                                 - 'POST' entries as complete if we  *\n*                                   will not be LSPACEing.            *\n*              2002/08/08 SDDA030 - V2.19                             *\n*                                 - Merged code from U0010 into this  *\n*                                   section                           *\n*                                 - Corrected increment when stepping *\n*                                   through @_STORGRP_List            *\n*              2003/10/07 SDDA030 - V2.21                             *\n*                                 - Fixed S0C4 when adjusting UCB pat-*\n*                                   terns when no UCBs found when sel-*\n*                                   ecting by UCB.                    *\n*                                 - Limited re-searching based on len *\n*                                   of entered UCB mask(s)            *\n*              2005/01/20 SDDA030 - V2.23                             *\n*                                 - Used CSRSI, if possible, to get   *\n*                                   CPU info.                         *\n*              2006/04/21 SDDA030 - V2.24                             *\n*                                 - Added .e display                  *\n*                                 - Init CHPIDs to '--'               *\n*                                 - Used standardised calling sequence*\n*                                 - Coped with insufficient storage   *\n*                                   for the volume table.             *\n*                                 - Used UCBTBYT4 to find device type *\n*                                   for emulated devices.             *\n*              ____/__/__ _______ -                                   *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         STM   R14,R12,12(R13)          Save callers registers\n         LARL  R11,D_Literals           Point to our literals\n         USING (D_Literals,D_Literals_End),R11 Tell the assembler\n\n         L     R12,0(0,R1)              A(@_Dynam)\n         USING @_Dynam,R12              Tell the assembler\n\n*-------------------------------------------------------------------*\n*    Get an area on the stack for our local storage                 *\n*-------------------------------------------------------------------*\n         L     R2,4(0,R1)               A(31-bit stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         SSCSTACK PUSH,                 Get stack area                 +\n               LEN=@D_Dynam_Length,      this long                     +\n               STACK=(R2)                using this stack\n\n         LR    R3,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LHI   R1,@D_Dynam_Length        Its length\n         LA    R14,0                    Clear source address\n         LA    R15,0                     and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R3                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*-------------------------------------------------------------------*\n         ST    R13,4(0,R1)              Chain\n         ST    R1,8(0,R13)               saveareas\n         LR    R13,R1                   Load dynam base\n         USING @D_Dynam,R13             Assign a base\n         L     R15,@D_Dynam+4           Get A(HSA)\n         LM    R0,R3,20(R15)            Restore callers registers\n\n         L     R15,4(0,R1)              A(31-bit Stack)\n         ST    R15,@D_31Bit_Stack_Ptr_Ptr Save it\n         L     R15,8(0,R1)              A(24-bit Stack)\n         ST    R15,@D_24Bit_Stack_Ptr_Ptr Save it\n\nD00020   DS    0H\n*-------------------------------------------------------------------*\n*    Reset our flags and counters                                   *\n*-------------------------------------------------------------------*\n         NI    @D_Eligible_UCB_Found,X'FF'-L'@D_Eligible_UCB_Found\n         NI    @D_CHPID_Unavail,X'FF'-L'@D_CHPID_Unavail CHPIDs OK\n         LA    R15,0                    Clear\n         ST    R15,@D_Volume_Count       nbr vols found\n\n*--------------------------------------------------------------------*\n*   Initialize our standard parmlist                                 *\n*--------------------------------------------------------------------*\n         LA    R15,@_Dynam              A(Dynamic area)\n         ST    R15,@D_Parms_Std         Save it\n         L     R15,@D_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)\n         ST    R15,@D_Parms_Std+4       Save it\n         L     R15,@D_24Bit_Stack_Ptr_Ptr A(24-bit Stack Pointer)\n         ST    R15,@D_Parms_Std+8       Save it\n\n*---------------------------------------------------------------------*\n*     If we are selecting by name, go get UCBs associated with the    *\n*    name                                                             *\n*---------------------------------------------------------------------*\n         LA    R15,0                    Clear\n         ST    R15,@D_UNITA              A(Unit Table)\n\n         CLI   @_UNITNM,C' '            Selecting by unit name?\n         JE    D00030                   No, skip\n         LHI   R0,128                   Yes, get table\n         SLL   R0,8                      size of 32K\n         BASR  R2,0\n         USING (*,D00020_End-1),R2\n         STORAGE OBTAIN,                Go get storage                 +\n               LENGTH=(0),               this long                     +\n               LOC=31                    above-the-line\nD00020_End DS  0H\n         DROP  R2\n         ST    R1,@D_UNITA              Save it\n         ST    R0,0(0,R1)               Save table length\n         LA    R15,0                    Clear nbr entries\n         ST    R15,4(0,R1)              Update table\n         MVI   @D_IOCT,0                Clear IOCP Token field\n         MVC   @D_IOCT+1(L'@D_IOCT-1),@D_IOCT\n         EDTINFO RTNDEVN,               Get UCB numbers                +\n               UNITNAME=@_UNITNM,        for this esoteric             +\n               DEVNLIST=@D_UNITA,        save them here                +\n               DYNAMIC=YES,              get dynamic devices           +\n               RANGE=ALL,                3- and 4-digit UCBs           +\n               LOC=ANY,                  no matter where they live     +\n               IOCTOKEN=@D_IOCT,         use dummy IOC Token           +\n               MF=(E,@D_EDTINFO)         staying reentrant\n         LTR   R15,R15                  Did it work?\n         JNZ   D00490                   No, exit\n\nD00030   DS    0H\n*---------------------------------------------------------------------*\n*   We now go and get UCBs (in fact, we get UCB copys), and the       *\n*  associated Device Class Extensions (DCEs) using UCBSCAN.           *\n*  First, however, we have to get the I/O Config token.               *\n*---------------------------------------------------------------------*\n         IOCINFO IOCTOKEN=@D_IOCT,      Get I/O Config token           +\n               MF=(E,@D_IOCINFO)\n\nD00040   DS    0H\n*---------------------------------------------------------------------*\n*   Initialize the UCBSCAN workarea ...                               *\n*---------------------------------------------------------------------*\n         XC    @D_UCBSCAN_WorkArea,@D_UCBSCAN_WorkArea Clear workarea\n\n*---------------------------------------------------------------------*\n*   If we have been invoked for a single Volser (ie, one with no      *\n*  wildcards), we invoke UCBSCAN with the VOLSER parameter, and set   *\n*  a flag indicating that we want to be invoked once only             *\n*---------------------------------------------------------------------*\n         NI    @D_Single_Volser,X'FF'-L'@D_Single_Volser Off our flag\n         ICM   R1,B'1111',@_Vol_List_Ptr A(Volser list)\n         JZ    D00050                   None, skip\n         L     R0,Vol_List_Hdr_Count-Vol_List_Hdr(R1) Get count\n         CHI   R0,1                     A single volser?\n         JNE   D00050                   No, skip\n         CLI   Vol_List_Ent_Mask-Vol_List_Hdr(R1),X'00' With\n         JNE   D00050                    no wildcards?\n         CLC   Vol_List_Ent_Mask+1-Vol_List_Hdr(L'Vol_List_Ent_Mask-1,R+\n               1),Vol_List_Ent_Mask-Vol_List_Hdr(R1)\n         JNE   D00050                   Wildcards, skip\n\n         OI    @D_Single_Volser,L'@D_Single_Volser Only 1 Volser\n         LA    R3,Vol_List_Ent_Vol-Vol_List_Hdr(R1) Point to it\n\n         LHI   R15,L'@D_DCE             Length of DCE area\n         STH   R15,@D_DCE_Length        Save it\n\n         UCBSCAN COPY,                  Get a copy of a UCB            +\n               UCBAREA=@D_UCB,           here                          +\n               DCEAREA=@D_DCE,           copy DCE as well              +\n               DCELEN=@D_DCE_Length,     copy this much                +\n               DYNAMIC=YES,              include HCD devices           +\n               NONBASE=NO,               only 1 UCB per device         +\n               DEVCLASS=DASD,            this device type only         +\n               RANGE=ALL,                3- and 4-byte UCB addresses   +\n               VOLSER=(3),               find this volume              +\n               IOCTOKEN=@D_IOCT,         This I/O Config               +\n               WORKAREA=@D_UCBSCAN_WorkArea, use this workarea         +\n               MF=(E,@D_UCBSCAN)         and stay re-entrant\n\n         LTR   R15,R15                  Did we get one?\n         JZ    D00060                   Yes, skip\n         CHI   R15,12                   No, I/O config changed?\n         JE    D00020                   Yes, start again\n         J     D00490                   End of UCBs, skip\n\nD00050   DS    0H\n*---------------------------------------------------------------------*\n*     Get the next UCB                                                *\n*---------------------------------------------------------------------*\n         LHI   R15,L'@D_DCE             Length of DCE area\n         STH   R15,@D_DCE_Length        Save it\n\n         UCBSCAN COPY,                  Get a copy of a UCB            +\n               UCBAREA=@D_UCB,           here                          +\n               DCEAREA=@D_DCE,           copy DCE as well              +\n               DCELEN=@D_DCE_Length,     copy this much                +\n               DYNAMIC=YES,              include HCD devices           +\n               NONBASE=NO,               only 1 UCB per device         +\n               DEVCLASS=DASD,            this device type only         +\n               RANGE=ALL,                3- and 4-byte UCB addresses   +\n               IOCTOKEN=@D_IOCT,         This I/O Config               +\n               WORKAREA=@D_UCBSCAN_WorkArea, use this workarea         +\n               MF=(E,@D_UCBSCAN)         and stay re-entrant\n\n         LTR   R15,R15                  Did we get one?\n         JZ    D00060                   Yes, skip\n         LA    R0,12                    No, RC if I/O config changed\n         CR    R0,R15                   Is that what happened?\n         JE    D00020                   Yes, start again\n         J     D00490                   No, end of UCBs, skip\n\nD00060   DS    0H\n         NI    @D_SMS_Ptrs_OK,X'FF'-L'@D_SMS_Ptrs_OK No SMS data yet\n\n*---------------------------------------------------------------------*\n*     We have a UCB address, so check it out. First, it must be       *\n*    ONLINE ...                                                       *\n*---------------------------------------------------------------------*\n         TM    @D_UCB+UCBSTAT-UCBOB,UCBONLI Online?\n         JNO   D00480                   No, go get next UCB\n\n*---------------------------------------------------------------------*\n*     ... and then match our UNIT address, if applicable ...          *\n*---------------------------------------------------------------------*\n         MVO   @D_DBLWD+5(3),@D_UCB+UCBCHAN-UCBOB(L'UCBCHAN)\n         OI    @D_DBLWD+7,X'0F'         Add a sign\n         UNPK  @D_DBLWD(5),@D_DBLWD+5(3) Unpack it\n         TR    @D_DBLWD+1(4),D_TRTAB     Make it readable\n         MVC   @D_UCBNAME,@D_DBLWD+1    Save it\n\n         ICM   R1,B'1111',@_UCB_List_Ptr A(UCB List)\n         JZ    D00080                   None, skip\n         L     R3,UCB_List_Hdr_Count-UCB_List_Hdr(R1) Get nbr entries\n         AHI   R1,UCB_List_Ent-UCB_List   and point to 1st\nD00070   DS    0H\n         MVC   @D_DBLWD(L'@D_UCBName),@D_UCBName Move UCB to temp area\n         OC    @D_DBLWD(L'@D_UCBName),UCB_List_Ent_Mask-UCB_List_Ent(R1+\n               )                        Wildcard positions = x'FF'\n         CLC   @D_DBLWD(L'@D_UCBName),UCB_List_Ent_UCB-UCB_List_Ent(R1)\n         JE    D00080                   We want it, skip\n         AHI   R1,UCB_List_Ent_Length   Bump to next entry\n         BRCT  R3,D00070                and try again\n         J     D00480                   Not here, skip this UCB\nD00080   DS    0H\n         OI    @D_Eligible_UCB_Found,L'@D_Eligible_UCB_Found\n         ICM   R1,B'1111',@_XUCB_List_Ptr A(XUCB List)\n         JZ    D00100                   None, skip\n         L     R3,UCB_List_Hdr_Count-UCB_List_Hdr(R1) Get nbr entries\n         AHI   R1,UCB_List_Ent-UCB_List     and point to 1st\nD00090   DS    0H\n         MVC   @D_DBLWD(L'@D_UCBName),@D_UCBName Move UCB to temp area\n         OC    @D_DBLWD(L'@D_UCBName),UCB_List_Ent_Mask-UCB_List_Ent(R1+\n               )                        Wildcard positions = x'FF'\n         CLC   @D_DBLWD(L'@D_UCBName),UCB_List_Ent_UCB-UCB_List_Ent(R1)\n         JE    D00480                   Exclude it, skip\n         AHI   R1,UCB_List_Ent_Length   Bump to next entry\n         BRCT  R3,D00090                and try again\n\nD00100   DS    0H\n*---------------------------------------------------------------------*\n*     ... and our VOLSER criteria, if applicable ...                  *\n*---------------------------------------------------------------------*\n         ICM   R1,B'1111',@_VOL_List_Ptr A(VOL List)\n         JZ    D00130                   None, skip\n         L     R3,Vol_List_Hdr_Count-Vol_List_Hdr(R1) Get nbr entries\n         AHI   R1,Vol_List_Ent-Vol_List     and point to 1st\nD00120   DS    0H\n         MVC   @D_DBLWD(L'UCBVOLI),@D_UCB+UCBVOLI-UCBOB Move Volser\n         OC    @D_DBLWD(L'UCBVOLI),Vol_List_Ent_Mask-Vol_List_Ent(R1)\n         CLC   @D_DBLWD(L'UCBVOLI),Vol_List_Ent_Vol-Vol_List_Ent(R1)\n         JE    D00130                   We want it, skip\n         AHI   R1,Vol_List_Ent_Length   Bump to next entry\n         BRCT  R3,D00120                and try again\n         J     D00480                   Not here, skip this UCB\nD00130   DS    0H\n         ICM   R1,B'1111',@_XVOL_List_Ptr A(XVOL List)\n         JZ    D00150                   None, skip\n         L     R3,Vol_List_Hdr_Count-Vol_List_Hdr(R1) Get nbr entries\n         AHI   R1,Vol_List_Ent-Vol_List     and point to 1st\nD00140   DS    0H\n         MVC   @D_DBLWD(L'UCBVOLI),@D_UCB+UCBVOLI-UCBOB Move Volser\n         OC    @D_DBLWD(L'UCBVOLI),Vol_List_Ent_Mask-Vol_List_Ent(R1)\n         CLC   @D_DBLWD(L'UCBVOLI),Vol_List_Ent_Vol-Vol_List_Ent(R1)\n         JE    D00480                   Exclude it, skip\n         AHI   R1,Vol_List_Ent_Length   Bump to next entry\n         BRCT  R3,D00140                and try again\n\nD00150   DS    0H\n*---------------------------------------------------------------------*\n*     ... our esoteric name criteria, if applicable ...               *\n*---------------------------------------------------------------------*\n         ICM   R14,B'1111',@D_UNITA     Get A(Unit Table)\n         JZ    D00170                   None, skip\n         ICM   R15,B'1111',4(R14)       Get nbr devices\n         JZ    D00480                   None, skip this UCB\n         AHI   R14,8                    Yes, point to first\n\nD00160   DS    0H\n         CLC   @D_DBLWD+1(4),0(R14)     Is this us?\n         JE    D00170                   Yes, use it\n         AHI   R14,4                    No, point to next in Unit Tbl\n         BRCT  R15,D00160               and check it\n         J     D00480                   Skip this UCB\n\nD00170   DS    0H\n*---------------------------------------------------------------------*\n*     ... and our Mount Attributes, if applicable ...                 *\n*---------------------------------------------------------------------*\n         TM    @_ATTRSMS,L'@_ATTRSMS    Selecting SMS vols?\n         JZ    D00180                   No, skip\n         TM    @D_UCB+UCBFL5-UCBOB,UCBSMS SMS?\n         JZ    D00480                   No, skip\n         J     D00210                   OK, use this vol\nD00180   DS    0H\n         TM    @_ATTRPvt,L'@_ATTRPvt    Selecting PRIVATE vols?\n         JZ    D00190                   No, skip\n         TM    @D_UCB+UCBSTAB-UCBOB,UCBBPRV PRIVATE?\n         JZ    D00480                   No, skip\n         TM    @D_UCB+UCBFL5-UCBOB,UCBSMS SMS?\n         JO    D00480                   Yes, skip\n         J     D00210                   OK, use this vol\nD00190   DS    0H\n         TM    @_ATTRPub,L'@_ATTRPub    Selecting PUBLIC vols?\n         JZ    D00200                   No, skip\n         TM    @D_UCB+UCBSTAB-UCBOB,UCBBPUB PUBLIC?\n         JZ    D00480                   No, skip\n         TM    @D_UCB+UCBFL5-UCBOB,UCBSMS SMS?\n         JO    D00480                   Yes, skip\n         J     D00210                   OK, use this vol\nD00200   DS    0H\n         TM    @_ATTRStg,L'@_ATTRStg    Selecting STORAGE vols?\n         JZ    D00210                   No, use this vol\n         TM    @D_UCB+UCBSTAB-UCBOB,UCBBSTR Storage?\n         JZ    D00480                   No, skip this vol\n         TM    @D_UCB+UCBFL5-UCBOB,UCBSMS SMS?\n         JO    D00480                   Yes, skip\n\nD00210   DS    0H\n*---------------------------------------------------------------------*\n*     ... and our STORGRP criteria, if applicable.                    *\n*---------------------------------------------------------------------*\n         ICM   R1,B'1111',@_STORGRP_List_Ptr A(STORGRP List)\n         JZ    D00240                   None, STORGRP not a criterion\n\n         TM    @D_UCB+UCBFL5-UCBOB,UCBSMS SMS?\n         JZ    D00480                   No, skip this volume\n\n         TM    @D_SMS_Unavail,L'@D_SMS_Unavail Is SMS there?\n         JO    D00480                  No, skip\n\n         LA    R15,@D_UCB+UCBVOLI-UCBOB A(Volser)\n         ST    R15,@D_Parms_T00010     Save it\n         LA    R15,@D_VLD_Anchor       A(VLD Anchor)\n         ST    R15,@D_Parms_T00010+4   Save it\n\n         LA    R1,@D_Parms             A(Parm list)\n         BRAS  R14,T00010              Go get Storgrp, status\n\n         STM   R0,R1,@D_SMS_Ptrs       Save the results\n         CHI   R15,4                   How did it go?\n         JL    D00220                  OK, skip\n         JE    D00480                  STORGRP not found, skip this vol\n         OI    @D_SMS_Unavail,L'@D_SMS_Unavail No SMS, set flag\n         J     D00480                  and skip this vol\n\nD00220   DS    0H\n         OI    @D_SMS_Ptrs_OK,L'@D_SMS_Ptrs_OK  We have SMS data\n\n         L     R15,@D_SMS_Ptrs+4        A(STORGRP Len, STORGRP)\n         L     R1,@_STORGRP_List_Ptr    A(STORGRP criterion)\n         L     R3,STORGRP_List_Hdr_Count-STORGRP_List_Hdr(R1) Get nbr\n         AHI   R1,STORGRP_List_Ent-STORGRP_List     and point to 1st\nD00230   DS    0H\n         MVC   @D_SMS_Temp_StorGrp,2(R15) Move STORGRP\n         OC    @D_SMS_Temp_StorGrp,STORGRP_List_Ent_Mask-STORGRP_List_E+\n               nt(R1)                   Reset wildcards\n         CLC   @D_SMS_Temp_StorGrp,STORGRP_List_Ent_STORGRP-STORGRP_Lis+\n               t_Ent(R1)                Our Storage group?\n         JE    D00240                   We want it, skip\n         AHI   R1,STORGRP_List_Ent_Length Bump to next entry\n         BRCT  R3,D00230                and try again\n         J     D00480                   Not here, skip this UCB\n\nD00240   DS    0H\n*---------------------------------------------------------------------*\n*     This seems to be a volume in which we are interested. Bump the  *\n*    count of volumes eligible to be included in the table ...        *\n*---------------------------------------------------------------------*\n         L     R15,@D_Volume_Count      Get current count\n         AHI   R15,1                    Bump it\n         ST    R15,@D_Volume_Count      Save it\n\n*---------------------------------------------------------------------*\n*     ... get a pointer to the next free entry in our table, ...      *\n*---------------------------------------------------------------------*\n         LA    R1,@D_Parms              A(Parm list)\n         BRAS  R14,W00010               Get A(Next entry in VolTbl)\n         LTR   R15,R15                  Did we get one?\n         JNZ   D00480                   No, don't update it then\n\n*---------------------------------------------------------------------*\n*     ... bump the count of vol entries in the table ...              *\n*---------------------------------------------------------------------*\n         ICM   R15,B'1111',@_VolTbl_Ptr A(VolTbl)\n         JZ    D00480                   Nothing, skip\n         L     R0,VolTbl_Hdr_Vols_Total-VolTbl_Hdr(R15) Get curr count\n         AHI   R0,1                     Bump it\n         ST    R0,VolTbl_Hdr_Vols_Total-VolTbl_Hdr(R15) Save it\n\n*---------------------------------------------------------------------*\n*     ... add this UCB to our table, and format some info about it.   *\n*---------------------------------------------------------------------*\n         LR    R9,R1                    Get A(Free entry)\n         USING VolTbl_Ent,R9\n\n         OI    VolTbl_Ent_Detail_Line,L'VolTbl_Ent_Detail_Line\n         MVC   VolTbl_Ent_UCBCopy,@D_UCB Move UCB Copy\n         MVC   VolTbl_Ent_DCECopy,@D_DCE Move DCE Copy\n\n*---------------------------------------------------------------------*\n*     If we will be displaying detail lines, format what we           *\n*    currently have available                                         *\n*---------------------------------------------------------------------*\n         TM    @_No_Details,L'@_No_Details Producing detail lines?\n         JO    D00470                    No, skip the formatting stuff\n\n         MVC   VolTbl_Ent_DevAddr,@D_UCBNAME Readable device address\n         MVC   VolTbl_Ent_DevType,=CL8' ' Clear device type\n\n*---------------------------------------------------------------------*\n*   Format the device type and model, using SYS1.$UCLEUS(IECDI$IT@, *\n*    CSECT IECDDE)T.                                                  *\n*     This is an undocumented CSECT, but its format seems to be:      *\n*      DS    XL1        DCEOBRDT/UCBTBYT4                             *\n*        DS    XL1        ??                                          *\n*        DS    CL8        Device Type in EBCDIC                       *\n*                                                                     *\n*    There are generic device entries (i.e 3380, 3390@, where the 1st *\n*    byte matches UCBTBYT4, and specific entries (i.e. 3380K. 33909@  *\n*    where the 1st byte matches DCEOBRDT. We try to identify emulated *\n*    devices by finding entries matching both UCBTBYT4 and DCEOBRDT;  *\n*    if the non-blank portion of the UCBTBYT4 entry does not match the*\n*    DCEOBRDT entry, we assume we have an emulated device, and use    *\n*    the UCBTBYT4 device type, suffixed with \"*E*\".                   *\n*                                                                     *\n*     If we use the DCEOBRDT entry, we format it, if required, by     *\n*    inserting, if required, a dash(-@ after the 4th character if     *\n*    there is at least 1 trailing blank.                              * *\n*---------------------------------------------------------------------*\n         ICM   R1,B'1111',@D_IECDDEVT_Ptr A(IECDDEVT)?\n         JZ    D00240C                   Not yet, skip\n\n*---------------------------------------------------------------------*\n*    If this device is the same as the previous one in the table,     *\n*    merely copy the device type                                      *\n*---------------------------------------------------------------------*\n         LA    R15,VolTbl_Ent            A(Our entry)\n         AHI   R15,-VolTbl_Ent_Len       A(Previous entry)\n         CLC   VolTbl_Ent_UCBCopy+UCBTBYT4-UCBOB(L'UCBTBYT4),VolTbl_Ent+\n               _UCBCopy+UCBTBYT4-UCBOB-VolTbl_Ent(R15)\n         JNE   D00250                    Not same, check IECDDEVT\n         CLC   VolTbl_Ent_DCECopy+DCEOBRDT-DCE(L'DCEOBRDT),VolTbl_Ent_D+\n               CECopy+DCEOBRDT-DCE-VolTbl_Ent(R15)\n         JNE   D00250                    Not same, check IECDDEVT\n         MVC   VolTbl_Ent_DevType,VolTbl_Ent_DevType-VolTbl_Ent(R15)\n         J     D00280                    and skip\nD00240C  DS    0H\n         NUCLKUP BYNAME,                 Not yet, look it up           +\n               NAME='IECDDEVT',           this CSECT                   +\n               ADDR=(0)                   return address here\n         LTR   R15,R15                   Did we get it?\n         JZ    D00240E                   Yes, OK\n         LA    R0,1                      No, set invalid address\nD00240E  DS    0H\n         ST    R0,@D_IECDDEVT_Ptr        Yes, save the address\n         LR    R1,R0                     and load up\nD00250   DS    0H\n         TM    @D_IECDDEVT_Ptr+3,X'01'   Is it a valid address?\n         JO    D00280                    No, skip device type\n         SLR   R14,R14                   Clear A(UCBTBYT4 entry)\n         SLR   R15,R15                   Clear A(DCEOBRDT entry)\nD00250A  DS    0H\n         CLI   0(R1),X'00'               End of table?\n         JE    D00280                    Yes, no device type\n         LTR   R14,R14                   Found UCBTBYT4 already?\n         JNZ   D00250C                   Yes, skip\n         CLC   0(L'UCBTBYT4,R1),VolTbl_Ent_UCBCopy+UCBTBYT4-UCBOB Us?\n         JNE   D00250C                   No, skip\n         LA    R14,2(0,R1)               Yes, save the address\n         J     D00250E                   and skip\nD00250C  DS    0H\n         LTR   R15,R15                   Found DCEOBRDT entry?\n         JNZ   D00250E                   Yes, skip\n         CLC   0(L'DCEOBRDT,R1),VolTbl_Ent_DCECopy+DCEOBRDT-DCE Us?\n         JNE   D00250E                   No, skip\n         LA    R15,2(0,R1)               Yes, save the address\nD00250E  DS    0H\n         LTR   R14,R14                   Found UCBTBYT4 entry?\n         JZ    D00250G                   No, keep checking\n         LTR   R15,R15                   Yes, got DCEOBRDT entry too?\n         JNZ   D00260                    Yes, all done\nD00250G  DS    0H\n         AHI   R1,10                     A(Next entry)\n         J     D00250A                   and check it out\nD00260   DS    0H\n         LA    R1,7(0,R14)               A(End of UCBTBYT4 entry\nD00260C  DS    0H\n         CLI   0(R1),C' '                End of device type?\n         JNE   D00260E                   Yes, skip\n         AHI   R1,-1                     No, back up a byte\n         J     D00260C                   and keep checking\nD00260E  DS    0H\n         SR    R1,R14                    EX length of compare\n         EX    R1,D_CLC                  Compare entries\n         JE    D00260G                   Equal, use DCEOBRDT\n         MVC   VolTbl_Ent_DevType,0(R14) Move UCBTBYT4 device type\n         CLC   VolTbl_Ent_DevType+L'VolTbl_Ent_DevType-3(3),=CL8' '\n         JNE   D00280                    No room for flag, skip\n         LA    R1,VolTbl_Ent_DevType(R1) Point to last char\n         MVC   1(3,R1),=C'*E*'           Say it's emulated\n         J     D00280                    and skip\n\nD00260G  DS    0H\n         MVC   VolTbl_Ent_DevType,0(R15) Move DCEOBRDT device type\n         CLI   VolTbl_Ent_DevType+4,C' ' 4-char dev type?\n         JE    D00280                    Yes, all done\n         CLI   VolTbl_Ent_DevType+4,C'-' Already formatted?\n         JE    D00280                    Yes, all done\n         CLI   VolTbl_Ent_DevType+L'VolTbl_Ent_DevType-1,C' ' Trail sp?\n         JNE   D00280                    No, skip formatting\n         MVC   VolTbl_Ent_DevType+5(L'VolTbl_Ent_DevType-5),4(R15)\n*                                        Make room for a dash\n         MVI   VolTbl_Ent_DevType+4,C'-' and insert it\n\n\nD00280   DS    0H\n*---------------------------------------------------------------------*\n*     Format the Volser, and the Mount attribute ...                  *\n*---------------------------------------------------------------------*\n         MVC   VolTbl_Ent_Volser,VolTbl_Ent_UCBCOPY+UCBVOLI-UCBOB\n\n         TM    VolTbl_Ent_UCBCOPY+UCBFL5-UCBOB,UCBSMS SMS?\n         JZ    D00290                    Not SMS, skip\n         MVC   VolTbl_Ent_Attrib,=C'SMS' Say so\n         J     D00320                    and skip\n\nD00290   DS    0H\n         TM    VolTbl_Ent_UCBCOPY+UCBSTAB-UCBOB,UCBBPRV Private?\n         JZ    D00300                    No, skip\n         MVC   VolTbl_Ent_Attrib,=C'Pvt' Yes, say so\n         J     D00320                    and skip\nD00300   DS    0H\n         TM    VolTbl_Ent_UCBCopy+UCBSTAB-UCBOB,UCBBPUB Public?\n         JZ    D00310                    No, skip\n         MVC   VolTbl_Ent_Attrib,=C'Pub' Yes, say so\n         J     D00320                    and skip\nD00310   DS    0H\n         MVC   VolTbl_Ent_Attrib,=C'Stg' Indicate Storage\nD00320   DS    0H\n*---------------------------------------------------------------------*\n*     Get the CHPIDs for this device using UCBINFO PATHINFO ...       *\n*---------------------------------------------------------------------*\n         LA    R1,VolTbl_Ent_CHPIDs     A(Output area)\n         LHI   R15,8                    Max nbr we can use\nD00320C  DS    0H\n         MVC   0(2,R1),=C'--'           Init CHPID value\n         AHI   R1,4                     Bump pointer\n         BRCT  R15,D00320C              and do them all\n\n         UCBINFO PATHINFO,              Get path info                  +\n               DEVN=VolTbl_Ent_UCBCOPY+UCBCHAN-UCBOB, for this device  +\n               PATHAREA=@D_UCBINFO_Data, in here                       +\n               MF=(E,@D_UCBINFO)        staying re-entrant\n\n         LTR   R15,R15                  Anything good happen?\n         JNZ   D00370                   No, skip\n\n*---------------------------------------------------------------------*\n*     ... and format them, flagging those that are unavailable        *\n*---------------------------------------------------------------------*\n         LA    R15,@D_UCBINFO_Data      Address of PATHINFO data\n         L     R14,@D_UCBINFO_Data+PATH#CHPIDS-PATH Nbr CHPIDS\n         CHI   R14,8                    Too many?\n         JNH   D00330                   No, OK\n         LHI   R14,8                    Yes, only use 1st 8\nD00330   DS    0H\n         LA    R15,@D_UCBINFO_Data+PATHCHPIDARRAY-PATH A(1st CHP entry)\n         LA    R1,VolTbl_Ent_CHPIDs     A(Output area)\nD00340   DS    0H\n         LH    R0,PATHCHPID-PATHCHPIDARRAY(R15) Get CHPID\n         SLL   R0,4                     Make room for sign\n         ST    R0,@D_DBLWD+4            Save it\n         OI    @D_DBLWD+7,X'0F'         Add a sign\n         UNPK  @D_DBLWD(3),@D_DBLWD+6(2) Unpack it\n         TR    @D_DBLWD+1(2),D_TRTAB     Make it readable\n         MVC   0(2,R1),@D_DBLWD+1       Move CHPID\n         TM    PATHBITS-PATHCHPIDARRAY(R15),PATHPAM  Physically avail?\n         JO    D00350                   Yes, skip\n         MVI   2(R1),C'$'               No, mark it\n         OI    @D_CHPID_Unavail,L'@D_CHPID_Unavail and set our flag\n         J     D00360                   Skip\nD00350   DS    0H\n         TM    PATHBITS-PATHCHPIDARRAY(R15),PATHLPM  Logically avail?\n         JO    D00360                   Yes, skip\n         MVI   2(R1),C'-'               No, mark it\n         OI    @D_CHPID_Unavail,L'@D_CHPID_Unavail and set our flag\n         J     D00360                   Skip\nD00360   DS    0H\n         AHI   R1,4                     Bump pointer\n         AHI   R15,L'PATHCHPIDARRAY     Point to next CHPID\n         BRCT  R14,D00340               and try again\n\nD00370   DS    0H\n*---------------------------------------------------------------------*\n*     If this is an SMS UCB, set up the Storage Group Name and SMS    *\n*    status.                                                          *\n*---------------------------------------------------------------------*\n         TM    VolTbl_Ent_UCBCopy+UCBFL5-UCBOB,UCBSMS SMS?\n         JNO   D00460                  No, skip\n\n         TM    @D_SMS_Ptrs_OK,L'@D_SMS_Ptrs_OK Do we already have it?\n         JO    D00380                  Yes, skip\n\n         TM    @D_SMS_Unavail,L'@D_SMS_Unavail Is SMS there?\n         JO    D00460                  No, skip\n\n         LA    R15,VolTbl_Ent_Volser   A(Volser)\n         ST    R15,@D_Parms_T00010     Save it\n         LA    R15,@D_VLD_Anchor       A(VLD Anchor)\n         ST    R15,@D_Parms_T00010+4   Save it\n\n         LA    R1,@D_Parms              A(Parm list)\n         BRAS  R14,T00010              Go get Storgrp, status\n\n         STM   R0,R1,@D_SMS_Ptrs       Save the results\n         CHI   R15,4                   How did it go?\n         JL    D00380                  OK, skip\n         JE    D00460                  STORGRP not found, skip this vol\n         OI    @D_SMS_Unavail,L'@D_SMS_Unavail No SMS, set flag\n         J     D00460                  and skip this vol\n\nD00380   DS    0H\n         L     R15,@D_SMS_Ptrs+4             A(STORGRP Len, name)\n         LH    R14,0(0,R15)                  Get len of STORGRP\n         LHI   R0,L'VolTbl_Ent_SMS_StorGrp   Len of output field\n         CR    R14,R0                        Too big?\n         JNH   D00390                        No, OK\n         LR    R14,R0                        Yes, reset it\nD00390   DS    0H\n         AHI   R14,-1                        EX Length\n         AHI   R15,2                         A(STORGRP)\n         LA    R1,VolTbl_Ent_SMS_StorGrp     A(Target field)\n         EX    R14,D_MVC\n\n         ICM   R15,B'1111',@D_SMS_Ptrs       A(SMS Status)\n         JZ    D00450                        None, we don't know\n\n         CLI   0(R15),VLD0                   Any status?\n         JNE   D00400                        No, skip\n         MVC   VolTbl_Ent_SMS_Status,=CL(L'VolTbl_Ent_SMS_Status)'None'\n         J     D00470                        and skip\nD00400   DS    0H\n         CLI   0(R15),VLDENBL                Enabled?\n         JNE   D00410                        No, skip\n         MVC   VolTbl_Ent_SMS_Status,=CL(L'VolTbl_Ent_SMS_Status)'Enabl+\n               ed'\n         J     D00470                        and skip\nD00410   DS    0H\n         CLI   0(R15),VLDQUI                 Quiesced/All?\n         JNE   D00420                        No, skip\n         MVC   VolTbl_Ent_SMS_Status,=CL(L'VolTbl_Ent_SMS_Status)'Quies+\n               ced/All'\n         J     D00470                        and skip\nD00420   DS    0H\n         CLI   0(R15),VLDQUIN                Quiesced/New?\n         JNE   D00430                        No, skip\n         MVC   VolTbl_Ent_SMS_Status,=CL(L'VolTbl_Ent_SMS_Status)'Quies+\n               ced/New'\n         J     D00470                        and skip\nD00430   DS    0H\n         CLI   0(R15),VLDDIS                 Disabled/All?\n         JNE   D00440                        No, skip\n         MVC   VolTbl_Ent_SMS_Status,=CL(L'VolTbl_Ent_SMS_Status)'Disab+\n               led/All'\n         J     D00470                        and skip\nD00440   DS    0H\n         CLI   0(R15),VLDDISN                Disabled/New?\n         JNE   D00450                        No, skip\n         MVC   VolTbl_Ent_SMS_Status,=CL(L'VolTbl_Ent_SMS_Status)'Disab+\n               led/New'\n         J     D00470                        and skip\nD00450   DS    0H\n         MVC   VolTbl_Ent_SMS_Status,=CL(L'VolTbl_Ent_SMS_Status)'Unkno+\n               wn'\n         J     D00470                        and skip\nD00460   DS    0H\n         MVC   VolTbl_Ent_SMS_StorGrp(3),=C'N/A' Move literal\n         MVC   VolTbl_Ent_SMS_Status(3),=C'N/A' and again\n         J     D00470                        and skip\n\nD00470   DS    0H\n*---------------------------------------------------------------------*\n*     If we are not going to be doing LSPACEs, mark this entry as     *\n*    complete ...                                                     *\n*---------------------------------------------------------------------*\n         TM    @_No_LSPACE,L'@_No_LSPACE     Doing LSPACE?\n         JNO   D00480                        Yes, skip\n         OI    VolTbl_Ent_Processed,L'VolTbl_Ent_Processed\n         OI    VolTbl_Ent_ECB,X'40'          'POST' as complete\n\nD00480   DS    0H\n*---------------------------------------------------------------------*\n*     ... and go get the next UCB, unless we are doing a single       *\n*    volser                                                           *\n*---------------------------------------------------------------------*\n         TM    @D_Single_Volser,L'@D_Single_Volser  Specific volser?\n         JO    D00490                   Yes, no need to keep checking\n         J     D00050                   No, do next UCB\n\nD00490   DS    0H\n*---------------------------------------------------------------------*\n*     Check to see if we found any UCBs                               *\n*---------------------------------------------------------------------*\n         ICM   R0,B'1111',@D_Volume_Count Any UCBs?\n         JNZ   D00540                   Yes, skip\n\n*---------------------------------------------------------------------*\n*   We couldn't find any UCBs - if we are selecting by UCB number,    *\n*  the user may have assumed a 3-byte UCB address, and we have been   *\n*  looking for 4-byte addresses. If this is the case, we add a '0'    *\n*  in front of the UCB address, and do all this again. We limit the   *\n*  re-iterations based on the entered UCB mask(s) - for example, we   *\n*  will reiterate for UCB(x??), but not for UCB(x???).                *\n*                                                                     *\n*   We assume (big mistake!) that the user has been consistent in     *\n*  specifying 3-digit UCBs in both UCB and XUCB - when we adjust an   *\n*  entry in UCB_List, if there is a subset of it in XUCB_List, we     *\n*  adjust it too.                                                     *\n*---------------------------------------------------------------------*\n         TM    @D_Eligible_UCB_Found,L'@D_Eligible_UCB_Found Any UCBs?\n         JO    D00540                   Yes, skip\n         ICM   R1,B'1111',@_UCB_List_Ptr A(UCB selection list)\n         JZ    D00540                   None, skip\n         NI    @D_UCB_Addr_Updated,X'FF'-L'@D_UCB_Addr_Updated\n\n         ICM   R3,B'1111',UCB_List_Hdr_Count-UCB_List_Hdr(R1)  Nbr UCBs\n         JZ    D00540                   None, skip\n         AHI   R1,UCB_List_Ent-UCB_List  Point to 1st\nD00500   DS    0H\n         CLI   UCB_List_Ent_UCB+L'UCB_List_Ent_UCB-1-UCB_List_Ent(R1),X+\n               'FF'                     Trailing wildcard?\n         JNE   D00530                   No, skip\n         CLI   UCB_List_Ent_UCB_Len-UCB_List_Ent(R1),L'@D_UCBNAME Adj?\n         JNL   D00530                   No, skip\n         LA    R0,0                     Yes, clear work reg\n         IC    R0,UCB_List_Ent_UCB_Len-UCB_List_Ent(R1) Entered len\n         AHI   R0,1                     Bump it\n         STC   R0,UCB_List_Ent_UCB_Len-UCB_List_Ent(R1) Entered len\n         L     R0,UCB_List_Ent_UCB-UCB_List_Ent(R1) Get the UCB\n         ST    R0,@D_DBLWD              Save it\n         SRL   R0,8                     Shift over 1 byte\n         ST    R0,UCB_List_Ent_UCB-UCB_List_Ent(R1) Save it\n         MVI   UCB_List_Ent_UCB-UCB_List_Ent(R1),C'0'  Leading 0\n         L     R0,UCB_List_Ent_Mask-UCB_List_Ent(R1) Get wildcard mask\n         SRL   R0,8                     Shift it right too\n         ST    R0,UCB_List_Ent_Mask-UCB_List_Ent(R1) Save it as well\n         OI    @D_UCB_Addr_Updated,L'@D_UCB_Addr_Updated UCB changed\n         ICM   R4,B'1111',@_XUCB_List_Ptr A(Excluded UCBs)\n         JZ    D00530                   None, skip\n\n         L     R5,UCB_List_Hdr_Count-UCB_List_Hdr(R4)  Count of UCBs\n         AHI   R4,UCB_List_Ent-UCB_List  Point to 1st\nD00510   DS    0H\n         CLI   UCB_List_Ent_UCB+L'UCB_List_Ent_UCB-1-UCB_List_Ent(R4),X+\n               'FF'                     Trailing wildcard?\n         JNE   D00520                   No, skip\n         CLI   UCB_List_Ent_UCB_Len-UCB_List_Ent(R4),L'@D_UCBNAME Adj?\n         JNL   D00520                   No, skip\n         LA    R0,0                     Yes, clear work reg\n         IC    R0,UCB_List_Ent_UCB_Len-UCB_List_Ent(R4) Entered len\n         AHI   R0,1                     Bump it\n         STC   R0,UCB_List_Ent_UCB_Len-UCB_List_Ent(R4) Entered len\n         L     R0,UCB_List_Ent_UCB-UCB_List_Ent(R4) Yes, get UCB\n         ST    R0,@D_DBLWD+4            Save it\n         OC    @D_DBLWD+4(L'UCB_List_Ent_UCB),UCB_List_Ent_Mask-UCB_Lis+\n               t_Ent(R1)                Reset wildcard characters\n         CLC   @D_DBLWD(L'UCB_List_Ent_UCB),@D_DBLWD+4  Subset of Incl?\n         JNE   D00520                   No, skip\n         SRL   R0,8                     Shift over 1 byte\n         ST    R0,UCB_List_Ent_UCB-UCB_List_Ent(R4) Save it\n         MVI   UCB_List_Ent_UCB-UCB_List_Ent(R4),C'0'  Leading 0\n         L     R0,UCB_List_Ent_Mask-UCB_List_Ent(R4) Get wildcard mask\n         SRL   R0,8                     Shift it right too\n         ST    R0,UCB_List_Ent_Mask-UCB_List_Ent(R4) Save it as well\n\nD00520   DS    0H\n         AHI   R4,UCB_List_Ent_Length   Bump to next entry\n         BRCT  R5,D00510                and process it\n\nD00530   DS    0H\n         AHI   R1,UCB_List_Ent_Length   Bump to next entry\n         BRCT  R3,D00500                and process it\n\n         TM    @D_UCB_Addr_Updated,L'@D_UCB_Addr_Updated Any changes?\n         JO    D00040                   Yes, try again\n\nD00540   DS    0H\n*---------------------------------------------------------------------*\n*     We have finished all our UCBs; update the total eligible vol    *\n*    count, and, if no entries, flag it as complete ...               *\n*---------------------------------------------------------------------*\n         ICM   R15,B'1111',@_VolTbl_Ptr A(VolTbl)\n         JZ    D00800                   Nothing, skip\n         L     R0,@D_Volume_Count       Total eligible volumes\n         ST    R0,VolTbl_Hdr_Vols_Eligible-VolTbl_Hdr(R15)\n\n         ICM   R0,B'1111',VolTbl_Hdr_Vols_Total-VolTbl_Hdr(R15) Any?\n         JZ    D00790                   No, POST table as complete\n\n*---------------------------------------------------------------------*\n*     ... and, if we are doing totals, create and populate (as much   *\n*    as we can) the Totals line ...                                   *\n*---------------------------------------------------------------------*\n         TM    @_No_Totals,L'@_No_Totals Doing Totals?\n         JO    D00590                   No, skip\n\n         LA    R1,@D_Parms              A(Parm list)\n         BRAS  R14,W00010               A(Next free entry)\n         LTR   R15,R15                  Did we get one?\n         JNZ   D00590                   No, skip\n         LR    R9,R1                    Yes, point to it\n\n         L     R15,@_VolTbl_Ptr          A(VolTbl)\n         SR    R1,R15                    Offset of Totals Line\n         ST    R1,VolTbl_Hdr_Total_Off-VolTbl_Hdr(R15) Save it\n\n         OI    VolTbl_Ent_Total_Line,L'VolTbl_Ent_Total_Line\n         L     R15,@_VolTbl_Ptr          A(VolTbl)\n         L     R0,VolTbl_Hdr_Vols_Total-VolTbl_Hdr(R15) Nbr vols\n         CVD   R0,@D_DBLWD               Pack it\n         MVC   VolTbl_Ent_DevType(7),=X'4020206B202120' Move mask\n         ED    VolTbl_Ent_DevType(7),@D_DBLWD+5 Edit in count\n\n         ICM   R1,B'1111',@_XVol_List_Ptr Excluding by vol?\n         JNZ   D00550                   Yes, leave volser blank\n         ICM   R1,B'1111',@_Vol_List_Ptr No, selecting by vol?\n         JZ    D00550                   No, set vol to asterisks\n         CLC   =FL4'1',4(R1)            Yes, a single volser?\n         JNE   D00550                   No, leave volser blank\n         MVC   VolTbl_Ent_Volser,8(R1)  Yes, move volser mask\n         TR    VolTbl_Ent_Volser,D_TrTbl and Xlate X'FF' to '*'\n         J     D00550                   and skip\n\nD00550   DS    0H\n         ICM   R1,B'1111',@_XUCB_List_Ptr Excluding by UCB?\n         JNZ   D00560                   Yes, leave UCB blank\n         ICM   R1,B'1111',@_UCB_List_Ptr No, selecting by UCB?\n         JZ    D00560                   No, set UCB to asterisks\n         L     R0,UCB_List_Hdr_Count-UCB_List_Hdr(R1)  Get Nbr masks\n         C     R0,=FL4'1'               A single UCB?\n         JNE   D00560                   No, leave UCB blank\n         AHI   R1,UCB_List_Ent-UCB_List Yes, point to it\n         MVC   VolTbl_Ent_DevAddr,UCB_List_Ent_UCB-UCB_List_Ent(R1)\n         TR    VolTbl_Ent_DevAddr,D_TrTbl and Xlate X'FF' to '*'\n         J     D00560                   and skip\n\nD00560   DS    0H\n         MVC   VolTbl_Ent_Attrib,=CL8' ' No attributes\n\n         ICM   R1,B'1111',@_STORGRP_List_Ptr Selecting by StorGrp?\n         JZ    D00570                   No, skip\n         CLC   =FL4'1',4(R1)            Yes, a single STORGRP?\n         JNE   D00570                   No, leave blank\n         MVC   VolTbl_Ent_SMS_StorGrp,8(R1) Yes, move mask\n         TR    VolTbl_Ent_SMS_StorGrp,D_TrTbl and Xlate X'FF' to '*'\n         J     D00570                   and skip\n\nD00570   DS    0H\n*---------------------------------------------------------------------*\n*     If a CHPID was not physically or logically available, put out   *\n*    a message in the CHPID area of the totals line.                  *\n*---------------------------------------------------------------------*\n         TM    @D_CHPID_Unavail,L'@D_CHPID_Unavail  CHPIDs OK?\n         JNO   D00580                   Yes, OK\n         MVC   VolTbl_Ent_CHPIDs(L'D_CHPID_Msg),D_CHPID_Msg No, msg\n\nD00580   DS    0H\n*---------------------------------------------------------------------*\n*     If we will not be doing LSPACEs, mark the Totals line as        *\n*    complete                                                         *\n*---------------------------------------------------------------------*\n         TM    @_No_LSPACE,L'@_No_LSPACE Doing LSPACEs?\n         JNO   D00590                   Yes, OK\n         OI    VolTbl_Ent_Processed,L'VolTbl_Ent_Processed\n         OI    VolTbl_Ent_ECB,X'40'     and POST as complete\n\nD00590   DS    0H\n*---------------------------------------------------------------------*\n*     If we will be doing LSPACEs, get a line for the SMS Anomaly     *\n*    message                                                          *\n*---------------------------------------------------------------------*\n         TM    @_No_LSPACE,L'@_No_LSPACE  Doing LSPACE?\n         JO    D00600                   No, skip\n\n         LA    R1,@D_Parms              A(Parm list)\n         BRAS  R14,W00010               A(Next entry in VolTbl)\n         LTR   R15,R15                  Did we get one?\n         JNZ   D00600                   No, skip\n         LR    R9,R1                    Yes, point to it\n\n         L     R15,@_VolTbl_Ptr          A(VolTbl)\n         SR    R1,R15                    Offset of SMS Anomaly Line\n         ST    R1,VolTbl_Hdr_SMS_Off-VolTbl_Hdr(R15) Clear offset\n\n         OI    VolTbl_Ent_Detail_Line,L'VolTbl_Ent_Detail_Line\n         OI    VolTbl_Ent_SMS_Line,L'VolTbl_Ent_SMS_Line SMS Anomaly\n\nD00600   DS    0H\n*---------------------------------------------------------------------*\n*     Get processor-related data                                      *\n*---------------------------------------------------------------------*\n         XC    @_LP_Count,@_LP_Count    Make sure LP Count is 0\n         MVI   @D_CSRSI_Manuf,C' '      Clear Manufacturer ID\n         MVC   @D_CSRSI_Manuf+1(L'@D_CSRSI_Manuf-1),@D_CSRSI_Manuf\n         MVC   @D_CSRSI_Type,@D_CSRSI_Manuf Clear Type\n         MVC   @D_CSRSI_Model,@D_CSRSI_Manuf Clear Model\n         MVC   @D_CSRSI_Serial,@D_CSRSI_Manuf Clear Serial\n\n         L     R15,CVTPTR               A(CVT)\n         TM    CVTDCB-CVT(R15),CVTOSEXT Is OSLVL OK?\n         JZ    D00600Z                  No, crawl through control blks\n         TM    CVTOSLV4-CVT(R15),CVTCSRSI Yes, can we use CSRSI?\n         JZ    D00600Z                  No, use control blocks\n\n*---------------------------------------------------------------------*\n*     We will be using CSRSI to get the processor-related data - go   *\n*    build the parm list ...                                          *\n*---------------------------------------------------------------------*\n         L     R0,=AL4(SIV1V2V3_LEN)    Length of return data\n\n         BASR  R2,0\n         USING (*,D00600_End-1),R2\n         STORAGE OBTAIN,                Go get some storage            +\n               LENGTH=(0)                this long\nD00600_End DS  0H\n         ST    R1,@D_CSRSI_Parm+8       Save A(Info area)\n         LA    R15,=AL4(CSRSI_REQUEST_V1CPC_MACHINE+CSRSI_REQUEST_V2CPC+\n               _LPAR+CSRSI_REQUEST_V3CPC_VM) All data requested\n         ST    R15,@D_CSRSI_Parm        Save request code\n         LA    R15,=AL4(SIV1V2V3_Len)   A(Length of Info area)\n         ST    R15,@D_CSRSI_Parm+4      Save length in parm list\n         LA    R15,@D_DBLWD             A(Return code area)\n         ST    R15,@D_DBLWD+4           Save it\n         LA    R15,@D_DBLWD+4           A(Return code area pointer)\n         ST    R15,@D_CSRSI_Parm+12     Save in parm list\n\n*---------------------------------------------------------------------*\n*     ... and issue CSRSI                                             *\n*---------------------------------------------------------------------*\n         BASR  R2,0\n         USING (*,D00600A_End-1),R2\n         LOAD  EP=CSRSI                 Go get machine info module\nD00600A_End DS  0H\n         LTR   R15,R15                  Did it work\n         JNZ   D00600X                  No, skip\n         LR    R15,R0                   Yes, save EP\n         LA    R1,@D_CSRSI_Parm         A(Parmlist)\n         BASR  R14,R15                  Go do it\n         DELETE EP=CSRSI                Don't need CSRSI anymore\n         L     R15,@D_DBLWD             Get CSRSI return code\n         CHI   R15,CSRSI_STSINOTAVAILABLE Did we get anything?\n         JH    D00600X                  No, skip\n\n*---------------------------------------------------------------------*\n*     We seem to have some valid data back from CSRSI, so save the    *\n*    bits we need.                                                    *\n*---------------------------------------------------------------------*\n         L     R15,@D_CSRSI_Parm+8      A(CSRSI Data)\n         TM    SI00VALIDITYFLAGS-SI00(R15),SI00VALIDSI11V1 V1 valid?\n         JZ    D00600C                  No, skip\n         A     R15,=AL4(SI00_LEN)       Yes, bump to V1 Data area\n         MVC   @D_CSRSI_Manuf,SI11V1CPCMANUFACTURER-SI11V1(R15)\n         MVC   @D_CSRSI_Type,SI11V1CPCTYPE-SI11V1(R15)\n         MVC   @D_CSRSI_Model,SI11V1CPCMODEL-SI11V1(R15)\n         MVC   @D_CSRSI_Serial,SI11V1CPCSEQUENCECODE+L'SI11V1CPCSEQUENC+\n               ECODE-L'@D_CSRSI_Serial-SI11V1(R15)\nD00600C  DS    0H\n         L     R15,@D_CSRSI_Parm+8      A(CSRSI Data)\n         TM    SI00VALIDITYFLAGS-SI00(R15),SI00VALIDSI22V3 VM valid?\n         JZ    D00600E                  No, skip\n         A     R15,=AL4(SIV1V2_LEN)     Yes, bump to VM Data area\n         LA    R0,0                     Clear work reg\n         IC    R0,SI22V3DBCOUNTFIELD-SI22V3(0,R15) Nbr V3 Desc Blks\n         SLL   R0,28                    Clean\n         SRL   R0,28                     it\n         AHI   R0,-1                    Relative to 0\n         MH    R0,=AL2(SI22V3DB_LEN)    Offset of last\n         LA    R15,SI22V3DBS-SI22V3(0,R15) Point to first\n         ALR   R15,R0                   and then to last\n         LH    R0,SI22V3DBCONFIGUREDLCPUCOUNT-SI22V3DB(R15) LCPUs\n         ST    R0,@_LP_Count            Save it\n         J     D00600X                  and skip\nD00600E  DS    0H\n         L     R15,@D_CSRSI_Parm+8      A(CSRSI Data)\n         TM    SI00VALIDITYFLAGS-SI00(R15),SI00VALIDSI22V2 LPAR valid?\n         JZ    D00600G                  No, skip\n         A     R15,=AL4(SIV1_LEN)       Yes, bump to LPAR Data area\n         LH    R0,SI22V2CONFIGUREDLCPUCOUNT-SI22V2(R15) LCPUs\n         ST    R0,@_LP_Count            Save it\n         J     D00600X                  and skip\nD00600G  DS    0H\n         L     R15,@D_CSRSI_Parm+8      A(CSRSI Data)\n         TM    SI00VALIDITYFLAGS-SI00(R15),SI00VALIDSI22V1 Mach OK?\n         JZ    D00600X                  No, skip\n         A     R15,=AL4(SI00_LEN+SI11V1_LEN) Bump to CPC Data area\n         LH    R0,SI22V1CONFIGUREDCPUCOUNT-SI22V1(R15) CPUs\n         ST    R0,@_LP_Count            Save it\n         J     D00600X                  and skip\n\nD00600X  DS    0H\n         L     R0,=AL4(SIV1V2V3_LEN)    Length of return data\n         L     R1,@D_CSRSI_Parm+8       A(Start)\n\n         BASR  R2,0\n         USING (*,D00600X_End-1),R2\n         STORAGE RELEASE,               Free CSRSI storage             +\n               ADDR=(1),                 starting here                 +\n               LENGTH=(0)                for this long\nD00600X_End DS  0H\n\n         LA    R15,0                    Clear work reg\n         ST    R15,@D_CSRSI_Parm+4      Clear storage length\n         ST    R15,@D_CSRSI_Parm+8         and address\n\nD00600Z  DS    0H\n*---------------------------------------------------------------------*\n*     We will be crawling through control blocks to get the processor *\n*    related info. Get the CPU-type data (Type, model, etc.)          *\n*---------------------------------------------------------------------*\n         CLI   @D_CSRSI_Manuf,C' '       Do we have CPU Data?\n         JNE   D00608                    Yes, skip\n         L     R15,CVTPTR                No, A(CVT)\n         L     R15,CVTHID-CVT(R15)       A(Host ID Table)\n         TM    CPCND_FLAGS-SHID(R15),CPCND_INVAL OK?\n         JO    D00602                    No, skip type info\n         MVC   @D_CSRSI_Manuf(L'CPCND_MAN),CPCND_MAN-SHID(R15)\n         MVC   @D_CSRSI_Type(L'CPCND_TYPE),CPCND_TYPE-SHID(R15)\n         MVC   @D_CSRSI_Model(L'CPCND_MODEL),CPCND_MODEL-SHID(R15)\nD00602   DS    0H\n         L     R15,CVTPTR                A(CVT)\n         L     R15,CVTPCCAT-CVT(R15)     A(PCCA Table)\n         LHI   R14,16                    Max of 16 CPUs\nD00604   DS    0H\n         ICM   R0,B'1111',0(R15)         Get A(PCCA) for this CPU\n         JNZ   D00606                    CPU Active, skip\n         AHI   R15,4                     No, point to next\n         BRCT  R14,D00604                and check again\n         J     D00608                    None(?), ignore it\nD00606   DS    0H\n         LR    R15,R0                    Point to PCCA\n         MVC   @D_CSRSI_Serial,PCCACPID+4-PCCA(R15)  Serial number\n\nD00608   DS    0H\n*---------------------------------------------------------------------*\n*     Go get the number of CPUs, if required                          *\n*---------------------------------------------------------------------*\n         ICM   R1,B'1111',@_LP_Count    Do we have an LP count?\n         JNZ   D00625                   Yes, skip\n         L     R15,CVTPTR               A(CVT)\n         L     R15,CVTLCCAT-CVT(R15)    A(LCCAVT)\n         LHI   R14,16                   Max number of CPUs\n         LA    R1,0                     Count of CPUs\nD00610   DS    0H\n         ICM   R0,B'1111',0(R15)        Get A(LCCA) for this CPU\n         JZ    D00620                   None, skip\n         AHI   R1,1                     OK, bump CPU count\nD00620   DS    0H\n         AHI   R15,4                    Bump to next LCCA pointer\n         BRCT  R14,D00610               and check it out\n         ST    R1,@_LP_Count            Save it\n\nD00625   DS    0H\n*---------------------------------------------------------------------*\n*     ... and initialize @_SubTask_Count to either MAXTASKS or        *\n*      MIN(Volumes, (2*#_Logical_Processors)+1)                       *\n*---------------------------------------------------------------------*\n         LH    R0,@_MaxTasks            Get MaxTasks specification\n         LTR   R0,R0                    Any?\n         JP    D00630                   Yes, skip\n         LR    R0,R1                    No, use #LPs\n         SLL   R0,1                      doubled\n         AHI   R0,1                      + 1\nD00630   DS    0H\n         AIF   (&Max_SubTask_Count LT 1).Max_SubTask_Count_020\n         CHI   R0,&Max_SubTask_Count    Is it > max?\n         JNH   D00630C                  No, OK\n         LHI   R0,&Max_SubTask_Count    Yes, use max\nD00630C  DS    0H\n.Max_SubTask_Count_020 ANOP\n         ST    R0,@_SubTask_Count       and update it\n\n         LA    R0,0                     Clear UCB count\n         ICM   R9,B'1111',@_VolTbl_Ptr A(Table of Volumes)\n         JZ    D00650                   None, skip\n         ICM   R10,B'1111',VolTbl_Hdr_Count-VolTbl_Hdr(R9) Get count\n         JZ    D00650                   None, skip\n         AHI   R9,VolTbl_Ent-VolTbl     Point to 1st entry\nD00640   DS    0H\n         TM    VolTbl_Ent_Detail_Line,L'VolTbl_Ent_Detail_Line UCB?\n         JNO   D00640C                  Not Detail line, skip\n         TM    VolTbl_Ent_SMS_Line,L'VolTbl_Ent_SMS_Line SMS Anomaly?\n         JO    D00640C                  Not really a UCB, skip\n         AHI   R0,1                     Bump UCB count\nD00640C  DS    0H\n         AHI   R9,VolTbl_Ent_Len        A(Next entry)\n         BRCT  R10,D00640               and check again\n\nD00650   DS    0H\n*---------------------------------------------------------------------*\n*     Use the lesser of UCB count and @_SubTask_Count for our         *\n*    number of subtasks                                               *\n*---------------------------------------------------------------------*\n         C     R0,@_SubTask_Count       Check against nbr subtasks\n         JNL   D00660                   OK, skip\n         ST    R0,@_SubTask_Count       Too few UCBs, use UCB count\n\nD00660   DS    0H\n*---------------------------------------------------------------------*\n*     If we will be doing Statistics, ...                             *\n*---------------------------------------------------------------------*\n         TM    @_Statistics,L'@_Statistics Doing stats?\n         JNO   D00780                    No, skip\n\n*---------------------------------------------------------------------*\n*    ... move the non-execution-related stats lines ...               *\n*---------------------------------------------------------------------*\n         LA    R2,D_Stats_Line_Ptrs      A(Start of line pointers)\n         SLR   R3,R3                     Clear count\nD00660C  DS    0H\n         LA    R1,@D_Parms               A(Parm list)\n         BRAS  R14,W00010                Get A(Next entry)\n         LTR   R15,R15                   Did we get one?\n         JNZ   D00780                    No, skip\n         LR    R9,R1                     Yes, point to it\n         L     R15,0(0,R2)               A(Stats line)\n         LH    R14,0(0,R15)              Get length of stats line\n         AHI   R14,-1                    EX len\n         EX    R14,D_MVC1                Move it\n\n         OI    VolTbl_Ent_Stats_Line,L'VolTbl_Ent_Stats_Line\n         OI    VolTbl_Ent_Processed,L'VolTbl_Ent_Processed Mark as done\n         OI    VolTbl_Ent_Stats_Done,L'VolTbl_Ent_Stats_Done Done\n         OI    VolTbl_Ent_ECB,X'40'      POST as done\n\n         AHI   R3,1                      Bump count\n         CHI   R3,3                      1st execution line?\n         JNE   D00680E                   No, skip\n\n\n         MVC   @D_TIME,D_TIME           Move L-Form of macro\n         TIME  DEC,                     Get time                       +\n               @D_Time_Area,             and return it here            +\n               LINKAGE=SYSTEM,           don't use the SVC             +\n               DATETYPE=YYYYMMDD,        format of returned data       +\n               MF=(E,@D_TIME)            addr of macro list\n         L     R0,@D_Time_Area          Get the time\n         SRL   R0,12                    Shift out seconds and 100s\n         ST    R0,@D_Time_Area          Save it\n         OI    @D_Time_Area+3,X'0F'     OR in a sign\n         MVC   @D_WkArea(7),=X'402120204B2020' Time mask\n         ED    @D_WkArea(7),@D_Time_Area+1 Make it readable\n         MVC   VolTbl_Ent_Display+D_Stats_Line3_Time-D_Stats_Line3(L'D_+\n               Stats_Line3_Time),@D_WkArea+2\n         L     R15,@D_Time_Area+8       Get Date (yyyymmdd)\n         LA    R14,0                    Clear work register\n         SLDL  R14,4                    Make room for sign\n         STM   R14,R15,@D_Time_Area     Save it\n         OI    @D_Time_Area+7,X'0F'     OR in a sign\n         MVC   @D_WkArea(12),=X'402120202020602020602020'  Date mask\n         ED    @D_WkArea(12),@D_Time_Area+3 Make it readable\n         MVC   VolTbl_Ent_Display+D_Stats_Line3_Date-D_Stats_Line3(L'D_+\n               Stats_Line3_Date),@D_WkArea+2\n\n         L     R14,CVTPTR               A(CVT)\n         L     R15,CVTECVT-CVT(0,R14)   A(EVCT)\n         MVC   VolTbl_Ent_Display+D_Stats_Line3_SysVer-D_Stats_Line3(L'+\n               ECVTPNAM),ECVTPNAM-ECVT(R15)\n         LA    R1,VolTbl_Ent_Display+D_Stats_Line3_SysVer+L'ECVTPNAM-1-+\n               D_Stats_Line3           A(Last char)\n         LA    R0,VolTbl_Ent_Display+D_Stats_Line3_SYSVer-D_Stats_Line3\nD00670   DS    0H\n         CLI   0(R1),C' '               Last significant character\n         JNE   D00680                   Yes, skip\n         S     R1,=FL4'1'               No, back up a byte\n         CR    R1,R0                    Too far?\n         JH    D00670                   No, check again\nD00680   DS    0H\n         AIF   (NOT D'CVTZOSE).D00680_010\n         TM    CVTOSLV5-CVT(R14),CVTZOSE z/OS.e?\n         JZ    D00680C                  No, skip\n         MVC   1(2,R1),=C'.e'           Yes, say so\n         LA    R1,2(0,R1)               and bump pointer\nD00680C  DS    0H\n.D00680_010 ANOP\n         MVC   2(L'ECVTPVER,R1),ECVTPVER-ECVT(R15)  Version\n         MVI   2+L'ECVTPVER(R1),C'.'    Separator\n         MVC   2+L'ECVTPVER+1(L'ECVTPREL,R1),ECVTPREL-ECVT(R15) Rel\n         MVI   2+L'ECVTPVER+1+L'ECVTPREL(R1),C'.'    Separator\n         MVC   2+L'ECVTPVER+1+L'ECVTPREL+1(L'ECVTPMOD,R1),ECVTPMOD-ECVT+\n               (R15)\n\nD00680E  DS    0H\n         CHI   R3,4                      2nd execution stats line?\n         JNE   D00750C                   No, skip\n\n         L     R15,CVTPTR                A(CVT)\n         MVC   VolTbl_Ent_Display+D_Stats_Line4_SNAME-D_Stats_Line4(L'C+\n               VTSNAME),CVTSNAME-CVT(R15)\n         LA    R1,VolTbl_Ent_Display+D_Stats_Line4_SNAME+L'CVTSNAME-1-D+\n               _Stats_Line4              A(Last char)\nD00690   DS    0H\n         CLI   0(R1),C' '                Trailing Blank?\n         JNE   D00700                    No, skip\n         S     R1,=FL4'1'                Yes, back up a byte\n         J     D00690                    and try again\nD00700   DS    0H\n         MVI   2(R1),C'('                Open paren\n         AHI   R1,3                      Point to next byte\n         MVC   0(L'@D_CSRSI_Manuf,R1),@D_CSRSI_Manuf Move manufacturer\n         LA    R1,L'@D_CSRSI_Manuf-1(0,R1) A(Last character)\nD00702   DS    0H\n         CLI   0(R1),C' '                Trailing blank?\n         JNE   D00704                    No, OK\n         BRCT  R1,D00702                 Yes, back up a byte\nD00704   DS    0H\n         MVI   1(R1),C' '                Move separator\n         MVC   2(L'@D_CSRSI_Type,R1),@D_CSRSI_Type\n         MVI   2+L'@D_CSRSI_Type(R1),C'-' Separator\n         MVC   2+L'@D_CSRSI_Type+1(L'@D_CSRSI_Model,R1),@D_CSRSI_Model\n         LA    R1,2+L'@D_CSRSI_Type+L'@D_CSRSI_Model(0,R1)\nD00706   DS    0H\n         CLI   0(R1),C' '                Trailing blank?\n         JNE   D00708                    No, OK\n         BRCT  R1,D00706                 Yes, back up and check again\nD00708   DS    0H\n         MVC   1(8,R1),=C', CPUID '      Literal\n         MVC   9(L'@D_CSRSI_Serial,R1),@D_CSRSI_Serial\n         MVI   9+L'@D_CSRSI_Serial(R1),C')'  Trailing paren\n         LA    R1,10+L'@D_CSRSI_Serial(0,R1) A(Next byte)\n\nD00740   DS    0H\n         MVC   0(5,R1),=C' with'         Start of literal\n         AHI   R1,5                      A(Next byte)\n         TM    @_OW48527,L'@_OW48527     APAR OW48527 on?\n         JO    D00750                    Yes, skip\n         MVC   0(3,R1),=C'out'           No, say so\n         AHI   R1,3                      A(Next byte)\nD00750   DS    0H\n         MVC   0(9,R1),=C' OW48527.'     Finish it off\n\nD00750C  DS    0H\n         CHI   R3,D_Stats_Line_Count     Any more to do?\n         JNL   D00750E                   No, skip\n         AHI   R2,4                      Yes, bump to next pointer\n         J     D00660C                   and go do it\n\nD00750E  DS    0H\n*-------------------------------------------------------------------*\n*    ... 2 more for the Stack statistics ...                        *\n*-------------------------------------------------------------------*\n         LA    R1,@D_Parms               A(Parm list)\n         BRAS  R14,W00010                Get A(Next entry)\n         LTR   R15,R15                   Did we get one?\n         JNZ   D00780                    No, skip\n         LR    R9,R1                     Yes, point to it\n\n         OI    VolTbl_Ent_Stats_Line,L'VolTbl_Ent_Stats_Line\n         OI    VolTbl_Ent_Stats_31Stack,L'VolTbl_Ent_Stats_31Stack\n\n         LA    R1,@D_Parms               A(Parm list)\n         BRAS  R14,W00010                Get A(Next entry)\n         LTR   R15,R15                   Did we get one?\n         JNZ   D00780                    No, skip\n         LR    R9,R1                     Yes, point to it\n\n         OI    VolTbl_Ent_Stats_Line,L'VolTbl_Ent_Stats_Line\n         OI    VolTbl_Ent_Stats_24Stack,L'VolTbl_Ent_Stats_24Stack\n\n*-------------------------------------------------------------------*\n*    ... and 1 more for the CPU time.                               *\n*-------------------------------------------------------------------*\n         LA    R1,@D_Parms               A(Parm list)\n         BRAS  R14,W00010                Get A(Next entry)\n         LTR   R15,R15                   Did we get one?\n         JNZ   D00780                    No, skip\n         LR    R9,R1                     Yes, point to it\n\n         OI    VolTbl_Ent_Stats_Line,L'VolTbl_Ent_Stats_Line\n         OI    VolTbl_Ent_Stats_CPUTime,L'VolTbl_Ent_Stats_CPUTime\n\n*---------------------------------------------------------------------*\n*   If we are doing LSPACEs, get enough lines for the subtask         *\n*  heading(s) and stats lines                                         *\n*---------------------------------------------------------------------*\n         TM    @_No_LSPACE,L'@_No_LSPACE Doing LSPACEs?\n         JO    D00780                   No, skip subtask stuff\n\n         L     R8,@_SubTask_Count       Get nbr subtasks\n         AHI   R8,H_SubTask_Hdg_Count   Plus nbr heading lines\n         SR    R3,R3                    Clear offset\n\nD00760   DS    0H\n         LA    R1,@D_Parms               A(Parm list)\n         BRAS  R14,W00010                Get A(Next entry)\n         LTR   R15,R15                   Did we get one?\n         JNZ   D00780                    No, skip\n         OI    VolTbl_Ent_Stats_Line-VolTbl_Ent(R1),L'VolTbl_Ent_Stats_+\n               Line\n         LTR   R3,R3                     Have we saved the offset?\n         JNZ   D00770                    Yes, skip\n         L     R15,@_VolTbl_Ptr          A(VolTbl)\n         LR    R3,R1                     A(1st heading line)\n         SR    R3,R15                    Offset of SubTask heading\n         ST    R3,VolTbl_Hdr_SubT_Off-VolTbl_Hdr(R15) Save it\nD00770   DS    0H\n\n         BRCT  R8,D00760                 And do it again\n\nD00780   DS    0H\n*---------------------------------------------------------------------*\n*     If we will not be doing LSPACEs ...                             *\n*---------------------------------------------------------------------*\n         TM    @_No_LSPACE,L'@_No_LSPACE  Doing LSPACE?\n         JNO   D00800                   Yes, skip\n\nD00790   DS    0H\n*---------------------------------------------------------------------*\n*     ... all volumes have been processed, and the table is complete. *\n*---------------------------------------------------------------------*\n         ICM   R15,B'1111',@_VolTbl_Ptr No, A(VolTbl)\n         JZ    D00800                   None, skip\n         L     R0,VolTbl_Hdr_Vols_Total-VolTbl_Hdr(R15)\n         ST    R0,VolTbl_Hdr_Vols_Proc-VolTbl_Hdr(R15)\n         OI    VolTbl_Hdr_ECB-VolTbl_Hdr(R15),X'40' POST table complete\n\nD00800   DS    0H\n*---------------------------------------------------------------------*\n*     Free up the esoteric table, if there is one ...                 *\n*---------------------------------------------------------------------*\n         ICM   R1,B'1111',@D_UNITA      A(Unit Table)\n         JZ    D00810                   None, skip\n         L     R0,0(0,R1)               Get its length\n\n         BASR  R2,0\n         USING (*,D00800_End-1),R2\n         STORAGE RELEASE,               Free the old table             +\n               ADDR=(1),                 starting here                 +\n               LENGTH=(0)                for this long\nD00800_End DS  0H\n         DROP  R2\n\n         LA    R15,0                    Clear work register\n         ST    R15,@D_UNITA             and clear A(Unit table)\n\nD00810   DS    0H\n*---------------------------------------------------------------------*\n*     ... and the VLDs, if there are any.                             *\n*---------------------------------------------------------------------*\n         LA    R15,0                   Clear work reg\n         ST    R15,@D_Parms_T00010     No volser\n         LA    R15,@D_VLD_Anchor       A(Anchor)\n         ST    R15,@D_Parms_T00010+4   No volser\n         LA    R1,@D_Parms              A(Parm list)\n         BRAS  R14,T00010               Go free VLDs\n\n*---------------------------------------------------------------------*\n*     If we have found any UCBs, exit with a return code of 0         *\n*---------------------------------------------------------------------*\n         ICM   R15,B'1111',@_VolTbl_Ptr Any VolTbl?\n         JZ    D80010                   No, exit with error\n         ICM   R15,B'1111',VolTbl_Hdr_Vols_Total-VolTbl_Hdr(R15) Vols?\n         JZ    D80010                   No, exit with error\n         LA    R15,0                    Clear return code\n         J     D90010                   and exit\n\nD80010   DS    0H\n*---------------------------------------------------------------------*\n*   We couldnt find any UCBs - set the return code and exit           *\n*---------------------------------------------------------------------*\n         LA    R15,4                    No UCBs returned\n         J     D90010                   and exit\n\nD90010   DS    0H\n*---------------------------------------------------------------------*\n*    Free up our local storage ...                                    *\n*---------------------------------------------------------------------*\n         LR    R3,R15                   Save return code\n\n         LA    R1,@D_Dynam              A(Local storage)\n         L     R2,@D_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         L     R13,4(0,R13)             Rescue A(HSA)\n\n         SSCSTACK POP,                  Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=(R2)                on this stack\n\n         LR    R15,R3                   Restore return code\n\n*-------------------------------------------------------------------*\n*    ... and return to caller                                       *\n*-------------------------------------------------------------------*\n         L     R14,12(0,R13)            Restore return address\n         LM    R0,R12,20(R13)           Restore other registers\n         BSM   0,R14                    and return\n\nD_Literals  DS  0H\n\nD_MVC    MVC   0(0,R1),0(R15)           Move STORGRP\nD_MVC1   MVC   VolTbl_Ent_Display(0),2(R15)  Move Stats line\n\nD_CLC    CLC   0(0,R14),0(R15)          UCBTBYT4 vs DCEOBRDT\n\nD_TrTbl  DC    256AL1(*-D_TrTbl)\n         ORG   D_TrTbl+X'FF'\n         DC    C'*'\n         ORG   ,\n\nD_TRTAB  EQU   *-X'F0'\n         DC    C'0123456789ABCDEF'\n\nD_TIME   TIME  LINKAGE=SYSTEM,          Get the time                   +\n               MF=L                      keep ourselves reentrant\nD_TIME_Length  EQU *-D_TIME\n\n\nD_CHPID_Msg  DC CL(L'VolTbl_Ent_CHPIDs)' $:Phys unavail, -:Log unavail'\n\nD_Stats_Line_Ptrs     EQU   *\n                      DC    AL4(D_Stats_Line1-2)\n                      DC    AL4(D_Stats_Line2-2)\n                      DC    AL4(D_Stats_Line3-2)\n                      DC    AL4(D_Stats_Line4-2)\n                      DC    AL4(D_Stats_Line5-2)\n                      DC    AL4(D_Stats_Line6-2)\n                      DC    AL4(D_Stats_Line7-2)\n                      DC    AL4(D_Stats_Line8-2)\n                      DC    AL4(D_Stats_Line9-2)\n                      DC    AL4(D_Stats_Line10-2)\n                      DC    AL4(D_Stats_Line11-2)\nD_Stats_Line_Count    EQU   (*-D_Stats_Line_Ptrs)/4\n\n                      DC    AL2(D_Stats_Line1_End-D_Stats_Line1)\nD_Stats_Line1         EQU   *\n                      DC    C'&PGMNAME '\n                      DC    C'&VERSION'\n                      DC    C' '\nD_Stats_Line1_Data    EQU   *\n                      DC    C'assembled on '\n                      DC    C'&ASMDT'\n                      DC    C' at '\n                      DC    C'&ASMTM'\n                      DC    C' under '\n                      DC    C'&SYSTEM_ID'\nD_Stats_Line1_End     EQU   *\n\n                      DC    AL2(D_Stats_Line2_End-D_Stats_Line2)\nD_Stats_Line2         EQU   *\n                      DC    CL(D_Stats_Line1_Data-D_Stats_Line1)' '\n                      DC    C'with '\n                      DC    C'&SYSASM'\n                      DC    C' '\n                      DC    C'&SYSVER'\n                      DC    C'.'\nD_Stats_Line2_End     EQU   *\n\n                      DC    AL2(D_Stats_Line3_End-D_Stats_Line3)\nD_Stats_Line3         EQU   *\n                      DC    CL(D_Stats_Line1_Data-D_Stats_Line1)' '\n                      DC    C'executing on '\nD_Stats_Line3_Date    DC    CL10' '\n                      DC    C' at '\nD_Stats_Line3_Time    DC    CL5' '\n                      DC    C' under '\nD_Stats_Line3_SysVer  DC    CL(L'ECVTPNAM+2+1+L'ECVTPVER+1+L'ECVTPREL+1+\n               +L'ECVTPMOD)' '\nD_Stats_Line3_End     EQU   *\n\n                      DC    AL2(D_Stats_Line4_End-D_Stats_Line4)\nD_Stats_Line4         EQU   *\n                      DC    CL(D_Stats_Line1_Data-D_Stats_Line1)' '\n                      DC    C'on '\nD_Stats_Line4_SNAME   DC    CL(L'CVTSNAME)' '\n                      DC    C' '\n                      DC    CL(12+L'CPCND_MAN+L'CPCND_TYPE+L'CPCND_MODE+\n               L)' '\nD_Stats_Line4_End     EQU   *\n\n                      DC    AL2(D_Stats_Line5_End-D_Stats_Line5)\nD_Stats_Line5         EQU   *\n                      DC    CL(D_Stats_Line1_Data-D_Stats_Line1)' '\n                      DC    C'Installation Defaults'\nD_Stats_Line5_End     EQU   *\n\n                      DC    AL2(D_Stats_Line6_End-D_Stats_Line6)\nD_Stats_Line6         EQU   *\n                      DC    CL(D_Stats_Line1_Data-D_Stats_Line1)' '\n                      DC    C' ISPF Output by default      : '\n         AIF   (&ISPF_by_Default).D_Stats_Line6_010\n                      DC    C'N'\n         AGO   .D_Stats_Line6_020\n.D_Stats_Line6_010  ANOP\n                      DC    C'Y'\n.D_Stats_Line6_020  ANOP\nD_Stats_Line6_End     EQU   *\n\n                      DC    AL2(D_Stats_Line7_End-D_Stats_Line7)\nD_Stats_Line7         EQU   *\n                      DC    CL(D_Stats_Line1_Data-D_Stats_Line1)' '\n                      DC    C' ISPF Output type            : '\n                      DC    C'&ISPF_Default_Type'\nD_Stats_Line7_End     EQU   *\n\n                      DC    AL2(D_Stats_Line8_End-D_Stats_Line8)\nD_Stats_Line8         EQU   *\n                      DC    CL(D_Stats_Line1_Data-D_Stats_Line1)' '\n                      DC    C' Max LSPACE Wait (Foreground): '\n         AIF   (&Fore_LSPACE_Wait EQ 0).D_Stats_Line8_010\n                      DC    C'&Fore_LSPACE_Wait'\n                      DC    C' secs.'\n         AGO   .D_Stats_Line8_020\n.D_Stats_Line8_010  ANOP\n                      DC    C'None'\n.D_Stats_Line8_020  ANOP\nD_Stats_Line8_End     EQU   *\n\n                      DC    AL2(D_Stats_Line9_End-D_Stats_Line9)\nD_Stats_Line9         EQU   *\n                      DC    CL(D_Stats_Line1_Data-D_Stats_Line1)' '\n                      DC    C' Max LSPACE Wait (Background): '\n         AIF   (&Back_LSPACE_Wait EQ 0).D_Stats_Line9_010\n                      DC    C'&Back_LSPACE_Wait'\n                      DC    C' secs.'\n         AGO   .D_Stats_Line9_020\n.D_Stats_Line9_010  ANOP\n                      DC    C'None'\n.D_Stats_Line9_020  ANOP\nD_Stats_Line9_End     EQU   *\n\n                      DC    AL2(D_Stats_Line10_End-D_Stats_Line10)\nD_Stats_Line10        EQU   *\n                      DC    CL(D_Stats_Line1_Data-D_Stats_Line1)' '\n                      DC    C' Default number of SubTasks  : '\n         AIF   (&Default_SubTask_Count EQ 0).D_Stats_Line10_010\n                      DC    C'&Default_SubTask_Count'\n         AGO   .D_Stats_Line10_020\n.D_Stats_Line10_010 ANOP\n                      DC    C'Dynamic'\n.D_Stats_Line10_020 ANOP\nD_Stats_Line10_End    EQU   *\n\n                      DC    AL2(D_Stats_Line11_End-D_Stats_Line11)\nD_Stats_Line11        EQU   *\n                      DC    CL(D_Stats_Line1_Data-D_Stats_Line1)' '\n                      DC    C' Maximum number of SubTasks  : '\n         AIF   (&Max_SubTask_Count EQ 0).D_Stats_Line11_010\n                      DC    C'&Max_SubTask_Count'\n         AGO   .D_Stats_Line11_020\n.D_Stats_Line11_010 ANOP\n                      DC    C'None'\n.D_Stats_Line11_020 ANOP\nD_Stats_Line11_End    EQU   *\n\n\n         LTORG\n\nD_Literals_End  DS  0H\n\n@D_Dynam                  DSECT       Dynamic area for D00000\n                          DS    18F    O/S Style save area\n@D_31Bit_Stack_Ptr_Ptr    DS    AL4    A(31-bit Stack Ptr)\n@D_24Bit_Stack_Ptr_Ptr    DS    AL4    A(24-bit Stack Ptr)\n@D_DBLWD                  DS    D      Doubleword work area\n@D_WkArea                 DS    CL12   EDit Word Area\n@D_UCBNAME                DS    CL4    UCB name\n@D_UNITA                  DS    AL4    A(UCB Table from EDTINFO\n@D_Volume_Count           DS    FL4    Nbr vols in the table\n@D_IECDDEVT_Ptr           DS    AL4    A(SYS1.NUCLEUS(IECDDEVT))\n@D_VLD_Anchor             DS    DL8    A(Start of SMS SG VLDs)\n@D_SMS_Ptrs               DS    2AL4   A(STORGRP, SMS Status)\n@D_R00010_Word            DS    FL4    A word for R00010\n                          DS    X      Flag byte\n@D_Eligible_UCB_Found     EQU   *-1,X'80' 1... .... At least 1 UCB\n@D_UCB_Addr_Updated       EQU   *-1,X'40' .1.. .... 4 --> 3 byte addr\n@D_Single_Volser          EQU   *-1,X'20' ..1. .... Specific Volser\n@D_SMS_Unavail            EQU   *-1,X'10' ...1 .... SMS not available\n@D_SMS_Ptrs_OK            EQU   *-1,X'08' .... 1... SMS data valid\n@D_CHPID_Unavail          EQU   *-1,X'04' .... .1.. CHP unavail\n                          DS    0F     Alignment\n@D_IOCT                   DS    CL48   IOC Token area for UCBSCAN\n\n                          DS    0F      Alignment\n@D_UCBSCAN_WorkArea       DS    CL100   UCBSCAN Work Area\n                          ORG   @D_UCBSCAN_WorkArea\n@D_CSRSI_Manuf            DS    CL(L'SI11V1CPCMANUFACTURER)\n@D_CSRSI_Type             DS    CL(L'SI11V1CPCTYPE)\n@D_CSRSI_Model            DS    CL(L'SI11V1CPCMODEL)\n@D_CSRSI_Serial           DS    CL4\n                          ORG   ,\n\n@D_Macro                  DS    0D     Macros\n                          EDTINFO MF=(L,@D_EDTINFO) EDTINFO L-Form\n                          ORG   @D_Macro\n                          IOCINFO MF=(L,@D_IOCINFO) IOCINFO L-Form\n                          ORG   @D_Macro\n                          UCBINFO MF=(L,@D_UCBINFO)\n@D_UCBINFO_Data           DS    XL256\n                          ORG   @D_Macro\n                          UCBSCAN MF=(L,@D_UCBSCAN) UCBSCAN L-Form\n                          DS    0F     Alignment\n@D_UCB                    DS    XL48   UCB Copy from UCBSCAN\n                          DS    0F     Alignment\n@D_DCE_Length             DS    XL2    DCE Area length\n@D_DCE                    DS    XL48   DCE Copy from UCBSCAN\n                          ORG   @D_Macro\n@D_SMS_Temp_StorGrp       DS    CL(L'VLDSTGRP)\n                          ORG   @D_Macro\n@D_TIME                   DS    CL(D_TIME_Length)   TIME Macro area\n                          DS    0D\n@D_Time_Area              DS    XL16   Data returned by TIME\n                          ORG   @D_Macro\n                          DS    0F\n@D_CSRSI_Parm             DS    4FL4   Parms for CSRSI\n                          ORG   ,      End of Macros\n\n@D_Parms                  DS    0F     Parms for called rtns\n@D_Parms_Std              DS    3AL4    Standard 3 parms\n@D_Parms_Extra            EQU   *       Extra parms\n@D_Parms_R00010           DS    5AL4       for R00010\n                          ORG   @D_Parms_Extra\n@D_Parms_T00010           DS    2AL4       for T00010\n                          ORG   ,\n                          DS    0D          Alignment\n@D_Dynam_Length           EQU   *-@D_Dynam Length of storage\n\n&PGMNAME CSECT\n\n         DROP  ,\n         POP   USING\n         TITLE 'E00010: Manage LSPACE SubTasks'\n         PUSH  USING\n\nE00010   DS    0H\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Routine   : E00010                                                 *\n*                                                                     *\n*  Abstract  : ATTACH and DETACH LSPACE Subtasks (H00010)             *\n*                                                                     *\n*  Inputs    : R1 : ---> A(@_Dynam)                                   *\n*                        A(31-bit Stack Pointer)                      *\n*                        A(24-bit Stack Pointer)                      *\n*  Outputs   : R15: 0 - OK                                            *\n*                   4 - No valid LSPACE data retrieved                *\n*                                                                     *\n*  Notes     :                                                        *\n*                                                                     *\n*  History:    1990/06/11 SDDA030 - New                               *\n*              1997/05/16 SDDA030 - ATTACHed subtasks to issue LSPACE *\n*                                   so that we don't wait forever for *\n*                                   devices that are constantly busy. *\n*              1998/09/17 SDDA030 - V2.0                              *\n*                                 - Corrected logic error where some  *\n*                                   STIMERMs were not being CANCELled *\n*                                 - Used Compare-and-Swap in pseudo-  *\n*                                   POST processing, rather than      *\n*                                   blindly ORing POST bit if no WAIT *\n*                                   was present (E00390).             *\n*                                 - Moved STIMERMs from this routine  *\n*                                   To H00010.                        *\n*                                 - Pass A(Volume Table) to H00010    *\n*                                   rather than individual entries    *\n*                                   within the table.                 *\n*              1999/03/03 SDDA030 - V2.5                              *\n*                                 - Added Version and Assembly info   *\n*                                   to statistics display             *\n*              1999/05/27 SDDA030 - V2.6                              *\n*                                 - Used LIFO Stack for our dynamic   *\n*                                   areas.                            *\n*              1999/07/30 SDDA030 - V2.7                              *\n*                                 - Added SubTask CPU time to         *\n*                                   statistics display                *\n*              1999/08/20 SDDA030 - V2.8                              *\n*                                 - Added SubTask Wait time to        *\n*                                   statistics display                *\n*              1999/09/01 SDDA030 - V2.9                              *\n*                                 - Passed totals fields as part of   *\n*                                   SubTask_Area, and totalled them   *\n*                                   after all subtasks complete.      *\n*              1999/09/30 SDDA030 - V2.10                             *\n*                                 - Inserted total volume count in the*\n*                                   Totals line                       *\n*              2000/01/19 SDDA030 - V2.11                             *\n*                                 - Created stats line for 24-bit     *\n*                                   stack.                            *\n*                                 - Reserved space for the Stack stats*\n*                                   lines, but deferred filling in    *\n*                                   values until they get output, in  *\n*                                   F00010.                           *\n*              2000/05/23 SDDA030 - V2.12                             *\n*                                 - Removed code that worried about   *\n*                                   subtasks that timed out.          *\n*                                 - Trimmed parm list passed to H00010*\n*                                 - Updated Stats lines to remove     *\n*                                   WAIT time data, and replace with  *\n*                                   APF authorization msg.            *\n*              2001/02/01 SDDA030 - V2.13                             *\n*                                 - Reset Parm list passed to H00010  *\n*                                 - Re-added WAIT stuff to stats line.*\n*                                 - Added IKJEFTSR re-invocation if   *\n*                                   we are not APFd.                  *\n*                                 - Moved CPU used stuff to V00010.   *\n*                                 - Made ourselves non-swappable while*\n*                                   daughter tasks active.            *\n*              2001/02/26 SDDA030 - V2.14                             *\n*                                 - Added VTOCIX and Frag Index info. *\n*                                 - Added call to U0010 to format     *\n*                                   detail and total lines.           *\n*                                 - Issue WAIT for @_MaxTasks ECBs,   *\n*                                   rather than for 1 ECB.            *\n*                                 - Acquired H00010 work area from the*\n*                                   stack.                            *\n*              2001/11/12 SDDA030 - V2.15                             *\n*                                   Passed STIMERM Wait time factor   *\n*                                   (based on #SubTasks/#LPs) to      *\n*                                   H00010.                           *\n*                                 - Checked Assembler version when    *\n*                                   generating our assembly time      *\n*                                   stamp.                            *\n*              2002/03/11 SDDA030 - V2.17                             *\n*                                 - If we will be using only 1 subtask*\n*                                   BASR rather than ATTACH           *\n*                                 - Used E_Stats_Line2 to verify that *\n*                                   IKJEFTSR invoked the same version *\n*                                   as was originally invoked.        *\n*              2002/06/11 SDDA030 - V2.18                             *\n*                                 - If OW48527 installed, don't WAIT  *\n*                                   for subtasks to terminate         *\n*                                 - Moved various fields passed to    *\n*                                   subtasks into VolTbl              *\n*              2002/08/08 SDDA030 - V2.19                             *\n*                                 - If we can't dispatch subtasks,    *\n*                                   POST entries and table as done.   *\n*              2003/01/16 SDDA030 - V2.20                             *\n*                                 - Correct bug when eliminating sub- *\n*                                   task stats if we aren't APF'd.    *\n*              2003/10/07 SDDA030 - V2.21                             *\n*                                 - Always ATTACH with ECB=, DETACH   *\n*                                   done in S00010.                   *\n*                                 - BRAS instead of ATTACHX H00010 if *\n*                                   only 1 vol, instead of only 1     *\n*                                   subtask.                          *\n*              2006/04/21 SDDA030 - V2.24                             *\n*                                 - IDENTIFY H00010 with a unique name*\n*                                   (based on TCB address) so we can  *\n*                                   run multiple copies simultaneously*\n*                                 - Used standardized calling sequence*\n*              ____/__/__ _______ -                                   *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         STM   R14,R12,12(R13)          Save callers registers\n         LARL  R11,E_Literals           Point to our literals\n         USING (E_Literals,E_Literals_End),R11 Tell the assembler\n\n         L     R12,0(0,R1)              A(@_Dynam)\n         USING @_Dynam,R12              Tell the assembler\n\n*-------------------------------------------------------------------*\n*    Get an area on the stack for our local storage                 *\n*-------------------------------------------------------------------*\n         L     R2,4(0,R1)               A(31-bit stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         SSCSTACK PUSH,                 Get stack area                 +\n               LEN=@E_Dynam_Length,      this long                     +\n               STACK=(R2)                using this stack\n\n         LR    R3,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LHI   R1,@E_Dynam_Length        Its length\n         LA    R14,0                    Clear source address\n         LA    R15,0                     and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R3                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*-------------------------------------------------------------------*\n         ST    R13,4(0,R1)              Chain\n         ST    R1,8(0,R13)               saveareas\n         LR    R13,R1                   Load dynam base\n         USING @E_Dynam,R13             Assign a base\n         L     R15,@E_Dynam+4           Get A(HSA)\n         LM    R0,R3,20(R15)            Restore callers registers\n\n         L     R15,4(0,R1)              A(31-bit Stack Pointer)\n         ST    R15,@E_31Bit_Stack_Ptr_Ptr Save it\n         L     R15,8(0,R1)              A(24-bit Stack Pointer)\n         ST    R15,@E_24Bit_Stack_Ptr_Ptr Save it\n\n*--------------------------------------------------------------------*\n*   Initialize our standard parmlist                                 *\n*--------------------------------------------------------------------*\n         LA    R15,@_Dynam              A(Dynamic area)\n         ST    R15,@E_Parms_Std         Save it\n         L     R15,@E_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)\n         ST    R15,@E_Parms_Std+4       Save it\n         L     R15,@E_24Bit_Stack_Ptr_Ptr A(24-bit Stack Pointer)\n         ST    R15,@E_Parms_Std+8       Save it\n\n*---------------------------------------------------------------------*\n*     Check that, in fact, we have something to do.                   *\n*---------------------------------------------------------------------*\n         ICM   R15,B'1111',@_VolTbl_Ptr A(VolTbl)\n         JZ    E80010                   None, exit with error\n         ICM   R15,B'1111',VolTbl_Hdr_Vols_Total-VolTbl_Hdr(R15)\n         JZ    E80010                   No volumes, exit with error\n         TM    @_No_LSPACE,L'@_No_LSPACE Yes, should we issue LSPACEs?\n         JO    E00230                   No, all done\n\n         TM    @_OW48527,L'@_OW48527    Yes, is OW48527 present?\n         JO    E00100                   Yes, OK\n\n*---------------------------------------------------------------------*\n*     We must be APF-Authorized to do our stuff. If we aren't, we     *\n*    re-invoke ourselves via IKJEFTSR (unless we are currently        *\n*    running as an IKJEFTSR invocation).                              *\n*---------------------------------------------------------------------*\n         TESTAUTH FCTN=1                Check APF Authorization\n         LTR   R15,R15                  Are we?\n         JNZ   E00020                   No, skip\n         TM    @_IKJEFTSR,L'@_IKJEFTSR  Yes, IKJEFTSR'd?\n         JZ    E00100                   No, OK\n\n*---------------------------------------------------------------------*\n*     We are APF'd and invoked under IKJEFTSR. Check to make sure     *\n*    that the code we are executing (under IKJEFTSR, which LOADs from *\n*    STEPLIB/LNKLST) is the same as was originally invoked as a       *\n*    command (possibly from ISPLLIB), using the time of assembly.     *\n*---------------------------------------------------------------------*\n         ICM   R15,B'1111',@_IKJEFTSR_TimeStamp_Ptr A(Callers timestmp)\n         JZ    E00010C                  Nothing, error\n         CLC   E_IKJEFTSR_TimeStamp(E_IKJEFTSR_TimeStamp_Length),0(R15)\n         JE    E00100                   Same as ours, OK\nE00010C  DS    0H\n         OI    @_SYSCLOCK_Err,L'@_SYSCLOCK_Err No, flag as an error\n         OI    @_LSPACE_Failed,L'@_LSPACE_Failed VolTbl Incomplete\n         J     E80010                   and go produce stats\n\nE00020   DS    0H\n         TM    @_IKJEFTSR,L'@_IKJEFTSR  Are we running from IKJEFTSR?\n         JZ    E00030                   No, skip\n         OI    @_No_APF,L'@_No_APF      Yes, still not authorized\n         OI    @_LSPACE_Failed,L'@_LSPACE_Failed VolTbl incomplete\n         J     E80010                   and go produce totals and stats\n\nE00030   DS    0H\n*---------------------------------------------------------------------*\n*     We are not APF'd, and not running as a result of IKJEFTSR, so   *\n*    re-invoke ourselves via IKJEFTSR.                                *\n*---------------------------------------------------------------------*\n\n*---------------------------------------------------------------------*\n*     Initialize our flags for IKJEFTSR                               *\n*---------------------------------------------------------------------*\n         LA    R15,E_IKJEFTSR_Flags     Point to our flags\n         ST    R15,@E_IKJEFTSR_Parms    Save it\n\n*---------------------------------------------------------------------*\n*     Use the program name as found from the PRB.                     *\n*---------------------------------------------------------------------*\n         L     R14,PSATNEW-PSA(0)       Get A(our TCB)\n         SLL   R14,8                    Clean\n         SRL   R14,8                      it\n         L     R15,TCBRBP-TCB(R14)      A(RB)\nE00050   DS    0H\n         L     R0,RBLINK-RBBASIC(R15)   A(Previous RB)\n         SLL   R0,8                     Clean\n         SRL   R0,8                       it\n         CR    R0,R14                   Last RB (RBLINK = A(TCB))?\n         JE    E00060                   Yes, skip\n         LR    R15,R0                   No, point to previous RB\n         J     E00050                   and keep trying\nE00060   DS    0H\n         LA    R14,0                    Get pointer to\n         ICM   R14,B'0111',RBCDE1-RBBASIC(R15)  our CDE\n         MVC   @E_IKJEFTSR_PgmName,CDNAME-CDENTRY(R14)  Move pgm name\n         LA    R15,@E_IKJEFTSR_PgmName  A(Program name)\n         ST    R15,@E_IKJEFTSR_Parms+4  Save it\n\n*---------------------------------------------------------------------*\n*     Length of the program name                                      *\n*---------------------------------------------------------------------*\n         LA    R15,@E_IKJEFTSR_PgmName+L'@E_IKJEFTSR_PgmName-1\nE00070   DS    0H\n         CLI   0(R15),C' '              Trailing blank?\n         JNE   E00080                   No, skip\n         BRCT  R15,E00070               Yes, keep checking\nE00080   DS    0H\n         LA    R14,@E_IKJEFTSR_PgmName-1 Calculate length\n         SR    R15,R14                   of program name\n         ST    R15,@E_IKJEFTSR_PgmName_Length  Save it\n         LA    R15,@E_IKJEFTSR_PgmName_Length A(Length)\n         ST    R15,@E_IKJEFTSR_Parms+8   Save it\n\n*---------------------------------------------------------------------*\n*     Pointers to the Return Code, Reason Code and ABEND Code areas.  *\n*---------------------------------------------------------------------*\n         LA    R15,@_IKJEFTSR_RC        A(Return Code Area)\n         ST    R15,@E_IKJEFTSR_Parms+12  Save it\n\n         LA    R15,@_IKJEFTSR_Reas      A(Reason Code Area)\n         ST    R15,@E_IKJEFTSR_Parms+16  Save it\n\n         LA    R15,@E_IKJEFTSR_ABEND     A(ABEND Code Area)\n         ST    R15,@E_IKJEFTSR_Parms+20  Save it\n\n*---------------------------------------------------------------------*\n*     Pointers to the parms we will be passing to ourselves           *\n*---------------------------------------------------------------------*\n         LA    R15,@E_IKJEFTSR_Pgm_Parm_Ptrs A(Parms for the Pgm)\n         ST    R15,@E_IKJEFTSR_Parms+24  Save it\n         OI    @E_IKJEFTSR_Parms+24,X'80' Flag as last parm\n\n         LA    R15,@E_IKJEFTSR_Pgm_Parm1 A(Pgm Parm 1) - A(@_Dynam)\n         ST    R15,@E_IKJEFTSR_Pgm_Parm_Ptrs Save it\n\n*---------------------------------------------------------------------*\n*     Point to our timestamp, which contains the assembly date,       *\n*    time and version. This will be used by the version of SPACE      *\n*    invoked by IKJEFTSR to ensure that the same code is running.     *\n*---------------------------------------------------------------------*\n         LA    R15,E_IKJEFTSR_TimeStamp A(Interesting assembly stats)\n         ST    R15,@_IKJEFTSR_TimeStamp_Ptr Save it\n\n*---------------------------------------------------------------------*\n*     And finally the parms themselves:                               *\n*       HL2'4',AL4(@_Dynam)                                           *\n*       HL2'16',1st 16 bytes of @_Dynam                               *\n*---------------------------------------------------------------------*\n         LHI   R15,4                    Length of an address\n         STH   R15,@E_IKJEFTSR_Pgm_Parm1 Save it\n         LA    R15,@_Dynam              A(Dynamic area)\n         ST    R15,@E_IKJEFTSR_Pgm_Parm1+2 Save it\n\n         LA    R15,@E_IKJEFTSR_Pgm_Parm2 A(Pgm Parm 1) - A(@_Dynam)\n         ST    R15,@E_IKJEFTSR_Pgm_Parm_Ptrs+4 Save it\n         OI    @E_IKJEFTSR_Pgm_Parm_Ptrs+4,X'80'  Last one\n\n         LA    R15,L'@E_IKJEFTSR_Pgm_Parm2-2 Length of data\n         STH   R15,@E_IKJEFTSR_Pgm_Parm2 Save it\n         MVC   @E_IKJEFTSR_Pgm_Parm2+2(L'@E_IKJEFTSR_Pgm_Parm2-2),@_Dyn+\n               am\n\n*---------------------------------------------------------------------*\n*     Re-invoke ourselves via IKJEFTSR so that we are (hopefully)     *\n*    APF-authorized.                                                  *\n*---------------------------------------------------------------------*\n         LA    R1,@E_IKJEFTSR_Parms     A(IKJEFTSR Parm List)\n         L     R15,CVTPTR               A(CVT)\n         L     R15,CVTTVT-CVT(R15)      A(TSVT)\n         L     R15,TSVTASF-TSVT(R15)    A(IKJEFTSR)\n         BASR  R14,R15                  Go do it\n\n*---------------------------------------------------------------------*\n*     Save the return code from IKJEFTSR, so if something went wrong, *\n*    we can tell somebody.                                            *\n*---------------------------------------------------------------------*\n         ST    R15,@_IKJEFTSR_RC        Save Return Code\n         CHI   R15,4                    How did it go?\n         JNH   E00090                   OK, skip\n         OI    @_IKJEFTSR_Err,L'@_IKJEFTSR_Err  Flag an error\n         OI    @_LSPACE_Failed,L'@_LSPACE_Failed VolTbl not filled in\n         J     E80010                   and clean up VolTbl\nE00090   DS    0H\n\n         LA    R15,0                    Clear return code\n         J     E90010                   and exit\n\nE00100   DS    0H\n*---------------------------------------------------------------------*\n*     OK, now we can start the real work,                             *\n*                                                                     *\n*     Set up to ATTACH the tasks to actually issue the LSPACE.        *\n*    We do this so that if one subtask gets hung up on a RESERVEd     *\n*    device, the other subtasks can still retrieve LSPACE info.       *\n*                                                                     *\n*     First, IDENTIFY the routine (H00010) we will ATTACH ...         *\n*---------------------------------------------------------------------*\n         L     R15,@_VolTbl_Ptr        A(Volume Table)\n         L     R15,VolTbl_Hdr_Count-VolTbl(R15) Get number of volumes\n         CHI   R15,1                   Doing more than 1?\n         JNH   E00160                  No, no need to IDENTIFY\n         L     R0,PSATNEW-PSA(0)       Yes, get A(our TCB)\n         SLL   R0,4                    Make room for 'sign'\n         ST    R0,@E_DBLWD+4           Save it\n         OI    @E_DBLWD+7,X'0F'        Pack it\n         UNPK  @E_H00010_IDENTIFY_ID+1(7),@E_DBLWD+4(4) Unpack it\n         LA    R15,E_Hex_TrTab         A(Translate Table)\n         AHI   R15,-240                adjust it\n         TR    @E_H00010_IDENTIFY_ID+1(7),0(R15) Make it readable\n         MVI   @E_H00010_IDENTIFY_ID,C'H' Init 1st char\n         LARL  R1,H00010               A(Our routine)\n         IDENTIFY EPLOC=@E_H00010_IDENTIFY_ID, and let MVS know        +\n               ENTRY=(1)                about it\n\nE00160   DS    0H\n*---------------------------------------------------------------------*\n*    Initialize our timer total, and the number of completed subtasks.*\n*    These are used to 'heuristically' set the timer values for the   *\n*    STIMERMs used in H00010 ...                                      *\n*---------------------------------------------------------------------*\n         LA    R0,0                    Clear work register\n         ICM   R15,B'1111',@_VolTbl_Ptr A(VolTbl)\n         JZ    E80010                  Nothing, exit quick smart\n         ST    R0,VolTbl_Hdr_LSPACE_Avg-VolTbl_Hdr(R15)\n         ST    R0,VolTbl_Hdr_LSPACE_Avg+4-VolTbl_Hdr(R15)\n\n*---------------------------------------------------------------------*\n*    Calculate the STIMERM Adjustment factor, based on the ratio of   *\n*    SubTasks to Logical Processors - this is used to try to prevent  *\n*    false RESERVEd messages when dispatching a lot of subtasks on    *\n*    a few LPs (we should really take processor speed and weights     *\n*    into account as well, but we don't know how).                    *\n*                                                                     *\n*    We arbitrarily calculate it as:                                  *\n*     ((#Subtasks/#LPs)/4)                                            *\n*---------------------------------------------------------------------*\n         L     R15,@_SubTask_Count      Get MaxTasks\n         LA    R14,0                    Clear other part of dividend\n         D     R14,@_LP_Count           Get ratio of Subtasks to LPs\n         SRL   R15,2                    divided by 4\n         LTR   R15,R15                  Anything?\n         JNZ   E00170                   Yes, OK\n         LHI   R15,1                    No, default to 1\nE00170   DS    0H\n         L     R14,@_VolTbl_Ptr         A(VolTbl)\n         ST    R15,VolTbl_Hdr_STIMERM_Adj-VolTbl_Hdr(R14) Save it\n\n*---------------------------------------------------------------------*\n*     Initialize the fields related to LSPACE timeouts                *\n*---------------------------------------------------------------------*\n         OI    VolTbl_Hdr_OW48527-VolTbl_Hdr(R14),L'VolTbl_Hdr_OW48527\n         MVC   VolTbl_Hdr_MaxLWait-VolTbl_Hdr(L'VolTbl_Hdr_MaxLWait,R14+\n               ),@_MaxLWait\n\n*---------------------------------------------------------------------*\n*     Lower our dispatching priority, so that we can ATTACH our       *\n*    subtasks with our original (higher) priority (most of the elap-  *\n*    sed time in the subtasks is spent WAITing for LSPACE).           *\n*---------------------------------------------------------------------*\n         TM    @_CHAP_Done,L'@_CHAP_Done Have we already CHAPped?\n         JO    E00170A                  Yes, skip\n         CHAP  -1,'S'                   No, do it now\n         OI    @_CHAP_Done,L'@_CHAP_Done and set our flag\n\nE00170A  DS    0H\n*---------------------------------------------------------------------*\n*     ... and get some storage for our ATTACHed tasks, as described   *\n*    in the SubTask_Area DSECT.                                       *\n*---------------------------------------------------------------------*\n         L     R0,@_SubTask_Count       Number of SubTasks\n         MHI   R0,SubTask_Area_Ent_Length * length per sub-task\n         AHI   R0,SubTask_Area_Hdr_Length + header length\n\n         BASR  R2,0\n         USING (*,E00170C_End-1),R2\n         STORAGE OBTAIN,                Go get some storage            +\n               LENGTH=(0)                this long\nE00170C_End DS  0H\n         DROP  R2\n\n         ST    R1,@_SubTask_Area_Ptr    Save its address\n         ST    R0,SubTask_Area_Hdr_Len-SubTask_Area(R1)  Save length\n         L     R0,@_SubTask_Count       Number of SubTasks\n         ST    R0,SubTask_Area_Hdr_Count-SubTask_Area(R1) Save #\n\n         TM    @_OW48527,L'@_OW48527    Yes, is OW48527 present?\n         JO    E00170E                  Yes, OK\n\n*---------------------------------------------------------------------*\n*    Set ourselves non-swappable - if we are swappable, and we get    *\n*   hung up on a RESERVEd volume, SRM will try to swap us out. To do  *\n*   do, (s)he must terminate our I/O, and while (s)he is trying to do *\n*   this, any asychronous processing (such as STIMERM Exits) will be  *\n*   suppressed. In our case, it is the STIMERM Exit that will allow   *\n*   the I/O to be terminated, so we have to run non-swappable.        *\n*                                                                     *\n*    Note that we issue STAX DEFER before we do this (STAX in a       *\n*   non-TSO environment seems to be benign).                          *\n*---------------------------------------------------------------------*\n         MVC   @E_TIME,E_TIME           MOVE Time macro\n         TIME  STCK,                    Get the current time           +\n               @E_Time_Area,             return it here                +\n               LINKAGE=SYSTEM,           as recommended by IBM         +\n               MF=(E,@E_TIME)            staying re-entrant\n         MVC   @E_NSwap_Start,@E_Time_Area  Save DONTSWAP TOD\n\n         MVC   @E_STAX,E_STAX           Move STAX Macro\n         STAX  DEFER=YES,               Defer Attentions               +\n               MF=(E,@E_STAX)            staying re-entrant\n\n         SYSEVENT DONTSWAP              Make ourselves non-swappable\n\nE00170E  DS    0H\n*---------------------------------------------------------------------*\n*     Point to our ECBLIST area ...                                   *\n*---------------------------------------------------------------------*\n         L     R10,@_SubTask_Area_Ptr   A(SubTask_Area)\n         AHI   R10,SubTask_Area_Hdr_Length Point past header\n         L     R8,@_SubTask_Count       Get number we have to do\n\n*---------------------------------------------------------------------*\n*    ... initialize the area for each sub-task ...                    *\n*---------------------------------------------------------------------*\nE00180   DS    0H\n         XC    0(SubTask_Area_Ent_Length,R10),0(R10)  Clear entry\n\n*---------------------------------------------------------------------*\n*    ... set up the parm list for the subtask ...                     *\n*---------------------------------------------------------------------*\n         LA    R15,@_Dynam              A(Dynamic area)\n         ST    R15,SubTask_Area_Ent_Parms-SubTask_Area_Ent(R10)\n         L     R15,@E_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)\n         ST    R15,SubTask_Area_Ent_Parms+4-SubTask_Area_Ent(R10)\n         L     R15,@E_24Bit_Stack_Ptr_Ptr A(24-bit Stack Pointer)\n         ST    R15,SubTask_Area_Ent_Parms+8-SubTask_Area_Ent(R10)\n         L     R15,@_VolTbl_Ptr          A(VolTbl)\n         ST    R15,SubTask_Area_Ent_Parms+12-SubTask_Area_Ent(R10)\n\n         LA    R1,SubTask_Area_Ent_Parms-SubTask_Area_Ent(R10)\n\n*---------------------------------------------------------------------*\n*    ... and ATTACH (or BASR, if we are doing only 1 volume).         *\n*---------------------------------------------------------------------*\n         L     R15,@_VolTbl_Ptr         A(Volume Table)\n         L     R15,VolTbl_Hdr_Count-VolTbl(R15) Get number of volumes\n         CHI   R15,1                    Doing more than 1?\n         JH    E00190                   Yes, use ATTACH\n         BRAS  R14,H00010               No, just go do it\n         OI    SubTask_Area_Ent_ECB-SubTask_Area_Ent(R10),X'40' Done\n         LA    R1,0                     Clear 'TCB pointer'\n         J     E00200                   and skip\n\nE00190   DS    0H\n         MVC   @E_ATTACHX,E_ATTACHX     Move ATTACH parms\n         BASR  R2,0\n         USING (*,E00190_End-1),R2\n         ATTACHX EPLOC=@E_H00010_IDENTIFY_ID,  ATTACH H00010           +\n               ECB=(10),                 POST this ECB when complete   +\n               SZERO=YES,                Share SubPool 0               +\n               ASYNCH=YES,               Allow subtask asynch exits    +\n               DPMOD=1,                  Run at a higher priority      +\n               MF=(E,(1)),               Parmlist area                 +\n               SF=(E,@E_ATTACHX)         keep ourselves reentrant\nE00190_End DS  0H\n         DROP  R2\n\nE00200   DS    0H\n         ST    R1,SubTask_Area_Ent_TCB-SubTask_Area_Ent(R10) A(TCB)\n\n         AHI   R10,SubTask_Area_Ent_Length  A(next sub-task area)\n         BRCT  R8,E00180                and continue\n\n         TM    @_OW48527,L'@_OW48527    Yes, is OW48527 present?\n         JO    E00230                   Yes, all done\n\n*---------------------------------------------------------------------*\n*    WAIT for our H00010 instances to complete                        *\n*---------------------------------------------------------------------*\n         L     R0,@_SubTask_Count       Nbr ECBs to WAIT for\n         CHI   R0,1                     More than 1?\n         JNH   E00210                   No, we BASRed, not ATTACHed\n         LA    R1,@E_Parms              A(Parms)\n         BRAS  R14,S00010               Wait for our subtasks\n\nE00210   DS    0H\n*---------------------------------------------------------------------*\n*     We are done - make ourselves swappable again ...                *\n*---------------------------------------------------------------------*\n         SYSEVENT OKSWAP                We can be swapped out now\n\n         MVC   @E_STAX,E_STAX           Move STAX Macro\n         STAX  DEFER=NO,                Allow Attentions               +\n               MF=(E,@E_STAX)            staying re-entrant\n\n*---------------------------------------------------------------------*\n*     ... calculate the time we were non-swappable ...                *\n*---------------------------------------------------------------------*\n         MVC   @E_TIME,E_TIME           MOVE Time macro\n         TIME  STCK,                    Get the current time           +\n               @E_Time_Area,             return it here                +\n               LINKAGE=SYSTEM,           as recommended by IBM         +\n               MF=(E,@E_TIME)            staying re-entrant\n         LM    R14,R15,@E_Time_Area     Get current time\n         SL    R15,@E_NSwap_Start+4     Calculate\n         JNM   E00220                   No borrow, skip\n         SL    R14,=FL4'1'              Borrow, reduce\nE00220   DS    0H\n         SL    R14,@E_NSwap_Start       Calculate\n         STM   R14,R15,@_NSwap_Time     Save Non-Swap time\n\n*---------------------------------------------------------------------*\n*     ... and exit.                                                   *\n*---------------------------------------------------------------------*\n         J     E00230                   and skip\n\nE00230   DS    0H\n*---------------------------------------------------------------------*\n*     Clear the return code, and exit                                 *\n*---------------------------------------------------------------------*\n         LA    R15,0                    Clear return code\n         J     E90010                   and exit\n\nE80010   DS    0H\n*---------------------------------------------------------------------*\n*   We cannot, or should not, issue LSPACEs, so we will POST all the  *\n*  appropriate lines as complete ...                                  *\n*---------------------------------------------------------------------*\n         ICM   R9,B'1111',@_VolTbl_Ptr  A(Table of Volumes)\n         JZ    E80016                   Nothing, skip\n         ICM   R10,B'1111',VolTbl_Hdr_Count-VolTbl_Hdr(R9) Get count\n         JZ    E80016                   None, skip\n         AHI   R9,VolTbl_Ent-VolTbl     Point to 1st entry\nE80012   DS    0H\n         TM    VolTbl_Ent_Stats_31Stack-VolTbl_Ent(R9),L'VolTbl_Ent_Sta+\n               ts_31Stack\n         JO    E80014                   Stack Stats line, skip it\n         TM    VolTbl_Ent_Stats_24Stack-VolTbl_Ent(R9),L'VolTbl_Ent_Sta+\n               ts_24Stack\n         JO    E80014                   Stack Stats line, skip it\n         TM    VolTbl_Ent_Stats_CPUTime-VolTbl_Ent(R9),L'VolTbl_Ent_Sta+\n               ts_CPUTime\n         JO    E80014                   CPU Stats, skip it\n\n         L     R0,VolTbl_Ent_ECB-VolTbl_Ent(R9) Current ECB\n         TM    VolTbl_Ent_ECB-VolTbl_Ent(R9),X'80' Anyone WAITing?\n         JO    E80013                   Yes, we need to POST\n         L     R1,=XL4'40000000'        No, POST code of 0\n         CS    R0,R1,VolTbl_Ent_ECB-VolTbl_Ent(R9) Pseudo-POST it\n         JZ    E80014                   OK, skip the real POST\nE80013   DS    0H\n         POST  VolTbl_Ent_ECB-VolTbl_Ent(R9),0 POST line as complete\n\nE80014   DS    0H\n         AHI   R9,VolTbl_Ent_Len        A(Next entry)\n         BRCT  R10,E80012               and check again\n\n*---------------------------------------------------------------------*\n*   ... and if there are any Subtask Stats lines, get rid of them ... *\n*---------------------------------------------------------------------*\n         L     R15,@_VolTbl_Ptr         A(Volume table)\n         ICM   R1,B'1111',VolTbl_Hdr_SubT_Off-VolTbl_Hdr(R15)\n         JZ    E80016                   No SubTask stats, skip\n         AHI   R1,-VolTbl_Hdr_Length    Nbr lines\n         LA    R0,0                      excluding\n         D     R0,=AL4(VolTbl_Ent_Len)   Subtask Stats\n         ST    R1,VolTbl_Hdr_Count-VolTbl_Hdr(15) Update nbr lines\n         LA    R1,0                      and clear offset\n         ST    R1,VolTbl_Hdr_SubT_Off-VolTbl_Hdr(R15)\n\nE80016   DS    0H\n*---------------------------------------------------------------------*\n*   ... POST the table as complete ...                                *\n*---------------------------------------------------------------------*\n         ICM   R15,B'1111',@_VolTbl_Ptr A(Table of Volumes)\n         JZ    E80018                   None, skip\n         L     R0,VolTbl_Hdr_ECB-VolTbl_Hdr(R15) Current ECB\n         TM    VolTbl_Hdr_ECB-VolTbl_Hdr(R15),X'80' Anyone WAITing?\n         JO    E80017                   Yes, we need to POST\n         L     R1,=XL4'40000000'        No, POST code of 0\n         CS    R0,R1,VolTbl_Hdr_ECB-VolTbl_Hdr(R15) Pseudo-POST it\n         JZ    E80018                   OK, skip the real POST\nE80017   DS    0H\n         POST  VolTbl_Hdr_ECB-VolTbl_Hdr(R15),0 POST table as complete\n\nE80018   DS    0H\n*---------------------------------------------------------------------*\n*   ... and exit with a return code of 4.                             *\n*---------------------------------------------------------------------*\n         LA    R15,4                    Nothing good happened\n         J     E90010                   and exit\n\nE90010   DS    0H\n         LR    R3,R15                 Save return code\n\n*-------------------------------------------------------------------*\n*    DELETE H00010 (which we IDENTIFYed earlier)                    *\n*-------------------------------------------------------------------*\n         CLI   @E_H00010_IDENTIFY_ID,C'H'    Did we IDENTIFY?\n         JNO   E90020                 No, skip\n         DELETE EPLOC=@E_H00010_IDENTIFY_ID  Yes, Un-IDENTIFY\n         XC    @E_H00010_IDENTIFY_ID,@E_H00010_IDENTIFY_ID\n\nE90020   DS    0H\n*-------------------------------------------------------------------*\n*    If we are running under IKJEFTSR, update @_CPU_Time_Used       *\n*   with the time we spent (because we are running under a          *\n*   separate TCB).                                                  *\n*-------------------------------------------------------------------*\n         TM    @_OW48527,L'@_OW48527  OW48527 installed?\n         JO    E90040                 Yes, skip\n\n         TM    @_IKJEFTSR,L'@_IKJEFTSR Running because of IKJEFTSR?\n         JNO   E90040                  No, skip\n\n         TIMEUSED STORADR=@E_DBLWD,     Get CPU time used              +\n               LINKAGE=SYSTEM,           as recommended by IBM         +\n               CPU=MIC                   get it in microseconds\n         LM    R14,R15,@_CPU_Time_Used  Get current CPU Time used\n         AL    R15,@E_DBLWD+4           Bump it\n         BRC   12,E90030                No Carry, OK\n         AL    R14,=FL4'1'              Carry, bump\nE90030   DS    0H\n         AL    R14,@E_DBLWD             Bump high-order word\n         STM   R14,R15,@_CPU_Time_Used  Save CPU Time\n\nE90040   DS    0H\n*-------------------------------------------------------------------*\n*    Free up our local storage ...                                  *\n*-------------------------------------------------------------------*\n         LA    R1,@E_Dynam              A(Local storage)\n         L     R2,@E_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         L     R13,4(0,R13)             Rescue A(HSA)\n\n         SSCSTACK POP,                  Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=(R2)                on this stack\n\n*-------------------------------------------------------------------*\n*    ... and return to caller                                       *\n*-------------------------------------------------------------------*\n         LR    R15,R3                   Restore return code\n\n         L     R14,12(0,R13)            Restore return address\n         LM    R0,R12,20(R13)           Restore other registers\n         BSM   0,R14                    and return\n\nE_Literals            DS   0H\n\nE_IKJEFTSR_Flags      EQU  *            Flag bytes for IKJEFTSR\n                      DC   X'00'         Must be 0\n                      DC   X'00'         Invoke in isolated environ\n                      DC   X'01'         Dump if abend\n                      DC   X'02'         Invoking a program\n\nE_IKJEFTSR_TimeStamp  EQU  *\n                      DC   C'&PGMNAME'\n                      DC   C'&VERSION'\n                      DC   C'&SYSDATC'\n                      DC   C'&SYSTIME'\nE_IKJEFTSR_TimeStamp_Length EQU *-E_IKJEFTSR_TimeStamp\n\n\nE_TIME                TIME  LINKAGE=SYSTEM, Get the time               +\n               MF=L                      keep ourselves reentrant\nE_TIME_Length         EQU *-E_TIME\n\nE_ATTACHX             ATTACHX EP=0,     ATTACH something               +\n               ECB=0,                    POST this ECB when complete   +\n               SZERO=YES,                Share SubPool 0               +\n               ASYNCH=YES,               Allow subtask asynch exits    +\n               DPMOD=5,                  Run at a higher priority      +\n               SF=L                      keep ourselves reentrant\nE_ATTACHX_Length      EQU  *-E_ATTACHX\n\nE_STAX                STAX DEFER=YES, Suspend Attention Interrupts     +\n               MF=L                      keep ourselves reentrant\nE_STAX_Length         EQU  *-E_STAX\n\nE_Hex_TrTab           DC   C'0123456789ABCDEF'\n\n                      LTORG\n\nE_Literals_End        DS    0H\n\n\n@E_Dynam                  DSECT        Dynamic area for E00000\n                          DS    18F     O/S Style save area\n@E_31Bit_Stack_Ptr_Ptr    DS    AL4     A(31-bit Stack Ptr)\n@E_24Bit_Stack_Ptr_Ptr    DS    AL4     A(24-bit Stack Ptr)\n@E_DBLWD                  DS    D       Work area\n\n@E_NSwap_Start            DS    DL8     STCK at DONTSWAP\n\n@E_H00010_IDENTIFY_ID     DS    CL8     IDENTIFY Name\n\n@E_Macro                  DS    0D      Macros\n@E_TIME                   DS    CL(E_TIME_Length) TIME Macro area\n                          DS    0D\n@E_Time_Area              DS    XL16     Data returned by TIME\n@E_WkArea                 DS    CL10     EDit Word Area\n                          ORG   @E_Macro\n@E_ATTACHX                DS    CL(E_ATTACHX_Length) ATTACHX Macro area\n                          ORG   @E_Macro\n@E_STAX                   DS    CL(E_STAX_Length)  STAX Macro area\n                          ORG   @E_Macro\n@E_IKJEFTSR_Parms         DS    7AL4     Parm List for IKJEFTSR\n@E_IKJEFTSR_PgmName       DS    CL8      Program name\n@E_IKJEFTSR_PgmName_Length DS   FL4      Program name length\n@E_IKJEFTSR_ABEND         DS    FL4      Abend code area\n@E_IKJEFTSR_Pgm_Parm_Ptrs DS    2AL4     Pgm parm pointers\n\n@E_IKJEFTSR_Pgm_Parm1     DS    CL6      Len + A(@_Dynam)\n@E_IKJEFTSR_Pgm_Parm2     DS    CL18     Len + 16 bytes of @_Dynam\n                          ORG   ,       End of Macros\n\n@E_Parms                  DS    0F      Parms for called rtns\n@E_Parms_Std              DS    3AL4     Standard 3 parms\n                          ORG   ,\n                          DS    0D       Alignment\n@E_Dynam_Length           EQU   *-@E_Dynam      Length of storage\n\n&PGMNAME CSECT\n\n         DROP  ,\n         POP   USING\n         TITLE 'F00010: Output Results'\n\n         PUSH  USING\n\nF00010   DS    0H\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Routine   : F00010                                                 *\n*                                                                     *\n*  Abstract  : Display results of LSPACE stuff                        *\n*                                                                     *\n*  Inputs    : R1 : ---> A(@_Dynam)                                   *\n*                        A(31-bit Stack Pointer)                      *\n*                        A(24-bit Stack Pointer)                      *\n*  Outputs   : R15: 0                                                 *\n*                                                                     *\n*  Notes     : Uses the Info Table built by D00010, and               *\n*               whose address is in @_VolTbl_Ptr                      *\n*              For ISPF output,                                       *\n*                Invoke ISPF processor (G00010)                       *\n*              For a TSO Cmd,                                         *\n*               PUTLINE for each unit                                 *\n*              For a Batch job,                                       *\n*               Write to SYSPRINT for each unit                       *\n*                                                                     *\n*  History:    1990/06/11 SDDA030 - New                               *\n*              1999/05/27 SDDA030 - V2.6                              *\n*                                 - Used LIFO Stack for our dynamic   *\n*                                   areas.                            *\n*              1999/09/30 SDDA030 - V2.10                             *\n*                                 - Changed default sort order from   *\n*                                   descending volser to none.        *\n*                                 - Do STLINENO stuff and build       *\n*                                   PUTLINE CBs here instead of C00010*\n*                                 - Removed generation of Hdr1-3 in   *\n*                                   batch - now done in Y00010.       *\n*              2000/01/19 SDDA030 - V2.11                             *\n*                                 - Added SORT() keywords to F_TBLOFF.*\n*                                 - Passed sort parms to I00010 as    *\n*                                   pointers.                         *\n*                                 - Passed sort direction to I00010.  *\n*                                   Used 24-bit stack for STLINENO.   *\n*                                 - Filled in values in Stack Stats   *\n*                                   lines.                            *\n*              2000/05/23 SDDA030 - V2.12                             *\n*                                 - Added messages for:               *\n*                                    - IOSCDR unavailable             *\n*                                    - ISPF services unavailable      *\n*                                 - Split out ISPF output handling to *\n*                                   G00010.                           *\n*                                 - Invoked V00010 to update stats    *\n*                                   lines.                            *\n*              2001/02/01 SDDA030 - V2.13                             *\n*                                 - Removed IOSCDR message            *\n*                                 - Added messages for LNKLST and     *\n*                                   IJEFTSR errors.                   *\n*              2001/02/26 SDDA030 - V2.14                             *\n*                                 - Checked Terminal Line Size when   *\n*                                   doing PUTLINEs.                   *\n*              2002/06/11 SDDA030 - V2.18                             *\n*                                 - WAIT for VolTbl_Ent to be populated\n*                                   before outputting                 *\n*              2006/04/21 SDDA030 - V2.24                             *\n*                                 - Used standardized calling sequence*\n*                                 - Added 'Internal Error' and        *\n*                                   'Incompatible OS' messages.       *\n*                                 - Added 'Insufficient Storage' msg  *\n*              ____/__/__ _______                                     *\n*                                                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         STM   R14,R12,12(R13)          Save callers registers\n         LARL  R11,F_Literals           Point to our literals\n         USING (F_Literals,F_Literals_End),R11 Tell the assembler\n\n         L     R12,0(0,R1)              A(@_Dynam)\n         USING @_Dynam,R12              Tell the assembler\n\n*-------------------------------------------------------------------*\n*    Get an area on the stack for our local storage                 *\n*-------------------------------------------------------------------*\n         L     R2,4(0,R1)               A(31-bit stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         SSCSTACK PUSH,                 Get stack area                 +\n               LEN=@F_Dynam_Length,      this long                     +\n               STACK=(R2)                using this stack\n\n         LR    R3,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LHI   R1,@F_Dynam_Length        Its length\n         LA    R14,0                    Clear source address\n         LA    R15,0                     and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R3                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*-------------------------------------------------------------------*\n         ST    R13,4(0,R1)              Chain\n         ST    R1,8(0,R13)               saveareas\n         LR    R13,R1                   Load dynam base\n         USING @F_Dynam,R13             Assign a base\n         L     R15,@F_Dynam+4           Get A(HSA)\n         LM    R0,R3,20(R15)            Restore callers registers\n\n         L     R15,4(0,R1)              A(31-bit Stack Pointer)\n         ST    R15,@F_31Bit_Stack_Ptr_Ptr Save it\n         L     R15,8(0,R1)              A(24-bit Stack Pointer)\n         ST    R15,@F_24Bit_Stack_Ptr_Ptr Save it\n\n*--------------------------------------------------------------------*\n*   Initialize our standard parmlist                                 *\n*--------------------------------------------------------------------*\n         LA    R15,@_Dynam              A(Dynamic area)\n         ST    R15,@F_Parms_Std         Save it\n         L     R15,@F_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)\n         ST    R15,@F_Parms_Std+4       Save it\n         L     R15,@F_24Bit_Stack_Ptr_Ptr A(24-bit Stack Pointer)\n         ST    R15,@F_Parms_Std+8       Save it\n\n*---------------------------------------------------------------------*\n*   If everything worked OK, but we are suppressing all the output,   *\n*  we are done.                                                       *\n*---------------------------------------------------------------------*\n         ICM   R15,B'1111',@_VolTbl_Ptr A(VolTbl)\n         JZ    F00020                   None, skip\n         ICM   R15,B'1111',VolTbl_Hdr_Vols_Total-VolTbl_Hdr(R15)\n         JZ    F00020                   No volumes, skip\n         TM    @_LSPACE_Failed,L'@_LSPACE_Failed LSPACE problem?\n         JO    F00020                   Yes, skip\n         TM    @_VolTbl_GETMAIN_Err,L'@_VolTbl_GETMAIN_Err GETMAIN err?\n         JO    F00020                   Yes, skip\n\n         TM    @_No_Headings,L'@_No_Headings  Suppressing headings?\n         JNO   F00020                   No, skip\n         TM    @_No_Details,L'@_No_Details Suppressing detail?\n         JNO   F00020                   No, skip\n         TM    @_No_Totals,L'@_No_Totals  Suppressing Totals?\n         JNO   F00020                   No, skip\n         TM    @_Statistics,L'@_Statistics Producing Statistics?\n         JO    F00020                   Yes, skip\n\n         LA    R15,0                    Clear return code\n         J     F90010                   and exit\n\nF00020   DS    0H\n*---------------------------------------------------------------------*\n*   If there is anything to display ...                               *\n*---------------------------------------------------------------------*\n         ICM   R15,B'1111',@_VolTbl_Ptr A(VolTbl)\n         JZ    F00030                   None, skip the sort\n         ICM   R15,B'1111',VolTbl_Hdr_Vols_Total-VolTbl_Hdr(R15)\n         JZ    F00030                   No volumes, skip sort\n\n*---------------------------------------------------------------------*\n*   ... sort it, if required.                                         *\n*---------------------------------------------------------------------*\n         CLI   @_Sort_Field,C' '        Any sort?\n         JE    F00030                   No, skip\n\n         LA    R15,@_Sort_Field         A(Sort Field)\n         ST    R15,@F_Parms_I00010      Save it\n         LA    R15,@_Sort_Direction     A(Sort direction)\n         ST    R15,@F_Parms_I00010+4    Save it\n\n         LA    R1,@F_Parms              A(Parms)\n         BRAS  R14,I00010               Go sort the table\n\nF00030   DS    0H\n*---------------------------------------------------------------------*\n*   Set up any applicable error messages                              *\n*---------------------------------------------------------------------*\n         MVI   @F_ErrMsgL,C' '          Clear msg area\n         MVC   @F_ErrMsgL+1(L'@F_ErrMsgL-1),@F_ErrMsgL\n         MVC   @F_ErrMsgS,@F_ErrMsgL    Short message too\n\n         TM    @_OW48527,L'@_OW48527    APAR OW48527 installed?\n         JO    F00060                   Yes, skip IKJEFTSR stuff\n\n         TM    @_No_APF,L'@_No_APF      Are we APF'ed?\n         JNO   F00040                   Yes, skip\n*---------------------------------------------------------------------*\n*     - Insufficient APF                                              *\n*       not APFed even when invoked by IKJEFTSR, or IKJEFTSR failed   *\n*       with RC=14, Reas=18 or 34                                     *\n*---------------------------------------------------------------------*\n         MVC   @F_ErrMsgL(L'F_EMsg02),F_EMsg02 Move APF msg\n         J     F00165                   and skip\nF00040   DS    0H\n         TM    @_IKJEFTSR_Err,L'@_IKJEFTSR_Err IKJEFTSR error?\n         JNO   F00050                   No, skip\n         L     R15,@_IKJEFTSR_RC        Yes, get IKJEFTSR RC\n         CHI   R15,20                   RC = 20?\n         JNE   F00045                   No, generic IKJEFTSR error\n         L     R15,@_IKJEFTSR_Reas      Yes, get reason code\n         CHI   R15,40                   Program not found?\n         JNE   F00045                   No, generic IKJEFTSR msg\n*---------------------------------------------------------------------*\n*     - Not in LNKLST/STEPLIB concatenation                           *\n*       IKJEFTSR couldn't find the module (RC=14,Reas=28)             *\n*---------------------------------------------------------------------*\n         MVC   @F_ErrMsgL(L'F_EMsg06),F_EMsg06 Move LNKLST msg\n         J     F00165                   and skip\nF00045   DS    0H\n*---------------------------------------------------------------------*\n*     - Unknown IKJEFTSR Error xx-yy                                  *\n*       Something else from IKJEFTSR xx: return code, yy:reason       *\n*---------------------------------------------------------------------*\n         MVC   @F_ErrMsgL(L'F_EMsg07),F_EMsg07 Move message\n         L     R15,@_IKJEFTSR_RC        Get ISPF failure return code\n         SLL   R15,4                    Make room for the sign\n         STH   R15,@F_DBLWD             Save it\n         OI    @F_DBLWD+1,X'0F'         Make it packed\n         UNPK  @F_DBLWD+2(3),@F_DBLWD(2) Unpack it\n         MVC   @F_ErrMsgL+F_EMsg07_RC-F_EMsg07(2),@F_DBLWD+3\n         TR    @F_ErrMsgL+F_EMsg07_RC-F_EMsg07(2),F_Hex_TrTab\n\n         L     R15,@_IKJEFTSR_Reas      Get ISPF failure reason code\n         SLL   R15,4                    Make room for the sign\n         STH   R15,@F_DBLWD             Save it\n         OI    @F_DBLWD+1,X'0F'         Make it packed\n         UNPK  @F_DBLWD+2(3),@F_DBLWD(2) Unpack it\n         MVC   @F_ErrMsgL+F_EMsg07_Reas-F_EMsg07(2),@F_DBLWD+3\n         TR    @F_ErrMsgL+F_EMsg07_Reas-F_EMsg07(2),F_Hex_TrTab\n         J     F00165                   And skip\nF00050   DS    0H\n         TM    @_SYSCLOCK_Err,L'@_SYSCLOCK_Err Code mismatch?\n         JNO   F00060                   No, skip\n*---------------------------------------------------------------------*\n*     - TimeStamp mismatch                                            *\n*       IKJEFTSR invoked a different version of the code - could be   *\n*       caused by this pgm being in ISPLLIB                           *\n*---------------------------------------------------------------------*\n         MVC   @F_ErrMsgL(L'F_EMsg09),F_EMsg09\n         J     F00165                   and skip\nF00060   DS    0H\n         TM    @_Internal_Err,L'@_Internal_Err Internal error?\n         JNO   F00070                   No, skip\n*---------------------------------------------------------------------*\n*     - Unrecognized parm (probably on re-invocation via IKJEFTSR)    *\n*---------------------------------------------------------------------*\n         MVC   @F_ErrMsgL(L'F_EMsg11),F_EMsg11\n         J     F00165                   and skip\nF00070   DS    0H\n         TM    @_Incompatible_OS,L'@_Incompatible_OS Incompatible?\n         JNO   F00110                   No, skip\n*---------------------------------------------------------------------*\n*     - CSVQUERY function unavailable                                 *\n*---------------------------------------------------------------------*\n         MVC   @F_ErrMsgL(L'F_EMsg05),F_EMsg05\n         L     R14,CVTPTR               A(CVT)\n         L     R15,CVTECVT-CVT(0,R14)   A(EVCT)\n         MVC   @F_ErrMsgL+L'F_EMsg05(L'ECVTPNAM),ECVTPNAM-ECVT(R15)\n         LA    R1,@F_ErrMsgL+L'F_EMsg05+L'ECVTPNAM-1\n         LA    R0,@F_ErrMsgL+L'F_EMsg05\nF00080   DS    0H\n         CLI   0(R1),C' '               Last significant character\n         JNE   F00090                   Yes, skip\n         S     R1,=FL4'1'               No, back up a byte\n         CR    R1,R0                    Too far?\n         JH    F00080                   No, check again\nF00090   DS    0H\n         TM    CVTOSLV5-CVT(R14),CVTZOSE z/OS.e?\n         JZ    F00100                   No, skip\n         MVC   1(2,R1),=C'.e'           Yes, say so\n         LA    R1,2(0,R1)               and bump pointer\nF00100   DS    0H\n         MVC   2(L'ECVTPVER,R1),ECVTPVER-ECVT(R15)  Version\n         MVI   2+L'ECVTPVER(R1),C'.'    Separator\n         MVC   2+L'ECVTPVER+1(L'ECVTPREL,R1),ECVTPREL-ECVT(R15) Rel\n         MVI   2+L'ECVTPVER+1+L'ECVTPREL(R1),C'.'    Separator\n         MVC   2+L'ECVTPVER+1+L'ECVTPREL+1(L'ECVTPMOD,R1),ECVTPMOD-ECVT+\n               (R15)\n         J     F00165                   And skip\nF00110   DS    0H\n         TM    @_VolTbl_GETMAIN_Err,L'@_VolTbl_GETMAIN_Err GETMAIN?\n         JNO   F00150                   No, skip\n*---------------------------------------------------------------------*\n*     - Insufficient Storage                                          *\n*---------------------------------------------------------------------*\n         MVC   @F_ErrMsgL(L'F_EMsg10),F_EMsg10\n         ICM   R15,B'1111',@_VolTbl_Ptr  A(VolTbl)\n         JZ    F00165                   None, skip\n         L     R0,VolTbl_Hdr_Vols_Eligible-VolTbl_Hdr(R15)\n         S     R0,VolTbl_Hdr_Vols_Total-VolTbl_Hdr(R15)\n         JP    F00120                   Some omitted, skip\n         MVC   @F_ErrMsgL+L'F_EMsg10+1(41),=C'Some totals/statistics li+\n               nes may be missing'\n         J     F00165                   all done\nF00120   DS    0H\n         CVD   R0,@F_DBLWD              Pack missing vols\n         MVC   @F_ErrMsgL+L'F_EMsg10(10),=X'40206B2020206B202120'\n         LA    R1,@F_ErrMsgL+L'F_EMsg10+9 Prime pointer\n         LR    R14,R1                  Save it\n         EDMK  @F_ErrMsgL+L'F_EMsg10(10),@F_DBLWD+4\n         LA    R15,@F_ErrMsgL+L'F_EMsg10+1 Left adjust start\n         CR    R1,R15                   Do we need to adjust?\n         JNH   F00140                   No, skip\n         SR    R14,R1                   Yes, EX len of number\n         EX    R14,F_EX1                Left adjust it\n         AR    R15,R14                  A(Last char)\nF00140   DS    0H\n         MVC   1(16,R15),=C' volumes omitted'\n         J     F00165                   and skip\nF00150   DS    0H\n         ICM   R15,B'1111',@_VolTbl_Ptr A(VolTbl)\n         JZ    F00160                   None, skip\n         ICM   R15,B'1111',VolTbl_Hdr_Vols_Total-VolTbl_Hdr(R15)\n         JNZ   F00170                   Got some data, skip\nF00160   DS    0H\n*---------------------------------------------------------------------*\n*     - VolTbl empty                                                  *\n*---------------------------------------------------------------------*\n         MVC   @F_ErrMsgS(4),=C'None'   No data\n         MVC   @F_ErrMsgL(L'F_EMsg01),F_EMsg01 Move No data msg\n         J     F00170                   and skip\n\nF00165   DS    0H\n         MVC   @F_ErrMsgS(10),=C'Incomplete' Flag table as incomplete\n\nF00170   DS    0H\n         NI    @_ReDisplay,X'FF'-L'@_ReDisplay  Off redisplay flag\n\n*---------------------------------------------------------------------*\n*      If output is via ISPF, go do it                                *\n*---------------------------------------------------------------------*\n         TM    @_Batch_Environ,L'@_Batch_Environ Are we Batch?\n         JO    F00190                   Yes, skip\n\n         TM    @_ISPF_SPACE,L'@_ISPF_SPACE ISPF Output requested?\n         JO    F00180                   Yes, skip\n         TM    @_ISPF_EDIF,L'@_ISPF_EDIF ISPF Output requested?\n         JO    F00180                   Yes, skip\n         TM    @_ISPF_BRIF,L'@_ISPF_BRIF ISPF Output requested?\n         JZ    F00190                   No, skip\n\nF00180   DS    0H\n         LA    R15,@F_ErrMsgS           A(Short error msg)\n         ST    R15,@F_Parms_G00010      Save it\n         LA    R15,@F_ErrMsgL           A(Long error msg)\n         ST    R15,@F_Parms_G00010+4    Save it\n\n         LA    R1,@F_Parms              A(Parms)\n         BRAS  R14,G00010               Go do ISPF stuff\n\n         TM    @_ReDisplay,L'@_ReDisplay Do we need to display again?\n         JO    F00170                   Yes, go do it\n         LTR   R15,R15                  No, did it work?\n         JZ    F90010                   Yes, exit quick smart\n         STH   R15,@F_G00010_RC         No, save return code\n         STH   R0,@F_G00010_Reas         and reason code\n\nF00190   DS    0H\n*---------------------------------------------------------------------*\n*      Perform initialization stuff for our environment               *\n*---------------------------------------------------------------------*\n         TM    @_TSO_Command,L'@_TSO_Command Is this a TSO command?\n         JZ    F00240                   No, skip\n\n*---------------------------------------------------------------------*\n*   TSO Command Processing - Clear the screen, and build our          *\n*  PUTLINE control blocks                                             *\n*---------------------------------------------------------------------*\n         L     R15,@F_24Bit_Stack_Ptr_Ptr A(24-bit Stack pointer)\n         ICM   R0,B'1111',0(R15)        A(24-bit stack)\n         JNZ   F00200                   OK, skip\n\n         LHI   R0,@_24Bit_Stack_Length  Length of storage we need\n         SSCSTACK INIT,                 Go get our storage             +\n               LEN=(R0),                 this long                     +\n               LOC=24                    below the line\n\n         L     R15,@F_24Bit_Stack_Ptr_Ptr A(24-bit Stack Pointer)\n         ST    R1,0(0,R15)              Update it\n\nF00200   DS    0H\n         L     R2,@F_24Bit_Stack_Ptr_Ptr A(24_bit Stack Pointer)\n         L     R2,0(0,R2)               A(24-bit Stack)\n         SSCSTACK PUSH,                 Get stack area                 +\n               LEN=F00230_End-F00230,    this long                     +\n               STACK=(R2)                using this stack\n\n         LR    R3,R1                    Save the address\n\n         LR    R1,R0                    Amount of storage we got\n         LR    R0,R3                    Point to it\n         LARL  R14,F00230                RMODE24 stuff)\n         LHI   R15,F00230_End-F00230    Length of STLINENO stuff\n         MVCL  R0,R14                   Move it\n\n         LR    R15,R3                   Point to the RMODE 24 stuff\n         BASR  R14,R15                  Go do it\n\n         L     R2,@F_24Bit_Stack_Ptr_Ptr A(24_bit Stack Pointer)\n         L     R2,0(0,R2)               A(24-bit Stack)\n         SSCSTACK POP,                  Free the stack area            +\n               ADDR=(R3),                starting here                 +\n               STACK=(R2)                on this stack\n\n*-------------------------------------------------------------------*\n*    ... and build the PUTLINE control blocks.                      *\n*-------------------------------------------------------------------*\n         L     R1,@_CPPL_Ptr            A(CPPL)\n         MVC   @F_IOPL+IOPLUPT-IOPL(L'IOPLUPT),CPPLUPT-CPPL(R1)\n         MVC   @F_IOPL+IOPLECT-IOPL(L'IOPLECT),CPPLECT-CPPL(R1)\n         LA    R15,@F_IOECB             A(Our ECB)\n         ST    R15,@F_IOPL+IOPLECB-IOPL Save it\n         LA    R15,@F_PLPB              A(PUTLINE Parm block)\n         ST    R15,@F_IOPL+IOPLIOPB-IOPL Save it\n         MVC   @F_PLPB,F_PLPB           Move PUTLINE Parm Block\n         LA    R15,@F_OLD               A(OLD)\n         ST    R15,@F_PLPB+4            Save in PLPB\n         LA    R15,0                    Clear work reg\n         ST    R15,@F_PLPB+8            Clear A(Format line)\n\n         LH    R1,@_LineSize            Get linesize from command line\n         LTR   R1,R1                    Anything?\n         JNZ   F00210                   Yup, skip\n         GTSIZE  ,                      Get terminal line size\n         AHI   R1,-1                     minus 1 byte\nF00210   DS    0H\n         LHI   R15,VolTbl_Ent_Display_Len Max len of data\n         LTR   R1,R1                    LINESIZE(MAX)?\n         JM    F00220                   Yes, use it\n         CR    R15,R1                   Can we display all the data?\n         JNH   F00220                   Yes, OK\n         LR    R15,R1                   No, display as much as we can\nF00220   DS    0H\n         AHI   R15,@F_VolTbl_Ent_Copy-@F_OLD Add len of OLD\n         STH   R15,@F_OLDLN             Save it\n         LA    R15,0                    Clear\n         STH   R15,@F_OLDOF              offset\n         J     F00270                   and skip\n\n*---------------------------------------------------------------------*\n*   This code fragment issues STLINENO. This code is moved to 24-bit  *\n*    storage, because the STLINENO SVC must be issued in AMODE 24.    *\n*---------------------------------------------------------------------*\n         PUSH  USING                    Save the USING environment\n         DROP  ,                        Free all current USINGs\n\nF00230   DS    0H\n         USING *,R15                    Assign temp base\n         STM   R0,R15,F00230_Save       Save callers registers\n         LR    R11,R15                  Load 'perm' base reg\n         DROP  R15                      Free temp\n         USING F00230,R11               Tell assembler about R11\n\n         STLINENO LINE=1                Clear the screen\n\n         LM    R0,R15,F00230_Save       Restore callers registers\n         BSM   0,R14                    And exit\n\n\nF00230_Save   DS   18F                  Save area\n              DS   0D                   Alignment\n\n         DROP  R11                      Free up base reg\n\nF00230_End   EQU        *               End of STLINENO Code\n\n         POP   USING                   Restore USING environment\n\nF00240   DS    0H\n*---------------------------------------------------------------------*\n*   Batch Job Processing                                              *\n*---------------------------------------------------------------------*\n         LHI   R0,4095                  Get count for Hdg0\n         LH    R15,@_Line_Count         Get current line count\n         CR    R15,R0                   Did C00010 start a new page?\n         JE    F00250                   No, we had better\n         LHI   R15,4094                 Yes, only Hdg1-3\n         J     F00260                   and skip\nF00250   DS    0H\n         LHI   R15,4090                 New page, Hdg0-3\nF00260   DS    0H\n         STH   R15,@_Line_Count         Save updated line count\n\n         J     F00270                   and skip\n\nF00270   DS    0H\n*---------------------------------------------------------------------*\n*   If we are here because ISPF output was requested, but we          *\n*  couldn't access ISPF DM services, say so now.                      *\n*---------------------------------------------------------------------*\n         TM    @_ISPF_SPACE,L'@_ISPF_SPACE ISPF Output requested?\n         JO    F00280                   Yes, skip\n         TM    @_ISPF_EDIF,L'@_ISPF_EDIF ISPF Output requested?\n         JO    F00280                   Yes, skip\n         TM    @_ISPF_BRIF,L'@_ISPF_BRIF ISPF Output requested?\n         JZ    F00300                   No, skip\n\nF00280   DS    0H\n         NI    @_ISPF_SPACE,X'FF'-L'@_ISPF_SPACE Not any more\n         NI    @_ISPF_EDIF,X'FF'-L'@_ISPF_EDIF Not any more\n         NI    @_ISPF_BRIF,X'FF'-L'@_ISPF_BRIF Not any more\n\n         TM    @_ISPF_Explicit,L'@_ISPF_Explicit ISPF specified?\n         JZ    F00300                   No, skip message\n\n         LA    R14,F_EMsg03             A(Source)\n         LHI   R15,L'F_EMsg03           Source Length\n         O     R15,=XL4'40000000'       Pad char of blank\n         LA    R0,@F_VolTbl_Ent_Copy    A(Target)\n         LHI   R1,@F_VolTbl_Ent_Copy_Len Target length\n         MVCL  R0,R14                   Move message\n         LH    R15,@F_G00010_RC         Get ISPF failure return code\n         SLL   R15,4                    Make room for the sign\n         STH   R15,@F_DBLWD             Save it\n         OI    @F_DBLWD+1,X'0F'         Make it packed\n         UNPK  @F_DBLWD+2(3),@F_DBLWD(2) Unpack it\n         MVC   @F_VolTbl_Ent_Copy+F_EMsg03_RC-F_EMsg03(2),@F_DBLWD+3\n         TR    @F_VolTbl_Ent_Copy+F_EMsg03_RC-F_EMsg03(2),F_Hex_TrTab\n\n         LH    R15,@F_G00010_Reas       Get ISPF failure reason code\n         SLL   R15,4                    Make room for the sign\n         STH   R15,@F_DBLWD             Save it\n         OI    @F_DBLWD+1,X'0F'         Make it packed\n         UNPK  @F_DBLWD+2(3),@F_DBLWD(2) Unpack it\n         MVC   @F_VolTbl_Ent_Copy+F_EMsg03_Reas-F_EMsg03(2),@F_DBLWD+3\n         TR    @F_VolTbl_Ent_Copy+F_EMsg03_Reas-F_EMsg03(2),F_Hex_TrTab\n\n         TM    @_TSO_Command,L'@_TSO_Command Is this a TSO command?\n         JZ    F00290                   No, skip\n\n         PUTLINE MF=(E,@F_IOPL)         Write it\n\n         LA    R14,F_EMsg04             A(Source)\n         LHI   R15,L'F_EMsg04           Source Length\n         O     R15,=XL4'40000000'       Pad char of blank\n         LA    R0,@F_VolTbl_Ent_Copy    A(Target)\n         LHI   R1,@F_VolTbl_Ent_Copy_Len Target length\n         MVCL  R0,R14                   Move message\n         PUTLINE MF=(E,@F_IOPL)         Write it\n         J     F00300                   and skip\n\nF00290   DS    0H\n         LA    R15,@F_VolTbl_Ent_Copy   A(Message)\n         ST    R15,@F_Parms_Y00010      Save it\n         LHI   R15,L'F_EMsg03           Length of message\n         ST    R15,@F_Parms_Y00010+4    Save it\n\n         LA    R1,@F_Parms              A(Parms)\n         BRAS  R14,Y00010               Output to SYSPRINT\n\n         LA    R15,F_EMsg04             A(Message)\n         ST    R15,@F_Parms_Y00010      Save it\n         LHI   R15,L'F_EMsg04           Length of message\n         ST    R15,@F_Parms_Y00010+4    Save it\n\n         LA    R1,@F_Parms              A(Parms)\n         BRAS  R14,Y00010               Output to SYSPRINT\n         J     F00300                   and skip\n\nF00300   DS    0H\n*---------------------------------------------------------------------*\n*   If we have an error message, put it out now                       *\n*---------------------------------------------------------------------*\n         CLI   @F_ErrMsgL,C' '          Anything?\n         JE    F00320                   Nope, skip\n\n         TM    @_TSO_Command,L'@_TSO_Command Is this a TSO command?\n         JNO   F00310                   No, skip\n\n         LA    R14,@F_ErrMsgL           A(Source)\n         LHI   R15,L'@F_ErrMsgL         Source Length\n         O     R15,=XL4'40000000'       Pad char of blank\n         LA    R0,@F_VolTbl_Ent_Copy    A(Target)\n         LHI   R1,@F_VolTbl_Ent_Copy_Len Target length\n         MVCL  R0,R14                   Move message\n         PUTLINE MF=(E,@F_IOPL)         Write it\n         J     F00320                   and skip\nF00310   DS    0H\n         LA    R15,@F_ErrMsgL           A(Message)\n         ST    R15,@F_Parms_Y00010      Save it\n         LHI   R15,L'@F_ErrMsgL         Len of data\n         ST    R15,@F_Parms_Y00010+4    Save it\n\n         LA    R1,@F_Parms              A(Parms)\n         BRAS  R14,Y00010               Output to SYSPRINT\n         J     F00320                   and skip\n\nF00320   DS    0H\n*---------------------------------------------------------------------*\n*   Common processing                                                 *\n*---------------------------------------------------------------------*\n         ICM   R15,B'1111',@_VolTbl_Ptr A(VolTbl)\n         JZ    F80010                   None, exit with error\n         ICM   R15,B'1111',VolTbl_Hdr_Vols_Total-VolTbl_Hdr(R15)\n         JZ    F80010                   No volumes, exit with error\n\n         TM    @_No_Headings,L'@_No_Headings  Headings wanted?\n         JO    F00400                   No, skip\n\n         TM    @_TSO_Command,L'@_TSO_Command Is this a TSO command?\n         JZ    F00400                   No, skip\n\n*---------------------------------------------------------------------*\n*   TSO Command processing for Headings                               *\n*---------------------------------------------------------------------*\n         ICM   R9,B'1111',@_VolTbl_Ptr  A(Volume Table)\n         JZ    F00400                   No vol tbl, skip headings\n         ICM   R10,B'1111',VolTbl_Hdr_Count-VolTbl_Hdr(R9) Get count\n         JZ    F00400                   None,skip headings\n         AHI   R9,VolTbl_Ent-VolTbl_Hdr Yes, point to first\n         USING VolTbl_Ent,R9            Assign a base\nF00370   DS    0H\n         TM    VolTbl_Ent_Heading_Line1,L'VolTbl_Ent_Heading_Line1\n         JO    F00380                   Yes, skip\n         TM    VolTbl_Ent_Heading_Line,L'VolTbl_Ent_Heading_Line\n         JZ    F00400                   End of headings, skip\nF00380   DS    0H\n         TM    VolTbl_Ent_ECB,X'40'     Has the line been populated?\n         JO    F00390                   Yes, skip\n         WAIT  ECB=VolTbl_Ent_ECB       Not yet, wait for it\nF00390   DS    0H\n         LA    R14,VolTbl_Ent_Display   A(Source)\n         LHI   R15,VolTbl_Ent_Display_Len Source Length\n         O     R15,=XL4'40000000'       Pad char of blank\n         LA    R0,@F_VolTbl_Ent_Copy    A(Target)\n         LHI   R1,@F_VolTbl_Ent_Copy_Len Target length\n         MVCL  R0,R14                   Move message\n         PUTLINE MF=(E,@F_IOPL)         Write it\n\n         AHI   R9,VolTbl_Ent_Len        Bump table pointer\n         BRCT  R10,F00370               and do next\n\n         DROP  R9                       Free our base\n\nF00400   DS    0H\n*---------------------------------------------------------------------*\n*   Common processing for VolTbl Entry                                *\n*---------------------------------------------------------------------*\n         ICM   R9,B'1111',@_VolTbl_Ptr  A(Volume Table)\n         JZ    F90010                   Nothing, exit\n         ICM   R10,B'1111',VolTbl_Hdr_Count-VolTbl_Hdr(R9) nbr ents\n         JZ    F90010                   Nothing, exit\n         AHI   R9,VolTbl_Ent-VolTbl     Point to first entry\n         USING VolTbl_Ent,R9            and assign a base\n\nF00410   DS    0H\n*--------------------------------------------------------------------*\n*     If this is a heading line, skip it                             *\n*--------------------------------------------------------------------*\n         TM    VolTbl_Ent_Heading_Line1,L'VolTbl_Ent_Heading_Line1\n         JO    F00470                   Yes, skip\n         TM    VolTbl_Ent_Heading_Line,L'VolTbl_Ent_Heading_Line\n         JO    F00470                   a heading, skip it\n\n*--------------------------------------------------------------------*\n*     If this is a line we want ...                                  *\n*--------------------------------------------------------------------*\n         TM    VolTbl_Ent_Detail_Line,L'VolTbl_Ent_Detail_Line\n         JNO   F00420                   No, skip\n         TM    @_No_Details,L'@_No_Details Do we want details?\n         JNO   F00440                   Yes, go process it\n         J     F00470                   No, ignore it\n\nF00420   DS    0H\n         TM    VolTbl_Ent_Total_Line,L'VolTbl_Ent_Total_Line Total?\n         JNO   F00430                   No, skip\n         TM    @_No_Totals,L'@_No_Totals Do we want totals?\n         JNO   F00440                   Yes, go process it\n         J     F00470                   No, ignore it\n\nF00430   DS    0H\n*--------------------------------------------------------------------*\n*     If this is a Statistics line, fill it in ...                   *\n*--------------------------------------------------------------------*\n         TM    VolTbl_Ent_Stats_Line,L'VolTbl_Ent_Stats_Line\n         JNO   F00440                   No, go display it\n\n         LA    R15,VolTbl_Ent           Point to the Volume Tbl entry\n         ST    R15,@F_Parms_V00010      Save it\n         LA    R1,@F_Parms              A(Parms)\n         BRAS  R14,V00010               Go process stats\n\nF00440   DS    0H\n         TM    VolTbl_Ent_ECB,X'40'     Has the line been populated?\n         JO    F00450                   Yes, skip\n         WAIT  ECB=VolTbl_Ent_ECB       Not yet, WAIT for it\n\nF00450   DS    0H\n*--------------------------------------------------------------------*\n*     ... and output this line, either via PUTLINE ...               *\n*--------------------------------------------------------------------*\n         TM    @_TSO_Command,L'@_TSO_Command Is this a TSO command?\n         JZ    F00460                   No, skip\n\n         LA    R14,VolTbl_Ent_Display   A(Source)\n         LHI   R15,VolTbl_Ent_Display_Len Source Length\n         O     R15,=XL4'40000000'       Pad char of blank\n         LA    R0,@F_VolTbl_Ent_Copy    A(Target)\n         LHI   R1,@F_VolTbl_Ent_Copy_Len Target length\n         MVCL  R0,R14                   Move message\n         PUTLINE MF=(E,@F_IOPL)         Write it\n         J     F00470                   and skip\n\nF00460   DS    0H\n*--------------------------------------------------------------------*\n*     ... or to SYSPRINT                                             *\n*--------------------------------------------------------------------*\n         LA    R15,VolTbl_Ent_Display   Data area\n         ST    R15,@F_Parms_Y00010      Save it\n         LHI   R15,VolTbl_Ent_Display_Len Len of data\n         ST    R15,@F_Parms_Y00010+4    Save it\n\n         LA    R1,@F_Parms              A(Parms)\n         BRAS  R14,Y00010               Go print it\n         J     F00470                   and skip\n\nF00470   DS    0H\n*--------------------------------------------------------------------*\n*     Point to next VolTbl Entry, and continue                       *\n*--------------------------------------------------------------------*\n         AHI   R9,VolTbl_Ent_Len        A(Next entry)\n         BRCT  R10,F00410               and continue\n         DROP  R9\n\nF00480   DS    0H\n*--------------------------------------------------------------------*\n*   We've finished displaying the table, so write it to OutFile, if  *\n*    required.                                                       *\n*--------------------------------------------------------------------*\n         SLR   R15,R15                  Clear return code\n         CLI   @_OutFile_DDName,C' '    Any output file?\n         JE    F00600                   No, just exit\n\n         LA    R15,@_OutFile_DDName     Yes, point to it\n         ST    R15,@F_Parms_X00010      Save it\n         TM    @_OutData_DISPLAY,L'@_OutData_DISPLAY\n         JNO   F00500                   No, skip\n         LA    R15,@_OutData_DISPLAY    Yes, point to it\n         J     F00520                   and skip\nF00500   DS    0H\n         TM    @_OutData_CB,L'@_OutData_CB\n         JNO   F00510                   No, skip\n         LA    R15,@_OutData_CB         Yes, point to it\n         J     F00520                   and skip\nF00510   DS    0H\n         LA    R15,@_OutData_ALL        All output\nF00520   DS    0H\n         ST    R15,@F_Parms_X00010+4    Save A(OutData Flag)\n         LA    R1,@F_Parms              A(Parm list)\n         BRAS  R14,X00010               Output to file, if necessary\n         LTR   R15,R15                  Did it work?\n         JZ    F00600                   Yes, exit\n\n*--------------------------------------------------------------------*\n*     OutFile processing failed - build our error message ...        *\n*--------------------------------------------------------------------*\n         MVI   @F_ErrMsgL,C' '          Clear msg area\n         MVC   @F_ErrMsgL+1(L'@F_ErrMsgL-1),@F_ErrMsgL\n         MVC   @F_ErrMsgL(L'F_Emsg12),F_EMsg12  Move msg start\n         MVC   @F_ErrMsgL+L'F_EMsg12+1(L'@_OutFile_DDName),@_OutFile_DD+\n               Name\n         LA    R15,@F_ErrMsgL+L'F_EMsg12+1+L'@_OutFile_DDName-1\nF00530   DS    0H\n         CLI   0(R15),C' '              End of DDName?\n         JNE   F00540                   yes, skip\n         BCT   R15,F00530               No, back up and try again\nF00540   DS    0H\n         MVC   2(21,R15),=C'not useable - ignored'\n\n*--------------------------------------------------------------------*\n*     ... and let the user know ...                                  *\n*--------------------------------------------------------------------*\n         TM    @_Batch_Environ,L'@_Batch_Environ Are we Batch?\n         JO    F00570                   Yes, skip\n         TM    @_ISPF_SPACE,L'@_ISPF_SPACE ISPF Output requested?\n         JO    F00550                   Yes, skip\n         TM    @_ISPF_EDIF,L'@_ISPF_EDIF ISPF Output requested?\n         JO    F00550                   Yes, skip\n         TM    @_ISPF_BRIF,L'@_ISPF_BRIF ISPF Output requested?\n         JZ    F00570                   No, skip\n\nF00550   DS    0H\n*--------------------------------------------------------------------*\n*     ... via ISPF ...                                               *\n*--------------------------------------------------------------------*\n         MVC   @F_LINKX,F_LINKX         Move LINK L-Form\n\n         LA    R15,=CL8'VDEFINE'        ISPF Function\n         ST    R15,@F_ISPF_Parms        Save it\n         LA    R15,=CL8'CHAR'           Character variables\n         ST    R15,@F_ISPF_Parms+12     Save it\n\n         LA    R15,=CL8'ZEDSMSG'        Variable name\n         ST    R15,@F_ISPF_Parms+4      Save it\n         LA    R15,=C'OutFile Error'    Short message\n         ST    R15,@F_ISPF_Parms+8      Save it\n         LA    R15,=AL4(13)             Length of message\n         ST    R15,@F_ISPF_Parms+16     Save it\n         OI    @F_ISPF_Parms+16,X'80'   Flag end of list\n\n         LARL  R2,F00560                A(Error return address)\n         LINKX EP=ISPLINK,              Link to ISPF Interface         +\n               ERRET=(2),                error here                    +\n               MF=(E,@F_ISPF_Parms),     passing these parms           +\n               SF=(E,@F_LINKX)           staying re-entrant\n\n         LA    R15,=CL8'ZEDLMSG'        Variable name\n         ST    R15,@F_ISPF_Parms+4      Save it\n         LA    R15,@F_ErrMsgL           Long message\n         ST    R15,@F_ISPF_Parms+8      Save it\n         LA    R15,=AL4(L'@F_ErrMsgL)   Length of message\n         ST    R15,@F_ISPF_Parms+16     Save it\n         OI    @F_ISPF_Parms+16,X'80'   Flag end of list\n         LINKX EP=ISPLINK,              Link to ISPF Interface         +\n               ERRET=(2),                error here                    +\n               MF=(E,@F_ISPF_Parms),     passing these parms           +\n               SF=(E,@F_LINKX)           staying re-entrant\n\n         LA    R15,=CL8'SETMSG'         Yes, ISPF Function\n         ST    R15,@F_ISPF_Parms        Save it\n         LA    R15,=CL8'ISRZ001'        A(Message ID)\n         ST    R15,@F_ISPF_Parms+4      Save it\n         OI    @F_ISPF_Parms+4,X'80'    Mark end of list\n         LINKX EP=ISPLINK,              Link to ISPF Interface         +\n               ERRET=(2),                error here                    +\n               MF=(E,@F_ISPF_Parms),     passing these parms           +\n               SF=(E,@F_LINKX)           staying re-entrant\n         J     F00590                   and exit with error\n\nF00560   DS    0H\n         LA    R1,@F_ErrMsgL            A(Error Message)\n         LA    R0,L'@F_ErrMsgL          Length\n         TPUT  (1),(0)                  All else failed\n         J     F00590                   and exit with error\n\nF00570   DS    0H\n*--------------------------------------------------------------------*\n*     ... or PUTLINE ...                                             *\n*--------------------------------------------------------------------*\n         TM    @_TSO_Command,L'@_TSO_Command Is this a TSO command?\n         JZ    F00580                   No, skip\n\n         LA    R14,@F_ErrMsgL           A(Source)\n         LHI   R15,L'@F_ErrMsgL         Length\n         O     R15,=XL4'40000000'       Pad char of blank\n         LA    R0,@F_VolTbl_Ent_Copy    A(Target)\n         LHI   R1,@F_VolTbl_Ent_Copy_Len Target length\n         MVCL  R0,R14                   Move message\n         PUTLINE MF=(E,@F_IOPL)         Write it\n         J     F00590                   and skip\n\nF00580   DS    0H\n*--------------------------------------------------------------------*\n*     ... or to SYSPRINT                                             *\n*--------------------------------------------------------------------*\n         LA    R15,@F_ErrMsgL           A(Error Msg)\n         ST    R15,@F_Parms_Y00010      Save it\n         LA    R15,L'@F_ErrMsgL         Length\n         ST    R15,@F_Parms_Y00010+4    Save it\n\n         LA    R1,@F_Parms              A(Parms)\n         BRAS  R14,Y00010               Go print it\n         J     F00590                   and exit with error\n\nF00590   DS    0H\n*--------------------------------------------------------------------*\n*     Set the return code, and exit                                  *\n*--------------------------------------------------------------------*\n         LA    R15,4                    OutFile processing failed\n         J     F00600                   and exit\n\nF00600   DS    0H\n*--------------------------------------------------------------------*\n*     All done processing the VolTbl Entries - exit                  *\n*--------------------------------------------------------------------*\n         J     F90010                   exit quick smart\n\n\nF80010   DS    0H\n*--------------------------------------------------------------------*\n*     Nothing to display                                             *\n*--------------------------------------------------------------------*\n         LA    R15,4                    Set return code\n         J     F90010                   and exit\n\nF90010   DS    0H\n*-------------------------------------------------------------------*\n*    Free up our local storage ...                                  *\n*-------------------------------------------------------------------*\n         LR    R3,R15                 Save return code\n\n         LA    R1,@F_Dynam              A(Local storage)\n         L     R2,@F_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         L     R13,4(0,R13)             Rescue A(HSA)\n\n         SSCSTACK POP,                  Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=(R2)                on this stack\n\n         LR    R15,R3                   Restore return code\n\n*-------------------------------------------------------------------*\n*    ... and return to caller                                       *\n*-------------------------------------------------------------------*\n         L     R14,12(0,R13)            Restore return address\n         LM    R0,R12,20(R13)           Restore other registers\n         BSM   0,R14                    and return\n\nF_Literals  DS  0H\n\nF_PLPB   PUTLINE OUTPUT=(0,TERM,SINGLE,DATA),                          +\n               TERMPUT=(EDIT,WAIT,NOHOLD,NOBREAK),                     +\n               MF=L\nF_PLPB_Length EQU *-F_PLPB\n\nF_LINKX  LINKX EP=ISPLINK,            ISPF services                    +\n               SF=L                    List form only\nF_LINKX_Length EQU   *-F_LINKX\n\nF_EMsg01 DC    C'&PGMNAME.01I No Devices/Volumes match selection criter+\n               ia'\nF_EMsg02 DC    C'&PGMNAME.02I Insufficient APF authorization'\nF_EMsg03 DC    C'&PGMNAME.03I ISPF DM Services unavailable xx-yy'\nF_EMsg03_RC    EQU F_EMsg03+L'F_EMsg03-5,2\nF_EMsg03_Reas  EQU F_EMsg03+L'F_EMsg03-2,2\nF_EMsg04 DC    C'&PGMNAME.04I Forcing non-ISPF output'\nF_EMsg05 DC    C'&PGMNAME.05I CSVQUERY unavailable on this system '\nF_EMsg06 DC    C'&PGMNAME.06I Program not found in STEPLIB/LNKLST'\nF_EMsg07 DC    C'&PGMNAME.07I IKJEFTSR Error xx-yy'\nF_EMsg07_RC    EQU   F_EMsg07+L'F_EMsg07-5,2\nF_EMsg07_Reas  EQU   F_EMsg07+L'F_EMsg07-2,2\nF_EMsg08 DC    C'&PGMNAME.08I LSPACE failed for at least 1 volume'\nF_EMsg09 DC    C'&PGMNAME.09I Incompatible version'\nF_EMsg10 DC    C'&PGMNAME.10I Insufficient storage:'\nF_EMsg11 DC    C'&PGMNAME.11I Internal Error - Unknown invocation type'\nF_EMsg12 DC    C'&PGMNAME.12I OutFile DDName'\n\nF_EX1    MVC   0(0,R15),0(R1)\n\nF_Hex_TrTab           EQU   *-240\n                      DC    C'0123456789ABCDEF'\n\n         LTORG\n\nF_Literals_End  DS  0H\n\n\n@F_Dynam                  DSECT        Dynamic area for F00000\n                          DS    18F     O/S Style save area\n@F_31Bit_Stack_Ptr_Ptr    DS    AL4     A(31-bit Stack Ptr)\n@F_24Bit_Stack_Ptr_Ptr    DS    AL4     A(24-bit Stack Ptr)\n@F_DBLWD                  DS    D       Work area\n\n@F_G00010_RC              DS    HL2     G00010 Return Code\n@F_G00010_Reas            DS    HL2     G00010 Reason Code\n\n@F_Parms                  DS    0F      Parms for called rtns\n@F_Parms_Std              DS    3AL4     Standard 3 parms\n@F_Parms_Extra            EQU   *        Extra parms\n@F_Parms_G00010           DS    2AL4        for G00010\n                          ORG   @F_Parms_Extra\n@F_Parms_I00010           DS    2AL4        for I00010\n                          ORG   @F_Parms_Extra\n@F_Parms_V00010           DS    AL4         for V00010\n                          ORG   @F_Parms_Extra\n@F_Parms_X00010           DS    2AL4        for X00010\n                          ORG   @F_Parms_Extra\n@F_Parms_Y00010           DS    2AL4        for Y00010\n                          ORG   @F_Parms_Extra\n@F_ISPF_Parms             DS    5AL4   ISPF Parm List\n@F_LINKX                  DS    CL(F_LINKX_Length)\n                          ORG   ,\n                          DS    0F      Alignment\n@F_IOPL                   DS    CL(IOPL_Length)  IOPL block\n                          DS    0F      Alignment\n@F_PLPB                   DS    CL(F_PLPB_Length) PUTLINE Parm Blk\n@F_IOECB                  DS    F       ECB for PUTLINE\n@F_OLD                    EQU   *       OLD for PUTLINE\n@F_OLDLN                  DS    HL2      Length\n@F_OLDOF                  DS    HL2      Offset\n@F_VolTbl_Ent_Copy        DS    2CL((VolTbl_Ent_Display_Len/2)+1)\n@F_VolTbl_Ent_Copy_Len    EQU   *-@F_VolTbl_Ent_Copy\n@F_ErrMsgS                DS    CL24\n@F_ErrMsgL                DS    CL(L'VolTbl_Ent_ErrMsg)\n                          DS    0D          Alignment\n@F_Dynam_Length           EQU   *-@F_Dynam  Length of storage\n\n&PGMNAME CSECT\n\n         DROP  ,\n         POP   USING\n         TITLE 'G00010: Output Results using ISPF'\n\n         PUSH  USING\n\nG00010   DS    0H\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Routine   : G00010                                                 *\n*                                                                     *\n*  Abstract  : Display results of LSPACE stuff via ISPF               *\n*                                                                     *\n*  Inputs    : R1 : ---> A(@_Dynam)                                   *\n*                        A(31-bit Stack Pointer)                      *\n*                        A(24-bit Stack Pointer)                      *\n*                        A(ISPF Short Message)                        *\n*                        A(ISPF Long Message)                         *\n*  Outputs   : R15: 00 - all OK                                       *\n*                   04 - ISPQRY Failed,       R0: RC from ISPQRY      *\n*                   08 - ISPLINK LOAD failed, R0: RC from LOAD        *\n*                                                                     *\n*  Notes     :                                                        *\n*                                                                     *\n*  History:    2000/05/23 SDDA030 - V2.12                             *\n*                                 - New, code was originally in       *\n*                                   F00010.                           *\n*                                 - Added MULT to TBADD.              *\n*                                 - If we are APF-auth turn off       *\n*                                   JSCBAUTH before trying to use DM, *\n*                                   and ATTACH a task to reset it     *\n*                                   when we are done.                 *\n*              2001/02/01 SDDA030 - V2.13                             *\n*                                 - Removed IOSCDR message pointer.   *\n*                                 - Removed JSCBAUTH stuff.           *\n*                                 - Added 'Incomplete' ISPF msg.      *\n*              2001/02/26 SDDA030 - V2.14                             *\n*                                 - Added BRIF/EDIF support.          *\n*                                 - Used BRIF if ISPF(S) wanted, but  *\n*                                   panel not available.              *\n*              2002/02/12 SDDA030 - V2.16                             *\n*                                 - Moved ISPF(S) code to K00010      *\n*              2003/10/07 SDDA030 - V2.21                             *\n*                                 - Added code to allow switching     *\n*                                   between display modes.            *\n*              2006/04/21 SDDA030 - V2.24                             *\n*                                 - Used standardised calling sequence*\n*              ____/__/__ _______                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         STM   R14,R12,12(R13)          Save callers registers\n         LARL  R11,G_Literals           Point to our literals\n         USING (G_Literals,G_Literals_End),R11 Tell the assembler\n\n         L     R12,0(0,R1)              A(@_Dynam)\n         USING @_Dynam,R12              Tell the assembler\n\n*-------------------------------------------------------------------*\n*    Get an area on the stack for our local storage                 *\n*-------------------------------------------------------------------*\n         L     R2,4(0,R1)               A(31-bit stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         SSCSTACK PUSH,                 Get stack area                 +\n               LEN=@G_Dynam_Length,      this long                     +\n               STACK=(R2)                using this stack\n\n         LR    R3,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LHI   R1,@G_Dynam_Length        Its length\n         LA    R14,0                    Clear source address\n         LA    R15,0                     and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R3                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*-------------------------------------------------------------------*\n         ST    R13,4(0,R1)              Chain\n         ST    R1,8(0,R13)               saveareas\n         LR    R13,R1                   Load dynam base\n         USING @G_Dynam,R13             Assign a base\n         L     R15,@G_Dynam+4           Get A(HSA)\n         LM    R0,R3,20(R15)            Restore callers registers\n\n         L     R15,4(0,R1)              A(31-bit Stack Pointer)\n         ST    R15,@G_31Bit_Stack_Ptr_Ptr Save it\n         L     R15,8(0,R1)              A(24-bit Stack Pointer)\n         ST    R15,@G_24Bit_Stack_Ptr_Ptr Save it\n\n*--------------------------------------------------------------------*\n*   Initialize our standard parmlist                                 *\n*--------------------------------------------------------------------*\n         LA    R15,@_Dynam              A(Dynamic area)\n         ST    R15,@G_Parms_Std         Save it\n         L     R15,@G_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)\n         ST    R15,@G_Parms_Std+4       Save it\n         L     R15,@G_24Bit_Stack_Ptr_Ptr A(24-bit Stack Pointer)\n         ST    R15,@G_Parms_Std+8       Save it\n\n*---------------------------------------------------------------------*\n*      If we can use ISPF, LOAD ISPLINK                               *\n*---------------------------------------------------------------------*\n         LA    R1,0                     Clear parm reg\n         LINK  EP=ISPQRY                Check ISPF services\n         LTR   R15,R15                  Are they available?\n         JNZ   G80010                   No, use line-by-line\nG00020   DS    0H\n         BASR  R2,0\n         USING (*,G00020_End-1),R2\n         LOAD  EP=ISPLINK               Get A(ISPF Interface)\nG00020_End DS  0H\n         DROP  R2\n         LTR   R15,R15                  Is it there?\n         JNZ   G80020                   No, skip\n         ST    R0,@_ISPLINK             Yes, save EPA\n\n*---------------------------------------------------------------------*\n*      ISPF seems to be available - save our display environment and  *\n*     ask ISPF to return errors to us.                                *\n*---------------------------------------------------------------------*\n         LA    R15,=CL8'CONTROL'        CONTROL\n         ST    R15,@G_ISPF_Parms\n         LA    R15,=CL8'DISPLAY'        DISPLAY\n         ST    R15,@G_ISPF_Parms+4\n         LA    R15,=CL8'SAVE'           SAVE\n         ST    R15,@G_ISPF_Parms+8\n         OI    @G_ISPF_Parms+8,X'80'    Flag end of list\n         LA    R1,@G_ISPF_Parms         A(Parmlist)\n         L     R15,@_ISPLINK            A(ISPF Interface)\n         BASR  R14,R15                  Go do it\n\n         LA    R15,=CL8'CONTROL'        CONTROL\n         ST    R15,@G_ISPF_Parms\n         LA    R15,=CL8'ERRORS'         ERRORS\n         ST    R15,@G_ISPF_Parms+4\n         LA    R15,=CL8'RETURN'         RETURN\n         ST    R15,@G_ISPF_Parms+8\n         OI    @G_ISPF_Parms+8,X'80'    Flag end of list\n         LA    R1,@G_ISPF_Parms         A(Parmlist)\n         L     R15,@_ISPLINK            A(ISPF Interface)\n         BASR  R14,R15                  Go do it\n\n*---------------------------------------------------------------------*\n*      Clear our flags                                                *\n*---------------------------------------------------------------------*\n         NI    @G_SETMSG_Issued,X'FF'-L'@G_SETMSG_Issued Clear flg\n\n*---------------------------------------------------------------------*\n*      If there is an error message, SETMSG it ...                    *\n*---------------------------------------------------------------------*\n         L     R15,@G_Dynam+4           A(HSA)\n         L     R15,24(0,R15)            Get original R1\n         ICM   R14,B'1111',12(R15)      A(Short Error message)\n         JZ    G00030                   Nothing, skip\n         CLI   0(R14),C' '              Message blank?\n         JE    G00030                   Yes, no message\n\n         LA    R15,=CL8'VDEFINE'        ISPF Function\n         ST    R15,@G_ISPF_Parms        Save it\n         LA    R15,=CL8'CHAR'           Character variables\n         ST    R15,@G_ISPF_Parms+12     Save it\n\n         LA    R15,=CL8'ZEDSMSG'        Variable name\n         ST    R15,@G_ISPF_Parms+4      Save it\n         ST    R14,@G_ISPF_Parms+8      Save A(short message)\n         LA    R15,=FL4'24'             Max len of SMSG\n         ST    R15,@G_ISPF_Parms+16     Save it\n         OI    @G_ISPF_Parms+16,X'80'   Flag end of list\n         LA    R1,@G_ISPF_Parms         A(Parmlist)\n         L     R15,@_ISPLINK            A(ISPF Interface)\n         BASR  R14,R15                  Go do it\n\n         LA    R15,=CL8'ZEDLMSG'        Variable name\n         ST    R15,@G_ISPF_Parms+4      Save it\n         L     R15,@G_Dynam+4           A(HSA)\n         L     R15,24(0,R15)            Get original R1\n         L     R15,16(0,R15)            A(Long message)\n         ST    R15,@G_ISPF_Parms+8      Save it\n         LA    R15,=AL4(L'VolTbl_Ent_ErrMsg) Length of Long Msg\n         ST    R15,@G_ISPF_Parms+16     Save it\n         OI    @G_ISPF_Parms+16,X'80'   Flag end of list\n         LA    R1,@G_ISPF_Parms         A(Parmlist)\n         L     R15,@_ISPLINK            A(ISPF Interface)\n         BASR  R14,R15                  Go do it\n\n         LA    R15,=CL8'SETMSG'         Yes, ISPF Function\n         ST    R15,@G_ISPF_Parms        Save it\n         LA    R15,=CL8'ISRZ001'        A(Message ID)\n         ST    R15,@G_ISPF_Parms+4      Save it\n         OI    @G_ISPF_Parms+4,X'80'    Mark end of list\n         LA    R1,@G_ISPF_Parms         Point to ISPF parms\n         L     R15,@_ISPLINK            A(Interface routine)\n         BASR  R14,R15                  Go do it\n\n         OI    @G_SETMSG_Issued,L'@G_SETMSG_Issued  We've done a SETMSG\n\nG00030   DS    0H\n*---------------------------------------------------------------------*\n*      If there is anything to do ...                                 *\n*---------------------------------------------------------------------*\n         SLR   R15,R15                  Clear return code\n         ICM   R1,B'1111',@_VolTbl_Ptr A(VolTbl)\n         JZ    G90010                   None, all done\n         ICM   R1,B'1111',VolTbl_Hdr_Vols_Total-VolTbl_Hdr(R1)\n         JZ    G90010                   None, all done\n\n*---------------------------------------------------------------------*\n*      If we will be invoking BRIF, put out the message indicating    *\n*     that the SORT command is available.                             *\n*---------------------------------------------------------------------*\n         TM    @_ISPF_BRIF,L'@_ISPF_BRIF Do we want BRIF?\n         JNO   G00060                   No, skip\n         TM    @G_SETMSG_Issued,L'@G_SETMSG_Issued Already a msg?\n         JO    G00060\n\n         LA    R15,=CL8'VDEFINE'        ISPF Function\n         ST    R15,@G_ISPF_Parms        Save it\n         LA    R15,=CL8'CHAR'           Character variables\n         ST    R15,@G_ISPF_Parms+12     Save it\n\n         LA    R15,=CL8'ZEDSMSG'        Variable name\n         ST    R15,@G_ISPF_Parms+4      Save it\n         LA    R15,G_Sort_SMsg          SORT Cmd available\n         ST    R15,@G_ISPF_Parms+8      Save it\n         LA    R15,=AL4(L'G_Sort_SMsg)  Length of message\n         ST    R15,@G_ISPF_Parms+16     Save it\n         OI    @G_ISPF_Parms+16,X'80'   Flag end of list\n         LA    R1,@G_ISPF_Parms         A(Parmlist)\n         L     R15,@_ISPLINK            A(ISPF Interface)\n         BASR  R14,R15                  Go do it\n\n         LA    R15,=CL8'ZEDLMSG'        Variable name\n         ST    R15,@G_ISPF_Parms+4      Save it\n         LA    R15,G_Sort_LMsg          Long message\n         ST    R15,@G_ISPF_Parms+8      Save it\n         LA    R15,=AL4(L'G_Sort_LMsg)  Length of message\n         ST    R15,@G_ISPF_Parms+16     Save it\n         OI    @G_ISPF_Parms+16,X'80'   Flag end of list\n         LA    R1,@G_ISPF_Parms         A(Parmlist)\n         L     R15,@_ISPLINK            A(ISPF Interface)\n         BASR  R14,R15                  Go do it\n\n         LA    R15,=CL8'SETMSG'         Yes, ISPF Function\n         ST    R15,@G_ISPF_Parms        Save it\n         LA    R15,=CL8'ISRZ000'        A(Message ID)\n         ST    R15,@G_ISPF_Parms+4      Save it\n         OI    @G_ISPF_Parms+4,X'80'    Mark end of list\n         LA    R1,@G_ISPF_Parms         Point to ISPF parms\n         L     R15,@_ISPLINK            A(Interface routine)\n         BASR  R14,R15                  Go do it\n\nG00060   DS    0H\n         TM    @_ISPF_BRIF,L'@_ISPF_BRIF Do we want BRIF?\n         JO    G00070                   Yes, skip\n         TM    @_ISPF_EDIF,L'@_ISPF_EDIF No, how about EDIF?\n         JO    G00070                   Yes, skip\n\n*---------------------------------------------------------------------*\n*      Invoke our standard ISPF SPACE display; if it fails, we will   *\n*     force BRIF.                                                     *\n*---------------------------------------------------------------------*\n         LA    R1,@G_Parms              A(Parms)\n         BRAS  R14,K00010               Go display ISPF(S)\n         TM    @_ReDisplay,L'@_ReDisplay Do it again?\n         JO    G00080                   Yes, exit quick smart\n         LTR   R15,R15                  No, how did it go?\n         JZ    G00080                   OK, skip\n\n*---------------------------------------------------------------------*\n*      We will use BRIF - set our flag, and let the user know         *\n*---------------------------------------------------------------------*\n         OI    @_ISPF_BRIF,L'@_ISPF_BRIF No, force BRIF\n         NI    @_ISPF_SPACE,X'FF'-L'@_ISPF_SPACE\n\n         TM    @G_SETMSG_Issued,L'@G_SETMSG_Issued  Already SETMSG'd?\n         JO    G00070                   Yes, don't clobber it\n\n         LA    R15,=CL8'VDEFINE'        ISPF Function\n         ST    R15,@G_ISPF_Parms        Save it\n         LA    R15,=CL8'CHAR'           Character variables\n         ST    R15,@G_ISPF_Parms+12     Save it\n\n         LA    R15,=CL8'ZEDSMSG'        Variable name\n         ST    R15,@G_ISPF_Parms+4      Save it\n         LA    R15,G_BRIF_SMsg          A(Short Message)\n         ST    R15,@G_ISPF_Parms+8      Save it\n         LA    R15,=AL4(L'G_BRIF_SMsg)  Length of variable\n         ST    R15,@G_ISPF_Parms+16     Save it\n         OI    @G_ISPF_Parms+16,X'80'   Flag end of list\n         LA    R1,@G_ISPF_Parms         A(Parmlist)\n         L     R15,@_ISPLINK            A(ISPF Interface)\n         BASR  R14,R15                  Go do it\n\n         LA    R15,=CL8'ZEDLMSG'        Variable name\n         ST    R15,@G_ISPF_Parms+4      Save it\n         LA    R15,G_BRIF_LMsg          A(Long message)\n         ST    R15,@G_ISPF_Parms+8      Save it\n         LA    R15,=AL4(L'G_BRIF_LMsg)  Length of message\n         ST    R15,@G_ISPF_Parms+16     Save it\n         OI    @G_ISPF_Parms+16,X'80'   Flag end of list\n         LA    R1,@G_ISPF_Parms         A(Parmlist)\n         L     R15,@_ISPLINK            A(ISPF Interface)\n         BASR  R14,R15                  Go do it\n\n         LA    R15,=CL8'SETMSG'         Yes, ISPF Function\n         ST    R15,@G_ISPF_Parms        Save it\n         LA    R15,=CL8'ISRZ001'        A(Message ID)\n         ST    R15,@G_ISPF_Parms+4      Save it\n         OI    @G_ISPF_Parms+4,X'80'    Mark end of list\n         LA    R1,@G_ISPF_Parms         Point to ISPF parms\n         L     R15,@_ISPLINK            A(Interface routine)\n         BASR  R14,R15                  Go do it\n\n         OI    @G_SETMSG_Issued,L'@G_SETMSG_Issued  We've done a SETMSG\n\n         J     G00070                   and go do it\n\nG00070   DS    0H\n         LA    R1,@G_Parms              A(Parms)\n         BRAS  R14,J00010               Go EDIF/BRIF\n\n         LA    R15,0                    Clear return code\n         LA    R0,0                     and reason code\n         J     G90010\n\nG00080   DS    0H\n*--------------------------------------------------------------------*\n*     END or RETURN from DISPLAY: Clear return codes and exit.       *\n*--------------------------------------------------------------------*\n         LA    R0,0                     Clear reason code\n         LA    R15,0                     and return code\n         J     G90010                   exit\n\n\nG80010   DS    0H\n*-------------------------------------------------------------------*\n*    Error - ISPQRY failed                                          *\n*-------------------------------------------------------------------*\n         LR    R0,R15                 Set reason code (RC from ISPQRY)\n         LA    R15,4                  Set return code\n         J     G90010                 and exit\n\nG80020   DS    0H\n*-------------------------------------------------------------------*\n*    Error - LOAD for ISPLINK failed                                *\n*-------------------------------------------------------------------*\n         LR    R0,R15                 Set reason code (RC from LOAD)\n         LA    R15,8                  Set return code\n         J     G90010                 and exit\n\n\nG90010   DS    0H\n*---------------------------------------------------------------------*\n*   Clean up and return to caller                                     *\n*---------------------------------------------------------------------*\n         LR    R3,R15                 Save return code\n         LR    R4,R0                   and reason code\n\n*---------------------------------------------------------------------*\n*   If we successfully LOADed ISPLINK ...                             *\n*---------------------------------------------------------------------*\n         ICM   R1,B'1111',@_ISPLINK     Get A(ISPF Interface)\n         JZ    G90030                   None, skip\n\n*---------------------------------------------------------------------*\n*   ... VDELETE any ISPF variables we created ...                     *\n*---------------------------------------------------------------------*\n         LA    R15,=CL8'VDELETE'        Yes, A(ISPF Function)\n         ST    R15,@G_ISPF_Parms        Save it\n         LA    R15,=CL8'*'              A(Variable names)\n         ST    R15,@G_ISPF_Parms+4      Save it\n         OI    @G_ISPF_Parms+4,X'80'    Flag end of list\n         LA    R1,@G_ISPF_Parms         Point to ISPF parms\n         L     R15,@_ISPLINK            A(ISPF Interface)\n         BASR  R14,R15                  Go do it\n\n*---------------------------------------------------------------------*\n*   ... restore the ISPF Display environment ...                      *\n*---------------------------------------------------------------------*\n         LA    R15,=CL8'CONTROL'        ISPF Function\n         ST    R15,@G_ISPF_Parms        Save it\n         LA    R15,=CL8'DISPLAY'        Character variables\n         ST    R15,@G_ISPF_Parms+4      Save it\n         LA    R15,=CL8'RESTORE'        Character variables\n         ST    R15,@G_ISPF_Parms+8      Save it\n         OI    @G_ISPF_Parms+8,X'80'    Flag end of list\n         LA    R1,@G_ISPF_Parms         A(Parmlist)\n         L     R15,@_ISPLINK            A(ISPF Interface)\n         BASR  R14,R15                  Go do it\n\n*---------------------------------------------------------------------*\n*   ... and DELETE ISPLINK                                            *\n*---------------------------------------------------------------------*\n         DELETE EP=ISPLINK              Delete it\n         LA    R15,0                    and clear\n         ST    R15,@_ISPLINK             the pointer\n\nG90030   DS    0H\n*-------------------------------------------------------------------*\n*    Free up our local storage ...                                  *\n*-------------------------------------------------------------------*\n         LA    R1,@G_Dynam              A(Local storage)\n         L     R2,@G_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         L     R13,4(0,R13)             Rescue A(HSA)\n\n         SSCSTACK POP,                  Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=(R2)                on this stack\n\n*-------------------------------------------------------------------*\n*    ... and return to caller                                       *\n*-------------------------------------------------------------------*\n         LR    R15,R3                   Restore return code\n         LR    R0,R4                    Restore reason code\n         L     R14,12(0,R13)            Restore return address\n         LM    R1,R12,24(R13)           Restore other registers\n         BSM   0,R14                    and return\n\nG_Literals  DS   0H\n\nG_Sort_SMsg DC C'SORT Cmd avail'\nG_Sort_LMsg DC C'''SORT'' can be used to sort the table'\n\nG_BRIF_SMsg DC C'BRIF substituted'\nG_BRIF_LMsg DC C'Panel &PNLNAME not found'\n\n         LTORG\n\nG_Literals_End  DS   0H\n\n\n@G_Dynam                  DSECT        Dynamic area for G00000\n                          DS    18F     O/S Style save area\n@G_31Bit_Stack_Ptr_Ptr    DS    AL4     A(31-bit Stack Ptr)\n@G_24Bit_Stack_Ptr_Ptr    DS    AL4     A(24-bit Stack Ptr)\n@G_DBLWD                  DS    D       Work area\n@G_ISPF_Parms             DS    10FL4   ISPF Parm list\n                          DS    X       Flag Byte\n@G_SETMSG_Issued          EQU   *-1,X'80' 1... .... SETMSG issued\n\n@G_Parms                  DS    0F      Parms for called rtns\n@G_Parms_Std              DS    3AL4     Standard 3 parms\n@G_Parms_Extra            EQU   *        Extra parms\n                          ORG   ,\n                          DS    0D      Alignment\n@G_Dynam_Length           EQU   *-@G_Dynam Length of storage\n\n&PGMNAME CSECT\n\n         DROP  ,\n         POP   USING\n\n         TITLE 'H00010: Issue LSPACE for device'\n\n         PUSH  USING\n\nH00010   DS    0H\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Routine   : H00010                                                 *\n*                                                                     *\n*  Abstract  : Issue LSPACE and save selected F4 DSCB data            *\n*                                                                     *\n*  Inputs    : R1 : ---> A(@_Dynam)                                   *\n*                        A(31-bit Stack Pointer)                      *\n*                        A(24-bit Stack Pointer)                      *\n*                        A(Volume Table)                              *\n*  Outputs   : VolTbl updated                                         *\n*                                                                     *\n*  Operation : Initialize                                             *\n*                Do while unprocessed entries in Volume Table         *\n*                  Flag entry as processed                            *\n*                  Issue STIMER                                       *\n*                  Issue LSPACE for device described by VolTbl_Ent    *\n*                  Cancel STIMER                                      *\n*                  Format detail line                                 *\n*                  Update Totals                                      *\n*                  If last volume,                                    *\n*                    Format Totals line, if present                   *\n*                  EndIf                                              *\n*                EndDo                                                *\n*              Update Stats Line, if present                          *\n*              Terminate                                              *\n*                                                                     *\n*  History   : 1997/05/16 SDDA030 - New                               *\n*              1998/09/17 SDDA030 - V2.0                              *\n*                                 - Used Compare-and-Swap in pseudo-  *\n*                                   POST processing, rather than      *\n*                                   blindly ORing POST bit if no WAIT *\n*                                   was present.                      *\n*              1998/09/22 SDDA030 - V2.1                              *\n*                                 - Added ESTAE to trap ABENDs and    *\n*                                   POST SPACE with a code of 8.      *\n*                                 - Moved STIMERM from D00010 to this *\n*                                   routine.                          *\n*              1998/11/13 SDDA030 - V2.2                              *\n*                                 - This routine now goes through the *\n*                                   Volume Table, rather than WAITing *\n*                                   for SPACE to POST it with the     *\n*                                   address of an entry to process.   *\n*                                   ESTAE merely restarts the search  *\n*                                   through the table, rather than    *\n*                                   POSTing the ECB (there seems to be*\n*                                   no point in re-ATTACHing after an *\n*                                   ESTAE).                           *\n*              1999/09/01 SDDA030 - V2.9                              *\n*                                 - Do not use CDS instruction to up- *\n*                                   date totals fields, as they are   *\n*                                   now in the subtask area.          *\n*              2000/01/19 SDDA030 - V2.11                             *\n*                                 - Used areas within the VolTbl      *\n*                                   entry to hold control blocks from *\n*                                   LSPACE.                           *\n*                                 - Removed SMS anomaly check (now    *\n*                                   in E00010).                       *\n*              2000/05/23 SDDA030 - V2.12                             *\n*                                 - Removed STIMERM-related stuff     *\n*                                   Added IOSCDR to check if we can   *\n*                                   get out to the DASD device before *\n*                                   issuing LSPACE.                   *\n*              2001/02/01 SDDA030 - V2.13                             *\n*                                 - Undid stuff from V2.12            *\n*                                 - Replaced POST with ESTAE and      *\n*                                   ABEND in STIMERM exit (H06000).   *\n*                                 - Mimimum STIMERM WAIT time = 1 sec.*\n*                                 - Used micro-secs and MICVL instead *\n*                                   of Timer Units.                   *\n*              2001/02/26 SDDA030 - V2.14                             *\n*                                 - Removed detail and total line     *\n*                                   formatting.                       *\n*                                 - Used work area passed by E00010   *\n*                                   rather than GETMAIN.              *\n*              2001/11/12 SDDA030 - V2.15                             *\n*                                 - Corrected bug in calculating      *\n*                                   STIMERM times - all our times are *\n*                                   now maintained in usec.           *\n*                                 - Used STIMERM Wait time factor in  *\n*                                   calculating wait time.            *\n*              2002/03/11 SDDA030 - V2.17                             *\n*                                 - Generated LSPACE error messages   *\n*                                   internally, instead of asking     *\n*                                   LSPACE to do it.                  *\n*              2002/06/11 SDDA030 - V2.18                             *\n*                                 - Formatted detail and total lines  *\n*                                   in this routine.                  *\n*                                 - Filled in SubTask Statistics Line.*\n*              2006/04/21 SDDA030 - V2.24                             *\n*                                 - Rounded numbers in the display    *\n*                                   area where appropriate.           *\n*                                 - Used TRKCALC to get track size,   *\n*                                   rather than use DS4DEVTK. For     *\n*                                   example, for 3390s:               *\n*                                     DS4DEVTK = 58786                *\n*                                     TRKCALC  = 56664                *\n*                                 - Used standardized calling sequence*\n*                                 - Saved callers registers on the    *\n*                                   Linkage Stack                     *\n*                                 - Used STIMERM around LSPACE if     *\n*                                   MaxLWait specified                *\n*                                                                     *\n*  Notes     : This routine differs from the others in this program   *\n*              in that it is ATTACHed.                                *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n\n*---------------------------------------------------------------------*\n*     Save caller's registers, get dynamic storage, etc. etc.         *\n*---------------------------------------------------------------------*\n         BAKR  R14,0                    Save callers registers\n         LARL  R11,H_Literals           Point to our literals\n         USING (H_Literals,H_Literals_End),R11 Tell the assembler\n\n         L     R12,0(0,R1)              A(@_Dynam)\n         USING @_Dynam,R12              Tell the assembler\n\n*-------------------------------------------------------------------*\n*    Get some storage for our LIFO stack ...                        *\n*-------------------------------------------------------------------*\n         LHI   R0,@_31Bit_Stack_Length  Length of storage we need\n         SSCSTACK INIT,                 Go get our storage             +\n               LEN=(R0),                 this long                     +\n               LOC=31                    above-the-line\n\n         LR    R4,R1                    Save its address\n\n*-------------------------------------------------------------------*\n*    ... and get an area on it for our local storage                *\n*-------------------------------------------------------------------*\n         SSCSTACK PUSH,                 Get Stack area                 +\n               LEN=@H_Dynam_Length,      this long                     +\n               STACK=(R4)                 using this stack\n\n         LR    R3,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LHI   R1,@H_Dynam_Length        Its length\n         LA    R14,0                    Clear source address\n         LA    R15,0                     and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R3                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*-------------------------------------------------------------------*\n         LR    R13,R1                   Load dynam base\n         USING @H_Dynam,R13             Assign a base\n         MVC   4(4,R13),=C'F1SA'        Init save area\n         ST    R4,@H_31Bit_Stack_Ptr    Save A(Stack)\n\n         EREG  R0,R4                    Restore callers registers\n\n*---------------------------------------------------------------------*\n*     Save our parm addresses ...                                     *\n*---------------------------------------------------------------------*\n         ICM   R15,B'1111',12(R1)       A(Volume Table)\n         JZ    H90010                   Nothing, all done\n         ST    R15,@H_VolTbl_Ptr        Save it\n         LA    R14,VolTbl_Hdr_LSPACE_Avg-VolTbl_Hdr(R15)\n         ST    R14,@H_LSPACE_Avg_Ptr    Save it\n         LA    R14,VolTbl_Hdr_STIMERM_Adj-VolTbl_Hdr(R15)\n         ST    R14,@H_STIMERM_Adj_Ptr   Save it\n\n*---------------------------------------------------------------------*\n*     ... set up the addresses of the lines we need ...               *\n*---------------------------------------------------------------------*\n         L     R15,@H_VolTbl_Ptr        A(VolTbl)\n         ICM   R0,B'1111',VolTbl_Hdr_Total_Off-VolTbl_Hdr(R15) Totals\n         JZ    H00020                   None, skip\n         AR    R0,R15                   Convert offset to address\n         ST    R0,@H_Totals_Line_Ptr    Save it\nH00020   DS    0H\n         ICM   R0,B'1111',VolTbl_Hdr_SMS_Off-VolTbl_Hdr(R15) SMS msg\n         JZ    H00030                   None, skip\n         AR    R0,R15                   Convert offset to address\n         ST    R0,@H_SMS_Anomaly_Ptr    Save it\nH00030   DS    0H\n         ICM   R0,B'1111',VolTbl_Hdr_SubT_Off-VolTbl_Hdr(R15) SubTask\n         JZ    H00040                   None, skip\n         AR    R0,R15                   Convert offset to address\n         ST    R0,@H_Stats_Line_Ptr     Save it\n\nH00040   DS    0H\n*---------------------------------------------------------------------*\n*     ... and set our flag, indicating the presence of OW48527, and   *\n*     the maximum LSPACE Wait time                                    *\n*---------------------------------------------------------------------*\n        L     R15,@H_VolTbl_Ptr         A(VolTbl)\n        TM    VolTbl_Hdr_OW48527-VolTbl_Hdr(R15),L'VolTbl_Hdr_OW48527\n        JNO   H00040C                   Not installed, skip\n        OI    @H_OW48527,L'@H_OW48527   OK, set our flag\nH00040C DS    0H\n        MVC   @H_MaxLWait,VolTbl_Hdr_MaxLWait-VolTbl_Hdr(R15)\n\n*--------------------------------------------------------------------*\n*   Initialize our standard parmlist                                 *\n*--------------------------------------------------------------------*\n         LA    R15,@_Dynam              A(Dynamic area)\n         ST    R15,@H_Parms_Std         Save it\n         LA    R15,@H_31Bit_Stack_Ptr   A(31-bit Stack Pointer)\n         ST    R15,@H_Parms_Std+4       Save it\n         LA    R15,@H_24Bit_Stack_Ptr   A(24-bit Stack Pointer)\n         ST    R15,@H_Parms_Std+8       Save it\n\n*---------------------------------------------------------------------*\n*     Set up our ESTAE parms                                          *\n*---------------------------------------------------------------------*\n         MVC   @H_ESTAE_RMask,=X'FFFF'  Restore all registers\n\n*---------------------------------------------------------------------*\n*     Find an unprocessed entry in the Volume Table                   *\n*---------------------------------------------------------------------*\n         ICM   R9,B'1111',@H_VolTbl_Ptr Point to the Volume Table\n         JZ    H90010                   None, exit\n         ICM   R10,B'1111',VolTbl_Hdr_Count-VolTbl_Hdr(R9) Nbr entries\n         JZ    H90010                   None, exit\n         AHI   R9,VolTbl_Ent-VolTbl     Yes, point to the first\n\n         USING VolTbl_Ent,R9            Assign a base\n\nH00050   DS    0H\n*---------------------------------------------------------------------*\n*     Establish an ESTAE, if required                                 *\n*---------------------------------------------------------------------*\n         STM   R0,R15,@H_ESTAE_Regs     Save our registers for retry\n         MVC   @H_ESTAE_Retry,=AL4(H00380) Set retry address\n\n         TM    @H_ESTAE_Issued,L'@H_ESTAE_Issued Do we have an ESTAE?\n         JO    H00060                   Yes, skip\n\n         MVC   @H_ESTAE,H_ESTAE         Move L-Form\n         L     R3,=AL4(H07000)          A(Exit\n         ESTAEX (3),                    Establish ESTAE Exit           +\n               CT,                       create it                     +\n               PARAM=@H_Dynam,           passing this parm             +\n               MF=(E,@H_ESTAE)           keeping ourselves reentrant\n         LTR   R15,R15                  Did it work?\n         JNZ   H00060                   No, skip\n         OI    @H_ESTAE_Issued,L'@H_ESTAE_Issued Yes, set our flag\n\nH00060   DS    0H\n*---------------------------------------------------------------------*\n*     If this entry has not been processed ...                        *\n*---------------------------------------------------------------------*\n         XC    @H_Current_VolTbl_Ent,@H_Current_VolTbl_Ent\n\n         TM    VolTbl_Ent_Detail_Line,L'VolTbl_Ent_Detail_Line\n         JNO   H00410                   No, skip this entry\n         TM    VolTbl_Ent_SMS_Line,L'VolTbl_Ent_SMS_Line SMS Anomaly?\n         JO    H00410                   Yes, dont use it\n         XC    @H_Current_VolTbl_Ent,@H_Current_VolTbl_Ent\n\n         TM    VolTbl_Ent_Processed,L'VolTbl_Ent_Processed\n         JNZ   H00410                   Yes, try next\n\n*---------------------------------------------------------------------*\n*     ... Compare-and-Swap the flag byte, ...                         *\n*---------------------------------------------------------------------*\n         L     R1,VolTbl_Ent_Processed  No, get the Flag byte\n         LA    R0,L'VolTbl_Ent_Processed Set up the\n         SLL   R0,24                     flag turned\n         OR    R0,R1                     on\n         CS    R1,R0,VolTbl_Ent_Processed and update it\n         JNZ   H00410                   Somebody else here, skip\n\n*---------------------------------------------------------------------*\n*     ... bump our counters ...                                       *\n*---------------------------------------------------------------------*\n         L     R14,@H_Total_Vols_Proc   Get nbr vols we processed\n         AHI   R14,1                    Bump it\n         ST    R14,@H_Total_Vols_Proc   and save it\n\n*---------------------------------------------------------------------*\n*     Calculate the time we will WAIT for LSPACE to complete, if      *\n*     MaxLWait has not been specified.                                *\n*     We arbitrarily wait for (8 * Avg of all previously completed    *\n*    LSPACEs * Adjustment Factor), rounded up to the next second.     *\n*                                                                     *\n*     If we are running with OW48527, this time is passed to LSPACE;  *\n*    otherwise, we set up a STIMERM to pop after this time.           *\n*---------------------------------------------------------------------*\n         LH    R15,@H_MaxLWait          Get MaxLWait\n         CHI   R15,0                    Was it specified?\n         JNE   H00080                   Yes, use it\n         L     R15,@H_LSPACE_Avg_Ptr    A(Avg Wait for LSPACE in usec)\n         ICM   R15,B'1111',0(R15)       Get it\n         JNZ   H00070                   Something there, skip\n         L     R15,=FL4'250000'         Nothing, default to .25 sec\nH00070   DS    0H\n         LA    R14,0                    Clear R14\n         SLDL  R14,3                    Multiply by 8\n         L     R1,@H_STIMERM_Adj_Ptr    A(Adjustment factor)\n         M     R14,0(0,R1)              Adjust it\n         D     R14,=FL4'1000000'        Convert to seconds\n         AHI   R15,1                    Bump it\n         CHI   R15,5                    More than 5 seconds?\n         JNH   H00080                   No, OK\n         LHI   R15,5                    Yes, max of 5 secs\nH00080   DS    0H\n         ST    R15,@H_LSPACE_Wait_Max   Save it\n\n*---------------------------------------------------------------------*\n*   If we are running without APAR OW48527, or MaxLWait was specified,*\n*   update our ESTAE Retry routine address and registers ...          *\n*---------------------------------------------------------------------*\n         TM    @H_OW48527,L'@H_OW48527  Is the APAR on\n         JNO   H00090                   No, skip\n         LH    R0,@H_MaxLWait           Get MaxLWait\n         CHI   R0,0                     Was it specified?\n         JE    H00100                   No, skip\n\nH00090   DS    0H\n         ST    R9,@H_Current_VolTbl_Ent Save A(VolTbl_Ent) for ESTAE\n         STM   R0,R15,@H_ESTAE_Regs     Save our registers for retry\n         MVC   @H_ESTAE_Retry,=AL4(H00120) Set retry address\n\n*---------------------------------------------------------------------*\n*     ... and establish a timer, so we don't wait forever for LSPACE  *\n*---------------------------------------------------------------------*\n         LA    R15,@H_Dynam             A(Dynamic storage)\n         ST    R15,@H_STIMERM_Exit_Parms Save it for the exit routine\n         LA    R15,@H_STIMERM_Exit_Parms Point to parm area\n         ST    R15,@H_STIMERM_Exit_Parms_Ptr  Save the address\n         LA    R3,@H_STIMERM_Exit_Parms_Ptr Point to parm area addr\n         L     R4,=AL4(H06000)          A(Exit)\n\n         L     R15,@H_LSPACE_Wait_Max   Get nbr secs to wait\n         MHI   R15,100                  in BINTVL\n         ST    R15,@H_DBLWD             Save it\n\n         MVC   @H_STIMERM_Set,H_STIMERM_Set Move L-Form of macro\n         STIMERM SET,                   Set a timer                    +\n               ID=@H_STIMERM_ID,         save the ID here              +\n               BINTVL=@H_DBLWD,          for this long                 +\n               EXIT=(4),                 invoke this when we pop       +\n               PARM=(3),                 with this parm                +\n               WAIT=NO,                  Dont wait                     +\n               MF=(E,@H_STIMERM_Set)     keep ourselves reentrant\n\nH00100   DS    0H\n*---------------------------------------------------------------------*\n*     Set up our areas that will be used by LSPACE                    *\n*---------------------------------------------------------------------*\n         XC    VolTbl_Ent_LSPACE_Data,VolTbl_Ent_LSPACE_Data\n         XC    VolTbl_Ent_DSCB,VolTbl_Ent_DSCB Clear DSCB area\n         NI    VolTbl_Ent_LSPACE_Fail,X'FF'-L'VolTbl_Ent_LSPACE_Fail\n\n*---------------------------------------------------------------------*\n*     Save the current TOD (ie, when LSPACE started)                  *\n*---------------------------------------------------------------------*\n         MVC   @H_TIME,H_TIME           MOVE Time macro\n         TIME  STCK,                    Get the current time           +\n               @H_LSPACE_Start,          return it here                +\n               LINKAGE=SYSTEM,           as recommended by IBM         +\n               MF=(E,@H_TIME)            staying re-entrant\n\n*---------------------------------------------------------------------*\n*     Set up the LSPACE parms, including LSPAXTIM if we are both      *\n*    assembling and running on systems with OW48527                   *\n*---------------------------------------------------------------------*\n         MVC   @H_LSPACE,H_LSPACE       Move LSPACE parms\n         AIF   (NOT D'LSPAXTIM).OW48527_200\n         TM    @H_OW48527,L'@H_OW48527  Are we running with OW48527?\n         JNO   H00110                   No, skip\n         L     R15,@H_LSPACE_Wait_Max   Get Wait Time\n         ICM   R0,B'1111',@H_STIMERM_ID Did we set up a STIMER?\n         JNZ   H00110                   Yes, use LSPACE default\n         STC   R15,@H_LSPACE+LSPAXTIM-LSPACE_Parm Update wait limit\nH00110   DS    0H\n.OW48527_200 ANOP\n\n*---------------------------------------------------------------------*\n*     Get the volume info using LSPACE                                *\n*---------------------------------------------------------------------*\n         LA     R3,VolTbl_Ent_UCBCopy   A(Our UCB)\n         LSPACE UCB=(3),                Get free space                 +\n               DATA=VolTbl_Ent_LSPACE_Data, save return info here      +\n               F4DSCB=VolTbl_Ent_DSCB,   Return F4 DSCB too            +\n               MF=(E,@H_LSPACE)          Parm area here\n\nH00120   DS    0H\n*---------------------------------------------------------------------*\n*     Cancel our STIMERM, if there is one ...                         *\n*---------------------------------------------------------------------*\n         ICM   R15,B'1111',@H_STIMERM_ID  Did we establish a timer?\n         JZ    H00130                   No, skip\n\n         MVC   @H_STIMERM_Can,H_STIMERM_Cancel Move L-Form macro\n         STIMERM CANCEL,                Cancel our timer               +\n               ID=@H_STIMERM_ID,         with this Id                  +\n               MF=(E,@H_STIMERM_Can)     keep ourselves reentrant\n         XC    @H_STIMERM_ID,@H_STIMERM_ID Clear STIMERM ID\n\n*---------------------------------------------------------------------*\n*     ... and update our ESTAE retry routine pointer, now that LSPACE *\n*    is done                                                          *\n*---------------------------------------------------------------------*\n         STM   R0,R15,@H_ESTAE_Regs     Save our registers for retry\n         MVC   @H_ESTAE_Retry,=AL4(H00380) Set retry address\n\nH00130   DS    0H\n*---------------------------------------------------------------------*\n*     Save the current TOD, and calculate the amount of time we have  *\n*    been waiting for LSPACE ...                                      *\n*---------------------------------------------------------------------*\n         MVC   @H_TIME,H_TIME           MOVE Time macro\n         TIME  STCK,                    Get the current time           +\n               @H_TIME_Area,             return it here                +\n               LINKAGE=SYSTEM,           as recommended by IBM         +\n               MF=(E,@H_TIME)            staying re-entrant\n\n         LM    R14,R15,@H_Time_Area     Get current time\n         SL    R15,@H_LSPACE_Start+4    Calculate\n         JNM   H00140                   No borrow, skip\n         SL    R14,=FL4'1'              Borrow, reduce\nH00140   DS    0H\n         SL    R14,@H_LSPACE_Start      Calculate WAIT time\n         SRDL  R14,12                   in usec\n         STM   R14,R15,@H_LSPACE_Wait   Save it\n\n*---------------------------------------------------------------------*\n*     ... and add it to the appropriate total (Successful or          *\n*    Unsuccessful LSPACE WAIT time)                                   *\n*---------------------------------------------------------------------*\n         LA    R3,@H_Total_LSPACE_Wait_OK     Assume all worked\n         CLI   @H_LSPACE+LSPAERCD-LSPACE_Parm,X'00' Did LSPACE Work?\n         JE    H00150                   Yes, skip\n         LA    R3,@H_Total_LSPACE_Wait_Bad  No, A(unsuccess total)\n\nH00150   DS    0H\n         LM    R0,R1,0(R3)              Get total (in usec)\n         ALR   R1,R15                   Add the wait time\n         BRC   12,H00160                No carry, skip\n         AL    R0,=FL4'1'               Carry, bump\nH00160   DS    0H\n         ALR   R0,R14                   Bump Wait totals\n         STM   R0,R1,0(R3)              Save Wait Time totals\n\n*---------------------------------------------------------------------*\n*     If LSPACE failed ...                                            *\n*---------------------------------------------------------------------*\n         CLI   @H_LSPACE+LSPAERCD-LSPACE_Parm,X'00' Did LSPACE Work?\n         JE    H00220                   Yes, skip\n\n*---------------------------------------------------------------------*\n*     ... flag the VolTbl_Ent, and generate an appropriate message (we*\n*    generate our own messages, because we would have to re-invoke    *\n*    LSPACE to get LSPACE to do it, and the conditions that caused it *\n*    to fail initially may have changed or disappeared by the time we *\n*    issue LSPACE again) ...                                          *\n*---------------------------------------------------------------------*\n         OI    VolTbl_Ent_LSPACE_Fail,L'VolTbl_Ent_LSPACE_Fail\n         CLC   =X'14850000',@H_LSPACE+LSPAERCD-LSPACE_Parm ESTAE?\n         JNE   H00170                   No, skip\n         TM    VolTbl_Ent_U522,L'VolTbl_Ent_U522 Because of us?\n         JNO   H00170                   No, skip\n         MVC   VolTbl_Ent_ErrMsg(L'H_MsgU522A),H_MsgU522A Say so\n         LH    R0,@H_MaxLWait           Get MaxLWait\n         CVD   R0,@H_DBLWD              Pack it\n         MVC   @H_DBLWD(4),=X'40202120' Move mask\n         LA    R1,@H_DBLWD+3            Set up start marker\n         EDMK  @H_DBLWD(4),@H_DBLWD+6   Edit it\n         LA    R14,@H_DBLWD+3           Last possible character\n         SR    R14,R1                   Length of result\n         LR    R15,R1                   A(Source)\n         AHI   R15,-3                   Adjust it\n         LA    R1,VolTbl_Ent_ErrMsg+L'H_MsgU522A A(Target)\n         EX    R14,H_MVC                Move MaxLWait\n         LA    R1,1(R1,R14)             Point last it\n         MVC   0(L'H_MsgU522B,R1),H_MsgU522B Move remainder\n         J     H00210                   and skip\nH00170   DS    0H\n         L     R15,=AL4(H_LSPACE_Msgs)  A(Message Table)\n         LA    R14,0                    Clear work register\nH00180   DS    0H\n         CLC   0(1,R15),@H_LSPACE+LSPAERCD-LSPACE_Parm  Our RC?\n         JNE   H00190                   No, skip\n         CLI   1(R15),X'00'             Yes, should we check SubFunc?\n         JE    H00200                   No, use this message\n         CLC   1(1,R15),@H_LSPACE+LSPASFID-LSPACE_Parm  Yes, our SF?\n         JE    H00200                   Yes, skip\nH00190   DS    0H\n         CLC   0(2,R15),=X'0000'        No, last entry?\n         JE    H00200                   Yes, we'd better use it\n         IC    R14,2(0,R15)             No, get len of message\n         LA    R15,3(R14,R15)           Point to next entry\n         J     H00180                   and check it out\n\nH00200   DS    0H\n         IC    R14,2(0,R15)             Length of the message\n         AHI   R14,-1                   EX Len\n         LA    R1,VolTbl_Ent_ErrMsg     A(Target)\n         EX    R14,H_MVC                Move the message\n         LA    R14,1(R1,R14)            Point past it\n         MVC   0(29,R14),=C', DADSM/CVAF Diagnostic Info:'\n         MVO   @H_DBLWD(5),@H_LSPACE+LSPAERCD-LSPACE_Parm(4)\n         OI    @H_DBLWD+4,X'0F'         'Pack' it\n         UNPK  29(9,R14),@H_DBLWD(5)    Unpack it\n         MVI   29(R14),C' '             Move separator\n         LA    R15,H_TrTbl              Point to translate table\n         AHI   R15,-240                 Adjust pointer\n         TR    30(8,R14),0(R15)         Make it readable\nH00210   DS    0H\n         J     H00380                   Go process next volume\n\nH00220   DS    0H\n*---------------------------------------------------------------------*\n*     LSPACE worked, so re-calculate the average time used by LSPACE  *\n*---------------------------------------------------------------------*\n         L     R3,@H_LSPACE_Avg_Ptr     A(Timer area)\nH00230   DS    0H\n         LM    R0,R1,0(R3)              Get Avg ms, nbr LSPACEs done\n         LR    R15,R0                   Get Avg micro-secs\n         MR    R14,R1                   Calculate total micro-secs\n         AL    R15,@H_LSPACE_Wait+4     Add the ones we used\n         BRC   12,H00240                No carry, skip\n         AL    R14,=FL4'1'              Carry, bump\nH00240   DS    0H\n         AL    R14,@H_LSPACE_Wait       Bump total WAIT time\n         LR    R4,R1                    Get total LSPACEs completed\n         AHI   R4,1                     Bump because we just finished\n         DR    R14,R4                   Re-calculate average\n         LR    R14,R15                  Set up new values for\n         LR    R15,R4                    Avg, # completed LSPACEs\n         CDS   R0,R14,0(R3)             Update them\n         JNE   H00230                   Collision, try again\n\n*---------------------------------------------------------------------*\n*     If the previous volume we processed wasn't on the same device   *\n*    type as this one, use TRKCALC to get the track size              *\n*---------------------------------------------------------------------*\n         CLC   @H_UCBTBYT4,VolTbl_Ent_UCBCopy+UCBTBYT4-UCBOB Same?\n         JE    H00270                   Yes, skip\n         MVC   @H_UCBTBYT4,VolTbl_Ent_UCBCopy+UCBTBYT4-UCBOB No\n         TRKCALC FUNCTN=TRKBAL,         Track balance                  +\n               TYPE=@H_UCBTBYT4,         A(Type)                       +\n               LOC=ANY,                  which is above the line       +\n               R=1,                      an empty track                +\n               K=0,                      no keys                       +\n               DD=VolTbl_Ent_DSCB+DS4DEVTK-IECSDSL4,  max size         +\n               REMOVE=NO,                Use an empty track            +\n               MAXSIZE=YES,              Return max we can use         +\n               REGSAVE=YES,              Save registers                +\n               MF=(E,@H_TRKCALC)         staying re-entrant\n         CHI   R15,12                    How did it go?\n         JNL   H00250                    Not good, set default\n         LTR   R0,R0                     Did we get a size back?\n         JNZ   H00260                    Yes, OK\nH00250   DS    0H\n         LH    R0,VolTbl_Ent_DSCB+DS4DEVTK-IECSDSL4 No, use default\n         XC    @H_UCBTBYT4,@H_UCBTBYT4\nH00260   DS    0H\n         ST    R0,@H_BytesPerTrack       Save bytes per track\nH00270   DS    0H\n\n*---------------------------------------------------------------------*\n*     Format the LSPACE info about this volume, and update our        *\n*    totals ...                                                       *\n*---------------------------------------------------------------------*\n         L     R15,@H_Total_Vols_OK     Get total valid volumes\n         AHI   R15,1                    Bump it\n         ST    R15,@H_Total_Vols_OK     Save it\n\n*     Tracks in the VTOC\n\n         LH    R0,VolTbl_Ent_DSCB+DS4DEVSZ+2-IECSDSL4 Get Trks/Cyl\n         LA    R1,0                     Clear register\n         ICM   R1,B'0011',VolTbl_Ent_DSCB+DS4VTOCE+6-IECSDSL4 Ending CC\n         LA    R15,0                    Clear register\n         ICM   R15,B'0011',VolTbl_Ent_DSCB+DS4VTOCE+2-IECSDSL4\n         SR    R1,R15                   End CC minus start CC\n         MR    R0,R0                          Get nbr tracks\n         AH    R1,VolTbl_Ent_DSCB+DS4VTOCE+8-IECSDSL4 Add ending HH\n         SH    R1,VolTbl_Ent_DSCB+DS4VTOCE+4-IECSDSL4 Less starting HH\n         AHI   R1,1                     Bump it\n         CDFBR R0,R1                    Convert to floating point\n         LA    R1,VolTbl_Ent_VTOCTrk    Point to output field\n         LHI   R0,L'VolTbl_Ent_VTOCTrk  Length of output field\n         BRAS  R14,H03000               Put in table\n\n         STD   R0,VolTbl_Ent_Sort_VTOCTrk Save it\n         ADB   R0,@H_Total_VTOCTrk      Bump total\n         STD   R0,@H_Total_VTOCTrk       and save it\n\n*     Total DSCBS in the VTOC\n\n         LA    R0,0                     Clear work reg\n         IC    R0,VolTbl_Ent_DSCB+DS4DEVDT-IECSDSL4 DSCBS/Trk\n         CDFBR R0,R0                    Convert to floating point\n         MDB   R0,VolTbl_Ent_Sort_VTOCTrk Nbr tracks in the VTOC\n\n         STD   R0,@H_TotDSCB            Save it\n         ADB   R0,@H_Total_DSCBs        Bump total\n         STD   R0,@H_Total_DSCBs        and save it\n\n*     Free DSCBs in the VTOC\n\n         L     R1,VolTbl_Ent_LSPACE_Data+LSPDF0S-LSPACE_Data Free DSCBs\n         CDFBR R0,R1                    Convert to floating point\n         LA    R1,VolTbl_Ent_FreeDSCB   Point to output field\n         LHI   R0,L'VolTbl_Ent_FreeDSCB Length of output field\n         BRAS  R14,H03000               Put in table\n\n         STD   R0,VolTbl_Ent_Sort_FreeDSCB Save for sorting\n         ADB   R0,@H_Total_FreeDSCBs    Bump total\n         STD   R0,@H_Total_FreeDSCBs    and save it\n\n*     % Free DSCBs in the VTOC\n\n         L     R1,VolTbl_Ent_LSPACE_Data+LSPDF0S-LSPACE_Data Free DSCBs\n         CDFBR R0,R1                    Convert to floating point\n         MDB   R0,=DBL8'1000'           100.0%\n         DDB   R0,@H_TotDSCB            Calc % free DSCBs\n         LA    R1,VolTbl_Ent_VTOCFree   Point to target field\n         LHI   R0,L'VolTbl_Ent_VTOCFree Length of output field\n         BRAS  R14,H03000               Put in table\n\n         DDB   R0,=DBL8'10'             back to xx.x%\n         STD   R0,VolTbl_Ent_Sort_VTOCFree Save it\n\n*     Total bytes on the volume\n\n         LA    R0,0                     Clear register\n         ICM   R0,B'0011',VolTbl_Ent_DSCB+DS4DEVSZ+2-IECSDSL4 Trks/Cyl\n         CDFBR R0,R0                    Convert to floating point\n         LA    R0,0                     Clear register\n         ICM   R0,B'0011',VolTbl_Ent_DSCB+DS4DEVSZ-IECSDSL4 Cyls/Device\n*        Begin Inserts Mahler, 13.NOV.2015 in order to support EAV\n         CLFI  R0,DS4EAV                R0=DS4EAV (X'0000FFFE')?\n         BNE   H00275                   Non EAV-Volume, New Label|\n         L     R0,VolTbl_Ent_DSCB+DS4DCYL-IECSDSL4 Cyls/Device (EAV)\n*        End   Inserts Mahler, 13.NOV.2015 in order to support EAV\nH00275   CDFBR R2,R0                    Convert to floating point\n         MDBR  R0,R2                    Get Trks/Device\n         LA    R0,0                     Clear work register\n         L     R0,@H_BytesPerTrack      Bytes/Trk\n         CDFBR R2,R0                    Convert to floating point\n         MDBR  R0,R2                    Bytes/Device\n         STD   R0,VolTbl_Ent_Sort_VolSize Save for sorting\n         STD   R0,@H_VolSize            Save it\n         LA    R1,VolTbl_Ent_VolSize    Point to output field\n         LHI   R0,L'VolTbl_Ent_VolSize  Length of output field\n         BRAS  R14,H03000               Put in table\n\n         ADB   R0,@H_Total_VolSize      Bump total\n         STD   R0,@H_Total_VolSize      and save it\n\n*     Nbr Free Extents on the volume\n\n         L     R1,VolTbl_Ent_LSPACE_Data+LSPDNEXT-LSPACE_Data Free ext\n         CDFBR R0,R1                    Convert to floating point\n         LA    R1,VolTbl_Ent_FreeExt    Point to output field\n         LHI   R0,L'VolTbl_Ent_FreeExt  Length of output field\n         BRAS  R14,H03000               Put in table\n\n         STD   R0,VolTbl_Ent_Sort_FreeExt Save for sorting\n         ADB   R0,@H_Total_Extents      Bump total\n         STD   R0,@H_Total_Extents      and save it\n\n*     Free Tracks on the volume\n\n         L     R0,VolTbl_Ent_LSPACE_Data+LSPDTCYL-LSPACE_Data Free Cyls\n         CDFBR R0,R0                    Convert to floating point\n         LH    R0,VolTbl_Ent_DSCB+DS4DEVSZ+2-IECSDSL4 Trks/Cyl\n         CDFBR R2,R0                    Convert to floating point\n         MDBR  R0,R2                    Get nbr free trks (in cyls)\n         L     R0,VolTbl_Ent_LSPACE_Data+LSPDTTRK-LSPACE_Data Free trks\n         CDFBR R2,R0                    Convert to floating point\n         ADBR  R0,R2                    Bump nbr trks\n         STD   R0,VolTbl_Ent_Sort_FreeTrk Save for sorting\n         LA    R1,VolTbl_Ent_FreeTrk    Point to output field\n         LHI   R0,L'VolTbl_Ent_FreeTrk  Length of output field\n         BRAS  R14,H03000               Put in table\n\n         ADB   R0,@H_Total_FreeTracks   Bump total\n         STD   R0,@H_Total_FreeTracks   and save it\n\n*     Free Bytes on the volume\n\n         LD    R0,VolTbl_Ent_Sort_FreeTrk Get nbr free tracks\n         LA    R0,0                     Clear work register\n         L     R0,@H_BytesPerTrack      Bytes/Trk\n         CDFBR R2,R0                    Convert to Floating point\n         MDBR  R0,R2                    Nbr free bytes\n         STD   R0,VolTbl_Ent_Sort_FreeBytes Save for sorting\n         LA    R1,VolTbl_Ent_FreeBytes  Point to output field\n         LHI   R0,L'VolTbl_Ent_FreeBytes Length of output field\n         BRAS  R14,H03000               Put in table\n\n         ADB   R0,@H_Total_FreeBytes    Bump totals\n         STD   R0,@H_Total_FreeBytes    and save it\n\n*     % Free space on the volume\n\n         LD    R0,VolTbl_Ent_Sort_FreeBytes Free Bytes on the volume\n         MDB   R0,=DBL8'1000'           Set up for % calc (100.0%)\n         DDB   R0,@H_VolSize            Divide by Bytes/Device\n         LA    R1,VolTbl_Ent_FreePct    Point to output field\n         LHI   R0,L'VolTbl_Ent_FreePct  Length of output field\n         BRAS  R14,H03000               Put in table\n\n         DDB   R0,=DBL8'10'             Convert to xx.x%\n         STD   R0,VolTbl_Ent_Sort_FreePct Save it\n\n*     Free Cylinders on the volume\n\n         L     R1,VolTbl_Ent_LSPACE_Data+LSPDTCYL-LSPACE_Data Free Cyls\n         CDFBR R0,R1                    Convert to floating point\n         LA    R1,VolTbl_Ent_FreeCyl    Point to output field\n         LHI   R0,L'VolTbl_Ent_FreeCyl  Length of output field\n         BRAS  R14,H03000               Put in table\n\n         STD   R0,VolTbl_Ent_Sort_FreeCyl Save for sorting\n         ADB   R0,@H_Total_FreeCyls     Bump totals\n         STD   R0,@H_Total_FreeCyls     and save it\n\n*     Largest extent (in tracks) on the volume\n\n         L     R0,VolTbl_Ent_LSPACE_Data+LSPDLCYL-LSPACE_Data Larg Cyls\n         CDFBR R0,R0                    Convert to FP\n         LH    R0,VolTbl_Ent_DSCB+DS4DEVSZ+2-IECSDSL4 Trks/Cyl\n         CDFBR R2,R0                    Convert to FP\n         MDBR  R0,R2                    Get nbr trks\n         L     R0,VolTbl_Ent_LSPACE_Data+LSPDLTRK-LSPACE_Data Get trks\n         CDFBR R2,R0                    Convert to FP\n         ADBR  R0,R2                    Add to total\n         STD   R0,VolTbl_Ent_Sort_LargTrk Save for sorting\n         LA    R1,VolTbl_Ent_LargTrk    Point to output field\n         LHI   R0,L'VolTbl_Ent_LargTrk  Length of output field\n         BRAS  R14,H03000               Put in table\n\n         CDB   R0,@H_Largest_FreeTracks Biggest so far?\n         JNH   H00280                   No, skip\n         STD   R0,@H_Largest_FreeTracks Yes, save it\n\nH00280   DS    0H\n\n*     Largest extent (in cylinders) on the volume\n\n         L     R0,VolTbl_Ent_LSPACE_Data+LSPDLCYL-LSPACE_Data Larg Cyls\n         CDFBR R0,R0                    Convert to floating point\n         LA    R1,VolTbl_Ent_LargCyl    Point to output field\n         LHI   R0,L'VolTbl_Ent_LargCyl  Length of output field\n         BRAS  R14,H03000               Put in table\n\n         STD   R0,VolTbl_Ent_Sort_LargCyl Save for sorting\n         CDB   R0,@H_Largest_FreeCyls   Largest so far?\n         JNH   H00290                   No, skip\n         STD   R0,@H_Largest_FreeCyls   Yes, save it\n\nH00290   DS    0H\n*---------------------------------------------------------------------*\n*     VTOC IX Status: A - Active                                      *\n*                     E - Exists, but not active                      *\n*                     N - Does not exist                              *\n*---------------------------------------------------------------------*\n         TM    VolTbl_Ent_LSPACE_Data+LSPDSTAT-LSPACE_Data,LSPDIXAC\n         JO    H00300                   Yes, skip\n         TM    VolTbl_Ent_LSPACE_Data+LSPDSTAT-LSPACE_Data,LSPDIXDS IX?\n         JO    H00310                   Yes, skip\n         MVI   VolTbl_Ent_VTOCIX+1,C'N' No, No IX VTOC\n         J     H00320                   and skip\nH00300   DS    0H\n         MVI   VolTbl_Ent_VTOCIX+1,C'A' IX VTOC active\n         J     H00320                   and skip\nH00310   DS    0H\n         MVI   VolTbl_Ent_VTOCIX+1,C'Y' IX VTOC exists\n         J     H00320                   and skip\n\nH00320   DS    0H\n*---------------------------------------------------------------------*\n*     Fragmentation Index                                             *\n*---------------------------------------------------------------------*\n         L     R0,VolTbl_Ent_LSPACE_Data+LSPDFRAG-LSPACE_Data Frag Indx\n         CHI   R0,999                   Too big?\n         JNH   H00330                   No, OK\n         LHI   R0,999                   Yes, set to max\nH00330   DS    0H\n         CDFBR R0,R0                    Convert to floating point\n         LHI   R0,L'VolTbl_Ent_Frag_Indx Len of target field\n         LA    R1,VolTbl_Ent_Frag_Indx  Point to it\n         BRAS  R14,H03000               Go format it\n\n         ADB   R0,@H_Total_FragIndex    Bump totals\n         STD   R0,@H_Total_FragIndex    and save it\n\n*---------------------------------------------------------------------*\n*     SMS Anomaly                                                     *\n*---------------------------------------------------------------------*\n         CLI   VolTbl_Ent_DSCB+DS4SMSFG-IECSDSL4,DS4NTSMS SMS in VTOC?\n         JE    H00340                   No, skip\n         TM    VolTbl_Ent_UCBCOPY+UCBFL5-UCBOB,UCBSMS Yes, UCB SMS too?\n         JO    H00370                   Yes, OK\n         J     H00350                   No, set message\nH00340   DS    0H\n         TM    VolTbl_Ent_UCBCOPY+UCBFL5-UCBOB,UCBSMS NO, UCB = SMS?\n         JZ    H00370                   No, OK\nH00350   DS    0H\n         MVI   VolTbl_Ent_VTOC_SMS,C'*' No, flag it\n         ICM   R14,B'1111',@H_SMS_Anomaly_Ptr  Yes, A(SMS Anomaly line)\n         JZ    H00370                   None, skip\n         TM    VolTbl_Ent_ECB-VolTbl_Ent(R14),X'40' Already done?\n         JO    H00370                   Yes, skip\n         LA    R0,VolTbl_Ent_VTOC_SMS-VolTbl_Ent(0,R14) A(Target)\n         LHI   R1,VolTbl_Ent_Display_End-VolTbl_Ent_VTOC_SMS Target Len\n         LA    R14,H_SMS_Anomaly_Msg    A(Source)\n         LA    R15,L'H_SMS_Anomaly_Msg  Source length\n         O     R15,=XL4'40000000'       Fill with blanks\n         MVCL  R0,R14                   Move message\n\n         L     R15,@H_SMS_Anomaly_Ptr   A(SMS Anomaly line)\n         L     R0,VolTbl_Ent_ECB-VolTbl_Ent(R15) Current ECB\n         TM    VolTbl_Ent_ECB-VolTbl_Ent(R15),X'80' Anyone WAITing?\n         JO    H00360                   Yes, we need to POST\n         L     R1,=XL4'40000000'        No, POST code of 0\n         CS    R0,R1,VolTbl_Ent_ECB-VolTbl_Ent(R15) Pseudo-POST it\n         JZ    H00370                   OK, skip the real POST\nH00360   DS    0H\n         POST  VolTbl_Ent_ECB-VolTbl_Ent(R15),0 POST line as complete\nH00370   DS    0H\n\nH00380   DS    0H\n*---------------------------------------------------------------------*\n*     POST this entry as complete ...                                 *\n*---------------------------------------------------------------------*\n         L     R14,VolTbl_Ent_ECB       Current contents of our ECB\n         TM    VolTbl_Ent_ECB,X'80'     Anyone WAITing?\n         JO    H00390                   Yes, we need to POST\n         L     R15,=XL4'40000000'       No, POST code of 0\n         CS    R14,R15,VolTbl_Ent_ECB   Pseudo-POST it\n         JZ    H00400                   OK, skip the real POST\nH00390   DS    0H\n         POST  VolTbl_Ent_ECB,0         Flag as complete\nH00400   DS    0H\n\nH00410   DS    0H\n*---------------------------------------------------------------------*\n*     ... and see if we can find another volume to do.                *\n*---------------------------------------------------------------------*\n         AHI   R9,VolTbl_Ent_Len        Point to next VolTbl_Ent\n         BRCT  R10,H00050               and check it out\n\n*---------------------------------------------------------------------*\n*     We are done - update the totals, if required ...                *\n*---------------------------------------------------------------------*\n         ICM   R9,B'1111',@H_Totals_Line_Ptr   A(Totals Line)\n         JZ    H00560                   None, skip\n\nH00420   DS    0H\n         L     R0,VolTbl_Ent_Total_Vols_OK Curr count\n         LR    R1,R0                    Save it\n         A     R1,@H_Total_Vols_OK      Bump it\n         CS    R0,R1,VolTbl_Ent_Total_Vols_OK Update it\n         JNZ   H00420                   Collision, try again\n\n         LD    R0,@H_Total_VTOCTrk      Amount we did\nH00430   DS    0H\n         LM    R0,R1,VolTbl_Ent_Total_VTOCTrk Orig Val\n         STM   R0,R1,@H_DBLWD           Save original value\n         LD    R2,@H_DBLWD              Load up FP register\n         ADBR  R2,R0                    Bump it\n         STD   R2,@H_DBLWD              Save updated total\n         LM    R2,R3,@H_DBLWD           Get new totals\n         CDS   R0,R2,VolTbl_Ent_Total_VTOCTrk Update it\n         JNZ   H00430                   Collision, try again\n\n         LD    R0,@H_Total_DSCBs        Get amount we did\nH00440   DS    0H\n         LM    R0,R1,VolTbl_Ent_Total_DSCBs\n         STM   R0,R1,@H_DBLWD           Save original value\n         LD    R2,@H_DBLWD              Load up FP register\n         ADBR  R2,R0                    Bump it\n         STD   R2,@H_DBLWD              Save updated total\n         LM    R2,R3,@H_DBLWD           Get old, new totals\n         CDS   R0,R2,VolTbl_Ent_Total_DSCBs Update it\n         JNZ   H00440                   Collision, try again\n\n         LD    R0,@H_Total_FreeDSCBs    Get amount we did\nH00450   DS    0H\n         LM    R0,R1,VolTbl_Ent_Total_FreeDSCBs\n         STM   R0,R1,@H_DBLWD           Save original value\n         LD    R2,@H_DBLWD              Load up FP register\n         ADBR  R2,R0                    Bump it\n         STD   R2,@H_DBLWD              Save updated total\n         LM    R2,R3,@H_DBLWD           Get old, new totals\n         CDS   R0,R2,VolTbl_Ent_Total_FreeDSCBs Update\n         JNZ   H00450                   Collision, try again\n\n         LD    R0,@H_Total_VolSize      Get amount we did\nH00460   DS    0H\n         LM    R0,R1,VolTbl_Ent_Total_VolSize\n         STM   R0,R1,@H_DBLWD           Save original value\n         LD    R2,@H_DBLWD              Load up FP register\n         ADBR  R2,R0                    Bump it\n         STD   R2,@H_DBLWD              Save updated total\n         LM    R2,R3,@H_DBLWD           Get old, new totals\n         CDS   R0,R2,VolTbl_Ent_Total_VolSize Update it\n         JNZ   H00460                   Collision, try again\n\n         LD    R0,@H_Total_Extents      Get amount we did\nH00470   DS    0H\n         LM    R0,R1,VolTbl_Ent_Total_Extents\n         STM   R0,R1,@H_DBLWD           Save original value\n         LD    R2,@H_DBLWD              Load up FP register\n         ADBR  R2,R0                    Bump it\n         STD   R2,@H_DBLWD              Save updated total\n         LM    R2,R3,@H_DBLWD           Get old, new totals\n         CDS   R0,R2,VolTbl_Ent_Total_Extents Update it\n         JNZ   H00470                   Collision, try again\n\n         LD    R0,@H_Total_FreeTracks   Get amount we did\nH00480   DS    0H\n         LM    R0,R1,VolTbl_Ent_Total_FreeTracks\n         STM   R0,R1,@H_DBLWD           Save original value\n         LD    R2,@H_DBLWD              Load up FP register\n         ADBR  R2,R0                    Bump it\n         STD   R2,@H_DBLWD              Save updated total\n         LM    R2,R3,@H_DBLWD           Get old, new totals\n         CDS   R0,R2,VolTbl_Ent_Total_FreeTracks Update\n         JNZ   H00480                   Collision, try again\n\n         LD    R0,@H_Total_FreeBytes    Get amount we did\nH00490   DS    0H\n         LM    R0,R1,VolTbl_Ent_Total_FreeBytes\n         STM   R0,R1,@H_DBLWD           Save original value\n         LD    R2,@H_DBLWD              Load up FP register\n         ADBR  R2,R0                    Bump it\n         STD   R2,@H_DBLWD              Save updated total\n         LM    R2,R3,@H_DBLWD           Get old, new totals\n         CDS   R0,R2,VolTbl_Ent_Total_FreeBytes Update\n         JNZ   H00490                   Collision, try again\n\n         LD    R0,@H_Total_FreeCyls     Get amount we did\nH00500   DS    0H\n         LM    R0,R1,VolTbl_Ent_Total_FreeCyls\n         STM   R0,R1,@H_DBLWD           Save original value\n         LD    R2,@H_DBLWD              Load up FP register\n         ADBR  R2,R0                    Bump it\n         STD   R2,@H_DBLWD              Save updated total\n         LM    R2,R3,@H_DBLWD           Get old, new totals\n         CDS   R0,R2,VolTbl_Ent_Total_FreeCyls Update\n         JNZ   H00500                   Collision, try again\n\n         LD    R0,@H_Largest_FreeTracks Get the biggest we did\nH00510   DS    0H\n         LM    R0,R1,VolTbl_Ent_Largest_FreeTracks\n         STM   R0,R1,@H_DBLWD           Save original value\n         LD    R2,@H_DBLWD              Load up FP register\n         CDBR  R0,R2                    Biggest so far?\n         JNH   H00520                   No, skip\n         STD   R0,@H_DBLWD              Yes, save new largest\n         LM    R2,R3,@H_DBLWD           Get old, new values\n         CDS   R0,R2,VolTbl_Ent_Largest_FreeTracks\n         JNZ   H00510                   Collision, try again\n\nH00520   DS    0H\n\n         LD    R0,@H_Largest_FreeCyls   Get the largest we did\nH00530   DS    0H\n         LM    R0,R1,VolTbl_Ent_Largest_FreeCyls\n         STM   R0,R1,@H_DBLWD           Save original value\n         LD    R2,@H_DBLWD              Load up FP register\n         CDBR  R0,R2                    Biggest so far?\n         JNH   H00540                   No, skip\n         STD   R0,@H_DBLWD              Yes, save new largest\n         LM    R2,R3,@H_DBLWD           Get old, new values\n         CDS   R0,R2,VolTbl_Ent_Largest_FreeCyls\n         JNZ   H00530                   Collision, try again\n\nH00540   DS    0H\n\n         LD    R0,@H_Total_FragIndex    Yes, bump totals\nH00550   DS    0H\n         LM    R0,R1,VolTbl_Ent_Total_FragIndex\n         STM   R0,R1,@H_DBLWD           Save original value\n         LD    R2,@H_DBLWD              Load up FP register\n         ADBR  R2,R0                    Bump it\n         STD   R2,@H_DBLWD              Save updated total\n         LM    R2,R3,@H_DBLWD           Get old, new totals\n         CDS   R0,R2,VolTbl_Ent_Total_FragIndex Update\n         JNZ   H00550                   Collision, try again\n\nH00560   DS    0H\n*---------------------------------------------------------------------*\n*     ... and then the total number of volumes we did                 *\n*---------------------------------------------------------------------*\n         L     R15,@H_VolTbl_Ptr        A(Volume Table)\n         L     R0,VolTbl_Hdr_Vols_Proc-VolTbl_Hdr(R15) Get current\n         LR    R1,R0                    Save it\n         A     R1,@H_Total_Vols_Proc    Bump it\n         CS    R0,R1,VolTbl_Hdr_Vols_Proc-VolTbl_Hdr(R15) Update it\n         JNZ   H00560                   Collision, try again\n\n*---------------------------------------------------------------------*\n*     If this completes the table, fill in the totals, if required    *\n*---------------------------------------------------------------------*\n         C     R1,VolTbl_Hdr_Vols_Total-VolTbl_Hdr(R15) All done?\n         JL    H00610                   No, skip\n         OI    @H_VolTbl_Complete,L'@H_VolTbl_Complete Yes, flag it\n\n         ICM   R9,B'1111',@H_Totals_Line_Ptr A(Totals line)\n         JZ    H00590                   None, all done\n\n         LD    R0,VolTbl_Ent_Total_VolSize Get Total bytes\n         LTDBR R0,R0                    Any?\n         JZ    H00570                   No, we're done with the totals\n\n         LD    R0,VolTbl_Ent_Total_FreeTracks Total free tracks\n         LA    R1,VolTbl_Ent_FreeTrk    Point to output field\n         LHI   R0,L'VolTbl_Ent_FreeTrk  Length of output field\n         BRAS  R14,H03000               Put in table\n\n         LD    R0,VolTbl_Ent_Total_FreeCyls Total Free Cyls\n         LA    R1,VolTbl_Ent_FreeCyl    Point to output field\n         LHI   R0,L'VolTbl_Ent_FreeCyl  Length of output field\n         BRAS  R14,H03000               Put in table\n\n         LD    R0,VolTbl_Ent_Total_FreeBytes Total Free Bytes\n         DDB   R0,VolTbl_Ent_Total_Volsize divided by total bytes\n         MDB   R0,=DBL8'1000'           Set up as a % (100.0)\n         LA    R1,VolTbl_Ent_FreePct    Point to output field\n         LHI   R0,L'VolTbl_Ent_FreePct  Length of output field\n         BRAS  R14,H03000               Put in table\n         DDB   R0,=DBL8'10'             back to xx.x\n         STD   R0,VolTbl_Ent_Total_FreePct Save it\n\n         LD    R0,VolTbl_Ent_Total_FreeBytes Total Free Bytes\n         LA    R1,VolTbl_Ent_FreeBytes  Point to output field\n         LHI   R0,L'VolTbl_Ent_FreeBytes Length of output field\n         BRAS  R14,H03000               Put in table\n\n         LD    R0,VolTbl_Ent_Total_Extents Total Extents\n         LA    R1,VolTbl_Ent_FreeExt    Point to output field\n         LHI   R0,L'VolTbl_Ent_FreeExt  Length of output field\n         BRAS  R14,H03000               Put in table\n\n         LD    R0,VolTbl_Ent_Largest_FreeCyls Largest Free Cyls\n         LA    R1,VolTbl_Ent_LargCyl    Point to output field\n         LHI   R0,L'VolTbl_Ent_LargCyl  Length of output field\n         BRAS  R14,H03000               Put in table\n\n         LD    R0,VolTbl_Ent_Largest_FreeTracks Largest Free Tracks\n         LA    R1,VolTbl_Ent_LargTrk    Point to output field\n         LHI   R0,L'VolTbl_Ent_LargTrk  Length of output field\n         BRAS  R14,H03000               Put in table\n\n         LD    R0,VolTbl_Ent_Total_VTOCTrk Total VTOC tracks\n         LA    R1,VolTbl_Ent_VTOCTrk    Point to output field\n         LHI   R0,L'VolTbl_Ent_VTOCTrk  Length of output field\n         BRAS  R14,H03000               Put in table\n\n         LD    R0,VolTbl_Ent_Total_FreeDSCBs Total Free DSCBs\n         LA    R1,VolTbl_Ent_FreeDSCB   Point to output field\n         LHI   R0,L'VolTbl_Ent_FreeDSCB Length of output field\n         BRAS  R14,H03000               Put in table\n\n         LD    R0,VolTbl_Ent_Total_FreeDSCBs Get Total Free DSCBs\n         DDB   R0,VolTbl_Ent_Total_DSCBs Get percent free\n         MDB   R0,=DBL8'1000'           * 100.0\n         LA    R1,VolTbl_Ent_VTOCFree   Point to output field\n         LHI   R0,L'VolTbl_Ent_VTOCFree Length of output field\n         BRAS  R14,H03000               Put in table\n         MDB   R0,=DBL8'10'             back to xx.x\n         STD   R0,VolTbl_Ent_Total_VTOCFree Save it\n\n         LD    R0,VolTbl_Ent_Total_VolSize Get Total Bytes\n         LA    R1,VolTbl_Ent_VolSize    Point to output field\n         LHI   R0,L'VolTbl_Ent_VolSize  Length of output field\n         BRAS  R14,H03000               Put in table\n\n         L     R0,VolTbl_Ent_Total_Vols_OK Number of volumes with data\n         CDFBR R2,R0                    Convert to floating point\n         LD    R0,VolTbl_Ent_Total_FragIndex Get Total Frag Index\n         DDBR  R0,R2                    Get avg frag index\n         LA    R1,VolTbl_Ent_Frag_Indx  Point to output field\n         LHI   R0,L'VolTbl_Ent_Frag_Indx Length of output field\n         BRAS  R14,H03000               Put in table\n\nH00570   DS    0H\n*---------------------------------------------------------------------*\n*     ... POST it as complete ...                                     *\n*---------------------------------------------------------------------*\n         L     R14,VolTbl_Ent_ECB       Current contents of our ECB\n         TM    VolTbl_Ent_ECB,X'80'     Anyone WAITing?\n         JO    H00580                   Yes, we need to POST\n         L     R15,=XL4'40000000'       No, POST code of 0\n         CS    R14,R15,VolTbl_Ent_ECB   Pseudo-POST it\n         JZ    H00590                   OK, skip the real POST\nH00580   DS    0H\n         POST  VolTbl_Ent_ECB,0         Flag as complete\n\nH00590   DS    0H\n*---------------------------------------------------------------------*\n*     ... if the SMS anomaly line has not been completed (because     *\n*    there was no SMS anomaly), flag it as complete now               *\n*---------------------------------------------------------------------*\n         ICM   R9,B'1111',@H_SMS_Anomaly_Ptr A(SMS Anomaly line)\n         JZ    H00610                   None, skip\n         TM    VolTbl_Ent_ECB,X'40'     Already POSTed?\n         JO    H00610                   Yes, skip\n         L     R14,VolTbl_Ent_ECB       Current contents of our ECB\n         TM    VolTbl_Ent_ECB,X'80'     Anyone WAITing?\n         JO    H00600                   Yes, we need to POST\n         L     R15,=XL4'40000000'       No, POST code of 0\n         CS    R14,R15,VolTbl_Ent_ECB   Pseudo-POST it\n         JZ    H00610                   OK, skip the real POST\nH00600   DS    0H\n         POST  VolTbl_Ent_ECB,0         Flag as complete\n\nH00610   DS    0H\n*---------------------------------------------------------------------*\n*     Fill in our Stats line, if present                              *\n*---------------------------------------------------------------------*\n         ICM   R9,B'1111',@H_Stats_Line_Ptr A(1st Stats Heading line)\n         JZ    H00730                   None, skip\n\n*---------------------------------------------------------------------*\n*     If the headings haven't yet been filled in (i.e., we are the    *\n*    first ones here), fill them in ...                               *\n*---------------------------------------------------------------------*\n         LA    R2,H_SubTask_Hdgs        A(Start of headings)\n         LA    R4,H_SubTask_Hdg_Lens    A(Lengths of heading lines)\n         LHI   R5,H_SubTask_Hdg_Count   Get nbr heading lines\nH00620   DS    0H\n         TM    VolTbl_Ent_Processed,L'VolTbl_Ent_Processed Done?\n         JNZ   H00650                   Yes, try next\n\n         L     R1,VolTbl_Ent_Processed  No, get the Flag byte\n         LA    R0,L'VolTbl_Ent_Processed Set up the\n         SLL   R0,24                     flag turned\n         OR    R0,R1                     on\n         CS    R1,R0,VolTbl_Ent_Processed and update it\n         JNE   H00650                   Somebody else here, skip it\n\n         LH    R3,0(0,R4)               Len of heading line\n         O     R3,=XL4'40000000'        Pad char of blank\n         LA    R0,VolTbl_Ent_Display    A(Target)\n         LHI   R1,L'VolTbl_Ent_Display  Length of target\n         MVCL  R0,R2                    Move heading\n         OI    VolTbl_Ent_Stats_Done,l'VolTbl_Ent_Stats_Done Done\n\n         L     R0,VolTbl_Ent_ECB        Current contents of our ECB\n         TM    VolTbl_Ent_ECB,X'80'     Anyone WAITing?\n         JO    H00630                   Yes, we need to POST\n         L     R1,=XL4'40000000'        No, POST code of 0\n         CS    R0,R1,VolTbl_Ent_ECB     Pseudo-POST it\n         JZ    H00640                   OK, skip the real POST\nH00630   DS    0H\n         POST  VolTbl_Ent_ECB,0         POST line as complete\nH00640   DS    0H\n\nH00650   DS    0H\n         AHI   R9,VolTbl_Ent_Len        Bump entry pointer\n         AHI   R4,2                     Bump lengths pointer\n         BRCT  R5,H00620                and try again\n\n*---------------------------------------------------------------------*\n*     Headings all done, find an unused entry for our subtask stats   *\n*    At this point, R9 points to the line after the subtask hdgs.     *\n*---------------------------------------------------------------------*\n         L     R14,@H_VolTbl_Ptr        A(VolTbl)\n         AHI   R14,VolTbl_Ent-VolTbl_Hdr  A(1st entry)\n         LR    R15,R9                   A(Our entry\n         SR    R15,R14                  Offset of our line\n         LA    R14,0                    Clear R14\n         LHI   R0,VolTbl_Ent_Len        Length of 1 entry\n         DR    R14,R0                   Get our entry num\n         S     R15,=FL4'1'              Relative to 0\n         JM    H00730                   Negative, skip it\n         L     R10,@H_VolTbl_Ptr        A(VolTbl) again\n         L     R10,VolTbl_Hdr_Count-VolTbl_Hdr(0,R10) Nbr entries\n         SR    R10,R15                  Nbr entries remaining\n         JNP   H00730                   None, skip it\n         LR    R3,R10                   Init SubTask Nbr\nH00660   DS    0H\n         TM    VolTbl_Ent_Processed,L'VolTbl_Ent_Processed Done?\n         JNZ   H00670                   Yes, try next\n\n         L     R1,VolTbl_Ent_Processed  No, get the Flag byte\n         LA    R0,L'VolTbl_Ent_Processed Set up the\n         SLL   R0,24                     flag turned\n         OR    R0,R1                     on\n         CS    R1,R0,VolTbl_Ent_Processed and update it\n         JE    H00680                   OK, skip\nH00670   DS    0H\n         AHI   R9,VolTbl_Ent_Len        Bump entry pointer\n         BRCT  R10,H00660               and try again\n         J     H00730                   None, skip it\nH00680   DS    0H\n*---------------------------------------------------------------------*\n*     Output our subtask stats.  Note that if we did all the volumes, *\n*   we were BASR'd to, rather than ATTACHed. In this case, we do      *\n*   not put out the 1st and 3rd fields (SubTask Nbr and CPU Time).    *\n*---------------------------------------------------------------------*\n         L     R14,=AL4(H_SubTask_Line) A(Stats line skeleton)\n         LHI   R15,H_SubTask_Line_Len   Len of skeleton\n         O     R15,=XL4'40000000'       Pad char of blank\n         LA    R0,VolTbl_Ent_Display    A(Target)\n         LA    R1,VolTbl_Ent_Display_Len Length of target\n         MVCL  R0,R14                   Move skeleton\n\n         L     R15,@H_Total_Vols_Proc   Total volumes\n         CVD   R15,@H_DBLWD             Pack it\n         ED    VolTbl_Ent_Display+H_SubTask_Line_TotVol-H_SubTask_Line(+\n               L'H_SubTask_Line_TotVol),@H_DBLWD+5\n\n         L     R0,@H_Total_Vols_Proc    Number of volumes we did\n         L     R15,@H_VolTbl_Ptr        A(Volume Table)\n         C     R0,VolTbl_Hdr_Vols_Total-VolTbl_Hdr(R15) All us?\n         JL    H00690                   No, others here too\n         MVC   VolTbl_Ent_Display+H_SubTask_Line_Nbr+1-H_SubTask_Line(L+\n               'H_SubTask_Line_Nbr-1),VolTbl_Ent_Display+H_SubTask_Line+\n               _Nbr-H_SubTask_Line      Clear ED mask\n         MVC   VolTbl_Ent_Display+H_SubTask_Line_Nbr+L'H_SubTask_Line_N+\n               br-3-H_SubTask_Line(3),=C'N/A'\n         MVC   VolTbl_Ent_Display+H_SubTask_Line_CPU+1-H_SubTask_Line(L+\n               'H_SubTask_Line_CPU-1),VolTbl_Ent_Display+H_SubTask_Line+\n               _CPU-H_SubTask_Line      Clear ED mask\n         MVC   VolTbl_Ent_Display+H_SubTask_Line_CPU+L'H_SubTask_Line_C+\n               PU-3-H_SubTask_Line(3),=C'N/A'\n         J     H00700                   and skip\n\nH00690   DS    0H\n         SR    R3,R10                   SubTask nbr\n         AHI   R3,1                     Relative to 1\n         CVD   R3,@H_DBLWD              Pack it\n         ED    VolTbl_Ent_Display+H_SubTask_Line_Nbr-H_SubTask_Line(L'H+\n               _SubTask_Line_Nbr),@H_DBLWD+6\n\n         TIMEUSED STORADR=@H_DBLWD,     Get CPU time used              +\n               LINKAGE=SYSTEM,           as recommended by IBM         +\n               CPU=MIC                   get it in microseconds\n         LM    R14,R15,@H_DBLWD         Get microseconds\n         D     R14,=FL4'1000'           Convert to milliseconds\n         CVD   R15,@H_DBLWD             Pack it\n         ED    VolTbl_Ent_Display+H_SubTask_Line_CPU-H_SubTask_Line(L'H+\n               _SubTask_Line_CPU),@H_DBLWD+5\n\nH00700   DS    0H\n         L     R15,@H_Total_Vols_OK     Volumes where LSPACE worked\n         CVD   R15,@H_DBLWD             Pack it\n         ED    VolTbl_Ent_Display+H_SubTask_Line_Vol_OK-H_SubTask_Line(+\n               L'H_SubTask_Line_Vol_OK),@H_DBLWD+5\n\n         LM    R14,R15,@H_Total_LSPACE_Wait_OK Good LSPACE time (usec)\n         D     R14,=FL4'1000'           Convert to milliseconds\n         CVD   R15,@H_DBLWD             Pack it\n         ED    VolTbl_Ent_Display+H_SubTask_Line_Wait_OK-H_SubTask_Line+\n               (L'H_SubTask_Line_Wait_OK),@H_DBLWD+5\n\n         L     R15,@H_Total_Vols_Proc   Total volumes\n         S     R15,@H_Total_Vols_OK      minus ones where LSPACE OK\n         CVD   R15,@H_DBLWD             Pack it\n         ED    VolTbl_Ent_Display+H_SubTask_Line_Vol_Bad-H_SubTask_Line+\n               (L'H_SubTask_Line_Vol_Bad),@H_DBLWD+5\n\n         LM    R14,R15,@H_Total_LSPACE_Wait_Bad Fail LSPACE time (usec)\n         D     R14,=FL4'1000'           Convert to milliseconds\n         CVD   R15,@H_DBLWD             Pack it\n         ED    VolTbl_Ent_Display+H_SubTask_Line_Wait_Bad-H_SubTask_Lin+\n               e(L'H_SubTask_Line_Wait_Bad),@H_DBLWD+5\n\n\n         OI    VolTbl_Ent_Stats_Done,L'VolTbl_Ent_Stats_Done Done\n\n         L     R0,VolTbl_Ent_ECB        Current contents of our ECB\n         TM    VolTbl_Ent_ECB,X'80'     Anyone WAITing?\n         JO    H00710                   Yes, we need to POST\n         L     R1,=XL4'40000000'        No, POST code of 0\n         CS    R0,R1,VolTbl_Ent_ECB     Pseudo-POST it\n         JZ    H00720                   OK, skip the real POST\nH00710   DS    0H\n         POST  VolTbl_Ent_ECB,0         POST line as complete\nH00720   DS    0H\n\n\nH00730   DS    0H\n*---------------------------------------------------------------------*\n*     If we are the last ones here (i.e., we finished VolTbl),        *\n*    flag the table as complete                                       *\n*---------------------------------------------------------------------*\n         TM    @H_VolTbl_Complete,L'@H_VolTbl_Complete All done?\n         JNO   H00750                   No, skip\n\n         L     R10,@H_VolTbl_Ptr        A(VolTbl)\n         L     R14,VolTbl_Hdr_ECB-VolTbl_Hdr(R10) Contents of our ECB\n         TM    VolTbl_Hdr_ECB-VolTbl_Hdr(R10),X'80' Anyone WAITing?\n         JO    H00740                   Yes, we need to POST\n         L     R15,=XL4'40000000'       No, POST code of 0\n         CS    R14,R15,VolTbl_Hdr_ECB-VolTbl_Hdr(R10) Pseudo-POST it\n         JZ    H00750                   OK, skip the real POST\nH00740   DS    0H\n         POST  VolTbl_Hdr_ECB-VolTbl_Hdr(R10),0 Flag as complete\nH00750   DS    0H\n\n         J     H90010                   All done, exit\n\n\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n\nH03000   DS    0H\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*   Format and scale a long binary FP number                          *\n*                                                                     *\n*   On Entry, FP0     = Long FP value                                 *\n*             GPR 0   = Length of Target Field                        *\n*             GPR 1   = A(Target field)                               *\n*                                                                     *\n*   On Exit,  N/A                                                     *\n*                                                                     *\n*   Notes: This routine should only be used for output fields with    *\n*          lengths if 4, 5, or 6.                                     *\n*          Output fields of length = 4 are assumed to be percents.    *\n*          Values destined for output fields with lengths of 5 or 6   *\n*          will be scaled, if necessary. All scaled values will have  *\n*          a single decimal point.                                    *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         STM   R14,R12,12(R13)          Save callers registers\n         LDR   R6,R0                    Save FP R0\n\n         LA    R15,0                    Clear scale indicator\n         CHI   R0,5                     Check output length\n         JL    H03040                   a %, skip scaling\n         JH    H03010                   6-char field, skip\n         LD    R2,=DBL8'10000'          Max value + 1\n         J     H03020\nH03010   DS    0H\n         LD    R2,=DBL8'100000'         Max value + 1\nH03020   DS    0H\n         CDBR  R0,R2                    Do we have to scale?\n         JNH   H03040                   No, skip\n         LTR   R15,R15                  Have we scaled already?\n         JNZ   H03030                   Yes, skip\n         DDB   R2,=DBL8'100'            No, max val +1\nH03030   DS    0H\n         DDB   R0,=DBL8'1000'           Divide by 1000\n         AHI   R15,1                    Bump scaling factor\n         J     H03020                   and check again\n\nH03040   DS    0H\n         LTR   R15,R15                  Did we have to scale it?\n         JZ    H03050                   No, skip\n         MVC   @H_MaskArea,=X'40202021204B2040' Yes, move mask\n         LA    R15,H_Scale-1(R15)       Get scaling factor\n         MVC   @H_Scale,0(R15)          Save it\n         MDB   R0,=DBL8'10'             Add a decimal point\n         J     H03070                   and skip\nH03050   DS    0H\n         CHI   R0,5                     Is this a percent?\n         JNL   H03060                   No, skip\n         MVC   @H_MaskArea,=X'4040202021204B20' Yes, move mask\n         CDB   R0,=DBL8'999.4'          Will we round up to 100%?\n         JNH   H03070                   No, OK\n         LD    R0,=DBL8'999.4'          Yes, set to 99.9%\n         J     H03070                   and skip\nH03060   DS    0H\n         MVC   @H_MaskArea,=X'404020206B202120' Move mask\nH03070   DS    0H\n         CFDBR R15,B'0100',R0           Convert and round\n         CVD   R15,@H_DBLWD             Pack it\n         ED    @H_MaskArea,@H_DBLWD+5   Edit in the number\n         CLI   @H_MaskArea+L'@H_MaskArea-1,C' ' Did we scale?\n         JNE   H03080                   No, skip\n         MVC   @H_MaskArea+L'@H_MaskArea-1(1),@H_Scale Yes, move factor\nH03080   DS    0H\n         LA    R15,@H_MaskArea+L'@H_MaskArea Point to\n         SR    R15,R0                     start of our data\n         MVC   @H_MaskArea,0(R15)       Left align in mask area\n         LR    R15,R0                   Get length again\n         AHI   R15,-1                   EX length\n         L     R1,24(0,R13)             A(Target field)\n         EX    R15,H_MVC1               Move to output field\nH03090   DS    0H\n\n         LM    R14,R12,12(R13)          Restore registers\n         LDR   R0,R6                    Restore FP R0\n\n         BR    R14                      and exit\n\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n\n\n\nH06000   DS    0H\n\n*---------------------------------------------------------------------*\n*     Our timer has expired - verify that we are in the middle of     *\n*    LSPACE by checking that the PRB at the end of the RB chain has   *\n*    issued an SVC 78 (LSPACE).                                       *\n*     If SVC78 is active, or has not yet been issued,                 *\n*        Establish an ESTAE with PURGE=HALT                           *\n*        ABEND X'0522'                                                *\n*     Else                                                            *\n*        disappear quietly (we have popped after LSPACE completed, but*\n*                           before the STIMERM was cancelled)         *\n*---------------------------------------------------------------------*\n         PUSH  USING                    Save our USING environment\n         DROP  ,\n\n         USING *,R15                    Assign temp base\n         STM   14,12,12(13)             Save callers registers\n         LR    R11,R15                  Load permanent base reg\n         DROP  R15                      Free up temp base\n         USING H06000,R11               Assign permanent base\n         L     R1,4(0,R1)               Get A(Parms passed)\n         L     R10,0(0,R1)              Get A(Dynamic storage)\n         USING @H_Dynam,R10             Assign a base\n\n*        STM   R14,R1,@H6_Debug_Save    Save our registers\n*        WTO   '&PGMNAME - STIMERM Exit popping'\n*        LM    R14,R1,@H6_Debug_Save    Restore our registers\n\n*---------------------------------------------------------------------*\n*   We will be checking the RB chain, to verify that we are, indeed,  *\n*  in LSPACE. If the ground should shift under us while we are doing  *\n*  this, we may get an S0C4, or some such, and the CVAF ESTAE (with   *\n*  PURGE=NONE) will be scheduled, and we will hang. We therefore      *\n*  establish our PURGE=HALT ESTAE here.                               *\n*---------------------------------------------------------------------*\n*        STM   R14,R1,@H6_Debug_Save    Save our registers\n*        WTO   '&PGMNAME - STIMERM Exit - establishing ESTAE'\n*        LM    R14,R1,@H6_Debug_Save    Restore our registers\n\n         MVC   @H6_ESTAE,H6_ESTAE       Move L-Form\n         ESTAEX H06800,                 Establish ESTAE Exit           +\n               CT,                       create it                     +\n               PURGE=HALT,               terminating IO                +\n               MF=(E,@H6_ESTAE)          keeping ourselves reentrant\n\n*---------------------------------------------------------------------*\n*   Chase down the RB chain for the last RB ...                       *\n*---------------------------------------------------------------------*\n         L     R14,PSATNEW-PSA(0)       Get A(our TCB)\n         SLL   R14,8                    Clean\n         SRL   R14,8                      it\n         L     R15,TCBRBP-TCB(R14)      A(RB)\nH06010   DS    0H\n         L     R0,RBLINK-RBBASIC(R15)   A(Previous RB)\n         SLL   R0,8                     Clean\n         SRL   R0,8                       it\n         CR    R0,R14                   Last RB (RBLINK = A(TCB))?\n         JE    H06020                   Yes, skip\n         LR    R15,R0                   No, point to previous RB\n         J     H06010                   and keep trying\nH06020   DS    0H\n\n*---------------------------------------------------------------------*\n*   ... and see if it is running SVC 78 (LSPACE)                      *\n*---------------------------------------------------------------------*\n         AHI   R15,-(RBPRFXND-RBPREFIX)   Back up to RB prefix\n         CLC   =X'004E',RBINTCOD-RBPREFIX(R15) SVC 78?\n         JE    H06030                   Yes, try to terminate\n\n*        STM   R14,R1,@H6_Debug_Save    Save our registers\n*        WTO   '&PGMNAME - STIMERM Exit - not in LSPACE'\n*        LM    R14,R1,@H6_Debug_Save    Restore our registers\n\n         ESTAEX 0                       No, delete our ESTAE\n\n         RETURN (14,12),,RC=0           and return\n\nH06030   DS    0H\n\n*---------------------------------------------------------------------*\n*   LSPACE is active, and, we assume, hung up. We have already set    *\n*  up our ESTAE with PURGE=HALT, which, on an ABEND, will get control *\n*  first, after the I/O is HALTed. This ESTAE merely percolates, so   *\n*  that the CVAF and LSPACE ESTAEs can do their tricks, and we will   *\n*  eventually end up in our ESTAE, which continues processing as if   *\n*  LSPACE had failed.                                                 *\n*---------------------------------------------------------------------*\n*        STM   R14,R1,@H6_Debug_Save    Save our registers\n*        WTO   '&PGMNAME - STIMERM Exit - ABENDing U0522'\n*        LM    R14,R1,@H6_Debug_Save    Restore our registers\n\n         ICM   R9,B'1111',@H_Current_VolTbl_Ent A(VolTbl Entry)\n         JZ    H06040                   None, skup\n         OI    VolTbl_Ent_U522-VolTbl_Ent(R9),L'VolTbl_Ent_U522\nH06040   DS    0H\n         ABEND X'0522'                  and abend with U522 (get it?)\n\nH06800   DS    0H\n\n*---------------------------------------------------------------------*\n*   This is the Exit for the ESTAE established in the STIMERM exit.   *\n*  This exit does nothing, merely returning to RTM with percolate.    *\n*  It is only here because we need the first ESTAE on the queue to    *\n*  have PURGE=HALT, so the I/O to the RESERVEd volume can be          *\n*  terminated.                                                        *\n*---------------------------------------------------------------------*\n         LA    R15,0                    Percolate\n         BSM   0,R14                     on return\n\nH6_ESTAE ESTAEX 1,                      Establish ESTAE Exit           +\n               CT,                       create it                     +\n               PURGE=HALT,               PURGEing I/O                  +\n               MF=L                      keeping ourselves reentrant\nH6_ESTAE_Length EQU *-H6_ESTAE\n\n         DROP  R11,R10                  Free up temp bases\n\n         POP   USING                    Restore USING environment\n\n*********************   Start of the ESTAE   **************************\n*                                                                     *\n*                                                                     *\n         SPACE ,\nH07000   DS    0H\n         PUSH  USING                    Save the USING environment\n         DROP  ,                        Drop all current USINGs\n         SPACE ,\n*---------------------------------------------------------------------*\n*   This is the ESTAE routine. All this does is:                      *\n*    Format an abend message                                          *\n*    Invoke the retry routine                                         *\n*                                                                     *\n*   Note that we run with our own set of USINGs here.                 *\n*---------------------------------------------------------------------*\n         USING *,R15                    Assign temporary base\n         CHI   R0,12                    Is there an SDWA?\n         JE    H07010                   No, skip\n\n*---------------------------------------------------------------------*\n*   We have an SDWA, so load the appropriate registers:               *\n*      R11 --> SDWA                                                   *\n*      R1  =   Abend Code                                             *\n*      R3  --> Parmarea                                               *\n*---------------------------------------------------------------------*\n         STM   R14,R11,12(R13)          Yes, save our registers\n         LR    R11,R1                   Point to the SDWA\n         L     R1,SDWAABCC-SDWA(R11)    Get the Abend code\n         L     R3,SDWAPARM-SDWA(R11)    Point to our parm address\n         L     R3,0(0,R3)               Point to our parms\n         J     H07020                   and skip\nH07010   DS    0H\n\n*---------------------------------------------------------------------*\n*   We don't have an SDWA, so clear R11 (the SDWA address)            *\n*---------------------------------------------------------------------*\n         LA    R11,0                    Clear A(SDWA)\n\nH07020   DS    0H\n*---------------------------------------------------------------------*\n*   Load up the base for our storage, and tell the assembler.         *\n*   At this point,                                                    *\n*    R1  contains the ABEND code                                      *\n*    R3  contains the address of @H_Dynam                             *\n*    R11 contains the address of the SDWA, or 0                       *\n*---------------------------------------------------------------------*\n         LR    R12,R15                  Load a base register\n         DROP  R15                      Free up temp base\n         USING H07000,R12               Tell the assembler about R11\n         USING @H_Dynam,R3              Assign a base for our parms\n\n*---------------------------------------------------------------------*\n*   Format our ABEND message                                          *\n*---------------------------------------------------------------------*\n         ST    R1,@H_DBLWD              Save completion code\n         ICM   R9,B'1111',@H_Current_VolTbl_Ent A(VolTbl_Ent)\n         JZ    H07050                   None, skip\n         USING VolTbl_Ent,R9            Assign a base\n         OI    VolTbl_Ent_LSPACE_Fail,L'VolTbl_Ent_LSPACE_Fail No data\n         CLC   =X'0522',@H_DBLWD+2      Is this U522 (STIMER pop)?\n         J     H07050                   Yes, exit\n\n         MVC   VolTbl_Ent_ErrMsg,=CL(L'VolTbl_Ent_ErrMsg)'**SubTask ABE+\n               ND xxxx'\n         MVI   VolTbl_Ent_ErrMsg+16,C'S' Assume system abend\n         L     R15,@H_DBLWD             Get ABEND code\n         SLL   R15,8                    Clear high-order byte and\n         SRL   R15,20                    User Abend code\n         LTR   R15,R15                  Is it a system Abend?\n         JNZ   H07040                   Yes, skip\n         MVI   VolTbl_Ent_ErrMsg+16,C'U' No, User abend\n         L     R15,@H_DBLWD             Get Abend code\n         SLL   R15,20                   Clear System\n         SRL   R15,20                     Abend code\nH07040   DS    0H\n         SLL   R15,4                    Make room for 'sign'\n         STH   R15,@H_DBLWD+6           Save it\n         OI    @H_DBLWD+7,X'0F'         Make it packed\n         UNPK  VolTbl_Ent_ErrMsg+17(3),@H_DBLWD+6(2) Unpack abend code\n         LA    R15,H_TrTbl              Point to translate table\n         S     R15,=FL4'240'            Adjust pointer\n         TR    VolTbl_Ent_ErrMsg+17(3),0(R15) Make it readable\n         DROP  R9                       Free up base\n\nH07050   DS    0H\n*---------------------------------------------------------------------*\n*   We will be retrying, so we will no longer have an ESTAE. Turn off *\n*  our flag, so that the retry routine will re-establish it ...       *\n*---------------------------------------------------------------------*\n         NI    @H_ESTAE_Issued,X'FF'-L'@H_ESTAE_Issued No ESTAE now\n\n*---------------------------------------------------------------------*\n*   ... and retry, either with an SDWA ...                            *\n*---------------------------------------------------------------------*\n         LTR   R11,R11                  Is there an SDWA?\n         JZ    H07060                   No, skip SDWA retry\n         SPACE ,\n         L     R4,@H_ESTAE_Retry        Yes, A(Retry routine)\n         LA    R5,@H_ESTAE_RMask        A(Register mask)\n         SETRP WKAREA=(11),             Set retry parms using this SDWA+\n               RC=4,                     Retry                         +\n               RETADDR=(4),              using this retry routine      +\n               RETREGS=YES,              and our registers             +\n               RUB=(5),                  which live here               +\n               FRESDWA=YES,              and get rid of the SDWA       +\n               REGS=(14,12)              Return to RTM\n\nH07060   DS    0H\n*---------------------------------------------------------------------*\n*   ... or without                                                    *\n*---------------------------------------------------------------------*\n         L     R0,@H_ESTAE_Retry         A(Retry routine)\n         LM    R1,R13,@H_ESTAE_Regs+4    Restore regs\n         LA    R15,4                     Retry\n         BR    R14                       go do it\n\n\n         DROP  ,                        Drop everything\n         POP   USING                    Restore USING environment\n\n*                                                                     *\n*                                                                     *\n**********************   End of the ESTAE   ***************************\n\n\nH90010   DS    0H\n*---------------------------------------------------------------------*\n*     We have finished doing our work                                 *\n*     First, delete our ESTAE if required ...                         *\n*---------------------------------------------------------------------*\n         TM    @H_ESTAE_Issued,L'@H_ESTAE_Issued ESTAE?\n         JZ    H90020                   No, skip\n         ESTAEX 0                       Yes, delete it\n         NI    @H_ESTAE_Issued,X'FF'-L'@H_ESTAE_Issued No ESTAE now\n\nH90020   DS    0H\n*---------------------------------------------------------------------*\n*    ... free up the 24-bit stack, if appropriate ...                 *\n*---------------------------------------------------------------------*\n         ICM   R1,B'1111',@H_24Bit_Stack_Ptr A(24-bit storage)\n         JZ    H90030                   None, skip\n         SSCSTACK TERM,                 Get rid of the stack           +\n               STACK=(1)                 starting here\n\nH90030   DS    0H\n*---------------------------------------------------------------------*\n*    ... then our locat 31-bit storage                                *\n*---------------------------------------------------------------------*\n         LA    R1,@H_Dynam              A(Local storage)\n         L     R3,@H_31Bit_Stack_Ptr    A(31-bit Stack)\n\n         SSCSTACK POP,                  Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=(R3)                on this stack\n\n*-------------------------------------------------------------------*\n*    ... and the stack itself ...                                   *\n*-------------------------------------------------------------------*\n         SSCSTACK TERM,                 Free the stack                 +\n               STACK=(R3)                starting here\n\n*---------------------------------------------------------------------*\n*    ... and exit.                                                    *\n*---------------------------------------------------------------------*\n         LA    R15,0                    Clear return code\n         PR    ,                        and return to caller\n\n\nH_Literals  DS  0H\n\nH_MVC    MVC   0(0,R1),3(R15) Move LSPACE error msg\n\n         PUSH  PRINT\n         PRINT NOGEN\n\nH_LSPACE LSPACE MF=L\nH_LSPACE_Length EQU *-H_LSPACE\n\nH_ESTAE  ESTAEX 1,                      Establish ESTAE Exit           +\n               CT,                       create it                     +\n               PARAM=0,                  passing this parm             +\n               MF=L                      keeping ourselves reentrant\nH_ESTAE_Length EQU *-H_ESTAE\n\nH_STIMERM_Set STIMERM SET,              Set a timer                    +\n               MF=L                      keep ourselves reentrant\nH_STIMERM_Set_Length EQU   *-H_STIMERM_Set\n\nH_STIMERM_Cancel STIMERM CANCEL,        Cancel our timer               +\n               MF=L                      keep ourselves reentrant\nH_STIMERM_Cancel_Length EQU   *-H_STIMERM_Cancel\n\nH_TIME   TIME  LINKAGE=SYSTEM,          Get the time                   +\n               MF=L                      keep ourselves reentrant\nH_TIME_Length  EQU *-H_TIME\n\nH_SMS_Anomaly_Msg     DC C'* indicates SMS status in UCB and VTOC are i+\n               nconsistent'\n         POP   PRINT\n\nH_TrTbl DC          C'0123456789ABCDEF'\n\nH_MVC1   MVC   0(0,R1),@H_MaskArea      Move readable results\n\nH_Scale  EQU   *\n         DC    C'K'             Kilo (/10**3)\n         DC    C'M'             Mega (/10**6)\n         DC    C'G'             Giga (/10**9)\n         DC    C'T'             Tera (/10**12)\n         DC    C'P'             Peta (/10**15)\n         DC    C'E'             Eta  (/10**18)\n         DC    C'Z'             Zetta (/10**21)\n         DC    C'Y'             Yotta (/10**24)\n         DC    C'?'             Hope we never get here\n\n         LTORG\n\nH_SubTask_Hdgs        EQU   *\nH_SubTask_Hdg1        DC    C' Subtask Statistics:'\nH_SubTask_Hdg2        DC    C'  SubTask    Volume         CPU       --L+\n               SPACE OK--       -LSPACE Bad--'\nH_SubTask_Hdg3        DC    C'   Number     Count        Time        Co+\n               unt   Wait        Count   Wait'\n\nH_SubTask_Hdg_Lens    DC    AL2(L'H_SubTask_Hdg1)\n                      DC    AL2(L'H_SubTask_Hdg2)\n                      DC    AL2(L'H_SubTask_Hdg3)\nH_SubTask_Hdg_Count   EQU   (*-H_SubTask_Hdg_Lens)/2\n\n\nH_SubTask_Line        EQU   *\n                      DC    C'     '\nH_SubTask_Line_Nbr    DC    X'40202120'\n                      DC    C'   '\nH_SubTask_Line_TotVol DC    X'4020206B202120'\n                      DC    C'     '\nH_SubTask_Line_CPU    DC    X'4021204B202020'\n                      DC    C'      '\nH_SubTask_Line_Vol_OK DC    X'4020206B202120'\nH_SubTask_Line_Wait_OK DC   X'4021204B202020'\n                      DC    C'      '\nH_SubTask_Line_Vol_Bad DC   X'4020206B202120'\nH_SubTask_Line_Wait_Bad DC  X'4021204B202020'\nH_SubTask_Line_Len    EQU   *-H_SubTask_Line\n\nH_LSPACE_Msgs EQU *\n           DC    XL2'0407'\n           DC    AL1(L'H_Msg0407)\nH_Msg0407  DC    C'LSPACE-I/O TIMEOUT ERROR'\n           DC    XL2'0400'\n           DC    AL1(L'H_Msg0400)\nH_Msg0400  DC    C'LSPACE-PERMANENT I/O ERROR'\n           DC    XL2'0800'\n           DC    AL1(L'H_Msg0800)\nH_Msg0800  DC    C'LSPACE-NON_STANDARD OS VOLUME'\n           DC    XL2'0C01'\n           DC    AL1(L'H_Msg0C01)\nH_Msg0C01  DC    C'LSPACE-UCBVTOC IS ZERO'\n           DC    XL2'0C02'\n           DC    AL1(L'H_Msg0C02)\nH_Msg0C02  DC    C'LSPACE-UCB NOT READY'\n           DC    XL2'1485'\n           DC    AL1(L'H_Msg1485)\nH_Msg1485  DC    C'&PGMNAME - LSPACE ESTAE invoked'\n           DC    XL2'0000'\n           DC    AL1(L'H_Msg0000)\nH_Msg0000  DC    C'&PGMNAME - Unknown LSPACE error'\n\nH_MsgU522A DC    C'&PGMNAME - MaxLWait ('\nH_MsgU522B DC    C' secs) exceeded.'\n\nH_Literals_End  DS  0H\n\n@H_Dynam                  DSECT Dynamic storage for H00010\n                          DS    18F     O/S Save area\n@H_31Bit_Stack_Ptr        DS    AL4     A(Local 31-bit Stack)\n@H_24Bit_Stack_Ptr        DS    AL4     A(Local 24-bit Stack)\n@H_VolTbl_Ptr             DS    AL4     A(VolTbl)\n@H_LSPACE_Avg_Ptr         DS    AL4     A(Avg LSPACE Wait microsecs)\n@H_STIMERM_Adj_Ptr        DS    AL4     A(STIMERM Adjustment Factor)\n@H_Totals_Line_Ptr        DS    AL4     A(Totals Line)\n@H_Stats_Line_Ptr         DS    AL4     A(1st SubTask Title line)\n@H_SMS_Anomaly_Ptr        DS    AL4     A(SMS Anomaly Line)\n@H_MaxLWait               DS    HL2     Max LSPACE Wait time\n\n@H_Current_VolTbl_Ent     DS    AL4     A(Current VolTbl_Ent)\n\n@H_UCBTBYT4               DS    XL(L'UCBTBYT4)  UCB Type for TRKCALC\n@H_BytesPerTrack          DS    FL4     Bytes/trk, from TRKCALC\n\n@H_STIMERM_ID             DS    AL4     STIMERM Id\n@H_STIMERM_Exit_Parms_Ptr DS    AL4     A(Parms for STIMERM Exit)\n@H_STIMERM_Exit_Parms     DS    2AL4    Parms for STIMERM Exit\n                          DS    0D      Alignment\n@H_LSPACE_Wait_Max        DS    FL4     Max LSPACE Wait Time (sec)\n@H_LSPACE_Start           DS    DL8     TOD of LSPACE start\n                          ORG   @H_LSPACE_Start\n@H_LSPACE_Wait            DS    DL8     Actual LSPACE Wait time (usec)\n                          ORG   ,\n\n@H_DBLWD                  DS    D          Doubleword work area\n@H_Total_VTOCTrk          DS    DBL8\n@H_Total_DSCBs            DS    DBL8\n@H_Total_FreeDSCBs        DS    DBL8\n@H_Total_VolSize          DS    DBL8\n@H_Total_Extents          DS    DBL8\n@H_Total_FreeTracks       DS    DBL8\n@H_Total_FreeBytes        DS    DBL8\n@H_Total_FreeCyls         DS    DBL8\n@H_Total_FragIndex        DS    DBL8\n@H_Largest_FreeTracks     DS    DBL8\n@H_Largest_FreeCyls       DS    DBL8\n@H_WaitTime_Total         DS    D       Total Wait Time (in usec)\n@H_Total_Vols_Proc        DS    FL4     Nbr volumes processed\n@H_Total_Vols_OK          DS    FL4     Nbr volumes processed OK\n@H_Total_LSPACE_Wait_OK   DS    DL8     Total good LSPACE Wait (usec)\n@H_Total_LSPACE_Wait_Bad  DS    DL8     Total bad LSPACE Wait (usec)\n                          DS    0F      Alignment\n@H_ESTAE_RMask            DS    HL2     ESTAE Register Mask\n@H_ESTAE_Regs             DS    16FL4   Registers for ESTAE Retry\n@H_ESTAE_Retry            DS    AL4     A(ESTAE Retry routine)\n                          DS    X       Flag Byte\n@H_ESTAE_Issued           EQU   *-1,X'80' 1... .... ESTAE established\n@H_VolTbl_Complete        EQU   *-1,X'40' .1.. .... All VolTbl_Ents OK\n@H_OW48527                EQU   *-1,X'20' ..1. .... APAR OW48527 on\n                          ORG   ,\n\n                          DS    0F      Alignment\n@H_LSPACE                 DS    CL(H_LSPACE_Length) LSPACE Macro\n\n@H_VolSize                DS    DBL8    Volume Bytes (Used in %Free)\n@H_TotDSCB                DS    DBL8    Volume Total DSCBs\n@H_MaskArea               DS    CL8     ED Mask area\n@H_Scale                  DS    C       Scaling factor\n\n@H_Macro                  DS    0F      Alignment\n@H_ESTAE                  DS    CL(H_ESTAE_Length)  ESTAE Macro area\n                          ORG   @H_Macro\n@H6_ESTAE                 DS    CL(H6_ESTAE_Length) STIMERM Exit ESTAE\n@H6_Debug_Save            DS    4FL4    Save registers around WTOs\n                          ORG   @H_Macro\n@H_STIMERM_Set            DS    CL(H_STIMERM_Set_Length)  STIMERM\n                          ORG   @H_Macro\n@H_STIMERM_Can            DS    CL(H_STIMERM_Cancel_Length)  STIMERM\n                          ORG   @H_Macro\n@H_TIME                   DS    CL(H_TIME_Length) TIME Macro area\n                          DS    0D\n@H_TIME_Area              DS    XL16    Data returned by TIME\n                          ORG   @H_Macro\n@H_TRKCALC                TRKCALC MF=L  Track balance calcs\n                          ORG   ,\n\n@H_Parms                  DS    0F      Parms for called rtns\n@H_Parms_Std              DS    3AL4     Standard 3 parms\n@H_Parms_Extra            EQU   *        Extra parms\n                          ORG   ,\n\n                          DS    0D      Alignment\n@H_Dynam_Length           EQU   *-@H_Dynam Length of Sub-Task Dynamic\n\n&PGMNAME CSECT\n\n         DROP  ,\n\n         POP   USING                    Restore USING environment\n         TITLE 'I00010: Sort Table'\n\n         PUSH  USING\n\nI00010   DS    0H\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Subroutine: I00010                                                 *\n*                                                                     *\n*  Abstract  : Sort data in VolTbl depending on the parameters        *\n*              passed.                                                *\n*                                                                     *\n*  Inputs    : R1 : ---> A(@_Dynam)                                   *\n*                        A(31-bit Stack Pointer)                      *\n*                        A(24-bit Stack Pointer)                      *\n*                        A(8-byte name of sort field)                 *\n*                        A(1-byte containing sort direction (A/D))    *\n*  Outputs   : R15: 0                                                 *\n*                                                                     *\n*  Notes     : N/A                                                    *\n*                                                                     *\n*  History:    1990/06/11 SDDA030 - New                               *\n*              1998/09/22 SDDA030 - V2.1                              *\n*                                 - Excluded Stats lines from being   *\n*                                   sorted                            *\n*              1999/05/27 SDDA030 - V2.6                              *\n*                                 - Used LIFO Stack for our dynamic   *\n*                                   areas.                            *\n*              2000/01/19 SDDA030 - V2.11                             *\n*                                 - Received parms as pointers.       *\n*                                 - Able to sort Ascending or Descend-*\n*                                   ing.                              *\n*              2000/05/23 SDDA030 - V2.12                             *\n*                                 - Moved table of offsets from F00010*\n*                                   to here.                          *\n*              2002/03/11 SDDA030 - V2.17                             *\n*                                 - Added FREEB to table of offsets.  *\n*                                 - Pointed numeric fields to the     *\n*                                   appropriate sort fields in VolTbl.*\n*                                 - Removed sort by column nbr.       *\n*              2003/10/07 SDDA030 - V2.21                             *\n*                                 - Added VOLSIZE to table of offsets.*\n*              2006/04/21 SDDA030 - V2.24                             *\n*                                 - Used standardised calling sequence*\n*                                 - Fixed bug causing unending WAIT   *\n*                                   when STATS and SORT specified     *\n*                                 - WAIT for all detail lines to be   *\n*                                   populated before sorting (doh!)   *\n*              ____/__/__ _______                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         STM   R14,R12,12(R13)          Save callers registers\n         LARL  R11,I_Literals           Point to our literals\n         USING (I_Literals,I_Literals_End),R11 Tell the assembler\n\n         L     R12,0(0,R1)              A(@_Dynam)\n         USING @_Dynam,R12              Tell the assembler\n\n*-------------------------------------------------------------------*\n*    Get an area on the stack for our local storage                 *\n*-------------------------------------------------------------------*\n         L     R2,4(0,R1)               A(31-bit stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         SSCSTACK PUSH,                 Get stack area                 +\n               LEN=@I_Dynam_Length,      this long                     +\n               STACK=(R2)                using this stack\n\n         LR    R3,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LHI   R1,@I_Dynam_Length        Its length\n         LA    R14,0                    Clear source address\n         LA    R15,0                     and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R3                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*-------------------------------------------------------------------*\n         ST    R13,4(0,R1)              Chain\n         ST    R1,8(0,R13)               saveareas\n         LR    R13,R1                   Load dynam base\n         USING @I_Dynam,R13             Assign a base\n         L     R15,@I_Dynam+4           Get A(HSA)\n         LM    R0,R3,20(R15)            Restore callers registers\n\n         L     R15,4(0,R1)              A(31-bit Stack Pointer)\n         ST    R15,@I_31Bit_Stack_Ptr_Ptr Save it\n         L     R15,8(0,R1)              A(24-bit Stack Pointer)\n         ST    R15,@I_24Bit_Stack_Ptr_Ptr Save it\n\n\n         ICM   R9,B'1111',@_VolTbl_Ptr  A(Volume table)\n         JZ    I00100                   None, don't sort it\n         L     R10,VolTbl_Hdr_Count-VolTbl_Hdr(R9) Get nbr entries\n         CHI   R10,1                    More than 1\n         JNH   I00100                   No, skip sort\n\n         L     R14,12(0,R1)             Get A(Name of sort field)\n         LA    R15,I_TBLOFF             and A(Table of offsets)\nI00020   DS    0H\n         CLI   0(R15),C' '              End of table?\n         JE    I80010                   Yes, error (sort fld not found)\n         CLC   0(8,R14),0(R15)          Name, is it ours?\n         JE    I00030                   Yes, skip\n\n         AHI   R15,12                   No, point to next entry\n         J     I00020                   and try again\nI00030   DS    0H\n         LH    R14,8(0,R15)             Offset of sort field\n         LH    R15,10(0,R15)            Length of sort field\n\n         L     R1,@I_Dynam+4            Get A(HSA)\n         L     R1,24(0,R1)              Get original R1\n         L     R1,16(0,R1)              A(Sort direction)\n         CLI   0(R1),C'D'               Descending sort?\n         JE    I00040                   Yes, skip\n         LHI   R3,13                    No, use BNH for ascending sort\n         J     I00050                   and skip\nI00040   DS    0H\n         LHI   R3,11                    Use BNL for descending sort\nI00050   DS    0H\n         SLL   R3,4                     Put mask in high nibble\n\n         TM    VolTbl_Hdr_ECB-VolTbl_Hdr(R9),X'40' All details done?\n         JO    I00050C                  Yes, skip\n         WAIT  ECB=VolTbl_Hdr_ECB-VolTbl_Hdr(R9) No, wait for it\nI00050C  DS    0H\n\n         AHI   R9,VolTbl_Ent-VolTbl     Point to first entry\n         AHI   R10,-1                   Adjust Loop count\nI00060   DS    0H\n         TM    VolTbl_Ent_Detail_Line-VolTbl_Ent(R9),L'VolTbl_Ent_Detai+\n               l_Line\n         JNO   I00060C                  No, skip it\n         TM    VolTbl_Ent_SMS_Line-VolTbl_Ent(R9),L'VolTbl_Ent_SMS_Line\n         JNO   I00070                   True Detail line, skip\nI00060C  DS    0H\n         AHI   R9,VolTbl_Ent_Len        No, A(Next entry)\n         BRCT  R10,I00060               and check again\n         J     I00100                   Nothing, skip sort\n\nI00070   DS    0H\n         LR    R4,R9                    Get A(entry)\n         LR    R5,R10                   Get inner loop count\n         LA    R6,VolTbl_Ent_Len(0,R4)  A(Next entry)\nI00080   DS    0H\n         TM    VolTbl_Ent_Detail_Line-VolTbl_Ent(R6),L'VolTbl_Ent_Detai+\n               l_Line\n         JNO   I00090                   Skip non-detail line\n         TM    VolTbl_Ent_SMS_Line-VolTbl_Ent(R6),L'VolTbl_Ent_SMS_Line\n         JO    I00090                   Skip SMS Anomaly msg\n\n         LA    R7,0(R4,R14)             Point to\n         LA    R8,0(R6,R14)              sort fields\n         EX    R15,I0EX1                Compare entries\n         EX    R3,I0EX2                 Branch if in sequence\n\n         STM   R14,R1,@I_TempSave       Save MVCL registers\n         LA    R0,@I_WK1                A(Temporary area)\n         LHI   R1,L'@I_WK1              Its length\n         LR    R14,R4                   A(Entry out of sequence)\n         LHI   R15,VolTbl_Ent_Len       Its length\n         MVCL  R0,R14                   Save entry\n         LR    R0,R4                    A(Entry to be switched)\n         LHI   R1,VolTbl_Ent_Len        Its length\n         LR    R14,R6                   A(Entry out of sequence)\n         LHI   R15,VolTbl_Ent_Len       Its length\n         MVCL  R0,R14                   Save entry\n         LR    R0,R6                    A(Entry to be switched)\n         LHI   R1,VolTbl_Ent_Len        Its length\n         LA    R14,@I_WK1               A(Temporary area)\n         LHI   R15,L'@I_WK1             Its length\n         MVCL  R0,R14                   Save entry\n         LM    R14,R1,@I_TempSave       Restore MVCL registers\n\nI00090   DS    0H\n         AHI   R6,VolTbl_Ent_Len        A(next entry)\n         BRCT  R5,I00080                Sort all entries\n         AHI   R9,VolTbl_Ent_Len        Reset start entry nbr\n         BRCT  R10,I00060                And do it all again\n\nI00100   DS    0H\n         LA    R15,0                    Clear return code\n         J     I90010                   and exit\n\nI80010   DS    0H\n*-------------------------------------------------------------------*\n*    Sort field not found                                           *\n*-------------------------------------------------------------------*\n         LA    R15,4                    Sort failed\n         J     I90010                   and exit\n\nI90010   DS    0H\n*-------------------------------------------------------------------*\n*    Free up our local storage ...                                  *\n*-------------------------------------------------------------------*\n         LR    R3,R15                   Save return code\n\n         LA    R1,@I_Dynam              A(Local storage)\n         L     R2,@I_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         L     R13,4(0,R13)             Rescue A(HSA)\n\n         SSCSTACK POP,                  Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=(R2)                on this stack\n\n         LR    R15,R3                   Restore return code\n\n*-------------------------------------------------------------------*\n*    ... and return to caller                                       *\n*-------------------------------------------------------------------*\n         L     R14,12(0,R13)            Restore return address\n         LM    R0,R12,20(R13)           Restore other registers\n         BSM   0,R14                    and return\n\nI_Literals  DS  0H\n\nI0EX1    CLC   0(0,R7),0(R8)            Compare entries\nI0EX2    JNOP  I00090                   Set to BNH/BNL for A/D sort\n\n\n         LTORG\n\nI_TBLOFF EQU   *\n         DC    CL8'VOL'\n         DC    AL2(VolTbl_Ent_Volser-VolTbl_Ent) Start of VOL\n         DC    AL2(L'VolTbl_Ent_Volser)         Len of VOL\n\n         DC    CL8'UCB'\n         DC    AL2(VolTbl_Ent_UCBCopy+UCBCHAN-UCBOB-VolTbl_Ent) UCB\n         DC    AL2(L'UCBCHAN)                   Length of UCB\n\n         DC    CL8'DEVT'\n         DC    AL2(VolTbl_Ent_DevType-VolTbl_Ent) Start of Device Type\n         DC    AL2(L'VolTbl_Ent_DevType)        Len of Device type\n\n         DC    CL8'ATTR'\n         DC    AL2(VolTbl_Ent_Attrib-VolTbl_Ent) Start of Mnt Attr\n         DC    AL2(L'VolTbl_Ent_Attrib)         Len of Mnt Attr\n\n         DC    CL8'FREET'\n         DC    AL2(VolTbl_Ent_Sort_FreeTrk-VolTbl_Ent) Free Trk\n         DC    AL2(L'VolTbl_Ent_Sort_FreeTrk)   Len of Free Trks\n\n         DC    CL8'FREEC'\n         DC    AL2(VolTbl_Ent_Sort_FreeCyl-VolTbl_Ent) Free Cyl\n         DC    AL2(L'VolTbl_Ent_Sort_FreeCyl)   Len of Free Cyl\n\n         DC    CL8'FREEP'\n         DC    AL2(VolTbl_Ent_FreePct-VolTbl_Ent) Free % of Vol\n         DC    AL2(L'VolTbl_Ent_FreePct)        Len of Free % of Vol\n\n         DC    CL8'FREEB'\n         DC    AL2(VolTbl_Ent_Sort_FreeBytes-VolTbl_Ent) Free Bytes\n         DC    AL2(L'VolTbl_Ent_Sort_FreeBytes)   Len of Free Bytes\n\n         DC    CL8'FREEE'\n         DC    AL2(VolTbl_Ent_Sort_FreeExt-VolTbl_Ent) Nbr Extents\n         DC    AL2(L'VolTbl_Ent_Sort_FreeExt)   Len of nbr Extents\n\n         DC    CL8'LARGET'\n         DC    AL2(VolTbl_Ent_Sort_LargTrk-VolTbl_Ent) Larg Trk\n         DC    AL2(L'VolTbl_Ent_Sort_LargTrk)   Len of Larg Trks\n\n         DC    CL8'LARGEC'\n         DC    AL2(VolTbl_Ent_Sort_LargCyl-VolTbl_Ent) Larg Cyl\n         DC    AL2(L'VolTbl_Ent_Sort_LargCyl)   Len of Larg Cyl\n\n         DC    CL8'VTRK'\n         DC    AL2(VolTbl_Ent_Sort_VTOCTrk-VolTbl_Ent) VTOC Trk\n         DC    AL2(L'VolTbl_Ent_Sort_VTOCTrk)   Len of VTOC Trks\n\n         DC    CL8'VFREED'\n         DC    AL2(VolTbl_Ent_Sort_FreeDSCB-VolTbl_Ent) Free DSCBs\n         DC    AL2(L'VolTbl_Ent_Sort_FreeDSCB)  Len of Free DSCBs\n\n         DC    CL8'VFREEP'\n         DC    AL2(VolTbl_Ent_VTOCFree-VolTbl_Ent) Start of Free %\n         DC    AL2(L'VolTbl_Ent_VTOCFree)       Len of Free %\n\n         DC    CL8'VIX'\n         DC    AL2(VolTbl_Ent_VTOCIX-VolTbl_Ent) Start of VTOC IX Stat\n         DC    AL2(L'VolTbl_Ent_VTOCIX)         Len of VTOC IS Stat\n\n         DC    CL8'FRAG'\n         DC    AL2(VolTbl_Ent_Frag_Indx-VolTbl_Ent) Frag Index\n         DC    AL2(L'VolTbl_Ent_Frag_Indx)      Len of Frag Index\n\n         DC    CL8'VOLSIZE'\n         DC    AL2(VolTbl_Ent_Sort_VolSize-VolTbl_Ent) Volume size\n         DC    AL2(L'VolTbl_Ent_Sort_VolSize)   Len of volume size\n\n         DC    CL8'STORGRP'\n         DC    AL2(VolTbl_Ent_SMS_StorGrp-VolTbl_Ent) Stor Group\n         DC    AL2(L'VolTbl_Ent_SMS_StorGrp)    Len of Stor Group\n\n         DC    CL8'SMSSTAT'\n         DC    AL2(VolTbl_Ent_SMS_Status-VolTbl_Ent) SMS Status\n         DC    AL2(L'VolTbl_Ent_SMS_Status)    Len of SMS Status\n\n         DC    CL8'CHPIDS'\n         DC    AL2(VolTbl_Ent_CHPIDs-VolTbl_Ent) Start of CHPIDs\n         DC    AL2(L'VolTbl_Ent_CHPIDs)         Len of CHPIDs\n\n         DC    CL8' '\n         DC    HL2'-1'                         End of table\n         DC    AL2(0)\n\nI_Literals_End  DS  0H\n\n\n@I_Dynam                  DSECT        Dynamic area for I00000\n                          DS    18F     O/S Style save area\n@I_31Bit_Stack_Ptr_Ptr    DS    AL4     A(31-bit Stack Ptr)\n@I_24Bit_Stack_Ptr_Ptr    DS    AL4     A(24-bit Stack Ptr)\n@I_TempSave               DS    4FL4    Temporary save area (for MVCLs)\n@I_WK1                    DS    CL(VolTbl_Ent_Len) Work area\n                          DS    0D         Alignment\n@I_Dynam_Length           EQU   *-@I_Dynam  Length of storage\n\n&PGMNAME CSECT\n\n         DROP  ,\n         POP   USING\n         TITLE 'J00010: EDIF/BRIF'\n\n         PUSH  USING\n\nJ00010   DS    0H\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Subroutine: J00010                                                 *\n*                                                                     *\n*  Abstract  : EDIF/BRIF invocation and associated service routines.  *\n*                                                                     *\n*  Inputs    : R1 : ---> A(@_Dynam)                                   *\n*                        A(31-bit Stack Pointer)                      *\n*                        A(24-bit Stack Pointer)                      *\n*  Outputs   : R15 = 0                                                *\n*                                                                     *\n*  Notes     : N/A                                                    *\n*                                                                     *\n*  History:    2001/02/26 SDDA030 - V2.14                             *\n*                                 - New                               *\n*              2002/02/12 SDDA030 - V2.16                             *\n*                                 - Added pop-up panel to BRIF when   *\n*                                   SORT command entered with no or   *\n*                                   invalid operands.                 *\n*              2002/06/11 SDDA030 - V2.18                             *\n*                                   WAIT for VolTbl_Ent to be populated\n*                                   before outputting                 *\n*              2004/10/15 SDDA030 - V2.22                             *\n*                                 - Resequenced labels                *\n*              2006/04/21 SDDA030 - V2.24                             *\n*                                 - Used standardised calling sequence*\n*              ____/__/__ _______                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         STM   R14,R12,12(R13)          Save callers registers\n         LARL  R11,J_Literals           Point to our literals\n         USING (J_Literals,J_Literals_End),R11 Tell the assembler\n\n         L     R12,0(0,R1)              A(@_Dynam)\n         USING @_Dynam,R12              Tell the assembler\n\n*-------------------------------------------------------------------*\n*    Get an area on the stack for our local storage                 *\n*-------------------------------------------------------------------*\n         L     R2,4(0,R1)               A(31-bit stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         SSCSTACK PUSH,                 Get stack area                 +\n               LEN=@J_Dynam_Length,      this long                     +\n               STACK=(R2)                using this stack\n\n         LR    R3,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LHI   R1,@J_Dynam_Length        Its length\n         LA    R14,0                    Clear source address\n         LA    R15,0                     and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R3                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*-------------------------------------------------------------------*\n         ST    R13,4(0,R1)              Chain\n         ST    R1,8(0,R13)               saveareas\n         LR    R13,R1                   Load dynam base\n         USING @J_Dynam,R13             Assign a base\n         L     R15,@J_Dynam+4           Get A(HSA)\n         LM    R0,R3,20(R15)            Restore callers registers\n\n         L     R15,4(0,R1)              A(31-bit Stack Pointer)\n         ST    R15,@J_31Bit_Stack_Ptr_Ptr Save it\n         L     R15,8(0,R1)              A(24-bit Stack Pointer)\n         ST    R15,@J_24Bit_Stack_Ptr_Ptr Save it\n\n*-------------------------------------------------------------------*\n*    Set up our record length for EDIF/BRIF                         *\n*-------------------------------------------------------------------*\n         LHI   R15,VolTbl_Ent_Display_Len Max len to display\n         ST    R15,@J_ISPF_LRECL        Save it\n\n*-------------------------------------------------------------------*\n*    Set up the parms to be passed to the EDIF/BRIF routines        *\n*-------------------------------------------------------------------*\n         LA    R15,@_Dynam              A(Dynamic storage)\n         ST    R15,@J_ISPF_Rtn_Parms    Save the address\n         L     R15,@J_31Bit_Stack_Ptr_Ptr A(31-bit Stack Ptr)\n         ST    R15,@J_ISPF_Rtn_Parms+4  Save the address\n         L     R15,@J_24Bit_Stack_Ptr_Ptr A(24-bit Stack Ptr)\n         ST    R15,@J_ISPF_Rtn_Parms+8  Save the address\n         LA    R15,@J_EDIF_Prev_Rec_Nbr A(EDIF Record Number field)\n         ST    R15,@J_ISPF_Rtn_Parms+12 Save the address\n         LA    R15,@J_ISPF_Rtn_Parms    A(Parms)\n         ST    R15,@J_ISPF_Rtn_Parms_Ptr Save the address\n\n*-------------------------------------------------------------------*\n*    Set up EDIF Parms ...                                          *\n*-------------------------------------------------------------------*\n         TM    @_ISPF_EDIF,L'@_ISPF_EDIF  Do we want EDIF?\n         JZ    J00020                   No, go do BRIF\n\n         LA    R15,=CL8'EDIF'           A(EDIF)\n         ST    R15,@J_ISPF_Parms        Save it\n         LA    R15,J_Data_Name          A(Data-name)\n         ST    R15,@J_ISPF_Parms+4      Save it\n         LA    R15,=CL8'TEXT'           A(Profile name)\n         ST    R15,@J_ISPF_Parms+8      Save it\n         LA    R15,=C'F '               A(record-format)\n         ST    R15,@J_ISPF_Parms+12     Save it\n         LA    R15,@J_ISPF_LRECL        A(record length)\n         ST    R15,@J_ISPF_Parms+16     Save it\n         LA    R15,=AL4(JA0010)         A(Read Routine)\n         ST    R15,@J_ISPF_Parms+20     Save it\n         LA    R15,=AL4(JB0010)         A(Write Routine)\n         ST    R15,@J_ISPF_Parms+24     Save it\n         LA    R15,=AL4(0)              No Cmd Routine\n         ST    R15,@J_ISPF_Parms+28     Save it\n         LA    R15,@J_ISPF_Rtn_Parms_Ptr Point to routine parmlist ptr\n         ST    R15,@J_ISPF_Parms+32     Save it\n         OI    @J_ISPF_Parms+32,X'80'   Flag as last parm\n\n         XC    @J_EDIF_Prev_Rec_Nbr,@J_EDIF_Prev_Rec_Nbr\n\n         J     J00040                   Go invoke EDIF\n\nJ00020   DS    0H\n*-------------------------------------------------------------------*\n*    ... or BRIF parms ...                                          *\n*-------------------------------------------------------------------*\n         LA    R15,=CL8'BRIF'           A(BRIF)\n         ST    R15,@J_ISPF_Parms        Save it\n         LA    R15,J_Data_Name          A(Data-name)\n         ST    R15,@J_ISPF_Parms+4      Save it\n         LA    R15,=C'F '               A(record-format)\n         ST    R15,@J_ISPF_Parms+8      Save it\n         LA    R15,@J_ISPF_LRECL        A(record length)\n         ST    R15,@J_ISPF_Parms+12     Save it\n         LA    R15,=AL4(JA0010)         A(Read Routine)\n         ST    R15,@J_ISPF_Parms+16     Save it\n         LA    R15,=AL4(JC0010)         A(Cmd Routine)\n         ST    R15,@J_ISPF_Parms+20     Save it\n         LA    R15,@J_ISPF_Rtn_Parms_Ptr Point to routine parmlist ptr\n         ST    R15,@J_ISPF_Parms+24     Save it\n         OI    @J_ISPF_Parms+24,X'80'   Flag as last parm\n\n         J     J00040                   Go invoke BRIF\n\nJ00040   DS    0H\n*-------------------------------------------------------------------*\n*    ... and invoke EDIF or BRIF                                    *\n*-------------------------------------------------------------------*\n         LA    R1,@J_ISPF_Parms         A(ISPF Parms)\n         L     R15,@_ISPLINK            A(ISPF routine)\n         BASR  R14,R15                  Invoke EDIF or BRIF\n\n         LA    R15,0                    Clear return code\n         LA    R0,0                     and reason code\n         J     J90010                   and exit\n\n\nJ90010   DS    0H\n*-------------------------------------------------------------------*\n*    Free up our local storage ...                                  *\n*-------------------------------------------------------------------*\n         LA    R1,@J_Dynam              A(Local storage)\n         L     R2,@J_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         L     R13,4(0,R13)             Rescue A(HSA)\n\n         SSCSTACK POP,                  Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=(R2)                on this stack\n\n*-------------------------------------------------------------------*\n*    ... and return to caller                                       *\n*-------------------------------------------------------------------*\n         L     R14,12(0,R13)            Restore return address\n         LA    R15,0                    Clear return code\n         LM    R0,R12,20(R13)           Restore other registers\n         BSM   0,R14                    and return\n\n\nJ_Literals  DS  0H\nJ_Data_Name EQU *\n            DC C'&PGMNAME'\n            DC X'00'\n            DC C'&VERSION'\n            DC C' '\n\n         LTORG\n\nJ_Literals_End  DS  0H\n\n\n@J_Dynam                  DSECT        Dynamic area for J00000\n                          DS    18F     O/S Style save area\n@J_31Bit_Stack_Ptr_Ptr    DS    AL4     A(31-bit Stack Ptr)\n@J_24Bit_Stack_Ptr_Ptr    DS    AL4     A(24-bit Stack Ptr)\n@J_DBLWD                  DS    D       Work area\n@J_ISPF_LRECL             DS    XL4     Record length for EDIF/BRIF\n@J_EDIF_Prev_Rec_Nbr      DS    FL4     Last rec nbr passed to EDIF\n@J_ISPF_Parms             DS    9AL4    Parms for EDIF/BRIF\n@J_ISPF_Rtn_Parms_Ptr     DS    AL4     A(Parms for EDIF/BRIF Routines)\n@J_ISPF_Rtn_Parms         DS    4AL4    Parms for EDIF/BRIF Routines\n                          DS    0D      Alignment\n@J_Dynam_Length           EQU   *-@J_Dynam  Length of storage\n\n&PGMNAME CSECT\n\n         DROP  ,\n         POP   USING\n\n\n\nJA0010   DS    0H\n\n         PUSH  USING                    Save USING environment\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    EDIF/BRIF Read Routine                                         *\n*     Input: R1 ---> A(Record pointer)                              *\n*                    A(Length of record read)                       *\n*                    A(Request Code)                                *\n*                    A(Parms Ptr): A(Parms): A(@_Dynam)             *\n*                                            A(31-bit Stack Ptr)    *\n*                                            A(24-bit Stack Ptr)    *\n*                                            A(EDIF Rec Nbr fld)    *\n*                                                                   *\n*     Output: R15:  0 - Record returned                             *\n*                   8 - EOF                                         *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         BAKR  R14,0                    Save callers registers\n         LARL  R11,JA_Literals          Point to our literals\n         USING (JA_Literals,JA_Literals_End),R11 Tell the assembler\n\n         L     R12,12(0,R1)             Get A(Parmlist pointer)\n         L     R12,0(0,R12)             Get A(Parmlist)\n         L     R12,0(0,R12)             Get A(@_Dynam)\n         USING @_Dynam,R12              Assign a base\n\n*-------------------------------------------------------------------*\n*    Get an area on the stack for our local storage                 *\n*-------------------------------------------------------------------*\n         L     R2,12(0,R1)              Get A(Parmlist pointer)\n         L     R2,0(0,R2)               Get A(Parmlist)\n         L     R2,4(0,R2)               Get A(31-bit Stack Ptr)\n         L     R2,0(0,R2)               Get A(31-bit Stack)\n         SSCSTACK PUSH,                 Get stack area                 +\n               LEN=@JA_Dynam_Length,     this long                     +\n               STACK=(R2)                using this stack\n\n         LR    R3,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LHI   R1,@JA_Dynam_Length      Its length\n         LA    R14,0                    Clear source address\n         LA    R15,0                     and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R3                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*-------------------------------------------------------------------*\n         LR    R13,R1                   Load dynam base\n         USING @JA_Dynam,R13            Assign a base\n         MVC   4(4,R13),=C'F1SA'        Init save area\n\n         EREG  R0,R3                    Restore callers registers\n\n         L     R14,12(0,R1)             A(Parmlist Ptr)\n         L     R14,0(0,R14)             A(Parmlist)\n         L     R15,4(0,R14)             A(31-bit Stack Ptr)\n         ST    R15,@JA_31Bit_Stack_Ptr_Ptr Save it\n         L     R15,8(0,R14)             A(24-bit Stack Ptr)\n         ST    R15,@JA_24Bit_Stack_Ptr_Ptr Save it\n\n*-------------------------------------------------------------------*\n*    Get the record number requested (BRIF), or retrieve it from    *\n*   our variable (EDIF)                                             *\n*-------------------------------------------------------------------*\n         L     R3,8(0,R1)               Get A(record number)\n         L     R3,0(0,R3)               Get record number\n         TM    @_ISPF_BRIF,L'@_ISPF_BRIF Is this BRIF?\n         JO    JA0020                   Yes, skip\n         L     R15,12(0,R1)             No, A(Parms Ptr)\n         L     R15,0(0,R15)             A(Parms)\n         L     R15,12(0,R15)            A(Prev EDIF Record number)\n         L     R3,0(0,R15)              Prev EDIF Record number\n         AHI   R3,1                     Bump it\n         ST    R3,0(0,R15)              and save it\n\nJA0020   DS    0H\n*-------------------------------------------------------------------*\n*    Run through the table, looking for our record                  *\n*-------------------------------------------------------------------*\n         L     R9,@_VolTbl_Ptr          A(Volume Table)\n         L     R10,VolTbl_Hdr_Count-VolTbl_Hdr(R9) Nbr entries\n         AHI   R9,VolTbl_Ent-VolTbl     and point to first\n         USING VolTbl_Ent,R9            Assign a base\n         LA    R4,0                     Clear record count\nJA0030   DS    0H\n         TM    VolTbl_Ent_Heading_Line,L'VolTbl_Ent_Heading_Line A Hdg?\n         JNO   JA0040                   No, skip\n         TM    @_No_Headings,L'@_No_Headings Yes, do we want them?\n         JO    JA0090                   No, skip it\n         J     JA0070                   Yes, check it out\nJA0040   DS    0H\n         TM    VolTbl_Ent_Detail_Line,L'VolTbl_Ent_Detail_Line\n         JNO   JA0050                   No, skip\n         TM    @_No_Details,L'@_No_Details Yes, do we want them?\n         JO    JA0090                   No, skip it\n         J     JA0070                   Yes, check it out\nJA0050   DS    0H\n         TM    VolTbl_Ent_Total_Line,L'VolTbl_Ent_Total_Line\n         JNO   JA0060                   No, skip\n         TM    @_No_Totals,L'@_No_Totals Yes, do we want them?\n         JO    JA0090                   No, skip it\n         J     JA0070                   Yes, check it out\nJA0060   DS    0H\n         TM    @_Statistics,L'@_Statistics Do we want stats?\n         JNO   JA0090                   No, skip it\nJA0070   DS    0H\n         LA    R8,VolTbl_Ent            Save A(Entry)\n         AHI   R4,1                     Bump record count\n         CR    R4,R3                    Is this ours?\n         JL    JA0090                   No, skip it\n         TM    @_Statistics,L'@_Statistics Yes, Stats line?\n         JNO   JA0080                   No, skip\n         STM   R0,R1,@JA_Temp_Save      Yes, save our registers\n\n         LA    R15,@_Dynam              A(Dynamic area)\n         ST    R15,@JA_Parms_Std        Save it\n         L     R15,@JA_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)\n         ST    R15,@JA_Parms_Std+4      Save it\n         L     R15,@JA_24Bit_Stack_Ptr_Ptr A(24-bit Stack Pointer)\n         ST    R15,@JA_Parms_Std+8      Save it\n         LA    R15,VolTbl_Ent           A(Table entry)\n         ST    R15,@JA_Parms_V00010     Save it\n\n         LA    R1,@JA_Parms             Point to the parmlist\n         BRAS  R14,V00010               Process stats line\n         LM    R0,R1,@JA_Temp_Save      Restore our registers\nJA0080   DS    0H\n         TM    VolTbl_Ent_ECB,X'40'     Entry populated?\n         JO    JA0100                   Yes, OK\n         STM   R0,R1,@JA_Temp_Save      Yes, save our registers\n         WAIT  ECB=VolTbl_Ent_ECB       No, WAIT for it\n         LM    R0,R1,@JA_Temp_Save      Restore our registers\n         J     JA0100                   and skip\nJA0090   DS    0H\n         AHI   R9,VolTbl_Ent_Len        A(Next entry)\n         BRCT  R10,JA0030\n\n*-------------------------------------------------------------------*\n*    We have reached the end of the table before finding our        *\n*   record - set the EOF return code, and, if this is BRIF, the     *\n*   pointer to the last valid record, and the record number.        *\n*-------------------------------------------------------------------*\n         LA    R15,8                  EOF\n         TM    @_ISPF_EDIF,L'@_ISPF_EDIF Is this EDIF?\n         JO    JA0110                 Yes, exit\n\n         LR    R9,R8                   A(Last valid entry)\n         L     R14,8(0,R1)            A(Record count)\n         ST    R4,0(0,R14)            update it for BRIF\n         LA    R15,8                  EOF\n         J     JA0110                 and skip\n\nJA0100   DS    0H\n         LA    R15,0                    found our record\n         J     JA0110                   and skip\n\nJA0110   DS    0H\n*-------------------------------------------------------------------*\n*    ... and update the record pointer (R9).                        *\n*-------------------------------------------------------------------*\n         AHI   R9,VolTbl_Ent_Display-VolTbl_Ent   Readable bits\n\n         L     R14,0(0,R1)            A(Record pointer)\n         ST    R9,0(0,R14)            update it\n         J     JA9010                 and exit\n\nJA9010   DS    0H\n*-------------------------------------------------------------------*\n*    Free up our local storage ...                                  *\n*-------------------------------------------------------------------*\n         LR    R3,R15                 Save return code\n\n         LA    R1,@JA_Dynam             A(Local storage)\n         L     R2,@JA_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n\n         SSCSTACK POP,                  Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=(R2)                on this stack\n\n         LR    R15,R3                   Restore return code\n\n*-------------------------------------------------------------------*\n*    ... and return to caller                                       *\n*-------------------------------------------------------------------*\n         PR    ,                        and return\n\nJA_Literals  DS  0H\n\n         LTORG\n\nJA_Literals_End  DS  0H\n\n\n@JA_Dynam                 DSECT\n                          DS    18F     O/S style save area\n@JA_31Bit_Stack_Ptr_Ptr   DS    AL4     A(31-bit Stack Ptr)\n@JA_24Bit_Stack_Ptr_Ptr   DS    AL4     A(24-bit Stack Ptr)\n@JA_Temp_Save             DS    2FL4    Save area around V00010 call\n\n@JA_Parms                 DS    0F      Parms for called rtns\n@JA_Parms_Std             DS    3AL4     Standard 3 parms\n@JA_Parms_Extra           EQU   *        Extra parms\n@JA_Parms_V00010          DS    AL4         for V00010\n                          ORG   ,\n                          DS    0D\n@JA_Dynam_Length          EQU   *-@JA_Dynam\n\n\n&PGMNAME CSECT\n         DROP  ,                        Free base registers\n         POP   USING\n\n\nJB0010   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    EDIF Write Routine                                             *\n*     Input: R1 ---> A(Record pointer)                              *\n*                    A(Length of record read)                       *\n*                    A(Change Flags)                                *\n*                    A(Request Code)                                *\n*                    A(Parms Ptr): A(Parms): A(@_Dynam)             *\n*                                            A(31-bit Stack Ptr)    *\n*                                            A(24-bit Stack Ptr)    *\n*                                            A(A word for our use)  *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         PUSH  USING                    Save USING environment\n         DROP  ,                        Free base registers\n\n         BAKR  R14,0                    Save callers registers\n         LARL  R11,JB_Literals          Point to our literals\n         USING (JB_Literals,JB_Literals_End),R11 Tell the assembler\n\n         L     R12,16(0,R1)             Get A(ParmList Ptr)\n         L     R12,0(0,R12)             Get A(ParmList)\n         L     R12,0(0,R12)             Get A(@_Dynam)\n         USING @_Dynam,R12              Assign a base\n\n*-------------------------------------------------------------------*\n*    Get an area on the stack for our local storage                 *\n*-------------------------------------------------------------------*\n         L     R2,16(0,R1)              Get A(Parmlist Ptr)\n         L     R2,0(0,R2)               Get A(Parmlist)\n         L     R2,4(0,R2)               Get A(31-bit Stack Ptr)\n         L     R2,0(0,R2)               Get A(31-bit Stack)\n         SSCSTACK PUSH,                 Get stack area                 +\n               LEN=@JB_Dynam_Length,     this long                     +\n               STACK=(R2)                using this stack\n\n         LR    R3,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LHI   R1,@JB_Dynam_Length      Its length\n         LA    R14,0                    Clear source address\n         LA    R15,0                     and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R3                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*    Set up our save area, and restore the important registers      *\n*   that we have destroyed                                          *\n*-------------------------------------------------------------------*\n         LR    R13,R1                   Load dynam base\n         USING @JB_Dynam,R13            Assign a base\n         MVC   4(4,R13),=C'F1SA'        Init save area\n\n         EREG  R0,R3                    Restore callers registers\n\n         L     R14,16(0,R1)             A(Parmlist Ptr)\n         L     R14,0(0,R14)             A(Parmlist)\n         L     R15,4(0,R14)             A(31-bit Stack)\n         ST    R15,@JB_31Bit_Stack_Ptr_Ptr Save it\n         L     R15,8(0,R14)             A(24-bit Stack)\n         ST    R15,@JB_24Bit_Stack_Ptr_Ptr Save it\n\n*-------------------------------------------------------------------*\n*    If this is the last (or only) write request, set an ISPF       *\n*    message to say the data wasn't saved ...                       *\n*-------------------------------------------------------------------*\n         L     R15,12(0,R1)             A(Request code)\n         L     R15,0(0,R15)             Get it\n         CHI   R15,2                    Last write request?\n         JE    JB0020                   Yes, issue message\n         CHI   R15,3                    Maybe, Last (and only)?\n         JE    JB0020                   Yes, skip\n\n         LA    R15,0                    No, clear return code\n         J     JB9010                   and exit\n\nJB0020   DS    0H\n         LA    R15,=CL8'VDEFINE'        ISPF Function\n         ST    R15,@JB_ISPF_Parms       Save it\n         LA    R15,=CL8'CHAR'           Character variables\n         ST    R15,@JB_ISPF_Parms+12 Save it\n\n         LA    R15,=CL8'ZEDSMSG'        Variable name\n         ST    R15,@JB_ISPF_Parms+4     Save it\n         LA    R15,JB_NoSave_SMsg       Short message\n         ST    R15,@JB_ISPF_Parms+8     Save it\n         LA    R15,=AL4(L'JB_NoSave_SMsg)     Length of message\n         ST    R15,@JB_ISPF_Parms+16 Save it\n         OI    @JB_ISPF_Parms+16,X'80' Flag end of list\n         LA    R1,@JB_ISPF_Parms        A(Parmlist)\n         L     R15,@_ISPLINK            A(ISPF Interface)\n         BASR  R14,R15                  Go do it\n\n         LA    R15,=CL8'ZEDLMSG'        Variable name\n         ST    R15,@JB_ISPF_Parms+4     Save it\n         LA    R15,JB_NoSave_LMsg       Short message\n         ST    R15,@JB_ISPF_Parms+8     Save it\n         LA    R15,=AL4(L'JB_NoSave_LMsg)     Length of message\n         ST    R15,@JB_ISPF_Parms+16 Save it\n         OI    @JB_ISPF_Parms+16,X'80' Flag end of list\n         LA    R1,@JB_ISPF_Parms        A(Parmlist)\n         L     R15,@_ISPLINK            A(ISPF Interface)\n         BASR  R14,R15                  Go do it\n\n         LA    R15,=CL8'SETMSG'         Yes, ISPF Function\n         ST    R15,@JB_ISPF_Parms       Save it\n         LA    R15,=CL8'ISRZ001'        A(Message ID)\n         ST    R15,@JB_ISPF_Parms+4     Save it\n         OI    @JB_ISPF_Parms+4,X'80' Mark end of list\n         LA    R1,@JB_ISPF_Parms        Point to ISPF parms\n         L     R15,@_ISPLINK            A(Interface routine)\n         BASR  R14,R15                  Go do it\n\n*-------------------------------------------------------------------*\n*    ... and exit                                                   *\n*-------------------------------------------------------------------*\n\n         LA    R15,0                    Clear return code\n         J     JB9010                   and exit\n\nJB9010   DS    0H\n*-------------------------------------------------------------------*\n*    Free up our local storage ...                                  *\n*-------------------------------------------------------------------*\n         LR    R3,R15                 Save return code\n\n         LA    R1,@JB_Dynam             A(Local storage)\n         L     R2,@JB_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         L     R13,4(0,R13)             Rescue A(HSA)\n\n         SSCSTACK POP,                  Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=(R2)                on this stack\n\n         LR    R15,R3                   Restore return code\n\n*-------------------------------------------------------------------*\n*    ... and return to caller                                       *\n*-------------------------------------------------------------------*\n         PR    ,                        and return\n\n\nJB_Literals  DS  0H\n\nJB_NoSave_SMsg     DC   C'SAVE disabled'\nJB_NoSave_LMsg     DC   C'Use CREATE or REPLACE to save the data'\n\n         LTORG\n\nJB_Literals_End  DS  0H\n\n\n@JB_Dynam                 DSECT\n                          DS    18F     O/S style save area\n@JB_31Bit_Stack_Ptr_Ptr   DS    AL4     A(31-bit Stack Ptr)\n@JB_24Bit_Stack_Ptr_Ptr   DS    AL4     A(24-bit Stack Ptr)\n@JB_ISPF_Parms            DS    5AL4    Parm list for ISPF\n                          DS    0D\n@JB_Dynam_Length          EQU   *-@JB_Dynam\n\n\n&PGMNAME CSECT\n         DROP  ,                        Free base registers\n         POP   USING\n\n\nJC0010   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    BRIF Command Routine                                           *\n*     Input: R1 ---> A(Function Code)                               *\n*                    A(Parms Ptr): A(Parms): A(@_Dynam)             *\n*                                            A(31-bit Stack Ptr)    *\n*                                            A(24-bit Stack Ptr)    *\n*                                            A(A word for our use)  *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         PUSH  USING                    Save USING environment\n         DROP  ,                        Free base registers\n\n         BAKR  R14,0                    Save callers registers\n         LARL  R11,JC_Literals          Point to our literals\n         USING (JC_Literals,JC_Literals_End),R11 Tell the assembler\n\n         L     R12,4(0,R1)              Get A(Parmlist Ptr)\n         L     R12,0(0,R12)             Get A(ParmList)\n         L     R12,0(0,R12)             Get A(@_Dynam)\n         USING @_Dynam,R12              Assign a base\n\n*-------------------------------------------------------------------*\n*    Get an area on the stack for our local storage                 *\n*-------------------------------------------------------------------*\n         L     R2,4(0,R1)               Get A(Parmlist Ptr)\n         L     R2,0(0,R2)               Get A(Parmlist)\n         L     R2,4(0,R2)               Get A(31-bit Stack Ptr)\n         L     R2,0(0,R2)               Get A(31-bit Stack)\n         SSCSTACK PUSH,                 Get stack area                 +\n               LEN=@JC_Dynam_Length,     this long                     +\n               STACK=(R2)                using this stack\n\n         LR    R3,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LHI   R1,@JC_Dynam_Length      Its length\n         LA    R14,0                    Clear source address\n         LA    R15,0                     and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R3                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*    Set up our save area, and restore the important registers      *\n*   that we have destroyed                                          *\n*-------------------------------------------------------------------*\n         LR    R13,R1                   Load dynam base\n         USING @JC_Dynam,R13            Assign a base\n         MVC   4(4,R13),=C'F1SA'        Init save area\n\n         EREG  R0,R3                    Restore callers registers\n\n         L     R14,4(0,R1)              A(Parmlist Ptr)\n         L     R14,0(0,R14)             A(Parmlist)\n         L     R15,4(0,R14)             A(31-bit Stack)\n         ST    R15,@JC_31Bit_Stack_Ptr_Ptr Save it\n         L     R15,8(0,R14)             A(24-bit Stack)\n         ST    R15,@JC_24Bit_Stack_Ptr_Ptr Save it\n\n*-------------------------------------------------------------------*\n*    Check out the function code from BRIF ...                      *\n*-------------------------------------------------------------------*\n         L     R15,0(0,R1)              Get A(Function code)\n         L     R15,0(0,R15)             Get it\n         CHI   R15,20                   Unknown command?\n         JNE   JC0030                   No, let recursive browse work\n\n*-------------------------------------------------------------------*\n*    ... and go check it out                                        *\n*-------------------------------------------------------------------*\n         LA    R15,@_Dynam              A(Dynamic area)\n         ST    R15,@JC_Parms_Std        Save it\n         L     R15,@JC_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)\n         ST    R15,@JC_Parms_Std+4      Save it\n         L     R15,@JC_24Bit_Stack_Ptr_Ptr A(24-bit Stack Pointer)\n         ST    R15,@JC_Parms_Std+8      Save it\n\n         LA    R1,@JC_Parms             Point to the parmlist\n         BRAS  R14,L00010               Process command\n\n         TM    @_ReDisplay,L'@_ReDisplay Display mode change?\n         JO    JC0020                   Yes, set rc and exit\n         LTR   R15,R15                  Did we process the command?\n         JNZ   JC0030                   No, skip\n         LA    R15,0                    Yes, normal completion\n         J     JC9010                   and exit\n\nJC0020   DS    0H\n         LA    R15,=CL8'VDEFINE'        ISPF Function\n         ST    R15,@JC_ISPF_Parms       Save it\n         LA    R15,=CL8'ZCMD'           Variable name\n         ST    R15,@JC_ISPF_Parms+4     Save it\n         LA    R15,JC_Blanks            A(blank string)\n         ST    R15,@JC_ISPF_Parms+8     Save it\n         LA    R15,=CL8'CHAR'           Character variables\n         ST    R15,@JC_ISPF_Parms+12    Save it\n         LA    R15,=AL4(L'JC_Blanks)    Length of blank string\n         ST    R15,@JC_ISPF_Parms+16    Save it\n         OI    @JC_ISPF_Parms+16,X'80'  Flag end of list\n         LA    R1,@JC_ISPF_Parms        A(Parmlist)\n         L     R15,@_ISPLINK            A(ISPF Interface)\n         BASR  R14,R15                  Go do it\n\n         LA    R15,=CL8'VPUT'           ISPF Function\n         ST    R15,@JC_ISPF_Parms       Save it\n         LA    R15,=CL8'ZCMD'           A(Variable name)\n         ST    R15,@JC_ISPF_Parms+4     Save it\n         LA    R15,=CL8'ASIS'           A(Variable name)\n         ST    R15,@JC_ISPF_Parms+8     Save it\n         OI    @JC_ISPF_Parms+8,X'80'   Flag end of list\n         LA    R1,@JC_ISPF_Parms        A(Parmlist)\n         L     R15,@_ISPLINK            A(ISPF Interface)\n         BASR  R14,R15                  Go do it\n\n         LHI   R15,20                   Re-display requested, exit\n         J     JC9010                   and exit\n\nJC0030   DS    0H\n         LHI   R15,4                    Unknown command, let BRIF do it\n         J     JC9010                   and exit\n\nJC9010   DS    0H\n*-------------------------------------------------------------------*\n*    Free up our local storage ...                                  *\n*-------------------------------------------------------------------*\n         LR    R3,R15                 Save return code\n\n         LA    R1,@JC_Dynam             A(Local storage)\n         L     R2,@JC_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n\n         SSCSTACK POP,                  Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=(R2)                on this stack\n\n         LR    R15,R3                   Restore return code\n\n*-------------------------------------------------------------------*\n*    ... and return to caller                                       *\n*-------------------------------------------------------------------*\n         PR    ,                        and return\n\nJC_Literals  DS  0H\n\nJC_Blanks    DC  C' '\n\n         LTORG\n\nJC_Literals_End  DS  0H\n\n\n@JC_Dynam                 DSECT\n                          DS    18F     O/S style save area\n@JC_31Bit_Stack_Ptr_Ptr   DS    AL4     A(31-bit Stack Ptr)\n@JC_24Bit_Stack_Ptr_Ptr   DS    AL4     A(24-bit Stack Ptr)\n@JC_ISPF_Parms            DS    5AL4    ISPF parms\n\n@JC_Parms                 DS    0F      Parms for called rtns\n@JC_Parms_Std             DS    3AL4     Standard 3 parms\n@JC_Parms_Extra           EQU   *        Extra parms\n                          ORG   ,\n\n                          DS    0D\n@JC_Dynam_Length          EQU   *-@JC_Dynam\n\n&PGMNAME CSECT\n         DROP  ,                        Free base registers\n         POP   USING\n         TITLE 'K00010: ISPF(S) Display'\n\n         PUSH  USING\n\nK00010   DS    0H\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Routine   : K00010                                                 *\n*                                                                     *\n*  Abstract  : Display the results via the ISPF SPACE Panel           *\n*                                                                     *\n*  Inputs    : R1 : ---> A(@_Dynam)                                   *\n*                        A(31-bit Stack Pointer)                      *\n*                        A(24-bit Stack Pointer)                      *\n*  Outputs   : R15: 0: OK                                             *\n*                   4: Panel not found                                *\n*                                                                     *\n*  Notes     :                                                        *\n*                                                                     *\n*  History:    2002/02/12 SDDA030 - V2.16                             *\n*                                 - New (originally part of G00010)   *\n*                                 - Used Dynamic displays (rather than*\n*                                   TBDISPL) for ISPF(S).             *\n*                                 - Added LEFT/RIGHT processing for   *\n*                                   ISPF(S).                          *\n*                                 - Added sort prompt pop-up panel in *\n*                                   ISPF(B).                          *\n*              2002/06/11 SDDA030 - V2.18                             *\n*                                   WAIT for VolTbl_Ent to be populated\n*                                   before outputting                 *\n*              2004/10/15 SDDA030 - V2.22                             *\n*                                 - Resequenced labels                *\n*              2006/04/21 SDDA030 - V2.24                             *\n*                                 - Added code to display number when *\n*                                   cursor on numeric fld, and ENTER. *\n*                                 - Used standardised calling sequence*\n*                                 - Changed 'Line x of y' to 'Line x'.*\n*              ____/__/__ _______                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         STM   R14,R12,12(R13)          Save callers registers\n         LARL  R11,K_Literals           Point to our literals\n         USING (K_Literals,K_Literals_End),R11 Tell the assembler\n\n         L     R12,0(0,R1)              A(@_Dynam)\n         USING @_Dynam,R12              Tell the assembler\n\n*-------------------------------------------------------------------*\n*    Get an area on the stack for our local storage                 *\n*-------------------------------------------------------------------*\n         L     R2,4(0,R1)               A(31-bit stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         SSCSTACK PUSH,                 Get stack area                 +\n               LEN=@K_Dynam_Length,      this long                     +\n               STACK=(R2)                using this stack\n\n         LR    R3,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LHI   R1,@K_Dynam_Length        Its length\n         LA    R14,0                    Clear source address\n         LA    R15,0                     and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R3                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*-------------------------------------------------------------------*\n         ST    R13,4(0,R1)              Chain\n         ST    R1,8(0,R13)               saveareas\n         LR    R13,R1                   Load dynam base\n         USING @K_Dynam,R13             Assign a base\n         L     R15,@K_Dynam+4           Get A(HSA)\n         LM    R0,R3,20(R15)            Restore callers registers\n\n         L     R15,4(0,R1)              A(31-bit Stack Pointer)\n         ST    R15,@K_31Bit_Stack_Ptr_Ptr Save it\n         L     R15,8(0,R1)              A(24-bit Stack Pointer)\n         ST    R15,@K_24Bit_Stack_Ptr_Ptr Save it\n\n*--------------------------------------------------------------------*\n*   Initialize our standard parmlist                                 *\n*--------------------------------------------------------------------*\n         LA    R15,@_Dynam              A(Dynamic area)\n         ST    R15,@K_Parms_Std         Save it\n         L     R15,@K_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)\n         ST    R15,@K_Parms_Std+4       Save it\n         L     R15,@K_24Bit_Stack_Ptr_Ptr A(24-bit Stack Pointer)\n         ST    R15,@K_Parms_Std+8       Save it\n\n*-------------------------------------------------------------------*\n*    Check to see that our panel exists, and that it has an         *\n*   appropriate Dynamic area in it.                                 *\n*-------------------------------------------------------------------*\n         LA    R15,=CL8'VDEFINE'        ISPF Function\n         ST    R15,@K_ISPF_Parms        Save it\n         LA    R15,K_ISPF_PQUERY_Names  A(Variable names)\n         ST    R15,@K_ISPF_Parms+4      Save it\n         LA    R15,@K_ISPF_PQUERY_Values A(Variable storage)\n         ST    R15,@K_ISPF_Parms+8      Save it\n         LA    R15,K_ISPF_PQUERY_Types  A(Variable types)\n         ST    R15,@K_ISPF_Parms+12     Save it\n         LA    R15,K_ISPF_PQUERY_Lens   A(Variable lengths)\n         ST    R15,@K_ISPF_Parms+16     Save it\n         LA    R15,=CL8'LIST'           Variable types\n         ST    R15,@K_ISPF_Parms+20     Save it\n         OI    @K_ISPF_Parms+20,X'80'   Flag last parm\n         LA    R1,@K_ISPF_Parms         A(ISPF Parms)\n         L     R15,@_ISPLINK            A(ISPF routine)\n         BASR  R14,R15                  Go check out panel\n\n         LA    R15,=CL8'PQUERY'         ISPF Function\n         ST    R15,@K_ISPF_Parms        Save it\n         LA    R15,=CL8'&PNLNAME'       A(Panel name)\n         ST    R15,@K_ISPF_Parms+4      Save it\n         LA    R15,=CL8'DATA    '       A(Area name)\n         ST    R15,@K_ISPF_Parms+8      Save it\n         LA    R15,K_SPCDYNTY           A(Area Type variable name)\n         ST    R15,@K_ISPF_Parms+12     Save it\n         LA    R15,K_SPCDYNWI           A(Width variable name)\n         ST    R15,@K_ISPF_Parms+16     Save it\n         LA    R15,K_SPCDYNDE           A(Depth variable name)\n         ST    R15,@K_ISPF_Parms+20     Save it\n         LA    R15,K_SPCDYNRO           A(Starting Row Number name)\n         ST    R15,@K_ISPF_Parms+24     Save it\n         LA    R15,K_SPCDYNCO           A(Starting Column number name)\n         ST    R15,@K_ISPF_Parms+28     Save it\n         OI    @K_ISPF_Parms+28,X'80'   Flag last parm\n         LA    R1,@K_ISPF_Parms         A(ISPF Parms)\n         L     R15,@_ISPLINK            A(ISPF routine)\n         BASR  R14,R15                  Go check out panel\n         LTR   R15,R15                  All OK?\n         JNZ   K80010                   No, error and exit\n\n         CLC   =CL8'DYNAMIC',@K_ISPF_SPCDYNTN_Value  Dynamic?\n         JNE   K80010                   No, error and exit\n         ICM   R15,B'1111',@K_ISPF_SPCDYNWI_Value  Width OK?\n         JZ    K80010                   No, error and exit\n         ST    R15,@K_ISPF_Dyn_Area_Width Yes, save it\n         ICM   R15,B'1111',@K_ISPF_SPCDYNDE_Value  Depth OK?\n         JZ    K80010                   No, error and exit\n         ST    R15,@K_ISPF_Dyn_Area_Depth Yes, save it\n         ICM   R15,B'1111',@K_ISPF_SPCDYNRO_Value  Starting Row OK?\n         JZ    K80010                   No, error and exit\n         AHI   R15,-1                   Yes, relative to 0\n         ST    R15,@K_ISPF_Dyn_Area_Row and save it\n         ICM   R15,B'1111',@K_ISPF_SPCDYNCO_Value  Starting column OK?\n         JZ    K80010                   No, error and exit\n         AHI   R15,-1                   Yes, relative to 0\n         ST    R15,@K_ISPF_Dyn_Area_Column and save it\n\n*---------------------------------------------------------------------*\n*     The panel seems OK, get some storage for the Dynamic Area ...   *\n*---------------------------------------------------------------------*\n         L     R1,@K_ISPF_Dyn_Area_Width Get area width\n         M     R0,@K_ISPF_Dyn_Area_Depth Get total length\n\n         ST    R1,@K_ISPF_Dyn_Area_Len  Save it\n         LR    R0,R1                    in proper register\n\n         L     R2,@K_31Bit_Stack_Ptr_Ptr A(31-bit stack Ptr)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         SSCSTACK PUSH,                 Get stack area                 +\n               LEN=(0),                  this long                     +\n               STACK=(R2)                using this stack\n\n         ST    R1,@K_ISPF_Dyn_Area_Ptr  Save A(Our storage)\n\n*---------------------------------------------------------------------*\n*     ... define it to ISPF ...                                       *\n*---------------------------------------------------------------------*\n         LA    R15,=CL8'VDEFINE'        ISPF Function\n         ST    R15,@K_ISPF_Parms        Save it\n         LA    R15,=CL8'DATA'           Variable name\n         ST    R15,@K_ISPF_Parms+4      Save it\n         L     R15,@K_ISPF_Dyn_Area_Ptr Point to it\n         ST    R15,@K_ISPF_Parms+8      Save it\n         LA    R15,=CL8'CHAR'           Character data\n         ST    R15,@K_ISPF_Parms+12     Save it\n         L     R15,@K_ISPF_Dyn_Area_Len Length of diaplay area\n         ST    R15,@K_ISPF_Parms+20     Save it\n         LA    R15,@K_ISPF_Parms+20     Point to it\n         ST    R15,@K_ISPF_Parms+16     Save it\n         OI    @K_ISPF_Parms+16,X'80'   Flag end of list\n         LA    R1,@K_ISPF_Parms         A(Parmlist)\n         L     R15,@_ISPLINK            A(ISPF Interface)\n         BASR  R14,R15                  Go do it\n\n*---------------------------------------------------------------------*\n*     ... and init some variables.                                    *\n*---------------------------------------------------------------------*\n         LA    R15,VolTbl_Ent_DevType-VolTbl_Ent_Display Set our\n         ST    R15,@K_VolTbl_Ent_Offset  offset\n\n         LA    R15,0                    Current top of display\n         ST    R15,@K_VolTbl_Ent_Display_Line Save it\n\n         LHI   R15,VolTbl_Ent_Display_Len Get max display len\n         S     R15,@K_ISPF_Dyn_Area_Width  Max offset within display\n         A     R15,=AL4(VolTbl_Ent_DevType-VolTbl_Ent_Display)\n         ST    R15,@K_VolTbl_Ent_Offset_Max Save it\n\n         L     R15,@_VolTbl_Ptr         A(Volume Table)\n         L     R15,VolTbl_Hdr_Count-VolTbl_Hdr(R15) Get nbr entries\n         ST    R15,@K_VolTbl_Ent_Display_Line_Max Save it\n\n         LA    R15,0                    Number of heading lines\n         ST    R15,@K_ISPF_Dyn_Area_Hdg_Lines and save it\n         ST    R15,@K_VolTbl_Hdg_Lines  here too\n\n         MVC   @K_VolTbl_Ent_Display_Line_Prev,=FL4'-1' Force the area\n         MVC   @K_VolTbl_Ent_Offset_Prev,=FL4'-1'  to be populated\n\n*---------------------------------------------------------------------*\n*     Set the EX length of each line of data to be copied to the      *\n*    dynamic area                                                     *\n*---------------------------------------------------------------------*\n         L     R15,@K_ISPF_Dyn_Area_Width Get area width\n         S     R15,=AL4(VolTbl_Ent_DevType-VolTbl_Ent_Display) Len\n         AHI   R15,-1                   EX length of data\n         ST    R15,@K_VolTbl_Ent_MVC_Len Save it\n\n*---------------------------------------------------------------------*\n*   Produce Heading 0, if required ...                                *\n*---------------------------------------------------------------------*\n         TM    @_No_Headings,L'@_No_Headings  Headings wanted?\n         JO    K00050                   No, skip\n\n         LA    R15,=CL8'VDEFINE'        ISPF Function\n         ST    R15,@K_ISPF_Parms        Save it\n         LA    R15,=CL8'HDG0'           Point to variable name\n         ST    R15,@K_ISPF_Parms+4      Save it\n         L     R15,@_VolTbl_Ptr         A(Volume Table)\n         LA    R15,VolTbl_Ent-VolTbl(R15) Point to first heading\n         LA    R15,VolTbl_Ent_Display-VolTbl_Ent(R15) Readable data\n         ST    R15,@K_ISPF_Parms+8      Save it\n         LA    R15,=CL8'CHAR'           Character variables\n         ST    R15,@K_ISPF_Parms+12     Save it\n         LHI   R15,VolTbl_Ent_Display_Len Get max display len\n         ST    R15,@K_DBLWD             Save it\n         LA    R15,@K_DBLWD             A(record length)\n         ST    R15,@K_ISPF_Parms+16     Save it\n         OI    @K_ISPF_Parms+16,X'80'   Flag end of list\n         LA    R1,@K_ISPF_Parms         A(Parmlist)\n         L     R15,@_ISPLINK            A(ISPF Interface)\n         BASR  R14,R15                  Go do it\n\n*---------------------------------------------------------------------*\n*   ... and count the number of heading lines in the table.           *\n*---------------------------------------------------------------------*\n         LA    R14,0                    Nbr hdg lines in VolTbl\n         LA    R15,0                    Nbr hdg lines in ISPF area\n\n         L     R9,@_VolTbl_Ptr          A(Volume Table)\n         L     R10,VolTbl_Hdr_Count-VolTbl_Hdr(R9) Get nbr entries\n         AHI   R9,VolTbl_Ent-VolTbl     Point to first entry\n         USING VolTbl_Ent,R9            and assign a base\nK00020   DS    0H\n         TM    VolTbl_Ent_Heading_Line1,L'VolTbl_Ent_Heading_Line1\n         JO    K00030                   Yes, skip\n         TM    VolTbl_Ent_Heading_Line,L'VolTbl_Ent_Heading_Line\n         JNO   K00040                   Not a hdg line, all done\n         AHI   R15,1                    Bump hdgs in ISPF area\nK00030   DS    0H\n         AHI   R14,1                    Bump hdgs in VolTbl\n\n         AHI   R9,VolTbl_Ent_Len        A(Next entry)\n         BRCT  R10,K00020               and continue\n\n         DROP  R9                       Free VolTbl_Ent base\nK00040   DS    0H\n         C     R15,@K_ISPF_Dyn_Area_Depth Is Dyn Area deep enough?\n         JNL   K80010                   No, use BRIF instead\n\n         ST    R15,@K_ISPF_Dyn_Area_Hdg_Lines Save it\n         ST    R14,@K_VolTbl_Hdg_Lines  Save nbr hdgs in VolTbl\n\n         L     R15,@K_VolTbl_Ent_Display_Line_Max Get max display line\n         S     R15,@K_ISPF_Dyn_Area_Hdg_Lines Adjust for heading lines\n         ST    R15,@K_VolTbl_Ent_Display_Line_Max Save it\n\nK00050   DS    0H\n*---------------------------------------------------------------------*\n*    VDEFINE FLIN, used in the 'Line x' display                       *\n*---------------------------------------------------------------------*\n         LA    R15,=CL8'VDEFINE'        ISPF Function\n         ST    R15,@K_ISPF_Parms        Save it\n         LA    R15,=CL8'FLIN'           Variable name (Curr line nbr)\n         ST    R15,@K_ISPF_Parms+4      Save it\n         LA    R15,@K_FLIN              Point to it\n         ST    R15,@K_ISPF_Parms+8      Save it\n         LA    R15,=CL8'CHAR'           Character data\n         ST    R15,@K_ISPF_Parms+12     Save it\n         LA    R15,L'@K_FLIN            Length of variable\n         ST    R15,@K_ISPF_Parms+20     Save it\n         LA    R15,@K_ISPF_Parms+20     Point to it\n         ST    R15,@K_ISPF_Parms+16     Save it\n         OI    @K_ISPF_Parms+16,X'80'   Flag end of list\n         LA    R1,@K_ISPF_Parms         A(Parmlist)\n         L     R15,@_ISPLINK            A(ISPF Interface)\n         BASR  R14,R15                  Go do it\n\nK00060   DS    0H\n*---------------------------------------------------------------------*\n*         Populate the table.                                         *\n*                                                                     *\n*     Verify that the display line and offset are within our limits.  *\n*    Note that @K_VolTbl_Ent_Display_Line is relative to the 1st      *\n*    non-heading line in VolTbl.                                      *\n*    If they aren't, adjust them.                                     *\n*---------------------------------------------------------------------*\n         ICM   R15,B'1111',@K_VolTbl_Ent_Display_Line Get line nbr\n         JNM   K00070                       0 or greater, OK\n         LA    R15,0                        Fix it\nK00070   DS    0H\n         C     R15,@K_VolTbl_Ent_Display_Line_Max Too big?\n         JNH   K00080                       No, OK\n         L     R15,@K_VolTbl_Ent_Display_Line_Max Yes, reset it\nK00080   DS    0H\n         ST    R15,@K_VolTbl_Ent_Display_Line Save it\n\n         L     R15,@K_VolTbl_Ent_Offset     Get offset\n         C     R15,=AL4(VolTbl_Ent_DevType-VolTbl_Ent_Display) small?\n         JNL   K00090                       No, OK\n         L     R15,=AL4(VolTbl_Ent_DevType-VolTbl_Ent_Display)\nK00090   DS    0H\n         C     R15,@K_VolTbl_Ent_Offset_Max Too big?\n         JNH   K00100                   No, OK\n         L     R15,@K_VolTbl_Ent_Offset_Max Yes, reset it\nK00100   DS    0H\n         ST    R15,@K_VolTbl_Ent_Offset Save it\n\n*---------------------------------------------------------------------*\n*     If the display line and the offset have not changed, we can     *\n*    just redisplay                                                   *\n*---------------------------------------------------------------------*\n         CLC   @K_VolTbl_Ent_Display_Line_Prev,@K_VolTbl_Ent_Display_Li+\n               ne\n         JNE   K00110                   Display line changed\n         CLC   @K_VolTbl_Ent_Offset_Prev,@K_VolTbl_Ent_Offset\n         JE    K00260                   Nothing changed, skip\n\nK00110   DS    0H\n*---------------------------------------------------------------------*\n*     If we need to re-generate the headings (because of a LEFT/RIGHT *\n*    scroll), do it now                                               *\n*---------------------------------------------------------------------*\n         TM    @_No_Headings,L'@_No_Headings  Are we doing headings?\n         JO    K00140                   No, skip\n         L     R15,@K_VolTbl_Ent_Offset Yes, get offset\n         C     R15,@K_VolTbl_Ent_Offset_Prev Same as last time?\n         JE    K00140                   Yes, skip\n\n         L     R3,@K_ISPF_Dyn_Area_Ptr  A(data for dynamic area)\n\n         L     R9,@_VolTbl_Ptr          A(Volume Table)\n         L     R10,VolTbl_Hdr_Count-VolTbl_Hdr(R9) Get nbr entries\n         AHI   R9,VolTbl_Ent-VolTbl     Point to first entry\n         USING VolTbl_Ent,R9            and assign a base\n\nK00120   DS    0H\n         TM    VolTbl_Ent_Heading_Line1,L'VolTbl_Ent_Heading_Line1\n         JO    K00130                   Heading 0, skip\n         TM    VolTbl_Ent_Heading_Line,L'VolTbl_Ent_Heading_Line\n         JZ    K00140                   Not a heading line, skip\n\n         MVC   0(VolTbl_Ent_DevType-VolTbl_Ent_Display,R3),VolTbl_Ent_D+\n               isplay\n         LA    R1,VolTbl_Ent_DevType-VolTbl_Ent_Display(0,R3)\n         LA    R15,VolTbl_Ent_Display   A(Start of source)\n         A     R15,@K_VolTbl_Ent_Offset A(Start of our data)\n         L     R14,@K_VolTbl_Ent_MVC_Len EX len of data to be moved\n         EX    R14,K_MVC                Move the data\n         A     R3,@K_ISPF_Dyn_Area_Width A(Next output area pointer)\n\nK00130   DS    0H\n         AHI   R9,VolTbl_Ent_Len        A(Next entry)\n         BRCT  R10,K00120               and continue\n\nK00140   DS    0H\n*--------------------------------------------------------------------*\n*     Calculate the address of the 1st line of data in the dynamic   *\n*    area                                                            *\n*--------------------------------------------------------------------*\n         L     R15,@K_ISPF_Dyn_Area_Hdg_Lines Nbr heading lines\n         M     R14,@K_ISPF_Dyn_Area_Width times length of line\n         A     R15,@K_ISPF_Dyn_Area_Ptr Point to  it\n         LR    R3,R15                   with the proper register\n\n*--------------------------------------------------------------------*\n*     If we are at the top of the table, insert our 'Top of Data'    *\n*    line.                                                           *\n*--------------------------------------------------------------------*\n         ICM   R15,B'1111',@K_VolTbl_Ent_Display_Line Curr display line\n         JNZ   K00150                   Not at top, skip\n\n         MVI   0(R3),C'*'               A line of asterisks\n         LR    R15,R3                   Point to it\n         LA    R1,1(0,R3)               A(Target area\n         L     R14,@K_ISPF_Dyn_Area_Width Get width\n         AHI   R14,2                    EX Length\n         EX    R14,K_MVC                All asterisks\n\n         L     R14,@K_ISPF_Dyn_Area_Width Get width\n         LA    R15,13                   Length of literal\n         SR    R14,R15                  Center our\n         SRL   R14,1                     message\n         LA    R1,0(R3,R14)             Point to start\n         S     R1,=FL4'1'                of output area\n         LA    R14,13                   Length of literal\n         AHI   R14,-1                   EX length\n         LA    R15,=CL13' Top of data ' A(Literal)\n         EX    R14,K_MVC                Move top of data text\n\n         A     R3,@K_ISPF_Dyn_Area_Width Bump output pointer\n         L     R15,@K_ISPF_Dyn_Area_Ptr Calculate\n         A     R15,@K_ISPF_Dyn_Area_Len  Dyn area max\n         CR    R3,R15                   Filled it up?\n         JNL   K00260                  Yes, go display\n\nK00150   DS    0H\n*--------------------------------------------------------------------*\n*     Point to the 1st VolTbl_Ent line to be output ...              *\n*--------------------------------------------------------------------*\n         ICM   R4,B'1111',@K_VolTbl_Ent_Display_Line Get line number\n         L     R5,=FL4'-1'              Clear entry counter\n\n         L     R15,@K_VolTbl_Hdg_Lines   Nbr hdg lines in VolTbl\n         MHI   R15,VolTbl_Ent_Len        * length of 1 entry\n\n         L     R9,@_VolTbl_Ptr          A(Volume Table)\n         L     R10,VolTbl_Hdr_Count-VolTbl_Hdr(R9) Get nbr entries\n         AHI   R9,VolTbl_Ent-VolTbl     Point to first entry\n         AR    R9,R15                   Point to our entry\n         S     R10,@K_VolTbl_Hdg_Lines  Nbr lines left in table\n         JNP   K00250                   None, skip\n\nK00170   DS    0H\n*--------------------------------------------------------------------*\n*     Find the entry (we count in R5) that corresponds to the        *\n*    entry we want (in R4)                                           *\n*--------------------------------------------------------------------*\n         TM    VolTbl_Ent_Detail_Line,L'VolTbl_Ent_Detail_Line Detail?\n         JNO   K00180                   No, skip\n         TM    @_No_Details,L'@_No_Details Yes, do we want it?\n         JO    K00240                   No, skip it\n         J     K00200                   Yes, process it\nK00180   DS    0H\n\n         TM    VolTbl_Ent_Total_Line,L'VolTbl_Ent_Total_Line Detail?\n         JNO   K00190                   No, skip\n         TM    @_No_Totals,L'@_No_Totals Yes, do we want it?\n         JO    K00240                   No, skip it\n         J     K00200                   Yes, process it\nK00190   DS    0H\n         TM    @_Statistics,L'@_Statistics Do we want stats?\n         JNO   K00240                   No, skip it\n\n         LA    R15,VolTbl_Ent           A(Table entry)\n         ST    R15,@K_Parms_V00010      Save it\n\n         LA    R1,@K_Parms              A(Parm list)\n         BRAS  R14,V00010               Go process stats line\nK00200   DS    0H\n         AHI   R5,1                     Bump counter\n         CR    R4,R5                    Ours?\n         JH    K00240                   Not yet, skip\n         TM    VolTbl_Ent_ECB,X'40'     Is it populated?\n         JO    K00210                   Yes, OK\n         WAIT  ECB=VolTbl_Ent_ECB       No, WAIT for it\n\nK00210 DS     0H\n*--------------------------------------------------------------------*\n*     Move the VolTbl_Ent data to the dynamic display area.          *\n*--------------------------------------------------------------------*\n         TM    VolTbl_Ent_Stats_Line,L'VolTbl_Ent_Stats_Line Stats?\n         JNO   K00220                   No, OK\n\n         LR    R1,R3                    A(Target area)\n         LA    R15,VolTbl_Ent_Display   A(Source)\n         S     R15,=AL4(VolTbl_Ent_DevType-VolTbl_Ent_Display)\n         A     R15,@K_VolTbl_Ent_Offset Plus offset\n         L     R14,@K_ISPF_Dyn_Area_Width Get length to move\n         AHI   R14,-1                   EX length\n         EX    R14,K_MVC                Move the data\n         J     K00230                   and skip\n\nK00220   DS    0H\n         MVC   0(VolTbl_Ent_DevType-VolTbl_Ent_Display,R3),VolTbl_Ent_D+\n               isplay\n         LA    R1,VolTbl_Ent_DevType-VolTbl_Ent_Display(0,R3) A(Target)\n         LA    R15,VolTbl_Ent_Display   A(Start of source)\n         A     R15,@K_VolTbl_Ent_Offset A(Start of our data)\n         L     R14,@K_VolTbl_Ent_MVC_Len EX len of data to be moved\n         EX    R14,K_MVC                Move the data\n\nK00230   DS    0H\n*--------------------------------------------------------------------*\n*     Bump the output pointer, and, if there is still room, ...      *\n*--------------------------------------------------------------------*\n         A     R3,@K_ISPF_Dyn_Area_Width Bump output pointer\n         L     R15,@K_ISPF_Dyn_Area_Ptr Calculate\n         A     R15,@K_ISPF_Dyn_Area_Len  Dyn area max\n         CR    R3,R15                   Filled it up?\n         JNL   K00260                  Yes, go display\n\nK00240   DS    0H\n*--------------------------------------------------------------------*\n*     ... process the next entry                                     *\n*--------------------------------------------------------------------*\n         AHI   R9,VolTbl_Ent_Len        A(Next entry)\n         BRCT  R10,K00170               and continue\n\nK00250   DS    0H\n*--------------------------------------------------------------------*\n*     Add our 'Bottom of data' line.                                 *\n*--------------------------------------------------------------------*\n         MVI   0(R3),C'*'               A line of asterisks\n         LR    R15,R3                   Point to it\n         LA    R1,1(0,R3)               A(Target area\n         L     R14,@K_ISPF_Dyn_Area_Width Get width\n         AHI   R14,-2                   EX len\n         EX    R14,K_MVC                All asterisks\n\n         L     R14,@K_ISPF_Dyn_Area_Width Get width\n         LA    R15,16                   Length of literal\n         SR    R14,R15                  Center our\n         SRL   R14,1                     message\n         LA    R1,0(R3,R14)             Point to start\n         S     R1,=FL4'1'                of output area\n         LA    R14,16                   Length of literal\n         AHI   R14,-1                   EX length\n         LA    R15,=CL16' Bottom of data ' A(Literal)\n         EX    R14,K_MVC                Move bottom of data text\n\n*--------------------------------------------------------------------*\n*     And clear out the rest of the display area                     *\n*--------------------------------------------------------------------*\n         A     R3,@K_ISPF_Dyn_Area_Width Bump output pointer\n         L     R15,@K_ISPF_Dyn_Area_Ptr Calculate\n         A     R15,@K_ISPF_Dyn_Area_Len  Dyn area max\n         CR    R3,R15                   Filled it up?\n         JNL   K00260                  Yes, go display\n\n         LR    R0,R3                    No, A(Start of area to clear)\n         LR    R1,R15                   Calculate length\n         SR    R1,R0                     to clear\n         LA    R14,0                    No sending address\n         LA    R15,C' '                 Pad character\n         SLL   R15,24                    of blank\n         MVCL  R0,R14                   Clear remainder if dynamic area\n\nK00260   DS    0H\n*--------------------------------------------------------------------*\n*     Save the current start line and offset ...                     *\n*--------------------------------------------------------------------*\n         MVC   @K_VolTbl_Ent_Display_Line_Prev,@K_VolTbl_Ent_Display_Li+\n               ne\n         MVC   @K_VolTbl_Ent_Offset_Prev,@K_VolTbl_Ent_Offset\n\n*--------------------------------------------------------------------*\n*     ... fill in the variable containing the 1st line number ...    *\n*--------------------------------------------------------------------*\n         L     R15,@K_VolTbl_Ent_Display_Line Get FLIN\n         AHI   R15,1                    Relative to 1\n         CVD   R15,@K_DBLWD             Pack it\n         MVC   @K_FLIN-1(L'@K_FLIN+1),=X'402020202120'  Move mask\n         ED    @K_FLIN-1(L'@K_FLIN+1),@K_DBLWD+5\n\n*--------------------------------------------------------------------*\n*     ... and display our panel                                      *\n*--------------------------------------------------------------------*\n         LA    R15,=CL8'DISPLAY'        ISPF Function\n         ST    R15,@K_ISPF_Parms        Save it\n         LA    R15,=CL8'&PNLNAME'       A(Panel name)\n         ST    R15,@K_ISPF_Parms+4      Save it\n         OI    @K_ISPF_Parms+4,X'80'    Flag last parm\n         LA    R1,@K_ISPF_Parms         A(ISPF Parms)\n         L     R15,@_ISPLINK            A(ISPF routine)\n         BASR  R14,R15                  Go display table\n         CHI   R15,8                    END or RETURN?\n         JNL   K00720                   Yes, just get out\n\n*--------------------------------------------------------------------*\n*     If the user entered CANCEL, we are done.                       *\n*--------------------------------------------------------------------*\n         LA    R15,=CL8'VCOPY'          ISPF Function\n         ST    R15,@K_ISPF_Parms        Save it\n         LA    R15,=CL8'ZCMD'           Variable we want\n         ST    R15,@K_ISPF_Parms+4      Save it\n         LA    R15,@K_ISPF_VCOPY_Lens   A(Length Address)\n         ST    R15,@K_ISPF_Parms+8      Save it\n         LA    R15,@K_ISPF_VCOPY_Ptrs   A(Variable)\n         ST    R15,@K_ISPF_Parms+12     Save it\n         OI    @K_ISPF_Parms+12,X'80'   Flag last parm\n         LA    R1,@K_ISPF_Parms         A(ISPF Parms)\n         L     R15,@_ISPLINK            A(ISPF routine)\n         BASR  R14,R15                  Go get the variable\n\n         LTR   R15,R15                  Did we get it?\n         JNZ   K00300                   No, skip check for CANCEL\n\n         ICM   R14,B'1111',@K_ISPF_VCOPY_Var_Len Get ZCMD length\n         JZ    K00300                   Nothing, skip\n         CHI   R14,3                    Could it be CANcel?\n         JL    K00270                   No, skip\n         CHI   R14,6                    Maybe, check again\n         JH    K00270                   Not CANCEL, skip\n         ICM   R15,B'1111',@K_ISPF_VCOPY_Var_Ptr A(ZCMD)\n         JZ    K00300                   Nothing, skip\n         LA    R1,@K_DBLWD              A(Work area)\n         AHI   R14,-1                   EX Len\n         EX    R14,K_MVC                Move to work area\n         OC    @K_DBLWD,=CL8' '         Uppercase it\n         EX    R14,K_CLC1               Check it out\n         JE    K00720                   CANCEL, just exit\n\nK00270   DS    0H\n*--------------------------------------------------------------------*\n*     Check out what happened. First check the command for something *\n*    we recognize ...                                                *\n*--------------------------------------------------------------------*\n         LA    R1,@K_Parms              A(Parm list)\n         BRAS  R14,L00010               Check out command\n\n         TM    @_ReDisplay,L'@_ReDisplay Change display mode?\n         JO    K00280                   Yes, skip\n         LTR   R15,R15                  No, did it work?\n         JNZ   K00700                   No, unknown command\n         J     K00290                   Unknown command, skip\n\nK00280   DS    0H\n         LA    R15,=CL8'VDEFINE'        ISPF Function\n         ST    R15,@K_ISPF_Parms        Save it\n         LA    R15,=CL8'ZCMD'           Variable name\n         ST    R15,@K_ISPF_Parms+4      Save it\n         LA    R15,K_Blanks             A(blank string)\n         ST    R15,@K_ISPF_Parms+8      Save it\n         LA    R15,=CL8'CHAR'           Character variables\n         ST    R15,@K_ISPF_Parms+12     Save it\n         LA    R15,=AL4(L'K_Blanks)     Length of blank string\n         ST    R15,@K_ISPF_Parms+16     Save it\n         OI    @K_ISPF_Parms+16,X'80'   Flag end of list\n         LA    R1,@K_ISPF_Parms         A(Parmlist)\n         L     R15,@_ISPLINK            A(ISPF Interface)\n         BASR  R14,R15                  Go do it\n\n         LA    R15,=CL8'VPUT'           ISPF Function\n         ST    R15,@K_ISPF_Parms        Save it\n         LA    R15,=CL8'ZCMD'           A(Variable name)\n         ST    R15,@K_ISPF_Parms+4      Save it\n         LA    R15,=CL8'ASIS'           A(Variable name)\n         ST    R15,@K_ISPF_Parms+8      Save it\n         OI    @K_ISPF_Parms+8,X'80'    Flag end of list\n         LA    R1,@K_ISPF_Parms         A(Parmlist)\n         L     R15,@_ISPLINK            A(ISPF Interface)\n         BASR  R14,R15                  Go do it\n\n         LHI   R15,20                   Change display mode, set rc\n         J     K90010                   and exit\n\nK00290   DS    0H\n*--------------------------------------------------------------------*\n*     We have processed the command, so clear ZCMD ...               *\n*--------------------------------------------------------------------*\n         LA    R15,=CL8'VREPLACE'       ISPF Function\n         ST    R15,@K_ISPF_Parms        Save it\n         LA    R15,=CL8'ZCMD'           Variable name\n         ST    R15,@K_ISPF_Parms+4      Save it\n         LA    R15,=AL4(0)              Length of variable\n         ST    R15,@K_ISPF_Parms+8      Save it\n         LA    R15,0                    Null value\n         ST    R15,@K_ISPF_Parms+12     Save it\n         OI    @K_ISPF_Parms+12,X'80'   Flag end of list\n         LA    R1,@K_ISPF_Parms         A(Parmlist)\n         L     R15,@_ISPLINK            A(ISPF Interface)\n         BASR  R14,R15                  Go do it\n\n*--------------------------------------------------------------------*\n*     ... and force a refresh of the table display area.             *\n*--------------------------------------------------------------------*\n         MVC   @K_VolTbl_Ent_Display_Line_Prev,=FL4'-1' Force tbl refr\n\nK00300   DS    0H\n*--------------------------------------------------------------------*\n*     Check for scroll request:                                      *\n*       ZVERB    = UP, DOWN, LEFT, or RIGHT                          *\n*       ZSCROLLN = scroll amount                                     *\n*       ZSCROLLA = PAGE, CSR, MAX, etc.                              *\n*--------------------------------------------------------------------*\n         LA    R15,=CL8'VCOPY'          ISPF Function\n         ST    R15,@K_ISPF_Parms        Save it\n         LA    R15,K_ISPF_VCOPY_Scroll_Names   A(Variable Names)\n         ST    R15,@K_ISPF_Parms+4      Save it\n         LA    R15,@K_ISPF_VCOPY_Scroll_Lens   A(Lengths)\n         ST    R15,@K_ISPF_Parms+8      Save it\n         LA    R15,@K_ISPF_VCOPY_Scroll_Ptrs   A(Addresses)\n         ST    R15,@K_ISPF_Parms+12     Save it\n         OI    @K_ISPF_Parms+12,X'80'   Flag last parm\n         LA    R1,@K_ISPF_Parms         A(ISPF Parms)\n         L     R15,@_ISPLINK            A(ISPF routine)\n         BASR  R14,R15                  Go get variables\n\n         CHI   R15,8                    Did we get any?\n         JH    K00710                   No, just re-display\n\n         NI    @K_Scroll_UP,X'FF'-L'@K_Scroll_UP  Off our flag\n         NI    @K_Scroll_DOWN,X'FF'-L'@K_Scroll_DOWN  Off our flag\n         NI    @K_Scroll_LEFT,X'FF'-L'@K_Scroll_LEFT  Off our flag\n         NI    @K_Scroll_RIGHT,X'FF'-L'@K_Scroll_RIGHT  Off our flag\n         NI    @K_Scroll_MAX,X'FF'-L'@K_Scroll_MAX  Off our flag\n\n         ICM   R14,B'1111',@K_ISPF_VCOPY_ZVERB_Len Len of ZVERB\n         JZ    K00500                   Nothing, go check expand\n         ICM   R15,B'1111',@K_ISPF_VCOPY_ZVERB_Ptr A(ZVERB)\n         JZ    K00500                   Nothing, check expand\n\n         CHI   R14,2                    Could it be UP?\n         JNE   K00310                   No, skip\n         CLC   =C'UP',0(R15)            Could be, is it?\n         JNE   K00710                   No, ignore it\n         OI    @K_Scroll_UP,L'@K_Scroll_UP  Yes, say so\n         J     K00340                   and check ZSCROLLN\nK00310   DS    0H\n\n         CHI   R14,4                    Could it be DOWN or LEFT?\n         JNE   K00330                   No, skip\n         CLC   =C'DOWN',0(R15)          Could be, is it DOWN?\n         JNE   K00320                   No, go check LEFT\n         OI    @K_Scroll_DOWN,L'@K_Scroll_DOWN  Yes, say so\n         J     K00340                   and check ZSCROLLN\nK00320   DS    0H\n         CLC   =C'LEFT',0(R15)          Is it LEFT?\n         JNE   K00710                   No, ignore it\n         OI    @K_Scroll_LEFT,L'@K_Scroll_LEFT  Yes, say so\n         J     K00340                   and check ZSCROLLN\nK00330   DS    0H\n         CHI   R14,5                    Could it be RIGHT?\n         JNE   K00710                   No, ignore it\n         CLC   =C'RIGHT',0(R15)         Could be, is it?\n         JNE   K00710                   No, ignore it\n         OI    @K_Scroll_RIGHT,L'@K_Scroll_RIGHT  Yes, say so\n         J     K00340                   and check ZSCROLLN\n\nK00340   DS    0H\n*--------------------------------------------------------------------*\n*     We have a scroll command, check ZSCROLLA for MAX               *\n*--------------------------------------------------------------------*\n         ICM   R14,B'1111',@K_ISPF_VCOPY_ZSCROLLA_Len Len of ZSCROLLA\n         JZ    K00350                   Nothing, check ZSCROLLN\n         CHI   R14,3                    Could it be MAX?\n         JNE   K00350                   No, check ZSCROLLN\n         ICM   R1,B'1111',@K_ISPF_VCOPY_ZSCROLLA_Ptr A(ZSCROLLA)\n         JZ    K00350                   Nothing, check ZSCROLLN\n         CLC   =C'MAX',0(R1)            Is it MAX?\n         JNE   K00350                   No, skip\n         OI    @K_Scroll_MAX,L'@K_Scroll_MAX Yes, set our flag\n\nK00350   DS    0H\n*--------------------------------------------------------------------*\n*     Set a flag if the user entered an explicit scroll amount       *\n*    (eg, DOWN 16). We can determine this if ZSCROLLN = ZSCROLLA     *\n*--------------------------------------------------------------------*\n         NI    @K_Scroll_Explicit,X'FF'-L'@K_Scroll_Explicit\n         ICM   R15,B'1111',@K_ISPF_VCOPY_ZSCROLLN_Len ZSCROLLN Length\n         JZ    K00360                   Nothing, skip\n         C     R15,@K_ISPF_VCOPY_ZSCROLLA_Len Same as ZSCROLLA?\n         JNE   K00360                   No, skip\n         ICM   R14,B'1111',@K_ISPF_VCOPY_ZSCROLLN_Ptr Yes, A(ZSCROLLN)\n         JZ    K00360                   Nothing, skip\n         ICM   R1,B'1111',@K_ISPF_VCOPY_ZSCROLLA_Ptr A(ZSCROLLA)\n         JZ    K00360                   Nothing, skip\n         AHI   R15,-1                   EX length\n         EX    R15,K_CLC                Same value?\n         JNE   K00360                   No, skip\n         OI    @K_Scroll_Explicit,L'@K_Scroll_Explicit Yes, set flag\n\nK00360   DS    0H\n*--------------------------------------------------------------------*\n*     Get ZSCROLLN (defaulting to 0 )                                *\n*--------------------------------------------------------------------*\n         LA    R15,0                    Set our default\n\n         ICM   R14,B'1111',@K_ISPF_VCOPY_ZSCROLLN_Len Len of ZSCROLLN\n         JZ    K00370                   Nothing, just re-display\n         ICM   R1,B'1111',@K_ISPF_VCOPY_ZSCROLLN_Ptr A(ZSCROLLN)\n         JZ    K00370                   Nothing, ignore it\n         AHI   R14,-1                   EX len\n         EX    R14,K_PACK               Pack it\n         CVB   R15,@K_DBLWD             Binarize it\n\nK00370   DS    0H\n         TM    @K_Scroll_RIGHT,L'@K_Scroll_RIGHT  Horizontal?\n         JO    K00430                   Yes, skip\n         TM    @K_Scroll_LEFT,L'@K_Scroll_LEFT No, check again\n         JO    K00460                   Yes, skip\n         TM    @K_Scroll_DOWN,L'@K_Scroll_DOWN No, scroll DOWN?\n         JO    K00390                   Yes, skip\n\n*--------------------------------------------------------------------*\n*     Scroll UP                                                      *\n*--------------------------------------------------------------------*\n         TM    @K_Scroll_MAX,L'@K_Scroll_MAX  UP MAX?\n         JO    K00380                   Yes, set to top\n         L     R14,@K_VolTbl_Ent_Display_Line Get current line number\n         SR    R14,R15                  Back up the scroll amount\n         TM    @K_Scroll_Explicit,L'@K_Scroll_Explicit Explicit nbr?\n         JO    K00420                   Yes, all done\n*        A     R14,@K_ISPF_Dyn_Area_Hdg_Lines No, adjust for headings\n         J     K00420                   and skip\nK00380   DS    0H\n         LA    R14,0                    UP MAX, reset line number\n         J     K00420                   and skip\n\nK00390   DS    0H\n*--------------------------------------------------------------------*\n*     Scroll DOWN                                                    *\n*--------------------------------------------------------------------*\n         TM    @K_Scroll_MAX,L'@K_Scroll_MAX  DOWN MAX?\n         JO    K00400                   Yes, skip\n         ICM   R14,B'1111',@K_VolTbl_Ent_Display_Line No, curr line nbr\n         JP    K00390C                  OK, skip\n         AHI   R14,-1                   Account for Top of Data line\nK00390C  DS    0H\n         AR    R14,R15                  Line number\n         TM    @K_Scroll_Explicit,L'@K_Scroll_Explicit Explicit nbr?\n         JO    K00420                   Yes, all done\n         S     R14,@K_ISPF_Dyn_Area_Hdg_Lines No, adjust for headings\n         J     K00420                   and skip\n\nK00400   DS    0H\n*--------------------------------------------------------------------*\n*     Scroll DOWN MAX - get the last visible line, and use it        *\n*    instead of @K_ISPF_Dyn_Area_Depth                               *\n*--------------------------------------------------------------------*\n         LA    R15,=CL8'VCOPY'          ISPF Function\n         ST    R15,@K_ISPF_Parms        Save it\n         LA    R15,=CL8'SSCSPCLV'       A(Variable Names)\n         ST    R15,@K_ISPF_Parms+4      Save it\n         LA    R15,@K_ISPF_VCOPY_Lens   A(Lengths)\n         ST    R15,@K_ISPF_Parms+8      Save it\n         LA    R15,@K_ISPF_VCOPY_Ptrs   A(Addresses)\n         ST    R15,@K_ISPF_Parms+12     Save it\n         OI    @K_ISPF_Parms+12,X'80'   Flag last parm\n         LA    R1,@K_ISPF_Parms         A(ISPF Parms)\n         L     R15,@_ISPLINK            A(ISPF routine)\n         BASR  R14,R15                  Go display table\n\n         L     R0,@K_ISPF_Dyn_Area_Depth Init our depth\n         LTR   R15,R15                  Did it work?\n         JNZ   K00410                   No, skip\n\n         ICM   R14,B'1111',@K_ISPF_VCOPY_Var_Len Len of SSCSPCLV\n         JZ    K00410                   Nothing, skip\n         ICM   R1,B'1111',@K_ISPF_VCOPY_Var_Ptr A(SSCSPCLV)\n         JZ    K00410                   Nothing, ignore it\n         AHI   R14,-1                   EX len\n         EX    R14,K_PACK               Pack it\n         CVB   R0,@K_DBLWD              Binarize it\nK00410   DS    0H\n         L     R14,@K_VolTbl_Ent_Display_Line_Max Get max display line\n         SR    R14,R0                   Back up a screen\n         A     R14,@K_ISPF_Dyn_Area_Hdg_Lines Adjust for heading lines\n         AHI   R14,1                    Make Bottom of Data visible\n         J     K00420                   and skip\n\nK00420   DS    0H\n*--------------------------------------------------------------------*\n*     Vertical Scroll, save updated line number, and skip            *\n*--------------------------------------------------------------------*\n         ST    R14,@K_VolTbl_Ent_Display_Line Save new line number\n         J     K00710                   Go re-display\n\nK00430   DS    0H\n*--------------------------------------------------------------------*\n*     Scroll RIGHT                                                   *\n*--------------------------------------------------------------------*\n         TM    @K_Scroll_Max,L'@K_Scroll_Max  RIGHT MAX?\n         JNO   K00440                   No, skip\n         L     R14,@K_VolTbl_Ent_Offset_Max Yes, get max offset\n         J     K00490                   and skip\nK00440   DS    0H\n         TM    @K_Scroll_Explicit,L'@K_Scroll_Explicit Explicit nbr?\n         JO    K00450                   Yes, skip\n         S     R15,=AL4(VolTbl_Ent_DevType-VolTbl_Ent_Display) Adj scrl\n         JP    K00450                   OK, skip\n         L     R15,@K_ISPF_Dyn_Area_Width cursor in non-scroll area,\n         S     R15,=AL4(VolTbl_Ent_DevType-VolTbl_Ent_Display) Width\nK00450   DS    0H\n         L     R14,@K_VolTbl_Ent_Offset Get current offset\n         AR    R14,R15                  Adjust offset\n         J     K00490                   and skip\n\nK00460   DS    0H\n*--------------------------------------------------------------------*\n*     Scroll LEFT                                                    *\n*--------------------------------------------------------------------*\n         TM    @K_Scroll_Max,L'@K_Scroll_Max  LEFT MAX?\n         JO    K00480                   Yes, skip\n\n         TM    @K_Scroll_Explicit,L'@K_Scroll_Explicit Explicit nbr?\n         JO    K00470                   Yes, skip\n         L     R0,@K_ISPF_Dyn_Area_Width Get width of\n         S     R0,=AL4(VolTbl_Ent_DevType-VolTbl_Ent_Display) scrl area\n         CR    R15,R0                   Too far left?\n         JNH   K00470                   No, OK\n         LR    R15,R0                   Yes, set to 1 screens worth\nK00470   DS    0H\n         L     R14,@K_VolTbl_Ent_Offset Get current offset\n         SR    R14,R15                  Adjust it\n         J     K00490                   and skip\nK00480   DS    0H\n         L     R14,=AL4(VolTbl_Ent_DevType-VolTbl_Ent_Display) Set min\n\nK00490   DS    0H\n*--------------------------------------------------------------------*\n*     Horizontal scroll - save new offset                            *\n*--------------------------------------------------------------------*\n         ST    R14,@K_VolTbl_Ent_Offset Yes, save new offset\n         J     K00710                   and redisplay\n\nK00500   DS    0H\n*--------------------------------------------------------------------*\n*     Not a scroll command -  see if the cursor is in the DATA       *\n*    field, and on a numeric field. If so, the value of the field is *\n*    displayed. This will allow the user to see the actual values    *\n*    for fields we have scaled to fit in our display.                *\n*                                                                    *\n*    Get ZSCREENW (screen width)                                     *\n*        ZSCREENC (cursor position ((row# * ZSCREENW) + col#)))      *\n*--------------------------------------------------------------------*\n         LA    R15,=CL8'VCOPY'          ISPF Function\n         ST    R15,@K_ISPF_Parms        Save it\n         LA    R15,K_ISPF_VCOPY_Cursor_Names   A(Variable Names)\n         ST    R15,@K_ISPF_Parms+4      Save it\n         LA    R15,@K_ISPF_VCOPY_Cursor_Lens   A(Lengths)\n         ST    R15,@K_ISPF_Parms+8      Save it\n         LA    R15,@K_ISPF_VCOPY_Cursor_Ptrs   A(Addresses)\n         ST    R15,@K_ISPF_Parms+12     Save it\n         OI    @K_ISPF_Parms+12,X'80'   Flag last parm\n         LA    R1,@K_ISPF_Parms         A(ISPF Parms)\n         L     R15,@_ISPLINK            A(ISPF routine)\n         BASR  R14,R15                  Go get variables\n\n         LTR   R15,R15                  Did we?\n         JNZ   K00710                   No, just re-display\n\n*--------------------------------------------------------------------*\n*     Get the cursor row and column (on the screen) ...              *\n*--------------------------------------------------------------------*\n         ICM   R15,B'1111',@K_ISPF_ZSCREENC_Len Get ZSCREENC length\n         JNP   K00710                   Nothing, just re-display\n         AHI   R15,-1                   EX length\n         ICM   R1,B'1111',@K_ISPF_ZSCREENC_Ptr Get A(ZSCREENC)\n         JZ    K00710                   Nothing, just re-display\n         EX    R15,K_PACK               PACK it\n         CVB   R15,@K_DBLWD             Cursor position in screen\n\n         ICM   R14,B'1111',@K_ISPF_ZSCREENW_Len Get ZSCREENW length\n         JZ    K00710                   Nothing, just re-display\n         ICM   R1,B'1111',@K_ISPF_ZSCREENW_Ptr Get A(ZSCREENW)\n         JZ    K00710                   Nothing, just re-display\n         AHI   R14,-1                   EX length\n         EX    R14,K_PACK               PACK it\n         CVB   R1,@K_DBLWD              Screen width\n\n         LA    R14,0                    Clear high-order register\n         DR    R14,R1                   R14: Col, R15: Row\n\n*--------------------------------------------------------------------*\n*     ... and see if it is within the DATA field                     *\n*--------------------------------------------------------------------*\n         S     R15,@K_ISPF_Dyn_Area_Row  Relative row in DATA\n         JM    K00710                   Before start of DATA, exit\n         C     R15,@K_ISPF_Dyn_Area_Depth Really within DATA?\n         JNL   K00710                   No, just redisplay\n\n         S     R14,@K_ISPF_Dyn_Area_Column Relative column of DATA\n         JM    K00710                   To the left of DATA, exit\n         C     R0,@K_ISPF_Dyn_Area_Width Really within DATA?\n         JNL   K00710                   No, just redisplay\n\n         S     R15,@K_ISPF_Dyn_Area_Hdg_Lines minus heading lines\n         JM    K00710                   Cursor on a heading line\n         ICM   R4,B'1111',@K_VolTbl_Ent_Display_Line Get line number\n         JNZ   K00510                   Not 0, OK\n         AHI   R15,-1                   Adjust for 'Top of Data'\n         JM    K00710                   Cursor on 'Top of Data'\nK00510   DS    0H\n         AR    R4,R15                   R4 = Cursor row\n         L     R5,=FL4'-1'              Clear entry counter\n\n         L     R9,@_VolTbl_Ptr          A(Volume Table)\n         L     R10,VolTbl_Hdr_Count-VolTbl_Hdr(R9) Get nbr entries\n         AHI   R9,VolTbl_Ent-VolTbl     Point to first entry\n\nK00520   DS    0H\n*--------------------------------------------------------------------*\n*     Find the entry (we count in R5) that corresponds to the        *\n*    entry we want (in R4)                                           *\n*--------------------------------------------------------------------*\n         TM    VolTbl_Ent_Detail_Line,L'VolTbl_Ent_Detail_Line Detail?\n         JNO   K00530                   No, skip\n         TM    @_No_Details,L'@_No_Details Yes, do we want it?\n         JO    K00550                   No, skip it\n         J     K00540                   Yes, count it\nK00530   DS    0H\n         TM    VolTbl_Ent_Total_Line,L'VolTbl_Ent_Total_Line Total?\n         JNO   K00550                   No, skip it\n         TM    @_No_Totals,L'@_No_Totals Yes, do we want it?\n         JO    K00550                   No, skip it\nK00540   DS    0H\n         AHI   R5,1                     Bump counter\n         CR    R4,R5                    Ours?\n         JNH   K00560                   Yup, skip\nK00550   DS    0H\n         AHI   R9,VolTbl_Ent_Len        A(Next entry)\n         BRCT  R10,K00520               and continue\n         J     K00710                   Not on a row, ignore it\n\nK00560   DS    0H\n         TM    VolTbl_Ent_SMS_Line,L'VolTbl_Ent_SMS_Line Anomaly msg?\n         JO    K00710                   Yes, ignore it\n\n         TM    VolTbl_Ent_LSPACE_Fail,L'VolTbl_Ent_LSPACE_Fail Data?\n         JO    K00710                   No, ignore it\n\n*--------------------------------------------------------------------*\n*     It looks like the cursor is on a line in our table - see if    *\n*    it is also within a numeric field                               *\n*--------------------------------------------------------------------*\n         C     R14,=AL4(VolTbl_Ent_DevType-VolTbl_Ent_Display)\n         JL    K00710                   Cursor in line prefix\n\n         A     R14,@K_VolTbl_Ent_Offset  Get offset within VolTbl_Ent\n         S     R14,=AL4(VolTbl_Ent_DevType-VolTbl_Ent_Display)\n         LA    R15,K_Expand_Tbl         A(Table of offsets)\nK00570   DS    0H\n         CH    R14,0(0,R15)             Our field?\n         JL    K00580                   No, skip\n         CH    R14,2(0,R15)             Maybe, is it?\n         JNH   K00590                   Yes, skip\nK00580   DS    0H\n         AHI   R15,K_Expand_Ent_Len     Bump our pointer\n         CLC   =HL2'0',0(R15)           End of table?\n         JNE   K00570                   No, keep checking\n         J     K00710                   Yes, just redisplay\nK00590   DS    0H\n         LH    R14,4(0,R15)             Offset of FP field\n         LD    R2,VolTbl_Ent(R14)       Get floating point value\n*--------------------------------------------------------------------*\n*     If this is a percent (length of output area = 4), and thus the *\n*    only type of field with fractions) ...                          *\n*--------------------------------------------------------------------*\n         LH    R0,2(0,R15)              A(End of output field) + 1\n         SH    R0,0(0,R15)              Less A(Start of output field)\n         CHI   R0,4                     Is this a percent?\n         JNE   K00630                   No, skip\n\n*--------------------------------------------------------------------*\n*     ... format it                                                  *\n*--------------------------------------------------------------------*\n         MDB   R2,=DBL8'10000000000000' 13-digit fraction\n         CGDBR R0,B'0101',R2            Convert to fixed, round to 0\n         CVDG  R0,@K_QuadWord           Pack it\n         MVC   @K_Expand_Number(17),=X'4021204B202020202020202020202020+\n               20'                      Move mask\n         LA    R1,@K_Expand_Number+2    A(Start of significance)\n         EDMK  @K_Expand_Number(17),@K_QuadWord+8 Unpack it\n         ST    R1,@K_Expand_NumStart    Save A(Start of number)\n         LA    R1,@K_Expand_Number+16   A(last possible 0\nK00600   DS    0H\n         CLI   0(R1),C'0'               Trailing 0?\n         JNE   K00610                   No, found the end\n         BRCT  R1,K00600                Yes, check prev byte\nK00610   DS    0H\n         CLI   0(R1),C'.'               Back to the decimal point?\n         JNE   K00620                   No, OK\n         AHI   R1,2                     Yes, set to 2 decimal places\nK00620   DS    0H\n         ST    R1,@K_Expand_NumEnd      Save A(end of number)\n         J     K00670                   and skip\n\nK00630   DS    0H\n*--------------------------------------------------------------------*\n*     Not a percent, we don't have to worry about decimal points.    *\n*    Format it in 2 groups of 15 decimal digits (max for ED/UNPK),   *\n*    unintuitively doing the rightmost group first.                  *\n*--------------------------------------------------------------------*\n         CGDBR R0,B'0101',R2            Convert to fixed, round to 0\n         CVDG  R0,@K_QuadWord           Pack it\n         LA    R15,@K_Expand_Number+L'@K_Expand_Number A(End of output)\nK00640   DS    0H\n         AHI   R15,-20                  Move mask\n         MVC   0(20,R15),=X'402020206B2020206B2020206B2020206B202120'\n         LG    R0,@K_QuadWord           Get high dblwd\n         LTGR  R0,R0                    Anything in it?\n         JZ    K00650                   No, OK\n         MVI   1(R15),X'21'             Yes, turn on significance\nK00650   DS    0H\n         LA    R1,19(0,R15)             Init A(1st significant field)\n         EDMK  0(20,R15),@K_QuadWord+8  Edit in data\n         LG    R0,@K_QuadWord           Get high dblwd\n         LTGR  R0,R0                    Anything in it?\n         JZ    K00660                   No, all done\n         SLLG  R0,R0,4                  Yes, make room for sign\n         STG   R0,@K_QuadWord+8         Save it\n         OI    @K_Quadword+15,X'0F'     Set sign\n         SLG   R0,R0                    and clear\n         STG   R0,@K_QuadWord             high dblwd\n         MVI   0(R15),C','              Move separator\n         CLI   1(R15),C' '              Significant 0 missed?\n         JNE   K00640                   No, OK\n         MVI   1(R15),C'0'              Yes, set it\n         J     K00640                   Go process it\nK00660   DS    0H\n         ST    R1,@K_Expand_NumStart    Save start of significance\n         LA    R1,@K_Expand_Number+L'@K_Expand_Number-1 A(End)\n         ST    R1,@K_Expand_NumEnd      Save it\n\nK00670   DS    0H\n*--------------------------------------------------------------------*\n*     Set up the SMSG ...                                            *\n*--------------------------------------------------------------------*\n         MVI   @K_Expand_ZEDSMSG,C' '\n         MVC   @K_Expand_ZEDSMSG+1(L'@K_Expand_ZEDSMSG-1),@K_Expand_ZED+\n               SMSG\n         L     R1,@K_Expand_NumStart    A(Start of number)\n         L     R15,@K_Expand_NumEnd     A(End)\n         SR    R15,R1                   Get EX length of number\n         CHI   R15,L'@K_Expand_ZEDSMSG  Too long for SMSG?\n         JL    K00680                   No, OK\n         LA    R1,=C'>>>>>>>>'          Yes, Indicate number too big\n         LA    R15,7                    EX Length\nK00680   DS    0H\n         LA    R14,@K_Expand_ZEDSMSG    A(SMSG)\n         EX    R15,K_K00680_MVC         MVC   0(0,R14),0(R1)\n         LA    R0,1(0,R15)              Real length\n         ST    R0,@K_Expand_ZEDSMSG_Len Save it\n\n*--------------------------------------------------------------------*\n*     ... and LMSG                                                   *\n*--------------------------------------------------------------------*\n         MVC   @K_Expand_ZEDLMSG(L'K_Expand_ZEDLMSG_Pfx),K_Expand_ZEDLM+\n               SG_Pfx\n         LA    R14,@K_Expand_ZEDLMSG+L'K_Expand_ZEDLMSG_Pfx\n         L     R1,@K_Expand_NumStart    A(Source)\n         L     R15,@K_Expand_NumEnd     Calculate\n         SR    R15,R1                    length\n         EX    R15,K_K00680_MVC         MVC   0(0,R14),0(R1)\n         AHI   R15,L'K_Expand_ZEDLMSG_Pfx+1 Len of LMSG\n         ST    R15,@K_Expand_ZEDLMSG_Len Save it\n\n*--------------------------------------------------------------------*\n*     Tell ISPF about the messages, and re-display                   *\n*--------------------------------------------------------------------*\n         LA    R15,=CL8'VDEFINE'        ISPF Function\n         ST    R15,@K_ISPF_Parms        Save it\n         LA    R15,=CL8'CHAR'           Character variables\n         ST    R15,@K_ISPF_Parms+12     Save it\n\n         LA    R15,=CL8'ZEDSMSG'        Variable name\n         ST    R15,@K_ISPF_Parms+4      Save it\n         LA    R15,@K_Expand_ZEDSMSG    A(Short Message)\n         ST    R15,@K_ISPF_Parms+8      Save it\n         LA    R15,@K_Expand_ZEDSMSG_Len Length of message\n         ST    R15,@K_ISPF_Parms+16     Save it\n         OI    @K_ISPF_Parms+16,X'80'   Flag end of list\n         LA    R1,@K_ISPF_Parms         A(Parmlist)\n         L     R15,@_ISPLINK            A(ISPF Interface)\n         BASR  R14,R15                  Go do it\n\n         LA    R15,=CL8'ZEDLMSG'        Variable name\n         ST    R15,@K_ISPF_Parms+4      Save it\n         LA    R15,@K_Expand_ZEDLMSG    A(Long message)\n         ST    R15,@K_ISPF_Parms+8      Save it\n         LA    R15,@K_Expand_ZEDLMSG_Len Length of message\n         ST    R15,@K_ISPF_Parms+16     Save it\n         OI    @K_ISPF_Parms+16,X'80'   Flag end of list\n         LA    R1,@K_ISPF_Parms         A(Parmlist)\n         L     R15,@_ISPLINK            A(ISPF Interface)\n         BASR  R14,R15                  Go do it\n\n         LA    R15,=CL8'SETMSG'         Yes, ISPF Function\n         ST    R15,@K_ISPF_Parms        Save it\n         LA    R15,=CL8'ISRZ001'        A(Message ID)\n         ST    R15,@K_ISPF_Parms+4      Save it\n         OI    @K_ISPF_Parms+4,X'80'    Mark end of list\n         LA    R1,@K_ISPF_Parms         Point to ISPF parms\n         L     R15,@_ISPLINK            A(Interface routine)\n         BASR  R14,R15                  Go do it\n\n         J     K00710                   And redisplay\n\nK00700   DS    0H\n*--------------------------------------------------------------------*\n*     Unrecognized ZCMD - Issue messages ...                         *\n*--------------------------------------------------------------------*\n         LA    R15,=CL8'VDEFINE'        ISPF Function\n         ST    R15,@K_ISPF_Parms        Save it\n         LA    R15,=CL8'CHAR'           Character variables\n         ST    R15,@K_ISPF_Parms+12     Save it\n\n         LA    R15,=CL8'ZEDSMSG'        Variable name\n         ST    R15,@K_ISPF_Parms+4      Save it\n         LA    R15,K_Bad_ZCMD_SMsg      A(Short Message)\n         ST    R15,@K_ISPF_Parms+8      Save it\n         LA    R15,=AL4(L'K_Bad_ZCMD_SMsg) Length of variable\n         ST    R15,@K_ISPF_Parms+16     Save it\n         OI    @K_ISPF_Parms+16,X'80'   Flag end of list\n         LA    R1,@K_ISPF_Parms         A(Parmlist)\n         L     R15,@_ISPLINK            A(ISPF Interface)\n         BASR  R14,R15                  Go do it\n\n         LA    R15,=CL8'ZEDLMSG'        Variable name\n         ST    R15,@K_ISPF_Parms+4      Save it\n         LA    R15,K_Bad_ZCMD_LMsg      A(Long message)\n         ST    R15,@K_ISPF_Parms+8      Save it\n         LA    R15,=AL4(L'K_Bad_ZCMD_LMsg) Length of message\n         ST    R15,@K_ISPF_Parms+16     Save it\n         OI    @K_ISPF_Parms+16,X'80'   Flag end of list\n         LA    R1,@K_ISPF_Parms         A(Parmlist)\n         L     R15,@_ISPLINK            A(ISPF Interface)\n         BASR  R14,R15                  Go do it\n\n         LA    R15,=CL8'SETMSG'         Yes, ISPF Function\n         ST    R15,@K_ISPF_Parms        Save it\n         LA    R15,=CL8'ISRZ001'        A(Message ID)\n         ST    R15,@K_ISPF_Parms+4      Save it\n         OI    @K_ISPF_Parms+4,X'80'    Mark end of list\n         LA    R1,@K_ISPF_Parms         Point to ISPF parms\n         L     R15,@_ISPLINK            A(Interface routine)\n         BASR  R14,R15                  Go do it\n\n         J     K00710                   And redisplay\n\nK00710   DS    0H\n*--------------------------------------------------------------------*\n*     ... and re-display the table.                                  *\n*--------------------------------------------------------------------*\n         J     K00060                   and start again\n\nK00720   DS    0H\n*--------------------------------------------------------------------*\n*     All done, clear our return code, and exit                      *\n*--------------------------------------------------------------------*\n         LA    R15,0                    Clear the return code\n         J     K90010                   and exit\n\n\nK80010   DS    0H\n*--------------------------------------------------------------------*\n*     Panel not found, set return code, and exit                     *\n*--------------------------------------------------------------------*\n         LA    R15,4                    Set return code\n         J     K90010                   and exit\n\nK90010   DS    0H\n*---------------------------------------------------------------------*\n*   Free up our Dynamic area storage                                  *\n*---------------------------------------------------------------------*\n         LR    R3,R15                 Save return code\n\n         ICM   R1,B'1111',@K_ISPF_Dyn_Area_Ptr\n         JZ    K90020                   None, skip\n         L     R2,@K_31Bit_Stack_Ptr_Ptr A(31-bit stack Ptr)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         SSCSTACK POP,                  Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=(R2)                on this stack\nK90020   DS    0H\n*-------------------------------------------------------------------*\n*    Free up our local storage ...                                  *\n*-------------------------------------------------------------------*\n         LA    R1,@K_Dynam              A(Local storage)\n         L     R2,@K_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         L     R13,4(0,R13)             Rescue A(HSA)\n\n         SSCSTACK POP,                  Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=(R2)                on this stack\n\n         LR    R15,R3                   Restore return code\n\n*-------------------------------------------------------------------*\n*    ... and return to caller                                       *\n*-------------------------------------------------------------------*\n         L     R14,12(0,R13)            Restore return address\n         LM    R0,R12,20(R13)           Restore other registers\n         BSM   0,R14                    and return\n\nK_Literals  DS  0H\n\nK_MVC    MVC   0(0,R1),0(R15)           Move data to dynamic area\nK_PACK   PACK  @K_DBLWD,0(0,R1)         Pack it\nK_CLC    CLC   0(0,R1),0(R14)           Compare ZSCROLLN and ZSCROLLA\nK_CLC1   CLC   @K_DBLWD(0),=C'CANCEL'   Check ZCMD for CANCEL\nK_BLANKS DC    C' '\n\nK_Bad_ZCMD_SMsg DC C'Invalid Command'\nK_Bad_ZCMD_LMsg DC C'Valid commands are: SORT, UP, DOWN, LEFT, RIGHT, E+\n               ND, RETURN, and CANCEL'\n\nK_ISPF_PQUERY_Names DC C'('            PQUERY Variable Names\nK_SPCDYNTY          DC CL8'SPCDYNTY',CL1' ' Type of Dyn area\nK_SPCDYNWI          DC CL8'SPCDYNWI',CL1' ' Width\nK_SPCDYNDE          DC CL8'SPCDYNDE',CL1' ' Depth\nK_SPCDYNRO          DC CL8'SSCDYNRO',CL1' ' Starting Row\nK_SPCDYNCO          DC CL8'SSCDYNCO',CL1' ' Starting Column\n                    DC C')'\nK_ISPF_PQUERY_Types DC CL8'CHAR'       Type of Dynamic area\n                    DC CL8'FIXED'      Width\n                    DC CL8'FIXED'      Depth\n                    DC CL8'FIXED'      Starting Row\n                    DC CL8'FIXED'      Starting Column\nK_ISPF_PQUERY_Lens  DC FL4'8'          Length of Type\n                    DC FL4'4'          Length of Width\n                    DC FL4'4'          Length of Depth\n                    DC FL4'4'          Length of Starting Row\n                    DC FL4'4'          Length of Starting Column\n\nK_ISPF_VCOPY_Scroll_Names DC C'(ZVERB,ZSCROLLN,ZSCROLLA)'\nK_ISPF_VCOPY_Cursor_Names DC C'(ZSCREENW ZSCREENC)'\n\nK_K00680_MVC           MVC   0(0,R14),0(R1)\n\nK_Expand_Tbl           EQU   *\nK_Expand_Ent           EQU   *\n                       DC    AL2(VolTbl_Ent_FreeTrk-VolTbl_Ent_Display)\n                       DC    AL2(VolTbl_Ent_FreeTrk+L'VolTbl_Ent_FreeTr+\n               k-VolTbl_Ent_Display)\n                       DC    AL2(VolTbl_Ent_Sort_FreeTrk-VolTbl_Ent)\nK_Expand_Ent_Len       EQU   *-K_Expand_Ent\n                       DC    AL2(VolTbl_Ent_FreeCyl-VolTbl_Ent_Display)\n                       DC    AL2(VolTbl_Ent_FreeCyl+L'VolTbl_Ent_FreeCy+\n               l-VolTbl_Ent_Display)\n                       DC    AL2(VolTbl_Ent_Sort_FreeCyl-VolTbl_Ent)\n\n                       DC    AL2(VolTbl_Ent_FreeBytes-VolTbl_Ent_Displa+\n               y)\n                       DC    AL2(VolTbl_Ent_FreeBytes+L'VolTbl_Ent_Free+\n               Bytes-VolTbl_Ent_Display)\n                       DC    AL2(VolTbl_Ent_Sort_FreeBytes-VolTbl_Ent)\n\n                       DC    AL2(VolTbl_Ent_FreePct-VolTbl_Ent_Display)\n                       DC    AL2(VolTbl_Ent_FreePct+L'VolTbl_Ent_FreePc+\n               t-VolTbl_Ent_Display)\n                       DC    AL2(VolTbl_Ent_Sort_FreePct-VolTbl_Ent)\n\n                       DC    AL2(VolTbl_Ent_FreeExt-VolTbl_Ent_Display)\n                       DC    AL2(VolTbl_Ent_FreeExt+L'VolTbl_Ent_FreeEx+\n               t-VolTbl_Ent_Display)\n                       DC    AL2(VolTbl_Ent_Sort_FreeExt-VolTbl_Ent)\n\n                       DC    AL2(VolTbl_Ent_LargTrk-VolTbl_Ent_Display)\n                       DC    AL2(VolTbl_Ent_LargTrk+L'VolTbl_Ent_LargTr+\n               k-VolTbl_Ent_Display)\n                       DC    AL2(VolTbl_Ent_Sort_LargTrk-VolTbl_Ent)\n\n                       DC    AL2(VolTbl_Ent_LargCyl-VolTbl_Ent_Display)\n                       DC    AL2(VolTbl_Ent_LargCyl+L'VolTbl_Ent_LargCy+\n               l-VolTbl_Ent_Display)\n                       DC    AL2(VolTbl_Ent_Sort_LargCyl-VolTbl_Ent)\n\n                       DC    AL2(VolTbl_Ent_VTOCTrk-VolTbl_Ent_Display)\n                       DC    AL2(VolTbl_Ent_VTOCTrk+L'VolTbl_Ent_VTOCTr+\n               k-VolTbl_Ent_Display)\n                       DC    AL2(VolTbl_Ent_Sort_VTOCTrk-VolTbl_Ent)\n\n                       DC    AL2(VolTbl_Ent_FreeDSCB-VolTbl_Ent_Display+\n               )\n                       DC    AL2(VolTbl_Ent_FreeDSCB+L'VolTbl_Ent_FreeD+\n               SCB-VolTbl_Ent_Display)\n                       DC    AL2(VolTbl_Ent_Sort_FreeDSCB-VolTbl_Ent)\n\n                       DC    AL2(VolTbl_Ent_VTOCFree-VolTbl_Ent_Display+\n               )\n                       DC    AL2(VolTbl_Ent_VTOCFree+L'VolTbl_Ent_VTOCF+\n               ree-VolTbl_Ent_Display)\n                       DC    AL2(VolTbl_Ent_Sort_VTOCFree-VolTbl_Ent)\n\n                       DC    AL2(VolTbl_Ent_VolSize-VolTbl_Ent_Display)\n                       DC    AL2(VolTbl_Ent_VolSize+L'VolTbl_Ent_VolSiz+\n               e-VolTbl_Ent_Display)\n                       DC    AL2(VolTbl_Ent_Sort_VolSize-VolTbl_Ent)\n\n                       DC    AL2(0)\n                       DC    AL2(0)\n                       DC    AL2(0)\n\nK_Expand_ZEDLMSG_Pfx   DC    C'The unrounded, unscaled value is '\n\n         LTORG\n\nK_Literals_End  DS  0H\n\n\n@K_Dynam                  DSECT        Dynamic area for K\n                          DS    18F     O/S style save area\n@K_31Bit_Stack_Ptr_Ptr    DS    AL4     A(31-bit Stack Ptr)\n@K_24Bit_Stack_Ptr_Ptr    DS    AL4     A(24-bit Stack Ptr)\n@K_DBLWD                  DS    D       Work area\n@K_QuadWord               DS    PL16    Work area\n@K_ISPF_Parms             DS    8AL4    ISPF Parm list\n\n@K_ISPF_Dyn_Area_Width    DS    FL4     Panel Dynam Area Width\n@K_ISPF_Dyn_Area_Depth    DS    FL4     Panel Dynam Area Depth\n@K_ISPF_Dyn_Area_Row      DS    FL4     Panel Dynam Area Start Row\n@K_ISPF_Dyn_Area_Column   DS    FL4     Panel Dynam Area Start Column\n@K_ISPF_Dyn_Area_Ptr      DS    AL4     A(Storage for dynamic area)\n@K_ISPF_Dyn_Area_Len      DS    FL4     Length of dynamic area\n\n                          DS    C\n@K_FLIN                   DS    CL5     Line x\n\n@K_VolTbl_Ent_MVC_Len     DS    FL4     EX len of MVC from VolTbl_Ent\n\n@K_VolTbl_Ent_Display_Line DS   FL4     Current top of display\n@K_VolTbl_Ent_Offset      DS    FL4     Offset for LEFT/RIGHT\n@K_VolTbl_Ent_Display_Line_Max DS FL4   Max value of display line\n@K_VolTbl_Ent_Offset_Max  DS    FL4     Max Offset for LEFT/RIGHT\n@K_VolTbl_Ent_Display_Line_Prev DS FL4  Previous top of display\n@K_VolTbl_Ent_Offset_Prev DS    FL4     Previous Offset for LEFT/RIGHT\n@K_ISPF_Dyn_Area_Hdg_Lines DS   FL4     Nbr of hdg lines in display\n@K_VolTbl_Hdg_Lines       DS    FL4     Nbr of hdg lines in VolTbl\n\n                          DS    X       Flag byte\n@K_Scroll_MAX             EQU   *-1,X'80' 1... .... Scroll MAX\n@K_Scroll_Explicit        EQU   *-1,X'40' .1.. .... Explicit Scroll amt\n@K_Scroll_UP              EQU   *-1,X'08' .... 1... Scroll UP\n@K_Scroll_DOWN            EQU   *-1,X'04' .... .1.. Scroll DOWN\n@K_Scroll_LEFT            EQU   *-1,X'02' .... ..1. Scroll LEFT\n@K_Scroll_RIGHT           EQU   *-1,X'01' .... ...1 Scroll RIGHT\n\n\n@K_Expand_Number          DS    XL40\n@K_Expand_NumStart        DS    AL4\n@K_Expand_NumEnd          DS    AL4\n\n@K_Expand_ZEDSMSG         DS    CL24\n@K_Expand_ZEDSMSG_Len     DS    FL4     Length\n@K_Expand_ZEDLMSG         DS    CL(L'K_Expand_ZEDLMSG_Pfx+L'@K_Expand_N+\n               umber)\n@K_Expand_ZEDLMSG_Len     DS    FL4     Length\n\n@K_ISPF_VCOPY_Ptrs        DS    0F      Pointer to var from VCOPY\n@K_ISPF_VCOPY_Var_Ptr     DS    AL4     A(VCOPYed variable)\n                          ORG   @K_ISPF_VCOPY_Ptrs\n@K_ISPF_VCOPY_Scroll_Ptrs DS    0F      Pointers to vars from VCOPY\n@K_ISPF_VCOPY_ZVERB_Ptr   DS    AL4      A(ZVERB)\n@K_ISPF_VCOPY_ZSCROLLN_Ptr DS   AL4      A(ZSCROLLN)\n@K_ISPF_VCOPY_ZSCROLLA_Ptr DS   AL4      A(ZSCROLLA)\n                          ORG   @K_ISPF_VCOPY_Ptrs\n@K_ISPF_PQUERY_Values     DS    0F     Value areas for PQUERY vars\n@K_ISPF_SPCDYNTN_Value    DS    CL8     Type of area\n@K_ISPF_SPCDYNWI_Value    DS    FL4     Area width\n@K_ISPF_SPCDYNDE_Value    DS    FL4     Area depth\n@K_ISPF_SPCDYNRO_Value    DS    FL4     Starting Row\n@K_ISPF_SPCDYNCO_Value    DS    FL4     Starting Column\n                          ORG   @K_ISPF_VCOPY_Ptrs\n@K_ISPF_VCOPY_Cursor_Ptrs DS    0F      Pointers to vars from VCOPY\n@K_ISPF_ZSCREENW_Ptr      DS    AL4      A(ZSCREENW)\n@K_ISPF_ZSCREENC_Ptr      DS    AL4      A(ZSCREENC)\n                          ORG ,\n\n@K_ISPF_VCOPY_Lens        DS    0F      Length of var from VCOPY\n@K_ISPF_VCOPY_Var_Len     DS    AL4     Len of VCOPYed variable\n                          ORG   @K_ISPF_VCOPY_Lens\n@K_ISPF_VCOPY_Scroll_Lens DS    0F      Lengths of vars from VCOPY\n@K_ISPF_VCOPY_ZVERB_Len   DS    FL4      ZVERB Length\n@K_ISPF_VCOPY_ZSCROLLN_Len DS   FL4      ZSCROLLN Length\n@K_ISPF_VCOPY_ZSCROLLA_Len DS   FL4      ZSCROLLA Length\n                          ORG   @K_ISPF_VCOPY_Lens\n@K_ISPF_VCOPY_Cursor_Lens DS    0F      Lengths of vars from VCOPY\n@K_ISPF_ZSCREENW_Len      DS    FL4      ZSCREENW Length\n@K_ISPF_ZSCREENC_Len      DS    FL4      ZSCREENC Length\n                          ORG   ,\n\n@K_Parms                  DS    0F      Parms for called rtns\n@K_Parms_Std              DS    3AL4     Standard 3 parms\n@K_Parms_Extra            EQU   *        Extra parms\n@K_Parms_V00010           DS    AL4        for V00010\n                          ORG   ,\n\n                          DS    0D\n@K_Dynam_Length           EQU   *-@K_Dynam\n\n&PGMNAME CSECT\n         DROP  ,                        Free base registers\n         POP   USING\n         TITLE 'L00010: Identify line command under ISPF'\n\n         PUSH  USING\n\nL00010   DS    0H\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Routine   : L00010                                                 *\n*                                                                     *\n*  Abstract  : Process primary command entered in ISPF (S)pace or     *\n*              (B)rowse mode.                                         *\n*                                                                     *\n*  Inputs    : R1 : ---> A(@_Dynam)                                   *\n*                        A(31-bit Stack Pointer)                      *\n*                        A(24-bit Stack Pointer)                      *\n*  Outputs   : R15: 0: Command processed OK                           *\n*                   4: Display mode change requested                  *\n*                   8: Unrecognized command                           *\n*                                                                     *\n*  Notes     :                                                        *\n*                                                                     *\n*  History:    2002/02/12 SDDA030 - V2.16                             *\n*                                   New                               *\n*              2003/10/07 SDDA030 - V2.21                             *\n*                                   Added line commands:              *\n*                                    - ISPF(x) to change display mode *\n*                                    - OUTPUT to write table to a file*\n*                                                                     *\n*              ____/__/__ _______                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         STM   R14,R12,12(R13)          Save callers registers\n         LARL  R11,L_Literals           Point to our literals\n         USING (L_Literals,L_Literals_End),R11 Tell the assembler\n\n         L     R12,0(0,R1)              A(@_Dynam)\n         USING @_Dynam,R12              Tell the assembler\n\n*-------------------------------------------------------------------*\n*    Get an area on the stack for our local storage                 *\n*-------------------------------------------------------------------*\n         L     R2,4(0,R1)               A(31-bit stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         SSCSTACK PUSH,                 Get stack area                 +\n               LEN=@L_Dynam_Length,      this long                     +\n               STACK=(R2)                using this stack\n\n         LR    R3,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LHI   R1,@L_Dynam_Length        Its length\n         LA    R14,0                    Clear source address\n         LA    R15,0                     and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R3                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*-------------------------------------------------------------------*\n         ST    R13,4(0,R1)              Chain\n         ST    R1,8(0,R13)               saveareas\n         LR    R13,R1                   Load dynam base\n         USING @L_Dynam,R13             Assign a base\n         L     R15,@L_Dynam+4           Get A(HSA)\n         LM    R0,R3,20(R15)            Restore callers registers\n\n         L     R15,4(0,R1)              A(31-bit Stack Pointer)\n         ST    R15,@L_31Bit_Stack_Ptr_Ptr Save it\n         L     R15,8(0,R1)              A(24-bit Stack Pointer)\n         ST    R15,@L_24Bit_Stack_Ptr_Ptr Save it\n\n*-------------------------------------------------------------------*\n*    Get ZCMD                                                       *\n*-------------------------------------------------------------------*\n         LA    R15,=CL8'VCOPY'          ISPF Function\n         ST    R15,@L_ISPF_Parms        Save it\n         LA    R15,=CL8'ZCMD'           Variable we want\n         ST    R15,@L_ISPF_Parms+4      Save it\n         LA    R15,@L_ZCMD_Length       A(Length Address)\n         ST    R15,@L_ISPF_Parms+8      Save it\n         LA    R15,@L_ZCMD_Ptr          A(Variable name)\n         ST    R15,@L_ISPF_Parms+12     Save it\n         OI    @L_ISPF_Parms+12,X'80'   Flag last parm\n         LA    R1,@L_ISPF_Parms         A(ISPF Parms)\n         L     R15,@_ISPLINK            A(ISPF routine)\n         BASR  R14,R15                  Go get the variable\n\n         LTR   R15,R15                  Did we get it?\n         JNZ   L00140                   No, pretend all is OK\n\n*-------------------------------------------------------------------*\n*    See if we recognize the command. First, uppercase it ...       *\n*-------------------------------------------------------------------*\n         ICM   R14,B'1111',@L_ZCMD_Length Get len of ZCMD\n         JZ    L00140                   Nothing, all done\n         ICM   R15,B'1111',@L_ZCMD_Ptr  OK, point to ZCMD\n         JZ    L00140                   Nothing (huh?), exit\n         MVI   @L_Prim_Cmd,C' '         Clear\n         MVC   @L_Prim_Cmd+1(L'@L_Prim_Cmd-1),@L_Prim_Cmd command area\n         AHI   R14,-1                   EX length\n         EX    R14,L_OC                 Uppercase it\n         AHI   R14,1                    Restore real length\n\n*-------------------------------------------------------------------*\n*    ... and search our table for the command                       *\n*-------------------------------------------------------------------*\n         LR    R0,R14                   Set up length register\n         LR    R1,R15                   and pointer register\n\n         LA    R15,0                    Clear length register\n         LA    R14,L_Command_Table      A(Commands we know about)\nL00020   DS    0H\n         ICM   R2,B'1111',0(R14)        A(Processing routine)\n         JZ    L00160                   End-of-table, unknown command\n         IC    R15,4(0,R14)             Get cmd len from table\n         CR    R0,R15                   Could it be ours?\n         JNH   L00030                   No, try next\n         EX    R15,L_CLC                Could be, is it?\n         JNE   L00030                   No, try next table entry\n         LA    R2,1(0,R15)              Maybe, get real length of cmd\n         CR    R0,R2                    Is that all there is?\n         JNH   L00040                   Yes, found our entry\n         AR    R2,R1                    No, point to last char of cmd\n         CLI   0(R2),C' '               Followed by a space?\n         JE    L00040                   Yes, this is our command\nL00030   DS    0H\n         LA    R14,6(R14,R15)           A(Next entry)\n         J     L00020                   and check it out\n\nL00040   DS    0H\n*-------------------------------------------------------------------*\n*    We have found our command entry, so now we set up the          *\n*   registers for the processing routine:                           *\n*        R1 = A(1st non-blank after the command)                    *\n*        R0 = length of data remaining in ZCMD                      *\n*-------------------------------------------------------------------*\n         AR    R0,R1                    A(char past end of ZCMD)\n         AR    R1,R15                   A(last char of command)\nL00050   DS    0H\n         AHI   R1,1                     A(next char)\n         CR    R1,R0                    Gone too far?\n         JNL   L00060                   Yep, skip\n         CLI   0(R1),C' '               No, a space?\n         JE    L00050                   Yes, keep going\nL00060   DS    0H\n         SR    R0,R1                    Length of data remaining\n\n*-------------------------------------------------------------------*\n*    Go process our command                                         *\n*-------------------------------------------------------------------*\n         LA    R15,@_Dynam              A(Dynamic area)\n         ST    R15,@L_Rtn_Parms         Save it\n         L     R15,@L_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)\n         ST    R15,@L_Rtn_Parms+4       Save it\n         L     R15,@L_24Bit_Stack_Ptr_Ptr A(24-bit Stack Pointer)\n         ST    R15,@L_Rtn_Parms+8       Save it\n         ST    R1,@L_Rtn_Parms+12       Save A(Command)\n         ST    R0,@L_Rtn_Parms+16       Save Len of Command\n\n         LA    R1,@L_Rtn_Parms          A(Parm list)\n         L     R15,0(0,R14)             A(processing routine)\n         BASR  R14,R15                  go do it\n\n         J     L00140                   and skip\n\nL00140   DS    0H\n         LA    R15,0                    Clear return code\n         J     L90010                   and exit\n\nL00160   DS    0H\n         LA    R15,8                    Unrecognized command\n         J     L90010                   and exit\n\n\nL90010   DS    0H\n*-------------------------------------------------------------------*\n*    Free up our local storage ...                                  *\n*-------------------------------------------------------------------*\n         LR    R3,R15                   Save return code\n\n         LA    R1,@L_Dynam              A(Local storage)\n         L     R2,@L_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         L     R13,4(0,R13)             Rescue A(HSA)\n\n         SSCSTACK POP,                  Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=(R2)                on this stack\n\n         LR    R15,R3                   Restore return code\n\n*-------------------------------------------------------------------*\n*    ... and return to caller                                       *\n*-------------------------------------------------------------------*\n         L     R14,12(0,R13)            Restore return address\n         LM    R0,R12,20(R13)           Restore regs other than R15\n         BSM   0,R14                    and return\n\nL_Literals  DS  0H\n\nL_Command_Table EQU  *\nL_Cmd_Proc  DC  AL4(LA0010)             Command processor\nL_Cmd_Len   DC  AL1(3)                  Command length (EX len)\nL_Cmd       DC  C'SORT'                 Command Name\n\n            DC  AL4(LB0010A)\n            DC  AL1(6)\n            DC  C'ISPF(S)'\n\n            DC  AL4(LB0010B)\n            DC  AL1(6)\n            DC  C'ISPF(E)'\n\n            DC  AL4(LB0010C)\n            DC  AL1(6)\n            DC  C'ISPF(B)'\n\n            DC  AL4(LB0010D)\n            DC  AL1(6)\n            DC  C'ISPF(N)'\n\n            DC  AL4(LC0010)\n            DC  AL1(5)\n            DC  C'OUTPUT'\n\n            DC  AL4(0)                  End-of-Table marker\n\nL_OC     OC    @L_Prim_Cmd(0),0(R15)    Uppercase command\nL_CLC    CLC   @L_Prim_Cmd(0),5(R14)    Check for command in table\n\n         LTORG\n\nL_Literals_End  DS  0H\n\n\n@L_Dynam                  DSECT\n                          DS    18F    O/S style save area\n@L_31Bit_Stack_Ptr_Ptr    DS    AL4    A(31-bit Stack Ptr)\n@L_24Bit_Stack_Ptr_Ptr    DS    AL4    A(24-bit Stack Ptr)\n@L_Prim_Cmd               DS    CL80   Copy of line command\n@L_ZCMD_Ptr               DS    AL4    A(ZCMD)\n@L_ZCMD_Length            DS    FL4    Length of ZCMD\n@L_ISPF_Parms             DS    5AL4   ISPF Parm List\n@L_Rtn_Parms              DS    5AL4   Cmd processing routine parms\n                          DS    0D\n@L_Dynam_Length           EQU   *-@L_Dynam\n\n\n&PGMNAME CSECT\n\n         DROP  ,\n         POP   USING\n\n         TITLE 'LA0010: Process SORT Primary Command'\n\n         PUSH  USING\n\nLA0010   DS    0H\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Routine   : LA0010                                                 *\n*                                                                     *\n*  Abstract  : Process SORT primary command                           *\n*                                                                     *\n*  Inputs    : R1 : ---> A(@_Dynam)                                   *\n*                        A(31-bit Stack Pointer)                      *\n*                        A(24-bit Stack Pointer)                      *\n*                        A(operands of the SORT command)              *\n*                        Length of operands                           *\n*  Outputs   : R15: 0                                                 *\n*                                                                     *\n*  Notes     :                                                        *\n*                                                                     *\n*  History:    2002/02/12 SDDA030 - V2.16                             *\n*                                   New                               *\n*              2003/10/07 SDDA030 - V2.21                             *\n*                                   New, originally in L0010          *\n*              2006/04/21 SDDA030 - V2.24                             *\n*                                   Used standardised calling sequence*\n*                                                                     *\n*              ____/__/__ _______                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         STM   R14,R12,12(R13)          Save callers registers\n         LARL  R11,LA_Literals          Point to our literals\n         USING (LA_Literals,LA_Literals_End),R11 Tell the assembler\n\n         L     R12,0(0,R1)              A(@_Dynam)\n         USING @_Dynam,R12              Tell the assembler\n\n*-------------------------------------------------------------------*\n*    Get an area on the stack for our local storage                 *\n*-------------------------------------------------------------------*\n         L     R2,4(0,R1)               A(31-bit stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         SSCSTACK PUSH,                 Get stack area                 +\n               LEN=@LA_Dynam_Length,     this long                     +\n               STACK=(R2)                using this stack\n\n         LR    R3,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LHI   R1,@LA_Dynam_Length       Its length\n         LA    R14,0                    Clear source address\n         LA    R15,0                     and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R3                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*-------------------------------------------------------------------*\n         ST    R13,4(0,R1)              Chain\n         ST    R1,8(0,R13)               saveareas\n         LR    R13,R1                   Load dynam base\n         USING @LA_Dynam,R13            Assign a base\n         L     R15,@LA_Dynam+4          Get A(HSA)\n         LM    R0,R3,20(R15)            Restore callers registers\n\n         L     R15,4(0,R1)              A(31-bit Stack Pointer)\n         ST    R15,@LA_31Bit_Stack_Ptr_Ptr Save it\n         L     R15,8(0,R1)              A(24-bit Stack Pointer)\n         ST    R15,@LA_24Bit_Stack_Ptr_Ptr Save it\n\n*---------------------------------------------------------------------*\n*   Initialize our flags, and get the operand length and addr         *\n*---------------------------------------------------------------------*\n         NI    @LA_Cmd_Prompted,X'FF'-L'@LA_Cmd_Prompted\n\n         L     R0,16(0,R1)              Get operand length\n         L     R1,12(0,R1)              Get A(Operands)\n\nLA0020   DS    0H\n*---------------------------------------------------------------------*\n*   Initialize our sort fields ...                                    *\n*---------------------------------------------------------------------*\n         MVC   @LA_I00010_Sort_Field,=CL8' ' Clear sort field\n         MVI   @LA_I00010_Sort_Dir,C' ' and direction\n\n*---------------------------------------------------------------------*\n*   Check to see what we have as operands                             *\n*---------------------------------------------------------------------*\n         LTR   R14,R0                   Get the length\n         JZ    LA0100                   No operands, skip\n         LR    R15,R1                   OK, point to it (them)\n\nLA0050   DS    0H\n         CLI   0(R15),C' '              End of field?\n         JE    LA0060                   Yes, skip\n         AHI   R15,1                    Bump input pointer\n         BRCT  R14,LA0050               and check out next\nLA0060   DS    0H\n         LR    R3,R15                   A(Byte past end-of-field)\n         SR    R3,R1                    Length of field\n         JNP   LA0100                   Nothing, skip\n         C     R3,=AL4(L'@LA_I00010_Sort_Field) Too long?\n         JNH   LA0070                   No, skip\n         L     R3,=AL4(L'@LA_I00010_Sort_Field) Yes, use max length\nLA0070   DS    0H\n         AHI   R3,-1                    EX length\n         EX    R3,LA_OC                 Save it\n\n*-------------------------------------------------------------------*\n*    Extract the sort direction                                     *\n*-------------------------------------------------------------------*\n         LTR   R14,R14                  Anything left?\n         JZ    LA0100                   No, all done\nLA0080   DS    0H\n         CLI   0(R15),C' '              Leading space?\n         JNE   LA0090                   No, skip\n         AHI   R15,1                    Yes, bump pointer\n         BRCT  R14,LA0080               and check next\n         J     LA0100                   All done, skip\nLA0090   DS    0H\n         OC    @LA_I00010_Sort_Dir,0(R15) Save Sort direction\n\nLA0100   DS    0H\n*-------------------------------------------------------------------*\n*    If we don't have a sort field, and we have prompted, just      *\n*   exit without sorting                                            *\n*-------------------------------------------------------------------*\n         CLI   @LA_I00010_Sort_Field,C' ' Any sort field?\n         JNE   LA0110                   Yes, go sort\n         TM    @LA_Cmd_Prompted,L'@LA_Cmd_Prompted Did we prompt?\n         JZ    LA0120                   No, go prompt now\n         J     LA9010                   Yes, exit\n\nLA0110   DS    0H\n*-------------------------------------------------------------------*\n*    Invoke the sort routine                                        *\n*-------------------------------------------------------------------*\n         LA    R15,@_Dynam              A(Dynamic area)\n         ST    R15,@LA_Parms_Std        Save it\n         L     R15,@LA_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)\n         ST    R15,@LA_Parms_Std+4      Save it\n         L     R15,@LA_24Bit_Stack_Ptr_Ptr A(24-bit Stack Pointer)\n         ST    R15,@LA_Parms_Std+8      Save it\n         LA    R15,@LA_I00010_Sort_Field A(Offset)\n         ST    R15,@LA_Parms_I00010     Save it\n         LA    R15,@LA_I00010_Sort_Dir  A(Sort Direction)\n         ST    R15,@LA_Parms_I00010+4   Save it\n\n         LA    R1,@LA_Parms             A(Parms)\n         BRAS  R14,I00010               Go sort\n\n         LTR   R15,R15                  Did it work?\n         JZ    LA9010                   Yes, exit\n\nLA0120   DS    0H\n*-------------------------------------------------------------------*\n*    SORT was entered with no operands, or the sort failed (because *\n*   of an invalid sort field) - if we can, pop up a panel prompting *\n*   for the sort field and direction.                               *\n*-------------------------------------------------------------------*\n         CLI   LA_Prompt_Panel,C' '     Any prompt panel?\n         JE    LA0130                   No, just get out\n\n         LA    R15,=CL8'PQUERY'         ISPF Function\n         ST    R15,@LA_ISPF_Parms       Save it\n         LA    R15,LA_Prompt_Panel      A(Panel name)\n         ST    R15,@LA_ISPF_Parms+4     Save it\n         LA    R15,LA_Prompt_Panel      A(Dummy area name)\n         ST    R15,@LA_ISPF_Parms+8     Save it\n         LA    R15,@LA_ISPF_Parms+16    A(Return area)\n         ST    R15,@LA_ISPF_Parms+12    Save it\n         OI    @LA_ISPF_Parms+12,X'80'  Flag last parm\n         LA    R1,@LA_ISPF_Parms        A(ISPF Parms)\n         L     R15,@_ISPLINK            A(ISPF routine)\n         BASR  R14,R15                  Go check out panel\n         CHI   R15,8                    Was the panel found?\n         JH    LA0130                   No, just exit\n\n         LA    R15,=CL8'ADDPOP'         ISPF Function\n         ST    R15,@LA_ISPF_Parms       Save it\n         OI    @LA_ISPF_Parms,X'80'     Flag last parm\n         LA    R1,@LA_ISPF_Parms        A(ISPF Parms)\n         L     R15,@_ISPLINK            A(ISPF routine)\n         BASR  R14,R15                  Set pop-up environment\n\n         LA    R15,=CL8'DISPLAY'        ISPF Function\n         ST    R15,@LA_ISPF_Parms       Save it\n         LA    R15,LA_Prompt_Panel      A(Panel name)\n         ST    R15,@LA_ISPF_Parms+4     Save it\n         OI    @LA_ISPF_Parms+4,X'80'   Flag last parm\n         LA    R1,@LA_ISPF_Parms        A(ISPF Parms)\n         L     R15,@_ISPLINK            A(ISPF routine)\n         BASR  R14,R15                  Display pop-up prompt\n         LR    R3,R15                   Save our return code\n\n         LA    R15,=CL8'REMPOP'         ISPF Function\n         ST    R15,@LA_ISPF_Parms       Save it\n         OI    @LA_ISPF_Parms,X'80'     Flag last parm\n         LA    R1,@LA_ISPF_Parms        A(ISPF Parms)\n         L     R15,@_ISPLINK            A(ISPF routine)\n         BASR  R14,R15                  Reset pop-up environment\n\n         CHI   R3,8                     How did we do?\n         JH    LA0130                   Not good, skip\n         JE    LA0140                   END, RETURN, etc.\n\n         OI    @LA_Cmd_Prompted,L'@LA_Cmd_Prompted We have prompted\n\n         LA    R15,=CL8'VCOPY'          ISPF Function\n         ST    R15,@LA_ISPF_Parms       Save it\n         LA    R15,=CL8'ZCMD'           Variable we want\n         ST    R15,@LA_ISPF_Parms+4     Save it\n         LA    R15,@LA_ISPF_VCOPY_Lens  A(Length Address)\n         ST    R15,@LA_ISPF_Parms+8     Save it\n         LA    R15,@LA_ISPF_VCOPY_Ptrs  A(Variable)\n         ST    R15,@LA_ISPF_Parms+12    Save it\n         OI    @LA_ISPF_Parms+12,X'80'  Flag last parm\n         LA    R1,@LA_ISPF_Parms        A(ISPF Parms)\n         L     R15,@_ISPLINK            A(ISPF routine)\n         BASR  R14,R15                  Go get the variable\n\n         LTR   R15,R15                  Did we get it?\n         JNZ   LA0130                   No, exit\n\n*-------------------------------------------------------------------*\n*    The popup seemed to work; if the 1st word is SORT, point past  *\n*   it                                                              *\n*-------------------------------------------------------------------*\n         ICM   R0,B'1111',@LA_ISPF_VCOPY_Lens Get ZCMD length\n         JZ    LA0130                   Nothing, skip\n         ICM   R1,B'1111',@LA_ISPF_VCOPY_Ptrs A(ZCMD)\n         JZ    LA0130                   Nothing, skip\n\n         CHI   R0,5                     Room enough for 'SORT '?\n         JNH   LA0128                   No, skip\n         CLC   =C'SORT ',0(R1)          Yes, is it?\n         JNE   LA0128                   No, skip\n         AR    R0,R1                    Yes, point past end of string\n         AHI   R1,5                     and point past 'SORT '\nLA0122   DS    0H\n         CLI   0(R1),C' '               Start of operand?\n         JNE   LA0124                   Yes, skip\n         AHI   R1,1                     No, bump pointer\n         CR    R1,R0                    Any string left?\n         JL    LA0122                   Yes, keep checking\nLA0124   DS    0H\n         SR    R0,R1                    Set up new length\nLA0128   DS    0H\n\n         J     LA0020                   and start again\n\nLA0130   DS    0H\n*-------------------------------------------------------------------*\n*    The sort failed, and we are not prompting, so set the ISPF     *\n*   messages                                                        *\n*-------------------------------------------------------------------*\n         LA    R15,=CL8'VDEFINE'        ISPF Function\n         ST    R15,@LA_ISPF_Parms       Save it\n         LA    R15,=CL8'CHAR'           Character variables\n         ST    R15,@LA_ISPF_Parms+12 Save it\n\n         LA    R15,=CL8'ZEDSMSG'        Variable name\n         ST    R15,@LA_ISPF_Parms+4     Save it\n         LA    R15,LA_Sort_Fail_SMsg    Short message\n         ST    R15,@LA_ISPF_Parms+8     Save it\n         LA    R15,=AL4(L'LA_Sort_Fail_SMsg) Length of message\n         ST    R15,@LA_ISPF_Parms+16 Save it\n         OI    @LA_ISPF_Parms+16,X'80' Flag end of list\n         LA    R1,@LA_ISPF_Parms        A(Parmlist)\n         L     R15,@_ISPLINK            A(ISPF Interface)\n         BASR  R14,R15                  Go do it\n\n         LA    R15,=CL8'ZEDLMSG'        Variable name\n         ST    R15,@LA_ISPF_Parms+4     Save it\n         LA    R15,LA_Sort_Fail_LMsg    Long message\n         ST    R15,@LA_ISPF_Parms+8     Save it\n         LA    R15,=AL4(L'LA_Sort_Fail_LMsg) Length of message\n         ST    R15,@LA_ISPF_Parms+16 Save it\n         OI    @LA_ISPF_Parms+16,X'80' Flag end of list\n         LA    R1,@LA_ISPF_Parms        A(Parmlist)\n         L     R15,@_ISPLINK            A(ISPF Interface)\n         BASR  R14,R15                  Go do it\n\n         LA    R15,=CL8'SETMSG'         Yes, ISPF Function\n         ST    R15,@LA_ISPF_Parms       Save it\n         LA    R15,=CL8'ISRZ001'        A(Message ID)\n         ST    R15,@LA_ISPF_Parms+4     Save it\n         OI    @LA_ISPF_Parms+4,X'80' Mark end of list\n         LA    R1,@LA_ISPF_Parms        Point to ISPF parms\n         L     R15,@_ISPLINK            A(Interface routine)\n         BASR  R14,R15                  Go do it\n\n         J     LA0150                   and exit with error\n\nLA0140   DS    0H\n         LA    R15,0                    Clear return code\n         J     LA9010                   and exit\n\nLA0150   DS    0H\n         LA    R15,4                    No Sort done\n         J     LA9010                   and exit\n\nLA0160   DS    0H\n         LA    R15,8                    ZCMD other than SORT\n         J     LA9010                   and exit\n\n\nLA9010   DS    0H\n*-------------------------------------------------------------------*\n*    Free up our local storage ...                                  *\n*-------------------------------------------------------------------*\n         LR    R3,R15                   Save return code\n\n         LA    R1,@LA_Dynam             A(Local storage)\n         L     R2,@LA_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         L     R13,4(0,R13)             Rescue A(HSA)\n\n         SSCSTACK POP,                  Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=(R2)                on this stack\n\n         LR    R15,R3                   Restore return code\n\n*-------------------------------------------------------------------*\n*    ... and return to caller                                       *\n*-------------------------------------------------------------------*\n         L     R14,12(0,R13)            Restore return address\n         LM    R0,R12,20(R13)           Restore regs other than R15\n         BSM   0,R14                    and return\n\nLA_Literals DS  0H\n\nLA_OC    OC    @LA_I00010_Sort_Field(0),0(R1) Move Sort Field Name\n\nLA_Sort_Fail_SMsg     DC  C'Sort failed'\nLA_Sort_Fail_LMsg     DC  C'Invalid SORT field'\n\nLA_Prompt_Panel DC   CL8'&SORT_Prompt_Popup_Panel'\n\n         LTORG\n\nLA_Literals_End DS  0H\n\n\n@LA_Dynam                 DSECT\n                          DS    18F     O/S style save area\n@LA_31Bit_Stack_Ptr_Ptr   DS    AL4     A(31-bit Stack Ptr)\n@LA_24Bit_Stack_Ptr_Ptr   DS    AL4     A(24-bit Stack Ptr)\n@LA_DBLWD                 DS    D       Work area\n                          DS    X       Flag Byte\n@LA_Cmd_Prompted          EQU   *-1,X'80' 1... .... SORT from prompt\n                          DS    0F      Alignment\n@LA_Macros                EQU   *\n@LA_ISPF_Parms            DS    5AL4    ISPF Parm List\n@LA_ISPF_VCOPY_Lens       DS    AL4     ZCMD Length pointer\n@LA_ISPF_VCOPY_Ptrs       DS    AL4     ZCMD Data Ptr\n@LA_ZCMD_Ptr              DS    AL4     A(ZCMD)\n@LA_ZCMD_Length           DS    FL4     Length of ZCMD\n                          ORG   @LA_Macros\n@LA_I00010_Sort_Field     DS    CL8     Sort Field Name/Offset\n@LA_I00010_Sort_Dir       DS    C       Sort Direction\n                          ORG   ,\n\n@LA_Parms                 DS    0F      Parms for called rtns\n@LA_Parms_Std             DS    3AL4     Standard 3 parms\n@LA_Parms_Extra           EQU   *         Extra parms\n@LA_Parms_I00010          DS    2AL4         for I00010\n                          ORG   ,\n                          DS    0D\n@LA_Dynam_Length          EQU   *-@LA_Dynam\n\n\n&PGMNAME CSECT\n\n         DROP  ,\n         POP   USING\n\n         TITLE 'LB0010: Process ISPF(x) line command'\n\n         PUSH  USING\n\nLB0010   DS    0H\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Routine   : LB0010                                                 *\n*                                                                     *\n*  Abstract  : Change display type to ISPF(x) - SPACE display         *\n*                                                                     *\n*  Inputs    : R1 : ---> A(@_Dynam)                                   *\n*                        A(31-bit Stack Pointer)                      *\n*                        A(24-bit Stack Pointer)                      *\n*                        A(operands of the command)                   *\n*                        Length of operands                           *\n*  Outputs   : R15: 4                                                 *\n*                                                                     *\n*  Notes     :                                                        *\n*                                                                     *\n*  History:    2003/10/07 SDDA030 - V2.16                             *\n*                                   New                               *\n*              2006/04/21 SDDA030 - V2.24                             *\n*                                   Used standardised calling sequence*\n*                                                                     *\n*              ____/__/__ _______                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n\nLB0010A  DS    0H\n         STM   R14,R12,12(R13)          Save callers registers\n         LA    R4,0                     R4=0: ISPF(S)\n         J     LB0020\nLB0010B  DS    0H\n         STM   R14,R12,12(R13)          Save callers registers\n         LHI   R4,4                     R4=4: ISPF(E)\n         J     LB0020\nLB0010C  DS    0H\n         STM   R14,R12,12(R13)          Save callers registers\n         LHI   R4,8                     R4=8: ISPF(B)\n         J     LB0020\nLB0010D  DS    0H\n         STM   R14,R12,12(R13)          Save callers registers\n         LHI   R4,12                    R4=12: ISPF(N)\n         J     LB0020\nLB0020   DS    0H\n         LARL  R11,LB_Literals          Point to our literals\n         USING (LB_Literals,LB_Literals_End),R11 Tell the assembler\n\n         L     R12,0(0,R1)              A(@_Dynam)\n         USING @_Dynam,R12              Tell the assembler\n\n*-------------------------------------------------------------------*\n*    Get an area on the stack for our local storage                 *\n*-------------------------------------------------------------------*\n         L     R2,4(0,R1)               A(31-bit stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         SSCSTACK PUSH,                 Get stack area                 +\n               LEN=@LB_Dynam_Length,     this long                     +\n               STACK=(R2)                using this stack\n\n         LR    R3,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LHI   R1,@LB_Dynam_Length       Its length\n         LA    R14,0                    Clear source address\n         LA    R15,0                     and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R3                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*-------------------------------------------------------------------*\n         ST    R13,4(0,R1)              Chain\n         ST    R1,8(0,R13)               saveareas\n         LR    R13,R1                   Load dynam base\n         USING @LB_Dynam,R13            Assign a base\n         L     R15,@LB_Dynam+4          Get A(HSA)\n         LM    R0,R3,20(R15)            Restore callers registers\n\n         L     R15,4(0,R1)              A(31-bit Stack Pointer)\n         ST    R15,@LB_31Bit_Stack_Ptr_Ptr Save it\n         L     R15,8(0,R1)              A(24-bit Stack Pointer)\n         ST    R15,@LB_24Bit_Stack_Ptr_Ptr Save it\n\n*---------------------------------------------------------------------*\n*   Go process the command, based on the contents of R4               *\n*---------------------------------------------------------------------*\n\nLB0030   DS    0H\n*---------------------------------------------------------------------*\n*   ISPF(S) requested - if not already active, reset flags            *\n*---------------------------------------------------------------------*\n         LTR   R4,R4                    R4 = 0 (ISPF(S)?)\n         JNZ   LB0040                   No, skip\n         TM    @_ISPF_SPACE,L'@_ISPF_SPACE Already active?\n         JO    LB8010                   Yes, error\n         NI    @_ISPF_BRIF,X'FF'-L'@_ISPF_BRIF    No, reset\n         NI    @_ISPF_EDIF,X'FF'-L'@_ISPF_EDIF     ISPF\n         OI    @_ISPF_SPACE,L'@_ISPF_SPACE           flags\n         J     LB0070                   and skip\n\nLB0040   DS    0H\n*---------------------------------------------------------------------*\n*   ISPF(E) requested - if not already active, reset flags            *\n*---------------------------------------------------------------------*\n         CHI   R4,4                     R4 = 4 (ISPF(E)?)\n         JNE   LB0050                   No, skip\n         TM    @_ISPF_EDIF,L'@_ISPF_EDIF Already in EDIF?\n         JO    LB8010                   Yes, error\n         NI    @_ISPF_SPACE,X'FF'-L'@_ISPF_SPACE  No, reset\n         NI    @_ISPF_BRIF,X'FF'-L'@_ISPF_BRIF     ISPF\n         OI    @_ISPF_EDIF,L'@_ISPF_EDIF            flags\n         J     LB0070                   and skip\n\nLB0050   DS    0H\n*---------------------------------------------------------------------*\n*   ISPF(B) requested - if not already active, reset flags            *\n*---------------------------------------------------------------------*\n         CHI   R4,8                     R4 = 8 (ISPF(B)?)\n         JNE   LB0060                   No, skip\n         TM    @_ISPF_BRIF,L'@_ISPF_BRIF Already in BRIF?\n         JO    LB8010                   Yes, error\n         NI    @_ISPF_SPACE,X'FF'-L'@_ISPF_SPACE  No, reset\n         NI    @_ISPF_EDIF,X'FF'-L'@_ISPF_EDIF     ISPF\n         OI    @_ISPF_BRIF,L'@_ISPF_BRIF            flags\n         J     LB0070                   and skip\n\nLB0060   DS    0H\n*---------------------------------------------------------------------*\n*   ISPF(N) requested - reset all the ISPF flags                      *\n*---------------------------------------------------------------------*\n         CHI   R4,12                    R4 = 12 (ISPF(N)?)\n         JNE   LB0080                   No, ignore it\n         NI    @_ISPF_SPACE,X'FF'-L'@_ISPF_SPACE\n         NI    @_ISPF_EDIF,X'FF'-L'@_ISPF_EDIF\n         NI    @_ISPF_BRIF,X'FF'-L'@_ISPF_BRIF\n         NI    @_ISPF_Explicit,X'FF'-L'@_ISPF_Explicit\n         J     LB0070                   and skip\n\nLB0070   DS    0H\n*---------------------------------------------------------------------*\n*   Turn on the re-display requested flag ...                         *\n*---------------------------------------------------------------------*\n         OI    @_ReDisplay,L'@_ReDisplay Say we need a redisplay\n\nLB0080   DS    0H\n*---------------------------------------------------------------------*\n*   ... and exit                                                      *\n*---------------------------------------------------------------------*\n         LA    R15,0                    Clear return code\n         J     LB9010                   and exit\n\nLB8010   DS    0H\n*-------------------------------------------------------------------*\n*    The requested display mode is already active - define ISPF     *\n*   messages, and exit                                              *\n*-------------------------------------------------------------------*\n         LA    R15,=CL8'VDEFINE'        ISPF Function\n         ST    R15,@LB_ISPF_Parms       Save it\n         LA    R15,=CL8'CHAR'           Character variables\n         ST    R15,@LB_ISPF_Parms+12 Save it\n\n         LA    R15,=CL8'ZEDSMSG'        Variable name\n         ST    R15,@LB_ISPF_Parms+4     Save it\n         LA    R15,LB_Curr_Act_SMsg     Short message\n         ST    R15,@LB_ISPF_Parms+8     Save it\n         LA    R15,=AL4(L'LB_Curr_Act_SMsg) Length of message\n         ST    R15,@LB_ISPF_Parms+16 Save it\n         OI    @LB_ISPF_Parms+16,X'80' Flag end of list\n         LA    R1,@LB_ISPF_Parms        A(Parmlist)\n         L     R15,@_ISPLINK            A(ISPF Interface)\n         BASR  R14,R15                  Go do it\n\n         LA    R15,=CL8'ZEDLMSG'        Variable name\n         ST    R15,@LB_ISPF_Parms+4     Save it\n         LA    R15,LB_Curr_Act_LMsg     Long message\n         ST    R15,@LB_ISPF_Parms+8     Save it\n         LA    R15,=AL4(L'LB_Curr_Act_LMsg) Length of message\n         ST    R15,@LB_ISPF_Parms+16 Save it\n         OI    @LB_ISPF_Parms+16,X'80' Flag end of list\n         LA    R1,@LB_ISPF_Parms        A(Parmlist)\n         L     R15,@_ISPLINK            A(ISPF Interface)\n         BASR  R14,R15                  Go do it\n\n         LA    R15,=CL8'SETMSG'         Yes, ISPF Function\n         ST    R15,@LB_ISPF_Parms       Save it\n         LA    R15,=CL8'ISRZ001'        A(Message ID)\n         ST    R15,@LB_ISPF_Parms+4     Save it\n         OI    @LB_ISPF_Parms+4,X'80' Mark end of list\n         LA    R1,@LB_ISPF_Parms        Point to ISPF parms\n         L     R15,@_ISPLINK            A(Interface routine)\n         BASR  R14,R15                  Go do it\n\n         LA    R15,0                    Clear return code\n         J     LB9010                   and exit\n\nLB9010   DS    0H\n*-------------------------------------------------------------------*\n*    Free up our local storage ...                                  *\n*-------------------------------------------------------------------*\n         LR    R3,R15                   Save return code\n\n         LA    R1,@LB_Dynam             A(Local storage)\n         L     R2,@LB_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         L     R13,4(0,R13)             Rescue A(HSA)\n\n         SSCSTACK POP,                  Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=(R2)                on this stack\n\n         LR    R15,R3                   Restore return code\n\n*-------------------------------------------------------------------*\n*    ... and return to caller                                       *\n*-------------------------------------------------------------------*\n         L     R14,12(0,R13)            Restore return address\n         LM    R0,R12,20(R13)           Restore regs other than R15\n         BSM   0,R14                    and return\n\nLB_Literals DS  0H\n\nLB_Curr_Act_SMsg     DC  C'Currently active'\nLB_Curr_Act_LMsg     DC  C'Requested display mode already active'\n\n         LTORG\n\nLB_Literals_End DS  0H\n\n\n@LB_Dynam                 DSECT\n                          DS    18F     O/S style save area\n@LB_31Bit_Stack_Ptr_Ptr   DS    AL4     A(31-bit Stack Ptr)\n@LB_24Bit_Stack_Ptr_Ptr   DS    AL4     A(24-bit Stack Ptr)\n@LB_ISPF_Parms            DS    5AL4    ISPF Parm List\n                          DS    0D\n@LB_Dynam_Length          EQU   *-@LB_Dynam\n\n\n&PGMNAME CSECT\n\n         DROP  ,\n         POP   USING\n\n         TITLE 'LC0010: Process OUTPUT Primary Command'\n\n         PUSH  USING\n\nLC0010   DS    0H\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Routine   : LC0010                                                 *\n*                                                                     *\n*  Abstract  : Process OUTPUT primary command                         *\n*                                                                     *\n*  Inputs    : R1 : ---> A(@_Dynam)                                   *\n*                        A(31-bit Stack Pointer)                      *\n*                        A(24-bit Stack Pointer)                      *\n*                        A(line command operands)                     *\n*                        Length of operands                           *\n*  Outputs   : R15: 0                                                 *\n*                                                                     *\n*  Notes     :                                                        *\n*                                                                     *\n*  History:    2003/10/07 SDDA030 - V2.21                             *\n*                                   New                               *\n*              2006/04/21 SDDA030 - V2.24                             *\n*                                   Used standardised calling sequence*\n*                                                                     *\n*              ____/__/__ _______                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         STM   R14,R12,12(R13)          Save callers registers\n         LARL  R11,LC_Literals          Point to our literals\n         USING (LC_Literals,LC_Literals_End),R11 Tell the assembler\n\n         L     R12,0(0,R1)              A(@_Dynam)\n         USING @_Dynam,R12              Tell the assembler\n\n*-------------------------------------------------------------------*\n*    Get an area on the stack for our local storage                 *\n*-------------------------------------------------------------------*\n         L     R2,4(0,R1)               A(31-bit stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         SSCSTACK PUSH,                 Get stack area                 +\n               LEN=@LC_Dynam_Length,     this long                     +\n               STACK=(R2)                using this stack\n\n         LR    R3,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LHI   R1,@LC_Dynam_Length       Its length\n         LA    R14,0                    Clear source address\n         LA    R15,0                     and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R3                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*-------------------------------------------------------------------*\n         ST    R13,4(0,R1)              Chain\n         ST    R1,8(0,R13)               saveareas\n         LR    R13,R1                   Load dynam base\n         USING @LC_Dynam,R13            Assign a base\n         L     R15,@LC_Dynam+4          Get A(HSA)\n         LM    R0,R3,20(R15)            Restore callers registers\n\n         L     R15,4(0,R1)              A(31-bit Stack Pointer)\n         ST    R15,@LC_31Bit_Stack_Ptr_Ptr Save it\n         L     R15,8(0,R1)              A(24-bit Stack Pointer)\n         ST    R15,@LC_24Bit_Stack_Ptr_Ptr Save it\n\n\n*-------------------------------------------------------------------*\n*    This option is not yet supported                               *\n*-------------------------------------------------------------------*\n         LA    R15,=CL8'VDEFINE'        ISPF Function\n         ST    R15,@LC_ISPF_Parms       Save it\n         LA    R15,=CL8'CHAR'           Character variables\n         ST    R15,@LC_ISPF_Parms+12 Save it\n\n         LA    R15,=CL8'ZEDSMSG'        Variable name\n         ST    R15,@LC_ISPF_Parms+4     Save it\n         LA    R15,LC_Unsupport_SMsg    Short message\n         ST    R15,@LC_ISPF_Parms+8     Save it\n         LA    R15,=AL4(L'LC_Unsupport_SMsg) Length of message\n         ST    R15,@LC_ISPF_Parms+16 Save it\n         OI    @LC_ISPF_Parms+16,X'80' Flag end of list\n         LA    R1,@LC_ISPF_Parms        A(Parmlist)\n         L     R15,@_ISPLINK            A(ISPF Interface)\n         BASR  R14,R15                  Go do it\n\n         LA    R15,=CL8'ZEDLMSG'        Variable name\n         ST    R15,@LC_ISPF_Parms+4     Save it\n         LA    R15,LC_Unsupport_LMsg    Long message\n         ST    R15,@LC_ISPF_Parms+8     Save it\n         LA    R15,=AL4(L'LC_Unsupport_LMsg) Length of message\n         ST    R15,@LC_ISPF_Parms+16 Save it\n         OI    @LC_ISPF_Parms+16,X'80' Flag end of list\n         LA    R1,@LC_ISPF_Parms        A(Parmlist)\n         L     R15,@_ISPLINK            A(ISPF Interface)\n         BASR  R14,R15                  Go do it\n\n         LA    R15,=CL8'SETMSG'         Yes, ISPF Function\n         ST    R15,@LC_ISPF_Parms       Save it\n         LA    R15,=CL8'ISRZ001'        A(Message ID)\n         ST    R15,@LC_ISPF_Parms+4     Save it\n         OI    @LC_ISPF_Parms+4,X'80' Mark end of list\n         LA    R1,@LC_ISPF_Parms        Point to ISPF parms\n         L     R15,@_ISPLINK            A(Interface routine)\n         BASR  R14,R15                  Go do it\n\n         LA    R15,0                    Clear return code\n         J     LC9010                   and exit\n\n\nLC9010   DS    0H\n*-------------------------------------------------------------------*\n*    Free up our local storage ...                                  *\n*-------------------------------------------------------------------*\n         LR    R3,R15                   Save return code\n\n         LA    R1,@LC_Dynam             A(Local storage)\n         L     R2,@LC_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         L     R13,4(0,R13)             Rescue A(HSA)\n\n         SSCSTACK POP,                  Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=(R2)                on this stack\n\n         LR    R15,R3                   Restore return code\n\n*-------------------------------------------------------------------*\n*    ... and return to caller                                       *\n*-------------------------------------------------------------------*\n         L     R14,12(0,R13)            Restore return address\n         LM    R0,R12,20(R13)           Restore regs other than R15\n         BSM   0,R14                    and return\n\nLC_Literals DS  0H\n\nLC_Unsupport_SMsg     DC   C'Unsupported'\nLC_Unsupport_LMsg     DC   C'This command is not yet implemented'\n\n\n         LTORG\n\nLC_Literals_End DS  0H\n\n\n@LC_Dynam                 DSECT\n                          DS    18F    O/S style save area\n@LC_31Bit_Stack_Ptr_Ptr   DS    AL4    A(31-bit Stack Ptr)\n@LC_24Bit_Stack_Ptr_Ptr   DS    AL4    A(24-bit Stack Ptr)\n                          DS    0F     Alignment\n@LC_ISPF_Parms            DS    5AL4   ISPF Parm List\n@LC_ISPF_VCOPY_Lens       DS    FL4    ZCMD Length\n@LC_ISPF_VCOPY_Ptrs       DS    AL4    ZCMD Address\n@LC_ZCMD_Ptr              DS    AL4    A(ZCMD)\n@LC_ZCMD_Length           DS    FL4    Length of ZCMD\n                          DS    0D\n@LC_Dynam_Length          EQU   *-@LC_Dynam\n\n\n&PGMNAME CSECT\n\n         DROP  ,\n         POP   USING\n         TITLE 'S00010: WAIT for subtasks to complete'\n\n         PUSH  USING\n\nS00010   DS    0H\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Routine   : S00010                                                 *\n*                                                                     *\n*  Abstract  : WAIT for subtasks to complete, DETACH them, and free   *\n*              SubTask_Area                                           *\n*                                                                     *\n*  Inputs    : R1 : ---> A(@_Dynam)                                   *\n*                        A(31-bit Stack Pointer)                      *\n*                        A(24-bit Stack Pointer)                      *\n*  Outputs   : R15: 0:                                                *\n*                                                                     *\n*  Notes     :                                                        *\n*                                                                     *\n*  History:    2003/10/07 SDDA030 - V2.21                             *\n*                                   New.                              *\n*              2006/04/21 SDDA030 - V2.24                             *\n*                                   Used standardised calling sequence*\n*              ____/__/__ _______                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         STM   R14,R12,12(R13)          Save callers registers\n         LARL  R11,S_Literals           Point to our literals\n         USING (S_Literals,S_Literals_End),R11 Tell the assembler\n\n         L     R12,0(0,R1)              A(@_Dynam)\n         USING @_Dynam,R12              Tell the assembler\n\n*-------------------------------------------------------------------*\n*    Get an area on the stack for our local storage                 *\n*-------------------------------------------------------------------*\n         L     R2,4(0,R1)               A(31-bit stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         SSCSTACK PUSH,                 Get stack area                 +\n               LEN=@S_Dynam_Length,      this long                     +\n               STACK=(R2)                using this stack\n\n         LR    R3,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LHI   R1,@S_Dynam_Length        Its length\n         LA    R14,0                    Clear source address\n         LA    R15,0                     and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R3                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*-------------------------------------------------------------------*\n         ST    R13,4(0,R1)              Chain\n         ST    R1,8(0,R13)               saveareas\n         LR    R13,R1                   Load dynam base\n         USING @S_Dynam,R13             Assign a base\n         L     R15,@S_Dynam+4           Get A(HSA)\n         LM    R0,R3,20(R15)            Restore callers registers\n\n         L     R15,4(0,R1)              A(31-bit Stack Pointer)\n         ST    R15,@S_31Bit_Stack_Ptr_Ptr Save it\n         L     R15,8(0,R1)              A(24-bit Stack Pointer)\n         ST    R15,@S_24Bit_Stack_Ptr_Ptr Save it\n\n*-------------------------------------------------------------------*\n*    If there is a Subtask_Area ...                                 *\n*-------------------------------------------------------------------*\n         ICM   R1,B'1111',@_SubTask_Area_Ptr Get A(SubTask Area)\n         JZ    S00100                  None, exit quick smart\n         ICM   R0,B'1111',SubTask_Area_Hdr_Count-SubTask_Area_Hdr(R1)\n         JZ    S00100                  None, go free it\n\n*-------------------------------------------------------------------*\n*    ... get an area for our ECB list                               *\n*-------------------------------------------------------------------*\n         MHI   R0,4                     (# ents * len of ECB ptr)\n\n         L     R2,@S_31Bit_Stack_Ptr_Ptr A(31-bit stack Ptr)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         SSCSTACK PUSH,                 Get stack area                 +\n               LEN=(0),                  this long                     +\n               STACK=(R2)                using this stack\n\n         ST    R1,@S_ECBLIST_Ptr       Save it\n\nS00020   DS    0H\n*-------------------------------------------------------------------*\n*    Build our ECBLIST, containing a pointer to each ECB that has   *\n*   not yet been POSTed. If the ECB has been POSTed, DETACH the TCB,*\n*   unless we have already done so.                                 *\n*-------------------------------------------------------------------*\n         ICM   R15,B'1111',@_SubTask_Area_Ptr A(SubTask Area)\n         JZ    S00100                  None, all done\n         ICM   R14,B'1111',SubTask_Area_Hdr_Count-SubTask_Area_Hdr(R15)\n         JZ    S00100                  None, exit\n         AHI   R15,SubTask_Area_Hdr_Length A(1st SubTask Entry)\n         ICM   R1,B'1111',@S_ECBLIST_Ptr A(Our ECBLIST)\n         JZ    S00100                  None, all done\nS00030   DS    0H\n         TM    SubTask_Area_Ent_ECB-SubTask_Area_Ent(R15),X'40' POSTed?\n         JO    S00040                  Yes, go DETACH TCB\n         ST    R15,0(0,R1)             No, Add to ECBLIST\n         AHI   R1,4                    Bump ECBLIST Ptr\n         J     S00050                  and skip\nS00040   DS    0H\n         ICM   R0,B'1111',SubTask_Area_Ent_TCB-SubTask_Area_Ent(R15)\n         JZ    S00050                  No TCB, skip\n         STM   R14,R1,@S_RSave         Save our registers\n         LA    R1,SubTask_Area_Ent_TCB-SubTask_Area_Ent(R15)\n         DETACH (1),                    Yes, DETACH it                 +\n               STAE=NO                   without invoking ESTAE Rtn\n         LM    R14,R1,@S_RSave         Restore our registers\n         LA    R0,0                    Clear TCB pointer\n         ST    R0,SubTask_Area_Ent_TCB-SubTask_Area_Ent(R15)\nS00050   DS    0H\n         AHI   R15,SubTask_Area_Ent_Length A(Stuff for next TCB)\n         BRCT  R14,S00030              and check it out\n\n*-------------------------------------------------------------------*\n*    If there are any ECBs not yet POSTed ...                       *\n*-------------------------------------------------------------------*\n         L     R0,@S_ECBLIST_Ptr       A(ECBLIST)\n         CR    R0,R1                   Anything in it?\n         JE    S00100                  No, we're all done\n\n*-------------------------------------------------------------------*\n*    ... WAIT for them to complete ...                              *\n*-------------------------------------------------------------------*\n         AHI   R1,-4                   Yes, back up to A(last ECB)\n         OI    0(R1),X'80'             Flag it as last\n         SLR   R1,R0                   Calculate nbr\n         SRL   R1,2                     of ECBS in\n         AHI   R1,1                     list\n         LR    R0,R1                   In proper register\n         L     R1,@S_ECBLIST_Ptr       A(ECB list)\n         WAIT  (R0),ECBLIST=(R1)       Wait for our subtasks\n\n*-------------------------------------------------------------------*\n*    ... and do it all again                                        *\n*-------------------------------------------------------------------*\n         J     S00020                  and do it all again\n\nS00100   DS    0H\n*-------------------------------------------------------------------*\n*    We're all done here, so free up the ECBLIST, if required ...   *\n*-------------------------------------------------------------------*\n         ICM   R1,B'1111',@S_ECBLIST_Ptr A(ECBLIST)\n         JZ    S00110                  None, skip\n\n         L     R2,@S_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         SSCSTACK POP,                  Free the ECBLIST               +\n               ADDR=(R1),                starting here                 +\n               STACK=(R2)                on this stack\n\nS00110   DS    0H\n*-------------------------------------------------------------------*\n*    ... and the SubTask_Area, if required ...                      *\n*-------------------------------------------------------------------*\n         ICM   R1,B'1111',@_SubTask_Area_Ptr A(SubTask Area)\n         JZ    S00120                  Nothing, skip\n         L     R0,SubTask_Area_Hdr_Len-SubTask_Area_Hdr(0,R1) Length\n\n         BASR  R2,0\n         USING (*,S00120_End-1),R2\n         STORAGE RELEASE,               Free the SubTask Area          +\n               ADDR=(1),                 starting here                 +\n               LENGTH=(0)                for this long\nS00120_End DS  0H\n         DROP  R2\n\n         LA    R0,0                     Clear work reg\n         ST    R0,@_SubTask_Area_Ptr    No more SubTask Area\n\nS00120   DS    0H\n*-------------------------------------------------------------------*\n*    ... and exit.                                                  *\n*-------------------------------------------------------------------*\n         LA    R15,0                    Clear return code\n         J     S90010                   and exit\n\nS90010   DS    0H\n*-------------------------------------------------------------------*\n*    Free up our local storage ...                                  *\n*-------------------------------------------------------------------*\n         LR    R3,R15                   Save return code\n\n         LA    R1,@S_Dynam              A(Local storage)\n         L     R2,@S_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         L     R13,4(0,R13)             Rescue A(HSA)\n\n         SSCSTACK POP,                  Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=(R2)                on this stack\n\n         LR    R15,R3                   Restore return code\n\n*-------------------------------------------------------------------*\n*    ... and return to caller                                       *\n*-------------------------------------------------------------------*\n         L     R14,12(0,R13)            Restore return address\n         LM    R0,R12,20(R13)           Restore callers regs\n         BSM   0,R14                    and return\n\nS_Literals  DS  0H\n\n         LTORG\n\nS_Literals_End  DS  0H\n\n\n@S_Dynam                  DSECT\n@S_SaveArea               DS    18F    O/S style save area\n@S_31Bit_Stack_Ptr_Ptr    DS    AL4    A(31-bit Stack Ptr)\n@S_24Bit_Stack_Ptr_Ptr    DS    AL4    A(24-bit Stack Ptr)\n\n@S_ECBLIST_Ptr            DS    AL4    A(ECBLIST)\n@S_RSave                  DS    4FL4   Temp reg save area\n\n                          DS    0D\n@S_Dynam_Length           EQU   *-@S_Dynam\n\n\n&PGMNAME CSECT\n\n         DROP  ,\n         POP   USING\n         TITLE 'T00010: Return SMS Storgrp'\n\n         PUSH  USING\n\nT00010   DS    0H\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Routine   : T00010                                                 *\n*                                                                     *\n*  Abstract  : Return pointers to the STORGRP name and SMS Status     *\n*              for a volser                                           *\n*                                                                     *\n*  Inputs    : R1 : ---> A(@_Dynam)                                   *\n*                        A(31-bit Stack Pointer)                      *\n*                        A(24-bit Stack Pointer)                      *\n*                        A(Volser)                                    *\n*                        A(VLD Anchor)                                *\n*  Outputs   : R15: 0: STORGRP found                                  *\n*                   4: STORGRP not found (??)                         *\n*                   8: SMS not active                                 *\n*              R0    : A(SMS Status)                                  *\n*              R1    : A(STORGRP Len, Name)                           *\n*                                                                     *\n*  Notes     : To try to reduce the number of times we have to call   *\n*              SMS, whenever we ask SMS about the StorGrp for a       *\n*              volume, we also ask for all the volsers in that        *\n*              StorGrp. We chain these VLDs (Volume Definitions), and *\n*              search them for the volser before asking SMS for the   *\n*              StorGrp.                                               *\n*              If A(Volser) is 0, all in-storage VLDs, chained off    *\n*              VLD Anchor, are freed.                                 *\n*              The IEFSSREQs to SMS are modelled on those found in    *\n*              SHOWMVS (Thanks Gilbert/Roland).                       *\n*              We clobber the VLDPID field and the next 2 bytes with: *\n*               0-3 A(Next VLD)                                       *\n*               4-7 Length of VLD                                     *\n*               8-9 SMS System number                                 *\n*                                                                     *\n*  History:    2002/03/11 SDDA030 - V2.17                             *\n*                                 - New                               *\n*              2003/10/07 SDDA030 - V2.21                             *\n*                                 - Corrected bug getting correct SMS *\n*                                   status (we make an additional     *\n*                                   call to SMS to get the system-ids)*\n*              2004/10/15 SDDA030 - V2.22                             *\n*                                 - Corrected bug where we overlayed  *\n*                                   the SMS System number with the    *\n*                                   length of the VLD.                *\n*                                 - Resequenced labels                *\n*              2006/04/21 SDDA030 - V2.24                             *\n*                                 - Used standardised calling sequence*\n*              ____/__/__ _______                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         STM   R14,R12,12(R13)          Save callers registers\n         LARL  R11,T_Literals           Point to our literals\n         USING (T_Literals,T_Literals_End),R11 Tell the assembler\n\n         L     R12,0(0,R1)              A(@_Dynam)\n         USING @_Dynam,R12              Tell the assembler\n\n*-------------------------------------------------------------------*\n*    Get an area on the stack for our local storage                 *\n*-------------------------------------------------------------------*\n         L     R2,4(0,R1)               A(31-bit stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         SSCSTACK PUSH,                 Get stack area                 +\n               LEN=@T_Dynam_Length,      this long                     +\n               STACK=(R2)                using this stack\n\n         LR    R3,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LHI   R1,@T_Dynam_Length        Its length\n         LA    R14,0                    Clear source address\n         LA    R15,0                     and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R3                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*-------------------------------------------------------------------*\n         ST    R13,4(0,R1)              Chain\n         ST    R1,8(0,R13)               saveareas\n         LR    R13,R1                   Load dynam base\n         USING @T_Dynam,R13             Assign a base\n         L     R15,@T_Dynam+4           Get A(HSA)\n         LM    R0,R3,20(R15)            Restore callers registers\n\n         L     R15,4(0,R1)              A(31-bit Stack Pointer)\n         ST    R15,@T_31Bit_Stack_Ptr_Ptr Save it\n         L     R15,8(0,R1)              A(24-bit Stack Pointer)\n         ST    R15,@T_24Bit_Stack_Ptr_Ptr Save it\n\n*-------------------------------------------------------------------*\n*    If we have a volser ...                                        *\n*-------------------------------------------------------------------*\n         ICM   R3,B'1111',12(R1)       Get A(Volser)\n         JZ    T00130                  None, free VLDs\n\n*-------------------------------------------------------------------*\n*    ... check the existing VLDs for the volser                     *\n*-------------------------------------------------------------------*\n         L     R1,16(0,R1)             A(VLD Chain Anchor)\n         AHI   R1,-(VLDPID-VLD)        Pretend we are a VLD Ptr\n         NI    @T_Volser_in_VLD,X'FF'-L'@T_Volser_in_VLD Off flag\n         LHI   R15,-1                  We have no\n         STH   R15,@T_SMS_SYSNum        no SMS System nbr\n         J     T00050                  and run chain\nT00020   DS    0H\n         ICM   R14,B'1111',VLDPCNT-VLD(R1) Number vols\n         JNP   T00050                  None, try next VLD\n         LA    R15,VLDEF-VLD(0,R1)     OK, point to 1st\nT00030   DS    0H\n         CLC   =HL2'6',VLDVSLEN-VLDEF(R15)  Right length for a volser?\n         JNE   T00040                  No, skip this entry\n         CLC   VLDVSER-VLDEF(L'VLDVSER,R15),0(R3)\n         JE    T00110                  Found our volser, skip\nT00040   DS    0H\n         A     R15,VLDPLEN-VLD(0,R1)   A(Next VLD)\n         BRCT  R14,T00030              and check it out\n         TM    @T_Volser_in_VLD,L'@T_Volser_in_VLD Should it be here?\n         JNO   T00050                  Not necessarily, OK\n         DC    H'0'                    It should be, ABEND\nT00050   DS    0H\n         ICM   R15,B'1111',VLDPID-VLD(R1) A(Next VLD)\n         JZ    T00060                  None, skip\n         LR    R1,R15                  Load up proper register\n         MVC   @T_SMS_SYSNum,VLDPID+8-VLD(R1) Save SMS Sys 'number'\n         J     T00020                  and check it out\n\nT00060   DS    0H\n*-------------------------------------------------------------------*\n*    We couldn't find the volser in our in-storage VLDs (meaning    *\n*   that this is the 1st volser we have come across in this         *\n*   STORGRP), so go get the STORGRP name from SMS.                  *\n*-------------------------------------------------------------------*\n         ST    R1,@T_Last_VLD_Ptr      Save A(Last VLD)\n         LH    R15,@T_SMS_SYSNum       Get SMS system 'number'\n         CHI   R15,-1                  Do we have one?\n         JNE   T00100                  Yes, OK\n\n*-------------------------------------------------------------------*\n*    This is the 1st VLD we are getting - before we do so, get the  *\n*   base configuration data (we have to know our system 'number' to *\n*   get the correct SMS status for the volumes).                    *\n*-------------------------------------------------------------------*\n         L     R15,CVTPTR              Point to CVT\n         L     R15,CVTJESCT-CVTMAP(,R15) JES Communication Table\n         L     R15,JESCTEXT-JESCT(,R15)  JESCT Extension\n         ICM   R15,B'1111',JESSMSIB-JESPEXT(R15) SMS SSIB\n         JZ    T00100                  SMS unavailable, skip\n\n         XC    @T_SMS_SSOB,@T_SMS_SSOB Clear the SSOB\n         MVI   @T_SMS_SSOB+SSOBLEN+1-SSOB,SSOBHSIZ Set length\n         MVC   @T_SMS_SSOB+SSOBID-SSOB(L'SSOBID),=C'SSOB' ID it\n         MVI   @T_SMS_SSOB+SSOBFUNC+1-SSOB,SSOBSSMS Function\n         L     R15,CVTPTR              Point to CVT\n         L     R15,CVTJESCT-CVTMAP(,R15) JES Communication Table\n         L     R15,JESCTEXT-JESCT(,R15)  JESCT Extension\n         L     R15,JESSMSIB-JESPEXT(R15) SMS SSIB\n         ST    R15,@T_SMS_SSOB+SSOBSSIB-SSOB Save it\n\n         LA    R15,@T_SMS_SSSA         SSSA Work Area\n         ST    R15,@T_SMS_SSOB+SSOBINDV-SSOB Update SSOB\n\n         XC    @T_SMS_SSSA,@T_SMS_SSSA Clear SSSA\n         LHI   R15,L'@T_SMS_SSSA       Get its length\n         STH   R15,@T_SMS_SSSA+SSSALEN-IEFSSSA Update SSSA\n         MVC   @T_SMS_SSSA+SSSAID-IEFSSSA(L'SSSAID),=C'SSSA' ID it\n         MVI   @T_SMS_SSSA+SSSAVER+1-IEFSSSA,SSOBSSVR Version\n         MVI   @T_SMS_SSSA+SSSASFN+1-IEFSSSA,SSSAACTV Sub-Function\n         MVI   @T_SMS_SSSA+SSSAIFLG-IEFSSSA,SSSANAUT Non-APF\n\n         MVI   @T_SMS_SSSA+SSSA1TYP-IEFSSSA,SSSA1CON Return Config\n\n         LHI   R15,L'@T_SMS_BCD                Len of Config Data\n         ST    R15,@T_SMS_SSSA+SSSA1LEN-IEFSSSA Save it\n         LA    R15,@T_SMS_BCD                  A(Config Data)\n         ST    R15,@T_SMS_SSSA+SSSA1PTR-IEFSSSA Save the address\n\n         LA    R15,@T_SMS_SSOB         A(SSOB)\n         ST    R15,@T_SMS_SSOB_Ptr     Save the address\n         LA    R1,@T_SMS_SSOB_Ptr      Point to the address\n\n         IEFSSREQ                      Call SMS\n\n         LTR   R15,R15                 SMS active?\n         JNZ   T00100                  No, exit quick smart\n\n         ICM   R15,B'1111',@T_SMS_SSOB+SSOBRETN-SSOB Check RC\n         JNZ   T00100                  Not good, skip SMS stuff\n\n*-------------------------------------------------------------------*\n*    We now have an IGDBCD, which is not documented or distributed  *\n*   by IBM. From SHOWMVS, we know that this data will contain our   *\n*   system ID (assuming, of course, we're SMSd). Rather than define *\n*   our own DSECT for this area, we search it for our system-id; if *\n*   we find it, we save our system 'number'.                        *\n*-------------------------------------------------------------------*\n         L     R1,CVTPTR                A(CVT)\n         LA    R1,CVTSNAME-CVT(R1)      A(Our System name)\n         LA    R15,@T_SMS_BCD           Point to config data\n         LHI   R14,L'@T_SMS_BCD-(L'CVTSNAME-1) Len of config data\nT00070   DS    0H\n         CLC   0(L'CVTSNAME,R1),0(R15)  Found our system?\n         JE    T00080                   Yes, skip\n         LA    R15,1(0,R15)             Not yet, bump pointer\n         BRCT  R14,T00070               and keep checking\n         J     T80010                   Not good, exit with error\nT00080   DS    0H\n         LA    R14,@T_SMS_BCD           A(Start of area)\n         LR    R0,R15                   Save A(Our name)\nT00090   DS    0H\n         AHI   R15,-L'CVTSNAME          Back up to prev system\n         CR    R15,R14                  Too far?\n         JL    T80010                   Yes, we're lost\n         TRT   0(L'CVTSNAME,R15),T_TRT  A valid sysname?\n         JZ    T00090                   Yes, check prev\n\n         AHI   R0,-L'CVTSNAME           Offset of last good name\n         SR    R0,R15                   offset to our sysname\n         SRDL  R0,32                    into correct register\n         LA    R15,L'CVTSNAME           Len of 1 system name\n         DR    R0,R15                   Calc system 'number'\n         STH   R1,@T_SMS_SYSNum         Save it\n\nT00100   DS    0H\n         L     R15,CVTPTR              Point to CVT\n         L     R15,CVTJESCT-CVTMAP(,R15) JES Communication Table\n         L     R15,JESCTEXT-JESCT(,R15)  JESCT Extension\n         ICM   R15,B'1111',JESSMSIB-JESPEXT(R15) SMS SSIB\n         JZ    T80010                  SMS unavailable, skip\n\n         XC    @T_SMS_SSOB,@T_SMS_SSOB Clear the SSOB\n         MVI   @T_SMS_SSOB+SSOBLEN+1-SSOB,SSOBHSIZ Set length\n         MVC   @T_SMS_SSOB+SSOBID-SSOB(L'SSOBID),=C'SSOB' ID it\n         MVI   @T_SMS_SSOB+SSOBFUNC+1-SSOB,SSOBSSMS Function\n         L     R15,CVTPTR              Point to CVT\n         L     R15,CVTJESCT-CVTMAP(,R15) JES Communication Table\n         L     R15,JESCTEXT-JESCT(,R15)  JESCT Extension\n         L     R15,JESSMSIB-JESPEXT(R15) SMS SSIB\n         ST    R15,@T_SMS_SSOB+SSOBSSIB-SSOB Save it\n\n         LA    R15,@T_SMS_SSSA         SSSA Work Area\n         ST    R15,@T_SMS_SSOB+SSOBINDV-SSOB Update SSOB\n\n         XC    @T_SMS_SSSA,@T_SMS_SSSA Clear SSSA\n         LHI   R15,L'@T_SMS_SSSA       Get its length\n         STH   R15,@T_SMS_SSSA+SSSALEN-IEFSSSA Update SSSA\n         MVC   @T_SMS_SSSA+SSSAID-IEFSSSA(L'SSSAID),=C'SSSA' ID it\n         MVI   @T_SMS_SSSA+SSSAVER+1-IEFSSSA,SSOBSSVR Version\n         MVI   @T_SMS_SSSA+SSSASFN+1-IEFSSSA,SSSAACTV Sub-Function\n         MVI   @T_SMS_SSSA+SSSAIFLG-IEFSSSA,SSSANAUT Non-APF\n\n         MVI   @T_SMS_SSSA+SSSA1TYP-IEFSSSA,SSSA1VOL Return VLD\n         MVI   @T_SMS_SSSA+SSSA1CNT+3-IEFSSSA,1   1 construct\n         MVI   @T_SMS_SSSA+SSSA1NML+1-IEFSSSA,L'UCBVOLI  Volser Len\n         MVC   @T_SMS_SSSA+SSSA1NAM-IEFSSSA(L'UCBVOLI),0(R3)\n\n         LHI   R15,L'@T_SMS_VLD                Len of VLD\n         ST    R15,@T_SMS_SSSA+SSSA1LEN-IEFSSSA Save it\n         LA    R15,@T_SMS_VLD                  Point VLD\n         ST    R15,@T_SMS_SSSA+SSSA1PTR-IEFSSSA Save the address\n\n         LA    R15,@T_SMS_SSOB         A(SSOB)\n         ST    R15,@T_SMS_SSOB_Ptr     Save the address\n         LA    R1,@T_SMS_SSOB_Ptr      Point to the address\n\n         IEFSSREQ                      Call SMS\n\n         LTR   R15,R15                 SMS active?\n         JNZ   T80010                  No, exit quick smart\n\n         ICM   R15,B'1111',@T_SMS_SSOB+SSOBRETN-SSOB Check RC\n         JNZ   T80020                  Not good, skip SMS stuff\n\n*-------------------------------------------------------------------*\n*    We have the SMS Storgrp for this volser, so now make another   *\n*   request to SMS for all volsers in this STORGRP.                 *\n*-------------------------------------------------------------------*\n         XC    @T_SMS_SSOB,@T_SMS_SSOB Clear the SSOB\n         MVI   @T_SMS_SSOB+SSOBLEN+1-SSOB,SSOBHSIZ Set length\n         MVC   @T_SMS_SSOB+SSOBID-SSOB(L'SSOBID),=C'SSOB' ID it\n         MVI   @T_SMS_SSOB+SSOBFUNC+1-SSOB,SSOBSSMS Function\n         L     R15,CVTPTR              Point to CVT\n         L     R15,CVTJESCT-CVTMAP(,R15) JES Communication Table\n         L     R15,JESCTEXT-JESCT(,R15)  JESCT Extension\n         L     R15,JESSMSIB-JESPEXT(R15) SMS SSIB\n         ST    R15,@T_SMS_SSOB+SSOBSSIB-SSOB Save it\n\n         LA    R15,@T_SMS_SSSA         SSSA Work Area\n         ST    R15,@T_SMS_SSOB+SSOBINDV-SSOB Update SSOB\n\n         XC    @T_SMS_SSSA,@T_SMS_SSSA Clear SSSA\n         LHI   R15,L'@T_SMS_SSSA       Get its length\n         STH   R15,@T_SMS_SSSA+SSSALEN-IEFSSSA Update SSSA\n         MVC   @T_SMS_SSSA+SSSAID-IEFSSSA(L'SSSAID),=C'SSSA' ID it\n         MVI   @T_SMS_SSSA+SSSAVER+1-IEFSSSA,SSOBSSVR Version\n         MVI   @T_SMS_SSSA+SSSASFN+1-IEFSSSA,SSSAACTV Sub-Function\n         MVI   @T_SMS_SSSA+SSSAIFLG-IEFSSSA,SSSANAUT Non-APF\n\n         MVI   @T_SMS_SSSA+SSSA1TYP-IEFSSSA,SSSA1SGV Return VLDs\n         MVI   @T_SMS_SSSA+SSSA1CNT+3-IEFSSSA,1   1 construct\n         MVC   @T_SMS_SSSA+SSSA1NML-IEFSSSA(L'SSSA1NML),@T_SMS_VLD+VLDS+\n               GLEN-VLD               Len of StorGrp Name\n         MVC   @T_SMS_SSSA+SSSA1NAM-IEFSSSA(L'SSSA1NAM),@T_SMS_VLD+VLDS+\n               TGRP-VLD               StorGrp Name\n\n         LA    R15,@T_SMS_SSOB         A(SSOB)\n         ST    R15,@T_SMS_SSOB_Ptr     Save the address\n         LA    R1,@T_SMS_SSOB_Ptr      Point to the address\n\n         IEFSSREQ                      Call SMS\n\n         LTR   R15,R15                 SMS active?\n         JNZ   T80010                  No, exit quick smart\n\n         ICM   R15,B'1111',@T_SMS_SSOB+SSOBRETN-SSOB Check RC\n         JNZ   T80020                  Not good, skip SMS stuff\n\n*-------------------------------------------------------------------*\n*    Chain the new VLD to the others (note that we use the ID field *\n*   (VLDPID) for this) ...                                          *\n*-------------------------------------------------------------------*\n         ICM   R1,B'1111',@T_SMS_SSSA+SSSA1PTR-IEFSSSA A(Returned VLD)\n         JZ    T80020                  Nothing, not good\n         L     R15,@T_Last_VLD_Ptr     OK, A(Last VLD)\n         ST    R1,VLDPID-VLD(0,R15)    Chain this one\n\n*-------------------------------------------------------------------*\n*    ... set up our fields in the new VLD ...                       *\n*-------------------------------------------------------------------*\n         LA    R15,0                   Clear forward pointer ...\n         ST    R15,VLDPID-VLD(0,R1)     ... in the VLD\n         L     R15,@T_SMS_SSSA+SSSA1LEN-IEFSSSA Len of VLD\n         ST    R15,VLDPID+4-VLD(R1)    Save length (for FREEMAIN)\n         MVC   VLDPID+8-VLD(L'@T_SMS_SYSNum,R1),@T_SMS_SYSNum\n\n*-------------------------------------------------------------------*\n*    ... and go check it out.                                       *\n*-------------------------------------------------------------------*\n         OI    @T_Volser_in_VLD,L'@T_Volser_in_VLD It should be here\n         J     T00020                  And check it out\n\nT00110   DS    0H\n*-------------------------------------------------------------------*\n*    We have found our volser in the VLD, set up our return         *\n*   pointers, and exit. At this point, R15 points to the VLDEF      *\n*   for our volume.                                                 *\n*-------------------------------------------------------------------*\n         LA    R0,0                          Assume no SMS Status\n         LH    R1,@T_SMS_SYSNum              Get SMS System 'number'\n         LTR   R1,R1                         Any?\n         JM    T00120                        No, unknown SMS Status\n         MHI   R1,L'VLDSSTAT                 r1 = Offset within status\n         LR    R0,R15                        A(Volume array)\n         A     R0,VLDSYSOF-VLDEF(R15)        A(Status fields)\n         AR    R0,R1                         A(Status on our system)\n\nT00120   DS    0H\n         LA    R1,VLDSGLEN-VLDEF(R15)        A(Storage group length)\n\n         LA    R15,0                         Clear return code\n         J     T90010                        and exit\n\nT00130   DS    0H\n*-------------------------------------------------------------------*\n*    We have been passed a Volser pointer of 0 - by convention,     *\n*   this is a request that we free any VLDs that have been gotten   *\n*   for us                                                          *\n*-------------------------------------------------------------------*\n         ICM   R4,B'1111',16(R1)        VLD Chain Anchor\n         JZ    T00150                   Nothing, OK\nT00140   DS    0H\n         LR    R1,R4                    A(Storage to free)\n         L     R0,VLDPID+4-VLD(0,R1)    Length to free\n         L     R4,VLDPID-VLD(0,R4)      Rescue forward pointer\n         BASR  R2,0\n         USING (*,T00140_End-1),R2\n         STORAGE RELEASE,               Free the old table             +\n               ADDR=(1),                 starting here                 +\n               LENGTH=(0)                for this long\nT00140_End DS  0H\n         DROP  R2\n\n         LTR   R4,R4                    Is there another one?\n         JNZ   T00140                   Yes, go free it\n\nT00150   DS    0H\n         LA    R0,0                     No SMS Status\n         LA    R1,0                     No STORGRP\n         LA    R15,0                    All OK\n         J     T90010                   and exit\n\nT80010   DS    0H\n*-------------------------------------------------------------------*\n*    SMS unavailable, set RC and exit                               *\n*-------------------------------------------------------------------*\n         LA    R1,0                     No SMS StorGrp\n         LA    R0,0                      or status\n         LA    R15,8                    SMS not available\n         J     T90010                   and exit\n\nT80020   DS    0H\n*-------------------------------------------------------------------*\n*    SSOBRETN not 0 on return from SSREQ                            *\n*-------------------------------------------------------------------*\n         LA    R1,0                     No SMS StorGrp\n         LA    R0,0                      or status\n         LA    R15,4                    STORGRP not found\n         J     T90010                   and exit\n\nT90010   DS    0H\n*-------------------------------------------------------------------*\n*    Free up our local storage ...                                  *\n*-------------------------------------------------------------------*\n         L     R14,4(0,R13)             A(HSA)\n         STM   R15,R1,16(R14)           Save rc, A(status), A(STORGRP)\n\n         LA    R1,@T_Dynam              A(Local storage)\n         L     R2,@T_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         L     R13,4(0,R13)             Rescue A(HSA)\n\n         SSCSTACK POP,                  Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=(R2)                on this stack\n\n\n*-------------------------------------------------------------------*\n*    ... and return to caller (note that we updated the callers     *\n*   savearea:   +16: Return Code       R15                          *\n*               +20: A(SMS Status)     R0                           *\n*               +24: A(SMS STORGRP)    R1                           *\n*-------------------------------------------------------------------*\n         LM    R14,R12,12(R13)          Restore callers regs\n         BSM   0,R14                    and return\n\nT_Literals  DS  0H\n\nT_TRT    DC    256XL1'FF'\n         ORG   T_TRT+C' '\n         DC    X'00'\n         ORG   T_TRT+C'$'\n         DC    X'00'\n         ORG   T_TRT+C'#'\n         DC    X'00'\n         ORG   T_TRT+C'@'\n         DC    X'00'\n         ORG   T_TRT+C'A'\n         DC    9XL1'00'\n         ORG   T_TRT+C'J'\n         DC    9XL1'00'\n         ORG   T_TRT+C'S'\n         DC    8XL1'00'\n         ORG   T_TRT+C'0'\n         DC    10XL1'00'\n         ORG\n\n         LTORG\n\nT_Literals_End  DS  0H\n\n\n@T_Dynam                  DSECT\n                          DS    18F    O/S style save area\n@T_31Bit_Stack_Ptr_Ptr    DS    AL4    A(31-bit Stack Ptr)\n@T_24Bit_Stack_Ptr_Ptr    DS    AL4    A(24-bit Stack Ptr)\n\n@T_Last_VLD_Ptr           DS    AL4    A(Last VLD)\n@T_SMS_SSOB_Ptr           DS    AL4    A(SSOB)\n@T_SMS_SYSNum             DS    HL2    SMS System Number\n@T_SMS_SSOB               DS    XL(SSOBHSIZ) SSOB\n@T_SMS_SSSA               DS    XL(SSSALN+SSSA1LN)  SSSA (HDR)\n                          DS    X      Flag Byte\n@T_Volser_in_VLD          EQU   *-1,X'80' 1... .... VLD has Volser\n                          DS    0D\n@T_SMS_VLD                DS    XL((VLDEND-VLD)+(VLDEND2-VLDSYSDT))\n                          ORG   @T_SMS_VLD\n@T_SMS_BCD                DS    XL6144  SMS Config Data\n                          ORG   ,\n\n                          DS    0D\n@T_Dynam_Length           EQU   *-@T_Dynam\n\n\n&PGMNAME CSECT\n\n         DROP  ,\n         POP   USING\n         TITLE 'U00010: Write to output file'\n\n         PUSH  USING\n\nU00010   DS    0H\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Subroutine: U00010                                                 *\n*                                                                     *\n*  Abstract  : This subroutine manages output DCBs, and writes data   *\n*              to them.                                               *\n*                                                                     *\n*  Inputs    : R1 : ---> A(@_Dynam)                                   *\n*                        A(31-bit Stack Pointer)                      *\n*                        A(24-bit Stack Pointer)                      *\n*                        A(DDName)                                    *\n*                        A(Data)                                      *\n*                        A(Length of Data)                            *\n*                        A(ASA Ctl Char) or 0                         *\n*  Outputs   : R15: 0 = OK                                            *\n*                   8 = Error (DCB not OPEN, etc.)                    *\n*                                                                     *\n*  Operation : If A(DDNAME) = 0                                       *\n*                CLOSE all OPEN DCBs                                  *\n*                Free DCB storage                                     *\n*              Else                                                   *\n*                Find DCB for DDName                                  *\n*                If DCB not found                                     *\n*                  If any data to write                               *\n*                    Create and OPEN DCB                              *\n*                  EndIf                                              *\n*                EndIf                                                *\n*                If DCB OPEN                                          *\n*                  If no data to write                                *\n*                    CLOSE DCB                                        *\n*                  Else                                               *\n*                    Write Data                                       *\n*                  EndIf                                              *\n*                EndIf                                                *\n*              EndIf                                                  *\n*              Return to caller                                       *\n*                                                                     *\n*  Notes     : Once an OUTFILE is OPEN, it will remain OPEN until     *\n*               the SPACE program terminates, to cope with the fol-   *\n*               lowing batch scenario:                                *\n*                  SPACE .... OUTFILE(X)                              *\n*                  SPACE .... OUTFILE(Y)                              *\n*                  SPACE .... OUTFILE(X)                              *\n*                                                                     *\n*  History:    2003/10/07 SDDA030 - V2.21                             *\n*                                   New.                              *\n*                                   This code was extracted from X0010*\n*                                   and generalized, so it could be   *\n*                                   used for all output files, includ-*\n*                                   ing SYSPRINT.                     *\n*              2006/04/21 SDDA030 - V2.24                             *\n*                                 - Used standardised calling sequence*\n*                                 - Used separate 24-bit stack for    *\n*                                   DCBs, PUT code, etc.              *\n*              ____/__/__ ______                                      *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         STM   R14,R12,12(R13)          Save callers registers\n         LARL  R11,U_Literals           Point to our literals\n         USING (U_Literals,U_Literals_End),R11 Tell the assembler\n\n         L     R12,0(0,R1)              A(@_Dynam)\n         USING @_Dynam,R12              Tell the assembler\n\n*-------------------------------------------------------------------*\n*    Get an area on the stack for our local storage                 *\n*-------------------------------------------------------------------*\n         L     R2,4(0,R1)               A(31-bit stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         SSCSTACK PUSH,                 Get stack area                 +\n               LEN=@U_Dynam_Length,      this long                     +\n               STACK=(R2)                using this stack\n\n         LR    R3,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LHI   R1,@U_Dynam_Length        Its length\n         LA    R14,0                    Clear source address\n         LA    R15,0                     and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R3                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*-------------------------------------------------------------------*\n         ST    R13,4(0,R1)              Chain\n         ST    R1,8(0,R13)               saveareas\n         LR    R13,R1                   Load dynam base\n         USING @U_Dynam,R13             Assign a base\n         L     R15,@U_Dynam+4           Get A(HSA)\n         LM    R0,R3,20(R15)            Restore callers registers\n\n         L     R15,4(0,R1)              A(31-bit Stack Pointer)\n         ST    R15,@U_31Bit_Stack_Ptr_Ptr Save it\n         L     R15,8(0,R1)              A(24-bit Stack Pointer)\n         ST    R15,@U_24Bit_Stack_Ptr_Ptr Save it\n\n*-------------------------------------------------------------------*\n*    Save our parms                                                 *\n*-------------------------------------------------------------------*\n        L     R15,12(0,R1)              A(DDName)\n        ST    R15,@U_DDName_Ptr         OK, save it\n\n        L     R15,16(0,R1)              A(Data)\n        ST    R15,@U_Data_Ptr           Save it\n\n        L     R15,20(0,R1)              A(Data Length)\n        ST    R15,@U_Data_Len_Ptr       Save it\n\n        TM    20(R1),X'80'              Was that the last parm?\n        BO    U00020                    Yes, skip\n        L     R15,24(R1)                A(ASA Character) or 0\n        ST    R15,@U_ASA_Char_Ptr       Save it\n\nU00020  DS    0H\n*-------------------------------------------------------------------*\n*    By convention, if the address of the DDName is 0, we CLOSE all *\n*   OPEN DCBs, and free up their storage.                           *\n*-------------------------------------------------------------------*\n        ICM   R15,B'1111',@U_DDName_Ptr A(DDName)\n        JNZ   U00100                    Something there, OK\n\n*-------------------------------------------------------------------*\n*    CLOSE the DCBs ...                                             *\n*-------------------------------------------------------------------*\n         ICM   R3,B'1111',@_OutFile_Chain_Ptr  A(First OUTFile DCB)\n         JZ    U00050                   None, exit\nU00030   DS    0H\n         LA    R15,4+L'@_OutFile_DDName(0,R3) A(DCB)\n         TM    DCBOFLGS-IHADCB(R15),DCBOFOPN Is it OPEN?\n         JNO   U00040                   No, skip CLOSE\n         MVC   @U_CLOSE,U_CLOSE         Yes, Move CLOSE Parms\n         CLOSE ((15)),MODE=31,MF=(E,@U_CLOSE) and CLOSE it\nU00040   DS    0H\n         ICM   R3,B'1111',0(R3)         A(next DCB)\n         JNZ   U00030                   Got one, close it too\n\nU00050   DS    0H\n*-------------------------------------------------------------------*\n*    ... free the stack ...                                         *\n*-------------------------------------------------------------------*\n         ICM   R1,B'1111',@_OutFile_24Bit_Stack_Ptr A(DCB Stack)\n         JZ    U00080                   None, skip\n         SSCSTACK TERM,                 Free the stack area            +\n               STACK=(1)                 this one\n\nU00080   DS    0H\n         LA    R15,0                    Clear\n         ST    R15,@_OutFile_PUT_Code    Code pointer\n         ST    R15,@_OutFile_Chain_Ptr   and DCB pointer\n\n*-------------------------------------------------------------------*\n*    ... and exit.                                                  *\n*-------------------------------------------------------------------*\n         LA    R15,0                    All done, clear return code\n         J     U90010                    and exit\n\nU00100   DS    0H\n*-------------------------------------------------------------------*\n*    ... search the chain of OUTFIL DCBs to see if we can find our  *\n*   DDName                                                          *\n*-------------------------------------------------------------------*\n         LA    R15,@_OutFile_Chain_Ptr  A(Ptr to start of chain)\n         L     R14,@U_DDName_Ptr        A(Our DDName)\n         J     U00120                   and start running it\nU00110   DS    0H\n         CLC   0(L'@_OutFile_DDName,R14),4(R15)  Yes, is it ours?\n         JNE   U00120                   No, skip\n         AHI   R15,4+L'@_OutFile_DDName Yes, point to the DCB\n         ST    R15,@U_DCB_Ptr           Save it\n         J     U00280                   and use it\nU00120   DS    0H\n         LR    R3,R15                   Save A(this DCB area)\n         ICM   R15,B'1111',0(R3)        Point to next\n         JNZ   U00110                   Got one, check it out\n\n*-------------------------------------------------------------------*\n*    If we have anything to do ...                                  *\n*-------------------------------------------------------------------*\n         ICM   R15,B'1111',@U_Data_Ptr  Any data?\n         JZ    U00390                   No, exit quick smart\n         ICM   R15,B'1111',@U_Data_Len_Ptr Yes, any length pointer?\n         JZ    U00390                   No, get out\n         ICM   R15,B'1111',0(R15)       Yes, length = 0?\n         JZ    U00390                   Yes, exit now\n\n*-------------------------------------------------------------------*\n*    Our DDName is not found, so get an area on the 24-bit Stack    *\n*   for our DCB area ...                                            *\n*    The format of this area:                                       *\n*       0- 3: Forward pointer                                       *\n*       4-11: DDName                                                *\n*      12-n : DCB                                                   *\n*                                                                   *\n*    First, however, we move our 24-bit PUT code, if required. PUT  *\n*   runs 24-bit because QSAM has trouble using 31-bit PUT for       *\n*   DDNames allocated to the terminal - rather than check, we       *\n*   blindly run PUT in 24-bit mode all the time.                    *\n*-------------------------------------------------------------------*\n         ICM   R0,B'1111',@_OutFile_24Bit_Stack_Ptr A(DCB Stack)\n         JNZ   U00130                   OK, skip\n\n         L     R0,=AL4(@_24Bit_Stack_Length) Length of storage we need\n         SSCSTACK INIT,                 Go get our storage             +\n               LEN=(R0),                 this long                     +\n               LOC=24                    below the line\n\n         ST    R1,@_OutFile_24Bit_Stack_Ptr Update A(DCB Stack)\n\nU00130   DS    0H\n         ICM   R15,B'1111',@_OutFile_PUT_Code  A(24-bit PUT code)\n         JNZ   U00140                  OK, skip\n\n         LA    R0,U00400_End-U00400    Length of storage we need\n         L     R2,@_OutFile_24Bit_Stack_Ptr A(DCB Stack)\n         SSCSTACK PUSH,                 Get stack area                 +\n               LEN=(R0),                 this long                     +\n               STACK=(R2)                using this stack\n\n         ST    R1,@_OutFile_PUT_Code   Save A(Storage)\n         LR    R0,R1                   Set Target address\n         LHI   R1,U00400_End-U00400    Set Target length\n         BASR  R14,0                   Set Source\n         AHI   R14,U00400-*              address\n         LR    R15,R1                  and Source length\n         MVCL  R0,R14                  Move PUT code\n\nU00140   DS    0H\n         LHI   R0,4+L'@_OutFile_DDName+U_OUTFILE_DCB_Length\n         L     R2,@_OutFile_24Bit_Stack_Ptr A(DCB Stack)\n         SSCSTACK PUSH,                 Get stack area                 +\n               LEN=(R0),                 this long                     +\n               STACK=(R2)                using this stack\n\n*-------------------------------------------------------------------*\n*    ... chain it to the previous DCB area (pointed to by R3) ...   *\n*-------------------------------------------------------------------*\n         ST    R1,0(0,R3)               Chain it\n\n*-------------------------------------------------------------------*\n*    ... and initialize it.                                         *\n*-------------------------------------------------------------------*\n         XC    0(4,R1),0(R1)          Clear Ptr to next DCB area\n         L     R15,@U_DDName_Ptr      A(DDName)\n         MVC   4(L'@_OutFile_DDName,R1),0(R15)  Set DDName\n         LA    R15,4+L'@_OutFile_DDName(0,R1) Point to DCB\n         MVC   0(U_OUTFILE_DCB_Length,R15),U_OUTFILE_DCB Move DCB\n         MVC   DCBDDNAM-IHADCB(L'DCBDDNAM,R15),4(R1)  Move DDName\n         ST    R15,@U_DCB_Ptr         Save A(DCB)\n\n*-------------------------------------------------------------------*\n*    Get the JFCB. First, find the TIOT entry ...                   *\n*-------------------------------------------------------------------*\n         L     R15,CVTPTR(0,0)          A(CVT)\n         L     R15,CVTTCBP-CVT(R15)     A(Current TCB pointer)\n         L     R15,0(0,R15)             A(Current TCB)\n         L     R15,TCBTIO-TCB(R15)      A(TIOT)\n         L     R14,@U_DDName_Ptr        A(DDName)\n         AHI   R15,TIOENTRY-TIOT1       A(1st entry in TIOT)\nU00150   DS    0H\n         CLI   TIOELNGH-TIOENTRY(R15),0 Last Entry?\n         JE    U80010                   Yes, DDName not found\n         CLC   TIOEDDNM-TIOENTRY(L'TIOEDDNM,R15),0(R14) Ours?\n         JE    U00160                   Found our entry, skip\n         LA    R0,0                     Clear work reg\n         IC    R0,TIOELNGH-TIOENTRY(R15) Get entry length\n         AR    R15,R0                   Point to next entry\n         J     U00150                   and check it out\n\nU00160   DS    0H\n*-------------------------------------------------------------------*\n*    ... and then get the JFCB address from the SWA                 *\n*-------------------------------------------------------------------*\n         XC    @U_SWAEPAX,@U_SWAEPAX    Clear SWAEPA\n         MVC   @U_SWAEPAX+SWVA-ZB505(L'SWVA),TIOEJFCB-TIOENTRY(R15)\n         LA    R15,@U_SWAEPAX           A(EPA)\n         ST    R15,@U_EPA_Ptr           Save the address\n         MVC   @U_SWAREQ,U_SWAREQ       Move L-Form of macro\n         SWAREQ FCODE=RL,               Read Locate                    +\n               EPA=@U_EPA_Ptr,           using the EPA at this addr    +\n               UNAUTH=YES,               not being authoriZED          +\n               MF=(E,@U_SWAREQ)          keep ourselves re-entrant\n         LTR   R15,R15                  Check return code\n         JNZ   U80010                   Not good, skip\n\n         L     R4,@U_SWAEPAX+SWBLKPTR-ZB505 Get A(JFCB)\n         L     R3,@U_DCB_Ptr            Get A(DCB)\n\n*-------------------------------------------------------------------*\n*    If this is a new dataset ...                                   *\n*-------------------------------------------------------------------*\n         TM    JFCBTSDM-INFMJFCB(R4),JFCSDS SubSystem Dataset?\n         JO    U00170                 Yes, treat it as NEW\n         CLI   JFCBIND2-INFMJFCB(R4),0 Any DISP specified?\n         JE    U00170                 No, treat it as NEW\n         TM    JFCBIND2-INFMJFCB(R4),JFCNEW Yes, DISP=NEW?\n         JNO   U00270                 No, use existing DCB stuff\n\nU00170   DS    0H\n*-------------------------------------------------------------------*\n*    ... set up RECFM, LRECL and BLKSIZE if they were not           *\n*   specified. First, set RECFM to FB if it has not been specified. *\n*-------------------------------------------------------------------*\n         IC    R15,JFCRECFM-INFMJFCB(0,R4) Get RECFM from JFCB\n         LTR   R15,R15                Anything?\n         JNZ   U00180                 Yes, OK\n         LA    R15,DCBRECF+DCBRECBR   No, default to FB\n\n         TM    JFCBTSDM-INFMJFCB(R4),JFCSDS SubSystem Dataset?\n         JNO   U00180                 No, OK\n         LA    R15,DCBRECCA(0,R15)    Yes, add ASA character\nU00180   DS    0H\n         STC   R15,DCBRECFM-IHADCB(R3) Set RECFM in DCB\n\n*-------------------------------------------------------------------*\n*    Get the LRECL and BLKSIZE from the JFCB ...                    *\n*-------------------------------------------------------------------*\n         LH    R15,JFCLRECL-INFMJFCB(R4) Get JFCB LRECL\n         LH    R14,JFCBLKSI-INFMJFCB(R4) Get JFCB BLKSIZE\n\n*-------------------------------------------------------------------*\n*    ... and, if the LRECL hasn't been specified, set it to the     *\n*   length of the data to be written (unless this is SYSPRINT, when *\n*   the LRECL is set to VolTbl_Ent_Display_Len, to maintain compat- *\n*   ibility with previous versions).                                *\n*-------------------------------------------------------------------*\n         LTR   R15,R15                 Any LRECL?\n         JNZ   U00210                  Yes, OK\n\n         L     R15,@U_Data_Len_Ptr     A(Length of data to be written)\n         L     R15,0(0,R15)            Get it\n         TM    DCBRECFM-IHADCB(R3),DCBRECCC Carriage control?\n         JZ    U00200                  No, skip\n         AHI   R15,1                   Yes, bump for CC\nU00200   DS    0H\n         TM    DCBRECFM-IHADCB(R3),DCBRECU RECFM = U?\n         JO    U00210                  Yes, not RECFM=V\n         TM    DCBRECFM-IHADCB(R3),DCBRECV RECFM = V?\n         JZ    U00210                  No, skip\n         AHI   R15,4                   Yes, bump for RDW\n\nU00210   DS    0H\n*-------------------------------------------------------------------*\n*    If no BLKSIZE specified for RECFM=U, make BLKSIZE = LRECL      *\n*-------------------------------------------------------------------*\n         LTR   R14,R14                 Any BLKSIZE in the JFCB?\n         JNZ   U00220                  Yes, skip\n         TM    DCBRECFM-IHADCB(R3),DCBRECU RECFM = U?\n         JNO   U00220                  No, use SDB\n         LR    R14,R15                 Yes, BLKSIZE = LRECL\n\nU00220   DS    0H\n*-------------------------------------------------------------------*\n*    Check LRECL vs BLKSIZE, and adjust them to fit                 *\n*     RECFM=U: LRECL = 0                                            *\n*     RECFM=V: BLKSIZE = (n * LRECL) + 4                            *\n*     RECFM=F: BLKSIZE = n * LRECL                                  *\n*-------------------------------------------------------------------*\n         TM    DCBRECFM-IHADCB(R3),DCBRECU RECFM = U?\n         JNO   U00230                  No, skip\n         LA    R15,0                   Yes, clear LRECL\n         J     U00260                  and skip\nU00230   DS    0H\n         TM    DCBRECFM-IHADCB(R3),DCBRECV RECFM = V?\n         JNO   U00240                  No, skip\n         LTR   R14,R14                 Yes, BLKSIZE=0 (SDB)?\n         JZ    U00260                  Yes, OK\n         TM    DCBRECFM-IHADCB(R3),DCBRECSB Spanned rec?\n         JO    U00260                  Yes, OK\n         LR    R1,R14                  No, get BLKSIZE\n         LA    R0,0                    Clear high-order word\n         DR    R0,R15                  BLKSIZE/LRECL\n         C     R0,=FL4'4'              Remainder of 4 (BDW)?\n         JNL   U00260                  Yes, OK\n         LR    R15,R14                 No, LRECL = ...\n         S     R15,=FL4'4'                BLKSIZE - 4\n         J     U00260                  and skip\nU00240   DS    0H\n         LTR   R14,R14                 Fixed, BLKSIZE=0 (SDB)?\n         JZ    U00260                  Yes, OK\n         CR    R14,R15                 No, BLKSIZE > LRECL?\n         JNL   U00250                  Yes, OK\n         LR    R14,R15                 No, BLKSIZE = LRECL\n         J     U00260                  and skip\nU00250   DS    0H\n         LR    R1,R14                  Get BLKSIZE\n         LA    R0,0                    Clear high-order word\n         DR    R0,R15                  BLKSIZE/LRECL\n         SR    R14,R0                  Adjust BLKSIZE by remainder\n         J     U00260                  and skip\nU00260   DS    0H\n         STH   R15,DCBLRECL-IHADCB(R3) Update DCB LRECL\n         STH   R14,DCBBLKSI-IHADCB(R3) Update DCB BLKSIZE\n\nU00270   DS    0H\n*-------------------------------------------------------------------*\n*    Open the DCB, and exit quick smart if it doesn't               *\n*-------------------------------------------------------------------*\n         L     R3,@U_DCB_Ptr           Point to our DCB\n\n         MVC   @U_OPEN,U_OPEN             Move OPEN parms\n         OPEN  ((3),OUTPUT),MODE=31,MF=(E,@U_OPEN) And OPEN it\n\n         TM    DCBOFLGS-IHADCB(R3),DCBOFOPN Is it OPEN?\n         JNO   U80010                  No, exit with error\n\nU00280   DS    0H\n*-------------------------------------------------------------------*\n*    We have our DCB - if it is OPEN ...                            *\n*-------------------------------------------------------------------*\n         LA    R15,0                   Clear return code\n         L     R3,@U_DCB_Ptr           Get A(DCB)\n         TM    DCBOFLGS-IHADCB(R3),DCBOFOPN Is it OPEN?\n         JNO   U90010                  No, skip\n\n*-------------------------------------------------------------------*\n*    ... if we have nothing to do, CLOSE the DCB. Otherwise ...     *\n*-------------------------------------------------------------------*\n         ICM   R15,B'1111',@U_Data_Ptr  Any data?\n         JZ    U00290                   No, close DCB\n         ICM   R15,B'1111',@U_Data_Len_Ptr Yes, any length pointer?\n         JZ    U00290                   No, close DCB\n         ICM   R15,B'1111',0(R15)       Yes, length = 0?\n         JNZ   U00300                   NO, OK\nU00290   DS    0H\n         MVC   @U_CLOSE,U_CLOSE         Move CLOSE Parms\n         CLOSE ((3)),MODE=31,MF=(E,@U_CLOSE) and CLOSE our DCB\n         J     U00390                   and exit\n\nU00300   DS    0H\n*-------------------------------------------------------------------*\n*    ... get an area to hold the data we will write. It's length    *\n*   is:                                                             *\n*    RECFM=U:                                                       *\n*       Length of data to be written                                *\n*      +1 if the DCB has a Print Ctl Char & A(ASA Char) \\= 0        *\n*    Otherwise:                                                     *\n*       DCBLRECL                                                    *\n*-------------------------------------------------------------------*\n         LH    R0,DCBLRECL-IHADCB(R3)  Get LRECL\n\n         TM    DCBRECFM-IHADCB(R3),DCBRECU RECFM = U?\n         JNO   U00310                  No, skip\n         L     R15,@U_Data_Len_Ptr     A(Len of data to be written)\n         L     R0,0(0,R15)             Get it\n         TM    DCBRECFM-IHADCB(R3),DCBRECCC CC?\n         JZ    U00310                  No, skip\n         ICM   R15,B'1111',@U_ASA_Char_Ptr Yes, do we have one?\n         JZ    U00310                  No, too bad\n         AHI   R0,1                    Yes, bump length\nU00310   DS    0H\n\n         ST    R0,@U_OutRec_Len        Save length\n         L     R2,@_OutFile_24Bit_Stack_Ptr A(DCB Stack)\n         SSCSTACK PUSH,                 Get stack area                 +\n               LEN=(R0),                 this long                     +\n               STACK=(R2)                using this stack\n\n         ST    R1,@U_OutRec_Ptr        Save A(Data area)\n\n*-------------------------------------------------------------------*\n*    ... move the data passed to us to our output area ...          *\n*-------------------------------------------------------------------*\n         L     R14,@U_OutRec_Ptr        A(Output Record)\n         TM    DCBRECFM-IHADCB(R3),DCBRECU RECFM=U?\n         JO    U00320                  Yes, its not RECFM=V\n         TM    DCBRECFM-IHADCB(R3),DCBRECV RECFM=V?\n         JNO   U00320                  No, skip\n         LA    R14,4(0,R14)            Yes, bump for RDW\nU00320   DS    0H\n         TM    DCBRECFM-IHADCB(R3),DCBRECCC CC?\n         JZ    U00330                  No, skip\n         ICM   R15,B'1111',@U_ASA_Char_Ptr Do we have one?\n         JZ    U00330                  No, skip\n         MVC   0(1,R14),0(R15)         Yes, move it\n         TM    DCBRECFM-IHADCB(R3),DCBRECCM Machine CC?\n         JZ    U00265                  No, skip\n         TR    0(1,R14),U_ASA_to_Mach  Yes, translate it\nU00265   DS    0H\n         LA    R14,1(0,R14)            and bump output pointer\nU00330   DS    0H\n         LR    R0,R14                  A(Output)\n         L     R1,@U_OutRec_Ptr        Calculate\n         A     R1,@U_OutRec_Len         length of output\n         SR    R1,R0                    data left\n         L     R14,@U_Data_Ptr         A(Data to be copied)\n         L     R15,@U_Data_Len_Ptr     A(Length)\n         L     R15,0(0,R15)            Get its length\n         O     R15,=XL4'40000000'      Pad character of blank\n         MVCL  R0,R14                  Move it\n\n         S     R14,@U_OutRec_Ptr       Length of output record\n\n*-------------------------------------------------------------------*\n*    ... if this is a RECFM=U file, update DCBBLKSI, after saving   *\n*   it. Otherwise ...                                               *\n*-------------------------------------------------------------------*\n         TM    DCBRECFM-IHADCB(R3),DCBRECU  RECFM=U?\n         JNO   U00350                  No, skip\n         LH    R0,DCBBLKSI-IHADCB(R3)  Yes, get max record len\n         STH   R0,@U_BLKSIZE           and save it\n         CR    R14,R0                  Are we trying to write too much?\n         JNH   U00340                  No, OK\n         LR    R14,R0                  Yes, write what we can\nU00340   DS    0H\n         STH   R14,DCBBLKSI-IHADCB(R3) Update it with current length\n         J     U00370                  and skip\n\nU00350   DS    0H\n*-------------------------------------------------------------------*\n*    ... if this is a RECFM=V file, update the RDW                  *\n*-------------------------------------------------------------------*\n         TM    DCBRECFM-IHADCB(R3),DCBRECV RECFM=V?\n         JNO   U00370                  No, OK\n         LH    R0,DCBLRECL-IHADCB(R3)  Yes, get LRECL\n         CR    R14,R0                  Are we trying to write too much?\n         JNH   U00360                  No, OK\n         LR    R14,R0                  Yes, write what we can\nU00360   DS    0H\n         L     R15,@U_OutRec_Ptr       Get A(Output record)\n         SLL   R14,16                  Length in high-order byte\n         ST    R14,0(0,R15)            Update RDW\n         J     U00370                  and skip\n\nU00370   DS    0H\n*-------------------------------------------------------------------*\n*    Write our data ...                                             *\n*-------------------------------------------------------------------*\n         L     R1,@U_DCB_Ptr           Point to our DCB\n         L     R0,@U_OutRec_Ptr        Point to data to be written\n         L     R15,@_OutFile_PUT_Code  Point to our code\n         BASR  R14,R15                 Go issue PUT\n\n*-------------------------------------------------------------------*\n*    ... and restore DCBBLKSI, if this is RECFM=U                   *\n*-------------------------------------------------------------------*\n         L     R1,@U_DCB_Ptr           Point to our DCB\n         TM    DCBRECFM-IHADCB(R1),DCBRECU  RECFM=U?\n         JNO   U00380                  No, skip\n         LH    R0,@U_BLKSIZE           Yes, get saved BLKSIZE\n         STH   R0,DCBBLKSI-IHADCB(R1)  and restore the DCB\n\nU00380   DS    0H\n*-------------------------------------------------------------------*\n*    Free the storage we got for our record ...                     *\n*-------------------------------------------------------------------*\n         ICM   R1,B'1111',@U_OutRec_Ptr A(Output record data area)\n         JZ    U00390                   Nothing, skip\n         L     R2,@_OutFile_24Bit_Stack_Ptr A(DCB Stack)\n         SSCSTACK POP,                  Free the record area           +\n               ADDR=(R1),                starting here                 +\n               STACK=(R2)                on this stack\n\nU00390   DS    0H\n*-------------------------------------------------------------------*\n*    ... clear the return code, and exit.                           *\n*-------------------------------------------------------------------*\n         LA    R15,0                   Clear return code\n         J     U90010                  and exit\n\n*-------------------------------------------------------------------*\n*    The following code is moved to storage below-the-line, and     *\n*   is executed via a BASR, so it runs AMODE24. This is required if *\n*   the DCB to which we are writing happens to be allocated to      *\n*   the TSO terminal.                                               *\n*                                                                   *\n*   Note that R14-R3 are updated by this routine.                   *\n*-------------------------------------------------------------------*\n\n\nU00400   DS    0H\n         PUSH  USING                   Save USING environment\n         DROP  ,                       Free them all\n         USING *,R15                   Assign a base\n         LR    R3,R14                  Save return address\n         PUT   (1),(0)                 Write record (MACRF=PM)\n         LA    R14,X'80'               Set up\n         SLL   R14,24                   31-bit\n         OR    R14,R3                   return address\n         BSM   0,R14                   Back to caller in AMODE31\n         DROP  R15                     Free our base\n         POP   USING                   Restore USING environment\nU00400_End EQU *\n\n\nU80010   DS    0H\n*-------------------------------------------------------------------*\n*    We couldn't OPEN the DCB, so exit with a return code           *\n*-------------------------------------------------------------------*\n         LA    R15,4                   RC = 4\n         J     U90010                  and exit\n\nU90010   DS    0H\n*-------------------------------------------------------------------*\n*    Free up our local storage ...                                  *\n*-------------------------------------------------------------------*\n         LR    R3,R15                   Save Return Code\n\n         LA    R1,@U_Dynam              A(Local storage)\n         L     R2,@U_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)\n         L     R2,0(0,R2)         Point to it\n         L     R13,4(0,R13)             Rescue A(HSA)\n\n         SSCSTACK POP,                  Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=(R2)                on this stack\n\n         LR    R15,R3                   Restore Return Code\n\n*-------------------------------------------------------------------*\n*    ... and return to caller                                       *\n*-------------------------------------------------------------------*\n         L     R14,12(0,R13)            Restore return address\n         LM    R0,R12,20(R13)           Restore other registers\n         BSM   0,R14                    and return\n\nU_Literals  DS  0H\n\nU_ASA_to_Mach DC  256X'09'               Default - space 1 line\n              ORG U_ASA_to_Mach+C'0'     Space 2 lines\n              DC  X'11'\n              ORG U_ASA_to_Mach+C'-'     Space 3 lines\n              DC  X'19'\n              ORG U_ASA_to_Mach+C'+'     Suppress spacing\n              DC  X'01'\n              ORG U_ASA_to_Mach+C'1'     Skip to Channel 1\n              DC  X'89'\n              ORG\n\n         LTORG\n\n         PUSH  PRINT\n         PRINT NOGEN\n\nU_OUTFILE_DCB DCB DDNAME=OUTFILE,MACRF=PM,DSORG=PS\nU_OUTFILE_DCB_Length EQU *-U_OUTFILE_DCB Length of OUTFILE DCB\n\nU_SWAREQ SWAREQ MF=L                    Read Locate\nU_SWAREQ_Length EQU *-U_SWAREQ          Length of SWAREQ Macro\n\nU_OPEN   OPEN  (0,INPUT),MODE=31,MF=L\nU_OPEN_Length EQU  *-U_OPEN\n\nU_CLOSE  CLOSE (0),MODE=31,MF=L\nU_CLOSE_Length EQU  *-U_CLOSE\n\n         POP PRINT\n\nU_Literals_End  DS  0H\n\n\n@U_Dynam                  DSECT       Dynamic area for U0000\n                          DS    18F    O/S Style save area\n@U_31Bit_Stack_Ptr_Ptr    DS    AL4    A(31-bit Stack Ptr)\n@U_24Bit_Stack_Ptr_Ptr    DS    AL4    A(24-bit Stack Ptr)\n\n@U_DDName_Ptr             DS    AL4    A(DDName)\n@U_Data_Ptr               DS    AL4    A(Data to be written)\n@U_Data_Len_Ptr           DS    AL4    A(Length of data to be written)\n@U_ASA_Char_Ptr           DS    AL4    A(ASA CC) or 0\n\n@U_DCB_Ptr                DS    AL4    A(Current DCB)\n@U_BLKSIZE                DS    HL2    BLKSIZE for RECFM=U DCB\n\n@U_OutRec_Ptr             DS    AL4    A(Buffer for PUT)\n@U_OutRec_Len             DS    FL4    A(Length of above buffer)\n\n@U_Macros                 DS    0F\n@U_OPEN                   DS    CL(U_OPEN_Length)\n                          ORG   @U_Macros\n@U_CLOSE                  DS    CL(U_CLOSE_Length)\n                          ORG   @U_Macros\n@U_EPA_Ptr                DS    AL4    A(EPA for SWAREQ)\n@U_SWAREQ                 DS    CL(U_SWAREQ_Length)\n                          DS    0F\n@U_SWAEPAX                DS    CL(L'SWAEPAX)\n                          ORG   ,\n                          DS    0D     Alignment\n@U_Dynam_Length           EQU   *-@U_Dynam Length of storage\n\n&PGMNAME CSECT\n\n         DROP  ,\n         POP   USING\n         TITLE 'V00010: Set up Statistics output lines'\n\n         PUSH  USING\n\nV00010   DS    0H\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Subroutine: V00010                                                 *\n*                                                                     *\n*  Abstract  : Populate statistics lines in the Volume Table.         *\n*                                                                     *\n*  Inputs    : R1 : ---> A(@_Dynam)                                   *\n*                        A(31-bit Stack Pointer)                      *\n*                        A(24-bit Stack Pointer)                      *\n*                        A(VolTbl_Ent)                                *\n*  Outputs   : R15: 0: OK                                             *\n*                                                                     *\n*  Notes     : N/A                                                    *\n*                                                                     *\n*  History:    2000/05/23 SDDA030 - V2.12                             *\n*                                 - New                               *\n*              2001/02/01 SDDA030 - V2.13                             *\n*                                 - Populated Main task CPU time      *\n*                                   stats line.                       *\n*              2001/02/26 SDDA030 - V2.14                             *\n*                                 - Checked and flagged               *\n*                                   VolTbl_Ent_Stats_Done so the stats*\n*                                   lines are populated once only.    *\n*              2002/06/11 SDDA030 - V2.18                             *\n*                                   WAIT for VolTbl to be populated   *\n*                                   before updating.                  *\n*              2006/04/21 SDDA030 - V2.24                             *\n*                                   Used standardised calling sequence*\n*              ____/__/__ _______                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         STM   R14,R12,12(R13)          Save callers registers\n         LARL  R11,V_Literals           Point to our literals\n         USING (V_Literals,V_Literals_End),R11 Tell the assembler\n\n         L     R12,0(0,R1)              A(@_Dynam)\n         USING @_Dynam,R12              Tell the assembler\n\n*-------------------------------------------------------------------*\n*    Get an area on the stack for our local storage                 *\n*-------------------------------------------------------------------*\n         L     R2,4(0,R1)               A(31-bit stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         SSCSTACK PUSH,                 Get stack area                 +\n               LEN=@V_Dynam_Length,      this long                     +\n               STACK=(R2)                using this stack\n\n         LR    R3,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LHI   R1,@V_Dynam_Length        Its length\n         LA    R14,0                    Clear source address\n         LA    R15,0                     and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R3                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*-------------------------------------------------------------------*\n         ST    R13,4(0,R1)              Chain\n         ST    R1,8(0,R13)               saveareas\n         LR    R13,R1                   Load dynam base\n         USING @V_Dynam,R13             Assign a base\n         L     R15,@V_Dynam+4           Get A(HSA)\n         LM    R0,R3,20(R15)            Restore callers registers\n\n         L     R15,4(0,R1)              A(31-bit Stack Pointer)\n         ST    R15,@V_31Bit_Stack_Ptr_Ptr Save it\n         L     R15,8(0,R1)              A(24-bit Stack Pointer)\n         ST    R15,@V_24Bit_Stack_Ptr_Ptr Save it\n\n*---------------------------------------------------------------------*\n*   Load the base register for VolTbl_Ent                             *\n*---------------------------------------------------------------------*\n         L     R9,12(0,R1)             Point to VolTbl_Ent\n         USING VolTbl_Ent,R9           Tell the Assembler\n\n*---------------------------------------------------------------------*\n*   If this is a Stack Statistics line ...                            *\n*---------------------------------------------------------------------*\n         TM    VolTbl_Ent_Stats_31Stack,L'VolTbl_Ent_Stats_31Stack\n         JZ    V00020                   Not 31-bit Stack stats, skip\n         TM    VolTbl_Ent_Stats_Done,L'VolTbl_Ent_Stats_Done Done?\n         JO    V00060                   Yes, skip\n         L     R8,@V_31Bit_Stack_Ptr_Ptr Get 31-bit stack pointer\n         L     R8,0(0,R8)               and point to the stack\n         J     V00030                   and skip\nV00020   DS    0H\n         TM    VolTbl_Ent_Stats_24Stack,L'VolTbl_Ent_Stats_24Stack\n         JZ    V00080                   Not 24-bit Stack stats, skip\n         TM    VolTbl_Ent_Stats_Done,L'VolTbl_Ent_Stats_Done Done?\n         JO    V00060                   Yes, skip\n         L     R8,@V_24Bit_Stack_Ptr_Ptr No, get 24-bit stack pointer\n         L     R8,0(0,R8)               and point to it\nV00030   DS    0H\n         L     R15,@_VolTbl_Ptr         A(VolTbl)\n         TM    VolTbl_Hdr_ECB-VolTbl_Hdr(R15),X'40' Table populated\n         JO    V00030C                  Yes, OK\n         WAIT  ECB=VolTbl_Hdr_ECB-VolTbl_Hdr(R15) No, WAIT for it\nV00030C  DS    0H\n         LA    R14,V_Stats_Line4        A(Source)\n         LHI   R15,V_Stats_Line4_Len    Length of source\n         O     R15,=XL4'40000000'       Pad char of blank\n         LA    R0,VolTbl_Ent_Display    A(Target)\n         LHI   R1,VolTbl_Ent_Display_Len Length of target\n         MVCL  R0,R14                   Move Stats Line4\n         TM    VolTbl_Ent_Stats_31Stack,L'VolTbl_Ent_Stats_31Stack\n         JNO   V00040                   Not 31-bit stack, skip\n         MVC   VolTbl_Ent_Display+V_Stats_Line4_Stack-V_Stats_Line4(L'V+\n               _Stats_Line4_Stack),=C'31'\n         J     V00050\nV00040   DS    0H\n         TM    VolTbl_Ent_Stats_24Stack,L'VolTbl_Ent_Stats_24Stack\n         JNO   V00050                   Not 24-bit stack, skip\n         MVC   VolTbl_Ent_Display+V_Stats_Line4_Stack-V_Stats_Line4(L'V+\n               _Stats_Line4_Stack),=C'24'\n         J     V00050\nV00050   DS    0H\n\n         LTR   R0,R8                     Any Stack?\n         JZ    V00050C                   No, default of 0\n         L     R0,StackHdr_StackLen-StackHdr(R8) Get stack length\nV00050C  DS    0H\n         CVD   R0,@V_DBLWD               Pack it\n         ED    VolTbl_Ent_Display+V_Stats_Line4_Size-V_Stats_Line4(L'V_+\n               Stats_Line4_Size),@V_DBLWD+5\n\n         LTR   R0,R8                     Any Stack?\n         JZ    V00050E                   No, default of 0\n         L     R0,StackHdr_HWM-StackHdr(R8) Get high-water mark\n         SR    R0,R8                     as a length\nV00050E  DS    0H\n         CVD   R0,@V_DBLWD               Pack it\n         ED    VolTbl_Ent_Display+V_Stats_Line4_HWM-V_Stats_Line4(L'V_S+\n               tats_Line4_HWM),@V_DBLWD+5\n\n         LTR   R0,R8                     Any Stack?\n         JZ    V00050G                   No, default of 0\n         L     R0,StackHdr_GETMAIN-StackHdr(R8) Get converted PUSHs\nV00050G  DS    0H\n         CVD   R0,@V_DBLWD               Pack it\n         ED    VolTbl_Ent_Display+V_Stats_Line4_GETMAIN-V_Stats_Line4(L+\n               'V_Stats_Line4_GETMAIN),@V_DBLWD+5\n\n         LTR   R0,R8                     Any Stack?\n         JZ    V00050I                   No, default of 0\n         L     R0,StackHdr_Overflow_HWM-StackHdr(R8) GETMAIN HWM\nV00050I  DS    0H\n         CVD   R0,@V_DBLWD               Pack it\n         ED    VolTbl_Ent_Display+V_Stats_Line4_GHWM-V_Stats_Line4(L'V_+\n               Stats_Line4_GHWM),@V_DBLWD+5\n\n         OI    VolTbl_Ent_Stats_Done,L'VolTbl_Ent_Stats_Done Done now\n\n         L     R0,VolTbl_Ent_ECB        Current contents of our ECB\n         TM    VolTbl_Ent_ECB,X'80'     Anyone WAITing?\n         JO    V00050K                  Yes, we need to POST\n         L     R1,=XL4'40000000'        No, POST code of 0\n         CS    R0,R1,VolTbl_Ent_ECB     Pseudo-POST it\n         JZ    V00060                   OK, skip the real POST\nV00050K  DS    0H\n         POST  VolTbl_Ent_ECB,0         POST line as complete\n\nV00060   DS    0H\n         LA    R15,0                    Clear return code\n         J     V90010                   and exit\n\nV00080   DS    0H\n*---------------------------------------------------------------------*\n*   If this is a CPU Stats Line ...                                   *\n*---------------------------------------------------------------------*\n         TM    VolTbl_Ent_Stats_CPUTime,L'VolTbl_Ent_Stats_CPUTime\n         JZ    V01999                   Not CPU Time, skip\n         TM    VolTbl_Ent_Stats_Done,L'VolTbl_Ent_Stats_Done Done?\n         JO    V00110                   Yes, skip\n         L     R15,@_VolTbl_Ptr         A(VolTbl)\n         TM    VolTbl_Hdr_ECB-VolTbl_Hdr(R15),X'40' Table populated\n         JO    V00080C                  Yes, OK\n         WAIT  ECB=VolTbl_Hdr_ECB-VolTbl_Hdr(R15) No, WAIT for it\nV00080C  DS    0H\n         LA    R14,V_Stats_Line5        A(Source)\n         LHI   R15,V_Stats_Line5_Len    Length of source\n         O     R15,=XL4'40000000'       Pad char of blank\n         LA    R0,VolTbl_Ent_Display    A(Target)\n         LHI   R1,VolTbl_Ent_Display_Len Length of target\n         MVCL  R0,R14                   Move Stats Line5\n         TIMEUSED STORADR=@V_DBLWD,     Get CPU time used              +\n               LINKAGE=SYSTEM,           as recommended by IBM         +\n               CPU=MIC                   get it in microseconds\n         LM    R14,R15,@V_DBLWD         Get current TCB time\n         LM    R0,R1,@_CPU_Time_Init    Get TCB Time used previously\n         SLR   R15,R1                   Subtract\n         JNM   V00090                   No overflow, OK\n         SL    R14,=FL4'1'              Borrow, adjust\nV00090   DS    0H\n         SLR   R14,R0                   Adjust this one too\n\n         AL    R15,@_CPU_Time_Used+4    Bump Accum CPU Time\n         BRC   12,V00100                No Carry, OK\n         AL    R14,=FL4'1'              Carry, bump it\nV00100   DS    0H\n         AL    R14,@_CPU_Time_Used      Bump Accum CPU Time\n         D     R14,=FL4'1000'           To seconds (3 decimals)\n         CVD   R15,@V_DBLWD              Pack it\n         ED    VolTbl_Ent_Display+V_Stats_Line5_CPUTime-V_Stats_Line5(L+\n               'V_Stats_Line5_CPUTime),@V_DBLWD+5\n\n         TM    @_OW48527,L'@_OW48527     Is OW48527 on?\n         JO    V00100B                   Yes, never went NONSWAP\n\n         LA    R1,VolTbl_Ent_Display+V_Stats_Line5_CPUTime+L'V_Stats_Li+\n               ne5_CPUTime-V_Stats_Line5 A(End of line)\n         MVC   0(29,R1),=C', Non-Swappable Elapsed Time:'\n         MVC   29(7,R1),=X'4021204B202020' Move mask\n         LM    R14,R15,@_NSwap_Time      Get Non-swappable time\n         SRDL  R14,12                    Convert to usec\n         D     R14,=FL4'1000'            Convert to millisecs\n         CVD   R15,@V_DBLWD              Pack it\n         ED    29(7,R1),@V_DBLWD+5       Edit into message\n\nV00100B  DS    0H\n         OI    VolTbl_Ent_Stats_Done,L'VolTbl_Ent_Stats_Done Done now\n\n         L     R0,VolTbl_Ent_ECB        Current contents of our ECB\n         TM    VolTbl_Ent_ECB,X'80'     Anyone WAITing?\n         JO    V00100C                  Yes, we need to POST\n         L     R1,=XL4'40000000'        No, POST code of 0\n         CS    R0,R1,VolTbl_Ent_ECB     Pseudo-POST it\n         JZ    V00110                   OK, skip the real POST\nV00100C  DS    0H\n         POST  VolTbl_Ent_ECB,0         POST line as complete\n\nV00110   DS    0H\n         LA    R15,0                    Clear return code\n         J     V90010                   and exit\n\nV01999   DS    0H\n*---------------------------------------------------------------------*\n*   Unknown Stats Line, exit                                          *\n*---------------------------------------------------------------------*\n         LA    R15,0                    Clear return code\n         J     V90010                   and exit\n\n\nV90010   DS    0H\n*-------------------------------------------------------------------*\n*    Free up our local storage ...                                  *\n*-------------------------------------------------------------------*\n         LR    R3,R15                   Save return code\n\n         LA    R1,@V_Dynam              A(Local storage)\n         L     R2,@V_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         L     R13,4(0,R13)             Rescue A(HSA)\n\n         SSCSTACK POP,                  Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=(R2)                on this stack\n\n         LR    R15,R3                   Restore return code\n\n*-------------------------------------------------------------------*\n*    ... and return to caller                                       *\n*-------------------------------------------------------------------*\n         L     R14,12(0,R13)            Restore return address\n         LM    R0,R12,20(R13)           Restore other registers\n         BSM   0,R14                    and return\n\nV_Literals  DS  0H\n\n\nV_Stats_Line4         EQU   *\n                      DC    C' '\nV_Stats_Line4_Stack   DC    C'31'\n                      DC    C'-Bit Stack: Size:'\nV_Stats_Line4_Size    DC    X'402020202120'\n                      DC    C', HWM:'\nV_Stats_Line4_HWM     DC    X'402020202120'\n                      DC    C', GETMAINs:'\nV_Stats_Line4_GETMAIN DC    X'402020202120'\n                      DC    C', GETMAIN HWM:'\nV_Stats_Line4_GHWM    DC    X'402020202120'\nV_Stats_Line4_Len     EQU   *-V_Stats_Line4\n\nV_Stats_Line5         EQU   *\n                      DC    C' '\n                      DC    C'Main Task CPU Time:'\nV_Stats_Line5_CPUTime DC    X'4021204B202020'\nV_Stats_Line5_Len     EQU   *-V_Stats_Line5\n\n         LTORG\n\nV_Literals_End  DS  0H\n\n\n@V_Dynam                  DSECT        Dynamic area for V00000\n                          DS    18F     O/S Style save area\n@V_31Bit_Stack_Ptr_Ptr    DS    AL4     A(31-bit Stack Ptr)\n@V_24Bit_Stack_Ptr_Ptr    DS    AL4     A(24-bit Stack Ptr)\n@V_DBLWD                  DS    D       Work area\n                          DS    0D      Alignment\n@V_Dynam_Length           EQU   *-@V_Dynam Length of storage\n\n&PGMNAME CSECT\n\n         DROP  ,\n         POP   USING\n         TITLE 'W00010: Point to next free VolTbl entry'\n\n         PUSH  USING\n\nW00010   DS    0H\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Subroutine: W00010                                                 *\n*                                                                     *\n*  Abstract  : Return a pointer to the next free entry in VolTbl. If  *\n*              all entries are used, a larger VolTbl is GETMAINed, and*\n*              the current table copied to the new                    *\n*                                                                     *\n*  Inputs    : R1 : ---> A(@_Dynam)                                   *\n*                        A(31-bit Stack Pointer)                      *\n*                        A(24-bit Stack Pointer)                      *\n*  Outputs   : R1 : A(Free entry) or 0 if storage unavailable         *\n*                                                                     *\n*  Notes     : N/A                                                    *\n*                                                                     *\n*  History:    1999/08/20 SDDA030 - V2.8                              *\n*                                 - New                               *\n*              2006/04/21 SDDA030 - V2.24                             *\n*                                 - Used conditional STORAGE OBTAINs  *\n*                                   when expanding VolTbl             *\n*              ____/__/__ _______                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         STM   R14,R12,12(R13)          Save callers registers\n         LARL  R11,W_Literals           Point to our literals\n         USING (W_Literals,W_Literals_End),R11 Tell the assembler\n\n         L     R12,0(0,R1)              A(@_Dynam)\n         USING @_Dynam,R12              Tell the assembler\n\n*-------------------------------------------------------------------*\n*    Get an area on the stack for our local storage                 *\n*-------------------------------------------------------------------*\n         L     R2,4(0,R1)               A(31-bit stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         SSCSTACK PUSH,                 Get stack area                 +\n               LEN=@W_Dynam_Length,      this long                     +\n               STACK=(R2)                using this stack\n\n         LR    R3,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LHI   R1,@W_Dynam_Length        Its length\n         LA    R14,0                    Clear source address\n         LA    R15,0                     and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R3                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*-------------------------------------------------------------------*\n         ST    R13,4(0,R1)              Chain\n         ST    R1,8(0,R13)               saveareas\n         LR    R13,R1                   Load dynam base\n         USING @W_Dynam,R13             Assign a base\n         L     R15,@W_Dynam+4           Get A(HSA)\n         LM    R0,R3,20(R15)            Restore callers registers\n\n         L     R15,4(0,R1)              A(31-bit Stack Pointer)\n         ST    R15,@W_31Bit_Stack_Ptr_Ptr Save it\n         L     R15,8(0,R1)              A(24-bit Stack Pointer)\n         ST    R15,@W_24Bit_Stack_Ptr_Ptr Save it\n\nW00020   DS    0H\n*---------------------------------------------------------------------*\n*   Point to the next free entry                                      *\n*---------------------------------------------------------------------*\n         LA    R14,0                    Clear used length\n         LA    R15,0                    Clear table length\n         ICM   R1,B'1111',@_VolTbl_Ptr  A(Current table)\n         JZ    W00030                   None, skip\n         LHI   R14,VolTbl_Ent_Len       Yes, Length of 1 entry\n         L     R15,VolTbl_Hdr_Count-VolTbl_Hdr(R1) Current entries used\n         MR    R14,R14                  Get current length used\n         LR    R14,R15                  Save it\n         L     R15,VolTbl_Hdr_TbLen-VolTbl(R1) Get len of table\n         AR    R15,R1                   Point to end of table\nW00030   DS    0H\n         LA    R1,VolTbl_Ent-VolTbl(R1,R14) Point to next (free) entry\n         SR    R15,R1                   Get length remaining\n         LHI   R0,VolTbl_Ent_Len        Length of 1 entry\n         CR    R15,R0                   Do we have room to add?\n         JNL   W00060                   Yes, skip\n\n*---------------------------------------------------------------------*\n*   We have to get a new table, so get the current number of entries  *\n*---------------------------------------------------------------------*\n         TM    @_VolTbl_GETMAIN_Err,L'@_VolTbl_GETMAIN_Err\n         JO    W80010                   Yes, just exit with error\n\n         LHI   R15,99                   Initial nbr entries (1st time)\n         ICM   R1,B'1111',@_VolTbl_Ptr  A(Table)\n         JZ    W00040                   None, skip\n         L     R15,VolTbl_Hdr_Count-VolTbl_Hdr(R1) Yes, get nbr ents\n\nW00040   DS    0H\n*---------------------------------------------------------------------*\n*   Calculate the Min (1 more entry) and Max (double the number of    *\n*    entries) lengths of the new table ...                            *\n*---------------------------------------------------------------------*\n         LA    R0,1(0,R15)              Min of 1 more entry\n         LHI   R1,VolTbl_Ent_Len        Length of 1 entry\n         MR    R0,R0                    Get new length of entries\n         LA    R4,VolTbl_Ent-VolTbl(R1) Add length of header\n         AHI   R4,7                     Make sure its\n         SRL   R4,3                      a doubleword\n         SLL   R4,3                      multiple\n\n         LR    R0,R15                   Max len of double\n         SLL   R0,1                      the number of entries\n         LHI   R1,VolTbl_Ent_Len        Length of 1 entry\n         MR    R0,R0                    Get new length of entries\n         LA    R5,VolTbl_Ent-VolTbl(R1) Add length of header\n         AHI   R5,7                     Make sure its\n         SRL   R5,3                      a doubleword\n         SLL   R5,3                      multiple\n\n*---------------------------------------------------------------------*\n*   ... and go get storage for it                                     *\n*---------------------------------------------------------------------*\n         BASR  R2,0\n         USING (*,W00040_End-1),R2\n         STORAGE OBTAIN,                Go get a table                 +\n               LENGTH=((4),(5)),         this long                     +\n               LOC=31,                   above-the-line                +\n               COND=YES,                 let us know what happens      +\n               ADDR=(3)                  return address here\nW00040_End DS  0H\n         DROP  R2\n\n         LTR   R15,R15                  Did we get the storage?\n         JNZ   W80010                   No, oh dear\n\n*---------------------------------------------------------------------*\n*   Copy the old table to the new.                                    *\n*---------------------------------------------------------------------*\n         LR    R4,R0                    Save new table length\n         LR    R1,R0                    New table length\n         LR    R0,R3                    Point to the new table\n         LA    R15,0                    Clear old table length\n         ICM   R14,B'1111',@_VolTbl_Ptr A(Old table)\n         JZ    W00050                   None, skip\n         L     R15,VolTbl_Hdr_TbLen-VolTbl(R14) Yes, get current length\nW00050   DS    0H\n         MVCL  R0,R14                   Move old to new\n         ST    R4,VolTbl_Hdr_TbLen-VolTbl(R3) Update table length\n         L     R1,@_VolTbl_Ptr          A(Old table)\n         ST    R3,@_VolTbl_Ptr          Update with A(New table)\n         LTR   R1,R1                    Is there an old table?\n         JZ    W00020                   No, start again\n\n*---------------------------------------------------------------------*\n*   Free up the old table                                             *\n*---------------------------------------------------------------------*\n         L     R0,VolTbl_Hdr_TbLen-VolTbl(R1) Get its length\n         BASR  R2,0\n         USING (*,W00050_End-1),R2\n         STORAGE RELEASE,               Free the old table             +\n               ADDR=(1),                 starting here                 +\n               LENGTH=(0)                for this long\nW00050_End DS  0H\n         DROP  R2\n         J     W00020                   Start again\n\nW00060   DS    0H\n*---------------------------------------------------------------------*\n*   We have an new entry: bump nbr entries used ...                   *\n*---------------------------------------------------------------------*\n         L     R15,@_VolTbl_Ptr         A(Volume Table)\n         L     R14,VolTbl_Hdr_Count-VolTbl_Hdr(R15) Get # used entries\n         AHI   R14,1                    Bump it\n         ST    R14,VolTbl_Hdr_Count-VolTbl_Hdr(R15) Save it\n\n*---------------------------------------------------------------------*\n*   ... and initialize the entry.                                     *\n*---------------------------------------------------------------------*\n         LR    R2,R1                    Save Entry address\n\n         LR    R0,R2                    A(Target)\n         LHI   R1,VolTbl_Ent_Len        Length of entry\n         LA    R14,0                    A(Source)\n         LA    R15,0                    Length of source\n         MVCL  R0,R14                   Set table entry to X'00'\n\n         LA    R0,VolTbl_Ent_Display-VolTbl_Ent(R2) A(Display area)\n         LHI   R1,VolTbl_Ent_Display_Len Length of display area\n         LA    R14,0                    A(Source)\n         L     R15,=XL4'40000000'       Source len = 0, pad = blank\n         MVCL  R0,R14                   Set display area to blanks\n\n         LR    R1,R2                    A(Table entry)\n         SLR   R15,R15                  Clear return code\n         J     W90010                   and exit\n\nW80010   DS    0H\n*-------------------------------------------------------------------*\n*    STORAGE OBTAIN error: set a flag so we don't try to get more,  *\n*                          set return code, and exit                *\n*-------------------------------------------------------------------*\n         OI    @_VolTbl_GETMAIN_Err,L'@_VolTbl_GETMAIN_Err\n         SLR   R1,R1                    Clear A(New entry)\n         LA    R15,8                    Set return code\n         J     W90010                   and exit\n\nW90010   DS    0H\n*-------------------------------------------------------------------*\n*    Free up our local storage ...                                  *\n*-------------------------------------------------------------------*\n         LR    R3,R1                    Save A(Free entry)\n         LR    R4,R15                   Save return code\n\n         LA    R1,@W_Dynam              A(Local storage)\n         L     R2,@W_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         L     R13,4(0,R13)             Rescue A(HSA)\n\n         SSCSTACK POP,                  Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=(R2)                on this stack\n\n         LR    R1,R3                    Restore A(Free entry)\n         LR    R15,R4                   Restore return code\n\n*-------------------------------------------------------------------*\n*    ... and return to caller                                       *\n*-------------------------------------------------------------------*\n         L     R14,12(0,R13)            Restore return address\n         L     R0,20(0,R13)             Restore R0\n         LM    R2,R12,28(R13)           Restore other registers\n         BSM   0,R14                    and return\n\nW_Literals  DS  0H\n\n         LTORG\n\nW_Literals_End  DS  0H\n\n\n@W_Dynam                  DSECT       Dynamic area for W00000\n@W_Save                   DS    18F    O/S Style save area\n@W_31Bit_Stack_Ptr_Ptr    DS    AL4    A(31-bit Stack Ptr)\n@W_24Bit_Stack_Ptr_Ptr    DS    AL4    A(24-bit Stack Ptr)\n                          DS    0D     Alignment\n@W_Dynam_Length           EQU   *-@W_Dynam Length of storage\n\n&PGMNAME CSECT\n\n         DROP  ,\n         POP   USING\n         TITLE 'X00010: Write data to OUTFIL'\n\n         PUSH  USING\n\nX00010   DS    0H\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Subroutine: X00010                                                 *\n*                                                                     *\n*  Abstract  : This subroutine goes through the VolTbl, writing       *\n*              detail lines to the DDName passed.                     *\n*                                                                     *\n*  Inputs    : R1 : ---> A(@_Dynam)                                   *\n*                        A(31-bit Stack Pointer)                      *\n*                        A(24-bit Stack Pointer)                      *\n*                        A(DDName)                                    *\n*                        A(OutData flag)                              *\n*  Outputs   : R15: 0 = OK                                            *\n*                   8 = Error (DCB not OPEN, etc.)                    *\n*                                                                     *\n*  Operation : Set up parms for U00010                                *\n*              Do for each Detail line in VolTbl                      *\n*                Invoke U00010                                        *\n*              EndDo                                                  *\n*              Return to caller                                       *\n*                                                                     *\n*  History:    2000/01/19 SDDA030 - V2.11                             *\n*                                   New                               *\n*              2000/05/23 SDDA030 - V2.12                             *\n*                                   Added check for OUTFILE(SYSPRINT) *\n*                                   Checked BLKSIZE=0                 *\n*              2001/02/26 SDDA030 - V2.14                             *\n*                                   Output all detail entries from    *\n*                                   VolTbl instead of one at a time.  *\n*              2002/03/11 SDDA030 - V2.17                             *\n*                                   Converted RDJFCB to SWAREQ.       *\n*                                   Updated logic for LRECL, BLKSIZE. *\n*                                   Improved efficiency.              *\n*                                   Preserved BLKSIZE for RECFM=U.    *\n*              2002/06/11 SDDA030 - V2.18                             *\n*                                   WAIT for VolTbl_Ent to be populated\n*                                   before outputting                 *\n*              2003/10/07 SDDA030 - V2.21                             *\n*                                   Accept DDName, OutData flag as    *\n*                                   parms.                            *\n*                                   Remove check for SYSPRINT.        *\n*                                   Moved OPEN/CLOSE, I/O to U00010.  *\n*              2006/04/21 SDDA030 - V2.24                             *\n*                                   Used standardised calling sequence*\n*              ____/__/__ ______                                      *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         STM   R14,R12,12(R13)          Save callers registers\n         LARL  R11,X_Literals           Point to our literals\n         USING (X_Literals,X_Literals_End),R11 Tell the assembler\n\n         L     R12,0(0,R1)              A(@_Dynam)\n         USING @_Dynam,R12              Tell the assembler\n\n*-------------------------------------------------------------------*\n*    Get an area on the stack for our local storage                 *\n*-------------------------------------------------------------------*\n         L     R2,4(0,R1)               A(31-bit stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         SSCSTACK PUSH,                 Get stack area                 +\n               LEN=@X_Dynam_Length,      this long                     +\n               STACK=(R2)                using this stack\n\n         LR    R3,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LHI   R1,@X_Dynam_Length        Its length\n         LA    R14,0                    Clear source address\n         LA    R15,0                     and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R3                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*-------------------------------------------------------------------*\n         ST    R13,4(0,R1)              Chain\n         ST    R1,8(0,R13)               saveareas\n         LR    R13,R1                   Load dynam base\n         USING @X_Dynam,R13             Assign a base\n         L     R15,@X_Dynam+4           Get A(HSA)\n         LM    R0,R3,20(R15)            Restore callers registers\n\n         L     R15,4(0,R1)              A(31-bit Stack Pointer)\n         ST    R15,@X_31Bit_Stack_Ptr_Ptr Save it\n         L     R15,8(0,R1)              A(24-bit Stack Pointer)\n         ST    R15,@X_24Bit_Stack_Ptr_Ptr Save it\n\n*--------------------------------------------------------------------*\n*   Initialize our standard parmlist                                 *\n*--------------------------------------------------------------------*\n         LA    R15,@_Dynam              A(Dynamic area)\n         ST    R15,@X_Parms_Std         Save it\n         L     R15,@X_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)\n         ST    R15,@X_Parms_Std+4       Save it\n         L     R15,@X_24Bit_Stack_Ptr_Ptr A(24-bit Stack Pointer)\n         ST    R15,@X_Parms_Std+8       Save it\n\n*-------------------------------------------------------------------*\n*    Build our parm list for U00010                                 *\n*-------------------------------------------------------------------*\n        ICM   R15,B'1111',12(R1)        A(DDName)\n        JZ    X00350                    None, exit quietly\n        ST    R15,@X_Parms_U00010       OK, save it\n\n*-------------------------------------------------------------------*\n*    Get the length and offset of the data we will be writing       *\n*-------------------------------------------------------------------*\n         ICM   R1,B'1111',16(R1)         A(OutData flag)\n         TM    0(R1),L'@_OutData_DISPLAY  Display only?\n         JNO   X00260                  No, skip\n         LA    R14,VolTbl_Ent_Display-VolTbl_Ent Yes, Offset of start\n         LHI   R15,VolTbl_Ent_Display_Len and get length\n         J     X00280                  skip\nX00260   DS    0H\n         TM    0(R1),L'@_OutData_CB    Control Blocks only?\n         JNO   X00270                  No, skip\n         LA    R14,VolTbl_Ent_CB_Start-VolTbl_Ent Yes, Offset of start\n         LHI   R15,VolTbl_Ent_CB_End-VolTbl_Ent_CB_Start and length\n         J     X00280                  and skip\nX00270   DS    0H\n         LA    R14,VolTbl_Ent_CB_Start-VolTbl_Ent ALL, Offset of CB)\n         LHI   R15,VolTbl_Ent_Display_End-VolTbl_Ent_CB_Start Length\nX00280   DS    0H\n         ST    R14,@X_Source_Offset    Save Offset\n         ST    R15,@X_Source_Len       Save Length\n         LA    R15,@X_Source_Len       A(Length)\n         ST    R15,@X_Parms_U00010+8   Save for U00010\n\n         OI    @X_Parms_U00010+8,X'80'   Flag as last\n\n*-------------------------------------------------------------------*\n*    Go through VolTbl ...                                          *\n*-------------------------------------------------------------------*\n         ICM   R9,B'1111',@_VolTbl_Ptr A(Volume Table)\n         JZ    X00350                  None, exit quietly\n         ICM   R10,B'1111',VolTbl_Hdr_Count-VolTbl(R9) Get nbr vols\n         JZ    X00350                  None, we're done\n         LA    R9,VolTbl_Ent-VolTbl(R9) A(1st entry)\n\n         Using VolTbl_Ent,R9           Tell the assembler\n\nX00330   DS    0H\n*-------------------------------------------------------------------*\n*    If this is a detail line, write it out                         *\n*-------------------------------------------------------------------*\n         TM    VolTbl_Ent_Detail_Line,L'VolTbl_Ent_Detail_Line Detail?\n         JNO   X00340                  No, skip it\n         TM    VolTbl_Ent_SMS_Line,L'VolTbl_Ent_SMS_Line SMS Anomaly?\n         JO    X00340                  Yes, skip it\n\n         TM    VolTbl_Ent_ECB,X'40'    Yes, is it populated?\n         JO    X00330C                 Yes, OK\n         WAIT  ECB=VolTbl_Ent_ECB      No, WAIT 'till it is\nX00330C  DS    0H\n         LA    R15,VolTbl_Ent          A(Entry)\n         A     R15,@X_Source_Offset    Point to our data\n         ST    R15,@X_Parms_U00010+4   Save it\n\n         LA    R1,@X_Parms             A(Parm list)\n         BRAS  R14,U00010              Output it\n\nX00340   DS    0H\n*-------------------------------------------------------------------*\n*    And process the next entry                                     *\n*-------------------------------------------------------------------*\n         AHI   R9,VolTbl_Ent_Len       A(Next VolTbl entry)\n         BRCT  R10,X00330              and do the next\n\nX00350   DS    0H\n*-------------------------------------------------------------------*\n*    Clear the return code, and exit.                               *\n*-------------------------------------------------------------------*\n         LA    R15,0                   Clear return code\n         J     X90010                  and exit\n\nX90010   DS    0H\n*-------------------------------------------------------------------*\n*    Free up our local storage ...                                  *\n*-------------------------------------------------------------------*\n         LR    R3,R15                   Save Return Code\n\n         LA    R1,@X_Dynam              A(Local storage)\n         L     R2,@X_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         L     R13,4(0,R13)             Rescue A(HSA)\n\n         SSCSTACK POP,                  Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=(R2)                on this stack\n\n         LR    R15,R3                   Restore Return Code\n\n*-------------------------------------------------------------------*\n*    ... and return to caller                                       *\n*-------------------------------------------------------------------*\n         L     R14,12(0,R13)            Restore return address\n         LM    R0,R12,20(R13)           Restore other registers\n         BSM   0,R14                    and return\n\nX_Literals  DS  0H\n\n         LTORG\n\nX_Literals_End  DS  0H\n\n\n@X_Dynam                  DSECT       Dynamic area for 10000\n                          DS    18F    O/S Style save area\n@X_31Bit_Stack_Ptr_Ptr    DS    AL4    A(31-bit Stack Ptr)\n@X_24Bit_Stack_Ptr_Ptr    DS    AL4    A(24-bit Stack Ptr)\n\n@X_Source_Offset          DS    FL4    Offset (in VolTbl_Ent)\n@X_Source_Len             DS    FL4    Length of data\n\n@X_Parms                  DS    0F     Parms for called rtns\n@X_Parms_Std              DS    3AL4    Standard 3 parms\n@X_Parms_Extra            EQU   *       Extra parms\n@X_Parms_U00010           DS    4AL4       for U00010\n                          ORG   ,\n\n                          DS    0D     Alignment\n@X_Dynam_Length           EQU   *-@X_Dynam Length of storage\n\n&PGMNAME CSECT\n\n         DROP  ,\n         POP   USING\n         TITLE 'Y00010: SYSPRINT I/O Routine'\n\n         PUSH  USING\n\nY00010   DS    0H\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Subroutine: Y00010                                                 *\n*                                                                     *\n*  Abstract  : This subroutine manages messages destined for SYSPRINT.*\n*                                                                     *\n*  Inputs    : R1 : ---> A(@_Dynam)                                   *\n*                        A(31-bit Stack Pointer)                      *\n*                        A(24-bit Stack Pointer)                      *\n*                        A(Data to be written) or 0                   *\n*                        Length of data to be written                 *\n*  Outputs   : R15: 0 = OK                                            *\n*                   8 = Error (SYSPRINT not OPEN, etc.)               *\n*                                                                     *\n*  Notes     :                                                        *\n*                                                                     *\n*  History:    1998/10/01 SDDA030 - New                               *\n*              1999/05/27 SDDA030 - V2.6                              *\n*                                 - Moved back into mainline code.    *\n*                                 - Used LIFO Stack for our dynamic   *\n*                                   areas.                            *\n*              1999/09/30 SDDA030 - V2.10                             *\n*                                 - Used @_Line_Count values to gen-  *\n*                                   erate Hdr0-3.                     *\n*              2001/02/26 SDDA030 - V2.14                             *\n*                                 - Headings now in table.            *\n*                                 - Only write DCBLRECLs worth of     *\n*                                   data to SYSPRINT.                 *\n*              2003/10/07 SDDA030 - V2.21                             *\n*                                 - Moved OPEN/CLOSE, I/O to U00010.  *\n*                                 - Trimmed trailing spaces.          *\n*              2006/04/21 SDDA030 - V2.24                             *\n*                                 - Used standardised calling sequence*\n*                                 - Checked length to be written      *\n*                                   against LINESIZE()                *\n*              ____/__/__ ______                                      *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         STM   R14,R12,12(R13)          Save callers registers\n         LARL  R11,Y_Literals           Point to our literals\n         USING (Y_Literals,Y_Literals_End),R11 Tell the assembler\n\n         L     R12,0(0,R1)              A(@_Dynam)\n         USING @_Dynam,R12              Tell the assembler\n\n*-------------------------------------------------------------------*\n*    Get an area on the stack for our local storage                 *\n*-------------------------------------------------------------------*\n         L     R2,4(0,R1)               A(31-bit stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         SSCSTACK PUSH,                 Get stack area                 +\n               LEN=@Y_Dynam_Length,      this long                     +\n               STACK=(R2)                using this stack\n\n         LR    R3,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LHI   R1,@Y_Dynam_Length        Its length\n         LA    R14,0                    Clear source address\n         LA    R15,0                     and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R3                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*-------------------------------------------------------------------*\n         ST    R13,4(0,R1)              Chain\n         ST    R1,8(0,R13)               saveareas\n         LR    R13,R1                   Load dynam base\n         USING @Y_Dynam,R13             Assign a base\n         L     R15,@Y_Dynam+4           Get A(HSA)\n         LM    R0,R3,20(R15)            Restore callers registers\n\n         L     R15,4(0,R1)              A(31-bit Stack Pointer)\n         ST    R15,@Y_31Bit_Stack_Ptr_Ptr Save it\n         L     R15,8(0,R1)              A(24-bit Stack Pointer)\n         ST    R15,@Y_24Bit_Stack_Ptr_Ptr Save it\n\n*--------------------------------------------------------------------*\n*   Initialize our standard parmlist                                 *\n*--------------------------------------------------------------------*\n         LA    R15,@_Dynam              A(Dynamic area)\n         ST    R15,@Y_Parms_Std         Save it\n         L     R15,@Y_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)\n         ST    R15,@Y_Parms_Std+4       Save it\n         L     R15,@Y_24Bit_Stack_Ptr_Ptr A(24-bit Stack Pointer)\n         ST    R15,@Y_Parms_Std+8       Save it\n\n*-------------------------------------------------------------------*\n*    If we have nothing to do, just exit.                           *\n*-------------------------------------------------------------------*\n         ICM   R15,B'1111',12(R1)       A(Data to be printed)\n         JZ    Y00130                   Nothing, just exit\n         ICM   R0,B'1111',16(R1)        Len of data\n         JZ    Y00130                   Nothing, just exit\n         LR    R1,R15                   A(Date in proper register)\n         ST    R15,@Y_Passed_Data_Ptr   Save A(Data)\n         ST    R0,@Y_Passed_Data_Len    and length\n\n         LA    R15,Y_SYSPRINT           A(DDNAme)\n         ST    R15,@Y_Parms_U00010      Save it for U00010\n         LA    R15,@Y_Data_Len          Point to length\n         ST    R15,@Y_Parms_U00010+8    Update Parms\n         LA    R15,@Y_ASA_Char          A(Our ASA character)\n         ST    R15,@Y_Parms_U00010+12   Save it\n\n*---------------------------------------------------------------------*\n*       Set our max len to LINESIZE(), if applicable                  *\n*---------------------------------------------------------------------*\n         LHI   R15,VolTbl_Ent_Display_Len Max len of data\nY00020   DS    0H\n         LH    R1,@_LineSize            Get linesize from command line\n         LTR   R1,R1                    Anything?\n         JNP   Y00040                   LINESIZE(MAX) or none, skip\n         CR    R15,R1                   Can we display all the data?\n         JNH   Y00040                   Yes, OK\n         LR    R15,R1                   No, display as much as we can\nY00040   DS    0H\n         STH   R15,@Y_LineSize          Save it\n\n*---------------------------------------------------------------------*\n*       Print headings, if required. By convention, the line count    *\n*      determines what headings to print:                             *\n*        =4095: Hdg1 only                                             *\n*        =4094: Hdg2-4 only                                           *\n*        >60  : Hdg1-4                                                *\n*---------------------------------------------------------------------*\n         MVI   @Y_ASA_Char,C' '         Assume single space\n\n         LH    R15,@_Line_Count         Get current line count\n         CHI   R15,60                   Over a page?\n         JNH   Y00090                   No, skip\n         TM    @_No_Headings,L'@_No_Headings Yes, do we want headings?\n         JO    Y00090                   No, skip\n         ICM   R9,B'1111',@_VolTbl_Ptr  Yes, get A(VolTbl)\n         JZ    Y00090                   None, no headings\n\n*-------------------------------------------------------------------*\n*    We are about to print headings - set up the length field ...   *\n*-------------------------------------------------------------------*\n         LH    R0,@Y_LineSize          Length of source data\n         ST    R0,@Y_Data_Len           Save it\n         L     R10,VolTbl_Hdr_Count-VolTbl_Hdr(R9) Yes, get count\n         AHI   R9,VolTbl_Ent-VolTbl     and point to first entry\n         USING VolTbl_Ent,R9            Assign a base\n\n         LH    R15,@_Line_Count         Get line count\n         CHI   R15,4094                 Hdg2-4 only?\n         JE    Y00070                   Yes, skip Hdg0\n\n*-------------------------------------------------------------------*\n*    ... Hdg0 ...                                                   *\n*-------------------------------------------------------------------*\n         CHI   R10,1                    Check VolTbl_Ent count\n         JL    Y00090                   No heading, skip\n         TM    VolTbl_Ent_Heading_Line1,L'VolTbl_Ent_Heading_Line1 Hdg1\n         JNO   Y00060                   No, skip\n         MVI   @Y_ASA_Char,C'1'         Yes, start a new page\n         LA    R15,VolTbl_Ent_Display   Point to Heading 1\n         ST    R15,@Y_Parms_U00010+4    Update Parms\n         AHI   R15,VolTbl_Ent_Display_Len-8 A(Page Literal)\nY00050   DS    0H\n         MVC   0(4,R15),=C'Page'        Move page lit\n         LH    R0,@_Page_Count          Get Page count\n         AHI   R0,1                     Bump it\n         STH   R0,@_Page_Count          Save it\n         CVD   R0,@Y_DBLWD              Pack it\n         MVC   4(4,R15),=X'40202120'    Move mask\n         ED    4(4,R15),@Y_DBLWD+6      Edit page count\n         OI    7(R15),X'F0'             Make it readable\n         LA    R1,@Y_Parms              A(Parm list)\n         BRAS  R14,U00010               Output Hdg1\n\n         MVI   @Y_ASA_Char,C'0'         skip a line\n         LH    R15,@_Line_Count         Get line count\n         CHI   R15,4094                 Hdg0 only?\n         JNH   Y00070                   No, all headings\n         LHI   R15,1                    Yes, initialize line count\n         J     Y00090                   and skip\n\nY00060   DS    0H\n*-------------------------------------------------------------------*\n*    ... Hdg1-Hdg3 ...                                              *\n*-------------------------------------------------------------------*\n         TM    VolTbl_Ent_Heading_Line,L'VolTbl_Ent_Heading_Line Hdg?\n         JNO   Y00080                   No, end of headings\n         LA    R14,VolTbl_Ent_Display   A(Source data)\n         ST    R14,@Y_Parms_U00010+4    Save it for U00010\n         LA    R1,@Y_Parms              A(Parm list)\n         BRAS  R14,U00010               Output it\n         MVI   @Y_ASA_Char,C' '         single space\nY00070   DS    0H\n         AHI   R9,VolTbl_Ent_Len        A(Next entry\n         BRCT  R10,Y00060               and do next one\nY00080   DS    0H\n         LHI   R15,5                    Re-init line count\n\n         DROP  R9                       No more VolTbl_Ent base\n\nY00090   DS    0H\n*---------------------------------------------------------------------*\n*       ... and then write the data passed to us.                     *\n*---------------------------------------------------------------------*\n         AHI   R15,1                    Bump line count\n         STH   R15,@_Line_Count         Save line count\n         L     R0,@Y_Passed_Data_Len    Get length of data\n         CH    R0,@Y_LineSize           Too long?\n         JNH   Y00100                   No, OK\n         LH    R0,@Y_LineSize           Yes, reset it\nY00100   DS    0H\n         L     R1,@Y_Passed_Data_Ptr    A(Data)\n         LR    R15,R1                   Point past\n         AR    R15,R0                    last character\nY00110   DS    0H\n         S     R15,=FL4'1'              Back up a byte\n         CR    R15,R1                   Too far?\n         JNH   Y00120                   Yes, skip\n         CLI   0(R15),C' '              Trailing space?\n         JE    Y00110                   Yes, back up and try again\nY00120   DS    0H\n         SLR   R15,R1                   Length of\n         AHI   R15,1                     data1\n         ST    R15,@Y_Data_Len          Save length\n         ST    R1,@Y_Parms_U00010+4     Save A(Data)\n         LA    R1,@Y_Parms              A(Parm list)\n         BRAS  R14,U00010               Output it\n\nY00130   DS    0H\n*---------------------------------------------------------------------*\n*       Exit with a return code of 0                                  *\n*---------------------------------------------------------------------*\n         LA    R15,0                    Clear return code\n         J     Y90010                   and exit\n\n\nY90010   DS    0H\n*-------------------------------------------------------------------*\n*    Free up our local storage ...                                  *\n*-------------------------------------------------------------------*\n         LR    R3,R15                   Save return code\n\n         LA    R1,@Y_Dynam              A(Local storage)\n         L     R2,@Y_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         L     R13,4(0,R13)             Rescue A(HSA)\n\n         SSCSTACK POP,                  Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=(R2)                on this stack\n\n         LR    R15,R3                   Restore return code\n\n*-------------------------------------------------------------------*\n*    ... and return to caller                                       *\n*-------------------------------------------------------------------*\n         L     R14,12(0,R13)            Restore return address\n         LM    R0,R12,20(R13)           Restore other registers\n         BSM   0,R14                    and return\n\nY_Literals  DS  0H\n\nY_SYSPRINT  DC  CL8'SYSPRINT'\n\n         LTORG\n\nY_Literals_End  DS  0H\n\n\n@Y_Dynam                  DSECT       Dynamic area for Y00000\n                          DS    18F    O/S Style save area\n@Y_31Bit_Stack_Ptr_Ptr    DS    AL4    A(31-bit Stack Ptr)\n@Y_24Bit_Stack_Ptr_Ptr    DS    AL4    A(24-bit Stack Ptr)\n@Y_DBLWD                  DS    D      Work area\n@Y_LineSize               DS    HL2    Max line size\n@Y_Passed_Data_Ptr        DS    AL4    A(Data passed to us)\n@Y_Passed_Data_Len        DS    FL4    Len of data passed to us\n@Y_Data_Len               DS    FL4    Length of data\n@Y_ASA_Char               DS    X      Carriage control character\n\n@Y_Parms                  DS    0F     Parms for called rtns\n@Y_Parms_Std              DS    3AL4    Standard 3 parms\n@Y_Parms_Extra            EQU   *       Extra parms\n@Y_Parms_U00010           DS    4AL4        for U00010\n                          ORG   ,\n                          DS    0D     Alignment\n@Y_Dynam_Length           EQU   *-@Y_Dynam Length of storage\n\n&PGMNAME CSECT\n\n         DROP  ,\n         POP   USING\n         TITLE 'Z00010: Termination'\n\n         PUSH  USING\n\nZ00010   DS    0H\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Subroutine: Z00010                                                 *\n*                                                                     *\n*  Abstract  : Perform one-time termination processes based on        *\n*              environment.                                           *\n*                                                                     *\n*  Inputs    : R1 : ---> A(@_Dynam)                                   *\n*                        A(31-bit Stack Pointer)                      *\n*                        A(24-bit Stack Pointer)                      *\n*  Outputs   : R15: 0                                                 *\n*                                                                     *\n*  Notes     :                                                        *\n*                                                                     *\n*  History:    1990/06/11 SDDA030 - New                               *\n*              1998/09/21 SDDA030 - Added CLOSEs for SYSIN and        *\n*                                   SYSPRINT in batch mode            *\n*              1998/10/01 SDDA030 - Free up 24-bit storage            *\n*              1999/05/27 SDDA030 - V2.6                              *\n*                                 - Used LIFO Stack for our dynamic   *\n*                                   areas.                            *\n*                                 - Remove CLOSE and STORAGE RELEASE  *\n*              2002/03/11 SDDA030 - V2.17                             *\n*                                 - Freed up the STORGRP selection    *\n*                                   list                              *\n*              2006/04/21 SDDA030 - V2.24                             *\n*                                 - Used standardised calling sequence*\n*              ____/__/__ _______                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         STM   R14,R12,12(R13)          Save callers registers\n         LARL  R11,Z_Literals           Point to our literals\n         USING (Z_Literals,Z_Literals_End),R11 Tell the assembler\n\n         L     R12,0(0,R1)              A(@_Dynam)\n         USING @_Dynam,R12              Tell the assembler\n\n*-------------------------------------------------------------------*\n*    Get an area on the stack for our local storage                 *\n*-------------------------------------------------------------------*\n         L     R2,4(0,R1)               A(31-bit stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         SSCSTACK PUSH,                 Get stack area                 +\n               LEN=@Z_Dynam_Length,      this long                     +\n               STACK=(R2)                using this stack\n\n         LR    R3,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LHI   R1,@Z_Dynam_Length        Its length\n         LA    R14,0                    Clear source address\n         LA    R15,0                     and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R3                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*-------------------------------------------------------------------*\n         ST    R13,4(0,R1)              Chain\n         ST    R1,8(0,R13)               saveareas\n         LR    R13,R1                   Load dynam base\n         USING @Z_Dynam,R13             Assign a base\n         L     R15,@Z_Dynam+4           Get A(HSA)\n         LM    R0,R3,20(R15)            Restore callers registers\n\n         L     R15,4(0,R1)              A(31-bit Stack Pointer)\n         ST    R15,@Z_31Bit_Stack_Ptr_Ptr Save it\n         L     R15,8(0,R1)              A(24-bit Stack Pointer)\n         ST    R15,@Z_24Bit_Stack_Ptr_Ptr Save it\n\n*--------------------------------------------------------------------*\n*   Initialize our standard parmlist                                 *\n*--------------------------------------------------------------------*\n         LA    R15,@_Dynam              A(Dynamic area)\n         ST    R15,@Z_Parms_Std         Save it\n         L     R15,@Z_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)\n         ST    R15,@Z_Parms_Std+4       Save it\n         L     R15,@Z_24Bit_Stack_Ptr_Ptr A(24-bit Stack Pointer)\n         ST    R15,@Z_Parms_Std+8       Save it\n\n*---------------------------------------------------------------------*\n*   Reset our priority, if we changed it                              *\n*---------------------------------------------------------------------*\n         TM    @_CHAP_Done,L'@_CHAP_Done Did we lower our priority?\n         JZ    Z00010I                  No, skip\n         CHAP  1,'S'                    Yes, reset it\n         NI    @_CHAP_Done,X'FF'-L'@_CHAP_Done and reset flag\n\nZ00010I  DS    0H\n*---------------------------------------------------------------------*\n*   Free up the Volume Table, if there is one                         *\n*---------------------------------------------------------------------*\n         ICM   R1,B'1111',@_VolTbl_Ptr A(Info Table)\n         JZ    Z00020                  None, skip\n         L     R0,VolTbl_Hdr_TbLen-VolTbl(R1) Get its length\n         BASR  R2,0\n         USING (*,Z00010_End-1),R2\n         STORAGE RELEASE,               Free the table                 +\n               ADDR=(1),                 starting here                 +\n               LENGTH=(0)                for this long\nZ00010_End DS  0H\n         DROP  R2\n         LA    R15,0                    Clear work register\n         ST    R15,@_VolTbl_Ptr         and clear VolTbl pointer\n\nZ00020   DS    0H\n*---------------------------------------------------------------------*\n*   CLOSE and free any output DCBs                                    *\n*---------------------------------------------------------------------*\n         LA    R15,0                    Clear pointer\n         ST    R15,@Z_Parms_U00010      No DDName\n         ST    R15,@Z_Parms_U00010+4    No data pointer\n         ST    R15,@Z_Parms_U00010+8    No length either\n         ST    R15,@Z_Parms_U00010+12   No ASA CC\n\n         LA    R1,@Z_Parms              A(Parms)\n         BRAS  R14,U00010               Close and free DCBs\n\nZ00030   DS    0H\n*---------------------------------------------------------------------*\n*   Free up the UCB and Volume selection tables                       *\n*---------------------------------------------------------------------*\n         ICM   R1,B'1111',@_UCB_List_Ptr A(List of UCB Masks)\n         JZ    Z00040                   None, skip\n         L     R0,UCB_List_Hdr_Len-UCB_List_Hdr(R1)  Length\n         BASR  R2,0\n         USING (*,Z00030_End-1),R2\n         STORAGE RELEASE,               Free the storage               +\n               ADDR=(1),                 starting here                 +\n               LENGTH=(0)                for this long\nZ00030_End DS  0H\n         DROP  R2\n         XC    @_UCB_List_Ptr,@_UCB_List_Ptr Clear A(UCB List)\n\nZ00040   DS    0H\n         ICM   R1,B'1111',@_XUCB_List_Ptr A(List of XUCB Masks)\n         JZ    Z00050                   None, skip\n         L     R0,UCB_List_Hdr_Len-UCB_List_Hdr(R1)  Length\n         BASR  R2,0\n         USING (*,Z00040_End-1),R2\n         STORAGE RELEASE,               Free the storage               +\n               ADDR=(1),                 starting here                 +\n               LENGTH=(0)                for this long\nZ00040_End DS  0H\n         DROP  R2\n         XC    @_XUCB_List_Ptr,@_XUCB_List_Ptr Clear A(XUCB List)\n\nZ00050   DS    0H\n         ICM   R1,B'1111',@_Vol_List_Ptr A(List of Vol Masks)\n         JZ    Z00060                   None, skip\n         L     R0,Vol_List_Hdr_Len-Vol_List_Hdr(R1)  Length\n         BASR  R2,0\n         USING (*,Z00050_End-1),R2\n         STORAGE RELEASE,               Free the storage               +\n               ADDR=(1),                 starting here                 +\n               LENGTH=(0)                for this long\nZ00050_End DS  0H\n         DROP  R2\n         XC    @_VOL_List_Ptr,@_VOL_List_Ptr Clear A(Vol List)\n\nZ00060   DS    0H\n         ICM   R1,B'1111',@_XVol_List_Ptr A(List of XVol Masks)\n         JZ    Z00070                   None, skip\n         L     R0,Vol_List_Hdr_Len-Vol_List_Hdr(R1)  Length\n         BASR  R2,0\n         USING (*,Z00060_End-1),R2\n         STORAGE RELEASE,               Free the storage               +\n               ADDR=(1),                 starting here                 +\n               LENGTH=(0)                for this long\nZ00060_End DS  0H\n         DROP  R2\n         XC    @_XVOL_List_Ptr,@_XVOL_List_Ptr Clear A(XVol List)\n\nZ00070   DS    0H\n         ICM   R1,B'1111',@_STORGRP_List_Ptr A(List of STORGRP Masks)\n         JZ    Z00070C                  None, skip\n         L     R0,STORGRP_List_Hdr_Len-STORGRP_List_Hdr(R1) Length\n         BASR  R2,0\n         USING (*,Z00070_End-1),R2\n         STORAGE RELEASE,               Free the storage               +\n               ADDR=(1),                 starting here                 +\n               LENGTH=(0)                for this long\nZ00070_End DS  0H\n         DROP  R2\n         XC    @_STORGRP_List_Ptr,@_STORGRP_List_Ptr Clear A(List)\n\nZ00070C  DS    0H\n         TM    @_TSO_Command,L'@_TSO_Command TSO Command?\n         JZ    Z00080                   No, skip\n\n*---------------------------------------------------------------------*\n*       TSO Command Processing                                        *\n*---------------------------------------------------------------------*\n         LA    R15,0                    Clear return code\n         J     Z90010                   and exit\n\nZ00080   DS    0H\n*---------------------------------------------------------------------*\n*       Batch Job Processing                                          *\n*---------------------------------------------------------------------*\n         TM    @_Batch_Environ,L'@_Batch_Environ Is this batch?\n         JZ    Z90010                   No, exit (??)\n\n         LA    R15,0                    Clear return code\n         J     Z90010                   and exit\n\nZ90010   DS    0H\n*-------------------------------------------------------------------*\n*    Free up our local storage ...                                  *\n*-------------------------------------------------------------------*\n         LR    R3,R15                 Save return code\n\n         LA    R1,@Z_Dynam              A(Local storage)\n         L     R2,@Z_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)\n         L     R2,0(0,R2)               A(31-bit Stack)\n         L     R13,4(0,R13)             Rescue A(HSA)\n\n         SSCSTACK POP,                  Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=(R2)                on this stack\n\n         LR    R15,R3                   Restore return code\n\n*-------------------------------------------------------------------*\n*    ... and return to caller                                       *\n*-------------------------------------------------------------------*\n         L     R14,12(0,R13)            Restore return address\n         LM    R0,R12,20(R13)           Restore other registers\n         BSM   0,R14                    and return\n\n\nZ_Literals DS   0H\n\n         LTORG\n\nZ_Literals_End DS   0H\n\n\n@Z_Dynam                  DSECT       Dynamic area for Z00000\n                          DS    18F    O/S Style save area\n@Z_31Bit_Stack_Ptr_Ptr    DS    AL4    A(31-bit Stack Ptr)\n@Z_24Bit_Stack_Ptr_Ptr    DS    AL4    A(24-bit Stack Ptr)\n\n\n@Z_Parms                  DS    0F    Parms for called rtns\n@Z_Parms_Std              DS    3AL4   Standard 3 parms\n@Z_Parms_Extra            EQU   *      Extra parms\n@Z_Parms_U00010           DS    4AL4      for U00010\n                          ORG   ,\n\n                          DS    0D    Alignment\n@Z_Dynam_Length           EQU   *-@Z_Dynam Length of storage\n\n&PGMNAME CSECT\n\n         DROP  ,\n         POP   USING\n\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SPF@PRIM": {"ttr": 20996, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x18\\x00\\x00\\x01\\x06\\x11\\x1f\\x01\\x06\\x11\\x1f\\x00\\x00\\x00\\x08\\x00\\x08\\x00\\x00\\xe2\\xd7\\xc1\\xc3\\xc5@@@@@'", "ispf": {"version": "02.24", "flags": 0, "createdate": "2006-04-21T00:00:00", "modifydate": "2006-04-21T00:00:00", "lines": 8, "newlines": 8, "modlines": 0, "user": "SPACE"}, "text": "&ZSEL = TRANS (TRUNC (&ZCMD,'.')\n   .      .      .        .       .\n   .      .      .        .       .\n   .      .      .        .       .\n   .      .      .        .       .\n SPACE,'PANEL(SSCSPC01) SCRNAME(SPACE)'\n   .      .      .        .       .\n   .      .      .        .       .\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SSCSPCD1": {"ttr": 20998, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x11\\x00\\x00\\x01\\x02\\x07\\x0f\\x01\\x02\\x07\\x0f\\x00\\x00\\x00%\\x00<\\x00\\x00\\xe2\\xd7\\xc1\\xc3\\xc5@@@@@'", "ispf": {"version": "02.17", "flags": 0, "createdate": "2002-03-11T00:00:00", "modifydate": "2002-03-11T00:00:00", "lines": 37, "newlines": 60, "modlines": 0, "user": "SPACE"}, "text": ")PANEL KEYLIST(ISRHLP2 ISR)\n)ATTR FORMAT(MIX) DEFAULT(|+_)                             /* ENGLISH */\n } TYPE(TEXT)    INTENS(HIGH)  COLOR(GREEN) HILITE(REVERSE)\n \u00a2 TYPE(TEXT)    INTENS(HIGH)  COLOR(YELLOW)\n $ TYPE(TEXT)    INTENS(HIGH)  COLOR(TURQ)\n + TYPE(TEXT)    INTENS(LOW)   COLOR(GREEN)\n @ TYPE(TEXT)    INTENS(HIGH)  COLOR(WHITE)\n)BODY  EXPAND(!!)\n$-!-!  SPACE Command   !-!-\n$COMMAND ===>_ZCMD                                                             +\n+\n+  Several options are available to control and direct the output\n+ of this command. All parameters are optional.\n+\n+  Information about the following display options are presented\n+ in sequence, or can be selected by number:\n+    @1+- Sort Field\n+    @2+- Sort Order\n+    @3+- Heading Lines\n+    @4+- Detail Lines\n+    @5+- Total Lines\n+    @6+- Statistics\n+    @7+- ISPF Display\n)INIT\n  &PANEL   = 'SSCSPCD1'\n)PROC\n   &ZSEL = TRANS(&ZCMD\n                1,SSCSPCF6\n                2,SSCSPCF7\n                3,SSCSPCF8\n                4,SSCSPCF9\n                5,SSCSPCFA\n                6,SSCSPCFB\n                7,SSCSPCFC\n                )\n   &ZUP = ISR00003\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SSCSPCFA": {"ttr": 21000, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x11\\x00\\x00\\x01\\x02\\x07\\x0f\\x01\\x02\\x07\\x0f\\x00\\x00\\x00)\\x00)\\x00\\x00\\xe2\\xd7\\xc1\\xc3\\xc5@@@@@'", "ispf": {"version": "02.17", "flags": 0, "createdate": "2002-03-11T00:00:00", "modifydate": "2002-03-11T00:00:00", "lines": 41, "newlines": 41, "modlines": 0, "user": "SPACE"}, "text": ")PANEL KEYLIST(ISRHLP2 ISR)\n)ATTR FORMAT(MIX) DEFAULT(|+_)                             /* ENGLISH */\n } TYPE(TEXT)    INTENS(HIGH)  COLOR(GREEN) HILITE(REVERSE)\n \u00a2 TYPE(TEXT)    INTENS(HIGH)  COLOR(YELLOW)\n $ TYPE(TEXT)    INTENS(HIGH)  COLOR(TURQ)\n + TYPE(TEXT)    INTENS(LOW)   COLOR(GREEN)\n @ TYPE(TEXT)    INTENS(HIGH)   COLOR(WHITE)\n27 AREA(SCRL) EXTEND(ON)\n)BODY WINDOW(60,19) EXPAND(!!)\n$COMMAND ===>_ZCMD                                      +\n$                                                       +\n@-!-! \u00a2Display Option@ !-!-\n@ Total Lines\n$\n\u001bSAREA01                                                 \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n)AREA SAREA01\n$ + Specifies whether or not the total line is to be\n$ + displayed.\n$ +\n$ + Valid values are:\n$   Y+es and\n$   N+o\n$ +\n$ + Default: Y\n$ +          Total line will be displayed.\n)INIT\n  &PANEL   = 'SSCSPCFA'\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SSCSPCFB": {"ttr": 21002, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x11\\x00\\x00\\x01\\x02\\x07\\x0f\\x01\\x02\\x07\\x0f\\x00\\x00\\x00+\\x00+\\x00\\x00\\xe2\\xd7\\xc1\\xc3\\xc5@@@@@'", "ispf": {"version": "02.17", "flags": 0, "createdate": "2002-03-11T00:00:00", "modifydate": "2002-03-11T00:00:00", "lines": 43, "newlines": 43, "modlines": 0, "user": "SPACE"}, "text": ")PANEL KEYLIST(ISRHLP2 ISR)\n)ATTR FORMAT(MIX) DEFAULT(|+_)                             /* ENGLISH */\n } TYPE(TEXT)    INTENS(HIGH)  COLOR(GREEN) HILITE(REVERSE)\n \u00a2 TYPE(TEXT)    INTENS(HIGH)  COLOR(YELLOW)\n $ TYPE(TEXT)    INTENS(HIGH)  COLOR(TURQ)\n + TYPE(TEXT)    INTENS(LOW)   COLOR(GREEN)\n @ TYPE(TEXT)    INTENS(HIGH)   COLOR(WHITE)\n27 AREA(SCRL) EXTEND(ON)\n)BODY WINDOW(60,19) EXPAND(!!)\n$COMMAND ===>_ZCMD                                      +\n$                                                       +\n@-!-! \u00a2Display Option@ !-!-\n@ Statistics\n$\n\u001bSAREA01                                                 \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n)AREA SAREA01\n$ + Specifies whether or not statistics lines are to be\n$ + displayed. Statistics lines contain information such\n$ + as version number, assembly information, and exec-\n$ + ution statistics.\n$ +\n$ + Valid values are:\n$   Y+es and\n$   N+o\n$ +\n$ + Default: N\n$ +          Statistics lines will not be displayed.\n)INIT\n  &PANEL   = 'SSCSPCFB'\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SSCSPCFC": {"ttr": 21004, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x11\\x00\\x00\\x01\\x02\\x07\\x0f\\x01\\x02\\x07\\x0f\\x00\\x00\\x002\\x002\\x00\\x00\\xe2\\xd7\\xc1\\xc3\\xc5@@@@@'", "ispf": {"version": "02.17", "flags": 0, "createdate": "2002-03-11T00:00:00", "modifydate": "2002-03-11T00:00:00", "lines": 50, "newlines": 50, "modlines": 0, "user": "SPACE"}, "text": ")PANEL KEYLIST(ISRHLP2 ISR)\n)ATTR FORMAT(MIX) DEFAULT(|+_)                             /* ENGLISH */\n } TYPE(TEXT)    INTENS(HIGH)  COLOR(GREEN) HILITE(REVERSE)\n \u00a2 TYPE(TEXT)    INTENS(HIGH)  COLOR(YELLOW)\n $ TYPE(TEXT)    INTENS(HIGH)  COLOR(TURQ)\n + TYPE(TEXT)    INTENS(LOW)   COLOR(GREEN)\n @ TYPE(TEXT)    INTENS(HIGH)   COLOR(WHITE)\n27 AREA(SCRL) EXTEND(ON)\n)BODY WINDOW(60,19) EXPAND(!!)\n$COMMAND ===>_ZCMD                                      +\n$                                                       +\n@-!-! \u00a2Display Option@ !-!-\n@ ISPF Display\n$\n\u001bSAREA01                                                 \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n)AREA SAREA01\n$ + Specifies the ISPF facilities to be used to display\n$ + the results from the command.\n$ +\n$ + Valid values are:\n$   N+one     No ISPF facilities will be used - output\n$ +           will be produced using TSO Line-by-Line\n$ +           (PUTLINE) facilities.\n$   S+tandard A customized, command-specific panel will\n$ +           be used to present the output.\n$   B+RIF     BRIF (Browse) will be used to present the\n$ +           output.\n$   E+DIF     EDIF (Edit) will be used to present the\n$ +           output.\n$ +\n$ + Default: Installation-defined\n$ +          The default for this parameter was defined\n$ +          by the installation when this command was\n$ +          inatalled.\n)INIT\n  &PANEL   = 'SSCSPCFC'\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SSCSPCFD": {"ttr": 21006, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x11\\x00\\x00\\x01\\x02\\x07\\x0f\\x01\\x02\\x07\\x0f\\x00\\x00\\x000\\x000\\x00\\x00\\xe2\\xd7\\xc1\\xc3\\xc5@@@@@'", "ispf": {"version": "02.17", "flags": 0, "createdate": "2002-03-11T00:00:00", "modifydate": "2002-03-11T00:00:00", "lines": 48, "newlines": 48, "modlines": 0, "user": "SPACE"}, "text": ")PANEL KEYLIST(ISRHLP2 ISR)\n)ATTR FORMAT(MIX) DEFAULT(|+_)                             /* ENGLISH */\n } TYPE(TEXT)    INTENS(HIGH)  COLOR(GREEN) HILITE(REVERSE)\n \u00a2 TYPE(TEXT)    INTENS(HIGH)  COLOR(YELLOW)\n $ TYPE(TEXT)    INTENS(HIGH)  COLOR(TURQ)\n + TYPE(TEXT)    INTENS(LOW)   COLOR(GREEN)\n @ TYPE(TEXT)    INTENS(HIGH)   COLOR(WHITE)\n27 AREA(SCRL) EXTEND(ON)\n)BODY WINDOW(60,19) EXPAND(!!)\n$COMMAND ===>_ZCMD                                      +\n$                                                       +\n@-!-! \u00a2Processing Option@ !-!-\n@ Max Subtasks\n$\n\u001bSAREA01                                                 \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n)AREA SAREA01\n$ + Specifies the number of MVS subtasks to be created\n$ + to retrieve DASD usage information. These subtasks\n$ + execute concurrently.\n$ +\n$ + This parameter is a numeric value from 1-16.\n$ +\n$ + Default: Null\n$ +          The number of subtasks is determined dyn-\n$ +          amically, based on the number of online\n$ +          processors (CPs) available at execution\n$ +          time.\n$ +\n$ + This parameter should not normally be specified: an\n$ + excessively high value can produce spurious indic-\n$ + ations of unavailable DASD volumes, while a low\n$ + value can increase response time.\n)INIT\n  &PANEL   = 'SSCSPCFD'\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SSCSPCFE": {"ttr": 21008, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x11\\x00\\x00\\x01\\x02\\x07\\x0f\\x01\\x02\\x07\\x0f\\x00\\x00\\x00/\\x00,\\x00\\x00\\xe2\\xd7\\xc1\\xc3\\xc5@@@@@'", "ispf": {"version": "02.17", "flags": 0, "createdate": "2002-03-11T00:00:00", "modifydate": "2002-03-11T00:00:00", "lines": 47, "newlines": 44, "modlines": 0, "user": "SPACE"}, "text": ")PANEL KEYLIST(ISRHLP2 ISR)\n)ATTR FORMAT(MIX) DEFAULT(|+_)                             /* ENGLISH */\n } TYPE(TEXT)    INTENS(HIGH)  COLOR(GREEN) HILITE(REVERSE)\n \u00a2 TYPE(TEXT)    INTENS(HIGH)  COLOR(YELLOW)\n $ TYPE(TEXT)    INTENS(HIGH)  COLOR(TURQ)\n + TYPE(TEXT)    INTENS(LOW)   COLOR(GREEN)\n @ TYPE(TEXT)    INTENS(HIGH)   COLOR(WHITE)\n27 AREA(SCRL) EXTEND(ON)\n)BODY WINDOW(60,19) EXPAND(!!)\n$COMMAND ===>_ZCMD                                      +\n$                                                       +\n@-!-! \u00a2Processing Option@ !-!-\n@ File DDName\n$\n\u001bSAREA01                                                 \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n)AREA SAREA01\n$ + Specifies the DDName to which the results of this\n$ + command will be writted, in addition to the normal\n$ + output. This DDName must be allocated before the\n$ + invocation of this command.\n$ +\n$ + This parameter must be a valid DDName.\n$ +\n$ + Default: Null\n$ +          Additional output is not produced.\n$ +\n$ + If the DDName is not useable (cannot be OPENed),\n$ + normal output will still be produced.\n$ + If DCB characteristics are not specified for a NEW\n$ + dataset, they will be generated appropriately for\n$ + the type of data being produced, with RECFM=FB.\n)INIT\n  &PANEL   = 'SSCSPCFE'\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SSCSPCFF": {"ttr": 21010, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x11\\x00\\x00\\x01\\x02\\x07\\x0f\\x01\\x02\\x07\\x0f\\x00\\x00\\x004\\x004\\x00\\x00\\xe2\\xd7\\xc1\\xc3\\xc5@@@@@'", "ispf": {"version": "02.17", "flags": 0, "createdate": "2002-03-11T00:00:00", "modifydate": "2002-03-11T00:00:00", "lines": 52, "newlines": 52, "modlines": 0, "user": "SPACE"}, "text": ")PANEL KEYLIST(ISRHLP2 ISR)\n)ATTR FORMAT(MIX) DEFAULT(|+_)                             /* ENGLISH */\n } TYPE(TEXT)    INTENS(HIGH)  COLOR(GREEN) HILITE(REVERSE)\n \u00a2 TYPE(TEXT)    INTENS(HIGH)  COLOR(YELLOW)\n $ TYPE(TEXT)    INTENS(HIGH)  COLOR(TURQ)\n + TYPE(TEXT)    INTENS(LOW)   COLOR(GREEN)\n @ TYPE(TEXT)    INTENS(HIGH)   COLOR(WHITE)\n27 AREA(SCRL) EXTEND(ON)\n)BODY WINDOW(60,19) EXPAND(!!)\n$COMMAND ===>_ZCMD                                      +\n$                                                       +\n@-!-! \u00a2Processing Option@ !-!-\n@ File Output\n$\n\u001bSAREA01                                                 \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n)AREA SAREA01\n$ + Specifies the type of output to be written to the\n$ + DDName specified in 'File DDName'. This parameter\n$ + is relevant only if the 'File DDName' parameter\n$ + has also been specified.\n$ +\n$ + Valid Values are:\n$   DISPLAY+ An image of the normal output will be\n$ +          written. This display is currently\n$ +          147 bytes long.\n$   CB     + Copies of various MVS Control Blocks\n$ +          will be written:\n$ +           UCB     (IEFUCBOB) 48 bytes\n$ +           DCE     (IECDDDCE) 48 bytes\n$ +           LSPACE  (LSPACE)   36 bytes\n$ +           F4 DSCB (IECSDSL1) 96 bytes\n$   ALL    + Both CB and DISPLAY data will be written,\n$ +          the CB data followed by the DISPLAY data.\n$ +\n$ + Default: ALL\n$ +          Both CB and DISPLAY data will be written.\n)INIT\n  &PANEL   = 'SSCSPCFF'\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SSCSPCFG": {"ttr": 21012, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x11\\x00\\x00\\x01\\x02\\x07\\x0f\\x01\\x02\\x07\\x0f\\x00\\x00\\x005\\x005\\x00\\x00\\xe2\\xd7\\xc1\\xc3\\xc5@@@@@'", "ispf": {"version": "02.17", "flags": 0, "createdate": "2002-03-11T00:00:00", "modifydate": "2002-03-11T00:00:00", "lines": 53, "newlines": 53, "modlines": 0, "user": "SPACE"}, "text": ")PANEL KEYLIST(ISRHLP2 ISR)\n)ATTR FORMAT(MIX) DEFAULT(|+_)                             /* ENGLISH */\n } TYPE(TEXT)    INTENS(HIGH)  COLOR(GREEN) HILITE(REVERSE)\n \u00a2 TYPE(TEXT)    INTENS(HIGH)  COLOR(YELLOW)\n $ TYPE(TEXT)    INTENS(HIGH)  COLOR(TURQ)\n + TYPE(TEXT)    INTENS(LOW)   COLOR(GREEN)\n @ TYPE(TEXT)    INTENS(HIGH)   COLOR(WHITE)\n27 AREA(SCRL) EXTEND(ON)\n)BODY WINDOW(60,19) EXPAND(!!)\n$COMMAND ===>_ZCMD                                      +\n$                                                       +\n@-!-! \u00a2Processing Option@ !-!-\n@ LSPACE Data?\n$\n\u001bSAREA01                                                 \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n)AREA SAREA01\n$ + Specifies whether the LSPACE SVC should be issued\n$ + to retreive DASD usage information for selected\n$ + volumes.\n$ +\n$ + Valid Values are:\n$   Y+es LSPACE will be issued\n$   N+o  LSPACE will not be issued\n$ +\n$ + Default: Y\n$ +          LSPACE will be issued.\n$ +\n$ + If N is specified, execution and response times\n$ + will generally be much lower. However, the only\n$ + data returned will be:\n$ +   Volser\n$ +   Device Address\n$ +   Device Type\n$ +   Mount Attribute\n$ +   SMS Storage Group\n$ +   SMS Status\n$ +   CHPIDs\n)INIT\n  &PANEL   = 'SSCSPCFG'\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SSCSPCFH": {"ttr": 21249, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x11\\x00\\x00\\x01\\x02\\x07\\x0f\\x01\\x02\\x07\\x0f\\x00\\x00\\x009\\x009\\x00\\x00\\xe2\\xd7\\xc1\\xc3\\xc5@@@@@'", "ispf": {"version": "02.17", "flags": 0, "createdate": "2002-03-11T00:00:00", "modifydate": "2002-03-11T00:00:00", "lines": 57, "newlines": 57, "modlines": 0, "user": "SPACE"}, "text": ")PANEL KEYLIST(ISRHLP2 ISR)\n)ATTR FORMAT(MIX) DEFAULT(|+_)                             /* ENGLISH */\n } TYPE(TEXT)    INTENS(HIGH)  COLOR(GREEN) HILITE(REVERSE)\n \u00a2 TYPE(TEXT)    INTENS(HIGH)  COLOR(YELLOW)\n $ TYPE(TEXT)    INTENS(HIGH)  COLOR(TURQ)\n + TYPE(TEXT)    INTENS(LOW)   COLOR(GREEN)\n @ TYPE(TEXT)    INTENS(HIGH)   COLOR(WHITE)\n27 AREA(SCRL) EXTEND(ON)\n)BODY WINDOW(60,19) EXPAND(!!)\n$COMMAND ===>_ZCMD                                      +\n$                                                       +\n@-!-! \u00a2Selection Criterion@ !-!-\n@ SMS Storage Group\n$\n\u001bSAREA01                                                 \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n)AREA SAREA01\n$ + Specifies the selection criterion based on the SMS\n$ + Storage Group to which the volume belongs.\n$ + Multiple Storage Group names, separated by a space\n$ + or a comma, can be entered. A volume belonging to\n$ + any of the Storage Groups will be eligible for\n$ + selection.\n$ +\n$ + Wildcard characters can be used:\n$ +  '*' - all remaining characters\n$ +  '?' - any single character\n$ +  '%' - any single character\n$ +\n$ + Default: Null\n$ +          SMS Storage Group is not considered during\n$ +          volume selection.\n$ +\n$ + Specifying this selection criterion implies\n$ + ATTR(SMS); that is, only SMS-controlled volumes\n$ + will be considered for selection.\n$ +\n$ + Note that a DASD volume must satisfy@all+criteria\n$ + (Volser, UCB, SMS Storage Group, Estoric Name,\n$ + and/or Mount Attribute) specified to be selected.\n)INIT\n  &PANEL   = 'SSCSPCFH'\n)PROC\n  .CURSOR = ZCMD\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SSCSPCFI": {"ttr": 21251, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x18\\x00\\x00\\x01\\x06\\x11\\x1f\\x01\\x06\\x11\\x1f\\x00\\x00\\x00.\\x00.\\x00\\x00\\xe2\\xd7\\xc1\\xc3\\xc5@@@@@'", "ispf": {"version": "02.24", "flags": 0, "createdate": "2006-04-21T00:00:00", "modifydate": "2006-04-21T00:00:00", "lines": 46, "newlines": 46, "modlines": 0, "user": "SPACE"}, "text": ")PANEL KEYLIST(ISRHLP2 ISR)\n)ATTR FORMAT(MIX) DEFAULT(|+_)                             /* ENGLISH */\n } TYPE(TEXT)    INTENS(HIGH)  COLOR(GREEN) HILITE(REVERSE)\n \u00a2 TYPE(TEXT)    INTENS(HIGH)  COLOR(YELLOW)\n $ TYPE(TEXT)    INTENS(HIGH)  COLOR(TURQ)\n + TYPE(TEXT)    INTENS(LOW)   COLOR(GREEN)\n @ TYPE(TEXT)    INTENS(HIGH)   COLOR(WHITE)\n27 AREA(SCRL) EXTEND(ON)\n)BODY WINDOW(60,19) EXPAND(!!)\n$COMMAND ===>_ZCMD                                      +\n$                                                       +\n@-!-! \u00a2Processing Options@ !-!-\n@ Maximum LSPACE Wait Time\n$\n\u001bSAREA01                                                 \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n)AREA SAREA01\n$ + Specifies the maximum number of seconds that will be allowed\n$ + for the LSPACE SVC to complete (the LSPACE SVC is the system\n$ + facility used to retrieve DASD usage stats). This parameter\n$ + would be used to prevent (seemingly) endless WAITs while the\n$ + system tries to access RESERVEd or extremely busy DASD devices.\n$ +\n$ +\n$ + Default: Installation dependent\n$ + Specifying 0 will cause LSPACE to wait the smaller of:\n$ +  - the MIH time for the device, and\n$ + - the LSPACE default of 240 seconds.\n$ +\n)INIT\n  &PANEL   = 'SSCSPCFI'\n)PROC\n  .CURSOR = ZCMD\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SSCSPCF1": {"ttr": 21253, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x11\\x00\\x00\\x01\\x02\\x07\\x0f\\x01\\x02\\x07\\x0f\\x00\\x00\\x00$\\x00:\\x00\\x00\\xe2\\xd7\\xc1\\xc3\\xc5@@@@@'", "ispf": {"version": "02.17", "flags": 0, "createdate": "2002-03-11T00:00:00", "modifydate": "2002-03-11T00:00:00", "lines": 36, "newlines": 58, "modlines": 0, "user": "SPACE"}, "text": ")PANEL KEYLIST(ISRHLP2 ISR)\n)ATTR FORMAT(MIX) DEFAULT(|+_)                             /* ENGLISH */\n } TYPE(TEXT)    INTENS(HIGH)  COLOR(GREEN) HILITE(REVERSE)\n \u00a2 TYPE(TEXT)    INTENS(HIGH)  COLOR(YELLOW)\n $ TYPE(TEXT)    INTENS(HIGH)  COLOR(TURQ)\n + TYPE(TEXT)    INTENS(LOW)   COLOR(GREEN)\n @ TYPE(TEXT)    INTENS(HIGH)  COLOR(WHITE)\n)BODY  EXPAND(!!)\n$-!-!  SPACE Command  !-!-\n$COMMAND ===>_ZCMD                                                             +\n+\n+  This command uses multiple selection criteria to determine the\n+ DASD volumes for which data will be presented. If multiple\n+ criteria are specified, the unit and volume must satisfy@all+criteria\n+ before being selected.\n+\n+  Information about the following selection criteria are presented\n+ in sequence, or can be selected by number:\n+    @1+- Volser\n+    @2+- UCB Address\n+    @3+- SMS Storage Group\n+    @4+- Esoteric Name\n+    @5+- Mount Attribute\n)INIT\n  &PANEL   = 'SSCSPCF1'\n  .CURSOR = ZCMD\n)PROC\n   &ZSEL = TRANS(&ZCMD\n                1,SSCSPCF2\n                2,SSCSPCF3\n                3,SSCSPCFH\n                4,SSCSPCF4\n                5,SSCSPCF5\n                )\n   &ZUP = ISR00003\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SSCSPCF2": {"ttr": 21255, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x11\\x00\\x00\\x01\\x02\\x07\\x0f\\x01\\x02\\x07\\x0f\\x00\\x00\\x006\\x006\\x00\\x00\\xe2\\xd7\\xc1\\xc3\\xc5@@@@@'", "ispf": {"version": "02.17", "flags": 0, "createdate": "2002-03-11T00:00:00", "modifydate": "2002-03-11T00:00:00", "lines": 54, "newlines": 54, "modlines": 0, "user": "SPACE"}, "text": ")PANEL KEYLIST(ISRHLP2 ISR)\n)ATTR FORMAT(MIX) DEFAULT(|+_)                             /* ENGLISH */\n } TYPE(TEXT)    INTENS(HIGH)  COLOR(GREEN) HILITE(REVERSE)\n \u00a2 TYPE(TEXT)    INTENS(HIGH)  COLOR(YELLOW)\n $ TYPE(TEXT)    INTENS(HIGH)  COLOR(TURQ)\n + TYPE(TEXT)    INTENS(LOW)   COLOR(GREEN)\n @ TYPE(TEXT)    INTENS(HIGH)   COLOR(WHITE)\n27 AREA(SCRL) EXTEND(ON)\n)BODY WINDOW(60,19) EXPAND(!!)\n$COMMAND ===>_ZCMD                                      +\n$                                                       +\n@-!-! \u00a2Selection Criterion@ !-!-\n@ Volser Mask\n$\n\u001bSAREA01                                                 \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n)AREA SAREA01\n$ + Specifies the selection criterion based on the\n$ + Volser. Volumes can be included or excluded based\n$ + on Volser.\n$ + Multiple Volsers, separated by a space or a\n$ + comma, can be entered. A volume matching any\n$ + of the Volsers will be eligible for selection.\n$ +\n$ + Wildcard characters can be used:\n$ +  '*' - all remaining characters\n$ +  '?' - any single character\n$ +  '%' - any single character\n$ +\n$ + Default: Null\n$ +          Volser is not considered during\n$ +          selection.\n$ +\n$ + If a volser of less that 6 characters is entered,\n$ + it is right-filled with '*'.\n$ +\n$ + Note that a DASD volume must satisfy@all+criteria\n$ + (Volser, UCB, SMS Storage Group, Estoric Name,\n$ + and/or Mount Attribute) specified to be selected.\n)INIT\n  &PANEL   = 'SSCSPCF2'\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SSCSPCF3": {"ttr": 21257, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x11\\x00\\x00\\x01\\x02\\x07\\x0f\\x01\\x02\\x07\\x0f\\x00\\x00\\x00?\\x00?\\x00\\x00\\xe2\\xd7\\xc1\\xc3\\xc5@@@@@'", "ispf": {"version": "02.17", "flags": 0, "createdate": "2002-03-11T00:00:00", "modifydate": "2002-03-11T00:00:00", "lines": 63, "newlines": 63, "modlines": 0, "user": "SPACE"}, "text": ")PANEL KEYLIST(ISRHLP2 ISR)\n)ATTR FORMAT(MIX) DEFAULT(|+_)                             /* ENGLISH */\n } TYPE(TEXT)    INTENS(HIGH)  COLOR(GREEN) HILITE(REVERSE)\n \u00a2 TYPE(TEXT)    INTENS(HIGH)  COLOR(YELLOW)\n $ TYPE(TEXT)    INTENS(HIGH)  COLOR(TURQ)\n + TYPE(TEXT)    INTENS(LOW)   COLOR(GREEN)\n @ TYPE(TEXT)    INTENS(HIGH)   COLOR(WHITE)\n27 AREA(SCRL) EXTEND(ON)\n)BODY WINDOW(60,19) EXPAND(!!)\n$COMMAND ===>_ZCMD                                      +\n$                                                       +\n@-!-! \u00a2Selection Criterion@ !-!-\n@ UCB Mask\n$\n\u001bSAREA01                                                 \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n)AREA SAREA01\n$ + Specifies the selection criterion based on the\n$ + UCB Address. Volumes can be included or excluded\n$ + based on UCB Address.\n$ + Multiple UCB Addresses, separated by a space\n$ + or a comma, can be entered. A volume matching any\n$ + of the UCB Addresses will be eligible for selection.\n$ +\n$ + Wildcard characters can be used:\n$ +  '*' - all remaining characters\n$ +  '?' - any single character\n$ +  '%' - any single character\n$ +\n$ + Default: Null\n$ +          UCB Address is not considered during\n$ +          selection.\n$ +\n$ + If a UCB Address of less that 4 characters is\n$ + entered, it is right-filled with '*'. Further,\n$ + if no volumes are found when selecting by UCB\n$ + Address, and the right-most character of the UCB\n$ + Address is '*', the UCB Address will be shifted\n$ + right by 1 character, a '0' inserted as the left-\n$ + most character, and the search repeated. For\n$ + example, if a UCB address of 1D2 were entered,\n$ + a search for UCBs 1D2* would be made. If no UCBs\n$ + were found, a second search for UCB 01D2 would be\n$ + made.\n$ +\n$ + Note that a DASD volume must satisfy@all+criteria\n$ + (Volser, UCB, SMS Storage Group, Estoric Name,\n$ + and/or Mount Attribute) specified to be selected.\n)INIT\n  &PANEL   = 'SSCSPCF3'\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SSCSPCF4": {"ttr": 21259, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x11\\x00\\x00\\x01\\x02\\x07\\x0f\\x01\\x02\\x07\\x0f\\x00\\x00\\x00-\\x00-\\x00\\x00\\xe2\\xd7\\xc1\\xc3\\xc5@@@@@'", "ispf": {"version": "02.17", "flags": 0, "createdate": "2002-03-11T00:00:00", "modifydate": "2002-03-11T00:00:00", "lines": 45, "newlines": 45, "modlines": 0, "user": "SPACE"}, "text": ")PANEL KEYLIST(ISRHLP2 ISR)\n)ATTR FORMAT(MIX) DEFAULT(|+_)                             /* ENGLISH */\n } TYPE(TEXT)    INTENS(HIGH)  COLOR(GREEN) HILITE(REVERSE)\n \u00a2 TYPE(TEXT)    INTENS(HIGH)  COLOR(YELLOW)\n $ TYPE(TEXT)    INTENS(HIGH)  COLOR(TURQ)\n + TYPE(TEXT)    INTENS(LOW)   COLOR(GREEN)\n @ TYPE(TEXT)    INTENS(HIGH)   COLOR(WHITE)\n27 AREA(SCRL) EXTEND(ON)\n)BODY WINDOW(60,19) EXPAND(!!)\n$COMMAND ===>_ZCMD                                      +\n$                                                       +\n@-!-! \u00a2Selection Criterion@ !-!-\n@ Esoteric Name\n$\n\u001bSAREA01                                                 \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n)AREA SAREA01\n$ + Specifies that only volumes mounted on DASD units\n$ + belonging to the Esoteric Name should be selected.\n$ + Only a single Esoteric Name can be entered, and it\n$ + can contain no wildcards.\n$ +\n$ + Default: Null\n$ +          Esoteric Name is not considered during\n$ +          selection.\n$ +\n$ +\n$ + Note that a DASD volume must satisfy@all+criteria\n$ + (Volser, UCB, SMS Storage Group, Estoric Name,\n$ + and/or Mount Attribute) specified to be selected.\n)INIT\n  &PANEL   = 'SSCSPCF4'\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SSCSPCF5": {"ttr": 21261, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x11\\x00\\x00\\x01\\x02\\x07\\x0f\\x01\\x02\\x07\\x0f\\x00\\x00\\x00-\\x00-\\x00\\x00\\xe2\\xd7\\xc1\\xc3\\xc5@@@@@'", "ispf": {"version": "02.17", "flags": 0, "createdate": "2002-03-11T00:00:00", "modifydate": "2002-03-11T00:00:00", "lines": 45, "newlines": 45, "modlines": 0, "user": "SPACE"}, "text": ")PANEL KEYLIST(ISRHLP2 ISR)\n)ATTR FORMAT(MIX) DEFAULT(|+_)                             /* ENGLISH */\n } TYPE(TEXT)    INTENS(HIGH)  COLOR(GREEN) HILITE(REVERSE)\n \u00a2 TYPE(TEXT)    INTENS(HIGH)  COLOR(YELLOW)\n $ TYPE(TEXT)    INTENS(HIGH)  COLOR(TURQ)\n + TYPE(TEXT)    INTENS(LOW)   COLOR(GREEN)\n @ TYPE(TEXT)    INTENS(HIGH)   COLOR(WHITE)\n27 AREA(SCRL) EXTEND(ON)\n)BODY WINDOW(60,19) EXPAND(!!)\n$COMMAND ===>_ZCMD                                      +\n$                                                       +\n@-!-! \u00a2Selection Criterion@ !-!-\n@ Mount Attribute\n$\n\u001bSAREA01                                                 \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n)AREA SAREA01\n$ + Specifies that only volumes mounted with the\n$ + attribute specified should be selected.\n$ + Only a single attribute (one of PVT, PUB, STG, or\n$ + SMS) can be entered.\n$ +\n$ + Default: Null\n$ +          Mount Attribute is not considered during\n$ +          selection.\n$ +\n$ +\n$ + Note that a DASD volume must satisfy@all+criteria\n$ + (Volser, UCB, SMS Storage Group, Estoric Name,\n$ + and/or Mount Attribute) specified to be selected.\n)INIT\n  &PANEL   = 'SSCSPCF5'\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SSCSPCF6": {"ttr": 21263, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x15\\x00\\x00\\x01\\x02\\x07\\x0f\\x01\\x03(\\x0f\\x00\\x00\\x00;\\x00:\\x00\\x00\\xe2\\xd7\\xc1\\xc3\\xc5@@@@@'", "ispf": {"version": "02.21", "flags": 0, "createdate": "2002-03-11T00:00:00", "modifydate": "2003-10-07T00:00:00", "lines": 59, "newlines": 58, "modlines": 0, "user": "SPACE"}, "text": ")PANEL KEYLIST(ISRHLP2 ISR)\n)ATTR FORMAT(MIX) DEFAULT(|+_)                             /* ENGLISH */\n } TYPE(TEXT)    INTENS(HIGH)  COLOR(GREEN) HILITE(REVERSE)\n \u00a2 TYPE(TEXT)    INTENS(HIGH)  COLOR(YELLOW)\n $ TYPE(TEXT)    INTENS(HIGH)  COLOR(TURQ)\n + TYPE(TEXT)    INTENS(LOW)   COLOR(GREEN)\n @ TYPE(TEXT)    INTENS(HIGH)   COLOR(WHITE)\n27 AREA(SCRL) EXTEND(ON)\n)BODY WINDOW(60,19) EXPAND(!!)\n$COMMAND ===>_ZCMD                                      +\n$                                                       +\n@-!-! \u00a2Display Option@ !-!-\n@ SORT Field\n$\n\u001bSAREA01                                                 \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n)AREA SAREA01\n$ + Specifies the field on which the selected DASD\n$ + volumes are to be sorted:\n$ +\n$ +     $VOL    +- Volser\n$ +     $UCB    +- UCB Name (Device Address)\n$ +     $DEVT   +- Device Type\n$ +     $ATTR   +- Mount Attribute\n$ +     $FREET  +- Free Tracks on Volume\n$ +     $FREEC  +- Free Cylinders on volume\n$ +     $FREEP  +- % Volume free\n$ +     $FREEB  +- Free Bytes on volume\n$ +     $FREEE  +- # Free Extents on volume\n$ +     $LARGET +- Largest Free Tracks\n$ +     $LARGEC +- Largest Free Cylinders\n$ +     $FRAG   +- Fragmentation Index\n$ +     $VFREED +- VTOC Free DSCBs\n$ +     $VFREEP +- % VTOC Free\n$ +     $VTRK   +- Tracks allocated to VTOC\n$ +     $VIX    +- Indexed VTOC Status\n$ +     $VOLSIZE+- Volume Capacity\n$ +     $STORGRP+- SMS Storage Group\n$ +     $SMSSTAT+- SMS Volume Status\n$ +     $CHPIDS +- CHPIDs\n$ +\n$ + Default: Null\n$ +          Selected volumes will normally be displayed\n$ +          in ascending order of UCB (Device Address).\n)INIT\n  &PANEL   = 'SSCSPCF6'\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SSCSPCF7": {"ttr": 21265, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x11\\x00\\x00\\x01\\x02\\x07\\x0f\\x01\\x02\\x07\\x0f\\x00\\x00\\x00,\\x00,\\x00\\x00\\xe2\\xd7\\xc1\\xc3\\xc5@@@@@'", "ispf": {"version": "02.17", "flags": 0, "createdate": "2002-03-11T00:00:00", "modifydate": "2002-03-11T00:00:00", "lines": 44, "newlines": 44, "modlines": 0, "user": "SPACE"}, "text": ")PANEL KEYLIST(ISRHLP2 ISR)\n)ATTR FORMAT(MIX) DEFAULT(|+_)                             /* ENGLISH */\n } TYPE(TEXT)    INTENS(HIGH)  COLOR(GREEN) HILITE(REVERSE)\n \u00a2 TYPE(TEXT)    INTENS(HIGH)  COLOR(YELLOW)\n $ TYPE(TEXT)    INTENS(HIGH)  COLOR(TURQ)\n + TYPE(TEXT)    INTENS(LOW)   COLOR(GREEN)\n @ TYPE(TEXT)    INTENS(HIGH)   COLOR(WHITE)\n27 AREA(SCRL) EXTEND(ON)\n)BODY WINDOW(60,19) EXPAND(!!)\n$COMMAND ===>_ZCMD                                      +\n$                                                       +\n@-!-! \u00a2Display Option@ !-!-\n@ SORT Order\n$\n\u001bSAREA01                                                 \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n)AREA SAREA01\n$ + Specifies the order in which the selected DASD\n$ + volumes are to be displayed. This field is only\n$ + relevent when the 'Sort Field' parameter is\n$ + specified.\n$ +\n$ + Valid values are:\n$   A+scending and\n$   D+escending\n$ +\n$ + Default: A\n$ +          Selected volumes will be displayed in\n$ +          ascending order of 'Sort Field'.\n)INIT\n  &PANEL   = 'SSCSPCF7'\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SSCSPCF8": {"ttr": 21267, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x11\\x00\\x00\\x01\\x02\\x07\\x0f\\x01\\x02\\x07\\x0f\\x00\\x00\\x00)\\x00)\\x00\\x00\\xe2\\xd7\\xc1\\xc3\\xc5@@@@@'", "ispf": {"version": "02.17", "flags": 0, "createdate": "2002-03-11T00:00:00", "modifydate": "2002-03-11T00:00:00", "lines": 41, "newlines": 41, "modlines": 0, "user": "SPACE"}, "text": ")PANEL KEYLIST(ISRHLP2 ISR)\n)ATTR FORMAT(MIX) DEFAULT(|+_)                             /* ENGLISH */\n } TYPE(TEXT)    INTENS(HIGH)  COLOR(GREEN) HILITE(REVERSE)\n \u00a2 TYPE(TEXT)    INTENS(HIGH)  COLOR(YELLOW)\n $ TYPE(TEXT)    INTENS(HIGH)  COLOR(TURQ)\n + TYPE(TEXT)    INTENS(LOW)   COLOR(GREEN)\n @ TYPE(TEXT)    INTENS(HIGH)   COLOR(WHITE)\n27 AREA(SCRL) EXTEND(ON)\n)BODY WINDOW(60,19) EXPAND(!!)\n$COMMAND ===>_ZCMD                                      +\n$                                                       +\n@-!-! \u00a2Display Option@ !-!-\n@ Heading Lines\n$\n\u001bSAREA01                                                 \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n)AREA SAREA01\n$ + Specifies whether or not heading lines are to\n$ + be displayed.\n$ +\n$ + Valid values are:\n$   Y+es and\n$   N+o\n$ +\n$ + Default: Y\n$ +          Heading lines will be displayed.\n)INIT\n  &PANEL   = 'SSCSPCF8'\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SSCSPCF9": {"ttr": 21269, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x11\\x00\\x00\\x01\\x02\\x07\\x0f\\x01\\x02\\x07\\x0f\\x00\\x00\\x00)\\x00)\\x00\\x00\\xe2\\xd7\\xc1\\xc3\\xc5@@@@@'", "ispf": {"version": "02.17", "flags": 0, "createdate": "2002-03-11T00:00:00", "modifydate": "2002-03-11T00:00:00", "lines": 41, "newlines": 41, "modlines": 0, "user": "SPACE"}, "text": ")PANEL KEYLIST(ISRHLP2 ISR)\n)ATTR FORMAT(MIX) DEFAULT(|+_)                             /* ENGLISH */\n } TYPE(TEXT)    INTENS(HIGH)  COLOR(GREEN) HILITE(REVERSE)\n \u00a2 TYPE(TEXT)    INTENS(HIGH)  COLOR(YELLOW)\n $ TYPE(TEXT)    INTENS(HIGH)  COLOR(TURQ)\n + TYPE(TEXT)    INTENS(LOW)   COLOR(GREEN)\n @ TYPE(TEXT)    INTENS(HIGH)   COLOR(WHITE)\n27 AREA(SCRL) EXTEND(ON)\n)BODY WINDOW(60,19) EXPAND(!!)\n$COMMAND ===>_ZCMD                                      +\n$                                                       +\n@-!-! \u00a2Display Option@ !-!-\n@ Detail Lines\n$\n\u001bSAREA01                                                 \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n\u001b                                                        \u001b\n)AREA SAREA01\n$ + Specifies whether or not detail lines (one for each\n$ + selected DASD volume) are to be displayed.\n$ +\n$ + Valid values are:\n$   Y+es and\n$   N+o\n$ +\n$ + Default: Y\n$ +          Detail lines will be displayed.\n)INIT\n  &PANEL   = 'SSCSPCF9'\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SSCSPCG1": {"ttr": 21505, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x15\\x00\\x00\\x01\\x02\\x07\\x0f\\x01\\x03(\\x0f\\x00\\x00\\x00W\\x00U\\x00\\x00\\xe2\\xd7\\xc1\\xc3\\xc5@@@@@'", "ispf": {"version": "02.21", "flags": 0, "createdate": "2002-03-11T00:00:00", "modifydate": "2003-10-07T00:00:00", "lines": 87, "newlines": 85, "modlines": 0, "user": "SPACE"}, "text": ")PANEL KEYLIST(ISRHLP2 ISR)\n)ATTR FORMAT(MIX) DEFAULT(|+_)                             /* ENGLISH */\n } TYPE(TEXT)    INTENS(HIGH)  COLOR(GREEN) HILITE(REVERSE)\n \u00a2 TYPE(TEXT)    INTENS(HIGH)  COLOR(YELLOW)\n $ TYPE(TEXT)    INTENS(HIGH)  COLOR(TURQ)\n + TYPE(TEXT)    INTENS(LOW)   COLOR(GREEN)\n @ TYPE(TEXT)    INTENS(HIGH)  COLOR(WHITE)\n27 AREA(SCRL) EXTEND(ON)\n)BODY  EXPAND(!!)\n$-!-!  SPACE Command   !-!-\n$COMMAND ===>_ZCMD                                                             +\n\u001bSAREA01                                                                       \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n)AREA SAREA01\n+    This command will display DASD usage statistics. It can:\n+    - cope with DASD devices RESERVEd on other systems without\n+      hanging\n+    - run as a TSO command or batch program\n+    - use EDIF or BRIF to display results\n+    - create machine-readable output (UCB, DCE, LSPACE data, F4DSCB)\n+    - select devices based on UCB address, Volser, Esoteric, Mount\n+      Attribute, or SMS Storage Group\n+    - sort results by any of the displayed fields\n+\n+    The data presented by the command are:\n+    - UCB address\n+    - Volser\n+    - Device Type\n+    - Use Attribute\n+    - Free Trks, Cyls, %\n+    - Fragmentation Index\n+    - Largest Trks, Cyls\n+    - VTOC Trks, free DSCBs, % free\n+    - Indexed VTOC Status\n+    - Volume Capacity\n+    - SMS Storage Group\n+    - SMS Volume Status\n+    - CHPIDs\n+\n+\n+ Sample Output:\n+ -------------\n+\n+     2002/03/11 12:51:14          DASD Free Space Report           SORT Cmd ava\n+   COMMAND ===>                                                  SCROLL ===> CS\n+                            ----------------- Volume Free -----------------\n+                                                          Nbr    - Largest-  Fr\n+  VOLSER  UCB  DevType  St     Trks  Cyls     %  Bytes  Xtnts    Trks  Cyls Ind\n+  SYYLD0 2705  3390-3  Pvt   19,669 1,292  39.2   1.0G     68   7,410   494   2\n+  SYYLD2 2707  3390-3  Pvt   21,639 1,421  43.1   1.1G     53   7,699   513   2\n+  SYYLD*             2       41,308 2,713  41.2   2.2G    121   7,699   513   2\n+\n+   The following data are also presented when displayed under ISPF, when\n+   running in batch, or if the terminal line size is wide enough to\n+   accomodate them:\n+    - Fragmentation Index\n+    - VTOC Trks, free DSCBs, % free\n+    - Indexed VTOC Status\n+    - Volume Capacity\n+    - SMS Storage Group\n+    - SMS Volume Status\n+    - CHPIDs\n)INIT\n  &PANEL   = 'SSCSPCG1'\n)PROC\n   &ZUP = SSCSPCH1\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SSCSPCH1": {"ttr": 21508, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x18\\x00\\x00\\x01\\x06\\x11\\x1f\\x01\\x06\\x11\\x1f\\x00\\x00\\x00*\\x00#\\x00\\x00\\xe2\\xd7\\xc1\\xc3\\xc5@@@@@'", "ispf": {"version": "02.24", "flags": 0, "createdate": "2006-04-21T00:00:00", "modifydate": "2006-04-21T00:00:00", "lines": 42, "newlines": 35, "modlines": 0, "user": "SPACE"}, "text": ")PANEL KEYLIST(ISRHLP2 ISR)\n)ATTR\n } TYPE(TEXT)    INTENS(HIGH)  COLOR(GREEN) HILITE(REVERSE)\n \u00a2 TYPE(TEXT)    INTENS(HIGH)  COLOR(YELLOW)\n $ TYPE(TEXT)    INTENS(HIGH)  COLOR(TURQ)\n + TYPE(TEXT)    INTENS(LOW)   COLOR(GREEN)\n @ TYPE(TEXT)    INTENS(HIGH)   COLOR(WHITE)\n)BODY\n@Space Tutorial        \u00a2SSC Space ISPF Tutorial Facility\n$OPTION ===>_ZCMD\n%                                                                              +\n+                 The following topics may be chosen by number.                +\n+                                                                              +\n%                  \u00a21+- General Information                                    +\n%                  \u00a22+- Selection Criteria\n%                  \u00a23+- Display Options\n%                  \u00a24+- Processing Options\n%                  \u00a25+- Messages\n%                  \u00a26+- What's New\n%\n%\n%\n%\n%\n%                                                                              +\n+                                                                              +\n+                 Press%END+to exit out of the tutorial system.                +\n+                                                                              +\n+                                                                              +\n)INIT\n &PANEL   = 'SSCSPCH1'\n &ZHTOP   = 'SSCSPCH1'\n)PROC\n  &ZSEL = TRANS(&ZCMD\n          1,*SSCSPCG1\n          2,*SSCSPCF1\n          3,*SSCSPCD1\n          4,*SSCSPCP1\n          5,*SSCSPCM1\n          6,*SSCSPCO6\n                )\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SSCSPCM1": {"ttr": 21510, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x18\\x00\\x00\\x01\\x02\\x07\\x0f\\x01\\x06\\x11\\x1f\\x00\\x00\\x00f\\x00[\\x00\\x00\\xe2\\xd7\\xc1\\xc3\\xc5@@@@@'", "ispf": {"version": "02.24", "flags": 0, "createdate": "2002-03-11T00:00:00", "modifydate": "2006-04-21T00:00:00", "lines": 102, "newlines": 91, "modlines": 0, "user": "SPACE"}, "text": ")ATTR FORMAT(MIX)                                          /* ENGLISH */\n } TYPE(TEXT)    INTENS(HIGH)  COLOR(GREEN) HILITE(REVERSE)\n \u00a2 TYPE(TEXT)    INTENS(HIGH)  COLOR(YELLOW)\n % TYPE(TEXT)    INTENS(HIGH)  COLOR(TURQ)\n + TYPE(TEXT)    INTENS(LOW)   COLOR(GREEN)\n27 AREA(SCRL) EXTEND(ON)\n)BODY  CMD(ZCMD)\n%-----------------------------  SSC SPACE Command  -----------------------------\n%COMMAND ===>_ZCMD                                                             +\n\u001bSAREA01                                                                       \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n)AREA SAREA01\n% SPACE01I  No Devices/Volumes match selection criteria\n+           This message is issued when no online DASD devices were\n+           found that satisfied the specified selection criteria.\n+\n% SPACE02I  Insufficient APF authorization\n+           The SPACE command requires APF authorization, but is cur-\n+           rently not authorized.\n+\n% SPACE03I  ISPF DM Services unavailable xx-yy\n+           This message is issued when the SPACE command could not\n+           use ISPF Dialogue Management Services to display the\n+           results of the command in ISPF format. Either the required\n+           ISPF modules were unavailable, or the environment is such\n+           that ISPF Dialogue Management Services are not functional.\n+           In the message, xx indicates which ISPF service is\n+           unavailable, and yy is the return code from that service.\n+\n% SPACE04I  Forcing non-ISPF output\n+           This message is issued when the user has requested that\n+           the command output be displayed using ISPF Dialogue\n+           Management Services, but these services are unavailable.\n+           The command output is displayed using TSO line-by-line\n+           facilities (PUTLINE).\n+\n% SPACE05I  CSVQUERY unavailable on this system xxxxx\n+           The CSVQUERY function was attempted to verify that APAR\n+           OW48527 had been APPLYed to this system, but CSVQUERY is\n+           not available. 'xxxxx' is the Operating System level on\n+           which this program is executing.\n+\n% SPACE06I  Program not found in STEPLIB/LNKLST\n+           This command requires that the processing program reside\n+           in the current STEPLIB or system LNKLST concatenation,\n+           but the program cannot be located.\n+\n% SPACE07I  IKJEFTSR error xx-yy\n+           The TSO/E Service Routine IKJEFTSR could not complete\n+           successfully. xx is the Return Code, and yy the reason\n+           code.\n+\n% SPACE08I  LSPACE failed for at least 1 volume\n+           The data presented in the table is incomplete because\n+           information for at least 1 DASD volume was unavailable.\n+\n% SPACE09I  Incompatible versions of SPACE found\n+           The TSO/E Service Routine IKJEFTSR invoked a different\n+           version of SPACE (from LNKLST/STEPLIB) than was\n+           originally invoked (from ISPLLIB?).\n+\n% SPACE10I  Insufficient storage: nnn volumes omitted\n+           Not enough (above-the-line) storage was available to\n+           save the information for all selected DASD volumes. nnn\n+           indicates how many volumes were not processed.\n+\n% SPACE11I  Internal error - unknown invocation type\n+           The program could not determine how it was invoked. This\n+           is most likely to occur when it is being reinvoked via\n+           IKJEFTSR, but the parameters passed are unrecognized.\n+\n% SPACE12I  OUTFILE DDname xxxxxxxx not useable - ignored.\n+           This message is issued when the user has requested that\n+           the volume usage data be written to a file, by specifying\n+           OUTFILE(xxxxxxxx) on the command line. DDName xxxxxxxx\n+           could not be OPENed for output.\n)INIT\n  &PANEL   = 'SSCSPCM1'\n  .CURSOR = ZCMD\n)PROC\n  &ZCONT   = 'SSCSPCH1'\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SSCSPCO0": {"ttr": 21513, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x18\\x00\\x00\\x01\\x06\\x11\\x1f\\x01\\x06\\x11\\x1f\\x00\\x00\\x00$\\x00!\\x00\\x00\\xe2\\xd7\\xc1\\xc3\\xc5@@@@@'", "ispf": {"version": "02.24", "flags": 0, "createdate": "2006-04-21T00:00:00", "modifydate": "2006-04-21T00:00:00", "lines": 36, "newlines": 33, "modlines": 0, "user": "SPACE"}, "text": ")PANEL KEYLIST(ISRHLP2 ISR)\n)ATTR FORMAT(MIX) DEFAULT(|+_)                             /* ENGLISH */\n } TYPE(TEXT)    INTENS(HIGH)  COLOR(GREEN) HILITE(REVERSE)\n \u00a2 TYPE(TEXT)    INTENS(HIGH)  COLOR(YELLOW)\n $ TYPE(TEXT)    INTENS(HIGH)  COLOR(TURQ)\n + TYPE(TEXT)    INTENS(LOW)   COLOR(GREEN)\n @ TYPE(TEXT)    INTENS(HIGH)  COLOR(WHITE)\n)BODY  EXPAND(!!)\n$-!-!  SPACE Command  !-!-\n$COMMAND ===>_ZCMD                                                             +\n+\n+  Data for selected DASD volumes are displayed in tabular format.\n+\n+  Information about the following subjects are presented in sequence,\n+ or can be selected by number:\n+    @1+- Primary Commands\n+    @2+- Heading Lines\n+    @3+- Detail Lines\n+    @4+- Total Lines\n+    @5+- Statistics Lines\n+    @6+- Messages\n+    @7+- What's New\n)INIT\n  &PANEL   = 'SSCSPCO0'\n)PROC\n   &ZSEL = TRANS(&ZCMD\n                1,SSCSPCO1\n                2,SSCSPCO2\n                3,SSCSPCO3\n                4,SSCSPCO4\n                5,SSCSPCO5\n                6,SSCSPCM1\n                7,SSCSPCO6\n                )\n   &ZUP = ISR00003\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SSCSPCO1": {"ttr": 21515, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x15\\x00\\x00\\x01\\x02\\x07\\x0f\\x01\\x03(\\x0f\\x00\\x00\\x00C\\x00\"\\x00\\x00\\xe2\\xd7\\xc1\\xc3\\xc5@@@@@'", "ispf": {"version": "02.21", "flags": 0, "createdate": "2002-03-11T00:00:00", "modifydate": "2003-10-07T00:00:00", "lines": 67, "newlines": 34, "modlines": 0, "user": "SPACE"}, "text": ")PANEL KEYLIST(ISRHLP2 ISR)\n)ATTR FORMAT(MIX) DEFAULT(|+_)                             /* ENGLISH */\n } TYPE(TEXT)    INTENS(HIGH)  COLOR(GREEN) HILITE(REVERSE)\n \u00a2 TYPE(TEXT)    INTENS(HIGH)  COLOR(YELLOW)\n $ TYPE(TEXT)    INTENS(HIGH)  COLOR(TURQ)\n + TYPE(TEXT)    INTENS(LOW)   COLOR(GREEN)\n @ TYPE(TEXT)    INTENS(HIGH)  COLOR(WHITE)\n27 AREA(SCRL) EXTEND(ON)\n)BODY  EXPAND(!!)\n$-!-!  SPACE Command  !-!-\n$COMMAND ===>_ZCMD                                                             +\n\u001bSAREA01                                                                       \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n)AREA SAREA01\n+\n+  The following Primary Commands are recognized:\n+\n+  Scroll Commands:\n+    The standard ISPF Scroll commands (UP, DOWN, LEFT, and RIGHT) are\n+   valid on this panel. The Scroll Amount is governed by the 'SCROLL'\n+   variable.\n+\n+  SORT\n+    The SORT command will sort the table. The format of this command\n+   is:\n+    SORT field-name A/D\n+     where sort-field is the name of the field on which the data is\n+                      to be sorted\n+           A/D        specifies the sort order (Ascending or Descending)\n+    If the sort field is invalid or missing, a pop-up panel will be\n+   presented, from which the Sort Field can be selected.\n+\n+  ISPF(x)\n+    The ISPF command will switch the ISPF display mode of the output.\n+   This command is available only in ISPF(S) and ISPF(B) modes. If\n+   used, x must be one of:\n+     E - ISPF EDIF (Edit)\n+     B - ISPF BRIF (Browse)\n+     S - SPACE-specific display\n+     N - None - TSO line-by-line output\n+\n+ Termination Commands:\n+    The standard ISPF termination commands (END, RETURN, and CANCEL)\n+   are recognized on this panel.\n)INIT\n  &PANEL   = 'SSCSPCO1'\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SSCSPCO2": {"ttr": 21517, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x11\\x00\\x00\\x01\\x02\\x07\\x0f\\x01\\x02\\x07\\x0f\\x00\\x00\\x00\\x15\\x00\\x15\\x00\\x00\\xe2\\xd7\\xc1\\xc3\\xc5@@@@@'", "ispf": {"version": "02.17", "flags": 0, "createdate": "2002-03-11T00:00:00", "modifydate": "2002-03-11T00:00:00", "lines": 21, "newlines": 21, "modlines": 0, "user": "SPACE"}, "text": ")PANEL KEYLIST(ISRHLP2 ISR)\n)ATTR FORMAT(MIX) DEFAULT(|+_)                             /* ENGLISH */\n } TYPE(TEXT)    INTENS(HIGH)  COLOR(GREEN) HILITE(REVERSE)\n \u00a2 TYPE(TEXT)    INTENS(HIGH)  COLOR(YELLOW)\n $ TYPE(TEXT)    INTENS(HIGH)  COLOR(TURQ)\n + TYPE(TEXT)    INTENS(LOW)   COLOR(GREEN)\n @ TYPE(TEXT)    INTENS(HIGH)  COLOR(WHITE)\n)BODY  EXPAND(!!)\n$-!-!  SPACE Command  !-!-\n$COMMAND ===>_ZCMD                                                             +\n+\n+  Heading Lines are produced by default, but can be suppressed by\n+ specifying the appropriate parameter (NOHeadings) on the command\n+ invocation string.\n+\n+  Heading lines are not vertically scrollable, but can be horizontally\n+ scrolled.\n+\n)INIT\n  &PANEL   = 'SSCSPCO2'\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SSCSPCO3": {"ttr": 21519, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x18\\x00\\x00\\x01\\x06\\x11\\x1f\\x01\\x06\\x11\\x1f\\x00\\x00\\x00~\\x00~\\x00\\x00\\xe2\\xd7\\xc1\\xc3\\xc5@@@@@'", "ispf": {"version": "02.24", "flags": 0, "createdate": "2006-04-21T00:00:00", "modifydate": "2006-04-21T00:00:00", "lines": 126, "newlines": 126, "modlines": 0, "user": "SPACE"}, "text": ")PANEL KEYLIST(ISRHLP2 ISR)\n)ATTR FORMAT(MIX) DEFAULT(|\u00ac[)                             /* ENGLISH */\n } TYPE(TEXT)    INTENS(HIGH)  COLOR(GREEN) HILITE(REVERSE)\n \u00a2 TYPE(TEXT)    INTENS(HIGH)  COLOR(YELLOW)\n ] TYPE(TEXT)    INTENS(HIGH)  COLOR(TURQ)\n { TYPE(TEXT)    INTENS(LOW)   COLOR(GREEN)\n @ TYPE(TEXT)    INTENS(HIGH)   COLOR(WHITE)\n27 AREA(SCRL) EXTEND(ON)\n)BODY EXPAND(!!)\n]COMMAND ===>[ZCMD                                      \u00ac\n]                                                       \u00ac\n@-!-! \u00a2Detail Lines@ !-!-\n]\n\u001bSAREA01                                                                       \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n)AREA SAREA01\n] { Each detail line contains information about a selected DASD volume.\n] { Numeric fields will be scaled by 1000, if required, to fit in the\n] { display fields. If scaling is done, the (scaled) number is rounded\n] { (remainder/divisor > .5, rounded up; otherwise down) and is suffixed\n] { with K, M, G, etc. Percent fields are also rounded.\n] {\n]   Volser:\n] {   The Volume Serial Number of the DASD volume.\n] {\n]   UCB:\n] {   The Device Address of the DASD volume.\n] {\n]   DevType:\n] {   The Device Type of the DASD volume. A trailing '*E*' is\n] { present (if space allows) for emulated devices.\n] {\n]   St:\n] {   The Mount Attribute (from the UCB) of the DASD volume:\n] {     Pvt: PRIVATE\n] {     Stg: STORAGE\n] {     Pub: PUBLIC\n] {     SMS: SMS-Managed\n] {    Note that if the VTOC of the DASD volume indicates that the\n] {     volume is SMS-managed, but the UCB is not, the Mount Attribute\n] {     will be flagged with an asterisk (*), and an explanatory note\n] {     displayed after the Totals line (if present).\n] {\n]  *Volume Free Trks:\n] {   The total number of free tracks on the volume, computed as:\n] {         (Free_Cyls * Trks_per_Cyl) + Free_Tracks\n] {\n]  *Volume Free Cyls:\n] {   The total number of free cylinders on the volume.\n] {\n]  *Volume Free %:\n] {   The free percentage of the volume, computed as:\n] {      ((Free_Tracks * Bytes_per_Track) * 100) / Bytes_per_Device\n] {\n]  *Volume Free Bytes:\n] {   The total number of free bytes on the volume, computed as:\n] {         Free_Tracks * Bytes_per_Track\n] {\n]  *Nbr Extents:\n] {   The number of free extents on the volume.\n] {\n]  *Largest Trks:\n] {   The number of tracks in the largest free extent.\n] {\n]  *Largest Cyls:\n] {   The number of cylinders in the largest free extent.\n] {\n]   Frag Index:\n] {   The fragmentation index for the volume, to a maximum of 999.\n] {\n]  *VTOC Trks:\n] {   The number of tracks allocated to the VTOC.\n] {\n]  *VTOC Free DSCBs:\n] {   The number of free DSCBs in the VTOC.\n] {\n]  *VTOC % Free:\n] {   The percentage of free DSCBs in the VTOC.\n] {\n]   IX St:\n] {   The status of the VTOC Index:\n] {     A: Active\n] {     E: Exists, but is not Active\n] {     N: Does not exist\n] {\n]  *Volume Size:\n] {   The total number of bytes on the volume, computed as:\n] {         Bytes_per_Track * Tracks_per_Cyl * Cyl_Per_Volume\n] {\n]   SMS Storage Group:\n] {   The SMS Storage Group to which this volume belongs. If not\n] {   SMS-Managed, this field will contain 'N/A'.\n] {\n]   SMS Status:\n] {   The SMS Status of this volume. If not SMS-Managed, this field\n] {   will contain 'N/A'.\n] {\n]   CHPIDs:\n] {   The CHannel Path IDs assigned to this device. Up to 8 CHPIDs\n] {   will be displayed.\n] {   If the CHPID is not physically available, it will be suffixed\n] {   with a '$'.\n] {   If the CHPID is not logically available, it will be suffixed\n] {   with a '-'.\n] {\n] {\n] {* When viewing the output of this command with ISPF(S) (the customized\n] { ISPF Panel), placing the cursor in one of these fields and pressing\n] { ENTER will cause the unscaled, unrounded number, to a maximum of 16\n] { digits, to be displayed in the upper right-hand corner of the screen.\n] {\n)INIT\n  &PANEL   = 'SSCSPCO3'\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SSCSPCO4": {"ttr": 21522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x18\\x00\\x00\\x01\\x06\\x11\\x1f\\x01\\x06\\x11\\x1f\\x00\\x00\\x00{\\x00q\\x00\\x00\\xe2\\xd7\\xc1\\xc3\\xc5@@@@@'", "ispf": {"version": "02.24", "flags": 0, "createdate": "2006-04-21T00:00:00", "modifydate": "2006-04-21T00:00:00", "lines": 123, "newlines": 113, "modlines": 0, "user": "SPACE"}, "text": ")PANEL KEYLIST(ISRHLP2 ISR)\n)ATTR FORMAT(MIX) DEFAULT(|\u00ac[)                             /* ENGLISH */\n } TYPE(TEXT)    INTENS(HIGH)  COLOR(GREEN) HILITE(REVERSE)\n \u00a2 TYPE(TEXT)    INTENS(HIGH)  COLOR(YELLOW)\n ] TYPE(TEXT)    INTENS(HIGH)  COLOR(TURQ)\n { TYPE(TEXT)    INTENS(LOW)   COLOR(GREEN)\n @ TYPE(TEXT)    INTENS(HIGH)   COLOR(WHITE)\n27 AREA(SCRL) EXTEND(ON)\n)BODY EXPAND(!!)\n]COMMAND ===>[ZCMD                                      \u00ac\n]                                                       \u00ac\n@-!-! \u00a2Total Line@ !-!-\n]\n\u001bSAREA01                                                                       \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n)AREA SAREA01\n] { The Total line contains totals, averages and maximums for various\n] { fields. Fields will be scaled by 1000, if required, to fit in the\n] { display fields. If scaling is done, the (scaled) number is rounded\n] { (remainder/divisor > .5, rounded up; otherwise down) and is suffixed\n] { with K, M, G, etc.\n] {\n]   Volser:\n] {   If the selection criteria contained a single volume mask to\n] {   include, this field contains the mask. Otherwise, this field\n] {   is blank.\n] {\n]   UCB:\n] {   If the selection criteria contained a single UCB mask to\n] {   include, this field contains the mask. Otherwise, this field\n] {   is blank.\n] {\n]   DevType:\n] {   This field contains the total number of DASD volumes that met\n] {   the selection criteria.\n] {\n]   St:\n] {   This field is blank.\n] {\n]  *Volume Free Trks:\n] {   The total number of free tracks on all the volumes from which\n] {   valid usage data were obtained.\n] {\n]  *Volume Free Cyls:\n] {   The total number of free cylinders on all the volumes from which\n] {   valid usage data were obtained.\n] {\n]  *Volume Free %:\n] {   The average free percentage of all volumes from which valid\n] {   usage data were obtained, based on Volume Free Bytes.\n] {   No rounding is done.\n] {\n]  *Volume Free Bytes:\n] {   The total number of free bytes on all the volumes from which\n] {   valid usage data were obtained, based on Volume Free Bytes.\n] {\n]  *Nbr Extents:\n] {   The total number of free extents on all the volumes from which\n] {   valid usage data were obtained.\n] {\n]  *Largest Trks:\n] {   The number of tracks in the largest free extent on any of the\n] {   volumes from which valid usage data were obtained.\n] {\n]  *Largest Cyls:\n] {   The number of cylinderss in the largest free extent on any of the\n] {   volumes from which valid usage data were obtained.\n] {\n]   Frag Index:\n] {   The average of the fragmentation index for all volumes from\n] {   which valid usage data were obtained.\n] {\n]  *VTOC Trks:\n] {   The total number of tracks allocated to the VTOCs on all volumes\n] {   from which valid usage data were obtained.\n] {\n]  *VTOC Free DSCBs:\n] {   The total number of free DSCBs in the VTOCs on all volumes from\n] {   which valid usage data were obtained.\n] {\n]  *VTOC % Free:\n] {   The average percentage of free DSCBs in the VTOCs on all volumes\n] {   from which valid usage data were obtained.\n] {\n]   IX St:\n] {   This field is blank.\n] {\n]  *Volume Size:\n] {   The total number of bytes on all the volumes from which\n] {   valid usage data were obtained.\n] {\n]   SMS Storage Group:\n] {   This field is blank.\n] {\n]   SMS Status:\n] {   This field is blank.\n] {\n]   CHPIDs:\n] {   This field is blank unless a CHPID was either physically or\n] {   logically unavailable, in which case it will contain a terse\n] {   indication of the symbols used to indicate unavailability.\n] {\n] {\n] {* When viewing the output of this command with ISPF(S) (the customized\n] { ISPF Panel), placing the cursor in one of these fields and pressing\n] { ENTER will cause the unscaled, unrounded number, to a maximum of 16\n] { digits, to be displayed in the upper right-hand corner of the screen.\n] {\n)INIT\n  &PANEL   = 'SSCSPCO4'\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SSCSPCO5": {"ttr": 21763, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x18\\x00\\x00\\x01\\x06\\x11\\x1f\\x01\\x06\\x11\\x1f\\x00\\x00\\x00?\\x00?\\x00\\x00\\xe2\\xd7\\xc1\\xc3\\xc5@@@@@'", "ispf": {"version": "02.24", "flags": 0, "createdate": "2006-04-21T00:00:00", "modifydate": "2006-04-21T00:00:00", "lines": 63, "newlines": 63, "modlines": 0, "user": "SPACE"}, "text": ")PANEL KEYLIST(ISRHLP2 ISR)\n)ATTR FORMAT(MIX) DEFAULT(|\u00ac[)                             /* ENGLISH */\n } TYPE(TEXT)    INTENS(HIGH)  COLOR(GREEN) HILITE(REVERSE)\n \u00a2 TYPE(TEXT)    INTENS(HIGH)  COLOR(YELLOW)\n ] TYPE(TEXT)    INTENS(HIGH)  COLOR(TURQ)\n { TYPE(TEXT)    INTENS(LOW)   COLOR(GREEN)\n @ TYPE(TEXT)    INTENS(HIGH)   COLOR(WHITE)\n27 AREA(SCRL) EXTEND(ON)\n)BODY EXPAND(!!)\n]COMMAND ===>[ZCMD                                      \u00ac\n]                                                       \u00ac\n@-!-! \u00a2Statistics Lines@ !-!-\n]\n\u001bSAREA01                                                                       \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n)AREA SAREA01\n] { The Statistics lines contain information about the assembly and\n] { execution environments, and are typically used during problem\n] { identification and resolution.\n] { Statistics lines are not produced by default.\n] { Statistics lines fall into 4 broad groups:\n] {    Assembly Environment\n] {    Execution Environment\n] {    Main Storage Usage\n] {    Execution Time Data\n] {\n] {\n]   Assembly Environment:\n] {   The first 2 lines identify the environment under which this\n] {   program was assembled.\n] {\n]   Execution Environment:\n] {   The next 2 lines identify the environment under which this\n] {   program was executed.\n] {\n]   Installation Defaults:\n] {   The next set of lines present the defaults with which the program\n] {   was installed.\n] {\n]   Main Storage Usage:\n] {   The next 2 lines present data relating to main storage usage,\n] {   both above and below the 16Mb line.\n] {\n]   Execution Time Data:\n] {   The remaining lines present data relating to the time used\n] {   during the execution of this program. All times are presented\n] {   in seconds.\n] {\n)INIT\n  &PANEL   = 'SSCSPCO5'\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SSCSPCO6": {"ttr": 21765, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x00\\x00\\x00\\x01\\x06\\x11\\x1f\\x01\\x06\\x11\\x1f\\x00\\x00\\x00T\\x00T\\x00\\x00\\xe2\\xd7\\xc1\\xc3\\xc5@@@@@'", "ispf": {"version": "02.00", "flags": 0, "createdate": "2006-04-21T00:00:00", "modifydate": "2006-04-21T00:00:00", "lines": 84, "newlines": 84, "modlines": 0, "user": "SPACE"}, "text": ")PANEL KEYLIST(ISRHLP2 ISR)\n)ATTR FORMAT(MIX) DEFAULT(|\u00ac[)                             /* ENGLISH */\n } TYPE(TEXT)    INTENS(HIGH)  COLOR(GREEN) HILITE(REVERSE)\n \u00a2 TYPE(TEXT)    INTENS(HIGH)  COLOR(YELLOW)\n ] TYPE(TEXT)    INTENS(HIGH)  COLOR(TURQ)\n { TYPE(TEXT)    INTENS(LOW)   COLOR(GREEN)\n @ TYPE(TEXT)    INTENS(HIGH)   COLOR(WHITE)\n27 AREA(SCRL) EXTEND(ON)\n)BODY EXPAND(!!)\n]COMMAND ===>[ZCMD                                      \u00ac\n]                                                       \u00ac\n@-!-! \u00a2What's New@ !-!-\n]\n\u001bSAREA01                                                                       \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n)AREA SAREA01\n]   2.24\n{   - Data based on track size use available track capacity, as opposed to\n{      raw track capacity. This means that, for instance, the volume size of\n{      a 3390-3 is now calculated to be the generally accepted value of 2.83G,\n{      instead of the previous 2.9G.\n{   - Numeric values that must be scaled to fit in the display fields are\n{      rounded (.5 and above are rounded up) instead of truncated.\n{   - When viewing the results in ISPF(S) (the customized panels, as opposed to\n{      Edit or View), the unscaled, unrounded values of numeric fields can be\n{      displayed by positioning the cursor on the field, and hitting Enter. The\n{      value of the field will be displayed in the upper right-hand corner of\n{      the screen.\n{   - Multiple instances of the program can be active concurrently in ISPF\n{      split-screen mode.\n{   - The LINESIZE keyword has been added to allow the user to specify the\n{      length of non-ISPF output - the default is still the terminal width or\n{      SYSPRINT record length.\n{   - The title of the output contains the name and version of the program.\n{   - z/OS.e identified in Statistics lines.\n{   - Changed 'Line x of y' to 'Line x' in ISPF(S) display.\n{   - WAIT for all detail lines to be populated before sorting.\n{   - MAXLWAIT parameter added, to specify the maximum time to wait for\n{     LSPACE to complete.\n{   - Added Assembly parms to allow the installation to define:\n{     - default MAXLWAIT in Foreground and Background\n{     - default and maximum subtask counts\n{   - Listed installation defaults in the stats lines\n{   - '*E*' added to emulated devices\n{   - Various internal changes\n{\n]   2.23\n{   - Internal changes (use CRCSI to retrieve CPU-related info).\n{\n]   2.22\n{   - Bug fix related to SMS info (again)\n{\n]   2.21\n{   - Bug fix when selecting by UCB, and no UCBs found.\n{   - When in ISPF(S) or ISPF(B) modes, you can switch to an alternate ISPF\n{      output mode with the primary command ISPF(x), where\n{       x = B: Browse mode\n{           E: Edit Mode\n{           S: Customised panel\n{      Note that this primary command is *not* available in ISPF(E).\n{   - Volume size field added after VTOC info.\n{   - Static System symbols and substringing can be used when invoking the\n{     program.\n{   - Bug fix related to SMS info.\n{   - Bug fix related to SA03 Abends.\n{   - If input is read from SYSIN, output is sent to SYSPRINT, even if ISPF\n{      is available.\n{   - Honoured SYSPRINT DCB characteristics.\n{\n)INIT\n  &PANEL   = 'SSCSPCO6'\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SSCSPCP1": {"ttr": 21768, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x11\\x00\\x00\\x01\\x02\\x07\\x0f\\x01\\x02\\x07\\x0f\\x00\\x00\\x00\\x1f\\x006\\x00\\x00\\xe2\\xd7\\xc1\\xc3\\xc5@@@@@'", "ispf": {"version": "02.17", "flags": 0, "createdate": "2002-03-11T00:00:00", "modifydate": "2002-03-11T00:00:00", "lines": 31, "newlines": 54, "modlines": 0, "user": "SPACE"}, "text": ")PANEL KEYLIST(ISRHLP2 ISR)\n)ATTR FORMAT(MIX) DEFAULT(|+_)                             /* ENGLISH */\n } TYPE(TEXT)    INTENS(HIGH)  COLOR(GREEN) HILITE(REVERSE)\n \u00a2 TYPE(TEXT)    INTENS(HIGH)  COLOR(YELLOW)\n $ TYPE(TEXT)    INTENS(HIGH)  COLOR(TURQ)\n + TYPE(TEXT)    INTENS(LOW)   COLOR(GREEN)\n @ TYPE(TEXT)    INTENS(HIGH)  COLOR(WHITE)\n)BODY  EXPAND(!!)\n$-!-!  SPACE Command  !-!-\n$COMMAND ===>_ZCMD                                                             +\n+\n+  Several options are available to control the processing performed\n+ by this command. All parameters are optional.\n+\n+  Information about the following processing options are presented\n+ in sequence, or can be selected by number:\n+    @1+- Max Subtasks\n+    @2+- File DDName\n+    @3+- File Output\n+    @4+- LSPACE Data?\n)INIT\n  &PANEL   = 'SSCSPCP1'\n)PROC\n   &ZSEL = TRANS(&ZCMD\n                1,SSCSPCFD\n                2,SSCSPCFE\n                3,SSCSPCFF\n                4,SSCSPCFG\n                )\n   &ZUP = ISR00003\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SSCSPC01": {"ttr": 21770, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x18\\x00\\x00\\x01\\x06\\x11\\x1f\\x01\\x06\\x11\\x1f\\x00\\x00\\x00\\x99\\x00\\x99\\x00\\x00\\xe2\\xd7\\xc1\\xc3\\xc5@@@@@'", "ispf": {"version": "02.24", "flags": 0, "createdate": "2006-04-21T00:00:00", "modifydate": "2006-04-21T00:00:00", "lines": 153, "newlines": 153, "modlines": 0, "user": "SPACE"}, "text": ")ATTR FORMAT(MIX)                                          /* ENGLISH */\n } TYPE(TEXT)    INTENS(HIGH)  COLOR(GREEN) HILITE(REVERSE)\n \u00a2 TYPE(TEXT)    INTENS(HIGH)  COLOR(YELLOW)\n $ TYPE(TEXT)    INTENS(HIGH)  COLOR(TURQ)\n + TYPE(TEXT)    INTENS(LOW)   COLOR(GREEN)\n @ TYPE(TEXT)    INTENS(HIGH)   COLOR(WHITE)\n _ INTENS(HIGH)   COLOR(TURQ)\n27 AREA(SCRL) EXTEND(ON)\n)BODY  CMD(ZCMD)\n@----------------------------- \u00a2SSC SPACE Command @-----------------------------\n$COMMAND ===>_ZCMD                                                             +\n\u001bSAREA01                                                                       \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n\u001b                                                                              \u001b\n)AREA SAREA01\n\u00a2 Selection Criteria:                                                          +\n+  Include Volser Masks :_Z                                                    +\n+  Exclude Volser Masks :_Z                                                    +\n+  Include UCB Masks    :_Z                                                    +\n+  Exclude UCB Masks    :_Z                                                    +\n+  SMS StorGrp Masks    :_Z                                                    +\n+  Esoteric Name        :_Z       +\n+  Mount Attribute      :_Z  +          PVT,PUB,STG,SMS\n+                                                                              +\n+                                                                              +\n\u00a2 Display Options:                                                             +\n+  Sort Field           :_Z      +      VOL UCB DEVT ATTR FREET FREEC FREEP\n+                                       FREEB FREEE LARGET LARGEC FRAG VFREED\n+                                       VFREEP VTRK VIX VOLSIZE STORGRP SMSSTAT\n+                                       RCOPY CHPIDS\n+  Sort Order           :_Z+            A/D (Ascending/Descending)\n+  Heading Lines        :_Z+            N:No Heading Lines\n+  Detail Lines         :_Z+            N:No Detail (Volume) Lines\n+  Totals Line          :_Z+            N:No Total Lines\n+  Statistics           :_Z+            Y:Internal processing statistics\n+  ISPF display         :_Z+            N(o), S(tandard), B(rowse), E(dit)\n+\n\u00a2 Processing Options:\n+  Max SubTasks         :_Z +           Maximum Subtasks\n+  File DDName          :_Z       +     Additional output DDName\n+  File Output          :_Z      +      DISPLAY/CB/ALL\n+  LSPACE Data?         :_Z+            N:Only in-storage data\n+  LSPACE Wait Time     :_Z  +          Max secs to wait for LSPACE\n)INIT\n  .ZVARS  = '(SSCSPCVO,SSCSPCXV,SSCSPCUC,SSCSPCXU,SSCSPCSG,SSCSPCEN,+\n              SSCSPCAT,SSCSPCSF,SSCSPCSO,+\n              SSCSPCHD,SSCSPCDT,SSCSPCTO,SSCSPCST,SSCSPCIS,+\n              SSCSPCMT,SSCSPCOF,SSCSPCOD,SSCSPCNL,SSCSPCLW)'\n  .HELP   = SSCSPCH1\n  .CURSOR = ZCMD\n  VGET (SSCSPCVO,SSCSPCXV,SSCSPCUC,SSCSPCXU,SSCSPCSG,SSCSPCEN,\n        SSCSPCAT,SSCSPCSF,SSCSPCSO,\n        SSCSPCHD,SSCSPCDT,SSCSPCTO,SSCSPCST,SSCSPCIS,SSCSPCMT,\n        SSCSPCOF,SSCSPCOD,SSCSPCNL,SSCSPCLW) PROFILE\n)PROC\n  VER (&SSCSPCSF,LIST,VOL,UCB,DEVT,ATTR,FREET,FREEC,FREEP,FREEB, +\n                      FREEE,LARGET,LARGEC,VFREED,VFREEP,VTRK,VIX,+\n                      FRAG,STORGRP,RCOPY,CHPIDS)\n  VER (&SSCSPCSO,LIST,A,D)\n  VER (&SSCSPCHD,LIST,Y,N)\n  VER (&SSCSPCDT,LIST,Y,N)\n  VER (&SSCSPCTO,LIST,Y,N)\n  VER (&SSCSPCST,LIST,Y,N)\n  VER (&SSCSPCIS,LIST,N,S,B,E)\n  VER (&SSCSPCMT,RANGE,0,255)\n  VER (&SSCSPCOF,NAME)\n  VER (&SSCSPCOD,LIST,DISPLAY,CB,ALL)\n  VER (&SSCSPCNL,LIST,Y,N)\n  VER (&SSCSPCLW,RANGE,0,255)\n  &SPCPRM = &Z\n  IF (&SSCSPCVO \u00ac= &Z)\n     &SPCPRM = '&SPCPRM. VOL(&SSCSPCVO.)'\n  IF (&SSCSPCXV \u00ac= &Z)\n     &SPCPRM = '&SPCPRM. XVOL(&SSCSPCXV.)'\n  IF (&SSCSPCUC \u00ac= &Z)\n     &SPCPRM = '&SPCPRM. UCB(&SSCSPCUC.)'\n  IF (&SSCSPCXU \u00ac= &Z)\n     &SPCPRM = '&SPCPRM. XUCB(&SSCSPCXU.)'\n  IF (&SSCSPCSG \u00ac= &Z)\n     &SPCPRM = '&SPCPRM. STORGRP(&SSCSPCSG.)'\n  IF (&SSCSPCEN \u00ac= &Z)\n     &SPCPRM = '&SPCPRM. NAME(&SSCSPCEN.)'\n  IF (&SSCSPCAT \u00ac= &Z)\n     &SPCPRM = '&SPCPRM. ATTR(&SSCSPCAT.)'\n  IF (&SSCSPCSF \u00ac= &Z)\n     &SPCPRM = '&SPCPRM. SORT(&SSCSPCSF.)'\n  IF (&SSCSPCSO  = 'D')\n     &SPCPRM = '&SPCPRM. DESCENDING'\n  IF (&SSCSPCHD = 'N')\n     &SPCPRM = '&SPCPRM. NOHDG'\n  IF (&SSCSPCDT = 'N')\n     &SPCPRM = '&SPCPRM. NODET'\n  IF (&SSCSPCTO = 'N')\n     &SPCPRM = '&SPCPRM. NOTOT'\n  IF (&SSCSPCST = 'Y')\n     &SPCPRM = '&SPCPRM. STATS'\n  IF (&SSCSPCMT \u00ac= 'N')\n     &SPCPRM = '&SPCPRM. MAXT(&SSCSPCMT.)'\n  IF (&SSCSPCIS \u00ac= &Z)\n     &SPCPRM = '&SPCPRM. ISPF(&SSCSPCIS.)'\n  IF (&SSCSPCOF \u00ac= &Z)\n     &SPCPRM = '&SPCPRM. OUTFILE(&SSCSPCOF.)'\n  IF (&SSCSPCOD \u00ac= &Z)\n     &SPCPRM = '&SPCPRM. OUTDATA(&SSCSPCOD.)'\n  IF (&SSCSPCNL = 'N')\n     &SPCPRM = '&SPCPRM. NOLSPACE'\n  IF (&SSCSPCLW \u00ac= &Z)\n     &SPCPRM = '&SPCPRM. MAXLWAIT(&SSCSPCLW.)'\n  VPUT (SSCSPCVO,SSCSPCXV,SSCSPCUC,SSCSPCXU,SSCSPCSG,SSCSPCEN,\n        SSCSPCAT,SSCSPCSF,SSCSPCSO,\n        SSCSPCHD,SSCSPCDT,SSCSPCTO,SSCSPCST,SSCSPCIS,SSCSPCMT,\n        SSCSPCOF,SSCSPCOD,SSCSPCNL,SSCSPCLW) PROFILE\n  &ZSEL = 'CMD(SPACE &SPCPRM)'\n)HELP\nFIELD(SSCSPCVO) PANEL(SSCSPCF2)\nFIELD(SSCSPCXV) PANEL(SSCSPCF2)\nFIELD(SSCSPCUC) PANEL(SSCSPCF3)\nFIELD(SSCSPCXU) PANEL(SSCSPCF3)\nFIELD(SSCSPCSG) PANEL(SSCSPCFH)\nFIELD(SSCSPCEN) PANEL(SSCSPCF4)\nFIELD(SSCSPCAT) PANEL(SSCSPCF5)\nFIELD(SSCSPCSF) PANEL(SSCSPCF6)\nFIELD(SSCSPCSO) PANEL(SSCSPCF7)\nFIELD(SSCSPCHD) PANEL(SSCSPCF8)\nFIELD(SSCSPCDT) PANEL(SSCSPCF9)\nFIELD(SSCSPCTO) PANEL(SSCSPCFA)\nFIELD(SSCSPCST) PANEL(SSCSPCFB)\nFIELD(SSCSPCIS) PANEL(SSCSPCFC)\nFIELD(SSCSPCMT) PANEL(SSCSPCFD)\nFIELD(SSCSPCOF) PANEL(SSCSPCFE)\nFIELD(SSCSPCOD) PANEL(SSCSPCFF)\nFIELD(SSCSPCNL) PANEL(SSCSPCFG)\nFIELD(SSCSPCLW) PANEL(SSCSPCFI)\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SSCSPC02": {"ttr": 21774, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x1a\\x002\\x01\\x06\\x11\\x1f\\x01\\x17\\t/\\x10$\\x00\\x10\\x00\\x0b\\x00\\x00\\xc2\\xc9\\xc7\\xe2\\xc3\\xd9\\xd5@@@'", "ispf": {"version": "02.26", "flags": 0, "createdate": "2006-04-21T00:00:00", "modifydate": "2017-04-02T10:24:32", "lines": 16, "newlines": 11, "modlines": 0, "user": "BIGSCRN"}, "text": ")ATTR DEFAULT(|+_)\n ' AREA(DYNAMIC) SCROLL(ON) EXTEND(ON)\n)BODY WIDTH(&ZSCREENW) EXPAND(\\\\)\n|&HDG0                        \\ \\                                  |Line|&FLIN|+\n|COMMAND ===>_ZCMD            \\ \\                             |Scroll ===>_AMT +\n'DATA                         \\ \\                                              '\n)INIT\n .HELP = SSCSPCO0\n)PROC\n &SSCSPCLV = LVLINE(DATA)\n)END\n/* 2017/03/30 EWP Added WIDTH and EXPAND to )BODY statement.         */\n/*                Added expansion string \"\\ \\\" to all lines in BODY. */\n/*                This allows the panel to expand to a screen size   */\n/*                GT 80, permitting cursor selection of a number     */\n/*                to work for screen size GT 80.                     */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SSCSPC03": {"ttr": 21776, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x15\\x00\\x00\\x01\\x02\\x16/\\x01\\x03(\\x0f\\x00\\x00\\x00e\\x00f\\x00\\x00\\xe2\\xd7\\xc1\\xc3\\xc5@@@@@'", "ispf": {"version": "02.21", "flags": 0, "createdate": "2002-06-11T00:00:00", "modifydate": "2003-10-07T00:00:00", "lines": 101, "newlines": 102, "modlines": 0, "user": "SPACE"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT534/FILE534.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT534", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}