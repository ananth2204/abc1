{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012318000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 352716, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 10, "INMDSNAM": "CBT.V500.FILE543.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 352716, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 352716, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE543.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x07\\x08'", "DS1TRBAL": "b'\\x8bR'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x04\\x02\\x00\\x0b\\x04\\x03\\x00\\x03\\x00\\x08'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\x06O\\x01\\x02\\x06O\\x17\\x15\\x00\\x0c\\x00\\x0c\\x00\\x00\\xe2\\xc8\\xc9\\xd7\\xc4\\xc1\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-03-05T00:00:00", "modifydate": "2002-03-05T17:15:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "SHIPDAT"}, "text": "REGULAR CBT TAPE - VERSION 443    FILE:  543\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT443.FILE543\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 30 MEMBERS COUNTED; CUMULATIVE SIZE IS 2,969 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   03/05/02    17:15:11    GMT-5:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$$INFO": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x05\\x00\\x01\\x01\\x02\\x01\\x7f\\x01\\x02\\x01\\x8f\\x12\\x05\\x00'\\x00\\x0c\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@\"", "ispf": {"version": "01.05", "flags": 0, "createdate": "2002-01-17T00:00:00", "modifydate": "2002-01-18T12:05:01", "lines": 39, "newlines": 12, "modlines": 0, "user": "SBGOLOB"}, "text": "Checksys was written to extend my use of REXX, and to provide a\nsimple tool to display System Information after an IPL.  It sort\nof grew from there.\n\nIt is written in REXX, with panels that need to be copied into an\nappropriate panel library and a simple Assembler program that\nneeds to be compiled on to an appripriate ISPLLIB library. The\nassembler program uses the UCBSCAN macro.  If someone could show\nme how to do this in REXX, I would be greatly appreciate it.\n\nSince I am working in France, the keyboard characters will not\nmatch US/UK keyboards.  For example, (| instead of ]), and some\nattribute characters within the panels.  You will have to change\nthem to suitable local values.\n\nThe interface is fairly simple, where you enter either a number\nor a character to select the option required.\n\nThe 'F'ind option requires that you enter 'F xxxx' where XXXX is\nthe character you are searching for.  The 'F'ind is available on\noption 5 - 8.\n\nError handling is rudamentary to non-existant.  I have tried by\nwriting 'fast' code, not 'fancy' code.  Any errors I will gladly\nattempt to fix, except when they are 'design features'.\n\nPlease feel free to update, replace or trash my code as much as\nyou like, just as long as you send me a copy.\n\nDavid H. Barnard-Brown.\nChief Designer, Coder, Tester, De-bugger and bottle-washer.\n\nphone: +33 (0)3 28 55 62 19\nemail: ext.b_m.barnard-brown@sncf.fr\n\nSNCF - DSIV - GL-XL\nCentre Informatique de Lille\nPont de Tournai - 59041 LILLE CEDEX\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$$$NOTE1": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\"\\x01\\x02\\x01\\x8f\\x01\\x02\\x01\\x8f\\x12\\x12\\x00)\\x00)\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-01-18T00:00:00", "modifydate": "2002-01-18T12:12:22", "lines": 41, "newlines": 41, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject: CBT tape\nDate: Thu, 17 Jan 2002 15:55:58 +0100\nFrom: EXT / B&M BARNARD-BROWN David <ext.b_m.barnard-brown@sncf.fr>\nOrganization: S.N.C.F. French Railways\nTo: \"'sbgolob@attglobal.net'\" <sbgolob@attglobal.net>\n\nI have written some REXX code to display System Information.\n\nI wrote it initialy to verify a system after an IPL, and it grew\nfrom there.\n\nThe utility is called 'CHECKSYS'.\n\nIt now uses pop-up ISPF panels, an assembler program ('cause I\ncould not do it in REXX) and REXX.\n\nI also continued to develop it as a means of understanding how\nOS/390 holds together and to utilize some of the 'fancier'\nstatements of REXX.\n\n'CHECKSYS' has been verified on OS/390 2.6 and OS/390 2.8.\nBecause I am contracting here in France, some of the characters\nused to define screen attributes, and used by REXX (! instead of\n|), may not operate correctly when used elsewhere.\n\nI know there are far superior programs (Showmvs, Tasid, etc.),\nbut I enjoyed writing mine and is useful to me in my work.  It is\nprobably full of 'features', because 'programmers can never see\nthe woods for the trees...'.\n\nIf you feel it would make a useful contribution to the CBT tape,\nplease feel free to use it.  David H. Barnard-Brown\n\n*       ext.b_m.barnard-brown@sncf.fr\n*       03 28 55 62 19    (SNCF : 22 52 19)\n*        03 28 55 63 09    (SNCF : 22 53 09)\n\nSNCF - DSIV - GL-XL\nCentre Informatique de Lille\nPont de Tournai - 59041 LILLE CEDEX\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$$NOTE2": {"ttr": 522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\x06O\\x01\\x02\\x06O\\x17\\x03\\x00\\x14\\x00\\x14\\x00\\x00\\xc4\\xc2\\xc2\\xd9\\xd6\\xe6\\xd5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-03-05T00:00:00", "modifydate": "2002-03-05T17:03:00", "lines": 20, "newlines": 20, "modlines": 0, "user": "DBBROWN"}, "text": "I have broken CHECKSYS up into it's individual compmnent.\n\nThis way, you can call the component direct, or you call still use CHECKSYS.\n\nThe components are:\n\nAPF - list out the current APF.\nASL - simple Address Space monitoring utility.\nLNK - list out the current Linklist.\nLPA - list out the current LPA list\nMAP - display Storage Map.\nSTR - Display the Storage Usage.\nSYS - display the System paramaters.\nVER - display the Software Versions.\n\nFor example:\n\nYou can call 'TSO LPA' directly, or still use the original CHECKSYS,\n'TSO CHECKSYS LPA' or 'TSO CHECKSYS 5' or just 'TSO CHECKSYS' and select\noption 5.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$$$NOTE3": {"ttr": 524, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\x06O\\x01\\x02\\x06O\\x17\\x03\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc4\\xc2\\xc2\\xd9\\xd6\\xe6\\xd5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-03-05T00:00:00", "modifydate": "2002-03-05T17:03:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "DBBROWN"}, "text": "I have included two REXX routines that I regularly use prior to an IPL.\n\nThe first, CHKIPLPK, checks each IPL pack to ensure that all the NONVSAM\ndatasets are indirectly cataloged, either to &SYSR1 or &SYSR2.  It also\ncheck that the datasets on &SYSR1 are correctly cataloged to &SYSR2 and\nvisa-versa.\n\nThe second, CHLMCAT, checks all the NONVSAM datasets in the\nMaster Catalog to verify that the dataset phyically exists|\n\nThese two utilities help me ensure the integrity of the system.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$$USAGE": {"ttr": 526, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\x06O\\x01\\x02\\x06O\\x17\\x03\\x00\\x1f\\x00\\x1f\\x00\\x00\\xc4\\xc2\\xc2\\xd9\\xd6\\xe6\\xd5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-03-05T00:00:00", "modifydate": "2002-03-05T17:03:00", "lines": 31, "newlines": 31, "modlines": 0, "user": "DBBROWN"}, "text": "CHECKSYS has 8 components.\n\nThe components are:\n\nAPF - list out the current APF.\n    - search the list using 'F xxx'\nASL - simple Address Space monitoring utility.\n    - output can be sorted\n    - view can be restricted\n    - display updated dynamically\n    - search the list using 'F xxx'\nLNK - list out the current Linklist.\n    - search the list using 'F xxx'\nLPA - list out the current LPA list\n    - search the list using 'F xxx'\nMAP - display Storage Map.\nSTR - Display the Storage Usage.\n    - CSA/SQA size, CSA/SQA usage, etc.\n    - ASVT 'slots'\nSYS - display the System paramaters.\n    - Master Catalog\n    - IODF dataset, LOADxx parm, etc.\n    - IPL date, SYSRES's, etc.\nVER - display the Software Versions.\n\nYou can call CHECKSYS and use the menu or you can call each\ncomponent directly.\n\nIf you want to list out LPA, but not us the menu then\nyou can call 'TSO CHECKSYS LPA' or 'TSO CHECKSYS 5'.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "@FILE543": {"ttr": 528, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00&\\x01\\x01\\x02_\\x01\\x02\\x06O\\x17\\x14\\x00C\\x00\\x02\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2001-01-25T00:00:00", "modifydate": "2002-03-05T17:14:26", "lines": 67, "newlines": 2, "modlines": 0, "user": "SBGOLOB"}, "text": "//***FILE 543 is from David Barnard-Brown, and contains REXX        *   FILE 543\n//*           execs and an Assembler program, to display system     *   FILE 543\n//*           information.                                          *   FILE 543\n//*                                                                 *   FILE 543\n//*      email:    ext.b_m.barnard-brown@sncf.fr                    *   FILE 543\n//*                                                                 *   FILE 543\n//*      phone:    03 28 55 62 19    (SNCF : 22 52 19)              *   FILE 543\n//*                03 28 55 63 09    (SNCF : 22 53 09)              *   FILE 543\n//*                                                                 *   FILE 543\n//*      SNCF - DSIV - GL-XL                                        *   FILE 543\n//*      Centre Informatique de Lille                               *   FILE 543\n//*      Pont de Tournai - 59041 LILLE CEDEX                        *   FILE 543\n//*                                                                 *   FILE 543\n//*   Short Description:                                            *   FILE 543\n//*                                                                 *   FILE 543\n//*      I have written some REXX code to display System            *   FILE 543\n//*      Information.                                               *   FILE 543\n//*                                                                 *   FILE 543\n//*      I wrote it initially to verify a system after an IPL,      *   FILE 543\n//*      and it grew from there.                                    *   FILE 543\n//*                                                                 *   FILE 543\n//*      The utility is called 'CHECKSYS'.                          *   FILE 543\n//*                                                                 *   FILE 543\n//*      It now uses pop-up ISPF panels, an assembler program       *   FILE 543\n//*      ('cause I could not do it in REXX) and REXX.               *   FILE 543\n//*                                                                 *   FILE 543\n//*      I also continued to develop it as a means of               *   FILE 543\n//*      understanding how OS/390 holds together and to utilize     *   FILE 543\n//*      some of the 'fancier' statements of REXX.                  *   FILE 543\n//*                                                                 *   FILE 543\n//*      'CHECKSYS' has been verified on OS/390 2.6 and OS/390      *   FILE 543\n//*      2.8.  Because I am contracting here in France, some of     *   FILE 543\n//*      the characters used to define screen attributes, and       *   FILE 543\n//*      used by REXX (! instead of |), may not operate             *   FILE 543\n//*      correctly when used elsewhere.                             *   FILE 543\n//*                                                                 *   FILE 543\n//*      There is one part of this package written in Assembler.    *   FILE 543\n//*      It is the member called GETUADDR, to return a UCB          *   FILE 543\n//*      address, given a volume name.                              *   FILE 543\n//*                                                                 *   FILE 543\n//*     - - - - - - - - - - - - - - - - - - - - - - - - - - - - -   *   FILE 543\n//*                                                                 *   FILE 543\n//*      I have broken CHECKSYS up into it's individual             *   FILE 543\n//*      compmnents.                                                *   FILE 543\n//*                                                                 *   FILE 543\n//*      This way, you can call the component directly, or you      *   FILE 543\n//*      can still use CHECKSYS.                                    *   FILE 543\n//*                                                                 *   FILE 543\n//*      The components are:                                        *   FILE 543\n//*                                                                 *   FILE 543\n//*      APF - list out the current APF.                            *   FILE 543\n//*      ASL - simple Address Space monitoring utility.             *   FILE 543\n//*      LNK - list out the current Linklist.                       *   FILE 543\n//*      LPA - list out the current LPA list                        *   FILE 543\n//*      MAP - display Storage Map.                                 *   FILE 543\n//*      STR - Display the Storage Usage.                           *   FILE 543\n//*      SYS - display the System paramaters.                       *   FILE 543\n//*      VER - display the Software Versions.                       *   FILE 543\n//*                                                                 *   FILE 543\n//*      For example:                                               *   FILE 543\n//*                                                                 *   FILE 543\n//*      You can call 'TSO LPA' directly, or still use the          *   FILE 543\n//*      original CHECKSYS,                                         *   FILE 543\n//*                                                                 *   FILE 543\n//*      'TSO CHECKSYS LPA' or 'TSO CHECKSYS 5' or just 'TSO        *   FILE 543\n//*      CHECKSYS' and select option 5.                             *   FILE 543\n//*                                                                 *   FILE 543\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "APF": {"ttr": 530, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\x06O\\x01\\x02\\x06O\\x17\\x03\\x00\\x86\\x00\\x86\\x00\\x00\\xc4\\xc2\\xc2\\xd9\\xd6\\xe6\\xd5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-03-05T00:00:00", "modifydate": "2002-03-05T17:03:00", "lines": 134, "newlines": 134, "modlines": 0, "user": "DBBROWN"}, "text": "/* REXX */\n/**********************************************************************/\n/* this routine gets the APF list - version 1.0                       */\n/**********************************************************************/\n/*------------------ initialize global variables ---------------------*/\ntrace 0\naddress tso                                    /* set mode            */\nnumeric digits 30                              /* set decimal size    */\nsysn = mvsvar('SYSNAME')                       /* get sysname         */\nred   = '01'x                                  /* set colour          */\nblue  = '02'x                                  /* attributes fo the   */\ngreen = '03'x                                  /* dynamic display     */\nwhite = '04'x                                  /* area                */\nturq  = '05'x                                  /*                     */\npink  = '06'x                                  /*                     */\nyellow = '07'x                                 /*                     */\ncur_line = 1                                   /* first row           */\ncsrpos  = 1                                    /* first character     */\npoppos  = 8                                    /* start pos. for pop  */\nscrn_wdth = 53                                 /* set screen width    */\n/*------------------ get linklist data -------------------------------*/\ncvt = c2d(storage(10,4))                       /* point to cvt        */\necvt = c2d(storage(d2x(cvt+140),4))            /* point to cvtecvt    */\ncvtauthl = c2d(storage(d2x(cvt+484),4))        /* point to cvtauthl   */\n\nif cvtauthl <> c2d('7ffff001'x) then           /* dynamic list ?      */\n  do\n    maxlines = c2d(storage(d2x(cvtauthl),2))   /* \u00a3 apf in table      */\n    apfoff   = 2                               /* first in apf tbl    */\n    do inc = 1 to maxlines\n       len = c2d(storage(d2x(cvtauthl+apfoff),1))  /* length of entry */\n       apfvol = storage(d2x(cvtauthl+apfoff+1),6)  /* apf volser      */\n       apfdsn = storage(d2x(cvtauthl+apfoff+1+6),len-6) /* apf dsn    */\n       apfoff = apfoff+len+1                   /* set apf offset      */\n       line.inc = green||left(apfdsn,45)||blue||apfvol\n    end\n  end\nelse\n  do\n    ecvtcsvt = c2d(storage(d2x(ecvt+228),4))   /* point to ecvtcsvt   */\n    apfa = c2d(storage(d2x(ecvtcsvt+12),4))    /* addr start of list  */\n    apht = c2d(storage(d2x(apfa+8),4))         /* addr 1st entry      */\n    last = c2d(storage(d2x(apfa+12),4))        /* addr last entry     */\n    apf. = ''\n    inc = 0\n    do forever\n      apfdsn = storage(d2x(apht+24),44)        /* apf dataset name    */\n      if substr(apfdsn,1,1) \u00ac= '00'x then      /* 00 = deleted        */\n        do\n          apfesms = storage(d2x(apht+4),1)     /* sms flag            */\n          if  bitand(apfesms,'80'x)  = '80'x then apfvol = '*SMS* '\n          else apfvol = storage(d2x(apht+68),6)   /* apf volser       */\n          line.inc =green||left(apfdsn,45)||blue||apfvol\n          inc = inc + 1\n        end\n      if apht = last then leave\n      else apht = c2d(storage(d2x(apht+8),4))  /* addr next entry     */\n    end\n    maxlines = inc - 1\n  end                                          /* set maximum lines   */\n\n/*--------------------- display list in pop-up window ----------------*/\ntitle = maxlines' APF Datasets for 'sysn       /* set display title   */\nsrchfor = ''                                   /* null string         */\ndyndata = ''                                   /* initialize display  */\n\ndo inc = 1 to maxlines                         /* for each line       */\n  dyndata = dyndata||line.inc                  /* build output line   */\nend\n\ndyndata = dyndata||blue||centre(white||'BOTTOM'||blue,scrn_wdth-1,'*')\n\naddress ispexec                                /* set mode            */\n\"vget zpf05 profile\"                           /* get PF5 key         */\nzpf05_old = zpf05                              /* save old key        */\nzpf05 = 'AGAIN'                                /* set PF5 key         */\n\"vput zpf05 profile\"                           /* store PF5 key       */\ncursor = 'cursor()'                            /* set initial value   */\n\"addpop row(2) column(\"poppos\")\"               /* set window          */\n\ndo until disprc > 0\n  dynarea = substr(dyndata,1+(cur_line-1)*scrn_wdth) /* set display   */\n  \"display panel(checkapf)\" cursor             /* display result      */\n  disprc = rc\n  \"vget (zverb,zscrolla,zscrolln)\"             /* get ispf values     */\n  select\n    when zverb = 'UP' then\n      do\n        if zscrolla = 'MAX' then cur_line = 1  /* move to top         */\n        else cur_line = max(1,cur_line-zscrolln) /* up x lines        */\n      end\n    when zverb = 'DOWN' then\n      do\n        if zscrolla = 'MAX' then cur_line = maxlines  /* move to bot. */\n        else cur_line = min(maxlines,cur_line+zscrolln) /*down x lines*/\n      end\n    when zcmd = 'AGAIN' & srchfor <> '' then   /* PF5 pressed         */\n      do\n        from_here = start_pos                  /* get search string   */\n        start_pos = pos(srchfor,dyndata,from_here+1) /* search again  */\n        if start_pos <> 0 then call get_position /* if found, display */\n        else call not_found                    /* reset cursor        */\n      end\n    when substr(zcmd,1,1) = 'F' then           /* find a string?      */\n      do\n        parse var zcmd . srchfor               /* get search string   */\n        start_pos = pos(srchfor,dyndata)       /* search for string   */\n        if start_pos <> 0 then call get_position /* if found, display */\n        else call not_found                    /* reset cursor        */\n      end\n    otherwise\n  end\nend\n\n\"rempop\"                                       /* close window        */\nzpf05 = zpf05_old                              /* reset pf key        */\n\"vput zpf05 profile\"                           /* store PF5 key       */\naddress tso                                    /* set mode            */\n\nexit\n/*------------------ calculate line position in dynamic area ---------*/\nget_position:\ncur_line = start_pos%scrn_wdth+1               /* get row position    */\ncsrpos = start_pos//scrn_wdth                  /* get column position */\ncursor = 'cursor(dynarea)'                     /* set cursor field    */\n\nreturn\n/*------------------ calculate line position in dynamic area ---------*/\nnot_found:\ncur_line = 1                                   /* set row position    */\ncsrpos  = 1                                    /* set column position */\ncursor = 'cursor()'                            /* set cursor field    */\n\nreturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ASL": {"ttr": 533, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\x06O\\x01\\x02\\x06O\\x17\\x03\\x01\\x84\\x01\\x84\\x00\\x00\\xc4\\xc2\\xc2\\xd9\\xd6\\xe6\\xd5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-03-05T00:00:00", "modifydate": "2002-03-05T17:03:00", "lines": 388, "newlines": 388, "modlines": 0, "user": "DBBROWN"}, "text": "/* REXX */\n/**********************************************************************/\n/* this routine gets the address space list - version 1.0             */\n/**********************************************************************/\n/*------------------ initialize global variables ---------------------*/\ntrace 0\naddress tso                                    /* set mode            */\nnumeric digits 30                              /* set decimal size    */\nsysn = mvsvar('SYSNAME')                       /* get sysname         */\nred   = '01'x                                  /* set colour          */\nblue  = '02'x                                  /* attributes fo the   */\ngreen = '03'x                                  /* dynamic display     */\nwhite = '04'x                                  /* area                */\nturq  = '05'x                                  /*                     */\npink  = '06'x                                  /*                     */\nyellow = '07'x                                 /*                     */\ncur_line = 1                                   /* first row           */\ncsrpos  = 1                                    /* first character     */\npoppos  = 3                                    /* start pos. for pop  */\ndisplay_again = 'Y'                            /* display once        */\nscrn_wdth = 64                                 /* set screen width    */\nsfld = 2                                       /* sort on first field */\nsfld = 2                                       /* sort on first field */\nslen = 8                                       /* length of field     */\nsorder = 'A'                                   /* sort type           */\nvfld = 'ALL'                                   /* view selection flag */\nvdis = 'All'                                   /* view selection flag */\n/*------------------ get address space list --------------------------*/\ncvt = c2d(storage(10,4))                       /* point to cvt        */\necvt = c2d(storage(d2x(cvt+140),4))            /* point to cvtecvt    */\ncvtasvt = c2d(storage(d2x(cvt+556),4))         /* point to cvtasvt    */\nasvtmaxu = c2d(storage(d2x(cvtasvt+516),4))    /* \u00a3 slots available   */\n\ndo until display_again = 'N'                  /* until PF3 is pressed */\n  inc = 1                                      /* at least once       */\n  acnt = 0                                     /*                     */\n  bcnt = 0                                     /*                     */\n  btcnt = 0                                    /* initialize          */\n  icnt = 0                                     /* counters            */\n  ocnt = 0                                     /* for all active      */\n  scnt = 0                                     /* address spaces      */\n  stcnt = 0                                    /*                     */\n  sycnt = 0                                    /*                     */\n  tcnt = 0                                     /*                     */\n  ucnt = 0                                     /*                     */\n  inc = 1                                      /* at least once       */\n/*---------------- get the cpu percentage ----------------------------*/\n  srmt = c2d(storage((d2x(cvt+604)),4))        /* point to smrt       */\n  cct = c2d(storage((d2x(srmt+4)),4))          /* point to cvtecvt    */\n  cpp = format(c2d(storage(d2x(cct+102),2)),3)||'%' /* format display */\n/*---------------- loop through non-vacant asvt slots ----------------*/\n  do cntr = 0 to asvtmaxu                     /* check all ASVT slots */\n    offset = cntr * 4                          /* increment offset    */\n    in_use_flag = storage(d2x(cvtasvt+528+offset),1)  /* get flag     */\n    if bitand(in_use_flag,'80'x) = '80'x then iterate   /* in use?    */\n    ascb = c2d(storage(d2x(cvtasvt+528+offset),4)) /* get ascb addr.  */\n    if ascb = '0' then iterate                     /* valid address?  */\n    if storage(d2x(ascb),4) <> 'ASCB' then iterate   /* eye catcher?  */\n    call get_ascb\n  end\n  maxlines = inc - 1                           /* set maximum lines   */\n  mcnt = maxlines                              /* set total ASIDs     */\n  call quicksort 1,maxlines                    /* sort the displays   */\n  call display_list                            /* display results     */\nend\n\nexit\n/**********************************************************************/\n/*-------------------- sub-routines ----------------------------------*/\n/**********************************************************************/\n/*------------- get address space infomation -------------------------*/\nget_ascb:\nasid = red||right(c2d(storage(d2x(ascb+36),2)),3)  /* get ASID        */\ndpri = blue||right(c2x(storage(d2x(ascb+43),1)),3) /* dispatch prior. */\ncscb = c2d(storage(d2x(ascb+56),4))            /* address of CSCB     */\nascbejst = c2d(storage(d2x(ascb+64),8))        /* job step cpu time   */\n/*--------------- convert CPU time to hh:mm.ss -----------------------*/\ncputime = ascbejst/4096/1000000                /* convert to minutes  */\ncpuhrs = cputime%60                            /* convert to hours    */\ncpuhrs = right(cpuhrs,3,' ')||':'              /* pad, add separator  */\ncpumin = (cputime//60)*60%60                   /* get seconds         */\ncpumin = right(cpumin,2,'0')||'.'              /* pad, add separator  */\ncpusec = cputime//1                            /* get seconds         */\ncpusec = substr(cpusec,3,2,'0')                /* pad                 */\ncpu = white||cpuhrs||cpumin||cpusec            /* build string        */\n/*--------------- get the assb info and build output line ------------*/\nassb = c2d(storage(d2x(ascb+336),4))           /* address of ASSB     */\nassbvsc = c2d(storage(d2x(assb+32),4))         /* VIO Aux pages used  */\nvio = turq||right(assbvsc,8)                   /* vio count           */\nassbnvsc = c2d(storage(d2x(assb+36),4))        /* non-VIO Aux pages   */\nnonvio = blue||right(assbnvsc,8)               /* non-vio count       */\n/*------------- set the job name and display colour ------------------*/\nascbjbns = c2d(storage(d2x(ascb+176),4))       /* address of jobname  */\n\nif ascbjbns = 0 then call starting_asid        /* Starting asid       */\nelse\n  do\n    jname = storage(d2x(ascbjbns),8)           /* get jobname         */\n    if cscb = 0 then call master_asid          /* Master asid?        */\n    else\n      do\n        chtrkid = c2d(storage(d2x(cscb+28),1)) /* display identifier  */\n        select\n          when chtrkid = 1 then call tso_asid  /* TSO asid?           */\n          when chtrkid = 2 then call stc_asid  /* STC asid?           */\n          when chtrkid = 3 then call init_asid /* Initiator asid?     */\n          when chtrkid = 4 then call system_asid /* System asid       */\n          otherwise call unknown_asid          /* Unknown asid        */\n        end\n      end\n  end\n\noucb = c2d(storage(d2x(ascb+144),4))           /* address of OUCB     */\noucbsfl = storage(d2x(oucb+17),1)              /* swapout flag        */\noucbsrc = c2d(storage(d2x(oucb+41),1))         /* get swap code       */\n/*----------------- convert numeric to swap code ---------------------*/\nselect\n  when oucbsrc = 1 then swap = blue||'TO'\n  when oucbsrc = 2 then swap = green||'TI'\n  when oucbsrc = 3 then swap = pink||'LW'\n  when oucbsrc = 4 then swap = turq||'XS'\n  when oucbsrc = 5 then swap = blue||'RS'\n  when oucbsrc = 6 then swap = pink||'DW'\n  when oucbsrc = 7 then swap = green||'RQ'\n  when oucbsrc = 8 then swap = turq||'NQ'\n  when oucbsrc = 9 then swap = blue||'EX'\n  when oucbsrc = 10 then swap = pink||'US'\n  when oucbsrc = 11 then swap = gteen||'TS'\n  when oucbsrc = 12 then swap = turq||'IC'\n  when oucbsrc = 13 then swap = blue||'IP'\n  when oucbsrc = 14 then swap = pink||'MR'\n  when oucbsrc = 15 then swap = green||'AW'\n  when oucbsrc = 16 then swap = turq||'OI'\n  when oucbsrc = 17 then swap = blue||'OO'\n  otherwise if bitand(oucbsfl,'80'x) = '80'x then swap = green||'NS'\n            else swap = yellow||'IN'\nend\n\nouxb = c2d(storage(d2x(ascb+148),4))           /* address of ouxb     */\nouxbiosm = c2d(storage(d2x(ouxb+152),4))       /* exception count     */\nexcp = pink||right(strip(ouxbiosm),9)          /* get exception count */\nrsme = c2d(storage(d2x(ascb+364),4))           /* address of rsme     */\nrstor = green||format(c2d(storage(d2x(rsme+44),4)),5) /* format rstor */\n\nif vfld = 'ALL' then call build_output\nelse\n  if type = vfld then call build_output\n  else nop\n\nreturn\n/*----------------------- build the output line ----------------------*/\nbuild_output:\nline.inc = jname||asid||dpri||swap||cpu||rstor||vio||nonvio||excp\ninc = inc + 1                                  /* increment counter   */\n\nreturn\n/*----------------------- Init ASID ----------------------------------*/\ninit_asid:\nselect\n  when jname = 'ASCHINT' then                  /* Initiator?          */\n    do\n      jname = white||jname                     /* set colour          */\n      type = 'ASC'                             /* set type            */\n      acnt = acnt + 1                          /* increment counter   */\n    end\n  when jname = 'BPXAS' then                    /* OMVS asid?          */\n    do\n      ascbjbni = c2d(storage(d2x(ascb+172),4)) /* iname address       */\n      if ascbjbni = 0 then                     /* blank iname field   */\n        do\n          jname = pink||jname                  /* set colour          */\n          type = 'BPX'                         /* set type            */\n          bcnt = bcnt + 1                      /* increment counter   */\n        end\n      else\n        do\n          jname = pink||storage(d2x(ascbjbni),8) /* use iname         */\n          type = 'OMV'                         /* set type            */\n          ocnt = ocnt + 1                      /* increment counter   */\n        end\n    end\n  when jname = 'INIT' then                     /* Initiator?          */\n    do\n      ascbjbni = c2d(storage(d2x(ascb+172),4)) /* iname address       */\n      if ascbjbni = 0 then                     /* blank iname field   */\n        do\n          jname = white||jname                 /* set colour          */\n          type = 'INI'                         /* set type            */\n          icnt = icnt + 1                      /* increment counter   */\n        end\n      else\n        do\n          jname = yellow||storage(d2x(ascbjbni),8) /* use iname       */\n          type = 'BAT'                         /* set type            */\n          btcnt = btcnt + 1                    /* increment counter   */\n        end\n    end\n  otherwise call unknown_asid                  /* what's left         */\nend\n\nreturn\n/*----------------------- Master ASID --------------------------------*/\nmaster_asid:\njname = white||jname                           /* set colour          */\ntype = 'SYS'                                   /* set type            */\nsycnt = sycnt + 1                              /* increment counter   */\n\nreturn\n/*----------------------- Starting ASID ------------------------------*/\nstarting_asid:\njname = yellow||'Starting'                     /* set colour          */\ntype = 'UKN'                                   /* set type            */\nstcnt = stcnt + 1                              /* increment counter   */\n\nreturn\n/*----------------------- STC ASID -----------------------------------*/\nstc_asid:\njname = turq||jname                            /* set colour          */\ntype = 'STC'                                   /* set type            */\nscnt = scnt + 1                                /* increment counter   */\n\nreturn\n/*----------------------- System ASID --------------------------------*/\nsystem_asid:\njname = blue||jname                            /* set colour          */\ntype = 'SYS'                                   /* set type            */\nsycnt = sycnt + 1                              /* increment counter   */\n\nreturn\n/*----------------------- TSO ASID -----------------------------------*/\ntso_asid:\njname = green||jname                           /* set colour          */\ntype = 'TSO'                                   /* set type            */\ntcnt = tcnt + 1                                /* increment counter   */\n\nreturn\n/*----------------------- Unknown ASID -------------------------------*/\nunknown_asid:\njname = red||'Unknown '                        /* set colour          */\ntype = 'UKN'                                   /* set type            */\nucnt = ucnt + 1                                /* increment counter   */\n\nreturn\n/*----------------------- sort the output lines ----------------------*/\nquicksort: procedure expose line. sorder sfld slen\narg first,last                                 /* point to cvtgda     */\nptr1 = first                                   /* point to cvtgda     */\nptr2 = last                                    /* point to cvtgda     */\nmid_point = (first + last) % 2                 /* point to cvtgda     */\nkeep = substr(line.mid_point,sfld,slen)        /* point to cvtgda     */\n\ndo until ptr1 > ptr2                           /* point to cvtgda     */\n  if sorder = 'A' then                         /* ascending sort      */\n    do\n      do while substr(line.ptr1,sfld,slen) << keep /* less than ?     */\n        ptr1 = ptr1 + 1                        /* increment counter   */\n      end\n      do while substr(line.ptr2,sfld,slen) >> keep /* more than ?     */\n        ptr2 = ptr2 - 1                        /* decrement counter   */\n      end\n    end\n  else                                         /* decending sort      */\n    do\n      do while substr(line.ptr1,sfld,slen) >> keep /* more than ?     */\n        ptr1 = ptr1 + 1                        /* increment counter   */\n      end\n      do while substr(line.ptr2,sfld,slen) << keep /* less than ?     */\n        ptr2 = ptr2 - 1                        /* decrement counter   */\n      end\n    end\n      if ptr1 <= ptr2 then                     /* point to cvtgda     */\n        do\n          temp_var = line.ptr1                 /* swap the two fields */\n          line.ptr1 = line.ptr2                /* using the temporary */\n          line.ptr2 = temp_var                 /* field               */\n          ptr1 = ptr1 + 1                      /* increment counter   */\n          ptr2 = ptr2 - 1                      /* decrement counter   */\n        end\n    end\n\nif first < ptr2 then call quicksort first,ptr2 /* move down top       */\nif ptr1 < last then call quicksort ptr1,last   /* move up bottom      */\n\nreturn\n/*--------------------- display list in pop-up window ----------------*/\ndisplay_list:\ntitle = ' Address Space List - 'vdis' for 'sysn /* set display title  */\nsrchfor = ''                                   /* null string         */\ndyndata = ''                                   /* initialize display  */\n\ndo inc = 1 to maxlines                         /* for each line       */\n  dyndata = dyndata||line.inc                  /* build output line   */\nend\n\ndyndata = dyndata||blue||centre(white||'BOTTOM'||blue,scrn_wdth-1,'*')\n\naddress ispexec                                /* set mode            */\n\"vget zpf05 profile\"                           /* get PF5 key         */\nzpf05_old = zpf05                              /* save old key        */\nzpf05 = 'AGAIN'                                /* set PF5 key         */\n\"vput zpf05 profile\"                           /* store PF5 key       */\ncursor = 'cursor()'                            /* set initial value   */\n\"addpop row(2) column(\"poppos\")\"               /* set window          */\n\ndo until disprc > 0\n  display_again = 'N'\n  dynarea = substr(dyndata,1+(cur_line-1)*scrn_wdth) /* set display   */\n  \"display panel(checkasl)\" cursor             /* display result      */\n  disprc = rc\n  \"vget (zverb,zscrolla,zscrolln)\"             /* get ispf values     */\n  select\n    when zverb = 'UP' then\n      do\n        if zscrolla = 'MAX' then cur_line = 1  /* move to top         */\n        else cur_line = max(1,cur_line-zscrolln) /* up x lines        */\n      end\n    when zverb = 'DOWN' then\n      do\n        if zscrolla = 'MAX' then cur_line = maxlines  /* move to bot. */\n        else cur_line = min(maxlines,cur_line+zscrolln) /*down x lines*/\n      end\n    when zcmd = 'AGAIN' & srchfor <> '' then   /* PF5 pressed         */\n      do\n        from_here = start_pos                  /* get search string   */\n        start_pos = pos(srchfor,dyndata,from_here+1) /* search again  */\n        if start_pos <> 0 then call get_position /* if found, display */\n        else call not_found                    /* reset cursor        */\n      end\n    when substr(zcmd,1,1) = 'F' then           /* find a string?      */\n      do\n        parse var zcmd . srchfor               /* get search string   */\n        start_pos = pos(srchfor,dyndata)       /* search for string   */\n        if start_pos <> 0 then call get_position /* if found, display */\n        else call not_found                    /* reset cursor        */\n      end\n    when substr(zcmd,1,1) = 'L' & sort = 'Y' then\n      do\n        \"addpop row(2) column(18)\"             /* start window        */\n        \"display panel(checkact)\"              /* display results     */\n        \"rempop\"                               /* stop window         */\n      end\n    when substr(zcmd,1,1) = 'S' then\n      do\n        \"addpop column(10)\"                    /* Set up sort window  */\n        \"display panel(checksrt)\"              /* Display window      */\n        \"rempop\"                               /* remove window       */\n        display_again = 'Y'                    /* Display again       */\n        cur_line = 1                           /* set to top          */\n        leave                                  /* exit loop           */\n      end\n    when substr(zcmd,1,1) = 'V' then\n      do\n        \"addpop column(10)\"                    /* Set up sort window  */\n        \"display panel(checkvie)\"              /* Display window      */\n        \"rempop\"                               /* remove window       */\n        display_again = 'Y'                    /* display again       */\n        cur_line = 1                           /* set to top          */\n        leave                                  /* exit loop           */\n      end\n    when disprc = 0 then                       /* enter pressed       */\n      do\n        display_again = 'Y'                    /* display again       */\n        leave                                  /* exit loop           */\n      end\n    otherwise\n  end\nend\n\n\"rempop\"                                       /* close window        */\nzpf05 = zpf05_old                              /* reset pf key        */\n\"vput zpf05 profile\"                           /* store PF5 key       */\naddress tso                                    /* set mode            */\n\nreturn\n/*------------------ calculate line position in dynamic area ---------*/\nget_position:\ncur_line = start_pos%scrn_wdth+1               /* get row position    */\ncsrpos = start_pos//scrn_wdth                  /* get column position */\ncursor = 'cursor(dynarea)'                     /* set cursor field    */\n\nreturn\n/*------------------ calculate line position in dynamic area ---------*/\nnot_found:\ncur_line = 1                                   /* set row position    */\ncsrpos  = 1                                    /* set column position */\ncursor = 'cursor()'                            /* set cursor field    */\n\nreturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ASM": {"ttr": 774, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Q\\x01\\x02\\x01\\x7f\\x01\\x02\\x01\\x7f\\x163\\x00\\x1d\\x00\\x1d\\x00\\x00\\xc1\\xe7\\xe2\\xd7\\xf0\\xf0\\xf3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-01-17T00:00:00", "modifydate": "2002-01-17T16:33:51", "lines": 29, "newlines": 29, "modlines": 0, "user": "AXSP003"}, "text": "//your account JCL.\n//ASM      EXEC PGM=ASMA90\n//SYSPRINT DD  SYSOUT=*\n//SYSTERM  DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SYS1.MODGEN\n//         DD  DISP=SHR,DSN=SYS1.MACLIB\n//SYSUT1   DD  UNIT=3390,SPACE=(CYL,(3,1))\n//SYSLIN   DD  DSN=&&OBJ,UNIT=3390,\n//             SPACE=(CYL,(1,1)),DISP=(,PASS)\n//SYSIN    DD  DISP=SHR,DSN=your source dataset(GETUADDR)\n//*\n//LKED     EXEC PGM=IEWL,PARM='LIST,XREF,RENT,REUS,REFR',\n//         COND=(0,NE)\n//SYSPRINT DD  SYSOUT=*\n//SYSLMOD  DD  DISP=SHR,DSN=your ISPLLIB dataset\n//SYSUT1   DD  UNIT=3390,SPACE=(CYL,(3,1))\n//OBJ      DD  DSN=&&OBJ,DISP=(OLD,DELETE)\n//SYSLIN   DD  *\n  INCLUDE OBJ\n  ENTRY GETUADDR\n  NAME GETUADDR(R)\n/*\n//COMPRESS EXEC PGM=IEBCOPY,COND=(0,NE)\n//SYSPRINT DD SYSOUT=*\n//INDD1    DD DISP=SHR,DSN=your ISPLLIB dataset\n//OUTDD1   DD DISP=SHR,DSN=your ISPLLIB dataset\n//SYSIN    DD *\n  COPY OUTDD=OUTDD1,INDD=((INDD1,R))\n/*\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CHECKACT": {"ttr": 776, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": ")attr\n |  type(text) color(green)\n \u00ac  type(text) color(yellow)\n \u20ac  type(text) color(red)\n \u00a2  type(text) color(pink)\n _  type(output) just(right) color(turq)\n \u00a8  type(output) just(right) color(yellow)\n \u00a3  type(output) just(right) color(red)\n \u00e0  type(output) just(right) color(pink)\n \u00b5  type(output) just(right) color(blue)\n \u00a7  type(output) just(right) color(white)\n \u00b0  type(output) just(right) color(green)\n)body window(20,11)\n|System    \u00ac:\u00b5sycnt+\n|STCs      \u00ac:_scnt +\n|OMVS STC  \u00ac:\u00e0ocnt +\n|TSO Users \u00ac:\u00b0tcnt +\n|Batch     \u00ac:\u00b0btcnt+\n|Initiators\u00ac:\u00a7icnt +\n|ASCH Init \u00ac:\u00a7acnt +\n|BPXAS init\u00ac:\u00e0bcnt +\n|Starting  \u00ac:\u00a8stcnt+\n|Unknown   \u00ac:\u00a8ucnt +\n|Total     \u00ac:\u00e0mcnt +\n)init\n&zwinttl = 'Address Space Type'\n)proc\n)end\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CHECKAPF": {"ttr": 778, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\x06O\\x01\\x02\\x06O\\x17\\x03\\x00\\x1b\\x00\\x1b\\x00\\x00\\xc4\\xc2\\xc2\\xd9\\xd6\\xe6\\xd5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-03-05T00:00:00", "modifydate": "2002-03-05T17:03:00", "lines": 27, "newlines": 27, "modlines": 0, "user": "DBBROWN"}, "text": ")ATTR\n |  type(text) color(green)\n \u00ac  type(text) color(yellow)\n \u20ac  type(text) color(red)\n \u00a2  type(text) color(turq)\n \u00a8  type(output) just(left) color(yellow)\n \u00a3  type(output) just(right) color(red)\n \u00b5  type(output) just(right) color(blue)\n \u00a7  type(output) just(right) color(pink)\n \u00b0  type(output) just(right) color(blue)\n 01 type(dataout)  color(red)\n 02 type(dataout)  color(blue)\n 03 type(dataout)  color(green)\n 04 type(dataout)  color(white)\n 05 type(dataout)  color(turq)\n 06 type(dataout)  color(pink)\n 07 type(dataout)  color(yellow)\n \u00e0 area(dynamic) scroll(on) extend(on)\n)body expand(\u00e7\u00e7) window(53,20)\n%Command+===>_zcmd                 %Scroll+===>_amt +\n\u00ac               Dataset Name                  Volser\n\u00e0dynarea                                            \u00e0\n)init\n.csrpos = &csrpos\n&zwinttl = &title\n&zcmd = ' '\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CHECKASL": {"ttr": 780, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\x06O\\x01\\x02\\x06O\\x17\\x03\\x00\\x1f\\x00\\x1f\\x00\\x00\\xc4\\xc2\\xc2\\xd9\\xd6\\xe6\\xd5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-03-05T00:00:00", "modifydate": "2002-03-05T17:03:00", "lines": 31, "newlines": 31, "modlines": 0, "user": "DBBROWN"}, "text": ")attr\n |  type(text) color(green)\n \u00ac  type(text) color(yellow)\n \u20ac  type(text) color(red)\n \u00a2  type(text) color(turq)\n \u00a8  type(output) just(left) color(yellow)\n \u00a3  type(output) just(right) color(red)\n \u00b5  type(output) just(right) color(blue)\n \u00a7  type(output) just(left) color(pink)\n \u00b0  type(output) just(left) color(blue)\n \u00e8  type(output) just(left) color(green)\n \u00e9  type(output) just(left) color(turq)\n 01 type(dataout)  color(red)\n 02 type(dataout)  color(blue)\n 03 type(dataout)  color(green)\n 04 type(dataout)  color(white)\n 05 type(dataout)  color(turq)\n 06 type(dataout)  color(pink)\n 07 type(dataout)  color(yellow)\n \u00e0 area(dynamic)   scroll(on) extend(on)\n)body expand(\u00e7\u00e7) window(64,21)\n%Command+===>_zcmd                            %Scroll+===>_amt +\n+Active\u00ac:\u00a7maxlines+\u20acL+List \u00a2F+xxxx \u20acS+Sort \u20acV+View   +CPU\u00ac:\u00a7cpp|\n\u00acJobname  ASID DP Pos.   CPU    Real      VIO  Non-VIO     Excp.\n\u00e0dynarea                                                       \u00e0\n)init\n.csrpos = &csrpos\n&zwinttl = &title\n&zcmd = ' '\n)reinit\n)end\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CHECKLNK": {"ttr": 782, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\x06O\\x01\\x02\\x06O\\x17\\x03\\x00\\x1d\\x00\\x1d\\x00\\x00\\xc4\\xc2\\xc2\\xd9\\xd6\\xe6\\xd5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-03-05T00:00:00", "modifydate": "2002-03-05T17:03:00", "lines": 29, "newlines": 29, "modlines": 0, "user": "DBBROWN"}, "text": ")attr\n |  type(text) color(green)\n \u00ac  type(text) color(yellow)\n \u20ac  type(text) color(red)\n \u00a2  type(text) color(turq)\n \u00a8  type(output) just(left) color(yellow)\n \u00a3  type(output) just(right) color(red)\n \u00b5  type(output) just(right) color(blue)\n \u00a7  type(output) just(right) color(pink)\n \u00b0  type(output) just(right) color(blue)\n 01 type(dataout)  color(red)\n 02 type(dataout)  color(blue)\n 03 type(dataout)  color(green)\n 04 type(dataout)  color(white)\n 05 type(dataout)  color(turq)\n 06 type(dataout)  color(pink)\n 07 type(dataout)  color(yellow)\n \u00e0 area(dynamic) scroll(on) extend(on)\n)body expand(\u00e7\u00e7) window(57,20)\n%Command+===>_zcmd                    %Scroll+===>_amt +\n\u00ac               Dataset Name                   Volser APF\n\u00e0dynarea                                               \u00e0\n)init\n.csrpos = &csrpos\n&zwinttl = &title\n&zcmd = ' '\n)proc\n&funckey = .pfkey\n)end\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CHECKLPA": {"ttr": 784, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\x06O\\x01\\x02\\x06O\\x17\\x03\\x00\\x1b\\x00\\x1b\\x00\\x00\\xc4\\xc2\\xc2\\xd9\\xd6\\xe6\\xd5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-03-05T00:00:00", "modifydate": "2002-03-05T17:03:00", "lines": 27, "newlines": 27, "modlines": 0, "user": "DBBROWN"}, "text": ")attr\n |  type(text) color(green)\n \u00ac  type(text) color(yellow)\n \u20ac  type(text) color(red)\n \u00a2  type(text) color(turq)\n \u00a8  type(output) just(left) color(yellow)\n \u00a3  type(output) just(right) color(red)\n \u00b5  type(output) just(right) color(blue)\n \u00a7  type(output) just(right) color(pink)\n \u00b0  type(output) just(right) color(blue)\n 01 type(dataout)  color(red)\n 02 type(dataout)  color(blue)\n 03 type(dataout)  color(green)\n 04 type(dataout)  color(white)\n 05 type(dataout)  color(turq)\n 06 type(dataout)  color(pink)\n 07 type(dataout)  color(yellow)\n \u00e0 area(dynamic)   scroll(on) extend(on)\n)body expand(\u00e7\u00e7) window(45,20)\n%Command+===>_zcmd         %Scroll+===>_amt +\n\u00ac               Dataset Name\n\u00e0dynarea                                    \u00e0\n)init\n.csrpos = &csrpos\n&zwinttl = &title\n&zcmd = ' '\n)end\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CHECKMAP": {"ttr": 786, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00%\\x01\\x02\\x01\\x8f\\x01\\x02\\x01\\x8f\\x08C\\x00&\\x00&\\x00\\x00\\xc1\\xe7\\xe2\\xd7\\xf0\\xf0\\xf3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-01-18T00:00:00", "modifydate": "2002-01-18T08:43:25", "lines": 38, "newlines": 38, "modlines": 0, "user": "AXSP003"}, "text": ")attr\n |  type(text) color(green)\n \u00ac  type(text) color(yellow)\n \u20ac  type(text) color(red)\n \u00a2  type(text) color(turq)\n _  type(output) just(left) color(turq)\n \u00a8  type(output) just(left) color(yellow)\n \u00a3  type(output) just(right) color(red)\n \u00e0  type(output) just(right) color(pink)\n \u00b5  type(output) just(right) color(blue)\n \u00a7  type(output) just(right) color(pink)\n \u00b0  type(output) just(right) color(blue)\n)body expand(\u00e7\u00e7) window(48,21)\n|   \u00acStorage Area    Start    End        Size\n|             PSA\u00a3psas     \u00b5psae      \u00e0psak   |K\n|          System\u00a3syss     \u00b5syse      \u00e0sysk   |K\n|     Private V=R\u00a3gblrs    \u00b5gblre     \u00e0gblrk  |K\n|     Private V=V\u00a3privs    \u00b5prive     \u00e0privk  |K\n|             CSA\u00a3csas     \u00b5csae      \u00e0csak   |K\n|            MLPA\u00a3mlpas    \u00b5mlpae     \u00e0mlpak  |K\n|            FLPA\u00a3flpas    \u00b5flpae     \u00e0flpak  |K\n|            PLPA\u00a3plpas    \u00b5plpae     \u00e0plpak  |K\n|             SQA\u00a3sqas     \u00b5sqae      \u00e0sqak   |K\n|     R/W Nucleus\u00a3nucws    \u00b5nucwe     \u00e0nucwk  |K\n|     R/O Nucleus\u00a3nucos    \u00b5nucoe     \u00e0nucok  |K\n\u00a2Ext. R/O Nucleus\u00a3enucos   \u00b5enucoe    \u00e0enucok \u00a2K\n\u00a2Ext. R/W Nucleus\u00a3enucws   \u00b5enucwe    \u00e0enucwk \u00a2K\n\u00a2        Ext. SQA\u00a3esqas    \u00b5esqae     \u00e0esqak  \u00a2K\n\u00a2       Ext. PLPA\u00a3eplpas   \u00b5eplpae    \u00e0eplpak \u00a2K\n\u00a2       Ext. FLPA\u00a3eflpas   \u00b5eflpae    \u00e0eflpak \u00a2K\n\u00a2       Ext. MLPA\u00a3emlpas   \u00b5emlpae    \u00e0emlpak \u00a2K\n\u00a2        Ext. CSA\u00a3ecsas    \u00b5ecsae     \u00e0ecsak  \u00a2K\n\u00a2    Ext. Private\u00a3eprvs    \u00b5eprve     \u00e0eprvk  \u00a2K\n%\u00e7 \u00e7|Press\u20acPF3|to\u00acEnd%\u00e7 \u00e7\n)init\n&zwinttl = &title\n)proc\n)end\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CHECKMNU": {"ttr": 788, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": ")attr\n |  type(text) color(green)\n \u00ac  type(text) color(yellow)\n \u20ac  type(text) color(red)\n \u00a2  type(text) color(pink)\n \u00a8  type(output) just(left) color(yellow)\n \u00a3  type(output) just(right) color(red)\n \u00e0  type(output) just(left) color(pink)\n \u00b5  type(output) just(left) color(blue)\n \u00a7  type(output) just(right) color(pink)\n \u00b0  type(output) just(right) color(blue)\n)body window(39,10)\n%Option+===>_z+\n+\n| Select one of the following options:\n+\n|1\u20ac-\u00acSystem          |5\u20ac-\u00acLPA\n|2\u20ac-\u00acStorage         |6\u20ac-\u00acLink\n|3\u20ac-\u00acStorage Map     |7\u20ac-\u00acAPF\n|4\u20ac-\u00acSoftware Version|8\u20ac-\u00acAddress Space\n+\n|         Press\u20acPF3|to\u00acEnd%\n)init\n&zwinttl = &title\n.zvars='(optn)'\n.cursor=optn\n&optn = ' '\n)proc\n ver (&optn,range,1,9)\n)end\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CHECKSRT": {"ttr": 1025, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": ")attr\n |  type(text) color(green) skip(on)\n \u00ac  type(text) color(yellow)\n \u20ac  type(text) color(red)\n \u00a2  type(text) color(turq)\n \u00a8  type(output) just(left) color(yellow)\n \u00a3  type(output) just(right) color(red)\n \u00b5  type(output) just(right) color(blue)\n \u00a7  type(output) just(right) color(pink)\n \u00b0  type(output) just(right) color(blue)\n)body window(21,12)\n% Option+==>_Z|\n+\n|1\u20ac-\u00acSort by Jobname\n|2\u20ac-\u00acSort by ASID\n|3\u20ac-\u00acSort by Dispatch\n|4\u20ac-\u00acSort by CPU Time\n|5\u20ac-\u00acSort by Real\n|6\u20ac-\u00acSort by VIO\n|7\u20ac-\u00acSort by Non-VIO\n|8\u20ac-\u00acSort by Excp.\n+\n% Type+==>_Z|(A/D)\n)init\n.zvars = '(soptn sorder)'\n.cursor = soptn\n&zwinttl = 'Sort Options'\n&soptn = '1'\n&sorder = 'D'\n)proc\nver (&sorder,nb,list,A,D)\nver (&soptn,nb,range,1,8)\n&sfld = trans(&soptn 1,2\n                     2,11\n                     3,16\n                     4,22\n                     5,32\n                     6,38\n                     7,47\n                     8,56)\n&slen = trans(&soptn 1,8\n                     2,3\n                     3,2\n                     4,9\n                     5,5\n                     6,8\n                     7,8\n                     8,8)\n)end\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CHECKSTM": {"ttr": 1027, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00H\\x01\\x02\\x01\\x7f\\x01\\x02\\x01\\x7f\\x11\\x05\\x00%\\x00%\\x00\\x00\\xc1\\xe7\\xe2\\xd7\\xf0\\xf0\\xf3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-01-17T00:00:00", "modifydate": "2002-01-17T11:05:48", "lines": 37, "newlines": 37, "modlines": 0, "user": "AXSP003"}, "text": ")attr\n |  type(text) color(green)\n \u00ac  type(text) color(yellow)\n \u20ac  type(text) color(red)\n \u00a2  type(text) color(pink)\n _  type(output) just(left) color(turq)\n \u00a8  type(output) just(left) color(yellow)\n \u00a3  type(output) just(right) color(red)\n \u00e0  type(output) just(left) color(pink)\n \u00b5  type(output) just(left) color(blue)\n \u00a7  type(output) just(right) color(pink)\n \u00b0  type(output) just(right) color(blue)\n)body expand(//) window(65,20)\n|IPL Date \u00a3ddd|          |IPL Time   SYSR1   Addr.  SYSR2  Addr.\n\u00a8iplday   \u00a8ipldate       \u00b5ipltime   \u00e0sysres _saddr \u00e0sysrs2_saddr2\n|\n|IPL Dataset               IPL Parm.     Volser       Addr.\n\u00a8ipln                     \u00b5ipll         \u00e0iplv        _iplu\n|\n|HCD Dataset        EDT    Volser   Addr.   SYMxx       SYSxx\n\u00a8hcdn              \u00b5edt   \u00e0hcdv    _hcdu   \u00b5symsf      \u00b5syssf\n|\n|Master Catalog                    Volser        Addr.\n\u00a8mcat                             \u00e0mvol         _maddr\n|\n|Parmlib DSN                       Volser        Addr.\n\u00a8pdsn                             \u00e0pvol         _paddr\n|\n|CPU Model  Online                 Real          Expanded\n\u00b5cpu          \u00a8cpuno|          \u00b0realm +M       \u00a7xpand \u00a2M\n|CPU Id's  \u00a8cpu1   \u00a8cpu2   \u00a8cpu3   \u00a8cpu4   \u00a8cpu5\n|          \u00a8cpu6   \u00a8cpu7   \u00a8cpu8   \u00a8cpu9   \u00a8cpu10\n%/ /|Press\u20acPF3|to\u00acEnd%/ /\n)init\n&zwinttl = &title\n)proc\n)end\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CHECKSTR": {"ttr": 1029, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\"\\x01\\x02\\x01\\x7f\\x01\\x02\\x01\\x7f\\x11\\t\\x00\\x1e\\x00\\x1e\\x00\\x00\\xc1\\xe7\\xe2\\xd7\\xf0\\xf0\\xf3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-01-17T00:00:00", "modifydate": "2002-01-17T11:09:22", "lines": 30, "newlines": 30, "modlines": 0, "user": "AXSP003"}, "text": ")attr\n |  type(text) color(green)\n \u00ac  type(text) color(yellow)\n \u20ac  type(text) color(red)\n \u00a2  type(text) color(pink)\n _  type(output) just(left) color(turq)\n \u00a8  type(output) just(left) color(yellow)\n \u00a3  type(output) just(right) color(red)\n \u00e0  type(output) just(left) color(pink)\n \u00b5  type(output) just(left) color(blue)\n \u00a7  type(output) just(right) color(pink)\n \u00b0  type(output) just(right) color(blue)\n)body expand(//) window(65,13)\n|CSA size        Ext. CSA          SQA size         Ext. SQA\n\u00b0csaf  +M       \u00a7ecsaf \u00a2M         \u00b0sqaf  +M        \u00a7esqaf \u00a2M\n|\n|CSA used        ECSA used         SQA used         ESQA used\n\u00a3csauf   +      \u00a3ecsauf  +           \u00e0sqauf +         \u00e0esqauf +\n|\n|Private region  Ext. Private      CSA overflow     ECSA overflow\n\u00b0privf +M        \u00a7eprvf   \u00a2M    \u00a3csaof   \u20acM      \u00a3ecsaof  \u20acM\n|\n|Slots Max.    Free       Init.      Re-useable    Max. User\n| _maxu +     \u00a3sltf+    \u00a7slti+      \u00b0sltn +         \u00a8maxo +\n|\n%/ /|Press\u20acPF3|to\u00acEnd%/ /\n)init\n&zwinttl = &title\n)proc\n)end\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CHECKSYS": {"ttr": 1031, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\x06O\\x01\\x02\\x06O\\x17\\x03\\x03\\xda\\x03\\xda\\x00\\x00\\xc4\\xc2\\xc2\\xd9\\xd6\\xe6\\xd5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-03-05T00:00:00", "modifydate": "2002-03-05T17:03:00", "lines": 986, "newlines": 986, "modlines": 0, "user": "DBBROWN"}, "text": "/* REXX */\n/**********************************************************************/\n/* this routine gets system information - version 1.1                 */\n/**********************************************************************/\n/*------------------ initialize global variables ---------------------*/\ntrace 0\narg optn\naddress tso                                    /* set mode            */\nnumeric digits 30                              /* set decimal size    */\ncvt = c2d(storage(10,4))                       /* point to cvt        */\necvt = c2d(storage(d2x(cvt+140),4))            /* point to cvtecvt    */\nsysn = mvsvar('SYSNAME')                       /* get sysname         */\nred   = '01'x                                  /* set colour          */\nblue  = '02'x                                  /* attributes fo the   */\ngreen = '03'x                                  /* dynamic display     */\nwhite = '04'x                                  /* area                */\nturq  = '05'x                                  /*                     */\npink  = '06'x                                  /*                     */\nyellow = '07'x                                 /*                     */\n/*--------------------- select an option -----------------------------*/\nif optn <> '' then                             /* no string passed    */\n  do\n    select\n      when optn = 'SYS' | optn = 1 then call system\n      when optn = 'STR' | optn = 2 then call storeuse\n      when optn = 'MAP' | optn = 3 then call storemap\n      when optn = 'VER' | optn = 4 then call softver\n      when optn = 'LPA' | optn = 5 then call lpalist\n      when optn = 'LNK' | optn = 6 then call lnklist\n      when optn = 'APF' | optn = 7 then call apflist\n      when optn = 'ASL' | optn = 8 then call asllist\n      otherwise call mainmenu                  /* display main menu   */\n    end\n  end\nelse\n  do forever\n    call mainmenu                              /* display main menu   */\n    select\n      when optn = 1 then call system\n      when optn = 2 then call storeuse\n      when optn = 3 then call storemap\n      when optn = 4 then call softver\n      when optn = 5 then call lpalist\n      when optn = 6 then call lnklist\n      when optn = 7 then call apflist\n      when optn = 8 then call asllist\n      otherwise exit                           /* end of the program  */\n    end\n  end\n\nexit                                           /* end of the program  */\n/*--------------------- display primary panel ------------------------*/\nmainmenu:\naddress ispexec\ntitle = ' System Information on 'sysn          /* set display title   */\n\n\"addpop row(2) column(12)\"                     /* start window        */\n\"display panel(checkmnu)\"                      /* display results     */\n\"rempop\"                                       /* stop window         */\n\nreturn\n/****************************** Option 1 ******************************/\n/*------------------ calculate and display system info ---------------*/\n/**********************************************************************/\nsystem:\naddress tso                                    /* set mode            */\nsort = 'N'                                     /* don't allow sorting */\ntitle = ' System Information '                 /* set display title   */\ncall get_cpu_info\ncall get_ipl_time\ncall get_ipl_info\ncall get_iodf_dsn\ncall get_sysres\ncall get_unit_addr\ncall get_volser\ncall get_real_storage\naddress ispexec                                /* set mode            */\n\"addpop row(2) column(2)\"                      /* start window        */\n\ndo until rc > 0\n  \"display panel(checkstm)\"                    /* display results     */\nend\n\n\"rempop\"                                       /* stop window         */\naddress tso                                    /* set mode            */\n\nreturn\n/*---------------- get IPL time --------------------------------------*/\nget_ipl_time:\ncvtsmca = c2d(storage(d2x(cvt+196),4))         /* point to cvtsmca    */\nipltime = c2d(storage(d2x(cvtsmca+336),4))     /* point to smcaitme   */\n/* ------- convert time from hundreds of seconds to hh:mm:ss -------- */\nipltime = ipltime%100                          /* remove 100's        */\niplhrs = ipltime%3600                          /* calculate hours     */\niplhrs = right(iplhrs,2,'0')                   /* add leading zero    */\nipltime = ipltime//3600                        /* calculate minutes   */\niplmin = ipltime%60                            /* decimal convertion  */\niplmin = right(iplmin,2,'0')                   /* add leading zero    */\niplsec = ipltime//60                           /* calculate seconds   */\niplsec = right(iplsec,2,'0')                   /* add leading zero    */\nipltime= iplhrs':'iplmin':'iplsec              /* build string        */\n/* ------- convert julian days to day of the week ------------------- */\nipldate = c2x(storage(d2x(cvtsmca+340),4))     /* point to smcaidte   */\nparse var ipldate . 3 yy 5 ddd 8 .             /* strip out year, day */\njuldate = yy||ddd                              /* build julain date   */\nipldate = date(,''juldate'','j')               /* Get the date        */\niplday  = date(w,''juldate'','j')              /* Get the day         */\n\nreturn\n/*---------------- get IPL info --------------------------------------*/\nget_ipl_info:\nihaipa = c2d(storage(d2x(ecvt+392),4))         /* point to ecvtipa    */\nipll = storage(d2x(ihaipa+16),8)               /* ipl load parameters */\nhcdu = storage(d2x(ihaipa+16),4)               /* hcd unit address    */\nhcdm = storage(d2x(ihaipa+20),2)               /* hcd load member     */\nlpar = storage(d2x(ihaipa+32),8)               /* lpar name           */\nipld = strip(storage(d2x(ihaipa+48),44))       /* ipl parm DSN        */\niplu = storage(d2x(ihaipa+92),4)               /* ipl load parm addr. */\nhcds = storage(d2x(ihaipa+96),2)               /* iodf suffix         */\nhcdq = storage(d2x(ihaipa+99),8)               /* hcd hi-level qual.  */\nsyssf = strip(storage(d2x(ihaipa+160),2))      /* ieasysxx suffixes   */\nmvol = storage(d2x(ihaipa+224),6)              /* mcat volser         */\nmcat = storage(d2x(ihaipa+234),44)             /* master catalog name */\nsymsf = strip(storage(d2x(ihaipa+288),63))     /* ieasymxx suffixes   */\npdsn = strip(storage(d2x(ihaipa+416),44))      /* parmlib dsn         */\npvol = storage(d2x(ihaipa+461),6)              /* parmlib volser      */\nipln = ipld'(LOAD'hcdm')'                      /* build iplparm dsn   */\n\nreturn\n/*---------------- get IODF DSN --------------------------------------*/\nget_iodf_dsn:\ncvtixavl = c2d(storage(d2x(cvt+124),4))        /* point to cvtixavl   */\niociovtp = c2d(storage(d2x(cvtixavl+208),4))   /* point to iociovtp   */\nhcdn   = strip(storage(d2x(iociovtp+288),15))  /* point to iodf name  */\ncda      = c2d(storage(d2x(iociovtp+24),4))    /* point to cda        */\nhcdn     = strip(storage(d2x(cda+32),15))      /* point to iodf name  */\nconfigid = storage(d2x(cda+92),8)              /* point to config     */\nedt      = storage(d2x(cda+104),2)             /* point to edt        */\n\nreturn\n/*--------------------- get the sysres volser ------------------------*/\nget_sysres:\nucb    = c2d(storage(d2x(cvt+48),4))           /* point to cvtsmca    */\nsysres = storage(d2x(ucb+28),6)                /* sysres volume       */\nsysrs2 = mvsvar('symdef','sysr2')              /* get second sysres   */\n\nif sysrs2 = '' then sysrs2 = '-none-'          /* no second sysres    */\n\nreturn\n/*---------------- get the unit address ------------------------------*/\nget_unit_addr:\nsaddr = getucb(sysres)                         /* sysres device no.   */\n\nif sysrs2 \u00ac= '-none-' then saddr2 = getucb(sysrs2) /* no second sysres*/\n\npaddr = getucb(pvol)                           /* parmlib device no.  */\nmaddr = getucb(mvol)                           /* mcat   device no.   */\n\nreturn\n/*----------------------- get the volser -----------------------------*/\nget_volser:\niplv = getvol(iplu)                            /* iplparm volser      */\nhcdv = getvol(hcdu)                            /* iodf volser         */\n\nreturn\n/*---------------- get numbers of cpu's ------------------------------*/\nget_cpu_info:\ncvtscpin = c2d(storage(d2x(cvt+832),4))        /* point to cvtscpin   */\ncpuno = c2d(storage(d2x(cvtscpin+16),2))       /*  get no. of cpu's   */\n/*---------------- get cpu info --------------------------------------*/\ncvthid = c2d(storage(d2x(cvt+1068),4))         /* point to cvthid     */\ncputype = strip(storage(d2x(cvthid+28),4))     /* get cpu type        */\ncpumod = strip(storage(d2x(cvthid+32),3))      /* get cpu model       */\ncpu = cputype'-'cpumod\n/*---------------- set up cpu display fields -------------------------*/\nx = syscpus('cpuid.')\n\ndo cntr = 1 to cpuid.0                         /* pack cpu id. into   */\n  temp_var_name = 'cpu'||cntr                  /* display string      */\n  interpret temp_var_name '= substr(cpuid.cntr,3,6)'\nend\n\nreturn\n/*---------------- get storage values --------------------------------*/\nget_real_storage:\ncvtrlstg = c2d(storage(d2x(cvt+856),4))        /* point to cvtrlstg   */\nrealm  = cvtrlstg/1024                         /* convert to MB.      */\ncvtrcep = c2d(storage(d2x(cvt+1168),4))        /* point to cvtrcep    */\nxpand  = c2d(storage(d2x(cvtrcep+160),4))      /* no. expanded stor.  */\nxpand  = xpand*4/1024                          /* convert to MB.      */\n\nreturn\n/*--------------------- get device number from UCB -------------------*/\ngetucb: procedure expose vol dnum\narg vol                                        /* get volume name     */\ndnum = '0000'                                  /* initilaize device   */\naddress LINKPGM \"GETUADDR vol dnum\"            /* call program        */\nreturn dnum\n/*--------------------- get volser from UCB --------------------------*/\ngetvol: procedure expose vol dnum\narg dnum                                       /* get device address  */\nvol= 'XXXXXX'                                  /* initilaize volser   */\naddress LINKPGM \"GETUADDR vol dnum\"            /* call program        */\nreturn vol\n/****************************** Option 2 ******************************/\n/*------------------ calculate and display storage useage ------------*/\n/**********************************************************************/\nstoreuse:\naddress tso                                    /* set mode            */\nsort = 'N'                                     /* don't allow sorting */\ntitle = ' Storage Usage '                      /* set display title   */\ncall set_default\ncall get_storage_use\ncall get_slots\naddress ispexec                                /* set mode            */\n\"addpop row(2) column(2)\"                      /* start window        */\n\ndo until rc > 0\n  \"display panel(checkstr)\"                    /* display results     */\nend\n\n\"rempop\"                                       /* stop window         */\naddress tso                                    /* set mode            */\n\nreturn\n/*---------------- get available 'slots' -----------------------------*/\nget_slots:\ncvtasvt = c2d(storage(d2x(cvt+556),4))         /* point to cvtasvt    */\nsltf = c2d(storage(d2x(cvtasvt+480),4))        /* # slots free        */\nslti = c2d(storage(d2x(cvtasvt+484),4))        /* # slots initial     */\nsltn = c2d(storage(d2x(cvtasvt+488),4))        /* # slots not reusable*/\nmaxo = c2d(storage(d2x(cvtasvt+500),4))        /* # slots orginally   */\nmaxu = c2d(storage(d2x(cvtasvt+516),4))        /* # slots available   */\n\nreturn\n/****************************** Option 3 ******************************/\n/*------------------ calculate and display storage map ---------------*/\n/**********************************************************************/\nstoremap:\naddress tso                                    /* set mode            */\nsort = 'N'                                     /* don't allow sorting */\ntitle = ' Storage Map '                        /* set display title   */\ncall set_default\ncall get_storage_use\ncall get_storage_map\naddress ispexec                                /* set mode            */\n\"addpop row(2) column(10)\"                     /* start window        */\n\ndo until rc > 0\n  \"display panel(checkmap)\"                    /* display results     */\nend\n\n\"rempop\"                                       /* stop window         */\naddress tso                                    /* set mode            */\n\nreturn\n/*---------------- get storage allocation ----------------------------*/\nget_storage_map:\ncvtgda = c2d(storage(d2x(cvt+560),4))          /* point to cvtgda     */\ncsas  = strip(c2x(storage(d2x(cvtgda+108),4)),'l',0) /* start of csa  */\ncsa   = strip(c2x(storage(d2x(cvtgda+112),4)),'l',0) /* csa size      */\ncsak  = x2d(csa)/1024                                /* convert to K. */\ncsae  = d2x(x2d(csa)+x2d(csas)-1)                    /* end of csa    */\necsas = strip(c2x(storage(d2x(cvtgda+124),4)),'l',0) /* start of ecsa */\necsa  = strip(c2x(storage(d2x(cvtgda+128),4)),'l',0) /* ex. csa size  */\necsak = x2d(ecsa)/1024                               /* convert to K. */\necsae = d2x(x2d(ecsa)+x2d(ecsas)-1)                  /* end of ecsa   */\nsqas  = strip(c2x(storage(d2x(cvtgda+144),4)),'l',0) /* start of sqa  */\nsqa   = strip(c2x(storage(d2x(cvtgda+148),4)),'l',0) /* sqa size *    */\nsqak  = x2d(sqa)/1024                                /* convert to K. */\nsqae  = d2x(x2d(sqa)+x2d(sqas)-1)                    /* end of sqa    */\nesqas = strip(c2x(storage(d2x(cvtgda+152),4)),'l',0) /* start of esqa */\nesqa  = strip(c2x(storage(d2x(cvtgda+156),4)),'l',0) /* ex. esqa size */\nesqak = x2d(esqa)/1024                               /* convert to K. */\nesqae = d2x(x2d(esqa)+x2d(esqas)-1)                  /* end of esqa   */\npriv  = strip(c2x(storage(d2x(cvtgda+164),4)),'l',0) /* priv.  size   */\nprivk = x2d(priv)/1024                               /* convert to K. */\nprive = d2x(20480+((privk-20)*1024)-1)               /* end of priv.  */\neprvs = strip(c2x(storage(d2x(cvtgda+168),4)),'l',0) /* start of eprv.*/\neprv  = strip(c2x(storage(d2x(cvtgda+172),4)),'l',0) /* epriv. size   */\neprvk = x2d(eprv)/1024                               /* convert to K. */\neprve = d2x(x2d(eprv)+x2d(eprvs)-1)                  /* end of epriv. */\ngblr  = strip(c2x(storage(d2x(cvtgda+196),4)),'l',0) /* size v=r gbl. */\ngblrk = x2d(gblr)/1024                               /* convert to K. */\ngblre = d2x(20480+x2d(gblr)-1)                       /* end of global */\ncvtsmext = c2d(storage(d2x(cvt+1196),4))           /* pnt to cvtsmext */\nmlpas  = strip(c2x(storage(d2x(cvtsmext+8),4)),'l',0) /*start of mlpa */\n\nif mlpas <> 0 then                             /* mlpa in use         */\n  do\n    mlpae = strip(c2x(storage(d2x(cvtsmext+12),4)),'l',0)\n    mlpak = (x2d(mlpae)-x2d(mlpas)+1)/1024     /* calc and convert    */\n  end\nelse                                           /* no mlpa             */\n  do\n    mplas = '  n/a   '\n    mlpae = '  n/a   '\n    mlpak = 0\n  end\n\nflpas = strip(c2x(storage(d2x(cvtsmext+16),4)),'l',0) /*start of flpa */\n\nif flpas <> 0 then                             /* flpa in use         */\n  do\n    flpae = strip(c2x(storage(d2x(cvtsmext+20),4)),'l',0)\n    flpak = (x2d(flpae)-x2d(flpas)+1)/1024     /* calc and convert    */\n  end\nelse                                           /* no flpa             */\n  do\n    fplas = '  n/a   '\n    flpae = '  n/a   '\n    flpak = 0\n  end\n\nplpas = strip(c2x(storage(d2x(cvtsmext+24),4)),'l',0) /*start of plpa */\nplpae = strip(c2x(storage(d2x(cvtsmext+28),4)),'l',0) /* end of plpa  */\nplpak = (x2d(plpae)-x2d(plpas)+1)/1024               /* calc and conv */\nnucws = strip(c2x(storage(d2x(cvtsmext+32),4)),'l',0) /* start of r/w */\nnucwe = strip(c2x(storage(d2x(cvtsmext+36),4)),'l',0) /* end of r/w   */\nnucwk = (x2d(nucwe)-x2d(nucws)+1)/1024               /* calc and conv */\nnucwk = format(nucwk,,0)                             /* tidy up size  */\nnucos = strip(c2x(storage(d2x(cvtsmext+40),4)),'l',0) /*start of flpa */\nnucok = (x2d('ffffff')-x2d(nucos)+1)/1024            /* calc and conv */\nenucoe = strip(c2x(storage(d2x(cvtsmext+44),4)),'l',0) /* end of r/o  */\nenucok = X2d(enucoe)-X2d('1000000')+1                /* calc and conv */\nenucok = Format(enucok/1024,,0)                      /* tidy up size  */\nenucws = strip(c2x(storage(d2x(cvtsmext+48),4)),'l',0) /* str e-r/w   */\nenucwe = strip(c2x(storage(d2x(cvtsmext+52),4)),'l',0) /* end e-r/w   */\nenucwk = (x2d(enucwe)-x2d(enucws)+1)/1024            /* calc and conv */\nenucwk = format(enucwk,,0)                           /* tidy up size  */\neplpas = strip(c2x(storage(d2x(cvtsmext+56),4)),'l',0) /*str of eplpa */\neplpae = strip(c2x(storage(d2x(cvtsmext+60),4)),'l',0) /*end of eplpa */\neplpak = (x2d(eplpae)-x2d(eplpas)+1)/1024            /* calc and conv */\neflpas = strip(c2x(storage(d2x(cvtsmext+64),4)),'l',0) /*str of eflpa */\n\nif eflpas <> 0 then                            /* ext. flpa in use    */\n  do\n    eflpae = strip(c2x(storage(d2x(cvtsmext+68),4)),'l',0)\n    eflpak = (x2d(eflpae)-x2d(eflpas)+1)/1024  /* calc and convert    */\n  end\nelse                                           /* no ext. flpa        */\n  do\n    efplas = '  n/a   '\n    eflpae = '  n/a   '\n    eflpak = 0\n  end\n\nemlpas = strip(c2x(storage(d2x(cvtsmext+72),4)),'l',0) /* str emlpa   */\n\nif emlpas <> 0 then                            /* ext. mlpa in use    */\n  do\n    emlpae = strip(c2x(storage(d2x(cvtsmext+76),4)),'l',0)\n    emlpak = (x2d(emlpae)-x2d(emlpas)+1)/1024  /* calc and convert    */\n  end\nelse                                           /* no ext. mlpa        */\n  do\n    emplas = '  n/a   '\n    emlpae = '  n/a   '\n    emlpak = 0\n  end\n\nreturn\n/****************************** Option 4 ******************************/\n/*------------------ calculate and display software version ----------*/\n/**********************************************************************/\nsoftver:\naddress tso                                    /* set mode            */\nsort = 'N'                                     /* don't allow sorting */\ntitle = ' Version Information '                /* set display title   */\n\ncall get_sysvar\ncall get_vtam\ncall get_dfa\ncall get_ispf\naddress ispexec                                /* set mode            */\n\"addpop row(2) column(6)\"                      /* start window        */\n\ndo until rc > 0\n  \"display panel(checkver)\"                    /* display results     */\nend\n\n\"rempop\"                                       /* stop window         */\naddress tso                                    /* set mode            */\n\nreturn\n/*--------------------- get system variable information --------------*/\nget_sysvar:\nosysd = mvsvar('sysopsys')                     /* get OS level        */\nosys1 = substr(osysd,1,6)                      /* format              */\nosys2 = substr(osysd,8,8)\nosysv = osys1' 'osys2\nfmid = substr(osysd,17,7)                      /* get FMID level      */\njesd = sysvar('sysjes')                        /* format              */\njesv = substr(jesd,9,8)\ndfpv = substr(mvsvar('sysdfp'),4,8)\nhsm  = sysvar('syshsm')                        /* get HSM level       */\nhsml = right(substr(hsm,1,1),2,0)              /* format              */\nhsmr = substr(hsm,2,2)\nhsmm = right(substr(hsm,4,1),2,0)\nhsmv = hsml'.'hsmr'.'hsmm\nracf = sysvar('syslracf')                      /* get RACF level      */\nracfl = right(substr(racf,1,1),2,0)            /* format              */\nracfr = substr(racf,2,2)\nracfm = right(substr(racf,4,1),2,0)\nracfv = racfl'.'racfr'.'racfm\ntso  = sysvar('systsoe')                       /* get TSO level       */\ntsol = right(substr(tso,1,1),2,0)              /* format              */\ntsor = substr(racf,2,2)\ntsom = right(substr(tso,4,1),2,0)\ntsov = tsol'.'tsor'.'tsom\nsmfid = mvsvar('syssmfid')                     /* get SMFID           */\nsplx = mvsvar('sysplex')                       /* get Sysplex Id.     */\nmvs = mvsvar('sysmvs')                         /* get MVS level       */\n\nreturn\n/*---------------- get the vtam version and release ------------------*/\nget_vtam:\natcvt = c2d(storage(408,4))                    /* point to atcvt      */\nvtamr = storage(d2x(atcvt+2),1)                /* get vtam version    */\nvtaml = storage(d2x(atcvt+3),1)                /* get vtam release    */\nvtamv = vtamr'.'vtaml                          /* build display       */\n\nreturn\n/*---------------- get dfa version------------------------------------*/\nget_dfa:\ncvtdfa  = c2d(storage(d2x(cvt+1216),4))        /* get cvtdfa address  */\ndfaprod = c2x(storage(d2x(cvtdfa+16),1))       /* product type        */\ndfaver  = c2x(storage(d2x(cvtdfa+17),1))       /* version             */\ndfarlse = c2x(storage(d2x(cvtdfa+18),1))       /* release             */\ndfamod  = c2x(storage(d2x(cvtdfa+19),1))       /* modification        */\n\nif dfamod = '' then dfamod = 0                 /* add modification    */\n\ndfsms = dfaver'.'dfarlse'.'dfamod              /* build display       */\n\nreturn\n/*----------------------- get the ispf level -------------------------*/\nget_ispf:\naddress ispexec                                /* set mode            */\nvget ZENVIR                                    /* get ispf version    */\nispfv = substr(ZENVIR,6,3)                     /* build display       */\ndrop ZENVIR                                    /* drop ispf variable  */\naddress tso                                    /* reset mode          */\n\nreturn\n/****************************** Option 5 ******************************/\n/*--------------------- get lpa list ---------------------------------*/\n/**********************************************************************/\nlpalist:\naddress tso                                    /* set mode            */\nsort = 'N'                                     /* don't allow sorting */\ncur_line = 1                                   /* first row           */\ncsrpos  = 1                                    /* first character     */\npoppos  = 10                                   /* start pos. for pop  */\nscrn_wdth = 45                                 /* set screen width    */\npanel_name = checklpa                          /* set panel name      */\ncvtsmext = c2d(storage(d2x(cvt+1196),4))       /* point to cvtsmext   */\ncvteplps = c2d(storage(d2x(cvtsmext+56),4))    /* point to cvteplps   */\nmaxlines = c2d(storage(d2x(cvteplps+4),4))     /* number of entries   */\nlpatntry = cvteplps+9                          /* point to first dsn  */\n\ndo inc = 1 for maxlines\n  lpadsn = storage(d2x(lpatntry),44)           /* get the lpa dsn     */\n  lpatntry = lpatntry+45                       /* increment the pntr  */\n  line.inc = green||lpadsn                     /* build display str.  */\nend\n\ntitle = maxlines' LPA Datasets '               /* set display title   */\ncall display_list                              /* display results     */\n\nreturn\n/****************************** Option 6 ******************************/\n/*--------------------- get link list --------------------------------*/\n/**********************************************************************/\nlnklist:\naddress tso                                    /* set mode            */\nsort = 'N'                                     /* don't allow sorting */\ncur_line = 1                                   /* first row           */\ncsrpos  = 1                                    /* first character     */\npoppos  = 6                                    /* start pos. for pop  */\nscrn_wdth = 56                                 /* set screen width    */\npanel_name = checklnk                          /* set panel name      */\nascb = c2d(storage(224,4))                     /* point to ascb       */\nassb = c2d(storage(d2x(ascb+336),4))           /* point to assb       */\ndlcb = c2d(storage(d2x(assb+236),4))           /* point to dlcb       */\nlnkname = strip(storage(d2x(dlcb+36),16),t)    /* lnklst set name     */\ncvtllta = c2d(storage(d2x(dlcb+16),4))         /* point to cvtllta    */\nlltx = c2d(storage(d2x(dlcb+20),4))            /* point to lltx       */\nmaxlines = c2d(storage(d2x(cvtllta+4),4))      /* number of entry     */\nlltapftb = cvtllta + 8 + (maxlines * 45)       /* first entry         */\nlnkoff = 8                                     /* offset for dsn      */\nvoloff = 8                                     /* offset for vol      */\napfoff = 0                                     /* offset for apf      */\n\ndo inc = 1 to maxlines\n  len = c2d(storage(d2x(cvtllta+lnkoff),1))    /* length of entry     */\n  lnkdsn = storage(d2x(cvtllta+lnkoff+1),len)  /* get the dsn         */\n  lnkvol = storage(d2x(lltx+voloff),6)         /* get the volser      */\n  apflag = storage(d2x(lltapftb+apfoff),1)     /* check apf flag      */\n  if bitand(apflag,'80'x) = '80'x then dsnapf = 'Y' /* apf flag on    */\n  else dsnapf = ' '                            /* apf flag off        */\n  lnkoff = lnkoff + 45                         /* incr. lnkoff        */\n  voloff = voloff + 8                          /* incr. voloff        */\n  apfoff = apfoff + 1                          /* incr. apfoff        */\n  line.inc = green||left(lnkdsn,45)||blue||left(lnkvol||' ',\n             ||red||dsnapf,9)\nend\n\ntitle = maxlines' LinkList Datasets in 'lnkname\ncall display_list                              /* display results     */\n\nreturn\n/****************************** Option 7 ******************************/\n/*--------------------- get apf list ---------------------------------*/\n/**********************************************************************/\napflist:\naddress tso                                    /* set mode            */\nsort = 'N'                                     /* don't allow sorting */\ncur_line = 1                                   /* first row           */\ncsrpos  = 1                                    /* first character     */\npoppos  = 8                                    /* start pos. for pop  */\nscrn_wdth = 53                                 /* set screen width    */\npanel_name = checkapf                          /* set panel name      */\n\ncvtauthl = c2d(storage(d2x(cvt+484),4))        /* point to cvtauthl   */\n\nif cvtauthl <> c2d('7ffff001'x) then           /* dynamic list ?      */\n  do\n    maxlines = c2d(storage(d2x(cvtauthl),2))   /* \u00a3 apf in table      */\n    apfoff   = 2                               /* first in apf tbl    */\n    do inc = 1 to maxlines\n       len = c2d(storage(d2x(cvtauthl+apfoff),1))  /* length of entry */\n       apfvol = storage(d2x(cvtauthl+apfoff+1),6)  /* apf volser      */\n       apfdsn = storage(d2x(cvtauthl+apfoff+1+6),len-6) /* apf dsn    */\n       apfoff = apfoff+len+1                   /* set apf offset      */\n       line.inc = green||left(apfdsn,45)||blue||apfvol\n    end\n  end\nelse\n  do\n    ecvtcsvt = c2d(storage(d2x(ecvt+228),4))   /* point to ecvtcsvt   */\n    apfa = c2d(storage(d2x(ecvtcsvt+12),4))    /* addr start of list  */\n    apht = c2d(storage(d2x(apfa+8),4))         /* addr 1st entry      */\n    last = c2d(storage(d2x(apfa+12),4))        /* addr last entry     */\n    apf. = ''\n    inc = 0\n    do forever\n      apfdsn = storage(d2x(apht+24),44)        /* apf dataset name    */\n      if substr(apfdsn,1,1) \u00ac= '00'x then      /* 00 = deleted        */\n        do\n          apfesms = storage(d2x(apht+4),1)     /* sms flag            */\n          if  bitand(apfesms,'80'x)  = '80'x then apfvol = '*SMS* '\n          else apfvol = storage(d2x(apht+68),6)   /* apf volser       */\n          line.inc =green||left(apfdsn,45)||blue||apfvol\n          inc = inc + 1\n        end\n      if apht = last then leave\n      else apht = c2d(storage(d2x(apht+8),4))  /* addr next entry     */\n    end\n    maxlines = inc - 1\n  end                                          /* set maximum lines   */\n\ntitle = maxlines' APF Datasets '               /* set display title   */\ncall display_list                              /* display results     */\n\nreturn\n/****************************** Option 8 ******************************/\n/*--------------------- get address space list -----------------------*/\n/**********************************************************************/\nasllist:\naddress tso                                    /* set mode            */\nsort = 'Y'                                     /* allow sorting       */\ncur_line = 1                                   /* first row           */\ncsrpos  = 1                                    /* first character     */\npoppos  = 3                                    /* start pos. for pop  */\ndisplay_again = 'Y'                            /* display once        */\nscrn_wdth = 64                                 /* set screen width    */\npanel_name = checkasl                          /* set panel name      */\nsfld = 2                                       /* sort on first field */\nsfld = 2                                       /* sort on first field */\nslen = 8                                       /* length of field     */\nsorder = 'A'                                   /* sort type           */\nvfld = 'ALL'                                   /* view selection flag */\nvdis = 'All'                                   /* view selection flag */\ncvtasvt = c2d(storage(d2x(cvt+556),4))         /* point to cvtasvt    */\nasvtmaxu = c2d(storage(d2x(cvtasvt+516),4))    /* \u00a3 slots available   */\n\ndo until display_again = 'N'                  /* until PF3 is pressed */\n  inc = 1                                      /* at least once       */\n  acnt = 0                                     /*                     */\n  bcnt = 0                                     /*                     */\n  btcnt = 0                                    /* initialize          */\n  icnt = 0                                     /* counters            */\n  ocnt = 0                                     /* for all active      */\n  scnt = 0                                     /* address spaces      */\n  stcnt = 0                                    /*                     */\n  sycnt = 0                                    /*                     */\n  tcnt = 0                                     /*                     */\n  ucnt = 0                                     /*                     */\n  inc = 1                                      /* at least once       */\n/*---------------- get the cpu percentage ----------------------------*/\n  srmt = c2d(storage((d2x(cvt+604)),4))        /* point to smrt       */\n  cct = c2d(storage((d2x(srmt+4)),4))          /* point to cvtecvt    */\n  cpp = format(c2d(storage(d2x(cct+102),2)),3)||'%' /* format display */\n/*---------------- loop through non-vacant asvt slots ----------------*/\n  do cntr = 0 to asvtmaxu                     /* check all ASVT slots */\n    offset = cntr * 4                          /* increment offset    */\n    in_use_flag = storage(d2x(cvtasvt+528+offset),1)  /* get flag     */\n    if bitand(in_use_flag,'80'x) = '80'x then iterate   /* in use?    */\n    ascb = c2d(storage(d2x(cvtasvt+528+offset),4)) /* get ascb addr.  */\n    if ascb = '0' then iterate                     /* valid address?  */\n    if storage(d2x(ascb),4) <> 'ASCB' then iterate   /* eye catcher?  */\n    call get_ascb\n  end\n  maxlines = inc - 1                           /* set maximum lines   */\n  mcnt = maxlines                              /* set total ASIDs     */\n  call quicksort 1,maxlines                    /* sort the displays   */\n  title = ' Address Space List - 'vdis         /* set display title   */\n  call display_list                            /* display results     */\nend\n\nreturn\n/*------------- get address space infomation -------------------------*/\nget_ascb:\nasid = red||right(c2d(storage(d2x(ascb+36),2)),3)  /* get ASID        */\ndpri = blue||right(c2x(storage(d2x(ascb+43),1)),3) /* dispatch prior. */\ncscb = c2d(storage(d2x(ascb+56),4))            /* address of CSCB     */\nascbejst = c2d(storage(d2x(ascb+64),8))        /* job step cpu time   */\n/*--------------- convert CPU time to hh:mm.ss -----------------------*/\ncputime = ascbejst/4096/1000000                /* convert to minutes  */\ncpuhrs = cputime%60                            /* convert to hours    */\ncpuhrs = right(cpuhrs,3,' ')||':'              /* pad, add separator  */\ncpumin = (cputime//60)*60%60                   /* get seconds         */\ncpumin = right(cpumin,2,'0')||'.'              /* pad, add separator  */\ncpusec = cputime//1                            /* get seconds         */\ncpusec = substr(cpusec,3,2,'0')                /* pad                 */\ncpu = white||cpuhrs||cpumin||cpusec            /* build string        */\n/*--------------- get the assb info and build output line ------------*/\nassb = c2d(storage(d2x(ascb+336),4))           /* address of ASSB     */\nassbvsc = c2d(storage(d2x(assb+32),4))         /* VIO Aux pages used  */\nvio = turq||right(assbvsc,8)                   /* vio count           */\nassbnvsc = c2d(storage(d2x(assb+36),4))        /* non-VIO Aux pages   */\nnonvio = blue||right(assbnvsc,8)               /* non-vio count       */\n/*------------- set the job name and display colour ------------------*/\nascbjbns = c2d(storage(d2x(ascb+176),4))       /* address of jobname  */\n\nif ascbjbns = 0 then call starting_asid        /* Starting asid       */\nelse\n  do\n    jname = storage(d2x(ascbjbns),8)           /* get jobname         */\n    if cscb = 0 then call master_asid          /* Master asid?        */\n    else\n      do\n        chtrkid = c2d(storage(d2x(cscb+28),1)) /* display identifier  */\n        select\n          when chtrkid = 1 then call tso_asid  /* TSO asid?           */\n          when chtrkid = 2 then call stc_asid  /* STC asid?           */\n          when chtrkid = 3 then call init_asid /* Initiator asid?     */\n          when chtrkid = 4 then call system_asid /* System asid       */\n          otherwise call unknown_asid          /* Unknown asid        */\n        end\n      end\n  end\n\noucb = c2d(storage(d2x(ascb+144),4))           /* address of OUCB     */\noucbsfl = storage(d2x(oucb+17),1)              /* swapout flag        */\noucbsrc = c2d(storage(d2x(oucb+41),1))         /* get swap code       */\n/*----------------- convert numeric to swap code ---------------------*/\nselect\n  when oucbsrc = 1 then swap = blue||'TO'\n  when oucbsrc = 2 then swap = green||'TI'\n  when oucbsrc = 3 then swap = pink||'LW'\n  when oucbsrc = 4 then swap = turq||'XS'\n  when oucbsrc = 5 then swap = blue||'RS'\n  when oucbsrc = 6 then swap = pink||'DW'\n  when oucbsrc = 7 then swap = green||'RQ'\n  when oucbsrc = 8 then swap = turq||'NQ'\n  when oucbsrc = 9 then swap = blue||'EX'\n  when oucbsrc = 10 then swap = pink||'US'\n  when oucbsrc = 11 then swap = gteen||'TS'\n  when oucbsrc = 12 then swap = turq||'IC'\n  when oucbsrc = 13 then swap = blue||'IP'\n  when oucbsrc = 14 then swap = pink||'MR'\n  when oucbsrc = 15 then swap = green||'AW'\n  when oucbsrc = 16 then swap = turq||'OI'\n  when oucbsrc = 17 then swap = blue||'OO'\n  otherwise if bitand(oucbsfl,'80'x) = '80'x then swap = green||'NS'\n            else swap = yellow||'IN'\nend\n\nouxb = c2d(storage(d2x(ascb+148),4))           /* address of ouxb     */\nouxbiosm = c2d(storage(d2x(ouxb+152),4))       /* exception count     */\nexcp = pink||right(strip(ouxbiosm),9)          /* get exception count */\nrsme = c2d(storage(d2x(ascb+364),4))           /* address of rsme     */\nrstor = green||format(c2d(storage(d2x(rsme+44),4)),5) /* format rstor */\n\nif vfld = 'ALL' then call build_output\nelse\n  if type = vfld then call build_output\n  else nop\n\nreturn\n/*----------------------- build the output line ----------------------*/\nbuild_output:\nline.inc = jname||asid||dpri||swap||cpu||rstor||vio||nonvio||excp\ninc = inc + 1                                  /* increment counter   */\n\nreturn\n/*----------------------- Init ASID ----------------------------------*/\ninit_asid:\nselect\n  when jname = 'ASCHINT' then                  /* Initiator?          */\n    do\n      jname = white||jname                     /* set colour          */\n      type = 'ASC'                             /* set type            */\n      acnt = acnt + 1                          /* increment counter   */\n    end\n  when jname = 'BPXAS' then                    /* OMVS asid?          */\n    do\n      ascbjbni = c2d(storage(d2x(ascb+172),4)) /* iname address       */\n      if ascbjbni = 0 then                     /* blank iname field   */\n        do\n          jname = pink||jname                  /* set colour          */\n          type = 'BPX'                         /* set type            */\n          bcnt = bcnt + 1                      /* increment counter   */\n        end\n      else\n        do\n          jname = pink||storage(d2x(ascbjbni),8) /* use iname         */\n          type = 'OMV'                         /* set type            */\n          ocnt = ocnt + 1                      /* increment counter   */\n        end\n    end\n  when jname = 'INIT' then                     /* Initiator?          */\n    do\n      ascbjbni = c2d(storage(d2x(ascb+172),4)) /* iname address       */\n      if ascbjbni = 0 then                     /* blank iname field   */\n        do\n          jname = white||jname                 /* set colour          */\n          type = 'INI'                         /* set type            */\n          icnt = icnt + 1                      /* increment counter   */\n        end\n      else\n        do\n          jname = yellow||storage(d2x(ascbjbni),8) /* use iname       */\n          type = 'BAT'                         /* set type            */\n          btcnt = btcnt + 1                    /* increment counter   */\n        end\n    end\n  otherwise call unknown_asid                  /* what's left         */\nend\n\nreturn\n/*----------------------- Master ASID --------------------------------*/\nmaster_asid:\njname = white||jname                           /* set colour          */\ntype = 'SYS'                                   /* set type            */\nsycnt = sycnt + 1                              /* increment counter   */\n\nreturn\n/*----------------------- Starting ASID ------------------------------*/\nstarting_asid:\njname = yellow||'Starting'                     /* set colour          */\ntype = 'UKN'                                   /* set type            */\nstcnt = stcnt + 1                              /* increment counter   */\n\nreturn\n/*----------------------- STC ASID -----------------------------------*/\nstc_asid:\njname = turq||jname                            /* set colour          */\ntype = 'STC'                                   /* set type            */\nscnt = scnt + 1                                /* increment counter   */\n\nreturn\n/*----------------------- System ASID --------------------------------*/\nsystem_asid:\njname = blue||jname                            /* set colour          */\ntype = 'SYS'                                   /* set type            */\nsycnt = sycnt + 1                              /* increment counter   */\n\nreturn\n/*----------------------- TSO ASID -----------------------------------*/\ntso_asid:\njname = green||jname                           /* set colour          */\ntype = 'TSO'                                   /* set type            */\ntcnt = tcnt + 1                                /* increment counter   */\n\nreturn\n/*----------------------- Unknown ASID -------------------------------*/\nunknown_asid:\njname = red||'Unknown '                        /* set colour          */\ntype = 'UKN'                                   /* set type            */\nucnt = ucnt + 1                                /* increment counter   */\n\nreturn\n/*----------------------- sort the output lines ----------------------*/\nquicksort: procedure expose line. sorder sfld slen\narg first,last                                 /* point to cvtgda     */\nptr1 = first                                   /* point to cvtgda     */\nptr2 = last                                    /* point to cvtgda     */\nmid_point = (first + last) % 2                 /* point to cvtgda     */\nkeep = substr(line.mid_point,sfld,slen)        /* point to cvtgda     */\n\ndo until ptr1 > ptr2                           /* point to cvtgda     */\n  if sorder = 'A' then                         /* ascending sort      */\n    do\n      do while substr(line.ptr1,sfld,slen) << keep /* less than ?     */\n        ptr1 = ptr1 + 1                        /* increment counter   */\n      end\n      do while substr(line.ptr2,sfld,slen) >> keep /* more than ?     */\n        ptr2 = ptr2 - 1                        /* decrement counter   */\n      end\n    end\n  else                                         /* decending sort      */\n    do\n      do while substr(line.ptr1,sfld,slen) >> keep /* more than ?     */\n        ptr1 = ptr1 + 1                        /* increment counter   */\n      end\n      do while substr(line.ptr2,sfld,slen) << keep /* less than ?     */\n        ptr2 = ptr2 - 1                        /* decrement counter   */\n      end\n    end\n      if ptr1 <= ptr2 then                     /* point to cvtgda     */\n        do\n          temp_var = line.ptr1                 /* swap the two fields */\n          line.ptr1 = line.ptr2                /* using the temporary */\n          line.ptr2 = temp_var                 /* field               */\n          ptr1 = ptr1 + 1                      /* increment counter   */\n          ptr2 = ptr2 - 1                      /* decrement counter   */\n        end\n    end\n\nif first < ptr2 then call quicksort first,ptr2 /* move down top       */\nif ptr1 < last then call quicksort ptr1,last   /* move up bottom      */\n\nreturn\n/**********************************************************************/\n/********************** common sub-routines ***************************/\n/**********************************************************************/\n/*---------------- default values ------------------------------------*/\nset_default:\npsas = 0                                       /* start of psa        */\npsae = FFF                                     /* end of psa          */\npsak = 4                                       /* size of psa         */\nsyss = 1000                                    /* start of system     */\nsyse = 4FFF                                    /* end of system       */\nsysk = 16                                      /* size of system      */\nprivs = 5000                                   /* start of private    */\ngblrs = 5000                                   /* start of real priv. */\nnucoe = FFFFFF                                 /* end of R/O nuc.     */\nenucos = 1000000                               /* start of ext. nuc.  */\n\nreturn\n/*---------------- get storage use details ---------------------------*/\nget_storage_use:\nmegabyte = 1024*1000\ncvtgda = c2d(storage(d2x(cvt+560),4))          /* point to cvtgda     */\ncsa   = c2d(storage(d2x(cvtgda+112),4))        /* csa region size     */\ncsaf  = format((csa/megabyte),,2)              /* convert to Megs.    */\necsa  = c2d(storage(d2x(cvtgda+128),4))        /* ex. csa size        */\necsaf = format((ecsa/megabyte),,2)             /* convert to Megs.    */\nsqa   = c2d(storage(d2x(cvtgda+148),4))        /* sqa region size     */\nsqaf  = format((sqa/megabyte),,2)              /* convert to Megs.    */\nesqa  = c2d(storage(d2x(cvtgda+156),4))        /* ex. sqa size        */\nesqaf = format((esqa/megabyte),,2)             /* convert to Megs.    */\npriv  = c2d(storage(d2x(cvtgda+164),4))        /* private region size */\nprivf = format((priv/megabyte),,2)             /* convert to Megs.    */\neprv  = c2d(storage(d2x(cvtgda+172),4))        /* ex. private size    */\neprvf = format((eprv/megabyte),,2)             /* convert to Megs.    */\ncsau  = c2d(storage(d2x(cvtgda+432),4))        /* csa used            */\ncsauf = format((csau/csa*100),,1)'%'           /* convert to Percent  */\necsau = c2d(storage(d2x(cvtgda+436),4))        /* ecsa used           */\necsauf = format((ecsau/ecsa*100),,1)'%'        /* convert to Percent  */\nsqau  = c2d(storage(d2x(cvtgda+440),4))        /* sqa used            */\nsqauf = format((sqau/sqa*100),,1)'%'           /* convert to Percent  */\nesqau = c2d(storage(d2x(cvtgda+444),4))        /* esqa used           */\nesqauf = format((esqau/esqa*100),,1)'%'        /* convert to Percent  */\ncsao  = c2d(storage(d2x(cvtgda+448),4))        /* csa overflow        */\ncsaof = format((csao/megabyte),,2)             /* convert to Megs.    */\necsao = c2d(storage(d2x(cvtgda+452),4))        /* ecsa overflow       */\necsaof = format((ecsao/megabyte),,2)           /* convert to Megs.    */\n\nreturn\n/*--------------------- display list in pop-up window ----------------*/\ndisplay_list:\nsrchfor = ''                                   /* null string         */\ndyndata = ''                                   /* initialize display  */\n\ndo inc = 1 to maxlines                         /* for each line       */\n  dyndata = dyndata||line.inc                  /* build output line   */\nend\n\ndyndata = dyndata||blue||centre(white||'BOTTOM'||blue,scrn_wdth-1,'*')\n\naddress ispexec                                /* set mode            */\n\"vget zpf05 profile\"                           /* get PF5 key         */\nzpf05_old = zpf05                              /* save old key        */\nzpf05 = 'AGAIN'                                /* set PF5 key         */\n\"vput zpf05 profile\"                           /* store PF5 key       */\ncursor = 'cursor()'                            /* set initial value   */\n\"addpop row(2) column(\"poppos\")\"               /* set window          */\n\ndo until disprc > 0\n  display_again = 'N'\n  dynarea = substr(dyndata,1+(cur_line-1)*scrn_wdth) /* set display   */\n  \"display panel(\"panel_name\")\" cursor         /* display result      */\n  disprc = rc\n  \"vget (zverb,zscrolla,zscrolln)\"             /* get ispf values     */\n  select\n    when zverb = 'UP' then\n      do\n        if zscrolla = 'MAX' then cur_line = 1  /* move to top         */\n        else cur_line = max(1,cur_line-zscrolln) /* up x lines        */\n      end\n    when zverb = 'DOWN' then\n      do\n        if zscrolla = 'MAX' then cur_line = maxlines  /* move to bot. */\n        else cur_line = min(maxlines,cur_line+zscrolln) /*down x lines*/\n      end\n    when zcmd = 'AGAIN' & srchfor <> '' then   /* PF5 pressed         */\n      do\n        from_here = start_pos                  /* get search string   */\n        start_pos = pos(srchfor,dyndata,from_here+1) /* search again  */\n        if start_pos <> 0 then call get_position /* if found, display */\n        else call not_found                    /* reset cursor        */\n      end\n    when substr(zcmd,1,1) = 'F' then           /* find a string?      */\n      do\n        parse var zcmd . srchfor               /* get search string   */\n        start_pos = pos(srchfor,dyndata)       /* search for string   */\n        if start_pos <> 0 then call get_position /* if found, display */\n        else call not_found                    /* reset cursor        */\n      end\n    when substr(zcmd,1,1) = 'L' & sort = 'Y' then\n      do\n        \"addpop row(2) column(18)\"             /* start window        */\n        \"display panel(checkact)\"              /* display results     */\n        \"rempop\"                               /* stop window         */\n      end\n    when substr(zcmd,1,1) = 'S' & sort = 'Y' then\n      do\n        \"addpop column(10)\"                    /* Set up sort window  */\n        \"display panel(checksrt)\"              /* Display window      */\n        \"rempop\"                               /* remove window       */\n        display_again = 'Y'                    /* Display again       */\n        cur_line = 1                           /* set to top          */\n        leave                                  /* exit loop           */\n      end\n    when substr(zcmd,1,1) = 'V' & sort = 'Y' then\n      do\n        \"addpop column(10)\"                    /* Set up sort window  */\n        \"display panel(checkvie)\"              /* Display window      */\n        \"rempop\"                               /* remove window       */\n        display_again = 'Y'                    /* display again       */\n        cur_line = 1                           /* set to top          */\n        leave                                  /* exit loop           */\n      end\n    when disprc = 0 & sort = 'Y' then          /* enter pressed       */\n      do\n        display_again = 'Y'                    /* display again       */\n        leave                                  /* exit loop           */\n      end\n    otherwise\n  end\nend\n\n\"rempop\"                                       /* close window        */\nzpf05 = zpf05_old                              /* reset pf key        */\n\"vput zpf05 profile\"                           /* store PF5 key       */\naddress tso                                    /* set mode            */\n\nreturn\n/*------------------ calculate line position in dynamic area ---------*/\nget_position:\ncur_line = start_pos%scrn_wdth+1               /* get row position    */\ncsrpos = start_pos//scrn_wdth                  /* get column position */\ncursor = 'cursor(dynarea)'                     /* set cursor field    */\n\nreturn\n/*------------------ calculate line position in dynamic area ---------*/\nnot_found:\ncur_line = 1                                   /* set row position    */\ncsrpos  = 1                                    /* set column position */\ncursor = 'cursor()'                            /* set cursor field    */\n\nreturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CHECKVER": {"ttr": 1290, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x004\\x01\\x02\\x01\\x7f\\x01\\x02\\x01\\x8f\\x08E\\x00\\x1d\\x00\\x1d\\x00\\x00\\xc1\\xe7\\xe2\\xd7\\xf0\\xf0\\xf3@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2002-01-17T00:00:00", "modifydate": "2002-01-18T08:45:34", "lines": 29, "newlines": 29, "modlines": 0, "user": "AXSP003"}, "text": ")attr\n |  type(text) color(green)\n \u00ac  type(text) color(yellow)\n \u20ac  type(text) color(red)\n \u00a2  type(text) color(pink)\n _  type(output) just(left) color(turq)\n \u00a8  type(output) just(left) color(yellow)\n \u00a3  type(output) just(right) color(red)\n \u00e0  type(output) just(left) color(pink)\n \u00b5  type(output) just(left) color(blue)\n \u00a7  type(output) just(right) color(pink)\n \u00b0  type(output) just(right) color(blue)\n)body expand(//) window(56,12)\n|Op. Sys.         FMID           JES2           VTAM\n_osysv           _fmid          _jesv          _vtamv\n|\n|RACF             TSOE           ISPF           MVS\n_racfv           _tsov          _ispfv         _mvs\n|\n|DFP              HSM            SMS            SMF Id.\n_dfpv            _hsmv          _dfsms         _smfid\n|\n|Sysplex Id.\n_splx\n%/ /|Press\u20acPF3|to\u00acEnd%/ /\n)init\n&zwinttl = &title\n)proc\n)end\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CHECKVIE": {"ttr": 1292, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": ")attr\n |  type(text) color(green) skip(on)\n \u00ac  type(text) color(yellow)\n \u20ac  type(text) color(red)\n \u00a2  type(text) color(turq)\n \u00a8  type(output) just(left) color(yellow)\n \u00a3  type(output) just(right) color(red)\n \u00b5  type(output) just(right) color(blue)\n \u00a7  type(output) just(right) color(pink)\n \u00b0  type(output) just(right) color(blue)\n)body window(17,11)\n% Option+==>_Z|\n+\n|1\u20ac-\u00acView All\n|2\u20ac-\u00acView System\n|3\u20ac-\u00acView STC\n|4\u20ac-\u00acView TSO\n|5\u20ac-\u00acView Batch\n|6\u20ac-\u00acView OMVS\n|7\u20ac-\u00acView Init.\n|8\u20ac-\u00acView ASCH.\n|9\u20ac-\u00acView BPXAS\n)init\n.zvars = '(voptn)'\n.cursor = voptn\n&zwinttl = 'View Options'\n&voptn = '1'\n)proc\nver (&voptn,nb,range,1,9)\n&vfld = trans(&voptn 1,ALL\n                     2,SYS\n                     3,STC\n                     4,TSO\n                     5,BAT\n                     6,OMV\n                     7,INI\n                     8,ASC\n                     9,BPX)\n&vdis = trans(&voptn 1,ALL\n                     2,System\n                     3,STC\n                     4,TSO\n                     5,Batch\n                     6,OMVS\n                     7,Inits\n                     8,ASCH\n                     9,BPXAS)\n)end\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "GETUADDR": {"ttr": 1537, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x05\\x01\\x02\\x01\\x7f\\x01\\x02\\x01\\x7f\\x15G\\x00w\\x00w\\x00\\x00\\xc1\\xe7\\xe2\\xd7\\xf0\\xf0\\xf3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-01-17T00:00:00", "modifydate": "2002-01-17T15:47:05", "lines": 119, "newlines": 119, "modlines": 0, "user": "AXSP003"}, "text": "         TITLE 'GET UCB ADDRESS USING PROVIDED VOLSER'\nGETUADDR CSECT\nGETUADDR AMODE 31\nGETUADDR RMODE ANY\n         BAKR  R14,0                    save caller's ars + gprs\n*                                       in the linkage stack\n         LAE   R12,0(R15,0)             set up program base register\n         USING GETUADDR,R12\n*\nGETPARMS EQU   *\n         LM    R3,R4,0(R1)              load parm \u00e0\n         USING RVOLUME,R3               get addressability\n         USING DEVNUM,R4                get addressability r\n*\nGETWORK  EQU   *\n         L     R9,=AL4(WORKALEN)        work area length\n         STORAGE OBTAIN,LENGTH=(R9),ADDR=(R10),SP=0,KEY=8,             X\n               LOC=BELOW,COND=NO,RELATED=(FREEWORK,'FREE WORK AREA')\n         LAE   R13,0(R0,R1)             \u00e0 the workarea\n         USING SAVEAREA,R13             inform the assembler\n*\nMAINLINE EQU   *\n         XC    UCBSWA,UCBSWA            clear the return area\n         XC    UCBCS,UCBCS              clear the return area\n         CLC   DNUM,=Cl4'0000'          are we looking for the volser?\n         BE    GETUCB                   yes\n         CLC   VOL,=Cl6'XXXXXX'         are we looking for the ucb?\n         BE    GETVOLSR                 yes\n         B     PARMERR                  something wrong\n*\nGETUCB   EQU   *\n         UCBSCAN COPY,                                                 X\n               VOLSER=VOL,                                             X\n               DEVNCHAR=DNUM,                                          X\n               DEVCLASS=DASD,                                          X\n               DYNAMIC=YES,                                            X\n               WORKAREA=UCBSWA,                                        X\n               UCBAREA=UCBCS,                                          X\n               RANGE=ALL,                                              X\n               MF=(E,UCBPARM,COMPLETE)\n         LTR   R15,R15                  test return code\n         BNZ   ERROR                    exit if non-zero\n         B     EXIT                     go home\n*\nGETVOLSR EQU   *\n         XC    DEVNCHAR,DEVNCHAR        clear the return area\n*\nSCANLOOP EQU   *\n         UCBSCAN COPY,                                                 X\n               DEVCLASS=DASD,                                          X\n               DEVNCHAR=DEVNCHAR,                                      X\n               DYNAMIC=YES,                                            X\n               WORKAREA=UCBSWA,                                        X\n               UCBAREA=UCBCS,                                          X\n               RANGE=ALL,                                              X\n               MF=(E,UCBPARM,COMPLETE)\n         LTR   R15,R15                  test return code\n         BNZ   ERROR                    exit if non-zero\n         CLC   DNUM,DEVNCHAR            is it the same?\n         BNE   SCANLOOP                 keep looping if not\n         LA    R9,UCBCS\n         USING UCB,R9                   get addressability\n         MVC   VOL,UCBVOLI              get volser\n         B     EXIT                     go home\n*\nPARMERR  EQU   *\n         WTO   'ERROR IN PARAMETER'\n         B     EXIT                     go home\n*\nERROR    EQU   *\n         WTO   'ERROR IN SEARCHING FOR UCB'\n         B     EXIT                     go home\n*\nEXIT     EQU   *\n         LAE   R1,0(R0,R13)             address to free\n         L     R9,=AL4(WORKALEN)        work area length\n         STORAGE RELEASE,ADDR=(R1),LENGTH=(R9),SP=0,KEY=8,             X\n               COND=NO,RELATED=(GETWORK,'OBTAIN WORK AREA')\n         SLR   R15,R15                  set rc to zero\n         PR                             restore & return\n         LTORG\n*\nR0  EQU   0\nR1  EQU   1\nR2  EQU   2\nR3  EQU   3\nR4  EQU   4\nR5  EQU   5\nR6  EQU   6\nR7  EQU   7\nR8  EQU   8\nR9  EQU   9\nR10 EQU  10\nR11 EQU  11\nR12 EQU  12\nR13 EQU  13\nR14 EQU  14\nR15 EQU  15\n*\nWORKAREA DSECT\nSAVEAREA DS    CL72                     savearea\nUCBSWA   DS    CL100                    ucbscan work area\nUCBCS    DS    CL48                     ucb common segment\nDEVNCHAR DS    CL4                      EBCDIC device number\n         UCBSCAN MF=(L,UCBPARM)         List form of UCBSCAN\n*\nENDWORK  DS    0D\nWORKALEN EQU   *-WORKAREA               work area length\n*\nRVOLUME  DSECT\nVOL      DS    CL6                      volume serial no\n*\nDEVNUM   DSECT\nDNUM     DS    CL4                      device number\n*\nUCB      DSECT\n         IEFUCBOB                       ucb macro id\n         CVT   DSECT=YES,LIST=NO\n         END   GETUADDR\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LNK": {"ttr": 1540, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\x06O\\x01\\x02\\x06O\\x17\\x03\\x00z\\x00z\\x00\\x00\\xc4\\xc2\\xc2\\xd9\\xd6\\xe6\\xd5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-03-05T00:00:00", "modifydate": "2002-03-05T17:03:00", "lines": 122, "newlines": 122, "modlines": 0, "user": "DBBROWN"}, "text": "/* REXX */\n/**********************************************************************/\n/* this routine gets the current linklist - Version 1.0               */\n/**********************************************************************/\n/*------------------ initialize global variables ---------------------*/\ntrace 0\naddress tso                                    /* set mode            */\nnumeric digits 30                              /* set decimal size    */\nred   = '01'x\nblue  = '02'x\ngreen = '03'x\nwhite = '04'x\nturq  = '05'x\npink  = '06'x\nyellow = '07'x\nsysn = mvsvar('SYSNAME')                       /* get sysname         */\ncur_line = 1                                   /* first row           */\ncsrpos  = 1                                    /* first character     */\npoppos  = 6                                    /* start pos. for pop  */\nscrn_wdth = 56                                 /* set screen width    */\n/*------------------ get linklist data -------------------------------*/\ncvt = c2d(storage(10,4))                       /* point to cvt        */\necvt = c2d(storage(d2x(cvt+140),4))            /* point to cvtecvt    */\nascb = c2d(storage(224,4))                     /* point to ascb       */\nassb = c2d(storage(d2x(ascb+336),4))           /* point to assb       */\ndlcb = c2d(storage(d2x(assb+236),4))           /* point to dlcb       */\nlnkname = strip(storage(d2x(dlcb+36),16),t)    /* lnklst set name     */\ncvtllta = c2d(storage(d2x(dlcb+16),4))         /* point to cvtllta    */\nlltx = c2d(storage(d2x(dlcb+20),4))            /* point to lltx       */\nmaxlines = c2d(storage(d2x(cvtllta+4),4))      /* number of entry     */\nlltapftb = cvtllta + 8 + (maxlines * 45)       /* first entry         */\nlnkoff = 8                                     /* offset for dsn      */\nvoloff = 8                                     /* offset for vol      */\napfoff = 0                                     /* offset for apf      */\n\ndo inc = 1 to maxlines\n  len = c2d(storage(d2x(cvtllta+lnkoff),1))    /* length of entry     */\n  lnkdsn = storage(d2x(cvtllta+lnkoff+1),len)  /* get the dsn         */\n  lnkvol = storage(d2x(lltx+voloff),6)         /* get the volser      */\n  apflag = storage(d2x(lltapftb+apfoff),1)     /* check apf flag      */\n  if bitand(apflag,'80'x) = '80'x then dsnapf = 'Y' /* apf flag on    */\n  else dsnapf = ' '                            /* apf flag off        */\n  lnkoff = lnkoff + 45                         /* incr. lnkoff        */\n  voloff = voloff + 8                          /* incr. voloff        */\n  apfoff = apfoff + 1                          /* incr. apfoff        */\n  line.inc = green||left(lnkdsn,45)||blue||left(lnkvol||' ',\n             ||red||dsnapf,9)\nend\n\n/*------------------ display the linklist ----------------------------*/\ntitle = maxlines' LinkList Datasets in 'lnkname' for 'sysn\nsrchfor = ''                                   /* initialize display  */\ndyndata = ''                                   /* initialize display  */\n\ndo inc = 1 to maxlines                         /* for each line       */\n  dyndata = dyndata||line.inc                  /* build output line   */\nend\n\ndyndata = dyndata||blue||centre(white||'BOTTOM'||blue,scrn_wdth-1,'*')\n\naddress ispexec                                /* set mode            */\n\"vget zpf05 profile\"                           /* get PF5 key         */\nzpf05_old = zpf05                              /* save old key        */\nzpf05 = 'AGAIN'                                /* set PF5 key         */\n\"vput zpf05 profile\"                           /* store PF5 key       */\ncursor = 'cursor()'                            /* set initial value   */\n\"addpop row(2) column(\"poppos\")\"               /* set window          */\n\ndo until disprc > 0\n  dynarea = substr(dyndata,1+(cur_line-1)*scrn_wdth) /* set display   */\n  \"display panel(checklnk)\" cursor             /* display result      */\n  disprc = rc\n  \"vget (zverb,zscrolla,zscrolln)\"             /* get ispf values     */\n  select\n    when zverb = 'UP' then\n      do\n        if zscrolla = 'MAX' then cur_line = 1  /* move to top         */\n        else cur_line = max(1,cur_line-zscrolln) /* up x lines        */\n      end\n    when zverb = 'DOWN' then\n      do\n        if zscrolla = 'MAX' then cur_line = maxlines  /* move to bot. */\n        else cur_line = min(maxlines,cur_line+zscrolln) /*down x lines*/\n      end\n    when zcmd = 'AGAIN' & srchfor <> '' then   /* PF5 pressed         */\n      do\n        from_here = start_pos                  /* get search string   */\n        start_pos = pos(srchfor,dyndata,from_here+1) /* search again  */\n        if start_pos <> 0 then call get_position /* if found, display */\n        else call not_found                    /* reset cursor        */\n      end\n    when substr(zcmd,1,1) = 'F' then           /* find a string?      */\n      do\n        parse var zcmd . srchfor               /* get search string   */\n        start_pos = pos(srchfor,dyndata)       /* search for string   */\n        if start_pos <> 0 then call get_position /* if found, display */\n        else call not_found                    /* reset cursor        */\n      end\n    otherwise\n  end\nend\n\n\"rempop\"                                       /* close window        */\nzpf05 = zpf05_old                              /* reset pf key        */\n\"vput zpf05 profile\"                           /* store PF5 key       */\naddress tso                                    /* set mode            */\n\nexit\n/*------------------ calculate line position in dynamic area ---------*/\nget_position:\ncur_line = start_pos%scrn_wdth+1               /* get row position    */\ncsrpos = start_pos//scrn_wdth                  /* get column position */\ncursor = 'cursor(dynarea)'                     /* set cursor field    */\n\nreturn\n/*------------------ calculate line position in dynamic area ---------*/\nnot_found:\ncur_line = 1                                   /* set row position    */\ncsrpos  = 1                                    /* set column position */\ncursor = 'cursor()'                            /* set cursor field    */\n\nreturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LPA": {"ttr": 1543, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\x06O\\x01\\x02\\x06O\\x17\\x03\\x00k\\x00k\\x00\\x00\\xc4\\xc2\\xc2\\xd9\\xd6\\xe6\\xd5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-03-05T00:00:00", "modifydate": "2002-03-05T17:03:00", "lines": 107, "newlines": 107, "modlines": 0, "user": "DBBROWN"}, "text": "/* REXX */\n/**********************************************************************/\n/* this routine gets the lpa list - version 1.0                       */\n/**********************************************************************/\n/*------------------ initialize global variables ---------------------*/\ntrace 0\naddress tso                                    /* set mode            */\nnumeric digits 30                              /* set decimal size    */\nsysn = mvsvar('SYSNAME')                       /* get sysname         */\nred   = '01'x                                  /* set colour          */\nblue  = '02'x                                  /* attributes fo the   */\ngreen = '03'x                                  /* dynamic display     */\nwhite = '04'x                                  /* area                */\nturq  = '05'x                                  /*                     */\npink  = '06'x                                  /*                     */\nyellow = '07'x                                 /*                     */\ncur_line = 1                                   /* first row           */\ncsrpos  = 1                                    /* first character     */\npoppos  = 10                                   /* start pos. for pop  */\nscrn_wdth = 45                                 /* set screen width    */\n/*------------------ get lpa list data -------------------------------*/\ncvt = c2d(storage(10,4))                       /* point to cvt        */\necvt = c2d(storage(d2x(cvt+140),4))            /* point to cvtecvt    */\ncvtsmext = c2d(storage(d2x(cvt+1196),4))       /* point to cvtsmext   */\ncvteplps = c2d(storage(d2x(cvtsmext+56),4))    /* point to cvteplps   */\nmaxlines = c2d(storage(d2x(cvteplps+4),4))     /* number of entries   */\nlpatntry = cvteplps+9                          /* point to first dsn  */\n\ndo inc = 1 for maxlines\n  lpadsn = storage(d2x(lpatntry),44)           /* get the lpa dsn     */\n  lpatntry = lpatntry+45                       /* increment the pntr  */\n  line.inc = green||lpadsn                     /* build display str.  */\nend\n\n/*--------------------- display list in pop-up window ----------------*/\ntitle = maxlines' LPA Datasets for 'sysn       /* set display title   */\nsrchfor = ''                                   /* null string         */\ndyndata = ''                                   /* initialize display  */\n\ndo inc = 1 to maxlines                         /* for each line       */\n  dyndata = dyndata||line.inc                  /* build output line   */\nend\n\ndyndata = dyndata||blue||centre(white||'BOTTOM'||blue,scrn_wdth-1,'*')\n\naddress ispexec                                /* set mode            */\n\"vget zpf05 profile\"                           /* get PF5 key         */\nzpf05_old = zpf05                              /* save old key        */\nzpf05 = 'AGAIN'                                /* set PF5 key         */\n\"vput zpf05 profile\"                           /* store PF5 key       */\ncursor = 'cursor()'                            /* set initial value   */\n\"addpop row(2) column(\"poppos\")\"               /* set window          */\n\ndo until disprc > 0\n  dynarea = substr(dyndata,1+(cur_line-1)*scrn_wdth) /* set display   */\n  \"display panel(checklpa)\" cursor         /* display result      */\n  disprc = rc\n  \"vget (zverb,zscrolla,zscrolln)\"             /* get ispf values     */\n  select\n    when zverb = 'UP' then\n      do\n        if zscrolla = 'MAX' then cur_line = 1  /* move to top         */\n        else cur_line = max(1,cur_line-zscrolln) /* up x lines        */\n      end\n    when zverb = 'DOWN' then\n      do\n        if zscrolla = 'MAX' then cur_line = maxlines  /* move to bot. */\n        else cur_line = min(maxlines,cur_line+zscrolln) /*down x lines*/\n      end\n    when zcmd = 'AGAIN' & srchfor <> '' then   /* PF5 pressed         */\n      do\n        from_here = start_pos                  /* get search string   */\n        start_pos = pos(srchfor,dyndata,from_here+1) /* search again  */\n        if start_pos <> 0 then call get_position /* if found, display */\n        else call not_found                    /* reset cursor        */\n      end\n    when substr(zcmd,1,1) = 'F' then           /* find a string?      */\n      do\n        parse var zcmd . srchfor               /* get search string   */\n        start_pos = pos(srchfor,dyndata)       /* search for string   */\n        if start_pos <> 0 then call get_position /* if found, display */\n        else call not_found                    /* reset cursor        */\n      end\n    otherwise\n  end\nend\n\n\"rempop\"                                       /* close window        */\nzpf05 = zpf05_old                              /* reset pf key        */\n\"vput zpf05 profile\"                           /* store PF5 key       */\naddress tso                                    /* set mode            */\n\nreturn\n/*------------------ calculate line position in dynamic area ---------*/\nget_position:\ncur_line = start_pos%scrn_wdth+1               /* get row position    */\ncsrpos = start_pos//scrn_wdth                  /* get column position */\ncursor = 'cursor(dynarea)'                     /* set cursor field    */\n\nreturn\n/*------------------ calculate line position in dynamic area ---------*/\nnot_found:\ncur_line = 1                                   /* set row position    */\ncsrpos  = 1                                    /* set column position */\ncursor = 'cursor()'                            /* set cursor field    */\n\nreturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MAP": {"ttr": 1546, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\x06O\\x01\\x02\\x06O\\x17\\x03\\x00\\xad\\x00\\xad\\x00\\x00\\xc4\\xc2\\xc2\\xd9\\xd6\\xe6\\xd5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-03-05T00:00:00", "modifydate": "2002-03-05T17:03:00", "lines": 173, "newlines": 173, "modlines": 0, "user": "DBBROWN"}, "text": "/* REXX */\n/**********************************************************************/\n/* this routine display the storage map - version 1.0                 */\n/**********************************************************************/\n/*------------------ initialize global variables ---------------------*/\ntrace 0\naddress tso                                    /* set mode            */\nnumeric digits 30                              /* set decimal size    */\nsysn = mvsvar('SYSNAME')                       /* get sysname         */\nred   = '01'x                                  /* set colour          */\nblue  = '02'x                                  /* attributes fo the   */\ngreen = '03'x                                  /* dynamic display     */\nwhite = '04'x                                  /* area                */\nturq  = '05'x                                  /*                     */\npink  = '06'x                                  /*                     */\nyellow = '07'x                                 /*                     */\ntitle = ' Storage Map for 'sysn                /* set display title   */\n/*---------------- default values ------------------------------------*/\npsas = 0                                       /* start of psa        */\npsae = FFF                                     /* end of psa          */\npsak = 4                                       /* size of psa         */\nsyss = 1000                                    /* start of system     */\nsyse = 4FFF                                    /* end of system       */\nsysk = 16                                      /* size of system      */\nprivs = 5000                                   /* start of private    */\ngblrs = 5000                                   /* start of real priv. */\nnucoe = FFFFFF                                 /* end of R/O nuc.     */\nenucos = 1000000                               /* start of ext. nuc.  */\nmegabyte = 1024*1000\n/*---------------- get storage use details ---------------------------*/\ncvt = c2d(storage(10,4))                       /* point to cvt        */\necvt = c2d(storage(d2x(cvt+140),4))            /* point to cvtecvt    */\ncvtgda = c2d(storage(d2x(cvt+560),4))          /* point to cvtgda     */\ncsa   = c2d(storage(d2x(cvtgda+112),4))        /* csa region size     */\ncsaf  = format((csa/megabyte),,2)              /* convert to Megs.    */\necsa  = c2d(storage(d2x(cvtgda+128),4))        /* ex. csa size        */\necsaf = format((ecsa/megabyte),,2)             /* convert to Megs.    */\nsqa   = c2d(storage(d2x(cvtgda+148),4))        /* sqa region size     */\nsqaf  = format((sqa/megabyte),,2)              /* convert to Megs.    */\nesqa  = c2d(storage(d2x(cvtgda+156),4))        /* ex. sqa size        */\nesqaf = format((esqa/megabyte),,2)             /* convert to Megs.    */\npriv  = c2d(storage(d2x(cvtgda+164),4))        /* private region size */\nprivf = format((priv/megabyte),,2)             /* convert to Megs.    */\neprv  = c2d(storage(d2x(cvtgda+172),4))        /* ex. private size    */\neprvf = format((eprv/megabyte),,2)             /* convert to Megs.    */\ncsau  = c2d(storage(d2x(cvtgda+432),4))        /* csa used            */\ncsauf = format((csau/csa*100),,1)'%'           /* convert to Percent  */\necsau = c2d(storage(d2x(cvtgda+436),4))        /* ecsa used           */\necsauf = format((ecsau/ecsa*100),,1)'%'        /* convert to Percent  */\nsqau  = c2d(storage(d2x(cvtgda+440),4))        /* sqa used            */\nsqauf = format((sqau/sqa*100),,1)'%'           /* convert to Percent  */\nesqau = c2d(storage(d2x(cvtgda+444),4))        /* esqa used           */\nesqauf = format((esqau/esqa*100),,1)'%'        /* convert to Percent  */\ncsao  = c2d(storage(d2x(cvtgda+448),4))        /* csa overflow        */\ncsaof = format((csao/megabyte),,2)             /* convert to Megs.    */\necsao = c2d(storage(d2x(cvtgda+452),4))        /* ecsa overflow       */\necsaof = format((ecsao/megabyte),,2)           /* convert to Megs.    */\n/*---------------- get storage allocation ----------------------------*/\ncvtgda = c2d(storage(d2x(cvt+560),4))          /* point to cvtgda     */\ncsas  = strip(c2x(storage(d2x(cvtgda+108),4)),'l',0) /* start of csa  */\ncsa   = strip(c2x(storage(d2x(cvtgda+112),4)),'l',0) /* csa size      */\ncsak  = x2d(csa)/1024                                /* convert to K. */\ncsae  = d2x(x2d(csa)+x2d(csas)-1)                    /* end of csa    */\necsas = strip(c2x(storage(d2x(cvtgda+124),4)),'l',0) /* start of ecsa */\necsa  = strip(c2x(storage(d2x(cvtgda+128),4)),'l',0) /* ex. csa size  */\necsak = x2d(ecsa)/1024                               /* convert to K. */\necsae = d2x(x2d(ecsa)+x2d(ecsas)-1)                  /* end of ecsa   */\nsqas  = strip(c2x(storage(d2x(cvtgda+144),4)),'l',0) /* start of sqa  */\nsqa   = strip(c2x(storage(d2x(cvtgda+148),4)),'l',0) /* sqa size *    */\nsqak  = x2d(sqa)/1024                                /* convert to K. */\nsqae  = d2x(x2d(sqa)+x2d(sqas)-1)                    /* end of sqa    */\nesqas = strip(c2x(storage(d2x(cvtgda+152),4)),'l',0) /* start of esqa */\nesqa  = strip(c2x(storage(d2x(cvtgda+156),4)),'l',0) /* ex. esqa size */\nesqak = x2d(esqa)/1024                               /* convert to K. */\nesqae = d2x(x2d(esqa)+x2d(esqas)-1)                  /* end of esqa   */\npriv  = strip(c2x(storage(d2x(cvtgda+164),4)),'l',0) /* priv.  size   */\nprivk = x2d(priv)/1024                               /* convert to K. */\nprive = d2x(20480+((privk-20)*1024)-1)               /* end of priv.  */\neprvs = strip(c2x(storage(d2x(cvtgda+168),4)),'l',0) /* start of eprv.*/\neprv  = strip(c2x(storage(d2x(cvtgda+172),4)),'l',0) /* epriv. size   */\neprvk = x2d(eprv)/1024                               /* convert to K. */\neprve = d2x(x2d(eprv)+x2d(eprvs)-1)                  /* end of epriv. */\ngblr  = strip(c2x(storage(d2x(cvtgda+196),4)),'l',0) /* size v=r gbl. */\ngblrk = x2d(gblr)/1024                               /* convert to K. */\ngblre = d2x(20480+x2d(gblr)-1)                       /* end of global */\ncvtsmext = c2d(storage(d2x(cvt+1196),4))           /* pnt to cvtsmext */\nmlpas  = strip(c2x(storage(d2x(cvtsmext+8),4)),'l',0) /*start of mlpa */\n\nif mlpas <> 0 then                             /* mlpa in use         */\n  do\n    mlpae = strip(c2x(storage(d2x(cvtsmext+12),4)),'l',0)\n    mlpak = (x2d(mlpae)-x2d(mlpas)+1)/1024     /* calc and convert    */\n  end\nelse                                           /* no mlpa             */\n  do\n    mplas = '  n/a   '\n    mlpae = '  n/a   '\n    mlpak = 0\n  end\n\nflpas = strip(c2x(storage(d2x(cvtsmext+16),4)),'l',0) /*start of flpa */\n\nif flpas <> 0 then                             /* flpa in use         */\n  do\n    flpae = strip(c2x(storage(d2x(cvtsmext+20),4)),'l',0)\n    flpak = (x2d(flpae)-x2d(flpas)+1)/1024     /* calc and convert    */\n  end\nelse                                           /* no flpa             */\n  do\n    fplas = '  n/a   '\n    flpae = '  n/a   '\n    flpak = 0\n  end\n\nplpas = strip(c2x(storage(d2x(cvtsmext+24),4)),'l',0) /*start of plpa */\nplpae = strip(c2x(storage(d2x(cvtsmext+28),4)),'l',0) /* end of plpa  */\nplpak = (x2d(plpae)-x2d(plpas)+1)/1024               /* calc and conv */\nnucws = strip(c2x(storage(d2x(cvtsmext+32),4)),'l',0) /* start of r/w */\nnucwe = strip(c2x(storage(d2x(cvtsmext+36),4)),'l',0) /* end of r/w   */\nnucwk = (x2d(nucwe)-x2d(nucws)+1)/1024               /* calc and conv */\nnucwk = format(nucwk,,0)                             /* tidy up size  */\nnucos = strip(c2x(storage(d2x(cvtsmext+40),4)),'l',0) /*start of flpa */\nnucok = (x2d('ffffff')-x2d(nucos)+1)/1024            /* calc and conv */\nenucoe = strip(c2x(storage(d2x(cvtsmext+44),4)),'l',0) /* end of r/o  */\nenucok = X2d(enucoe)-X2d('1000000')+1                /* calc and conv */\nenucok = Format(enucok/1024,,0)                      /* tidy up size  */\nenucws = strip(c2x(storage(d2x(cvtsmext+48),4)),'l',0) /* str e-r/w   */\nenucwe = strip(c2x(storage(d2x(cvtsmext+52),4)),'l',0) /* end e-r/w   */\nenucwk = (x2d(enucwe)-x2d(enucws)+1)/1024            /* calc and conv */\nenucwk = format(enucwk,,0)                           /* tidy up size  */\neplpas = strip(c2x(storage(d2x(cvtsmext+56),4)),'l',0) /*str of eplpa */\neplpae = strip(c2x(storage(d2x(cvtsmext+60),4)),'l',0) /*end of eplpa */\neplpak = (x2d(eplpae)-x2d(eplpas)+1)/1024            /* calc and conv */\neflpas = strip(c2x(storage(d2x(cvtsmext+64),4)),'l',0) /*str of eflpa */\n\nif eflpas <> 0 then                            /* ext. flpa in use    */\n  do\n    eflpae = strip(c2x(storage(d2x(cvtsmext+68),4)),'l',0)\n    eflpak = (x2d(eflpae)-x2d(eflpas)+1)/1024  /* calc and convert    */\n  end\nelse                                           /* no ext. flpa        */\n  do\n    efplas = '  n/a   '\n    eflpae = '  n/a   '\n    eflpak = 0\n  end\n\nemlpas = strip(c2x(storage(d2x(cvtsmext+72),4)),'l',0) /* str emlpa   */\n\nif emlpas <> 0 then                            /* ext. mlpa in use    */\n  do\n    emlpae = strip(c2x(storage(d2x(cvtsmext+76),4)),'l',0)\n    emlpak = (x2d(emlpae)-x2d(emlpas)+1)/1024  /* calc and convert    */\n  end\nelse                                           /* no ext. mlpa        */\n  do\n    emplas = '  n/a   '\n    emlpae = '  n/a   '\n    emlpak = 0\n  end\n\n/*----------------------- display the information --------------------*/\naddress ispexec                                /* set mode            */\n\"addpop row(2) column(10)\"                     /* start window        */\n\ndo until rc > 0\n  \"display panel(checkmap)\"                    /* display results     */\nend\n\n\"rempop\"                                       /* stop window         */\naddress tso                                    /* set mode            */\n\nexit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "STR": {"ttr": 1550, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\x06O\\x01\\x02\\x06O\\x17\\x03\\x00N\\x00N\\x00\\x00\\xc4\\xc2\\xc2\\xd9\\xd6\\xe6\\xd5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-03-05T00:00:00", "modifydate": "2002-03-05T17:03:00", "lines": 78, "newlines": 78, "modlines": 0, "user": "DBBROWN"}, "text": "/* REXX */\n/**********************************************************************/\n/* this routine gets storage information - version 1.0                */\n/**********************************************************************/\n/*------------------ initialize global variables ---------------------*/\ntrace 0\naddress tso                                    /* set mode            */\nnumeric digits 30                              /* set decimal size    */\ncvt = c2d(storage(10,4))                       /* point to cvt        */\necvt = c2d(storage(d2x(cvt+140),4))            /* point to cvtecvt    */\nsysn = mvsvar('SYSNAME')                       /* get sysname         */\nred   = '01'x                                  /* set colour          */\nblue  = '02'x                                  /* attributes fo the   */\ngreen = '03'x                                  /* dynamic display     */\nwhite = '04'x                                  /* area                */\nturq  = '05'x                                  /*                     */\npink  = '06'x                                  /*                     */\nyellow = '07'x                                 /*                     */\ntitle = ' Storage Usage for 'sysn              /* set display title   */\n/*---------------- default values ------------------------------------*/\npsas = 0                                       /* start of psa        */\npsae = FFF                                     /* end of psa          */\npsak = 4                                       /* size of psa         */\nsyss = 1000                                    /* start of system     */\nsyse = 4FFF                                    /* end of system       */\nsysk = 16                                      /* size of system      */\nprivs = 5000                                   /* start of private    */\ngblrs = 5000                                   /* start of real priv. */\nnucoe = FFFFFF                                 /* end of R/O nuc.     */\nenucos = 1000000                               /* start of ext. nuc.  */\nmegabyte = 1024*1000\n/*---------------- get storage use details ---------------------------*/\ncvtgda = c2d(storage(d2x(cvt+560),4))          /* point to cvtgda     */\ncsa   = c2d(storage(d2x(cvtgda+112),4))        /* csa region size     */\ncsaf  = format((csa/megabyte),,2)              /* convert to Megs.    */\necsa  = c2d(storage(d2x(cvtgda+128),4))        /* ex. csa size        */\necsaf = format((ecsa/megabyte),,2)             /* convert to Megs.    */\nsqa   = c2d(storage(d2x(cvtgda+148),4))        /* sqa region size     */\nsqaf  = format((sqa/megabyte),,2)              /* convert to Megs.    */\nesqa  = c2d(storage(d2x(cvtgda+156),4))        /* ex. sqa size        */\nesqaf = format((esqa/megabyte),,2)             /* convert to Megs.    */\npriv  = c2d(storage(d2x(cvtgda+164),4))        /* private region size */\nprivf = format((priv/megabyte),,2)             /* convert to Megs.    */\neprv  = c2d(storage(d2x(cvtgda+172),4))        /* ex. private size    */\neprvf = format((eprv/megabyte),,2)             /* convert to Megs.    */\ncsau  = c2d(storage(d2x(cvtgda+432),4))        /* csa used            */\ncsauf = format((csau/csa*100),,1)'%'           /* convert to Percent  */\necsau = c2d(storage(d2x(cvtgda+436),4))        /* ecsa used           */\necsauf = format((ecsau/ecsa*100),,1)'%'        /* convert to Percent  */\nsqau  = c2d(storage(d2x(cvtgda+440),4))        /* sqa used            */\nsqauf = format((sqau/sqa*100),,1)'%'           /* convert to Percent  */\nesqau = c2d(storage(d2x(cvtgda+444),4))        /* esqa used           */\nesqauf = format((esqau/esqa*100),,1)'%'        /* convert to Percent  */\ncsao  = c2d(storage(d2x(cvtgda+448),4))        /* csa overflow        */\ncsaof = format((csao/megabyte),,2)             /* convert to Megs.    */\necsao = c2d(storage(d2x(cvtgda+452),4))        /* ecsa overflow       */\necsaof = format((ecsao/megabyte),,2)           /* convert to Megs.    */\n/*---------------- get available 'slots' -----------------------------*/\ncvtasvt = c2d(storage(d2x(cvt+556),4))         /* point to cvtasvt    */\nsltf = c2d(storage(d2x(cvtasvt+480),4))        /* # slots free        */\nslti = c2d(storage(d2x(cvtasvt+484),4))        /* # slots initial     */\nsltn = c2d(storage(d2x(cvtasvt+488),4))        /* # slots not reusable*/\nmaxo = c2d(storage(d2x(cvtasvt+500),4))        /* # slots orginally   */\nmaxu = c2d(storage(d2x(cvtasvt+516),4))        /* # slots available   */\n\n/*----------------------- display the information --------------------*/\naddress ispexec                                /* set mode            */\n\"addpop row(2) column(2)\"                      /* start window        */\n\ndo until rc > 0\n  \"display panel(checkstr)\"                    /* display results     */\nend\n\n\"rempop\"                                       /* stop window         */\naddress tso                                    /* set mode            */\n\nexit\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SYS": {"ttr": 1795, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\x06O\\x01\\x02\\x06O\\x17\\x03\\x00\\x7f\\x00\\x7f\\x00\\x00\\xc4\\xc2\\xc2\\xd9\\xd6\\xe6\\xd5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-03-05T00:00:00", "modifydate": "2002-03-05T17:03:00", "lines": 127, "newlines": 127, "modlines": 0, "user": "DBBROWN"}, "text": "/* REXX */\n/**********************************************************************/\n/* this routine gets system information - version 1.0                 */\n/**********************************************************************/\n/*------------------ initialize global variables ---------------------*/\ntrace 0\naddress tso                                    /* set mode            */\nnumeric digits 30                              /* set decimal size    */\ncvt = c2d(storage(10,4))                       /* point to cvt        */\necvt = c2d(storage(d2x(cvt+140),4))            /* point to cvtecvt    */\nsysn = mvsvar('SYSNAME')                       /* get sysname         */\nred   = '01'x                                  /* set colour          */\nblue  = '02'x                                  /* attributes fo the   */\ngreen = '03'x                                  /* dynamic display     */\nwhite = '04'x                                  /* area                */\nturq  = '05'x                                  /*                     */\npink  = '06'x                                  /*                     */\nyellow = '07'x                                 /*                     */\ntitle = ' System Information for 'sysn         /* set display title   */\n/*---------------- get IPL time --------------------------------------*/\ncvtsmca = c2d(storage(d2x(cvt+196),4))         /* point to cvtsmca    */\nipltime = c2d(storage(d2x(cvtsmca+336),4))     /* point to smcaitme   */\n/* ------- convert time from hundreds of seconds to hh:mm:ss -------- */\nipltime = ipltime%100                          /* remove 100's        */\niplhrs = ipltime%3600                          /* calculate hours     */\niplhrs = right(iplhrs,2,'0')                   /* add leading zero    */\nipltime = ipltime//3600                        /* calculate minutes   */\niplmin = ipltime%60                            /* decimal convertion  */\niplmin = right(iplmin,2,'0')                   /* add leading zero    */\niplsec = ipltime//60                           /* calculate seconds   */\niplsec = right(iplsec,2,'0')                   /* add leading zero    */\nipltime= iplhrs':'iplmin':'iplsec              /* build string        */\n/* ------- convert julian days to day of the week ------------------- */\nipldate = c2x(storage(d2x(cvtsmca+340),4))     /* point to smcaidte   */\nparse var ipldate . 3 yy 5 ddd 8 .             /* strip out year, day */\njuldate = yy||ddd                              /* build julain date   */\nipldate = date(,''juldate'','j')               /* Get the date        */\niplday  = date(w,''juldate'','j')              /* Get the day         */\n/*---------------- get IPL info --------------------------------------*/\nihaipa = c2d(storage(d2x(ecvt+392),4))         /* point to ecvtipa    */\nipll = storage(d2x(ihaipa+16),8)               /* ipl load parameters */\nhcdu = storage(d2x(ihaipa+16),4)               /* hcd unit address    */\nhcdm = storage(d2x(ihaipa+20),2)               /* hcd load member     */\nlpar = storage(d2x(ihaipa+32),8)               /* lpar name           */\nipld = strip(storage(d2x(ihaipa+48),44))       /* ipl parm DSN        */\niplu = storage(d2x(ihaipa+92),4)               /* ipl load parm addr. */\nhcds = storage(d2x(ihaipa+96),2)               /* iodf suffix         */\nhcdq = storage(d2x(ihaipa+99),8)               /* hcd hi-level qual.  */\nsyssf = strip(storage(d2x(ihaipa+160),2))      /* ieasysxx suffixes   */\nmvol = storage(d2x(ihaipa+224),6)              /* mcat volser         */\nmcat = storage(d2x(ihaipa+234),44)             /* master catalog name */\nsymsf = strip(storage(d2x(ihaipa+288),63))     /* ieasymxx suffixes   */\npdsn = strip(storage(d2x(ihaipa+416),44))      /* parmlib dsn         */\npvol = storage(d2x(ihaipa+461),6)              /* parmlib volser      */\nipln = ipld'(LOAD'hcdm')'                      /* build iplparm dsn   */\n/*---------------- get IODF DSN --------------------------------------*/\ncvtixavl = c2d(storage(d2x(cvt+124),4))        /* point to cvtixavl   */\niociovtp = c2d(storage(d2x(cvtixavl+208),4))   /* point to iociovtp   */\nhcdn   = strip(storage(d2x(iociovtp+288),15))  /* point to iodf name  */\ncda      = c2d(storage(d2x(iociovtp+24),4))    /* point to cda        */\nhcdn     = strip(storage(d2x(cda+32),15))      /* point to iodf name  */\nconfigid = storage(d2x(cda+92),8)              /* point to config     */\nedt      = storage(d2x(cda+104),2)             /* point to edt        */\n/*--------------------- get the sysres volser ------------------------*/\nucb    = c2d(storage(d2x(cvt+48),4))           /* point to cvtsmca    */\nsysres = storage(d2x(ucb+28),6)                /* sysres volume       */\nsysrs2 = mvsvar('symdef','sysr2')              /* get second sysres   */\n\nif sysrs2 = '' then sysrs2 = '-none-'          /* no second sysres    */\n\n/*---------------- get the unit address ------------------------------*/\nsaddr = getucb(sysres)                         /* sysres device no.   */\n\nif sysrs2 \u00ac= '-none-' then saddr2 = getucb(sysrs2) /* no second sysres*/\n\npaddr = getucb(pvol)                           /* parmlib device no.  */\nmaddr = getucb(mvol)                           /* mcat   device no.   */\n\n/*----------------------- get the volser -----------------------------*/\niplv = getvol(iplu)                            /* iplparm volser      */\nhcdv = getvol(hcdu)                            /* iodf volser         */\n/*---------------- get numbers of cpu's ------------------------------*/\ncvtscpin = c2d(storage(d2x(cvt+832),4))        /* point to cvtscpin   */\ncpuno = c2d(storage(d2x(cvtscpin+16),2))       /*  get no. of cpu's   */\n/*---------------- get cpu info --------------------------------------*/\ncvthid = c2d(storage(d2x(cvt+1068),4))         /* point to cvthid     */\ncputype = strip(storage(d2x(cvthid+28),4))     /* get cpu type        */\ncpumod = strip(storage(d2x(cvthid+32),3))      /* get cpu model       */\ncpu = cputype'-'cpumod\n/*---------------- get storage values --------------------------------*/\ncvtrlstg = c2d(storage(d2x(cvt+856),4))        /* point to cvtrlstg   */\nrealm  = cvtrlstg/1024                         /* convert to MB.      */\ncvtrcep = c2d(storage(d2x(cvt+1168),4))        /* point to cvtrcep    */\nxpand  = c2d(storage(d2x(cvtrcep+160),4))      /* no. expanded stor.  */\nxpand  = xpand*4/1024                          /* convert to MB.      */\n/*---------------- set up cpu display fields -------------------------*/\nx = syscpus('cpuid.')\n\ndo cntr = 1 to cpuid.0                         /* pack cpu id. into   */\n  temp_var_name = 'cpu'||cntr                  /* display string      */\n  interpret temp_var_name '= substr(cpuid.cntr,3,6)'\nend\n\n/*----------------------- display the information --------------------*/\naddress ispexec                                /* set mode            */\n\"addpop row(2) column(2)\"                      /* start window        */\n\ndo until rc > 0\n  \"display panel(checkstm)\"                    /* display results     */\nend\n\n\"rempop\"                                       /* stop window         */\naddress tso                                    /* set mode            */\n\nexit\n/*--------------------- get device number from UCB -------------------*/\ngetucb: procedure expose vol dnum\narg vol                                        /* get volume name     */\ndnum = '0000'                                  /* initilaize device   */\naddress LINKPGM \"GETUADDR vol dnum\"            /* call program        */\nreturn dnum\n/*--------------------- get volser from UCB --------------------------*/\ngetvol: procedure expose vol dnum\narg dnum                                       /* get device address  */\nvol= 'XXXXXX'                                  /* initilaize volser   */\naddress LINKPGM \"GETUADDR vol dnum\"            /* call program        */\nreturn vol\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "VER": {"ttr": 1798, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\x06O\\x01\\x02\\x06O\\x17\\x03\\x00Q\\x00Q\\x00\\x00\\xc4\\xc2\\xc2\\xd9\\xd6\\xe6\\xd5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-03-05T00:00:00", "modifydate": "2002-03-05T17:03:00", "lines": 81, "newlines": 81, "modlines": 0, "user": "DBBROWN"}, "text": "/* REXX */\n/**********************************************************************/\n/* this routine gets software version information - version 1.0       */\n/**********************************************************************/\n/*------------------ initialize global variables ---------------------*/\ntrace 0\narg optn\naddress tso                                    /* set mode            */\nnumeric digits 30                              /* set decimal size    */\nsysn = mvsvar('SYSNAME')                       /* get sysname         */\nred   = '01'x                                  /* set colour          */\nblue  = '02'x                                  /* attributes fo the   */\ngreen = '03'x                                  /* dynamic display     */\nwhite = '04'x                                  /* area                */\nturq  = '05'x                                  /*                     */\npink  = '06'x                                  /*                     */\nyellow = '07'x                                 /*                     */\ntitle = ' Version Information for 'sysn        /* set display title   */\n/*--------------------- get system variable information --------------*/\ncvt = c2d(storage(10,4))                       /* point to cvt        */\necvt = c2d(storage(d2x(cvt+140),4))            /* point to cvtecvt    */\nosysd = mvsvar('sysopsys')                     /* get OS level        */\nosys1 = substr(osysd,1,6)                      /* format              */\nosys2 = substr(osysd,8,8)\nosysv = osys1' 'osys2\nfmid = substr(osysd,17,7)                      /* get FMID level      */\njesd = sysvar('sysjes')                        /* format              */\njesv = substr(jesd,9,8)\ndfpv = substr(mvsvar('sysdfp'),4,8)\nhsm  = sysvar('syshsm')                        /* get HSM level       */\nhsml = right(substr(hsm,1,1),2,0)              /* format              */\nhsmr = substr(hsm,2,2)\nhsmm = right(substr(hsm,4,1),2,0)\nhsmv = hsml'.'hsmr'.'hsmm\nracf = sysvar('syslracf')                      /* get RACF level      */\nracfl = right(substr(racf,1,1),2,0)            /* format              */\nracfr = substr(racf,2,2)\nracfm = right(substr(racf,4,1),2,0)\nracfv = racfl'.'racfr'.'racfm\ntso  = sysvar('systsoe')                       /* get TSO level       */\ntsol = right(substr(tso,1,1),2,0)              /* format              */\ntsor = substr(racf,2,2)\ntsom = right(substr(tso,4,1),2,0)\ntsov = tsol'.'tsor'.'tsom\nsmfid = mvsvar('syssmfid')                     /* get SMFID           */\nsplx = mvsvar('sysplex')                       /* get Sysplex Id.     */\nmvs = mvsvar('sysmvs')                         /* get MVS level       */\n/*---------------- get the vtam version and release ------------------*/\natcvt = c2d(storage(408,4))                    /* point to atcvt      */\nvtamr = storage(d2x(atcvt+2),1)                /* get vtam version    */\nvtaml = storage(d2x(atcvt+3),1)                /* get vtam release    */\nvtamv = vtamr'.'vtaml                          /* build display       */\n/*---------------- get dfa version------------------------------------*/\ncvtdfa  = c2d(storage(d2x(cvt+1216),4))        /* get cvtdfa address  */\ndfaprod = c2x(storage(d2x(cvtdfa+16),1))       /* product type        */\ndfaver  = c2x(storage(d2x(cvtdfa+17),1))       /* version             */\ndfarlse = c2x(storage(d2x(cvtdfa+18),1))       /* release             */\ndfamod  = c2x(storage(d2x(cvtdfa+19),1))       /* modification        */\n\nif dfamod = '' then dfamod = 0                 /* add modification    */\n\ndfsms = dfaver'.'dfarlse'.'dfamod              /* build display       */\n\n/*----------------------- get the ispf level -------------------------*/\naddress ispexec                                /* set mode            */\nvget ZENVIR                                    /* get ispf version    */\nispfv = substr(ZENVIR,6,3)                     /* build display       */\ndrop ZENVIR                                    /* drop ispf variable  */\n\n/*----------------------- display the information --------------------*/\naddress ispexec                                /* set mode            */\n\"addpop row(2) column(6)\"                      /* start window        */\n\ndo until rc > 0\n  \"display panel(checkver)\"                    /* display results     */\nend\n\n\"rempop\"                                       /* stop window         */\naddress tso                                    /* set mode            */\n\nexit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT543/FILE543.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT543", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}