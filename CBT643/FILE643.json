{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012521000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 764218, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 7, "INMDSNAM": "CBT.V500.FILE643.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 764218, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 764218, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE643.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x0c\\t'", "DS1TRBAL": "b')\\xf8'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x04\\x95\\x00\\x07\\x04\\x96\\x00\\x04\\x00\\r'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04=\\x00\\x00\\x01\\x03\\x19_\\x01\\x03\\x19_\\t2\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf6\\xf1@@@'", "ispf": {"version": "04.61", "flags": 0, "createdate": "2003-07-14T00:00:00", "modifydate": "2003-07-14T09:32:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-461"}, "text": "REGULAR CBT TAPE - VERSION 461    FILE:  643\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT461.FILE643\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 10 MEMBERS COUNTED; CUMULATIVE SIZE IS 6,625 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   07/14/03    09:32:16    GMT-5:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$$CPYRT": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x009\\x01\\x03\\x19O\\x01\\x03\\x19_\\t#\\x00\\t\\x00\\x05\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2003-07-13T00:00:00", "modifydate": "2003-07-14T09:23:39", "lines": 9, "newlines": 5, "modlines": 0, "user": "SBGOLOB"}, "text": "The software on this file is copyrighted by Paul A. Scott, but\npermission has been granted by the author, to include these\nmaterials on the CBT tapes.  Ownership is retained by the author,\nbut it is permissible to download and use this software, provided\nthat the copyright notices are included.\n\n      email:         \"Paul A. Scott\" <pscott@skycoast.us>\n      web site:      http://skycoast.us/pscott/software/mvs/\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$DOC": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00G\\x01\\x03\\x19O\\x01\\x03\\x19O\\x14\\x00\\x00\\x7f\\x00x\\x00\\x00\\xd7\\xc1\\xe2\\xc3\\xd6\\xe3\\xe3@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2003-07-13T00:00:00", "modifydate": "2003-07-13T14:00:47", "lines": 127, "newlines": 120, "modlines": 0, "user": "PASCOTT"}, "text": "                    MVS SoftwareMVS Software\n\nSource Code\n\nHere you'll find a collection of useful programs I've written on IBM's\nMVS operating system.\n\nMacro Library  -  members are part of SRCLIB\n\nMy experience with the stack architecture of 8-bit\nmicroprocessors---as well as the Concept 14 macros---inspired me\nto write a macro library that simulates a stack architecture for\nS/390. The macro library is assigned the acronym PSM, which\nstands for Pseudo Stack Machine or Paul Scott's Macros depending\non my mood. The PSM macros used in the code exhibits are:\n\nPENTER    --- Module entry linkage with optional stack construction\nPEXIT     --- Module exit linkage with auto stack destruction\nPCALL     --- Call external entry point reentrantly\nPUSHREG   --- Push one or more registers onto stack\nPOPREG    --- Pop one or more registers from stack\n\nCopyright -- 1988-1989, Paul A. Scott, All rights reserved. |\nComments (0)\n\nJCL String Compare\n\nPSU001 --- Sets the step condition code to the boolean result of\nthe string comparison specified in the PARM field. This allows\nconditional execution of subsequent steps based on the comparison\n\nExample:\n//STEP0001 EXEC PGM=PSU001,PARM=('&DAY,EQ,FRI')\n//*\n\nNotes:\n  Either string may be a sybolic parameter (very handy)\n  Allowed conditionals are EQ, NE, GT, GE, LT, LE\n  Both strings are treated as characters even if all numeric\n  The shorter of two otherwise equal strings is the lesser\n  The step return code is 0 if the condition is true, 1 if false\n\nCopyright -- 1988-1989, Paul A. Scott, All rights reserved. |\nComments (0)\n\nJCL Instream Data\n\nPSU002 --- Writes one or more lines of text in the PARM field to\nSYSOUT. The first character of the PARM field is the line\nseparator and is not included in the output.\n\nExample:\n//STEP0001 EXEC PGM=PSU002,\n//            PARM=('\\',                       RECORD SEPARATOR\n//            ' C INDD=SYSUT1,OUTDD=SYSUT2\\',  CARD #1\n//            ' S M=(MEMBERA,MEMBERB) ')       CARD #2\n//SYSOUT  DD  DSN=&&IEBCOPY,UNIT=VIO, ...\n//*\n\nNotes:\n  Sybolic parameters are allowed\n  The PARM field is limited to 100 characters\n  If necessary, use multiple steps with SYSOUT DD DISP=MOD,...\n  The step return code is always 0\n  Any failure results in a system ABEND code\n\nCopyright -- 1988-1989, Paul A. Scott, All rights reserved. |\nComments (0)\n\nJCL Dataset Editor\n\nPSU003 --- Copy SYSUT1 to SYSUT2 while replacing one string with\nanother. Specify one or more \"old=new\" strings in the PARM field,\ndelimited by a comma.  All occurences of old in SYSUT1 will be\nreplaced with new in SYSUT2 during the copy operation.\n\nExample:\n//STEP0001 EXEC PGM=PSU003,\n//            PARM=('&&PREFIX=PROD.LOAN.SL',\n//            '&&UNIT=SYSDA')\n//SYSIN    DD  DUMMY,DCB=(RECFM=FB,LRECL=80,BLKSIZE=80)\n//SYSUT1   DD  DSN=PROD.CONTROL.JCL(LOAN001),DISP=SHR\n//SYSUT2   DD  DSN=PROD.CONTROL.JCL(LOAN001),DISP=SHR\n//*\n\nNotes:\n  Symbolic parameters are allowed\n  A string containing & must be specified as &&\n  A search string begining with & obeys JCL symbolic replacement\n  rules of concatenation\n  The PARM field is limited to 100 characters\n  SYSIN may be used to specify up to 500 replacement strings\n  (source configurable)\n  The PARM and SYSIN strings are combined, if present\n  If SYSUT2 and SYSUT1 are identical, then records are updated in\n  place\n\nCopyright -- 1988-1989, Paul A. Scott, All rights reserved. |\nComments (0)\n\nCalendar Generator\nPSU004 --- Generate a calendar for the current (or specified) year.\n\nExample:\n//STEP0001 EXEC PGM=PSU004,PARM=('1989')\n//SYSOUT    DD  SYSOUT=*\n//*\n\nAlternately, use a CLIST to generate a calendar in ISPF edit.\n\nNotes:\n  Specify a 4-digit year in the PARM field\n  If the PARM is blank or invalid, the current year is substituted\n  The calendar is written to DD name SYSOUT\n  SYSOUT is forced to DCB=(RECFM=FBA,LREC=121,BLKSIZE=6171)\n  The return code is always 0\n\nCopyright -- 1988-1989, Paul A. Scott, All rights reserved. |\nComments (0)\n\nOnce you've had a chance to review the code above, you may want to grab the\nInstallation Job Stream that will install all of the programs, plus an\nIVP and documentation. Change only the JOB statement and the parameters\non the first PROC statement. The Job Stream is set up to take care of\nthe rest.\n\nImportant: The installation requires MVS/ESA or above and Assembler H.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$MACDOC": {"ttr": 523, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00$\\x01\\x03\\x19O\\x01\\x03\\x19O\\x13U\\x01\\xb1\\x01\\xb1\\x00\\x00\\xd7\\xc1\\xe2\\xc3\\xd6\\xe3\\xe3@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2003-07-13T00:00:00", "modifydate": "2003-07-13T13:55:24", "lines": 433, "newlines": 433, "modlines": 0, "user": "PASCOTT"}, "text": "             MVS Software Documentation --- PSM Macro Library\n\n                     MVS Software Documentation\n\n\nCopyright -- 1988-2003, Paul A. Scott, All rights reserved.\n\nPSM Macro Library\n\nQuick Links:  PCALL   PENTER   PEXIT   POPREG   PUSHREG   ZIC   ZICM\n\nPCALL --- Call External Entry Point\nOne of the advantages to using the PSM macros is the simplicity\nthey provide.  Although PCALL is a replacement for the standard\nsystem CALL macro, and performs the same function, it is greatly\nsimplified.\n\nPCALL does not require separate list and execute forms. It is\nimplicitly reentrant, building its parameter list dynamically on\nthe stack. You need only supply an entry point and any optional\nparameters.  A prerequiste to using PCALL is a consistent use of\nPENTER and PEXIT throughout your code. That is, there must be a\nstack available when you invoke PCALL.\n\nSyntax:\n\nlabel    PCALL entrypoint[,(parm[[,parm]...])]\n\nParameters:\n\n      label  Optional.  Code label to assign a location symbol to the\n      first expanded instruction.\n\n      entrypoint  Required.  Specify the name of an external symbol\n      to which the program should transfer control..\n\n      parm  Optional.  Specify one or more of: a constant, literal,\n      equated symbol, or location symbol; essentially anything\n      that the LA instruction can generate a base/displacement\n      for. You may also specify a register if it is enclosed in\n      parentheses.\n\n      The entire list of parameters must be enclosed in parentheses.\n\nCopyright -- 1988-2003, Paul A. Scott, All rights reserved.\n\nPENTER --- Program Entry Linkage\n\nThere is probably no other macro solution more often reinvented\nthan program entry and exit code, and there's always a \"good\"\nreason for doing so. This is no exception. In order to implement\na pseudo-stack machine, it was necessary to provide automatic\nstack creation, destruction and management. PENTER is part of\nthis solution.\n\nPENTER is used in four ways: (1) conventional program linkage;\n(2) PSM program linkage with stack creation; (3) PSM program\nlinkage without stack creation; (4) \"C\" style program linkage.\nThe latter usage supports an unfinished C compiler and runtime\nlibrary project, and should be avoided. In most cases, you'll use\nPSM linkage, although conventional linkage is available if\nneeded. Note that PSM linkage is fully compatible with\nconventional linkage.\n\nIn addition to program linkage and stack allocation/management,\nPENTER also provides automatic register equates, code\naddressability, and allocation of local storage. This latter\nfeature means PENTER is reentrant (as are all PSM macros), and\nassists the programmer in writing reentrant code.\n\nWhen multiple PENTER/PEXIT pairs are used in a single source\nmodule, there is no need to DROP register addressability between\nthem. PENTER will automatically DROP any previously generated\nUSING.\n\nPENTER generates standard register equates. However, no equate is\ngenerated for the register assigned to the stack pointer (global\nsymbol &SP) or the base pointer (global symbol &BP). This will\nhelp to prevent inadvertantly destroying the stack. PENTER uses\nthe global symbol &REGS to both announce its equates and check\nfor equates from the IBM supplied YREGS macro. If it can be\ndetermined that register equates have already been defined,\nPENTER will issue a warning to avoid using the registers assigned\nto &BP and &SP.\n\nSyntax:\n\nlabel    PENTER type[,BASE=12|reg|(reg,reg,...)]\n                [,VARS=(addr,length)][,STACK=n]\n\nParameters:\n\n      label  Required.  Code label to name the CSECT for this\n      entry point. Do not code a CSECT statement; PENTER will\n      automatically generates one for the label supplied.\n\n      type  Optional.  May be blank or one of: MAIN, FUNC, CMAIN\n\n             blank  Conventional program linkage. Storage is\n            obtained for a save area, VARS local storage space\n            (if requested), and a minimal stack to support the\n            other PSM macros. The STACK parameter is not\n            permitted.  Sub-programs of this program should not\n            use type FUNC; they should use conventional program\n            linkage.\n\n             MAIN  PSM program linkage. Storage is obtained for a\n            save area, VARS local storage, and a full stack. The\n            STACK parameter must request enough stack to meet the\n            needs of this program and all sub-programs of type\n            FUNC. Use MAIN for programs directly invoked by the\n            system, or by LINK and ATTACH.\n\n             FUNC  PSM program linkage. This program will use the\n            stack passed by the caller, and will pass the stack\n            pointer to called programs. The program save area and\n            any VARS local storage is carved off the stack. Use\n            FUNC for sub-programs of MAIN and other FUNC\n            routines.\n\n             CMAIN  Not fully implemented. Do not use CMAIN.\n\n      BASE=12|reg|(reg,...)  Optional.  By default, register 12 is\n      used as the program base register. If more base registers\n      are required, you can use BASE to provide more. However, if\n      you do, you must specify all the base registers, including\n      the first one. This is unlike VARS which always provides\n      the first base register and cannot be overridden. For\n      example:\n\n      ... ,BASE=12\n\n      ... ,BASE=(12,11)\n\n      Note that when mulitple base registers are given, they must\n      be separated with commas and the entire group of registers\n      surrounded by parentheses.  If only one register is given,\n      the parentheses are optional.\n\n      Important: Never use a higher numbered register in your\n      program than the highest numbered base register! This is\n      because of an undocumented feature (a real feature, not a\n      bug). The only exceptions are registers 14 and 15, which\n      may be used safely. For example, if your highest base\n      register is 5, then registers 6 through 13 are off limits\n      within your program! It is therefore recommended to use\n      register 12 as a base register, unless you are keenly aware\n      of the circumstances.\n\n      STACK=n  Optional.  Specify the number of 4K blocks of\n      storage to allocate to the stack. This must include enough\n      space for local stack operations (such as PUSHREG and\n      POPREG), and all program linkage, local variables, and\n      stack operations performed by called programs. Local\n      variable storage for this program (from VARS) is then added\n      to the total.\n\n      Unfortunately, there is no easy way to determine the\n      correct value, and no rule of thumb would suffice. However,\n      stack sizes of 4K (STACK=1) to 8K (STACK=2) are typical\n      unless large amounts of local storage are used, or a\n      program is highly recursive.\n\n      There is currently no stack overflow/underflow checking.\n\n      VARS=(addr,length)  Optional.  Allocate space for local\n      storage and provide addressability. The addr parameter\n      should be a DSECT label, and length is the DSECT length\n      (usually specified as a symbol created with a statement at\n      the end of the DSECT such as \"VARSLEN EQU *-label\").\n\n      Addressability is automatically established on the DSECT\n      using global symbol &BP (the base pointer---defaults to\n      register 13). This is usually sufficient to cover local\n      storage. However, if additional base registers are\n      required, they may be appended to the end of the parameter\n      list separated by commas. You cannot override the first\n      base register; it is always defined as &BP. For example:\n\n        ... ,VARS=(VARDSECT,VARLEN,4)\n\n      would generate \"USING VARDSECT,&BP,4\" to provide 8192 bytes\n      of addressability. Note that there is a small amount of\n      storage carved out of the total for save area and overhead,\n      so it is possible that if you are very, very close to the\n      limit, you might need to allocate a second base register..\n\n      Do not specify a register assigned to the &BP or &SP global\n      symbols. These are registers 13 and 3 by default. PENTER\n      should admonish you if you try, but to avoid insult, please\n      don't show it any disrespect.\n\n\n\nCopyright -- 1988-2003, Paul A. Scott, All rights reserved.\n\nPEXIT --- Program Exit Linkage\n\nUnlike the Hotel California where you can never leave, when you\nPENTER you must eventually PEXIT.\n\nPEXIT undoes the effects of PENTER. It's a good idea to pack a\nsouvenir on your way out---in the form of a return code---but if\nyou don't, then one of zero value will be supplied for you.\n\nPEXIT will unwind the stack and automatically free any storage\nobtained by its corresponding PENTER.\n\nJust before returning to the caller, PEXIT leaves behind a\nbreadcrumb by setting the rightmost bit in the return address\nfield of the caller's save area. This might be useful in the\nextremely unlikely event your program dumps and you're\nwondering---while examing the storage dump---if the program was\ncalled at some time in the recent past.\n\nNote that PEXIT is designed to be coded only once for each\nPENTER. Do not code more than one PEXIT without an intervening\nPENTER.\n\nSyntax:\n\n[label]  PEXIT [RC=(reg)|n]\n\nParameters:\n\n      label  Optional.  Code label to assign a location symbol to\n      the first expanded instruction.\n\n      RC=(reg)|n  Optional.  To supply a return code in a\n      register, specify the register within parentheses. For\n      example:\n\n             PEXIT RC=(15)  Exit using the return code in register 15.\n\n            To specify a numeric return code, specify the number\n            directly or code an equate symbol. For example:\n\n             PEXIT RC=4  Exit with return code 4.\n\n             PEXIT RC=ERROR4  Exit with the value of equate\n             symbol ERROR4.\n\n            There is no support for supplying a return code\n            directly from a memory location. Instead, load the\n            value into a register and invoke PEXIT with register\n            notation.\n\n            If a return code is not supplied, then RC=0 is\n            automatically generated.\n\n\nCopyright -- 1988-2003, Paul A. Scott, All rights reserved.\n\nPUSHREG --- Push Registers Onto Stack\n\nPUSHREG will push one or more registers, or range of registers,\nonto the stack.\n\nThe stack pointer &SP is incremented when the operation is\ncomplete.  Registers are pushed from left to right as coded on\nthe MACRO instruction.\n\nThe condition code in the PSW is preserved across PUSHREG.\nHowever, it is recommended that you don't depend on the condition\ncode being static.\n\nNo registers other than &SP are changed.\n\nSyntax:\n\n[label]  PUSHREG reg|(reg,reg)[[,reg|(reg,reg)]...]\n\nParameters:\n\n      label  Optional.  Code label to assign a location symbol to\n      the first expanded instruction.\n\n      reg  At least one required.  Code reg as a number from 0 to\n      15, or one of the symbols R0 through R15.\n\n      Code a range of registers by specifying two registers\n      separated by a comma and enclosed in parentheses. If the\n      first register in a range is higher than the second\n      register, the range wraps through registers 15 and 0.\n\n      The rules are best explained by example:\n\n             PUSHREG R14  pushes register 14 onto the stack.\n             PUSHREG R9,(R15,R1)  pushes registers 9, 15, 0, and\n                   1 onto the stack.\n\n\nCopyright -- 1988-2003, Paul A. Scott, All rights reserved.\n\nPOPREG --- Pop Registers From Stack\n\nPOPREG will pop one or more registers, or range of registers,\nfrom the stack.\n\nThe stack pointer &SP is decremented when the operation is\ncomplete.\n\nRegisters are popped from right to left as coded on the MACRO\ninstruction, exactly opposite the direction used by PUSHREG. This\nallows you to code the same operands on both PUSHREG and POPREG.\n\nUse great care when the POPREG parameter list does not exactly\nmatch its corresponding PUSHREG. In particular, you cannot\nsuccessfully pop registers pushed earlier than the last unpopped\nregister. Although it is possible to have more than one POPREG\nundo the effect of a single PUSHREG, this practice is strongly\ndiscouraged.\n\nThe condition code in the PSW is not preserved across POPREG; it\nwas decided that speed was the more important goal.\n\nNo registers other than &SP and those being popped are changed.\n\nSyntax:\n\n[label]  POPREG reg|(reg,reg)[[,reg|(reg,reg)]...]\n\nParameters:\n\n      label  Optional.  Code label to assign a location symbol to\n      the first expanded instruction.\n\n      reg  At least one required.  Code reg as a number from 0 to\n      15, or one of the symbols R0 through R15.\n\n      Code a range of registers by specifying two registers\n      separated by a comma and enclosed in parentheses. If the\n      first register in a range is higher than the second\n      register, the range wraps through registers 15 and 0.\n\n      The rules are best explained by example:\n\n             POPREG R14  pops register 14 from the stack.\n             POPREG R9,(R15,R1)  pops registers 1, 0, 15, and 9\n                  from the stack.\n\n\nCopyright -- 1988-2003, Paul A. Scott, All rights reserved.\n\nZIC --- Zero and Insert Character\n\nIt is quite common when using the IC instruction to first clear\nthe target register. ZIC is designed to do this automatically,\nrelieving the programmer of that responsibility.\n\nAt first it seems like a simple task to simply clear the target\nregister before issuing IC. However, it is possible (although\nunlikely) that the target register is also a base or index\nregister used by IC. In that case, it is necessary to mask off\nthe unused bits in the target register after the IC instruction\nis completed. Because the masking operation is slower, ZIC makes\nevery effort to clear the register before issuing IC.\n\nIf ZIC cannot determine that it is safe to clear the target\nregister first (faster), then it will mask off the unused bits\n(slower) after the fact. The programmer can assist ZIC by using\nbase-index-displacement notation whenever possible, but this is\nnot required.\n\nSyntax:\n\n[label]  ZIC reg,addr\n\nParameters:\n\n      label  Optional.  Code label to assign a location symbol to\n      the first expanded instruction.\n\n      reg  Required.  Code reg as a number from 0 to 15, or one\n      of the symbols R0 through R15. Of course, you shouldn't use\n      a register assigned to an active USING, or the base (&BP)\n      or stack (&SP) registers.\n\n      addr  Required.  A location sybmol referencing the address\n      of the character to insert. Alternately, the\n      base-index-displacement format may be used.\n\nZIC is coded in exactly the same manner as IC. There are no known\nproblems or side-effects.\n\nCopyright -- 1988-2003, Paul A. Scott, All rights reserved.\n\nZICM --- Zero and Insert Characters Under Mask\n\nIt is quite common when using the ICM instruction to first clear\nthe target register. ZICM is designed to do this automatically,\nrelieving the programmer of that responsibility.\n\nAt first it seems like a simple task to simply clear the target\nregister before issuing ICM. However, it is possible (although\nunlikely) that the target register is also a base register used\nby ICM. In that case, it is necessary to mask off the unused bits\nin the target register after the ICM instruction is completed.\nBecause the masking operation is slower, ZICM makes every effort\nto clear the register before issuing ICM.\n\nIf ZICM cannot determine that it is safe to clear the target\nregister first (faster), then it will mask off the unused bits\n(slower) after the fact. The programmer can assist ZICM by using\nregister notation whenever possible, but this is not required.\n\nSyntax:\n\n[label]  ZICM reg,mask,addr\n\nParameters:\n\n      label  Optional.  Code label to assign a location symbol to\n      the first expanded instruction.\n\n      reg  Required.  Code reg as a number from 0 to 15, or one\n      of the symbols R0 through R15. Of course, you shouldn't use\n      a register assigned to an active USING, or the base (&BP)\n      or stack (&SP) registers.\n\n      mask  Required.  A value from 0 to 16 representing the byte\n      or bytes in reg that will participate in the insert\n      operation. Typically, you would use binary representation,\n      such as B'1111' (all bytes participate).\n\n      addr  Required.  A location sybmol referencing the address\n      of the character(s) to insert. Alternately, the\n      base-displacement format may be used.\n\nZICM can be coded in exactly the same manner as ICM. There are no\nknown problems or side-effects.\n\nCopyright -- 1988-2003, Paul A. Scott, All rights reserved.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$ALTINST": {"ttr": 771, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x006\\x01\\x03\\x19O\\x01\\x03\\x19_\\t\"\\x00\\x17\\x00\\x0b\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2003-07-13T00:00:00", "modifydate": "2003-07-14T09:22:36", "lines": 23, "newlines": 11, "modlines": 0, "user": "SBGOLOB"}, "text": "//SBGOLOBL JOB (ACCT#),PDSLOAD,\n// NOTIFY=&SYSUID,\n// CLASS=B,MSGCLASS=X,COND=(1,LT)\n//*\n//*    ALTERNATE INSTALL OF PAUL SCOTT'S LIBRARIES\n//*\n//RUNLIB EXEC PGM=IKJEFT01\n//SYSTSPRT DD SYSOUT=*\n//SYSTSIN DD *\n RECEIVE INDS('SBGOLOB.CBT461.FILE643(RUNLIB)')\n DSN('SBGOLOB.PSM.RUNLIB') VOL(DATA02) UNIT(SYSALLDA)\n/*\n//SRCLIB EXEC PGM=PDSLOAD          /* FROM FILE 093 OR 035 LOADMOD)\n//STEPLIB  DD DISP=SHR,DSN=SBGOLOB.PSM.RUNLIB\n//SYSUT1   DD DISP=SHR,DSN=SBGOLOB.CBT461.FILE643(SRCLIB)\n//SYSPRINT DD SYSOUT=*\n//SYSUT2   DD DSN=SBGOLOB.PSM.SRCLIB,\n//            DISP=(NEW,CATLG,DELETE),\n//            UNIT=SYSALLDA,VOL=SER=DATA02,\n//            SPACE=(TRK,(15,15,44),RLSE),\n//            DCB=(RECFM=FB,LRECL=80,BLKSIZE=3200)\n//*\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "@FILE643": {"ttr": 773, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04=\\x00\\x00\\x01\\x03\\x19_\\x01\\x03\\x19_\\t1\\x00f\\x00f\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf6\\xf1@@@'", "ispf": {"version": "04.61", "flags": 0, "createdate": "2003-07-14T00:00:00", "modifydate": "2003-07-14T09:31:00", "lines": 102, "newlines": 102, "modlines": 0, "user": "CBT-461"}, "text": "//***FILE 643 is from Paul A. Scott and contains some programs      *   FILE 643\n//*           and macros he has written.  Documentation for these   *   FILE 643\n//*           is included below.  Additionally, see members $$DOC,  *   FILE 643\n//*           $$MACDOC, and $ALTINST in this pds.                   *   FILE 643\n//*                                                                 *   FILE 643\n//*           email:      \"Paul A. Scott\" <pscott@skycoast.us>      *   FILE 643\n//*           web site:   http://skycoast.us/pscott/software/mvs/   *   FILE 643\n//*                                                                 *   FILE 643\n//*                         MVS Software                            *   FILE 643\n//*                                                                 *   FILE 643\n//*     Source Code                                                 *   FILE 643\n//*                                                                 *   FILE 643\n//*     Here you'll find a collection of useful programs I've       *   FILE 643\n//*     written on IBM's MVS operating system.                      *   FILE 643\n//*                                                                 *   FILE 643\n//*     Macro Library  -  members are part of SRCLIB                *   FILE 643\n//*                                                                 *   FILE 643\n//*     My experience with the stack architecture of 8-bit          *   FILE 643\n//*     microprocessors---as well as the Concept 14                 *   FILE 643\n//*     macros---inspired me to write a macro library that          *   FILE 643\n//*     simulates a stack architecture for S/390. The macro         *   FILE 643\n//*     library is assigned the acronym PSM, which stands for       *   FILE 643\n//*     Pseudo Stack Machine or Paul Scott's Macros depending       *   FILE 643\n//*     on my mood. The PSM macros used in the code exhibits        *   FILE 643\n//*     are:                                                        *   FILE 643\n//*                                                                 *   FILE 643\n//*     PENTER    --- Module entry linkage with optional stack      *   FILE 643\n//*                   construction                                  *   FILE 643\n//*     PEXIT     --- Module exit linkage with auto stack           *   FILE 643\n//*                   destruction                                   *   FILE 643\n//*     PCALL     --- Call external entry point reentrantly         *   FILE 643\n//*     PUSHREG   --- Push one or more registers onto stack         *   FILE 643\n//*     POPREG    --- Pop one or more registers from stack          *   FILE 643\n//*                                                                 *   FILE 643\n//*     JCL String Compare                                          *   FILE 643\n//*                                                                 *   FILE 643\n//*     PSU001 --- Sets the step condition code to the boolean      *   FILE 643\n//*     result of the string comparison specified in the PARM       *   FILE 643\n//*     field. This allows conditional execution of subsequent      *   FILE 643\n//*     steps based on the comparison                               *   FILE 643\n//*                                                                 *   FILE 643\n//*     Example:                                                    *   FILE 643\n//*     //STEP0001 EXEC PGM=PSU001,PARM=('&DAY,EQ,FRI')             *   FILE 643\n//*     //*                                                         *   FILE 643\n//*                                                                 *   FILE 643\n//*                                                                 *   FILE 643\n//*     JCL Instream Data                                           *   FILE 643\n//*                                                                 *   FILE 643\n//*     PSU002 --- Writes one or more lines of text in the PARM     *   FILE 643\n//*     field to SYSOUT. The first character of the PARM field      *   FILE 643\n//*     is the line separator and is not included in the            *   FILE 643\n//*     output.                                                     *   FILE 643\n//*                                                                 *   FILE 643\n//*     Example:                                                    *   FILE 643\n//*     //STEP0001 EXEC PGM=PSU002,                                 *   FILE 643\n//*     //            PARM=('\\',                       SEPARATOR    *   FILE 643\n//*     //            ' C INDD=SYSUT1,OUTDD=SYSUT2\\',  CARD #1      *   FILE 643\n//*     //            ' S M=(MEMBERA,MEMBERB) ')       CARD #2      *   FILE 643\n//*     //SYSOUT  DD  DSN=&&IEBCOPY,UNIT=VIO, ...                   *   FILE 643\n//*     //*                                                         *   FILE 643\n//*                                                                 *   FILE 643\n//*     JCL Dataset Editor                                          *   FILE 643\n//*                                                                 *   FILE 643\n//*     PSU003 --- Copy SYSUT1 to SYSUT2 while replacing one        *   FILE 643\n//*     string with another. Specify one or more \"old=new\"          *   FILE 643\n//*     strings in the PARM field, delimited by a comma.  All       *   FILE 643\n//*     occurences of old in SYSUT1 will be replaced with new       *   FILE 643\n//*     in SYSUT2 during the copy operation.                        *   FILE 643\n//*                                                                 *   FILE 643\n//*     Example:                                                    *   FILE 643\n//*     //STEP0001 EXEC PGM=PSU003,                                 *   FILE 643\n//*     //            PARM=('&&PREFIX=PROD.LOAN.SL',                *   FILE 643\n//*     //            '&&UNIT=SYSDA')                               *   FILE 643\n//*     //SYSIN    DD  DUMMY,DCB=(RECFM=FB,LRECL=80,BLKSIZE=80)     *   FILE 643\n//*     //SYSUT1   DD  DSN=PROD.CONTROL.JCL(LOAN001),DISP=SHR       *   FILE 643\n//*     //SYSUT2   DD  DSN=PROD.CONTROL.JCL(LOAN001),DISP=SHR       *   FILE 643\n//*     //*                                                         *   FILE 643\n//*                                                                 *   FILE 643\n//*     Calendar Generator                                          *   FILE 643\n//*                                                                 *   FILE 643\n//*     PSU004 --- Generate a calendar for the current (or          *   FILE 643\n//*                specified) year.                                 *   FILE 643\n//*                                                                 *   FILE 643\n//*     Example:                                                    *   FILE 643\n//*     //STEP0001 EXEC PGM=PSU004,PARM=('1989')                    *   FILE 643\n//*     //SYSOUT    DD  SYSOUT=*                                    *   FILE 643\n//*     //*                                                         *   FILE 643\n//*                                                                 *   FILE 643\n//*     Alternately, use a CLIST to generate a calendar in ISPF     *   FILE 643\n//*     edit.  CLIST called CALENDAR is supplied here.              *   FILE 643\n//*                                                                 *   FILE 643\n//*                                                                 *   FILE 643\n//*     Once you've had a chance to review the code above, you      *   FILE 643\n//*     may want to grab the Installation Job Stream that will      *   FILE 643\n//*     install all of the programs, plus an IVP and                *   FILE 643\n//*     documentation. Change only the JOB statement and the        *   FILE 643\n//*     parameters on the first PROC statement. The Job Stream      *   FILE 643\n//*     is set up to take care of the rest.                         *   FILE 643\n//*                                                                 *   FILE 643\n//*     Important: The installation requires MVS/ESA or above       *   FILE 643\n//*     and Assembler H.                                            *   FILE 643\n//*                                                                 *   FILE 643\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CALENDAR": {"ttr": 776, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00F\\x01\\x03\\x19O\\x01\\x03\\x19O\\x14\\x06\\x00\\x0c\\x00\\x0c\\x00\\x00\\xd7\\xc1\\xe2\\xc3\\xd6\\xe3\\xe3@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2003-07-13T00:00:00", "modifydate": "2003-07-13T14:06:46", "lines": 12, "newlines": 12, "modlines": 0, "user": "PASCOTT"}, "text": "PROC 0 YEAR()\n/*\n/* GENERATE CALENDAR FOR CURRENT (OR SPECIFIED) YEAR\n/* AUTHOR: P. SCOTT\n/*\nCONTROL NOMSG NOLIST NOFLUSH\nCLS\nALLOC F(SYSOUT) UNIT(SYSDA) TRACKS SPACE(1) DELETE REUSE\nCALL 'SYS1.PSM.RUNLIB(PSU004)' '&YEAR'\nISPEXEC  LMINIT DATAID(SYSOUT) DDNAME(SYSOUT) ENQ(SHR)\nISPEXEC  EDIT   DATAID(&SYSOUT)\nFREE F(SYSOUT)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PSMUPDTE": {"ttr": 778, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00%\\x01\\x03\\x19O\\x01\\x03\\x19O\\x14W\\x0b\\x8d\\x0b\\x87\\x00\\x00\\xd7\\xc1\\xe2\\xc3\\xd6\\xe3\\xe3@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2003-07-13T00:00:00", "modifydate": "2003-07-13T14:57:25", "lines": 2957, "newlines": 2951, "modlines": 0, "user": "PASCOTT"}, "text": "//PSMUPDTE JOB PSMUPDTE,'PSMUPDTE',CLASS=A,MSGCLASS=H\n//*\n//*    This is the original Jobstream to install and test\n//*     the programs described in member $$DOC.\n//*\n//*    See member $ALTINST as an alternate means of installing\n//*     these programs.\n//*\n//PROC     PROC PREFIX=SYS1,      <--- DATA SET NAME PREFIX\n//             JOBNAME=PSMIVP,    <--- IVP JOB NAME\n//             JOBCLASS=A,        <--- IVP JOB CLASS\n//             MSGCLASS=H,        <--- IVP MSG CLASS\n//             DISKUNIT=SYSDA     <--- STORAGE UNIT NAME\n//*\n//* ---------------------------------\n//* STEP 1 - DELETE PRODUCT LIBRARIES\n//* ---------------------------------\n//*\n//S1       EXEC PGM=IEFBR14\n//DD       DD  DSN=&PREFIX..PSM.SRCLIB,DISP=(MOD,DELETE,DELETE),\n//             UNIT=&DISKUNIT,SPACE=(TRK,0)\n//         DD  DSN=&PREFIX..PSM.RUNLIB,DISP=(MOD,DELETE,DELETE),\n//             UNIT=&DISKUNIT,SPACE=(TRK,0)\n//*\n//* ---------------------------------\n//* STEP 2 - CREATE PRODUCT LIBRARIES\n//* ---------------------------------\n//*\n//S2       EXEC PGM=IEFBR14\n//DD       DD  DSN=&PREFIX..PSM.SRCLIB,\n//             UNIT=&DISKUNIT,SPACE=(CYL,(2,1,16)),\n//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=6160,DSORG=PO),\n//             DISP=(NEW,CATLG,CATLG)\n//         DD  DSN=&PREFIX..PSM.RUNLIB,\n//             UNIT=&DISKUNIT,SPACE=(CYL,(2,1,16)),\n//             DCB=(RECFM=U,LRECL=0,BLKSIZE=6233,DSORG=PO),\n//             DISP=(NEW,CATLG,CATLG)\n//*\n//* -----------------------------------\n//* STEP 3 - POPULATE PRODUCT LIBRARIES\n//* -----------------------------------\n//*\n//S3       EXEC PGM=IEBUPDTE,PARM=MOD\n//SYSPRINT DD  SYSOUT=*\n//SYSUT1   DD  DSN=&PREFIX..PSM.SRCLIB,DISP=SHR\n//SYSUT2   DD  DSN=&PREFIX..PSM.SRCLIB,DISP=SHR\n//SYSIN    DD  DUMMY\n//*\n//* --------------------------------\n//* STEP 4 - ASSEMBLE PROGRAM PSU001\n//* --------------------------------\n//*\n//S4       EXEC PGM=ASMA90,PARM=RENT,COND=(8,LT,S3)\n//SYSLIB   DD  DSN=SYS1.MACLIB,DISP=SHR\n//         DD  DSN=SYS1.MODGEN,DISP=SHR\n//         DD  DSN=&PREFIX..PSM.SRCLIB,DISP=SHR\n//SYSUT1   DD  DSN=&&SYSUT1,SPACE=(4096,(120,120),,,ROUND),\n//             UNIT=SYSALLDA,DCB=BUFNO=1\n//SYSPRINT DD  SYSOUT=*\n//SYSLIN   DD  DSN=&&OBJ,SPACE=(3040,(40,40),,,ROUND),\n//             UNIT=SYSALLDA,DISP=(MOD,PASS),\n//             DCB=(BLKSIZE=6160,LRECL=80,RECFM=FB,BUFNO=1)\n//SYSIN    DD  DSN=&PREFIX..PSM.SRCLIB(PSU001),DISP=SHR\n//*\n//* ----------------------------\n//* STEP 5 - LINK PROGRAM PSU001\n//* ----------------------------\n//*\n//S5       EXEC PGM=HEWL,PARM='MAP,LET,LIST,NCAL',COND=(8,LT,S4)\n//SYSLIN   DD  DSN=&&OBJ,DISP=(OLD,DELETE)\n//         DD  DDNAME=SYSIN\n//SYSLMOD  DD  DSN=&PREFIX..PSM.RUNLIB(PSU001),DISP=SHR\n//SYSUT1   DD  DSN=&&SYSUT1,SPACE=(1024,(120,120),,,ROUND),\n//             UNIT=SYSALLDA,DCB=BUFNO=1\n//SYSPRINT DD  SYSOUT=*\n//*\n//* --------------------------------\n//* STEP 6 - ASSEMBLE PROGRAM PSU002\n//* --------------------------------\n//*\n//S6       EXEC PGM=ASMA90,PARM=RENT,COND=(8,LT,S5)\n//SYSLIB   DD  DSN=SYS1.MACLIB,DISP=SHR\n//         DD  DSN=SYS1.MODGEN,DISP=SHR\n//         DD  DSN=&PREFIX..PSM.SRCLIB,DISP=SHR\n//SYSUT1   DD  DSN=&&SYSUT1,SPACE=(4096,(120,120),,,ROUND),\n//             UNIT=SYSALLDA,DCB=BUFNO=1\n//SYSPRINT DD  SYSOUT=*\n//SYSLIN   DD  DSN=&&OBJ,SPACE=(3040,(40,40),,,ROUND),\n//             UNIT=SYSALLDA,DISP=(MOD,PASS),\n//             DCB=(BLKSIZE=6160,LRECL=80,RECFM=FB,BUFNO=1)\n//SYSIN    DD  DSN=&PREFIX..PSM.SRCLIB(PSU002),DISP=SHR\n//*\n//* ----------------------------\n//* STEP 7 - LINK PROGRAM PSU002\n//* ----------------------------\n//*\n//S7       EXEC PGM=HEWL,PARM='MAP,LET,LIST,NCAL',COND=(8,LT,S6)\n//SYSLIN   DD  DSN=&&OBJ,DISP=(OLD,DELETE)\n//         DD  DDNAME=SYSIN\n//SYSLMOD  DD  DSN=&PREFIX..PSM.RUNLIB(PSU002),DISP=SHR\n//SYSUT1   DD  DSN=&&SYSUT1,SPACE=(1024,(120,120),,,ROUND),\n//             UNIT=SYSALLDA,DCB=BUFNO=1\n//SYSPRINT DD  SYSOUT=*\n//*\n//* --------------------------------\n//* STEP 8 - ASSEMBLE PROGRAM PSU003\n//* --------------------------------\n//*\n//S8       EXEC PGM=ASMA90,PARM=RENT,COND=(8,LT,S7)\n//SYSLIB   DD  DSN=SYS1.MACLIB,DISP=SHR\n//         DD  DSN=SYS1.MODGEN,DISP=SHR\n//         DD  DSN=&PREFIX..PSM.SRCLIB,DISP=SHR\n//SYSUT1   DD  DSN=&&SYSUT1,SPACE=(4096,(120,120),,,ROUND),\n//             UNIT=SYSALLDA,DCB=BUFNO=1\n//SYSPRINT DD  SYSOUT=*\n//SYSLIN   DD  DSN=&&OBJ,SPACE=(3040,(40,40),,,ROUND),\n//             UNIT=SYSALLDA,DISP=(MOD,PASS),\n//             DCB=(BLKSIZE=6160,LRECL=80,RECFM=FB,BUFNO=1)\n//SYSIN    DD  DSN=&PREFIX..PSM.SRCLIB(PSU003),DISP=SHR\n//*\n//* ----------------------------\n//* STEP 9 - LINK PROGRAM PSU003\n//* ----------------------------\n//*\n//S9       EXEC PGM=HEWL,PARM='MAP,LET,LIST,NCAL',COND=(8,LT,S8)\n//SYSLIN   DD  DSN=&&OBJ,DISP=(OLD,DELETE)\n//         DD  DDNAME=SYSIN\n//SYSLMOD  DD  DSN=&PREFIX..PSM.RUNLIB(PSU003),DISP=SHR\n//SYSUT1   DD  DSN=&&SYSUT1,SPACE=(1024,(120,120),,,ROUND),\n//             UNIT=SYSALLDA,DCB=BUFNO=1\n//SYSPRINT DD  SYSOUT=*\n//*\n//* ---------------------------------\n//* STEP 10 - ASSEMBLE PROGRAM PSU004\n//* ---------------------------------\n//*\n//S10      EXEC PGM=ASMA90,PARM=RENT,COND=(8,LT,S9)\n//SYSLIB   DD  DSN=SYS1.MACLIB,DISP=SHR\n//         DD  DSN=SYS1.MODGEN,DISP=SHR\n//         DD  DSN=&PREFIX..PSM.SRCLIB,DISP=SHR\n//SYSUT1   DD  DSN=&&SYSUT1,SPACE=(4096,(120,120),,,ROUND),\n//             UNIT=SYSALLDA,DCB=BUFNO=1\n//SYSPRINT DD  SYSOUT=*\n//SYSLIN   DD  DSN=&&OBJ,SPACE=(3040,(40,40),,,ROUND),\n//             UNIT=SYSALLDA,DISP=(MOD,PASS),\n//             DCB=(BLKSIZE=6160,LRECL=80,RECFM=FB,BUFNO=1)\n//SYSIN    DD  DSN=&PREFIX..PSM.SRCLIB(PSU004),DISP=SHR\n//*\n//* -----------------------------\n//* STEP 11 - LINK PROGRAM PSU004\n//* -----------------------------\n//*\n//S11      EXEC PGM=HEWL,PARM='MAP,LET,LIST,NCAL',COND=(8,LT,S10)\n//SYSLIN   DD  DSN=&&OBJ,DISP=(OLD,DELETE)\n//         DD  DDNAME=SYSIN\n//SYSLMOD  DD  DSN=&PREFIX..PSM.RUNLIB(PSU004),DISP=SHR\n//SYSUT1   DD  DSN=&&SYSUT1,SPACE=(1024,(120,120),,,ROUND),\n//             UNIT=SYSALLDA,DCB=BUFNO=1\n//SYSPRINT DD  SYSOUT=*\n//*\n//* --------------------------\n//* STEP 12 - GENERATE IVP JOB\n//* --------------------------\n//*\n//S12      EXEC PGM=PSU003,COND=(8,LT,S11),\n//             PARM=('&&JOBNAME=&JOBNAME',\n//             '&&JOBCLASS=&JOBCLASS',\n//             '&&MSGCLASS=&MSGCLASS',\n//             '&&PREF=&PREFIX')\n//STEPLIB  DD  DSN=&PREFIX..PSM.RUNLIB,DISP=SHR\n//SYSUT1   DD  DSN=&PREFIX..PSM.SRCLIB($PSMIVP),DISP=OLD\n//SYSUT2   DD  DSN=&PREFIX..PSM.SRCLIB($PSMIVP),DISP=OLD\n//*\n//* -------------------------------\n//* STEP 14 - GENERATE GENCAL CLIST\n//* -------------------------------\n//*\n//S14      EXEC PGM=PSU003,COND=(8,LT,S11),\n//             PARM=('&&PREF=&PREFIX')\n//STEPLIB  DD  DSN=&PREFIX..PSM.RUNLIB,DISP=SHR\n//SYSUT1   DD  DSN=&PREFIX..PSM.SRCLIB(GENCAL),DISP=OLD\n//SYSUT2   DD  DSN=&PREFIX..PSM.SRCLIB(GENCAL),DISP=OLD\n//         PEND\n//*\n// EXEC PROC\n//S3.SYSIN  DD DATA,DLM=$$\n./ ADD NAME=PCALL,LEVEL=00\n./ NUMBER NEW1=10000,INCR=10000\n.* COPYRIGHT (C) 1988, PAUL A. SCOTT, ALL RIGHTS RESERVED\n.*\n         MACRO\n&NAME    PCALL\n.*\n         COPY  PSMGBL01\n.*\n         LCLA  &A\n&A       SETA  N'&SYSLIST(2)\n.*\n         AIF   (&A GT 0).L00100\n&NAME    CALL  &SYSLIST(1)\n         MEXIT\n.*\n.L00100  ANOP\n&NAME    LR    1,&SP\n         LA    &SP,4*&A.(,&SP)\n         CALL  &SYSLIST(1),&SYSLIST(2),VL,MF=(E,(1))\n         LA    14,4*&A\n         SR    &SP,14\n.*\n         MEND\n./ ADD NAME=PENTER,LEVEL=00\n./ NUMBER NEW1=10000,INCR=10000\n.* COPYRIGHT (C) 1988, PAUL A. SCOTT, ALL RIGHTS RESERVED\n.*\n         MACRO\n&NAME    PENTER &TYPE,             PROCEDURE TYPE                      X\n               &BASE=12,           BASE REGISTER(S)                    X\n               &VARS=,             LOCAL VARIABLE STORAGE              X\n               &STACK=,            SIZE OF STACK IN 1K BLOCKS          X\n               &PREFIX=PSM         LABEL PREFIX FOR MACRO EXPANSION\n.*\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*       VARIABLE DEFINITIONS\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*\n         COPY  PSMGBL00\n         COPY  PSMGBL01\n         COPY  PSMGBL02\n.*\n         LCLA  &I                  INDEX AND COUNTER\n         LCLA  &K                  STACK SIZE\n         LCLA  &N                  NUMBER OF PARAMETERS (REUSED)\n         LCLA  &S                  HIGHEST REGISTER USED\n.*\n         LCLB  &B0                 STACK DEFINED FLAG\n         LCLB  &B1                 PSM MAIN LINKAGE\n         LCLB  &B2                 PSM CMAIN LINKAGE\n         LCLB  &B3                 PSM FUNCTION LINKAGE\n         LCLB  &B4                 STANDARD LINKAGE\n.*\n         LCLC  &C                  CHARACTER STRING (REUSED)\n         LCLC  &P                  EXPANSION PREFIX\n.*\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*       VALIDATE &STACK PARAMETER\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*\n         AIF   ((T'&STACK EQ 'O') OR (&STACK EQ 0)).L0010\n&K       SETA  ((&STACK*4)*1024)\n&B0      SETB  ('&TYPE' EQ 'CMAIN')\n&B0      SETB  (('&TYPE' EQ 'MAIN') OR &B0)\n         AIF   (&B0).L0010\n         MNOTE 4,'INVALID STACK USAGE - STACK=&STACK IGNORED'\n.L0010   ANOP\n.*\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*       VALIDATE &TYPE PARAMETER\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*\n&B1      SETB  ('&TYPE' EQ 'MAIN')\n&B2      SETB  ('&TYPE' EQ 'CMAIN')\n&B3      SETB  ('&TYPE' EQ 'FUNC')\n&B4      SETB  (T'&TYPE EQ 'O')\n         AIF   (NOT (&B1 OR &B2)).L0020\n.*\n         AIF   (&B0).L0030\n         MNOTE 4,'TYPE &TYPE REQUIRES STACK - 4K ASSUMMED'\n&K       SETA  4096\n&B0      SETB  1\n         AGO   .L0030\n.*\n.L0020   ANOP\n         AIF   (&B1 OR &B2 OR &B3 OR &B4).L0030\n         MNOTE 4,'INVALID TYPE &TYPE - STANDARD LINKAGE ASSUMED '\n&B4      SETA  1\n.L0030   ANOP\n         AIF   (NOT &B4).L0040\n&K       SETA  64                      MINIMAL STACK FOR PCALL, ETC.\n&B0      SETB  1                       FORCE MINIMAL STACK\n.L0040   ANOP\n.*\n.*\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*       MAKE EXPANSION PREFIX SHORTER FOR CLEANER EXPANSION\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*\n&P       SETC  '&PREFIX'           SHORTEN THE VARIABLE NAME\n.*\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*       SAVE AREA STRUCTURE DEFINITION\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*\n         AIF   (&PSMSVA AND ('&P' EQ 'PSM')).L0060\n.L0050   ANOP\n.*      - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.*       S T A R T   O F   S A V E   A R E A   S T R U C T U R E\n.*      - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n&PSMSVA  SETB  1\n&P.SVA   DSECT ,                   SAVE AREA STRUCTURE\n&P.PLI   DS    F                   UNUSED\n&P.HSA   DS    A                   HIGH SAVE AREA PTR\n&P.LSA   DS    A                   LOW SAVE AREA PTR\n&P.RET   DS    A                   RETURN ADDRESS\n&P.EPA   DS    A                   ENTRY POINT ADDRESS\n&P.GPR0  DS    A                   REGISTER 0\n&P.GPR1  DS    A                   REGISTER 1\n&P.GPR2  DS    A                   REGISTER 2\n&P.GPR3  DS    A                   REGISTER 3\n&P.GPR4  DS    A                   REGISTER 4\n&P.GPR5  DS    A                   REGISTER 5\n&P.GPR6  DS    A                   REGISTER 6\n&P.GPR7  DS    A                   REGISTER 7\n&P.GPR8  DS    A                   REGISTER 8\n&P.GPR9  DS    A                   REGISTER 9\n&P.GPR10 DS    A                   REGISTER 10\n&P.GPR11 DS    A                   REGISTER 11\n&P.GPR12 DS    A                   REGISTER 12\n&P.GDS   DS    A                   GLOBAL DATA STRUCTURE PTR\n&P.LDS   DS    A                   LOCAL DATA STRUCTURE PTR\n&P.TOS   DS    A                   TOP OF STACK PTR\n&P.BOS   DS    A                   BOTTOM OF STACK PTR\n&P.SVALN EQU   *-&P.SVA            LENGTH OF SAVE AREA STRUCTURE\n&P.LVARS DS    0F                  START OF LOCAL VARIABLES\n.*      - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.*       E N D   O F   S A V E   A R E A   S T R U C T U R E\n.*      - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.L0060   ANOP\n.*\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*       COMPUTE HIGHEST REGISTER USED (FROM BASE REGS DEFINED)\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*\n&S       SETA  0                   START WITH NO HIGHEST\n.*\n.*       SCAN THE CODE BASE REGISTERS\n.*\n&N       SETA  N'&BASE             NUMBER OF BASE REGISTERS\n&I       SETA  1                   START WITH FIRST ONE\n.*\n.L0070   ANOP\n         AIF   (&I GT &N).L0090    WHILE (UNSCANNED REGISTERS)\n         PSMRVAL &BASE(&I)              GET VALUE OF REGISTER\n         AIF   (&S GE &PSMRVAL).L0080   IF HIGHER THAN PREVIOUS\n&S       SETA  &PSMRVAL                    SAVE REGISTER\n.L0080   ANOP                           ENDIF\n&I       SETA  &I+1                     INCREMENT REGISTER INDEX\n         AGO   .L0070              END WHILE\n.L0090   ANOP\n.*\n.*       SCAN THE DATA BASE REGISTERS\n.*\n&N       SETA  N'&VARS(3)          NUMBER OF BASE REGISTERS\n&I       SETA  1                   START WITH FIRST ONE\n.*\n.L0100   ANOP\n         AIF   (&I GT &N).L0120    WHILE (UNSCANNED REGISTERS)\n         PSMRVAL &VARS(3,&I)            GET VALUE OF REGISTER\n         AIF   (&S GE &PSMRVAL).L0110   IF HIGHER THAN PREVIOUS\n&S       SETA  &PSMRVAL                    SAVE REGISTER\n.L0110   ANOP                           ENDIF\n&I       SETA  &I+1                     INCREMENT REGISTER INDEX\n         AGO   .L0100              END WHILE\n.L0120   ANOP\n.*\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*       GENERATE REGISTER EQUATES\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*\n         AIF   (&PSMREGS).L0170    SKIP IF ALREADY DEFINED\n         AIF   (&REGS).L0160       ISSUE WARNING IF EXTERNALLY DEFINED\n.*\n&PSMREGS SETB  1                   MARK AS DEFINED\n&REGS    SETB  1                   MARK AS DEFINED\n.*\n&I       SETA  0\n.L0140   ANOP                         REPEAT\n.*                                       IF ( NOT SPECIAL REGISTER )\n         AIF   ((&I EQ &SP) OR (&I EQ &BP)).L0150\n.*       AIF   ((&I GT &S) AND NOT (&I LT &BP)).L0150\nR&I      EQU   &I                           GENERATE REGISTER EQUATE\n.L0150   ANOP                            ENDIF\n&I       SETA  &I+1                      BUMP TO NEXT REGISTER\n         AIF   (&I LE &HIREG).L0140   UNTIL ( NO MORE REGISTERS )\n         AGO   .L0170                 SKIP WARNING\n.*\n.L0160   ANOP\n         MNOTE 4,'USE REGISTERS &SP AND &BP WITH CAUTION!!!'\n.*\n.L0170   ANOP\n.*\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*       DROP PREVIOUS BASE REGISTERS\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*\n.*       DROP CODE BASE REGISTERS\n.*\n         AIF   ('&PSMBSEC(2)' EQ '').L0180\n         DROP  &PSMBSEC(2)\n.*\n.*       DROP DATA BASE REGISTERS\n.*\n.L0180   ANOP\n         AIF   ('&PSMBSED' EQ '').L0190\n         DROP  &PSMBSED\n.*\n.L0190   ANOP\n.*\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*       INITIALIZE THE PENTER/PEXIT GLOBAL VARIABLES\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*\n&PSMCNAM SETC  ''                  CLEAR THE CSECT NAME\n&PSMBSEC(1) SETC ''                CLEAR THE FIRST CODE BASE REGISTER\n&PSMBSEC(2) SETC ''                CLEAR THE CODE BASE REGISTER LIST\n&PSMBSED SETC  ''                  CLEAR THE DATA BASE\n&PSMBSEH SETC  ''                  CLEAR THE HIGHEST REGISTER USED\n&PSMSTKS SETC  ''                  CLEAR THE STACK SIZE\n.*\n&PSMCNAM SETC  '&NAME'             INITIALIZE THE CSECT NAME\n.*\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*       GENERATE THE CSECT PREFACE AREA\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*\n         PSMRLSE ,\n&N       SETA  (K'&PSMRLSE+3)/4*4\n.*\n.*      - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.*       S T A R T   O F   C S E C T   P R E F A C E\n.*      - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.*       THE CSECT ID SECTION IS MAPPED BY MACRO PSMCPREF\n.*       ANY CHANGES TO HERE SHOULD BE DUPLICATED THERE\n.*\n&NAME    CSECT ,\n.*\n&C       SETC  ''\n         AIF   (NOT &B2).L0200\n         ENTRY MAIN\n&C       SETC  'MAIN'\n.L0200   ANOP\n.*\n&I       SETA  36+&N+(&B0*4)+(&B2*4)\n&C       B     &I.(,15)            BRANCH AROUND CSECT PREFACE\n&I       SETA  27+&N\n         DC    AL1(&I.)            . LENGTH OF DUMP TEXT\n         DC    CL9'&NAME'          . CSECT NAME\n         DC    CL9'&SYSDATE'       . ASSEMBLY DATE\n         DC    CL9'&SYSTIME'       . ASSEMBLY TIME\n         AIF   (&N LT 1).L0210\n         DC    CL&N.'&PSMRLSE'     . PRODUCT RELEASE ID\n.L0210   ANOP\n&C       SETC  '0'\n         AIF   (T'&VARS(2) EQ 'O').L0220\n&C       SETC  '&VARS(2)'\n.L0220   ANOP\n&C       SETC  '((&P.SVALN+&C+7)/8)*8'\n         DC    A(&C)               . INITIAL STACK OFFSET\n.*\n.*       GENERATE STACK CONSTANTS\n.*\n         AIF   (NOT &B0).L0230\n&PSMSTKS SETC '&K'\n         DC    AL1(&SSID),AL3(&K)  . STACK ALLOCATION\n.*\n.*       GENERATE PSM INITIALIZATION MODULE ADDRESS CONSTANT\n.*\n         AIF   (NOT &B2).L0230\n         DC    V(PSMINIT)          . PSM INITIALIZATION\n.*      - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.*       E N D   O F   C S E C T   P R E F A C E\n.*      - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.L0230   ANOP\n.*\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*       SAVE REGISTERS FOR STANDARD LINKAGE\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*\n         STM   14,&S,12(&BP)\n.*\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*       ESTABLISH CODE BASE REGISTERS\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*\n&N       SETA  N'&BASE             NUMBER OF BASE REGISTERS\n&C       SETC  '&BASE(1)'          FIRST BASE REGISTER\n&PSMBSEC(1) SETC '&C'              SAVE FIRST BASE REGISTER\n.*\n         LR    &BASE(1),15\n         AIF   (&N LE 1).L0250     IF ( MORE THAN ONE REGISTER)\n&I       SETA  1                      SET INDEX TO FIRST REGISTER\n         LA    &BASE(&N),4095\n.L0240   ANOP\n         AIF   (&I+1 GT &N).L0250     WHILE ( MORE REGISTERS )\n&I       SETA  &I+1                      GET NEXT REGISTER\n         LA    &BASE(&I),1(&BASE(&N),&BASE(&I-1))\n&C       SETC  '&C.,&BASE(&I)'           COLLECT REGISTERS\n         AGO   .L0240                 END WHILE\n.L0250   ANOP                      ENDIF\n&PSMBSEC(2) SETC '&C'              SAVE BASE REGISTER LIST\n         USING &NAME,&C\n.*\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*       COMPLETE STANDARD LINKAGE\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*\n         LR    2,&BP\n&N       SETA  (K'&PSMRLSE+3)/4*4\n         AIF   (&B1 OR &B4).L0260\n         LR    &BP,&SP\n         AGO   .L0270\n.*\n.L0260   ANOP\n&I       SETA  36+&N\n         L     0,&I.(,&BASE(1))\n&I       SETA  &I-4\n         AL    0,&I.(,&BASE(1))\n         GETMAIN R,LV=(0)\n         LR    &BP,1\n         LR    &SP,1\n.*\n.L0270   ANOP\n         LA    0,0(,&BP)\n&I       SETA  32+&N\n         L     1,&I.(,&BASE(1))\n         LR    14,0\n         SR    15,15\n         MVCL  0,14\n.*\n         AIF   (&B1 OR &B4).L0280\n         MVC   &P.GDS-&P.SVA(&P.LVARS-&P.GDS,&BP),&P.GDS-&P.SVA(2)\n.L0280   ANOP\n.*\n         ST    2,4(,&BP)\n         ST    &BP,8(,2)\n         LM    1,2,24(2)\n         AIF   (&B4).L0290\n         A     &SP,&I.(,&BASE(1))\n.L0290   ANOP\n.*\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*       ESTABLISH DATA BASE REGISTERS\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*\n         AIF   (T'&VARS EQ 'O').L0340\n&C       SETC  '&BP'\n&N       SETA  N'&VARS(3)\n         AIF   (&N LT 1).L0330\n&I       SETA  0\n         LA    &VARS(3,&N),4095\n.L0300   ANOP\n&I       SETA  &I+1\n         AIF   (&I GT &N).L0330\n         AIF   (&I GT 1).L0310\n         LA    &VARS(3,&I),1(&VARS(3,&N),&BP)\n         AGO   .L0320\n.L0310   ANOP\n         LA    &VARS(3,&I),1(&VARS(3,&N),&VARS(3,&I-1))\n.L0320   ANOP\n&C       SETC  '&C.,&VARS(3,&I)'\n         AGO   .L0300\n.L0330   ANOP\n         USING &VARS(1)-&P.SVALN,&C\n&PSMBSED SETC  '&C'\n.L0340   ANOP\n.*\n&PSMBSEH SETC  '&S'\n.*\n         MEND\n./ ADD NAME=PEXIT,LEVEL=00\n./ NUMBER NEW1=10000,INCR=10000\n.* COPYRIGHT (C) 1988, PAUL A. SCOTT, ALL RIGHTS RESERVED\n.*\n         MACRO\n&NAME    PEXIT &RC=0               RETURN CODE\n.*\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*       VARIABLE DEFINITIONS\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*\n         COPY  PSMGBL00\n         COPY  PSMGBL01\n         COPY  PSMGBL02\n.*\n         LCLA  &A,&I,&J,&N\n         LCLC  &C\n.*\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*       SETUP\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*\n.L1000   ANOP\n.*\n&N       SETA  (K'&PSMRLSE+3)/4*4\n&C       SETC  '&PSMCNAM'\n.*\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*       GENERATE INITIAL RETURN CODE\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*\n&C       CSECT ,\n&NAME    LR    1,&BP\n         L     &BP,4(,&BP)\n.*\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*       STORE SPECIFIED REGISTERS IN CALLERS SAVE AREA\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*\n&A       SETA  N'&SYSLIST\n&I       SETA  1\n.L1020   ANOP\n         AIF   (&I GT &A).L1060\n         PSMROP &SYSLIST(&I)\n         AIF   (&PSMROP1 GT &PSMROP2).L1040\n         AIF   (&PSMROP1 LT 0 OR &PSMROP1 GT 12).L1040\n         AIF   (&PSMROP2 LT 0 OR &PSMROP1 GT 12).L1040\n&J       SETA  20+(&PSMROP1*4)\n         AIF   (&PSMROPC GT 1).L1030\n         ST    &PSMROP1,&J.(,&BP)\n         AGO   .L1050\n.L1030   ANOP\n         STM   &PSMROP1,&PSMROP2,&J.(&BP)\n         AGO   .L1050\n.L1040   ANOP\n         MNOTE 4,'REGISTER &SYSLIST(&I) OUT OF RANGE, IGNORED.'\n.L1050   ANOP\n&I       SETA  &I+1\n         AGO   .L1020\n.*\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*       STORE RETURN CODE\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*\n.L1060   ANOP\n         AIF   ('&RC' EQ '').L1090\n         AIF   ('&RC'(1,1) EQ '(').L1070\n         LA    15,&RC\n         AGO   .L1080\n.L1070   ANOP\n.*\n&C       SETC   '&RC'(2,K'&RC-2)\n         PSMRVAL &C\n         AIF   (&PSMRVAL EQ 15).L1080\n         LR    15,&PSMRVAL\n.*\n.L1080   ANOP\n         ST    15,16(,&BP)\n.*\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*       FREE THE STACK (IF ONE IS THERE)\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*\n.L1090   ANOP\n         AIF   (T'&PSMSTKS EQ 'O').L1100\n&I       SETA  36+&N\n         L     0,&I.(,&PSMBSEC(1))\n&I       SETA  &I-4\n         AL    0,&I.(,&PSMBSEC(1))\n         FREEMAIN R,LV=(0),A=(1)\n.*\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*       RETURN TO CALLER\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*\n.L1100   ANOP\n.*       RETURN (14,&PSMBSEH)\n         LM    14,&PSMBSEH,12(&BP)\n         OI    15(&BP),1           MARK RETURN\n         BR    14\n.*\n         LTORG ,\n         MEND\n./ ADD NAME=PLINK,LEVEL=00\n./ NUMBER NEW1=10000,INCR=10000\n.* COPYRIGHT (C) 1988, PAUL A. SCOTT, ALL RIGHTS RESERVED\n.*\n         MACRO\n&NAME    PLINK\n.*\n         COPY  PSMGBL01\n.*\n         LCLA  &A\n&A       SETA  N'&SYSLIST(2)\n.*\n&NAME    LR    1,&SP\n         LA    &SP,4*&A.(,&SP)\n         LINK  EP=&SYSLIST(1),PARAM=&SYSLIST(2),VL=1,MF=(E,(1))\n         LA    14,4*&A\n         SR    &SP,14\n.*\n         MEND\n./ ADD NAME=POPREG,LEVEL=00\n./ NUMBER NEW1=10000,INCR=10000\n.* COPYRIGHT (C) 1988, PAUL A. SCOTT, ALL RIGHTS RESERVED\n.*\n         MACRO\n&NAME    POPREG\n.*\n         COPY  PSMGBL01\n         COPY  PSMGBL02\n         LCLA  &I,&J,&K,&N\n.*\n         AIF   (T'&NAME EQ 'O').A000\n&NAME    DS    0H\n.A000    ANOP\n.*\n&N       SETA  N'&SYSLIST\n         AIF   (&N GT 0).A010\n         MEXIT\n.*\n.* COMPUTE AMOUNT OF STACK SPACE TO RELEASE\n.*\n.A010    ANOP\n&I       SETA  1\n&K       SETA  0\n.A020    ANOP\n         PSMROP &SYSLIST(&I)\n&I       SETA  &I+1\n&K       SETA  &K+&PSMROPC\n         AIF   (&I LE &N).A020\n.*\n.* RELEASE STACK SPACE\n.*\n.B010    ANOP\n         PSMRVAL &SYSLIST(1,1)\n&PSMROP1 SETA  &PSMRVAL\n         LA    &PSMROP1,4*&K\n         SR    &SP,&PSMROP1\n.*\n.* POP REGISTERS FROM STACK\n.*\n.C010    ANOP\n&I       SETA  &N\n&J       SETA  4*&K\n.C020    ANOP\n         PSMROP &SYSLIST(&I)\n         AIF   (&PSMROPC GT 1).C030\n&J       SETA  &J-4\n         L     &PSMROP1,&J.(,&SP)\n         AGO   .C060\n.*\n.C030    ANOP\n&J       SETA  &J-(4*&PSMROPC)\n         LM    &PSMROP1,&PSMROP2,&J.(&SP)\n.*\n.C060    ANOP\n&I       SETA  &I-1\n         AIF   (&I GE 1).C020\n.*\n         MEND\n./ ADD NAME=PSMASYM,LEVEL=00\n./ NUMBER NEW1=10000,INCR=10000\n.* COPYRIGHT (C) 1988, PAUL A. SCOTT, ALL RIGHTS RESERVED\n.*\n         MACRO\n         PSMASYM\n.*\n         COPY  PSMGBL02\n.*\n&PSMASYM SETA  &SYSLIST(1,1)\n.*\n         MEND\n./ ADD NAME=PSMCPREF,LEVEL=00\n./ NUMBER NEW1=10000,INCR=10000\n.* COPYRIGHT (C) 1988, PAUL A. SCOTT, ALL RIGHTS RESERVED\n.*\n         MACRO\n&NAME    PSMCPREF &PREFIX=PSM\n.*\n         LCLA  &N\n         LCLC  &P\n.*\n&P       SETC  '&PREFIX'\n.*\n         AIF   (T'&NAME NE 'O').L0100\n&NAME    SETC  '&P'.'CPREF'\n.L0100   ANOP\n.*\n.L0200   ANOP\n.*\n&NAME    DSECT ,\n&P.PJUMP DS    F                   BRANCH AROUND CSECT PREFIX\n*\n*                                  ID STRING\n&P.PLENG DS    FL1                 LENGTH OF IDENTIFIER STRING\n&P.PID   DS    0C                  . S\n&P.PNAME DS    CL8,CL1             . CSECT NAME\n&P.PDATE DS    0CL8                . ASSEMBLY DATE\n&P.PDTEM DS    CL2,CL1               . MONTH\n&P.PDTED DS    CL2,CL1               . DAY\n&P.PDTEY DS    CL2,CL1               . YEAR\n&P.PTIME DS    0CL8                . ASSEMBLY TIME\n&P.PTMEH DS    CL2,CL1               . HOUR\n&P.PTMEM DS    CL2,CL1               . MINUTES\n&P.PTMES DS    CL2,CL1               . SECONDS\n.*\n&P.PRLSE DS    0C                  . PRODUCT RELEASE\n.*\n&P.PLOCL DS    FL4                 SIZE OF SVA PLUS LOCAL VARIABLES\n         DS    FL1                 STACK SUBPOOL ID\n         DS    FL3                 SIZE OF STACK\n         DS    A                   PTR TO PSMINIT MODULE\n.*\n./ ADD NAME=PSMGBL00,LEVEL=00\n./ NUMBER NEW1=10000,INCR=10000\n.* COPYRIGHT (C) 1988, PAUL A. SCOTT, ALL RIGHTS RESERVED\n.*\n         GBLB  &PSMREGS            PSM REGISTERS DEFINED FLAG\n         GBLB  &REGS               IBM REGISTERS DEFINED FLAG\n         GBLC  &PSMBSEC(2)         PROCEDURE BASE REGISTERS\n         GBLC  &PSMBSED            AUTO STORAGE BASE REGISTERS\n         GBLC  &PSMBSEH            HIGHEST REGISTER USED\n         GBLC  &PSMCNAM            PROCEDURE NAME\n         GBLC  &PSMSTKS            STACK SIZE\n.*\n./ ADD NAME=PSMGBL01,LEVEL=00\n./ NUMBER NEW1=10000,INCR=10000\n.* COPYRIGHT (C) 1988, PAUL A. SCOTT, ALL RIGHTS RESERVED\n.*\n         GBLA  &SSID               STACK SUBPOOL ID\n         GBLA  &SP                 STACK POINTER\n         GBLA  &BP                 STACK BASE POINTER\n         GBLA  &HIREG              HIGHEST REGISTER AVAILABLE\n.*\n         GBLB  &PSMSVA             SAVE AREA DEFINED FLAG\n         GBLC  &PSMSIG             UNIQUE SIGNATURE\n.*\n&SSID    SETA  127                 INITIALIZE STACK SUBPOOL ID\n&SP      SETA  3                   INITIALIZE STACK POINTER\n&BP      SETA  13                  INITIALIZE STACK BASE POINTER\n&HIREG   SETA  15                  INITIALIZE HI-REG VALUE\n.*\n&PSMSIG  SETC  'CAFE'\n./ ADD NAME=PSMGBL02,LEVEL=00\n./ NUMBER NEW1=10000,INCR=10000\n.* COPYRIGHT (C) 1988, PAUL A. SCOTT, ALL RIGHTS RESERVED\n.*\n.*             SYMBOL-NAME         MACRO-ID   COMMENT\n.*             _________________   ________   ________________________\n.*\n         GBLA  &PSMRVAL            PSMRVAL  - RETURN REGISTER VALUE\n         GBLA  &PSMROPC            PSMROP   - RETURN REGISTER COUNT\n         GBLA  &PSMROP1,&PSMROP2   PSMROP   - RETURN REGISTER OPERANDS\n         GBLA  &PSMASYM            PSMASYM  - RETURN VALUE\n.*\n         GBLC  &PSMSUBP            PSMSUBP  - RETURN VALUE\n         GBLC  &PSMRLSE            PSMRLSE  - RETURN VALUE\n.*\n./ ADD NAME=PSMGDS,LEVEL=00\n./ NUMBER NEW1=10000,INCR=10000\n         MACRO\n         PSMGDS &PREFIX=GDS\n         LCLC   &P\n&P       SETC   '&PREFIX'\n.*****************************************************************\n.*       PSEUDO-STACK MACHINE GLOBAL DATA STRUCTURE              *\n.*---------------------------------------------------------------*\n.* NAME:            GDS                                          *\n.* POINTED TO BY:   LABEL PSMGDS IN PSMSVA (SAVE AREA +72)       *\n.* DESCRIPTION:     THE GDS IS GENERATED DURING PENTER PROCESSING*\n.*                  IF  TYPE HAS BEEN CODED AS MAIN.  IN THEORY  *\n.*                  THE GDS IS AN ADDRESS SPACE LEVEL CONTROL    *\n.*                  BLOCK WHILE THE LDS IS AT THE TASK LEVEL.    *\n.*                  INFORMATION IN THE GDS IS LIMITED TO THAT    *\n.*                  WHICH COULD BE CONSIDERED APPLICABLE OR      *\n.*                  COMMON TO ALL TASKS WITHIN THE ADDRESS SPACE *\n.*                                                               *\n.*                MAIN TASK                                      *\n.*                 ________                   SUB TASK           *\n.*                | GDS    |<-----.  <--------------------.      *\n.*                |--------|      |           ________    |      *\n.*                | LDS    |<----.|          | LDS    |   |      *\n.*                |--------|     ||          |--------|   |      *\n.*                | PSMSVA |=====-'          | PSMSVA |---'      *\n.*                |--------|                 |--------|          *\n.*                | STACK  |                 | STACK  |          *\n.*                |________|                 |________|          *\n.*                                                               *\n.*                                                               *\n.*****************************************************************\nGDS      DSECT ,\n*\n&P.ID    DS    CL8'PSMGDS'         EYE CATCHER\n*\n&P.IN    DS    A(0)                STANDARD INPUT WORK AREA\n&P.OUT   DS    A(0)                STANDARD OUTPUT WORK AREA\n&P.ERROR DS    A(0)                STANDARD ERROR WORK AREA\n&P.PRINT DS    A(0)                STANDARD PRINT WORK AREA\n*\n&P.ARGC  DS    F'0'                ARGUMENT COUNT\n&P.ARGV  DS    A(0)                PTR TO LIST OF ARGUMENT PTRS\n&P.ENVPT DS    A(0)                PTR TO ENVIRONMENT STRINGS\n*\n&P.HEAPF DS    A(0)                PTR TO FIRST HEAP BLOCK (PSMHEAP)\n&P.HEAPL DS    A(0)                PTR TO LAST  HEAP BLOCK\n&P.HLOCK DS    A(0)                HEAP LOCK (SERIALIZATION WITH CS)\n*\n&P.ENVSW DS    X                   ENVIRONMENT SWITCH\n&P.ESXA  DS    X'01'               .... ...1   MVS/XA (SP VERSION 2)\n&P.ESJ2  DS    X'02'               .... ..1.   JES2\n&P.ESJ3  DS    X'04'               .... .1..   JES3\n&P.ESTSO DS    X'08'               .... 1...   TSO\n&P.ESSPF DS    X'10'               ...1 ....   TSO/ISPF\n&P.ESJOB DS    X'20'               ..1. ....   JOB\n&P.ESSTC DS    X'40'               .1.. ....   STARTED TASK\n&P.NAME  DS    CL8                 ADDRESS SPACE NAME\n&P.JOBID DS    CL8                 ADDRESS SPACE JOBID\n&P.SSNAM DS    CL4                 SUBSYSTEM NAME\n&P.SPVER DS    CL8                 MVS/SP VERSION (CVTPRODN)\n*\n*  PSM LOCKS ARE SERIALIZED USING COMPARE AND SWAP.  THE VALUE\n*  SWAPPED IN X'FFFFFFFF' IF THE LOCK IS HELD AND ZERO IF IT IS\n*  NOT.  ALL LOCKS MUST PROVIDE 2 WORDS.\n*\n&P.LOCKS DS    CL8'LOCKS>'         START OF PSM LOCKS SECTION\n&P.HPLOC DS    F                   HEAP LOCK\n&P.HPECB DS    F                   HEAP LOCK ECB IF QUEUED\n*\n&P.LENG  EQU   *-PSMGDS            LENGTH OF GLOBAL DATA AREA\n         MEND\n./ ADD NAME=PSMRLSE,LEVEL=00\n./ NUMBER NEW1=10000,INCR=10000\n.* COPYRIGHT (C) 1988, PAUL A. SCOTT, ALL RIGHTS RESERVED\n.*\n         MACRO\n         PSMRLSE\n.*\n         COPY  PSMGBL02\n.*\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*       THIS MACRO DEFINES THE PRODUCT NAME AND RELEASE DATA\n.*       WHICH WILL BE INCLUDED IN THE CSECT PREFIX AREA.\n.*       KEEP A COPY OF THIS MACRO IN EACH PRODUCT MACRO LIBRARY\n.*       AND CHANGE THE GLOBAL VARIABLE &PSMRLSE AS APPROPRIATE.\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*\n&PSMRLSE SETC  'PSM 1.0.0'\n.*\n         MEND\n./ ADD NAME=PSMROP,LEVEL=00\n./ NUMBER NEW1=10000,INCR=10000\n.* COPYRIGHT (C) 1988, PAUL A. SCOTT, ALL RIGHTS RESERVED\n.*\n         MACRO\n         PSMROP\n.*\n         COPY  PSMGBL02\n         LCLA  &A\n.*\n.A010    ANOP\n.*\n&PSMROPC SETA  0\n&PSMROP1 SETA  17\n&PSMROP2 SETA  17\n&A       SETA  N'&SYSLIST(1)\n         AIF   (&A LT 1).A040\n.*\n         AIF   (&A GT 1).A020\n         PSMRVAL &SYSLIST(1,1)\n&PSMROP1 SETA  &PSMRVAL\n&PSMROP2 SETA  &PSMRVAL\n&PSMROPC SETA  1\n         AGO   .A040\n.*\n.A020    ANOP\n         PSMRVAL &SYSLIST(1,1)\n&PSMROP1 SETA  &PSMRVAL\n         PSMRVAL &SYSLIST(1,2)\n&PSMROP2 SETA  &PSMRVAL\n         AIF   (&PSMROP1 GT &PSMROP2).A030\n&PSMROPC SETA  1+(&PSMROP2-&PSMROP1)\n         AGO   .A040\n.A030    ANOP\n&PSMROPC SETA  (1+(15-&PSMROP1))+(1+&PSMROP2)\n.*\n.A040    ANOP\n.*\n         MEND\n./ ADD NAME=PSMROPS,LEVEL=00\n./ NUMBER NEW1=10000,INCR=10000\n.* COPYRIGHT (C) 1988, PAUL A. SCOTT, ALL RIGHTS RESERVED\n         MACRO\n&LABEL   PSMROPS\n.*\n         COPY  PSMGBL02\n         LCLA  &I,&K\n         LCLC  &C,&R1,&R2\n.*\n.A010    ANOP\n.*\n&C       SETC  '&SYSLIST(1,1)'\n         AIF   ('&C'(1,1) NE '(').A020\n&C       SETC  '&C'(2,K'&C-2)\n.*\n.A020    ANOP\n&I       SETA  1\n&K       SETA  K'&C\n.*\n.A030    ANOP\n         AIF   (&I GT &K).A040\n         AIF   ('&C'(&I,1) EQ ',').A040\n&I       SETA  &I+1\n         AGO   .A030\n.*\n.A040    ANOP\n&R1      SETC  '0'\n&R2      SETC  '0'\n.*\n         AIF   ('&C'(1,1) EQ ',').A050\n&R1      SETC  '&C'(1,&I-1)\n.*\n.A050    ANOP\n         AIF   (&I GE &K).A060\n&R2      SETC  '&C'(&I+1,&K-&I)\n.*\n.A060    ANOP\n         PSMROP  (&R1,&R2)\n.*\n         MEND\n./ ADD NAME=PSMRVAL,LEVEL=00\n./ NUMBER NEW1=10000,INCR=10000\n.* COPYRIGHT (C) 1988, PAUL A. SCOTT, ALL RIGHTS RESERVED\n.*\n         MACRO\n         PSMRVAL\n.*\n         COPY  PSMGBL02\n         LCLC  &C\n.*\n&C       SETC  '&SYSLIST(1,1)'\n         AIF   ('&C'(1,1) NE 'R').A010\n&C       SETC  '&C'(2,K'&C-1)\n.*\n.A010    ANOP\n         PSMASYM &C\n.*\n&PSMRVAL SETA  &PSMASYM\n.*\n         AIF   (&PSMRVAL GT 15).MSG1\n         MEXIT\n.*\n.*  ERROR PROCESSING\n.*\n.MSG1    MNOTE 8,'OOPS, ONLY 15 REGISTERS ON THIS MACHINE'\n         MNOTE 8,'PARM 1 CAN BE 0-15 (R1-R15)'\n         MEND\n./ ADD NAME=PUSHREG,LEVEL=00\n./ NUMBER NEW1=10000,INCR=10000\n.* COPYRIGHT (C) 1988, PAUL A. SCOTT, ALL RIGHTS RESERVED\n.*\n         MACRO\n&NAME    PUSHREG\n.*\n         COPY  PSMGBL01\n         COPY  PSMGBL02\n         LCLA  &I,&J,&K,&N\n.*\n         AIF   (T'&NAME EQ 'O').A000\n&NAME    DS    0H\n.A000    ANOP\n.*\n&N       SETA  N'&SYSLIST\n         AIF   (&N GT 0).A010\n         MEXIT\n.*\n.A010    ANOP\n&I       SETA  1\n&J       SETA  0\n&K       SETA  0\n.A020    ANOP\n         PSMROP &SYSLIST(&I)\n         AIF   (&PSMROPC GT 1).A030\n         ST    &PSMROP1,&J.(,&SP)\n         AGO   .A040\n.*\n.A030    ANOP\n         STM   &PSMROP1,&PSMROP2,&J.(&SP)\n.*\n.A040    ANOP\n&I       SETA  &I+1\n&J       SETA  &J+(4*&PSMROPC)\n&K       SETA  &K+&PSMROPC\n         AIF   (&I LE &N).A020\n.*\n         LA    &SP,4*&K.(,&SP)\n.*\n         MEND\n./ ADD NAME=ZIC,LEVEL=00\n./ NUMBER NEW1=10000,INCR=10000\n.* COPYRIGHT (C) 1988, PAUL A. SCOTT, ALL RIGHTS RESERVED\n         MACRO\n&LABEL   ZIC   &P1,&P2             ZERO AND INSERT CHARACTER\n.*\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*       VARIABLE DEFINITIONS\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*\n         COPY  PSMGBL02\n.*\n         LCLA  &I,&K\n         LCLC  &C,&R1,&R2\n.*\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*       CHECK FOR REGISTER NOTATION IN OPERAND 2\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*\n&I       SETA  1\n&K       SETA  K'&P2\n.L0100   ANOP\n         AIF   (&I GT &K).L0130\n         AIF   ('&P2'(&I,1) EQ '(').L0110\n&I       SETA  &I+1\n         AGO   .L0100\n.*\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*       CHECK IF TARGET REG IS ALSO BASE OR INDEX REG\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*\n.L0110   ANOP\n&C       SETC  '&P2'(&I,(&K-&I)+1)\n         PSMROPS &C\n         PSMRVAL &P1\n&I       SETA  &PSMRVAL\n         AIF   (&I EQ 0).L0130\n         AIF   ((&I NE &PSMROP1) AND (&I NE &PSMROP2)).L0130\n.*\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*       CLEAR UNUSED BITS AFTER OPERATION (SLOWER)\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*\n.L0120   ANOP\n&LABEL   IC    &P1,&P2\n         SLL   &P1,24\n         SRL   &P1,24\n         MEXIT\n.*\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*       CLEAR UNUSED BITS BEFORE OPERATION (FASTER)\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*\n.L0130   ANOP\n.*\n&LABEL   XR    &P1,&P1                         ZERO TARGET REGISTER\n         IC    &P1,&P2                         INSERT CHARACTER\n         MEND\n./ ADD NAME=ZICM,LEVEL=00\n./ NUMBER NEW1=10000,INCR=10000\n.* COPYRIGHT (C) 1988, PAUL A. SCOTT, ALL RIGHTS RESERVED\n         MACRO\n&LABEL   ZICM &P1,&P2,&P3          ZERO AND INSERT CHARS UNDER MASK\n.*\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*       VARIABLE DEFINITIONS\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*\n         COPY  PSMGBL02\n.*\n         LCLA  &I,&K\n         LCLC  &C\n.*\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*       CHECK FOR REGISTER NOTATION IN OPERAND 3\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*\n&I       SETA  1\n&K       SETA  K'&P3\n.L0100   ANOP\n         AIF   (&I GT &K).L0130\n         AIF   ('&P3'(&I,1) EQ '(').L0110\n&I       SETA  &I+1\n         AGO   .L0100\n.*\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*       CHECK IF TARGET REG IS ALSO BASE OR INDEX REG\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*\n.L0110   ANOP\n&C       SETC  '&P3'(&I,(&K-&I)+1)\n         PSMROPS &C\n         PSMRVAL &P1\n         AIF   ((&PSMRVAL EQ 0) OR (&PSMRVAL NE &PSMROP1)).L0130\n.*\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*       CLEAR UNUSED BITS AFTER OPERATION (SLOWER)\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*\n.L0120   ANOP\n.*\n&B0      SETB  ((&P2/16*2) NE &P2/8)\n&B1      SETB  ((&P2/8*2) NE &P2/4)\n&B2      SETB  ((&P2/4*2) NE &P2/2)\n&B3      SETB  ((&P2/2*2) NE &P2)\n&C       SETC  '00FF'(&B0*2+1,2)\n&C       SETC  '&C'.'00FF'(&B1*2+1,2)\n&C       SETC  '&C'.'00FF'(&B2*2+1,2)\n&C       SETC  '&C'.'00FF'(&B3*2+1,2)\n.*\n&LABEL   ICM   &P1,&P2,&P3\n         N     &P1,=A(X'&C')\n         MEXIT\n.*\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*       CLEAR UNUSED BITS BEFORE OPERATION (FASTER)\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*\n.L0130   ANOP\n.*\n&LABEL   XR    &P1,&P1                         ZERO TARGET REGISTER\n         ICM   &P1,&P2,&P3                     INSERT CHARACTER MASK\n         MEND\n./ ADD NAME=PSU001,LEVEL=00\n./ NUMBER NEW1=10000,INCR=10000\n* COPYRIGHT (C) 1988, PAUL A. SCOTT, ALL RIGHTS RESERVED\n* ANY USE OF THIS CODE MUST RETAIN THE ABOVE COPYRIGHT NOTICE\n*\n* PSU001 IS RENT,REUS\n*\n* COMPARES TWO CONSTANTS OR SYMBOLICS SPECIFIED IN THE PARM FIELD.\n* A TRUE CONDITION RESULTS IN A ZERO RETURN CODE, AND A FALSE\n* CONDITION RESULTS IN A RETURN CODE OF 1.\n* THE FORMAT OF THE PARM FIELD IS: FIELD1,OP,FIELD2\n*   WHERE FIELD1 AND FIELD2 ARE EITHER A CONSTANT OR A SYMBOLIC\n*     AND OP IS ONE OF THE FOLLOWING OPERATORS:\n*           EQ, NE, LT, LE, GT, GE\n*\n* EXAMPLE:\n*    //STEP1   EXEC PGM=PSU001,\n*    //            PARM=(&JESNAME,EQ,JES2)\n*\n*\nPSU001   PENTER MAIN,VARS=(@VARS,@VARSLEN),STACK=1\n*\n*---------------------------------------------------------------------*\n*        MAINLINE                                                     *\n*---------------------------------------------------------------------*\n*\n         L     R2,0(,R1)               PARM PTR\n         LH    R4,0(,R2)               PARM LENGTH\n*\n         LTR   R4,R4                   ANY PARM PRESENT ?\n         BZ    INVALID                 NO, REPORT ERROR\n*\n*        PARSE PARM FOR 'STRING1,OP,STRING2'\n*\n         LA    R5,1(R4,R2)             POINT TO LAST BYTE OF PARM\n         LA    R4,1                    STEP ONE BYTE AT A TIME\n         LA    R2,2(,R2)               POINT TO FIRST BYTE OF PARM\n         LR    R7,R2                   SAVE PTR TO FIRST BYTE OF PARM\n*\nA00100   CLI   0(R2),C','              FOUND A COMMA?\n         BNE   A00200                  NO, CHECK NEXT BYTE\n         BAL   R14,SVFIELD             YES, SAVE CURRENT FIELD\nA00200   BXLE  R2,R4,A00100            LOOP THROUGH EVERY BYTE OF PARM\n         BAL   R14,SVFIELD             SAVE LAST FIELD\n*\n*        DO STRING COMPARISON\n*\n         L     R4,@STR1                STRING1 PTR\n         L     R5,@STR1L               STRING1 LENGTH\n         L     R6,@STR2                STRING2 PTR\n         L     R7,@STR2L               STRING2 LENGTH\n*\n         OR    R4,R4                   HAVE VALID STRING1 PTR ?\n         BZ    INVALID                 NO, REPORT ERROR\n         OR    R5,R5                   HAVE VALID STRING1 LENGTH ?\n         BZ    INVALID                 NO, REPORT ERROR\n         OR    R6,R6                   HAVE VALID STRING2 PTR ?\n         BZ    INVALID                 NO, REPORT ERROR\n         OR    R7,R7                   HAVE VALID STRING2 LENGTH ?\n         BZ    INVALID                 NO, REPORT ERROR\n*\n         LA    R1,OPTABLE              START OF OPERATOR TABLE\n         LA    R14,L'OPTABLE           LENGTH OF EACH ENTRY\n         LA    R15,OPEND               END OF OPERATOR TABLE\n*\n         USING OPTABLE,R1\n*\nA00300   CLC   OP,@OP                  FOUND LOGICAL OPERATOR ?\n         BE    A00400                  YES, CONTINUE\n         BXLE  R1,R14,A00300           NO, SCAN ENTIRE TABLE\n*\nA00400   XR    R14,R14                 CLEAR\n         CLCL  R4,R6                   COMPARE STRINGS\n         EX    R14,COND                EXECUTE BRANCH TRUE CONDITION\n         B     EXITFALS                LOGICAL CONDITION WAS FALSE\n*\n         DROP  R1\n*\nINVALID  WTO  'PSU0011I - INVALID PARAMETERS',ROUTCDE=11,DESC=6\n         WTO  'PSU0012I - USE ''STRING1,OP,STRING2''',ROUTCDE=11,DESC=6\n         ABEND 1\n*\nEXITFALS MVC  @RC,=F'1'                RETURN FALSE\nEXITTRUE L    R15,@RC                  RETURN TRUE\n*\n         PEXIT RC=(R15)                RETURN TO CALLER\n*\n*---------------------------------------------------------------------*\n*        SVFIELD SUBROUTINE                                           *\n*---------------------------------------------------------------------*\n*\n*        INPUT REGS:  R2 - PTR TO COMMA AT END OF CURRENT FIELD\n*                     R7 - PTR TO START OF CURRENT FIELD\n*\n*        OUTPUT REGS: R7 - PTR TO FIRST BYTE OF NEXT FIELD\n*\n*\nSVFIELD  PUSHREG R14                   SAVE RETURN ADDRESS\n*\n         OC    @STR1,@STR1             NOW AT STRING1 ?\n         BNZ   S00100                  NO, TRY OPERATOR\n*\n         ST    R7,@STR1                STORE START OF FIELD\n         LR    R14,R2                  CURRENT LOCATION\n         SR    R14,R7                  COMPUTE LENGTH OF PARM\n         ST    R14,@STR1L              SAVE ZERO RELATIVE LENGTH\n         LA    R7,1(,R2)               COMPUTE START OF NEXT FIELD\n         B     S00400\n*\nS00100   OC    @OP,@OP                 NOW AT OPERATOR ?\n         BNZ   S00300                  NO, TRY STRING2\n*\n         MVC   @OP,0(R7)               SAVE THE OPERATOR\n         LA    R7,1(,R2)               COMPUTE START OF NEXT FIELD\n         B     S00400\n*\nS00300   OC    @STR2,@STR2             NOW AT STRING2 ?\n         BNZ   S00400                  NO, IGNORE EXCESS FIELDS\n*\n         ST    R7,@STR2                STORE START OF FIELD\n         LR    R14,R2                  CURRENT LOCATION\n         SR    R14,R7                  COMPUTE LENGTH OF PARM\n         ST    R14,@STR2L              SAVE ZERO RELATIVE LENGTH\n         LA    R7,1(,R2)               COMPUTE START OF NEXT FIELD\n*\nS00400   POPREG R14                    RESTORE RETURN ADDRESS\n         BR  R14                       RETURN TO CALLER\n*\n*---------------------------------------------------------------------*\n*        OPERATION CODE TABLE                                         *\n*---------------------------------------------------------------------*\n*\n*        THE OPCODE TABLE MATCHES THE CHARACTER OPERATION CODE WITH\n*        ITS CORRESPONDING 'BRANCH ON CONDITION' INSTRUCTION.\n*\n*        THE LAST ENTRY IN THE TABLE IS A HARD BRANCH TO THE LABEL\n*        THAT SETS A FALSE CONDITION. THIS SIMPLIFIES THE PROGRAM\n*        LOGIC SUCH THAT NO SPECIAL END-OF-TABLE CHECK IS NECESSARY.\n*\nOPTABLE  DS  0CL6                      OPERATOR TABLE\n*\nOP       DC  CL2'EQ'                   EQUAL OPERATOR\nCOND     BE          EXITTRUE              BRANCH ON EQUAL\n         DC  CL2'NE'                   NOT EQUAL OPERATOR\n         BNE         EXITTRUE              BRANCH ON NOT EQUAL\n         DC  CL2'LT'                   LESS THAN OPERATOR\n         BL          EXITTRUE              BRANCH ON LESS THAN\n         DC  CL2'LE'                   LESS THAN OR EQUAL OPERATOR\n         BNH         EXITTRUE              BRANCH ON NOT GREATER\n         DC  CL2'GT'                   GREATER THAN OPERATOR\n         BH          EXITTRUE              BRANCH ON GREATER THAN\n         DC  CL2'GE'                   GREATER OR EQUAL OPERATOR\n         BNL         EXITTRUE              BRANCH ON NOT LESS\nOPEND    EQU *-1\n         DC  CL2'FF'                   MARK END OF TABLE\n         B           INVALID           FORCE FALSE CONDITION\n*\n*---------------------------------------------------------------------*\n*        LOCAL (AUTO) STORAGE                                         *\n*---------------------------------------------------------------------*\n*\n*   N.B. AUTO STORAGE INITIALIZED TO BINARY ZEROS ON PROGRAM ENTRY\n*\n@VARS    DSECT ,                       LOCAL STORAGE\n@RC      DS    F                       . RETURN CODE\n@STR1    DS    F                       . STRING1 PTR\n@STR1L   DS    F                       . STRING1 LENGTH\n@STR2    DS    F                       . STRING2 PTR\n@STR2L   DS    F                       . STRING2 LENGTH\n@OP      DS    CL2                     . OPERATOR\n@VARSLEN EQU *-@VARS                   LENGTH OF LOCAL STORAGE\n*\n         END   PSU001\n./ ADD NAME=PSU002,LEVEL=00\n./ NUMBER NEW1=10000,INCR=10000\n* COPYRIGHT (C) 1988, PAUL A. SCOTT, ALL RIGHTS RESERVED\n* ANY USE OF THIS CODE MUST RETAIN THE ABOVE COPYRIGHT NOTICE\n*\n* PSU002 IS RENT,REUS\n*\n* COPIES PARM FIELD TO A DATA SET ON ONE OR MORE RECORDS.\n* THE OUTPUT DATASET (SYSOUT) CAN HAVE F, FB, V, OR VB\n* FORMAT RECORDS.\n* THE RECORD SEPARATOR IS THE FIRST CHARACTER OF THE PARM\n* AND IS NOT INCLUDED IN THE OUTPUT RECORDS.\n* IF A COMMA IMMEDIATELY FOLLOWS A RECORD SEPARATOR, THE\n* COMMA IS NOT INCLUDED IN THE OUTPUT RECORD.\n*\n* EXAMPLE:\n*    //STEP1   EXEC PGM=PSU002,\n*    //            PARM=('\\',                       RECORD SEPARATOR\n*    //            ' C INDD=SYSUT1,OUTDD=SYSUT2\\',  CARD #1\n*    //            ' S M=(MEMBERA,MEMBERB) ')       CARD #2\n*    //SYSOUT  DD  DSN=&&IEBCOPY,UNIT=VIO,ETC...\n*\nPSU002   PENTER MAIN,VARS=(@VARS,@VARSLEN),STACK=1\n*\n*---------------------------------------------------------------------*\n*        MAINLINE                                                     *\n*---------------------------------------------------------------------*\n*\n         L     R2,0(,R1)               PARM PTR\n         LH    R4,0(,R2)               PARM LENGTH\n*\n         MVC   @SYSOUT(DCBL),DCB       INITIALIZE DCB\n         MVC   @OPEN(OPENL),OPEN       INITIALIZE OPEN PARAMETER LIST\n         OPEN  (@SYSOUT,(OUTPUT)),     OPEN OUTPUT FILE                C\n               MF=(E,@OPEN)\n*\n         CH    R4,=H'2'                PARM PRESENT ?\n         BL    EXIT                    NO, NOTHING TO WRITE\n*\n         MVC   @SEP,2(R2)              SAVE THE LINE SEPARATOR\n*\n         LA    R5,1(R4,R2)             POINT TO LAST BYTE OF PARM\n         LA    R4,1                    STEP ONE BYTE AT A TIME\n         LA    R2,3(,R2)               POINT TO 1ST BYTE PAST SEPARATOR\n         LR    R7,R2                   SAVE PTR TO RECORD DATA\n*\nA00100   CLC   0(1,R2),@SEP            FOUND A SEPARATOR?\n         BNE   A00200                  NO, KEEP LOOKING\n         BAL   R14,MOVECARD            YES, WRITE A RECORD\nA00200   BXLE  R2,R4,A00100            LOOP THROUGH EVERY BYTE OF PARM\n         BAL   R14,MOVECARD            WRITE LAST RECORD\n*\nEXIT     MVC   @CLOSE(CLOSEL),CLOSE    INITIALIZE CLOSE PARAMETER LIST\n         CLOSE (@SYSOUT),              CLOSE OUTPUT FILE               C\n               MF=(E,@CLOSE)\n*\n         L  R15,@RC                    PICK UP RETURN CODE\n         PEXIT RC=(R15)                RETURN TO CALLER\n*\n*---------------------------------------------------------------------*\n*        MOVECARD SUBROUTINE                                          *\n*---------------------------------------------------------------------*\n*\n*        INPUT REGS:  R2 - PTR TO RECORD SEPARATOR AT END OF RECORD\n*                     R7 - PTR TO START OF CURRENT RECORD\n*\n*        OUTPUT REGS: R7 - PTR TO START OF NEXT RECORD\n*\n*\nMOVECARD PUSHREG R14,R6\n*\n         LR    R6,R2                   CURRENT LOCATION\n         SR    R6,R7                   COMPUTE LENGTH OF CARD\n         BCTR  R6,0                    MAKE LENGTH ZERO RELATIVE\n*\n*        REMOVE A COMMA FOLLOWING A RECORD SEPERATOR\n*\n*        ONE CAN EASILY IMAGINE A SITUATION IN WHICH\n*        A COMMA FOLLOWING A RECORD SEPARATOR SHOULD\n*        NOT BE REMOVED. BUT AS THERE IS NO POSSIBLE\n*        METHOD TO DETERMINE WHEN SUCH A CASE EXISTS\n*        WE ESTABLISH THE LAW THAT A COMMA FOLLOWING\n*        A RECORD SEPARATOR SHALL ALWAYS BE REMOVED.\n*\n*        A FULL DISCUSSION OF ALL THE POINTS LEADING\n*        TO THIS RULE IS NOT APPROPRIATE HERE. TRUST\n*        ME, THOUGH, THERE IS NO BUG HERE, SO PLEASE\n*        DON'T TRY TO FIX IT.  ;-)\n*\n         CLI   0(R7),C','              TRAILING COMMA ?\n         BNE   B00100                  NO, TIME TO WRITE RECORD\n         LA    R7,1(,R7)               SKIP OVER THE COMMA\n         BCTR  R6,0                    ADJUST LENGTH TO COMPENSATE\n*\n*        WRITE THE RECORD, TAKING INTO ACCOUNT THE\n*        SUBTLETIES OF THE ALLOWED RECORD FORMATS.\n*\nB00100   LA    R8,@SYSOUT              POINT TO OUTPUT DCB\n         USING IHADCB,R8               ESTABLISH ADDRESSABILITY\n*\n         TM    DCBRECFM,DCBRECU        UNDEFINED RECORD FORMAT ?\n         BO    B00400                  YES, FORMAT NOT SUPPORTED\n*\n         PUT   @SYSOUT                 LOCATE RECORD BUFFER --> R1\n         TM    DCBRECFM,DCBRECV        VARIABLE RECORD FORMAT ?\n         BNO   B00200                  NO, TRY FIXED FORMAT\n*\n         LA    R14,5(,R6)              ADJUST LENGTH FOR RDW\n         STCM  R14,B'0011',0(R1)       STUFF LENGTH INTO RDW\n         STCM  R14,B'1100',2(R1)       CLEAR HIGH-ORDER RDW BITS\n         LA    R1,4(,R1)               SKIP RDW, POINT TO RECORD AREA\n         LR    R14,R6                  ACTUAL RECORD LENGTH\n         BCTR  R14,0                   MINUS ONE FOR CLEARING BUFFER\n         B     B00300                  CLEAR BUFFER\n*\nB00200   TM    DCBRECFM,DCBRECF        FIXED RECORD FORMAT ?\n         BNO   B00400                  NO, FORMAT NOT SUPPORTED\n         LH    R14,DCBLRECL            FIXED RECORD LENGTH\n         BCTR  R14,0                   MAKE LENGTH ZERO RELATIVE\n         BCTR  R14,0                   MINUS ONE FOR CLEARING BUFFER\n*\nB00300   MVI   0(R1),C' '              CLEAR RECORD BUFFER\n         EX    R14,CLRINSTR               TO ALL SPACES\n*\n         LTR   R6,R6                   ACTUAL RECORD LENGTH > 0 ?\n         BM    B00400                  NO, USE BLANK RECORD\n         EX    R6,MVCINSTR             YES, COPY RECORD TO BUFFER\n*\nB00400   LA    R7,1(,R2)               COMPUTE START OF NEXT RECORD\n*\n         POPREG R14,R6                 RESTORE RETURN ADDRESS\n         BR    R14                     RETURN TO CALLER\n*\n*---------------------------------------------------------------------*\n*        PROTOTYPE INSTRUCTIONS AND DATA                              *\n*---------------------------------------------------------------------*\n*\nCLRINSTR MVC 1(0,R1),0(R1)\nMVCINSTR MVC 0(0,R1),0(R7)\n*\nDCB      DCB   DDNAME=SYSOUT,                                          X\n               DSORG=PS,                                               X\n               MACRF=PL\nDCBL     EQU   *-DCB\n*\nOPEN     OPEN  (,),                                                    X\n               MF=L\nOPENL    EQU   *-OPEN\n*\nCLOSE    CLOSE (,),                                                    X\n               MF=L\nCLOSEL   EQU   *-CLOSE\n*\n         DCBD  DSORG=PS\n*\n*---------------------------------------------------------------------*\n*        LOCAL (AUTO) STORAGE                                         *\n*---------------------------------------------------------------------*\n*\n*   N.B. AUTO STORAGE INITIALIZED TO BINARY ZEROS ON PROGRAM ENTRY\n*\n@VARS    DSECT ,\n@RC      DS    F\n@STR1    DS    F\n@STR1L   DS    F\n@STR2    DS    F\n@STR2L   DS    F\n@OP      DS    CL2\n@SEP     DS    B\n@OPEN    OPEN  (,),MF=L\n@CLOSE   CLOSE (,),MF=L\n@SYSOUT  DCB   DSORG=PS,MACRF=(PL)\n@VARSLEN EQU   *-@VARS\n*\n         END   PSU002\n./ ADD NAME=PSU003,LEVEL=00\n./ NUMBER NEW1=10000,INCR=10000\n* COPYRIGHT (C) 1988, PAUL A. SCOTT, ALL RIGHTS RESERVED\n* ANY USE OF THIS CODE MUST RETAIN THE ABOVE COPYRIGHT NOTICE\n*\n* MODULE     PSU003\n* AUTHOR     P. SCOTT\n*\n* PSU003 IS RENT,REUS\n*\n* EXAMPLE:\n*    //STEP1   EXEC PGM=PSU003,\n*    //            PARM=('&&PREFIX=PROD.LOAN.SL')\n*\n*\nPSU003   TITLE ' - MAINLINE PROCESSING '\n*---------------------------------------------------------------------*\n*        MAINLINE PROCESSING                                          *\n*---------------------------------------------------------------------*\n*\nPSU003   PENTER MAIN,VARS=(ZVARS,ZVARL),STACK=1\n*\n         BAL   R14,B0000           PARSE OUT STRINGS\n*\n         LA    R0,ZSTRINGS         START OF STRING PTRS\n         C     R0,ZSTREPTR         WERE ANY STRINGS FOUND ?\n         BL    A0100               YES, PROCESS THEM\n*\n         LA    R0,28               MESSAGE LENGTH\n         LA    R1,=C'PSU0030I NO STRINGS DEFINED.'\n         BAL   R14,W0000           WRITE MESSAGE TO JOB LOG\n         MVC   ZRC,=A(8)           SET RETURN CODE\n         B     EXIT                AND EXIT\n*\nA0100    BAL   R14,W0100           WRITE STRINGS TO LOG\n         BAL   R14,P0000           PROCESS INPUT DATA SET\n*\nEXIT     L     R15,ZRC             GET RETURN CODE\n         PEXIT RC=(15)             RETURN TO CALLER\n*\n         TITLE ' - B0000 - PARSE OUT STRINGS '\n*---------------------------------------------------------------------*\n*        B0000 - PARSE OUT STRINGS                                    *\n*---------------------------------------------------------------------*\n*\nB0000    PUSHREG R14               SAVE RETURN PTR\n*\n         LA    R6,ZSTRINGS         TABLE OF STRPTR'S AND STRLEN'S\n         USING STRINGS,R6\n*\n         BAL   R14,B1000           PROCESS PARM STRINGS\n         BAL   R14,B2000           PROCESS SYSIN STRINGS\n*\n         BCTR  R6,0                LAST BYTE USED IN STRING TABLE\n         ST    R6,ZSTREPTR         SAVE END OF TABLE PTR\n*\nB0990    POPREG R14                RETORE RETURN PTR\n         BR    R14                 RETURN\n*\n         TITLE ' - B1000 - PROCESS PARM DATA '\n*---------------------------------------------------------------------*\n*        B1000 - PROCESS PARM DATA                                    *\n*---------------------------------------------------------------------*\n*\nB1000    PUSHREG R14               SAVE RETURN PTR\n*\n         L     R2,0(,R1)           PARM PTR\n         LH    R4,0(,R2)           PARM LENGTH\n*\n         LTR   R4,R4               CHECK FOR PRESENCE OF PARM\n         BZ    B1990               SKIP IF NO PARM\n*\n         BCTR  R4,0                COMPUTE ZERO RELATIVE LENGTH\n         MVC   STRBFR(0),2(R2)     MODEL\n         EX    R4,*-6              SAVE THE STRING\n*\n         LA    R15,STRBFR(R4)      POINT TO LAST  BYTE OF PARM DATA\n         LA    R2,STRBFR           POINT TO FIRST BYTE OF PARM DATA\n         BAL   R14,C0000           PARSE FIELDS\n*\nB1990    POPREG R14                RESTORE RETURN PTR\n         BR    R14                 RETURN\n*\n         TITLE ' - B2000 - PROCESS SYSIN DATA '\n*---------------------------------------------------------------------*\n*        B2000 - PROCESS SYSIN DATA                                   *\n*---------------------------------------------------------------------*\n*\nB2000    PUSHREG R14               SAVE RETURN PTR\n*\n         LA    R2,=CL8'SYSIN'\n         BAL   R14,D1000           OBTAIN SYSIN DATA SET INFO\n         BNZ   B2990               NO, RETURN\n*\n         LA    R2,ZDCBPS1          ESTABLISH DCB ADDRESSABILITY\n         USING IHADCB,R2\n*\n         MVC   ZDCBPS1(DCBPSL),DCBPS      INITIALIZE DCB\n         MVC   DCBDDNAM,=CL8'SYSIN'       DDNAME=SYSIN\n         LA    R0,B2980                   SYSIN END-OF-DATA ROUTINE\n         STCM  R0,B'0111',DCBEODA         EODAD=B2980\n*\n         MVC   ZOPEN(OPENL),OPEN\n         OPEN  (ZDCBPS1,(INPUT)),MF=(E,ZOPEN)\n         TM    DCBOFLGS,DCBOFOPN   DID SYSIN OPEN SUCCESSFULLY?\n         BNO   B2990               NO, RETURN\n*\n         DROP  R2\n*\nB2100    GET   ZDCBPS1             OBTAIN A RECORD\n         MVC   STRBFR(80),0(R1)\n*\n         LA    R15,STRBFR+70       POINT TO LAST  BYTE OF PARM DATA\n         LA    R2,STRBFR           POINT TO FIRST BYTE OF PARM DATA\n         BAL   R14,C0000           PARSE FIELDS\n*\n         B     B2100\n*\nB2980    MVC   ZCLOSE(CLOSEL),CLOSE\n         CLOSE (ZDCBPS1),MF=(E,ZCLOSE)\n*\nB2990    POPREG R14                RESTORE RETURN PTR\n         BR    R14                 RETURN\n*\n         TITLE ' - C0000 - PARSE FIELDS '\n*---------------------------------------------------------------------*\n*        C0000 - PARSE FIELDS                                         *\n*           ENTRY:                                                    *\n*               R2 - START OF DATA AREA                               *\n*              R15 - LAST BYTE OF DATA AREA                           *\n*---------------------------------------------------------------------*\n*\nC0000    PUSHREG R14               SAVE RETURN PTR\n*\n*        REMOVE LEADING SPACES\n*\n         LR    R4,R2               SAVE STARTING LOCATION\n         LA    R14,1               INCREMENT A BYTE AT A TIME\n*\nC0100    CLI   0(R4),C' '          SPACE CHARACTER ?\n         BNE   C0150               NO, FOUND SIGNIFICANT CHARACTER\n         BXLE  R4,R14,C0100        SCAN ALL OF DATA\n         B     C0990               RETURN, NO DATA\n*\n*        REMOVE TRAILING SPACES\n*\nC0150    LR    R2,R4               NEW LOCATION OF DATA\n         LR    R4,R15              START WITH END OF RECORD\n         LA    R14,1               DECREMENT A BYTE AT A TIME\n         LNR   R14,R14             MAKE NEGATIVE INCREMENT\n         LR    R15,R2              FINISH WITH START OF RECORD\n*\nC0200    CLI   0(R4),C' '          CHECK FOR SPACE\n         BNE   C0250               FOUND A CHARACTER\n         BXH   R4,R14,C0200        KEEP LOOKING\n*\n*        COMPUTE SCAN LENGTH - 1\n*\nC0250    SR    R4,R2               COMPUTE LENGTH OF STRING - 1\n         LTR   R4,R4               COMPUTED VALUE SHOULD NEVER\n         BM    C0990                  BECOME NEGATIVE\n*\n*        LOCATE AND SAVE START AND LENGTH OF EACH FIELD\n*\n         LA    R5,0(R4,R2)         POINT TO LAST BYTE OF PARM\n         LA    R4,1                STEP ONE BYTE AT A TIME\n         LR    R7,R2               SAVE PTR TO FIRST BYTE OF PARM\n*\nC0300    CLI   0(R2),C'='          FOUND END OF FIRST FIELD ?\n         BE    C0350               YES, SAVE FIRST FIELD\n         CLI   0(R2),C','          FOUND END OF SECOND FIELD ?\n         BNE   C0400               NO, TRY NEXT CHARACTER\nC0350    MVC   ZSEPCHAR,0(R2)      SAVE SEPARATER CHARACTER\n         BAL   R14,C1000           SAVE CURRENT FIELD\nC0400    BXLE  R2,R4,C0300         SCAN ENTIRE PARM\n*\n         MVI   ZSEPCHAR,C'!'       INDICATE END OF DATA\n         BAL   R14,C1000           SAVE CURRENT FIELD\n*\nC0990    POPREG R14                RESTORE RETURN PTR\n         BR    R14                 RETURN\n*\n         TITLE ' - C1000 - SAVE CURRENT FIELD '\n*---------------------------------------------------------------------*\n*        C1000 - SAVE CURRENT FIELD                                   *\n*---------------------------------------------------------------------*\n*\nC1000    PUSHREG R14               SAVE RETURN PTR\n*\n         L     R14,=A(STRNUM*STRLEN)\n         LA    R0,ZSTRINGS(R14)\n         CR    R0,R6               MAXIMUM NUMBER OF STRINGS ?\n         BH    C1100               NO, CONTINUE\n*\n         LA    R0,43               MESSAGE LENGTH\n         LA    R1,=C'PSU0031I EXCEEDED MAXIMUM NUMBER OF STRINGS'\n         BAL   R14,W0000           WRITE MESSAGE TO JOB LOG\n         ABEND 1\n*\nC1100    CLI   ZSEPCHAR,C','       IS THIS THE SECOND STRING ?\n         BE    C1150               YES, PROCESS SECOND\n*\n         OC    STR1PTR,STR1PTR     IS THIS THE FIRST STRING ?\n         BNZ   C1150               NO, PROCESS SECOND\n*\n         ST    R7,STR1PTR          STORE START OF FIELD\n         LR    R14,R2              CURRENT LOCATION\n         SR    R14,R7              COMPUTE LENGTH OF PARM\n         ST    R14,STR1LEN         SAVE LENGTH\n         LA    R7,1(,R2)           COMPUTE BEGINNING OF NEXT FIELD\n*\n         CLI   ZSEPCHAR,C'!'       END OF DATA ?\n         BE    C1175               YES, POINT TO NEXT GROUP OF STRINGS\n*\n         B     C1200               RETURN\n*\nC1150    CLI   ZSEPCHAR,C'='       FIRST STRING SEPARATOR ?\n         BE    C1200               YES, BUT MUST BE DATA\n*\n         OC    STR2PTR,STR2PTR     ALREADY ACCOUNTED FOR END OF PARM ?\n         BNZ   C1200               YES, RETURN\n*\n         ST    R7,STR2PTR          STORE START OF FIELD\n         LR    R14,R2              CURRENT LOCATION\n         SR    R14,R7              COMPUTE LENGTH OF PARM\n         ST    R14,STR2LEN         SAVE LENGTH\n         LA    R7,1(,R2)           COMPUTE BEGINNING OF NEXT FIELD\n*\nC1175    LA    R6,STRLEN(,R6)      POINT TO NEXT GROUP OF STRINGS\n*\nC1200    POPREG R14                RESTORE RETURN PTR\n         BR    R14                 RETURN\n*\n         TITLE ' - D0000 - DYNAMIC ALLOCATION '\n*---------------------------------------------------------------------*\n*        D0000 - DYNAMIC ALLOCATION                                   *\n*---------------------------------------------------------------------*\n*\nD0000    PUSHREG R14               SAVE RETURN PTR\n*\n         LA    R1,ZDRB\n         ST    R1,ZDRBP\n         OI    ZDRBP,X'80'\n         LA    R1,ZDRBP\n         DYNALLOC ,\n*\nD0990    POPREG R14                RESTORE RETURN PTR\n         BR    R14                 RETURN\n*\n         TITLE ' - D1000 - OBTAIN DATA SET INFO '\n*---------------------------------------------------------------------*\n*        D1000 - OBTAIN DATA SET INFO                                 *\n*---------------------------------------------------------------------*\n*\nD1000    PUSHREG R14               SAVE RETURN PTR\n*\n         LA    R14,ZINTU1          ALLOCATION TEXT UNIT 1\n         LA    R15,ZINTU2          ALLOCATION TEXT UNIT 2\n         LA    R0,ZINTU3           ALLOCATION TEXT UNIT 3\n         LA    R1,ZINTU4           ALLOCATION TEXT UNIT 4\n         O     R1,=A(X'80000000')  MARK END OF LIST\n         STM   R14,R1,ZDTUP        STORE LIST OF POINTERS\n*\n         XC    ZDRB,ZDRB\n         MVI   ZDRBL,20\n         MVI   ZDRBVERB,S99VRBIN\n         LA    R14,ZDTUP\n         ST    R14,ZDRBTUP\n*\n         MVC   ZINTU1V,=Y(DINDDNAM) DDNAME REFERENCE\n         MVC   ZINTU1N,=Y(1)       NUMBER OF ENTRIES\n         MVC   ZINTU1L,=Y(8)       LENGTH OF EACH ENTRY\n         MVC   ZINTU1E(8),0(R2)\n*\n         MVC   ZINTU2V,=Y(DINRTDSN) RETURN DSNAME\n         MVC   ZINTU2N,=Y(1)       NUMBER OF ENTRIES\n         MVC   ZINTU2L,=Y(44)      LENGTH OF EACH ENTRY\n         MVI   ZINTU2E,C' '        INITIALIZE ENTRY\n         MVC   ZINTU2E+1(L'ZINTU2E-1),ZINTU2E\n*\n         MVC   ZINTU3V,=Y(DINRTTYP) RETURN DATA SET TYPE\n         MVC   ZINTU3N,=Y(1)       NUMBER OF ENTRIES\n         MVC   ZINTU3L,=Y(1)       LENGTH OF EACH ENTRY\n         MVI   ZINTU3E,0           INITIALIZE ENTRY\n*\n         MVC   ZINTU4V,=Y(DINRTORG) RETURN DATA SET ORGANIZATION\n         MVC   ZINTU4N,=Y(1)       NUMBER OF ENTRIES\n         MVC   ZINTU4L,=Y(2)       LENGTH OF EACH ENTRY\n         MVC   ZINTU4E,=Y(0)       INITIALIZE ENTRY\n*\n         BAL   R14,D0000\n*\n         POPREG R14                RESTORE RETURN PTR\n         LTR   R15,R15             SET CONDITION CODE\n         BR    R14                 RETURN\n*\n         TITLE ' - D2000 - OBTAIN MEMBER NAME '\n*---------------------------------------------------------------------*\n*        D2000 - OBTAIN MEMBER NAME                                   *\n*---------------------------------------------------------------------*\n*\nD2000    PUSHREG R14               SAVE RETURN PTR\n*\n         LA    R14,ZINTU1          ALLOCATION TEXT UNIT 1\n         LA    R15,ZINTU5          ALLOCATION TEXT UNIT 2\n         O     R15,=A(X'80000000') MARK END OF LIST\n         STM   R14,R15,ZDTUP       STORE LIST OF POINTERS\n*\n         XC    ZDRB,ZDRB\n         MVI   ZDRBL,20\n         MVI   ZDRBVERB,S99VRBIN\n         LA    R14,ZDTUP\n         ST    R14,ZDRBTUP\n*\n         MVC   ZINTU1V,=Y(DINDDNAM) DDNAME REFERENCE\n         MVC   ZINTU1N,=Y(1)       NUMBER OF ENTRIES\n         MVC   ZINTU1L,=Y(8)       LENGTH OF EACH ENTRY\n         MVC   ZINTU1E(8),0(R2)\n*\n         MVC   ZINTU5V,=Y(DINRTMEM) RETURN MEMBER NAME\n         MVC   ZINTU5N,=Y(1)       NUMBER OF ENTRIES\n         MVC   ZINTU5L,=Y(8)       LENGTH OF EACH ENTRY\n         MVI   ZINTU5E,C' '        INITIALIZE ENTRY\n         MVC   ZINTU5E+1(L'ZINTU5E-1),ZINTU5E\n*\n         BAL   R14,D0000\n*\n         POPREG R14                RESTORE RETURN PTR\n         LTR   R15,R15             SET CONDITION CODE\n         BR    R14                 RETURN\n*\n         TITLE ' - P0000 - PROCESS STRINGS '\n*---------------------------------------------------------------------*\n*        P0000 - PROCESS STRINGS '                                    *\n*---------------------------------------------------------------------*\n*\nP0000    PUSHREG R14               SAVE RETURN PTR\n*\n*        OBTAIN SYSUT1 DATA SET INFORMATION\n*\n         LA    R2,=CL8'SYSUT1'     DDNAME FOR INFO RETRIEVAL\n         BAL   R14,D1000           OBTAIN DATA SET INFORMATION\n         BZ    P0100               BRIF SUCCESSFUL\n*\n         LA    R0,37               MESSAGE LENGTH\n         LA    R1,=C'PSU0032I SYSUT1 DD STATEMENT MISSING.'\n         BAL   R14,W0000           WRITE MESSAGE TO JOB LOG\n         ABEND 2\n*\nP0100    MVC   ZSYSUT1O,ZINTU4E    SAVE SYSUT1 ORGANIZATION\n         MVC   ZSYSUT1T,ZINTU3E    SAVE SYSUT1 DATA SET TYPE\n         MVC   ZSYSUT1D,ZINTU2E    SAVE SYSUT1 DATA SET NAME\n         MVI   ZSYSUT1M,C' '       CLEAR MEMBER NAME\n         MVC   ZSYSUT1M+1(L'ZSYSUT1M-1),ZSYSUT1M\n*\n         CLC   ZSYSUT1O,=Y(DOPO)   PARTITIONED DATA SET ?\n         BE    P0150               YES, DO PO\n         CLC   ZSYSUT1O,=Y(DOPOU)  PARTITIONED DATA SET ?\n         BNE   P0200               NO, MUST BE SEQUENTIAL\n*\nP0150    LA    R2,=CL8'SYSUT1'     DDNAME FOR INFO RETRIEVAL\n         BAL   R14,D2000           OBTAIN MEMBER NAME\n         BNZ   P0200               BRIF NO MEMBER FOUND\n*\n         MVC   ZSYSUT1M,ZINTU5E\n         CLI   ZSYSUT1M,C' '\n         BE    P0200\n*\n         MVC   ZSYSUT1O,=Y(DOPS)   TREAT AS SEQUENTIAL DATA SET\n*\n*        OBTAIN SYSUT2 DATA SET INFORMATION\n*\nP0200    LA    R2,=CL8'SYSUT2'     DDNAME FOR INFO RETRIEVAL\n         BAL   R14,D1000           OBTAIN DATA SET INFORMATION\n         BZ    P0250               BRIF SUCCESSFUL\n*\n         LA    R0,37               MESSAGE LENGTH\n         LA    R1,=C'PSU0032I SYSUT2 DD STATEMENT MISSING.'\n         BAL   R14,W0000           WRITE MESSAGE TO JOB LOG\n         ABEND 2\n*\nP0250    MVC   ZSYSUT2O,ZINTU4E    SAVE SYSUT2 ORGANIZATION\n         MVC   ZSYSUT2T,ZINTU3E    SAVE SYSUT2 DATA SET TYPE\n         MVC   ZSYSUT2D,ZINTU2E    SAVE SYSUT2 DATA SET NAME\n         MVI   ZSYSUT2M,C' '       CLEAR MEMBER NAME\n         MVC   ZSYSUT2M+1(L'ZSYSUT2M-1),ZSYSUT2M\n*\n         CLC   ZSYSUT2O,=Y(DOPO)   PARTITIONED DATA SET ?\n         BE    P0300               YES, DO PO\n         CLC   ZSYSUT2O,=Y(DOPOU)  PARTITIONED DATA SET ?\n         BNE   P0350               NO, MUST BE SEQUENTIAL\n*\nP0300    LA    R2,=CL8'SYSUT2'     DDNAME FOR INFO RETRIEVAL\n         BAL   R14,D2000           OBTAIN MEMBER NAME\n         BNZ   P0350               BRIF NO MEMBER FOUND\n*\n         MVC   ZSYSUT2M,ZINTU5E\n         CLI   ZSYSUT2M,C' '\n         BE    P0350\n*\n         MVC   ZSYSUT2O,=Y(DOPS)   TREAT AS SEQUENTIAL DATA SET\n*\n*        SET IDENTICAL DATA SET FLAG\n*\nP0350    NI    ZFLAG1,255-ZF1IDENT RESET FLAG - DATASETS ARE DIFFERENT\n         CLC   ZSYSUT1D,ZSYSUT2D   ARE DSNAMES THE SAME ?\n         BNE   P0400               NO, THEN THEY'RE DIFFERENT\n         CLC   ZSYSUT1M,ZSYSUT2M   ARE MEMBER NAMES THE SAME ?\n         BNE   P0400               NO, THEN THEY'RE DIFFERENT\n         OI    ZFLAG1,ZF1IDENT     OTHERWISE, SET IDENTICAL FLAG\n*\n*        PROCESS DATA SET BASED ON ORGANIZATION\n*\nP0400    LA    R15,PTABLE          START OF TABLE\n         LA    R0,L'PTABLE         LENGTH OF EACH ENTRY\n         LA    R1,PTBLEND          LAST BYTE OF LAST ENTRY\n*\n         USING PTABLE,R15\n*\nP0450    CLC   PTBLORG,ZDSORGS     FOUND COMPATIBLE DSORG'S ?\n         BE    P0500               YES, GO PROCESS DATA\n         BXLE  R15,R0,P0450        SCAN ENTIRE TABLE\n*\nP0500    L     R15,PTBLRTN         GET ROUTINE ADDRESS\n         BALR  R14,R15             GO TO ROUTINE\n*\n         DROP  R15\n*\nP0990    POPREG R14                RESTORE RETURN PTR\n         BR    R14                 RETURN\n*\n         TITLE ' - P1000 - PROCESS PO - PO DATA SETS '\n*---------------------------------------------------------------------*\n*        P1000 - PARTITIONED TO PARTITIONED                           *\n*---------------------------------------------------------------------*\n*\nP1000    PUSHREG R14               SAVE RETURN PTR\n*\n*      * CURRENTLY UNIMPLEMENTED *\n*\n*        ADD CODE HERE TO APPLY STRINGS TO EVERY MEMBER.\n*\n*        SYSUT1 AND SYSUT2 COULD BE THE SAME DATA SET OR\n*        DIFFERENT  DATA SETS.  SEE ROUTINE P3000 FOR AN\n*        EXAMPLE OF HOW TO HANDLE UPDATE-IN-PLACE.\n*\n*\n         LA    R0,44               MESSAGE LENGTH\n         LA    R1,=C'PSU0033I SYSUT1/PO SYSUT2/PO NOT IMPLEMENTED'\n         BAL   R14,W0000           WRITE MESSAGE TO JOB LOG\n         ABEND 3                   ABEND UNTIL IMPLEMENTED\n*\n         POPREG R14                RESTORE RETURN PTR\n         BR    R14                 RETURN\n*\n         TITLE ' - P2000 - PROCESS PO - PS DATA SETS '\n*---------------------------------------------------------------------*\n*        P2000 - PARTITIONED TO SEQUENTIAL                            *\n*---------------------------------------------------------------------*\n*\nP2000    PUSHREG R14               SAVE RETURN PTR\n*\n*      * CURRENTLY UNIMPLEMENTED *\n*\n*        ADD CODE HERE TO APPLY STRINGS TO EVERY MEMBER.\n*\n*        SINCE SYSUT2 IS SEQUENTIAL, ALL MEMBERS MUST BE\n*        CONCATENATED ON OUTPUT.\n*\n         LA    R0,44               MESSAGE LENGTH\n         LA    R1,=C'PSU0033I SYSUT1/PO SYSUT2/PS NOT IMPLEMENTED'\n         BAL   R14,W0000           WRITE MESSAGE TO JOB LOG\n         ABEND 3                   ABEND UNTIL IMPLEMENTED\n*\n         POPREG R14                RESTORE RETURN PTR\n         BR    R14                 RETURN\n*\n         TITLE ' - P3000 - PROCESS PS - PS DATA SETS '\n*---------------------------------------------------------------------*\n*        P3000 - SEQUENTIAL TO SEQUENTIAL                             *\n*---------------------------------------------------------------------*\n*\nP3000    PUSHREG R14               SAVE RETURN PTR\n*\n*        HANDLE THE CASE WHERE BOTH SYSUT1 AND SYSUT2 HAVE DSORG=PS\n*        OR ARE TREATED AS DSORG=PS BECAUSE A MEMBER NAME IS GIVEN.\n*\n*        SYSUT1 AND SYSUT2 COULD BOTH POINT TO THE IDENTICAL DATA\n*        SET OR MEMBER. IF SO, RECORDS ARE UPDATED IN PLACE.\n*\n*        OPEN SYSUT1 FOR INPUT (OR UPDATE-IN-PLACE)\n*\n         LA    R2,ZDCBPS1          ESTABLISH DCB ADDRESSABILITY\n         USING IHADCB,R2\n*\n         MVC   ZDCBPS1(DCBPSL),DCBPS      INITIALIZE DCB\n         MVC   DCBDDNAM,=CL8'SYSUT1'      DDNAME=SYSUT1\n         LA    R0,P3980                   SYSIN END-OF-DATA ROUTINE\n         STCM  R0,B'0111',DCBEODA         EODAD=P3980\n*\n         TM    ZFLAG1,ZF1IDENT     ARE SYSUT1 AND SYSUT2 IDENTICAL ?\n         BNO   P3100               NO, OPEN FOR INPUT PROCESSING\n*\n         MVC   ZOPEN(OPENL),OPEN   YES, OPEN SYSUT1 FOR UPDATE\n         OPEN  (ZDCBPS1,(UPDAT)),MF=(E,ZOPEN)\n         B     P3150\n*\nP3100    MVC   ZOPEN(OPENL),OPEN\n         OPEN  (ZDCBPS1,(INPUT)),MF=(E,ZOPEN)\n*\n         DROP  R2\n*\n*        OPEN SYSUT2 FOR OUTPUT (IF SYSUT1 IS OPEN FOR INPUT)\n*\n         LA    R2,ZDCBPS2          ESTABLISH DCB ADDRESSABILITY\n         USING IHADCB,R2\n*\n         MVC   ZDCBPS2(DCBPSL),DCBPS      INITIALIZE DCB\n         MVC   DCBDDNAM,=CL8'SYSUT2'      DDNAME=SYSUT1\n*\n         MVC   ZOPEN(OPENL),OPEN\n         OPEN  (ZDCBPS2,(OUTPUT)),MF=(E,ZOPEN)\n*\n         DROP  R2\n*\n*        PROCESS THE REPLACEMENT STRINGS AGAINST SYSUT1\n*\nP3150    GET   ZDCBPS1             GET A RECORD\n*\n         BAL   R14,R0000           REPLACE STRINGS IN RECORD\n*\n         TM    ZFLAG1,ZF1IDENT     SYSSUT1 AND SYSUT2 IDENTICAL ?\n         BNO   P3200               NO, THEN WRITE NEW RECORD\n         PUTX  ZDCBPS1             REPLACE OLD RECORD\n         B     P3150               PROCESS THE ENTIRE DATA SET\n*\nP3200    LR    R0,R1               COPY RECORD PTR\n         PUT   ZDCBPS2,(0)         OUTPUT NEW RECORD\n         B     P3150               PROCESS THE ENTIRE DATA SET\n*\n*        CLOSE THE DATA SETS AND RETURN\n*\nP3980    MVC   ZCLOSE(CLOSEL),CLOSE\n         CLOSE (ZDCBPS1),MF=(E,ZCLOSE)\n         TM    ZFLAG1,ZF1IDENT     SYSUT1 AND SYSUT2 IDENTICAL ?\n         BO    P3990               YES, SKIP CLOSE\n         CLOSE (ZDCBPS2),MF=(E,ZCLOSE)\n*\nP3990    POPREG R14                RESTORE RETURN PTR\n         BR    R14                 RETURN\n*\n         TITLE ' - P4000 - INCOMPATIBLE DSORGS '\n*---------------------------------------------------------------------*\n*        P4000  - INCOMPATIBLE DSORGS                                 *\n*---------------------------------------------------------------------*\n*\nP4000    PUSHREG R14               SAVE RETURN PTR\n*\n*      * UNIMPLEMETABLE *\n*\n         LA    R0,28\n         LA    R1,=C'SYSUT2 REQUIRES MEMBER NAME.'\n         BAL   R14,W0000\n*\n         LA    R0,44               MESSAGE LENGTH\n         LA    R1,=C'PSU0033I SYSUT1 OR SYSUT2 DSORG INCOMPATIBLE'\n         BAL   R14,W0000           WRITE MESSAGE TO JOB LOG\n         ABEND 3                   ABEND ALWAYS\n*\n         POPREG R14                RESTORE RETURN PTR\n         BR    R14                 RETURN\n*\n         TITLE ' - R0000 - REPLACE STRINGS IN RECORD '\n*---------------------------------------------------------------------*\n*        R0000 - REPLACE STRINGS IN RECORD                            *\n*---------------------------------------------------------------------*\n*\n*        THIS ROUTINE OBEYS JCL RULES OF STRING CONCATENATION.\n*        THAT IS, A SEARCH STRING THAT BEGINS WITH & ENDS AT\n*        EITHER A NON-ALPHANUMERIC OR . CHARACTER. IF IT ENDS\n*        WITH A . THEN THE . IS REMOVED.\n*\n*        FOR EXAMPLE IF THE PARM IS CODED AS ('&&PREF=PSCOTT')\n*        (NOTE THE && IN JCL WILL BE SEEN AS A SINGLE & HERE)\n*        THEN &PREF..MY.CNTL WILL BE REPLACED BY PSCOTT.MY.CNTL\n*        BUT &PREFIX..MY.CNTL WILL NOT MATCH AND NO REPLACEMENT\n*        WILL BE MADE.\n*\n*        SEARCH STRINGS THAT DO NOT BEGIN WITH & HAVE NO SUCH\n*        RULES APPPLIED, SO THAT IF THE PARM IS ('PREF=PSCOTT')\n*        THEN &PREF..MY.CNTL WITLL BE BECOME &PSCOTT..MY.CNTL\n*        AND &PREFIX..MY.CNTL WILL BECOME &PSCOTTIX..MY.CNTL\n*\nR0000    PUSHREG R14               SAVE RETURN PTR\n         PUSHREG R1                SAVE RECORD PTR\n*\n         MVI   ZWORKREC,C' '       CLEAR WORK RECORD\n         MVC   ZWORKREC+1(L'ZWORKREC-1),ZWORKREC\n         MVC   ZWORKREC(71),0(R1)       COPY DATA RECORD\n*\n         LA    R6,ZSTRINGS         START OF PTRS\n         LA    R4,STRLEN           LENGTH OF EACH ENTRY\n         L     R5,ZSTREPTR         LAST BYTE OF LAST ENTRY\n*\nR0100    L     R7,STR1PTR          PTR TO STRING TO LOCATE\n         L     R8,STR1LEN          PTR TO STRING LENGTH\n         LTR   R7,R7               NULL STRING PTR ?\n         BZ    R0900               YES, SKIP STRING\n         LTR   R8,R8               LENGTH ZERO ?\n         BZ    R0900               YES, SKIP STRING\n*\n         BCTR  R8,0                GET ZERO RELATIVE LENGTH\n         LA    R1,ZWORKREC         POINT AT RECORD\n         LA    R14,1               SCAN A BYTE AT A TIME\n         LA    R15,ZWORKREC+L'ZWORKREC-1  LAST BYTE IN RECORD TO SCAN\n         SR    R15,R8              ADJUST FOR LENGTH OF STRING\n*\nR0150    CLC   0(0,R1),0(R7)       MODEL COMPARE INSTRUCTION\n         EX    R8,*-6              HAS STRING BEEN LOCATED ?\n         BNE   R0300               NO, KEEP LOOKING\n*\n         CLI   0(R7),C'&&'         FIRST CHAR AN AMPERSAND ?\n         BNE   R0350               NO, THEN REPLACE STRING\n*\n         SR    R2,R2               CLEAR REGISTER\n         IC    R2,1(R8,R1)         GET CHARACTER AFTER STRING\n         LA    R2,TCHARTBL(R2)     INDEX INTO TABLE\n*\n         CLI   0(R2),C'.'          CONCATENATION CHARACTER ?\n         BNE   R0250               NO, THEN KEEP LOOKING FOR STRING\n         LA    R8,1(,R8)           REMOVE THE PERIOD WITH THE STRING\n         B     R0350               REMOVE STRING\n*\nR0250    CLI   0(R2),0             STRING TERMINATION CHARACTER ?\n         BE    R0350               YES, REPLACE THE STRING\n*\nR0300    BXLE  R1,R14,R0150        SCAN ENTIRE RECORD\n         B     R0900               STRING WAS NOT FOUND\n*\nR0350    LR    R2,R1               SAVE STRING PTR\n         LR    R0,R2                    DESTINATION PTR (STRING)\n         LA    R1,ZWORKREC+L'ZWORKREC   COMPUTE THE\n         SR    R1,R0                    DESTINATION LENGTH\n         LA    R14,1(R8,R2)             SOURCE PTR (CHAR AFTER STRING)\n         LA    R15,ZWORKREC+L'ZWORKREC  COMPUTE THE\n         SR    R15,R14                  SOURCE LENGTH\n         ICM   R15,B'1000',=C' '   SPACE FILL\n         MVCL  R0,R14              SHIFT THE STRING OVER\n         LR    R1,R2               RESTORE STRING PTR\n*\n         L     R7,STR2PTR          PTR TO REPLACEMENT STRING\n         L     R8,STR2LEN          LENGTH OF REPLACEMENT STRING\n         LTR   R7,R7               NULL STRING PTR ?\n         BZ    R0900               YES, NOTHING TO REPLACE\n         LTR   R8,R8               LENGTH ZERO ?\n         BZ    R0900               YES, NOTHING TO REPLACE\n*\n         LA    R2,ZWORKREC+L'ZWORKREC-1  PTR TO TARGET\n         LR    R15,R2              COMPUTE THE\n         SR    R15,R8                 PTR TO SOURCE\n         LA    R14,1(,R15)\n         SR    R14,R1\n*\nR0400    MVC   0(1,R2),0(R15)      MOVE (PTR-N) TO (PTR)\n         BCTR  R2,0\n         BCTR  R15,0\n         BCT   R14,R0400           FINISH WITH START OF FIELD\n*\n         BCTR  R8,0\n         MVC   0(0,R1),0(R7)\n         EX    R8,*-6\n*\nR0900    BXLE  R6,R4,R0100         REPLACE ALL STRINGS IN RECORD\n*\n         POPREG R1                 RESTORE RECORD PTR\n         MVC   0(71,R1),ZWORKREC   REPLACE RECORD\n*\n         POPREG R14                RESTORE RETURN PTR\n         BR    R14                 RETURN\n*\n         TITLE ' - W0000 - WRITE TO LOG '\n*---------------------------------------------------------------------*\n*        W0000 - WRITE TO LOG                                         *\n*---------------------------------------------------------------------*\n*\nW0000    PUSHREG R14                   SAVE RETURN PTR\n*\n         MVC   ZWTO,WTO                INITIALIZE WTO PARAMETER LIST\n         MVI   ZMSG,C' '               CLEAR MESSAGE BUFFER\n         MVC   ZMSG+1(L'ZMSG-1),ZMSG      TO ALL SPACES\n*\n         LR    R15,R0                  GET MESSAGE LENGTH\n         CH    R15,=Y(L'ZMSG)          TOO LARGE FOR MESSAGE BUFFER ?\n         BNH   W0010                   NO, MESSAGE WILL FIT\n         LH    R15,=Y(L'ZMSG)          TRUNCATE MESSAGE TO BUFFER SIZE\nW0010    BCTR  R15,0                   MAKE LENGTH ZERO RELATIVE\n         MVC   ZMSG(0),0(R1)           INSTRUCTION TEMPLATE\n         EX    R15,*-6                 MOVE MESSAGE TO WTO BUFFER\n*\n         WTO   MF=(E,ZWTO)             WRITE TO JOB LOG\n*\n         POPREG R14                RESTORE RETURN PTR\n         BR    R14                 RETURN\n*\n*        DUMP THE REPLACEMENT STRINGS TO THE JOB LOG\n*\nW0100    PUSHREG R14\n*\n         LA    R6,ZSTRINGS         START OF PTRS\n         LA    R4,STRLEN           LENGTH OF EACH ENTRY\n         L     R5,ZSTREPTR         LAST BYTE OF LAST ENTRY\n*\nW0120    MVC   ZWTO,WTO                INITIALIZE WTO PARAMETER LIST\n         MVI   ZMSG,C' '               CLEAR MESSAGE BUFFER\n         MVC   ZMSG+1(L'ZMSG-1),ZMSG      TO ALL SPACES\n         LA    R1,ZMSG\n*\n         USING STRINGS,R6\n         USING ZMSG,R1\n*\n         MVC   ZMSG(8),=C'PSU0034I'    MESSAGE PREFIX\n         LA    R1,9(0,R1)              NEXT AVAILABLE SLOT\n*\n         MVC   ZMSG(6),=C'(NULL)'      DEFAULT SEARCH STRING\n         L     R7,STR1PTR              SEARCH STRING PTR\n         L     R8,STR1LEN              SEARCH STRING LENGTH\n         LTR   R7,R7                   NULL SEARCH STRING PTR ?\n         BZ    W0130                   YES, MOVE ON\n         LTR   R8,R8                   NULL SEARCH STRING LENGTH ?\n         BZ    W0130                   YES, MOVE ON\n         MVC   ZMSG(6),=CL6' '         CLEAR '(NULL)'\n         BCTR  R8,0                    MAKE ZERO RELATIVE LENGTH\n         MVC   ZMSG(0),0(R7)           INSTRUCTION TEMPLATE\n         EX    R8,*-6                  COPY SEARCH STRING TO BUFFER\n         LA    R1,1(R8,R1)             NEXT AVAILABLE SLOT\n*\nW0130    MVI   ZMSG,C'='               SET DEMARCATION LITERAL\n         LA    R1,1(0,R1)              NEXT AVAILABLE SLOT\n*\n         MVC   ZMSG(6),=C'(NULL)'      DEFAULT REPLACEMENT STRING\n         L     R7,STR2PTR              REPLACEMENT STRING PTR\n         L     R8,STR2LEN              REPLACEMENT STRING LEN\n         LTR   R7,R7                   NULL REPLACEMENT STRING PTR ?\n         BZ    W0150                   YES, MOVE ON\n         LTR   R8,R8                   NULL REPLACEMENT STRING LENGTH ?\n         BZ    W0140                   YES, MOVE ON\n         MVC   ZMSG(6),=CL6' '         CLEAR '(NULL)'\n         BCTR  R8,0                    MAKE ZERO RELATIVE LENGTH\n         MVC   ZMSG(0),0(R7)           INSTRUCTION TEMPLATE\n         EX    R8,*-6                  COPY REPLACEMENT STRNG TO BUFFER\n         LA    R1,1(R8,R1)             NEXT AVAILABLE SLOT\n         DROP  R1\n*\nW0140    WTO   MF=(E,ZWTO)\n*\nW0150    BXLE  R6,R4,W0120         SCAN ENTIRE OPERATOR TABLE\n*\n         POPREG R14                RESET ALL BITS\n         BR    R14\n*\n         TITLE ' - TABLES '\n*---------------------------------------------------------------------*\n*        DATA SET PROCESSING TABLE                                    *\n*---------------------------------------------------------------------*\n         DS    0F                  ALIGN TABLE ON FULLWORD BOUNDARY\nPTABLE   DS    0CL8                DATA SET PROCESSING TABLE\nPTBLORG  DS    A                   . ORGANIZATION (SYSUT1,SYSUT2)\nPTBLRTN  DS                 A      . ROUTINE\n         ORG   PTABLE\n         DC    Y(DOPO,DOPO),A(P1000)\n         DC    Y(DOPO,DOPS),A(P2000)\n         DC    Y(DOPS,DOPS),A(P3000)\nPTBLEND  EQU *-1\n         DC    Y(-001,-001),A(P4000)\n*\n*---------------------------------------------------------------------*\n*        TABLE OF STRING TERMINATION CHARACTERS                       *\n*---------------------------------------------------------------------*\n*\nTCHARTBL DC    256X'00'\n         ORG   TCHARTBL+C'A'\n         DC    C'ABCDEFGHI'\n         ORG   TCHARTBL+C'J'\n         DC    C'JKLMNOPQR'\n         ORG   TCHARTBL+C'S'\n         DC    C'STUVWXYZ'\n         ORG   TCHARTBL+C'0'\n         DC    C'0123456789'\n         ORG   TCHARTBL+C'Z'\n         DC    C'Z'\n         ORG   TCHARTBL+C'#'\n         DC    C'#'\n         ORG   TCHARTBL+C'$'\n         DC    C'4'\n         ORG   TCHARTBL+C'.'\n         DC    C'.'\n         ORG   ,\n*\n*---------------------------------------------------------------------*\n*        STRING TABLE                                                 *\n*---------------------------------------------------------------------*\n*\nSTRINGS  DSECT ,                   MAP STRING TABLE\nSTR1PTR  DS    F                   . STRING 1 PTR\nSTR1LEN  DS    F                   . STRING 1 LENGTH\nSTR2PTR  DS    F                   . STRING 2 PTR\nSTR2LEN  DS    F                   . STRING 2 LENGTH\nSTRBFR   DS    CL100               . STRING BUFFER\nSTRLEN   EQU   *-STRINGS           LENGTH OF EACH ENTRY\nSTRNUM   EQU   500                 TOTAL NUMBER OF ENTRIES\nPSU003   CSECT ,                   RESTORE CSECT\n*\n         TITLE ' - CONSTANTS AND TEMPLATES'\n*---------------------------------------------------------------------*\n*        CONSTANTS AND TEMPLATES                                      *\n*---------------------------------------------------------------------*\n*\nERROR4   EQU   4\nERROR8   EQU   8\nERROR12  EQU   12\n*\nWTO      WTO   '4....10...15...20...25...30...35...40...45...50...55', C\n               DESC=6,ROUTCDE=11,MF=L\nWTOL     EQU   *-WTO\n*\n         DS    0F\nOPEN     OPEN  (*),MF=L\nOPENL    EQU   *-OPEN\n*\nDCBPS    DCB   DDNAME=Z,DSORG=PS,MACRF=(GL,PM),RECFM=FB,LRECL=80\nDCBPSL   EQU   *-DCBPS\n*\nDCBPO    DCB   DDNAME=Z,DSORG=PO,MACRF=(R,W),RECFM=FB,LRECL=80\nDCBPOL   EQU   *-DCBPO\n*\n         DS    0F\nCLOSE    CLOSE (*),MF=L\nCLOSEL   EQU   *-CLOSE\n*\n         TITLE ' - LOCAL VARIABLE STORAGE '\n*---------------------------------------------------------------------*\n*        LOCAL VARIABLE STORAGE                                       *\n*---------------------------------------------------------------------*\n*\nZVARS    DSECT ,\nZSAVEALL DS    18F                 SAVE AREA\nZRC      DS    F                   RETURN CODE\n*\n*        FLAG BYTES\n*\nZFLAG1   DS    B                   FLAG BYTE 1\nZF1IDENT EQU   B'10000000'         . SYSUT1 & SYSUT2 ARE IDENTICAL\n*        EQU   B'01000000'         . UNUSED\n*        EQU   B'00100000'         . UNUSED\n*        EQU   B'00010000'         . UNUSED\n*        EQU   B'00001000'         . UNUSED\n*        EQU   B'00000100'         . UNUSED\n*        EQU   B'00000010'         . UNUSED\n*        EQU   B'00000001'         . UNUSED\n*\n*        I/O WORK AREAS\n*\nZDIRREC  DS    CL256\nZDATAREC DS    CL80\nZWORKREC DS    CL(L'ZDATAREC*2)\n*\n*        DATA SET VARIABLE AND CONTROL BLOCKS\n*\n*        WTO   MF=L\nZWTO     DS    XL(WTOL)\nZMSG     EQU   ZWTO+4,52\n*\nZOPEN    DS    0F,(OPENL)X         OPEN  PARAMETER LIST\nZCLOSE   DS    0F,(CLOSEL)X        CLOSE PARAMETER LIST\n*\nZDCBPS1  DS    0D,(DCBPSL)X        SYSUT1 SEQUENTIAL  DATA SET DCB\nZDCBPO1  DS    0D,(DCBPOL)X        SYSUT1 PARTITIONED DATA SET DCB\nZJFCB1   DS    0F,(JFCBLGTH)X      SYSUT1 JFCB\n*\nZDCBPS2  DS    0D,(DCBPSL)X        SYSUT2 SEQUENTIAL  DATA SET DCB\nZDCBPO2  DS    0D,(DCBPOL)X        SYSUT2 PARTITIONED DATA SET DCB\nZJFCB2   DS    0F,(JFCBLGTH)X      SYSUT2 JFCB\n*\nZEXLST1  DS    3F                  SYSUT1 EXIT LIST\nZEXLST2  DS    3F                  SYSUT2 EXIT LIST\n*\nZDSNAMES DS    0CL88\nZSYSUT1D DS    CL44                SYSUT1 DATA SET NAME\nZSYSUT2D DS    CL44                SYSUT2 DATA SET NAME\n*\nZMEMBERS DS    0CL16\nZSYSUT1M DS    CL8                 SYSUT1 MEMBER NAME\nZSYSUT2M DS    CL8                 SYSUT2 MEMBER NAME\n*\nZDSORGS  DS    0AL4\nZSYSUT1O DS    Y                   SYSUT1 DATA SET ORGANIZATION\nZSYSUT2O DS    Y                   SYSUT2 DATA SET ORGANIZATION\n*\nZDSTYPES DS    0AL2\nZSYSUT1T DS    X                   SYSUT1 DATA SET TYPE\nZSYSUT2T DS    X                   SYSUT2 DATA SET TYPE\n*\n*        DYNAMIC ALLOCATION PARAMETER LISTS\n*\nZDRBP    DS    A(ZDRB)             REQUEST BLOCK PTR\n*\nZDRB     DS    0CL20               REQUEST BLOCK\nZDRBL    DS    AL1(20)             . LENGTH OF RB\nZDRBVERB DS    AL1(S99VRBAL)       . VERB CODE (ALLOCATION)\nZDRBFLAG DS    AL2(0)              . FLAGS\nZDRBECD  DS    AL2(0)              . ERROR CODE FIELDS\nZDRBRCD  DS    AL2(0)              . REASON CODE FIELDS\nZDRBTUP  DS    A(ZDTUP)            . ADR OF TEXT UNIT PTRS\n         DS    A(0)                . RESERVED\n         DS    AL4(0)              . FLAGS FOR AUTHORIZED FUNCTIONS\n*\nZDTUP    DS    8A                  TEXT UNIT POINTER LIST\n*\nZINTU1   DS    0CL14               TEXT UNIT 1\nZINTU1V  DS    AL2(DINDDNAM)       . DDNAME REFERENCE\nZINTU1N  DS    AL2(1)              . NUMBER OF ENTRIES\nZINTU1L  DS    AL2(8)              . LENGTH OF ENTRY\nZINTU1E  DS    CL8' '              . ENTRY PARAMETER\n*\nZINTU2   DS    0CL50               TEXT UNIT 2\nZINTU2V  DS    AL2(DINRTDSN)       . RETURN DATA SET NAME\nZINTU2N  DS    AL2(1)              . NUMBER OF ENTRIES\nZINTU2L  DS    AL2(44)             . LENGTH OF ENTRY\nZINTU2E  DS    CL44                . ENTRY PARAMETER\n*\nZINTU3   DS    0CL7                TEXT UNIT 3\nZINTU3V  DS    AL2(DINRTTYP)       . RETURN DATA SET TYPE\nZINTU3N  DS    AL2(1)              . NUMBER OF ENTRIES\nZINTU3L  DS    AL2(1)              . LENGTH OF ENTRY\nZINTU3E  DS    XL1'00'             . ENTRY PARAMETER\nDTDUMMY  EQU   X'80'\nDTTERM   EQU   X'40'\nDTSYSIN  EQU   X'20'\nDTSYSOUT EQU   X'10'\nDTFILE   EQU   X'00'\n*\nZINTU4   DS    0CL8                TEXT UNIT 4\nZINTU4V  DS    AL2(DINRTORG)       . RETURN DATA SET ORGANIZATION\nZINTU4N  DS    AL2(1)              . NUMBER OF ENTRIES\nZINTU4L  DS    AL2(2)              . LENGTH OF ENTRY\nZINTU4E  DS    AL2(0)              . ENTRY PARAMETER\nDOUNK    EQU   X'0000'\nDOVSAM   EQU   X'0008'\nDOPO     EQU   X'0200'\nDOPOU    EQU   X'0300'\nDODA     EQU   X'2000'\nDODAU    EQU   X'2100'\nDOPS     EQU   X'4000'\nDOPSU    EQU   X'4100'\n*\nZINTU5   DS    0CL14               TEXT UNIT 5\nZINTU5V  DS    AL2(DINRTMEM)       . RETURN MEMBER NAME\nZINTU5N  DS    AL2(1)              . NUMBER OF ENTRIES\nZINTU5L  DS    AL2(8)              . LENGTH OF ENTRY\nZINTU5E  DS    CL8' '              . ENTRY PARAMETER\n*\n*        STRING STORAGE\n*\nZSTREPTR DS    F\nZSEPCHAR DS    C\nZSTRINGS DS    (STRNUM*STRLEN)X    STORAGE FOR STRING PTRS AND LENGTHS\n*\nZVARL    EQU   *-ZVARS\n*\n         PUSH  PRINT\n         PRINT NOGEN\n*\n         DCBD  DSORG=PS\n         IEFZB4D0 ,\n         IEFZB4D2 ,\n         IEFJFCBN ,\n         IKJDAP08 ,\n*\n         POP   PRINT\n*\n         END   PSU003\n./ ADD NAME=PSU004,LEVEL=00\n./ NUMBER NEW1=10000,INCR=10000\n* COPYRIGHT (C) PAUL A. SCOTT, 1989. ALL RIGHTS RESERVED.\n* ANY USE OF THIS CODE MUST RETAIN THE ABOVE COPYRIGHT NOTICE\n*\n* MODULE     PSU004\n* AUTHOR     P. SCOTT\n*\n* PSU004 IS RENT,REUS\n*\n* EXAMPLE:\n*    //STEP1   EXEC PGM=PSU004,PARM=('1989')\n*    //SYSOUT  DD  SYSOUT=*\n*\nPSU004   PENTER MAIN,VARS=(WRKDSECT,WRKLEN),STACK=1\n*\n*---------------------------------------------------------------------*\n*        MAINLINE                                                     *\n*---------------------------------------------------------------------*\n*\n*        GET FULL FOUR DIGIT YEAR IN CHARACTER FORMAT\n*        ACCOUNTING FOR CENTURY CHANGES.  USE CURRENT\n*        YEAR UNLESS PARM SPECIFIES A YEAR.\n*\n         PUSHREG R1                SAVE PARM ADDRESS\n*\n         TIME  DEC\n*\n         LR    R15,R1              COPY DATE\n         SRL   R15,24              ISOLATE CENTURY\n         SLL   R15,4               MAKE ROOM FOR SIGN\n         LA    R15,12(,R15)        INSERT SIGN\n         ST    R15,WRKDWORD+4      SAVE IN DOUBLEWORD\n         CVB   R15,WRKDWORD        MAKE BINARY VALUE\n         MH    R15,=H'100'         CONVERT TO YEARS\n         AH    R15,=H'1900'        ADD IN BASE CENTURY\n*\n         SLL   R1,8                STRIP OFF CENTURY\n         SRL   R1,24               STRIP OFF DAYS\n         SLL   R1,4                MAKE ROOM FOR SIGN\n         LA    R1,12(,R1)          INSERT SIGN\n         ST    R1,WRKDWORD+4       SAVE IN DOUBLEWORD\n         CVB   R1,WRKDWORD         MAKE BINARY VALUE\n*\n         AR    R1,R15              INCLUDE CENTURIES\n         STH   R1,WRKYEAR          SAVE YEAR\n*\n         POPREG R1                 RESTORE PARM ADDRESS\n*\n         L     R1,0(,R1)           CALLER'S PARM\n         LH    R15,0(,R1)          GET PARM LENGTH\n         CH    R15,=H'4'           CORRECT LENGTH FOR YEAR ?\n         BNE   A0010               NO,  IGNORE IT\n         PACK  WRKDWORD,2(4,R1)    MAKE PACKED DECIMAL\n         CVB   R1,WRKDWORD         MAKE BINARY\n         STH   R1,WRKYEAR          SAVE YEAR\n*\nA0010    LH    R1,WRKYEAR          YEAR IN BINARY\n         CVD   R1,WRKDWORD         MAKE PACKED DECIMAL\n         UNPK  WRKYEARZ,WRKDWORD   MAKE ZONED DECIMAL\n         OI    WRKYEARZ+3,C'0'     REMOVE SIGN\n*\n*        COMPUTE FIRST DAY OF EACH MONTH\n*\n         LA    R2,12               NUMBER OF MONTHS\n         LA    R11,WRKDAY1-1       FIRST DAY OF MONTH TABLE\nA0020    STH   R2,WRKMONTH         SAVE MONTH FOR DAYOFWK\n         PCALL DAYOFWK,(WRKMONTH,=H'1',WRKYEAR)\n         STC   R15,0(R2,R11)       SAVE FIRST DAY OF MONTH\n         BCT   R2,A0020            COMPUTE FOR ALL MONTHS\n*\n*        CHECK FOR LEAP YEAR\n*\n         MVC   WRKDAYS(12),DAYS    SET DEFAULT WEEKDAYS\n         PCALL DAYOFWK,(=H'2',=H'28',WRKYEAR)\n         LR    R2,R15              SAVE WEEKDAY OF 2/28\n         PCALL DAYOFWK,(=H'3',=H'1',WRKYEAR)\n         CR    R15,R2              DID WEEKDAY WRAP AROUND ?\n         BH    A0030               NO, COMPARE DIFFERENCE IN DAYS\n         LA    R15,7(,R15)         ADJUST FOR WEEKDAY WRAP\nA0030    SR    R15,R2              COMPUTE DIFFERENCE IN DAYS\n         CH    R15,=H'1'           ONE DAY BETWEEN 2/28 AND 3/1 ?\n         BNE   A0040               NO, IT'S A LEAP YEAR\n         MVI   WRKDAYS+1,28        RESET\n*\n*        CLEAR CALENDAR TO ALL BLANKS\n*\nA0040    LA    R15,29              NUMBER OF LINES\n         LA    R14,WRKLINE         START OF LINES\nA0050    MVC   0(L'WRKLINE,R14),BLANKS CLEAR LINE\n         LA    R14,L'WRKLINE(,R14) ADVANCE TO NEXT LINE\n         BCT   R15,A0050           CLEAR NEXT LINE\n*\n*        FILL IN NAME OF EACH MONTH AND YEAR\n*\n         LA    R15,WRKLINE               START OF LINE\n         MVI   0(R15),C'1'               EJECT TO TOP OF FORM\n         MVC   1(7,R15),=C'JANUARY'      SET JANUARY\n         MVC   24(4,R15),WRKYEARZ        SET YEAR\n         MVC   32(8,R15),=C'FEBRUARY'    SET FEBRUARY\n         MVC   55(4,R15),WRKYEARZ        SET YEAR\n         MVC   63(5,R15),=C'MARCH'       SET MARCH\n         MVC   86(4,R15),WRKYEARZ        SET YEAR\n         MVC   94(5,R15),=C'APRIL'       SET APRIL\n         MVC   117(4,R15),WRKYEARZ       SET YEAR\n*\n         LA    R15,10*L'WRKLINE(,R15)    SKIP TO NEXT ROW\n         MVC   1(3,R15),=C'MAY'          SET MAY\n         MVC   24(4,R15),WRKYEARZ        SET YEAR\n         MVC   32(4,R15),=C'JUNE'        SET JUNE\n         MVC   55(4,R15),WRKYEARZ        SET YEAR\n         MVC   63(5,R15),=C'JULY'        SET JULY\n         MVC   86(4,R15),WRKYEARZ        SET YEAR\n         MVC   94(6,R15),=C'AUGUST'      SET AUGUST\n         MVC   117(4,R15),WRKYEARZ       SET YEAR\n*\n         LA    R15,10*L'WRKLINE(,R15)    SKIP TO NEXT ROW\n         MVC   1(9,R15),=C'SEPTEMBER'    SET SEPTEMBER\n         MVC   24(4,R15),WRKYEARZ        SET YEAR\n         MVC   32(7,R15),=C'OCTOBER'     SET OCTOBER\n         MVC   55(4,R15),WRKYEARZ        SET YEAR\n         MVC   63(8,R15),=C'NOVEMBER'    SET NOVEMBER\n         MVC   86(4,R15),WRKYEARZ        SET YEAR\n         MVC   94(8,R15),=C'DECEMBER'    SET DECEMBER\n         MVC   117(4,R15),WRKYEARZ       SET YEAR\n*\n*        FILL IN NAME OF DAY OF WEEK FOR EACH MONTH\n*\n         LA    R14,3                     NUMBER OF ROWS\n         LA    R15,WRKLINE               ADDRESS FIRST ROW\n         SH    R15,=Y(9*L'WRKLINE)       BACK UP FOR LOOP\nA0060    LA    R15,10*L'WRKLINE(,R15)    NEXT ROW\n         MVC   1(27,R15),=C'SUN MON TUE WED THU FRI SAT'\n         MVC   32(27,R15),1(R15)         FILL NEXT COLUMN\n         MVC   63(27,R15),1(R15)         FILL NEXT COLUMN\n         MVC   94(27,R15),1(R15)         FILL NEXT COLUMN\n         BCT   R14,A0060                 ADVANCE TO NEXT ROW\n*\n*        UNDERLINE DAY OF WEEK FOR EACH MONTH\n*\n         LA    R14,3                     NUMBER OF ROWS\n         LA    R15,WRKLINE               ADDRESS FIRST ROW\n         SH    R15,=Y(8*L'WRKLINE)       BACK UP FOR LOOP\nA0070    LA    R15,10*L'WRKLINE(,R15)    NEXT ROW\n         MVI   1(R15),C'-'               UNDERLINE WEEKDAYS\n         MVC   2(26,R15),1(R15)          FILL FIRST COLUMN\n         MVC   32(27,R15),1(R15)         FILL NEXT COLUMN\n         MVC   63(27,R15),1(R15)         FILL NEXT COLUMN\n         MVC   94(27,R15),1(R15)         FILL NEXT COLUMN\n         BCT   R14,A0070                 ADVANCE TO NEXT ROW\n*\n*        GENERATE CALENDAR OF DAYS IN EACH MONTH\n*\n         LA    R2,1                INITIALIZE MONTH\n         LA    R4,3                NUMBER OF ROWS\n         LA    R5,WRKLINE          START OF LINE\n         SH    R5,=Y(7*L'WRKLINE)  BACK UP FOR LOOP\nA0080    LA    R5,10*L'WRKLINE(,R5)  NEXT ROW\n         SR    R6,R6               CLEAR OFFSET TO MONTH\n         LA    R11,4               NUMBER OF MONTHS PER ROW\nA0090    LA    R7,0(R6,R5)         ADDRESS MONTH\n         SR    R8,R8               CLEAR DAYS IN MONTH\n         SR    R9,R9               CLEAR DAY OF WEEK\n         IC    R8,WRKDAYS-1(R2)    GET DAYS IN MONTH\n         IC    R9,WRKDAY1-1(R2)    GET FIRST DAY OF WEEK\n         LA    R10,1               GET FIRST DAY OF MONTH\nA0100    LR    R15,R9              COPY DAY OF WEEK\n         MH    R15,=H'4'           COMPUTE OFFSET IN LINE\n         LA    R15,0(R15,R7)       COMPUTE ADDRESS IN LINE\n         CVD   R10,WRKDWORD        MAKE DAY PACKED DECIMAL\n         MVC   0(4,R15),=X'40202120' EDIT PATTERN ZZ9\n         ED    0(4,R15),WRKDWORD+6 MAKE DAY DISPLAYABLE\n         LA    R10,1(,R10)         NEXT DAY\n         LA    R9,1(,R9)           NEXT DAY OF WEEK\n         CH    R9,=H'7'            GREATER THAN SATURADAY ?\n         BL    A0110               NO,  CONTINUE\n         SR    R9,R9               YES, RESET TO SUNDAY\n         LA    R7,L'WRKLINE(,R7)   GO TO NEXT LINE\nA0110    BCT   R8,A0100            DO ALL DAYS\n         LA    R2,1(,R2)           NEXT MONTH\n         LA    R6,31(,R6)          ADDRESS OF NEXT MONTH\n         BCT   R11,A0090           ALL MONTHS THIS ROW\n         BCT   R4,A0080            ALL ROWS\n*\n*        PUT CALENDAR TO DDNAME SYSOUT\n*\n         OPEN  (DCB,(OUTPUT))\n         LA    R2,29\n         LA    R11,WRKLINE\nPUT      PUT   DCB,(R11)\n         LA    R11,L'WRKLINE(,R11)\n         BCT   R2,PUT\n         CLOSE (DCB)\n*\n*        RETURN TO CALLER\n*\n         PEXIT RC=0\n         LTORG ,\n*\nDAYS     DC    AL1(31,29,31,30,31,30,31,31,30,31,30,31)\nBLANKS   DC    256C' '\n*\nDCB      DCB   DDNAME=SYSOUT,                                          +\n               DSORG=PS,                                               +\n               MACRF=PM,                                               +\n               RECFM=FBA,                                              +\n               LRECL=121,                                              +\n               BLKSIZE=6171\n*\nWRKDSECT DSECT ,\nWRKSAVEA DS    18F                 FIRST SAVE AREA\nWRKSAVE2 DS    18F                 SECOND SAVE AREA\nWRKID    EQU   WRKSAVEA,4\n*\nWRKDWORD DS    D                   DOUBLE WORD\nWRKFWORD DS    F                   FULL WORD\nWRKHWORD DS    H                   HALF WORD\nWRKBYTE  DS    B                   BYTE\n*\nWRKYEARZ DS    CL4                 CHARACTER YEAR\nWRKYEAR  DS    H                   NUMERIC YEAR\nWRKMONTH DS    H                   NUMERIC MONTH\nWRKDAY1  DS    12AL1               FIRST DAY OF EACH MONTH\nWRKDAYS  DS    12AL1               NUMBER OF DAYS EACH MONTH\n*\nWRKLINE  DS    29CL121\n*\nWRKEND   DS    0D\nWRKLEN   EQU   *-WRKDSECT\n*\n         EJECT ,\n*---------------------------------------------------------------------*\n*        DAYOFWK SUBROUTINE                                           *\n*---------------------------------------------------------------------*\n*\nDAYOFWK  PENTER FUNC\n*\n         L     R4,0(,R1)           MONTH\n         LH    R4,0(,R4)\n*\n         L     R5,4(,R1)           DAY\n         LH    R5,0(,R5)\n*\n         L     R6,8(,R1)           YEAR\n         LH    R6,0(,R6)\n*\n*        COMPUTE CENTURY = YEAR / 100\n*        COMPUTE DECADE  = YEAR MOD 100\n*\n         XR    R14,R14             CLEAR HIGH WORD OF DIVISOR\n         LR    R15,R6              GET DIVISOR ( YEAR )\n         LA    R2,100              GET DIVIDEND\n         DR    R14,R2              COMPUTE\n         LR    R7,R15              R7 = CENTURY (QUOTIENT)\n         LR    R8,R14              R8 = DECADE  (REMAINDER)\n*\n*        THE DAY OF THE MONTH INCREMENTS THE BASE BY THE\n*        SAME NUMBER OF DAYS, THE PASSING OF EACH YEAR ADDS\n*        A DAY, AND EACH LEAP YEAR ADDS A DAY\n*\n*        WEEKDAY = ( ( YEAR / 4 ) - CENTURY ) + ( YEAR / 400 ) +\n*                  DAY + YEAR + BMC( MONTH-1 )\n*\n         LR    R9,R6               GET YEAR\n         SRL   R9,2                WEEKDAY = ( YEAR / 4 )\n*\n         SR    R9,R7               WEEKDAY = WEEKDAY - CENTURY\n*\n         LR    R14,R7              GET CENTURY ( YEAR / 100 )\n         SRL   R14,2               COMPUTE ( YEAR / 400 )\n         AR    R9,R14              WEEKDAY = WEEKDAY + ( YEAR / 400 )\n*\n         AR    R9,R5               WEEKDAY = WEEKDAY + DAY\n*\n         AR    R9,R6               WEEKDAY = WEEKDAY + YEAR\n*\n         LR    R14,R4              GET MONTH\n         BCTR  R14,0               MINUS 1\n         SR    R15,R15             CLEAR REGISTER\n         IC    R15,BMC(R14)        INDEX INTO BASE MONTH CODE TABLE\n         AR    R9,R15              WEEKDAY = WEEKDAY + BMC( MONTH-1 )\n*\n*        FOR A LEAP YEAR, REMOVE THE EXTRA DAY BEFORE IT OCCURS,\n*        I.E. JANUARY AND FEBRUARY\n*\n*        IF ( ( YEAR MOD 400 = 0 ) OR\n*             ( ( YEAR MOD 4 = 0 ) AND ( DECADE ^= 0 ) ) )\n*           IF ( MONTH < 3 )\n*              WEEKDAY = WEEKDAY - 1\n*\n         XR    R14,R14             CLEAR HIGH WORD OF DIVISOR\n         LR    R15,R6              GET DIVISOR ( YEAR )\n         LA    R2,400              GET DIVIDEND\n         DR    R14,R2              COMPUTE ( YEAR MOD 400 )\n*\n         LTR   R14,R14             CHECK LEAP CENTURY ( YEAR MOD 400 )\n         BZ    D0010               YES, ALSO LEAP YEAR\n         XR    R14,R14             CLEAR HIGH WORD OF DIVISOR\n         LR    R15,R6              GET DIVISOR ( YEAR )\n         LA    R2,4                GET DIVIDEND\n         DR    R14,R2              COMPUTE ( YEAR MOD 4 )\n         LTR   R14,R14             POSSIBLE LEAP YEAR ?\n         BNZ   D00005              NO,  SHOW NOT A LEAP YEAR\n         LTR   R8,R8               YES, BUT IS IT A CENTURY YEAR ?\n         BNZ   D0010               NO,  SO IT'S A LEAP YEAR\nD00005   LA    R14,1               YES, NOT A LEAP CENTURY YEAR\n*\nD0010    LTR   R14,R14             LEAP YEAR ?\n         BNZ   D0020               NO,  SKIP ADJUSTMENT\n         CH    R4,=H'3'            JANUARY OR FEBRUARY ?\n         BNL   D0020               NO,  SKIP ADJUSTMENT\n         BCTR  R9,0                WEEKDAY = WEEKDAY - 1\n*\n*        RETURN ( WEEKDAY MOD 7 )\n*\nD0020    XR    R14,R14             CLEAR HIGH WORD OF DIVISOR\n         LR    R15,R9              GET LOW WORD OF DIVISOR (WEEKDAY)\n         LA    R2,7                GET DIVIDEND\n         DR    R14,R2              COMPUTE WEEKDAY MOD 7\n         LR    R15,R14             RETURN VALUE (WEEKDAY MOD 7)\n*\n         PEXIT RC=(15)\n         LTORG ,\n*\nSUN      EQU   0\nMON      EQU   1\nTUE      EQU   2\nWED      EQU   3\nTHU      EQU   4\nFRI      EQU   5\nSAT      EQU   6\n*\n*        BASE MONTH CODE TABLE\nBMC      DC    AL1(SAT)            JANUARY   1, 0000\n         DC    AL1(TUE)            FEBRUARY  1, 0000\n         DC    AL1(TUE)            MARCH     1, 0000\n         DC    AL1(FRI)            APRIL     1, 0000\n         DC    AL1(SUN)            MAY       1, 0000\n         DC    AL1(WED)            JUNE      1, 0000\n         DC    AL1(FRI)            JULY      1, 0000\n         DC    AL1(MON)            AUGUST    1, 0000\n         DC    AL1(THU)            SEPTEMBER 1, 0000\n         DC    AL1(SAT)            OCTOBER   1, 0000\n         DC    AL1(TUE)            NOVEMBER  1, 0000\n         DC    AL1(THU)            DECEMBER  1, 0000\n*\n         END   PSU004\n./ ADD NAME=$$$DOC,LEVEL=00\n./ NUMBER NEW1=10000,INCR=10000\nComplete documentation may be found at:\n\nhttp://skycoast.us/pscott/software/mvs/\n\nIf you require assistance, contact pscott@skycoast.us\n\n./ ADD NAME=GENCAL,LEVEL=00\n./ NUMBER NEW1=10000,INCR=10000\nPROC 0 YEAR()\n/*\n/* GENERATE CALENDAR FOR CURRENT (OR SPECIFIED) YEAR\n/* AUTHOR: P. SCOTT\n/*\nCONTROL NOMSG NOLIST NOFLUSH\nALLOC F(SYSOUT) UNIT(SYSDA) TRACKS SPACE(1) DELETE REUSE\nCALL '&PREF..PSM.RUNLIB(PSU004)' '&YEAR'\nISPEXEC  LMINIT DATAID(SYSOUT) DDNAME(SYSOUT) ENQ(SHR)\nISPEXEC  EDIT   DATAID(&SYSOUT)\nFREE F(SYSOUT)\n./ ADD NAME=$PSMIVP,LEVEL=00\n./ NUMBER NEW1=10000,INCR=10000\n//&JOBNAME JOB PSMIVP,'PSMIVP',CLASS=&JOBCLASS,MSGCLASS=&MSGCLASS\n//*\n//IVP      PROC PREFIX=&PREF,     <--- YOUR USER ID\n//             FMT=U\n//*\n//* ---------------------------------\n//* STEP 1 - PSU001 (V)\n//* ---------------------------------\n//*\n//S1       EXEC PGM=PSU001,PARM=('&FMT,EQ,VB')\n//STEPLIB  DD  DSN=&PREFIX..PSM.RUNLIB,DISP=SHR\n//*\n//* ---------------------------------\n//* STEP 2 - PSU002 (V)\n//* ---------------------------------\n//*\n//S2       EXEC PGM=PSU002,COND=(0,NE,S1),PARM=('/',\n//             'PSU002 - INSTALLATION VERIFICATION PROCEDURE/',\n//             '         VARIABLE RECORD FORMAT/',\n//             ' ')\n//STEPLIB  DD  DSN=&PREFIX..PSM.RUNLIB,DISP=SHR\n//SYSOUT   DD  SYSOUT=H,DCB=(RECFM=VB,LRECL=255,BLKSIZE=6233)\n//*\n//* ---------------------------------\n//* STEP 3 - PSU001 (F)\n//* ---------------------------------\n//*\n//S3       EXEC PGM=PSU001,PARM=('&FMT,EQ,FB')\n//STEPLIB  DD  DSN=&PREFIX..PSM.RUNLIB,DISP=SHR\n//*\n//* ---------------------------------\n//* STEP 4 - PSU002 (F)\n//* ---------------------------------\n//*\n//S4       EXEC PGM=PSU002,COND=(0,NE,S3),PARM=('/',\n//             'PSU002 - INSTALLATION VERIFICATION PROCEDURE/',\n//             '         FIXED RECORD FORMAT/',\n//             ' ')\n//STEPLIB  DD  DSN=&PREFIX..PSM.RUNLIB,DISP=SHR\n//SYSOUT   DD  SYSOUT=H,DCB=(RECFM=FB,LRECL=80,BLKSIZE=6160)\n//*\n//IVP      PEND\n//*\n//IVP1     EXEC IVP,FMT=VB\n//IVP2     EXEC IVP,FMT=FB\n//\n//*\n$$\n//\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RUNLIB": {"ttr": 2051, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x03\\x19O\\x01\\x03\\x19O\\x14Q\\x00\\xc7\\x00\\xc7\\x00\\x00\\xd3\\xd6\\xc1\\xc4\\xd3\\xc9\\xc2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2003-07-13T00:00:00", "modifydate": "2003-07-13T14:51:00", "lines": 199, "newlines": 199, "modlines": 0, "user": "LOADLIB"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "SRCLIB": {"ttr": 2055, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00V\\x01\\x03\\x19O\\x01\\x03\\x19O\\x14\\x02\\n\\xbf\\n\\xb8\\x00\\x00\\xd7\\xc1\\xe2\\xc3\\xd6\\xe3\\xe3@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2003-07-13T00:00:00", "modifydate": "2003-07-13T14:02:56", "lines": 2751, "newlines": 2744, "modlines": 0, "user": "PASCOTT"}, "text": "./ ADD NAME=$$$DOC   0100-03194-03194-1243-00013-00013-00000-PASCOTT\nComplete documentation may be found at:\n\nhttp://skycoast.us/pscott/software/mvs/\n\nSee members $$DOC     - general documentation of MVS programs\n\n            $$MACDOC  - detailed documentation for the macros\n\n\n\n\nIf you require assistance, contact pscott@skycoast.us\n\n./ ADD NAME=$PSMIVP  0100-03194-03194-1243-00047-00047-00000-PASCOTT\n//SBGOLOBV JOB PSMIVP,'PSMIVP',CLASS=B,MSGCLASS=X\n//*\n//IVP      PROC PREFIX=SBGOLOB,     <--- YOUR USER ID\n//             FMT=U\n//*\n//* ---------------------------------\n//* STEP 1 - PSU001 (V)\n//* ---------------------------------\n//*\n//S1       EXEC PGM=PSU001,PARM=('&FMT,EQ,VB')\n//STEPLIB  DD  DSN=&PREFIX..PSM.RUNLIB,DISP=SHR\n//*\n//* ---------------------------------\n//* STEP 2 - PSU002 (V)\n//* ---------------------------------\n//*\n//S2       EXEC PGM=PSU002,COND=(0,NE,S1),PARM=('/',\n//             'PSU002 - INSTALLATION VERIFICATION PROCEDURE/',\n//             '         VARIABLE RECORD FORMAT/',\n//             ' ')\n//STEPLIB  DD  DSN=&PREFIX..PSM.RUNLIB,DISP=SHR\n//SYSOUT   DD  SYSOUT=H,DCB=(RECFM=VB,LRECL=255,BLKSIZE=6233)\n//*\n//* ---------------------------------\n//* STEP 3 - PSU001 (F)\n//* ---------------------------------\n//*\n//S3       EXEC PGM=PSU001,PARM=('&FMT,EQ,FB')\n//STEPLIB  DD  DSN=&PREFIX..PSM.RUNLIB,DISP=SHR\n//*\n//* ---------------------------------\n//* STEP 4 - PSU002 (F)\n//* ---------------------------------\n//*\n//S4       EXEC PGM=PSU002,COND=(0,NE,S3),PARM=('/',\n//             'PSU002 - INSTALLATION VERIFICATION PROCEDURE/',\n//             '         FIXED RECORD FORMAT/',\n//             ' ')\n//STEPLIB  DD  DSN=&PREFIX..PSM.RUNLIB,DISP=SHR\n//SYSOUT   DD  SYSOUT=H,DCB=(RECFM=FB,LRECL=80,BLKSIZE=6160)\n//*\n//IVP      PEND\n//*\n//IVP1     EXEC IVP,FMT=VB\n//IVP2     EXEC IVP,FMT=FB\n//\n//*\n./ ADD NAME=GENCAL   0100-03194-03194-1243-00011-00011-00000-PASCOTT\nPROC 0 YEAR()\n/*\n/* GENERATE CALENDAR FOR CURRENT (OR SPECIFIED) YEAR\n/* AUTHOR: P. SCOTT\n/*\nCONTROL NOMSG NOLIST NOFLUSH\nALLOC F(SYSOUT) UNIT(SYSDA) TRACKS SPACE(1) DELETE REUSE\nCALL 'SBGOLOB.PSM.RUNLIB(PSU004)' '&YEAR'\nISPEXEC  LMINIT DATAID(SYSOUT) DDNAME(SYSOUT) ENQ(SHR)\nISPEXEC  EDIT   DATAID(&SYSOUT)\nFREE F(SYSOUT)\n./ ADD NAME=PCALL    0100-03194-03194-1243-00022-00022-00000-PASCOTT\n.* COPYRIGHT (C) 1988, PAUL A. SCOTT, ALL RIGHTS RESERVED\n.*\n         MACRO\n&NAME    PCALL\n.*\n         COPY  PSMGBL01\n.*\n         LCLA  &A\n&A       SETA  N'&SYSLIST(2)\n.*\n         AIF   (&A GT 0).L00100\n&NAME    CALL  &SYSLIST(1)\n         MEXIT\n.*\n.L00100  ANOP\n&NAME    LR    1,&SP\n         LA    &SP,4*&A.(,&SP)\n         CALL  &SYSLIST(1),&SYSLIST(2),VL,MF=(E,(1))\n         LA    14,4*&A\n         SR    &SP,14\n.*\n         MEND\n./ ADD NAME=PENTER   0100-03194-03194-1243-00356-00356-00000-PASCOTT\n.* COPYRIGHT (C) 1988, PAUL A. SCOTT, ALL RIGHTS RESERVED\n.*\n         MACRO\n&NAME    PENTER &TYPE,             PROCEDURE TYPE                      X\n               &BASE=12,           BASE REGISTER(S)                    X\n               &VARS=,             LOCAL VARIABLE STORAGE              X\n               &STACK=,            SIZE OF STACK IN 1K BLOCKS          X\n               &PREFIX=PSM         LABEL PREFIX FOR MACRO EXPANSION\n.*\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*       VARIABLE DEFINITIONS\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*\n         COPY  PSMGBL00\n         COPY  PSMGBL01\n         COPY  PSMGBL02\n.*\n         LCLA  &I                  INDEX AND COUNTER\n         LCLA  &K                  STACK SIZE\n         LCLA  &N                  NUMBER OF PARAMETERS (REUSED)\n         LCLA  &S                  HIGHEST REGISTER USED\n.*\n         LCLB  &B0                 STACK DEFINED FLAG\n         LCLB  &B1                 PSM MAIN LINKAGE\n         LCLB  &B2                 PSM CMAIN LINKAGE\n         LCLB  &B3                 PSM FUNCTION LINKAGE\n         LCLB  &B4                 STANDARD LINKAGE\n.*\n         LCLC  &C                  CHARACTER STRING (REUSED)\n         LCLC  &P                  EXPANSION PREFIX\n.*\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*       VALIDATE &STACK PARAMETER\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*\n         AIF   ((T'&STACK EQ 'O') OR (&STACK EQ 0)).L0010\n&K       SETA  ((&STACK*4)*1024)\n&B0      SETB  ('&TYPE' EQ 'CMAIN')\n&B0      SETB  (('&TYPE' EQ 'MAIN') OR &B0)\n         AIF   (&B0).L0010\n         MNOTE 4,'INVALID STACK USAGE - STACK=&STACK IGNORED'\n.L0010   ANOP\n.*\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*       VALIDATE &TYPE PARAMETER\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*\n&B1      SETB  ('&TYPE' EQ 'MAIN')\n&B2      SETB  ('&TYPE' EQ 'CMAIN')\n&B3      SETB  ('&TYPE' EQ 'FUNC')\n&B4      SETB  (T'&TYPE EQ 'O')\n         AIF   (NOT (&B1 OR &B2)).L0020\n.*\n         AIF   (&B0).L0030\n         MNOTE 4,'TYPE &TYPE REQUIRES STACK - 4K ASSUMMED'\n&K       SETA  4096\n&B0      SETB  1\n         AGO   .L0030\n.*\n.L0020   ANOP\n         AIF   (&B1 OR &B2 OR &B3 OR &B4).L0030\n         MNOTE 4,'INVALID TYPE &TYPE - STANDARD LINKAGE ASSUMED '\n&B4      SETA  1\n.L0030   ANOP\n         AIF   (NOT &B4).L0040\n&K       SETA  64                      MINIMAL STACK FOR PCALL, ETC.\n&B0      SETB  1                       FORCE MINIMAL STACK\n.L0040   ANOP\n.*\n.*\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*       MAKE EXPANSION PREFIX SHORTER FOR CLEANER EXPANSION\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*\n&P       SETC  '&PREFIX'           SHORTEN THE VARIABLE NAME\n.*\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*       SAVE AREA STRUCTURE DEFINITION\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*\n         AIF   (&PSMSVA AND ('&P' EQ 'PSM')).L0060\n.L0050   ANOP\n.*      - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.*       S T A R T   O F   S A V E   A R E A   S T R U C T U R E\n.*      - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n&PSMSVA  SETB  1\n&P.SVA   DSECT ,                   SAVE AREA STRUCTURE\n&P.PLI   DS    F                   UNUSED\n&P.HSA   DS    A                   HIGH SAVE AREA PTR\n&P.LSA   DS    A                   LOW SAVE AREA PTR\n&P.RET   DS    A                   RETURN ADDRESS\n&P.EPA   DS    A                   ENTRY POINT ADDRESS\n&P.GPR0  DS    A                   REGISTER 0\n&P.GPR1  DS    A                   REGISTER 1\n&P.GPR2  DS    A                   REGISTER 2\n&P.GPR3  DS    A                   REGISTER 3\n&P.GPR4  DS    A                   REGISTER 4\n&P.GPR5  DS    A                   REGISTER 5\n&P.GPR6  DS    A                   REGISTER 6\n&P.GPR7  DS    A                   REGISTER 7\n&P.GPR8  DS    A                   REGISTER 8\n&P.GPR9  DS    A                   REGISTER 9\n&P.GPR10 DS    A                   REGISTER 10\n&P.GPR11 DS    A                   REGISTER 11\n&P.GPR12 DS    A                   REGISTER 12\n&P.GDS   DS    A                   GLOBAL DATA STRUCTURE PTR\n&P.LDS   DS    A                   LOCAL DATA STRUCTURE PTR\n&P.TOS   DS    A                   TOP OF STACK PTR\n&P.BOS   DS    A                   BOTTOM OF STACK PTR\n&P.SVALN EQU   *-&P.SVA            LENGTH OF SAVE AREA STRUCTURE\n&P.LVARS DS    0F                  START OF LOCAL VARIABLES\n.*      - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.*       E N D   O F   S A V E   A R E A   S T R U C T U R E\n.*      - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.L0060   ANOP\n.*\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*       COMPUTE HIGHEST REGISTER USED (FROM BASE REGS DEFINED)\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*\n&S       SETA  0                   START WITH NO HIGHEST\n.*\n.*       SCAN THE CODE BASE REGISTERS\n.*\n&N       SETA  N'&BASE             NUMBER OF BASE REGISTERS\n&I       SETA  1                   START WITH FIRST ONE\n.*\n.L0070   ANOP\n         AIF   (&I GT &N).L0090    WHILE (UNSCANNED REGISTERS)\n         PSMRVAL &BASE(&I)              GET VALUE OF REGISTER\n         AIF   (&S GE &PSMRVAL).L0080   IF HIGHER THAN PREVIOUS\n&S       SETA  &PSMRVAL                    SAVE REGISTER\n.L0080   ANOP                           ENDIF\n&I       SETA  &I+1                     INCREMENT REGISTER INDEX\n         AGO   .L0070              END WHILE\n.L0090   ANOP\n.*\n.*       SCAN THE DATA BASE REGISTERS\n.*\n&N       SETA  N'&VARS(3)          NUMBER OF BASE REGISTERS\n&I       SETA  1                   START WITH FIRST ONE\n.*\n.L0100   ANOP\n         AIF   (&I GT &N).L0120    WHILE (UNSCANNED REGISTERS)\n         PSMRVAL &VARS(3,&I)            GET VALUE OF REGISTER\n         AIF   (&S GE &PSMRVAL).L0110   IF HIGHER THAN PREVIOUS\n&S       SETA  &PSMRVAL                    SAVE REGISTER\n.L0110   ANOP                           ENDIF\n&I       SETA  &I+1                     INCREMENT REGISTER INDEX\n         AGO   .L0100              END WHILE\n.L0120   ANOP\n.*\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*       GENERATE REGISTER EQUATES\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*\n         AIF   (&PSMREGS).L0170    SKIP IF ALREADY DEFINED\n         AIF   (&REGS).L0160       ISSUE WARNING IF EXTERNALLY DEFINED\n.*\n&PSMREGS SETB  1                   MARK AS DEFINED\n&REGS    SETB  1                   MARK AS DEFINED\n.*\n&I       SETA  0\n.L0140   ANOP                         REPEAT\n.*                                       IF ( NOT SPECIAL REGISTER )\n         AIF   ((&I EQ &SP) OR (&I EQ &BP)).L0150\n.*       AIF   ((&I GT &S) AND NOT (&I LT &BP)).L0150\nR&I      EQU   &I                           GENERATE REGISTER EQUATE\n.L0150   ANOP                            ENDIF\n&I       SETA  &I+1                      BUMP TO NEXT REGISTER\n         AIF   (&I LE &HIREG).L0140   UNTIL ( NO MORE REGISTERS )\n         AGO   .L0170                 SKIP WARNING\n.*\n.L0160   ANOP\n         MNOTE 4,'USE REGISTERS &SP AND &BP WITH CAUTION!!!'\n.*\n.L0170   ANOP\n.*\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*       DROP PREVIOUS BASE REGISTERS\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*\n.*       DROP CODE BASE REGISTERS\n.*\n         AIF   ('&PSMBSEC(2)' EQ '').L0180\n         DROP  &PSMBSEC(2)\n.*\n.*       DROP DATA BASE REGISTERS\n.*\n.L0180   ANOP\n         AIF   ('&PSMBSED' EQ '').L0190\n         DROP  &PSMBSED\n.*\n.L0190   ANOP\n.*\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*       INITIALIZE THE PENTER/PEXIT GLOBAL VARIABLES\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*\n&PSMCNAM SETC  ''                  CLEAR THE CSECT NAME\n&PSMBSEC(1) SETC ''                CLEAR THE FIRST CODE BASE REGISTER\n&PSMBSEC(2) SETC ''                CLEAR THE CODE BASE REGISTER LIST\n&PSMBSED SETC  ''                  CLEAR THE DATA BASE\n&PSMBSEH SETC  ''                  CLEAR THE HIGHEST REGISTER USED\n&PSMSTKS SETC  ''                  CLEAR THE STACK SIZE\n.*\n&PSMCNAM SETC  '&NAME'             INITIALIZE THE CSECT NAME\n.*\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*       GENERATE THE CSECT PREFACE AREA\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*\n         PSMRLSE ,\n&N       SETA  (K'&PSMRLSE+3)/4*4\n.*\n.*      - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.*       S T A R T   O F   C S E C T   P R E F A C E\n.*      - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.*       THE CSECT ID SECTION IS MAPPED BY MACRO PSMCPREF\n.*       ANY CHANGES TO HERE SHOULD BE DUPLICATED THERE\n.*\n&NAME    CSECT ,\n.*\n&C       SETC  ''\n         AIF   (NOT &B2).L0200\n         ENTRY MAIN\n&C       SETC  'MAIN'\n.L0200   ANOP\n.*\n&I       SETA  36+&N+(&B0*4)+(&B2*4)\n&C       B     &I.(,15)            BRANCH AROUND CSECT PREFACE\n&I       SETA  27+&N\n         DC    AL1(&I.)            . LENGTH OF DUMP TEXT\n         DC    CL9'&NAME'          . CSECT NAME\n         DC    CL9'&SYSDATE'       . ASSEMBLY DATE\n         DC    CL9'&SYSTIME'       . ASSEMBLY TIME\n         AIF   (&N LT 1).L0210\n         DC    CL&N.'&PSMRLSE'     . PRODUCT RELEASE ID\n.L0210   ANOP\n&C       SETC  '0'\n         AIF   (T'&VARS(2) EQ 'O').L0220\n&C       SETC  '&VARS(2)'\n.L0220   ANOP\n&C       SETC  '((&P.SVALN+&C+7)/8)*8'\n         DC    A(&C)               . INITIAL STACK OFFSET\n.*\n.*       GENERATE STACK CONSTANTS\n.*\n         AIF   (NOT &B0).L0230\n&PSMSTKS SETC '&K'\n         DC    AL1(&SSID),AL3(&K)  . STACK ALLOCATION\n.*\n.*       GENERATE PSM INITIALIZATION MODULE ADDRESS CONSTANT\n.*\n         AIF   (NOT &B2).L0230\n         DC    V(PSMINIT)          . PSM INITIALIZATION\n.*      - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.*       E N D   O F   C S E C T   P R E F A C E\n.*      - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.L0230   ANOP\n.*\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*       SAVE REGISTERS FOR STANDARD LINKAGE\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*\n         STM   14,&S,12(&BP)\n.*\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*       ESTABLISH CODE BASE REGISTERS\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*\n&N       SETA  N'&BASE             NUMBER OF BASE REGISTERS\n&C       SETC  '&BASE(1)'          FIRST BASE REGISTER\n&PSMBSEC(1) SETC '&C'              SAVE FIRST BASE REGISTER\n.*\n         LR    &BASE(1),15\n         AIF   (&N LE 1).L0250     IF ( MORE THAN ONE REGISTER)\n&I       SETA  1                      SET INDEX TO FIRST REGISTER\n         LA    &BASE(&N),4095\n.L0240   ANOP\n         AIF   (&I+1 GT &N).L0250     WHILE ( MORE REGISTERS )\n&I       SETA  &I+1                      GET NEXT REGISTER\n         LA    &BASE(&I),1(&BASE(&N),&BASE(&I-1))\n&C       SETC  '&C.,&BASE(&I)'           COLLECT REGISTERS\n         AGO   .L0240                 END WHILE\n.L0250   ANOP                      ENDIF\n&PSMBSEC(2) SETC '&C'              SAVE BASE REGISTER LIST\n         USING &NAME,&C\n.*\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*       COMPLETE STANDARD LINKAGE\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*\n         LR    2,&BP\n&N       SETA  (K'&PSMRLSE+3)/4*4\n         AIF   (&B1 OR &B4).L0260\n         LR    &BP,&SP\n         AGO   .L0270\n.*\n.L0260   ANOP\n&I       SETA  36+&N\n         L     0,&I.(,&BASE(1))\n&I       SETA  &I-4\n         AL    0,&I.(,&BASE(1))\n         GETMAIN R,LV=(0)\n         LR    &BP,1\n         LR    &SP,1\n.*\n.L0270   ANOP\n         LA    0,0(,&BP)\n&I       SETA  32+&N\n         L     1,&I.(,&BASE(1))\n         LR    14,0\n         SR    15,15\n         MVCL  0,14\n.*\n         AIF   (&B1 OR &B4).L0280\n         MVC   &P.GDS-&P.SVA(&P.LVARS-&P.GDS,&BP),&P.GDS-&P.SVA(2)\n.L0280   ANOP\n.*\n         ST    2,4(,&BP)\n         ST    &BP,8(,2)\n         LM    1,2,24(2)\n         AIF   (&B4).L0290\n         A     &SP,&I.(,&BASE(1))\n.L0290   ANOP\n.*\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*       ESTABLISH DATA BASE REGISTERS\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*\n         AIF   (T'&VARS EQ 'O').L0340\n&C       SETC  '&BP'\n&N       SETA  N'&VARS(3)\n         AIF   (&N LT 1).L0330\n&I       SETA  0\n         LA    &VARS(3,&N),4095\n.L0300   ANOP\n&I       SETA  &I+1\n         AIF   (&I GT &N).L0330\n         AIF   (&I GT 1).L0310\n         LA    &VARS(3,&I),1(&VARS(3,&N),&BP)\n         AGO   .L0320\n.L0310   ANOP\n         LA    &VARS(3,&I),1(&VARS(3,&N),&VARS(3,&I-1))\n.L0320   ANOP\n&C       SETC  '&C.,&VARS(3,&I)'\n         AGO   .L0300\n.L0330   ANOP\n         USING &VARS(1)-&P.SVALN,&C\n&PSMBSED SETC  '&C'\n.L0340   ANOP\n.*\n&PSMBSEH SETC  '&S'\n.*\n         MEND\n./ ADD NAME=PEXIT    0100-03194-03194-1243-00101-00101-00000-PASCOTT\n.* COPYRIGHT (C) 1988, PAUL A. SCOTT, ALL RIGHTS RESERVED\n.*\n         MACRO\n&NAME    PEXIT &RC=0               RETURN CODE\n.*\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*       VARIABLE DEFINITIONS\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*\n         COPY  PSMGBL00\n         COPY  PSMGBL01\n         COPY  PSMGBL02\n.*\n         LCLA  &A,&I,&J,&N\n         LCLC  &C\n.*\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*       SETUP\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*\n.L1000   ANOP\n.*\n&N       SETA  (K'&PSMRLSE+3)/4*4\n&C       SETC  '&PSMCNAM'\n.*\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*       GENERATE INITIAL RETURN CODE\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*\n&C       CSECT ,\n&NAME    LR    1,&BP\n         L     &BP,4(,&BP)\n.*\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*       STORE SPECIFIED REGISTERS IN CALLERS SAVE AREA\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*\n&A       SETA  N'&SYSLIST\n&I       SETA  1\n.L1020   ANOP\n         AIF   (&I GT &A).L1060\n         PSMROP &SYSLIST(&I)\n         AIF   (&PSMROP1 GT &PSMROP2).L1040\n         AIF   (&PSMROP1 LT 0 OR &PSMROP1 GT 12).L1040\n         AIF   (&PSMROP2 LT 0 OR &PSMROP1 GT 12).L1040\n&J       SETA  20+(&PSMROP1*4)\n         AIF   (&PSMROPC GT 1).L1030\n         ST    &PSMROP1,&J.(,&BP)\n         AGO   .L1050\n.L1030   ANOP\n         STM   &PSMROP1,&PSMROP2,&J.(&BP)\n         AGO   .L1050\n.L1040   ANOP\n         MNOTE 4,'REGISTER &SYSLIST(&I) OUT OF RANGE, IGNORED.'\n.L1050   ANOP\n&I       SETA  &I+1\n         AGO   .L1020\n.*\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*       STORE RETURN CODE\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*\n.L1060   ANOP\n         AIF   ('&RC' EQ '').L1090\n         AIF   ('&RC'(1,1) EQ '(').L1070\n         LA    15,&RC\n         AGO   .L1080\n.L1070   ANOP\n.*\n&C       SETC   '&RC'(2,K'&RC-2)\n         PSMRVAL &C\n         AIF   (&PSMRVAL EQ 15).L1080\n         LR    15,&PSMRVAL\n.*\n.L1080   ANOP\n         ST    15,16(,&BP)\n.*\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*       FREE THE STACK (IF ONE IS THERE)\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*\n.L1090   ANOP\n         AIF   (T'&PSMSTKS EQ 'O').L1100\n&I       SETA  36+&N\n         L     0,&I.(,&PSMBSEC(1))\n&I       SETA  &I-4\n         AL    0,&I.(,&PSMBSEC(1))\n         FREEMAIN R,LV=(0),A=(1)\n.*\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*       RETURN TO CALLER\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*\n.L1100   ANOP\n.*       RETURN (14,&PSMBSEH)\n         LM    14,&PSMBSEH,12(&BP)\n         OI    15(&BP),1           MARK RETURN\n         BR    14\n.*\n         LTORG ,\n         MEND\n./ ADD NAME=PLINK    0100-03194-03194-1243-00017-00017-00000-PASCOTT\n.* COPYRIGHT (C) 1988, PAUL A. SCOTT, ALL RIGHTS RESERVED\n.*\n         MACRO\n&NAME    PLINK\n.*\n         COPY  PSMGBL01\n.*\n         LCLA  &A\n&A       SETA  N'&SYSLIST(2)\n.*\n&NAME    LR    1,&SP\n         LA    &SP,4*&A.(,&SP)\n         LINK  EP=&SYSLIST(1),PARAM=&SYSLIST(2),VL=1,MF=(E,(1))\n         LA    14,4*&A\n         SR    &SP,14\n.*\n         MEND\n./ ADD NAME=POPREG   0100-03194-03194-1243-00057-00057-00000-PASCOTT\n.* COPYRIGHT (C) 1988, PAUL A. SCOTT, ALL RIGHTS RESERVED\n.*\n         MACRO\n&NAME    POPREG\n.*\n         COPY  PSMGBL01\n         COPY  PSMGBL02\n         LCLA  &I,&J,&K,&N\n.*\n         AIF   (T'&NAME EQ 'O').A000\n&NAME    DS    0H\n.A000    ANOP\n.*\n&N       SETA  N'&SYSLIST\n         AIF   (&N GT 0).A010\n         MEXIT\n.*\n.* COMPUTE AMOUNT OF STACK SPACE TO RELEASE\n.*\n.A010    ANOP\n&I       SETA  1\n&K       SETA  0\n.A020    ANOP\n         PSMROP &SYSLIST(&I)\n&I       SETA  &I+1\n&K       SETA  &K+&PSMROPC\n         AIF   (&I LE &N).A020\n.*\n.* RELEASE STACK SPACE\n.*\n.B010    ANOP\n         PSMRVAL &SYSLIST(1,1)\n&PSMROP1 SETA  &PSMRVAL\n         LA    &PSMROP1,4*&K\n         SR    &SP,&PSMROP1\n.*\n.* POP REGISTERS FROM STACK\n.*\n.C010    ANOP\n&I       SETA  &N\n&J       SETA  4*&K\n.C020    ANOP\n         PSMROP &SYSLIST(&I)\n         AIF   (&PSMROPC GT 1).C030\n&J       SETA  &J-4\n         L     &PSMROP1,&J.(,&SP)\n         AGO   .C060\n.*\n.C030    ANOP\n&J       SETA  &J-(4*&PSMROPC)\n         LM    &PSMROP1,&PSMROP2,&J.(&SP)\n.*\n.C060    ANOP\n&I       SETA  &I-1\n         AIF   (&I GE 1).C020\n.*\n         MEND\n./ ADD NAME=PSMASYM  0100-03194-03194-1243-00010-00010-00000-PASCOTT\n.* COPYRIGHT (C) 1988, PAUL A. SCOTT, ALL RIGHTS RESERVED\n.*\n         MACRO\n         PSMASYM\n.*\n         COPY  PSMGBL02\n.*\n&PSMASYM SETA  &SYSLIST(1,1)\n.*\n         MEND\n./ ADD NAME=PSMCPREF 0100-03194-03194-1243-00039-00039-00000-PASCOTT\n.* COPYRIGHT (C) 1988, PAUL A. SCOTT, ALL RIGHTS RESERVED\n.*\n         MACRO\n&NAME    PSMCPREF &PREFIX=PSM\n.*\n         LCLA  &N\n         LCLC  &P\n.*\n&P       SETC  '&PREFIX'\n.*\n         AIF   (T'&NAME NE 'O').L0100\n&NAME    SETC  '&P'.'CPREF'\n.L0100   ANOP\n.*\n.L0200   ANOP\n.*\n&NAME    DSECT ,\n&P.PJUMP DS    F                   BRANCH AROUND CSECT PREFIX\n*\n*                                  ID STRING\n&P.PLENG DS    FL1                 LENGTH OF IDENTIFIER STRING\n&P.PID   DS    0C                  . S\n&P.PNAME DS    CL8,CL1             . CSECT NAME\n&P.PDATE DS    0CL8                . ASSEMBLY DATE\n&P.PDTEM DS    CL2,CL1               . MONTH\n&P.PDTED DS    CL2,CL1               . DAY\n&P.PDTEY DS    CL2,CL1               . YEAR\n&P.PTIME DS    0CL8                . ASSEMBLY TIME\n&P.PTMEH DS    CL2,CL1               . HOUR\n&P.PTMEM DS    CL2,CL1               . MINUTES\n&P.PTMES DS    CL2,CL1               . SECONDS\n.*\n&P.PRLSE DS    0C                  . PRODUCT RELEASE\n.*\n&P.PLOCL DS    FL4                 SIZE OF SVA PLUS LOCAL VARIABLES\n         DS    FL1                 STACK SUBPOOL ID\n         DS    FL3                 SIZE OF STACK\n         DS    A                   PTR TO PSMINIT MODULE\n.*\n./ ADD NAME=PSMGBL00 0100-03194-03194-1243-00010-00010-00000-PASCOTT\n.* COPYRIGHT (C) 1988, PAUL A. SCOTT, ALL RIGHTS RESERVED\n.*\n         GBLB  &PSMREGS            PSM REGISTERS DEFINED FLAG\n         GBLB  &REGS               IBM REGISTERS DEFINED FLAG\n         GBLC  &PSMBSEC(2)         PROCEDURE BASE REGISTERS\n         GBLC  &PSMBSED            AUTO STORAGE BASE REGISTERS\n         GBLC  &PSMBSEH            HIGHEST REGISTER USED\n         GBLC  &PSMCNAM            PROCEDURE NAME\n         GBLC  &PSMSTKS            STACK SIZE\n.*\n./ ADD NAME=PSMGBL01 0100-03194-03194-1243-00016-00016-00000-PASCOTT\n.* COPYRIGHT (C) 1988, PAUL A. SCOTT, ALL RIGHTS RESERVED\n.*\n         GBLA  &SSID               STACK SUBPOOL ID\n         GBLA  &SP                 STACK POINTER\n         GBLA  &BP                 STACK BASE POINTER\n         GBLA  &HIREG              HIGHEST REGISTER AVAILABLE\n.*\n         GBLB  &PSMSVA             SAVE AREA DEFINED FLAG\n         GBLC  &PSMSIG             UNIQUE SIGNATURE\n.*\n&SSID    SETA  127                 INITIALIZE STACK SUBPOOL ID\n&SP      SETA  3                   INITIALIZE STACK POINTER\n&BP      SETA  13                  INITIALIZE STACK BASE POINTER\n&HIREG   SETA  15                  INITIALIZE HI-REG VALUE\n.*\n&PSMSIG  SETC  'CAFE'\n./ ADD NAME=PSMGBL02 0100-03194-03194-1243-00013-00013-00000-PASCOTT\n.* COPYRIGHT (C) 1988, PAUL A. SCOTT, ALL RIGHTS RESERVED\n.*\n.*             SYMBOL-NAME         MACRO-ID   COMMENT\n.*             _________________   ________   ________________________\n.*\n         GBLA  &PSMRVAL            PSMRVAL  - RETURN REGISTER VALUE\n         GBLA  &PSMROPC            PSMROP   - RETURN REGISTER COUNT\n         GBLA  &PSMROP1,&PSMROP2   PSMROP   - RETURN REGISTER OPERANDS\n         GBLA  &PSMASYM            PSMASYM  - RETURN VALUE\n.*\n         GBLC  &PSMSUBP            PSMSUBP  - RETURN VALUE\n         GBLC  &PSMRLSE            PSMRLSE  - RETURN VALUE\n.*\n./ ADD NAME=PSMGDS   0100-03194-03194-1243-00070-00070-00000-PASCOTT\n         MACRO\n         PSMGDS &PREFIX=GDS\n         LCLC   &P\n&P       SETC   '&PREFIX'\n.*****************************************************************\n.*       PSEUDO-STACK MACHINE GLOBAL DATA STRUCTURE              *\n.*---------------------------------------------------------------*\n.* NAME:            GDS                                          *\n.* POINTED TO BY:   LABEL PSMGDS IN PSMSVA (SAVE AREA +72)       *\n.* DESCRIPTION:     THE GDS IS GENERATED DURING PENTER PROCESSING*\n.*                  IF  TYPE HAS BEEN CODED AS MAIN.  IN THEORY  *\n.*                  THE GDS IS AN ADDRESS SPACE LEVEL CONTROL    *\n.*                  BLOCK WHILE THE LDS IS AT THE TASK LEVEL.    *\n.*                  INFORMATION IN THE GDS IS LIMITED TO THAT    *\n.*                  WHICH COULD BE CONSIDERED APPLICABLE OR      *\n.*                  COMMON TO ALL TASKS WITHIN THE ADDRESS SPACE *\n.*                                                               *\n.*                MAIN TASK                                      *\n.*                 ________                   SUB TASK           *\n.*                | GDS    |<-----.  <--------------------.      *\n.*                |--------|      |           ________    |      *\n.*                | LDS    |<----.|          | LDS    |   |      *\n.*                |--------|     ||          |--------|   |      *\n.*                | PSMSVA |=====-'          | PSMSVA |---'      *\n.*                |--------|                 |--------|          *\n.*                | STACK  |                 | STACK  |          *\n.*                |________|                 |________|          *\n.*                                                               *\n.*                                                               *\n.*****************************************************************\nGDS      DSECT ,\n*\n&P.ID    DS    CL8'PSMGDS'         EYE CATCHER\n*\n&P.IN    DS    A(0)                STANDARD INPUT WORK AREA\n&P.OUT   DS    A(0)                STANDARD OUTPUT WORK AREA\n&P.ERROR DS    A(0)                STANDARD ERROR WORK AREA\n&P.PRINT DS    A(0)                STANDARD PRINT WORK AREA\n*\n&P.ARGC  DS    F'0'                ARGUMENT COUNT\n&P.ARGV  DS    A(0)                PTR TO LIST OF ARGUMENT PTRS\n&P.ENVPT DS    A(0)                PTR TO ENVIRONMENT STRINGS\n*\n&P.HEAPF DS    A(0)                PTR TO FIRST HEAP BLOCK (PSMHEAP)\n&P.HEAPL DS    A(0)                PTR TO LAST  HEAP BLOCK\n&P.HLOCK DS    A(0)                HEAP LOCK (SERIALIZATION WITH CS)\n*\n&P.ENVSW DS    X                   ENVIRONMENT SWITCH\n&P.ESXA  DS    X'01'               .... ...1   MVS/XA (SP VERSION 2)\n&P.ESJ2  DS    X'02'               .... ..1.   JES2\n&P.ESJ3  DS    X'04'               .... .1..   JES3\n&P.ESTSO DS    X'08'               .... 1...   TSO\n&P.ESSPF DS    X'10'               ...1 ....   TSO/ISPF\n&P.ESJOB DS    X'20'               ..1. ....   JOB\n&P.ESSTC DS    X'40'               .1.. ....   STARTED TASK\n&P.NAME  DS    CL8                 ADDRESS SPACE NAME\n&P.JOBID DS    CL8                 ADDRESS SPACE JOBID\n&P.SSNAM DS    CL4                 SUBSYSTEM NAME\n&P.SPVER DS    CL8                 MVS/SP VERSION (CVTPRODN)\n*\n*  PSM LOCKS ARE SERIALIZED USING COMPARE AND SWAP.  THE VALUE\n*  SWAPPED IN X'FFFFFFFF' IF THE LOCK IS HELD AND ZERO IF IT IS\n*  NOT.  ALL LOCKS MUST PROVIDE 2 WORDS.\n*\n&P.LOCKS DS    CL8'LOCKS>'         START OF PSM LOCKS SECTION\n&P.HPLOC DS    F                   HEAP LOCK\n&P.HPECB DS    F                   HEAP LOCK ECB IF QUEUED\n*\n&P.LENG  EQU   *-PSMGDS            LENGTH OF GLOBAL DATA AREA\n         MEND\n./ ADD NAME=PSMRLSE  0100-03194-03194-1243-00017-00017-00000-PASCOTT\n.* COPYRIGHT (C) 1988, PAUL A. SCOTT, ALL RIGHTS RESERVED\n.*\n         MACRO\n         PSMRLSE\n.*\n         COPY  PSMGBL02\n.*\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*       THIS MACRO DEFINES THE PRODUCT NAME AND RELEASE DATA\n.*       WHICH WILL BE INCLUDED IN THE CSECT PREFIX AREA.\n.*       KEEP A COPY OF THIS MACRO IN EACH PRODUCT MACRO LIBRARY\n.*       AND CHANGE THE GLOBAL VARIABLE &PSMRLSE AS APPROPRIATE.\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*\n&PSMRLSE SETC  'PSM 1.0.0'\n.*\n         MEND\n./ ADD NAME=PSMROP   0100-03194-03194-1243-00037-00037-00000-PASCOTT\n.* COPYRIGHT (C) 1988, PAUL A. SCOTT, ALL RIGHTS RESERVED\n.*\n         MACRO\n         PSMROP\n.*\n         COPY  PSMGBL02\n         LCLA  &A\n.*\n.A010    ANOP\n.*\n&PSMROPC SETA  0\n&PSMROP1 SETA  17\n&PSMROP2 SETA  17\n&A       SETA  N'&SYSLIST(1)\n         AIF   (&A LT 1).A040\n.*\n         AIF   (&A GT 1).A020\n         PSMRVAL &SYSLIST(1,1)\n&PSMROP1 SETA  &PSMRVAL\n&PSMROP2 SETA  &PSMRVAL\n&PSMROPC SETA  1\n         AGO   .A040\n.*\n.A020    ANOP\n         PSMRVAL &SYSLIST(1,1)\n&PSMROP1 SETA  &PSMRVAL\n         PSMRVAL &SYSLIST(1,2)\n&PSMROP2 SETA  &PSMRVAL\n         AIF   (&PSMROP1 GT &PSMROP2).A030\n&PSMROPC SETA  1+(&PSMROP2-&PSMROP1)\n         AGO   .A040\n.A030    ANOP\n&PSMROPC SETA  (1+(15-&PSMROP1))+(1+&PSMROP2)\n.*\n.A040    ANOP\n.*\n         MEND\n./ ADD NAME=PSMROPS  0100-03194-03194-1243-00039-00039-00000-PASCOTT\n.* COPYRIGHT (C) 1988, PAUL A. SCOTT, ALL RIGHTS RESERVED\n         MACRO\n&LABEL   PSMROPS\n.*\n         COPY  PSMGBL02\n         LCLA  &I,&K\n         LCLC  &C,&R1,&R2\n.*\n.A010    ANOP\n.*\n&C       SETC  '&SYSLIST(1,1)'\n         AIF   ('&C'(1,1) NE '(').A020\n&C       SETC  '&C'(2,K'&C-2)\n.*\n.A020    ANOP\n&I       SETA  1\n&K       SETA  K'&C\n.*\n.A030    ANOP\n         AIF   (&I GT &K).A040\n         AIF   ('&C'(&I,1) EQ ',').A040\n&I       SETA  &I+1\n         AGO   .A030\n.*\n.A040    ANOP\n&R1      SETC  '0'\n&R2      SETC  '0'\n.*\n         AIF   ('&C'(1,1) EQ ',').A050\n&R1      SETC  '&C'(1,&I-1)\n.*\n.A050    ANOP\n         AIF   (&I GE &K).A060\n&R2      SETC  '&C'(&I+1,&K-&I)\n.*\n.A060    ANOP\n         PSMROP  (&R1,&R2)\n.*\n         MEND\n./ ADD NAME=PSMRVAL  0100-03194-03194-1243-00025-00025-00000-PASCOTT\n.* COPYRIGHT (C) 1988, PAUL A. SCOTT, ALL RIGHTS RESERVED\n.*\n         MACRO\n         PSMRVAL\n.*\n         COPY  PSMGBL02\n         LCLC  &C\n.*\n&C       SETC  '&SYSLIST(1,1)'\n         AIF   ('&C'(1,1) NE 'R').A010\n&C       SETC  '&C'(2,K'&C-1)\n.*\n.A010    ANOP\n         PSMASYM &C\n.*\n&PSMRVAL SETA  &PSMASYM\n.*\n         AIF   (&PSMRVAL GT 15).MSG1\n         MEXIT\n.*\n.*  ERROR PROCESSING\n.*\n.MSG1    MNOTE 8,'OOPS, ONLY 15 REGISTERS ON THIS MACHINE'\n         MNOTE 8,'PARM 1 CAN BE 0-15 (R1-R15)'\n         MEND\n./ ADD NAME=PSU001   0100-03194-03194-1243-00171-00171-00000-PASCOTT\n* COPYRIGHT (C) 1988, PAUL A. SCOTT, ALL RIGHTS RESERVED\n* ANY USE OF THIS CODE MUST RETAIN THE ABOVE COPYRIGHT NOTICE\n*\n* PSU001 IS RENT,REUS\n*\n* COMPARES TWO CONSTANTS OR SYMBOLICS SPECIFIED IN THE PARM FIELD.\n* A TRUE CONDITION RESULTS IN A ZERO RETURN CODE, AND A FALSE\n* CONDITION RESULTS IN A RETURN CODE OF 1.\n* THE FORMAT OF THE PARM FIELD IS: FIELD1,OP,FIELD2\n*   WHERE FIELD1 AND FIELD2 ARE EITHER A CONSTANT OR A SYMBOLIC\n*     AND OP IS ONE OF THE FOLLOWING OPERATORS:\n*           EQ, NE, LT, LE, GT, GE\n*\n* EXAMPLE:\n*    //STEP1   EXEC PGM=PSU001,\n*    //            PARM=(&JESNAME,EQ,JES2)\n*\n*\nPSU001   PENTER MAIN,VARS=(@VARS,@VARSLEN),STACK=1\n*\n*---------------------------------------------------------------------*\n*        MAINLINE                                                     *\n*---------------------------------------------------------------------*\n*\n         L     R2,0(,R1)               PARM PTR\n         LH    R4,0(,R2)               PARM LENGTH\n*\n         LTR   R4,R4                   ANY PARM PRESENT ?\n         BZ    INVALID                 NO, REPORT ERROR\n*\n*        PARSE PARM FOR 'STRING1,OP,STRING2'\n*\n         LA    R5,1(R4,R2)             POINT TO LAST BYTE OF PARM\n         LA    R4,1                    STEP ONE BYTE AT A TIME\n         LA    R2,2(,R2)               POINT TO FIRST BYTE OF PARM\n         LR    R7,R2                   SAVE PTR TO FIRST BYTE OF PARM\n*\nA00100   CLI   0(R2),C','              FOUND A COMMA?\n         BNE   A00200                  NO, CHECK NEXT BYTE\n         BAL   R14,SVFIELD             YES, SAVE CURRENT FIELD\nA00200   BXLE  R2,R4,A00100            LOOP THROUGH EVERY BYTE OF PARM\n         BAL   R14,SVFIELD             SAVE LAST FIELD\n*\n*        DO STRING COMPARISON\n*\n         L     R4,@STR1                STRING1 PTR\n         L     R5,@STR1L               STRING1 LENGTH\n         L     R6,@STR2                STRING2 PTR\n         L     R7,@STR2L               STRING2 LENGTH\n*\n         OR    R4,R4                   HAVE VALID STRING1 PTR ?\n         BZ    INVALID                 NO, REPORT ERROR\n         OR    R5,R5                   HAVE VALID STRING1 LENGTH ?\n         BZ    INVALID                 NO, REPORT ERROR\n         OR    R6,R6                   HAVE VALID STRING2 PTR ?\n         BZ    INVALID                 NO, REPORT ERROR\n         OR    R7,R7                   HAVE VALID STRING2 LENGTH ?\n         BZ    INVALID                 NO, REPORT ERROR\n*\n         LA    R1,OPTABLE              START OF OPERATOR TABLE\n         LA    R14,L'OPTABLE           LENGTH OF EACH ENTRY\n         LA    R15,OPEND               END OF OPERATOR TABLE\n*\n         USING OPTABLE,R1\n*\nA00300   CLC   OP,@OP                  FOUND LOGICAL OPERATOR ?\n         BE    A00400                  YES, CONTINUE\n         BXLE  R1,R14,A00300           NO, SCAN ENTIRE TABLE\n*\nA00400   XR    R14,R14                 CLEAR\n         CLCL  R4,R6                   COMPARE STRINGS\n         EX    R14,COND                EXECUTE BRANCH TRUE CONDITION\n         B     EXITFALS                LOGICAL CONDITION WAS FALSE\n*\n         DROP  R1\n*\nINVALID  WTO  'PSU0011I - INVALID PARAMETERS',ROUTCDE=11,DESC=6\n         WTO  'PSU0012I - USE ''STRING1,OP,STRING2''',ROUTCDE=11,DESC=6\n         ABEND 1\n*\nEXITFALS MVC  @RC,=F'1'                RETURN FALSE\nEXITTRUE L    R15,@RC                  RETURN TRUE\n*\n         PEXIT RC=(R15)                RETURN TO CALLER\n*\n*---------------------------------------------------------------------*\n*        SVFIELD SUBROUTINE                                           *\n*---------------------------------------------------------------------*\n*\n*        INPUT REGS:  R2 - PTR TO COMMA AT END OF CURRENT FIELD\n*                     R7 - PTR TO START OF CURRENT FIELD\n*\n*        OUTPUT REGS: R7 - PTR TO FIRST BYTE OF NEXT FIELD\n*\n*\nSVFIELD  PUSHREG R14                   SAVE RETURN ADDRESS\n*\n         OC    @STR1,@STR1             NOW AT STRING1 ?\n         BNZ   S00100                  NO, TRY OPERATOR\n*\n         ST    R7,@STR1                STORE START OF FIELD\n         LR    R14,R2                  CURRENT LOCATION\n         SR    R14,R7                  COMPUTE LENGTH OF PARM\n         ST    R14,@STR1L              SAVE ZERO RELATIVE LENGTH\n         LA    R7,1(,R2)               COMPUTE START OF NEXT FIELD\n         B     S00400\n*\nS00100   OC    @OP,@OP                 NOW AT OPERATOR ?\n         BNZ   S00300                  NO, TRY STRING2\n*\n         MVC   @OP,0(R7)               SAVE THE OPERATOR\n         LA    R7,1(,R2)               COMPUTE START OF NEXT FIELD\n         B     S00400\n*\nS00300   OC    @STR2,@STR2             NOW AT STRING2 ?\n         BNZ   S00400                  NO, IGNORE EXCESS FIELDS\n*\n         ST    R7,@STR2                STORE START OF FIELD\n         LR    R14,R2                  CURRENT LOCATION\n         SR    R14,R7                  COMPUTE LENGTH OF PARM\n         ST    R14,@STR2L              SAVE ZERO RELATIVE LENGTH\n         LA    R7,1(,R2)               COMPUTE START OF NEXT FIELD\n*\nS00400   POPREG R14                    RESTORE RETURN ADDRESS\n         BR  R14                       RETURN TO CALLER\n*\n*---------------------------------------------------------------------*\n*        OPERATION CODE TABLE                                         *\n*---------------------------------------------------------------------*\n*\n*        THE OPCODE TABLE MATCHES THE CHARACTER OPERATION CODE WITH\n*        ITS CORRESPONDING 'BRANCH ON CONDITION' INSTRUCTION.\n*\n*        THE LAST ENTRY IN THE TABLE IS A HARD BRANCH TO THE LABEL\n*        THAT SETS A FALSE CONDITION. THIS SIMPLIFIES THE PROGRAM\n*        LOGIC SUCH THAT NO SPECIAL END-OF-TABLE CHECK IS NECESSARY.\n*\nOPTABLE  DS  0CL6                      OPERATOR TABLE\n*\nOP       DC  CL2'EQ'                   EQUAL OPERATOR\nCOND     BE          EXITTRUE              BRANCH ON EQUAL\n         DC  CL2'NE'                   NOT EQUAL OPERATOR\n         BNE         EXITTRUE              BRANCH ON NOT EQUAL\n         DC  CL2'LT'                   LESS THAN OPERATOR\n         BL          EXITTRUE              BRANCH ON LESS THAN\n         DC  CL2'LE'                   LESS THAN OR EQUAL OPERATOR\n         BNH         EXITTRUE              BRANCH ON NOT GREATER\n         DC  CL2'GT'                   GREATER THAN OPERATOR\n         BH          EXITTRUE              BRANCH ON GREATER THAN\n         DC  CL2'GE'                   GREATER OR EQUAL OPERATOR\n         BNL         EXITTRUE              BRANCH ON NOT LESS\nOPEND    EQU *-1\n         DC  CL2'FF'                   MARK END OF TABLE\n         B           INVALID           FORCE FALSE CONDITION\n*\n*---------------------------------------------------------------------*\n*        LOCAL (AUTO) STORAGE                                         *\n*---------------------------------------------------------------------*\n*\n*   N.B. AUTO STORAGE INITIALIZED TO BINARY ZEROS ON PROGRAM ENTRY\n*\n@VARS    DSECT ,                       LOCAL STORAGE\n@RC      DS    F                       . RETURN CODE\n@STR1    DS    F                       . STRING1 PTR\n@STR1L   DS    F                       . STRING1 LENGTH\n@STR2    DS    F                       . STRING2 PTR\n@STR2L   DS    F                       . STRING2 LENGTH\n@OP      DS    CL2                     . OPERATOR\n@VARSLEN EQU *-@VARS                   LENGTH OF LOCAL STORAGE\n*\n         END   PSU001\n./ ADD NAME=PSU002   0100-03194-03194-1243-00173-00173-00000-PASCOTT\n* COPYRIGHT (C) 1988, PAUL A. SCOTT, ALL RIGHTS RESERVED\n* ANY USE OF THIS CODE MUST RETAIN THE ABOVE COPYRIGHT NOTICE\n*\n* PSU002 IS RENT,REUS\n*\n* COPIES PARM FIELD TO A DATA SET ON ONE OR MORE RECORDS.\n* THE OUTPUT DATASET (SYSOUT) CAN HAVE F, FB, V, OR VB\n* FORMAT RECORDS.\n* THE RECORD SEPARATOR IS THE FIRST CHARACTER OF THE PARM\n* AND IS NOT INCLUDED IN THE OUTPUT RECORDS.\n* IF A COMMA IMMEDIATELY FOLLOWS A RECORD SEPARATOR, THE\n* COMMA IS NOT INCLUDED IN THE OUTPUT RECORD.\n*\n* EXAMPLE:\n*    //STEP1   EXEC PGM=PSU002,\n*    //            PARM=('\\',                       RECORD SEPARATOR\n*    //            ' C INDD=SYSUT1,OUTDD=SYSUT2\\',  CARD #1\n*    //            ' S M=(MEMBERA,MEMBERB) ')       CARD #2\n*    //SYSOUT  DD  DSN=&&IEBCOPY,UNIT=VIO,ETC...\n*\nPSU002   PENTER MAIN,VARS=(@VARS,@VARSLEN),STACK=1\n*\n*---------------------------------------------------------------------*\n*        MAINLINE                                                     *\n*---------------------------------------------------------------------*\n*\n         L     R2,0(,R1)               PARM PTR\n         LH    R4,0(,R2)               PARM LENGTH\n*\n         MVC   @SYSOUT(DCBL),DCB       INITIALIZE DCB\n         MVC   @OPEN(OPENL),OPEN       INITIALIZE OPEN PARAMETER LIST\n         OPEN  (@SYSOUT,(OUTPUT)),     OPEN OUTPUT FILE                C\n               MF=(E,@OPEN)\n*\n         CH    R4,=H'2'                PARM PRESENT ?\n         BL    EXIT                    NO, NOTHING TO WRITE\n*\n         MVC   @SEP,2(R2)              SAVE THE LINE SEPARATOR\n*\n         LA    R5,1(R4,R2)             POINT TO LAST BYTE OF PARM\n         LA    R4,1                    STEP ONE BYTE AT A TIME\n         LA    R2,3(,R2)               POINT TO 1ST BYTE PAST SEPARATOR\n         LR    R7,R2                   SAVE PTR TO RECORD DATA\n*\nA00100   CLC   0(1,R2),@SEP            FOUND A SEPARATOR?\n         BNE   A00200                  NO, KEEP LOOKING\n         BAL   R14,MOVECARD            YES, WRITE A RECORD\nA00200   BXLE  R2,R4,A00100            LOOP THROUGH EVERY BYTE OF PARM\n         BAL   R14,MOVECARD            WRITE LAST RECORD\n*\nEXIT     MVC   @CLOSE(CLOSEL),CLOSE    INITIALIZE CLOSE PARAMETER LIST\n         CLOSE (@SYSOUT),              CLOSE OUTPUT FILE               C\n               MF=(E,@CLOSE)\n*\n         L  R15,@RC                    PICK UP RETURN CODE\n         PEXIT RC=(R15)                RETURN TO CALLER\n*\n*---------------------------------------------------------------------*\n*        MOVECARD SUBROUTINE                                          *\n*---------------------------------------------------------------------*\n*\n*        INPUT REGS:  R2 - PTR TO RECORD SEPARATOR AT END OF RECORD\n*                     R7 - PTR TO START OF CURRENT RECORD\n*\n*        OUTPUT REGS: R7 - PTR TO START OF NEXT RECORD\n*\n*\nMOVECARD PUSHREG R14,R6\n*\n         LR    R6,R2                   CURRENT LOCATION\n         SR    R6,R7                   COMPUTE LENGTH OF CARD\n         BCTR  R6,0                    MAKE LENGTH ZERO RELATIVE\n*\n*        REMOVE A COMMA FOLLOWING A RECORD SEPERATOR\n*\n*        ONE CAN EASILY IMAGINE A SITUATION IN WHICH\n*        A COMMA FOLLOWING A RECORD SEPARATOR SHOULD\n*        NOT BE REMOVED. BUT AS THERE IS NO POSSIBLE\n*        METHOD TO DETERMINE WHEN SUCH A CASE EXISTS\n*        WE ESTABLISH THE LAW THAT A COMMA FOLLOWING\n*        A RECORD SEPARATOR SHALL ALWAYS BE REMOVED.\n*\n*        A FULL DISCUSSION OF ALL THE POINTS LEADING\n*        TO THIS RULE IS NOT APPROPRIATE HERE. TRUST\n*        ME, THOUGH, THERE IS NO BUG HERE, SO PLEASE\n*        DON'T TRY TO FIX IT.  ;-)\n*\n         CLI   0(R7),C','              TRAILING COMMA ?\n         BNE   B00100                  NO, TIME TO WRITE RECORD\n         LA    R7,1(,R7)               SKIP OVER THE COMMA\n         BCTR  R6,0                    ADJUST LENGTH TO COMPENSATE\n*\n*        WRITE THE RECORD, TAKING INTO ACCOUNT THE\n*        SUBTLETIES OF THE ALLOWED RECORD FORMATS.\n*\nB00100   LA    R8,@SYSOUT              POINT TO OUTPUT DCB\n         USING IHADCB,R8               ESTABLISH ADDRESSABILITY\n*\n         TM    DCBRECFM,DCBRECU        UNDEFINED RECORD FORMAT ?\n         BO    B00400                  YES, FORMAT NOT SUPPORTED\n*\n         PUT   @SYSOUT                 LOCATE RECORD BUFFER --> R1\n         TM    DCBRECFM,DCBRECV        VARIABLE RECORD FORMAT ?\n         BNO   B00200                  NO, TRY FIXED FORMAT\n*\n         LA    R14,5(,R6)              ADJUST LENGTH FOR RDW\n         STCM  R14,B'0011',0(R1)       STUFF LENGTH INTO RDW\n         STCM  R14,B'1100',2(R1)       CLEAR HIGH-ORDER RDW BITS\n         LA    R1,4(,R1)               SKIP RDW, POINT TO RECORD AREA\n         LR    R14,R6                  ACTUAL RECORD LENGTH\n         BCTR  R14,0                   MINUS ONE FOR CLEARING BUFFER\n         B     B00300                  CLEAR BUFFER\n*\nB00200   TM    DCBRECFM,DCBRECF        FIXED RECORD FORMAT ?\n         BNO   B00400                  NO, FORMAT NOT SUPPORTED\n         LH    R14,DCBLRECL            FIXED RECORD LENGTH\n         BCTR  R14,0                   MAKE LENGTH ZERO RELATIVE\n         BCTR  R14,0                   MINUS ONE FOR CLEARING BUFFER\n*\nB00300   MVI   0(R1),C' '              CLEAR RECORD BUFFER\n         EX    R14,CLRINSTR               TO ALL SPACES\n*\n         LTR   R6,R6                   ACTUAL RECORD LENGTH > 0 ?\n         BM    B00400                  NO, USE BLANK RECORD\n         EX    R6,MVCINSTR             YES, COPY RECORD TO BUFFER\n*\nB00400   LA    R7,1(,R2)               COMPUTE START OF NEXT RECORD\n*\n         POPREG R14,R6                 RESTORE RETURN ADDRESS\n         BR    R14                     RETURN TO CALLER\n*\n*---------------------------------------------------------------------*\n*        PROTOTYPE INSTRUCTIONS AND DATA                              *\n*---------------------------------------------------------------------*\n*\nCLRINSTR MVC 1(0,R1),0(R1)\nMVCINSTR MVC 0(0,R1),0(R7)\n*\nDCB      DCB   DDNAME=SYSOUT,                                          X\n               DSORG=PS,                                               X\n               MACRF=PL\nDCBL     EQU   *-DCB\n*\nOPEN     OPEN  (,),                                                    X\n               MF=L\nOPENL    EQU   *-OPEN\n*\nCLOSE    CLOSE (,),                                                    X\n               MF=L\nCLOSEL   EQU   *-CLOSE\n*\n         DCBD  DSORG=PS\n*\n*---------------------------------------------------------------------*\n*        LOCAL (AUTO) STORAGE                                         *\n*---------------------------------------------------------------------*\n*\n*   N.B. AUTO STORAGE INITIALIZED TO BINARY ZEROS ON PROGRAM ENTRY\n*\n@VARS    DSECT ,\n@RC      DS    F\n@STR1    DS    F\n@STR1L   DS    F\n@STR2    DS    F\n@STR2L   DS    F\n@OP      DS    CL2\n@SEP     DS    B\n@OPEN    OPEN  (,),MF=L\n@CLOSE   CLOSE (,),MF=L\n@SYSOUT  DCB   DSORG=PS,MACRF=(PL)\n@VARSLEN EQU   *-@VARS\n*\n         END   PSU002\n./ ADD NAME=PSU003   0100-03194-03194-1243-00979-00979-00000-PASCOTT\n* COPYRIGHT (C) 1988, PAUL A. SCOTT, ALL RIGHTS RESERVED\n* ANY USE OF THIS CODE MUST RETAIN THE ABOVE COPYRIGHT NOTICE\n*\n* MODULE     PSU003\n* AUTHOR     P. SCOTT\n*\n* PSU003 IS RENT,REUS\n*\n* EXAMPLE:\n*    //STEP1   EXEC PGM=PSU003,\n*    //            PARM=('&&PREFIX=PROD.LOAN.SL')\n*\n*\nPSU003   TITLE ' - MAINLINE PROCESSING '\n*---------------------------------------------------------------------*\n*        MAINLINE PROCESSING                                          *\n*---------------------------------------------------------------------*\n*\nPSU003   PENTER MAIN,VARS=(ZVARS,ZVARL),STACK=1\n*\n         BAL   R14,B0000           PARSE OUT STRINGS\n*\n         LA    R0,ZSTRINGS         START OF STRING PTRS\n         C     R0,ZSTREPTR         WERE ANY STRINGS FOUND ?\n         BL    A0100               YES, PROCESS THEM\n*\n         LA    R0,28               MESSAGE LENGTH\n         LA    R1,=C'PSU0030I NO STRINGS DEFINED.'\n         BAL   R14,W0000           WRITE MESSAGE TO JOB LOG\n         MVC   ZRC,=A(8)           SET RETURN CODE\n         B     EXIT                AND EXIT\n*\nA0100    BAL   R14,W0100           WRITE STRINGS TO LOG\n         BAL   R14,P0000           PROCESS INPUT DATA SET\n*\nEXIT     L     R15,ZRC             GET RETURN CODE\n         PEXIT RC=(15)             RETURN TO CALLER\n*\n         TITLE ' - B0000 - PARSE OUT STRINGS '\n*---------------------------------------------------------------------*\n*        B0000 - PARSE OUT STRINGS                                    *\n*---------------------------------------------------------------------*\n*\nB0000    PUSHREG R14               SAVE RETURN PTR\n*\n         LA    R6,ZSTRINGS         TABLE OF STRPTR'S AND STRLEN'S\n         USING STRINGS,R6\n*\n         BAL   R14,B1000           PROCESS PARM STRINGS\n         BAL   R14,B2000           PROCESS SYSIN STRINGS\n*\n         BCTR  R6,0                LAST BYTE USED IN STRING TABLE\n         ST    R6,ZSTREPTR         SAVE END OF TABLE PTR\n*\nB0990    POPREG R14                RETORE RETURN PTR\n         BR    R14                 RETURN\n*\n         TITLE ' - B1000 - PROCESS PARM DATA '\n*---------------------------------------------------------------------*\n*        B1000 - PROCESS PARM DATA                                    *\n*---------------------------------------------------------------------*\n*\nB1000    PUSHREG R14               SAVE RETURN PTR\n*\n         L     R2,0(,R1)           PARM PTR\n         LH    R4,0(,R2)           PARM LENGTH\n*\n         LTR   R4,R4               CHECK FOR PRESENCE OF PARM\n         BZ    B1990               SKIP IF NO PARM\n*\n         BCTR  R4,0                COMPUTE ZERO RELATIVE LENGTH\n         MVC   STRBFR(0),2(R2)     MODEL\n         EX    R4,*-6              SAVE THE STRING\n*\n         LA    R15,STRBFR(R4)      POINT TO LAST  BYTE OF PARM DATA\n         LA    R2,STRBFR           POINT TO FIRST BYTE OF PARM DATA\n         BAL   R14,C0000           PARSE FIELDS\n*\nB1990    POPREG R14                RESTORE RETURN PTR\n         BR    R14                 RETURN\n*\n         TITLE ' - B2000 - PROCESS SYSIN DATA '\n*---------------------------------------------------------------------*\n*        B2000 - PROCESS SYSIN DATA                                   *\n*---------------------------------------------------------------------*\n*\nB2000    PUSHREG R14               SAVE RETURN PTR\n*\n         LA    R2,=CL8'SYSIN'\n         BAL   R14,D1000           OBTAIN SYSIN DATA SET INFO\n         BNZ   B2990               NO, RETURN\n*\n         LA    R2,ZDCBPS1          ESTABLISH DCB ADDRESSABILITY\n         USING IHADCB,R2\n*\n         MVC   ZDCBPS1(DCBPSL),DCBPS      INITIALIZE DCB\n         MVC   DCBDDNAM,=CL8'SYSIN'       DDNAME=SYSIN\n         LA    R0,B2980                   SYSIN END-OF-DATA ROUTINE\n         STCM  R0,B'0111',DCBEODA         EODAD=B2980\n*\n         MVC   ZOPEN(OPENL),OPEN\n         OPEN  (ZDCBPS1,(INPUT)),MF=(E,ZOPEN)\n         TM    DCBOFLGS,DCBOFOPN   DID SYSIN OPEN SUCCESSFULLY?\n         BNO   B2990               NO, RETURN\n*\n         DROP  R2\n*\nB2100    GET   ZDCBPS1             OBTAIN A RECORD\n         MVC   STRBFR(80),0(R1)\n*\n         LA    R15,STRBFR+70       POINT TO LAST  BYTE OF PARM DATA\n         LA    R2,STRBFR           POINT TO FIRST BYTE OF PARM DATA\n         BAL   R14,C0000           PARSE FIELDS\n*\n         B     B2100\n*\nB2980    MVC   ZCLOSE(CLOSEL),CLOSE\n         CLOSE (ZDCBPS1),MF=(E,ZCLOSE)\n*\nB2990    POPREG R14                RESTORE RETURN PTR\n         BR    R14                 RETURN\n*\n         TITLE ' - C0000 - PARSE FIELDS '\n*---------------------------------------------------------------------*\n*        C0000 - PARSE FIELDS                                         *\n*           ENTRY:                                                    *\n*               R2 - START OF DATA AREA                               *\n*              R15 - LAST BYTE OF DATA AREA                           *\n*---------------------------------------------------------------------*\n*\nC0000    PUSHREG R14               SAVE RETURN PTR\n*\n*        REMOVE LEADING SPACES\n*\n         LR    R4,R2               SAVE STARTING LOCATION\n         LA    R14,1               INCREMENT A BYTE AT A TIME\n*\nC0100    CLI   0(R4),C' '          SPACE CHARACTER ?\n         BNE   C0150               NO, FOUND SIGNIFICANT CHARACTER\n         BXLE  R4,R14,C0100        SCAN ALL OF DATA\n         B     C0990               RETURN, NO DATA\n*\n*        REMOVE TRAILING SPACES\n*\nC0150    LR    R2,R4               NEW LOCATION OF DATA\n         LR    R4,R15              START WITH END OF RECORD\n         LA    R14,1               DECREMENT A BYTE AT A TIME\n         LNR   R14,R14             MAKE NEGATIVE INCREMENT\n         LR    R15,R2              FINISH WITH START OF RECORD\n*\nC0200    CLI   0(R4),C' '          CHECK FOR SPACE\n         BNE   C0250               FOUND A CHARACTER\n         BXH   R4,R14,C0200        KEEP LOOKING\n*\n*        COMPUTE SCAN LENGTH - 1\n*\nC0250    SR    R4,R2               COMPUTE LENGTH OF STRING - 1\n         LTR   R4,R4               COMPUTED VALUE SHOULD NEVER\n         BM    C0990                  BECOME NEGATIVE\n*\n*        LOCATE AND SAVE START AND LENGTH OF EACH FIELD\n*\n         LA    R5,0(R4,R2)         POINT TO LAST BYTE OF PARM\n         LA    R4,1                STEP ONE BYTE AT A TIME\n         LR    R7,R2               SAVE PTR TO FIRST BYTE OF PARM\n*\nC0300    CLI   0(R2),C'='          FOUND END OF FIRST FIELD ?\n         BE    C0350               YES, SAVE FIRST FIELD\n         CLI   0(R2),C','          FOUND END OF SECOND FIELD ?\n         BNE   C0400               NO, TRY NEXT CHARACTER\nC0350    MVC   ZSEPCHAR,0(R2)      SAVE SEPARATER CHARACTER\n         BAL   R14,C1000           SAVE CURRENT FIELD\nC0400    BXLE  R2,R4,C0300         SCAN ENTIRE PARM\n*\n         MVI   ZSEPCHAR,C'!'       INDICATE END OF DATA\n         BAL   R14,C1000           SAVE CURRENT FIELD\n*\nC0990    POPREG R14                RESTORE RETURN PTR\n         BR    R14                 RETURN\n*\n         TITLE ' - C1000 - SAVE CURRENT FIELD '\n*---------------------------------------------------------------------*\n*        C1000 - SAVE CURRENT FIELD                                   *\n*---------------------------------------------------------------------*\n*\nC1000    PUSHREG R14               SAVE RETURN PTR\n*\n         L     R14,=A(STRNUM*STRLEN)\n         LA    R0,ZSTRINGS(R14)\n         CR    R0,R6               MAXIMUM NUMBER OF STRINGS ?\n         BH    C1100               NO, CONTINUE\n*\n         LA    R0,43               MESSAGE LENGTH\n         LA    R1,=C'PSU0031I EXCEEDED MAXIMUM NUMBER OF STRINGS'\n         BAL   R14,W0000           WRITE MESSAGE TO JOB LOG\n         ABEND 1\n*\nC1100    CLI   ZSEPCHAR,C','       IS THIS THE SECOND STRING ?\n         BE    C1150               YES, PROCESS SECOND\n*\n         OC    STR1PTR,STR1PTR     IS THIS THE FIRST STRING ?\n         BNZ   C1150               NO, PROCESS SECOND\n*\n         ST    R7,STR1PTR          STORE START OF FIELD\n         LR    R14,R2              CURRENT LOCATION\n         SR    R14,R7              COMPUTE LENGTH OF PARM\n         ST    R14,STR1LEN         SAVE LENGTH\n         LA    R7,1(,R2)           COMPUTE BEGINNING OF NEXT FIELD\n*\n         CLI   ZSEPCHAR,C'!'       END OF DATA ?\n         BE    C1175               YES, POINT TO NEXT GROUP OF STRINGS\n*\n         B     C1200               RETURN\n*\nC1150    CLI   ZSEPCHAR,C'='       FIRST STRING SEPARATOR ?\n         BE    C1200               YES, BUT MUST BE DATA\n*\n         OC    STR2PTR,STR2PTR     ALREADY ACCOUNTED FOR END OF PARM ?\n         BNZ   C1200               YES, RETURN\n*\n         ST    R7,STR2PTR          STORE START OF FIELD\n         LR    R14,R2              CURRENT LOCATION\n         SR    R14,R7              COMPUTE LENGTH OF PARM\n         ST    R14,STR2LEN         SAVE LENGTH\n         LA    R7,1(,R2)           COMPUTE BEGINNING OF NEXT FIELD\n*\nC1175    LA    R6,STRLEN(,R6)      POINT TO NEXT GROUP OF STRINGS\n*\nC1200    POPREG R14                RESTORE RETURN PTR\n         BR    R14                 RETURN\n*\n         TITLE ' - D0000 - DYNAMIC ALLOCATION '\n*---------------------------------------------------------------------*\n*        D0000 - DYNAMIC ALLOCATION                                   *\n*---------------------------------------------------------------------*\n*\nD0000    PUSHREG R14               SAVE RETURN PTR\n*\n         LA    R1,ZDRB\n         ST    R1,ZDRBP\n         OI    ZDRBP,X'80'\n         LA    R1,ZDRBP\n         DYNALLOC ,\n*\nD0990    POPREG R14                RESTORE RETURN PTR\n         BR    R14                 RETURN\n*\n         TITLE ' - D1000 - OBTAIN DATA SET INFO '\n*---------------------------------------------------------------------*\n*        D1000 - OBTAIN DATA SET INFO                                 *\n*---------------------------------------------------------------------*\n*\nD1000    PUSHREG R14               SAVE RETURN PTR\n*\n         LA    R14,ZINTU1          ALLOCATION TEXT UNIT 1\n         LA    R15,ZINTU2          ALLOCATION TEXT UNIT 2\n         LA    R0,ZINTU3           ALLOCATION TEXT UNIT 3\n         LA    R1,ZINTU4           ALLOCATION TEXT UNIT 4\n         O     R1,=A(X'80000000')  MARK END OF LIST\n         STM   R14,R1,ZDTUP        STORE LIST OF POINTERS\n*\n         XC    ZDRB,ZDRB\n         MVI   ZDRBL,20\n         MVI   ZDRBVERB,S99VRBIN\n         LA    R14,ZDTUP\n         ST    R14,ZDRBTUP\n*\n         MVC   ZINTU1V,=Y(DINDDNAM) DDNAME REFERENCE\n         MVC   ZINTU1N,=Y(1)       NUMBER OF ENTRIES\n         MVC   ZINTU1L,=Y(8)       LENGTH OF EACH ENTRY\n         MVC   ZINTU1E(8),0(R2)\n*\n         MVC   ZINTU2V,=Y(DINRTDSN) RETURN DSNAME\n         MVC   ZINTU2N,=Y(1)       NUMBER OF ENTRIES\n         MVC   ZINTU2L,=Y(44)      LENGTH OF EACH ENTRY\n         MVI   ZINTU2E,C' '        INITIALIZE ENTRY\n         MVC   ZINTU2E+1(L'ZINTU2E-1),ZINTU2E\n*\n         MVC   ZINTU3V,=Y(DINRTTYP) RETURN DATA SET TYPE\n         MVC   ZINTU3N,=Y(1)       NUMBER OF ENTRIES\n         MVC   ZINTU3L,=Y(1)       LENGTH OF EACH ENTRY\n         MVI   ZINTU3E,0           INITIALIZE ENTRY\n*\n         MVC   ZINTU4V,=Y(DINRTORG) RETURN DATA SET ORGANIZATION\n         MVC   ZINTU4N,=Y(1)       NUMBER OF ENTRIES\n         MVC   ZINTU4L,=Y(2)       LENGTH OF EACH ENTRY\n         MVC   ZINTU4E,=Y(0)       INITIALIZE ENTRY\n*\n         BAL   R14,D0000\n*\n         POPREG R14                RESTORE RETURN PTR\n         LTR   R15,R15             SET CONDITION CODE\n         BR    R14                 RETURN\n*\n         TITLE ' - D2000 - OBTAIN MEMBER NAME '\n*---------------------------------------------------------------------*\n*        D2000 - OBTAIN MEMBER NAME                                   *\n*---------------------------------------------------------------------*\n*\nD2000    PUSHREG R14               SAVE RETURN PTR\n*\n         LA    R14,ZINTU1          ALLOCATION TEXT UNIT 1\n         LA    R15,ZINTU5          ALLOCATION TEXT UNIT 2\n         O     R15,=A(X'80000000') MARK END OF LIST\n         STM   R14,R15,ZDTUP       STORE LIST OF POINTERS\n*\n         XC    ZDRB,ZDRB\n         MVI   ZDRBL,20\n         MVI   ZDRBVERB,S99VRBIN\n         LA    R14,ZDTUP\n         ST    R14,ZDRBTUP\n*\n         MVC   ZINTU1V,=Y(DINDDNAM) DDNAME REFERENCE\n         MVC   ZINTU1N,=Y(1)       NUMBER OF ENTRIES\n         MVC   ZINTU1L,=Y(8)       LENGTH OF EACH ENTRY\n         MVC   ZINTU1E(8),0(R2)\n*\n         MVC   ZINTU5V,=Y(DINRTMEM) RETURN MEMBER NAME\n         MVC   ZINTU5N,=Y(1)       NUMBER OF ENTRIES\n         MVC   ZINTU5L,=Y(8)       LENGTH OF EACH ENTRY\n         MVI   ZINTU5E,C' '        INITIALIZE ENTRY\n         MVC   ZINTU5E+1(L'ZINTU5E-1),ZINTU5E\n*\n         BAL   R14,D0000\n*\n         POPREG R14                RESTORE RETURN PTR\n         LTR   R15,R15             SET CONDITION CODE\n         BR    R14                 RETURN\n*\n         TITLE ' - P0000 - PROCESS STRINGS '\n*---------------------------------------------------------------------*\n*        P0000 - PROCESS STRINGS '                                    *\n*---------------------------------------------------------------------*\n*\nP0000    PUSHREG R14               SAVE RETURN PTR\n*\n*        OBTAIN SYSUT1 DATA SET INFORMATION\n*\n         LA    R2,=CL8'SYSUT1'     DDNAME FOR INFO RETRIEVAL\n         BAL   R14,D1000           OBTAIN DATA SET INFORMATION\n         BZ    P0100               BRIF SUCCESSFUL\n*\n         LA    R0,37               MESSAGE LENGTH\n         LA    R1,=C'PSU0032I SYSUT1 DD STATEMENT MISSING.'\n         BAL   R14,W0000           WRITE MESSAGE TO JOB LOG\n         ABEND 2\n*\nP0100    MVC   ZSYSUT1O,ZINTU4E    SAVE SYSUT1 ORGANIZATION\n         MVC   ZSYSUT1T,ZINTU3E    SAVE SYSUT1 DATA SET TYPE\n         MVC   ZSYSUT1D,ZINTU2E    SAVE SYSUT1 DATA SET NAME\n         MVI   ZSYSUT1M,C' '       CLEAR MEMBER NAME\n         MVC   ZSYSUT1M+1(L'ZSYSUT1M-1),ZSYSUT1M\n*\n         CLC   ZSYSUT1O,=Y(DOPO)   PARTITIONED DATA SET ?\n         BE    P0150               YES, DO PO\n         CLC   ZSYSUT1O,=Y(DOPOU)  PARTITIONED DATA SET ?\n         BNE   P0200               NO, MUST BE SEQUENTIAL\n*\nP0150    LA    R2,=CL8'SYSUT1'     DDNAME FOR INFO RETRIEVAL\n         BAL   R14,D2000           OBTAIN MEMBER NAME\n         BNZ   P0200               BRIF NO MEMBER FOUND\n*\n         MVC   ZSYSUT1M,ZINTU5E\n         CLI   ZSYSUT1M,C' '\n         BE    P0200\n*\n         MVC   ZSYSUT1O,=Y(DOPS)   TREAT AS SEQUENTIAL DATA SET\n*\n*        OBTAIN SYSUT2 DATA SET INFORMATION\n*\nP0200    LA    R2,=CL8'SYSUT2'     DDNAME FOR INFO RETRIEVAL\n         BAL   R14,D1000           OBTAIN DATA SET INFORMATION\n         BZ    P0250               BRIF SUCCESSFUL\n*\n         LA    R0,37               MESSAGE LENGTH\n         LA    R1,=C'PSU0032I SYSUT2 DD STATEMENT MISSING.'\n         BAL   R14,W0000           WRITE MESSAGE TO JOB LOG\n         ABEND 2\n*\nP0250    MVC   ZSYSUT2O,ZINTU4E    SAVE SYSUT2 ORGANIZATION\n         MVC   ZSYSUT2T,ZINTU3E    SAVE SYSUT2 DATA SET TYPE\n         MVC   ZSYSUT2D,ZINTU2E    SAVE SYSUT2 DATA SET NAME\n         MVI   ZSYSUT2M,C' '       CLEAR MEMBER NAME\n         MVC   ZSYSUT2M+1(L'ZSYSUT2M-1),ZSYSUT2M\n*\n         CLC   ZSYSUT2O,=Y(DOPO)   PARTITIONED DATA SET ?\n         BE    P0300               YES, DO PO\n         CLC   ZSYSUT2O,=Y(DOPOU)  PARTITIONED DATA SET ?\n         BNE   P0350               NO, MUST BE SEQUENTIAL\n*\nP0300    LA    R2,=CL8'SYSUT2'     DDNAME FOR INFO RETRIEVAL\n         BAL   R14,D2000           OBTAIN MEMBER NAME\n         BNZ   P0350               BRIF NO MEMBER FOUND\n*\n         MVC   ZSYSUT2M,ZINTU5E\n         CLI   ZSYSUT2M,C' '\n         BE    P0350\n*\n         MVC   ZSYSUT2O,=Y(DOPS)   TREAT AS SEQUENTIAL DATA SET\n*\n*        SET IDENTICAL DATA SET FLAG\n*\nP0350    NI    ZFLAG1,255-ZF1IDENT RESET FLAG - DATASETS ARE DIFFERENT\n         CLC   ZSYSUT1D,ZSYSUT2D   ARE DSNAMES THE SAME ?\n         BNE   P0400               NO, THEN THEY'RE DIFFERENT\n         CLC   ZSYSUT1M,ZSYSUT2M   ARE MEMBER NAMES THE SAME ?\n         BNE   P0400               NO, THEN THEY'RE DIFFERENT\n         OI    ZFLAG1,ZF1IDENT     OTHERWISE, SET IDENTICAL FLAG\n*\n*        PROCESS DATA SET BASED ON ORGANIZATION\n*\nP0400    LA    R15,PTABLE          START OF TABLE\n         LA    R0,L'PTABLE         LENGTH OF EACH ENTRY\n         LA    R1,PTBLEND          LAST BYTE OF LAST ENTRY\n*\n         USING PTABLE,R15\n*\nP0450    CLC   PTBLORG,ZDSORGS     FOUND COMPATIBLE DSORG'S ?\n         BE    P0500               YES, GO PROCESS DATA\n         BXLE  R15,R0,P0450        SCAN ENTIRE TABLE\n*\nP0500    L     R15,PTBLRTN         GET ROUTINE ADDRESS\n         BALR  R14,R15             GO TO ROUTINE\n*\n         DROP  R15\n*\nP0990    POPREG R14                RESTORE RETURN PTR\n         BR    R14                 RETURN\n*\n         TITLE ' - P1000 - PROCESS PO - PO DATA SETS '\n*---------------------------------------------------------------------*\n*        P1000 - PARTITIONED TO PARTITIONED                           *\n*---------------------------------------------------------------------*\n*\nP1000    PUSHREG R14               SAVE RETURN PTR\n*\n*      * CURRENTLY UNIMPLEMENTED *\n*\n*        ADD CODE HERE TO APPLY STRINGS TO EVERY MEMBER.\n*\n*        SYSUT1 AND SYSUT2 COULD BE THE SAME DATA SET OR\n*        DIFFERENT  DATA SETS.  SEE ROUTINE P3000 FOR AN\n*        EXAMPLE OF HOW TO HANDLE UPDATE-IN-PLACE.\n*\n*\n         LA    R0,44               MESSAGE LENGTH\n         LA    R1,=C'PSU0033I SYSUT1/PO SYSUT2/PO NOT IMPLEMENTED'\n         BAL   R14,W0000           WRITE MESSAGE TO JOB LOG\n         ABEND 3                   ABEND UNTIL IMPLEMENTED\n*\n         POPREG R14                RESTORE RETURN PTR\n         BR    R14                 RETURN\n*\n         TITLE ' - P2000 - PROCESS PO - PS DATA SETS '\n*---------------------------------------------------------------------*\n*        P2000 - PARTITIONED TO SEQUENTIAL                            *\n*---------------------------------------------------------------------*\n*\nP2000    PUSHREG R14               SAVE RETURN PTR\n*\n*      * CURRENTLY UNIMPLEMENTED *\n*\n*        ADD CODE HERE TO APPLY STRINGS TO EVERY MEMBER.\n*\n*        SINCE SYSUT2 IS SEQUENTIAL, ALL MEMBERS MUST BE\n*        CONCATENATED ON OUTPUT.\n*\n         LA    R0,44               MESSAGE LENGTH\n         LA    R1,=C'PSU0033I SYSUT1/PO SYSUT2/PS NOT IMPLEMENTED'\n         BAL   R14,W0000           WRITE MESSAGE TO JOB LOG\n         ABEND 3                   ABEND UNTIL IMPLEMENTED\n*\n         POPREG R14                RESTORE RETURN PTR\n         BR    R14                 RETURN\n*\n         TITLE ' - P3000 - PROCESS PS - PS DATA SETS '\n*---------------------------------------------------------------------*\n*        P3000 - SEQUENTIAL TO SEQUENTIAL                             *\n*---------------------------------------------------------------------*\n*\nP3000    PUSHREG R14               SAVE RETURN PTR\n*\n*        HANDLE THE CASE WHERE BOTH SYSUT1 AND SYSUT2 HAVE DSORG=PS\n*        OR ARE TREATED AS DSORG=PS BECAUSE A MEMBER NAME IS GIVEN.\n*\n*        SYSUT1 AND SYSUT2 COULD BOTH POINT TO THE IDENTICAL DATA\n*        SET OR MEMBER. IF SO, RECORDS ARE UPDATED IN PLACE.\n*\n*        OPEN SYSUT1 FOR INPUT (OR UPDATE-IN-PLACE)\n*\n         LA    R2,ZDCBPS1          ESTABLISH DCB ADDRESSABILITY\n         USING IHADCB,R2\n*\n         MVC   ZDCBPS1(DCBPSL),DCBPS      INITIALIZE DCB\n         MVC   DCBDDNAM,=CL8'SYSUT1'      DDNAME=SYSUT1\n         LA    R0,P3980                   SYSIN END-OF-DATA ROUTINE\n         STCM  R0,B'0111',DCBEODA         EODAD=P3980\n*\n         TM    ZFLAG1,ZF1IDENT     ARE SYSUT1 AND SYSUT2 IDENTICAL ?\n         BNO   P3100               NO, OPEN FOR INPUT PROCESSING\n*\n         MVC   ZOPEN(OPENL),OPEN   YES, OPEN SYSUT1 FOR UPDATE\n         OPEN  (ZDCBPS1,(UPDAT)),MF=(E,ZOPEN)\n         B     P3150\n*\nP3100    MVC   ZOPEN(OPENL),OPEN\n         OPEN  (ZDCBPS1,(INPUT)),MF=(E,ZOPEN)\n*\n         DROP  R2\n*\n*        OPEN SYSUT2 FOR OUTPUT (IF SYSUT1 IS OPEN FOR INPUT)\n*\n         LA    R2,ZDCBPS2          ESTABLISH DCB ADDRESSABILITY\n         USING IHADCB,R2\n*\n         MVC   ZDCBPS2(DCBPSL),DCBPS      INITIALIZE DCB\n         MVC   DCBDDNAM,=CL8'SYSUT2'      DDNAME=SYSUT1\n*\n         MVC   ZOPEN(OPENL),OPEN\n         OPEN  (ZDCBPS2,(OUTPUT)),MF=(E,ZOPEN)\n*\n         DROP  R2\n*\n*        PROCESS THE REPLACEMENT STRINGS AGAINST SYSUT1\n*\nP3150    GET   ZDCBPS1             GET A RECORD\n*\n         BAL   R14,R0000           REPLACE STRINGS IN RECORD\n*\n         TM    ZFLAG1,ZF1IDENT     SYSSUT1 AND SYSUT2 IDENTICAL ?\n         BNO   P3200               NO, THEN WRITE NEW RECORD\n         PUTX  ZDCBPS1             REPLACE OLD RECORD\n         B     P3150               PROCESS THE ENTIRE DATA SET\n*\nP3200    LR    R0,R1               COPY RECORD PTR\n         PUT   ZDCBPS2,(0)         OUTPUT NEW RECORD\n         B     P3150               PROCESS THE ENTIRE DATA SET\n*\n*        CLOSE THE DATA SETS AND RETURN\n*\nP3980    MVC   ZCLOSE(CLOSEL),CLOSE\n         CLOSE (ZDCBPS1),MF=(E,ZCLOSE)\n         TM    ZFLAG1,ZF1IDENT     SYSUT1 AND SYSUT2 IDENTICAL ?\n         BO    P3990               YES, SKIP CLOSE\n         CLOSE (ZDCBPS2),MF=(E,ZCLOSE)\n*\nP3990    POPREG R14                RESTORE RETURN PTR\n         BR    R14                 RETURN\n*\n         TITLE ' - P4000 - INCOMPATIBLE DSORGS '\n*---------------------------------------------------------------------*\n*        P4000  - INCOMPATIBLE DSORGS                                 *\n*---------------------------------------------------------------------*\n*\nP4000    PUSHREG R14               SAVE RETURN PTR\n*\n*      * UNIMPLEMETABLE *\n*\n         LA    R0,28\n         LA    R1,=C'SYSUT2 REQUIRES MEMBER NAME.'\n         BAL   R14,W0000\n*\n         LA    R0,44               MESSAGE LENGTH\n         LA    R1,=C'PSU0033I SYSUT1 OR SYSUT2 DSORG INCOMPATIBLE'\n         BAL   R14,W0000           WRITE MESSAGE TO JOB LOG\n         ABEND 3                   ABEND ALWAYS\n*\n         POPREG R14                RESTORE RETURN PTR\n         BR    R14                 RETURN\n*\n         TITLE ' - R0000 - REPLACE STRINGS IN RECORD '\n*---------------------------------------------------------------------*\n*        R0000 - REPLACE STRINGS IN RECORD                            *\n*---------------------------------------------------------------------*\n*\n*        THIS ROUTINE OBEYS JCL RULES OF STRING CONCATENATION.\n*        THAT IS, A SEARCH STRING THAT BEGINS WITH & ENDS AT\n*        EITHER A NON-ALPHANUMERIC OR . CHARACTER. IF IT ENDS\n*        WITH A . THEN THE . IS REMOVED.\n*\n*        FOR EXAMPLE IF THE PARM IS CODED AS ('&&PREF=PSCOTT')\n*        (NOTE THE && IN JCL WILL BE SEEN AS A SINGLE & HERE)\n*        THEN &PREF..MY.CNTL WILL BE REPLACED BY PSCOTT.MY.CNTL\n*        BUT &PREFIX..MY.CNTL WILL NOT MATCH AND NO REPLACEMENT\n*        WILL BE MADE.\n*\n*        SEARCH STRINGS THAT DO NOT BEGIN WITH & HAVE NO SUCH\n*        RULES APPPLIED, SO THAT IF THE PARM IS ('PREF=PSCOTT')\n*        THEN &PREF..MY.CNTL WITLL BE BECOME &PSCOTT..MY.CNTL\n*        AND &PREFIX..MY.CNTL WILL BECOME &PSCOTTIX..MY.CNTL\n*\nR0000    PUSHREG R14               SAVE RETURN PTR\n         PUSHREG R1                SAVE RECORD PTR\n*\n         MVI   ZWORKREC,C' '       CLEAR WORK RECORD\n         MVC   ZWORKREC+1(L'ZWORKREC-1),ZWORKREC\n         MVC   ZWORKREC(71),0(R1)       COPY DATA RECORD\n*\n         LA    R6,ZSTRINGS         START OF PTRS\n         LA    R4,STRLEN           LENGTH OF EACH ENTRY\n         L     R5,ZSTREPTR         LAST BYTE OF LAST ENTRY\n*\nR0100    L     R7,STR1PTR          PTR TO STRING TO LOCATE\n         L     R8,STR1LEN          PTR TO STRING LENGTH\n         LTR   R7,R7               NULL STRING PTR ?\n         BZ    R0900               YES, SKIP STRING\n         LTR   R8,R8               LENGTH ZERO ?\n         BZ    R0900               YES, SKIP STRING\n*\n         BCTR  R8,0                GET ZERO RELATIVE LENGTH\n         LA    R1,ZWORKREC         POINT AT RECORD\n         LA    R14,1               SCAN A BYTE AT A TIME\n         LA    R15,ZWORKREC+L'ZWORKREC-1  LAST BYTE IN RECORD TO SCAN\n         SR    R15,R8              ADJUST FOR LENGTH OF STRING\n*\nR0150    CLC   0(0,R1),0(R7)       MODEL COMPARE INSTRUCTION\n         EX    R8,*-6              HAS STRING BEEN LOCATED ?\n         BNE   R0300               NO, KEEP LOOKING\n*\n         CLI   0(R7),C'&&'         FIRST CHAR AN AMPERSAND ?\n         BNE   R0350               NO, THEN REPLACE STRING\n*\n         SR    R2,R2               CLEAR REGISTER\n         IC    R2,1(R8,R1)         GET CHARACTER AFTER STRING\n         LA    R2,TCHARTBL(R2)     INDEX INTO TABLE\n*\n         CLI   0(R2),C'.'          CONCATENATION CHARACTER ?\n         BNE   R0250               NO, THEN KEEP LOOKING FOR STRING\n         LA    R8,1(,R8)           REMOVE THE PERIOD WITH THE STRING\n         B     R0350               REMOVE STRING\n*\nR0250    CLI   0(R2),0             STRING TERMINATION CHARACTER ?\n         BE    R0350               YES, REPLACE THE STRING\n*\nR0300    BXLE  R1,R14,R0150        SCAN ENTIRE RECORD\n         B     R0900               STRING WAS NOT FOUND\n*\nR0350    LR    R2,R1               SAVE STRING PTR\n         LR    R0,R2                    DESTINATION PTR (STRING)\n         LA    R1,ZWORKREC+L'ZWORKREC   COMPUTE THE\n         SR    R1,R0                    DESTINATION LENGTH\n         LA    R14,1(R8,R2)             SOURCE PTR (CHAR AFTER STRING)\n         LA    R15,ZWORKREC+L'ZWORKREC  COMPUTE THE\n         SR    R15,R14                  SOURCE LENGTH\n         ICM   R15,B'1000',=C' '   SPACE FILL\n         MVCL  R0,R14              SHIFT THE STRING OVER\n         LR    R1,R2               RESTORE STRING PTR\n*\n         L     R7,STR2PTR          PTR TO REPLACEMENT STRING\n         L     R8,STR2LEN          LENGTH OF REPLACEMENT STRING\n         LTR   R7,R7               NULL STRING PTR ?\n         BZ    R0900               YES, NOTHING TO REPLACE\n         LTR   R8,R8               LENGTH ZERO ?\n         BZ    R0900               YES, NOTHING TO REPLACE\n*\n         LA    R2,ZWORKREC+L'ZWORKREC-1  PTR TO TARGET\n         LR    R15,R2              COMPUTE THE\n         SR    R15,R8                 PTR TO SOURCE\n         LA    R14,1(,R15)\n         SR    R14,R1\n*\nR0400    MVC   0(1,R2),0(R15)      MOVE (PTR-N) TO (PTR)\n         BCTR  R2,0\n         BCTR  R15,0\n         BCT   R14,R0400           FINISH WITH START OF FIELD\n*\n         BCTR  R8,0\n         MVC   0(0,R1),0(R7)\n         EX    R8,*-6\n*\nR0900    BXLE  R6,R4,R0100         REPLACE ALL STRINGS IN RECORD\n*\n         POPREG R1                 RESTORE RECORD PTR\n         MVC   0(71,R1),ZWORKREC   REPLACE RECORD\n*\n         POPREG R14                RESTORE RETURN PTR\n         BR    R14                 RETURN\n*\n         TITLE ' - W0000 - WRITE TO LOG '\n*---------------------------------------------------------------------*\n*        W0000 - WRITE TO LOG                                         *\n*---------------------------------------------------------------------*\n*\nW0000    PUSHREG R14                   SAVE RETURN PTR\n*\n         MVC   ZWTO,WTO                INITIALIZE WTO PARAMETER LIST\n         MVI   ZMSG,C' '               CLEAR MESSAGE BUFFER\n         MVC   ZMSG+1(L'ZMSG-1),ZMSG      TO ALL SPACES\n*\n         LR    R15,R0                  GET MESSAGE LENGTH\n         CH    R15,=Y(L'ZMSG)          TOO LARGE FOR MESSAGE BUFFER ?\n         BNH   W0010                   NO, MESSAGE WILL FIT\n         LH    R15,=Y(L'ZMSG)          TRUNCATE MESSAGE TO BUFFER SIZE\nW0010    BCTR  R15,0                   MAKE LENGTH ZERO RELATIVE\n         MVC   ZMSG(0),0(R1)           INSTRUCTION TEMPLATE\n         EX    R15,*-6                 MOVE MESSAGE TO WTO BUFFER\n*\n         WTO   MF=(E,ZWTO)             WRITE TO JOB LOG\n*\n         POPREG R14                RESTORE RETURN PTR\n         BR    R14                 RETURN\n*\n*        DUMP THE REPLACEMENT STRINGS TO THE JOB LOG\n*\nW0100    PUSHREG R14\n*\n         LA    R6,ZSTRINGS         START OF PTRS\n         LA    R4,STRLEN           LENGTH OF EACH ENTRY\n         L     R5,ZSTREPTR         LAST BYTE OF LAST ENTRY\n*\nW0120    MVC   ZWTO,WTO                INITIALIZE WTO PARAMETER LIST\n         MVI   ZMSG,C' '               CLEAR MESSAGE BUFFER\n         MVC   ZMSG+1(L'ZMSG-1),ZMSG      TO ALL SPACES\n         LA    R1,ZMSG\n*\n         USING STRINGS,R6\n         USING ZMSG,R1\n*\n         MVC   ZMSG(8),=C'PSU0034I'    MESSAGE PREFIX\n         LA    R1,9(0,R1)              NEXT AVAILABLE SLOT\n*\n         MVC   ZMSG(6),=C'(NULL)'      DEFAULT SEARCH STRING\n         L     R7,STR1PTR              SEARCH STRING PTR\n         L     R8,STR1LEN              SEARCH STRING LENGTH\n         LTR   R7,R7                   NULL SEARCH STRING PTR ?\n         BZ    W0130                   YES, MOVE ON\n         LTR   R8,R8                   NULL SEARCH STRING LENGTH ?\n         BZ    W0130                   YES, MOVE ON\n         MVC   ZMSG(6),=CL6' '         CLEAR '(NULL)'\n         BCTR  R8,0                    MAKE ZERO RELATIVE LENGTH\n         MVC   ZMSG(0),0(R7)           INSTRUCTION TEMPLATE\n         EX    R8,*-6                  COPY SEARCH STRING TO BUFFER\n         LA    R1,1(R8,R1)             NEXT AVAILABLE SLOT\n*\nW0130    MVI   ZMSG,C'='               SET DEMARCATION LITERAL\n         LA    R1,1(0,R1)              NEXT AVAILABLE SLOT\n*\n         MVC   ZMSG(6),=C'(NULL)'      DEFAULT REPLACEMENT STRING\n         L     R7,STR2PTR              REPLACEMENT STRING PTR\n         L     R8,STR2LEN              REPLACEMENT STRING LEN\n         LTR   R7,R7                   NULL REPLACEMENT STRING PTR ?\n         BZ    W0150                   YES, MOVE ON\n         LTR   R8,R8                   NULL REPLACEMENT STRING LENGTH ?\n         BZ    W0140                   YES, MOVE ON\n         MVC   ZMSG(6),=CL6' '         CLEAR '(NULL)'\n         BCTR  R8,0                    MAKE ZERO RELATIVE LENGTH\n         MVC   ZMSG(0),0(R7)           INSTRUCTION TEMPLATE\n         EX    R8,*-6                  COPY REPLACEMENT STRNG TO BUFFER\n         LA    R1,1(R8,R1)             NEXT AVAILABLE SLOT\n         DROP  R1\n*\nW0140    WTO   MF=(E,ZWTO)\n*\nW0150    BXLE  R6,R4,W0120         SCAN ENTIRE OPERATOR TABLE\n*\n         POPREG R14                RESET ALL BITS\n         BR    R14\n*\n         TITLE ' - TABLES '\n*---------------------------------------------------------------------*\n*        DATA SET PROCESSING TABLE                                    *\n*---------------------------------------------------------------------*\n         DS    0F                  ALIGN TABLE ON FULLWORD BOUNDARY\nPTABLE   DS    0CL8                DATA SET PROCESSING TABLE\nPTBLORG  DS    A                   . ORGANIZATION (SYSUT1,SYSUT2)\nPTBLRTN  DS                 A      . ROUTINE\n         ORG   PTABLE\n         DC    Y(DOPO,DOPO),A(P1000)\n         DC    Y(DOPO,DOPS),A(P2000)\n         DC    Y(DOPS,DOPS),A(P3000)\nPTBLEND  EQU *-1\n         DC    Y(-001,-001),A(P4000)\n*\n*---------------------------------------------------------------------*\n*        TABLE OF STRING TERMINATION CHARACTERS                       *\n*---------------------------------------------------------------------*\n*\nTCHARTBL DC    256X'00'\n         ORG   TCHARTBL+C'A'\n         DC    C'ABCDEFGHI'\n         ORG   TCHARTBL+C'J'\n         DC    C'JKLMNOPQR'\n         ORG   TCHARTBL+C'S'\n         DC    C'STUVWXYZ'\n         ORG   TCHARTBL+C'0'\n         DC    C'0123456789'\n         ORG   TCHARTBL+C'Z'\n         DC    C'Z'\n         ORG   TCHARTBL+C'#'\n         DC    C'#'\n         ORG   TCHARTBL+C'$'\n         DC    C'4'\n         ORG   TCHARTBL+C'.'\n         DC    C'.'\n         ORG   ,\n*\n*---------------------------------------------------------------------*\n*        STRING TABLE                                                 *\n*---------------------------------------------------------------------*\n*\nSTRINGS  DSECT ,                   MAP STRING TABLE\nSTR1PTR  DS    F                   . STRING 1 PTR\nSTR1LEN  DS    F                   . STRING 1 LENGTH\nSTR2PTR  DS    F                   . STRING 2 PTR\nSTR2LEN  DS    F                   . STRING 2 LENGTH\nSTRBFR   DS    CL100               . STRING BUFFER\nSTRLEN   EQU   *-STRINGS           LENGTH OF EACH ENTRY\nSTRNUM   EQU   500                 TOTAL NUMBER OF ENTRIES\nPSU003   CSECT ,                   RESTORE CSECT\n*\n         TITLE ' - CONSTANTS AND TEMPLATES'\n*---------------------------------------------------------------------*\n*        CONSTANTS AND TEMPLATES                                      *\n*---------------------------------------------------------------------*\n*\nERROR4   EQU   4\nERROR8   EQU   8\nERROR12  EQU   12\n*\nWTO      WTO   '4....10...15...20...25...30...35...40...45...50...55', C\n               DESC=6,ROUTCDE=11,MF=L\nWTOL     EQU   *-WTO\n*\n         DS    0F\nOPEN     OPEN  (*),MF=L\nOPENL    EQU   *-OPEN\n*\nDCBPS    DCB   DDNAME=Z,DSORG=PS,MACRF=(GL,PM),RECFM=FB,LRECL=80\nDCBPSL   EQU   *-DCBPS\n*\nDCBPO    DCB   DDNAME=Z,DSORG=PO,MACRF=(R,W),RECFM=FB,LRECL=80\nDCBPOL   EQU   *-DCBPO\n*\n         DS    0F\nCLOSE    CLOSE (*),MF=L\nCLOSEL   EQU   *-CLOSE\n*\n         TITLE ' - LOCAL VARIABLE STORAGE '\n*---------------------------------------------------------------------*\n*        LOCAL VARIABLE STORAGE                                       *\n*---------------------------------------------------------------------*\n*\nZVARS    DSECT ,\nZSAVEALL DS    18F                 SAVE AREA\nZRC      DS    F                   RETURN CODE\n*\n*        FLAG BYTES\n*\nZFLAG1   DS    B                   FLAG BYTE 1\nZF1IDENT EQU   B'10000000'         . SYSUT1 & SYSUT2 ARE IDENTICAL\n*        EQU   B'01000000'         . UNUSED\n*        EQU   B'00100000'         . UNUSED\n*        EQU   B'00010000'         . UNUSED\n*        EQU   B'00001000'         . UNUSED\n*        EQU   B'00000100'         . UNUSED\n*        EQU   B'00000010'         . UNUSED\n*        EQU   B'00000001'         . UNUSED\n*\n*        I/O WORK AREAS\n*\nZDIRREC  DS    CL256\nZDATAREC DS    CL80\nZWORKREC DS    CL(L'ZDATAREC*2)\n*\n*        DATA SET VARIABLE AND CONTROL BLOCKS\n*\n*        WTO   MF=L\nZWTO     DS    XL(WTOL)\nZMSG     EQU   ZWTO+4,52\n*\nZOPEN    DS    0F,(OPENL)X         OPEN  PARAMETER LIST\nZCLOSE   DS    0F,(CLOSEL)X        CLOSE PARAMETER LIST\n*\nZDCBPS1  DS    0D,(DCBPSL)X        SYSUT1 SEQUENTIAL  DATA SET DCB\nZDCBPO1  DS    0D,(DCBPOL)X        SYSUT1 PARTITIONED DATA SET DCB\nZJFCB1   DS    0F,(JFCBLGTH)X      SYSUT1 JFCB\n*\nZDCBPS2  DS    0D,(DCBPSL)X        SYSUT2 SEQUENTIAL  DATA SET DCB\nZDCBPO2  DS    0D,(DCBPOL)X        SYSUT2 PARTITIONED DATA SET DCB\nZJFCB2   DS    0F,(JFCBLGTH)X      SYSUT2 JFCB\n*\nZEXLST1  DS    3F                  SYSUT1 EXIT LIST\nZEXLST2  DS    3F                  SYSUT2 EXIT LIST\n*\nZDSNAMES DS    0CL88\nZSYSUT1D DS    CL44                SYSUT1 DATA SET NAME\nZSYSUT2D DS    CL44                SYSUT2 DATA SET NAME\n*\nZMEMBERS DS    0CL16\nZSYSUT1M DS    CL8                 SYSUT1 MEMBER NAME\nZSYSUT2M DS    CL8                 SYSUT2 MEMBER NAME\n*\nZDSORGS  DS    0AL4\nZSYSUT1O DS    Y                   SYSUT1 DATA SET ORGANIZATION\nZSYSUT2O DS    Y                   SYSUT2 DATA SET ORGANIZATION\n*\nZDSTYPES DS    0AL2\nZSYSUT1T DS    X                   SYSUT1 DATA SET TYPE\nZSYSUT2T DS    X                   SYSUT2 DATA SET TYPE\n*\n*        DYNAMIC ALLOCATION PARAMETER LISTS\n*\nZDRBP    DS    A(ZDRB)             REQUEST BLOCK PTR\n*\nZDRB     DS    0CL20               REQUEST BLOCK\nZDRBL    DS    AL1(20)             . LENGTH OF RB\nZDRBVERB DS    AL1(S99VRBAL)       . VERB CODE (ALLOCATION)\nZDRBFLAG DS    AL2(0)              . FLAGS\nZDRBECD  DS    AL2(0)              . ERROR CODE FIELDS\nZDRBRCD  DS    AL2(0)              . REASON CODE FIELDS\nZDRBTUP  DS    A(ZDTUP)            . ADR OF TEXT UNIT PTRS\n         DS    A(0)                . RESERVED\n         DS    AL4(0)              . FLAGS FOR AUTHORIZED FUNCTIONS\n*\nZDTUP    DS    8A                  TEXT UNIT POINTER LIST\n*\nZINTU1   DS    0CL14               TEXT UNIT 1\nZINTU1V  DS    AL2(DINDDNAM)       . DDNAME REFERENCE\nZINTU1N  DS    AL2(1)              . NUMBER OF ENTRIES\nZINTU1L  DS    AL2(8)              . LENGTH OF ENTRY\nZINTU1E  DS    CL8' '              . ENTRY PARAMETER\n*\nZINTU2   DS    0CL50               TEXT UNIT 2\nZINTU2V  DS    AL2(DINRTDSN)       . RETURN DATA SET NAME\nZINTU2N  DS    AL2(1)              . NUMBER OF ENTRIES\nZINTU2L  DS    AL2(44)             . LENGTH OF ENTRY\nZINTU2E  DS    CL44                . ENTRY PARAMETER\n*\nZINTU3   DS    0CL7                TEXT UNIT 3\nZINTU3V  DS    AL2(DINRTTYP)       . RETURN DATA SET TYPE\nZINTU3N  DS    AL2(1)              . NUMBER OF ENTRIES\nZINTU3L  DS    AL2(1)              . LENGTH OF ENTRY\nZINTU3E  DS    XL1'00'             . ENTRY PARAMETER\nDTDUMMY  EQU   X'80'\nDTTERM   EQU   X'40'\nDTSYSIN  EQU   X'20'\nDTSYSOUT EQU   X'10'\nDTFILE   EQU   X'00'\n*\nZINTU4   DS    0CL8                TEXT UNIT 4\nZINTU4V  DS    AL2(DINRTORG)       . RETURN DATA SET ORGANIZATION\nZINTU4N  DS    AL2(1)              . NUMBER OF ENTRIES\nZINTU4L  DS    AL2(2)              . LENGTH OF ENTRY\nZINTU4E  DS    AL2(0)              . ENTRY PARAMETER\nDOUNK    EQU   X'0000'\nDOVSAM   EQU   X'0008'\nDOPO     EQU   X'0200'\nDOPOU    EQU   X'0300'\nDODA     EQU   X'2000'\nDODAU    EQU   X'2100'\nDOPS     EQU   X'4000'\nDOPSU    EQU   X'4100'\n*\nZINTU5   DS    0CL14               TEXT UNIT 5\nZINTU5V  DS    AL2(DINRTMEM)       . RETURN MEMBER NAME\nZINTU5N  DS    AL2(1)              . NUMBER OF ENTRIES\nZINTU5L  DS    AL2(8)              . LENGTH OF ENTRY\nZINTU5E  DS    CL8' '              . ENTRY PARAMETER\n*\n*        STRING STORAGE\n*\nZSTREPTR DS    F\nZSEPCHAR DS    C\nZSTRINGS DS    (STRNUM*STRLEN)X    STORAGE FOR STRING PTRS AND LENGTHS\n*\nZVARL    EQU   *-ZVARS\n*\n         PUSH  PRINT\n         PRINT NOGEN\n*\n         DCBD  DSORG=PS\n         IEFZB4D0 ,\n         IEFZB4D2 ,\n         IEFJFCBN ,\n         IKJDAP08 ,\n*\n         POP   PRINT\n*\n         END   PSU003\n./ ADD NAME=PSU004   0100-03194-03194-1243-00345-00345-00000-PASCOTT\n* COPYRIGHT (C) PAUL A. SCOTT, 1989. ALL RIGHTS RESERVED.\n* ANY USE OF THIS CODE MUST RETAIN THE ABOVE COPYRIGHT NOTICE\n*\n* MODULE     PSU004\n* AUTHOR     P. SCOTT\n*\n* PSU004 IS RENT,REUS\n*\n* EXAMPLE:\n*    //STEP1   EXEC PGM=PSU004,PARM=('1989')\n*    //SYSOUT  DD  SYSOUT=*\n*\nPSU004   PENTER MAIN,VARS=(WRKDSECT,WRKLEN),STACK=1\n*\n*---------------------------------------------------------------------*\n*        MAINLINE                                                     *\n*---------------------------------------------------------------------*\n*\n*        GET FULL FOUR DIGIT YEAR IN CHARACTER FORMAT\n*        ACCOUNTING FOR CENTURY CHANGES.  USE CURRENT\n*        YEAR UNLESS PARM SPECIFIES A YEAR.\n*\n         PUSHREG R1                SAVE PARM ADDRESS\n*\n         TIME  DEC\n*\n         LR    R15,R1              COPY DATE\n         SRL   R15,24              ISOLATE CENTURY\n         SLL   R15,4               MAKE ROOM FOR SIGN\n         LA    R15,12(,R15)        INSERT SIGN\n         ST    R15,WRKDWORD+4      SAVE IN DOUBLEWORD\n         CVB   R15,WRKDWORD        MAKE BINARY VALUE\n         MH    R15,=H'100'         CONVERT TO YEARS\n         AH    R15,=H'1900'        ADD IN BASE CENTURY\n*\n         SLL   R1,8                STRIP OFF CENTURY\n         SRL   R1,24               STRIP OFF DAYS\n         SLL   R1,4                MAKE ROOM FOR SIGN\n         LA    R1,12(,R1)          INSERT SIGN\n         ST    R1,WRKDWORD+4       SAVE IN DOUBLEWORD\n         CVB   R1,WRKDWORD         MAKE BINARY VALUE\n*\n         AR    R1,R15              INCLUDE CENTURIES\n         STH   R1,WRKYEAR          SAVE YEAR\n*\n         POPREG R1                 RESTORE PARM ADDRESS\n*\n         L     R1,0(,R1)           CALLER'S PARM\n         LH    R15,0(,R1)          GET PARM LENGTH\n         CH    R15,=H'4'           CORRECT LENGTH FOR YEAR ?\n         BNE   A0010               NO,  IGNORE IT\n         PACK  WRKDWORD,2(4,R1)    MAKE PACKED DECIMAL\n         CVB   R1,WRKDWORD         MAKE BINARY\n         STH   R1,WRKYEAR          SAVE YEAR\n*\nA0010    LH    R1,WRKYEAR          YEAR IN BINARY\n         CVD   R1,WRKDWORD         MAKE PACKED DECIMAL\n         UNPK  WRKYEARZ,WRKDWORD   MAKE ZONED DECIMAL\n         OI    WRKYEARZ+3,C'0'     REMOVE SIGN\n*\n*        COMPUTE FIRST DAY OF EACH MONTH\n*\n         LA    R2,12               NUMBER OF MONTHS\n         LA    R11,WRKDAY1-1       FIRST DAY OF MONTH TABLE\nA0020    STH   R2,WRKMONTH         SAVE MONTH FOR DAYOFWK\n         PCALL DAYOFWK,(WRKMONTH,=H'1',WRKYEAR)\n         STC   R15,0(R2,R11)       SAVE FIRST DAY OF MONTH\n         BCT   R2,A0020            COMPUTE FOR ALL MONTHS\n*\n*        CHECK FOR LEAP YEAR\n*\n         MVC   WRKDAYS(12),DAYS    SET DEFAULT WEEKDAYS\n         PCALL DAYOFWK,(=H'2',=H'28',WRKYEAR)\n         LR    R2,R15              SAVE WEEKDAY OF 2/28\n         PCALL DAYOFWK,(=H'3',=H'1',WRKYEAR)\n         CR    R15,R2              DID WEEKDAY WRAP AROUND ?\n         BH    A0030               NO, COMPARE DIFFERENCE IN DAYS\n         LA    R15,7(,R15)         ADJUST FOR WEEKDAY WRAP\nA0030    SR    R15,R2              COMPUTE DIFFERENCE IN DAYS\n         CH    R15,=H'1'           ONE DAY BETWEEN 2/28 AND 3/1 ?\n         BNE   A0040               NO, IT'S A LEAP YEAR\n         MVI   WRKDAYS+1,28        RESET\n*\n*        CLEAR CALENDAR TO ALL BLANKS\n*\nA0040    LA    R15,29              NUMBER OF LINES\n         LA    R14,WRKLINE         START OF LINES\nA0050    MVC   0(L'WRKLINE,R14),BLANKS CLEAR LINE\n         LA    R14,L'WRKLINE(,R14) ADVANCE TO NEXT LINE\n         BCT   R15,A0050           CLEAR NEXT LINE\n*\n*        FILL IN NAME OF EACH MONTH AND YEAR\n*\n         LA    R15,WRKLINE               START OF LINE\n         MVI   0(R15),C'1'               EJECT TO TOP OF FORM\n         MVC   1(7,R15),=C'JANUARY'      SET JANUARY\n         MVC   24(4,R15),WRKYEARZ        SET YEAR\n         MVC   32(8,R15),=C'FEBRUARY'    SET FEBRUARY\n         MVC   55(4,R15),WRKYEARZ        SET YEAR\n         MVC   63(5,R15),=C'MARCH'       SET MARCH\n         MVC   86(4,R15),WRKYEARZ        SET YEAR\n         MVC   94(5,R15),=C'APRIL'       SET APRIL\n         MVC   117(4,R15),WRKYEARZ       SET YEAR\n*\n         LA    R15,10*L'WRKLINE(,R15)    SKIP TO NEXT ROW\n         MVC   1(3,R15),=C'MAY'          SET MAY\n         MVC   24(4,R15),WRKYEARZ        SET YEAR\n         MVC   32(4,R15),=C'JUNE'        SET JUNE\n         MVC   55(4,R15),WRKYEARZ        SET YEAR\n         MVC   63(5,R15),=C'JULY'        SET JULY\n         MVC   86(4,R15),WRKYEARZ        SET YEAR\n         MVC   94(6,R15),=C'AUGUST'      SET AUGUST\n         MVC   117(4,R15),WRKYEARZ       SET YEAR\n*\n         LA    R15,10*L'WRKLINE(,R15)    SKIP TO NEXT ROW\n         MVC   1(9,R15),=C'SEPTEMBER'    SET SEPTEMBER\n         MVC   24(4,R15),WRKYEARZ        SET YEAR\n         MVC   32(7,R15),=C'OCTOBER'     SET OCTOBER\n         MVC   55(4,R15),WRKYEARZ        SET YEAR\n         MVC   63(8,R15),=C'NOVEMBER'    SET NOVEMBER\n         MVC   86(4,R15),WRKYEARZ        SET YEAR\n         MVC   94(8,R15),=C'DECEMBER'    SET DECEMBER\n         MVC   117(4,R15),WRKYEARZ       SET YEAR\n*\n*        FILL IN NAME OF DAY OF WEEK FOR EACH MONTH\n*\n         LA    R14,3                     NUMBER OF ROWS\n         LA    R15,WRKLINE               ADDRESS FIRST ROW\n         SH    R15,=Y(9*L'WRKLINE)       BACK UP FOR LOOP\nA0060    LA    R15,10*L'WRKLINE(,R15)    NEXT ROW\n         MVC   1(27,R15),=C'SUN MON TUE WED THU FRI SAT'\n         MVC   32(27,R15),1(R15)         FILL NEXT COLUMN\n         MVC   63(27,R15),1(R15)         FILL NEXT COLUMN\n         MVC   94(27,R15),1(R15)         FILL NEXT COLUMN\n         BCT   R14,A0060                 ADVANCE TO NEXT ROW\n*\n*        UNDERLINE DAY OF WEEK FOR EACH MONTH\n*\n         LA    R14,3                     NUMBER OF ROWS\n         LA    R15,WRKLINE               ADDRESS FIRST ROW\n         SH    R15,=Y(8*L'WRKLINE)       BACK UP FOR LOOP\nA0070    LA    R15,10*L'WRKLINE(,R15)    NEXT ROW\n         MVI   1(R15),C'-'               UNDERLINE WEEKDAYS\n         MVC   2(26,R15),1(R15)          FILL FIRST COLUMN\n         MVC   32(27,R15),1(R15)         FILL NEXT COLUMN\n         MVC   63(27,R15),1(R15)         FILL NEXT COLUMN\n         MVC   94(27,R15),1(R15)         FILL NEXT COLUMN\n         BCT   R14,A0070                 ADVANCE TO NEXT ROW\n*\n*        GENERATE CALENDAR OF DAYS IN EACH MONTH\n*\n         LA    R2,1                INITIALIZE MONTH\n         LA    R4,3                NUMBER OF ROWS\n         LA    R5,WRKLINE          START OF LINE\n         SH    R5,=Y(7*L'WRKLINE)  BACK UP FOR LOOP\nA0080    LA    R5,10*L'WRKLINE(,R5)  NEXT ROW\n         SR    R6,R6               CLEAR OFFSET TO MONTH\n         LA    R11,4               NUMBER OF MONTHS PER ROW\nA0090    LA    R7,0(R6,R5)         ADDRESS MONTH\n         SR    R8,R8               CLEAR DAYS IN MONTH\n         SR    R9,R9               CLEAR DAY OF WEEK\n         IC    R8,WRKDAYS-1(R2)    GET DAYS IN MONTH\n         IC    R9,WRKDAY1-1(R2)    GET FIRST DAY OF WEEK\n         LA    R10,1               GET FIRST DAY OF MONTH\nA0100    LR    R15,R9              COPY DAY OF WEEK\n         MH    R15,=H'4'           COMPUTE OFFSET IN LINE\n         LA    R15,0(R15,R7)       COMPUTE ADDRESS IN LINE\n         CVD   R10,WRKDWORD        MAKE DAY PACKED DECIMAL\n         MVC   0(4,R15),=X'40202120' EDIT PATTERN ZZ9\n         ED    0(4,R15),WRKDWORD+6 MAKE DAY DISPLAYABLE\n         LA    R10,1(,R10)         NEXT DAY\n         LA    R9,1(,R9)           NEXT DAY OF WEEK\n         CH    R9,=H'7'            GREATER THAN SATURADAY ?\n         BL    A0110               NO,  CONTINUE\n         SR    R9,R9               YES, RESET TO SUNDAY\n         LA    R7,L'WRKLINE(,R7)   GO TO NEXT LINE\nA0110    BCT   R8,A0100            DO ALL DAYS\n         LA    R2,1(,R2)           NEXT MONTH\n         LA    R6,31(,R6)          ADDRESS OF NEXT MONTH\n         BCT   R11,A0090           ALL MONTHS THIS ROW\n         BCT   R4,A0080            ALL ROWS\n*\n*        PUT CALENDAR TO DDNAME SYSOUT\n*\n         OPEN  (DCB,(OUTPUT))\n         LA    R2,29\n         LA    R11,WRKLINE\nPUT      PUT   DCB,(R11)\n         LA    R11,L'WRKLINE(,R11)\n         BCT   R2,PUT\n         CLOSE (DCB)\n*\n*        RETURN TO CALLER\n*\n         PEXIT RC=0\n         LTORG ,\n*\nDAYS     DC    AL1(31,29,31,30,31,30,31,31,30,31,30,31)\nBLANKS   DC    256C' '\n*\nDCB      DCB   DDNAME=SYSOUT,                                          +\n               DSORG=PS,                                               +\n               MACRF=PM,                                               +\n               RECFM=FBA,                                              +\n               LRECL=121,                                              +\n               BLKSIZE=6171\n*\nWRKDSECT DSECT ,\nWRKSAVEA DS    18F                 FIRST SAVE AREA\nWRKSAVE2 DS    18F                 SECOND SAVE AREA\nWRKID    EQU   WRKSAVEA,4\n*\nWRKDWORD DS    D                   DOUBLE WORD\nWRKFWORD DS    F                   FULL WORD\nWRKHWORD DS    H                   HALF WORD\nWRKBYTE  DS    B                   BYTE\n*\nWRKYEARZ DS    CL4                 CHARACTER YEAR\nWRKYEAR  DS    H                   NUMERIC YEAR\nWRKMONTH DS    H                   NUMERIC MONTH\nWRKDAY1  DS    12AL1               FIRST DAY OF EACH MONTH\nWRKDAYS  DS    12AL1               NUMBER OF DAYS EACH MONTH\n*\nWRKLINE  DS    29CL121\n*\nWRKEND   DS    0D\nWRKLEN   EQU   *-WRKDSECT\n*\n         EJECT ,\n*---------------------------------------------------------------------*\n*        DAYOFWK SUBROUTINE                                           *\n*---------------------------------------------------------------------*\n*\nDAYOFWK  PENTER FUNC\n*\n         L     R4,0(,R1)           MONTH\n         LH    R4,0(,R4)\n*\n         L     R5,4(,R1)           DAY\n         LH    R5,0(,R5)\n*\n         L     R6,8(,R1)           YEAR\n         LH    R6,0(,R6)\n*\n*        COMPUTE CENTURY = YEAR / 100\n*        COMPUTE DECADE  = YEAR MOD 100\n*\n         XR    R14,R14             CLEAR HIGH WORD OF DIVISOR\n         LR    R15,R6              GET DIVISOR ( YEAR )\n         LA    R2,100              GET DIVIDEND\n         DR    R14,R2              COMPUTE\n         LR    R7,R15              R7 = CENTURY (QUOTIENT)\n         LR    R8,R14              R8 = DECADE  (REMAINDER)\n*\n*        THE DAY OF THE MONTH INCREMENTS THE BASE BY THE\n*        SAME NUMBER OF DAYS, THE PASSING OF EACH YEAR ADDS\n*        A DAY, AND EACH LEAP YEAR ADDS A DAY\n*\n*        WEEKDAY = ( ( YEAR / 4 ) - CENTURY ) + ( YEAR / 400 ) +\n*                  DAY + YEAR + BMC( MONTH-1 )\n*\n         LR    R9,R6               GET YEAR\n         SRL   R9,2                WEEKDAY = ( YEAR / 4 )\n*\n         SR    R9,R7               WEEKDAY = WEEKDAY - CENTURY\n*\n         LR    R14,R7              GET CENTURY ( YEAR / 100 )\n         SRL   R14,2               COMPUTE ( YEAR / 400 )\n         AR    R9,R14              WEEKDAY = WEEKDAY + ( YEAR / 400 )\n*\n         AR    R9,R5               WEEKDAY = WEEKDAY + DAY\n*\n         AR    R9,R6               WEEKDAY = WEEKDAY + YEAR\n*\n         LR    R14,R4              GET MONTH\n         BCTR  R14,0               MINUS 1\n         SR    R15,R15             CLEAR REGISTER\n         IC    R15,BMC(R14)        INDEX INTO BASE MONTH CODE TABLE\n         AR    R9,R15              WEEKDAY = WEEKDAY + BMC( MONTH-1 )\n*\n*        FOR A LEAP YEAR, REMOVE THE EXTRA DAY BEFORE IT OCCURS,\n*        I.E. JANUARY AND FEBRUARY\n*\n*        IF ( ( YEAR MOD 400 = 0 ) OR\n*             ( ( YEAR MOD 4 = 0 ) AND ( DECADE ^= 0 ) ) )\n*           IF ( MONTH < 3 )\n*              WEEKDAY = WEEKDAY - 1\n*\n         XR    R14,R14             CLEAR HIGH WORD OF DIVISOR\n         LR    R15,R6              GET DIVISOR ( YEAR )\n         LA    R2,400              GET DIVIDEND\n         DR    R14,R2              COMPUTE ( YEAR MOD 400 )\n*\n         LTR   R14,R14             CHECK LEAP CENTURY ( YEAR MOD 400 )\n         BZ    D0010               YES, ALSO LEAP YEAR\n         XR    R14,R14             CLEAR HIGH WORD OF DIVISOR\n         LR    R15,R6              GET DIVISOR ( YEAR )\n         LA    R2,4                GET DIVIDEND\n         DR    R14,R2              COMPUTE ( YEAR MOD 4 )\n         LTR   R14,R14             POSSIBLE LEAP YEAR ?\n         BNZ   D00005              NO,  SHOW NOT A LEAP YEAR\n         LTR   R8,R8               YES, BUT IS IT A CENTURY YEAR ?\n         BNZ   D0010               NO,  SO IT'S A LEAP YEAR\nD00005   LA    R14,1               YES, NOT A LEAP CENTURY YEAR\n*\nD0010    LTR   R14,R14             LEAP YEAR ?\n         BNZ   D0020               NO,  SKIP ADJUSTMENT\n         CH    R4,=H'3'            JANUARY OR FEBRUARY ?\n         BNL   D0020               NO,  SKIP ADJUSTMENT\n         BCTR  R9,0                WEEKDAY = WEEKDAY - 1\n*\n*        RETURN ( WEEKDAY MOD 7 )\n*\nD0020    XR    R14,R14             CLEAR HIGH WORD OF DIVISOR\n         LR    R15,R9              GET LOW WORD OF DIVISOR (WEEKDAY)\n         LA    R2,7                GET DIVIDEND\n         DR    R14,R2              COMPUTE WEEKDAY MOD 7\n         LR    R15,R14             RETURN VALUE (WEEKDAY MOD 7)\n*\n         PEXIT RC=(15)\n         LTORG ,\n*\nSUN      EQU   0\nMON      EQU   1\nTUE      EQU   2\nWED      EQU   3\nTHU      EQU   4\nFRI      EQU   5\nSAT      EQU   6\n*\n*        BASE MONTH CODE TABLE\nBMC      DC    AL1(SAT)            JANUARY   1, 0000\n         DC    AL1(TUE)            FEBRUARY  1, 0000\n         DC    AL1(TUE)            MARCH     1, 0000\n         DC    AL1(FRI)            APRIL     1, 0000\n         DC    AL1(SUN)            MAY       1, 0000\n         DC    AL1(WED)            JUNE      1, 0000\n         DC    AL1(FRI)            JULY      1, 0000\n         DC    AL1(MON)            AUGUST    1, 0000\n         DC    AL1(THU)            SEPTEMBER 1, 0000\n         DC    AL1(SAT)            OCTOBER   1, 0000\n         DC    AL1(TUE)            NOVEMBER  1, 0000\n         DC    AL1(THU)            DECEMBER  1, 0000\n*\n         END   PSU004\n./ ADD NAME=PUSHREG  0100-03194-03194-1243-00039-00039-00000-PASCOTT\n.* COPYRIGHT (C) 1988, PAUL A. SCOTT, ALL RIGHTS RESERVED\n.*\n         MACRO\n&NAME    PUSHREG\n.*\n         COPY  PSMGBL01\n         COPY  PSMGBL02\n         LCLA  &I,&J,&K,&N\n.*\n         AIF   (T'&NAME EQ 'O').A000\n&NAME    DS    0H\n.A000    ANOP\n.*\n&N       SETA  N'&SYSLIST\n         AIF   (&N GT 0).A010\n         MEXIT\n.*\n.A010    ANOP\n&I       SETA  1\n&J       SETA  0\n&K       SETA  0\n.A020    ANOP\n         PSMROP &SYSLIST(&I)\n         AIF   (&PSMROPC GT 1).A030\n         ST    &PSMROP1,&J.(,&SP)\n         AGO   .A040\n.*\n.A030    ANOP\n         STM   &PSMROP1,&PSMROP2,&J.(&SP)\n.*\n.A040    ANOP\n&I       SETA  &I+1\n&J       SETA  &J+(4*&PSMROPC)\n&K       SETA  &K+&PSMROPC\n         AIF   (&I LE &N).A020\n.*\n         LA    &SP,4*&K.(,&SP)\n.*\n         MEND\n./ ADD NAME=ZIC      0100-03194-03194-1244-00056-00056-00000-PASCOTT\n.* COPYRIGHT (C) 1988, PAUL A. SCOTT, ALL RIGHTS RESERVED\n         MACRO\n&LABEL   ZIC   &P1,&P2             ZERO AND INSERT CHARACTER\n.*\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*       VARIABLE DEFINITIONS\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*\n         COPY  PSMGBL02\n.*\n         LCLA  &I,&K\n         LCLC  &C,&R1,&R2\n.*\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*       CHECK FOR REGISTER NOTATION IN OPERAND 2\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*\n&I       SETA  1\n&K       SETA  K'&P2\n.L0100   ANOP\n         AIF   (&I GT &K).L0130\n         AIF   ('&P2'(&I,1) EQ '(').L0110\n&I       SETA  &I+1\n         AGO   .L0100\n.*\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*       CHECK IF TARGET REG IS ALSO BASE OR INDEX REG\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*\n.L0110   ANOP\n&C       SETC  '&P2'(&I,(&K-&I)+1)\n         PSMROPS &C\n         PSMRVAL &P1\n&I       SETA  &PSMRVAL\n         AIF   (&I EQ 0).L0130\n         AIF   ((&I NE &PSMROP1) AND (&I NE &PSMROP2)).L0130\n.*\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*       CLEAR UNUSED BITS AFTER OPERATION (SLOWER)\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*\n.L0120   ANOP\n&LABEL   IC    &P1,&P2\n         SLL   &P1,24\n         SRL   &P1,24\n         MEXIT\n.*\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*       CLEAR UNUSED BITS BEFORE OPERATION (FASTER)\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*\n.L0130   ANOP\n.*\n&LABEL   XR    &P1,&P1                         ZERO TARGET REGISTER\n         IC    &P1,&P2                         INSERT CHARACTER\n         MEND\n./ ADD NAME=ZICM     0100-03194-03194-1244-00063-00063-00000-PASCOTT\n.* COPYRIGHT (C) 1988, PAUL A. SCOTT, ALL RIGHTS RESERVED\n         MACRO\n&LABEL   ZICM &P1,&P2,&P3          ZERO AND INSERT CHARS UNDER MASK\n.*\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*       VARIABLE DEFINITIONS\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*\n         COPY  PSMGBL02\n.*\n         LCLA  &I,&K\n         LCLC  &C\n.*\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*       CHECK FOR REGISTER NOTATION IN OPERAND 3\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*\n&I       SETA  1\n&K       SETA  K'&P3\n.L0100   ANOP\n         AIF   (&I GT &K).L0130\n         AIF   ('&P3'(&I,1) EQ '(').L0110\n&I       SETA  &I+1\n         AGO   .L0100\n.*\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*       CHECK IF TARGET REG IS ALSO BASE OR INDEX REG\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*\n.L0110   ANOP\n&C       SETC  '&P3'(&I,(&K-&I)+1)\n         PSMROPS &C\n         PSMRVAL &P1\n         AIF   ((&PSMRVAL EQ 0) OR (&PSMRVAL NE &PSMROP1)).L0130\n.*\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*       CLEAR UNUSED BITS AFTER OPERATION (SLOWER)\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*\n.L0120   ANOP\n.*\n&B0      SETB  ((&P2/16*2) NE &P2/8)\n&B1      SETB  ((&P2/8*2) NE &P2/4)\n&B2      SETB  ((&P2/4*2) NE &P2/2)\n&B3      SETB  ((&P2/2*2) NE &P2)\n&C       SETC  '00FF'(&B0*2+1,2)\n&C       SETC  '&C'.'00FF'(&B1*2+1,2)\n&C       SETC  '&C'.'00FF'(&B2*2+1,2)\n&C       SETC  '&C'.'00FF'(&B3*2+1,2)\n.*\n&LABEL   ICM   &P1,&P2,&P3\n         N     &P1,=A(X'&C')\n         MEXIT\n.*\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*       CLEAR UNUSED BITS BEFORE OPERATION (FASTER)\n.*      /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n.*\n.L0130   ANOP\n.*\n&LABEL   XR    &P1,&P1                         ZERO TARGET REGISTER\n         ICM   &P1,&P2,&P3                     INSERT CHARACTER MASK\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT643/FILE643.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT643", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}