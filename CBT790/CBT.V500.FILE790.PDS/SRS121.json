{"INMR01": {"INMLRECL": 80, "INMFNODE": "USCSTST", "INMFUID": "DWD", "INMTNODE": "N1", "INMTUID": "X", "INMFTIME": "20061102193846000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 470288, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 27920, "INMRECFM": "FB", "INMDIR": 9, "INMDSNAM": "SRS.V121.SRC", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 470288, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 470288, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"SRS.V121.SRC": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 27920, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 10017, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "060306", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\xc0\\x00\\x00\\x00'", "DS1LSTAR": "b'\\x00G\\x03'", "DS1TRBAL": "b'\\r\\xae'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x030\\x00\\x04\\x9a\\x00\\xc8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x030\\x00\\x04\\x9a\\x00\\xc8'", "b'P\\xfbk\\xa8\\x00\\x00\\x00N\\x00\\x00\\x00R\\x00\\x0e\\x00K'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$ABOUT": {"ttr": 15875, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x08\\x00B\\x01\\x03'?\\x01\\x05\\x19o\\x14P\\x00\\x86\\x00L\\x00\\x00\\xc4\\xe6\\xc4@@@@@@@\"", "ispf": {"version": "01.08", "flags": 0, "createdate": "2003-09-30T00:00:00", "modifydate": "2005-07-15T14:50:42", "lines": 134, "newlines": 76, "modlines": 0, "user": "DWD"}, "text": "SYSOUT Retrieval Services (SRS) is a product that retrieves data from\nthe JES spool using the SYSOUT Application Program Interface (SAPI).\nSRS supports a robust set of SYSOUT selection criteria (documented\nbelow) that can be specified by the user on the EXEC PARM= statement.\nUsing these criteria, SRS builds the necessary data structures and\ncalls SAPI asking for SYSOUT data that matches the selection request.\nIf JES finds and returns a spool data set, SRS copies the data to a\nfile specified by the user.\n\nFor more complex applications, SRS supports a user-written \"despooler\"\nroutine.  In this mode, SRS still processes selection criteria, and\nmakes the SAPI call.  But instead of writing the spool data to a file,\nSRS calls the despooler routine, one record at a time, to process the\ndata.  The SRSJWRAP program (which is shipped with SRS) is one example\nof a special despooler routine.\n\nSRS can be invoked from a batch job or started task as follows:\n\n//DESPOOL EXEC SRS,PARM='<options>'\n\n<options> specify a combination of SRS control options and SYSOUT\nselection criteria.  An explanation of each option follows.\nRequired characters are in uppercase while optional characters are\nin lowercase.  For example, the DDname keyword can be specified as\nDD=, DDN=, DDNA=, DDNAM=, or DDNAME=.\n\nThe following options specify what SYSOUT to select.\n\nQ=<c> -or-  The SYSOUT class\nCLASS=<c>   default: none\n            example: CLASS=A\n\nJobname=    The jobname (wild-card characters supported)\n <jobname>  default: none\n            example: JOBN=MYJOB\n\nJI=         The 8-character JES jobid\n <jobid> or default: none\nJOBId=      example: JOBI=J98754 or JI=JOB98754\n <jobid>\n\nDest=       The destination (or 'ALL' to select all destinations)\n <destid>   default: LOCAL\n            example: DEST=SRSDEST\n\nForms=      The forms ID (or 'ALL' to select all forms)\n <forms>    default: STD\n            example: FORMS=STDX\n\nWriter=     The writer name (or 'ALL' to select all writer names)\n <writer>   default: null (SYSOUT with NO writer name)\n            example: WRITER=SRSWTR\n\nSTATus=     The status of data sets to select\n <status>   'HELD', 'NONHELD', or 'ALL' can be specified\n            default: NONHELD\n\nDDname=     The DDNAME of the spool data set (wild-card\n <ddname>   characters supported)\n            default: none\n            example: DD=JES*\n\n\nThe following options control SRS processing.\n\nProgram=    The name of the special despooler program\n <pgnmane>  default: none (SRSGENER is used)\n\nPPARM=      Parameter list passed to the despooler program\n (parms)    or to the standard despooler routine.\n            Note: parms must be enclosed in parentheses.\n            default: none\n\nLIMit=      The maximum number of output groups to select (1-9999)\n <lim>      default: no limit\n\nWAIT=YES/NO Whether SRS is to wait for data sets or end when no\n            more spool data sets remain to select\n            default: NO if invoked in batch; YES if STC\n\nDISP=       The disposition of selected spool data sets\n <disp>     'KEEP' or 'DELETE' can be specified.\n            default: DELETE\n\nSEP=        Specifies whether separator records are to be written to\n <sep_opt>  the output data stream prior to the actual SYSOUT data.\n            Valid options are:\n\n            JOB - writes a record containing the job name and JOBID\n                  before each job's selected SYSOUT\n\n            OUTGRP - writes a record containing (in addition to the JOB\n              or     record) the SYSOUT class, destination, writer name,\n             YES     forms name, and output group name before each\n                     output group's selected SYSOUT\n\n            DATASET - writes a record containing (in addition to the\n              or      OUTGRP record) the DDNAME before each data set's\n              DS      selected SYSOUT\n\n            NO - no separator records are produced\n\n            Default: NO\n\nSEPId=      Specifies a one to eight byte character string that can be\n <sepid>    used to identify separator records.  <sepid> will appear\n            at the beginning of each separator.\n            default: *SRS>\n            example: SEPID=**SEP**\n\nOPTs=       Specifies a one or two character suffix that is appended\n <options>  to 'SRSOPT' to form the options module name.  The options\n            module must be accessible (STEPLIB, link list, etc.) and\n            must have been created using a current version of the\n            SRSOPTS macro.\n            default: S (uses module SRSOPTS)\n            example: OPTS=99 (uses module SRSOPT99)\n\nThe following options can be specified on the PPARM= keyword if\ndefault processing (i.e. no special despooler program) is in effect.\n\nOUTFILE=file Specifies the DDNAME of the data set to write spool data\n             records to\n             default: SYSUT2\n\nDEFER_OPEN=YES/NO Specifies whether the OUTFILE= file should be opened\n                  at SRS initialization or after the first record is\n                  despooled.  If 'YES' is specified and the OUTFILE=\n                  file is a new data set that does not specify LRECL\n                  information, SRS will use the record length of the\n                  first record despooled as the LRECL.  If 'NO', LRECL\n                  must be specified on the OUTFILE= file or a S013-34\n                  abend will occur.\n                  default: YES\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$APARS": {"ttr": 17155, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00T\\x01\\x060\\x0f\\x01\\x060\\x0f\\x173\\x00\\x10\\x00\\x10\\x00\\x00\\xc4\\xe6\\xc4@@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2006-10-27T00:00:00", "modifydate": "2006-10-27T17:33:54", "lines": 16, "newlines": 16, "modlines": 0, "user": "DWD"}, "text": "APARS issued since V121 General Availability\n======================================================================\nAPAR: A12101\nRel:  121\nDate: 10/27/2006\nProblem: Message SRS100E SSOB RETN=32 RESN=36 when an 8-character DEST\n         and a JOBNAME is specified.\n         SRS supports up to 8 character destination ID's via the\n         DEST= keyword.  SAPI supports up to 18 characters in the SSOB\n         SSS2DEST.  Code in SRSTASK incorrectly moves 18 bytes from\n         the DEST field in the TBLK to the SSOB.  When the adjacent\n         field in the TBLK (which happens to be the JOBNAME) is\n         non-blank, a logic error results on the SAPI SSI call.\nFix:     Expand the SRS DEST field to 18 characters.\nUpdates: SRSDRVR, SRSOPT, SRSTASK, SRSTBLK\n======================================================================\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$ASMSRS": {"ttr": 14597, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x04\\x01\\x05\\x19_\\x01\\x05\\x19_\\x17\"\\x00\\x14\\x00\\x14\\x00\\x00\\xc4\\xe6\\xc4@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2005-07-14T00:00:00", "modifydate": "2005-07-14T17:22:04", "lines": 20, "newlines": 20, "modlines": 0, "user": "DWD"}, "text": "//SRSASM   JOB (TE10,SRS),'Assemble/Link SRS   ',MSGCLASS=X,\n//   CLASS=H,NOTIFY=&SYSUID\n//*=================================================================*\n//* This job assembles and links all modules in the SRS product.    *\n//* The load modules shipped with SRS are usually compatible        *\n//* with higher/lower z/OS releases, so in general it is NOT        *\n//* necessary to run this job to use SRS.                           *\n//*=================================================================*\n//PROCLIB JCLLIB ORDER='SRS.V121.SRC'\n//*\n//SRSAUTH  EXEC ASMSRS,SRSMOD=SRSAUTH,LOPT='AC=1,RENT,REFR,REUS'\n//SRSGENER EXEC ASMSRS,SRSMOD=SRSGENER\n//SRSJWRAP EXEC ASMSRS,SRSMOD=SRSJWRAP\n//SRSOPTS  EXEC ASMSRS,SRSMOD=SRSOPTS\n//SRSPRHEX EXEC ASMSRS,SRSMOD=SRSPRHEX,LOPT='RENT,REFR,REUS'\n//SRSTASK  EXEC ASMSRS,SRSMOD=SRSTASK,LOPT='AC=1,REUS=REFR'\n//SRSDRVR  EXEC ASMSRS,SRSMOD=SRSDRVR,LOPT='AC=1,RENT,REFR,REUS'\n//LKED.SYSIN DD *\n ALIAS SRS\n NAME  SRSDRVR(R)\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$INSTALL": {"ttr": 15887, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x05\\x00T\\x00\\x99\\x18\\x8f\\x01\\x05!\\x7f\\x136\\x00'\\x00\\x18\\x00\\x00\\xc4\\xe6\\xc4@@@@@@@\"", "ispf": {"version": "01.05", "flags": 0, "createdate": "1999-07-07T00:00:00", "modifydate": "2005-08-05T13:36:54", "lines": 39, "newlines": 24, "modlines": 0, "user": "DWD"}, "text": "SRS Installation Instructions:\n\n1. SRS is distributed in two files: src.xmt (source code) and\n   linklib.xmt (execution library).  The files are in TSO TRANSMIT form\n   and must be unformatted with the TSO RECEIVE command to translate\n   them into useable PDSes.\n\n2. Binary Upload both files.\n   - If using IND$FILE or a similar file transfer program DO NOT\n     specify 'Convert to EBCDIC' or 'Delete CRLF'.\n   - If using FTP, specify BINARY transfer mode\n\n3. For each file, issue TSO command RECEIVE INDS(dsn), where dsn is the\n   data set name assigned to each uploaded file.  When message INMR906A\n   appears, enter DS(newdsn) to specify the desired names for the source\n   and execution libraries on your system.\n\n4. Update PROGxx or IEAAPFxx to APF authorize the execution library.\n   Dynamically authorize the execution library or IPL the system.\n\n5. Member SRS in the source library is a sample cataloged procedure that\n   can be used to invoke SRS.  Change the STEPLIB data set name to the\n   execution library name you've chosen for your system.  Make any other\n   updates to suit your installation standards and copy the proc to a\n   system procedure library or use a JCLLIB statement in SRS execution\n   JCL to point to the SRS source library.\n\nNOTES:\n\n- Review the $ABOUT member in the source library for information\n  on how to use SRS.\n\n- SRS 1.2.1 was assembled on z/OS 1.6.  The Linklib shipped should be\n  downward and upward compatible with prior and future releases.\n\n- If you install SRS, please send a note to\n  david.danner@associates.dhs.gov so I can add you to the distribution\n  list for future product upgrades.  Of course comments and/or\n  enhancement requests are also welcome!\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$NEWS": {"ttr": 15885, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x03\\x002\\x01\\x05\\x19o\\x01\\x05\\x19o\\x15'\\x00&\\x00\\x1f\\x00\\x00\\xc4\\xe6\\xc4@@@@@@@\"", "ispf": {"version": "01.03", "flags": 0, "createdate": "2005-07-15T00:00:00", "modifydate": "2005-07-15T15:27:32", "lines": 38, "newlines": 31, "modlines": 0, "user": "DWD"}, "text": "SYSOUT Retrieval Services (SRS) 1.2.1          Release Date: 07/15/2005\n\nEnhancements in this release:\n\n1. Keyword Expansion\n   Most keywords have been expanded to enhance readability and simplify\n   ease of use.  For example, 'J=' (the keyword to select jobname) can\n   now be specified as 'JOBNAME=' 'JOBNAM=' 'JOBNA=' 'JOBN=' 'JOB='\n   'JO=' or 'J='.  ** PLEASE SEE NOTE BELOW **\n\n2. Separator records can now optionally be produced between each\n   dataset, output group, or job.  The new SEP and SEPID keywords\n   control whether separator records are produced and specify the\n   text string used as a separator record prefix.\n\n3. Installations can override any SRS defaults by updating the\n   SRSOPTS module shipped with the product.  (For example, the\n   default FORMS specification can be changed from 'STD' to 'STDX').\n   In addition, a \"prepackaged\" set of options can be generated for\n   specific uses and jobs can reference these options with the new\n   OPT= keyword.  The $OPTIONS member in the source library can be\n   used to update the system-wide SRSOPTS default options or to\n   generate a unique options set.\n\n4. Product packaging has been streamlined to make module re-assembly\n   easier.  See member $ASMSRS in the source library.\n\n5. Miscellaneous:\n   - SRSDRVR is now RMODE ANY.\n   - Better syntax checking for parms specified.\n   - Minor improvements to messages issued.\n   - LIMIT maximum increased from 999 to 9999.\n\nNOTE: There is one incompatible change in this release.  Due to the\n      keyword processing changes, parameters on the PPARM= keyword\n      must now be enclosed in parentheses.  For example,\n      PPARM=OUTFILE=SRSOUT was valid in SRS 1.2.0 but now must be\n      specified as: PPARM=(OUTFILE=SRSOUT)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$NEWS112": {"ttr": 11, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00C\\x00\\x99\\x18\\x8f\\x00\\x99\\x18\\x9f\\x143\\x00$\\x00$\\x00\\x00\\xc4\\xe6\\xc4@@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1999-07-07T00:00:00", "modifydate": "1999-07-08T14:33:43", "lines": 36, "newlines": 36, "modlines": 0, "user": "DWD"}, "text": "What's new in SRS 1.1.2 ?\n\n1. Support for HELD datasets.\n   Prior to release 1.1.2, only 'ready', non-held output datasets could\n   be processed.  The new STATUS= parameter allows NONHELD (the\n   default), HELD, or ALL datasets to be selected.\n\n2. Elimination of S001-3 abends.\n   Prior to 1.1.2, when SRS attempted to process a sysout dataset that\n   was not closed properly by JES (usually as a result of a system\n   crash), the SRS subtask would receive a S001-3 abend and processing\n   would terminate.  In 1.1.2, SRS intercepts the abend and generates\n   messages similar to the following:\n\n   SRS050E DWDSRS  ,SRS     ,JES ,I,SYSSAPI ,GET   ,READ ERROR     ,\n           **************,QSAM\n   SRS051E I/O error reading spool dataset RMF.RMF.STC37951.D0000102.?\n\n   Note that SRS050E reports error information provided by the SYNADAF\n   service routine.  SRS will then continue as if end-of-file had been\n   encountered on the dataset, and will resume normal processing,\n   selecting more datasets if appropriate.  If SRS encounters an I/O\n   error reading a dataset, it will not count the dataset for LIMIT\n   checking.\n\n3. STC/TSU support for JOBID (JI=) parameter.\n   Prior to 1.1.2, users had to specify JOBnnnnn on the JI= parameter,\n   even to select STC and TSU output.  The JI= keyword now honors\n   STCnnnnn and TSUnnnnn specifications, and will select only the\n   desired jobid type (for example, JI=STC1234 will not select JOB1234).\n\n4. Miscellaneous.\n   Several bugs have been corrected:\n      ABEND0C4 HASCHAM+4F6\n      Loop when WAIT=YES specified\n   A few messages have been clarified with expanded error text.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$NEWS120": {"ttr": 9, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00W\\x01\\x03%\\x9f\\x01\\x03&\\x8f\\x16A\\x00?\\x00\\x14\\x00\\x00\\xc4\\xe6\\xc4@@@@@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2003-09-16T00:00:00", "modifydate": "2003-09-25T16:41:57", "lines": 63, "newlines": 20, "modlines": 0, "user": "DWD"}, "text": "What's new in SRS 1.2.0 ?\n\n1. Select by DDNAME.\n   The DDNAME= keyword filters the selection of spool data to data\n   sets with a specific DDNAME.  For example DDNAME=JESJCL will\n   select only the JES JCL listing data set.  Wildcarding is supported.\n\n2. PARM support for despool program.\n   The PPARM= keyword can be used to pass up to 80 characters to the\n   despooler program.  If the string contains commas, it must be\n   specified within parentheses.\n\n3. WTO changes.\n   - Minor changes were made to SRS505I\n   - The DDNAME of the data set selected is now included on SRS001I\n   - SRS010I is no longer issued with DESC=2\n   - New message SRS002I is issued when DDNAME= was specified and a\n     job was found that matched the selection criteria but did not\n     contain the desired ddname.\n\n4. SRSGENER Enhancements:\n   Several enhancements were made to the default despooler program.\n\n   - New parameters can be passed on the PPARM= keyword:\n\n     OUTFILE= can be used to specify the DDNAME despooled records\n     are to be written to.  In prior releases, SYSUT2 was the only\n     choice.  SYSUT2 is the default.\n\n     DEFER_OPEN=YES/NO specifies whether the OUTFILE= file should\n     be opened at SRS initialization or after the first record is\n     despooled.  If 'YES' (which is the default) is specified and\n     no LRECL is specified on the OUTFILE= file, SRS will use the\n     record length of the first record despooled as the LRECL.\n     If 'NO', LRECL must be specified on the OUTFILE= file or a\n     S013-34 abend will occur.  'NO' may be useful if OUTFILE=\n     specifies a tape device and SRS ends with RC=4 (indicating no\n     spool files matched the selection criteria) before the tape\n     is mounted.\n\n   - New message SRSG01I indicates the DDNAME and DSN despooled\n     data is being written to.\n\n   - Corrected a problem where if multiple data sets with different\n     LRECL's were despooled, the smaller data sets were sometimes\n     written with data from a previous data set.\n\n   - Message SRSG02W will now be issued for each data set that has\n     a record length greater than the OUTFILE= file LRECL (indicating\n     possible data truncation).  In prior releases, this message was\n     issued only once per output group for the first data set\n     truncated.\n\n5. Miscellaneous.\n   - A warning message is issued if the SYSPARM DD is used to specify\n     SRS PARMS.  Support for SYSPARM will be dropped in a future\n     release.  (Specify SRS parms on the EXEC PARMS= keyword).\n\n   - Fixed S0C4 when the despooler program requests termination on\n     the initialization call.\n\n   - Set RC=8 when SRS510E (No SYSOUT selection criteria specified) is\n     issued.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$OPTIONS": {"ttr": 14599, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00 \\x01\\x05\\x19_\\x01\\x05\\x19_\\x177\\x00\\x19\\x00\\x19\\x00\\x00\\xc4\\xe6\\xc4@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2005-07-14T00:00:00", "modifydate": "2005-07-14T17:37:20", "lines": 25, "newlines": 25, "modlines": 0, "user": "DWD"}, "text": "//SRSOPTS  JOB (TE10,SRS),'Change SRS def opts ',MSGCLASS=X,\n//   CLASS=H,NOTIFY=&SYSUID\n//*=================================================================*\n//* This sample job changes SRS default options.                    *\n//* All defaults that are shipped with the product are specified    *\n//* below.  If you would like to change any default, do so here     *\n//* and submit this job.                                            *\n//*=================================================================*\n//PROCLIB JCLLIB ORDER='SRS.V121.SRC'\n//*\n//SRSOPTS  EXEC ASMSRS,SRSMOD=SRSOPTS\n//ASM.SYSIN DD *\n         SRSOPT CLASS=,         SYSOUT Class                           X\n               DEST=LOCAL,      Destination ID                         X\n               DISP=DELETE,     Processed SYSOUT disposition           X\n               FORMS=STD,       Forms ID                               X\n               JOBNAME=,        Jobname                                X\n               LIM=,            SYSOUT limit                           X\n               PPARM=,          Despooling program parms               X\n               PROG=SRSGENER,   Despooling program name                X\n               SEP=NO,          Separator record option                X\n               SEPID=*SRS>,     Separator record ID                    X\n               STATUS=NONHELD,  SYSOUT status                          X\n               WAIT=,           WAIT-for-SYSOUT option                 X\n               WRITER=          WRITER ID\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ASMSRS": {"ttr": 16647, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x16\\x00Q\\x00\\x93\"/\\x01\\x060\\x0f\\x17\\x01\\x00\\x1c\\x00.\\x00\\x00\\xc4\\xe6\\xc4@@@@@@@'", "ispf": {"version": "01.22", "flags": 0, "createdate": "1993-08-10T00:00:00", "modifydate": "2006-10-27T17:01:51", "lines": 28, "newlines": 46, "modlines": 0, "user": "DWD"}, "text": "//ASMSRS PROC  SRCREL='V121',         SRS source code level\n//             LNKREL='V12101',       SRS link library level\n//             HLQSRC='SRS',          High-level qualifier for SRC lib\n//             HLQLNK='SRS',          High-level qualifier for LINKLIB\n//             SRSMOD=,               SRS module to asm/link\n//             AOPT=,                 Assembler parms\n//             LOPT=                  Binder parms\n//*********************************************************************\n//*  Assemble and Link an SRS module\n//*********************************************************************\n//ASM      EXEC PGM=ASMA90,PARM=(TERM,BATCH,&AOPT)\n//SYSIN    DD  DISP=SHR,DSN=&HLQSRC..&SRCREL..SRC(&SRSMOD)\n//SYSLIB   DD  DISP=SHR,DSN=SYS1.MODGEN\n//         DD  DISP=SHR,DSN=SYS1.MACLIB\n//         DD  DISP=SHR,DSN=&HLQSRC..&SRCREL..SRC\n//SYSLIN   DD  DISP=(,PASS),UNIT=VIO,SPACE=(CYL,(5,5,0)),DSN=&&LOADSET\n//SYSTERM  DD  SYSOUT=*\n//SYSPRINT DD  SYSOUT=*\n//SYSPUNCH DD  DUMMY\n//SYSUT1   DD  UNIT=VIO,SPACE=(CYL,(40))\n//LKED   EXEC  PGM=HEWL,PARM='XREF,LIST,&LOPT',\n//             COND=(4,LT,ASM)\n//SYSLIB   DD  DISP=SHR,DSN=&HLQLNK..&LNKREL..LINKLIB\n//SYSLMOD  DD  DISP=SHR,DSN=&HLQLNK..&LNKREL..LINKLIB(&SRSMOD)\n//SYSLIN   DD  DSN=&&LOADSET,DISP=(OLD,DELETE)\n//         DD  DDNAME=SYSIN\n//SYSIN    DD  DUMMY\n//SYSPRINT DD  SYSOUT=*\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SRS": {"ttr": 15883, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0b\\x00!\\x00\\x976O\\x01\\x05\\x19o\\x15\\x17\\x008\\x00\\x04\\x00\\x00\\xc4\\xe6\\xc4@@@@@@@'", "ispf": {"version": "01.11", "flags": 0, "createdate": "1997-12-30T00:00:00", "modifydate": "2005-07-15T15:17:21", "lines": 56, "newlines": 4, "modlines": 0, "user": "DWD"}, "text": "//SRS      PROC\n//SRS      EXEC PGM=SRS,REGION=6M,PARM=''\n//*********************************************************************\n//* SYSOUT Retrieval Services - Sample cataloged procedure            *\n//*                                                                   *\n//* This proc can be invoked as a started task or used in a batch     *\n//* job.                                                              *\n//*                                                                   *\n//* Some of the options that can be specified on PARM= are below.     *\n//* See the $ABOUT member in the SRS source library for a complete    *\n//* list of parameter options.                                        *\n//*                                                                   *\n//* Q=<c> -or-  The SYSOUT class                                      *\n//* CLASS=<c>   default: none                                         *\n//*             example: CLASS=A                                      *\n//*                                                                   *\n//* Jobname=    The jobname (wild-card characters supported)          *\n//*  <jobname>  default: none                                         *\n//*             example: JOBN=MYJOB                                   *\n//*                                                                   *\n//* JI=         The 8-character JES jobid                             *\n//*  <jobid> or default: none                                         *\n//* JOBId=      example: JOBI=J98754 or JI=JOB98754                   *\n//*  <jobid>                                                          *\n//*                                                                   *\n//* Dest=       The destination (or 'ALL' to select all destinations) *\n//*  <destid>   default: LOCAL                                        *\n//*             example: DEST=SRSDEST                                 *\n//*                                                                   *\n//* Forms=      The forms ID (or 'ALL' to select all forms)           *\n//*  <forms>    default: STD                                          *\n//*             example: FORMS=STDX                                   *\n//*                                                                   *\n//* Writer=     The writer name (or 'ALL' to select all writer names) *\n//*  <writer>   default: null (SYSOUT with NO writer name)            *\n//*             example: WRITER=SRSWTR                                *\n//*                                                                   *\n//* STATus=     The status of data sets to select                     *\n//*  <status>   'HELD', 'NONHELD', or 'ALL' can be specified          *\n//*             default: NONHELD                                      *\n//*                                                                   *\n//* DDname=     The DDNAME of the spool data set (wild-card           *\n//*  <ddname>   characters supported)                                 *\n//*             default: none                                         *\n//*             example: DD=JES*                                      *\n//*                                                                   *\n//* LIMit=      The maximum number of output groups to select (1-9999)*\n//*  <lim>      default: no limit                                     *\n//*                                                                   *\n//* DISP=       The disposition of selected spool data sets           *\n//*  <disp>     'KEEP' or 'DELETE' can be specified.                  *\n//*             default: DELETE                                       *\n//*                                                                   *\n//*********************************************************************\n//STEPLIB   DD  DSN=SRS.V121.LINKLIB,DISP=SHR\n//SYSUDUMP  DD  SYSOUT=*\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SRSABLK": {"ttr": 13, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x19\\x00\\x976O\\x01\\x03&\\x0f\\x159\\x00\\x15\\x00\\x14\\x00\\x00\\xc4\\xe6\\xc4@@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1997-12-30T00:00:00", "modifydate": "2003-09-17T15:39:19", "lines": 21, "newlines": 20, "modlines": 0, "user": "DWD"}, "text": "         MACRO\n         SRSABLK &DSECT=YES\n         SPACE 3\n         AIF   ('&DSECT' EQ 'NO').GENLBL\nSRSABLK DSECT\n         AGO   .GENAREA\n.GENLBL  ANOP\nSRSABLK DS     0F\n.GENAREA ANOP\nSRSABLKE DS    CL8'SRSABLK'    SRSABLK eye-catcher                 V120\nSRSAAECB DS    F               Address of ECB SRSAUTH WAITs on\nSRSARECB DS    F               Address of ECB SRSAUTH POSTs\nSRSATECB DS    F               Address of SRSAUTH task ECB\nSRSAREQ  DS    B               Request flags\nSRSAAUTH EQU   B'10000000'         Authorization request\nSRSAUNAU EQU   B'01000000'         Un-authorization request\nSRSATERM EQU   B'00100000'         Termination request\n         DS    0F              Expand to fullword boundry\nSRSABLKL EQU   *-SRSABLK\n         SPACE 5\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SRSAMODE": {"ttr": 15, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x006\\x00\\x98\\x10o\\x00\\x98\\x10o\\x11F\\x00\\x15\\x00\\x15\\x00\\x00\\xc4\\xe6\\xc4@@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-04-16T00:00:00", "modifydate": "1998-04-16T11:46:36", "lines": 21, "newlines": 21, "modlines": 0, "user": "DWD"}, "text": "         MACRO -- SRSAMODE -- SRS address mode switch\n&LABEL   SRSAMODE &MODE,&R=R15\n&HIBITON SETC  '=X''80000000'''\n         AIF   ('&MODE' NE '24' AND '&MODE' NE '31').ERR1\n         AIF   ('&R' EQ '').ERR2\n&SKIPIT  SETC  '$$$$'.'&SYSNDX'    Build end-label\n&NAME    SETC  '&LABEL'\n&NAME    LA    &R,&SKIPIT          Pick up address for mode switch\n         AIF   ('&MODE' EQ '24').NOAND\n         O     &R,&HIBITON         Set addr for 31-bit mode\n.NOAND   ANOP\n         BSM   R0,&R               BSM to set address mode\n&SKIPIT  DS    0H                  End of SRSAMODE processing\n         MEXIT\n.*\n.*       ERROR MACRO NOTES\n.*\n.ERR1    MNOTE 8,'ERROR: Invalid address mode specified for SRSAMODE'\n         MEXIT\n.ERR2    MNOTE 8,'ERROR: Invalid work register specified for SRSAMODE'\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SRSAUTH": {"ttr": 13061, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\r\\x00X\\x00\\x976O\\x01\\x05\\x19_\\x17\\x07\\x00t\\x00u\\x00\\x00\\xc4\\xe6\\xc4@@@@@@@'", "ispf": {"version": "01.13", "flags": 0, "createdate": "1997-12-30T00:00:00", "modifydate": "2005-07-14T17:07:58", "lines": 116, "newlines": 117, "modlines": 0, "user": "DWD"}, "text": "*PROCESS RENT,FLAG(PAGE0)                                          V121\nSRSAUTH TITLE '- SYSOUT Retrieval Services (SRS) State-switch rtn'\nSRSAUTH CSECT , ATTR=RENT,REUS,REFR\nSRSAUTH AMODE 31\nSRSAUTH RMODE ANY\n*=====================================================================*\n*                                                                     *\n*  MODULE NAME:  SRSAUTH                                              *\n*                                                                     *\n*  DESCRIPTIVE-NAME: SYSOUT Retrieval Services (SRS) State-switch rtn *\n*                                                                     *\n*  STATUS: MVS/SP Version 4 and higher                                *\n*                                                                     *\n*  OPERATION:                                                         *\n*                                                                     *\n*    SRSAUTH provides APF authorization/unauthorization switching     *\n*    services to SRSTASK.  SRSTASK must be supervisor, key zero to    *\n*    issue the SAPI request to JES2.  It switches to key 8, problem   *\n*    state to call the user program to process each spool record.     *\n*                                                                     *\n*    The SRSDRVR program attaches one SRSAUTH and passes its ECB      *\n*    address to the SRSTASK program.                                  *\n*                                                                     *\n*                                                                     *\n*    ATTRIBUTES:                                                      *\n*                                                                     *\n*      Location:  resident in own address space                       *\n*      State:  problem & supervisor, must be APF authorized           *\n*      Amode:  31-bit                                                 *\n*      Rmode:  Any                                                    *\n*      Key:  key 0,8                                                  *\n*      Mode:  task                                                    *\n*      Serialization: none                                            *\n*      Type:  Reentrant                                               *\n*                                                                     *\n*  Written By: Dave Danner                                      @A11202\n*              Summit Technical Services, Inc.                  @A11202\n*                                                               @A11202\n*          January, 1998                                              *\n*                                                                     *\n*  Change log:                                                        *\n*=====================================================================*\n         USING SRSAUTH,R15          Temporary base\n         B     START                Branch around eyecatcher\n         DC    C'SRSAUTH_&SYSDATE._&SYSTIME. '                     V121\n         DC    C'COPYRIGHT 1998-2004 DAVID W DANNER '              V121\n         DC    C'ALL RIGHTS RESERVED'                              V121\nSTART    DS    0H\n         DROP  R15                  Drop temporary addressability\n         SAVE  (14,12)              Save regs\n         LR    R12,R15              Set base register\n         USING SRSAUTH,R12\n         LR    R6,R1                Save address of authorization parm\n         USING SRSABLK,R6           And address it\n         MODESET MODE=SUP           Get supervisor state\n         MODESET EXTKEY=ZERO        Get PSW key zero\n* Locate our JSCB\n         L     R15,PSATOLD-PSA(,0)     Get our TCB address\n         L     R5,TCBJSCB-TCB(,R15)    Get our JSCB address\n         USING IEZJSCB,R5\n         L     R5,JSCBACT              Get address of active JSCB\n         TM    JSCBOPTS,JSCBAUTH    Are we APF authorized ?\n         BNO   NOAPF                No, can't continue\n*        WTO   'SRS700I SRS Authorization Services active'\n*\nWAIT     DS    0H\n         WAIT  ECB=SRSAAECB         Wait for request\n         NI    SRSAAECB,X'FF'-ECBPOST  Turn off post bit\n         TM    SRSAREQ,SRSAAUTH     Authorization request ?\n         BO    AUTH                 Yes, do it\n         TM    SRSAREQ,SRSAUNAU     Un-authorization request ?\n         BO    UNAUTH               Yes, do it\n         TM    SRSAREQ,SRSATERM     Termination request ?\n         BO    TERM                 Yes, do it\n         WTO   'SRS710E Unknown request type - SRSAUTH'\n         B     REQDONE\n         SPACE 3\nAUTH     DS    0H\n**       WTO   'SRSAUTH - APF Authorization ON'\n         OI    JSCBOPTS,JSCBAUTH    Make task authorized\n         B     REQDONE\n         SPACE 3\nUNAUTH   DS    0H\n**       WTO   'SRSAUTH - APF Authorization OFF'\n         NI    JSCBOPTS,X'FF'-JSCBAUTH    Make task unauthorized\n         B     REQDONE\n         SPACE 3\nREQDONE  DS    0H\n         POST  SRSARECB             Let requestor know we are done\n         B     WAIT                 Wait for next request\n         SPACE 3\nNOAPF    DS    0H\n         WTO   'SRS711E SRSAUTH not invoked APF authorized',DESC=1\n         SPACE 3\nTERM     DS    0H\n*        WTO   'SRS701I SRS Authorization Services terminated'     V134\n         RETURN (14,12),,RC=0        RETURN TO CALLER\n* MAPPING MACROS\n         SRSABLK                   MAP SRS Task Data Block\n         PRINT NOGEN\n         IHAPSA                    MAP PSA\n         IHAASCB                   MAP ASCB\n         CVT   DSECT=YES           MAP CVT\n         IKJTCB\n         IEFJESCT\n         IEFJSSIB\n         IEZJSCB\nCSCB     DSECT\n         IEECHAIN                  MAP CSCB\n         DCBD DSORG=PS             MAP DCB\n         IHAECB\n         IEZCOM\n         IEZCIB\n         IHASDWA\n         YREGS\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SRSDATA": {"ttr": 260, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00X\\x00\\x976O\\x01\\x046?\\x14\\x01\\x00!\\x00\\x1c\\x00\\x00\\xc4\\xe6\\xc4@@@@@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1997-12-30T00:00:00", "modifydate": "2004-12-28T14:01:58", "lines": 33, "newlines": 28, "modlines": 0, "user": "DWD"}, "text": "         MACRO\n         SRSDATA &DSECT=YES\n         SPACE 3\n         AIF   ('&DSECT' EQ 'NO').GENLBL\nSRSDATA DSECT\n         AGO   .GENAREA\n.GENLBL  ANOP\nSRSDATA DS     0F\n.GENAREA ANOP\nSRSSSOB  DS    F               Pointer to SSOB (mapped by IEFSSSO)\nSRSREC   DS    F               Pointer to record returned\nSRSRECL  DS    H               Length of record returned\n         DS    H               Reserved for future use\nSRSUSER  DS    F               Reserved for user\nSRSTOKNA DS    F               Address of 24-byte token\nSRSFLAGS DS    BL1'0'          Status bits\nSRSFIRST EQU   B'10000000'     New dataset call\nSRSEOF   EQU   B'01000000'     End-of-file call\nSRSINIT  EQU   B'00100000'     Task initialization\nSRSTERM  EQU   B'00010000'     Task termination\nSRSDREC  EQU   B'00001000'     Data record call\nSRSDSEP  EQU   B'00000100'     Separator record call               V121\n*                              Note: When SRSDSEP is on, SRSDREC   V121\n*                                    will also be set.             V121\nSRSFLGB7 EQU   B'00000010'     Reserved for future use\nSRSFLGB8 EQU   B'00000001'     Reserved for future use\n*                                                                  V120\nSRSPARM  DS    CL80            Despooling program parameters       V120\nSRSPARML DS    XL1             Length of parms in SRSPARM          V120\n         DS    0F              Expand to fullword boundry\nSRSDATAL EQU   *-SRSDATA\n         SPACE 5\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SRSDRVR": {"ttr": 17921, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01c\\x00C\\x00\\x976O\\x01\\x060\\x0f\\x177\\x05C\\x03\\xba\\x00\\x00\\xc4\\xe6\\xc4@@@@@@@'", "ispf": {"version": "01.99", "flags": 0, "createdate": "1997-12-30T00:00:00", "modifydate": "2006-10-27T17:37:43", "lines": 1347, "newlines": 954, "modlines": 0, "user": "DWD"}, "text": "*PROCESS RENT,FLAG(PAGE0)                                          V121\nSRSDRVR TITLE '- SYSOUT Retrieval Services (SRS) Driver Module'\nSRSDRVR CSECT , ATTR=RENT,REUS,REFR\nSRSDRVR AMODE 31\nSRSDRVR RMODE ANY                                                  V121\n*=====================================================================*\n*                                                                     *\n*  MODULE NAME:  SRSDRVR                                              *\n*                                                                     *\n*  DESCRIPTIVE-NAME: SYSOUT Retrieval Services (SRS) Driver Module    *\n*                                                                     *\n*  STATUS: OS/390 JES2 Release 3 and higher                           *\n*                                                                     *\n*  OPERATION:                                                         *\n*                                                                     *\n*    This module is part of SYSOUT Retrieval Services, generalized    *\n*    external interface to data residing on the JES spool.  SRS uses  *\n*    the SYSOUT Application Program Interface (SAPI) to request       *\n*    spool data from JES2.                                            *\n*                                                                     *\n*    SRSDRVR attaches the SRSTASK subprogram to setup and manage      *\n*    the SRS request to JES, and to handle the actual de-spooling     *\n*    selected SYSOUT.                                                 *\n*                                                                     *\n*    The following dataset selection criteria is supported:           *\n*                                                                     *\n*       1) SYSOUT class                                               *\n*       2) Jobname                                                    *\n*       3) Destination                                                *\n*       4) Forms ID                                                   *\n*       5) JES jobid                                                  *\n*       6) Writer name                                                *\n*       7) DDNAME                                                  V120\n*                                                                     *\n*    Selection criteria can be specified as a PARM to the SRSDRVR  V121\n*    program.  Note that reading parms from SYSPARM DD dataset     V121\n*    is no longer supported.                                       V121\n*                                                                     *\n*    The PARM is specified as follows:                                *\n*                                                                     *\n*    P=pgnmane        The program that will be called to despool      *\n*                     the data (default: SRSGENER)                 V111\n*PPARM=parms          Parameter list passed to the despooling pgm  V120\n*    Q=class          The output class to be selected                 *\n*    J=jobname        The jobname to be selected                      *\n*    D=destination    The destination to be selected                  *\n*    F=forms          The forms queue to be selected                  *\n*   JI=jobid          The 8-character JES jobid to be selected        *\n*                     NOTE: In SRS 1.1.2 and higher, STC and TSU   V112\n*                           ARE honored in addition to JOB         V112\n*    W=writername     The writer name to be selected                  *\n*DDNAME=ddname        The DDNAME of the spool data set to be sel'd V120\n*  LIM=select-limit   The maximum number of datasets to despool       *\n* WAIT=YES or NO      Whether the task is to wait for datasets        *\n*                     or end when no more datasets remain             *\n* DISP=KEEP or DELETE The disposition of despooled datasets        V111\n*                     (default: DELETE)                            V111\n* STATUS=HELD         The status of datasets to be selected     @A11102\n*        NONHELD      (default: NONHELD)                        @A11102\n*        ALL                                                    @A11102\n*                                                                     *\n*    Selection parameters are passed un-edited to SAPI.  Wildcard     *\n*    and masking parameters can be specified wherever supported by    *\n*    SAPI.                                                            *\n*                                                                     *\n*    In addition, SRSDRVR handles STOP/MODIFY commands issued by      *\n*    the operator.                                                    *\n*                                                                     *\n*    NOTES:                                                           *\n*                                                                     *\n*      Currently, only one SYSOUT selection criteria combination can  *\n*      be specified, and only one SRSTASK can be attached per SRSDRVR.*\n*                                                                     *\n*    ATTRIBUTES:                                                      *\n*                                                                     *\n*      Location:  resident in own address space                       *\n*      State:  problem & supervisor, must be APF authorized           *\n*      Amode:  31-bit                                                 *\n*      Rmode:  24-bit                                                 *\n*      Key:  key 0,8                                                  *\n*      Mode:  task                                                    *\n*      Serialization: none                                            *\n*      Type:  Reentrant                                               *\n*                                                                     *\n*  Written By: Dave Danner                                      @A11202\n*              Summit Technical Services, Inc.                  @A11202\n*                                                                     *\n*          January, 1998                                              *\n*                                                                     *\n*  Change log:                                                        *\n*    DWD 04/98: Add DISP=KEEP/DELETE support                       V111\n*               Remove JES2 macros                                 V111\n*    DWD 03/99: STATUS= support                                 @A11102\n*    DWD 07/99: STC/TSU support for JOBID (JI=) parameter          V112\n*    DWD 03/02: 7-digit job numbers in JOIID                    @A11206\n*    DWD 09/03: Select by DDNAME                                   V120\n*               Support for parameter list passed to despool pgm   V120\n*    DWD 12/04: Separator record support                           V121\n*               Expand parm keywords; support abbreviated kwds     V121\n*               Support installation defaults                      V121\n*    DWD 10/06: Expand DEST to 18 characters                    @A12101\n*=====================================================================*\n         USING SRSDRVR,R15          Temporary base\n         B     START                Branch around eyecatcher\n         DC    C'SRSDRVR_&SYSDATE._&SYSTIME. '                     V121\n         DC    C'COPYRIGHT 1998-2005 DAVID W DANNER '              V121\n         DC    C'ALL RIGHTS RESERVED'                              V121\nSTART    DS    0H\n         DROP  R15                  Drop temporary addressability\n         BAKR  R14,0                Save environment\n         LR    R12,R15              Set base register\n         LR    R6,R1                Save pointer to parms\n         USING SRSDRVR,R12\n         LA    R11,4095(R12)        Set second                     V120\n         LA    R11,1(R11)           ...base register               V120\n         USING SRSDRVR+4096,R11                                    V120\n*\n         STORAGE OBTAIN,LENGTH=SRSDLEN,LOC=ANY Get a work area     V121\n         LR    R4,R1                Copy work area address\n         LA    R5,SRSDLEN           Get length of work area\n         SLR   R15,R15              Zero source length for MVCL\n         LR    R14,R15              Zero source address for MVCL\n         MVCL  R4,R14               Clear entire work area\n         LR    R13,R1               Point to my save area\n         MVC   4(4,R13),=C'F1SA'    Indicate linkage stack in use\n         USING SRSDWORK,R13         Address work area\n*\n         MVC   WTOBUFF+2(L'SRS500I),SRS500I\n         LA    R15,L'SRS500I       Get length of message\n         STH   R15,WTOBUFF         Save length in WTO\n         BAL   R9,SRSDWTO          Issue the message\n*\n         BAL   R10,SETUP           Perform general setup functions\n         LTR   R4,R15              Was setup successfull ?\n         BNZ   RETURN              No, quit now\n         BAL   R10,PARSPARM        Parse input parms               V121\n         LTR   R4,R15              Was parse successfull ?\n         BNZ   RETURN              No, quit now\n         MODESET MODE=SUP          Get supervisor state\n*=====================================================================*\n* Attach a writer subtask to process the request.                     *\n*=====================================================================*\n         BAL   R10,ATTWTR\n         LTR   R4,R15                  Attach successful?          V121\n         BNZ   RETURN                  No, quit now                V121\n         SPACE 2\n*=====================================================================*\n* Show the status of the writer.                                      *\n*=====================================================================*\n         BAL   R10,WTRSTAT\n         SPACE 2\n*=====================================================================*\n* Wait for STOP/MODIFY command.                                       *\n*=====================================================================*\nWAITCHEK DS    0H\n         TM    STATUS,NOWAIT           Are we waiting for datasets\n         BO    TESTSUB                 No, skip CIB setup\n* Initialize stc/operator communication.\nWAITSM   DS    0H\n         MVC   WTOBUFF(EXTPARML),EXTPARM\n         EXTRACT RESPAREA,MF=(E,WTOBUFF)\n         L     R8,RESPAREA             Load comm area address\n         USING COMLIST,R8\n         ICM   R3,15,COMCIBPT          Obtain address of CIB\n         BZ    NOSTCIB                 If none, continue\n         QEDIT ORIGIN=COMCIBPT,BLOCK=(3)  Free start CIB\nNOSTCIB  DS    0H\n         QEDIT ORIGIN=COMCIBPT,CIBCTR=2   Set CIB limit\n         L     R15,COMECBPT            Get address of comm ecb\n         ST    R15,ECBCOMM             Save in ecb list\nWAITREP  DS    0H\n         L     R1,ECBCOMM          Get address of comm ecb\n         WAIT  1,ECBLIST=ECBLIST   Wait for STOP/MOD or task end\n         L     R15,ECBCOMM         Get address of comm ECB\n         TM    0(R15),ECBPOST      Was it posted ?\n         BNO   TESTSUB             No, SRSTASK ended\n*=====================================================================*\n* Process the STOP or MODIFY command.                                 *\n*=====================================================================*\nPROCCIB  DS    0H\n         OI    STATUS,STOPMOD      Flag STOP/MODIFY processing\n         MODESET EXTKEY=ZERO,SAVEKEY=(2)  Get PSW key zero\n         NI    0(R15),X'FF'-(ECBWAIT+ECBPOST)  Clear wait & post bits\n         MODESET KEYREG=(2)        Reset PSW key\n         L     R7,COMCIBPT         Get address of CIB\n         USING CIB,R7\n         CLI   CIBVERB,CIBSTOP     STOP command issued ?\n         BE    SHUTDOWN            Yes, shut it down\n*=====================================================================*\n* Process MODIFY command.                                             *\n*=====================================================================*\n         CLC   =C'STOP',CIBDATA    MODIFY STOP ISSUED ?\n         BE    SHUTDOWN            Yes, shut it down\n         CLC   =C'SHUTDOWN',CIBDATA  MODIFY SHUTDOWN ISSUED ?\n         BE    SHUTDOWN            Yes, shut it down\n         CLC   =C'STATUS',CIBDATA  Modify STATUS issued ?\n         BE    SHOWSTAT            Yes, issue status message\n         MVC   WTOBUFF+2(L'SRS530E),SRS530E\n         LA    R15,L'SRS530E       Get length of message\n         STH   R15,WTOBUFF         Save length in WTO\n         BAL   R9,SRSDWTO          Issue the message\n         B     FREECIB             Free the CIB and shutdown\n         SPACE 2\nSHUTDOWN DS    0H\n         OI    STATUS,STOP         Set stop bit\n         MVC   WTOBUFF+2(L'SRS502I),SRS502I\n         LA    R15,L'SRS502I       Get length of message\n         STH   R15,WTOBUFF         Save length in WTO\n         BAL   R9,SRSDWTO          Issue the message\n         B     FREECIB             Free the CIB\n         SPACE 2\nSHOWSTAT DS    0H\n         L     R1,TBLKFRST         Get address of SRSTBLK\n         BAL   R10,WTRSTAT         And show its status\n         SPACE 2\nFREECIB  DS    0H\n         NI    STATUS,X'FF'-STOPMOD  STOP/MODIFY processing done\n         QEDIT ORIGIN=COMCIBPT,BLOCK=(3)  Free the CIB\n         DROP  R7\n         TM    STATUS,STOP         Stop requested ?\n         BNO   WAITSM              No, go wait again\n*=====================================================================*\n* Post SRSTASK, requesting shutdown.\n*=====================================================================*\nTESTSUB  DS    0H\n         SLR   R4,R4               Set RC=0\n         ICM   R6,15,TBLKFRST      Get address of first SRSTBLK    V121\n         BZ    RETURN              Skip if no subtasks attached    V121\nSHUTTASK DS    0H\n         USING SRSTBLK,R6          Addressability to block\n         TM    SRSTECB,ECBPOST     Did task already end ?\n         BO    DODETACH            Yes, detach it\n         TM    SRSTFLAG,SRSTNOWT   Is task waiting for datasets ?\n         BO    SKIPPOST            No, just wait for task to end\n         OI    SRSTFLAG,SRSTSHUT   Indicate SHUTDOWN requested\n         POST  SRSTECBX            POST subtask\nSKIPPOST DS    0H\n         WAIT  1,ECB=SRSTECB       Wait for subtask to complete\nDODETACH DS    0H\n         ICM   R15,7,SRSTECB+(ECBCCCNT-ECB) SRSTASK RC=0, noabend?\n         BZ    TASKOK              Yes, leave RC\n         LA    R4,24               No, set RC=24\nTASKOK   DS    0H\n         DETACH SRSTTCB            Detach subtask\n         C     R4,SRSTRC           Higher RC ?\n         BNL   FREETBLK            Branch if not\n         L     R4,SRSTRC           Set new RC\nFREETBLK DS    0H\n         L     R5,SRSTNEXT         Point at next block\n         STORAGE RELEASE,LENGTH=SRSTBLKL,ADDR=(6) Free work TBLK   V121\n         LTR   R6,R5               Get next block\n         BNZ   SHUTTASK            Branch back if more\n         DROP  R6\n         SPACE 5\nRETURN   DS    0H\n         TM    STATUS,OPSTABL      SRSOPTS module loaded?          V121\n         BZ    NOOPTDEL            No, don't DELETE                V121\n         DELETE EPLOC=OPTSTAB      Delete options table            V121\nNOOPTDEL DS    0H                                                  V121\n         LR    R1,R13              Save getmained storage address\n         STORAGE RELEASE,LENGTH=SRSDLEN,ADDR=(1) Free work area    V121\n         LR    R15,R4              Set RC\n         PR                        Return to caller\n         EJECT\n*=====================================================================*\n* GENERAL SETUP ROUTINE.                                              *\n*  1) Initialize stc/operator communication.                          *\n*=====================================================================*\nSETUP    DS    0H\n* Initialize variables.\n         LA    R15,TBLKFRST            Get last block pointer\n         ST    R15,TBLKPLST            And save it\n         LA    R15,1                   Set the writer ID\n         STH   R15,XWTRID              And save it\n         L     R15,PSAAOLD-PSA(,0)     Point to ASCB\n         ICM   R15,15,ASCBJBNI-ASCB(R15) Get batch name address\n         BZ    NOBATJ                  If not batch, skip flag set\n         OI    STATUS,BATCHJ           Flag running as batch job   V112\nNOBATJ   DS    0H\n         SLR   R15,R15             Set RC=0\nSETUPX   DS    0H\n         BR    R10                 Return to main routine\n         EJECT\n*==================================================================\n* Process the PARM= keywords from the EXEC statement.\n*==================================================================\nPARSPARM DS    0H                                                  V121\n* Build the keyword table                                          V121\n         LA    R1,SRSKEYTB         Point at start of table         V121\n         USING SRSKW,R1                                            V121\n*==================================================================V121\n* Define all supported keywords via the SRSKEY macro.              V121\n* The format is as follows:                                        V121\n* SRSKEY                                                           V121\n*    KEYWORD=keyword                                               V121\n*       Specifies the full name of the keyword                     V121\n*    LOC=temp-storage-loc                                          V121\n*       Specifies the temporary storage location to parse the      V121\n*       keyword value into                                         V121\n*    ABBREV=n                                                      V121\n*       Specifies that the keyword can be abbreviated by           V121\n*       specifying only the first n characters                     V121\n*    DEFAULT=default-value-loc                                     V121\n*       Specifies the location of the default value for this       V121\n*       keyword which is used if the keyword is not specified      V121\n*       by the user                                                V121\n*    TBLK=TBLK-loc                                                 V121\n*       Specifies the location in the TBLK to move either the      V121\n*       keyword value specified by the user or the default value   V121\n*       if none is specified.  If TBLK= is specified, the          V121\n*       appropriate value is simply moved into the TBLK without    V121\n*       any editing or validation.  TBLK= and ROUTINE= are         V121\n*       mutually exclusive.                                        V121\n*    ROUTINE=routine-address                                       V121\n*       Specifies the address of a routine to process the keyword. V121\n*       The routine is responsible for building the entry in the   V121\n*       TBLK that corresponds to the keyword.  TBLK= and ROUTINE=  V121\n*       are mutually exclusive.                                    V121\n*==================================================================V121\n         SRSKEY KEYWORD=PROGRAM,LOC=SRSUPGMN,ABBREV=1,             V121+\n               TBLK=SRSTPGMN,DEFAULT=SRSOPGMN                      V121\n         SRSKEY KEYWORD=CLASS,LOC=SRSUCLAS,                        V121+\n               TBLK=SRSTCLAS,DEFAULT=SRSOCLAS                      V121\n         SRSKEY KEYWORD=Q,LOC=SRSUCLAS,                            V121+\n               TBLK=SRSTCLAS,DEFAULT=SRSOCLAS                      V121\n         SRSKEY KEYWORD=JOBNAME,LOC=SRSUJOBN,ABBREV=1,             V121+\n               TBLK=SRSTJOBN,DEFAULT=SRSOJOBN                      V121\n         SRSKEY KEYWORD=DEST,LOC=SRSUDEST,ABBREV=1,                V121+\n               TBLK=SRSTDEST,DEFAULT=SRSODEST                      V121\n         SRSKEY KEYWORD=FORMS,LOC=SRSUFORM,ABBREV=1,               V121+\n               TBLK=SRSTFORM,DEFAULT=SRSOFORM                      V121\n         SRSKEY KEYWORD=JOBID,LOC=SRSUJBID,ABBREV=4,               V121+\n               ROUTINE=PROCJBID                                    V121\n         SRSKEY KEYWORD=JI,LOC=SRSUJBID,                           V121+\n               ROUTINE=PROCJBID                                    V121\n         SRSKEY KEYWORD=WRITER,LOC=SRSUWTRN,ABBREV=1,              V121+\n               TBLK=SRSTWTRN,DEFAULT=SRSOWTRN                      V121\n         SRSKEY KEYWORD=LIMIT,LOC=SRSULIMT,ABBREV=3,               V121+\n               ROUTINE=PROCLIMT,DEFAULT=SRSOLIMT                   V121\n         SRSKEY KEYWORD=WAIT,LOC=SRSUWAIT,                         V121+\n               ROUTINE=PROCWAIT,DEFAULT=SRSOWAIT                   V121\n         SRSKEY KEYWORD=DISP,LOC=SRSUDISP,                         V121+\n               ROUTINE=PROCDISP,DEFAULT=SRSODISP                   V121\n         SRSKEY KEYWORD=STATUS,LOC=SRSUSTAT,ABBREV=4,              V121+\n               ROUTINE=PROCSTAT,DEFAULT=SRSOSTAT                   V121\n         SRSKEY KEYWORD=SEP,LOC=SRSUSEPO,                          V121+\n               ROUTINE=PROCSEPO,DEFAULT=SRSOSEPO                   V121\n         SRSKEY KEYWORD=SEPID,LOC=SRSUSEPI,ABBREV=4,               V121+\n               TBLK=SRSTSEPI,DEFAULT=SRSOSEPI                      V121\n         SRSKEY KEYWORD=DDNAME,LOC=SRSUDDNM,ABBREV=2,              V121+\n               TBLK=SRSTDDNM                                       V121\n         SRSKEY KEYWORD=PPARM,LOC=SRSUPPRM,                        V121+\n               TBLK=SRSTPPRM,DEFAULT=SRSOPPRM                      V121\n         SRSKEY KEYWORD=OPTS,LOC=SRSUOPTS,ABBREV=3                 V121\n         MVC    SRSKW(4),=X'FFFFFFFF'  Set end of table marker     V121\n         DROP  R1                                                  V121\n*                                                                  V121\n*==================================================================V121\n* In this phase of processing, we scan the input parm provided     V121\n* by the user and move the keyword values supplied to a temporary  V121\n* location.                                                        V121\n*==================================================================V121\n         L     R6,0(,R6)           Point at length of parms        V121\n         LH    R15,0(,R6)          Get length of parms             V121\n         LTR   R15,R15             Any parms ?                     V121\n         BZ    PARSDONE            No, skip parse                  V121\n         LA    R2,2(R6)            Point at first char in parm     V121\n         LA    R7,1(R15,R6)        Point at last char in parm      V121\nCHECKOP  DS    0H\n         CR    R2,R7               Any more operands ?\n         BH    PARSDONE            No, done with parse\n* Find the last character in the operand and the '='               V121\n         LA    R3,1(R2)            Point at next character\n         SLR   R5,R5               Init equals pointer             V121\nFINDEND  DS    0H\n         CR    R3,R7               End of operand ?\n         BH    GOTEND              Yes, good\n         TM    PARSSTAT,PARSPARN   Looking for right parenthesis ? V120\n         BZ    NOPCHECK            No, check for comma             V120\n         CLI   0(R3),C')'          End of operand ?                V120\n         BNE   NEXTCHAR            No, keep looking                V120\n         NI    PARSSTAT,X'FF'-PARSPARN  Reset parenthesis flag     V120\n         B     NEXTCHAR            Check for comma next            V120\nNOPCHECK DS    0H                                                  V120\n         CLI   0(R3),C'='          Equals found?                   V121\n         BNE   CKCOMM              No, keep checking               V121\n         LR    R5,R3               Save equals location            V121\n         B     NEXTCHAR            Check next char                 V121\nCKCOMM   DS    0H                                                  V121\n         CLI   0(R3),C','          End of operand ?\n         BE    GOTEND              Yes, good\n         CLI   0(R3),C'('          Operand with parenthesis ?      V120\n         BNE   NEXTCHAR            No, keep looking for comma      V120\n         OI    PARSSTAT,PARSPARN   Flag right parenthesis needed   V120\nNEXTCHAR DS    0H                                                  V120\n         LA    R3,1(R3)            Point at next char\n         B     FINDEND             And check it\nGOTEND   DS    0H\n         BCTR  R3,0                Point at last character in op\n         LR    R4,R3               Copy to work reg\n* At this point...                                                 V121\n* R2 points at the beginning of the keyword=value string           V121\n* R3/R4 points at the end of the keyword=value string              V121\n* R5 points at the equals sign in the keyword=value string         V121\n         ST    R2,PARSOPST         Save start of operand           V112\n         ST    R3,PARSOPEN         Save end of operand             V112\n         LTR   R5,R5               Equals sign found?              V121\n         BZ    PARSERR             No, error                       V121\n         TM    PARSSTAT,PARSPARN   Were we looking for a rt paren? V120\n         BZ    NOPCHEC2            No, skip check                  V120\n         CLI   0(R3),C')'          Did we find one ?               V120\n         BNE   PARSERR             No, error                       V120\nNOPCHEC2 DS    0H                                                  V120\n* Locate keyword in keyword table                                  V121\n         SR    R5,R2               Calculate length of keyword     V121\n         LA    R8,SRSKEYTB         Point at start of table         V121\n         USING SRSKW,R8                                            V121\n         SLR   R15,R15             Clear work reg                  V121\nKWDLOOP  DS    0H                                                  V121\n         CLC   SRSKW(4),=X'FFFFFFFF'  At end of table?             V121\n         BE    PARSERR             Yes, invalid keyword            V121\n         IC    R15,SRSKWNAL        Get length of keyword           V121\n         CR    R5,R15              User kwd len > table kwd len?   V121\n         BH    NEXTKWD             Yes, can't match                V121\n         IC    R15,SRSKWSIG        Get min (abbrev) length         V121\n         CR    R15,R5              Min kwd len > user kwd len      V121\n         BH    NEXTKWD             Yes, can't match                V121\n         L     R6,SRSKWNAM         Get addr of kwd name            V121\n         LR    R14,R5              Copy kwd length                 V121\n         BCTR  R14,0               Prep for execute                V121\n         EX    R14,CLCKWD          Keyword match?                  V121\n         BNE   NEXTKWD             No, check next keyword          V121\n         LA    R2,1(R5,R2)         Point at keyword value          V121\n         SR    R4,R2               Get length of value (minus 1)   V121\n         LA    R4,1(R4)            Get true length                 V121\n         LTR   R4,R4               Null operand?                   V121\n         BNP   NOVPAR              Yes, skip paren check           V121\n         CLI   0(R2),C'('          Is kwd value inside parens?     V121\n         BNE   NOVPAR              No, skip adjustment             V121\n         LA    R2,1(R2)            Point at 1st char inside paren  V121\n         SH    R4,=H'2'            And fix up length               V121\nNOVPAR   DS    0H                                                  V121\n         IC    R15,SRSKWLOL        Get max length of value         V121\n         CR    R4,R15              User value greater than max?    V121\n         BH    PARSERR             *temp*                          V121\n         L     R6,SRSKWLOC         Get location address            V121\n         CLI   0(R6),C' '          Keyword already specified?      V121\n         BH    PARSDUP             Yes, error                      V121\n         MVI   0(R6),C' '          Init first char to blank        V121\n         SH    R15,=H'2'           One for first char & one for EX V121\n         BM    ONEBYTEF            Done if 1-byte field            V121\n         EX    R15,MVCBLNK         Init rest of value to blanks    V121\nONEBYTEF DS    0H                                                  V121\n         LTR   R4,R4               Null operand?                   V121\n         BNP   NEXTOP              Yes, leave blanks               V121\n         BCTR  R4,0                Prep for execute                V121\n         EX    R4,MVCVAL           Move value                      V121\n         B     NEXTOP              Process next parm opt           V121\nNEXTKWD  DS    0H                                                  V121\n         LA    R8,SRSKWL(R8)       Next kwd table entry            V121\n         B     KWDLOOP             Go check it                     V121\nCLCKWD   CLC   0(*-*,R6),0(R2)                                     V121\nMVCBLNK  MVC   1(*-*,R6),0(R6)                                     V121\nMVCVAL   MVC   0(*-*,R6),0(R2)                                     V121\n         DROP  R8                                                  V121\nNEXTOP   DS    0H\n         LA    R2,2(R3)            Point at next operand\n         B     CHECKOP             Check next operand\n         SPACE 3\nPARSDONE DS    0H\n         SLR   R15,R15             Set parse RC=0\n         BR    R10                 Return to main routine\n         SPACE 3\n* Syntax error in paramater list\nPARSERR  DS    0H\n         MVC   WTOBUFF+2(L'SRS520E),SRS520E\n         LA    R1,WTOBUFF+L'SRS520E+2 Point at end of base message V121\n         L     R2,PARSOPST         Restore pointer to operand      V112\n         L     R4,PARSOPEN         Restore pointer to end of op    V112\n         SR    R4,R2               Get length                      V112\n         EX    R4,MVCPARM          Move bad op into message\n         LA    R1,1(R1,R4)         Point after bad op              V121\n         LA    R15,WTOBUFF+2       Get start of WTO text           V121\n         SR    R1,R15              Calculate length of message     V121\n         STH   R1,WTOBUFF          Save length in WTO parm         V121\n         BAL   R9,SRSDWTO          Issue the message\n         LA    R15,8               Set parse RC=8\n         BR    R10                 Return to main routine\n         SPACE 3                                                   V121\n* Parameter previously specified                                   V121\nPARSDUP  DS    0H                                                  V121\n         MVC   WTOBUFF+2(L'SRS520E),SRS520E  Move basic msg        V121\n         LA    R1,WTOBUFF+L'SRS520E+2 Point at end of base message V121\n         L     R2,PARSOPST         Restore pointer to operand      V121\n         BCTR  R5,0                Prep keyword length for EX      V121\n         EX    R5,MVCPARM          Move bad op into message        V121\n         LA    R1,1(R1,R5)         Point after keyword             V121\n         MVC   0(23,R1),=C'= was already specified'                V121\n         LA    R1,23(R1)           Point after added text          V121\n         LA    R15,WTOBUFF+2       Get start of WTO text           V121\n         SR    R1,R15              Calculate length of message     V121\n         STH   R1,WTOBUFF          Save length in WTO parm         V121\n         BAL   R9,SRSDWTO          Issue the message               V121\n         LA    R15,8               Set parse RC=8                  V121\n         BR    R10                 Return to main routine          V121\nMVCPARM  MVC   0(*-*,R1),0(R2)                                     V121\n         EJECT\nATTWTR   DS    0H\n*=====================================================================*\n* ATTACH SRS SSI interface subtask.                                   *\n*  1) Load the default options module.                             V121\n*  2) Obtain storage for and build the SRSTBLK.                    V121\n*  3) Validate the option specified (either from the user-supplied V121\n*     PARMS or from the default options.                           V121\n*  4) Attach SRSTASK.                                              V121\n*=====================================================================*\n         SPACE 2\n         MVC   OPTSTAB,=CL8'SRSOPTS'  Set default SRSOPT name      V121\n         CLI   SRSUOPTS,C' '          Specified by user?           V121\n         BNH   NOUOPTS                No, keep default             V121\n         MVC   OPTSTAB+6(2),SRSUOPTS  Use SRSOPTxx from user       V121\nNOUOPTS  DS    0H                                                  V121\n         LA    R2,1                   Set possible error code      V121\n         LOAD  EPLOC=OPTSTAB,ERRET=OPTSERR   Load the module       V121\n         OI    STATUS,OPSTABL         Flag table loaded            V121\n         LR    R7,R0                  Copy default options addr    V121\n         USING SRSOPT,R7                                           V121\n         LA    R2,2                   Set possible error code      V121\n         SLL   R1,3                   Convert length to bytes      V121\n         CLM   R1,B'0011',=AL2(SRSOPTL)  Expected length ?         V121\n         BNE   OPTSERR                No, quit now                 V121\n         LA    R2,3                   Set possible error code      V121\n         CLC   =C'SRSOPT',SRSOEYE     Valid eye-catcher?           V121\n         BNE   OPTSERR                No, quit now                 V121\n         LA    R2,4                   Set possible error code      V121\n         CLI   SRSOLVL,SRSOMAC        Same level as SRSDRVR?       V121\n         BNE   OPTSERR                No, quit now                 V121\n*=====================================================================*\n* Build the SRSTBLK for the SRSTASK to be attached.                   *\n*=====================================================================*\n         STORAGE OBTAIN,LENGTH=SRSTBLKL,LOC=ANY Get stor for TBLK  V121\n         LR    R6,R1               Save block address\n         USING SRSTBLK,R6          Addressability to block\n         XC    SRSTBLK(SRSTBLKL),SRSTBLK   Clear block\n         MVC   SRSTBLKE,=CL8'SRSTBLK'  Set eye-catcher             V120\n         L     R15,TBLKPLST        Get old foward chain pointer\n         ST    R6,0(,R15)          Update new foward chain\n         LA    R15,SRSTNEXT        Get address of new last ptr\n         ST    R15,TBLKPLST        Save new foward chain pointer\n         LH    R15,XWTRID          Get the hex writer ID\n         CVD   R15,DOUBWORK        Make it decimal\n         LA    R15,1(R15)          Incrament task counter\n         STH   R15,XWTRID          Save new hex writer ID\n         OI    DOUBWORK+7,X'0F'    Fix up sign\n         UNPK  SRSTWRID,DOUBWORK+6(2)  Make it EBCDIC & put in SRSTBLK\n*==================================================================V121\n* Here we go back to the keyword table.  For keywords with TBLK=   V121\n* specified, we move the keyword setting to that location.  For    V121\n* keywords with ROUTINE= we call that routine to process the       V121\n* keyword.  If the keyword was specified by the user, we use the   V121\n* value copied to the temporary location.  Otherwise, we use the   V121\n* default value from the options table.                            V121\n*==================================================================V121\n*                                                                  V121\n         LA    R5,SRSKEYTB         Point at start of table         V121\n         USING  SRSKW,R5                                           V121\nTBLKLOOP DS    0H                                                  V121\n         CLC   SRSKW(4),=X'FFFFFFFF' End of table?                 V121\n         BE    TBLKDONE              Yes, all done                 V121\n         LH    R15,SRSKWTBK          Get TBLK offset               V121\n         LTR   R15,R15               Any specified?                V121\n         BNZ   TBLKFILL              Yes, copy value into TBLK     V121\n         ICM   R15,15,SRSKWRTN       Get routine address           V121\n         BZ    TBLKNEXT              If no routine, skip keyword   V121\n         BALR  R8,R15                Call routine to process kwd   V121\n         TM    STATUS,KEYERR         Error encountered ?           V121\n         BZ    TBLKNEXT              No, process next keyword      V121\n         LA    R15,8                 Set bad RC                    V121\n         B     ATTWTRX               And exit routine              V121\nTBLKFILL DS    0H                                                  V121\n         LA    R15,SRSTBLK(R15)      Get address in TBLK           V121\n         CLI   0(R15),C' '           Already filled in?            V121\n         BH    TBLKNEXT              Yes, nothing to do            V121\n         L     R14,SRSKWLOC          Get address of parsed value   V121\n         CLI   0(R14),X'00'          Was it specified?             V121\n         BNE   TBLKUSER              Yes, use it                   V121\n         LH    R14,SRSKWDEF          Get default offset            V121\n         LTR   R14,R14               Is there a default?           V121\n         BZ    TBLKNEXT              Not spec and no default       V121\n         LA    R14,SRSOPT(R14)       Get address in default table  V121\nTBLKUSER DS    0H                                                  V121\n         SLR   R1,R1                 Clear work reg                V121\n         IC    R1,SRSKWLOL           Get length of field in TBLK   V121\n         BCTR  R1,0                  Fix for execute               V121\n         EX    R1,MVCTBLK            Move value into TBLK          V121\nTBLKNEXT DS    0H                                                  V121\n         LA    R5,SRSKWL(R5)         Point to next entry           V121\n         B     TBLKLOOP              Process next keyword          V121\nTBLKDONE DS    0H                                                  V121\n         TM    STATUS,MSGLIM         Limit WTOs displayed ?\n         BZ    SPWTOALL              No, display all WTOs\n         OI    SRSTFLAG,SRSTWLIM     Set WTO limit option\nSPWTOALL DS    0H\n         CLI   SRSTPGMN,C' '         Despool pgm specified?        V121\n         BH    DSPGMOK               Yes, use it                   V121\n         MVC   SRSTPGMN,=CL8'SRSGENER' Set default                 V121\nDSPGMOK  DS    0H                                                  V121\n*==================================================================V121\n* If DISP=DELETE, check for at least some selection criteria.      V121\n* This is to prevent a user from inadvertently draining the spool! V121\n*==================================================================V121\n         TM    SRSTFLAG,SRSTKEEP   DISP=KEEP ?                     V121\n         BO    POK                 Yes, skip checks                V121\n         CLC   OPTSTAB,=CL8'SRSOPTS'  Special options in use?      V121\n         BNE   POK                 Yes, skip checks                V121\n         CLC   SRSTCLAS,SRSOCLAS   Was class specified ?           V121\n         BNE   POK                 Yes, process the request        V121\n         CLC   SRSTJOBN,SRSOJOBN   Was jobname specified ?         V121\n         BNE   POK                 Yes, process the request        V121\n         CLI   SRSTJBID,C' '       Was jobid specified ?           V121\n         BH    POK                 Yes, process the request        V121\n         CLC   =CL4'ALL',SRSTDEST  DEST=ALL specified ?         @A12101\n         BE    PDALL               Yes, skip DEST check            V121\n         CLC   SRSTDEST,SRSODEST   Was dest specified ?            V121\n         BNE   POK                 Yes, process the request        V121\nPDALL    DS    0H                                                  V121\n         CLC   SRSTFORM,=CL8'ALL'  FORMS=ALL specified ?           V121\n         BE    PFALL               Yes, skip FORMS check           V121\n         CLC   SRSTFORM,SRSOFORM   Was forms queue specified ?     V121\n         BNE   POK                 Yes, process the request        V121\nPFALL    DS    0H                                                  V121\n         CLC   SRSTWTRN,=CL8'ALL'  WRITER=ALL specified ?          V121\n         BE    PWALL               Yes, skip WRITER check          V121\n         CLC   SRSTWTRN,SRSOWTRN   Was writer name specified ?     V121\n         BNE   POK                 Yes, process the request        V121\nPWALL    DS    0H                                                  V121\n         MVC   WTOBUFF+2(L'SRS510E),SRS510E                        V121\n         LA    R15,L'SRS510E       Get length of message           V121\n         STH   R15,WTOBUFF         Save length in WTO              V121\n         BAL   R9,SRSDWTO          Issue the message               V121\n         LA    R15,8               Set RC=8                        V121\n         B     ATTWTRX             Termination                     V121\nPOK      DS    0H                                                  V121\n*=====================================================================*\n* Attach SRSTASK to establish the SAPI interface.                     *\n*=====================================================================*\n         MVC   WTOBUFF(ATTPARML),ATTPARM\n         LA    R1,SRSTBLK          Get address of SRSTASK block\n         ATTACH EP=SRSTASK,ECB=SRSTECB,SF=(E,WTOBUFF)\n         ST    R1,SRSTTCB          Save TCB address\n         LA    R15,SRSTECB         Get address of subtask ECB\n         ST    R15,ECBPTASK        Save in ECB list\n         OI    ECBPTASK,X'80'      Flag as last entry\n* Document writer attached\n         TM    STATUS,MSGLIM       Limit number of WTOs ?\n         BO    NO502I              Yes, skip SRS502I\n         MVC   WTOBUFF+2(L'SRS501I),SRS501I\n         LA    R15,L'SRS501I       Get length of message\n         STH   R15,WTOBUFF         Save length in WTO\n         MVC   WTOBUFF+13(2),SRSTWRID  Move in SRS task ID\n         BAL   R9,SRSDWTO          Issue the message\nNO502I   DS    0H\n         LR    R1,R6               Return SRSTBLK in R1\n         SLR   R15,R15             Set RC=0                        V121\nATTWTRX  DS    0H                                                  V121\n         BR    R10\nMVCTBLK  MVC   0(*-*,R15),0(R14)                                   V121\n         EJECT\nOPTSERR  DS    0H                                                  V121\n*==================================================================V121\n* Handle problems with the options table.  R2 identifies the error V121\n* 1 - LOAD failed                                                  V121\n* 2 - Invaid length                                                V121\n* 3 - Invalid module idetifier                                     V121\n* 4 - Assembled at different SRS level                             V121\n*==================================================================V121\n         MVC   WTOBUFF+2(L'SRS525E),SRS525E     Set basic msg      V121\n         MVC   WTOBUFF+2+SRS525EM(8),OPTSTAB    Add Module name    V121\n         BCTR  R2,0                 Get index                      V121\n         MH    R2,=AL2(OPTSERE-OPTSERS)                            V121\n         LA    R15,OPTSERS(R2)      Get branch address             V121\n         BR    R15                  Add specific error text        V121\n* R2 = 1 branches here                                             V121\nOPTSERS  DS    0H                                                  V121\n         MVC   WTOBUFF+L'SRS525E+2(L'SRS525E1),SRS525E1            V121\n         LA    R15,L'SRS525E+L'SRS525E1         Length of msg      V121\n         B     OPTSERRM                         Issue msg          V121\nOPTSERE  DS    0H                                                  V121\n* R2 = 2 branches here                                             V121\n         MVC   WTOBUFF+L'SRS525E+2(L'SRS525E2),SRS525E2            V121\n         LA    R15,L'SRS525E+L'SRS525E2         Length of msg      V121\n         B     OPTSERRM                         Issue msg          V121\n* R2 = 3 branches here                                             V121\n         MVC   WTOBUFF+L'SRS525E+2(L'SRS525E3),SRS525E3            V121\n         LA    R15,L'SRS525E+L'SRS525E3         Length of msg      V121\n         B     OPTSERRM                         Issue msg          V121\n* R2 = 4 branches here                                             V121\n         MVC   WTOBUFF+L'SRS525E+2(L'SRS525E4),SRS525E4            V121\n         LA    R15,L'SRS525E+L'SRS525E4         Length of msg      V121\nOPTSERRM DS    0H                                                  V121\n         STH   R15,WTOBUFF         Save length in WTO parm         V121\n         BAL   R9,SRSDWTO          Issue the message               V121\n         LA    R15,8               Set bad RC                      V121\n         B     ATTWTRX             And exit                        V121\n*==================================================================V121\n* Special routines to process unique keywords follow               V121\n*==================================================================V121\n*                                                                  V121\nPROCSEPO DS    0H                                                  V121\n*==================================================================V121\n* Process the SEP option                                           V121\n*==================================================================V121\n         LA    R2,SRSOSEPO         Point at default SEP option     V121\n         CLI   SRSUSEPO,C' '       User specify SEP= ?             V121\n         BNH   NOSPUSEP            No, leave default               V121\n         LA    R2,SRSUSEPO         Use user specification          V121\nNOSPUSEP DS    0H                                                  V121\n         CLI   0(R2),C' '          SEP= specified ?                V121\n         BNH   PROCSEPX            No, skip it                     V121\n         CLC   =CL7'NO',0(R2)      SEP=NO ?                        V121\n         BE    PROCSEPX            Yes, no flags to set            V121\n         MVI   SRSTSEPO,SRSTSEPG   Assume SEP=OUTGRP               V121\n         CLC   =CL7'OUTGRP',0(R2)  SEP=OUTGRP ?                    V121\n         BE    PROCSEPX            Yes, cool - finished            V121\n         CLC   =CL7'YES',0(R2)     SEP=YES ?                       V121\n         BE    PROCSEPX            Yes, cool - finished            V121\n         MVI   SRSTSEPO,SRSTSEPJ   Assume SEP=JOB                  V121\n         CLC   =CL7'JOB',0(R2)     SEP=JOB ?                       V121\n         BE    PROCSEPX            Yes, cool - finished            V121\n         MVI   SRSTSEPO,SRSTSEPD   Assume SEP=DATASET              V121\n         CLC   =CL7'DATASET',0(R2) SEP=DATASET ?                   V121\n         BE    PROCSEPX            Yes, cool - finished            V121\n         CLC   =CL7'DS',0(R2)      SEP=DATASET (abbrev form) ?     V121\n         BNE   PARMERR             No, parm error                  V121\nPROCSEPX DS    0H                                                  V121\n         BR    R8                  Return to mainline              V121\n*                                                                  V121\nPROCLIMT DS    0H                                                  V121\n*==================================================================V121\n* Process the LIMIT option                                         V121\n*==================================================================V121\n         LA    R2,SRSOLIMT         Point at default LIMIT          V121\n         CLI   SRSULIMT,C' '       User specify LIM= ?             V121\n         BNH   NOSPULIM            No, keep default                V121\n         LA    R2,SRSULIMT         Use user specification          V121\nNOSPULIM DS    0H                                                  V121\n         CLI   0(R2),C' '          Limit specified ?               V121\n         BNH   PROCLIMX            No, skip it                     V121\n         LA    R3,L'SRSULIMT-1(R2) Last char in LIMIT area         V121\n         CLI   0(R3),C' '          Last char a blank?              V121\n         BNE   LIMEND              No, already pointing at end     V121\n         LR    R1,R2               Copy first char addr            V121\n         SLR   R0,R0               Set function code for findblnk  V121\n         BAL   R9,FINDBLNK         Find blank char                 V121\n         BCTR  R1,0                Point at last char in limit     V121\n         LR    R3,R1               Save last char address          V121\nLIMEND   DS    0H                                                  V121\n         SR    R3,R2               Get length of limit (minus 1)   V121\n         EX    R3,MVCLIM1          Move to work area               V121\n         OC    FULLWORK(4),=X'F0F0F0F0' Force numeric              V121\n         EX    R3,CLCLIM           Validate numeric value          V121\n         BNE   PARMERR             If not numeric - error          V121\n         MVC   FULLWORK(4),=X'F0F0F0F0' Init work field            V121\n         LA    R1,FULLWORK+3       Last possible char              V121\n         SR    R1,R3               Backup length                   V121\n         EX    R3,MVCLIM2          Move to work area               V121\n         XC    DOUBWORK,DOUBWORK   Clear work area                 V121\n         PACK  DOUBWORK+5(3),FULLWORK(4)  Pack select limit        V121\n         CVB   R15,DOUBWORK        Make limit binary               V121\n         STH   R15,SRSTLIMT        And save in paramater block     V121\nPROCLIMX DS    0H                                                  V121\n         BR    R8                    Return to mainline            V121\nMVCLIM1  MVC   FULLWORK(*-*),0(R2)                                 V121\nCLCLIM   CLC   FULLWORK(*-*),0(R2)                                 V121\nMVCLIM2  MVC   0(*-*,R1),0(R2)                                     V121\n*                                                                  V121\nPROCWAIT DS    0H                                                  V121\n*==================================================================V121\n* Process the WAIT option                                          V121\n*==================================================================V121\n         LA    R2,SRSOWAIT           Point at default WAIT option  V121\n         CLI   SRSUWAIT,C' '         User specify WAIT= ?          V121\n         BNH   NOSPUWA               No, leave default             V121\n         LA    R2,SRSUWAIT           Use user specification        V121\nNOSPUWA  DS    0H                                                  V121\n         CLC   =CL3'YES',0(R2)       WAIT=YES ?                    V121\n         BE    PROCWAIX              Yes, allow wait               V121\n         CLC   =CL3'NO',0(R2)        WAIT=NO ?                     V121\n         BE    NOSPWAIT              No, disallow wait             V121\n         CLI   0(R2),C' '            Any option specified ?        V121\n         BH    PARMERR               Yes, it's invalid             V121\n         TM    STATUS,BATCHJ         Running as batch job ?        V121\n         BZ    PROCWAIX              If not batch, default to WAIT V121\nNOSPWAIT DS    0H                                                  V121\n         OI    SRSTFLAG,SRSTNOWT     Set no wait option            V121\n         OI    STATUS,NOWAIT         Set no wait option            V121\n         OI    STATUS,MSGLIM         Limit extraneous messages     V121\nPROCWAIX DS    0H                                                  V121\n         BR    R8                    Return to mainline            V121\n*                                                                  V121\nPROCDISP DS    0H                                                  V121\n*==================================================================V121\n* Process the DISP option                                          V121\n*==================================================================V121\n         LA    R2,SRSODISP           Point at default DISP option  V121\n         CLI   SRSUDISP,C' '         User specify DISP= ?          V121\n         BNH   NOSPUDS               No, leave default             V121\n         LA    R2,SRSUDISP           Use user specification        V121\nNOSPUDS  DS    0H                                                  V121\n         CLC   =CL6'DELETE',0(R2)    DISP=DELETE ?                 V121\n         BE    PROCDISX              Yes, cool                     V121\n         CLC   BLANKS(6),0(R2)       DISP= not specified ?         V121\n         BE    PROCDISX              Yes, treat as DELETE          V121\n         CLC   =CL6'KEEP',0(R2)      DISP=KEEP ?                   V121\n         BNE   PARMERR               No, it's invalid              V121\n         OI    SRSTFLAG,SRSTKEEP     Set KEEP option               V111\nPROCDISX DS    0H                                                  V121\n         BR    R8                    Return to mainline            V121\n*                                                                  V121\n*==================================================================V121\n* Process the STATUS option                                        V121\n*==================================================================V121\nPROCSTAT DS    0H                                                  V121\n         LA    R2,SRSOSTAT         Point at default STAT option    V121\n         CLI   SRSUSTAT,C' '       User specify STAT= ?            V121\n         BNH   NOSPUST             No, leave default               V121\n         LA    R2,SRSUSTAT         Use user specification          V121\nNOSPUST  DS    0H                                                  V121\n         CLC   =CL7'HELD',0(R2)    STATUS=HELD ?                   V121\n         BNE   SELNHLD             No, keep checkin                V121\n         OI    SRSTFLAG,SRSTSHLD   Flag HELD in TBLK               V121\n         B     PROCSTAX                                            V121\nSELNHLD  DS    0H                                                  V121\n         CLC   =CL7'ALL',0(R2)     STATUS=ALL ?                    V121\n         BNE   SELNALL             No, check NONHELD               V121\n         OI    SRSTFLAG,SRSTSHLD+SRSTSNHL Select HELD & NONHELD    V121\n         B     PROCSTAX                                            V121\nSELNALL  DS    0H                                                  V121\n         OI    SRSTFLAG,SRSTSNHL   Select NONHELD (default)        V121\n         CLC   =CL7'NONHELD',0(R2) STATUS=NONHELD ?                V121\n         BE    PROCSTAX            Yes, continue                   V121\n         CLC   BLANKS(6),0(R1)     Any other STATUS= ?             V121\n         BNE   PARMERR             Yes, it's invalid               V121\nPROCSTAX DS    0H                                                  V121\n         BR    R8                  Return to mainline              V121\n*                                                                  V121\n*==================================================================V121\n* Process the JOBID option                                         V121\n*==================================================================V121\nPROCJBID DS    0H                                                  V121\n         CLI   SRSTJBID,C' '         JOBID= already processed?     V121\n         BH    PROCJBIX              Yes, skip it                  V121\n         CLI   SRSUJBID,C' '         JOBID= specified ?            V121\n         BNH   PROCJBIX              No, skip it (no default)      V121\n*=================================================================*V121\n* Verify that the JOBID parameter is one of the following:         V121\n*                                                                  V121\n* Jn-Jnnnnnnn, JOn-JOnnnnnn, JOBn-JOBnnnnn                         V121\n* Sn-Snnnnnnn, STn-STnnnnnn, STCn-STCnnnnn                         V121\n* Tn-Tnnnnnnn, TSn-TSnnnnnn, TSUn-TSUnnnnn                         V121\n*                                                                  V121\n* Also, build the JOBID passed to the subtask using the            V121\n* 1-character prefix (i.e. pass 'J1234' instead of 'JOB1234').     V121\n*=================================================================*V121\n         LA    R2,SRSUJBID         Addr of JOBID= specified        V121\n         LA    R3,SRSUJBID+L'SRSUJBID-1 Last char in JOBID area    V121\n         CLI   0(R3),C' '          Last char a blank?              V121\n         BNE   JIEND               No, already pointing at end     V121\n         LR    R1,R2               Copy first char addr            V121\n         SLR   R0,R0               Set function code for findblnk  V121\n         BAL   R9,FINDBLNK         Find blank char                 V121\n         BCTR  R1,0                Point at last char in jobid     V121\n         LR    R3,R1               Save last char address          V121\nJIEND    DS    0H                                                  V121\n         LA    R14,=C'JOBSTCTSU'   Point at valid jobid prefix     V121\n         LA    R15,3               Set max trips thru loop         V121\nGETFRST  DS    0H                                                  V121\n         CLC   0(1,R14),0(R2)      Check 1st char for JOB/STC/TSU  V121\n         BE    GOTFRST             If match, check rest            V121\n         LA    R14,3(R14)          Point to next prefix            V121\n         BCT   R15,GETFRST         Go check it                     V121\n         B     PARMERR             1st char not J S or T, error    V121\nGOTFRST  DS    0H                                                  V121\n         MVC   SRSTJBID,BLANKS     Init JOBID field                V121\n         MVC   SRSTJBID(1),0(R14)  Set J/S/T prefix                V121\n         LA    R15,2               Set max trips thru loop         V121\n         LR    R4,R2               Copy start of jobid             V121\nGETNUM   DS    0H                                                  V121\n         LA    R4,1(R4)            Point at next character         V121\n         CLI   0(R4),C'Z'          Start of job number ?           V121\n         BH    GOTNUM              Yes, go process the job number  V121\n         LA    R14,1(R14)          Next char in prefix             V121\n         CLC   0(1,R4),0(R14)      Prefix match ?                  V121\n         BNE   PARMERR             No, parameter error             V121\n         BCT   R15,GETNUM                                          V121\n         LA    R4,1(R4)            Point at 1st char in job number V121\nGOTNUM   DS    0H                                                  V121\n* R4 now points at the first character in the job number           V121\n         SR    R3,R4               Get length of job number        V121\n         BM    PARMERR             Error if no job number          V121\n         LA    R1,SRSTJBID+1       Get field for job number        V121\n         EX    R3,MVCJNUM          Save job number                 V121\n         EX    R3,NMCJNUM          Force job number to be numeric  V121\n         EX    R3,CLCJNUM          Passed jobnum numeric ?         V121\n         BNE   PARMERR             No, error                       V121\n         B     NOSPUJI                                             V121\nNMCJNUM  OC    SRSTJBID+1(*-*),=C'0000000'                         V121\nCLCJNUM  CLC   SRSTJBID+1(*-*),0(R4)                               V121\nMVCJNUM  MVC   0(*-*,R1),0(R4)                                     V121\nNOSPUJI  DS    0H                                                  V121\nPROCJBIX DS    0H                                                  V121\n         BR    R8                    Return to mainline            V121\n*                                                                  V121\nPARMERR  DS    0H                                                  V121\n*==================================================================V121\n* Routine to handle invalid value specified for keyword            V121\n*  R2 contains the address of the value specified                  V121\n*  R5 contains the address of keyword table entry for the keyword  V121\n*==================================================================V121\n         MVI   WTOBUFF,C' '                     Init WTO buffer    V121\n         MVC   WTOBUFF+1(L'WTOBUFF-1),WTOBUFF     to blanks        V121\n         MVC   WTOBUFF+2(L'SRS521E),SRS521E     Set basic msg      V121\n         LA    R1,WTOBUFF+L'SRS521E+2 Point at end of base message V121\n         LR    R15,R2              Get bad value addr              V121\n         IC    R14,SRSKWLOL        Get length of value             V121\n         BCTR  R14,0               Prep for execute                V121\n         EX    R14,MVCERR          Move into error msg             V121\n         SLR   R0,R0               Set function code for findblnk  V121\n         BAL   R9,FINDBLNK         Find blank char                 V121\n         MVC   0(14,R1),=C''' for keyword '  add next part         V121\n         LA    R1,14(R1)           Bump msg pointer                V121\n         L     R15,SRSKWNAM        Get bad keyword name            V121\n         SLR   R14,R14             Clear reg for length            V121\n         IC    R14,SRSKWNAL        Get length of keyword           V121\n         BCTR  R14,0               Prep for execute                V121\n         EX    R14,MVCERR          Move into error msg             V121\n         BAL   R9,FINDBLNK         Find blank char                 V121\n         LA    R15,WTOBUFF+2       Get start of WTO text           V121\n         SR    R1,R15              Calculate length of message     V121\n         STH   R1,WTOBUFF          Save length in WTO parm         V121\n         BAL   R9,SRSDWTO          Issue the message               V121\n         OI    STATUS,KEYERR       Flag error encountered          V121\n         BR    R8                  Return to ATTWTR routine        V121\n         DROP  R5,R6,R7                                            V121\nMVCERR   MVC   0(*-*,R1),0(R15)                                    V121\n*                                                                  V121\nWTRSTAT  DS    0H\n*=====================================================================*\n* Show status of writer                                               *\n*  R1 contains the address of SRSTBLK                                 *\n*=====================================================================*\n         LR    R6,R1               Save block address\n         USING SRSTBLK,R6          Addressability to block\n         MVI   WTOBUFF,C' '                    Initialize ...\n         MVC   WTOBUFF+1(L'WTOBUFF-1),WTOBUFF  ... wto buffer\n         LA    R1,WTOBUFF+2        Point at first character of text\n         MVC   0(L'SRS505I,R1),SRS505I Move in message ID\n         LA    R1,L'SRS505I(R1)    Point character after msgid     V120\n         MVC   0(2,R1),SRSTWRID    Add writer id\n         LA    R1,3(R1)            Update message pointer\n         MVC   0(5,R1),=C'STAT='   Add next part\n         LA    R1,5(R1)            Update message pointer\n         TM    SRSTECB,ECBPOST     Did task end ?\n         BO    TASKEND             Yes, handle it\n         MVC   0(6,R1),=C'ACTIVE'  Assume active\n         TM    SRSTFLAG,SRSTACT    Is task active ?\n         BO    TASKACT             Yes, leave alone\n         MVC   0(8,R1),=C'STARTING'  Fix up status\n         B     TASKACT             Do rest of msg\nTASKEND  DS    0H\n         MVC   0(11,R1),=C'ENDED CODE-'  Fix up status\n         LA    R1,11(R1)            Update message pointer\n         LR    R5,R1\n         L     R1,SRSTECB          Get return code\n         CALL  SRSPRHEX                                            V111\n         STCM  R0,3,0(R5)          Save first part of RC\n         STCM  R1,15,2(R5)         Save last part of RC\n         LR    R1,R5\nTASKACT  DS    0H\n         SLR   R0,R0               Set function code for findblnk\n         BAL   R9,FINDBLNK         Find blank char\n         CLC   =C'SRSGENER',SRSTPGMN  Using default despool pgm?   V120\n         BE    NOSPGMN             Yes, leave off msg              V120\n         LA    R1,1(R1)            Add a blank\n         MVC   0(2,R1),=C'P='      Add next part\n         MVC   2(8,R1),SRSTPGMN    Add program name\n         SLR   R0,R0               Set function code for findblnk\n         BAL   R9,FINDBLNK         Find blank char\nNOSPGMN  DS    0H                                                  V120\n         CLI   SRSTCLAS,X'00'      Select by class ?\n         BE    NOSCLAS             No, skip in message\n         MVC   1(2,R1),=C'Q='      Add next part\n         MVC   3(1,R1),SRSTCLAS    Add class\n         LA    R1,4(R1)            Point at next slot\nNOSCLAS  DS    0H\n         CLI   SRSTJOBN,X'00'      Select by jobname ?\n         BE    NOSJOBN             No, skip in message\n         MVC   1(2,R1),=C'J='      Add next part\n         LA    R1,3(R1)            Point at next slot\n         MVC   0(8,R1),SRSTJOBN    Add jobname\n         SLR   R0,R0               Set function code for findblnk\n         BAL   R9,FINDBLNK         Find blank char\nNOSJOBN  DS    0H\n         CLI   SRSTJBID,X'00'      Select by jobid ?               V120\n         BE    NOSJBID             No, skip in message             V120\n         MVC   1(3,R1),=C'JI='     Add next part                   V120\n         LA    R1,4(R1)            Point at next slot              V120\n         MVC   0(8,R1),SRSTJBID    Add jobid name                  V120\n         SLR   R0,R0               Set function code for findblnk  V120\n         BAL   R9,FINDBLNK         Find blank char                 V120\nNOSJBID  DS    0H\n         CLI   SRSTDEST,X'00'      Select by destination ?\n         BE    NOSDEST             No, skip in message\n         MVC   1(2,R1),=C'D='      Add next part\n         LA    R1,3(R1)            Point at next slot\n         MVC   0(L'SRSTDEST,R1),SRSTDEST  Add destination       @A12101\n         SLR   R0,R0               Set function code for findblnk\n         BAL   R9,FINDBLNK         Find blank char\nNOSDEST  DS    0H\n         CLI   SRSTFORM,X'00'      Select by forms ?\n         BE    NOSFORM             No, skip in message\n         MVC   1(2,R1),=C'F='      Add next part\n         LA    R1,3(R1)            Point at next slot\n         MVC   0(L'SRSTFORM,R1),SRSTFORM    Add forms name\n         SLR   R0,R0               Set function code for findblnk\n         BAL   R9,FINDBLNK         Find blank char\nNOSFORM  DS    0H\n         CLI   SRSTWTRN,X'00'      Select by writer name ?\n         BE    NOSWTRN             No, skip in message\n         MVC   1(2,R1),=C'W='      Add next part\n         LA    R1,3(R1)            Point at next slot\n         MVC   0(8,R1),SRSTWTRN    Add writer name\n         SLR   R0,R0               Set function code for findblnk\n         BAL   R9,FINDBLNK         Find blank char\nNOSWTRN  DS    0H\n         CLI   SRSTDDNM,X'00'      Select by ddname ?              V120\n         BE    NOSDDNM             No, skip in message             V120\n         MVC   1(7,R1),=C'DDNAME=' Add next part                   V120\n         LA    R1,8(R1)            Point at next slot              V120\n         MVC   0(8,R1),SRSTDDNM    Add ddname                      V120\n         SLR   R0,R0               Set function code for findblnk  V120\n         BAL   R9,FINDBLNK         Find blank char                 V120\nNOSDDNM  DS    0H                                                  V120\n         MVC   1(2,R1),=C'S='      Set SELECT= kwd              @A11102\n         LA    R1,3(R1)            Update msg ptr               @A11102\n         TM    SRSTFLAG,SRSTSNHL+SRSTSHLD  SELECT=ALL ?         @A11102\n         BNO   SELO2               No, keep checkin             @A11102\n         MVC   0(3,R1),=C'ALL'     Set opt in msg text          @A11102\n         LA    R1,3(R1)            Update msg ptr               @A11102\n         B     SELODONE            Continue building message    @A11102\nSELO2    DS    0H                                               @A11102\n         TM    SRSTFLAG,SRSTSNHL   SELECT=NONHELD?              @A11102\n         BNO   SELO3               No, must be HELD             @A11102\n         MVC   0(7,R1),=C'NONHELD' Set opt in msg text          @A11102\n         LA    R1,7(R1)            Update msg ptr               @A11102\n         B     SELODONE            Continue building message    @A11102\nSELO3    DS    0H                                               @A11102\n         MVC   0(4,R1),=C'HELD'    Set opt in msg text          @A11102\n         LA    R1,4(R1)            Update msg ptr               @A11102\nSELODONE DS    0H                                               @A11102\n         TM    SRSTFLAG,SRSTKEEP   DISP=KEEP ?                     V111\n         BZ    NOSDKEEP            No, skip in message             V111\n         MVC   1(9,R1),=C'DISP=KEEP'  Set in msg                   V111\n         LA    R1,10(R1)           Point at next slot              V111\nNOSDKEEP DS    0H                                                  V111\n         LA    R15,WTOBUFF+2       Point at beginning of msg\n         SR    R1,R15              Get total msg length\n         STH   R1,WTOBUFF          Save length\n         BAL   R9,SRSDWTO          Issue the message\n* Display the number of datasets and the last job selected\n         TM    SRSTFLAG,SRSTACT    Is task active ?\n         BZ    WTRSTATX            No, no totals displayed\n         LA    R1,WTOBUFF+2        Restore pointer to msg text\n         LA    R1,8(R1)            Point at text after msgid\n         MVC   0(25,R1),=C'Output Groups Processed='               V120\n         LA    R1,24(R1)           Point at next area              V120\n         MVC   EDBUF,EDPAT         Move edit pattern to buffer\n         L     R15,SRSTCNT         Get dataset count\n         CVD   R15,DOUBWORK        Make it decimal\n         ED    EDBUF,DOUBWORK+3    Edit dataset count\n         LR    R3,R1               Save message pointer\n         LA    R1,EDBUF+L'EDBUF-1  Point at last char in data\n         LR    R2,R1               Save pointer\n         LA    R0,4                Set backward scan direction\n         BAL   R9,FINDBLNK         Find blank char\n         LA    R1,1(R1)            Point at first digit\n         SR    R2,R1               Get length of cnt (minus one)\n         EX    R2,MOVECNT          Move record count to message\n         LA    R1,1(R2,R3)         Point at end of text\n         LA    R15,WTOBUFF+2       Point at beginning of msg\n         SR    R1,R15              Get total msg length\n         STH   R1,WTOBUFF          Save length\n         BAL   R9,SRSDWTO          Issue the message\n         ICM   R15,15,SRSTCNT      Is count = 0 ?\n         BZ    WTRSTATX            Yes, skip rest of display\n         LA    R1,WTOBUFF+2        Restore pointer to msg text\n         LA    R1,8(R1)            Point at text after msgid\n         MVC   0(5,R1),=C'Last='   Move in next part of text\n         LA    R1,5(R1)            Point at next field\n         MVC   0(8,R1),SRSTLJBN    Move in last job selected\n         MVI   8(R1),C' '          Insure next char is a blank\n         SLR   R0,R0               Set foward scan direction\n         BAL   R9,FINDBLNK         Find blank char\n         MVI   0(R1),C'('          Set starter for jobid\n         MVC   1(8,R1),SRSTLJBI    Move in last jobid selected\n         MVC   9(2,R1),=C') '      Set ending for jobid\n         LA    R1,11(R1)           Point at next field\n         MVC   DOUBWORK,SRSTTIME   Copy time to work area\n         L     R15,DOUBWORK        Get first part of GMT time\n         ACONTROL FLAG(NOPAGE0)    Valid use of low core below     V121\n         L     R14,CVTPTR          Get CVT addressability\n         ACONTROL FLAG(PAGE0)      Restore PAGE0 checking          V121\n         A     R15,CVTTZ-CVT(,R14) Add the time zone offset\n         ST    R15,DOUBWORK        Save local time\n         LR    R2,R1               Save message buffer pointer\n         MVC   CKCNPRMB(SCNVPRML),SCNVPARM  Move parm to buffer\n         STCKCONV STCKVAL=DOUBWORK,CONVVAL=TODCNV,                     +\n               DATETYPE=YYYYMMDD,MF=(E,CKCNPRMB) Convert time\n         LR    R1,R2               Restore message buffer pointer\n         LTR   R15,R15             RC=0 ?\n         BNZ   STCKFAIL            No, skip time display\n         MVC   0(17,R1),=C'hh:mm:ss mm/dd/yy'\n         UNPK  TODWORK(9),TODCNV(5)      Get 1st 8 digits of time\n         UNPK  TODWORK+8(5),TODCNV+4(3)  Get last 4 digits of time\n         MVC   0(2,R1),TODWORK           Move in hh\n         MVC   3(2,R1),TODWORK+2         Move in mm\n         MVC   6(2,R1),TODWORK+4         Move in ss\n         UNPK  TODWORK(9),TODCNV+8(5)    Get date\n         MVC   9(2,R1),TODWORK+4         Move in mm\n         MVC   12(2,R1),TODWORK+6        Move in dd\n         MVC   15(2,R1),TODWORK+2        Move in yy\n         LA    R1,17(R1)                 Point at end of text\nSTCKFAIL DS    0H\n         LA    R15,WTOBUFF+2       Point at beginning of msg\n         SR    R1,R15              Get total msg length\n         STH   R1,WTOBUFF          Save length\n         BAL   R9,SRSDWTO          Issue the message\nWTRSTATX DS    0H\n         BR    R10\n         DROP  R6\nMOVECNT  MVC   0(*-*,R3),0(R1)\n         SPACE 2\n*==================================================================\n* SRSDRVR general-purpose WTO routine.\n*\n* This routine issues all WTOs for the SRS driver.  It supports\n* two forms of messages: normal and command-response.\n*\n*  At input:\n*    1) The message must reside in WTOBUFF.  The first two bytes\n*       contain the length of the text followed by the actual\n*       text.\n*    2) If the STOPMOD flag in STATUS is on, then the WTO is a\n*       command response.  R7 must point to the CIB that was\n*       generated for the STOP/MODIFY.\n*    3) R9 contains the return address.\n*  At input:\n*    1) The contents of R2 may be changed.\n*==================================================================\nSRSDWTO  DS    0H\n         TM    STATUS,STOPMOD      Command response ?\n         BO    WTORESP             Yes, issue w/CONSNAME           V120\n         USING CIB,R7\nWTONRESP DS    0H\n         MVC   WTOPARMB,WTOP1      Move WTO parm to buffer\n         WTO   TEXT=WTOBUFF,MF=(E,WTOPARMB)\n         B     SRSDWTOX            All done\n         SPACE 3\nWTORESP  DS    0H\n         LR    R2,R7               Copy CIB address\n         AH    R2,CIBXOFF          Get addr of extention\n         USING CIBX,R2\n         MVC   WTOPARMB,WTOP2      Move WTO parm to buffer\n         WTO   TEXT=WTOBUFF,CART=CIBXCART,CONSNAME=CIBXCNNM,           +\n               MF=(E,WTOPARMB)\n         DROP  R2,R7\n         SPACE 3\nSRSDWTOX DS    0H\n         BR    R9\n*\n*=====================================================================*\n* Find the next blank character                                       *\n*  At input:                                                          *\n*    R0 - contains a code indicating the scanning direction           *\n*         0 - foward                                                  *\n*         4 - backward                                                *\n*    R1 - points to the character to start searching                  *\n*    R9 - contains the return address                                 *\n*  At output:                                                         *\n*    R1 - points to the next blank character                          *\n*=====================================================================*\nFINDBLNK DS    0H\n         LTR   R0,R0               Foward search ?\n         BZ    GETFWD              Yes, continue\nGETBACK  DS    0H\n         CLI   0(R1),C' '          Blank found\n         BER   R9                  Yes, return\n         BCTR  R1,0                Point at previous character\n         B     GETBACK             Check next char\n*\nGETFWD   DS    0H\n         CLI   0(R1),C' '          Blank found\n         BER   R9                  Yes, return\n         LA    R1,1(R1)            Point at next character\n         B     GETFWD              Check next char\n         EJECT\n* Static constants and areas\n* Message text\nBLANKS   DC    CL20' '\nSRS500I  DC    C'SRS500I SYSOUT Retrieval Services - Release 1.2.1_01' +\n                                                                @A12101\nSRS501I  DC    C'SRS501I WTRxx attached'\nSRS502I  DC    C'SRS502I STOP command accepted'\nSRS505I  DC    C'SRS505I WTR'\nSRS510E  DC    C'SRS510E Error: No SYSOUT selection criteria specified'\nSRS520E  DC    C'SRS520E Input parameter invalid: '                V121\nSRS521E  DC    C'SRS521E Invalid value '''                         V121\nSRS525E  DC    C'SRS525E Error in options module xxxxxxxx - '      V121\nSRS525EM EQU   32      Offset to module name                       V121\nSRS525E1 DC    C'LOAD for module failed'                           V121\nSRS525E2 DC    C'Invaid length'                                    V121\nSRS525E3 DC    C'Invalid module identifier'                        V121\nSRS525E4 DC    C'Assembled at different SRS level'                 V121\nSRS530E  DC    C'SRS530E Invalid MODIFY option specified'\n*\n*\nATTPARM  ATTACH SF=L\nATTPARML EQU   *-ATTPARM\n*\nEXTPARM  EXTRACT 0,FIELDS=COMM,MF=L\nEXTPARML EQU   *-EXTPARM\n*\nOPNPARM  OPEN  0,MF=L\nOPNPARML EQU   *-OPNPARM\n*\nCLSPARM  CLOSE 0,MF=L\nCLSPARML EQU   *-CLSPARM\n*\nWTOP1    WTO   TEXT=(0),MF=L           Standard WTO parm list\nWTOP1L   EQU   *-WTOP1\nWTOP2    WTO   TEXT=(0),CART=,CONSNAME=,MCSFLAG=(RESP),                +\n               MF=L                    WTO parm list for cmdresp\nWTOP2L   EQU   *-WTOP2\n*\nSCNVPARM STCKCONV MF=L\nSCNVPRML EQU   *-SCNVPARM\nEDPAT    DC    X'402020206B2020206B202120'  999,999,999\n         LTORG\n         EJECT\n*\nSRSDWORK DSECT\nSAVE     DS    18F                     Save area\nDOUBWORK DS    D                       Doubleword work area\nFULLWORK DS    D                       Fullword work area          V121\nTBLKFRST DS    F                       Pointer to the first SRSTBLK\nTBLKPLST DS    F                       Pointer to the pointer field in +\n                                       the last SRSTBLK\nXWTRID   DS    H                       NUmber of the next SRSTASK to   +\n                                       attach\nOPTSTAB  DS    CL8                     Name of SRSOPTxx module     V121\n*                                                                  V120\n* Parameters below extracted from user-specified PARM=             V121\nSRSUPGMN DS    CL8             Name of despooling program          V121\nSRSUJOBN DS    CL8             Jobname to select                   V121\nSRSUDEST DS    CL18            Destination to select            @A12101\nSRSUFORM DS    CL8             Forms queue to select               V121\nSRSUJBID DS    CL8             JES2 jobid to select                V121\nSRSUWTRN DS    CL8             Writer name to select               V121\nSRSUSEPI DS    CL8             SEPID selected                      V121\nSRSUDDNM DS    CL8             DDNAME selected                     V121\nSRSUCLAS DS    C               SYSOUT class to select              V121\nSRSUOPTS DS    CL2             Options table suffix                V121\nSRSULIMT DS    CL4             Number of datasets to select        V121\nSRSUWAIT DS    CL3             WAIT option                         V121\nSRSUDISP DS    CL6             Dataset disposition                 V121\nSRSUSTAT DS    CL7             Dataset status                      V121\nSRSUSEPO DS    CL7             Separator Option                    V121\nSRSUPPRM DS    CL80            Parameters passed to despool pgm    V121\n*                                                                  V121\nECBLIST  DS    0F\nECBCOMM  DS    F\nECBPTASK DS    F         SRSTASK ECB\n*\nRESPAREA DS    F\nPARSOPST DS    F         Starting address of operand being parsed  V112\nPARSOPEN DS    F         Ending address of operand being parsed    V112\n*\n         DS    0F                                                  V121\nSRSKEYTB DS    CL(100*SRSKWL)  Keyword table (up to 99 keywords)   V121\n         DS    0F\nWTOBUFF  DS    CL100\n         DS    0F\nWTOPARMB DS    CL(WTOP2L)\n         DS    0S(L'WTOPARMB-WTOP1L)   Insure buffer big enough\nCKCNPRMB DS    CL(SCNVPRML)\n*\nSTATUS   DC    BL1'0'    Status bits\nBATCHJ   EQU   X'80'     Driver is running as a batch job\nMSGLIM   EQU   X'40'     Display only important WTO messages\nSTOPMOD  EQU   X'20'     Processing STOP/MODIFY command\nSTOP     EQU   X'08'     STOP COMMAND HAS BEEN ISSUED\nNOWAIT   EQU   X'04'     Writer is not waiting for datasets\nKEYERR   EQU   X'02'     Invalid value for keyword encountered     V121\nOPSTABL  EQU   X'01'     SRSOPTS module has been loaded            V121\n*\nPARSSTAT DC    BL1'0'       Parse Routine Status bits              V120\nPARSPARN EQU   B'10000000'  Looking for right parenthesis          V120\n*                                                                  V120\nTODCNV   DS    CL16                Converted TOD time\nTODWORK  DS    CL17                EBCDIC STCK time work area\nEDBUF    DS    CL(L'EDPAT)\nSRSDLEN  EQU   *-SRSDWORK\n         EJECT\n*                                                                  V121\nSRSKW    DSECT                                                     V121\nSRSKWLOC DS   F             Location of keyword value              V121\nSRSKWNAM DS   F             Name of keyword                        V121\nSRSKWRTN DS   F             Routine to process kwd (if any)        V121\nSRSKWTBK DS   H             Offset of keyword value in TBLK        V121\nSRSKWDEF DS   H             Offset of defalt val in OPTS table     V121\nSRSKWLOL DS   XL1           Length of the SRSKWLOC area            V121\nSRSKWNAL DS   XL1           Length of the SRSKWNAM area            V121\nSRSKWSIG DS   XL1           Num chars kwd name can be abbrev to    V121\nSRSKWFIL DS   XL1                                                  V121\nSRSKWL   EQU  *-SRSKW       Length of each SRSKW entry             V121\n*\n* MAPPING MACROS\n         SRSTBLK                   MAP SRS Task Data Block\n         SRSOPT  DSECT=YES         MAP SRS Options table           V121\n*        PRINT NOGEN\n         IHAPSA                    MAP PSA\n         IHAASCB                   MAP ASCB\n         CVT   DSECT=YES           MAP CVT\n         IKJTCB\n         IEFJESCT\n         IEFJSSIB\n         IEZJSCB\nCSCB     DSECT\n         IEECHAIN                  MAP CSCB\n         IHAECB\n         IEFZB4D0\n         IEFZB4D2\n         IEZCOM\nCIB      DSECT\n         IEZCIB\n         YREGS\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SRSGENER": {"ttr": 14849, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x1c\\x00Y\\x00\\x94\\x06\\x8f\\x01\\x05\\x19o\\x11\\x00\\x01v\\x00\\x8f\\x00\\x00\\xc4\\xe6\\xc4@@@@@@@'", "ispf": {"version": "01.28", "flags": 0, "createdate": "1994-03-09T00:00:00", "modifydate": "2005-07-15T11:00:59", "lines": 374, "newlines": 143, "modlines": 0, "user": "DWD"}, "text": "*PROCESS FLAG(PAGE0)                                               V121\nSRSGENER TITLE '- SRS Copy Routine'\nSRSGENER CSECT , ATTR=NONE\nSRSGENER AMODE 31\nSRSGENER RMODE 24\n*=====================================================================*\n*                                                                     *\n*  MODULE NAME:  SRSGENER                                             *\n*                                                                     *\n*  OPERATION:                                                         *\n*                                                                     *\n*    SRSGENER is an SRS despooler routine provided to perform      V120\n*    IEBGENER-like functions for the SRSTASK routine.  The program    *\n*    receives spool record images, and simply writes the images    V120\n*    to the data set specified in the OUTFILE= parameter.          V120\n*                                                                     *\n*    The following options can be specified via the PPARM= SRS     V120\n*    option:                                                       V120\n*                                                                  V120\n*    OUTFILE=<ddname>                                              V120\n*    Specifies the DDNAME of the data set to write spool data      V120\n*    records to.  The default is SYSUT2.                           V120\n*                                                                  V120\n*    DEFER_OPEN=YES/NO                                             V120\n*    Specifies whether the OUTFILE= file should be opened at SRS   V120\n*    initialization or after the first record is despooled.  If    V120\n*    'YES' (which is the default) is specified and the OUTFILE=    V120\n*    file is a new data set that does not specify LRECL            V120\n*    information, SRS will use the record length of the first      V120\n*    record despooled as the LRECL.  If 'NO', LRECL must be        V120\n*    specified on the OUTFILE= file or a S013-34 abend will        V120\n*    occur.  'NO' may be useful if OUTFILE= specifies a tape       V120\n*    device and SRS ends with RC=4 (indicating no spool files      V120\n*    matched the selection criteria) before the tape is mounted.   V120\n*                                                                  V120\n*    NOTES:                                                        V120\n*                                                                  V120\n*    This routine is loaded and branch-entered by SRSTASK at       V120\n*    various times.  When invoked, R1 points to the SRS Data Block V120\n*    (mapped by SRSDATA).  A flag in SRSDATA indicates the calling V120\n*    reason:                                                       V120\n*                                                                  V120\n*    o Task initialization  (SRSFLAGS=SRSINIT)                     V120\n*    o Task termination     (SRSFLAGS=SRSTERM)                     V120\n*    o New dataset call     (SRSFLAGS=SRSFIRST)                    V120\n*    o Data record call     (SRSFLAGS=SRSDREC)                     V120\n*    o End-of-dataset call  (SRSFLAGS=SRSEOF)                      V120\n*                                                                  V120\n*    A fullword (SRSUSER) is avaiable for the program's use and    V120\n*    will be preserved across calls.                               V120\n*                                                                  V120\n*    ATTRIBUTES:                                                      *\n*                                                                     *\n*      LOCATION:  Resident in own address space                       *\n*      STATE:  Problem, not APF authorized                            *\n*      AMODE:  31-BIT                                                 *\n*      RMODE:  24-BIT (Uses Access Methods)                           *\n*      KEY:   8                                                       *\n*      MODE:  Task                                                    *\n*      SERIALIZATION: None                                            *\n*      TYPE:  Not reentrant                                           *\n*                                                                     *\n*  Written By: Dave Danner                                      @A11202\n*              Summit Technical Services, Inc.                  @A11202\n*                                                               @A11202\n*          April, 1998 (Copied from PSOGENER in PSOS)                 *\n*                                                                     *\n*  Change log:                                                        *\n*    DWD 04/98: Set LRECL for SYSUT2 if not in JCL                 V111\n*    DWD 09/03: Support for OUTFILE= option                        V120\n*               Support for DEFER_OPEN=YES/NO                      V120\n*=====================================================================*\n         USING SRSGENER,R15         Temporary base\n         B     START                Branch around eyecatcher\n         DC    C'SRSGENER_&SYSDATE._&SYSTIME. '                    V121\n         DC    C'COPYRIGHT 1998-2004 DAVID W DANNER '              V121\n         DC    C'ALL RIGHTS RESERVED'                              V121\nSTART    DS    0H\n         DROP  R15                  Drop temporary addressability\n         BAKR  R14,0                Save environment\n         LR    R12,R15              Set base register\n         USING SRSGENER,R12\n*\n         LR    R8,R1                Copy SRS data block address    V120\n         USING SRSDATA,R8                                          V120\n         L     R9,SRSUSER           Get work area address\n         USING GENRWORK,R9          Address work area\n         SPACE 3\n*=====================================================================*\n* Check calling code indicator                                        *\n*=====================================================================*\n         TM    SRSFLAGS,SRSINIT     Initialization call ?\n         BNO   NOINIT               No, continue\n*=====================================================================*\n* SRSGENER initialization call                                        *\n*=====================================================================*\n         BAL   R10,CKPARM           Check PPARM= parameters        V120\n         LTR   R15,R15              Parameters OK ?                V120\n         BNZ   RETURN               No, quit now                   V120\n         LA    R15,SYSUT2           Get output file DCB address    V120\n         MVC   DCBDDNAM-IHADCB(8,R15),GENRDDNM Set outfile DDNAME  V120\n         RDJFCB SYSUT2              Read JFCB of SYSUT2            V111\n         LTR   R15,R15              SYSUT2 DD stmt provided ?      V111\n         BNZ   NOSYSUT2             No, quit now                   V111\n         TM    GENRSTAT,GENRDOPN    Deferred OPEN ?                V120\n         BO    SKIPOPEN             Yes, wait for data record      V120\n         BAL   R10,OPENOUT          Open the output file           V120\nSKIPOPEN DS    0H                                                  V120\n         MVC   WTOBUFF+2(L'SRSG01I),SRSG01I  Move info message     V120\n         MVC   WTOBUFF+39(8),GENRDDNM                   Move ddnameV120\n         LA    R15,WTOBUFF+39       Point at 1st char in ddname    V121\nDDNLOOP  DS    0H                                                  V121\n         LA    R15,1(R15)           Bump pointer                   V121\n         CLI   0(R15),C' '          End of ddname ?                V121\n         BNE   DDNLOOP              No, check next char            V121\n         MVC   1(4,R15),=C'DSN='    Move next part of msg          V121\n         LA    R15,5(R15)           Point at spot for DSN          V121\n         MVC   0(L'JFCBDSNM,R15),JFCBDSNM Move dsn to msg          V121\n         LA    R15,L'JFCBDSNM(R15)  Point past end of DSN          V121\n         LA    R1,WTOBUFF+2         Get start of message           V121\n         SR    R15,R1               Calculate length               V121\n         STH   R15,WTOBUFF          Save length in WTO             V120\n         WTO   TEXT=WTOBUFF         Issue message                  V120\n         B     RETURN0              Return\n         SPACE 3\nNOINIT   DS    0H\n         TM    SRSFLAGS,SRSDREC     Data record call ?\n         BNO   NOREC                No, continue\n*=====================================================================*\n* SRSGENER data record call                                           *\n*=====================================================================*\n         TM    GENRSTAT,GENROPEN    Is SYSUT2 dataset open ?       V111\n         BO    GETREC               Yes, skip OPEN                 V111\n         CLC   JFCLRECL,=AL2(0)     LRECL specified by user ?      V111\n         BNE   U2OPEN               Yes, use it                    V111\n         TM    JFCBIND2,JFCNEW      DISP=NEW ?                     V111\n         BO    LRECSET              Yes, copy LRECL from input     V111\n         TM    JFCBTSDM,JFCSDS      SYSOUT dataset ?               V111\n         BNO   U2OPEN               No, use existing dataset       V111\n*==================================================================V111\n* Copy the LRECL of the first dataset to SYSUT2 LRECL.             V111\n* Set the RECFM to fixed, blocked.                                 V111\n* Set the BLKSIZE to zero, to use system determined blocksize.     V111\n*==================================================================V111\nLRECSET  DS    0H                                                  V111\n         LA    R3,SYSUT2            Get SYSUT2 DCB address         V111\n         MVC   DCBLRECL-IHADCB(L'DCBLRECL,R3),SRSRECL  Set LRECL   V111\n         MVI   DCBRECFM-IHADCB(R3),DCBRECF+DCBRECBR    RECFM=FB    V111\n         XC    DCBBLKSI-IHADCB(L'DCBBLKSI,R3),DCBBLKSI-IHADCB(R3)  V111\nU2OPEN   DS    0H                                                  V111\n         BAL   R10,OPENOUT          Open the output file           V120\nGETREC   DS    0H                                                  V112\n* Check lengths, copy record to output buffer if necessary\n         L     R6,SRSREC            Get address of record\n         LH    R7,SRSRECL           Get length of record\n         CH    R7,GENRRECL          Record length vs. buffer length\n         BE    DOPUT                Equal, do PUT now\n         BH    LOWLRECL             Higher, issue warning\n*                                   Lower, move record into buffer\n         TM    GENRSTAT,GENRFREC    First record in data set?      V120\n         BZ    SKIPCLR              No, skip clearing buffer       V120\n         LA    R2,GENRRBUF          Get address of buffer          V120\n         LH    R3,GENRRECL          Get length of buffer           V120\n         L     R15,=A(X'40000000')  Set blank pad & zero length    V120\n         MVCL  R2,R14               Set buffer to blanks           V120\nSKIPCLR  DS    0H                                                  V120\n         LA    R2,GENRRBUF          Get address of buffer\n         LR    R3,R7                Get length of record\n         MVCL  R2,R6                Move record to buffer\n         LA    R6,GENRRBUF          Point at buffer\n         B     DOPUT                Go write record\nLOWLRECL DS    0H\n         TM    GENRSTAT,GENRFREC    First record in data set?      V120\n         BZ    DOPUT                No, message already issued     V120\n         WTO   'SRSG02W WARNING - Input record length greater than outp+\n               ut file LRECL - Data truncated'                     V120\nDOPUT    DS    0H\n* Write record to output buffer\n         PUT   SYSUT2,(6)           Write out record\n         NI    GENRSTAT,X'FF'-GENRFREC  Reset first-record flag    V120\n         B     RETURN0\n         SPACE 3\nNOREC    DS    0H\n         TM    SRSFLAGS,SRSFIRST    Processing new dataset ?       V120\n         BNO   NOFIRST              No, continue                   V120\n*==================================================================V120\n* SRSGENER New Data set call                                       V120\n*==================================================================V120\n         OI    GENRSTAT,GENRFREC    Set first record flag          V120\n         B     RETURN0              Return                         V120\n         SPACE 3                                                   V120\nNOFIRST  DS    0H                                                  V120\n         TM    SRSFLAGS,SRSTERM     Termination call ?\n         BNO   NOTERM               No, continue\n*=====================================================================*\n* SRSGENER termination call                                           *\n*=====================================================================*\n         TM    GENRSTAT,GENROPEN    Is OUTFILE data set open?      V120\n         BZ    SKIPCLOS             No, don't CLOSE it             V120\n         CLOSE SYSUT2               Close output dataset\nSKIPCLOS DS    0H                                                  V120\n         LTR   R9,R9                Did we get a work area ?\n         BZ    RETURN0              No, nothing to free\n         LH    R2,GENRGETL          Get length of GETMAINed area\n         FREEMAIN R,A=(9),LV=(2)    Free the work area\n         B     RETURN0              Return\n         SPACE 3                                                   V120\nNOTERM   DS    0H                                                  V120\n         B     RETURN0              Not interested in this call    V120\n         SPACE 3\n*=====================================================================*\n* SRSGENER error handling                                             *\n*=====================================================================*\nNOSYSUT2 DS    0H                                                  V111\n         MVC   WTOBUFF+2(L'SRSG10E),SRSG10E  Move error message    V120\n         MVC   WTOBUFF+18(8),GENRDDNM        Move ddname           V120\n         LA    R15,L'SRSG10E       Get length of whole msg         V120\n         STH   R15,WTOBUFF         Save length in WTO              V120\n         WTO   TEXT=WTOBUFF        Issue message                   V120\n         LA    R15,8               Set RC=8, terminate\n         B     RETURN              Return\n         SPACE 3\nRETURN0  DS    0H\n         SLR   R15,R15             SET RC=0\nRETURN   DS    0H\n         PR                         Return to caller\n         EJECT\n*==================================================================V120\n* This routine opens the output file and acquires a buffer         V120\n* which might be needed to write the data records.                 V120\n*==================================================================V120\nOPENOUT  DS    0H                                                  V120\n         OPEN  (SYSUT2,OUTPUT)      Open output dataset            V120\n         OI    GENRSTAT,GENROPEN    Flag SYSUT2 open               V120\n         LA    R3,SYSUT2            Get SYSUT2 DCB address         V120\n         LH    R3,DCBLRECL-IHADCB(,R3)  Get required buffer size   V120\n         LA    R2,GENRWRKL(R3)      Get required work area length  V120\n         GETMAIN R,LV=(2),LOC=BELOW Get a work area                V120\n         ST    R1,SRSUSER           Save addr in anchor block      V120\n         LR    R9,R1                Update work area pointer       V120\n         STH   R3,GENRRECL          Save length of buffer (LRECL)  V120\n         STH   R2,GENRGETL          Save length of GETMAINed area  V120\n         BR    R10                  Return                         V120\n         EJECT                                                     V120\n*==================================================================V120\n* This routine processes the PPARM= options.                       V120\n*==================================================================V120\nCKPARM   DS    0H                                                  V120\n         SLR   R15,R15             Clear work reg                  V120\n         IC    R15,SRSPARML        Get length of parms             V120\n         LTR   R15,R15             Any parms ?                     V120\n         BZ    CKPARMX             No, quit now                    V120\n         LA    R2,SRSPARM          Point at first char in parm     V120\n         LA    R7,0(R15,R2)        Point one past end of parm      V120\n         BCTR  R7,0                Point at last char in parm      V120\n         SLR   R15,R15             Set CKPARM RC=0                 V120\nCHECKOP  DS    0H                                                  V120\n         CR    R2,R7               Any more operands ?             V120\n         BH    CKPARMX             No, done with parse             V120\n* Find the last character in the operand                           V120\n         LA    R3,1(R2)            Point at next character         V120\n         CLI   0(R2),C','          Null operand ?                  V120\n         BNE   FINDEND             No, process it                  V120\n         LR    R2,R3               Point at next character         V120\n         B     CHECKOP             And check it out                V120\nFINDEND  DS    0H                                                  V120\n         CR    R3,R7               End of operand ?                V120\n         BH    GOTEND              Yes, good                       V120\n         CLI   0(R3),C','          End of operand ?                V120\n         BE    GOTEND              Yes, good                       V120\n         LA    R3,1(R3)            Point at next char              V120\n         B     FINDEND             And check it                    V120\nGOTEND   DS    0H                                                  V120\n         BCTR  R3,0                Point at last character in op   V120\n         LR    R4,R3               Copy to work reg                V120\n* R2 now points at the operand, and R3 points at the last char     V120\n         ST    R2,PARSOPST         Save start of operand           V120\n         ST    R3,PARSOPEN         Save end of operand             V120\n         CLC   =C'OUTFILE=',0(R2)  Check keyword                   V120\n         BNE   NOOUTF              If not matched, check next      V120\n* Process the OUTFILE= keyword                                     V120\n         LA    R2,8(R2)            Point at keyword value          V120\n         SR    R4,R2               Get length of value             V120\n         BM    NEXTOP              Branch if null                  V120\n         CH    R4,=Y(L'GENRDDNM-1) Check max length                V120\n         BH    PARSERR             Error if too large              V120\n         MVC   GENRDDNM,BLANKS     Init outfile DDNAME             V120\n         LA    R1,GENRDDNM         Point at target field           V120\n         EX    R4,MVCPARM          Save program name               V120\n         B     NEXTOP              Check next operand              V120\n*                                                                  V120\nNOOUTF   DS    0H                                                  V120\n         CLC   =C'DEFER_OPEN=',0(R2) Check keyword                 V120\n         BNE   NODEFOPN            If not matched, check next      V120\n* Process the DEFER_OPEN= keyword                                  V120\n         LA    R2,11(R2)           Point at keyword value          V120\n         SR    R4,R2               Get length of value             V120\n         BM    NEXTOP              Branch if null                  V120\n         CH    R4,=H'1'            Is length 2 ?                   V120\n         BNE   CKDFOY              No, check for 'YES'             V120\n         CLC   =C'NO',0(R2)        'NO' option ?                   V120\n         BNE   PARSERR             No, parm error                  V120\n         NI    GENRSTAT,X'FF'-GENRDOPN   Set DEFER_OPEN=NO         V120\n         B     NEXTOP              Check next operand              V120\nCKDFOY   DS    0H                                                  V120\n         CH    R4,=H'2'            Is length 3 ?                   V120\n         BNE   PARSERR             No, bad parm                    V120\n         CLC   =C'YES',0(R2)       'YES' option ?                  V120\n         BNE   PARSERR             No, bad parm                    V120\n         OI    GENRSTAT,GENRDOPN   Set DEFER_OPEN=YES              V120\n         B     NEXTOP              Check next operand              V120\n*                                                                  V120\nNODEFOPN DS    0H                                                  V120\n         B     PARSERR             No more valid operands          V120\n         SPACE 3                                                   V120\nNEXTOP   DS    0H                                                  V120\n         LA    R2,2(R3)            Point at next operand           V120\n         B     CHECKOP             Check next operand              V120\n         SPACE 3                                                   V120\n* Syntax error in paramaters specified                             V120\nPARSERR  DS    0H                                                  V120\n         MVC   WTOBUFF+2(L'SRSG20E),SRSG20E                        V120\n         LA    R15,L'SRSG20E       Get length of message           V120\n         STH   R15,WTOBUFF         Save length in WTO              V120\n         LA    R1,WTOBUFF+32       Point at target for bad op      V120\n         L     R2,PARSOPST         Restore pointer to operand      V120\n         L     R4,PARSOPEN         Restore pointer to end of op    V120\n         SR    R4,R2               Get length                      V120\n         CH    R4,=H'19'           Bad op greater than 20 bytes ?  V120\n         BNH   BADOPOK             No, use its real length         V120\n         LA    R4,19               Just show first 20 bytes        V120\nBADOPOK  DS    0H                                                  V120\n         EX    R4,MVCPARM          Move bad op into message        V120\n         WTO   TEXT=WTOBUFF        Issue message                   V120\n         LA    R15,8               Set parse RC=8                  V120\nCKPARMX  DS    0H                                                  V120\n         BR    R10                 Return to main routine          V120\n         SPACE 3                                                   V120\nMVCPARM  MVC   0(*-*,R1),0(R2)     Generic executed MVC            V120\n         EJECT                                                     V120\nJFCBX    DS    0F\n         DC    XL1'87',AL3(JFCBAREA)\nJFCBAREA DS    0F\n         IEFJFCBN LIST=YES\nPARSOPST DS    F                                                   V120\nPARSOPEN DS    F                                                   V120\nGENRDDNM DC    CL8'SYSUT2'          DDNAME of output file          V120\nGENRSTAT DC    AL1(GENRDOPN)  Set default options                  V120\nGENRFREC EQU   B'10000000'  Processing first record of spool DS    V120\nGENROPEN EQU   B'01000000'  SYSUT2 dataset is open                 V111\nGENRDOPN EQU   B'00100000'  Deferred OPEN is in effect             V120\nGENRSTA4 EQU   B'00010000'  Reserved for future use                V120\nGENRSTA5 EQU   B'00001000'  Reserved for future use                V120\nGENRSTA6 EQU   B'00000100'  Reserved for future use                V120\nGENRSTA7 EQU   B'00000010'  Reserved for future use                V120\nGENRSTA8 EQU   B'00000001'  Reserved for future use                V120\n*                                                                  V120\nSRSG01I  DC    C'SRSG01I Writing spool data to DDNAME=xxxxxxxx '   V121\nSRSG10E  DC    C'SRSG10E ERROR - xxxxxxxx DD statement missing'    V120\nSRSG20E  DC    C'SRSG20E Input PPARM= invalid:                        '+\n                                                                   V120\nSYSUT2   DCB   DDNAME=SYSUT2,DSORG=PS,MACRF=(PM),EXLST=JFCBX       V111\nBLANKS   DC    CL20' '                                             V120\nWTOBUFF  DS    CL120                                               V121\nGENRWORK DSECT\nGENRRECL DS    H       Length of buffer (SYSUT2 LRECL)\nGENRGETL DS    H       Length of GETMAINed area\nGENRRBUF DS    0F      Output buffer\nGENRWRKL EQU   *-GENRWORK\n* MAPPING MACROS\n         SRSDATA\n         DCBD DSORG=PS             MAP DCB\n         YREGS\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SRSJWRAP": {"ttr": 15621, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0b\\x00(\\x00\\x99\\x02_\\x01\\x05\\x19o\\x14\\x16\\x00\\xdc\\x00\\xde\\x00\\x00\\xc4\\xe6\\xc4@@@@@@@'", "ispf": {"version": "01.11", "flags": 0, "createdate": "1999-01-25T00:00:00", "modifydate": "2005-07-15T14:16:28", "lines": 220, "newlines": 222, "modlines": 0, "user": "DWD"}, "text": "SRSJWRAP TITLE '- SYSOUT Retrieval Services (SRS) Despooler Program'\nSRSJWRAP CSECT\nSRSJWRAP AMODE 31\nSRSJWRAP RMODE 24\n*=====================================================================*\n*                                                                     *\n*  MODULE NAME:  SRSJWRAP                                             *\n*                                                                     *\n*  OPERATION:                                                         *\n*                                                                     *\n*    This module is part of SYSOUT Retrieval Services (SRS) a         *\n*    generalized external interface to data residing on the JES spool.*\n*                                                                     *\n*    This module retrieves data from the JES spool, \"wraps\" JCL       *\n*    around the data, and submits the combined JCL/data as a batch    *\n*    job.  This is especially useful for data sent to or recieved     *\n*    from an NJE site.                                                *\n*                                                                     *\n*    The JCL is supplied in file \"JCLFILE\".  The merged JCL images    *\n*    and data retrieved from the spool are written to the \"OUTRDR\"    *\n*    file.  The spool data is concatenated after all JCL statements   *\n*    have been written, unless the JCL file contains a special        *\n*    record with \"##SYSOUT\" starting in column 1 of the data.  If     *\n*    this statement is found, spool data is inserted at this point    *\n*    followed by the remainder of the JCL.  For example:              *\n*                                                                     *\n*    //jobcard                                                        *\n*    //*************************************************************  *\n*    //* COPY SPOOL DATA TO A DASD FILE                            *  *\n*    //*************************************************************  *\n*    //COPY1   EXEC PGM=IEBGENER                                      *\n*    //SYSUT2   DD DSN=xxx,DPS=(,CATLG),UNIT=SYSDA,SPACE=...          *\n*    //SYSIN    DD DUMMY                                              *\n*    //SYSPRINT DD SYSOUT=*                                           *\n*    //SYSUT1   DD *                                                  *\n*    ##SYSOUT DATA GOES HERE                                          *\n*    /*                                                               *\n*    //*************************************************************  *\n*    //* THIS IS NEXT STEP OF THE JOB                              *  *\n*    //*************************************************************  *\n*    //STEP2   EXEC PGM=...                                           *\n*        ...                                                          *\n*                                                                     *\n*    This module is called from the SRSTASK routine.  See that        *\n*    module for documentation on the invocation environment.          *\n*                                                                     *\n*    ATTRIBUTES:                                                      *\n*                                                                     *\n*      LOCATION:  RESIDENT IN OWN ADDRESS SPACE                       *\n*      STATE:  PROBLEM                                                *\n*      AMODE:  31-BIT                                                 *\n*      RMODE:  24-BIT                                                 *\n*      KEY:  KEY 8                                                    *\n*      MODE:  TASK                                                    *\n*      SERIALIZATION: NONE                                            *\n*      TYPE:  NOT REENTRANT                                           *\n*                                                                     *\n*  Written By: Dave Danner                                      @A11202\n*              Summit Technical Services, Inc.                  @A11202\n*                                                               @A11202\n*          January 1999 (Source modified from PSOJWRAP)               *\n*                                                                     *\n*  Change log:                                                        *\n*=====================================================================*\n         USING SRSJWRAP,R15         Temporary base\n         B     START                Branch around eyecatcher\n         DC    C'SRSJWRAP_&SYSDATE._&SYSTIME. '                    V121\n         DC    C'COPYRIGHT 1998-2004 DAVID W DANNER '              V121\n         DC    C'ALL RIGHTS RESERVED'                              V121\nSTART    DS    0H\n         DROP  R15                  Drop temporary addressability\n         BAKR  R14,0                Save environment\n         LR    R12,R15              Set base register\n         USING SRSJWRAP,R12\n*\n         LR    R9,R1                Copy SRS data block address\n         USING SRSDATA,R9\n         TM    SRSFLAGS,SRSDREC     Data record call ?\n         BNO   NODREC               No, continue\n*=====================================================================*\n* Data Record Call                                                    *\n*=====================================================================*\n         LH    R3,SRSRECL          Get length of data record\n         LA    R4,OUTRDR           Get reader DCB address\n         LH    R4,DCBLRECL-IHADCB(,R4)  Get reader LRECL\n         CR    R3,R4               Do we need to use buffer ?\n         BNL   DATALOOP            No, continue\n         OI    STATUS,SYSBUFF      Write data from buffer\nDATALOOP DS    0H\n         L     R1,SRSREC           Point at data record\n         LR    R2,R1               Save address\n         TM    STATUS,SYSBUFF      Are we buffering sysout data ?\n         BNO   WRITEDAT            No, write straight from input buff\n         SH    R4,=H'2'            Set up for execute below\n         BCTR  R3,0                Set up for execute below\n         LA    R5,DATABUFF         Get address of data buffer\n         MVI   0(R5),C' '          Initialize buffer ..\n         EX    R4,CLRRDR              .. to blanks\n         EX    R3,MOVERDR          Move data stmt to reader\n         LR    R2,R5               Get address of buffer\nWRITEDAT DS    0H\n         PUT   OUTRDR,(2)          Write data to internal reader\n         B     RETURN0\n         EJECT\nNODREC   DS    0H\n         TM    SRSFLAGS,SRSFIRST    Start-of-dataset call ?\n         BNO   NOFIRST              No, continue\n*=====================================================================*\n* Start of Dataset Call                                               *\n*=====================================================================*\n         MVI   STATUS,X'00'        Reset STATUS bits\n         OPEN  JCLFILE             Open JCL statements dataset\n* Copy JCL statements from JCLFILE to the reader dataset (OUTRDR)\n         LA    R3,JCLFILE          Get JCLFILE DCB address\n         LH    R3,DCBLRECL-IHADCB(,R3)  Get JCLFILE LRECL\n         LA    R4,OUTRDR           Get reader DCB address\n         LH    R4,DCBLRECL-IHADCB(,R4)  Get reader LRECL\n         CR    R3,R4               Do we need to use buffer ?\n         BNL   JCLLOOP             No, continue\n         SH    R4,=H'2'            Set up for execute below\n         BCTR  R3,0                Set up for execute below\n         OI    STATUS,JCLBUFF      Write JCL from buffer\nJCLLOOP  DS    0H\n         GET   JCLFILE             Read the next JCL statement\n         TM    SRSFLAGS,SRSEOF     End-of-dataset call ?\n         BO    NOINSCK             Yes, bypass insert-data check\n         CLC   =C'##SYSOUT',0(R1)  Special sysout-insert record ?\n         BE    RETURN0             Yes, insert sysout data now\nNOINSCK  DS    0H\n         LR    R2,R1               Save buffer address\n         TM    STATUS,JCLBUFF      Are we buffering jcl records ?\n         BNO   WRITEJCL            No, write straight from input buff\n         LA    R5,DATABUFF         Get address of data buffer\n         MVI   0(R5),C' '          Initialize buffer ..\n         EX    R4,CLRRDR              .. to blanks\n         EX    R3,MOVERDR          Move jcl stmt to buffer\n         LR    R2,R5               Get address of buffer\nWRITEJCL DS    0H\n         PUT   OUTRDR,(2)          Write JCL stmt to intrdr\n         B     JCLLOOP             Loop to process next stmt\nCLRRDR   MVC   1(*-*,R5),0(R5)\nMOVERDR  MVC   0(*-*,R5),0(R1)\n         EJECT\nNOFIRST  DS    0H\n         TM    SRSFLAGS,SRSEOF      End-of-dataset call ?\n         BNO   NOLAST               No, continue\n*=====================================================================*\n* End of Dataset Call                                                 *\n*=====================================================================*\n         TM    STATUS,JCLWROTE     Has all JCL been written ?\n         BNO   JCLLOOP             No, write rest of it\n         B     JOBDONE             Yes, write /*EOF card\n         EJECT\nNOLAST   DS    0H\n         TM    SRSFLAGS,SRSINIT     Initilization call ?\n         BNO   NOINIT               No, continue\n*=====================================================================*\n* Initialization Call                                                 *\n*=====================================================================*\n         OPEN  (OUTRDR,OUTPUT)      Open output dataset (internal rdr)\n         B     RETURN0\n         EJECT\nNOINIT   DS    0H\n         TM    SRSFLAGS,SRSTERM     Termination call ?\n         BNO   NOTERM               No, continue\n*=====================================================================*\n* Termination Call                                                    *\n*=====================================================================*\n         CLOSE (OUTRDR)             Close output dataset (internal rdr)\n         B     RETURN0\n         EJECT\nNOTERM   DS    0H\n         WTO   'Unsupported value in SRSFLAGS - interface terminated'\n         LA    R15,8               Set RC=8\n         B     RETURN\n         SPACE 5\n*=====================================================================*\n* The following code is executed when EOF is hit on JCLFILE.          *\n* Note that this can happen during SRSFIRST or SRSEOF processing.     *\n*=====================================================================*\nEOFJCL   DS    0H\n         OI    STATUS,JCLWROTE     Indicate all JCL has been written\n         CLOSE JCLFILE             Close the JCL dataset\n         TM    SRSFLAGS,SRSEOF     End-of-dataset call ?\n         BNO   RETURN0             No, wait for it\n         SPACE 5\n*=====================================================================*\n* All data and JCL has been written for this dataset.                 *\n*=====================================================================*\nJOBDONE  DS    0H\n         LA    R5,DATABUFF         Get address of data buffer\n         MVI   0(R5),C' '          Initialize buffer ..\n         EX    R4,CLRRDR              .. to blanks\n         MVC   0(L'EOFREC,R5),EOFREC  Write \"/*EOF\" to reader\n         PUT   OUTRDR,(5)          Write eof statement\n         B     RETURN0             Return to mainline\nRETURN0  DS    0H\n         SLR   R15,R15             Set rc=0\nRETURN   DS    0H\n         PR                        Return to caller\n         EJECT\n*\nEOFREC   DC    C'/*EOF'\n*\nSTATUS   DC    BL1'0'    STATUS BITS\nJCLBUFF  EQU   X'80'     WRITE JCL STATEMENTS FROM BUFFER\nSYSBUFF  EQU   X'40'     WRITE SYSOUT DATA FROM BUFFER\nJCLWROTE EQU   X'20'     ALL JCL STATEMENTS HAVE BEEN WRITTEN\nSYSWROTE EQU   X'10'     ALL SYSOUT DATA HAS BEEN WRITTEN\n*\nDATABUFF DS    0F,CL256\n*\nJCLFILE  DCB   DDNAME=JCLFILE,DSORG=PS,MACRF=(GL),EODAD=EOFJCL\nOUTRDR   DCB   DDNAME=OUTRDR,DSORG=PS,MACRF=(PM),LRECL=80,BLKSIZE=80\n         EJECT\n* MAPPING MACROS\n         SRSDATA\n         DCBD DSORG=PS             MAP DCB\n         YREGS\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SRSKEY": {"ttr": 1027, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x01\\x01\\x046_\\x01\\x05\\x00O\\x16\\x03\\x00)\\x00\\x18\\x00\\x00\\xc4\\xe6\\xc4@@@@@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "2004-12-30T00:00:00", "modifydate": "2005-01-04T16:03:01", "lines": 41, "newlines": 24, "modlines": 0, "user": "DWD"}, "text": "*/*********************************************************************\n*/* SRSKEY - Define SRS keywords                                      *\n*/*********************************************************************\n*/* Change log:                                                      */\n*/*   DWD 12/04: New for V121                                    V121*/\n*/*********************************************************************\n*\n         MACRO\n         SRSKEY &KEYWORD=,                                             X\n               &LOC=,                                                  X\n               &ROUTINE=0,                                             X\n               &TBLK=0,                                                X\n               &DEFAULT=0,                                             X\n               &ABBREV=0\n*\n         LA    R15,&LOC                Addr of loc to store value\n         ST    R15,SRSKWLOC            Save value addr\n         LA    R15,L'&LOC              Get length of storage loc\n         STC   R15,SRSKWLOL            Save length\n         LA    R15,&ROUTINE            Processing routine addr\n         ST    R15,SRSKWRTN            Save routine addr\n         AIF    ('&TBLK' EQ '0').NOTBLK\n         LA    R15,&TBLK-SRSTBLK       Offest of value into TBLK\n         STH   R15,SRSKWTBK            Save TBLK offset\n.NOTBLK  ANOP\n         AIF    ('&DEFAULT' EQ '0').NODEFA\n         LA    R15,&DEFAULT-SRSOPT     Offest of default into OPTS\n         STH   R15,SRSKWDEF            Save default offset\n.NODEFA  ANOP\n         LA    R15,=C'&KEYWORD'        Addr of keyword name\n         ST    R15,SRSKWNAM            Save name addr\n         LA    R15,L'=C'&KEYWORD'      Length of keyword name\n         STC   R15,SRSKWNAL            Save keyword name length\n         AIF    ('&ABBREV' EQ '0').NOABBREV\n         MVI   SRSKWSIG,&ABBREV        Set significant chars\n         AGO   .ABBREVX\n.NOABBREV ANOP\n         STC   R15,SRSKWSIG            All chars are significant\n.ABBREVX  ANOP\n         LA    R1,SRSKWL(R1)           Point to next entry\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SRSOPT": {"ttr": 16641, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x12\\x00\\x13\\x01\\x046O\\x01\\x060\\x0f\\x16S\\x00\\x8e\\x00U\\x00\\x00\\xc4\\xe6\\xc4@@@@@@@'", "ispf": {"version": "01.18", "flags": 0, "createdate": "2004-12-29T00:00:00", "modifydate": "2006-10-27T16:53:13", "lines": 142, "newlines": 85, "modlines": 0, "user": "DWD"}, "text": "*/*********************************************************************\n*/* SRSOPT - Specify SRS installtion-wide defaults                    *\n*/*********************************************************************\n*/* Change log:                                                      */\n*/*   DWD 12/04: New for V121                                    V121*/\n*/*********************************************************************\n*\n         MACRO\n         SRSOPT &DSECT=NO,                                             X\n               &CLASS=,                                                X\n               &DEST=LOCAL,                                            X\n               &DISP=DELETE,                                           X\n               &FORMS=STD,                                             X\n               &JOBNAME=,                                              X\n               &LIM=,                                                  X\n               &PPARM=,                                                X\n               &PROG=SRSGENER,                                         X\n               &SEP=NO,                                                X\n               &SEPID=*SRS>,                                           X\n               &STATUS=NONHELD,                                        X\n               &WAIT=,                                                 X\n               &WRITER=\n*\n         AIF    ('&DSECT' NE 'YES').NODSECT\nSRSOPT   DSECT\n&NEYE    SETC  'SRSOEYE'\n&NLVL    SETC  'SRSOLVL'\n&NCLS    SETC  'SRSOCLAS'\n&NDST    SETC  'SRSODEST'\n&NDISP   SETC  'SRSODISP'\n&NFORM   SETC  'SRSOFORM'\n&NJOBN   SETC  'SRSOJOBN'\n&NLIM    SETC  'SRSOLIMT'\n&NPPA    SETC  'SRSOPPRM'\n&NPGM    SETC  'SRSOPGMN'\n&NSEP    SETC  'SRSOSEPO'\n&NSEPI   SETC  'SRSOSEPI'\n&NSTAT   SETC  'SRSOSTAT'\n&NWAIT   SETC  'SRSOWAIT'\n&NWTR    SETC  'SRSOWTRN'\n         AGO   .GENCODE\n.NODSECT ANOP\nSRSOPT   CSECT\nSRSOPT   AMODE  31\nSRSOPT   RMODE  ANY\n&NEYE    SETC  ''\n&NLVL    SETC  ''\n&NCLS    SETC  ''\n&NDST    SETC  ''\n&NDISP   SETC  ''\n&NFORM   SETC  ''\n&NJOBN   SETC  ''\n&NLIM    SETC  ''\n&NPPA    SETC  ''\n&NPGM    SETC  ''\n&NSEP    SETC  ''\n&NSEPI   SETC  ''\n&NSTAT   SETC  ''\n&NWAIT   SETC  ''\n&NWTR    SETC  ''\n.GENCODE ANOP\n         AIF   ('&DISP' NE 'KEEP' AND '&DISP' NE 'DELETE').DISPERR\n         AIF   ('&SEP' NE 'YES' AND '&SEP' NE 'NO' AND                 X\n                '&SEP' NE 'JOB' AND '&SEP' NE 'OUTGRP' AND             X\n                '&SEP' NE 'DATASET').SEPERR\n         AIF   ('&STATUS' NE 'HELD' AND '&STATUS' NE 'NONHELD' AND     X\n                '&STATUS' NE 'ALL').STATERR\n.* Check for &CLASS= specified\n&DCLS    SETC  'DC'\n         AIF    ('&CLASS' NE '').DSET1\n&DCLS    SETC  'DS'\n.DSET1   ANOP\n.* Check if &DEST= specified\n&DDST    SETC  'DC'\n         AIF    ('&DEST' NE '').DSET2\n&DDST    SETC  'DS'\n.DSET2   ANOP\n.* Check if &FORMS= specified\n&DFORM   SETC  'DC'\n         AIF    ('&FORMS' NE '').DSET3\n&DFORM   SETC  'DS'\n.DSET3   ANOP\n.* Check if &JOBNAME= specified\n&DJOBN   SETC  'DC'\n         AIF    ('&JOBNAME' NE '').DSET4\n&DJOBN   SETC  'DS'\n.DSET4   ANOP\n.* Check if &PPARM= specified\n&DPPA    SETC  'DC'\n         AIF    ('&PPARM' NE '').DSET5\n&DPPA    SETC  'DS'\n.DSET5   ANOP\n.* Check if &SEPID= specified\n&DSEPI   SETC  'DC'\n         AIF    ('&SEPID' NE '').DSET6\n&DSEPI   SETC  'DS'\n.DSET6   ANOP\n.* Check if &WAIT= specified\n&DWAIT   SETC  'DC'\n         AIF    ('&WAIT' NE '').DSET7\n&DWAIT   SETC  'DS'\n.DSET7   ANOP\n.* Check if &WRITER= specified\n&DWTR    SETC  'DC'\n         AIF    ('&WRITER' NE '').DSET8\n&DWTR    SETC  'DS'\n.DSET8   ANOP\nSRSOMAC  EQU    2                       Level of SRSOPT         @A12101\n.*=====================================================================\n.* NOTE: Whenever this macro is updated, SRSOMAC *MUST* be incremented.\n.* This will force a re-assembly of any down-level options modules.\n.*=====================================================================\n&NEYE    DC     C'SRSOPT_&SYSDATE._&SYSTIME. '\n&NLVL    DC     AL1(SRSOMAC)            Options module level\n&NCLS    &DCLS  CL1'&CLASS'             SYSOUT Class\n&NDST    &DDST  CL18'&DEST'             Destination ID\n&NDISP   DC     CL6'&DISP'              Processed SYSOUT disposition\n&NFORM   &DFORM CL8'&FORMS'             Forms ID\n&NJOBN   &DJOBN CL8'&JOBNAME'           Jobname\n&NLIM    DC     CL4'&LIM'               SYSOUT limit\n&NPPA    &DPPA  CL100'&PPARM'           Despooling program parms\n&NPGM    DC     CL8'&PROG'              Despooling program name\n&NSEP    DC     CL7'&SEP'               Separator record option\n&NSEPI   &DSEPI CL8'&SEPID'             Separator record ID\n&NSTAT   DC     CL7'&STATUS'            SYSOUT status\n&NWAIT   &DWAIT CL3'&WAIT'              WAIT-for-SYSOUT option\n&NWTR    &DWTR  CL8'&WRITER'            WRITER ID\n         DS     0D\n         AIF    ('&DSECT' NE 'YES').NODLEN\nSRSOPTL  EQU    *-SRSOPT\n         AGO   .NOEND\n.NODLEN  ANOP\n         END\n.NOEND   ANOP\n         MEXIT\n.DISPERR MNOTE 8,'ERROR: DISP= must be KEEP or DELETE'\n         MEXIT\n.SEPERR  MNOTE 8,'ERROR: SEP= must be YES NO JOB OUTGRP or DATASET'\n         MEXIT\n.STATERR MNOTE 8,'ERROR: STATUS= must be HELD NONHELD or ALL'\n         MEXIT\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SRSOPTS": {"ttr": 13830, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x008\\x01\\x046_\\x01\\x05\\x19_\\x17\\x11\\x00\\x01\\x00\\x07\\x00\\x00\\xc4\\xe6\\xc4@@@@@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "2004-12-30T00:00:00", "modifydate": "2005-07-14T17:11:38", "lines": 1, "newlines": 7, "modlines": 0, "user": "DWD"}, "text": "         SRSOPT\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SRSPRHEX": {"ttr": 13832, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0f\\x00\\x13\\x00\\x88$/\\x01\\x05\\x19_\\x17\\x13\\x00+\\x00(\\x00\\x00\\xc4\\xe6\\xc4@@@@@@@'", "ispf": {"version": "01.15", "flags": 0, "createdate": "1988-08-29T00:00:00", "modifydate": "2005-07-14T17:13:13", "lines": 43, "newlines": 40, "modlines": 0, "user": "DWD"}, "text": "*PROCESS RENT\nSRSPRHEX TITLE '- HEX to EBCDIC conversion routine'\nSRSPRHEX CSECT , ATTR=RENT,REUS,REFR\nSRSPRHEX AMODE 31\nSRSPRHEX RMODE ANY\n***********************************************************************\n* SRS general purpose hexadecimal-to-ebcdic conversion routine        *\n*                                                                     *\n* This program converts hexadecimal characters to printable ebcdic    *\n* characters.                                                         *\n*                                                                     *\n* On entry to program,                                                *\n*   R1 - contains the four-byte hex field to be converted             *\n*   R13 - contains the address of an eighteen-byte save area          *\n*   R14 - contains the return address                                 *\n*   R15 - contains the program's entry point                          *\n* On return to caller,                                                *\n*   R0 & R1 - contains the converted string                           *\n***********************************************************************\n         SAVE  (14,12),,SRSPRHEX_&SYSDATE._&SYSTIME.\n         LR    R12,R15             Set up base reg\n         USING SRSPRHEX,R12        Establish addressability\n         LR    R5,R1               Save data\n         GETMAIN R,LV=WORKLEN      Get workarea core\n         LR    R11,R1              Save address\n         USING WORKAREA,R11\n         XC    WORKAREA(WORKLEN),WORKAREA      Clear work area\n         ST    R5,FIELD1           Move data to work area\n         UNPK  FIELD2(9),FIELD1(5)\n         NC    FIELD2(8),=X'0F0F0F0F0F0F0F0F'  Turn off high order bits\n         TR    FIELD2(8),=C'0123456789ABCDEF'  Convert to EBCDIC\n         LM    R3,R4,FIELD2        Load translated data\n         FREEMAIN R,A=(R11),LV=WORKLEN         Free work area\n         LR    R0,R3\n         LR    R1,R4\n         L     R14,12(R13)         Restore R14\n         RETURN (3,12),,RC=0       Return\nWORKAREA DSECT\nFIELD1   DS    F,CL1\nFIELD2   DS    2F,CL1\nWORKLEN  EQU   *-WORKAREA\n         YREGS\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SRSTASK": {"ttr": 17157, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01O\\x00P\\x00\\x976O\\x01\\x060\\x0f\\x175\\x05\\xa2\\x03\\xb3\\x00\\x00\\xc4\\xe6\\xc4@@@@@@@'", "ispf": {"version": "01.79", "flags": 0, "createdate": "1997-12-30T00:00:00", "modifydate": "2006-10-27T17:35:50", "lines": 1442, "newlines": 947, "modlines": 0, "user": "DWD"}, "text": "*PROCESS RENT,FLAG(PAGE0)                                          V121\nSRSTASK TITLE '- SYSOUT Retrieval Services (SRS) SAPI interface'\nSRSTASK CSECT , ATTR=RENT,REUS,REFR\nSRSTASK AMODE 31\nSRSTASK RMODE 24\n*=====================================================================*\n*                                                                     *\n*  MODULE NAME:  SRSTASK                                              *\n*                                                                     *\n*  DESCRIPTIVE-NAME: SYSOUT Retrieval Services (SRS) SAPI interface   *\n*                                                                     *\n*  STATUS: OS/390 JES2 Release 3 and higher                           *\n*                                                                     *\n*  OPERATION:                                                         *\n*                                                                     *\n*    SRSTASK takes SYSOUT datasets from the JES2 spool, and calls     *\n*    a user-written program to process the datasets.                  *\n*                                                                     *\n*    The SRSDRVR program attaches one SRSTASK for each unique         *\n*    combination of supported selection criteria, which are:          *\n*                                                                     *\n*       1) SYSOUT class                                               *\n*       2) Jobname                                                    *\n*       3) Destination                                                *\n*       4) Forms ID                                                   *\n*       5) JES2 jobid                                                 *\n*       6) User-writer name                                           *\n*       7) DDNAME of spool data set                                V120\n*                                                                     *\n*    The name of the program to be invoked to process the datasets    *\n*    is passed in the SRSTBLK.  Immediately after the program is      *\n*    loaded, it is called with an initialization bit on.  Similarly,  *\n*    just prior to being deleted, it is called with a termination     *\n*    indicator set.  After a dataset is returned from                 *\n*    the SSI, the program is called with a \"start-of-dataset\"         *\n*    indicator.  The program is then called for each record read, and *\n*    then once more with an \"end-of-file\" indicator.  At any time,    *\n*    the program can return a non-zero return code, and stop the      *\n*    SSI.                                                             *\n*                                                                     *\n*    NOTES:                                                           *\n*      This program uses the SYSOUT Application Program Interface     *\n*      (SAPI) - SSI Function Code 79 - subsystem                      *\n*      brodcast to request sysout from JES2.  This support was        *\n*      introduced in OS/390 Release 3.                                *\n*                                                                     *\n*      A state-switching routine is attached which allows the         *\n*      user program to always be invoked APF un-authorized,           *\n*      PSW key 8, problem state.                                      *\n*                                                                     *\n*                                                                     *\n*      The program issues the following Return Codes:                 *\n*                                                                     *\n*        0 - Normal completion                                        *\n*        4 - No SYSOUT datasets were processed                        *\n*       16 - The user-supplied program requested the SRS interface    *\n*            to shutdown or rejected the dataset                      *\n*       20 - A SAPI error was encountered                             *\n*       24 - A catastrophic error occurred                            *\n*       32 - SRSTASK abended processing a spool dataset               *\n*                                                                     *\n*                                                                     *\n*    ATTRIBUTES:                                                      *\n*                                                                     *\n*      Location:  resident in own address space                       *\n*      State:  problem & supervisor, must be APF authorized           *\n*      Amode:  31-bit                                                 *\n*      Rmode:  24-bit                                                 *\n*      Key:  key 0,8                                                  *\n*      Mode:  task                                                    *\n*      Serialization: none                                            *\n*      Type:  Reentrant                                               *\n*                                                                     *\n*  Written By: Dave Danner                                      @A11202\n*              Summit Technical Services, Inc.                  @A11202\n*                                                               @A11202\n*          January, 1998                                              *\n*                                                                     *\n*  Change log:                                                        *\n*    DWD 04/98: Add DISP=KEEP/DELETE support                       V111\n*    DWD 01/99: Reset ECBPOST prior to IEFSSREQ                 @A11101\n*    DWD 03/99: STATUS= support                                 @A11102\n*    DWD 03/99: Fix ABEND0C4 HASCHAM+4F6                        @A11103\n*    DWD 07/99: STC/TSU support for JOBID (JI=) parameter          V112\n*               Fix S001-3 abends following system crash           V112\n*    DWD 09/99: Document non-zero RC's from SSI call            @A11201\n*    DWD 05/00: Eliminate termination due to SSOBRETN=12        @A11203\n*    DWD 05/01: Don't delete last dataset if SRSTASK abends     @A11204\n*    DWD 03/02: Recursive abends after SD37 abend during CLOSE  @A11205\n*    DWD 03/02: 7-digit job numbers in JOIID                    @A11206\n*    DWD 09/03: Select by DDNAME                                   V120\n*               Support for parameter list passed to despool pgm   V120\n*    DWD 12/04: Separator record support                           V121\n*               Installation defaults                              V121\n*    DWD 10/06: Expand DEST to 18 characters                    @A12101\n*=====================================================================*\n         USING SRSTASK,R15          Temporary base\n         B     START                Branch around eyecatcher\n         DC    C'SRSTASK_&SYSDATE._&SYSTIME. '                     V121\n         DC    C'COPYRIGHT 1998-2005 DAVID W DANNER '              V121\n         DC    C'ALL RIGHTS RESERVED'                              V121\nSTART    DS    0H\n         DROP  R15                  Drop temporary addressability\n         SAVE  (14,12)              Save regs\n         LR    R12,R15              Set base register\n         USING SRSTASK,R12\n         LA    R11,4095(R12)        Set second base register\n         LA    R11,1(R11)           Set second base register\n         USING SRSTASK+4096,R11\n         LR    R6,R1                Save address of SRSTBLK\n         USING SRSTBLK,R6           And address it\n*\n         MODESET MODE=SUP           Get supervisor state\n         STORAGE OBTAIN,LENGTH=SRSTLEN,LOC=BELOW,KEY=8,SP=132\n         LR    R4,R1                Copy work area address\n         LA    R5,SRSTLEN           Get length of work area\n         SLR   R15,R15              Zero source length for MVCL\n         LR    R14,R15              Zero source address for MVCL\n         MVCL  R4,R14               Clear entire work area\n         ST    R13,4(,R1)           Save caller's save area address\n         ST    R1,8(,R13)           Save our SA addr in caller's SA\n         LR    R13,R1               Point to my save area\n         USING SRSTWORK,R13         Address work area\n         USING S99RB,SVC99RBB       Address SVS99 RB in work area\n*\n         BAL   R10,SETUP           Perform general setup functions\n         LTR   R15,R15             Was setup successfull ?\n         BNZ   RETURN              No, quit now\n         TM    STATUS,STATREJ      Reject from user pgm ?\n         BO    PROGREJ             Yes, tell oper & quit now\n         SPACE 5\n*=====================================================================*\n* Initialize an SSOB to make the SAPI call                            *\n*=====================================================================*\n         MODESET EXTKEY=ZERO,SAVEKEY=(2)  Get PSW key zero\n         GETMAIN R,LV=BUFSSLEN,SP=228     Get storage for SSOB\n         ST    R1,WORKSSOB         Save address of SSOB work area\n         USING BUFSSWK,R1          Address SSOB buffer\n         LA    R7,BUFSSOB          Point at actual SSOB\n         ST    R7,BUFSSPTR         Save in ptr for IEFSSREQ\n         OI    BUFSSPTR,X'80'      Turn on high-order bit\n         DROP  R1\n         USING SSOB,R7\n         LR    R4,R7               Copy SSOB address\n         LA    R5,SSOFLEN          Get length of SSOB buffer\n         SLR   R15,R15             Zero source length for MVCL\n         LR    R14,R15             Zero source address for MVCL\n         MVCL  R4,R14              Clear entire SSOB\n         MVC   SSOB(WTRSOSIZ),WTRSSOB Initialize header\n         LA    R3,SSOBGN           Initialize ssob\n         ST    R3,SSOBINDV         Save address of sysout extention\n         LA    R4,SSS2SIZE         Get sysout extention size\n         STH   R4,SSS2LEN          Save in SAPI extention\n         MVI   SSS2VER,SSS2CVER    Set version in SAPI extention\n         MVC   SSS2EYE,=C'SSS2'    Set eyecatcher in SAPI extention\n         MVI   SSS2TYPE,SSS2PUGE   Indicate PUT/GET request\n*DEL     MVI   SSS2SEL1,SSS2SWTR   Select only ODISP=WRITE or KE@A11102\n         LA    R15,ECBSAPI         Get the SAPI ECB addr\n         ST    R15,SSS2ECBP        Save in SAPI extention\n         CLI   SRSTCLAS,X'00'      Select by SYSOUT class ?\n         BE    NOCLASS             No, continue\n         MVI   SSS2CLSL,C' '       Init SSS2CLSL to blanks\n         MVC   SSS2CLSL+1(L'SSS2CLSL-1),SSS2CLSL\n         MVC   SSS2CLSL(1),SRSTCLAS   Set class to select\n         OI    SSS2SEL1,SSS2SCLS   Check SYSOUT class\nNOCLASS  DS    0H\n         CLI   SRSTJOBN,X'00'      Select by jobname ?\n         BE    NOJOBNM             No, continue\n         MVC   SSS2JOBN,SRSTJOBN   Set jobname to select\n         OI    SSS2SEL1,SSS2SJBN   Check jobname\nNOJOBNM  DS    0H\n         CLC   =CL4'ALL',SRSTDEST  Select all destinations ?    @A12101\n         BE    NODEST              Yes, skip dest checking\n         OI    SSS2SEL1,SSS2SDST   Check destination\n         MVC   SSS2DEST,SRSTDEST   Set destid to check             V121\nNODEST   DS    0H\n         CLC   SRSTFORM,=CL8'ALL'  Select all forms?               V121\n         BE    NOFORM              Yes, skip forms checking        V121\n         OI    SSS2SEL2,SSS2SFRM   Check forms\n         MVI   SSS2FORM,C' '       Init forms fields to blanks\n         MVC   SSS2FORM+1(L'SSS2FORC-1),SSS2FORM\n         MVC   SSS2FORM(8),SRSTFORM Set forms ID to check          V121\nNOFORM   DS    0H\n         CLI   SRSTJBID,X'00'      Select by jobid ?\n         BE    NOJBID              No, continue\n         MVC   SSS2JBIL,SRSTJBID   Set low jobid\n         MVC   SSS2JBIH,SRSTJBID   Set high jobid\n         OI    SSS2SEL1,SSS2SJBI   Check jobid\n         MVI   SSS2SEL3,SSS2SJOB   Assume JOB                      V112\n         CLI   SRSTJBID,C'J'       Selecting batch job ?           V112\n         BE    NOJBID              Yes, continue                   V112\n         MVI   SSS2SEL3,SSS2SSTC   Assume STC                      V112\n         CLI   SRSTJBID,C'S'       Selecting started tasks ?       V112\n         BE    FIXJBID             Yes, reset JBID to 'JOB'        V112\n         MVI   SSS2SEL3,SSS2STSU   Must be selecting TSU           V112\nFIXJBID  DS    0H                                                  V112\n         MVI   SSS2JBIL,C'J'       Reset low jobid              @A11206\n         MVI   SSS2JBIH,C'J'       Reset high jobid             @A11206\nNOJBID   DS    0H\n         CLC   SRSTWTRN,=CL8'ALL'  Select all writer ID's?         V121\n         BE    NOWTRN              Yes, skip writer ID checking    V121\n         OI    SSS2SEL2,SSS2SPGM   Check writer name\n         MVC   SSS2PGMN,=CL8' '    If not spec, verify null writer\n         CLI   SRSTWTRN,X'00'      Select by writer name ?\n         BE    NOWTRN              No, continue\n         MVC   SSS2PGMN,SRSTWTRN   Set writer ID to check          V121\nNOWTRN   DS    0H\n         TM    SRSTFLAG,SRSTSHLD+SRSTSNHL Select all output?    @A11102\n         BNO   NOSALL                                           @A11102\n         OI    SSS2SEL1,SSS2SAWT   Select all output            @A11102\nNOSALL   DS    0H                                               @A11102\n         TM    SRSTFLAG,SRSTSNHL   Select NONHELD output?       @A11102\n         BNO   NOSNHL                                           @A11102\n         OI    SSS2SEL1,SSS2SWTR   Select ODISP=WRITE/KEEP      @A11102\nNOSNHL   DS    0H                                               @A11102\n         TM    SRSTFLAG,SRSTSHLD   Select HELD output?          @A11102\n         BNO   NOSHLD                                           @A11102\n         OI    SSS2SEL1,SSS2SHLD   Select ODISP=HOLD/LEAVE      @A11102\nNOSHLD   DS    0H                                               @A11102\n         SPACE 3\n         MODESET KEYREG=(2)        RESET PSW KEY\n* Write \"initialization complete\" message\n         TM    SRSTFLAG,SRSTWLIM   WTO limit option on ?\n         BO    NO003I              Yes, skip SRS003I\n         MVC   WTOBUFF+2(L'SRS003I),SRS003I\n         LA    R15,L'SRS003I       Get length of message\n         STH   R15,WTOBUFF         Save length in WTO\n         MVC   WTOBUFF+13(2),SRSTWRID  Move in SRS task ID\n         MVC   WTOPARMB,WTOPARM    Move WTO parm to buffer\n         WTO   TEXT=WTOBUFF,MF=(E,WTOPARMB) Write SHUTDOWN request\nNO003I   DS    0H\n         OI    SRSTFLAG,SRSTACT    Task is now active\n*=====================================================================*\n* Establish a recovery routine.                                       *\n*=====================================================================*\n         STM   R2,R12,ESTAREGS     Save current regs for recovery rtn\n         MVC   WTOBUFF(ESTAPRML),ESTAPARM Move in ESTAE parm list\n         ACONTROL FLAG(NOPAGE0)    ESTAE uses IX instead of base   V121\n         ESTAE STAEXIT,TERM=YES,PARAM=(R13),MF=(E,WTOBUFF)\n         ACONTROL FLAG(PAGE0)      Restore PAGE0 checking          V121\n         OI    STATUS,STATESTA     Flag ESTAE now in effect\n*=====================================================================*\n* Make the SAPI SSI call to request sysout from JES2                  *\n*=====================================================================*\nGETWORK  DS    0H\n         L     R1,ECBCOMM          Get addr ecb posted by driver\n         TM    0(R1),ECBPOST       Were we posted ?\n         BO    PROCDRVR            Yes, check it out\n         CLC   SRSTLIMT,=AL2(0)    Limit number datasets selected?\n         BE    NOLIMCK             No, bypass check\n         L     R15,SRSTCNT         Pick up current dataset count\n         CH    R15,SRSTLIMT        Limit hit ?\n         BL    NOLIMCK             No, keep processing\n         MVC   WTOBUFF+2(L'SRS021I),SRS021I\n         LA    R15,L'SRS021I       Get length of message\n         STH   R15,WTOBUFF         Save length in WTO\n         MVC   WTOPARMB,WTOPARM    Move WTO parm to buffer\n         WTO   TEXT=WTOBUFF,MF=(E,WTOPARMB)\n         B     STOPXWTR            Shutdown now\nNOLIMCK  DS    0H\n         NI    ECBSAPI,X'FF'-ECBPOST Reset POST bit in SAPI ECB @A11101\n         L     R1,WORKSSOB         Point at addr of addr of ssob\n         MODESET EXTKEY=ZERO,SAVEKEY=(2)  Get psw key zero\n         IEFSSREQ                  Ask jes2 for sysout\n         ST    R15,SSIRC           Save return code             @A11201\n         MODESET KEYREG=(2)        Reset psw key\n         ICM   R15,15,SSIRC        SSI RC=0 ?                   @A11201\n         BNZ   SAPIERR             No, handle SAPI error        @A11201\nSSRCHEK  DS    0H\n         OI    STATUS,STATSAPI     SAPI interface is active\n         CLC   SSOBRETN,=A(SSS2RTOK)  SYSOUT dataset returned ?\n         BE    PROCDS              Yes, go process it\n         CLC   SSOBRETN,=A(SSS2EODS)   Any more datasets ?\n         BE    WAITDS              Yes, wait for some\n         CLC   SSOBRETN,=A(SSS2UNAV)   Unavailable now ?        @A11203\n         BE    SAPIUNAV            Yes, wait and try again      @A11203\nSAPIERR  DS    0H                                               @A11201\n*===============================================================@A11201\n* The SAPI call failed.  Either IEFSSREQ returned a non-zero RC @A11201\n* in R15, or SSOBRETN was greater than 4.  Write the SRS100E    @A11201\n* message to document each code, then write a second line to    @A11201\n* report the textual meaning of the error.                      @A11201\n*===============================================================@A11201\n         MVC   WTOBUFF+2(L'SRS100E),SRS100E                     @A11201\n         LA    R15,L'SRS100E       Get length of message        @A11201\n         STH   R15,WTOBUFF         Save length in WTO           @A11201\n         L     R15,PSATOLD-PSA(,0)        Get TCB address       @A11201\n         L     R15,TCBJSCB-TCB(,R15)      Get JSCB address      @A11201\n         L     R15,JSCBSSIB-IEZJSCB(,R15) Get SSIB address      @A11201\n         MVC   WTOBUFF+37(L'SSIBSSNM),SSIBSSNM-SSIB(R15) SSN    @A11201\n         L     R15,SSIRC           Get SSI RC                   @A11201\n         CVD   R15,DOUBWORK        Make it decimal              @A11201\n         OI    DOUBWORK+7,X'0F'    Fix up sign                  @A11201\n         UNPK  WTOBUFF+49(2),DOUBWORK+6(2)  Move to msg         @A11201\n         L     R15,SSOBRETN        Get SSOB return code         @A11201\n         CVD   R15,DOUBWORK        Make it decimal              @A11201\n         OI    DOUBWORK+7,X'0F'    Fix up sign                  @A11201\n         UNPK  WTOBUFF+62(2),DOUBWORK+6(2)  Move to msg         @A11201\n         SLR   R15,R15             Clear work reg               @A11201\n         IC    R15,SSS2REAS        Get reason code              @A11201\n         CVD   R15,DOUBWORK        Make it decimal              @A11201\n         OI    DOUBWORK+7,X'0F'    Fix up sign                  @A11201\n         UNPK  WTOBUFF+70(2),DOUBWORK+6(2)  Move to msg         @A11201\n         MVC   WTOPARMB,WTOPARM    Move WTO parm to buffer      @A11201\n         WTO   TEXT=WTOBUFF,DESC=2,MF=(E,WTOPARMB) Write msg    @A11201\n         ICM   R15,15,SSIRC        Get SSI RC                   @A11201\n         BZ    CKSSORC             If zero, use SSOB RC         @A11201\n         C     R15,=A(HISSIRC)     RC w/in range of known RC's? @A11201\n         BH    SAPIERRX            Yes, no description          @A11201\n         LA    R5,SSIMSG           Set pointer to msg table     @A11201\n         B     SAPIEDES            Get error description        @A11201\nCKSSORC  DS    0H                                               @A11201\n         L     R15,SSOBRETN        Get SSOB return code         @A11201\n         C     R15,=A(HISSORC)     RC w/in range of known RC's? @A11201\n         BH    SAPIERRX            Yes, no description          @A11201\n         LA    R5,SSOMSG           Set pointer to msg table     @A11201\nSAPIEDES DS    0H                                               @A11201\n         SH    R15,=H'4'           Set msg index                @A11201\n         L     R5,0(R5,R15)        Point at msg len & text      @A11201\n         IC    R15,0(,R5)          Get length of msg               V121\n         BCTR  R15,0               Prep for execute             @A11201\n         EX    R15,MVCSSIM         Move in error text           @A11201\n         LA    R15,1+8(R15)        Rest length & add msgid      @A11201\n         STH   R15,WTOBUFF         Save length in WTO           @A11201\n         MVC   WTOPARMB,WTOPARM    Move WTO parm to buffer      @A11201\n         WTO   TEXT=WTOBUFF,DESC=2,MF=(E,WTOPARMB) Write msg    @A11201\nSAPIERRX DS    0H                                               @A11201\n         LA    R15,20              Set SAPI error RC            @A11201\n         ST    R15,SRSTRC          Save in block                @A11201\n         B     STOPXWTR            Go shutdown                  @A11201\nMVCSSIM  MVC   WTOBUFF+10(*-*),1(R5)                            @A11201\n         EJECT                                                  @A11201\n*===============================================================@A11203\n* JES not available now.  Wait and try the call again.          @A11203\n*===============================================================@A11203\nSAPIUNAV DS    0H                                               @A11203\n         MVC   WTOBUFF+2(L'SRS025I),SRS025I                     @A11203\n         LA    R15,L'SRS025I       Get length of message        @A11203\n         STH   R15,WTOBUFF         Save length in WTO           @A11203\n         MVC   WTOPARMB,WTOPARM    Move WTO parm to buffer      @A11203\n         WTO   TEXT=WTOBUFF,MF=(E,WTOPARMB) Write message       @A11203\n         STIMER WAIT,DINTVL=SAPIWAIT  Wait just a minute        @A11203\n         B     GETWORK             And try the call again       @A11203\n         EJECT                                                  @A11203\n*=====================================================================*\n* No sysout datasets are available.  Wait for some.                   *\n*=====================================================================*\nWAITDS   DS    0H\n         OI    STATUS,STATWADS     Set wait-for-datasets\n         TM    SRSTFLAG,SRSTNOWT   Not waiting for datasets ?\n         BO    STOPXWTR            Yes, shutdown now\n         L     R15,SSS2ECBP        Get address of ecb jes2 will post\n         ST    R15,ECBSSOB         Save in ecb list\n         OI    ECBSSOB,X'80'       Set end-of list bit\nWAITM    DS    0H\n         MODESET EXTKEY=ZERO,SAVEKEY=(2)  Get psw key zero\n         WAIT  1,ECBLIST=ECBLIST   Wait for sysout or stop/modify\n         MODESET KEYREG=(2)        Reset psw key\n         B     GETWORK             Go get more sysout\n*=====================================================================*\n* Process the dataset returned.                                       *\n*=====================================================================*\nPROCDS   DS    0H\n         BAL   R10,PROCESS         Call routine to process the dataset\n         TM    STATUS,STATREJ      Was dataset rejected ?\n         BO    PROGREJ             Yes, tell oper & quit now\n         LTR   R15,R15             Dataset processed ?\n         BZ    GETWORK             Yes, request more SYSOUT from JES2\n         B     CATASTRO            Go issue horrible msg & shutdown\n         SPACE 3\n*==================================================================\n* The user-supplied program requested SRS processing stop.\n*==================================================================\nPROGREJ  DS    0H\n         MVC   WTOBUFF+2(L'SRS010I),SRS010I\n         LA    R15,L'SRS010I       Get length of message\n         STH   R15,WTOBUFF         Save length in WTO\n         MVC   WTOBUFF+13(2),SRSTWRID  Move in SRS task ID\n         MVC   WTOBUFF+38(8),SRSTPGMN  Move in user program name\n         MVC   WTOPARMB,WTOPARM    Move WTO parm to buffer\n*DEL120  OI    WTOPARMB+X'1C',X'40'   Set DESC=2                   V120\n         WTO   TEXT=WTOBUFF,MF=(E,WTOPARMB) Write SHUTDOWN request\n         TM    STATUS,STATSAPI     Is the SAPI interface active?   V120\n         BNO   NOSSOBSH            No, SSOB ain't there            V120\n         OI    SSS2DSP1,SSS2DKPE   Keep last dataset selected\nNOSSOBSH DS    0H                                                  V120\n         LA    R15,16              Set return code\n         ST    R15,SRSTRC          Save in block\n         B     STOPXWTR            Go shutdown\n*\nCATASTRO DS    0H\n         MVC   WTOBUFF+2(L'SRS110E),SRS110E\n         LA    R15,L'SRS110E       Get length of message\n         STH   R15,WTOBUFF         Save length in WTO\n         MVC   WTOBUFF+34(2),SRSTWRID  Move in SRS task ID\n         MVC   WTOPARMB,WTOPARM    Move WTO parm to buffer\n         OI    WTOPARMB+X'1C',X'80'   Set DESC=1\n         WTO   TEXT=WTOBUFF,MF=(E,WTOPARMB) Write SHUTDOWN request\n         LA    R15,24              Set return code\n         ST    R15,SRSTRC          Save in block\n         B     STOPXWTR            Go shutdown\n*=====================================================================*\n* Process the request from the driver.                                *\n*=====================================================================*\nPROCDRVR DS    0H\n         OI    SRSTECBX,X'FF'-ECBPOST  Clear POST bit\n         TM    SRSTFLAG,SRSTSHUT   Should we shutdown ?\n         BNO   WAITM               No, go wait again\nSTOPXWTR DS    0H\n         TM    STATUS,STATSAPI     Is the SAPI interface active?   V120\n         BNO   RETURN              No, skip these checks           V120\n         XC    SSS2JBIR,SSS2JBIR   Clear the SSOB jobid            V120\n         BAL   R9,CKDDNAME         ...and perform DDNAME check     V120\n* See if any datasets were selected from spool\n         ICM   R15,15,SRSTCNT      Get number of datasets selected\n         BNZ   DSELECTY            Branch if any selected\n         ICM   R15,15,SRSTRC       Get task RC                  @A11201\n         BNZ   DSELECTY            If error ocurred, skip msg   @A11201\n         MVC   WTOBUFF+2(L'SRS020I),SRS020I\n         LA    R15,L'SRS020I       Get length of message\n         STH   R15,WTOBUFF         Save length in WTO\n         MVC   WTOPARMB,WTOPARM    Move WTO parm to buffer\n         WTO   TEXT=WTOBUFF,MF=(E,WTOPARMB)\n         LA    R15,4               Set return code\n         C     R15,SRSTRC          Worse RC already issued ?\n         BL    DSELECTY            Yes, keep worse one\n         ST    R15,SRSTRC          Save in block\n         B     SHUTDOWN            Start shutdown\nDSELECTY DS    0H\n         TM    SRSTFLAG,SRSTSHUT   Was a STOP cmd issued ?\n         BO    STRTSHUT            Yes, write SHUTDOWN message\n         TM    SRSTFLAG,SRSTNOWT   Not waiting for datasets ?\n         BNO   SHUTDOWN            No, skip message\n         TM    STATUS,STATWADS     Did we wait-for-datasets ?\n         BNO   SHUTDOWN            No, skip message\n         MVC   WTOBUFF+2(L'SRS022I),SRS022I\n         LA    R15,L'SRS022I       Get length of message\n         STH   R15,WTOBUFF         Save length in WTO\n         MVC   WTOPARMB,WTOPARM    Move WTO parm to buffer\n         WTO   TEXT=WTOBUFF,MF=(E,WTOPARMB)\n         B     SHUTDOWN            Start shutdown\nSTRTSHUT DS    0H\n* Write \"SHUTDOWN in progress\" message\n         MVC   WTOBUFF+2(L'SRS011I),SRS011I\n         LA    R15,L'SRS011I       Get length of message\n         STH   R15,WTOBUFF         Save length in WTO\n         MVC   WTOBUFF+13(2),SRSTWRID  Move in SRS task ID\n         MVC   WTOPARMB,WTOPARM    Move WTO parm to buffer\n         WTO   TEXT=WTOBUFF,MF=(E,WTOPARMB) Write SHUTDOWN request\n*=====================================================================*\n* Tell JES2 we no longer want sysout.                                 *\n*=====================================================================*\nSHUTDOWN DS    0H\n         MODESET EXTKEY=ZERO,SAVEKEY=(2)  GET PSW KEY ZERO\n         OI    SSS2MSC1,SSS2CTRL   Indicate Processing Complete\n         L     R1,WORKSSOB         Point at addr of addr of ssob\n         IEFSSREQ                  Tell JES2 we are all done\n* Document SRS interface deactivated\n         TM    SRSTFLAG,SRSTWLIM   WTO limit option on ?\n         BO    NO012I              Yes, skip SRS012I\n         MVC   WTOBUFF+2(L'SRS012I),SRS012I\n         LA    R15,L'SRS012I       Get length of message\n         STH   R15,WTOBUFF         Save length in WTO\n         MVC   WTOBUFF+13(2),SRSTWRID  Move in SRS task ID\n         MVC   WTOPARMB,WTOPARM    Move WTO parm to buffer\n         WTO   TEXT=WTOBUFF,MF=(E,WTOPARMB) Write SRS SSI closed\nNO012I   DS    0H\n*\n         L     R1,WORKSSOB         Get address of ssob buffer\n         FREEMAIN R,A=(1),LV=BUFSSLEN,SP=228   FREE IT\n         MODESET KEYREG=(2)        RESET PSW KEY\nRETURN   DS    0H\n         TM    STATUS,STATLOAD     User program loaded ?\n         BNO   NOLOAD              No, continue\n* Call the user-written routine for the termination call\n         BAL   R9,UNAUTH           Establish unauthorized env\n         MVI   SRSFLAGS,SRSTERM    Set initialization indicator\n         LA    R1,SRSDATA          Get address of SRSDATA block\n         L     R15,SRSPGMA         Get address of user program\n         BASSM R14,R15             Call user program\n         SRSAMODE 31,R=R1          Force AMODE31                   V111\n         BAL   R9,AUTH             Establish authorized env\nNOTCALL  DS    0H                                               @A11205\n         LA    R1,SRSTPGMN         Get address of program name\n         DELETE  EPLOC=(1)         Delete the routine\nNOLOAD   DS    0H\n         TM    SRSTFLAG,SRSTWLIM   WTO limit option on ?\n         BO    NO013I              Yes, skip SRS013I\n         MVC   WTOBUFF+2(L'SRS013I),SRS013I\n         LA    R15,L'SRS013I       Get length of message\n         STH   R15,WTOBUFF         Save length in WTO\n         MVC   WTOBUFF+13(2),SRSTWRID  Move in SRS task ID\n         MVC   WTOPARMB,WTOPARM    Move WTO parm to buffer\n         WTO   TEXT=WTOBUFF,MF=(E,WTOPARMB) Write SRS SSI closed\nNO013I   DS    0H\n*\n         MVI   SRSAREQ,SRSATERM    Set termination request\n         POST  SRSAAECB            Terminate SRSAUTH subtask\n         WAIT  1,ECB=SRSATECB      Wait for completion\n         LA    R1,AUTHTCB          Point at TCB\n         DETACH (1)                Detach SRSAUTH\n         TM    STATUS,STATESTA     Was ESTAE issued ?\n         BZ    NOESTAE             No, skip cancel\n         ESTAE 0                   Cancel ESTAE\nNOESTAE  DS    0H\n         LR    R1,R13               Save getmained storage address\n         L     R13,SAVE+4           Restore caller's save area addr\n         STORAGE RELEASE,LENGTH=SRSTLEN,ADDR=(1),SP=132,KEY=8\n         NI    SRSTFLAG,X'FF'-SRSTACT    Task is now inactive\n         RETURN (14,12),,RC=0        Return to caller\n         EJECT\n*=====================================================================*\n* General setup routine.                                              *\n*  1) Initialize global variables and work area.                      *\n*  2) Initialize the ECB list.                                        *\n*  3) Set up the allocation parm.                                     *\n*  4) Attach the authorization subtask (SRSAUTH).                     *\n*  5) Load the user routine to process the dataset.                   *\n*  6) Switch to problem state, key 8, not APF authorized.             *\n*  7) Call the user program with the initialization flag on.          *\n*=====================================================================*\nSETUP    DS    0H\n* Initialize global variables and work area.\n         LA    R1,TASKRETR             Get ESTAE retry routine addr\n         ST    R1,TASKRETA             Save it\n         MVC   SYSSAPI,SYSSRSD         Initialize the SYSSRS DCB\n         CLI   SRSTDDNM,C' '           Select by DDNAME ?          V120\n         BNH   SETSV99                 No, skip flag set           V120\n         OI    STATUS2,STA2DDNS        Set select-by-DDNAME        V120\nSETSV99  DS    0H                                                  V120\n* Set up the SVC99 parms\n         LA    R1,SVC99RBB             Get address of request block\n         ST    R1,SVC99P               Save in pointer\n         OI    SVC99P,S99RBPND         Set end-of-list\n         MVI   S99RBLN,S99RBEND-S99RB  Set length\n*\nU1       USING S99TUNIT,ALTXTU1        Addressability to text unit\n         LA    R1,ALTXTU1              Get address of text unit\n         ST    R1,AALTXTU1             Save in pointer list\n         MVC   U1.S99TUKEY,=AL2(DALDDNAM)   Set \"DDNAME\" key\n         MVC   U1.S99TUNUM,=AL2(1)          Set number of entries\n         MVC   U1.S99TULNG,=AL2(L'ALLOCDDN) Set length of entry\n         MVC   ALLOCDDN,=C'SYSSAPI'    Set DDNAME\n         DROP  U1\n*\nU2       USING S99TUNIT,ALTXTU2        Addressability to text unit\n         LA    R1,ALTXTU2              Get address of text unit\n         ST    R1,AALTXTU2             Save in pointer list\n         MVC   U2.S99TUKEY,=AL2(DALDSNAM)   Set \"DSN=\" key\n         MVC   U2.S99TUNUM,=AL2(1)          Set number of entries\n         MVC   U2.S99TULNG,=AL2(L'ALLOCDSN) Set length of entry\n         DROP  U2\n*\nU3       USING S99TUNIT,ALTXTU3        Addressability to text unit\n         LA    R1,ALTXTU3              Get address of text unit\n         ST    R1,AALTXTU3             Save in pointer list\n         MVC   U3.S99TUKEY,=AL2(DALSSREQ)   Set \"SUBSYS=\" key\n         MVC   U3.S99TUNUM,=AL2(1)          Set number of entries\n         MVC   U3.S99TULNG,=AL2(L'ALLOCSSN) Set length of entry\n         DROP  U3\n*\nU4       USING S99TUNIT,ALTXTU4        Addressability to text unit\n         LA    R1,ALTXTU4              Get address of text unit\n         ST    R1,AALTXTU4             Save in pointer list\n         MVC   U4.S99TUKEY,=AL2(DALSTATS) Set \"DISP=\" key\n         MVC   U4.S99TUNUM,=AL2(1)        Set number of entries\n         MVC   U4.S99TULNG,=AL2(1)        Set length of entry\n         MVI   ALLOCDSP,X'01'          Set \"OLD\"\n         DROP  U4\n* Initialize the ECB list.\n         LA    R15,SRSTECBX            ECB SRSDRVR will POST\n         ST    R15,ECBCOMM             SAVE IN ECB LIST\n* Set up the allocation parm.\n         L     R15,PSATOLD-PSA(,0)     GET MY TCB ADDRESS\n         L     R15,TCBJSCB-TCB(,R15)   GET JSCB ADDRESS\n         L     R15,JSCBSSIB-IEZJSCB(,R15) GET SSIB ADDRESS\n         MVC   ALLOCSSN,SSIBSSNM-SSIB(R15)\n* Attach the authorization subtask (SRSAUTH).\n         MVC   SRSABLKE,=CL8'SRSABLK'  Set SRSABLK eye-catcher     V120\n         LA    R1,SRSABLK          Get address of auth blk\n         MVC   WTOBUFF(ATTPARML),ATTPARM  Move in ATTACH parm list\n         ATTACH EP=SRSAUTH,ECB=SRSATECB,SF=(E,WTOBUFF)  Do ATTACH\n         ST    R1,AUTHTCB          Save TCB address\n* Load the user-written routine to process the dataset\n         LA    R1,SRSTPGMN         Get address of program name\n         LOAD  EPLOC=(1)           Load the routine                V121\n         ST    R0,SRSPGMA          Save entry point of program\n         OI    STATUS,STATLOAD     Indicate program has been loaded\n* Switch to problem state, key 8, not APF authorized.\n         BAL   R9,UNAUTH           Set unauthorized mode\n* Call the user program with the initialization flag on.\n         MVI   SRSFLAGS,SRSINIT    Set initialization indicator\n         MVC   SRSPARM,SRSTPPRM    Set program parms               V120\n         CLI   SRSPARM,C' '        Are there any parms?            V121\n         BNH   NOPPARM             No, leave length zero           V121\n         LA    R15,SRSPARM+L'SRSPARM-1 Point at last char in parm  V121\nPPLOOP   DS    0H                                                  V121\n         CLI   0(R15),C' '         Blank char?                     V121\n         BH    PPEND               Yes, found end                  V121\n         BCTR  R15,0               Bump to next char               V121\n         B     PPLOOP              And check it out                V121\nPPEND    DS    0H                                                  V121\n         LA    R1,SRSPARM-1        Point at first char (less one)  V121\n         SR    R15,R1              Get length of parm              V121\n         STC   R15,SRSPARML        Set program parms length        V121\nNOPPARM  DS    0H                                                  V121\n         LA    R1,SRSDATA          Get address of SRSDATA block\n         L     R15,SRSPGMA         Get address of user program\n         BASSM R14,R15             Call user program\n         SRSAMODE 31,R=R1          Force AMODE31                   V111\n         LTR   R15,R15             RC=0 from user pgm ?\n         BZ    SETUPX              Yes, return to main routine\n         OI    STATUS,STATREJ      Set reject from user pgm\n         SLR   R15,R15             Set SETUP RC=0\n         B     SETUPX              Return to main routine\nSETUPX   DS    0H\n         LR    R5,R15              Save routine's RC\n         BAL   R9,AUTH             Set authorized mode\n         LR    R15,R5              Restore routine's RC\n         BR    R10                 Return to main routine\n         EJECT\n*=====================================================================*\n* Process sysout dataset.                                             *\n*  1) Build the SRS001I message text.                                 *\n*  2) Call the user-program with the \"new dataset\" indicator on.      *\n*  3) If the user program wants to process the dataset,               *\n*     then issue message SRS001I indicating datset has been selected  *\n*     else return with RC from program                                *\n*  4) Dynamically allocate the SYSOUT dataset.                        *\n*  5) Open sysout dataset.                                            *\n*  6) Read a record from the SYSOUT dataset.                          *\n*  7) Pass the record to the user program.                            *\n*  8) When EOF hit, call the user-program with the \"eof\" bit on       *\n*  9) Dynamically un-allocate SYSOUT dataset.                         *\n* 10) Return to caller.                                               *\n*=====================================================================*\nPROCESS  DS    0H\n         TM    STATUS,STATABND     In here for error cleanup ?\n         BO    CLSDATA             Yes, process end of dataset\n         NI    STATUS2,X'FF'-STA2IOER Reset I/O error flag         V120\n* Set the disp flags to keep.  If the dataset is successfully      V112\n* processed, we'll reset this to delete.                           V112\n         OI    SSS2DSP1,SSS2DKPE+SSS2RNPR  Keep the dataset, but don't +\n                                           return it to me again   V112\n         TM    SSS2RET1,SSS2DSF    First dataset in output group ?\n         BZ    NODSF               No, skip down\n         XC    DSID,DSID           Reset the dataset counter\n         BAL   R9,CKDDNAME         Perform DDNAME check            V120\nNODSF    DS    0H\n         LH    R15,DSID            Get dataset ID counter\n         LA    R15,1(R15)          Bump counter\n         STH   R15,DSID            Save updated count\n         MVC   SRSTLJBN,SSS2JOBR   Update last jobname selected\n         MVC   SRSTLJBI,SSS2JBIR   Update last jobid selected\n         TM    STATUS2,STA2DDNS    Select by DDNAME ?              V120\n         BZ    NOSELDD             No, don't check DDNAME          V120\n         SLR   R15,R15             Clear work reg                  V120\n         LA    R15,L'SRSTDDNM      Get length of ddname mask       V121\n         ST    R15,DOUBWORK        Save as fullword                V120\n         ASAXWC PATTERNSTR=SRSTDDNM, Set pattern address               +\n               PATTERNSTRLEN=DOUBWORK, and length                      +\n               STRING=SSS2DDND,     Set string address                 +\n               STRINGLEN==AL4(L'SSS2DDND),  and length                 +\n               ZEROORMORE==C'*',    Generic character                  +\n               ONECHAR==C'?',       Single wildcard character          +\n               DELIMITER==C' ',     End of data delimiter              +\n               WORKAREA=WORK256,    Work area for ASAXWC               +\n               MF=(E,XWCLIST,COMPLETE)  Test DDNAME match          V120\n         LTR   R14,R15             Save and test RC                V120\n         LA    R15,0               Set PROCESSX RC for poss exit   V120\n         BNZ   NODSKEEP            Exit if no DDNAME match         V120\n         OI    STATUS2,STA2DDNF    Set DDNAME found                V120\nNOSELDD  DS    0H                                                  V120\n* Build the SRS001I message text.\n         MVI   WTOBUFF,C' '                    INITIALIZE ...\n         MVC   WTOBUFF+1(L'WTOBUFF-1),WTOBUFF  ... WTO BUFFER\n         LA    R1,WTOBUFF+2        Point at first character of text\n         MVC   0(L'SRS001I,R1),SRS001I Move in message ID\n         LA    R1,L'SRS001I+1(R1)  Point character after msgid\n         MVC   0(L'SSS2JOBR,R1),SSS2JOBR    Move jobname to msg\n         SLR   R0,R0               Set function code for findblnk\n         BAL   R9,FINDBLNK         Find blank char\n         MVI   0(R1),C'('          Insert paren\n         MVC   1(L'SSS2JBIR,R1),SSS2JBIR    Move JOBID to msg\n         LA    R1,L'SSS2JBIR+1(R1) Point character after JOBID\n         MVC   0(4,R1),=C') Q='    Add next part\n         LA    R1,4(R1)            Update message pointer\n         MVC   0(1,R1),SSS2CLAR    Move in class of SYSOUT\n         MVC   1(3,R1),=C' D='     Add next part\n         LA    R1,4(R1)            Update message pointer\n         MVC   0(L'SSS2DESR,R1),SSS2DESR    Move dest to msg\n         SLR   R0,R0               Set function code for findblnk\n         BAL   R9,FINDBLNK         Find blank char\n         LA    R1,1(R1)            Add a blank after dest\n         MVC   0(7,R1),=C'O=?.?.?' Add next part\n         TM    SSS2RET1,SSS2GNVA   Is output group ID good ?\n         BNO   NOOUTGP             No, skip it\n         MVC   2(L'SSS2OGNM,R1),SSS2OGNM    Move output group ID to msg\nNOOUTGP  DS    0H\n         SLR   R0,R0               Set function code for findblnk\n         BAL   R9,FINDBLNK         Find blank char\n         LA    R1,1(R1)            Add a blank after outgroup\n         MVC   0(3,R1),=C'DS='     Add next part\n         LA    R1,3(R1)            Point at insertion point\n         SLR   R15,R15             Clear work reg\n         ICM   R15,B'0011',DSID    Get datset number\n         CVD   R15,DOUBWORK        Make it decimal\n         OI    DOUBWORK+7,X'0F'    Fix up sign\n         UNPK  DOUBWORK(5),DOUBWORK+5(3)\n         LA    R15,DOUBWORK-1      Point at 1st digit\nCKDSZERO DS    0H\n         LA    R15,1(R15)          Skip to next digit\n         CLI   0(R15),C'0'         Look for leading zero\n         BE    CKDSZERO            If found, skip to next digit\n         LA    R14,DOUBWORK+4      Point at last digit\n         SR    R14,R15             Get length of DS number\n         EX    R14,MVCDSID         Move DS number to message\n         LA    R1,1(R14,R1)        Point past DS number            V120\n         MVI   0(R1),C'/'          Add a slash                     V120\n         MVC   1(8,R1),SSS2DDND    Move DDNAME of data set         V120\n         LA    R1,2(R1)            Reset index                     V120\n         BAL   R9,FINDBLNK         ... and find next blank char    V120\n         MVC   1(6,R1),=C'on WTR'  Add next part                   V120\n         MVC   7(2,R1),SRSTWRID    Move writer ID of this SRSTASK  V120\n         LA    R1,9(R1)            Point at next slot              V120\n         MVI   1(R1),C'('          Insert paren\n         LA    R1,2(R1)            Update message pointer\n         MVI   0(R1),C'?'          Assume unknown line count\n         TM    SSS2RET1,SSS2DSCL   Is line count accurate ?\n         BZ    LINEUNKN            No, don't use it\n         MVC   EDBUF,EDPAT         Move edit pattern to buffer\n         L     R15,SSS2LNCT        Get dataset line count\n         CVD   R15,DOUBWORK        Make it decimal\n         ED    EDBUF,DOUBWORK+3    Edit record count\n         LR    R3,R1               Save message pointer\n         LA    R1,EDBUF+L'EDBUF-1  Point at last char in record cnt\n         LR    R2,R1               Save pointer\n         LA    R0,4                Set backward scan direction\n         BAL   R9,FINDBLNK         Find blank char\n         LA    R1,1(R1)            Point at first digit\n         SR    R2,R1               Get length of cnt (minus one)\n         EX    R2,MOVECNT          Move record count to message\n         LR    R1,R3               Restore message pointer\nLINEUNKN DS    0H\n         SLR   R0,R0               Set foward scan direction\n         BAL   R9,FINDBLNK         Find blank char\n         MVC   1(5,R1),=C'RECS)'   Move in end of message\n         LA    R1,6(R1)            Point at end of message (plus 1)\n         LA    R15,WTOBUFF+2       Point at beginning of msg\n         SR    R1,R15              Get total msg length\n         STH   R1,WTOBUFF          Save length\n         MVC   WTOPARMB,WTOPARM    Move WTO parm to buffer\n         WTO   TEXT=WTOBUFF,MF=(E,WTOPARMB) Indicate dataset sel'd\n*==================================================================*\n* Call the user-program with the \"new dataset\" indicator on.       *\n*==================================================================*\n         BAL   R9,UNAUTH           Establish unauthorized env\n         LA    R1,SSS2             Get address of SAPI SSOB ext'n\n         ST    R1,SRSSSOB          Save for user program\n         XC    SRSREC,SRSREC       Clear record pointer...\n         XC    SRSRECL,SRSRECL     ... and length\n         MVI   SRSFLAGS,SRSFIRST   Set new dataset indicator\n         LA    R1,SRSDATA          Get address of SRSDATA block\n         L     R15,SRSPGMA         Get address of user program\n         BASSM R14,R15             Call user program\n         SRSAMODE 31,R=R1          Force AMODE31                   V111\n         LR    R5,R15              Save return code\n         BAL   R9,AUTH             Establish authorized env\n         LTR   R5,R5               Does user want this dataset ?\n         BZ    ALLOCDS             Yes, go allocate it\n         OI    STATUS,STATREJ      Set reject from user pgm\n         B     PROCESSX            End processing this dataset\n* Dynamically allocate the SYSOUT dataset.\nALLOCDS  DS    0H\n         STCK  SRSTTIME            Save time dataset selected\n         NI    SRSFLAGS,X'FF'-SRSFIRST Turn off new dataset indicator\n         MVI   S99VERB,S99VRBAL    Set allocate verb\n         MVC   ALLOCDSN,SSS2DSN    Set DSN to allocate\n         MVC   ALTXBTOK,SSS2BTOK   Set the allocation token from JES\n         OI    ALTXBTOK,S99TUPLN   Set last text ptr indicator\n         LA    R15,ALTXTBK         Get address of text pointer list\n         ST    R15,S99TXTPP        Point header at alloc block\n         LA    R1,SVC99P           Point at svc99 parmeter list\n         SVC   99                  Allocate sysout dataset\n         LR    R5,R15              Save allocation RC\n         BAL   R9,UNAUTH           Establish unauthorized env\n         LTR   R5,R5               Was allocation successfull ?\n         BNZ   ALOCFAIL            No, issue diagnostic msg\nALLOCOK  DS    0H\n* Open sysout dataset.\n         MVC   DOUBWORK(OPNPARML),OPNPARM\n         OI    STATUS,STATSAPO     Flag spool dataset open\n         OPEN  (SYSSAPI),MF=(E,DOUBWORK)  Open dataset\n         LA    R3,SYSSAPI          GET SYSSAPI DCB ADDRESS\n         LH    R3,DCBLRECL-IHADCB(,R3)  GET SYSSAPI LRECL\n         STH   R3,SRSRECL          Save record length\n         LA    R4,SYNADMSG         SYNADAF message buffer address  V112\n         MVI   SRSFLAGS,SRSDREC    Assume no separators            V121\n         CLI   SRSTSEPO,SRSTSEPD   DATASET separators in effect?   V121\n         BE    DOSEP               Yes, write a separator rec      V121\n         CLI   SRSTSEPO,SRSTSEPJ   Job separators in effect?       V121\n         BNE   NOJBSEP             No, skip job sep check          V121\n         CLC   SSS2JBIR,SRSSEPJI   Sep already done for this job?  V121\n         BE    DATALOOP            Yes, none needed                V121\n         B     DOSEP               No, produce separator           V121\nNOJBSEP  DS    0H                                                  V121\n         CLI   SRSTSEPO,SRSTSEPG   OUTGRP separators in effect?    V121\n         BNE   DATALOOP            No, skip OG sep check           V121\n         TM    SSS2RET1,SSS2DSF    First dataset in output group ? V121\n         BZ    DATALOOP            Yes, none needed                V121\n* Produce separator record                                         V121\nDOSEP    DS    0H                                                  V121\n         MVC   SRSSEPJI,SSS2JBIR   Set jobname for sep produced    V121\n         LH    R0,SRSRECL          Get data record length          V121\n         CH    R0,=H'130'          Lower than minimum?             V121\n         BNL   GETSEPST            No, use DS LRECL                V121\n         LH    R0,=H'130'          Use minimum length              V121\nGETSEPST DS    0H                                                  V121\n         STH   R0,SRSSEPL          Save sep buffer length          V121\n         GETMAIN R,LV=(0)          Get storage for separator       V121\n         ST    R1,SRSSEPA          Save sep buffer addr            V121\n         LR    R2,R1               Get address of buffer           V121\n         LH    R3,SRSSEPL          Get length of buffer            V121\n         L     R15,=A(X'40000000')  Set blank pad & zero length    V121\n         MVCL  R2,R14              Set buffer to blanks            V121\n         MVC   0(L'SRSTSEPI,R1),SRSTSEPI  Set sep record ID        V121\n         SLR   R0,R0               Set function code for findblnk  V121\n         BAL   R9,FINDBLNK         Find blank char                 V121\n         MVC   0(5,R1),=C' JOB='   Set data tag                    V121\n         LA    R1,5(R1)            Point past tag                  V121\n         MVC   0(L'SSS2JOBR,R1),SSS2JOBR  Move in jobname          V121\n         BAL   R9,FINDBLNK         Find blank char                 V121\n         MVC   0(7,R1),=C' JOBID='  Set data tag                   V121\n         MVC   7(L'SSS2JBIR,R1),SSS2JBIR  Move in jobid            V121\n         CLI   SRSTSEPO,SRSTSEPJ   Job separators in effect?       V121\n         BE    DATASEP             Yes, end of job separato        V121\n         LA    R1,16(R1)           Point at spot for next element  V121\n         MVC   0(6,R1),=C'CLASS='  Set data tag                    V121\n         MVC   6(L'SSS2CLAR,R1),SSS2CLAR  Move in SYSOUT class     V121\n         LA    R1,7+L'SSS2CLAR(R1) Point at spot for next element  V121\n         MVC   0(5,R1),=C'DEST='   Set data tag                    V121\n         MVC   5(L'SSS2DESR,R1),SSS2DESR  Move in DESTID           V121\n         BAL   R9,FINDBLNK         Find blank char                 V121\n         LA    R1,1(R1)            Point at spot for next element  V121\n         MVC   0(4,R1),=C'WTR='    Set data tag                    V121\n         MVC   4(L'SSS2PGMR,R1),SSS2PGMR  Move in WRITER name      V121\n         BAL   R9,FINDBLNK         Find blank char                 V121\n         LA    R1,1(R1)            Point at spot for next element  V121\n         MVC   0(5,R1),=C'FORM='   Set data tag                    V121\n         MVC   5(L'SSS2FORR,R1),SSS2FORR  Move in FORMS ID         V121\n         BAL   R9,FINDBLNK         Find blank char                 V121\n         LA    R1,1(R1)            Point at spot for next element  V121\n         MVC   0(7,R1),=C'OUTGRP=' Set data tag                    V121\n         MVC   7(L'SSS2OGNM,R1),SSS2OGNM  Move in output grp name  V121\n         CLI   SRSTSEPO,SRSTSEPG   OUTGRP separators in effect?    V121\n         BE    DATASEP             Yes, end of OUTGRP separator    V121\n         BAL   R9,FINDBLNK         Find blank char                 V121\n         LA    R1,1(R1)            Point at spot for next element  V121\n         MVC   0(3,R1),=C'DD='     Set data tag                    V121\n         MVC   3(L'SSS2DDND,R1),SSS2DDND  Move in DDNAME           V121\nDATASEP  DS    0H                                                  V121\n         MVI   SRSFLAGS,SRSDREC+SRSDSEP  Set sep call flag         V121\n         L     R1,SRSSEPA          Get addr of separator record    V121\nDATALOOP DS    0H\n* Read a record from the SYSOUT dataset.\n         TM    SRSFLAGS,SRSDSEP    Processing separator record?    V121\n         BO    DATACALL            Yes, skip SYSOUT read           V121\n         SRSAMODE 24               Set AMODE24                     V111\n         GET   SYSSAPI             Read the next data record\n         SRSAMODE 31               Set AMODE31                     V111\n* Pass the record to the user program.\nDATACALL DS    0H                                                  V121\n         ST    R1,SRSREC           Save buffer address\n         LA    R1,SRSDATA          Get address of SRSDATA block\n         L     R15,SRSPGMA         Get address of user program\n         BASSM R14,R15             Call user program\n         SRSAMODE 31,R=R1          Force AMODE31                   V111\n         MVI   SRSFLAGS,SRSDREC    Turn off sep indicator          V121\n         LR    R5,R15              Save return code\n         LTR   R5,R5               RC=0 ?\n         BZ    DATALOOP            Yes, read next record\n         OI    STATUS,STATREJ      Set reject from user pgm\n         B     CLSDATA             Close and deallocate data set\n         SPACE 5                                                   V112\n*=================================================================*V112\n* SYNAD routine for the SYSSAPI DCB.                              *V112\n*                                                                 *V112\n* The following routine gets control if QSAM GET encounters an I/O*V112\n* error reading the SYSSAPI JES spool dataset.  This most often   *V112\n* happens following a system crash when JES did not close spool   *V112\n* datasets.  The routine does the following:                      *V112\n*                                                                 *V112\n* 1) Invoke SYNADAF to create a formatted I/O error mesage.       *V112\n* 2) Save the message in the work area.                           *V112\n* 3) Free the SYNADAF work area and re-establish our R13.         *V112\n* 4) Write SRS050E & 51E to document the I/O error.               *V112\n* 5) Continue processing as if EOF was hit.                       *V112\n*                                                                 *V112\n* Note that when the routine is called, R4 must point to the      *V112\n* buffer used to hold the I/O error message.                      *V112\n*=================================================================*V112\nSRSSYNAD DS    0H                                                  V112\n         SYNADAF ACSMETH=QSAM      Create error message            V112\n         MVC   0(L'SYNADMSG,R4),50(R1) Save formatted message      V112\n         SYNADRLS                  Free SYNADAF acquired storage   V112\n         SRSAMODE 31,R=R1          Reset AMODE31                   V112\n         OI    STATUS2,STA2IOER    Flag I/O error                  V120\n         BAL   R9,AUTH             Set for WTO's                   V112\n* Write message SRS050E                                            V112\n         MVC   WTOTEXT(L'SRS050E),SRS050E Move in message ID       V112\n         MVC   WTOTEXT+L'SRS050E(L'SYNADMSG),SYNADMSG              V112\n         LA    R15,L'SRS050E+L'SYNADMSG  Get length of msg         V112\n         STH   R15,WTOBUFF         Save length                     V112\n         MVC   WTOPARMB,WTOPARM    Move WTO parm to buffer         V112\n         WTO   TEXT=WTOBUFF,MF=(E,WTOPARMB) Write SYNADAF err msg  V112\n* Write message SRS051E                                            V112\n         MVC   WTOTEXT(L'SRS051E),SRS051E Move in message ID       V112\n         MVC   WTOTEXT+L'SRS051E(L'SSS2DSN),SSS2DSN                V112\n         LA    R15,L'SRS051E+L'SSS2DSN   Get length of msg         V112\n         STH   R15,WTOBUFF         Save length                     V112\n         MVC   WTOPARMB,WTOPARM    Move WTO parm to buffer         V112\n         WTO   TEXT=WTOBUFF,MF=(E,WTOPARMB) Write SYNADAF err msg  V112\n         BAL   R9,UNAUTH           Go back to key8, problem        V112\n         SPACE 5                                                   V112\nEOFDATA  DS    0H\n* EOF hit, call the user-program with the \"eof\" bit on\n         MVI   SRSFLAGS,SRSEOF     Set new end-of-file indicator\n         LA    R1,SRSDATA          Get address of SRSDATA block\n         L     R15,SRSPGMA         Get address of user program\n         BASSM R14,R15             Call user program\n         SRSAMODE 31,R=R1          Force AMODE31                   V111\n         LTR   R15,R15             RC=0 ?\n         BZ    CLSDATA             Yes, close and deallocate\n         OI    STATUS,STATREJ      Set reject from user pgm\nCLSDATA  DS    0H\n         TM    STATUS,STATSAPO     Is spool dataset open ?\n         BZ    PROCESSX            No, don't close/dealloc\n         MVC   DOUBWORK(CLSPARML),CLSPARM\n         NI    STATUS,X'FF'-STATSAPO     Flag spool dataset closed\n         CLOSE (SYSSAPI),MF=(E,DOUBWORK) Close spool dataset\n         FREEPOOL SYSSAPI          Release QSAM buffers         @A11103\n         ICM   R1,15,SRSSEPA       Did we get a buffer for a sep?  V121\n         BZ    NOFREESB            No, nothing to free             V121\n         LH    R0,SRSSEPL          Get length of buffer            V121\n         FREEMAIN R,A=(1),LV=(0)   Free separator buffer           V121\n         XC    SRSSEPA,SRSSEPA     Clear buffer pointer            V121\nNOFREESB DS    0H                                                  V121\n* Dynamically un-allocate SYSOUT dataset\n         BAL   R9,AUTH             Establish authorized env\n         MVI   S99VERB,S99VRBUN    Set allocate verb\n         LA    R15,UNTXTBK         Addr of unallocation text block\n         ST    R15,S99TXTPP        Point header at alloc block\n         LA    R1,SVC99P           Point at SVC99 parameter list\n         SVC   99                  Unallocate sysout dataset\n         LTR   R5,R15              Was unallocation successfull ?\n         BNZ   ALOCFAIL            No, handle error                V112\n         TM    STATUS,STATREJ+STATABND  Rejected or abend?      @A11204\n         BNZ   PROCESSX            Yes, don't count or delete   @A11204\n         TM    STATUS2,STA2IOER    I/O error reading dataset ?     V120\n         BO    PROCESSX            Yes, don't count or delete it   V112\n         TM    SRSTFLAG,SRSTKEEP   KEEP despooled datasets ?       V112\n         BO    NODSKEEP            Yes, leave default (KEEP)       V112\n         NI    SSS2DSP1,X'FF'-SSS2DKPE Delete the dataset          V112\nNODSKEEP DS    0H                                                  V112\n         TM    SSS2RET1,SSS2DSL    Last dataset in output group ?  V112\n         BZ    PROCESSX            No, don't count it              V112\n         TM    STATUS2,STA2DDNS+STA2DDNF  DDNAME in effect & found?V120\n         BM    PROCESSX            Yes & no, don't count           V120\n         L     R1,SRSTCNT          Get dataset select count        V112\n         LA    R1,1(R1)            Bump counter                    V112\n         ST    R1,SRSTCNT          Save updated count              V112\n         B     PROCESSX            Finish up                       V112\nALOCFAIL DS    0H\n         BAL   R9,AUTH             Establish authorized env\n         MVI   WTOBUFF,C' '                    INITIALIZE ...\n         MVC   WTOBUFF+1(L'WTOBUFF-1),WTOBUFF  ... WTO BUFFER\n         LA    R1,WTOBUFF+2        Point at first character of text\n         MVC   0(L'SRS101E,R1),SRS101E Move in message ID\n         LA    R1,L'SRS101E+1(R1)  Point character after msgid\n         MVC   0(4,R1),=C'DSN='    Move in next part\n         MVC   4(L'ALLOCDSN,R1),ALLOCDSN Move in failed DSN\n         SLR   R0,R0               Set function code for findblnk\n         BAL   R9,FINDBLNK         Find blank char\n         LA    R15,WTOBUFF+2       Point at beginning of msg\n         SR    R1,R15              Get total msg length\n         STH   R1,WTOBUFF          Save length\n         MVC   WTOPARMB,WTOPARM    Move WTO parm to buffer\n         OI    WTOPARMB+X'1C',X'80'   Set DESC=1\n         WTO   TEXT=WTOBUFF,MF=(E,WTOPARMB) Write dataset name\n         LA    R1,WTOBUFF+L'SRS101E+3  Point at first char\n         MVC   0(L'SRS101EA,R1),SRS101EA  Move in next part\n         CLI   S99VERB,S99VRBAL    Was it allocation ?\n         BE    ALFLMSOK            Yes, leave alone\n         MVC   8(10,R1),=C'unallocatn'  make unallocation\nALFLMSOK DS    0H\n         LR    R2,R1               Copy pointer\n         LR    R1,R5               Copy return code\n         CALL  SRSPRHEX                                            V111\n         STCM  R0,15,30(R2)        Move RC to message\n         STCM  R1,15,34(R2)        Move RC to message\n         L     R1,S99ERROR         Get error & info codes\n         CALL  SRSPRHEX                                            V111\n         STCM  R0,15,43(R2)        Move error code to message\n         STCM  R1,15,52(R2)        Move info code to message\n         LA    R1,L'SRS101EA(R2)   Point at end of message\n         LA    R15,WTOBUFF+2       Point at beginning of msg\n         SR    R1,R15              Get total msg length\n         STH   R1,WTOBUFF          Save length\n         MVC   WTOPARMB,WTOPARM    Move WTO parm to buffer\n         OI    WTOPARMB+X'1C',X'80'   Set DESC=1\n         WTO   TEXT=WTOBUFF,MF=(E,WTOPARMB) Indicate alloc failed\n         OI    SSS2DSP1,SSS2DKPE   Keep last dataset selected\n         LA    R15,16              Set bad RC\nPROCESSX DS    0H\n         BR    R10                 RETURN TO MAINLINE\nMVCDSID  MVC   0(*-*,R1),0(R15)\nMOVECNT  MVC   0(*-*,R3),0(R1)\n         EJECT\n*=================================================================*V120\n* This routine checks to see if the requested DDNAME was found    *V120\n* for each job (*NOT JOE*) processed.  It is called:              *V120\n*                                                                 *V120\n* 1) Each time the first data set of a JOE is processed.          *V120\n* 2) When SRS termination is in process.                          *V120\n*                                                                 *V120\n* If we didn't select any data sets in the previous job processed *V120\n* and we are in DDNAME selection mode, then issue SRS002I to      *V120\n* document that we selected the job, but didn't find a matching   *V120\n* DDNAME.                                                         *V120\n*=================================================================*V120\nCKDDNAME DS    0H                                                  V120\n         TM    STATUS2,STA2DDNS    Select by DDNAME ?              V120\n         BZ    CKDDNAMX            No, don't do check              V120\n         CLI   SRSTLJBN,C' '       First job selected ?            V120\n         BNH   CKDDNAMX            No, don't do check              V120\n         CLC   SRSTLJBI,SSS2JBIR   Processing same job (new OG) ?  V120\n         BE    CKDDNAMX            Yes, don't do check             V120\n         TM    STATUS2,STA2DDNF    Did we find DDNAME for job ?    V120\n         BO    DDNMFND             Yes, cool..no msg needed        V120\n         LR    R15,R9              Save ret addr (used by FINDBLNK)V120\n* Start building SRS002I message                                   V120\n         MVI   WTOBUFF,C' '                    Initialize          V120\n         MVC   WTOBUFF+1(L'WTOBUFF-1),WTOBUFF  ... WTO buffer      V120\n         LA    R1,WTOBUFF+2        Point at first character        V120\n         MVC   0(L'SRS002I,R1),SRS002I Move in message ID          V120\n         LA    R1,L'SRS002I+1(R1)  Point character after msgid     V120\n         MVC   0(L'SRSTLJBN,R1),SRSTLJBN    Move jobname to msg    V120\n         SLR   R0,R0               Set function code for findblnk  V120\n         BAL   R9,FINDBLNK         Find blank char                 V120\n         MVI   0(R1),C'('          Insert paren                    V120\n         MVC   1(L'SRSTLJBI,R1),SRSTLJBI    Move JOBID to msg      V120\n         LA    R1,L'SRSTLJBI+1(R1) Point character after JOBID     V120\n         MVC   0(27,R1),=C') does not contain DDNAME='             V120\n         LA    R1,26(R1)           Update message pointer          V120\n         MVC   0(L'SRSTDDNM,R1),SRSTDDNM  Move in DDNAME n.f.      V120\n         LA    R1,9(R1)            Point at end of msg (plus 1)    V120\n* Done building SRS002I message                                    V120\n         LR    R9,R15              Restore return address          V120\n         LA    R15,WTOBUFF+2       Point at beginning of msg       V120\n         SR    R1,R15              Get total msg length            V120\n         STH   R1,WTOBUFF          Save length                     V120\n         MVC   WTOPARMB,WTOPARM    Move WTO parm to buffer         V120\n         WTO   TEXT=WTOBUFF,MF=(E,WTOPARMB)                        V120\nDDNMFND  DS    0H                                                  V120\n         NI    STATUS2,X'FF'-STA2DDNF  Reset DDNAME found          V120\nCKDDNAMX DS    0H                                                  V120\n         BR    R9                                                  V120\n         EJECT                                                     V120\n*==================================================================*\n* Un-authorization routine.                                        *\n* This routine:                                                    *\n*   1) Sets PSW key to 8                                           *\n*   2) Sets mode to problem state                                  *\n*   3) Posts SRSAUTH to become APF un-authorized                   *\n*   4) Returns to the caller via R9                                *\n*==================================================================*\nUNAUTH   DS    0H\n         MODESET MODE=SUP          Set supervisor state\n         MODESET KEYADDR=PSWKEY8,WORKREG=2  Set PSW key 8\n         MODESET MODE=PROB         Set problem state\nAUTHCHEK DS    0H\n         TM    SRSAAECB,ECBWAIT    Is Auth task up ?\n         BNO   AUTHCHEK            No, wait for it\n         MVI   SRSAREQ,SRSAUNAU    Set un-authorization request\n         POST  SRSAAECB            Get Un-authorized\n         WAIT  ECB=SRSARECB        Wait for completion\n         NI    SRSARECB,X'FF'-ECBPOST  Turn off post bit\n         BR    R9\n         EJECT\n*==================================================================*\n* Authorization routine.                                           *\n* This routine:                                                    *\n*   1) Posts SRSAUTH to become APF authorized                      *\n*   2) Sets mode to supervisor state                               *\n*   3) Sets PSW key to zero                                        *\n*   4) Returns to the caller via R9                                *\n*==================================================================*\nAUTH   DS    0H\n         MVI   SRSAREQ,SRSAAUTH    Set authorization request\n         POST  SRSAAECB            Get APF Authorized\n         WAIT  ECB=SRSARECB        Wait for completion\n         NI    SRSARECB,X'FF'-ECBPOST  Turn off post bit\n         MODESET MODE=SUP          Set supervisor state\n         MODESET EXTKEY=ZERO       Set PSW key 0\n         BR    R9\n         EJECT\n*=====================================================================*\n* Find the next blank character                                       *\n*  At input:                                                          *\n*    R0 - contains a code indicating the scanning direction           *\n*         0 - foward                                                  *\n*         4 - backward                                                *\n*    R1 - points to the character to start searching                  *\n*    R9 - contains the return address                                 *\n*  At output:                                                         *\n*    R1 - points to the next blank character                          *\n*=====================================================================*\nFINDBLNK DS    0H\n         LTR   R0,R0               Foward search ?\n         BZ    GETFWD              Yes, continue\nGETBACK  DS    0H\n         CLI   0(R1),C' '          Blank found ?\n         BER   R9                  Yes, return\n         BCTR  R1,0                Point at previous character\n         B     GETBACK             Check next char\n*\nGETFWD   DS    0H\n         CLI   0(R1),C' '          Blank found ?\n         BER   R9                  Yes, return\n         LA    R1,1(R1)            Point at next character\n         B     GETFWD              Check next char\n         EJECT\nTASKRETR DS    0H\n*=====================================================================*\n* This ESTAE routine loads this address as the retry address.         *\n* This routine issues a message to indicate the abend code, then      *\n* branches to shutdown the SAPI interface and terminate.              *\n*=====================================================================*\n         USING SDWA,R1\n         L     R13,SDWAPARM        Restore work area address\n         LM    R2,R12,ESTAREGS     Restore R2-R12\n         LR    R4,R1               Copy SDWA address\n         DROP  R1\n         USING SDWA,R4\n         OI    STATUS,STATABND     Flag abend\n*V112    OI    SSS2DSP1,SSS2DKPE+SSS2RHLD                          V112\n         MVC   WTOBUFF+2(L'SRS120E),SRS120E\n         LA    R15,L'SRS120E       Get length of message\n         STH   R15,WTOBUFF         Save length in WTO\n         L     R1,SDWAABCC         Get abend code\n         CALL  SRSPRHEX            Make it printable               V111\n         STCM  R0,B'0011',WTOBUFF+30 Move 1st & 2nd chars of system cde\n         STCM  R1,B'1000',WTOBUFF+32 Move 3rd char of system code\n         TM    SDWAABCC,SDWAREQ    Was it a system abend ?\n         BO    ISSABNDM            Yes, issue message\n         MVI   WTOBUFF+29,C'U'     Set user abend indicator\n         STCM  R1,B'0111',WTOBUFF+30 Move user code\n         DROP  R4\nISSABNDM DS    0H\n         MVC   WTOPARMB,WTOPARM    Move WTO parm to buffer\n         WTO   TEXT=WTOBUFF,DESC=2,MF=(E,WTOPARMB) Write error msg\n         BAL   R9,AUTH             Establish authorized env\n         MODESET KEYADDR=PSWKEY8,WORKREG=2  Set PSW key 8\n         BAL   R10,PROCESS         Close and dealloc spool dataset\n         LA    R15,32              Set return code\n         ST    R15,SRSTRC          Save in block\n         CLI   SRSFLAGS,SRSTERM    Abend during termination?    @A11205\n         BE    NOTCALL             Yes, skip term call again    @A11205\n         B     SHUTDOWN            Shutdown the SAPI interface\n         EJECT\nSTAEXIT  DS    0H\n*=====================================================================*\n* This routine gets control in the unfortunate event that             *\n* SRSTASK abends. If an SDWA is present, the routine saves loads the  *\n* parameter address from ESTAE (REG13) and retrys to the              *\n* TASKRETR routine.                                                   *\n*=====================================================================*\n         PUSH  USING               Save prior USINGs\n         DROP  ,                   Can prior USINGs\n         USING STAEXIT,R15         Temporary base\n         CH    R0,=H'12'           SDWA provided ?\n         BE    NOSDWA              No, branch\n         DROP  R15\n         SAVE  (14,12)             Save registers\n         LR    R12,R15             Set base register\n         USING STAEXIT,R12         Exit base register\n         LR    R4,R1               Save SDWA address\n         USING SDWA,R4\n**       WTO   'SRS110E SRSTASK ESTAE given control',DESC=1\n         L     R10,SDWAPARM        Get work area address\n         USING SRSTWORK,R10\n         L     R2,TASKRETA         Load retry routine address\n         LR    R1,R4               Restore SDWA address\n         TM    STATUS,STATABND     Been here before?            @A11205\n         BO    SDTERM              Yes, avoid recursive abends  @A11205\n         DROP  R4,R10\n         SETRP REGS=(14,12),RC=4,RETADDR=(2)  Return to retry routine\nSDTERM   DS    0H                                               @A11205\n         SETRP REGS=(14,12),RC=0   Continue termination         @A11205\nNOSDWA   DS    0H\n         SLR   R15,R15             Set RC = 0\n         BR    R14                 Continue termination\n         SPACE 2\n         POP   USING               Restore prior USINGs\n         EJECT\n* Static constants and areas\nWTRSSOB  DS    0F\nWTSSOBID DC    CL4'SSOB'\nWTSSOBSZ DC    AL2(SSOBHSIZ)\nWTSSOBFN DC    AL2(SSOBSOU2)\nWTRSOSIZ EQU   *-WTRSSOB\nPSWKEY8  DC    X'80'\nSAPIWAIT DC    0D,C'00010000'                                   @A11203\n* Message text\nSRS001I  DC    C'SRS001I'\nSRS002I  DC    C'SRS002I'                                          V120\nSRS003I  DC    C'SRS003I WTRxx Initialization complete'\nSRS010I  DC    C'SRS010I WTRxx SHUTDOWN requested by xxxxxxxx'\nSRS011I  DC    C'SRS011I WTRxx SHUTDOWN in progress'\nSRS012I  DC    C'SRS012I WTRxx SAPI interface deactivated'         V112\nSRS013I  DC    C'SRS013I WTRxx SHUTDOWN complete'\nSRS020I  DC    C'SRS020I No SYSOUT datasets processed'             V112\nSRS021I  DC    C'SRS021I SYSOUT retrieval limit reached'\nSRS022I  DC    C'SRS022I No more SYSOUT datasets to select'\nSRS025I  DC    C'SRS025I SAPI Services unavailable.  Waiting...'       +\n                                                                @A11203\nSRS050E  DC    C'SRS050E '                                         V112\nSRS051E  DC    C'SRS051E I/O error reading spool dataset '         V112\nSRS100E  DC    C'SRS100E SAPI SSI Call Failed - SSN=nnnn SSI RC=nn SSOB+\n                RETN=nn RESN=nn'                                @A11201\nSRS101E  DC    C'SRS101E'\nSRS101EA DC    C'Dynamic allocation failed, RC=xxxxxxxx ERR=xxxx INF=xx+\n               xx'\nSRS110E  DC    C'SRS110E Catastrophic error - WTRxx terminated'\nSRS120E  DC    C'SRS120E Subtask abend code=Snnn'\n*===============================================================@A11201\n* Table of SSI RC descriptions                                  @A11201\n*===============================================================@A11201\nSSIMSG   DS    0F                                               @A11201\n         DC    A(SSIRC4)                                        @A11201\n         DC    A(SSIRC8)                                        @A11201\n         DC    A(SSIRC12)                                       @A11201\n         DC    A(SSIRC16)                                       @A11201\n         DC    A(SSIRC20)                                       @A11201\n         DC    A(SSIRC24)                                       @A11201\nHISSIRC  EQU   *-SSIMSG                                         @A11201\nSSIRC4   DC    AL1(L'SSIRC4T)                                   @A11201\nSSIRC4T  DC    C'Subsystem does not support SAPI'                  V121\nSSIRC8   DC    AL1(L'SSIRC8T)                                   @A11201\nSSIRC8T  DC    C'Subsystem exists, but is not active'           @A11201\nSSIRC12  DC    AL1(L'SSIRC12T)                                  @A11201\nSSIRC12T DC    C'Subsystem does not exist'                      @A11201\nSSIRC16  DC    AL1(L'SSIRC16T)                                  @A11201\nSSIRC16T DC    C'Function not completed-disastrous error'       @A11201\nSSIRC20  DC    AL1(L'SSIRC20T)                                  @A11201\nSSIRC20T DC    C'Logic error - Notify SRS support'              @A11201\nSSIRC24  DC    AL1(L'SSIRC24T)                                  @A11201\nSSIRC24T DC    C'SSI not initialized'                           @A11201\n*===============================================================@A11201\n* Table of SSOBRETN RC descriptions                             @A11201\n*===============================================================@A11201\nSSOMSG   DS    0F                                               @A11201\n         DC    A(0)          RC=4 not possible                  @A11201\n         DC    A(SSORC8)                                        @A11201\n         DC    A(SSORC12)                                       @A11201\n         DC    A(SSORC16)                                       @A11201\n         DC    A(SSORC20)                                       @A11201\n         DC    A(SSORC24)                                       @A11201\n         DC    A(SSORC28)                                       @A11201\n         DC    A(SSORC32)                                       @A11201\n         DC    A(SSORC36)                                       @A11201\n         DC    A(SSORC40)                                       @A11201\n         DC    A(SSORC44)                                       @A11201\nHISSORC  EQU   *-SSOMSG                                         @A11201\nSSORC8   DC    AL1(L'SSORC8T)                                   @A11201\nSSORC8T  DC    C'Invalid search arguments'                      @A11201\nSSORC12  DC    AL1(L'SSORC12T)                                  @A11201\nSSORC12T DC    C'Unable to process now'                         @A11201\nSSORC16  DC    AL1(L'SSORC16T)                                  @A11201\nSSORC16T DC    C'Duplicate jobnames'                            @A11201\nSSORC20  DC    AL1(L'SSORC20T)                                  @A11201\nSSORC20T DC    C'Invalid destination specified'                 @A11201\nSSORC24  DC    AL1(L'SSORC24T)                                  @A11201\nSSORC24T DC    C'Unknown error'                                 @A11201\nSSORC28  DC    AL1(L'SSORC28T)                                  @A11201\nSSORC28T DC    C'Token map failed'                              @A11201\nSSORC32  DC    AL1(L'SSORC32T)                                  @A11201\nSSORC32T DC    C'Logic error - check SSOB RESN code'            @A11201\nSSORC36  DC    AL1(L'SSORC36T)                                  @A11201\nSSORC36T DC    C'Invalid SYSOUT class specified'                @A11201\nSSORC40  DC    AL1(L'SSORC40T)                                  @A11201\nSSORC40T DC    C'Disposition settings incorrect'                @A11201\nSSORC44  DC    AL1(L'SSORC44T)                                  @A11201\nSSORC44T DC    C'Disposition for data set group not uniform'    @A11201\n*\nEDPAT    DC    X'402020206B2020206B202120'  999,999,999\n         DC    C' '\n* DYNAMIC UNALLOCATION TEXT BLOCK\nUNTXTBK  DS    0F\n         DC    XL1'80',AL3(UNTXTU1)\nUNTXTU1  DC    AL2(DALDDNAM)   DDNAME: SYSSAPI\n         DC    AL2(1)\n         DC    AL2(L'UNDDN)\nUNDDN    DC    C'SYSSAPI'\nUNTXTBKL EQU   *-UNTXTBK\n*\nSYSSRSD  DCB   DDNAME=SYSSAPI,DSORG=PS,MACRF=(GL),EODAD=EOFDATA,       +\n               SYNAD=SRSSYNAD                                      V112\nSYSSRSDL EQU   *-SYSSRSD\n*\nESTAPARM ESTAE TERM=YES,PARAM=0,MF=L                               V120\nESTAPRML EQU   *-ESTAPARM\n*\nOPNPARM  OPEN  0,MF=L\nOPNPARML EQU   *-OPNPARM\n*\nCLSPARM  CLOSE 0,MF=L\nCLSPARML EQU   *-CLSPARM\n*\nWTOPARM  WTO   TEXT=(0),ROUTCDE=11,MF=L                            V120\nWTOPARML EQU   *-WTOPARM\n*\nATTPARM  ATTACH SF=L\nATTPARML EQU   *-ATTPARM\n*\nSRSTWORK DSECT\nSAVE     DS    18F                     Save area\nDOUBWORK DS    D                       Doubleword work area\nESTAREGS DS    11F                     GPRs 2-12 for recovery rtn use\nTASKRETA DS    F                       Address of retry routine\nSRSPGMA  DS    A                       Address of user program\nSYSSAPI  DS    CL(SYSSRSDL)            SYSSAPI DCB\nWORKSSOB DS    F\nECBSAPI  DS    F                  ECB SAPI will post when work is ready\nECBLIST  DS    0F\nECBCOMM  DS    F\nECBSSOB  DS    F\nAUTHTCB  DS    F\nSSIRC    DS    F                                               .....\nSRSSEPA  DS    F                       Addr of buffer for sep rec  V121\nSRSSEPJI DS    CL8                     JOBID of last sep produced  V121\nSRSSEPL  DS    H                       Length of SRSSEPA           V121\nDSID     DS    H                       Count of dataset per-JOE\nSYNADMSG DS    CL(128-50)         Message returned by SYNADAF      V112\n*\n         DS    0F\nWTOBUFF  DS    CL100\nWTOTEXT  EQU   WTOBUFF+2                                           V112\n         DS    0F\nWTOPARMB DS    CL(WTOPARML)\n*\nEDBUF    DS    CL(L'EDPAT)\n*\nSTATUS   DC    BL1'0'    Status bits\nSTATLOAD EQU   B'10000000'   User writer program has been loaded\nSTATREJ  EQU   B'01000000'   User program has issued stop/reject\nSTATSAPI EQU   B'00100000'   JES SAPI interface established\nSTATESTA EQU   B'00010000'   ESTAE recovery is in effect\n*TOP     EQU   B'00001000'   STOP command has been issued *unused* V120\nSTATABND EQU   B'00000100'   Abend has ocurred\nSTATSAPO EQU   B'00000010'   Spool dataset is open\nSTATWADS EQU   B'00000001'   No datasets were available for immediate  +\n                             processing\n*                                                                  V112\nSTATUS2  DC    BL1'0'    Status bits                               V112\nSTA2IOER EQU   B'10000000'   An I/O error ocurred reading SYSSAPI  V120\nSTA2DDNS EQU   B'01000000'   DDNAME= checking is in effect         V120\nSTA2DDNF EQU   B'00100000'   DDNAME specified has was found        V120\nST2BIT3  EQU   B'00010000'   Available for future use              V112\nST2BIT4  EQU   B'00001000'   Available for future use              V112\nST2BIT5  EQU   B'00000100'   Available for future use              V112\nST2BIT6  EQU   B'00000010'   Available for future use              V112\nST2BIT7  EQU   B'00000001'   Available for future use              V112\n*\n*=====================================================================*\n* Common dynamic allocation/unallocation parm\n*=====================================================================*\nSVC99P   DS    F               Address of S99RBP\nSVC99RBL EQU   S99RBEND-S99RBP Length of S99RBP\nSVC99RBB DS    XL(X'14')       Buffer for S99RBP\n* List of text pointers for allocation\nALTXTBK  DS    0F\nAALTXTU1 DS    A(0)            DDNAME=SYSSAPI\nAALTXTU2 DS    A(0)            DSN=xxxxxxxx\nAALTXTU3 DS    A(0)            SUBSYS=JES2\nAALTXTU4 DS    A(0)            DISP=OLD\nALTXBTOK DS    A(0)            Text unit passed from JES\n*\nALTXTPRE EQU   L'S99TUKEY+L'S99TUNUM+L'S99TULNG\n* Allocation Text unit 1 - DDNAME=SYSSAPI\nALTXTU1  DS    XL(ALTXTPRE)\nALLOCDDN DC    C'SYSSAPI'\n* Allocation Text unit 2 - DSN=xxxxxxxx\nALTXTU2  DS    XL(ALTXTPRE)\nALLOCDSN DS    CL44\n* Allocation Text unit 3 - SUBSYS=JESx\nALTXTU3  DS    XL(ALTXTPRE)\nALLOCSSN DS    CL4\n* Allocation Text unit 4 - DISP=OLD\nALTXTU4  DS    XL(ALTXTPRE)\nALLOCDSP DS    AL1(1)\n         EJECT\n*\n         SRSDATA DSECT=NO          MAP SRS Data Block\n         SRSABLK DSECT=NO          MAP SRSAUTH block\n         ASAXWC MF=(L,XWCLIST,0F)  List form of wildcard macro     V120\nWORK256  DS    CL265                                               V120\nSRSTLEN  EQU   *-SRSTWORK\n         EJECT\n*=====================================================================*\n* The SSOB is built in common storage, SP=228 KEY=0\n*=====================================================================*\nBUFSSWK  DSECT                  SSOB buffer\nBUFSSPTR DS    F                Pointer to SSOB\nBUFSSOB  DS    CL(SSOFLEN)      Buffer for SSOB & ext'n\nBUFSSLEN EQU   *-BUFSSWK        Total buffer length\n*\n* MAPPING MACROS\n         SRSTBLK                   MAP SRS Task Data Block\n         IEFJSSOB ,                Map SSOB header\nSSOBGN   DS    0D\n         IAZSSS2 DSECT=NO          Map SAPI extention\nSSOFLEN  EQU   *-SSOB              Length of full SSOB & ext'n\n         IEFZB4D0\n         IEFZB4D2\n*        PRINT NOGEN\n         IHAPSA                    MAP PSA\n         IHAASCB                   MAP ASCB\n         CVT   DSECT=YES           MAP CVT\n         IKJTCB\n         IEFJESCT\n         IEFJSSIB\n         IEZJSCB\nCSCB     DSECT\n         IEECHAIN                  MAP CSCB\n         DCBD DSORG=PS             MAP DCB\n         IHAECB\n         IEZCOM\n         IEZCIB\n         IHASDWA\n         YREGS\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SRSTBLK": {"ttr": 16643, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\r\\x00A\\x00\\x976O\\x01\\x060\\x0f\\x16X\\x002\\x00*\\x00\\x00\\xc4\\xe6\\xc4@@@@@@@'", "ispf": {"version": "01.13", "flags": 0, "createdate": "1997-12-30T00:00:00", "modifydate": "2006-10-27T16:58:41", "lines": 50, "newlines": 42, "modlines": 0, "user": "DWD"}, "text": "         MACRO\n         SRSTBLK &DSECT=YES\n         SPACE 3\n         AIF   ('&DSECT' EQ 'NO').GENLBL\nSRSTBLK DSECT\n         AGO   .GENAREA\n.GENLBL  ANOP\nSRSTBLK DS     0F\n.GENAREA ANOP\nSRSTBLKE DS    CL8'SRSTBLK'    SRSTBLK eye-catcher                 V120\nSRSTTIME DS    D               TOD of last dataset select\nSRSTECB  DS    F               ECB for attached SRSTASK\nSRSTECBX DS    F               ECB SRSDRVR will post for STATUS changes\nSRSTTCB  DS    F               TCB address of this SRSTASK\nSRSTNEXT DS    F               Pointer to next SRSTBLK\nSRSTAUTH DS    F               Pointer to SRSABLK auth blk\nSRSTCNT  DS    F               Number of datasets despooled\nSRSTRC   DS    F               Return code from SRSTASK subtask\nSRSTWRID DS    CL2             EBCDIC ID number of this SRS task\nSRSTPGMN DS    CL8             Name of user program to invoke\nSRSTFLAG DS    BL1'0'          Status bits\nSRSTSHUT EQU   B'10000000'     Writer is to be shutdown\nSRSTACT  EQU   B'01000000'     Writer is active\nSRSTSTRT EQU   B'00100000'     Writer is starting\nSRSTSHLD EQU   B'00010000'     Select HELD output               @A11102\nSRSTSNHL EQU   B'00001000'     SELECT NONHELD output            @A11102\nSRSTKEEP EQU   B'00000100'     Keep despooled datasets             V111\nSRSTWLIM EQU   B'00000010'     Display only important WTO messages\nSRSTNOWT EQU   B'00000001'     Do not wait for SYSOUT datasets\nSRSTCLAS DS    C               SYSOUT class selected\nSRSTDEST DS    CL18            Destination selected             @A12101\nSRSTJOBN DS    CL8             Jobname selected\nSRSTFORM DS    CL8             Forms queue selected\nSRSTWTRN DS    CL8             User writer name selected\nSRSTJBID DS    CL8             JES2 jobid selected\nSRSTSEPI DS    CL8             Separator record identifier         V121\nSRSTLIMT DS    H               Dataset select limit\nSRSTSEPO DS    BL1'0'          Separator Options                   V121\nSRSTSEPX EQU   B'00000000'     No separator records                V121\nSRSTSEPJ EQU   B'10000000'     Separator records between jobs      V121\nSRSTSEPG EQU   B'01000000'     Separator records between OUTGRPs   V121\nSRSTSEPD EQU   B'00100000'     Separator records between data sets V121\nSRSTDDNM DS    CL8             DDNAME selected                     V120\nSRSTPPRM DS    CL80            Parameters passed to despool pgm    V120\nSRSTLJBN DS    CL8             Jobname of last dataset despooled\nSRSTLJBI DS    CL8             Jobid of last dataset despooled\n         DS    0F              Expand to fullword boundry\nSRSTBLKL EQU   *-SRSTBLK\n         SPACE 5\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT790/CBT.V500.FILE790.PDS/SRS121.xmi", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT790/CBT.V500.FILE790.PDS", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}