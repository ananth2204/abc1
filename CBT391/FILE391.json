{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220011917000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 940576, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 7, "INMDSNAM": "CBT.V500.FILE391.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 940576, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 940576, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE391.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x10\\x07'", "DS1TRBAL": "b'\\xa94'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x02\\xce\\x00\\x04\\x02\\xcf\\x00\\x05\\x00\\x11'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04E\\x00\\x00\\x01\\x05\\to\\x01\\x05\\to\"\\x11\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf6\\xf9@@@'", "ispf": {"version": "04.69", "flags": 0, "createdate": "2005-04-06T00:00:00", "modifydate": "2005-04-06T22:11:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-469"}, "text": "REGULAR CBT TAPE - VERSION 469    FILE:  391\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT469.FILE391\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 11 MEMBERS COUNTED; CUMULATIVE SIZE IS 8,783 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   04/06/05    22:11:26    GMT-4:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$NOTE": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x00\\x08?\\x01\\x00\\x08?\\x199\\x00\\x1f\\x00\\x1f\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-03-23T00:00:00", "modifydate": "2000-03-23T19:39:00", "lines": 31, "newlines": 31, "modlines": 0, "user": "SBGOLOB"}, "text": "Hi Sam,\n\nThis will describe how I use TRACE390.\n\nBeing an assembler consultant working at mostly COBOL clients, I cannot\nguarantee there will be any assembler debugging tools available, so\nTRACE390 is used mostly as a poor man's debugger.\n\nIn most case I can isolate where a problem is occurring but sometimes\ncannot see why. I invoke TRACE390 at a point close to where I believe\nthe problem is occurring and single step thru the output until I see it\ndo something unexpected.\n\nSince the source is available, you can customize it to work for\nspecialized problems. One example of this is the watchpoint feature I\nadded when I had a problem where I knew what was being altered, but had\nno clue who was doing it. Watchpoints allow you to specify a storage\nlocation (address and length) and have an exit invoked whenever that\nstorage is about to be updated.  By activating TRACE390, but suppressing\nthe output until the exit detects the storage alteration, you can avoid\ngenerating millions of lines of output before the problem is\nencountered.\n\nDue to the potentially large amount of output TRACE390 can produce, I\nmostly use it to analyze strange but repeatable problems in assembler\nprograms.\n\nHope this helps,\nRobert\n\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$$NOTE1": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\t\\x01\\x05\\to\\x01\\x05\\to\"\\x11\\x00\\x0c\\x00\\x0c\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2005-04-06T00:00:00", "modifydate": "2005-04-06T22:11:09", "lines": 12, "newlines": 12, "modlines": 0, "user": "SBGOLOB"}, "text": "Hi Sam,\n\nThe attached XMI file contains a minor fix to TRACE390 to\ncorrectly handle the STAM, TAR and EAR instructions.\n\nI also removed some obsolete email addresses of mine, and added a\nreference in the doc to the original source to this program\n(written in 1968!).\n\n\nRobert Ngan\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$DOCTRAC": {"ttr": 522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x10\\x01\\x05\\to\\x01\\x05\\to\\x15T\\x02\\xd4\\x02\\xd4\\x00\\x00\\xd9\\xd5\\xc7\\xc1\\xd5@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2005-04-06T00:00:00", "modifydate": "2005-04-06T15:54:10", "lines": 724, "newlines": 724, "modlines": 0, "user": "RNGAN"}, "text": "TRACE390 - An Assembler Level Trace Routine\n\n\nFunction\n\nThe TRACE390 routine is used to trace a program's execution at the\nassembly level. Each instruction is printed after it is executed\ndisplaying various data related to the execution of the instruction.\n\nDescription\n\nTRACE390 retains control of the traced program after it is called\nand executes the traced program's instructions until it detects that\nit is tracing itself at which point it returns control.\n\nControl\n\nOn entry, register one contains one of the following values:\n\n0            Turn tracing off, if tracing is not on then do nothing.\n\n-1           Invoke trace with parameter list containing zeroes in\n             all positions.\n\n-2           Same as for -1 except flag Flg$GDSN is assumed to be\n             set.\n\nOther        The value in register one is the address of a variable\n             length parameter list in the format shown in the table\n             below.\n\nIf register 1 is non-zero, tracing is toggled (i.e. if it is off,\nit will be turned on and vice versa).\n\nOffset     Type       Description\n\n+0         A          Address of Bit Flags Word\n+4         A          Address of Print Range(s) Table\n+8         A          Address of Break Point(s) Table\n+C         A          Address of Watchpoint(s) Table\n+10        A          Address of Execution Profile Table\n+14        A          Address of Instruction Count Table\n+18        A          Address of Output DD Name\n\nRegister 14 contains the address of the first instruction to be\ntraced, with the high order bit specifying the addressing mode of\nthe traced program. Note that the BAL instruction will set the high\norder bit in the linkage register in AMODE=24, so should not be used\nto invoke this module.\n\nThe parameter list and parameters passed to TRACE390 may reside\nanywhere in virtual storage. The dsects for the various table\nentries are generated by macro TRCTBLS.\n\nNote: ALL addresses specified in the parameters are treated as 31\nbit values, it is up to the user to ensure that there is no\nextraneous bits set in the top byte. The high order bit should only\nbe set to signify \"end of list\" or that an user exit should be\nentered with AMODE=31.\n\nBit Flags Word\n\nThis is a fullword containing the initial status flags to be used by\nthe trace routine. Equates for the flags are found in macro TRCFLAGS,\nthe flags specified in the first byte are:\n\nFlg$PrHdr           x'80'     Print page header at top of each page.\n\nFlg$Print           x'40'     Instruction printing is enabled.\n\nFlg$PrCurInst       x'20'     Print current instruction even if\n                              Flg$Print is off, this flag is normally\n                              only set by user exits and is turned off\n                              at the end of each instruction.\n\nFlg$TrDLI           x'10'     Trace code within DL/I calls.\n\nFlg$PrBAL           x'08'     Turn Flg$PrCurInst on for BAL, BALR,\n                              BAS, BASR and BASSM.\n\nFlg$PrRet           x'04'     Turn Flg$PrCurInst on for BSM, and\n                              BCR instructions in which the branch\n                              was taken.\n\nFlg$Spin            x'02'     If set on entry to TRACE390 and output\n                              is directed to a SYSOUT dataset, will\n                              spin off the output when tracing is\n                              turned off. If set on return from an\n                              user exit, will close and re-open output\n                              dataset before printing the next output\n                              line. If output is to a SYSOUT dataset,\n                              the closed dataset will be spun off\n                              before it is re-opened.\n\nFlg$Call            x'01'     Turn on Flg$PrCurInst for SVC, and for\n                              BALR, BASR and BASSM instructions which\n                              use R14 and R15, with R15 pointing at a\n                              branch instruction jumping around module\n                              identification information.  The flags\n                              used in the second byte are:\n\nFlg$PICT            x'80'     Print contents of the instruction count\n                              table(s) on exit from trace. Where trace\n                              is to be invoked multiple times, this\n                              flag should be set on the last entry to\n                              trace otherwise you will get the\n                              table(s) printed multiple times.\n\nFlg$NCFP            x'40'     Setting this flag disables counting\n                              of floating point instructions.\n\nFlg$PEPT            x'20'     Print contents of the execution profile\n                              table(s) on exit from trace. Where trace\n                              is to be invoked multiple times, this\n                              flag should be set on the last entry to\n                              trace otherwise you will get the tables\n                              printed multiple times.\n\nFlg$NPNE            x'10'     Suppress printing of execution counts of\n                              instructions that were never executed.\n\nFlg$NALC            x'08'     Do not dynamically allocate output\n                              dataset if the DD name entry was not\n                              found in the TIOT. If this occurs,\n                              tracing is disabled.\n\nFlg$GDSN            x'04'     Allocate a cataloged dataset to hold the\n                              trace output, the name of the dataset is\n                              of the form:\n\n                              TESTHOG.T370.asname.Ddate.Ttime.Sseq\n\n                              where:\n                              asname  The name of the address space in\n                                      which TRACE390 is executing\n                              date    The Julian date when the first\n                                      output line was written\n                              time    The time (hhmmss) when the first\n                                      output line was written\n                              seq     This 3 character field is the\n                                      hundredths of seconds from the\n                                      time plus a single hex digit (in\n                                      case you spin off multiple output\n                                      datasets within the space of the\n                                      same hundredth of a second!).\n\nFlg$NoPrEMC         x'02'     Do not print BC, BCR and BRC\n                              instructions in extended mnemonic\n                              format.\n\nx'01'               Reserved\n\nThe other two bytes are reserved and must be set to zeros. If the\nflag word address is zero, a default of Flg$PrHdr+Flg$Print will be\nused.\n\nPrint Range(s) Table\n\nThis table containing range(s) of addresses for which traced\ninstructions will be printed. Instructions traced, which are not\nwithin any specified range, will not be printed. If the table\naddress is zero or this parameter is not supplied, all traced\ninstructions will be printed.\n\nThe table consists of one or more 8 byte entries in the format shown\nbelow. Entries are mapped by DSECT PrtEntry.\n\nOffset     Type       Name       Description\n\n+0         A          PrtStart   Start Address of Print Range\n+4         A          PrtEnd     End Address of Print Range\n\nThe end of the table is specified by setting the high order bit of\nthe in the PrtStart field.\n\nBreak Point(s) Table\n\nThe break point table allows programmers to obtain control when the\ninstruction pointer reaches a specified location (or locations).\nThis table consists of one or more 8 bytes in the format shown in\nthe table below.  Entries are mapped by DSECT BptEntry.\n\nOffset     Type       Name       Description\n\n+0         A          BptAddr    Break Point Address\n+4         A          BptExit    AMODE/EPA of breakpoint exit.\n\nSetting the high order bit in the BtpAddr field of the last table\nentry specifies the end of the table.  If the table address is zero\nor this parameter is not supplied, there are no breakpoints.  See\nBreakpoint/Watchpoint Exits below for details on Breakpoint exits.\n\nWatch Point Table\n\nThis table defines a range (or ranges) of storage at which the user\nwants to trap storage alterations. If the table address is zero or\nthis parameter is not supplied, no watch points are set.  This table\nconsists of one or more 16 byte entries in the format shown below.\nEntries are mapped by dsect WPTENTRY.\n\nOffset     Type       Name       Description\n\n+0         A          WptStart   Watch Point Address\n+4         A          WptEnd     Watch Point End Address\n+8         F          WptALET    ALET of watchpoint range\n+C         A          WptExit    AMODE/EPA of Watch Point Exit\n\nSetting the high order bit in the WPTSTART field of the last table\nentry specifies the end of the table.  The exit routine is invoked\nprior to the execution of the instruction that will alter any byte\nin the address range specified with the exit.\n\nProfiler Table\n\nThe profiler table is used to obtain information on the where a\nprogram is spending its time. The table contains one or more 24 byte\nentries in the format shown below. Entries are mapped by dsect\nPRFENTRY.\n\nOffset     Type       Name       Description\n\n+0         A          PRFTABLE   Address of Profile Data Table\n+4         F          PRFINTVL   Profile Range Sub-Interval Size\n+8         A          PRFSTART   Start Address of Profile Range\n+C         A          PRFEND     End Address of Profile Range\n+10        CL8        PRFIDENT   Profile Range Identifier.\n\nSetting the high order bit in the PRFTABLE field of the last table\nentry specifies the end of the table.  If the table address is zero\nor not supplied, no profiling will be done.\n\nThe Sub-Interval Size is the size of the interval which the profile\nrange will be sub-divided into. The minimum value for this field is\nfour.\n\nThe Profiler Data Table is a block of unsigned fullwords containing\nthe count of instructions executed within the relative sub-interval.\nThe number of fullwords in this table is equal to:\n\n        CEIL(End Address - Start Address)/(Sub Interval Size))\n\nIt is the user's responsibility to initialize the data table to\nzeros, TRACE390 will not zero the table so it can be invoked\nmultiple times with the same parameter list to give the caller\ncumulative counts.  The identifier is used when TRACE390 prints the\ncontents of the data table and is printed with the title line.\n\nInstruction Count Table\n\nThis table is used to count the number of times an instruction is\nexecuted within an address range.  If the table address is zero or\nnot supplied, no instruction counting is done. The table contains\none or more 20 byte entries in the format shown below. Entries are\nmapped by dsect IN#ENTRY.\n\nOffset     Type       Name       Description\n\n+0         A          IN#TABLE   Address of Instruction Count Data\n+4         A          IN#START   Start Address of Count Range\n+8         A          IN#END     End Address of Count Range\n+C         CL8        IN#IDENT   Count Range Identifier.\n\nThe end of the table is specified by setting the high order bit in\nthe IN#TABLE field of the last table entry.\n\nThe instruction count data area consists of 1024 fullwords, it is\nthe callers responsibility to initialize the count data to zeros.\nTRACE390 will not zero the table so it can be invoked multiply times\nwith the same parameter list to give the caller cumulative counts.\nEach fullword is considered to be a 32 bit unsigned number.\n\nThe count table is indexed by the first byte of the instruction code\nso counts of two byte opcodes with equal first bytes are merged.\n\nThe identifier is used when TRACE390 prints the contents of the data\ntable and is printed with the title line.\n\nOutput DD Name\n\nThis is an 8-byte character string to be used as the DD name which\ntrace will write its output to. If this parameter is zero or not\nsupplied, the output DD name will default to SYSTRACE.\n\nInvoking TRACE390\n\nThe trace routine should always be invoked using the instructions\n        LA    R01,parmlist        (or SLR  R01,R01 to disable Trace)\n        CALL  TRACE               Toggle/Disable Trace\n\nThe csect TRACE is actually a stub that will load TRACE390 on first\ntime through and branch to it. If not the first time through, it\nwill just branch to TRACE390.  This gives us a standard interface to\nthe trace routine for callers above and below the 16M line.  TRACE is\nalso link-edited as RMODE=ANY so linking it into your program make\nyour program RMODE=24.\n\nNote: The csect TRACE is NOT re-entrant since it needs to store the\nEPA of TRACE390.  TRACE390 must reside below the line since it must\nrun with AMODE=24 while processing AMODE=24 code so it cannot be\nlink-edited into modules which are loaded above the 16M line, this\nis not a problem for TRACE.\n\nSince TRACE390 is dynamically loaded at run time, it must reside in\neither the link list or your JOBLIB/STEPLIB.\n\nExit Conditions\n\nOn exit, the registers and the condition code are restored to the\nvalues they had after the last instruction traced.\n\nAll output written by the trace routine is written to a user DD name\n(or SYSTRACE if no DD name was supplied). If no DD statement was\nsupplied for the trace output dataset, it will be dynamically\nallocated as a SYSOUT=* dataset (unless the caller set the Flg$NALC\nflag). The dataset has the following attributes:\nLRECL=133,BLKSIZE=0,RECFM=FBA\n\nExample of output produced by TRACE390 is shown in member\n$EXTRACE.\n\nThe following fields are printed with each instruction executed\n(assuming that printing is enabled):\n\n. Current addressing mode and location counter (bits 32-63 of PSW)\n. Current Address Space Control (ASC) mode, one of:\n    P - Primary-space mode\n    S - Secondary-space mode\n    A - Access-register mode\n    H - Home-space mode\n. Instruction image (in hex)\n. Condition Code (displayed as mask bit value)\n. An arrow is printed for each successful branch instruction, the\n  arrow indicates the relative direction of the branch, i.e.,\n    <- : branching to a lower address\n    -> : branching to a higher address\n    <> : branch to the current instruction (looping?)\n. Instruction Mnemonic\n. Instruction Operand(s)\n. For SVC instructions, the name(s) of the macro(s) normally used to\n  generate the SVC.\n. Contents of first register operand (R1)\n. Contents of second register operand (R2) (or contents of R1+1 if a\n  double register operand)\n. Effective address of first storage operand (or contents of R2 if a\n  double register operand)\n. First Operand storage contents (up to 8 bytes) (or contents of\n  R2+1 if a double register operand)\n. First Operand storage contents (Second half of double word)\n. Effective address of Second storage operand\n. Second Operand storage contents (up to 8 bytes)\n. For BALR/BASR/BASSM instructions using registers 14 and 15 as\n  operands, the module-id information (if present).\n. Module-id information will not be printed for BASSM instructions\n  which switch from AMODE=24 to AMODE=31 where the target of the\n  branch is above the 16M line.\n\nThe following information is printed for each execution profile table:\n. The offset from the start of the range to the sub-interval.\n. The start-end addresses of the sub-interval.\n. The number of instructions executed within the sub-interval.\n. The percentage of instructions executed in the sub-interval\n  (compared to the total over that range).\n\nThe following information is printed for each instruction count table:\n. Operation Code (in hex)\n. Instruction Mnemonic\n. Number of instructions executed in the count range\n. The percentage value of the number of this instruction compared to\n  the total number of instructions executed in the count range.\n\nThe instructions are printed in order of operation code.\n\nBreakpoint/WatchPoint Exits\n\nBoth Breakpoint and WatchPoint exits are invoked before execution of\nthe instruction in question. On entry to the exit, the contents of\nthe registers are:\n\nR01 - Address of a 9 fullword fixed length parameter list.\nR13 - Address of a 18 fullword register save area.\nR14 - Return address to TRACE390\nR15 - Entry point address to exit\n\nThe parameter list pointed at by R01 is in the format shown in the\nfollowing table.\n\nOffset     Type       Description\n\n+0         A          Address of Bit Flags Fullword\n+4         A          Address of traced program's general registers\n+8         A          Address of the traced program's access registers\n+C         A          Address of traced program's Condition Code\n+10        A          Address of traced program's PSW Bits 32-63\n+14        A          Address of Address of Storage to be Altered\n+18        A          AMODE/EPA of the Trace Output Routine\n+1C        A          Address of Output Routine's Data Area\n+20        A          AMODE/EPA of the Storage Dump Routine\n\n1. The address of the status flags word, this flag word was\n   described at the beginning of this document.  The exit may modify\n   these flags to change processing by the trace routine. Note that\n   setting flag Flg$PrCurInst will result in printing of the current\n   instruction (only), even if printing is disabled or the instruction\n   is not in a valid instruction print range.\n\n2. The address of a 16-fullword area containing the traced programs\n   general registers, stored in the sequence R00-R15. The exit may\n   modify any/all of the registers.\n\n3. The address of a 16-fullword area containing the traced programs\n   access registers, stored in the sequence AR00-AR15. The exit may\n   modify any/all of the registers.\n\n4. The address of a byte containing the traced programs current\n   condition code. The condition code is stored in bits 6-7 of the\n   byte, bits 0-5 are zeros and must remain so. The exit may modify the\n   condition code.\n\n5. The address of a fullword containing bits 32-63 of the traced\n   programs PSW, i.e. its addressing mode and current location counter.\n   Breakpoint exits may change the addressing mode and/or location\n   counter, changes to this field by WatchPoint exits are ignored.\n\n6. The address of a fullword containing the address of the byte of\n   storage about to be altered. For breakpoint exits, this fullword\n   contains zero.\n\n7. The address of a routine used to write to output to the trace\n   dataset. Callers in any amode/rmode may use this routine. This\n   routine must be invoked via BASSM R14,R15, and the caller must\n   provide a save-area pointed at by R13.\n\n8. The address of a 133-byte area used by the trace output routine\n   as the data area to be printed. This is the actual I/O area used by\n   TRACE390 to build output lines so the user could set the carriage\n   control byte to C'1' to generate page skips so as to break up the\n   output into logical sections.\n\n9. The address of a routine which a user exit may invoke to produce\n   a formatted dump of virtual storage (output is sent to the trace\n   dataset) and may be used by callers in any amode/rmode. On entry, it\n   expects the starting address of the storage to dump in register 0\n   and the length of the storage to be dumped (in fullwords) in\n   register 1. This routine must be invoked via BASSM R14,R15, and the\n   caller must provide a save-area pointed at by R13.\n\nNote that calling this routine will clear the contents of the output\nroutine's data area as it is used by the dump routine.\n\nAll exits are invoked using BASSM R14,R15 so should return to the\ntrace routine via a BSM 0,R14 instruction. The traced programs\nfloating point registers remain in the actual floating-point\nregisters on entry to an exit, the exit may change any/all of the\nfloating point registers.\n\nIf the exit wants to write to the trace output dataset, it should\nuse the following code:\n\n         L     R02,24(,R01)         Point to output buffer\n         MVC   0(133,R02),outdata   Move data to output buffer\n         L     R15,20(,R01)         Address of TRACE's PUT routine\n         BASSM R14,R15              Go do PUT\n\nAll registers are restored on return from the PUT routine.\n\nTo spin-off (or reuse) the output dataset, the exit merely needs to\nset Flg$SPIN in the first byte of the status word i.e.\n\nSPINEXIT DS    0H                   Spinoff or reuse output dataset\n         L     R15,0(,R01)          Load address of status flags\n         OI    0(R15),Flg$SPIN      Turn on spinoff flag\n         SLR   R15,R15              Set zero return code\n         BSM   0,R14                Return to TRACE\n\nOn return from a user exit, R00-R14 must be restored, R15 holds the\nreturn code, a value of zero to indicate continuation of tracing,\nany other value will turn tracing off. If tracing is turned off, it\nwill be turned off after the current instruction is executed.\n\nMessages\n\nData set closed by ESTAE, abending PSW is hhhhhhhh hhhhhhhh\n-----------------------------------------------------------\n\nAn abend occurred at the indicated PSW address, the TRACE390 ESTAE\nroutine successfully closed the SYSPRINT dataset before allowing the\nabend to percolate.\n\nThis message is issued when the abend occurs during execution of an\ninstruction which TRACE390 is not controlling, i.e.\n. DL/1 code not traced by TRACE390\n. Code being executed under a different RB (normally a result of\n  executing a SVC)\n. Bad code within TRACE390 itself\n\nData set closed by ESTAE, abending while tracing instruction at\n---------------------------------------------------------------\naddress aaaaaaaa\n----------------\n\nTRACE390 abended while attempting to execute an instruction copied\nfrom the indicated address. The TRACE390 ESTAE routine successfully\nclosed the SYSPRINT dataset before allowing the abend to percolate.\n\nTRC001 Status flags invalid, bytes 3-4 are non-zero, Flags=hhhhhhhh\n-------------------------------------------------------------------\n\nThe second 2 bytes of the flag word in the parameter list are\ncurrently reserved for future use and should be set to zero but\nTRACE390 found the indicated values there.  Ensure that you are\npassing a correct parameter list to TRACE390.\n\nTRC002 Invalid tttt table entry, Start(ssssssss) GT End(eeeeeeee)\n-----------------------------------------------------------------\n\nA table entry was found with a start range higher than the end\nrange. Note that the end of table marker should be on the start of\nrange address.\n\nTRC003 User Supplied DDNAME dddddddd is invalid\n-----------------------------------------------\n\nThe user supplied DD name with which to replace SYSTRACE contains\ncharacters which are not valid in a DD name.\n\nTRC004 End of parmlist not found at seventh parameter\n-----------------------------------------------------\n\nTRACE390 expects a maximum of 7 parameters to be passed to it but\nthe seventh parameter was processed without finding the high order\nbit set in a parameter address.\n\nTRC005 DYNALLOC error, Verb=vv, RC=rr, Error=eeee, Info=iiii,\n-------------------------------------------------------------\nDDNAME=dddddddd\n---------------\n\nA dynamic allocation request failed while attempting to allocate or\ndeallocate the trace output dataset.  Refer to the OS/390 MVS\nAuthorized Assembler Services Guide manual for details on the\nreturned error information.\n\nTRC006 Attempt to ESTAE failed, RC=rr\n-------------------------------------\n\nTRACE390's attempt to establish an ESTAE to trap abends returned the\nindicated return code, zero was the expected return code.  Contact\nUmbrella Support.\n\nTRC007 Dataset OPEN failed on DDNAME dddddddd\n---------------------------------------------\n\nAn OPEN for output failed for the indicated DD.\n\nTRC008 DDNAME \"dddddddd\" not found in task I/O table\n----------------------------------------------------\n\nThe indicated DD was not found in the Task I/O Table and flag\nTRC$NARC was not specified.\n\nTRC009 Unable to return to traced program, no valid base register\n-----------------------------------------------------------------\n\nDuring trace termination, a register must be used as a base for the\nbranch back to the code being traced. No register was found which\ncould be used for this purpose.\n\nThis can occur if the traced program issues an SVC which branches\nback into the traced program to where tracing is turned off before\nthe SVC returns. An example of this is PEM linking to SORT which\nthen calls PEM as a SORT exit.\n\nTRC010 Profile sub-interval of iiiiiiii is invalid\n--------------------------------------------------\n\nThe profiler sub-interval must have a value not less than 4.\n\nTRC011 Zero table address is invalid in tttttttt entry\n------------------------------------------------------\n\nA zero address is not allowed for a profiler or instruction count\ndata table.\n\nTRC012 Bit zero set in tttttttt address (aaaaaaaa)\n--------------------------------------------------\n\nThe high order bit of an address field was set where it was not\npermitted. The high order bit may only be used in exit EPA's to\nindicate the exit is to be invoked with AMODE=31, or to mark the\nlast entry of a table.\n\nTRC013 tttttttt entry at address aaaaaaaa has an exit EPA of zero\n-----------------------------------------------------------------\n\nA table entry was found in which the exit routine's address was\nzero, which is not permitted.\n\nException Conditions\n\nA U3579 abend will result from any of the following conditions:\n    1. Attempt to ESTAE failed\n    2. Invalid output DD name passed to program.\n    3. Trace output DCB could not be opened.\n    4. Invalid parameter list passed to TRACE390.\n\nThe actual cause of the abend will be displayed on the job log via a\nWTO message immediately before issuing the ABEND.\n\nNote: 3579 is used as it is in the range of codes reserved by IMS\nfor customer usage.\n\nRestrictions (and known bugs)\n\nThe following is a list of known problems and restrictions in the\nuse of the trace routine:\n\n. Does not support privileged instructions\n. Does not support vector instructions\n. Does not support binary floating point instructions.\n. WatchPoints are only triggered by (non-SVC) instructions executed\n  under the control of TRACE390, therefore if the DL/I trace flag is\n  off, storage altered by DL/I will not trigger a call to the watch\n  point exit. Storage altered by SVC and PC instructions never trigger\n  watchpoint exits.\n. WatchPoints are not triggered by UPT instructions.\n. Tracing of DL/I calls is only be disabled for entries to DL/I via\n  BALR, BASR and BASSM with R14,R15 as operands. If a BASSM\n  instruction is used which switches from AMODE=24 to AMODE=31 with\n  the branch target above the 16MB line, DL/I tracing cannot be\n  disabled.\n\nComponents\n\nName       Type       Description\n\nTRACE      Program    Stub for linking to traced program\nTRACE390   Program    Main trace routine\nTRCTBLS    Macro      Dsects for parameters passed to TRACE390\nTRCFLAGS   Macro      Equates for bit switches used by TRACE390\n\n * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\nCredits\n\nAuthor:    Bernard Schoch, Comnet Computer Center\nDebugged 03/22/74 by Claude Schoch\nConverted for 370 instructions and extended floating point\ninstructions by Claude Schoch 2/12/75\n\nEnhanced and supported by:\n    Lionel Silva\n    US Postal Data Center\n    850 Cherry Avenue\n    San Bruno, CA 94097-9330\n    (415) 876-9142\n\nEnhanced again by:\n    Robert Ngan (October 1987)\n    Environment Technical Support,\n    Databank Systems (NZ) Ltd.\n    Wellington,\n    New Zealand.\n\nin the following areas:\n    . Support 370/XA instructions\n    . Support programs running in AMODE=31\n    . Support RMODE=ANY code and data\n    . Support semi and non privileged X'B2' instructions\n    . Trap storage alteration at user specified addresses\n      (watchpoints)\n    . Restrict instructions printed to user specified ranges\n    . Allow caller to specify breakpoints\n    . Allow (optional) suppression of DL/I code trace\n    . Correct format of packed decimal operands for printing\n    . Prevent instruction fetches off the end of the program\n    . Trace program/subroutine call and return type branches\n    . Print module identification data on CALL type branches\n    . Gather program execution profile information\n    . Count number of instructions executed in user defined ranges\n    . Dynamically allocate output dataset if not pre-allocated\n\nEnhanced by:\nRobert Ngan (November 1989)\nIntegrated Systems Support,\nGreat Western Bank.\n19860 Plummer Street,\nChatsworth, CA 91311\nin the following area(s):\n\n    . Allow dynamic allocation of cataloged output dataset\n\nEnhanced by:\nRobert Ngan (October 1999)\nCSC Financial Services Group,\nDallas, TX 75063\nin the following area(s):\n\n    . Support access-register ASC mode programs and the use of access\n      registers\n    . Support tracing of BAKR and PR instructions\n    . Support move-page facility\n    . Support string-instruction facility\n    . Support immediate-and-relative facility.\n    . Support compare-and-move-extended facility\n    . Support checksum facility\n    . Support trap facility\n    . Print BC, BCR and BRC instructions in extended mnemonic format\n\nReporting Problems\n\nBug reports should be emailed to Robert Ngan at:\n\n  Robert_Ngan@csc.com\n\nOriginal Program Source\n\nA Compiler Generator (Appendix 2)\nby W M McKeeman, J J Horning and D B Wortman.\nPrentice Hall. (c) 1970.\n\nLibrary of Congress Catalog Number 76-117205\nISBN 013-155077-2\n\nOriginal program source available from: www.cs.toronto.edu/XPL/xpl.zip\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$EXTRACE": {"ttr": 774, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99)O\\x00\\x99)O\\x15&\\x00\\xa7\\x00\\xa7\\x00\\x00\\xe7\\xd4\\xc9\\xe3@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-10-21T00:00:00", "modifydate": "1999-10-21T15:26:00", "lines": 167, "newlines": 167, "modlines": 0, "user": "XMIT"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "$TRACDOC": {"ttr": 778, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00#\\x01\\x05\\to\\x01\\x05\\to\\x15T\\x03\\xc7\\x03\\xc7\\x00\\x00\\xe6\\xd6\\xd9\\xc4\\xf9\\xf7@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2005-04-06T00:00:00", "modifydate": "2005-04-06T15:54:23", "lines": 967, "newlines": 967, "modlines": 0, "user": "WORD97"}, "mimetype": "application/msword", "datatype": "binary", "extension": ".doc"}, "@FILE391": {"ttr": 1284, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04E\\x00\\x00\\x01\\x05\\to\\x01\\x05\\to\"\\x11\\x00\\x19\\x00\\x19\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf6\\xf9@@@'", "ispf": {"version": "04.69", "flags": 0, "createdate": "2005-04-06T00:00:00", "modifydate": "2005-04-06T22:11:00", "lines": 25, "newlines": 25, "modlines": 0, "user": "CBT-469"}, "text": "//***FILE 391 is from Robert Ngan and is an assembler level         *   FILE 391\n//*           instruction tracing program called TRACE390.          *   FILE 391\n//*                                                                 *   FILE 391\n//*           Documentation for this program is in member           *   FILE 391\n//*           $DOCTRAC.  Member $EXTRACE, which contains a sample   *   FILE 391\n//*           of the output of this program, is in TSO XMIT         *   FILE 391\n//*           format, which becomes a sequential file with          *   FILE 391\n//*           RECFM=FB, LRECL=133, after TSO RECEIVE is done        *   FILE 391\n//*           to it, as the INDSN dataset name.                     *   FILE 391\n//*                                                                 *   FILE 391\n//*           Member $TRACDOC is in Word 97 format.  In order to    *   FILE 391\n//*           read it, download it \"binary\" RECFM=FB,LRECL=80       *   FILE 391\n//*           to a PC, and it should be readable.  I tried it,      *   FILE 391\n//*           and it was OK.                                        *   FILE 391\n//*                                                                 *   FILE 391\n//*         Address:                                                *   FILE 391\n//*                                                                 *   FILE 391\n//*         Robert Ngan (April 2005)                                *   FILE 391\n//*         CSC Financial Services Group,                           *   FILE 391\n//*         Dallas, TX 75063                                        *   FILE 391\n//*                                                                 *   FILE 391\n//*           email:                                                *   FILE 391\n//*                                                                 *   FILE 391\n//*           Robert_Ngan@csc.com                                   *   FILE 391\n//*                                                                 *   FILE 391\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TRACE": {"ttr": 1286, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00\\x00\\x00\\x99$_\\x00\\x99)\\x1f\\x15\\x06\\x00@\\x00B\\x00\\x00\\xd9\\xd5\\xc7\\xc1\\xd5@@@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "1999-09-02T00:00:00", "modifydate": "1999-10-18T15:06:00", "lines": 64, "newlines": 66, "modlines": 0, "user": "RNGAN"}, "text": "TRACE    TITLE 'TRACE390 Interface Stub'\nR00      EQU   0\nR01      EQU   1\nR02      EQU   2\nR03      EQU   3\nR04      EQU   4\nR05      EQU   5\nR06      EQU   6\nR07      EQU   7\nR08      EQU   8\nR09      EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         SPACE 2\n         SYSSTATE ASCENV=P\n&AsmDate SETC  '&SYSDATC'(1,4).'/'.'&SYSDATC'(5,2).'/'.'&SYSDATC'(7,2)\n         SPACE\n*---------------------------------------------------------------------*\n*        Entry Logic                                                  *\n*---------------------------------------------------------------------*\n         SPACE\nTRACE    CSECT ,\nTRACE    AMODE 31\nTRACE    RMODE ANY\n         USING TRACE,R12\n         J     AA010                   Branch around ID string\n         DC    AL1(AA010-*-1)          ID string length\n         DC    CL9'TRACE'              Program id\n         DC    CL12'v03.r01.m00'        - Version, Release & Mod. level\n         DC    CL9'HLA&SYSVER'          - HL Assembler version\n         DC    CL11'&AsmDate'           - Assembly date\n         DC    CL5'&SYSTIME'            - Assembly time\n         SPACE\n*---------------------------------------------------------------------*\n*        Load module TRACE390 if first time through                   *\n*---------------------------------------------------------------------*\n         SPACE\nAA010    DS    0H\n         STM   R14,R12,12(R13)         Save callers registers\n         LR    R12,R15                 Load our program base\n         ICM   R00,B'1111',aTRACE      Q. Trace routine loaded yet?\n         JNZ   AA020                   Y. Branch to it then\n         LOAD  EPLOC=TRACE390          N. Load trace module\n         ST    R00,aTRACE                 Save entry point address\n         SPACE\nAA020    DS    0H\n         LR    R15,R00                 Load branch register\n         L     R14,12(,R13)            Load return address\n         LM    R00,R12,20(R13)         Restore callers registers\n         BR    R15                     Invoke TRACE390\n         SPACE 3\naTRACE   DC    A(0)                    Entry point address of TRACE390\nTRACE390 DC    CL8'TRACE390'           Name of real trace routine\n         SPACE 2\n         LTORG ,\n         SPACE 3\n         END   TRACE\n         PUNCH ' SETOPT PARM(REUS=SERIAL,CALL)'\n         PUNCH ' NAME TRACE(R)'\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TRACE390": {"ttr": 1288, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01E\\x00\\x10\\x01\\x05\\to\\x01\\x05\\to\\x15T\\x1aF\\x1aF\\x00\\x00\\xd9\\xd5\\xc7\\xc1\\xd5@@@@@'", "ispf": {"version": "01.69", "flags": 0, "createdate": "2005-04-06T00:00:00", "modifydate": "2005-04-06T15:54:10", "lines": 6726, "newlines": 6726, "modlines": 0, "user": "RNGAN"}, "text": "Trace390 TITLE 'Enterprise System Architecture/390 Instruction Trace'\n&ABEND   SETC  '3579'               ABEND code issued by TRACE390\nBit0     EQU   X'80000000'          High order bit of fullword\nARmode   EQU   X'00000010'          Access-register mode\n         SPACE\n*---------------------------------------------------------------------*\n*        General Purpose Registers                                    *\n*---------------------------------------------------------------------*\n         SPACE\nR00      EQU   0                    Scratch register\nR01      EQU   1                    Scratch register\nR02      EQU   2                    Scratch register\nR03      EQU   3                    Scratch register\nR04      EQU   4                    Scratch register\nR05      EQU   5                    Instruction attribute flags pointer\n*                                   ... within routine 'ExecInst' only\nR06      EQU   6                    Used by profiler/count print rtnes\nR07      EQU   7                    1st program base\nR08      EQU   8                    2nd program base\nR09      EQU   9                    3rd program base\nR10      EQU   10                   Base for data area\nR11      EQU   11                   Traced program instruction pointer\nR12      EQU   12                   First level subroutine linkage\nR13      EQU   13                   Address of our register save area\nR14      EQU   14                   Second level subroutine linkage\nR15      EQU   15                   Scratch, base during initialisation\n         SPACE\nR0t      EQU   12                   Dummy GPR specifier used as base   -\n                                    by instructions which will be      -\n                                    updated (zapped) with a dynamically-\n                                    determined register at run-time.   -\n                                    Value is arbitrary, but non-zero\nAR0t     EQU   R0t                  Matching dummy AR for R0t\n         SPACE\n*---------------------------------------------------------------------*\n*        Access register equates                                      *\n*---------------------------------------------------------------------*\n         SPACE\nAR00     EQU   0\nAR01     EQU   1\nAR02     EQU   2\nAR03     EQU   3\nAR04     EQU   4\nAR05     EQU   5\nAR06     EQU   6\nAR07     EQU   7\nAR08     EQU   8\nAR09     EQU   9\nAR10     EQU   10\nAR11     EQU   11\nAR12     EQU   12\nAR13     EQU   13\nAR14     EQU   14\nAR15     EQU   15\n         SPACE\n*---------------------------------------------------------------------*\n*        Instruction codes explicitly tested for, or for those        *\n*        instructions prefixed by X'B2', the second byte only         *\n*---------------------------------------------------------------------*\n         SPACE\n$01      EQU   X'01'                x'01' prefixed instructions\n$A7      EQU   X'A7'                x'A7' prefixed instructions\n$B2      EQU   X'B2'                x'B2' prefixed instructions\n         SPACE\n$BAKR    EQU   X'B240'-X'B200'      Branch and Stack\n$BC      EQU   X'47'                Branch on Condition\n$BCR     EQU   X'07'                Branch on Condition Register\n$BSM     EQU   X'0B'                Branch and Set Mode\n$CDS     EQU   X'BB'                Compare Double and Swap\n$CLCL    EQU   X'0F'                Compare Logical Long\n$CLCLE   EQU   X'A9'                Compare Logical Long Extended\n$EAR     EQU   X'B24F'-X'B200'      Extract Access Register\n$EREG    EQU   X'B249'-X'B200'      Extract Stacked Registers\n$ESTA    EQU   X'B24A'-X'B200'      Extract Stacked State\n$IPM     EQU   X'B222'-X'B200'      Insert Program Mask\n$IVSK    EQU   X'B223'-X'B200'      Insert Virtual Storage Key\n$LAM     EQU   X'9A'                Load Access Multiply\n$LM      EQU   X'98'                Load Multiply\n$MVCL    EQU   X'0E'                Move Characters Long\n$MVCLE   EQU   X'A8'                Move Characters Long Extended\n$MVCS    EQU   X'DB'                Move to Secondary\n$PR      EQU   X'0101'-X'0100'      Program Return\n$PT      EQU   X'B228'-X'B200'      Program Transfer\n$SAR     EQU   X'B24E'-X'B200'      Store Access\n$SRP     EQU   X'F0'                Shift and Round Packed\n$STAM    EQU   X'9B'                Store Access Multiple\n$STCM    EQU   X'BE'                Store Characters under Mask\n$STM     EQU   X'90'                Store Multiple\n$SVC     EQU   X'0A'                Supervisor Call\n$TAR     EQU   X'B24C'-X'B200'      Test Access\n$TRAP2   EQU   X'01FF'-X'0100'      Trap (2-byte version)\n         EJECT\n***********************************************************************\n*                                                                     *\n*        Machine instruction attribute flags                          *\n*                                                                     *\n***********************************************************************\n         SPACE\n*---------------------------------------------------------------------*\n*        Flags in first attribute flag byte                           *\n*---------------------------------------------------------------------*\n          SPACE\nbitILGL   EQU   X'80'               Illegal or unsupported instruction\nbitCC     EQU   X'40'               Instruction sets condition code\nbitBR     EQU   X'20'               Instruction is a (executed?) branch\nbitAMODE  EQU   X'10'               Instruction alters addressing mode\nbitACCESS EQU   X'08'               Access register(s) used/modified\nbitPACKD  EQU   X'04'               Packed decimal instruction\nbitMVCX   EQU   X'02'               MVCK, MVCP or MVCS instruction\nbitALTER  EQU   X'01'               Instruction alters storage\n          SPACE\n*---------------------------------------------------------------------*\n*        Flags in second attribute flag byte                          *\n*---------------------------------------------------------------------*\n         SPACE\nbitRR     EQU   X'80'               RR format instruction\nbitRX     EQU   X'40'               RX format instruction\nbitRS     EQU   X'20'               RS format instruction\nbitSSI    EQU   X'10'               S/SI format instruction\nbitSS     EQU   X'08'               SS/SSE format instruction\nbitRXEF   EQU   X'04'               RXE/RXF format instruction\nbitIMDF   EQU   X'02'               Contains 8-bit immediate field\nbitIMREL  EQU   X'01'               Immediate and Relative instruction\n          SPACE\nbitSI     EQU   bitSSI+bitIMDF      SI format instruction\nbitRRE    EQU   bitRS+bitSSI        RRE format instruction\nbitRSI    EQU   bitRS+bitIMREL      RSI/RI format instruction\n          SPACE\n*---------------------------------------------------------------------*\n*        Flags in third attribute flag byte                           *\n*---------------------------------------------------------------------*\n          SPACE\nbitDBLR   EQU   X'80'               Double word register operand(s)\nbitDBLS   EQU   X'40'               Double word storage operand\nbitFULL   EQU   X'20'               Full word storage operand\nbitHALF   EQU   X'10'               Half word storage operand\nbitBYTE   EQU   X'08'               Single byte storage operand\nbitSHIFT  EQU   X'04'               Shift instruction\nbitMASK   EQU   X'02'               Instruction contains bit mask\nbitNOREF  EQU   X'01'               ddd(b) does NOT reference storage\n          SPACE\n*---------------------------------------------------------------------*\n*        Flags in fourth attribute flag byte                          *\n*---------------------------------------------------------------------*\n          SPACE\nbitDUMPR  EQU   X'80'               Dump all registers to SYSTRACE\nbitEX     EQU   X'40'               Instruction is EXECUTE (EX)\nbitFLOAT  EQU   X'20'               Floating point instruction\n         EJECT\n         PRINT NOGEN\n         CVT   DSECT=YES,PREFIX=NO  Communications Vector Table (CVT)\n         SPACE\n         IEFTIOT1 ,                 Task Input/Output Table (TIOT)\n         SPACE\n         IHAPSA ,                   Prefixed Save Area (PSA)\n         SPACE\n         IHASDWA ,                  System Diagnostics Work Area (SDWA)\n         SPACE\n         IKJTCB ,                   Task Control Block (TCB)\n         SPACE\n         DCBD  DSORG=QS,DEVD=DA     Data Control Block (DCB)\n         SPACE\n         IHADCBE ,                  Data Control Block Extension (DCBE)\n         SPACE\n         IEFZB4D0 ,                 DYNALLOC parameter dsects\nlenS99RB EQU   (S99RBEND-S99RB)     DYNALLOC request block length\n         SPACE\n         IEFZB4D2 ,                 DYNALLOC text unit keywords\n         PRINT GEN\n         EJECT\n         TRCTBLS ,                  TRACE390 parm table entries\n         SPACE 3\n         TrcFlags ,                 TRACE390 user flag values\n         SPACE 2\nCNT$FLD  DSECT ,\nCNT$OPCD DS    CL4                  Opcode\n         DS    C\nCNT$MNEM DS    CL5                  Assembler Mnemonic\n         DS    C\nCNT$ICNT DS    CL10                 Number of times executed\n         DS    C\nCNT$PCNT DS    CL6                  Percentage of total\n         DS    CL4\nCNT$LEN  EQU   *-CNT$FLD            Length\n         EJECT\n***********************************************************************\n*                                                                     *\n*   Title :                                                           *\n*        ESA/390 Assembler Trace Routine                              *\n*                                                                     *\n*   Module Identifiers :                                              *\n*        Source Name       - TRACE390                                 *\n*        Link Name         - TRACE390                                 *\n*        Entry Point       - TRACE390                                 *\n*        Module Attributes - Re-usable, Only-loadable,                *\n*                            Amode(31), Rmode(24).                    *\n*                                                                     *\n*   Credits :                                                         *\n*        Bernard Schoch, Comnet Computer Center                       *\n*        Debugged 1974/03/22 by Claude Schoch                         *\n*        Converted for 370 instructions and extended floating point   *\n*        instructions by Claude Schoch 1975/02/12.                    *\n*                                                                     *\n*        Enhanced and Supported by:                                   *\n*          Lionel Silva                                               *\n*          US Postal Data Center                                      *\n*          850 Cherry Avenue                                          *\n*          San Bruno, CA 94097-9330                                   *\n*          (415) 876-9142                                             *\n*                                                                     *\n*        Enhanced by:                                                 *\n*          Robert Ngan        (1987/09/10)                            *\n*          Environment Technical Support,                             *\n*          Databank Systems (NZ) Ltd.                                 *\n*          175 The Terrace,                                           *\n*          Wellington,                                                *\n*          New Zealand.                                               *\n*          (64) (4) 735-979                                           *\n*                                                                     *\n*        in the following areas:                                      *\n*          Support bimodal addressing.                                *\n*          Support 370/XA instructions.                               *\n*          Support programs running in AMODE=31.                      *\n*          Support programs (and data) above the 16M line.            *\n*          Support semi and non privileged X'B2' instructions.        *\n*          Trap storage alteration at user specified addresses.       *\n*          Restrict instructions printed to user supplied ranges.     *\n*          Add support for caller specified breakpoints.              *\n*          Optional tracing of DL/I calls.                            *\n*          Correct format of packed decimal operands for printing.    *\n*          Prevent instruction fetches off the end of the program.    *\n*          Trace program/subroutine call and return type branches.    *\n*          Print module identification data on call type branches.    *\n*          Gather program execution profile information.              *\n*          Count number of instructions executed in user defined      *\n*          ranges.                                                    *\n*                                                                     *\n*        Enhanced (and supported) by:                                 *\n*          Robert Ngan        (1999/10/04)                            *\n*          CSC Financial Services Group,                              *\n*          5525 LBJ Freeway (3rd Floor),                              *\n*          Dallas, TX 75240                                           *\n*                                                                     *\n*        in the following areas:                                      *\n*          Support access-register ASC mode and the use of access     *\n*          registers.                                                 *\n*          Support tracing of BAKR and PR instructions.               *\n*          Support the move-page facility.                            *\n*          Support string-instruction facility.                       *\n*          Support immediate-and-relative facility instructions.      *\n*          Support compare-and-move-extended facility instructions.   *\n*          Support the CHECKSUM instruction.                          *\n*          Support TRAP facility instructions (well, recognize them!) *\n*          Print BC, BCR and BRC instructions in extended mnemonic    *\n*          format.                                                    *\n*                                                                     *\n*        Original program source can be found in:                     *\n*          Appendix 2                                                 *\n*          A Compiler Generator                                       *\n*          by W M McKeeman, J J Horning and D B Wortman.              *\n*          Prentice Hall. (c) 1970.                                   *\n*          Library of Congress Catalog Number 76-117205               *\n*                                                                     *\n*   Function :                                                        *\n*        This routine traces the execution of another program at the  *\n*        assembler instruction level.                                 *\n*                                                                     *\n*   Reporting Problems :                                              *\n*        Bug reports should be emailed to one of the follow accounts: *\n*            Robert_Ngan@csc.com                                      *\n*                                                                     *\n***********************************************************************\n         EJECT\n***********************************************************************\n*                                                                     *\n*   Implementation Notes :                                            *\n*        Suppression of tracing internal DL/I call logic was added    *\n*        to prevent TRACE390 disabling itself when DL/I logic used    *\n*        unsupported instructions (1990/04).                          *\n*        Note that tracing of internal DL/I logic (both in BMP and    *\n*        batch DL/I modes) has been tested successfully with v3r1 of  *\n*        TRACE390 under IMS v5r1 (1999/10).                           *\n*                                                                     *\n*        The ASMTDLI/AIBTDLI interfaces are dynamically loaded so     *\n*        as to match the version in the current environment.          *\n*                                                                     *\n*        Handling of X'01' prefixed instructions (PR/UPT/TRAP2) was   *\n*        kludged since there are not that many to handle. If more of  *\n*        these codes are ever used, the logic will need to be         *\n*        rewritten.                                                   *\n*                                                                     *\n*        MVPG abends with a S0C4 when executed in primary ASC mode    *\n*        when issued from 'Execute1'. Enabling bitACCESS for this     *\n*        instruction (so it is issued from 'Execute2') corrects this  *\n*        problem.                                                     *\n*        I assume that the access registers are used (in primary ASC  *\n*        mode) for what the \"Principles of Operation\" describes as    *\n*        \"additional address translation\" within MVPG.                *\n*                                                                     *\n*        The End9nn/Retnnn logic would be handled cleaner by using a  *\n*        RESUME PROGRAM instruction, however I'm not sure how         *\n*        prevalent support for RP is at this time (1999/10).          *\n*                                                                     *\n*   Restrictions (and known bugs) :                                   *\n*        Does not support the following instruction types:            *\n*         - Privileged instructions                                   *\n*         - Vector instructions                                       *\n*         - Binary floating point instructions                        *\n*         - Square-root facility instructions                         *\n*         - Subspace-group facility instructions                      *\n*                                                                     *\n*        Storage altered by the following instructions do not trigger *\n*        watchpoint exits:                                            *\n*         - SVC                                                       *\n*         - PC                                                        *\n*         - UPT                                                       *\n*         - MVPG                                                      *\n*                                                                     *\n*        Watchpoints are only triggered by (non-SVC) instructions     *\n*        executed under the control of TRACE390, therefore if DL/I    *\n*        call tracing is not enabled, storage altered within DL/I     *\n*        logic will not trigger the watchpoint exit.                  *\n*                                                                     *\n*        Currently, only the ASMTDLI and AIBTDLI interfaces are       *\n*        recognized as entry into DL/I (CBLTDLI and CEETDLI support   *\n*        needs to be added).                                          *\n*                                                                     *\n*        If tracing is terminated when the local stack (BAKR_Stack)   *\n*        is not empty, ESTA instruction to get the return PSW address *\n*        or the branch address will get values inside TRACE390.       *\n*                                                                     *\n*        We should check when BAKR_Stack overflows and take some      *\n*        appropriate action, this has not been implemented yet!       *\n*                                                                     *\n*   To Do List:                                                       *\n*        Add support for binary floating point instructions.          *\n*        Add support for the RESUME PROGRAM (RP) instruction.         *\n*                                                                     *\n***********************************************************************\n         TITLE 'Change Log'\n***********************************************************************\n*                                                                     *\n*   2005/04/06                                                        *\n*        Correct STAM, TAR and EAR as instructions which explicitly   *\n*        reference access registers.                                  *\n*        Mark PT instruction as unsupported.                          *\n*                                                                     *\n*   1999/10/21                                                        *\n*        Add support for COMPRESSION CALL (CMPSC) instruction.        *\n*                                                                     *\n*   1999/10/19                                                        *\n*        Zero AR15-AR00 at label ExER020 with LAM, not STAM!          *\n*                                                                     *\n*   1999/10/18                                                        *\n*        Use SR to zero PSW condition code bits, SLR actually sets    *\n*        condition code 2, not 0!                                     *\n*        Add routine to handle IPM instruction, since condition code  *\n*        bits are NOT restored by either Execute1 or Execute2.        *\n*                                                                     *\n***********************************************************************\n         TITLE 'Enterprise System Architecture/390 Instruction Trace'\n         SYSSTATE ASCENV=AR\n&AsmDate SETC  '&SYSDATC'(1,4).'/'.'&SYSDATC'(5,2).'/'.'&SYSDATC'(7,2)\n         SPACE\nTRACE390 CSECT ,\nTRACE390 AMODE 31                   So we can access stuff above 16M\nTRACE390 RMODE 24                   Required for tracing AMODE=24 logic\n         USING TRACE390,R15\n         J     INIT\n         DC    AL1(lenID)           Length of identification data\n         DC    CL9'TRACE390'        Program id\n         DC    CL12'v03.r01.m02'    Version\n         DC    CL9'HLA&SYSVER'      HL Assembler version\n         DC    CL11'&AsmDate'       Assembly date\n         DC    CL5'&SYSTIME'        Assembly time\nlenID    EQU   (*-TRACE390)-4-1\n         SPACE\n*---------------------------------------------------------------------*\n*        Save area                                                    *\n*---------------------------------------------------------------------*\n         SPACE\nSAVEAREA DC    18F'0'               Register save area\n         EJECT\n***********************************************************************\n*                                                                     *\n*        Program initialization                                       *\n*                                                                     *\n***********************************************************************\n         SPACE\nINIT     DS    0H\n         LTR   R01,R01              Q. Parameter list passed?\n         BZR   R14                  N. Do nothing\n         STM   R00,R15,SAVEAREA     Y. Save all callers registers\n         LM    R07,R10,aBASE           Load our base registers\n         DROP  R15\n         SPACE\n         USING TRACE390,R07,R08,R09 Load module base registers\n         USING Tr390$WS,R10         ...\n         LA    R13,SAVEAREA         Load our save area pointer\n         SPACE\n         STAM  AR00,AR15,TraceARs   Save callers access registers\n         IAC   R02                  Save callers ASC mode\n         STCM  R02,B'0010',TraceASC ...\n         NI    TraceASC,X'03'       ... and mask out any garbage\n         SPACE\n         NI    TrcFlag1,Trc$NoDD    Initialise status flags\n         NI    TrcFlag2,255-Trc$NoIH ...\n***                                 Set default processing flags\n         MVI   UsrFlag1,Flg$PrHdr+Flg$Print ...\n         MVI   UsrFlag2,0           ...\n         MVI   UsrFlag3,0           ...\n         MVI   UsrFlag4,0           ...\n         SPACE\n         LR    R03,R01              Get parmlist pointer\n         LA    R15,VERIFY           Parmlist verification routine addr\n         O     R15,BitZero          Invoke it in AMODE(31)\n         BASSM R14,R15              Go validate parmlist\n         SPACE\n         ZAP   IRCOUNT,cpZero       Zero instructions counted this run\n         ICM   R15,B'1111',AddrFlgs Q. Address of flags supplied?\n         JZ    Init010              N. Use default flags\n         MVC   UsrFlags,0(R15)      Y. Load user supplied flags\n         SPACE\nInit010  DS    0H\n         MVC   TraceAMODE(1),SAVEAREA+4*14 Top byte of callers R14\n         NI    TraceAMODE,X'80'     Clear all but high order bit\n         SPACE\n         ESTAEX MF=(E,cplESTAEX)\n         LTR   R00,R15              Q. Abend exit established?\n         JZ    Init020              Y. Continue\n         BRAS  R14,HexToEBC         N. Convert return code to display\n         STCM  R01,B'0011',cMsg006+28\n         LA    R02,Msg006              Point to WTO message\n         J     WTOABEND                Go issue WTO and ABEND\n         SPACE\nInit020  DS    0H\n         L     R11,SAVEAREA+(4*14)  Address of 1st instruction traced\n         MVC   DDNAME,SYSTRACE      Reset output ddname to default\n         BRAS  R14,SetFlags         Process user flags\n         SPACE\n*---------------------------------------------------------------------*\n*        Load ASMTDLI and AIBTDLI if not already loaded               *\n*---------------------------------------------------------------------*\n         SPACE\n         TM    TrcFlag2,Trc$A2DL    Q. Tried to load ASMTDLI before?\n         JNZ   Init030              Y. Don't do it again\n         OI    TrcFlag2,Trc$A2DL    N. Indicate load attempted\n         LOAD  EPLOC=ASMTDLI,ERRET=Init030\n         ST    R00,ASM2DLI             Save entry point address\n         SPACE\n         LOAD  EPLOC=AIBTDLI,ERRET=Init030\n         ST    R00,AIB2DLI             Save entry point address\n         SPACE\n*---------------------------------------------------------------------*\n*        Copy the registers of the traced program into 'TraceGPRs'    *\n*---------------------------------------------------------------------*\n         SPACE\nInit030  DS    0H\n         MVC   TraceGPRs(64),SAVEAREA Copy traced programs registers\n         BRAS  R14,TimeStamp        Obtain formatted date and time\n         TM    UsrFlag1,Flg$Print   Q. Printing enabled?\n         JZ    MainLoop             N. Nothing to print then\n         BRAS  R12,DumpGPRs         Y. Dump the general registers\n         BRAS  R12,DumpARs             Dump the access registers\n         BRAS  R12,DumpFPRs            Dump floating point registers\n         J     MainLoop\n         SPACE 3\naBASE    DC    A(TRACE390)          Module base registers\n         DC    A(TRACE390+4096)     ...\n         DC    A(TRACE390+8192)     ...\n         DC    A(Tr390$WS)          Address of trace routine data\n         EJECT ,\n***********************************************************************\n*                                                                     *\n*        Validate user parameters                                     *\n*                                                                     *\n***********************************************************************\n         SPACE\nVERIFY   DS    0H\n         XC    ParmList,ParmList    Clear parmlist save area\n         LHI   R15,-1               High values = default parameters\n         CLR   R15,R03              Q. Use default parameters?\n         JE    Ver990               Y. Nothing more to do here\n         BCTR  R15,0                N. Minus one = -2\n         CLR   R15,R03                 Q. Defaults with generated DSN?\n         JNE   Ver010                  N. Go validate parameters\n         OI    UsrFlag2,Flg$GDSN       Y. Indicate generated DSN\n         J     Ver990                     Nothing more to do here\n         SPACE\n*---------------------------------------------------------------------*\n*        Validate user flags                                          *\n*---------------------------------------------------------------------*\n         SPACE\nVer010   DS    0H\n         ICM   R15,B'1111',AddrFlgs-ParmList(R03)\n*                                   Q. User flags supplied?\n         JZ    Ver100               N. Nothing to check then\n         N     R15,SevenFs          Y. Q. User flags really supplied?\n         JZ    Ver990                  N. Must be null last parameter\n         ST    R15,AddrFlgs            Y. Save address of flags\n         ICM   R00,B'0011',2(R15)         Q. Are last 2 bytes zeros?\n         JZ    Ver020                     Y. Flags are ok then\n         L     R00,0(,R15)                N. Load flag word\n         BRAS  R14,HexToEBC                  Convert to display\n         STM   R00,R01,cMsg001+59            Place into WTO message\n         LA    R02,Msg001                    Point to WTO message\n         J     WTOABEND                      ... and go issue WTO\n         SPACE\nVer020   DS    0H\n         TM    AddrFlgs-ParmList(R03),X'80'\n*                                   Q. End of parmlist?\n         JO    Ver990               N. Nothing more to check then\n         SPACE\n*---------------------------------------------------------------------*\n*        Validate print-range table                                   *\n*---------------------------------------------------------------------*\n         SPACE\nVer100   DS    0H\n         ICM   R15,B'1111',PrRngTbl-ParmList(R03)\n*                                   Q. Print range table supplied?\n         JZ    Ver200               N. Nothing to check then\n         N     R15,SevenFs          Y. Q. Range table really supplied?\n         JZ    Ver990                  N. Must be null end of list\n         ST    R15,PrRngTbl            Y. Save table address\n         USING PrtEntry,R15\n         SPACE\nVer110   DS    0H\n         LM    R01,R02,PrtStart     Load print range\n         N     R01,SevenFs          Ensure top bit of start range clear\n         CLR   R01,R02              Q. R01 higher than R02?\n         JH    Ver120               Y. Invalid print range table\n         LTR   R02,R02              Q. Q. End address negative?\n         JM    Ver130                  Y. Bit zero set is invalid\n         TM    PrtEntry,X'80'          N. Q. Last print range?\n         JO    Ver190                     Y. This table validated\n         LA    R15,PrtEntry+Prt$ELen      N. Point to next table entry\n         J     Ver110\n         SPACE\nVer120   DS    0H\n         MVC   cMsg002+15(L'CC$PRT),CC$PRT\n         J     Ver900\n         SPACE\nVer130   DS    0H\n         MVC   cMsg012+23(L'CC$PRT),CC$PRT\n         J     Ver910\n         SPACE\nVer190   DS    0H\n         TM    PrRngTbl-ParmList(R03),X'80'\n*                                   Q. End of parmlist?\n         JO    Ver990               N. Nothing more to check then\n         SPACE\n*---------------------------------------------------------------------*\n*        Validate break-point table                                   *\n*---------------------------------------------------------------------*\n         SPACE\nVer200   DS    0H\n         ICM   R15,B'1111',BrkPtTbl-ParmList(R03)\n*                                   Q. Break point table supplied?\n         JZ    Ver300               N. Nothing to check then\n         N     R15,SevenFs          Y. Q. Table really supplied?\n         JZ    Ver990                  N. Must be null last parameter\n         ST    R15,BrkPtTbl            Y. Save table address\n         USING BptEntry,R15\n         SPACE\nVer210   DS    0H\n         L     R01,BptEXIT           Load breakpoint exit address\n         N     R01,SevenFs           Q. Valid address?\n         JZ    Ver220                N. Go complain about this\n         IC    R01,0(,R01)           Y. Attempt access of exit address\n         TM    BptEntry,X'80'           Q. Last entry in table\n         JO    Ver230                   Y. Breakpoint table validated\n         LA    R15,BptEntry+Bpt$ELEN    N. Point to next table entry\n         J     Ver210\n         SPACE\nVer220   DS    0H\n         MVC   cMsg013+7(L'CC$BPT),CC$BPT\n         J     Ver920\n         SPACE\nVer230   DS    0H\n         TM    BrkPtTbl-ParmList(R03),X'80'\n*                                   Q. End of parmlist?\n         JO    Ver990               N. Nothing more to check then\n         SPACE\n*---------------------------------------------------------------------*\n*        Validate watch-point table                                   *\n*---------------------------------------------------------------------*\n         SPACE\nVer300   DS    0H\n         ICM   R15,B'1111',WatchTbl-ParmList(R03)\n*                                   Q. Watch point table supplied?\n         JZ    Ver400               N. Nothing to check then\n         N     R15,SevenFs          Y. Q. Table really suppled?\n         JZ    Ver990                  N. Must be null last parameter\n         ST    R15,WatchTbl            Y. Save table address\n         USING WptEntry,R15\n         SPACE\nVer310   DS    0H\n         LM    R01,R02,WptStart     Load watchpoint addresses\n         N     R01,SevenFs          Clear top bit of address\n         CLR   R01,R02              Q. R01 higher than R02?\n         JH    Ver320               Y. Invalid watchpoint entry\n         LTR   R02,R02              N. Q. Top bit set in R02?\n         JM    Ver330                  Y. Top bit set is invalid\n         L     R01,WptExit             N. Load exit address\n         N     R01,SevenFs                Q. Exit address valid?\n         JZ    Ver340                     N. Invalid watchpoint entry\n         IC    R01,0(,R01)                Y. S0C4 if EPA not readable\n         TM    WptStart,X'80'                Q. Last entry in table\n         JO    Ver390                        Y. Table validated\n         LA    R15,WptEntry+Wpt$ELen         N. Point to next entry\n         J     Ver310                           ... go process it\n         SPACE\nVer320   DS    0H\n         MVC   cMsg002+15(L'CC$WPT),CC$WPT\n         J     Ver900\n         SPACE\nVer330   DS    0H\n         MVC   cMsg012+23(L'CC$WPT),CC$WPT\n         J     Ver910\n         SPACE\nVer340   DS    0H\n         MVC   cMsg013+7(L'CC$WPT),CC$WPT\n         J     Ver920\n         SPACE\nVer390   DS    0H\n         TM    WatchTbl-ParmList(R03),X'80'\n*                                   Q. End of parmlist?\n         JO    Ver990               N. Nothing more to check then\n         SPACE\n*---------------------------------------------------------------------*\n*        Validate execution profile table                             *\n*---------------------------------------------------------------------*\n         SPACE\nVer400   DS    0H\n         ICM   R15,B'1111',EProfTbl-ParmList(R03)\n*                                   Q. Profiler point table supplied?\n         JZ    Ver500               N. Nothing to check then\n         N     R15,SevenFs          Y. Q. Table really supplied?\n         JZ    Ver990                  N. Must be null last parameter\n         ST    R15,EProfTbl            Y. Save table address\n         USING PrfEntry,R15\n         SPACE\nVer410   DS    0H\n         L     R00,PrfTable         Get profiler data table address\n         N     R00,SevenFs          Q. Address bits zero?\n         JNZ   Ver420               N. Assume address is ok\n         LA    R02,Msg011           Y. Point to WTO message\n         MVC   cMsg011+40(L'CC$PROF),CC$PROF\n         J     WTOABEND                Go issue WTO and ABEND\n         SPACE\nVer420   DS    0H\n         L     R00,PrfIntvl         Profiler range sub-interval size\n         CHI   R00,4                Q. Sub-interval at least four?\n         JNL   Ver430               Y. Sub-interval size ok, continue\n         BRAS  R14,HexToEBC         N. Convert size to display\n         STM   R00,R01,cMsg010+32      place into WTO message\n         LA    R02,Msg010              Point to WTO text\n         J     WTOABEND                Go issue WTO and ABEND\n         SPACE\nVer430   DS    0H\n         LM    R01,R02,PrfStart     Load profile range\n         CLR   R01,R02              Q. R01 higher than R02?\n         JH    Ver440               Y. Invalid profile range entry\n         LTR   R02,R02              N. Q. Bit zero of address set?\n         JM    Ver450                  Y. Address in invalid\n         LTR   R02,R01                 N. Q. Bit zero of address set?\n         JM    Ver450                     Y. Address in invalid\n         TM    PrfEntry,X'80'             N. Q. Last entry in table?\n         JO    Ver490                        Y. Table validated\n         LA    R15,PrfEntry+PRF$ELEN         N. Point to next entry\n         J     Ver410                           ... go process it\n         SPACE\nVer440   DS    0H\n         MVC   cMsg002+15(L'CC$PROF),CC$PROF\n         J     Ver900\n         SPACE\nVer450   DS    0H\n         MVC   cMsg012+23(L'CC$PROF),CC$PROF\n         J     Ver910\n         SPACE\nVer490   DS    0H\n         TM    EProfTbl-ParmList(R03),X'80'\n*                                   Q. End of parmlist?\n         JO    Ver990               N. Nothing more to check then\n         SPACE\n*---------------------------------------------------------------------*\n*        Validate instruction count table                             *\n*---------------------------------------------------------------------*\n         SPACE\nVer500   DS    0H\n         ICM   R15,B'1111',InstrTbl-ParmList(R03)\n*                                   Q. Got instruction count table?\n         JZ    Ver590               N. Nothing to check then\n         N     R15,SevenFs          Y. Q. Really got count table?\n         JZ    Ver990                  N. Must be null last parameter\n         ST    R15,InstrTbl            Y. Save table address\n         USING In#Entry,R15\n         SPACE\nVer510   DS    0H\n         L     R00,In#Table         Count table address\n         N     R00,SevenFs          Q. Address zero?\n         JNZ   Ver520               N. Assume its ok\n         LA    R02,Msg011              Point to WTO text\n         MVC   cMsg011+40(L'CC$ICNT),CC$ICNT\n         J     WTOABEND                Go issue WTO and ABEND\nVer520   DS    0H\n         LM    R01,R02,In#Start     Load instruction count range\n         CLR   R01,R02              Q. R01 higher than R02?\n         JH    Ver530               Y. Invalid profile range entry\n         LTR   R02,R02              N. Q. Top bit of address set?\n         JM    Ver540                  Y. Address is invalid\n         LTR   R02,R01                 N. Q. Top bit of address set?\n         JM    Ver540                     Y. Address is invalid\n         TM    In#Entry,X'80'             N. Q. Last entry in table?\n         JO    Ver590                        Y. Table validated\n         LA    R15,In#Entry+IN#$ELEN         N. Point to next entry\n         J     Ver510                           ... go process it\n         SPACE\nVer530   DS    0H\n         MVC   cMsg002+15(L'CC$ICNT),CC$ICNT\n         J     Ver900\n         SPACE\nVer540   DS    0H\n         MVC   cMsg012+23(L'CC$ICNT),CC$ICNT\n         J     Ver910\n         SPACE\nVer590   DS    0H\n         TM    InstrTbl-ParmList(R03),X'80'\n*                                   Q. End of parmlist?\n         JO    Ver990               N. Nothing more to check then\n         DROP  R15\n         SPACE\n*---------------------------------------------------------------------*\n*        Validate user DDname                                         *\n*---------------------------------------------------------------------*\n         SPACE\nVer600   DS    0H\n         ICM   R15,B'1111',aUserDDN-ParmList(R03)\n*                                   Q. User supplied DDNAME present?\n         JNM   Ver610               N. Nothing to check then\n         N     R15,SevenFs          Y. Q. Really got DDNAME?\n         JZ    Ver990                  N. Must be null last parameter\n         ST    R15,aUserDDN            Y. Save ddname address\n         TRT   0(8,R15),DDNchars          Q. DDname OK?\n         JZ    Ver990                     Y. Probably (not definitely)\n***                                       N. Put bad ddname in message\n         MVC   cMsg003+29(L'DCBDDNAM),0(R15)\n         LA    R02,Msg003                    Point to WTO text\n         J     WTOABEND                      Go issue WTO\n         SPACE\nVer610   DS    0H\n         LA    R02,Msg004           Parameter list is too long\n         J     WTOABEND             Go issue WTO and ABEND\n         SPACE\n*---------------------------------------------------------------------*\n*        Invalid range entry in table                                 *\n*---------------------------------------------------------------------*\n         SPACE\nVer900   DS    0H\n         LR    R00,R01              Start address\n         BRAS  R14,HexToEBC         Convert to display\n         STM   R00,R01,cMsg002+46   ...\n         LR    R00,R02              End address\n         BRAS  R14,HexToEBC         Convert to display\n         STM   R00,R01,cMsg002+63   ...\n         LA    R02,Msg002           Address of WTO text\n         J     WTOABEND\n         SPACE\n*---------------------------------------------------------------------*\n*        Address with bit zero set is invalid                         *\n*---------------------------------------------------------------------*\n         SPACE\nVer910   DS    0H\n         LR    R00,R02              Address in question\n         BRAS  R14,HexToEBC         Convert to display\n         STM   R00,R01,cMsg012+44   ...\n         LA    R02,Msg012           Address of WTO text\n         J     WTOABEND\n         SPACE\n*---------------------------------------------------------------------*\n*        EPA of Exit is zero                                          *\n*---------------------------------------------------------------------*\n         SPACE\nVer920   DS    0H\n         LR    R00,R15              Address of invalid entry\n         BRAS  R14,HexToEBC         Convert to display\n         STM   R00,R01,cMsg013+36   ...\n         LA    R02,Msg013           Address of WTO text\n         J     WTOABEND\n         SPACE\n*---------------------------------------------------------------------*\n*        Parameter list validated, return to caller                   *\n*---------------------------------------------------------------------*\n         SPACE\nVer990   DS    0H\n         BSM   0,R14                Return to caller\n         SPACE 3\nCC$PRT   DC    CL11'Print Range'\nCC$BPT   DC    CL11'Break Point'\nCC$WPT   DC    CL11'Watch Point'\nCC$PROF  DC    CL11'Profiler   '\nCC$ICNT  DC    CL11'Instr Count'\n         EJECT\n***********************************************************************\n*                                                                     *\n*        This is invoked if TRACE390 ABENDs                           *\n*        All it does is attempt to close the SYSTRACE dataset         *\n*                                                                     *\n***********************************************************************\n         SPACE\nRECOVER  DS    0H\n         CHI   R00,12               Q. SDWA provided?\n         JNE   Rec010               Y. Attempt to close systrace\n         SLR   R15,R15              N. Take ABEND with no action\n         BSM   0,R14\n         SPACE\nRec010   DS    0H\n         LR    R11,R14              Save return address\n         LM    R07,R10,0(R02)       Reload mainline base registers\n         SPACE\n         LR    R03,R01              Save pointer to SDWA\n         USING SDWA,R03             ... and set base\n         SPACE\n         IAC   R04                  Q. In primary ASC mode?\n         JZ    Rec020               Y. We're good as is\n         SAC   0                    N. Switch to primary ASC mode\n         SPACE\nRec020   DS    0H\n         USING IHADCB,dcbTRACE\n         TM    DCBOFLGS,DCBOFOPN    Q. Output dataset open?\n         JZ    Rec999               N. No need to close it then\n         TM    TrcFlag2,Trc$EPUT    Y. Q. ESTAEX PUT attempted already?\n         JO    Rec060                  Y. Don't try it again\n         OI    TrcFlag2,Trc$EPUT       N. Say ESTAEX PUT in progress\n         LA    R15,ExecIns2               Executed instruction address\n         TM    bAttribute1,bitACCESS      Q. Access registers involved?\n         JO    Rec030                     Y. Got right instruction\n         CLI   TraceASC,ARmode            N. Q. In AR ASC mode?\n         JE    Rec030                        Y. Access registers used\n         LA    R15,ExecIns1                  N. No access registers\n         SPACE\nRec030   DS    0H\n         LA    R00,6(,R15)          Maximum address of NSI\n         L     R14,SDWANXT1         Get address of NSI\n         N     R14,SevenFs          Clear AMODE indicator\n         CLR   R14,R15              Q. Possibly ABEND at ExecInsx?\n         JL    Rec040               N. Not a possibility\n         CLR   R14,R00              Y. Q. Really at ExecInsN?\n         JH    Rec040                  N. Must be some where else\n         L     R00,SaveRegs+4*11       Y. Traced instruction pointer\n         O     R00,TraceAMODE             OR in addressing mode\n         BRAS  R14,HexToEBC               Convert to display hex\n         STM   R00,R01,STAEaddr           Bung into print line\n         LA    R00,STAEMSG2               Load message address\n         J     Rec050                     and go put line\n         SPACE\nRec040   DS    0H\n         L     R00,SDWAEC1          Get first half of abending PSW\n         BRAS  R14,HexToEBC         Convert to display hex\n         STM   R00,R01,STAEPSW      ... and store in output line\n         L     R00,SDWAEC1+4        Get second half of abending PSW\n         BRAS  R14,HexToEBC         Convert to display hex\n         STM   R00,R01,STAEPSW+9    ... and store in output line\n         LA    R00,STAEMSG1         Load message address\n         SPACE\nRec050   DS    0H\n         PUT   dcbTRACE,(0)         Attempt final PUT\n         NI    TrcFlag2,255-Trc$EPUT Reset 'PUT in progress' flag\n         SPACE\nRec060   DS    0H\n         TM    TrcFlag2,Trc$ECLS    Q. ESTAEX CLOSE attempted already?\n         JO    Rec999               Y. Don't try it again\n         OI    TrcFlag2,Trc$ECLS    N. Say ESTAEX CLOSE in progress\n         MVI   cplCLOSE,X'80'          Indicate single entry in list\n         CLOSE (dcbTRACE),MODE=31,MF=(E,cplCLOSE)\n         NI    TrcFlag2,255-Trc$ECLS   Reset 'CLOSE in progress' flag\n         SPACE\nRec999   DS    0H\n         SETRP WKAREA=(R03),DUMP=YES,RC=0\n         DROP  R03\n         LR    R14,R11              Reload return address\n         BR    R14                  and return control to RTM\n         SPACE\n         LTORG ,\n         EJECT ,\n***********************************************************************\n*                                                                     *\n*        Binary to EBCDIC hexadecimal conversion routine              *\n*                                                                     *\n***********************************************************************\n         SPACE\nHexToEBC DS    0H\n         ST    R00,WorkDblW         Store the word to be converted\n         UNPK  WorkCL9,WorkCL5      Spread out the hex digits\n         TR    WorkDblW,HexChar-C'0' Translate to hex characters\n         LM    R00,R01,WorkDblW     Load the results\n         BSM   0,R14                and return\n         EJECT\n***********************************************************************\n*                                                                     *\n*        Main loop executed for each instruction                      *\n*                                                                     *\n***********************************************************************\n         SPACE\nMainLoop DS    0H\n         TM    TrcFlag1,Trc$EndT    Q. Trace terminated by an exit?\n         JO    End000               Y. End trace\n         LA    R01,Main010          N. Set addressing mode to that of\n         O     R01,TraceAMODE          ... the traced program\n         BSM   0,R01                   ...\n         SPACE\nMain010  DS    0H\n         MVC   OldAMODE(1),TraceAMODE Save current addressing mode\n         LA    R11,0(,R11)          Ensure high order bit/byte cleared\n         CLR   R11,R07              Q. Reached entry to TRACE390?\n         JE    End000               Y. Go end trace\n         SPACE\n*---------------------------------------------------------------------*\n*        Check for breakpoint                                         *\n*---------------------------------------------------------------------*\n         SPACE\n         ICM   R15,B'1111',BrkPtTbl Q. Breakpoint table available?\n         JZ    Main060              N. No break points active\n         LA    R02,Main020          Y. Load BSM address\n         O     R02,BitZero             Indicate AMODE=31\n         BSM   0,R02                   Search table in AMODE=31\n         USING BptEntry,R15\n         SPACE\nMain020  DS    0H\n         L     R02,BptADDR          Load a breakpoint address\n         N     R02,SevenFs          Ensure top bit is clear\n         CLR   R02,R11              Q. Have we reached a breakpoint?\n         JE    Main030              Y. Go call breakpoint exit\n         TM    BptEntry,X'80'       N. Q. Last entry in table?\n         JO    Main050                 Y. Nothing else to check then\n         LA    R15,BptEntry+Bpt$ELEN   N. Point to next entry\n         J     Main020                    and go check it out\n         SPACE\n*---------------------------------------------------------------------*\n*        Breakpoint reached, call breakpoint exit                     *\n*---------------------------------------------------------------------*\n         SPACE\nMain030  DS    0H\n         O     R02,TraceAMODE       Put AMODE into instruction pointer\n         ST    R02,InstrPointer     Store it where exit expects it\n         XC    StoreAddr,StoreAddr  Indicate not a storage exception\n         OI    TrcFlag1,Trc$Exit    Indicate user exit active\n         L     R15,BptEXIT          AMODE/Address of breakpoint exit\n         DROP  R15\n         LA    R01,plUserExit       Point to exit parameter list\n         BASSM R14,R15              Invoke breakpoint routine\n         LTR   R15,R15              Q. Good return code from exit?\n         JZ    Main040              Y. Keep going\n         OI    TrcFlag1,Trc$EndT    N. Indicate termination by exit\n         SPACE\nMain040  DS    0H\n         NI    TrcFlag1,255-Trc$Exit User exit no longer active\n         BRAS  R12,CloseDS          Spin off output if required\n         BRAS  R14,SetFlags         Re-process user flags\n         CL    R02,InstrPointer     Q. AMODE/instruction ptr changed?\n         JE    Main050              N. Nothing to reset then\n***                                 Y. Save new addressing mode\n         MVC   TraceAMODE(1),InstrPointer ...\n         NI    TraceAMODE,X'80'        Only need high order bit\n         LR    R15,R11                 Save old instruction pointer\n         NI    InstrPointer,X'7F'      Clear out amode bit and\n         L     R11,InstrPointer        ... load new instruction pointer\n         CLR   R11,R15                 Q. Instruction pointer changed?\n         JNE   MainLoop                Y. Go set (new) AMODE and check\n*                                         ... for another breakpoint\n         SPACE\nMain050  DS    0H\n         LA    R15,Main060          Switch back to the traced program's\n         O     R15,TraceAMODE       ... addressing mode and continue\n         BSM   0,R15                ...\n         SPACE\n*---------------------------------------------------------------------*\n*        Get instruction attributes                                   *\n*---------------------------------------------------------------------*\n         SPACE\nMain060  DS    0H\n         NI    TrcFlag1,255-Trc$ModCall Turn off ID string present flag\n         MVC   OldAMODE(1),TraceAMODE Save initial AMODE for printing\n         MVC   OldRegs(4*16),TraceGPRs Save old registers for EvalXBD\n         MVC   XCell+2(4),NopInstr  Pad XCell with NOPs\n         MVC   XCell(2),0(R11)      Fetch first 2 bytes of instruction\n         SLR   R01,R01              Clear R01\n         IC    R01,XCell            The instruction code\n         L     R15,aOpIndex         Instruction index address\n         SPACE\n*---------------------------------------------------------------------*\n*        Check for 2 byte instruction codes (x'01'/x'B2'/x'A7' only)  *\n*---------------------------------------------------------------------*\n         SPACE\n         CLI   XCell,$B2            Q. x'B2' type instruction?\n         JNE   Main070              N. Bif not\n         IC    R01,XCell+1          Y. 2nd byte of instruction code\n         L     R15,aB2index            x'B2' instruction index address\n         J     Main090\n         SPACE\nMain070  DS    0H\n         CLI   XCell,$A7            Q. x'A7' type instruction?\n         JNE   Main080              N. Bif not\n         IC    R01,XCell+1          Y. 2nd byte of instruction code\n         N     R01,OOOOOOOF            Isolate low order nybble\n         L     R15,aA7index            x'A7' instruction index address\n         J     Main090\n         SPACE\nMain080  DS    0H\n         CLI   XCell,$01            Q. x'01' type instruction?\n         JNE   Main090              N. First byte identifies opcode\n         IC    R01,XCell+1          Y. 2nd byte of instruction code\n         L     R15,a01index            x'01' instruction index address\n         SPACE\nMain090  DS    0H\n         SLL   R01,1                Multiply by 2 for entry length\n         LH    R01,0(R01,R15)       The instruction index\n         L     R15,aOpFlags         Instruction attribute flags address\n         L     R00,0(R01,R15)       The instruction attribute flags\n         ST    R00,bAttributes      Save the flags\n         TM    bAttribute1,bitILGL  Q. Instruction illegal?\n         JO    ILGLOP               Y. Go print message and quit\n         SPACE\n*---------------------------------------------------------------------*\n*        Move actual instruction into 'XCell'                         *\n*        Note that instruction bytes are fetched 2 at a time to       *\n*        prevent ABEND S0C4's if the instruction is less than 6 bytes *\n*        long and it is the last instruction in a load module that    *\n*        ends at the end of a page boundary (and the next page is not *\n*        accessible).                                                 *\n*---------------------------------------------------------------------*\n         SPACE\n         TM    bAttribute2,bitRR    Q. RR type instruction?\n         JZ    Main100              N. Go get rest of instruction\n         CLC   XCell(2),ABEND       Y. Q. ABEND SVC instruction?\n         JNE   Main110                 N. Continue\n         OI    TrcFlag1,Trc$EndT       Y. Indicate end of trace\n         J     End000                     and return control to caller\n         SPACE\nMain100  DS    0H\n         MVC   XCell+2(2),2(R11)    Get next two bytes\n         TM    bAttribute2,bitSS    Q. SS(E) type instruction?\n         JZ    Main110              N. Got all of instruction\n         MVC   XCell+4(2),4(R11)    Y. Get last two bytes\n         SPACE\n*---------------------------------------------------------------------*\n*        Call appropriate routine to execute instruction              *\n*---------------------------------------------------------------------*\n         SPACE\nMain110  DS    0H\n         TM    bAttribute1,bitBR    Q. Branch (or executed branch)?\n         JZ    Main120              N. Process standard instruction\n         TM    bAttribute4,bitEX    Y. Q. EXECUTE instruction?\n         JO    ExOP                    Y. Go to the EXECUTE processor\n         BRAS  R14,BrProc              N. Call the branch processor\n         J     Main200\n         SPACE 2\nMain120  DS    0H\n         MVC   ExecIns1,XCell       Parameters for execute routine\n         LA    R05,bAttributes      Load address of flags\n         BRAS  R03,ExecInst         Call the execute routine\n         SPACE\n*---------------------------------------------------------------------*\n*        Update condition codes if then could have changed            *\n*---------------------------------------------------------------------*\n         SPACE\n         TM    bAttribute1,bitCC    Q. Can condition codes change?\n         JZ    Main200              N. Not a possibility\n         SRL   R00,4                Y. Shift condition code into\n         STCM  R00,B'1000',TraceCC     ... bits 6-7 and save\n         EJECT\n*---------------------------------------------------------------------*\n*        Post instruction-execution processing                        *\n*---------------------------------------------------------------------*\n         SPACE\nMain200  DS    0H\n         TM    UsrFlag1,Flg$PrCurInst Q. Print this instruction?\n         JO    Main230              Y. Go print it\n         TM    UsrFlag1,Flg$Print   N. Q. Is printing enabled?\n         JZ    Main300                 N. Skip print phase\n         ICM   R01,B'1111',PrRngTbl    Y. Q. Got a print range table?\n         JZ    Main230                    N. Print everything then\n         LA    R15,Main210                Y. Ensure print range table\n         O     R15,BitZero                   ... search is done in\n         BSM   0,R15                         ... AMODE=31\n         USING PrtEntry,R01\n         SPACE\nMain210  DS    0H\n         LM    R14,R15,PrtStart     Load print range\n         N     R14,SevenFs          Ensure start range top bit is clear\n         CLR   R11,R14              Q. Address lower than low range?\n         JL    Main220              Y. Not in this range, try next one\n         CLR   R11,R15              N. Q. Addr higher than high range?\n         JNH   Main230                 N. Inside range so print it\n         SPACE\nMain220  DS    0H\n         TM    PrtEntry,X'80'        Q. End of range table entries?\n         JO    Main300               Y. Nothing to print then\n         LA    R01,PrtEntry+Prt$ELen N. Point to next range table entry\n         J     Main210                  and go check it out\n         DROP  R01\n         SPACE\nMain230  DS    0H\n         LA    R15,Main240          BSM target address\n         O     R15,OldAMODE         Insert target amode\n         BSM   0,R15                Ensure right AMODE for EvalBD etc.\n         SPACE\nMain240  DS    0H\n         BRAS  R14,PrintSup         Call the print supervisor\n         NI    UsrFlag1,255-Flg$PrCurInst Disable current instr. flag\n         SPACE\n*---------------------------------------------------------------------*\n*        Do execution profiling if required                           *\n*---------------------------------------------------------------------*\n         SPACE\nMain300  DS    0H\n         N     R11,SevenFs          Ensure H.O. bit is zero\n         ICM   R02,B'1111',EProfTbl Q. Profiler table present?\n         JZ    Main400              N. Skip execution profiling\n         LA    R15,Main310          Y. Search table in AMODE=31\n         O     R15,BitZero             ...\n         BSM   0,R15                   ...\n         USING PrfEntry,R02\n         SPACE\nMain310  DS    0H\n         LM    R14,R15,PrfStart     Load a profiler range\n         CLR   R11,R14              Q. IP lower than low range?\n         JL    Main320              Y. No in this range\n         CLR   R11,R15              N. Q. IP higher than high range?\n         JH    Main320                 N. Not in this range\n         L     R00,PrfIntvl            Y. Get range sub-interval size\n         CHI   R00,4                      Q. Valid sub-interval size?\n         JNL   Main330                    Y. Go update table\n         BRAS  R14,HexToEBC               N. Convert to display\n         STM   R00,R01,cMsg010+32            Move to message\n         LA    R02,Msg010                    Point to error message\n         J     WTOABEND                      Go write message and ABEND\n         SPACE\nMain320  DS    0H\n         TM    PrfEntry,X'80'        Q. Last entry?\n         JO    Main400               Y. Nothing to profile\n         LA    R02,PrfEntry+PRF$ELEN N. Bump to next entry\n         J     Main310                  and go process it\n         SPACE\nMain330  DS    0H\n         LR    R15,R11              R11 - R14 gives the offset\n         SLR   R15,R14              ... within the profiler range\n         SLR   R14,R14              Clear top half of dividend\n         DR    R14,R00              Relative sub-interval\n         SLL   R15,2                Multiply by 4 (cell size)\n         AL    R15,PrfTable         Address of relative cell\n         LHI   R14,1                Increment value in cell\n         AL    R14,0(,R15)          ...\n         ST    R14,0(,R15)          ...\n         DROP  R02\n         SPACE\n*---------------------------------------------------------------------*\n*        Do instruction counting if required                          *\n*---------------------------------------------------------------------*\n         SPACE\nMain400  DS    0H\n         ICM   R02,B'1111',InstrTbl Q. Instruction count table present?\n         JZ    Main500              N. Skip instruction counting\n         LA    R15,Main410          Y. Search table in AMODE=31\n         O     R15,BitZero             ...\n         BSM   0,R15                   ...\n         USING In#Entry,R02\n         SPACE\nMain410  DS    0H\n         LM    R15,R00,In#Start     Load a instr. count range\n         CLR   R11,R15              Q. IP lower than low range?\n         JL    Main420              Y. No in this range\n         CLR   R11,R00              N. Q. IP higher than high range?\n         JNH   Main430                 N. Found an instr. count range\n         SPACE\nMain420  DS    0H\n         TM    In#Entry,X'80'        Q. Last entry?\n         JO    Main500               Y. Do not count this instruction\n         LA    R02,In#Entry+IN#$ELEN N. Bump to next entry\n         J     Main410                  and go process it\n         SPACE\nMain430  DS    0H\n         TM    bAttribute4,bitFLOAT Q. Floating point instruction?\n         JZ    Main440              N. Go count instruction\n         TM    UsrFlag2,Flg$NCFP    Y. Q. Ignore floating point?\n         JO    Main500                 Y. Skip instruction counting\n         SPACE\nMain440  DS    0H\n         SLR   R00,R00              Default table offset is zero\n         SLR   R15,R15              Ensure top 3 bytes are zero\n         CLI   XCell,$B2            Q. x'B2' prefixed instruction?\n         JNE   Main450              N. Check for x'A7'\n         LHI   R00,256              Y. Offset to x'B2' table\n         IC    R15,XCell+1             Use 2nd byte as instruction code\n         J     Main480\n         SPACE\nMain450  DS    0H\n         CLI   XCell,$A7            Q. x'A7' prefixed instruction?\n         JNE   Main460              N. Check for x'01'\n         LHI   R00,256+256          Y. Offset to x'A7' table\n         IC    R15,XCell+1             Use 2nd byte as instruction code\n         N     R15,OOOOOOOF            Only L.O. nybble is relevant\n         J     Main480\n         SPACE\nMain460  DS    0H\n         CLI   XCell,$01            Q. x'01' prefixed instruction?\n         JNE   Main470              N. Stay with default table\n         LHI   R00,256+256+16       Y. Offset to x'01' table\n         IC    R15,XCell+1             Use 2nd byte as instruction code\n         CLI   XCell+1,$TRAP2          Q. Is this TRAP2?\n         JNE   Main480                 N. Instruction code is OK\n         LHI   R15,03                  Y. Use 3 as the offset instead\n         J     Main480\n         SPACE\nMain470  DS    0H\n         IC    R15,XCell            Instruction code (1st byte only)\n         SPACE\nMain480  DS    0H\n         ALR   R15,R00              Add table offset\n         SLL   R15,2                Multiply by 4 (cell size)\n         AL    R15,In#Table         Address of relative cell\n         LHI   R14,1                Increment value in cell\n         AL    R14,0(,R15)          ...\n         ST    R14,0(,R15)          ...\n         DROP  R02\n         SPACE\n*---------------------------------------------------------------------*\n*        Update instruction pointer (IP) if necessary                 *\n*---------------------------------------------------------------------*\n         SPACE\nMain500  DS    0H\n         AP    IRCOUNT,cpOne        Increment instructions traced count\n         AP    ITCOUNT,cpOne        Increment total instructions traced\n         TM    TrcFlag1,Trc$Branch   Q. Increment the pseudo IP?\n         JZ    Main510               Y. Go increment\n         L     R11,BranchTgt         N. New IP from branch routine\n         NI    TrcFlag1,255-Trc$Branch  Reset 'branch taken' flag\n         J     MainLoop                 Go to the end of main loop\n         SPACE\nMain510  DS    0H                   Increment the pseudo IP\n         SLR   R14,R14              Zero H.O. 3 bytes\n         IC    R14,XCell            First byte of instruction\n         SRL   R14,6                First 2 bits of instruction\n         IC    R14,BitCount(R14)    Number of bits ON in 1st 2 bits is -\n                                    ... instruction length in halfwords-\n                                    ... minus one\n         LA    R14,1(,R14)          Number of halfwords in instruction\n         ALR   R14,R14              Number of bytes in instruction\n         LA    R11,0(R14,R11)       Increment the instruction pointer\n         J     MainLoop             Go process next instruction\n         EJECT\n***********************************************************************\n*                                                                     *\n*        Illegal/unsupported instruction handling                     *\n*                                                                     *\n***********************************************************************\n         SPACE\nILGLOP   DS    0H\n         MVC   PLINE(L'IlglMsg),IlglMsg **** ILLEGAL INSTRUCTION\n         BRAS  R14,Write            Print the message\n         BRAS  R14,PrintSup         Print the illegal instruction\n         OI    TrcFlag1,Trc$EndT    Indicate instruction ptr in R11\n         J     End000               End trace, let traced program ABEND\n         SPACE 3\n***********************************************************************\n*                                                                     *\n*        Issue WTO for error message and ABEND                        *\n*                                                                     *\n***********************************************************************\n         SPACE\nWTOABEND DS    0H\n         WTO   TEXT=(R02),MF=(E,cplWTO) Write error message\n         ABEND &ABEND,DUMP          ... and crap out\n         SPACE 3\n***********************************************************************\n*                                                                     *\n*        Set control flags as passed by caller                        *\n*                                                                     *\n***********************************************************************\n         SPACE\nSetFlags DS    0H\n         TM    UsrFlag1,Flg$Spin    Q. Spin off previous output?\n         JZ    SetF010              N. Bif not\n         OI    TrcFlag1,Trc$SPEX    Y. Set internal spin off flag\n         NI    UsrFlag1,255-Flg$Spin   and turn off user spin off flag\n         SPACE\nSetF010  DS    0H\n         TM    UsrFlag2,Flg$PICT    Q. Print instruction count table?\n         JZ    SetF020              N. Bif not\n         OI    TrcFlag1,Trc$PICT    Y. Set internal print flag\n         NI    UsrFlag2,255-Flg$PICT   and turn off user print flag\n         SPACE\nSetF020  DS    0H\n         TM    UsrFlag2,Flg$PEPT    Q. Print execution profile table?\n         JZ    SetF030              N. Bif not\n         OI    TrcFlag2,Trc$PEPT    Y. Set internal print flag\n         NI    UsrFlag2,255-Flg$PEPT   and turn off user print flag\n         SPACE\nSetF030  DS    0H\n         TM    UsrFlag2,Flg$NALC    Q. Allocate DDNAME if not found?\n         JZ    SetF040              Y. Nothing more to do\n         OI    TrcFlag2,Trc$NALC    N. Set internal 'no allocate' flag\n         NI    UsrFlag2,255-Flg$NALC   and turn off user flag\n         SPACE\nSetF040  DS    0H\n         BSM   0,R14                Return to caller\n         EJECT ,\n***********************************************************************\n*                                                                     *\n*        Terminate tracing and resume execution of calling or traced  *\n*        module (which ever is currently active)                      *\n*                                                                     *\n***********************************************************************\n         SPACE\nEnd000   DS    0H\n         BRAS  R12,DumpGPRs         Dump general registers\n         BRAS  R12,DumpARs          Dump access registers\n         BRAS  R12,DumpFPRs         Dump floating point registers\n         TM    TrcFlag2,Trc$PEPT    Q. Print instruction table?\n         JZ    End010               N. Bif not\n         BRAS  R14,PROFILER         Y. Print instruction count table\n         SPACE\nEnd010   DS    0H\n         TM    TrcFlag1,Trc$PICT    Q. Print instruction table?\n         JZ    End020               N. Bif not\n         BRAS  R14,PRINTCNT         Y. Print instruction count table\n         SPACE\nEnd020   DS    0H\n         TM    TrcFlag1,Trc$EndT    Q. Termination by user exit?\n         JO    End030               Y. Got instruction pointer + AMODE\n         L     R11,TraceGPRs+(4*14) N. R14 contains instruction pointer\n         N     R11,SevenFs             Ensure top bit of address clear\n         MVI   TraceAMODE,X'80'        Assume caller is using AMODE=31\n         TM    TraceGPRs+(4*14),X'80'  Q. Actually using AMODE=31\n         JO    End030                  Y. Leave rest of top byte alone\n         ICM   R11,B'1000',HexZeros    N. Zero top byte of address\n         MVI   TraceAMODE,0               Indicate AMODE=24\n         SPACE\nEnd030   DS    0H\n         MVC   PrL$Data+3(L'EndMsg1),EndMsg1\n         LA    R03,PrL$Data+3+L'EndMsg1 Address of resume address field\n         L     R00,TraceAMODE       Get amode indicator\n         OR    R00,R11              Merge in instruction pointer\n         BRAS  R14,HexToEBC         Convert for printing\n         STM   R00,R01,0(R03)       ... and place in message\n         MVI   8(R03),C';'          Field separator\n         LA    R03,10(,R03)         Bump past field separator\n         LA    R02,IRCOUNT          # instructions traced this run\n         BRAS  R14,Edit20           Convert to display\n         EX    R15,MoveEDMK         Move to print line\n         LA    R03,1(R15,R03)       Bump past count\n         MVC   1(L'EndMsg2,R03),EndMsg2\n         LA    R03,L'EndMsg2+1(,R03) Bump to end of message\n         LA    R02,ITCOUNT          Total instructions traced\n         BRAS  R14,Edit20           Convert to display\n         EX    R15,MoveEDMK         Move to print line\n         LA    R03,1(R15,R03)       Bump to end of total trace count\n         MVI   0(R03),C')'\n         MVI   PrL$CCB,C'0'         Double space the line\n         BRAS  R14,Write            Print the message\n         SPACE\n         OI    UsrFlag1,Flg$Spin    Force close of output dataset\n         BRAS  R12,CloseDS          ... and invoke close routine\n         TM    TrcFlag1,Trc$SPEX    Q. Spin off output on exit?\n         JZ    End900               N. Bif not\n         SLR   R00,R00              Y. Indicate spinoff request\n         BRAS  R14,SpinOff             Go spin off the output\n         NI    TrcFlag1,255-Trc$SPEX   ... and clear flag\n         SPACE\nEnd900   DS    0H\n         MVC   DDNAME,SYSTRACE      Reset default output ddname\n         ESTAEX 0                   Cancel our ESTAEX routine\n         SPACE\n*---------------------------------------------------------------------*\n*        Find a register with which we can branch back to the traced  *\n*        program with and zap the return branch instruction with the  *\n*        required index register and offset before executing it.      *\n*---------------------------------------------------------------------*\n         SPACE\nEnd910   DS    0H\n         LHI   R15,15               Register number\n         L     R01,SevenFs          AMODE=31 address mask\n         NR    R11,R01              Ensure high order bit is clear\n         LR    R02,R11              High bound of register value\n         LHI   R14,4095             Maximum branch offset allowed\n         SLR   R02,R14              Low bound of search range\n         TM    TraceAMODE,X'80'     Q. Traced program in AMODE=31?\n         JO    End920               Y. Address mask is OK\n         ICM   R01,B'1000',HexZeros N. Change to AMODE=24 address mask\n         SPACE\nEnd920   DS    0H\n         LR    R14,R15              Get register number\n         SLL   R14,2                Multiply by four for offset\n         L     R14,TraceGPRs(R14)   Contents of register in question\n         NR    R14,R01              Clear top bit(s) from address\n         CLR   R14,R11              Q. Register possibly within bounds?\n         JH    End930               N. Go try next register\n         CLR   R14,R02              Y. Q. Can we use this register?\n         JNL   End940                  Y. Go use this register\n         SPACE\nEnd930   DS    0H\n         BRCT  R15,End920           Try next register\n         LA    R02,Msg009           Tell user we cannot return\n         J     WTOABEND             Go issue WTO and ABEND\n         SPACE\nEnd940   DS    0H\n         SLR   R11,R14              Offset for branch\n         SLL   R15,12               Move register id to bits 16-19\n         OR    R11,R15              OR register with offset\n         STCM  R11,B'0011',Zap4BC+2 Zap 'BC' with base and offset\n         LA    R14,Ret999           Address of return code\n         O     R14,TraceAMODE       Insert traced program's amode\n         SPACE\n         SR    R01,R01              Zero the condition code bits in PSW\n         IPM   R01                  Get current program mask\n         SLR   R02,R02              Clear for condition code insertion\n         ICM   R02,B'1000',TraceCC  Get traced condition code\n         SLL   R02,4                Shift condition code to bits 2-3\n         OR    R01,R02              OR condition code with program mask\n         SPM   R01                  Restore traced condition code\n         BSM   0,R14                Go to return to caller code\n         EJECT\n***********************************************************************\n*                                                                     *\n*        Convert PL8 field to display                                 *\n*                                                                     *\n*        Entry - R02 contains address of PL8 field to convert         *\n*        Exit  - R01 contains address of first display field          *\n*                R15 contains length of display field minus one       *\n*                                                                     *\n***********************************************************************\n         SPACE\nEdit20   DS    0H\n         MVC   WorkCL32,EDmask20         Move edit mask to work area\n         LA    R01,WorkCL32+L'EDmask20-1 Init R01 to default value\n         LR    R15,R01                   which is also end of the field\n         EDMK  WorkCL32(L'EDmask20),0(R02) Convert packed to display\n         SLR   R15,R01                   Calculate length minus one\n         BSM   0,R14\n         EJECT\n***********************************************************************\n*                                                                     *\n*        Branch instruction processor                                 *\n*                                                                     *\n***********************************************************************\n         SPACE\nBrProc   DS    0H\n         ST    R14,BRSAV            Save return address\n         TM    bAttribute2,bitIMREL Q. Relative branch instruction?\n         JZ    BP010                N. Must be an \"old\" style branch\n         CLI   XCell,$A7            Y. Q. x'A7' type instruction?\n         JNE   BP320                   N. Must be BRXH or BRXLE\n         IC    R00,XCell+1             Y. Get 2nd instruction byte\n         N     R00,OOOOOOOF               Isolate A7 qualifier nybble\n         CHI   R00,05                     Q. BRAS instruction?\n         JL    BP500                      Lo. Must be BRC\n         JE    BP300                      Eq. Must be BRAS\n         J     BP600                      Hi. Must be BRCT\n         SPACE\nBP010    DS    0H\n         TM    bAttribute2,bitRRE   Q. BAKR instruction?\n         JO    BP700                Y. Go process it\n         TM    bAttribute2,bitRS    Q. BXH or BXLE ?\n         JO    BP800                Y. Go process it\n         TM    XCell,X'07'          Q. BC (X'47') or BCR (X'07')?\n         JO    BP500                Y. Go process it\n         TM    XCell,X'06'          Q. BCT(X'46') or BCTR(X'06')?\n         JO    BP600                Y. Go process it\n         CLI   XCell,$BSM           Q. BSM instruction?\n         JE    BP100                N. Go process it\n         CLI   XCell,$01            Q. PR instruction?\n         JE    BP200                Y. Go process it\n         J     BP300                N. Must be BAS, BASR, BASSM etc.\n         SPACE\n***********************************************************************\n*                                                                     *\n*        BSM processor                                                *\n*                                                                     *\n***********************************************************************\n         SPACE\nBP100    DS    0H\n         TM    UsrFlag1,Flg$PrRet   Q. Print return type branches?\n         JZ    BP110                N. Do not turn print flag on then\n         OI    UsrFlag1,Flg$PrCurInst Y. Print this instruction\n         SPACE\nBP110    DS    0H\n         IC    R02,XCell+1          rr\n         N     R02,OOOOOOFO         r0\n         JZ    BP120                Don't save mode if R00\n         SRL   R02,2                r*4\n         LA    R01,TraceGPRs(R02)   Address of r1\n         NI    0(R01),X'7F'         Clear top bit of r1\n         OC    0(1,R01),TraceAMODE  Set top bit from current amode\n         J     BP930                Go evaluate branch address\n         SPACE\nBP120    DS    0H\n         CLI   XCell+1,X'0F'        Q. Registers used 0 and 15?\n         JNE   BP930                N. Can't be PEM calling assembler\n         ICM   R00,15,TraceGPRs+4*14 Y. Q. Register 14 zero?\n         JZ    BP350                   Y. PEM equivalent to BALR 14,15\n         J     BP930                   N. Go evaluate branch address\n         SPACE\n***********************************************************************\n*                                                                     *\n*        PR processor                                                 *\n*                                                                     *\n***********************************************************************\n         SPACE\nBP200    DS    0H\n         ICM   R00,B'1111',StackPtr Q. Local stack empty?\n         JNZ   BP210                N. Process the PR instruction\n***                                 Y. Can't handle PR from a BAKR that\n         MVC   PLINE(L'UnMatchedPR),UnMatchedPR ... we did not trace!\n         BRAS  R14,Write            Print the message\n         OI    TrcFlag1,Trc$EndT    Indicate instruction ptr in R11\n         J     End000               End trace\n         SPACE\nBP210    DS    0H\n         TM    UsrFlag1,Flg$PrRet   Q. Print RETURN branches?\n         JZ    BP220                N. Skip turning flag on\n***                                 Y. Print this instruction\n         OI    UsrFlag1,Flg$PrCurInst  ...\n         SPACE\nBP220    DS    0H\n         NI    Zap3BRC+1,X'0F'      NOP the JUMP\n         SPACE\n         STM   R03,R13,SaveRegs+4*3 Save non-scratch registers\n         LR    R15,R10              Point to our working storage\n         PUSH  USING\n         DROP  R10\n         USING Tr390$WS,R15         Temporary base to working-storage\n         EREG  R02,R14              Pop registers off stack entry\n         STM   R02,R14,TraceGPRs+4*2  ... and save\n         STAM  AR02,AR14,TraceARs+4*2 ...\n         PR    ,                    Return to label Zap3BRC\n         POP   USING\n         SPACE\n***********************************************************************\n*                                                                     *\n*        BAL(R), BAS(R), BRAS and BASSM processor                     *\n*                                                                     *\n***********************************************************************\n         SPACE\nBP300    DS    0H\n         TM    UsrFlag1,Flg$PrBAL   Q. Print BAL(R) type branches?\n         JZ    BP310                N. Bypass switch on of print flag\n***                                 Y. Print this instruction\n         OI    UsrFlag1,Flg$PrCurInst\n         SPACE\nBP310    DS    0H\n         LHI   R01,2                Compute increment to R11\n         ICM   R15,B'1000',bAttribute2\n         ICM   R15,B'0100',bAttribute4\n         TMH   R15,(bitRX+bitRS)*256+bitEX\n***                                 Q. RS, RX or EXecute instruction?\n         JZ    BP320                N. Must be RR, increment is 2\n         ALR   R01,R01              Y. Instruction is BAL/BAS/BRAS/EX\n         SPACE\nBP320    DS    0H\n         ALR   R01,R11              Return address for branch\n         O     R01,TraceAMODE       OR in the current AMODE bit\n         TM    XCell,X'0C'          Q. BAS, BASR or BASSM?\n         JO    BP340                Y. Don't fiddle with H.O. byte\n         LTR   R01,R01              N. Q. Program in AMODE=31?\n         JM    BP340                   Y. BAL(R) -> BAS(R) in AMODE=31\n         TM    bAttribute2,bitIMREL    N. Q. BRAS instruction?\n         JO    BP340                      Y. Don't alter H.O. byte\n         SPACE\n*---------------------------------------------------------------------*\n*        Build return register for an AMODE=24 BAL(R) instruction     *\n*---------------------------------------------------------------------*\n         SPACE\n         IPM   R00                  Get program mask bits\n         N     R00,OFOOOOOO         Program mask bits only\n         OR    R01,R00              Insert in the return\n         L     R00,ILC1             Get instruction length bits\n         TMH   R15,bitRX*256+bitEX  Q. RX or EXecute instruction?\n         JZ    BP330                N. Must be BALR so length is two\n         ALR   R00,R00              Y. BAL or executed BALR length is 4\n         SPACE\nBP330    DS    0H\n         OR    R01,R00              OR in instruction length code\n         IC    R00,TraceCC          Get the correct condition code\n         SLL   R00,28               Position it properly\n         OR    R01,R00              OR in condition code bits\n         SPACE\n*---------------------------------------------------------------------*\n*        R01 now contains the return register that would have         *\n*        resulted in actual execution from storing the right half     *\n*        of the PSW                                                   *\n*---------------------------------------------------------------------*\n         SPACE\nBP340    DS    0H\n         IC    R02,XCell+1          rr\n         N     R02,OOOOOOFO         r0\n         SRL   R02,2                r*4\n         ST    R01,TraceGPRs(R02)   Store return in pseudo register\n         TM    bAttribute2,bitIMREL Q. BRAS instruction?\n         JO    BP920                Y. Always branch\n         TM    bAttribute2,bitRX    N. Q. BAS or BAL instruction?\n         JO    BP910                   Y. Always branch\n         EJECT\n***********************************************************************\n*                                                                     *\n*        Get module identification string (if possible)               *\n*                                                                     *\n***********************************************************************\n         SPACE\n         CLI   XCell+1,X'EF'        Q. Branch using registers R14,R15?\n         JNE   BP930                N. Not a standard call\n         TM    bAttribute1,bitAMODE Y. Q. BASSM instruction?\n         JZ    BP350                   N. No need to check AMODEs\n         TM    OldRegs+(4*15),X'80'    Y. Q. Going to AMODE=31?\n         JZ    BP350                      N. Not a problem then\n         TM    TraceAMODE,X'80'           Y. Q. Currently AMODE=24?\n         JO    BP350                         N. Not a problem then\n         TM    OldRegs+(4*15),X'7F'          Y. Q. Target above 16M?\n         JNZ   BP930                            Y. Can't address it\n         SPACE\nBP350    DS    0H\n         L     R15,OldRegs+(4*15)   Get destination address\n         TM    UsrFlag1,Flg$Print+Flg$PrCurInst+Flg$Call\n***                                 Q. Printing active?\n         JZ    BP400                N. Ignore any ID string\n         CLC   0(3,R15),BRANCH      Y. Q. BRANCH around ID string?\n         JE    BP360                   Y. Go check it out\n         CLC   0(3,R15),JUMP           N. Q. JUMP around ID string?\n         JNE   BP400                      N. No ID string present\n         SPACE\nBP360    DS    0H\n         CLI   4(R15),C'$'          Q. Is first byte the length?\n         JL    BP370                Y. Go validate length byte\n         LHI   R01,8                N. Assume length is 8 bytes\n         LA    R14,4(,R15)             Get address of ID string\n         J     BP380                   ... and go process it\n         SPACE\nBP370    DS    0H\n         CLI   4(R15),0             Q. Valid length?\n         JE    BP400                N. Can't use it then\n         LA    R14,5(,R15)          Y. Get address of id string\n         IC    R01,4(,R15)             Load length\n         CLI   4(R15),L'IDstring       Q. Length too long?\n         JNH   BP380                   N. Use it\n         LHI   R01,L'IDstring          Y. Truncate to max length\n         SPACE\nBP380    DS    0H\n         TRT   0(2,R14),DDNchars    Q. 1st 2 bytes valid in module id?\n         JNZ   BP400                N. Assume no module id present\n         MVI   IDstring,C' '        Y. Clear out module name field\n         MVC   IDstring+1(L'IDstring-1),IDstring\n         SPACE\n         BCTR  R01,0                Get machine length\n         EX    R01,MoveIdent        Save module id string\n***      MVC   IDstring(0),0(R14)   ...\n         TR    IDstring,EBCDIC      Replace non-display chars with C'.'\n         OI    TrcFlag1,Trc$ModCall Indicate id string present\n         TM    UsrFlag1,Flg$Call    Q. Print call information?\n         JZ    BP930                N. Use default printing options\n         OI    UsrFlag1,Flg$PrCurInst Y. Explicitly turn on printing\n         J     BP930                   DL/I has no module id info\n         SPACE\n***********************************************************************\n*        Trap calls to DL/I so internal DL/I logic is not traced.     *\n*---------------------------------------------------------------------*\n*        Note that the first 24 bytes of all DL/I interface routines  *\n*        are the same but we cannot just do a 24 byte compare in case *\n*        the storage we are branching to is shorter than 24 bytes     *\n*        long and is at the end of a page boundary, so we will do     *\n*        six 4-byte compares instead and (hopefully) avoid S0C4's.    *\n*                                                                     *\n***********************************************************************\n         SPACE\nBP400    DS    0H\n         CLI   XCell,$BSM           Q. BSM instruction?\n         JE    BP930                Y. Can't be call to DL/I\n         CLI   bAttribute2,bitRRE   Q. BAKR instruction?\n         JO    BP930                Y. Can't be call to DL/I\n         TM    UsrFlag1,Flg$TrDLI   N. Q. Want DL/I calls traced too?\n         JO    BP930                   Y. Bypass DL/I call test\n         ICM   R02,B'1111',ASM2DLI     N. Q. ASMTDLI loaded?\n         JZ    BP930                      Y. Cannot check for ASMTDLI\n         LA    R14,ASMTDLI                N. First DL/I interface name\n         SPACE\nBP410    DS    0H\n         LR    R01,R15              Get copy of branch address\n         LHI   R00,6                Loop 6 times (test 24 bytes)\n         SPACE\nBP420    DS    0H\n         CLC   0(4,R02),0(R01)      Q. Same code as DL/I interface?\n         JNE   BP440                N. Go check for AIBTDLI\n         LA    R02,4(,R02)          Y. Increment DL/I code pointer\n         LA    R01,4(,R01)             Increment branch code pointer\n         BRCT  R00,BP420               Loop for 6 fullwords\n         SPACE\n         OI    TrcFlag1,Trc$ModCall Indicate id string present\n         MVI   IDstring,C' '        Clear out module name field\n         MVC   IDstring+1(L'IDstring-1),IDstring\n         MVC   IDstring(L'DLIcall),DLIcall ... Indicate call is to DL/I\n         MVC   IDstring(8),0(R14)   Actual interface name\n         SPACE\n         L     R01,OldRegs+4        Load R01 with DL/I parmlist\n         BASR  R14,R15              Do call to DL/I\n         ST    R15,TraceGPRs+(4*15) Save return code\n         LA    R02,2(,R11)          Point to next instruction\n         TM    bAttribute4,bitEX    Q. Execute instruction?\n         JZ    BP430                N. Got NSI address\n         LA    R02,4(,R11)          Y. Execute is four bytes long\n         SPACE\nBP430    DS    0H\n         LR    R00,R02              Load R00 with destination address\n         TM    UsrFlag1,Flg$Call    Q. Print call information?\n         JZ    BP990                N. Finished\n***                                 Y. Print this instruction\n         OI    UsrFlag1,Flg$PrCurInst  ...\n         J     BP990                   ... and finish up\n         SPACE\nBP440    DS    0H\n         CLC   AIBTDLI,0(R14)       Q. Did we just check for AIBTDLI?\n         JZ    BP930                Y. Not a DL/I call\n         ICM   R02,B'1111',AIB2DLI  N. Q. AIBTDLI loaded?\n         JZ    BP930                   Y. Cannot check for AIBTDLI\n         LA    R14,AIBTDLI             N. Point to DL/I interface name\n         J     BP410\n         EJECT\n***********************************************************************\n*                                                                     *\n*        BC, BRC and BCR processor                                    *\n*                                                                     *\n***********************************************************************\n         SPACE\nBP500    DS    0H                   Conditional branch processor\n         IC    R01,XCell+1          mr\n         N     R01,OOOOOOFO         m0\n         SLR   R02,R02              Clear R02\n         IC    R02,TraceCC          Actual condition code\n         SLL   R02,2                (condition code)*4\n         N     R01,CCbits(R02)      Mask bits corresponding to\n*                                   the condition code\n         JZ    BP999                Branch is not taken\n         TM    bAttribute2,bitIMREL Q. BRC instruction?\n         JO    BP920                Y. Go evaluate relative address\n         TM    bAttribute2,bitRX    Q. BC instruction?\n         JO    BP910                Y. Go evaluate RX address\n         TM    UsrFlag1,Flg$PrRet   N. Q. Print return type branches?\n         JZ    BP930                   N. Go evaluate R address\n         OI    UsrFlag1,Flg$PrCurInst  Y. Print this instruction\n         J     BP930                      and go evaluate R address\n         SPACE 3\n***********************************************************************\n*                                                                     *\n*        BCT, BRCT and BCTR processor                                 *\n*                                                                     *\n***********************************************************************\n         SPACE\nBP600    DS    0H\n         IC    R02,XCell+1          rr\n         N     R02,OOOOOOFO         r0\n         SRL   R02,2                r1*4\n         L     R01,TraceGPRs(R02)   Value of the count register\n         AHI   R01,-1               Subtract 1 (and set condition code)\n         ST    R01,TraceGPRs(R02)   Store new value back\n         JZ    BP999                No branch if new value is zero\n         TM    bAttribute2,bitIMREL Q. BRC instruction?\n         JO    BP920                Y. Go evaluate relative address\n         TM    bAttribute2,bitRX    Q. RX instruction?\n         JO    BP910                Y. Must be BCT, evaluate RX address\n         J     BP930                N. Must be BCTR, evaluate R address\n         EJECT\n***********************************************************************\n*                                                                     *\n*        BAKR processor                                               *\n*                                                                     *\n***********************************************************************\n         SPACE\nBP700    DS    0H\n         STM   R03,R13,SaveRegs+4*3 Save current registers now for     -\n                                    ... restore after actual BAKR\n         TM    UsrFlag1,Flg$PrBAL   Q. Print BAL(R) type branches?\n         JZ    BP710                N. Bypass switch on of print flag\n***                                 Y. Print this instruction\n         OI    UsrFlag1,Flg$PrCurInst\n         SPACE\nBP710    DS    0H\n         IC    R02,XCell+3          rr\n         N     R02,OOOOOOFO         r0\n         JZ    BP720                Return address is NSI when r1 is 0\n         SRL   R02,2                r*4\n         L     R01,TraceGPRs(R02)   Load return address register value\n         LTR   R01,R01              Q. AMODE=31 on return?\n         JM    BP730                Y. H.O. byte is OK\n         ICM   R01,B'1000',HexZeros N. Ensure H.O. byte is zero\n         J     BP730\n         SPACE\nBP720    DS    0H\n         LA    R01,4(,R11)          Compute increment to IP\n         O     R01,TraceAMODE       OR in the current AMODE bit\n         SPACE\nBP730    DS    0H\n         L     R15,StackPtr         Current stack pointer (offset)\n         LA    R14,BAKR_Stack       Point to our (local) stack\n         LR    R02,R15              Current stack pointer (offset)\n         SLL   R02,3                Multiply by 8 (stack entry length)\n         ST    R01,0(R02,R14)       Save return address in stack entry\n         LA    R15,1(,R15)          Increment stack pointer\n         ST    R15,StackPtr         ... and update\n         IC    R01,XCell+3          rr\n         N     R01,OOOOOOOF         0r\n         JZ    BP740                No branch if using register zero\n         SLL   R01,2                r*4\n         L     R00,OldRegs(R01)     Get address from register\n         N     R00,SevenFs          Ensure H.O. bit is zero\n         J     BP750\n         SPACE\nBP740    DS    0H\n         LA    R00,4(,R11)          Address of NSI\n         SPACE\nBP750    DS    0H\n         O     R00,OldAMODE         Merge with addressing mode bit\n         LTR   R00,R00              Q. AMODE=31 address\n         JM    BP760                Y. All bits are relevant\n         ICM   R00,B'1000',HexZeros N. Zero the H.O. byte\n         SPACE\nBP760    DS    0H\n         ST    R00,4(R02,R14)       Save branch address in stack entry\n         B     Execute3             Go form the stack state entry\n         EJECT\n***********************************************************************\n*                                                                     *\n*        BXH/BRXH and BXLE/BRXLE processor                            *\n*                                                                     *\n***********************************************************************\n         SPACE\nBP800    DS    0H\n         IC    R01,XCell+1          rr\n         N     R01,OOOOOOOF         0r\n         SLL   R01,2                r3*4\n         L     R00,TraceGPRs(R01)   Value of the increment\n         IC    R02,XCell+1          rr\n         N     R02,OOOOOOFO         r0\n         SRL   R02,2                r1*4\n         AL    R00,TraceGPRs(R02)   1st operand + increment\n         ST    R00,TraceGPRs(R02)   Store sum back in r1\n         TM    XCell+1,X'01'        Q. Is r3 odd?\n         JO    BP810                Y. So it is the comparand\n         LA    R01,4(,R01)             (r3+1)*4\n         SPACE\nBP810    DS    0H\n         C     R00,TraceGPRs(R01)   Compare new value and comparand\n         JH    BP820                New value is greater\n         TM    XCell,X'01'          Q. Is the instruction B(R)XLE?\n         JO    BP900                Y. BXLE so branch is taken\n         J     BP999                N. BXH so branch is not taken\n         SPACE\nBP820    DS    0H\n         TM    XCell,X'01'          Q. Is the instruction B(R)XH?\n         JNZ   BP999                N. Branch is not taken\n         EJECT\n*---------------------------------------------------------------------*\n*        Type RS, branch is taken.  Compute effective address         *\n*---------------------------------------------------------------------*\n         SPACE\nBP900    DS    0H\n         TM    bAttribute2,bitIMREL Q. Relative branch?\n         JO    BP920                Y. Go evaluate relative branch\n         LA    R02,XCell+2          N. Point at base, displacement\n         BRAS  R14,EvalBD              Go evaluate effective address\n         J     BP990\n         SPACE\n*---------------------------------------------------------------------*\n*        Type RX, branch is taken.  Compute effective address         *\n*---------------------------------------------------------------------*\n         SPACE\nBP910    DS    0H\n         LA    R02,XCell+2          Point at base, displacement field\n         BRAS  R14,EvalXBD          Go evaluate effective address\n         J     BP990\n         SPACE\n*---------------------------------------------------------------------*\n*        Type RI, branch is taken.  Compute effective address         *\n*---------------------------------------------------------------------*\n         SPACE\nBP920    DS    0H\n         BRAS  R14,EvalRI           Go evaluate relative address\n         J     BP990\n         SPACE\n*---------------------------------------------------------------------*\n*        Type RR(E), branch is taken.  Compute effective address      *\n*---------------------------------------------------------------------*\n         SPACE\nBP930    DS    0H\n         IC    R01,XCell+1          rr from RR instruction\n         TM    bAttribute2,bitRRE   Q. Actually an RRE instruction?\n         JNO   BP940                N. Got the correct rr specifiers\n         IC    R01,XCell+3          Y. Load correct rr for RRE\n         SPACE\nBP940    DS    0H\n         N     R01,OOOOOOOF         0r\n         JZ    BP999                No branch if register 0 specified\n         SLL   R01,2                r*4\n         L     R00,OldRegs(R01)     Get address from register\n         SPACE\nBP950    DS    0H\n         TM    bAttribute1,bitAMODE Q. Does this instruction set mode?\n         JZ    BP990                N. AMODE does not change then\n         STCM  R00,8,TraceAMODE     Y. Save new addressing mode\n         NI    TraceAMODE,X'80'        Only interested in H.O. bit\n         SPACE\n*---------------------------------------------------------------------*\n*        Successful branch exit                                       *\n*---------------------------------------------------------------------*\n         SPACE\nBP990    DS    0H\n         ST    R00,BranchTgt        Save branch address as new IP\n         OI    TrcFlag1,Trc$Branch  Indicate branch was taken\n         SPACE\n*---------------------------------------------------------------------*\n*        Unsuccessful branch exit                                     *\n*---------------------------------------------------------------------*\n         SPACE\nBP999    DS    0H\n         L     R14,BRSAV            Restore return address\n         BSM   0,R14                Return\n         TITLE 'Execute Instruction Processor'\n***********************************************************************\n*                                                                     *\n*        EXECUTE instruction processor                                *\n*                                                                     *\n***********************************************************************\n         SPACE\nExOP     DS    0H\n         MVC   PSXCell+2(4),NopInstr Pad PSXCell with NOPs\n         LA    R02,XCell+2          Point to base and displacement\n         BRAS  R14,EvalXBD          Evaluate the effective address of  X\n                                    ... the EXECUTE'd instruction\n         LR    R01,R00              Move address to non-zero register\n         ST    R00,aEX_Target       Save address in case it's a BRANCH\n         SPACE\n         SLR   R14,R14              Clear work register\n         IC    R14,0(,R01)          First byte of target instruction\n         SRL   R14,6                Mask off instruction length code\n         IC    R14,BitCount(R14)    Number of halfwords minus one\n         ALR   R14,R14              Number of bytes in instruction - 2\n         LA    R14,1(,R14)          Number of bytes in instruction - 1\n         EX    R14,EXMVCEX          Load target instruction\n***      MVC   PSXCell(0),0(R01)    ...\n         SPACE\n         IC    R02,XCell+1          rr of the EXECUTE instruction\n         N     R02,OOOOOOFO         Isolate execute register\n         SPACE\n*---------------------------------------------------------------------*\n*        If the r1 field of the execute instruction is zero then the  *\n*        subject instruction is executed as is,  otherwise the right  *\n*        hand byte of the register specified by the r1 field is OR'ed *\n*        into the second byte of the subject instruction.             *\n*---------------------------------------------------------------------*\n         SPACE\n         JZ    ExOp010              Register 0? Then nothing to OR in\n         SRL   R02,2                r0 / 2 = r1*4\n         IC    R02,TraceGPRs+3(R02) Get the bits to OR in\n         SLL   R02,16               00nn0000 <- 000000nn\n         O     R02,PSXCell          OR with the subject instruction\n         STCM  R02,B'1100',PSXCell  ... and save updated instruction\n         SPACE\nExOp010  DS    0H\n         SLR   R01,R01              Clear R01\n         IC    R01,PSXCell          Code of the subject instruction\n         L     R15,aOpIndex         Instruction code index address\n         CLI   XCell,$B2            Q. x'B2' type instruction?\n         JNE   ExOp020              N. Go check for x'A7' instruction\n         IC    R01,XCell+1          Y. 2nd byte of instruction code\n         L     R15,aB2index            Instruction code index address\n         J     ExOp040\n         SPACE\nExOp020  DS    0H\n         CLI   XCell,$A7            Q. x'A7' type instruction?\n         JNE   ExOp030              N. No other checking\n         IC    R01,XCell+1          Y. 2nd byte of instruction code\n         N     R01,OOOOOOOF            Isolate low order nybble\n         L     R15,aA7index            Instruction code index address\n         J     ExOp040\n         SPACE\nExOp030  DS    0H\n         CLI   XCell,$01            Q. x'01' type instruction?\n         JNE   ExOp040              N. No other checking\n         IC    R01,XCell+1          Y. 2nd byte of instruction code\n         L     R15,a01index            Instruction code index address\n         SPACE\nExOp040  DS    0H\n         SLL   R01,1                Multiply by 2 for entry length\n         LH    R01,0(R01,R15)       Instruction code index\n         L     R15,aOpFlags         Address of attribute flags table\n         L     R01,0(R01,R15)       Load instruction attribute flags\n         ST    R01,PSFLAGS          Save the flags\n         TM    PSFLAGS,bitILGL      Q. Subject instruction illegal?\n         JO    ILGLOP               Y. Print message and terminate\n         TM    PSFLAGS,bitBR        Q. Is subject instruction a branch?\n         JO    ExBr                 Y. Simulate an executed branch ins.\n         MVC   ExecIns1,PSXCell     N. Parameters for execute routine\n         LA    R05,PSFLAGS             Load address of PSFLAGS\n         BRAS  R03,ExecInst            Call the execute routine\n         SPACE\n         TM    PSFLAGS,bitCC        Q. Condition code possibly changed?\n         JZ    ExOp050              N. Not a possibility\n         SRL   R00,4                Y. Shift condition code into\n         STCM  R00,B'1000',TraceCC     ... bits 6-7 of R00 and save\n         SPACE\nExOp050  DS    0H\n         J     Main200              Return to the main loop\n         TITLE 'Executed Branch Handler'\n***********************************************************************\n*                                                                     *\n*       EXECUTE'd branch handler                                      *\n*                                                                     *\n***********************************************************************\n         SPACE\nExBr     DS    0H\n         TM    PSFLAGS+3,bitEX      Q. EXECUTE'd instruction an EX?\n         JZ    ExBr010              N. Go process executed branch\n         OI    TrcFlag1,Trc$EndT    Y. Indicate end of trace so the\n         J     End000                  ... S0C3 happens outside TRACE\n         SPACE\n*---------------------------------------------------------------------*\n*        Shuffle things around to fool the branch processor           *\n*---------------------------------------------------------------------*\n         SPACE\nExBr010  DS    0H\n         L     R01,bAttributes      Swap bAttributes and PSFLAGS\n         L     R02,PSFLAGS          ...\n         ST    R01,PSFLAGS          ...\n         ST    R02,bAttributes      ...\n         LM    R00,R01,XCell        Swap XCell and PSXCell\n         LM    R02,R03,PSXCell      ...\n         STM   R00,R01,PSXCell      ...\n         STM   R02,R03,XCell        ...\n         SPACE\n*---------------------------------------------------------------------*\n*        Signal an executed branch so that the instruction length     *\n*        code comes out right for RR format branch instructions       *\n*---------------------------------------------------------------------*\n         SPACE\n         OI    bAttribute4,bitEX    Set executed branch flag\n         BRAS  R14,BrProc           Call the branch processor\n         SPACE\n*---------------------------------------------------------------------*\n*        Put things back the way they were so that the execute        *\n*        instruction gets printed                                     *\n*---------------------------------------------------------------------*\n         SPACE\n         L     R01,bAttributes      Swap bAttributes and PSFLAGS\n         L     R02,PSFLAGS          ...\n         ST    R01,PSFLAGS          ...\n         ST    R02,bAttributes      ...\n         LM    R00,R01,XCell        Swap XCell and PSXCell\n         LM    R02,R03,PSXCell      ...\n         STM   R00,R01,PSXCell      ...\n         STM   R02,R03,XCell        ...\n         J     Main200              Return to the main loop\n         TITLE 'Non-Branch and Execute Instruction Handler'\n***********************************************************************\n*                                                                     *\n*        Instruction execution processor                              *\n*                                                                     *\n*        ExecIns1 - Instruction to be executed                        *\n*        R03      - Return address                                    *\n*        R05      - Address of executed instruction's attribute flags *\n*                                                                     *\n***********************************************************************\n         SPACE\nExecInst DS    0H\n         CLI   ExecIns1,$LM         Q. 'Load Multiple' instruction?\n         JE    ExecLM               Y. Go process\n         STM   R03,R13,SaveRegs+4*3 N. Save callers registers\n         SPACE\n*---------------------------------------------------------------------*\n*        Check for instructions which alter storage if necessary      *\n*---------------------------------------------------------------------*\n         SPACE\n         TM    0(R05),bitALTER      Q. Instruction alter storage?\n         JZ    EI200                N. Cannot alter storage\n         ICM   R15,B'1111',WatchTbl Y. Q. Watchpoint table supplied?\n         JZ    EI200                   N. Nothing to do then\n         SPACE\n         TM    2(R05),bitDBLS+bitFULL+bitHALF+bitBYTE\n*                                   Q. Fixed length operand?\n         JZ    EI010                N. Need to calculate length then\n         LHI   R15,4-1              Y. Assume fullword operand\n         TM    2(R05),bitFULL          Q. Really fullword operand?\n         JO    EI100                   Y. Go calculate address\n         SLR   R15,R15                 N. Assume byte operand\n         TM    2(R05),bitBYTE             Q. Really byte operand?\n         JO    EI100                      Y. Go calculate address\n         LHI   R15,8-1                    N. Assume doubleword operand\n         TM    2(R05),bitDBLS                Q. Really doubleword?\n         JO    EI100                         Y. Go calculate address\n         LHI   R15,2-1                       N. Must be halfword\n         J     EI120                            Go calculate address\n         SPACE\n*---------------------------------------------------------------------*\n*        Determine type of instruction                                *\n*---------------------------------------------------------------------*\n         SPACE\nEI010    DS    0H\n         CLI   ExecIns1,$STCM       Q. STCM instruction?\n         JE    EI060                EQ. Yes, go get STCM operand length\n         JL    EI020                LO. Must be MVCL or STM\n         TM    0(R05),bitPACKD      HI. SS instruction, is it packed?\n         JZ    EI030                    N. Non-packed SS instruction\n         IC    R15,ExecIns1+1           Y. Get ll byte (l1,l2)\n         N     R15,OOOOOOFO                Mask off l1\n         SRL   R15,4                       Move into right nybble\n         J     EI110                       Got get storage address\n         SPACE\n*---------------------------------------------------------------------*\n*        Get length of storage accessed by STM instruction            *\n*---------------------------------------------------------------------*\n         SPACE\nEI020    DS    0H\n         CLI   ExecIns1,$STM        Q. STM instruction?\n         JNE   EI070                Y. Must be MVCL instruction then\n         IC    R15,ExecIns1+1       N. rr\n         LR    R14,R15                 rr\n         N     R14,OOOOOOFO            r0       r1\n         SRL   R14,4                   r        r1\n         N     R15,OOOOOOOF            0r       r2\n         LA    R15,16(,R15)            r2 + 16\n         SLR   R15,R14                 r2 + 16 - r1\n         N     R15,OOOOOOOF            (r2 + 16 - r1) MOD 16\n         SLL   R15,4                   = (# of registers minus one) * 4\n         LA    R15,3(,R15)             = (# of registers * 4) minus one\n         J     EI110                   Go find storage address\n         SPACE\n*---------------------------------------------------------------------*\n*        Get length of storage altered by a non-decimal SS format     *\n*        instruction  (note that MVCK and MVCP are special cases)     *\n*---------------------------------------------------------------------*\n         SPACE\nEI030    DS    0H\n         TM    0(R05),bitMVCX       Q. MVCK or MVCP instruction?\n         JO    EI040                Y. Length is in a register\n         SLR   R15,R15              N. Clear R15\n         IC    R15,ExecIns1+1          Length minus one\n         J     EI110                   Go get storage address\n         SPACE\n*---------------------------------------------------------------------*\n*        Instruction is a MVCK or a MVCP                              *\n*---------------------------------------------------------------------*\n         SPACE\nEI040    DS    0H\n         IC    R15,ExecIns1+1       rr\n         N     R15,OOOOOOFO         r0\n         SRL   R15,2                r*4\n         L     R15,TraceGPRs(R15)   True length\n         CHI   R15,256              Q. True length less than 256 bytes?\n         JNH   EI050                Y. True length will be used\n         LHI   R15,256              N. Used length will be 256 bytes\n         SPACE\nEI050    DS    0H\n         BCTR  R15,0                Want length minus one\n         J     EI110                Go find storage address\n         SPACE\n*---------------------------------------------------------------------*\n*        Instruction is a STCM                                        *\n*---------------------------------------------------------------------*\n         SPACE\nEI060    DS    0H\n         IC    R15,ExecIns1+1       rm\n         N     R15,OOOOOOOF         0m\n         IC    R15,BitCount(R15)    Number of bits\n         BCTR  R15,0                Number of bits in m minus one\n         J     EI110                Go find address of storage\n         SPACE\n*---------------------------------------------------------------------*\n*        Get address and length of MVCL(E) instruction                *\n*---------------------------------------------------------------------*\n         SPACE\nEI070    DS    0H\n         IC    R15,ExecIns1+1       rr\n         N     R15,OOOOOOFO         r0\n         SRL   R15,2                r1*4\n         SLR   R04,R04              Assume we're not in AR ASC mode\n         CLI   TraceASC,ARmode      Q. In AR ASC mode?\n         JNE   EI080                N. Default value is good\n         L     R04,TraceARs(R15)    Y. Load associated ALET\n         SPACE\nEI080    DS    0H\n         L     R14,TraceGPRs(R15)   Start address (contents of r1)\n         LA    R14,0(,R14)          Ensure high order bit/byte clear\n         LA    R15,4(,R15)          (r1 + 1) * 4\n         L     R01,TraceGPRs(R15)   Length of target\n         TM    bAttribute2,bitRR    Q. MVCL instruction?\n         JZ    EI090                N. Length is OK for MVCLE\n         ICM   R01,B'1000',HexZeros Y. MVCL only has 3-byte length\n         SPACE\nEI090    DS    0H\n         LTR   R01,R01              Q. Target length zero?\n         JZ    EI200                Y. Zero length results in no store\n         BCTR  R01,0                N. Length minus 1\n         LA    R15,0(R01,R14)          End address\n         J     EI130\n         EJECT\n*---------------------------------------------------------------------*\n*        Is instruction RX or one of S, SS, RS and SI                 *\n*---------------------------------------------------------------------*\n         SPACE\nEI100    DS    0H\n         TM    1(R05),bitRX         Q. RX instruction?\n         JO    EI120                Y. Calculate ddd(x,b) address\n         SPACE\n*---------------------------------------------------------------------*\n*        Generate address range used by S, SS, RS and SI instructions *\n*---------------------------------------------------------------------*\n         SPACE\nEI110    DS    0H\n         LA    R02,ExecIns1+2       Point to ddd(b)\n         BRAS  R14,EvalBD           Generate address into R00\n         LR    R14,R00              Start address of altered storage\n         LA    R15,0(R15,R14)       End address of altered storage\n         J     EI130                Go check address range\n         SPACE\n*---------------------------------------------------------------------*\n*        Generate address range for RX instructions                   *\n*---------------------------------------------------------------------*\n         SPACE\nEI120    DS    0H\n         LA    R02,ExecIns1+2       Point to ddd(b)\n         IC    R03,XCell+1          Save contents of XCell+1\n         MVC   XCell+1(1),ExecIns1+1 ... and replace it\n         BRAS  R14,EvalXBD          Generate address into R00\n         STC   R03,XCell+1          Restore contents of XCell+1\n         LR    R14,R00              Start address of altered storage\n         LA    R15,0(R15,R14)       End address of altered storage\n         J     EI130                Go test address range for trap\n         SPACE\n*---------------------------------------------------------------------*\n*        Test if storage about to be altered is in a range            *\n*        specified by the user in the watchpoint table.               *\n*---------------------------------------------------------------------*\n         SPACE\nEI130    DS    0H\n         L     R01,WatchTbl         Address of watch point table\n         USING WptEntry,R01         ...\n         LA    R02,EI140            Ensure that the watch point table\n         O     R02,BitZero          ... is searched in AMODE=31\n         BSM   0,R02                ...\n         SPACE\nEI140    DS    0H\n         CL    R04,WptALET          Q. ALETs match?\n         JNE   EI150                N. Ignore this range\n         LM    R02,R03,WptEntry     Y. Load a watchpoint range\n         N     R02,SevenFs             Ensure start range H.O. bit zero\n         CLR   R14,R03                 Q. Possible overlap in ranges?\n         JH    EI150                   N. Not a possibility\n         CLR   R02,R15                 Y. Q. Really an overlap?\n         JH    EI150                      N. Go try next range\n         CLR   R02,R14                    Y. Q. R02 higher than R14?\n         JNL   EI160                         Y. Pass R02 to exit\n         LR    R02,R14                       N. Pass R14 to exit\n         J     EI160\n         SPACE\nEI150    DS    0H\n         TM    WptStart,X'80'       Q. Last watchpoint entry?\n         JO    EI180                Y. No watch point for this address\n         LA    R01,WptEntry+Wpt$ELEN   Point to next entry in table\n         J     EI140                   and go check it out\n         SPACE\n*---------------------------------------------------------------------*\n*        Invoke watchpoint exit                                       *\n*---------------------------------------------------------------------*\n         SPACE\nEI160    DS    0H\n         ST    R02,StoreAddr        Indicate watchpoint exit\n         LR    R02,R11              Current instruction pointer\n         O     R02,TraceAMODE       Merge in addressing mode bit\n         ST    R02,InstrPointer     Store it where exit expects it\n         OI    TrcFlag1,Trc$Exit    Indicate user exit active\n         L     R15,WptExit          AMODE/Address of watch-point exit\n         DROP  R01\n         LA    R01,plUserExit       Point to exit parameter list\n         BASSM R14,R15              Invoke watch-point routine\n         LTR   R15,R15              Q. Good return code from exit?\n         JZ    EI170                Y. Go execute the instruction\n         OI    TrcFlag1,Trc$EndT    N. Indicate termination of tracing\n         SPACE\nEI170    DS    0H\n         NI    TrcFlag1,255-Trc$Exit User exit no longer active\n         BRAS  R12,CloseDS          Spin off output if required\n         BRAS  R14,SetFlags         Reprocess user flags\n         SPACE\nEI180    DS    0H\n         LA    R15,EI200            Restore addressing mode to that of\n         O     R15,TraceAMODE       ... the traced program\n         BSM   0,R15\n         EJECT\n*---------------------------------------------------------------------*\n*        Mark register (pairs) used by the instruction                *\n*---------------------------------------------------------------------*\n         SPACE\nEI200    DS    0H\n         XC    ExecReg,ExecReg      Clear register (pairs) used\n         CLI   ExecIns1,$B2         Q. X'B2' type instruction?\n         JNE   EI240                N. Go check for normal formats\n         TM    1(R05),bitRRE        Y. Q. RRE instruction?\n         JZ    EI270                   N. Must be S format instruction\n         CLI   ExecIns1+1,$IPM         Y. Q. IPM instruction?\n         JE    ExecIPM                    Y. Go process the IPM\n         SPACE\n*---------------------------------------------------------------------*\n*        Mark register (pairs) used by RRE instruction                *\n*        Note that only some RRE instructions actually use r2         *\n*---------------------------------------------------------------------*\n         SPACE\n         IC    R01,ExecIns1+3       Get byte containing registers\n         BRAS  R14,ExecLeft         Get r1\n         CLI   ExecIns1+1,$EREG     Q. EREG instruction?\n         JE    EI220                Y. Special case\n         CLI   ExecIns1+1,$BAKR     Q. BAKR instruction?\n         JE    EI210                Y. r2 is used\n         CLI   ExecIns1+1,$SAR      Q. SAR instruction?\n         JE    EI210                Y. r2 is used\n         CLI   ExecIns1+1,$TAR      Q. TAR instruction?\n         JE    EI210                Y. r2 is used\n         CLI   ExecIns1+1,$IVSK     Q. IVSK instruction?\n         JE    EI210                Y. r2 is used\n         CLI   ExecIns1+1,$PT       Q. PT instruction?\n         JE    EI210                Y. r2 is used\n         CLI   ExecIns1+1,$ESTA     Q. ESTA instruction?\n         JNE   EI290                N. r2 not used\n         SPACE\n*---------------------------------------------------------------------*\n*        Check ESTA for extraction of the PSW or branch address       *\n*---------------------------------------------------------------------*\n         SPACE\n         IC    R15,XCell+3          rr\n         N     R15,OOOOOOOF         r2\n         SLL   R15,2                r2*4\n         LA    R14,TraceGPRs+3(R15) Point to L.O. byte of r2\n         TM    0(R14),03            Q. Want stacked PSW or branch addr?\n         JNM   EI210                N. Not our \"special\" case(s)\n         ICM   R02,B'1111',StackPtr Y. Q. Is our stack empty?\n         JNZ   ExecESTA                N. Go get data from our stack\n         SPACE\n*---------------------------------------------------------------------*\n*        Get r2 for RRE instruction                                   *\n*---------------------------------------------------------------------*\n         SPACE\nEI210    DS    0H\n         BRAS  R14,ExecRight        Get r2\n         J     EI290\n         SPACE\n*---------------------------------------------------------------------*\n*        EREG can potentially use ALL registers (however, in most     *\n*        cases it won't!). We can safely use one of R01-R14 as R0t if *\n*        they are available for use, otherwise even more specialized  *\n*        logic will be required to emulate this instruction.          *\n*---------------------------------------------------------------------*\n         SPACE\nEI220    DS    0H\n         SLR   R01,R01              Load EREG register specifiers\n         IC    R01,ExecIns1+3       ...\n         LR    R14,R01              ...\n         SRL   R01,4                Isolate r1\n         N     R14,OOOOOOOF         Isolate r2\n         CLR   R01,R14              Q. Extracting a single register?\n         JE    EI290                Y. Standard processing will work!\n         SPACE\nEI230    DS    0H\n         BCTR  R01,0                Decrement starting register ID\n         N     R01,OOOOOOOF         Mask H.O. bits in case it wrapped\n         CLR   R01,R14              Q. Reached ending register?\n         JE    ExecEREG             Y. No registers available to use\n         CHI   R01,15               N. Q. Register 15?\n         JE    EI230                   Y. Can't use this register\n         LTR   R01,R01                 N. Q. Register 0?\n         JE    EI230                      Y. Can't use this register\n         SLL   R01,4                      N. Shift ID to H.O. nybble\n         J     EI320                         Use this register\n         SPACE\n*---------------------------------------------------------------------*\n*        RR instruction, mark register (pairs) used                   *\n*---------------------------------------------------------------------*\n         SPACE\nEI240    DS    0H\n         TM    1(R05),bitRR         Q. RR instruction?\n         JZ    EI250                N. Try RX, RS and SI\n         TM    3(R05),bitFLOAT      Y. Q. Floating point instruction?\n         JO    EI290                   Y. No general registers are used\n         IC    R01,ExecIns1+1          N. Get register part\n         BRAS  R14,ExecLeft               Get r1\n         BRAS  R14,ExecRight              Get r2\n         CLI   ExecIns1,$SVC              Q. SVC instruction?\n         JNE   EI290                      N. Go find register pairs\n         TM    UsrFlag1,Flg$Call          Y. Q. Print call information?\n         JZ    EI290                         N. Go find register pairs\n         OI    UsrFlag1,Flg$PrCurInst        Y. Print this instruction\n         J     EI290                            Go find register pairs\n         SPACE\n*---------------------------------------------------------------------*\n*        If an RX or RS instruction, mark register (pairs) used       *\n*---------------------------------------------------------------------*\n         SPACE\nEI250    DS    0H\n         TM    1(R05),bitSS         Q. SS/SSE type instruction?\n         JO    EI280                Y. Go process it\n         TM    1(R05),bitSSI        N. Q. S/SI type instruction?\n         JO    EI270                   Y. There is no r1/x2\n         IC    R01,ExecIns1+1          N. Must be RX or RS\n         TM    3(R05),bitFLOAT            Q. Floating point?\n         JO    EI260                      Y. r1 not a general register\n         BRAS  R14,ExecLeft               N. Get r1\n         TM    2(R05),bitSHIFT               Q. Shift instruction?\n         JO    EI270                         Y. No r3 in instruction\n         SPACE\nEI260    DS    0H\n         BRAS  R14,ExecRight        Get x2 (or r3)\n         SPACE\nEI270    DS    0H                   S/SI instruction (and RS, RX)\n         IC    R01,ExecIns1+2\n         BRAS  R14,ExecLeft         Get b2\n         J     EI290\n         SPACE\n*---------------------------------------------------------------------*\n*        Mark register (pairs) used by SS and SSE instructions        *\n*---------------------------------------------------------------------*\n         SPACE\nEI280    DS    0H\n         IC    R01,ExecIns1+2       Get b1\n         BRAS  R14,ExecLeft         ...\n         IC    R01,ExecIns1+4       Get b2\n         BRAS  R14,ExecLeft         ...\n         TM    0(R05),bitMVCX       Q. MVCK, MVCP or MVCS?\n         JZ    EI290                N. r1/r3 not present then\n         IC    R01,ExecIns1+1       Y. Get byte with r1/r3 in it\n         BRAS  R14,ExecLeft            Get r1\n         BRAS  R14,ExecRight           Get r3\n         EJECT\n*---------------------------------------------------------------------*\n*        Search backwards starting at R10-R11 for a register pair     *\n*        which is not used by the instruction to be executed.         *\n*                                                                     *\n*        There is a maximum of five register pairs looked at, these   *\n*        being R02-R03, R04-R05, R06-R07, R08-R09 and R10-R11.        *\n*        we cannot use R00-R01, R12-R13 or R14-R15 as they are        *\n*        implicitly used by some instructions (i.e. SVC, TRT, etc.)   *\n*                                                                     *\n*        Since the maximum number of registers specified in any       *\n*        instruction format is four, this search should never fail.   *\n*---------------------------------------------------------------------*\n         SPACE\nEI290    DS    0H\n         LHI   R01,4                Set maximum loop count to 4\n         LA    R02,ExecReg+1(R01)   Addr of first reg pair to look at\n         SPACE\nEI300    DS    0H\n         CLI   0(R02),X'FF'         Q. This register pair used?\n         JNE   EI310                N. We can use it then\n         BCTR  R02,0                Y. Point to previous register pair\n         BRCT  R01,EI300               ... and go check it\n         SPACE\n*---------------------------------------------------------------------*\n*        Chosen temporary base register (R0t) is the even register    *\n*        in the register pair, put it into the right nybble of R01    *\n*---------------------------------------------------------------------*\n         SPACE\nEI310    DS    0H\n         LA    R01,1(,R01)          R01 + 1 = R0t / 2\n         SLL   R01,5                R0t, moved into H.O. nybble\n         SPACE\n         TM    0(R05),bitACCESS     Q. Access register(s) affected?\n         JO    EI320                Y. Use access register logic\n         CLI   TraceASC,ARmode      N. Q. In AR ASC mode?\n         JE    EI320                   Y. Can't ignore access registers\n         SPACE\n*---------------------------------------------------------------------*\n*        Zap the appropriate bytes in storage which need to use R0t   *\n*        and then invoke the (non-AR) instruction execution logic.    *\n*---------------------------------------------------------------------*\n         SPACE\n         STC   R01,Zap1BASR+1       Store register to be used\n         SRL   R01,2                R0t*4\n         STC   R01,Zap1LA+3         ...\n         NI    Zap1STM+2,X'0F'      Clear base register from STM\n         OC    Zap1STM+2(1),Zap1BASR+1 ... and replace with new base\n         SPACE\n         B     Execute1             Go execute the traced instruction\n         SPACE\n*---------------------------------------------------------------------*\n*        Zap the appropriate bytes in storage which need to use R0t   *\n*        and then invoke the AR related instruction execution logic.  *\n*---------------------------------------------------------------------*\n         SPACE\nEI320    DS    0H\n         MVC   ExecIns2,ExecIns1    Instruction to be executed\n         STC   R01,Zap2BASR+1       Store register to be used\n         SRL   R01,2                R0t*4\n         STC   R01,Zap2LA+3         ...\n         SPACE\n         NI    Zap2STM+2,X'0F'      Clear base register from STM\n         OC    Zap2STM+2(1),Zap2BASR+1 ... and replace with new base\n         SPACE\n         LR    R00,R01              R0t*4\n         SRL   R00,2                R0t\n         STC   R00,WorkCL5          R0t in right nybble of a byte\n         SLL   R01,2                R0t*16 (i.e. R0t in left nybble)\n         SPACE\n         NI    ZAP2ST+1,X'F0'       Clear old index register value\n         NI    ZAP2ST+2,X'0F'       Ensure base register is zero\n         OC    ZAP2ST+1(1),WorkCl5  Insert R0t as INDEX register\n         SPACE\n         NI    Zap2EAR+3,X'F0'      Clear base register from EAR\n         OC    Zap2EAR+3(1),WorkCL5 ... and replace with new base\n         SPACE\n         OR    R00,R01              R0t in both nybbles of L.O. byte\n         STC   R00,Zap2LAM1+1       Update register range in LAM\n         NI    Zap2LAM1+2,X'0F'     Clear base register from LAM\n         OC    Zap2LAM1+2(1),Zap2BASR+1 ... and replace with new base\n         SPACE\n         NI    Zap2STAM+2,X'0F'      Clear base register from STAM\n         OC    Zap2STAM+2(1),Zap2BASR+1 ... and replace with new base\n         SPACE\n         NI    Zap2LAM2+2,X'0F'      Clear base register from LAM\n         OC    Zap2LAM2+2(1),Zap2BASR+1 ... and replace with new base\n         SPACE\n         B     Execute2             Go execute the traced instruction\n         EJECT\n*---------------------------------------------------------------------*\n*        These two routines are used to mark 'ExecReg' with the       *\n*        register (pairs) used by the instruction to be executed.     *\n*---------------------------------------------------------------------*\n         SPACE\nExecRight DS   0H\n         LR    R02,R01              Move parm (R01) into work register\n         N     R02,OOOOOOOF         Mask out all but right nybble\n         SRL   R02,1                Divide by two for byte offset\n         J     ExecLRCT\n         SPACE\nExecLeft DS    0H\n         LR    R02,R01              Move parm (R01) into work register\n         N     R02,OOOOOOFO         Mask out all but left nybble\n         SRL   R02,5                Shift to right nybble & divide by 2\n         SPACE\nExecLRCT DS    0H\n         LA    R02,ExecReg(R02)     Point to register pair to be used\n         MVI   0(R02),X'FF'         ... mark it\n         BSM   0,R14                ... and return\n         EJECT\n*---------------------------------------------------------------------*\n*        Process 'Load Multiple' instruction                          *\n*---------------------------------------------------------------------*\n         SPACE\nExecLM   DS    0H\n         LA    R02,ExecIns1+2       Point to source operand\n         BRAS  R14,EvalBD           Get address of source (in R00)\n         LR    R14,R00              ... and copy to usable address reg\n         SPACE\n         CLI   TraceASC,ARmode      Q. Are we in AR ASC mode?\n         JNE   ExLM010              N. Ignore access registers\n         SLR   R01,R01              Y. Get source base register\n         IC    R01,ExecIns1+2          ...\n         SRL   R01,2                   b*4\n         LA    R01,TraceARs(R01)       Address of associated AR\n         LAM   AR14,AR14,0(R01)        Load associated AR\n         SPACE\nExLM010  DS    0H\n         IC    R01,XCell+1          Get LM registers\n         LR    R02,R01              Copy here too\n         N     R01,OOOOOOFO         Isolate r1\n         SRL   R01,2                Mult. by 4 and put in right nybble\n         N     R02,OOOOOOOF         Isolate r2\n         SLL   R02,2                ... and multiply by four\n         SLR   R15,R15              Zero index into source\n         SPACE\nExLM020  DS    0H\n         L     R00,0(R15,R14)       Load a word from the source\n         ST    R00,TraceGPRs(R01)   Store it in the register table\n         CLR   R01,R02              Q. LM completed?\n         JE    ExLM030              Y. Exit from loop\n         LA    R15,4(,R15)          N. Increment source index\n         LA    R01,4(,R01)             Increment register table index\n         N     R01,OOOOOO3C            Wrap register index if required\n         J     ExLM020                 Go load next register\n         SPACE\nExLM030  DS    0H\n         SLR   R14,R14              Zero the access register\n         SAR   AR14,R14             ...\n         BSM   0,R03                Return to caller\n         EJECT\n*---------------------------------------------------------------------*\n*        Process a ESTA instruction that extracts the PSW             *\n*---------------------------------------------------------------------*\n         SPACE\nExecESTA DS    0H\n         MVC   WorkCL5(1),0(R14)    Save the function code\n         IC    R01,XCell+3          rr\n         N     R01,OOOOOOFO         r0\n         SRL   R01,4                r1\n         TML   R01,X'0001'          Q. Odd register specified as r1?\n         JZ    ESTA010              N. Keep processing\n         OI    TrcFlag1,Trc$EndT    Y. Disable tracing\n         J     End000                  Let S0C6 occur in traced program\n         SPACE\nESTA010  DS    0H\n         SLL   R01,2                r1*4\n         LHI   R00,1                Function = extract PSW\n         ESTA  R14,R00              Extract the stacked PSW\n         IPM   R00                  Save the condition code\n         ST    R14,TraceGPRs(R01)   Save first 1/2 of extracted PSW\n         BCTR  R02,0                Backup to last used stack entry\n         SLL   R02,2                Multiply by 4 (entry length)\n         L     R14,BAKR_Stack(R02)  Load stacked return address\n         ST    R14,TraceGPRs+4(R01) ... and update traced registers\n         BSM   0,R03                and we're done\n         EJECT\n*---------------------------------------------------------------------*\n*        Process IPM instruction                                      *\n*---------------------------------------------------------------------*\n         SPACE\nExecIPM  DS    0H\n         IC    R15,XCell+3          rr\n         N     R15,OOOOOOFO         r0\n         SRL   R15,2                r1*4\n         LA    R15,TraceGPRs(R15)   A(byte in TraceGPRs to update)\n         SPACE\n         SR    R01,R01              Set PSW condition code bits to zero\n         IPM   R01                  Get current program mask\n         SLR   R02,R02              Clear for condition code insertion\n         ICM   R02,B'1000',TraceCC  Get \"traced\" condition code\n         SLL   R02,4                Shift condition code to bits 2-3\n         OR    R01,R02              OR condition code with program mask\n         STCM  R01,B'1000',0(R15)   Save result of IPM\n         SPACE\n         BSM   0,R03                and we're done\n         EJECT\n***********************************************************************\n*        Pathological case EREG instruction                           *\n*---------------------------------------------------------------------*\n*        'Execute2' requires use of 2 (addressable) general registers *\n*        for processing (R15 and one other). This routine is used for *\n*        EREG instructions which extract R01 through R14 (and maybe   *\n*        R00 and R15 as well)!                                        *\n*                                                                     *\n***********************************************************************\n         SPACE\nExecEREG DS    0H\n         LR    R15,R10              Temporary base to working storage\n         PUSH  USING                ...\n         DROP  R10                  ...\n         USING Tr390$WS,R15         ...\n         EREG  R01,R14              Extract (A)R01 through (A)R14\n         STM   R01,R14,TraceGPRs+4*1  ... and save\n         STAM  AR01,AR14,TraceARs+4*1 ...\n         LM    R03,R13,SaveRegs+4*3 Restore our general registers\n         LAM   AR01,AR14,HexZeros   Clear out the access registers\n         POP   USING                Drop temporary base to WS\n         SPACE\n         CLI   Xcell+3,X'0E'        Q. Register range 0-14?\n         JE    ExER010              Y. (A)R15 not required\n         CLI   Xcell+3,X'1E'        N. Q. Register range 1-14?\n         JE    ExER010                 Y. (A)R15 not required\n         EREG  R15,R15                 N. Extract (A)R15 from stack\n         ST    R15,TraceGPRs+4*15         ... and save\n         STAM  AR15,AR15,TraceARs+4*15    ...\n         SPACE\nExER010  DS    0H\n         CLI   Xcell+3,X'1E'        Q. Register range 1-14?\n         JE    ExER020              Y. (A)R00 not required\n         CLI   Xcell+3,X'1F'        N. Q. Register range 1-15?\n         JE    ExER020                 Y. (A)R00 not required\n         EREG  R00,R00                 N. Extract (A)R00 from stack\n         ST    R00,TraceGPRs              ... and save\n         STAM  AR00,AR00,TraceARs         ...\n         SPACE\nExER020  DS    0H\n         LAM   AR15,AR00,HexZeros   Zero AR15 and AR00\n         SPACE\n         BSM   0,R03                Return to caller\n         TITLE 'Trace Write Routine for User Exits'\n***********************************************************************\n*                                                                     *\n*        Called by user exits to write to our output dataset          *\n*                                                                     *\n***********************************************************************\n         SPACE\nPUTR     DS    0H\n         STM   R14,R12,12(R13)      Save callers registers\n         L     R15,aBASEREGS-PUTR(,R15) Address of base addresses\n         LM    R07,R10,0(R15)       Load base registers\n         SPACE\n         ST    R13,PUTRSAVE+4       Set save area back pointer\n         LA    R15,PUTRSAVE         Point to new save area\n         ST    R15,8(,R13)          Set callers forward pointer\n         LR    R13,R15              Set up new save area pointer\n         SPACE\n         BRAS  R12,CloseDS          Spin off output if required\n         TR    PLINE,EBCDIC         Remove any non-display chars\n         BRAS  R14,Write            Write out line\n         SPACE\n         SLR   R15,R15              Zero return code\n         L     R13,4(,R13)          Restore callers R13\n         ST    R15,8(,R13)          Clear forward pointer\n         L     R14,12(,R13)         Load return address\n         LM    R00,R12,20(R13)      Restore caller's registers\n         OI    15(R13),X'01'        Indicate exit from here\n         BSM   0,R14                Return to the user exit\n         TITLE 'Storage Dump Routine for User Exits'\n***********************************************************************\n*                                                                     *\n*         Produce formatted dump of storage                           *\n*         On entry:                                                   *\n*              R00 - Address of first byte to be dumped               *\n*              R01 - Number of fullwords to dump                      *\n*                                                                     *\n***********************************************************************\n         SPACE\nDumpVS   DS    0H\n         STM   R14,R12,12(R13)      Save callers registers\n         L     R15,aBASEREGS-DumpVS(,R15) Get pointer to base addresses\n         LM    R07,R10,0(R15)       Load base registers\n         SPACE\n         ST    R13,PUTRSAVE+4       Chain save areas\n         LA    R15,PUTRSAVE         ...\n         ST    R15,8(,R13)          ...\n         LR    R13,R15              ...\n         SPACE\n         LR    R02,R00              Load dump address\n         LR    R03,R01              Move number of words to dump\n         SLR   R04,R04              Initialise offset to zero\n         SPACE\n         L     R14,0(,R02)          First word to be dumped\n         LA    R14,1(,R14)          Ensure not equal\n         ST    R14,WorkCL32         Save in last line dumped save area\n         SPACE\nDmp010   DS    0H\n         LHI   R15,8                Number of words per line\n         SPACE\nDmp020   DS    0H\n         CLR   R03,R15              Q. More that a full line to dump?\n         JNH   Dmp040               N. Dump last line\n         LA    R14,0(R04,R02)       Y. Point to dump data\n         CLC   WorkCL32,0(R14)         Q. Same as last line?\n         JNE   Dmp030                  N. Go dump it\n         MVC   PrD$HexData(4),SAME     Y. Indicate same as previous\n         LA    R04,4*8(,R04)              Increment offset\n         SLR   R03,R15                    Decrement number of words\n         J     Dmp020                     Ignore this line\n         SPACE\nDmp030   DS    0H\n         MVC   WorkCL32,0(R14)      Reset last line\n         SPACE\nDmp040   DS    0H\n         CLC   PrD$HexData(4),SAME  Q. \"Same\" lines found?\n         JNE   Dmp050               N. Bif not\n         BRAS  R14,Write            Y. Write out the \"SAME\" line\n         SPACE\nDmp050   DS    0H\n         MVI   PrD$Offset-1,C'+'    Offset prefix character\n         LR    R00,R04              Load offset\n         BRAS  R14,HexToEBC         Convert to display hex\n         STCM  R00,B'0011',PrD$Offset Move offset to print line\n         STCM  R01,15,PrD$Offset+2  ...\n         SPACE\n         MVI   PrD$Address-1,C'@'   Address prefix character\n         LA    R00,0(R04,R02)       Load current dump address\n         BRAS  R14,HexToEBC         Convert to display hex\n         STM   R00,R01,PrD$Address  Store in print line\n         SPACE\n         LHI   R15,8                Number of words per line\n         LA    R11,PrD$HexData      Point to hex data area\n         SPACE\nDmp060   DS    0H\n         L     R00,0(R04,R02)       Load data byte\n         LHI   R14,8                Calculate offset within EBCDIC\n         SLR   R14,R15              ... data area for current word\n         SLL   R14,2                ...\n         ST    R00,PrD$EBCDIC(R14)  ... and store EBCDIC representation\n         BRAS  R14,HexToEBC         Format hex data\n         STM   R00,R01,0(R11)       Store data in print line\n         LA    R11,L'PrD$HexData(,R11) Bump hex output area pointer\n         LA    R04,4(,R04)          Bump offset value\n         BCTR  R03,0                Decrement number of word left\n         LTR   R03,R03              Q. Any words left?\n         JNP   Dmp070               N. Drop out of loop\n         BRCT  R15,Dmp060           Y. Loop up to 8 times\n         SPACE\nDmp070   DS    0H\n         TR    PrD$EBCDIC,EBCDIC    Replace any non-printable data\n         BRAS  R14,Write            Write out the line\n         LTR   R03,R03              Q. Any more words to dump?\n         JNZ   Dmp010               Y. Start new line\n         SPACE\n         SLR   R15,R15              Zero return code\n         L     R13,4(,R13)          Restore callers r13\n         ST    R15,8(,R13)          Zero save area forward pointer\n         L     R14,12(,R13)         Load return address\n         LM    R00,R12,20(R13)      Restore callers registers\n         OI    15(R13),X'01'        Set return indicator\n         BSM   0,R14                ... and return\n         SPACE 3\naBASEREGS DC   A(aBASE)             Address of base addresses\n         TITLE 'High Level Write Routine'\n***********************************************************************\n*        Routine to output the print line                             *\n*---------------------------------------------------------------------*\n*        Also keeps track of the line count on a page so we know when *\n*        to generate page headers.                                    *\n*                                                                     *\n***********************************************************************\n         SPACE\nWrite    DS    0H\n         ST    R14,WRSAV            Save return address\n         TM    UsrFlag1,Flg$PrHdr   Q. Page headers to be printed?\n         JZ    Write050             N. Bif not\n         CLI   PrL$CCB,C' '         Y. Q. Single spacing?\n         JE    Write040                Y. Space 1 line\n         CLI   PrL$CCB,C'0'            N. Q. Double spacing?\n         JE    Write030                   Y. Space 2 lines\n         CLI   PrL$CCB,C'-'               N. Q. Triple spacing?\n         JE    Write020                      Y. Space 3 line\n         CLI   PrL$CCB,C'+'                  N. Q. Overstriking?\n         JE    Write050                         Y. Don't count line\n         CLI   PrL$CCB,C'1'                     N. Q. New page?\n         JE    Write010                            Y. Generate header\n         MVI   PrL$CCB,C' '                        N. Force single\n         J     Write040                               ... spacing\n         SPACE\nWrite010 DS    0H\n         ZAP   LINE#,cpZero         Zero number of lines left on page\n         J     Write040             Go force new page\n         SPACE\nWrite020 DS    0H\n         SP    LINE#,cpOne          Decrement line counter\n         SPACE\nWrite030 DS    0H\n         SP    LINE#,cpOne          Decrement line counter\n         SPACE\nWrite040 DS    0H\n         SP    LINE#,cpOne          Decrement line counter\n         JP    Write050             Go do write if it will fit on page\n         MVC   SAVELINE,PLINE       Save line to be printed\n         MVI   PLINE,C' '           ... and clear printline\n         MVC   PrL$Data(L'PrL$Data),PLINE ...\n         BRAS  R14,PRINTHDR         Print page headers\n         MVC   PLINE,SAVELINE       Restore original line\n         MVI   PrL$CCB,C'0'         Double space after headers\n         SPACE\nWrite050 DS    0H\n         BRAS  R14,PutLine          Write out data line\n         SPACE\n         L     R14,WRSAV            Get return address\n         BSM   0,R14                Return to caller\n         TITLE 'Write Out a Print Line to the Output Dataset'\n***********************************************************************\n*        Routine which does the actual PUT                            *\n*---------------------------------------------------------------------*\n*        Also handles spinoff and opening of the output dataset       *\n*                                                                     *\n***********************************************************************\n         SPACE\nPutLine  DS    0H\n         ST    R14,PLSAV            Save return address\n         IAC   R04                  Q. In primary ASC mode?\n         JZ    PutL010              Y. We're OK as is\n         SAC   0                    N. Switch to primary ASC mode\n         SPACE\nPutL010  DS    0H\n         TM    DCBOFLGS,DCBOFOPN    Q. Trace dataset opened yet?\n         JO    PutL200              Y. No need to open it again\n         ICM   R15,B'1111',aUserDDN N. Q. Did caller supply a DD name?\n         JZ    PutL020                 N. Default is 'SYSTRACE'\n         MVC   DDNAME,0(R15)           Y. Use supplied ddname\n         SPACE\n*---------------------------------------------------------------------*\n*        Scan the Task I/O Table for the trace output ddname          *\n*---------------------------------------------------------------------*\n         SPACE\nPutL020  DS    0H\n         L     R01,FLCCVT-PSA       CVT address\n         L     R01,CVTTCBP-CVT(,R01) Address of TCB pointers\n         L     R01,4(,R01)          Current TCB address\n         L     R01,TCBTIO-TCB(,R01) Address of TIOT\n         LHI   R15,TIOENTRY-TIOT1   Displacement of 1st TIOT entry\n         USING TIOENTRY,R01         Map TIOT entry\n         SPACE\nPutL030  DS    0H\n         ALR   R01,R15              Bump to first/next entry\n         ICM   R15,B'0001',TIOELNGH Q. Length of this TIOT entry zero?\n         JZ    PutL040              Y. End of table reached\n         CLC   TIOEDDNM,DDNAME      N. Q. Found our DD name in TIOT?\n         JNE   PutL030                 N. Go look at next TIOT entry\n         DROP  R01\n         SPACE\n         TM    TrcFlag1,Trc$SPIN    Q. Spin off old old dataset?\n         JZ    PutL100              N. Go open reopen it\n         SLR   R00,R00              Y. Indicate SpinOff request\n         BRAS  R14,SpinOff             Attempt to spin off old output\n         NI    TrcFlag1,255-Trc$SPIN   ... Clear spin off flag\n         J     PutL100                 ... and go open dataset\n         SPACE\n*---------------------------------------------------------------------*\n*        DDname is not in the task I/O table, tell user and quit      *\n*---------------------------------------------------------------------*\n         SPACE\nPutL040  DS    0H\n         TM    TrcFlag2,Trc$NALC    Q. Allocate DD name if not found?\n         JO    PutL050              N. Must be an error then\n         LHI   R00,1                Y. Indicate allocation request\n         BRAS  R14,SpinOff             Allocate the output DD name\n         J     PutL100                 ... and go OPEN the dataset\n         SPACE\nPutL050  DS    0H                   Move in DDNAME causing error\n         MVC   cMsg008+15(L'DCBDDNAM),DDNAME\n         WTO   TEXT=Msg008,MF=(E,cplWTO) Tell user about it\n         OI    TrcFlag1,Trc$NoDD+Trc$EndT Indicate no DD name present  X\n                                    and quit out of trace at mainline\n         TM    TrcFlag1,Trc$Exit    Q. User exit active?\n         JO    PutL900              Y. Return to exit\n         J     End900               N. Return from trace\n         SPACE\n*---------------------------------------------------------------------*\n*        Open the dataset, ABEND on OPEN failure                      *\n*---------------------------------------------------------------------*\n         SPACE\nPutL100  DS    0H\n         MVC   DCBDDNAM,DDNAME\n         MVI   cplOPEN,X'80'        Indicate single entry in list\n         OPEN  (dcbTRACE,OUTPUT),MODE=31,MF=(E,cplOPEN)\n         SPACE\n         TM    DCBOFLGS,DCBOFOPN    Q. OPEN successful?\n         JO    PutL200              Y. Continue\n***                                 N. Move in DDNAME causing error\n         MVC   cMsg007+38(L'DCBDDNAM),DDNAME\n         LA    R02,Msg007              Point to WTO text\n         J     WTOABEND                Go issue WTO and ABEND\n         SPACE\n*---------------------------------------------------------------------*\n*        Write the line and return to caller                          *\n*---------------------------------------------------------------------*\n         SPACE\nPutL200  DS    0H\n         PUT   dcbTRACE,PLINE       Write out the line\n         SPACE\nPutL900  DS    0H\n         MVI   PLINE,C' '           One blank to start\n         MVC   PrL$Data(L'PrL$Data),PLINE Propagate the blank\n         SPACE\n         TML   R04,X'0300'          Q. Were we in primary ASC mode?\n         JZ    PutL990              Y. Nothing to restore then\n         SAC   0(R04)               N. Switch back to entry ASC mode\n         SPACE\nPutL990  DS    0H\n         L     R14,PLSAV            Get return address\n         BSM   0,R14                Return to caller\n         TITLE 'Close the Output Dataset'\n***********************************************************************\n*                                                                     *\n*        This routine isolates closing of the output dataset into a   *\n*        single location within the program (excluding ESTAE routine) *\n*                                                                     *\n***********************************************************************\n         SPACE\nCloseDS  DS    0H\n         TM    UsrFlag1,Flg$Spin    Q. Spin off (close) output DS?\n         BZR   R12                  N. Do nothing, just return\n         TM    DCBOFLGS,DCBOFOPN    Y. Q. Is dataset open?\n         JZ    Close020                N. No need to close it then\n         IAC   R04                     Y. Q. In primary ASC mode?\n         JZ    Close010                   Y. We're OK as is\n         SAC   0                          N. Switch to primary ASC mode\n         SPACE\nClose010 DS    0H\n         MVI   cplCLOSE,X'80'       Indicate single entry in list\n         CLOSE (dcbTRACE),MODE=31,MF=(E,cplCLOSE)\n         TML   R04,X'0300'          Q. Were we in primary ASC mode?\n         JZ    Close020             Y. Nothing to restore then\n         SAC   0(R04)               N. Switch back to entry ASC mode\n         SPACE\nClose020 DS    0H\n         ZAP   LINE#,cpZero         Reset number of line left on page\n         ZAP   PAGE#,cpZero         Reset page counter\n         NI    UsrFlag1,255-Flg$Spin Turn off user SpinOff flag\n         OI    TrcFlag1,Trc$SPIN    Turn on internal SpinOff flag\n         SPACE\n         BSM   0,R12                Return to caller\n         TITLE 'Spin Off Output Dataset if Sysout Dataset'\n***********************************************************************\n*                                                                     *\n*        Spin off the output dataset if it is of type SYSOUT          *\n*                                                                     *\n***********************************************************************\n         SPACE\nSpinOff  DS    0H\n         ST    R14,SPSAV            Save return address\n         SPACE\n*---------------------------------------------------------------------*\n*        Check if output dataset is a SYSOUT one                      *\n*---------------------------------------------------------------------*\n         SPACE\n         LA    R02,SVC99RB          Point to DYNALLOC request block\n         USING S99RB,R02            Set base\n         XC    S99RB(lenS99RB),S99RB Zero the request block\n         MVI   S99RBLN,lenS99RB     Set length field\n         LTR   R00,R00              Q. Allocate only request?\n         JNZ   Spin200              Y. Go do allocate\n         TM    UsrFlag2,Flg$GDSN    N. Q. Generated output DS name?\n         JO    Spin100                 Y. Deallocate it\n         MVI   S99VERB,S99VRBIN        N. Information request\n         LA    R15,plTestAlloc            Parameters for SYSOUT test\n         ST    R15,S99TXTPP               Set parameter list pointer\n         LA    R01,S99PARM                Parameter list for SVC 99\n         DYNALLOC ,                       Issue the request\n         LTR   R15,R15                    Q. Good result?\n         JNZ   Spin900                    N. Go issue error message\n         CLI   TESTPARM,X'10'             Y. Q. SYSOUT data set?\n         JNE   Spin999                       N. Ignore it\n         SPACE\n         SPACE\n*---------------------------------------------------------------------*\n*        Deallocate current output dataset                            *\n*---------------------------------------------------------------------*\n         SPACE\nSpin100  DS    0H\n         LA    R15,plDeallocate     Get deallocate parameter list\n         ST    R15,S99TXTPP         Put in request block\n         MVI   S99VERB,S99VRBUN     Deallocate request\n         LA    R01,S99PARM          Parameter list for SVC 99\n         DYNALLOC ,                 De-allocate the DD\n         LTR   R15,R15              Q. Good return?\n         JNZ   Spin900              N. Go issue error message\n         SPACE\nSpin200  DS    0H\n         LA    R15,plAllocate       Allocation parameter list\n         ST    R15,S99TXTPP         Put in request block\n         TM    UsrFlag2,Flg$GDSN    Q. Generated output DS name?\n         JZ    Spin210              N. Allocate sysout dataset\n         BRAS  R14,GENDSN           Y. Generate the dataset name\n         LA    R15,plDSN_Allocate      Load text pointers address\n         ST    R15,S99TXTPP            Put in request block\n         MVC   tu$DDNAM,DDNAME         Move in correct DDNAME\n         SPACE\nSpin210  DS    0H\n         MVI   S99VERB,S99VRBAL     Indicate allocate request\n         LA    R01,S99PARM          Parameter list for SVC 99\n         DYNALLOC ,                 (Re)allocate dataset\n         LTR   R15,R15              Q. Successful allocation?\n         JZ    Spin999              Y. Return to caller\n         SPACE\n*---------------------------------------------------------------------*\n*        Non-zero return code from DYNALLOC, tell user and ABEND      *\n*---------------------------------------------------------------------*\n         SPACE\nSpin900  DS    0H\n         LR    R00,R15              Convert SVC 99 return code for msg\n         BRAS  R14,HexToEBC         ...\n         STCM  R01,B'0011',cMsg005+35\n         SPACE\n         IC    R00,S99VERB          Display DYNALLOC verb\n         BRAS  R14,HexToEBC         ...\n         STCM  R01,B'0011',cMsg005+28\n         SPACE\n         L     R00,S99ERROR         Load error and info codes\n         BRAS  R14,HexToEBC         Convert to display\n         STCM  R00,15,cMsg005+45    Put error code in WTO message\n         STCM  R01,15,cMsg005+56    Put reason code in WTO message\n         MVC   cMsg005+69(L'DCBDDNAM),DDNAME\n         LA    R02,Msg005           Point to WTO text\n         J     WTOABEND             Go issue WTO and ABEND\n         DROP  R02\n         SPACE\n*---------------------------------------------------------------------*\n*        Return to caller                                             *\n*---------------------------------------------------------------------*\n         SPACE\nSpin999  DS    0H\n         L     R14,SPSAV            Load return address\n         BSM   0,R14                and return\n         TITLE 'Generate Name for Output Dataset'\n***********************************************************************\n*        Allocate cataloged dataset to hold TRACE390 output           *\n*---------------------------------------------------------------------*\n*        Allocate a new (cataloged) dataset to the output DDNAME      *\n*        to which the trace output will be written in the IMS/DC      *\n*        (online) environment.                                        *\n*        This must be done as most people do NOT have access to the   *\n*        IMS message region SYSOUT datasets via SDSF.                 *\n*                                                                     *\n***********************************************************************\n         SPACE\nGENDSN   DS    0H\n         ST    R14,GDSAV            Save return address\n         TIME  ,                    Get the date and time\n         L     R15,FLCCVT-PSA       CVT address\n         L     R15,CVTTCBP-CVT(,R15) Address of TCB pointers\n         L     R15,4(,R15)          Current TCB address\n         L     R15,TCBTIO-TCB(,R15) Address of TIOT\n         MVC   tu$DSN+13(8),0(R15)  Move in address space name\n         LA    R15,tu$DSN+13+7      End of address space name field\n         SPACE\nGDSN010  DS    0H\n         CLI   0(R15),C' '          Q. Is it a blank?\n         JNE   GDSN020              N. Last character found\n         BRCT  R15,GDSN010          Y. Loop 'til non-blank found\n         SPACE\nGDSN020  DS    0H\n         CLI   0(R15),C'.'          Q. Is it a delimiter?\n         JE    GDSN030              Y. Don't set another one\n         LA    R15,1(,R15)          N. Bump pointer\n         MVI   0(R15),C'.'             and insert delimiter\n         SPACE\nGDSN030  DS    0H\n         LA    R15,1(,R15)          Bump past delimiter\n         STCM  R01,B'0111',WorkDblW Store date for UNPK\n         UNPK  0(6,R15),WorkDblW(3) Unpack julian date into DSN\n         MVI   0(R15),C'D'          Insert 'D' into day qualifier\n         MVI   6(R15),C'.'          Append qualifier character\n         LA    R15,7(,R15)          Bump past date qualifier field\n         SPACE\n         LR    R14,R00              Save time\n         SRL   R00,4                Shift off tenths of a second\n         ST    R00,WorkDblW         Place in storage for UNPK\n         OI    WorkDblW+3,X'0F'     Ensure F sign\n         UNPK  0(7,R15),WorkDblW(4) Unpack time into dataset name\n         MVI   0(R15),C'T'          Insert 'T' into the time qualifier\n         SPACE\n         MVI   7(R15),C'.'          Insert separator\n         MVI   8(R15),C'S'          Insert S into sequence qualifier\n         SPACE\n         SLR   R14,R14              Ensure H.O. 3 bytes area zero\n         IC    R14,DSNSEQ#          Get DSN sequence number\n         LA    R14,1(,R14)          Increment sequence number\n         STC   R14,DSNSEQ#          Save it back\n         CLI   DSNSEQ#,X'0A'        wrap to 0 if it exceeds 9\n         JNE   GDSN040\n         MVI   DSNSEQ#,X'00'\n         IC    R14,DSNSEQ#          reset r14 to 0\n         SPACE\nGDSN040  DS    0H\n         SLL   R00,4                Make room for sequence number\n         ALR   R00,R14              Add DSN sequence number\n         SLL   R00,4                Make room for sign\n         ST    R00,WorkDblW         Place in storage for UNPK\n         OI    WorkDblW+3,X'0F'     Ensure F sign\n         UNPK  9(3,R15),WorkDblW(4) Unpack sequence number\n         LA    R15,12(,R15)         Bump to end of dataset name\n         SPACE\n         LA    R01,tu$DSN           Calculate then length of the\n         SLR   R15,R01              ... dataset name\n         STH   R15,tu$DSNL          Store in SVC 99 DSN length parm\n         SPACE\n         L     R14,GDSAV            Load return address\n         BSM   0,R14\n         TITLE 'Format Page Header'\n***********************************************************************\n*                                                                     *\n*        Print field names for fields printed                         *\n*                                                                     *\n***********************************************************************\n         SPACE\nPRINTHDR DS    0H\n         ST    R14,PHSAV            Save return address\n         MVC   PrL$DATA(lenID),TRACE390+4+1\n         TM    TrcFlag1,Trc$SPIN    Q. Dataset to be spinned off\n         JZ    PHDR010              N. Bif not\n         BRAS  R14,TimeStamp           Obtain formatted date and time\n         SPACE\nPHDR010  DS    0H\n         AP    PAGE#,cpOne          Increment page counter\n         ZAP   LINE#,PageLen        Line remaining on page\n         MVC   PrL$DATE,PageDate    Current date\n         MVC   PrL$TIME,PageTime    Time (when dataset was opened)\n         MVC   PrL$PAGE,=C'Page'\n         OI    PAGE#+L'PAGE#-1,X'0F' Ensure correct sign\n         UNPK  PrL$PageNo,PAGE#     Page number\n         MVI   PrL$CCB,C'1'         Skip to top of new page\n         BRAS  R14,PutLine          Print the line\n         SP    LINE#,cpOne          Decrement remaining lines\n         TM    TrcFlag2,Trc$NoIH    Q. Print instruction fields?\n         JO    PHDR900              N. Finished\n         SPACE\n         MVC   PrL$ILC,=CL8'PSW-Bits'       PSW bits 32-63\n         MVI   PrL$ASC,C'A'                 ASC mode\n         MVI   PrL$CondCode,C'C'            Condition code\n         MVC   PrL$Reg1,=CL8'  DR1   '      Double register one\n         MVC   PrL$DR1,=CL8' DR1+1  '       Second register in pair\n         MVC   PrL$DR2A,=CL8'  DR2   '      Double register two\n         MVC   PrL$DR2B,=CL8' DR2+1  '      Second register in pair\n         BRAS  R14,PutLine                  Print the line\n         SP    LINE#,cpOne                  Decrement remaining lines\n         SPACE\n         MVC   PrL$ILC,=CL8' 32-63  '       PSW bits 32-63\n         MVC   PrL$ObjCode,=CL12'Object-Code' Instruction in hex\n         MVI   PrL$ASC,C'S'                 ASC mode\n         MVI   PrL$CondCode,C'C'            Condition codes\n         MVC   PrL$Mnemonic,=CL6'OpCode'    Instruction Mnemonic\n         MVC   PrL$Operands(8),=CL8'Operands' Instruction operands\n         MVC   PrL$Reg1,=CL8'  Reg1  '      Contents of first register\n         MVC   PrL$Reg2,=CL8'  Reg2  '      Contents of second register\n         MVC   PrL$Address1,=CL8'Address1'  First operand address\n         MVC   PrL$Data1,=CL8'Operand1'     First operand data\n         MVC   PrL$Double1,=CL8'Operand1'   First operand data also\n         MVC   PrL$Address2,=CL8'Address2'  Second operand address\n         MVC   PrL$Data2,=CL8'Operand2'     Second operand data\n         MVC   PrL$Double2,=CL8'Operand2'   Second operand data also\n         BRAS  R14,PutLine                  Print the line\n         SP    LINE#,cpOne                  Decrement remaining lines\n         SPACE\nPHDR900  DS    0H\n         MVI   PrL$CCB,C'0'         Double space next line\n         L     R14,PHSAV            Load return address\n         BSM   0,R14                ... and return\n         SPACE 2\n         LTORG ,\n         TITLE 'Print Instruction Counts'\n***********************************************************************\n*        Print contents of the instruction count table entries        *\n*---------------------------------------------------------------------*\n*        Note that handling of x'01' prefixed opcodes is somewhat     *\n*        kludgy and will require rewriting if additional x'01' codes  *\n*        are added to the architecture.                               *\n*                                                                     *\n***********************************************************************\n         SPACE\nPRINTCNT DS    0H\n         ST    R14,PCSAV            Save return address\n         ICM   R06,B'1111',InstrTbl Q. Instruction count table present?\n         JZ    PIC900               N. Nothing to do then\n         OI    TrcFlag2,Trc$NoIH    Y. No instruction field headers\n         LA    R15,PIC010              Process table in AMODE=31\n         O     R15,BitZero             ...\n         BSM   0,R15                   ...\n         USING In#Entry,R06\n         SPACE\nPIC010   DS    0H\n         L     R14,In#Table         Address of instruction count table\n         ZAP   WorkPL8,cpZero       Zero cumulative instruction count\n         LA    R15,256+256+16+4     Loop counter\n         SPACE\nPIC020   DS    0H\n         ICM   R00,B'1111',0(R14)   Q. Anything to count?\n         JZ    PIC040               N. Ignore it then\n         CVD   R00,WorkDblW         Y. Convert to packed\n         CP    WorkDblW,cpZero         Q. Number negative?\n         JNL   PIC030                  N. Use it as is\n         AP    WorkDblW,TwoTo32        Y. Make it unsigned, add 2**32\n         SPACE\nPIC030   DS    0H\n         AP    WorkPL8,WorkDblW     Add to total count of instructions\n         SPACE\nPIC040   DS    0H\n         LA    R14,4(,R14)          Bump to next counter\n         BRCT  R15,PIC020           Repeat for each counter\n         SPACE\n         MVC   PLINE(L'PCHEADER),PCHEADER\n         MVC   WorkCL16(L'EDMask12),EDMask12  Move in edit mask\n         ED    WorkCL16(L'EDMask12),WorkPL8+2 Format instruction count\n         MVC   PrL$Data+5(11),WorkCL16+1\n         L     R00,In#Start         Count range start address\n         BRAS  R14,HexToEBC         Convert to display\n         STM   R00,R01,PrL$Data+56  ... and place into title\n         L     R00,IN#END           Count range end address\n         BRAS  R14,HexToEBC         Convert to display\n         STM   R00,R01,PrL$Data+65  ... and place into title\n         MVC   PrL$Data+75(L'IN#IDENT),IN#IDENT\n         BRAS  R14,Write            Print title line\n         CP    WorkPL8,cpZero       Q. Any instrns executed in range?\n         JZ    PIC300               N. Skip this entry\n         SLR   R05,R05              Y. Initialise loop counter\n         SPACE\n*---------------------------------------------------------------------*\n*        The following logic assumes OpCodes, B2codes and A7codes are *\n*        defined back-to-back in contiguous storage.                  *\n*---------------------------------------------------------------------*\n         SPACE\nPIC100   DS    0H\n         LR    R15,R05              R15 := R05 * 6\n         ALR   R15,R15              ...\n         ALR   R15,R05              ...\n         ALR   R15,R15              ...\n         AL    R15,aOpCodes         Address of instruction mnemonic\n         CLI   0(R15),C'A'          Q. Valid instruction?\n         JL    PIC200               N. Ignore it then\n         LR    R01,R05              Y. Instruction 1st/2nd byte value\n         ICM   R01,B'0010',HexZeros    Only interested in L.O. byte\n         SLL   R01,1                   Multiply by 2 for entry length\n         LR    R02,R05                 Current index value\n         SRL   R02,8                   Divide by 256 for table number\n         SLL   R02,2                   Multiply by 4 for address length\n         L     R14,aOpIndex(R02)       Address of attribute index table\n         LH    R01,0(R01,R14)          Load attribute index value\n         L     R14,aOpFlags            Attribute table address\n         LA    R14,0(R01,R14)          Attributes for this instruction\n         TM    3(R14),bitFLOAT         Q. Floating point instruction?\n         JZ    PIC110                  N. Must be counted\n         TM    UsrFlag2,Flg$NCFP       Y. Q. FP instructions counted?\n         JO    PIC200                     N. Ignore this one then\n         SPACE\nPIC110   DS    0H\n         LHI   R14,4-1              Max. entries per line minus one\n         LA    R03,PrL$Data+2       Point to first entry on line\n         USING CNT$FLD,R03\n         SPACE\nPIC120   DS    0H\n         CLI   CNT$MNEM,C' '        Q. This entry used?\n         JE    PIC130               N. Go use it\n         LA    R03,CNT$FLD+CNT$LEN  Y. Bump to next entry\n         BRCT  R14,PIC120              and go check it out\n         SPACE\nPIC130   DS    0H\n         LR    R14,R05              Offset to instruction count\n         SLL   R14,2                ...\n         AL    R14,In#Table         Address of instruction count\n         ICM   R02,B'1111',0(R14)   Q. Counter zero?\n         JNZ   PIC140               N. Go process it\n         TM    UsrFlag2,Flg$NPNE    Y. Q. Suppress zero counts?\n         JO    PIC200                  Y. Ignore this instruction then\n         SPACE\nPIC140   DS    0H\n         MVC   CNT$MNEM,0(R15)      Copy mnemonic to print line\n         LR    R00,R05              Convert opcode to display\n         CHI   R00,256+256+16       Q. This an x'01' opcode?\n         JL    PIC150               N. Try x'A7' opcode\n         AHI   R00,-16              Y. Compensate for x'A7' offset\n         ICM   R00,B'0010',=AL1($01)   Set x'01' prefix\n         J     PIC170\n         SPACE\nPIC150   DS    0H\n         CHI   R00,512              Q. This an x'A7' opcode?\n         JL    PIC160               N. Try x'B2' opcode\n         ICM   R00,B'0010',=AL1($A7)\n         J     PIC170\n         SPACE\nPIC160   DS    0H\n         CHI   R00,256              Q. This a x'B2' opcode?\n         JL    PIC180               N. Must be a 2 byte opcode\n         ICM   R00,B'0010',=AL1($B2)\n         SPACE\nPIC170   DS    0H\n         BRAS  R14,HexToEBC         Convert opcode to display hex\n         ST    R01,CNT$OPCD         Move opcode to print line\n         J     PIC190\n         SPACE\nPIC180   DS    0H\n         BRAS  R14,HexToEBC         Convert opcode to display hex\n         STH   R01,CNT$OPCD         Move opcode to print line\n         SPACE\nPIC190   DS    0H\n         CVD   R02,WorkDblW         Convert to packed\n         LA    R02,CNT$ICNT         Load pointer to display areas\n         BRAS  R14,PERCENT          Format count and percentages\n         SPACE\n         CLI   PrL$Data+2+(4-1)*CNT$LEN,C' '\n*                                   Q. Print line full?\n         JE    PIC200               N. Defer printing it\n         MVI   PrL$Data,C'+'        Y. Mark line as instruction counts\n         BRAS  R14,Write               and go print it\n         SPACE\nPIC200   DS    0H\n         LA    R05,1(,R05)          Increment instruction loop counter\n         CHI   R05,256+256+16+4     Q. End of instructions?\n         JL    PIC100               N. Go process next instruction\n         CLI   PrL$Data+2,C' '      Y. Q. Partial print line built?\n         JE    PIC300                  N. Finished with this range\n         MVI   PrL$Data,C'+'           Y. Mark line as instr. counts\n         BRAS  R14,Write                  Print the last (partial) line\n         DROP  R03\n         SPACE\nPIC300   DS    0H\n         TM    In#Entry,X'80'        Q. Last entry in table?\n         JO    PIC900                Y. All finished then\n         LA    R06,In#Entry+IN#$ELEN N. Point to next entry in table\n         J     PIC010                   and go process it\n         DROP  R06\n         SPACE\nPIC900   DS    0H\n         NI    TrcFlag2,255-Trc$NoIH Reset header flag\n         L     R14,PCSAV            Load return address\n         BSM   0,R14                and return\n         TITLE 'Print Execution Profiler Data'\n***********************************************************************\n*                                                                     *\n*        Print data in execution profile table                        *\n*                                                                     *\n***********************************************************************\n         SPACE\nPROFILER DS    0H\n         ST    R14,PFSAV            Save return address\n         ICM   R06,B'1111',EProfTbl Q. Profiler table present?\n         JZ    Prof900              N. Nothing to do then\n         OI    TrcFlag2,Trc$NoIH    Y. No instruction field headers\n         LA    R15,Prof010             Process table in AMODE=31\n         O     R15,BitZero             ...\n         BSM   0,R15                   ...\n         USING PrfEntry,R06\n         SPACE\n*---------------------------------------------------------------------*\n*        Loop for each entry, first print header line                 *\n*---------------------------------------------------------------------*\n         SPACE\nProf010  DS    0H\n         MVC   PLINE(L'EPHEADER),EPHEADER\n         L     R00,PrfStart         Profiler range start address\n         BRAS  R14,HexToEBC         Convert to display\n         STM   R00,R01,PrL$Data+46  ... and place into title\n         L     R00,PRFEND           Profiler range end address\n         BRAS  R14,HexToEBC         Convert to display\n         STM   R00,R01,PrL$Data+55  ... and place into title\n         MVC   PrL$Data+65(L'PRFIDENT),PRFIDENT\n         BRAS  R14,Write            Print title line\n         SPACE\n*---------------------------------------------------------------------*\n*        Find total number of instructions counted in range           *\n*---------------------------------------------------------------------*\n         SPACE\n         L     R15,PRFEND           Calculate size of profile range\n         SL    R15,PrfStart         ...\n         SLR   R14,R14              Clear top half of dividend\n         L     R01,PrfIntvl         Get sub-interval size\n         DR    R14,R01              Calculate number of cells in table\n         LTR   R14,R14              Q. Any remainder?\n         JZ    Prof020              N. Quotient is correct value\n         LA    R15,1(,R15)          Y. Add one for partial cell\n         SPACE\nProf020  DS    0H\n         ST    R15,#Cells           Save number of cells\n         ZAP   WorkPL8,cpZero       Zero cumulative counts for range\n         L     R14,PrfTable         Point to data table\n         SPACE\nProf030  DS    0H\n         ICM   R00,B'1111',0(R14)   Q. Anything to count?\n         JZ    Prof050              N. Ignore it then\n         CVD   R00,WorkDblW         Y. Convert to packed\n         CP    WorkDblW,cpZero         Q. Number negative?\n         JNL   Prof040                 N. Use as is\n         AP    WorkDblW,TwoTo32        Y. Make it unsigned, add 2**32\n         SPACE\nProf040  DS    0H\n         AP    WorkPL8,WorkDblW     Add to total count\n         SPACE\nProf050  DS    0H\n         LA    R14,4(,R14)          Bump to next counter\n         BRCT  R15,Prof030          Repeat for each counter\n         SPACE\n         XC    ZERO1RST,ZERO1RST    Zero first zero count address\n         XC    ZEROLAST,ZEROLAST    Zero last zero count address\n         XC    ZEROFSET,ZEROFSET    Zero offset\n         SLR   R03,R03              Initialise cell id\n         SPACE\n*---------------------------------------------------------------------*\n*        Loop for each cell                                           *\n*---------------------------------------------------------------------*\n         SPACE\nProf060  DS    0H\n         LR    R15,R03              Cell id\n         SLR   R14,R14              Clear top word\n         M     R14,PrfIntvl         Calculate offset\n         LR    R02,R15              Generate start address\n         AL    R02,PrfStart         ...\n         LR    R12,R02              Generate end address\n         AL    R12,PrfIntvl         ...\n         BCTR  R12,0                ...\n         SPACE\n         LR    R01,R03              Cell id\n         SLL   R01,2                Multiply by cell size\n         AL    R01,PrfTable         Address of cell\n         ICM   R05,B'1111',0(R01)   Q. Count zero?\n         JNZ   Prof080              N. Go process it\n         ICM   R14,B'1111',ZERO1RST Y. Q. First zero address available?\n         JNZ   Prof070                 Y. Leave it\n         ST    R02,ZERO1RST            N. Save start address\n         ST    R15,ZEROFSET               ... and offset\n         SPACE\nProf070  DS    0H\n         ST    R12,ZEROLAST         Save new end address\n         J     Prof100\n         SPACE\nProf080  DS    0H\n         ICM   R00,B'1111',ZERO1RST Q. Zero range to print?\n         JZ    Prof090              N. Go do normal print\n         BRAS  R14,HexToEBC         Y. Format start address\n         STM   R00,R01,PrL$Data+11     ...\n         L     R00,ZEROLAST            Format end address of range\n         BRAS  R14,HexToEBC            ...\n         STM   R00,R01,PrL$Data+20     ...\n         L     R00,ZEROFSET            Format offset for printing\n         BRAS  R14,HexToEBC            ...\n         STM   R00,R01,PrL$Data+1      ...\n         MVC   PrL$Data+28(L'NOEXEC),NOEXEC\n         ST    R15,ZEROFSET            Save R15\n         BRAS  R14,Write\n         XC    ZERO1RST,ZERO1RST       Clear first address\n         L     R15,ZEROFSET            Restore R15 after write\n         SPACE\nProf090  DS    0H\n         LR    R00,R15              Offset\n         BRAS  R14,HexToEBC         Convert to display\n         STM   R00,R01,PrL$Data+1   Move to print line\n         SPACE\n         LR    R00,R02              Start address\n         BRAS  R14,HexToEBC         Convert to display\n         STM   R00,R01,PrL$Data+11  Move to print line\n         SPACE\n         LR    R00,R12              End address\n         BRAS  R14,HexToEBC         Convert to display\n         MVI   PrL$Data+19,C'-'\n         STM   R00,R01,PrL$Data+20  Move to print line\n         SPACE\n         CVD   R05,WorkDblW         Convert to packed\n         LA    R02,PrL$Data+30      Load pointer to printline fields\n         BRAS  R14,PERCENT          Format count and percentage\n         BRAS  R14,Write            Write out print line\n         SPACE\nProf100  DS    0H\n         LA    R03,1(,R03)          Bump to next cell\n         CL    R03,#Cells           Q. Any more cells to process?\n         JL    Prof060              Y. Go process them\n         SPACE\n         ICM   R00,B'1111',ZERO1RST N. Q. Zero range to print?\n         JZ    Prof110                 N. Go do normal print\n         BRAS  R14,HexToEBC            Y. Format start address\n         STM   R00,R01,PrL$Data+11        ...\n         L     R00,ZEROLAST               Format end address of range\n         BRAS  R14,HexToEBC               ...\n         STM   R00,R01,PrL$Data+20        ...\n         L     R00,ZEROFSET               Format offset for printing\n         BRAS  R14,HexToEBC               ...\n         STM   R00,R01,PrL$Data+1         ...\n         MVC   PrL$Data+28(L'NOEXEC),NOEXEC\n         BRAS  R14,Write\n         SPACE\nProf110  DS    0H\n         TM    PrfEntry,X'80'        Q. Last entry in table?\n         JO    Prof900               Y. Finished\n         LA    R06,PrfEntry+PRF$ELEN N. Point to next entry\n         J     Prof010                  and go process it\n         DROP  R06\n         SPACE\nProf900  DS    0H\n         NI    TrcFlag2,255-Trc$NoIH Reset header flag\n         L     R14,PFSAV            Load return address\n         BSM   0,R14                and return\n         TITLE 'Format Unsigned Count and Percentage'\n***********************************************************************\n*        Format count as number as well as a percentage               *\n*---------------------------------------------------------------------*\n*        On entry, R02 points to area to place print data             *\n*                  WorkDblW contains count field                      *\n*                  WorkPL8 contains total count                       *\n*                                                                     *\n***********************************************************************\n         SPACE\nPERCENT  DS    0H\n         CP    WorkDblW,cpZero      Q. Is count negative?\n         JNL   PER010               N. Top bit not used\n         AP    WorkDblW,TwoTo32     Y. Convert to unsigned, add 2**32\n         SPACE\nPER010   DS    0H\n         USING CNT$ICNT,R02\n         MVC   WorkCL16(L'EDMask12),EDMask12   Move in edit mask\n         ED    WorkCL16(L'EDMask12),WorkDblW+2 Format instruction count\n         MVC   CNT$ICNT,WorkCL16+2             Move to print line\n         SPACE\n         CP    WorkPL8,WorkDblW     Q. Values equal (100%)?\n         JNE   PER020               N. Go do normal processing\n         MVC   CNT$PCNT,=C'  100%'  Y. Indicate 100%\n         J     PER900\n         SPACE\nPER020   DS    0H\n         ZAP   WorkCL16,WorkDblW    Instruction count\n         SRP   WorkCL16,4,0         Multiply by 10**4 (i.e. 1000)\n         DP    WorkCL16,WorkPL8     Divide by total instruction count\n         OI    WorkCL16+7,X'0F'     Ensure F sign\n         UNPK  WorkDblW(5),WorkCL16+5(3)\n         MVC   CNT$PCNT(2),WorkDblW+1   Whole percentage points\n         MVI   CNT$PCNT+2,C'.'          Decimal point\n         MVC   CNT$PCNT+3(2),WorkDblW+3 100ths of a percentage point\n         MVI   CNT$PCNT+L'CNT$PCNT-1,C'%'\n         CLI   CNT$PCNT,C'0'        Q. First digit zero?\n         JNE   PER900               N. Let it be\n         MVI   CNT$PCNT,C' '        Y. Suppress leading zero\n         SPACE\nPER900   DS    0H\n         BSM   0,R14\n         DROP  R02\n         SPACE 2\n         LTORG ,\n         TITLE 'Print Supervisor Routine Main Line'\n***********************************************************************\n*                                                                     *\n*        Print supervisor                                             *\n*                                                                     *\n***********************************************************************\n         SPACE\nPrintSup DS    0H\n         ST    R14,PSSAV            Save return\n         BRAS  R14,PLINE1           Format location counter\n         BRAS  R14,PrOpCode         Format opcode and operands\n         BRAS  R14,PrintRegs        Format registers used\n         BRAS  R14,PrintEFA         Format storage operands used\n         TM    TrcFlag1,Trc$ModCall Q. Module name present?\n         JZ    PS010                N. Nothing special to be done\n         MVC   PrL$ModuleID,IDstring Y. Move module id to print line\n         SPACE\nPS010    DS    0H\n         BRAS  R14,Write            Print the line\n         TM    bAttribute4,bitDUMPR Q. Print all registers?\n         JZ    PS999                N. Bif not\n         CLI   XCell,$LAM           Y. Q. LAM instruction?\n         JE    PS020                   Y. Don't dump general registers\n         CLI   XCell,$STAM             N. Q. STAM instruction?\n         JE    PS020                      Y. Don't dump general regs\n         SPACE\n         BRAS  R12,DumpGPRs         Dump general registers\n         MVI   PrL$CCB,C'0'         Double space next line\n         CLI   XCell,$LM            Q. LM instruction?\n         JE    PS999                Y. Don't dump ARs\n         CLI   XCell,$STM           N. Q. STM instruction?\n         JE    PS999                   Y. Don't dump ARs\n         SPACE\nPS020    DS    0H\n         BRAS  R12,DumpARs          Dump ARs too\n         MVI   PrL$CCB,C'0'         Double space next line\n         SPACE\nPS999    DS    0H\n         L     R14,PSSAV            Load return address\n         BSM   0,R14                ... and return\n         TITLE 'Format Location Counter and Hex Instruction Image'\n***********************************************************************\n*                                                                     *\n*        Format the pseudo instruction pointer, ASC mode, hexadecimal *\n*        instruction image and the condition code onto the print line *\n*                                                                     *\n***********************************************************************\n         SPACE\nPLINE1   DS    0H\n         ST    R14,P1SAV            Save return address\n         SPACE\n*---------------------------------------------------------------------*\n*        Format instruction pointer (PSW bits 32-63)                  *\n*---------------------------------------------------------------------*\n         SPACE\n         LR    R00,R11              Copy instruction pointer\n         O     R00,OldAMODE         Merge in addressing mode bit\n         BRAS  R14,HexToEBC         Convert it for printing\n         STM   R00,R01,PrL$ILC      Place it in the print line\n         SPACE\n*---------------------------------------------------------------------*\n*        Format Address Space Control (ASC) mode                      *\n*---------------------------------------------------------------------*\n         SPACE\n         SLR   R01,R01              Zero H.O. 3 bytes of work register\n         IC    R01,TraceASC         Address Space Control mode\n         IC    R00,ASCmodes(R01)    Get corresponding character\n         STC   R00,PrL$ASC          Place character in print line\n         SPACE\n*---------------------------------------------------------------------*\n*        Format instruction image                                     *\n*---------------------------------------------------------------------*\n         SPACE\n         L     R00,XCell            Get the instruction image\n         BRAS  R14,HexToEBC         Convert 1st four bytes\n         STCM  R00,15,PrL$ObjCode   Place 1st 2 bytes in print line\n         TM    bAttribute2,bitRR    Q. RR type instruction?\n         JO    P1CC                 Y. Only print two bytes\n         STCM  R01,15,PrL$ObjCode+4 N. Place 2nd 2 bytes in print line\n         TM    bAttribute2,bitSS       Q. SS/SSe type instruction?\n         JZ    P1CC                    N. Only print 4 bytes\n         L     R00,XCell+4             Y. Last 2 bytes of instruction\n         BRAS  R14,HexToEBC               Convert for printing\n         STCM  R00,15,PrL$ObjCode+8       ... and place in print line\n         SPACE\n*---------------------------------------------------------------------*\n*        Format condition code                                        *\n*---------------------------------------------------------------------*\n         SPACE\nP1CC     DS    0H\n         SLR   R01,R01              Clear R01\n         IC    R01,TraceCC          Actual condition code\n         IC    R00,EBDCC(R01)       Get corresponding character\n         STC   R00,PrL$CondCode     Place character in print line\n         SPACE\n*---------------------------------------------------------------------*\n*        Format branch indicator (successful branches only)           *\n*---------------------------------------------------------------------*\n         SPACE\n         TM    TrcFlag1,Trc$Branch  Q. Branch taken?\n         JZ    P1EXIT               N. Finished then\n***                                 Y. Indicate branch taken\n         MVC   PrL$BranchDir,BranchDir ...\n         L     R15,BranchTgt           Get branch address\n         TM    TraceAMODE,X'80'        Q. 31-bit addressing mode?\n         JO    P1MODE31                Y. Don't clear top byte\n         ICM   R15,B'1000',HexZeros    N. Clear top byte\n         SPACE\nP1MODE31 DS    0H\n         N     R15,SevenFs          Ensure top bit clear for compare\n         CLR   R11,R15              Q.  Which direction is branch?\n         JL    P1BRFOR              Lo. Forward branch\n         JE    P1EXIT               Eq. Branch to itself???\n         MVI   PrL$BranchDir+1,C'-' Hi. Indicate backwards branch\n         J     P1EXIT                   ... and return\n         SPACE\nP1BRFOR  DS    0H\n         MVI   PrL$BranchDir,C'-'   Indicate forward branch\n         SPACE\nP1EXIT   DS    0H\n         L     R14,P1SAV\n         BSM   0,R14                Return\n         TITLE 'Format Symbolic Opcode and Operands'\n***********************************************************************\n*                                                                     *\n*        Place the symbolic instruction code and the instruction      *\n*        fields in assembly format into the print line.               *\n*                                                                     *\n***********************************************************************\n         SPACE\nPrOpCode DS    0H\n         ST    R14,POSAV            Save return address\n         L     R14,aOpCodes         Point to standard mnemonic table\n         SLR   R01,R01              Ensure H.O. 3-bytes are zero\n         IC    R02,XCell+1          RR/RX/RS register specifiers\n         IC    R01,XCell            Instruction code\n         SPACE\n         CLI   XCell,$B2            Q. X'B2' type instruction?\n         JNE   PO010                N. Go check if x'A7' instruction\n         IC    R01,XCell+1          Y. Use 2nd byte of instruction\n         L     R14,aB2codes            ... and use X'B2' mnemonic table\n         IC    R02,XCell+3             Register specifiers for RRE\n         J     PO030\n         SPACE\nPO010    DS    0H\n         CLI   XCell,$A7            Q. X'A7' type instruction?\n         JNE   PO020                N. Go check if x'01' instruction\n         IC    R01,XCell+1          Y. Use 2nd byte of instruction\n         N     R01,OOOOOOOF            Clear out register specifier\n         L     R14,aA7codes            ... and use X'A7' mnemonic table\n         J     PO030\n         SPACE\nPO020    DS    0H\n         CLI   XCell,$01            Q. X'01' type instruction?\n         JNE   PO030                N. Use the standard table\n         IC    R01,XCell+1          Y. Use 2nd byte of instruction\n         L     R14,a01codes            ... and use X'01' mnemonic table\n         SPACE\nPO030    DS    0H\n         LR    R00,R01\n         ALR   R01,R01              (instruction code)*2\n         ALR   R01,R00              (instruction code)*3\n         ALR   R01,R01              (instruction code)*6\n         LA    R01,0(R01,R14)       Address of instruction mnemonic\n         MVC   PrL$Mnemonic,0(R01)  Place in print line\n         LA    R03,PrL$Operands     Point R03 at operand area\n         SPACE\n         TM    bAttribute1,bitCC    Q. Instruction set condition code?\n         JZ    PO040                N. Ignore it then\n         MVC   LastCCOp,0(R01)      Y. Save it for EMC test\n         SPACE\nPO040    DS    0H\n         CLI   XCell,$01            Q. X'01' type instruction?\n         JE    PO999                N. No operands\n         TM    UsrFlag2,Flg$NoPrEMC Y. Q. Want extended mnemonic codes?\n         JO    PO200                   N. Bypass EMC logic\n         SPACE\n*---------------------------------------------------------------------*\n*        Translate BC, BCR and BRC to Extended Mnemonic Codes (EMC)   *\n*---------------------------------------------------------------------*\n         SPACE\n         CLI   XCell,$BC            Q. BC instruction?\n         JE    PO100                Y. Process extended mnemonic\n         CLI   XCell,$BCR           N. Q. BCR instruction?\n         JE    PO100                   Y. Process extended mnemonic\n         CLC   =C'BRC',0(R01)          N. Q. BRC instruction?\n         JNE   PO200                      N. Not a conditional branch\n         TM    XCell+1,X'F0'              Y. Q. JNOP instruction?\n         JNE   PO100                         N. Go process EMC\n         MVC   PrL$Mnemonic,=CL6'JNOP'       Y. Indicate JNOP\n         SLR   R01,R01                          Indicate no index\n         J     PO700                            Go process target\n         SPACE\nPO100    DS    0H\n         LA    R14,EMstandard       Default is standard mnemonic table\n         CLI   LastCCOp,C'C'        Q. Was it a compare instruction?\n         JE    PO110                Y. Go use compare table\n         CLC   =C'MVCL',LastCCOp    N. Q. Was it a MVCL(E) instruction?\n         JNE   PO120                   N. Use standard mnemonic table\n         SPACE\nPO110    DS    0H\n         LA    R14,EMcompare        Use the compare mnemonic table\n         SPACE\nPO120    DS    0H\n         ICM   R15,B'1000',XCell+1  Load branch mask byte\n         SRL   R15,28               Shift into low order nybble\n         SLL   R15,2                Multiply by 4 for mnemonic offset\n         LA    R14,0(R15,R14)       Point to extended mnemonic\n         CLI   0(R14),C' '          Q. Is there an extended mnemonic?\n         JE    PO200                N. Just use standard menonic\n         MVC   PrL$Mnemonic(4),0(R14) Y. Replace the standard mnemonic\n         TM    bAttribute2,bitRR       Q. BCR instruction?\n         JO    PO130                   Y. Go append R to mnemonic\n         TM    bAttribute2,bitIMREL    N. Q. BRC instruction?\n         JZ    PO600                      N. Must have been BC\n         MVI   PrL$Mnemonic,C'J'          Y. Indicate it's a JUMP\n         J     PO600\n         SPACE\nPO130    DS    0H\n         LA    R15,PrL$Mnemonic+1   Second byte of mnemonic\n         LHI   R14,3                Number of bytes to test\n         SPACE\nPO140    DS    0H\n         CLI   0(R15),C' '          Q. End of mnemonic found?\n         JE    PO150                Y. Go append the 'R'\n         LA    R15,1(,R15)          N. Bump to the next byte\n         BCT   R14,PO140               Loop until a blank found\n         SPACE\nPO150    DS    0H\n         MVI   0(R15),C'R'          Indicate it's an RR instruction\n         J     PO520                Go format register number\n         SPACE\n*---------------------------------------------------------------------*\n*        Prepare the instruction fields in assembly format            *\n*---------------------------------------------------------------------*\n         SPACE\nPO200    DS    0H\n         TM    bAttribute2,bitRR+bitRX+bitRS\n*                                   Q. Is first operand a register?\n         JNZ   PO500                Y. Go split the field into R,X\n         SLR   R01,R01              N. Indicate no index register\n         LH    R00,XCell+2             bddd\n         BRAS  R14,BDproc              'ddd(b)'\n         TM    bAttribute2,bitSS       Q. SS/SSE type instruction?\n         JZ    PO400                   N. Must be S/SI type instruction\n         TM    bAttribute1,bitPACKD    Y. Q. Decimal instruction?\n         JO    PO300                      Y. Format packed decimal SS\n         TM    bAttribute2,bitIMDF        N. Q. SSE instruction?\n         JZ    PO210                         Y. No length field then\n         SPACE\n*---------------------------------------------------------------------*\n*        Finish up type SS(E) instruction (non-decimal)               *\n*---------------------------------------------------------------------*\n         SPACE\n         AHI   R03,-3               Back up the field pointer\n         MVC   5(2,R03),1(R03)      'ddd(    b)'\n         SLR   R01,R01              Clear R01\n         IC    R01,XCell+1          ll        (machine) length field\n         LA    R00,1(,R01)          lll       Add one for real length\n         BRAS  R14,HexToEBC         Convert to display\n         STCM  R01,B'0111',1(R03)   'ddd(lll b)'\n         MVI   4(R03),C','          'ddd(lll,b)'\n         LA    R03,7(,R03)          Adjust the field pointer\n         SPACE\nPO210    DS    0H\n         MVI   0(R03),C','          'ddd(lll,b),' or 'ddd(b),'\n         LA    R03,1(,R03)          Adjust field pointer\n         LH    R00,XCell+4          bddd      2nd base,displacement\n         SLR   R01,R01              Indicate no index register\n         BRAS  R14,BDproc           'ddd(lll,b),ddd(b)'\n         J     PO999                We're done\n         SPACE\n*---------------------------------------------------------------------*\n*        Format packed decimal instruction operands                   *\n*---------------------------------------------------------------------*\n         SPACE\nPO300    DS    0H\n         AHI   R03,-3               Back up the field pointer\n         MVC   4(2,R03),1(R03)      'ddd(   b)'\n         IC    R01,XCell+1          ll        (machine) length field\n         N     R01,OOOOOOFO         l0\n         SRL   R01,4                l\n         LA    R00,1(,R01)          l+1       Real length\n         BRAS  R14,HexToEBC         Convert to display\n         STCM  R01,B'0011',1(R03)   'ddd(ll b)'\n         MVI   3(R03),C','          'ddd(ll,b)'\n         MVI   6(R03),C','          'ddd(ll,b),'\n         LA    R03,7(,R03)          Adjust the field pointer\n         SPACE\n         LH    R00,XCell+4          bddd      2nd base,displacement\n         SLR   R01,R01              Indicate no index register\n         BRAS  R14,BDproc           'ddd(ll,b),ddd(b)'\n         CLI   XCell,$SRP           Q. SRP instruction?\n         JE    PO310                Y. Go complete formatting SRP\n         SPACE\n         AHI   R03,-3               Back up the field pointer\n         MVC   4(2,R03),1(R03)      'ddd(ll,b),ddd(  b)'\n         IC    R01,XCell+1          ll        Length field\n         N     R01,OOOOOOOF         l\n         LA    R00,1(,R01)          l+1       Real length\n         BRAS  R14,HexToEBC         Convert to display\n         STCM  R01,B'0011',1(R03)   'ddd(ll,b),ddd(ll b)'\n         MVI   3(R03),C','          'ddd(ll,b),ddd(ll,b)'\n         J     PO999                Finished\n         SPACE\nPO310    DS    0H\n         MVI   0(R03),C','          'ddd(ll,b),ddd(b),'\n         IC    R01,XCell+1          li        Length field\n         N     R01,OOOOOOOF         i\n         IC    R01,HexChar(R01)     'i'\n         STC   R01,1(,R03)          'ddd(ll,b),ddd(b),i'\n         J     PO999                We're done\n         SPACE\n*---------------------------------------------------------------------*\n*        Format immediate field of SI instruction                     *\n*---------------------------------------------------------------------*\n         SPACE\nPO400    DS    0H\n         TM    bAttribute2,bitIMDF  Q. S type instruction?\n         JZ    PO999                Y. No immediate field then\n         MVI   0(R03),C','          N. 'ddd(b),'\n         SLR   R01,R01                 Clear R01\n         IC    R01,XCell+1             ii        Immediate field\n         SRL   R01,4                   i\n         IC    R01,HexChar(R01)        'i'\n         STC   R01,1(,R03)             'ddd(b),i'\n         IC    R01,XCell+1             ii\n         N     R01,OOOOOOOF            0i\n         IC    R01,HexChar(R01)        'i'\n         STC   R01,2(,R03)             'ddd(b),ii'\n         J     PO999                   We're done\n         SPACE\n*---------------------------------------------------------------------*\n*        Split the second byte of the instruction into r,x or r,r     *\n*---------------------------------------------------------------------*\n         SPACE\nPO500    DS    0H\n         LR    R01,R02              RX or RR register specifiers\n         N     R01,OOOOOOFO         r0\n         SRL   R01,4                r\n         IC    R00,HexChar(R01)     'r'\n         STC   R00,0(,R03)          'r'\n         LA    R03,1(,R03)          Adjust field pointer\n         CLI   XCell,$SVC           Q. SVC instruction?\n         JNE   PO510                N. Skip SVC specific code\n         CLI   XCell+1,HighSVC      Y. Q. SVC code in table?\n         JH    PO520                   Y. Must be a user SVC\n         SLR   R14,R14                 N. Clear index register\n         IC    R14,XCell+1                Get SVC number\n         SLL   R14,3                      Multiply by 8\n         AL    R14,aSVCtable              Address of SVC entry\n         IC    R15,5(,R14)                Length of mnemonic for EX\n         L     R01,0(,R14)                Address of mnemonic\n         EX    R15,MoveSVC                Copy mnemonic to print line\n***      MVC   PrL$SVC(0),0(R01)          ...\n         LH    R15,6(,R14)                Offset for special processing\n         LTR   R15,R15                    Q. Any special processing?\n         JM    PO520                      N. Bif not\n         LA    R01,PrL$SVC+2              Y. Point to operand area\n         AH    R01,4(,R14)                   ...\n         L     R14,aSVC_Ops                  Get address of SVC operand\n         L     R15,0(R15,R14)                ... special processing rtn\n         BASR  R14,R15                       and invoke it\n         J     PO520                         Go format operand as 'ii'\n         SPACE\nPO510    DS    0H\n         MVI   0(R03),C','          'r,'\n         LA    R03,1(,R03)          Adjust field pointer\n         TM    bAttribute2,bitRR+bitRS Q. Need to format 'r,r'?\n         JZ    PO600                N. Bif not\n         TM    bAttribute3,bitSHIFT Y. Q. Shift instruction?\n         JO    PO600                   Y. r2 is not used\n         CLI   XCell,$A7               N. Q. x'A7' prefixed opcode?\n         JE    PO600                      Y. r2 is part of opcode\n         SPACE\nPO520    DS    0H\n         LR    R01,R02              rr     Register specifiers\n         N     R01,OOOOOOOF         0r\n         IC    R00,HexChar(R01)     'r'\n         STC   R00,0(,R03)          'r,r'\n         TM    bAttribute2,bitRR    Q. RR instruction?\n         JO    PO999                Y. Finished\n         TM    bAttribute2,bitRRE   N. Q. RRE instruction?\n         JO    PO999                   Y. Finished\n         SLR   R01,R01                 N. RS has no index register\n         MVI   1(R03),C','                'r,r,'\n         LA    R03,2(,R03)                Adjust the field pointer\n         J     PO700                      Evaluate base, displacement\n         SPACE\nPO600    DS    0H\n         IC    R01,XCell+1          rx\n         N     R01,OOOOOOOF         0x\n         SPACE\nPO700    DS    0H\n         LH    R00,XCell+2          bddd      Base and displacement\n         BRAS  R14,BDproc           'r,ddd(x,b)'  or    'r,ddd(b)'\n         SPACE\nPO999    DS    0H\n         L     R14,POSAV            Load return address\n         BSM   0,R14                Return\n         TITLE 'Format Base-Displacement-Index Fields for Operands'\n***********************************************************************\n*                                                                     *\n*        Format the base, displacement, & index fields into assembly  *\n*        format for printing.                                         *\n*        On entry:                                                    *\n*              R00 contains the 'base,displacement' (as a halfword)   *\n*              R01 contains the number of the index register          *\n*                                                                     *\n*        On exit:                                                     *\n*              Either 'ddd(b) or 'ddd(x,b)' is placed into the        *\n*              instruction image at the address specified bt R03.     *\n*              R00 and R01 are destroyed, R03 is modified             *\n*                                                                     *\n***********************************************************************\n         SPACE\nBDproc   DS    0H\n         ST    R14,BDSAV            Save return address\n         TM    bAttribute2,bitIMREL Q. Relative/immediate instruction?\n         JZ    BD010                N. Must be base,displacement format\n         BRAS  R14,HexToEBC         Y. Convert value to hex\n         ST    R01,0(,R03)             Display halfword value\n         LA    R03,4(,R03)             Adjust output pointer\n         J     BD999\n         SPACE\nBD010    DS    0H\n         ST    R00,BDTEMP           Save  bddd\n         ST    R01,BDTEMP2          Save index specifier\n         N     R00,OOOOOFFF         ddd       displacement\n         BRAS  R14,HexToEBC         Convert for printing\n         L     R00,BDTEMP2          x          index register\n         ST    R01,BDTEMP2          '0ddd'\n         MVC   0(3,R03),BDTEMP2+1   'ddd'\n         MVI   3(R03),C'('          'ddd('\n         LTR   R01,R00              Q. Is an index specified?\n         JZ    BD020                N. Zero specifies no index\n         IC    R01,HexChar(R01)     Y. 'x'\n         STC   R01,4(R03)              'ddd(x'\n         MVI   5(R03),C','             'ddd(x,'\n         LA    R03,2(,R03)             Adjust pointer for the index\n         SPACE\nBD020    DS    0H\n         L     R01,BDTEMP           bddd     Base, displacement\n         N     R01,OOOOFOOO         b000\n         SRL   R01,12               b        Base register\n         IC    R01,HexChar(R01)     'b'\n         STC   R01,4(,R03)          'ddd,x,b'     or   'ddd(b'\n         MVI   5(R03),C')'          'ddd(x,b)'   or   'ddd(b)'\n         LA    R03,6(,R03)          Adjust field pointer\n         SPACE\nBD999    DS    0H\n         L     R14,BDSAV            Load return address\n         BSM   0,R14                Return\n         TITLE 'Display Registers used by Instructions'\n***********************************************************************\n*                                                                     *\n*         Routine to place the operand registers referenced by the    *\n*         instruction into the print line                             *\n*                                                                     *\n***********************************************************************\n         SPACE\nPrintRegs DS   0H\n         TM    bAttribute2,bitRR+bitRX+bitRS\n***                                      Q. Instruction use registers?\n         BZR   R14                       N. So return\n         CLI   XCell,$01                 Y. Q. E format instruction?\n         BER   R14                          Y. Has no operands\n         ST    R14,PRSAV                    N. Save return address\n         IC    R03,XCell+1                     Load register specifiers\n         TM    bAttribute1,bitBR               Q. Branch instruction?\n         JZ    PR020                           N. Bif not\n         SPACE\n*---------------------------------------------------------------------*\n*        Instruction is a branch, so test to see if it is a branch    *\n*        condition, in which case the r1 field is actually the mask   *\n*        against the condition code                                   *\n*---------------------------------------------------------------------*\n         SPACE\n         CLI   XCell,$BC            Q. Is the instruction BC?\n         JE    PR010                Y. Display cond-code mask only\n         CLI   XCell,$BCR           N. Q. Is the instruction BCR?\n         JE    PR010                   Y. Display cond-code mask only\n         CLI   XCell,$A7               N. Q. Is the instruction BRC?\n         JNE   PR020                      N. Bif not\n         SPACE\nPR010    DS    0H\n         IC    R00,PrL$ObjCode+2    r (condition code mask) in EBCDIC\n         STC   R00,PrL$Reg1+7       Store in register field\n         LA    R02,TraceGPRs        Address of register table\n         J     PR100                Go test for type RR instruction\n         SPACE\nPR020    DS    0H\n         TM    bAttribute2,bitRRE   Q. RRE instruction?\n         JNO   PR030                N. Got correct register specifiers\n         IC    R03,XCell+3          Y. Load correct register specifiers\n         SPACE\nPR030    DS    0H\n         CLI   XCell,$SVC           Q. SVC instruction?\n         JE    PR999                Y. Doesn't actually use registers\n         LR    R01,R03              N. rr\n         N     R01,OOOOOOFO            r0\n         SRL   R01,2                   r*4\n         LA    R02,TraceGPRs           Address of register table\n         TM    bAttribute4,bitFLOAT    Q. Floating point instruction?\n         JZ    PR040                   N. Use general registers\n         LA    R02,FPR0                Y. Use floating point registers\n         STD   0,FPR0                     Load FP register table\n         STD   2,FPR2                     ...\n         STD   4,FPR4                     ...\n         STD   6,FPR6                     ...\n         J     PR060\n         SPACE\nPR040    DS    0H\n         CLI   Xcell,$LAM           Q.  LAM instruction?\n         JL    PR060                Lo. r1 must be a general register\n         CLI   Xcell,$STAM          NL. Q. STAM instruction?\n         JNH   PR050                    NH. LAM/STAM references AR\n         CLI   Xcell,$B2                Hi. Q. x'B2' code?\n         JNE   PR060                        N. r1 is a general register\n         CLI   Xcell+1,$TAR                 Y. Q.  TAR instruction?\n         JL    PR060                           Lo. r1 cannot be an AR\n         CLI   Xcell+1,$SAR                    NL. Q. SAR instruction?\n         JH    PR060                               Hi. r1 must be a GPR\n         SPACE\nPR050    DS    0H\n         LA    R02,TraceARs         Use access register table\n         SPACE\nPR060    DS    0H\n         L     R00,0(R01,R02)       Get the value of the register\n         LR    R15,R01              Save register number\n         BRAS  R14,HexToEBC         Convert value for printing\n         STM   R00,R01,PrL$Reg1     Place in print line\n         TM    bAttribute3,bitDBLR  Q. Doubleword register operand?\n         JZ    PR100                N. Go process r2 as single register\n         L     R00,4(R15,R02)       Y. Value of register r1+1\n         BRAS  R14,HexToEBC            Convert for printing\n         STM   R00,R01,PrL$DR1         Place in print line\n         TM    bAttribute2,bitRR+bitRS Q. RR or RRE instruction?\n         JZ    PR999                   N. Finished\n         SPACE\n*---------------------------------------------------------------------*\n*        Process r2 when double registers are used                    *\n*---------------------------------------------------------------------*\n         SPACE\n         LR    R01,R03              rr\n         N     R01,OOOOOOOF         0r\n         SLL   R01,2                r*4\n         L     R00,0(R01,R02)       Get register value\n         LR    R15,R01              Save register number\n         BRAS  R14,HexToEBC         Convert for printing\n         STM   R00,R01,PrL$DR2A     Place in print line\n         L     R00,4(R15,R02)       Get 2nd half of value\n         BRAS  R14,HexToEBC         Convert for printing\n         STM   R00,R01,PrL$DR2B     Place in print line\n         J     PR999                Finished\n         SPACE\n*---------------------------------------------------------------------*\n*        Check if a second (single) register is specified             *\n*---------------------------------------------------------------------*\n         SPACE\nPR100    DS    0H\n         TM    bAttribute2,bitRR+bitRS\n***                                 Q. RR(E) or RS instruction?\n         JZ    PR999                N. No second register present\n         TM    bAttribute3,bitSHIFT+bitMASK\n***                                 Y. Q. Shift or mask instruction?\n         JNZ   PR999                   Y. No second register\n         CLI   XCell,$A7               N. Q. x'A7' instruction?\n         JE    PR999                      Y. No second register\n         SPACE\n*---------------------------------------------------------------------*\n*        EAR, SAR and TAR use both general and access registers       *\n*---------------------------------------------------------------------*\n         SPACE\n         CLI   XCell,$B2            Q. x'B2' prefixed instruction?\n         JNE   PR130                N. r1 and r2 are of the same type\n         CLI   XCell+1,$TAR         Y. Q.  Is this a TAR instruction?\n         JL    PR130                   Lo. r1/r2 must be same type\n         JE    PR120                   Eq. TAR r2 is a general register\n         CLI   XCell+1,$EAR            Hi. Q.  This an EAR instruction?\n         JH    PR130                       Hi. r1/r2 must be same type\n         JL    PR110                       Lo. Must be SAR or CPYA\n         LA    R02,TraceARs                Eq. r2 of EAR is an AR\n         J     PR130\n         SPACE\nPR110    DS    0H\n         CLI   XCell+1,$SAR         Q. Is this a SAR instruction?\n         JNE   PR130                N. Register type did not change\n         SPACE\nPR120    DS    0H\n         LA    R02,TraceGPRs        Switch to general register table\n         SPACE\nPR130    DS    0H\n         LR    R01,R03              rr\n         N     R01,OOOOOOOF         0r\n         SLL   R01,2                r*4\n         L     R00,0(R01,R02)       Value of the register\n         BRAS  R14,HexToEBC         Convert for printing\n         STM   R00,R01,PrL$Reg2     Place in print line\n         SPACE\nPR999    DS    0H\n         L     R14,PRSAV            Load return address\n         BSM   0,R14                and return\n         TITLE 'Display Operand Effective Addresses and their Contents'\n***********************************************************************\n*                                                                     *\n*        Place the effective address of the instruction operand and   *\n*        the contents at that memory location onto the print line.    *\n*                                                                     *\n***********************************************************************\n         SPACE\nPrintEFA DS    0H\n         ST    R14,PESAV            Save return address\n         TM    bAttribute2,bitRR    Q. RR type instruction?\n         JO    PE050                Y. Go check if MVCL or CLCL\n         TM    bAttribute2,bitRRE   N. Q. Type RRE instruction?\n         BOR   R14                     Y. No memory reference\n         TM    bAttribute2,bitIMREL    N. Q. RSI/RI instruction?\n         JZ    PE010                      N. Go evaluate address\n         TM    bAttribute1,bitBR          Y. Q. Relative branch?\n         BZR   R14                           N. Nothing left to do\n         SPACE\n*---------------------------------------------------------------------*\n*        Evaluate effective address of relative branch                *\n*---------------------------------------------------------------------*\n         SPACE\n         BRAS  R14,EvalRI           Evaluate relative address\n         BRAS  R14,HexToEBC         Convert address for printing\n         STM   R00,R01,PrL$Address1 Place address in print line\n         J     PE999                We're done\n         SPACE\n*---------------------------------------------------------------------*\n*        Evaluate effective address of first storage operand          *\n*---------------------------------------------------------------------*\n         SPACE\nPE010    DS    0H\n         CLI   XCell,$MVCLE         Q. MVCLE instruction?\n         JL    PE020                N. Must be standard RX/RS\n         CLI   XCell,$CLCLE         Y. Q. MVCLE/CLCLE instruction?\n         JNH   PE060                   N. Must be standard RX/RS\n         SPACE\nPE020    DS    0H\n         LA    R02,XCell+2          Address of base, displacement\n         TM    bAttribute2,bitRX    Q. RX type instruction?\n         JZ    PE030                N. Has no index register then\n         BRAS  R14,EvalXBD          Y. Evaluate indexed address\n         J     PE040                   and go place in print line\n         SPACE\nPE030    DS    0H\n         BRAS  R14,EvalBD           Evaluate address, no index\n         CLI   XCell,$CDS           Q. CDS instruction?\n         JNE   PE040                N. Go process first storage operand\n         LHI   R03,8                Y. Operand length is 8\n         LR    R02,R00                 Save effective address\n         J     PE410                   Format onto 2nd operand area\n         SPACE\n*---------------------------------------------------------------------*\n*        Format effective address of first storage operand            *\n*---------------------------------------------------------------------*\n         SPACE\nPE040    DS    0H\n         LR    R02,R00              Save effective address\n         BRAS  R14,HexToEBC         Convert address for printing\n         STM   R00,R01,PrL$Address1 Place address in print line\n         TM    bAttribute3,bitSHIFT+bitNOREF\n*                                   Q. Really an address?\n         JNZ   PE999                N. No storage referenced\n         CLI   XCell,$MVCS          Y. Q. MVCS instruction?\n         JNE   PE080                   N. Go get operand length\n         J     PE400                   Y. Cannot access secondary a/s\n         SPACE\nPE050    DS    0H\n         CLI   XCell,$MVCL          Q. Possibly MVCL or CLCL?\n         BLR   R14                  N. No storage operands\n         CLI   XCell,$CLCL          Y. Q. Actually MVCL or CLCL?\n         BHR   R14                     N. No storage operands\n         SPACE\nPE060    DS    0H\n         IC    R15,XCell+1          rr\n         N     R15,OOOOOOFO         r0 (destination register)\n         SRL   R15,2                (r0 >> 4) * 4\n         SLR   R04,R04              Assume we're not in AR ASC mode\n         CLI   TraceASC,ARmode      Q. In AR ASC mode?\n         JNE   PE070                N. Default value is good\n         L     R04,TraceARs(R15)    Y. Load associated ALET\n         SPACE\nPE070    DS    0H\n         L     R02,OldRegs(R15)     Original 1st operand address\n         LA    R02,0(,R02)          Clear top byte/bit\n         LR    R00,R02              Pass to conversion routine\n         BRAS  R14,HexToEBC         Convert address for printing\n         STM   R00,R01,PrL$Address1 Place address in print line\n         L     R03,OldRegs+4(R15)   Get length register\n         TM    bAttribute2,bitRR    Q. MVCL or CLCL instruction?\n         JZ    PE300                N. Length is 4-bytes\n         ICM   R03,B'1000',HexZeros Y. Ensure top byte is zero\n         J     PE300                   Go get operand\n         SPACE\n*---------------------------------------------------------------------*\n*        Get length of storage operand(s)                             *\n*---------------------------------------------------------------------*\n         SPACE\nPE080    DS    0H\n         TM    bAttribute3,bitDBLS+bitFULL+bitHALF+bitBYTE\n*                                   Q. Fixed length operand?\n         JZ    PE100                N. We need to calculate length\n         LHI   R03,4                Y. Assume fullword operand\n         TM    bAttribute3,bitFULL     Q. Really fullword operand?\n         JO    PE300                   Y. Go calculate address\n         LHI   R03,1                   N. Assume byte operand\n         TM    bAttribute3,bitBYTE        Q. Really byte operand?\n         JO    PE300                      Y. Go calculate address\n         LHI   R03,8                      N. Assume doubleword operand\n         TM    bAttribute3,bitDBLS           Q. Really doubleword?\n         JO    PE300                         Y. Go calculate address\n         LHI   R03,2                         N. Must be halfword\n         J     PE300                            Go calculate address\n         SPACE\n*---------------------------------------------------------------------*\n*        Get length of target of execute instruction                  *\n*---------------------------------------------------------------------*\n         SPACE\nPE100    DS    0H\n         TM    bAttribute4,bitEX    Q. Execute instruction?\n         JZ    PE200                N. Try next instruction type\n         SLR   R15,R15              Y. Clear work register\n         LR    R03,R15                 ... and length register\n         IC    R15,0(,R02)             First byte of target instruction\n         SRL   R15,6                   Instruction length specifiers\n         IC    R03,BitCount(R15)       Number of halfwords minus one\n         LA    R03,1(,R03)             Number of halfwords\n         ALR   R03,R03                 Times two gives number of bytes\n         CLI   0(R02),$SVC             Q. SVC instruction?\n         JNE   PE300                   N. Go get actual operands\n         IC    R14,XCell+1             Y. Get rr\n         N     R14,OOOOOOFO               Q. EXecute using register 0?\n         JNZ   PE110                      N. Go OR reg with storage\n         SLR   R14,R14                    Y. Register value is ignored\n         IC    R14,1(,R02)                   Just use operand value\n         J     PE120\n         SPACE\nPE110    DS    0H\n         SRL   R14,2                r*4  (right 4 + left 2 = right 2)\n         L     R14,OldRegs(R14)     Original register contents\n         MVC   WorkCL5+3(1),1(R02)  Second byte of SVC instruction\n         O     R14,WorkCL5          OR with register\n         ICM   R14,B'1110',HexZeros Clear top 3 bytes\n         SPACE\nPE120    DS    0H\n         CLM   R14,B'0001',=AL1(HighSVC)\n*                                   Q. Is this a user SVC?\n         JH    PE300                Y. No known mnemonic then\n         SLL   R14,3                   Multiply by 8\n         AL    R14,aSVCtable           Address of SVC descriptor entry\n         IC    R15,5(,R14)             Length for move\n         L     R01,0(,R14)             Address of SVC macro name\n         EX    R15,MoveExSVC           Copy to print line\n***      MVC   PrL$ESVC(0),0(R01)      ...\n         LH    R15,6(,R14)             Offset for special processing\n         LTR   R15,R15                 Q. Any special processing?\n         JM    PE300                   N. Bif not\n         LA    R01,PrL$ESVC+2          Y. Point to operand output area\n         AH    R01,4(,R14)                ...\n         L     R14,aSVC_Ops               Get address of SVC operand\n         L     R15,0(R15,R14)             ... processing routine\n         BASR  R14,R15                    and invoke it\n         J     PE300                      Go get actual instruction\n         SPACE\n*---------------------------------------------------------------------*\n*        Get number of bytes used by CLM, STCM or ICM instruction     *\n*---------------------------------------------------------------------*\n         SPACE\nPE200    DS    0H\n         TM    bAttribute1,bitBR    Q. Branch instruction?\n         JO    PE999                Y. Ignore contents of storage\n         TM    bAttribute2,bitRS    N. Q. RS instruction?\n         JZ    PE220                   N. Must be a SS/S instruction\n         TM    bAttribute3,bitMASK     Y. Q. Mask instruction?\n         JZ    PE210                      N. Must be STM or LM then\n         IC    R15,XCell+1                Y. rm\n         N     R15,OOOOOOOF                  0m\n         IC    R15,BitCount(R15)             Number of bits in m\n         LTR   R03,R15                       Q. Zero length operand?\n         JZ    PE999                         Y. No storage operand\n         J     PE300                         N. Go get storage operand\n         SPACE\nPE210    DS    0H\n         TM    bAttribute4,bitDUMPR Q. STM or LM instruction?\n         BZ    *+1                  N. This should never happen!!!!!!\n         LHI   R03,8                Y. Operand length is 8 (max)\n         J     PE300\n         SPACE\n*---------------------------------------------------------------------*\n*        Get length of first operand of a packed decimal instruction  *\n*---------------------------------------------------------------------*\n         SPACE\nPE220    DS    0H\n         TM    bAttribute1,bitPACKD Q. Packed decimal instruction?\n         JZ    PE230                N. Go try next instruction type\n         IC    R15,XCell+1          Y. Get ll byte (l1,l2)\n         N     R15,OOOOOOFO            Mask off l1\n         SRL   R15,4                   Shift into bottom nybble\n         LA    R03,1(,R15)             Add one for real length\n         J     PE300\n         SPACE\n*---------------------------------------------------------------------*\n*        Get length of operand from ss instruction with byte length   *\n*---------------------------------------------------------------------*\n         SPACE\nPE230    DS    0H\n         TM    bAttribute1,bitMVCX  Q. MVCK/MVCP/MVCS instruction?\n         JO    PE240                Y. Length is in a register\n         SLR   R15,R15              N. Clear R15\n         IC    R15,XCell+1             Length minus one\n         LA    R03,1(,R15)             Actual length\n         J     PE300\n         SPACE\n*---------------------------------------------------------------------*\n*        Get length of MVCK/MVCP/MVCS instruction operand             *\n*---------------------------------------------------------------------*\n         SPACE\nPE240    DS    0H\n         IC    R15,XCell+1          rr\n         N     R15,OOOOOOFO         r0\n         SRL   R15,2                r*4\n         L     R15,OldRegs(R15)     Operand length\n         LTR   R03,R15              Q. Operand length zero?\n         JZ    PE400                Y. Storage not accessed then\n         SPACE\n*---------------------------------------------------------------------*\n*        Load storage operand, the number of bytes loaded is the      *\n*        smaller of eight bytes or the actual operand length          *\n*---------------------------------------------------------------------*\n         SPACE\nPE300    DS    0H\n         LHI   R14,8                Maximum length displayed by trace\n         CLR   R14,R03              Q. Operand length too long?\n         JH    PE310                N. Use actual operand length\n         LR    R03,R14              Y. Use maximum length allowed\n         SPACE\nPE310    DS    0H\n         SAR   AR02,R04             Set access register\n         LR    R14,R03              Get length of storage operand\n         BCTR  R14,0                Machine length\n         EX    R14,PEFAMVC          Get first storage operand\n***      MVC   WorkDblW(0),0(R02)   ...\n         LAM   AR02,AR02,HexZeros   Clear the access register\n         SPACE\n*---------------------------------------------------------------------*\n*        Convert operand to display and move to print line            *\n*---------------------------------------------------------------------*\n         SPACE\n         LM    R15,R00,WorkDblW     Load storage contents into regs\n         L     R00,WorkDblW+4       Convert second word to display hex\n         BRAS  R14,HexToEBC         ...\n         STM   R00,R01,WorkCL16+8   ... and save\n         SPACE\n         LR    R00,R15              Convert first word to display hex\n         BRAS  R14,HexToEBC         ...\n         STM   R00,R01,WorkCL16     ... and save\n         SPACE\n         LR    R01,R03              Actual operand length\n         ALR   R01,R01              Times two (for each hex nybble)\n         LA    R14,WorkCL16(R01)    Address of end of operand\n         LHI   R15,16               Maximum length of operand displayed\n         SR    R15,R01              Number of positions to blank out\n         JZ    PE320                Bif none\n         AHI   R15,-2               Adjust for initial blank           X\n                                    ... and machine length\n         MVI   0(R14),C' '          Initial blank\n         EX    R15,PEFACLR          Propagate the blank\n***      MVC   1(0,R14),0(R14)      ...\n         SPACE\nPE320    DS    0H\n         MVC   PrL$Data1,WorkCL16   Move into print line\n         MVC   PrL$Double1,WorkCL16+8 ...\n         SPACE\n*---------------------------------------------------------------------*\n*        Format second storage operand if there is one                *\n*---------------------------------------------------------------------*\n         SPACE\n         CLI   XCell,$MVCLE         Q. MVCLE/CLCLE instruction?\n         JL    PE330                N. Check for others\n         CLI   XCell,$CLCLE         Y. Q. MVCLE/CLCLE instruction?\n         JNH   PE340                   Y. Process as if RR\n         SPACE\nPE330    DS    0H\n         TM    bAttribute2,bitRR+bitSS\n***                                 Q. Can 2nd operand be from storage?\n         JZ    PE999                N. We must be finished\n         TM    bAttribute2,bitRR    Y. Q. RR instruction?\n         JZ    PE400                   N. Must be ss instruction\n         SPACE\nPE340    DS    0H\n         IC    R15,XCell+1          rr\n         N     R15,OOOOOOOF         0r (source register)\n         SLL   R15,2                0r times 4\n         SLR   R04,R04              Assume we're not in AR ASC mode\n         CLI   TraceASC,ARmode      Q. In AR ASC mode?\n         JNE   PE350                N. Default value is good\n         L     R04,TraceARs(R15)    Y. Load associated ALET\n         SPACE\nPE350    DS    0H\n         L     R02,OldRegs(R15)     Original 2nd operand address\n         LA    R02,0(,R02)          Clear top bit/byte\n         L     R03,OldRegs+4(R15)   Get length register\n         TM    bAttribute2,bitRR    Q. MVCL or CLCL instruction?\n         JZ    PE410                N. MVCLE/CLCLE length is 4-bytes\n         ICM   R03,B'1000',HexZeros Y. MVCL/CLCL length is 3-bytes\n         J     PE410                   Go get operand\n         SPACE\nPE400    DS    0H\n         CLI   XCell,$SRP           Q. SRP instruction?\n         JE    PE999                Y. Second operand not an address\n         LA    R02,XCell+4          N. Point to 2nd base, displacement\n         BRAS  R14,EvalBD              Evaluate 2nd operand address\n         LR    R02,R00                 Save effective address\n         SPACE\n         TM    bAttribute1,bitPACKD    Q. Packed decimal instruction?\n         JZ    PE410                   N. Operand length still in R03\n         IC    R15,XCell+1             Y. Get ll byte\n         N     R15,OOOOOOOF               Mask off l2\n         LA    R03,1(,R15)                Actual operand length\n         SPACE\nPE410    DS    0H\n         LR    R00,R02              Load R00 with effective address\n         BRAS  R14,HexToEBC         Convert EFA for printing\n         STM   R00,R01,PrL$Address2 ... and move to print line\n         SPACE\n         LTR   R03,R03              Q. Zero length operand?\n         JZ    PE999                Y. No storage to print then\n         TM    bAttribute1,bitMVCX  N. Q. MVCK/MVCP/MVCS instruction?\n         JZ    PE420                   N. Go get operands\n         CLI   XCell,$MVCS             Y. Q. MVCS instruction?\n         JNE   PE999                      N. Cannot access A/S used\n         SPACE\nPE420    DS    0H\n         LHI   R14,8                Maximum operand display length\n         CLR   R14,R03              Q. Operand length too long?\n         JH    PE430                N. Use actual operand length\n         LR    R03,R14              Y. Use maximum allowed length\n         SPACE\nPE430    DS    0H\n         SAR   AR02,R04             Load ALET for MVC source\n         LR    R14,R03              Load operand length\n         BCTR  R14,0                Machine length\n         EX    R14,PEFAMVC          Get second storage operand\n***      MVC   WorkDblW(0),0(R02)   ...\n         LAM   AR02,AR02,HexZeros   Ensure AR02 zero to avoid problems\n         SPACE\n*---------------------------------------------------------------------*\n*        Convert storage contents to display and move to print line   *\n*---------------------------------------------------------------------*\n         SPACE\n         LM    R15,R00,WorkDblW     Load storage contents into regs\n         L     R00,WorkDblW+4       Convert second word to display hex\n         BRAS  R14,HexToEBC         ...\n         STM   R00,R01,WorkCL16+8   ... and save\n         SPACE\n         LR    R00,R15              Convert first word to display hex\n         BRAS  R14,HexToEBC         ...\n         STM   R00,R01,WorkCL16     ... and save\n         SPACE\n         ALR   R03,R03              Times two (for each hex nybble)\n         LA    R14,WorkCL16(R03)    Address of end of operand\n         LHI   R15,16               Maximum length of operand displayed\n         SR    R15,R03              Number of positions to blank out\n         JZ    PE440                Bif 8 bytes are displayed\n         AHI   R15,-2               Adjust for initial blank           X\n                                    ... and machine length\n         MVI   0(R14),C' '          Initial blank\n         EX    R15,PEFACLR          Propagate the blank\n***      MVC   1(0,R14),0(R14)      ...\n         SPACE\nPE440    DS    0H\n         MVC   PrL$Data2,WorkCL16   Move into print line\n         MVC   PrL$Double2,WorkCL16+8 ...\n         SPACE\nPE999    DS    0H\n         L     R14,PESAV            Load return address\n         BSM   0,R14                Return\n         SPACE 2\n         LTORG ,\n         TITLE 'Evaluate Memory Address Referenced by Instructions'\n***********************************************************************\n*        Evaluate the address of storage reference instructions       *\n*---------------------------------------------------------------------*\n*                                                                     *\n*        R00-R01 - used for work, contents destroyed                  *\n*        R02     - address of X'bddd' field                           *\n*        XCell+1 - index register in bottom nybble for xbd            *\n*                                                                     *\n*        On return, R00 contains the effective address and R04 the    *\n*        associated ALET.                                             *\n*                                                                     *\n***********************************************************************\n         SPACE\nEvalBD   DS    0H                   Base and displacement\n         SLR   R00,R00              Value of the index is zero\n         J     EA010                Go evaluate base, displacement\n         SPACE\nEvalXBD  DS    0H                   Index, base and displacement\n         SLR   R00,R00              Clear R00\n         IC    R01,XCell+1          rx\n         N     R01,OOOOOOOF         0x\n         JZ    EA010                Register zero implies no index\n         SLL   R01,2                x*4\n         L     R00,OldRegs(R01)     Value of the index\n         SPACE\n*---------------------------------------------------------------------*\n*        At this point, R00 contains the value of the index           *\n*---------------------------------------------------------------------*\n         SPACE\nEA010    DS    0H\n         SLR   R04,R04              Default ALET value is zero\n         IC    R01,0(,R02)          bd\n         N     R01,OOOOOOFO         b0       base register\n         JZ    EA030                Register zero implies no base\n         SRL   R01,2                b*4\n         CLI   TraceASC,ARmode      Q. In AR ASC mode?\n         JNE   EA020                N. Use default ALET of zero\n         L     R04,TraceARs(R01)    Y. Load associated ALET\n         SPACE\nEA020    DS    0H\n         AL    R00,OldRegs(R01)     Index + base\n         SPACE\nEA030    DS    0H\n         LH    R01,0(,R02)          bddd     base, displacement\n         N     R01,OOOOOFFF         0ddd     displacement\n         ALR   R01,R00              Index + base + displacement\n         LA    R01,0(,R01)          Clear high order bit/byte\n         LR    R00,R01              Load R00 with effective address\n         BSM   0,R14                Return\n         SPACE 3\n*---------------------------------------------------------------------*\n*        Evaluate address for a relative branch instruction           *\n*---------------------------------------------------------------------*\n         SPACE\nEvalRI   DS    0H\n         LH    R01,XCell+2          Load immediate value\n         SLA   R01,1                Times 2 for number of halfwords\n         TM    bAttribute4,bitEX    Q. EXECUTE'd relative branch?\n         JO    EA100                Y. Relative to EX'ed instruction\n         LA    R00,0(R01,R11)       N. Calculate effective address\n         BSM   0,R14                   and return\n         SPACE\nEA100    DS    0H\n         L     R02,aEX_Target       Address relative to the EXECUTE'd\n         LA    R00,0(R01,R02)       ... instruction\n         BSM   0,R14                and return\n         TITLE 'Print Contents of General, Access and FP registers'\n***********************************************************************\n*        Register dump routines                                       *\n*---------------------------------------------------------------------*\n*        Contents of R00-R03 and R14-R15 are destroyed                *\n*                                                                     *\n***********************************************************************\n         SPACE\nDumpGPRs DS    0H                   Dump general registers\n         LA    R02,TraceGPRs        Address of first 8 registers\n         BRAS  R14,RPUT             Place them in print line\n         MVI   PrL$CCB,C'0'         Double space next line\n         MVC   PrL$Data+29(L'GRM0),GRM0   ' R00-R07  '\n         BRAS  R14,Write            Print the line\n         LA    R02,TraceGPRs+32     Address of 2nd 8 registers\n         BRAS  R14,RPUT             Place them in print line\n         MVC   Prl$Data+29(L'GRM8),GRM8   ' R08-R15  '\n         BRAS  R14,Write            Print the line\n         BSM   0,R12                Return\n         SPACE 3\nDumpARs  DS    0H                   Dump access registers\n         LA    R02,TraceARs         Address of first 8 registers\n         BRAS  R14,RPUT             Place them in print line\n         MVI   PrL$CCB,C'0'         Double space next line\n         MVC   PrL$Data+29(L'ARM0),ARM0   'AR00-AR07 '\n         BRAS  R14,Write            Print the line\n         LA    R02,TraceARs+32      Address of 2nd 8 registers\n         BRAS  R14,RPUT             Place them in print line\n         MVC   PrL$Data+29(L'ARM8),ARM8   'AR08-AR15 '\n         BRAS  R14,Write            Print the line\n         BSM   0,R12                Return\n         SPACE 3\nDumpFPRs DS    0H\n         MVC   PrL$Data+29(L'FPM0),FPM0   'FPR0-FPR6'\n         LA    R02,FPR0             Address of floating register table\n         STD   0,FPR0               Load floating point register table\n         STD   2,FPR2               ...\n         STD   4,FPR4               ...\n         STD   6,FPR6               ...\n         BRAS  R14,RPUT             Format FP registers for printing\n         BRAS  R14,Write            Print the line\n         MVI   PrL$CCB,C'0'         Double space next line\n         BSM   0,R12                Return\n         SPACE 3\n*---------------------------------------------------------------------*\n*        Place eight registers into the print line                    *\n*---------------------------------------------------------------------*\n         SPACE\nRPUT     DS    0H\n         ST    R14,RPSAV            Save return address\n         LA    R03,PrL$Data+40      Starting point in print line\n         LHI   R15,8                Number of registers to print\n         SPACE\nRP010    DS    0H\n         L     R00,0(,R02)          Get the value of a register\n         BRAS  R14,HexToEBC         Convert it for printing\n         STM   R00,R01,0(R03)       Place in print line\n         SPACE\n         LA    R02,4(,R02)          Point at next register\n         SLR   R01,R01              Clear work register\n         IC    R01,Offsets-1(R15)   Get offset to next field in line\n         LA    R03,0(R01,R03)       Point to next field in print line\n         BRCT  R15,RP010            Loop for eight fullwords\n         SPACE\n         L     R14,RPSAV            Load return address\n         BSM   0,R14                ... and return\n         TITLE 'Formatted Date and Time'\n***********************************************************************\n*                                                                     *\n*        Format current date and time for display                     *\n*                                                                     *\n***********************************************************************\n         SPACE\nTimeStamp DS   0H\n         ST    R14,TSSAV             Save return address\n         MVC   PageDate,=X'21202020612020612020'\n         MVC   PageTime,=X'4021207A20207A20204B202020202020'\n         SPACE\n         TIME  DEC,WorkCL16,DATETYPE=YYYYMMDD,                         X\n               LINKAGE=SYSTEM,MF=(E,cplTIME)\n         SPACE\n         OI    WorkCL16+7,X'0F'      Force displayable packed sign\n         SRP   WorkCL16(8),64-2,0    Shift off trailing zeros\n         ED    PageTime,WorkCL16+1\n         SPACE\n         MVI   WorkCL16+12,X'0F'     Set packed sign\n         ED    PageDate,WorkCL16+8\n         SPACE\n         L     R14,TSSAV             Reload return address\n         BSM   0,R14                 ... and return to caller\n         SPACE 2\n         LTORG ,\n         TITLE 'SVC Special Operand Processing Routines'\n***********************************************************************\n*        Format special operands for SVC print line                   *\n*---------------------------------------------------------------------*\n*        R01 points to area after SVC macro name                      *\n*                                                                     *\n***********************************************************************\n         SPACE\nSVC@06   DS    0H                   LINK\nSVC@07   DS    0H                   XCTL\n         L     R15,OldRegs+(4*15)   Address of parameter list\n         L     R15,0(,R15)          Address of module name\n         MVC   0(8,R01),0(R15)      Copy to print line\n         BSM   0,R14                and return\n         SPACE 2\nSVC@08   DS    0H                   LOAD\n         L     R00,OldRegs+(4*0)    Address of module name\n         CLI   OldRegs+(4*0),X'FF'  Q. Is address complemented?\n         JNE   SVC@08A              N. Use it as it is\n         LCR   R00,R00              Y. Uncomplement it\n         SPACE\nSVC@08A  DS    0H\n         LR    R15,R00              Copy to usable address register\n         MVC   0(8,R01),0(R15)      Copy module name to print line\n         BSM   0,R14                and return\n         SPACE 2\nSVC@09   DS    0H                   DELETE\n         L     R15,OldRegs+(4*0)    Address of module name\n         MVC   0(8,R01),0(R15)      Copy to print line\n         BSM   0,R14                and return\n         SPACE 2\nSVC@7A   DS    0H                   LINK/XCTL/LOAD\n         LHI   R00,7                Extended route code for LINK\n         CL    R00,OldRegs+(4*15)   Q. Possibly LINK/XCTL/LOAD?\n         BLR   R14                  N. Do nothing\n         LHI   R00,9                Y. Extended route code for LOAD\n         CL    R00,OldRegs+(4*15)      Q. Definitely LINK/XCTL/LOAD?\n         BHR   R14                     N. Do nothing\n         L     R15,OldRegs+(4*1)       Y. Address of parmlist\n         L     R15,0(,R15)                Address of module name\n         MVC   0(8,R01),0(R15)            Copy to print line\n         BSM   0,R14                      and return\n         TITLE 'Program Constants'\n***********************************************************************\n*                                                                     *\n*        P R O G R A M   C O N S T A N T S                            *\n*                                                                     *\n***********************************************************************\n         SPACE\naOpCodes DC    A(OpCodes)           Address of instruction opcode table\naB2codes DC    A(B2codes)           X'B2' prefixed opcode table address\naA7codes DC    A(A7codes)           X'A7' prefixed opcode table address\na01codes DC    A(O1codes)           X'01' prefixed opcode table address\naSVCtable DC   A(SVCtable)          SVC mnemonic descriptor table\naSVC_Ops DC    A(SVCOPS)            SVC operand special processing tbl\naOpFlags DC    A(OpFlags)           Opcode bit flag table\naOpIndex DC    A(OpIndex)           Opcode bit flag table index\naB2index DC    A(B2Index)           X'B2' opcode bit flag table index\naA7index DC    A(A7Index)           X'A7' opcode bit flag table index\na01index DC    A(O1Index)           X'01' opcode bit flag table index\n         SPACE\nplUserExit DS  0A                   Exit parameter list\n         DC    A(UsrFlag1)           - Address of status flags\n         DC    A(TraceGPRs)          - Address of general registers\n         DC    A(TraceARs)           - Address of access registers\n         DC    A(TraceCC)            - Address of program's cond-codes\n         DC    A(InstrPointer)       - Address of AMODE/Instruction-Ptr\n         DC    A(StoreAddr)          - Storage exception address\n         DC    A(PUTR+Bit0)          - Address of trace put routine\n         DC    A(PLINE)              - Address of the print line\n         DC    A(DumpVS+Bit0)        - Address of storage dump routine\n         SPACE\nOOOOOOOF DC    X'0000000F'          Masking constants\nOOOOOOFO DC    X'000000F0'\nOOOOOFFF DC    X'00000FFF'\nOOOOFOOO DC    X'0000F000'\nOFOOOOOO DC    X'0F000000'\nOOOOOO3C DC    X'0000003C'\nSevenFs  DC    X'7FFFFFFF'\nBitZero  DC    X'80000000'\n         SPACE\nASMTDLI  DC    CL8'ASMTDLI'         DL/I interface stub module name\nAIBTDLI  DC    CL8'AIBTDLI'         New DL/I interface stub module name\nSYSTRACE DC    C'SYSTRACE'          Default output ddname\nEBDCC    DC    C'8421'              Characters for condition code\n         SPACE\nCCbits   DC    X'00000080'          Bits corresponding to the\n         DC    X'00000040'          ... condition code\n         DC    X'00000020'\n         DC    X'00000010'\n         SPACE\nILC1     DC    X'40000000'          Instruction length code of BALR\n         SPACE\nASCmodes DC    C'PSAH'              Primary, Secondary, Access, Home\n         SPACE\nOffsets  DC    X'09090A090C090A09'\n         SPACE\n*                 0 1 2 3 4 5 6 7 8 9 A B C D E F\nBitCount DC    X'00010102010202030102020302030304'\n         SPACE\nEDMask12 DC    XL12'402020202020202020202120'\nEDmask20 DC    X'402020206B2020206B2020206B2020206B202120'\nHexChar  DC    C'0123456789ABCDEF'\n         SPACE\ncpZero   DC    P'0'                 Packed constant 0\ncpOne    DC    P'1'                 Packed constant 1\nTwoTo32  DC    P'4294967296'        Two to the power of thirty two\nPageLen  DC    P'58'                Number of lines on a page\n         SPACE\nDLIcall  DC    C'DFSLI000 - DL/I Language Interface'\n*                0----+----1----+----2----+----3----+----4----+----5---\nPCHEADER DC    C'1**** *********** instructions executed in address ran-\n               ge ********-******** (xxxxxxxx)'\nEPHEADER DC    C'1**** Execution profile data for address range *******-\n               *-******** (xxxxxxxx)'\n*              -+----6----+----7----+----8----+\nBranchDir DC   C'<>'                Branch direction indicator\nFPM0     DC    C'FPR0-FPR6'\nGRM0     DC    C'GR00-GR07'\nGRM8     DC    C'GR08-GR15'\nARM0     DC    C'AR00-AR07'\nARM8     DC    C'AR08-AR15'\nIlglMsg  DC    C'0****    Illegal  Instruction  ****'\nEndMsg1  DC    C'  Resuming execution at: '\nEndMsg2  DC    C'instructions traced this run (out of a total of '\nUnMatchedPR DC C'0TRACE terminated by unmatched PR instruction'\nNOEXEC   DC    C' - No instructions executed in this range'\nSAME     DC    C'SAME'\n         SPACE 2\nNopInstr DS    0H                   NOPR instructions for padding\n         NOPR  0                    ... ExecIns1 out to 6 bytes\n         NOPR  0                    ...\n         SPACE\nMoveIdent MVC  IDstring(0),0(R14)   Save identification string\nMoveSVC  MVC   PrL$SVC(0),0(R01)    Copy SVC mnemonic to print line\nMoveExSVC MVC  PrL$ESVC(0),0(R01)   ditto but for executed SVC\nPEFAMVC  MVC   WorkDblW(0),0(R02)   Get contents of storage operand\nPEFACLR  MVC   1(0,R14),0(R14)      Blank end of operand\nEXMVCEX  MVC   PSXCell(0),0(R01)    Get target instruction of execute\nMoveEDMK MVC   0(0,R03),0(R01)      Move instruction count to prt line\nJUMP     J     *+12                 JUMP (around module ID string)\nBRANCH   B     0(0,R15)             BRANCH (around module ID string)\nABEND    DC    X'0A0D'              ABEND instruction\n         SPACE\n*---------------------------------------------------------------------*\n*          Extended Mnemonics for BC/BCR and BRC                      *\n*---------------------------------------------------------------------*\n           SPACE\nEMstandard DS    0F                      Standard table\n           DC    C'NOP '                 0\n           DC    C'BO  '                 1\n           DC    C'BP  '                 2\n           DC    C'    '                 3\n           DC    C'BM  '                 4\n           DC    C'    '                 5\n           DC    C'    '                 6\n           DC    C'BNZ '                 7\n           DC    C'BZ  '                 8\n           DC    C'    '                 9\n           DC    C'    '                 A\n           DC    C'BNM '                 B\n           DC    C'    '                 C\n           DC    C'BNP '                 D\n           DC    C'BNO '                 E\n           DC    C'B   '                 F\n           SPACE 2\nEMcompare  DS    0F                      After COMPARE instructions\n           DC    C'NOP '                 0\n           DC    C'BO  '                 1\n           DC    C'BH  '                 2\n           DC    C'    '                 3\n           DC    C'BL  '                 4\n           DC    C'    '                 5\n           DC    C'    '                 6\n           DC    C'BNE '                 7\n           DC    C'BE  '                 8\n           DC    C'    '                 9\n           DC    C'    '                 A\n           DC    C'BNL '                 B\n           DC    C'    '                 C\n           DC    C'BNH '                 D\n           DC    C'BNO '                 E\n           DC    C'B   '                 F\n           SPACE 2\nDDNchars DC    256X'FF'             Valid characters in ddnames and\n         ORG   DDNchars+C'$'        ... load module member names\n         DC    X'00'\n         ORG   DDNchars+C'#'\n         DC    X'00'\n         ORG   DDNchars+C'@'\n         DC    X'00'\n         ORG   DDNchars+C' '\n         DC    X'00'\n         ORG   DDNchars+C'A'\n         DC    9X'00'\n         ORG   DDNchars+C'J'\n         DC    9X'00'\n         ORG   DDNchars+C'S'\n         DC    8X'00'\n         ORG   DDNchars+C'0'\n         DC    10X'00'\n         ORG   ,\n         SPACE\nEBCDIC   DC    256C'.'              Printable EBCDIC characters\n         ORG   EBCDIC+X'40'\n         DC    AL1(*-EBCDIC)\n         ORG   EBCDIC+X'4A'\n         DC    7AL1(*-EBCDIC)\n         ORG   EBCDIC+X'5A'\n         DC    8AL1(*-EBCDIC)\n         ORG   EBCDIC+X'6A'\n         DC    6AL1(*-EBCDIC)\n         ORG   EBCDIC+X'79'\n         DC    7AL1(*-EBCDIC)\n         ORG   EBCDIC+X'81'\n         DC    9AL1(*-EBCDIC)\n         ORG   EBCDIC+X'91'\n         DC    9AL1(*-EBCDIC)\n         ORG   EBCDIC+X'A1'\n         DC    9AL1(*-EBCDIC)\n         ORG   EBCDIC+X'C0'\n         DC    10AL1(*-EBCDIC)\n         ORG   EBCDIC+X'D0'\n         DC    10AL1(*-EBCDIC)\n         ORG   EBCDIC+X'E0'\n         DC    AL1(*-EBCDIC)\n         ORG   EBCDIC+X'E2'\n         DC    8AL1(*-EBCDIC)\n         ORG   EBCDIC+X'F0'\n         DC    10AL1(*-EBCDIC)\n         ORG   ,\n         SPACE 2\nSVCOPS   DS    0A\nSVC@06$$ DC    A(SVC@06)\nSVC@07$$ DC    A(SVC@07)\nSVC@08$$ DC    A(SVC@08)\nSVC@09$$ DC    A(SVC@09)\nSVC@7A$$ DC    A(SVC@7A)\n         TITLE 'Instruction Mnemonics'\n***********************************************************************\n*                                                                     *\n*        Isolate large (constant) data structures to relieve          *\n*        addressibililty constraints in main CSECT.                   *\n*                                                                     *\n***********************************************************************\n         SPACE\nT390DATA RSECT\nT390DATA AMODE ANY\nT390DATA RMODE 24\n         SPACE 2\nOpCodes  DS    0C      * = Unsupported,  - = pre-XA only\n         DC    C'???   X\"01\" ???   ???   SPM   BALR  BCTR  BCR   ' 00\n         DC    C'-SSK  -ISK  SVC   BSM   BASSM BASR  MVCL  CLCL  ' 08\n         DC    C'LPR   LNR   LTR   LCR   NR    CLR   OR    XR    ' 10\n         DC    C'LR    CR    AR    SR    MR    DR    ALR   SLR   ' 18\n         DC    C'LPDR  LNDR  LTDR  LCDR  HDR   LRDR  MXR   MXDR  ' 20\n         DC    C'LDR   CDR   ADR   SDR   MDR   DDR   AWR   SWR   ' 28\n         DC    C'LPER  LNER  LTER  LCER  HER   LRER  AXR   SXR   ' 30\n         DC    C'LER   CER   AER   SER   MER   DER   AUR   SUR   ' 38\n         DC    C'STH   LA    STC   IC    EX    BAL   BCT   BC    ' 40\n         DC    C'LH    CH    AH    SH    MH    BAS   CVD   CVB   ' 48\n         DC    C'ST    LAE   ???   ???   N     CL    O     X     ' 50\n         DC    C'L     C     A     S     M     D     AL    SL    ' 58\n         DC    C'STD   ???   ???   ???   ???   ???   ???   MXD   ' 60\n         DC    C'LD    CD    AD    SD    MD    DD    AW    SW    ' 68\n         DC    C'STE   MS    ???   ???   ???   ???   ???   ???   ' 70\n         DC    C'LE    CE    AE    SE    ME    DE    AU    SU    ' 78\n         DC    C'*SSM  ???   *LPSW *DIAG BRXH  BRXLE BXH   BXLE  ' 80\n         DC    C'SRL   SLL   SRA   SLA   SRDL  SLDL  SRDA  SLDA  ' 88\n         DC    C'STM   TM    MVI   TS    NI    CLI   OI    XI    ' 90\n         DC    C'LM    *TRACELAM   STAM  -SIO  -TIO  -HIO  -TCH  ' 98\n         DC    C'???   ???   ???   ???   *VAE+ *VAER+*VM+  X\"A7\" ' A0\n         DC    C'MVCLE CLCLE ???   ???   *STNSM*STOSM*SIGP MC    ' A8\n         DC    C'???   *LRA  X\"B2\" X\"B3\" ???   ???   *STCTL*LCTL ' B0\n         DC    C'???   ???   CS    CDS   ???   CLM   STCM  ICM   ' B8\n         DC    C'???   ???   ???   ???   ???   ???   ???   ???   ' C0\n         DC    C'???   ???   ???   ???   ???   ???   ???   ???   ' C8\n         DC    C'???   MVN   MVC   MVZ   NC    CLC   OC    XC    ' D0\n         DC    C'???   MVCK  MVCP  MVCS  TR    TRT   ED    EDMK  ' D8\n         DC    C'???   ???   ???   ???   *VLI+ *X\"E5\"???   ???   ' E0\n         DC    C'MVCIN ???   ???   ???   ???   *X\"ED\"PLO   ???   ' E8\n         DC    C'SRP   MVO   PACK  UNPK  ???   ???   ???   ???   ' F0\n         DC    C'ZAP   CP    AP    SP    MP    DP    ???   ???   ' F8\n         SPACE 3\nB2codes  DS    0C\n         DC    C'-CONC -DISC *STIDP-STIDC*SCK  STCK  *STKC *STCKC' 00\n         DC    C'*SPT  *STPT SPKA  IPK   ???   *PTLB ???   ???   ' 08\n         DC    C'*SPX  *STPX *STAP -RRB  ???   ???   ???   ???   ' 10\n         DC    C'PC    SAC   CFC   ???   ???   ???   ???   ???   ' 18\n         DC    C'SERVC *IPTE IPM   IVSK  IAC   SSAR  EPAR  ESAR  ' 20\n         DC    C'PT    *ISKE *RRBE *SSKE *TB   DXR   ???   ???   ' 28\n         DC    C'*CSCH *HSCH *MSCH *SSCH *STSCH*TSCH *TPI  *SAL  ' 30\n         DC    C'*RSCH *STCRW*STCPS*RCHP *SCHM ???   ???   ???   ' 38\n         DC    C'BAKR  CKSM  ???   ???   SQDR  SQER  *STURAMSTA  ' 40\n         DC    C'*PALB EREG  ESTA  *LURA TAR   CPYA  SAR   EAR   ' 48\n         DC    C'CSP   ???   MSR   ???   MVPG  MVST  ???   CUSE  ' 50\n         DC    C'BSG   ???   BSA   ???   ???   CLST  SRST  ???   ' 58\n         DC    C'???   ???   ???   CMPSC ???   ???   ???   ???   ' 60\n         DC    C'???   ???   ???   ???   ???   ???   ???   ???   ' 68\n         DC    C'???   ???   ???   ???   ???   ???   ???   RP    ' 70\n         DC    C'STCKE SACF  ???   ???   ???   STSI  ???   ???   ' 78\n         DC    C'???   ???   ???   ???   ???   ???   ???   ???   ' 80\n         DC    C'???   ???   ???   ???   ???   ???   ???   ???   ' 88\n         DC    C'???   ???   ???   ???   ???   ???   ???   ???   ' 90\n         DC    C'???   SRNM  ???   ???   STFPC LFPC  ???   ???   ' 98\n         DC    C'???   ???   ???   ???   ???   TRE   CUUTF CUTFU ' A0\n         DC    C'???   ???   ???   ???   ???   ???   ???   ???   ' A8\n         DC    C'???   ???   ???   ???   ???   ???   ???   ???   ' B0\n         DC    C'???   ???   ???   ???   ???   ???   ???   ???   ' B8\n         DC    C'???   ???   ???   ???   ???   ???   ???   ???   ' C0\n         DC    C'???   ???   ???   ???   ???   ???   ???   ???   ' C8\n         DC    C'???   ???   ???   ???   ???   ???   ???   ???   ' D0\n         DC    C'???   ???   ???   ???   ???   ???   ???   ???   ' D8\n         DC    C'???   ???   ???   ???   ???   ???   ???   ???   ' E0\n         DC    C'???   ???   ???   ???   ???   ???   ???   ???   ' E8\n         DC    C'???   ???   ???   ???   ???   ???   ???   ???   ' F0\n         DC    C'???   ???   ???   ???   ???   ???   ???   TRAP4 ' F8\n         SPACE 3\nA7codes  DS    0C\n         DC    C'TMH   TML   ???   ???   BRC   BRAS  BRCT  ???   ' 00\n         DC    C'LHI   ???   AHI   ???   MHI   ???   CHI   ???   ' 08\n         SPACE 3\nO1codes  DS    0C\n         DC    C'???   PR    UPT   ???   ???   ???   ???   ???   ' 00\n         DC  30C'???   ???   ???   ???   ???   ???   ???   ???   ' ...\n         DC    C'???   ???   ???   ???   ???   ???   ???   TRAP2 ' F8\n         SPACE 3\n         TITLE 'SVC Mnemonic Pointer table'\nSVCtable DS    0A\n         DC    A(SVC$00),AL2(L'SVC$00-1),AL2(65535)\n         DC    A(SVC$01),AL2(L'SVC$01-1),AL2(65535)\n         DC    A(SVC$02),AL2(L'SVC$02-1),AL2(65535)\n         DC    A(SVC$03),AL2(L'SVC$02-1),AL2(65535)\n         DC    A(SVC$04),AL2(L'SVC$04-1),AL2(65535)\n         DC    A(SVC$05),AL2(L'SVC$05-1),AL2(65535)\n         DC    A(SVC$06),AL2(L'SVC$06-1),AL2(SVC@06$$-SVCOPS)\n         DC    A(SVC$07),AL2(L'SVC$07-1),AL2(SVC@07$$-SVCOPS)\n         DC    A(SVC$08),AL2(L'SVC$08-1),AL2(SVC@08$$-SVCOPS)\n         DC    A(SVC$09),AL2(L'SVC$09-1),AL2(SVC@09$$-SVCOPS)\n         DC    A(SVC$0A),AL2(L'SVC$0A-1),AL2(65535)\n         DC    A(SVC$0B),AL2(L'SVC$0B-1),AL2(65535)\n         DC    A(SVC$0C),AL2(L'SVC$0C-1),AL2(65535)\n         DC    A(SVC$0D),AL2(L'SVC$0D-1),AL2(65535)\n         DC    A(SVC$0E),AL2(L'SVC$0E-1),AL2(65535)\n         DC    A(SVC$0F),AL2(L'SVC$0F-1),AL2(65535)\n         DC    A(SVC$10),AL2(L'SVC$10-1),AL2(65535)\n         DC    A(SVC$11),AL2(L'SVC$11-1),AL2(65535)\n         DC    A(SVC$12),AL2(L'SVC$12-1),AL2(65535)\n         DC    A(SVC$13),AL2(L'SVC$13-1),AL2(65535)\n         DC    A(SVC$14),AL2(L'SVC$14-1),AL2(65535)\n         DC    A(SVC$15),AL2(L'SVC$14-1),AL2(65535)\n         DC    A(SVC$16),AL2(L'SVC$16-1),AL2(65535)\n         DC    A(SVC$17),AL2(L'SVC$17-1),AL2(65535)\n         DC    A(SVC$18),AL2(L'SVC$18-1),AL2(65535)\n         DC    A(SVC$19),AL2(L'SVC$19-1),AL2(65535)\n         DC    A(SVC$1A),AL2(L'SVC$1A-1),AL2(65535)\n         DC    A(SVC$1B),AL2(L'SVC$1B-1),AL2(65535)\n         DC    A(SVC$RS),AL2(L'SVC$RS-1),AL2(65535)\n         DC    A(SVC$1D),AL2(L'SVC$1D-1),AL2(65535)\n         DC    A(SVC$1E),AL2(L'SVC$1E-1),AL2(65535)\n         DC    A(SVC$1F),AL2(L'SVC$1F-1),AL2(65535)\n         DC    A(SVC$20),AL2(L'SVC$20-1),AL2(65535)\n         DC    A(SVC$21),AL2(L'SVC$21-1),AL2(65535)\n         DC    A(SVC$22),AL2(L'SVC$22-1),AL2(65535)\n         DC    A(SVC$23),AL2(L'SVC$23-1),AL2(65535)\n         DC    A(SVC$24),AL2(L'SVC$24-1),AL2(65535)\n         DC    A(SVC$25),AL2(L'SVC$25-1),AL2(65535)\n         DC    A(SVC$RS),AL2(L'SVC$RS-1),AL2(65535)\n         DC    A(SVC$27),AL2(L'SVC$27-1),AL2(65535)\n         DC    A(SVC$28),AL2(L'SVC$28-1),AL2(65535)\n         DC    A(SVC$29),AL2(L'SVC$29-1),AL2(65535)\n         DC    A(SVC$2A),AL2(L'SVC$2A-1),AL2(65535)\n         DC    A(SVC$2B),AL2(L'SVC$2B-1),AL2(65535)\n         DC    A(SVC$2C),AL2(L'SVC$2C-1),AL2(65535)\n         DC    A(SVC$2D),AL2(L'SVC$2D-1),AL2(65535)\n         DC    A(SVC$2E),AL2(L'SVC$2E-1),AL2(65535)\n         DC    A(SVC$2F),AL2(L'SVC$2F-1),AL2(65535)\n         DC    A(SVC$30),AL2(L'SVC$30-1),AL2(65535)\n         DC    A(SVC$RS),AL2(L'SVC$RS-1),AL2(65535)\n         DC    A(SVC$RS),AL2(L'SVC$RS-1),AL2(65535)\n         DC    A(SVC$33),AL2(L'SVC$33-1),AL2(65535)\n         DC    A(SVC$34),AL2(L'SVC$34-1),AL2(65535)\n         DC    A(SVC$35),AL2(L'SVC$35-1),AL2(65535)\n         DC    A(SVC$36),AL2(L'SVC$36-1),AL2(65535)\n         DC    A(SVC$37),AL2(L'SVC$37-1),AL2(65535)\n         DC    A(SVC$38),AL2(L'SVC$38-1),AL2(65535)\n         DC    A(SVC$39),AL2(L'SVC$39-1),AL2(65535)\n         DC    A(SVC$3A),AL2(L'SVC$3A-1),AL2(65535)\n         DC    A(SVC$3B),AL2(L'SVC$3B-1),AL2(65535)\n         DC    A(SVC$3C),AL2(L'SVC$3C-1),AL2(65535)\n         DC    A(SVC$3D),AL2(L'SVC$3D-1),AL2(65535)\n         DC    A(SVC$3E),AL2(L'SVC$3E-1),AL2(65535)\n         DC    A(SVC$3F),AL2(L'SVC$3F-1),AL2(65535)\n         DC    A(SVC$40),AL2(L'SVC$40-1),AL2(65535)\n         DC    A(SVC$RS),AL2(L'SVC$RS-1),AL2(65535)\n         DC    A(SVC$42),AL2(L'SVC$42-1),AL2(65535)\n         DC    A(SVC$RS),AL2(L'SVC$RS-1),AL2(65535)\n         DC    A(SVC$44),AL2(L'SVC$44-1),AL2(65535)\n         DC    A(SVC$45),AL2(L'SVC$45-1),AL2(65535)\n         DC    A(SVC$46),AL2(L'SVC$46-1),AL2(65535)\n         DC    A(SVC$47),AL2(L'SVC$47-1),AL2(65535)\n         DC    A(SVC$NM),AL2(L'SVC$NM-1),AL2(65535)\n         DC    A(SVC$49),AL2(L'SVC$49-1),AL2(65535)\n         DC    A(SVC$4A),AL2(L'SVC$4A-1),AL2(65535)\n         DC    A(SVC$4B),AL2(L'SVC$4B-1),AL2(65535)\n         DC    A(SVC$4C),AL2(L'SVC$4C-1),AL2(65535)\n         DC    A(SVC$RS),AL2(L'SVC$RS-1),AL2(65535)\n         DC    A(SVC$4E),AL2(L'SVC$4E-1),AL2(65535)\n         DC    A(SVC$4F),AL2(L'SVC$4F-1),AL2(65535)\n         DC    A(SVC$RS),AL2(L'SVC$RS-1),AL2(65535)\n         DC    A(SVC$51),AL2(L'SVC$51-1),AL2(65535)\n         DC    A(SVC$RS),AL2(L'SVC$RS-1),AL2(65535)\n         DC    A(SVC$53),AL2(L'SVC$53-1),AL2(65535)\n         DC    A(SVC$54),AL2(L'SVC$54-1),AL2(65535)\n         DC    A(SVC$55),AL2(L'SVC$55-1),AL2(65535)\n         DC    A(SVC$56),AL2(L'SVC$56-1),AL2(65535)\n         DC    A(SVC$57),AL2(L'SVC$57-1),AL2(65535)\n         DC    A(SVC$RS),AL2(L'SVC$RS-1),AL2(65535)\n         DC    A(SVC$RS),AL2(L'SVC$RS-1),AL2(65535)\n         DC    A(SVC$RS),AL2(L'SVC$RS-1),AL2(65535)\n         DC    A(SVC$5B),AL2(L'SVC$5B-1),AL2(65535)\n         DC    A(SVC$5C),AL2(L'SVC$5C-1),AL2(65535)\n         DC    A(SVC$5D),AL2(L'SVC$5D-1),AL2(65535)\n         DC    A(SVC$5E),AL2(L'SVC$5E-1),AL2(65535)\n         DC    A(SVC$5F),AL2(L'SVC$5F-1),AL2(65535)\n         DC    A(SVC$60),AL2(L'SVC$60-1),AL2(65535)\n         DC    A(SVC$61),AL2(L'SVC$61-1),AL2(65535)\n         DC    A(SVC$62),AL2(L'SVC$62-1),AL2(65535)\n         DC    A(SVC$63),AL2(L'SVC$63-1),AL2(65535)\n         DC    A(SVC$64),AL2(L'SVC$64-1),AL2(65535)\n         DC    A(SVC$65),AL2(L'SVC$65-1),AL2(65535)\n         DC    A(SVC$66),AL2(L'SVC$66-1),AL2(65535)\n         DC    A(SVC$67),AL2(L'SVC$67-1),AL2(65535)\n         DC    A(SVC$68),AL2(L'SVC$68-1),AL2(65535)\n         DC    A(SVC$69),AL2(L'SVC$69-1),AL2(65535)\n         DC    A(SVC$RS),AL2(L'SVC$RS-1),AL2(65535)\n         DC    A(SVC$6B),AL2(L'SVC$6B-1),AL2(65535)\n         DC    A(SVC$RS),AL2(L'SVC$RS-1),AL2(65535)\n         DC    A(SVC$6D),AL2(L'SVC$6D-1),AL2(65535)\n         DC    A(SVC$NM),AL2(L'SVC$NM-1),AL2(65535)\n         DC    A(SVC$NM),AL2(L'SVC$NM-1),AL2(65535)\n         DC    A(SVC$70),AL2(L'SVC$70-1),AL2(65535)\n         DC    A(SVC$71),AL2(L'SVC$71-1),AL2(65535)\n         DC    A(SVC$72),AL2(L'SVC$72-1),AL2(65535)\n         DC    A(SVC$RS),AL2(L'SVC$RS-1),AL2(65535)\n         DC    A(SVC$74),AL2(L'SVC$74-1),AL2(65535)\n         DC    A(SVC$75),AL2(L'SVC$75-1),AL2(65535)\n         DC    A(SVC$RS),AL2(L'SVC$RS-1),AL2(65535)\n         DC    A(SVC$77),AL2(L'SVC$77-1),AL2(65535)\n         DC    A(SVC$78),AL2(L'SVC$78-1),AL2(65535)\n         DC    A(SVC$79),AL2(L'SVC$79-1),AL2(65535)\n         DC    A(SVC$7A),AL2(L'SVC$7A-1),AL2(SVC@7A$$-SVCOPS)\n         DC    A(SVC$7B),AL2(L'SVC$7B-1),AL2(65535)\n         DC    A(SVC$7C),AL2(L'SVC$7C-1),AL2(65535)\n         DC    A(SVC$7D),AL2(L'SVC$7D-1),AL2(65535)\n         DC    A(SVC$7E),AL2(L'SVC$7E-1),AL2(65535)\n         DC    A(SVC$RS),AL2(L'SVC$RS-1),AL2(65535)\n         DC    A(SVC$RS),AL2(L'SVC$RS-1),AL2(65535)\n         DC    A(SVC$RS),AL2(L'SVC$RS-1),AL2(65535)\n         DC    A(SVC$82),AL2(L'SVC$82-1),AL2(65535)\n         DC    A(SVC$83),AL2(L'SVC$83-1),AL2(65535)\n         DC    A(SVC$84),AL2(L'SVC$84-1),AL2(65535)\n         DC    A(SVC$85),AL2(L'SVC$85-1),AL2(65535)\n         DC    A(SVC$RS),AL2(L'SVC$RS-1),AL2(65535)\n         DC    A(SVC$RS),AL2(L'SVC$RS-1),AL2(65535)\n         DC    A(SVC$RS),AL2(L'SVC$RS-1),AL2(65535)\n         DC    A(SVC$89),AL2(L'SVC$89-1),AL2(65535)\n         DC    A(SVC$8A),AL2(L'SVC$8A-1),AL2(65535)\n         DC    A(SVC$8B),AL2(L'SVC$8B-1),AL2(65535)\n         DC    A(SVC$RS),AL2(L'SVC$RS-1),AL2(65535)\n         DC    A(SVC$RS),AL2(L'SVC$RS-1),AL2(65535)\n         DC    A(SVC$RS),AL2(L'SVC$RS-1),AL2(65535)\n         DC    A(SVC$8F),AL2(L'SVC$8F-1),AL2(65535)\nHighSVC  EQU   ((*-SVCtable)/8)-1\n         TITLE 'SVC Mnemonics'\nSVC$NM   DC    C'NO MACRO'          For SVC's not generated by macros\nSVC$RS   DC    C'RESERVED'          Unused SVC numbers reserved by IBM\nSVC$00   DC    C'EXCP/XDAP'\nSVC$01   DC    C'WAIT/WAITR/PRTOV'\nSVC$02   DC    C'POST'\nSVC$03   DC    C'EXIT'\nSVC$04   DC    C'GETMAIN (Type 1)'\nSVC$05   DC    C'FREEMAIN (Type 1)'\nSVC$06   DC    C'LINK(X)'\nSVC$07   DC    C'XCTL(X)'\nSVC$08   DC    C'LOAD'\nSVC$09   DC    C'DELETE'\nSVC$0A   DC    C'GETMAIN/FREEMAIN (R OPERAND)'\nSVC$0B   DC    C'TIME'\nSVC$0C   DC    C'SYNCH(X)'\nSVC$0D   DC    C'ABEND'\nSVC$0E   DC    C'SPIE'\nSVC$0F   DC    C'ERREXCP'\nSVC$10   DC    C'PURGE'\nSVC$11   DC    C'RESTORE'\nSVC$12   DC    C'BLDL/FIND (Type D)'\nSVC$13   DC    C'OPEN'\nSVC$14   DC    C'CLOSE'\nSVC$15   DC    C'STOW'\nSVC$16   DC    C'OPEN (TYPE=J)'\nSVC$17   DC    C'CLOSE (TYPE=T)'\nSVC$18   DC    C'DEVTYPE'\nSVC$19   DC    C'TRKBAL'\nSVC$1A   DC    C'CATALOG/INDEX/LOCATE'\nSVC$1B   DC    C'OBTAIN'\nSVC$1D   DC    C'SCRATCH'\nSVC$1E   DC    C'RENAME'\nSVC$1F   DC    C'FEOV'\nSVC$20   DC    C'REALLOC'\nSVC$21   DC    C'IOHALT'\nSVC$22   DC    C'MGCR(E)/QEDIT'\nSVC$23   DC    C'WTO/WTOR'\nSVC$24   DC    C'WTL'\nSVC$25   DC    C'SEGLD/SEGWT'\nSVC$27   DC    C'LABEL'\nSVC$28   DC    C'EXTRACT'\nSVC$29   DC    C'IDENTIFY'\nSVC$2A   DC    C'ATTACH(X)'\nSVC$2B   DC    C'CIRB'\nSVC$2C   DC    C'CHAP'\nSVC$2D   DC    C'OVLYBRCH'\nSVC$2E   DC    C'STIMERM/TTIMER'\nSVC$2F   DC    C'STIMER/STIMERM'\nSVC$30   DC    C'DEQ'\nSVC$33   DC    C'SNAP(X)/SDUMP(X)'\nSVC$34   DC    C'RESTART'\nSVC$35   DC    C'RELEX'\nSVC$36   DC    C'DISABLE'\nSVC$37   DC    C'EOV'\nSVC$38   DC    C'ENQ/RESERVE'\nSVC$39   DC    C'FREEDBUF'\nSVC$3A   DC    C'RELBUF/REQBUF'\nSVC$3B   DC    C'OLTEP'\nSVC$3C   DC    C'STAE/ESTAE'\nSVC$3D   DC    C'IKJEGS6A'\nSVC$3E   DC    C'DETACH'\nSVC$3F   DC    C'CHKPT'\nSVC$40   DC    C'RDJFCB'\nSVC$42   DC    C'BTAMTEST'\nSVC$44   DC    C'SYNADAF/SYNADRLS'\nSVC$45   DC    C'BSP'\nSVC$46   DC    C'GSERV'\nSVC$47   DC    C'ASGNBFR/BUFINQ/RLSEBFR'\nSVC$49   DC    C'SPAR'\nSVC$4A   DC    C'DAR'\nSVC$4B   DC    C'DQUEUE'\nSVC$4C   DC    C'IFBSTAT'\nSVC$4E   DC    C'LSPACE'\nSVC$4F   DC    C'STATUS'\nSVC$51   DC    C'SETDEV/SETPRT'\nSVC$53   DC    C'SMFWTM/SMFEWTM,BRANCH=NO'\nSVC$54   DC    C'GRAPHICS'\nSVC$55   DC    C'DDRSWAP'\nSVC$56   DC    C'ATLAS'\nSVC$57   DC    C'DOM'\nSVC$5B   DC    C'VOLSTAT'\nSVC$5C   DC    C'TCPEXCP'\nSVC$5D   DC    C'TGET/TPG/TPUT'\nSVC$5E   DC    C'STCC (PLUS OTHERS)'\nSVC$5F   DC    C'SYSEVENT'\nSVC$60   DC    C'STAX'\nSVC$61   DC    C'IKJEGS9G'\nSVC$62   DC    C'PROTECT'\nSVC$63   DC    C'DYNALLOC'\nSVC$64   DC    C'IKJEFFIB'\nSVC$65   DC    C'QTIP'\nSVC$66   DC    C'AQCTL'\nSVC$67   DC    C'XLATE'\nSVC$68   DC    C'TOPCTL'\nSVC$69   DC    C'IMGLIB'\nSVC$6B   DC    C'MODESET'\nSVC$6D   DC    C'MFSTART/MFDATA/ESPIE/MSGDISP/ESR/OUTADD/OUTDEL'\nSVC$70   DC    C'PGRLSE'\nSVC$71   DC    C'PGANY/PGFIX/PGFREE/PGLOAD/PGOUT'\nSVC$72   DC    C'EXCPVR'\nSVC$74   DC    C'IECTRDTI/IECTATNR/CHNGNTRY/IECTCHGA/RESETPL/CALLDISP'\nSVC$75   DC    C'DEBCHK'\nSVC$77   DC    C'TESTAUTH'\nSVC$78   DC    C'GETMAIN/FREEMAIN'\nSVC$79   DC    C'VSAM'\nSVC$7A   DC    C'EVENTS/LINK/XCTL/LOAD'\nSVC$7B   DC    C'PURGEDQ'\nSVC$7C   DC    C'TPIO'\nSVC$7D   DC    C'EVENTS'\nSVC$7E   DC    C'MSS (ICB2SVC)'\nSVC$82   DC    C'RACHECK'\nSVC$83   DC    C'RACINIT'\nSVC$84   DC    C'RACLIST'\nSVC$85   DC    C'RACDEF'\nSVC$89   DC    C'ESR'\nSVC$8A   DC    C'PGSER'\nSVC$8B   DC    C'CVAFDIR/CVAFDSM/CVAFSEQ/CVAFVOL/CVAFVRF'\nSVC$8F   DC    C'CIPHER/EMK/GENKEY/RETKEY'\n         TITLE 'Instruction Attribute Flags'\nOpFlags     DS    0F\n            SPACE\n*---------------------------------------------------------------------*\n*           Attributes for RR format instructions                     *\n*---------------------------------------------------------------------*\n            SPACE\nbAttrRR_00  DC    AL1(bitILGL,bitRR,0,0)\nbAttrRR_01  DC    AL1(0,bitRR,0,0)                                LR\nbAttrRR_02  DC    AL1(bitBR,bitRR,0,0)\nbAttrRR_03  DC    AL1(bitBR+bitAMODE,bitRR,0,0)\nbAttrRR_04  DC    AL1(bitCC,bitRR,0,0)\nbAttrRR_05  DC    AL1(0,bitRR,bitDBLR,0)\nbAttrRR_06  DC    AL1(bitACCESS,bitRR,0,bitDUMPR)                 SVC\nbAttrRR_07  DC    AL1(bitCC+bitALTER,bitRR,0,0)                   MVCL\nbAttrRR_08  DC    AL1(0,bitRR,0,bitFLOAT)\nbAttrRR_09  DC    AL1(bitCC,bitRR,0,bitFLOAT)\nbAttrRR_10  DC    AL1(0,bitRR,bitDBLR,bitFLOAT)\nbAttrRR_11  DC    AL1(bitCC,bitRR,bitDBLR,bitFLOAT)\n            SPACE\n*---------------------------------------------------------------------*\n*           Attributes for RX format instructions                     *\n*---------------------------------------------------------------------*\n            SPACE\nbAttrRX_00  DC    AL1(bitILGL,bitRX,0,0)\nbAttrRX_01  DC    AL1(0,bitRX,bitFULL,0)\nbAttrRX_02  DC    AL1(0,bitRX,bitHALF,0)\nbAttrRX_03  DC    AL1(0,bitRX,bitBYTE,0)                          IC\nbAttrRX_04  DC    AL1(bitCC,bitRX,bitFULL,0)\nbAttrRX_05  DC    AL1(bitCC,bitRX,bitHALF,0)\nbAttrRX_06  DC    AL1(0,bitRX,bitDBLS,0)                          CVB\nbAttrRX_07  DC    AL1(bitALTER,bitRX,bitFULL,0)                   ST\nbAttrRX_08  DC    AL1(bitALTER,bitRX,bitHALF,0)                   STH\nbAttrRX_09  DC    AL1(bitALTER,bitRX,bitBYTE,0)                   STC\nbAttrRX_10  DC    AL1(bitALTER,bitRX,bitDBLS,0)                   CVD\nbAttrRX_11  DC    AL1(bitBR,bitRX,0,bitEX)                        EX\nbAttrRX_12  DC    AL1(bitBR,bitRX,0,0)\nbAttrRX_13  DC    AL1(0,bitRX,bitNOREF,0)                         LA\nbAttrRX_14  DC    AL1(0,bitRX,bitDBLR+bitFULL,0)\nbAttrRX_15  DC    AL1(0,bitRX,bitFULL,bitFLOAT)\nbAttrRX_16  DC    AL1(bitCC,bitRX,bitFULL,bitFLOAT)\nbAttrRX_17  DC    AL1(bitALTER,bitRX,bitFULL,bitFLOAT)\nbAttrRX_18  DC    AL1(0,bitRX,bitDBLR+bitDBLS,bitFLOAT)\nbAttrRX_19  DC    AL1(bitCC,bitRX,bitDBLR+bitDBLS,bitFLOAT)\nbAttrRX_20  DC    AL1(bitALTER,bitRX,bitDBLR+bitDBLS,bitFLOAT)    STD\nbAttrRX_21  DC    AL1(bitACCESS,bitRX,bitNOREF,0)                 LAE\n            SPACE\n*---------------------------------------------------------------------*\n*           Attributes for RS format instructions                     *\n*---------------------------------------------------------------------*\n            SPACE\nbAttrRS_00  DC    AL1(bitILGL,bitRS,0,0)\nbAttrRS_01  DC    AL1(bitBR,bitRS,0,0)\nbAttrRS_02  DC    AL1(0,bitRS,bitSHIFT+bitNOREF,0)\nbAttrRS_03  DC    AL1(bitCC,bitRS,bitSHIFT+bitNOREF,0)\nbAttrRS_04  DC    AL1(0,bitRS,bitDBLR+bitSHIFT+bitNOREF,0)\nbAttrRS_05  DC    AL1(bitCC,bitRS,bitDBLR+bitSHIFT+bitNOREF,0)\nbAttrRS_06  DC    AL1(0,bitRS,0,bitDUMPR)                         LM\nbAttrRS_07  DC    AL1(bitCC,bitRS,bitMASK,0)\nbAttrRS_08  DC    AL1(bitCC+bitALTER,bitRS,bitDBLR+bitDBLS,0)     CDS\nbAttrRS_09  DC    AL1(bitALTER,bitRS,0,bitDUMPR)\nbAttrRS_10  DC    AL1(bitCC+bitALTER,bitRS,bitFULL,0)             CS\nbAttrRS_11  DC    AL1(bitCC+bitALTER,bitRS,bitMASK,0)             STCM\nbAttrRS_12  DC    AL1(bitACCESS,bitRS,0,bitDUMPR)                 LAM\nbAttrRS_13  DC    AL1(bitACCESS+bitALTER,bitRS,0,bitDUMPR)        STAM\n            SPACE\n*---------------------------------------------------------------------*\n*           Attributes for RSI/RI format instructions                 *\n*---------------------------------------------------------------------*\n            SPACE\nbAttrRI_00  DC    AL1(bitILGL,bitRSI,0,0)\nbAttrRI_01  DC    AL1(bitBR,bitRSI,0,0)\nbAttrRI_02  DC    AL1(bitCC,bitRSI,bitNOREF,0)\nbAttrRI_03  DC    AL1(0,bitRSI,bitHALF+bitNOREF,0)                LHI\nbAttrRI_04  DC    AL1(bitCC,bitRSI,bitHALF+bitNOREF,0)\n            SPACE\n*---------------------------------------------------------------------*\n*           Attributes for SI format instructions                     *\n*---------------------------------------------------------------------*\n            SPACE\nbAttrSI_00  DC    AL1(bitILGL,bitSI,0,0)\nbAttrSI_01  DC    AL1(0,bitSI,bitNOREF,0)                         MC\nbAttrSI_02  DC    AL1(bitCC,bitSI,bitBYTE,0)\nbAttrSI_03  DC    AL1(bitALTER,bitSI,bitBYTE,0)                   MVI\nbAttrSI_04  DC    AL1(bitCC+bitALTER,bitSI,bitBYTE,0)\n            SPACE\n*---------------------------------------------------------------------*\n*           Attributes for S format instructions                      *\n*---------------------------------------------------------------------*\n            SPACE\nbAttrS_00   DC    AL1(bitILGL,bitSSI,0,0)\nbAttrS_01   DC    AL1(0,bitSSI,bitNOREF,0)\nbAttrS_02   DC    AL1(bitCC+bitALTER,bitSSI,bitDBLS,0)            STCK\nbAttrS_03   DC    AL1(bitCC+bitALTER,bitSSI,bitBYTE,0)            TS\nbAttrS_04   DC    AL1(bitACCESS,bitSSI,bitNOREF,bitDUMPR)         PC\nbAttrS_05   DC    AL1(bitCC,bitSSI,bitNOREF,0)                    CFC\nbAttrS_06   DC    AL1(bitACCESS,bitSSI,bitNOREF,0)\n            SPACE\n*---------------------------------------------------------------------*\n*           Attributes for SS format instructions                     *\n*---------------------------------------------------------------------*\n            SPACE\nbAttrSS_00  DC    AL1(bitILGL,bitSS,0,0)\nbAttrSS_01  DC    AL1(bitCC,bitSS+bitIMDF,0,0)\nbAttrSS_02  DC    AL1(bitALTER,bitSS+bitIMDF,0,0)\nbAttrSS_03  DC    AL1(bitCC+bitALTER,bitSS+bitIMDF,0,0)\nbAttrSS_04  DC    AL1(bitCC+bitPACKD,bitSS,0,0)                   CP\nbAttrSS_05  DC    AL1(bitPACKD+bitALTER,bitSS,0,0)\nbAttrSS_06  DC    AL1(bitCC+bitPACKD+bitALTER,bitSS,0,0)\nbAttrSS_07  DC    AL1(bitCC+bitMVCX,bitSS,0,0)                    MVCS\nbAttrSS_08  DC    AL1(bitCC+bitMVCX+bitALTER,bitSS,0,0)\n            SPACE\n*---------------------------------------------------------------------*\n*           Attributes for RRE format instructions                    *\n*---------------------------------------------------------------------*\n            SPACE\nbAttrRRE_00 DC    AL1(bitILGL,bitRRE,0,0)\nbAttrRRE_01 DC    AL1(0,bitRRE,0,0)\nbAttrRRE_02 DC    AL1(bitCC,bitRRE,0,0)\nbAttrRRE_03 DC    AL1(0,bitRRE,bitDBLR,bitFLOAT)                  DXR\nbAttrRRE_04 DC    AL1(bitBR+bitACCESS,bitRRE,0,bitDUMPR)          BAKR\nbAttrRRE_05 DC    AL1(bitCC+bitALTER,bitRRE,0,0)                  MVST\nbAttrRRE_06 DC    AL1(bitCC,bitRRE,bitDBLR,0)\nbAttrRRE_07 DC    AL1(bitACCESS,bitRRE,0,0)\nbAttrRRE_08 DC    AL1(bitCC+bitACCESS,bitRRE,0,0)\nbAttrRRE_09 DC    AL1(0,bitRRE,bitDBLR,0)\nbAttrRRE_10 DC    AL1(bitACCESS,bitRRE,0,bitDUMPR)                EREG\n            SPACE\n*---------------------------------------------------------------------*\n*           Attributes for E format instructions                      *\n*---------------------------------------------------------------------*\n            SPACE\nbAttrE_00   DC    AL1(bitILGL,bitRR,0,0)\nbAttrE_01   DC    AL1(0,bitRR,0,0)                                TRAP2\nbAttrE_02   DC    AL1(bitCC,bitRR,0,0)                            UPT\nbAttrE_03   DC    AL1(bitBR+bitACCESS+bitAMODE,bitRR,0,bitDUMPR)  PR\n         TITLE 'Instruction Attributes Index Table'\nOpIndex  DS    0H                       * = privileged, - = pre-XA only\n         DC    AL2(bAttrRR_00-OpFlags)   00  ...\n         DC    AL2(bAttrE_00-OpFlags)    01  PR/UPT/TRAP2/SCKPF\n         DC    AL2(bAttrRR_04-OpFlags)   02  ...\n         DC    AL2(bAttrRR_00-OpFlags)   03  ...\n         DC    AL2(bAttrRR_04-OpFlags)   04  SPM\n         DC    AL2(bAttrRR_02-OpFlags)   05  BALR\n         DC    AL2(bAttrRR_02-OpFlags)   06  BCTR\n         DC    AL2(bAttrRR_02-OpFlags)   07  BCR\n         DC    AL2(bAttrRR_00-OpFlags)   08 *SSK-\n         DC    AL2(bAttrRR_00-OpFlags)   09 *ISK-\n         DC    AL2(bAttrRR_06-OpFlags)   0A  SVC\n         DC    AL2(bAttrRR_03-OpFlags)   0B  BSM\n         DC    AL2(bAttrRR_03-OpFlags)   0C  BASSM\n         DC    AL2(bAttrRR_02-OpFlags)   0D  BASR\n         DC    AL2(bAttrRR_07-OpFlags)   0E  MVCL\n         DC    AL2(bAttrRR_04-OpFlags)   0F  CLCL\n         SPACE\n         DC    AL2(bAttrRR_04-OpFlags)   10  LPR\n         DC    AL2(bAttrRR_04-OpFlags)   11  LNR\n         DC    AL2(bAttrRR_04-OpFlags)   12  LTR\n         DC    AL2(bAttrRR_04-OpFlags)   13  LCR\n         DC    AL2(bAttrRR_04-OpFlags)   14  NR\n         DC    AL2(bAttrRR_04-OpFlags)   15  CLR\n         DC    AL2(bAttrRR_04-OpFlags)   16  OR\n         DC    AL2(bAttrRR_04-OpFlags)   17  XR\n         DC    AL2(bAttrRR_01-OpFlags)   18  LR\n         DC    AL2(bAttrRR_04-OpFlags)   19  CR\n         DC    AL2(bAttrRR_04-OpFlags)   1A  AR\n         DC    AL2(bAttrRR_04-OpFlags)   1B  SR\n         DC    AL2(bAttrRR_05-OpFlags)   1C  MR\n         DC    AL2(bAttrRR_05-OpFlags)   1D  DR\n         DC    AL2(bAttrRR_04-OpFlags)   1E  ALR\n         DC    AL2(bAttrRR_04-OpFlags)   1F  SLR\n         SPACE\n         DC    AL2(bAttrRR_11-OpFlags)   20  LPDR\n         DC    AL2(bAttrRR_11-OpFlags)   21  LNDR\n         DC    AL2(bAttrRR_11-OpFlags)   22  LTDR\n         DC    AL2(bAttrRR_11-OpFlags)   23  LCDR\n         DC    AL2(bAttrRR_10-OpFlags)   24  HDR\n         DC    AL2(bAttrRR_10-OpFlags)   25  LRDR\n         DC    AL2(bAttrRR_10-OpFlags)   26  MXR\n         DC    AL2(bAttrRR_10-OpFlags)   27  MXDR\n         DC    AL2(bAttrRR_10-OpFlags)   28  LDR\n         DC    AL2(bAttrRR_11-OpFlags)   29  CDR\n         DC    AL2(bAttrRR_11-OpFlags)   2A  ADR\n         DC    AL2(bAttrRR_11-OpFlags)   2B  SDR\n         DC    AL2(bAttrRR_10-OpFlags)   2C  MDR\n         DC    AL2(bAttrRR_10-OpFlags)   2D  DDR\n         DC    AL2(bAttrRR_11-OpFlags)   2E  AWR\n         DC    AL2(bAttrRR_11-OpFlags)   2F  SWR\n         SPACE\n         DC    AL2(bAttrRR_09-OpFlags)   30  LPER\n         DC    AL2(bAttrRR_09-OpFlags)   31  LNER\n         DC    AL2(bAttrRR_09-OpFlags)   32  LTER\n         DC    AL2(bAttrRR_09-OpFlags)   33  LCER\n         DC    AL2(bAttrRR_08-OpFlags)   34  HER\n         DC    AL2(bAttrRR_08-OpFlags)   35  LRER\n         DC    AL2(bAttrRR_11-OpFlags)   36  AXR\n         DC    AL2(bAttrRR_11-OpFlags)   37  SXR\n         DC    AL2(bAttrRR_08-OpFlags)   38  LER\n         DC    AL2(bAttrRR_09-OpFlags)   39  CER\n         DC    AL2(bAttrRR_09-OpFlags)   3A  AER\n         DC    AL2(bAttrRR_09-OpFlags)   3B  SER\n         DC    AL2(bAttrRR_08-OpFlags)   3C  MER\n         DC    AL2(bAttrRR_08-OpFlags)   3D  DER\n         DC    AL2(bAttrRR_09-OpFlags)   3E  AUR\n         DC    AL2(bAttrRR_09-OpFlags)   3F  SUR\n         SPACE\n         DC    AL2(bAttrRX_08-OpFlags)   40  STH\n         DC    AL2(bAttrRX_13-OpFlags)   41  LA\n         DC    AL2(bAttrRX_09-OpFlags)   42  STC\n         DC    AL2(bAttrRX_03-OpFlags)   43  IC\n         DC    AL2(bAttrRX_11-OpFlags)   44  EX\n         DC    AL2(bAttrRX_12-OpFlags)   45  BAL\n         DC    AL2(bAttrRX_12-OpFlags)   46  BCT\n         DC    AL2(bAttrRX_12-OpFlags)   47  BC\n         DC    AL2(bAttrRX_02-OpFlags)   48  LH\n         DC    AL2(bAttrRX_05-OpFlags)   49  CH\n         DC    AL2(bAttrRX_05-OpFlags)   4A  AH\n         DC    AL2(bAttrRX_05-OpFlags)   4B  SH\n         DC    AL2(bAttrRX_02-OpFlags)   4C  MH\n         DC    AL2(bAttrRX_12-OpFlags)   4D  BAS\n         DC    AL2(bAttrRX_10-OpFlags)   4E  CVD\n         DC    AL2(bAttrRX_06-OpFlags)   4F  CVB\n         SPACE\n         DC    AL2(bAttrRX_07-OpFlags)   50  ST\n         DC    AL2(bAttrRX_21-OpFlags)   51  LAE\n         DC    AL2(bAttrRX_00-OpFlags)   52  ...\n         DC    AL2(bAttrRX_00-OpFlags)   53  ...\n         DC    AL2(bAttrRX_04-OpFlags)   54  N\n         DC    AL2(bAttrRX_04-OpFlags)   55  CL\n         DC    AL2(bAttrRX_04-OpFlags)   56  O\n         DC    AL2(bAttrRX_04-OpFlags)   57  X\n         DC    AL2(bAttrRX_01-OpFlags)   58  L\n         DC    AL2(bAttrRX_04-OpFlags)   59  C\n         DC    AL2(bAttrRX_04-OpFlags)   5A  A\n         DC    AL2(bAttrRX_04-OpFlags)   5B  S\n         DC    AL2(bAttrRX_14-OpFlags)   5C  M\n         DC    AL2(bAttrRX_14-OpFlags)   5D  D\n         DC    AL2(bAttrRX_04-OpFlags)   5E  AL\n         DC    AL2(bAttrRX_04-OpFlags)   5F  SL\n         SPACE\n         DC    AL2(bAttrRX_20-OpFlags)   60  STD\n         DC    AL2(bAttrRX_00-OpFlags)   61  ...\n         DC    AL2(bAttrRX_00-OpFlags)   62  ...\n         DC    AL2(bAttrRX_00-OpFlags)   63  ...\n         DC    AL2(bAttrRX_00-OpFlags)   64  ...\n         DC    AL2(bAttrRX_00-OpFlags)   65  ...\n         DC    AL2(bAttrRX_00-OpFlags)   66  ...\n         DC    AL2(bAttrRX_18-OpFlags)   67  MXD\n         DC    AL2(bAttrRX_18-OpFlags)   68  LD\n         DC    AL2(bAttrRX_19-OpFlags)   69  CD\n         DC    AL2(bAttrRX_19-OpFlags)   6A  AD\n         DC    AL2(bAttrRX_19-OpFlags)   6B  SD\n         DC    AL2(bAttrRX_18-OpFlags)   6C  MD\n         DC    AL2(bAttrRX_19-OpFlags)   6D  DD\n         DC    AL2(bAttrRX_19-OpFlags)   6E  AW\n         DC    AL2(bAttrRX_19-OpFlags)   6F  SW\n         SPACE\n         DC    AL2(bAttrRX_17-OpFlags)   70  STE\n         DC    AL2(bAttrRX_01-OpFlags)   71  MS\n         DC    AL2(bAttrRX_00-OpFlags)   72  ...\n         DC    AL2(bAttrRX_00-OpFlags)   73  ...\n         DC    AL2(bAttrRX_00-OpFlags)   74  ...\n         DC    AL2(bAttrRX_00-OpFlags)   75  ...\n         DC    AL2(bAttrRX_00-OpFlags)   76  ...\n         DC    AL2(bAttrRX_00-OpFlags)   77  ...\n         DC    AL2(bAttrRX_15-OpFlags)   78  LE\n         DC    AL2(bAttrRX_16-OpFlags)   79  CE\n         DC    AL2(bAttrRX_16-OpFlags)   7A  AE\n         DC    AL2(bAttrRX_16-OpFlags)   7B  SE\n         DC    AL2(bAttrRX_15-OpFlags)   7C  ME\n         DC    AL2(bAttrRX_15-OpFlags)   7D  DE\n         DC    AL2(bAttrRX_16-OpFlags)   7E  AU\n         DC    AL2(bAttrRX_16-OpFlags)   7F  AU\n         SPACE\n         DC    AL2(bAttrS_00-OpFlags)    80 *SSM\n         DC    AL2(bAttrS_00-OpFlags)    81  ...\n         DC    AL2(bAttrS_00-OpFlags)    82 *LPSW\n         DC    AL2(bAttrS_00-OpFlags)    83 *DIAG\n         DC    AL2(bAttrRI_01-OpFlags)   84  BRXH\n         DC    AL2(bAttrRI_01-OpFlags)   85  BRXLE\n         DC    AL2(bAttrRS_01-OpFlags)   86  BXH\n         DC    AL2(bAttrRS_01-OpFlags)   87  BXLE\n         DC    AL2(bAttrRS_02-OpFlags)   88  SRL\n         DC    AL2(bAttrRS_02-OpFlags)   89  SLL\n         DC    AL2(bAttrRS_03-OpFlags)   8A  SRA\n         DC    AL2(bAttrRS_03-OpFlags)   8B  SLA\n         DC    AL2(bAttrRS_04-OpFlags)   8C  SRDL\n         DC    AL2(bAttrRS_04-OpFlags)   8D  SLDL\n         DC    AL2(bAttrRS_05-OpFlags)   8E  SRDA\n         DC    AL2(bAttrRS_05-OpFlags)   8F  SLDA\n         SPACE\n         DC    AL2(bAttrRS_09-OpFlags)   90  STM\n         DC    AL2(bAttrSI_02-OpFlags)   91  TM\n         DC    AL2(bAttrSI_03-OpFlags)   92  MVI\n         DC    AL2(bAttrS_03-OpFlags)    93  TS\n         DC    AL2(bAttrSI_04-OpFlags)   94  NI\n         DC    AL2(bAttrSI_02-OpFlags)   95  CLI\n         DC    AL2(bAttrSI_04-OpFlags)   96  OI\n         DC    AL2(bAttrSI_04-OpFlags)   97  XI\n         DC    AL2(bAttrRS_06-OpFlags)   98  LM\n         DC    AL2(bAttrRS_00-OpFlags)   99 *TRACE\n         DC    AL2(bAttrRS_12-OpFlags)   9A  LAM\n         DC    AL2(bAttrRS_13-OpFlags)   9B  STAM\n         DC    AL2(bAttrS_00-OpFlags)    9C *SIO-\n         DC    AL2(bAttrS_00-OpFlags)    9D *TIO-\n         DC    AL2(bAttrS_00-OpFlags)    9E *HIO-\n         DC    AL2(bAttrS_00-OpFlags)    9F *TCH-\n         SPACE\n         DC    AL2(bAttrS_00-OpFlags)    A0  ...\n         DC    AL2(bAttrS_00-OpFlags)    A1  ...\n         DC    AL2(bAttrS_00-OpFlags)    A2  ...\n         DC    AL2(bAttrS_00-OpFlags)    A3  ...\n         DC    AL2(bAttrS_00-OpFlags)    A4  VAE\n         DC    AL2(bAttrS_00-OpFlags)    A5  VAER\n         DC    AL2(bAttrS_00-OpFlags)    A6  VM\n         DC    AL2(bAttrS_00-OpFlags)    A7  A7rx\n         DC    AL2(bAttrRR_07-OpFlags)   A8  MVCLE\n         DC    AL2(bAttrRR_04-OpFlags)   A9  CLCLE\n         DC    AL2(bAttrS_00-OpFlags)    AA  ...\n         DC    AL2(bAttrS_00-OpFlags)    AB  ...\n         DC    AL2(bAttrSI_00-OpFlags)   AC *STNSM\n         DC    AL2(bAttrSI_00-OpFlags)   AD *STOSM\n         DC    AL2(bAttrRS_00-OpFlags)   AE *SIGP\n         DC    AL2(bAttrSI_01-OpFlags)   AF  MC\n         SPACE\n         DC    AL2(bAttrSI_00-OpFlags)   B0  ...\n         DC    AL2(bAttrRX_00-OpFlags)   B1 *LRA\n         DC    AL2(bAttrS_00-OpFlags)    B2  B2xx\n         DC    AL2(bAttrRRE_00-OpFlags)  B3  B3xx (HFP and BFP)\n         DC    AL2(bAttrRS_00-OpFlags)   B4  ...\n         DC    AL2(bAttrRS_00-OpFlags)   B5  ...\n         DC    AL2(bAttrRS_00-OpFlags)   B6 *STCTL\n         DC    AL2(bAttrRS_00-OpFlags)   B7 *LCTL\n         DC    AL2(bAttrRS_00-OpFlags)   B8  ...\n         DC    AL2(bAttrRS_00-OpFlags)   B9  ...\n         DC    AL2(bAttrRS_10-OpFlags)   BA  CS\n         DC    AL2(bAttrRS_08-OpFlags)   BB  CDS\n         DC    AL2(bAttrRS_00-OpFlags)   BC  ...\n         DC    AL2(bAttrRS_07-OpFlags)   BD  CLM\n         DC    AL2(bAttrRS_11-OpFlags)   BE  STCM\n         DC    AL2(bAttrRS_07-OpFlags)   BF  ICM\n         SPACE\n         DC    AL2(bAttrSS_00-OpFlags)   C0  ...\n         DC    AL2(bAttrSS_00-OpFlags)   C1  ...\n         DC    AL2(bAttrSS_00-OpFlags)   C2  ...\n         DC    AL2(bAttrSS_00-OpFlags)   C3  ...\n         DC    AL2(bAttrSS_00-OpFlags)   C4  ...\n         DC    AL2(bAttrSS_00-OpFlags)   C5  ...\n         DC    AL2(bAttrSS_00-OpFlags)   C6  ...\n         DC    AL2(bAttrSS_00-OpFlags)   C7  ...\n         DC    AL2(bAttrSS_00-OpFlags)   C8  ...\n         DC    AL2(bAttrSS_00-OpFlags)   C9  ...\n         DC    AL2(bAttrSS_00-OpFlags)   CA  ...\n         DC    AL2(bAttrSS_00-OpFlags)   CB  ...\n         DC    AL2(bAttrSS_00-OpFlags)   CC  ...\n         DC    AL2(bAttrSS_00-OpFlags)   CD  ...\n         DC    AL2(bAttrSS_00-OpFlags)   CE  ...\n         DC    AL2(bAttrSS_00-OpFlags)   CF  ...\n         SPACE\n         DC    AL2(bAttrSS_00-OpFlags)   D0  ...\n         DC    AL2(bAttrSS_02-OpFlags)   D1  MVN\n         DC    AL2(bAttrSS_02-OpFlags)   D2  MVC\n         DC    AL2(bAttrSS_02-OpFlags)   D3  MVZ\n         DC    AL2(bAttrSS_03-OpFlags)   D4  NC\n         DC    AL2(bAttrSS_01-OpFlags)   D5  CLC\n         DC    AL2(bAttrSS_03-OpFlags)   D6  OC\n         DC    AL2(bAttrSS_03-OpFlags)   D7  XC\n         DC    AL2(bAttrSS_00-OpFlags)   D8  ...\n         DC    AL2(bAttrSS_08-OpFlags)   D9  MVCK\n         DC    AL2(bAttrSS_08-OpFlags)   DA  MVCP\n         DC    AL2(bAttrSS_07-OpFlags)   DB  MVCS\n         DC    AL2(bAttrSS_03-OpFlags)   DC  TR\n         DC    AL2(bAttrSS_01-OpFlags)   DD  TRT\n         DC    AL2(bAttrSS_03-OpFlags)   DE  ED\n         DC    AL2(bAttrSS_03-OpFlags)   DF  EDMK\n         SPACE\n         DC    AL2(bAttrSS_00-OpFlags)   E0  ...\n         DC    AL2(bAttrSS_00-OpFlags)   E1  ...\n         DC    AL2(bAttrSS_00-OpFlags)   E2  ...\n         DC    AL2(bAttrSS_00-OpFlags)   E3  ...\n         DC    AL2(bAttrSS_00-OpFlags)   E4  ...\n         DC    AL2(bAttrSS_00-OpFlags)   E5 *LASP/TPROT/MVCSK/MVCDK\n         DC    AL2(bAttrSS_00-OpFlags)   E6  ...\n         DC    AL2(bAttrSS_00-OpFlags)   E7  ...\n         DC    AL2(bAttrSS_02-OpFlags)   E8  MVCIN\n         DC    AL2(bAttrSS_00-OpFlags)   E9  ...\n         DC    AL2(bAttrSS_00-OpFlags)   EA  ...\n         DC    AL2(bAttrSS_00-OpFlags)   EB  ...\n         DC    AL2(bAttrSS_00-OpFlags)   EC  ...\n         DC    AL2(bAttrSS_00-OpFlags)   ED  EDxx (BFP instructions)\n         DC    AL2(bAttrSS_00-OpFlags)   EE  PLO\n         DC    AL2(bAttrSS_00-OpFlags)   EF  ...\n         SPACE\n         DC    AL2(bAttrSS_06-OpFlags)   F0  SRP\n         DC    AL2(bAttrSS_05-OpFlags)   F1  MVO\n         DC    AL2(bAttrSS_05-OpFlags)   F2  PACK\n         DC    AL2(bAttrSS_05-OpFlags)   F3  UNPK\n         DC    AL2(bAttrSS_00-OpFlags)   F4  ...\n         DC    AL2(bAttrSS_00-OpFlags)   F5  ...\n         DC    AL2(bAttrSS_00-OpFlags)   F6  ...\n         DC    AL2(bAttrSS_00-OpFlags)   F7  ...\n         DC    AL2(bAttrSS_06-OpFlags)   F8  ZAP\n         DC    AL2(bAttrSS_04-OpFlags)   F9  CP\n         DC    AL2(bAttrSS_06-OpFlags)   FA  AP\n         DC    AL2(bAttrSS_06-OpFlags)   FB  SP\n         DC    AL2(bAttrSS_05-OpFlags)   FC  MP\n         DC    AL2(bAttrSS_05-OpFlags)   FD  DP\n         DC    AL2(bAttrSS_00-OpFlags)   FE  ...\n         DC    AL2(bAttrSS_00-OpFlags)   FF  ...\n         SPACE 3\n*---------------------------------------------------------------------*\n*        Attributes for x'01' prefixed instructions                   *\n*---------------------------------------------------------------------*\n         SPACE\nO1Index  DS    0H\n         DC    AL2(bAttrE_00-OpFlags)    00  ...\n         DC    AL2(bAttrE_03-OpFlags)    01  PR\n         DC    AL2(bAttrE_02-OpFlags)    02  UPT\n         DC 252AL2(bAttrE_00-OpFlags)    ??  ...   <--- Note repetition\n         DC    AL2(bAttrE_01-OpFlags)    FF  TRAP2\n         SPACE 3\n*---------------------------------------------------------------------*\n*        Attributes for x'A2' prefixed instructions                   *\n*---------------------------------------------------------------------*\n         SPACE\nA7Index  DS    0H\n         DC    AL2(bAttrRI_02-OpFlags)   00  TMH\n         DC    AL2(bAttrRI_02-OpFlags)   01  TML\n         DC    AL2(bAttrRI_00-OpFlags)   02  ...\n         DC    AL2(bAttrRI_00-OpFlags)   03  ...\n         DC    AL2(bAttrRI_01-OpFlags)   04  BRC\n         DC    AL2(bAttrRI_01-OpFlags)   05  BRAS\n         DC    AL2(bAttrRI_01-OpFlags)   06  BRCT\n         DC    AL2(bAttrRI_00-OpFlags)   07  ...\n         DC    AL2(bAttrRI_03-OpFlags)   08  LHI\n         DC    AL2(bAttrRI_00-OpFlags)   09  ...\n         DC    AL2(bAttrRI_04-OpFlags)   0A  AHI\n         DC    AL2(bAttrRI_00-OpFlags)   0B  ...\n         DC    AL2(bAttrRI_04-OpFlags)   0C  MHI\n         DC    AL2(bAttrRI_00-OpFlags)   0D  ...\n         DC    AL2(bAttrRI_04-OpFlags)   0E  CHI\n         DC    AL2(bAttrRI_00-OpFlags)   0F  ...\n         SPACE 3\n*---------------------------------------------------------------------*\n*        Attributes for x'B2' prefixed instructions                   *\n*---------------------------------------------------------------------*\n         SPACE\nB2Index  DS    0H\n         DC    AL2(bAttrS_00-OpFlags)    00 *CONCS-\n         DC    AL2(bAttrS_00-OpFlags)    01 *DISCS-\n         DC    AL2(bAttrS_00-OpFlags)    02 *STIDP\n         DC    AL2(bAttrS_00-OpFlags)    03 *STIDC-\n         DC    AL2(bAttrS_00-OpFlags)    04 *SCK\n         DC    AL2(bAttrS_02-OpFlags)    05  STCK\n         DC    AL2(bAttrS_00-OpFlags)    06 *SCKC\n         DC    AL2(bAttrS_00-OpFlags)    07 *STCKC\n         DC    AL2(bAttrS_00-OpFlags)    08 *SPT\n         DC    AL2(bAttrS_00-OpFlags)    09 *STPT\n         DC    AL2(bAttrS_01-OpFlags)    0A  SPKA\n         DC    AL2(bAttrS_01-OpFlags)    0B  IPK\n         DC    AL2(bAttrS_00-OpFlags)    0C  ...\n         DC    AL2(bAttrS_00-OpFlags)    0D *PTLB\n         DC    AL2(bAttrS_00-OpFlags)    0E  ...\n         DC    AL2(bAttrS_00-OpFlags)    0F  ...\n         SPACE\n         DC    AL2(bAttrS_00-OpFlags)    10 *SPX\n         DC    AL2(bAttrS_00-OpFlags)    11 *STPX\n         DC    AL2(bAttrS_00-OpFlags)    12 *STAP\n         DC    AL2(bAttrS_00-OpFlags)    13 *RRB-\n         DC    AL2(bAttrS_00-OpFlags)    14  ...\n         DC    AL2(bAttrS_00-OpFlags)    15  ...\n         DC    AL2(bAttrS_00-OpFlags)    16  ...\n         DC    AL2(bAttrS_00-OpFlags)    17  ...\n         DC    AL2(bAttrS_04-OpFlags)    18  PC/PCF\n         DC    AL2(bAttrS_06-OpFlags)    19  SAC\n         DC    AL2(bAttrS_05-OpFlags)    1A  CFC\n         DC    AL2(bAttrS_00-OpFlags)    1B  ...\n         DC    AL2(bAttrS_00-OpFlags)    1C  ...\n         DC    AL2(bAttrS_00-OpFlags)    1D  ...\n         DC    AL2(bAttrS_00-OpFlags)    1E  ...\n         DC    AL2(bAttrS_00-OpFlags)    1F  ...\n         SPACE\n         DC    AL2(bAttrRRE_00-OpFlags)  20  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  21 *IPTE\n         DC    AL2(bAttrRRE_01-OpFlags)  22  IPM\n         DC    AL2(bAttrRRE_01-OpFlags)  23  IVSK\n         DC    AL2(bAttrRRE_02-OpFlags)  24  IAC\n         DC    AL2(bAttrRRE_01-OpFlags)  25  SSAR\n         DC    AL2(bAttrRRE_01-OpFlags)  26  EPAR\n         DC    AL2(bAttrRRE_01-OpFlags)  27  ESAR\n         DC    AL2(bAttrRRE_00-OpFlags)  28  PT\n         DC    AL2(bAttrRRE_00-OpFlags)  29 *ISKE\n         DC    AL2(bAttrRRE_00-OpFlags)  2A *RRBE\n         DC    AL2(bAttrRRE_00-OpFlags)  2B *SSKE\n         DC    AL2(bAttrRRE_00-OpFlags)  2C *TB\n         DC    AL2(bAttrRRE_03-OpFlags)  2D  DXR\n         DC    AL2(bAttrRRE_00-OpFlags)  2E  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  2F  ...\n         SPACE\n         DC    AL2(bAttrRRE_00-OpFlags)  30 *CSCH\n         DC    AL2(bAttrRRE_00-OpFlags)  31 *HSCH\n         DC    AL2(bAttrRRE_00-OpFlags)  32 *MSCH\n         DC    AL2(bAttrRRE_00-OpFlags)  33 *SSCH\n         DC    AL2(bAttrRRE_00-OpFlags)  34 *STSCH\n         DC    AL2(bAttrRRE_00-OpFlags)  35 *TSCH\n         DC    AL2(bAttrRRE_00-OpFlags)  36 *TPI\n         DC    AL2(bAttrRRE_00-OpFlags)  37 *SAL\n         DC    AL2(bAttrRRE_00-OpFlags)  38 *RSCH\n         DC    AL2(bAttrRRE_00-OpFlags)  39 *STCRW\n         DC    AL2(bAttrRRE_00-OpFlags)  3A *STCPS\n         DC    AL2(bAttrRRE_00-OpFlags)  3B *RCHP\n         DC    AL2(bAttrRRE_00-OpFlags)  3C *SCHM\n         DC    AL2(bAttrRRE_00-OpFlags)  3D  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  3E  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  3F  ...\n         SPACE\n         DC    AL2(bAttrRRE_04-OpFlags)  40  BAKR\n         DC    AL2(bAttrRRE_06-OpFlags)  41  CKSM\n         DC    AL2(bAttrRRE_00-OpFlags)  42  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  43  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  44  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  45  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  46  STURA\n         DC    AL2(bAttrRRE_09-OpFlags)  47  MSTA\n         DC    AL2(bAttrRRE_00-OpFlags)  48  PALB\n         DC    AL2(bAttrRRE_10-OpFlags)  49  EREG\n         DC    AL2(bAttrRRE_06-OpFlags)  4A  ESTA\n         DC    AL2(bAttrRRE_00-OpFlags)  4B  LURA\n         DC    AL2(bAttrRRE_08-OpFlags)  4C  TAR\n         DC    AL2(bAttrRRE_07-OpFlags)  4D  CPYA\n         DC    AL2(bAttrRRE_07-OpFlags)  4E  SAR\n         DC    AL2(bAttrRRE_07-OpFlags)  4F  EAR\n         SPACE\n         DC    AL2(bAttrRRE_00-OpFlags)  50  CSP\n         DC    AL2(bAttrRRE_00-OpFlags)  51  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  52  MSR\n         DC    AL2(bAttrRRE_00-OpFlags)  53  ...\n         DC    AL2(bAttrRRE_08-OpFlags)  54  MVPG\n         DC    AL2(bAttrRRE_05-OpFlags)  55  MVST\n         DC    AL2(bAttrRRE_00-OpFlags)  56  ...\n         DC    AL2(bAttrRRE_06-OpFlags)  57  CUSE\n         DC    AL2(bAttrRRE_00-OpFlags)  58  BSG\n         DC    AL2(bAttrRRE_00-OpFlags)  59  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  5A  BSA\n         DC    AL2(bAttrRRE_00-OpFlags)  5B  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  5C  ...\n         DC    AL2(bAttrRRE_02-OpFlags)  5D  CLST\n         DC    AL2(bAttrRRE_02-OpFlags)  5E  SRST\n         DC    AL2(bAttrRRE_00-OpFlags)  5F  ...\n         SPACE\n         DC    AL2(bAttrRRE_00-OpFlags)  60  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  61  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  62  ...\n         DC    AL2(bAttrRRE_06-OpFlags)  63  CMPSC\n         DC    AL2(bAttrRRE_00-OpFlags)  64  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  65  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  66  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  67  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  68  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  69  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  6A  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  6B  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  6C  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  6D  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  6E  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  6F  ...\n         SPACE\n         DC    AL2(bAttrRRE_00-OpFlags)  70  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  71  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  72  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  73  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  74  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  75  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  76  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  77  RP\n         DC    AL2(bAttrS_00-OpFlags)    78  STCKE\n         DC    AL2(bAttrS_06-OpFlags)    79  SACF\n         DC    AL2(bAttrS_00-OpFlags)    7A  ...\n         DC    AL2(bAttrS_00-OpFlags)    7B  ...\n         DC    AL2(bAttrS_00-OpFlags)    7C  ...\n         DC    AL2(bAttrS_00-OpFlags)    7D *STSI\n         DC    AL2(bAttrS_00-OpFlags)    7E  ...\n         DC    AL2(bAttrS_00-OpFlags)    7F  ...\n         SPACE\n         DC    AL2(bAttrRRE_00-OpFlags)  80  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  81  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  82  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  83  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  84  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  85  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  86  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  87  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  88  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  89  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  8A  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  8B  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  8C  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  8D  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  8E  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  8F  ...\n         SPACE\n         DC    AL2(bAttrRRE_00-OpFlags)  90  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  91  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  92  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  93  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  94  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  95  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  96  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  97  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  98  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  99  SRNM\n         DC    AL2(bAttrRRE_00-OpFlags)  9A  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  9B  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  9C  STFPC\n         DC    AL2(bAttrRRE_00-OpFlags)  9D  LFPC\n         DC    AL2(bAttrRRE_00-OpFlags)  9E  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  9F  ...\n         SPACE\n         DC    AL2(bAttrRRE_00-OpFlags)  A0  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  A1  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  A2  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  A3  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  A4  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  A5  TRE\n         DC    AL2(bAttrRRE_00-OpFlags)  A6  CUUTF\n         DC    AL2(bAttrRRE_00-OpFlags)  A7  CUTFU\n         DC    AL2(bAttrRRE_00-OpFlags)  A8  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  A9  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  AA  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  AB  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  AC  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  AD  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  AE  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  AF  ...\n         SPACE\n         DC    AL2(bAttrRRE_00-OpFlags)  B0  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  B1  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  B2  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  B3  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  B4  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  B5  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  B6  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  B7  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  B8  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  B9  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  BA  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  BB  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  BC  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  BD  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  BE  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  BF  ...\n         SPACE\n         DC    AL2(bAttrRRE_00-OpFlags)  C0  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  C1  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  C2  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  C3  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  C4  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  C5  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  C6  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  C7  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  C8  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  C9  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  CA  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  CB  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  CC  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  CD  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  CE  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  CF  ...\n         SPACE\n         DC    AL2(bAttrRRE_00-OpFlags)  D0  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  D1  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  D2  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  D3  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  D4  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  D5  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  D6  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  D7  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  D8  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  D9  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  DA  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  DB  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  DC  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  DD  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  DE  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  DF  ...\n         SPACE\n         DC    AL2(bAttrRRE_00-OpFlags)  E0  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  E1  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  E2  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  E3  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  E4  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  E5  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  E6  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  E7  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  E8  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  E9  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  EA  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  EB  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  EC  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  ED  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  EE  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  EF  ...\n         SPACE\n         DC    AL2(bAttrRRE_00-OpFlags)  F0  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  F1  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  F2  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  F3  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  F4  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  F5  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  F6  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  F7  ...\n         DC    AL2(bAttrRRE_00-OpFlags)  F8  ...\n         DC    AL2(bAttrS_00-OpFlags)    F9  ...\n         DC    AL2(bAttrS_00-OpFlags)    FA  ...\n         DC    AL2(bAttrS_00-OpFlags)    FB  ...\n         DC    AL2(bAttrS_00-OpFlags)    FC  ...\n         DC    AL2(bAttrS_00-OpFlags)    FD  ...\n         DC    AL2(bAttrS_00-OpFlags)    FE  ...\n         DC    AL2(bAttrS_01-OpFlags)    FF  TRAP4\n         TITLE 'Program Working Storage (Global)'\n***********************************************************************\n*                                                                     *\n*        Modifiable code and storage areas                            *\n*                                                                     *\n***********************************************************************\n         SPACE\nTr390$WS CSECT ,                    Origin of the modifiable data area\nTr390$WS AMODE 31\nTr390$WS RMODE 24\n         SPACE\n***********************************************************************\n*        All references to R0t in the following labelled instructions *\n*        are modified to reference a dynamically selected temporary   *\n*        base register before the code sequence is invoked!           *\n*                                                                     *\n*        Uncomment the 'BR 0' instruction(s) below if you believe     *\n*        your CPU's instruction pipeline is deep enough that any      *\n*        instructions may have been prefetched BEFORE they are        *\n*        modified by us.                                              *\n*                                                                     *\n***********************************************************************\n         SPACE\n*---------------------------------------------------------------------*\n*        Execute an instruction from the traced program (no ARs)      *\n*---------------------------------------------------------------------*\n         SPACE\nExecute1 DS    0H\n*+++     BR    0                    Ensure that any instructions we    -\n                                    ... zapped that are already in the -\n                                    ... pipeline are discarded\n         SPACE\n         LM    R00,R15,TraceGPRs    Reload traced program's GPRs\n         SPACE\n         PUSH  USING\n         DROP  R10                  Cannnot use R10 past this point\nExecIns1 DS    0XL6                 Executed instruction\n         NOPR  0                    ... (padded with NOPR's)\n         NOPR  0                    ...\n         NOPR  0                    ...\nZap1BASR BASR  R0t,0                Temp addressibility to Tr390$WA\n         USING *,R0t                ...\n         SPACE\n*---------------------------------------------------------------------*\n*        Save the general registers used by the traced program        *\n*---------------------------------------------------------------------*\n         SPACE\nZap1STM  STM   R00,R15,TraceGPRs    Save traced program's GPRs\n         IPM   R00                  Save the condition code\n         DROP  R0t\n         SPACE\n         BASR  R01,0                Use R01 as temporary program base\n         USING *,R01                ...\n         SPACE\nZap1LA   LA    R15,4*R0t(0,0)       Offset to R0t in 'OldRegs'\n         L     R14,OldRegs(R15)     Restore original value of R0t\n         ST    R14,TraceGPRs(R15)   ...\n         LM    R03,R13,SaveRegs+4*3 Restore callers registers\n         LAM   AR14,AR01,HexZeros   Ensure \"scratch\" ARs are zero\n         BSM   0,R03                and return to caller of 'ExecInst'\n         POP   USING\n         EJECT\n***********************************************************************\n*                                                                     *\n*        Execute an instruction from the traced program (ARs used)    *\n*                                                                     *\n***********************************************************************\n         SPACE\nExecute2 DS    0H\n*+++     BR    0                    Ensure that any instructions we    -\n                                    ... zapped that are already in the -\n                                    ... pipeline are discarded\n         SPACE\n         LM    R00,R09,TraceGPRs    Reload traced program's GPRs\n         LM    R11,R15,TraceGPRs+4*11 ... except R10\n         LAM   AR00,AR15,TraceARs   Reload traced program's access regs\n         L     R10,(TraceGPRs-Tr390$WS)+4*10(R10,0) Reload traced R10\n         SPACE\n         PUSH  USING\n         DROP  R10                  Cannnot use R10 past this point\nExecIns2 DS    0XL6                 Executed instruction\n         NOPR  0                    ... (padded with NOPR's)\n         NOPR  0                    ...\n         NOPR  0                    ...\nZap2BASR BASR  R0t,0                Temp addressibility to Tr390$WA\n         USING *,R0t                ...\n         SPACE\n*---------------------------------------------------------------------*\n*        Save general & access registers used by the traced program   *\n*---------------------------------------------------------------------*\n         SPACE\nZap2ST   ST    R15,TraceGPRs+4*15   Save traced program's R15\nZap2EAR  EAR   R15,AR0t             Save copy of AR0t value in R15\nZap2LAM1 LAM   AR0t,AR0t,HexZeros   ... and then zero AR0t\nZap2STM  STM   R00,R14,TraceGPRs    Save traced program's GPRs\nZap2STAM STAM  AR00,AR15,TraceARs   Save traced program's ARs\nZap2LAM2 LAM   R00,R15,HexZeros     Clear all access registers\n         IPM   R00                  Save the condition code\n         DROP  R0t\n         SPACE\n         BASR  R01,0                Use R01 as temporary program base\n         USING *,R01                ...\n         SPACE\nZap2LA   LA    R02,4*R0t(0,0)       Offset to R0t in 'OldRegs'\n         L     R14,OldRegs(R02)     Restore original value of R0t\n         ST    R14,TraceGPRs(R02)   ...\n         SPACE\n         ST    R15,TraceARs(R02)    Save traced program's AR0t\n         IAC   R02                  Save current ASC mode\n         STCM  R02,B'0010',TraceASC ...\n         NI    TraceASC,X'03'       ... and mask out any garbage\n         LM    R03,R13,SaveRegs+4*3 Restore callers registers\n         BSM   0,R03                and return to caller of 'ExecInst'\n         POP   USING\n         EJECT\n***********************************************************************\n*                                                                     *\n*        Execute BAKR instruction (or return from PR instruction)     *\n*                                                                     *\n***********************************************************************\n         SPACE\nExecute3 DS    0H\n         NI    Zap3BRC+1,X'0F'      NOP the JUMP\n*+++     BR    0                    Flush instruction pipeline in case -\n                                    ... Zap3BRC is already in it\n         SR    R01,R01              Set PSW condition code bits to zero\n         IPM   R01                  Get current program mask\n         SLR   R02,R02              Clear for condition code insertion\n         ICM   R02,B'1000',TraceCC  Get \"traced\" condition code\n         SLL   R02,4                Shift condition code to bits 2-3\n         OR    R01,R02              OR condition code with program mask\n         SPM   R01                  Restore \"trace\" condition code\n         SPACE\n         LM    R00,R09,TraceGPRs    Reload traced program's GPRs\n         LM    R11,R15,TraceGPRs+4*11 ... except R10\n         LAM   AR00,AR15,TraceARs   Reload traced program's access regs\n         L     R10,(TraceGPRs-Tr390$WS)+4*10(R10,0) Reload traced R10\n         SPACE\n         BAKR  0,0                  Form the stack state entry\n         SPACE\n*---------------------------------------------------------------------*\n*        Traced PR instruction's always return to here                *\n*---------------------------------------------------------------------*\n         SPACE\nZap3BRC  J     Exec320              Jump for PR after TRACE terminated\n         SPACE\n*---------------------------------------------------------------------*\n*        Restore environment after BAKR or PR (with trace active)     *\n*---------------------------------------------------------------------*\n         SPACE\n         SLR   R00,R00              Ensure AR15 contains zero\n         SAR   AR15,R00             ...\n         PUSH  USING\n         DROP  R10\n         BASR  R15,0                Temp addressibility for LM\n         USING *,R15                ...\n         LM    R03,R13,SaveRegs+4*3 Restore our registers\n         LAM   R00,R14,HexZeros     Clear all access registers\n         POP   USING\n         OI    Zap3BRC+1,X'F0'      Re-activate JUMP in case TRACE390  -\n                                    ... is terminated for any reason\n         CLI   XCell+1,$PR          Q. Is this a PR instruction?\n         JE    Exec310              Y. Go do PR cleanup logic\n         CLI   XCell+3,X'0F'        N. Q. Was it 'BAKR 0,15'?\n         BNE   BP930                   N. Go complete BAKR processing\n         B     BP350                   Y. Go check for module ID string\n         SPACE\n*---------------------------------------------------------------------*\n*        Cleanup after executing a PR instruction (trace ACTIVE)      *\n*---------------------------------------------------------------------*\n         SPACE\nExec310  DS    0H\n         IAC   R02                  Save unstacked ASC mode\n         STCM  R02,B'0010',TraceASC ...\n         NI    TraceASC,X'03'       ... and mask out any garbage\n         L     R15,StackPtr         Load current local stack pointer\n         LA    R14,BAKR_Stack       Point to start of local BAKR stack\n         BCTR  R15,0                Offset to last used entry\n         ST    R15,StackPtr         ... and update\n         SLL   R15,3                Multiply by 8 (stack entry length)\n         L     R00,0(R15,R14)       Get PR return address\n         B     BP950                Finish up as a successful branch\n         SPACE\n*---------------------------------------------------------------------*\n*        Restore environment after PR (trace NO LONGER ACTIVE)        *\n*---------------------------------------------------------------------*\n         SPACE\n         PUSH  USING\n         DROP  R10\nExec320  DS    0H\n         BAKR  0,0                  Save state after (non-traced) PR\nZap3BRC2 BRC   0,Exec330            Branch NOP'ed by defaulted\n         SLR   R15,R15              Ensure AR15 is zero\n         SAR   AR15,R15             ...\n         BASR  R15,0                Temp addressibility to this code\n         USING *,R15                ...\n         STM   R00,R14,TraceGPRs    Save (most of) callers general\n         STAM  R00,R14,TraceARs     ... and access registers\n         IAC   R02                  Save unstacked ASC mode\n         STCM  R02,B'0010',TraceASC ...\n         NI    TraceASC,X'03'       ... and mask out any garbage\n         LAM   R00,R14,HexZeros     Clear all access registers\n         LM    R07,R13,SaveRegs+4*7 Restore our base registers\n         POP   USING\n         SPACE\n         OI    Zap3BRC2+1,X'F0'     Alter JNOP to J\n*+++     B     R00                  Flush old Zap3BRC2 from pipline\n         SPACE\n         EREG  R15,R15              Reload R15/AR15 from untraced PR\n         ST    R15,TraceGPRs+4*15   ... and save for resume processing\n         STAM  AR15,AR15,TraceARs+4*14 ...\n         L     R15,StackPtr         Load current local stack pointer\n         LA    R14,BAKR_Stack       Point to start of local BAKR stack\n         BCTR  R15,0                Offset to last used entry\n         ST    R15,StackPtr         ... and update\n         SLL   R15,3                Multiply by 8 (stack entry length)\n         L     R11,0(R15,R14)       Get PR return address\n         STCM  R11,B'1000',TraceAMODE Update addressing mode\n         NI    TraceAMODE,X'80'      ...\n         ST    R11,SaveRegs+4*11    Save resume address\n         PR    ,                    Remove stack entry created by us\n         PUSH  USING\n         DROP  R10\n         SPACE\nExec330  DS    0H\n         BASR  R15,0                Temp addressibility to this code\n         USING *,R15\n         SLR   R00,R00              Zero AR15\n         SAR   AR15,R00             ...\n         LM    R07,R13,SaveRegs+4*7 Restore our registers\n         LAM   R00,R14,HexZeros     Zero all access registers\n         POP   USING\n         NI    Zap3BRC2+1,X'0F'     Reset J back to JNOP\n         B     End910               Get out of Dodge (err, TRACE390)\n         EJECT\n***********************************************************************\n*                                                                     *\n*        Trace terminated, restore and return to the traced program   *\n*                                                                     *\n***********************************************************************\n         SPACE\nRet999   DS    0H\n         LM    R00,R09,TraceGPRs    Reload traced program's GPRs\n         LM    R11,R15,TraceGPRs+4*11 ... except R10\n         LAM   AR00,AR15,TraceARs   Reload traced program's access regs\n         L     R10,(TraceGPRs-Tr390$WS)+4*10(R10,0) Reload traced R10\nZap4BC   B     0(0,0)               Index/Offset zapped in before use\n         EJECT\n*---------------------------------------------------------------------*\n*        HexZeros is a constant, it is placed in working storage as   *\n*        it is the only constant required within the ExecuteN logic   *\n*        and placing it here means we do not need a base to TRACE390  *\n*---------------------------------------------------------------------*\n         SPACE\nHexZeros DC    16F'0'               Constant binary zeros\n         SPACE\nParmList DS    0XL28                Program parameter list\nAddrFlgs DC    A(0)                  - Address of status flags\nPrRngTbl DC    A(0)                  - Address of print range table\nBrkPtTbl DC    A(0)                  - Address of break point table\nWatchTbl DC    A(0)                  - Address of watch point table\nEProfTbl DC    A(0)                  - Execution profile table address\nInstrTbl DC    A(0)                  - Instruction count table address\naUserDDN DC    A(0)                  - Address of user supplied ddname\n         SPACE\nTraceAMODE  DC    A(0)              Current AMODE of traced program\nOldAMODE    DC    A(0)              AMODE at start of instruction\naEX_Target  DC    A(0)              Address of EXECUTE'd instruction\n            SPACE\nASM2DLI     DC    A(0)              Address of ASMTDLI\nAIB2DLI     DC    A(0)              Address of AIBTDLI\nStoreAddr   DC    A(0)              Address causing a storage exception\nInstrPointer DC   A(0)              AMODE/instruction ptr (for exits)\n            SPACE\nXCell       DC    XL8'00'           A copy of the instruction          -\n                                    ... currently being traced\n            SPACE\nTraceGPRs   DC    16F'0'            Traced programs general registers\nTraceARs    DC    16F'0'            Traced programs access registers\n            SPACE\nSaveRegs    DC    16F'0'            Save registers here while          -\n                                    ... calling the execute routine\n            SPACE\nOldRegs     DC    16F'0'            Copy register table here before    -\n                                    ... executing the instruction\n            SPACE\nBranchTgt   DC    A(0)              New value for the instruction      -\n                                    ... pointer after a successful     -\n                                    ... branch instruction\n            SPACE\nUsrFlags    DS    0BL4              User supplied status flags\nUsrFlag1    DC    BL1'00000000'      - 1st user status flag byte\nUsrFlag2    DC    BL1'00000000'      - 2nd user status flag byte\nUsrFlag3    DC    BL1'00000000'      - 3rd user status flag byte\nUsrFlag4    DC    BL1'00000000'      - 4th user status flag byte\n            SPACE\nbAttributes DS    0BL4              Attribute flags of instruction\nbAttribute1 DC    BL1'00000000'      - 1st byte of attribute flags\nbAttribute2 DC    BL1'00000000'      - 2nd byte of attribute flags\nbAttribute3 DC    BL1'00000000'      - 3rd byte of attribute flags\nbAttribute4 DC    BL1'00000000'      - 4th byte of attribute flags\n            SPACE\nTraceCC     DC    X'00'             Traced program's condition code\nTraceASC    DC    X'00'             Traced program's ASC mode\n            SPACE\nTrcFlag1    DC    BL1'00000000'     Internal status flag byte 1\nTrc$NoDD    EQU   X'80'              - Output ddname not found\nTrc$Branch  EQU   X'40'              - PSW updated for branch\nTrc$EndT    EQU   X'20'              - End trace at mainline\nTrc$ModCall EQU   X'10'              - Module call id present\nTrc$SPIN    EQU   X'08'              - Spin off output ds before open\nTrc$Exit    EQU   X'04'              - User exit is active\nTrc$SPEX    EQU   X'02'              - Spin off output on exit\nTrc$PICT    EQU   X'01'              - Print instruction count table\n            SPACE\nTrcFlag2    DC    BL1'00000000'     Internal status flag byte 2\nTrc$PEPT    EQU   X'80'              - Print execution profile table\nTrc$NoIH    EQU   X'40'              - Do not print instruction headers\nTrc$NALC    EQU   X'20'              - Output dataset is pre-allocated\nTrc$ECLS    EQU   X'10'              - ESTAEX attempting dataset CLOSE\nTrc$EPUT    EQU   X'08'              - ESTAEX attempting final PUT\nTrc$A2DL    EQU   X'04'              - LOAD for ASMTDLI has been issued\n            SPACE\nLINE#       DC    PL2'0'            Line count within page\nPAGE#       DC    PL4'0'            Page number\nIRCOUNT     DC    PL8'0'            Instruction count (reset each run)\nITCOUNT     DC    PL8'0'            Instruction count (cumulative)\nLastCCOp    DC    CL6' '            Mnemonic of last condition code    -\n                                    ... altering instruction\nDSNSEQ#     DC    X'00'             Generated DSN sequence number\n            SPACE\nZEROFSET    DC    F'0'              Offset of range within table\nZERO1RST    DC    A(0)              Address of first address in range\nZEROLAST    DC    A(0)              Address of last address in range\n            SPACE\n            DS    0D\nPageTime    DC    CL16' '           System time (HH:MM:SS.thmiju)\nPageDate    DC    CL10' '           System date (in format YYYY/MM/DD)\n            SPACE\nStackPtr    DC    F'0'              Offset into BAKR_Stack of next     -\n                                    ... available stack entry\nBAKR_Stack  DC    32D'0'            BAKR/PR branch and return address  -\n                                    ... simulation stack\n            SPACE\nFPR0        DS    D                 Work area used by DumpFPRs\nFPR2        DS    D                 ...\nFPR4        DS    D                 ...\nFPR6        DS    D                 ...\n            SPACE\nWorkCL32    DS    XL32              Data on last line printed by DumpVS\n            SPACE\n            DS    0D\nWorkCL16    DS    0CL16             Operand value formatting area\nBDTEMP      DC    F'0'              BDproc temp storage\nBDTEMP2     DC    F'0'              ...\nExecReg     DC    XL8'00'           Registers used markers\n            SPACE\nWorkPL8     DC    PL8'0'            Packed decimal work area\nWorkDblW    DS    0D                General doubleword work area\nWorkCL5     DS    0CL5\nWorkCL9     DC    CL9' '\n            SPACE 2\nSTAEMSG1    DC    CL133' '\n         ORG   STAEMSG1\n         DC    C'0* * * * * Data set closed by ESTAEX, abending PSW: '\nSTAEPSW  DC    C'XXXXXXXX XXXXXXXX * * * * *'\n         ORG   ,\n         SPACE 2\nSTAEMSG2 DC    CL133' '\n         ORG   STAEMSG2\n         DC    C'0* * * * * Data set closed by ESTAEX, abended while tr-\n               acing instruction at address: '\nSTAEaddr DC    C'XXXXXXXX * * * * *'\n         ORG   ,\n         SPACE 2\n         PRINT NOGEN\ndcbTRACE DCB   MACRF=PM,LRECL=133,BLKSIZE=0,DDNAME=SYSTRACE,           X\n               DSORG=PS,RECFM=FBA,BUFNO=16,DCBE=dcbETRACE\n         SPACE\ndcbeTRACE DCBE RMODE31=BUFF\n         PRINT GEN\n         TITLE 'Dynamic Allocation Parameters'\n***********************************************************************\n*                                                                     *\n*        Parameter lists, request block and text units for dynamic    *\n*        allocation and deallocation                                  *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nS99PARM  DS    0F                   Pointer to request block\n         DC    A(SVC99RB+Bit0)\n         SPACE\nSVC99RB  DS    0F                   SVC 99 request block\n         DS    XL(lenS99RB)\n         SPACE\n*---------------------------------------------------------------------*\n*        DYNALLOC text units for testing for sysout dataset           *\n*---------------------------------------------------------------------*\n         SPACE\nplTestAlloc DS 0F                   Text pointer for allocation test\n         DC    A(tuDDname)\n         DC    A(tuTestSYSOUT+Bit0)\n         SPACE 2\ntuDDname DS    0F\n         DC    AL2(DINDDNAM)        Indicate ddname specification\n         DC    H'1'                 Number of parameters\n         DC    AL2(L'DDname)        Length of parameter\nDDname   DC    CL8'SYSTRACE'        Actual DD name of output dataset\n         SPACE\ntuTestSYSOUT DS 0F                  Test for a SYSOUT data set\n         DC    AL2(DINRTTYP)        Return dataset type specification\n         DC    H'1'                 Number of parameters\n         DC    AL2(L'TESTPARM)      Length of parameter\nTESTPARM DC    X'00'\n         SPACE\n*---------------------------------------------------------------------*\n*        DYNALLOC text units for dataset de-allocation                *\n*---------------------------------------------------------------------*\n         SPACE\nplDeallocate DS 0F                  Deallocate output dataset\n         DC    A(tuDDname)\n         DC    A(tuDeallocate+Bit0)\n         SPACE 2\ntuDeallocate DS 0F\n         DC    AL2(DUNUNALC)        Deallocation request\n         DC    H'0'                 Parameter count\n         SPACE\n*---------------------------------------------------------------------*\n*        DYNALLOC text units for dataset allocation                   *\n*---------------------------------------------------------------------*\n         SPACE\nplAllocate DS    0F                 Allocate output dataset\n         DC    A(tuDDname)\n         DC    A(tuAllocate+Bit0)\n         SPACE 2\ntuAllocate DS  0F\n         DC    AL2(DALSYSOU)        Indicate sysout dataset\n         DC    H'0'                 Zero parameters to specify default\n         EJECT\nplDSN_Allocate DS 0F                Text pointers for DSN allocation\n         DC    A(tuAllocDD)          - DDNAME\n         DC    A(tuAllocDSN)         - DSN Allocation\n         DC    A(tuStatus)           - Dataset status\n         DC    A(tuNormalDisp)       - Normal disposition\n         DC    A(tuCondDisp)         - Conditional disposition\n         DC    A(tuTrackAlloc)       - Allocate in tracks\n         DC    A(tuPrimeSpace)       - Allocation primary quantity\n         DC    A(tu2ndySpace)        - Allocation secondary quantity\n         DC    A(tuRelease)          - Release unused space on close\n         DC    A(tuUnits)            - Unit type to allocate on\n         DC    A(tuClose)            - Deallocate on close\n         DC    A(tuLRECL)            - Logical record length\n         DC    A(tuRECFM+Bit0)       - Record format\n         SPACE 2\ntuAllocDD DS   0F                   DDNAME of dataset\n         DC    AL2(DALDDNAM)\n         DC    H'1'\n         DC    AL2(L'tu$DDNAM)\ntu$DDNAM DC    CL8' '\n         SPACE\ntuAllocDSN DS  0F                   Dataset name text unit\n         DC    AL2(DALDSNAM)\n         DC    H'1'\ntu$DSNL  DC    AL2(L'tu$DSN)\ntu$DSN   DC    CL44'TESTXXX.T390.ASNAME.D99001.T010101'\n         SPACE\ntuStatus DS    0F                   Dataset status\n         DC    AL2(DALSTATS)\n         DC    H'1'\n         DC    AL2(L'tu$STATS)\ntu$STATS DC    X'02'                - MOD\n         SPACE\ntuNormalDisp DS 0F                  Dataset normal disposition\n         DC    AL2(DALNDISP)\n         DC    H'1'\n         DC    AL2(L'tu$NDISP)\ntu$NDISP DC    X'02'                - CATLG\n         SPACE\ntuCondDisp DS  0F                   Dataset conditional disposition\n         DC    AL2(DALCDISP)\n         DC    H'1'\n         DC    AL2(L'tu$CDISP)\ntu$CDISP DC    X'02'                - CATLG\n         SPACE\ntuTrackAlloc DS 0F                  Dataset space allocation\n         DC    AL2(DALTRK)          - Tracks\n         DC    H'0'\n         SPACE\ntuPrimeSpace DS 0F                  Dataset primary space allocation\n         DC    AL2(DALPRIME)\n         DC    H'1'\n         DC    AL2(L'tu$PRIME)\ntu$PRIME DC    AL3(30)              - 30 tracks\n         SPACE\ntu2ndySpace DS 0F                   Dataset secondary space allocation\n         DC    AL2(DALSECND)\n         DC    H'1'\n         DC    AL2(L'tu$SEC)\ntu$SEC   DC    AL3(30)              - 30 tracks\n         SPACE\ntuRelease DS   0F                   Release unused space\n         DC    AL2(DALRLSE)\n         DC    H'0'\n         SPACE\ntuUnits  DS    0F                   Unit specification\n         DC    AL2(DALUNIT)\n         DC    H'1'\n         DC    AL2(L'tu$UNIT)\ntu$UNIT  DC    CL5'SYSDA'           - Disk\n         SPACE\ntuClose  DS    0F                   Deallocate file when closed\n         DC    AL2(DALCLOSE)\n         DC    H'0'\n         SPACE\ntuLRECL  DS    0F                   Logical record length\n         DC    AL2(DALLRECL)\n         DC    H'1'\n         DC    AL2(L'tu$LRECL)\ntu$LRECL DC    H'133'               - Standard SYSOUT print records\n         SPACE\ntuRECFM  DS    0F                   Record Format\n         DC    AL2(DALRECFM)\n         DC    H'1'\n         DC    AL2(L'tu$RECFM)\ntu$RECFM DC    X'94'               - Fixed, Blocked, ANSI\n         TITLE 'WTO Messages for Fatal Conditions'\n         PUSH  PRINT\n         PRINT NOGEN\n*                0----+----1----+----2----+----3----+----4----+----5---\n*              -+----6----+----7----+----8----+----9----+----0\nMsg001   DC    AL2(L'cMsg001)\ncMsg001  DC    C'TRC001 Status flags invalid, bytes 3-4 are non-zero, FX\n               lags=********'\nMsg002   DC    AL2(L'cMsg002)\ncMsg002  DC    C'TRC002 Invalid *********** table entry, Start(********X\n               ) GT End(********)'\nMsg003   DC    AL2(L'cMsg003)\ncMsg003  DC    C'TRC003 User supplied DDNAME \"********\" is invalid'\nMsg004   DC    AL2(L'cMsg004)\ncMsg004  DC    C'TRC004 End of ParmList not found at seventh parameter'\nMsg005   DC    AL2(L'cMsg005)\ncMsg005  DC    C'TRC005 DYNALLOC error, Verb=**, RC=**, Error=****, InfX\n               o=****, DDNAME=********'\nMsg006   DC    AL2(L'cMsg006)\ncMsg006  DC    C'TRC006 Attempt to ESTAEX failed, RC=**'\nMsg007   DC    AL2(L'cMsg007)\ncMsg007  DC    C'TRC007 Dataset OPEN failed on DDNAME \"********\"'\nMsg008   DC    AL2(L'cMsg008)\ncMsg008  DC    C'TRC008 DDNAME \"********\" not found in task I/O table, X\n               tracing is disabled'\nMsg009   DC    AL2(L'cMsg009)\ncMsg009  DC    C'TRC009 Unable to return to traced program, no valid baX\n               se register'\nMsg010   DC    AL2(L'cMsg010)\ncMsg010  DC    C'TRC010 Profiler sub-interval of ******** is invalid'\nMsg011   DC    AL2(L'cMsg011)\ncMsg011  DC    C'TRC011 Zero table address is invalid in *********** enX\n               try'\nMsg012   DC    AL2(L'cMsg012)\ncMsg012  DC    C'TRC012 Bit zero set in *********** address (********)'\nMsg013   DC    AL2(L'cMsg013)\ncMsg013  DC    C'TRC013 *********** entry at address ******** has an exX\n               it EPA of zero'\n         SPACE\ncplOPEN  DS    0D                   Control parameter list for SYSTRACE\ncplCLOSE DC    D'0'                 ... OPEN and CLOSE\n         SPACE\ncplWTO   WTO   TEXT=,ROUTCDE=(11),DESC=(7),MF=L\n         SPACE\ncplTIME  TIME  LINKAGE=SYSTEM,MF=L\n         SPACE\ncplESTAEX ESTAEX RECOVER,PARAM=aBASE,                                  X\n               XCTL=NO,PURGE=NONE,ASYNCH=YES,TERM=YES,MF=L\n         TITLE 'Program Working Storage (local to each routine)'\n***********************************************************************\n*                                                                     *\n*        Temporary storage used by the various routines               *\n*                                                                     *\n***********************************************************************\n         SPACE\n*---------------------------------------------------------------------*\n*        Sub-routine return address save-areas                        *\n*---------------------------------------------------------------------*\n         SPACE\nPSSAV    DS    A                    PrintSup\nPHSAV    DS    A                    PRINTHDR\nPFSAV    DS    A                    PROFILER\nPCSAV    DS    A                    PRINTCNT\nPLSAV    DS    A                    PutLine\nP1SAV    DS    A                    PLINE1\nPOSAV    DS    A                    PrOpCode\nBDSAV    DS    A                    BDproc\nPRSAV    DS    A                    PrintRegs\nPESAV    DS    A                    PrintEFA\nBRSAV    DS    A                    BrProc\nRPSAV    DS    A                    RPUT\nSPSAV    DS    A                    SpinOff\nGDSAV    DS    A                    GENDSN\nWRSAV    DS    A                    WRITE\nTSSAV    DS    A                    TimeStamp\n         SPACE\nPUTRSAVE DS    18F                  Save area used by PUTR\n         SPACE\n#Cells   DS    F                    Number of cells left to process\n         SPACE\nPSXCell  DS    XL8                  Copy of the subject instruction\nPSFLAGS  DS    BL4                  Attribute flags of the above instr.\nSAVELINE DS    CL133                Save PLINE here while title printed\n         EJECT\n*---------------------------------------------------------------------*\n*            The print output line                                    *\n*---------------------------------------------------------------------*\n             SPACE\nPLINE        DC    CL133' '\n            ORG *-(L'PageDate+1+L'PageTime+3+L'PrL$PAGE+1+L'PrL$PageNo)\nPrL$DATE     DS    CL(L'PageDate)   YYYY/MM/DD\n             DS    C\nPrL$TIME     DS    CL(L'PageTime)   HH:MM:SS.thmiju\n             DS    CL3\nPrL$PAGE     DS    CL4              C'PAGE'\n             DS    C\nPrL$PageNo   DS    ZL6              Page Number\n             SPACE 2\n             ORG   PLINE\nPrL$CCB      DS    C                Carriage control byte\nPrL$Data     DS    0CL132           Print line data\nPrL$ILC      DS    CL8              Instruction pointer (PSW address)\n             DS    C\nPrL$ASC      DS    C                Address Space Control mode\n             DS    C\nPrL$ObjCode  DS    CL12             Instruction image\n             DS    C\nPrL$CondCode DS    C                Condition code\n             DS    C\nPrL$BranchDir DS   CL2              Branch direction\n             DS    C\nPrL$Mnemonic DS CL6                 Symbolic instruction code\n             DS    C\nPrL$Operands DS CL20                Instruction operand fields\n             DS    C\nPrL$Reg1     DS    CL8              First operand register\n             DS    C\nPrL$Reg2     DS    CL8              Second operand register\n             DS    CL2\nPrL$Address1 DS    CL8              1st operand effective address\n             DS    CL2\nPrL$Data1    DS    CL8              First operand data\n             DS    C\nPrL$Double1  DS    CL8              2nd half of doubleword at Address1\n             DS    CL2\nPrL$Address2 DS    CL8              Second operand effective address\n             DS    CL2\nPrL$Data2    DS    CL8              Second operand data\n             DS    C\nPrL$Double2  DS    CL8              2nd half of doubleword at Address2\n             SPACE 2\n             ORG   PrL$Reg2\nPrL$DR1      DS    CL8              2nd half of 1st double register\n             DS    CL2\nPrL$DR2A     DS    CL8              2nd double register\n             DS    CL2\nPrL$DR2B     DS    CL8              2nd half of 2nd double register\n             SPACE 2\n             ORG   PrL$Address1\nPrL$ModuleID DS    CL(L'PLINE-1-(PrL$Address1-PLINE)) Module id\n             ORG   PrL$Reg1\nPrL$SVC      DS    CL(L'PLINE-1-(PrL$Reg1-PLINE))     SVC Mnemonic\n             ORG   PrL$Address2\n***                                 Executed SVC Mnemonic\nPrL$ESVC     DS    CL(L'PLINE-1-(PrL$Address2-PLINE))\n             SPACE 2\n             ORG   PrL$Data\n             DS    C\nPrD$Offset   DS    CL6              Offset from start of dump data\n             DS    CL3\nPrD$Address  DS    CL8              Virtual address\n             DS    CL2\nPrD$HexData  DS    8CL9             Data in display hex format\n             DS    CL2\nPrD$EBCDIC   DS    CL32             Data in EBCDIC format\n             ORG   ,\n             SPACE\nIDstring     DC    CL(L'PrL$ModuleID)' ' Module id string\n         SPACE 3\n         END   TRACE390\n         PUNCH ' PAGE TRACE390'\n         PUNCH ' SETOPT PARM(REUS=SERIAL,CALL)'\n         PUNCH ' NAME TRACE390(R)'\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TRCFLAGS": {"ttr": 4100, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x04\\x00\\x00\\x00\\x99$_\\x00\\x99'\\x9f\\x16U\\x00\\x14\\x00\\x14\\x00\\x00\\xd9\\xd5\\xc7\\xc1\\xd5@@@@@\"", "ispf": {"version": "01.04", "flags": 0, "createdate": "1999-09-02T00:00:00", "modifydate": "1999-10-06T16:55:00", "lines": 20, "newlines": 20, "modlines": 0, "user": "RNGAN"}, "text": "         MACRO ,\n         TRCFLAGS ,\nFlg$PrHdr     EQU   X'80'     Print page headers\nFlg$Print     EQU   X'40'     Print executed instructions\nFlg$PrCurInst EQU   X'20'     Print current instruction\nFlg$TrDLI     EQU   X'10'     Trace DL/I logic\nFlg$PrBAL     EQU   X'08'     Print BAL/BAS/BALR/BASR/BASSM\nFlg$PrRet     EQU   X'04'     Print BR/BSM (return type branches)\nFlg$Spin      EQU   X'02'     Spin off output dataset\nFlg$Call      EQU   X'01'     Print called module and SVC info\n              SPACE\nFlg$PICT      EQU   X'80'     Print instruction count table\nFlg$NCFP      EQU   X'40'     Don't count FP instructions\nFlg$PEPT      EQU   X'20'     Print execution profile table\nFlg$NPNE      EQU   X'10'     Don't print instructions not executed\nFlg$NALC      EQU   X'08'     Suppress dynamic allocation\nFlg$GDSN      EQU   X'04'     Generate DYNALLOC dataset name\nFlg$NoPrEMC   EQU   X'02'     Don't print branch \"Extended Menomics\"\n*             EQU   X'01'     Reserved\n              MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TRCTBLS": {"ttr": 4102, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x99$_\\x00\\x99(\\x8f\\x14S\\x00#\\x00\"\\x00\\x00\\xd9\\xd5\\xc7\\xc1\\xd5@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1999-09-02T00:00:00", "modifydate": "1999-10-15T14:53:00", "lines": 35, "newlines": 34, "modlines": 0, "user": "RNGAN"}, "text": "         MACRO ,\n         TRCTBLS ,\nPrtEntry DSECT ,\nPrtStart DS    A            Print range start address\nPrtEnd   DS    A            Print range end address\nPrt$ELEN EQU   *-PrtEntry   Entry length\n         SPACE 2\nBptEntry DSECT ,\nBptAddr  DS    A            Break point address\nBptExit  DS    A            Break point exit EPA\nBpt$ELEN EQU   *-BPTEntry   Entry length\n         SPACE 2\nWptEntry DSECT ,\nWptStart DS    A            Watch point start address\nWptEnd   DS    A            Watch point end address\nWptALET  DS    F            ALET for watchpoint range\nWptExit  DS    A            Watch point exit EPA\nWpt$ELEN EQU   *-WPTEntry   Entry length\n         SPACE 2\nPrfEntry DSECT ,\nPrfTable DS    A            Address of profile data table\nPrfIntvl DS    A            Profile range sub-interval\nPrfStart DS    A            Start of profile range\nPrfEnd   DS    A            End of profile range\nPrfIdent DS    CL8          Profile range identifier\nPrf$ELEN EQU   *-PrfEntry   Entry length\n         SPACE 2\nIn#Entry DSECT ,\nIn#Table DS    A            Address of instruction count data table\nIn#Start DS    A            Start of instruction count range\nIn#End   DS    A            End of instruction count range\nIn#Ident DS    CL8          Instruction count table identifier\nIn#$ELEN EQU   *-In#Entry   Entry length\n         SPACE 2\n         MEND  ,\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT391/FILE391.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT391", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}