{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220011442000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 3468374, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 13, "INMDSNAM": "CBT.V500.FILE185.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 3468374, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 3468374, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE185.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x006\\n'", "DS1TRBAL": "b'\\x04\\xa6'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x01o\\x00\\x0b\\x01s\\x00\\x05\\x007'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04c\\x00H\\x01 \\x08\\x7f\\x01 \\x08\\x7f\\x14\\x05\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf9\\xf9@@@'", "ispf": {"version": "04.99", "flags": 0, "createdate": "2020-03-27T00:00:00", "modifydate": "2020-03-27T14:05:48", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-499"}, "text": "REGULAR CBT TAPE - VERSION 499    FILE:  185\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT499.FILE185\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 42 MEMBERS COUNTED; CUMULATIVE SIZE IS 32,444 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   03/27/20    14:05:48    UTC-4:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$CAUTON": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x006\\x01\\t\\x06O\\x01\\t\\x06O\\x10\\x16\\x00-\\x00+\\x00\\x00```````@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2009-03-05T00:00:00", "modifydate": "2009-03-05T10:16:36", "lines": 45, "newlines": 43, "modlines": 0, "user": "-------"}, "text": "CAUTION CAUTION CAUTION  -  when using the ASUB or LSLT program\n                            to fill in the last slot of one of the\n                            \"common storage\" TSO AUTH tables.\n\nTSUB is SAFER than ASUB to use for FILLING IN THE LAST SLOT of a table.\n-----------------------                           ---------\n\n When in doubt, use TSUB instead of ASUB.  There is no potential\n using TSUB, to ruin subsequent LOGONs of TSO users.  Sometimes\n filling in the last blank entry of a \"common storage\" table with\n the ASUB or LSLT programs, will ruin subsequent LOGONS of TSO\n users.  (This has to be tested in each case.  It depends on WHAT\n IS IN THE STORAGE THAT IS JUST AFTER the given TSO auth table.)\n\nExplanation:    (see bottom for a SOLUTION)\n\n It all depends what is after the table, in storage.\n\n A blank entry, at the end of any TSO Auth Table, will ALWAYS delimit\n the table.  Auth tables which have LENGTHS associated with them, are\n sometimes delimited by the lengths, but according to a few of the\n programs which read these tables, the table is ONLY DELIMITED BY A\n BLANK ENTRY AT THE END.  Therefore, the program reading the table\n might run into the data past the end of the table, if there is no\n blank entry at the end.\n\n I have noticed that, depending on what follows the table in storage,\n if the last blank entry of a table has been filled by ASUB or LSLT,\n then SUBSEQUENT TSO LOGONS MAY ABEND in allocation of the DD names\n that the session will require.  Therefore, don't use ASUB or LSLT to\n fill in the last blank entry in a table, unless it is absolutely\n necessary for getting the job done.  Use the LOOK program from CBT\n File 264, to see what is in storage just after the table.  If LOOK\n produces an ABEND on your system, use the UKEYCSA program to allow\n LOOK to work.\n\nSOLUTION :  -------\n\n In a pinch, if this problem occurs, the solution is to run a\n PARMLIB UPDATE(xx) to replace the public tables, or a SET IKJTSO=xx\n operator command to accomplish the same thing.  These commands\n ALWAYS produce new tables having a blank entry at the end.\n\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$NOTE1": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x05\\x00'\\x01\\x041\\x9f\\x01\\x07\\x19/\\x10\\x03\\x00\\x12\\x00\\x12\\x00\\x00```````@@@\"", "ispf": {"version": "01.05", "flags": 0, "createdate": "2004-11-14T00:00:00", "modifydate": "2007-07-11T10:03:27", "lines": 18, "newlines": 18, "modlines": 0, "user": "-------"}, "text": "            V E R Y    I M P O R T A N T    N O T E\n\n>>>   Note so you DO NOT LOSE AUTHORIZATION of any program by  <<<\n>>>   doing this procedure:                                    <<<\n\nPlease note that when module IKJTABLS resides in an APF authorized\nSTEPLIB DD in your TSO LOGON PROC, IT COMPLETELY OVERRIDES the tables\nin IKJTSOxx in PARMLIB.  Therefore, in order that you should not lose\nany authorizations of programs, please look in your own IKJTSOxx\nPARMLIB member which is active, and copy all entries which we have\nnot copied.  Perhaps you have more authorized vendor programs\ninstalled, than we have.\n\nAGAIN, NOTE:  COPY OR ZAP IN ALL PROGRAM NAMES (INTO THE APPROPRIATE\n       TABLES) WHICH YOU HAVE IN YOUR IKJTSOxx, AND WHICH WE DON'T\n       HAVE IN OUR SAMPLE TABLES .......\n\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$$NOTE2": {"ttr": 522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x008\\x01\\x13\\x11\\x1f\\x01\\x13\\x11\\x1f\\x11\\x00\\x00/\\x00/\\x00\\x00```````@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2013-04-21T00:00:00", "modifydate": "2013-04-21T11:00:38", "lines": 47, "newlines": 47, "modlines": 0, "user": "-------"}, "text": "Subject:  Easier Disasembly of IKJTABLS with free tools\nFrom:     Sam Golob <IBMUSER@cbttape.org>\nDate:     4/21/2013 10:30 AM\n\n   This refers to member FILE234I in this pds, which is a\n   self-contained package to create a disassembly of the IKJTABLS\n   load module using only free tools.\n\n   Here is a pds which will help you disassemble IKJTABLS with\n   free tools, and which will greatly assist you in making an\n   assembly job for your own load module IKJTABLS.  The File 234\n   disassembler is already installed in the XMIT-ed load library\n   that is member LOADLIB in the FILE234I pds.  See the member\n   $$$$READ in the FILE234I pds, for detailed instructions.\n\n   Once everything is set up, you will only have to run one job,\n   called DISAJC01, to create the assembly JCL.  The output of\n   this job is four disassembled source members of a pds, the\n   OUTPUTS pds, with assembly JCL at the top (included as OUTPUTS\n   pds member ASM) and linkedit JCL at the bottom (as OUTPUTS pds\n   member LINK).  Just put all 6 members together in order, and\n   you have the job to assemble and link your own IKJTABLS.  In\n   my example installation, I called the combined JCL as member\n   WHOLEJOB.  You, of course, will create your own combined JCL\n   member in the OUTPUTS pds.\n\n   I hope that this will help you set up any reassemblies for\n   IKJTABLS that you will need in the future.\n\n   There was one problem that I had.  The disassembly of table\n   IKJEFTNS did not show the X'FFFF' that marks the end of that\n   table.  Practically speaking, this will not cause a problem,\n   because the table is already delimited by more than one blank\n   entries, and you don't really need the X'FFFF' to delimit that\n   table, unless all the other entries were already filled and\n   none of them were blank.  A blank entry will always delimit\n   any one of these tables.\n\n   You can always write in a DC  X'FFFF' line at the end of the\n   IKJEFTNS assembly, by hand.\n\n   Please let me know how this method worked for you.\n\n   All the best of everything to you and your family.\n\nSincerely,   Sam\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$EXPLAIN": {"ttr": 524, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00$\\x00\\x925\\x7f\\x01\\t\\x02\\x9f\\x13H\\x00g\\x00A\\x00\\x00```````@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "1992-12-22T00:00:00", "modifydate": "2009-01-29T13:48:24", "lines": 103, "newlines": 65, "modlines": 0, "user": "-------"}, "text": "                 A SHORT EXPLANATION OF THIS FILE\n\n* * I M P O R T A N T * * I M P O R T A N T * * I M P O R T A N T * *\n    -----------------     -----------------     -----------------\nTHE SUBMITTER OF THIS MATERIAL ASSUMES NO RESPONSIBILITY FOR ANY\nDAMAGE OR ANY HARM WHATSOEVER, RESULTING FROM THE USE OF THIS MATERIAL,\nOR FROM THE USE OF ANY OTHER MATERIAL ON THIS TAPE.  THIS MATERIAL WAS\nCONTRIBUTED SO IT CAN POTENTIALLY BENEFIT AN INSTALLATION THROUGH THE\nENHANCED ABILITY OF ITS SUPPORT PERSONNEL TO DO THEIR REQUIRED JOBS,\nAS DETERMINED BY THEIR EMPLOYERS.\n    -------------------------------------------------------------\n* * I M P O R T A N T * * I M P O R T A N T * * I M P O R T A N T * *\n\nNote.  More information on this subject is now available.\n       See member @ARTICLE in this pds (File 185).\n       See also, the entire File 797.  Powerful new tools are there.\n\nThis source file (185) and the LOADLIB member (in TSO XMIT format)\nwhich creates a load library, enable the systems programmer to\nprivately authorize TSO commands and not give this privilege to the\nrest of the TSO users.\n\nThe trick of doing this depends on two things:\n    1 - You have access to an APF authorized STEPLIB DD in your\n         TSO Logon PROC.\n    2 - You have TSO/E Version 2 or higher (although the same idea\n         applies to all of the old releases of TSO for way back,\n         but it was implemented differently there.)\n\nThere are tables that TSO uses to determine whether an authorized\ncommand or program should be permitted to run.  These tables used to\nbe inside of module IKJEFT02, but now, IBM has separated them out into\na separate load module IKJTABLS.  The reason for that is to make these\ntables independent of which release of TSO you are running.  With\nTSO/E Version 2, there is now a parmlib member IKJTSOxx which\noverrides IKJTABLS when IKJTABLS is in LPALIB.  However, if you have a\ncopy of IKJTABLS in an APF authorized STEPLIB DD, IKJTABLS overrides\nboth the IKJTSOxx parmlib member and the copy of IKJTABLS in\nSYS1.LPALIB.  If for some reason, the APF authorization of the STEPLIB\nDD goes away, then the copy of IKJTABLS that is there, does not\noverride IKJTSOxx anymore.\n\nThus it is possible that when an APF authorized load library which\ncontains a copy of IKJTABLS is run by you, in your LOGON PROC, as a\nSTEPLIB DD in an APF authorized manner, then THAT COPY of IKJTABLS\n\"rules\" for you.  But if the exact same load library is also in the\nlinklist for everyone (even if it is APF authorized), but the other\npeople are not running it as a STEPLIB DD in their LOGON PROC, then\nIKJTSOxx \"rules\" for them.  Therefore on the exact same running system\nand at the exact same time, YOU have one set of authorized programs,\nand the OTHER PEOPLE have a completely different set.  I call this\n\"personal TSO authorization\", and it was made possible by the loophole\nbuilt into TSO, that IKJTABLS in an \"APF authorized STEPLIB DD\"\noverrides all other copies of the authorization tables in the system.\n\nThis principle also applies when running TSO-in-batch.  A STEPLIB DD\nto an APF authorized load library containing a copy of IKJTABLS, will\nallow an APF authorized TSO command to run in batch mode, according\nto the entries in that copy of the IKJTABLS load module.\n\nSo what we do, is to make a copy of IKJTABLS which contains all the\nentries in your IKJTSOxx parmlib member, plus more, plus a lot of new\nblank entries for expansion.  When we do this, your powers do not\ndecrease, but they are added to.  We put this copy of IKJTABLS into\nan APF authorized STEPLIB DD in your LOGON PROC, so it COMPLETELY\nOVERRIDES the table from IKJTSOxx that is in use by everyone else.\n\nAs shipped, IKJTABLS is rather small, and has four csects:\nIKJEFTE2, IKJEFTE8, IKJEFTNS, and IKJEFTAP.  See the \"TSO Customization\"\nmanual for detailed information on these.\n\nThe problem for us is:  The IKJTSOnn member can have many many entries,\nand it can be a big table.  IKJTABLS as shipped, only has a few slots\nfor entries.  But it can be enlarged, unlimitedly, for all practical\npurposes.\n\nSo this file is to show you how to enlarge IKJTABLS, copy all the\nIKJTSOnn entries into it, leave a zillion more slots for any other\nprograms you may desire to run authorized, and run all this privately\nand merrily from your own APF authorized STEPLIB DD.\n\nFile 185 is a source file which has disassembled source for my own\nIKJTABLS csects.  This is along with enough JCL to reassemble it.\n(I used STARTOOL FDM from Serena to create this disassembled source.\nIn fact, with STARTOOL FDM, this entire business can be done in less\nthan half an hour, and these two files are really unnecessary,\nbecause you can create the whole thing instantly with the STARTOOL\nFDM disassembler and its type-over full-screen load module zapper.)\n\nThe LOADLIB member of this pds (which is in TSO XMIT format),\nproduces my own IKJTABLS load module with its aliases, which can\nprobably be used as-is in an authorized STEPLIB on any TSO/E 2.n\n(or higher) system.\n\nAgain.  Please remember that you're the system doctor.  When you\nrun anything authorized there is always potential to put the system\nin peril.  You're there to fix stuff, not to ruin your company's\nvaluable investment in electronic data processing.  Anyway, I'd\nfeel better if you all read this cautionary statement.  Thanks.\n\n\nGood luck.  Be careful.  Thanks.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$EXPLAI2": {"ttr": 527, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x17\\x01\\t\\x06/\\x01\\t\\x06/\\t#\\x009\\x009\\x00\\x00```````@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2009-03-03T00:00:00", "modifydate": "2009-03-03T09:23:17", "lines": 57, "newlines": 57, "modlines": 0, "user": "-------"}, "text": "        Perspective in Auth Tables for TSO - ASUB or TSUB\n        ----------- -- ---- ------ --- ---   ------------\n\nWhen to use the ASUB program, and when to use the TSUB program.\n\nASUB displays/changes the PARMLIB-defined tables in common storage.\n\nTSUB displays/changes each TSO Userid's tables in the userid's private\n  storage.  Each TSO session actually uses its own private tables, so\n  to affect your own session only, use TSUB.\n\n1.  The IKJTSOxx PARMLIB member will manufacture auth tables in common\n    storage.  This is done either at IPL time, or via a PARMLIB\n    UPDATE(xx) TSO command, or via a SET IKJTSO=xx operator command.\n    These tables are:  AUTHCMD (IKJEFTE2), AUTHPGM (IKJEFTE8), AUTHTSF\n    (IKJEFTAP), NOTBKGND (IKJEFTNS), and optionally, PLATCMD and\n    PLATPGM.  The ASUB command is available to display or change\n    entries in any of these tables.  These tables can be changed after\n    IPL, using a PARMLIB UPDATE(xx) TSO command, or a SET IKJTSO=xx\n    operator command.  These tables are used GLOBALLY across the\n    entire LPAR, to manufacture the LOCAL TSO auth tables for each\n    userid at LOGON time.  Use the APF-authorized ASUB command to\n    display or change these tables or entries in them.\n\n2.  At LOGON time, each TSO userid will have its own auth tables (only\n    the first four - AUTHCMD, AUTHPGM, AUTHTSF, NOTBKGND) created in\n    Key 0, Subpool 252 storage IN ITS OWN ADDRESS SPACE.  The\n    individual TSO user's tables are created at LOGON time either from\n    the PARMLIB tables in common storage, or else from a load module\n    IKJTABLS containing the proper CSECTs (IKJEFTE2, IKJEFTE8,\n    IKJEFTAP, IKJEFTNS) if IKJTABLS is running from an APF-authorized\n    STEPLIB defined to that TSO user's LOGON PROC.  These are the\n    Local Auth Tables that the TSO session actually uses.  Use the\n    TSUB (APF-authorized) TSO command to display or change entries in\n    these tables.  The scope of the TSUB command is only for tables in\n    the issuing TSO user's session.\n\n3.  If you want to REBUILD the local TSO userid's auth tables at any\n    time, then go to CBT File 797 and use either the LLWA or LWATMGR\n    authorized TSO commands, optionally together with the LWATEDIT\n    ISPF interface for the LWATMGR command.  Since LLWA and LWATMGR\n    are authorized commands, they have to be in the AUTHCMD (E2)\n    table.  To use LWATEDIT to rebuild auth tables, LWATMGR has to\n    additionally be in the AUTHTSF (AP) table.\n\n4.  You can bootstrap all of these commands into your auth tables by\n    minimally just authorizing the TSUB command.  Since TSUB can be\n    used to change all of your session's auth table entries, once you\n    have TSUB, you can then use it to authorize everything else.\n    Also, please use the STEPLIB command (CBT File 452 and load module\n    in this file) to dynamically STEPLIB any APF-authorized load\n    library into your TSO session, that you might have available to\n    use for yourself in your installation.  This will get you access\n    to load modules for the commands you need.  The STEPLIB command\n    also has to be in the AUTHCMD (E2) table, but TSUB can be used\n    to put it there initially.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "@ARTICLE": {"ttr": 529, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Y\\x01\\t\\x00\\x7f\\x01\\t\\x00\\x7f\\x14\\x12\\x01\\x99\\x01\\x99\\x00\\x00```````@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2009-01-07T00:00:00", "modifydate": "2009-01-07T14:12:59", "lines": 409, "newlines": 409, "modlines": 0, "user": "-------"}, "text": "                    TSO AUTHORIZATION TABLES\n\n(c) Copyright 2009 by Sam Golob.  All rights reserved.\n\n     TSO sessions rely on a set of tables containing program names, when\nthey test a TSO user's ability to run an APF-authorized program, or an\nAPF-authorized TSO command, or when they test if a TSO command can be\nexecuted under TSO-in-batch.  People outside of IBM do not generally\npossess definitive information about where these tables actually are,\nalthough they have general knowledge about how to change them.  In this\narticle, I hope to put most doubts to rest, and after reading this\narticle, you should have a very good idea about your TSO session's\nauthorization tables, where they are, and how they got there.\n\n\nHISTORY OF THE AUTH TABLES\n\n     In the \"ancient\" days, before TSO/E, which many of us still\nremember, the four CSECTs:  IKJEFTE2 (AUTHCMD), IKJEFTE8 (AUTHPGM),\nIKJEFTAP (AUTHTSF - which didn't exist then), and IKJEFTNS (NOTBKGND),\nwere linkedited into the IKJEFT02 load module (mainline TSO).  So I\nlearned a trick about what you should do, if you want to expand which\nprograms you would like authorized in your own TSO session.  The trick\nwas to make your own copy of the IKJEFT02 load module, stick it in an\nAPF-authorized STEPLIB that was in your TSO LOGON PROC, and linkedit\nyour own copies of the IKJTFTE2 and IKJEFTE8 CSECTs, in particular, into\nthat copy of IKJEFT02.  This worked fine and did the job.  You had your\nown personal command and program authorizations, which the other TSO\nusers did not have.  And that is what you, as the \"system doctor\",\nneeded to have, as opposed to what the \"ordinary users\" needed.\n\n     However, there was one problem.  When normal maintenance came in\nfrom the monthly PUT tapes, and hit the other CSECTs in IKJEFT02, or\nelse if a new version of TSO came out, either your own individual copy\nof IKJEFT02 didn't get the maintenance, or else you'd have to copy it\nover again, and re-linkedit the IKJEFTE2 and IKJEFTE8 CSECTs back again.\nIf you didn't do that, the result would be that your own TSO session\nwould become backleveled, often to the point where you'd get some abends\nthat you didn't really want.\n\n     Arrive TSO/E, with one improvement (among many other non-related\nones).  The four CSECTs:  IKJEFTE2, IKJEFTE8, IKJEFTNS, and IKJEFTAP\nwere taken out of IKJEFT02 and inserted into their own load module,\nwhich was called IKJTABLS.  IKJTABLS didn't contain any executable\ncode--it just contained program list tables.  The trick for the special\nuse of your own IKJTABLS was similar to that for IKJEFT02.  If the\nIKJTABLS load module was present in an APF-authorized STEPLIB in your\nTSO session, it would override the same-named CSECTs that were in LPALIB\nor wherever (which the public would use), and you yourself could get\nyour own personal special TSO command authorization.  But this time, the\nauthorization tables, being in a completely separate load module, were\nindependent of which TSO/E release level and maintenance level you were\nrunning.  The \"auth CSECTs\" were no longer connected to \"mainline TSO\",\nand when changing them, you would not interfere with applying normal TSO\nmaintenance.  So TSO itself was now in sync with current maintenance,\nand you had your own personal \"auth tables\" too.  This was a much better\nsituation than before.\n\n     The next improvement in TSO/E came because of the push within IBM,\nspurred on by banks and other institutions which had to remain up for 24\nX 7, to eliminate IPLs.  In the late 80's and early 90's, IBM made a big\neffort to convert hard-coded tables that were created at IPL time, to\ndynamically created tables in common storage, that could be re-created\nat any time after IPL, usually via an operator command.\n\n     Around this time, the IKJTSOxx PARMLIB member was created.  It was\ngiven the capability of renewing a copy of the TSO auth tables in common\nstorage, at any time, via the PARMLIB UPDATE(xx) TSO command.  The\nadvantage of this was obvious, making it possible for installations to\nauthorize commands and programs to TSO, whenever they wanted to do so,\neven in-between IPLs.  Later on, with TSO/E Release 3 (corresponding to\nz/OS 1.3), the SET IKJTSO=xx operator command was also introduced, and\nwas given the same power and action as the PARMLIB UPDATE(xx) TSO\ncommand.  The PARMLIB UPDATE(xx) facility was created first.  I think\nthat's because IBM wanted to give this \"dynamic auth\" capability to\nsystems programmers only, but later they relented, and realized that you\nneed an operator command too, sometimes.  Again, the advantage of the\noperator SET command, is that you don't need to have a TSO session up\nwhen you need to change something.\n\n     In modern z/OS systems, the default auth tables in the system are\ncreated from the default PARMLIB member IKJTSO00, or whatever IKJTSOxx\nmember is pointed to, by the active IEASYSxx member.  So at this point,\nwe have to realize that \"everybody else's\" TSO/E authorizations come\nfrom the PARMLIB member IKJTSOxx that is currently active.\n\n     Nevertheless, if your session's TSO/E authorizations come from a\ncopy of the IKJTABLS load module that is in an APF-authorized STEPLIB,\nthey will STILL COMPLETELY OVERRIDE the default tables.  That is because\nyour TSO session's LWA pointed-to tables were copied from your STEPLIB\nload library at LOGON time, instead of being copied from the\nPARMLIB-created copies of the tables in common storage.  We'll see how\nthis works, a bit later on.\n\n     However, if the PARMLIB member IKJTSOxx does NOT contain one of the\nkeywords:  AUTHCMD, AUTHPGM, AUTHTSF, or NOTBKGND, then that respective\ntable is defaulted from its copy in IKJTABLS that is in LPALIB.  Again,\nif your session has an authorized STEPLIB with IKJTABLS, then your\nSTEPLIB's IKJTABLS will override any other default table that is in the\nenvironment.  We'll discuss all these facts in much greater detail\nlater.\n\n\nTABLE LENGTHS AND TABLE DELIMITERS\n\n     At this point, I just want to interrupt the discussion to talk\nabout the lengths of the tables that were created by the PARMLIB TSO\ncommand (or by the SET IKJTSO=xx operator command).\n\n     When the PARMLIB processing creates one of its incore tables in\ncommon storage, the length of the created table is measured, and it is\nrecorded in the CTLT control block (some details to be discussed later).\nWhen the auth tables are created (for a user's TSO session) via their\nbeing copied from an IKJTABLS load module in STEPLIB, no lengths of\ntables are recorded in the system.  This is a big difference.\n\n     So the question is, if no table lengths are recorded, how does the\nsystem \"know\" where the table ends?  Answer is, that all the TSO auth\ntables are delimited by a blank table entry.  In other words, if the\nprogram name is 8 blanks, then all table entries after that point, are\nignored, and the table is deemed to end at the blank entry.  This is a\nVERY important fact for us to know.\n\n     Since we have the possibility of an \"auth table\" coming from any of\nseveral origins, there have to be \"flags\" in the system, telling you how\nto deal with that particular copy of that particular table.  The Logon\nWork Area (LWA), which we'll talk about later, contains such flags to\ndeal with a TSO session's auth tables that come from various origins.\nBut in any case, the bottom line is that A BLANK TABLE ENTRY WILL ALWAYS\nDELIMIT THE TABLE, no matter what its origin was.\n\n\nYOUR OWN COPY OF THE AUTH TABLES\n\n     Consider this.  It is almost universally true that when you set up\nan entry in a PARMLIB member (that is actively being used by the\nsystem), this entry gets translated into some information that is in an\nMVS control block in storage somewhere, usually in common storage.  And\nthe system itself \"knows\" how to get to that information, through an\nestablished path.  To summarize:  Information in a PARMLIB member will\n(almost) always translate into information in common storage, which the\nsystem can get to, via a known path.\n\n     There's a problem with information in common storage, especially\nwhen it comes to TSO.  The TSO developers always have to consider a case\nwhere a thousand TSO users are trying to LOGON to their TSO sessions at\nthe same time.  In a very large installation, it might happen, and the\nTSO developers have to consider this \"boundary condition\" (so to speak)\nas being one of their developmental constraints.  What happens when a\nthousand users (or any other large number) are trying to get to common\nresources?  There will be contention somewhere, and there will be a\nbackup in trying to get to some of the (common) resources that are shared\nby all (or many) of these TSO sessions.\n\n     One solution to this general problem, is to give each TSO user his\nor her own copy of a resource, rather than for the user to continually\ntry and access the common resource.  Then, contention (by many users)\nfor the common resource is minimized or eliminated.  This happened with\nthe TSO authorization tables:  IKJEFTE2, IKJEFTE8, IKJEFTAP, and\nIKJEFTNS (AUTHCMD, AUTHPGM, AUTHTSF, and NOTBKGND respectively).  At one\npoint in time, the TSO developers decided to GIVE EACH TSO SESSION its\nOWN COPY of these authorization tables.  The \"individual copy\" of these\nauthorization tables is created within the userid's address space at\nLOGON time, in Key 0, Subpool 252 storage, and they are pointed to by\naddress fields in the Logon Work Area (LWA) which is also created for\neach TSO userid at LOGON time.  Each TSO userid has its own unique Logon\nWork Area that was created for it.  And the LWA-pointed-to copies of the\nauthorization tables are the ones which your TSO session actually refers\nto!  Most people don't know this.  I ran a survey test question among\nold MVS veterans with 25 years of experience or more.  Most of them did\nnot know where the \"real\" TSO authorization tables were!\n\n     Getting back to the subject, how do the individual copies of the\nTSO \"auth tables\" get there?  At LOGON time, they are copied into\nGETMAINed storage in Key 0, Subpool 252 from any of several sources.  As\nfar as I can determine, the IKJEFTP1 TSO initialization module (executed\nat LOGON time) performs this construction process.\n\n     Where are the tables copied from?  Under usual circumstances, they\nare copied from either of two places.  One place, is from the \"common\nstorage\" tables that are created from the active IKJTSOxx PARMLIB\nmember.  If the keywords AUTHCMD, AUTHPGM, AUTHTSF, and NOTBKGND were\ncoded in the IKJTSOxx PARMLIB member, together with an appropriate list\nof program names, then \"TSO system initialization\" at IPL time will\ncreate several areas in common storage which contain these tables.\nThese areas can be \"renewed\" or \"re-created\" whenever you do a PARMLIB\nUPDATE(xx) TSO command, or a SET IKJTSO=xx operator command, provided\nthat you have changed the list of names in the IKJTSOxx member.  If you\ndo not issue a(nother) PARMLIB UPDATE(xx) command or a(nother) SET\nIKJTSO=xx command, then these tables remain in place, in common storage,\nfor the duration of the IPL.  When a TSO user does its LOGON, the \"auth\ntables\" are usually copied from the \"common storage\" version of these\ntables, which are intended for \"most TSO users\".  I'll talk about the\n\"second possible place\" soon, where it's possible for your TSO session\nto get its \"auth tables\".\n\n     For the record, if you really want to know where the \"common\nstorage\" versions of the \"auth tables\" are, you do as follows:  The CVT\nhas an address pointer to the TSVT (TSO Vector Table) at +X'9C' from the\nCVT.  The TSVT points to the TPVT (TSO Parmlib Vector Table) at +X'4C'\nfrom the TSVT.  The TPVT points to the CTLT control block at +X'14'.\nAnd the CTLT points to the rest of the table addresses.  The TPVT and\nCTLT are not documented by IBM for public use, and IBM doesn't give out\nmacros in the macro libraries which describe them.  However, approximate\ndescriptions of these control blocks, which were figured out by users,\ncan be found on CBT Tape File 731 in the MODGEN member, or in CBT File\n492 in the SHOWMACS member.  So the macros IKJTPVT and IKJCTLT in CBT\nTape File 731 or File 492 will do the job very well, for us.  I have\nwritten several commands:  ADIS, ASUB, and LSLT, which can be found as\nload modules in the LOADLIB member of CBT File 185, that can display\nand/or directly manipulate the \"common storage\" version of the \"auth\ntables\".\n\n     The second possible place for your TSO session to get its tables\ncopied from, will happen if two circumstances are true.  First, the TSO\nsession's LOGON PROC (i.e. it's JCL) has to contain a STEPLIB DD to an\nAPF-authorized load library.  Second, a properly linkedited copy of the\nIKJTABLS load module must be present in the STEPLIB library, with one,\nseveral, or all, of the CSECTs IKJEFTE2, IKJEFTE8, IKJEFTAP, and\nIKJEFTNS present.  In that case, TSO LOGON (the IKJEFTP1 program which\ncreates your session) will copy the \"auth tables\" individually from the\nappropriate CSECT in the IKJTABLS load module that's in your authorized\nSTEPLIB library, and put that table into Key 0, Subpool 252 storage,\npointed to by the Logon Work Area.\n\n     Remember now, that the LWA version of the \"auth tables\" are the\nones which your TSO session actually uses.  So if your TSO session has\nan APF-authorized load library as a STEPLIB in its LOGON PROC, with an\nIKJTABLS load module in it, then LOGON DOES NOT GET THAT TABLE from the\n\"common storage\" copy.  Therefore the STEPLIB version of the table will\nCOMPLETELY OVERRIDE the version of that table in common storage, which\nwas created by the (active) PARMLIB member IKJTSOxx.  Thus we see that\nyour \"auth tables\" for your TSO session can come from one of two places,\nEITHER, OR, BUT NOT BOTH!\n\n     What if AUTHCMD, AUTHPGM, AUTHTSF, or NOTBKGND are NOT coded in the\nIKJTSOxx PARMLIB member?  And additionally, there is no authorized\nSTEPLIB library, or it doesn't contain an IKJTABLS load module?  Then\nwhat happens?\n\n     In THAT case, the LWA will NOT point to the appropriate table in\nKey 0, Subpool 252 storage.  But it will merely point to the appropriate\ndefault CSECT:  IKJEFTE2, IKJEFTE8, IKJEFTAP, or IKJEFTNS that is in the\ncopy of IKJTABLS that is in LPALIB.  In that case, the LPALIB version of\nthe table will be the one which your session uses.\n\n\nNEW WAYS OF LOADING TSO AUTH TABLES\n\n     Dan Dalby has written a marvelous \"dynamic\" STEPLIB command (found\nin CBT Tape File 452) which can perform the creation of a STEPLIB in a\nTSO session, exactly the way IBM does it with JCL.  This STEPLIB command\nhas to be APF-authorized, but once it is, and you've used it, you've\ngiven your TSO session access to programs that it wouldn't otherwise\nhave had access to.\n\n     If Dan's STEPLIB command is executed against an APF-authorized load\nlibrary, the effect is exactly as if you have an APF-authorized STEPLIB\nin the JCL, but there is one great big difference when it comes to\nloading the auth tables into your TSO session.  Dan's STEPLIB command\nwas not in effect at your session's LOGON time.  If you have an\nauthorized STEPLIB, statically coded in the LOGON PROC, it WAS there at\nLOGON time.  Therefore, if the authorized STEPLIB was there at LOGON\ntime, and it has an IKJTABLS load module in it, the auth tables come\nfrom IKJTABLS.  But if the STEPLIB was NOT there at LOGON time, then the\ntables still come from the \"common storage\" tables that were created\nfrom the active IKJTSOxx PARMLIB member.  Therefore, even though you\nhave executed Dan's STEPLIB command against an APF-authorized load\nlibrary that contains a big IKJTABLS member, you don't have all the\npower you need to execute all the programs, because you are still using\nthe \"common storage auth tables\" and not the (presumably bigger) tables\nthat were coded in the STEPLIB.\n\n     How can we \"dynamically load\" the STEPLIB, and then \"dynamically\nload\" the tables after that?\n\n     Dan and I have independently written two programs which will do\nthis.  Dan's program is called LWATMGR (LWA Table Manager).  My program\nis called LLWA, or (re)Load the LWA.  These two programs can load a\nfresh set of auth tables, from any of 3 different sources, into Key 0\nSubpool 252 storage in your TSO session's address space, and then\nre-point the LWA pointers and flags to properly point to the new tables.\nYour TSO session will then honor the new tables, and not the old ones.\n\n     In addition to my LLWA program, I have written another program\ncalled TSUB, which manipulates pre-existing auth tables that are\npointed to by the LWA.  In functionality, LWATMGR will approximately\nequal the combined capabilities of LLWA and TSUB.  But they do have\nnon-overlapping capabilities too, so it would pay for you to learn about\nall three programs.  These programs are found in the CBT Tape collection\n(at www.cbttape.org on the Updates Page) in File 797.\n\n     In order to get full capability with your \"auth tables\" later, you\nwill have to pre-authorize just two programs in the AUTHCMD table.\nThese would be either STEPLIB and LWATMGR, or STEPLIB and LLWA.\nActually, if you have LLWA or LWATMGR loaded into an authorized load\nlibrary already, that your TSO session has access to, you just have to\npre-authorize either one of these, and you can include STEPLIB in the\nAUTHCMD (IKJEFTE2) list in your new freshly loaded tables.\n\n     So what we do, is to use LLWA or LWATMGR to load a fresh set of\nauth tables for your own TSO session.  And then, it doesn't matter what\nauth tables your TSO session used before.  The combined action of the\nSTEPLIB program and either LLWA or LWATMGR will then exactly duplicate\nthe effect of an authorized STEPLIB in your LOGON PROC, without your\nactually needing to have a special LOGON PROC for yourself.\n\n\nSOURCES OF AUTH TABLES FOR RELOADING\n\n     Both the LLWA and LWATMGR programs can load a new set of auth\ntables from either of 3 sources:  An IKJTABLS-like load module, an\nIKJTSOxx-like LRECL=80 PARMLIB-like dataset (sequential or a pds\nmember), or a raw list of program names, with LRECL=8.  This list of\nnames is as \"bare-bones\" a piece of input as you'll ever need, and it\ntakes very little disk space to store it.  In addition, the LLWA program\ncan convert either load library input, or PARMLIB-like input into the\nLRECL=8 list input, so you can conveniently store the lists away.\n\n     The LRECL=8 list input is most fascinating, in my view.  You\nspecify which table is being loaded, with a special 8-byte header.  For\nthe IKJEFTE2 table, the header in the list, is ---E2---.  For the\nIKJEFTE8 table, the header entry is ---E8---.  And similarly, ---AP---\nand ---NS--- will cause the reloading of those respective tables, with\nall the program name entries that follow that header (until encountering\neither the next header, or the end-of-file).  Again, the LLWA program can\nconvert either load-module input or PARMLIB-like input into LRECL=8\n\"name list\" input.\n\n     For details as to how to run the LWATMGR, LLWA, and TSUB programs,\nplease see CBT Tape File 797, which has source code for all of them, as\nwell as HELP members for them.\n\n     My recommendation would be to store all of your auth tables as\nLRECL=8 lists, as members of a pds.  The pds will take up very little\nroom.  For example if the blocksize of the pds is 6000, then 750 table\nentries will fit in just one block.  Therefore, the data to rebuild all\nof your auth tables will probably fit into just one block of data.  Now\nthat's compact!  If you want to hide your lists and store them offsite,\njust put the pds into TSO XMIT format and download it in BINARY to a PC,\ngiving the XMIT-format dataset any name you want.\n\n     You can sort-merge all of your auth tables to get one big list.  Or\nelse, you can just load \"specialty tables\" as the need arises.  You've\ngot a lot of power here.\n\n\nTHE EFFECT OF PARMLIB UPDATE(xx)\n\n     There's one more fact here, which you should know about.  There are\nflags in the LWA for each of the four tables, saying whether they were\nloaded into your TSO session (presumably at LOGON time) from PARMLIB or\nfrom a STEPLIB.  If the flag bit is 0, that table was presumed to be\nloaded from PARMLIB.  If that flag bit is 1, then the table is presumed\nto have been loaded from STEPLIB.  What happens to the tables for your\nTSO session, when a PARMLIB UPDATE(xx) is done, to change one or more of\nthe tables?\n\n     Well, IBM would like that every active TSO session should use the\nnew tables.  So the PARMLIB command goes around, across address spaces,\nvisits each active TSO session, and looks at each of its auth tables.\nIf the LWA flag for that table says that it came from PARMLIB, then the\nPARMLIB command replaces the given table with a new one, dynamically.\nSo the effect is that if OUR new tables were marked as if they came from\nPARMLIB, then a PARMLIB UPDATE(xx) command would overlay our work with\nthe common tables again.  Therefore, both the LLWA and LWATMGR commands\nwill mark their newly created tables as if they came from STEPLIB rather\nthan PARMLIB, so a PARMLIB UPDATE(xx) command would not re-overlay them.\n\n     An additional consequence comes out from this.  PARMLIB UPDATE(xx)\nhas the effect of making a global change to the auth tables.  Suppose we\nonly want to test a new set of auth tables on one session!  Then we use\neither the LWATMGR or LLWA commands to limit the effect of the new auth\ntable(s) to just the session that invoked them.  This way, we have a\nLOCAL change and not a GLOBAL change.  Thus we can use the new LLWA\nand/or LWATMGR commands to test a new auth table on only one TSO userid,\nwithout consequences for the rest of the TSO sessions in the LPAR.\n\n\nSUMMARY\n\n     The TSO authorization tables (AUTHCMD, AUTHPGM, AUTHTSF and\nNOTBKGND) which your TSO session uses, are local tables in your own\naddress space, that were either copied from the \"common storage\" tables,\ncreated from the IKJTSOxx PARMLIB member, or were copied from an\nIKJTABLS load module in a STEPLIB that is APF-authorized to your TSO\nsession.  The active tables are pointed to, and described, by addresses\nand flags in the LWA (Logon Work Area) which is unique to your TSO\nsession.  Your TSO session's auth tables are created during LOGON\nprocessing, at LOGON time, by the IKJEFTP1 program.  These can be\nreplaced later, by either of the authorized TSO commands, LLWA or\nLWATMGR, which can be found on the CBT collection (www.cbttape.org)\non the Updates page, in File 797.\n\n     The LLWA and LWATMGR programs can take new table input in three\nformats:  load module input, PARMLIB member type input, or LRECL=8 name\nlist input.  See File 797 for the details.  It is my experience that\nyour auth tables are most conveniently stored in LRECL=8 input, as\nmembers of a pds.  The LLWA program can convert auth table input from\neither load module format or PARMLIB-like format into LRECL=8 list\nformat, for convenient storage and later use.\n\n     I hope that this article will open your minds to being able to\ncustomize your TSO environment better, and with more flexibility.  Your\nrole as \"system doctors\" will be greatly enhanced by this knowledge and\nby these new capabilities.\n\n     Best of luck to all of you.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@ARTICL2": {"ttr": 773, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00)\\x01\\t\\x03\\x7f\\x01\\t\\x03\\x7f\\x13&\\x01@\\x01@\\x00\\x00```````@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2009-02-06T00:00:00", "modifydate": "2009-02-06T13:26:29", "lines": 320, "newlines": 320, "modlines": 0, "user": "-------"}, "text": "               TSO AUTHORIZATION TABLES - Part 2\n\n(c) Copyright 2009 by Sam Golob.  All rights reserved.\n\nTOOLS TO MANIPULATE OR REBUILD THE AUTH TABLES:\nASUB, TSUB, LLWA, and LWATMGR\n\n      In our last article, we discussed the TSO authorization tables in\ngeneral, the fact that they consist of lists of program names, and we\nsaid something about what each of the lists accomplishes.  There are\nfour main lists:  These are AUTHCMD (module IKJEFTE2), AUTHPGM (module\nIKJEFTE8), AUTHTSF (module IKJEFTAP), and NOTBKGND (module IKJEFTNS).\nAUTHCMD lists all TSO commands that are allowed to run APF authorized\nunder your TSO session.  AUTHPGM lists all programs that can run APF\nauthorized when called by your TSO session.  AUTHTSF lists all programs\nthat can get authorized using the TSO Service Facility.  And NOTBKGND\nlists all TSO commands that cannot be run under TSO-in-batch.\n\n      As systems programmers, we all know how to set the lists of\nprogram names in each of these categories, by creating or modifying an\nIKJTSOxx PARMLIB member.  Then, once the member is created, we issue a\nPARMLIB UPDATE(xx) TSO command or a SET IKJTSO=xx operator command to\nput that member into effect.  What happens to the system as a result of\nthese commands, is what most people don't know about.  This is part of\nwhat we're going to talk about.  What comes next, though, will be some\ninstructions about how we can directly manipulate the in-core program\ntables that are constructed from the PARMLIB IKJTSOxx member.\n\n      When a PARMLIB UPDATE(xx) command, or an IPL, or a SET IKJTSO=xx\noperator command is issued, in-core tables:  IKJEFTE2, IKJEFTE8,\nIKJEFTAP, and IKJEFTNS are created in common storage.  These become\ntemplates for the corresponding tables that will belong to (almost)\nevery TSO session that will LOGON afterwards.  These common storage\ntables are pointed to by the CVT, the TSO Vector Table, the TSO PARMLIB\nVector Table, and the IKJCTLT control block.  Once you get to the\nIKJCTLT control block, you have the pointers to all of the in-core TSO\nauthorization tables.   The exact addresses are:  TSO Vector Table is\nX'9C' off the CVT.  The TSO PARMLIB Vector Table is X'4C' off the TSVT.\nAnd the CTLT is X'14' off the TPVT.  A map of the TPVT and the CTLT\ncan be obtained from the SHOWMACS member of CBT File 492 or the MODGEN\nmember of CBT File 731.  Maps of these last two control blocks are not\ndistributed by IBM.  We had to figure them out.\n\n\nMANIPULATING THE IN-CORE COPIES OF THE AUTH TABLES - THE ASUB COMMAND\n\n      I wrote an authorized TSO command called ASUB, which goes directly\ninto the in-core TSO auth tables created from the IKJTSOxx PARMLIB\nmember, and manipulates its table entries, which are program names.  The\nASUB program can be found on CBT Tape File 185, where the TSUB program\ncan also be found.\n\n      The ASUB program works as follows:  ASUB has three functions:\nDISPLAY an entry, or the entire table.  REPLACE a numbered entry in the\ntable, and BLANK the last entry in the table.  The syntax of the ASUB\ncommand is:\n\n      ASUB tta nnn pgmname\n\nwhere tt is the table name:  E2, E8, AP, or NS.\na is the action code, D for display, R for replace, B for blank.\nnnn is the specific numbered table entry you want to display or change.\npgmname is the new program name you want to Replace, for the\n   existing name that is in that table slot now\n\n      For example, ASUB E2D   will display the entire IKJEFTE2 table and\nlist all its entries.\n\n      ASUB E2D 55    will list only one entry in the IKJEFTE2 table, the\n55th one.\n\n      ASUB E2R 55 CQX  will replace whatever name was in the 55th entry\nof the IKJEFTE2 table, with the program name of CQX.\n\n      ASUB E2B   will erase whatever program name was in the last entry\nof the IKJEFTE2 table, and will replace it with a blank entry consisting\nof all spaces.\n\n      A blank entry always delimits the entire table, causing any\nentries after the blank entry, to be ignored.  For that reason, I did\nnot allow the B function of ASUB, to blank any entry in the middle of\nthe table, but if I had filled in the last entry of the table with a\nnon-blank program name, using the ASUB Replace function, the B function\nwill blank out this non-blank entry that I had put at the end of the\ntable.  This concept is very important for us, because when I discuss\nthe similar TSUB program later, I'll show you how TSUB can blank out any\ntable entry even in the middle of the table, and not just the last\nentry.  This is a VERY significant concept for us to grasp.\n\n      Since the ASUB program has to run as an APF authorized TSO\ncommand, its name has to be entered in the IKJEFTE2 (AUTHCMD) table list\nof program names, and its load module has to reside in an APF authorized\nload library.  Again, I must emphasize that ASUB does not modify a copy\nof the tables that is used directly by your TSO session.  The copy of\nthe tables that ASUB modifies, is the \"common storage\" copy of the table\nthat TSO LOGON uses to create your session's tables at LOGON time.  So\nif your TSO session was logged on, and you used ASUB to change one or\nmore table entries, the changes will only affect your TSO session after\nyou re-LOGON.  The effect of ASUB in manipulating the TSO auth tables\nis GLOBAL, and it affects the entire LPAR until another PARMLIB UPDATE\ncommand, or SET IKJTSO= command is issued, or until you IPL.  Every NEW\nTSO session to LOGON, will copy the table version which ASUB has\nmodified.\n\n\nGETTING YOUR TSO SESSION'S TABLES FROM STEPLIB\n\n      The TSO designers have created another way to build your TSO\nsession's \"auth\" tables at LOGON time.  If you are a sysprog or another\n\"special-type\" user, who was allowed by management to have a LOGON PROC\nin your TSO session with a STEPLIB DD to an APF-authorized load library,\nthen this is a special case, different from ordinary TSO users.\n\n      One other condition must be satisfied to create the special case.\nThe APF-authorized STEPLIB must contain a linkedited copy of a load\nmodule called IKJTABLS, that contains CSECTs IKJEFTE2, IKJEFTE8,\nIKJEFTAP, and IKJEFTNS, or some of these.  In this special case, at\nLOGON time, the LOGON processing will not copy your session's auth\ntables from the PARMLIB-created copies in common storage.  But it will\ndo a BLDL for the CSECTs from the STEPLIB, and if the CSECTs are there,\nLOGON will copy them from the authorized STEPLIB instead of from the\n\"common storage\" PARMLIB-created copies.  In this way, a \"special\" user\ncan have different \"auth tables\" than everybody else.\n\n      At LOGON time, there are differences to how the STEPLIB-created\ntables look, as opposed to the PARMLIB-created tables.  In the LWA, the\nSTEPLIB-created tables are marked as having zero length.  This has the\neffect of forcing the only delimiter to the tables, to be the first\nblank entry.  The system (in that case) has no other way of knowing how\nlong each table is.  On the other hand, when the tables are copied from\nthe PARMLIB-created \"common storage\" copy, the length of each table is\nfilled in, in an appropriate field in the LWA (Logon Work Area) for that\nparticular table and that TSO session.\n\n      One other difference exists between STEPLIB-created auth tables\nand PARMLIB-created auth tables for your TSO session.  This is, that the\nLWA for your TSO session contains a flag bit for each of the four\ntables, which is 1 if the table came from STEPLIB, and it is 0 if the\ntable came from PARMLIB.  The effect of this bit is as follows:  If the\nbit for that table is 0, then when some TSO session does a PARMLIB\nUPDATE(xx) command, or the operator issues a SET IKJTSO=xx command, all\nTSO sessions which have their tables marked as coming from PARMLIB, will\nget their tables overlaid and re-created, according to the new IKJTSOxx\nmember that is in effect.  If a table is marked as coming from STEPLIB,\nwith the bit set to 1, then overlay from a PARMLIB UPDATE(xx) or SET\nIKJTSO=xx command DOES NOT OCCUR.  This is understandable.  If a\n\"special user\" has special authorization permissions, he/she does not\nwant them overlaid by a global change for the rest of the TSO users.  So\nthat's why IBM designers put the STEPLIB bit there, in the LWA.\n\n\nMANIPULATING YOUR TSO SESSION'S OWN TABLES - THE TSUB COMMAND\n\n      To manipulate YOUR TSO SESSION's auth tables, or to change the\ncharacteristics of your TSO session's existing tables, I have written\nthe authorized TSO command called TSUB.  Except for its Display\nfunction, TSUB has to be APF-authorized, so its name has to be entered\nin your session's IKJEFTE2 (AUTHCMD) table.\n\n      The TSUB command is like the ASUB command, but with more added\ncapability, owing to the difference in the nature of the \"common\nstorage\" copy of the tables (created by PARMLIB) and the individual\nusers' copy of the tables, pointed to by the LWA.  ASUB works on the\n\"common storage\" copy of the TSO auth tables.  TSUB works locally, on\nYOUR OWN SESSION's copy of the TSO auth tables, pointed to by the LWA.\n\n      As a consequence, other differences between TSUB and ASUB are:\n\n1.  If you make a change to a table with ASUB, your TSO session will\n    only get the changes if you re-LOGON.  When you make table changes\n    with TSUB, the effect (to your TSO session) is immediate.  If you\n    re-LOGON after TSUB has made changes, all changes will be lost.\n\n2.  ASUB only deals with tables that were created from PARMLIB members,\n    and which therefore are marked with a length.  TSUB can get its\n    tables either from PARMLIB or from STEPLIB.  If your session's\n    tables came from STEPLIB, they do not have length values (in the\n    LWA) attached to them.  Therefore, TSUB can not easily \"blank\" a\n    \"last member\" of a table, because we don't really know where the\n    \"last member\" is.  So I allow TSUB to blank ANY member of a table.\n    This is potentially dangerous, but also potentially useful and\n    creative.  It depends on how much knowledge you have, and on how\n    responsible you are.  Fortunately, if you mess up with TSUB, you\n    can re-LOGON and set things back to the beginning state.  Not so\n    with ASUB.  With ASUB you have to re-issue PARMLIB UPDATE(xx) or\n    SET IKJTSO=xx to set things straight again.\n\n3.  ASUB only manipulates tables in common storage.  TSUB can ALSO\n    manipulate LWA fields that are connected to each of the tables.\n    The effect of a TSUB change is IMMEDIATE, but it only affects\n    your own TSO session.  Therefore, TSUB has extra action codes\n    possible.\n\n    Extra action codes associated with TSUB, which you don't have with\n    ASUB, are:\n\n    H - Alter the header of the table to make it look like it came\n        from PARMLIB.\n\n    L - Measure the table, to put a \"length\" field for it, in the LWA.\n\n    Z - Zero out the length field for the table in the LWA.  Force it\n        to be delimited only by the first blank entry.\n\n    S - Turn on the STEPLIB bit for the table in the LWA.  This has the\n        effect that a PARMLIB UPDATE(xx) or SET IKJTSO=xx command will\n        not overlay your session's table.\n\n    P - Turn off the STEPLIB bit for the table in the LWA.  Then a\n        PARMLIB UPDATE(xx) or SET IKJTSO=xx command will overwrite the\n        existing table when those commands are issued.\n\n    B - Blank any table entry.  With ASUB, you say E2B and you can only\n        blank out the \"last table entry\".  With TSUB, the B action must\n        be followed by a \"slot number\" to blank out, and it can be ANY\n        SLOT, even one in the middle of the table.  The effect of this\n        blanking, is to nullify ALL SUBSEQUENT NON-BLANK entries in the\n        table, and to stop reading the table at the blank entry.  That\n        is dangerous if you don't know what you're doing, but I can\n        think of some very creative ways of using this capability.\n\n\nMAKING COMPLETELY NEW TABLES WITH LLWA, LWATMGR, AND LWATEDIT\n\n      TSUB (and ASUB) deal with MODIFYING ALREADY EXISTING tables.  What\nif you wanted to forget about the existing table and load a completely\nnew one, with a whole set of new and/or different and extra entries?  If\nyou're dealing with your own TSO session's LLWA-pointed auth tables,\nthis is entirely possible, using a set of TSO commands:  LLWA and/or\nLWATMGR from CBT Tape File 797.  LLWA was written by me.  LWATMGR and\nits ISPF interface program, LWATEDIT were written by Dan Dalby.\n\n      To replace an existing table with a new table, a program has to\nGETMAIN some Key 0, Subpool 252 storage (for that, it has to be APF\nauthorized), the new table has to be constructed in storage and copied\ninto the GETMAINed area, and the field in the Logon Work Area, which\npoints to the requisite table, has to be re-pointed to the new table.\n\n      To modify the LWA, you also have to be APF authorized.  And before\na new table location is finalized, there are two more modifications that\nhave to be made.  If the table has a length value associated with it,\nthat length has to be plugged into the proper field in the LWA, and also\nthere is a bit in the LWA which states that this table came from STEPLIB\nand not from PARMLIB.  Our programs LLWA and LWATMGR set this bit on,\nbecause if it is not on, a future PARMLIB UPDATE(xx) or SET IKJTSO=xx\ncommand would overlay our new table in our address space, erasing our\nchanges.\n\n      The LLWA program, written by me, will replace one table, or all\nfour tables, from either of three sources.  The LWATMGR program, written\nby Dan Dalby, will deal with one table at a time only, but LWATMGR can\nalso create an entirely new table from the same three sources.  These\nsources are:  An IKJTABLS load module, similar to the one that you put\nin an APF authorized STEPLIB, or, an FB-80 IKJTSOxx PARMLIB-like member,\nor, an FB-8 (that is, LRECL=8) list of program names.  The FB-8 list of\nprogram names is headed by a \"header record\" that looks like \"---E2---\",\nor \"---E8---\" or \"---AP---\" or \"---NS---\", which tells you which table\nto build from the names that follow the header.\n\n      LLWA will create a new table with 30 blank entries at the end,\nwhich is my preference.  The extra blank entries allow you to add more\nnames with the TSUB program, one at a time.  Dan Dalby's LWATMGR program\nadds only one blank entry at the end, because his program can repeatedly\nFREEMAIN and GETMAIN storage for new tables as needed.  And LWATMGR has\nfacility to add or delete one program name at a time also.\n\n      Dan's LWATEDIT facility for creating a new table is quite amazing.\nYou execute the TSO command LWATEDIT under ISPF, and a panel comes up,\nasking you which table you want to update.  When you pick a table, you\nget the list of program names which that current table contains.  You\nthen can edit the list as you wish, copy names in and out, and then you\nSAVE it.  After you SAVE the list and when you exit it, LWATEDIT calls\nLWATMGR to automatically build a new table with just those entries.  So\nyou can actually EDIT your auth tables and customize them as your\ncurrent needs dictate.\n\n      LWATEDIT makes its table updates by calling LWATMGR, which must be\nAPF authorized.  Since LWATEDIT operates under ISPF, and ISPF does NOT\n\"like\" to be authorized, LWATEDIT must authorize LWATMGR using the\nAUTHTSF facility.  So when you use LWATEDIT, the name LWATMGR must reside\nin BOTH the AUTHCMD and the AUTHTSF tables.  When you use LWATMGR as a\nTSO command only, it need only reside in the AUTHCMD table.\n\n      Either LLWA or LWATMGR, whichever one you use, will have to be in\nthe AUTHCMD list, from the beginning.  Or else, TSUB has to be in the\nAUTHCMD list from the beginning.  Then TSUB can be used to put LLWA or\nLWATMGR in the AUTHCMD list, and after that, LLWA or LWATMGR will be\nused, to build a completely new list, with everything you want in it.\nThis is how you escalate your ability to do useful work for your\ninstallation.  Once you authorize TSUB as a TSO command, you can get all\nthe other commands and programs authorized.\n\n\nSUMMARY\n\n      The four TSO authorization tables, AUTHCMD (IKJEFTE2), AUTHPGM\n(IKJEFTE8), AUTHTSF (IKJEFTAP), and NOTBKGND (IKJEFTNS) that your TSO\nsession uses, are pointed to by fields in the LOGON WORK AREA (LWA)\nwhich is unique to your TSO session.  The LWA is created at LOGON time.\nOnce we authorize one program, for example the TSUB program, to modify\nan existing table, we can get all our other programs authorized, to our\nheart's desire.  This is done either by modifying one of the auth tables\nwith either TSUB or LWATMGR, or by building completely new tables using\neither the programs LLWA or LWATMGR.\n\n      The TSUB program can also modify any of the existing tables'\ncharacteristics, as reflected by fields in the LWA which refer to that\ntable.  These may be either the table's length (whether it has a length\nor not, and if it has, what the length is).  Or, it may be whether the\ntable is marked as coming from STEPLIB or not.  If the table is not\nmarked as coming from STEPLIB, then it is at risk of being overlaid by\na future PARMLIB UPDATE(xx) command or a SET IKJTSO=xx operator\ncommand.\n\n      The LLWA and LWATMGR programs can be used to create a completely\nnew auth table.  The LWATEDIT ISPF interface to the LWATMGR program\nallows you to ISPF EDIT your existing table entries, SAVE the EDIT, and\nbuild a completely new table from the EDIT.  This is an extremely\namazing capability, which I believe, never existed before.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@FILE185": {"ttr": 779, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04c\\x00@\\x01 \\x08\\x7f\\x01 \\x08\\x7f\\x14\\x05\\x00r\\x00r\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf9\\xf9@@@'", "ispf": {"version": "04.99", "flags": 0, "createdate": "2020-03-27T00:00:00", "modifydate": "2020-03-27T14:05:40", "lines": 114, "newlines": 114, "modlines": 0, "user": "CBT-499"}, "text": "//***FILE 185 contains tools to help you control the TSO auth       *   FILE 185\n//*           tables which APF-authorize TSO commands and programs  *   FILE 185\n//*           to your TSO session.  Between this file, and File     *   FILE 185\n//*           797, you have a very nice set of tools which will     *   FILE 185\n//*           help you in this matter, both in altering the         *   FILE 185\n//*           \"common storage\" copies of the auth tables created    *   FILE 185\n//*           by PARMLIB (members IKJTSOxx), and in altering the    *   FILE 185\n//*           individual TSO session's auth tables pointed to by    *   FILE 185\n//*           the LWA (Logon Work Area).                            *   FILE 185\n//*                                                                 *   FILE 185\n//*           ASUB deals with the \"common storage\" tables. (CSA)    *   FILE 185\n//*           TSUB deals with the \"LWA pointed to\" tables. (User)   *   FILE 185\n//*                                                                 *   FILE 185\n//*           File 185 also contains source code (member ASMTABLS)  *   FILE 185\n//*           and a load library (member LOADLIB) to help you make  *   FILE 185\n//*           a greatly expanded IKJTABLS load module to authorize  *   FILE 185\n//*           programs and commands under TSO.  When run in an APF  *   FILE 185\n//*           authorized STEPLIB in a TSO session, this IKJTABLS    *   FILE 185\n//*           load module will override IKJTSOxx from PARMLIB and   *   FILE 185\n//*           will also override the copies of IKJTEFE2, IKJEFTE8,  *   FILE 185\n//*           IKJEFTAP, and IKJEFTNS that are in SYS1.LPALIB.       *   FILE 185\n//*           The load module IKJTABLS should be copied into        *   FILE 185\n//*           an APF-authorized STEPLIB with all its aliases:       *   FILE 185\n//*           IKJEFTE2, IKJEFTE8, IKJEFTAP, IKJEFTNS.               *   FILE 185\n//*                                                                 *   FILE 185\n//*           The source code (member ASMTABLS) was created with    *   FILE 185\n//*           the aid of the vendor product STARTOOL FDM from       *   FILE 185\n//*           Serena, Inc.  I have included a free method of        *   FILE 185\n//*           generating a nearly equivalent disassembly of your    *   FILE 185\n//*           current IKJTABLS load module, using only free tools.  *   FILE 185\n//*           This is completely self-contained in XMIT format,     *   FILE 185\n//*           as pds member FILE234I in this file.  Member $$$$READ *   FILE 185\n//*           in that pds, and member $$NOTE2 in this pds, will     *   FILE 185\n//*           explain what to do, if you need to generate your      *   FILE 185\n//*           own assembly JCL for IKJTABLS.                        *   FILE 185\n//*                                                                 *   FILE 185\n//*           The load library is included in this file, in member  *   FILE 185\n//*           LOADLIB, in TSO XMIT format.  Just do a TSO RECEIVE   *   FILE 185\n//*           INDS(this.pds(LOADLIB)) to create the load library    *   FILE 185\n//*           on your system.  There are load modules for other     *   FILE 185\n//*           \"TSO auth table\" tools in this load library as well:  *   FILE 185\n//*                                                                 *   FILE 185\n//*           ADIS, ASUB, LLWA, LSLT, LWATEDIT, LWATMGR, STEPLIB,   *   FILE 185\n//*           and TSUB.                                             *   FILE 185\n//*                                                                 *   FILE 185\n//*           If you want to authorize everything that everybody    *   FILE 185\n//*           else has, you have to copy (zap) all the names        *   FILE 185\n//*           from your IKJTSOxx PARMLIB member into this load      *   FILE 185\n//*           module, or else you might find that you've lost       *   FILE 185\n//*           authorization of some programs and/or commands.       *   FILE 185\n//*           I have tried to include all the commands that I       *   FILE 185\n//*           use, and all the names that I could find on the       *   FILE 185\n//*           live systems, but you may most likely need some       *   FILE 185\n//*           more.  To quickly obtain a list of programs in your   *   FILE 185\n//*           session's auth tables see the LWATMGR and LWATEDIT    *   FILE 185\n//*           tools in CBT File 797.  Also you can run TSUB E2D,    *   FILE 185\n//*           TSUB E8D, TSUB APD, TSUB NSD, to display your         *   FILE 185\n//*           TSO session's current lists.  Use ASUB E2D, etc.      *   FILE 185\n//*           to display the PARMLIB-generated current lists.       *   FILE 185\n//*                                                                 *   FILE 185\n//*           Also refer to CBT Tape File 797 for extra help in     *   FILE 185\n//*           this area.  File 797 has tools to manipulate the      *   FILE 185\n//*           TSO auth tables in each userid's session, or to       *   FILE 185\n//*           LOAD COMPLETELY NEW TABLES for a user's session.      *   FILE 185\n//*           File 185 concentrates on tools to CHANGE the          *   FILE 185\n//*           EXISTING TSO auth tables either in common storage,    *   FILE 185\n//*           or in your own session.  (ASUB and TSUB               *   FILE 185\n//*           respectively.)                                        *   FILE 185\n//*                                                                 *   FILE 185\n//*           Please read members $EXPLAIN and $$NOTE1 carefully.   *   FILE 185\n//*                                                                 *   FILE 185\n//*           Use the new ADIS command (Auth table DISplay)         *   FILE 185\n//*           command to display what authorized commands and       *   FILE 185\n//*           programs everybody else has.  ADIS will generate      *   FILE 185\n//*           a \"copyable list\" of these commands, whether it be    *   FILE 185\n//*           from the \"live\" IKJEFTE2, or IKJEFTE8, or IKJEFTAP    *   FILE 185\n//*           tables, or even from the IKJEFTNS table.              *   FILE 185\n//*                                                                 *   FILE 185\n//*           Members ADIS (source for a TSO command to display     *   FILE 185\n//*           the active \"auth tables\" generated from a PARMLIB     *   FILE 185\n//*           UPDATE(xx) command, a SET IKJTSO=xx command, or       *   FILE 185\n//*           an IPL, and ADIS$ (JCL to assemble ADIS) have been    *   FILE 185\n//*           added to this pds.  And the load module for ADIS      *   FILE 185\n//*           has been added to the LOADLIB member.                 *   FILE 185\n//*                                                                 *   FILE 185\n//*           ADIS will display the common storage TSO/E \"auth      *   FILE 185\n//*           tables\" generated from the PARMLIB member IKJTSOxx.   *   FILE 185\n//*           The output of the ADIS command can be captured        *   FILE 185\n//*           using SYSOUTTRAP tools, since it is generated by      *   FILE 185\n//*           the TSO PUTLINE service.  Try ADIS.  You'll like      *   FILE 185\n//*           it.  ADIS is read-only, and does not need APF         *   FILE 185\n//*           authorization.                                        *   FILE 185\n//*                                                                 *   FILE 185\n//*           A new TSO command called SHOWTPVT documents all       *   FILE 185\n//*           the fields of the TPVT control block (TSO PARMLIB     *   FILE 185\n//*           Vector Table) which is not documented publicly        *   FILE 185\n//*           by IBM.  SHOWTPVT shows all the values of your        *   FILE 185\n//*           own system's TPVT.                                    *   FILE 185\n//*                                                                 *   FILE 185\n//*           Remember that the member LOADLIB of this pds also     *   FILE 185\n//*           contains a load module for a greatly expanded         *   FILE 185\n//*           IKJTABLS to authorize programs and commands under     *   FILE 185\n//*           TSO.  This load module was created from the ASMTABLS  *   FILE 185\n//*           source code.  For TSO/E Release 2.n, and higher,      *   FILE 185\n//*           this load module (and its aliases) can be used as     *   FILE 185\n//*           is.  There is also plenty of room to zap more names,  *   FILE 185\n//*           in the IKJEFTE2, IKJEFTE8, and IKJEFTAP tables.  You  *   FILE 185\n//*           may want to zap the tables to authorize more of your  *   FILE 185\n//*           favorite programs.  Put it in an APF authorized       *   FILE 185\n//*           STEPLIB in your TSO logon proc.  Has to be SETCODE    *   FILE 185\n//*           AC(1).                                                *   FILE 185\n//*                                                                 *   FILE 185\n//*           Updated for z/OS Version 2.3.     (CBT498)            *   FILE 185\n//*                                                                 *   FILE 185\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ADIS": {"ttr": 1027, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x17\\x00!\\x01\\x06\\x01\\x8f\\x01\\t\\x03_\\x08#\\x05r\\x04)\\x00\\x00```````@@@'", "ispf": {"version": "01.23", "flags": 0, "createdate": "2006-01-18T00:00:00", "modifydate": "2009-02-04T08:23:21", "lines": 1394, "newlines": 1065, "modlines": 0, "user": "-------"}, "text": "ADIS     TITLE 'ADIS - DISPLAY TSO/E AUTH TABLES CREATED BY PARMLIB. '\n         SPACE 1\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*  Documentation:   This program is meant to be run as a TSO          *\n*                   command.  Not APF Authorized.  It displays the    *\n*                   incore TSO/E Auth Tables created by the IKJTSOxx  *\n*                   member of PARMLIB.  Read-only.                    *\n*                                                                     *\n*    Environment:   TSO command, NOT APF-Authorized.                  *\n*                   PUTLINE interface enabled by APUT, EPUTL.         *\n*                   This program is non-reentrant.                    *\n*                   This is a \"harmless\" version of ASUB.             *\n*                                                                     *\n*    Description    Display an Auth Table entry from the TSO/E        *\n*     and           program list tables in storage.  The entire       *\n*      Function :   table is shown, unless you enter a number,        *\n*                   and then, only that slot is shown.  Only          *\n*                   tables manufactured from PARMLIB entries are      *\n*                   displayed, not the ones created from the          *\n*                   IKJTABLS load module in LPALIB.                   *\n*                                                                     *\n*                                                                     *\n*         Syntax:   ADIS ttD \u00ddnnn\u00a8                                    *\n*                                                                     *\n*                   Where tt is a table code, and D is the action     *\n*                   code that tells the program to \"display\".         *\n*                                                                     *\n*                   The table code is a nickname for any of the       *\n*                   TSO/E auth tables which are incore.  They are:    *\n*                                                                     *\n*                   E2 - IKJEFTE2 = AUTHCMD                           *\n*                   E8 - IKJEFTE8 = AUTHPGM                           *\n*                   AP - IKJEFTAP = AUTHTSF                           *\n*                   NS - IKJEFTNS = NOTBKGND                          *\n*                   PC - FCVE     = PLATCMD                           *\n*                   PP - PPVE     = PLATPGM                           *\n*                                                                     *\n*                                                                     *\n*                   If the PLATCMD or PLATPGM keywords (and at least  *\n*                   one name) were not coded in the active IKJTSOxx   *\n*                   PARMLIB entry, then there is no control block of  *\n*                   names to be pointed to, and therefore no display  *\n*                   of names can be made.  The condition is reported  *\n*                   in a message.                                     *\n*                                                                     *\n*             Note:  If an E2, E8, AP, or NS table which is being     *\n*                    used by the system, did not come from the        *\n*                    IKJTSOxx PARMLIB entry, but it came from the     *\n*                    default IKJTABLS entry in LPALIB, then an        *\n*                    appropriate error message is displayed, and      *\n*                    no display is performed for that table.          *\n*                                                                     *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*  Change Log:                                                        *\n*    2008/05/15 - 1.0 - Initial version - Got it to work.             *\n*                                                                     *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*       I N S T R E A M    M A C R O S                                *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*  ---------------------------------------------------------------  *\n*    This macro is used to display hex values in a printed report.\n*  ---------------------------------------------------------------  *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n         SPACE 1\n         YREGS\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n         MACRO\n&NAME    HEX   &TO,&LEN,&FROM\n&NAME    DS    0H\n         STM   R15,R1,HEXSAVE\n         LA    R1,&FROM\n         LA    R0,&LEN\n         LA    R15,&TO\n         BAL   R9,HEX\n         LM    R15,R1,HEXSAVE\n         MEND\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n* ------------------------------------------------------------------- *\n         MACRO\n&LABEL   APUT  &MSG,                    @MESSAGE TEXT                  &\n               &LEN,                    @LENGTH OF MESSAGE             &\n               &RSA=,                   OPTIONAL 2 WORD SAVE AREA      &\n               &EPA=                    EPUTL EPA\n.*\n.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*\n.*  --> E@PUT\n.*\n.*  THIS MACRO SETS UP A PARAMETERS AND INVOKES THE EPUTL ROUTINE.\n.*\n.*\n.*  ARGUMENTS: -----------------------------------------------------\n.*\n.*      &MSG : ADDRESS OF MESSAGE TEXT OR A LITERAL\n.*\n.*      &LEN : LENGTH OF MESSAGE TEXT (DEFAULT IS L'&MSG)\n.*\n.*      &RSA :(OPTIONAL) 1 WORD SAVE AREA TO PRESERVE R14 FOR TPUT\n.*            COMPATIBILITY.\n.*\n.*      &EPA :(OPTIONAL) EPA FOR EPUTL ROUTINE\n.*\n.*\n.*   EXAMPLES: -----------------------------------------------------\n.*\n.*      1) APUT  'LITERAL'\n.*\n.*      2) APUT  (R3),80\n.*\n.*      3) APUT  LABEL\n.*\n.*      4) APUT  LABEL,40\n.*\n.*\n.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*\n.*\n.*  LOCAL SET SYMBOLS\n.*\n         LCLC  &SMA                     MESSAGE ADDRESS (REG)\n         LCLC  &SML                     MESSAGE LENGTH (REG)\n         LCLC  &SEP                     EPA (REGISTER)\n.*\n         LCLC  &L1,&L2,&L3              LOCAL LABELS\n.*\n&L1      SETC  'EP'.'&SYSNDX'.'L1'      LOCAL LABELS\n&L2      SETC  'EP'.'&SYSNDX'.'L2'      LOCAL LABELS\n&L3      SETC  'EP'.'&SYSNDX'.'L3'      LOCAL LABELS\n.*\n.*\n.*  MESSAGE ADDRESS\n.*\n         AIF   (T'&LABEL EQ 'O').A0500                      *HMD 11/86*\n.*                                                          *HMD 11/86*\n&LABEL   DS    0H                                           *HMD 11/86*\n.*                                                          *HMD 11/86*\n.A0500   ANOP                                               *HMD 11/86*\n         AIF   ('&MSG' NE '').A2000\n         MNOTE 8,'''&MSG='' MISSING / REQUIRED'\n         MEXIT\n.*\n.A2000   ANOP\n         AIF   ('&MSG'(1,1) NE '(').A2400\n&SMA     SETC  '&MSG'(2,K'&MSG-2)\n         LR    R1,&SMA                  @MESSAGE TEXT\n         AGO   .A2600\n.*\n.A2400   ANOP\n         AIF   ('&MSG'(1,1) NE '''').A2500\n         B     &L3                      BRANCH AROUND MESSAGE\n&L2      DC    C&MSG\n&L3      DS    0H\n         LA    R1,&L2                   @MESSAGE\n         AGO   .A2600\n.*\n.A2500   ANOP\n         LA    R1,&MSG                  @MESSAGE TEXT\n.A2600   ANOP\n.*\n.*  MESSAGE LENGTH\n.*\n         AIF   ('&LEN' NE '').A3000\n         AIF   ('&MSG'(1,1) NE '''').A2800\n         LA    R0,L'&L2                 MESSAGE LENGTH\n         AGO   .A3600\n.*\n.A2800   ANOP\n         AIF   ('&MSG'(1,1) EQ '(').A2900\n         LA    R0,L'&MSG                MESSAGE LENGTH\n         AGO   .A3600\n.*\n.A2900   ANOP\n         MNOTE 8,'''LEN'' MISSING / REQUIRED'\n         MEXIT\n.*\n.A3000   ANOP\n         AIF   ('&LEN'(1,1) NE '(').A3400\n&SML     SETC  '&LEN'(2,K'&LEN-2)\n         LR    R0,&SML                  MESSAGE LENGTH\n         AGO   .A3600\n.*\n.A3400   ANOP\n         LA    R0,&LEN                  MESSAGE LENGTH\n.A3600   ANOP\n.*\n.*  RSA\n.*\n         AIF   ('&RSA' EQ '').A4900\n         ST    R14,&RSA                 SAVE REGS 14\n.A4900   ANOP\n.*\n.*  ENTRY POINT\n.*\n         AIF   ('&EPA' NE '').A5000\n         L     R15,=V(EPUTL)            EPA\n         AGO   .A5600\n.*\n.A5000   AIF   ('&EPA'(1,1) NE '(').A5400\n&SEP     SETC  '&EPA'(2,K'&EPA-2)\n         LR    R15,&SEP                 EPA\n         AGO   .A5600\n.*\n.A5400   ANOP\n         L     R15,&EPA                 EPA\n.*\n.A5600   ANOP\n.*\n.*  CALL LINKAGE\n.*\n.ACALL   BALR  R14,R15                  CALL PUTLINE ROUTINE\n.*\n         AIF   ('&RSA' EQ '').A6900\n         L     R14,&RSA                 RESTORE R14\n.A6900   ANOP\n.*\n.AMEND   MEND\n* ------------------------------------------------------------------- *\nADIS     CSECT\nADIS     AMODE 31\nADIS     RMODE 24\n         USING *,R15                                                  *  01493\n         B     BEGINN                   Eyecatcher\n         DC    CL15'ADIS VER 1.0 -'\n         DC    CL16' &SYSDATE &SYSTIME '\nBEGINN   DS    0H\n         DROP  R15\n         USING ADIS,R12,R11,R10\n         STM   R14,R12,12(R13)\n         LR    R12,R15                  Set up base registers.\n         ST    R1,SAVEPARM              Save CPPL pointer\n         LA    R11,4095(,R12)\n         LA    R11,1(,R11)\n         LA    R10,4095(,R11)\n         LA    R10,1(,R10)\n         LA    R1,SAVEAREA          Point to new save area               01508\n         ST    R1,8(,R13)           Forward save area chain pointer      01509\n         ST    R13,4(,R1)           Backward save area chain pointer     01510\n         LR    R13,R1               New save area address                01511\n         B     INITCON              Branch past save area\n         SPACE 1\n* -----------------------\nSAVEAREA DC    18F'0'                                                    01504\n* -----------------------\nINITCON  DS    0H                   Initialize constants\n         MVI   OFFFLAG,X'00'\n         MVI   PLATFLG,X'00'\n         MVI   NSCHFLG,X'00'\n         MVI   LINEB,X'40'\n         MVC   CODEPLAC(2),BLANKS\n         XC    FSTCOUNT,FSTCOUNT\n         XC    FSTNOUNT,FSTNOUNT\n         MVC   FSTFIELD(8),BLANKS\n         MVI   BLANKS-1,X'40'\n         MVC   BLANKS,BLANKS-1\n         XC    SLOTBIN,SLOTBIN\n         MVC   SLOTSAVE,BLANKS\n         MVC   FSTNAME,BLANKS\n         MVI   CMDBCOPY-1,X'00'\n         MVC   CMDBCOPY,CMDBCOPY-1\n* -----------------------\n         L     R2,16               POINT TO CVT.\n         L     R2,0(,R2)           POINT TO TCB/ASCB WORDS\n         L     R2,4(,R2)           POINT TO TCB.\n         L     R2,X'B4'(,R2)       POINT TO JSCB.\n         L     R2,X'108'(,R2)      POINT TO PSCB.\n         LA    R2,0(,R2)           CLEAR HIGH BYTE.\n         LTR   R2,R2               ANY PSCB?\n         BZ    EOJ4                GET OUT.  NOT TSO.\n         L     R1,SAVEPARM         Get the address of the CPPL back\n         USING CPPL,R1\n         L     R0,CPPLUPT          Copy CPPL fields for possible\n         ST    R0,SAVEUPT            later use, if needed.\n         L     R0,CPPLPSCB\n         ST    R0,SAVEPSCB\n         L     R0,CPPLECT\n         ST    R0,SAVEECT\n         LA    R6,0\n         DROP  R1\n         BAL   R9,PGMTITLE         First display the program title.\n         USING PSCB,R2\nCHEKAUTH DS    0H\n*        B     CONT0               Bypass authorization check\n         TM    PSCBATR1,PSCBACCT   ACCT user?\n         BO    CONT0               Yes.  Continue.\n         TM    PSCBATR1,PSCBCTRL   OPER user?\n         BZ    EOJ4                No.  Get out.\n         DROP  R2\nCONT0    DS    0H                  Get starting addresses for tables\n         L     R2,16               Point to CVT\n         L     R2,X'9C'(,R2)       Point to TSVT (TSO Vector Table)\n         L     R2,X'4C'(,R2)       Point to TPVT\n         ST    R2,SAVETPVT         Save TPVT address for later use\n         L     R2,X'14'(,R2)       Point to CTLT control block\n         ST    R2,SAVECTLT         Save CTLT address for later use\n         L     R2,SAVETPVT         Load TPVT address back\n         L     R2,X'34'(,R2)       Point to PLATCMD pointer\n         LTR   R2,R2               Is there any?\n         BZ    NOFCVE              No. Say so.\n         ST    R2,SAVEFCVE         Yes. Store the FCVE pointer away.\n         OI    PLATFLG,X'01'       Indicate that FCVE exists.\nTRYPPVE  DS    0H\n         L     R2,SAVETPVT         Load TPVT address back\n         L     R2,X'40'(,R2)       Point to PLATPGM pointer\n         LTR   R2,R2               Is there any?\n         BZ    NOPPVE              No. Say so.\n         ST    R2,SAVEPPVE         Yes. Store the PPVE pointer away.\n         OI    PLATFLG,X'02'       Indicate that PPVE exists.\nTRYPPVEE DS    0H\n* ------\n*    There doesn't seem to be a way to tell from an old INMXPARM\n*    control block itself, that it is the old version.  So we use\n*    the position of the active PARMLIB member name in the TPVT.\n* ------\n         L     R2,SAVETPVT         Load TPVT address back.\n         CLC   =C'IKJ',7(R2)       Parmlib member name in old position?\n         BNE   NEWSYSTM            No. It's a new TSO/E version\n         OI    OLDFLAG,X'01'       Yes. Flag that the system is old.\nNEWSYSTM DS    0H\n* ------\n*    We start scanning for PARMs here.\n* ------\n         L     R1,SAVEPARM         Original R1 from entry to program.\n         LTR   R1,R1               Any CPPL?\n         BZ    EOJ8                No. Get out.\n         L     R1,0(,R1)           Point to Command Buffer\n         LTR   R1,R1               Any Command Buffer?\n         BZ    EOJ4                Get out if none.\n         LH    R3,0(,R1)           Load length.\n         CH    R3,=H'4'            Anything?\n         BNH   EOJ4                No.  Get out.\n         LR    R5,R3               Length of command + 4\n         ICM   R5,14,FULLZERO      Clear high order 3 bytes.\n         ST    R1,CMBUFAD          Save Command Buffer Address\n         LH    R3,2(,R1)           Load offset.\n         ST    R3,OFFSETSV\n         SR    R5,R3               Subtract offset from full length+4\n         SH    R5,=H'4'            Correct for length of CMDBUFR header\n*                                  in the command buffer.\n         BC    8,EOJC              Zero, Message\n         BC    5,EOJC              Less, or overflow, out.\n         ST    R5,CMBUFEND         Store away the number of bytes left\n         L     R1,CMBUFAD          Load Command Buffer Address\n*\n* ----  Copy command buffer into pgm's buffer so we can control it.\n*\n         STM   R14,R1,SAVE1401     Now save registers 14 thru 1.\n         XR    R14,R14             Clear R14.\n         LH    R14,0(,R1)          Load full command buffer length.\n         S     R14,=F'5'           Subtract 4 for header, 1 for execute\n         EX    R14,COPYCMDB        Copy command into pgm's area.\n         LM    R14,R1,SAVE1401     Restore registers 14 thru 1.\n         B     GOGOGO              Jump over executed instruction.\nCOPYCMDB MVC   CMDBCOPY(0),4(R1)   <<< Executed >>>\nGOGOGO   DS    0H\n* ----\n         LA    R6,3                Load register for BCT loop.\n* >>>\n         LA    R1,CMDBCOPY         Point to command in our buffer\n         A     R1,OFFSETSV         Add offset, point to subcommands\n         ST    R1,CHARSTRT         Store starting point away\n* >>>\n         LR    R7,R1               Initialize pointer\n         LA    R7,0(,R7)           to first character of function name.\n         LA    R8,0                Initialize character count\nCUTIDLEN CLI   0(R7),X'40'         Is this character a blank?\n         BE    AFTFIRST            Yes, end of the first parm.\n         CLI   0(R7),X'00'         Is this character hex zero?\n         BE    AFTFIRST            Yes, end of command in buffer copy.\n         LA    R7,1(,R7)           Bump another character\n         LA    R8,1(,R8)           Count another character\n         CR    R8,R5               End of command buffer ?\n         BNL   AFTFIRST            Yes. Get out now.\n         BCT   R6,CUTIDLEN         Try for blank again.\nAFTFIRST DS    0H\n         MVC   TABCODE(8),BLANKS   Clear field\n         BCTR  R8,0                Subtract 1 for execute.\n         L     R1,CHARSTRT         Reload R1 to be sure it's correct.\n         EX    R8,MOVOUTL          Move entered parameter to program.\n         LA    R8,1(,R8)           Restore number of characters\n         AR    R1,R8               Point past last search\n         ST    R1,CHARCONT         Continue from here\n         ST    R8,SAVER8           Save\n         ST    R6,SAVER6             the\n         ST    R1,SAVER1A              registers\n* ---- >\nSEEIFPRM DS    0H                  Check if a command is here\n         OC    TABCODE(3),BLANKS   Uppercase. Won't affect numbers\n         CLI   TABCODE+2,C'D'      Display contents of last slot\n         BE    SEEIF0A3\n         B     SEEIF000\nSEEIF0A3 DS    0H\n         OI    OFFFLAG,X'04'       Display an entry or entries\n         B     SEEIF001\nSEEIF000 DS    0H                  Wrong function code was entered...\n* --- >                            Display what we entered, plus code\n         MVC   LINE,LINEB          Clear line\n         MVC   LINE(3),TABCODE     Move code in\n*        HEX   LINE+6,1,OFFFLAG    Display contents of flag\n         MVC   LINE+13(35),=C'Table code | Action code   entered.'\n         APUT  LINE,48\n* --- >\n         BAL   R9,ERRORCOD         Indicate error and display syntax.\n         B     EOJ4                Get out with code = 4.\nSEEIF001 DS    0H                  Which table to display\n         MVC   CODEPLAC(2),TABCODE\n* --- >                            Display what we entered, plus code\n         MVC   LINE,LINEB          Clear line\n         MVC   LINE(3),TABCODE     Move code in\n*        HEX   LINE+6,1,OFFFLAG    Display contents of flag\n         MVC   LINE+13(35),=C'Table code | Action code   entered.'\n         APUT  LINE,48\n         MVC   LINE,LINE-1         Write a blank line.\n         APUT  LINE,30\n* --- >                            Handle each table separately.\n         CLC   TABCODE(2),=C'E2'   Display IKJEFTE2?\n         BE    E2CHANGE            Yes. Branch.\n         CLC   TABCODE(2),=C'E8'   Display IKJEFTE8?\n         BE    E8CHANGE            Yes. Branch.\n         CLC   TABCODE(2),=C'AP'   Display IKJEFTAP?\n         BE    APCHANGE            Yes. Branch.\n         CLC   TABCODE(2),=C'PC'   Display PLATCMD?\n         BE    PCCHANGE            Yes. Branch.\n         CLC   TABCODE(2),=C'PP'   Display PLATPGM?\n         BE    PPCHANGE            Yes. Branch.\n         CLC   TABCODE(2),=C'NS'   Display IKJEFTNS?\n         BE    NSCHANGE            Yes. Branch.\n         BAL   R9,ERRORCOD         Indicate error and display syntax.\n         B     EOJ4                Invalid code entered.\nEOJ      DS    0H                  END OF JOB                            04216\n         L     R13,4(,R13)                                               04214\n         LR    R15,R5              Put in real return code\n         ST    R15,16(,R13)        Shove it where it belongs\n         L     R14,12(,R13)        R14 and\n         LM    R0,R12,20(R13)        rest of registers\n         BR    R14                 Go back to caller\nEOJ0     DS    0H                  Return code 0\n         MVC   LINE,LINE-1         Clear output area\n         MVC   LINE,MESSAGR0       Show Return Code 0\n         APUT  MESSAGR0,L'MESSAGR0\n         LA    R5,0                Set CC = 0\n         B     EOJ                 Now end the program\nEOJ4     DS    0H                  Return code 4\n         MVC   LINE,LINE-1         Clear output area\n         MVC   LINE,MESSAGR4       Show Return Code 4\n         APUT  LINE,L'MESSAGR4\n         L     R5,FULLFOUR         Set CC = 4                            04215\n         B     EOJ                 Now end the program\nEOJ8     DS    0H                  Return code 8\n         MVC   LINE,LINE-1         Clear output area\n         MVC   LINE,MESSAGR8       Show Return Code 8\n         APUT  LINE,L'MESSAGR8\n         L     R5,FULLEIGT         Set CC = 8                            04215\n         B     EOJ                 Now end the program\nEOJC     DS    0H                  Return code 12\n         MVC   LINE,LINE-1         Clear output area\n         MVC   LINE,MESSA11Q       Show Return Code 12\n         APUT  LINE,L'MESSA11Q\n         BAL   R9,ERRORCOD\n         MVC   LINE,LINE-1         Clear output area\n         MVC   LINE,MESSAGRC       Show Return Code 12\n         APUT  LINE,L'MESSAGRC\n         L     R5,FULLTWLV         Set CC = 12\n         B     EOJ                 Now end the program\n** ---------------------------------------------------------------- **\nE2CHANGE DS    0H                 Handle the E2 table\n         BAL   R9,ADJNEXTP\n         BAL   R9,NAMEPARM\n         L     R2,SAVECTLT\n         LR    R4,R2\n         LA    R4,X'8'(,R4)       POINT TO E2 TABLE\n         L     R4,0(,R4)\n* - -\n         ST    R4,TABLSTRT        Store start address of table\n         L     R1,TABLSTRT\n**-->>\n         CLC   =C' PARMLIB',8(R1) Indicator this table is from PARMLIB.\n         BE    E2CHENTY           It is, then we're cool.\n         BAL   R9,MISSPGM3        It isn't, then send message saying so\n         B     EOJ4               And exit with code = 4.\nE2CHENTY DS    0H                 Table was made from a IKJTSOxx entry.\n**-->>\n         LA    R1,X'10'(,R1)      Bump past header\n         ST    R1,TABLSTRT        Store new start address\n* - -\n         L     R3,X'C'(,R2)       LOAD SIZE OF E2 TABLE\n         LTR   R3,R3              Is there any Parmlib-supplied one?\n         BZ    NOE2               No. Say so and get out.\n         AR    R4,R3              POINT JUST PAST E2 TABLE\n* - -\n         XR    R5,R5\n         LH    R5,X'10'(,R2)      Load number of entries in table\n         ST    R5,TABLENUM        Store number of entries\n* - -\n         XR    R5,R5\n         LH    R5,X'12'(,R2)      LOAD SIZE OF E2 ENTRY\n* - -\n         ST    R5,TABLESIZ        Store size of each entry\n* - -\n         SR    R4,R5              POINT TO LAST SLOT\n         ST    R4,SAVLSLOT\n         TM    OFFFLAG,X'04'      Is this just a contents display?\n         BZ    E2CHANGX           No. We must do a real change.\n         BAL   R9,DISPTABL        Yes. Just display.\n         B     EOJ0\nE2CHANGX DS    0H\n         BAL   R9,DISPTABL        Search table for the proper entry.\n         B     EOJ0\nE8CHANGE DS    0H                 Handle the E8 table\n         BAL   R9,ADJNEXTP\n         BAL   R9,NAMEPARM\n         L     R2,SAVECTLT\n         LR    R4,R2\n         LA    R4,X'14'(,R4)      POINT TO E8 TABLE\n         L     R4,0(,R4)\n* - -\n         ST    R4,TABLSTRT        Store start address of table\n         L     R1,TABLSTRT\n**-->>\n         CLC   =C' PARMLIB',8(R1) Indicator this table is from PARMLIB.\n         BE    E8CHENTY           It is, then we're cool.\n         BAL   R9,MISSPGM3        It isn't, then send message saying so\n         B     EOJ4               And exit with code = 4.\nE8CHENTY DS    0H                 Table was made from a IKJTSOxx entry.\n**-->>\n         LA    R1,X'10'(,R1)      Bump past header\n         ST    R1,TABLSTRT        Store new start address\n* - -\n         L     R3,X'18'(,R2)      Size of E8 table\n         LTR   R3,R3              Is there any Parmlib-supplied one?\n         BZ    NOE8               No. Say so and get out.\n         AR    R4,R3              POINT JUST PAST E8 TABLE\n* - -\n         XR    R5,R5\n         LH    R5,X'1C'(,R2)      Load number of entries in table\n         ST    R5,TABLENUM        Store number of entries\n* - -\n         XR    R5,R5\n         LH    R5,X'1E'(,R2)      LOAD SIZE OF E8 ENTRY\n* - -\n         ST    R5,TABLESIZ        Store size of each entry\n* - -\n         SR    R4,R5              POINT TO LAST SLOT\n         ST    R4,SAVLSLOT\n         TM    OFFFLAG,X'04'      Is this just a contents display?\n         BZ    E8CHANGX           No. We must do a real change.\n         BAL   R9,DISPTABL        Yes. Just display.\n         B     EOJ0\nE8CHANGX DS    0H\n         BAL   R9,DISPTABL        Search table for the proper entry.\n         B     EOJ0\nAPCHANGE DS    0H                 Handle the AP table\n         BAL   R9,ADJNEXTP\n         BAL   R9,NAMEPARM\n         L     R2,SAVECTLT\n         LR    R4,R2\n         LA    R4,X'2C'(,R4)      POINT TO AP TABLE\n         L     R4,0(,R4)\n* - -\n         ST    R4,TABLSTRT        Store start address of table\n         L     R1,TABLSTRT\n**-->>\n         CLC   =C' PARMLIB',8(R1) Indicator this table is from PARMLIB.\n         BE    APCHENTY           It is, then we're cool.\n         BAL   R9,MISSPGM3        It isn't, then send message saying so\n         B     EOJ4               And exit with code = 4.\nAPCHENTY DS    0H                 Table was made from a IKJTSOxx entry.\n**-->>\n         LA    R1,X'10'(,R1)      Bump past header\n         ST    R1,TABLSTRT        Store new start address\n* - -\n         L     R3,X'30'(,R2)      Size of AP table\n         LTR   R3,R3              Is there any Parmlib-supplied one?\n         BZ    NOAP               No. Say so and get out.\n         AR    R4,R3              POINT JUST PAST AP TABLE\n* - -\n         XR    R5,R5\n         LH    R5,X'34'(,R2)      Load number of entries in table\n         ST    R5,TABLENUM        Store number of entries\n* - -\n         XR    R5,R5\n         LH    R5,X'36'(,R2)      LOAD SIZE OF AP ENTRY\n* - -\n         ST    R5,TABLESIZ        Store size of each entry\n* - -\n         SR    R4,R5              POINT TO LAST SLOT\n         ST    R4,SAVLSLOT\n         TM    OFFFLAG,X'04'      Is this just a contents display?\n         BZ    APCHANGX           No. We must do a real change.\n         BAL   R9,DISPTABL        Yes. Just display.\n         B     EOJ0\nAPCHANGX DS    0H\n         BAL   R9,DISPTABL        Search table for the proper entry.\n         B     EOJ0\nPCCHANGE DS    0H                 Handle the PC table\n         TM    PLATFLG,X'01'\n         BZ    PCCHAERR\n         BAL   R9,ADJNEXTP\n         BAL   R9,NAMEPARM\n         L     R2,SAVEFCVE        Get the PC table address\n         LR    R4,R2              Save it off\n* -- >                            Do Display\n         MVC   LINE,LINE-1\n         ST    R4,DISPREG\n         HEX   LINE+13,4,DISPREG\n         MVC   LINE(8),=C'SAVEFCVE'\n         APUT  LINE,30\n* -- >\n         L     R3,X'8'(,R4)\n         AR    R4,R3              POINT JUST PAST PC TABLE\n* - -\n         L     R3,X'C'(,R2)\n         ST    R3,TABLENUM\n         LA    R3,8\n         ST    R3,TABLESIZ\n         L     R3,SAVEFCVE\n         LA    R3,X'10'(,R3)\n         ST    R3,TABLSTRT\n* - -\n         LA    R5,8\n         SR    R4,R5              POINT TO LAST SLOT\n         ST    R4,SAVLSLOT\n         TM    OFFFLAG,X'04'      Is this just a contents display?\n         BZ    PCCHANGX           No. We must do a real change.\n         BAL   R9,DISPTABL        Yes. Just display.\n         B     EOJ0\nPCCHANGX DS    0H\n         BAL   R9,DISPTABL        Search table for the proper entry.\n         B     EOJ0\nPCCHAERR DS    0H\n         MVC   LINE,LINE-1\n         MVC   LINE(43),=C'PC command not valid if no PC table exists.'\n         APUT  LINE,43\n         B     EOJ4\nPCCHAEND DS    0H\n         B     EOJ0\nPPCHANGE DS    0H                 Handle the PP table\n         TM    PLATFLG,X'02'\n         BZ    PPCHAERR\n         BAL   R9,ADJNEXTP\n         BAL   R9,NAMEPARM\n         L     R2,SAVEPPVE        Get the PP table address\n         LR    R4,R2              Save it off\n* -- >                            Do Display\n         MVC   LINE,LINE-1\n         ST    R4,DISPREG\n         HEX   LINE+13,4,DISPREG\n         MVC   LINE(8),=C'SAVEPPVE'\n         APUT  LINE,30\n* -- >\n         L     R3,X'8'(,R4)\n         AR    R4,R3              POINT JUST PAST PP TABLE\n* - -\n         L     R3,X'C'(,R2)\n         ST    R3,TABLENUM\n         LA    R3,8\n         ST    R3,TABLESIZ\n         L     R3,SAVEPPVE\n         LA    R3,X'10'(,R3)\n         ST    R3,TABLSTRT\n* - -\n         LA    R5,8\n         SR    R4,R5              POINT TO LAST SLOT\n         ST    R4,SAVLSLOT\n         TM    OFFFLAG,X'04'      Is this just a contents display?\n         BZ    PPCHANGX           No. We must do a real change.\n         BAL   R9,DISPTABL        Yes. Just display.\n         B     EOJ0\nPPCHANGX DS    0H\n         BAL   R9,DISPTABL        Search table for the proper entry.\n         B     EOJ0\nPPCHAERR DS    0H\n         MVC   LINE,LINE-1\n         MVC   LINE(43),=C'PP command not valid if no PP table exists.'\n         APUT  LINE,43\n         B     EOJ4\nPPCHAEND DS    0H\n         B     EOJ0\nNSCHANGE DS    0H                 Handle the NS table\n         BAL   R9,ADJNEXTP\n         BAL   R9,NAMEPARM\n         L     R2,SAVECTLT\n         OI    NSCHFLG,X'01'      Show DISPTABL we're doing NS\n         LR    R4,R2              Save location of CTLT\n         LA    R4,X'20'(,R4)      Point to NS table address\n         L     R4,0(,R4)          Point to NS table\n* - -\n         ST    R4,TABLSTRT        Store start address of table\n         L     R1,TABLSTRT\n**-->>\n         CLC   =C' PARMLIB',8(R1) Indicator this table is from PARMLIB.\n         BE    NSCHENTY           It is, then we're cool.\n         BAL   R9,MISSPGM3        It isn't, then send message saying so\n         B     EOJ4               And exit with code = 4.\nNSCHENTY DS    0H                 Table was made from a IKJTSOxx entry.\n**-->>\n         LA    R1,X'10'(,R1)\n         ST    R1,TABLSTRT        Store new start address\n* - -\n         L     R3,X'24'(,R2)      Load size of NS table\n         LTR   R3,R3              Is there any Parmlib-supplied one?\n         BZ    NONS               No. Say so and get out.\n         AR    R4,R3              Point just past NS table\n* - -\n         XR    R5,R5\n         LH    R5,X'28'(,R2)      Load number of entries in table\n         ST    R5,TABLENUM        Store number of entries\n* - -\n         XR    R5,R5              Clear register\n         LH    R5,X'2A'(,R2)      Load size of NS entry\n* - -\n         ST    R5,TABLESIZ        Store size of each entry\n* - -\n         SR    R4,R5              Point to Last Slot\n         ST    R4,SAVLSLOT        Save location of last slot\n         TM    OFFFLAG,X'04'      Is this just a contents display?\n         BZ    NSCHANGX           No. We must do a real change.\n         BAL   R9,DISPTABL        Yes. Just display.\n         B     EOJ0\nNSCHANGX DS    0H\n         BAL   R9,DISPTABL        Search table for the proper entry.\n         B     EOJ0\nNOE2     DS    0H                 No Parmlib-supplied table there.\n         MVC   LINE,LINE-1\n         MVC   LINE(L'MESSAGEP),MESSAGEP\n         MVC   LINE+20(2),=C'E2'\n         APUT  LINE,L'MESSAGEP\n         B     EOJ4\nNOE8     DS    0H                 No Parmlib-supplied table there.\n         MVC   LINE,LINE-1\n         MVC   LINE(L'MESSAGEP),MESSAGEP\n         MVC   LINE+20(2),=C'E8'\n         APUT  LINE,L'MESSAGEP\n         B     EOJ4\nNOAP     DS    0H                 No Parmlib-supplied table there.\n         MVC   LINE,LINE-1\n         MVC   LINE(L'MESSAGEP),MESSAGEP\n         MVC   LINE+20(2),=C'AP'\n         APUT  LINE,L'MESSAGEP\n         B     EOJ4\nNONS     DS    0H                 No Parmlib-supplied table there.\n         MVC   LINE,LINE-1\n         MVC   LINE(L'MESSAGEP),MESSAGEP\n         MVC   LINE+20(2),=C'NS'\n         APUT  LINE,L'MESSAGEP\n         B     EOJ4\nNOFCVE   DS    0H\n         APUT  =C'No FCVE found.  PC is an invalid table code now.',48\n         B     TRYPPVE\nNOPPVE   DS    0H\n         APUT  =C'No PPVE found.  PP is an invalid table code now.',48\n         B     TRYPPVEE\n         B     EOJ0\nNOTNUMER DS    0H\n         MVC   LINE,LINE-1\n         MVC   LINE(L'MESSAGEN),MESSAGEN\n         MVC   LINE+21(1),0(R7)\n         APUT  LINE,L'MESSAGEN\n         B     EOJ4\n** ---------------------------------------------------------------- **\nSAVEPARM DC    F'0'\nSAVETPVT DC    F'0'\nSAVECTLT DC    F'0'\nSAVEFCVE DC    F'0'\nSAVEPPVE DC    F'0'\nSAVEUPT  DC    F'0'\nSAVEECT  DC    F'0'\nSAVEPSCB DC    F'0'\n** ---------------------------------------------------------------- **\nFULLZERO DC    F'0'\nFULLFOUR DC    F'4'\nFULLEIGT DC    F'8'\nFULLTWLV DC    F'12'\nSAVE1401 DC    5F'0'                  More for safety\n* - - - - - - - - - - - - - - - - - - - - - - - - *\nMOVOUTL  MVC   TABCODE(*-*),0(R1)     EXECUTED\nMOVFSTN  MVC   FSTNAME(*-*),0(R3)     EXECUTED\nMOVSNDN  MVC   SNDNAME(*-*),0(R1)     EXECUTED\nMOVFNUM  MVC   FSTNUME(*-*),0(R3)     EXECUTED\nPACK     PACK  WORKA,0(0,3)          <<< EXECUTED >>>                    06758\n** ---------------------------------------------------------------- **\n* - - - - - - - - - - - - - - - - - - - - - - - - *\n*            S U B R O U T I N E S                *\n* - - - - - - - - - - - - - - - - - - - - - - - - *\nHEX      DS    0H\n         ST    R9,SAVER9A\n         MVC   1(1,R15),0(R1)        Move byte\n         UNPK  0(3,R15),1(2,R15)     Unpack\n         TR    0(2,R15),HEXTAB-240\n         LA    R15,2(,R15)           Increment output pointer\n         LA    R1,1(,R1)             Increment input pointer\n         BCT   R0,HEX                Decrement length, then loop\n         MVI   0(R15),C' '           Blank the trailing byte\n         L     R9,SAVER9A\n         BR    R9                    Return to caller\nHEXTAB   DC    C'0123456789ABCDEF'   Translate table\nHEXSAVE  DS    3F                    Register save for HEX macro\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nGETNAMES DS    0H\n         ST    R9,SAVER9B\nGETNAMST DS    0H                  Get rid of leading blanks\n         L     R1,CHARCONT         Point to start of character\n         CLI   0(R1),X'40'         Is it a blank?\n         BNE   GETNAMNZ            No. Get the entire name.\n         LA    R1,1(,R1)           Yes. Bump start place one up.\n         ST    R1,CHARCONT         And store the place away for now.\n         C     R5,=F'1'            End of cmd buffer one away?\n         BNH   EOJ4                Yes. Error.\n         BCTR  R5,0                Subtract one from end count\n         B     GETNAMST            And loop to find first non-blank.\nGETNAMNZ DS    0H                  Got first non-blank. Get whole name.\n         LA    R6,8                BCT initial quantity - 8 chars.\n         LA    R8,0                Character count\n         L     R1,CHARCONT         Load starting place\n         LR    R7,R1               Initialize pointer\n         LA    R7,0(,R7)           to first character of program name.\nGETNAMLU DS    0H                  Loop to get entire name\n         CLI   0(R7),X'40'         First blank?\n         BE    GETNAMGT            Yes, got whole name.\n         CLI   0(R7),X'00'         First hex zeros?\n         BE    GETNAMGT            Yes, got whole name.\n         CR    R8,R5               End of command buffer?\n         BNL   GETNAMGT            Yes. Got all we can get.\n         LA    R8,1(,R8)           Bump character counter.\n         LA    R7,1(,R7)           Bump where we are.\n         BCT   R6,GETNAMLU         Loop back.\nGETNAMGT DS    0H\n         ST    R8,SAVER8\n         ST    R8,FSTCOUNT\n         CLC   SAVER8,=F'0'\n         BNE   GETREALY\n         B     EOJ4\nGETREALY DS    0H\n         MVC   FSTCHALF(2),FSTCOUNT+2\n         MVC   LINE,LINE-1\n         HEX   LINE,4,SAVER8\n         MVC   LINE+13(17),=C'Length of command'\n         APUT  LINE,30\n         L     R3,CHARCONT\n         BCTR  R8,0                One less for EXECUTE\n         MVC   FSTNAME(8),BLANKS\n         EX    R8,MOVFSTN\n         OC    FSTNAME(8),BLANKS\n         MVC   LINE,LINE-1\n         MVC   LINE(8),FSTNAME\n         MVC   LINE+13(17),=C'New program name '\n         APUT  LINE,30\n* - >\nGETNAMEN DS    0H\n         L     R9,SAVER9B\n         BR    R9\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nNAMEPARM DS    0H\n         ST    R9,SAVER9D\n         TM    OFFFLAG,X'02'          Are we blanking?\n         BO    NAMEPEND               Yes. Don't need a name parameter\n         L     R8,SAVER8              Get number of characters used\n         CR    R8,R5                  More than what's left?\n         BNL   NAMEBAD1               Yes. Error.\n         C     R5,=F'3'               Is end bigger than 3?\n         BNH   NAMEBAD1               No. Error.\nNAMEGOOD DS    0H\n         S     R5,=F'3'               Subtract 3 from number till end.\n         BAL   R9,GETNUMES            Get the number of the pgm entry.\n         TM    OFFFLAG,X'04'          Displaying?\n         BO    NAMEPEND               Yes. No names wanted.\n         BAL   R9,GETNAMES            Get the name of pgm to shove in.\n         B     NAMEPEND\nNAMEBAD1 DS    0H\n         TM    OFFFLAG,X'04'          Are we displaying?\n         BO    NAMEPEND\n         B     EOJ4\nNAMEPEND DS    0H\n         L     R9,SAVER9D\n         BR    R9\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nADJNEXTP DS    0H\n         ST    R9,SAVER9E\n         MVC   CHARSTRT,CHARCONT\n         L     R1,CHARSTRT\nSEEIFENX DS    0H\n         CLI   0(R1),X'40'\n         BE    SEEIFENZ\n         LA    R1,1(,R1)\n         ST    R1,CHARSTRT\n         B     SEEIFENX\nSEEIFENZ DS    0H\n         L     R9,SAVER9E\n         BR    R9\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n         LTORG\n************************************************************\nPGMTITLE DS    0H                     Display program name\n         ST    R9,SAVER9F\n         MVC   LINE,LINE-1            Blank line\n         MVC   LINE,MESSAGET          Move title line in\n         APUT  LINE,L'MESSAGET        And put out to tube\n         MVC   LINE,LINE-1            Blank line again\n         MVC   LINE,MESSAGEU          Move underlines in\n         APUT  LINE,L'MESSAGEU        And put them out also\n         L     R9,SAVER9F\n         BR    R9                     Return to caller\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nERRORCOD DS    0H\n         ST    R9,SAVER9H\n         MVC   LINE,LINE-1\n         APUT  LINE,30\n         APUT  MESSA11L,L'MESSA11L\n         APUT  MESSA11M,L'MESSA11M\n         APUT  MESSA11P,L'MESSA11P\n         APUT  MESSA11A,L'MESSA11A\n         APUT  MESSA11C,L'MESSA11C\n         APUT  MESSA11D,L'MESSA11D\n         APUT  MESSA11I,L'MESSA11I\n         APUT  MESSA11K,L'MESSA11K\n         APUT  MESSA11F,L'MESSA11F\n         MVC   LINE,LINE-1\n         APUT  LINE,30\n         L     R9,SAVER9H\n         BR    R9                     Return to caller\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nMISSPGM3 DS    0H\n         ST    R9,SAVER9K\n         MVC   LINE,LINE-1\n         APUT  MESSA11H,L'MESSA11H\n         L     R9,SAVER9K\n         BR    R9                     Return to caller\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nDISPTABL DS    0H                Scan thru the particular table....\n         ST    R9,SAVER9L          Save BAL register\n         ST    R3,SAVER3A          Save\n         ST    R4,SAVER4A             the\n         ST    R5,SAVER5A                work\n         ST    R6,SAVER6A                   registers.\n         TM    OFFFLAG,X'02'       Are we blanking the last entry?\n         BO    DISPTEND            Yes. Don't have to scan entire table\n         XR    R3,R3               Zero\n         XR    R5,R5                  work\n         XR    R6,R6                     registers.\nDISPTSTR DS    0H\n         L     R3,TABLSTRT         Load start address of table\n         L     R6,TABLENUM         Load number of entries in table\n         L     R5,TABLESIZ         Load size of each entry\n         LA    R4,1                Start slot number count at 1\n         ST    R4,SLOTNOW          Stort slot number count away\n         CLC   SLOTBIN,=F'0'       If there's no slot num in param\n         BE    DISPTLUP            Then bypass error checking\n         C     R6,SLOTBIN          Compare table size to parm number\n         BNL   DISPTLUP            If parm number is LE, then display\nDISPTERR DS    0H                  Else error message and out.\n         MVC   LINE,LINE-1\n         MVC   LINE(22),=C'Slot number specified '\n         L     R1,SLOTBIN          Display field\n         CVD   R1,CVDAREA          Convert count to printable\n         MVC   LINE+22(10),MASK10  Move in the mask\n         ED    LINE+22(10),CVDAREA+3 Make it pretty\n         MVC   LINE+34(26),=C'is bigger than table size '\n         L     R1,TABLENUM         Display field\n         CVD   R1,CVDAREA          Convert count to printable\n         MVC   LINE+60(10),MASK10  Move in the mask\n         ED    LINE+60(10),CVDAREA+3 Make it pretty\n         APUT  LINE,72\n         B     EOJ4\nDISPTLUP DS    0H                  Loop thru the table entries.\n         MVC   LINE,LINE-1\n         MVC   LINE(2),CODEPLAC\n         MVC   LINE+3(19),=C'Table Entry Number:'\n         CVD   R4,CVDAREA          Convert count to printable\n         MVC   LINE+22(10),MASK10  Move in the mask\n         ED    LINE+22(10),CVDAREA+3 Make it pretty\n         TM    NSCHFLG,X'01'       Is this the 10-byte NS table entry?\n         BO    DISPTBNS            Yes. Handle separately.\n         MVC   LINE+34(8),0(R3)\n         CLC   LINE+34(8),BLANKS   Is this a blank entry.\n         BNE   DISPTBLK            No.\n         MVC   LINE+34(8),=C'*empty* '   Yes. Don't just show blanks.\n         B     DISPTBLK\nDISPTBNS DS    0H\n         HEX   LINE+34,2,0(R3)\n         MVC   LINE+40(8),2(R3)\n         CLC   LINE+40(8),BLANKS   Is this a blank entry.\n         BNE   DISPTBLK            No.\n         MVC   LINE+40(8),=C'*empty* '   Yes. Don't just show blanks.\nDISPTBLK DS    0H                  Search each slot number.\n         CLC   SLOTBIN,=F'0'       Has a slot number been specified?\n         BE    DISPTYES            No. Just display all the slots.\n         CLC   SLOTBIN,SLOTNOW     Yes. Then are we at the one we want?\n         BNE   DISPTNOT            No. Just go further and search.\n* ---  Save contents of the current slot which was found - below\n         LR    R1,R5               Load table entry size\n         BCTR  R1,0                One less for execute\n         EX    R1,MOVESLOT         Save contents of slot for kicks\n         ST    R3,OURSLOT          Store its address - important....\n         MVC   TABENNUM(10),MASK10    Save edited version\n         ED    TABENNUM(10),CVDAREA+3    of this slot number\n         B     DISPTPEX               Branch past executed instruction\nMOVESLOT MVC   SLOTSAVE(*-*),0(R3)    EXECUTED\nDISPTPEX DS    0H\n* ---  Save contents of the current slot which was found - above\nDISPTYES DS    0H                  Print this slot entry\n         APUT  LINE,52\nDISPTNOT DS    0H                  Bump to next slot and loop back.\n         LA    R3,0(R5,R3)         Bump to next slot\n         LA    R4,1(,R4)           Bump count of slot number\n         ST    R4,SLOTNOW          Store new slot number away\n         BCT   R6,DISPTLUP         And loop to examine the new slot.\nDISPTEND DS    0H\n         L     R3,SAVER3A          Restore all the work registers.\n         L     R4,SAVER4A\n         L     R5,SAVER5A\n         L     R6,SAVER6A\n         L     R9,SAVER9L          Restore the BAL register.\n         BR    R9                  Return to caller\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nGETNUMES DS    0H\n         ST    R9,SAVER9M\nGETNUMST DS    0H                  Get rid of leading blanks\n         L     R1,CHARCONT         Point to start of character\n         CLI   0(R1),X'40'         Is it a blank?\n         BNE   GETNUMNZ            No. Get the entire name.\n         LA    R1,1(,R1)           Yes. Bump start place one up.\n         ST    R1,CHARCONT         And store the place away for now.\n         C     R5,=F'1'            End of cmd buffer one away?\n         BNH   EOJ4                Yes. Error.\n         S     R5,=F'1'            Subtract one from end count\n         B     GETNUMST            And loop to find first non-blank.\nGETNUMNZ DS    0H                  Got first non-blank. Get whole name.\n         LA    R6,5                BCT initial quantity - 5 chars.\n         LA    R8,0                Character count\n         L     R1,CHARCONT         Load starting place\n         LR    R7,R1               Initialize pointer\n         LA    R7,0(,R7)           to first character of program number\nGETNUMLU DS    0H                  Loop to get entire number\n         CLI   0(R7),X'40'         First blank?\n         BE    GETNUMGT            Yes, got whole number\n         CLI   0(R7),X'00'         First hex zeros?\n         BE    GETNUMGT            Yes, got whole number\n         CR    R8,R5               End of command buffer?\n         BNL   GETNUMGT            Yes. Got all we can get.\n* --\n         CLI   0(R7),X'F0'         Check this parm if numeric.\n         BL    NOTNUMER\n         CLI   0(R7),X'F9'\n         BH    NOTNUMER\n* --\n         LA    R8,1(,R8)           Bump character counter.\n         LA    R7,1(,R7)           Bump where we are.\n         BCT   R6,GETNUMLU         Loop back.\nGETNUMGT DS    0H                  Got the whole number - examine it.\n         ST    R8,SAVER8\n         ST    R8,FSTNOUNT         Get halfword value of slot number\n         MVC   FSTNHALF(2),FSTNOUNT+2\n         L     R3,CHARCONT\n         BCTR  R8,0                One less for EXECUTE\n         MVC   FSTFIELD(8),BLANKS  5-char number plus 3 blanks\n         EX    R8,MOVFNUM          Get the number from the parm\n         EX    R8,PACK             Convert it to packed\n         CVB   R0,WORKA            Convert it to Binary                  06446\n         ST    R0,SLOTBIN          Store the value for later use         06447\n         MVC   LINE,LINE-1\n         MVC   LINE(8),FSTFIELD    8-char number with blanks\n         MVC   LINE+13(19),=C'Entry slot number  '\n         APUT  LINE,32\n         LA    R8,1(,R8)           Restore number of chars after EX\n         ST    R8,CHARSIZE         Save this value off.\n         AR    R3,R8               Add it to R3 so we start past it.\n         ST    R3,CHARCONT         Store start value for next parm.\nGETNUMEN DS    0H\n         L     R9,SAVER9M\n         BR    R9\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nMASK10   DC    XL10'40202020202020202120'\n         DC    C' '\nBLANKS   DC    C'                                            '\nMESSAGET DC    C'ADIS Command - Display Auth Table Entries           '\nMESSAGEU DC    C'---- -------   ------- ---- ----- -------           '\nMESSA11A DC    C'Supply a table code TT, followed by an action code A.'\nMESSA11C DC    C'Valid table codes are:  E2, E8, AP, NS, PC, PP. '\nMESSA11D DC    C'Valid action code is :  D - display. '\nMESSA11F DC    C'Full command is in the form TTA, TT=table code, A=acti-\n               on code.'\nMESSA11H DC    C'This table did not come from a PARMLIB specification.'\nMESSA11I DC    C'If D (display) is followed by a slot number, only that-\n                slot is shown.'\nMESSA11K DC    C'If D is not followed by a number, then the entire tabl-\n               e is displayed.'\nMESSA11L DC    C'  Instructions to use this program:                  '\nMESSA11M DC    C'  ------------ -- --- ---- -------                   '\nMESSA11P DC    C'Syntax:   ADIS TTA |nnn| (nnn is an optional slot numb-\n               er).'\nMESSA11Q DC    C'***  Please try entering a parameter.  *** '\nMESSAGR0 DC    C'Return Code = 0 '\nMESSAGR4 DC    C'Return Code = 4 '\nMESSAGR8 DC    C'Return Code = 8 '\nMESSAGRC DC    C'Return Code = 12'\nMESSDIAG DC    C'                                            '\nMESSAGEP DC    C'No Parmlib-supplied XX table was found in storage. '\nMESSAGEN DC    C'Supplied character        was not numeric. '\n         SPACE 3\n         LTORG\n         SPACE 3\nCVDAREA  DS    D                   For CVD instruction\nSAVEAPUT DS    2D\nSAVER1   DS    F                   Save R1 here\nSAVER1A  DS    F                   Save R1 here\nSAVER3A  DS    F                   Save R3 here\nSAVER4A  DS    F                   Save R4 here\nSAVER5A  DS    F                   Save R5 here\nSAVER6   DS    F                   Save R6 here\nSAVER6A  DS    F                   Save R6 here\nSAVER8   DS    F                   Save R8 here\nSAVER8A  DS    F                   Save R8 here\nSAVER8B  DS    F                   Save R8 here\nSAVER9A  DS    F                   BAL Register Save Area\nSAVER9B  DS    F                   BAL Register Save Area\nSAVER9C  DS    F                   BAL Register Save Area\nSAVER9D  DS    F                   BAL Register Save Area\nSAVER9E  DS    F                   BAL Register Save Area\nSAVER9F  DS    F                   BAL Register Save Area\nSAVER9G  DS    F                   BAL Register Save Area\nSAVER9H  DS    F                   BAL Register Save Area\nSAVER9I  DS    F                   BAL Register Save Area\nSAVER9J  DS    F                   BAL Register Save Area\nSAVER9K  DS    F                   BAL Register Save Area\nSAVER9L  DS    F                   BAL Register Save Area\nSAVER9M  DS    F                   BAL Register Save Area\nSAVER9N  DS    F                   BAL Register Save Area\nSAVER9O  DS    F                   BAL Register Save Area\nSAVER9P  DS    F                   BAL Register Save Area\nSAVER9Q  DS    F                   BAL Register Save Area\nSAVER9R  DS    F                   BAL Register Save Area\nSAVER9S  DS    F                   BAL Register Save Area\nSAVER9T  DS    F                   BAL Register Save Area\nSAVER9U  DS    F                   BAL Register Save Area\nSAVER9V  DS    F                   BAL Register Save Area\nSAVER9W  DS    F                   BAL Register Save Area\nSAVER9X  DS    F                   BAL Register Save Area\nSAVER9Y  DS    F                   BAL Register Save Area\nCMBUFEND DS    F                   Number of bytes to end of cmd buff\nSAVLSLOT DS    F                   Save place where Key 0 will change\nSLOTBIN  DS    F\nSLOTNOW  DS    F\nDISPREG  DS    F                   DISPLAY\nCMBUFAD  DS    F                   Command Buffer address\nCHARSTRT DS    F                   Address of first parm character\nCHARCONT DS    F                   Address of next parm character\nCHARSIZE DS    F\nOURSLOT  DS    F\n* --- >\nTABLSTRT DS    F                   Start address of table\nTABLENUM DS    F                   Number of entries in table\nTABLESIZ DS    F                   Size of a table entry\n* --- >\nOFFSETSV DS    F\nWORKA    DC    D'0'                                                      06772\nNUMVSTRT DC    X'00'               Character count of first parm\nNUMCOUTL DC    X'00'               Entered first parm length\nCODEPLAC DS    CL2\nPAD01    DS    CL4                 Filler\nOFFFLAG  DS    X                   Are we blanking the last entry?\nOLDFLAG  DS    X                   Old system detected if X'01'\nPLATFLG  DS    X\nNSCHFLG  DS    X\nPAD02    DS    CL4                 Filler\nFSTNAME  DC    CL8' '\nFSTCOUNT DS    F                   Number of characters in FSTNAME\nFSTCHALF DC    H'0'\nPAD03    DS    CL4                 Filler\nFSTFIELD DS    0CL8\nFSTNUME  DC    CL5' '\nFSTNUPAD DC    CL3' '\nFSTNOUNT DS    F                   Number of characters in FSTNAME\nFSTNHALF DC    H'0'\nPAD04    DS    CL4                 Filler\nSLOTSAVE DS    CL10\nPAD05    DS    CL4                 Filler\nSNDNAME  DC    CL8' '\nSNDCOUNT DS    F                   Number of characters in SNDNAME\nSNDCHALF DC    H'0'\nTABCODE  DC    CL8' '              Original OUTLIM character\nTABENNUM DC    CL10' '\n         DS    CL7                 PADDING\n         DS    CL1\nCMDBCOPY DS    CL252\n         DS    CL128               PADDING\n         DS    0F                  ALIGN ON FULLWORD\nLINEB    DS    C                   LINE-1\nLINE     DS    CL137               Output line area\nLINET    EQU   LINE+7              Indented line\n         SPACE\n         IKJCPPL\n         IKJPSCB\n         CVT      LIST=YES,DSECT=YES\n         IKJTSVT\n         END\nEPUTL    TITLE 'PUTLINE FOR FEWER THAN 83 ARGUMENTS IN THE KEY OF C MAJ&\n               OR'\nEPUTL    CSECT                                              *HMD 10/85*\n         LCLB  &XA                                          *HMD 10/85*\n&XA      SETB  1                  SET TO ZERO ON NON/XA     *HMD 10/85*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*  MODULE NAME  . . . . EPUTL\n*\n*  ALIASES  . . . . . . NONE\n*\n*  DATE WRITTEN . . . . 06/85\n*  UPDATED      . . . . 04/88                                  HD APR88\n*\n*  AUTHOR . . . . . . . JIM ELSWORTH\n*  UPDATOR  . . . . . . HOWARD M. DEAN                         HD APR88\n*\n*  ENVIRONMENT  . . . . TSO COMMAND-PROCESSOR\n*\n*  PURPOSE:\n*    ALLOW AN EASY INTERFACE TO PUTLINE ROUTINE\n*\n*\n*  DESCRIPTION:\n*    BUILDS PUTLINE PARAMETER LIST BASED ON INPUT ARGUMENTS.\n*    ISSUES SINGLE LINE PUTLINE.\n*\n*\n*  ATTRIBUTES:\n*    REENTRANT\n*\n*  FEATURES:\n*    WILL RUN UNDER BATCH TMP SINCE PUTLINE USED INSTEAD OF TPUT.\n*\n*  CALLED MODULES:\n*    PUTLINE\n*\n*  ASSUMPTIONS:\n*    CALLED BY A TSO-CP THAT IS OBSERVING STANDARD LINKAGE\n*\n*  ABENDS:\n*    POSSIBLE 0CX IF BAD ARGUEMNTS\n*\n*  CAVEATS:\n*    UNPREDICTABLE RESULTS IF FIRST PROGRAM RUNNING UNDER THIS TCB\n*    DID NOT SAVE (14,12) BEFOR R1 WAS MODIFIED.\n*\n*\n*  INPUT ARGUMENTS:\n*    1)  R1 : ADDRESS OF MESSAGE TEXT\n*    2)  R0 : LENGTH OF MESSAGE TEXT\n*    3) R13 : STANDARD OS SAVE AREA\n*    4) R14 : RETURN ADDRESS\n*    5) R15 : ENTRY ADDRESS\n*\n*               ( CONTINUED ... )\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*\n*  OUTPUT ARGUMENT: RETURN CODE FROM PUTLINE OR\n*\nRCBA     EQU   100                 BAD MESSAGE ADDRESS\nRCBL     EQU   104                 MESSAGE LENGTH <1 OR >MAXMSG\n*\nMAXMSG   EQU   128                 MAXIMUM MESSAGE LENGTH\n*\n*\n*  REGISTERS USED:\n*\nR0       EQU   0                   MESSAGE LENGTH AT ENTRY\nR1       EQU   1                   MESSAGE ADDRESS AT ENTRY\nR2       EQU   2                   WORK\nRMA      EQU   4                   @MESSAGE TEXT\nRML      EQU   5                   MESSAGE LENGTH\nRUPT     EQU   6                   @UPT (USER PROFILE TABLE)\nRECT     EQU   7                   @ECT\nR12      EQU   12                  CSECT BASE\nR13      EQU   13                  @SAVE AREA AND DYNAMIC WORK AREA\nR14      EQU   14                  WORK/LINKAGE\nR15      EQU   15                  WORK/LINKAGE\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         EJECT\n         IKJCPPL\n         EJECT\n         IKJTCB   LIST=YES                                  *HMD 10/85*\n         EJECT                                              *HMD 10/85*\n         CVT      DSECT=YES,LIST=YES                        *HMD 10/85*\n         EJECT\n         IHAPSA   LIST=YES                                     HD APR88\n         EJECT                                                 HD APR88\nPUTLDS   DSECT\n         DS    18F                      OS SAVE AREA\nPUTAAA   EQU   *\nPUTECB   DS    F                        ECB\nPUTIOPL  DS    4F                       IOPLADS\nPUTBLOK  PUTLINE MF=L\nPUTLEN   DS    H                        LENGTH\nPUTZZZ   DS    H                        RESERVED\nPUTMSG   DS    (MAXMSG)C                MESSAGE TEXT AREA\nPUTSIZE  EQU   *-PUTLDS                 SIZE OF PUTLINE PARMS\n         EJECT\n***********************************************************************\n*  SET UP LINKAGE\n***********************************************************************\n         SPACE 1\nEPUTL    CSECT\n         AIF  (NOT &XA).X001                                *HMD 10/85*\nEPUTL    AMODE 31\n.X001    ANOP                                               *HMD 10/85*\n         STM   14,12,12(13)       SAVE CALLERS REGS\n         LR    R12,R15            COPY EPA\n         USING EPUTL,R12          ADDRESSABILITY\n         AIF   (NOT &XA).X002                               *HMD 10/85*\n         GETMAIN RU,              LV=LENGTH                            &\n               LV=PUTSIZE,        STANDARD OS SA PLUS ANY EXTRA        &\n               LOC=RES            RELATIVE TO 16MB LINE\n         AGO   .X003                                        *HMD 10/85*\n.X002    ANOP                                               *HMD 10/85*\n         GETMAIN RU,              LV=LENGTH                            &\n               LV=PUTSIZE         STANDARD OS SA PLUS ANY EXTRA\n.X003    ANOP                                               *HMD 10/85*\n         ST    1,8(13)            OUR SAVE AREA POINTER\n         ST    13,4(1)            POINTER TO CALLERS SAVE AREA\n         LR    13,1               @OUR SAVE AREA\n         USING PUTLDS,R13         MAP SA AND WORK AREA\n         L     R14,4(R13)         POINT TO CALLERS RSA\n         LM    R0,R1,20(R14)      RESTORE REGS CHANGED BY GETMAIN\n         SPACE 2\n***********************************************************************\n*  UNLOAD ARGUMENTS AND VALIDATE WHERE POSSIBLE\n***********************************************************************\n         SPACE 1\n         LA    R15,RCBA                 ASSUME BAD ADDRESS\n         LTR   RMA,R1                   MESSAGE ADDRESS\n         BNP   RETURN                   GOOD ASSUMPTION\n         LA    R15,RCBL                 ASSUME BAD LENGTH\n         LTR   RML,R0                   POSITIVE?\n         BNP   RETURN                   -NO\n         C     RML,=A(MAXMSG)           MORE THAN MAX?\n         BH    RETURN                   -YES\n         SPACE 2\n***********************************************************************\n*  BUILD PARAMETER LIST\n***********************************************************************\n         SPACE 1\n         LA    R15,4(RML)               MESSAGE LENGTH\n         STH   R15,PUTLEN                 PLUS HEADER\n         XC    PUTZZZ,PUTZZZ            CLEAR 2ND HWORD OF RDW\n         BCTR  RML,0                    REDUCE FOR MOVE\n         EX    RML,PUTMOVE\n         EJECT\n***********************************************************************\n*  DIG UP ADDRESS OF UPT AND ECT\n***********************************************************************\n         SPACE 1\n         L     R2,PSATOLD-PSA           @TCB                   HD APR88\n         L     R2,TCBFSA-TCB(R2)        @1ST PROBLEM PGM SAVE AREA\n         L     R2,24(R2)                REG1 THAT WAS PASSED TO CP\n         USING CPPL,R2                  MAP CPPL\n         L     RUPT,CPPLUPT             @UPT\n         L     RECT,CPPLECT             @ECT\n         SPACE 2\n***********************************************************************\n*  ISSUE PUTLINE CALL\n***********************************************************************\n         SPACE 1\n         XC    PUTECB,PUTECB            CLEAR ECB\n         XC    PUTBLOK(12),PUTBLOK      CLEAR PARM BLOCK       HD APR88\n         PUTLINE PARM=PUTBLOK,          PARAMETER BLOCK                &\n               UPT=(RUPT),              @UPT                           &\n               ECT=(RECT),              @ECT                           &\n               ECB=PUTECB,              @ECB                           &\n               OUTPUT=(PUTLEN,TERM,SINGLE,DATA),                       &\n               MF=(E,PUTIOPL)\n         EJECT\n***********************************************************************\n*  RETURN TO CALLER\n***********************************************************************\n         SPACE 1\nRETURN   EQU   *\n         LR    2,R13                    @OUR SAVE AREA\n         LR    3,R15                    SAVE RETURN CODE\n         L     R13,4(R13)               @CALLERS SAVE AREA\n         FREEMAIN RU,LV=PUTSIZE,A=(R2),SP=0\n         LR    R15,3                    RESTORE RC\n         RETURN (14,12),RC=(15)         RESTORE CALLERS REGS\n         SPACE 5\n***********************************************************************\n*  CONSTANTS AND NON-REENTRANT WORK AREAS\n***********************************************************************\n         SPACE 1\nPUTMOVE  MVC   PUTMSG(*-*),0(RMA)       MOVE MESSAGE TO BUFFER\n         SPACE 2\n         LTORG\n         SPACE 2\n         END   EPUTL\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ADIS$": {"ttr": 1541, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00A\\x01\\x055O\\x01\\x13\\x17/\\x10\\t\\x00\\x1b\\x00\\x1d\\x00\\x00```````@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "2005-12-20T00:00:00", "modifydate": "2013-06-21T10:09:41", "lines": 27, "newlines": 29, "modlines": 0, "user": "-------"}, "text": "//IBMUSERU JOB (CCMVS),ASMLINK,\n// NOTIFY=&SYSUID,\n// CLASS=A,MSGCLASS=X,COND=(1,LT)\n//*\n//*     ASM LINKEDIT FROM SOURCE ASM\n//*\n//ASMH EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,NORLD,NOXREF)\n//SYSLIB   DD DISP=SHR,DSN=SYS1.MACLIB\n//         DD DISP=SHR,DSN=SYS1.MODGEN\n//SYSIN    DD DISP=SHR,DSN=IBMUSER.CBT477.FILE185(ADIS)\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,9),DISP=(,PASS),DCB=BLKSIZE=3200,\n//            DSN=&&TEMP\n//*\n//LKED   EXEC  PGM=HEWL,\n//       PARM='NCAL,MAP,LIST,LET'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=IBMUSER.W$$.LINKLIB\n//SYSLMOD  DD  DISP=SHR,DSN=IBMUSER.W$$.LINKLIB\n//OBJECT   DD  DISP=(OLD,DELETE),DSN=&&TEMP\n//SYSLIN   DD  *\n INCLUDE OBJECT\n SETCODE AC(0)\n ENTRY   ADIS\n NAME    ADIS(R)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ASMKKTBL": {"ttr": 1543, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x10\\x00 \\x01\\x13\\x10\\x9f\\x01\\x19#\\x1f\\x10&\\x03\\x9b\\x03\\x0e\\x00\\x00```````@@@'", "ispf": {"version": "01.16", "flags": 0, "createdate": "2013-04-19T00:00:00", "modifydate": "2019-08-19T10:26:20", "lines": 923, "newlines": 782, "modlines": 0, "user": "-------"}, "text": "//IBMUSERB  JOB (ACCT#),-------,\n// NOTIFY=&SYSUID,\n// CLASS=B,MSGCLASS=X\n//         JCLLIB ORDER=IBMUSER.CBT493.FILE185\n//* ------------------------------------------------ *//\n//*    ASSEMBLY OF KKJTABLS FOR Z/OS 2.3 AND BELOW   *//\n//* ------------------------------------------------ *//\n//*    YOU MUST ALWAYS CODE AT LEAST ONE BLANK       *//\n//*      ENTRY AT THE END OF EACH TABLE !!!!!        *//\n//* ------------------------------------------------ *//\n//IKJTABLS  EXEC REASMLNK,OUTPUT='IBMUSER.ASMTABLS.LOAD',   <=== CHANGE\n//  PARM.LKED='NCAL,MAP,LIST,LET,RENT,REUS'\n//ASM.SYSIN   DD *\nKKJEFTE2 CSECT\n         DC    C'IKJEFTE2'\n         DC    C'76.152  '\n         ENTRY APFCTABL\nAPFCTABL DC    C'$$      '\n         DC    C'$HOWMVS '\n         DC    C'$MDSMAIN'\n         DC    C'#       '\n         DC    C'ABUDSN  '\n         DC    C'AD      '\n         DC    C'ADB2UTIL'\n         DC    C'ADDDIR  '\n         DC    C'ADDFILE '\n         DC    C'ADDGROUP'\n         DC    C'ADDSD   '\n         DC    C'ADDUSER '\n         DC    C'ADIR    '\n         DC    C'ADNR    '\n         DC    C'ADRDSSU '\n         DC    C'ADYOPCMD'\n         DC    C'AF      '\n         DC    C'AG      '\n         DC    C'ALD     '\n         DC    C'ALF     '\n         DC    C'ALG     '\n         DC    C'ALLIDS  '\n         DC    C'ALTDIR  '\n         DC    C'ALTDSD  '\n         DC    C'ALTER   '\n         DC    C'ALTFILE '\n         DC    C'ALTGROUP'\n         DC    C'ALTUSER '\n         DC    C'ALU     '\n         DC    C'APCACBL '\n         DC    C'APCANB  '\n         DC    C'APCARB  '\n         DC    C'APCAUB  '\n         DC    C'APFCMD  '\n         DC    C'ASUB    '\n         DC    C'AU      '\n         DC    C'AUCMD   '\n         DC    C'AUPGM   '\n         DC    C'BACKUP  '\n         DC    C'BCMDEL  '\n         DC    C'BCMDEL1 '\n         DC    C'BCMNAUTH'\n         DC    C'BCMNUPD '\n         DC    C'BDATA   '\n         DC    C'BDMNNOTC'\n         DC    C'BDMNUPD '\n         DC    C'BINDDATA'\n         DC    C'BLKUPD  '\n         DC    C'BUDDSN  '\n         DC    C'BUDGET  '\n         DC    C'BUFRSIZE'\n         DC    C'BURN    '\n         DC    C'CAE$BQRY'\n         DC    C'CANCELU '\n         DC    C'CAS9UDTN'\n         DC    C'CDELPAIR'\n         DC    C'CDELPATH'\n         DC    C'CDMRSTAT'\n         DC    C'CDSCB   '\n         DC    C'CDSCBA  '\n         DC    C'CESTPAIR'\n         DC    C'CESTPATH'\n         DC    C'CGROUP  '\n         DC    C'CHKPT   '\n         DC    C'CHNLEN  '\n         DC    C'CINMX   '\n         DC    C'CKGRACF '\n         DC    C'CLCHECK '\n         DC    C'CNCLPG  '\n         DC    C'CNCLPGA '\n         DC    C'CNCLPGBK'\n         DC    C'CNCLP210'\n         DC    C'CNVTCAT '\n         DC    C'CO      '\n         DC    C'COFDMON '\n         DC    C'CONNECT '\n         DC    C'CONS    '\n         DC    C'CONSPROF'\n         DC    C'CPFX    '\n         DC    C'CPSCB   '\n         DC    C'CQUERY  '\n         DC    C'CQUERYSG'\n         DC    C'CQX     '\n         DC    C'CRECOVER'\n         DC    C'CSCAN   '\n         DC    C'CSCF    '\n         DC    C'CSUSPEND'\n         DC    C'DCAS    '\n         DC    C'DD      '\n         DC    C'DDIR    '\n         DC    C'DEF     '\n         DC    C'DEFINE  '\n         DC    C'DEL     '\n         DC    C'DELDIR  '\n         DC    C'DELDSD  '\n         DC    C'DELETE  '\n         DC    C'DELFILE '\n         DC    C'DELGROUP'\n         DC    C'DELUSER '\n         DC    C'DF      '\n         DC    C'DG      '\n         DC    C'DITTO   '\n         DC    C'DITTOA  '\n         DC    C'DITTOU  '\n         DC    C'DMRSHR  '\n         DC    C'DRI     '\n         DC    C'DSPRINT '\n         DC    C'DU      '\n         DC    C'DUMPPPT '\n         DC    C'DUMPTSB '\n         DC    C'ENGTRANS'\n         DC    C'ERWMAUTH'\n         DC    C'EX      '\n         DC    C'EXP     '\n         DC    C'EXPORT  '\n         DC    C'EYU9XENF'\n         DC    C'EZAZSSI '\n         DC    C'EZBREINI'\n         DC    C'EZBTNINI'\n         DC    C'FCESTABL'\n         DC    C'FCQUERY '\n         DC    C'FCWITHDR'\n         DC    C'FIXDSCB '\n         DC    C'FTPD    '\n         DC    C'FTPDNS  '\n         DC    C'GJTRUCBS'\n         DC    C'HIBFREXT'\n         DC    C'IEBCOPY '\n         DC    C'IKJEHDSF'\n         DC    C'IKJEHDS1'\n         DC    C'IKJPRMLB'\n         DC    C'IM      '\n         DC    C'IMP     '\n         DC    C'IMPORT  '\n         DC    C'IOBSNMP '\n         DC    C'IQIEXPN '\n         DC    C'IQIMAIN '\n         DC    C'IQIQUERY'\n         DC    C'IQIQUIT '\n         DC    C'IRRDPI00'\n         DC    C'ISPICP  '\n         DC    C'JOELOOK '\n         DC    C'JOELOOX '\n         DC    C'KOMPRESS'\n         DC    C'LASTCLPA'\n         DC    C'LBADV   '\n         DC    C'LBAGENT '\n         DC    C'LD      '\n         DC    C'LDATA   '\n         DC    C'LDIR    '\n         DC    C'LDIRECT '\n         DC    C'LF      '\n         DC    C'LFILE   '\n         DC    C'LG      '\n         DC    C'LISTB   '\n         DC    C'LISTBC  '\n         DC    C'LISTD   '\n         DC    C'LISTDATA'\n         DC    C'LISTDS  '\n         DC    C'LISTDSD '\n         DC    C'LISTGRP '\n         DC    C'LISTUSER'\n         DC    C'LLAPRINT'\n         DC    C'LLASAC  '\n         DC    C'LLWA    '\n         DC    C'LMRKTSO '\n         DC    C'LOBFREXT'\n         DC    C'LOCATE  '\n         DC    C'LOCKTERM'\n         DC    C'LOGOPTS '\n         DC    C'LOOK    '\n         DC    C'LOOKJ   '\n         DC    C'LOOKN   '\n         DC    C'LOOKNBAD'\n         DC    C'LOOKX   '\n         DC    C'LPQ     '\n         DC    C'LPR     '\n         DC    C'LPRM    '\n         DC    C'LPROC   '\n         DC    C'LSLT    '\n         DC    C'LU      '\n         DC    C'LWATMGR '\n         DC    C'MAKEUSER'\n         DC    C'MERLIN  '\n         DC    C'MIMTSO  '\n         DC    C'MODDVIPA'\n         DC    C'MU      '\n         DC    C'MVPMAIN '\n         DC    C'MVPXDISP'\n         DC    C'MVSCPCMD'\n         DC    C'NAMEDXFR'\n         DC    C'NAMED4  '\n         DC    C'NDVRC1  '\n         DC    C'NETSTAT '\n         DC    C'NSUPDATE'\n         DC    C'NSUPDAT4'\n         DC    C'NUL8    '\n         DC    C'NYPPW   '\n         DC    C'OC      '\n         DC    C'OMPROUTE'\n         DC    C'OP      '\n         DC    C'OPER    '\n         DC    C'OPERA   '\n         DC    C'OPERATOR'\n         DC    C'OPINFO  '\n         DC    C'OPING   '\n         DC    C'OPSCMD  '\n         DC    C'OPSCONSL'\n         DC    C'OPSOSCMD'\n         DC    C'OPSPARM '\n         DC    C'OPSREPLY'\n         DC    C'OPSTAT  '\n         DC    C'OPSWTO  '\n         DC    C'OSASK   '\n         DC    C'OSCMD   '\n         DC    C'OSNMPD  '\n         DC    C'OSWTO   '\n         DC    C'OTRACERT'\n         DC    C'PACKRAT '\n         DC    C'PARMLIB '\n         DC    C'PASSWORD'\n         DC    C'PDIR    '\n         DC    C'PDSCLEAN'\n         DC    C'PDSEAUTH'\n         DC    C'PDS38   '\n         DC    C'PE      '\n         DC    C'PERMDIR '\n         DC    C'PERMFILE'\n         DC    C'PERMIT  '\n         DC    C'PF      '\n         DC    C'PHRASE  '\n         DC    C'PING    '\n         DC    C'POPPER  '\n         DC    C'PPTD    '\n         DC    C'PPTSCAN '\n         DC    C'PRELOAD '\n         DC    C'PRINT   '\n         DC    C'PRSMINFO'\n         DC    C'PW      '\n         DC    C'Q       '\n         DC    C'QUEUE   '\n         DC    C'Q522    '\n         DC    C'RACDCERT'\n         DC    C'RACFSIM '\n         DC    C'RACLINK '\n         DC    C'RACONVRT'\n         DC    C'RACPRIV '\n         DC    C'RALT    '\n         DC    C'RALTER  '\n         DC    C'RDEF    '\n         DC    C'RDEFINE '\n         DC    C'RDEL    '\n         DC    C'RDELETE '\n         DC    C'RE      '\n         DC    C'RECEIVE '\n         DC    C'RECONLIM'\n         DC    C'RELOGON '\n         DC    C'REMOVE  '\n         DC    C'REPRO   '\n         DC    C'RESOLVE '\n         DC    C'REVIEW  '\n         DC    C'REVVSAM '\n         DC    C'REXCPCMD'\n         DC    C'RL      '\n         DC    C'RLIST   '\n         DC    C'RLOAD   '\n         DC    C'RLOADA  '\n         DC    C'RMM     '\n         DC    C'RPF     '\n         DC    C'RPFE    '\n         DC    C'RSH     '\n         DC    C'RSHD    '\n         DC    C'RVARY   '\n         DC    C'SAMENDM '\n         DC    C'SCRSIZE '\n         DC    C'SDSF    '\n         DC    C'SE      '\n         DC    C'SEARCH  '\n         DC    C'SECURE  '\n         DC    C'SEE     '\n         DC    C'SEND    '\n         DC    C'SEND@   '\n         DC    C'SETC    '\n         DC    C'SETCACHE'\n         DC    C'SETPASSW'\n         DC    C'SETPW   '\n         DC    C'SETPW2  '\n         DC    C'SETR    '\n         DC    C'SETROPTS'\n         DC    C'SETUSER '\n         DC    C'SHCDS   '\n         DC    C'SHOWPPT '\n         DC    C'SHOWTCAS'\n         DC    C'SHOWTPVT'\n         DC    C'SM      '\n         DC    C'SMTP    '\n         DC    C'SNTPD   '\n         DC    C'SPACE   '\n         DC    C'SPFCOPY '\n         DC    C'SPSWT   '\n         DC    C'SPY     '\n         DC    C'SR      '\n         DC    C'SRDIR   '\n         DC    C'SRF     '\n         DC    C'SRFILE  '\n         DC    C'SRSTAT  '\n         DC    C'STEPLIB '\n         DC    C'STEPLIBG'\n         DC    C'STEPLIBN'\n         DC    C'STEPLIB4'\n         DC    C'SU      '\n         DC    C'SYNC    '\n         DC    C'SYSPROG '\n         DC    C'TEAEXTSO'\n         DC    C'TERM    '\n         DC    C'TERMINAL'\n         DC    C'TERMSZ  '\n         DC    C'TESTA   '\n         DC    C'TESTAUTH'\n         DC    C'TMONCICS'\n         DC    C'TMONDB2 '\n         DC    C'TMONIMS '\n         DC    C'TMONMVS '\n         DC    C'TRACERTE'\n         DC    C'TRANSMIT'\n         DC    C'TRAPFWD '\n         DC    C'TRMD    '\n         DC    C'TSOENQ  '\n         DC    C'TSOSMS  '\n         DC    C'TSUB    '\n         DC    C'TSVT8   '\n         DC    C'UACEE   '\n         DC    C'UCB     '\n         DC    C'UGRP    '\n         DC    C'UKEYCSA '\n         DC    C'ULWA    '\n         DC    C'UPRC    '\n         DC    C'USAT    '\n         DC    C'USERMAX '\n         DC    C'USET    '\n         DC    C'USIT    '\n         DC    C'USOT    '\n         DC    C'USPT    '\n         DC    C'USUR    '\n         DC    C'USUT    '\n         DC    C'USWT    '\n         DC    C'USXT    '\n         DC    C'USYNC   '\n         DC    C'USYT    '\n         DC    C'USZT    '\n         DC    C'UTSB    '\n         DC    C'VERIFY  '\n         DC    C'VFY     '\n         DC    C'VIEWUSER'\n         DC    C'VLFNOTE '\n         DC    C'VMCF    '\n         DC    C'VU      '\n         DC    C'WAITT   '\n         DC    C'WHEREIS '\n         DC    C'WHOENQ  '\n         DC    C'WHOIS   '\n         DC    C'WSSTAT  '\n         DC    C'XD      '\n         DC    C'XDCCALLA'\n         DC    C'XDCCMDA '\n         DC    C'XF      '\n         DC    C'XMDSMAIN'\n         DC    C'XMIT    '\n         DC    C'XTRCUSER'\n         DC    C'XU      '\n         DC    C'YKCONMSG'\n         DC    C'ZAP     '\n         DC    C'ZAP$    '\n         DC    C'ZAPDSCB '\n         DC    C'ZAPLWA  '\n         DC    C'ZAPV    '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\nKKJEFTE8 CSECT\n         DC    C'IKJEFTE8'\n         DC    C'85.092  '\n         ENTRY APFPTABL\nAPFPTABL DC    C'ADB2ATH '\n         DC    C'ADB2UTIL'\n         DC    C'ADRDSSU '\n         DC    C'ALPAUTH '\n         DC    C'APCACBL '\n         DC    C'APCANB  '\n         DC    C'APCARB  '\n         DC    C'APCAUB  '\n         DC    C'APFPGM  '\n         DC    C'ARMAUTH '\n         DC    C'COMMAND '\n         DC    C'COMMND  '\n         DC    C'CONSPROF'\n         DC    C'CSFDAUTH'\n         DC    C'CSFDPKDS'\n         DC    C'CTMAES  '\n         DC    C'CTMDFL  '\n         DC    C'CTMRUN  '\n         DC    C'CTRCTR  '\n         DC    C'CTRSPL  '\n         DC    C'DISKMAP '\n         DC    C'EDGAUD  '\n         DC    C'EDGHSKP '\n         DC    C'EDGRPTD '\n         DC    C'EDGUTIL '\n         DC    C'EMCICS61'\n         DC    C'EMCSNAP '\n         DC    C'EMCTF   '\n         DC    C'EMCTFU  '\n         DC    C'EQQMINOR'\n         DC    C'ERWMAUTH'\n         DC    C'FDRABR  '\n         DC    C'FDRABRUT'\n         DC    C'FDRCPK  '\n         DC    C'FDREPORT'\n         DC    C'FDRMONA '\n         DC    C'FDRPASA '\n         DC    C'FDRQUERY'\n         DC    C'FDRSRSA '\n         DC    C'FSYTPA00'\n         DC    C'GIMSMP  '\n         DC    C'GJTRUCBS'\n         DC    C'HESEVMI '\n         DC    C'ICADCFGS'\n         DC    C'ICADCT  '\n         DC    C'ICADDCT '\n         DC    C'ICADFTPD'\n         DC    C'ICADIKED'\n         DC    C'ICADPFTP'\n         DC    C'ICADSLOG'\n         DC    C'ICADSOCK'\n         DC    C'ICADSOXD'\n         DC    C'ICADSTAK'\n         DC    C'ICHDSM00'\n         DC    C'ICHUEX00'\n         DC    C'ICHUT100'\n         DC    C'ICHUT200'\n         DC    C'ICHUT400'\n         DC    C'IDCAMS  '\n         DC    C'IEBCOPY '\n         DC    C'IEHINIT '\n         DC    C'IEHMOVE '\n         DC    C'IEHPROGM'\n         DC    C'IFCEREP1'\n         DC    C'IKJEFF76'\n         DC    C'IOEAGFMT'\n         DC    C'IOEAGSLV'\n         DC    C'IOEBAK  '\n         DC    C'IOEBOS  '\n         DC    C'IOECM   '\n         DC    C'IOEDCEER'\n         DC    C'IOEDFSXP'\n         DC    C'IOEFTS  '\n         DC    C'IOEGRWAG'\n         DC    C'IOEMAPID'\n         DC    C'IOENEWAG'\n         DC    C'IOESALVG'\n         DC    C'IOESCOUT'\n         DC    C'IOESMBPW'\n         DC    C'IOEUDBG '\n         DC    C'IOEZADM '\n         DC    C'IRMAUTH '\n         DC    C'IRRDBU00'\n         DC    C'IRRDIP00'\n         DC    C'IRRDPI00'\n         DC    C'IRRDSC00'\n         DC    C'IRRUT100'\n         DC    C'IRRUT200'\n         DC    C'IRRUT400'\n         DC    C'IRRXUTI2'\n         DC    C'ITPENTER'\n         DC    C'IXCMIAPU'\n         DC    C'JCLSRB  '\n         DC    C'KEPSTCTO'\n         DC    C'KOBROUTR'\n         DC    C'KOBSPFAU'\n         DC    C'LISTDATA'\n         DC    C'LLAPRINT'\n         DC    C'LLASAC  '\n         DC    C'LOCKTERM'\n         DC    C'LWATMGR '\n         DC    C'MIMTSO  '\n         DC    C'MVPXDISP'\n         DC    C'NDVRC1  '\n         DC    C'OBROUTR '\n         DC    C'OBSPFAU '\n         DC    C'OLDCOPY '\n         DC    C'OMCICS  '\n         DC    C'OMEGAMON'\n         DC    C'OMSPFAU '\n         DC    C'PDSCLEAN'\n         DC    C'PDSCLEAR'\n         DC    C'PDSEAUTH'\n         DC    C'PDSFAST '\n         DC    C'PING    '\n         DC    C'PSIPCTL '\n         DC    C'RESOLVE '\n         DC    C'REVVSAM '\n         DC    C'REXCPCMD'\n         DC    C'SAMENDM '\n         DC    C'SCRAMRE '\n         DC    C'SDSF    '\n         DC    C'SHERCOMM'\n         DC    C'SHOWMVS '\n         DC    C'SHOWZOS '\n         DC    C'SYSPROG '\n         DC    C'TESTENQ '\n         DC    C'TMONMVS '\n         DC    C'TMSIOCAP'\n         DC    C'TMSSCR  '\n         DC    C'TSOENQ  '\n         DC    C'TSOSPA  '\n         DC    C'WHOENQ  '\n         DC    C'ZAPVIRT '\n         DC    C'ZSIZER  '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\nKKJEFTNS CSECT\n         DC    C'IKJEFTNS'\n         DC    C'76.033  '\n         ENTRY NSCPTABL\nNSCPTABL DC    X'0008'\n         DC    C'OPERATOR'\n         DC    X'0004'\n         DC    C'OPER    '\n         DC    X'0008'\n         DC    C'TERMINAL'\n         DC    X'0004'\n         DC    C'TERM    '\n         DC    X'0000'\n         DC    C'        '\n         DC    X'0000'\n         DC    C'        '\n         DC    X'0000'\n         DC    C'        '\n         DC    X'0000'\n         DC    C'        '\n         DC    X'0000'\n         DC    C'        '\n         DC    X'0000'\n         DC    C'        '\n         DC    X'0000'\n         DC    C'        '\n         DC    X'0000'\n         DC    C'        '\n         DC    X'0000'\n         DC    C'        '\n         DC    X'0000'\n         DC    C'        '\n         DC    X'FFFF'\nKKJEFTAP CSECT\n         DC    C'IKJEFTAP'\n         DC    C'86.120  '\n         ENTRY APFTTABL\nAPFTTABL DC    C'$$      '\n         DC    C'#       '\n         DC    C'@       '\n         DC    C'AAATHCHK'\n         DC    C'AACMD001'\n         DC    C'AACMD002'\n         DC    C'AACMD003'\n         DC    C'AACMD004'\n         DC    C'AACMD005'\n         DC    C'AACMD006'\n         DC    C'AACMD007'\n         DC    C'AACMD008'\n         DC    C'AACMD009'\n         DC    C'AACMD014'\n         DC    C'AACMD015'\n         DC    C'AACNG001'\n         DC    C'AACNG002'\n         DC    C'AACNG003'\n         DC    C'AAGRPUSR'\n         DC    C'AAPSWCHK'\n         DC    C'AAREP011'\n         DC    C'ADB2ATH '\n         DC    C'ADB2UTIL'\n         DC    C'ADRDSSU '\n         DC    C'APFCMD  '\n         DC    C'BACKUP  '\n         DC    C'BBSDTCPA'\n         DC    C'BCMNUPD '\n         DC    C'BDMNUPD '\n         DC    C'BFFLU   '\n         DC    C'CADU4804'\n         DC    C'CADU4805'\n         DC    C'CAT01IKB'\n         DC    C'CAZ2CTSO'\n         DC    C'CDFAUTH '\n         DC    C'CDSCB   '\n         DC    C'CSCCOPY '\n         DC    C'CSFDAUTH'\n         DC    C'CSFDPKDS'\n         DC    C'DISKMAP '\n         DC    C'EDGAUD  '\n         DC    C'EDGHSKP '\n         DC    C'EDGRPTD '\n         DC    C'EDGUTIL '\n         DC    C'EMCICS61'\n         DC    C'EMCSNAP '\n         DC    C'EMCTF   '\n         DC    C'EMCTFU  '\n         DC    C'EOUCCSYM'\n         DC    C'EQQMINOR'\n         DC    C'ERWMAUTH'\n         DC    C'EX      '\n         DC    C'FDRABR  '\n         DC    C'FDRABRUT'\n         DC    C'FDRCPK  '\n         DC    C'FDREPORT'\n         DC    C'FDRMONA '\n         DC    C'FDRPASA '\n         DC    C'FDRQUERY'\n         DC    C'FDRSRSA '\n         DC    C'FMNSMF  '\n         DC    C'GIMSMP  '\n         DC    C'GJTRUCBS'\n         DC    C'IAMRECVR'\n         DC    C'IAMXMONA'\n         DC    C'ICADCFGS'\n         DC    C'ICADCT  '\n         DC    C'ICADDCT '\n         DC    C'ICADFTPD'\n         DC    C'ICADIKED'\n         DC    C'ICADPFTP'\n         DC    C'ICADSLOG'\n         DC    C'ICADSOCK'\n         DC    C'ICADSOXD'\n         DC    C'ICADSTAK'\n         DC    C'ICHDSM00'\n         DC    C'ICHUT100'\n         DC    C'ICHUT200'\n         DC    C'ICHUT400'\n         DC    C'ICQASLI0'\n         DC    C'IEBCOPY '\n         DC    C'IKJEFF76'\n         DC    C'IM      '\n         DC    C'IOEAGFMT'\n         DC    C'IOEAGSLV'\n         DC    C'IOEBAK  '\n         DC    C'IOEBOS  '\n         DC    C'IOECM   '\n         DC    C'IOEDCEER'\n         DC    C'IOEDFSXP'\n         DC    C'IOEFTS  '\n         DC    C'IOEGRWAG'\n         DC    C'IOEMAPID'\n         DC    C'IOENEWAG'\n         DC    C'IOESALVG'\n         DC    C'IOESCOUT'\n         DC    C'IOEUDBG '\n         DC    C'IOEZADM '\n         DC    C'IRRDPI00'\n         DC    C'IRRDSC00'\n         DC    C'IRRUT100'\n         DC    C'IRRUT200'\n         DC    C'IRRUT400'\n         DC    C'IRRXUTI2'\n         DC    C'JCLSRB  '\n         DC    C'LLAPRINT'\n         DC    C'LLASAC  '\n         DC    C'LSLT    '\n         DC    C'LWATEDIT'\n         DC    C'LWATMGR '\n         DC    C'MIMTSO  '\n         DC    C'MNAPFPRC'\n         DC    C'MNCDTPRC'\n         DC    C'MNCD2PRC'\n         DC    C'MNGRPPRC'\n         DC    C'MNLLTPRC'\n         DC    C'MNLPAPRC'\n         DC    C'MNPPTPRC'\n         DC    C'MNRACPRC'\n         DC    C'MNRAUPRC'\n         DC    C'MNRFRPRC'\n         DC    C'MNSMFPRC'\n         DC    C'MNSM4PRC'\n         DC    C'MNSTCPRC'\n         DC    C'MNSVCPRC'\n         DC    C'MXI     '\n         DC    C'MXITSF  '\n         DC    C'NDVRC1  '\n         DC    C'OBROUTR '\n         DC    C'OBSPFAU '\n         DC    C'OLDCOPY '\n         DC    C'OMCICS  '\n         DC    C'OMEGAMON'\n         DC    C'OMSPFAU '\n         DC    C'PDSCLEAN'\n         DC    C'PDSEAUTH'\n         DC    C'PDSFAST '\n         DC    C'PMGLAUTH'\n         DC    C'PSIPCTL '\n         DC    C'PTLTSRB '\n         DC    C'RCFRESET'\n         DC    C'REATSF  '\n         DC    C'SAMENDM '\n         DC    C'TMONMVS '\n         DC    C'TMSIOCAP'\n         DC    C'TMSSCR  '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         YREGS\n         END\n//LKED.SYSLIN  DD *\n INCLUDE SYSLIBX\n ORDER   KKJEFTE2(P),KKJEFTE8,KKJEFTNS,KKJEFTAP\n MODE    RMODE(24),AMODE(24)\n SETCODE AC(1)\n ENTRY   KKJEFTAP\n ALIAS   KKJEFTAP,KKJEFTE2,KKJEFTE8,KKJEFTNS\n NAME    KKJTABLS(R)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ASMTABLS": {"ttr": 2049, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0f\\x00W\\x01\\x13\\x10\\x9f\\x01\\x19#\\x1f\\x10\\x18\\x03\\x9b\\x03\\x0e\\x00\\x00```````@@@'", "ispf": {"version": "01.15", "flags": 0, "createdate": "2013-04-19T00:00:00", "modifydate": "2019-08-19T10:18:57", "lines": 923, "newlines": 782, "modlines": 0, "user": "-------"}, "text": "//IBMUSERB  JOB (ACCT#),-------,\n// NOTIFY=&SYSUID,\n// CLASS=B,MSGCLASS=X\n//         JCLLIB ORDER=IBMUSER.CBT498.FILE185\n//* ------------------------------------------------ *//\n//*    ASSEMBLY OF IKJTABLS FOR Z/OS 2.3 AND BELOW   *//\n//* ------------------------------------------------ *//\n//*    YOU MUST ALWAYS CODE AT LEAST ONE BLANK       *//\n//*      ENTRY AT THE END OF EACH TABLE !!!!!        *//\n//* ------------------------------------------------ *//\n//IKJTABLS  EXEC REASMLNK,OUTPUT='IBMUSER.ASMTABLS.LOAD',   <=== CHANGE\n//  PARM.LKED='NCAL,MAP,LIST,LET,RENT,REUS'\n//ASM.SYSIN   DD *\nIKJEFTE2 CSECT\n         DC    C'IKJEFTE2'\n         DC    C'76.152  '\n         ENTRY APFCTABL\nAPFCTABL DC    C'$$      '\n         DC    C'$HOWMVS '\n         DC    C'$MDSMAIN'\n         DC    C'#       '\n         DC    C'ABUDSN  '\n         DC    C'AD      '\n         DC    C'ADB2UTIL'\n         DC    C'ADDDIR  '\n         DC    C'ADDFILE '\n         DC    C'ADDGROUP'\n         DC    C'ADDSD   '\n         DC    C'ADDUSER '\n         DC    C'ADIR    '\n         DC    C'ADNR    '\n         DC    C'ADRDSSU '\n         DC    C'ADYOPCMD'\n         DC    C'AF      '\n         DC    C'AG      '\n         DC    C'ALD     '\n         DC    C'ALF     '\n         DC    C'ALG     '\n         DC    C'ALLIDS  '\n         DC    C'ALTDIR  '\n         DC    C'ALTDSD  '\n         DC    C'ALTER   '\n         DC    C'ALTFILE '\n         DC    C'ALTGROUP'\n         DC    C'ALTUSER '\n         DC    C'ALU     '\n         DC    C'APCACBL '\n         DC    C'APCANB  '\n         DC    C'APCARB  '\n         DC    C'APCAUB  '\n         DC    C'APFCMD  '\n         DC    C'ASUB    '\n         DC    C'AU      '\n         DC    C'AUCMD   '\n         DC    C'AUPGM   '\n         DC    C'BACKUP  '\n         DC    C'BCMDEL  '\n         DC    C'BCMDEL1 '\n         DC    C'BCMNAUTH'\n         DC    C'BCMNUPD '\n         DC    C'BDATA   '\n         DC    C'BDMNNOTC'\n         DC    C'BDMNUPD '\n         DC    C'BINDDATA'\n         DC    C'BLKUPD  '\n         DC    C'BUDDSN  '\n         DC    C'BUDGET  '\n         DC    C'BUFRSIZE'\n         DC    C'BURN    '\n         DC    C'CAE$BQRY'\n         DC    C'CANCELU '\n         DC    C'CAS9UDTN'\n         DC    C'CDELPAIR'\n         DC    C'CDELPATH'\n         DC    C'CDMRSTAT'\n         DC    C'CDSCB   '\n         DC    C'CDSCBA  '\n         DC    C'CESTPAIR'\n         DC    C'CESTPATH'\n         DC    C'CGROUP  '\n         DC    C'CHKPT   '\n         DC    C'CHNLEN  '\n         DC    C'CINMX   '\n         DC    C'CKGRACF '\n         DC    C'CLCHECK '\n         DC    C'CNCLPG  '\n         DC    C'CNCLPGA '\n         DC    C'CNCLPGBK'\n         DC    C'CNCLP210'\n         DC    C'CNVTCAT '\n         DC    C'CO      '\n         DC    C'COFDMON '\n         DC    C'CONNECT '\n         DC    C'CONS    '\n         DC    C'CONSPROF'\n         DC    C'CPFX    '\n         DC    C'CPSCB   '\n         DC    C'CQUERY  '\n         DC    C'CQUERYSG'\n         DC    C'CQX     '\n         DC    C'CRECOVER'\n         DC    C'CSCAN   '\n         DC    C'CSCF    '\n         DC    C'CSUSPEND'\n         DC    C'DCAS    '\n         DC    C'DD      '\n         DC    C'DDIR    '\n         DC    C'DEF     '\n         DC    C'DEFINE  '\n         DC    C'DEL     '\n         DC    C'DELDIR  '\n         DC    C'DELDSD  '\n         DC    C'DELETE  '\n         DC    C'DELFILE '\n         DC    C'DELGROUP'\n         DC    C'DELUSER '\n         DC    C'DF      '\n         DC    C'DG      '\n         DC    C'DITTO   '\n         DC    C'DITTOA  '\n         DC    C'DITTOU  '\n         DC    C'DMRSHR  '\n         DC    C'DRI     '\n         DC    C'DSPRINT '\n         DC    C'DU      '\n         DC    C'DUMPPPT '\n         DC    C'DUMPTSB '\n         DC    C'ENGTRANS'\n         DC    C'ERWMAUTH'\n         DC    C'EX      '\n         DC    C'EXP     '\n         DC    C'EXPORT  '\n         DC    C'EYU9XENF'\n         DC    C'EZAZSSI '\n         DC    C'EZBREINI'\n         DC    C'EZBTNINI'\n         DC    C'FCESTABL'\n         DC    C'FCQUERY '\n         DC    C'FCWITHDR'\n         DC    C'FIXDSCB '\n         DC    C'FTPD    '\n         DC    C'FTPDNS  '\n         DC    C'GJTRUCBS'\n         DC    C'HIBFREXT'\n         DC    C'IEBCOPY '\n         DC    C'IKJEHDSF'\n         DC    C'IKJEHDS1'\n         DC    C'IKJPRMLB'\n         DC    C'IM      '\n         DC    C'IMP     '\n         DC    C'IMPORT  '\n         DC    C'IOBSNMP '\n         DC    C'IQIEXPN '\n         DC    C'IQIMAIN '\n         DC    C'IQIQUERY'\n         DC    C'IQIQUIT '\n         DC    C'IRRDPI00'\n         DC    C'ISPICP  '\n         DC    C'JOELOOK '\n         DC    C'JOELOOX '\n         DC    C'KOMPRESS'\n         DC    C'LASTCLPA'\n         DC    C'LBADV   '\n         DC    C'LBAGENT '\n         DC    C'LD      '\n         DC    C'LDATA   '\n         DC    C'LDIR    '\n         DC    C'LDIRECT '\n         DC    C'LF      '\n         DC    C'LFILE   '\n         DC    C'LG      '\n         DC    C'LISTB   '\n         DC    C'LISTBC  '\n         DC    C'LISTD   '\n         DC    C'LISTDATA'\n         DC    C'LISTDS  '\n         DC    C'LISTDSD '\n         DC    C'LISTGRP '\n         DC    C'LISTUSER'\n         DC    C'LLAPRINT'\n         DC    C'LLASAC  '\n         DC    C'LLWA    '\n         DC    C'LMRKTSO '\n         DC    C'LOBFREXT'\n         DC    C'LOCATE  '\n         DC    C'LOCKTERM'\n         DC    C'LOGOPTS '\n         DC    C'LOOK    '\n         DC    C'LOOKJ   '\n         DC    C'LOOKN   '\n         DC    C'LOOKNBAD'\n         DC    C'LOOKX   '\n         DC    C'LPQ     '\n         DC    C'LPR     '\n         DC    C'LPRM    '\n         DC    C'LPROC   '\n         DC    C'LSLT    '\n         DC    C'LU      '\n         DC    C'LWATMGR '\n         DC    C'MAKEUSER'\n         DC    C'MERLIN  '\n         DC    C'MIMTSO  '\n         DC    C'MODDVIPA'\n         DC    C'MU      '\n         DC    C'MVPMAIN '\n         DC    C'MVPXDISP'\n         DC    C'MVSCPCMD'\n         DC    C'NAMEDXFR'\n         DC    C'NAMED4  '\n         DC    C'NDVRC1  '\n         DC    C'NETSTAT '\n         DC    C'NSUPDATE'\n         DC    C'NSUPDAT4'\n         DC    C'NUL8    '\n         DC    C'NYPPW   '\n         DC    C'OC      '\n         DC    C'OMPROUTE'\n         DC    C'OP      '\n         DC    C'OPER    '\n         DC    C'OPERA   '\n         DC    C'OPERATOR'\n         DC    C'OPINFO  '\n         DC    C'OPING   '\n         DC    C'OPSCMD  '\n         DC    C'OPSCONSL'\n         DC    C'OPSOSCMD'\n         DC    C'OPSPARM '\n         DC    C'OPSREPLY'\n         DC    C'OPSTAT  '\n         DC    C'OPSWTO  '\n         DC    C'OSASK   '\n         DC    C'OSCMD   '\n         DC    C'OSNMPD  '\n         DC    C'OSWTO   '\n         DC    C'OTRACERT'\n         DC    C'PACKRAT '\n         DC    C'PARMLIB '\n         DC    C'PASSWORD'\n         DC    C'PDIR    '\n         DC    C'PDSCLEAN'\n         DC    C'PDSEAUTH'\n         DC    C'PDS38   '\n         DC    C'PE      '\n         DC    C'PERMDIR '\n         DC    C'PERMFILE'\n         DC    C'PERMIT  '\n         DC    C'PF      '\n         DC    C'PHRASE  '\n         DC    C'PING    '\n         DC    C'POPPER  '\n         DC    C'PPTD    '\n         DC    C'PPTSCAN '\n         DC    C'PRELOAD '\n         DC    C'PRINT   '\n         DC    C'PRSMINFO'\n         DC    C'PW      '\n         DC    C'Q       '\n         DC    C'QUEUE   '\n         DC    C'Q522    '\n         DC    C'RACDCERT'\n         DC    C'RACFSIM '\n         DC    C'RACLINK '\n         DC    C'RACONVRT'\n         DC    C'RACPRIV '\n         DC    C'RALT    '\n         DC    C'RALTER  '\n         DC    C'RDEF    '\n         DC    C'RDEFINE '\n         DC    C'RDEL    '\n         DC    C'RDELETE '\n         DC    C'RE      '\n         DC    C'RECEIVE '\n         DC    C'RECONLIM'\n         DC    C'RELOGON '\n         DC    C'REMOVE  '\n         DC    C'REPRO   '\n         DC    C'RESOLVE '\n         DC    C'REVIEW  '\n         DC    C'REVVSAM '\n         DC    C'REXCPCMD'\n         DC    C'RL      '\n         DC    C'RLIST   '\n         DC    C'RLOAD   '\n         DC    C'RLOADA  '\n         DC    C'RMM     '\n         DC    C'RPF     '\n         DC    C'RPFE    '\n         DC    C'RSH     '\n         DC    C'RSHD    '\n         DC    C'RVARY   '\n         DC    C'SAMENDM '\n         DC    C'SCRSIZE '\n         DC    C'SDSF    '\n         DC    C'SE      '\n         DC    C'SEARCH  '\n         DC    C'SECURE  '\n         DC    C'SEE     '\n         DC    C'SEND    '\n         DC    C'SEND@   '\n         DC    C'SETC    '\n         DC    C'SETCACHE'\n         DC    C'SETPASSW'\n         DC    C'SETPW   '\n         DC    C'SETPW2  '\n         DC    C'SETR    '\n         DC    C'SETROPTS'\n         DC    C'SETUSER '\n         DC    C'SHCDS   '\n         DC    C'SHOWPPT '\n         DC    C'SHOWTCAS'\n         DC    C'SHOWTPVT'\n         DC    C'SM      '\n         DC    C'SMTP    '\n         DC    C'SNTPD   '\n         DC    C'SPACE   '\n         DC    C'SPFCOPY '\n         DC    C'SPSWT   '\n         DC    C'SPY     '\n         DC    C'SR      '\n         DC    C'SRDIR   '\n         DC    C'SRF     '\n         DC    C'SRFILE  '\n         DC    C'SRSTAT  '\n         DC    C'STEPLIB '\n         DC    C'STEPLIBG'\n         DC    C'STEPLIBN'\n         DC    C'STEPLIB4'\n         DC    C'SU      '\n         DC    C'SYNC    '\n         DC    C'SYSPROG '\n         DC    C'TEAEXTSO'\n         DC    C'TERM    '\n         DC    C'TERMINAL'\n         DC    C'TERMSZ  '\n         DC    C'TESTA   '\n         DC    C'TESTAUTH'\n         DC    C'TMONCICS'\n         DC    C'TMONDB2 '\n         DC    C'TMONIMS '\n         DC    C'TMONMVS '\n         DC    C'TRACERTE'\n         DC    C'TRANSMIT'\n         DC    C'TRAPFWD '\n         DC    C'TRMD    '\n         DC    C'TSOENQ  '\n         DC    C'TSOSMS  '\n         DC    C'TSUB    '\n         DC    C'TSVT8   '\n         DC    C'UACEE   '\n         DC    C'UCB     '\n         DC    C'UGRP    '\n         DC    C'UKEYCSA '\n         DC    C'ULWA    '\n         DC    C'UPRC    '\n         DC    C'USAT    '\n         DC    C'USERMAX '\n         DC    C'USET    '\n         DC    C'USIT    '\n         DC    C'USOT    '\n         DC    C'USPT    '\n         DC    C'USUR    '\n         DC    C'USUT    '\n         DC    C'USWT    '\n         DC    C'USXT    '\n         DC    C'USYNC   '\n         DC    C'USYT    '\n         DC    C'USZT    '\n         DC    C'UTSB    '\n         DC    C'VERIFY  '\n         DC    C'VFY     '\n         DC    C'VIEWUSER'\n         DC    C'VLFNOTE '\n         DC    C'VMCF    '\n         DC    C'VU      '\n         DC    C'WAITT   '\n         DC    C'WHEREIS '\n         DC    C'WHOENQ  '\n         DC    C'WHOIS   '\n         DC    C'WSSTAT  '\n         DC    C'XD      '\n         DC    C'XDCCALLA'\n         DC    C'XDCCMDA '\n         DC    C'XF      '\n         DC    C'XMDSMAIN'\n         DC    C'XMIT    '\n         DC    C'XTRCUSER'\n         DC    C'XU      '\n         DC    C'YKCONMSG'\n         DC    C'ZAP     '\n         DC    C'ZAP$    '\n         DC    C'ZAPDSCB '\n         DC    C'ZAPLWA  '\n         DC    C'ZAPV    '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\nIKJEFTE8 CSECT\n         DC    C'IKJEFTE8'\n         DC    C'85.092  '\n         ENTRY APFPTABL\nAPFPTABL DC    C'ADB2ATH '\n         DC    C'ADB2UTIL'\n         DC    C'ADRDSSU '\n         DC    C'ALPAUTH '\n         DC    C'APCACBL '\n         DC    C'APCANB  '\n         DC    C'APCARB  '\n         DC    C'APCAUB  '\n         DC    C'APFPGM  '\n         DC    C'ARMAUTH '\n         DC    C'COMMAND '\n         DC    C'COMMND  '\n         DC    C'CONSPROF'\n         DC    C'CSFDAUTH'\n         DC    C'CSFDPKDS'\n         DC    C'CTMAES  '\n         DC    C'CTMDFL  '\n         DC    C'CTMRUN  '\n         DC    C'CTRCTR  '\n         DC    C'CTRSPL  '\n         DC    C'DISKMAP '\n         DC    C'EDGAUD  '\n         DC    C'EDGHSKP '\n         DC    C'EDGRPTD '\n         DC    C'EDGUTIL '\n         DC    C'EMCICS61'\n         DC    C'EMCSNAP '\n         DC    C'EMCTF   '\n         DC    C'EMCTFU  '\n         DC    C'EQQMINOR'\n         DC    C'ERWMAUTH'\n         DC    C'FDRABR  '\n         DC    C'FDRABRUT'\n         DC    C'FDRCPK  '\n         DC    C'FDREPORT'\n         DC    C'FDRMONA '\n         DC    C'FDRPASA '\n         DC    C'FDRQUERY'\n         DC    C'FDRSRSA '\n         DC    C'FSYTPA00'\n         DC    C'GIMSMP  '\n         DC    C'GJTRUCBS'\n         DC    C'HESEVMI '\n         DC    C'ICADCFGS'\n         DC    C'ICADCT  '\n         DC    C'ICADDCT '\n         DC    C'ICADFTPD'\n         DC    C'ICADIKED'\n         DC    C'ICADPFTP'\n         DC    C'ICADSLOG'\n         DC    C'ICADSOCK'\n         DC    C'ICADSOXD'\n         DC    C'ICADSTAK'\n         DC    C'ICHDSM00'\n         DC    C'ICHUEX00'\n         DC    C'ICHUT100'\n         DC    C'ICHUT200'\n         DC    C'ICHUT400'\n         DC    C'IDCAMS  '\n         DC    C'IEBCOPY '\n         DC    C'IEHINIT '\n         DC    C'IEHMOVE '\n         DC    C'IEHPROGM'\n         DC    C'IFCEREP1'\n         DC    C'IKJEFF76'\n         DC    C'IOEAGFMT'\n         DC    C'IOEAGSLV'\n         DC    C'IOEBAK  '\n         DC    C'IOEBOS  '\n         DC    C'IOECM   '\n         DC    C'IOEDCEER'\n         DC    C'IOEDFSXP'\n         DC    C'IOEFTS  '\n         DC    C'IOEGRWAG'\n         DC    C'IOEMAPID'\n         DC    C'IOENEWAG'\n         DC    C'IOESALVG'\n         DC    C'IOESCOUT'\n         DC    C'IOESMBPW'\n         DC    C'IOEUDBG '\n         DC    C'IOEZADM '\n         DC    C'IRMAUTH '\n         DC    C'IRRDBU00'\n         DC    C'IRRDIP00'\n         DC    C'IRRDPI00'\n         DC    C'IRRDSC00'\n         DC    C'IRRUT100'\n         DC    C'IRRUT200'\n         DC    C'IRRUT400'\n         DC    C'IRRXUTI2'\n         DC    C'ITPENTER'\n         DC    C'IXCMIAPU'\n         DC    C'JCLSRB  '\n         DC    C'KEPSTCTO'\n         DC    C'KOBROUTR'\n         DC    C'KOBSPFAU'\n         DC    C'LISTDATA'\n         DC    C'LLAPRINT'\n         DC    C'LLASAC  '\n         DC    C'LOCKTERM'\n         DC    C'LWATMGR '\n         DC    C'MIMTSO  '\n         DC    C'MVPXDISP'\n         DC    C'NDVRC1  '\n         DC    C'OBROUTR '\n         DC    C'OBSPFAU '\n         DC    C'OLDCOPY '\n         DC    C'OMCICS  '\n         DC    C'OMEGAMON'\n         DC    C'OMSPFAU '\n         DC    C'PDSCLEAN'\n         DC    C'PDSCLEAR'\n         DC    C'PDSEAUTH'\n         DC    C'PDSFAST '\n         DC    C'PING    '\n         DC    C'PSIPCTL '\n         DC    C'RESOLVE '\n         DC    C'REVVSAM '\n         DC    C'REXCPCMD'\n         DC    C'SAMENDM '\n         DC    C'SCRAMRE '\n         DC    C'SDSF    '\n         DC    C'SHERCOMM'\n         DC    C'SHOWMVS '\n         DC    C'SHOWZOS '\n         DC    C'SYSPROG '\n         DC    C'TESTENQ '\n         DC    C'TMONMVS '\n         DC    C'TMSIOCAP'\n         DC    C'TMSSCR  '\n         DC    C'TSOENQ  '\n         DC    C'TSOSPA  '\n         DC    C'WHOENQ  '\n         DC    C'ZAPVIRT '\n         DC    C'ZSIZER  '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\nIKJEFTNS CSECT\n         DC    C'IKJEFTNS'\n         DC    C'76.033  '\n         ENTRY NSCPTABL\nNSCPTABL DC    X'0008'\n         DC    C'OPERATOR'\n         DC    X'0004'\n         DC    C'OPER    '\n         DC    X'0008'\n         DC    C'TERMINAL'\n         DC    X'0004'\n         DC    C'TERM    '\n         DC    X'0000'\n         DC    C'        '\n         DC    X'0000'\n         DC    C'        '\n         DC    X'0000'\n         DC    C'        '\n         DC    X'0000'\n         DC    C'        '\n         DC    X'0000'\n         DC    C'        '\n         DC    X'0000'\n         DC    C'        '\n         DC    X'0000'\n         DC    C'        '\n         DC    X'0000'\n         DC    C'        '\n         DC    X'0000'\n         DC    C'        '\n         DC    X'0000'\n         DC    C'        '\n         DC    X'FFFF'\nIKJEFTAP CSECT\n         DC    C'IKJEFTAP'\n         DC    C'86.120  '\n         ENTRY APFTTABL\nAPFTTABL DC    C'$$      '\n         DC    C'#       '\n         DC    C'@       '\n         DC    C'AAATHCHK'\n         DC    C'AACMD001'\n         DC    C'AACMD002'\n         DC    C'AACMD003'\n         DC    C'AACMD004'\n         DC    C'AACMD005'\n         DC    C'AACMD006'\n         DC    C'AACMD007'\n         DC    C'AACMD008'\n         DC    C'AACMD009'\n         DC    C'AACMD014'\n         DC    C'AACMD015'\n         DC    C'AACNG001'\n         DC    C'AACNG002'\n         DC    C'AACNG003'\n         DC    C'AAGRPUSR'\n         DC    C'AAPSWCHK'\n         DC    C'AAREP011'\n         DC    C'ADB2ATH '\n         DC    C'ADB2UTIL'\n         DC    C'ADRDSSU '\n         DC    C'APFCMD  '\n         DC    C'BACKUP  '\n         DC    C'BBSDTCPA'\n         DC    C'BCMNUPD '\n         DC    C'BDMNUPD '\n         DC    C'BFFLU   '\n         DC    C'CADU4804'\n         DC    C'CADU4805'\n         DC    C'CAT01IKB'\n         DC    C'CAZ2CTSO'\n         DC    C'CDFAUTH '\n         DC    C'CDSCB   '\n         DC    C'CSCCOPY '\n         DC    C'CSFDAUTH'\n         DC    C'CSFDPKDS'\n         DC    C'DISKMAP '\n         DC    C'EDGAUD  '\n         DC    C'EDGHSKP '\n         DC    C'EDGRPTD '\n         DC    C'EDGUTIL '\n         DC    C'EMCICS61'\n         DC    C'EMCSNAP '\n         DC    C'EMCTF   '\n         DC    C'EMCTFU  '\n         DC    C'EOUCCSYM'\n         DC    C'EQQMINOR'\n         DC    C'ERWMAUTH'\n         DC    C'EX      '\n         DC    C'FDRABR  '\n         DC    C'FDRABRUT'\n         DC    C'FDRCPK  '\n         DC    C'FDREPORT'\n         DC    C'FDRMONA '\n         DC    C'FDRPASA '\n         DC    C'FDRQUERY'\n         DC    C'FDRSRSA '\n         DC    C'FMNSMF  '\n         DC    C'GIMSMP  '\n         DC    C'GJTRUCBS'\n         DC    C'IAMRECVR'\n         DC    C'IAMXMONA'\n         DC    C'ICADCFGS'\n         DC    C'ICADCT  '\n         DC    C'ICADDCT '\n         DC    C'ICADFTPD'\n         DC    C'ICADIKED'\n         DC    C'ICADPFTP'\n         DC    C'ICADSLOG'\n         DC    C'ICADSOCK'\n         DC    C'ICADSOXD'\n         DC    C'ICADSTAK'\n         DC    C'ICHDSM00'\n         DC    C'ICHUT100'\n         DC    C'ICHUT200'\n         DC    C'ICHUT400'\n         DC    C'ICQASLI0'\n         DC    C'IEBCOPY '\n         DC    C'IKJEFF76'\n         DC    C'IM      '\n         DC    C'IOEAGFMT'\n         DC    C'IOEAGSLV'\n         DC    C'IOEBAK  '\n         DC    C'IOEBOS  '\n         DC    C'IOECM   '\n         DC    C'IOEDCEER'\n         DC    C'IOEDFSXP'\n         DC    C'IOEFTS  '\n         DC    C'IOEGRWAG'\n         DC    C'IOEMAPID'\n         DC    C'IOENEWAG'\n         DC    C'IOESALVG'\n         DC    C'IOESCOUT'\n         DC    C'IOEUDBG '\n         DC    C'IOEZADM '\n         DC    C'IRRDPI00'\n         DC    C'IRRDSC00'\n         DC    C'IRRUT100'\n         DC    C'IRRUT200'\n         DC    C'IRRUT400'\n         DC    C'IRRXUTI2'\n         DC    C'JCLSRB  '\n         DC    C'LLAPRINT'\n         DC    C'LLASAC  '\n         DC    C'LSLT    '\n         DC    C'LWATEDIT'\n         DC    C'LWATMGR '\n         DC    C'MIMTSO  '\n         DC    C'MNAPFPRC'\n         DC    C'MNCDTPRC'\n         DC    C'MNCD2PRC'\n         DC    C'MNGRPPRC'\n         DC    C'MNLLTPRC'\n         DC    C'MNLPAPRC'\n         DC    C'MNPPTPRC'\n         DC    C'MNRACPRC'\n         DC    C'MNRAUPRC'\n         DC    C'MNRFRPRC'\n         DC    C'MNSMFPRC'\n         DC    C'MNSM4PRC'\n         DC    C'MNSTCPRC'\n         DC    C'MNSVCPRC'\n         DC    C'MXI     '\n         DC    C'MXITSF  '\n         DC    C'NDVRC1  '\n         DC    C'OBROUTR '\n         DC    C'OBSPFAU '\n         DC    C'OLDCOPY '\n         DC    C'OMCICS  '\n         DC    C'OMEGAMON'\n         DC    C'OMSPFAU '\n         DC    C'PDSCLEAN'\n         DC    C'PDSEAUTH'\n         DC    C'PDSFAST '\n         DC    C'PMGLAUTH'\n         DC    C'PSIPCTL '\n         DC    C'PTLTSRB '\n         DC    C'RCFRESET'\n         DC    C'REATSF  '\n         DC    C'SAMENDM '\n         DC    C'TMONMVS '\n         DC    C'TMSIOCAP'\n         DC    C'TMSSCR  '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         YREGS\n         END\n//LKED.SYSLIN  DD *\n INCLUDE SYSLIBX\n ORDER   IKJEFTE2(P),IKJEFTE8,IKJEFTNS,IKJEFTAP\n MODE    RMODE(24),AMODE(24)\n SETCODE AC(1)\n ENTRY   IKJEFTAP\n ALIAS   IKJEFTAP,IKJEFTE2,IKJEFTE8,IKJEFTNS\n NAME    IKJTABLS(R)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ASUB": {"ttr": 2311, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0f\\x007\\x01\\x06\\x01\\x8f\\x01\\x160O\\x17T\\x07c\\x04)\\x00\\x00```````@@@'", "ispf": {"version": "01.15", "flags": 0, "createdate": "2006-01-18T00:00:00", "modifydate": "2016-10-30T17:54:37", "lines": 1891, "newlines": 1065, "modlines": 0, "user": "-------"}, "text": "ASUB     TITLE 'ASUB - FILL IN ANY SLOT OF THE INCORE TSO AUTH TABLES'\n         SPACE 1\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*   Program Name:   ASUB                                              *\n*                                                                     *\n*  Documentation:   This program is meant to be run as a TSO          *\n*                   command, APF authorized, except for the display   *\n*                   functions.                                        *\n*                                                                     *\n*    Environment:   TSO command, APF Authorized.                      *\n*                   PUTLINE interface enabled by APUT, EPUTL.         *\n*                   This program is non-reentrant.                    *\n*                                                                     *\n*    Description:   Display an Auth Table entry from the TSO/E \"auth\" *\n*                   program list tables in storage.  Or display the   *\n*                   entire table.  Or replace one entry with a new    *\n*                   program name.  If you are invoking a display      *\n*                   function, then the entire table is shown, unless  *\n*                   you enter a number, and then, only that slot is   *\n*                   shown.  Only tables manufactured from PARMLIB     *\n*                   entries are displayed or changed, not the ones    *\n*                   created from IKJTABLS in LPALIB, or from the      *\n*                   IKJTABLS load module that was present in an       *\n*                   APF-authorized STEPLIB.                           *\n*                                                                     *\n*       Function:   To substitute one new program name in the global  *\n*                   incore TSO auth tables, IKJEFTE2, IKJEFTE8, or    *\n*                   IKJEFTAP, IKJEFTNS, or even to the PLATCMD or     *\n*                   PLATPGM lists, if they exist.  This is done to    *\n*                   any numbered entry of each table.  Or else merely *\n*                   display the contents of the entire table, or the  *\n*                   contents of any particular numbered entry.        *\n*                                                                     *\n*                   Also, a blanking function can be performed on     *\n*                   the last entry of any table, which is usually     *\n*                   blank anyway.  No blanking can be performed on    *\n*                   a slot in the middle of a table, because that     *\n*                   will invalidate all the table entries after the   *\n*                   blanked slot, and it is too dangerous to do,      *\n*                   when done irresponsibly.                          *\n*                                                                     *\n*         Syntax:   ASUB TTA nnn pgmname                              *\n*                                                                     *\n*                   Where TT is a table code, and A is an action      *\n*                   code.                                             *\n*                                                                     *\n*                   The table code is a nickname for any of the       *\n*                   TSO/E auth tables which are incore.  They are:    *\n*                                                                     *\n*                   E2 - IKJEFTE2 = AUTHCMD                           *\n*                   E8 - IKJEFTE8 = AUTHPGM                           *\n*                   AP - IKJEFTAP = AUTHTSF                           *\n*                   NS - IKJEFTNS = NOTBKGND                          *\n*                   PC - FCVE     = PLATCMD                           *\n*                   PP - PPVE     = PLATPGM                           *\n*                                                                     *\n*                   If the action code is B (blank the last           *\n*                   entry), then no program name is required.         *\n*                                                                     *\n*                   If the action code is D (display the last         *\n*                   entry), then no program name is required.         *\n*                   The default action is to display the entire       *\n*                   table, unless a number is entered.  If a          *\n*                   number is present, then only that entry           *\n*                   number is displayed.  If the number is larger     *\n*                   than the number of entries in that particular     *\n*                   table, then an informative error message is       *\n*                   issued, and the program ends with code = 4.       *\n*                                                                     *\n*                   If the action code is R (replace the program      *\n*                   name) then a number (the table entry number)      *\n*                   and a program name are required.  If you want     *\n*                   to blank the last slot, instead of putting a      *\n*                   program name into it, then use action code B.     *\n*                                                                     *\n*                   If the PLATCMD or PLATPGM keywords (and at least  *\n*                   one name) were not coded in the active IKJTSOxx   *\n*                   PARMLIB entry, then there is no control block of  *\n*                   names to be pointed to, and therefore no addition *\n*                   of names can be made.  The condition is reported. *\n*                                                                     *\n*             Note:  If an E2, E8, AP, or NS table which is being     *\n*                    used by the system, did not come from the        *\n*                    IKJTSOxx PARMLIB entry, but it came from the     *\n*                    default IKJTABLS entry in LPALIB, then an        *\n*                    appropriate error message is displayed, and      *\n*                    no action is performed on that table.            *\n*                                                                     *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*  Change Log:                                                        *\n*                                                                     *\n*    2007/10/21 - 1.0  - Initial version - Got it to work.            *\n*                                                                     *\n*    2009/03/04 - 1.14 - Measure the tables, list the lengths.        *\n*                        Count/display the number of entries and      *\n*                         perceived blanks.  Try to detect the true   *\n*                         end of table in storage, by measuring,      *\n*                         even though (for PARMLIB-created tables)    *\n*                         we have a listed length.                    *\n*                                                                     *\n*    2016/10/30 - 1.15 - Allow a table to validly show question       *\n*                         marks (?) in a table entry.                 *\n*                        So if you want to nullify a table entry      *\n*                         effectively, change the entry to a ?        *\n*                         using the \"xxR\" function.  And \"xxD\"        *\n*                         will show the result accurately.            *\n*                        I don't want to put all the functionality    *\n*                         from TSUB into this program, because this   *\n*                         program affects the whole LPAR, whereas     *\n*                         TSUB only affects the owning TSO id.        *\n*                                                                     *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*       I N S T R E A M    M A C R O S                                *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n         YREGS\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*  ---------------------------------------------------------------  *\n*    This macro is used to display hex values in a printed report.  *\n*  ---------------------------------------------------------------  *\n         MACRO\n&NAME    HEX   &TO,&LEN,&FROM\n&NAME    DS    0H\n         STM   R15,R1,HEXSAVE\n         LA    R1,&FROM\n         LA    R0,&LEN\n         LA    R15,&TO\n         BAL   R9,HEX\n         LM    R15,R1,HEXSAVE\n         MEND\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n* ------------------------------------------------------------------- *\n         MACRO\n&LABEL   APUT  &MSG,                    @MESSAGE TEXT                  &\n               &LEN,                    @LENGTH OF MESSAGE             &\n               &RSA=,                   OPTIONAL 2 WORD SAVE AREA      &\n               &EPA=                    EPUTL EPA\n.*\n.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*\n.*  --> E@PUT\n.*\n.*  THIS MACRO SETS UP A PARAMETERS AND INVOKES THE EPUTL ROUTINE.\n.*\n.*\n.*  ARGUMENTS: -----------------------------------------------------\n.*\n.*      &MSG : ADDRESS OF MESSAGE TEXT OR A LITERAL\n.*\n.*      &LEN : LENGTH OF MESSAGE TEXT (DEFAULT IS L'&MSG)\n.*\n.*      &RSA :(OPTIONAL) 1 WORD SAVE AREA TO PRESERVE R14 FOR TPUT\n.*            COMPATIBILITY.\n.*\n.*      &EPA :(OPTIONAL) EPA FOR EPUTL ROUTINE\n.*\n.*\n.*   EXAMPLES: -----------------------------------------------------\n.*\n.*      1) APUT  'LITERAL'\n.*\n.*      2) APUT  (R3),80\n.*\n.*      3) APUT  LABEL\n.*\n.*      4) APUT  LABEL,40\n.*\n.*\n.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*\n.*\n.*  LOCAL SET SYMBOLS\n.*\n         LCLC  &SMA                     MESSAGE ADDRESS (REG)\n         LCLC  &SML                     MESSAGE LENGTH (REG)\n         LCLC  &SEP                     EPA (REGISTER)\n.*\n         LCLC  &L1,&L2,&L3              LOCAL LABELS\n.*\n&L1      SETC  'EP'.'&SYSNDX'.'L1'      LOCAL LABELS\n&L2      SETC  'EP'.'&SYSNDX'.'L2'      LOCAL LABELS\n&L3      SETC  'EP'.'&SYSNDX'.'L3'      LOCAL LABELS\n.*\n.*\n.*  MESSAGE ADDRESS\n.*\n         AIF   (T'&LABEL EQ 'O').A0500                      *HMD 11/86*\n.*                                                          *HMD 11/86*\n&LABEL   DS    0H                                           *HMD 11/86*\n.*                                                          *HMD 11/86*\n.A0500   ANOP                                               *HMD 11/86*\n         AIF   ('&MSG' NE '').A2000\n         MNOTE 8,'''&MSG='' MISSING / REQUIRED'\n         MEXIT\n.*\n.A2000   ANOP\n         AIF   ('&MSG'(1,1) NE '(').A2400\n&SMA     SETC  '&MSG'(2,K'&MSG-2)\n         LR    R1,&SMA                  @MESSAGE TEXT\n         AGO   .A2600\n.*\n.A2400   ANOP\n         AIF   ('&MSG'(1,1) NE '''').A2500\n         B     &L3                      BRANCH AROUND MESSAGE\n&L2      DC    C&MSG\n&L3      DS    0H\n         LA    R1,&L2                   @MESSAGE\n         AGO   .A2600\n.*\n.A2500   ANOP\n         LA    R1,&MSG                  @MESSAGE TEXT\n.A2600   ANOP\n.*\n.*  MESSAGE LENGTH\n.*\n         AIF   ('&LEN' NE '').A3000\n         AIF   ('&MSG'(1,1) NE '''').A2800\n         LA    R0,L'&L2                 MESSAGE LENGTH\n         AGO   .A3600\n.*\n.A2800   ANOP\n         AIF   ('&MSG'(1,1) EQ '(').A2900\n         LA    R0,L'&MSG                MESSAGE LENGTH\n         AGO   .A3600\n.*\n.A2900   ANOP\n         MNOTE 8,'''LEN'' MISSING / REQUIRED'\n         MEXIT\n.*\n.A3000   ANOP\n         AIF   ('&LEN'(1,1) NE '(').A3400\n&SML     SETC  '&LEN'(2,K'&LEN-2)\n         LR    R0,&SML                  MESSAGE LENGTH\n         AGO   .A3600\n.*\n.A3400   ANOP\n         LA    R0,&LEN                  MESSAGE LENGTH\n.A3600   ANOP\n.*\n.*  RSA\n.*\n         AIF   ('&RSA' EQ '').A4900\n         ST    R14,&RSA                 SAVE REGS 14\n.A4900   ANOP\n.*\n.*  ENTRY POINT\n.*\n         AIF   ('&EPA' NE '').A5000\n         L     R15,=V(EPUTL)            EPA\n         AGO   .A5600\n.*\n.A5000   AIF   ('&EPA'(1,1) NE '(').A5400\n&SEP     SETC  '&EPA'(2,K'&EPA-2)\n         LR    R15,&SEP                 EPA\n         AGO   .A5600\n.*\n.A5400   ANOP\n         L     R15,&EPA                 EPA\n.*\n.A5600   ANOP\n.*\n.*  CALL LINKAGE\n.*\n.ACALL   BALR  R14,R15                  CALL PUTLINE ROUTINE\n.*\n         AIF   ('&RSA' EQ '').A6900\n         L     R14,&RSA                 RESTORE R14\n.A6900   ANOP\n.*\n.AMEND   MEND\n* ------------------------------------------------------------------- *\nASUB     CSECT\nASUB     AMODE 31\nASUB     RMODE 24\n         USING *,R15                                                  *  01493\n         B     BEGINN                   Eyecatcher\n         DC    CL8'ASUB  - '\nVERS#    DC    CL10'Ver 1.15'\n         DC    CL1' '\n         DC    CL16' &SYSDATE &SYSTIME '\n         DC    CL6'HLASM '\n         DC    C'&SYSVER'\n         DC    C' '\nBEGINN   DS    0H\n         DROP  R15\n         USING ASUB,R12,R11,R10\n         STM   R14,R12,12(R13)\n         LR    R12,R15                  Set up base registers.\n         ST    R1,SAVEPARM              Save CPPL pointer\n         LA    R11,4095(,R12)\n         LA    R11,1(,R11)\n         LA    R10,4095(,R11)\n         LA    R10,1(,R10)\n         LA    R1,SAVEAREA          Point to new save area               01508\n         ST    R1,8(,R13)           Forward save area chain pointer      01509\n         ST    R13,4(,R1)           Backward save area chain pointer     01510\n         LR    R13,R1               New save area address                01511\n         B     INITCON              Branch past save area\n         SPACE 1\n* -----------------------\nSAVEAREA DC    18F'0'                                                    01504\n* -----------------------\nINITCON  DS    0H                   Initialize constants\n         MVI   OFFFLAG,X'00'\n         MVI   PLATFLG,X'00'\n         MVI   NSCHFLG,X'00'\n         MVI   LINEB,X'40'\n         MVC   CODEPLAC(2),BLANKS\n         XC    FSTCOUNT,FSTCOUNT\n         XC    FSTNOUNT,FSTNOUNT\n         MVC   FSTFIELD(8),BLANKS\n         MVI   BLANKS-1,X'40'\n         MVC   BLANKS,BLANKS-1\n         XC    BLNKCNT,BLNKCNT      Zero the counters\n         XC    NTRYCNT,NTRYCNT\n         XC    SLOTBIN,SLOTBIN\n         MVC   SLOTSAVE,BLANKS\n         MVC   FSTNAME,BLANKS\n         MVI   CMDBCOPY-1,X'00'\n         MVC   CMDBCOPY,CMDBCOPY-1\n* -----------------------\n         L     R2,16               POINT TO CVT.\n         L     R2,0(,R2)           POINT TO TCB/ASCB WORDS\n         L     R2,4(,R2)           POINT TO TCB.\n         L     R2,X'B4'(,R2)       POINT TO JSCB.\n         L     R2,X'108'(,R2)      POINT TO PSCB.\n         LA    R2,0(,R2)           CLEAR HIGH BYTE.\n         LTR   R2,R2               ANY PSCB?\n         BZ    EOJ4                GET OUT.  NOT TSO.\n         L     R1,SAVEPARM         Get the address of the CPPL back\n         USING CPPL,R1\n         L     R0,CPPLUPT          Copy CPPL fields for possible\n         ST    R0,SAVEUPT            later use, if needed.\n         L     R0,CPPLPSCB\n         ST    R0,SAVEPSCB\n         L     R0,CPPLECT\n         ST    R0,SAVEECT\n         LA    R6,0\n         DROP  R1\n         BAL   R9,PGMTITLE         First display the program title.\n         USING PSCB,R2\nCHEKAUTH DS    0H\n*        B     CONT0               Bypass authorization check\n         TM    PSCBATR1,PSCBACCT   ACCT user?\n         BO    CONT0               Yes.  Continue.\n         TM    PSCBATR1,PSCBCTRL   OPER user?\n         BZ    EOJ4                No.  Get out.\n         DROP  R2\nCONT0    DS    0H                  Get starting addresses for tables\n         L     R2,16               Point to CVT\n         L     R2,X'9C'(,R2)       Point to TSVT (TSO Vector Table)\n         L     R2,X'4C'(,R2)       Point to TPVT\n         ST    R2,SAVETPVT         Save TPVT address for later use\n         L     R2,X'14'(,R2)       Point to CTLT control block\n         ST    R2,SAVECTLT         Save CTLT address for later use\n         L     R2,SAVETPVT         Load TPVT address back\n         L     R2,X'34'(,R2)       Point to PLATCMD pointer\n         LTR   R2,R2               Is there any?\n         BZ    NOFCVE              No. Say so.\n         ST    R2,SAVEFCVE         Yes. Store the FCVE pointer away.\n         OI    PLATFLG,X'01'       Indicate that FCVE exists.\nTRYPPVE  DS    0H\n         L     R2,SAVETPVT         Load TPVT address back\n         L     R2,X'40'(,R2)       Point to PLATPGM pointer\n         LTR   R2,R2               Is there any?\n         BZ    NOPPVE              No. Say so.\n         ST    R2,SAVEPPVE         Yes. Store the PPVE pointer away.\n         OI    PLATFLG,X'02'       Indicate that PPVE exists.\nTRYPPVEE DS    0H\n* ------\n*    There doesn't seem to be a way to tell from an old INMXPARM\n*    control block itself, that it is the old version.  So we use\n*    the position of the active PARMLIB member name in the TPVT.\n* ------\n         L     R2,SAVETPVT         Load TPVT address back.\n         CLC   =C'IKJ',7(R2)       Parmlib member name in old position?\n         BNE   NEWSYSTM            No. It's a new TSO/E version\n         OI    OLDFLAG,X'01'       Yes. Flag that the system is old.\nNEWSYSTM DS    0H\n* ------\n*    We start scanning for PARMs here.\n* ------\n         L     R1,SAVEPARM         Original R1 from entry to program.\n         LTR   R1,R1               Any CPPL?\n         BZ    EOJ8                No. Get out.\n         L     R1,0(,R1)           Point to Command Buffer\n         LTR   R1,R1               Any Command Buffer?\n         BZ    EOJ4                Get out if none.\n         LH    R3,0(,R1)           Load length.\n         CH    R3,=H'4'            Anything?\n         BNH   EOJ4                No.  Get out.\n         LR    R5,R3               Length of command + 4\n         ICM   R5,14,FULLZERO      Clear high order 3 bytes.\n         ST    R1,CMBUFAD          Save Command Buffer Address\n         LH    R3,2(,R1)           Load offset.\n         ST    R3,OFFSETSV\n         SR    R5,R3               Subtract offset from full length+4\n         SH    R5,=H'4'            Correct for length of CMDBUFR header\n*                                  in the command buffer.\n         BC    8,EOJC              Zero, Message\n         BC    5,EOJC              Less, or overflow, out.\n         ST    R5,CMBUFEND         Store away the number of bytes left\n         L     R1,CMBUFAD          Load Command Buffer Address\n*\n* ----  Copy command buffer into pgm's buffer so we can control it.\n*\n         STM   R14,R1,SAVE1401     Now save registers 14 thru 1.\n         XR    R14,R14             Clear R14.\n         LH    R14,0(,R1)          Load full command buffer length.\n         S     R14,=F'5'           Subtract 4 for header, 1 for execute\n         EX    R14,COPYCMDB        Copy command into pgm's area.\n         LM    R14,R1,SAVE1401     Restore registers 14 thru 1.\n         B     GOGOGO              Jump over executed instruction.\nCOPYCMDB MVC   CMDBCOPY(0),4(R1)   <<< Executed >>>\nGOGOGO   DS    0H\n* ----\n         LA    R6,3                Load register for BCT loop.\n* >>>\n         LA    R1,CMDBCOPY         Point to command in our buffer\n         A     R1,OFFSETSV         Add offset, point to subcommands\n         ST    R1,CHARSTRT         Store starting point away\n* >>>\n         LR    R7,R1               Initialize pointer\n         LA    R7,0(,R7)           to first character of function name.\n         LA    R8,0                Initialize character count\nCUTIDLEN CLI   0(R7),X'40'         Is this character a blank?\n         BE    AFTFIRST            Yes, end of the first parm.\n         CLI   0(R7),X'00'         Is this character hex zero?\n         BE    AFTFIRST            Yes, end of command in buffer copy.\n         LA    R7,1(,R7)           Bump another character\n         LA    R8,1(,R8)           Count another character\n         CR    R8,R5               End of command buffer ?\n         BNL   AFTFIRST            Yes. Get out now.\n         BCT   R6,CUTIDLEN         Try for blank again.\nAFTFIRST DS    0H\n         MVC   TABCODE(8),BLANKS   Clear field\n         BCTR  R8,0                Subtract 1 for execute.\n         L     R1,CHARSTRT         Reload R1 to be sure it's correct.\n         EX    R8,MOVOUTL          Move entered parameter to program.\n         LA    R8,1(,R8)           Restore number of characters\n         AR    R1,R8               Point past last search\n         ST    R1,CHARCONT         Continue from here\n         ST    R8,SAVER8           Save\n         ST    R6,SAVER6             the\n         ST    R1,SAVER1A              registers\n* ---- >\nSEEIFPRM DS    0H                  Check if a command is here\n         OC    TABCODE(3),BLANKS   Uppercase. Won't affect numbers\n         CLI   TABCODE+2,C'R'      Replace the entry in the given slot\n         BE    SEEIF0A1\n         CLI   TABCODE+2,C'B'      Blank the last slot\n         BE    SEEIF0A2\n         CLI   TABCODE+2,C'D'      Display contents of last slot\n         BE    SEEIF0A3\n         B     SEEIF000\nSEEIF0A1 DS    0H\n         OI    OFFFLAG,X'01'       Replace an entry\n         B     SEEIF001\nSEEIF0A2 DS    0H\n         OI    OFFFLAG,X'02'       Blank entry in the last slot\n         B     SEEIF001\nSEEIF0A3 DS    0H\n         OI    OFFFLAG,X'04'       Display an entry or entries\n         B     SEEIF001\nSEEIF000 DS    0H                  Wrong function code was entered...\n* --- >                            Display what we entered, plus code\n         MVC   LINE,LINEB          Clear line\n         MVC   LINE(3),TABCODE     Move code in\n         HEX   LINE+6,1,OFFFLAG    Display contents of flag\n         MVC   LINE+13(35),=C'Program table name + Function code '\n         APUT  LINE,48\n* --- >\n         BAL   R9,ERRORCOD         Indicate error and display syntax.\n         B     EOJ4                Get out with code = 4.\nSEEIF001 DS    0H                  Which table to change\n         MVC   CODEPLAC(2),TABCODE\n* --- >                            Display what we entered, plus code\n         MVC   LINE,LINEB          Clear line\n         MVC   LINE(3),TABCODE     Move code in\n         HEX   LINE+6,1,OFFFLAG    Display contents of flag\n         MVC   LINE+13(35),=C'Program table name + Function code '\n         APUT  LINE,48\n* --- >                            Handle each table separately.\n         CLC   TABCODE(2),=C'E2'   Change IKJEFTE2?\n         BE    E2CHANGE            Yes. Branch.\n         CLC   TABCODE(2),=C'E8'   Change IKJEFTE8?\n         BE    E8CHANGE            Yes. Branch.\n         CLC   TABCODE(2),=C'AP'   Change IKJEFTAP?\n         BE    APCHANGE            Yes. Branch.\n         CLC   TABCODE(2),=C'PC'   Change PLATCMD?\n         BE    PCCHANGE            Yes. Branch.\n         CLC   TABCODE(2),=C'PP'   Change PLATPGM?\n         BE    PPCHANGE            Yes. Branch.\n         CLC   TABCODE(2),=C'NS'   Change IKJEFTNS?\n         BE    NSCHANGE            Yes. Branch.\n         BAL   R9,ERRORCOD         Indicate error and display syntax.\n         B     EOJ4                Invalid code entered.\nEOJ      DS    0H                  END OF JOB                            04216\n         L     R13,4(,R13)                                               04214\n         LR    R15,R5              Put in real return code\n         ST    R15,16(,R13)        Shove it where it belongs\n         L     R14,12(,R13)        R14 and\n         LM    R0,R12,20(R13)        rest of registers\n         BR    R14                 Go back to caller\nEOJ0     DS    0H                  Return code 0\n         MVC   LINE,LINE-1         Clear output area\n         MVC   LINE,MESSAGR0       Show Return Code 0\n         APUT  MESSAGR0,L'MESSAGR0\n         LA    R5,0                Set CC = 0\n         B     EOJ                 Now end the program\nEOJ4     DS    0H                  Return code 4\n         MVC   LINE,LINE-1         Clear output area\n         MVC   LINE,MESSAGR4       Show Return Code 4\n         APUT  LINE,L'MESSAGR4\n         L     R5,FULLFOUR         Set CC = 4                            04215\n         B     EOJ                 Now end the program\nEOJ8     DS    0H                  Return code 8\n         MVC   LINE,LINE-1         Clear output area\n         MVC   LINE,MESSAGR8       Show Return Code 8\n         APUT  LINE,L'MESSAGR8\n         L     R5,FULLEIGT         Set CC = 8                            04215\n         B     EOJ                 Now end the program\nEOJC     DS    0H                  Return code 12\n         MVC   LINE,LINE-1         Clear output area\n         MVC   LINE,MESSAGRC       Show Return Code 12\n         APUT  LINE,L'MESSAGRC\n         L     R5,FULLTWLV         Set CC = 12\n         B     EOJ                 Now end the program\n** ---------------------------------------------------------------- **\nNOTAUTH  DS    0H                     Command not authorized message.\n         APUT  MESSAG2C,L'MESSAG2C\n         APUT  MESSAG2D,L'MESSAG2D\n         B     EOJC\nE2CHANGE DS    0H                 Handle the E2 table\n         BAL   R9,ADJNEXTP\n         BAL   R9,NAMEPARM\n         L     R2,SAVECTLT\n         LR    R4,R2\n         LA    R4,X'8'(,R4)       POINT TO E2 TABLE\n         L     R4,0(,R4)\n* - -\n         ST    R4,TABLSTRT        Store start address of table\n         ST    R4,TABLADDR        Store start address of table\n         BAL   R9,PRTBLADR        Display table address\n         L     R1,TABLSTRT\n**-->>\n         CLC   =C' PARMLIB',8(R1) Indicator this table is from PARMLIB.\n         BE    E2CHENTY           It is, then we're cool.\n         BAL   R9,MISSPGM3        It isn't, then send message saying so\n         B     EOJ4               And exit with code = 4.\nE2CHENTY DS    0H                 Table was made from a IKJTSOxx entry.\n**-->>\n         LA    R1,X'10'(,R1)      Bump past header\n         ST    R1,TABLSTRT        Store new start address\n* - -\n         L     R3,X'C'(,R2)       LOAD SIZE OF E2 TABLE\n         ST    R3,TABLELEN        Store listed table size\n         LTR   R3,R3              Is there any Parmlib-supplied one?\n         BZ    NOE2               No. Say so and get out.\n         AR    R4,R3              POINT JUST PAST E2 TABLE\n* - -\n         XR    R5,R5\n         LH    R5,X'10'(,R2)      Load number of entries in table\n         ST    R5,TABLENUM        Store number of entries\n         BAL   R9,MEASUR08        Measure the table\n         BAL   R9,LISTLNTH        Print lengths of table\n         BAL   R9,PRTNENTR        Print official number of entries\n* - -\n         XR    R5,R5\n         LH    R5,X'12'(,R2)      LOAD SIZE OF E2 ENTRY\n* - -\n         ST    R5,TABLESIZ        Store size of each entry\n* - -\n         SR    R4,R5              POINT TO LAST SLOT\n         ST    R4,SAVLSLOT\n         TM    OFFFLAG,X'04'      Is this just a contents display?\n         BZ    E2CHANGX           No. We must do a real change.\n         BAL   R9,DISPTABL        Yes. Just display.\n         BAL   R9,CHANGED         Message\n         B     EOJ0\nE2CHANGX DS    0H\n         BAL   R9,DISPTABL        Search table for the proper entry.\n         BAL   R9,SETTMODE        Do the Key 0 stuff\n         BAL   R9,CHANGED         Tell em we changed the values.\n         B     EOJ0\nE8CHANGE DS    0H                 Handle the E8 table\n         BAL   R9,ADJNEXTP\n         BAL   R9,NAMEPARM\n         L     R2,SAVECTLT\n         LR    R4,R2\n         LA    R4,X'14'(,R4)      POINT TO E8 TABLE\n         L     R4,0(,R4)\n* - -\n         ST    R4,TABLSTRT        Store start address of table\n         ST    R4,TABLADDR        Store start address of table\n         BAL   R9,PRTBLADR        Display table address\n         L     R1,TABLSTRT\n**-->>\n         CLC   =C' PARMLIB',8(R1) Indicator this table is from PARMLIB.\n         BE    E8CHENTY           It is, then we're cool.\n         BAL   R9,MISSPGM3        It isn't, then send message saying so\n         B     EOJ4               And exit with code = 4.\nE8CHENTY DS    0H                 Table was made from a IKJTSOxx entry.\n**-->>\n         LA    R1,X'10'(,R1)      Bump past header\n         ST    R1,TABLSTRT        Store new start address\n* - -\n         L     R3,X'18'(,R2)      Size of E8 table\n         ST    R3,TABLELEN        Store listed table size\n         LTR   R3,R3              Is there any Parmlib-supplied one?\n         BZ    NOE8               No. Say so and get out.\n         AR    R4,R3              POINT JUST PAST E8 TABLE\n* - -\n         XR    R5,R5\n         LH    R5,X'1C'(,R2)      Load number of entries in table\n         ST    R5,TABLENUM        Store number of entries\n         BAL   R9,MEASUR08        Measure the table\n         BAL   R9,LISTLNTH        Print lengths of table\n         BAL   R9,PRTNENTR        Print official number of entries\n* - -\n         XR    R5,R5\n         LH    R5,X'1E'(,R2)      LOAD SIZE OF E8 ENTRY\n* - -\n         ST    R5,TABLESIZ        Store size of each entry\n* - -\n         SR    R4,R5              POINT TO LAST SLOT\n         ST    R4,SAVLSLOT\n         TM    OFFFLAG,X'04'      Is this just a contents display?\n         BZ    E8CHANGX           No. We must do a real change.\n         BAL   R9,DISPTABL        Yes. Just display.\n         BAL   R9,CHANGED         Message\n         B     EOJ0\nE8CHANGX DS    0H\n         BAL   R9,DISPTABL        Search table for the proper entry.\n         BAL   R9,SETTMODE        Do the Key 0 stuff\n         BAL   R9,CHANGED         Tell em we changed the values.\n         B     EOJ0\nAPCHANGE DS    0H                 Handle the AP table\n         BAL   R9,ADJNEXTP\n         BAL   R9,NAMEPARM\n         L     R2,SAVECTLT\n         LR    R4,R2\n         LA    R4,X'2C'(,R4)      POINT TO AP TABLE\n         L     R4,0(,R4)\n* - -\n         ST    R4,TABLSTRT        Store start address of table\n         ST    R4,TABLADDR        Store start address of table\n         BAL   R9,PRTBLADR        Display table address\n         L     R1,TABLSTRT\n**-->>\n         CLC   =C' PARMLIB',8(R1) Indicator this table is from PARMLIB.\n         BE    APCHENTY           It is, then we're cool.\n         BAL   R9,MISSPGM3        It isn't, then send message saying so\n         B     EOJ4               And exit with code = 4.\nAPCHENTY DS    0H                 Table was made from a IKJTSOxx entry.\n**-->>\n         LA    R1,X'10'(,R1)      Bump past header\n         ST    R1,TABLSTRT        Store new start address\n* - -\n         L     R3,X'30'(,R2)      Size of AP table\n         ST    R3,TABLELEN        Store listed table size\n         LTR   R3,R3              Is there any Parmlib-supplied one?\n         BZ    NOAP               No. Say so and get out.\n         AR    R4,R3              POINT JUST PAST AP TABLE\n* - -\n         XR    R5,R5\n         LH    R5,X'34'(,R2)      Load number of entries in table\n         ST    R5,TABLENUM        Store number of entries\n         BAL   R9,MEASUR08        Measure the table\n         BAL   R9,LISTLNTH        Print lengths of table\n         BAL   R9,PRTNENTR        Print official number of entries\n* - -\n         XR    R5,R5\n         LH    R5,X'36'(,R2)      LOAD SIZE OF AP ENTRY\n* - -\n         ST    R5,TABLESIZ        Store size of each entry\n* - -\n         SR    R4,R5              POINT TO LAST SLOT\n         ST    R4,SAVLSLOT\n         TM    OFFFLAG,X'04'      Is this just a contents display?\n         BZ    APCHANGX           No. We must do a real change.\n         BAL   R9,DISPTABL        Yes. Just display.\n         BAL   R9,CHANGED         Message\n         B     EOJ0\nAPCHANGX DS    0H\n         BAL   R9,DISPTABL        Search table for the proper entry.\n         BAL   R9,SETTMODE        Do the Key 0 stuff\n         BAL   R9,CHANGED         Tell em we changed the values.\n         B     EOJ0\nPCCHANGE DS    0H                 Handle the PC table\n         TM    PLATFLG,X'01'\n         BZ    PCCHAERR\n         BAL   R9,ADJNEXTP\n         BAL   R9,NAMEPARM\n         L     R2,SAVEFCVE        Get the PC table address\n         LR    R4,R2              Save it off\n* -- >                            Do Display\n*        MVC   LINE,LINE-1\n         ST    R4,DISPREG\n*        HEX   LINE+13,4,DISPREG\n*        MVC   LINE(8),=C'SAVEFCVE'\n*        APUT  LINE,30\n* -- >\n         L     R3,X'8'(,R4)\n         ST    R3,TABLELEN        Store listed table size\n         AR    R4,R3              POINT JUST PAST PC TABLE\n* - -\n         L     R3,X'C'(,R2)\n         ST    R3,TABLENUM\n         LA    R3,8\n         ST    R3,TABLESIZ\n         L     R3,SAVEFCVE\n         ST    R3,TABLADDR        Store start address of table\n         BAL   R9,PRTBLADR        Display table address\n         BAL   R9,MEASUR08        Measure the table\n         BAL   R9,LISTLNTH        Print lengths of table\n         BAL   R9,PRTNENTR        Print official number of entries\n         LA    R3,X'10'(,R3)\n         ST    R3,TABLSTRT\n* - -\n         LA    R5,8\n         SR    R4,R5              POINT TO LAST SLOT\n         ST    R4,SAVLSLOT\n         TM    OFFFLAG,X'04'      Is this just a contents display?\n         BZ    PCCHANGX           No. We must do a real change.\n         BAL   R9,DISPTABL        Yes. Just display.\n         BAL   R9,CHANGED         Message\n         B     EOJ0\nPCCHANGX DS    0H\n         BAL   R9,DISPTABL        Search table for the proper entry.\n         BAL   R9,SETTMODE        Do the Key 0 stuff\n         BAL   R9,CHANGED         Tell em we changed the values.\n         B     EOJ0\nPCCHAERR DS    0H\n         MVC   LINE,LINE-1\n         MVC   LINE(43),=C'PC command not valid if no PC table exists.'\n         APUT  LINE,43\n         B     EOJ4\nPCCHAEND DS    0H\n         B     EOJ0\nPPCHANGE DS    0H                 Handle the PP table\n         TM    PLATFLG,X'02'\n         BZ    PPCHAERR\n         BAL   R9,ADJNEXTP\n         BAL   R9,NAMEPARM\n         L     R2,SAVEPPVE        Get the PP table address\n         LR    R4,R2              Save it off\n* -- >                            Do Display\n*        MVC   LINE,LINE-1\n         ST    R4,DISPREG\n*        HEX   LINE+13,4,DISPREG\n*        MVC   LINE(8),=C'SAVEPPVE'\n*        APUT  LINE,30\n* -- >\n         L     R3,X'8'(,R4)\n         ST    R3,TABLELEN        Store listed table size\n         AR    R4,R3              POINT JUST PAST PP TABLE\n* - -\n         L     R3,X'C'(,R2)\n         ST    R3,TABLENUM\n         LA    R3,8\n         ST    R3,TABLESIZ\n         L     R3,SAVEPPVE\n         ST    R3,TABLADDR        Store start address of table\n         BAL   R9,PRTBLADR        Display table address\n         BAL   R9,MEASUR08        Measure the table\n         BAL   R9,LISTLNTH        Print lengths of table\n         BAL   R9,PRTNENTR        Print official number of entries\n         LA    R3,X'10'(,R3)\n         ST    R3,TABLSTRT\n* - -\n         LA    R5,8\n         SR    R4,R5              POINT TO LAST SLOT\n         ST    R4,SAVLSLOT\n         TM    OFFFLAG,X'04'      Is this just a contents display?\n         BZ    PPCHANGX           No. We must do a real change.\n         BAL   R9,DISPTABL        Yes. Just display.\n         BAL   R9,CHANGED         Message\n         B     EOJ0\nPPCHANGX DS    0H\n         BAL   R9,DISPTABL        Search table for the proper entry.\n         BAL   R9,SETTMODE        Do the Key 0 stuff\n         BAL   R9,CHANGED         Tell em we changed the values.\n         B     EOJ0\nPPCHAERR DS    0H\n         MVC   LINE,LINE-1\n         MVC   LINE(43),=C'PP command not valid if no PP table exists.'\n         APUT  LINE,43\n         B     EOJ4\nPPCHAEND DS    0H\n         B     EOJ0\nNSCHANGE DS    0H                 Handle the NS table\n         BAL   R9,ADJNEXTP\n         BAL   R9,NAMEPARM\n         L     R2,SAVECTLT\n         OI    NSCHFLG,X'01'      Show SETTMODE we're doing NS\n         LR    R4,R2              Save location of CTLT\n         LA    R4,X'20'(,R4)      Point to NS table address\n         L     R4,0(,R4)          Point to NS table\n* - -\n         ST    R4,TABLSTRT        Store start address of table\n         ST    R4,TABLADDR        Store start address of table\n         BAL   R9,PRTBLADR        Display table address\n         L     R1,TABLSTRT\n**-->>\n         CLC   =C' PARMLIB',8(R1) Indicator this table is from PARMLIB.\n         BE    NSCHENTY           It is, then we're cool.\n         BAL   R9,MISSPGM3        It isn't, then send message saying so\n         B     EOJ4               And exit with code = 4.\nNSCHENTY DS    0H                 Table was made from a IKJTSOxx entry.\n**-->>\n         LA    R1,X'10'(,R1)\n         ST    R1,TABLSTRT        Store new start address\n* - -\n         L     R3,X'24'(,R2)      Load size of NS table\n         ST    R3,TABLELEN        Store listed table size\n         LTR   R3,R3              Is there any Parmlib-supplied one?\n         BZ    NONS               No. Say so and get out.\n         AR    R4,R3              Point just past NS table\n* - -\n         XR    R5,R5\n         LH    R5,X'28'(,R2)      Load number of entries in table\n         ST    R5,TABLENUM        Store number of entries\n         BAL   R9,MEASUR10        Measure the table\n         BAL   R9,LISTLNTH        Print lengths of table\n         BAL   R9,PRTNENTR        Print official number of entries\n* - -\n         XR    R5,R5              Clear register\n         LH    R5,X'2A'(,R2)      Load size of NS entry\n* - -\n         ST    R5,TABLESIZ        Store size of each entry\n* - -\n         SR    R4,R5              Point to Last Slot\n         ST    R4,SAVLSLOT        Save location of last slot\n         TM    OFFFLAG,X'04'      Is this just a contents display?\n         BZ    NSCHANGX           No. We must do a real change.\n         BAL   R9,DISPTABL        Yes. Just display.\n         BAL   R9,CHANGED         Message\n         B     EOJ0\nNSCHANGX DS    0H\n         BAL   R9,DISPTABL        Search table for the proper entry.\n         BAL   R9,SETTMODE        Do the Key 0 stuff\n         BAL   R9,CHANGED         Tell em we changed the values.\n         B     EOJ0\nNOE2     DS    0H                 No Parmlib-supplied table there.\n         MVC   LINE,LINE-1\n         MVC   LINE(L'MESSAGEP),MESSAGEP\n         MVC   LINE+20(2),=C'E2'\n         APUT  LINE,L'MESSAGEP\n         B     EOJ4\nNOE8     DS    0H                 No Parmlib-supplied table there.\n         MVC   LINE,LINE-1\n         MVC   LINE(L'MESSAGEP),MESSAGEP\n         MVC   LINE+20(2),=C'E8'\n         APUT  LINE,L'MESSAGEP\n         B     EOJ4\nNOAP     DS    0H                 No Parmlib-supplied table there.\n         MVC   LINE,LINE-1\n         MVC   LINE(L'MESSAGEP),MESSAGEP\n         MVC   LINE+20(2),=C'AP'\n         APUT  LINE,L'MESSAGEP\n         B     EOJ4\nNONS     DS    0H                 No Parmlib-supplied table there.\n         MVC   LINE,LINE-1\n         MVC   LINE(L'MESSAGEP),MESSAGEP\n         MVC   LINE+20(2),=C'NS'\n         APUT  LINE,L'MESSAGEP\n         B     EOJ4\nNOFCVE   DS    0H\n         APUT  =C'No PLATCMD table found',22\n         B     TRYPPVE\nNOPPVE   DS    0H\n         APUT  =C'No PLATPGM table found',22\n         B     TRYPPVEE\n         B     EOJ0\nNOTNUMER DS    0H\n         MVC   LINE,LINE-1\n         MVC   LINE(L'MESSAGEN),MESSAGEN\n         MVC   LINE+21(1),0(R7)\n         APUT  LINE,L'MESSAGEN\n         B     EOJ4\n** ---------------------------------------------------------------- **\nSAVEPARM DC    F'0'\nSAVETPVT DC    F'0'\nSAVECTLT DC    F'0'\nSAVEFCVE DC    F'0'\nSAVEPPVE DC    F'0'\nSAVEUPT  DC    F'0'\nSAVEECT  DC    F'0'\nSAVEPSCB DC    F'0'\n** ---------------------------------------------------------------- **\nFULLZERO DC    F'0'\nFULLFOUR DC    F'4'\nFULLEIGT DC    F'8'\nFULLTWLV DC    F'12'\nSAVE1401 DC    5F'0'                  More for safety\n* - - - - - - - - - - - - - - - - - - - - - - - - *\nMOVOUTL  MVC   TABCODE(*-*),0(R1)     EXECUTED\nMOVFSTN  MVC   FSTNAME(*-*),0(R3)     EXECUTED\nMOVSNDN  MVC   SNDNAME(*-*),0(R1)     EXECUTED\nMOVFNUM  MVC   FSTNUME(*-*),0(R3)     EXECUTED\nPACK     PACK  WORKA,0(0,3)          <<< EXECUTED >>>                    06758\n** ---------------------------------------------------------------- **\n* - - - - - - - - - - - - - - - - - - - - - - - - *\n*            S U B R O U T I N E S                *\n* - - - - - - - - - - - - - - - - - - - - - - - - *\nHEX      DS    0H\n         ST    R9,SAVER9A\n         MVC   1(1,R15),0(R1)        Move byte\n         UNPK  0(3,R15),1(2,R15)     Unpack\n         TR    0(2,R15),HEXTAB-240\n         LA    R15,2(,R15)           Increment output pointer\n         LA    R1,1(,R1)             Increment input pointer\n         BCT   R0,HEX                Decrement length, then loop\n         MVI   0(R15),C' '           Blank the trailing byte\n         L     R9,SAVER9A\n         BR    R9                    Return to caller\nHEXTAB   DC    C'0123456789ABCDEF'   Translate table\nHEXSAVE  DS    3F                    Register save for HEX macro\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nGETNAMES DS    0H\n         ST    R9,SAVER9B\nGETNAMST DS    0H                  Get rid of leading blanks\n         L     R1,CHARCONT         Point to start of character\n         CLI   0(R1),X'40'         Is it a blank?\n         BNE   GETNAMNZ            No. Get the entire name.\n         LA    R1,1(,R1)           Yes. Bump start place one up.\n         ST    R1,CHARCONT         And store the place away for now.\n         C     R5,=F'1'            End of cmd buffer one away?\n         BNH   EOJ4                Yes. Error.\n         BCTR  R5,0                Subtract one from end count\n         B     GETNAMST            And loop to find first non-blank.\nGETNAMNZ DS    0H                  Got first non-blank. Get whole name.\n         LA    R6,8                BCT initial quantity - 8 chars.\n         LA    R8,0                Character count\n         L     R1,CHARCONT         Load starting place\n         LR    R7,R1               Initialize pointer\n         LA    R7,0(,R7)           to first character of program name.\nGETNAMLU DS    0H                  Loop to get entire name\n         CLI   0(R7),X'40'         First blank?\n         BE    GETNAMGT            Yes, got whole name.\n         CLI   0(R7),X'00'         First hex zeros?\n         BE    GETNAMGT            Yes, got whole name.\n         CR    R8,R5               End of command buffer?\n         BNL   GETNAMGT            Yes. Got all we can get.\n         LA    R8,1(,R8)           Bump character counter.\n         LA    R7,1(,R7)           Bump where we are.\n         BCT   R6,GETNAMLU         Loop back.\nGETNAMGT DS    0H\n         ST    R8,SAVER8\n         ST    R8,FSTCOUNT\n         CLC   SAVER8,=F'0'\n         BNE   GETREALY\n         BAL   R9,MISSPGM2\n         B     EOJ4\nGETREALY DS    0H\n         MVC   FSTCHALF(2),FSTCOUNT+2\n         MVC   LINE,LINE-1\n         HEX   LINE,4,SAVER8\n         MVC   LINE+13(17),=C'Length of command'\n         APUT  LINE,30\n         L     R3,CHARCONT\n         BCTR  R8,0                One less for EXECUTE\n         MVC   FSTNAME(8),BLANKS\n         EX    R8,MOVFSTN\n         OC    FSTNAME(8),BLANKS\n         MVC   LINE,LINE-1\n         MVC   LINE(8),FSTNAME\n         MVC   LINE+13(17),=C'New program name '\n         APUT  LINE,30\n* - >\nGETNAMEN DS    0H\n         L     R9,SAVER9B\n         BR    R9\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nCHANGED  DS    0H                     The \"value was changed\" message.\n         ST    R9,SAVER9C\n         TM    OFFFLAG,X'01'\n         BO    CHANGEDA\n         TM    OFFFLAG,X'02'\n         BO    CHANGEDB\n         TM    OFFFLAG,X'04'\n         BO    CHANGEDD\nCHANGEDA DS    0H\n         MVC   MESSAG3A+5(4),TABENNUM+6\n         MVC   MESSAG3A+13(2),CODEPLAC\n         MVC   MESSAG3A+42(8),FSTNAME\n         APUT  MESSAG3A,L'MESSAG3A    Tell em we changed the value.\n         B     CHANGEND\nCHANGEDB DS    0H\n         MVC   MESSAG3B+13(2),CODEPLAC\n         APUT  MESSAG3B,L'MESSAG3B    Tell em we changed the value.\n         B     CHANGEND\nCHANGEDD DS    0H\n         TM    OFFFLAG,X'04'\n         BZ    CHANGEDX\n         CLC   SLOTBIN,=F'0'\n         BE    CHANGEND\nCHANGEDX DS    0H\n         MVC   LINE,LINE-1\n         MVC   LINE(30),=C'Display of Slot contents.     '\n         APUT  LINE,30\nCHANGEND DS    0H\n         L     R9,SAVER9C\n         BR    R9\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nNAMEPARM DS    0H\n         ST    R9,SAVER9D\n         TM    OFFFLAG,X'02'          Are we blanking?\n         BO    NAMEPEND               Yes. Don't need a name parameter\n         L     R8,SAVER8              Get number of characters used\n         CR    R8,R5                  More than what's left?\n         BNL   NAMEBAD1               Yes. Error.\n         C     R5,=F'3'               Is end bigger than 3?\n         BNH   NAMEBAD1               No. Error.\nNAMEGOOD DS    0H\n         S     R5,=F'3'               Subtract 3 from number till end.\n         BAL   R9,GETNUMES            Get the number of the pgm entry.\n         TM    OFFFLAG,X'04'          Displaying?\n         BO    NAMEPEND               Yes. No names wanted.\n         BAL   R9,GETNAMES            Get the name of pgm to shove in.\n         B     NAMEPEND\nNAMEBAD1 DS    0H\n         TM    OFFFLAG,X'04'          Are we displaying?\n         BO    NAMEPEND\n         BAL   R9,MISSPGM1\n         B     EOJ4\nNAMEPEND DS    0H\n         L     R9,SAVER9D\n         BR    R9\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nADJNEXTP DS    0H\n         ST    R9,SAVER9E\n         MVC   CHARSTRT,CHARCONT\n         L     R1,CHARSTRT\nSEEIFENX DS    0H\n         CLI   0(R1),X'40'\n         BE    SEEIFENZ\n         LA    R1,1(,R1)\n         ST    R1,CHARSTRT\n         B     SEEIFENX\nSEEIFENZ DS    0H\n         L     R9,SAVER9E\n         BR    R9\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n         LTORG\n************************************************************\nPGMTITLE DS    0H                     Display program name\n         ST    R9,SAVER9F\n         MVC   LINE,LINE-1            Blank line\n         MVC   LINE,MESSAGET          Move title line in\n         APUT  LINE,L'MESSAGET        And put out to tube\n         MVC   LINE,LINE-1            Blank line again\n         MVC   LINE,MESSAGEU          Move underlines in\n         APUT  LINE,L'MESSAGEU        And put them out also\n         L     R9,SAVER9F\n         BR    R9                     Return to caller\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nSETTMODE DS    0H\n         ST    R9,SAVER9G\n* -- >       Test if this command is being run APF Authorized\n         STM   R15,R1,SAVE1401     Now save registers and test if APF\n         XR    R15,R15                  authorized.\n         TESTAUTH FCTN=1           Are we authorized?\n         LTR   R15,R15             Test the return code.\n         BNZ   NOTAUTH             Not zero, tell not authorized.\n         LM    R15,R1,SAVE1401     Restore registers used by TESTAUTH.\n* -- >\n* -- >      Key Zero ---- Here's where we change the stuff.\nKZ       MODESET KEY=ZERO\n* -\n         TM    OFFFLAG,X'03'\n         BZ    ENDKZ\n         TM    NSCHFLG,X'01'\n         BO    TENSLOT\nEIGHSLOT DS    0H\n         L     R3,OURSLOT\n         TM    OFFFLAG,X'01'\n         BZ    BLANKIT\n         CLC   FSTNAME,BLANKS\n         BE    ENDKZ\n         MVC   0(8,R3),FSTNAME\n         B     ENDKZ\nBLANKIT  DS    0H\n         TM    OFFFLAG,X'02'\n         BZ    ENDKZ\n         L     R3,SAVLSLOT\n         MVC   0(8,R3),BLANKS\n         B     ENDKZ\nTENSLOT  DS    0H\n         L     R3,OURSLOT\n         TM    OFFFLAG,X'01'\n         BZ    BLANKTEN\n         CLC   FSTNAME,BLANKS\n         BE    ENDKZ\n         MVC   0(2,R3),FSTCHALF\n         MVC   2(8,R3),FSTNAME\n         B     ENDKZ\nBLANKTEN DS    0H\n         TM    OFFFLAG,X'02'\n         BZ    ENDKZ\n         L     R3,SAVLSLOT\n         MVC   0(2,R3),=X'FFFF'\n         MVC   2(8,R3),BLANKS\n         B     ENDKZ\nENDKZ    DS    0H\n* -\nNZ       MODESET KEY=NZERO\n* -- >      Back to ordinary life ----\n         L     R9,SAVER9G\n         BR    R9                     Return to caller\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nERRORCOD DS    0H\n         ST    R9,SAVER9H\n         MVC   LINE,LINE-1\n         APUT  LINE,30\n         APUT  MESSA11L,L'MESSA11L\n         APUT  MESSA11M,L'MESSA11M\n         APUT  MESSA11P,L'MESSA11P\n         APUT  MESSA11A,L'MESSA11A\n         APUT  MESSA11C,L'MESSA11C\n         APUT  MESSA11D,L'MESSA11D\n         APUT  MESSA11F,L'MESSA11F\n         APUT  MESSA11I,L'MESSA11I\n         APUT  MESSA11K,L'MESSA11K\n         APUT  MESSA11J,L'MESSA11J\n         APUT  MESSA11N,L'MESSA11N\n         APUT  MESSA11O,L'MESSA11O\n         L     R9,SAVER9H\n         BR    R9                     Return to caller\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nMISSPGM1 DS    0H\n         ST    R9,SAVER9I\n         MVC   LINE,LINE-1\n         APUT  MESSA11G,L'MESSA11G\n         L     R9,SAVER9I\n         BR    R9                     Return to caller\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nMISSPGM2 DS    0H\n         ST    R9,SAVER9J\n         MVC   LINE,LINE-1\n         APUT  MESSA11E,L'MESSA11E\n         L     R9,SAVER9J\n         BR    R9                     Return to caller\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nMISSPGM3 DS    0H\n         ST    R9,SAVER9K\n         MVC   LINE,LINE-1\n         APUT  MESSA11H,L'MESSA11H\n         L     R9,SAVER9K\n         BR    R9                     Return to caller\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nDISPTABL DS    0H                Scan thru the particular table....\n         ST    R9,SAVER9L          Save BAL register\n         ST    R3,SAVER3A          Save\n         ST    R4,SAVER4A             the\n         ST    R5,SAVER5A                work\n         ST    R6,SAVER6A                   registers.\n         TM    OFFFLAG,X'02'       Are we blanking the last entry?\n         BO    DISPTEND            Yes. Don't have to scan entire table\n         XR    R3,R3               Zero\n         XR    R5,R5                  work\n         XR    R6,R6                     registers.\nDISPTSTR DS    0H\n         L     R3,TABLSTRT         Load start address of table\n         L     R6,TABLENUM         Load number of entries in table\n         L     R5,TABLESIZ         Load size of each entry\n         LA    R4,1                Start slot number count at 1\n         ST    R4,SLOTNOW          Stort slot number count away\n         CLC   SLOTBIN,=F'0'       If there's no slot num in param\n         BE    DISPTLUP            Then bypass error checking\n         C     R6,SLOTBIN          Compare table size to parm number\n         BNL   DISPTLUP            If parm number is LE, then display\nDISPTERR DS    0H                  Else error message and out.\n         MVC   LINE,LINE-1\n         MVC   LINE(22),=C'Slot number specified '\n         L     R1,SLOTBIN          Display field\n         CVD   R1,CVDAREA          Convert count to printable\n         MVC   LINE+22(10),MASK10  Move in the mask\n         ED    LINE+22(10),CVDAREA+3 Make it pretty\n         MVC   LINE+34(26),=C'is bigger than table size '\n         L     R1,TABLENUM         Display field\n         CVD   R1,CVDAREA          Convert count to printable\n         MVC   LINE+60(10),MASK10  Move in the mask\n         ED    LINE+60(10),CVDAREA+3 Make it pretty\n         APUT  LINE,72\n         B     EOJ4\nDISPTLUP DS    0H                  Loop thru the table entries.\n         MVC   LINE,LINE-1\n         MVC   LINE(2),CODEPLAC\n         MVC   LINE+3(19),=C'Table Entry Number:'\n         CVD   R4,CVDAREA          Convert count to printable\n         MVC   LINE+22(10),MASK10  Move in the mask\n         ED    LINE+22(10),CVDAREA+3 Make it pretty\n         TM    NSCHFLG,X'01'       Is this the 10-byte NS table entry?\n         BO    DISPTBNS            Yes. Handle separately.\n         MVC   LINE+34(8),0(R3)\n         CLC   LINE+34(8),BLANKS   Is this a blank entry.\n         BNE   DISPTBLK            No.\n         MVC   LINE+34(8),=C'*empty* '   Yes. Don't just show blanks.\n         B     DISPTBLK\nDISPTBNS DS    0H\n         HEX   LINE+34,2,0(R3)\n         MVC   LINE+40(8),2(R3)\n         CLC   LINE+40(8),BLANKS   Is this a blank entry.\n         BNE   DISPTBLK            No.\n         MVC   LINE+40(8),=C'*empty* '   Yes. Don't just show blanks.\nDISPTBLK DS    0H                  Search each slot number.\n         CLC   SLOTBIN,=F'0'       Has a slot number been specified?\n         BE    DISPTYES            No. Just display all the slots.\n         CLC   SLOTBIN,SLOTNOW     Yes. Then are we at the one we want?\n         BNE   DISPTNOT            No. Just go further and search.\n* ---  Save contents of the current slot which was found - below\n         LR    R1,R5               Load table entry size\n         BCTR  R1,0                One less for execute\n         EX    R1,MOVESLOT         Save contents of slot for kicks\n         ST    R3,OURSLOT          Store its address - important....\n         MVC   TABENNUM(10),MASK10    Save edited version\n         ED    TABENNUM(10),CVDAREA+3    of this slot number\n         B     DISPTPEX               Branch past executed instruction\nMOVESLOT MVC   SLOTSAVE(*-*),0(R3)    EXECUTED\nDISPTPEX DS    0H\n* ---  Save contents of the current slot which was found - above\nDISPTYES DS    0H                  Print this slot entry\n         APUT  LINE,52\nDISPTNOT DS    0H                  Bump to next slot and loop back.\n         LA    R3,0(R5,R3)         Bump to next slot\n         LA    R4,1(,R4)           Bump count of slot number\n         ST    R4,SLOTNOW          Store new slot number away\n         BCT   R6,DISPTLUP         And loop to examine the new slot.\nDISPTEND DS    0H\n         L     R3,SAVER3A          Restore all the work registers.\n         L     R4,SAVER4A\n         L     R5,SAVER5A\n         L     R6,SAVER6A\n         L     R9,SAVER9L          Restore the BAL register.\n         BR    R9                  Return to caller\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nGETNUMES DS    0H\n         ST    R9,SAVER9M\nGETNUMST DS    0H                  Get rid of leading blanks\n         L     R1,CHARCONT         Point to start of character\n         CLI   0(R1),X'40'         Is it a blank?\n         BNE   GETNUMNZ            No. Get the entire name.\n         LA    R1,1(,R1)           Yes. Bump start place one up.\n         ST    R1,CHARCONT         And store the place away for now.\n         C     R5,=F'1'            End of cmd buffer one away?\n         BNH   EOJ4                Yes. Error.\n         S     R5,=F'1'            Subtract one from end count\n         B     GETNUMST            And loop to find first non-blank.\nGETNUMNZ DS    0H                  Got first non-blank. Get whole name.\n         LA    R6,5                BCT initial quantity - 5 chars.\n         LA    R8,0                Character count\n         L     R1,CHARCONT         Load starting place\n         LR    R7,R1               Initialize pointer\n         LA    R7,0(,R7)           to first character of program number\nGETNUMLU DS    0H                  Loop to get entire number\n         CLI   0(R7),X'40'         First blank?\n         BE    GETNUMGT            Yes, got whole number\n         CLI   0(R7),X'00'         First hex zeros?\n         BE    GETNUMGT            Yes, got whole number\n         CR    R8,R5               End of command buffer?\n         BNL   GETNUMGT            Yes. Got all we can get.\n* --\n         CLI   0(R7),X'F0'         Check this parm if numeric.\n         BL    NOTNUMER\n         CLI   0(R7),X'F9'\n         BH    NOTNUMER\n* --\n         LA    R8,1(,R8)           Bump character counter.\n         LA    R7,1(,R7)           Bump where we are.\n         BCT   R6,GETNUMLU         Loop back.\nGETNUMGT DS    0H                  Got the whole number - examine it.\n         ST    R8,SAVER8\n         ST    R8,FSTNOUNT         Get halfword value of slot number\n         MVC   FSTNHALF(2),FSTNOUNT+2\n         L     R3,CHARCONT\n         BCTR  R8,0                One less for EXECUTE\n         MVC   FSTFIELD(8),BLANKS  5-char number plus 3 blanks\n         EX    R8,MOVFNUM          Get the number from the parm\n         EX    R8,PACK             Convert it to packed\n         CVB   R0,WORKA            Convert it to Binary                  06446\n         ST    R0,SLOTBIN          Store the value for later use         06447\n         MVC   LINE,LINE-1\n         MVC   LINE(8),FSTFIELD    8-char number with blanks\n         MVC   LINE+13(19),=C'Entry slot number  '\n         APUT  LINE,32\n         LA    R8,1(,R8)           Restore number of chars after EX\n         ST    R8,CHARSIZE         Save this value off.\n         AR    R3,R8               Add it to R3 so we start past it.\n         ST    R3,CHARCONT         Store start value for next parm.\nGETNUMEN DS    0H\n         L     R9,SAVER9M\n         BR    R9\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nPRTBLADR DS    0H\n         ST    R9,SAVER9N\n*-*-*->>                          Print the address out so we can see.\n         STM   R14,R1,SAVE1401    Save registers 14 thru 1.\n         MVC   LINE,LINE-1        Clear line area.\n         MVC   LINE(16),=C'Table address:  '\n         HEX   LINE+21,4,TABLADDR     Display address in Hex\n         APUT  LINE,35\n         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.\n*-*-*->>\n         L     R9,SAVER9N\n         BR    R9\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n* ----------------------------------------------------------------- *\n*      Measure \"8-byte entry\" loaded table.                         *\n* ----------------------------------------------------------------- *\n*      R5 contains the entry point of the table.                    *\n* ----------------------------------------------------------------- *\nMEASUR08 DS    0H                 R5 has beginning address of table.\n         ST    R9,SAVER9O           Save BAL register\n         ST    R5,SAVER5D           Save work register\n         ST    R4,SAVER4B           Save work register\n         ST    R6,SAVER6B           Save work register\n         L     R5,TABLADDR          Load start of table\n         XC    BLNKCNT,BLNKCNT      Zero the counters\n         XC    NTRYCNT,NTRYCNT\n         LA    R4,16                Count size of header\n         LA    R5,16(,R5)           Bump past header\n         L     R6,TABLENUM          No of entries to limit loop\nME08LOOP DS    0H\n*     Try (real hard) to detect the end of the table  -  below\n         MVC   SAVECHAR(1),0(R5)    Save first character\n         CLC   =C'        ',0(R5)   Is this table entry a blank?\n         BE    ME08BLNK             Yes. Reached virtual end of table\n         CLC   ZEROES8(8),0(R5)     Is this \"entry\" hex zeros?\n         BE    ME08NOBL             Yes. Reached possible junk storage\n         CLC   =C' ',0(R5)          Is first character blank?\n         BE    ME08NOBL             Yes, not a valid table entry.\n         TR    SAVECHAR,TRTPGMNM    Check first char if appropriate.\n         CLI   SAVECHAR,X'02'       Not. probably end of table.\n         BE    ME08NOBL\n         CLC   =C'IKJEFTE2',0(R5)\n         BE    ME08NOBL\n         CLC   =C'IKJEFTE8',0(R5)\n         BE    ME08NOBL\n         CLC   =C'IKJEFTAP',0(R5)\n         BE    ME08NOBL\n         CLC   =C'IKJEFTNS',0(R5)\n         BE    ME08NOBL\n*     Try (real hard) to detect the end of the table  -  above\n         LA    R4,8(,R4)            Count next table entry\n         LA    R5,8(,R5)            Bump to next entry\n         L     R1,NTRYCNT           Increment \"entry count\" counter\n         A     R1,=F'1'\n         ST    R1,NTRYCNT\n         BCT   R6,ME08LOOP          Loop back till table end\n         B     ME08NOBL             No blanks if we fell through\nME08BLNK DS    0H\n         LA    R4,8(,R4)            Add length of blank entry\n         LA    R5,8(,R5)            Bump past blank entry.\n         L     R1,BLNKCNT           Increment \"blank entry\" counter\n         A     R1,=F'1'\n         ST    R1,BLNKCNT\nME08NOBL DS    0H\n         STH   R4,ME08LENG          Store measured length of table.\n         ST    R5,ME08END           And record address of table end.\n*        BAL   R9,MESBLK08          Measure more blanks after table.\n*        TM    MEASFLG,X'01'        Been here already?\n*        BO    ME08NOSH             Don't show count again.\n         BAL   R9,ENTRYDSP          Show number of entries.\nME08NOSH DS    0H\n*        OI    MEASFLG,X'01'        Show we did this once.\n         L     R4,SAVER4B           Restore work register\n         L     R6,SAVER6B           Restore work register\n         L     R5,SAVER5D           Restore work register\n         L     R9,SAVER9O           Restore BAL register\n         BR    R9\nME08END  DS    F                    Store end-of-table address\nME08LENG DS    H                    Store table length\nBL08LENG DS    H                    Store length of blanks\nTO08LENG DS    H                    Store total, nonblank+blank\n* ----------------------------------------------------------------- *\nMEASUR10 DS    0H                 R5 has beginning address of table.\n         ST    R9,SAVER9R           Save BAL register\n         ST    R5,SAVER5D           Save work register\n         ST    R4,SAVER4B           Save work register\n         ST    R6,SAVER6B           Save work register\n         L     R5,TABLADDR          Load start of table\n         XC    BLNKCNT,BLNKCNT      Zero the counters\n         XC    NTRYCNT,NTRYCNT\n         LA    R4,16                Count size of header\n         LA    R5,16(,R5)           Bump past header\n         L     R6,TABLENUM          No of entries to limit loop\nME10LOOP DS    0H\n         MVC   SAVECHAR(1),2(R5)    Save first character of pgm name\n         MVC   SAVECH08(1),9(R5)    Save last character of pgm name\n         CLC   BLKSTRNG(10),0(R5)   Full blank entry here?\n         BE    ME10BLNK             Yes. Count the blank entry.\n         CLC   ENDSTRNG(10),0(R5)   FFFF plus blank pgm name?\n         BE    ME10BLNK             Yes. Can still be considered blank.\n         CLC   =X'0000',0(R5)       Zeros in length field?\n         BE    ME10TEST             Yes. Test rest of entry.\n         B     ME10REST             Not zeros, go on.\nME10TEST DS    0H\n         TR    SAVECHAR,TRTPGMNM    Check for strange character.\n         CLI   SAVECHAR,X'02'       Is it strange?\n         BE    ME10NOBL             Yes. This is not a blank entry.\nME10REST DS    0H\n         CLC   =X'FFFF',0(R5)       Test for end string separately.\n         BNE   ME10TES2             Not. Not at virtual end of table\n         B     ME10NOBL             FFFF alone. Not a blank entry.\nME10TES2 DS    0H\n         TR    SAVECHAR,TRTPGMNM    Check for strange character.\n         CLI   SAVECHAR,X'02'\n         BE    ME10NOBL             Not. probably end of table.\n         TR    SAVECH08,TRTPGMNM    Check last char if strange.\n         CLI   SAVECH08,X'02'\n         BE    ME10NOBL             Not. probably end of table.\n         LA    R4,10(,R4)           Count next table entry\n         LA    R5,10(,R5)           Bump to next entry\n         L     R1,NTRYCNT           Increment \"entry count\" counter\n         A     R1,=F'1'\n         ST    R1,NTRYCNT\n         BCT   R6,ME10LOOP          Finished entry, try for more.\n         B     ME10NOBL\nME10BLNK DS    0H\n         LA    R4,10(,R4)           Add length of blank entry\n         LA    R5,10(,R5)           Bump past blank entry.\n         L     R1,BLNKCNT           Increment \"blank entry\" counter\n         A     R1,=F'1'\n         ST    R1,BLNKCNT\nME10NOBL DS    0H\n         STH   R4,ME10LENG          Store measured length of table.\n         ST    R5,ME10END           And record address of table end.\n         BAL   R9,ENTRYDSP          Show number of entries.\nME10NOSH DS    0H\n         L     R4,SAVER4B           Restore work register\n         L     R6,SAVER6B           Restore work register\n         L     R5,SAVER5D           Restore work register\n         L     R9,SAVER9R           Restore BAL register\n         BR    R9\nME10END  DS    F                    Store end-of-table address\nME10LENG DS    H                    Store table length\nBL10LENG DS    H                    Store length of blanks\nTO10LENG DS    H                    Store total, nonblank+blank\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nENTRYDSP DS    0H\n         ST    R9,SAVER9P\n         STM   R14,R1,SAVE1401    Save registers 14 thru 1.\n         MVC   LINE,LINE-1\n         L     R1,NTRYCNT\n         CVD   R1,CVDAREA\n         MVC   LINE+22(10),MASK10\n         ED    LINE+22(10),CVDAREA+3\n         MVC   LINE(24),=C'Non-blank table entries:'\n         MVC   LINE+35(25),=C'(these are the ones used)'\n         APUT  LINE,65\n         MVC   LINE,LINE-1\n         L     R1,BLNKCNT\n         CVD   R1,CVDAREA\n         MVC   LINE+22(10),MASK10\n         ED    LINE+22(10),CVDAREA+3\n         MVC   LINE(24),=C'Perceived blank entries:'\n         MVC   LINE+35(25),=C'(blank program name slot)'\n         APUT  LINE,65\n         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.\nENTRYEXI DS    0H\n         L     R9,SAVER9P\n         BR    R9\nENTRYDEN DS    0H\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nPRTNENTR DS    0H\n         ST    R9,SAVER9Q\n         STM   R14,R1,SAVE1401    Save registers 14 thru 1.\n         MVC   LINE,LINE-1\n         ST    R1,SAVER1B\n         L     R1,TABLENUM         Display field\n         CVD   R1,CVDAREA          Convert count to printable\n         MVC   LINE+22(10),MASK10  Move in the mask\n         ED    LINE+22(10),CVDAREA+3 Make it pretty\n         L     R1,SAVER1B\n         MVC   LINE(24),=C'Number of valid entries:'\n         APUT  LINE,45\n         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.\n         L     R9,SAVER9Q\n         BR    R9\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nLISTLNTH DS    0H\n         ST    R9,SAVER9S\n         STM   R14,R1,SAVE1401    Save registers 14 thru 1.\n         MVC   LINE,LINE-1\n         MVC   LINE(30),=C'Listed   length of this table:'\n         HEX   LINE+32,2,TABLELEN+2\n         L     R1,TABLELEN         Display field\n         CVD   R1,CVDAREA          Convert count to printable\n         MVC   LINE+45(10),MASK10  Move in the mask\n         ED    LINE+45(10),CVDAREA+3 Make it pretty\n         MVC   LINE+39(8),=C'Decimal:'\n         APUT  LINE,65\n         TM    NSCHFLG,X'01'\n         BO    LISTLN10\n         MVC   LINE,LINE-1\n         MVC   LINE(30),=C'Measured length of this table:'\n         HEX   LINE+32,2,ME08LENG\n         LH    R1,ME08LENG         Display field\n         CVD   R1,CVDAREA          Convert count to printable\n         MVC   LINE+45(10),MASK10  Move in the mask\n         ED    LINE+45(10),CVDAREA+3 Make it pretty\n         MVC   LINE+39(8),=C'Decimal:'\n         APUT  LINE,65\n         B     LISTLNEN\nLISTLN10 DS    0H\n         MVC   LINE,LINE-1\n         MVC   LINE(30),=C'Measured length of this table:'\n         HEX   LINE+32,2,ME10LENG\n         LH    R1,ME10LENG         Display field\n         CVD   R1,CVDAREA          Convert count to printable\n         MVC   LINE+45(10),MASK10  Move in the mask\n         ED    LINE+45(10),CVDAREA+3 Make it pretty\n         MVC   LINE+39(8),=C'Decimal:'\n         APUT  LINE,65\nLISTLNEN DS    0H\n         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.\n         L     R9,SAVER9S\n         BR    R9\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nBLKSTRNG DC    XL10'00004040404040404040'\nENDSTRNG DC    XL10'FFFF4040404040404040'\nZEROES8  DC    X'0000000000000000'\nMASK10   DC    XL10'40202020202020202120'\n         DC    C' '\nBLANKS   DC    C'                                            '\nMESSAGET DC    C'ASUB Command - Display or Change PARMLIB Auth Table Enx\n               try - Ver 1.15'\nMESSAGEU DC    C'---- -------   ------- -- ------ ------- ---- ----- --x\n               ---   --- ----'\nMESSAG2C DC    C'Command was not invoked APF authorized.'\nMESSAG2D DC    C'Nothing was changed.  '\nMESSAG3A DC    C'Slot      in XX table has been changed to         .'\nMESSAG3B DC    C'Last slot in XX table has been blanked.            '\nMESSAG3C DC    C'                                                      +\n                  '\nMESSA11A DC    C'Supply a table code, followed by an action code. '\nMESSA11B DC    C'Supply a program name, as the next parameter.   '\nMESSA11C DC    C'Valid table  codes are:  E2, E8, AP, NS, PC, PP. '\nMESSA11D DC    C'Valid action codes are:  R - replace, B - blank, D - d-\n               isplay.'\nMESSA11E DC    C'Please supply a program name.  '\nMESSA11F DC    C'Full command is in the form TTA, TT=table code, A=acti-\n               on code.'\nMESSA11G DC   C'Please supply slot number to change, and program name.'\nMESSA11H DC    C'This table did not come from a PARMLIB specification.'\nMESSA11I DC    C'If D (display) is followed by a slot number, only that-\n                slot is shown.'\nMESSA11J DC    C'R (replace) requires a slot number, followed by a prog-\n               ram name.'\nMESSA11K DC    C'If D is not followed by a number, then the entire tabl-\n               e is displayed.'\nMESSA11L DC    C'  Instructions to use this program:                  '\nMESSA11M DC    C'  ------------ -- --- ---- -------                   '\nMESSA11N DC    C'B (blank) will blank the last table entry, which norma-\n               lly is blank.'\nMESSA11O DC    C'Only R (replace) and B (blank) require APF authorizati-\n               on. D does not.'\nMESSA11P DC    C'  ASUB TTA nnn pgmname (nnn optional for D, both requi-\n               red for R)'\nMESSAGR0 DC    C'Return Code = 0 '\nMESSAGR4 DC    C'Return Code = 4 '\nMESSAGR8 DC    C'Return Code = 8 '\nMESSAGRC DC    C'Return Code = 12'\nMESSDIAG DC    C'                                            '\nMESSAGEP DC    C'No Parmlib-supplied XX table was found in storage. '\nMESSAGEN DC    C'Supplied character        was not numeric. '\n         SPACE 3\n         LTORG\n         SPACE 3\nCVDAREA  DS    D                   For CVD instruction\nSAVEAPUT DS    2D\nSAVER1   DS    F                   Save R1 here\nSAVER1A  DS    F                   Save R1 here\nSAVER1B  DS    F                   Save R1 here\nSAVER3A  DS    F                   Save R3 here\nSAVER4A  DS    F                   Save R4 here\nSAVER4B  DS    F                   Save R4 here\nSAVER5A  DS    F                   Save R5 here\nSAVER5D  DS    F                   Save R5 here\nSAVER6   DS    F                   Save R6 here\nSAVER6A  DS    F                   Save R6 here\nSAVER6B  DS    F                   Save R6 here\nSAVER8   DS    F                   Save R8 here\nSAVER8A  DS    F                   Save R8 here\nSAVER8B  DS    F                   Save R8 here\nSAVER9A  DS    F                   BAL Register Save Area\nSAVER9B  DS    F                   BAL Register Save Area\nSAVER9C  DS    F                   BAL Register Save Area\nSAVER9D  DS    F                   BAL Register Save Area\nSAVER9E  DS    F                   BAL Register Save Area\nSAVER9F  DS    F                   BAL Register Save Area\nSAVER9G  DS    F                   BAL Register Save Area\nSAVER9H  DS    F                   BAL Register Save Area\nSAVER9I  DS    F                   BAL Register Save Area\nSAVER9J  DS    F                   BAL Register Save Area\nSAVER9K  DS    F                   BAL Register Save Area\nSAVER9L  DS    F                   BAL Register Save Area\nSAVER9M  DS    F                   BAL Register Save Area\nSAVER9N  DS    F                   BAL Register Save Area\nSAVER9O  DS    F                   BAL Register Save Area\nSAVER9P  DS    F                   BAL Register Save Area\nSAVER9Q  DS    F                   BAL Register Save Area\nSAVER9R  DS    F                   BAL Register Save Area\nSAVER9S  DS    F                   BAL Register Save Area\nSAVER9T  DS    F                   BAL Register Save Area\nSAVER9U  DS    F                   BAL Register Save Area\nSAVER9V  DS    F                   BAL Register Save Area\nSAVER9W  DS    F                   BAL Register Save Area\nSAVER9X  DS    F                   BAL Register Save Area\nSAVER9Y  DS    F                   BAL Register Save Area\nCMBUFEND DS    F                   Number of bytes to end of cmd buff\nSAVLSLOT DS    F                   Save place where Key 0 will change\nSLOTBIN  DS    F\nSLOTNOW  DS    F\nDISPREG  DS    F                   DISPLAY\nCMBUFAD  DS    F                   Command Buffer address\nCHARSTRT DS    F                   Address of first parm character\nCHARCONT DS    F                   Address of next parm character\nCHARSIZE DS    F\nOURSLOT  DS    F\n* --- >\nTABLSTRT DS    F                   Start address of table\nTABLADDR DS    F                   Start address of table\nTABLENUM DS    F                   Number of entries in table\nTABLESIZ DS    F                   Size of a table entry\nTABLELEN DS    F                   Listed length of the table\n* --- >\nBLNKCNT  DS    F\nNTRYCNT  DS    F\n* --- >\nOFFSETSV DS    F\nWORKA    DC    D'0'                                                      06772\nNUMVSTRT DC    X'00'               Character count of first parm\nNUMCOUTL DC    X'00'               Entered first parm length\nCODEPLAC DS    CL2\nPAD01    DS    CL4                 Filler\nSAVECHAR DS    X\nSAVECH08 DS    X\nOFFFLAG  DS    X                   Are we blanking the last entry?\nOLDFLAG  DS    X                   Old system detected if X'01'\nPLATFLG  DS    X\nNSCHFLG  DS    X\nPAD02    DS    CL4                 Filler\nFSTNAME  DC    CL8' '\nFSTCOUNT DS    F                   Number of characters in FSTNAME\nFSTCHALF DC    H'0'\nPAD03    DS    CL4                 Filler\nFSTFIELD DS    0CL8\nFSTNUME  DC    CL5' '\nFSTNUPAD DC    CL3' '\nFSTNOUNT DS    F                   Number of characters in FSTNAME\nFSTNHALF DC    H'0'\nPAD04    DS    CL4                 Filler\nSLOTSAVE DS    CL10\nPAD05    DS    CL4                 Filler\nSNDNAME  DC    CL8' '\nSNDCOUNT DS    F                   Number of characters in SNDNAME\nSNDCHALF DC    H'0'\nTABCODE  DC    CL8' '              Original OUTLIM character\nTABENNUM DC    CL10' '\n         DS    CL7                 PADDING\n         DS    CL1\nCMDBCOPY DS    CL252\n         DS    CL128               PADDING\n         DS    0F                  ALIGN ON FULLWORD\nLINEB    DS    C                   LINE-1\nLINE     DS    CL137               Output line area\nLINET    EQU   LINE+7              Indented line\nTRTPGMNM DC    X'02020202020202020202020202020202'\n         DC    X'02020202020202020202020202020202'\n         DC    X'02020202020202020202020202020202'\n         DC    X'02020202020202020202020202020202'\n         DC    X'40020202020202020202020202020202'\n         DC    X'02020202020202020202025B02020202'\n         DC    X'0202020202020202020202020202026F'\n         DC    X'02020202020202020202027B7C020202'\n         DC    X'02C1C2C3C4C5C6C7C8C9020202020202'\n         DC    X'02D1D2D3D4D5D6D7D8D9020202020202'\n         DC    X'0202E2E3E4E5E6E7E8E9020202020202'\n         DC    X'02020202020202020202020202020202'\n         DC    X'02C1C2C3C4C5C6C7C8C9020202020202'\n         DC    X'02D1D2D3D4D5D6D7D8D9020202020202'\n         DC    X'0202E2E3E4E5E6E7E8E9020202020202'\n         DC    X'02020202020202020202020202020202'\n         SPACE\n         IKJCPPL\n         IKJPSCB\n         CVT      LIST=YES,DSECT=YES\n         IKJTSVT\n         END\nEPUTL    TITLE 'PUTLINE FOR FEWER THAN 83 ARGUMENTS IN THE KEY OF C MAJ&\n               OR'\nEPUTL    CSECT                                              *HMD 10/85*\n         LCLB  &XA                                          *HMD 10/85*\n&XA      SETB  1                  SET TO ZERO ON NON/XA     *HMD 10/85*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*  MODULE NAME  . . . . EPUTL\n*\n*  ALIASES  . . . . . . NONE\n*\n*  DATE WRITTEN . . . . 06/85\n*  UPDATED      . . . . 04/88                                  HD APR88\n*\n*  AUTHOR . . . . . . . JIM ELSWORTH\n*  UPDATOR  . . . . . . HOWARD M. DEAN                         HD APR88\n*\n*  ENVIRONMENT  . . . . TSO COMMAND-PROCESSOR\n*\n*  PURPOSE:\n*    ALLOW AN EASY INTERFACE TO PUTLINE ROUTINE\n*\n*\n*  DESCRIPTION:\n*    BUILDS PUTLINE PARAMETER LIST BASED ON INPUT ARGUMENTS.\n*    ISSUES SINGLE LINE PUTLINE.\n*\n*\n*  ATTRIBUTES:\n*    REENTRANT\n*\n*  FEATURES:\n*    WILL RUN UNDER BATCH TMP SINCE PUTLINE USED INSTEAD OF TPUT.\n*\n*  CALLED MODULES:\n*    PUTLINE\n*\n*  ASSUMPTIONS:\n*    CALLED BY A TSO-CP THAT IS OBSERVING STANDARD LINKAGE\n*\n*  ABENDS:\n*    POSSIBLE 0CX IF BAD ARGUEMNTS\n*\n*  CAVEATS:\n*    UNPREDICTABLE RESULTS IF FIRST PROGRAM RUNNING UNDER THIS TCB\n*    DID NOT SAVE (14,12) BEFOR R1 WAS MODIFIED.\n*\n*\n*  INPUT ARGUMENTS:\n*    1)  R1 : ADDRESS OF MESSAGE TEXT\n*    2)  R0 : LENGTH OF MESSAGE TEXT\n*    3) R13 : STANDARD OS SAVE AREA\n*    4) R14 : RETURN ADDRESS\n*    5) R15 : ENTRY ADDRESS\n*\n*               ( CONTINUED ... )\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*\n*  OUTPUT ARGUMENT: RETURN CODE FROM PUTLINE OR\n*\nRCBA     EQU   100                 BAD MESSAGE ADDRESS\nRCBL     EQU   104                 MESSAGE LENGTH <1 OR >MAXMSG\n*\nMAXMSG   EQU   128                 MAXIMUM MESSAGE LENGTH\n*\n*\n*  REGISTERS USED:\n*\nR0       EQU   0                   MESSAGE LENGTH AT ENTRY\nR1       EQU   1                   MESSAGE ADDRESS AT ENTRY\nR2       EQU   2                   WORK\nRMA      EQU   4                   @MESSAGE TEXT\nRML      EQU   5                   MESSAGE LENGTH\nRUPT     EQU   6                   @UPT (USER PROFILE TABLE)\nRECT     EQU   7                   @ECT\nR12      EQU   12                  CSECT BASE\nR13      EQU   13                  @SAVE AREA AND DYNAMIC WORK AREA\nR14      EQU   14                  WORK/LINKAGE\nR15      EQU   15                  WORK/LINKAGE\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         EJECT\n         IKJCPPL\n         EJECT\n         IKJTCB   LIST=YES                                  *HMD 10/85*\n         EJECT                                              *HMD 10/85*\n         CVT      DSECT=YES,LIST=YES                        *HMD 10/85*\n         EJECT\n         IHAPSA   LIST=YES                                     HD APR88\n         EJECT                                                 HD APR88\nPUTLDS   DSECT\n         DS    18F                      OS SAVE AREA\nPUTAAA   EQU   *\nPUTECB   DS    F                        ECB\nPUTIOPL  DS    4F                       IOPLADS\nPUTBLOK  PUTLINE MF=L\nPUTLEN   DS    H                        LENGTH\nPUTZZZ   DS    H                        RESERVED\nPUTMSG   DS    (MAXMSG)C                MESSAGE TEXT AREA\nPUTSIZE  EQU   *-PUTLDS                 SIZE OF PUTLINE PARMS\n         EJECT\n***********************************************************************\n*  SET UP LINKAGE\n***********************************************************************\n         SPACE 1\nEPUTL    CSECT\n         AIF  (NOT &XA).X001                                *HMD 10/85*\nEPUTL    AMODE 31\n.X001    ANOP                                               *HMD 10/85*\n         STM   14,12,12(13)       SAVE CALLERS REGS\n         LR    R12,R15            COPY EPA\n         USING EPUTL,R12          ADDRESSABILITY\n         AIF   (NOT &XA).X002                               *HMD 10/85*\n         GETMAIN RU,              LV=LENGTH                            &\n               LV=PUTSIZE,        STANDARD OS SA PLUS ANY EXTRA        &\n               LOC=RES            RELATIVE TO 16MB LINE\n         AGO   .X003                                        *HMD 10/85*\n.X002    ANOP                                               *HMD 10/85*\n         GETMAIN RU,              LV=LENGTH                            &\n               LV=PUTSIZE         STANDARD OS SA PLUS ANY EXTRA\n.X003    ANOP                                               *HMD 10/85*\n         ST    1,8(13)            OUR SAVE AREA POINTER\n         ST    13,4(1)            POINTER TO CALLERS SAVE AREA\n         LR    13,1               @OUR SAVE AREA\n         USING PUTLDS,R13         MAP SA AND WORK AREA\n         L     R14,4(R13)         POINT TO CALLERS RSA\n         LM    R0,R1,20(R14)      RESTORE REGS CHANGED BY GETMAIN\n         SPACE 2\n***********************************************************************\n*  UNLOAD ARGUMENTS AND VALIDATE WHERE POSSIBLE\n***********************************************************************\n         SPACE 1\n         LA    R15,RCBA                 ASSUME BAD ADDRESS\n         LTR   RMA,R1                   MESSAGE ADDRESS\n         BNP   RETURN                   GOOD ASSUMPTION\n         LA    R15,RCBL                 ASSUME BAD LENGTH\n         LTR   RML,R0                   POSITIVE?\n         BNP   RETURN                   -NO\n         C     RML,=A(MAXMSG)           MORE THAN MAX?\n         BH    RETURN                   -YES\n         SPACE 2\n***********************************************************************\n*  BUILD PARAMETER LIST\n***********************************************************************\n         SPACE 1\n         LA    R15,4(RML)               MESSAGE LENGTH\n         STH   R15,PUTLEN                 PLUS HEADER\n         XC    PUTZZZ,PUTZZZ            CLEAR 2ND HWORD OF RDW\n         BCTR  RML,0                    REDUCE FOR MOVE\n         EX    RML,PUTMOVE\n         EJECT\n***********************************************************************\n*  DIG UP ADDRESS OF UPT AND ECT\n***********************************************************************\n         SPACE 1\n         L     R2,PSATOLD-PSA           @TCB                   HD APR88\n         L     R2,TCBFSA-TCB(R2)        @1ST PROBLEM PGM SAVE AREA\n         L     R2,24(R2)                REG1 THAT WAS PASSED TO CP\n         USING CPPL,R2                  MAP CPPL\n         L     RUPT,CPPLUPT             @UPT\n         L     RECT,CPPLECT             @ECT\n         SPACE 2\n***********************************************************************\n*  ISSUE PUTLINE CALL\n***********************************************************************\n         SPACE 1\n         XC    PUTECB,PUTECB            CLEAR ECB\n         XC    PUTBLOK(12),PUTBLOK      CLEAR PARM BLOCK       HD APR88\n         PUTLINE PARM=PUTBLOK,          PARAMETER BLOCK                &\n               UPT=(RUPT),              @UPT                           &\n               ECT=(RECT),              @ECT                           &\n               ECB=PUTECB,              @ECB                           &\n               OUTPUT=(PUTLEN,TERM,SINGLE,DATA),                       &\n               MF=(E,PUTIOPL)\n         EJECT\n***********************************************************************\n*  RETURN TO CALLER\n***********************************************************************\n         SPACE 1\nRETURN   EQU   *\n         LR    2,R13                    @OUR SAVE AREA\n         LR    3,R15                    SAVE RETURN CODE\n         L     R13,4(R13)               @CALLERS SAVE AREA\n         FREEMAIN RU,LV=PUTSIZE,A=(R2),SP=0\n         LR    R15,3                    RESTORE RC\n         RETURN (14,12),RC=(15)         RESTORE CALLERS REGS\n         SPACE 5\n***********************************************************************\n*  CONSTANTS AND NON-REENTRANT WORK AREAS\n***********************************************************************\n         SPACE 1\nPUTMOVE  MVC   PUTMSG(*-*),0(RMA)       MOVE MESSAGE TO BUFFER\n         SPACE 2\n         LTORG\n         SPACE 2\n         END   EPUTL\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ASUB$": {"ttr": 3080, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0f\\x001\\x01\\x055O\\x01\\x160O\\x145\\x00\\x1c\\x00\\x1d\\x00\\x00```````@@@'", "ispf": {"version": "01.15", "flags": 0, "createdate": "2005-12-20T00:00:00", "modifydate": "2016-10-30T14:35:31", "lines": 28, "newlines": 29, "modlines": 0, "user": "-------"}, "text": "//IBMUSERU JOB (CCMVS),ASMLINK,\n// NOTIFY=&SYSUID,\n// CLASS=A,MSGCLASS=X,COND=(1,LT)\n//*\n//*     ASM LINKEDIT FROM SOURCE ASM\n//*\n//ASMH EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,NORLD,NOXREF)\n//SYSLIB   DD DISP=SHR,DSN=SYS1.MACLIB\n//         DD DISP=SHR,DSN=SYS1.MODGEN\n//         DD DISP=SHR,DSN=IBMUSER.B.ASM\n//SYSIN    DD DISP=SHR,DSN=IBMUSER.B.ASM(ASUB)\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,9),DISP=(,PASS),DCB=BLKSIZE=3200,\n//            DSN=&&TEMP\n//*\n//LKED   EXEC  PGM=HEWL,\n//       PARM='NCAL,MAP,LIST,LET'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//SYSLMOD  DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//OBJECT   DD  DISP=(OLD,DELETE),DSN=&&TEMP\n//SYSLIN   DD  *\n INCLUDE OBJECT\n SETCODE AC(1)\n ENTRY   ASUB\n NAME    ASUB(R)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ASUBHELP": {"ttr": 3082, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0f\\x00\\x02\\x01\\x07)O\\x01\\x19\"_!\\x05\\x00a\\x00S\\x00\\x00```````@@@'", "ispf": {"version": "01.15", "flags": 0, "createdate": "2007-10-21T00:00:00", "modifydate": "2019-08-13T21:05:02", "lines": 97, "newlines": 83, "modlines": 0, "user": "-------"}, "text": "* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*                                                                     *\n*   Program Name:   ASUB                                              *\n*                                                                     *\n*  Documentation:   This program is meant to be run as a TSO          *\n*                   command, APF authorized, except for the display   *\n*                   functions.                                        *\n*                                                                     *\n*    Environment:   TSO command, APF Authorized.                      *\n*                   PUTLINE interface enabled by APUT, EPUTL.         *\n*                   This program is non-reentrant.                    *\n*                                                                     *\n*    Description:   Display an Auth Table entry from the TSO/E \"auth\" *\n*                   program list tables in storage.  Or display the   *\n*                   entire table.  Or replace one entry with a new    *\n*                   program name.  If you are invoking a display      *\n*                   function, then the entire table is shown, unless  *\n*                   you enter a number, and then, only that slot is   *\n*                   shown.  Only tables manufactured from PARMLIB     *\n*                   entries are displayed or changed, not the ones    *\n*                   created from IKJTABLS in LPALIB, or from the      *\n*                   IKJTABLS load module that was present in an       *\n*                   APF-authorized STEPLIB.                           *\n*                                                                     *\n*       Function:   To substitute one new program name in the global  *\n*                   incore TSO auth tables, IKJEFTE2, IKJEFTE8, or    *\n*                   IKJEFTAP, IKJEFTNS, or even to the PLATCMD or     *\n*                   PLATPGM lists, if they exist.  This is done to    *\n*                   any numbered entry of each table.  Or else merely *\n*                   display the contents of the entire table, or the  *\n*                   contents of any particular numbered entry.        *\n*                                                                     *\n*                   Also, a blanking function can be performed on     *\n*                   the last entry of any table, which is usually     *\n*                   blank anyway.  No blanking can be performed on    *\n*                   a slot in the middle of a table, because that     *\n*                   will invalidate all the table entries after the   *\n*                   blanked slot, and it is too dangerous to do,      *\n*                   when done irresponsibly.                          *\n*                                                                     *\n*         Syntax:   ASUB TTA nnn pgmname                              *\n*                                                                     *\n*                   Where TT is a table code, and A is an action      *\n*                   code.                                             *\n*                                                                     *\n*                   The table code is a nickname for any of the       *\n*                   TSO/E auth tables which are incore.  They are:    *\n*                                                                     *\n*                   E2 - IKJEFTE2 = AUTHCMD                           *\n*                   E8 - IKJEFTE8 = AUTHPGM                           *\n*                   AP - IKJEFTAP = AUTHTSF                           *\n*                   NS - IKJEFTNS = NOTBKGND                          *\n*                   PC - FCVE     = PLATCMD                           *\n*                   PP - PPVE     = PLATPGM                           *\n*                                                                     *\n*                   If the action code is B (blank the last           *\n*                   entry), then no program name is required.         *\n*                                                                     *\n*                   If the action code is D (display the last         *\n*                   entry), then no program name is required.         *\n*                   The default action is to display the entire       *\n*                   table, unless a number is entered.  If a          *\n*                   number is present, then only that entry           *\n*                   number is displayed.  If the number is larger     *\n*                   than the number of entries in that particular     *\n*                   table, then an informative error message is       *\n*                   issued, and the program ends with code = 4.       *\n*                                                                     *\n*                   If the action code is R (replace the program      *\n*                   name) then a number (the table entry number)      *\n*                   and a program name are required.  If you want     *\n*                   to blank the last slot, instead of putting a      *\n*                   program name into it, then use action code B.     *\n*                                                                     *\n*                   If the PLATCMD or PLATPGM keywords (and at least  *\n*                   one name) were not coded in the active IKJTSOxx   *\n*                   PARMLIB entry, then there is no control block of  *\n*                   names to be pointed to, and therefore no addition *\n*                   of names can be made.  The condition is reported. *\n*                                                                     *\n*             Note:  If an E2, E8, AP, or NS table which is being     *\n*                    used by the system, did not come from the        *\n*                    IKJTSOxx PARMLIB entry, but it came from the     *\n*                    default IKJTABLS entry in LPALIB, then an        *\n*                    appropriate error message is displayed, and      *\n*                    no action is performed on that table.            *\n*                                                                     *\n*       Suggestion:  If you want to \"nullify\" any entry in one of     *\n*                    the tables, replace it with a question mark '?'  *\n*                    by entering ASUB xxR nn ? .                      *\n*                                                                     *\n*                    This will replace the program name entry with    *\n*                    a question mark (not an executable program)      *\n*                    but it will not nullify the subsequent table     *\n*                    entries.                                         *\n*                                                                     *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FILE234I": {"ttr": 3085, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x13\\x11\\x1f\\x01\\x13\\x11\\x1f\\x13\\x07%\\xc8%\\xc8\\x00\\x00\\xc4\\xc9\\xe2\\xc1\\xd7\\xc4\\xe2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2013-04-21T00:00:00", "modifydate": "2013-04-21T13:07:00", "lines": 9672, "newlines": 9672, "modlines": 0, "user": "DISAPDS"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "LOADLIB": {"ttr": 7173, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01-\\x003\\x01 \\x08\\x7f\\x01 \\x08\\x7f\\x139\\x16\\x1f\\x16\\x1f\\x00\\x00```````@@@'", "ispf": {"version": "01.45", "flags": 0, "createdate": "2020-03-27T00:00:00", "modifydate": "2020-03-27T13:39:33", "lines": 5663, "newlines": 5663, "modlines": 0, "user": "-------"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "LWAEDIT1": {"ttr": 9477, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00\\x04\\x01\\x082\\x9f\\x01\\x082\\x9f\\x19X\\x009\\x009\\x00\\x00\\xd7\\xc1\\xd5\\xc5\\xd3@@@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "2008-11-24T00:00:00", "modifydate": "2008-11-24T19:58:04", "lines": 57, "newlines": 57, "modlines": 0, "user": "PANEL"}, "text": ")ATTR\n  % TYPE(TEXT)   INTENS(HIGH) CAPS(OFF) JUST(LEFT)            SKIP(ON)\n  + TYPE(TEXT)   INTENS(LOW)  CAPS(OFF) JUST(LEFT)            SKIP(ON)\n  _ TYPE(NEF)    CAPS(ON) PAD(NULLS)\n  \u00ac TYPE(NEF)    CAPS(ON) PAD('.')\n  $ TYPE(NT)\n  ! TYPE(ET)\n  ~ TYPE(LID)\n  \u00a2 TYPE(TEXT)   INTENS(HIGH) CAPS(OFF) JUST(LEFT)            SKIP(OFF)\n)BODY\n%---------------------------------- LWATMgr ------------------------------------\n+Command ===>_ZCMD                                 +Date:%&ZDATE   +Time:%&ZTIME\n+                                                                              +\n      *------------------------------------------------------------------*\n      *                                                                  *\n      *               TSO Authorized Command Table Manager               *\n      *                                                                  *\n      *                                                                  *\n      *------------------------------------------------------------------*\n+                                                                              +\n+                                                                              +\n$Enter!\"/\"$to select table or!\"EXIT\"$/!\"CANCEL\"$to terminate.                  +\n+                                                                              +\n+  \u00acZ~AUTHTSF+  -  Authorized when called through the TSO Service Facility.    +\n+  \u00acZ~AUTHCMD+  -  Authorized Commands.                                        +\n+  \u00acZ~AUTHPGM+  -  Authorized Programs.                                        +\n+  \u00acZ~NOTBKGND+ -  Commands Which May Not Be Issued In The Background.         +\n)INIT\n  &AUTHTSF = 'AUTHTSF'\n  &AUTHCMD = 'AUTHCMD'\n  &AUTHPGM = 'AUTHPGM'\n  &NOTBKGND = 'NOTBKGND'\n\n  .ZVARS='(SEL1 SEL2 SEL3 SEL4)'\n  &SEL1 = &Z\n  &SEL2 = &Z\n  &SEL3 = &Z\n  &SEL4 = &Z\n)PROC\n  &ZCURSOR = .CURSOR\n\n  VER (&SEL1,LIST,'/')\n  VER (&SEL2,LIST,'/')\n  VER (&SEL3,LIST,'/')\n  VER (&SEL4,LIST,'/')\n\n  &ALL = '&SEL1 &SEL2 &SEL3 &SEL4'\n  IF (&ALL = ' ')\n     IF (&ZCURSOR = 'SEL1')\n        &SEL1 = '/'\n     IF (&ZCURSOR = 'SEL2')\n        &SEL2 = '/'\n     IF (&ZCURSOR = 'SEL3')\n        &SEL3 = '/'\n     IF (&ZCURSOR = 'SEL4')\n        &SEL4 = '/'\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LWATEDI@": {"ttr": 9479, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00B\\x01\\t\\x04\\x1f\\x01\\t\\x04/\\x107\\x00G\\x00!\\x00\\x00```````@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "2009-02-10T00:00:00", "modifydate": "2009-02-11T10:37:42", "lines": 71, "newlines": 33, "modlines": 0, "user": "-------"}, "text": "                 NOTES ON HOW TO USE LWATEDIT\n\nThese instructions have to do with LWATEDIT from CBT File 797.  But\nsince the LWATEDIT load module is here too, these are instructions\nfor its use.  The LWATMGR load module is also here, so you can follow\nthese instructions to set them both up.\n\nThe LWATEDIT program was written by Dan Dalby, to make it easier to\nmanipulate your TSO authorization tables, just by editing them.\n\nIngredients:\n\n1.  Copy the LWAEDIT1 panel to one of your ISPPLIB libraries.\n\n2.  Assemble the LWATEDIT program.  It should NOT be APF-authorized.\n\n3.  Assemble the LWATMGR program.  This program has to have its name\n    in the AUTHCMD table (when it is used standalone) and also in the\n    AUTHTSF table (so it can be called by IKJEFTSR from the LWATEDIT\n    program).\n\n4.  Issue the TSO command LWATEDIT from within ISPF.\n\n5.  You will get the LWAEDIT1 panel, which will ask you to pick which\n    table you want to edit.  Place a slash / next to the table you\n    want to edit.  Press ENTER.  You will get a list of 8-character\n    program names that are in the table.  Do what you want with this\n    table, sort it, etc.  When you have finished, if you want to make\n    the new names into a new table, enter SAVE.  Otherwise just END.\n\n    If AUTOSAVE is ON in your EDIT profile, then END will create a\n    new table, because it has followed an implicit SAVE.  Therefore,\n    if you don't want to create a new table, then you have to CANcel\n    the EDIT, whenever AUTOSAVE is ON.\n\n6.  If you SAVEd the table and then exit, LWATEDIT will call LWATMGR\n    using IKJEFTSR (that's why LWATMGR has to be in AUTHTSF), and\n    LWATMGR will update the table with your new SAVEd entries.\n\n7.  Making a new table is easy, just edit the old one with LWATEDIT,\n    change it, SAVE it, and exit.  Easy as pie.  Thanks, Dan Dalby!\n\n8.  One further note.  When you are EDITing a table, you can CREATE\n    a copy of it, or of part of it, and make an LRECL=8 dataset to\n    use against LWATMGR BUILD, or LLWA D, to make a new table at a\n    later time.  You can use LWATEDIT to create lists of programs\n    for use later.  LWATEDIT is a handy way of making a program list.\n\n9.  My own practice is to make a pds with LRECL=8, and I store a large\n    collection of authorization lists there.  So when I use LWATEDIT\n    and CREATE an auth table list, I usually save it in the LRECL=8\n    pds.  When you do this, you have to remember to include the header\n    at the top of the list: \"---E2---\", \"---E8---\", \"---AP---\", or\n    \"---NS---\" so the proper new table will be built from your list\n    of program names.\n\nNOTES:\n\n1.  After removing table lengths with TSUB option Z, be VERY CAREFUL\n    to make sure that the resulting table has a blank at the end of\n    it.  You can use the D option of TSUB to see this.  If there is\n    no blank at the end, and no lengths either, the table might pour\n    over into subsequent storage which follows it, and there will be\n    garbage at the end of the table.  YOU DO NOT WANT TO SAVE THAT!\n\n    One solution:  Use TSUB option B to blank an entry where you think\n    the end of the table is.  Then LWATEDIT the table and SAVE it, and\n    END.  Then check it again with LWATEDIT to make sure that no\n    garbage remains at the table's end.\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RDHSVCA8": {"ttr": 9482, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x11\\x08o\\x01\\x11\\x08o\\x12&\\x00\\x12\\x00\\x12\\x00\\x00```````@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2011-03-27T00:00:00", "modifydate": "2011-03-27T12:26:00", "lines": 18, "newlines": 18, "modlines": 0, "user": "-------"}, "text": "//IBMUSERS JOB (0,0),'TEST',NOTIFY=&SYSUID,\n//             CLASS=A,MSGCLASS=X,MSGLEVEL=(1,1)\n//*\n//** INSERT/REMOVE/REPLACE an SVC - or - Dump the SVCTABLE\n//*\n//*    This job was created for the purpose of testing the SVC\n//*  install program.  This jobstream installs RDHAPSVC which is\n//*  the SVC that provides APF Authorization in an ISPF\n//*  environment.\n//*\n//*UMP      EXEC PGM=RDHINSTL,PARM=DUMP\n//*REMOVE   EXEC PGM=RDHINSTL,PARM='REMOVE,RDHAPSVC,168'\n//*REPLACE  EXEC PGM=RDHINSTL,PARM='REPLACE,RDHAPSVC,168'\n//*\n//INSERT    EXEC PGM=RDHINSTL,PARM='INSERT,RDHAPSVC,168'\n//STEPLIB  DD  DISP=SHR,DSN=IBMUSER.LOAD      <== AUTHORIZED LIBRARY\n//SYSPRINT DD  SYSOUT=*\n//\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "REASMLNK": {"ttr": 9484, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x89\"_\\x00\\x99 \\x9f\\x16!\\x00\\x12\\x00E\\x00\\x05```````@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1989-08-13T00:00:00", "modifydate": "1999-07-28T16:21:00", "lines": 18, "newlines": 69, "modlines": 5, "user": "-------"}, "text": "//REASMLNK PROC\n//ASM    EXEC  PGM=ASMA90,REGION=2048K,\n//             PARM=(DECK,NOOBJECT,NORLD,RENT,TERM,'XREF(SHORT)')\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(CYL,(10,5))\n//SYSUT2   DD  UNIT=SYSDA,SPACE=(CYL,(10,5))\n//SYSUT3   DD  UNIT=SYSDA,SPACE=(CYL,(10,5))\n//SYSPUNCH DD  UNIT=SYSDA,SPACE=(TRK,(5,5)),DISP=(MOD,PASS),DSN=&&X,\n//             DCB=BLKSIZE=3120\n//SYSPRINT DD  SYSOUT=*\n//SYSTERM  DD  SYSOUT=*\n//SYSLIB   DD  DSN=SYS1.MODGEN,DISP=SHR\n//         DD  DSN=SYS1.MACLIB,DISP=SHR\n//LKED   EXEC  PGM=IEWL,PARM='MAP,RENT,REUS,REFR,LET,NCAL',COND=(0,LT)\n//SYSPRINT DD  SYSOUT=*\n//SYSLIBX  DD  DSN=&&X,DISP=(OLD,DELETE)\n//SYSLMOD  DD  DISP=SHR,DSN=&OUTPUT\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(TRK,(5,5))\n//       PEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "REGEQU": {"ttr": 9486, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x89\\x13\\x7f\\x00\\x89\\x17\\x1f\\x178\\x00\\x13\\x00\\x10\\x00\\x00```````@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1989-05-17T00:00:00", "modifydate": "1989-06-20T17:38:00", "lines": 19, "newlines": 16, "modlines": 0, "user": "-------"}, "text": "         MACRO\n         REGEQU\nR0       EQU   0       R\nR1       EQU   1         E\nR2       EQU   2           G\nR3       EQU   3             I\nR4       EQU   4               S\nR5       EQU   5                 T\nR6       EQU   6                   E\nR7       EQU   7                     R\nR8       EQU   8                            E\nR9       EQU   9                              Q\nR10      EQU   10                               U\nR11      EQU   11                                 A\nR12      EQU   12                                   T\nR13      EQU   13                                     E\nR14      EQU   14                                       S\nR15      EQU   15\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "REGS": {"ttr": 9488, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x89\\x13\\x7f\\x00\\x89\\x13\\x8f \\x00\\x00\\x10\\x00\\x10\\x00\\x00```````@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1989-05-17T00:00:00", "modifydate": "1989-05-18T20:00:00", "lines": 16, "newlines": 16, "modlines": 0, "user": "-------"}, "text": "R0       EQU   0       R\nR1       EQU   1         E\nR2       EQU   2           G\nR3       EQU   3             I\nR4       EQU   4               S\nR5       EQU   5                 T\nR6       EQU   6                   E\nR7       EQU   7                     R\nR8       EQU   8                            E\nR9       EQU   9                              Q\nR10      EQU   10                               U\nR11      EQU   11                                 A\nR12      EQU   12                                   T\nR13      EQU   13                                     E\nR14      EQU   14                                       S\nR15      EQU   15\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SHOWTPV$": {"ttr": 9490, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0f\\x00\\x13\\x00\\x91\\x12?\\x01\\x19\\x00?\\x01%\\x00\\x1f\\x00\\x0e\\x00\\x00```````@@@'", "ispf": {"version": "01.15", "flags": 0, "createdate": "1991-05-03T00:00:00", "modifydate": "2019-01-03T01:25:13", "lines": 31, "newlines": 14, "modlines": 0, "user": "-------"}, "text": "//IBMUSERU JOB (CCMVS),ASMLINK,\n// NOTIFY=&SYSUID,\n// CLASS=B,MSGCLASS=X,COND=(1,LT)\n//*\n//*     ASM LINKEDIT FROM SOURCE ASM\n//*\n//ASMH EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,NORLD,BATCH,FLAG(5))\n//*YSLIB   DD DISP=SHR,DSN=SYS1.Z23.MACLIB\n//SYSLIB   DD DISP=SHR,DSN=SYS1.MACLIB\n//         DD DISP=SHR,DSN=SYS1.MODGEN\n//*        DD DISP=SHR,DSN=IBMUSER.TPVT.MACLIB\n//SYSIN    DD DISP=SHR,DSN=IBMUSER.B.ASM(SHOWTPVT)\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),DCB=BLKSIZE=3200,\n//            DSN=&&TEMP\n//*\n//LKED   EXEC  PGM=HEWL,\n//       PARM='NCAL,MAP,LIST,LET'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//SYSLMOD  DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//OBJECT   DD  DISP=(OLD,DELETE),DSN=&&TEMP\n//SYSLIN   DD  *\n INCLUDE OBJECT\n ENTRY   SHOWTPVT\n SETCODE AC(0)\n SETSSI  CB497731\n NAME    SHOWTPVT(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SHOWTPVT": {"ttr": 9492, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x008\\x00\\x804_\\x01\\x19\\x00/ \\x12\\x04\\xe6\\x01\\xcf\\x00\\x00```````@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1980-12-10T00:00:00", "modifydate": "2019-01-02T20:12:38", "lines": 1254, "newlines": 463, "modlines": 0, "user": "-------"}, "text": "         TITLE ' SHOW AND EXPLAIN ALL TPVT FIELDS  '\n************************************************************\n*        'SHOWTPVT' OR 'LIST TPVT FIELDS AND EXPLAIN THEM' *\n************************************************************\n         SPACE\n*\n*        This program is in the Public Domain.\n*\n*        THIS PROGRAM WAS CONSTRUCTED FROM THE LPSCB PROGRAM,\n*        WHICH WAS:\n*        WRITTEN BY. BILL GODFREY,  PLANNING RESEARCH CORPORATION.\n*        INSTALLATION. PRC COMPUTER CENTER INC, MCLEAN VA.\n*        DATE WRITTEN. OCTOBER 19 1979.\n*        DATE UPDATED. MAY 10, 1995   SAM GOLOB\n*                      NOV 28, 2016   SAM GOLOB\n*                      MAR 10, 2017   SAM GOLOB\n*        DATE CHANGED. JAN 02, 2019   SAM GOLOB\n*\n*        ATTRIBUTES. RE-ENTRANT.\n*\n*        COMMENTS.\n*            THIS TSO COMMAND SHOWS ALL THE FIELDS OF THE\n*            UNDOCUMENTED IBM CONTROL BLOCK, TPVT, SHORT FOR\n*            \"TSO PARMLIB VECTOR TABLE\", DESCRIBED BY THE IBM\n*            INTERNAL MACRO, IKJTPVT, WRITTEN IN PL/X ONLY.\n*\n*            OF COURSE WE DON'T HAVE THE ORIGINAL IBM MACRO.\n*            WE HAVE RECONSTRUCTED THE IKJTPVT MACRO IN\n*            ASSEMBLER LANGUAGE, AND OUR DESCRIPTION OF IT,\n*            AND ITS FIELDS, IS INCLUDED IN THIS SOURCE CODE.\n*            THE FIELD NAMES IN OUR ASSEMBLER COPY OF THE\n*            MACRO HAVE TO BE CONSIDERED AS ENTIRELY OUR OWN\n*            DESCRIPTIONS, EVEN THOUGH SOME OF THEM MAY\n*            CLOSELY RESEMBLE THEIR POSSIBLE IBM DESCRIPTIONS\n*            (WHICH WE DON'T REALLY KNOW).\n*\n*        CHANGE LOG:\n*           JDM - JIM MARSHALL\n*           SBG - SAM GOLOB\n*\n*     These remarks pertain to the LPSCB program:\n*     JDM    02APR91 - ADDED DSECTS TO REPLACE HARDCODED OFFSETS JDM1\n*     SBG    28NOV16 - LIST 8 HEX DIGIT ADDRESSES INSTEAD OF 6.\n*                      CHANGED AMODE TO 31. DIDN'T SEEM TO HURT.\n*     SBG    10MAR17 - FIXES FOR 8-CHARACTER USERIDS.\n*                      DEPENDS ON TSVT+6 BYTE. PROGRAM DEPENDS ON\n*                      TSVT NOW, WHICH IT DIDN'T DEPEND ON BEFORE.\n*\n*     The remarks from here on, pertain to the SHOWTPVT program:\n*     SBG    02JAN19 - Changed the program to display fields in the\n*                      undocumented TPVT only.  It is now a new\n*                      program, but many pieces of the old program\n*                      remain.\n*\n*                      Please note that the TPVTUMXL field described\n*                      in the TPVT, indicating whether 8-character\n*                      userids are supported or not, seems to be just\n*                      an \"indicator of status\" and not a switch to\n*                      turn the 8-character userid capability on or\n*                      off.\n*\n*                      The \"real switch\", that turns 8-character userid\n*                      support on or off, is located at the TSVT+6\n*                      location for one byte.\n*\n*                      This program actually reports the status of\n*                      both bytes.  The \"real switch\" byte status is\n*                      reported in the header of this program, where\n*                      it says:  8-CHARACTER USERID SUPPORT IS: ON|OFF\n*                      while the TPVTUMXL byte is reported in the\n*                      detail part of the program below.\n*\n*\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n         MACRO\n&NAME    HEX   &TO,&LEN,&FROM\n&NAME    LA    1,&FROM\n         LA    0,&LEN\n         LA    15,&TO\n         BAL   14,HEX\n         MEND\n         SPACE\n         MACRO\n&NAME    MSGZ  &AREA,&LEN\n         LA    1,&AREA\n         LA    0,&LEN\n         BAL   R14,PUTLINE\n         MVC   LINE,LINE-1\n         MEND\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*    This macro must be included in this assembly, and is our         *\n*    interpretation of IBM's \"internal use only\" control block        *\n*    macro, IKJTPVT (which we haven't ever actually seen).            *\n*  The names in this macro have been adjusted for format with CBMACS. *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n         MACRO\n         IKJTPVT\nTPVT     DSECT                         TSO PARMLIB VECTOR TABLE\nTPVT_ID  DS    CL4'TPVT'            00 BLOCK ID\nTPVT_LEN DS    H'72'                04 LENGTH OF TPVT\n****     DS    H'220'                  LENGTH OF TPVT\nTPVT_VERS DS   FL1'2'               06 VERSION\nTPVT_MEM1 DS  0C'IKJTSO00'          07 CURRENT PARMLIB MEMBER  HTE25E2\nTPVTFIL1 DS    X                 (above field was moved one byte down)\nTPVT_MEM DS    CL8'IKJTSO00'        08 CURRENT PARMLIB MEMBER  HTE26E2\nTPVT_GEN DS    F                    10 PARMLIB generation count\nTPVTCTLT DS    V(CTLT)              14 IKJCTLT\nTPVTCTLTLEN  DS F'60'               18 length of CTLT\n         DS    4X                   1C\nTPVTSEND DS    V(SCB)               20 IKJEESCB   (SYS1.BRODCAST)\nTPVTALPL DS    V(ALPL)              24 ALPL       (ALLOCATE defaults)\nTPVTTEST DS    V(TPT)               28 TPT (TEST)\nTPVTXPRMD DS   V(XPRM)              2C INMXPARM   (XMIT)\nTPVTCONSOLE DS V(CNPRM)             30 IKJCNPRM   (CONSOLE)\nTPVTFCVEC DS   A,F                  34 FCVE       (Platform commands)\nTPVTHELP DS    V(HCB)               3C IKJEFHCB   (HELP)\nTPVTPPVEC DS   A,F                  40 PPVE       (Platform programs)\n           ORG  TPVT+X'4C'\nTPVTLOGON DS   X                    4C IKJTSOxx LOGON KEYWORD\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n* The following bit settings must correspond to the same bit settings *\n* in the TSVTFLG1 field of the TSVT (TSVT + X'5') - lower nibble only *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nTPVTPHRS  EQU  X'08'                Password phrase support active\nTPVTAPPL  EQU  X'04'                LOGON applid verification active\nTPVTLGNH  EQU  X'02'                LOGONHERE support is active\nTPVTLGPC  EQU  X'01'                LOGONPREPROMPT is active\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nTPVTUMXL  DS   X                4D  MAXIMUM NUMBER OF CHARS IN USERID\n*   This is a reflection of the value in TSVTUMXL, but the \"real      *\n*   switch\" where the system \"decides\" if 8-character userids are     *\n*   allowed, appears to be TSVT+X'6', not in this value.              *\n*   Permissible values:  X'00' for pre z/OS 2.3 systems               *\n*                        X'07' for z/OS 2.3 with 8-char uids off.     *\n*                        X'08' for z/OS 2.3 with 8-char uids on.      *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n           ORG  TPVT+X'50'\nTPVTDSNAM  DS  CL44'SYS1.PARMLIB'   50 dsname\nTPVTVOLSER DS  CL6'SYSCAT'          7C VOLSER\n           DS  2X\nTPVTSYSNAM DS  CL8'P390'            84 from system\nTPVTUSERID DS  CL8'IBMUSERM'        8C by userid\nTPVTHHMMSS DS  CL8'16:59:56'        94 at hh:mm:ss\nTPVTYYMMDD DS  CL10'1998-10-29'     9C on yyyy-mm-dd\nTPVTCPUIDP DS  XL2                  A6 CPUID prefix\nTPVTCPUID  DS  F                    A8 CPUID\nTPVTMODEL  DS  H                    AC CPU Model\nTPVTUPDTIM DS  XL4                  AA Update Time\nTPVTUPDDAT DS  XL4                  B2 Update Date\nTPVTFEATURE DS  X                   B6 Feature\n*              X'80'            Dynamic Broadcast Feature is available\nTPVTFEATVER DS X                    B7 Feature Version\n         ORG   TPVT+X'DC'              end of TPVT\n         MEND\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n         GBLC  &SYSLVL\n&SYSLVL  SETC  'ESA'                 370 OR ESA ?\n*                                    SET ESA FOR TSO/E VERSION 2\n*                                    SET 370 FOR MVS/370.\n*   LOOK AT YOUR LEVEL OF IKJUPT TO SEE HOW MUCH CAN DISPLAY.\n*   SEE BELOW LABEL :    DOUPT\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n         PRINT ON,GEN\nSHOWTPVT AMODE 31                                                JDM1\nSHOWTPVT RMODE 24                                                JDM1\nSHOWTPVT CSECT\n         USING *,R12,R10\n         B     @PROLOG-*(,15)\n         DC    AL1(11),CL11'SHOWTPVT '\n         DC    CL16' &SYSDATE &SYSTIME '\n         DC    CL16' Public Domain '\n@SIZE    DC    0F'0',AL1(1),AL3(@DATAL)\n@PROLOG  STM   14,12,12(R13)       SAVE REGISTERS\n         LR    R12,R15             LOAD BASE REGISTER\n         LA    R10,2048(,R12)      Load second base\n         LA    R10,2048(,R10)\n         LR    R2,R1               PARM POINTER\n         USING CPPL,R2\n         L     R0,@SIZE            WORKAREA SUBPOOL AND LENGTH\n         GETMAIN R,LV=(0)\n         LR    R9,R1               INITIALIZE WORKAREA POINTER\n         USING @DATA,R9\n         SPACE 1\n         ST    R13,4(,R9)          CHAIN SAVEAREA\n         ST    R9,8(,R13)          CHAIN SAVEAREA\n         LR    R13,R9              UPDATE SAVEAREA POINTER\n         SPACE\n         MVI   LINE-1,C' '\n         XC    LINKAREA(8),LINKAREA\n         L     R0,=V(TODCNVRT)     ENTRY PT OF TODCNVRT PROGRAM\n         ST    R0,ENTRY            SAVE ITS ENTRY POINT\n         SPACE\n************************************************************\n*        SET UP IOPL FOR PUTLINE                           *\n************************************************************\n         SPACE\n         LA    R15,MYIOPL\n         USING IOPL,R15\n         MVC   IOPLUPT(4),CPPLUPT\n         MVC   IOPLECT(4),CPPLECT\n         LA    R0,MYECB\n         ST    R0,IOPLECB\n         XC    MYECB,MYECB\n         LA    R0,MYPTPB\n         ST    R0,IOPLIOPB\n         DROP  R15\n         SPACE\n         L     R15,CVTPTR          POINT TO CVT                  JDM1\n         USING CVTMAP,R15          GET ADDRESSABILITY            JDM1\n         TM    CVTPUTL,X'80'       IS PUTLINE LOADED? (VS2)      JDM1\n         BNO   PUTLOAD             NO - BRANCH TO LOAD\n         L     R15,CVTPUTL         YES - USE CVTPUTL             JDM1\n         DROP  R15                                               JDM1\n         B     PUTLOADX            BRANCH AROUND LOAD\nPUTLOAD  LA    R0,=CL8'IKJPUTL '\n         LOAD  EPLOC=(0)\n         LR    R15,R0              GET ENTRY ADDRESS\n         LA    R15,0(,R15)         CLEAR HI BYTE FOR DELETE ROUTINE\nPUTLOADX ST    R15,MYPUTLEP        SAVE PUTLINE ENTRY ADDRESS\n         SPACE\n         SPACE 1\n************************************************************\n*        SET UP PPL FOR PARSE                              *\n************************************************************\n         SPACE\n         LA    R15,MYPPL\n         USING PPL,R15\n         MVC   PPLUPT(4),CPPLUPT\n         MVC   PPLECT(4),CPPLECT\n         LA    R0,MYECB\n         ST    R0,PPLECB\n         XC    MYECB,MYECB\n         L     R0,=A(MYPCL)\n         ST    R0,PPLPCL\n         LA    R0,MYANS\n         ST    R0,PPLANS\n         MVC   PPLCBUF(4),CPPLCBUF\n         ST    R13,PPLUWA\n         DROP  R15\n         SPACE 1\n************************************************************\n*        CALL THE PARSE SERVICE ROUTINE                    *\n************************************************************\n         SPACE 1\n         LR    R1,R15              POINT TO PPL\n         L     R15,CVTPTR          POINT TO CVT                  JDM1\n         USING CVTMAP,R15          GET ADDRESSABILITY            JDM1\n         TM    CVTPARS,X'80'       IF HI ORDER BIT NOT ON        JDM1\n         BNO   PARSELNK               THEN DO LINK, NOT CALL\n         L     R15,CVTPARS         CVTPARS                       JDM1\n         DROP  R15                                               JDM1\n         BALR  R14,R15             CALL IKJPARS\n         B     PARSEEXT            SKIP AROUND LINK\nPARSELNK DS    0H\n         LINK  EP=IKJPARS,SF=(E,LINKAREA)\nPARSEEXT DS    0H\n         SPACE 1\n         LTR   R15,R15\n         BNZ   EXIT12\n         L     R3,MYANS\n         USING IKJPARMD,R3\n         L     R4,CPPLPSCB\n         CLI   ALLKW+1,1           'ALL SPECIFIED'\n         BE    TESTTSVT\n         CLI   REALKW+1,2          'REAL' SPECIFIED\n         BNE   TESTTSVT            NO, BRANCH\n         L     R1,CVTPTR           YES, FIND PSCB VIA JSCB       JDM1\n         USING CVTMAP,R1           GET ADDRESSABILITY            JDM1\n         L     R1,CVTTCBP          POINT TO NEW TCB WORD         JDM1\n         L     R1,4(,R1)           POINT TO OLD TCB WORD         JDM1\n         DROP  R1                                                JDM1\n         USING TCB,R1              ADDRESSABILITY TO TCB         JDM1\n         L     R1,TCBJSCB          GET JSCB ADDRESS              JDM1\n         DROP  R1                                                JDM1\n         USING IEZJSCB,R1          GET ADDRESSABILITY            JDM1\n         L     R1,JSCBPSCB         GET PSCB ADDRESS              JDM1\n         ST    R1,SAVEPSCB         SAVE IT EVEN IF WE DON'T USE IT\n         DROP  R1                                                JDM1\n         LTR   R4,R1               IS THERE A PSCB\n         BZ    EXIT12              NO, BRANCH\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*        TEST FOR PRESENCE OF 8-CHARACTER USERID SUPPORT            *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nTESTTSVT DS    0H                  TEACH PGM ABOUT 8-CHAR ID SUPPORT\n         ST    R6,SAVER6A          SAVE WORK REGISTER\n         XC    FLAG1,FLAG1         CLEAR FLAG\n         L     R6,16               CVT\n         L     R6,X'9C'(,R6)       TSVT\n         ST    R6,TSVTADDR         SAVE ADDRESS OF TSVT\n         L     R6,X'4C'(,R6)       TPVT ADDRESS\n         ST    R6,TPVTADDR         SAVE ADDRESS OF TPVT\n         L     R6,TSVTADDR         RELOAD TSVT ADDRESS FOR TEST\n         TM    6(R6),X'08'         IS THIS FIELD 08?\n         BO    TEST8CHR            FLIP FLAG BIT\n         CLI   6(R6),X'00'         IS IT 00, THE OLD WAY?\n         BE    TEST8END            YES. DON'T FLIP ANYTHING\nTEST7CHR DS    0H                  NOT 00 AND NOT 08.\n         OI    FLAG1,X'01'         SUPPORT ON BUT 7-CHAR UID LIMIT\n         B     TEST8END            THEN GET OUT\nTEST8CHR DS    0H                  8-CHAR SUPPORT IS ON\n         OI    FLAG1,X'02'         SUPPORT ON AND 8-CHAR UID LIMIT\nTEST8END DS    0H                  END OF ROUTINE\n         L     R6,SAVER6A          RESTORE WORK REGISTER\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*                  PRINT TITLE OF THIS REPORT                       *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n         MVC   LINE,LINE-1\n         MVC   LINET(45),TITLELIT     Program title\n         BAL   R8,MSG\n         MVC   LINE,LINE-1\n         MVC   LINET(45),TITLEUND     Underlines\n         BAL   R8,MSG\n         MVC   LINE,LINE-1\n         MVC   LINET(44),TITLEEX0     Explanation of program purpose\n         BAL   R8,MSG\n         MVC   LINET(44),TITLEEX1     Underlines\n         BAL   R8,MSG\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*   IF 8-CHARACTER USERID SUPPORT IS PRESENT, THEN SEND MESSAGE     *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*              It is important to know if there exists              *\n*              8-character userid support.                          *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nEIGHTCID DS    0H\n         CLI   FLAG1,X'00'         NO 8-CHARACTER SUPPORT\n         BE    EIGHTOUT            THEN GET OUT\n         TM    FLAG1,X'01'         SUPPORT IS PRESENT BUT NOT ON\n         BO    EIGHTOFF            THEN REPORT IT\n         TM    FLAG1,X'02'         SUPPORT IS PRESENT AND IS ON\n         BO    EIGHTON             THEN REPORT IT\n*                                  MSG IF 8-CHAR UID'S IN EFFECT\nEIGHTOFF DS    0H                       OFF\n         MVI   LINE-1,X'40'             BLANK MSG LINE\n         MVC   LINE,LINE-1\n         MVC   LINEU(L'MSG04),MSG04      YES, BUT\n         BAL   R8,MSG                   SUPPORT IS TURNED OFF\n         B     EIGHTOUT\nEIGHTON  DS    0H                       ON\n         MVI   LINE-1,X'40'             BLANK MSG LINE\n         MVC   LINE,LINE-1\n         MVC   LINEU(L'MSG05),MSG05      YES, AND\n         BAL   R8,MSG                   SUPPORT IS TURNED ON\n         B     EIGHTOUT\nEIGHTOUT DS    0H\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*                 PRINT THE ADDRESS OF THE TPVT                     *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n         L     R4,TPVTADDR\n         HEX   LINE+33,4,TPVTADDR\n         MVC   LINE+17(L'MSG01),MSG01\n         MSGZ  LINE,L'MSG01+28\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*                  PRINT REPORT TITLE HEADERS                       *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n         MVC   LINE,LINE-1\n         MVC   LINE(49),TITLEHDR\n         BAL   R8,MSG\n         MVC   LINE,LINE-1\n         MVC   LINE(49),TITLEHUN\n         BAL   R8,MSG\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*                FORMAT FIELDS OF THE TPVT LAYOUT                   *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nGOTTPVT  DS    0H\n         USING TPVT,R4\n         MVC   LINE,LINE-1\n         L     R4,TPVTADDR\n         MVC   LINETXT,TEXT_ID\n*        HEX   LINEX,4,TPVT_ID\n         MVC   LINEX(4),TPVT_ID\n         MVC   LINEC(24),=C'Control block identifier'\n         BAL   R8,MSG\n         SPACE\n         MVC   LINETXT,TEXT_LEN\n         HEX   LINEX,2,TPVT_LEN\n         MVC   LINEC(18),=C'TPVT length in hex'\n         BAL   R8,MSG\n         SPACE\n         MVC   LINETXT,TEXT_VER\n         HEX   LINEX,1,TPVT_VERS\n         MVC   LINEC(18),=C'TPVT version level'\n         BAL   R8,MSG\n         SPACE\n         MVC   LINETXT,TEXT_FL1\n         HEX   LINEX,1,TPVTFIL1\n         BAL   R8,MSG\n         SPACE\n         MVC   LINETXT,TEXT_MEM\n*        HEX   LINEX,8,TPVT_MEM\n         MVC   LINEX(8),TPVT_MEM\n         MVC   LINEC(32),=C'PARMLIB member filling this TPVT'\n         BAL   R8,MSG\n         SPACE\n         MVC   LINETXT,TEXT_GEN\n         HEX   LINEX,4,TPVT_GEN\n         MVC   LINEC(32),=C'TPVT generation number, fullword'\n         BAL   R8,MSG\n         SPACE\n         MVC   LINETXT,TEXT_CTL\n         HEX   LINEX,4,TPVTCTLT\n         MVC   LINEC(32),=C'CTLT addr, points to auth tables'\n         BAL   R8,MSG\n         SPACE\n         MVC   LINETXT,TEXTCTLN\n         HEX   LINEX,4,TPVTCTLTLEN\n         MVC   LINEC(25),=C'CTLT control block length'\n         BAL   R8,MSG\n         SPACE\n         MVC   LINETXT,TEXTRSV1\n         HEX   LINEX,4,TPVT+X'1C'\n         BAL   R8,MSG\n         SPACE\n         MVC   LINETXT,TEXTSEND\n         HEX   LINEX,4,TPVTSEND\n         MVC   LINEC(33),=C'IKJEESCB-SEND PARMLIB contr block'\n         BAL   R8,MSG\n         SPACE\n         MVC   LINETXT,TEXTALPL\n         HEX   LINEX,4,TPVTALPL\n         MVC   LINEC(29),=C'ALPL addr, default allocation'\n         L     R8,TPVTALPL\n         TM    12(R8),X'80'\n         BO    ALPLOLD\n         TM    12(R8),X'40'\n         BO    ALPLSHR\n         B     ALPLEND\nALPLOLD  DS    0H\n         MVC   LINEC+30(3),=C'OLD'\n         B     ALPLEND\nALPLSHR  DS    0H\n         MVC   LINEC+30(3),=C'SHR'\nALPLEND  DS    0H\n         BAL   R8,MSG\n         SPACE\n         MVC   LINETXT,TEXTTEST\n         HEX   LINEX,4,TPVTTEST\n         MVC   LINEC(32),=C'TPT addr, TEST cmd control block'\n         BAL   R8,MSG\n         SPACE\n         MVC   LINETXT,TEXTXPRM\n         HEX   LINEX,4,TPVTXPRMD\n         MVC   LINEC(32),=C'INMXPARM address-SEND parameters'\n         BAL   R8,MSG\n         SPACE\n         MVC   LINETXT,TEXTCNSL\n         HEX   LINEX,4,TPVTCONSOLE\n         MVC   LINEC(30),=C'TSO CONSOLE command parameters'\n         BAL   R8,MSG\n         SPACE\n         MVC   LINETXT,TEXTFCVE\n         HEX   LINEX,4,TPVTFCVEC\n         MVC   LINEC(31),=C'Address-PLATFORM commands table'\n         BAL   R8,MSG\n         SPACE\n         MVC   LINETXT,TEXTHELP\n         HEX   LINEX,4,TPVTHELP\n         MVC   LINEC(26),=C'Address-HELP datasets list'\n         BAL   R8,MSG\n         SPACE\n         MVC   LINETXT,TEXTPPVE\n         HEX   LINEX,4,TPVTPPVEC\n         MVC   LINEC(31),=C'Address-PLATFORM programs table'\n         BAL   R8,MSG\n         SPACE\n         MVC   LINETXT,TEXTRSV2\n         HEX   LINEX,8,TPVT+X'44'\n         BAL   R8,MSG\n         SPACE\n         MVC   LINETXT,TEXTLOGO\n         HEX   LINEX,1,TPVTLOGON\n         MVC   LINEC(27),=C'LOGON option fields - bits:'\n         BAL   R8,MSG\n         MVC   LINEC(30),TEXTLG1A\n         BAL   R8,MSG\n         MVC   LINEC(30),TEXTLG1B\n         BAL   R8,MSG\n         MVC   LINEC(30),TEXTLG1C\n         BAL   R8,MSG\n         MVC   LINEC(30),TEXTLG1D\n         BAL   R8,MSG\n         SPACE\n         MVC   LINETXT,TEXTUMXL\n         HEX   LINEX,1,TPVTUMXL\n         MVC   LINEC(30),=C'8-char userid status indicator'\n         BAL   R8,MSG\n         SPACE\n         MVC   LINETXT,TEXTRSV3\n         HEX   LINEX,2,TPVT+X'4E'\n         BAL   R8,MSG\n         SPACE\n         MVC   LINETXT,TEXTDSNM\n         MVC   LINEX(44),TPVTDSNAM\n         MVC   LINE+58(14),=C'PARMLIB dsname'\n         BAL   R8,MSG\n         SPACE\n         MVC   LINETXT,TEXTVOLS\n         MVC   LINEX(6),TPVTVOLSER\n         MVC   LINE+58(14),=C'and its volser'\n         BAL   R8,MSG\n         SPACE\n         MVC   LINETXT,TEXTRSV4\n         HEX   LINEX,2,TPVT+X'82'\n         BAL   R8,MSG\n         SPACE\n         MVC   LINETXT,TEXTSNAM\n         MVC   LINEX(8),TPVTSYSNAM\n         MVC   LINEC(25),=C'ID of this system or LPAR'\n         BAL   R8,MSG\n         SPACE\n         MVC   LINETXT,TEXTUSID\n         MVC   LINEX(8),TPVTUSERID\n         MVC   LINEC(31),=C'Who did the last PARMLIB update'\n         BAL   R8,MSG\n         SPACE\n         MVC   LINETXT,TEXTTIME\n         MVC   LINEX(8),TPVTHHMMSS\n         MVC   LINEC(28),=C'Time HHMMSS when it was done'\n         BAL   R8,MSG\n         SPACE\n         MVC   LINETXT,TEXTDATE\n         MVC   LINEX(10),TPVTYYMMDD\n         MVC   LINEC(30),=C'Date YYYYMMDD when it was done'\n         BAL   R8,MSG\n         SPACE\n         MVC   LINETXT,TEXTCPIP\n         HEX   LINEX,2,TPVTCPUIDP\n         MVC   LINEC(12),=C'CPUID prefix'\n         BAL   R8,MSG\n         SPACE\n         MVC   LINETXT,TEXTCPUI\n         HEX   LINEX,4,TPVTCPUID\n         MVC   LINEC(21),=C'CPUID of this machine'\n         BAL   R8,MSG\n         SPACE\n         MVC   LINETXT,TEXTMODN\n         HEX   LINEX,2,TPVTMODEL\n         MVC   LINEC(16),=C'CPU model number'\n         BAL   R8,MSG\n         SPACE\n         MVC   LINETXT,TEXTUPDT\n         HEX   LINEX,4,TPVTUPDTIM\n         MVC   LINEC(25),=C'TIME when updated, in hex'\n         BAL   R8,MSG\n         SPACE\n         MVC   LINETXT,TEXTUPDD\n         HEX   LINEX,4,TPVTUPDDAT\n         MVC   LINEC(25),=C'DATE when updated, in hex'\n         BAL   R8,MSG\n         SPACE\n         MVC   LINETXT,TEXTFEAT\n         HEX   LINEX,1,TPVTFEATURE\n         MVC   LINEC(13),=C'Feature codes'\n         BAL   R8,MSG\n         SPACE\n         MVC   LINETXT,TEXTFEAV\n         HEX   LINEX,1,TPVTFEATVER\n         MVC   LINEC(15),=C'Feature version'\n         BAL   R8,MSG\n         SPACE\n         MVC   LINETXT,TEXTRSV5         SPLIT THE RESERVE AREA\n         HEX   LINEX,18,TPVT+X'B8'\n         BAL   R8,MSG\n         SPACE\n         MVC   LINETXT,TEXTRS5A         INTO TWO LINES.\n         HEX   LINEX,18,TPVT+X'CA'\n         BAL   R8,MSG\n         SPACE\nTSVTEND  B     EXIT0\n         SPACE\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*     ROUTINE TO SHOW HEXADECIMAL VALUES AS DISPLAY CHARACTERS      *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nHEX      MVC   1(1,R15),0(R1)      MOVE BYTE\n         UNPK  0(3,R15),1(2,R15)   UNPACK\n         TR    0(2,R15),HEXTAB-240\n         LA    R15,2(,R15)         INCREMENT OUTPUT PTR\n         LA    R1,1(,R1)           INCREMENT INPUT PTR\n         BCT   R0,HEX              DECREMENT LENGTH, THEN LOOP\n         MVI   0(R15),C' '         BLANK THE TRAILING BYTE\n         BR    R14                 RETURN TO CALLER\nHEXTAB   DC    C'0123456789ABCDEF' TRANSLATE TABLE\n         SPACE\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nMSG      LA    R1,LINE             DISPLAY A MESSAGE W/PUTLINE\n         LA    R0,72\n         BAL   R14,PUTLINE\n         MVC   LINE,LINE-1\n         BR    R8\n         SPACE\n************************************************************\n*        PUTMSG ROUTINE                                    *\n************************************************************\n         SPACE\nPUTMSG   STM   R14,R1,PUTSAVE\n         XC    MYOLD(8),MYOLD\n         XC    MYSEG1(4),MYSEG1\n         MVC   MYPTPB(12),MODLPTPM\n         LA    R14,1               NO. OF MESSAGE SEGMENTS\n         ST    R14,MYOLD\n         LA    R14,MYSEG1          POINT TO 1ST SEGMENT\n         ST    R14,MYOLD+4\n         LR    R14,R0              LENGTH IN R0\n         LA    R14,4(,R14)         ADD 4\n         LA    R15,MYSEG1+4\n         CLC   0(3,R1),=C'IKJ'     IS DATA PRECEEDED BY MESSAGE ID?\n         BE    *+16                YES - BRANCH\n         LA    R14,1(,R14)         ADD 1 TO LENGTH\n         MVI   0(R15),C' '         INSERT LEADING BLANK\n         LA    R15,1(,R15)         BUMP POINTER\n         STH   R14,MYSEG1\n         LR    R14,R0\n         BCTR  R14,0\n         B     *+10\n         MVC   0(0,R15),0(R1)      MOVE MESSAGE IN\n         EX    R14,*-6\n         LA    R1,MYIOPL\n         L     R15,MYPUTLEP\n         SPACE\n         PUTLINE PARM=MYPTPB,OUTPUT=(MYOLD),ENTRY=(15),MF=(E,(1))\n         SPACE\n         LM    R14,R1,PUTSAVE\n         BR    R14\n         SPACE\n************************************************************\n*        PUTLINE ROUTINE                                   *\n************************************************************\n         SPACE\nPUTLINE  STM   R14,R1,PUTSAVE\n         XC    MYSEG1(4),MYSEG1\n         MVC   MYPTPB(12),MODLPTPB\n         LR    R14,R0              LENGTH IN R0\n         LA    R14,4(,R14)         ADD 4\n         STH   R14,MYSEG1\n         LR    R14,R0\n         BCTR  R14,0\n         B     *+10\n         MVC   MYSEG1+4(0),0(R1)   MOVE TEXT IN\n         EX    R14,*-6\n         LA    R1,MYIOPL\n         L     R15,MYPUTLEP\n         SPACE\n         PUTLINE PARM=MYPTPB,OUTPUT=(MYSEG1,DATA),ENTRY=(15),MF=(E,(1))\n         SPACE\n         LM    R14,R1,PUTSAVE\n         BR    R14\n         SPACE 1\nEXIT0    SR    R15,R15             RETURN CODE ZERO\n         B     EXIT\nEXIT12   LA    R15,12              RETURN CODE 12\nEXIT     LR    R2,R15              SAVE RETURN CODE\nEXITX    LR    R15,R2              RESTORE RETURN CODE\n         LR    R1,R13              POINT R1 TO AREA TO BE FREED\n         L     R0,@SIZE            SUBPOOL AND LENGTH\n         L     R13,4(,R13)         RESTORE PREVIOUS SAVEAREA\n         ST    R15,16(,R13)        STORE RETURN CODE FOR LM\n         FREEMAIN R,A=(1),LV=(0)\n         LM    14,12,12(R13)       LOAD RETURN ADDRESS AND RC\n         BR    14                  RETURN\n         SPACE\n************************************************************\n*        CONSTANTS                                         *\n************************************************************\n         SPACE\n         LTORG\n         SPACE\nMODLPTPM PUTLINE OUTPUT=(1,TERM,SINGLE,INFOR),                         X\n               TERMPUT=(EDIT,WAIT,NOHOLD,NOBREAK),MF=L\n         SPACE\nMODLPTPB PUTLINE OUTPUT=(1,TERM,SINGLE,DATA),                          X\n               TERMPUT=(EDIT,WAIT,NOHOLD,NOBREAK),MF=L\n         SPACE\n         DS    0F\nBLANKS   DC    C'                '\nMSG01    DC    C'TPVT ADDRESS:'\nMSG02    DC    C'UPT FROM PSCB   '\nMSG02A   DC    C'UPT FROM CPPL   '\nMSG03    DC    C'ECT ADDRESS '\nMSG04    DC    C'8-CHARACTER USERID SUPPORT IS: OFF'\nMSG05    DC    C'8-CHARACTER USERID SUPPORT IS: ON '\nTITLELIT DC    C'SHOW TPVT - TSO PARMLIB VECTOR TABLE - FIELDS'\nTITLEUND DC    C'---- ----   --- ------- ------ -----   ------'\nTITLEEX0 DC    C'  Display of Common Storage Deriving from   '\nTITLEEX1 DC    C'        the IKJTSOxx PARMLIB member         '\nTITLEHDR DC    C'  addr  field        value            explanation'\nTITLEHUN DC    C'  ----  -----        -----            -----------'\nTEXT_ID  DC    C'    +0  TPVT_ID     '        4 BYTES\nTEXT_LEN DC    C'    +4  TPVT_LEN    '        2 BYTES\nTEXT_VER DC    C'    +6  TPVT_VERS   '        1 BYTE\nTEXT_FL1 DC    C'    +7  TPVT_FILLER1'        1 BYTE\nTEXT_MEM DC    C'    +8  TPVT_MEM    '        8 BYTES\nTEXT_GEN DC    C'   +10  TPVT_GEN    '        4 BYTES\nTEXT_CTL DC    C'   +14  TPVTCTLT    '        4 BYTES\nTEXTCTLN DC    C'   +18  TPVTCTLTLEN '        4 BYTES\nTEXTRSV1 DC    C'   +1C  RESERVED 1  '        4 BYTES\nTEXTSEND DC    C'   +20  TPVTSEND    '        4 BYTES\nTEXTALPL DC    C'   +24  TPVTALPL    '        4 BYTES\nTEXTTEST DC    C'   +28  TPVTTEST    '        4 BYTES\nTEXTXPRM DC    C'   +2C  TPVTXPRMD   '        4 BYTES\nTEXTCNSL DC    C'   +30  TPVTCONSOLE '        4 BYTES\nTEXTFCVE DC    C'   +34  TPVTFCVEC   '        8 BYTES\nTEXTHELP DC    C'   +3C  TPVTHELP    '        4 BYTES\nTEXTPPVE DC    C'   +40  TPVTPPVEC   '        8 BYTES\nTEXTRSV2 DC    C'   +44  RESERVED 2  '        8 BYTES\nTEXTLOGO DC    C'   +4C  TPVTLOGON   '        1 BYTE\nTEXTUMXL DC    C'   +4D  TPVTUMXL    '        1 BYTE\nTEXTRSV3 DC    C'   +4E  RESERVED 3  '        2 BYTES\nTEXTDSNM DC    C'   +50  TPVTDSNAM   '       44 BYTES\nTEXTVOLS DC    C'   +7C  TPVTVOLSER  '        6 BYTES\nTEXTRSV4 DC    C'   +82  RESERVED 4  '        2 BYTES\nTEXTSNAM DC    C'   +84  TPVTSYSNAM  '        8 BYTES\nTEXTUSID DC    C'   +8C  TPVTUSERID  '        8 BYTES\nTEXTTIME DC    C'   +94  TPVTHHMMSS  '        8 BYTES\nTEXTDATE DC    C'   +9C  TPVTYYMMDD  '       10 BYTES\nTEXTCPIP DC    C'   +A6  TPVTCPUIDP  '        2 BYTES\nTEXTCPUI DC    C'   +A8  TPVTCPUID   '        4 BYTES\nTEXTMODN DC    C'   +AC  TPVTMODEL   '        2 BYTES\nTEXTUPDT DC    C'   +AE  TPVTUPDTIM  '        4 BYTES\nTEXTUPDD DC    C'   +B2  TPVTUPDDAT  '        4 BYTES\nTEXTFEAT DC    C'   +B6  TPVTFEATURE '        1 BYTE\nTEXTFEAV DC    C'   +B7  TPVTFEATVER '        1 BYTE\nTEXTRSV5 DC    C'   +B8  RESERVED 5  '       18 BYTES\nTEXTRS5A DC    C'   +CA  RESERVED 5A '       18 BYTES\nTEXTLG1A DC    C'Password Phrase Support     08'\nTEXTLG1B DC    C'Applid Verification         04'\nTEXTLG1C DC    C'LOGONHERE Support           02'\nTEXTLG1D DC    C'Password Preprompt Support  01'\n         SPACE\n************************************************************\n*        PARSE PCL                                         *\n************************************************************\n         SPACE\n         PRINT GEN\nMYPCL    IKJPARM\nREALKW   IKJKEYWD\n         IKJNAME 'CPPL'\n         IKJNAME 'REAL'\nUPTKW    IKJKEYWD\n         IKJNAME 'UPT'\nECTKW    IKJKEYWD\n         IKJNAME 'ECT'\nALLKW    IKJKEYWD\n         IKJNAME 'ALL'\n         IKJENDP\n         PRINT GEN\n         SPACE\n************************************************************\n*        DSECTS                                            *\n************************************************************\n         SPACE\n@DATA    DSECT\n         DS    18F                 REGISTER SAVEAREA\nDOUBLE   DS    D                   DOUBLEWORD WORK AREA\nLINKAREA DS    2F\nADDRESS  DS    F\nTSVTADDR DS    F                   TSVTADDR\nTPVTADDR DS    F                   TPVTADDR\nUPTADDR  DS    F                   UPT FROM PSCB\nUPTADDRC DS    F                   UPT FROM CPPL\nECTADDR  DS    F\nSAVER6A  DS    F\nSAVEPSCB DS    F                   WE DON'T USE IT, BUT WE HAVE IT\nMYPPL    DS    7F\nMYANS    DS    F\nMYECB    DS    F                   USED BY PUTLINE ROUTINE\nMYIOPL   DS    4F                  USED BY PUTLINE ROUTINE\nMYPTPB   DS    3F                  USED BY PUTLINE ROUTINE\nMYPUTLEP DS    F                   USED BY PUTLINE ROUTINE\nMYOLD    DS    2F                  USED BY PUTLINE ROUTINE\nMYSEG1   DS    2H,CL100            USED BY PUTLINE ROUTINE\nPUTSAVE  DS    4F                  USED BY PUTLINE ROUTINE\nFLAG1    DS    X\n*                                  X'00' IF NO 8-CHAR UID SUPPORT\n*                                  X'01' IF 8-CHAR SUPPORT BUT NOT ON\n*                                  X'02' IF 8-CHAR SUPPORT IS ON\nLINEB    DS    C                   LINE-1\nLINE     DS    CL120\nLINETXT  EQU   LINE,20\nLINEX    EQU   LINE+21\nLINEC    EQU   LINE+38\nLINET    EQU   LINE+8\nLINEU    EQU   LINE+13\nENTRY    DS    F                1  LOADED ENTRY POINT OF TODCNVRT\nPARAM    DS    5F               2  PARAMETER LIST FOR TODCNVRT PROGRAM\nCLOCK    DS    D                3  TARGET AREA OF STCK INSTRUCTION\nTIMEZONE DS    F                4  FILLED IN FROM CVTTZ\nANSWER   DS    CL64             5  ANSWER PLACE FOR TODCNVRT PROGRAM\n         DS    C\nTIMEFMT  DS    CL64                FORMAT FOR DATE AND TIME DISPLAY\nOPTION   DS    C\nWORKA    DS    10D\nPARMSAVE DS    F\n@DATAL   EQU   *-@DATA\n         SPACE 1                                                 JDM1\n         CVT   DSECT=YES,LIST=NO                                 JDM1\n         SPACE 1                                                 JDM1\n         PRINT ON,GEN\n         IKJTCB DSECT=YES,LIST=NO                                JDM1\n         SPACE 1                                                 JDM1\n         IKJPSCB\n         SPACE\n         IKJTPVT\n         SPACE\n         IEZJSCB                                                 JDM1\n         SPACE\n         IKJCPPL\n         SPACE\n         IKJIOPL\n         SPACE\n         IKJPPL\n         SPACE\n         IKJUPT\n         SPACE\n         IKJECT\n         SPACE\n         PRINT OFF\n         YREGS\n         END\n         TITLE '   T O D C N V R T  '\n*---------------------------------------------------------------------*\n*                                                                     *\n*        'TODCNVRT'                                                   *\n*                                                                     *\n*        WRITTEN BY. BILL GODFREY,  PLANNING RESEARCH CORPORATION.    *\n*        INSTALLATION. PRC COMPUTER CENTER INC, MCLEAN VA.            *\n*        DATE WRITTEN. DECEMBER 7 1976.                               *\n*        DATE UPDATED. JANUARY 31 1977.                               *\n*        ATTRIBUTES. RE-ENTRANT.                                      *\n*                                                                     *\n*        DESCRIPTION.                                                 *\n*         THIS SUBPROGRAM CONVERTS THE RESULTS OF A                   *\n*         'STORE CLOCK' INSTRUCTION TO EBCDIC. THE LOGIC              *\n*         IS TAKEN STRAIGHT OUT OF MODULE 'AMDPRSEG' IN               *\n*         AMDPRDMP (5752-SC113), VS2 RELEASE 3.0                      *\n*         WITH A FEW MODIFICATIONS TO MAKE THE PASSING                *\n*         OF PARAMETERS MORE CONVENTIONAL.                            *\n*                                                                     *\n*            INPUT - LIST OF 5 ADDRESSES POINTED TO BY REG 1          *\n*                       1) PTR TO CVTTZ VALUE                         *\n*                       2) PTR TO 8-BYTE TOD CLOCK VALUE              *\n*                       3) PTR TO OUTPUT AREA                         *\n*                       4) PTR TO OPTION BYTE X'01' OR X'02'          *\n*                       5) PTR TO 80-BYTE WORKAREA                    *\n*                    REG 15 = ENTRY ADDRESS  REG 14 = RETURN ADDRES   *\n*                    REG 13 = 72 BYTE REGISTER SAVEAREA ADDRESS       *\n*                                                                     *\n*            OUTPUT - EBCDIC TIME IN OUTPUT AREA                      *\n*                     REG 15 = 4 IF INPUT CLOCK TIME ALL ZEROES       *\n*                     REG 15 = 0 ALL OTHER CASES.                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE\nTODCNVRT CSECT\n         SAVE  (14,12),,&SYSDATE\n         LR    R12,15\n         USING TODCNVRT,R12\n         L     R1,16(,R1)              SAVEPTR\n         ST    R13,4(,R1)\n         ST    R1,8(,R13)\n         LR    R14,R13\n         LR    R13,R1\n         L     R1,24(,R14)             RESTORE R1\n         USING MYDSECT,R13\n         USING PARAMS,R1\n         SPACE 1\n         L     R7,TODPTR\n         MVC   CVRTAREA(8),0(R7)\n         SPACE\n*---------------------------------------------------------------------*\n*        CHANGE TOD TO LOCAL TIME\n*---------------------------------------------------------------------*\n         SPACE\n         L     R7,CVTTZPTR         GET ADDR OF TZ FIELD\n         L     R7,0(,R7)           R7 = TZ VALUE\n         L     R15,MINUS1\n         CLR   R7,R15              IS TZ = MINUS 1?\n         BNE   TZADD               NO - USE TZ FROM CALLER\n         L     R7,16               YES - USE TZ FROM CVT\n         L     R7,X'598'(,R7)      GET CVTTZ\nTZADD    DS    0H\n         AL    R7,CVRTAREA         ADD TZ TO FIRST WORD\n         ST    R7,CVRTAREA\n         SPACE\n         LM    R4,R5,CVRTAREA\n         SRDL  R4,12               REMOVE INSIGNIFICANT BITS\n         D     R4,SIXTYMIL         DIVIDE BY 60,000,000\n         SPACE\n         L     R7,OPTION\n         CLI   0(R7),2\n         BE    RELTVTME\n         B     FULLDATE\n         SPACE\n*---------------------------------------------------------------------*\n*        RELATIVE TIME CONVERSION -- THIS ROUTINE CONVERTS THE TOD\n*        VALUE TO RELATIVE SECONDS.MICROSECONDS FROM 0 A.M. OF THE\n*        CURRENT DAY REFLECTED BY THE TOD VALUE. THE CONVERTED TIME\n*        IS PLACED LEFT JUSTIFIED IN THE OUTPUT AREA IN THE FORM\n*        SSSSS.MMMMMM (EBCDIC).   UPON ENTRY TO THIS ROUTINE THE TOD\n*        VALUE HAS ALREADY BEEN CHANGED TO TOTAL MINUTES (IN R5) AND\n*        NUMBER OF MICROSECONDS INTO CURRENT MINUTE (IN R4).\n*---------------------------------------------------------------------*\n         SPACE\nRELTVTME DS    0H\n         L     R7,TODPTR\n         CLC   0(8,R7),=XL8'00'\n         BNE   RNOTZERO\n         L     R7,OUTAREA\n         MVI   12(R7),C' '\n         MVC   13(11,R7),12(R7)\n         MVC   0(12,R7),=C'00000.000000'\n         LA    R15,4\n         B     EXIT\n         SPACE\nRNOTZERO DS    0H\n         SPACE\n*---------------------------------------------------------------------*\n*        CALCULATE NO. OF SECONDS INTO CURRENT MINUTE\n*---------------------------------------------------------------------*\n         SPACE\n         LR    R15,R4\n         SLR   R14,R14\n         D     R14,MILLION\n         ST    R15,TIMELEFT\n         SPACE\n*---------------------------------------------------------------------*\n*        CALCULATE NO. OF MICROSEC INTO CURRENT SECOND\n*---------------------------------------------------------------------*\n         SPACE\n         LR    R4,R14              REMAINDER IN R4\n         SPACE\n         L     R2,OUTAREA\n         LA    R2,6(,R2)           OUT LOC FOR MICROSEC\n         SPACE\n*---------------------------------------------------------------------*\n*        CONVERT MICROSEC TO EBCDIC\n*---------------------------------------------------------------------*\n         SPACE\n         CVD   R4,CVRTAREA\n         UNPK  0(6,R2),CVRTAREA+4(4)\n         OI    5(R2),X'F0'\n         SPACE\n         L     R7,OUTAREA\n         MVI   5(R7),C'.'\n         SPACE\n*---------------------------------------------------------------------*\n*        CALCULATE NO. OF SECONDS INTO CURRENT DAY\n*        AND CONVERT TO EBCDIC\n*---------------------------------------------------------------------*\n         SPACE\n         LR    R14,R5              R4=((R5//1440)*60)+SECONDS\n         SRDA  R14,32\n         D     R14,=F'1440'\n         MH    R14,=H'60'\n         LA    R15,TIMELEFT\n         LA    R14,0(,R15)         ADD SECONDS\n         LR    R4,R14\n         SPACE\n         LR    R2,R7               POINT TO OUTPUT AREA\n         CVD   R4,CVRTAREA\n         UNPK  0(5,R2),CVRTAREA+5(3)  UNPACK SECONDS\n         OI    4(R2),X'F0'\n         SPACE\n         B     EXIT0\n         SPACE\n*---------------------------------------------------------------------*\n*        FULL DATE AND TIME CONVERSION -- THIS ROUTINE\n*        CONVERTS THE TOD VALUE TO YEAR, JULIAN DAY, HOURS\n*        MINUTES, SECONDS, AND MICROSECONDS. THE CONVERTED\n*        TIME IS PLACED LEFT-JUSTIFIED IN THE OUTPUT AREA\n*        IN THE FORM YYYYDDDHH.MM.SS.MMMMMM (EBCDIC). UPON\n*        ENTRY TO THIS ROUTINE, THE TOD VALUE HAS ALREADY\n*        BEEN CHANGED TO TOTAL MINUTES SINCE EPOCH (IN R5)\n*        AND NUMBER OF MICROSECS INTO CURRENT MINUTE (R4).\n*---------------------------------------------------------------------*\n         SPACE\nFULLDATE DS    0H\n         L     R7,TODPTR\n         CLC   0(8,R7),=XL8'00'\n         BNE   FNOTZERO\n         L     R7,OUTAREA\n         MVI   22(R7),C' '\n         MVI   23(R7),C' '\n         MVC   0(22,R7),=C'000000000.00.00.000000'\n         LA    R15,4\n         B     EXIT\n         SPACE\nFNOTZERO DS    0H\n         SPACE\n*---------------------------------------------------------------------*\n*        CALCULATE NUMBER OF SECONDS (R4/1,000,000)\n*---------------------------------------------------------------------*\n         SPACE\n         LA    R7,TIMELEFT\n         LR    R15,R4\n         SLR   R14,R14\n         D     R14,MILLION\n         ST    R15,0(,R7)\n         SPACE\n*---------------------------------------------------------------------*\n*        CALCULATE NO. OF MICROSECONDS (R4//1,000,000)\n*---------------------------------------------------------------------*\n         SPACE\n         LR    R4,R14\n         SPACE\n*---------------------------------------------------------------------*\n*        CONVERT MICROSEC TO EBCDIC\n*---------------------------------------------------------------------*\n         SPACE\n         L     R7,OUTAREA\n         LA    R2,16(,R7)\n         SPACE\n         CVD   R4,CVRTAREA\n         UNPK  0(6,R2),CVRTAREA+4(4)\n         OI    5(R2),X'F0'\n         SPACE\n         MVI   15(R7),C'.'\n         SPACE\n*---------------------------------------------------------------------*\n*        CONVERT SECONDS TO EBCDIC\n*---------------------------------------------------------------------*\n         SPACE\n         L     R4,TIMELEFT\n         LA    R2,13(,R7)\n         SPACE\n         CVD   R4,CVRTAREA\n         UNPK  0(2,R2),CVRTAREA+6(2)\n         OI    1(R2),X'F0'\n         SPACE\n         MVI   12(R7),C'.'\n         SPACE\n*---------------------------------------------------------------------*\n*        CALCULATE NO. OF MINUTES INTO CURRENT HOUR.\n*        R5 CONTAINS TOTAL NO. OF MINUTES FROM THE EPOCH.\n*---------------------------------------------------------------------*\n         SPACE\n         LR    R15,R5\n         SLR   R14,R14\n         D     R14,=F'60'\n         ST    R15,TIMELEFT\n         SPACE\n*---------------------------------------------------------------------*\n*        CALCULATE MINUTES INTO CURRENT HOUR\n*        R4 = R5//60\n*---------------------------------------------------------------------*\n         SPACE\n         LR    R4,R14\n         SPACE\n         LA    R2,10(,R7)\n         CVD   R4,CVRTAREA\n         UNPK  0(2,R2),CVRTAREA+6(2)\n         OI    1(R2),X'F0'\n         SPACE\n         MVI   9(R7),C'.'\n         SPACE\n*---------------------------------------------------------------------*\n*        CALCULATE NO. OF HOURS INTO CURRENT DAY.\n*        TIMELEFT CONTAINS TOTAL NO. OF HOURS SINCE EPOCH.\n*---------------------------------------------------------------------*\n         SPACE\n         L     R5,TIMELEFT\n         LR    R15,R5\n         SLR   R14,R14\n         D     R14,=F'24'\n         ST    R15,TIMELEFT        TOTAL DAYS SINCE EPOCH\n         SPACE\n*---------------------------------------------------------------------*\n*        CALCULATE NO. OF HOURS INTO CURRENT DAY.\n*---------------------------------------------------------------------*\n         SPACE\n         LR    R4,R14\n         SPACE\n         LA    R2,7(,R7)\n         CVD   R4,CVRTAREA\n         UNPK  0(2,R2),CVRTAREA+6(2)\n         OI    1(R2),X'F0'\n         SPACE\n*---------------------------------------------------------------------*\n*        CALCULATE THE CURRENT YEAR AND JULIAN DAY\n*        USING 'TIMELEFT' WHICH CONTAINS THE TOTAL NUMBER\n*        OF ELAPSED DAYS SINCE 1900. FIRST CHECK WHETHER\n*        THE TIME IS IN THE 1900 THRU 1903 ERA (I.E. LESS\n*        THAN 1460 ELAPSED DAYS). IF SO, THE TIME MUST BE\n*        HANDLED IN A SPECIAL WAY SINCE 1900 IS NOT A LEAP\n*        YEAR AND EACH YEAR IN THAT 4 YEAR SPAN THUS CON-\n*        TAINS 365 DAYS. IF THE ELAPSED TIME HOWEVER IS\n*        GREATER THAN 1459 DAYS, THEN EVERY 4 YEARS CON-\n*        TAIN 1461 DAYS RATHER THAN 1460 AND THE FIRST\n*        YEAR OF EACH GROUP IS A LEAP YEAR. THESE FOUR\n*        YEAR GROUPS ARE REFERRED TO AS LEAP YEAR GROUPS.\n*        THE YEAR AND THE DAY WHEN THE ELAPSED TIME FALLS\n*        INTO ONE OF THESE GROUPS MUST BE CALCULATED USING\n*        STANDARD FORMULAS DIFFERENT FROM THE FORMULAS\n*        USED WHEN THE TIME IS WITHIN 1900 TO 1903.\n*---------------------------------------------------------------------*\n         SPACE\n         L     R7,TIMELEFT\n         CH    R7,=H'1460'\n         BNL   POST1903\n         SPACE\nNOLEAPYR DS    0H\n         SPACE\n*---------------------------------------------------------------------*\n*        R3 = (TIMELEFT//365)+1   CURRENT DAY\n*---------------------------------------------------------------------*\n         SPACE\n         LR    R14,R7\n         SRDA  R14,32\n         D     R14,=F'365'\n         AH    R14,=H'1'\n         LR    R3,R14\n         SPACE\n*---------------------------------------------------------------------*\n*        R6 = (TIMELEFT/365)     CURRENT YEAR\n*---------------------------------------------------------------------*\n         SPACE\n         AH    R15,=H'1900'\n         LR    R6,R15\n         B     DATECOM\n         SPACE\n*---------------------------------------------------------------------*\n*        THE TIME ELAPSED IS 1460 OR MORE DAYS.\n*        CALCULATE R5, THE RELATIVE LEAP YEAR GROUP SINCE\n*        1904, AND R4, THE NUMBER OF DAYS ELAPSED IN THE\n*        CURRENT LEAP YEAR GROUP. USE THESE VALUES IN THE\n*        FORMULAS.  IN THE FORMULA USED TO CALCULATE THE\n*        JULIAN DAY, THE EXPRESSION IN PARENTHESES IS THE\n*        NUMBER OF WHOLE DAYS THAT HAVE PAST IN THE\n*        CURRENT YEAR. BECAUSE THE CURRENT DAY HAS NOT YET\n*        ELAPSED, IT IS NOT INCLUDED IN THE RESULT PRO-\n*        DUCED BY THE EXPRESSION AND THEREFORE 1 MUST BE\n*        ADDED TO GET THE ACTUAL JULIAN DAY.\n*        WITHIN THE EXPRESSION THE FIRST TERM, R, MUST BE\n*        ADJUSTED BY 1 (I.E, L/731) IF THE TOTAL DAYS INTO\n*        THE LEAP YEAR GROUP IS GREATER THAN OR EQUAL TO\n*        2 YEARS, AND AGAIN BY 1 (I.E, L/1096) IF THE\n*        TOTAL DAYS IS EQUAL TO OR GREATER THAN 3 YEARS.\n*        THE AFFECT OF THIS IS THAT THE 2ND AND 3RD YEARS\n*        ARE FORCED TO 366 DAYS ONCE THE TOTAL DAYS INTO\n*        THE GROUP EXCEEDS EACH OF THESE YEARS. THIS IS\n*        NECESSARY BECAUSE A DIVISOR OF 366 IS USED.\n*        THE SECOND TERM (W * 4) YIELDS THE RELATIVE\n*        NUMBER OF YEARS SINCE 1904 UP TO AND INCLUDING\n*        THE LEAP YEAR IN THE CURRENT GROUP. THE THIRD\n*        TERM ( (L-1)/365 ) YIELDS THE RELATIVE YEAR\n*        WITHIN THE CURRENT LEAP YEAR GROUP. THUS IF THE\n*        CURRENT YEAR IS A LEAP YEAR THE RELATIVE YEAR IS\n*        ZERO AND THE THIRD TERM WILL RESULT IN ZERO.\n*---------------------------------------------------------------------*\n         SPACE\nPOST1903 DS    0H\nLEAPYR   DS    0H\n         SPACE\n*---------------------------------------------------------------------*\n*        TIMELEFT=TIMELEFT-1460  1904 BASE\n*---------------------------------------------------------------------*\n         SPACE\n         L     R7,TIMELEFT\n         SH    R7,=H'1460'\n         STH   R7,TIMELEFT\n         SPACE\n*---------------------------------------------------------------------*\n*        R5 = TIMELEFT/1461\n*---------------------------------------------------------------------*\n         SPACE\n         LR    R14,R7\n         SRDA  R14,32\n         D     R14,=F'1461'\n         LR    R5,R15\n         SPACE\n*---------------------------------------------------------------------*\n*        R4 = TIMELEFT//1461\n*---------------------------------------------------------------------*\n         SPACE\n         LR    R4,R14\n         SPACE\n*---------------------------------------------------------------------*\n*        R3 = ((L+L/731+L/1096)//336)+1  JULIAN DAY\n*---------------------------------------------------------------------*\n         SPACE\n         LR    R15,R4\n         SLR   R14,R14\n         D     R14,=F'731'\n         LR    R14,R15\n         ALR   R14,R4\n         LR    R3,R14\n         LR    R15,R4\n         SLR   R14,R14\n         D     R14,=F'1096'\n         LR    R14,R15\n         ALR   R14,R3\n         SRDA  R14,32\n         D     R14,=F'366'\n         AH    R14,=H'1'\n         LR    R3,R14\n         SPACE\n*---------------------------------------------------------------------*\n*        R6 = 1904+(W*4)+(L-1)/365       YEAR\n*---------------------------------------------------------------------*\n         SPACE\n         LR    R6,R5\n         SLA   R6,2\n         AH    R6,=H'1904'\n         LR    R14,R4\n         BCTR  R14,0\n         SRDA  R14,32\n         D     R14,=F'365'\n         ALR   R6,R15\n         SPACE\nDATECOM  DS    0H\n         L     R7,OUTAREA\n         LA    R2,4(,R7)\n         CVD   R3,CVRTAREA\n         UNPK  0(3,R2),CVRTAREA+6(2)\n         OI    2(R2),X'F0'\n         SPACE\n         LA    R2,0(,R7)\n         CVD   R6,CVRTAREA\n         UNPK  0(4,R2),CVRTAREA+5(3)\n         OI    3(R2),X'F0'\n         SPACE\nEXIT0    SR    15,15\nEXIT     LR    1,13\n         L     13,4(,13)\n         ST    15,16(,13)\n         LM    14,12,12(13)\n         BR    14\n         SPACE\n*---------------------------------------------------------------------*\n*        CONSTANTS\n*---------------------------------------------------------------------*\n         SPACE\nMILLION  DC    F'1000000'\nSIXTYMIL DC    F'60000000'\nMINUS1   DC    F'-1'\n         LTORG\n         SPACE\n*---------------------------------------------------------------------*\n*        DSECTS\n*---------------------------------------------------------------------*\n         SPACE\nMYDSECT  DSECT\nTIMELEFT DS    0F                  1ST FULLWORD OF SAVEAREA\n         DS    18F                 REGISTER SAVEAREA\nCVRTAREA DS    D\nMYDSECTL EQU   *-MYDSECT\n         SPACE\nPARAMS   DSECT\nCVTTZPTR DS    A                   ADDR OF CVTTZ VALUE\nTODPTR   DS    A                   ADDR OF TOD CLOCK VALUE\nOUTAREA  DS    A                   ADDR OF OUTPUT AREA\nOPTION   DS    A                   ADDR OF OPTION BYTE\nSAVEPTR  DS    A                   ADDR OF SAVEAREA\n         SPACE\n         YREGS\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TSUB": {"ttr": 9994, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01'\\x00\\x18\\x01\\x06\\x01\\x8f\\x01\\x164/\\x14D\\r\\xb1\\x04)\\x00\\x00```````@@@\"", "ispf": {"version": "01.39", "flags": 0, "createdate": "2006-01-18T00:00:00", "modifydate": "2016-12-07T14:44:18", "lines": 3505, "newlines": 1065, "modlines": 0, "user": "-------"}, "text": "TSUB     TITLE 'TSUB - MAINTAIN LWA-POINTED-TO INCORE TSO AUTH TABLES'\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*   Program Name:   TSUB                                              *\n*                                                                     *\n*  Documentation:   This program is meant to be run as a TSO          *\n*                   command, APF authorized except for the display    *\n*                   functions.                                        *\n*                                                                     *\n*    Environment:   TSO command, APF Authorized.                      *\n*                   PUTLINE interface enabled by APUT, EPUTL.         *\n*                   This program is non-reentrant.                    *\n*                                                                     *\n* Short Function:   This program deals with existing TSO \"auth\"       *\n*                   tables that are pointed to by fields in the       *\n*                   LWA (Logon Work Area) which is created for a      *\n*                   TSO session at LOGON time.  These tables are      *\n*                   the actual tables that your TSO session uses      *\n*                   to determine program authorization.  Many of      *\n*                   the characteristics of these tables can be        *\n*                   changed or reset by the TSUB program.  The        *\n*                   changes that TSUB can do, are of two types:       *\n*                                                                     *\n*                   1.  Replacing or blanking any table entry.        *\n*                   2.  Altering the LWA flags or fields that         *\n*                       determine this table's properties.            *\n*                   3.  Effectively nullifying an entry by            *\n*                       putting a C'?' into it.  This effectively     *\n*                       removes the entry, without nullifying any     *\n*                       of the following table entries.               *\n*                                                                     *\n*                Details:                                             *\n*                                                                     *\n*                   1.  TSUB can substitute a different program name  *\n*                       or insert a blank entry into any valid slot   *\n*                       of a TSO \"auth\" table that belongs to your    *\n*                       TSO session.                                  *\n*                                                                     *\n*                       Blanking (not the last entry) is dangerous    *\n*                       (see below) because it invalidates all the    *\n*                       subsequent non-blank table entries.  But the  *\n*                       technique of blanking an entry can be used    *\n*                       carefully if you are sure of what you want    *\n*                       to accomplish.                                *\n*                                                                     *\n*                       But you can effectively nullify a table       *\n*                       entry without blanking it, using the          *\n*                       \"nullify\" function \"N\" instead of the         *\n*                       \"blanking\" function \"B\".  The nullifying      *\n*                       function inserts a C'?' into the slot,        *\n*                       allowing all following slots to still         *\n*                       work, since a ? entry is not a blank that     *\n*                       delimits the table.                           *\n*                                                                     *\n*                   2.  TSUB can change the characteristics of your   *\n*                       own session's TSO \"auth\" tables, that are     *\n*                       pointed to by the LWA, by means of changing   *\n*                       the LWA (Logon Work Area) settings for each   *\n*                       table.  For example, LWA table lengths can    *\n*                       be supplied or removed.  LWA flags marking    *\n*                       the table as coming from a STEPLIB can be     *\n*                       set, or removed.  Even the physical table     *\n*                       header can be altered to make the table       *\n*                       look as though it came from PARMLIB.          *\n*                                                                     *\n*   Introduction:   At LOGON time for a TSO session, the system       *\n*                   copies a set of the E2, E8, AP, and NS TSO        *\n*                   authorization tables into SP 252 protected Key 0  *\n*                   storage which lies in the TSO user's address      *\n*                   space.  These are the tables WHICH ARE ACTUALLY   *\n*                   USED by that TSO session, and their location is   *\n*                   pointed to in the LWA control block (Logon Work   *\n*                   Area).  The duration of these tables is for the   *\n*                   life of that TSO session.  TSO LOGON processing   *\n*                   creates both the LWA itself, and the copies of    *\n*                   the auth tables that are used. TSUB displays and  *\n*                   manipulates this copy of these tables--the ones   *\n*                   that are actually in use. Thus, changes to these  *\n*                   tables are effective immediately, and their       *\n*                   scope affects only the issuing TSO session.       *\n*                                                                     *\n*                   Where does TSO get these tables from, at LOGON    *\n*                   time?                                             *\n*                                                                     *\n*              Case 1.  The most commonly found source for the auth   *\n*                       tables pointed to in the LWA, is the \"common  *\n*                       storage\" tables created from the active       *\n*                       PARMLIB member IKJTSOxx.  Those are pointed   *\n*                       to by the TPVT control block + X'14' which    *\n*                       is the CTLT.  If the CTLT is the source of    *\n*                       the LWA tables, then lengths of the tables,   *\n*                       and the size of each entry, are copied from   *\n*                       the CTLT into the LWA (Logon Work Area).      *\n*                       Use the program called ASUB to directly       *\n*                       access the public tables from PARMLIB that    *\n*                       are pointed to by the CTLT (undocumented)     *\n*                       control block.  Our program, TSUB, accesses   *\n*                       the copy of those tables which is pointed to  *\n*                       by the LWA, which were created for the TSO    *\n*                       session at LOGON time, and which are unique   *\n*                       to the current TSO session.                   *\n*                                                                     *\n*              Case 2.  If a list of table entries for one or more    *\n*                       of the tables:  E2, E8, AP, or NS is not      *\n*                       found in the IKJTSOxx PARMLIB member that     *\n*                       is currently active, then the table in the    *\n*                       LWA is not copied from the IKJTABLS module    *\n*                       in LPALIB, but it is just pointed to.  Thus   *\n*                       in such a situation, TSUB cannot alter the    *\n*                       particular table.  The actual table is        *\n*                       located in PLPA, in that particular case.     *\n*                                                                     *\n*              Case 3.  If a copy of the IKJTABLS load module         *\n*                       containing csects IKJEFTE2, IKJEFTE8,         *\n*                       IKJEFTAP, and IKJEFTNS is found in an         *\n*                       APF-authorized STEPLIB that the TSO session   *\n*                       has access to (running as an APF authorized   *\n*                       STEPLIB only), then those E2, E8, NS, and AP  *\n*                       tables are copied into the LWA at LOGON       *\n*                       time, from that CSECT in the STEPLIB copy of  *\n*                       IKJTABLS.  Therefore the table entries in     *\n*                       the respective CSECTs of the IKJTABLS in the  *\n*                       authorized STEPLIB are the ones which are in  *\n*                       force for that user's TSO session.  But in    *\n*                       that case, no \"table lengths\" or \"number of   *\n*                       table entries\" from these tables, are         *\n*                       available.  The table is delimited by the     *\n*                       first blank entry in it.  This TSUB program   *\n*                       has the ability to blank any numbered table   *\n*                       entry.  Since a blank entry is a delimiter    *\n*                       for the entire table, and all entries after   *\n*                       the blank entry are no longer used, you       *\n*                       have to be very careful.  Therefore, when     *\n*                       blanking entries, you should usually blank    *\n*                       the last one only, unless you have a very     *\n*                       good reason to blank out a different entry,   *\n*                       other than the last one.  The good news is    *\n*                       that the effect of the TSUB program only      *\n*                       lasts for the duration of this LOGON, and     *\n*                       only for the userid that is currently running *\n*                       the TSUB program.                             *\n*                                                                     *\n*            Note - Tables copied from a CSECT in IKJTABLS do not     *\n*                   have lengths associated with them.  They are      *\n*                   delimited by a blank table entry at the end.      *\n*                   Therefore the copy of each such table pointed     *\n*                   to by the LWA, does not have any length           *\n*                   associated with it.  Therefore we can only        *\n*                   judge its length by looking at the first blank    *\n*                   entry that has been found by a forward scan.      *\n*                                                                     *\n*                   This program, TSUB, directly manipulates the      *\n*                   \"live\" authorization tables pointed to by the     *\n*                   LWA.  Supported tables are:  E2, E2, NS and       *\n*                   AP.  The public PP (Platform Program) table       *\n*                   and PC (Platform Command) table, not in the       *\n*                   LWA, are also supported by this program, if       *\n*                   they had been created by their presence in the    *\n*                   active IKJTSOxx PARMLIB member.                   *\n*                                                                     *\n*    Description:   Display an Auth Table entry from any of the       *\n*                   TSO/E program list tables:  IKJEFTE2, IKJEFTE8,   *\n*                   IKJEFTNS or IKJEFTAP that are in storage.  Or     *\n*                   display the entire table.  Or replace a numbered  *\n*                   entry with a new program name.  Or blank out      *\n*                   any numbered entry.  (Be very careful if you are  *\n*                   attempting to blank an entry.  Blanking an entry  *\n*                   invalidates ALL subsequent entries).  If you are  *\n*                   invoking a display function, then the entire      *\n*                   table is shown, unless you enter a number, and    *\n*                   then, only that slot is shown.  The tables        *\n*                   handled by this program are the actual tables     *\n*                   pointed to by the LWA of the issuing TSO/E        *\n*                   address space, and they lie in that user's        *\n*                   TSO/E address space (unless they were pointed to, *\n*                   and are from an IKJTABLS load module that is in   *\n*                   the LPA list.)                                    *\n*                                                                     *\n*       Function:   To substitute one new program name in the local   *\n*                   incore TSO auth tables, IKJEFTE2, IKJEFTE8, or    *\n*                   IKJEFTAP, IKJEFTNS lists.  This is done to any    *\n*                   numbered entry of each table.  Or else merely to  *\n*                   display the contents of the entire table, or the  *\n*                   contents of any particular numbered entry.        *\n*                                                                     *\n*                   The effect of replacing any program name is       *\n*                   immediate.  The scope of the change, is just for  *\n*                   the issuing current TSO userid.                   *\n*                                                                     *\n*                   You can blank out any numbered entry in any of    *\n*                   the four tables.  But blanking an entry, will     *\n*                   invalidate all subsequent table entries which     *\n*                   follow the blanked entry slot.  So be careful!    *\n*                                                                     *\n*                   Better than blanking an entry, you can \"nullify\"  *\n*                   an entry, which inserts a \"?\" character into the  *\n*                   table entry instead of blanks.  The subsequent    *\n*                   table entries remain valid.  The \"nullify\"        *\n*                   function is \"N\".  The \"blanking\" function is      *\n*                   \"B\".                                              *\n*                                                                     *\n*                   Or, you can use this program to list the complete *\n*                   contents of any of the auth tables which are      *\n*                   incore.                                           *\n*                                                                     *\n*                   Additionally, as described below, you can change  *\n*                   fields in the LWA which characterize the          *\n*                   individual tables--size characteristics and       *\n*                   whether or not the table came from STEPLIB.       *\n*                                                                     *\n*         Syntax:   TSUB ttA nnn pgmname                              *\n*                                                                     *\n*                   Where tt is a table code, and A is an action      *\n*                   code.                                             *\n*                                                                     *\n*                   The table code is a nickname for any of the       *\n*                   TSO/E auth tables which are incore.  They are:    *\n*                                                                     *\n*                   E2 - IKJEFTE2 = AUTHCMD  entry in IKJTSOxx        *\n*                   E8 - IKJEFTE8 = AUTHPGM  entry in IKJTSOxx        *\n*                   AP - IKJEFTAP = AUTHTSF  entry in IKJTSOxx        *\n*                   NS - IKJEFTNS = NOTBKGND entry in IKJTSOxx        *\n*                   PP -            PLATPGM  table in IKJTSOxx        *\n*                   PC -            PLATCMD  table in IKJTSOxx        *\n*                                                                     *\n*                   If the action code is B (blank the numbered       *\n*                   entry), then no program name is required,         *\n*                   but a number is required.  When blanking a        *\n*                   table entry, BE VERY CAREFUL !!!!!                *\n*                                                                     *\n*                   If the action code is N (nullify the numbered     *\n*                   entry), then no program name is required,         *\n*                   but a number is required.  Nullifying a table     *\n*                   entry will insert a \"?\" (question mark) into      *\n*                   that particular table slot, effectively           *\n*                   nullifying that entry, but NOT the entries        *\n*                   which follow, since blanks are the table          *\n*                   delimiters.                                       *\n*                                                                     *\n*     IMPORTANT  >  Under most circumstances, you should use the      *\n*       N O T E  >  \"nullify\" function \"N\" instead of the \"blanking\"  *\n*                >  function \"B\".  N will only nullify that one       *\n*                >  table entry, leaving all subsequent entries       *\n*                >  valid.  Blanking an entry will leave all          *\n*                >  subsequent table entries invalid.                 *\n*                                                                     *\n*       WARNING  >  If you blank out an entry which is not the        *\n*       WARNING  >  last entry in the particular table, then          *\n*       WARNING  >  all subsequent entries in that table are          *\n*       WARNING  >  rendered invalid!  It is best to restore          *\n*       WARNING  >  a non-blank entry to that slot, using the         *\n*       WARNING  >  ttR function, where tt is the table code.         *\n*                   Then you will be able to display the rest         *\n*                   of the table using the ttD function.              *\n*                                                                     *\n*                   If the action code is D (display the given        *\n*                   entry), then no program name is required.         *\n*                   The default action is to display the entire       *\n*                   table, unless a number is entered.  If a          *\n*                   number is present, then only that entry           *\n*                   number is displayed.  If the number is larger     *\n*                   than the number of entries in that particular     *\n*                   table, then an informative error message is       *\n*                   issued, and the program ends with code = 4.       *\n*                                                                     *\n*                   If the action code is R (replace the program      *\n*                   name) then a number (the table entry number)      *\n*                   and a program name are required.  If you want     *\n*                   to blank that slot, instead of putting a          *\n*                   program name into it, then use action code B.     *\n*                   But if you are blanking any slot which is not     *\n*                   the last slot, then PLEASE HEED THE WARNING       *\n*                   THAT IS ABOVE.                                    *\n*                                                                     *\n*                   If the action code is H, then TSUB will replace   *\n*                   the last 8 bytes of the table header with the     *\n*                   literal: C' PARMLIB', as if the table were        *\n*                   created from the IKJTSOxx member in PARMLIB.      *\n*                                                                     *\n*                   If the action code is L, then TSUB will look to   *\n*                   create a length value for that table.  This value *\n*                   is equal to the length of a table with all the    *\n*                   non-blank entries, plus all the potential blank   *\n*                   entries at the end of the table.  So this number  *\n*                   will often reflect more entries than TSO will     *\n*                   actually use.  Additionally, TSUB can change or   *\n*                   blank any one of these entries, because TSUB's    *\n*                   range depends on the number of entries indicated  *\n*                   by the LWA length.  (If there's no length, then   *\n*                   TSUB uses the length of all non-blank entries     *\n*                   plus the first blank, if it exists.)              *\n*                                                                     *\n*                   If the action code is M, then TSUB will look to   *\n*                   create a length value for that table.  This value *\n*                   is equal to the length of a table with all the    *\n*                   non-blank entries, plus one blank entry, if any   *\n*                   perceived blank entries exist at the end of the   *\n*                   table.                                            *\n*                                                                     *\n*                   If the action code is Z, then TSUB will look at   *\n*                   the LWA length value for that table, and it will  *\n*                   zero that length value, whether it already was    *\n*                   zero, or not.                                     *\n*                                                                     *\n*                   If the action code is S, then TSUB will make      *\n*                   the given table look like it came from STEPLIB,   *\n*                   so that a subsequent PARMLIB UPDATE(xx) command   *\n*                   will not overlay the session's auth table.        *\n*                                                                     *\n*                   If the action code is P, then TSUB will make      *\n*                   the given table look like it came from PARMLIB,   *\n*                   so that a subsequent PARMLIB UPDATE(xx) command   *\n*                   will overlay the session's auth table.            *\n*                                                                     *\n*                   If the action code is X, then TSUB will display   *\n*                   all the LPA address ranges (undocumented).        *\n*                                                                     *\n*                   If the PLATCMD or PLATPGM keywords (and at least  *\n*                   one name) were not coded in the active IKJTSOxx   *\n*                   PARMLIB entry, then there is no control block of  *\n*                   names to be pointed to.  The condition is         *\n*                   reported.  If these keywords WERE coded in the    *\n*                   IKJTSOxx member of PARMLIB which is currently     *\n*                   active, then the PC and PP table codes in TSUB    *\n*                   WILL ACT ON THE COMMON STORAGE COPY of THESE      *\n*                   TWO TABLES ONLY.                                  *\n*                                                                     *\n*  Recommendation:  First list the entire table using the \"D\"         *\n*                   action code, and then decide which entry, by      *\n*                   number, that you want to replace.                 *\n*                                                                     *\n*                   Then use the \"R\" action code, to replace the      *\n*                   particular numbered entry you have chosen.        *\n*                                                                     *\n*            Note:  The E2, E8, AP, or NS table which is being        *\n*                   used by the system, can come from either the      *\n*                   IKJTSOxx PARMLIB entry, or it can come from       *\n*                   an IKJTABLS load module which was running         *\n*                   from an APF authorized library as a STEPLIB,      *\n*                   or a default IKJTABLS entry in LPALIB.  Each      *\n*                   CSECT is copied into the TSO user's address       *\n*                   space, albeit in a protected key, and pointed     *\n*                   to by the user's LWA, except in the case of an    *\n*                   IKJTABLS CSECT that is in LPALIB.  These are      *\n*                   the actual auth tables, E2, E8, AP, NS, in        *\n*                   use by that TSO address space.                    *\n*                                                                     *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*  Change Log:                                                        *\n*    2008/09/10 - 1.0 - Initial version - Got it to work.             *\n*                       TSUB can blank any slot.  I'm allowing        *\n*                       that for now, because the scope of the        *\n*                       possible damage is only for that TSO          *\n*                       session as long as it is logged on.           *\n*                       The LWA auth tables are all reset by          *\n*                       logging on to that TSO session again.         *\n*                                                                     *\n*    2008/09/15 - 1.0 - Filled in and cleaned up some of the doc.     *\n*                                                                     *\n*    2009/01/28 - 1.0 - Added action codes: H, L, Z, S, P             *\n*                                                                     *\n*         All action codes except D need APF-authorization.           *\n*                                                                     *\n*         What they do:                                               *\n*                                                                     *\n*            H - Add PARMLIB-like table header, in 2nd 8-bytes.       *\n*            L - Supply length of table in LWA with ALL the blanks.   *\n*            M - Supply length of table to first blank, in LWA.       *\n*            Z - Zero the table length marked in the LWA.             *\n*            S - Mark that the table came from STEPLIB, so            *\n*                 someone (else's) PARMLIB UPDATE(xx) won't           *\n*                 overlay it.                                         *\n*            P - Turn off STEPLIB bit in LWA and mark that it         *\n*                 came from PARMLIB.  Now PARMLIB UPDATE(xx)          *\n*                 will overlay the table.                             *\n*            X - (undocumented) Gives LPA storage range display.      *\n*                                                                     *\n*         Other action codes are: (these are the original ones)       *\n*                                                                     *\n*            D - Display table entries by slot number.                *\n*            R - Replace the entry in a given slot, by another one.   *\n*            B - Blank a given table entry, by slot number.           *\n*            N - Nullify a given table entry, by slot number.         *\n*                 (It works by inserting a ? (question mark)          *\n*                  into that table slot.)                             *\n*                                                                     *\n*    2009/02/01 - 1.1 - Fourth and fifth base registers.              *\n*                                                                     *\n*         Improved message clarity.  Told messages to show states,    *\n*          \"before\" and \"after\" any changes were made.                *\n*                                                                     *\n*    2009/02/12 - 1.1 - Fix bug in calculating length of NS table.    *\n*         Fix convoluted logic in calculating table lengths.          *\n*                                                                     *\n*    2009/02/13 - 1.1 - Measure perceived blanks after logical end    *\n*         of the table.  For NS table, blank an entry with X'0000'    *\n*         for the \"length\" field, instead of X'FFFF', to see more     *\n*         perceived blanks, if there are any.                         *\n*                                                                     *\n*    2009/02/16 - 1.1 - Added option M to tailor length to reflect    *\n*         only up to the first blank.  Changed option L to make the   *\n*         LWA length equal to all non-blank entries plus all blank    *\n*         entries too.  Thus the table can be expanded, even if       *\n*         lengths are there.                                          *\n*                                                                     *\n*    2009/02/18 -1.1.31 Cosmetic changes. Put in Version numbers.     *\n*                                                                     *\n*    2009/02/20 -1.1.32 Improved displays for PC and PP tables.       *\n*                       Made sure S,P,H,L,M,Z options for PC and PP   *\n*                       actually do nothing, and say they do nothing. *\n*                       Made \"error display\" messages better.         *\n*                                                                     *\n*    2009/02/24 -1.1.33 Better messages if PLATPGM or PLATCMD tables  *\n*                       are missing.                                  *\n*                                                                     *\n*    2009/03/03 -1.1.34 More cosmetic changes in title & messages.    *\n*                                                                     *\n*    2011/03/24 -1.1.37 If an installation has an \"authorization SVC\" *\n*                       already installed, put in a provision to use  *\n*                       it with conditional assembly.  Of course,     *\n*                       you have to code your own appropriate         *\n*                       invocation code for the SVC, and its number,  *\n*                       in the AUTHON and AUTHOFF macros provided     *\n*                       in this code here.  Otherwise, SETC the &SVC  *\n*                       variable to 'NOSVC'                           *\n*                                                                     *\n*    2016/10/30 -1.1.38 A Blanking function on a table entry will     *\n*                       invalidate all subsequent table entries.      *\n*                       So I introduced a \"nullify\" function \"N\"      *\n*                       which will put a question mark, followed      *\n*                       by seven blanks, into a table entry,          *\n*                       effectively nullifying that entry, without    *\n*                       nullifying all the following entries too.     *\n*                                                                     *\n*    2016/12/07 -1.1.39 Describe the nullify function in HELP.        *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n***********************************************************************\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*       I N S T R E A M    M A C R O S                                *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n***********************************************************************\n*  If you are turning on authorization for this program using a\n*   \"trick SVC\", then do   &SVC  SETC  'SVC'\n*   and put your SVC invocation code in the AUTHON and AUTHOFF macros.\n*\n         LCLC  &SVC,&SVCX\n&SVC     SETC  'NOSVC'\n*&SVC     SETC  'SVC'\nSVNO     EQU   242\n&SVCX    SETC  '242'\n         AIF   ('&SVC' EQ 'NOSVC').SVTEST1\n         AIF   ('&SVC' EQ 'SVC').SVTEST1\n&SVC     SETC  'NOSVC'\n.SVTEST1 ANOP\n*\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n         YREGS\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n         AIF   ('&SVC' EQ 'NOSVC').NOSVC01\n*  Put your own SVC Auth turn on code here.....\n         MACRO\n&AON     AUTHON\n         ST    R1,SAVER1C\n         L     R1,=C'AUTH'\n         SVC   SVNO\n         L     R1,SAVER1C\n         MEND\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*  Put your own SVC Auth turn off code here.....\n         MACRO\n&AOFF    AUTHOFF\n         ST    R1,SAVER1C\n         L     R1,=C'NONE'\n         SVC   SVNO\n         L     R1,SAVER1C\n         MEND\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n.NOSVC01 ANOP\n*  ---------------------------------------------------------------  *\n*    This macro is used to display hex values in a printed report.\n*  ---------------------------------------------------------------  *\n         MACRO\n&NAME    HEX   &TO,&LEN,&FROM\n&NAME    DS    0H\n         STM   R15,R1,HEXSAVE\n         LA    R1,&FROM\n         LA    R0,&LEN\n         LA    R15,&TO\n         BAL   R9,HEX\n         LM    R15,R1,HEXSAVE\n         MEND\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n* ------------------------------------------------------------------- *\n         MACRO\n&LABEL   APUT  &MSG,                    @MESSAGE TEXT                  &\n               &LEN,                    @LENGTH OF MESSAGE             &\n               &RSA=,                   OPTIONAL 2 WORD SAVE AREA      &\n               &EPA=                    EPUTL EPA\n.*\n.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*\n.*  --> E@PUT\n.*\n.*  THIS MACRO SETS UP A PARAMETERS AND INVOKES THE EPUTL ROUTINE.\n.*\n.*\n.*  ARGUMENTS: -----------------------------------------------------\n.*\n.*      &MSG : ADDRESS OF MESSAGE TEXT OR A LITERAL\n.*\n.*      &LEN : LENGTH OF MESSAGE TEXT (DEFAULT IS L'&MSG)\n.*\n.*      &RSA :(OPTIONAL) 1 WORD SAVE AREA TO PRESERVE R14 FOR TPUT\n.*            COMPATIBILITY.\n.*\n.*      &EPA :(OPTIONAL) EPA FOR EPUTL ROUTINE\n.*\n.*\n.*   EXAMPLES: -----------------------------------------------------\n.*\n.*      1) APUT  'LITERAL'\n.*\n.*      2) APUT  (R3),80\n.*\n.*      3) APUT  LABEL\n.*\n.*      4) APUT  LABEL,40\n.*\n.*\n.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*\n.*\n.*  LOCAL SET SYMBOLS\n.*\n         LCLC  &SMA                     MESSAGE ADDRESS (REG)\n         LCLC  &SML                     MESSAGE LENGTH (REG)\n         LCLC  &SEP                     EPA (REGISTER)\n.*\n         LCLC  &L1,&L2,&L3              LOCAL LABELS\n.*\n&L1      SETC  'EP'.'&SYSNDX'.'L1'      LOCAL LABELS\n&L2      SETC  'EP'.'&SYSNDX'.'L2'      LOCAL LABELS\n&L3      SETC  'EP'.'&SYSNDX'.'L3'      LOCAL LABELS\n.*\n.*\n.*  MESSAGE ADDRESS\n.*\n         AIF   (T'&LABEL EQ 'O').A0500                      *HMD 11/86*\n.*                                                          *HMD 11/86*\n&LABEL   DS    0H                                           *HMD 11/86*\n.*                                                          *HMD 11/86*\n.A0500   ANOP                                               *HMD 11/86*\n         AIF   ('&MSG' NE '').A2000\n         MNOTE 8,'''&MSG='' MISSING / REQUIRED'\n         MEXIT\n.*\n.A2000   ANOP\n         AIF   ('&MSG'(1,1) NE '(').A2400\n&SMA     SETC  '&MSG'(2,K'&MSG-2)\n         LR    R1,&SMA                  @MESSAGE TEXT\n         AGO   .A2600\n.*\n.A2400   ANOP\n         AIF   ('&MSG'(1,1) NE '''').A2500\n         B     &L3                      BRANCH AROUND MESSAGE\n&L2      DC    C&MSG\n&L3      DS    0H\n         LA    R1,&L2                   @MESSAGE\n         AGO   .A2600\n.*\n.A2500   ANOP\n         LA    R1,&MSG                  @MESSAGE TEXT\n.A2600   ANOP\n.*\n.*  MESSAGE LENGTH\n.*\n         AIF   ('&LEN' NE '').A3000\n         AIF   ('&MSG'(1,1) NE '''').A2800\n         LA    R0,L'&L2                 MESSAGE LENGTH\n         AGO   .A3600\n.*\n.A2800   ANOP\n         AIF   ('&MSG'(1,1) EQ '(').A2900\n         LA    R0,L'&MSG                MESSAGE LENGTH\n         AGO   .A3600\n.*\n.A2900   ANOP\n         MNOTE 8,'''LEN'' MISSING / REQUIRED'\n         MEXIT\n.*\n.A3000   ANOP\n         AIF   ('&LEN'(1,1) NE '(').A3400\n&SML     SETC  '&LEN'(2,K'&LEN-2)\n         LR    R0,&SML                  MESSAGE LENGTH\n         AGO   .A3600\n.*\n.A3400   ANOP\n         LA    R0,&LEN                  MESSAGE LENGTH\n.A3600   ANOP\n.*\n.*  RSA\n.*\n         AIF   ('&RSA' EQ '').A4900\n         ST    R14,&RSA                 SAVE REGS 14\n.A4900   ANOP\n.*\n.*  ENTRY POINT\n.*\n         AIF   ('&EPA' NE '').A5000\n         L     R15,=V(EPUTL)            EPA\n         AGO   .A5600\n.*\n.A5000   AIF   ('&EPA'(1,1) NE '(').A5400\n&SEP     SETC  '&EPA'(2,K'&EPA-2)\n         LR    R15,&SEP                 EPA\n         AGO   .A5600\n.*\n.A5400   ANOP\n         L     R15,&EPA                 EPA\n.*\n.A5600   ANOP\n.*\n.*  CALL LINKAGE\n.*\n.ACALL   BALR  R14,R15                  CALL PUTLINE ROUTINE\n.*\n         AIF   ('&RSA' EQ '').A6900\n         L     R14,&RSA                 RESTORE R14\n.A6900   ANOP\n.*\n.AMEND   MEND\n* ------------------------------------------------------------------- *\nTSUB     CSECT\nTSUB     AMODE 31\nTSUB     RMODE 24\n         USING *,R15                                                  *\n         B     BEGINN               Eyecatcher\nMAXBLANK DC    F'120'        Guess of max number of blanks after table\n         DC    CL5'TSUB '\nVERS#    DC    CL10'Ver 1.39'\n         DC    CL1' '\n         AIF   ('&SVC' EQ 'SVC').NOSVC00\n         DC    C'&SVC'\n.NOSVC00 ANOP\n         AIF   ('&SVC' EQ 'NOSVC').SVC00\n         DC    C'&SVC'\n         DC    C' '\n         DC    C'&SVCX'\n.SVC00   ANOP\n         DC    CL18' - &SYSDATE &SYSTIME '\nBEGINN   DS    0H\n         DROP  R15\n         USING TSUB,R12,R11,R10,R6,R7  Set up base registers.\n         STM   R14,R12,12(R13)\n         LR    R12,R15                 Set up base registers.\n         ST    R1,SAVEPARM          Save CPPL pointer to use later.\n         LA    R11,4095(,R12)       Second base.\n         LA    R11,1(,R11)\n         LA    R10,4095(,R11)       Third base.\n         LA    R10,1(,R10)\n         LA    R6,4095(,R10)        Fourth base.\n         LA    R6,1(,R6)\n         LA    R7,4095(,R6)         Fifth base.\n         LA    R7,1(,R7)\n         LA    R1,SAVEAREA          Point to new save area\n         ST    R1,8(,R13)           Forward save area chain pointer\n         ST    R13,4(,R1)           Backward save area chain pointer\n         LR    R13,R1               New save area address\n         B     INITCON              Branch past save area\n         SPACE 1\n* -----------------------\nSAVEAREA DC    18F'0'               Non-reentrant save area\n* -----------------------\nINITCON  DS    0H                   Initialize constants to be sure.\n         MVI   OFFFLAG,X'00'\n         MVI   PLATFLG,X'00'\n         MVI   MEASFLG,X'00'\n         MVI   LPAFLAG,X'00'\n         MVI   SHBLFLG,X'00'\n         MVI   LPADFLG,X'00'\n         MVI   NSCHFLG,X'00'\n         MVI   HAVLFLG,X'00'\n         MVI   LWAPFLG,X'00'\n         MVI   LWAMFLG,X'00'\n         MVI   TIDFLAG,X'00'\n         MVI   OLDFLAG,X'00'\n         MVI   FLAGZ,X'00'\n         MVI   LINEB,X'40'\n         MVI   LINAB,X'40'\n         XC    FSTCOUNT,FSTCOUNT\n         XC    FSTNOUNT,FSTNOUNT\n         MVC   FSTFIELD(8),BLANKS\n         MVI   BLANKS-1,X'40'\n         MVC   BLANKS,BLANKS-1\n         MVC   CODEPLAC(2),BLANKS\n         MVC   DISPHDR(16),BLANKS\n         XC    SLOTBIN,SLOTBIN\n         XC    BLNKCNT,BLNKCNT\n         XC    NTRYCNT,NTRYCNT\n         XC    SAVETCUR,SAVETCUR\n         MVC   SLOTSAVE,BLANKS\n         MVC   FSTNAME,BLANKS\n         MVI   CMDBCOPY-1,X'00'\n         MVC   CMDBCOPY,CMDBCOPY-1\n* -----------------------\nGETPSCB  DS    0H                  See if we are allowed to\n*                                  run this program.\n         L     R2,16               POINT TO CVT.\n         L     R2,0(,R2)           POINT TO TCB/ASCB WORDS\n         L     R2,4(,R2)           POINT TO TCB.\n         L     R2,X'B4'(,R2)       POINT TO JSCB.\n         L     R2,X'108'(,R2)      POINT TO PSCB.\n         LA    R2,0(,R2)           CLEAR HIGH BYTE.\n         LTR   R2,R2               ANY PSCB?\n         BZ    EOJ4                GET OUT.  NOT TSO.\n         L     R1,SAVEPARM         Get the address of the CPPL back\n         USING CPPL,R1\n         L     R0,CPPLUPT          Copy CPPL fields for possible\n         ST    R0,SAVEUPT            later use, if needed.\n         L     R0,CPPLPSCB\n         ST    R0,SAVEPSCB\n         L     R0,CPPLECT\n         ST    R0,SAVEECT\n         DROP  R1\n         BAL   R9,PGMTITLE         First display the program title.\n         USING PSCB,R2\nCHEKAUTH DS    0H\n         NOP   GETLWA              Zap to bypass authorization check\n         TM    PSCBATR1,PSCBACCT   ACCT user?\n         BO    GETLWA              Yes.  Continue.\n         TM    PSCBATR1,PSCBCTRL   OPER user?\n         BZ    EOJ4                No.  Get out.\n         DROP  R2\n***** ----- >>>>>\nGETLWA   DS    0H                  Obtain all the relevant fields\n*                                  from the LWA (Logon Work Area)\n         L     R2,X'224'           Point to PSAAOLD\n         L     R2,X'6C'(,R2)       Point to ASXB\n         L     R2,X'14'(,R2)       Point to LWA\n         ST    R2,LWAADDR          Store LWA address\n         USING LWA,R2\n* ------------------------------------------------------------------ *\n*    Save all the relevant information from the LWA, to use later.   *\n* ------------------------------------------------------------------ *\n         ST    R5,SAVER5B          Store original contents of R5\n         L     R5,LWATNS           Pointer to NS table\n         ST    R5,SAVETNS          Save it.\n         L     R5,LWATE2           Pointer to E2 table\n         ST    R5,SAVETE2          Save it.\n         L     R5,LWATE8           Pointer to E8 table\n         ST    R5,SAVETE8          Save it.\n         L     R5,LWATAP           Pointer to AP table\n         ST    R5,SAVETAP          Save it.\n         XR    R5,R5               Clear register to be double sure.\n         LH    R5,LWATNSLN         Length of NS table if available\n         STH   R5,SAVETNSL         Save whatever was there in program.\n         LTR   R5,R5               Has a size been supplied in the LWA?\n         BZ    NONSSIZE            No\n         OI    LWAMFLG,X'40'       Yes. Indicate that in a flag.\nNONSSIZE DS    0H\n         LH    R5,LWATE2LN         Length of E2 table if available\n         STH   R5,SAVETE2L         Save whatever was there in program.\n         LTR   R5,R5               Has a size been supplied in the LWA?\n         BZ    NOE2SIZE            No\n         OI    LWAMFLG,X'20'       Yes. Indicate that in a flag.\nNOE2SIZE DS    0H\n         LH    R5,LWATE8LN         Length of E8 table if available\n         STH   R5,SAVETE8L         Save whatever was there in program.\n         LTR   R5,R5               Has a size been supplied in the LWA?\n         BZ    NOE8SIZE            No\n         OI    LWAMFLG,X'10'       Yes. Indicate that in a flag.\nNOE8SIZE DS    0H\n         LH    R5,LWATAPLN         Length of AP table if available\n         STH   R5,SAVETAPL         Save whatever was there in program.\n         LTR   R5,R5               Has a size been supplied in the LWA?\n         BZ    NOAPSIZE            No\n         OI    LWAMFLG,X'80'       Yes. Indicate that in a flag.\nNOAPSIZE DS    0H\n         L     R5,SAVER5B          Restore original R5 contents\n         MVC   LWAPFLG,LWAPRMLB    Save flags showing which tables\n*                                  came from STEPLIB, if any.\n         DROP  R2\n* ------------------------------------------------------------------ *\n*    At this point we have finished saving things out of the LWA.    *\n* ------------------------------------------------------------------ *\n*    Now we have to find the LPA boundaries.                         *\n* ------------------------------------------------------------------ *\nLPAINFO  DS    0H\n         BAL   R9,GETLPABD         Get list of LPA storage boundaries.\n* ------------------------------------------------------------------ *\n***** ----- >>>>>  We can handle the public Platform Command and     *\n***** ----- >>>>>  Platform Program tables, if they exist.           *\n* ------------------------------------------------------------------ *\nGETPCPP  DS    0H            Info about Platpgm and Platcmd Tables\n         L     R2,16               Point to CVT\n         L     R2,X'9C'(,R2)       Point to TSVT (TSO Vector Table)\n         L     R2,X'4C'(,R2)       Point to TPVT\n         ST    R2,SAVETPVT         Save TPVT address for later use\n         L     R2,X'14'(,R2)       Point to CTLT control block\n         ST    R2,SAVECTLT         Save CTLT address for later use\n         L     R2,SAVETPVT         Load TPVT address back\n         L     R2,X'34'(,R2)       Point to PLATCMD pointer\n         LTR   R2,R2               Is there any?\n         BZ    NOFCVE              No. Say so.\n         ST    R2,SAVEFCVE         Yes. Store the FCVE pointer away.\n         OI    PLATFLG,X'01'       Indicate that FCVE exists.\nTRYPPVE  DS    0H\n         L     R2,SAVETPVT         Load TPVT address back\n         L     R2,X'40'(,R2)       Point to PLATPGM pointer\n         LTR   R2,R2               Is there any?\n         BZ    NOPPVE              No. Say so.\n         ST    R2,SAVEPPVE         Yes. Store the PPVE pointer away.\n         OI    PLATFLG,X'02'       Indicate that PPVE exists.\nTRYPPVEE DS    0H\n         B     CHKOLVER            Skip over relevant error messages.\n* -------------------------------------------------------------- *\n* ------           Error messages if tables don't exist   ------ *\n* -------------------------------------------------------------- *\nNOFCVE   DS    0H\n         APUT  =C'No PLATCMD table found',22\n         B     TRYPPVE\nNOPPVE   DS    0H\n         APUT  =C'No PLATPGM table found',22\n         B     TRYPPVEE\n* ----------------------------------------------------------------- *\n*    There doesn't seem to be a way to tell from an old INMXPARM    *\n*    control block itself, that it is the old version.  So we use   *\n*    the position of the active PARMLIB member name in the TPVT.    *\n* ----------------------------------------------------------------- *\nCHKOLVER DS    0H\n         L     R2,SAVETPVT         Load TPVT address back.\n         CLC   =C'IKJ',7(R2)       Parmlib member name in old position?\n         BNE   PARMSCAN            No. It's a new TSO/E version\n         OI    OLDFLAG,X'01'       Yes. Flag that the system is old.\n* -------------------------------------------------------------- *\n*    After we got the system information we finally start        *\n*     scanning the TSO command for parms, here.                  *\n* -------------------------------------------------------------- *\nPARMSCAN DS    0H\n         L     R1,SAVEPARM         Original R1 from entry to program.\n         LTR   R1,R1               Any CPPL?\n         BZ    EOJ8                No. Get out.\n         L     R1,0(,R1)           Point to Command Buffer\n         LTR   R1,R1               Any Command Buffer?\n         BZ    EOJ4                Get out if none.\n         LH    R3,0(,R1)           Load length.\n         CH    R3,=H'4'            Anything?\n         BNH   EOJ4                No.  Get out.\n         LR    R5,R3               Length of command + 4\n         ICM   R5,14,FULLZERO      Clear high order 3 bytes.\n         ST    R1,CMBUFAD          Save Command Buffer Address\n         LH    R3,2(,R1)           Load offset.\n         ST    R3,OFFSETSV         Save offset value.\n         SR    R5,R3               Subtract offset from full length+4\n         SH    R5,=H'4'            Correct for length of CMDBUFR header\n*                                  in the command buffer.\n         BC    8,EOJC              Zero, Message\n         BC    5,EOJC              Less, or overflow, out.\n         ST    R5,CMBUFEND         Store away the number of bytes left\n         L     R1,CMBUFAD          Load Command Buffer Address\n*\n* ----  Copy command buffer into pgm's buffer so we can control it.\n*\n         STM   R14,R1,SAVE1401     Now save registers 14 thru 1.\n         XR    R14,R14             Clear R14.\n         LH    R14,0(,R1)          Load full command buffer length.\n         S     R14,=F'5'           Subtract 4 for header, 1 for execute\n         ICM   R14,14,FULLZERO     Ensure cmd buffer smaller than 255\n         EX    R14,COPYCMDB        Copy command into pgm's area.\n         LM    R14,R1,SAVE1401     Restore registers 14 thru 1.\n         B     GOGOGO              Jump over executed instruction.\nCOPYCMDB MVC   CMDBCOPY(0),4(R1)   <<< Executed >>>\nGOGOGO   DS    0H\n* ----\n         LA    R2,3                Load register for BCT loop.\n* >>>\n         LA    R1,CMDBCOPY         Point to command in our buffer\n         A     R1,OFFSETSV         Add offset, point to subcommands\n         ST    R1,CHARSTRT         Store starting point away\n* >>>\n         LR    R4,R1               Initialize pointer\n         LA    R4,0(,R4)           to first character of function name.\n         LA    R8,0                Initialize character count\nCUTIDLEN CLI   0(R4),X'40'         Is this character a blank?\n         BE    AFTFIRST            Yes, end of the first parm.\n         CLI   0(R4),X'00'         Is this character hex zero?\n         BE    AFTFIRST            Yes, end of command in buffer copy.\n         LA    R4,1(,R4)           Bump another character\n         LA    R8,1(,R8)           Count another character\n         CR    R8,R5               End of command buffer ?\n         BNL   AFTFIRST            Yes. Get out now.\n         BCT   R2,CUTIDLEN         Try for blank again.\nAFTFIRST DS    0H\n         MVC   TABCODE(8),BLANKS   Clear field\n         BCTR  R8,0                Subtract 1 for execute.\n         L     R1,CHARSTRT         Reload R1 to be sure it's correct.\n         EX    R8,MOVOUTL          Move entered parameter to program.\n         LA    R8,1(,R8)           Restore number of characters\n         AR    R1,R8               Point past last search\n         ST    R1,CHARCONT         Continue from here\n         ST    R8,SAVER8A          Save register\n* ---- >\nSEEIFPRM DS    0H                  Check if a command is here\n         OC    TABCODE(3),BLANKS   Uppercase. Won't affect numbers.\n         CLI   TABCODE+2,C'X'      Special action code, code X.\n         BNE   SEEIFJ01            Not this. Just go on.\n         OI    LPADFLG,X'01'       Set flag to display LPA range.\nSEEIFJ01 DS    0H\n*--*\n         TM    LPADFLG,X'01'       Display LPA range only?\n         BZ    SEEIFK01            No. Do all regular processing.\n         BAL   R9,GETLPRNT         Yes. Display LPA range and exit.\n         B     EOJ0                Out of program with Code 0\nSEEIFK01 DS    0H\n*--*\n         CLI   TABCODE+2,C'R'      Replace the entry in the given slot\n         BE    SEEIF0A1\n         CLI   TABCODE+2,C'B'      Blank the given slot\n         BE    SEEIF0A2\n         CLI   TABCODE+2,C'D'      Display contents of given slot\n         BE    SEEIF0A3              or all slots.\n         CLI   TABCODE+2,C'H'      Alter table header\n         BE    SEEIF0A4\n         CLI   TABCODE+2,C'L'      Supply length for table in LWA\n         BE    SEEIF0A5              including trailing blank entries.\n         CLI   TABCODE+2,C'M'      Supply length for table in LWA plus\n         BE    SEEIF0M5              one trailing blank, if there.\n         CLI   TABCODE+2,C'Z'      Zero length for table in LWA\n         BE    SEEIF0A6\n         CLI   TABCODE+2,C'S'      Say this table came from STEPLIB\n         BE    SEEIF0A7\n         CLI   TABCODE+2,C'P'      Say this table is not from STEPLIB\n         BE    SEEIF0A8\n         CLI   TABCODE+2,C'N'      Are we nullifying an entry?\n         BE    SEEIF0A9\n         B     SEEIF000\nSEEIF0A1 DS    0H\n         OI    OFFFLAG,X'01'       Replace an entry\n         B     SEEIF001\nSEEIF0A2 DS    0H\n         OI    OFFFLAG,X'02'       Blank entry in the last slot\n         B     SEEIF001\nSEEIF0A3 DS    0H\n         OI    OFFFLAG,X'04'       Display an entry or entries\n         B     SEEIF001\nSEEIF0A4 DS    0H\n         OI    OFFFLAG,X'08'       Alter table header\n         B     SEEIF001\nSEEIF0M5 DS    0H                  Short length with one blank\n         OI    SHBLFLG,X'01'\nSEEIF0A5 DS    0H\n         OI    OFFFLAG,X'10'       Supply length for table in LWA\n         B     SEEIF001\nSEEIF0A6 DS    0H\n         OI    OFFFLAG,X'20'       Zero length for table in LWA\n         B     SEEIF001\nSEEIF0A7 DS    0H\n         OI    OFFFLAG,X'40'       Say this table came from STEPLIB\n         B     SEEIF001\nSEEIF0A8 DS    0H\n         OI    OFFFLAG,X'80'       Say this table not from STEPLIB\n         B     SEEIF001\nSEEIF0A9 DS    0H\n         OI    OFFFLAG1,X'10'      Use OFFFLAF1\n         MVI   OFFFLAG,X'00'         instead of OFFFLAG.\n         B     SEEIF001\nSEEIF000 DS    0H                  Wrong function code was entered...\n* --- >                            Display what we entered, plus code\n         MVC   LINE,LINEB          Clear line\n         MVC   LINE(3),TABCODE     Move code in\n         HEX   LINE+6,1,OFFFLAG    Display contents of flag\n         HEX   LINE+8,1,OFFFLAG1\n         MVC   LINE+15(37),=C'Program table code + Function code '\n         APUT  LINE,50\n* --- >\n         BAL   R9,ERRORCOD         Indicate error and display syntax.\n         B     EOJ4                Get out with code = 4.\nSEEIF001 DS    0H                  Which table to change\n         MVC   CODEPLAC(2),TABCODE    Save table code.\n* --- >\n         TM    OFFFLAG,X'04'       Display only--no changes to be made\n         BO    NOBEFORE            Don't show \"before changes\" message\n         STM   R14,R1,SAVE1401     Save registers 14 thru 1.\n         MVC   LINE,LINE-1\n         APUT  LINE,30\n         APUT  MESSAGED,L'MESSAGED Say \"after making changes\"\n         LM    R14,R1,SAVE1401     Restore registers 14 thru 1.\nNOBEFORE DS    0H\n* --- >                            Display what we entered, plus code\n         MVC   LINE,LINEB          Clear line\n         MVC   LINE(3),TABCODE     Move code in\n         HEX   LINE+6,1,OFFFLAG    Display contents of flag\n         HEX   LINE+8,1,OFFFLAG1\n         MVC   LINE+15(37),=C'Program table code + Function code '\n         APUT  LINE,50\n* --- >                            Handle each table separately.\n         CLC   TABCODE(2),=C'E2'   Change IKJEFTE2?\n         BE    E2CHANGE            Yes. Branch.\n         CLC   TABCODE(2),=C'E8'   Change IKJEFTE8?\n         BE    E8CHANGE            Yes. Branch.\n         CLC   TABCODE(2),=C'AP'   Change IKJEFTAP?\n         BE    APCHANGE            Yes. Branch.\n         CLC   TABCODE(2),=C'PC'   Change PLATCMD?\n         BE    PCCHANGE            Yes. Branch.\n         CLC   TABCODE(2),=C'PP'   Change PLATPGM?\n         BE    PPCHANGE            Yes. Branch.\n         CLC   TABCODE(2),=C'NS'   Change IKJEFTNS?\n         BE    NSCHANGE            Yes. Branch.\n         BAL   R9,ERRORCOD         Indicate error and display syntax.\n         B     EOJ4                Invalid code entered.\nEOJ      DS    0H                  END OF JOB\n         L     R13,4(,R13)\n         LR    R15,R5              Put in real return code\n         ST    R15,16(,R13)        Shove it where it belongs\n         L     R14,12(,R13)        R14 and\n         LM    R0,R12,20(R13)        rest of registers\n         BR    R14                 Go back to caller\nEOJ0     DS    0H                  Return code 0\n         MVC   LINE,LINE-1\n         APUT  LINE,30\n         MVC   LINE,LINE-1         Clear output area\n         MVC   LINE,MESSAGR0       Show Return Code 0\n         APUT  MESSAGR0,L'MESSAGR0\n         LA    R5,0                Set CC = 0\n         B     EOJ                 Now end the program\nEOJ4     DS    0H                  Return code 4\n         MVC   LINE,LINE-1\n         APUT  LINE,30\n         MVC   LINE,LINE-1         Clear output area\n         MVC   LINE,MESSAGR4       Show Return Code 4\n         APUT  LINE,L'MESSAGR4\n         L     R5,FULLFOUR         Set CC = 4\n         B     EOJ                 Now end the program\nEOJ8     DS    0H                  Return code 8\n         MVC   LINE,LINE-1\n         APUT  LINE,30\n         MVC   LINE,LINE-1         Clear output area\n         MVC   LINE,MESSAGR8       Show Return Code 8\n         APUT  LINE,L'MESSAGR8\n         L     R5,FULLEIGT         Set CC = 8\n         B     EOJ                 Now end the program\nEOJC     DS    0H                  Return code 12\n         MVC   LINE,LINE-1\n         APUT  LINE,30\n         MVC   LINE,LINE-1         Clear output area\n         MVC   LINE,MESSAGRC       Show Return Code 12\n         APUT  LINE,L'MESSAGRC\n         L     R5,FULLTWLV         Set CC = 12\n         B     EOJ                 Now end the program\n** ---------------------------------------------------------------- **\n**                                                                  **\n**   Different Table Handling Routines                              **\n**   --------- ----- -------- --------                              **\n**                                                                  **\n**  At this point, we have the routines which handle each of the    **\n**  separate types of tables.  E2, E8, AP, and NS, for which the    **\n**  live LWA version is handled.  But we also do the FCVE and       **\n**  PPVE (Platform Command and Platform Program) tables pointed     **\n**  to by the TPVT (TSO Parmlib Vector Table) control block, and    **\n**  those two tables, if they exist, are similarly handled.  But    **\n**  the FCVE and PPVE tables (table codes PC and PP respectively,   **\n**  in this program) are in common storage, and are not in the      **\n**  TSO user's address space.                                       **\n**                                                                  **\n** ---------------------------------------------------------------- **\nE2CHANGE DS    0H                 Handle the E2 table\n         OI    TIDFLAG,X'20'      Show we're doing the E2 table.\n         MVC   TABLEID,=C'E2'     Identify which table\n         BAL   R9,ADJNEXTP        Get to first blank\n         BAL   R9,NAMEPARM        Get rest of parms from the command\n         L     R4,SAVETE2         Point to saved E2 table address\n         ST    R4,TABLSTRT        Store start address of table\n         ST    R4,TABLADDR        Keep start address of table\n*\n         BAL   R9,TESTLPA         Check if table address is in LPA\n         BAL   R9,CHANGEDL        LPA message (conditional)\n         BAL   R9,MEASUR08        Measure the table\n*\n         L     R1,TABLSTRT        Load it back into work register\n**-->>\nE2CHENTY DS    0H                 Show we have a size for E2 table\n         TM    LPAFLAG,X'01'      Is this table in LPA?\n         BO    E2CHYSST           Yes. Don't message the properties.\n         TM    LWAMFLG,X'20'      Do we have a size for the E2 table?\n         BZ    E2CHNOSZ           No.\n         OI    FLAGZ,X'04'        Yes. Flag that we have a size.\n         STM   R14,R1,SAVE1401    Save registers 14 thru 1.\n         MVC   MESSAG1A+6(2),CODEPLAC    Move in table code.\n         HEX   MESSAG1A+57,2,SAVETE2L    Move in length amount\n         MVI   MESSAG1A+61,C'.'          Put period at end.\n         APUT  MESSAG1A,L'MESSAG1A\n         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.\n         B     E2CHYSSZ\nE2CHNOSZ DS    0H                 Show message that we have no size\n         STM   R14,R1,SAVE1401    Save registers 14 thru 1.\n         MVC   MESSAG1B+6(2),CODEPLAC    Move in table code.\n         APUT  MESSAG1B,L'MESSAG1B\n         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.\nE2CHYSSZ DS    0H\n         TM    LWAPFLG,X'20'      Was the E2 table loaded from STEPLIB?\n         BZ    E2CHNOST           No. Say that it wasn't.\n         STM   R14,R1,SAVE1401    Yes. Put out message saying it was.\n         MVC   MESSAG1C+6(2),CODEPLAC    Move in table code.\n         APUT  MESSAG1C,L'MESSAG1C\n         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.\n         B     E2CHYSST\nE2CHNOST DS    0H                 Message. Table not from STEPLIB.\n         STM   R14,R1,SAVE1401    Save registers 14 thru 1.\n         MVC   MESSAG1D+6(2),CODEPLAC    Move in table code.\n         APUT  MESSAG1D,L'MESSAG1D\n         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.\nE2CHYSST DS    0H\n*-*                               Print out table header\n         BAL   R9,PRTABLHD        Table Header Display Routine\n*-*\n         LA    R1,X'10'(,R1)      Bump past header\n         ST    R1,TABLSTRT        Store new start address\n* - -\n         LH    R2,SAVETE2L        Load LWA Table Length\n         LTR   R2,R2              Is it there?\n         BNZ   E2CHHAVB           There is a length, so we use it.\n* - -                             None there, have to guess.\n***\n         LH    R3,ME08LENG        Measured table length.\n***\n         B     E2CHNOHB           And go on.\nE2CHHAVB DS    0H                 We have a table length given.\n         MVC   SAVETCUR,SAVETE2L  This is the length we use for now.\n         LR    R3,R2              Dump the number into R3.\nE2CHNOHB DS    0H\n         L     R4,TABLADDR        Load start address of table\n         AR    R4,R3              Point past the guessed end of table.\n         S     R4,=F'16'          Compensate for 16 byte head start.\n         ST    R4,TABLEND         Store away guessed table end.\n* - -\n         LR    R5,R3              Dump best length into register.\n         SRL   R5,3               Divide by 8.\n         BCTR  R5,0               Actually two fewer entries, because\n         BCTR  R5,0                of the header.\n         ST    R5,TABLENUM        Store the number of entries.\n***\n         STM   R14,R1,SAVE1401    Save registers 14 thru 1.\n         MVC   LINE,LINE-1\n         ST    R1,SAVER1B\n         L     R1,TABLENUM         Display field\n         CVD   R1,CVDAREA          Convert count to printable\n         MVC   LINE+22(10),MASK10  Move in the mask\n         ED    LINE+22(10),CVDAREA+3 Make it pretty\n         L     R1,SAVER1B\n         MVC   LINE(24),=C'Number of valid entries:'\n         APUT  LINE,45\n         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.\n***\n* - >\n         LA    R5,8               Size of each E2 table entry\n         ST    R5,TABLESIZ        Store size of each entry\n*                                 We'll stop the search at first blank\n         SR    R4,R5              Point past end of table - guessed.\n         ST    R4,SAVLSLOT        Store this location\n         TM    OFFFLAG,X'04'      Is this just a contents display?\n         BZ    E2CHANGX           No. We must do a real change.\n         BAL   R9,DISPTABL        Yes. Just display.\n         BAL   R9,CHANGED         Message that nothing changed.\n         B     EOJ0\nE2CHANGX DS    0H\n         BAL   R9,DISPTABL        Search table for the proper entry.\n         BAL   R9,SETTMODE        Do the Key 0 stuff\n         BAL   R9,CHANGED         Tell em we changed the values.\n         B     EOJ0\n** ---------------------------------------------------------------- **\nE8CHANGE DS    0H                 Handle the E8 table\n         OI    TIDFLAG,X'10'      Show we're doing the E8 table.\n         MVC   TABLEID,=C'E8'     Identify which table\n         BAL   R9,ADJNEXTP        Get to first blank\n         BAL   R9,NAMEPARM        Get rest of parms from the command\n         L     R4,SAVETE8         Point to saved E8 table address\n         ST    R4,TABLSTRT        Store start address of table\n         ST    R4,TABLADDR        Keep start address of table\n*\n         BAL   R9,TESTLPA         Check if table address is in LPA\n         BAL   R9,CHANGEDL        LPA message (conditional)\n         BAL   R9,MEASUR08        Measure the table\n*\n         L     R1,TABLSTRT        Load it back into work register\n**-->>\nE8CHENTY DS    0H                 Deal with the E8 table.             .\n         TM    LPAFLAG,X'01'      Is this table in LPA?\n         BO    E8CHYSST           Yes. Don't message the properties.\n         TM    LWAMFLG,X'10'      Do we have a size for the E8 table?\n         BZ    E8CHNOSZ           No.\n         OI    FLAGZ,X'04'        Yes. Flag that we have a size.\n         STM   R14,R1,SAVE1401    Save registers 14 thru 1.\n         MVC   MESSAG1A+6(2),CODEPLAC    Move in table code.\n         HEX   MESSAG1A+57,2,SAVETE8L    Move in length amount\n         MVI   MESSAG1A+61,C'.'          Put period at end.\n         APUT  MESSAG1A,L'MESSAG1A\n         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.\n         B     E8CHYSSZ\nE8CHNOSZ DS    0H\n         STM   R14,R1,SAVE1401    Save registers 14 thru 1.\n         MVC   MESSAG1B+6(2),CODEPLAC    Move in table code.\n         APUT  MESSAG1B,L'MESSAG1B\n         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.\nE8CHYSSZ DS    0H\n         TM    LWAPFLG,X'10'      Was the E8 table loaded from STEPLIB?\n         BZ    E8CHNOST           No. Say that it wasn't.\n         STM   R14,R1,SAVE1401    Yes. Put out message saying it was.\n         MVC   MESSAG1C+6(2),CODEPLAC    Move in table code.\n         APUT  MESSAG1C,L'MESSAG1C\n         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.\n         B     E8CHYSST\nE8CHNOST DS    0H                 Message. Table not from STEPLIB.\n         STM   R14,R1,SAVE1401    Save registers 14 thru 1.\n         MVC   MESSAG1D+6(2),CODEPLAC    Move in table code.\n         APUT  MESSAG1D,L'MESSAG1D\n         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.\nE8CHYSST DS    0H\n*-*                               Print out table header\n         BAL   R9,PRTABLHD        Table Header Display Routine\n*-*\n         LA    R1,X'10'(,R1)      Bump past header\n         ST    R1,TABLSTRT        Store new start address\n* - -\n         LH    R2,SAVETE8L        Load LWA Table Length\n         LTR   R2,R2              Is it there?\n         BNZ   E8CHHAVB           There is a length, so we use it.\n* - -                             None there, have to guess.\n***\n         LH    R3,ME08LENG        Measured table length.\n***\n         B     E8CHNOHB           And go on.\nE8CHHAVB DS    0H                 We have a table length given.\n         MVC   SAVETCUR,SAVETE8L  This is the length we use for now.\n         LR    R3,R2              Dump the number into R3.\nE8CHNOHB DS    0H\n         L     R4,TABLADDR        Load start address of table\n         AR    R4,R3              Point past the guessed end of table.\n         S     R4,=F'16'          Compensate for 16 byte head start.\n         ST    R4,TABLEND         Store away guessed table end.\n* - -\n         LR    R5,R3              Dump best length into register.\n         SRL   R5,3               Divide by 8.\n         BCTR  R5,0               Actually two fewer entries, because\n         BCTR  R5,0                of the header.\n         ST    R5,TABLENUM        Store the number of entries.\n***\n         STM   R14,R1,SAVE1401    Save registers 14 thru 1.\n         MVC   LINE,LINE-1\n         ST    R1,SAVER1B\n         L     R1,TABLENUM         Display field\n         CVD   R1,CVDAREA          Convert count to printable\n         MVC   LINE+22(10),MASK10  Move in the mask\n         ED    LINE+22(10),CVDAREA+3 Make it pretty\n         L     R1,SAVER1B\n         MVC   LINE(24),=C'Number of valid entries:'\n         APUT  LINE,45\n         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.\n***\n* - -\n         LA    R5,8               Size of each E8 table entry\n         ST    R5,TABLESIZ        Store size of each entry\n* - -                             We'll stop the search at first blank\n         SR    R4,R5              Point past end of table - guessed.\n         ST    R4,SAVLSLOT        Store this location\n         TM    OFFFLAG,X'04'      Is this just a contents display?\n         BZ    E8CHANGX           No. We must do a real change.\n         BAL   R9,DISPTABL        Yes. Just display.\n         BAL   R9,CHANGED         Message that nothing changed.\n         B     EOJ0\nE8CHANGX DS    0H\n         BAL   R9,DISPTABL        Search table for the proper entry.\n         BAL   R9,SETTMODE        Do the Key 0 stuff\n         BAL   R9,CHANGED         Tell em we changed the values.\n         B     EOJ0\n** ---------------------------------------------------------------- **\nAPCHANGE DS    0H                 Handle the AP table\n         OI    TIDFLAG,X'80'      Show we're doing the AP table.\n         MVC   TABLEID,=C'AP'     Identify which table\n         BAL   R9,ADJNEXTP        Get to first blank\n         BAL   R9,NAMEPARM        Get rest of parms from the command\n* - -\n         L     R4,SAVETAP         Get address of AP table\n         ST    R4,TABLSTRT        Store start address of table\n         ST    R4,TABLADDR        Keep start address of table\n*\n         BAL   R9,TESTLPA         Check if table address is in LPA\n         BAL   R9,CHANGEDL        LPA message (conditional)\n         BAL   R9,MEASUR08        Measure the table\n*\n         L     R1,TABLSTRT        Load it back into work register\n**-->>\nAPCHENTY DS    0H                 Table was made from a IKJTSOxx entry.\n         TM    LPAFLAG,X'01'      Is this table in LPA?\n         BO    APCHYSST           Yes. Don't message the properties.\n         TM    LWAMFLG,X'80'      Do we have a size for the AP table?\n         BZ    APCHNOSZ           No.\n         OI    FLAGZ,X'04'        Yes. Flag that we have a size.\n         STM   R14,R1,SAVE1401    Save registers 14 thru 1.\n         MVC   MESSAG1A+6(2),CODEPLAC    Move in table code.\n         HEX   MESSAG1A+57,2,SAVETAPL    Move in length amount\n         MVI   MESSAG1A+61,C'.'          Put period at end.\n         APUT  MESSAG1A,L'MESSAG1A\n         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.\n         B     APCHYSSZ\nAPCHNOSZ DS    0H\n         STM   R14,R1,SAVE1401    Save registers 14 thru 1.\n         MVC   MESSAG1B+6(2),CODEPLAC    Move in table code.\n         APUT  MESSAG1B,L'MESSAG1B\n         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.\nAPCHYSSZ DS    0H\n         TM    LWAPFLG,X'80'      Was the AP table loaded from STEPLIB?\n         BZ    APCHNOST           No. Say that it wasn't.\n         STM   R14,R1,SAVE1401    Yes. Put out message saying it was.\n         MVC   MESSAG1C+6(2),CODEPLAC    Move in table code.\n         APUT  MESSAG1C,L'MESSAG1C\n         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.\n         B     APCHYSST\nAPCHNOST DS    0H                 Message. Table not from STEPLIB.\n         STM   R14,R1,SAVE1401    Save registers 14 thru 1.\n         MVC   MESSAG1D+6(2),CODEPLAC    Move in table code.\n         APUT  MESSAG1D,L'MESSAG1D\n         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.\nAPCHYSST DS    0H\n*-*                               Print out table header\n         BAL   R9,PRTABLHD        Table Header Display Routine\n*-*\n         LA    R1,X'10'(,R1)      Bump past header\n         ST    R1,TABLSTRT        Store new start address\n* - -\n         LH    R2,SAVETAPL        Load LWA Table Length\n         LTR   R2,R2              Is it there?\n         BNZ   APCHHAVB           There is a length, so we use it.\n* - -                             None there, have to guess.\n***\n         LH    R3,ME08LENG        Measured table length.\n***\n         B     APCHNOHB           And go on.\nAPCHHAVB DS    0H                 We have a table length given.\n         MVC   SAVETCUR,SAVETAPL  This is the length we use for now.\n         LR    R3,R2              Dump the number into R3.\nAPCHNOHB DS    0H\n         L     R4,TABLADDR        Load start address of table\n         AR    R4,R3              Point past the guessed end of table.\n         S     R4,=F'16'          Compensate for 16 byte head start.\n         ST    R4,TABLEND         Store away guessed table end.\n* - -\n         LR    R5,R3              Dump best length into register.\n         SRL   R5,3               Divide by 8.\n         BCTR  R5,0               Actually two fewer entries, because\n         BCTR  R5,0                of the header.\n         ST    R5,TABLENUM        Store the number of entries.\n***\n         STM   R14,R1,SAVE1401    Save registers 14 thru 1.\n         MVC   LINE,LINE-1\n         ST    R1,SAVER1B\n         L     R1,TABLENUM         Display field\n         CVD   R1,CVDAREA          Convert count to printable\n         MVC   LINE+22(10),MASK10  Move in the mask\n         ED    LINE+22(10),CVDAREA+3 Make it pretty\n         L     R1,SAVER1B\n         MVC   LINE(24),=C'Number of valid entries:'\n         APUT  LINE,45\n         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.\n***\n* - -\n         LA    R5,8               Size of each AP table entry\n         ST    R5,TABLESIZ        Store size of each entry\n* - -                             We'll stop the search at first blank\n         SR    R4,R5              Point past end of table - guessed.\n         ST    R4,SAVLSLOT        Save this location.\n         TM    OFFFLAG,X'04'      Is this just a contents display?\n         BZ    APCHANGX           No. We must do a real change.\n         BAL   R9,DISPTABL        Yes. Just display.\n         BAL   R9,CHANGED         Message that nothing changed.\n         B     EOJ0\nAPCHANGX DS    0H\n         BAL   R9,DISPTABL        Search table for the proper entry.\n         BAL   R9,SETTMODE        Do the Key 0 stuff\n         BAL   R9,CHANGED         Tell em we changed the values.\n         B     EOJ0\n** ---------------------------------------------------------------- **\nPCCHANGE DS    0H                 Handle the PC table\n         OI    TIDFLAG,X'01'      Show PC table chosen.\n         MVC   TABLEID,=C'PC'\n         TM    PLATFLG,X'01'      Does the table exist?\n         BZ    PCCHAERR           No. Report error.\n         BAL   R9,ADJNEXTP        Get to first blank\n         BAL   R9,NAMEPARM        Get rest of parms from the command\n         L     R2,SAVEFCVE        Get the PC table address\n         LR    R4,R2              Save it off\n         ST    R4,DISPREG         Store register contents for display\n* -- >                            Do Display\n*-*-*->>                          Print the address out so we can see.\n         STM   R14,R1,SAVE1401    Save registers 14 thru 1.\n         MVC   LINE,LINE-1        Clear line area.\n         MVC   LINE(16),=C'Table address:  '\n         HEX   LINE+21,4,DISPREG      Display address in Hex\n         APUT  LINE,35\n         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.\n*-*-*->>\n* -- >\n         L     R3,X'8'(,R4)       Point to length of table\n         STH   R3,SAVETCUR        Store it to show non-zero\n         AR    R4,R3              Point just past PC table\n         ST    R4,TABLEND         And mark the projected end of table\n* - -\n         L     R3,X'C'(,R2)       Get number of table entries\n         ST    R3,TABLENUM        Preserve number for table search\n         LA    R3,8               Load table size\n         ST    R3,TABLESIZ        And store it for DISPTABL routine\n** -- **\n***\n         STM   R14,R1,SAVE1401    Save registers 14 thru 1.\n         MVC   LINE,LINE-1\n         MVC   LINE(22),=C'Table length in Hex:  '\n         HEX   LINE+25,2,SAVETCUR\n         APUT  LINE,45\n         MVC   LINE,LINE-1\n         ST    R1,SAVER1B\n         L     R1,TABLENUM         Display field\n         CVD   R1,CVDAREA          Convert count to printable\n         MVC   LINE+22(10),MASK10  Move in the mask\n         ED    LINE+22(10),CVDAREA+3 Make it pretty\n         L     R1,SAVER1B\n         MVC   LINE(24),=C'Number of valid entries:'\n         APUT  LINE,45\n         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.\n***\n** -- **\n         L     R3,SAVEFCVE        Get the platcmd table start address\n         LA    R3,X'10'(,R3)      Bump past its header\n         ST    R3,TABLSTRT        And store the starting place away\n* - -\n         LA    R5,8               Get 8 bytes ready for subtraction\n         SR    R4,R5              Back up to the last slot\n         ST    R4,SAVLSLOT        Save location of last table slot\n         TM    OFFFLAG,X'04'      Is this just a contents display?\n         BZ    PCCHANGX           No. We must do a real change.\n         BAL   R9,DISPTABL        Yes. Just display.\n         BAL   R9,CHANGED         Message\n         B     EOJ0\nPCCHANGX DS    0H\n         BAL   R9,DISPTABL        Search table for the proper entry.\n         BAL   R9,SETTMODE        Do the Key 0 stuff\n         BAL   R9,CHANGED         Tell em we changed the values.\n         B     EOJ0\nPCCHAERR DS    0H                 Say no PC table exists.\n         MVC   LINE,LINE-1\n         MVC   LINE(43),=C'PC command not valid if no PC table exists.'\n         APUT  LINE,43\n         B     EOJ4\nPCCHAEND DS    0H\n         B     EOJ0\n** ---------------------------------------------------------------- **\nPPCHANGE DS    0H                 Handle the PP table\n         OI    TIDFLAG,X'02'      Show PP table chosen.\n         MVC   TABLEID,=C'PP'\n         TM    PLATFLG,X'02'      Is there a Platpgm table?\n         BZ    PPCHAERR           If no, then display error condition\n         BAL   R9,ADJNEXTP        Get to first blank\n         BAL   R9,NAMEPARM        Get rest of parms from the command\n         L     R2,SAVEPPVE        Get the PP table address\n         LR    R4,R2              Save it off\n         ST    R4,DISPREG         Store PP table address for display\n* -- >                            Do Display\n*-*-*->>                          Print the address out so we can see.\n         STM   R14,R1,SAVE1401    Save registers 14 thru 1.\n         MVC   LINE,LINE-1        Clear line area.\n         MVC   LINE(16),=C'Table address:  '\n         HEX   LINE+21,4,DISPREG      Display address in Hex\n         APUT  LINE,35\n         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.\n*-*-*->>\n* -- >\n         L     R3,X'8'(,R4)       Size of PP table in bytes\n         STH   R3,SAVETCUR        Show it's non-zero\n         AR    R4,R3              Point just past the PP table\n         ST    R4,TABLEND         Mark the end of table for DISPTABL\n* - -\n         L     R3,X'C'(,R2)       Get number of table entries\n         ST    R3,TABLENUM        Store that number away for DISPTABL\n         LA    R3,8               Size of each entry\n         ST    R3,TABLESIZ        Store that away too\n** -- **\n***\n         STM   R14,R1,SAVE1401    Save registers 14 thru 1.\n         MVC   LINE,LINE-1\n         MVC   LINE(22),=C'Table length in Hex:  '\n         HEX   LINE+25,2,SAVETCUR\n         APUT  LINE,45\n         MVC   LINE,LINE-1\n         ST    R1,SAVER1B\n         L     R1,TABLENUM         Display field\n         CVD   R1,CVDAREA          Convert count to printable\n         MVC   LINE+22(10),MASK10  Move in the mask\n         ED    LINE+22(10),CVDAREA+3 Make it pretty\n         L     R1,SAVER1B\n         MVC   LINE(24),=C'Number of valid entries:'\n         APUT  LINE,45\n         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.\n***\n** -- **\n         L     R3,SAVEPPVE        Get start address of PP table\n         LA    R3,X'10'(,R3)      Add 16 to bump past header\n         ST    R3,TABLSTRT        Store search starting address away\n* - -\n         LA    R5,8               Load size of one entry\n         SR    R4,R5              Back up to last slot address\n         ST    R4,SAVLSLOT        And save it off.\n         TM    OFFFLAG,X'04'      Is this just a contents display?\n         BZ    PPCHANGX           No. We must do a real change.\n         BAL   R9,DISPTABL        Yes. Just display.\n         BAL   R9,CHANGED         Message\n         B     EOJ0\nPPCHANGX DS    0H\n         BAL   R9,DISPTABL        Search table for the proper entry.\n         BAL   R9,SETTMODE        Do the Key 0 stuff\n         BAL   R9,CHANGED         Tell em we changed the values.\n         B     EOJ0\nPPCHAERR DS    0H                 Say no PC table exists.\n         MVC   LINE,LINE-1\n         MVC   LINE(43),=C'PP command not valid if no PP table exists.'\n         APUT  LINE,43\n         B     EOJ4\nPPCHAEND DS    0H\n         B     EOJ0\n** ---------------------------------------------------------------- **\nNSCHANGE DS    0H                 Handle the NS table\n         OI    TIDFLAG,X'40'      Show we're doing the NS table.\n         MVC   TABLEID,=C'NS'     Identify which table\n         BAL   R9,ADJNEXTP        Get to first blank\n         BAL   R9,NAMEPARM        Get rest of parms from the command\n         OI    NSCHFLG,X'01'      Show SETTMODE we're doing NS\n* - -\n         L     R4,SAVETNS         Saved location of the NS table\n         ST    R4,TABLSTRT        Store start address of table\n         ST    R4,TABLADDR        Keep start address of table\n*\n         BAL   R9,TESTLPA         Check if table address is in LPA\n         BAL   R9,CHANGEDL        LPA message (conditional)\n         BAL   R9,MEASUR10        Measure the table\n*\n         L     R1,TABLSTRT        Load it to start table search later\n**-->>\nNSCHENTY DS    0H                 Table was made from a IKJTSOxx entry.\n         TM    LPAFLAG,X'01'      Is this table in LPA?\n         BO    NSCHYSST           Yes. Don't message the properties.\n         TM    LWAMFLG,X'40'      Do we have a size for the NS table?\n         BZ    NSCHNOSZ           No.\n         OI    FLAGZ,X'04'        Yes. Flag that we have a size.\n         STM   R14,R1,SAVE1401    Save registers 14 thru 1.\n         MVC   MESSAG1A+6(2),CODEPLAC    Move in table code.\n         HEX   MESSAG1A+57,2,SAVETNSL    Move in length amount\n         MVI   MESSAG1A+61,C'.'          Put period at end.\n         APUT  MESSAG1A,L'MESSAG1A\n         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.\n         B     NSCHYSSZ\nNSCHNOSZ DS    0H                 Say we have no size for the NS table\n         STM   R14,R1,SAVE1401    Save registers 14 thru 1.\n         MVC   MESSAG1B+6(2),CODEPLAC    Move in table code.\n         APUT  MESSAG1B,L'MESSAG1B\n         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.\nNSCHYSSZ DS    0H\n         TM    LWAPFLG,X'40'      Was the NS table loaded from STEPLIB?\n         BZ    NSCHNOST           No. Say that it wasn't.\n         STM   R14,R1,SAVE1401    Yes. Put out message saying it was.\n         MVC   MESSAG1C+6(2),CODEPLAC    Move in table code.\n         APUT  MESSAG1C,L'MESSAG1C\n         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.\n         B     NSCHYSST           Don't put out contradictory messages\nNSCHNOST DS    0H                 Message. Table not from STEPLIB.\n         STM   R14,R1,SAVE1401    Save registers 14 thru 1.\n         MVC   MESSAG1D+6(2),CODEPLAC    Move in table code.\n         APUT  MESSAG1D,L'MESSAG1D\n         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.\nNSCHYSST DS    0H\n*-*                               Print out table header\n         BAL   R9,PRTABLHD        Table Header Display Routine\n*-*\n         LA    R1,X'10'(,R1)      Bump past the table header\n         ST    R1,TABLSTRT        Store new start address for DISPTABL\n* - -\n         LH    R2,SAVETNSL        Load LWA Table Length\n         LTR   R2,R2              Is it there?\n         BNZ   NSCHHAVB           There is a length, so we use it.\n* - -                             None there, have to guess.\n***\n         LH    R3,ME10LENG        Measured table length.\n***\n         B     NSCHNOHB           And go on.\nNSCHHAVB DS    0H                 We have a table length given.\n         MVC   SAVETCUR,SAVETNSL  This is the length we use for now.\n         LR    R3,R2              Dump the number into R3.\nNSCHNOHB DS    0H\n         L     R4,TABLADDR        Load start address of table\n         AR    R4,R3              Point past the guessed end of table.\n*        S     R4,=F'16'          Compensate for 16 byte head start.\n         ST    R4,TABLEND         Store away guessed table end.\n* - -\n         LR    R5,R3              Dump best length into register.\n         S     R5,=F'16'\n         STM   R2,R3,SAVER23      Save work registers.\n         XR    R2,R2              Zero work registers.\n         XR    R3,R3\n         LR    R3,R5              Feed length into work register\n         D     R2,=F'10'          Divide by 10.\n         LR    R5,R3              Save the result.\n         LM    R2,R3,SAVER23      Restore work registers.\n         ST    R5,TABLENUM        Store the number of entries.\n***\n         STM   R14,R1,SAVE1401    Save registers 14 thru 1.\n         MVC   LINE,LINE-1\n         ST    R1,SAVER1B\n         L     R1,TABLENUM         Display field\n         CVD   R1,CVDAREA          Convert count to printable\n         MVC   LINE+22(10),MASK10  Move in the mask\n         ED    LINE+22(10),CVDAREA+3 Make it pretty\n         L     R1,SAVER1B\n         MVC   LINE(24),=C'Number of valid entries:'\n         APUT  LINE,45\n         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.\n***\n* - -\n         XR    R5,R5              Clear register\n         LA    R5,10              Size of each NS table entry\n         ST    R5,TABLESIZ        Store size of each table entry\n* - -                             We'll stop the search at first blank\n         SR    R4,R5              Point to Last Slot\n         ST    R4,SAVLSLOT        Save location of last slot\n         TM    OFFFLAG,X'04'      Is this just a contents display?\n         BZ    NSCHANGX           No. We must do a real change.\n         BAL   R9,DISPTABL        Yes. Just display.\n         BAL   R9,CHANGED         Message that nothing changed.\n         B     EOJ0\nNSCHANGX DS    0H\n         BAL   R9,DISPTABL        Search table for the proper entry.\n         BAL   R9,SETTMODE        Do the Key 0 stuff\n         BAL   R9,CHANGED         Tell em we changed the values.\n         B     EOJ0\n** ---------------------------------------------------------------- **\n* ----------------------------------------------------------------- *\n*     Various \"abnormal ending\" routines.                           *\n* ----------------------------------------------------------------- *\nNOTAUTH  DS    0H                     Command not authorized message.\n         APUT  MESSAG2C,L'MESSAG2C\n         APUT  MESSAG2D,L'MESSAG2D\n         B     EOJC\n* ----------------------------------------------------------------- *\nNOE2     DS    0H                 No Parmlib-supplied table there.\n         MVC   LINE,LINE-1\n         MVC   LINE(L'MESSAGEP),MESSAGEP\n         MVC   LINE+20(2),=C'E2'\n         APUT  LINE,L'MESSAGEP\n         B     EOJ4\n* ----------------------------------------------------------------- *\nNOE8     DS    0H                 No Parmlib-supplied table there.\n         MVC   LINE,LINE-1\n         MVC   LINE(L'MESSAGEP),MESSAGEP\n         MVC   LINE+20(2),=C'E8'\n         APUT  LINE,L'MESSAGEP\n         B     EOJ4\n* ----------------------------------------------------------------- *\nNOAP     DS    0H                 No Parmlib-supplied table there.\n         MVC   LINE,LINE-1\n         MVC   LINE(L'MESSAGEP),MESSAGEP\n         MVC   LINE+20(2),=C'AP'\n         APUT  LINE,L'MESSAGEP\n         B     EOJ4\n* ----------------------------------------------------------------- *\nNONS     DS    0H                 No Parmlib-supplied table there.\n         MVC   LINE,LINE-1\n         MVC   LINE(L'MESSAGEP),MESSAGEP\n         MVC   LINE+20(2),=C'NS'\n         APUT  LINE,L'MESSAGEP\n         B     EOJ4\n* ----------------------------------------------------------------- *\nNOTNUMER DS    0H                 Message that a parm was not numeric\n         MVC   LINE,LINE-1\n         MVC   LINE(L'MESSAGEN),MESSAGEN\n         MVC   LINE+21(1),0(R4)\n         APUT  LINE,L'MESSAGEN\n         B     EOJ4\n** ---------------------------------------------------------------- **\n**    Some of the Register and Pointer Save Areas                   **\n** ---------------------------------------------------------------- **\nSAVEPARM DC    F'0'                   Parm address from R1 at entry\nSAVETPVT DC    F'0'                   Address of TPVT control block\nSAVECTLT DC    F'0'                   Address of CTLT control block\nSAVEFCVE DC    F'0'                   Address of Platcmd table if non-0\nSAVEPPVE DC    F'0'                   Address of Platpgm table if non-0\nSAVEUPT  DC    F'0'                   Address of UPT\nSAVEECT  DC    F'0'                   Address of ECT\nSAVEPSCB DC    F'0'                   Address of PSCB\nSAVETNS  DC    F'0'                   Address of NS table\nSAVETE2  DC    F'0'                   Address of E2 table\nSAVETE8  DC    F'0'                   Address of E8 table\nSAVETAP  DC    F'0'                   Address of AP table\nSAVETNSL DC    H'0'                   Length of NS table, if nonzero\nSAVETE2L DC    H'0'                   Length of E2 table, if nonzero\nSAVETE8L DC    H'0'                   Length of E8 table, if nonzero\nSAVETAPL DC    H'0'                   Length of AP table, if nonzero\nSAVETCUR DC    H'0'                   Copied length of current table\nSAVETNEW DC    H'0'                   Changed length of current table\n** ---------------------------------------------------------------- **\nFULLZERO DC    F'0'                   Fullword of numeric 0\nFULLFOUR DC    F'4'                   Fullword 4\nFULLEIGT DC    F'8'                   Fullowrd 8\nFULLTWLV DC    F'12'                  Fullword 12\nSAVE1401 DC    5F'0'                  More for safety\nLWAADDR  DC    F'0'                   Address of LWA control block\n* - - - - - - - - - - - - - - - - - - - - - - - - *\nMOVOUTL  MVC   TABCODE(*-*),0(R1)     EXECUTED\nMOVFSTN  MVC   FSTNAME(*-*),0(R3)     EXECUTED\nMOVSNDN  MVC   SNDNAME(*-*),0(R1)     EXECUTED\nMOVFNUM  MVC   FSTNUME(*-*),0(R3)     EXECUTED\nPACK     PACK  WORKA,0(0,3)          <<< EXECUTED >>>\n** ---------------------------------------------------------------- **\n*          * - - - - - - - - - - - - - - - - - - - - - - - - *\n*          *            S U B R O U T I N E S                *\n*          * - - - - - - - - - - - - - - - - - - - - - - - - *\n** ---------------------------------------------------------------- **\n**  These are executed using a BAL R9,subroutn  instruction.        **\n** ---------------------------------------------------------------- **\nHEX      DS    0H\n         ST    R9,SAVER9A\n         MVC   1(1,R15),0(R1)        Move byte\n         UNPK  0(3,R15),1(2,R15)     Unpack\n         TR    0(2,R15),HEXTAB-240\n         LA    R15,2(,R15)           Increment output pointer\n         LA    R1,1(,R1)             Increment input pointer\n         BCT   R0,HEX                Decrement length, then loop\n         MVI   0(R15),C' '           Blank the trailing byte\n         L     R9,SAVER9A\n         BR    R9                    Return to caller\nHEXTAB   DC    C'0123456789ABCDEF'   Translate table\nHEXSAVE  DS    3F                    Register save for HEX macro\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nGETNAMES DS    0H                  Get program name from parm.\n         ST    R9,SAVER9B          Save BAL register\n         ST    R2,SAVER2D          Save work register\nGETNAMST DS    0H                  Get rid of leading blanks\n         L     R1,CHARCONT         Point to start of character\n         CLI   0(R1),X'40'         Is it a blank?\n         BNE   GETNAMNZ            No. Get the entire name.\n         LA    R1,1(,R1)           Yes. Bump start place one up.\n         ST    R1,CHARCONT         And store the place away for now.\n         C     R5,=F'1'            End of cmd buffer one away?\n         BNH   EOJ4                Yes. Error.\n         BCTR  R5,0                Subtract one from end count\n         B     GETNAMST            And loop to find first non-blank.\nGETNAMNZ DS    0H                  Got first non-blank. Get whole name.\n         LA    R2,8                BCT initial quantity - 8 chars.\n         LA    R8,0                Character count\n         L     R1,CHARCONT         Load starting place\n         LR    R4,R1               Initialize pointer\n         LA    R4,0(,R4)           to first character of program name.\nGETNAMLU DS    0H                  Loop to get entire name\n         CLI   0(R4),X'40'         First blank?\n         BE    GETNAMGT            Yes, got whole name.\n         CLI   0(R4),X'00'         First hex zeros?\n         BE    GETNAMGT            Yes, got whole name.\n         CR    R8,R5               End of command buffer?\n         BNL   GETNAMGT            Yes. Got all we can get.\n         LA    R8,1(,R8)           Bump character counter.\n         LA    R4,1(,R4)           Bump where we are.\n         BCT   R2,GETNAMLU         Loop back.\nGETNAMGT DS    0H\n         ST    R8,SAVER8A          Save character count\n         ST    R8,FSTCOUNT         Again.\n         CLC   SAVER8A,=F'0'       Is character count (left) 0?\n         BNE   GETREALY            No. Go on processing for name.\n         BAL   R9,MISSPGM2         Say we're missing a program name.\n         B     EOJ4                And get out with code = 4.\nGETREALY DS    0H\n         MVC   FSTCHALF(2),FSTCOUNT+2    Get halfword program length\n         MVC   LINE,LINE-1               Print it in message\n         HEX   LINE,4,SAVER8A\n         MVC   LINE+13(17),=C'Length of command'\n         APUT  LINE,30\n         L     R3,CHARCONT         Load starting place again.\n         BCTR  R8,0                One less for EXECUTE.\n         MVC   FSTNAME(8),BLANKS   Blank entire target field.\n         EX    R8,MOVFSTN          Move program name to target.\n         OC    FSTNAME(8),BLANKS   Uppercase the program name.\n         MVC   LINE,LINE-1         And print its name out.\n         MVC   LINE(8),FSTNAME\n         MVC   LINE+13(17),=C'New program name '\n         APUT  LINE,30\n* - >\nGETNAMEN DS    0H                  Exit this routine.\n         L     R2,SAVER2D          Restore work register\n         L     R9,SAVER9B          Restore BAL register\n         BR    R9\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nCHANGED  DS    0H                     The \"value was changed\" message.\n         ST    R9,SAVER9C\n         TM    LPAFLAG,X'01'          Is the table within LPA?\n         BO    CHANGEND               Yes. Change already shown.\n         TM    FLAGZ,X'02'            Is parm number past end of table?\n         BO    CHANGEDN               Yes. Bypass all operations here.\n         TM    OFFFLAG,X'01'          Replacement?\n         BO    CHANGEDA               Say what was replaced\n         TM    OFFFLAG,X'02'          Blanking?\n         BO    CHANGEDB               Say what was blanked\n         TM    OFFFLAG,X'04'          Display?\n         BO    CHANGEDD               Skip saying anything was changed.\n         TM    OFFFLAG,X'08'          Change header to \" PARMLIB\"?\n         BO    CHANGEDH               Write message that its done.\n         TM    OFFFLAG,X'10'          Supply lengths in LWA?\n         BO    CHANGEDK               Write appropriate messages.\n         TM    OFFFLAG,X'20'          Zero lengths in LWA?\n         BO    CHANGEDZ               Write appropriate messages.\n         TM    OFFFLAG1,X'10'         Nullifying a table entry?\n         BO    CHANGENU               Write appropriate messages.\n*                                     X'40' dealt with in SETSTEPL\n*                                     X'80' dealt with in NOTSTEPL\n         B     CHANGEND\nCHANGEDA DS    0H                     Replacing a table entry.\n         MVC   LINE,LINE-1\n         APUT  LINE,30\n         APUT  MESSAGEC,L'MESSAGEC    Say \"before making changes\".\n         MVC   MESSAG3A+5(4),TABENNUM+6\n         MVC   MESSAG3A+13(2),CODEPLAC     Move in table code.\n         MVC   MESSAG3A+42(8),FSTNAME      Move in program name.\n         APUT  MESSAG3A,L'MESSAG3A    Tell em we changed the value.\n         B     CHANGEND\nCHANGEDB DS    0H                     Blanking a table entry.\n         MVC   LINE,LINE-1\n         APUT  LINE,30\n         APUT  MESSAGEC,L'MESSAGEC    Say \"before making changes\".\n         MVC   MESSAG3B+5(4),TABENNUM+6\n         MVC   MESSAG3B+13(2),CODEPLAC     Move in table code.\n         MVC   MESSAG3B+42(8),FSTNAME      Move in program name.\n         APUT  MESSAG3B,L'MESSAG3B    Tell em we changed the value.\n         B     CHANGEND\nCHANGENU DS    0H                     Blanking a table entry.\n         MVC   LINE,LINE-1\n         APUT  LINE,30\n         APUT  MESSAGEC,L'MESSAGEC    Say \"before making changes\".\n         MVC   MESSAG3G+5(4),TABENNUM+6\n         MVC   MESSAG3G+13(2),CODEPLAC     Move in table code.\n         MVC   MESSAG3G+42(8),FSTNAME      Move in program name.\n         APUT  MESSAG3G,L'MESSAG3G    Tell em we changed the value.\n         B     CHANGEND\nCHANGEDD DS    0H                     Displaying table entries (entry)\n         TM    OFFFLAG,X'04'\n         BZ    CHANGEDX               Not display? Say what's in slot.\n         CLC   SLOTBIN,=F'0'          Display entire table?\n         BE    CHANGEND               Don't say anything changed.\nCHANGEDX DS    0H                     Say we're displaying 1 slot.\n         MVC   LINE,LINE-1\n         MVC   LINE(30),=C'Display of Slot contents.     '\n         APUT  LINE,30\n         B     CHANGEND\nCHANGEDN DS    0H                     Say nothing changed.\n         APUT  MESSAG2D,L'MESSAG2D\n         B     CHANGEND\nCHANGEDH DS    0H                 Putting \" PARMLIB\" in table header.\n         TM    TIDFLAG,X'03'      Dealing with PC or PP?\n         BNZ   CHANGEDN           Yes. Show nothing was changed.\n         MVC   LINE,LINE-1\n         APUT  LINE,30\n         APUT  MESSAGEC,L'MESSAGEC       Say \"before making changes\".\n         APUT  MESSAG3D,L'MESSAG3D\n         BAL   R9,PRTABLHD        Table Header Display Routine\n         B     CHANGEND\nCHANGEDK DS    0H                 \"Supply table lengths\" message.\n         TM    TIDFLAG,X'03'      Dealing with PC or PP?\n         BNZ   CHANGEDN           Yes. Show nothing was changed.\n         MVC   LINE,LINE-1               Print a blank line.\n         APUT  LINE,30\n         APUT  MESSAGEC,L'MESSAGEC       Say \"before making changes\".\n         MVC   MESSAG3E+19(2),TABLEID    Put table id into message.\n         HEX   MESSAG3E+48,2,SAVETCUR    Old message length\n         CLC   TABLEID,=C'NS'            Is it the NS table?\n         BE    CHANGK01\n         HEX   MESSAG3E+60,2,SAVETNEW    8-byte table length\n         B     CHANGK02\nCHANGK01 DS    0H\n         TM    SHBLFLG,X'01'\n         BO    CHANGKA1\n         HEX   MESSAG3E+60,2,TO10LENG    10-byte table length\n         B     CHANGK02\nCHANGKA1 DS    0H\n         HEX   MESSAG3E+60,2,ME10LENG    10-byte table length\nCHANGK02 DS    0H\n         MVI   MESSAG3E+64,C'.'          Finish \"table length\" message.\n         APUT  MESSAG3E,L'MESSAG3E\n*                                        Message after change.\n         MVC   MESSAG1A+6(2),CODEPLAC    Move in table code.\n         HEX   MESSAG1A+57,2,SAVETNEW    New message length\n         MVI   MESSAG1A+61,C'.'          Put period at end.\n         APUT  MESSAG1A,L'MESSAG1A\n         B     CHANGEND\nCHANGEDZ DS    0H                 Zeroing table lengths in the LWA.\n         TM    TIDFLAG,X'03'      Dealing with PC or PP?\n         BNZ   CHANGEDN           Yes. Show nothing was changed.\n         MVC   LINE,LINE-1\n         APUT  LINE,30\n         APUT  MESSAGEC,L'MESSAGEC       Say \"before making changes\"\n         MVC   MESSAG3F+19(2),TABLEID\n         HEX   MESSAG3F+33,2,SAVETNEW\n         MVI   MESSAG3F+37,C'.'\n         APUT  MESSAG3F,L'MESSAG3F\n         MVC   MESSAG1B+6(2),CODEPLAC    Move in table code.\n         APUT  MESSAG1B,L'MESSAG1B\n         B     CHANGEND\nCHANGEND DS    0H\n         L     R9,SAVER9C\n         BR    R9\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nNAMEPARM DS    0H\n         ST    R9,SAVER9D\n         TM    LPADFLG,X'01'          Displaying LPA range?\n         BO    NAMEPEND               Don't look for a number here.\n*-*\n         TM    OFFFLAG,X'08'          Just changing table header?\n         BO    NAMEPEND               Yes. Then don't look for number.\n*-*\n*-*-*\n         TM    OFFFLAG,X'10'          Supply table length in LWA.\n         BO    NAMEPEND               Yes. Then don't look for number.\n*-*-*\n*-*-*-*\n         TM    OFFFLAG,X'20'          Zero table length in LWA.\n         BO    NAMEPEND               Yes. Then don't look for number.\n*-*-*-*\n*-*-*-*-*\n         TM    OFFFLAG,X'40'          Set on STEPLIB flag for table?\n         BO    NAMEPEND               Yes. Then don't look for number.\n*-*-*-*-*\n*-*-*-*-*-*\n         TM    OFFFLAG,X'80'          Set off STEPLIB flag for table?\n         BO    NAMEPEND               Yes. Then don't look for number.\n*-*-*-*-*-*\n         L     R8,SAVER8A             Get number of characters used\n         CR    R8,R5                  More than what's left?\n         BNL   NAMEBAD1               Yes. Error.\n         C     R5,=F'3'               Is end bigger than 3?\n         BNH   NAMEBAD1               No. Error.\nNAMEGOOD DS    0H\n         S     R5,=F'3'               Subtract 3 from number till end.\n         BAL   R9,GETNUMES            Get the number of the pgm entry.\n         TM    OFFFLAG,X'02'          Are we blanking?\n         BO    NAMEPEND               Yes. Don't need a name parameter\n         TM    OFFFLAG,X'04'          Displaying?\n         BO    NAMEPEND               Yes. No names wanted.\n         TM    OFFFLAG1,X'10'         Nullifying an entry?\n         BO    NAMEPEND               Yes. No names needed.\n         BAL   R9,GETNAMES            Get the name of pgm to shove in.\n         B     NAMEPEND\nNAMEBAD1 DS    0H                     Get here if there's no parameter.\n         TM    OFFFLAG,X'04'          Are we displaying?\n         BO    NAMEPEND               No error. Just get out normally.\n         TM    OFFFLAG,X'02'\n         BO    NAMEBAD2\n         BAL   R9,MISSPGM1            We're replacing. Ask for both.\n         B     EOJ4                   RC = 4\nNAMEBAD2 DS    0H\n         BAL   R9,MISSPGM3\n         B     EOJ4                   RC = 4\nNAMEPEND DS    0H\n         L     R9,SAVER9D\n         BR    R9\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nADJNEXTP DS    0H                     Get to first blank\n         ST    R9,SAVER9E\n         MVC   CHARSTRT,CHARCONT      Set up\n         L     R1,CHARSTRT\nSEEIFENX DS    0H                     Loop\n         CLI   0(R1),X'40'            First blank?\n         BE    SEEIFENZ               Yes, then end.\n         LA    R1,1(,R1)              Bump to next character\n         ST    R1,CHARSTRT            Store address away\n         B     SEEIFENX               Loop back\nSEEIFENZ DS    0H\n         L     R9,SAVER9E\n         BR    R9\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n         LTORG\n************************************************************\nPGMTITLE DS    0H                     Display program name\n         ST    R9,SAVER9F\n         MVC   LINE,LINE-1            Blank line\n         MVC   LINE,MESSAGET          Move title line in\n         MVC   LINE+56(8),VERS#       Version number into title\n         APUT  LINE,L'MESSAGET        And put out to tube\n         MVC   LINE,LINE-1            Blank line again\n         MVC   LINE,MESSAGEU          Move underlines in\n         APUT  LINE,L'MESSAGEU        And put them out also\n         L     R9,SAVER9F\n         BR    R9                     Return to caller\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nSETTMODE DS    0H                  Routine that does Key 0 stuff.\n         ST    R9,SAVER9G\n         TM    FLAGZ,X'02'         Is parm number past end of table?\n         BO    SETTMEND            Yes. Don't do key zero operations.\n         TM    LPAFLAG,X'01'       Is the table in LPA region?\n         BO    SETTMEND            Yes. Do not attempt to change it.\n* -- >       Test if this command is being run APF Authorized\n         AIF   ('&SVC' EQ 'SVC').DOSVC\n         STM   R15,R1,SAVE1401     Now save registers and test if APF\n         XR    R15,R15                  authorized.\n         TESTAUTH FCTN=1           Are we authorized?\n         LTR   R15,R15             Test the return code.\n         BNZ   NOTAUTH             Not zero, tell not authorized.\n         LM    R15,R1,SAVE1401     Restore registers used by TESTAUTH.\n.DOSVC   ANOP\n* -- >\n         AIF   ('&SVC' EQ 'NOSVC').NOSVC02\n         AUTHON\n.NOSVC02 ANOP\n* -- >      Key Zero ---- Here's where we change the stuff.\nKZ       MODESET KEY=ZERO\n* -\n         TM    OFFFLAG,X'04'       Only displaying entr(ies)?\n         BNZ   ENDKZ               Yes. No Key 0 stuff done.\n         CLI   LPAFLAG,X'01'       Did the table come from LPALIB?\n         BE    ENDKZ               Yes. Don't try to alter table.\n         TM    NSCHFLG,X'01'       Are we doing the NS table?\n         BO    TENSLOT             Yes. Handle its special needs.\nEIGHSLOT DS    0H                  8-character tables.\n*-*                                Altering table header only\n         TM    OFFFLAG,X'08'       Alter table header?\n         BZ    GONOHDRA            No. Escape this section.\n         TM    TIDFLAG,X'03'       Dealing with PC or PP?\n         BNZ   GONOHDRA            Yes. Show nothing was changed.\n         L     R3,HDRADDR          Load header address\n         MVC   8(8,R3),=C' PARMLIB'  Move in standard table header.\n         B     ENDKZ               Get out of supervisor state.\nGONOHDRA DS    0H\n*-*\n*-*-*\n         TM    OFFFLAG,X'30'       Supplying length to LWA field?\n         BZ    GONZLWA1            No. Don't do this routine.\n         BAL   R9,MEASUR08         Measure it.\n         BAL   R9,WHERSIZE         Load size into proper place in LWA.\n         B     ENDKZ               Get out of supervisor state.\nGONZLWA1 DS    0H\n*-*-*\n*-*-*-*-*\n         TM    OFFFLAG,X'40'       Set STEPLIB flag in LWA for table?\n         BZ    NOGSTEP1            No. Skip step.\n         BAL   R9,SETSTEPL         Set the STEPLIB flag on.\n         B     ENDKZ               Get out of supervisor state.\nNOGSTEP1 DS    0H\n*-*-*-*-*\n*-*-*-*-*-*\n         TM    OFFFLAG,X'80'       STEPLIB flag off in LWA for table?\n         BZ    NOGSTOF1            No. Skip step.\n         BAL   R9,NOTSTEPL         Set the STEPLIB flag off.\n         B     ENDKZ               Get out of supervisor state.\nNOGSTOF1 DS    0H\n*-*-*-*-*-*\n         L     R3,OURSLOT          Address of slot to replace name in.\n         TM    OFFFLAG,X'01'       Replacing function here?\n         BZ    BLANKIT             No. Do blanking function.\n         CLC   FSTNAME,BLANKS      Yes. Is new entry non-blank?\n         BE    ENDKZ               No. It is blank. Nothing to do.\n         MVC   0(8,R3),FSTNAME     Non-blank. Move in new pgm name.\n         B     ENDKZ               And get out.\nBLANKIT  DS    0H                  Blank an 8-character table entry\n         TM    OFFFLAG,X'02'       Blanking function here?\n         BZ    NULLIT              No. Try the next possibility.\n         L     R3,OURSLOT          Address of slot entry to blank\n         MVC   0(8,R3),BLANKS      Move the blanks in.\n         B     ENDKZ               And get out.\nNULLIT   DS    0H                  Nullify an entry by inserting ?.\n         TM    OFFFLAG1,X'10'      Nullifying function here?\n         BZ    ENDKZ               No. Can't do anything.\n         L     R3,OURSLOT          Yes. Load current slot number.\n         MVC   0(8,R3),QUEST08     Change it to C'?       '\n         B     ENDKZ               And get out.\nTENSLOT  DS    0H                  10-character tables.\n         L     R3,OURSLOT          Address of slot to replace name in.\n         TM    OFFFLAG,X'01'       Replacing function here?\n         BZ    BLANKTEN            No. Do blanking function.\n         CLC   FSTNAME,BLANKS      Yes. Is new entry non-blank?\n         BE    ENDKZ               No. It is blank. Nothing to do.\n         MVC   0(2,R3),FSTCHALF    Put length of the new program name.\n         MVC   2(8,R3),FSTNAME     Put in the new program name.\n         B     ENDKZ               Get out of supervisor state.\nBLANKTEN DS    0H                  Blank the 10-character table entry\n*-*                                Altering table header only\n         TM    OFFFLAG,X'08'       Alter table header?\n         BZ    GONOHDRB            No. Escape this section.\n         TM    TIDFLAG,X'03'       Dealing with PC or PP?\n         BNZ   GONOHDRB            Yes. Show nothing was changed.\n         L     R3,HDRADDR          Load header address\n         MVC   8(8,R3),=C' PARMLIB'  Move in standard table header.\n         B     ENDKZ               Get out of supervisor state.\nGONOHDRB DS    0H\n*-*\n*-*-*\n         TM    OFFFLAG,X'30'       Supplying length to LWA field?\n         BZ    GONZLWA2            No. Don't do this routine.\n         BAL   R9,MEASUR10         Measure it.\n         BAL   R9,WHERSIZE         Load size into proper place in LWA.\n         B     ENDKZ               Get out of supervisor state.\nGONZLWA2 DS    0H\n*-*-*\n*-*-*-*-*\n         TM    OFFFLAG,X'40'       Set STEPLIB flag in LWA for table?\n         BZ    NOGSTEP2            No. Skip step.\n         BAL   R9,SETSTEPL         Set the STEPLIB flag.\n         B     ENDKZ               Get out of supervisor state.\nNOGSTEP2 DS    0H\n*-*-*-*-*\n*-*-*-*-*-*\n         TM    OFFFLAG,X'80'       STEPLIB flag off in LWA for table?\n         BZ    NOGSTOF2            No. Skip step.\n         BAL   R9,NOTSTEPL         Set the STEPLIB flag off.\n         B     ENDKZ               Get out of supervisor state.\nNOGSTOF2 DS    0H\n*-*-*-*-*-*\n         TM    OFFFLAG,X'02'       Blanking function here?\n         BZ    NULLTEN             No. Can't do anything.\n         L     R3,OURSLOT          Address of slot entry to blank.\n         MVC   0(2,R3),=X'0000'    Move X'FFFF' to mark table end\n         MVC   2(8,R3),BLANKS      And move the blanks to pgm name slot\n         B     ENDKZ               Get out of supervisor state.\nNULLTEN  DS    0H\n         TM    OFFFLAG1,X'10'      Slot nullify function here?\n         BZ    ENDKZ               No. No action here.\n         L     R3,OURSLOT          Yes. Point to current slot in table\n         MVC   0(2,R3),=X'0001'    This is NS, so insert length.\n         MVC   2(8,R3),QUEST08     Insert Question Mark.\n         B     ENDKZ\nENDKZ    DS    0H                  Get ready to get out of Key 0.\n* -\nNZ       MODESET KEY=NZERO\n         AIF   ('&SVC' EQ 'NOSVC').NOSVC03\n         AUTHOFF\n.NOSVC03 ANOP\n* -- >      Back to ordinary life ----\nSETTMEND DS    0H                  Bypass Key 0 stuff.\n         L     R9,SAVER9G\n         BR    R9                  Return to caller\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nERRORCOD DS    0H                  Give instructions if wrong things\n*                                   were entered, how to do it right.\n         ST    R9,SAVER9H\n         TM    LPADFLG,X'01'\n         BO    ERRORCOE\n         MVC   LINE,LINE-1\n         APUT  LINE,30\n         APUT  MESSA11L,L'MESSA11L\n         APUT  MESSA11M,L'MESSA11M\n         APUT  MESSA11P,L'MESSA11P\n         APUT  MESSA11A,L'MESSA11A\n         MVC   LINE,LINE-1\n         APUT  LINE,30\n         APUT  MESSA11C,L'MESSA11C\n         APUT  MESSA11D,L'MESSA11D\n         APUT  MESSA11Z,L'MESSA11Z\n         APUT  MESSA11Y,L'MESSA11Y\n         APUT  MESSA11X,L'MESSA11X\n         APUT  MESSA11W,L'MESSA11W\n         APUT  MESSA11F,L'MESSA11F\n         MVC   LINE,LINE-1\n         APUT  LINE,30\n         APUT  MESSA11I,L'MESSA11I\n         APUT  MESSA11K,L'MESSA11K\n         APUT  MESSA11J,L'MESSA11J\n         APUT  MESSA11N,L'MESSA11N\n         APUT  MESSA11R,L'MESSA11R\n         APUT  MESSA11Q,L'MESSA11Q\n         APUT  MESSA11O,L'MESSA11O\n*        MVC   LINE,LINE-1\n*        APUT  LINE,30\nERRORCOE DS    0H\n         L     R9,SAVER9H\n         BR    R9                     Return to caller\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nMISSPGM1 DS    0H                     Supply a slot number & pgm name.\n         ST    R9,SAVER9I\n         MVC   LINE,LINE-1\n         APUT  MESSA11G,L'MESSA11G\n         L     R9,SAVER9I\n         BR    R9                     Return to caller\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nMISSPGM2 DS    0H                     Supply a program name to put in.\n         ST    R9,SAVER9J\n         MVC   LINE,LINE-1\n         APUT  MESSA11E,L'MESSA11E\n         L     R9,SAVER9J\n         BR    R9                     Return to caller\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nMISSPGM3 DS    0H                     Supply a slot number to Blank.\n         ST    R9,SAVER9N\n         MVC   LINE,LINE-1\n         APUT  MESSA12Q,L'MESSA12Q\n         L     R9,SAVER9N\n         BR    R9                     Return to caller\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nDISPTABL DS    0H                Scan thru the particular table....\n         ST    R9,SAVER9L          Save BAL register\n         ST    R3,SAVER3A          Save\n         ST    R4,SAVER4A             the\n         ST    R5,SAVER5A                work\n         ST    R2,SAVER2G                   registers.\n*-*\n         TM    OFFFLAG,X'08'     Just altering table header?\n         BO    DISPTSKP          Yes. Don't display table at all.\n*-*\n*-*-*\n         TM    OFFFLAG,X'10'     Just supplying an LWA size?\n         BO    DISPTSKP          Yes. Don't display table at all.\n*-*-*\n*-*-*-*\n         TM    OFFFLAG,X'20'     Zeroing out LWA size?\n         BO    DISPTSKP          Yes. Don't display table at all.\n*-*-*-*\n*-*-*-*-*\n         TM    OFFFLAG,X'40'     Setting table to come from STEPLIB?\n         BO    DISPTSKP          Yes. Don't display table at all.\n*-*-*-*-*\n*-*-*-*-*-*\n         TM    OFFFLAG,X'80'     Setting table not from STEPLIB?\n         BO    DISPTSKP          Yes. Don't display table at all.\n*-*-*-*-*-*\n         XR    R3,R3               Zero\n         XR    R5,R5                  work\n         XR    R2,R2                     registers.\nDISPTSTR DS    0H\n         L     R3,TABLSTRT         Load start address of table\n         L     R2,TABLENUM         Load number of entries in table\n         L     R5,TABLESIZ         Load size of each entry\n         LA    R4,1                Start slot number count at 1\n         ST    R4,SLOTNOW          Store slot number count away\n         ST    R3,OURSLOT          Initialize slot address.\n         CLC   SLOTBIN,=F'0'       If there's no slot num in parameter\n         BE    DISPTLUP            Then bypass error checking\n         C     R2,SLOTBIN          Compare table size to parm number\n         BNL   DISPTLUP            If parm number is LE, then display\nDISPTERR DS    0H                  Else error message and out.\n         MVC   LINE,LINE-1\n         MVC   LINE(22),=C'Slot number specified '\n         L     R1,SLOTBIN          Display field\n         CVD   R1,CVDAREA          Convert count to printable\n         MVC   LINE+22(10),MASK10  Move in the mask\n         ED    LINE+22(10),CVDAREA+3 Make it pretty\n         MVC   LINE+34(26),=C'is bigger than table size '\n         L     R1,TABLENUM         Display field\n         CVD   R1,CVDAREA          Convert count to printable\n         MVC   LINE+60(10),MASK10  Move in the mask\n         ED    LINE+60(10),CVDAREA+3 Make it pretty\n         APUT  LINE,72\n         B     EOJ4\nDISPTLUP DS    0H                  Loop thru the table entries.\n         MVC   LINE,LINE-1\n         MVC   LINE(2),CODEPLAC    Move in table code.\n         MVC   LINE+3(19),=C'Table Entry Number:'\n         CVD   R4,CVDAREA          Convert count to printable\n         MVC   LINE+22(10),MASK10  Move in the mask\n         ED    LINE+22(10),CVDAREA+3 Make it pretty\n         MVC   TABENNUM(10),MASK10      Preserve printable slot number\n         ED    TABENNUM(10),CVDAREA+3\n         TM    NSCHFLG,X'01'       Is this the 10-byte NS table entry?\n         BO    DISPTBNS            Yes. Handle separately.\n         MVC   LINE+34(8),0(R3)\n         CLC   LINE+34(8),BLANKS   Is this a blank entry.\n         BNE   DISPTBLK            No.\n         MVC   LINE+34(8),=C'*empty* '   Yes. Don't just show blanks.\n         OI    FLAGZ,X'01'         We found a blank table entry.\n         TM    FLAGZ,X'04'         Do we have table lengths?\n         BO    DISPTBLK            Yes, then use the table lengths\n* -------                           that we have.\n*                                  No table lengths here. So....\n         ST    R3,OURSLOT          Preserve empty slot address\n         ST    R4,SLOTNOW          Also preserve this slot number.\n         B     DISPTYES            And then stop on first blank.\nDISPTBNS DS    0H\n         HEX   LINE+34,2,0(R3)     Display size of this entry\n         MVC   LINE+40(8),2(R3)    Move in program name to slot\n         CLC   LINE+40(8),BLANKS   Is this a blank entry.\n         BNE   DISPTBLK            No.\n         MVC   LINE+40(8),=C'*empty* '   Yes. Don't just show blanks.\n         OI    FLAGZ,X'01'         We found a blank table entry.\n         TM    FLAGZ,X'04'         Do we have table lengths?\n         BO    DISPTBLK            Yes, then use the table lengths\n* -------                           that we have.\n*                                  No table lengths here. So....\n         ST    R3,OURSLOT          Preserve empty slot address\n         ST    R4,SLOTNOW          Also preserve this slot number.\n         B     DISPTYES            And then stop on first blank.\nDISPTBLK DS    0H                  Search each slot number.\n         CLC   SLOTBIN,=F'0'       Has a slot number been specified?\n         BE    DISPTYES            No. Just display all the slots.\n         CLC   SLOTBIN,SLOTNOW     Yes. Then are we at the one we want?\n         BNE   DISPTNOT            No. Just go further and search.\n         OI    FLAGZ,X'08'         We're at the desired slot.\n* ---  Save contents of the current slot which was found - below\n         ST    R3,OURSLOT          Preserve this slot's address\n         LR    R1,R5               Load table entry size\n         BCTR  R1,0                One less for execute\n         EX    R1,MOVESLOT         Save contents of slot for kicks\n         B     DISPTPEX               Branch past executed instruction\nMOVESLOT MVC   SLOTSAVE(*-*),0(R3)    EXECUTED\nDISPTPEX DS    0H\n* ---  Save contents of the current slot which was found - above\nDISPTYES DS    0H                  Print this slot entry\n         APUT  LINE,52\n         TM    FLAGZ,X'01'         Is this a blank table entry?\n         BO    DISPTEND            Yes, end the table search.\n         TM    FLAGZ,X'08'         Are we at the slot # we specified?\n         BO    DISPTEND            Yes. Stop the search.\nDISPTNOT DS    0H                  Bump to next slot and loop back.\n         C     R3,TABLEND          Compare to end from adding bytes.\n         BH    DISPTEND            Past it, then end the search.\n         LA    R3,0(R5,R3)         Bump to next slot\n         ST    R3,OURSLOT          Store its address - important....\n         LA    R4,1(,R4)           Bump count of slot number\n         ST    R4,SLOTNOW          Store new slot number away\n         ST    R2,SAVER2E\n         BCT   R2,DISPTLUP         And loop to examine the new slot.\n*\nDISPTEND DS    0H                  END OF TABLE SEARCH ROUTINE\n* - >                              Display message if desired slot is\n* - >                               past the end of the table.\n         CLC   SLOTBIN,SLOTNOW     Is the parm number past the end?\n         BNH   DISPTNOP            No. Don't report a problem.\n         L     R1,SLOTBIN          Display field\n         CVD   R1,CVDAREA          Convert count to printable\n         MVC   LINE+22(10),MASK10  Move in the mask\n         ED    LINE+22(10),CVDAREA+3 Make it pretty\n         MVC   LINE+34(26),=C'exceeds scanned table size'\n         L     R1,SLOTNOW          Display field\n         CVD   R1,CVDAREA          Convert count to printable\n         MVC   LINE+60(10),MASK10  Move in the mask\n         ED    LINE+60(10),CVDAREA+3 Make it pretty\n         APUT  LINE,72\n         OI    FLAGZ,X'02'         Flag a problem situation.\nDISPTNOP DS    0H\nDISPTSKP DS    0H\n* - >\n         L     R3,SAVER3A          Restore all the work registers.\n         L     R4,SAVER4A\n         L     R5,SAVER5A\n         L     R2,SAVER2G\n         L     R9,SAVER9L          Restore the BAL register.\n         BR    R9                  Return to caller\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nGETNUMES DS    0H                  Get the number after the table code\n         ST    R9,SAVER9M           + the action code. If it exists.\n         ST    R2,SAVER2F\nGETNUMST DS    0H                  Get rid of leading blanks\n         L     R1,CHARCONT         Point to start of character\n         CLI   0(R1),X'40'         Is it a blank?\n         BNE   GETNUMNZ            No. Get the entire name.\n         LA    R1,1(,R1)           Yes. Bump start place one up.\n         ST    R1,CHARCONT         And store the place away for now.\n         C     R5,=F'1'            End of cmd buffer one away?\n         BNH   EOJ4                Yes. Error.\n         S     R5,=F'1'            Subtract one from end count\n         B     GETNUMST            And loop to find first non-blank.\nGETNUMNZ DS    0H                  Got first non-blank. Get whole name.\n         LA    R2,5                BCT initial quantity - 5 chars.\n         LA    R8,0                Character count\n         L     R1,CHARCONT         Load starting place\n         LR    R4,R1               Initialize pointer\n         LA    R4,0(,R4)           to first character of program number\nGETNUMLU DS    0H                  Loop to get entire number\n         CLI   0(R4),X'40'         First blank?\n         BE    GETNUMGT            Yes, got whole number\n         CLI   0(R4),X'00'         First hex zeros?\n         BE    GETNUMGT            Yes, got whole number\n         CR    R8,R5               End of command buffer?\n         BNL   GETNUMGT            Yes. Got all we can get.\n* --                               Test EBCDIC number if numeric.\n         CLI   0(R4),X'F0'         Check character if numeric digit.\n         BL    NOTNUMER            Less than X'F0', not a number.\n         CLI   0(R4),X'F9'         More than X'F9'?\n         BH    NOTNUMER            Not a number.\n* --\n         LA    R8,1(,R8)           Bump character counter.\n         LA    R4,1(,R4)           Bump where we are.\n         BCT   R2,GETNUMLU         Loop back.\nGETNUMGT DS    0H                  Got the whole number - examine it.\n         ST    R8,SAVER8A\n         ST    R8,FSTNOUNT         Get halfword value of slot number\n         MVC   FSTNHALF(2),FSTNOUNT+2\n         L     R3,CHARCONT\n         BCTR  R8,0                One less for EXECUTE\n         MVC   FSTFIELD(8),BLANKS  5-char number plus 3 blanks\n         EX    R8,MOVFNUM          Get the number from the parm\n         EX    R8,PACK             Convert it to packed\n         CVB   R0,WORKA            Convert it to Binary\n         ST    R0,SLOTBIN          Store the value for later use\n         MVC   LINE,LINE-1\n         MVC   LINE(8),FSTFIELD    8-char number with blanks\n         MVC   LINE+13(19),=C'Entry slot number  '\n         APUT  LINE,32\n         LA    R8,1(,R8)           Restore number of chars after EX\n         ST    R8,CHARSIZE         Save this value off.\n         AR    R3,R8               Add it to R3 so we start past it.\n         ST    R3,CHARCONT         Store start value for next parm.\nGETNUMEN DS    0H\n         L     R2,SAVER2F\n         L     R9,SAVER9M\n         BR    R9\n* ----------------------------------------------------------------- *\n*      Measure \"8-byte entry\" loaded table.                         *\n* ----------------------------------------------------------------- *\n*      R5 contains the entry point of the table.                    *\n* ----------------------------------------------------------------- *\nMEASUR08 DS    0H                 R5 has beginning address of table.\n         ST    R9,SAVER9O           Save BAL register\n         ST    R5,SAVER5D           Save work register\n         ST    R4,SAVER4B           Save work register\n         L     R5,TABLADDR          Load start of table\n         XC    BLNKCNT,BLNKCNT      Zero the counters\n         XC    NTRYCNT,NTRYCNT\n         LA    R4,16                Count size of header\n         LA    R5,16(,R5)           Bump past header\nME08LOOP DS    0H\n*     Try (real hard) to detect the end of the table  -  below\n         MVC   SAVECHAR(1),0(R5)    Save first character\n         CLC   =C'        ',0(R5)   Is this table entry a blank?\n         BE    ME08BLNK             Yes. Reached virtual end of table\n         CLC   ZEROES8(8),0(R5)     Is this \"entry\" hex zeros?\n         BE    ME08NOBL             Yes. Reached possible junk storage\n         CLC   =C' ',0(R5)          Is first character blank?\n         BE    ME08NOBL             Yes, not a valid table entry.\n         TR    SAVECHAR,TRTPGMNM    Check first char if appropriate.\n         CLI   SAVECHAR,X'02'       Not. probably end of table.\n         BE    ME08NOBL\n         CLC   =C'IKJEFTE2',0(R5)\n         BE    ME08NOBL\n         CLC   =C'IKJEFTE8',0(R5)\n         BE    ME08NOBL\n         CLC   =C'IKJEFTAP',0(R5)\n         BE    ME08NOBL\n         CLC   =C'IKJEFTNS',0(R5)\n         BE    ME08NOBL\n*     Try (real hard) to detect the end of the table  -  above\n         LA    R4,8(,R4)            Count next table entry\n         LA    R5,8(,R5)            Bump to next entry\n         L     R1,NTRYCNT           Increment \"entry count\" counter\n         A     R1,=F'1'\n         ST    R1,NTRYCNT\n         B     ME08LOOP             Loop back till perceived table end\nME08BLNK DS    0H\n         LA    R4,8(,R4)            Add length of blank entry\n         LA    R5,8(,R5)            Bump past blank entry.\n         L     R1,BLNKCNT           Increment \"blank entry\" counter\n         A     R1,=F'1'\n         ST    R1,BLNKCNT\nME08NOBL DS    0H\n         STH   R4,ME08LENG          Store measured length of table.\n         ST    R5,ME08END           And record address of table end.\n         BAL   R9,MESBLK08          Measure more blanks after table.\n         TM    MEASFLG,X'01'        Been here already?\n         BO    ME08NOSH             Don't show count again.\n         BAL   R9,ENTRYDSP          Show number of entries.\nME08NOSH DS    0H\n         OI    MEASFLG,X'01'        Show we did this once.\n         L     R4,SAVER4B           Restore work register\n         L     R5,SAVER5D           Restore work register\n         L     R9,SAVER9O           Restore BAL register\n         BR    R9\nME08END  DS    F                    Store end-of-table address\nME08LENG DS    H                    Store table length\nBL08LENG DS    H                    Store length of blanks\nTO08LENG DS    H                    Store total, nonblank+blank\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nMESBLK08 DS    0H                   See how many more blanks we have.\n         ST    R9,SAVER9Y           Save BAL register\n         ST    R5,SAVER5E           Save work register\n         L     R5,ME08END           Start at measured end of table.\nMESBLL08 DS    0H                   Loop\n         CLC   =C'        ',0(R5)   Is this entry a blank?\n         BNE   MESBLE08             Yes. Stop counting blanks.\n         CLC   BLNKCNT,MAXBLANK     Have we exceeded the maximum guess?\n         BH    MESBLE08             Yes. Don't find more blanks.\n         L     R1,BLNKCNT           Increment \"blank entry\" counter\n         A     R1,=F'1'\n         ST    R1,BLNKCNT\n         LA    R5,8(,R5)            Bump to next entry.\n         B     MESBLL08             Loop until no blanks or max.\nMESBLE08 DS    0H\n         L     R1,BLNKCNT           Total count of found blanks\n         LTR   R1,R1\n         BZ    MESBLX08\n         BCTR  R1,0                 Really one less\nMESBLX08 DS    0H\n         SLL   R1,3                 Multiply by 8\n         STH   R1,BL08LENG          Length of blank entries\n         AH    R1,ME08LENG          Add length of non-blank entries\n         STH   R1,TO08LENG          Total length of both\n*>*----\n*        STM   R14,R1,SAVE1401      Save registers 14 thru 1.\n*        MVC   LINE,LINE-1\n*        HEX   LINE,2,ME08LENG\n*        HEX   LINE+10,2,BL08LENG\n*        HEX   LINE+20,2,TO08LENG\n*        APUT  LINE,30\n*        LM    R14,R1,SAVE1401      Load registers 14 thru 1.\n*>*----\n         L     R5,SAVER5E           Restore work register\n         L     R9,SAVER9Y           Restore BAL register\n         BR    R9\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n* ----------------------------------------------------------------- *\n*      Measure \"10-byte entry\" loaded table.                        *\n* ----------------------------------------------------------------- *\n*      R5 contains the entry point of the table.                    *\n* ----------------------------------------------------------------- *\nMEASUR10 DS    0H                 R5 has beginning address of table.\n         ST    R9,SAVER9P           Save BAL register\n         ST    R5,SAVER5D           Save work register\n         ST    R4,SAVER4B           Save work register\n         L     R5,TABLADDR          Load start of table\n         XC    BLNKCNT,BLNKCNT      Zero the counters\n         XC    NTRYCNT,NTRYCNT\n         LA    R4,16                Count size of header\n         LA    R5,16(,R5)           Bump past header\nME10LOOP DS    0H\n         MVC   SAVECHAR(1),2(R5)    Save first character of pgm name\n         MVC   SAVECH08(1),9(R5)    Save last character of pgm name\n         CLC   BLKSTRNG(10),0(R5)   Full blank entry here?\n         BE    ME10BLNK             Yes. Count the blank entry.\n         CLC   ENDSTRNG(10),0(R5)   FFFF plus blank pgm name?\n         BE    ME10BLNK             Yes. Can still be considered blank.\n         CLC   =X'0000',0(R5)       Test-test-test-test-test\n         BE    ME10TEST             Test rest of \"entry\n         B     ME10REST             Not zeros, go on.\nME10TEST DS    0H\n         TR    SAVECHAR,TRTPGMNM    Check for strange character.\n         CLI   SAVECHAR,X'02'       Is it strange?\n         BE    ME10NOBL             Yes. This is not a blank entry.\nME10REST DS    0H\n         CLC   =X'FFFF',0(R5)       Test for end string separately.\n         BNE   ME10TES2             Not. Not at virtual end of table\n         B     ME10NOBL             FFFF alone. Not a blank entry.\nME10TES2 DS    0H\n         TR    SAVECHAR,TRTPGMNM    Check first char not upcase alpha.\n         CLI   SAVECHAR,X'02'       Not. probably end of table.\n         BE    ME10NOBL\n         TR    SAVECH08,TRTPGMNM    Check last char not upcase alpha.\n         CLI   SAVECH08,X'02'       Not. probably end of table.\n         BE    ME10NOBL\n         LA    R4,10(,R4)           Count next table entry\n         LA    R5,10(,R5)           Bump to next entry\n         L     R1,NTRYCNT           Increment \"entry count\" counter\n         A     R1,=F'1'\n         ST    R1,NTRYCNT\n         B     ME10LOOP             Finished this entry, try for more.\nME10BLNK DS    0H\n         LA    R4,10(,R4)           Add length of blank entry\n         LA    R5,10(,R5)           Bump past blank entry.\n         L     R1,BLNKCNT           Increment \"blank entry\" counter\n         A     R1,=F'1'\n         ST    R1,BLNKCNT\nME10NOBL DS    0H\n         STH   R4,ME10LENG          Store measured length of table.\n         ST    R5,ME10END           And record address of table end.\n         BAL   R9,MESBLK10          Measure more blanks after table.\n         TM    MEASFLG,X'01'        Been here already?\n         BO    ME10NOSH             Don't show count again.\n         BAL   R9,ENTRYDSP          Show number of entries.\nME10NOSH DS    0H\n         OI    MEASFLG,X'01'        Show we did this once.\n         L     R4,SAVER4B           Restore work register\n         L     R5,SAVER5D           Restore work register\n         L     R9,SAVER9P           Restore BAL register\n         BR    R9\nME10END  DS    F                    Store end-of-table address\nME10LENG DS    H                    Store table length\nBL10LENG DS    H                    Store length of blanks\nTO10LENG DS    H                    Store total, nonblank+blank\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nMESBLK10 DS    0H                   See how many more blanks we have.\n         ST    R9,SAVER9Y           Save BAL register\n         ST    R5,SAVER5E           Save work register\n         L     R5,ME10END           Start at measured end of table.\nMESBLL10 DS    0H                   Loop\n         CLC   =C'        ',2(R5)   Is this entry a blank entry?\n         BNE   MESBLE10             No. End of perceived blanks.\n         CLC   =X'0000',0(R5)       Length is zero?\n         BNE   MESBLE10             No. End of perceived blanks.\n         CLC   =X'FFFF',0(R5)       Real table end?\n         BE    MESBLE10             Yes. Consider it end of table.\n         CLC   BLNKCNT,MAXBLANK     Have we exceeded the maximum guess?\n         BH    MESBLE10             Yes. Don't find more blanks.\n         L     R1,BLNKCNT           Increment \"blank entry\" counter\n         A     R1,=F'1'\n         ST    R1,BLNKCNT\n         LA    R5,10(,R5)           Bump to next entry.\n         B     MESBLL10             Loop until no blanks or max.\nMESBLE10 DS    0H\n         L     R1,BLNKCNT           Number of blank entries\n         LTR   R1,R1\n         BZ    MESBLX10\n         BCTR  R1,0                 Really one less\nMESBLX10 DS    0H\n         STM   R2,R3,SAVER23        Save work registers\n         XR    R2,R2                Clear R2\n         XR    R3,R3                Clear R3\n         LR    R3,R1                Dump count into R2 for mult.\n         M     R2,=F'10'            Multiply by entry size\n         STH   R3,BL10LENG          Store length of blank entries\n         AH    R3,ME10LENG          Add length of non-blank entries\n         STH   R3,TO10LENG          Total length of both\n         LM    R2,R3,SAVER23        Restore work registers\n*>*----\n*        STM   R14,R1,SAVE1401      Save registers 14 thru 1.\n*        MVC   LINE,LINE-1\n*        HEX   LINE,2,ME10LENG\n*        HEX   LINE+10,2,BL10LENG\n*        HEX   LINE+20,2,TO10LENG\n*        HEX   LINE+30,4,BLNKCNT\n*        APUT  LINE,50\n*        LM    R14,R1,SAVE1401      Load registers 14 thru 1.\n*>*----\n         L     R5,SAVER5E           Restore work register\n         L     R9,SAVER9Y           Restore BAL register\n         BR    R9\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n* ------------------------------------------------------------------ *\nWHERSIZE DS    0H                   Point to size field to update.\n* ------------------------------------------------------------------ *\n*    This is executed after MEASUR08 or MEASUR10.                    *\n*    The idea here is to update the appropriate length field for     *\n*      the appropriate table, after having measured the size.        *\n*    This routine is also used for zeroing the table lengths.        *\n*    This routine is executed in supervisor state. Called from       *\n*      the SETTMODE routine.                                         *\n* ------------------------------------------------------------------ *\n*   ***  Note:  We unconditionally update the table lengths.  ***    *\n* ------------------------------------------------------------------ *\n         ST    R9,SAVER9Q           Save BAL register\n         ST    R2,SAVER2B           Save work registers\n         ST    R3,SAVER3C\n         TM    OFFFLAG,X'30'        Are we updating or zeroing lengths?\n         BZ    WHEREXIT             No. We have no business here.\n         L     R2,LWAADDR           Point to the Logon Work Area.\n         USING LWA,R2               Address its fields.\n*-----------------------------*\nWHERCHUZ DS    0H                   Which table are we dealing with?\n*-----------------------------*\n         TM    TIDFLAG,X'20'           E2?\n         BO    WHERE2\n         TM    TIDFLAG,X'10'           E8?\n         BO    WHERE8\n         TM    TIDFLAG,X'80'           AP?\n         BO    WHERAP\n         TM    TIDFLAG,X'40'           NS?\n         BO    WHERNS\n         B     WHEREXIT\n*-----------------------------*\nWHERE2   DS    0H                      Update E2 length\n         TM    SHBLFLG,X'01'\n         BO    WHERE2SH\n         MVC   LWATE2LN(2),TO08LENG    Move length to LWA\n         MVC   SAVETNEW(2),TO08LENG    Save length for message\n         B     WHERE2E\nWHERE2SH DS    0H\n         MVC   LWATE2LN(2),ME08LENG    Move length to LWA\n         MVC   SAVETNEW(2),ME08LENG    Save length for message\nWHERE2E  DS    0H\n*-*-*-*\nWHERE2Z  DS    0H                      If zeroing, then zero E2 length\n         TM    OFFFLAG,X'20'           Zeroing length?\n         BZ    WHE2NOZ1                No. Bypass this.\n         MVC   LWATE2LN(2),=X'0000'    Move length to LWA\n         MVC   SAVETNEW(2),=X'0000'    Save length for message\nWHE2NOZ1 DS    0H\n*-*-*-*\n         B     WHEREXIT                Finished, get out of routine.\n*-----------------------------*\nWHERE8   DS    0H                      Update E8 length\n         TM    SHBLFLG,X'01'\n         BO    WHERE8SH\n         MVC   LWATE8LN(2),TO08LENG    Move length to LWA\n         MVC   SAVETNEW(2),TO08LENG    Save length for message\n         B     WHERE8E\nWHERE8SH DS    0H\n         MVC   LWATE8LN(2),ME08LENG    Move length to LWA\n         MVC   SAVETNEW(2),ME08LENG    Save length for message\nWHERE8E  DS    0H\n*-*-*-*\nWHERE8Z  DS    0H                      If zeroing, then zero E8 length\n         TM    OFFFLAG,X'20'           Zeroing length?\n         BZ    WHE8NOZ1                No. Bypass this.\n         MVC   LWATE8LN(2),=X'0000'    Move length to LWA\n         MVC   SAVETNEW(2),=X'0000'    Save length for message\nWHE8NOZ1 DS    0H\n*-*-*-*\n         B     WHEREXIT                Finished, get out of routine.\n*-----------------------------*\nWHERAP   DS    0H                      Update AP length\n         TM    SHBLFLG,X'01'\n         BO    WHERAPSH\n         MVC   LWATAPLN(2),TO08LENG    Move length to LWA\n         MVC   SAVETNEW(2),TO08LENG    Save length for message\n         B     WHERAPE\nWHERAPSH DS    0H\n         MVC   LWATAPLN(2),ME08LENG    Move length to LWA\n         MVC   SAVETNEW(2),ME08LENG    Save length for message\nWHERAPE  DS    0H\n*-*-*-*\nWHERAPZ  DS    0H                      If zeroing, then zero AP length\n         TM    OFFFLAG,X'20'           Zeroing length?\n         BZ    WHAPNOZ1                No. Bypass this.\n         MVC   LWATAPLN(2),=X'0000'    Move length to LWA\n         MVC   SAVETNEW(2),=X'0000'    Save length for message\nWHAPNOZ1 DS    0H\n*-*-*-*\n         B     WHEREXIT                Finished, get out of routine.\n*-----------------------------*\nWHERNS   DS    0H                      Update NS length\n         TM    SHBLFLG,X'01'\n         BO    WHERNSSH\n         MVC   LWATNSLN(2),TO10LENG    Move length to LWA\n         MVC   SAVETNEW(2),TO10LENG    Save length for message\n         B     WHERNSE\nWHERNSSH DS    0H\n         MVC   LWATNSLN(2),ME10LENG    Move length to LWA\n         MVC   SAVETNEW(2),ME10LENG    Save length for message\nWHERNSE  DS    0H\n*-*-*-*\nWHERNSZ  DS    0H                      If zeroing, then zero NS length\n         TM    OFFFLAG,X'20'           Zeroing length?\n         BZ    WHNSNOZ1                No. Bypass this.\n         MVC   LWATNSLN(2),=X'0000'    Move length to LWA\n         MVC   SAVETNEW(2),=X'0000'    Save length for message\nWHNSNOZ1 DS    0H\n*-*-*-*\n         B     WHEREXIT                Finished, get out of routine.\n*-----------------------------*\nWHEREXIT DS    0H\n         L     R2,SAVER2B              Restore work registers\n         L     R3,SAVER3C\n         L     R9,SAVER9Q\n         BR    R9\n         DROP  R2\nTABLEID  DC    CL2' '\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nSETSTEPL DS    0H                     Routine to turn on STEPLIB flags\n         ST    R9,SAVER9R\n         ST    R2,SAVER2C                Save work register\n         L     R2,LWAADDR\n         USING LWA,R2\nSETSWTBL DS    0H                     Check which table we're seeing\n         TM    TIDFLAG,X'03'          PC OR PP table?\n         BNZ   SETSTEPN               Say nothing changed.\n         TM    TIDFLAG,X'20'          E2?\n         BO    SETSDOE2\n         TM    TIDFLAG,X'10'          E8?\n         BO    SETSDOE8\n         TM    TIDFLAG,X'80'          AP?\n         BO    SETSDOAP\n         TM    TIDFLAG,X'40'          NS?\n         BO    SETSDONS\nSETSDOE2 DS    0H\n         OI    LWAPRMLB,LWATE2ST         STEPLIB flag on for E2\n         B     SETSWTBE\nSETSDOE8 DS    0H\n         OI    LWAPRMLB,LWATE8ST         STEPLIB flag on for E8\n         B     SETSWTBE\nSETSDOAP DS    0H\n         OI    LWAPRMLB,LWATAPST         STEPLIB flag on for AP\n         B     SETSWTBE\nSETSDONS DS    0H\n         OI    LWAPRMLB,LWATNSST         STEPLIB flag on for NS\n         B     SETSWTBE\nSETSWTBE DS    0H                        Print informative message\n         MVC   LINE,LINE-1\n         APUT  LINE,30\n         APUT  MESSAGEC,L'MESSAGEC    Say \"before making changes\"\n         MVC   LINE,LINE-1\n         MVC   LINE(71),=C'Table    marked from STEPLIB so PARMLIB UPDA-\n               TE(xx) will not overlay it.'\n         MVC   LINE+6(2),TABLEID\n         APUT  LINE,71\n         B     SETSTEPE\nSETSTEPN DS    0H\n         STM   R14,R1,SAVE1401    Save registers 14 thru 1.\n         APUT  MESSAG2D,L'MESSAG2D   Say nothing changed.\n         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.\n         B     SETSTEPE\nSETSTEPE DS    0H\n         L     R2,SAVER2C             Restore work register\n         L     R9,SAVER9R\n         DROP  R2\n         BR    R9\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nNOTSTEPL DS    0H                    Routine to turn off STEPLIB flags\n         ST    R9,SAVER9K\n         ST    R2,SAVER2C             Save work register\n         L     R2,LWAADDR\n         USING LWA,R2\nNOTSWTBL DS    0H                     Check which table we're seeing\n         TM    TIDFLAG,X'03'          PC OR PP table?\n         BNZ   NOTSTEPN               Say nothing changed.\n         TM    TIDFLAG,X'20'          E2?\n         BO    NOTSDOE2\n         TM    TIDFLAG,X'10'          E8?\n         BO    NOTSDOE8\n         TM    TIDFLAG,X'80'          AP?\n         BO    NOTSDOAP\n         TM    TIDFLAG,X'40'          NS?\n         BO    NOTSDONS\nNOTSDOE2 DS    0H\n         NI    LWAPRMLB,X'FF'-LWATE2ST   STEPLIB flag off for E2\n         B     NOTSWTBE\nNOTSDOE8 DS    0H\n         NI    LWAPRMLB,X'FF'-LWATE8ST   STEPLIB flag off for E8\n         B     NOTSWTBE\nNOTSDOAP DS    0H\n         NI    LWAPRMLB,X'FF'-LWATAPST   STEPLIB flag off for AP\n         B     NOTSWTBE\nNOTSDONS DS    0H\n         NI    LWAPRMLB,X'FF'-LWATNSST   STEPLIB flag off for NS\n         B     NOTSWTBE\nNOTSWTBE DS    0H                     Print informative message.\n         MVC   LINE,LINE-1            Print a blank first.\n         APUT  LINE,30\n         APUT  MESSAGEC,L'MESSAGEC    Say \"before making changes\".\n         MVC   LINE,LINE-1\n         MVC   LINE(71),=C'Table    marked from not from STEPLIB. PARML-\n               IB UPDATE(xx) can overlay. '\n         MVC   LINE+6(2),TABLEID      Move table name into message.\n         APUT  LINE,71\n         B     NOTSTEPE\nNOTSTEPN DS    0H\n         STM   R14,R1,SAVE1401    Save registers 14 thru 1.\n         APUT  MESSAG2D,L'MESSAG2D   Say nothing changed.\n         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.\n         B     NOTSTEPE\nNOTSTEPE DS    0H\n         L     R2,SAVER2C             Restore work register\n         L     R9,SAVER9K\n         BR    R9\n         DROP  R2\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nGETLPABD DS    0H                  Get storage boundary values for LPA\n         ST    R9,SAVER9S\nGETLSTRT DS    0H\n         ST    R5,SAVER5C          Prepare a bunch of work registers\n         ST    R4,SAVER4C          Prepare a bunch of work registers\n         L     R5,X'10'            Point to CVT.\n         USING CVT,R5              Tell Assembler.\n         L     R4,CVTSMEXT         Point to CVT Extension.\n         USING CVTVSTGX,R4         Tell Assembler.\n         MVC   SAVMLPAS,CVTMLPAS   MLPA start\n         MVC   SAVMLPAE,CVTMLPAE   MLPA end\n         MVC   SAVFLPAS,CVTFLPAS   FLPA start\n         MVC   SAVFLPAE,CVTFLPAE   FLPA end\n         MVC   SAVPLPAS,CVTPLPAS   PLPA start\n         MVC   SAVPLPAE,CVTPLPAE   PLPA end\n         MVC   SAVEMLPS,CVTEMLPS   E-MLPA start\n         MVC   SAVEMLPE,CVTEMLPE   E-MLPA end\n         MVC   SAVEFLPS,CVTEFLPS   E-FLPA start\n         MVC   SAVEFLPE,CVTEFLPE   E-FLPA end\n         MVC   SAVEPLPS,CVTEPLPS   E-PLPA start\n         MVC   SAVEPLPE,CVTEPLPE   E-PLPA end\n         L     R5,SAVER5C          Restore the work registers\n         L     R4,SAVER4C          Restore the work registers\n         L     R9,SAVER9S\n         DROP  R5,R4\n         BR    R9                  Return\n*                                  Constants needed here.\nSAVMLPAS DC    A(0)\nSAVMLPAE DC    A(0)\nSAVFLPAS DC    A(0)\nSAVFLPAE DC    A(0)\nSAVPLPAS DC    A(0)\nSAVPLPAE DC    A(0)\nSAVEMLPS DC    A(0)\nSAVEMLPE DC    A(0)\nSAVEFLPS DC    A(0)\nSAVEFLPE DC    A(0)\nSAVEPLPS DC    A(0)\nSAVEPLPE DC    A(0)\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nGETLPRNT DS    0H         Routine to Print LPA Range - action code X\n         ST    R9,SAVER9T\n         TM    LPADFLG,X'01'         Code wasn't X. Don't print.\n         BZ    GETLPRTE              Just restore R9 and go on.\n         MVC   LINE,LINE-1\n         MVC   LINE(28),DASHES28\n         APUT  LINE,35\n         MVC   LINE,LINE-1\n         MVC   LINE(28),=C' --- LPA RANGE DISPLAY ---  '\n         APUT  LINE,35\n         MVC   LINE,LINE-1\n         MVC   LINE(28),DASHES28\n         APUT  LINE,35\n         MVC   LINE,LINE-1\n         MVC   LINE(4),=C'MLPA'\n         HEX   LINE+10,4,SAVMLPAS    MLPA range\n         HEX   LINE+20,4,SAVMLPAE\n         APUT  LINE,35\n         MVC   LINE,LINE-1\n         MVC   LINE(4),=C'FLPA'\n         HEX   LINE+10,4,SAVFLPAS    FLPA range\n         HEX   LINE+20,4,SAVFLPAE\n         APUT  LINE,35\n         MVC   LINE,LINE-1\n         MVC   LINE(4),=C'PLPA'      PLPA range\n         HEX   LINE+10,4,SAVPLPAS\n         HEX   LINE+20,4,SAVPLPAE\n         APUT  LINE,35\n         MVC   LINE,LINE-1\n         MVC   LINE(6),=C'E-MLPA'    E-MLPA range\n         HEX   LINE+10,4,SAVEMLPS\n         HEX   LINE+20,4,SAVEMLPE\n         APUT  LINE,35\n         MVC   LINE,LINE-1\n         MVC   LINE(6),=C'E-FLPA'    E-FLPA range\n         HEX   LINE+10,4,SAVEFLPS\n         HEX   LINE+20,4,SAVEFLPE\n         APUT  LINE,35\n         MVC   LINE,LINE-1\n         MVC   LINE(6),=C'E-PLPA'    E-PLPA range\n         HEX   LINE+10,4,SAVEPLPS\n         HEX   LINE+20,4,SAVEPLPE\n         APUT  LINE,35\n         MVC   LINE,LINE-1\n         MVC   LINE(28),DASHES28     Print row of dashes at the bottom\n         APUT  LINE,35\nGETLPRTE DS    0H\n         L     R9,SAVER9T\n         BR    R9\nDASHES28 DC    28C'-'\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nPRTABLHD DS    0H\n         ST    R9,SAVER9U\n*                                 Print out table header\n         STM   R14,R1,SAVE1401    Now save registers 14 thru 1.\n         L     R1,TABLADDR        Load table start address.\n         MVC   DISPHDR(16),0(R1)  Move header info to display area.\n         ST    R1,HDRADDR         Store header address for alter\n         MVC   LINE,LINE-1        Clear line\n         MVC   LINE(15),=C'Table Header:  '  Move in title.\n         MVC   LINE+15(16),DISPHDR           Move in title info.\n         APUT  LINE,35\n         MVC   LINE,LINE-1        Clear line for next time\n         LM    R14,R1,SAVE1401    Restore  registers 14 thru 1.\n*-*\n         L     R9,SAVER9U\n         BR    R9\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n** ---------------------------------------------------------------- **\n**   When this routine is invoked, TABLADDR points to the start     **\n**    of the real table.                                            **\n** ---------------------------------------------------------------- **\nTESTLPA  DS    0H             Test if an address is in any LPA range\n         ST    R9,SAVER9W\n*-*-*->>                          Print the address out so we can see.\n         STM   R14,R1,SAVE1401    Save registers 14 thru 1.\n         MVC   LINE,LINE-1        Clear line area.\n         MVC   LINE(16),=C'Table address:  '\n         HEX   LINE+20,4,TABLADDR     Display address in Hex\n         APUT  LINE,35\n         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.\n*-*-*->>\nTESLSTRT DS    0H\n         CLC   TABLADDR,SAVMLPAS      Smaller than MLPA start?\n         BL    TESLTST1\n         CLC   TABLADDR,SAVMLPAE      Larger than MLPA end?\n         BH    TESLTST1\n         OI    LPAFLAG,X'01'          In between, flag it and exit.\n         B     TESLMSG\nTESLTST1 DS    0H\n         CLC   TABLADDR,SAVFLPAS      Smaller than FLPA start?\n         BL    TESLTST2\n         CLC   TABLADDR,SAVFLPAE      Larger than FLPA end?\n         BH    TESLTST2\n         OI    LPAFLAG,X'01'          In between, flag it and exit.\n         B     TESLMSG\nTESLTST2 DS    0H\n         CLC   TABLADDR,SAVPLPAS      Smaller than PLPA start?\n         BL    TESLTST3\n         CLC   TABLADDR,SAVPLPAE      Larger than PLPA end?\n         BH    TESLTST3\n         OI    LPAFLAG,X'01'\n         B     TESLMSG                In between, flag it and exit.\nTESLTST3 DS    0H\n         CLC   TABLADDR,SAVEMLPS      Smaller than E-MLPA start?\n         BL    TESLTST4\n         CLC   TABLADDR,SAVEMLPE      Larger than E-MLPA end?\n         BH    TESLTST4\n         OI    LPAFLAG,X'01'          In between, flag it and exit.\n         B     TESLMSG\nTESLTST4 DS    0H\n         CLC   TABLADDR,SAVEFLPS      Smaller than E-FLPA start?\n         BL    TESLTST5\n         CLC   TABLADDR,SAVEFLPE      Larger than E-FLPA end?\n         BH    TESLTST5\n         OI    LPAFLAG,X'01'          In between, flag it and exit.\n         B     TESLMSG\nTESLTST5 DS    0H\n         CLC   TABLADDR,SAVEPLPS      Smaller than E-PLPA start?\n         BL    TESLMSG\n         CLC   TABLADDR,SAVEPLPE      Larger than E-PLPA end?\n         BH    TESLMSG\n         OI    LPAFLAG,X'01'          In between, flag it and exit.\n         B     TESLMSG\nTESLMSG  DS    0H\n*-*-*->>                          Message the result of the LPA test.\n         STM   R14,R1,SAVE1401    Save registers 14 thru 1.\n         MVC   LINE,LINE-1        Clear line area.\n         TM    LPAFLAG,X'01'      Is the address within LPA?\n         BZ    TESLMSGA           No. Say not.\n         MVC   LINE(40),=C'Table address lies within an LPA region.'\n         B     TESLMSGP           Go send the message.\nTESLMSGA DS    0H\n         MVC   LINE(42),=C'Table address is not within an LPA region.'\nTESLMSGP DS    0H                 Send the message.\n         APUT  LINE,45\n         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.\n*-*-*->>\nTESLEND  DS    0H\n         L     R9,SAVER9W\n         BR    R9\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nCHANGEDL DS    0H                     Say table was in LPALIB so that\n*                                       therefore nothing was changed.\n         ST    R9,SAVER9V\n         TM    LPAFLAG,X'01'          Table was loaded in the LPALIB\n*                                      storage range. Can't change it.\n         BZ    CHANGEEN\n         APUT  MESSAG2E,L'MESSAG2E    Say that table was from LPALIB.\n         APUT  MESSAG2D,L'MESSAG2D    Say that nothing was changed.\nCHANGEEN DS    0H\n         L     R9,SAVER9V\n         BR    R9\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nENTRYDSP DS    0H\n         ST    R9,SAVER9X\n         TM    TIDFLAG,X'03'      PC or PP table?\n         BNZ   ENTRYEXI           Yes. No display here.\n         STM   R14,R1,SAVE1401    Save registers 14 thru 1.\n         MVC   LINE,LINE-1\n         L     R1,NTRYCNT\n         CVD   R1,CVDAREA\n         MVC   LINE+22(10),MASK10\n         ED    LINE+22(10),CVDAREA+3\n         MVC   LINE(24),=C'Non-blank table entries:'\n         MVC   LINE+35(25),=C'(these are the ones used)'\n         APUT  LINE,65\n         MVC   LINE,LINE-1\n         L     R1,BLNKCNT\n         CVD   R1,CVDAREA\n         MVC   LINE+22(10),MASK10\n         ED    LINE+22(10),CVDAREA+3\n         MVC   LINE(24),=C'Perceived blank entries:'\n         MVC   LINE+35(25),=C'(potential for expansion)'\n         APUT  LINE,65\n         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.\nENTRYEXI DS    0H\n         L     R9,SAVER9X\n         BR    R9\nENTRYDEN DS    0H\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n** ---------------------------------------------------------------- **\n**   Here are the rest of the constants for the program.            **\n** ---------------------------------------------------------------- **\nBLKSTRNG DC    XL10'00004040404040404040'\nENDSTRNG DC    XL10'FFFF4040404040404040'\nZEROES8  DC    X'0000000000000000'\nMASK10   DC    XL10'40202020202020202120'\n         DC    C' '\nBLANKS   DC    C'                                            '\nQUEST08  DC    C'?       '     Nullify table entry without terminating\nMESSAGET DC    C'TSUB Command - Display/Change USERID Auth Table Entry -\n               - xxxxxxxx'\nMESSAGEU DC    C'---- -------   ------- ------ ------ ---- ----- ----- -\n                 --------'\nMESSAGEC DC    C'  **--------   AFTER MAKING CHANGES   -------**'\nMESSAGED DC    C'  **--- STATE BEFORE MAKING TABLE CHANGES ---**'\nMESSAG1A DC    C'Table XX pointed to by the LWA has length available. H+\n               ex xxxx '\nMESSAG1B DC    C'Table XX pointed to by the LWA has no lengths. Blanks +\n               will delimit.'\nMESSAG1C DC    C'Table XX pointed to by the LWA came from an APF STEPLI+\n               B.'\nMESSAG1D DC    C'Table XX pointed to by the LWA did not come from an AP+\n               F STEPLIB.'\nMESSAG2C DC    C'Command was not invoked APF authorized.'\nMESSAG2D DC    C'Nothing was changed.  '\nMESSAG2E DC    C'Table is in LPALIB, and we will not attempt to alter i+\n               t.'\nMESSAG3A DC    C'Slot      in XX table has been changed to         .'\nMESSAG3B DC    C'Slot      in XX table has been blanked.            '\nMESSAG3C DC    C'                                                      +\n                  '\nMESSAG3D DC    C'Last 8 bytes of table header altered to \" PARMLIB\". '\nMESSAG3E DC    C'LWA size for table    has been changed from Hex xxxx t+\n               o Hex xxxx.'\nMESSAG3F DC    C'LWA size for table    is now Hex xxxx. '\nMESSAG3G DC    C'Slot      in XX table has been nullified.          '\nMESSA11A DC    C'  Supply a table code TT, followed by an action code A-\n               .'\nMESSA11B DC    C'Supply a program name, as the next parameter.   '\nMESSA11C DC    C'Valid table  codes are:  E2, E8, AP, NS, PC, PP. '\nMESSA11D DC    C'Valid action codes are:  R - replace, B - blank, D - d-\n               isplay,'\nMESSA11Z DC    C'  H - header, L - supply full table length, Z - zero t-\n               able length,'\nMESSA11Y DC    C'  S - mark table from STEPLIB, P - mark table from PAR-\n               MLIB,'\nMESSA11X DC    C'  X - display LPA storage ranges, M - supply minimum t-\n               able length.'\nMESSA11W DC    C'  N - nullify a single entry without invalidating subs-\n               equent entries.'\nMESSA11E DC    C'Please supply a program name.  '\nMESSA11F DC    C'Full command is in the form TTA, TT=table code, A=acti-\n               on code.'\nMESSA11G DC   C'Please supply slot number to change, and program name.'\nMESSA11I DC    C'If D (display) is followed by a slot number, only that-\n                slot is shown.'\nMESSA11J DC    C'R (replace) requires a slot number, followed by a prog-\n               ram name.'\nMESSA11K DC    C'If D is not followed by a number, then the entire tabl-\n               e is displayed.'\nMESSA11L DC    C'  Instructions to use this program:                  '\nMESSA11M DC    C'  ------------ -- --- ---- -------                   '\nMESSA11N DC    C'B (blank) blanks the slot number given. Higher slots a-\n               re invalidated.'\nMESSA11R DC    C'N (nullify) invalidates that slot number. Higher slots-\n                remain valid.'\nMESSA11O DC    C'D does not need APF authorization. All other codes req-\n               uire it.'\nMESSA11P DC    C'TSUB TTA nnn pgmname (nnn optional for D, both require-\n               d for R)'\nMESSA11Q DC    C'Codes: D,H,L,M,Z,P,S,X do not require extra parameters-\n               .'\nMESSA12Q DC    C'Please supply slot number to blank out. BE CAREFUL !'\nMESSAGR0 DC    C'Return Code = 0 '\nMESSAGR4 DC    C'Return Code = 4 '\nMESSAGR8 DC    C'Return Code = 8 '\nMESSAGRC DC    C'Return Code = 12'\nMESSDIAG DC    C'                                            '\nMESSAGEP DC    C'No Parmlib-supplied XX table was found in storage. '\nMESSAGEN DC    C'Supplied character        was not numeric. '\n         SPACE 3\n         LTORG\n         SPACE 3\nCVDAREA  DS    D                   For CVD instruction\nSAVEAPUT DS    2D\nSAVER23  DS    2F                  Save pair of regs R2, R3\nSAVER1A  DS    F                   Save R1 here\nSAVER1B  DS    F                   Save R1 here\nSAVER1C  DS    F                   Save R1 here\nSAVER2A  DS    F                   Save R2 here\nSAVER2B  DS    F                   Save R2 here\nSAVER2C  DS    F                   Save R2 here\nSAVER2D  DS    F                   Save R2 here\nSAVER2E  DS    F                   Save R2 here\nSAVER2F  DS    F                   Save R2 here\nSAVER2G  DS    F                   Save R2 here\nSAVER3A  DS    F                   Save R3 here\nSAVER3B  DS    F                   Save R3 here\nSAVER3C  DS    F                   Save R3 here\nSAVER4A  DS    F                   Save R4 here\nSAVER4B  DS    F                   Save R4 here\nSAVER4C  DS    F                   Save R4 here\nSAVER5A  DS    F                   Save R5 here\nSAVER5B  DS    F                   Save R5 here\nSAVER5C  DS    F                   Save R5 here\nSAVER5D  DS    F                   Save R5 here\nSAVER5E  DS    F                   Save R5 here\nSAVER5F  DS    F                   Save R5 here\nSAVER8A  DS    F                   Save R8 here\nSAVER9A  DS    F                   BAL Register Save Area\nSAVER9B  DS    F                   BAL Register Save Area\nSAVER9C  DS    F                   BAL Register Save Area\nSAVER9D  DS    F                   BAL Register Save Area\nSAVER9E  DS    F                   BAL Register Save Area\nSAVER9F  DS    F                   BAL Register Save Area\nSAVER9G  DS    F                   BAL Register Save Area\nSAVER9H  DS    F                   BAL Register Save Area\nSAVER9I  DS    F                   BAL Register Save Area\nSAVER9J  DS    F                   BAL Register Save Area\nSAVER9K  DS    F                   BAL Register Save Area\nSAVER9L  DS    F                   BAL Register Save Area\nSAVER9M  DS    F                   BAL Register Save Area\nSAVER9N  DS    F                   BAL Register Save Area\nSAVER9O  DS    F                   BAL Register Save Area\nSAVER9P  DS    F                   BAL Register Save Area\nSAVER9Q  DS    F                   BAL Register Save Area\nSAVER9R  DS    F                   BAL Register Save Area\nSAVER9S  DS    F                   BAL Register Save Area\nSAVER9T  DS    F                   BAL Register Save Area\nSAVER9U  DS    F                   BAL Register Save Area\nSAVER9V  DS    F                   BAL Register Save Area\nSAVER9W  DS    F                   BAL Register Save Area\nSAVER9X  DS    F                   BAL Register Save Area\nSAVER9Y  DS    F                   BAL Register Save Area\nCMBUFEND DS    F                   Number of bytes to end of cmd buff\nSAVLSLOT DS    F                   Save place where Key 0 will change\nSLOTBIN  DS    F                   Fullword binary value of slot number\nSLOTNOW  DS    F                   Slot number being searched\nDISPREG  DS    F                   DISPLAY\nCMBUFAD  DS    F                   Command Buffer address\nCHARSTRT DS    F                   Address of first parm character\nCHARCONT DS    F                   Address of next parm character\nCHARSIZE DS    F\nOURSLOT  DS    F                   Address of current slot searched\nFOUNSLOT DS    F\nTABLEND  DS    F                   Estimated or real end addr of table\n* --- >\nTABLSTRT DS    F                   Start address of table\nTABLADDR DS    F                   Store address of current table\nTABLENUM DS    F                   Number of entries in table\nTABLESIZ DS    F                   Size of a table entry\n* --- >\nBLNKCNT  DS    F\nNTRYCNT  DS    F\n* --- >\nOFFSETSV DS    F\nWORKA    DC    D'0'                Work area for CVB\nNUMVSTRT DC    X'00'               Character count of first parm\nNUMCOUTL DC    X'00'               Entered first parm length\nCODEPLAC DS    CL2                 Store entered table code here\nPAD01    DS    CL4                 Filler\nSAVECHAR DS    X\nSAVECH08 DS    X\nMEASFLG  DS    X\nSHBLFLG  DS    X\nOFFFLAG  DS    X                   What function are we doing?\nOFFFLAG1 DS    X                   Extra function flag\nOLDFLAG  DS    X                   Old system detected if X'01'\nTIDFLAG  DS    X                   Which table are we handling.\nLPAFLAG  DS    X                   Is the table address in the LPA?\nLPADFLG  DS    X                   Do LPA range display.\nPLATFLG  DS    X                   FCVE or PPVE exist.\nHAVLFLG  DS    X                   Have length of table available\nNSCHFLG  DS    X                   Dealing the 10-byte NS table?\nLWAPFLG  DS    X                   LWAPRMLB flag copied into program\n*              X'80'               LWATAPST TAP came from STEPLIB\n*              X'40'               LWATNSST TNS came from STEPLIB\n*              X'20'               LWATE2ST TE2 came from STEPLIB\n*              X'10'               LWATE8ST TE8 came from STEPLIB\nLWAMFLG  DS    X                   Which tables have a size in the LWA.\n*              X'80'               AP has a size in the LWA.\n*              X'40'               NS has a size in the LWA.\n*              X'20'               E2 has a size in the LWA.\n*              X'10'               E8 has a size in the LWA.\nFLAGZ    DS    X\n*              X'01'               Found a blank entry. End table srch.\n*              X'02'               Parm number is past the end of table\n*              X'04'               Table lengths have been supplied.\nPAD02    DS    CL4                 Filler\nFSTNAME  DC    CL8' '              Entered program name for \"Replace\"\nFSTCOUNT DS    F                   Number of characters in FSTNAME\nFSTCHALF DC    H'0'\nPAD03    DS    CL4                 Filler\nTABENNUM DC    CL10' '\nPAD03A   DS    CL4                 Filler\nFSTFIELD DS    0CL8\nFSTNUME  DC    CL5' '\nFSTNUPAD DC    CL3' '\nFSTNOUNT DS    F                   Number of characters in FSTNAME\nFSTNHALF DC    H'0'\nPAD04    DS    CL4                 Filler\nSLOTSAVE DS    CL10\nPAD05    DS    CL4                 Filler\nSNDNAME  DC    CL8' '\nSNDCOUNT DS    F                   Number of characters in SNDNAME\nSNDCHALF DC    H'0'\nTABCODE  DC    CL8' '              Original OUTLIM character\n         DS    CL7                 PADDING\nDISPHDR  DS    CL16                Table header display area\n         DS    CL1\nHDRADDR  DS    F                   Address of table header\nCMDBCOPY DS    CL252\n         DS    CL128               PADDING\n         DS    0F                  ALIGN ON FULLWORD\nLINEB    DS    C                   LINE-1\nLINE     DS    CL137               Output line area\nLINET    EQU   LINE+7              Indented line\nLINAB    DS    C                   LINE-1\nLINA     DS    CL137               Output line area\nLINAT    EQU   LINA+7              Indented line\nTRTPGMNM DC    X'02020202020202020202020202020202'\n         DC    X'02020202020202020202020202020202'\n         DC    X'02020202020202020202020202020202'\n         DC    X'02020202020202020202020202020202'\n         DC    X'40020202020202020202020202020202'\n         DC    X'02020202020202020202025B02020202'\n         DC    X'0202020202020202020202020202026F'\n         DC    X'02020202020202020202027B7C020202'\n         DC    X'02C1C2C3C4C5C6C7C8C9020202020202'\n         DC    X'02D1D2D3D4D5D6D7D8D9020202020202'\n         DC    X'0202E2E3E4E5E6E7E8E9020202020202'\n         DC    X'02020202020202020202020202020202'\n         DC    X'02C1C2C3C4C5C6C7C8C9020202020202'\n         DC    X'02D1D2D3D4D5D6D7D8D9020202020202'\n         DC    X'0202E2E3E4E5E6E7E8E9020202020202'\n         DC    X'02020202020202020202020202020202'\n         SPACE\n         IKJCPPL\n         IKJPSCB\n         CVT      LIST=YES,DSECT=YES\n         IKJTSVT\n         IKJEFLWA\n         END\nEPUTL    TITLE 'PUTLINE FOR FEWER THAN 83 ARGUMENTS IN THE KEY OF C MAJ&\n               OR'\nEPUTL    CSECT                                              *HMD 10/85*\n         LCLB  &XA                                          *HMD 10/85*\n&XA      SETB  1                  SET TO ZERO ON NON/XA     *HMD 10/85*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*  MODULE NAME  . . . . EPUTL\n*\n*  ALIASES  . . . . . . NONE\n*\n*  DATE WRITTEN . . . . 06/85\n*  UPDATED      . . . . 04/88                                  HD APR88\n*\n*  AUTHOR . . . . . . . JIM ELSWORTH\n*  UPDATOR  . . . . . . HOWARD M. DEAN                         HD APR88\n*\n*  ENVIRONMENT  . . . . TSO COMMAND-PROCESSOR\n*\n*  PURPOSE:\n*    ALLOW AN EASY INTERFACE TO PUTLINE ROUTINE\n*\n*\n*  DESCRIPTION:\n*    BUILDS PUTLINE PARAMETER LIST BASED ON INPUT ARGUMENTS.\n*    ISSUES SINGLE LINE PUTLINE.\n*\n*\n*  ATTRIBUTES:\n*    REENTRANT\n*\n*  FEATURES:\n*    WILL RUN UNDER BATCH TMP SINCE PUTLINE USED INSTEAD OF TPUT.\n*\n*  CALLED MODULES:\n*    PUTLINE\n*\n*  ASSUMPTIONS:\n*    CALLED BY A TSO-CP THAT IS OBSERVING STANDARD LINKAGE\n*\n*  ABENDS:\n*    POSSIBLE 0CX IF BAD ARGUEMNTS\n*\n*  CAVEATS:\n*    UNPREDICTABLE RESULTS IF FIRST PROGRAM RUNNING UNDER THIS TCB\n*    DID NOT SAVE (14,12) BEFOR R1 WAS MODIFIED.\n*\n*\n*  INPUT ARGUMENTS:\n*    1)  R1 : ADDRESS OF MESSAGE TEXT\n*    2)  R0 : LENGTH OF MESSAGE TEXT\n*    3) R13 : STANDARD OS SAVE AREA\n*    4) R14 : RETURN ADDRESS\n*    5) R15 : ENTRY ADDRESS\n*\n*               ( CONTINUED ... )\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*\n*  OUTPUT ARGUMENT: RETURN CODE FROM PUTLINE OR\n*\nRCBA     EQU   100                 BAD MESSAGE ADDRESS\nRCBL     EQU   104                 MESSAGE LENGTH <1 OR >MAXMSG\n*\nMAXMSG   EQU   128                 MAXIMUM MESSAGE LENGTH\n*\n*\n*  REGISTERS USED:\n*\nR0       EQU   0                   MESSAGE LENGTH AT ENTRY\nR1       EQU   1                   MESSAGE ADDRESS AT ENTRY\nR2       EQU   2                   WORK\nRMA      EQU   4                   @MESSAGE TEXT\nRML      EQU   5                   MESSAGE LENGTH\nRUPT     EQU   6                   @UPT (USER PROFILE TABLE)\nRECT     EQU   7                   @ECT\nR12      EQU   12                  CSECT BASE\nR13      EQU   13                  @SAVE AREA AND DYNAMIC WORK AREA\nR14      EQU   14                  WORK/LINKAGE\nR15      EQU   15                  WORK/LINKAGE\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         EJECT\n         IKJCPPL\n         EJECT\n         IKJTCB   LIST=YES                                  *HMD 10/85*\n         EJECT                                              *HMD 10/85*\n         CVT      DSECT=YES,LIST=YES                        *HMD 10/85*\n         EJECT\n         IHAPSA   LIST=YES                                     HD APR88\n         EJECT                                                 HD APR88\nPUTLDS   DSECT\n         DS    18F                      OS SAVE AREA\nPUTAAA   EQU   *\nPUTECB   DS    F                        ECB\nPUTIOPL  DS    4F                       IOPLADS\nPUTBLOK  PUTLINE MF=L\nPUTLEN   DS    H                        LENGTH\nPUTZZZ   DS    H                        RESERVED\nPUTMSG   DS    (MAXMSG)C                MESSAGE TEXT AREA\nPUTSIZE  EQU   *-PUTLDS                 SIZE OF PUTLINE PARMS\n         EJECT\n***********************************************************************\n*  SET UP LINKAGE\n***********************************************************************\n         SPACE 1\nEPUTL    CSECT\n         AIF  (NOT &XA).X001                                *HMD 10/85*\nEPUTL    AMODE 31\n.X001    ANOP                                               *HMD 10/85*\n         STM   14,12,12(13)       SAVE CALLERS REGS\n         LR    R12,R15            COPY EPA\n         USING EPUTL,R12          ADDRESSABILITY\n         AIF   (NOT &XA).X002                               *HMD 10/85*\n         GETMAIN RU,              LV=LENGTH                            &\n               LV=PUTSIZE,        STANDARD OS SA PLUS ANY EXTRA        &\n               LOC=RES            RELATIVE TO 16MB LINE\n         AGO   .X003                                        *HMD 10/85*\n.X002    ANOP                                               *HMD 10/85*\n         GETMAIN RU,              LV=LENGTH                            &\n               LV=PUTSIZE         STANDARD OS SA PLUS ANY EXTRA\n.X003    ANOP                                               *HMD 10/85*\n         ST    1,8(13)            OUR SAVE AREA POINTER\n         ST    13,4(1)            POINTER TO CALLERS SAVE AREA\n         LR    13,1               @OUR SAVE AREA\n         USING PUTLDS,R13         MAP SA AND WORK AREA\n         L     R14,4(R13)         POINT TO CALLERS RSA\n         LM    R0,R1,20(R14)      RESTORE REGS CHANGED BY GETMAIN\n         SPACE 2\n***********************************************************************\n*  UNLOAD ARGUMENTS AND VALIDATE WHERE POSSIBLE\n***********************************************************************\n         SPACE 1\n         LA    R15,RCBA                 ASSUME BAD ADDRESS\n         LTR   RMA,R1                   MESSAGE ADDRESS\n         BNP   RETURN                   GOOD ASSUMPTION\n         LA    R15,RCBL                 ASSUME BAD LENGTH\n         LTR   RML,R0                   POSITIVE?\n         BNP   RETURN                   -NO\n         C     RML,=A(MAXMSG)           MORE THAN MAX?\n         BH    RETURN                   -YES\n         SPACE 2\n***********************************************************************\n*  BUILD PARAMETER LIST\n***********************************************************************\n         SPACE 1\n         LA    R15,4(RML)               MESSAGE LENGTH\n         STH   R15,PUTLEN                 PLUS HEADER\n         XC    PUTZZZ,PUTZZZ            CLEAR 2ND HWORD OF RDW\n         BCTR  RML,0                    REDUCE FOR MOVE\n         EX    RML,PUTMOVE\n         EJECT\n***********************************************************************\n*  DIG UP ADDRESS OF UPT AND ECT\n***********************************************************************\n         SPACE 1\n         L     R2,PSATOLD-PSA           @TCB                   HD APR88\n         L     R2,TCBFSA-TCB(R2)        @1ST PROBLEM PGM SAVE AREA\n         L     R2,24(R2)                REG1 THAT WAS PASSED TO CP\n         USING CPPL,R2                  MAP CPPL\n         L     RUPT,CPPLUPT             @UPT\n         L     RECT,CPPLECT             @ECT\n         SPACE 2\n***********************************************************************\n*  ISSUE PUTLINE CALL\n***********************************************************************\n         SPACE 1\n         XC    PUTECB,PUTECB            CLEAR ECB\n         XC    PUTBLOK(12),PUTBLOK      CLEAR PARM BLOCK       HD APR88\n         PUTLINE PARM=PUTBLOK,          PARAMETER BLOCK                &\n               UPT=(RUPT),              @UPT                           &\n               ECT=(RECT),              @ECT                           &\n               ECB=PUTECB,              @ECB                           &\n               OUTPUT=(PUTLEN,TERM,SINGLE,DATA),                       &\n               MF=(E,PUTIOPL)\n         EJECT\n***********************************************************************\n*  RETURN TO CALLER\n***********************************************************************\n         SPACE 1\nRETURN   EQU   *\n         LR    2,R13                    @OUR SAVE AREA\n         LR    3,R15                    SAVE RETURN CODE\n         L     R13,4(R13)               @CALLERS SAVE AREA\n         FREEMAIN RU,LV=PUTSIZE,A=(R2),SP=0\n         LR    R15,3                    RESTORE RC\n         RETURN (14,12),RC=(15)         RESTORE CALLERS REGS\n         SPACE 5\n***********************************************************************\n*  CONSTANTS AND NON-REENTRANT WORK AREAS\n***********************************************************************\n         SPACE 1\nPUTMOVE  MVC   PUTMSG(*-*),0(RMA)       MOVE MESSAGE TO BUFFER\n         SPACE 2\n         LTORG\n         SPACE 2\n         END   EPUTL\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TSUB$": {"ttr": 11527, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x10\\x00\\x05\\x01\\x055O\\x01\\x164/\\x15\\x02\\x00\\x1d\\x00\\x1d\\x00\\x00```````@@@'", "ispf": {"version": "01.16", "flags": 0, "createdate": "2005-12-20T00:00:00", "modifydate": "2016-12-07T15:02:05", "lines": 29, "newlines": 29, "modlines": 0, "user": "-------"}, "text": "//IBMUSERU JOB (CCMVS),ASMLINK,\n// NOTIFY=&SYSUID,\n// CLASS=A,MSGCLASS=X,COND=(1,LT)\n//*\n//*     ASM LINKEDIT FROM SOURCE ASM\n//*\n//ASMH EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,NORLD,NOXREF)\n//SYSLIB   DD DISP=SHR,DSN=SYS1.MACLIB\n//         DD DISP=SHR,DSN=SYS1.MODGEN\n//         DD DISP=SHR,DSN=IBMUSER.CBT493.FILE185\n//SYSIN    DD DISP=SHR,DSN=IBMUSER.CBT493.FILE185(TSUB)\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,9),DISP=(,PASS),DCB=BLKSIZE=3200,\n//            DSN=&&TEMP\n//*\n//LKED   EXEC  PGM=HEWL,\n//       PARM='NCAL,MAP,LIST,LET'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//SYSLMOD  DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//OBJECT   DD  DISP=(OLD,DELETE),DSN=&&TEMP\n//SYSLIN   DD  *\n INCLUDE OBJECT\n SETCODE AC(1)\n SETSSI  CB493185\n ENTRY   TSUB\n NAME    TSUB(R)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TSUB#01": {"ttr": 11529, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x04\\x01\\t\\x04\\x8f\\x01\\t\\x04\\x8f\\x081\\x005\\x00/\\x00\\x00```````@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2009-02-17T00:00:00", "modifydate": "2009-02-17T08:31:04", "lines": 53, "newlines": 47, "modlines": 0, "user": "-------"}, "text": "Output of command:  TSUB E8D\n\n     This is from a userid that took its tables from PARMLIB.\n     Note the messages below, to that effect.\n\n\nTSUB Command - Display or Change Auth Table or Entry\n---- -------   ------- -- ------ ---- ----- -- -----\nE8D   04     Program table code + Function code\nTable address:      0000B3E8\nTable address is not within an LPA region.\nNon-blank table entries:      33   (these are the ones used)\nPerceived blank entries:       1   (potential for expansion)\nTable E8 pointed to by the LWA has length available. Hex 0120.\nTable E8 pointed to by the LWA did not come from an APF STEPLIB.\nTable Header:  IKJEFTE8 PARMLIB\nNumber of valid entries:      34\nE8 Table Entry Number:         1  ICHUT100\nE8 Table Entry Number:         2  ICHUT200\nE8 Table Entry Number:         3  ICHUT400\nE8 Table Entry Number:         4  ICHDSM00\nE8 Table Entry Number:         5  IRRDSC00\nE8 Table Entry Number:         6  IRRUT100\nE8 Table Entry Number:         7  IRRUT200\nE8 Table Entry Number:         8  IRRUT400\nE8 Table Entry Number:         9  IRRDPI00\nE8 Table Entry Number:        10  CSFDAUTH\nE8 Table Entry Number:        11  ICADCT\nE8 Table Entry Number:        12  ICADDCT\nE8 Table Entry Number:        13  ICADCFGS\nE8 Table Entry Number:        14  ICADPFTP\nE8 Table Entry Number:        15  ICADFTPD\nE8 Table Entry Number:        16  ICADSLOG\nE8 Table Entry Number:        17  ICADSOCK\nE8 Table Entry Number:        18  ICADSOXD\nE8 Table Entry Number:        19  ICADSTAK\nE8 Table Entry Number:        20  ICADIKED\nE8 Table Entry Number:        21  IEBCOPY\nE8 Table Entry Number:        22  IOEGRWAG\nE8 Table Entry Number:        23  IOENEWAG\nE8 Table Entry Number:        24  IOESALVG\nE8 Table Entry Number:        25  IOEBAK\nE8 Table Entry Number:        26  IOEBOS\nE8 Table Entry Number:        27  IOECM\nE8 Table Entry Number:        28  IOEDCEER\nE8 Table Entry Number:        29  IOEDFSXP\nE8 Table Entry Number:        30  IOEFTS\nE8 Table Entry Number:        31  IOEMAPID\nE8 Table Entry Number:        32  IOESCOUT\nE8 Table Entry Number:        33  IOEUDBG\nE8 Table Entry Number:        34  *empty*\n\nReturn Code = 0\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TSUB#02": {"ttr": 11531, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x01\\x01\\t\\x04\\x8f\\x01\\t\\x04\\x8f\\x080\\x00\\x18\\x00\\x05\\x00\\x00```````@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2009-02-17T00:00:00", "modifydate": "2009-02-17T08:30:01", "lines": 24, "newlines": 5, "modlines": 0, "user": "-------"}, "text": "Output of command:  TSUB APD\n\n     This was from a userid that loaded its tables from PARMLIB.\n     See messages below, in the command output.\n\nTSUB Command - Display or Change Auth Table or Entry\n---- -------   ------- -- ------ ---- ----- -- -----\nAPD   04     Program table code + Function code\nTable address:      0000B7E0\nTable address is not within an LPA region.\nNon-blank table entries:       5   (these are the ones used)\nPerceived blank entries:       1   (potential for expansion)\nTable AP pointed to by the LWA has length available. Hex 0040.\nTable AP pointed to by the LWA did not come from an APF STEPLIB.\nTable Header:  IKJEFTAP PARMLIB\nNumber of valid entries:       6\nAP Table Entry Number:         1  CSFDAUTH\nAP Table Entry Number:         2  LWATMGR\nAP Table Entry Number:         3  IEBCOPY\nAP Table Entry Number:         4  ICQASLI0\nAP Table Entry Number:         5  IKJEFF76\nAP Table Entry Number:         6  *empty*\n\nReturn Code = 0\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TSUB#03": {"ttr": 11533, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00W\\x01\\t\\x04\\x8f\\x01\\t\\x04\\x8f\\x08%\\x01<\\x00\\x08\\x00\\x00```````@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2009-02-17T00:00:00", "modifydate": "2009-02-17T08:25:57", "lines": 316, "newlines": 8, "modlines": 0, "user": "-------"}, "text": "Output of command:  TSUB E2D\n\n    This was on a userid where there was an APF-authorized STEPLIB\n    library that had an IKJTABLS load library assembled from the\n    example on File 185 called ASMTABLS.  Note the message in TSUB\n    to that effect.\n\n\nTSUB Command - Display or Change Auth Table or Entry\n---- -------   ------- -- ------ ---- ----- -- -----\nE2D   04     Program table code + Function code\nTable address:      0000C000\nTable address is not within an LPA region.\nNon-blank table entries:     294   (these are the ones used)\nPerceived blank entries:      30   (potential for expansion)\nTable E2 pointed to by the LWA has no lengths. Blanks will delimit.\nTable E2 pointed to by the LWA came from an APF STEPLIB.\nTable Header:  IKJEFTE276.152\nNumber of valid entries:     295\nE2 Table Entry Number:         1  $$\nE2 Table Entry Number:         2  $HOWMVS\nE2 Table Entry Number:         3  $MDSMAIN\nE2 Table Entry Number:         4  ABUDSN\nE2 Table Entry Number:         5  AD\nE2 Table Entry Number:         6  ADB2UTIL\nE2 Table Entry Number:         7  ADDDIR\nE2 Table Entry Number:         8  ADDFILE\nE2 Table Entry Number:         9  ADDGROUP\nE2 Table Entry Number:        10  ADDSD\nE2 Table Entry Number:        11  ADDUSER\nE2 Table Entry Number:        12  ADIR\nE2 Table Entry Number:        13  ADNR\nE2 Table Entry Number:        14  ADYOPCMD\nE2 Table Entry Number:        15  AF\nE2 Table Entry Number:        16  AG\nE2 Table Entry Number:        17  AHOWMVS\nE2 Table Entry Number:        18  ALD\nE2 Table Entry Number:        19  ALF\nE2 Table Entry Number:        20  ALG\nE2 Table Entry Number:        21  ALTDIR\nE2 Table Entry Number:        22  ALTDSD\nE2 Table Entry Number:        23  ALTER\nE2 Table Entry Number:        24  ALTFILE\nE2 Table Entry Number:        25  ALTGROUP\nE2 Table Entry Number:        26  ALTUSER\nE2 Table Entry Number:        27  ALU\nE2 Table Entry Number:        28  APCACBL\nE2 Table Entry Number:        29  APCANB\nE2 Table Entry Number:        30  APCARB\nE2 Table Entry Number:        31  APCAUB\nE2 Table Entry Number:        32  APFCMD\nE2 Table Entry Number:        33  ASUB\nE2 Table Entry Number:        34  AU\nE2 Table Entry Number:        35  BACKUP\nE2 Table Entry Number:        36  BCMDEL\nE2 Table Entry Number:        37  BCMDEL1\nE2 Table Entry Number:        38  BCMNAUTH\nE2 Table Entry Number:        39  BCMNUPD\nE2 Table Entry Number:        40  BDATA\nE2 Table Entry Number:        41  BDMNUPD\nE2 Table Entry Number:        42  BINDDATA\nE2 Table Entry Number:        43  BLKUPD\nE2 Table Entry Number:        44  BUDDSN\nE2 Table Entry Number:        45  BUDGET\nE2 Table Entry Number:        46  CAE$BQRY\nE2 Table Entry Number:        47  CANCELU\nE2 Table Entry Number:        48  CAS9UDTN\nE2 Table Entry Number:        49  CDELPAIR\nE2 Table Entry Number:        50  CDMRSTAT\nE2 Table Entry Number:        51  CDSCB\nE2 Table Entry Number:        52  CESTPAIR\nE2 Table Entry Number:        53  CHKPT\nE2 Table Entry Number:        54  CINMX\nE2 Table Entry Number:        55  CLCHECK\nE2 Table Entry Number:        56  CNVTCAT\nE2 Table Entry Number:        57  CO\nE2 Table Entry Number:        58  COFDMON\nE2 Table Entry Number:        59  CONNECT\nE2 Table Entry Number:        60  CONSPROF\nE2 Table Entry Number:        61  CPSCB\nE2 Table Entry Number:        62  CQUERYSG\nE2 Table Entry Number:        63  CRECOVER\nE2 Table Entry Number:        64  CSCAN\nE2 Table Entry Number:        65  CSUSPEND\nE2 Table Entry Number:        66  DCAS\nE2 Table Entry Number:        67  DD\nE2 Table Entry Number:        68  DDIR\nE2 Table Entry Number:        69  DEF\nE2 Table Entry Number:        70  DEFINE\nE2 Table Entry Number:        71  DEL\nE2 Table Entry Number:        72  DELDIR\nE2 Table Entry Number:        73  DELDSD\nE2 Table Entry Number:        74  DELETE\nE2 Table Entry Number:        75  DELFILE\nE2 Table Entry Number:        76  DELGROUP\nE2 Table Entry Number:        77  DELUSER\nE2 Table Entry Number:        78  DF\nE2 Table Entry Number:        79  DG\nE2 Table Entry Number:        80  DITTO\nE2 Table Entry Number:        81  DITTOA\nE2 Table Entry Number:        82  DITTOU\nE2 Table Entry Number:        83  DMRSHR\nE2 Table Entry Number:        84  DRI\nE2 Table Entry Number:        85  DU\nE2 Table Entry Number:        86  ERWMAUTH\nE2 Table Entry Number:        87  EX\nE2 Table Entry Number:        88  EXP\nE2 Table Entry Number:        89  EXPORT\nE2 Table Entry Number:        90  EYU9XENF\nE2 Table Entry Number:        91  EZAZSSI\nE2 Table Entry Number:        92  EZBREINI\nE2 Table Entry Number:        93  EZBTNINI\nE2 Table Entry Number:        94  FCESTABL\nE2 Table Entry Number:        95  FCQUERY\nE2 Table Entry Number:        96  FCWITHDR\nE2 Table Entry Number:        97  FTPD\nE2 Table Entry Number:        98  FTPDNS\nE2 Table Entry Number:        99  GJTRUCBS\nE2 Table Entry Number:       100  IEBCOPY\nE2 Table Entry Number:       101  IKJEHDSF\nE2 Table Entry Number:       102  IKJEHDS1\nE2 Table Entry Number:       103  IKJPRMLB\nE2 Table Entry Number:       104  IM\nE2 Table Entry Number:       105  IMP\nE2 Table Entry Number:       106  IMPORT\nE2 Table Entry Number:       107  IOBSNMP\nE2 Table Entry Number:       108  IQIEXPN\nE2 Table Entry Number:       109  IQIMAIN\nE2 Table Entry Number:       110  IQIQUERY\nE2 Table Entry Number:       111  IQIQUIT\nE2 Table Entry Number:       112  IRRDPI00\nE2 Table Entry Number:       113  ISPICP\nE2 Table Entry Number:       114  ISRPCP\nE2 Table Entry Number:       115  LBADV\nE2 Table Entry Number:       116  LBAGENT\nE2 Table Entry Number:       117  LD\nE2 Table Entry Number:       118  LDATA\nE2 Table Entry Number:       119  LDIR\nE2 Table Entry Number:       120  LDIRECT\nE2 Table Entry Number:       121  LF\nE2 Table Entry Number:       122  LFILE\nE2 Table Entry Number:       123  LG\nE2 Table Entry Number:       124  LISTB\nE2 Table Entry Number:       125  LISTBC\nE2 Table Entry Number:       126  LISTD\nE2 Table Entry Number:       127  LISTDATA\nE2 Table Entry Number:       128  LISTDS\nE2 Table Entry Number:       129  LISTDSD\nE2 Table Entry Number:       130  LISTGRP\nE2 Table Entry Number:       131  LISTUSER\nE2 Table Entry Number:       132  LLWA\nE2 Table Entry Number:       133  LMRKTSO\nE2 Table Entry Number:       134  LOCKTERM\nE2 Table Entry Number:       135  LOOK\nE2 Table Entry Number:       136  LPQ\nE2 Table Entry Number:       137  LPR\nE2 Table Entry Number:       138  LPRM\nE2 Table Entry Number:       139  LPROC\nE2 Table Entry Number:       140  LSLT\nE2 Table Entry Number:       141  LU\nE2 Table Entry Number:       142  LWATMGR\nE2 Table Entry Number:       143  MAKEUSER\nE2 Table Entry Number:       144  MIMTSO\nE2 Table Entry Number:       145  MODDVIPA\nE2 Table Entry Number:       146  MU\nE2 Table Entry Number:       147  MVPMAIN\nE2 Table Entry Number:       148  MVPXDISP\nE2 Table Entry Number:       149  MVSCPCMD\nE2 Table Entry Number:       150  NAMEDXFR\nE2 Table Entry Number:       151  NAMED4\nE2 Table Entry Number:       152  NDVRC1\nE2 Table Entry Number:       153  NETSTAT\nE2 Table Entry Number:       154  NSUPDATE\nE2 Table Entry Number:       155  NSUPDAT4\nE2 Table Entry Number:       156  NYPPW\nE2 Table Entry Number:       157  OC\nE2 Table Entry Number:       158  OMPROUTE\nE2 Table Entry Number:       159  OP\nE2 Table Entry Number:       160  OPER\nE2 Table Entry Number:       161  OPERATOR\nE2 Table Entry Number:       162  OPINFO\nE2 Table Entry Number:       163  OPING\nE2 Table Entry Number:       164  OPSCMD\nE2 Table Entry Number:       165  OPSCONSL\nE2 Table Entry Number:       166  OPSOSCMD\nE2 Table Entry Number:       167  OPSPARM\nE2 Table Entry Number:       168  OPSREPLY\nE2 Table Entry Number:       169  OPSTAT\nE2 Table Entry Number:       170  OPSWTO\nE2 Table Entry Number:       171  OSNMPD\nE2 Table Entry Number:       172  OTRACERT\nE2 Table Entry Number:       173  PACKRAT\nE2 Table Entry Number:       174  PARMLIB\nE2 Table Entry Number:       175  PASSWORD\nE2 Table Entry Number:       176  PDIR\nE2 Table Entry Number:       177  PDSCLEAN\nE2 Table Entry Number:       178  PDSEAUTH\nE2 Table Entry Number:       179  PE\nE2 Table Entry Number:       180  PERMDIR\nE2 Table Entry Number:       181  PERMFILE\nE2 Table Entry Number:       182  PERMIT\nE2 Table Entry Number:       183  PF\nE2 Table Entry Number:       184  PHRASE\nE2 Table Entry Number:       185  PING\nE2 Table Entry Number:       186  POPPER\nE2 Table Entry Number:       187  PRINT\nE2 Table Entry Number:       188  PW\nE2 Table Entry Number:       189  Q\nE2 Table Entry Number:       190  QUEUE\nE2 Table Entry Number:       191  Q522\nE2 Table Entry Number:       192  RACDCERT\nE2 Table Entry Number:       193  RACFSIM\nE2 Table Entry Number:       194  RACLINK\nE2 Table Entry Number:       195  RACONVRT\nE2 Table Entry Number:       196  RACPRIV\nE2 Table Entry Number:       197  RALT\nE2 Table Entry Number:       198  RALTER\nE2 Table Entry Number:       199  RDEF\nE2 Table Entry Number:       200  RDEFINE\nE2 Table Entry Number:       201  RDEL\nE2 Table Entry Number:       202  RDELETE\nE2 Table Entry Number:       203  RE\nE2 Table Entry Number:       204  RECEIVE\nE2 Table Entry Number:       205  RELOGON\nE2 Table Entry Number:       206  REMOVE\nE2 Table Entry Number:       207  REPRO\nE2 Table Entry Number:       208  RESOLVE\nE2 Table Entry Number:       209  REVIEW\nE2 Table Entry Number:       210  REVVSAM\nE2 Table Entry Number:       211  REXCPCMD\nE2 Table Entry Number:       212  RL\nE2 Table Entry Number:       213  RLIST\nE2 Table Entry Number:       214  RLOAD\nE2 Table Entry Number:       215  RLOADA\nE2 Table Entry Number:       216  RMM\nE2 Table Entry Number:       217  RPF\nE2 Table Entry Number:       218  RPFE\nE2 Table Entry Number:       219  RSH\nE2 Table Entry Number:       220  RSHD\nE2 Table Entry Number:       221  RVARY\nE2 Table Entry Number:       222  SAMENDM\nE2 Table Entry Number:       223  SDSF\nE2 Table Entry Number:       224  SE\nE2 Table Entry Number:       225  SEARCH\nE2 Table Entry Number:       226  SECURE\nE2 Table Entry Number:       227  SEND\nE2 Table Entry Number:       228  SETC\nE2 Table Entry Number:       229  SETCACHE\nE2 Table Entry Number:       230  SETPASSW\nE2 Table Entry Number:       231  SETPW\nE2 Table Entry Number:       232  SETPW2\nE2 Table Entry Number:       233  SETR\nE2 Table Entry Number:       234  SETROPTS\nE2 Table Entry Number:       235  SETUSER\nE2 Table Entry Number:       236  SHCDS\nE2 Table Entry Number:       237  SM\nE2 Table Entry Number:       238  SMTP\nE2 Table Entry Number:       239  SNTPD\nE2 Table Entry Number:       240  SPACE\nE2 Table Entry Number:       241  SPY\nE2 Table Entry Number:       242  SR\nE2 Table Entry Number:       243  SRDIR\nE2 Table Entry Number:       244  SRF\nE2 Table Entry Number:       245  SRFILE\nE2 Table Entry Number:       246  SRSTAT\nE2 Table Entry Number:       247  STEPLIB\nE2 Table Entry Number:       248  STEPLIBN\nE2 Table Entry Number:       249  SU\nE2 Table Entry Number:       250  SYNC\nE2 Table Entry Number:       251  SYSPROG\nE2 Table Entry Number:       252  TEAEXTSO\nE2 Table Entry Number:       253  TERM\nE2 Table Entry Number:       254  TERMINAL\nE2 Table Entry Number:       255  TESTA\nE2 Table Entry Number:       256  TESTAUTH\nE2 Table Entry Number:       257  TMONCICS\nE2 Table Entry Number:       258  TMONDB2\nE2 Table Entry Number:       259  TMONIMS\nE2 Table Entry Number:       260  TMONMVS\nE2 Table Entry Number:       261  TRACERTE\nE2 Table Entry Number:       262  TRANSMIT\nE2 Table Entry Number:       263  TRAPFWD\nE2 Table Entry Number:       264  TRMD\nE2 Table Entry Number:       265  TSOENQ\nE2 Table Entry Number:       266  TSOSMS\nE2 Table Entry Number:       267  TSUB\nE2 Table Entry Number:       268  UKEYCSA\nE2 Table Entry Number:       269  USAT\nE2 Table Entry Number:       270  USIT\nE2 Table Entry Number:       271  USOT\nE2 Table Entry Number:       272  USUT\nE2 Table Entry Number:       273  VERIFY\nE2 Table Entry Number:       274  VFY\nE2 Table Entry Number:       275  VIEWUSER\nE2 Table Entry Number:       276  VLFNOTE\nE2 Table Entry Number:       277  VMCF\nE2 Table Entry Number:       278  VU\nE2 Table Entry Number:       279  WAITT\nE2 Table Entry Number:       280  WHOENQ\nE2 Table Entry Number:       281  WSSTAT\nE2 Table Entry Number:       282  XD\nE2 Table Entry Number:       283  XDCCALLA\nE2 Table Entry Number:       284  XDCCMDA\nE2 Table Entry Number:       285  XF\nE2 Table Entry Number:       286  XMDSMAIN\nE2 Table Entry Number:       287  XMIT\nE2 Table Entry Number:       288  XTRCUSER\nE2 Table Entry Number:       289  XU\nE2 Table Entry Number:       290  YKCONMSG\nE2 Table Entry Number:       291  ZAP\nE2 Table Entry Number:       292  ZAP$\nE2 Table Entry Number:       293  ZAPLWA\nE2 Table Entry Number:       294  ZAPV\nE2 Table Entry Number:       295  *empty*\n\nReturn Code = 0\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TSUB#04": {"ttr": 11781, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x02\\x01\\t\\x04\\x8f\\x01\\t\\x04\\x8f\\x087\\x00\\x1e\\x00\\t\\x00\\x00```````@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2009-02-17T00:00:00", "modifydate": "2009-02-17T08:37:02", "lines": 30, "newlines": 9, "modlines": 0, "user": "-------"}, "text": "Output of command:  TSUB E2R 295 CQX\n\n     This command replaces the former contents of slot 294, which\n     had been empty, with the program name entry CQX.  This has the\n     effect of allowing execution of the CQX command as an APF\n     authorized program.\n\n\nTSUB Command - Display or Change Auth Table or Entry\n---- -------   ------- -- ------ ---- ----- -- -----\n\n  **--- STATE BEFORE MAKING TABLE CHANGES ---**\nE2R   01     Program table code + Function code\n295          Entry slot number\n00000003     Length of command\nCQX          New program name\nTable address:      0000C000\nTable address is not within an LPA region.\nNon-blank table entries:     294   (these are the ones used)\nPerceived blank entries:      30   (potential for expansion)\nTable E2 pointed to by the LWA has no lengths. Blanks will delimit.\nTable E2 pointed to by the LWA came from an APF STEPLIB.\nTable Header:  IKJEFTE276.152\nNumber of valid entries:     295\nE2 Table Entry Number:       295  *empty*\n\n  **--------   AFTER MAKING CHANGES   -------**\nSlot  295 in E2 table has been changed to CQX     .\n\nReturn Code = 0\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TSUB#05": {"ttr": 11783, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00!\\x01\\t\\x04\\x8f\\x01\\t\\x04\\x8f\\x08E\\x01U\\x00\\x08\\x00\\x00```````@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2009-02-17T00:00:00", "modifydate": "2009-02-17T08:45:21", "lines": 341, "newlines": 8, "modlines": 0, "user": "-------"}, "text": "Output of command:  TSUB E2L   (compare TSUB E2M - example TSUB#06)\n\n     This command measures the length of the IKJEFTE2 table in\n     the user's address space, to (and including) all trailing blank\n     table entries.  Then that length is plugged into the LWA field\n     which is supposed to contain the length of the IKJEFTE2 table.\n     The messages below, tell you what happened.  Another TSUB E2D\n     command will tell you the resulting state of the E2 table.\n\n\nTSUB Command - Display or Change Auth Table or Entry\n---- -------   ------- -- ------ ---- ----- -- -----\n\n  **--- STATE BEFORE MAKING TABLE CHANGES ---**\nE2L   10     Program table code + Function code\nTable address:      0000C000\nTable address is not within an LPA region.\nNon-blank table entries:     295   (these are the ones used)\nPerceived blank entries:      29   (potential for expansion)\nTable E2 pointed to by the LWA has no lengths. Blanks will delimit.\nTable E2 pointed to by the LWA came from an APF STEPLIB.\nTable Header:  IKJEFTE276.152\nNumber of valid entries:     296\n\n  **--------   AFTER MAKING CHANGES   -------**\nLWA size for table E2 has been changed from Hex 0000 to Hex 0A30.\nTable E2 pointed to by the LWA has length available. Hex 0A30.\n\nReturn Code = 0\n\n-----------------------------------------------------------------\n\nTSUB Command - Display or Change Auth Table or Entry\n---- -------   ------- -- ------ ---- ----- -- -----\nE2D   04     Program table code + Function code\nTable address:      0000C000\nTable address is not within an LPA region.\nNon-blank table entries:     295   (these are the ones used)\nPerceived blank entries:      29   (potential for expansion)\nTable E2 pointed to by the LWA has length available. Hex 0A30.\nTable E2 pointed to by the LWA came from an APF STEPLIB.\nTable Header:  IKJEFTE276.152\nNumber of valid entries:     324\nE2 Table Entry Number:         1  $$\nE2 Table Entry Number:         2  $HOWMVS\nE2 Table Entry Number:         3  $MDSMAIN\nE2 Table Entry Number:         4  ABUDSN\nE2 Table Entry Number:         5  AD\nE2 Table Entry Number:         6  ADB2UTIL\nE2 Table Entry Number:         7  ADDDIR\nE2 Table Entry Number:         8  ADDFILE\nE2 Table Entry Number:         9  ADDGROUP\nE2 Table Entry Number:        10  ADDSD\nE2 Table Entry Number:        11  ADDUSER\nE2 Table Entry Number:        12  ADIR\nE2 Table Entry Number:        13  ADNR\nE2 Table Entry Number:        14  ADYOPCMD\nE2 Table Entry Number:        15  AF\nE2 Table Entry Number:        16  AG\nE2 Table Entry Number:        17  AHOWMVS\nE2 Table Entry Number:        18  ALD\nE2 Table Entry Number:        19  ALF\nE2 Table Entry Number:        20  ALG\nE2 Table Entry Number:        21  ALTDIR\nE2 Table Entry Number:        22  ALTDSD\nE2 Table Entry Number:        23  ALTER\nE2 Table Entry Number:        24  ALTFILE\nE2 Table Entry Number:        25  ALTGROUP\nE2 Table Entry Number:        26  ALTUSER\nE2 Table Entry Number:        27  ALU\nE2 Table Entry Number:        28  APCACBL\nE2 Table Entry Number:        29  APCANB\nE2 Table Entry Number:        30  APCARB\nE2 Table Entry Number:        31  APCAUB\nE2 Table Entry Number:        32  APFCMD\nE2 Table Entry Number:        33  ASUB\nE2 Table Entry Number:        34  AU\nE2 Table Entry Number:        35  BACKUP\nE2 Table Entry Number:        36  BCMDEL\nE2 Table Entry Number:        37  BCMDEL1\nE2 Table Entry Number:        38  BCMNAUTH\nE2 Table Entry Number:        39  BCMNUPD\nE2 Table Entry Number:        40  BDATA\nE2 Table Entry Number:        41  BDMNUPD\nE2 Table Entry Number:        42  BINDDATA\nE2 Table Entry Number:        43  BLKUPD\nE2 Table Entry Number:        44  BUDDSN\nE2 Table Entry Number:        45  BUDGET\nE2 Table Entry Number:        46  CAE$BQRY\nE2 Table Entry Number:        47  CANCELU\nE2 Table Entry Number:        48  CAS9UDTN\nE2 Table Entry Number:        49  CDELPAIR\nE2 Table Entry Number:        50  CDMRSTAT\nE2 Table Entry Number:        51  CDSCB\nE2 Table Entry Number:        52  CESTPAIR\nE2 Table Entry Number:        53  CHKPT\nE2 Table Entry Number:        54  CINMX\nE2 Table Entry Number:        55  CLCHECK\nE2 Table Entry Number:        56  CNVTCAT\nE2 Table Entry Number:        57  CO\nE2 Table Entry Number:        58  COFDMON\nE2 Table Entry Number:        59  CONNECT\nE2 Table Entry Number:        60  CONSPROF\nE2 Table Entry Number:        61  CPSCB\nE2 Table Entry Number:        62  CQUERYSG\nE2 Table Entry Number:        63  CRECOVER\nE2 Table Entry Number:        64  CSCAN\nE2 Table Entry Number:        65  CSUSPEND\nE2 Table Entry Number:        66  DCAS\nE2 Table Entry Number:        67  DD\nE2 Table Entry Number:        68  DDIR\nE2 Table Entry Number:        69  DEF\nE2 Table Entry Number:        70  DEFINE\nE2 Table Entry Number:        71  DEL\nE2 Table Entry Number:        72  DELDIR\nE2 Table Entry Number:        73  DELDSD\nE2 Table Entry Number:        74  DELETE\nE2 Table Entry Number:        75  DELFILE\nE2 Table Entry Number:        76  DELGROUP\nE2 Table Entry Number:        77  DELUSER\nE2 Table Entry Number:        78  DF\nE2 Table Entry Number:        79  DG\nE2 Table Entry Number:        80  DITTO\nE2 Table Entry Number:        81  DITTOA\nE2 Table Entry Number:        82  DITTOU\nE2 Table Entry Number:        83  DMRSHR\nE2 Table Entry Number:        84  DRI\nE2 Table Entry Number:        85  DU\nE2 Table Entry Number:        86  ERWMAUTH\nE2 Table Entry Number:        87  EX\nE2 Table Entry Number:        88  EXP\nE2 Table Entry Number:        89  EXPORT\nE2 Table Entry Number:        90  EYU9XENF\nE2 Table Entry Number:        91  EZAZSSI\nE2 Table Entry Number:        92  EZBREINI\nE2 Table Entry Number:        93  EZBTNINI\nE2 Table Entry Number:        94  FCESTABL\nE2 Table Entry Number:        95  FCQUERY\nE2 Table Entry Number:        96  FCWITHDR\nE2 Table Entry Number:        97  FTPD\nE2 Table Entry Number:        98  FTPDNS\nE2 Table Entry Number:        99  GJTRUCBS\nE2 Table Entry Number:       100  IEBCOPY\nE2 Table Entry Number:       101  IKJEHDSF\nE2 Table Entry Number:       102  IKJEHDS1\nE2 Table Entry Number:       103  IKJPRMLB\nE2 Table Entry Number:       104  IM\nE2 Table Entry Number:       105  IMP\nE2 Table Entry Number:       106  IMPORT\nE2 Table Entry Number:       107  IOBSNMP\nE2 Table Entry Number:       108  IQIEXPN\nE2 Table Entry Number:       109  IQIMAIN\nE2 Table Entry Number:       110  IQIQUERY\nE2 Table Entry Number:       111  IQIQUIT\nE2 Table Entry Number:       112  IRRDPI00\nE2 Table Entry Number:       113  ISPICP\nE2 Table Entry Number:       114  ISRPCP\nE2 Table Entry Number:       115  LBADV\nE2 Table Entry Number:       116  LBAGENT\nE2 Table Entry Number:       117  LD\nE2 Table Entry Number:       118  LDATA\nE2 Table Entry Number:       119  LDIR\nE2 Table Entry Number:       120  LDIRECT\nE2 Table Entry Number:       121  LF\nE2 Table Entry Number:       122  LFILE\nE2 Table Entry Number:       123  LG\nE2 Table Entry Number:       124  LISTB\nE2 Table Entry Number:       125  LISTBC\nE2 Table Entry Number:       126  LISTD\nE2 Table Entry Number:       127  LISTDATA\nE2 Table Entry Number:       128  LISTDS\nE2 Table Entry Number:       129  LISTDSD\nE2 Table Entry Number:       130  LISTGRP\nE2 Table Entry Number:       131  LISTUSER\nE2 Table Entry Number:       132  LLWA\nE2 Table Entry Number:       133  LMRKTSO\nE2 Table Entry Number:       134  LOCKTERM\nE2 Table Entry Number:       135  LOOK\nE2 Table Entry Number:       136  LPQ\nE2 Table Entry Number:       137  LPR\nE2 Table Entry Number:       138  LPRM\nE2 Table Entry Number:       139  LPROC\nE2 Table Entry Number:       140  LSLT\nE2 Table Entry Number:       141  LU\nE2 Table Entry Number:       142  LWATMGR\nE2 Table Entry Number:       143  MAKEUSER\nE2 Table Entry Number:       144  MIMTSO\nE2 Table Entry Number:       145  MODDVIPA\nE2 Table Entry Number:       146  MU\nE2 Table Entry Number:       147  MVPMAIN\nE2 Table Entry Number:       148  MVPXDISP\nE2 Table Entry Number:       149  MVSCPCMD\nE2 Table Entry Number:       150  NAMEDXFR\nE2 Table Entry Number:       151  NAMED4\nE2 Table Entry Number:       152  NDVRC1\nE2 Table Entry Number:       153  NETSTAT\nE2 Table Entry Number:       154  NSUPDATE\nE2 Table Entry Number:       155  NSUPDAT4\nE2 Table Entry Number:       156  NYPPW\nE2 Table Entry Number:       157  OC\nE2 Table Entry Number:       158  OMPROUTE\nE2 Table Entry Number:       159  OP\nE2 Table Entry Number:       160  OPER\nE2 Table Entry Number:       161  OPERATOR\nE2 Table Entry Number:       162  OPINFO\nE2 Table Entry Number:       163  OPING\nE2 Table Entry Number:       164  OPSCMD\nE2 Table Entry Number:       165  OPSCONSL\nE2 Table Entry Number:       166  OPSOSCMD\nE2 Table Entry Number:       167  OPSPARM\nE2 Table Entry Number:       168  OPSREPLY\nE2 Table Entry Number:       169  OPSTAT\nE2 Table Entry Number:       170  OPSWTO\nE2 Table Entry Number:       171  OSNMPD\nE2 Table Entry Number:       172  OTRACERT\nE2 Table Entry Number:       173  PACKRAT\nE2 Table Entry Number:       174  PARMLIB\nE2 Table Entry Number:       175  PASSWORD\nE2 Table Entry Number:       176  PDIR\nE2 Table Entry Number:       177  PDSCLEAN\nE2 Table Entry Number:       178  PDSEAUTH\nE2 Table Entry Number:       179  PE\nE2 Table Entry Number:       180  PERMDIR\nE2 Table Entry Number:       181  PERMFILE\nE2 Table Entry Number:       182  PERMIT\nE2 Table Entry Number:       183  PF\nE2 Table Entry Number:       184  PHRASE\nE2 Table Entry Number:       185  PING\nE2 Table Entry Number:       186  POPPER\nE2 Table Entry Number:       187  PRINT\nE2 Table Entry Number:       188  PW\nE2 Table Entry Number:       189  Q\nE2 Table Entry Number:       190  QUEUE\nE2 Table Entry Number:       191  Q522\nE2 Table Entry Number:       192  RACDCERT\nE2 Table Entry Number:       193  RACFSIM\nE2 Table Entry Number:       194  RACLINK\nE2 Table Entry Number:       195  RACONVRT\nE2 Table Entry Number:       196  RACPRIV\nE2 Table Entry Number:       197  RALT\nE2 Table Entry Number:       198  RALTER\nE2 Table Entry Number:       199  RDEF\nE2 Table Entry Number:       200  RDEFINE\nE2 Table Entry Number:       201  RDEL\nE2 Table Entry Number:       202  RDELETE\nE2 Table Entry Number:       203  RE\nE2 Table Entry Number:       204  RECEIVE\nE2 Table Entry Number:       205  RELOGON\nE2 Table Entry Number:       206  REMOVE\nE2 Table Entry Number:       207  REPRO\nE2 Table Entry Number:       208  RESOLVE\nE2 Table Entry Number:       209  REVIEW\nE2 Table Entry Number:       210  REVVSAM\nE2 Table Entry Number:       211  REXCPCMD\nE2 Table Entry Number:       212  RL\nE2 Table Entry Number:       213  RLIST\nE2 Table Entry Number:       214  RLOAD\nE2 Table Entry Number:       215  RLOADA\nE2 Table Entry Number:       216  RMM\nE2 Table Entry Number:       217  RPF\nE2 Table Entry Number:       218  RPFE\nE2 Table Entry Number:       219  RSH\nE2 Table Entry Number:       220  RSHD\nE2 Table Entry Number:       221  RVARY\nE2 Table Entry Number:       222  SAMENDM\nE2 Table Entry Number:       223  SDSF\nE2 Table Entry Number:       224  SE\nE2 Table Entry Number:       225  SEARCH\nE2 Table Entry Number:       226  SECURE\nE2 Table Entry Number:       227  SEND\nE2 Table Entry Number:       228  SETC\nE2 Table Entry Number:       229  SETCACHE\nE2 Table Entry Number:       230  SETPASSW\nE2 Table Entry Number:       231  SETPW\nE2 Table Entry Number:       232  SETPW2\nE2 Table Entry Number:       233  SETR\nE2 Table Entry Number:       234  SETROPTS\nE2 Table Entry Number:       235  SETUSER\nE2 Table Entry Number:       236  SHCDS\nE2 Table Entry Number:       237  SM\nE2 Table Entry Number:       238  SMTP\nE2 Table Entry Number:       239  SNTPD\nE2 Table Entry Number:       240  SPACE\nE2 Table Entry Number:       241  SPY\nE2 Table Entry Number:       242  SR\nE2 Table Entry Number:       243  SRDIR\nE2 Table Entry Number:       244  SRF\nE2 Table Entry Number:       245  SRFILE\nE2 Table Entry Number:       246  SRSTAT\nE2 Table Entry Number:       247  STEPLIB\nE2 Table Entry Number:       248  STEPLIBN\nE2 Table Entry Number:       249  SU\nE2 Table Entry Number:       250  SYNC\nE2 Table Entry Number:       251  SYSPROG\nE2 Table Entry Number:       252  TEAEXTSO\nE2 Table Entry Number:       253  TERM\nE2 Table Entry Number:       254  TERMINAL\nE2 Table Entry Number:       255  TESTA\nE2 Table Entry Number:       256  TESTAUTH\nE2 Table Entry Number:       257  TMONCICS\nE2 Table Entry Number:       258  TMONDB2\nE2 Table Entry Number:       259  TMONIMS\nE2 Table Entry Number:       260  TMONMVS\nE2 Table Entry Number:       261  TRACERTE\nE2 Table Entry Number:       262  TRANSMIT\nE2 Table Entry Number:       263  TRAPFWD\nE2 Table Entry Number:       264  TRMD\nE2 Table Entry Number:       265  TSOENQ\nE2 Table Entry Number:       266  TSOSMS\nE2 Table Entry Number:       267  TSUB\nE2 Table Entry Number:       268  UKEYCSA\nE2 Table Entry Number:       269  USAT\nE2 Table Entry Number:       270  USIT\nE2 Table Entry Number:       271  USOT\nE2 Table Entry Number:       272  USUT\nE2 Table Entry Number:       273  VERIFY\nE2 Table Entry Number:       274  VFY\nE2 Table Entry Number:       275  VIEWUSER\nE2 Table Entry Number:       276  VLFNOTE\nE2 Table Entry Number:       277  VMCF\nE2 Table Entry Number:       278  VU\nE2 Table Entry Number:       279  WAITT\nE2 Table Entry Number:       280  WHOENQ\nE2 Table Entry Number:       281  WSSTAT\nE2 Table Entry Number:       282  XD\nE2 Table Entry Number:       283  XDCCALLA\nE2 Table Entry Number:       284  XDCCMDA\nE2 Table Entry Number:       285  XF\nE2 Table Entry Number:       286  XMDSMAIN\nE2 Table Entry Number:       287  XMIT\nE2 Table Entry Number:       288  XTRCUSER\nE2 Table Entry Number:       289  XU\nE2 Table Entry Number:       290  YKCONMSG\nE2 Table Entry Number:       291  ZAP\nE2 Table Entry Number:       292  ZAP$\nE2 Table Entry Number:       293  ZAPLWA\nE2 Table Entry Number:       294  ZAPV\nE2 Table Entry Number:       295  CQX\nE2 Table Entry Number:       296  *empty*\n\nReturn Code = 0\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TSUB#06": {"ttr": 12033, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x002\\x01\\t\\x04\\x8f\\x01\\t\\x04\\x8f\\x08G\\x01V\\x00\\x08\\x00\\x00```````@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2009-02-17T00:00:00", "modifydate": "2009-02-17T08:47:32", "lines": 342, "newlines": 8, "modlines": 0, "user": "-------"}, "text": "Output of command:  TSUB E2M    (like E2L except the new length\n                                 only includes ONE blank at the end.)\n\n     This command measures the length of the IKJEFTE2 table in\n     the user's address space, to (and including) the first blank\n     table entry.  Then this length is plugged into the LWA field\n     which is supposed to contain the length of the IKJEFTE2 table.\n     The messages below, tell you what happened.  Another TSUB E2D\n     command will tell you the resulting state of the E2 table.\n\n\nTSUB Command - Display or Change Auth Table or Entry\n---- -------   ------- -- ------ ---- ----- -- -----\n\n  **--- STATE BEFORE MAKING TABLE CHANGES ---**\nE2M   10     Program table code + Function code\nTable address:      0000C000\nTable address is not within an LPA region.\nNon-blank table entries:     295   (these are the ones used)\nPerceived blank entries:      29   (potential for expansion)\nTable E2 pointed to by the LWA has length available. Hex 0A30.\nTable E2 pointed to by the LWA came from an APF STEPLIB.\nTable Header:  IKJEFTE276.152\nNumber of valid entries:     324\n\n  **--------   AFTER MAKING CHANGES   -------**\nLWA size for table E2 has been changed from Hex 0A30 to Hex 0950.\nTable E2 pointed to by the LWA has length available. Hex 0950.\n\nReturn Code = 0\n\n-----------------------------------------------------------------\n\nTSUB Command - Display or Change Auth Table or Entry\n---- -------   ------- -- ------ ---- ----- -- -----\nE2D   04     Program table code + Function code\nTable address:      0000C000\nTable address is not within an LPA region.\nNon-blank table entries:     295   (these are the ones used)\nPerceived blank entries:      29   (potential for expansion)\nTable E2 pointed to by the LWA has length available. Hex 0950.\nTable E2 pointed to by the LWA came from an APF STEPLIB.\nTable Header:  IKJEFTE276.152\nNumber of valid entries:     296\nE2 Table Entry Number:         1  $$\nE2 Table Entry Number:         2  $HOWMVS\nE2 Table Entry Number:         3  $MDSMAIN\nE2 Table Entry Number:         4  ABUDSN\nE2 Table Entry Number:         5  AD\nE2 Table Entry Number:         6  ADB2UTIL\nE2 Table Entry Number:         7  ADDDIR\nE2 Table Entry Number:         8  ADDFILE\nE2 Table Entry Number:         9  ADDGROUP\nE2 Table Entry Number:        10  ADDSD\nE2 Table Entry Number:        11  ADDUSER\nE2 Table Entry Number:        12  ADIR\nE2 Table Entry Number:        13  ADNR\nE2 Table Entry Number:        14  ADYOPCMD\nE2 Table Entry Number:        15  AF\nE2 Table Entry Number:        16  AG\nE2 Table Entry Number:        17  AHOWMVS\nE2 Table Entry Number:        18  ALD\nE2 Table Entry Number:        19  ALF\nE2 Table Entry Number:        20  ALG\nE2 Table Entry Number:        21  ALTDIR\nE2 Table Entry Number:        22  ALTDSD\nE2 Table Entry Number:        23  ALTER\nE2 Table Entry Number:        24  ALTFILE\nE2 Table Entry Number:        25  ALTGROUP\nE2 Table Entry Number:        26  ALTUSER\nE2 Table Entry Number:        27  ALU\nE2 Table Entry Number:        28  APCACBL\nE2 Table Entry Number:        29  APCANB\nE2 Table Entry Number:        30  APCARB\nE2 Table Entry Number:        31  APCAUB\nE2 Table Entry Number:        32  APFCMD\nE2 Table Entry Number:        33  ASUB\nE2 Table Entry Number:        34  AU\nE2 Table Entry Number:        35  BACKUP\nE2 Table Entry Number:        36  BCMDEL\nE2 Table Entry Number:        37  BCMDEL1\nE2 Table Entry Number:        38  BCMNAUTH\nE2 Table Entry Number:        39  BCMNUPD\nE2 Table Entry Number:        40  BDATA\nE2 Table Entry Number:        41  BDMNUPD\nE2 Table Entry Number:        42  BINDDATA\nE2 Table Entry Number:        43  BLKUPD\nE2 Table Entry Number:        44  BUDDSN\nE2 Table Entry Number:        45  BUDGET\nE2 Table Entry Number:        46  CAE$BQRY\nE2 Table Entry Number:        47  CANCELU\nE2 Table Entry Number:        48  CAS9UDTN\nE2 Table Entry Number:        49  CDELPAIR\nE2 Table Entry Number:        50  CDMRSTAT\nE2 Table Entry Number:        51  CDSCB\nE2 Table Entry Number:        52  CESTPAIR\nE2 Table Entry Number:        53  CHKPT\nE2 Table Entry Number:        54  CINMX\nE2 Table Entry Number:        55  CLCHECK\nE2 Table Entry Number:        56  CNVTCAT\nE2 Table Entry Number:        57  CO\nE2 Table Entry Number:        58  COFDMON\nE2 Table Entry Number:        59  CONNECT\nE2 Table Entry Number:        60  CONSPROF\nE2 Table Entry Number:        61  CPSCB\nE2 Table Entry Number:        62  CQUERYSG\nE2 Table Entry Number:        63  CRECOVER\nE2 Table Entry Number:        64  CSCAN\nE2 Table Entry Number:        65  CSUSPEND\nE2 Table Entry Number:        66  DCAS\nE2 Table Entry Number:        67  DD\nE2 Table Entry Number:        68  DDIR\nE2 Table Entry Number:        69  DEF\nE2 Table Entry Number:        70  DEFINE\nE2 Table Entry Number:        71  DEL\nE2 Table Entry Number:        72  DELDIR\nE2 Table Entry Number:        73  DELDSD\nE2 Table Entry Number:        74  DELETE\nE2 Table Entry Number:        75  DELFILE\nE2 Table Entry Number:        76  DELGROUP\nE2 Table Entry Number:        77  DELUSER\nE2 Table Entry Number:        78  DF\nE2 Table Entry Number:        79  DG\nE2 Table Entry Number:        80  DITTO\nE2 Table Entry Number:        81  DITTOA\nE2 Table Entry Number:        82  DITTOU\nE2 Table Entry Number:        83  DMRSHR\nE2 Table Entry Number:        84  DRI\nE2 Table Entry Number:        85  DU\nE2 Table Entry Number:        86  ERWMAUTH\nE2 Table Entry Number:        87  EX\nE2 Table Entry Number:        88  EXP\nE2 Table Entry Number:        89  EXPORT\nE2 Table Entry Number:        90  EYU9XENF\nE2 Table Entry Number:        91  EZAZSSI\nE2 Table Entry Number:        92  EZBREINI\nE2 Table Entry Number:        93  EZBTNINI\nE2 Table Entry Number:        94  FCESTABL\nE2 Table Entry Number:        95  FCQUERY\nE2 Table Entry Number:        96  FCWITHDR\nE2 Table Entry Number:        97  FTPD\nE2 Table Entry Number:        98  FTPDNS\nE2 Table Entry Number:        99  GJTRUCBS\nE2 Table Entry Number:       100  IEBCOPY\nE2 Table Entry Number:       101  IKJEHDSF\nE2 Table Entry Number:       102  IKJEHDS1\nE2 Table Entry Number:       103  IKJPRMLB\nE2 Table Entry Number:       104  IM\nE2 Table Entry Number:       105  IMP\nE2 Table Entry Number:       106  IMPORT\nE2 Table Entry Number:       107  IOBSNMP\nE2 Table Entry Number:       108  IQIEXPN\nE2 Table Entry Number:       109  IQIMAIN\nE2 Table Entry Number:       110  IQIQUERY\nE2 Table Entry Number:       111  IQIQUIT\nE2 Table Entry Number:       112  IRRDPI00\nE2 Table Entry Number:       113  ISPICP\nE2 Table Entry Number:       114  ISRPCP\nE2 Table Entry Number:       115  LBADV\nE2 Table Entry Number:       116  LBAGENT\nE2 Table Entry Number:       117  LD\nE2 Table Entry Number:       118  LDATA\nE2 Table Entry Number:       119  LDIR\nE2 Table Entry Number:       120  LDIRECT\nE2 Table Entry Number:       121  LF\nE2 Table Entry Number:       122  LFILE\nE2 Table Entry Number:       123  LG\nE2 Table Entry Number:       124  LISTB\nE2 Table Entry Number:       125  LISTBC\nE2 Table Entry Number:       126  LISTD\nE2 Table Entry Number:       127  LISTDATA\nE2 Table Entry Number:       128  LISTDS\nE2 Table Entry Number:       129  LISTDSD\nE2 Table Entry Number:       130  LISTGRP\nE2 Table Entry Number:       131  LISTUSER\nE2 Table Entry Number:       132  LLWA\nE2 Table Entry Number:       133  LMRKTSO\nE2 Table Entry Number:       134  LOCKTERM\nE2 Table Entry Number:       135  LOOK\nE2 Table Entry Number:       136  LPQ\nE2 Table Entry Number:       137  LPR\nE2 Table Entry Number:       138  LPRM\nE2 Table Entry Number:       139  LPROC\nE2 Table Entry Number:       140  LSLT\nE2 Table Entry Number:       141  LU\nE2 Table Entry Number:       142  LWATMGR\nE2 Table Entry Number:       143  MAKEUSER\nE2 Table Entry Number:       144  MIMTSO\nE2 Table Entry Number:       145  MODDVIPA\nE2 Table Entry Number:       146  MU\nE2 Table Entry Number:       147  MVPMAIN\nE2 Table Entry Number:       148  MVPXDISP\nE2 Table Entry Number:       149  MVSCPCMD\nE2 Table Entry Number:       150  NAMEDXFR\nE2 Table Entry Number:       151  NAMED4\nE2 Table Entry Number:       152  NDVRC1\nE2 Table Entry Number:       153  NETSTAT\nE2 Table Entry Number:       154  NSUPDATE\nE2 Table Entry Number:       155  NSUPDAT4\nE2 Table Entry Number:       156  NYPPW\nE2 Table Entry Number:       157  OC\nE2 Table Entry Number:       158  OMPROUTE\nE2 Table Entry Number:       159  OP\nE2 Table Entry Number:       160  OPER\nE2 Table Entry Number:       161  OPERATOR\nE2 Table Entry Number:       162  OPINFO\nE2 Table Entry Number:       163  OPING\nE2 Table Entry Number:       164  OPSCMD\nE2 Table Entry Number:       165  OPSCONSL\nE2 Table Entry Number:       166  OPSOSCMD\nE2 Table Entry Number:       167  OPSPARM\nE2 Table Entry Number:       168  OPSREPLY\nE2 Table Entry Number:       169  OPSTAT\nE2 Table Entry Number:       170  OPSWTO\nE2 Table Entry Number:       171  OSNMPD\nE2 Table Entry Number:       172  OTRACERT\nE2 Table Entry Number:       173  PACKRAT\nE2 Table Entry Number:       174  PARMLIB\nE2 Table Entry Number:       175  PASSWORD\nE2 Table Entry Number:       176  PDIR\nE2 Table Entry Number:       177  PDSCLEAN\nE2 Table Entry Number:       178  PDSEAUTH\nE2 Table Entry Number:       179  PE\nE2 Table Entry Number:       180  PERMDIR\nE2 Table Entry Number:       181  PERMFILE\nE2 Table Entry Number:       182  PERMIT\nE2 Table Entry Number:       183  PF\nE2 Table Entry Number:       184  PHRASE\nE2 Table Entry Number:       185  PING\nE2 Table Entry Number:       186  POPPER\nE2 Table Entry Number:       187  PRINT\nE2 Table Entry Number:       188  PW\nE2 Table Entry Number:       189  Q\nE2 Table Entry Number:       190  QUEUE\nE2 Table Entry Number:       191  Q522\nE2 Table Entry Number:       192  RACDCERT\nE2 Table Entry Number:       193  RACFSIM\nE2 Table Entry Number:       194  RACLINK\nE2 Table Entry Number:       195  RACONVRT\nE2 Table Entry Number:       196  RACPRIV\nE2 Table Entry Number:       197  RALT\nE2 Table Entry Number:       198  RALTER\nE2 Table Entry Number:       199  RDEF\nE2 Table Entry Number:       200  RDEFINE\nE2 Table Entry Number:       201  RDEL\nE2 Table Entry Number:       202  RDELETE\nE2 Table Entry Number:       203  RE\nE2 Table Entry Number:       204  RECEIVE\nE2 Table Entry Number:       205  RELOGON\nE2 Table Entry Number:       206  REMOVE\nE2 Table Entry Number:       207  REPRO\nE2 Table Entry Number:       208  RESOLVE\nE2 Table Entry Number:       209  REVIEW\nE2 Table Entry Number:       210  REVVSAM\nE2 Table Entry Number:       211  REXCPCMD\nE2 Table Entry Number:       212  RL\nE2 Table Entry Number:       213  RLIST\nE2 Table Entry Number:       214  RLOAD\nE2 Table Entry Number:       215  RLOADA\nE2 Table Entry Number:       216  RMM\nE2 Table Entry Number:       217  RPF\nE2 Table Entry Number:       218  RPFE\nE2 Table Entry Number:       219  RSH\nE2 Table Entry Number:       220  RSHD\nE2 Table Entry Number:       221  RVARY\nE2 Table Entry Number:       222  SAMENDM\nE2 Table Entry Number:       223  SDSF\nE2 Table Entry Number:       224  SE\nE2 Table Entry Number:       225  SEARCH\nE2 Table Entry Number:       226  SECURE\nE2 Table Entry Number:       227  SEND\nE2 Table Entry Number:       228  SETC\nE2 Table Entry Number:       229  SETCACHE\nE2 Table Entry Number:       230  SETPASSW\nE2 Table Entry Number:       231  SETPW\nE2 Table Entry Number:       232  SETPW2\nE2 Table Entry Number:       233  SETR\nE2 Table Entry Number:       234  SETROPTS\nE2 Table Entry Number:       235  SETUSER\nE2 Table Entry Number:       236  SHCDS\nE2 Table Entry Number:       237  SM\nE2 Table Entry Number:       238  SMTP\nE2 Table Entry Number:       239  SNTPD\nE2 Table Entry Number:       240  SPACE\nE2 Table Entry Number:       241  SPY\nE2 Table Entry Number:       242  SR\nE2 Table Entry Number:       243  SRDIR\nE2 Table Entry Number:       244  SRF\nE2 Table Entry Number:       245  SRFILE\nE2 Table Entry Number:       246  SRSTAT\nE2 Table Entry Number:       247  STEPLIB\nE2 Table Entry Number:       248  STEPLIBN\nE2 Table Entry Number:       249  SU\nE2 Table Entry Number:       250  SYNC\nE2 Table Entry Number:       251  SYSPROG\nE2 Table Entry Number:       252  TEAEXTSO\nE2 Table Entry Number:       253  TERM\nE2 Table Entry Number:       254  TERMINAL\nE2 Table Entry Number:       255  TESTA\nE2 Table Entry Number:       256  TESTAUTH\nE2 Table Entry Number:       257  TMONCICS\nE2 Table Entry Number:       258  TMONDB2\nE2 Table Entry Number:       259  TMONIMS\nE2 Table Entry Number:       260  TMONMVS\nE2 Table Entry Number:       261  TRACERTE\nE2 Table Entry Number:       262  TRANSMIT\nE2 Table Entry Number:       263  TRAPFWD\nE2 Table Entry Number:       264  TRMD\nE2 Table Entry Number:       265  TSOENQ\nE2 Table Entry Number:       266  TSOSMS\nE2 Table Entry Number:       267  TSUB\nE2 Table Entry Number:       268  UKEYCSA\nE2 Table Entry Number:       269  USAT\nE2 Table Entry Number:       270  USIT\nE2 Table Entry Number:       271  USOT\nE2 Table Entry Number:       272  USUT\nE2 Table Entry Number:       273  VERIFY\nE2 Table Entry Number:       274  VFY\nE2 Table Entry Number:       275  VIEWUSER\nE2 Table Entry Number:       276  VLFNOTE\nE2 Table Entry Number:       277  VMCF\nE2 Table Entry Number:       278  VU\nE2 Table Entry Number:       279  WAITT\nE2 Table Entry Number:       280  WHOENQ\nE2 Table Entry Number:       281  WSSTAT\nE2 Table Entry Number:       282  XD\nE2 Table Entry Number:       283  XDCCALLA\nE2 Table Entry Number:       284  XDCCMDA\nE2 Table Entry Number:       285  XF\nE2 Table Entry Number:       286  XMDSMAIN\nE2 Table Entry Number:       287  XMIT\nE2 Table Entry Number:       288  XTRCUSER\nE2 Table Entry Number:       289  XU\nE2 Table Entry Number:       290  YKCONMSG\nE2 Table Entry Number:       291  ZAP\nE2 Table Entry Number:       292  ZAP$\nE2 Table Entry Number:       293  ZAPLWA\nE2 Table Entry Number:       294  ZAPV\nE2 Table Entry Number:       295  CQX\nE2 Table Entry Number:       296  *empty*\n\nReturn Code = 0\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TSUB#07": {"ttr": 12039, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00A\\x01\\t\\x04\\x8f\\x01\\t\\x04\\x8f\\x08R\\x01T\\x00\\x07\\x00\\x00```````@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2009-02-17T00:00:00", "modifydate": "2009-02-17T08:52:41", "lines": 340, "newlines": 7, "modlines": 0, "user": "-------"}, "text": "Output of command:  TSUB E2Z\n\n     This command zeroes the length of the IKJEFTE2 table in the\n     user's address space, as marked in the LWA field that contains\n     the length of the IKJEFTE2 table.  The messages below, tell\n     you what happened.  TSUB E2D tells you the resulting state of\n     the E2 table.\n\n\nTSUB Command - Display or Change Auth Table or Entry\n---- -------   ------- -- ------ ---- ----- -- -----\n\n  **--- STATE BEFORE MAKING TABLE CHANGES ---**\nE2Z   20     Program table code + Function code\nTable address:      0000C000\nTable address is not within an LPA region.\nNon-blank table entries:     295   (these are the ones used)\nPerceived blank entries:      29   (potential for expansion)\nTable E2 pointed to by the LWA has length available. Hex 0950.\nTable E2 pointed to by the LWA came from an APF STEPLIB.\nTable Header:  IKJEFTE276.152\nNumber of valid entries:     296\n\n  **--------   AFTER MAKING CHANGES   -------**\nLWA size for table E2 is now Hex 0000.\nTable E2 pointed to by the LWA has no lengths. Blanks will delimit.\n\nReturn Code = 0\n\n--------------------------------------------------------------------\n\nTSUB Command - Display or Change Auth Table or Entry\n---- -------   ------- -- ------ ---- ----- -- -----\nE2D   04     Program table code + Function code\nTable address:      0000C000\nTable address is not within an LPA region.\nNon-blank table entries:     295   (these are the ones used)\nPerceived blank entries:      29   (potential for expansion)\nTable E2 pointed to by the LWA has no lengths. Blanks will delimit.\nTable E2 pointed to by the LWA came from an APF STEPLIB.\nTable Header:  IKJEFTE276.152\nNumber of valid entries:     296\nE2 Table Entry Number:         1  $$\nE2 Table Entry Number:         2  $HOWMVS\nE2 Table Entry Number:         3  $MDSMAIN\nE2 Table Entry Number:         4  ABUDSN\nE2 Table Entry Number:         5  AD\nE2 Table Entry Number:         6  ADB2UTIL\nE2 Table Entry Number:         7  ADDDIR\nE2 Table Entry Number:         8  ADDFILE\nE2 Table Entry Number:         9  ADDGROUP\nE2 Table Entry Number:        10  ADDSD\nE2 Table Entry Number:        11  ADDUSER\nE2 Table Entry Number:        12  ADIR\nE2 Table Entry Number:        13  ADNR\nE2 Table Entry Number:        14  ADYOPCMD\nE2 Table Entry Number:        15  AF\nE2 Table Entry Number:        16  AG\nE2 Table Entry Number:        17  AHOWMVS\nE2 Table Entry Number:        18  ALD\nE2 Table Entry Number:        19  ALF\nE2 Table Entry Number:        20  ALG\nE2 Table Entry Number:        21  ALTDIR\nE2 Table Entry Number:        22  ALTDSD\nE2 Table Entry Number:        23  ALTER\nE2 Table Entry Number:        24  ALTFILE\nE2 Table Entry Number:        25  ALTGROUP\nE2 Table Entry Number:        26  ALTUSER\nE2 Table Entry Number:        27  ALU\nE2 Table Entry Number:        28  APCACBL\nE2 Table Entry Number:        29  APCANB\nE2 Table Entry Number:        30  APCARB\nE2 Table Entry Number:        31  APCAUB\nE2 Table Entry Number:        32  APFCMD\nE2 Table Entry Number:        33  ASUB\nE2 Table Entry Number:        34  AU\nE2 Table Entry Number:        35  BACKUP\nE2 Table Entry Number:        36  BCMDEL\nE2 Table Entry Number:        37  BCMDEL1\nE2 Table Entry Number:        38  BCMNAUTH\nE2 Table Entry Number:        39  BCMNUPD\nE2 Table Entry Number:        40  BDATA\nE2 Table Entry Number:        41  BDMNUPD\nE2 Table Entry Number:        42  BINDDATA\nE2 Table Entry Number:        43  BLKUPD\nE2 Table Entry Number:        44  BUDDSN\nE2 Table Entry Number:        45  BUDGET\nE2 Table Entry Number:        46  CAE$BQRY\nE2 Table Entry Number:        47  CANCELU\nE2 Table Entry Number:        48  CAS9UDTN\nE2 Table Entry Number:        49  CDELPAIR\nE2 Table Entry Number:        50  CDMRSTAT\nE2 Table Entry Number:        51  CDSCB\nE2 Table Entry Number:        52  CESTPAIR\nE2 Table Entry Number:        53  CHKPT\nE2 Table Entry Number:        54  CINMX\nE2 Table Entry Number:        55  CLCHECK\nE2 Table Entry Number:        56  CNVTCAT\nE2 Table Entry Number:        57  CO\nE2 Table Entry Number:        58  COFDMON\nE2 Table Entry Number:        59  CONNECT\nE2 Table Entry Number:        60  CONSPROF\nE2 Table Entry Number:        61  CPSCB\nE2 Table Entry Number:        62  CQUERYSG\nE2 Table Entry Number:        63  CRECOVER\nE2 Table Entry Number:        64  CSCAN\nE2 Table Entry Number:        65  CSUSPEND\nE2 Table Entry Number:        66  DCAS\nE2 Table Entry Number:        67  DD\nE2 Table Entry Number:        68  DDIR\nE2 Table Entry Number:        69  DEF\nE2 Table Entry Number:        70  DEFINE\nE2 Table Entry Number:        71  DEL\nE2 Table Entry Number:        72  DELDIR\nE2 Table Entry Number:        73  DELDSD\nE2 Table Entry Number:        74  DELETE\nE2 Table Entry Number:        75  DELFILE\nE2 Table Entry Number:        76  DELGROUP\nE2 Table Entry Number:        77  DELUSER\nE2 Table Entry Number:        78  DF\nE2 Table Entry Number:        79  DG\nE2 Table Entry Number:        80  DITTO\nE2 Table Entry Number:        81  DITTOA\nE2 Table Entry Number:        82  DITTOU\nE2 Table Entry Number:        83  DMRSHR\nE2 Table Entry Number:        84  DRI\nE2 Table Entry Number:        85  DU\nE2 Table Entry Number:        86  ERWMAUTH\nE2 Table Entry Number:        87  EX\nE2 Table Entry Number:        88  EXP\nE2 Table Entry Number:        89  EXPORT\nE2 Table Entry Number:        90  EYU9XENF\nE2 Table Entry Number:        91  EZAZSSI\nE2 Table Entry Number:        92  EZBREINI\nE2 Table Entry Number:        93  EZBTNINI\nE2 Table Entry Number:        94  FCESTABL\nE2 Table Entry Number:        95  FCQUERY\nE2 Table Entry Number:        96  FCWITHDR\nE2 Table Entry Number:        97  FTPD\nE2 Table Entry Number:        98  FTPDNS\nE2 Table Entry Number:        99  GJTRUCBS\nE2 Table Entry Number:       100  IEBCOPY\nE2 Table Entry Number:       101  IKJEHDSF\nE2 Table Entry Number:       102  IKJEHDS1\nE2 Table Entry Number:       103  IKJPRMLB\nE2 Table Entry Number:       104  IM\nE2 Table Entry Number:       105  IMP\nE2 Table Entry Number:       106  IMPORT\nE2 Table Entry Number:       107  IOBSNMP\nE2 Table Entry Number:       108  IQIEXPN\nE2 Table Entry Number:       109  IQIMAIN\nE2 Table Entry Number:       110  IQIQUERY\nE2 Table Entry Number:       111  IQIQUIT\nE2 Table Entry Number:       112  IRRDPI00\nE2 Table Entry Number:       113  ISPICP\nE2 Table Entry Number:       114  ISRPCP\nE2 Table Entry Number:       115  LBADV\nE2 Table Entry Number:       116  LBAGENT\nE2 Table Entry Number:       117  LD\nE2 Table Entry Number:       118  LDATA\nE2 Table Entry Number:       119  LDIR\nE2 Table Entry Number:       120  LDIRECT\nE2 Table Entry Number:       121  LF\nE2 Table Entry Number:       122  LFILE\nE2 Table Entry Number:       123  LG\nE2 Table Entry Number:       124  LISTB\nE2 Table Entry Number:       125  LISTBC\nE2 Table Entry Number:       126  LISTD\nE2 Table Entry Number:       127  LISTDATA\nE2 Table Entry Number:       128  LISTDS\nE2 Table Entry Number:       129  LISTDSD\nE2 Table Entry Number:       130  LISTGRP\nE2 Table Entry Number:       131  LISTUSER\nE2 Table Entry Number:       132  LLWA\nE2 Table Entry Number:       133  LMRKTSO\nE2 Table Entry Number:       134  LOCKTERM\nE2 Table Entry Number:       135  LOOK\nE2 Table Entry Number:       136  LPQ\nE2 Table Entry Number:       137  LPR\nE2 Table Entry Number:       138  LPRM\nE2 Table Entry Number:       139  LPROC\nE2 Table Entry Number:       140  LSLT\nE2 Table Entry Number:       141  LU\nE2 Table Entry Number:       142  LWATMGR\nE2 Table Entry Number:       143  MAKEUSER\nE2 Table Entry Number:       144  MIMTSO\nE2 Table Entry Number:       145  MODDVIPA\nE2 Table Entry Number:       146  MU\nE2 Table Entry Number:       147  MVPMAIN\nE2 Table Entry Number:       148  MVPXDISP\nE2 Table Entry Number:       149  MVSCPCMD\nE2 Table Entry Number:       150  NAMEDXFR\nE2 Table Entry Number:       151  NAMED4\nE2 Table Entry Number:       152  NDVRC1\nE2 Table Entry Number:       153  NETSTAT\nE2 Table Entry Number:       154  NSUPDATE\nE2 Table Entry Number:       155  NSUPDAT4\nE2 Table Entry Number:       156  NYPPW\nE2 Table Entry Number:       157  OC\nE2 Table Entry Number:       158  OMPROUTE\nE2 Table Entry Number:       159  OP\nE2 Table Entry Number:       160  OPER\nE2 Table Entry Number:       161  OPERATOR\nE2 Table Entry Number:       162  OPINFO\nE2 Table Entry Number:       163  OPING\nE2 Table Entry Number:       164  OPSCMD\nE2 Table Entry Number:       165  OPSCONSL\nE2 Table Entry Number:       166  OPSOSCMD\nE2 Table Entry Number:       167  OPSPARM\nE2 Table Entry Number:       168  OPSREPLY\nE2 Table Entry Number:       169  OPSTAT\nE2 Table Entry Number:       170  OPSWTO\nE2 Table Entry Number:       171  OSNMPD\nE2 Table Entry Number:       172  OTRACERT\nE2 Table Entry Number:       173  PACKRAT\nE2 Table Entry Number:       174  PARMLIB\nE2 Table Entry Number:       175  PASSWORD\nE2 Table Entry Number:       176  PDIR\nE2 Table Entry Number:       177  PDSCLEAN\nE2 Table Entry Number:       178  PDSEAUTH\nE2 Table Entry Number:       179  PE\nE2 Table Entry Number:       180  PERMDIR\nE2 Table Entry Number:       181  PERMFILE\nE2 Table Entry Number:       182  PERMIT\nE2 Table Entry Number:       183  PF\nE2 Table Entry Number:       184  PHRASE\nE2 Table Entry Number:       185  PING\nE2 Table Entry Number:       186  POPPER\nE2 Table Entry Number:       187  PRINT\nE2 Table Entry Number:       188  PW\nE2 Table Entry Number:       189  Q\nE2 Table Entry Number:       190  QUEUE\nE2 Table Entry Number:       191  Q522\nE2 Table Entry Number:       192  RACDCERT\nE2 Table Entry Number:       193  RACFSIM\nE2 Table Entry Number:       194  RACLINK\nE2 Table Entry Number:       195  RACONVRT\nE2 Table Entry Number:       196  RACPRIV\nE2 Table Entry Number:       197  RALT\nE2 Table Entry Number:       198  RALTER\nE2 Table Entry Number:       199  RDEF\nE2 Table Entry Number:       200  RDEFINE\nE2 Table Entry Number:       201  RDEL\nE2 Table Entry Number:       202  RDELETE\nE2 Table Entry Number:       203  RE\nE2 Table Entry Number:       204  RECEIVE\nE2 Table Entry Number:       205  RELOGON\nE2 Table Entry Number:       206  REMOVE\nE2 Table Entry Number:       207  REPRO\nE2 Table Entry Number:       208  RESOLVE\nE2 Table Entry Number:       209  REVIEW\nE2 Table Entry Number:       210  REVVSAM\nE2 Table Entry Number:       211  REXCPCMD\nE2 Table Entry Number:       212  RL\nE2 Table Entry Number:       213  RLIST\nE2 Table Entry Number:       214  RLOAD\nE2 Table Entry Number:       215  RLOADA\nE2 Table Entry Number:       216  RMM\nE2 Table Entry Number:       217  RPF\nE2 Table Entry Number:       218  RPFE\nE2 Table Entry Number:       219  RSH\nE2 Table Entry Number:       220  RSHD\nE2 Table Entry Number:       221  RVARY\nE2 Table Entry Number:       222  SAMENDM\nE2 Table Entry Number:       223  SDSF\nE2 Table Entry Number:       224  SE\nE2 Table Entry Number:       225  SEARCH\nE2 Table Entry Number:       226  SECURE\nE2 Table Entry Number:       227  SEND\nE2 Table Entry Number:       228  SETC\nE2 Table Entry Number:       229  SETCACHE\nE2 Table Entry Number:       230  SETPASSW\nE2 Table Entry Number:       231  SETPW\nE2 Table Entry Number:       232  SETPW2\nE2 Table Entry Number:       233  SETR\nE2 Table Entry Number:       234  SETROPTS\nE2 Table Entry Number:       235  SETUSER\nE2 Table Entry Number:       236  SHCDS\nE2 Table Entry Number:       237  SM\nE2 Table Entry Number:       238  SMTP\nE2 Table Entry Number:       239  SNTPD\nE2 Table Entry Number:       240  SPACE\nE2 Table Entry Number:       241  SPY\nE2 Table Entry Number:       242  SR\nE2 Table Entry Number:       243  SRDIR\nE2 Table Entry Number:       244  SRF\nE2 Table Entry Number:       245  SRFILE\nE2 Table Entry Number:       246  SRSTAT\nE2 Table Entry Number:       247  STEPLIB\nE2 Table Entry Number:       248  STEPLIBN\nE2 Table Entry Number:       249  SU\nE2 Table Entry Number:       250  SYNC\nE2 Table Entry Number:       251  SYSPROG\nE2 Table Entry Number:       252  TEAEXTSO\nE2 Table Entry Number:       253  TERM\nE2 Table Entry Number:       254  TERMINAL\nE2 Table Entry Number:       255  TESTA\nE2 Table Entry Number:       256  TESTAUTH\nE2 Table Entry Number:       257  TMONCICS\nE2 Table Entry Number:       258  TMONDB2\nE2 Table Entry Number:       259  TMONIMS\nE2 Table Entry Number:       260  TMONMVS\nE2 Table Entry Number:       261  TRACERTE\nE2 Table Entry Number:       262  TRANSMIT\nE2 Table Entry Number:       263  TRAPFWD\nE2 Table Entry Number:       264  TRMD\nE2 Table Entry Number:       265  TSOENQ\nE2 Table Entry Number:       266  TSOSMS\nE2 Table Entry Number:       267  TSUB\nE2 Table Entry Number:       268  UKEYCSA\nE2 Table Entry Number:       269  USAT\nE2 Table Entry Number:       270  USIT\nE2 Table Entry Number:       271  USOT\nE2 Table Entry Number:       272  USUT\nE2 Table Entry Number:       273  VERIFY\nE2 Table Entry Number:       274  VFY\nE2 Table Entry Number:       275  VIEWUSER\nE2 Table Entry Number:       276  VLFNOTE\nE2 Table Entry Number:       277  VMCF\nE2 Table Entry Number:       278  VU\nE2 Table Entry Number:       279  WAITT\nE2 Table Entry Number:       280  WHOENQ\nE2 Table Entry Number:       281  WSSTAT\nE2 Table Entry Number:       282  XD\nE2 Table Entry Number:       283  XDCCALLA\nE2 Table Entry Number:       284  XDCCMDA\nE2 Table Entry Number:       285  XF\nE2 Table Entry Number:       286  XMDSMAIN\nE2 Table Entry Number:       287  XMIT\nE2 Table Entry Number:       288  XTRCUSER\nE2 Table Entry Number:       289  XU\nE2 Table Entry Number:       290  YKCONMSG\nE2 Table Entry Number:       291  ZAP\nE2 Table Entry Number:       292  ZAP$\nE2 Table Entry Number:       293  ZAPLWA\nE2 Table Entry Number:       294  ZAPV\nE2 Table Entry Number:       295  CQX\nE2 Table Entry Number:       296  *empty*\n\nReturn Code = 0\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TSUB#08": {"ttr": 12291, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x001\\x01\\t\\x04\\x8f\\x01\\t\\x04\\x8f\\x08T\\x00\\x1d\\x00\\n\\x00\\x00```````@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2009-02-17T00:00:00", "modifydate": "2009-02-17T08:54:31", "lines": 29, "newlines": 10, "modlines": 0, "user": "-------"}, "text": "Output of command:  TSUB E2S\n\n     This command throws a bit in the LWA that says that the\n     IKJEFTE2 table came from a STEPLIB, and not from an IKJTSOxx\n     PARMLIB member.  This has the effect that when someone issues\n     a command PARMLIB UPDATE(xx) or SET IKJTSO=xx later, then\n     your IKJEFTE2 table which is now marked that it came from\n     STEPLIB, will not be overlaid from the \"common storage\" copy\n     of the table.\n\n\nTSUB Command - Display or Change Auth Table or Entry\n---- -------   ------- -- ------ ---- ----- -- -----\n\n  **--- STATE BEFORE MAKING TABLE CHANGES ---**\nE2S   40     Program table code + Function code\nTable address:      0000C000\nTable address is not within an LPA region.\nNon-blank table entries:     295   (these are the ones used)\nPerceived blank entries:      29   (potential for expansion)\nTable E2 pointed to by the LWA has no lengths. Blanks will delimit.\nTable E2 pointed to by the LWA came from an APF STEPLIB.\nTable Header:  IKJEFTE276.152\nNumber of valid entries:     296\n\n  **--------   AFTER MAKING CHANGES   -------**\nTable E2 marked from STEPLIB so PARMLIB UPDATE(xx) will not overlay it.\n\nReturn Code = 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TSUB#09": {"ttr": 12293, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x003\\x01\\t\\x04\\x8f\\x01\\t\\x04\\x8f\\x08V\\x00\\x1e\\x00\\x0b\\x00\\x00```````@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2009-02-17T00:00:00", "modifydate": "2009-02-17T08:56:33", "lines": 30, "newlines": 11, "modlines": 0, "user": "-------"}, "text": "Output of command:  TSUB E2P\n\n     This command zeroes a bit in the LWA that says that the\n     IKJEFTE2 table came from a STEPLIB, and not from an IKJTSOxx\n     PARMLIB member.  Thus the table is marked that it came from\n     PARMLIB (even if it didn't).  This has the effect that when\n     someone issues a command PARMLIB UPDATE(xx) or SET IKJTSO=xx\n     later, then your IKJEFTE2 table which is now marked that it\n     came from PARMLIB, will be completely overlaid from the\n     \"common storage\" copy of the table.\n\n\nTSUB Command - Display or Change Auth Table or Entry\n---- -------   ------- -- ------ ---- ----- -- -----\n\n  **--- STATE BEFORE MAKING TABLE CHANGES ---**\nE2P   80     Program table code + Function code\nTable address:      0000C000\nTable address is not within an LPA region.\nNon-blank table entries:     295   (these are the ones used)\nPerceived blank entries:      29   (potential for expansion)\nTable E2 pointed to by the LWA has no lengths. Blanks will delimit.\nTable E2 pointed to by the LWA came from an APF STEPLIB.\nTable Header:  IKJEFTE276.152\nNumber of valid entries:     296\n\n  **--------   AFTER MAKING CHANGES   -------**\nTable E2 marked from not from STEPLIB. PARMLIB UPDATE(xx) can overlay.\n\nReturn Code = 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TSUB#10": {"ttr": 12295, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00G\\x01\\t\\x04\\x8f\\x01\\t\\x04\\x8f\\x08W\\x00\\x1b\\x00\\x07\\x00\\x00```````@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2009-02-17T00:00:00", "modifydate": "2009-02-17T08:57:47", "lines": 27, "newlines": 7, "modlines": 0, "user": "-------"}, "text": "Output of command:  TSUB E2H\n\n     This command alters the header of the IKJEFTE2 table, which\n     originally came from a STEPLIB, and not from an IKJTSOxx\n     PARMLIB member, to make it look as if it came from an IKJTSOxx\n     PARMLIB member.  The messages tell you what was done.\n\n\nTSUB Command - Display or Change Auth Table or Entry\n---- -------   ------- -- ------ ---- ----- -- -----\n\n  **--- STATE BEFORE MAKING TABLE CHANGES ---**\nE2H   08     Program table code + Function code\nTable address:      0000C000\nTable address is not within an LPA region.\nNon-blank table entries:     295   (these are the ones used)\nPerceived blank entries:      29   (potential for expansion)\nTable E2 pointed to by the LWA has no lengths. Blanks will delimit.\nTable E2 pointed to by the LWA did not come from an APF STEPLIB.\nTable Header:  IKJEFTE276.152\nNumber of valid entries:     296\n\n  **--------   AFTER MAKING CHANGES   -------**\nLast 8 bytes of table header altered to \" PARMLIB\".\nTable Header:  IKJEFTE2 PARMLIB\n\nReturn Code = 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TSUB#11": {"ttr": 12297, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00G\\x01\\t\\x04\\x9f\\x01\\t\\x04\\x9f\\x11\\x19\\x01U\\x01U\\x00\\x00```````@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2009-02-18T00:00:00", "modifydate": "2009-02-18T11:19:47", "lines": 341, "newlines": 341, "modlines": 0, "user": "-------"}, "text": "TRICKS OF THE TRADE\n\nTSUB E2D, AFTER TSUB E2L followed by TSUB E2R 300 CQX\n\nExplanation.\n\n    The original E2 table had 294 non-blank entries followed by 30 blank\nentries.  Of course, TSO stops when it reaches the first blank, which is\nthe 295th slot.  However, after issuing TSUB E2L, the length of the\ntable (not there before, because the table came from a STEPLIB, and then\nI issued E2P which is not necessary) was increased to enough for 324\nslots.  The main thing here is the TSUB E2L.\n\n    Once the length of the table was increased to 324 slots, even though\nTSO will not honor anything after the first blank, TSUB will be able to\nreplace any of the blank entries with non-blanks.  This is because TSUB\nfigures out how many slots you have, in two ways.  If there is no table\nlength, then TSUB measures the table until the first blank.  If there is\na table length, then TSUB figures out, from that length, how many table\nentries there should be.  From the length of 324 entries, TSUB still has\nthe ability to change one of the later entries to a program name.  You\ncan tell what happened from the TSUB E2D display, because there are 324\nentries, 294 non-blank contiguous entries at the beginning, followed by\nonly 5 blank entries.  That means that the 6th entry is non-blank.\n\n    So theoretically, you can fill in 10 new program names, contiguously\nwhile still leaving the first blank entry, and you can activate them all\nat once, by putting a non-blank entry in the first blank spot, making 11\nnon-blank contiguous entries all of a sudden, which TSO will now honor.\n\n    Nice trick.  Only made possible by the new \"L\" action code.\n\n\nTSUB Command - Display or Change Auth Table or Entry\n---- -------   ------- -- ------ ---- ----- -- -----\nE2D   04     Program table code + Function code\nTable address:      0000C000\nTable address is not within an LPA region.\nNon-blank table entries:     294   (these are the ones used)\nPerceived blank entries:       5   (potential for expansion)\nTable E2 pointed to by the LWA has length available. Hex 0A30.\nTable E2 pointed to by the LWA did not come from an APF STEPLIB.\nTable Header:  IKJEFTE2 PARMLIB\nNumber of valid entries:     324\nE2 Table Entry Number:         1  $$\nE2 Table Entry Number:         2  $HOWMVS\nE2 Table Entry Number:         3  $MDSMAIN\nE2 Table Entry Number:         4  ABUDSN\nE2 Table Entry Number:         5  AD\nE2 Table Entry Number:         6  ADB2UTIL\nE2 Table Entry Number:         7  ADDDIR\nE2 Table Entry Number:         8  ADDFILE\nE2 Table Entry Number:         9  ADDGROUP\nE2 Table Entry Number:        10  ADDSD\nE2 Table Entry Number:        11  ADDUSER\nE2 Table Entry Number:        12  ADIR\nE2 Table Entry Number:        13  ADNR\nE2 Table Entry Number:        14  ADYOPCMD\nE2 Table Entry Number:        15  AF\nE2 Table Entry Number:        16  AG\nE2 Table Entry Number:        17  AHOWMVS\nE2 Table Entry Number:        18  ALD\nE2 Table Entry Number:        19  ALF\nE2 Table Entry Number:        20  ALG\nE2 Table Entry Number:        21  ALTDIR\nE2 Table Entry Number:        22  ALTDSD\nE2 Table Entry Number:        23  ALTER\nE2 Table Entry Number:        24  ALTFILE\nE2 Table Entry Number:        25  ALTGROUP\nE2 Table Entry Number:        26  ALTUSER\nE2 Table Entry Number:        27  ALU\nE2 Table Entry Number:        28  APCACBL\nE2 Table Entry Number:        29  APCANB\nE2 Table Entry Number:        30  APCARB\nE2 Table Entry Number:        31  APCAUB\nE2 Table Entry Number:        32  APFCMD\nE2 Table Entry Number:        33  ASUB\nE2 Table Entry Number:        34  AU\nE2 Table Entry Number:        35  BACKUP\nE2 Table Entry Number:        36  BCMDEL\nE2 Table Entry Number:        37  BCMDEL1\nE2 Table Entry Number:        38  BCMNAUTH\nE2 Table Entry Number:        39  BCMNUPD\nE2 Table Entry Number:        40  BDATA\nE2 Table Entry Number:        41  BDMNUPD\nE2 Table Entry Number:        42  BINDDATA\nE2 Table Entry Number:        43  BLKUPD\nE2 Table Entry Number:        44  BUDDSN\nE2 Table Entry Number:        45  BUDGET\nE2 Table Entry Number:        46  CAE$BQRY\nE2 Table Entry Number:        47  CANCELU\nE2 Table Entry Number:        48  CAS9UDTN\nE2 Table Entry Number:        49  CDELPAIR\nE2 Table Entry Number:        50  CDMRSTAT\nE2 Table Entry Number:        51  CDSCB\nE2 Table Entry Number:        52  CESTPAIR\nE2 Table Entry Number:        53  CHKPT\nE2 Table Entry Number:        54  CINMX\nE2 Table Entry Number:        55  CLCHECK\nE2 Table Entry Number:        56  CNVTCAT\nE2 Table Entry Number:        57  CO\nE2 Table Entry Number:        58  COFDMON\nE2 Table Entry Number:        59  CONNECT\nE2 Table Entry Number:        60  CONSPROF\nE2 Table Entry Number:        61  CPSCB\nE2 Table Entry Number:        62  CQUERYSG\nE2 Table Entry Number:        63  CRECOVER\nE2 Table Entry Number:        64  CSCAN\nE2 Table Entry Number:        65  CSUSPEND\nE2 Table Entry Number:        66  DCAS\nE2 Table Entry Number:        67  DD\nE2 Table Entry Number:        68  DDIR\nE2 Table Entry Number:        69  DEF\nE2 Table Entry Number:        70  DEFINE\nE2 Table Entry Number:        71  DEL\nE2 Table Entry Number:        72  DELDIR\nE2 Table Entry Number:        73  DELDSD\nE2 Table Entry Number:        74  DELETE\nE2 Table Entry Number:        75  DELFILE\nE2 Table Entry Number:        76  DELGROUP\nE2 Table Entry Number:        77  DELUSER\nE2 Table Entry Number:        78  DF\nE2 Table Entry Number:        79  DG\nE2 Table Entry Number:        80  DITTO\nE2 Table Entry Number:        81  DITTOA\nE2 Table Entry Number:        82  DITTOU\nE2 Table Entry Number:        83  DMRSHR\nE2 Table Entry Number:        84  DRI\nE2 Table Entry Number:        85  DU\nE2 Table Entry Number:        86  ERWMAUTH\nE2 Table Entry Number:        87  EX\nE2 Table Entry Number:        88  EXP\nE2 Table Entry Number:        89  EXPORT\nE2 Table Entry Number:        90  EYU9XENF\nE2 Table Entry Number:        91  EZAZSSI\nE2 Table Entry Number:        92  EZBREINI\nE2 Table Entry Number:        93  EZBTNINI\nE2 Table Entry Number:        94  FCESTABL\nE2 Table Entry Number:        95  FCQUERY\nE2 Table Entry Number:        96  FCWITHDR\nE2 Table Entry Number:        97  FTPD\nE2 Table Entry Number:        98  FTPDNS\nE2 Table Entry Number:        99  GJTRUCBS\nE2 Table Entry Number:       100  IEBCOPY\nE2 Table Entry Number:       101  IKJEHDSF\nE2 Table Entry Number:       102  IKJEHDS1\nE2 Table Entry Number:       103  IKJPRMLB\nE2 Table Entry Number:       104  IM\nE2 Table Entry Number:       105  IMP\nE2 Table Entry Number:       106  IMPORT\nE2 Table Entry Number:       107  IOBSNMP\nE2 Table Entry Number:       108  IQIEXPN\nE2 Table Entry Number:       109  IQIMAIN\nE2 Table Entry Number:       110  IQIQUERY\nE2 Table Entry Number:       111  IQIQUIT\nE2 Table Entry Number:       112  IRRDPI00\nE2 Table Entry Number:       113  ISPICP\nE2 Table Entry Number:       114  ISRPCP\nE2 Table Entry Number:       115  LBADV\nE2 Table Entry Number:       116  LBAGENT\nE2 Table Entry Number:       117  LD\nE2 Table Entry Number:       118  LDATA\nE2 Table Entry Number:       119  LDIR\nE2 Table Entry Number:       120  LDIRECT\nE2 Table Entry Number:       121  LF\nE2 Table Entry Number:       122  LFILE\nE2 Table Entry Number:       123  LG\nE2 Table Entry Number:       124  LISTB\nE2 Table Entry Number:       125  LISTBC\nE2 Table Entry Number:       126  LISTD\nE2 Table Entry Number:       127  LISTDATA\nE2 Table Entry Number:       128  LISTDS\nE2 Table Entry Number:       129  LISTDSD\nE2 Table Entry Number:       130  LISTGRP\nE2 Table Entry Number:       131  LISTUSER\nE2 Table Entry Number:       132  LLWA\nE2 Table Entry Number:       133  LMRKTSO\nE2 Table Entry Number:       134  LOCKTERM\nE2 Table Entry Number:       135  LOOK\nE2 Table Entry Number:       136  LPQ\nE2 Table Entry Number:       137  LPR\nE2 Table Entry Number:       138  LPRM\nE2 Table Entry Number:       139  LPROC\nE2 Table Entry Number:       140  LSLT\nE2 Table Entry Number:       141  LU\nE2 Table Entry Number:       142  LWATMGR\nE2 Table Entry Number:       143  MAKEUSER\nE2 Table Entry Number:       144  MIMTSO\nE2 Table Entry Number:       145  MODDVIPA\nE2 Table Entry Number:       146  MU\nE2 Table Entry Number:       147  MVPMAIN\nE2 Table Entry Number:       148  MVPXDISP\nE2 Table Entry Number:       149  MVSCPCMD\nE2 Table Entry Number:       150  NAMEDXFR\nE2 Table Entry Number:       151  NAMED4\nE2 Table Entry Number:       152  NDVRC1\nE2 Table Entry Number:       153  NETSTAT\nE2 Table Entry Number:       154  NSUPDATE\nE2 Table Entry Number:       155  NSUPDAT4\nE2 Table Entry Number:       156  NYPPW\nE2 Table Entry Number:       157  OC\nE2 Table Entry Number:       158  OMPROUTE\nE2 Table Entry Number:       159  OP\nE2 Table Entry Number:       160  OPER\nE2 Table Entry Number:       161  OPERATOR\nE2 Table Entry Number:       162  OPINFO\nE2 Table Entry Number:       163  OPING\nE2 Table Entry Number:       164  OPSCMD\nE2 Table Entry Number:       165  OPSCONSL\nE2 Table Entry Number:       166  OPSOSCMD\nE2 Table Entry Number:       167  OPSPARM\nE2 Table Entry Number:       168  OPSREPLY\nE2 Table Entry Number:       169  OPSTAT\nE2 Table Entry Number:       170  OPSWTO\nE2 Table Entry Number:       171  OSNMPD\nE2 Table Entry Number:       172  OTRACERT\nE2 Table Entry Number:       173  PACKRAT\nE2 Table Entry Number:       174  PARMLIB\nE2 Table Entry Number:       175  PASSWORD\nE2 Table Entry Number:       176  PDIR\nE2 Table Entry Number:       177  PDSCLEAN\nE2 Table Entry Number:       178  PDSEAUTH\nE2 Table Entry Number:       179  PE\nE2 Table Entry Number:       180  PERMDIR\nE2 Table Entry Number:       181  PERMFILE\nE2 Table Entry Number:       182  PERMIT\nE2 Table Entry Number:       183  PF\nE2 Table Entry Number:       184  PHRASE\nE2 Table Entry Number:       185  PING\nE2 Table Entry Number:       186  POPPER\nE2 Table Entry Number:       187  PRINT\nE2 Table Entry Number:       188  PW\nE2 Table Entry Number:       189  Q\nE2 Table Entry Number:       190  QUEUE\nE2 Table Entry Number:       191  Q522\nE2 Table Entry Number:       192  RACDCERT\nE2 Table Entry Number:       193  RACFSIM\nE2 Table Entry Number:       194  RACLINK\nE2 Table Entry Number:       195  RACONVRT\nE2 Table Entry Number:       196  RACPRIV\nE2 Table Entry Number:       197  RALT\nE2 Table Entry Number:       198  RALTER\nE2 Table Entry Number:       199  RDEF\nE2 Table Entry Number:       200  RDEFINE\nE2 Table Entry Number:       201  RDEL\nE2 Table Entry Number:       202  RDELETE\nE2 Table Entry Number:       203  RE\nE2 Table Entry Number:       204  RECEIVE\nE2 Table Entry Number:       205  RELOGON\nE2 Table Entry Number:       206  REMOVE\nE2 Table Entry Number:       207  REPRO\nE2 Table Entry Number:       208  RESOLVE\nE2 Table Entry Number:       209  REVIEW\nE2 Table Entry Number:       210  REVVSAM\nE2 Table Entry Number:       211  REXCPCMD\nE2 Table Entry Number:       212  RL\nE2 Table Entry Number:       213  RLIST\nE2 Table Entry Number:       214  RLOAD\nE2 Table Entry Number:       215  RLOADA\nE2 Table Entry Number:       216  RMM\nE2 Table Entry Number:       217  RPF\nE2 Table Entry Number:       218  RPFE\nE2 Table Entry Number:       219  RSH\nE2 Table Entry Number:       220  RSHD\nE2 Table Entry Number:       221  RVARY\nE2 Table Entry Number:       222  SAMENDM\nE2 Table Entry Number:       223  SDSF\nE2 Table Entry Number:       224  SE\nE2 Table Entry Number:       225  SEARCH\nE2 Table Entry Number:       226  SECURE\nE2 Table Entry Number:       227  SEND\nE2 Table Entry Number:       228  SETC\nE2 Table Entry Number:       229  SETCACHE\nE2 Table Entry Number:       230  SETPASSW\nE2 Table Entry Number:       231  SETPW\nE2 Table Entry Number:       232  SETPW2\nE2 Table Entry Number:       233  SETR\nE2 Table Entry Number:       234  SETROPTS\nE2 Table Entry Number:       235  SETUSER\nE2 Table Entry Number:       236  SHCDS\nE2 Table Entry Number:       237  SM\nE2 Table Entry Number:       238  SMTP\nE2 Table Entry Number:       239  SNTPD\nE2 Table Entry Number:       240  SPACE\nE2 Table Entry Number:       241  SPY\nE2 Table Entry Number:       242  SR\nE2 Table Entry Number:       243  SRDIR\nE2 Table Entry Number:       244  SRF\nE2 Table Entry Number:       245  SRFILE\nE2 Table Entry Number:       246  SRSTAT\nE2 Table Entry Number:       247  STEPLIB\nE2 Table Entry Number:       248  STEPLIBN\nE2 Table Entry Number:       249  SU\nE2 Table Entry Number:       250  SYNC\nE2 Table Entry Number:       251  SYSPROG\nE2 Table Entry Number:       252  TEAEXTSO\nE2 Table Entry Number:       253  TERM\nE2 Table Entry Number:       254  TERMINAL\nE2 Table Entry Number:       255  TESTA\nE2 Table Entry Number:       256  TESTAUTH\nE2 Table Entry Number:       257  TMONCICS\nE2 Table Entry Number:       258  TMONDB2\nE2 Table Entry Number:       259  TMONIMS\nE2 Table Entry Number:       260  TMONMVS\nE2 Table Entry Number:       261  TRACERTE\nE2 Table Entry Number:       262  TRANSMIT\nE2 Table Entry Number:       263  TRAPFWD\nE2 Table Entry Number:       264  TRMD\nE2 Table Entry Number:       265  TSOENQ\nE2 Table Entry Number:       266  TSOSMS\nE2 Table Entry Number:       267  TSUB\nE2 Table Entry Number:       268  UKEYCSA\nE2 Table Entry Number:       269  USAT\nE2 Table Entry Number:       270  USIT\nE2 Table Entry Number:       271  USOT\nE2 Table Entry Number:       272  USUT\nE2 Table Entry Number:       273  VERIFY\nE2 Table Entry Number:       274  VFY\nE2 Table Entry Number:       275  VIEWUSER\nE2 Table Entry Number:       276  VLFNOTE\nE2 Table Entry Number:       277  VMCF\nE2 Table Entry Number:       278  VU\nE2 Table Entry Number:       279  WAITT\nE2 Table Entry Number:       280  WHOENQ\nE2 Table Entry Number:       281  WSSTAT\nE2 Table Entry Number:       282  XD\nE2 Table Entry Number:       283  XDCCALLA\nE2 Table Entry Number:       284  XDCCMDA\nE2 Table Entry Number:       285  XF\nE2 Table Entry Number:       286  XMDSMAIN\nE2 Table Entry Number:       287  XMIT\nE2 Table Entry Number:       288  XTRCUSER\nE2 Table Entry Number:       289  XU\nE2 Table Entry Number:       290  YKCONMSG\nE2 Table Entry Number:       291  ZAP\nE2 Table Entry Number:       292  ZAP$\nE2 Table Entry Number:       293  ZAPLWA\nE2 Table Entry Number:       294  ZAPV\nE2 Table Entry Number:       295  *empty*\n\nReturn Code = 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TSUBHELP": {"ttr": 12303, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01'\\x00Q\\x01\\x160_\\x01\\x164/\\x14I\\x01\\xb5\\x01\\xb3\\x00\\x00```````@@@\"", "ispf": {"version": "01.39", "flags": 0, "createdate": "2016-10-31T00:00:00", "modifydate": "2016-12-07T14:49:51", "lines": 437, "newlines": 435, "modlines": 0, "user": "-------"}, "text": "***********************************************************************\n*                                                                     *\n*   Program Name:   TSUB                                              *\n*                                                                     *\n*  Documentation:   This program is meant to be run as a TSO          *\n*                   command, APF authorized except for the display    *\n*                   functions.                                        *\n*                                                                     *\n*    Environment:   TSO command, APF Authorized.                      *\n*                   PUTLINE interface enabled by APUT, EPUTL.         *\n*                   This program is non-reentrant.                    *\n*                                                                     *\n* Short Function:   This program deals with existing TSO \"auth\"       *\n*                   tables that are pointed to by fields in the       *\n*                   LWA (Logon Work Area) which is created for a      *\n*                   TSO session at LOGON time.  These tables are      *\n*                   the actual tables that your TSO session uses      *\n*                   to determine program authorization.  Many of      *\n*                   the characteristics of these tables can be        *\n*                   changed or reset by the TSUB program.  The        *\n*                   changes that TSUB can do, are of two types:       *\n*                                                                     *\n*                   1.  Replacing or blanking any table entry.        *\n*                   2.  Altering the LWA flags or fields that         *\n*                       determine this table's properties.            *\n*                   3.  Effectively nullifying an entry by            *\n*                       putting a C'?' into it.  This effectively     *\n*                       removes the entry, without nullifying any     *\n*                       of the following table entries.               *\n*                                                                     *\n*                Details:                                             *\n*                                                                     *\n*                   1.  TSUB can substitute a different program name  *\n*                       or insert a blank entry into any valid slot   *\n*                       of a TSO \"auth\" table that belongs to your    *\n*                       TSO session.                                  *\n*                                                                     *\n*                       Blanking (not the last entry) is dangerous    *\n*                       (see below) because it invalidates all the    *\n*                       subsequent non-blank table entries.  But the  *\n*                       technique of blanking an entry can be used    *\n*                       carefully if you are sure of what you want    *\n*                       to accomplish.                                *\n*                                                                     *\n*                       But you can effectively nullify a table       *\n*                       entry without blanking it, using the          *\n*                       \"nullify\" function \"N\" instead of the         *\n*                       \"blanking\" function \"B\".  The nullifying      *\n*                       function inserts a C'?' into the slot,        *\n*                       allowing all following slots to still         *\n*                       work, since a ? entry is not a blank that     *\n*                       delimits the table.                           *\n*                                                                     *\n*                   2.  TSUB can change the characteristics of your   *\n*                       own session's TSO \"auth\" tables, that are     *\n*                       pointed to by the LWA, by means of changing   *\n*                       the LWA (Logon Work Area) settings for each   *\n*                       table.  For example, LWA table lengths can    *\n*                       be supplied or removed.  LWA flags marking    *\n*                       the table as coming from a STEPLIB can be     *\n*                       set, or removed.  Even the physical table     *\n*                       header can be altered to make the table       *\n*                       look as though it came from PARMLIB.          *\n*                                                                     *\n*   Introduction:   At LOGON time for a TSO session, the system       *\n*                   copies a set of the E2, E8, AP, and NS TSO        *\n*                   authorization tables into SP 252 protected Key 0  *\n*                   storage which lies in the TSO user's address      *\n*                   space.  These are the tables WHICH ARE ACTUALLY   *\n*                   USED by that TSO session, and their location is   *\n*                   pointed to in the LWA control block (Logon Work   *\n*                   Area).  The duration of these tables is for the   *\n*                   life of that TSO session.  TSO LOGON processing   *\n*                   creates both the LWA itself, and the copies of    *\n*                   the auth tables that are used. TSUB displays and  *\n*                   manipulates this copy of these tables--the ones   *\n*                   that are actually in use. Thus, changes to these  *\n*                   tables are effective immediately, and their       *\n*                   scope affects only the issuing TSO session.       *\n*                                                                     *\n*                   Where does TSO get these tables from, at LOGON    *\n*                   time?                                             *\n*                                                                     *\n*              Case 1.  The most commonly found source for the auth   *\n*                       tables pointed to in the LWA, is the \"common  *\n*                       storage\" tables created from the active       *\n*                       PARMLIB member IKJTSOxx.  Those are pointed   *\n*                       to by the TPVT control block + X'14' which    *\n*                       is the CTLT.  If the CTLT is the source of    *\n*                       the LWA tables, then lengths of the tables,   *\n*                       and the size of each entry, are copied from   *\n*                       the CTLT into the LWA (Logon Work Area).      *\n*                       Use the program called ASUB to directly       *\n*                       access the public tables from PARMLIB that    *\n*                       are pointed to by the CTLT (undocumented)     *\n*                       control block.  Our program, TSUB, accesses   *\n*                       the copy of those tables which is pointed to  *\n*                       by the LWA, which were created for the TSO    *\n*                       session at LOGON time, and which are unique   *\n*                       to the current TSO session.                   *\n*                                                                     *\n*              Case 2.  If a list of table entries for one or more    *\n*                       of the tables:  E2, E8, AP, or NS is not      *\n*                       found in the IKJTSOxx PARMLIB member that     *\n*                       is currently active, then the table in the    *\n*                       LWA is not copied from the IKJTABLS module    *\n*                       in LPALIB, but it is just pointed to.  Thus   *\n*                       in such a situation, TSUB cannot alter the    *\n*                       particular table.  The actual table is        *\n*                       located in PLPA, in that particular case.     *\n*                                                                     *\n*              Case 3.  If a copy of the IKJTABLS load module         *\n*                       containing csects IKJEFTE2, IKJEFTE8,         *\n*                       IKJEFTAP, and IKJEFTNS is found in an         *\n*                       APF-authorized STEPLIB that the TSO session   *\n*                       has access to (running as an APF authorized   *\n*                       STEPLIB only), then those E2, E8, NS, and AP  *\n*                       tables are copied into the LWA at LOGON       *\n*                       time, from that CSECT in the STEPLIB copy of  *\n*                       IKJTABLS.  Therefore the table entries in     *\n*                       the respective CSECTs of the IKJTABLS in the  *\n*                       authorized STEPLIB are the ones which are in  *\n*                       force for that user's TSO session.  But in    *\n*                       that case, no \"table lengths\" or \"number of   *\n*                       table entries\" from these tables, are         *\n*                       available.  The table is delimited by the     *\n*                       first blank entry in it.  This TSUB program   *\n*                       has the ability to blank any numbered table   *\n*                       entry.  Since a blank entry is a delimiter    *\n*                       for the entire table, and all entries after   *\n*                       the blank entry are no longer used, you       *\n*                       have to be very careful.  Therefore, when     *\n*                       blanking entries, you should usually blank    *\n*                       the last one only, unless you have a very     *\n*                       good reason to blank out a different entry,   *\n*                       other than the last one.  The good news is    *\n*                       that the effect of the TSUB program only      *\n*                       lasts for the duration of this LOGON, and     *\n*                       only for the userid that is currently running *\n*                       the TSUB program.                             *\n*                                                                     *\n*            Note - Tables copied from a CSECT in IKJTABLS do not     *\n*                   have lengths associated with them.  They are      *\n*                   delimited by a blank table entry at the end.      *\n*                   Therefore the copy of each such table pointed     *\n*                   to by the LWA, does not have any length           *\n*                   associated with it.  Therefore we can only        *\n*                   judge its length by looking at the first blank    *\n*                   entry that has been found by a forward scan.      *\n*                                                                     *\n*                   This program, TSUB, directly manipulates the      *\n*                   \"live\" authorization tables pointed to by the     *\n*                   LWA.  Supported tables are:  E2, E2, NS and       *\n*                   AP.  The public PP (Platform Program) table       *\n*                   and PC (Platform Command) table, not in the       *\n*                   LWA, are also supported by this program, if       *\n*                   they had been created by their presence in the    *\n*                   active IKJTSOxx PARMLIB member.                   *\n*                                                                     *\n*    Description:   Display an Auth Table entry from any of the       *\n*                   TSO/E program list tables:  IKJEFTE2, IKJEFTE8,   *\n*                   IKJEFTNS or IKJEFTAP that are in storage.  Or     *\n*                   display the entire table.  Or replace a numbered  *\n*                   entry with a new program name.  Or blank out      *\n*                   any numbered entry.  (Be very careful if you are  *\n*                   attempting to blank an entry.  Blanking an entry  *\n*                   invalidates ALL subsequent entries).  If you are  *\n*                   invoking a display function, then the entire      *\n*                   table is shown, unless you enter a number, and    *\n*                   then, only that slot is shown.  The tables        *\n*                   handled by this program are the actual tables     *\n*                   pointed to by the LWA of the issuing TSO/E        *\n*                   address space, and they lie in that user's        *\n*                   TSO/E address space (unless they were pointed to, *\n*                   and are from an IKJTABLS load module that is in   *\n*                   the LPA list.)                                    *\n*                                                                     *\n*       Function:   To substitute one new program name in the local   *\n*                   incore TSO auth tables, IKJEFTE2, IKJEFTE8, or    *\n*                   IKJEFTAP, IKJEFTNS lists.  This is done to any    *\n*                   numbered entry of each table.  Or else merely to  *\n*                   display the contents of the entire table, or the  *\n*                   contents of any particular numbered entry.        *\n*                                                                     *\n*                   The effect of replacing any program name is       *\n*                   immediate.  The scope of the change, is just for  *\n*                   the issuing current TSO userid.                   *\n*                                                                     *\n*                   You can blank out any numbered entry in any of    *\n*                   the four tables.  But blanking an entry, will     *\n*                   invalidate all subsequent table entries which     *\n*                   follow the blanked entry slot.  So be careful!    *\n*                                                                     *\n*                   Better than blanking an entry, you can \"nullify\"  *\n*                   an entry, which inserts a \"?\" character into the  *\n*                   table entry instead of blanks.  The subsequent    *\n*                   table entries remain valid.  The \"nullify\"        *\n*                   function is \"N\".  The \"blanking\" function is      *\n*                   \"B\".                                              *\n*                                                                     *\n*                   Or, you can use this program to list the complete *\n*                   contents of any of the auth tables which are      *\n*                   incore.                                           *\n*                                                                     *\n*                   Additionally, as described below, you can change  *\n*                   fields in the LWA which characterize the          *\n*                   individual tables--size characteristics and       *\n*                   whether or not the table came from STEPLIB.       *\n*                                                                     *\n*         Syntax:   TSUB ttA nnn pgmname                              *\n*                                                                     *\n*                   Where tt is a table code, and A is an action      *\n*                   code.                                             *\n*                                                                     *\n*                   The table code is a nickname for any of the       *\n*                   TSO/E auth tables which are incore.  They are:    *\n*                                                                     *\n*                   E2 - IKJEFTE2 = AUTHCMD  entry in IKJTSOxx        *\n*                   E8 - IKJEFTE8 = AUTHPGM  entry in IKJTSOxx        *\n*                   AP - IKJEFTAP = AUTHTSF  entry in IKJTSOxx        *\n*                   NS - IKJEFTNS = NOTBKGND entry in IKJTSOxx        *\n*                   PP -            PLATPGM  table in IKJTSOxx        *\n*                   PC -            PLATCMD  table in IKJTSOxx        *\n*                                                                     *\n*                   If the action code is B (blank the numbered       *\n*                   entry), then no program name is required,         *\n*                   but a number is required.  When blanking a        *\n*                   table entry, BE VERY CAREFUL !!!!!                *\n*                                                                     *\n*                   If the action code is N (nullify the numbered     *\n*                   entry), then no program name is required,         *\n*                   but a number is required.  Nullifying a table     *\n*                   entry will insert a \"?\" (question mark) into      *\n*                   that particular table slot, effectively           *\n*                   nullifying that entry, but NOT the entries        *\n*                   which follow, since blanks are the table          *\n*                   delimiters.                                       *\n*                                                                     *\n*     IMPORTANT  >  Under most circumstances, you should use the      *\n*       N O T E  >  \"nullify\" function \"N\" instead of the \"blanking\"  *\n*                >  function \"B\".  N will only nullify that one       *\n*                >  table entry, leaving all subsequent entries       *\n*                >  valid.  Blanking an entry will leave all          *\n*                >  subsequent table entries invalid.                 *\n*                                                                     *\n*       WARNING  >  If you blank out an entry which is not the        *\n*       WARNING  >  last entry in the particular table, then          *\n*       WARNING  >  all subsequent entries in that table are          *\n*       WARNING  >  rendered invalid!  It is best to restore          *\n*       WARNING  >  a non-blank entry to that slot, using the         *\n*       WARNING  >  ttR function, where tt is the table code.         *\n*                   Then you will be able to display the rest         *\n*                   of the table using the ttD function.              *\n*                                                                     *\n*                   If the action code is D (display the given        *\n*                   entry), then no program name is required.         *\n*                   The default action is to display the entire       *\n*                   table, unless a number is entered.  If a          *\n*                   number is present, then only that entry           *\n*                   number is displayed.  If the number is larger     *\n*                   than the number of entries in that particular     *\n*                   table, then an informative error message is       *\n*                   issued, and the program ends with code = 4.       *\n*                                                                     *\n*                   If the action code is R (replace the program      *\n*                   name) then a number (the table entry number)      *\n*                   and a program name are required.  If you want     *\n*                   to blank that slot, instead of putting a          *\n*                   program name into it, then use action code B.     *\n*                   But if you are blanking any slot which is not     *\n*                   the last slot, then PLEASE HEED THE WARNING       *\n*                   THAT IS ABOVE.                                    *\n*                                                                     *\n*                   If the action code is H, then TSUB will replace   *\n*                   the last 8 bytes of the table header with the     *\n*                   literal: C' PARMLIB', as if the table were        *\n*                   created from the IKJTSOxx member in PARMLIB.      *\n*                                                                     *\n*                   If the action code is L, then TSUB will look to   *\n*                   create a length value for that table.  This value *\n*                   is equal to the length of a table with all the    *\n*                   non-blank entries, plus all the potential blank   *\n*                   entries at the end of the table.  So this number  *\n*                   will often reflect more entries than TSO will     *\n*                   actually use.  Additionally, TSUB can change or   *\n*                   blank any one of these entries, because TSUB's    *\n*                   range depends on the number of entries indicated  *\n*                   by the LWA length.  (If there's no length, then   *\n*                   TSUB uses the length of all non-blank entries     *\n*                   plus the first blank, if it exists.)              *\n*                                                                     *\n*                   If the action code is M, then TSUB will look to   *\n*                   create a length value for that table.  This value *\n*                   is equal to the length of a table with all the    *\n*                   non-blank entries, plus one blank entry, if any   *\n*                   perceived blank entries exist at the end of the   *\n*                   table.                                            *\n*                                                                     *\n*                   If the action code is Z, then TSUB will look at   *\n*                   the LWA length value for that table, and it will  *\n*                   zero that length value, whether it already was    *\n*                   zero, or not.                                     *\n*                                                                     *\n*                   If the action code is S, then TSUB will make      *\n*                   the given table look like it came from STEPLIB,   *\n*                   so that a subsequent PARMLIB UPDATE(xx) command   *\n*                   will not overlay the session's auth table.        *\n*                                                                     *\n*                   If the action code is P, then TSUB will make      *\n*                   the given table look like it came from PARMLIB,   *\n*                   so that a subsequent PARMLIB UPDATE(xx) command   *\n*                   will overlay the session's auth table.            *\n*                                                                     *\n*                   If the action code is X, then TSUB will display   *\n*                   all the LPA address ranges (undocumented).        *\n*                                                                     *\n*                   If the PLATCMD or PLATPGM keywords (and at least  *\n*                   one name) were not coded in the active IKJTSOxx   *\n*                   PARMLIB entry, then there is no control block of  *\n*                   names to be pointed to.  The condition is         *\n*                   reported.  If these keywords WERE coded in the    *\n*                   IKJTSOxx member of PARMLIB which is currently     *\n*                   active, then the PC and PP table codes in TSUB    *\n*                   WILL ACT ON THE COMMON STORAGE COPY of THESE      *\n*                   TWO TABLES ONLY.                                  *\n*                                                                     *\n*  Recommendation:  First list the entire table using the \"D\"         *\n*                   action code, and then decide which entry, by      *\n*                   number, that you want to replace.                 *\n*                                                                     *\n*                   Then use the \"R\" action code, to replace the      *\n*                   particular numbered entry you have chosen.        *\n*                                                                     *\n*            Note:  The E2, E8, AP, or NS table which is being        *\n*                   used by the system, can come from either the      *\n*                   IKJTSOxx PARMLIB entry, or it can come from       *\n*                   an IKJTABLS load module which was running         *\n*                   from an APF authorized library as a STEPLIB,      *\n*                   or a default IKJTABLS entry in LPALIB.  Each      *\n*                   CSECT is copied into the TSO user's address       *\n*                   space, albeit in a protected key, and pointed     *\n*                   to by the user's LWA, except in the case of an    *\n*                   IKJTABLS CSECT that is in LPALIB.  These are      *\n*                   the actual auth tables, E2, E8, AP, NS, in        *\n*                   use by that TSO address space.                    *\n*                                                                     *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*  Change Log:                                                        *\n*    2008/09/10 - 1.0 - Initial version - Got it to work.             *\n*                       TSUB can blank any slot.  I'm allowing        *\n*                       that for now, because the scope of the        *\n*                       possible damage is only for that TSO          *\n*                       session as long as it is logged on.           *\n*                       The LWA auth tables are all reset by          *\n*                       logging on to that TSO session again.         *\n*                                                                     *\n*    2008/09/15 - 1.0 - Filled in and cleaned up some of the doc.     *\n*                                                                     *\n*    2009/01/28 - 1.0 - Added action codes: H, L, Z, S, P             *\n*                                                                     *\n*         All action codes except D need APF-authorization.           *\n*                                                                     *\n*         What they do:                                               *\n*                                                                     *\n*            H - Add PARMLIB-like table header, in 2nd 8-bytes.       *\n*            L - Supply length of table in LWA with ALL the blanks.   *\n*            M - Supply length of table to first blank, in LWA.       *\n*            Z - Zero the table length marked in the LWA.             *\n*            S - Mark that the table came from STEPLIB, so            *\n*                 someone (else's) PARMLIB UPDATE(xx) won't           *\n*                 overlay it.                                         *\n*            P - Turn off STEPLIB bit in LWA and mark that it         *\n*                 came from PARMLIB.  Now PARMLIB UPDATE(xx)          *\n*                 will overlay the table.                             *\n*            X - (undocumented) Gives LPA storage range display.      *\n*                                                                     *\n*         Other action codes are: (these are the original ones)       *\n*                                                                     *\n*            D - Display table entries by slot number.                *\n*            R - Replace the entry in a given slot, by another one.   *\n*            B - Blank a given table entry, by slot number.           *\n*            N - Nullify a given table entry, by slot number.         *\n*                 (It works by inserting a ? (question mark)          *\n*                  into that table slot.)                             *\n*                                                                     *\n*    2009/02/01 - 1.1 - Fourth and fifth base registers.              *\n*                                                                     *\n*         Improved message clarity.  Told messages to show states,    *\n*          \"before\" and \"after\" any changes were made.                *\n*                                                                     *\n*    2009/02/12 - 1.1 - Fix bug in calculating length of NS table.    *\n*         Fix convoluted logic in calculating table lengths.          *\n*                                                                     *\n*    2009/02/13 - 1.1 - Measure perceived blanks after logical end    *\n*         of the table.  For NS table, blank an entry with X'0000'    *\n*         for the \"length\" field, instead of X'FFFF', to see more     *\n*         perceived blanks, if there are any.                         *\n*                                                                     *\n*    2009/02/16 - 1.1 - Added option M to tailor length to reflect    *\n*         only up to the first blank.  Changed option L to make the   *\n*         LWA length equal to all non-blank entries plus all blank    *\n*         entries too.  Thus the table can be expanded, even if       *\n*         lengths are there.                                          *\n*                                                                     *\n*    2009/02/18 -1.1.31 Cosmetic changes. Put in Version numbers.     *\n*                                                                     *\n*    2009/02/20 -1.1.32 Improved displays for PC and PP tables.       *\n*                       Made sure S,P,H,L,M,Z options for PC and PP   *\n*                       actually do nothing, and say they do nothing. *\n*                       Made \"error display\" messages better.         *\n*                                                                     *\n*    2009/02/24 -1.1.33 Better messages if PLATPGM or PLATCMD tables  *\n*                       are missing.                                  *\n*                                                                     *\n*    2009/03/03 -1.1.34 More cosmetic changes in title & messages.    *\n*                                                                     *\n*    2011/03/24 -1.1.37 If an installation has an \"authorization SVC\" *\n*                       already installed, put in a provision to use  *\n*                       it with conditional assembly.  Of course,     *\n*                       you have to code your own appropriate         *\n*                       invocation code for the SVC, and its number,  *\n*                       in the AUTHON and AUTHOFF macros provided     *\n*                       in this code here.  Otherwise, SETC the &SVC  *\n*                       variable to 'NOSVC'                           *\n*                                                                     *\n*    2016/10/30 -1.1.38 A Blanking function on a table entry will     *\n*                       invalidate all subsequent table entries.      *\n*                       So I introduced a \"nullify\" function \"N\"      *\n*                       which will put a question mark, followed      *\n*                       by seven blanks, into a table entry,          *\n*                       effectively nullifying that entry, without    *\n*                       nullifying all the following entries too.     *\n*                                                                     *\n*    2016/12/07 -1.1.39 Describe the nullify function in HELP.        *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TSUBQUIK": {"ttr": 12552, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01'\\x00S\\x01\\t4O\\x01\\x164/\\x14F\\x00\\x18\\x00\\x1a\\x00\\x00```````@@@\"", "ispf": {"version": "01.39", "flags": 0, "createdate": "2009-12-10T00:00:00", "modifydate": "2016-12-07T14:46:53", "lines": 24, "newlines": 26, "modlines": 0, "user": "-------"}, "text": "TSUB Command - Display/Change USERID Auth Table Entry - Ver 1.39\n---- -------   ------- ------ ------ ---- ----- -----   --------\n\n  Instructions to use this program:\n  ------------ -- --- ---- -------\nTSUB TTA nnn pgmname (nnn optional for D, both required for R)\n  Supply a table code TT, followed by an action code A.\n\nValid table  codes are:  E2, E8, AP, NS, PC, PP.\nValid action codes are:  R - replace, B - blank, D - display,\n  H - header, L - supply full table length, Z - zero table length,\n  S - mark table from STEPLIB, P - mark table from PARMLIB,\n  X - display LPA storage ranges, M - supply minimum table length.\n  N - nullify a single entry without invalidating subsequent entries.\nFull command is in the form TTA, TT=table code, A=action code.\n\nIf D (display) is followed by a slot number, only that slot is shown.\nIf D is not followed by a number, then the entire table is displayed.\nR (replace) requires a slot number, followed by a program name.\nB (blank) blanks the slot number given. Higher slots are invalidated.\nN (nullify) invalidates that slot number. Higher slots remain valid.\nCodes: D,H,L,M,Z,P,S,X do not require extra parameters.\nD does not need APF authorization. All other codes require it.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TSUB36": {"ttr": 12554, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01$\\x00@\\x01\\x06\\x01\\x8f\\x01\\t\\x08o\\x18&\\r\\x15\\x04)\\x00\\x00```````@@@'", "ispf": {"version": "01.36", "flags": 0, "createdate": "2006-01-18T00:00:00", "modifydate": "2009-03-27T18:26:40", "lines": 3349, "newlines": 1065, "modlines": 0, "user": "-------"}, "text": "TSUB     TITLE 'TSUB - MAINTAIN LWA-POINTED-TO INCORE TSO AUTH TABLES'\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*   Program Name:   TSUB                                              *\n*                                                                     *\n*  Documentation:   This program is meant to be run as a TSO          *\n*                   command, APF authorized except for the display    *\n*                   functions.                                        *\n*                                                                     *\n*    Environment:   TSO command, APF Authorized.                      *\n*                   PUTLINE interface enabled by APUT, EPUTL.         *\n*                   This program is non-reentrant.                    *\n*                                                                     *\n* Short Function:   This program deals with existing TSO \"auth\"       *\n*                   tables that are pointed to by fields in the       *\n*                   LWA (Logon Work Area) which is created for a      *\n*                   TSO session at LOGON time.  These tables are      *\n*                   the actual tables that your TSO session uses      *\n*                   to determine program authorization.  Many of      *\n*                   the characteristics of these tables can be        *\n*                   changed or reset by the TSUB program.  The        *\n*                   changes that TSUB can do, are of two types:       *\n*                                                                     *\n*                   1.  Replacing or blanking any table entry.        *\n*                   2.  Altering the LWA flags or fields that         *\n*                       determine this table's properties.            *\n*                                                                     *\n*                Details:                                             *\n*                                                                     *\n*                   1.  TSUB can substitute a different program name  *\n*                       or insert a blank entry into any valid slot   *\n*                       of a TSO \"auth\" table that belongs to your    *\n*                       TSO session.                                  *\n*                                                                     *\n*                       Blanking (not the last entry) is dangerous    *\n*                       (see below) because it invalidates all the    *\n*                       subsequent non-blank table entries.  But the  *\n*                       technique of blanking an entry can be used    *\n*                       carefully if you are sure of what you want    *\n*                       to accomplish.                                *\n*                                                                     *\n*                   2.  TSUB can change the characteristics of your   *\n*                       own session's TSO \"auth\" tables, that are     *\n*                       pointed to by the LWA, by means of changing   *\n*                       the LWA (Logon Work Area) settings for each   *\n*                       table.  For example, LWA table lengths can    *\n*                       be supplied or removed.  LWA flags marking    *\n*                       the table as coming from a STEPLIB can be     *\n*                       set, or removed.  Even the physical table     *\n*                       header can be altered to make the table       *\n*                       look as though it came from PARMLIB.          *\n*                                                                     *\n*   Introduction:   At LOGON time for a TSO session, the system       *\n*                   copies a set of the E2, E8, AP, and NS TSO        *\n*                   authorization tables into SP 252 protected Key 0  *\n*                   storage which lies in the TSO user's address      *\n*                   space.  These are the tables WHICH ARE ACTUALLY   *\n*                   USED by that TSO session, and their location is   *\n*                   pointed to in the LWA control block (Logon Work   *\n*                   Area).  The duration of these tables is for the   *\n*                   life of that TSO session.  TSO LOGON processing   *\n*                   creates both the LWA itself, and the copies of    *\n*                   the auth tables that are used. TSUB displays and  *\n*                   manipulates this copy of these tables--the ones   *\n*                   that are actually in use. Thus, changes to these  *\n*                   tables are effective immediately, and their       *\n*                   scope affects only the issuing TSO session.       *\n*                                                                     *\n*                   Where does TSO get these tables from, at LOGON    *\n*                   time?                                             *\n*                                                                     *\n*              Case 1.  The most commonly found source for the auth   *\n*                       tables pointed to in the LWA, is the \"common  *\n*                       storage\" tables created from the active       *\n*                       PARMLIB member IKJTSOxx.  Those are pointed   *\n*                       to by the TPVT control block + X'14' which    *\n*                       is the CTLT.  If the CTLT is the source of    *\n*                       the LWA tables, then lengths of the tables,   *\n*                       and the size of each entry, are copied from   *\n*                       the CTLT into the LWA (Logon Work Area).      *\n*                       Use the program called ASUB to directly       *\n*                       access the public tables from PARMLIB that    *\n*                       are pointed to by the CTLT (undocumented)     *\n*                       control block.  Our program, TSUB, accesses   *\n*                       the copy of those tables which is pointed to  *\n*                       by the LWA, which were created for the TSO    *\n*                       session at LOGON time, and which are unique   *\n*                       to the current TSO session.                   *\n*                                                                     *\n*              Case 2.  If a list of table entries for one or more    *\n*                       of the tables:  E2, E8, AP, or NS is not      *\n*                       found in the IKJTSOxx PARMLIB member that     *\n*                       is currently active, then the table in the    *\n*                       LWA is not copied from the IKJTABLS module    *\n*                       in LPALIB, but it is just pointed to.  Thus   *\n*                       in such a situation, TSUB cannot alter the    *\n*                       particular table.  The actual table is        *\n*                       located in PLPA, in that particular case.     *\n*                                                                     *\n*              Case 3.  If a copy of the IKJTABLS load module         *\n*                       containing csects IKJEFTE2, IKJEFTE8,         *\n*                       IKJEFTAP, and IKJEFTNS is found in an         *\n*                       APF-authorized STEPLIB that the TSO session   *\n*                       has access to (running as an APF authorized   *\n*                       STEPLIB only), then those E2, E8, NS, and AP  *\n*                       tables are copied into the LWA at LOGON       *\n*                       time, from that CSECT in the STEPLIB copy of  *\n*                       IKJTABLS.  Therefore the table entries in     *\n*                       the respective CSECTs of the IKJTABLS in the  *\n*                       authorized STEPLIB are the ones which are in  *\n*                       force for that user's TSO session.  But in    *\n*                       that case, no \"table lengths\" or \"number of   *\n*                       table entries\" from these tables, are         *\n*                       available.  The table is delimited by the     *\n*                       first blank entry in it.  This TSUB program   *\n*                       has the ability to blank any numbered table   *\n*                       entry.  Since a blank entry is a delimiter    *\n*                       for the entire table, and all entries after   *\n*                       the blank entry are no longer used, you       *\n*                       have to be very careful.  Therefore, when     *\n*                       blanking entries, you should usually blank    *\n*                       the last one only, unless you have a very     *\n*                       good reason to blank out a different entry,   *\n*                       other than the last one.  The good news is    *\n*                       that the effect of the TSUB program only      *\n*                       lasts for the duration of this LOGON, and     *\n*                       only for the userid that is currently running *\n*                       the TSUB program.                             *\n*                                                                     *\n*            Note - Tables copied from a CSECT in IKJTABLS do not     *\n*                   have lengths associated with them.  They are      *\n*                   delimited by a blank table entry at the end.      *\n*                   Therefore the copy of each such table pointed     *\n*                   to by the LWA, does not have any length           *\n*                   associated with it.  Therefore we can only        *\n*                   judge its length by looking at the first blank    *\n*                   entry that has been found by a forward scan.      *\n*                                                                     *\n*                   This program, TSUB, directly manipulates the      *\n*                   \"live\" authorization tables pointed to by the     *\n*                   LWA.  Supported tables are:  E2, E2, NS and       *\n*                   AP.  The public PP (Platform Program) table       *\n*                   and PC (Platform Command) table, not in the       *\n*                   LWA, are also supported by this program, if       *\n*                   they had been created by their presence in the    *\n*                   active IKJTSOxx PARMLIB member.                   *\n*                                                                     *\n*    Description:   Display an Auth Table entry from any of the       *\n*                   TSO/E program list tables:  IKJEFTE2, IKJEFTE8,   *\n*                   IKJEFTNS or IKJEFTAP that are in storage.  Or     *\n*                   display the entire table.  Or replace a numbered  *\n*                   entry with a new program name.  Or blank out      *\n*                   any numbered entry.  (Be very careful if you are  *\n*                   attempting to blank an entry.  Blanking an entry  *\n*                   invalidates ALL subsequent entries).  If you are  *\n*                   invoking a display function, then the entire      *\n*                   table is shown, unless you enter a number, and    *\n*                   then, only that slot is shown.  The tables        *\n*                   handled by this program are the actual tables     *\n*                   pointed to by the LWA of the issuing TSO/E        *\n*                   address space, and they lie in that user's        *\n*                   TSO/E address space (unless they were pointed to, *\n*                   and are from an IKJTABLS load module that is in   *\n*                   the LPA list.)                                    *\n*                                                                     *\n*       Function:   To substitute one new program name in the local   *\n*                   incore TSO auth tables, IKJEFTE2, IKJEFTE8, or    *\n*                   IKJEFTAP, IKJEFTNS lists.  This is done to any    *\n*                   numbered entry of each table.  Or else merely to  *\n*                   display the contents of the entire table, or the  *\n*                   contents of any particular numbered entry.        *\n*                                                                     *\n*                   The effect of replacing any program name is       *\n*                   immediate.  The scope of the change, is just for  *\n*                   the issuing current TSO userid.                   *\n*                                                                     *\n*                   You can blank out any numbered entry in any of    *\n*                   the four tables.  But blanking an entry, will     *\n*                   invalidate all subsequent table entries which     *\n*                   follow the blanked entry slot.  So be careful!    *\n*                                                                     *\n*                   Or, you can use this program to list the complete *\n*                   contents of any of the auth tables which are      *\n*                   incore.                                           *\n*                                                                     *\n*                   Additionally, as described below, you can change  *\n*                   fields in the LWA which characterize the          *\n*                   individual tables--size characteristics and       *\n*                   whether or not the table came from STEPLIB.       *\n*                                                                     *\n*         Syntax:   TSUB ttA nnn pgmname                              *\n*                                                                     *\n*                   Where tt is a table code, and A is an action      *\n*                   code.                                             *\n*                                                                     *\n*                   The table code is a nickname for any of the       *\n*                   TSO/E auth tables which are incore.  They are:    *\n*                                                                     *\n*                   E2 - IKJEFTE2 = AUTHCMD  entry in IKJTSOxx        *\n*                   E8 - IKJEFTE8 = AUTHPGM  entry in IKJTSOxx        *\n*                   AP - IKJEFTAP = AUTHTSF  entry in IKJTSOxx        *\n*                   NS - IKJEFTNS = NOTBKGND entry in IKJTSOxx        *\n*                                                                     *\n*                   If the action code is B (blank the numbered       *\n*                   entry), then no program name is required,         *\n*                   but a number is required.  When blanking a        *\n*                   table entry, BE VERY CAREFUL !!!!!                *\n*                                                                     *\n*       WARNING  >  If you blank out an entry which is not the        *\n*       WARNING  >  last entry in the particular table, then          *\n*       WARNING  >  all subsequent entries in that table are          *\n*       WARNING  >  rendered invalid!  It is best to restore          *\n*       WARNING  >  a non-blank entry to that slot, using the         *\n*       WARNING  >  ttR function, where tt is the table code.         *\n*                   Then you will be able to display the rest         *\n*                   of the table using the ttD function.              *\n*                                                                     *\n*                   If the action code is D (display the given        *\n*                   entry), then no program name is required.         *\n*                   The default action is to display the entire       *\n*                   table, unless a number is entered.  If a          *\n*                   number is present, then only that entry           *\n*                   number is displayed.  If the number is larger     *\n*                   than the number of entries in that particular     *\n*                   table, then an informative error message is       *\n*                   issued, and the program ends with code = 4.       *\n*                                                                     *\n*                   If the action code is R (replace the program      *\n*                   name) then a number (the table entry number)      *\n*                   and a program name are required.  If you want     *\n*                   to blank that slot, instead of putting a          *\n*                   program name into it, then use action code B.     *\n*                   But if you are blanking any slot which is not     *\n*                   the last slot, then PLEASE HEED THE WARNING       *\n*                   THAT IS ABOVE.                                    *\n*                                                                     *\n*                   If the action code is H, then TSUB will replace   *\n*                   the last 8 bytes of the table header with the     *\n*                   literal: C' PARMLIB', as if the table were        *\n*                   created from the IKJTSOxx member in PARMLIB.      *\n*                                                                     *\n*                   If the action code is L, then TSUB will look to   *\n*                   create a length value for that table.  This value *\n*                   is equal to the length of a table with all the    *\n*                   non-blank entries, plus all the potential blank   *\n*                   entries at the end of the table.  So this number  *\n*                   will often reflect more entries than TSO will     *\n*                   actually use.  Additionally, TSUB can change or   *\n*                   blank any one of these entries, because TSUB's    *\n*                   range depends on the number of entries indicated  *\n*                   by the LWA length.  (If there's no length, then   *\n*                   TSUB uses the length of all non-blank entries     *\n*                   plus the first blank, if it exists.)              *\n*                                                                     *\n*                   If the action code is M, then TSUB will look to   *\n*                   create a length value for that table.  This value *\n*                   is equal to the length of a table with all the    *\n*                   non-blank entries, plus one blank entry, if any   *\n*                   perceived blank entries exist at the end of the   *\n*                   table.                                            *\n*                                                                     *\n*                   If the action code is Z, then TSUB will look at   *\n*                   the LWA length value for that table, and it will  *\n*                   zero that length value, whether it already was    *\n*                   zero, or not.                                     *\n*                                                                     *\n*                   If the action code is S, then TSUB will make      *\n*                   the given table look like it came from STEPLIB,   *\n*                   so that a subsequent PARMLIB UPDATE(xx) command   *\n*                   will not overlay the session's auth table.        *\n*                                                                     *\n*                   If the action code is P, then TSUB will make      *\n*                   the given table look like it came from PARMLIB,   *\n*                   so that a subsequent PARMLIB UPDATE(xx) command   *\n*                   will overlay the session's auth table.            *\n*                                                                     *\n*                   If the action code is X, then TSUB will display   *\n*                   all the LPA address ranges (undocumented).        *\n*                                                                     *\n*                   If the PLATCMD or PLATPGM keywords (and at least  *\n*                   one name) were not coded in the active IKJTSOxx   *\n*                   PARMLIB entry, then there is no control block of  *\n*                   names to be pointed to.  The condition is         *\n*                   reported.  If these keywords WERE coded in the    *\n*                   IKJTSOxx member of PARMLIB which is currently     *\n*                   active, then the PC and PP table codes in TSUB    *\n*                   WILL ACT ON THE COMMON STORAGE COPY of THESE      *\n*                   TWO TABLES ONLY.                                  *\n*                                                                     *\n*  Recommendation:  First list the entire table using the \"D\"         *\n*                   action code, and then decide which entry, by      *\n*                   number, that you want to replace.                 *\n*                                                                     *\n*                   Then use the \"R\" action code, to replace the      *\n*                   particular numbered entry you have chosen.        *\n*                                                                     *\n*            Note:  The E2, E8, AP, or NS table which is being        *\n*                   used by the system, can come from either the      *\n*                   IKJTSOxx PARMLIB entry, or it can come from       *\n*                   an IKJTABLS load module which was running         *\n*                   from an APF authorized library as a STEPLIB,      *\n*                   or a default IKJTABLS entry in LPALIB.  Each      *\n*                   CSECT is copied into the TSO user's address       *\n*                   space, albeit in a protected key, and pointed     *\n*                   to by the user's LWA, except in the case of an    *\n*                   IKJTABLS CSECT that is in LPALIB.  These are      *\n*                   the actual auth tables, E2, E8, AP, NS, in        *\n*                   use by that TSO address space.                    *\n*                                                                     *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*  Change Log:                                                        *\n*    2008/09/10 - 1.0 - Initial version - Got it to work.             *\n*                       TSUB can blank any slot.  I'm allowing        *\n*                       that for now, because the scope of the        *\n*                       possible damage is only for that TSO          *\n*                       session as long as it is logged on.           *\n*                       The LWA auth tables are all reset by          *\n*                       logging on to that TSO session again.         *\n*                                                                     *\n*    2008/09/15 - 1.0 - Filled in and cleaned up some of the doc.     *\n*                                                                     *\n*    2009/01/28 - 1.0 - Added action codes: H, L, Z, S, P             *\n*                                                                     *\n*         All action codes except D need APF-authorization.           *\n*                                                                     *\n*         What they do:                                               *\n*                                                                     *\n*            H - Add PARMLIB-like table header, in 2nd 8-bytes.       *\n*            L - Supply length of table in LWA with ALL the blanks.   *\n*            M - Supply length of table to first blank, in LWA.       *\n*            Z - Zero the table length marked in the LWA.             *\n*            S - Mark that the table came from STEPLIB, so            *\n*                 someone (else's) PARMLIB UPDATE(xx) won't           *\n*                 overlay it.                                         *\n*            P - Turn off STEPLIB bit in LWA and mark that it         *\n*                 came from PARMLIB.  Now PARMLIB UPDATE(xx)          *\n*                 will overlay the table.                             *\n*            X - (undocumented) Gives LPA storage range display.      *\n*                                                                     *\n*         Other action codes are: (these are the original ones)       *\n*                                                                     *\n*            D - Display table entries by slot number.                *\n*            R - Replace the entry in a given slot, by another one.   *\n*            B - Blank a given table entry, by slot number.           *\n*                                                                     *\n*    2009/02/01 - 1.1 - Fourth and fifth base registers.              *\n*                                                                     *\n*         Improved message clarity.  Told messages to show states,    *\n*          \"before\" and \"after\" any changes were made.                *\n*                                                                     *\n*    2009/02/12 - 1.1 - Fix bug in calculating length of NS table.    *\n*         Fix convoluted logic in calculating table lengths.          *\n*                                                                     *\n*    2009/02/13 - 1.1 - Measure perceived blanks after logical end    *\n*         of the table.  For NS table, blank an entry with X'0000'    *\n*         for the \"length\" field, instead of X'FFFF', to see more     *\n*         perceived blanks, if there are any.                         *\n*                                                                     *\n*    2009/02/16 - 1.1 - Added option M to tailor length to reflect    *\n*         only up to the first blank.  Changed option L to make the   *\n*         LWA length equal to all non-blank entries plus all blank    *\n*         entries too.  Thus the table can be expanded, even if       *\n*         lengths are there.                                          *\n*                                                                     *\n*    2009/02/18 -1.1.31 Cosmetic changes. Put in Version numbers.     *\n*                                                                     *\n*    2009/02/20 -1.1.32 Improved displays for PC and PP tables.       *\n*                       Made sure S,P,H,L,M,Z options for PC and PP   *\n*                       actually do nothing, and say they do nothing. *\n*                       Made \"error display\" messages better.         *\n*                                                                     *\n*    2009/02/24 -1.1.33 Better messages if PLATPGM or PLATCMD tables  *\n*                       are missing.                                  *\n*                                                                     *\n*    2009/03/03 -1.1.34 More cosmetic changes in title & messages.    *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n***********************************************************************\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*       I N S T R E A M    M A C R O S                                *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n***********************************************************************\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n         YREGS\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*  ---------------------------------------------------------------  *\n*    This macro is used to display hex values in a printed report.\n*  ---------------------------------------------------------------  *\n         MACRO\n&NAME    HEX   &TO,&LEN,&FROM\n&NAME    DS    0H\n         STM   R15,R1,HEXSAVE\n         LA    R1,&FROM\n         LA    R0,&LEN\n         LA    R15,&TO\n         BAL   R9,HEX\n         LM    R15,R1,HEXSAVE\n         MEND\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n* ------------------------------------------------------------------- *\n         MACRO\n&LABEL   APUT  &MSG,                    @MESSAGE TEXT                  &\n               &LEN,                    @LENGTH OF MESSAGE             &\n               &RSA=,                   OPTIONAL 2 WORD SAVE AREA      &\n               &EPA=                    EPUTL EPA\n.*\n.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*\n.*  --> E@PUT\n.*\n.*  THIS MACRO SETS UP A PARAMETERS AND INVOKES THE EPUTL ROUTINE.\n.*\n.*\n.*  ARGUMENTS: -----------------------------------------------------\n.*\n.*      &MSG : ADDRESS OF MESSAGE TEXT OR A LITERAL\n.*\n.*      &LEN : LENGTH OF MESSAGE TEXT (DEFAULT IS L'&MSG)\n.*\n.*      &RSA :(OPTIONAL) 1 WORD SAVE AREA TO PRESERVE R14 FOR TPUT\n.*            COMPATIBILITY.\n.*\n.*      &EPA :(OPTIONAL) EPA FOR EPUTL ROUTINE\n.*\n.*\n.*   EXAMPLES: -----------------------------------------------------\n.*\n.*      1) APUT  'LITERAL'\n.*\n.*      2) APUT  (R3),80\n.*\n.*      3) APUT  LABEL\n.*\n.*      4) APUT  LABEL,40\n.*\n.*\n.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.*\n.*\n.*  LOCAL SET SYMBOLS\n.*\n         LCLC  &SMA                     MESSAGE ADDRESS (REG)\n         LCLC  &SML                     MESSAGE LENGTH (REG)\n         LCLC  &SEP                     EPA (REGISTER)\n.*\n         LCLC  &L1,&L2,&L3              LOCAL LABELS\n.*\n&L1      SETC  'EP'.'&SYSNDX'.'L1'      LOCAL LABELS\n&L2      SETC  'EP'.'&SYSNDX'.'L2'      LOCAL LABELS\n&L3      SETC  'EP'.'&SYSNDX'.'L3'      LOCAL LABELS\n.*\n.*\n.*  MESSAGE ADDRESS\n.*\n         AIF   (T'&LABEL EQ 'O').A0500                      *HMD 11/86*\n.*                                                          *HMD 11/86*\n&LABEL   DS    0H                                           *HMD 11/86*\n.*                                                          *HMD 11/86*\n.A0500   ANOP                                               *HMD 11/86*\n         AIF   ('&MSG' NE '').A2000\n         MNOTE 8,'''&MSG='' MISSING / REQUIRED'\n         MEXIT\n.*\n.A2000   ANOP\n         AIF   ('&MSG'(1,1) NE '(').A2400\n&SMA     SETC  '&MSG'(2,K'&MSG-2)\n         LR    R1,&SMA                  @MESSAGE TEXT\n         AGO   .A2600\n.*\n.A2400   ANOP\n         AIF   ('&MSG'(1,1) NE '''').A2500\n         B     &L3                      BRANCH AROUND MESSAGE\n&L2      DC    C&MSG\n&L3      DS    0H\n         LA    R1,&L2                   @MESSAGE\n         AGO   .A2600\n.*\n.A2500   ANOP\n         LA    R1,&MSG                  @MESSAGE TEXT\n.A2600   ANOP\n.*\n.*  MESSAGE LENGTH\n.*\n         AIF   ('&LEN' NE '').A3000\n         AIF   ('&MSG'(1,1) NE '''').A2800\n         LA    R0,L'&L2                 MESSAGE LENGTH\n         AGO   .A3600\n.*\n.A2800   ANOP\n         AIF   ('&MSG'(1,1) EQ '(').A2900\n         LA    R0,L'&MSG                MESSAGE LENGTH\n         AGO   .A3600\n.*\n.A2900   ANOP\n         MNOTE 8,'''LEN'' MISSING / REQUIRED'\n         MEXIT\n.*\n.A3000   ANOP\n         AIF   ('&LEN'(1,1) NE '(').A3400\n&SML     SETC  '&LEN'(2,K'&LEN-2)\n         LR    R0,&SML                  MESSAGE LENGTH\n         AGO   .A3600\n.*\n.A3400   ANOP\n         LA    R0,&LEN                  MESSAGE LENGTH\n.A3600   ANOP\n.*\n.*  RSA\n.*\n         AIF   ('&RSA' EQ '').A4900\n         ST    R14,&RSA                 SAVE REGS 14\n.A4900   ANOP\n.*\n.*  ENTRY POINT\n.*\n         AIF   ('&EPA' NE '').A5000\n         L     R15,=V(EPUTL)            EPA\n         AGO   .A5600\n.*\n.A5000   AIF   ('&EPA'(1,1) NE '(').A5400\n&SEP     SETC  '&EPA'(2,K'&EPA-2)\n         LR    R15,&SEP                 EPA\n         AGO   .A5600\n.*\n.A5400   ANOP\n         L     R15,&EPA                 EPA\n.*\n.A5600   ANOP\n.*\n.*  CALL LINKAGE\n.*\n.ACALL   BALR  R14,R15                  CALL PUTLINE ROUTINE\n.*\n         AIF   ('&RSA' EQ '').A6900\n         L     R14,&RSA                 RESTORE R14\n.A6900   ANOP\n.*\n.AMEND   MEND\n* ------------------------------------------------------------------- *\nTSUB     CSECT\nTSUB     AMODE 31\nTSUB     RMODE 24\n         USING *,R15                                                  *\n         B     BEGINN               Eyecatcher\nMAXBLANK DC    F'120'        Guess of max number of blanks after table\n         DC    CL5'TSUB '\nVERS#    DC    CL10'Ver 1.35'\n         DC    CL18' - &SYSDATE &SYSTIME '\nBEGINN   DS    0H\n         DROP  R15\n         USING TSUB,R12,R11,R10,R6,R7  Set up base registers.\n         STM   R14,R12,12(R13)\n         LR    R12,R15                 Set up base registers.\n         ST    R1,SAVEPARM          Save CPPL pointer to use later.\n         LA    R11,4095(,R12)       Second base.\n         LA    R11,1(,R11)\n         LA    R10,4095(,R11)       Third base.\n         LA    R10,1(,R10)\n         LA    R6,4095(,R10)        Fourth base.\n         LA    R6,1(,R6)\n         LA    R7,4095(,R6)         Fifth base.\n         LA    R7,1(,R7)\n         LA    R1,SAVEAREA          Point to new save area\n         ST    R1,8(,R13)           Forward save area chain pointer\n         ST    R13,4(,R1)           Backward save area chain pointer\n         LR    R13,R1               New save area address\n         B     INITCON              Branch past save area\n         SPACE 1\n* -----------------------\nSAVEAREA DC    18F'0'               Non-reentrant save area\n* -----------------------\nINITCON  DS    0H                   Initialize constants to be sure.\n         MVI   OFFFLAG,X'00'\n         MVI   PLATFLG,X'00'\n         MVI   MEASFLG,X'00'\n         MVI   LPAFLAG,X'00'\n         MVI   SHBLFLG,X'00'\n         MVI   LPADFLG,X'00'\n         MVI   NSCHFLG,X'00'\n         MVI   HAVLFLG,X'00'\n         MVI   LWAPFLG,X'00'\n         MVI   LWAMFLG,X'00'\n         MVI   TIDFLAG,X'00'\n         MVI   OLDFLAG,X'00'\n         MVI   FLAGZ,X'00'\n         MVI   LINEB,X'40'\n         MVI   LINAB,X'40'\n         XC    FSTCOUNT,FSTCOUNT\n         XC    FSTNOUNT,FSTNOUNT\n         MVC   FSTFIELD(8),BLANKS\n         MVI   BLANKS-1,X'40'\n         MVC   BLANKS,BLANKS-1\n         MVC   CODEPLAC(2),BLANKS\n         MVC   DISPHDR(16),BLANKS\n         XC    SLOTBIN,SLOTBIN\n         XC    BLNKCNT,BLNKCNT\n         XC    NTRYCNT,NTRYCNT\n         XC    SAVETCUR,SAVETCUR\n         MVC   SLOTSAVE,BLANKS\n         MVC   FSTNAME,BLANKS\n         MVI   CMDBCOPY-1,X'00'\n         MVC   CMDBCOPY,CMDBCOPY-1\n* -----------------------\nGETPSCB  DS    0H                  See if we are allowed to\n*                                  run this program.\n         L     R2,16               POINT TO CVT.\n         L     R2,0(,R2)           POINT TO TCB/ASCB WORDS\n         L     R2,4(,R2)           POINT TO TCB.\n         L     R2,X'B4'(,R2)       POINT TO JSCB.\n         L     R2,X'108'(,R2)      POINT TO PSCB.\n         LA    R2,0(,R2)           CLEAR HIGH BYTE.\n         LTR   R2,R2               ANY PSCB?\n         BZ    EOJ4                GET OUT.  NOT TSO.\n         L     R1,SAVEPARM         Get the address of the CPPL back\n         USING CPPL,R1\n         L     R0,CPPLUPT          Copy CPPL fields for possible\n         ST    R0,SAVEUPT            later use, if needed.\n         L     R0,CPPLPSCB\n         ST    R0,SAVEPSCB\n         L     R0,CPPLECT\n         ST    R0,SAVEECT\n         DROP  R1\n         BAL   R9,PGMTITLE         First display the program title.\n         USING PSCB,R2\nCHEKAUTH DS    0H\n         NOP   GETLWA              Zap to bypass authorization check\n         TM    PSCBATR1,PSCBACCT   ACCT user?\n         BO    GETLWA              Yes.  Continue.\n         TM    PSCBATR1,PSCBCTRL   OPER user?\n         BZ    EOJ4                No.  Get out.\n         DROP  R2\n***** ----- >>>>>\nGETLWA   DS    0H                  Obtain all the relevant fields\n*                                  from the LWA (Logon Work Area)\n         L     R2,X'224'           Point to PSAAOLD\n         L     R2,X'6C'(,R2)       Point to ASXB\n         L     R2,X'14'(,R2)       Point to LWA\n         ST    R2,LWAADDR          Store LWA address\n         USING LWA,R2\n* ------------------------------------------------------------------ *\n*    Save all the relevant information from the LWA, to use later.   *\n* ------------------------------------------------------------------ *\n         ST    R5,SAVER5B          Store original contents of R5\n         L     R5,LWATNS           Pointer to NS table\n         ST    R5,SAVETNS          Save it.\n         L     R5,LWATE2           Pointer to E2 table\n         ST    R5,SAVETE2          Save it.\n         L     R5,LWATE8           Pointer to E8 table\n         ST    R5,SAVETE8          Save it.\n         L     R5,LWATAP           Pointer to AP table\n         ST    R5,SAVETAP          Save it.\n         XR    R5,R5               Clear register to be double sure.\n         LH    R5,LWATNSLN         Length of NS table if available\n         STH   R5,SAVETNSL         Save whatever was there in program.\n         LTR   R5,R5               Has a size been supplied in the LWA?\n         BZ    NONSSIZE            No\n         OI    LWAMFLG,X'40'       Yes. Indicate that in a flag.\nNONSSIZE DS    0H\n         LH    R5,LWATE2LN         Length of E2 table if available\n         STH   R5,SAVETE2L         Save whatever was there in program.\n         LTR   R5,R5               Has a size been supplied in the LWA?\n         BZ    NOE2SIZE            No\n         OI    LWAMFLG,X'20'       Yes. Indicate that in a flag.\nNOE2SIZE DS    0H\n         LH    R5,LWATE8LN         Length of E8 table if available\n         STH   R5,SAVETE8L         Save whatever was there in program.\n         LTR   R5,R5               Has a size been supplied in the LWA?\n         BZ    NOE8SIZE            No\n         OI    LWAMFLG,X'10'       Yes. Indicate that in a flag.\nNOE8SIZE DS    0H\n         LH    R5,LWATAPLN         Length of AP table if available\n         STH   R5,SAVETAPL         Save whatever was there in program.\n         LTR   R5,R5               Has a size been supplied in the LWA?\n         BZ    NOAPSIZE            No\n         OI    LWAMFLG,X'80'       Yes. Indicate that in a flag.\nNOAPSIZE DS    0H\n         L     R5,SAVER5B          Restore original R5 contents\n         MVC   LWAPFLG,LWAPRMLB    Save flags showing which tables\n*                                  came from STEPLIB, if any.\n         DROP  R2\n* ------------------------------------------------------------------ *\n*    At this point we have finished saving things out of the LWA.    *\n* ------------------------------------------------------------------ *\n*    Now we have to find the LPA boundaries.                         *\n* ------------------------------------------------------------------ *\nLPAINFO  DS    0H\n         BAL   R9,GETLPABD         Get list of LPA storage boundaries.\n* ------------------------------------------------------------------ *\n***** ----- >>>>>  We can handle the public Platform Command and     *\n***** ----- >>>>>  Platform Program tables, if they exist.           *\n* ------------------------------------------------------------------ *\nGETPCPP  DS    0H            Info about Platpgm and Platcmd Tables\n         L     R2,16               Point to CVT\n         L     R2,X'9C'(,R2)       Point to TSVT (TSO Vector Table)\n         L     R2,X'4C'(,R2)       Point to TPVT\n         ST    R2,SAVETPVT         Save TPVT address for later use\n         L     R2,X'14'(,R2)       Point to CTLT control block\n         ST    R2,SAVECTLT         Save CTLT address for later use\n         L     R2,SAVETPVT         Load TPVT address back\n         L     R2,X'34'(,R2)       Point to PLATCMD pointer\n         LTR   R2,R2               Is there any?\n         BZ    NOFCVE              No. Say so.\n         ST    R2,SAVEFCVE         Yes. Store the FCVE pointer away.\n         OI    PLATFLG,X'01'       Indicate that FCVE exists.\nTRYPPVE  DS    0H\n         L     R2,SAVETPVT         Load TPVT address back\n         L     R2,X'40'(,R2)       Point to PLATPGM pointer\n         LTR   R2,R2               Is there any?\n         BZ    NOPPVE              No. Say so.\n         ST    R2,SAVEPPVE         Yes. Store the PPVE pointer away.\n         OI    PLATFLG,X'02'       Indicate that PPVE exists.\nTRYPPVEE DS    0H\n         B     CHKOLVER            Skip over relevant error messages.\n* -------------------------------------------------------------- *\n* ------           Error messages if tables don't exist   ------ *\n* -------------------------------------------------------------- *\nNOFCVE   DS    0H\n         APUT  =C'No PLATCMD table found',22\n         B     TRYPPVE\nNOPPVE   DS    0H\n         APUT  =C'No PLATPGM table found',22\n         B     TRYPPVEE\n* ----------------------------------------------------------------- *\n*    There doesn't seem to be a way to tell from an old INMXPARM    *\n*    control block itself, that it is the old version.  So we use   *\n*    the position of the active PARMLIB member name in the TPVT.    *\n* ----------------------------------------------------------------- *\nCHKOLVER DS    0H\n         L     R2,SAVETPVT         Load TPVT address back.\n         CLC   =C'IKJ',7(R2)       Parmlib member name in old position?\n         BNE   PARMSCAN            No. It's a new TSO/E version\n         OI    OLDFLAG,X'01'       Yes. Flag that the system is old.\n* -------------------------------------------------------------- *\n*    After we got the system information we finally start        *\n*     scanning the TSO command for parms, here.                  *\n* -------------------------------------------------------------- *\nPARMSCAN DS    0H\n         L     R1,SAVEPARM         Original R1 from entry to program.\n         LTR   R1,R1               Any CPPL?\n         BZ    EOJ8                No. Get out.\n         L     R1,0(,R1)           Point to Command Buffer\n         LTR   R1,R1               Any Command Buffer?\n         BZ    EOJ4                Get out if none.\n         LH    R3,0(,R1)           Load length.\n         CH    R3,=H'4'            Anything?\n         BNH   EOJ4                No.  Get out.\n         LR    R5,R3               Length of command + 4\n         ICM   R5,14,FULLZERO      Clear high order 3 bytes.\n         ST    R1,CMBUFAD          Save Command Buffer Address\n         LH    R3,2(,R1)           Load offset.\n         ST    R3,OFFSETSV         Save offset value.\n         SR    R5,R3               Subtract offset from full length+4\n         SH    R5,=H'4'            Correct for length of CMDBUFR header\n*                                  in the command buffer.\n         BC    8,EOJC              Zero, Message\n         BC    5,EOJC              Less, or overflow, out.\n         ST    R5,CMBUFEND         Store away the number of bytes left\n         L     R1,CMBUFAD          Load Command Buffer Address\n*\n* ----  Copy command buffer into pgm's buffer so we can control it.\n*\n         STM   R14,R1,SAVE1401     Now save registers 14 thru 1.\n         XR    R14,R14             Clear R14.\n         LH    R14,0(,R1)          Load full command buffer length.\n         S     R14,=F'5'           Subtract 4 for header, 1 for execute\n         ICM   R14,14,FULLZERO     Ensure cmd buffer smaller than 255\n         EX    R14,COPYCMDB        Copy command into pgm's area.\n         LM    R14,R1,SAVE1401     Restore registers 14 thru 1.\n         B     GOGOGO              Jump over executed instruction.\nCOPYCMDB MVC   CMDBCOPY(0),4(R1)   <<< Executed >>>\nGOGOGO   DS    0H\n* ----\n         LA    R2,3                Load register for BCT loop.\n* >>>\n         LA    R1,CMDBCOPY         Point to command in our buffer\n         A     R1,OFFSETSV         Add offset, point to subcommands\n         ST    R1,CHARSTRT         Store starting point away\n* >>>\n         LR    R4,R1               Initialize pointer\n         LA    R4,0(,R4)           to first character of function name.\n         LA    R8,0                Initialize character count\nCUTIDLEN CLI   0(R4),X'40'         Is this character a blank?\n         BE    AFTFIRST            Yes, end of the first parm.\n         CLI   0(R4),X'00'         Is this character hex zero?\n         BE    AFTFIRST            Yes, end of command in buffer copy.\n         LA    R4,1(,R4)           Bump another character\n         LA    R8,1(,R8)           Count another character\n         CR    R8,R5               End of command buffer ?\n         BNL   AFTFIRST            Yes. Get out now.\n         BCT   R2,CUTIDLEN         Try for blank again.\nAFTFIRST DS    0H\n         MVC   TABCODE(8),BLANKS   Clear field\n         BCTR  R8,0                Subtract 1 for execute.\n         L     R1,CHARSTRT         Reload R1 to be sure it's correct.\n         EX    R8,MOVOUTL          Move entered parameter to program.\n         LA    R8,1(,R8)           Restore number of characters\n         AR    R1,R8               Point past last search\n         ST    R1,CHARCONT         Continue from here\n         ST    R8,SAVER8A          Save register\n* ---- >\nSEEIFPRM DS    0H                  Check if a command is here\n         OC    TABCODE(3),BLANKS   Uppercase. Won't affect numbers.\n         CLI   TABCODE+2,C'X'      Special action code, code X.\n         BNE   SEEIFJ01            Not this. Just go on.\n         OI    LPADFLG,X'01'       Set flag to display LPA range.\nSEEIFJ01 DS    0H\n*--*\n         TM    LPADFLG,X'01'       Display LPA range only?\n         BZ    SEEIFK01            No. Do all regular processing.\n         BAL   R9,GETLPRNT         Yes. Display LPA range and exit.\n         B     EOJ0                Out of program with Code 0\nSEEIFK01 DS    0H\n*--*\n         CLI   TABCODE+2,C'R'      Replace the entry in the given slot\n         BE    SEEIF0A1\n         CLI   TABCODE+2,C'B'      Blank the given slot\n         BE    SEEIF0A2\n         CLI   TABCODE+2,C'D'      Display contents of given slot\n         BE    SEEIF0A3              or all slots.\n         CLI   TABCODE+2,C'H'      Alter table header\n         BE    SEEIF0A4\n         CLI   TABCODE+2,C'L'      Supply length for table in LWA\n         BE    SEEIF0A5              including trailing blank entries.\n         CLI   TABCODE+2,C'M'      Supply length for table in LWA plus\n         BE    SEEIF0M5              one trailing blank, if there.\n         CLI   TABCODE+2,C'Z'      Zero length for table in LWA\n         BE    SEEIF0A6\n         CLI   TABCODE+2,C'S'      Say this table came from STEPLIB\n         BE    SEEIF0A7\n         CLI   TABCODE+2,C'P'      Say this table is not from STEPLIB\n         BE    SEEIF0A8\n         B     SEEIF000\nSEEIF0A1 DS    0H\n         OI    OFFFLAG,X'01'       Replace an entry\n         B     SEEIF001\nSEEIF0A2 DS    0H\n         OI    OFFFLAG,X'02'       Blank entry in the last slot\n         B     SEEIF001\nSEEIF0A3 DS    0H\n         OI    OFFFLAG,X'04'       Display an entry or entries\n         B     SEEIF001\nSEEIF0A4 DS    0H\n         OI    OFFFLAG,X'08'       Alter table header\n         B     SEEIF001\nSEEIF0M5 DS    0H                  Short length with one blank\n         OI    SHBLFLG,X'01'\nSEEIF0A5 DS    0H\n         OI    OFFFLAG,X'10'       Supply length for table in LWA\n         B     SEEIF001\nSEEIF0A6 DS    0H\n         OI    OFFFLAG,X'20'       Zero length for table in LWA\n         B     SEEIF001\nSEEIF0A7 DS    0H\n         OI    OFFFLAG,X'40'       Say this table came from STEPLIB\n         B     SEEIF001\nSEEIF0A8 DS    0H\n         OI    OFFFLAG,X'80'       Say this table not from STEPLIB\n         B     SEEIF001\nSEEIF000 DS    0H                  Wrong function code was entered...\n* --- >                            Display what we entered, plus code\n         MVC   LINE,LINEB          Clear line\n         MVC   LINE(3),TABCODE     Move code in\n         HEX   LINE+6,1,OFFFLAG    Display contents of flag\n         MVC   LINE+13(35),=C'Program table code + Function code '\n         APUT  LINE,48\n* --- >\n         BAL   R9,ERRORCOD         Indicate error and display syntax.\n         B     EOJ4                Get out with code = 4.\nSEEIF001 DS    0H                  Which table to change\n         MVC   CODEPLAC(2),TABCODE    Save table code.\n* --- >\n         TM    OFFFLAG,X'04'       Display only--no changes to be made\n         BO    NOBEFORE            Don't show \"before changes\" message\n         STM   R14,R1,SAVE1401     Save registers 14 thru 1.\n         MVC   LINE,LINE-1\n         APUT  LINE,30\n         APUT  MESSAGED,L'MESSAGED Say \"after making changes\"\n         LM    R14,R1,SAVE1401     Restore registers 14 thru 1.\nNOBEFORE DS    0H\n* --- >                            Display what we entered, plus code\n         MVC   LINE,LINEB          Clear line\n         MVC   LINE(3),TABCODE     Move code in\n         HEX   LINE+6,1,OFFFLAG    Display contents of flag\n         MVC   LINE+13(35),=C'Program table code + Function code '\n         APUT  LINE,48\n* --- >                            Handle each table separately.\n         CLC   TABCODE(2),=C'E2'   Change IKJEFTE2?\n         BE    E2CHANGE            Yes. Branch.\n         CLC   TABCODE(2),=C'E8'   Change IKJEFTE8?\n         BE    E8CHANGE            Yes. Branch.\n         CLC   TABCODE(2),=C'AP'   Change IKJEFTAP?\n         BE    APCHANGE            Yes. Branch.\n         CLC   TABCODE(2),=C'PC'   Change PLATCMD?\n         BE    PCCHANGE            Yes. Branch.\n         CLC   TABCODE(2),=C'PP'   Change PLATPGM?\n         BE    PPCHANGE            Yes. Branch.\n         CLC   TABCODE(2),=C'NS'   Change IKJEFTNS?\n         BE    NSCHANGE            Yes. Branch.\n         BAL   R9,ERRORCOD         Indicate error and display syntax.\n         B     EOJ4                Invalid code entered.\nEOJ      DS    0H                  END OF JOB\n         L     R13,4(,R13)\n         LR    R15,R5              Put in real return code\n         ST    R15,16(,R13)        Shove it where it belongs\n         L     R14,12(,R13)        R14 and\n         LM    R0,R12,20(R13)        rest of registers\n         BR    R14                 Go back to caller\nEOJ0     DS    0H                  Return code 0\n         MVC   LINE,LINE-1\n         APUT  LINE,30\n         MVC   LINE,LINE-1         Clear output area\n         MVC   LINE,MESSAGR0       Show Return Code 0\n         APUT  MESSAGR0,L'MESSAGR0\n         LA    R5,0                Set CC = 0\n         B     EOJ                 Now end the program\nEOJ4     DS    0H                  Return code 4\n         MVC   LINE,LINE-1\n         APUT  LINE,30\n         MVC   LINE,LINE-1         Clear output area\n         MVC   LINE,MESSAGR4       Show Return Code 4\n         APUT  LINE,L'MESSAGR4\n         L     R5,FULLFOUR         Set CC = 4\n         B     EOJ                 Now end the program\nEOJ8     DS    0H                  Return code 8\n         MVC   LINE,LINE-1\n         APUT  LINE,30\n         MVC   LINE,LINE-1         Clear output area\n         MVC   LINE,MESSAGR8       Show Return Code 8\n         APUT  LINE,L'MESSAGR8\n         L     R5,FULLEIGT         Set CC = 8\n         B     EOJ                 Now end the program\nEOJC     DS    0H                  Return code 12\n         MVC   LINE,LINE-1\n         APUT  LINE,30\n         MVC   LINE,LINE-1         Clear output area\n         MVC   LINE,MESSAGRC       Show Return Code 12\n         APUT  LINE,L'MESSAGRC\n         L     R5,FULLTWLV         Set CC = 12\n         B     EOJ                 Now end the program\n** ---------------------------------------------------------------- **\n**                                                                  **\n**   Different Table Handling Routines                              **\n**   --------- ----- -------- --------                              **\n**                                                                  **\n**  At this point, we have the routines which handle each of the    **\n**  separate types of tables.  E2, E8, AP, and NS, for which the    **\n**  live LWA version is handled.  But we also do the FCVE and       **\n**  PPVE (Platform Command and Platform Program) tables pointed     **\n**  to by the TPVT (TSO Parmlib Vector Table) control block, and    **\n**  those two tables, if they exist, are similarly handled.  But    **\n**  the FCVE and PPVE tables (table codes PC and PP respectively,   **\n**  in this program) are in common storage, and are not in the      **\n**  TSO user's address space.                                       **\n**                                                                  **\n** ---------------------------------------------------------------- **\nE2CHANGE DS    0H                 Handle the E2 table\n         OI    TIDFLAG,X'20'      Show we're doing the E2 table.\n         MVC   TABLEID,=C'E2'     Identify which table\n         BAL   R9,ADJNEXTP        Get to first blank\n         BAL   R9,NAMEPARM        Get rest of parms from the command\n         L     R4,SAVETE2         Point to saved E2 table address\n         ST    R4,TABLSTRT        Store start address of table\n         ST    R4,TABLADDR        Keep start address of table\n*\n         BAL   R9,TESTLPA         Check if table address is in LPA\n         BAL   R9,CHANGEDL        LPA message (conditional)\n         BAL   R9,MEASUR08        Measure the table\n*\n         L     R1,TABLSTRT        Load it back into work register\n**-->>\nE2CHENTY DS    0H                 Show we have a size for E2 table\n         TM    LPAFLAG,X'01'      Is this table in LPA?\n         BO    E2CHYSST           Yes. Don't message the properties.\n         TM    LWAMFLG,X'20'      Do we have a size for the E2 table?\n         BZ    E2CHNOSZ           No.\n         OI    FLAGZ,X'04'        Yes. Flag that we have a size.\n         STM   R14,R1,SAVE1401    Save registers 14 thru 1.\n         MVC   MESSAG1A+6(2),CODEPLAC    Move in table code.\n         HEX   MESSAG1A+57,2,SAVETE2L    Move in length amount\n         MVI   MESSAG1A+61,C'.'          Put period at end.\n         APUT  MESSAG1A,L'MESSAG1A\n         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.\n         B     E2CHYSSZ\nE2CHNOSZ DS    0H                 Show message that we have no size\n         STM   R14,R1,SAVE1401    Save registers 14 thru 1.\n         MVC   MESSAG1B+6(2),CODEPLAC    Move in table code.\n         APUT  MESSAG1B,L'MESSAG1B\n         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.\nE2CHYSSZ DS    0H\n         TM    LWAPFLG,X'20'      Was the E2 table loaded from STEPLIB?\n         BZ    E2CHNOST           No. Say that it wasn't.\n         STM   R14,R1,SAVE1401    Yes. Put out message saying it was.\n         MVC   MESSAG1C+6(2),CODEPLAC    Move in table code.\n         APUT  MESSAG1C,L'MESSAG1C\n         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.\n         B     E2CHYSST\nE2CHNOST DS    0H                 Message. Table not from STEPLIB.\n         STM   R14,R1,SAVE1401    Save registers 14 thru 1.\n         MVC   MESSAG1D+6(2),CODEPLAC    Move in table code.\n         APUT  MESSAG1D,L'MESSAG1D\n         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.\nE2CHYSST DS    0H\n*-*                               Print out table header\n         BAL   R9,PRTABLHD        Table Header Display Routine\n*-*\n         LA    R1,X'10'(,R1)      Bump past header\n         ST    R1,TABLSTRT        Store new start address\n* - -\n         LH    R2,SAVETE2L        Load LWA Table Length\n         LTR   R2,R2              Is it there?\n         BNZ   E2CHHAVB           There is a length, so we use it.\n* - -                             None there, have to guess.\n***\n         LH    R3,ME08LENG        Measured table length.\n***\n         B     E2CHNOHB           And go on.\nE2CHHAVB DS    0H                 We have a table length given.\n         MVC   SAVETCUR,SAVETE2L  This is the length we use for now.\n         LR    R3,R2              Dump the number into R3.\nE2CHNOHB DS    0H\n         L     R4,TABLADDR        Load start address of table\n         AR    R4,R3              Point past the guessed end of table.\n         S     R4,=F'16'          Compensate for 16 byte head start.\n         ST    R4,TABLEND         Store away guessed table end.\n* - -\n         LR    R5,R3              Dump best length into register.\n         SRL   R5,3               Divide by 8.\n         BCTR  R5,0               Actually two fewer entries, because\n         BCTR  R5,0                of the header.\n         ST    R5,TABLENUM        Store the number of entries.\n***\n         STM   R14,R1,SAVE1401    Save registers 14 thru 1.\n         MVC   LINE,LINE-1\n         ST    R1,SAVER1B\n         L     R1,TABLENUM         Display field\n         CVD   R1,CVDAREA          Convert count to printable\n         MVC   LINE+22(10),MASK10  Move in the mask\n         ED    LINE+22(10),CVDAREA+3 Make it pretty\n         L     R1,SAVER1B\n         MVC   LINE(24),=C'Number of valid entries:'\n         APUT  LINE,45\n         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.\n***\n* - >\n         LA    R5,8               Size of each E2 table entry\n         ST    R5,TABLESIZ        Store size of each entry\n*                                 We'll stop the search at first blank\n         SR    R4,R5              Point past end of table - guessed.\n         ST    R4,SAVLSLOT        Store this location\n         TM    OFFFLAG,X'04'      Is this just a contents display?\n         BZ    E2CHANGX           No. We must do a real change.\n         BAL   R9,DISPTABL        Yes. Just display.\n         BAL   R9,CHANGED         Message that nothing changed.\n         B     EOJ0\nE2CHANGX DS    0H\n         BAL   R9,DISPTABL        Search table for the proper entry.\n         BAL   R9,SETTMODE        Do the Key 0 stuff\n         BAL   R9,CHANGED         Tell em we changed the values.\n         B     EOJ0\n** ---------------------------------------------------------------- **\nE8CHANGE DS    0H                 Handle the E8 table\n         OI    TIDFLAG,X'10'      Show we're doing the E8 table.\n         MVC   TABLEID,=C'E8'     Identify which table\n         BAL   R9,ADJNEXTP        Get to first blank\n         BAL   R9,NAMEPARM        Get rest of parms from the command\n         L     R4,SAVETE8         Point to saved E8 table address\n         ST    R4,TABLSTRT        Store start address of table\n         ST    R4,TABLADDR        Keep start address of table\n*\n         BAL   R9,TESTLPA         Check if table address is in LPA\n         BAL   R9,CHANGEDL        LPA message (conditional)\n         BAL   R9,MEASUR08        Measure the table\n*\n         L     R1,TABLSTRT        Load it back into work register\n**-->>\nE8CHENTY DS    0H                 Deal with the E8 table.             .\n         TM    LPAFLAG,X'01'      Is this table in LPA?\n         BO    E8CHYSST           Yes. Don't message the properties.\n         TM    LWAMFLG,X'10'      Do we have a size for the E8 table?\n         BZ    E8CHNOSZ           No.\n         OI    FLAGZ,X'04'        Yes. Flag that we have a size.\n         STM   R14,R1,SAVE1401    Save registers 14 thru 1.\n         MVC   MESSAG1A+6(2),CODEPLAC    Move in table code.\n         HEX   MESSAG1A+57,2,SAVETE8L    Move in length amount\n         MVI   MESSAG1A+61,C'.'          Put period at end.\n         APUT  MESSAG1A,L'MESSAG1A\n         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.\n         B     E8CHYSSZ\nE8CHNOSZ DS    0H\n         STM   R14,R1,SAVE1401    Save registers 14 thru 1.\n         MVC   MESSAG1B+6(2),CODEPLAC    Move in table code.\n         APUT  MESSAG1B,L'MESSAG1B\n         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.\nE8CHYSSZ DS    0H\n         TM    LWAPFLG,X'10'      Was the E8 table loaded from STEPLIB?\n         BZ    E8CHNOST           No. Say that it wasn't.\n         STM   R14,R1,SAVE1401    Yes. Put out message saying it was.\n         MVC   MESSAG1C+6(2),CODEPLAC    Move in table code.\n         APUT  MESSAG1C,L'MESSAG1C\n         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.\n         B     E8CHYSST\nE8CHNOST DS    0H                 Message. Table not from STEPLIB.\n         STM   R14,R1,SAVE1401    Save registers 14 thru 1.\n         MVC   MESSAG1D+6(2),CODEPLAC    Move in table code.\n         APUT  MESSAG1D,L'MESSAG1D\n         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.\nE8CHYSST DS    0H\n*-*                               Print out table header\n         BAL   R9,PRTABLHD        Table Header Display Routine\n*-*\n         LA    R1,X'10'(,R1)      Bump past header\n         ST    R1,TABLSTRT        Store new start address\n* - -\n         LH    R2,SAVETE8L        Load LWA Table Length\n         LTR   R2,R2              Is it there?\n         BNZ   E8CHHAVB           There is a length, so we use it.\n* - -                             None there, have to guess.\n***\n         LH    R3,ME08LENG        Measured table length.\n***\n         B     E8CHNOHB           And go on.\nE8CHHAVB DS    0H                 We have a table length given.\n         MVC   SAVETCUR,SAVETE8L  This is the length we use for now.\n         LR    R3,R2              Dump the number into R3.\nE8CHNOHB DS    0H\n         L     R4,TABLADDR        Load start address of table\n         AR    R4,R3              Point past the guessed end of table.\n         S     R4,=F'16'          Compensate for 16 byte head start.\n         ST    R4,TABLEND         Store away guessed table end.\n* - -\n         LR    R5,R3              Dump best length into register.\n         SRL   R5,3               Divide by 8.\n         BCTR  R5,0               Actually two fewer entries, because\n         BCTR  R5,0                of the header.\n         ST    R5,TABLENUM        Store the number of entries.\n***\n         STM   R14,R1,SAVE1401    Save registers 14 thru 1.\n         MVC   LINE,LINE-1\n         ST    R1,SAVER1B\n         L     R1,TABLENUM         Display field\n         CVD   R1,CVDAREA          Convert count to printable\n         MVC   LINE+22(10),MASK10  Move in the mask\n         ED    LINE+22(10),CVDAREA+3 Make it pretty\n         L     R1,SAVER1B\n         MVC   LINE(24),=C'Number of valid entries:'\n         APUT  LINE,45\n         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.\n***\n* - -\n         LA    R5,8               Size of each E8 table entry\n         ST    R5,TABLESIZ        Store size of each entry\n* - -                             We'll stop the search at first blank\n         SR    R4,R5              Point past end of table - guessed.\n         ST    R4,SAVLSLOT        Store this location\n         TM    OFFFLAG,X'04'      Is this just a contents display?\n         BZ    E8CHANGX           No. We must do a real change.\n         BAL   R9,DISPTABL        Yes. Just display.\n         BAL   R9,CHANGED         Message that nothing changed.\n         B     EOJ0\nE8CHANGX DS    0H\n         BAL   R9,DISPTABL        Search table for the proper entry.\n         BAL   R9,SETTMODE        Do the Key 0 stuff\n         BAL   R9,CHANGED         Tell em we changed the values.\n         B     EOJ0\n** ---------------------------------------------------------------- **\nAPCHANGE DS    0H                 Handle the AP table\n         OI    TIDFLAG,X'80'      Show we're doing the AP table.\n         MVC   TABLEID,=C'AP'     Identify which table\n         BAL   R9,ADJNEXTP        Get to first blank\n         BAL   R9,NAMEPARM        Get rest of parms from the command\n* - -\n         L     R4,SAVETAP         Get address of AP table\n         ST    R4,TABLSTRT        Store start address of table\n         ST    R4,TABLADDR        Keep start address of table\n*\n         BAL   R9,TESTLPA         Check if table address is in LPA\n         BAL   R9,CHANGEDL        LPA message (conditional)\n         BAL   R9,MEASUR08        Measure the table\n*\n         L     R1,TABLSTRT        Load it back into work register\n**-->>\nAPCHENTY DS    0H                 Table was made from a IKJTSOxx entry.\n         TM    LPAFLAG,X'01'      Is this table in LPA?\n         BO    APCHYSST           Yes. Don't message the properties.\n         TM    LWAMFLG,X'80'      Do we have a size for the AP table?\n         BZ    APCHNOSZ           No.\n         OI    FLAGZ,X'04'        Yes. Flag that we have a size.\n         STM   R14,R1,SAVE1401    Save registers 14 thru 1.\n         MVC   MESSAG1A+6(2),CODEPLAC    Move in table code.\n         HEX   MESSAG1A+57,2,SAVETAPL    Move in length amount\n         MVI   MESSAG1A+61,C'.'          Put period at end.\n         APUT  MESSAG1A,L'MESSAG1A\n         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.\n         B     APCHYSSZ\nAPCHNOSZ DS    0H\n         STM   R14,R1,SAVE1401    Save registers 14 thru 1.\n         MVC   MESSAG1B+6(2),CODEPLAC    Move in table code.\n         APUT  MESSAG1B,L'MESSAG1B\n         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.\nAPCHYSSZ DS    0H\n         TM    LWAPFLG,X'80'      Was the AP table loaded from STEPLIB?\n         BZ    APCHNOST           No. Say that it wasn't.\n         STM   R14,R1,SAVE1401    Yes. Put out message saying it was.\n         MVC   MESSAG1C+6(2),CODEPLAC    Move in table code.\n         APUT  MESSAG1C,L'MESSAG1C\n         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.\n         B     APCHYSST\nAPCHNOST DS    0H                 Message. Table not from STEPLIB.\n         STM   R14,R1,SAVE1401    Save registers 14 thru 1.\n         MVC   MESSAG1D+6(2),CODEPLAC    Move in table code.\n         APUT  MESSAG1D,L'MESSAG1D\n         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.\nAPCHYSST DS    0H\n*-*                               Print out table header\n         BAL   R9,PRTABLHD        Table Header Display Routine\n*-*\n         LA    R1,X'10'(,R1)      Bump past header\n         ST    R1,TABLSTRT        Store new start address\n* - -\n         LH    R2,SAVETAPL        Load LWA Table Length\n         LTR   R2,R2              Is it there?\n         BNZ   APCHHAVB           There is a length, so we use it.\n* - -                             None there, have to guess.\n***\n         LH    R3,ME08LENG        Measured table length.\n***\n         B     APCHNOHB           And go on.\nAPCHHAVB DS    0H                 We have a table length given.\n         MVC   SAVETCUR,SAVETAPL  This is the length we use for now.\n         LR    R3,R2              Dump the number into R3.\nAPCHNOHB DS    0H\n         L     R4,TABLADDR        Load start address of table\n         AR    R4,R3              Point past the guessed end of table.\n         S     R4,=F'16'          Compensate for 16 byte head start.\n         ST    R4,TABLEND         Store away guessed table end.\n* - -\n         LR    R5,R3              Dump best length into register.\n         SRL   R5,3               Divide by 8.\n         BCTR  R5,0               Actually two fewer entries, because\n         BCTR  R5,0                of the header.\n         ST    R5,TABLENUM        Store the number of entries.\n***\n         STM   R14,R1,SAVE1401    Save registers 14 thru 1.\n         MVC   LINE,LINE-1\n         ST    R1,SAVER1B\n         L     R1,TABLENUM         Display field\n         CVD   R1,CVDAREA          Convert count to printable\n         MVC   LINE+22(10),MASK10  Move in the mask\n         ED    LINE+22(10),CVDAREA+3 Make it pretty\n         L     R1,SAVER1B\n         MVC   LINE(24),=C'Number of valid entries:'\n         APUT  LINE,45\n         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.\n***\n* - -\n         LA    R5,8               Size of each AP table entry\n         ST    R5,TABLESIZ        Store size of each entry\n* - -                             We'll stop the search at first blank\n         SR    R4,R5              Point past end of table - guessed.\n         ST    R4,SAVLSLOT        Save this location.\n         TM    OFFFLAG,X'04'      Is this just a contents display?\n         BZ    APCHANGX           No. We must do a real change.\n         BAL   R9,DISPTABL        Yes. Just display.\n         BAL   R9,CHANGED         Message that nothing changed.\n         B     EOJ0\nAPCHANGX DS    0H\n         BAL   R9,DISPTABL        Search table for the proper entry.\n         BAL   R9,SETTMODE        Do the Key 0 stuff\n         BAL   R9,CHANGED         Tell em we changed the values.\n         B     EOJ0\n** ---------------------------------------------------------------- **\nPCCHANGE DS    0H                 Handle the PC table\n         OI    TIDFLAG,X'01'      Show PC table chosen.\n         MVC   TABLEID,=C'PC'\n         TM    PLATFLG,X'01'      Does the table exist?\n         BZ    PCCHAERR           No. Report error.\n         BAL   R9,ADJNEXTP        Get to first blank\n         BAL   R9,NAMEPARM        Get rest of parms from the command\n         L     R2,SAVEFCVE        Get the PC table address\n         LR    R4,R2              Save it off\n         ST    R4,DISPREG         Store register contents for display\n* -- >                            Do Display\n*-*-*->>                          Print the address out so we can see.\n         STM   R14,R1,SAVE1401    Save registers 14 thru 1.\n         MVC   LINE,LINE-1        Clear line area.\n         MVC   LINE(16),=C'Table address:  '\n         HEX   LINE+21,4,DISPREG      Display address in Hex\n         APUT  LINE,35\n         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.\n*-*-*->>\n* -- >\n         L     R3,X'8'(,R4)       Point to length of table\n         STH   R3,SAVETCUR        Store it to show non-zero\n         AR    R4,R3              Point just past PC table\n         ST    R4,TABLEND         And mark the projected end of table\n* - -\n         L     R3,X'C'(,R2)       Get number of table entries\n         ST    R3,TABLENUM        Preserve number for table search\n         LA    R3,8               Load table size\n         ST    R3,TABLESIZ        And store it for DISPTABL routine\n** -- **\n***\n         STM   R14,R1,SAVE1401    Save registers 14 thru 1.\n         MVC   LINE,LINE-1\n         MVC   LINE(22),=C'Table length in Hex:  '\n         HEX   LINE+25,2,SAVETCUR\n         APUT  LINE,45\n         MVC   LINE,LINE-1\n         ST    R1,SAVER1B\n         L     R1,TABLENUM         Display field\n         CVD   R1,CVDAREA          Convert count to printable\n         MVC   LINE+22(10),MASK10  Move in the mask\n         ED    LINE+22(10),CVDAREA+3 Make it pretty\n         L     R1,SAVER1B\n         MVC   LINE(24),=C'Number of valid entries:'\n         APUT  LINE,45\n         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.\n***\n** -- **\n         L     R3,SAVEFCVE        Get the platcmd table start address\n         LA    R3,X'10'(,R3)      Bump past its header\n         ST    R3,TABLSTRT        And store the starting place away\n* - -\n         LA    R5,8               Get 8 bytes ready for subtraction\n         SR    R4,R5              Back up to the last slot\n         ST    R4,SAVLSLOT        Save location of last table slot\n         TM    OFFFLAG,X'04'      Is this just a contents display?\n         BZ    PCCHANGX           No. We must do a real change.\n         BAL   R9,DISPTABL        Yes. Just display.\n         BAL   R9,CHANGED         Message\n         B     EOJ0\nPCCHANGX DS    0H\n         BAL   R9,DISPTABL        Search table for the proper entry.\n         BAL   R9,SETTMODE        Do the Key 0 stuff\n         BAL   R9,CHANGED         Tell em we changed the values.\n         B     EOJ0\nPCCHAERR DS    0H                 Say no PC table exists.\n         MVC   LINE,LINE-1\n         MVC   LINE(43),=C'PC command not valid if no PC table exists.'\n         APUT  LINE,43\n         B     EOJ4\nPCCHAEND DS    0H\n         B     EOJ0\n** ---------------------------------------------------------------- **\nPPCHANGE DS    0H                 Handle the PP table\n         OI    TIDFLAG,X'02'      Show PP table chosen.\n         MVC   TABLEID,=C'PP'\n         TM    PLATFLG,X'02'      Is there a Platpgm table?\n         BZ    PPCHAERR           If no, then display error condition\n         BAL   R9,ADJNEXTP        Get to first blank\n         BAL   R9,NAMEPARM        Get rest of parms from the command\n         L     R2,SAVEPPVE        Get the PP table address\n         LR    R4,R2              Save it off\n         ST    R4,DISPREG         Store PP table address for display\n* -- >                            Do Display\n*-*-*->>                          Print the address out so we can see.\n         STM   R14,R1,SAVE1401    Save registers 14 thru 1.\n         MVC   LINE,LINE-1        Clear line area.\n         MVC   LINE(16),=C'Table address:  '\n         HEX   LINE+21,4,DISPREG      Display address in Hex\n         APUT  LINE,35\n         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.\n*-*-*->>\n* -- >\n         L     R3,X'8'(,R4)       Size of PP table in bytes\n         STH   R3,SAVETCUR        Show it's non-zero\n         AR    R4,R3              Point just past the PP table\n         ST    R4,TABLEND         Mark the end of table for DISPTABL\n* - -\n         L     R3,X'C'(,R2)       Get number of table entries\n         ST    R3,TABLENUM        Store that number away for DISPTABL\n         LA    R3,8               Size of each entry\n         ST    R3,TABLESIZ        Store that away too\n** -- **\n***\n         STM   R14,R1,SAVE1401    Save registers 14 thru 1.\n         MVC   LINE,LINE-1\n         MVC   LINE(22),=C'Table length in Hex:  '\n         HEX   LINE+25,2,SAVETCUR\n         APUT  LINE,45\n         MVC   LINE,LINE-1\n         ST    R1,SAVER1B\n         L     R1,TABLENUM         Display field\n         CVD   R1,CVDAREA          Convert count to printable\n         MVC   LINE+22(10),MASK10  Move in the mask\n         ED    LINE+22(10),CVDAREA+3 Make it pretty\n         L     R1,SAVER1B\n         MVC   LINE(24),=C'Number of valid entries:'\n         APUT  LINE,45\n         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.\n***\n** -- **\n         L     R3,SAVEPPVE        Get start address of PP table\n         LA    R3,X'10'(,R3)      Add 16 to bump past header\n         ST    R3,TABLSTRT        Store search starting address away\n* - -\n         LA    R5,8               Load size of one entry\n         SR    R4,R5              Back up to last slot address\n         ST    R4,SAVLSLOT        And save it off.\n         TM    OFFFLAG,X'04'      Is this just a contents display?\n         BZ    PPCHANGX           No. We must do a real change.\n         BAL   R9,DISPTABL        Yes. Just display.\n         BAL   R9,CHANGED         Message\n         B     EOJ0\nPPCHANGX DS    0H\n         BAL   R9,DISPTABL        Search table for the proper entry.\n         BAL   R9,SETTMODE        Do the Key 0 stuff\n         BAL   R9,CHANGED         Tell em we changed the values.\n         B     EOJ0\nPPCHAERR DS    0H                 Say no PC table exists.\n         MVC   LINE,LINE-1\n         MVC   LINE(43),=C'PP command not valid if no PP table exists.'\n         APUT  LINE,43\n         B     EOJ4\nPPCHAEND DS    0H\n         B     EOJ0\n** ---------------------------------------------------------------- **\nNSCHANGE DS    0H                 Handle the NS table\n         OI    TIDFLAG,X'40'      Show we're doing the NS table.\n         MVC   TABLEID,=C'NS'     Identify which table\n         BAL   R9,ADJNEXTP        Get to first blank\n         BAL   R9,NAMEPARM        Get rest of parms from the command\n         OI    NSCHFLG,X'01'      Show SETTMODE we're doing NS\n* - -\n         L     R4,SAVETNS         Saved location of the NS table\n         ST    R4,TABLSTRT        Store start address of table\n         ST    R4,TABLADDR        Keep start address of table\n*\n         BAL   R9,TESTLPA         Check if table address is in LPA\n         BAL   R9,CHANGEDL        LPA message (conditional)\n         BAL   R9,MEASUR10        Measure the table\n*\n         L     R1,TABLSTRT        Load it to start table search later\n**-->>\nNSCHENTY DS    0H                 Table was made from a IKJTSOxx entry.\n         TM    LPAFLAG,X'01'      Is this table in LPA?\n         BO    NSCHYSST           Yes. Don't message the properties.\n         TM    LWAMFLG,X'40'      Do we have a size for the NS table?\n         BZ    NSCHNOSZ           No.\n         OI    FLAGZ,X'04'        Yes. Flag that we have a size.\n         STM   R14,R1,SAVE1401    Save registers 14 thru 1.\n         MVC   MESSAG1A+6(2),CODEPLAC    Move in table code.\n         HEX   MESSAG1A+57,2,SAVETNSL    Move in length amount\n         MVI   MESSAG1A+61,C'.'          Put period at end.\n         APUT  MESSAG1A,L'MESSAG1A\n         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.\n         B     NSCHYSSZ\nNSCHNOSZ DS    0H                 Say we have no size for the NS table\n         STM   R14,R1,SAVE1401    Save registers 14 thru 1.\n         MVC   MESSAG1B+6(2),CODEPLAC    Move in table code.\n         APUT  MESSAG1B,L'MESSAG1B\n         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.\nNSCHYSSZ DS    0H\n         TM    LWAPFLG,X'40'      Was the NS table loaded from STEPLIB?\n         BZ    NSCHNOST           No. Say that it wasn't.\n         STM   R14,R1,SAVE1401    Yes. Put out message saying it was.\n         MVC   MESSAG1C+6(2),CODEPLAC    Move in table code.\n         APUT  MESSAG1C,L'MESSAG1C\n         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.\n         B     NSCHYSST           Don't put out contradictory messages\nNSCHNOST DS    0H                 Message. Table not from STEPLIB.\n         STM   R14,R1,SAVE1401    Save registers 14 thru 1.\n         MVC   MESSAG1D+6(2),CODEPLAC    Move in table code.\n         APUT  MESSAG1D,L'MESSAG1D\n         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.\nNSCHYSST DS    0H\n*-*                               Print out table header\n         BAL   R9,PRTABLHD        Table Header Display Routine\n*-*\n         LA    R1,X'10'(,R1)      Bump past the table header\n         ST    R1,TABLSTRT        Store new start address for DISPTABL\n* - -\n         LH    R2,SAVETNSL        Load LWA Table Length\n         LTR   R2,R2              Is it there?\n         BNZ   NSCHHAVB           There is a length, so we use it.\n* - -                             None there, have to guess.\n***\n         LH    R3,ME10LENG        Measured table length.\n***\n         B     NSCHNOHB           And go on.\nNSCHHAVB DS    0H                 We have a table length given.\n         MVC   SAVETCUR,SAVETNSL  This is the length we use for now.\n         LR    R3,R2              Dump the number into R3.\nNSCHNOHB DS    0H\n         L     R4,TABLADDR        Load start address of table\n         AR    R4,R3              Point past the guessed end of table.\n*        S     R4,=F'16'          Compensate for 16 byte head start.\n         ST    R4,TABLEND         Store away guessed table end.\n* - -\n         LR    R5,R3              Dump best length into register.\n         S     R5,=F'16'\n         STM   R2,R3,SAVER23      Save work registers.\n         XR    R2,R2              Zero work registers.\n         XR    R3,R3\n         LR    R3,R5              Feed length into work register\n         D     R2,=F'10'          Divide by 10.\n         LR    R5,R3              Save the result.\n         LM    R2,R3,SAVER23      Restore work registers.\n         ST    R5,TABLENUM        Store the number of entries.\n***\n         STM   R14,R1,SAVE1401    Save registers 14 thru 1.\n         MVC   LINE,LINE-1\n         ST    R1,SAVER1B\n         L     R1,TABLENUM         Display field\n         CVD   R1,CVDAREA          Convert count to printable\n         MVC   LINE+22(10),MASK10  Move in the mask\n         ED    LINE+22(10),CVDAREA+3 Make it pretty\n         L     R1,SAVER1B\n         MVC   LINE(24),=C'Number of valid entries:'\n         APUT  LINE,45\n         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.\n***\n* - -\n         XR    R5,R5              Clear register\n         LA    R5,10              Size of each NS table entry\n         ST    R5,TABLESIZ        Store size of each table entry\n* - -                             We'll stop the search at first blank\n         SR    R4,R5              Point to Last Slot\n         ST    R4,SAVLSLOT        Save location of last slot\n         TM    OFFFLAG,X'04'      Is this just a contents display?\n         BZ    NSCHANGX           No. We must do a real change.\n         BAL   R9,DISPTABL        Yes. Just display.\n         BAL   R9,CHANGED         Message that nothing changed.\n         B     EOJ0\nNSCHANGX DS    0H\n         BAL   R9,DISPTABL        Search table for the proper entry.\n         BAL   R9,SETTMODE        Do the Key 0 stuff\n         BAL   R9,CHANGED         Tell em we changed the values.\n         B     EOJ0\n** ---------------------------------------------------------------- **\n* ----------------------------------------------------------------- *\n*     Various \"abnormal ending\" routines.                           *\n* ----------------------------------------------------------------- *\nNOTAUTH  DS    0H                     Command not authorized message.\n         APUT  MESSAG2C,L'MESSAG2C\n         APUT  MESSAG2D,L'MESSAG2D\n         B     EOJC\n* ----------------------------------------------------------------- *\nNOE2     DS    0H                 No Parmlib-supplied table there.\n         MVC   LINE,LINE-1\n         MVC   LINE(L'MESSAGEP),MESSAGEP\n         MVC   LINE+20(2),=C'E2'\n         APUT  LINE,L'MESSAGEP\n         B     EOJ4\n* ----------------------------------------------------------------- *\nNOE8     DS    0H                 No Parmlib-supplied table there.\n         MVC   LINE,LINE-1\n         MVC   LINE(L'MESSAGEP),MESSAGEP\n         MVC   LINE+20(2),=C'E8'\n         APUT  LINE,L'MESSAGEP\n         B     EOJ4\n* ----------------------------------------------------------------- *\nNOAP     DS    0H                 No Parmlib-supplied table there.\n         MVC   LINE,LINE-1\n         MVC   LINE(L'MESSAGEP),MESSAGEP\n         MVC   LINE+20(2),=C'AP'\n         APUT  LINE,L'MESSAGEP\n         B     EOJ4\n* ----------------------------------------------------------------- *\nNONS     DS    0H                 No Parmlib-supplied table there.\n         MVC   LINE,LINE-1\n         MVC   LINE(L'MESSAGEP),MESSAGEP\n         MVC   LINE+20(2),=C'NS'\n         APUT  LINE,L'MESSAGEP\n         B     EOJ4\n* ----------------------------------------------------------------- *\nNOTNUMER DS    0H                 Message that a parm was not numeric\n         MVC   LINE,LINE-1\n         MVC   LINE(L'MESSAGEN),MESSAGEN\n         MVC   LINE+21(1),0(R4)\n         APUT  LINE,L'MESSAGEN\n         B     EOJ4\n** ---------------------------------------------------------------- **\n**    Some of the Register and Pointer Save Areas                   **\n** ---------------------------------------------------------------- **\nSAVEPARM DC    F'0'                   Parm address from R1 at entry\nSAVETPVT DC    F'0'                   Address of TPVT control block\nSAVECTLT DC    F'0'                   Address of CTLT control block\nSAVEFCVE DC    F'0'                   Address of Platcmd table if non-0\nSAVEPPVE DC    F'0'                   Address of Platpgm table if non-0\nSAVEUPT  DC    F'0'                   Address of UPT\nSAVEECT  DC    F'0'                   Address of ECT\nSAVEPSCB DC    F'0'                   Address of PSCB\nSAVETNS  DC    F'0'                   Address of NS table\nSAVETE2  DC    F'0'                   Address of E2 table\nSAVETE8  DC    F'0'                   Address of E8 table\nSAVETAP  DC    F'0'                   Address of AP table\nSAVETNSL DC    H'0'                   Length of NS table, if nonzero\nSAVETE2L DC    H'0'                   Length of E2 table, if nonzero\nSAVETE8L DC    H'0'                   Length of E8 table, if nonzero\nSAVETAPL DC    H'0'                   Length of AP table, if nonzero\nSAVETCUR DC    H'0'                   Copied length of current table\nSAVETNEW DC    H'0'                   Changed length of current table\n** ---------------------------------------------------------------- **\nFULLZERO DC    F'0'                   Fullword of numeric 0\nFULLFOUR DC    F'4'                   Fullword 4\nFULLEIGT DC    F'8'                   Fullowrd 8\nFULLTWLV DC    F'12'                  Fullword 12\nSAVE1401 DC    5F'0'                  More for safety\nLWAADDR  DC    F'0'                   Address of LWA control block\n* - - - - - - - - - - - - - - - - - - - - - - - - *\nMOVOUTL  MVC   TABCODE(*-*),0(R1)     EXECUTED\nMOVFSTN  MVC   FSTNAME(*-*),0(R3)     EXECUTED\nMOVSNDN  MVC   SNDNAME(*-*),0(R1)     EXECUTED\nMOVFNUM  MVC   FSTNUME(*-*),0(R3)     EXECUTED\nPACK     PACK  WORKA,0(0,3)          <<< EXECUTED >>>\n** ---------------------------------------------------------------- **\n*          * - - - - - - - - - - - - - - - - - - - - - - - - *\n*          *            S U B R O U T I N E S                *\n*          * - - - - - - - - - - - - - - - - - - - - - - - - *\n** ---------------------------------------------------------------- **\n**  These are executed using a BAL R9,subroutn  instruction.        **\n** ---------------------------------------------------------------- **\nHEX      DS    0H\n         ST    R9,SAVER9A\n         MVC   1(1,R15),0(R1)        Move byte\n         UNPK  0(3,R15),1(2,R15)     Unpack\n         TR    0(2,R15),HEXTAB-240\n         LA    R15,2(,R15)           Increment output pointer\n         LA    R1,1(,R1)             Increment input pointer\n         BCT   R0,HEX                Decrement length, then loop\n         MVI   0(R15),C' '           Blank the trailing byte\n         L     R9,SAVER9A\n         BR    R9                    Return to caller\nHEXTAB   DC    C'0123456789ABCDEF'   Translate table\nHEXSAVE  DS    3F                    Register save for HEX macro\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nGETNAMES DS    0H                  Get program name from parm.\n         ST    R9,SAVER9B          Save BAL register\n         ST    R2,SAVER2D          Save work register\nGETNAMST DS    0H                  Get rid of leading blanks\n         L     R1,CHARCONT         Point to start of character\n         CLI   0(R1),X'40'         Is it a blank?\n         BNE   GETNAMNZ            No. Get the entire name.\n         LA    R1,1(,R1)           Yes. Bump start place one up.\n         ST    R1,CHARCONT         And store the place away for now.\n         C     R5,=F'1'            End of cmd buffer one away?\n         BNH   EOJ4                Yes. Error.\n         BCTR  R5,0                Subtract one from end count\n         B     GETNAMST            And loop to find first non-blank.\nGETNAMNZ DS    0H                  Got first non-blank. Get whole name.\n         LA    R2,8                BCT initial quantity - 8 chars.\n         LA    R8,0                Character count\n         L     R1,CHARCONT         Load starting place\n         LR    R4,R1               Initialize pointer\n         LA    R4,0(,R4)           to first character of program name.\nGETNAMLU DS    0H                  Loop to get entire name\n         CLI   0(R4),X'40'         First blank?\n         BE    GETNAMGT            Yes, got whole name.\n         CLI   0(R4),X'00'         First hex zeros?\n         BE    GETNAMGT            Yes, got whole name.\n         CR    R8,R5               End of command buffer?\n         BNL   GETNAMGT            Yes. Got all we can get.\n         LA    R8,1(,R8)           Bump character counter.\n         LA    R4,1(,R4)           Bump where we are.\n         BCT   R2,GETNAMLU         Loop back.\nGETNAMGT DS    0H\n         ST    R8,SAVER8A          Save character count\n         ST    R8,FSTCOUNT         Again.\n         CLC   SAVER8A,=F'0'       Is character count (left) 0?\n         BNE   GETREALY            No. Go on processing for name.\n         BAL   R9,MISSPGM2         Say we're missing a program name.\n         B     EOJ4                And get out with code = 4.\nGETREALY DS    0H\n         MVC   FSTCHALF(2),FSTCOUNT+2    Get halfword program length\n         MVC   LINE,LINE-1               Print it in message\n         HEX   LINE,4,SAVER8A\n         MVC   LINE+13(17),=C'Length of command'\n         APUT  LINE,30\n         L     R3,CHARCONT         Load starting place again.\n         BCTR  R8,0                One less for EXECUTE.\n         MVC   FSTNAME(8),BLANKS   Blank entire target field.\n         EX    R8,MOVFSTN          Move program name to target.\n         OC    FSTNAME(8),BLANKS   Uppercase the program name.\n         MVC   LINE,LINE-1         And print its name out.\n         MVC   LINE(8),FSTNAME\n         MVC   LINE+13(17),=C'New program name '\n         APUT  LINE,30\n* - >\nGETNAMEN DS    0H                  Exit this routine.\n         L     R2,SAVER2D          Restore work register\n         L     R9,SAVER9B          Restore BAL register\n         BR    R9\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nCHANGED  DS    0H                     The \"value was changed\" message.\n         ST    R9,SAVER9C\n         TM    LPAFLAG,X'01'          Is the table within LPA?\n         BO    CHANGEND               Yes. Change already shown.\n         TM    FLAGZ,X'02'            Is parm number past end of table?\n         BO    CHANGEDN               Yes. Bypass all operations here.\n         TM    OFFFLAG,X'01'          Replacement?\n         BO    CHANGEDA               Say what was replaced\n         TM    OFFFLAG,X'02'          Blanking?\n         BO    CHANGEDB               Say what was blanked\n         TM    OFFFLAG,X'04'          Display?\n         BO    CHANGEDD               Skip saying anything was changed.\n         TM    OFFFLAG,X'08'          Change header to \" PARMLIB\"?\n         BO    CHANGEDH               Write message that its done.\n         TM    OFFFLAG,X'10'          Supply lengths in LWA?\n         BO    CHANGEDK               Write appropriate messages.\n         TM    OFFFLAG,X'20'          Zero lengths in LWA?\n         BO    CHANGEDZ               Write appropriate messages.\n*                                     X'40' dealt with in SETSTEPL\n*                                     X'80' dealt with in NOTSTEPL\n         B     CHANGEND\nCHANGEDA DS    0H                     Replacing a table entry.\n         MVC   LINE,LINE-1\n         APUT  LINE,30\n         APUT  MESSAGEC,L'MESSAGEC    Say \"before making changes\".\n         MVC   MESSAG3A+5(4),TABENNUM+6\n         MVC   MESSAG3A+13(2),CODEPLAC     Move in table code.\n         MVC   MESSAG3A+42(8),FSTNAME      Move in program name.\n         APUT  MESSAG3A,L'MESSAG3A    Tell em we changed the value.\n         B     CHANGEND\nCHANGEDB DS    0H                     Blanking a table entry.\n         MVC   LINE,LINE-1\n         APUT  LINE,30\n         APUT  MESSAGEC,L'MESSAGEC    Say \"before making changes\".\n         MVC   MESSAG3B+5(4),TABENNUM+6\n         MVC   MESSAG3B+13(2),CODEPLAC     Move in table code.\n         MVC   MESSAG3B+42(8),FSTNAME      Move in program name.\n         APUT  MESSAG3B,L'MESSAG3B    Tell em we changed the value.\n         B     CHANGEND\nCHANGEDD DS    0H                     Displaying table entries (entry)\n         TM    OFFFLAG,X'04'\n         BZ    CHANGEDX               Not display? Say what's in slot.\n         CLC   SLOTBIN,=F'0'          Display entire table?\n         BE    CHANGEND               Don't say anything changed.\nCHANGEDX DS    0H                     Say we're displaying 1 slot.\n         MVC   LINE,LINE-1\n         MVC   LINE(30),=C'Display of Slot contents.     '\n         APUT  LINE,30\n         B     CHANGEND\nCHANGEDN DS    0H                     Say nothing changed.\n         APUT  MESSAG2D,L'MESSAG2D\n         B     CHANGEND\nCHANGEDH DS    0H                 Putting \" PARMLIB\" in table header.\n         TM    TIDFLAG,X'03'      Dealing with PC or PP?\n         BNZ   CHANGEDN           Yes. Show nothing was changed.\n         MVC   LINE,LINE-1\n         APUT  LINE,30\n         APUT  MESSAGEC,L'MESSAGEC       Say \"before making changes\".\n         APUT  MESSAG3D,L'MESSAG3D\n         BAL   R9,PRTABLHD        Table Header Display Routine\n         B     CHANGEND\nCHANGEDK DS    0H                 \"Supply table lengths\" message.\n         TM    TIDFLAG,X'03'      Dealing with PC or PP?\n         BNZ   CHANGEDN           Yes. Show nothing was changed.\n         MVC   LINE,LINE-1               Print a blank line.\n         APUT  LINE,30\n         APUT  MESSAGEC,L'MESSAGEC       Say \"before making changes\".\n         MVC   MESSAG3E+19(2),TABLEID    Put table id into message.\n         HEX   MESSAG3E+48,2,SAVETCUR    Old message length\n         CLC   TABLEID,=C'NS'            Is it the NS table?\n         BE    CHANGK01\n         HEX   MESSAG3E+60,2,SAVETNEW    8-byte table length\n         B     CHANGK02\nCHANGK01 DS    0H\n         TM    SHBLFLG,X'01'\n         BO    CHANGKA1\n         HEX   MESSAG3E+60,2,TO10LENG    10-byte table length\n         B     CHANGK02\nCHANGKA1 DS    0H\n         HEX   MESSAG3E+60,2,ME10LENG    10-byte table length\nCHANGK02 DS    0H\n         MVI   MESSAG3E+64,C'.'          Finish \"table length\" message.\n         APUT  MESSAG3E,L'MESSAG3E\n*                                        Message after change.\n         MVC   MESSAG1A+6(2),CODEPLAC    Move in table code.\n         HEX   MESSAG1A+57,2,SAVETNEW    New message length\n         MVI   MESSAG1A+61,C'.'          Put period at end.\n         APUT  MESSAG1A,L'MESSAG1A\n         B     CHANGEND\nCHANGEDZ DS    0H                 Zeroing table lengths in the LWA.\n         TM    TIDFLAG,X'03'      Dealing with PC or PP?\n         BNZ   CHANGEDN           Yes. Show nothing was changed.\n         MVC   LINE,LINE-1\n         APUT  LINE,30\n         APUT  MESSAGEC,L'MESSAGEC       Say \"before making changes\"\n         MVC   MESSAG3F+19(2),TABLEID\n         HEX   MESSAG3F+33,2,SAVETNEW\n         MVI   MESSAG3F+37,C'.'\n         APUT  MESSAG3F,L'MESSAG3F\n         MVC   MESSAG1B+6(2),CODEPLAC    Move in table code.\n         APUT  MESSAG1B,L'MESSAG1B\n         B     CHANGEND\nCHANGEND DS    0H\n         L     R9,SAVER9C\n         BR    R9\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nNAMEPARM DS    0H\n         ST    R9,SAVER9D\n         TM    LPADFLG,X'01'          Displaying LPA range?\n         BO    NAMEPEND               Don't look for a number here.\n*-*\n         TM    OFFFLAG,X'08'          Just changing table header?\n         BO    NAMEPEND               Yes. Then don't look for number.\n*-*\n*-*-*\n         TM    OFFFLAG,X'10'          Supply table length in LWA.\n         BO    NAMEPEND               Yes. Then don't look for number.\n*-*-*\n*-*-*-*\n         TM    OFFFLAG,X'20'          Zero table length in LWA.\n         BO    NAMEPEND               Yes. Then don't look for number.\n*-*-*-*\n*-*-*-*-*\n         TM    OFFFLAG,X'40'          Set on STEPLIB flag for table?\n         BO    NAMEPEND               Yes. Then don't look for number.\n*-*-*-*-*\n*-*-*-*-*-*\n         TM    OFFFLAG,X'80'          Set off STEPLIB flag for table?\n         BO    NAMEPEND               Yes. Then don't look for number.\n*-*-*-*-*-*\n         L     R8,SAVER8A             Get number of characters used\n         CR    R8,R5                  More than what's left?\n         BNL   NAMEBAD1               Yes. Error.\n         C     R5,=F'3'               Is end bigger than 3?\n         BNH   NAMEBAD1               No. Error.\nNAMEGOOD DS    0H\n         S     R5,=F'3'               Subtract 3 from number till end.\n         BAL   R9,GETNUMES            Get the number of the pgm entry.\n         TM    OFFFLAG,X'02'          Are we blanking?\n         BO    NAMEPEND               Yes. Don't need a name parameter\n         TM    OFFFLAG,X'04'          Displaying?\n         BO    NAMEPEND               Yes. No names wanted.\n         BAL   R9,GETNAMES            Get the name of pgm to shove in.\n         B     NAMEPEND\nNAMEBAD1 DS    0H                     Get here if there's no parameter.\n         TM    OFFFLAG,X'04'          Are we displaying?\n         BO    NAMEPEND               No error. Just get out normally.\n         TM    OFFFLAG,X'02'\n         BO    NAMEBAD2\n         BAL   R9,MISSPGM1            We're replacing. Ask for both.\n         B     EOJ4                   RC = 4\nNAMEBAD2 DS    0H\n         BAL   R9,MISSPGM3\n         B     EOJ4                   RC = 4\nNAMEPEND DS    0H\n         L     R9,SAVER9D\n         BR    R9\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nADJNEXTP DS    0H                     Get to first blank\n         ST    R9,SAVER9E\n         MVC   CHARSTRT,CHARCONT      Set up\n         L     R1,CHARSTRT\nSEEIFENX DS    0H                     Loop\n         CLI   0(R1),X'40'            First blank?\n         BE    SEEIFENZ               Yes, then end.\n         LA    R1,1(,R1)              Bump to next character\n         ST    R1,CHARSTRT            Store address away\n         B     SEEIFENX               Loop back\nSEEIFENZ DS    0H\n         L     R9,SAVER9E\n         BR    R9\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n         LTORG\n************************************************************\nPGMTITLE DS    0H                     Display program name\n         ST    R9,SAVER9F\n         MVC   LINE,LINE-1            Blank line\n         MVC   LINE,MESSAGET          Move title line in\n         MVC   LINE+56(8),VERS#       Version number into title\n         APUT  LINE,L'MESSAGET        And put out to tube\n         MVC   LINE,LINE-1            Blank line again\n         MVC   LINE,MESSAGEU          Move underlines in\n         APUT  LINE,L'MESSAGEU        And put them out also\n         L     R9,SAVER9F\n         BR    R9                     Return to caller\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nSETTMODE DS    0H                  Routine that does Key 0 stuff.\n         ST    R9,SAVER9G\n         TM    FLAGZ,X'02'         Is parm number past end of table?\n         BO    SETTMEND            Yes. Don't do key zero operations.\n         TM    LPAFLAG,X'01'       Is the table in LPA region?\n         BO    SETTMEND            Yes. Do not attempt to change it.\n* -- >       Test if this command is being run APF Authorized\n         STM   R15,R1,SAVE1401     Now save registers and test if APF\n         XR    R15,R15                  authorized.\n         TESTAUTH FCTN=1           Are we authorized?\n         LTR   R15,R15             Test the return code.\n         BNZ   NOTAUTH             Not zero, tell not authorized.\n         LM    R15,R1,SAVE1401     Restore registers used by TESTAUTH.\n* -- >\n* -- >      Key Zero ---- Here's where we change the stuff.\nKZ       MODESET KEY=ZERO\n* -\n         TM    OFFFLAG,X'04'       Only displaying entr(ies)?\n         BNZ   ENDKZ               Yes. No Key 0 stuff done.\n         CLI   LPAFLAG,X'01'       Did the table come from LPALIB?\n         BE    ENDKZ               Yes. Don't try to alter table.\n         TM    NSCHFLG,X'01'       Are we doing the NS table?\n         BO    TENSLOT             Yes. Handle its special needs.\nEIGHSLOT DS    0H                  8-character tables.\n*-*                                Altering table header only\n         TM    OFFFLAG,X'08'       Alter table header?\n         BZ    GONOHDRA            No. Escape this section.\n         TM    TIDFLAG,X'03'       Dealing with PC or PP?\n         BNZ   GONOHDRA            Yes. Show nothing was changed.\n         L     R3,HDRADDR          Load header address\n         MVC   8(8,R3),=C' PARMLIB'  Move in standard table header.\n         B     ENDKZ               Get out of supervisor state.\nGONOHDRA DS    0H\n*-*\n*-*-*\n         TM    OFFFLAG,X'30'       Supplying length to LWA field?\n         BZ    GONZLWA1            No. Don't do this routine.\n         BAL   R9,MEASUR08         Measure it.\n         BAL   R9,WHERSIZE         Load size into proper place in LWA.\n         B     ENDKZ               Get out of supervisor state.\nGONZLWA1 DS    0H\n*-*-*\n*-*-*-*-*\n         TM    OFFFLAG,X'40'       Set STEPLIB flag in LWA for table?\n         BZ    NOGSTEP1            No. Skip step.\n         BAL   R9,SETSTEPL         Set the STEPLIB flag on.\n         B     ENDKZ               Get out of supervisor state.\nNOGSTEP1 DS    0H\n*-*-*-*-*\n*-*-*-*-*-*\n         TM    OFFFLAG,X'80'       STEPLIB flag off in LWA for table?\n         BZ    NOGSTOF1            No. Skip step.\n         BAL   R9,NOTSTEPL         Set the STEPLIB flag off.\n         B     ENDKZ               Get out of supervisor state.\nNOGSTOF1 DS    0H\n*-*-*-*-*-*\n         L     R3,OURSLOT          Address of slot to replace name in.\n         TM    OFFFLAG,X'01'       Replacing function here?\n         BZ    BLANKIT             No. Do blanking function.\n         CLC   FSTNAME,BLANKS      Yes. Is new entry non-blank?\n         BE    ENDKZ               No. It is blank. Nothing to do.\n         MVC   0(8,R3),FSTNAME     Non-blank. Move in new pgm name.\n         B     ENDKZ               And get out.\nBLANKIT  DS    0H                  Blank an 8-character table entry\n         TM    OFFFLAG,X'02'       Blanking function here?\n         BZ    ENDKZ               No. Can't do anything.\n         L     R3,OURSLOT          Address of slot entry to blank\n         MVC   0(8,R3),BLANKS      Move the blanks in.\n         B     ENDKZ               And get out.\nTENSLOT  DS    0H                  10-character tables.\n         L     R3,OURSLOT          Address of slot to replace name in.\n         TM    OFFFLAG,X'01'       Replacing function here?\n         BZ    BLANKTEN            No. Do blanking function.\n         CLC   FSTNAME,BLANKS      Yes. Is new entry non-blank?\n         BE    ENDKZ               No. It is blank. Nothing to do.\n         MVC   0(2,R3),FSTCHALF    Put length of the new program name.\n         MVC   2(8,R3),FSTNAME     Put in the new program name.\n         B     ENDKZ               Get out of supervisor state.\nBLANKTEN DS    0H                  Blank the 10-character table entry\n*-*                                Altering table header only\n         TM    OFFFLAG,X'08'       Alter table header?\n         BZ    GONOHDRB            No. Escape this section.\n         TM    TIDFLAG,X'03'       Dealing with PC or PP?\n         BNZ   GONOHDRB            Yes. Show nothing was changed.\n         L     R3,HDRADDR          Load header address\n         MVC   8(8,R3),=C' PARMLIB'  Move in standard table header.\n         B     ENDKZ               Get out of supervisor state.\nGONOHDRB DS    0H\n*-*\n*-*-*\n         TM    OFFFLAG,X'30'       Supplying length to LWA field?\n         BZ    GONZLWA2            No. Don't do this routine.\n         BAL   R9,MEASUR10         Measure it.\n         BAL   R9,WHERSIZE         Load size into proper place in LWA.\n         B     ENDKZ               Get out of supervisor state.\nGONZLWA2 DS    0H\n*-*-*\n*-*-*-*-*\n         TM    OFFFLAG,X'40'       Set STEPLIB flag in LWA for table?\n         BZ    NOGSTEP2            No. Skip step.\n         BAL   R9,SETSTEPL         Set the STEPLIB flag.\n         B     ENDKZ               Get out of supervisor state.\nNOGSTEP2 DS    0H\n*-*-*-*-*\n*-*-*-*-*-*\n         TM    OFFFLAG,X'80'       STEPLIB flag off in LWA for table?\n         BZ    NOGSTOF2            No. Skip step.\n         BAL   R9,NOTSTEPL         Set the STEPLIB flag off.\n         B     ENDKZ               Get out of supervisor state.\nNOGSTOF2 DS    0H\n*-*-*-*-*-*\n         TM    OFFFLAG,X'02'       Blanking function here?\n         BZ    ENDKZ               No. Can't do anything.\n         L     R3,OURSLOT          Address of slot entry to blank.\n         MVC   0(2,R3),=X'0000'    Move X'FFFF' to mark table end\n         MVC   2(8,R3),BLANKS      And move the blanks to pgm name slot\n         B     ENDKZ               Get out of supervisor state.\nENDKZ    DS    0H                  Get ready to get out of Key 0.\n* -\nNZ       MODESET KEY=NZERO\n* -- >      Back to ordinary life ----\nSETTMEND DS    0H                  Bypass Key 0 stuff.\n         L     R9,SAVER9G\n         BR    R9                  Return to caller\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nERRORCOD DS    0H                  Give instructions if wrong things\n*                                   were entered, how to do it right.\n         ST    R9,SAVER9H\n         TM    LPADFLG,X'01'\n         BO    ERRORCOE\n         MVC   LINE,LINE-1\n         APUT  LINE,30\n         APUT  MESSA11L,L'MESSA11L\n         APUT  MESSA11M,L'MESSA11M\n         APUT  MESSA11P,L'MESSA11P\n         APUT  MESSA11A,L'MESSA11A\n         MVC   LINE,LINE-1\n         APUT  LINE,30\n         APUT  MESSA11C,L'MESSA11C\n         APUT  MESSA11D,L'MESSA11D\n         APUT  MESSA11Z,L'MESSA11Z\n         APUT  MESSA11Y,L'MESSA11Y\n         APUT  MESSA11X,L'MESSA11X\n         APUT  MESSA11F,L'MESSA11F\n         MVC   LINE,LINE-1\n         APUT  LINE,30\n         APUT  MESSA11I,L'MESSA11I\n         APUT  MESSA11K,L'MESSA11K\n         APUT  MESSA11J,L'MESSA11J\n         APUT  MESSA11N,L'MESSA11N\n         APUT  MESSA11Q,L'MESSA11Q\n         APUT  MESSA11O,L'MESSA11O\n*        MVC   LINE,LINE-1\n*        APUT  LINE,30\nERRORCOE DS    0H\n         L     R9,SAVER9H\n         BR    R9                     Return to caller\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nMISSPGM1 DS    0H                     Supply a slot number & pgm name.\n         ST    R9,SAVER9I\n         MVC   LINE,LINE-1\n         APUT  MESSA11G,L'MESSA11G\n         L     R9,SAVER9I\n         BR    R9                     Return to caller\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nMISSPGM2 DS    0H                     Supply a program name to put in.\n         ST    R9,SAVER9J\n         MVC   LINE,LINE-1\n         APUT  MESSA11E,L'MESSA11E\n         L     R9,SAVER9J\n         BR    R9                     Return to caller\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nMISSPGM3 DS    0H                     Supply a slot number to Blank.\n         ST    R9,SAVER9N\n         MVC   LINE,LINE-1\n         APUT  MESSA12Q,L'MESSA12Q\n         L     R9,SAVER9N\n         BR    R9                     Return to caller\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nDISPTABL DS    0H                Scan thru the particular table....\n         ST    R9,SAVER9L          Save BAL register\n         ST    R3,SAVER3A          Save\n         ST    R4,SAVER4A             the\n         ST    R5,SAVER5A                work\n         ST    R2,SAVER2G                   registers.\n*-*\n         TM    OFFFLAG,X'08'     Just altering table header?\n         BO    DISPTSKP          Yes. Don't display table at all.\n*-*\n*-*-*\n         TM    OFFFLAG,X'10'     Just supplying an LWA size?\n         BO    DISPTSKP          Yes. Don't display table at all.\n*-*-*\n*-*-*-*\n         TM    OFFFLAG,X'20'     Zeroing out LWA size?\n         BO    DISPTSKP          Yes. Don't display table at all.\n*-*-*-*\n*-*-*-*-*\n         TM    OFFFLAG,X'40'     Setting table to come from STEPLIB?\n         BO    DISPTSKP          Yes. Don't display table at all.\n*-*-*-*-*\n*-*-*-*-*-*\n         TM    OFFFLAG,X'80'     Setting table not from STEPLIB?\n         BO    DISPTSKP          Yes. Don't display table at all.\n*-*-*-*-*-*\n         XR    R3,R3               Zero\n         XR    R5,R5                  work\n         XR    R2,R2                     registers.\nDISPTSTR DS    0H\n         L     R3,TABLSTRT         Load start address of table\n         L     R2,TABLENUM         Load number of entries in table\n         L     R5,TABLESIZ         Load size of each entry\n         LA    R4,1                Start slot number count at 1\n         ST    R4,SLOTNOW          Store slot number count away\n         ST    R3,OURSLOT          Initialize slot address.\n         CLC   SLOTBIN,=F'0'       If there's no slot num in parameter\n         BE    DISPTLUP            Then bypass error checking\n         C     R2,SLOTBIN          Compare table size to parm number\n         BNL   DISPTLUP            If parm number is LE, then display\nDISPTERR DS    0H                  Else error message and out.\n         MVC   LINE,LINE-1\n         MVC   LINE(22),=C'Slot number specified '\n         L     R1,SLOTBIN          Display field\n         CVD   R1,CVDAREA          Convert count to printable\n         MVC   LINE+22(10),MASK10  Move in the mask\n         ED    LINE+22(10),CVDAREA+3 Make it pretty\n         MVC   LINE+34(26),=C'is bigger than table size '\n         L     R1,TABLENUM         Display field\n         CVD   R1,CVDAREA          Convert count to printable\n         MVC   LINE+60(10),MASK10  Move in the mask\n         ED    LINE+60(10),CVDAREA+3 Make it pretty\n         APUT  LINE,72\n         B     EOJ4\nDISPTLUP DS    0H                  Loop thru the table entries.\n         MVC   LINE,LINE-1\n         MVC   LINE(2),CODEPLAC    Move in table code.\n         MVC   LINE+3(19),=C'Table Entry Number:'\n         CVD   R4,CVDAREA          Convert count to printable\n         MVC   LINE+22(10),MASK10  Move in the mask\n         ED    LINE+22(10),CVDAREA+3 Make it pretty\n         MVC   TABENNUM(10),MASK10      Preserve printable slot number\n         ED    TABENNUM(10),CVDAREA+3\n         TM    NSCHFLG,X'01'       Is this the 10-byte NS table entry?\n         BO    DISPTBNS            Yes. Handle separately.\n         MVC   LINE+34(8),0(R3)\n         CLC   LINE+34(8),BLANKS   Is this a blank entry.\n         BNE   DISPTBLK            No.\n         MVC   LINE+34(8),=C'*empty* '   Yes. Don't just show blanks.\n         OI    FLAGZ,X'01'         We found a blank table entry.\n         TM    FLAGZ,X'04'         Do we have table lengths?\n         BO    DISPTBLK            Yes, then use the table lengths\n* -------                           that we have.\n*                                  No table lengths here. So....\n         ST    R3,OURSLOT          Preserve empty slot address\n         ST    R4,SLOTNOW          Also preserve this slot number.\n         B     DISPTYES            And then stop on first blank.\nDISPTBNS DS    0H\n         HEX   LINE+34,2,0(R3)     Display size of this entry\n         MVC   LINE+40(8),2(R3)    Move in program name to slot\n         CLC   LINE+40(8),BLANKS   Is this a blank entry.\n         BNE   DISPTBLK            No.\n         MVC   LINE+40(8),=C'*empty* '   Yes. Don't just show blanks.\n         OI    FLAGZ,X'01'         We found a blank table entry.\n         TM    FLAGZ,X'04'         Do we have table lengths?\n         BO    DISPTBLK            Yes, then use the table lengths\n* -------                           that we have.\n*                                  No table lengths here. So....\n         ST    R3,OURSLOT          Preserve empty slot address\n         ST    R4,SLOTNOW          Also preserve this slot number.\n         B     DISPTYES            And then stop on first blank.\nDISPTBLK DS    0H                  Search each slot number.\n         CLC   SLOTBIN,=F'0'       Has a slot number been specified?\n         BE    DISPTYES            No. Just display all the slots.\n         CLC   SLOTBIN,SLOTNOW     Yes. Then are we at the one we want?\n         BNE   DISPTNOT            No. Just go further and search.\n         OI    FLAGZ,X'08'         We're at the desired slot.\n* ---  Save contents of the current slot which was found - below\n         ST    R3,OURSLOT          Preserve this slot's address\n         LR    R1,R5               Load table entry size\n         BCTR  R1,0                One less for execute\n         EX    R1,MOVESLOT         Save contents of slot for kicks\n         B     DISPTPEX               Branch past executed instruction\nMOVESLOT MVC   SLOTSAVE(*-*),0(R3)    EXECUTED\nDISPTPEX DS    0H\n* ---  Save contents of the current slot which was found - above\nDISPTYES DS    0H                  Print this slot entry\n         APUT  LINE,52\n         TM    FLAGZ,X'01'         Is this a blank table entry?\n         BO    DISPTEND            Yes, end the table search.\n         TM    FLAGZ,X'08'         Are we at the slot # we specified?\n         BO    DISPTEND            Yes. Stop the search.\nDISPTNOT DS    0H                  Bump to next slot and loop back.\n         C     R3,TABLEND          Compare to end from adding bytes.\n         BH    DISPTEND            Past it, then end the search.\n         LA    R3,0(R5,R3)         Bump to next slot\n         ST    R3,OURSLOT          Store its address - important....\n         LA    R4,1(,R4)           Bump count of slot number\n         ST    R4,SLOTNOW          Store new slot number away\n         ST    R2,SAVER2E\n         BCT   R2,DISPTLUP         And loop to examine the new slot.\n*\nDISPTEND DS    0H                  END OF TABLE SEARCH ROUTINE\n* - >                              Display message if desired slot is\n* - >                               past the end of the table.\n         CLC   SLOTBIN,SLOTNOW     Is the parm number past the end?\n         BNH   DISPTNOP            No. Don't report a problem.\n         L     R1,SLOTBIN          Display field\n         CVD   R1,CVDAREA          Convert count to printable\n         MVC   LINE+22(10),MASK10  Move in the mask\n         ED    LINE+22(10),CVDAREA+3 Make it pretty\n         MVC   LINE+34(26),=C'exceeds scanned table size'\n         L     R1,SLOTNOW          Display field\n         CVD   R1,CVDAREA          Convert count to printable\n         MVC   LINE+60(10),MASK10  Move in the mask\n         ED    LINE+60(10),CVDAREA+3 Make it pretty\n         APUT  LINE,72\n         OI    FLAGZ,X'02'         Flag a problem situation.\nDISPTNOP DS    0H\nDISPTSKP DS    0H\n* - >\n         L     R3,SAVER3A          Restore all the work registers.\n         L     R4,SAVER4A\n         L     R5,SAVER5A\n         L     R2,SAVER2G\n         L     R9,SAVER9L          Restore the BAL register.\n         BR    R9                  Return to caller\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nGETNUMES DS    0H                  Get the number after the table code\n         ST    R9,SAVER9M           + the action code. If it exists.\n         ST    R2,SAVER2F\nGETNUMST DS    0H                  Get rid of leading blanks\n         L     R1,CHARCONT         Point to start of character\n         CLI   0(R1),X'40'         Is it a blank?\n         BNE   GETNUMNZ            No. Get the entire name.\n         LA    R1,1(,R1)           Yes. Bump start place one up.\n         ST    R1,CHARCONT         And store the place away for now.\n         C     R5,=F'1'            End of cmd buffer one away?\n         BNH   EOJ4                Yes. Error.\n         S     R5,=F'1'            Subtract one from end count\n         B     GETNUMST            And loop to find first non-blank.\nGETNUMNZ DS    0H                  Got first non-blank. Get whole name.\n         LA    R2,5                BCT initial quantity - 5 chars.\n         LA    R8,0                Character count\n         L     R1,CHARCONT         Load starting place\n         LR    R4,R1               Initialize pointer\n         LA    R4,0(,R4)           to first character of program number\nGETNUMLU DS    0H                  Loop to get entire number\n         CLI   0(R4),X'40'         First blank?\n         BE    GETNUMGT            Yes, got whole number\n         CLI   0(R4),X'00'         First hex zeros?\n         BE    GETNUMGT            Yes, got whole number\n         CR    R8,R5               End of command buffer?\n         BNL   GETNUMGT            Yes. Got all we can get.\n* --                               Test EBCDIC number if numeric.\n         CLI   0(R4),X'F0'         Check character if numeric digit.\n         BL    NOTNUMER            Less than X'F0', not a number.\n         CLI   0(R4),X'F9'         More than X'F9'?\n         BH    NOTNUMER            Not a number.\n* --\n         LA    R8,1(,R8)           Bump character counter.\n         LA    R4,1(,R4)           Bump where we are.\n         BCT   R2,GETNUMLU         Loop back.\nGETNUMGT DS    0H                  Got the whole number - examine it.\n         ST    R8,SAVER8A\n         ST    R8,FSTNOUNT         Get halfword value of slot number\n         MVC   FSTNHALF(2),FSTNOUNT+2\n         L     R3,CHARCONT\n         BCTR  R8,0                One less for EXECUTE\n         MVC   FSTFIELD(8),BLANKS  5-char number plus 3 blanks\n         EX    R8,MOVFNUM          Get the number from the parm\n         EX    R8,PACK             Convert it to packed\n         CVB   R0,WORKA            Convert it to Binary\n         ST    R0,SLOTBIN          Store the value for later use\n         MVC   LINE,LINE-1\n         MVC   LINE(8),FSTFIELD    8-char number with blanks\n         MVC   LINE+13(19),=C'Entry slot number  '\n         APUT  LINE,32\n         LA    R8,1(,R8)           Restore number of chars after EX\n         ST    R8,CHARSIZE         Save this value off.\n         AR    R3,R8               Add it to R3 so we start past it.\n         ST    R3,CHARCONT         Store start value for next parm.\nGETNUMEN DS    0H\n         L     R2,SAVER2F\n         L     R9,SAVER9M\n         BR    R9\n* ----------------------------------------------------------------- *\n*      Measure \"8-byte entry\" loaded table.                         *\n* ----------------------------------------------------------------- *\n*      R5 contains the entry point of the table.                    *\n* ----------------------------------------------------------------- *\nMEASUR08 DS    0H                 R5 has beginning address of table.\n         ST    R9,SAVER9O           Save BAL register\n         ST    R5,SAVER5D           Save work register\n         ST    R4,SAVER4B           Save work register\n         L     R5,TABLADDR          Load start of table\n         XC    BLNKCNT,BLNKCNT      Zero the counters\n         XC    NTRYCNT,NTRYCNT\n         LA    R4,16                Count size of header\n         LA    R5,16(,R5)           Bump past header\nME08LOOP DS    0H\n*     Try (real hard) to detect the end of the table  -  below\n         MVC   SAVECHAR(1),0(R5)    Save first character\n         CLC   =C'        ',0(R5)   Is this table entry a blank?\n         BE    ME08BLNK             Yes. Reached virtual end of table\n         CLC   ZEROES8(8),0(R5)     Is this \"entry\" hex zeros?\n         BE    ME08NOBL             Yes. Reached possible junk storage\n         CLC   =C' ',0(R5)          Is first character blank?\n         BE    ME08NOBL             Yes, not a valid table entry.\n         TR    SAVECHAR,TRTPGMNM    Check first char if appropriate.\n         CLI   SAVECHAR,X'02'       Not. probably end of table.\n         BE    ME08NOBL\n         CLC   =C'IKJEFTE2',0(R5)\n         BE    ME08NOBL\n         CLC   =C'IKJEFTE8',0(R5)\n         BE    ME08NOBL\n         CLC   =C'IKJEFTAP',0(R5)\n         BE    ME08NOBL\n         CLC   =C'IKJEFTNS',0(R5)\n         BE    ME08NOBL\n*     Try (real hard) to detect the end of the table  -  above\n         LA    R4,8(,R4)            Count next table entry\n         LA    R5,8(,R5)            Bump to next entry\n         L     R1,NTRYCNT           Increment \"entry count\" counter\n         A     R1,=F'1'\n         ST    R1,NTRYCNT\n         B     ME08LOOP             Loop back till perceived table end\nME08BLNK DS    0H\n         LA    R4,8(,R4)            Add length of blank entry\n         LA    R5,8(,R5)            Bump past blank entry.\n         L     R1,BLNKCNT           Increment \"blank entry\" counter\n         A     R1,=F'1'\n         ST    R1,BLNKCNT\nME08NOBL DS    0H\n         STH   R4,ME08LENG          Store measured length of table.\n         ST    R5,ME08END           And record address of table end.\n         BAL   R9,MESBLK08          Measure more blanks after table.\n         TM    MEASFLG,X'01'        Been here already?\n         BO    ME08NOSH             Don't show count again.\n         BAL   R9,ENTRYDSP          Show number of entries.\nME08NOSH DS    0H\n         OI    MEASFLG,X'01'        Show we did this once.\n         L     R4,SAVER4B           Restore work register\n         L     R5,SAVER5D           Restore work register\n         L     R9,SAVER9O           Restore BAL register\n         BR    R9\nME08END  DS    F                    Store end-of-table address\nME08LENG DS    H                    Store table length\nBL08LENG DS    H                    Store length of blanks\nTO08LENG DS    H                    Store total, nonblank+blank\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nMESBLK08 DS    0H                   See how many more blanks we have.\n         ST    R9,SAVER9Y           Save BAL register\n         ST    R5,SAVER5E           Save work register\n         L     R5,ME08END           Start at measured end of table.\nMESBLL08 DS    0H                   Loop\n         CLC   =C'        ',0(R5)   Is this entry a blank?\n         BNE   MESBLE08             Yes. Stop counting blanks.\n         CLC   BLNKCNT,MAXBLANK     Have we exceeded the maximum guess?\n         BH    MESBLE08             Yes. Don't find more blanks.\n         L     R1,BLNKCNT           Increment \"blank entry\" counter\n         A     R1,=F'1'\n         ST    R1,BLNKCNT\n         LA    R5,8(,R5)            Bump to next entry.\n         B     MESBLL08             Loop until no blanks or max.\nMESBLE08 DS    0H\n         L     R1,BLNKCNT           Total count of found blanks\n         LTR   R1,R1\n         BZ    MESBLX08\n         BCTR  R1,0                 Really one less\nMESBLX08 DS    0H\n         SLL   R1,3                 Multiply by 8\n         STH   R1,BL08LENG          Length of blank entries\n         AH    R1,ME08LENG          Add length of non-blank entries\n         STH   R1,TO08LENG          Total length of both\n*>*----\n*        STM   R14,R1,SAVE1401      Save registers 14 thru 1.\n*        MVC   LINE,LINE-1\n*        HEX   LINE,2,ME08LENG\n*        HEX   LINE+10,2,BL08LENG\n*        HEX   LINE+20,2,TO08LENG\n*        APUT  LINE,30\n*        LM    R14,R1,SAVE1401      Load registers 14 thru 1.\n*>*----\n         L     R5,SAVER5E           Restore work register\n         L     R9,SAVER9Y           Restore BAL register\n         BR    R9\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n* ----------------------------------------------------------------- *\n*      Measure \"10-byte entry\" loaded table.                        *\n* ----------------------------------------------------------------- *\n*      R5 contains the entry point of the table.                    *\n* ----------------------------------------------------------------- *\nMEASUR10 DS    0H                 R5 has beginning address of table.\n         ST    R9,SAVER9P           Save BAL register\n         ST    R5,SAVER5D           Save work register\n         ST    R4,SAVER4B           Save work register\n         L     R5,TABLADDR          Load start of table\n         XC    BLNKCNT,BLNKCNT      Zero the counters\n         XC    NTRYCNT,NTRYCNT\n         LA    R4,16                Count size of header\n         LA    R5,16(,R5)           Bump past header\nME10LOOP DS    0H\n         MVC   SAVECHAR(1),2(R5)    Save first character of pgm name\n         MVC   SAVECH08(1),9(R5)    Save last character of pgm name\n         CLC   BLKSTRNG(10),0(R5)   Full blank entry here?\n         BE    ME10BLNK             Yes. Count the blank entry.\n         CLC   ENDSTRNG(10),0(R5)   FFFF plus blank pgm name?\n         BE    ME10BLNK             Yes. Can still be considered blank.\n         CLC   =X'0000',0(R5)       Test-test-test-test-test\n         BE    ME10TEST             Test rest of \"entry\n         B     ME10REST             Not zeros, go on.\nME10TEST DS    0H\n         TR    SAVECHAR,TRTPGMNM    Check for strange character.\n         CLI   SAVECHAR,X'02'       Is it strange?\n         BE    ME10NOBL             Yes. This is not a blank entry.\nME10REST DS    0H\n         CLC   =X'FFFF',0(R5)       Test for end string separately.\n         BNE   ME10TES2             Not. Not at virtual end of table\n         B     ME10NOBL             FFFF alone. Not a blank entry.\nME10TES2 DS    0H\n         TR    SAVECHAR,TRTPGMNM    Check first char not upcase alpha.\n         CLI   SAVECHAR,X'02'       Not. probably end of table.\n         BE    ME10NOBL\n         TR    SAVECH08,TRTPGMNM    Check last char not upcase alpha.\n         CLI   SAVECH08,X'02'       Not. probably end of table.\n         BE    ME10NOBL\n         LA    R4,10(,R4)           Count next table entry\n         LA    R5,10(,R5)           Bump to next entry\n         L     R1,NTRYCNT           Increment \"entry count\" counter\n         A     R1,=F'1'\n         ST    R1,NTRYCNT\n         B     ME10LOOP             Finished this entry, try for more.\nME10BLNK DS    0H\n         LA    R4,10(,R4)           Add length of blank entry\n         LA    R5,10(,R5)           Bump past blank entry.\n         L     R1,BLNKCNT           Increment \"blank entry\" counter\n         A     R1,=F'1'\n         ST    R1,BLNKCNT\nME10NOBL DS    0H\n         STH   R4,ME10LENG          Store measured length of table.\n         ST    R5,ME10END           And record address of table end.\n         BAL   R9,MESBLK10          Measure more blanks after table.\n         TM    MEASFLG,X'01'        Been here already?\n         BO    ME10NOSH             Don't show count again.\n         BAL   R9,ENTRYDSP          Show number of entries.\nME10NOSH DS    0H\n         OI    MEASFLG,X'01'        Show we did this once.\n         L     R4,SAVER4B           Restore work register\n         L     R5,SAVER5D           Restore work register\n         L     R9,SAVER9P           Restore BAL register\n         BR    R9\nME10END  DS    F                    Store end-of-table address\nME10LENG DS    H                    Store table length\nBL10LENG DS    H                    Store length of blanks\nTO10LENG DS    H                    Store total, nonblank+blank\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nMESBLK10 DS    0H                   See how many more blanks we have.\n         ST    R9,SAVER9Y           Save BAL register\n         ST    R5,SAVER5E           Save work register\n         L     R5,ME10END           Start at measured end of table.\nMESBLL10 DS    0H                   Loop\n         CLC   =C'        ',2(R5)   Is this entry a blank entry?\n         BNE   MESBLE10             No. End of perceived blanks.\n         CLC   =X'0000',0(R5)       Length is zero?\n         BNE   MESBLE10             No. End of perceived blanks.\n         CLC   =X'FFFF',0(R5)       Real table end?\n         BE    MESBLE10             Yes. Consider it end of table.\n         CLC   BLNKCNT,MAXBLANK     Have we exceeded the maximum guess?\n         BH    MESBLE10             Yes. Don't find more blanks.\n         L     R1,BLNKCNT           Increment \"blank entry\" counter\n         A     R1,=F'1'\n         ST    R1,BLNKCNT\n         LA    R5,10(,R5)           Bump to next entry.\n         B     MESBLL10             Loop until no blanks or max.\nMESBLE10 DS    0H\n         L     R1,BLNKCNT           Number of blank entries\n         LTR   R1,R1\n         BZ    MESBLX10\n         BCTR  R1,0                 Really one less\nMESBLX10 DS    0H\n         STM   R2,R3,SAVER23        Save work registers\n         XR    R2,R2                Clear R2\n         XR    R3,R3                Clear R3\n         LR    R3,R1                Dump count into R2 for mult.\n         M     R2,=F'10'            Multiply by entry size\n         STH   R3,BL10LENG          Store length of blank entries\n         AH    R3,ME10LENG          Add length of non-blank entries\n         STH   R3,TO10LENG          Total length of both\n         LM    R2,R3,SAVER23        Restore work registers\n*>*----\n*        STM   R14,R1,SAVE1401      Save registers 14 thru 1.\n*        MVC   LINE,LINE-1\n*        HEX   LINE,2,ME10LENG\n*        HEX   LINE+10,2,BL10LENG\n*        HEX   LINE+20,2,TO10LENG\n*        HEX   LINE+30,4,BLNKCNT\n*        APUT  LINE,50\n*        LM    R14,R1,SAVE1401      Load registers 14 thru 1.\n*>*----\n         L     R5,SAVER5E           Restore work register\n         L     R9,SAVER9Y           Restore BAL register\n         BR    R9\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n* ------------------------------------------------------------------ *\nWHERSIZE DS    0H                   Point to size field to update.\n* ------------------------------------------------------------------ *\n*    This is executed after MEASUR08 or MEASUR10.                    *\n*    The idea here is to update the appropriate length field for     *\n*      the appropriate table, after having measured the size.        *\n*    This routine is also used for zeroing the table lengths.        *\n*    This routine is executed in supervisor state. Called from       *\n*      the SETTMODE routine.                                         *\n* ------------------------------------------------------------------ *\n*   ***  Note:  We unconditionally update the table lengths.  ***    *\n* ------------------------------------------------------------------ *\n         ST    R9,SAVER9Q           Save BAL register\n         ST    R2,SAVER2B           Save work registers\n         ST    R3,SAVER3C\n         TM    OFFFLAG,X'30'        Are we updating or zeroing lengths?\n         BZ    WHEREXIT             No. We have no business here.\n         L     R2,LWAADDR           Point to the Logon Work Area.\n         USING LWA,R2               Address its fields.\n*-----------------------------*\nWHERCHUZ DS    0H                   Which table are we dealing with?\n*-----------------------------*\n         TM    TIDFLAG,X'20'           E2?\n         BO    WHERE2\n         TM    TIDFLAG,X'10'           E8?\n         BO    WHERE8\n         TM    TIDFLAG,X'80'           AP?\n         BO    WHERAP\n         TM    TIDFLAG,X'40'           NS?\n         BO    WHERNS\n         B     WHEREXIT\n*-----------------------------*\nWHERE2   DS    0H                      Update E2 length\n         TM    SHBLFLG,X'01'\n         BO    WHERE2SH\n         MVC   LWATE2LN(2),TO08LENG    Move length to LWA\n         MVC   SAVETNEW(2),TO08LENG    Save length for message\n         B     WHERE2E\nWHERE2SH DS    0H\n         MVC   LWATE2LN(2),ME08LENG    Move length to LWA\n         MVC   SAVETNEW(2),ME08LENG    Save length for message\nWHERE2E  DS    0H\n*-*-*-*\nWHERE2Z  DS    0H                      If zeroing, then zero E2 length\n         TM    OFFFLAG,X'20'           Zeroing length?\n         BZ    WHE2NOZ1                No. Bypass this.\n         MVC   LWATE2LN(2),=X'0000'    Move length to LWA\n         MVC   SAVETNEW(2),=X'0000'    Save length for message\nWHE2NOZ1 DS    0H\n*-*-*-*\n         B     WHEREXIT                Finished, get out of routine.\n*-----------------------------*\nWHERE8   DS    0H                      Update E8 length\n         TM    SHBLFLG,X'01'\n         BO    WHERE8SH\n         MVC   LWATE8LN(2),TO08LENG    Move length to LWA\n         MVC   SAVETNEW(2),TO08LENG    Save length for message\n         B     WHERE8E\nWHERE8SH DS    0H\n         MVC   LWATE8LN(2),ME08LENG    Move length to LWA\n         MVC   SAVETNEW(2),ME08LENG    Save length for message\nWHERE8E  DS    0H\n*-*-*-*\nWHERE8Z  DS    0H                      If zeroing, then zero E8 length\n         TM    OFFFLAG,X'20'           Zeroing length?\n         BZ    WHE8NOZ1                No. Bypass this.\n         MVC   LWATE8LN(2),=X'0000'    Move length to LWA\n         MVC   SAVETNEW(2),=X'0000'    Save length for message\nWHE8NOZ1 DS    0H\n*-*-*-*\n         B     WHEREXIT                Finished, get out of routine.\n*-----------------------------*\nWHERAP   DS    0H                      Update AP length\n         TM    SHBLFLG,X'01'\n         BO    WHERAPSH\n         MVC   LWATAPLN(2),TO08LENG    Move length to LWA\n         MVC   SAVETNEW(2),TO08LENG    Save length for message\n         B     WHERAPE\nWHERAPSH DS    0H\n         MVC   LWATAPLN(2),ME08LENG    Move length to LWA\n         MVC   SAVETNEW(2),ME08LENG    Save length for message\nWHERAPE  DS    0H\n*-*-*-*\nWHERAPZ  DS    0H                      If zeroing, then zero AP length\n         TM    OFFFLAG,X'20'           Zeroing length?\n         BZ    WHAPNOZ1                No. Bypass this.\n         MVC   LWATAPLN(2),=X'0000'    Move length to LWA\n         MVC   SAVETNEW(2),=X'0000'    Save length for message\nWHAPNOZ1 DS    0H\n*-*-*-*\n         B     WHEREXIT                Finished, get out of routine.\n*-----------------------------*\nWHERNS   DS    0H                      Update NS length\n         TM    SHBLFLG,X'01'\n         BO    WHERNSSH\n         MVC   LWATNSLN(2),TO10LENG    Move length to LWA\n         MVC   SAVETNEW(2),TO10LENG    Save length for message\n         B     WHERNSE\nWHERNSSH DS    0H\n         MVC   LWATNSLN(2),ME10LENG    Move length to LWA\n         MVC   SAVETNEW(2),ME10LENG    Save length for message\nWHERNSE  DS    0H\n*-*-*-*\nWHERNSZ  DS    0H                      If zeroing, then zero NS length\n         TM    OFFFLAG,X'20'           Zeroing length?\n         BZ    WHNSNOZ1                No. Bypass this.\n         MVC   LWATNSLN(2),=X'0000'    Move length to LWA\n         MVC   SAVETNEW(2),=X'0000'    Save length for message\nWHNSNOZ1 DS    0H\n*-*-*-*\n         B     WHEREXIT                Finished, get out of routine.\n*-----------------------------*\nWHEREXIT DS    0H\n         L     R2,SAVER2B              Restore work registers\n         L     R3,SAVER3C\n         L     R9,SAVER9Q\n         BR    R9\n         DROP  R2\nTABLEID  DC    CL2' '\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nSETSTEPL DS    0H                     Routine to turn on STEPLIB flags\n         ST    R9,SAVER9R\n         ST    R2,SAVER2C                Save work register\n         L     R2,LWAADDR\n         USING LWA,R2\nSETSWTBL DS    0H                     Check which table we're seeing\n         TM    TIDFLAG,X'03'          PC OR PP table?\n         BNZ   SETSTEPN               Say nothing changed.\n         TM    TIDFLAG,X'20'          E2?\n         BO    SETSDOE2\n         TM    TIDFLAG,X'10'          E8?\n         BO    SETSDOE8\n         TM    TIDFLAG,X'80'          AP?\n         BO    SETSDOAP\n         TM    TIDFLAG,X'40'          NS?\n         BO    SETSDONS\nSETSDOE2 DS    0H\n         OI    LWAPRMLB,LWATE2ST         STEPLIB flag on for E2\n         B     SETSWTBE\nSETSDOE8 DS    0H\n         OI    LWAPRMLB,LWATE8ST         STEPLIB flag on for E8\n         B     SETSWTBE\nSETSDOAP DS    0H\n         OI    LWAPRMLB,LWATAPST         STEPLIB flag on for AP\n         B     SETSWTBE\nSETSDONS DS    0H\n         OI    LWAPRMLB,LWATNSST         STEPLIB flag on for NS\n         B     SETSWTBE\nSETSWTBE DS    0H                        Print informative message\n         MVC   LINE,LINE-1\n         APUT  LINE,30\n         APUT  MESSAGEC,L'MESSAGEC    Say \"before making changes\"\n         MVC   LINE,LINE-1\n         MVC   LINE(71),=C'Table    marked from STEPLIB so PARMLIB UPDA-\n               TE(xx) will not overlay it.'\n         MVC   LINE+6(2),TABLEID\n         APUT  LINE,71\n         B     SETSTEPE\nSETSTEPN DS    0H\n         STM   R14,R1,SAVE1401    Save registers 14 thru 1.\n         APUT  MESSAG2D,L'MESSAG2D   Say nothing changed.\n         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.\n         B     SETSTEPE\nSETSTEPE DS    0H\n         L     R2,SAVER2C             Restore work register\n         L     R9,SAVER9R\n         DROP  R2\n         BR    R9\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nNOTSTEPL DS    0H                    Routine to turn off STEPLIB flags\n         ST    R9,SAVER9K\n         ST    R2,SAVER2C             Save work register\n         L     R2,LWAADDR\n         USING LWA,R2\nNOTSWTBL DS    0H                     Check which table we're seeing\n         TM    TIDFLAG,X'03'          PC OR PP table?\n         BNZ   NOTSTEPN               Say nothing changed.\n         TM    TIDFLAG,X'20'          E2?\n         BO    NOTSDOE2\n         TM    TIDFLAG,X'10'          E8?\n         BO    NOTSDOE8\n         TM    TIDFLAG,X'80'          AP?\n         BO    NOTSDOAP\n         TM    TIDFLAG,X'40'          NS?\n         BO    NOTSDONS\nNOTSDOE2 DS    0H\n         NI    LWAPRMLB,X'FF'-LWATE2ST   STEPLIB flag off for E2\n         B     NOTSWTBE\nNOTSDOE8 DS    0H\n         NI    LWAPRMLB,X'FF'-LWATE8ST   STEPLIB flag off for E8\n         B     NOTSWTBE\nNOTSDOAP DS    0H\n         NI    LWAPRMLB,X'FF'-LWATAPST   STEPLIB flag off for AP\n         B     NOTSWTBE\nNOTSDONS DS    0H\n         NI    LWAPRMLB,X'FF'-LWATNSST   STEPLIB flag off for NS\n         B     NOTSWTBE\nNOTSWTBE DS    0H                     Print informative message.\n         MVC   LINE,LINE-1            Print a blank first.\n         APUT  LINE,30\n         APUT  MESSAGEC,L'MESSAGEC    Say \"before making changes\".\n         MVC   LINE,LINE-1\n         MVC   LINE(71),=C'Table    marked from not from STEPLIB. PARML-\n               IB UPDATE(xx) can overlay. '\n         MVC   LINE+6(2),TABLEID      Move table name into message.\n         APUT  LINE,71\n         B     NOTSTEPE\nNOTSTEPN DS    0H\n         STM   R14,R1,SAVE1401    Save registers 14 thru 1.\n         APUT  MESSAG2D,L'MESSAG2D   Say nothing changed.\n         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.\n         B     NOTSTEPE\nNOTSTEPE DS    0H\n         L     R2,SAVER2C             Restore work register\n         L     R9,SAVER9K\n         BR    R9\n         DROP  R2\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nGETLPABD DS    0H                  Get storage boundary values for LPA\n         ST    R9,SAVER9S\nGETLSTRT DS    0H\n         ST    R5,SAVER5C          Prepare a bunch of work registers\n         ST    R4,SAVER4C          Prepare a bunch of work registers\n         L     R5,X'10'            Point to CVT.\n         USING CVT,R5              Tell Assembler.\n         L     R4,CVTSMEXT         Point to CVT Extension.\n         USING CVTVSTGX,R4         Tell Assembler.\n         MVC   SAVMLPAS,CVTMLPAS   MLPA start\n         MVC   SAVMLPAE,CVTMLPAE   MLPA end\n         MVC   SAVFLPAS,CVTFLPAS   FLPA start\n         MVC   SAVFLPAE,CVTFLPAE   FLPA end\n         MVC   SAVPLPAS,CVTPLPAS   PLPA start\n         MVC   SAVPLPAE,CVTPLPAE   PLPA end\n         MVC   SAVEMLPS,CVTEMLPS   E-MLPA start\n         MVC   SAVEMLPE,CVTEMLPE   E-MLPA end\n         MVC   SAVEFLPS,CVTEFLPS   E-FLPA start\n         MVC   SAVEFLPE,CVTEFLPE   E-FLPA end\n         MVC   SAVEPLPS,CVTEPLPS   E-PLPA start\n         MVC   SAVEPLPE,CVTEPLPE   E-PLPA end\n         L     R5,SAVER5C          Restore the work registers\n         L     R4,SAVER4C          Restore the work registers\n         L     R9,SAVER9S\n         DROP  R5,R4\n         BR    R9                  Return\n*                                  Constants needed here.\nSAVMLPAS DC    A(0)\nSAVMLPAE DC    A(0)\nSAVFLPAS DC    A(0)\nSAVFLPAE DC    A(0)\nSAVPLPAS DC    A(0)\nSAVPLPAE DC    A(0)\nSAVEMLPS DC    A(0)\nSAVEMLPE DC    A(0)\nSAVEFLPS DC    A(0)\nSAVEFLPE DC    A(0)\nSAVEPLPS DC    A(0)\nSAVEPLPE DC    A(0)\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nGETLPRNT DS    0H         Routine to Print LPA Range - action code X\n         ST    R9,SAVER9T\n         TM    LPADFLG,X'01'         Code wasn't X. Don't print.\n         BZ    GETLPRTE              Just restore R9 and go on.\n         MVC   LINE,LINE-1\n         MVC   LINE(28),DASHES28\n         APUT  LINE,35\n         MVC   LINE,LINE-1\n         MVC   LINE(28),=C' --- LPA RANGE DISPLAY ---  '\n         APUT  LINE,35\n         MVC   LINE,LINE-1\n         MVC   LINE(28),DASHES28\n         APUT  LINE,35\n         MVC   LINE,LINE-1\n         MVC   LINE(4),=C'MLPA'\n         HEX   LINE+10,4,SAVMLPAS    MLPA range\n         HEX   LINE+20,4,SAVMLPAE\n         APUT  LINE,35\n         MVC   LINE,LINE-1\n         MVC   LINE(4),=C'FLPA'\n         HEX   LINE+10,4,SAVFLPAS    FLPA range\n         HEX   LINE+20,4,SAVFLPAE\n         APUT  LINE,35\n         MVC   LINE,LINE-1\n         MVC   LINE(4),=C'PLPA'      PLPA range\n         HEX   LINE+10,4,SAVPLPAS\n         HEX   LINE+20,4,SAVPLPAE\n         APUT  LINE,35\n         MVC   LINE,LINE-1\n         MVC   LINE(6),=C'E-MLPA'    E-MLPA range\n         HEX   LINE+10,4,SAVEMLPS\n         HEX   LINE+20,4,SAVEMLPE\n         APUT  LINE,35\n         MVC   LINE,LINE-1\n         MVC   LINE(6),=C'E-FLPA'    E-FLPA range\n         HEX   LINE+10,4,SAVEFLPS\n         HEX   LINE+20,4,SAVEFLPE\n         APUT  LINE,35\n         MVC   LINE,LINE-1\n         MVC   LINE(6),=C'E-PLPA'    E-PLPA range\n         HEX   LINE+10,4,SAVEPLPS\n         HEX   LINE+20,4,SAVEPLPE\n         APUT  LINE,35\n         MVC   LINE,LINE-1\n         MVC   LINE(28),DASHES28     Print row of dashes at the bottom\n         APUT  LINE,35\nGETLPRTE DS    0H\n         L     R9,SAVER9T\n         BR    R9\nDASHES28 DC    28C'-'\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nPRTABLHD DS    0H\n         ST    R9,SAVER9U\n*                                 Print out table header\n         STM   R14,R1,SAVE1401    Now save registers 14 thru 1.\n         L     R1,TABLADDR        Load table start address.\n         MVC   DISPHDR(16),0(R1)  Move header info to display area.\n         ST    R1,HDRADDR         Store header address for alter\n         MVC   LINE,LINE-1        Clear line\n         MVC   LINE(15),=C'Table Header:  '  Move in title.\n         MVC   LINE+15(16),DISPHDR           Move in title info.\n         APUT  LINE,35\n         MVC   LINE,LINE-1        Clear line for next time\n         LM    R14,R1,SAVE1401    Restore  registers 14 thru 1.\n*-*\n         L     R9,SAVER9U\n         BR    R9\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n** ---------------------------------------------------------------- **\n**   When this routine is invoked, TABLADDR points to the start     **\n**    of the real table.                                            **\n** ---------------------------------------------------------------- **\nTESTLPA  DS    0H             Test if an address is in any LPA range\n         ST    R9,SAVER9W\n*-*-*->>                          Print the address out so we can see.\n         STM   R14,R1,SAVE1401    Save registers 14 thru 1.\n         MVC   LINE,LINE-1        Clear line area.\n         MVC   LINE(16),=C'Table address:  '\n         HEX   LINE+20,4,TABLADDR     Display address in Hex\n         APUT  LINE,35\n         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.\n*-*-*->>\nTESLSTRT DS    0H\n         CLC   TABLADDR,SAVMLPAS      Smaller than MLPA start?\n         BL    TESLTST1\n         CLC   TABLADDR,SAVMLPAE      Larger than MLPA end?\n         BH    TESLTST1\n         OI    LPAFLAG,X'01'          In between, flag it and exit.\n         B     TESLMSG\nTESLTST1 DS    0H\n         CLC   TABLADDR,SAVFLPAS      Smaller than FLPA start?\n         BL    TESLTST2\n         CLC   TABLADDR,SAVFLPAE      Larger than FLPA end?\n         BH    TESLTST2\n         OI    LPAFLAG,X'01'          In between, flag it and exit.\n         B     TESLMSG\nTESLTST2 DS    0H\n         CLC   TABLADDR,SAVPLPAS      Smaller than PLPA start?\n         BL    TESLTST3\n         CLC   TABLADDR,SAVPLPAE      Larger than PLPA end?\n         BH    TESLTST3\n         OI    LPAFLAG,X'01'\n         B     TESLMSG                In between, flag it and exit.\nTESLTST3 DS    0H\n         CLC   TABLADDR,SAVEMLPS      Smaller than E-MLPA start?\n         BL    TESLTST4\n         CLC   TABLADDR,SAVEMLPE      Larger than E-MLPA end?\n         BH    TESLTST4\n         OI    LPAFLAG,X'01'          In between, flag it and exit.\n         B     TESLMSG\nTESLTST4 DS    0H\n         CLC   TABLADDR,SAVEFLPS      Smaller than E-FLPA start?\n         BL    TESLTST5\n         CLC   TABLADDR,SAVEFLPE      Larger than E-FLPA end?\n         BH    TESLTST5\n         OI    LPAFLAG,X'01'          In between, flag it and exit.\n         B     TESLMSG\nTESLTST5 DS    0H\n         CLC   TABLADDR,SAVEPLPS      Smaller than E-PLPA start?\n         BL    TESLMSG\n         CLC   TABLADDR,SAVEPLPE      Larger than E-PLPA end?\n         BH    TESLMSG\n         OI    LPAFLAG,X'01'          In between, flag it and exit.\n         B     TESLMSG\nTESLMSG  DS    0H\n*-*-*->>                          Message the result of the LPA test.\n         STM   R14,R1,SAVE1401    Save registers 14 thru 1.\n         MVC   LINE,LINE-1        Clear line area.\n         TM    LPAFLAG,X'01'      Is the address within LPA?\n         BZ    TESLMSGA           No. Say not.\n         MVC   LINE(40),=C'Table address lies within an LPA region.'\n         B     TESLMSGP           Go send the message.\nTESLMSGA DS    0H\n         MVC   LINE(42),=C'Table address is not within an LPA region.'\nTESLMSGP DS    0H                 Send the message.\n         APUT  LINE,45\n         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.\n*-*-*->>\nTESLEND  DS    0H\n         L     R9,SAVER9W\n         BR    R9\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nCHANGEDL DS    0H                     Say table was in LPALIB so that\n*                                       therefore nothing was changed.\n         ST    R9,SAVER9V\n         TM    LPAFLAG,X'01'          Table was loaded in the LPALIB\n*                                      storage range. Can't change it.\n         BZ    CHANGEEN\n         APUT  MESSAG2E,L'MESSAG2E    Say that table was from LPALIB.\n         APUT  MESSAG2D,L'MESSAG2D    Say that nothing was changed.\nCHANGEEN DS    0H\n         L     R9,SAVER9V\n         BR    R9\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nENTRYDSP DS    0H\n         ST    R9,SAVER9X\n         TM    TIDFLAG,X'03'      PC or PP table?\n         BNZ   ENTRYEXI           Yes. No display here.\n         STM   R14,R1,SAVE1401    Save registers 14 thru 1.\n         MVC   LINE,LINE-1\n         L     R1,NTRYCNT\n         CVD   R1,CVDAREA\n         MVC   LINE+22(10),MASK10\n         ED    LINE+22(10),CVDAREA+3\n         MVC   LINE(24),=C'Non-blank table entries:'\n         MVC   LINE+35(25),=C'(these are the ones used)'\n         APUT  LINE,65\n         MVC   LINE,LINE-1\n         L     R1,BLNKCNT\n         CVD   R1,CVDAREA\n         MVC   LINE+22(10),MASK10\n         ED    LINE+22(10),CVDAREA+3\n         MVC   LINE(24),=C'Perceived blank entries:'\n         MVC   LINE+35(25),=C'(potential for expansion)'\n         APUT  LINE,65\n         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.\nENTRYEXI DS    0H\n         L     R9,SAVER9X\n         BR    R9\nENTRYDEN DS    0H\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n** ---------------------------------------------------------------- **\n**   Here are the rest of the constants for the program.            **\n** ---------------------------------------------------------------- **\nBLKSTRNG DC    XL10'00004040404040404040'\nENDSTRNG DC    XL10'FFFF4040404040404040'\nZEROES8  DC    X'0000000000000000'\nMASK10   DC    XL10'40202020202020202120'\n         DC    C' '\nBLANKS   DC    C'                                            '\nMESSAGET DC    C'TSUB Command - Display/Change USERID Auth Table Entry -\n               - xxxxxxxx'\nMESSAGEU DC    C'---- -------   ------- ------ ------ ---- ----- ----- -\n                 --------'\nMESSAGEC DC    C'  **--------   AFTER MAKING CHANGES   -------**'\nMESSAGED DC    C'  **--- STATE BEFORE MAKING TABLE CHANGES ---**'\nMESSAG1A DC    C'Table XX pointed to by the LWA has length available. H+\n               ex xxxx '\nMESSAG1B DC    C'Table XX pointed to by the LWA has no lengths. Blanks +\n               will delimit.'\nMESSAG1C DC    C'Table XX pointed to by the LWA came from an APF STEPLI+\n               B.'\nMESSAG1D DC    C'Table XX pointed to by the LWA did not come from an AP+\n               F STEPLIB.'\nMESSAG2C DC    C'Command was not invoked APF authorized.'\nMESSAG2D DC    C'Nothing was changed.  '\nMESSAG2E DC    C'Table is in LPALIB, and we will not attempt to alter i+\n               t.'\nMESSAG3A DC    C'Slot      in XX table has been changed to         .'\nMESSAG3B DC    C'Slot      in XX table has been blanked.            '\nMESSAG3C DC    C'                                                      +\n                  '\nMESSAG3D DC    C'Last 8 bytes of table header altered to \" PARMLIB\". '\nMESSAG3E DC    C'LWA size for table    has been changed from Hex xxxx t+\n               o Hex xxxx.'\nMESSAG3F DC    C'LWA size for table    is now Hex xxxx. '\nMESSA11A DC    C'  Supply a table code TT, followed by an action code A-\n               .'\nMESSA11B DC    C'Supply a program name, as the next parameter.   '\nMESSA11C DC    C'Valid table  codes are:  E2, E8, AP, NS, PC, PP. '\nMESSA11D DC    C'Valid action codes are:  R - replace, B - blank, D - d-\n               isplay,'\nMESSA11Z DC    C'  H - header, L - supply full table length, Z - zero t-\n               able length,'\nMESSA11Y DC    C'  S - mark table from STEPLIB, P - mark table from PAR-\n               MLIB,'\nMESSA11X DC    C'  X - display LPA storage ranges, M - supply minimum t-\n               able length.'\nMESSA11E DC    C'Please supply a program name.  '\nMESSA11F DC    C'Full command is in the form TTA, TT=table code, A=acti-\n               on code.'\nMESSA11G DC   C'Please supply slot number to change, and program name.'\nMESSA11I DC    C'If D (display) is followed by a slot number, only that-\n                slot is shown.'\nMESSA11J DC    C'R (replace) requires a slot number, followed by a prog-\n               ram name.'\nMESSA11K DC    C'If D is not followed by a number, then the entire tabl-\n               e is displayed.'\nMESSA11L DC    C'  Instructions to use this program:                  '\nMESSA11M DC    C'  ------------ -- --- ---- -------                   '\nMESSA11N DC    C'B (blank) blanks the slot number given. Higher slots a-\n               re invalidated.'\nMESSA11O DC    C'D does not need APF authorization. All other codes req-\n               uire it.'\nMESSA11P DC    C'TSUB TTA nnn pgmname (nnn optional for D, both require-\n               d for R)'\nMESSA11Q DC    C'Codes: H,L,M,Z,P,S,X do not require extra parameters.'\nMESSA12Q DC    C'Please supply slot number to blank out. BE CAREFUL !'\nMESSAGR0 DC    C'Return Code = 0 '\nMESSAGR4 DC    C'Return Code = 4 '\nMESSAGR8 DC    C'Return Code = 8 '\nMESSAGRC DC    C'Return Code = 12'\nMESSDIAG DC    C'                                            '\nMESSAGEP DC    C'No Parmlib-supplied XX table was found in storage. '\nMESSAGEN DC    C'Supplied character        was not numeric. '\n         SPACE 3\n         LTORG\n         SPACE 3\nCVDAREA  DS    D                   For CVD instruction\nSAVEAPUT DS    2D\nSAVER23  DS    2F                  Save pair of regs R2, R3\nSAVER1A  DS    F                   Save R1 here\nSAVER1B  DS    F                   Save R1 here\nSAVER2A  DS    F                   Save R2 here\nSAVER2B  DS    F                   Save R2 here\nSAVER2C  DS    F                   Save R2 here\nSAVER2D  DS    F                   Save R2 here\nSAVER2E  DS    F                   Save R2 here\nSAVER2F  DS    F                   Save R2 here\nSAVER2G  DS    F                   Save R2 here\nSAVER3A  DS    F                   Save R3 here\nSAVER3B  DS    F                   Save R3 here\nSAVER3C  DS    F                   Save R3 here\nSAVER4A  DS    F                   Save R4 here\nSAVER4B  DS    F                   Save R4 here\nSAVER4C  DS    F                   Save R4 here\nSAVER5A  DS    F                   Save R5 here\nSAVER5B  DS    F                   Save R5 here\nSAVER5C  DS    F                   Save R5 here\nSAVER5D  DS    F                   Save R5 here\nSAVER5E  DS    F                   Save R5 here\nSAVER5F  DS    F                   Save R5 here\nSAVER8A  DS    F                   Save R8 here\nSAVER9A  DS    F                   BAL Register Save Area\nSAVER9B  DS    F                   BAL Register Save Area\nSAVER9C  DS    F                   BAL Register Save Area\nSAVER9D  DS    F                   BAL Register Save Area\nSAVER9E  DS    F                   BAL Register Save Area\nSAVER9F  DS    F                   BAL Register Save Area\nSAVER9G  DS    F                   BAL Register Save Area\nSAVER9H  DS    F                   BAL Register Save Area\nSAVER9I  DS    F                   BAL Register Save Area\nSAVER9J  DS    F                   BAL Register Save Area\nSAVER9K  DS    F                   BAL Register Save Area\nSAVER9L  DS    F                   BAL Register Save Area\nSAVER9M  DS    F                   BAL Register Save Area\nSAVER9N  DS    F                   BAL Register Save Area\nSAVER9O  DS    F                   BAL Register Save Area\nSAVER9P  DS    F                   BAL Register Save Area\nSAVER9Q  DS    F                   BAL Register Save Area\nSAVER9R  DS    F                   BAL Register Save Area\nSAVER9S  DS    F                   BAL Register Save Area\nSAVER9T  DS    F                   BAL Register Save Area\nSAVER9U  DS    F                   BAL Register Save Area\nSAVER9V  DS    F                   BAL Register Save Area\nSAVER9W  DS    F                   BAL Register Save Area\nSAVER9X  DS    F                   BAL Register Save Area\nSAVER9Y  DS    F                   BAL Register Save Area\nCMBUFEND DS    F                   Number of bytes to end of cmd buff\nSAVLSLOT DS    F                   Save place where Key 0 will change\nSLOTBIN  DS    F                   Fullword binary value of slot number\nSLOTNOW  DS    F                   Slot number being searched\nDISPREG  DS    F                   DISPLAY\nCMBUFAD  DS    F                   Command Buffer address\nCHARSTRT DS    F                   Address of first parm character\nCHARCONT DS    F                   Address of next parm character\nCHARSIZE DS    F\nOURSLOT  DS    F                   Address of current slot searched\nFOUNSLOT DS    F\nTABLEND  DS    F                   Estimated or real end addr of table\n* --- >\nTABLSTRT DS    F                   Start address of table\nTABLADDR DS    F                   Store address of current table\nTABLENUM DS    F                   Number of entries in table\nTABLESIZ DS    F                   Size of a table entry\n* --- >\nBLNKCNT  DS    F\nNTRYCNT  DS    F\n* --- >\nOFFSETSV DS    F\nWORKA    DC    D'0'                Work area for CVB\nNUMVSTRT DC    X'00'               Character count of first parm\nNUMCOUTL DC    X'00'               Entered first parm length\nCODEPLAC DS    CL2                 Store entered table code here\nPAD01    DS    CL4                 Filler\nSAVECHAR DS    X\nSAVECH08 DS    X\nMEASFLG  DS    X\nSHBLFLG  DS    X\nOFFFLAG  DS    X                   Are we blanking the last entry?\nOLDFLAG  DS    X                   Old system detected if X'01'\nTIDFLAG  DS    X                   Which table are we handling.\nLPAFLAG  DS    X                   Is the table address in the LPA?\nLPADFLG  DS    X                   Do LPA range display.\nPLATFLG  DS    X                   FCVE or PPVE exist.\nHAVLFLG  DS    X                   Have length of table available\nNSCHFLG  DS    X                   Dealing the 10-byte NS table?\nLWAPFLG  DS    X                   LWAPRMLB flag copied into program\n*              X'80'               LWATAPST TAP came from STEPLIB\n*              X'40'               LWATNSST TNS came from STEPLIB\n*              X'20'               LWATE2ST TE2 came from STEPLIB\n*              X'10'               LWATE8ST TE8 came from STEPLIB\nLWAMFLG  DS    X                   Which tables have a size in the LWA.\n*              X'80'               AP has a size in the LWA.\n*              X'40'               NS has a size in the LWA.\n*              X'20'               E2 has a size in the LWA.\n*              X'10'               E8 has a size in the LWA.\nFLAGZ    DS    X\n*              X'01'               Found a blank entry. End table srch.\n*              X'02'               Parm number is past the end of table\n*              X'04'               Table lengths have been supplied.\nPAD02    DS    CL4                 Filler\nFSTNAME  DC    CL8' '              Entered program name for \"Replace\"\nFSTCOUNT DS    F                   Number of characters in FSTNAME\nFSTCHALF DC    H'0'\nPAD03    DS    CL4                 Filler\nTABENNUM DC    CL10' '\nPAD03A   DS    CL4                 Filler\nFSTFIELD DS    0CL8\nFSTNUME  DC    CL5' '\nFSTNUPAD DC    CL3' '\nFSTNOUNT DS    F                   Number of characters in FSTNAME\nFSTNHALF DC    H'0'\nPAD04    DS    CL4                 Filler\nSLOTSAVE DS    CL10\nPAD05    DS    CL4                 Filler\nSNDNAME  DC    CL8' '\nSNDCOUNT DS    F                   Number of characters in SNDNAME\nSNDCHALF DC    H'0'\nTABCODE  DC    CL8' '              Original OUTLIM character\n         DS    CL7                 PADDING\nDISPHDR  DS    CL16                Table header display area\n         DS    CL1\nHDRADDR  DS    F                   Address of table header\nCMDBCOPY DS    CL252\n         DS    CL128               PADDING\n         DS    0F                  ALIGN ON FULLWORD\nLINEB    DS    C                   LINE-1\nLINE     DS    CL137               Output line area\nLINET    EQU   LINE+7              Indented line\nLINAB    DS    C                   LINE-1\nLINA     DS    CL137               Output line area\nLINAT    EQU   LINA+7              Indented line\nTRTPGMNM DC    X'02020202020202020202020202020202'\n         DC    X'02020202020202020202020202020202'\n         DC    X'02020202020202020202020202020202'\n         DC    X'02020202020202020202020202020202'\n         DC    X'40020202020202020202020202020202'\n         DC    X'02020202020202020202025B02020202'\n         DC    X'02020202020202020202020202020202'\n         DC    X'02020202020202020202027B7C020202'\n         DC    X'02C1C2C3C4C5C6C7C8C9020202020202'\n         DC    X'02D1D2D3D4D5D6D7D8D9020202020202'\n         DC    X'0202E2E3E4E5E6E7E8E9020202020202'\n         DC    X'02020202020202020202020202020202'\n         DC    X'02C1C2C3C4C5C6C7C8C9020202020202'\n         DC    X'02D1D2D3D4D5D6D7D8D9020202020202'\n         DC    X'0202E2E3E4E5E6E7E8E9020202020202'\n         DC    X'02020202020202020202020202020202'\n         SPACE\n         IKJCPPL\n         IKJPSCB\n         CVT      LIST=YES,DSECT=YES\n         IKJTSVT\n         IKJEFLWA\n         END\nEPUTL    TITLE 'PUTLINE FOR FEWER THAN 83 ARGUMENTS IN THE KEY OF C MAJ&\n               OR'\nEPUTL    CSECT                                              *HMD 10/85*\n         LCLB  &XA                                          *HMD 10/85*\n&XA      SETB  1                  SET TO ZERO ON NON/XA     *HMD 10/85*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*  MODULE NAME  . . . . EPUTL\n*\n*  ALIASES  . . . . . . NONE\n*\n*  DATE WRITTEN . . . . 06/85\n*  UPDATED      . . . . 04/88                                  HD APR88\n*\n*  AUTHOR . . . . . . . JIM ELSWORTH\n*  UPDATOR  . . . . . . HOWARD M. DEAN                         HD APR88\n*\n*  ENVIRONMENT  . . . . TSO COMMAND-PROCESSOR\n*\n*  PURPOSE:\n*    ALLOW AN EASY INTERFACE TO PUTLINE ROUTINE\n*\n*\n*  DESCRIPTION:\n*    BUILDS PUTLINE PARAMETER LIST BASED ON INPUT ARGUMENTS.\n*    ISSUES SINGLE LINE PUTLINE.\n*\n*\n*  ATTRIBUTES:\n*    REENTRANT\n*\n*  FEATURES:\n*    WILL RUN UNDER BATCH TMP SINCE PUTLINE USED INSTEAD OF TPUT.\n*\n*  CALLED MODULES:\n*    PUTLINE\n*\n*  ASSUMPTIONS:\n*    CALLED BY A TSO-CP THAT IS OBSERVING STANDARD LINKAGE\n*\n*  ABENDS:\n*    POSSIBLE 0CX IF BAD ARGUEMNTS\n*\n*  CAVEATS:\n*    UNPREDICTABLE RESULTS IF FIRST PROGRAM RUNNING UNDER THIS TCB\n*    DID NOT SAVE (14,12) BEFOR R1 WAS MODIFIED.\n*\n*\n*  INPUT ARGUMENTS:\n*    1)  R1 : ADDRESS OF MESSAGE TEXT\n*    2)  R0 : LENGTH OF MESSAGE TEXT\n*    3) R13 : STANDARD OS SAVE AREA\n*    4) R14 : RETURN ADDRESS\n*    5) R15 : ENTRY ADDRESS\n*\n*               ( CONTINUED ... )\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*\n*  OUTPUT ARGUMENT: RETURN CODE FROM PUTLINE OR\n*\nRCBA     EQU   100                 BAD MESSAGE ADDRESS\nRCBL     EQU   104                 MESSAGE LENGTH <1 OR >MAXMSG\n*\nMAXMSG   EQU   128                 MAXIMUM MESSAGE LENGTH\n*\n*\n*  REGISTERS USED:\n*\nR0       EQU   0                   MESSAGE LENGTH AT ENTRY\nR1       EQU   1                   MESSAGE ADDRESS AT ENTRY\nR2       EQU   2                   WORK\nRMA      EQU   4                   @MESSAGE TEXT\nRML      EQU   5                   MESSAGE LENGTH\nRUPT     EQU   6                   @UPT (USER PROFILE TABLE)\nRECT     EQU   7                   @ECT\nR12      EQU   12                  CSECT BASE\nR13      EQU   13                  @SAVE AREA AND DYNAMIC WORK AREA\nR14      EQU   14                  WORK/LINKAGE\nR15      EQU   15                  WORK/LINKAGE\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         EJECT\n         IKJCPPL\n         EJECT\n         IKJTCB   LIST=YES                                  *HMD 10/85*\n         EJECT                                              *HMD 10/85*\n         CVT      DSECT=YES,LIST=YES                        *HMD 10/85*\n         EJECT\n         IHAPSA   LIST=YES                                     HD APR88\n         EJECT                                                 HD APR88\nPUTLDS   DSECT\n         DS    18F                      OS SAVE AREA\nPUTAAA   EQU   *\nPUTECB   DS    F                        ECB\nPUTIOPL  DS    4F                       IOPLADS\nPUTBLOK  PUTLINE MF=L\nPUTLEN   DS    H                        LENGTH\nPUTZZZ   DS    H                        RESERVED\nPUTMSG   DS    (MAXMSG)C                MESSAGE TEXT AREA\nPUTSIZE  EQU   *-PUTLDS                 SIZE OF PUTLINE PARMS\n         EJECT\n***********************************************************************\n*  SET UP LINKAGE\n***********************************************************************\n         SPACE 1\nEPUTL    CSECT\n         AIF  (NOT &XA).X001                                *HMD 10/85*\nEPUTL    AMODE 31\n.X001    ANOP                                               *HMD 10/85*\n         STM   14,12,12(13)       SAVE CALLERS REGS\n         LR    R12,R15            COPY EPA\n         USING EPUTL,R12          ADDRESSABILITY\n         AIF   (NOT &XA).X002                               *HMD 10/85*\n         GETMAIN RU,              LV=LENGTH                            &\n               LV=PUTSIZE,        STANDARD OS SA PLUS ANY EXTRA        &\n               LOC=RES            RELATIVE TO 16MB LINE\n         AGO   .X003                                        *HMD 10/85*\n.X002    ANOP                                               *HMD 10/85*\n         GETMAIN RU,              LV=LENGTH                            &\n               LV=PUTSIZE         STANDARD OS SA PLUS ANY EXTRA\n.X003    ANOP                                               *HMD 10/85*\n         ST    1,8(13)            OUR SAVE AREA POINTER\n         ST    13,4(1)            POINTER TO CALLERS SAVE AREA\n         LR    13,1               @OUR SAVE AREA\n         USING PUTLDS,R13         MAP SA AND WORK AREA\n         L     R14,4(R13)         POINT TO CALLERS RSA\n         LM    R0,R1,20(R14)      RESTORE REGS CHANGED BY GETMAIN\n         SPACE 2\n***********************************************************************\n*  UNLOAD ARGUMENTS AND VALIDATE WHERE POSSIBLE\n***********************************************************************\n         SPACE 1\n         LA    R15,RCBA                 ASSUME BAD ADDRESS\n         LTR   RMA,R1                   MESSAGE ADDRESS\n         BNP   RETURN                   GOOD ASSUMPTION\n         LA    R15,RCBL                 ASSUME BAD LENGTH\n         LTR   RML,R0                   POSITIVE?\n         BNP   RETURN                   -NO\n         C     RML,=A(MAXMSG)           MORE THAN MAX?\n         BH    RETURN                   -YES\n         SPACE 2\n***********************************************************************\n*  BUILD PARAMETER LIST\n***********************************************************************\n         SPACE 1\n         LA    R15,4(RML)               MESSAGE LENGTH\n         STH   R15,PUTLEN                 PLUS HEADER\n         XC    PUTZZZ,PUTZZZ            CLEAR 2ND HWORD OF RDW\n         BCTR  RML,0                    REDUCE FOR MOVE\n         EX    RML,PUTMOVE\n         EJECT\n***********************************************************************\n*  DIG UP ADDRESS OF UPT AND ECT\n***********************************************************************\n         SPACE 1\n         L     R2,PSATOLD-PSA           @TCB                   HD APR88\n         L     R2,TCBFSA-TCB(R2)        @1ST PROBLEM PGM SAVE AREA\n         L     R2,24(R2)                REG1 THAT WAS PASSED TO CP\n         USING CPPL,R2                  MAP CPPL\n         L     RUPT,CPPLUPT             @UPT\n         L     RECT,CPPLECT             @ECT\n         SPACE 2\n***********************************************************************\n*  ISSUE PUTLINE CALL\n***********************************************************************\n         SPACE 1\n         XC    PUTECB,PUTECB            CLEAR ECB\n         XC    PUTBLOK(12),PUTBLOK      CLEAR PARM BLOCK       HD APR88\n         PUTLINE PARM=PUTBLOK,          PARAMETER BLOCK                &\n               UPT=(RUPT),              @UPT                           &\n               ECT=(RECT),              @ECT                           &\n               ECB=PUTECB,              @ECB                           &\n               OUTPUT=(PUTLEN,TERM,SINGLE,DATA),                       &\n               MF=(E,PUTIOPL)\n         EJECT\n***********************************************************************\n*  RETURN TO CALLER\n***********************************************************************\n         SPACE 1\nRETURN   EQU   *\n         LR    2,R13                    @OUR SAVE AREA\n         LR    3,R15                    SAVE RETURN CODE\n         L     R13,4(R13)               @CALLERS SAVE AREA\n         FREEMAIN RU,LV=PUTSIZE,A=(R2),SP=0\n         LR    R15,3                    RESTORE RC\n         RETURN (14,12),RC=(15)         RESTORE CALLERS REGS\n         SPACE 5\n***********************************************************************\n*  CONSTANTS AND NON-REENTRANT WORK AREAS\n***********************************************************************\n         SPACE 1\nPUTMOVE  MVC   PUTMSG(*-*),0(RMA)       MOVE MESSAGE TO BUFFER\n         SPACE 2\n         LTORG\n         SPACE 2\n         END   EPUTL\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT185/FILE185.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT185", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}